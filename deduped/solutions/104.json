[{"problem":104,"code":"(fn roman [arabic]\n  (letfn [(recurse [r a] (str r (roman (- arabic a))))]\n    (cond (>= arabic 1000) (recurse \"M\" 1000)\n          (>= arabic 900) (recurse \"CM\" 900)\n          (>= arabic 500) (recurse \"D\" 500)\n          (>= arabic 100) (recurse \"C\" 100)\n          (>= arabic 90) (recurse \"XC\" 90)\n          (>= arabic 40) (recurse \"XL\" 40)\n          (>= arabic 10) (recurse \"X\" 10)\n          (>= arabic 9) (recurse \"IX\" 9)\n          (>= arabic 5) (recurse \"V\" 5)\n          (>= arabic 4) (recurse \"IV\" 4)\n          (>= arabic 1) (recurse \"I\"  1))))","user":"53acaf1fe4b047364c04445f"},{"code":"(fn __ [roman]\n  (let [table \n         {1000 \"M\" 900 \"CM\" 500 \"D\" 400 \"CD\" \n    \t  100 \"C\" 90 \"XC\" 50 \"L\" 40 \"XL\" \n  \t\t  10 \"X\" 9 \"IX\" 5 \"V\" 4 \"IV\" 1 \"I\" 0 \"\"}]\n    (loop [cur roman final \"\" numerator 0]\n      (if (= 0 cur)\n          final\n          (recur \n           (- cur numerator) \n           (str final (table numerator))\n           (apply (partial max-key identity) \n                 (filter (partial >= (- cur numerator)) (keys table))))))))","problem":104,"user":"4fa719c0e4b081705acca1bf"},{"code":"(fn [n]\n    (loop [n n\n           roman '()]\n      (cond\n       (>= n 1000) (recur (- n 1000) (conj roman \\M))\n       (>= n 900) (recur (- n 900) (concat '(\\M \\C) roman))\n       (>= n 500) (recur (- n 500) (conj roman \\D))\n       (>= n 400) (recur (- n 400) (concat '(\\D \\C) roman))\n       (>= n 100) (recur (- n 100) (conj roman \\C))\n       (>= n 90) (recur (- n 90) (concat '(\\C \\X) roman))\n       (>= n 50) (recur (- n 50) (conj roman \\L))\n       (>= n 40) (recur (- n 40) (concat '(\\L \\X) roman))\n       (>= n 10) (recur (- n 10) (conj roman \\X))\n       (>= n 9) (recur (- n 9) (concat '(\\X \\I) roman))\n       (>= n 5) (recur (- n 5) (conj roman \\V))\n       (>= n 4) (recur (- n 4) (concat '(\\V \\I) roman))\n       (>= n 1) (recur (- n 1) (conj roman \\I))\n       (= n 0) (apply str (reverse roman)))))","problem":104,"user":"50bca033e4b0594b91591c5d"},{"problem":104,"code":"(fn to-roman [n]\n  (letfn [(repeat-str [s n] (apply str (repeat n s)))]\n    (let [coins\n          '((1000 \"M\") (900 \"CM\") (500 \"D\") (400 \"CD\") (100 \"C\") (90 \"XC\") (50 \"L\") (40 \"XL\") (10 \"X\") (9 \"IX\") (5 \"V\") (4 \"IV\") (1 \"I\"))]\n      (second\n       (reduce\n        (fn [[num current-str] [value code]]\n          (let [repetitions (quot num value)]\n            [(- num (* repetitions value)) (str current-str (repeat-str code repetitions))]))\n        [n \"\"] coins)))))","user":"5d9c1226e4b0d3f9b434ad51"},{"problem":104,"code":"(fn k[n]\n   (let [rep (fn[s n] (clojure.string/join(repeat n s)))]\n     (loop [n n\n            out \"\"]\n       (cond\n\n         (>  (quot n 1000) 0) (recur (rem n 1000)(str out (rep \"M\" (quot n 1000)) ))\n         (>  (quot n 100) 0) (recur (rem n 100)(str out (case (quot n 100)\n                                                         1 \"C\"\n                                                         2  \"CC\"\n                                                         3 \"CCC\"\n                                                         4 \"CD\"\n                                                         5 \"D\"\n                                                         6 \"DC\"\n                                                         7 \"DCC\"\n                                                         8 \"DCCC\"\n                                                         9 \"CM\") ))\n         (>  (quot n 10) 0) (recur (rem n 10 )(str out (case (quot n 10)\n                                                         1 \"X\"\n                                                         2  \"XX\"\n                                                         3 \"XXX\"\n                                                         4 \"XL\"\n                                                         5 \"L\"\n                                                         6 \"LX\"\n                                                         7 \"LXX\"\n                                                         8 \"LXXX\"\n                                                         9 \"XC\") ))\n         (< n 10) (str out (case n\n                             0 \"\"\n                             1 \"I\"\n                             2 \"II\"\n                             3 \"III\"\n                             4 \"IV\"\n                             5 \"V\"\n                             6 \"VI\"\n                             7 \"VII\"\n                             8 \"VIII\"\n                             9 \"IX\"))\n         ))))","user":"5d0cf1c8e4b0cc9c91588246"},{"code":"(fn [s]\n  (let [digits (map #(- (int %) 48) (str s))\n        digits-indexed (clojure.core/reverse (map list (clojure.core/reverse digits) (range)))\n        parts (filter #(< 0 %) (map #(* (first %) (int (Math/pow 10 (second %)))) digits-indexed))\n        tr (fn g [n]\n   (let [ml '([\\I 1] [\\V 5] [\\X 10] [\\L 50] [\\C 100] [\\D 500] [\\M 1000])\n         numbs (map second ml)\n         m (apply hash-map (apply concat ml))\n         mi (clojure.set/map-invert m)\n         st (last (take-while #(<= % n) numbs))\n         minuend (some #(if (< n %) %) numbs)\n         subtrs [1000 100 10 1]\n         subtr (some #(if (= minuend (+ n %)) %) subtrs)]\n     (cond  (not= nil subtr)\n            (str (mi subtr) (mi minuend))\n            (some #(= % n) numbs)\n            (apply str (repeat (quot n st) (mi st)))\n            true\n            (str (mi st) (g (- n st))))))]\n    (apply str (map tr parts))))","problem":104,"user":"4fa30027e4b081705acca187"},{"problem":104,"code":"(fn f [n]\n   (let [triads [[\\X \\V \\I]\n                 [\\C \\L \\X]\n                 [\\M \\D \\C]\n                 [\\- \\- \\M]]\n         to-digits (fn [n]\n                     (loop [n n\n                            res []]\n                       (if (zero? n) res\n                           (recur (quot n 10) (conj res (mod n 10))))))\n         rm-to-al (fn [d triad]\n                    (let [[x v i] triad]\n                      (apply str\n                             (nth [[]\n                                   [i]\n                                   [i i]\n                                   [i i i]\n                                   [i v]\n                                   [v]\n                                   [v i]\n                                   [v i i]\n                                   [v i i i]\n                                   [i x]] d))))]\n     (apply str (reverse (map rm-to-al (to-digits n) triads)))))","user":"5e3ef7d4e4b01d43a70e8e2d"},{"code":"(fn [n]\n    (let [numeral-and-pair-values [1000 900 500 400 100 90 50 40 10 9 5 4 1]\n          numeral-and-pairs [\"M\" \"CM\" \"D\" \"CD\" \"C\" \"XC\" \"L\" \"XL\" \"X\" \"IX\" \"V\" \"IV\" \"I\"]]\n        (loop [n n, i 0, digits []]\n            (if (zero? n)\n                (apply str digits)\n                (let [times (quot n (numeral-and-pair-values i))\n                      sub (* times (numeral-and-pair-values i))]\n                    (recur (- n sub) (inc i) (into digits (repeat times (numeral-and-pairs i))))\n                )))))","problem":104,"user":"4df3d4f4535d08e6dec9fe2c"},{"problem":104,"code":"(fn int->roman\n  [n]\n  (let [digit-seq\n        (reverse (map (fn [x] (Integer/parseInt (str x))) (str n)))\n\n        count-digits\n        (count digit-seq)\n\n        roman-map\n        {:single    {:a \"I\"\n                     :b \"V\"\n                     :c \"X\"}\n         :tenth     {:a \"X\"\n                     :b \"L\"\n                     :c \"C\"}\n         :hundreds  {:a \"C\"\n                     :b \"D\"\n                     :c \"M\"}\n         :thousands {:a \"M\"}}\n        \n        what-pattern\n        (fn what-pattern\n          [n group]\n          (cond\n            (= n 0) \"\"\n            (< n 4) (apply str(repeat n (:a (group roman-map))))\n            (= 4 n) (str (:a (group roman-map)) (:b (group roman-map)))\n            (= 5 n) (:b (group roman-map))\n            (= 6 n) (str (:b (group roman-map)) (:a (group roman-map)))\n            (< n 9) (str (:b (group roman-map)) (apply str(repeat (- n 5) (:a (group roman-map)))))\n            (= 9 n) (str (:a (group roman-map)) (:c (group roman-map)))))]\n    (str\n     (if (<= 4 count-digits)\n       (str (what-pattern (nth digit-seq 3) :thousands))\n       \"\") \n     (if (<= 3 count-digits)\n       (str (what-pattern (nth digit-seq 2) :hundreds))\n       \"\")\n     (if (<= 2 count-digits)\n       (str (what-pattern (nth digit-seq 1) :tenth))\n       \"\")\n     (if (<= 1 count-digits)\n       (str (what-pattern (nth digit-seq 0) :single))\n       \"\"))\n\n    ))","user":"5b759ca8e4b047b03b2036d0"},{"problem":104,"code":"(fn rn [n] \n     (let [[v s] (some #(if (<= (first %) n) %) \n                       [[3000 \"MMM\"] [2000 \"MM\"] [1000 \"M\"] [900 \"CM\"]\n                        [500 \"D\"] [400 \"CD\"] [300 \"CCC\"] [200 \"CC\"] [100 \"C\"]\n                        [90 \"XC\"] [50 \"L\"] [40 \"XL\"] [30 \"XXX\"] [20 \"XX\"] [10 \"X\"]\n                        [9 \"IX\"] [5 \"V\"] [4 \"IV\"] [3 \"III\"] [2 \"II\"] [1 \"I\"]]\n                  )]\n        (if (nil? v) \"\"\n            (str s (rn (- n v))))))","user":"559c13c5e4b066d22e731f61"},{"problem":104,"code":"(fn\n  [n]\n  (let [rm '((\"\" \"M\" \"MM\" \"MMM\")\n             (\"\" \"C\" \"CC\" \"CCC\" \"CD\" \"D\" \"DC\" \"DCC\" \"DCCC\" \"CM\")\n             (\"\" \"X\" \"XX\"  \"XXX\" \"XL\" \"L\" \"LX\" \"LXX\" \"LXXX\" \"XC\")\n             (\"\" \"I\" \"II\" \"III\" \"IV\" \"V\" \"VI\" \"VII\" \"VIII\" \"IX\"))]\n    (reduce str (reverse\n                 (map #(nth (nth rm %2) %)\n                      (seq (map #(- (int %) 48) (reverse (str n))))\n                      [3 2 1 0])))))","user":"5893c64ce4b00487982d524b"},{"problem":104,"code":"(fn [n]\n  (let [vals [1000 900 500 400 100 90 50 40 10 9 5 4 1]\n        nums [\"M\" \"CM\" \"D\" \"CD\" \"C\" \"XC\" \"L\" \"XL\" \"X\" \"IX\" \"V\" \"IV\" \"I\"]\n        RN (zipmap vals nums)]\n    (first (reduce\n            (fn [[s x] v]\n              (let [q (quot x v)]\n                (if (> q 0)\n                  [(str s (apply str (repeat q (get RN v))))\n                   (- x (* q v))]\n                  [s x])))\n            [\"\" n] vals))))","user":"53c1b787e4b00fb29b221266"},{"code":"(fn [x]\n  (let [thousands [\"\" \"M\" \"MM\" \"MMM\" \"MMMM\" \"MMMMM\" \"MMMMMM\" \"MMMMMMM\" \"MMMMMMMM\" \"MMMMMMMMM\"]\n        hundreds [\"\" \"C\" \"CC\" \"CCC\" \"CD\" \"D\" \"DC\" \"DCC\" \"DCCC\" \"CM\"]\n        tens [\"\" \"X\" \"XX\" \"XXX\" \"XL\" \"L\" \"LX\" \"LXX\" \"LXXX\" \"XC\"]\n        ones [\"\" \"I\" \"II\" \"III\" \"IV\" \"V\" \"VI\" \"VII\" \"VIII\" \"IX\"]]\n    (str (thousands (quot x 1000))\n         (hundreds (quot (mod x 1000) 100))\n         (tens (quot (mod (mod x 1000) 100) 10))\n         (ones (mod (mod (mod x 1000) 100) 10)))))","problem":104,"user":"50645e12e4b007509339a58a"},{"code":"(fn [n]\n  (let [R {1000 \"M\"  900 \"CM\" 500 \"D\" 100 \"C\" 90 \"XC\" 50 \"L\" 40 \"XL\"\n                 10 \"X\"  9 \"IX\" 8 \"VIII\" 7 \"VII\"\n                 6 \"VI\" 5 \"V\" 4 \"IV\" 3 \"III\" 2 \"II\" 1 \"I\"}]\n    (letfn [(next [n]\n              (first (filter #(>= n %) (sort > (keys R)))))\n            (rom [n result]\n              (if (= 0 n)\n                result\n                (let [r (next n)]\n                  (rom (- n r) (conj result (R r))))))]\n      (apply str (rom n [])))))","problem":104,"user":"512eb723e4b0b740abc5982b"},{"problem":104,"code":"(fn [n]\n   (->> n\n        str\n        reverse\n        (map-indexed\n          (fn [magnitude x-char]\n            (let [lookup {0 {1 \"I\"\n                             5 \"V\"}\n                          1 {1 \"X\"\n                             5 \"L\"}\n                          2 {1 \"C\"\n                             5 \"D\"}\n                          3 {1 \"M\"}}\n                  numerals (lookup magnitude)\n                  digit (Character/getNumericValue x-char)]\n              (cond\n                (= digit 9) (str (numerals 1) ((lookup (inc magnitude)) 1))\n                (= digit 4) (str (numerals 1) (numerals 5))\n                (= digit 0) \"\"\n                :default (apply str (when (< 5 digit) (numerals 5)) (repeat (mod digit 5) (numerals 1)))))))\n        reverse\n        (apply str)))","user":"554bd33ce4b0a04f7929959a"},{"code":"(fn wnum [n]\n  (let [r (sorted-map-by > 1000 \"M\" 900 \"CM\" 500 \"D\" 400 \"CD\" 100 \"C\"\n                      90 \"XC\" 50 \"L\" 40 \"XL\" 10 \"X\" 9 \"IX\" 5 \"V\" 4 \"IV\" 1 \"I\")       \n        m (some #(when (>= (- n %) 0) %) (keys r))]\n  (when-not (nil? m)\n      (str (r m) (wnum (- n m))))))","problem":104,"user":"4f05ea25535dcb61093f6c02"},{"code":"(fn roman [n]\n  (let [r (fn [n u h f]\n            (apply str (cond \n                      (< n 4) (repeat n u)\n                      (= n 4) (list u h)\n                      (= n 9) (list u f)\n                      :else\n                      (cons h (repeat (- n 5) u)))))]\n        (apply str (r (mod (quot n 1000) 10) \"M\" \"?\" \"!\")\n                (r (mod (quot n 100) 10) \"C\" \"D\" \"M\")\n                (r (mod (quot n 10) 10) \"X\" \"L\" \"C\")\n                (r (mod n 10) \"I\" \"V\" \"X\"))))","problem":104,"user":"52ba43d0e4b07a9af57922cd"},{"problem":104,"code":"(fn[n]\n        (loop [drum [[\"M\" 1000][\"CM\" 900][\"D\" 500][\"CD\" 400][\"C\" 100][\"XC\" 90]\n                     [\"L\" 50][\"XL\" 40] [\"X\" 10][\"IX\" 9][\"V\" 5][\"IV\" 4] [\"I\" 1]]\n               in  n\n               out []]\n          \n          (let [head (first drum)\n                lit (first head)\n                val (second head)]\n\n            (cond\n             (zero? in)\n             (apply str (interpose \"\" out))\n                    \n             :else\n             (if (<= val in)\n               (recur drum (- in val) (conj out lit))\n               (recur (rest drum) in out))))))","user":"57e6f90de4b0bfb2137f5af6"},{"problem":104,"code":"(fn write-roman-numerals [num] (let [digits (fn digits [num ] \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t      (let [r (quot num 10)]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(if(= 0 r)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  [num]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  (conj (digits r) (mod num 10) ))))\n                                       symb [\\I \\V \\X \\L \\C \\D \\M]\n                                       digit-to-string (fn [[low middle high] num]\n                                                         (cond \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t                         (= 1 num) (str low)\n\t\t\t\t\t\t\t\t\t                                           (= 2 num) (str low low )\n\t\t\t\t\t\t\t\t\t                                           (= 3 num) (str low low low)\n\t\t\t\t\t\t\t\t\t                                           (= 4 num) (str low middle)\n\t\t\t\t\t\t\t\t\t                                           (= 5 num) (str middle)\n\t\t\t\t\t\t\t\t\t                                           (= 6 num) (str middle low)\n\t\t\t\t\t\t\t\t\t                                           (= 7 num) (str middle low low)\n\t\t\t\t\t\t\t\t\t                                           (= 8 num) (str middle low low low)\n\t\t\t\t\t\t\t\t\t                                           (= 9 num) (str low high)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t                         :else \"\")\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t                       )\n                                       reduce-func (fn [xs x] (let [pos (:pos xs)\n                                                                    value (:value xs)]\n                                                                { :value (conj (:value xs) (digit-to-string (take 3 (drop (* 2 pos) symb)) x))\n                                                                 :pos (dec  pos)}))]\n                                   (apply str (:value (reduce reduce-func {:value [] :pos (dec (count (digits num)))} (digits num))))))","user":"5df0c6ffe4b093ff717275c2"},{"code":"(fn [n]\n  (let [arabic-numbers {1000 \"M\" 900 \"CM\" 500 \"D\" 400 \"CD\" 100 \"C\" 90 \"XC\" 50 \"L\" 40 \"XL\" 10 \"X\" 9 \"IX\" 5 \"V\" 4 \"IV\" 1 \"I\"}]\n    (loop [rslt \"\" curr-n n values (sort > (keys arabic-numbers))]\n      (if (= curr-n 0)\n        rslt\n        (recur (str rslt\n                    (apply str (repeat (quot curr-n (first values))\n                               (arabic-numbers (first values)))))\n               (- curr-n (* (quot curr-n (first values)) (first values)))\n               (rest values))))))","problem":104,"user":"526f9715e4b03e8d9a4a7372"},{"code":"(fn [n]\n  (let [r (sorted-map 1000 \"M\" 900 \"CM\" 500 \"D\" 400 \"CD\"\n                      100 \"C\" 90 \"XC\" 50 \"L\" 40 \"XL\" 10 \"X\"\n                      9 \"IX\" 5 \"V\" 4 \"IV\" 1 \"I\")]\n    (last (reduce #(let [n (first %), s (last %),\n                         k (key %2), v (val %2)]\n                     (loop [n n, s s]\n                       (if (>= n k)\n                         (recur (- n k) (str s v))\n                         [n s])))         \n                  [n \"\"]\n                  (rseq r)))))","problem":104,"user":"524b0645e4b09eba1c0223bf"},{"problem":104,"code":"; {1 \"I\" 30 \"XXX\" 4 \"IV\" 140 \"CXL\" 827 \"DCCCXXVII\" 3999 \"MMMCMXCIX\" 48 \"XLVIII\"}\n\n(fn roman [n]\n  (loop [n n\n         s \"\"\n         l [[1000 \"M\"]\n            [900  \"CM\"]\n            [500  \"D\"]\n            [400  \"CD\"]\n            [100  \"C\"]\n            [90   \"XC\"]\n            [50   \"L\"]\n            [40   \"XL\"]\n            [10   \"X\"]\n            [9    \"IX\"]\n            [5    \"V\"]\n            [4    \"IV\"]\n            [1    \"I\"]]]\n    (if l\n      (let [[k v] (first l)]\n        (if (>= n k)\n          (recur (- n k) (str s v) l)\n          (recur n s (next l))))\n      s)))","user":"567b39b6e4b05957ce8c61a3"},{"code":"(fn romanize\n  ([int] (romanize int '()))\n  ([int out]\n     (if (zero? int)\n       (apply str (reverse out))\n       (let [numerals {\n                       1 \\I\n                       4 \"IV\"\n                       5 \\V\n                       9 \"IX\"\n                       10 \\X\n                       40 \"XL\"\n                       50 \\L\n                       90 \"XC\"\n                       100 \\C\n                       400 \"CD\"\n                       500 \\D\n                       900 \"CM\"\n                       1000 \\M\n                       }\n             smaller-numerals (filter (partial >= int) (keys numerals))\n             largest (apply max smaller-numerals)]\n         (recur (- int largest) (conj out (numerals largest)))))))","problem":104,"user":"4dbb0f2d535d1e037afb21b1"},{"code":"(fn\n  [n]\n  (let [m (array-map\n         1 \"I\"\n         4 \"IV\"\n         5 \"V\"\n         9 \"IX\"\n         10 \"X\"\n         50 \"L\"\n         40 \"XL\"\n         100 \"C\"\n         90 \"XC\"\n         500 \"D\"\n         900 \"CM\"\n         1000 \"M\")\n        ns (map #(let [v (rem (quot n %) 10)]\n                   (cond\n                    (= % 1000) (repeat v \"M\")\n                    (= % 100) (or (m (* v 100))\n                                  (if (> v 5)\n                                    (cons \"D\" (repeat (- v 5) \"C\"))\n                                    (repeat v \"C\")))\n                    (= % 10) (or (m (* v 10))\n                                (if (> v 5)\n                                  (cons \"L\" (repeat (- v 5) \"X\"))\n                                  (repeat v \"X\")))\n                    (= % 1) (or (m v)\n                               (if (> v 5)\n                                 (cons \"V\" (repeat (- v 5) \"I\"))\n                                 (repeat v \"I\")))))\n                [1000 100 10 1])\n        ]\n    (reduce str (flatten ns))))","problem":104,"user":"51852961e4b0da5a5be3babb"},{"problem":104,"code":"(fn [n]\n  (let [\n    trans (fn [s f t]\n      (let [m (into {} (map vector f t))]\n        (map #(apply str (replace m %)) s)))\n\n    digits [\"\" \"I\" \"II\" \"III\" \"IV\" \"V\" \"VI\" \"VII\" \"VIII\" \"IX\"]\n\n    units #(nth digits %)\n    tens #(nth (trans digits \"IVX\" \"XLC\") %)\n    hundreds #(nth (trans digits \"IVX\" \"CDM\") %)\n    thousands #(apply str (repeat % \\M))]\n\n      (let [digits (reverse (map (comp read-string str) (str n)))]\n        (apply str    \n          (reverse \n            (map #(%1 %2) [units tens hundreds thousands] digits))))))","user":"574dfcb8e4b02ea11479923a"},{"problem":104,"code":"(fn [n]\n  (loop [b [] n n]\n    (if (zero? n)\n      (apply str b)\n      (let [[v r] (some #(if (>= n (first %)) %)  [[1000 \"M\"] [900 \"CM\"]\n   [500  \"D\"] [400 \"CD\"]\n   [100  \"C\"] [90  \"XC\"]\n   [50   \"L\"] [40  \"XL\"]\n   [10   \"X\"] [9   \"IX\"]\n   [5    \"V\"] [4   \"IV\"]\n   [1    \"I\"]])]\n        (recur (conj b r) (- n v))))))","user":"55be39f9e4b01b9910ae2a06"},{"problem":104,"code":"(fn [n]\n    (let [m     [[1000  \"M\"]\n                 [900  \"CM\"]\n                 [500   \"D\"]\n                 [400  \"CD\"]\n                 [100   \"C\"]\n                 [90   \"XC\"]\n                 [50    \"L\"]\n                 [40   \"XL\"]\n                 [10    \"X\"]\n                 [9    \"IX\"]\n                 [5     \"V\"]\n                 [4    \"IV\"]\n                 [1     \"I\"]\n                 ]]\n      (loop [n n\n             s []]\n        (if (zero? n)\n          (apply str s)\n          (let [[v r] (first (filter (fn [[v _]] (<= v n)) m))]\n            (recur (- n v) (concat s [r]))\n            ))))\n    )","user":"52ffb7f2e4b0d8b024fd370b"},{"code":"(fn to-romans [n]\n  (->>\n   ((fn [n ds]\n             (if (zero? n)\n               ds\n               (let [roman-digits { 1 \"I\", 4 \"IV\", 5 \"V\", 9 \"IX\", 10 \"X\", 40 \"XL\", 50 \"L\", 90 \"XC\", 100 \"C\", 500 \"D\", 900 \"CM\" 1000 \"M\"}\n                     digits-sorted (->> roman-digits keys sort reverse)\n                     next-digit (first (filter #(>= n %) digits-sorted))]\n                 (recur (- n next-digit) (cons (->> next-digit roman-digits) ds))))) n '())\n   (reverse)\n   (apply str)))","problem":104,"user":"4ddb696b535d02782fcbe9fa"},{"problem":104,"code":"clojure.pprint/cl-format nil \"~@r\"","user":"5339c105e4b0e30313ee6cae"},{"code":"(fn [n]\n  (let [dec->roman (sorted-map-by > 1 \"I\" 4 \"IV\" 5 \"V\" 9 \"IX\" 10 \"X\"\n                                  40 \"XL\" 50 \"L\" 90 \"XC\" 100 \"C\" 400\n                                  \"CD\" 500 \"D\" 900 \"CM\" 1000 \"M\")]\n    (loop [nums [] rem n]\n      (if (zero? rem)\n        (apply str (map dec->roman nums))\n        (let [u (ffirst (subseq dec->roman >= rem))]\n          (recur (conj nums u) (- rem u)))))))","problem":104,"user":"4dbb0b6c535d1e037afb21b0"},{"code":"(fn [x]\n   (let [pairs {1 \\I\n    4 \"IV\"\n    5 \\V\n    9 \"IX\"\n    10 \\X\n    40 \"XL\"\n    50 \\L\n    90 \"XC\"\n    100 \\C\n    400 \"CD\"\n    500 \\D\n    900 \"CM\"\n    1000 \\M}\n         nums (reverse (sort (map first pairs)))]\n     (loop [st \"\" num x]\n       (if (= num 0)\n         st\n         (let [b (some #(if (<= % num) % nil) nums)]\n           (println st)\n           (println b)\n           (recur (str st (pairs b))\n                  (- num b))))))\n   )","problem":104,"user":"4eb02674535d7eef30807338"},{"problem":104,"code":"(fn gen-roman [n]\n    (apply str\n           (second\n            (reduce\n             (fn [[total v] [t-str t-val]]\n               (let [append-n (quot total t-val)]\n                 [(- total\n                     (* append-n t-val))\n                  (into v\n                        (repeat append-n t-str))]))\n             [n []]\n             (sort-by second > {\"I\" 1\n                                \"IV\" 4\n                                \"V\" 5\n                                \"IX\" 9\n                                \"X\" 10\n                                \"XL\" 40\n                                \"L\" 50\n                                \"XC\" 90\n                                \"C\" 100\n                                \"CD\" 400\n                                \"D\" 500\n                                \"CM\" 900\n                                \"M\" 1000})))))","user":"54246fcce4b01498b1a71aed"},{"code":"(fn [n]\r\n        (let [cs (loop [ret [] n n]\r\n                (cond (>= n 1000) (recur (conj ret \"M\")  (- n 1000))\r\n                      (>= n  900) (recur (conj ret \"CM\") (- n  900))\r\n                      (>= n  500) (recur (conj ret \"D\")  (- n  500))\r\n                      (>= n  100) (recur (conj ret \"C\")  (- n  100))\r\n                      (>= n   90) (recur (conj ret \"XC\") (- n   90))\r\n                      (>= n   40) (recur (conj ret \"XL\") (- n   40))\r\n                      (>= n   10) (recur (conj ret \"X\")  (- n   10))\r\n                      (>= n    9) (recur (conj ret \"IX\") (- n    9))\r\n                      (>= n    5) (recur (conj ret \"V\")  (- n    5))\r\n                      (>= n    4) (recur (conj ret \"IV\") (- n    4))\r\n                      (>= n    1) (recur (conj ret \"I\")  (- n    1))\r\n                      :else ret))]\r\n                (apply str cs)))","problem":104,"user":"506fd0afe4b07bd6ad9b9f23"},{"problem":104,"code":"(fn to-roman\n([n] (to-roman n []))\n([n s]\n    (let [ones   (clojure.string/split \"0 I II III IV V VI VII VIII IX\" #\" \")\n          tens   (clojure.string/split \"0 X XX XXX XL L LX LXX LXXX XC\" #\" \")\n          hund   (clojure.string/split \"0 C CC CCC CD D DC DCC DCCC CM\" #\" \") ]\n    ;(println \"to-roman\" n s)\n    (cond (zero?   n) (clojure.string/join s)\n          (>= n 1000) (recur (- n 1000) (conj s \"M\"))\n          (>= n 100 ) (let [h (quot n 100)]\n                        (recur (- n (* 100 h)) (conj s (hund h))))\n          (>= n 10  ) (let [t (quot n 10) ]\n                        (recur (- n (* 10 t)) (conj s (tens t))))\n          (>= n 1   ) (clojure.string/join (conj s (ones n))) ))\n        ))","user":"5eff6c0ee4b0cf489e8d7f11"},{"code":"(fn [x]\n  (let [m [[1000 \"M\"] [900 \"CM\"] [500 \"D\"] [400 \"DM\"] [100 \"C\"]\n           [90 \"XC\"] [50 \"L\"] [40 \"XL\"] [10 \"X\"]\n           [9 \"IX\"] [5 \"V\"] [4 \"IV\"] [1 \"I\"]]]\n    (loop [x x s \"\"]\n      (if (< x 1)\n        s\n        (let [i (first (filter #(<= (first %) x) m))]\n          (recur (- x (first i)) (str s (last i))))))))","problem":104,"user":"528652fbe4b0239c8a67ae14"},{"code":"(let [table (sorted-map\n             1000 \"M\"\n             900 \"CM\"\n             500 \"D\"\n             400 \"CD\"\n             100 \"C\"\n             90 \"XC\"\n             50 \"L\"\n             40 \"XL\"\n             10 \"X\"\n             9 \"IX\"\n             5 \"V\"\n             4 \"IV\"\n             1 \"I\")]\n  (fn [n]\n    (loop [i n acc \"\"]\n      (if (zero? i)\n        acc\n        (let [[x y] (first (rsubseq table <= i))]\n          (recur (- i x) (str acc y)))))))","problem":104,"user":"4ec7fa6e535d6d7199dd36ee"},{"code":"(fn write-roman-numerals[num]\n     (let[roman-number-map {\"I\" 1 \"IV\" 4 \"V\" 5 \"IX\" 9 \n                            \"X\" 10 \"XL\" 40 \"L\" 50 \"XC\" 90 \n                            \"C\" 100 \"CD\" 400 \"D\" 500  \"CM\" 900 \"M\" 1000}]\n       (letfn[(step \n                [n]\n                (if-not(zero? n)\n                  (let[k (last (sort #(<(second %1) (second %2)) (filter #(<= (second %)  n) roman-number-map)))\n                       q (quot n (second k))\n                       r (rem n (second k))]\n                    (lazy-cat (map (fn[_] (first k)) (range q))\n                              (step r)))))]\n         (apply str (step num)))))","problem":104,"user":"5273562ae4b03e8d9a4a7479"},{"code":"(fn [n]\n  (let [m {1 \"I\" 4 \"IV\" 5 \"V\" 9 \"IX\" 10 \"X\"\n           40 \"XL\" 50 \"L\" 90 \"XC\" 100 \"C\"\n           400 \"CD\" 500 \"D\" 900 \"CM\" 1000 \"M\"}\n        a (sort > (keys m))]\n    (letfn [(slice [n [a & arest :as alpha] out]\n      (if (and (pos? n) alpha)\n        (if (>= n a)\n          (recur (- n a) alpha (conj out a))\n          (recur n arest out))\n        out))]\n      (apply str (map m (slice n a []))))))","problem":104,"user":"4f4ba29ae4b03ad3f0c10c7a"},{"problem":104,"code":"(fn [input]\n  (let [decimal->roman-pairs [[1000 \"M\"]\n   \t\t\t\t\t\t\t  [900  \"CM\"]\n   \t\t\t\t\t\t\t  [500  \"D\"]\n   \t\t\t\t\t\t\t  [400  \"CD\"]\n   \t\t\t\t\t\t\t  [100  \"C\"]\n   \t\t\t\t\t\t\t  [90   \"XC\"]\n   \t\t\t\t\t\t\t  [50   \"L\"]\n   \t\t\t\t\t\t\t  [40   \"XL\"]\n   \t\t\t\t\t\t\t  [10   \"X\"]\n   \t\t\t\t\t\t\t  [9    \"IX\"]\n   \t\t\t\t\t\t\t  [5    \"V\"]\n   \t\t\t\t\t\t\t  [4    \"IV\"]\n   \t\t\t\t\t\t\t  [1    \"I\"]]]\n  \t(loop [[[k v] & xs :as pairs] decimal->roman-pairs\n    \t    n                     input\n        \tacc                   []]\n   \t (if (zero? n)\n    \t  (apply str acc)\n      \t(if (>= n k)\n        \t(recur pairs (- n k) (conj acc v))\n       \t (recur xs    n       acc))))))","user":"5dc88a38e4b02f9375f4e1db"},{"problem":104,"code":"(fn [x] \n       (letfn [(get-numeral [value one five ten] (cond (< value 4) (apply str (take value (repeat one)))\n                                         (= value 4) (str one five)\n                                         (< value 9) (str five (apply str (take (- value 5) (repeat one))))\n                                         (= value 9) (str one ten)))]\n         (apply str (reverse (map-indexed \n                      #(cond (= %1 0) (get-numeral (read-string %2) \"I\" \"V\" \"X\")\n                             (= %1 1) (get-numeral (read-string %2) \"X\" \"L\" \"C\")\n                             (= %1 2) (get-numeral (read-string %2) \"C\" \"D\" \"M\")\n                             (= %1 3) (get-numeral (read-string %2) \"M\" \"NA\" \"NA\")\n                             :else \"\"\n            \n           ) (reverse (re-seq #\"\\d\" (str x))))))))","user":"5654cb2de4b0f9d632dd848b"},{"problem":104,"code":"(fn int2roman [n]\n    (let [rm (sorted-map 1 \"I\" 4 \"IV\" 5 \"V\"\n                         9 \"IX\" 10 \"X\" 40 \"XL\"\n                         50 \"L\" 90 \"XC\" 100 \"C\"\n                         500 \"D\" 900 \"CM\" 1000 \"M\")\n          largest-in (fn [n]\n                       (last (filter #(<= % n) (keys rm))))\n          ]\n      (if (contains? rm n)\n        (rm n)\n        (let [nn (largest-in n)]\n          (str (rm nn) (int2roman (- n nn)))))))","user":"54965534e4b0b312c081ff65"},{"code":"(fn [n]\n  (let [r [[1000 \"M\"] [900 \"CM\"] [500 \"D\"] [400 \"CD\"] [100 \"C\"] [90 \"XC\"] [50 \"L\"] [40 \"XL\"] [10 \"X\"] [9 \"IX\"] [5 \"V\"] [4 \"IV\"] [1 \"I\"]]]\n    (first (reduce (fn [[acc n] r]\n              [(str acc (apply str (repeat (quot n (first r)) (last r)))) (rem n (first r))])\n            [\"\" n]\n            r))))","problem":104,"user":"4f9f7daae4b0dcca54ed6d37"},{"problem":104,"code":"(fn [n]\n(let [m [[1000 \"M\"] [900 \"CM\"] [500 \"D\"] [400 \"CD\"] [100 \"C\"] [90 \"XC\"] [50 \"L\"] [40 \"XL\"] [10 \"X\"] [9 \"IX\"] [5 \"V\"] [4 \"IV\"] [1 \"I\"]]]\n(loop [i n [[v s] & mm :as m] m c []]\n(cond (zero? i) (apply str c) (> v i) (recur i mm c) :e (recur (- i v) m (conj c s))))))","user":"5fd10010e4b07e53c2f3f02a"},{"problem":104,"code":"(fn [n] (->> ((fn [number] (->> (str number)\n                                 seq\n                                 (map (comp int bigint str))\n                                 reverse)) n)\n              (map (zipmap (range 10) [[] [1] [1 1] [1 1 1] [1 5] [5] [5 1] [5 1 1] [5 1 1 1] [1 10]]))\n              (map (fn [p d] (map p d)) [{1 \\I 5 \\V 10 \\X}\n                                         {1 \\X 5 \\L 10 \\C}\n                                         {1 \\C 5 \\D 10 \\M}\n                                         {1 \\M}])\n              reverse\n              flatten\n              (apply str)))","user":"54db3d82e4b024c67c0cf75f"},{"problem":104,"code":"(fn [n] (let [dic {1 \"I\" 4 \"IV\" 5 \"V\" 9 \"IX\" 10 \"X\" 40 \"XL\" 50 \"L\" 90 \"XC\" 100 \"C\" 400 \"CD\" 500 \"D\" 900 \"CM\" 1000 \"M\"}\n                        o [1000 900 500 400 100 90 50 40 10 9 5 4 1]]\n                    (loop [n n o o r []]\n                      (if (first o)\n                        \n                        (let [dig (first o) m (quot n dig) remind (- n (* m dig)) c (repeat m (get dic dig))]\n                          (recur remind (next o) (conj r c)))\n                        (apply str (apply concat r))))))","user":"5b924123e4b0c0b3ffbd4a34"},{"code":"(fn arabic->roman [n]\n  (let [ subs [\n                 [1000 \"M\"]\n                 [900 \"CM\"]\n                 [500 \"D\"]\n                 [400 \"CD\"]\n                 [100 \"C\"]\n                 [90 \"XC\"]\n                 [50 \"L\"]\n                 [40 \"XL\"]\n                 [10 \"X\"]\n                 [9 \"IX\"]\n                 [5 \"V\"]\n                 [4 \"IV\"]\n                 [1 \"I\"]]\n         reducto (fn reducto [n lst]\n                  (if-let [[lim symb] (first lst)]\n                   (if (<= lim n)\n                    (cons symb (reducto (- n lim) lst))\n                    (recur n (rest lst))))) ]\n   \n   (apply str (reducto n subs))))","problem":104,"user":"4e356d2b535deb9a81d77f2d"},{"code":"(fn roman-number\n  ([n]    (roman-number \"\" n))\n  ([s n]  (let [numerals [{ :value 1000, :chars \"M\" }\n                          { :value 900,  :chars \"CM\"}\n                          { :value 500,  :chars \"D\" }\n                          { :value 400,  :chars \"CD\"}\n                          { :value 100,  :chars \"C\" }\n                          { :value 90,   :chars \"XC\"}\n                          { :value 50,   :chars \"L\" }\n                          { :value 40,   :chars \"XL\"}\n                          { :value 10,   :chars \"X\" }\n                          { :value 9,    :chars \"IX\"}\n                          { :value 5,    :chars \"V\" }\n                          { :value 4,    :chars \"IV\"}\n                          { :value 1,    :chars \"I\" }]]\n            (cond\n             (zero? n) s\n             :else (let [d (first (filter #(<= (:value %) n) numerals))]\n                     (roman-number (str s (:chars d)) (- n (:value d))))))))","problem":104,"user":"530bf87ee4b02e82168697d5"},{"code":"#((fn s \n    [i [[v d] & r :as n]]\n    (cond\n     (= 0 i) \"\"\n     (< i v) (s i r)\n     :else (str d (s (- i v) n))))\n  % (rseq \n     (sorted-map \n      1000 \\M 900 \"CM\" 500 \\D 400 \"CD\" 100 \\C 90 \"XC\"\n      50 \\L 40 \"XL\" 10 \\X 9 \"IX\" 5 \\V 4 \"IV\" 1 \\I)))","problem":104,"user":"4e03c616535d04ed9115e796"},{"problem":104,"code":"(fn write-roman [n]\n  (let [roman-num [\"M\" \"CM\" \"D\" \"CD\" \"C\" \"XC\" \"L\" \"XL\" \"X\" \"IX\" \"V\" \"IV\" \"I\"]\n        quots (rest (reductions (fn [[_ num] div]\n                                  ((juxt quot rem) num div))\n                                [0 n] [1000 900 500 400 100 90 50 40 10 9 5 4 1]))]\n    (->>\n     (map (fn [x [y1 y2]] (vector x y1)) roman-num quots)\n     (mapcat (fn [[x y]] (repeat y x)))\n     (apply str))))","user":"505d1b01e4b0e6aca564be04"},{"code":"(fn [x] (letfn [\n(invert-map [m] (apply hash-map (flatten (map reverse (seq m)))))\n(roman-to-arabic []\n\t{\n  \t\t\"M\" 1000,\n  \t\t\"CM\" 900,\n  \t\t\"D\" 500,\n  \t\t\"CD\" 400,\n  \t\t\"C\" 100,\n  \t\t\"XC\" 90,\n  \t\t\"L\" 50,\n  \t\t\"XL\" 40,\n  \t\t\"X\" 10,\n  \t\t\"IX\" 9,\n  \t\t\"V\" 5,\n  \t\t\"IV\" 4,\n  \t\t\"I\" 1\n  \t}\n)\n(arabic-to-roman [] (invert-map (roman-to-arabic)))\n(descending-arabic-values [] (reverse (keys (into (sorted-map) (arabic-to-roman)))))\n(read-roman-numerals [x]\n  (let [val-map\n  \t{\n  \t\t\"M\" 1000,\n  \t\t\"CM\" 900,\n  \t\t\"D\" 500,\n  \t\t\"CD\" 400,\n  \t\t\"C\" 100,\n  \t\t\"XC\" 90,\n  \t\t\"L\" 50,\n  \t\t\"XL\" 40,\n  \t\t\"X\" 10,\n  \t\t\"IX\" 9,\n  \t\t\"V\" 5,\n  \t\t\"IV\" 4,\n  \t\t\"I\" 1}\n        roman-re #\"(?:C?M)|(?:C?D)|(?:X?C)|(?:X?L)|(?:I?X)|(?:I?V)|(?:I)\"]\n    (reduce + (map val-map (re-seq roman-re x)))))\n(write-roman-numerals\n\t([n] (apply str (flatten (write-roman-numerals n (descending-arabic-values)))))\n\t([n values]\n\t\t(cond\n\t\t\t(empty? values)\n\t\t\t[]\n\t\t\t(zero? n)\n\t\t\t[]\n\t\t\t(zero? (quot n (first values)))\n\t\t\t(write-roman-numerals (rem n (first values)) (rest values))\n\t\t\t:else\n\t\t\t(cons\n\t\t\t\t(repeat (quot n (first values)) (get (arabic-to-roman) (first values)))\n\t\t\t\t(write-roman-numerals (rem n (first values)) (rest values))\n\t\t\t)\n\t\t)\n\t)\n)\n] (write-roman-numerals x)))","problem":104,"user":"52f10094e4b05e3f0be25ee8"},{"problem":104,"code":"(fn foo [x]\n  (let\n    [numerals [1 5 10 50 100 500 1000 5000]\n     numerals-map {1 \"I\" 5 \"V\" 10 \"X\" 50 \"L\" 100 \"C\" 500 \"D\" 1000 \"M\" 5000 \":-(\"}\n     minuends [100 10 1]]\n    (loop [x x\n           str-so-far \"\"]\n      (if\n        (>= 0 x)\n        str-so-far\n        (let\n          [biggest (first (filter #(<= % x) (reverse numerals)) )\n           next-possible (first (filter #(> % biggest) numerals))\n           possible-minuend (first (filter #(< % next-possible) minuends))]\n          (if\n            (>= x (- next-possible possible-minuend))\n            (recur\n              (- x (- next-possible possible-minuend)  )\n              (str str-so-far (numerals-map possible-minuend) (numerals-map next-possible)))\n            (recur\n              (- x biggest)\n              (str str-so-far (numerals-map biggest)))))))))","user":"54f904c2e4b01ecee9d88832"},{"code":"#(loop [s (reverse \n                  [[1 \"I\"], [4 \"IV\"], [5 \"V\"], [9 \"IX\"], [10 \"X\"], [40 \"XL\"], [50 \"L\"], [90 \"XC\"], [100 \"C\"], [400 \"CD\"], [500 \"D\"], [900 \"CM\"], [1000 \"M\"]])\n        [h & t] s, r %, res \"\"]\n   (if h (let [x (- r (first h))] \n(if (>= x 0) (recur s s x (.concat res (last h))) (recur t t r res))) res))","problem":104,"user":"4eabb245535d7eef30807319"},{"problem":104,"code":"(fn write-roman [n]\n  (loop [val n roman \"\"]\n    (cond \n      (> val 999) (recur (- val 1000) (str roman \"M\"))\n      (> val 899) (recur (- val 900) (str roman \"CM\"))\n      (> val 499) (recur (- val 500) (str roman \"D\"))\n      (> val 399) (recur (- val 400) (str roman \"CD\"))\n      (> val 99) (recur (- val 100) (str roman \"C\"))\n      (> val 89) (recur (- val 90) (str roman \"XC\"))\n      (> val 49) (recur (- val 50) (str roman \"L\"))\n      (> val 39) (recur (- val 40) (str roman \"XL\"))\n      (> val 9) (recur (- val 10) (str roman \"X\"))\n      (> val 8) (recur (- val 9) (str roman \"IX\"))\n      (> val 4) (recur (- val 5) (str roman \"V\"))\n      (> val 3) (recur (- val 4) (str roman \"IV\"))\n      (> val 0) (recur (- val 1) (str roman \"I\"))\n      :otherwise roman\n      )\n    )\n  )","user":"5592bf9fe4b0c79f6e1db933"},{"code":"(fn [n]\n (letfn [(f [m]\n           (cond (>= m 1000) [\"M\" (- m 1000)]\n                 (>= m 900) [\"CM\" (- m 900)]\n                 (>= m 500) [\"D\" (- m 500)]\n                 (>= m 400) [\"CD\" (- m 400)]\n                 (>= m 100) [\"C\" (- m 100)]\n                 (>= m 90) [\"XC\" (- m 90)]\n                 (>= m 50) [\"L\" (- m 50)]\n                 (>= m 40) [\"XL\" (- m 40)]\n                 (>= m 10) [\"X\" (- m 10)]\n                 (= m 9) [\"IX\" (- m 9)]\n                 (>= m 5) [\"V\" (- m 5)]\n                 (= m 4) [\"IV\" (- m 4)]\n                 (>= m 1) [\"I\" (- m 1)]))\n         (g [r s] (if (zero? s) r\n                      (let [[u v] (f s)]\n                        (recur (str r u) v))))]\n (g \"\" n)))","problem":104,"user":"5097b556e4b00ad8bab4e970"},{"problem":104,"code":"(fn f\n  [n]\n  (apply str (condp <= n\n               1000 (cons \"M\" (f (- n 1000)))\n               900 (cons \"CM\" (f (- n 900)))\n               500 (cons \"D\" (f (- n 500)))\n               400 (cons \"CD\" (f (- n 400)))\n               100 (cons \"C\" (f (- n 100)))\n               90 (cons \"XC\" (f (- n 90)))\n               50 (cons \"L\" (f (- n 50)))\n               40 (cons \"XL\" (f (- n 40)))\n               10 (cons \"X\" (f (- n 10)))\n               9 (cons \"IX\" (f (- n 9)))\n               5 (cons \"V\" (f (- n 5)))\n               4 (cons \"IV\" (f (- n 4)))\n               1 (cons \"I\" (f (- n 1)))\n               0 ())))","user":"56bb652ae4b0f26550335953"},{"code":"(fn [n]\n  (let [vals [[1000 \"M\"] [ 900 \"CM\"]\n              [ 500 \"D\"] [ 400 \"CD\"]\n              [ 100 \"C\"] [  90 \"XC\"]\n              [  50 \"L\"] [  40 \"XL\"]\n              [  10 \"X\"] [   9 \"IX\"]\n              [   5 \"V\"] [   4 \"IV\"]\n              [   1 \"I\"]]\n        numerals (fn [nums n]\n                   (if-let [[[val num]] (seq (filter #(>= n (first %)) vals))]\n                     (recur (conj nums num) (- n val))\n                     nums))]\n    (apply str (numerals [] n))))","problem":104,"user":"500d8c49e4b07ccb9a7ddb00"},{"code":"(fn [n]\n  (let [x1000 [\"\" \"M\" \"MM\" \"MMM\" \"MMMM\" \"MMMMM\" \"MMMMMM\" \"MMMMMMM\" \"MMMMMMMM\" \"MMMMMMMMM\"]\n        x100  [\"\" \"C\" \"CC\" \"CCC\" \"CD\" \"D\" \"DC\" \"DCC\" \"DCCC\" \"CM\"]\n        x10   [\"\" \"X\" \"XX\" \"XXX\" \"XL\" \"L\" \"LX\" \"LXX\" \"LXXX\" \"XC\"]\n        x1    [\"\" \"I\" \"II\" \"III\" \"IV\" \"V\" \"VI\" \"VII\" \"VIII\" \"IX\"]\n        q1000 (quot n 1000)\n        r1000 (rem n 1000)\n        q100  (quot r1000 100)\n        r100  (rem r1000 100)\n        q10   (quot r100 10)\n        r10   (rem r100 10)]\n    (str (x1000 q1000) (x100 q100) (x10 q10) (x1 r10))))","problem":104,"user":"52015698e4b0d7096e99ddba"},{"code":"(fn [n] (let [roman [[\"I\" \"II\" \"III\" \"IV\" \"V\" \"VI\" \"VII\" \"VIII\" \"IX\" \"X\"]\n                              [\"X\" \"XX\" \"XXX\" \"XL\" \"L\" \"LX\" \"LXX\" \"LXXX\" \"XC\" \"C\"]\n                              [\"C\" \"CC\" \"CCC\" \"CD\" \"D\" \"DC\" \"DCC\" \"DCCC\" \"CM\" \"M\"]\n                              [\"M\" \"MM\" \"MMM\"]\n                              ]]\n                   (apply str (reverse (map-indexed #(identity (get-in roman [%1 (dec (Integer. (str %2)))])) (reverse (str n)))))\n                   ))","problem":104,"user":"52c1bd29e4b07a9af579236a"},{"problem":104,"code":"(fn to-roman [n]\n  (let [integers [1000 500 100 50 10 5 1]\n        int-to-roman {1000 \"M\" 500 \"D\" 100 \"C\" 50 \"L\" 10 \"X\" 5 \"V\" 1 \"I\"}\n        possible-subtractions #{100 10 1}\n        check-for-sub (fn [a b]\n                        (if (> b 0)\n                          (let [max-sub (reduce max  (filter #(<= % b) possible-subtractions))\n                                adj-b (* max-sub (quot b max-sub))\n                                c (- a adj-b)\n                                sub-exists? (and (contains? possible-subtractions c)\n                                                 (<= (/ 1 10) (/ adj-b a)))]\n                            (if sub-exists?\n                               [adj-b (concat (get int-to-roman c) (get int-to-roman a))]\n                               false))\n                          nil))]\n\n    (loop [n2 n\n           radii integers;(filter #(<= % n2) integers)\n           acc \"\"]\n      (let [radii (filter #(<= % n2) integers)\n            possible-sub (last (filter #(> % n2) integers))\n            has-sub (if possible-sub (check-for-sub possible-sub n2) false)]\n         (if (= n2 0)\n            (apply str acc)\n            (let [n2 (- n2 (if has-sub (first has-sub) (first radii)))] \n              (recur n2 \n                (filter #(<= % n2) radii) \n                (concat acc (if has-sub (second has-sub)\n                                (get int-to-roman (first radii)))))))))))","user":"56f4cedce4b046a417f92063"},{"code":"(fn [n]\n    (let [ribuan (quot n 1000)\n          ratusan (quot (rem n 1000) 100)\n          puluhan (quot (rem n 100) 10)\n          satuan (rem n 10)\n          r? (fn [a f1 b f2 c]\n                      (and (f1 a b) (f2 b c)))]\n        (apply str (concat (repeat ribuan \\M)\n                (cond (= 9 ratusan) (list \\C \\M)\n                      (r? 5 <= ratusan <= 8) (cons \\D (repeat (- ratusan 5) \\C))\n                      (= 4 ratusan) (list \\C \\D)\n                      (r? 1 <= ratusan <= 3) (repeat ratusan \\C))\n                (cond (= 9 puluhan) (list \\X \\C)\n                      (r? 5 <= puluhan <= 8) (cons \\L (repeat (- puluhan 5) \\X))\n                      (= 4 puluhan) (list \\X \\L)\n                      (r? 1 <= puluhan <= 3) (repeat puluhan \\X))\n                (cond (= 9 satuan) (list \\I \\X)\n                      (r? 5 <= satuan <= 8) (cons \\V (repeat (- satuan 5) \\I))\n                      (= 4 satuan) (list \\I \\V)\n                      (r? 1 <= satuan <= 3) (repeat satuan \\I))))))","problem":104,"user":"528a3e14e4b0239c8a67ae72"},{"problem":104,"code":"(fn roman [n]\n  (loop [rn [[1000 \"M\"] [900 \"CM\"] [500 \"D\"] [400 \"CD\"] \n           \t [100 \"C\"]  [90 \"XC\"]  [50 \"L\"]  [40 \"XL\"]\n             [10 \"X\"]   [9 \"IX\"]   [5 \"V\"]   [4 \"IV\"] \n             [1 \"I\"]] \n         i n \n         res \"\"]\n    (if (= i 0)\n      res\n      (let [rr (drop-while (fn [[f s]] (> f i)) rn)\n            [f s] (first rr)]\n        (recur (rest rr) (rem i f) (apply str res (repeat (quot i f) s)))))))","user":"55c0afa5e4b01b9910ae2a27"},{"problem":104,"code":"(fn[x](\n          apply str(flatten(reverse(map-indexed\n                                        (fn[idx itm](\n                                                     case idx\n                                                     (0) (replace [\"\" \"I\" \"II\" \"III\" \"IV\" \"V\" \"VI\" \"VII\" \"VIII\" \"IX\"] [itm])\n                                                     (1) (replace [\"\" \"X\" \"XX\" \"XXX\" \"XL\" \"L\" \"LX\" \"LXX\" \"LXXX\" \"XC\"] [itm])\n                                                     (2) (replace [\"\" \"C\" \"CC\" \"CCC\" \"CD\" \"D\" \"DC\" \"DCC\" \"DCCC\" \"CM\"] [itm])\n                                                     (3) (replace [\"\" \"M\" \"MM\" \"MMM\" \"?\" \"?\" \"?\" \"?\" \"?\" \"?\"] [itm])\n                                                     ))\n                                        (map (fn[c](- (int c) 48)) (reverse(str x))))))\n             ))","user":"56039843e4b04bb52996e1be"},{"problem":104,"code":"(fn [k]\n  (let [Ro\n          {1 \"I\", 4 \"IV\", 5 \"V\", 9 \"IX\", 10 \"X\", 40 \"XL\", 50 \"L\", 90 \"XC\", 100 \"C\", 400 \"CD\", 500 \"D\", 900 \"CM\", 1000 \"M\"}\n        Rokey \n            (reverse (sort (keys Ro)))\n        digits\n          (loop [ret [], nn k]\n            (if (= 0 nn)\n              ret\n              (let [dd (first (drop-while #(< nn %) Rokey))]\n                (recur (conj ret dd) (- nn dd)))))]\n      \n     (apply str (map Ro digits)))\n)","user":"593f95d8e4b069cdc2982be3"},{"code":"(fn [z]\n    (let [m (array-map 1000 \\M,                     \n                        900 \"CM\", 500 \\D, 400 \"CD\", 100 \\C,\n                         90 \"XC\",  50 \\L,  40 \"XL\",  10 \\X, \n                          9 \"IX\",   5 \\V,   4 \"IV\",   1 \\I)]\n      (loop [x z, r \"\"]\n        (let [ch (get m x), xs (filter #(<= %1 x) (keys m)), fxs (first xs)]\n          (cond\n            (not (nil? ch)) (str r ch)                                \n            (not (nil? fxs)) (recur (- x fxs) (str r (get m fxs)))\n            :else r\n          )))))","problem":104,"user":"4f038567535dcb61093f6b0c"},{"code":"(fn to-roman [n]\n  (let [d0 (rem n 10)\n        d1 (rem (quot n 10) 10)\n        d2 (rem (quot n 100) 10)\n        d3 (rem (quot n 1000) 10)]\n    (str\n      (condp = d3\n        1 \"M\"\n        2 \"MM\"\n        3 \"MMM\"\n        \"\")\n      (condp = d2\n        1 \"C\"\n        2 \"CC\"\n        3 \"CCC\"\n        4 \"CD\"\n        5 \"D\"\n        6 \"DC\"\n        7 \"DCC\"\n        8 \"DCCC\"\n        9 \"CM\"\n        \"\")\n      (condp = d1\n        1 \"X\"\n        2 \"XX\"\n        3 \"XXX\"\n        4 \"XL\"\n        5 \"L\"\n        6 \"LX\"\n        7 \"LXX\"\n        8 \"LXXX\"\n        9 \"XC\"\n        \"\")\n      (condp = d0\n        1 \"I\"\n        2 \"II\"\n        3 \"III\"\n        4 \"IV\"\n        5 \"V\"\n        6 \"VI\"\n        7 \"VII\"\n        8 \"VIII\"\n        9 \"IX\"\n        \"\"))))","problem":104,"user":"4dab218f30acd6ed15482a68"},{"problem":104,"code":"(fn numba\n  ([x] (numba x []))\n  ([x result]\n   (cond\n    (and (= x 0)) (apply str result)\n    (and (< x 4)) (numba (- x 1) (conj result \\I))\n    (and (= x 4)) (numba (- x 4) (conj result \\I \\V))\n    (and (< x 9) (>= x 5)) (numba (- x 5) (conj result \\V))\n    (and (< x 10) (>= x 9)) (numba (- x 9) (conj result \\I \\X))\n    (and (< x 40) (>= x 10)) (numba (- x 10) (conj result \\X))\n    (and (< x 50) (>= x 40)) (numba (- x 40) (conj result \\X \\L))\n    (and (< x 90) (>= x 50)) (numba (- x 50) (conj result \\L))\n    (and (< x 100) (>= x 90)) (numba (- x 90) (conj result \\X \\C))\n    (and (< x 400) (>= x 100)) (numba (- x 100) (conj result \\C))\n    (and (< x 500) (>= x 400)) (numba (- x 400) (conj result \\C \\D))\n    (and (< x 900) (>= x 500)) (numba (- x 500) (conj result \\D))\n    (and (< x 1000) (>= x 900)) (numba (- x 900) (conj result \\C \\M))\n    (and (<= x 4000) (>= x 1000)) (numba (- x 1000) (conj result \\M))\n   )\n  )\n)","user":"55357ab5e4b09218d5f44faf"},{"problem":104,"code":"(fn [n]                                                                                                           ((fn convert [nu ss]                                                                                                          (println nu)                                                                                                       \n     (if (== nu 0)                                                                                                      \n       \"\"                                                                                                               \n       (let [[n s] (first ss)]                                                                                          \n         (if (>= nu n)                                                                                                  \n           (.concat s (convert (- nu n) ss))                                                                               \n           (convert nu (rest ss)))))                                                                                       \n  ) n [[1000 \"M\"]                                                                                                          \n       [900 \"CM\"] [800 \"DCCC\"] [700 \"DCC\"] [600 \"DC\"] [500 \"D\"] [400 \"CD\"] [100 \"C\"]                                    \n       [90 \"XC\"]  [80 \"LXXX\"]  [70 \"LXX\"]  [60 \"LX\"]  [50 \"L\"]  [40 \"XL\"]  [10 \"X\"]                                      \n       [9  \"IX\"]  [8  \"VIII\"]  [7  \"VII\"]  [6  \"VI\"]  [5  \"V\"]  [4 \"IV\"]  [1  \"I\"]])                                    \n  )","user":"56d91a53e4b0ea9b8538f7ee"},{"problem":104,"code":"(fn arabic->roman\n  [n] {:pre [(integer? n), (< 0 n 4000)]}\n  (let [\n        ;; The function digits returns the digits of its argument, in decreasing\n        ;; order of significance.\n        digits\n        (fn [n]\n          (loop [n n, acc '()]\n            (if (< n 10)\n              (cons n acc)\n              (recur (int (/ n 10)) (cons (rem n 10) acc)))))\n\n        ;; The function pad adds leading zeroes to a sequence until the sequence\n        ;; is the specified length.\n        pad\n        (fn [n coll]\n          (if (> (count coll) n)\n            coll\n            (concat (repeat (- n (count coll)) 0) coll)))\n\n        ;; In order to adhere to the subtractive principle, we need to keep\n        ;; track of triples [A B C], where A is the Roman numeral for a power of\n        ;; 10, B is the Roman numeral that is five times A, and C is the Roman\n        ;; numeral that is ten times A. We store these triples in a vector, in\n        ;; decreasing order of magnitude.\n        dict\n        [[\\M nil nil] [\\C \\D \\M] [\\X \\L \\C] [\\I \\V \\X]]\n\n        ;; The function digit->roman returns the Roman numeral for a given digit\n        ;; d, when also provided with the triple [a b c] from dict corresponding\n        ;; to the intended magnitude of d.\n        digit->roman\n        (fn [d [a b c]]\n          (cond\n            (zero? d)  \"\"\n            (< 0 d 4)  (apply str (repeat d a))\n            (= d 4)    (str a b)\n            (< 4 d 9)  (apply str b (repeat (- d 5) a))\n            (= d 9)    (str a c)))]\n\n    (apply str (map digit->roman\n                    (->> n digits (pad 4))\n                    dict))))","user":"4fc6305de4b0ee37620e180b"},{"code":"(fn [n]\n  (let [m (partition 2 [1000 \"M\" 900 \"CM\" 500 \"D\" 100 \"C\" 90 \"XC\" 50 \"L\" 40 \"XL\" 10 \"X\" 9 \"IX\" 5 \"V\" 4 \"IV\" 1 \"I\"])]\n    (loop [x n, r \"\"]\n      (if (zero? x) r\n      (let [[a b] (some (fn [[a b]] (when (<= a x) [a b])) m)]\n        (recur (- x a) (str r b)))))))","problem":104,"user":"4e7db3b4535db169f9c796e1"},{"problem":104,"code":"(fn [arg1]\n(cond\n(and (= arg1 1)) \"I\"\n(and (= arg1 30)) \"XXX\"\n(and (= arg1 4)) \"IV\"\n(and (= arg1 140)) \"CXL\"\n(and (= arg1 827)) \"DCCCXXVII\"\n(and (= arg1 3999)) \"MMMCMXCIX\"\n(and (= arg1 48)) \"XLVIII\"\n))","user":"565f2461e4b068f2fe63dc3b"},{"code":"(fn [n]\n  (let [trans {1000 \"M\" 900 \"CM\" 500 \"D\" 400 \"CD\" 100 \"C\" 90 \"XC\" 50 \"L\" 40 \"XL\"  10 \"X\" 9 \"IX\" 5 \"V\" 4 \"IV\" 1 \"I\"}]\n      (->> (reverse (sort (keys trans)))                                    ;; sorted base 1000, 900, 500 ...\n           (reduce #(cons (rem (first %1) %2 )                              ;; keep last rem result in head\n                          (cons [%2 (quot (first %1) %2)] (rest %1))) [n])  ;; append [base,quotient] per base\n           rest reverse                                                     ;; rest remove last rem result (0)\n           (map #(apply str (repeat (% 1) (trans (% 0)))))                  ;; convert [[base,quotient]] to [\"quotient*trans[base]\"]\n           (apply str))))                                                   ;; then join to get final roman number","problem":104,"user":"533ab9abe4b0e30313ee6cbf"},{"code":"(fn [n] (let [num-mapping {1 \"I\" 4 \"IV\" 5 \"V\" 9 \"IX\" 10 \"X\"\n              \t\t\t   40 \"XL\" 50 \"L\" 90 \"XC\" 100 \"C\"\n              \t\t\t\t400 \"CD\" 500 \"D\" 900 \"CM\" 1000 \"M\"}\n              vals-in-order [1000 900 500 400 100 90 50 40 10 9 5 4 1]\n             ] (loop [number n curr (first vals-in-order) values (next vals-in-order) result \"\"]\n                 (println number curr values result)\n                 (cond\n                  (= 0 number) result\n                  (<= 0 (- number curr)) (recur (- number curr) (first vals-in-order) (next vals-in-order) (str result (num-mapping curr)))\n                  :else (recur number (first values) (next values) result)\n                 )\n               )\n        )\n)","problem":104,"user":"526dd90de4b03e8d9a4a72fe"},{"problem":104,"code":"(fn [num] (let [digitized (map #(Character/digit %1 10) (flatten (partition 1 (str num))))\n                  table (take-last (count digitized) [[\"\" \"M\" \"MM\" \"MMM\" \"MMMM\" \"MMMMM\" \"MMMMMM\" \"MMMMMMM\" \"MMMMMMMM\" \"MMMMMMMMM\"]\n                          [\"\" \"C\" \"CC\" \"CCC\" \"CD\" \"D\" \"DC\" \"DCC\" \"DCCC\" \"CM\"]\n                          [\"\" \"X\" \"XX\" \"XXX\" \"XL\" \"L\" \"LX\" \"LXX\" \"LXXX\" \"XC\"]\n                          [\"\" \"I\" \"II\" \"III\" \"IV\" \"V\" \"VI\" \"VII\" \"VIII\" \"IX\"]\n                          ])\n                  ]\n              (clojure.string/join (reduce (fn [a b] (conj a (nth (nth table b) (nth digitized b))))\n                       []\n                       (range (count digitized))))))","user":"567f988be4b0feffd0d18ebe"},{"problem":104,"code":"(fn roman-numbers [n]\n  (if (or (>= 0 n) (<= 4000 n)) \"\"\n      (condp #(>= (- %2 %) 0) n\n        1000 (str \\M (roman-numbers (- n 1000)))\n        900 (str \"CM\" (roman-numbers (- n 900)))\n        500 (str \\D (roman-numbers (- n 500)))\n        400 (str \"CD\" (roman-numbers (- n 400)))\n        100 (str \\C (roman-numbers (- n 100)))\n        90 (str \"XC\" (roman-numbers (- n 90)))\n        50 (str \\L (roman-numbers (- n 50)))\n        40 (str \"XL\" (roman-numbers (- n 40)))\n        10 (str \\X (roman-numbers (- n 10)))\n        9 (str \"IX\" (roman-numbers (- n 9)))\n        5 (str \\V (roman-numbers (- n 5)))\n        4 (str \"IV\" (roman-numbers (- n 4)))\n        1 (str \\I (roman-numbers (- n 1))))))","user":"572ec4dde4b0cd1946bd0f8d"},{"code":"(fn rnum [n]\n  (let [r (sorted-map-by > 1000 \"M\" 900 \"CM\" 500 \"D\" 400 \"CD\" 100 \"C\" 90 \"XC\" 50 \"L\" 40 \"XL\" 10 \"X\" 9 \"IX\" 5 \"V\" 4 \"IV\" 1 \"I\")       \n        m (some #(when (>= (- n %) 0) %) (keys r))]\n  (when-not (nil? m)\n    (str (r m) (rnum (- n m))))))","problem":104,"user":"50705072e4b07bd6ad9b9f27"},{"problem":104,"code":"(fn t92 [value]\n  (loop [n value  r \"\"]\n    (cond\n          (>= n 1000) (recur (- n 1000) (str r \\M))\n          (>= n 900) (recur (- n 900) (str r \"CM\"))\n          (>= n 500) (recur (- n 500) (str r \\D))\n          (>= n 400) (recur (- n 400) (str r \"CD\"))\n          (>= n 100) (recur (- n 100) (str r \"C\"))\n          (>= n 90) (recur (- n 90) (str r \"XC\"))\n          (>= n 50) (recur (- n 50) (str r \"L\"))\n          (>= n 40) (recur (- n 40) (str r \"XL\"))\n          (>= n 10) (recur (- n 10) (str r \"X\"))\n          (>= n 9) (recur (- n 9) (str r \"IX\"))\n          (>= n 5) (recur (- n 5) (str r \"V\"))\n          (>= n 4) (recur (- n 4) (str r \"IV\"))\n          (>= n 1) (recur (- n 1) (str r \"I\"))\n          :else r)))","user":"5046f909e4b03b02161376b5"},{"code":"(fn [n]\n  (when (and (< n 4000) (> n 0))\n    (loop [n n\n           m {1000 \"M\"\n              900  \"CM\"\n              500  \"D\"\n              400  \"CD\"\n              100  \"C\"\n              90   \"XC\"\n              50   \"L\"\n              40   \"XL\"\n              10   \"X\"\n              9    \"IX\"\n              5    \"V\"\n              4    \"IV\"\n              1    \"I\"}\n           [f & d] (reverse (sort (keys m)))\n           r []]\n      (if (zero? n)\n        (apply str (flatten r))\n        (recur (mod n f) m d (conj r (repeat (unchecked-divide-int n f) (m f))))))))","problem":104,"user":"4dda44f2535d02782fcbe9f1"},{"code":"(fn [n]\n  (let [r clojure.string/replace]\n    (-> (loop [s   \"\"\n               n   n\n               x [[1000 \\M]\n                  [ 500 \\D]\n                  [ 100 \\C]\n                  [  50 \\L]\n                  [  10 \\X]\n                  [   5 \\V]\n                  [   1 \\I]]]\n          (if (empty? x)\n            s\n            (let [[d c] (first x)]\n              (recur\n                (str s (apply str (repeat (quot n d) c)))\n                (mod n d)\n                (rest x)))))\n      (r \"DCCCC\" \"CM\")\n      (r  \"CCCC\" \"CD\")\n      (r \"LXXXX\" \"XC\")\n      (r  \"XXXX\" \"XL\")\n      (r \"VIIII\" \"IX\")\n      (r  \"IIII\" \"IV\"))))","problem":104,"user":"51a10b2ce4b0b292b01ee3fe"},{"problem":104,"code":"(fn mywr [n]\n  (let [pow10 #(reduce * 1 (repeat % 10))\n        srep #(apply str (repeat %1 %2))\n        dig #(quot (mod %1 (pow10 (inc %2))) (pow10 %2))\n        r [{1 \\I 5 \\V} {1 \\X 5 \\L} {1 \\C 5 \\D} {1 \\M}]\n        ]\n    (apply str \n           (for [x (reverse (range 4))]\n             (let [d (dig n x) s (r x)]\n               (cond\n                (= d 4) (str (s 1) (s 5))\n                (= d 9) (str (s 1) ((r (inc x)) 1))\n                (>= d 5) (str (s 5) (srep (- d 5) (s 1)))\n                (< d 4) (srep d (s 1))\n                )))\n           )\n    )\n  )","user":"587c59d1e4b01531a375eb17"},{"problem":104,"code":"(fn to-roman\n  ([x]\n   (to-roman x \"\"))\n  ([x so-far]\n   (cond (>= x 1000) (recur (- x 1000) (str so-far \"M\"))\n         (>= x 900)  (recur (- x 900)  (str so-far \"CM\"))\n         (>= x 500)  (recur (- x 500)  (str so-far \"D\"))\n         (>= x 400)  (recur (- x 400)  (str so-far \"CD\"))\n         (>= x 100)  (recur (- x 100)  (str so-far \"C\"))\n         (>= x 90)   (recur (- x 90)   (str so-far \"XC\"))\n         (>= x 50)   (recur (- x 50)   (str so-far \"L\"))\n         (>= x 40)   (recur (- x 40)   (str so-far \"XL\"))\n         (>= x 10)   (recur (- x 10)   (str so-far \"X\"))\n         (>= x 9)    (recur (- x 9)    (str so-far \"IX\"))\n         (>= x 5)    (recur (- x 5)    (str so-far \"V\"))\n         (>= x 4)    (recur (- x 5)    (str so-far \"IV\"))\n         (>= x 1)    (recur (- x 1)    (str so-far \"I\"))\n         :else (str so-far))))","user":"4daeabf6edd6309eace4d15c"},{"code":"(fn nr ([n] (nr n []))\n  ([n s] \n   (condp <= n \n     1000 (nr (- n 1000) (conj s \\M))\n     900 (nr (- n 900) (conj  s \\C \\M))\n     500  (nr (- n 500) (conj s \\D))\n     400 (nr (- n 400) (conj s \\C \\D))\n     100  (nr (- n 100) (conj s \\C))\n     90   (nr (- n 90) (conj s \\X \\C))\n     50   (nr (- n 50) (conj s \\L))\n     40   (nr (- n 40) (conj s \\X \\L))\n     10 (nr (- n 10) (conj s \\X))\n     9  (nr (- n 9) (conj s \\I \\X))\n     5  (nr (- n 5) (conj s \\V))\n     4  (nr (- n 4) (conj s \\I \\V))\n     1  (nr (- n 1) (conj s \\I))\n     (apply str s))))","problem":104,"user":"4eb2eae5535d7eef30807351"},{"code":"(letfn [(f [n [a b c]]\n          (cond\n            (= n 9) (str a c)\n            (= n 5) b\n            (= n 4) (str a b)\n            (> n 5) (str b (apply str (repeat (- n 5) a)))\n            :else (apply str (repeat n a))))]\n  (fn [n] \n    (str\n      (f (quot n 1000) [\\M \\V \\X])\n      (f (quot (rem n 1000) 100) [\\C \\D \\M])\n      (f (quot (rem n 100) 10) [\\X \\L \\C])\n      (f (rem n 10) [\\I \\V \\X]))))","problem":104,"user":"4ef6e689535dced4c769f24f"},{"problem":104,"code":"(fn [n]\n  (let [numerals {1    [\\I \\V] \n                  10   [\\X \\L] \n                  100  [\\C \\D] \n                  1000 [\\M]}]\n    (->>\n      (iterate #(quot % 10) n)\n      (take-while pos?)\n      (map (fn [p x]\n           (let [d (rem x 10)\n                 [n1 n5] (numerals p)\n                 [n10 _] (numerals (* 10 p))]\n             (condp > d\n               4 (repeat d n1)\n               5 [n1 n5]\n               9 (cons n5 (repeat (- d 5) n1))\n               [n1 n10])))\n         (iterate #(* 10 %) 1))\n      reverse flatten (apply str))))","user":"53dfdf01e4b0d874e779ae46"},{"problem":104,"code":"(fn [n] (first (reduce (fn [[r d] [k v]] (if (< d k) [r d] (recur [(str r v) (- d k)] [k v]))) [\"\" n] [[1000 \"M\"] [900 \"CM\"] [500 \"D\"] [400 \"CD\"] [100 \"C\"] [90 \"XC\"] [50 \"L\"] [40 \"XL\"] [10 \"X\"] [9 \"IX\"] [5 \"V\"] [4 \"IV\"] [1 \"I\"]])))","user":"5481be5fe4b0e286459a1172"},{"problem":104,"code":"(fn c [n]\n  (if (zero? n)\n    \"\"\n    (let [numerals {1000 \"M\", 900 \"CM\", 500 \"D\", 400 \"CD\", 100 \"C\", 90 \"XC\", 50 \"L\", 40 \"XL\", 10 \"X\", 9 \"IX\", 5 \"V\", 4 \"IV\", 1 \"I\"}\n          detect (fn [p c] (first (filter p c)))\n          less-than? (fn [x y] (>= x y))\n          [arabic roman] (detect #(less-than? n (first %)) (reverse (into (sorted-set) numerals)))]\n    (str roman (c (- n arabic))))))","user":"4ee7d6d8535d93acb0a66870"},{"problem":104,"code":"(fn\n  [n]\n \n  ((fn acc [\n      remainder       ; Remaining (unrepresented) decimal part of the number\n      roman-rep       ; Roman numeral representation built so far\n    ]\n    (cond\n      (>= remainder 1000) (acc (- remainder 1000) (str roman-rep \"M\" ))\n      (>= remainder  900) (acc (- remainder  900) (str roman-rep \"CM\"))\n      (>= remainder  500) (acc (- remainder  500) (str roman-rep \"D\" ))\n      (>= remainder  400) (acc (- remainder  400) (str roman-rep \"CD\"))\n      (>= remainder  100) (acc (- remainder  100) (str roman-rep \"C\" ))\n      (>= remainder   90) (acc (- remainder   90) (str roman-rep \"XC\"))\n      (>= remainder   50) (acc (- remainder   50) (str roman-rep \"L\" ))\n      (>= remainder   40) (acc (- remainder   40) (str roman-rep \"XL\"))\n      (>= remainder   10) (acc (- remainder   10) (str roman-rep \"X\" ))\n      (>= remainder    9) (acc (- remainder    9) (str roman-rep \"IX\"))\n      (>= remainder    5) (acc (- remainder    5) (str roman-rep \"V\" ))\n      (>= remainder    4) (acc (- remainder    4) (str roman-rep \"IV\"))\n      (>= remainder    1) (acc (- remainder    1) (str roman-rep \"I\" ))\n      :else roman-rep)) n \"\"))","user":"540b851fe4b0addc1aec66f9"},{"code":"(fn wr [x]\n  (cond (>= x 1000) (str \"M\" (wr (- x 1000)))\n        (>= x 900) (str \"CM\" (wr (- x 900)))\n        (>= x 500) (str \"D\" (wr (- x 500)))\n        (>= x 400) (str \"CD\" (wr (- x 400)))\n        (>= x 100) (str \"C\" (wr (- x 100)))\n        (>= x 90) (str \"XC\" (wr (- x 90)))\n        (>= x 50) (str \"L\" (wr (- x 50)))\n        (>= x 40) (str \"XL\" (wr (- x 40)))\n        (>= x 10) (str \"X\" (wr (- x 10)))\n        (>= x 9) (str \"IX\" (wr (- x 9)))\n        (>= x 5) (str \"V\" (wr (- x 5)))\n        (>= x 4) (str \"IV\" (wr (- x 4)))\n        (>= x 1) (str \"I\" (wr (- x 1)))))","problem":104,"user":"52736ca1e4b03e8d9a4a747e"},{"problem":104,"code":"(fn q[n]\n    (if (= n 0)\n      \"\"\n      (let [v {1000 \"M\" 900 \"CM\" 500 \"D\" 400 \"CD\" 100 \"C\" 90 \"XC\" 50 \"L\" 40 \"XL\" 10 \"X\" 9 \"IX\" 5 \"V\" 4 \"IV\" 1 \"I\"} t (apply max (filter     #(<= % n) (keys v)))]\n        (str \n          (v t) \n          (q (- n t)))\n        )\n      )\n    )","user":"54b90836e4b0ed20f4ff6e9d"},{"problem":104,"code":"(fn [n] \n  (let [m { 1000 \"M\", 900 \"CM\", 500 \"D\", 400 \"CD\", 100 \"C\", 90 \"XC\", 50 \"L\", 40 \"XL\", 10 \"X\", 9 \"IX\", 5 \"V\", 4 \"IV\", 1 \"I\"}\n        r (fn [[s n] k]\n            [(apply str s (repeat (quot n k) (get m k)))\n             (rem n k)])]\n    (first (reduce r [\"\" n] (sort > (keys m))))))","user":"5078d366e4b08327cd804a5b"},{"problem":104,"code":"(fn roman [n]\n  (let [s   (map #(Character/digit % 10) (clojure.pprint/cl-format nil \"~4,'0d\" (str n)))\n        tho (zipmap (range 4) '(nil M MM MMM))\n        hun (zipmap (range 10) '(nil C CC CCC CD D DC DCC DCCC CM))\n        ten (zipmap (range 10) '(nil X XX XXX XL L LX LXX LXXX XC))\n        uni (zipmap (range 10) '(nil I II III IV V VI VII VIII IX))\n        m (map vector s [tho hun ten uni])]\n    (->> (map #(val (find (second %) (first %))) m)\n         (filter identity)\n         (map str)\n         (clojure.string/join))))","user":"5e6ca949e4b04a83ad7cd289"},{"code":"(fn roman[i] (apply str (let [a (quot i 1000) b (quot (rem i 1000) 100) c (quot (rem i 100) 10) d (rem i 10)]\n                             (concat (repeat a \"M\")\n                                     (cond (< b 4) (repeat b \"C\")\n                                           (= b 4) [\"C\" \"D\"]\n                                           (= 9 b) [\"CM\"]\n                                           (= b 5) [\"D\"]\n                                           (<= 6 b) [(str \"D\" (apply str (repeat (- b 5) \"C\")))])\n                                     (cond (< c 4) (repeat c \"X\")\n                                           (= c 4) [\"X\" \"L\"]\n                                           (= 9 c) [\"XC\"]\n                                           (= c 5) [\"L\"]\n                                           (<= 6 c) [(str \"L\" (apply str (repeat (- c 5) \"X\")))])\n                                     (cond (< d 4) (repeat d \"I\")\n                                           (= d 4) [\"I\" \"V\"]\n                                           (= 9 d) [\"IX\"]\n                                           (= d 5) [\"V\"]\n                                           (<= 6 d) [(str \"V\" (apply str (repeat (- d 5) \"I\")))])\n                                     ))))","problem":104,"user":"4f0e4ebd535d0136e6c22322"},{"code":"(fn f [n]\n  (let [table {1000 [nil \"M\" \"MM\" \"MMM\"]\n               100 [nil \"C\" \"CC\" \"CCC\" \"CD\" \"D\" \"DC\" \"DCC\" \"DCCC\" \"CM\"]\n               10 [nil \"X\" \"XX\" \"XXX\" \"XL\" \"L\" \"LX\" \"LXX\" \"LXXX\" \"XC\"]\n               1 [nil \"I\" \"II\" \"III\" \"IV\" \"V\" \"VI\" \"VII\" \"VIII\" \"IX\"]}]\n    (->> n\n         str\n         reverse\n         (map (zipmap \"0123456789\" (range)))\n         (map #((table %) %2) [1 10 100 1000])\n         reverse\n         (apply str))))","problem":104,"user":"510db6cde4b078ea71921145"},{"code":"(fn [n]\n  (let [dict [[1000 \"M\"] [900 \"CM\"] [500 \"D\"] [400 \"CD\"] [100 \"C\"] [90 \"XC\"]\n              [50 \"L\"] [40 \"XL\"] [10 \"X\"] [9 \"IX\"] [5 \"V\"] [4 \"IV\"] [1 \"I\"]]]\n    (loop [n   n\n           acc []]\n      (if (zero? n)\n        (apply str acc)\n        (let [[v c] (first (drop-while #(> (first %) n) dict))]\n          (recur (- n v) (conj acc c)))))))","problem":104,"user":"50586354e4b06522596eba78"},{"code":"(let [digits [[1000 \\M] [900 \"CM\"] [500 \\D] [400 \"CD\"]\n              [100 \\C] [90 \"XC\"] [50 \\L] [40 \"XL\"]\n              [10 \\X] [9 \"IX\"] [5 \\V] [4 \"IV\"] [1 \"I\"]]\n      romanizer (fn romanizer\n                  [letters n]\n                  (if (zero? n)\n                    letters\n                    (let [[diff suffix] (some #(and (>= n (first %)) %)\n                                              digits)]\n                      (romanizer (conj letters suffix) (- n diff)))))]\n  (fn romanize\n    [n]\n    (apply str (romanizer [] n))))","problem":104,"user":"51f9527fe4b09be9c177e549"},{"problem":104,"code":"(fn ->roman\n  ([x] (->roman \"\" x))\n  ([s x]\n    (cond\n      (zero? x)           s \n      (>= x 1000) (recur (str s \"M\") (- x 1000))\n      (>= x 900)  (recur (str s \"CM\") (- x 900))\n      (>= x 500)  (recur (str s \"D\") (- x 500))\n      (>= x 400)  (recur (str s \"CD\") (- x 400))\n      (>= x 100)  (recur (str s \"C\") (- x 100))\n      (>= x 90)   (recur (str s \"XC\") (- x 90))\n      (>= x 50)   (recur (str s \"L\") (- x 50))\n      (>= x 40)   (recur (str s \"XL\") (- x 40))\n      (>= x 10)   (recur (str s \"X\") (- x 10))\n      (>= x 9)    (recur (str s \"IX\") (- x 9))\n      (>= x 5)    (recur (str s \"V\") (- x 5))\n      (>= x 4)    (recur (str s \"IV\") (- x 4))\n      :else       (recur (str s \"I\") (- x 1)))))","user":"52761edae4b03e8d9a4a74d4"},{"problem":104,"code":"(fn f [[n & a] [s & b] o i]\n  (if n\n    (f a b (into o (repeat (int (/ i n)) s)) (rem i n))\n    (apply str o)))\n[1000 900 500 400 100 90 50 40 10  9 5  4 1]\n'[  M  CM   D  CD   C XC  L XL  X IX V IV I]\n[]","user":"4db1fe241254ad5b4805fa77"},{"code":"(fn [x]\n  (letfn [(nextnumeral [y]\n            (cond\n                (>= y 1000) [\"M\" (- y 1000)]\n                (>= y 900) [\"CM\" (- y 900)]\n                (>= y 500) [\"D\" (- y 500)]\n                (>= y 400) [\"CD\" (- y 400)]\n                (>= y 100) [\"C\" (- y 100)]\n                (>= y 90) [\"XC\" (- y 90)]\n                (>= y 50) [\"L\" (- y 50)]\n                (>= y 40) [\"XL\" (- y 40)]\n                (>= y 10) [\"X\" (- y 10)]\n                (>= y 9) [\"IX\" (- y 9)]\n                (>= y 5) [\"V\" (- y 5)]\n                (>= y 4) [\"IV\" (- y 4)]\n                (>= y 1) [\"I\" (- y 1)]\n                :else [\"\" 0]))]\n    (loop [numerals [] remainder x]\n      (if (zero? remainder)\n        (apply str numerals)\n        (let [[nextnum remainder] (nextnumeral remainder)]\n          (recur (into numerals nextnum) remainder ))))))","problem":104,"user":"512d3304e4b040332b905b2d"},{"problem":104,"code":"(fn [n]\n    (let [cd (fn [i n]\n               (let [ls (drop (* 2 i) [\\I \\V \\X \\L \\C \\D \\M \\v \\x])\n                     r5 (rem  n 5)]\n                 (clojure.string/join\n                   \"\"\n                   (cond\n                     (= 4 n)    [(first ls) (second ls)]\n                     (= 9 n)    [(first ls) (nth ls 2)]\n                     :else      (reduce conj\n                                        (if (< n 5) [] [(second ls)])\n                                        (repeat r5 (first ls)))))))\n          ds (->> n\n                  str\n                  seq\n                  reverse\n                  (map (comp read-string str))\n                  (map-indexed #(cd %1 %2))\n                  reverse)]\n      (clojure.string/join \"\" ds)))","user":"559a9a3de4b066d22e731f45"},{"problem":104,"code":"(fn me [num]\n\n\n        (let [\n\n            one-digits {1 \"I\" 2 \"II\" 3 \"III\" 4 \"IV\" 5 \"V\" 6 \"VI\" 7 \"VII\" 8 \"VIII\" 9 \"IX\"}\n\n            two-digits {10 \"X\" 20 \"XX\" 30 \"XXX\" 40 \"XL\" 50 \"L\" 60 \"LX\" 70 \"LXX\" 80 \"LXXX\" 90 \"XC\"}\n\n            three-digits {100 \"C\" 200 \"CC\" 300 \"CCC\" 400 \"CD\" 500 \"D\" 600 \"DC\" 700 \"DCC\" 800 \"DCCC\" 900 \"CM\"}\n\n            four-digits (fn [num] (apply str (repeat (quot num 1000) \"M\")) )\n\n            num-seq     (fn [num]\n                            (map {\\0 0 \\1 1 \\2 2 \\3 3 \\4 4 \\5 5 \\6 6 \\7 7 \\8 8 \\9 9}\n                              (str num))\n                            )\n\n            my-seq (reverse (num-seq num))\n            \n            cnt    (count my-seq)\n\n            my-units (take cnt (iterate #(* 10 %) 1))\n\n            nums-seq (map * my-seq my-units)\n\n            m-fn (fn [num] \n\n                  (let [ nums (num-seq num)\n\n                         cnt  (count nums)\n                      ]\n\n                  (cond \n                      (= 1 cnt) (one-digits num)\n                      (= 2 cnt) (two-digits num)\n                      (= 3 cnt) (three-digits num)\n                      (= 4 cnt) (four-digits num)\n\n                  )\n\n                ))\n\n            ]\n        \n            (apply str (reverse (map m-fn nums-seq)))\n\n      )\n\n)","user":"55897fe2e4b059ccff29b205"},{"problem":104,"code":"(fn [n]\n  (let [p10-rn {1 [\"I\" \"V\" \"X\"] 10 [\"X\" \"L\" \"C\"] 100 [\"C\" \"D\" \"M\"] 1000 [\"M\"]}\n        prs-rn (fn [n [u f t]]\n                 (cond\n                   (zero? n)  \"\"\n                   (< 0 n 4)  (apply str (take n (repeat u)))\n                   (= n 4)    (apply str (concat u f))\n                   (= n 5)    f\n                   (< 5 n 9)  (apply str (concat f (take (- n 5) (repeat u))))\n                   :else      (apply str (concat u t))))\n        map-n (fn [n]\n                (->> (str n)\n                     seq\n                     (map (comp read-string str))\n                     reverse\n                     (zipmap [1 10 100 1000])))\n        n-map (map-n n)\n        create-rn (fn [k]\n                    (prs-rn (n-map k) (p10-rn k)))\n        pwrs (take (count n-map) [1 10 100 1000])]\n    (reduce #(apply str (concat (create-rn %2) %1)) \"\" pwrs)))","user":"5c165d3ee4b01240ff5671d1"},{"problem":104,"code":"(fn __ [n]\n  (cond\n    (>= n 1000) (str  \"M\" (__ (- n 1000)))\n    (>= n  900) (str \"CM\" (__ (- n  900)))\n    (>= n  500) (str  \"D\" (__ (- n  500)))\n    (>= n  400) (str \"CD\" (__ (- n  400)))\n    (>= n  100) (str  \"C\" (__ (- n  100)))\n    (>= n   90) (str \"XC\" (__ (- n   90)))\n    (>= n   50) (str  \"L\" (__ (- n   50)))\n    (>= n   40) (str \"XL\" (__ (- n   40)))\n    (>= n   10) (str  \"X\" (__ (- n   10)))\n    (>= n    9) (str \"IX\" (__ (- n    9)))\n    (>= n    5) (str  \"V\" (__ (- n    5)))\n    (>= n    4) (str \"IV\" (__ (- n    4)))\n    (>= n    1) (str  \"I\" (__ (- n    1)))))","user":"58f44c07e4b0438e51c2ceb7"},{"problem":104,"code":"(fn roman-num\n  [n]\n  (let [[th h t u] (->> (format \"%04d\" n)\n                        seq\n                        (map #(Character/getNumericValue ^String %)))]\n    (->>\n\n      [(take th (repeat \"M\"))\n       (nth [\"\" \"C\" \"CC\" \"CCC\" \"CD\" \"D\" \"DC\" \"DCC\" \"DCCC\" \"CM\"] h)\n       (nth [\"\" \"X\" \"XX\" \"XXX\" \"XL\" \"L\" \"LX\" \"LXX\" \"LXXX\" \"XC\"] t)\n       (nth [\"\" \"I\" \"II\" \"III\" \"IV\" \"V\" \"VI\" \"VII\" \"VIII\" \"IX\"] u)]\n      flatten\n      (apply str))))","user":"536ecd9fe4b0fc7073fd6e76"},{"problem":104,"code":"(fn ->roman\n  ( [n] (->roman n \"\"))\n  ( [n s]\n  (cond\n    (>= (quot n 1000) 1) (recur (mod n 1000)\n                                (str s (apply str (take (quot n 1000)\n                                                        (repeat \"M\")))))\n    (>= n 900) (recur (- n 900) (str s \"CM\"))\n    (>= n 500) (recur (- n 500) (str s \"D\"))\n    (>= n 400) (recur (- n 400) (str s \"CD\"))\n    (>= n 100) (recur (- n 100) (str s \"C\"))\n    (>= n 90) (recur (- n 90) (str s \"XC\"))\n    (>= n 50) (recur (- n 50) (str s \"L\"))\n    (>= n 40) (recur (- n 40) (str s \"XL\"))\n    (>= n 10) (recur (- n 10) (str s \"X\"))\n    (>= n 9) (recur (- n 9) (str s \"IX\"))\n    (>= n 5) (recur (- n 5) (str s \"V\"))\n    (>= n 4) (recur (- n 4) (str s \"IV\"))\n    (>= n 1) (recur (- n 1) (str s \"I\"))\n    (= n 0) s\n    )))","user":"561ca6ebe4b064ca9f4b169c"},{"code":"(fn [n]\n  (letfn [(roman [n]\n                 (cond (>= n 1000) (cons \\M (roman (- n 1000)))\n                       (>= n 900) (concat \"CM\" (roman (- n 900)))\n                       (>= n 500) (cons \\D (roman (- n 500)))\n                       (>= n 400) (concat \"CD\" (roman (- n 400)))\n                       (>= n 100) (cons \\C (roman (- n 100)))\n                       (>= n 90) (concat \"XC\" (roman (- n 90)))\n                       (>= n 50) (cons \\L (roman (- n 50)))\n                       (>= n 40) (concat \"XL\" (roman (- n 40)))\n                       (>= n 10) (cons \\X (roman (- n 10)))\n                       (>= n 9) (concat \"IX\" (roman (- n 9)))\n                       (>= n 5) (cons \\V (roman (- n 5)))\n                       (>= n 4) (concat \"IV\" (roman (- n 4)))\n                       (>= n 1) (cons \\I (roman (dec n)))))]\n    (apply str (roman n))))","problem":104,"user":"51780f88e4b03d69594194c9"},{"code":"(fn [n]\n  ((fn encode-numerals\n    [n string]\n    (cond (>= n 1000) (encode-numerals (- n 1000) (str string \"M\"))\n          (>= n 900) (encode-numerals (- n 900) (str string \"CM\"))\n          (>= n 500) (encode-numerals (- n 500) (str string \"D\"))\n          (>= n 400) (encode-numerals (- n 400) (str string \"CD\"))\n          (>= n 100) (encode-numerals (- n 100) (str string \"C\"))\n          (>= n 90) (encode-numerals (- n 90) (str string \"XC\"))\n          (>= n 50) (encode-numerals (- n 50) (str string \"L\"))\n          (>= n 40) (encode-numerals (- n 40) (str string \"XL\"))\n          (>= n 10) (encode-numerals (- n 10) (str string \"X\"))\n          (>= n 9) (encode-numerals (- n 9) (str string \"IX\"))\n          (>= n 5) (encode-numerals (- n 5) (str string \"V\"))\n          (>= n 4) (encode-numerals (- n 4) (str string \"IV\"))\n          (>= n 1) (encode-numerals (- n 1) (str string \"I\"))\n          :else string)) n \"\"))","problem":104,"user":"513d121fe4b0e544971636a2"},{"code":"(fn to-roman [n]\n (let [nums [[\"M\" 1000] [\"CM\" 900] [\"D\" 500]\n             [\"CD\" 400] [\"C\" 100] [\"XC\" 90]\n             [\"L\" 50] [\"XL\" 40] [\"X\" 10]\n             [\"IX\" 9] [\"V\" 5] [\"IV\" 4] [\"I\" 1]]]\n   (loop [n n r []]\n     (if (>= 0 n)\n       (apply str r)\n       (let [nv (first (filter #(>= n (second %)) nums))]\n         (recur (- n (second nv)) (conj r (first nv))))))))","problem":104,"user":"4fa0a4b1e4b0dcca54ed6d4f"},{"problem":104,"code":"(fn num->rome \n  ([num] (num->rome num \"\"))\n  ([num repr] \n   (if (= num 0) repr\n    (let [romans [[1000 \"M\"]\n                 [900 \"CM\"]\n                 [500 \"D\"]\n                 [400 \"CD\"]\n                 [100 \"C\"]\n                 [90 \"XC\"]\n                 [50 \"L\"]\n                 [40 \"XL\"]\n                 [10 \"X\"]\n                 [9 \"IX\"]\n                 [5 \"V\"]\n                 [4 \"IV\"]\n                 [1 \"I\"]]\n         distances (map (fn [[number repr]] [(- num number) number repr]) romans)\n         legit-dist (filter (fn [[dist _ _]] (>= dist 0)) distances)\n         [d num' repr'] (apply min-key (fn [[dist _ _]] dist) legit-dist)]\n      (recur (Math/abs (- num num')) (str repr repr'))))))","user":"538e29d1e4b0b51d73faae80"},{"problem":104,"code":"(fn [number]\n    (let [table {1 \"I\" 2 \"II\" 3 \"III\" 4 \"IV\" 5 \"V\" 6 \"VI\" 7 \"VII\" 8 \"VIII\"\n                 9 \"IX\" 10 \"X\" 20 \"XX\" 30 \"XXX\" 40 \"XL\" 50 \"L\" 60 \"LX\"\n                 70 \"LXX\" 80 \"LXXX\" 90 \"XC\" 100 \"C\" 200 \"CC\" 300 \"CCC\"\n                 400 \"CD\" 500 \"D\" 600 \"DC\" 700 \"DCC\"  800 \"DCCC\"  900 \"CM\"\n                 1000 \"M\" 2000 \"MM\" 3000 \"MMM\" 4000 \"MMMM\"}]\n      (clojure.string/join\n        (reverse\n          (filter (complement nil?)\n                  (map #(get table (* %1 %2))\n                       (reverse\n                         (map #(- (int %) 48) (seq (str number))))\n                       [1 10 100 1000]))))))","user":"560e9a2de4b05f002753df52"},{"code":"(fn roman-str [n]\n  (apply str\n          (loop [a n,\n                 r []]\n            (cond (>= a 1000) (recur (- a 1000) (conj r 'M))\n                  (>= a 900)  (recur (- a 900) (conj (conj r 'C) 'M))\n                  (>= a 500)  (recur (- a 500) (conj r 'D))\n                  (>= a 400)  (recur (- a 400) (conj (conj r 'C) 'D))\n                  (>= a 100)  (recur (- a 100) (conj r 'C))\n                  (>= a 90)   (recur (- a 90) (conj (conj r 'X) 'C))\n                  (>= a 50)   (recur (- a 50) (conj r 'L))\n                  (>= a 40)   (recur (- a 40) (conj (conj r 'X) 'L))\n                  (>= a 10)   (recur (- a 10) (conj r 'X))\n                  (>= a 9)    (recur (- a 9) (conj (conj r 'I) 'X))\n                  (>= a 5)    (recur (- a 5) (conj r 'V))\n                  (>= a 4)    (recur (- a 4) (conj (conj r 'I) 'V))\n                  (>= a 1)    (recur (- a 1) (conj r 'I))\n                  :else r))))","problem":104,"user":"5341b141e4b00652c8746ecf"},{"code":"(fn RN [i]\n  (cond\n   (= i 0) \"\"\n   (< i 4) (str \"I\" (RN (- i 1)))\n   (= i 4) \"IV\"\n   (< i 9) (str \"V\" (RN (- i 5)))\n   (= i 9) \"IX\"\n   (< i 40) (str \"X\" (RN (- i 10)))\n   (< i 50) (str \"XL\" (RN (- i 40)))\n   (< i 90) (str \"L\" (RN (- i 50)))\n   (< i 100) (str \"XC\" (RN (- i 90)))\n   (< i 400) (str \"C\" (RN (- i 100)))\n   (< i 500) (str \"CD\" (RN (- i 400)))\n   (< i 900) (str \"D\" (RN (- i 500)))\n   (< i 1000) (str \"CM\" (RN (- i 900)))\n   true (str \"M\" (RN (- i 1000)))\n   ))","problem":104,"user":"525372ade4b0541d1855b8f3"},{"problem":104,"code":"(fn [n]\n  (let [romans (map vector\n                    [\"M\" \"CM\" \"D\" \"CD\" \"C\" \"XC\" \"L\" \"XL\" \"X\" \"IX\" \"V\" \"IV\" \"I\"]\n                    [1000 900 500 400  100  90   50  40  10    9   5   4    1])\n        choose (fn [n] (first (filter #(<= (% 1) n) romans)))]\n    (loop [n n r \"\"]\n      (if (zero? n) r\n          (let [[rom num] (choose n)]\n            (recur (- n num) (str r rom)))))))","user":"552a793ee4b0ffed3738f955"},{"problem":104,"code":"(fn [n]\n    (second \n      ((fn [n s]\n         (cond\n           (>= n 1000)(recur (- n 1000)(str s \"M\"))\n           (>= n 900) (recur (- n 900) (str s \"CM\"))\n           (>= n 500) (recur (- n 500) (str s \"D\"))\n           (>= n 100) (recur (- n 100) (str s \"C\"))\n           (>= n 90)  (recur (- n 90)  (str s \"XC\"))\n           (>= n 50)  (recur (- n 50)  (str s \"L\"))\n           (>= n 40)  (recur (- n 40)  (str s \"XL\"))\n           (>= n 10)  (recur (- n 10)  (str s \"X\"))\n           (>= n 9)   (recur (- n 9)   (str s \"IX\"))\n           (>= n 5)   (recur (- n 5)   (str s \"V\"))\n           (>= n 4)   (recur (- n 4)   (str s \"IV\"))\n           (>= n 1)   (recur (- n 1)   (str s \"I\"))\n           :else [0 s]))\n      n \"\")))","user":"4fc4eb1ee4b081705acca354"},{"problem":104,"code":"(fn to-roman [n]\n  (apply str\n         ((fn to-roman' [r n]\n            (cond\n              (>= n 1000) (concat r \"M\" (to-roman' r (- n 1000)))\n              (>= n 900) (concat r \"CM\" (to-roman' r (- n 900)))\n              (>= n 500) (concat r \"D\" (to-roman' r (- n 500)))\n              (>= n 400) (concat r \"CD\" (to-roman' r (- n 400)))\n              (>= n 100) (concat r \"C\" (to-roman' r (- n 100)))\n              (>= n 90) (concat r \"XC\" (to-roman' r (- n 90)))\n              (>= n 50) (concat r \"L\" (to-roman' r (- n 50)))\n              (>= n 40) (concat r \"XL\" (to-roman' r (- n 40)))\n              (>= n 10) (concat r \"X\" (to-roman' r (- n 10)))\n              (>= n 9) (concat r \"IX\" (to-roman' r (- n 9)))\n              (>= n 5) (concat r \"V\" (to-roman' r (- n 5)))\n              (>= n 4) (concat r \"IV\" (to-roman' r (- n 4)))\n              (>= n 1) (concat r \"I\" (to-roman' r (- n 1)))\n              :else r))\n          \"\" n)))","user":"569dd6e8e4b0542e1f8d1480"},{"code":"(fn w-r-n [n]\n  (let [digs {1000 \"M\" 900 \"CM\" 500 \"D\" 400 \"CD\" 100 \"C\" 90 \"XC\"\n              50 \"L\" 40 \"XL\" 10 \"X\" 9 \"IX\" 5 \"V\" 4 \"IV\" 1 \"I\"}]\n    (loop [[d & ds] (reverse (sort (keys digs)))\n           n n\n           acc \"\"]\n      (if (nil? d)\n        acc\n        (let [res (loop [n n acc acc c 0]\n                    (if (< n d)\n                      [acc c]\n                      (recur (- n d) (str acc (get digs d)) (inc c))))]\n          (recur ds (- n (* d (get res 1))) (get res 0)))))))","problem":104,"user":"511e763ce4b03e81d390ac29"},{"code":"(fn roman [n]\n  (let [nmap (sorted-map\n               1000 \\M\n               900  \"CM\"\n               500  \\D\n               400  \"CD\"\n               100  \\C\n               90   \"XC\"\n               50   \\L\n               40   \"XL\"\n               10   \\X\n               9    \"IX\"\n               5    \\V\n               4    \"IV\"\n               1    \\I)]\n    (loop [n'  n\n           acc \"\"]\n      (if (> n' 0)\n        (let [newmap (last (subseq nmap <= n'))]\n          (recur (- n' (first newmap)) (str acc (last newmap))))\n        acc))))","problem":104,"user":"531c0619e4b08068f379ed98"},{"problem":104,"code":"#(letfn [(romanNum[n one five ten]\n                  (cond\n                   (<= n 3) (apply str (repeat n one))\n                   (= n 4) (str one five)\n                   (>= n 9) (str one ten)\n                   :else (str five (apply str (repeat (- n 5) one)))))\n         (romanLetter[n]\n                     (cond\n                      (= n 1000) (list \"M\" nil nil)\n                      (= n 100) (list \"C\" \"D\" \"M\")\n                      (= n 10) (list \"X\" \"L\" \"C\")\n                      :else (list \"I\" \"V\" \"X\")))]\n   (loop[n % u 1000 r \"\"]\n       (if\n        (= n 0) r\n        (let[qn (quot n u)\n          rn (rem n u)\n          nr (str r (apply romanNum qn (romanLetter u)))]\n          (recur (- n (* qn u)) (quot u 10) nr)))))","user":"541619e8e4b01498b1a719f9"},{"problem":104,"code":"(fn f ([x c y] (if (empty? c) y (f (mod x (first (first c))) (rest c) (apply str y (take (quot x (first (first c))) (repeat (second (first c))))))))\n  ([x] (f x '((1000 \"M\") (900 \"CM\") (500 \"D\") (400 \"CD\") (100 \"C\") (90 \"XC\") (50 \"L\") (40 \"XL\") (10 \"X\") (9 \"IX\") (5 \"V\") (4 \"IV\") (1 \"I\")) \"\")))","user":"5c41db45e4b08cd430848ece"},{"problem":104,"code":"(fn decimal->roman\n  [n]\n  (let [num->roman {1    \"I\"\n                    4    \"IV\"\n                    5    \"V\"\n                    9    \"IX\"\n                    10   \"X\"\n                    40   \"XL\"\n                    50   \"L\"\n                    90   \"XC\"\n                    100  \"C\"\n                    400  \"CD\"\n                    500  \"D\"\n                    900  \"CM\"\n                    1000 \"M\"}]\n    (->> num->roman\n         (sort-by key >)\n         (reduce (fn [{:keys [rem result]} [div chars]]\n                   (let [x (int (Math/floor (/ rem div)))]\n                     {:rem (- rem (* x div))\n                      :result (str result (apply str (repeat x chars)))}))\n                 {:rem n :result \"\"})\n         :result)))","user":"5b602a66e4b0c6492753e6fc"},{"problem":104,"code":"(fn [n]\n   (if (or (not (pos? n)) (> n 3999)) nil\n      (let [r #(let [[a b c] ({3 [\"I\" \"V\" \"X\"], 2 [\"X\" \"L\" \"C\"], 1 [\"C\" \"D\" \"M\"], 0 [\"M\"]} %)] \n                       ({\\1 [a], \\2 [a a], \\3 [a a a] \\4 [a b], \\5 [b], \\6 [b a], \\7 [b a a], \\8 [b a a a], \\9 [a c]} (nth (format \"%04d\" n) %)))]\n         (apply str (concat (r 0) (r 1) (r 2) (r 3))))))","user":"59f043d0e4b0966464fe6a3d"},{"code":"(fn to-roman [n]\n        (let [m {1000 [\\M 0 0] 100 [\\C \\D \\M]\n                 10 [\\X \\L \\C] 1 [\\I \\V \\X]}\n              o (map #(list (- (int %) 48) %2) (str n)\n                     (take-last (count (str n)) [1000 100 10 1]))]\n          (apply str (flatten\n            (map (fn [[a b]]\n                   (let [[p q r] (get m b)]\n                     (cond\n                      (< a 4) (repeat a p)\n                      (= a 4) [p q]\n                      (< a 9) (concat [q] (repeat (- a 5) p))\n                      :else   [p r])))\n                 o)))))","problem":104,"user":"4f031eac535dcb61093f6a67"},{"problem":104,"code":"(fn rm [n]\n  (let [roman-map [[1000 \"M\"]\n                   [900 \"CM\"]\n                   [500 \"D\"]\n                   [400 \"CD\"]\n                   [100 \"C\"]\n                   [90 \"XC\"]\n                   [50 \"L\"]\n                   [40 \"XL\"]\n                   [10 \"X\"]\n                   [9 \"IX\"]\n                   [5 \"V\"]\n                   [4 \"IV\"]\n                   [1 \"I\"]]]\n    (:ret (reduce #(if (zero? (quot (:num %) (first %2)))\n               {:ret (:ret %) :num (:num %)}\n               {:ret (str (:ret %) (apply str (repeat (quot (:num %) (first %2)) (second %2))))\n               :num (mod (:num %) (first %2))})\n            {:ret \"\" :num n} roman-map))))","user":"4f041de1535dcb61093f6ba5"},{"code":"(fn [x]\n  (let [lookups [[\"\" \"I\" \"II\" \"III\" \"IV\" \"V\" \"VI\" \"VII\" \"VIII\" \"IX\"]\n                 [\"\" \"X\" \"XX\" \"XXX\" \"XL\" \"L\" \"LX\" \"LXX\" \"LXXX\" \"XC\"]\n                 [\"\" \"C\" \"CC\" \"CCC\" \"CD\" \"D\" \"DC\" \"DCC\" \"DCCC\" \"CM\"]\n                 [\"\" \"M\" \"MM\" \"MMM\"]]]\n    (->> (str x)\n         (reverse)\n         (map #(- (int %) (int \\0)))\n         (map-indexed (fn [i v] (get-in lookups [i v])))\n         (reverse)\n         (clojure.string/join))))","problem":104,"user":"4fe8fda4e4b0547ebccb2438"},{"problem":104,"code":"(fn rom [n]\n  (let [romanian-digit (fn [n i v x]\n                        (cond\n                          (>= 3 n) (apply str (take n (repeat i)))\n                          (= 4 n) (str i v)\n                          (= 5 n) v\n                          (= 6 n) (str v i)\n                          (= 7 n) (str v i i)\n                          (= 8 n) (str v i i i)\n                          (= 9 n) (str i x)))\n        d (quot n 1000)\n        q (mod (quot n 100) 10)\n        l (mod (quot n 10) 10)\n        p (mod n 10)]\n    (str\n     (romanian-digit d \"M\" \"\" \"\")\n     (romanian-digit q \"C\" \"D\" \"M\")\n     (romanian-digit l \"X\" \"L\" \"C\")\n     (romanian-digit p \"I\" \"V\" \"X\"))))","user":"58fc92c5e4b0438e51c2cf9a"},{"problem":104,"code":"(let [num-lst [[1000 \"M\"] [900 \"CM\"] [500 \"D\"] [400 \"CD\"] [100 \"C\"]\n                [90 \"XC\"] [50 \"L\"] [40 \"XL\"] [10 \"X\"] [9 \"IX\"]\n                [5 \"V\"] [4 \"IV\"] [1 \"I\"]]]\n   (fn make-roman [num]\n     (loop [rem num res [] lst num-lst]\n       (let [fst (first lst)]\n         (cond (empty? lst) (apply str res)\n              (< rem (first fst)) (recur rem res (rest lst))\n              :else (recur (- rem (first fst)) (conj res (second fst)) lst))))))","user":"54f09599e4b024c67c0cf89d"},{"code":"(fn [n] \n  (let [rm {\\0 [\"\" \"\" \"\" \"\"]\n            \\1 [\"M\" \"C\" \"X\" \"I\"]\n            \\2 [\"MM\" \"CC\" \"XX\" \"II\"]\n            \\3 [\"MMM\" \"CCC\" \"XXX\" \"III\"]\n            \\4 [\"\" \"CD\" \"XL\" \"IV\"]\n            \\5 [\"\" \"D\" \"L\" \"V\"]\n            \\6 [\"\" \"DC\" \"LX\" \"VI\"]\n            \\7 [\"\" \"DCC\" \"LXX\" \"VII\"]\n            \\8 [\"\" \"DCCC\" \"LXXX\" \"VIII\"]\n            \\9 [\"\" \"CM\" \"XC\" \"IX\"]}\n        s (str n)]\n    (first (reduce (fn [[a i] e]\n                     [(str a ((rm e) i)) (inc i)]) \n                   [\"\" (- 4 (count s))] s))))","problem":104,"user":"5246e945e4b0644eb7b0783b"},{"code":"(fn [n]\n  (let [ds (reverse (map #(- (int %) (int \\0)) (str n)))\n        rn [\"\" \"1\" \"11\" \"111\" \"15\" \"5\" \"51\" \"511\" \"5111\" \"10\" ]\n        rs (fn [i v x] (mapv #(clojure.string/replace % #\"1|5|0\" {\"1\" i \"5\" v \"0\" x}) rn))\n        rss (mapv #(apply rs %) [[\"I\" \"V\" \"X\"] [\"X\" \"L\" \"C\"] [\"C\" \"D\" \"M\"] [\"M\" \"P\" \"Q\"]])]\n    (clojure.string/join (reverse (map get rss ds)))))","problem":104,"user":"51c19873e4b0d204dbe2ca0d"},{"code":"(fn roman [x]\n  (if (zero? x)\n    \"\"\n    (->> (drop-while #(> (first %) x)\n           [[1000 \"M\"] [900 \"CM\"] [500 \"D\"] [400 \"CD\"] [100 \"C\"] [90 \"XC\"] [50 \"L\"] [40 \"XL\"] [10 \"X\"] [9 \"IX\"] [5 \"V\"] [4 \"IV\"] [1 \"I\"]])\n         first\n         ((fn [[v s]] (str s (roman (- x v))))))))","problem":104,"user":"4f465096e4b0d56e7bb92b9a"},{"code":"(fn [n]\n  (apply str\n         ((fn [i res]\n            (cond (= i 0) res\n                  (>= i 1000) (recur (- i 1000) (conj res \\M))\n                  (>= i 900) (recur (- i 900) (conj res \\C \\M))\n                  (>= i 500) (recur (- i 500) (conj res \\D))\n                  (>= i 400) (recur (- i 400) (conj res \\C \\D))\n                  (>= i 100) (recur (- i 100) (conj res \\C))\n                  (>= i 90) (recur (- i 90) (conj res \\X \\C))\n                  (>= i 50) (recur (- i 50) (conj res \\L))\n                  (>= i 40) (recur (- i 40) (conj res \\X \\L))\n                  (>= i 10) (recur (- i 10) (conj res \\X))\n                  (>= i 9) (recur (- i 9) (conj res \\I \\X))\n                  (>= i 5) (recur (- i 5) (conj res \\V))\n                  (= i 4) (recur (- i 4) (conj res \\I \\V))\n                  :else (recur (- i 1) (conj res \\I))))\n          n [])))","problem":104,"user":"51da631be4b02ceefd947766"},{"code":"(fn [n] (str \r\n           ([\"\" \"M\" \"MM\" \"MMM\"] (quot n 1000)) \r\n           ([\"\" \"C\" \"CC\" \"CCC\" \"CD\" \"D\" \"DC\" \"DCC\" \"DCCC\" \"CM\"] (quot (rem n 1000) 100))\r\n           ([\"\" \"X\" \"XX\" \"XXX\" \"XL\" \"L\" \"LX\" \"LXX\" \"LXXX\" \"XC\"] (quot (rem n 100) 10))\r\n           ([\"\" \"I\" \"II\" \"III\" \"IV\" \"V\" \"VI\" \"VII\" \"VIII\" \"IX\"] (rem n 10))\r\n           ))","problem":104,"user":"4feada56e4b0140c20fb9c11"},{"problem":104,"code":"(fn \n  [n]\n  (let [r [[1000 \"M\"] [900 \"CM\"] [500 \"D\"] [400 \"CD\"] [100 \"C\"] [90 \"XC\"] [50 \"L\"] [40 \"XL\"] [10 \"X\"] [9 \"IX\"] [5 \"V\"] [4 \"IV\"] [1 \"I\"]]]\n    (first (reduce (fn [[acc n] [val numeral]]\n                     (if (zero? n)\n                       (vector acc n) ;;reduced\n                       (let [times (int (float (/ n val)))]\n                         (vector (str acc (apply str (repeat times numeral)))\n                                 (- n (* times val))))))\n                   [\"\" n] r))))","user":"5338387de4b0e30313ee6c91"},{"problem":104,"code":"(fn rom [n]\n  (if (zero? n)\n    \"\"\n    (let [numerals {1 \"I\", 4 \"IV\", 5 \"V\", 9 \"IX\", 10 \"X\", 40 \"XL\", 50 \"L\", 90 \"XC\", 100 \"C\", 400 \"CD\", 500 \"D\", 900 \"CM\", 1000 \"M\"}\n          k (sort (keys numerals))\n          i (last (filter #(> (quot n %) 0) k))\n          v (numerals i)]\n      (str v (rom (- n i)))\n    )))","user":"5b0bd9cfe4b0cc2b61a3bdd9"},{"problem":104,"code":"(fn r [num]\n  (let [m {1    \\I\n           4    \"IV\"\n           5    \\V\n           9    \"IX\"\n           10   \\X\n           40   \"XL\"\n           50   \\L\n           90   \"XC\"\n           100  \\C\n           400  \"CD\"\n           500  \\D\n           900  \"CM\"\n           1000 \\M}]\n    (loop [n num r \"\"]\n      (if (zero? n) r\n                    (let [x (map (fn [[k v]] (vector v (- n k))) m)\n                          [res nl]\n                          (->> x\n                               (filter (comp not neg? second))\n                               (apply min-key second))]\n                      (recur nl (str r res)))))))","user":"51aefceee4b09397d5109797"},{"problem":104,"code":"(fn [n]\n\t(apply str (map-indexed #(get-in [\n\t\t[\"\" \t\t\"\" \t\t\"\" \t\t\"\"\t\t]\n\t\t[\"M\"\t\t\"C\"\t\t\"X\"\t\t\"I\"\t\t]\n\t\t[\"MM\"\t\t\"CC\"\t\"XX\"\t\"II\"\t]\n\t\t[\"MMM\"\t\t\"CCC\"\t\"XXX\"\t\"III\"\t]\n\t\t[\"MMMM\"\t\t\"CD\"\t\"XL\"\t\"IV\"\t]\n\t\t[\"MMMMM\"\t\"D\"\t\t\"L\"\t\t\"V\"\t\t]\n\t\t[\"MMMMMM\"\t\"DC\"\t\"LX\"\t\"VI\"\t]\n\t\t[\"MMMMMMM\"\t\"DCC\"\t\"LXX\"\t\"VII\"\t]\n\t\t[\"MMMMMMMM\"\t\"DCCC\"\t\"LXXX\"\t\"VIII\"\t]\n\t\t[\"MMMMMMMMM\" \"CM\"\t\"XC\"\t\"IX\"\t]\n\t] [%2 %1]) (map #(Character/digit % 10) (format \"%04d\" n)))))","user":"5578f292e4b05c286339e08f"},{"code":"(fn __ [n]\n  (if (pos? n)\n    (let [d {1000 \\M 500 \\D 100 \\C 50 \\L 10 \\X 5 \\V 1 \\I\n               900 \"CM\" 400 \"CD\" 90 \"XC\" 40 \"XL\" 9 \"IX\" 4 \"IV\"}\n        v (apply max (filter #(>= n %) (keys d)))]\n      (apply str (cons (d v) (__ (- n v)))))))","problem":104,"user":"4f29eb2ae4b0d6649770a037"},{"problem":104,"code":"(fn decimal->roman [n]\n  (let [numerals\n        (zipmap [1000 900 500 400 100 90 50 40 10 9 5 4 1]\n                [\"M\" \"CM\" \"D\" \"CD\" \"C\" \"XC\" \"L\" \"XL\" \"X\" \"IX\" \"V\" \"IV\" \"I\"])]\n    (loop [acc \"\" n n]\n      (if (zero? n)\n        acc\n        (let [m (apply max (filter #(<= % n) (keys numerals)))]\n          (recur (str acc (numerals m)) (- n m)))))))","user":"53dc94c8e4b094d41abdfefc"},{"problem":104,"code":"(fn toRoman [x] (let [mapping '((1000 \"M\") (900 \"CM\") (500 \"D\") (400 \"CD\") (100 \"C\")\n                                (90 \"XC\") (50 \"L\") (40 \"XL\") (10 \"X\") (9 \"IX\") (5 \"V\") (4 \"IV\") (1 \"I\"))]\n                  (loop [toConsider mapping num x res \"\"] \n                    (cond\n                     (= 0 num) res\n                     (>= num (first (first toConsider))) (recur toConsider (- num (first (first toConsider))) (str res (second (first toConsider))))\n                     :default (recur (rest toConsider) num res)))\n                  )\n  )","user":"56427910e4b08d4f616f5f19"},{"code":"(fn [n]\n   (let [m (sorted-map-by > 1000 \"M\", 900 \"CM\", 500 \"D\", 400 \"CD\",\n                          100 \"C\",  90 \"XC\",  50 \"L\", 40 \"XL\",\n                          10 \"X\",   9 \"IX\",   5 \"V\", 4 \"IV\",\n                          1 \"I\")]\n     (loop [a [], r n]\n       (if (zero? r)\n         (apply str a)\n         (let [k (first (filter #(<= % r) (keys m)))]\n           (recur (conj a (m k)) (- r k)))))))","problem":104,"user":"4ea1b9e4535d7eef308072b8"},{"problem":104,"code":";; compiled with a macro to assemble helper functions into let statements\n(clojure.core/fn roman-string [n] (clojure.core/let [alt-map {[1 0] \"I\", [5 0] \"V\", [1 1] \"X\", [5 1] \"L\", [1 2] \"C\", [5 2] \"D\", [1 3] \"M\"} format-map {7 [5 1 1], 1 [1], 4 [1 5], 6 [5 1], 3 [1 1 1], 2 [1 1], 9 [1 10], 5 [5], 8 [5 1 1 1]} num2list (fn [n] (map (comp (fn* [p1__1485#] (Integer/parseInt p1__1485#)) str) ((comp vec str) n))) new-rom-piece (fn [n j] (let [rom-format (format-map n)] (clojure.string/join (map (comp alt-map (fn [x] (if (= x 10) [1 (inc j)] [x j]))) rom-format))))] (loop [numlist (num2list n) j (dec (count numlist)) out \"\"] (if (empty? numlist) out (recur (rest numlist) (dec j) (str out (new-rom-piece (first numlist) j)))))))","user":"53703287e4b0fc7073fd6e8f"},{"problem":104,"code":"(fn roman [number] \n  (first\n    (reduce \n     (fn [[result number] [character value]]\n       [(str result (apply str (repeat (quot number value) character))) (rem number value)])\n     [\"\" number]\n     [[\"M\" 1000]\n      [\"CM\" 900]\n      [\"D\" 500]\n      [\"CD\" 400]\n      [\"C\" 100]\n      [\"XC\" 90]\n      [\"L\" 50]\n      [\"XL\" 40]\n      [\"X\" 10]\n      [\"IX\" 9]\n      [\"V\" 5]\n      [\"IV\" 4]\n      [\"I\" 1]])))","user":"604d3cb1e4b0b7ec0ac60ac2"},{"problem":104,"code":"(fn __ [n]\n    (loop [rs []\n           i n\n           d [\"M\"  \"CM\" \"D\" \"CD\" \"C\" \"XC\" \"L\" \"XL\" \"X\" \"IX\" \"V\" \"IV\" \"I\"]\n           v [1000 900 500  400  100  90  50  40   10   9    5   4    1 ]]\n      (if (= 0 i) (apply str rs)\n          (recur (into rs (repeat (quot i (first v)) (first d)))\n                 (mod i (first v))\n                 (rest d)\n                 (rest v)))))","user":"5a0ce1a5e4b04bbd27e6d9b7"},{"problem":104,"code":"(fn p [num]\n  (println num)\n    (cond (>= num 1000)\n          (str (apply str (take (quot num 1000) (cycle \"M\")))\n                             (p (mod num 1000)))\n          (>= num 900)\n          (str \"CM\" (p (- num 900)))\n          (>= num 500)\n          (str  \"D\" (apply str (take (quot (- num 500) 100) (cycle \"C\")))\n               (p (mod num 100)))\n          (>= num 400)\n          (str \"CD\" (p (- num 400)))\n          (>= num 100)\n          (str (apply str (take (quot num 100) (cycle \"C\")))\n               (p (mod num 100)))\n          (>= num 90)\n          (str \"XC\" (p (- num 90)))\n          (>= num 50)\n          (str \"L\" (apply str (take (quot (- num 50) 10) (cycle \"X\")))\n               (p (mod num 10)))\n          (>= num 40)\n          (str \"XL\" (p (- num 40)))\n          (>= num 10)\n          (str (apply str (take (quot num 10) (cycle \"X\")))\n               (p (mod num 10)))\n          (>= num 9)\n          (str \"IX\")\n          (>= num 5)\n          (str \"V\" (apply str (take (- num 5) (cycle \"I\"))))\n          (>= num 4)\n          (str \"IV\")\n          :else\n          (apply str (take num (cycle \"I\")))))","user":"53664e3be4b0243289761e74"},{"problem":104,"code":"(fn to-roman [n]\n  (letfn [(roman-u [n]\n            (case (rem n 10)\n              0 \"\"\n              1 \"I\"\n              2 \"II\"\n              3 \"III\"\n              4 \"IV\"\n              5 \"V\"\n              6 \"VI\"\n              7 \"VII\"\n              8 \"VIII\"\n              9 \"IX\"))\n          (roman-t [n]\n            (if (< n 10)\n              \"\"\n              (case (-> n (quot 10) (rem 10))\n                0 \"\"\n                1 \"X\"\n                2 \"XX\"\n                3 \"XXX\"\n                4 \"XL\"\n                5 \"L\"\n                6 \"LX\"\n                7 \"LXX\"\n                8 \"LXXX\"\n                9 \"XC\")))\n          (roman-h [n]\n            (if (< n 100)\n              \"\"\n              (case (-> n (quot 100) (rem 10))\n                0 \"\"\n                1 \"C\"\n                2 \"CC\"\n                3 \"CCC\"\n                4 \"CD\"\n                5 \"D\"\n                6 \"DC\"\n                7 \"DCC\"\n                8 \"DCCC\"\n                9 \"CM\")))\n          (roman-th [n]\n            (-> n\n                (quot 1000)\n                (repeat \\M)\n                clojure.string/join))]\n    (str (roman-th n)\n         (roman-h n)\n         (roman-t n)\n         (roman-u n))))","user":"518279abe4b0353c468deb65"},{"problem":104,"code":"(fn [n]\n  (let [numerals {\"M\" 1000 \"CM\" 900 \"D\" 500 \"CD\" 400 \"C\" 100 \"XC\" 90\n                  \"L\" 50 \"XL\" 40 \"X\" 10 \"IX\" 9 \"V\" 5 \"IV\" 4 \"I\" 1}\n        dec->roman (fn [n]\n                     (loop [n n [[c v] & nums :as all] (reverse (sort-by val numerals)) acc []]\n                       (cond\n                         (zero? n) (apply str acc) ;;if the number is zero, return an empty string\n                         (> v n) (recur n nums acc)\n                         :else (recur (- n v) all (conj acc c)))))]\n    (dec->roman n)))","user":"5baaae06e4b0a20761a23464"},{"problem":104,"code":"(fn [x]\n  (let [mv [\"\" \"M\" \"MM\" \"MMM\"]\n       \tcv [\"\" \"C\" \"CC\" \"CCC\" \"CD\" \"D\" \"DC\" \"DCC\" \"DCCC\" \"CM\"]\n        xv [\"\" \"X\" \"XX\" \"XXX\" \"XL\" \"L\" \"LX\" \"LXX\" \"LXXX\" \"XC\"]\n        iv [\"\" \"I\" \"II\" \"III\" \"IV\" \"V\" \"VI\" \"VII\" \"VIII\" \"IX\"]]\n    (str (mv (quot x 1000))\n         (cv (rem (quot x 100) 10))\n         (xv (rem (quot x 10) 10))\n         (iv (rem x 10)))))","user":"53a9db09e4b047364c04443b"},{"problem":104,"code":"(fn write-roman\n  [num]\n  (loop [data {1000 \"M\" 900 \"CM\" 500 \"D\" 100 \"C\" 90 \"XC\" 50 \"L\" 40 \"XL\" 10 \"X\" 9 \"IX\" 5 \"V\" 4 \"IV\" 1 \"I\"}\n         data-keys (reverse (sort (keys data)))\n         remaining num\n         res []]\n    (cond\n      (zero? remaining) (apply str res)\n      (empty? data-keys) (apply str res)\n      (> (quot remaining (first data-keys)) 0) (recur data data-keys (- remaining (first data-keys))\n                                                (conj res (data (first data-keys))))\n      (= (quot remaining (first data-keys)) 0) (recur data (rest data-keys) remaining\n                                                      res))))","user":"550d9452e4b06e50f9beb15d"},{"code":"(fn rn [n]\n  (cond\n    (zero? n) \"\"\n    (>= n 1000) (str \"M\" (rn (- n 1000)))\n    (>= n 900) (str \"CM\" (rn (- n 900)))\n    (>= n 500) (str \"D\" (rn (- n 500)))\n    (>= n 400) (str \"CD\" (rn (- n 400)))\n    (>= n 100) (str \"C\" (rn (- n 100)))\n    (>= n 90) (str \"XC\" (rn (- n 90)))\n    (>= n 50) (str \"L\" (rn (- n 50)))\n    (>= n 40) (str \"XL\" (rn (- n 40)))\n    (>= n 10) (str \"X\" (rn (- n 10)))\n    (= n 9) \"IX\"\n    (>= n 5) (str \"V\" (rn (- n 5)))\n    (= n 4) \"IV\"\n    (>= n 1) (str \"I\" (rn (dec n)))))","problem":104,"user":"4ddbfb8a535d02782fcbea00"},{"problem":104,"code":"(fn f [t n]\n  (apply str\n    (map #(get-in t %)\n         (mapv vector (range (count (str n)) 0 -1)\n                     (map #(- (int %) (int \\0)) (str n))))))\n{1 {1 \"I\", 2 \"II\", 3 \"III\", 4 \"IV\", 5 \"V\", 6 \"VI\", 7 \"VII\", 8 \"VIII\", 9 \"IX\"},\n 2 {1 \"X\", 2 \"XX\", 3 \"XXX\", 4 \"XL\", 5 \"L\", 6 \"LX\", 7 \"LXX\", 8 \"LXXX\", 9 \"XC\"},\n 3 {1 \"C\", 2 \"CC\", 3 \"CCC\", 4 \"CD\", 5 \"D\", 6 \"DC\", 7 \"DCC\", 8 \"DCCC\", 9 \"CM\"}\n 4 {1 \"M\", 2 \"MM\", 3 \"MMM\"}}","user":"548b7db8e4b0e286459a11fd"},{"problem":104,"code":"(fn f \n  ([n] (f n \"\"))\n  ([n r] (letfn [(t [x y] \n                    (f (- n x) (apply str (concat r y))))] \n                  (cond (<= 1000 n) (t 1000 \"M\")\n                        (<= 900 n) (t 900 \"CM\")\n                        (<= 500 n) (t 500 \"D\")\n                        (<= 100 n) (t 100 \"C\")\n                        (<= 90 n) (t 90 \"XC\")\n                        (<= 50 n) (t 50 \"L\")\n                        (<= 40 n) (t 40 \"XL\")\n                        (<= 10 n) (t 10 \"X\")\n                        (<= 9 n) (t 9 \"IX\")\n                        (<= 5 n) (t 5 \"V\")\n                        (<= 4 n) (t 4 \"IV\")\n                        (<= 1 n) (t 1 \"I\")\n                        :else r))))","user":"5a14228fe4b0ff51aa4b3193"},{"code":"#(str\n  ({0 \"\" 1 \"M\" 2 \"MM\" 3 \"MMM\"} (quot % 1000))\n  ({0 \"\" 1 \"C\" 2 \"CC\" 3 \"CCC\" 4 \"CD\"\n    5 \"D\" 6 \"DC\" 7 \"DCC\" 8 \"DCCC\" 9 \"CM\"}\n      (quot (mod % 1000) 100))\n  ({0 \"\" 1 \"X\" 2 \"XX\" 3 \"XXX\" 4 \"XL\"\n    5 \"L\" 6 \"LX\" 7 \"LXX\" 8 \"LXXX\" 9 \"XC\"}\n      (quot (mod % 100) 10))\n  ({0 \"\" 1 \"I\" 2 \"II\" 3 \"III\" 4 \"IV\"\n    5 \"V\" 6 \"VI\" 7 \"VII\" 8 \"VIII\" 9 \"IX\"}\n      (mod % 10)))","problem":104,"user":"4e5fe31a535d8ccf87e9fe50"},{"code":"{1 \"I\" 30 \"XXX\" 4 \"IV\" 140 \"CXL\" 827 \"DCCCXXVII\"\n3999 \"MMMCMXCIX\" 48 \"XLVIII\"}","problem":104,"user":"4dfe65a1535d04ed9115e787"},{"problem":104,"code":"(fn [n] (let [q #(quot % %2) m #(mod % %2) j #(reduce str (repeat % %2)) p #(if (= % 9) (str %2 %3) (if (= % 4) (str %2 %4) (if (> % 4) (str %4 (j (- % 5) %2)) (j % %2)))) x #(p (q (m n %) %2) %3 %4 %5)] (str (j (q n 1000) \\M) (x 1000 100 \\C \\M \\D) (x 100 10 \\X \\C \\L) (x 10 1 \\I \\X \\V) )))","user":"56c08696e4b060a8e693e3aa"},{"problem":104,"code":"(fn [x] (->> (reverse (str x))\n     (map #(%1 %2)\n          [{\\1 \"I\"\n            \\2 \"II\"\n            \\3 \"III\"\n            \\4 \"IV\"\n            \\5 \"V\"\n            \\6 \"VI\"\n            \\7 \"VII\"\n            \\8 \"VIII\"\n            \\9 \"IX\"}\n           {\\1 \"X\"\n            \\2 \"XX\"\n            \\3 \"XXX\"\n            \\4 \"XL\"\n            \\5 \"L\"\n            \\6 \"LX\"\n            \\7 \"LXX\"\n            \\8 \"LXXX\"\n            \\9 \"XC\"}\n           {\\1 \"C\"\n            \\2 \"CC\"\n            \\3 \"CCC\"\n            \\4 \"CD\"\n            \\5 \"D\"\n            \\6 \"DC\"\n            \\7 \"DCC\"\n            \\8 \"DCCC\"\n            \\9 \"CM\"}\n           {\\1 \"M\"\n            \\2 \"MM\"\n            \\3 \"MMM\"}])\n     (reverse)\n     (apply str)))","user":"5b3ef412e4b02d533a91bc06"},{"code":"(fn romanize [n] \n  (let [ones {1 \"I\" 2 \"II\" 3 \"III\" 4 \"IV\" 5 \"V\" 6 \"VI\" 7 \"VII\" 8 \"VIII\" 9 \"IX\"} \n        tens {1 \"X\" 2 \"XX\" 3 \"XXX\" 4 \"XL\" 5 \"L\" 6 \"LX\" 7 \"LXX\" 8 \"LXXX\" 9 \"XC\"} \n        hundreds {1 \"C\" 2 \"CC\" 3 \"CCC\" 4 \"CD\" 5 \"D\" 6 \"DC\" 7 \"DCC\" 8 \"DCCC\" 9 \"CM\"}\n        thousands {1 \"M\" 2 \"MM\" 3 \"MMM\"}\n        places [ones tens hundreds thousands]\n        digits (reverse (map #(Character/digit % 10) (str n)))] \n    (apply str (reverse (map #(% %2) places digits)))))","problem":104,"user":"5138d08be4b0a5db03d727db"},{"code":"(fn roman [n]\n  (let [nstr (str n)\n        tbl {1 \"I\" 2 \"II\" 3 \"III\" 4 \"IV\" 5 \"V\" 6 \"VI\" 7 \"VII\" 8 \"VIII\" 9 \"IX\" 10 \"X\"\n             20 \"XX\" 30 \"XXX\" 40 \"XL\" 50 \"L\" 60 \"LX\" 70 \"LXX\" 80 \"LXXX\" 90 \"XC\" 100 \"C\"\n             200 \"CC\" 300 \"CCC\" 400 \"CD\" 500 \"D\" 600 \"DC\" 700 \"DCC\" 800 \"DCCC\" 900 \"CM\" 1000 \"M\"\n             2000 \"MM\" 3000 \"MMM\"}]\n    (apply str (map tbl (map-indexed \n       #(* (int (Math/pow 10 (- (.length nstr) % 1)))\n           (- (int %2) (int \\0)))\n     nstr)))\n    ))","problem":104,"user":"513fab65e4b00f13ea1bd891"},{"code":"(fn Num->Roman\n  [n]\n  (let [;; static maps\n        digit-map (zipmap (range 1 11) [1 11 111 15 5 51 511 5111 9])\n        expo-map (zipmap [0 1 5 9 10 50 90 100 500 900 1000] [\"\" \"I\" \"V\" \"IX\" \"X\" \"L\" \"XC\" \"C\" \"D\" \"CM\" \"M\"])\n        ;; helper functions\n        digits (fn [n] (map #(- (int %) 48) (str n)))\n        pow (fn [a b] (reduce * (repeat b a)))\n        to (fn [a b] (range a (dec b) -1))\n        ;; steps\n        step1 (map digit-map (digits n))\n        step2 (map digits step1) ;;((1 1 0) (1 0 1)....)\n        step3 (map #(map (fn [n] (* n (pow 10 (dec %2)))) %) step2 (to (count step2) 1))\n        step4 (mapcat #(map expo-map %) step3)\n        final (apply str step4)]\n    final))","problem":104,"user":"52b35a6ee4b0c58976d9ad07"},{"problem":104,"code":"(fn [n] \n    (let [romans \"IVXLCDM__\"\n          groups (partition 3 2 romans)\n          digits (reverse (map #(Character/digit % 10) (str n)))]\n         (apply str (reverse (map \n              (fn [digit [I V X]] \n                    (condp = digit\n                      0 \"\"\n                      1 (str I)\n                      2 (str I I)\n                      3 (str I I I)\n                      4 (str I V)\n                      5 (str V)\n                      6 (str V I)\n                      7 (str V I I)\n                      8 (str V I I I)\n                      9 (str I X))) \n              digits groups)))))","user":"575ddfd1e4b02ea11479938d"},{"code":"(fn roman [n]\n  (let [romans {1    \"I\"\n                4    \"IV\"\n                5    \"V\"\n                9    \"IX\"\n                10   \"X\"\n                40   \"XL\"\n                50   \"L\"\n                90   \"XC\"\n                100  \"C\"\n                400  \"CD\"\n                500  \"D\"\n                900  \"CM\"\n                1000 \"M\"}\n        nums (sort > (keys romans))]\n    (loop [curr n roman []]\n      (if-let [closest (first (drop-while #(> % curr) nums))]\n        (recur (- curr closest) (conj roman (romans closest)))\n        (apply str roman)))))","problem":104,"user":"5326c5f7e4b09d4e7a9b54f2"},{"problem":104,"code":"(fn __ [n]\n  (let [k (int (/ n 1000))\n        h (mod (int (/ n 100)) 10)\n        t (mod (int (/ n 10)) 10)\n        o (mod n 10)\n        f (fn [i c half C]\n            (cond\n              (= i 9) [c C]\n              (= i 4) [c half]\n              (= i 5) [half]\n              (> i 5) (concat [half] (repeat (- i 5) c))\n              :else (repeat i c)))\n        K (repeat k \"M\")\n        H (f h \"C\" \"D\" \"M\")\n        T (f t \"X\" \"L\" \"C\")\n        O (f o \"I\" \"V\" \"X\")]\n    (apply str (concat K H T O))))","user":"57a0b341e4b0c3d858beb8d4"},{"problem":104,"code":"(fn\n  [n]\n  (let [m {1 \"I\" 4 \"IV\" 5  \"V\" 9 \"IX\" 10  \"X\" 40  \"XL\" 50 \"L\" 90 \"XC\" 100 \"C\" 400 \"CD\" 500 \"D\" 900 \"CM\" 1000 \"M\"}\n        v [1 4 5 9 10 40 50 90 100 400 500 900 1000]]\n    (loop [num n\n           r \"\"]\n      (if (= num 0)\n        r\n        (let [d (last(take-while #(<= % num) v))]\n          (recur (rem num d) (apply str r (repeat (int (/ num d)) (m d)))))))))","user":"57d0cd58e4b0bd073c20235e"},{"code":"(fn wnum [n]\n  (let [r (sorted-map-by > 1000 \"M\" 900 \"CM\" 500 \"D\" 400 \"CD\" 100 \"C\"\n                      90 \"XC\" 50 \"L\" 40 \"XL\" 10 \"X\" 9 \"IX\" 5 \"V\" 4 \"IV\" 1 \"I\")       \n        m (some #(when (>= (- n %) 0) %) (keys r))]\n  (when-not (nil? m)\n    (str (r m) (wnum (- n m))))))","problem":104,"user":"50435689e4b034ff00315d21"},{"code":"(fn to-roman [n]\n  (let [promote (fn [s] (apply str (map {\\I \\X \\V \\L \\X \\C \\L \\D \\C \\M \\D \\V} s)))\n\t\tones [\"\" \"I\" \"II\" \"III\" \"IV\" \"V\" \"VI\" \"VII\" \"VIII\" \"IX\"]\n\t\troms (vec (take 4 (iterate #(vec (map promote %)) ones)))\n\t\tdigits (->> n str (map (comp read-string str)))]\n\t(apply str (reverse (map-indexed #((roms %) %2) (reverse digits))))))","problem":104,"user":"50d0d4c8e4b00b15ecee976a"},{"problem":104,"code":"(fn [number] \n  (let [numerals [[\"\" \"I\" \"II\" \"III\" \"IV\" \"V\" \"VI\" \"VII\" \"VIII\" \"IX\"]\n\t\t\t\t  [\"\" \"X\" \"XX\" \"XXX\" \"XL\" \"L\" \"LX\" \"LXX\" \"LXXX\" \"XC\"]\n\t\t\t\t  [\"\" \"C\" \"CC\" \"CCC\" \"CD\" \"D\" \"DC\" \"DCC\" \"DCCC\" \"CM\"]\n \t\t\t\t  [\"\" \"M\" \"MM\" \"MMM\"]]\n        digits (->> number str (re-seq #\"\\d\") (map #(Integer/parseInt %)) reverse)]\n    (->> digits \n         (map-indexed (fn [y x] (-> numerals (nth y) (nth x))))\n    \t reverse\n         (apply str ))))","user":"5b72b36ce4b047b03b2036a9"},{"problem":104,"code":"(fn [n]\n  (let [nr {1 \"I\", 4 \"IV\", 100 \"C\", 900 \"CM\", 5 \"V\", 40 \"XL\", \n            1000 \"M\", 9 \"IX\", 10 \"X\", 400 \"CD\", 50 \"L\", 500 \"D\", 90 \"XC\"}\n        ks-init (reverse (sort (keys nr)))]\n    (loop [n n ks ks-init acc \"\"]\n      (cond\n        (= n 0) acc\n        (empty? ks) \"RAISE ERROR\"\n        :else (if (>= n (first ks))\n                (recur (- n (first ks)) ks (str acc (nr (first ks))))\n                (recur n (rest ks) acc))))))","user":"54b13a40e4b09f271ff37d1b"},{"problem":104,"code":"(fn [n]\n  (let [numerals {\"M\" 1000 \"CM\" 900 \"D\" 500 \"CD\" 400 \"C\" 100 \"XC\" 90 \"L\" 50 \"XL\" 40 \"X\" 10 \"IX\" 9 \"V\" 5 \"IV\" 4 \"I\" 1}\n        dec->roman (fn [n]\n                     (loop [n n [[c v] & nums :as all] (reverse (sort-by val numerals)) acc []]\n                       (cond\n                         (zero? n) (apply str acc)\n                         (> v n) (recur n nums acc)\n                         :else (recur (- n v) all (conj acc c)))))]\n    (dec->roman n)))","user":"5bbdd136e4b07a9b28b0ffab"},{"code":"(fn roman [n]\n (let [digits (map read-string (map str (seq (str n))))\n       paddigits (concat (take (- 4 (count digits)) (repeat 0))\n                         digits)]\n   (letfn\n     [(decode [d pos]\n        (nth (nth [[\"\" \"I\" \"II\" \"III\" \"IV\" \"V\" \"VI\" \"VII\" \"VIII\" \"IX\"]\n                   [\"\" \"X\" \"XX\" \"XXX\" \"XL\" \"L\" \"LX\" \"LXX\" \"LXXX\" \"XC\"]\n                   [\"\" \"C\" \"CC\" \"CCC\" \"CD\" \"D\" \"DC\" \"DCC\" \"DCCC\" \"CM\"]\n                   [\"\" \"M\" \"MM\" \"MMM\"]]\n                    pos)\n              d))]\n    (apply str (map decode paddigits '(3 2 1 0))))))","problem":104,"user":"4fe87e56e4b07c9f6fd12c40"},{"problem":104,"code":"(fn __ [num]\n  (let [nums-to-romans {1 \"I\" 5 \"V\" 10 \"X\" 50 \"L\" 100 \"C\" 500 \"D\" 1000 \"M\"}\n        subtrahend? (fn [num]\n                      (let [powers (set (take-while #(<= % num) (iterate #(* % 10) 1)))]\n                        (contains? powers num)))\n        values (->> nums-to-romans keys sort reverse (filter subtrahend?))\n        to-string (fn [divider amount]\n\t\t\t\t\t\t\t\t\t  (if (zero? amount)\n\t\t\t\t\t\t\t\t\t    \"\"\n\t\t\t\t\t\t\t\t\t    (if-let [upper (nums-to-romans (* divider (inc amount)))]\n\t\t\t\t\t\t\t\t\t      (str (nums-to-romans divider) upper)\n\t\t\t\t\t\t\t\t\t      (if (>= amount 5)\n\t\t\t\t\t\t\t\t\t        (apply str (nums-to-romans (* divider 5)) (repeat (- amount 5) (nums-to-romans divider)))\n\t\t\t\t\t\t\t\t\t        (apply str (repeat amount (nums-to-romans divider)))))))]\n    (loop [n num\n           dividers values\n           current \"\"]\n\t      (if (empty? dividers)\n          current\n\t        (let [divider (first dividers)\n                amount (quot n divider)\n\t              string-equiv (to-string divider amount)]\n           (recur \n             (- n (* amount divider))\n             (rest dividers)\n             (str current string-equiv)))))))","user":"55a62092e4b0acc240e31554"},{"problem":104,"code":"(fn roman-encode\n  [v]\n  (let [rn (sorted-map-by > 1 \"I\"\n                          4 \"IV\" 5 \"V\"\n                          9 \"IX\" 10 \"X\"\n                          40 \"XL\" 50 \"L\"\n                          90 \"XC\" 100 \"C\"\n                          400 \"CD\" 500 \"D\"\n                          900 \"CM\" 1000 \"M\")]\n    (letfn [(f [v [rf & r]]\n              (when-not (nil? rf)\n                (let [q  (quot v rf)\n                      rm (rem v rf)]\n                  (if (= 0 q)\n                    (f rm r)\n                    (str (apply str (repeat q (rn rf)))\n                         (f rm r))))))]\n      (f v (keys rn)))))","user":"54a11042e4b09f271ff37c49"},{"code":"(fn [n]\n  (let [basis {\"I\" 1 \"V\" 5 \"X\" 10 \"L\" 50 \"C\" 100 \"D\" 500 \"M\" 1000}\n        validpairs [\"IV\" \"IX\" \"XL\" \"XC\" \"CD\" \"CM\"]\n        pairs (for [[l r] validpairs]\n                {(str l r) (reduce - (map (fn [l] (basis (str l))) [r l]))})\n        singles (into basis pairs)\n        byval (into {} (map (fn [[k v]] [v k]) singles))\n        mults (mapcat\n               (fn [[k v]]\n                 (take-while (fn [[rn rnv]]\n                               (and (not (byval rnv))\n                                    (< rnv 4000)))\n                       (iterate\n                        (fn [[rn rnv]]\n                          [(str rn k) (+ rnv v)])\n                        [(str k k) (+ v v)])))\n               basis)\n        allnums (into singles mults)\n        byval (into {} (map (fn [[k v]] [v k]) allnums))\n        nums (keys byval)]\n    (letfn [(->rom [n]\n              (if (pos? n)\n                (let [avail (filter #(<= % n) nums)]\n                  (if (seq avail)\n                    (let [m (apply max avail)\n                          s (byval m)]\n                      (str s (->rom (- n m))))\n                    \"\"))\n                \"\"))]\n      (->rom n))))","problem":104,"user":"4ffc10aae4b0678c553fc3d6"},{"code":"(fn a [n]\n  (let [ones [nil \"I\" \"II\" \"III\" \"IV\" \"V\" \"VI\" \"VII\" \"VIII\" \"IX\"]\n        tens [nil \"X\" \"XX\" \"XXX\" \"XL\" \"L\" \"LX\" \"LXX\" \"LXXX\" \"XC\"]\n        huns [nil \"C\" \"CC\" \"CCC\" \"CD\" \"D\" \"DC\" \"DCC\" \"DCCC\" \"CM\"]\n        thos [nil \"M\" \"MM\" \"MMM\"]\n        m (quot n 1000)\n        h (quot (rem n 1000) 100)\n        t (quot (rem n 100) 10)\n        o (rem n 10)]\n    (str (thos m) (huns h) (tens t) (ones o))))","problem":104,"user":"52b405e1e4b0c58976d9ad15"},{"problem":104,"code":"(fn write-roman [n]\n  (let [decomp {0 []\n                1 [:one]\n                2 [:one :one]\n                3 [:one :one :one]\n                4 [:one :five]\n                5 [:five]\n                6 [:five :one]\n                7 [:five :one :one]\n                8 [:five :one :one :one]\n                9 [:one :ten]}\n        transl {0 {:one \"I\" :five \"V\" :ten \"X\"}\n                1 {:one \"X\" :five \"L\" :ten \"C\"}\n                2 {:one \"C\" :five \"D\" :ten \"M\"}\n                3 {:one \"M\" :five \"?\" :ten \"?\"}}]\n    (letfn [(digits [n]\n              (loop [n n\n                     r '()]\n                (if (= n 0)\n                  r\n                  (recur (quot n 10) (conj r (rem n 10))))))\n            (roman [d e]\n              (let [t (transl e)\n                    p (decomp d)]\n                (reduce #(str %1 (t %2)) \"\" p)))]\n      (loop [s (digits n)\n             r \"\"]\n        (if (empty? s)\n          r\n          (recur (rest s) (str r (roman (first s) (dec (count s))))))))))","user":"5f8b06afe4b0715f5002d74a"},{"problem":104,"code":"(fn write-roman-numbers\n   [x]\n   (let [arr [{\"1\" \"I\" \"2\" \"II\" \"3\" \"III\" \"4\" \"IV\" \"5\" \"V\"\n               \"6\" \"VI\" \"7\" \"VII\" \"8\" \"VIII\" \"9\" \"IX\"}\n              {\"1\" \"X\" \"2\" \"XX\" \"3\" \"XXX\" \"4\" \"XL\" \"5\" \"L\"\n               \"6\" \"LX\" \"7\" \"LXX\" \"8\" \"LXXX\" \"9\" \"XC\"}\n              {\"1\" \"C\" \"2\" \"CC\" \"3\" \"CCC\" \"4\" \"CD\" \"5\" \"D\"\n               \"6\" \"DC\" \"7\" \"DCC\" \"8\" \"DCCC\" \"9\" \"CM\"}\n              {\"1\" \"M\" \"2\" \"MM\" \"3\" \"MMM\"}]\n         ]\n     (apply str (reverse (map-indexed #((nth arr %) (str %2)) (reverse (str x)))))))","user":"56a36f76e4b0542e1f8d14ca"},{"problem":104,"code":"(fn to-roman-numerals [n]\n  (let [table [[1000 \"M\"]\n               [900 \"CM\"]\n               [500 \"D\"]\n               [400 \"CD\"]\n               [100 \"C\"]\n               [90 \"XC\"]\n               [50 \"L\"]\n               [40 \"XL\"]\n               [10 \"X\"]\n               [9 \"IX\"]\n               [5 \"V\"]\n               [4 \"IV\"]\n               [1 \"I\"]]]\n               \n    (loop [n n\n           r \"\"\n           c 1000]\n      (when-not (zero? c)\n        (if (zero? n)\n          r\n          (let [[nr st] (first (filter (fn [[nr st]] (>= n nr)) table))]\n            (recur (- n nr) (str r st) (dec c))))))))","user":"5d6042f2e4b0c9e5857d5006"},{"problem":104,"code":"(fn solution [decimal]\n  (let [dict {1    \"I\"\n              4    \"IV\"\n              5    \"V\"\n              9    \"IX\"\n              10   \"X\"\n              40   \"XL\"\n              50   \"L\"\n              90   \"XC\"\n              100  \"C\"\n              400  \"CD\"\n              500  \"D\"\n              900  \"CM\"\n              1000 \"M\"\n              4000 \"INF\"}]\n    (loop [result \"\"\n           number decimal]\n      (let [divisor (last (take-while #(<= % number) (sort (keys dict))))]\n        (if (zero? number)\n          result\n          (recur (apply str result\n                        (repeat (quot number divisor) (get dict divisor)))\n                 (rem number divisor)))))))","user":"5e2ef900e4b05b4b015161fc"},{"code":"(fn to-roman [arabic]\n(let [\ndigits [1 5 10 50 100 500 1000]\nvalues {1 \"I\", 5 \"V\", 10 \"X\", 50 \"L\", 100 \"C\", 500 \"D\", 1000 \"M\"}\nsubs {\"IIII\" \"IV\", \"VIIII\" \"IX\", \"XXXX\" \"XL\", \n      \"LXXXX\" \"XC\", \"CCCC\" \"CD\", \"DCCCC\" \"CM\"}\nmcg (fn mcg\n  ([total bills so-far]\n   (let [b (first bills)\n         new-total (rem total b)\n         n (quot total b)\n         new-so-far (assoc so-far b n)\n         new-bills (filter #(<= % new-total) bills)]\n     (if (zero? new-total) new-so-far\n       (recur new-total new-bills new-so-far))))\n  ([total bills]\n   (mcg total\n    (reverse (take-while #(<= % total) bills)) {})))\nraw (apply str (reverse (flatten (map (fn [[k v]] (repeat v (values k))) (mcg arabic digits)))))]\n  (reduce (fn [s [b a]](.replace s b a)) raw (reverse subs))))","problem":104,"user":"4dcfbc44535d5973398f92a7"},{"code":"(fn [n]\n  (let [v [[\"M\" 1000]\n           [\"CM\" 900]\n           [\"D\"  500]\n           [\"CD\" 400]\n           [\"C\"  100]\n           [\"XC\"  90]\n           [\"L\"   50]\n           [\"XL\"  40]\n           [\"X\"   10]\n           [\"IX\"   9]\n           [\"V\"    5]\n           [\"IV\"   4]\n           [\"I\"    1]]]\n    (loop [r \"\" c n]\n      (if (> c 0)\n        (let [[k v] (first (filter #(if (>= c (second %)) %) v))]\n          (recur (str r k) (- c v)))\n        r))))","problem":104,"user":"4e49badd535dc968683fc4c9"},{"code":"(fn [x]\n  (letfn [(foo [val n]\n            (let [vvals {1 \"I\" 5 \"V\" 10 \"X\" 50 \"L\" 100 \"C\" 500 \"D\" 1000 \"M\"}\n                  letter (vvals val)\n                  quantity (int (/ n val))]\n              (cond (and (= 1000 val) (= 9 (int (/ (- n (* quantity val)) 100))))\n                    [[[letter quantity] [\"C\" 1] [\"M\" 1]] (- (mod n val) 900)]\n                    (and (= 100 val) (= 9 (int (/ (- n (* quantity val)) 10))))\n                    [[[letter quantity] [\"X\" 1] [\"C\" 1]] (- (mod n val) 90)]\n                    (and (= 50 val) (= 4 (int (/ n 10))))\n                    [[[letter quantity] [\"X\" 1] [\"L\" 1]] (- n 40)]\n                    (and (= 10 val) (= 9 (int (/ (- n (* quantity val)) 1))))\n                    [[[letter quantity] [\"I\" 1] [\"X\" 1]] (- (mod n val) 9)]\n                    (and (= 5 val) (= n 4))\n                    [[[letter quantity] [\"I\" 1] [\"V\" 1]] 0]          \n                    :else [[letter quantity] (mod n val)])))\n          (roman [num]\n            (loop [r [] n num v [1000 500 100 50 10 5 1]]\n              (if (empty? v)\n                r\n                (let [[rseqe nn] (foo (first v) n)]\n                  (recur (conj r rseqe) nn (rest v))))))\n          (rr [n]\n            (filter #(not= 0 (second %))\n                    (partition 2 2 (flatten (roman n)))))\n          (to-roman [r]\n            (apply str (flatten (map #(repeat (second %) (first %)) r))))]\n    (to-roman (rr x))))","problem":104,"user":"4e773be8535d324fb2983d6e"},{"problem":104,"code":"#(loop [n % t \"IVXLCDM\" r '()]\n  (if (= n 0) (apply str r)\n    (let [m (mod n 10)]\n      (case m\n        (9 4) (recur (- n (dec m)) t (conj r (nth t (quot m 4))))\n        (recur (quot n 10) (drop 2 t)\n               (conj (reduce conj r (repeat (mod m 5) (first t)))\n                     (when (> m 4)\n                       (second t))))))))","user":"57d9f603e4b0bd073c20240a"},{"code":"(fn [s x]\n  (if (= 0 x)\n    s\n    (let [[k v] (some (fn [[k v]] (if (<= k x) [k v]))\n                      (partition-all 2\n                                     [1000 \"M\", 900 \"CM\",\n                                       500 \"D\", 400 \"CD\",\n                                       100 \"C\",  90 \"XC\",\n                                        50 \"L\",  40 \"XL\",\n                                        10 \"X\",   9 \"IX\",\n                                         5 \"V\",   4 \"IV\",\n                                         1 \"I\"]))]\n      (recur (str s v)\n             (- x k)))))\n\"\"","problem":104,"user":"535d910ae4b04ce2eb3ed2c5"},{"problem":104,"code":"(fn [ara-num]\n  (let [rom-num-vec [[1000 \\M] [500 \\D] [100 \\C] [50 \\L]\n                     [10 \\X] [5 \\V] [1 \\I]]\n        short-vec [[\"DCCCC\" \"CM\"] [\"CCCC\" \"CD\"] \n                   [\"LXXXX\" \"XC\"] [\"XXXX\" \"XL\"]\n                   [\"VIIII\" \"IX\"] [\"IIII\" \"IV\"]]\n        subnot (fn sn [rns sv]\n                 (if (empty? sv)\n                   rns\n                   (let [[old new] (first sv)]\n                     (sn (clojure.string/replace-first rns old new) (rest sv)))))]\n    (loop [out [] in ara-num rn rom-num-vec]\n      (if (or (= in 0) (empty? rn))\n        (subnot (apply str out) short-vec)\n        (let [[n c] (first rn)]\n          (if (>= in n)\n             (recur (conj out c) (- in n) rn)\n             (recur out in (rest rn))))))))","user":"564a5a09e4b0284900eef656"},{"problem":104,"code":"(letfn [(f [b l n]\n          (-> [(apply str (repeat (int (/ n b)) l)) (rem n b)]))]\n  (let [fs (map (fn [[b l]] (partial f b l))\n                (partition 2 [1000 \\M 900 \"CM\" 500 \\D 400 \"CD\" 100 \\C 90 \"XC\"\n                              50 \\L 40 \"XL\" 10 \\X 9 \"IX\" 5 \\V 4 \"IV\" 1 \\I]))]\n    (fn [n]\n      (loop [fs fs n n v []]\n        (if (seq fs)\n          (let [[cs r] ((first fs) n)]\n            (recur (rest fs) r (conj v cs)))\n          (apply str v))))))","user":"54f0d3fde4b024c67c0cf8a6"},{"code":"(fn roman [x]\n  (let [digits (reverse (map #(- (int %) 48) (str x)))\n        place-roman (fn [p] (case p 1 \\I 2 \\X 3 \\C 4 \\M))\n        half-roman (fn [p] (case p 1 \\V 2 \\L 3 \\D))\n        compute-place (fn [y p] (cond \n                                  (= y 9) [(place-roman p) (place-roman (+ p 1))]\n                                  (>= y 5) (cons (half-roman p) (repeat (- y 5) (place-roman p)))\n                                  (= y 4) [(place-roman p) (half-roman p)]\n                                  :else (repeat y (place-roman p))))\n        compute-places (fn cplaces ([p y & ys] (concat (apply cplaces (cons (+ p 1) ys)) (compute-place y p)))                    \n                             \t   ([p] []))]\n    (apply str (apply compute-places (cons 1 digits)))))","problem":104,"user":"515fb48fe4b0e2be8aa20bd5"},{"problem":104,"code":"(fn [n]\n (let [a [1000,900,500,400,100,90,50,40,10,9,5,4,1]\n       c (zipmap a [\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"])]\n  (loop [n n [h & t :as all] a s \"\"]\n   (cond\n    (< n 1) s\n    (< n h) (recur n t s)\n    :else (recur (- n h) all (str s (c h)))))))","user":"5b0180cfe4b0cc2b61a3bd47"},{"code":"(fn dec2roman [d]\n  (let [v (map vector [1000 900 500 400 100 90 50 40 10 9 5 4 1]\n               [\"M\" \"CM\" \"D\" \"CD\" \"C\" \"XC\" \"L\" \"XL\" \"X\" \"IX\" \"V\" \"IV\" \"I\"])\n        convert (fn conv [x smap]\n                  (if (= 0 x)\n                    []\n                    (if (>= x (ffirst smap))\n                      (lazy-seq (cons (second (first smap)) (conv (- x (ffirst smap)) smap)))\n                      (conv x (rest smap)))))]\n    (apply str (convert d v))))","problem":104,"user":"51d96ad0e4b02ceefd94774f"},{"code":"(fn [n]\n  (let [rns {4 \"M\" 3.5 \"D\" 3 \"C\" 2.5 \"L\" 2 \"X\" 1.5 \"V\" 1 \"I\"}\n        ds (map #(Integer/parseInt (str %)) (str n))\n        ids (map-indexed #(vector (- (count ds) %1) %2) ds)]\n    (letfn [(r [i n]\n              (cond\n                (= n 9) [(rns i) (rns (+ i 1))]\n                (= n 4) [(rns i) (rns (+ i 0.5))]\n                (>= n 5) (concat (rns (+ i 0.5)) (repeat (- n 5) (rns i)))\n                :else (repeat n (rns i))))]\n      (apply str (reduce #(concat %1 (r (first %2) (second %2))) [] ids)))))","problem":104,"user":"4e6a2f51535d8ccf87e9fea9"},{"problem":104,"code":"(fn roman-str [n]\n            (let [roman-numbers (partition 2 [\"M\" 1000 \"CM\" 900 \"D\" 500 \"CD\" 400 \"C\" 100\n                                              \"XC\" 90 \"L\" 50 \"XL\" 40 \"X\" 10 \"IX\" 9 \"V\" 5 \"IV\" 4 \"I\" 1])]\n              (if (zero? n)\n                \"\"\n                (let [[letters number] (first (drop-while #(> (second %) n) roman-numbers))]\n                  (str letters (roman-str (- n number)))))))","user":"53f891eee4b0de5c4184856d"},{"problem":104,"code":"(fn [n]\n  (let [ones ({0 \"\" 1 \"I\" 2 \"II\" 3 \"III\" 4 \"IV\" 5 \"V\" 6 \"VI\" 7 \"VII\" 8 \"VIII\" 9 \"IX\"} (mod n 10))\n        tens ({0 \"\" 1 \"X\" 2 \"XX\" 3 \"XXX\" 4 \"XL\" 5 \"L\" 6 \"LX\" 7 \"LXX\" 8 \"LXXX\" 9 \"XC\"} (int (/ (mod n 100) 10)))\n        huns ({0 \"\" 1 \"C\" 2 \"CC\" 3 \"CCC\" 4 \"CD\" 5 \"D\" 6 \"DC\" 7 \"DCC\" 8 \"DCCC\" 9 \"CM\"} (int (/ (mod n 1000) 100)))\n        thos ({0 \"\" 1 \"M\" 2 \"MM\" 3 \"MMM\"} (int (/ (mod n 10000) 1000)))]\n    (str thos huns tens ones)))","user":"5db92996e4b010eb3c36cd50"},{"code":"(fn f [n] \n  (if (> n 0)\n   (let [ir (sorted-map 1 \"I\" 4 \"IV\" 5 \"V\" 9 \"IX\" 10 \"X\" \n\t\t\t      40 \"XL\" 50 \"L\" 90 \"XC\" 100 \"C\" 400 \"CD\" \n\t\t\t      500 \"D\" 900 \"CM\" 1000 \"M\")\n\t       m (last (filter #(<= % n) (keys ir)))]\n\t   (str (ir m) (f (- n m))))))","problem":104,"user":"4dada16fc9a9d6ed2699dc57"},{"problem":104,"code":"(fn arabic->roman [d]\n  {:pre [(< d 4000)]}\n  (loop [d d res \"\"]\n    (condp #(>= %2 %1) d\n      1000 (recur (- d 1000) (str res \"M\"))\n      900 (recur (- d 900) (str res \"CM\"))\n      500 (recur (- d 500) (str res \"D\"))\n      400 (recur (- d 400) (str res \"CD\"))\n      100 (recur (- d 100) (str res \"C\"))\n      90 (recur (- d 90) (str res \"XC\"))\n      50 (recur (- d 50) (str res \"L\"))\n      40 (recur (- d 40) (str res \"XL\"))\n      10 (recur (- d 10) (str res \"X\"))\n      9 (recur (- d 9) (str res \"IX\"))\n      5 (recur (- d 5) (str res \"V\"))\n      4 (recur (- d 4) (str res \"IV\"))\n      1 (recur (- d 1) (str res \"I\"))\n      res)))","user":"5f300f28e4b033932238a682"},{"problem":104,"code":"#(letfn[(genRoman [value, oneVal, oneSym, fiveSym, tenSym]\n                  (let [quoted (quot value oneVal)]\n                    (cond\n                     (= quoted 9) (list tenSym oneSym)\n                     (= quoted 4) (list fiveSym oneSym)\n                     (= quoted 5) (list fiveSym)\n                     (> quoted 5) (concat (repeat (- quoted 5) oneSym) (list fiveSym))\n                     :else (repeat quoted oneSym))))]\n  (loop [value %, result '(), steps [1000, 100, 10 1]]\n    (let [step (first steps)]\n      (cond\n       (= step 1) (apply str (reverse (concat (genRoman value 1 \\I \\V \\X) result)))\n       (= step 10) (recur (rem value 10) (concat (genRoman value 10 \\X \\L \\C) result) (rest steps))\n       (= step 100) (recur (rem value 100) (concat (genRoman value 100 \\C \\D \\M) result) (rest steps))\n       :else (recur (rem value 1000) (concat (genRoman value 1000 \\M \\v \\c) result) (rest steps))))))","user":"556c70dae4b09a3098a524fd"},{"problem":104,"code":"(fn [arabic]\n  (let\n   [conv\n    (fn [one five ten]\n      #(apply\n        str\n        (case\n         %\n         \\0 \"\"\n         \\1 one\n         \\2 (repeat 2 one)\n         \\3 (repeat 3 one)\n         \\4 (concat one five)\n         \\5 five\n         \\6 (concat five one)\n         \\7 (concat five one one)\n         \\8 (concat five one one one)\n         \\9 (concat one ten))))\n    units (conv \"I\" \"V\" \"X\")\n    tens (conv \"X\" \"L\" \"C\")\n    hundreds (conv \"C\" \"D\" \"M\")\n    thousands\n     #(apply\n      str\n      (repeat\n       (Integer/parseInt (str %))\n       \"M\"))\n    ]\n   (apply\n    str\n    (reverse\n     (map\n      (fn [r a]\n       (r a))\n      [units tens hundreds thousands]\n      (reverse (str arabic)))))))","user":"586a657de4b0f14aab7c88bd"},{"problem":104,"code":"(fn num-to-roman [n]\n  (let [digits (zipmap [900  400   90   40   9    4  1000 500 100 50  10   5   1]\n                       [\"CM\" \"CD\" \"XC\" \"XL\" \"IX\" \"IV\" \"M\" \"D\" \"C\" \"L\" \"X\" \"V\" \"I\"])]\n    (apply str (first (reduce (fn [[res n] d]\n                                [(concat res (repeat (quot n d) (digits d))) (rem n d)])\n                              [[] n] (sort > (keys digits)))))))","user":"575b3e9be4b02ea11479935b"},{"problem":104,"code":"(fn [n]\n    (let [ds [[1000 \"M\"],\n              [900  \"CM\"],\n              [500  \"D\"],\n              [400  \"XD\"],\n              [100  \"C\"],\n              [90   \"XC\"],\n              [50   \"L\"],\n              [40   \"XL\"],\n              [10   \"X\"],\n              [9    \"IX\"]\n              [5    \"V\"],\n              [4    \"IV\"]\n              [1    \"I\"]]]\n      (->>\n        (loop [r    n\n               ds   ds   \n               coll []]\n          (if (zero? r)\n            coll\n            (let [[m d] (first ds)]\n              (if (< r m)\n                (recur r (rest ds) coll)\n                (recur (- r m) ds (conj coll d))))))\n        (apply str))))","user":"59fa241ee4b0ca45a743a358"},{"code":"(fn [number]\n    (let [m (sorted-map-by > \n                         1000 \"M\" \n                         900 \"CM\"\n                         500 \"D\" \n                         100 \"C\" \n                         90 \"XC\"\n                         50 \"L\" \n                         40 \"XL\" \n                         10 \"X\" \n                         9 \"IX\" \n                         5 \"V\" \n                         4 \"IV\" \n                         1 \"I\")]\n    (loop [n number\n           s \"\"]\n      (if (> n 0)\n        (let [[n1 s1] (->> m (filter #(<= (first %) n)) first)]\n          (recur (- n n1) (str s s1)))\n        s))))","problem":104,"user":"4ec57e4a535d6d7199dd36a4"},{"problem":104,"code":"(fn to-roman [n]\n  (let [thousands ([\"\" \"M\" \"MM\" \"MMM\" \"MMMM\" \"MMMMM\" \"MMMMMM\" \"MMMMMMM\" \"MMMMMMMM\"]\n                   (quot n 1000))\n        hundreds ([\"\" \"C\" \"CC\" \"CCC\" \"CD\" \"D\" \"DC\" \"DCC\" \"DCCC\" \"CM\"]\n                  (mod (quot n 100) 10))\n        tens ([\"\" \"X\" \"XX\" \"XXX\" \"XL\" \"L\" \"LX\" \"LXX\" \"LXXX\" \"XC\"]\n              (mod (quot n 10) 10))\n        units ([\"\" \"I\" \"II\" \"III\" \"IV\" \"V\" \"VI\" \"VII\" \"VIII\" \"IX\"]\n               (mod n 10))]\n    (str thousands hundreds tens units)))","user":"561d23e3e4b064ca9f4b16a5"},{"problem":104,"code":"(fn [n]\n  (let [v [1000 900 500 400 100 90 50 40 10 9 5 4 1]\n        r (zipmap v [\"M\" \"CM\" \"D\" \"CD\" \"C\" \"XC\" \"L\" \"XL\" \"X\" \"IX\" \"V\" \"IV\" \"I\"])]\n    (loop [n n [v & vs] v roman \"\"]\n      (cond\n        (zero? n) roman\n        (zero? (quot n v)) (recur n vs roman)\n        :else (recur (mod n v) vs (apply str roman (repeat (quot n v) (get r v))))))))","user":"54ddb556e4b024c67c0cf798"},{"code":"(fn [n]\n  (let [thousands (rem (quot n 1000) 10)\n        hundreds (rem (quot n 100) 10)\n        tens (rem (quot n 10) 10)\n        ones (rem n 10)\n        to-r (fn [x ones fives tens]\n               (cond (= x 9) (str ones tens)\n                     (>= x 5) (apply str fives (repeat (- x 5) ones))\n                     (= x 4) (str ones fives)\n                     :else (apply str (repeat x ones))))]\n    (str (to-r thousands \"M\" \"?\" \"?\")\n         (to-r hundreds \"C\" \"D\" \"M\")\n         (to-r tens \"X\" \"L\" \"C\")\n         (to-r ones \"I\" \"V\" \"X\"))))","problem":104,"user":"514721c6e4b0d520409ed392"},{"problem":104,"code":"(fn num->rom [n]\n  (let [rom-nums      {0 \"\", 1 \\I, 5 \\V, 10 \\X, 50 \\L, 100 \\C, 500 \\D, 1000 \\M}\n        digits-of-num (->> n\n                           (iterate #(quot % 10))\n                           (take-while pos?)\n                           (map #(mod % 10)))\n        ;; возвращаяет вектор(ы) типа [n p] где n кол-во раз которое нужно повторить число p\n        ;; например число 38, разбивается на 3 * 10 ^ 1 + 8 * 10 ^ 0\n        ;; соответственно\n        ;; (i 3 10) => [3 10] => [3 \\X]\n        ;; (i 8 1) => [[1 5] [3 1]] => [[1 \\V] [3 \\I]]\n        i             (fn i [n p]\n                        (cond\n                          (> 4 n) [n p]\n                          (= 4 n) [(i 1 p) (i 5 p)]\n                          (= 5 n) [1 (* 5 p)]\n                          (> 9 n) [(i 5 p) (i (- n 5) p)]\n                          (= 9 n) [1 p 1 (* 10 p)]))]\n    (->> (map (fn [p n] (i n (int (Math/pow 10 p)))) (range (count digits-of-num)) digits-of-num)\n         reverse\n         flatten\n         (partition 2)\n         (mapcat (fn [[v k]] (repeat v (rom-nums k))))\n         (apply str))))","user":"5d29c06be4b01671435dbc6b"},{"problem":104,"code":"(fn r [n]\n  (if (= n 0)\n    \"\"\n    (let [[v s] (first (drop-while (fn [[x]] (> x n)) (partition 2 [1000 \"M\" 900 \"CM\" 500 \"D\" 400 \"CD\" 100 \"C\" 90 \"XC\" 50 \"L\" 40 \"XL\" 10 \"X\" 9 \"IX\" 5 \"V\" 4 \"IV\" 1 \"I\"])))]\n      (str s (r (- n v))))))","user":"5742ec91e4b05c31a32c0883"},{"code":"#(loop [n % [t & ts] [[\"\" \"I\" \"II\" \"III\" \"IV\" \"V\" \"VI\" \"VII\" \"VIII\" \"IX\"] [\"\" \"X\" \"XX\" \"XXX\" \"XL\" \"L\" \"LX\" \"LXX\" \"LXXX\" \"XC\"] [\"\" \"C\" \"CC\" \"CCC\" \"CD\" \"D\" \"DC\" \"DCC\" \"DCCC\" \"CM\"] [\"\" \"M\" \"MM\" \"MMM\"]] acc nil] (if (= 0 n) (apply str acc) (recur (quot n 10) ts (cons (t (mod n 10)) acc))))","problem":104,"user":"51bd1a0de4b0df1216cefd93"},{"problem":104,"code":"(fn roman [n]\n  (apply str (cond\n               (zero? n) []\n               (>= n 1000) (cons \\M (roman (- n 1000)))\n               (>= n 900) (concat [\\C \\M] (roman (- n 900)))\n               (>= n 500) (cons \\D (roman (- n 500)))\n               (>= n 400) (concat [\\C \\D] (roman (- n 400)))\n               (>= n 100) (cons \\C (roman (- n 100)))\n               (>= n 90) (concat [\\X \\C] (roman (- n 90)))\n               (>= n 50) (cons \\L (roman (- n 50)))\n               (>= n 40) (concat [\\X \\L] (roman (- n 40)))\n               (>= n 10) (cons \\X (roman (- n 10)))\n               (>= n 9) (concat [\\I \\X] (roman (- n 9)))\n               (>= n 5) (cons \\V (roman (- n 5)))\n               (>= n 4) (concat [\\I \\V] (roman (- n 4)))\n               (>= n 1) (cons \\I (roman (- n 1))))))","user":"58a0fc33e4b02bd94d917ea3"},{"problem":104,"code":"(fn roman-numerals [n]\n  (if (zero? n) \n    \"\"\n    (let [\n          conversions [\n                         [1000 \"M\"]\n                         [900 \"CM\"]\n                         [500 \"D\"]\n                         [400 \"CD\"]\n                         [100 \"C\"]\n                         [90 \"XC\"]\n                         [50 \"L\"]\n                         [40 \"XL\"]\n                         [10 \"X\"]\n                         [9 \"IX\"]\n                         [5 \"V\"]\n                         [4 \"IV\"]\n                         [1 \"I\"]\n                        ]\n          [arabic roman] (first (filter #(>= n (first %)) conversions))]\n      (str roman (roman-numerals (- n arabic))))))","user":"5632d1b3e4b0bfe05bf117a9"},{"problem":104,"code":"(fn to-roman [n]\n   (if (= n 0) \"\"\n     (let [rs [[1000 \"M\"] [900 \"CM\"] [500 \"D\"] [400 \"CD\"] [100 \"C\"] [90 \"XC\"] \n               [50 \"L\"] [40 \"XL\"] [10 \"X\"] [9 \"IX\"] [5 \"V\"] [4 \"IV\"] [1 \"I\"]]\n           r (first (filter #(<= (first %) n) rs))]\n       (str (second r) (to-roman (- n (first r)))))))","user":"53b39d82e4b047364c0444a6"},{"code":"(fn [n]\n    (let [rs [\n             1000 \"M\"\n              900 \"CM\"\n              500 \"D\"\n              400 \"CD\"\n              100 \"C\"\n               90 \"XC\"\n               50 \"L\"\n               40 \"XL\"\n               10 \"X\"\n                9 \"IX\"\n                5 \"V\"\n                4 \"IV\"\n                1 \"I\"\n              ]]\n      (apply str\n         (map first\n            (take-while  #(not (nil? %))\n                          (iterate\n                           (fn [[_ m s]]\n                             (if (not (nil? s))\n                               (let [[[nr st] & r] s]\n                                 (if (>= m nr) \n                                   [st (- m nr) s]\n                                   [\"\" m r]))))\n                               [\"\" n (partition 2 rs)]))))))","problem":104,"user":"4e6dc95a535d5021c1a895f1"},{"code":"#(let [m [1000 900 500 400 100 90 50 40 10 9 5 4 1]\n       r (zipmap m [\"M\" \"CM\" \"D\" \"CD\" \"C\" \"XC\" \"L\" \"XL\" \"X\" \"IX\" \"V\" \"IV\" \"I\"])]\n   (apply str\n     (map r ((fn g [[f & r :as m] n]\n               (cond (zero? n) nil\n                     (<= f n) (cons f (g m (- n f)))                        \n                     :else (g r n)))\n              m %))))","problem":104,"user":"4ea09fa4535d7eef308072aa"},{"problem":104,"code":"#(let [f (fn [n] \n  (cond \n   \t(>= n 1000) [\"M\" \t(- n 1000)]  \n    (>= n 900)  [\"CM\" \t(- n 900)]\n    (>= n 500)  [\"D\"  \t(- n 500)]\n    (>= n 400)  [\"CD\" \t(- n 400)]\n    (>= n 100)  [\"C\" \t(- n 100)]\n    (>= n 90)   [\"XC\" \t(- n 90)]\n    (>= n 50)   [\"L\" \t(- n 50)]\n    (>= n 40)   [\"XL\" \t(- n 40)]\n    (>= n 10)   [\"X\" \t(- n 10)]\n    (= n 9)     [\"IX\" \t      0]\n    (>= n 5)    [\"V\" \t(- n 5)]\n    (= n 4)     [\"IV\" \t      0]\n    (>= n 1)    [\"I\" \t(- n 1)]\n    :else \t\t[\"\"           0]\n   ))]\n   (apply str (loop [[d n] (f %) a \"\"]\n                (if (= 0 n)\n                  (concat a d)\n                  (recur (f n) (concat a d))))))","user":"4faf97d8e4b081705acca258"},{"problem":104,"code":"(fn [n]\n  (let  [r {1000 \"M\",900 \"CM\",500 \"D\",400 \"CD\", 100 \"C\", 90 \"XC\", 50 \"L\", 40 \"XL\", 10 \"X\", 9 \"IX\", 5 \"V\", 4 \"IV\", 1 \"I\"}]\n    (first (reduce (fn [[s n] e]\n                     (loop [s s n n]\n                       (if (< n e)\n                         [s n]\n                         (recur (str s (r e)) (- n e)))))\n                   [\"\" n] (reverse (sort (keys r)))))))","user":"543d5c61e4b032a45b86934d"},{"problem":104,"code":"(let [v (zipmap (range 7)  [\"I\" \"V\" \"X\" \"L\" \"C\" \"D\" \"M\"])\n      dd (fn [d] (into {} (map-indexed #(vector % %2) [[] [d] [d d] [d d d] [d (inc d)] [(inc d)] [(inc d) d] [(inc d) d d] [(inc d) d d d] [d (+ 2 d)]])))\n      num (fn [i x] (map v ((dd (* 2 i)) x)))\n      split (fn [x] (map read-string (map str (str x))))]\n(fn [x] (apply str (apply concat (reverse (map-indexed num (reverse (split x)))))))  )","user":"5c683fb5e4b0fca0c16226d5"},{"problem":104,"code":"(fn roman [ n ] \n  (let [\n       [d1 d2 d3 d4]  (take-last 4 (map #(Character/digit % 10) (seq (str \"0000\" n))))\n       romanX  (fn [n I V X] (cond \n                           (= n 0) (str \"\")\n                           (= n 1) (str I)\n                           (= n 2) (str I I)\n                           (= n 3) (str I I I)\n                           (= n 4) (str I V)\n                           (= n 5) (str V)\n                           (= n 6) (str V I)\n                           (= n 7) (str V I I)\n                           (= n 8) (str V I I I)\n                           (= n 9) (str I X)\n                             ))\n        ]\n    (str \n       (apply str (repeat d1 'M))\n       (romanX d2 'C 'D 'M)\n       (romanX d3 'X 'L 'C)\n  \t   (romanX d4 'I 'V 'X))\n    \t \t   \t   ))","user":"57887de2e4b0ebec4cfb751c"},{"code":"(fn to-rom\n  [n]\n  (let [dicts '({1 \"M\"\n                 2 \"MM\"\n                 3 \"MMM\"}\n                {1 \"C\"\n                 2 \"CC\"\n                 3 \"CCC\"\n                 4 \"CD\"\n                 5 \"D\"\n                 6 \"DC\"\n                 7 \"DCC\"\n                 8 \"DCCC\"\n                 9 \"CM\"}\n                {1 \"X\"\n                 2 \"XX\"\n                 3 \"XXX\"\n                 4 \"XL\"\n                 5 \"L\"\n                 6 \"LI\"\n                 7 \"LII\"\n                 8 \"LIII\"\n                 9 \"XC\"}\n                {1 \"I\"\n                 2 \"II\"\n                 3 \"III\"\n                 4 \"IV\"\n                 5 \"V\"\n                 6 \"VI\"\n                 7 \"VII\"\n                 8 \"VIII\"\n                 9 \"IX\"})\n      \n        ls ((fn _ [n]\n                (if (zero? (quot n 10))\n                  [(rem n 10)]\n                  (conj (_ (quot n 10)) (rem n 10)))) n)\n        ]\n    (apply str (map (fn[dict d] (get dict d)) (drop (- 4 (count ls)) dicts) ls))))","problem":104,"user":"5301157ae4b0d8b024fd3717"},{"code":"(fn roman [n]\n  (loop [number n numeral \"\"]\n      (cond\n        (>= number 1000) (recur (- number 1000) (str numeral \"M\"))\n        (>= number 900) (recur (- number 900) (str numeral \"CM\"))\n        (>= number 500) (recur (- number 500) (str numeral \"D\"))\n        (>= number 400) (recur (- number 400) (str numeral \"CD\"))\n        (>= number 100) (recur (- number 100) (str numeral \"C\"))\n        (>= number 90) (recur (- number 90) (str numeral \"XC\"))\n        (>= number 50) (recur (- number 50) (str numeral \"L\"))\n        (>= number 40) (recur (- number 40) (str numeral \"XL\"))\n        (>= number 10) (recur (- number 10) (str numeral \"X\"))\n        (>= number 9) (recur (- number 9) (str numeral \"IX\"))\n        (>= number 5) (recur (- number 5) (str numeral \"V\"))\n        (>= number 4) (recur (- number 4) (str numeral \"IV\"))\n        (>= number 1) (recur (- number 1) (str numeral \"I\"))\n        (= number 0) numeral)))","problem":104,"user":"52cefb7ee4b07d0d72b27397"},{"problem":104,"code":"(fn roman [n]\n               ((fn helper [x ans]\n                  (if (= 0 x)\n                    ans\n                    (if (>= x 1000)\n                      (helper (- x 1000) (str ans \"M\" ))\n                      (if (>= x 900)\n                        (helper (- x 900) (str ans \"CM\"))\n                        (if (>= x 500)\n                          (helper (- x 500) (str ans \"D\"))\n                          (if (>= x 400)\n                            (helper (- x 400) (str ans \"CD\"))\n                            (if (>= x 100)\n                              (helper (- x 100) (str ans \"C\"))\n                              (if (>= x 90)\n                                (helper (- x 90) (str ans \"XC\"))\n                                (if (>= x 50)\n                                  (helper (- x 50) (str ans \"L\"))\n                                  (if (>= x 40)\n                                    (helper (- x 40) (str ans \"XL\"))\n                                    (if (>= x 10)\n                                      (helper (- x 10) (str ans \"X\"))\n                                      (if (>= x 9)\n                                        (helper (- x 9) (str ans \"IX\"))\n                                        (if (>= x 5)\n                                          (helper (- x 5) (str ans \"V\"))\n                                          (if (>= x 4)\n                                            (helper (- x 4) (str ans \"IV\"))\n                                            (if (>= x 1)\n                                              (helper (- x 1) (str ans \"I\"))))))))))))))))) n \"\"))","user":"5746061ae4b009280f9f2b5b"},{"code":"(fn d-to-r [n]\n  (let [conv-map \n        {0 {3 \"\"         , 2 \"\"    , 1 \"\"    , 0 \"\"    }\n         1 {3 \"M\"        , 2 \"C\"   , 1 \"X\"   , 0 \"I\"   },\n         2 {3 \"MM\"       , 2 \"CC\"  , 1 \"XX\"  , 0 \"II\"  },\n         3 {3 \"MMM\"      , 2 \"CCC\" , 1 \"XXX\" , 0 \"III\" },\n         4 {3 \"MMMM\"     , 2 \"CD\"  , 1 \"XL\"  , 0 \"IV\"  },\n         5 {3 \"MMMMM\"    , 2 \"D\"   , 1 \"L\"   , 0 \"V\"   },\n         6 {3 \"MMMMMM\"   , 2 \"DV\"  , 1 \"LX\"  , 0 \"VI\"  },\n         7 {3 \"MMMMMMM\"  , 2 \"DCC\" , 1 \"LXX\" , 0 \"VII\" },\n         8 {3 \"MMMMMMMM\" , 2 \"DCCC\", 1 \"LXXX\", 0 \"VIII\"},\n         9 {3 \"MMMMMMMMM\", 2 \"CM\",   1 \"XC\"  , 0 \"IX\"  }}\n        digits (map #(-> % str Integer/parseInt) (seq (str n)))\n        pows   (reverse (take (count digits) (range))) \n        get-value (fn [digit pow] (get-in conv-map [digit pow]))]\n    (loop [ds digits, ps pows, result []]\n      (if (empty? ds)\n        (apply str result)\n        (recur \n          (rest ds) \n          (rest ps) \n          (conj result (get-value (first ds) (first ps)) ))\n        ))\n    ))","problem":104,"user":"52cf084ce4b07d0d72b27399"},{"code":"(fn r [s [v & vs] [c & cs] n]\n    (if (= 0 n) s\n        (recur (apply str s (replicate (quot n v) c)) vs cs (rem n v))) )\n  \"\"\n  [1000 900 500 400 100 90  50  40  10   9   5   4   1]\n  [\\M  \"CM\" \\D \"CD\" \\C \"XC\" \\L \"XL\" \\X \"IX\" \\V \"IV\" \\I]","problem":104,"user":"4ff67852e4b0678c553fc37e"},{"problem":104,"code":"(fn [n]\n  (let [rn [\\I \\V \\X \\L \\C \\D \\M \\?]\n        ->rn (fn [n i]\n               (cond\n                 (< n 4) (repeat n (rn (dec i)))\n                 (= n 4) (list (rn (dec i)) (rn i))\n                 (< n 9) (conj (repeat (- n 5) (rn (dec i))) (rn i))\n                 :else (list (rn (dec i)) (rn (inc i)))))]\n    (loop [n n, i 1, acc '()]\n      (if (> n 0)\n        (recur (quot n 10) (+ i 2) (conj acc (->rn (rem n 10) i)))\n        (reduce #(apply str %1 %2) \"\" acc)))))","user":"5eb1c786e4b00a66d4a95201"},{"code":"(fn [n]\r\n  (let [conv {1 \"I\", 900 \"CM\", 100 \"C\", 5 \"V\", 40 \"XL\", 9 \"IX\", 10 \"X\"\r\n              400 \"CD\", 1000 \"M\", 50 \"L\", 500 \"D\", 4 \"IV\", 90 \"XC\"}]\r\n    (loop [acc \"\", n n, [c & cs] (reverse (sort (keys conv)))]\r\n      (if (zero? n)\r\n        acc\r\n        (if (<= c n)\r\n          (recur (str acc (conv c)) (- n c) (cons c cs))\r\n          (recur acc n cs))))))","problem":104,"user":"509c03f3e4b085ae113522a8"},{"problem":104,"code":"(fn int->roman-numeral [n]\n  (let [numeral-map {\"I\" [\"V\" \"X\"] \"X\" [\"L\" \"C\"] \"C\" [\"D\" \"M\"] \"M\" []}\n        digits (map #(Integer/valueOf (str %)) (str n))\n        subtractify (fn [numeral d]\n                      (let [[five ten] (numeral-map numeral)]\n                        (apply str (case d\n                                     (0 1 2 3) (repeat d numeral)\n                                     4 (list numeral five)\n                                     (5 6 7 8) (apply list five \n                                                 (repeat (- d 5) numeral))\n                                     9 (list numeral ten)))))]\n    (->> digits\n         (concat (repeat (- 4 (count digits)) 0))\n         (map subtractify [\"M\" \"C\" \"X\" \"I\"])\n         (apply str))))","user":"5c506951e4b0f9f7a8770ec5"},{"problem":104,"code":"(fn roman [n]\n   (loop [i n\n          a []]\n     (let [conv [\n                 [1000 \"M\"]\n                 [900 \"CM\"]\n                 [500 \"D\"]\n                 [400 \"CD\"]\n                 [100 \"C\"]\n                 [90 \"XC\"]\n                 [50 \"L\"]\n                 [40 \"XL\"]\n                 [10 \"X\"]\n                 [9 \"IX\"]\n                 [5 \"V\"]\n                 [4 \"IV\"]\n                 [1 \"I\"]]\n           [cn cr] (first (filter #(>= i (first %) ) conv))]\n       (if (zero? i)\n         (apply str a)\n         (recur (- i cn) (conj a cr)))\n       )))","user":"535eaa73e4b04ce2eb3ed2d4"},{"problem":104,"code":"(fn __ [x]\n  (let [key ['(:s)\n             '(:s :s)\n             '(:s :s :s)\n             '(:s :m)\n             '(:m)\n             '(:m :s)\n             '(:m :s :s)\n             '(:m :s :s :s)\n             '(:s :M)]]\n    (loop [n x\n           m 10\n           u [\"I\" \"V\" \"X\" \"L\" \"C\" \"D\" \"M\"]\n           v '()]\n      (if (= 0 n)\n        (clojure.string/join (flatten v))\n        (let [r (mod n m)\n              d (/ r (/  m 10))]\n          (recur (- n r) (* m 10) (rest (rest u)) (if(> d 0)\n                                                    (conj v (map #(cond\n                                                                    (= :s %) (first u)\n                                                                    (= :m %) (second u)\n                                                                    (= :M %) (nth u 2)) (key (dec d)))) v)))))))","user":"53d5a63be4b0e771c3025449"},{"problem":104,"code":"(fn [n]\n  (case n\n    1 \"I\"\n    30 \"XXX\"\n    4 \"IV\"\n    140 \"CXL\"\n    827 \"DCCCXXVII\"\n    3999 \"MMMCMXCIX\"\n    48 \"XLVIII\"))","user":"52b02329e4b0c58976d9acc5"},{"problem":104,"code":"(fn [n]\n  (let [m (array-map\n        1000 \"M\"\n        900 \"CM\"\n        500 \"D\"\n        400 \"CD\"\n        100 \"C\"\n        90 \"XC\"\n        50 \"L\"\n        40 \"XL\"\n        10 \"X\"\n        9 \"IX\"\n        5 \"V\"\n        4 \"IV\"\n        1 \"I\"\n        )]\n    (loop [n n res \"\"]\n      (if (= 0 n) res\n        (let [[k v] (first (drop-while #(< n (first %)) m))]\n          (recur (- n k) (str res v)))))))","user":"553e0b70e4b0a04f792994e8"},{"problem":104,"code":"(fn [n]\n  (let [\n         UNITS {\n           0 \"\", 1 \"I\", 2 \"II\", 3 \"III\", 4 \"IV\", 5 \"V\", 6 \"VI\", 7 \"VII\", 8 \"VIII\", 9 \"IX\"\n         },\n         TENS {\n           0 \"\", 1 \"X\", 2 \"XX\", 3 \"XXX\", 4 \"XL\", 5 \"L\", 6 \"LX\", 7 \"LXX\", 8 \"LXXX\", 9 \"XC\"\n         },\n         HUNDREDS {\n           0 \"\", 1 \"C\", 2 \"CC\", 3 \"CCC\", 4 \"CD\", 5 \"D\", 6 \"DC\", 7 \"DCC\", 8 \"DCCC\", 9 \"CM\"\n         },\n         THOUSANDS {\n           0 \"\", 1 \"M\", 2 \"MM\", 3 \"MMM\", 4 \"MMMM\", 5 \"MMMMM\", 6 \"MMMMMM\", 7 \"MMMMMMM\", 8 \"MMMMMMMM\", 9 \"MMMMMMMMM\"\n         },\n         th (quot n 1000),\n         hd (mod (quot n 100) 10),\n         tn (mod (quot n 10) 10),\n         ut (mod n 10)\n       ]\n    (str (get THOUSANDS th) (get HUNDREDS hd) (get TENS tn) (get UNITS ut))\n  )\n)","user":"53ca41dae4b00fb29b2212c8"},{"problem":104,"code":"(fn [n]\n  (let [roman-digits [[\"\" \"I\" \"II\" \"III\" \"IV\" \"V\" \"VI\" \"VII\" \"VIII\" \"IX\"]\n                      [\"\" \"X\" \"XX\" \"XXX\" \"XL\" \"L\" \"LX\" \"LXX\" \"LXXX\" \"XC\"]\n                      [\"\" \"C\" \"CC\" \"CCC\" \"CD\" \"D\" \"DC\" \"DCC\" \"DCCC\" \"CM\"]\n                      [\"\" \"M\" \"MM\" \"MMM\"]]\n        digits (loop [res [], n n]\n                 (if (zero? n)\n                   res\n                   (recur (conj res (rem n 10)) (quot n 10))))]\n    (->> (map get roman-digits digits)\n         (reverse)\n         (apply str))))","user":"5455c2f3e4b080a794c2c87d"},{"problem":104,"code":"(fn roman-numeral [number]\n  (let [numerals-map {\"M\" 1000 \"CM\" 900 \"D\" 500 \"CD\" 400 \"C\" 100 \"XC\" 90 \n                      \"L\" 50 \"XL\" 40 \"X\" 10 \"IX\" 9 \"V\" 5 \"IV\" 4 \"I\" 1}]\n    (loop [n number\n           remaining-numerals (sort-by val > numerals-map)\n           accum []]\n      (let [[numeral value] (first remaining-numerals)]\n        (cond (zero? n) (apply str accum)\n              (> value n) (recur n (rest remaining-numerals) accum)\n              :else (recur (- n value) remaining-numerals (conj accum numeral)))))))","user":"58ed713de4b056aecfd47d84"},{"code":"(fn [n]\n   (loop [n n acc []]\n     (cond\n      (>= n 1000) (recur (- n 1000) (conj acc \"M\"))\n      (>= n 900) (recur (- n 900) (conj acc \"CM\"))\n      (>= n 500) (recur (- n 500) (conj acc \"D\"))\n      (>= n 400) (recur (- n 400) (conj acc \"CD\"))\n      (>= n 100) (recur (- n 100) (conj acc \"C\"))\n      (>= n 90) (recur (- n 90) (conj acc \"XC\"))\n      (>= n 50) (recur (- n 50) (conj acc \"L\"))\n      (>= n 40) (recur (- n 40) (conj acc \"XL\"))\n      (>= n 10) (recur (- n 10) (conj acc \"X\"))\n      (>= n 9) (recur (- n 9) (conj acc \"IX\"))\n      (>= n 5) (recur (- n 5) (conj acc \"V\"))\n      (>= n 4) (recur (- n 4) (conj acc \"IV\"))\n      (>= n 1) (recur (- n 1) (conj acc \"I\"))\n      :else (apply str acc))))","problem":104,"user":"4ed188c8535d44c135fd68cf"},{"code":"#(first (reduce (fn [[acc n] [m s]]\n                  [(apply str acc (repeat (quot n m) s)), (rem n m)])\n                [\"\" %]\n                [[1000 \"M\"][900 \"CM\"][500 \"D\"][400 \"CD\"][100 \"C\"][90 \"XC\"]\n                 [50 \"L\"][40 \"XL\"][10 \"X\"][9 \"IX\"][5 \"V\"][4 \"IV\"][1 \"I\"]]))","problem":104,"user":"4daec9dcedd6309eace4d15f"},{"problem":104,"code":"(fn romantransl [n]\r\n  (let [translation-table {1000 \"M\", 900 \"CM\",\r\n                           500  \"D\", 400 \"CD\",\r\n                           100  \"C\", 90  \"XC\",\r\n                           50   \"L\", 40  \"XL\",\r\n                           10   \"X\", 9   \"IX\",\r\n                           5    \"V\", 4   \"IV\",\r\n                           1 \"I\"}\r\n        tt-keys (sort > (keys translation-table))]\r\n    (loop [n n\r\n           output \"\"]\r\n      (if (= 0 n)  output\r\n          (let [x (first (drop-while (partial < n) tt-keys))]\r\n            (recur (- n x)\r\n                   (str output (translation-table x))))))))","user":"55d0e76ae4b0e31453f64a40"},{"code":"(fn p104 [n]\n   (letfn [(div [m n k] (if (<= n 0) m (div (conj m [k (mod n 10)]) (int (/ n 10)) (* k 10))))]\n     (let [m (div {} n 1) ks (sort (keys m))\n           vs (fn [k v m] (cond\n              (= k 1)    (cond (= v 9) \"IX\" (= v 4) \"IV\" true (str (if (<= 5 v) \"V\" \"\") (apply str (replicate m \"I\"))))\n              (= k 10)   (cond (= v 9) \"XC\" (= v 4) \"XL\" true (str (if (<= 5 v) \"L\" \"\") (apply str (replicate m \"X\"))))\n              (= k 100)  (cond (= v 9) \"CM\" (= v 4) \"DC\" true (str (if (<= 5 v) \"D\" \"\") (apply str (replicate m \"C\"))))\n              (= k 1000) (apply str (replicate v \"M\"))\n              ))]\n       (apply str (reverse (for [k ks] (vs k (m k) (mod (m k) 5))))))))","problem":104,"user":"5272669de4b03e8d9a4a742e"},{"code":"(fn [n]\n    (let [lookup { 1000 \"M\"\n                   900  \"CM\"\n                   500  \"D\"\n                   400  \"CD\"\n                   100  \"C\"\n                   90   \"XC\"\n                   50   \"L\"\n                   40   \"XL\"\n                   10   \"X\"\n                   9    \"IX\"\n                   5    \"V\"\n                   4    \"IV\"\n                   1    \"I\" }\n          nums ((comp reverse sort keys) lookup)\n          get-digit (fn [n']\n                      (first (drop-while #(> % n') nums)))]\n      (loop [n n\n             s \"\"]\n        (if (zero? n)\n          s\n          (let [res (get-digit n)]\n            (recur (- n res) (str s (lookup res))))))))","problem":104,"user":"51195e77e4b055cfb310d499"},{"problem":104,"code":"(comp (partial apply str) \n(fn f\n  [n]\n  (if (zero? n)\n    nil\n    (let [n->s {1000 \"M\"  900 \"CM\" 500 \"D\" \n                 400 \"CD\" 100 \"C\"   90 \"XC\"\n                  50 \"L\"   40 \"XL\"  10 \"X\"\n                   9 \"IX\"   4 \"IV\"   5 \"V\" \n                   1 \"I\"}\n          ncol (reverse (sort (keys n->s)))\n          nn (first (filter #(<= % n) ncol))]\n      (println n nn)\n      (lazy-seq (cons (n->s nn) (f (- n nn))))))))","user":"56102f50e4b05f002753df6b"},{"code":"#(loop [n % r \"\" [i v & [x & _ :as d]] [\\I \\V \\X \\L \\C \\D \\M]]\n   (if (= 0 n)\n     r\n     (recur (quot n 10) (str (apply str ([[] [i] [i i] [i i i] [i v] [v] [v i] [v i i] [v i i i] [i x]] (mod n 10))) r) d)))","problem":104,"user":"52b453b0e4b0c58976d9ad21"},{"code":"(fn do-rom[number]((fn mkrom [rnums n]\n                      (cond\n                       (= 0 n) (apply str rnums)\n                       (= 1 n) \"I\"\n                       :else\n       (let [bkmp (sorted-map 100 \\C 10 \\X 1 \\I)\n             mp (sorted-map 1000 \\M 500 \\D 100 \\C 50 \\L 10 \\X 5 \\V 1 \\I)\n             times (apply merge (reverse (map #(sorted-map (quot n (first %)) (last %)) mp)))\n             rmap {\\M 1000, \\D 500, \\C 100, \\L 50, \\X 10, \\V 5, \\I 1}\n             check (if (zero? (first (first times))) (first (first (rest times)))\n                       (first (first times)))\n             n-check (if (zero? (first (first times))) (last (first (rest times)))\n                         (last (first times)))\n             minus (last (filter #(< (first %) n) bkmp))\n             postminus (last (first times))\n             f-rom-num (if (< check 4) (repeat check n-check)\n                         (vector (last minus) postminus))\n             f-num (if (< check 4) (* check (get rmap (first f-rom-num)))\n                     (- (get rmap (last f-rom-num)) (get rmap (first f-rom-num))))\n             t-rom-num (vector (last minus) postminus)\n             t-num (- (get rmap postminus) (get rmap (last minus)))\n             use-t (and (>= (- n t-num) 0) (< (- n t-num) (- n f-num)))\n             rom-num (if use-t t-rom-num f-rom-num)\n             num (if use-t t-num f-num)]\n         (mkrom (flatten (cons rnums rom-num)) (- n num))))) [] number))","problem":104,"user":"4fb86dc9e4b081705acca2d8"},{"code":"(fn [l]\r\n  (cond\r\n    (= l 1) \"I\"\r\n    (= l 30) \"XXX\"\r\n    (= l 4) \"IV\"\r\n    (= l 140) \"CXL\"\r\n    (= l 827) \"DCCCXXVII\"\r\n    (= l 3999) \"MMMCMXCIX\"\r\n    (= l 48) \"XLVIII\"))","problem":104,"user":"4faa3eeae4b081705acca1ed"},{"code":"#(let [\n  r {1 \"I\" 4 \"IV\" 5 \"V\" 9 \"IX\" 10 \"X\" 40 \"XL\" 50 \"L\" 90 \"XC\" 100 \"C\" 400 \"CD\" 500 \"D\" 900 \"CM\" 1000 \"M\"}]\n  (letfn [\n    (w [n s]\n      (if (= 0 n)\n        s\n        (let [k (last (filter (fn [i] (<= i n)) (sort (keys r))))]\n          (recur (- n k) (str s (r k))))))]\n    (w % \"\")))","problem":104,"user":"4e8f4f64535d65386fec2149"},{"problem":104,"code":"(fn p-104 [n]\n  \n  (cond (= n 0) \"\"\n        (>= n 1000) (str \"M\" (p-104 (- n 1000)))\n        (>= n 900) (str \"CM\" (p-104 (- n 900)))\n        (>= n 500) (str \"D\" (p-104 (- n 500)))\n        (>= n 400) (str \"CD\" (p-104 (- n 400)))\n        (>= n 100) (str \"C\" (p-104 (- n 100)))\n        (>= n 90) (str \"XC\" (p-104 (- n 90)))\n        (>= n 500) (str \"L\" (p-104 (- n 50)))\n        (>= n 40) (str \"XL\" (p-104 (- n 40)))\n        (>= n 10) (str \"X\" (p-104 (- n 10)))\n        (>= n 9) (str \"IX\" (p-104 (- n 9)))\n        (>= n 5) (str \"V\" (p-104 (- n 5)))\n        (>= n 4) (str \"IV\" (p-104 (- n 4)))\n        (>= n 1) (str \"I\" (p-104 (- n 1)))))","user":"5bfc9037e4b0bdcf453d15f2"},{"code":"(fn [x]\r\n  (letfn [(ntimes-char [c n]\r\n            (apply str (map (fn [_] c) (range 0 n))))\r\n          (process-any [a divisor c1 c5 c10 next]\r\n            (let [l (quot a divisor)]\r\n              (str\r\n               (cond\r\n                (zero? l) \"\"\r\n                (<= 1 l 3) (ntimes-char c1 l)\r\n                (= l 4) (str (ntimes-char c1 1) c5)\r\n                (= l 5) (str c5)\r\n                (<= 6 l 8) (str c5 (ntimes-char c1 (- l 5)))\r\n                (= l 9) (str (ntimes-char c1 1) c10))\r\n               (next (rem a divisor)))))\r\n          (process-thousand [a]\r\n            (process-any a 1000 \\M \\v \\x process-hundred))\r\n          (process-hundred [a]\r\n            (process-any a 100 \\C \\D \\M process-ten))\r\n          (process-ten [a]\r\n            (process-any a 10 \\X \\L \\C process-one))\r\n          (process-one [a]\r\n            (process-any a 1 \\I \\V \\X (fn [_] \"\")))]\r\n    (process-thousand x)))","problem":104,"user":"4f474f43e4b0d56e7bb92bb7"},{"code":"(fn [x]\n    (->> (loop [v x\n                nums [1000 100 10 1] \n                res []]\n           (if (zero? v)\n             res\n             (let [num (first nums)]\n               (recur (mod v num)\n                      (rest nums)\n                      (conj res [(quot v num) num])))))\n         (mapcat\n          (fn [[a b]]\n            (condp = a\n              9 [[1 b] [1 (* 10 b)]]\n              8 [[1 (* 5 b)] [3 b]]\n              7 [[1 (* 5 b)] [2 b]]\n              6 [[1 (* 5 b)] [1 b]]\n              5 [[1 (* 5 b)]]\n              4 [[1 b] [1 (* 5 b)]]\n              [[a b]])))\n         (mapcat\n          (fn [[a b]] (repeat a ({1 \"I\"\n                                 5 \"V\"\n                                 10 \"X\"\n                                 50 \"L\"\n                                 100 \"C\"\n                                 500 \"D\"\n                                 1000 \"M\"} b))))\n         (apply str)))","problem":104,"user":"4f463dfde4b0d56e7bb92b99"},{"code":"(fn [n]\r\n  (letfn [(digit [n one five ten]\r\n            (condp = n\r\n              4 [one five]\r\n              9 [one ten]\r\n              (concat (if (>= n 5) [five])\r\n                      (repeat (mod n 5) one))))]\r\n    (apply str\r\n      (concat \r\n        (digit (quot n 1000) \\M \\Z \\Z) \r\n        (digit (quot (mod n 1000) 100) \\C \\D \\M)\r\n        (digit (quot (mod n 100) 10) \\X \\L \\C)\r\n        (digit (mod n 10) \\I \\V \\X)))))","problem":104,"user":"4e994541535dbda64a6f6b64"},{"problem":104,"code":"(fn [n]\n  (let [numerals {\"M\" 1000 \"CM\" 900 \"D\" 500 \"CD\" 400 \"C\" 100 \"XC\" 90\n                  \"L\" 50 \"XL\" 40 \"X\" 10 \"IX\" 9 \"V\" 5 \"IV\" 4 \"I\" 1}\n        dec->roman (fn [n]\n                     (loop [n n [[c v] & nums :as all] (reverse (sort-by val numerals)) acc []]\n                       (cond\n                         (zero? n) (apply str acc)\n                         (> v n) (recur n nums acc)\n                         :else (recur (- n v) all (conj acc c)))))]\n    (dec->roman n)))","user":"537e104ce4b06839e8705e9a"},{"code":"(fn [n]\n  (loop [a () q n [i v x :as r] '(\\I \\V \\X \\L \\C \\D \\M)]\n    (if (zero? q)\n        (apply str a)\n        (let [m (mod q 10)]\n          (recur \n            ((comp #(if (= 4 (mod  m 5)) (cons i %) %)\n                   #(if (< 3 (mod  m 9)) (cons v %) %)\n                   #(if (< 0 (quot m 9)) (cons x %) %))\n              (reduce conj a (repeat (mod (mod m 5) 4) i)))\n            (quot q 10)\n            (nthnext r 2))))))","problem":104,"user":"4fd96694e4b05e33b9224f37"},{"problem":104,"code":"(fn [arabic]\n  (let [ones           [1    \\I \\V \\X]\n        tens           [10   \\X \\L \\C]\n        hundreds       [100  \\C \\D \\M]\n        thousands      [1000 \\M]\n        symbol-pattern (fn ([o x]\n                            (apply str (repeat x o)))\n                           ([o f t x]\n                            (let [pattern {1 [o],     2 [o o],     3 [o o o],\n                                           4 [o f],   5 [f],       6 [f o],\n                                           7 [f o o], 8 [f o o o], 9 [o t]}]\n                              (apply str (get pattern x)))))\n        ]\n    (apply\n      str\n      (map\n        (fn [pattern]\n          (let [[magnitude & chars] pattern\n                value (if (>= arabic magnitude)\n                        (quot (mod arabic (* magnitude 10)) magnitude)\n                        0)\n                args (conj (vec chars) value)]\n            (apply symbol-pattern args)))\n        [thousands\n         hundreds\n         tens\n         ones]))))","user":"55d28b38e4b0e31453f64a58"},{"problem":104,"code":"(fn [x]\n  ((fn [x acc]\n     (cond (zero? x) (apply str acc)\n           (>= x 1000) (recur (- x 1000) (conj acc \"M\"))\n           (>= x 900) (recur (+ x 100) (conj acc \"C\"))\n           (>= x 500) (recur (- x 500) (conj acc \"D\"))\n           (>= x 100) (recur (- x 100) (conj acc \"C\"))\n           (>= x 90) (recur (+ x 10) (conj acc \"X\"))\n           (>= x 50) (recur (- x 50) (conj acc \"L\"))\n           (>= x 40) (recur (+ x 10) (conj acc \"X\"))\n           (>= x 10) (recur (- x 10) (conj acc \"X\"))\n           (>= x 9) (recur (+ x 1) (conj acc \"I\"))\n           (>= x 5) (recur (- x 5) (conj acc \"V\"))\n           (>= x 4) (recur (+ x 1) (conj acc \"I\"))\n           (>= x 1) (recur (- x 1) (conj acc \"I\")))) x []))","user":"516f06dce4b06aac486e5b39"},{"problem":104,"code":"(fn [n]\n  (apply str (flatten (reverse\n    (map (fn [d [a b c]] ({1 [a], 2 [a a], 3 [a a a], 4 [a b], 5 [b], 6 [b a], 7 [b a a], 8 [b a a a], 9 [a c]} d))\n      (reverse (map #(Character/getNumericValue %) (str n)))\n      (partition-all 3 2 \"IVXLCDM\"))))))","user":"536046a9e4b063bf7a5f8fe1"},{"code":"(fn [n]\n  (loop [n n\n         romnum \"\"\n         decvals '(1000 900 500 400 100 90\n                   50 40 10 9 5 4 1)\n         romsyms '(\"M\" \"CM\" \"D\" \"CD\" \"C\" \"XC\"\n                   \"L\" \"XL\" \"X\" \"IX\" \"V\" \"IV\" \"I\") ]\n    (if (zero? n)\n      romnum\n      (let [v (first decvals)\n            k (int (/ n v))]\n        (recur (- n (* k v))\n               (apply str romnum (repeat k (first romsyms)))\n               (next decvals)\n               (next romsyms))))))","problem":104,"user":"4fe84c74e4b07c9f6fd12c3c"},{"code":"(fn [n]\n    (let [r (sorted-map\n                    1 \"I\" \n                    4 \"IV\"\n                    5 \"V\"\n                    9 \"IX\"\n                    10 \"X\"\n                    40 \"XL\"\n                    50 \"L\"\n                    90 \"XC\"\n                    100 \"C\"\n                    500 \"D\"\n                    900 \"CM\"\n                    1000 \"M\")\n          k (keys r)]\n        (loop [n n v []]\n            (if (zero? n)\n                (apply str v)\n                (let [x (last (filter #(<= % n) k))]\n                    (recur (- n x) (conj v (r x)))\n                    )\n                )\n            )\n        )\n    )","problem":104,"user":"4fbbcf0ce4b081705acca2ee"},{"problem":104,"code":"(fn [x]\n  (loop [x x\n         m [1000 900  500 400  100 90   50  40   10  9    5   4    1]\n         s [\"M\"  \"CM\" \"D\" \"CD\" \"C\" \"XC\" \"L\" \"XL\" \"X\" \"IX\" \"V\" \"IV\" \"I\"]\n         r \"\"]\n    (if (seq m)\n      (let [b (first m)\n            i (int (/ x b))\n            x (mod x b)]\n        (recur x (rest m) (rest s) (apply str (conj (repeat i (first s)) r))))\n      r)))","user":"5799ff45e4b05b1deef9add1"},{"problem":104,"code":"(fn [num]\n  (letfn [(render [n one five ten]\n    (condp = n\n     0 \"\"\n     1 one\n     4 (str one five)\n     5 five\n     9 (str one ten)\n     (str (render (dec n) one five ten) (render 1 one five ten))))]\n\n    (let [digits (mapv #(mod (quot num %) 10) [1000 100 10 1])] \n\n      (reduce str (mapv #(apply render %1 %2) digits [[\\M \\? \\?] \n                                                      [\\C \\D \\M] \n                                                      [\\X \\L \\C] \n                                                      [\\I \\V \\X]])))))","user":"55ecb2c0e4b0121d4835fdce"},{"code":"(fn [n]\n  (loop [[[a b c] & rt] [[\\I \\V \\X] [\\X \\L \\C] [\\C \\D \\M] [\\M]]\n         [ft & ot] (map #(- (int %) 48) (reverse (str n)))\n         ret []]\n    (let [s (cond \n             (nil? ft)\n             []\n             (<= ft 3)\n             (repeat ft a)\n             (= 4 ft)\n             [b a]\n             (= 5 ft)\n             [b]\n             (< 5 ft 9)\n             (concat (repeat (- ft 5) a) [b])\n             (= 9 ft)\n             [c a])]\n      (if ft\n        (recur rt ot (concat ret s))\n        (apply str (reverse ret))))))","problem":104,"user":"51944aaae4b0142f60b4aedc"},{"problem":104,"code":"(let [m {\"I\" 1 \"V\" 5 \"X\" 10 \"L\" 50 \"C\" 100 \"D\" 500 \"M\" 1000}\n      s->i (reduce (fn [m [k v]]\n                     (if (#{1 10 100 1000} v)\n                       (->> (dissoc m k)\n                            (filter (comp #(<= v % (* v 10)) \n                                          val))\n                            (map (fn [[a b]] [(str k a) (- b v)]))\n                            (into m))\n                       m))\n                   m\n                   m)]\n  (fn [n]\n    (->> [nil n]\n         (iterate (fn [[res i]]\n                    (if (< 0 i)\n                      (->> s->i\n                           vals\n                           (remove #(< i %))\n                           (apply max)\n                           (#(vector % (- i %)))))))\n         rest\n         (take-while #(-> %))\n         (map first)\n         (map (clojure.set/map-invert s->i))\n         (apply str))))","user":"53ea5851e4b036ad0777e4e4"},{"code":"; yes, this is ugly, but I'm tired.\n(fn __ [x]\n  (let [units (partition 2 \n                         (interleave \"MDCLXVI\" [1000 500 100 50 10 5 1]))\n        e (first (filter #(pos? (first %))\n                 (map #(conj % (quot x (second %))) units)))\n        rst (- x (* (first e) (last e)))\n        rom (repeat (first e) (second e))\n        r clojure.string/replace\n        repl (comp ; 4*\n                   #(r % \"IIII\" \"IV\")\n                   #(r % \"XXXX\" \"XL\")\n                   #(r % \"CCCC\" \"CD\")\n                   ; 9*\n                   #(r % \"VIV\" \"IX\")\n                   #(r % \"LXL\" \"XC\")\n                   #(r % \"DCD\" \"CM\"))\n        rrom (fn [x s]\n               (repl (apply str (if (zero? rst)\n                      rom\n                      (concat rom (__ rst))))))]\n    (rrom x [])))","problem":104,"user":"4ec9549d535d6d7199dd36fe"},{"code":"(let [m (sorted-map \n          1 \"I\", 4 \"IV\", 5 \"V\", 9 \"IX\", 10 \"X\",\n          40 \"XL\", 50 \"L\", 90 \"XC\", 100 \"C\",\n          400 \"CD\", 500 \"D\", 900 \"CM\", 1000 \"M\")]\n  (fn f [x]\n    (or\n      (m x)\n      (let [[[a b] & _] (rsubseq m < x)]\n        (str b (f (- x a)))))))","problem":104,"user":"4f08b15b535dcb61093f6c40"},{"problem":104,"code":"(fn [n] (condp = n\n1 \"I\"\n30 \"XXX\"\n4 \"IV\"\n140 \"CXL\"\n827 \"DCCCXXVII\"\n3999 \"MMMCMXCIX\"\n48 \"XLVIII\"))","user":"5849ac5fe4b089d5ab817ed7"},{"code":"(fn [d]\n  (let [d2r {1000 \"M\" 900 \"CM\" 500 \"D\" 100 \"C\" 90 \"XC\" 50 \"L\" 40 \"XL\" 10 \"X\" 9 \"IX\" 5 \"V\" 4 \"IV\" 1 \"I\"}]\n    (loop [ret \"\"\n           d d\n           ks (remove #(< d %) (sort > (keys d2r)))]\n      (if (empty? ks) ret\n        (let [k (first ks)\n              q (quot d k)\n              m (mod d k)]\n        (recur (str ret (apply str (repeat q (d2r k)))) m (rest ks)))))))","problem":104,"user":"5300158ae4b0d8b024fd370f"},{"code":"(fn [n] (let [d (map (zipmap \"0123456789\" (range)) (str n)) \n                      m {0 \"\" 4 \"IV\" 5 \"V\" 9 \"IX\" 40 \"XL\" 50 \"L\" 90 \"XC\" 400 \"CD\" 500 \"D\" 900 \"CM\"} ]\n                     (apply str (map-indexed \n                          #(let [p (- (count d) % 1) \n                                 f (fn [x] \n                                    (cond (= p 0) \n                                          (if (< x 5) (apply str (repeat x \"I\"))\n                                              (apply str \"V\" (repeat (- x 5) \"I\")) )\n                                          (= p 1) \n                                          (if (< x 5) (apply str (repeat x \"X\"))\n                                              (apply str \"L\" (repeat (- x 5) \"X\")) )\n                                          (= p 2) \n                                          (if (< x 5) (apply str (repeat x \"C\"))\n                                              (apply str \"D\" (repeat (- x 5) \"C\")) )\n                                          (= p 3) (apply str (repeat x \"M\")) ))]\n                                (m (int (* (Math/pow 10 p) %2)) (f %2)) ) d) )  ) )","problem":104,"user":"4ee7d177535d93acb0a6686f"},{"code":"(fn torn [n]\n    (if (zero? n) \"\"\n      (let [rn [[1000 \"M\"] [900 \"CM\"] [500 \"D\"] [400 \"CD\"] [100 \"C\"] [90 \"XC\"] [50 \"L\"] [40 \"XL\"] [10 \"X\"] [9 \"IX\"] [5 \"V\"] [4 \"IV\"] [1 \"I\"]]\n            [a r]  (first (filter #(>= n (first %)) rn))\n          ]\n         (str r (torn (- n a)))\n      )\n    )\n)","problem":104,"user":"504f191ae4b0e7ad84dbc4ba"},{"problem":104,"code":"#( loop [ n % res \"\" ]\n   (cond\n    (== n 0) res\n    (>= n 1000) (recur (- n 1000) (str res \"M\"))\n    (>= n 900) (recur (- n 900) (str res \"CM\"))\n    (>= n 500) (recur (- n 500) (str res \"D\"))\n    (>= n 400) (recur (- n 400) (str res \"CD\"))\n    (>= n 100) (recur (- n 100) (str res \"C\"))\n    (>= n 90) (recur (- n 90) (str res \"XC\"))\n    (>= n 50) (recur (- n 50) (str res \"L\"))\n    (>= n 40) (recur (- n 40) (str res \"XL\"))\n    (>= n 10) (recur (- n 10) (str res \"X\"))\n    (>= n 9) (recur (- n 9) (str res \"IX\"))\n    (>= n 5) (recur (- n 5) (str res \"V\"))\n    (>= n 4) (recur (- n 4) (str res \"IV\"))\n    (>= n 1) (recur (- n 1) (str res \"I\"))\n    )\n   )","user":"5b3aa98be4b02d533a91bbca"},{"problem":104,"code":"(fn [dec]\n  (let [d->r_f\n          (fn [[decem quinque uni]]\n            (fn [d]\n              (if-let [r ({4 (str uni quinque), 9 (str uni decem)} d)]\n                r (apply str (cons (if (>= d 5) quinque \"\") (repeat (mod d 5) uni))))))\n        f-list (map d->r_f (partition 3 2 \"**MDCLXVI\"))\n        digits (->> dec (format \"%04d\") seq (map (comp read-string str)))]\n    (apply str (map #(%1 %2) f-list digits))))","user":"5416b4a2e4b01498b1a71a01"},{"problem":104,"code":";stolen elegant solution: \n;(fn roman [s [v & vs] [c & cs] n]\n;  (if (= 0 n) s\n;              (recur (apply str s (repeat (quot n v) c)) vs cs (rem n v))) )\n;\"\"\n;[1000 900 500 400 100 90  50  40  10   9   5   4   1]\n;[\"M\" \"CM\" \"D\" \"CD\" \\C \"XC\" \\L \"XL\" \\X \"IX\" \\V \"IV\" \\I]\n; my 1st passed C style solution\n(fn roman [n]\n   (loop [num n\n          out \"\"]\n     (if (>= num 1000)\n       (recur (- num 1000) (clojure.string/join [out \"M\"]))\n       (if (>= num 900)\n         (recur (- num 900) (clojure.string/join [out \"CM\"]))\n         (if (>= num 500)\n           (recur (- num 500) (clojure.string/join [out \"D\"]))\n           (if (>= num 400)\n             (recur (- num 400) (clojure.string/join [out \"CD\"]))\n              (if (>= num 100)\n              (recur (- num 100) (clojure.string/join [out \"C\"]))\n              (if (>= num 90)\n                (recur (- num 90) (clojure.string/join [out \"XC\"]))\n                (if (>= num 50)\n                  (recur (- num 50) (clojure.string/join [out \"L\"]))\n                  (if (>= num 40)\n                    (recur (- num 40) (clojure.string/join [out \"XL\"]))\n                    (if (>= num 10)\n                      (recur (- num 10) (clojure.string/join [out \"X\"]))\n                      (case num\n                        9 (clojure.string/join [out \"IX\"])\n                        8 (clojure.string/join [out \"VIII\"])\n                        7 (clojure.string/join [out \"VII\"])\n                        6 (clojure.string/join [out \"VI\"])\n                        5 (clojure.string/join [out \"V\"])\n                        4 (clojure.string/join [out \"IV\"])\n                        3 (clojure.string/join [out \"III\"])\n                        2 (clojure.string/join [out \"II\"])\n                        1 (clojure.string/join [out \"I\"])\n                        out\n                        )\n                      )\n                    )\n                  )\n))))))))","user":"5f0824c5e4b0cf489e8d7f5b"},{"problem":104,"code":"(fn write-roman-numberals [num]\n  (letfn [(decompose [num]\n            (->> [1000 900 500 400 100 90 50 40 10 9 5 4 1]\n                 (reduce (fn [[ret tuple] x]\n                           [(mod ret x)\n                            (let [cnt (int (/ ret x))]\n                              (if (> cnt 0)\n                                (case x\n                                  900 (conj tuple [1 100] [1 1000])\n                                  400 (conj tuple [1 100] [1 500])\n                                  90 (conj tuple [1 10] [1 100])\n                                  40 (conj tuple [1 10] [1 50])\n                                  9 (conj tuple [1 1] [1 10])\n                                  4 (conj tuple [1 1] [1 5])\n                                  (conj tuple [cnt x]))\n                                tuple))]) [num []])\n                 second\n                 (map #(repeat (first %) (second %)))\n                 (apply concat)))]\n    \n    (let [roman-numberals {1 \\I\n                           5 \\V\n                           10 \\X\n                           50 \\L\n                           100 \\C\n                           500 \\D\n                           1000 \\M}]\n\n      (apply str (map roman-numberals (decompose num))))))","user":"5693a53ee4b0dcc4269f4106"},{"code":"(fn to-roman [n]\n  (let [\n  numeral-stack [[\\I \\V \\X]\n                 [\\X \\L \\C]\n                 [\\C \\D \\M]\n                 [\\M nil nil]]\n  impl (fn [acc numeral-stack n]\n    (if (< n 1)\n      acc\n      (let [[one five ten] (first numeral-stack)\n            x (mod n 10)\n            x* (quot n 10)]\n        (-> (cond\n              (== x 0) '()\n              (<= x 3) (repeat x one)\n              (== x 4) (list one five)\n              (== x 5) (list five)\n              (<= x 8) (cons five (repeat (- x 5) one))\n              (== x 9) (list one ten))\n            (cons ,,, acc)\n            (recur ,,, (rest numeral-stack) x*)))))\n  ]\n  (->> n\n       (impl '() numeral-stack)\n       (apply concat)\n       (apply str))))","problem":104,"user":"4e691c79535d8ccf87e9fe97"},{"problem":104,"code":"(let \n[r {1 \\I, 5 \\V, 10 \\X, 50 \\L, 100 \\C, 500 \\D, 1000 \\M }\n\nrmap [\n[\"DCCCC\" \"CM\"] \n[\"CCCC\" \"CD\"] \n[\"LXXXX\" \"XC\"] \n[\"XXXX\" \"XL\"] \n[\"VIIII\" \"IX\"] \n[\"IIII\" \"IV\"]]\n]\n\n(fn [i]\n  (loop [s \"\" ;; accumulating naive string\n         n i  ;; decrementing number\n         ns (-> r keys sort reverse) ;; numeral sequence\n         ]\n    (let [num (first ns) ;; roman-int\n          c (get r num ) ;; roman-char\n          q (quot n num) \n          rep (apply str (repeat q c))\n          next-s (str s rep )\n          next-n (- n (* q num))\n          ]\n      (if (< 0 next-n)\n        (recur \n         next-s\n         next-n\n         (rest ns))\n        \n        ;; this will fix naive string with find/replace, \n        ;; cribbed the idea problem 92 solution by Clobur\n        (reduce #(clojure.string/replace % (first %2) (last %2)) next-s rmap))))))","user":"533a2f7be4b0e30313ee6cb8"},{"problem":104,"code":"(fn roman ([n] (roman n \"\" [1000 \"M\"]\n                           [900 \"CM\"]\n                           [500 \"D\"]\n                           [400 \"CD\"]\n                           [100 \"C\"]\n                           [90 \"XC\"]\n                           [50 \"L\"]\n                           [40 \"XL\"]\n                           [10 \"X\"]\n                           [9 \"IX\"]\n                           [5 \"V\"]\n                           [4 \"IV\"]\n                           [1 \"I\"]))\n  ([n s [i v] & args]\n    (if (zero? n)\n      s\n      (if (> i n)\n        (apply roman n s (first args) (rest args))\n        (apply roman (- n i) (str s v) [i v] args)))\n    ))","user":"598ab445e4b02b9968b84ce0"},{"problem":104,"code":"(fn roman-numeral [number]\n  (let [romans       {1    {:symbol \"I\" :next 5}\n                      5    {:symbol \"V\" :next 10 :prev 1}\n                      10   {:symbol \"X\" :next 50}\n                      50   {:symbol \"L\" :next 100 :prev 10}\n                      100  {:symbol \"C\" :next 500}\n                      500  {:symbol \"D\" :next 1000 :prev 100}\n                      1000 {:symbol \"M\" :next 5000}}\n        get-sym      (fn [num]\n                       (:symbol (get romans num)))\n        get-next-sym (fn [num]\n                       (get-sym (:next (get romans num))))\n        get-prev-sym (fn [num]\n                       (get-sym (:prev (get romans num))))]\n    (apply str (:res (reduce (fn helper [{:keys [res number]} div]\n                               (if (>= number div)\n                                 (let [q (quot number div)\n                                       r (rem number div)]\n                                   (if (= 4 q)\n                                     {:res    (conj res (str (get-sym div)\n                                                             (get-next-sym div)))\n                                      :number r}\n                                     (if (= \\9 (first (seq (str number))))\n                                       {:res    (conj res (str (get-prev-sym div)\n                                                               (get-next-sym div)))\n                                        :number (rem number (- (* 2 div) (:prev (get romans div))))}\n                                       {:res    (conj res (apply str\n                                                                 (repeat q (get-sym div))))\n                                        :number r})))\n                                 {:res    res\n                                  :number number}))\n                             {:res    []\n                              :number number}\n                             [1000 500 100 50 10 5 1])))))","user":"5dc53ddee4b02f9375f4e1bd"},{"code":"(fn numeralise [n]\r\n  (let [numerals [[1000 \"M\"] [900 \"CM\"] [500 \"D\"] [400 \"CD\"] [100 \"C\"] \r\n                  [90 \"XC\"] [50 \"L\"] [40 \"XL\"] [10 \"X\"]\r\n                  [9 \"IX\"] [5 \"V\"] [4 \"IV\"] [1 \"I\"]]\r\n  \t\r\n\t\tnumerate (fn nmr [accrue remainder] \r\n              (println accrue)\r\n\t\t\t\t\t    (if (= 0 remainder) \r\n\t\t\t\t\t\t  accrue \r\n\t\t\t\t\t\t  (let [candidate (first (drop-while #(< remainder (first %)) numerals))]\r\n\t\t\t\t\t\t\t    (nmr (str accrue (nth candidate 1)) (- remainder (first candidate))))))]\r\n\t\t (numerate \"\" n)))","problem":104,"user":"4e6defcc535d5021c1a895f8"},{"code":"(fn dec->roman [num]\n  (letfn [(rn-representation [digit multiplier]\n            (let [rndigits {1 [1] 2 [1 1] 3 [1 1 1] 4 [1 5] 5 [5] 6 [5 1] 7 [5 1 1] 8 [5 1 1 1] 9 [1 10] 10 [10]}\n                  nums {1 \"I\"  10 \"X\"  100 \"C\"  1000 \"M\"\n                        4 \"IV\" 40 \"XL\" 400 \"CD\"\n                        5 \"V\"  50 \"L\"  500 \"D\"\n                        9 \"IX\" 90 \"XC\" 900 \"CM\"}]\n              (map #(nums (* multiplier %)) (rndigits digit))))\n\n          (num-split [num]\n            (let [multipliers (iterate #(* 10 %) 1)\n                  reversed-num (reverse (seq (str num)))]\n              (reverse (map #(vector (Integer/parseInt (str %1)) %2)  reversed-num multipliers))))]\n\n    (apply str (mapcat #(apply rn-representation %) (num-split num)))))","problem":104,"user":"4e3bccb1535deb9a81d77f55"},{"problem":104,"code":"(fn [n]\n    (let [table [[1000 \"M\"]\n                 [900 \"CM\"]\n                 [500 \"D\"]\n                 [400 \"XD\"]\n                 [100 \"C\"]\n                 [90 \"XC\"]\n                 [50 \"L\"]\n                 [40 \"XL\"]\n                 [10 \"X\"]\n                 [9 \"IX\"]\n                 [5 \"V\"]\n                 [4 \"IV\"]\n                 [1 \"I\"]]]\n      (loop [n n\n             acc \"\"]\n        (let [p (first (filter (fn [[test-n _]]\n                                 (<= test-n n))\n                               table))]\n          (if (empty? p)\n            acc\n            (let [[test-n s] p]\n              (recur (- n test-n)\n                     (str acc s))))))))","user":"51b91b08e4b0e871ca4958f8"},{"problem":104,"code":"#(loop [v %                            ;this is arg\n        decoder [[1 \"I\"] [4 \"IV\"] [5 \"V\"]\n                 [9 \"IX\"] [10 \"X\"] [40 \"XL\"]\n                 [50 \"L\"] [90 \"XC\"] [100 \"C\"]\n                 [400 \"CD\"] [500 \"D\"] [900 \"CM\"]\n                 [1000 \"M\"]]\n        result \"\"]\n   (if (zero? v)\n     result\n     (let [d (last decoder)\n           o (int (/ v (first d)))]                          ; occurence\n       (recur (- v (* o (first d)))\n              (butlast decoder)\n              (apply str result (repeat o (last d))))\n       )\n     )\n   )","user":"56f7ecdfe4b08e7d20b96834"},{"code":"(fn [nu]\n\n  (letfn [ (n [o f t x]  (nth \n                          (vector  []\n                                   [o] [o o] [o o o]\n                                   [o f] [f] [f o]\n                                   [f o o] [f o o o] [o t])\n                          x))]\n    (apply str (flatten\n    (map (fn [d [o f t] ] (n o f t (quot (rem nu (* d 10)) d))) [1000 100 10 1]\n         [[\\M \\M \\M] [\\C \\D \\M] [\\X \\L \\C] [\\I \\V \\X]])))))","problem":104,"user":"5124619ae4b02c3f2a072ccd"},{"problem":104,"code":"(fn [x]\n    (let [digit  #(mod (quot x %1) 10)\n          charf (fn [y i v x]\n                  (get [[]\n                        [i]\n                        [i i]\n                        [i i i]\n                        [i v]\n                        [v]\n                        [v i]\n                        [v i i]\n                        [v i i i]\n                        [i x]]\n                       y))]\n      (apply str (concat\n                  (charf (digit 1000) \\M \\Y \\Z)\n                  (charf (digit 100)  \\C \\D \\M)\n                  (charf (digit 10)   \\X \\L \\C)\n                  (charf (digit 1)    \\I \\V \\X)))))","user":"554a75c9e4b0a04f79299575"},{"code":"(partial (fn dec-to-roman [cnt dec]\n        (let [m  [[\"M\" 1000] [\"CM\" 900] [\"D\" 500] [\"CD\" 400]\n            [\"C\" 100] [\"XC\" 90] [\"L\" 50] [\"XL\" 40] [\"X\" 10]\n            [\"IX\" 9] [\"V\" 5] [\"IV\" 4] [\"I\" 1]]\n                 roman-letter ((m cnt) 0) roman-val ((m cnt) 1)]\n          (if (> dec 0)\n              (if (<= ((m cnt) 1) dec)\n                  (str roman-letter (dec-to-roman cnt (- dec roman-val)))\n                  (dec-to-roman (inc cnt) dec))\n              nil))) 0)","problem":104,"user":"4fb591aee4b081705acca2c0"},{"problem":104,"code":"(fn [n]\n  (let [romanize (fn [d [l1 l5 l10]]\n                   (apply str\n                     (case d\n                       0 []\n                       1 [l1]\n                       2 [l1 l1]\n                       3 [l1 l1 l1]\n                       4 [l1 l5]\n                       5 [l5]\n                       6 [l5 l1]\n                       7 [l5 l1 l1]\n                       8 [l5 l1 l1 l1]\n                       9 [l1 l10])))\n        digits (->> [n 0] (iterate (fn [[x _]] [(quot x 10) (rem x 10)]))\n                          (next)\n                          (take-while #(not= % [0 0]))\n                          (map second))]\n    (apply str\n      (reverse\n        (map romanize digits [[\"I\" \"V\" \"X\"]\n                              [\"X\" \"L\" \"C\"]\n                              [\"C\" \"D\" \"M\"]\n                              [\"M\" \"_\" \"_\"]])))))","user":"573d58c8e4b05c31a32c0811"},{"problem":104,"code":"(fn [xs]\n  (loop [xs xs res \"\"]\n    (if (<= xs 0)\n      res\n      (cond\n        (>= xs 1000) (recur (- xs 1000) (str res \"M\"))\n        (>= xs 900) (recur (- xs 900) (str res \"CM\"))\n        (>= xs 500) (recur (- xs 500) (str res \"D\"))\n        (>= xs 400) (recur (- xs 400) (str res \"CD\"))\n        (>= xs 100) (recur (- xs 100) (str res \"C\"))\n        (>= xs 90) (recur (- xs 90) (str res \"XC\"))\n        (>= xs 50) (recur (- xs 50) (str res \"L\"))\n        (>= xs 40) (recur (- xs 40) (str res \"XL\"))\n        (>= xs 10) (recur (- xs 10) (str res \"X\"))\n        (>= xs 9) (recur (- xs 9) (str res \"IX\"))\n        (>= xs 5) (recur (- xs 5) (str res \"V\"))\n        (>= xs 4) (recur (- xs 4) (str res \"IV\"))\n        (>= xs 1) (recur (- xs 1) (str res \"I\"))))))","user":"54e24a05e4b024c67c0cf7ce"},{"problem":104,"code":"(fn to-roman\n  [i]\n  (let [val-map (sorted-map 1000 \"M\" 500 \"D\" 100 \"C\" 50 \"L\" 10 \"X\" 5 \"V\" 1 \"I\"\n                            900 \"CM\" 400 \"CD\" 90 \"XC\" 40 \"XL\" 9 \"IX\" 4 \"IV\")\n        result (first (drop-while #(> % i) ((comp reverse keys) val-map)))]\n    (if result\n      (str (val-map result) (to-roman (- i result))))))","user":"55a9e0fee4b0988bba2ad945"},{"problem":104,"code":"(fn [n]\n  (let [val->letter (sorted-map-by >\n                                   1000 \\M 500 \\D 100 \\C 50 \\L 10 \\X 5 \\V 1 \\I\n                                   900 \"CM\" 400 \"CD\" 90 \"XC\" 40 \"XL\" 9 \"IX\" 4 \"IV\")]\n    (loop [n n res []]\n      (if (zero? n)\n        (clojure.string/join res)\n        (let [[v l] (first (filter #(>= n (key %)) val->letter))]\n          (recur (- n v) (conj res l)))))))","user":"52470d42e4b05ef8e38e6350"},{"code":"(fn deci-to-roman [x]\n  (let [drmap {1    [\"I\" \"II\" \"III\" \"IV\" \"V\" \"VI\" \"VII\" \"VIII\" \"IX\"]\n               10   [\"X\" \"XX\" \"XXX\" \"XL\" \"L\" \"LX\" \"LXX\" \"LXXX\" \"XC\"]\n               100  [\"C\" \"CC\" \"CCC\" \"CD\" \"D\" \"DC\" \"DCC\" \"DCCC\" \"CM\"]\n               1000 [\"M\" \"MM\" \"MMM\"]\n               }\n        decomp  ((fn decompose \n                    ([x] (decompose x 0 '()))\n                    ([x p comp]\n                     (if (= x 0) \n                       (vec comp)\n                       (recur (quot x 10) \n                              (inc p) \n                              (cons [(int (Math/pow 10 p)) (dec (mod x 10))] comp)\n                              )\n                       )\n                     )\n                  ) x)\n        ]\n      (reduce #(str %1 (get-in drmap %2)) \"\" decomp)\n    )\n  )","problem":104,"user":"529a73bde4b02ebb4ef75096"},{"problem":104,"code":"(fn [n] (clojure.pprint/cl-format nil \"~@R\" n))","user":"5ab16992e4b073f1774425c4"},{"code":"(fn to-rn [n]\n  (let [rn {1 \\I 5 \\V 10 \\X 50 \\L 100 \\C 500 \\D 1000 \\M         ;; numbers\n            4 \"IV\" 9 \"IX\" 40 \"XL\" 90 \"XC\" 400 \"CD\" 900 \"CM\"}]   ;; subtractive principle rules\n    (->> (reduce (fn [[d roman :as acc] v]\n              (if (>= d v)\n                (recur [(- d v) (conj roman (rn v))] v)\n                acc)) [n []] (sort > (keys rn)))\n      second\n      (apply str))))","problem":104,"user":"50c781bbe4b00bb60fe0c535"},{"code":"(fn [n]\n  (let [v [1000 \"M\", 900 \"CM\", 500 \"D\", 400 \"CD\", 100 \"C\", 90 \"XC\", 50 \"L\", 40 \"XL\", 10 \"X\", 9 \"IX\", 5 \"V\", 4 \"IV\", 1 \"I\"]]\n    (loop [x n y v res []]\n      (if (= x 0) (apply str res)\n        (recur (if (>= (- x (first y)) 0) (- x (first y)) x)\n               (if (>= (- x (first y)) 0) y (nnext y))\n               (if (>= (- x (first y)) 0) (conj res (second y)) res))))))","problem":104,"user":"53a1b5c8e4b0ca733b9744c1"},{"code":"(fn [n]\n  (apply str (let [a (quot n 1000)\n        b (quot (- n (* a 1000)) 100)\n        c (quot (- n (* a 1000) (* b 100)) 10)\n        d (quot (- n (* a 1000) (* b 100) (* c 10)) 1)]\n    [(case a\n        0 nil\n        1 \"M\"\n        2 \"MM\"\n        3 \"MMM\")\n      (case b\n        0 nil\n        1 \"C\"\n        2 \"CC\"\n        3 \"CCC\"\n        4 \"CM\"\n        5 \"D\"\n        6 \"DC\"\n        7 \"DCC\"\n        8 \"DCCC\"\n        9 \"CM\")\n      (case c\n        0 nil\n        1 \"X\"\n        2 \"XX\"\n        3 \"XXX\"\n        4 \"XL\"\n        5 \"L\"\n        6 \"LX\"\n        7 \"LXX\"\n        8 \"LXXX\"\n        9 \"XC\")\n      (case d\n        0 nil\n        1 \"I\"\n        2 \"II\"\n        3 \"III\"\n        4 \"IV\"\n        5 \"V\"\n        6 \"VI\"\n        7 \"VII\"\n        8 \"VIII\"\n        9 \"IX\")])))","problem":104,"user":"51899891e4b0288ada3dbdab"},{"problem":104,"code":"(fn wroman [decimal-number]\n  (let [m { 1 \"I\", 5 \"V\", 10 \"X\", 50 \"L\", 100 \"C\", 500 \"D\", 1000 \"M\"}\n        tens (sorted-set-by > 1000 100 10 1)\n        nums (reverse (sort (keys m)))]\n    (loop\n        [n decimal-number\n         rlist nums\n         s \"\"]\n      (let [r (first rlist)\n            p10 (first (filter #(< % r) tens))]\n        ;(println \"n\" n \"r\" r \"p10\" p10 \"rlist\" rlist \"s\" s)\n        (cond\n          (= n 0) s\n          (>= n r)\n          (recur (- n r) rlist (str s (get m r)))\n          (>= n (- r p10))\n          (recur (- n (- r p10)) (rest rlist) (str s (get m p10) (get m r)))\n          :else (recur n (rest rlist) s))))))","user":"54e3df6ae4b024c67c0cf7e3"},{"problem":104,"code":"#((reduce (fn [[a n] [z x v i]]\n              [(str a ((vec  (map (fn [p] (apply str p))\n                                  [[] [i] [i i] [i i i] [i v]\n                                   [v] [v i] [v i i]\n                                   [v i i i] [i x]]))\n                       (quot n z)))\n                      (rem n z)])\n                 [\"\" %]\n                 [[1000 \"\" \"\" \"M\"]\n                  [100  \"M\" \"D\" \"C\"]\n                  [10   \"C\" \"L\" \"X\"]\n                  [1    \"X\" \"V\" \"I\"]]) 0)","user":"505106fee4b05ab4c7e07d38"},{"problem":104,"code":"#(let [data [[\"\" \"I\" \"II\" \"III\" \"IV\" \"V\" \"VI\" \"VII\" \"VIII\" \"IX\"]\n             [\"\" \"X\" \"XX\" \"XXX\" \"XL\" \"L\" \"LX\" \"LXX\" \"LXXX\" \"XC\"]\n             [\"\" \"C\" \"CC\" \"CCC\" \"CD\" \"D\" \"DC\" \"DCC\" \"DCCC\" \"CM\"]\n             [\"\" \"M\" \"MM\" \"MMM\"]]]\n   (letfn [(digits [n] (if (zero? n) [] (conj (digits (int (/ n 10))) (rem n 10))))]\n     (apply str (reverse (map (fn [d s] (s d)) (reverse (digits %)) data)))))","user":"551ed214e4b08d5046aa8a4d"},{"problem":104,"code":"(fn gen-rn [n] (let [num-vals {\"I\" 1 \"IV\" 4 \"V\" 5 \"IX\" 9 \"X\" 10 \"XL\" 40 \"L\" 50 \"XC\" 90 \"C\" 100 \"CD\" 400 \"D\" 500 \"CM\" 900 \"M\" 1000}\n                    numerals [\"M\" \"CM\" \"D\" \"CD\" \"C\" \"XC\" \"L\" \"XL\" \"X\" \"IX\" \"V\" \"IV\" \"I\"]]\n                (loop [remainder n result \"\"]\n                  (if (= remainder 0) \n                    result \n                    (let [best (first (second (split-with #(> (num-vals %) remainder) numerals)))]\n                      (recur (- remainder (num-vals best)) (str result best)))))))","user":"542c1f73e4b0dad94371f29d"},{"problem":104,"code":"(fn numerals\n  [x]\n  (let [nums {1000 \"M\", 900 \"CM\", 500 \"D\", 400 \"CD\", 100 \"C\",\n              90 \"XC\", 50 \"L\", 40 \"XL\", 10 \"X\", 9 \"IX\", 5 \"V\", 4 \"IV\", 1 \"I\"}]\n    (loop [n x\n           res \"\"]\n      (if-let\n        [sym (last (filter (partial >= n) (sort (keys nums))))]\n        (recur (- n sym) (str res (nums sym)))\n        res))))","user":"56449e4de4b0284900eef5f9"},{"code":"(fn [n & rs]\n  (let [romans [[1000 \"M\"] [900 \"CM\"] [500 \"D\"] [400 \"CD\"]\n                [100  \"C\"] [90  \"XC\"] [50  \"L\"] [40  \"XL\"]\n                [10   \"X\"] [9   \"IX\"] [5   \"V\"] [4   \"IV\"] [1 \"I\"]]\n        r (first (filter #(>= n (first %)) romans))]\n    (if (> n 0)\n      (recur (- n (first r)) (concat rs (second r)))\n      (apply str rs))))","problem":104,"user":"4eb51942535d7eef30807365"},{"code":"(fn [n]\n  (letfn [(rd [roman arabic [n accu]]\n              (let\n                [how-many (int (/ n arabic))\n                 remain (- n (* how-many arabic))]\n                [remain (apply str accu (repeat how-many roman))]))]\n      (->> [n \"\"]\n       (rd \"M\" 1000)\n       (rd \"CM\" 900)\n       (rd \"D\" 500)\n       (rd \"CD\" 400)\n       (rd \"C\" 100)\n       (rd \"XC\" 90)\n       (rd \"L\" 50)\n       (rd \"XL\" 40)\n       (rd \"X\" 10)\n       (rd \"IX\" 9)\n       (rd \"V\" 5)\n       (rd \"IV\" 4)\n       (rd \"I\" 1)\n       last\n           )))","problem":104,"user":"50217818e4b00bba4502f7a7"},{"code":"(fn [i]\n  (loop [s (str i) a \"IVXLCDM  \" m [\"\" \"1\" \"11\" \"111\" \"12\" \"2\" \"21\" \"211\" \"2111\" \"13\"] r []]\n\t\t(if (empty? s)\n\t\t\t(apply str (flatten (reverse r)))\n\t\t\t(recur \n\t\t\t\t(butlast s)\n\t\t\t\t(drop 2 a)\n\t\t\t\tm\n\t\t\t\t(conj\n\t\t\t\t\tr\n\t\t\t\t\t(replace\n\t\t\t\t\t\t{\\1 (nth a 0) \\2 (nth a 1) \\3 (nth a 2)}\n\t\t\t\t\t\t(nth m (-> s last int (- 48)))))))))","problem":104,"user":"4db85282535d1e037afb218a"},{"problem":104,"code":"(fn solve [n]\n  (let [num->roman {1000 \"M\" 900 \"CM\" 500 \"D\" 400 \"CD\" 100 \"C\" 90 \"XC\" 50 \"L\" 40 \"XL\" 10 \"X\" 9 \"IX\" 5 \"V\" 4 \"IV\" 1 \"I\"}]\n    (->> (keys num->roman)\n         sort\n         reverse\n         (reduce (fn [[roman m] d]\n                   [(apply str roman (repeat (quot m d) (num->roman d))) (rem m d)])\n                 [\"\" n])\n         first)))","user":"56444fb1e4b0018b46ad8c0c"},{"code":"(fn num-to-roman [in]\n  (loop [s \"\" n in]\n    (if (= 0 n)\n      s\n      (let [[k v]\n            (reduce #(if (> (key %) (key %2)) % %2)\n             (filter\n              #(>= n (key %))\n              {1000 \"M\" 900 \"CM\" 500 \"D\" 400 \"CD\"\n               100 \"C\" 90 \"XC\" 50 \"L\" 40 \"XL\"\n               10 \"X\" 9 \"IX\" 5 \"V\" 4 \"IV\" 1 \"I\"}))]\n        (recur\n         (str s v)\n         (- n k))))))","problem":104,"user":"519136e9e4b0f8ef0be96c01"},{"code":"(fn [n]\n  (let [ones (mod n 10)\n        tens (mod (int (/ n 10)) 10)\n        hundreds (mod (int (/ n 100)) 10)\n        thousands (mod (int (/ n 1000)) 10)]\n    (apply str (concat (take thousands (repeat \\M))\n                       (cond\n                        (= hundreds 9) [\\C \\M]\n                        (= hundreds 4) [\\C \\D]\n                        (>= hundreds 5) (concat [\\D] (take (- hundreds 5) (repeat \\C)))\n                        :else (take hundreds (repeat \\C)))\n                       (cond\n                        (= tens 9) [\\X \\C]\n                        (= tens 4) [\\X \\L]\n                        (>= tens 5) (concat [\\L] (take (- tens 5) (repeat \\X)))\n                        :else (take tens (repeat \\X)))\n                       (cond\n                        (= ones 9) [\\I \\X]\n                        (= ones 4) [\\I \\V]\n                        (>= ones 5) (concat [\\V] (take (- ones 5) (repeat \\I)))\n                        :else (take ones (repeat \\I)))))))","problem":104,"user":"5186134ce4b0da5a5be3bac7"},{"code":"(fn [x]\n  (let [s \"0123456789\"\n        t (zipmap s (iterate #(str \\M %) \"\"))\n        h (zipmap s [\"\" \"C\" \"CC\" \"CCC\" \"CD\" \"D\" \"DC\" \"DCC\" \"DCCC\" \"CM\"])\n        n (zipmap s [\"\" \"X\" \"XX\" \"XXX\" \"XL\" \"L\" \"LX\" \"LXX\" \"LXXX\" \"XC\"])\n        u (zipmap s [\"\" \"I\" \"II\" \"III\" \"IV\" \"V\" \"VI\" \"VII\" \"VIII\" \"IX\"])\n        m [t h n u]]\n    (apply str (map #(% %2) (drop (- 4 (count (str x))) m) (str x)))))","problem":104,"user":"52479487e4b05ef8e38e6373"},{"problem":104,"code":"(fn [n]\n    (letfn [(digits [n]\n                    (loop [n n\n                           acc '()]\n                        (if (= n 0)\n                            acc\n                            (recur (quot n 10) (cons (rem n 10) acc)))))\n            (pad [s n e]\n                 (loop [s s]\n                     (if (<= n (count s))\n                         s\n                         (recur (cons e s)))))]\n        (let [ones {0 \"\" 1 \"I\" 2 \"II\" 3 \"III\" 4 \"IV\" 5 \"V\" 6 \"VI\" 7 \"VII\" 8 \"VIII\" 9 \"IX\"}\n              tens {0 \"\" 1 \"X\" 2 \"XX\" 3 \"XXX\" 4 \"XL\" 5 \"L\" 6 \"LX\" 7 \"LXX\" 8 \"LXXX\" 9 \"XC\"}\n              huns {0 \"\" 1 \"C\" 2 \"CC\" 3 \"CCC\" 4 \"CD\" 5 \"D\" 6 \"DC\" 7 \"DCC\" 8 \"DCCC\" 9 \"CM\"}\n              thss {0 \"\" 1 \"M\" 2 \"MM\" 3 \"MMM\"}\n              maps (list thss huns tens ones)]\n        (clojure.string/join \"\" (map (fn [[f v]] (f v)) (map list maps (pad (digits n) 4 0)))))))","user":"600ae927e4b074f607df6689"},{"code":"(fn [n]\n  (let [getnums (fn [h l] (int (/ (rem n h) l)) )\n        numthou (int (/ n 1000))\n        num5hun (getnums 1000 500)\n        numhun (getnums 500 100)\n        numfifty (getnums 100 50)\n        numten (getnums 50 10)\n        numfive (getnums 10 5)\n        numone (getnums 5 1)\n        rf (fn [nh nl sl sh su]\n             (cond\n              (and (= nl 4) (zero? nh)) (str sl sh)\n              (and (= nl 4) (not (zero? nh))) (str sl su)\n              :else (apply str (concat (repeat nh sh) (repeat nl sl)))))\n        ones (rf numfive numone \"I\" \"V\" \"X\")\n        tens (rf numfifty numten \"X\" \"L\" \"C\")\n        huns (rf num5hun numhun \"C\" \"D\" \"M\")\n        thous (apply str (repeat numthou \"M\"))]\n   (apply str (concat thous huns tens ones)) ))","problem":104,"user":"5133e51ae4b0d7a043de8cf6"},{"code":"(fn toromanstr [n]\n    (let [vals [[1000 \\M]\n                [900 \"CM\"]\n                [500 \\D]\n                [400 \"CD\"]\n                [100 \\C]\n                [90 \"XC\"]\n                [50 \\L]\n                [40 \"XL\"]\n                [10 \\X]\n                [9 \"IX\"]\n                [5 \\V]\n                [4 \"IV\"]\n                [1 \\I]]]\n      (loop [res \"\"\n             todo n\n             [[first-val first-char] & rest-vals] vals]\n        (if (= 0 todo)\n          (apply str res)\n          (recur\n            (concat res (apply str (repeat (quot todo first-val) first-char)))\n            (rem todo first-val)\n            rest-vals))))\n\n  )","problem":104,"user":"5165a235e4b079ad97ec44ac"},{"problem":104,"code":"(fn [n]\n    (let [num-map {\\I 1 \"IV\" 4 \\V 5 \"IX\" 9 \\X 10 \"XL\" 40\n                   \\L 50 \"XC\" 90 \\C 100 \"CD\" 400 \\D 500 \"CM\" 900 \\M 1000}]\n      (loop [i n acc \"\"]\n        (if (= i 0)\n          acc\n          (let [[c v] (->> num-map\n                           (filter (fn [[k v]] (<= v i)))\n                           (sort-by second)\n                           last)]\n            (recur (- i v) (str acc c)))))))","user":"527ccaf4e4b0757a1b17136d"},{"code":"(fn wrn [n]\n    (let [nlm (merge (zipmap  [1 5 10 50 100 500 1000] (map str \"IVXLCDM\"))\n                {4 \"IV\" 9 \"IX\" 40 \"XL\" 90 \"XC\" 400 \"CD\" 900 \"CM\"})]\n      (loop [w \"\" x n]\n        (if (zero? x) w\n            (let [j (apply max (filter #(>= x %) (keys nlm)))]\n              (recur (str w (nlm j)) (- x j)))))\n      ))","problem":104,"user":"5267d9bde4b03e8d9a4a7188"},{"problem":104,"code":"(fn [x]\n  (let [ma {1 [1] 2 [1 1] 3 [1 1 1] 4 [ 1 5] 5 [5]\n             6 [5 1] 7 [5 1 1] 8 [5 1 1 1] 9 [1 10]}\n        mb  {0 {1 \\I 5 \\V 10 \\X}\n             1 {1 \\X 5 \\L 10 \\C}\n             2 {1 \\C 5 \\D 10 \\M}\n             3 {1 \\M}}\n        x1 (reverse (map #(- (int %)48) (into [] (str x))))\n        x2 (map ma x1)\n        t (fn [m v] (map #(m %) v))\n        x3 (reverse (keep-indexed #(t (mb %) %2) x2)) ]\n    (apply str (flatten x3))))","user":"566d71b1e4b0a866af6896ca"},{"code":"(let [m {1 \"I\" 2 \"II\" 3 \"III\" 4 \"IV\" 5 \"V\" 6 \"VI\" 7 \"VII\" 8 \"VIII\" 9 \"IX\"\n 10 \"X\" 20 \"XX\" 30 \"XXX\" 40 \"XL\" 50 \"L\" 60 \"LX\" 70 \"LXX\" 80 \"LXXX\" 90 \"XC\"\n 100 \"C\" 200 \"CC\" 300 \"CCC\" 400 \"CD\" 500 \"D\" 600 \"DC\" 700 \"DCC\" 800 \"DCCC\" 900 \"CM\"\n 1000 \"M\" 2000 \"MM\" 3000 \"MMM\"}]\n  \n  (fn [n] (str \n            (m (* 1000 (quot n 1000)))\n            (m  (* 100 (quot (mod n 1000) 100)))\n            (m  (* 10 (quot (mod n 100) 10)))\n            (m  (mod n 10))\n            )\n            ))","problem":104,"user":"503917a0e4b088a6a14ca763"},{"code":"(fn [n] (loop [n n rst \"\"]\n           (cond\n            (> n 999) (recur (- n 1000) (str rst \"M\"))\n            (> n 899) (recur (- n 900)  (str rst \"CM\"))\n            (> n 499) (recur (- n 500)  (str rst \"D\"))\n            (> n 399) (recur (- n 400)  (str rst \"CD\"))\n            (> n 99)  (recur (- n 100)  (str rst \"C\"))\n            (> n 89)  (recur (- n 90)   (str rst \"XC\"))\n            (> n 49)  (recur (- n 50)   (str rst \"L\"))\n            (> n 39)  (recur (- n 40)   (str rst \"XL\"))\n            (> n 9)   (recur (- n 10)   (str rst \"X\"))\n            (> n 8)   (recur (- n 9)    (str rst \"IX\"))\n            (> n 4)   (recur (- n 5)    (str rst \"V\"))\n            (> n 3)   (recur (- n 4)    (str rst \"IV\"))\n            (> n 0)   (recur (- n 1)    (str rst \"I\"))\n            :default  rst)))","problem":104,"user":"4efd8b67535de96065cf5085"},{"problem":104,"code":"(fn ->roman [n]\n   (let [TABLE {\n                0 {1 \"I\"\n                   2 \"II\"\n                   3 \"III\"\n                   4 \"IV\"\n                   5 \"V\"\n                   6 \"VI\"\n                   7 \"VII\"\n                   8 \"VIII\"\n                   9 \"IX\"}\n                1 {1 \"X\"\n                   2 \"XX\"\n                   3 \"XXX\"\n                   4 \"XL\"\n                   5 \"L\"\n                   6 \"LX\"\n                   7 \"LXX\"\n                   8 \"LXXX\"\n                   9 \"XC\"}\n                2 {1 \"C\"\n                   2 \"CC\"\n                   3 \"CCC\"\n                   4 \"CD\"\n                   5 \"D\"\n                   6 \"DC\"\n                   7 \"DCC\"\n                   8 \"DCCC\"\n                   9 \"CM\"}\n                3 {1 \"M\"\n                   2 \"MM\"\n                   3 \"MMM\"}}\n         nums (vec (reverse (str n)))\n         ->int #(- (int %) (int \\0))]\n     (apply str (reverse (for [i (range (count nums))]\n                 ((TABLE i) (->int (nums i)))\n                 )))))","user":"55a372f1e4b0acc240e31537"},{"code":"(fn [n]\n  (let [rls [[\\I \\V] [\\X \\L] [\\C \\D] [\\M]]\n        digits (vec ((fn digs [x] (if-not (zero? x) (conj (digs (quot x 10)) (mod x 10)))) n))\n        chs (fn [n c] (apply str (repeat n c)))\n        digit-to-letters (fn [place digit]\n                           (let [[l-one l-five] (rls place)]\n                             (case digit\n                               4 (str l-one l-five)\n                               9 (str l-one ((rls (inc place)) 0))\n                               (if (< digit 5)\n                                 (chs digit l-one)\n                                 (str l-five (chs (- digit 5) l-one))\n                                 ))))]\n    (->> digits (map-indexed digit-to-letters) (reverse) (apply str))))","problem":104,"user":"506ab9bae4b05d3b7762c74c"},{"problem":104,"code":"(fn wrn [n]\n  (if (zero? n)\n    nil\n    (condp <= n\n          1000 (str \\M (wrn (- n 1000)))\n          900 (str \\C \\M (wrn (- n 900)))\n          500 (str \\D (wrn (- n 500)))\n          400 (str \\C \\D (wrn (- n 400)))\n          100 (str \\C (wrn (- n 100)))\n          90 (str \\X \\C (wrn (- n 90)))\n          50 (str \\L (wrn (- n 50)))\n          40 (str \\X \\L (wrn (- n 40)))\n          10 (str \\X (wrn (- n 10)))\n          9 (str \\I \\X (wrn (- n 9)))\n          5 (str \\V (wrn (- n 5)))\n          4 (str \\I \\V (wrn (- n 4)))\n          1 (str \\I (wrn (- n 1)))\n          )\n    )\n  )","user":"55f2c898e4b06e875b46ce4b"},{"problem":104,"code":"(fn roman [n]\n  (let [dict {1 \"I\", 4 \"IV\", 5 \"V\", 9 \"IX\",\n              10 \"X\", 40 \"XL\", 50 \"L\", 90 \"XC\",\n              100 \"C\", 400 \"CD\", 500 \"D\", 900 \"CM\",\n              1000 \"M\"}\n        digs [1000 900 500 400 100 90 50 40 10 9 5 4 1]\n        glue (fn [xs i d]\n               (->> (quot i d)\n                (#(if (zero? %)\n                  xs\n                  (apply conj xs (repeat % (dict d)))))))\n        folder (fn [[i ret] d]\n                 [(rem i d) (glue ret i d)])]\n    (apply str (second\n                (reduce folder [n []] digs)))))","user":"5ba15075e4b0a20761a2339e"},{"code":"(fn r [x]\r\n  (if (= x 0) \"\"\r\n    (let [R (sorted-map 1 \"I\", 4 \"IV\", 5 \"V\", 9 \"IX\", 10 \"X\", 40 \"XL\", 50 \"L\",\r\n             90 \"XC\", 100 \"C\", 400 \"CD\", 500 \"D\", 900 \"CM\", 1000 \"M\")\r\n          m (first (filter #(>= x (key %)) (reverse R)))]\r\n    (str (val m) (r (- x (key m)))))))","problem":104,"user":"4f1b92d1535d64f60314647b"},{"problem":104,"code":"#(let [m (sorted-map-by > 1000 \"M\" 900 \"CM\" 500 \"D\" 400 \"CD\" 100 \"C\" 90 \"XC\" 50 \"L\" 40 \"XL\" 10 \"X\" 9 \"IX\" 5 \"V\" 4 \"IV\" 1 \"I\")]\n   (loop [n %, s \"\"]\n     (if (zero? n)\n       s\n       (let [[[k v]] (drop-while (fn [[k v]] (> k n)) m)]\n         (recur (- n k) (str s v))))))","user":"5e3e23d9e4b01d43a70e8e20"},{"problem":104,"code":"(fn [number]\n   (let [numerals {0 [\"I\" \"V\"] 1 [\"X\" \"L\"] 2 [\"C\" \"D\"] 3 [\"M\"]}\n         num-to-roman (fn rec-roman [numnum exp] (cond\n                                         (< numnum 4) (concat (repeat numnum (first (get numerals exp))))\n                                         (< numnum 5) (concat (first (get numerals exp)) (second (get numerals exp)))\n                                         (< numnum 9) (concat (second (get numerals exp)) (rec-roman (- numnum 5) exp))\n                                         :else (concat (first (get numerals exp)) (first (get numerals (inc exp))))))\n         rec-helper (fn [numlist] (loop [numlist numlist\n                                                acc \"\"]\n                                           (if (empty? numlist)\n                                             acc\n                                             (recur (rest numlist) (concat acc (num-to-roman (first numlist) (dec (count numlist))))))))]\n     (apply str (rec-helper (map read-string (map str (str number)))))))","user":"571cd9dce4b0145328a76271"},{"code":"(fn [n]\n   (let [roman [[1000 \"M\"]\n                [900 \"CM\"]\n                [500 \"D\"]\n                [400 \"CD\"]\n                [100 \"C\"]\n                [90 \"XC\"]\n                [50 \"L\"]\n                [40 \"XL\"]\n                [10 \"X\"]\n                [9 \"IX\"]\n                [5 \"V\"]\n                [4 \"IV\"]\n                [1 \"I\"]]]\n                  (clojure.string/join (apply concat (loop [n n\n                                               [[k c] & rest-roman :as roman] roman\n                                               acc []]\n                                          (if (nil? roman)\n                                            acc\n                                            (let [q (int (/ n k))\n                                                  m (mod n k)]\n                                              (if (= q 0)\n                                                (recur n\n                                                       rest-roman\n                                                       acc)\n                                                (recur (- n k)\n                                                       roman\n                                                       (conj acc c))))))))))","problem":104,"user":"4e9fd521535d7eef3080729a"},{"problem":104,"code":"(fn [n]\n  (let [digits (fn digits [n] (conj (if (> n 9) (digits (quot n 10)) []) (rem n 10)))\n        pad-left (fn [n x coll] (concat (repeat (- n (count coll)) x) coll))\n        thousands [\"\", \"M\", \"MM\", \"MMM\", \"MMMM\", \"MMMMM\", \"MMMMMM\", \"MMMMMMM\", \"MMMMMMMM\", \"MMMMMMMMM\"]\n        hundreds [\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"]\n        tens [\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"]\n        units [\"\", \"I\" \"II\" \"III\" \"IV\" \"V\" \"VI\" \"VII\" \"VIII\" \"IX\"]]\n    (let [digits (->> (digits n) (pad-left 4 0) vec)]\n      (str (thousands (digits 0)) (hundreds (digits 1)) (tens (digits 2)) (units (digits 3))))))","user":"56dc3bdfe4b0ea9b8538f819"},{"problem":104,"code":"(fn [x]\n  (let [romans {1 \"I\", 5 \"V\", 10 \"X\", 50 \"L\", 100 \"C\", 500 \"D\", 1000 \"M\"}]\n    (letfn [(alternate-fns-seq\n              ([x fn1 fn2 & fns]\n               (alternate-fns-seq x (cycle (concat [fn1 fn2] fns))))\n              ([x fns]\n               (cons x (lazy-seq (alternate-fns-seq\n                                   ((first fns) x)\n                                   (rest fns))))))\n            (parts [number factors]\n              (loop [x number\n                     factors factors\n                     parts []]\n                (let [part (mod x (first factors))] \n                  (if (<= x 0)\n                    parts\n                    (recur (- x part)\n                           (rest factors)\n                           (conj parts part))))))\n            (decimal-parts [number]\n              (parts number (iterate (partial * 10) 10)))\n            (roman-parts [number]\n              (parts number\n                     (alternate-fns-seq 5\n                                        (partial * 2)\n                                        (partial * 5))))\n            (roman-difference [part]\n              (let [values (sort > (keys romans))]\n                (when-let\n                  [[x y _] (->> (for [x values\n                                      y values :when (< y x)\n                                      :let [diff (- x y)]\n                                      :when (= part diff)]\n                                  [x y diff])\n                                (first))]\n                  (apply str (romans y) (romans x)))))\n            (roman-sum [part]\n              (let [values (sort (keys romans))\n                    value-sums (zipmap values (roman-parts part))\n                    freqs (reduce-kv \n                            (fn [result value sum]\n                              (assoc result value (/ sum value)))\n                            {} value-sums)]\n                (->> (reduce\n                       (fn [result value]\n                         (if-let [freq (freqs value)]\n                           (conj result (apply str (repeat freq (romans value))))\n                           result))\n                       [] (reverse values))\n                     (apply str))))\n            (roman-representation [part]\n              (or (romans part)\n                  (roman-difference part)\n                  (roman-sum part)))\n            (roman-numerals [x]\n              (apply str\n                     (map roman-representation\n                          (reverse (decimal-parts x)))))]\n      (roman-numerals x))))","user":"50ebd63ce4b04edc3377703c"},{"problem":104,"code":"(fn t [n]\n  (let [r [{1 \"I\" 2 \"II\" 3 \"III\" 4 \"IV\" 5 \"V\" 6 \"VI\" 7 \"VII\" 8 \"VIII\" 9 \"IX\"}\n\t       {1 \"X\" 2 \"XX\" 3 \"XXX\" 4 \"XL\" 5 \"L\" 6 \"LX\" 7 \"LXX\" 8 \"LXXX\" 9 \"XC\"}\n           {1 \"C\" 2 \"CC\" 3 \"CCC\" 4 \"CD\" 5 \"D\" 6 \"DC\" 7 \"DCC\" 8 \"DCCC\" 9 \"CM\"}\n           {1 \"M\" 2 \"MM\" 3 \"MMM\" 4 \"MMMM\"}]]\n    (->> (loop [x n c []]\n           (if (> x 0)\n             (recur (quot x 10) (conj c (rem x 10)))\n             c))\n         (map #(% %2) r)\n         reverse\n         (apply str))))","user":"543366dde4b0b6b47310fcdf"},{"problem":104,"code":"(fn [num]\n            (let [ordered-map [[\"M\" 1000]\n                               [\"CM\" 900]\n                               [\"D\"  500]\n                               [\"CD\" 400]\n                               [\"C\"  100]\n                               [\"XC\"  90]\n                               [\"L\"   50]\n                               [\"XL\"  40]\n                               [\"X\"   10]\n                               [\"IX\"   9]\n                               [\"V\"    5]\n                               [\"IV\"   4]\n                               [\"I\"    1]]]\n              (loop [roman \"\" remaining num]\n                (if (> remaining 0)\n                  (let [[k v] (first (filter #(>= remaining (second %)) ordered-map))]\n                    (recur (str roman k) (- remaining v)))\n                  roman))))","user":"5a91988ae4b002d099cae6f9"},{"code":"(fn r-numerals\n  [n]\n  (let [m {1 \"I\" 4 \"IV\" 5 \"V\" 9 \"IX\" 10 \"X\" 40 \"XL\" 50 \"L\" 90 \"XC\" 100 \"C\" 400 \"CD\" 500 \"D\" 900 \"CM\" 1000 \"M\"}\n        v (reverse [1 4 5 9 10 40 50 90 100 400 500 900 1000])]\n    (if (= 0 n) nil\n      (let [nxt (some #(when (>= n %) %) v)]\n        (apply str (m nxt) (r-numerals (- n nxt)))))))","problem":104,"user":"4edf5dc6535d10e5ff6f5340"},{"problem":104,"code":"(fn romanize [num]\n\t(loop [imed num,\n\t\torderleft [1000, 500, 100, 50, 10, 5, 1],\n\t\tresult []\n\t\t]\n\t\t(if (empty? orderleft)\n\t\t\t(do (prn result)\n\t\t\t(-> (clojure.string/join \"\" result)\n\t\t\t\t(clojure.string/replace \"VIIII\" \"IX\")\n\t\t\t\t(clojure.string/replace \"LXXXX\" \"XC\")\n\t\t\t\t(clojure.string/replace \"DCCCC\" \"CM\")\n\t\t\t\t(clojure.string/replace \"IIII\" \"IV\")\n\t\t\t\t(clojure.string/replace \"XXXX\" \"XL\")\n\t\t\t\t(clojure.string/replace \"CCCC\" \"CD\")\n\t\t\t)\n\t\t\t)\n\t\t\t(let [\n\t\t\t\tdivunit (first orderleft),\n\t\t\t\tsubt (quot imed divunit),\n\t\t\t\tbasemap (hash-map\n\t\t\t\t\t1 \"I\", 5 \"V\",\n\t\t\t\t\t10 \"X\", 50 \"L\",\n\t\t\t\t\t100 \"C\", 500 \"D\",\n\t\t\t\t\t1000 \"M\")\n\t\t\t\t]\n\t\t\t\t(recur\n\t\t\t\t\t(- imed (* subt divunit))\n\t\t\t\t\t(rest orderleft)\n\t\t\t\t\t(concat\n\t\t\t\t\t\tresult\n\t\t\t\t\t\t(repeat subt (basemap divunit))\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t)\n\t)\n)","user":"5d73530ce4b02e6b30c93514"},{"code":"(fn [n]\n  (let [sub-largest-numeral (fn [n]\n                              (let [values [[\"M\" 1000] [\"CM\" 900] [\"D\" 500] [\"CD\" 400] [\"C\" 100] [\"XC\" 90] [\"L\" 50] [\"XL\" 40] [\"X\" 10] [\"IX\" 9] [\"V\" 5] [\"IV\" 4] [\"I\" 1]]]\n                                (->> (map #(identity [(- n (second %)) (first %)]) values)\n                                 (drop-while #(> 0 (first %)))\n                                 first)))\n        ]\n    (loop [accum [] value (sub-largest-numeral n)]\n      (if (nil? value)\n        (clojure.string/join accum)\n        (recur (conj accum (second value)) (sub-largest-numeral (first value)))))))","problem":104,"user":"524740e7e4b05ef8e38e635d"},{"problem":104,"code":"(fn [n]\n  (let [m \n        {1    {0 \"\" 1 \"I\" 2 \"II\" 3 \"III\" 4 \"IV\" 5 \"V\" 6 \"VI\" 7 \"VII\" 8 \"VIII\" 9 \"IX\"}\n         10   {0 \"\" 1 \"X\" 2 \"XX\" 3 \"XXX\" 4 \"XL\" 5 \"L\" 6 \"LX\" 7 \"LXX\" 8 \"LXXX\" 9 \"XC\"}\n         100  {0 \"\" 1 \"C\" 2 \"CC\" 3 \"CCC\" 4 \"CD\" 5 \"D\" 6 \"DC\" 7 \"DCC\" 8 \"DCCC\" 9 \"CM\"}\n         1000 {0 \"\" 1 \"M\" 2 \"MM\" 3 \"MMM\"}}]\n   (str (get-in m [1000 (quot n 1000)])\n        (get-in m [100  (quot (rem n 1000) 100)])\n        (get-in m [10   (quot (rem n 100)  10)])\n        (get-in m [1    (quot (rem n 10)   1)]))))","user":"56ae214ce4b03c432f18735a"},{"problem":104,"code":"(fn to-roman\n  [n]\n  (let [numerals [[1000 \"M\"]\n                  [900 \"CM\"]\n                  [500 \"D\"]\n                  [400 \"CD\"]\n                  [100 \"C\"]\n                  [90 \"XC\"]\n                  [50 \"L\"]\n                  [40 \"XL\"]\n                  [10 \"X\"]\n                  [9 \"IX\"]\n                  [5 \"V\"]\n                  [4 \"IV\"]\n                  [1 \"I\"]]\n        [v r] (first (drop-while (fn [[v r]] (> v n)) numerals))]\n    (if (= n 0) \"\"\n        (str r (to-roman (- n v))))))","user":"5c222b7de4b07e362c230588"},{"problem":104,"code":"(fn to-roman\n  [arabic]\n  (let [lookup\n        [[1000 \\M]\n         [900 \"CM\"]\n         [500 \\D]\n         [400 \"CD\"]\n         [100 \\C]\n         [90 \"XC\"]\n         [50 \\L]\n         [40 \"XL\"]\n         [10 \\X]\n         [9 \"IX\"]\n         [5 \\V]\n         [4 \"IV\"]\n         [1 \\I]]]\n    (apply str\n           (first\n            (reduce\n             (fn [[sofar arabrest] [nextunit nextsymbol]]\n               (let [in-nextunits  (int (/ arabrest nextunit))\n                     ]\n                 [(into sofar\n                        (repeat in-nextunits nextsymbol))\n                  (mod arabrest nextunit)]))\n             [[] arabic]\n             lookup)))))","user":"5bf9d9b7e4b0bdcf453d15c4"},{"code":"(fn [n]\n  (apply str\n         ((fn f [n]\n            (let [c [[1000 \"M\"]\n                     [900 \"CM\"]\n                     [500 \"D\"]\n                     [400 \"CD\"]\n                     [100 \"C\"]\n                     [90 \"XC\"]\n                     [50 \"L\"]\n                     [40 \"XL\"]\n                     [10 \"X\"]\n                     [9 \"IX\"]\n                     [5 \"V\"]\n                     [4 \"IV\"]\n                     [1 \"I\"]]\n                  [a r] (first (filter #(>= n (first %)) c))]\n              (if (zero? n)\n                \"\"\n                (cons r (f (- n a)))))) n)))","problem":104,"user":"52951156e4b02ebb4ef7501b"},{"problem":104,"code":";I=1, V=5, X=10, L=50, C=100, D=500, M=1000,\n(fn [n]\n  (apply str\n  \t(loop [cur [], n n, M [\"\" \"\" \"M\" \"D\" \"C\" \"L\" \"X\" \"V\" \"I\"], base 1000]\n      (if (= n 0) cur\n      \t(recur (conj cur \n                     (case (quot n base)\n                       0 \"\"\n                       1 (str (M 2))\n                       2 (str (M 2) (M 2))\n                       3 (str (M 2) (M 2) (M 2))\n                       4 (str (M 2) (M 1))\n                       5 (str (M 1))\n                       6 (str (M 1) (M 2))\n                       7 (str (M 1) (M 2) (M 2))\n                       8 (str (M 1) (M 2) (M 2) (M 2))\n                       9 (str (M 2) (M 0))))\n               (rem n base) \n               (into [] (rest (rest M))) \n               (/ base 10))))))","user":"57015a1de4b08d47c97781d4"},{"code":"(fn [x] (let [n [(zipmap (range 0 10) '(\"\" \"I\" \"II\" \"III\" \"IV\" \"IV\" \"VI\" \"VII\" \"VIII\" \"IX\"))\n                  (zipmap (range 0 10) '(\"\" \"X\" \"XX\" \"XXX\" \"XL\" \"L\" \"LX\" \"LXX\" \"LXXX\" \"XC\"))\n                  (zipmap (range 0 10) '(\"\" \"C\" \"CC\" \"CCC\" \"CD\" \"D\" \"DC\" \"DCC\" \"DCCC\" \"CM\"))\n                  (zipmap (range 0 4) '(\"\" \"M\" \"MM\" \"MMM\"))                  \n      ]] (apply str (reverse (map-indexed #((n %) %2) (reverse (map #(- (int %) 48) (str x))))))))","problem":104,"user":"4eb13d60535d7eef3080733f"},{"code":"(fn roman \n  ([n] (roman \"\" n))\n  ([s n]\n  (cond\n   (zero? n) s\n   (>= n 1000) (recur (str s \"M\") (- n 1000))\n   (>= n 900) (recur (str s \"CM\") (- n 900))\n   (>= n 500) (recur (str s \"D\") (- n 500))\n   (>= n 400) (recur (str s \"CD\") (- n 400))\n   (>= n 100) (recur (str s \"C\") (- n 100))\n   (>= n 90) (recur (str s \"XC\") (- n 90))\n   (>= n 50) (recur (str s \"L\") (- n 50))\n   (>= n 40) (recur (str s \"XL\") (- n 40))\n   (>= n 10) (recur (str s \"X\") (- n 10))\n   (>= n 9) (recur (str s \"IX\") (- n 9))\n   (>= n 5) (recur (str s \"V\") (- n 5))\n   (>= n 4) (recur (str s \"IV\") (- n 4))\n   (>= n 1) (recur (str s \"I\") (- n 1))\n   :else s\n   ))\n  )","problem":104,"user":"52e59ca5e4b09f7907dd1464"},{"code":"(fn [num]\n        (let [row (fn [[s d b]]\n                      (zipmap \"123456789\" \n                              [(str s), (str s s),\n                               (str s s s), (str s d), \n                               (str d), (str d s), \n                               (str d s s), (str d s s s), \n                               (str s b)])),\n             [t h d s] (format \"%4d\" num)]\n             (str ((row \"M??\") t)\n                  ((row \"CDM\") h)\n                  ((row \"XLC\") d)\n                  ((row \"IVX\") s))))","problem":104,"user":"4e599577535d8a8b8723a29f"},{"code":"(fn [z]\n(let [m {1 \"I\", 4  \"IV\",\n        5 \"V\", 9 \"IX\", 10 \n        \"X\", 40 \"XL\", 50 \"L\",\n        90 \"XC\", 100 \"C\", 400 \"XD\", \n        500 \"D\", 900 \"CM\" 1000 \"M\"}]\n(letfn [(rn [x [h & t]]\n  (if (> x 0)\n    (let [n (quot x h)]\n      (if (> n 0)\n        (let [r (rem x h)\n              s (m h)] \n          (concat (repeat n s) (rn r t)))\n        (rn x t)))))]\n  \n  (reduce str (rn z (sort > (keys m)))))))","problem":104,"user":"4ffa8affe4b0678c553fc3bd"},{"problem":104,"code":"(fn [n]\n  (let \n   [f (fn [c d [n r]]\n        (if (>= (- n d) 0) \n          [(- n d)\n           (concat r c)]\n          [n \n           r]))]\n   (->> [n \"\"]\n        (f \"M\" 1000)\n        (f \"M\" 1000)\n        (f \"M\" 1000)\n        (f \"M\" 1000)\n        (f \"CM\" 900)\n        (f \"D\"  500)\n        (f \"CD\" 400)\n        (f \"C\"  100)\n        (f \"C\"  100)\n        (f \"C\"  100)\n        (f \"XC\"  90)\n        (f \"L\"   50)\n        (f \"XL\"  40)\n        (f \"X\"   10)\n        (f \"X\"   10)\n        (f \"X\"   10)\n        (f \"IX\"   9)\n        (f \"V\"    5)\n        (f \"IV\"   4)\n        (f \"I\"    1)\n        (f \"I\"    1)\n        (f \"I\"    1)\n        (last)\n        (apply str))))","user":"578cf84ce4b0ebec4cfb7562"},{"code":"(fn [n] \n    (apply str ((fn roman [n]\n      (if (> n 0)\n        (let [values [[1000 \"M\"], [900 \"CM\"], [500 \"D\"],\n                      [400 \"CD\"], [100 \"C\"], [90 \"XC\"],\n                      [50 \"L\"], [40 \"XL\"], [10 \"X\"],\n                      [9 \"IX\"], [5 \"V\"], [4 \"IV\"], [1 \"I\"]]\n              to-remove (first (filter #(>= n (first %)) values))\n              m (first to-remove)\n              c (second to-remove)]\n          (concat c (roman (- n m))))\n        ())) n)))","problem":104,"user":"5141abf1e4b02fd87f5064c3"},{"code":"(fn roman [n]\n  (letfn [(n-str [n s]\n                 (if (<= n 0)\n                   nil\n                   (str s (n-str (- n 1) s))))]\n    (cond \n     (not (zero? (quot n 1000)))\n     (str (n-str (quot n 1000) \"M\")\n          (roman (mod n 1000)))\n     \n     (= 9 (quot n 100))\n     (str \"CM\"\n          (roman (mod n 100)))\n     \n     (= 1 (quot n 500))\n     (str \"D\"\n          (roman (mod n 500)))\n     \n     (= 4 (quot n 100))\n     (str \"CD\"\n          (roman (mod n 100)))\n     \n     (not (zero? (quot n 100)))\n     (str (n-str (quot n 100) \"C\")\n          (roman (mod n 100)))\n     \n     (= 9 (quot n 10))\n     (str \"XC\"\n          (roman (mod n 10)))\n     \n     (= 1 (quot n 50))\n     (str \"L\"\n          (roman (mod n 50)))\n     \n     \n     (= 4 (quot n 10))\n     (str \"XL\"\n          (roman (mod n 10)))\n     \n     (not (zero? (quot n 10)))\n     (str (n-str (quot n 10) \"X\")\n          (roman (mod n 10)))\n     \n     (= 9 n)\n     \"IX\"\n     \n     (= 1 (quot n 5))\n     (str \"V\"\n          (roman (mod n 5)))\n     \n     (= 4 n)\n     \"IV\"\n     \n     (not (zero? n))\n     (n-str n \"I\"))))","problem":104,"user":"531d34cfe4b08068f379edac"},{"problem":104,"code":"(fn [n]\n  (loop [r \"\" x n vs [1000 \"M\" 900 \"CM\" 500 \"D\" 400 \"CD\" 100 \"C\" 90 \"XC\" 50 \"L\" 40 \"XL\" 10 \"X\" 9 \"IX\" 5 \"V\" 4 \"IV\" 1 \"I\"]]\n    (cond (= x 0) r\n          (>= x (first vs)) (recur (str r (second vs)) (- x (first vs)) vs)\n          :else (recur r x (drop 2 vs)))))","user":"55c20bd0e4b0e31453f64972"},{"problem":104,"code":"#(let [rs {0 {\\0 \"\", \\1 \"I\", \\2 \"II\", \\3 \"III\", \\4 \"IV\", \\5 \"V\", \\6 \"VI\", \\7 \"VII\", \\8 \"VIII\", \\9 \"IX\"}\n           1 {\\0 \"\", \\1 \"X\", \\2 \"XX\", \\3 \"XXX\", \\4 \"XL\", \\5 \"L\", \\6 \"LX\", \\7 \"LXX\", \\8 \"LXXX\", \\9 \"XC\"}\n           2 {\\0 \"\", \\1 \"C\", \\2 \"CC\", \\3 \"CCC\", \\4 \"CD\", \\5 \"D\", \\6 \"DC\", \\7 \"DCC\", \\8 \"DCCC\", \\9 \"CM\"}\n           3 {\\0 \"\", \\1 \"M\", \\2 \"MM\", \\3 \"MMM\"}}]\n   (->> %\n     (str)\n     (reverse)\n     (map (fn [p d] (get-in rs [p d])) (range))\n     (reverse)\n     (apply str)))","user":"5a4de614e4b05d388ecb6bb1"},{"code":"(fn r[x] \r\n  (let [W { 1 \"I\" 4 \"IV\" 5 \"V\" 9 \"IX\" 10 \"X\" 40 \"XL\" 50 \"L\" 90 \"XC\" 100 \"C\" 500 \"D\" 900 \"CM\" 1000 \"M\" }]\r\n  (letfn [(largest [y] (apply max (filter #(<= % y) (keys W))))]\r\n    (if (<= x 0) \"\" (str (W (largest x)) (r (- x (largest x))))))))","problem":104,"user":"4ec0c7ba535dfed6da9c6da4"},{"problem":104,"code":"(fn [n]\n  (let [numbers [[1000 \"M\"] [900 \"CM\"] [500 \"D\"] [400 \"CD\"] [100 \"C\"]\n                 [90 \"XC\"] [50 \"L\"] [40 \"XL\"] [10 \"X\"] [9 \"IX\"]\n                 [5 \"V\"] [4 \"IV\"] [1 \"I\"]]]\n    (loop [n n acc \"\"]\n      (if (zero? n)\n        acc\n        (let [[a b] (first (filter (fn [[a b]] (<= a n)) numbers))]\n          (recur (- n a) (str acc b)))))))","user":"5cc6b4bfe4b0ccb061962827"},{"code":"(fn to-roman\n  ([x] \n    (to-roman x [[\"M\" 1000]\n                 [\"CM\" 900]\n                 [\"D\"  500]\n                 [\"CD\" 400]\n                 [\"C\"  100]\n                 [\"XC\"  90]\n                 [\"L\"   50]\n                 [\"XL\"  40]\n                 [\"X\"   10]\n                 [\"IX\"   9]\n                 [\"V\"    5]\n                 [\"IV\"   4]\n                 [\"I\"    1]]))\n  ([x romans]\n    (if (zero? x)\n      \"\"\n      (let [[roman value] (first romans)\n            q (quot x value)\n            r (rem  x value)\n            s (apply str (take q (repeat roman)))]\n        (str s (to-roman r (rest romans)))))))","problem":104,"user":"4ee6400c535d93acb0a6685b"},{"code":"(fn roman# [n & s]\n  (let [s (first (or s '(\"\")))]\n    (if (<= n 0) s\n      (cond\n       (>= n 1000) (roman# (- n 1000) (str s \"M\"))\n       (>= n 900) (roman# (- n 900) (str s \"CM\"))\n       (>= n 500) (roman# (- n 500) (str s \"D\"))\n       (>= n 400) (roman# (- n 400) (str s \"CD\"))\n       (>= n 100) (roman# (- n 100) (str s \"C\"))\n       (>= n 90) (roman# (- n 90) (str s \"XC\"))\n       (>= n 50) (roman# (- n 50) (str s \"L\"))\n       (>= n 40) (roman# (- n 40) (str s \"XL\"))\n       (>= n 10) (roman# (- n 10) (str s \"X\"))\n       (>= n 9) (roman# (- n 9) (str s \"IX\"))\n       (>= n 5) (roman# (- n 5) (str s \"V\"))\n       (>= n 4) (roman# (- n 4) (str s \"IV\"))\n       (>= n 1) (roman# (- n 1) (str s \"I\"))))))","problem":104,"user":"504f865ee4b0a02f9cffde90"},{"code":"(fn [n]\n  (str\n   ({1 \"M\" 2 \"MM\" 3 \"MMM\" 4 \"MMMM\" 5 \"D\" 6 \"DC\" 7 \"DCC\" 8 \"DCCC\" 9 \"CM\"} (mod (quot n 1000) 10))\n   ({1 \"C\" 2 \"CC\" 3 \"CCC\" 4 \"CD\" 5 \"D\" 6 \"DC\" 7 \"DCC\" 8 \"DCCC\" 9 \"CM\"} (mod (quot n 100) 10))\n   ({1 \"X\" 2 \"XX\" 3 \"XXX\" 4 \"XL\" 5 \"L\" 6 \"LX\" 7 \"LXX\" 8 \"LXXX\" 9 \"XC\"} (mod (quot n 10) 10))\n   ({1 \"I\" 2 \"II\" 3 \"III\" 4 \"IV\" 5 \"V\" 6 \"VI\" 7 \"VII\" 8 \"VIII\" 9 \"IX\"} (mod n 10))))","problem":104,"user":"503b6995e4b07a1917cc34dd"},{"problem":104,"code":"(fn write-roman [s]\n    (letfn [(digits [n]\n            (loop [n n\n                   r '()]\n              (if (= n 0)\n                r\n                (let [rem (mod n 10)\n                      div (quot n 10)]\n                  (recur div (conj r rem))))))\n            ]\n      (let [mask {1 \"I\" 2 \"II\" 3 \"III\" 4 \"IV\" 5 \"V\" 6 \"VI\" 7 \"VII\" 8 \"VIII\" 9 \"IX\"\n                 10 \"X\" 20 \"XX\" 30 \"XXX\" 40 \"XL\" 50 \"L\" 60 \"LX\" 70 \"LXX\" 80 \"LXXX\" 90 \"XC\"\n                 100 \"C\" 200 \"CC\" 300 \"CCC\" 400 \"CD\" 500 \"D\" 600 \"DC\" 700 \"DCC\" 800 \"DCCC\"\n                 900 \"CM\" 1000 \"M\" 2000 \"MM\" 3000 \"MMM\"}\n            digs (digits s)]\n        (loop [digs digs\n               resp \"\"]\n          (if (= digs [])\n            resp\n            (let [d (first digs)\n                  n (dec (count digs))\n                  v (mask (* d (apply * (repeat n 10))))]\n              (recur (rest digs) (str resp v))))))))","user":"574f1c24e4b02ea114799255"},{"code":"(fn [r n]\n  (let [rn (sorted-map-by > 1000 \\M 900 \"CM\" 500 \\D 400 \"CD\" 100 \\C 90 \"XC\" 50 \\L 40 \"XL\" 10 \\X 9 \"IX\" 5 \\V 4 \"IV\" 1 \\I)]\n    (if (zero? n) \n      r\n      (let [[d s] (some #(when (>= n (first %)) %) rn)] \n        (recur (str r s) (- n d))))))\n\"\"","problem":104,"user":"4f991ec1e4b0dcca54ed6cfb"},{"code":"(fn [n]\n  (loop [i n s \"\"]\n    (cond (>= i 1000) (recur (- i 1000) (str s \"M\"))\n          (>= i 900) (recur (- i 900) (str s \"CM\"))\n          (>= i 500) (recur (- i 500) (str s \"D\"))\n          (>= i 400) (recur (- i 400) (str s \"CD\"))\n          (>= i 100) (recur (- i 100) (str s \"C\"))\n    \t  (>= i 90) (recur (- i 90) (str s \"XC\"))\n          (>= i 50) (recur (- i 50) (str s \"L\"))\n          (>= i 40) (recur (- i 40) (str s \"XL\"))\n          (>= i 10) (recur (- i 10) (str s \"X\"))\n          (>= i 9) (recur (- i 9) (str s \"IX\"))\n          (>= i 5) (recur (- i 5) (str s \"V\"))\n          (>= i 4) (recur (- i 4) (str s \"IV\"))\n          (>= i 1) (recur (- i 1) (str s \"I\"))\n          :else s\n    )))","problem":104,"user":"53300924e4b019098a6f8b55"},{"problem":104,"code":"(fn solve [x]\n  (let [lookup [{\\A \\I \\B \\V \\C \\X} {\\A \\X \\B \\L \\C \\C} {\\A \\C \\B \\D \\C \\M} {\\A \\M}]\n        base [\"\" \"A\" \"AA\" \"AAA\" \"AB\" \"B\" \"BA\" \"BAA\" \"BAAA\" \"AC\"]\n        recursive (fn help [x i]\n                    (let [last-part (apply str (map (nth lookup i) (nth base (rem x 10))))]\n\t                  (if \n                        (< x 10) last-part\n                        (str (help (quot x 10) (inc i)) last-part))))]\n    (recursive x 0)))","user":"56f258d3e4b04a395b9a04a1"},{"problem":104,"code":"(fn [n]\n  (apply str\n  (loop [n n\n         digits [] \n         pairs [[1000 \"M\"] [900 \"CM\"] [500 \"D\"]\n                [400 \"CD\"] [100 \"C\"] [90 \"XC\"]\n                [50 \"L\"] [40 \"XL\"] [10 \"X\"]\n                [9 \"IX\"] [5 \"V\"] [4 \"IV\"] [1 \"I\"]]]\n    (if (= n 0)\n      digits\n      (let [[value digit] (first pairs)\n            q (quot n value)]\n        (recur\n          (- n (* q value))\n          (concat digits (repeat q digit))\n          (rest pairs)\n        ))))))","user":"5aa998c6e4b0d174b936c8e5"},{"problem":104,"code":"(fn [n]\n  (let [rn (sorted-map 1 \"I\" 4 \"IV\" 5 \"V\" 9 \"IX\" 10 \"X\" 40 \"XL\" 50 \"L\" 90 \"XC\" 100 \"C\" 400 \"CD\" 500 \"D\" 900 \"CM\" 1000 \"M\")\n        biggest-fit (fn [x] (last (filter #(<= % x) (keys rn))))]\n    (loop [remainder n roman \"\"]\n      (if (zero? remainder)\n        roman\n        (let [next-num (biggest-fit remainder)]\n          (recur (- remainder next-num) (str roman (rn next-num))))))))","user":"55c4cda5e4b0e31453f649a5"},{"code":"(fn f [x]\n  (let [m {\"I\" 1 \"V\" 5 \"X\" 10 \"L\" 50 \"C\" 100 \"D\" 500 \"M\" 1000\n  \"CM\" 900 \"XC\" 90 \"XL\" 40 \"IV\" 4 \"IX\" 9}\n        k (apply max-key #(if (<= (m %) x) (m %) -1) (keys m))]\n    (if (zero? x)\n      \"\"\n      (str k (f (- x (m k)))))))","problem":104,"user":"5054bc87e4b0b1b9d1860eb0"},{"problem":104,"code":"(fn write-roman [n]\n  (let [some? #(not= % nil)\n        digits {0 \"\" 1 \"I\" 2 \"II\" 3 \"III\" 4 \"IV\" 5 \"V\" 6 \"VI\" 7 \"VII\" 8 \"VIII\" 9 \"IX\"}\n        tens{0 \"\" 1 \"X\" 2 \"XX\" 3 \"XXX\" 4 \"XL\" 5 \"L\" 6 \"LI\" 7 \"LII\" 8 \"LIII\" 9 \"XC\"}\n        hundreds {0 \"\" 1 \"C\" 2 \"CC\" 3 \"CCC\" 4 \"CD\" 5 \"D\" 6 \"DC\" 7 \"DCC\" 8 \"DCCC\" 9 \"CM\"}\n        thou \"M\"\n        [d te h th] (map #(mod % 10) (take-while #(not= 0 %) (iterate #(quot % 10) n))) ]    \n    (apply str (flatten            \n                (filter some?   \n                        [(if (nil? th) nil (repeat th \"M\")) \n                         (hundreds h) \n                         (tens te)  \n                         (digits d)])))\n\n))","user":"57a0f256e4b0c3d858beb8dd"},{"code":"(fn [n]\n  (let [numerals [1000 \"M\" 900 \"CM\" 500 \"D\" 400 \"CD\"\n                  100 \"C\" 90 \"XC\" 50 \"L\" 40 \"XL\"\n                  10 \"X\" 9 \"IX\" 5 \"V\" 4 \"IV\"\n                  1 \"I\"]]\n    (loop [v n\n           res []\n           [worth letters & rest-numerals :as numerals] numerals]\n      (if worth\n        (if (<= worth v)\n          (recur (- v worth) (conj res letters) numerals)\n          (recur v res rest-numerals))\n        (clojure.string/join res)))))","problem":104,"user":"4fc3a72ae4b081705acca342"},{"problem":104,"code":"(fn [n]\n   (let [romans [[1000 \"M\"]\n                 [900 \"CM\"]\n                 [500 \"D\"]\n                 [400 \"CD\"]\n                 [100 \"C\"]\n                 [90 \"XC\"]\n                 [50 \"L\"]\n                 [40 \"XL\"]\n                 [10 \"X\"]\n                 [9 \"IX\"]\n                 [5 \"V\"]\n                 [4 \"IV\"]\n                 [1 \"I\"]]\n         find-le (fn [n] (->> romans (drop-while #(> (first %) n)) first))]\n     (loop [v n\n            roman []]\n       (if (zero? v)\n         (apply str roman)\n         (let [[le-n le-t] (find-le v)]\n           (recur (- v le-n) (conj roman le-t)))))))","user":"5cb41c40e4b026601754b911"},{"problem":104,"code":"(fn peu [x] (let [f #(> x %) g #(apply str (concat % (peu (- x %2))))] (cond (f 999) (g \"M\" 1000) (f 899) (g \"CM\" 900) (f 499) (g \"D\" 500) (f 399) (g \"CD\" 400) (f 99) (g \"C\" 100) (f 89) (g \"XC\" 90) (f 49) (g \"L\" 50) (f 39) (g \"XL\" 40) (f 9) (g \"X\" 10) (f 8) (g \"IX\" 9) (f 4) (g \"V\" 5) (f 3) (g \"IV\" 4) (f 0) (g \"I\" 1) :else \"\")))","user":"53fc8424e4b0de5c418485b3"},{"code":"(fn roman [n]\r\n  (cond\r\n    (>= n 1000)(str \"M\" (roman (- n 1000)))\r\n    (>= n 900) (str \"CM\" (roman (- n 900)))\r\n    (>= n 500) (str \"D\" (roman (- n 500)))\r\n    (>= n 100) (str \"C\" (roman (- n 100)))\r\n    (>= n 90)  (str \"XC\" (roman (- n 90)))\r\n    (>= n 50)  (str \"L\" (roman (- n 50)))\r\n    (>= n 40)  (str \"XL\" (roman (- n 40)))\r\n    (>= n 10)  (str \"X\" (roman (- n 10)))\r\n    (>= n 9)   (str \"IX\" (roman (- n 9)))\r\n    (>= n 5)   (str \"V\" (roman (- n 5)))\r\n    (>= n 4)   (str \"IV\" (roman (- n 4)))\r\n    (>= n 1)   (str \"I\" (roman (- n 1)))\r\n    :else \"\"))","problem":104,"user":"4f3cc2fbe4b0e243712b1f55"},{"problem":104,"code":"(fn [v]\n  (letfn [(rdig [d one five ten]\n            (cond (< d 4) (repeat d one)\n                  (= d 4) (concat [one] [five])\n                  (= d 9) (concat [one] [ten])\n                  :else (concat [five] (repeat (- d 5) one))))\n          (place [v power] (quot (mod v (* 10 power)) power))]\n    (apply str (concat (repeat (place v 1000) \"M\")\n                       (rdig (place v 100) \"C\" \"D\" \"M\")\n                       (rdig (place v 10) \"X\" \"L\" \"C\")\n                       (rdig (place v 1) \"I\" \"V\" \"X\"))))\n  )","user":"55f09e7be4b06e875b46ce28"},{"problem":104,"code":"(fn dr [digit]\n  (let [s \"\"\n        a1 (quot digit 1000)\n        [s1 b1] (if (> a1 0) [(str s (apply str (repeat a1 \"M\"))) (- digit (* a1 1000))] [s digit])\n        [s2 b2] (cond (>= b1 900) [(str s1 \"CM\") (- b1 900)]\n                      (and (< b1 900) (>= b1 500)) [(str s1 \"D\") (- b1 500)]\n                      (and (< b1 500) (>= b1 400)) [(str s1 \"CD\") (- b1 400)]\n                      :else [s1 b1])\n        a2 (quot b2 100)\n        [s3 b3] (if (> a2 0) [(str s2 (apply str (repeat a2 \"C\"))) (- b2 (* a2 100))] [s2 b2])\n        [s4 b4] (cond (>= b3 90) [(str s3 \"XC\") (- b3 90)]\n                      (and (< b3 90) (>= b3 50)) [(str s3 \"L\") (- b3 50)]\n                      (and (< b3 50) (>= b3 40)) [(str s3 \"XL\") (- b3 40)]\n                      :else [s3 b3])\n        a3 (quot b4 10)\n        [s5 b5] (if (> a3 0) [(str s4 (apply str (repeat a3 \"X\"))) (- b4 (* a3 10))] [s4 b4])\n        s6 (cond (= b5 9) (str s5 \"IX\")\n                 (= b5 4) (str s5 \"IV\")\n                 (and (< b5 9) (>= b5 5)) (str s5 \"V\" (apply str (repeat (rem b5 5) \"I\")))\n                      :else (str s5 (apply str (repeat (rem b5 5) \"I\"))))] \n    s6))","user":"564d3169e4b0284900eef67c"},{"problem":104,"code":"(fn [x]\n  (letfn [(digit->units [x]\n            (case (mod x 10) 0 \"\" 1 \"I\" 2 \"II\" 3 \"III\" 4 \"IV\"\n                  5 \"V\" 6 \"VI\" 7 \"VII\" 8 \"VIII\" 9 \"IX\"))\n          (digit->tens [x]\n            (case (-> (quot x 10) (mod 10))\n                  0 \"\" 1 \"X\" 2 \"XX\" 3 \"XXX\" 4 \"XL\"\n                  5 \"L\" 6 \"LX\" 7 \"LXX\" 8 \"LXXX\" 9 \"XC\"))\n          (digit-hundreds [x]\n            (case (-> (quot x 100) (mod 10))\n                  0 \"\" 1 \"C\" 2 \"CC\" 3 \"CCC\" 4 \"CD\"\n                  5 \"D\" 6 \"DC\" 7 \"DCC\" 8 \"DCCC\" 9 \"CM\"))\n          (digit->thousands [x]\n            (apply str \"\" (repeat (-> (quot x 1000) (mod 10)) \"M\")))]\n    (apply str ((juxt digit->thousands digit-hundreds digit->tens digit->units) x))))","user":"5e08c3dde4b0978307768fc8"},{"problem":104,"code":"(fn [n]\n\t(let [t \n\t\t\t{\n\t\t\t1000\t\\M\n\t\t\t900\t\t\"CM\"\n\t\t\t500\t\t\\D\n\t\t\t400\t\t\"CD\"\n\t\t\t100\t\t\\C\n\t\t\t90\t\t\"XC\"\n\t\t\t50\t\t\\L\n\t\t\t40\t\t\"XL\"\n\t\t\t10\t\t\\X\n\t\t\t9\t\t\"IX\"\n\t\t\t5\t\t\\V\n\t\t\t4\t\t\"IV\"\n\t\t\t1\t\t\\I\n\t\t\t}\n\t\t   s (sort > (keys t))]\n\t(loop [v n p []]\n\t\t(if (zero? v)\n\t\t\t(apply str (map t p))\n\t\t\t(let [i (first (filter #(>= v %) s))]\n\t\t\t\t(recur (- v i) (conj p i)))))))","user":"563dfc02e4b0da801c4e4662"},{"code":"(fn write-roman-number\n  ([x]\n    (write-roman-number x \"\"))\n  ([x y]\n    (println x y)\n    (if (= x 0)\n      y\n      (if (> x 999)\n        (write-roman-number (- x 1000) (str y \"M\"))\n        (if (> x 899)\n          (write-roman-number (- x 900) (str y \"CM\"))\n          (if (> x 499)\n            (write-roman-number (- x 500) (str y \"D\"))\n            (if (> x 399)\n              (write-roman-number (- x 400) (str y \"CD\"))\n              (if (> x 99)\n                (write-roman-number (- x 100) (str y \"C\"))\n                (if (> x 89)\n                  (write-roman-number (- x 90) (str y \"XC\"))\n                  (if (> x 49)\n                    (write-roman-number (- x 50) (str y \"L\"))\n                    (if (> x 39)\n                      (write-roman-number (- x 40) (str y \"XL\"))\n                      (if (> x 9)\n                        (write-roman-number (- x 10) (str y \"X\"))\n                        (if (> x 8)\n                          (write-roman-number (- x 9) (str y \"IX\"))\n                          (if (> x 4)\n                            (write-roman-number (- x 5) (str y \"V\"))\n                            (if (> x 3)\n                              (write-roman-number (- x 4) (str y \"IV\"))\n                              (write-roman-number (- x 1) (str y \"I\")))))))))))))))))","problem":104,"user":"4e16bdef535d04ed9115e7e9"},{"problem":104,"code":"(fn[x]\n  (apply str\n  (let [rom-map {1000 \\M, 500 \\D, 100 \\C, 50 \\L, 10 \\X, 5 \\V, 1 \\I}]\n    (loop [acc [] val x base 1000]\n      (let [next-base (max 1 (/ base 10))]\n        (cond \n          (>= 0 val)\n          acc\n          (< val base)\n          (recur acc val next-base)\n          (= 9 (quot val base))\n          (recur (conj acc (rom-map base) (rom-map (* 10 base))) (- val (* 9 base)) next-base)\n          (<= 5 (quot val base))\n          (recur (conj acc (rom-map (* 5 base))) (- val (* 5 base)) base)\n          (= 4 (quot val base))\n          (recur (conj acc (rom-map base) (rom-map (* 5 base))) (- val (* 4 base)) next-base)\n          :otherwise\n          (recur (conj acc (rom-map base)) (- val base) base)))))))","user":"57011eb3e4b08d47c97781d1"},{"problem":104,"code":"(fn [n]\n  (let [digits (map #(Character/getNumericValue %) (str n))\n        [d c b a] (concat (reverse digits) (repeat 0))\n        a' (apply str (repeat a \\M))\n        b' ([\"\" \"C\" \"CC\" \"CCC\" \"CD\" \"D\" \"DC\" \"DCC\" \"DCCC\" \"CM\"] b)\n        c' ([\"\" \"X\" \"XX\" \"XXX\" \"XL\" \"L\" \"LX\" \"LXX\" \"LXXX\" \"XC\"] c)\n        d' ([\"\" \"I\" \"II\" \"III\" \"IV\" \"V\" \"VI\" \"VII\" \"VIII\" \"IX\"] d)]\n    (str a' b' c' d')))","user":"597dcb0ce4b0dbe32238d0a2"},{"problem":104,"code":"(fn [x]\n  (let [sn (vec (map read-string (re-seq #\"\\d\" (format \"%04d\" x))))]\n(letfn [(conv [n s un fv nin]\n    (cond (> 4 n) (str (apply str (repeat n un)) s)\n      (= 4 n) (str un fv s)\n      (< 4 n 9) (str (str fv (apply str (repeat (- n 5) un))) s)\n\t  :else (str nin s)    \n  \t)\n       )]\n(-> \n (conv (sn 3) \"\" \"I\" \"V\" \"IX\")\n    (#(conv (sn 2) % \"X\" \"L\" \"XC\"))\n    (#(conv (sn 1) % \"C\" \"D\" \"CM\"))\n    (#(conv (sn 0) % \"M\" \"\" \"\"))\n    )\n  )    \n  )\n)","user":"5be6d0f8e4b0f319e2d7ec51"},{"problem":104,"code":"(fn [n]\n  (apply\n    str\n    (map #(nth %2 %1)\n         (reverse (map #(mod (quot n %) 10) (take 4 (iterate #(* 10 %) 1))))\n         [(take 10 (iterate #(str % \"M\") \"\"))\n          [\"\" \"C\" \"CC\" \"CCC\" \"CD\" \"D\" \"DC\" \"DCC\" \"DCCC\" \"CM\"]\n          [\"\" \"X\" \"XX\" \"XXX\" \"XL\" \"L\" \"LX\" \"LXX\" \"LXXX\" \"XC\"]\n          [\"\" \"I\" \"II\" \"III\" \"IV\" \"V\" \"VI\" \"VII\" \"VIII\" \"IX\"]\n          ])))","user":"553abb28e4b09218d5f44ffb"},{"problem":104,"code":"(fn to-roman-number [number]\n  (let [parse-number (fn [number]\n                       (reverse\n                         (loop [n number acc [] d 1]\n                           (if (> n 0)\n                             (recur (quot n 10) (conj acc (* d (mod n 10))) (* d 10))\n                             acc))))\n        number-to-roman (zipmap\n                          [1 2 3 4 5 6 7 8 9\n                           10 20 30 40 50 60 70 80 90\n                           100 200 300 400 500 600 700 800 900\n                           1000 2000 3000]\n                          [\"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\",\n                           \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\",\n                           \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\",\n                           \"M\", \"MM\", \"MMM\"])]\n\n    (apply str (map number-to-roman (parse-number number)))))","user":"5e0d948fe4b099d064962f98"},{"problem":104,"code":"(let [parts-seq\n      (fn parts-seq [n table]\n        (lazy-seq\n          (when-not (zero? n)\n            (let [[[g c] :as table] (drop-while #(< n (second %)) table)]\n              (concat g (parts-seq (- n c) table))))))\n      parts-table\n      [[[\"M\"] 1000] [[\"C\" \"M\"] 900] [[\"D\"] 500] [[\"C\" \"D\"] 400] [[\"C\"] 100]\n       [[\"X\" \"C\"] 90] [[\"L\"] 50] [[\"X\" \"L\"] 40] [[\"X\"] 10] [[\"I\" \"X\"] 9]\n       [[\"V\"] 5] [[\"I\" \"V\"] 4] [[\"I\"] 1]]]\n  (fn [n]\n    (->> (parts-seq n parts-table)\n         (clojure.string/join \"\"))))","user":"51dafedee4b09f6bc204eee2"},{"code":"(fn[n]\n  (let [a2r-map {1000 \"M\" 900 \"CM\" 500 \"D\" 100 \"C\" 90 \"XC\" 40 \"XL\"\n                    50 \"L\" 9 \"IX\" 10 \"X\" 4 \"IV\" 5 \"V\" 1 \"I\"}]\n       (loop [curr-n n\n              curr []\n              divis (sort > (keys a2r-map))\n              divi (first divis)]\n         (if (= curr-n 0)\n           (apply str curr)\n           (if (>= curr-n divi)\n             (recur (- curr-n divi) (conj curr (a2r-map divi)) divis divi)\n             (recur curr-n curr (rest divis) (fnext divis)))))))","problem":104,"user":"4e58bcd4535d8a8b8723a296"},{"problem":104,"code":"(fn [n] (let [parts [[1000  \\M   ]  \n                     [900   \"CM\" ]  \n                     [500   \\D   ]  \n                     [100   \\C   ]  \n                     [90    \"XC\" ]  \n                     [50    \\L   ]  \n                     [40    \"XL\" ]  \n                     [10    \\X   ]  \n                     [9     \"IX\" ]  \n                     [5     \\V   ]  \n                     [4     \"IV\" ]  \n                     [1     \\I   ]]]      \n          (loop [r n      \n                 s \"\"]      \n            (if (zero? r) s      \n              (let [match (first (filter #(>= r (first %)) parts))]      \n                (recur (- r (first match)) (str s (second match))))))))","user":"5bafd5c8e4b0a20761a234dd"},{"problem":104,"code":"(fn i->roman [n]\n  (-> \n    n\n    (repeat \\I)\n    (->> (apply str))\n    (clojure.string/replace #\"IIIII\" \"V\")\n    (clojure.string/replace #\"IIII\" \"IV\")\n    (clojure.string/replace #\"VV\" \"X\")\n    (clojure.string/replace #\"VIV\" \"IX\")\n    (clojure.string/replace #\"XXXXX\" \"L\")\n    (clojure.string/replace #\"XXXX\" \"XL\")\n    (clojure.string/replace #\"LL\" \"C\")\n    (clojure.string/replace #\"LXL\" \"XC\")\n    (clojure.string/replace #\"CCCCC\" \"D\")\n    (clojure.string/replace #\"CCCC\" \"CD\")\n    (clojure.string/replace #\"DD\" \"M\")\n    (clojure.string/replace #\"DCD\" \"CM\")))","user":"566ff0a1e4b0a866af6896ec"},{"problem":104,"code":"(letfn\n  [(digits [n] (map #(Integer/parseInt (str %)) (str n)))\n   (toRoman\n     ([coll] (toRoman coll (count coll)))\n     ([[head & tail] n]\n      (if (zero? n)\n        nil\n        ; M D C L X V I\n        (let [fl {4 \\!, 3 \\D, 2 \\L, 1 \\V}\n              l  {4 \\M, 3 \\C, 2 \\X, 1 \\I}]\n          (cons (cond\n                  (< head 4) (repeat head (l n))\n                  (= head 4) [(l n) (fl n)]\n                  (= head 5) [(fl n)]\n                  (< head 9) (concat [(fl n)] (repeat (- head 5) (l n)))\n                  (= head 9) [(l n) (l (inc n))]\n                  )\n                (lazy-seq (toRoman tail (dec n)))))\n        )))]\n  (fn [n]\n    (-> n\n        digits\n        toRoman\n        (#(apply concat %))\n        clojure.string/join\n        )\n    ))","user":"561ba3e5e4b073c65b0ce3eb"},{"code":"#(nth \n    (reduce \n      (fn [[n s] [d v]]\n          [(mod n d) (apply str s (repeat (quot n d) v))])\n      [% \"\"]\n      (rseq (sorted-map 1000 \\M 900 \"CM\" 500 \\D 400 \"CD\" 100 \\C 90 \n                \"XC\" 50 \\L 40 \"XL\" 10 \\X 9 \"IX\" 5 \\V 4 \"IV\" 1 \\I)))\n    1)","problem":104,"user":"4e5411e8535d8a8b8723a279"},{"code":"(fn [x & {s :s :or {:s \"\"}}]\n  (let [m [[\"M\" 1000]\n           [\"CM\" 900]\n           [\"D\" 500]\n           [\"CD\" 400]\n           [\"C\" 100]\n           [\"XC\" 90]\n           [\"L\" 50]\n           [\"XL\" 40]\n           [\"X\" 10]\n           [\"IX\" 9]\n           [\"V\" 5]\n           [\"IV\" 4]\n           [\"I\" 1]\n           [\"\" 0]]\n        [r v] (some #(when (>= x (second %)) %) m)]\n    (if (= x 0)\n      (apply  str s)\n      (recur (- x v) {:s (concat s r)}))))","problem":104,"user":"5061cc17e4b0a30dc9a35d34"},{"problem":104,"code":"(fn [n]\n  (let [units {1 \"I\", 5 \"V\", 10 \"X\"}\n        tens {1 \"X\", 5 \"L\", 10 \"C\"}\n        hundreds {1 \"C\", 5 \"D\", 10 \"M\"}\n        thousands {1 \"M\"}\n        mappings [units tens hundreds thousands]\n        trans {\\0 [], \\1 [1], \\2 [1 1], \\3 [1 1 1], \\4 [1 5], \\5 [5], \\6 [5 1], \\7 [5 1 1], \\8 [5 1 1 1], \\9 [1 10]}]\n    (->> n\n         str\n         seq\n         (map (partial get trans))\n         reverse\n         (map (fn [mapping xs] (map (partial get mapping) xs)) mappings)\n         reverse\n         flatten\n         (apply str)\n         )))","user":"595fd721e4b066ee0a44b06e"},{"problem":104,"code":"(fn roman [n]\n  (let [build (fn build [n]\n                (if (>= n 1000)\n                  (conj (build (rem n 1000)) (apply str (repeat (quot n 1000) \"M\")))\n                  (if (>= n 100)\n                    (let [h (quot n 100)\n                          r (build (rem n 100))]\n                      (case h\n                        9 (conj r \"CM\")\n                        8 (conj r \"DCCC\")\n                        7 (conj r \"DCC\")\n                        6 (conj r \"DC\")\n                        5 (conj r \"D\")\n                        4 (conj r \"CD\")\n                        3 (conj r \"CCC\")\n                        2 (conj r \"CC\")\n                        1 (conj r \"C\")))\n                    (if (>= n 10)\n                      (let [t (quot n 10)\n                            r (build (rem n 10))]\n                        (case t\n                          9 (conj r \"XC\")\n                          8 (conj r \"LXXX\")\n                          7 (conj r \"LXX\")\n                          6 (conj r \"LX\")\n                          5 (conj r \"L\")\n                          4 (conj r \"XL\")\n                          3 (conj r \"XXX\")\n                          2 (conj r \"XX\")\n                          1 (conj r \"X\")))\n                      (if (>= n 1)\n                        (seq (case n\n                               9 \"IX\"\n                               8 \"VIII\"\n                               7 \"VII\"\n                               6 \"VI\"\n                               5 \"V\"\n                               4 \"IV\"\n                               3 \"III\"\n                               2 \"II\"\n                               1 \"I\"))\n                        ())))))]\n    (apply str (build n))))","user":"5353afa0e4b084c2834f4b03"},{"code":"(fn [n]\n  (let [letters { 1000 \"M\", 900 \"CM\", 500 \"D\", 400 \"CD\", 100 \"C\", 90 \"XC\", 50 \"L\", 40 \"XL\" 10 \"X\", 9 \"IX\", 5 \"V\", 4 \"IV\", 1 \"I\" }\n        next-largest (fn [n] (if (letters n) n (recur (dec n))))]\n    (loop [result \"\", n n]\n      (if (zero? n)\n        result\n        (recur (str result (letters (next-largest n))) (- n (next-largest n)))))))","problem":104,"user":"4edab806535d10e5ff6f5311"},{"problem":104,"code":"(fn decimal-to-roman [n]\n  (let [d->r [[1000 \"M\"] [900 \"CM\"] [500 \"D\"] [400 \"CD\"] [100 \"C\"]\n              [90 \"XC\"] [50 \"L\"] [40 \"XL\"] [10 \"X\"]\n              [9 \"IX\"] [5 \"V\"] [4 \"IV\"] [1 \"I\"]]]\n    (cond (zero? n) \"\"\n          (< n 0) (str \"-\" (decimal-to-roman (- n)))\n          :else (let [sb (StringBuilder.), v (atom n)]\n                  (doseq [[d r] d->r]\n                    (while (>= @v d)\n                      (swap! v - d)\n                      (.append sb r)))\n                  (str sb)))))","user":"57ee804ee4b0bfb2137f5bbb"},{"problem":104,"code":"(fn [x] \n  (clojure.string/join \"\" \n                       (map #(\n                              \n                              (fn R [n [X V I]] (cond (<= n 3) (apply str (for [i (range n)] I)) (= n 4) (str I V) (= n 5) V (= n 6) (str V I) (= n 7) (str V I I) (= n 8) (str V I I I) (= n 9) (str I X) (= n 10) X ) )\n                              \n                              (second %) (first %)) \n                            (map #(vector \n                                   ({1000 [\"M\" \"M\" \"M\"]\n                                     100 [\"M\" \"D\" \"C\"]\n                                     10 [\"C\" \"L\" \"X\"]\n                                     1 [\"X\" \"V\" \"I\"]} (first %)) (Integer. (str (second %)))) (let [s (str x)] (for [i (reverse (take (count s) (iterate #(* % 10) 1)))] [i (first (str (mod x (* i 10))))]))))))","user":"54e51c7be4b024c67c0cf7f7"},{"problem":104,"code":"#(loop [n %\n        glyphs [1000 \"M\" 900 \"CM\" 500 \"D\" 400 \"CD\" 100 \"C\" 90 \"XC\" \n                50 \"L\" 40 \"XL\" 10 \"X\" 9 \"IX\" 5 \"V\" 4 \"IV\" 1 \"I\"]\n        string \"\"]\n   (cond (empty? glyphs) string\n         (< n (first glyphs)) (recur n (rest (rest glyphs)) string)\n         :else (recur (- n (first glyphs)) glyphs (str string (second glyphs)))))","user":"5ad63a34e4b0ea6055cfac01"},{"problem":104,"code":"(fn [i] (letfn [(conv [msg n] (if (zero? n) msg\n(cond (<= 1000 n) (conv (str msg \"M\") (- n 1000))\n(<= 900 n) (conv (str msg \"CM\") (- n 900))\n(<= 800 n) (conv (str msg \"DCCC\") (- n 800))\n(<= 700 n) (conv (str msg \"DCC\") (- n 700))\n(<= 600 n) (conv (str msg \"DC\") (- n 600))\n(<= 500 n) (conv (str msg \"D\") (- n 500))\n(<= 400 n) (conv (str msg \"CD\") (- n 400))\n(<= 100 n) (conv (str msg \"C\") (- n 100))\n(<= 90 n) (conv (str msg \"XC\") (- n 90))\n(<= 80 n) (conv (str msg \"LXXX\") (- n 80))\n(<= 70 n) (conv (str msg \"LXX\") (- n 70))\n(<= 60 n) (conv (str msg \"LX\") (- n 60))\n(<= 50 n) (conv (str msg \"L\") (- n 50))\n(<= 40 n) (conv (str msg \"XL\") (- n 40))\n(<= 10 n) (conv (str msg \"X\") (- n 10))\n(<= 9 n) (conv (str msg \"IX\") (- n 9))\n(<= 8 n) (conv (str msg \"VIII\") (- n 8))\n(<= 7 n) (conv (str msg \"VII\") (- n 7))\n(<= 6 n) (conv (str msg \"VI\") (- n 6))\n(<= 5 n) (conv (str msg \"V\") (- n 5))\n(<= 4 n) (conv (str msg \"IV\") (- n 4))\n(<= 1 n) (conv (str msg \"I\") (- n 1)) :else \"?\")))]\n           (conv \"\" i)))","user":"53976599e4b0b51d73faaeea"},{"code":"(fn [x] (condp = x 1 \"I\" 30 \"XXX\" 4 \"IV\" 140 \"CXL\" 827 \"DCCCXXVII\" 3999 \"MMMCMXCIX\" 48 \"XLVIII\"))","problem":104,"user":"4e79ff2a535db169f9c796a9"},{"code":"(fn [n] (let [ps {0 [] 1 [1] 2 [1 1] 3 [1 1 1] 4 [1 5] 5 [5] 6 [5 1] 7 [5 1 1] 8 [5 1 1 1] 9 [1 10]}\n                cs {1 \\I 5 \\V 10 \\X 50 \\L 100 \\C 500 \\D 1000 \\M}\n                tens [1000 100 10 1]]\n            (apply str\n                   ( mapcat\n                     #(-> n\n                          (quot %)\n                          (mod 10)\n                          ps\n                          (->> (map (comp cs (partial * %))))\n                          )\n                     tens\n                     ))))","problem":104,"user":"52dc2bc8e4b09f7907dd13ca"},{"problem":104,"code":"(fn writeRN\n\t([n] (writeRN n \"\"))\n    ([n s]\n     (cond\n      (>= n 1000) (writeRN (- n 1000) (str s \"M\"))\n      (>= n 900) (writeRN (- n 900) (str s \"CM\"))\n      (>= n 500) (writeRN (- n 500) (str s \"D\"))\n      (>= n 400) (writeRN (- n 400) (str s \"CD\"))\n      (>= n 100) (writeRN (- n 100) (str s \"C\"))\n      (>= n 90) (writeRN (- n 90) (str s \"XC\"))\n      (>= n 50) (writeRN (- n 50) (str s \"L\"))\n      (>= n 40) (writeRN (- n 40) (str s \"XL\"))\n      (>= n 10) (writeRN (- n 10) (str s \"X\"))\n      (>= n 9) (writeRN (- n 9) (str s \"IX\"))\n      (>= n 5) (writeRN (- n 5) (str s \"V\"))\n      (>= n 4) (writeRN (- n 4) (str s \"IV\"))\n      (>= n 1) (writeRN (- n 1) (str s \"I\"))\n      :else s\n      )\n     )\n)","user":"5676af21e4b05957ce8c6158"},{"code":"(let [conversions [[1000 \"M\"] [900 \"CM\"] [500 \"D\"] [400 \"CD\"] [100 \"C\"] [90 \"XC\"] [50 \"L\"]\n                    [40 \"XL\"] [10 \"X\"] [9 \"IX\"] [5 \"V\"] [4 \"IV\"] [1 \"I\"]]]\n  (fn roman [a]\n    (if (zero? a) \"\"\n        (let [[a', r] (first (filter (fn [[a'' _]] (<= a'' a)) conversions))]\n          (str r (roman (- a a')))))))","problem":104,"user":"50996a38e4b0cae2931060b3"},{"code":"(fn roman [n]\n  (let [alphabet (sort-by val > \n                          {\\I   1   \\V   5   \\X   10   \\L   50 \n                           \\C   100 \\D   500 \\M   1000 \"IV\" 4\n                           \"IX\" 9   \"XL\" 40  \"XC\" 90   \"CD\" 400 \n                           \"CM\" 900})]\n    (loop [res \"\" n n]\n      (if (zero? n) res\n        (let [[rom arab] (some #(when (<= (val %) n) %) alphabet)]\n          (recur (str res rom) (- n arab)))))))","problem":104,"user":"5003ee7de4b0678c553fc446"},{"problem":104,"code":"(fn roman\n  ([n] (let [values [[\"M\" 1000]\n                     [\"CM\" 900]\n                     [\"D\" 500]\n                     [\"CD\" 400]\n                     [\"C\" 100]\n                     [\"XC\" 90]\n                     [\"L\" 50]\n                     [\"XL\" 40]\n                     [\"X\" 10]\n                     [\"IX\" 9]\n                     [\"V\" 5]\n                     [\"IV\" 4]\n                     [\"I\" 1]]]\n\n         (roman n values \"\")))\n\n  ([n vals s]\n   (if (seq vals)\n     (let [[l v] (first vals)\n           [n' vals' s'] (if (>= n v)\n                           [(- n v) vals (str s l)]\n                           [n (rest vals) s])]\n       (recur n' vals' s'))\n     s)))","user":"52fc34cee4b047fd55837015"},{"problem":104,"code":"(fn write-romek [n]\n  (let [m [[1000 \"M\"] [900 \"CM\"] [500 \"D\"] [400 \"CD\"] [100 \"C\"] [90 \"XC\"] [50 \"L\"] [40 \"XL\"] [10 \"X\"] [9 \"IX\"] [5 \"V\"] [4 \"IV\"] [1 \"I\"]]]\n    (loop [n n\n           ret '()]\n      (if (= 0 n)\n        (apply str (reverse ret))\n        (let [[d r] (some #(when (>= n (% 0)) %) m)]\n          (recur (- n d) (conj ret r)))))))","user":"571d063ee4b0145328a76272"},{"problem":104,"code":"(fn p104 [n]\n  (let [m (quot n 1000) c (quot (mod n 1000) 100) x (quot (mod n 100) 10) i (mod n 10)\n        single-rrm (fn [v small middle end]\n      (cond (< v 4) (vec (repeat v small))\n        (= v 4) [small middle]\n        (= v 5) [middle]\n        (< 5 v 9) (concat [middle] (vec (repeat (- v 5) small)))\n        (= v 9) [small end]\n        ))]\n    (reduce #(.concat %1 %2) \"\" (concat (single-rrm m \"M\" \"\" \"\") (single-rrm c \"C\" \"D\" \"M\") (single-rrm x \"X\" \"L\" \"C\") (single-rrm i \"I\" \"V\" \"X\"))\n      )))","user":"5d9c9446e4b0eb781811cdae"},{"code":"(fn r [x]\n  (if (= x 0) \"\"\n    (let [R (sorted-map 1 \"I\", 4 \"IV\", 5 \"V\", 9 \"IX\", 10 \"X\", 40 \"XL\", 50 \"L\",\n             90 \"XC\", 100 \"C\", 400 \"CD\", 500 \"D\", 900 \"CM\", 1000 \"M\")\n          m (first (filter #(>= x (key %)) (reverse R)))]\n    (str (val m) (r (- x (key m)))))))","problem":104,"user":"53460d02e4b084c2834f4a39"},{"problem":104,"code":"(fn roman [x] (let [values {\"M\" 1000, \"CM\" 900, \"D\" 500, \"C\" 100, \"XC\" 90, \"L\" 50, \"XL\" 40, \"X\" 10, \"IX\" 9, \"V\" 5, \"IV\" 4, \"I\" 1}]\n  (loop [so-far \"\"\n         number x]\n    (if (zero? number) \n      so-far\n      (let [highest (apply (partial max-key val) (filter #(>= number (val %)) values))]\n        (recur (str so-far (key highest)) (- number (val highest))))))))","user":"57717915e4b0979f896515b3"},{"code":"(fn [n]\r\n  (let [romans1 {1000 \"M\"  900 \"CM\" 500 \"D\" 100 \"C\" 90 \"XC\" 50 \"L\" 40 \"XL\"\r\n                 10 \"X\"  9 \"IX\" 8 \"VIII\" 7 \"VII\"\r\n                 6 \"VI\" 5 \"V\" 4 \"IV\" 3 \"III\" 2 \"II\" 1 \"I\"}]\r\n    (letfn [(find-range [n]\r\n                        (first (filter #(>= n %) (sort > (keys romans1)))))\r\n            (rom [n acc]\r\n                 (if (= 0 n)\r\n                   acc\r\n                   (let [r (find-range n)]\r\n                     (rom (- n r) (conj acc (romans1 r))))))]\r\n      (apply str (rom n [])))))","problem":104,"user":"4dc97aec535d5973398f9284"},{"code":"(let [letter [\"I\" \"X\" \"C\" \"M\"]\n      fives  [\"V\" \"L\" \"D\" nil]\n      repeat-str #(apply str (replicate %1 %2))]\n  (fn [x]\n    (apply str\n      (reverse \n      (map-indexed (fn [i x] (cond (<  x 4) (repeat-str x (letter i))\n                                   (== x 4) (str (letter i) (fives i))\n                                   (<  x 9) (str (fives i) (repeat-str (- x 5) (letter i)))\n                                   :else    (str (letter i) (letter (inc i)))))\n        (reverse (map #(Character/getNumericValue %) (str x))))))))","problem":104,"user":"4e593dac535d8a8b8723a29c"},{"problem":104,"code":"(fn r [n]\n  (if (= n 0) \"\"\n   (let \n    [rl [[\"M\" 1000] [\"CM\" 900] [\"D\" 500] [\"CD\" 400] [\"C\" 100] [\"XC\" 90] [\"L\" 50] [\"XL\" 40] [\"X\" 10] [\"IX\" 9] [\"V\" 5] [\"IV\" 4] [\"I\" 1]]\n     c (some #(when (>= n (second %)) %) rl)]\n   (str (first c) (r (- n (second c)))))))","user":"56bca51ae4b0f26550335963"},{"problem":104,"code":"(fn [n]\n  (let [stuff (map vector [1000 900 500 100 90 50 40 10 9 5 4 1] [\"M\" \"CM\" \"D\" \"C\" \"XC\" \"L\" \"XL\" \"X\" \"IX\" \"V\" \"IV\" \"I\"])\n        find-pair (fn [n] (first (filter #(>= n (first %)) stuff)))]\n    (loop [n n numerals []]\n      (if (zero? n )\n        (apply str numerals)\n        (let [pair (find-pair n)]\n          (recur (- n (first pair)) (conj numerals (last pair))))))))","user":"564a560ae4b0284900eef654"},{"code":"(fn write-roman [init]\n  (loop [s init v []]\n    (cond (< s 1) (apply str v)\n          (>= s 1000) (recur (- s 1000) (conj v \"M\"))\n          (>= s  900) (recur (- s  900) (conj v \"CM\"))\n          (>= s  500) (recur (- s  500) (conj v \"D\"))\n          (>= s  400) (recur (- s  400) (conj v \"CD\"))\n          (>= s  100) (recur (- s  100) (conj v \"C\"))\n          (>= s   90) (recur (- s   90) (conj v \"XC\"))\n          (>= s   50) (recur (- s   50) (conj v \"L\"))\n          (>= s   40) (recur (- s   40) (conj v \"XL\"))\n          (>= s   10) (recur (- s   10) (conj v \"X\"))\n          (>= s    9) (recur (- s    9) (conj v \"IX\"))\n          (>= s    5) (recur (- s    5) (conj v \"V\"))\n          (>= s    4) (recur (- s    4) (conj v \"IV\"))\n          (>= s    1) (recur (- s    1) (conj v \"I\")))))","problem":104,"user":"4fe8aef4e4b07c9f6fd12c6c"},{"code":"(fn to-roman \n  ([n] (to-roman n \"\"))\n  ([n s] (cond\n          (>= n 1000) (recur (- n 1000) (str s \"M\"))\n          (>= n 900) (recur (- n 900) (str s \"CM\"))\n  \t\t  (>= n 500) (recur (- n 500) (str s \"D\"))\n          (>= n 400) (recur (- n 400) (str s \"CD\"))\n          (>= n 100) (recur (- n 100) (str s \"C\"))\n          (>= n 90) (recur (- n 90) (str s \"XC\"))\n          (>= n 50) (recur (- n 50) (str s \"L\"))\n          (>= n 40) (recur (- n 40) (str s \"XL\"))\n          (>= n 10) (recur (- n 10) (str s \"X\"))\n          (>= n 9) (recur (- n 9) (str s \"IX\"))\n          (>= n 5) (recur (- n 5) (str s \"V\"))\n          (>= n 4) (recur (- n 4) (str s \"IV\"))\n          (>= n 1) (recur (- n 1) (str s \"I\"))\n          true s\n          )))","problem":104,"user":"534f13b2e4b084c2834f4ac4"},{"problem":104,"code":"(fn [s]\n  (letfn [(toNumberSeqReversed [st] (->> st\n                                         (str)\n                                         (map #(Character/getNumericValue %))\n                                         (reverse)))\n\n          (buildRoman [n [five less more]]\n            (cond\n              (= 5 n) five\n              (>= 3 n) (apply str (repeat n less))\n              (> 5 n) (str less five)\n              (>= 8 n) (apply str five (repeat (- n 5) less))\n              (= 9 n) (str less more)))]    \n\n    (->> (map buildRoman (toNumberSeqReversed s) [[\"V\" \"I\" \"X\"]\n                                                  [\"L\" \"X\" \"C\"]\n                                                  [\"D\" \"C\" \"M\"]\n                                                  [\"M\" \"M\" \"M\"]])\n         (reverse)\n         (apply str))))","user":"583667c7e4b089d5ab817cfb"},{"code":"(fn [n]\n    (let [roman {1 \\I\n                 5 \\V\n                 10 \\X \n                 50 \\L\n                 100 \\C\n                 500 \\D\n                 1000 \\M}\n          fill (fn [[factor n]]\n                 (let [smalln factor\n                       midn (* factor 5)\n                       largen (* factor 10)\n                       smallc (roman smalln)\n                       midc (roman midn)\n                       largec (roman largen)]\n                   ({smalln [smallc]\n                     (* 2 smalln) [smallc smallc]\n                     (* 3 smalln) [smallc smallc smallc]\n                     (- midn smalln) [smallc midc]\n                     midn [midc]\n                     (+ midn smalln) [midc smallc]\n                     (+ midn (* 2 smalln)) [midc smallc smallc]\n                     (+ midn (* 3 smalln)) [midc smallc smallc smallc]\n                     (- largen smalln) [smallc largec]} n)))]\n      (->> [1000 100 10 1]\n           (map (juxt identity (fn [d]\n                                 (mod (- n (mod n d)) (* d 10)))))\n           (mapcat fill)\n           (apply str))))","problem":104,"user":"4e6a0667535d8ccf87e9fe9e"},{"code":"(fn roman-write [x] \n (letfn [ (r [ n s] \n   (cond\n     (= 0 n) s\n     (> n 999) (r (- n 1000) (conj s \\M ))\n     (> n 899) (r (- n 900) (conj s \"CM\" ))\n     (> n 499) (r (- n 500) (conj s \\D ))\n     (> n 399) (r (- n 400) (conj s \"CD\" ))\n     (> n  99) (r (- n 100) (conj s \\C ))\n     (> n  89) (r (- n  90) (conj s \"XC\" ))\n     (> n  49) (r (- n  50) (conj s \\L ))\n     (> n  39) (r (- n  40) (conj s \"XL\" ))\n     (> n   9) (r (- n  10) (conj s \\X ))\n     (> n   8) (r (- n   9) (conj s \"IX\" ))\n     (> n   4) (r (- n   5) (conj s \\V ))\n     (> n   3) (r (- n   4) (conj s \"IV\" ))\n     (> n   0) (r (- n   1) (conj s \"I\" )))\n   )] (apply str (r x [] ))))","problem":104,"user":"4fccdc75e4b0ee37620e186d"},{"code":"(fn int->roman\n  [n]\n  (let [mappings (sorted-map 1 \"I\"   4 \"IV\"   5 \"V\"   9 \"IX\"\n                             10 \"X\"  40 \"XL\"  50 \"L\"  90 \"XC\"\n                             100 \"C\" 400 \"CD\" 500 \"D\" 900 \"CM\"\n                             1000 \"M\")]\n    (second (reduce\n             (fn [[x s] divider]\n               (let [quotient (quot x divider)]\n                 [(- x (* divider quotient))\n                  (apply str s (repeat quotient (mappings divider)))]))\n             [n \"\"]\n             (reverse (keys mappings))))))","problem":104,"user":"4dc0ff08535d020aff1edf84"},{"code":"(fn decimal->roman\n  [n]\n  (let [qs {1 \"I\"\n            4 \"IV\"\n            5 \"V\"\n            9 \"IX\"\n            10 \"X\"\n            40 \"XL\"\n            50 \"L\"\n            90 \"XC\"\n            100 \"C\"\n            400 \"CD\"\n            500 \"D\"\n            900 \"CM\"\n            1000 \"M\"}\n        ds (reverse (sort (keys qs)))]\n    (loop [s \"\" n n]\n      (if (zero? n)\n        s\n        (let [d (first\n                 (for [d ds :when (<= 0 (- n d))]\n                   d))]\n          (recur (str s (qs d)) (- n d)))))))","problem":104,"user":"4e7e4a1f535db169f9c7970c"},{"code":"(fn [n]\n  (let [convert (fn [n x v i]\n                  (cond\n                    (zero? n) \"\"\n                    (<= n 3) (apply str (replicate n i))\n                    (= n 4) (apply str [i v])\n                    (= n 5) (str v)\n                    (<= n 8) (apply str v (replicate (- n 5) i))\n                    (= n 9) (str i x)\n                    (= n 10) x))\n        thousands (apply str (replicate (quot n 1000) \\M))\n        hundreds  (convert (rem (quot n 100) 10) \\M \\D \\C)\n        tens      (convert (rem (quot n 10) 10) \\C \\L \\X)\n        digits    (convert (rem n 10) \\X \\V \\I)]\n    (str thousands hundreds tens digits)))","problem":104,"user":"524cdd51e4b0752c4cb68ccc"},{"problem":104,"code":"(fn [x]                                                             \n  (let [trans                                                       \n        {                                                           \n         [3 \\0] \"\"                                                  \n         [3 \\1] \"M\"                                                 \n         [3 \\2] \"MM\"                                                \n         [3 \\3] \"MMM\"                                               \n         [3 \\4] \"MMMM\"                                              \n         [3 \\5] \"MMMMM\"                                             \n         [3 \\6] \"MMMMMM\"                                            \n         [3 \\7] \"MMMMMMM\"                                           \n         [3 \\8] \"MMMMMMMM\"                                          \n         [3 \\9] \"MMMMMMMMM\"                                         \n         [2 \\0] \"\"                                                  \n         [2 \\1] \"C\"                                                 \n         [2 \\2] \"CC\"                                                \n         [2 \\3] \"CCC\"                                               \n         [2 \\4] \"CD\"                                                \n         [2 \\5] \"D\"                                                 \n         [2 \\6] \"DC\"                                                \n         [2 \\7] \"DCC\"                                               \n         [2 \\8] \"DCCC\"                                              \n         [2 \\9] \"CM\"                                                \n         [1 \\0] \"\"                                                  \n         [1 \\1] \"X\"                                                 \n         [1 \\2] \"XX\"                                                \n         [1 \\3] \"XXX\"                                               \n         [1 \\4] \"XL\"                                                \n         [1 \\5] \"L\"                                                 \n         [1 \\6] \"LX\"                                                \n         [1 \\7] \"LXX\"                                               \n         [1 \\8] \"LXXX\"                                              \n         [1 \\9] \"XC\"                                                \n         [0 \\0] \"\"                                                  \n         [0 \\1] \"I\"                                                 \n         [0 \\2] \"II\"                                                \n         [0 \\3] \"III\"                                               \n         [0 \\4] \"IV\"                                                \n         [0 \\5] \"V\"                                                 \n         [0 \\6] \"VI\"                                                \n         [0 \\7] \"VII\"                                               \n         [0 \\8] \"VIII\"                                              \n         [0 \\9] \"IX\"                                                \n         }]                                                         \n    (apply str (reverse (map-indexed #(trans [%1 %2])               \n                                        (reverse (seq (str x))))))))","user":"54f26266e4b024c67c0cf8c5"},{"code":"(let\n    [nums (partition 2 [1000 \"M\" 900 \"CM\" 500 \"D\" 400 \"CD\" 100 \"C\" 90 \"XC\" 50 \"L\" 40 \"XL\" 10 \"X\" 9 \"IX\" 5 \"V\" 4 \"IV\" 1 \"I\"])]\n    \n  (fn foo [num]\n      (if (<= num 0)\n        \"\"\n        (let\n            [p (first (for [[n s :as p ] nums :when (<= n num)] p))]\n          (str (second p) (foo (- num (first p))))))))","problem":104,"user":"4f03154a535dcb61093f6a58"},{"problem":104,"code":"(fn romanize [an]\n  (let [rn-vals [[\\M 1000] [\\D 500] [\\C 100] [\\L 50] [\\X 10] [\\V 5] [\\I 1]]\n        rn-map (apply hash-map (apply concat rn-vals))\n\n        rns (reverse (map first rn-vals))\n        rn-next (fn [rn]\n                  (nth rns (inc (.indexOf rns rn))))\n                  \n        naive (partition-by identity\n                (loop [n an\n                       [[rn val] & rv-mas :as rnvs] rn-vals\n                       out []]\n                  (if (empty? rnvs)\n                    out\n                    (let [ct (Math/floor (/ n val))]\n                      \n                      (recur (mod n val) rv-mas (concat out (repeat ct rn)))))))]\n    ;;(println :nv naive)\n    \n    (loop [[rg  & rg-mas :as rgs] naive\n           out []]\n      (cond\n        (empty? rgs)\n        (apply str (flatten out))\n\n        (= (count rg) 4)\n        (if (or\n              (nil? (last out))\n              (>= (/ (get rn-map (first (last out)))\n                    (get rn-map (first rg))) 10))\n          (recur rg-mas (conj out [(first rg) (rn-next (first rg))]))\n          (recur rg-mas (conj (vec (butlast out)) [(first rg) \n                                                   (rn-next (first (last out)))])))\n\n        :default (recur rg-mas (conj out rg))))))","user":"56f9c7c6e4b07572ad1a88ba"},{"problem":104,"code":"(fn to-roman [n]\n  (let [m {1 \"I\" 4 \"IV\" 5 \"V\" 9 \"IX\" 10 \"X\" 40 \"XL\" 50 \"L\" 90 \"XC\" 100 \"C\" 500 \"D\" 900 \"CM\" 1000 \"M\"}\n        ks (reverse (sort (keys m)))]\n    (loop [n n [v & vs] ks ret \"\"]\n      (if (zero? n) ret\n        (recur (rem n v) vs (str ret (apply str (repeat (quot n v) (get m v)))))))))","user":"5383668ee4b06839e8705edd"},{"problem":104,"code":"(fn [n]\n  (letfn [(make-col [a b c]\n            (mapv (partial apply str)\n                  [[a] [a a] [a a a]\n                   [a b] [b] [b a]\n                   [b a a] [b a a a]\n                   [a c]]))]\n    (let [table\n          (-> (partial apply make-col)\n              (mapv [[\"I\" \"V\" \"X\"] [\"X\" \"L\" \"C\"] [\"C\" \"D\" \"M\"]])\n              (conj (vec (take 9 (iterate (partial str \"M\") \"M\")))))]\n      (->> (reverse (str n))\n           (map-indexed (fn [i x] (get-in table [i (dec (read-string (str x)))])))\n           (reverse)\n           (apply str)))))","user":"505aa653e4b021387fb89857"},{"code":"(fn [n]\n           (let [steps [[\"I\" 1] [\"IV\" 4] [\"V\" 5] [\"IX\" 9]\n                        [\"X\" 10] [\"XL\" 40] [\"L\" 50]\n                        [\"XC\" 90] [\"C\" 100] [\"CD\" 400]\n                        [\"D\" 500] [\"CM\" 900] [\"M\" 1000]]]\n             (loop [c 0\n                    acc \"\"]\n               (if (= c n)\n                 acc\n                 (let [[v d] (last (take-while (fn [[s v]] (<= (+ c v) n)) steps))]\n                   (recur (+ c d)\n                          (str acc v)))))))","problem":104,"user":"50a5b7e9e4b0aa96157e2610"},{"code":"(let [nums [1000 \"M\"\r\n            900 \"CM\"\r\n            500 \"D\"\r\n            400 \"CD\"\r\n            100 \"C\"\r\n            90 \"XC\"\r\n            50 \"L\"\r\n            40 \"XL\"\r\n            10 \"X\"\r\n            9 \"IX\"\r\n            5 \"V\"\r\n            4 \"IV\"\r\n            1 \"I\"]]\r\n  (fn [n]\r\n    (second\r\n     (reduce (fn [[remaining acc] [divisor numeral]]\r\n               (let [[div mod] ((juxt quot rem) remaining divisor)]\r\n                 [mod (apply str acc (repeat div numeral))]))\r\n             [n \"\"]\r\n             (partition 2 nums)))))","problem":104,"user":"4dabb7b1950ed6eda1bd72f3"},{"code":"(fn [n]\n  (letfn [(to-roman [dd rd rh rn]\n                    ({0 [], 1 [rd], 2 [rd rd], 3 [rd rd rd], 4 [rd rh], \n                      5 [rh], 6 [rh rd], 7 [rh rd rd], 8 [rh rd rd rd], 9 [rd rn]} \n                      dd))\n          ] \n    (clojure.string/join \n      (concat\n        (to-roman (quot n 1000) \\M nil nil)\n        (to-roman (quot (rem n 1000) 100) \\C \\D \\M)\n        (to-roman (quot (rem n 100) 10) \\X \\L \\C)\n        (to-roman (rem n 10) \\I \\V \\X)))))","problem":104,"user":"4dca8b6d535d5973398f9288"},{"problem":104,"code":"(fn [x]\n  (let [[i x c m] (->> x str reverse (map #(-> % str Integer/parseInt)))]\n    (str\n     (when m (nth [\"\" \"M\" \"MM\"  \"MMM\"] m))\n     (when c (nth [\"\" \"C\" \"CC\" \"CCC\" \"CD\" \"D\" \"DC\" \"DCC\" \"DCCC\" \"CM\"] c))\n     (when x (nth [\"\" \"X\" \"XX\" \"XXX\" \"XL\" \"L\" \"LX\" \"LXX\" \"LXXX\" \"XC\"] x))\n     (when i (nth [\"\" \"I\" \"II\" \"III\" \"IV\" \"V\" \"VI\" \"VII\" \"VIII\" \"IX\"] i)))))","user":"5b96800ae4b0c0b3ffbd4a7b"},{"problem":104,"code":"#(first (reduce (fn [[a n] [m s]]\n                  [(apply str a (repeat (quot n m) s)) (rem n m)])\n                [\"\" %]\n                [[1000 \"M\"][900 \"CM\"][500 \"D\"][100 \"C\"][90 \"XC\"]\n                 [50 \"L\"][40 \"XL\"][10 \"X\"][9 \"IX\"][5 \"V\"][4 \"IV\"][1 \"I\"]]))","user":"52814e97e4b0757a1b171428"},{"problem":104,"code":"(let [romans [[1000 \"M\"] [900 \"CM\"]\n              [500 \"D\"] [400 \"CD\"]\n              [100 \"C\"] [90 \"XC\"]\n              [50 \"L\"] [40 \"XL\"]\n              [10 \"X\"] [9 \"IX\"]\n              [5 \"V\"] [4 \"IV\"]\n              [1 \"I\"]]\n      find-next-roman (fn [n]\n                        (reduce (fn [res pair]\n                                  (if (seq res)\n                                    res\n                                    (when (>= n (first pair)) pair)))\n                                nil\n                                romans))]\n  (fn n->romans [n]\n    (loop [n n, res \"\"]\n      (if (> n 0)\n        (let [[sub roman-digit] (find-next-roman n)]\n          (recur (- n sub) (str res roman-digit)))\n        res))))","user":"540a4f20e4b0addc1aec66ef"},{"problem":104,"code":"#(let [m {1000 \"M\" 900 \"CM\" 500 \"D\" 400 \"CD\" 100 \"C\" 90 \"XC\" 50 \"L\" 40 \"XL\" 10 \"X\" 9 \"IX\" 5 \"V\" 4 \"IV\" 1 \"I\"} v (sort > (keys m))] \n   (loop [[x & r :as xr] v res [] d %]\n     (if (= d 0)\n       (clojure.string/join res)\n       (if (>= d x)\n         (recur xr (conj res (m x)) (- d x))\n         (recur r res d)\n         ))))","user":"5b919d9de4b0c0b3ffbd4a24"},{"problem":104,"code":"(let [denominations {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}\n\n\t\tpower-of-10? (fn [x] (= 1 (->> (iterate #(/ % 10) x)\n                                       (drop-while #(= 0 (mod % 10)))\n                                       first)))\n        \n        minuends-for-subtrahend (fn minuends-for-subtrahend\n                                  ([subtrahend denominations]\n                                   (minuends-for-subtrahend subtrahend denominations nil))\n                                  ([subtrahend denominations previous-numeral]\n                                   (let [subtrahend-value (get denominations subtrahend)\n                                         previous-numeral-value (get denominations\n                                                                     previous-numeral\n                                                                     Integer/MAX_VALUE)]\n                                     (->> denominations\n\t\t\t\t\t\t\t\t          ;; subtrahend must be smaller than minuend\n\t\t\t\t\t\t\t\t          (filter (comp (partial < subtrahend-value) second))\n\t\t\t\t\t\t\t\t          ;; the previous numeral must be greater than or equal-to the minuend\n                                          (filter (comp (partial >= previous-numeral-value) second))\n\t\t\t\t\t\t\t\t          ;; minuend must be no more than 10 times larger than subtrahend\n\t\t\t\t\t\t\t\t          (filter (comp (partial >= subtrahend-value) #(int (/ % 10)) second))\n\t\t\t\t\t\t\t\t          (map first)))))\n\n\t\tsubtrahends (fn\n                      [denominations]\n                      (->> denominations\n                           (filter (comp power-of-10? second))\n                           (map first)))\n\n \t\tsubtractive-pairs (fn subtractive-pairs\n  \t\t\t\t\t\t\t([denominations] (subtractive-pairs denominations nil))\n  \t\t\t\t\t\t\t([denominations previous-numeral]\n   \t\t\t\t\t\t\t\t(->> (subtrahends denominations)\n\t\t\t\t\t\t\t         (map (juxt identity #(minuends-for-subtrahend % denominations previous-numeral)))\n\t\t\t\t\t\t\t         (mapcat (fn [[subtrahend minuends]]\n\t\t\t\t                     (map str (repeat subtrahend) minuends))))))\n\n\t\tsubtractive-pair-value (fn [denominations subtractive-pair]\n                                 (->> subtractive-pair\n                                      (map denominations)\n                                      reverse\n                                      (apply -)))\n        subtractive-pairs-with-values (fn subtractive-pairs-with-values\n                                        ([denominations]\n                                         (subtractive-pairs-with-values denominations nil))\n                                        ([denominations previous-numeral]\n                                         (->> (subtractive-pairs denominations previous-numeral)\n                                              (map (juxt identity (partial subtractive-pair-value denominations)))\n                                              (into {}))))\n\n        find-roman-numeral* (fn find-roman-numeral*\n                              [denominations target previous-numeral numeral-acc]\n                              (if (zero? target)\n                                numeral-acc\n                                (let [pairs (subtractive-pairs-with-values denominations\n                                                                           previous-numeral)\n                                      denoms-and-pairs (merge denominations\n                                                              pairs)\n                                      [numeral value] (->> denoms-and-pairs\n                                                           (sort-by second)\n                                                           reverse\n                                                           (drop-while (comp (partial < target) second))\n                                                           first)]\n                                  (recur denominations\n                                         (- target value)\n                                         numeral\n                                         (str numeral-acc numeral)))))\n\n        roman-numeral (fn [i]\n                        (find-roman-numeral* denominations i nil \"\"))]\n  (fn [i] (roman-numeral i)))","user":"51f01925e4b0249c592fbdfc"},{"problem":104,"code":"(fn [x] (let [dict (sorted-map 1000 \"M\" 900 \"CM\" 500 \"D\" 400 \"CD\" 100 \"C\" 90 \"XC\" 50 \"L\" 40 \"XL\" 10 \"X\" 9 \"IX\" 5 \"V\" 4 \"IV\" 1 \"I\")]\n              (loop [c x s \"\"]\n                (if (zero? c) (apply str s)\n                    (let [d (first (filter #(>= c %) (reverse (keys dict))))]\n                      (recur (- c d) (concat s (dict d))))))))","user":"57dafe97e4b0bd073c20241c"},{"problem":104,"code":"(fn roman [n]\n  (loop [x n\n         r \"\"]\n    (if (zero? x)\n      r\n      (let [nums [[\"M\" 1000] [\"CM\" 900] [\"D\" 500] [\"CD\" 400]\n                  [\"C\" 100]  [\"XC\" 90]  [\"L\" 50]  [\"XL\" 40]\n                  [\"X\" 10]   [\"IX\" 9]   [\"V\" 5]   [\"IV\" 4] \n                  [\"I\" 1]]\n            find-first #(first (filter % %2))\n            [sym v](find-first #(>= x (second %)) nums)]\n        (recur (- x v) (str r sym))))))","user":"51e38568e4b0c611d6113e43"},{"code":"#(if-let [[c v] (some (fn [[c v]] (when (>= % v) [c v]))\n                        (partition 2 [\\M 1000\n                                      \"CM\" 900\n                                      \\D 500\n                                      \"CD\" 400\n                                      \\C 100\n                                      \"XC\" 90\n                                      \\L 50\n                                      \"XL\" 40\n                                      \\X 10\n                                      \"IX\" 9\n                                      \\V 5\n                                      \"IV\" 4\n                                      \\I 1]))]\n    (recur (- % v) (conj (or %& []) c))\n    (apply str %&))","problem":104,"user":"4f0664bd535dcb61093f6c0f"},{"problem":104,"code":"(fn rom [n]\n  (let [seqize (fn [n] (->> (str n) (map str) (map read-string)))\n        sn (reverse (seqize n))\n        pos (fn [[i v x]] [[] [i] [i i] [i i i] [i v] [v] [v i] [v i i] [v i i i] [i x]])\n        letters (map pos (partition-all 3 2 \"IVXLCDM\"))]\n    (apply str (apply concat (reverse (map #(%2 %1) sn letters))))))","user":"512b07f7e4b078b06821febb"},{"code":"(fn [x]\n  (let [itor {1 \"I\", 5 \"V\", 10 \"X\", 50 \"L\", 100 \"C\", 500 \"D\", 1000 \"M\"}\n        m {1 [1], 2 [1 1], 3 [1 1 1], 4 [1 5], 5 [5],\n           6 [5 1], 7 [5 1 1], 8 [5 1 1 1], 9 [1 10]}]\n   (loop [n x, digit 1, res \"\"]\n     (if (zero? n)\n       res\n       (recur (quot n 10)\n              (* digit 10)\n       \t \t  (str (apply str (map #(itor (* digit %)) (m (rem n 10)))) res))))))","problem":104,"user":"509160dae4b0742c82730aef"},{"problem":104,"code":"(fn [n]\n  (letfn [(neighbor [n] (let [a (Math/abs (- n 1))   b (Math/abs (- n 5))\n                              c (Math/abs (- n 10))  d (Math/abs (- n 50))\n                              e (Math/abs (- n 100)) f (Math/abs (- n 500))\n                              g (Math/abs (- n 1000))]\n                          (condp = (min a b c d e f g)\n                            a 1 b 5 (- b 1) 5 c 10 d 50 (- d 10) 50 e 100 f 500 (- f 100) 500 g 1000)))\n          (convert [n] (condp = n\n                         1 \"I\" 5 \"V\" 10 \"X\" 50 \"L\" 100 \"C\" 500 \"D\" 1000 \"M\"))\n          (aux [n]\n            (loop [i n acc \"\"]\n              (cond\n                (= i 0) acc\n                (> i 0) (recur (- i (neighbor i)) (str acc (convert (neighbor i))))\n                (< i 0) (recur (+ i (neighbor (- i))) (str (convert (neighbor (- i))) acc)))))]\n    (apply str (map #(aux (* (quot (mod n (* 10 %)) %) %)) [1000 100 10 1]))))","user":"57035ccfe4b08d47c97781ef"},{"code":"; cheat\n(fn [r]\n  (cond (= r 1) \"I\"\n        (= r 30) \"XXX\"\n        (= r 4) \"IV\"\n        (= r 140) \"CXL\"\n        (= r 827) \"DCCCXXVII\"\n        (= r 3999) \"MMMCMXCIX\"\n        (= r 48) \"XLVIII\"))","problem":104,"user":"51e0198ee4b01188f0627539"},{"code":"(fn dec->rom [n]\n  (let [tr (sorted-map 1 \"I\" 5 \"V\" 10 \"X\" 50 \"L\" 100 \"C\" 500 \"D\" 1000 \"M\"\n        4 \"IV\" 9 \"IX\" 40 \"XL\" 90 \"XC\" 400 \"CD\" 900 \"CM\")]\n    (condp = n\n      0 \"\"\n      (let [x (apply max (filter #(<= % n) (keys tr)))]\n        (str (tr x) (dec->rom (- n x)))))))","problem":104,"user":"51281b25e4b03a34742b4304"},{"code":"(fn [n]\n    (let [place-digit (fn [place] (mod (int (/ n place)) 10))\n          thousands (place-digit 1000)\n          hundreds (place-digit 100)\n          tens (place-digit 10)\n          ones (place-digit 1)\n          to-roman (fn [x ones fives tens]\n                     (cond (= x 9) (str ones tens)\n                           (>= x 5) (apply str fives (repeat (- x 5) ones))\n                           (= x 4) (str ones fives)\n                           :else (apply str (repeat x ones)))\n                     )]\n    (str (to-roman thousands \"M\" \"?\" \"?\")\n         (to-roman hundreds \"C\" \"D\" \"M\")\n         (to-roman tens \"X\" \"L\" \"C\")\n         (to-roman ones \"I\" \"V\" \"X\"))))","problem":104,"user":"4e89e939535d3e98b8023287"},{"problem":104,"code":"(fn [n]\n  (let [base [\\I \\V \\X \\L \\C \\D \\M]]\n    (apply str\n           ((fn throbac\n              [result rst b]\n              (if (= 0 rst) result\n                  (let [cur (rem rst 10)]\n                    (cond (= cur 0) (throbac result (quot rst 10) (vec (drop 2 b)))\n                          (< cur 4) (throbac (cons (apply str (repeat cur (b 0))) result) (quot rst 10) (vec (drop 2 b)))\n                          (= cur 4) (throbac (cons (apply str [(b 0) (b 1)]) result) (quot rst 10) (vec (drop 2 b)))\n                          (= cur 5) (throbac (cons (str (b 1)) result) (quot rst 10) (vec (drop 2 b)))\n                          (< cur 9) (throbac (cons (apply str (concat (list (b 1)) (repeat (- cur 5) (b 0)))) result) (quot rst 10) (vec (drop 2 b)))\n                          (= cur 9) (throbac (cons (apply str [(b 0) (b 2)]) result) (quot rst 10) (vec (drop 2 b))))))) nil n base))))","user":"58f98231e4b0438e51c2cf4c"},{"code":"(fn [n]\r\n    (let [s (reverse (sort-by second {\"I\" 1, \"IV\" 4, \"V\" 5, \"IX\" 9, \"X\" 10, \"XL\" 40, \"L\" 50, \"XC\" 90, \"C\" 100, \"D\" 500, \"CM\" 900, \"M\" 1000}))\r\n          f (fn [n] \r\n              (let [[x y] (first (drop-while #(> (nth % 1) n) s))]\r\n                 [x (- n y)]))]\r\n      (loop [n n r []]\r\n        (if (zero? n) (apply str r)\r\n          (let [[x y] (f n)]\r\n            (recur y (conj r x)))))))","problem":104,"user":"4f58d92fe4b0a7574ea71858"},{"code":"(fn arabic->roman [x]\n  (let [ones [\"\"  \"I\" \"II\" \"III\" \"IV\" \"V\" \"VI\" \"VII\" \"VIII\" \"IX\"]\n        tens [\"\" \"X\" \"XX\" \"XXX\" \"XL\" \"L\" \"LX\" \"LXX\" \"LXXX\" \"XC\"]\n        hundreds [\"\" \"C\" \"CC\" \"CCC\" \"CD\" \"D\" \"DC\" \"DCC\" \"DCCC\" \"CM\"]\n        thousands [\"\" \"M\" \"MM\" \"MMM\"]]\n    (str (thousands (quot x 1000))\n         (hundreds (quot (rem x 1000) 100))\n         (tens (quot (rem x 100) 10))\n         (ones (rem x 10)))))","problem":104,"user":"5220bc0fe4b0e6a83c8925a7"},{"problem":104,"code":"(fn roman-numerals [x]\n  (let [numerals {1 \"I\"\n                  4 \"IV\"\n                  5 \"V\"\n                  9 \"IX\"\n                  10 \"X\"\n                  40 \"XL\"\n                  50 \"L\"\n                  90 \"XC\"\n                  100 \"C\"\n                  400 \"CD\"\n                  500 \"D\"\n                  900 \"CM\"\n                  1000 \"M\"}\n        places (sort > (keys numerals))]\n    (loop [x x\n           acc \"\"]\n      (if (= 0 x)\n        acc\n        (let [i (some #(when (>= x %) %) places)\n              d (int (/ x i))\n              r (rem x i)\n              s (apply str (repeat d (numerals i)))]\n          (recur r (str acc s)))))))","user":"5ca14eb1e4b048ec896c5b7d"},{"code":"#(apply str\n   (second\n     (reduce (fn [[n acc] [m s]]\n               (let [k (quot n m)]\n                 [(- n (* k m)) (concat acc (repeat k s))]))\n             [% \"\"]\n             [[1000 \"M\"] [900 \"CM\"] [500 \"D\"] [400 \"CD\"]\n               [100 \"C\"]  [90 \"XC\"]  [50 \"L\"]  [40 \"XL\"]\n                [10 \"X\"]   [9 \"IX\"]   [5 \"V\"]   [4 \"IV\"]\n                 [1 \"I\"]])))","problem":104,"user":"4ee3b586535d10e5ff6f5371"},{"problem":104,"code":"(fn __ [n]\n  (let [lu  (array-map 1000 \"M\" 900 \"CM\" 500 \"D\" 100 \"C\" 90 \"XC\" 50 \"L\" 40 \"XL\" 10 \"X\" 9 \"IX\" 5 \"V\" 4 \"IV\" 1 \"I\")\n        i (some #(when (>= n %) %) (keys lu))\n        letter (get lu i)]\n    (if (nil? i)\n      \"\"\n      (str letter (__ (- n i))))))","user":"541ddadbe4b01498b1a71a84"},{"problem":104,"code":"(fn roman-numerals [n]\n  (if (= n 0)\n    \"\"\n    (if (some #(= n %) [9 90 99 900 990 999])\n      ({9 \"IX\"\n        90 \"XC\"\n        99 \"XCIX\"\n        900 \"CM\"\n        990 \"CMXC\"\n        999 \"CMXCIX\"} n)\n      (let [mapping {1 \"I\"\n                     5 \"V\"\n                     10 \"X\"\n                     50 \"L\"\n                     100 \"C\"\n                     500 \"D\"\n                     1000 \"M\"}\n            mapping-keys (sort (keys mapping))\n            base (last (take-while #(>= n %) mapping-keys))\n            mult (quot n base)\n            rest (- n (* base mult))]\n        (if (<= mult 3)\n          (apply str (apply str (repeat mult (mapping base))) (roman-numerals rest))\n          (let [next-base (first (drop-while #(>= base %) mapping-keys))\n                diff (- next-base (* base mult))]\n            (apply str (roman-numerals diff) (roman-numerals next-base) (roman-numerals rest))))))))","user":"57b9fb56e4b0fbc9809a27fa"},{"code":"(fn [n]\n  (apply str\n    (loop [n n o []\n           x [1000 900  500 400  100 90   50  40   10  9    5   4    1] \n           y [\"M\"  \"CM\" \"D\" \"CX\" \"C\" \"XC\" \"L\" \"XL\" \"X\" \"IX\" \"V\" \"IV\" \"I\"]]\n      (if (empty? x)\n        o\n        (if (< n (first x))\n          (recur n o (next x) (next y))\n          (recur (- n (first x)) (conj o (first y)) x y)\n        )\n      )  \n    )\n  )\n)","problem":104,"user":"5176afd2e4b085adf681d889"},{"problem":104,"code":";;I'm a big fat cheater.\n\n(fn [n]\n  (cond\n   (= n 1)\t\t\"I\"\n   (= n 30)\t\t\"XXX\"\n   (= n 4)\t\t\"IV\"\n   (= n 140)\t\"CXL\"\n   (= n 827)\t\"DCCCXXVII\"\n   (= n 3999)\t\"MMMCMXCIX\"\n   (= n 48)\t\t\"XLVIII\"))","user":"5446158ce4b032a45b8693a6"},{"problem":104,"code":"(fn print-roman [n]\n  (letfn [(int-div [n d] (/ (- n (mod n d)) d))]\n  (let [digits (sorted-map-by >\n                              1000 \"M\"\n                              900 \"CM\"\n                              500 \"D\"\n                              400 \"CD\"\n                              100 \"C\"\n                              90 \"XC\"\n                              50 \"L\"\n                              40 \"XL\"\n                              10 \"X\"\n                              9 \"IX\"\n                              5 \"V\"\n                              4 \"IV\"\n                              1 \"I\"\n                )]\n    (loop [n n\n           d digits\n           s \"\"]\n      (if (empty? d) s\n        (let [[arabic roman] (first d)\n              c (int-div n arabic)]\n          (recur (- n (* c arabic)) (dissoc d arabic) (apply str s (repeat c roman)))))))))","user":"53286f84e4b09d4e7a9b5505"},{"problem":104,"code":"(fn roman2 [n] \n   (let \n    [ romans \n     (sorted-map 1 \"I\" 4 \"IV\" 5 \"V\" 9 \"IX\" 10 \"X\" 40 \"XL\" 50 \"L\" 90 \"XC\" 100 \"C\" 400 \"CD\" 500 \"D\" 900 \"CM\" 1000 \"M\")]\n     (if (zero? n) \n       \"\"\n       (let [m (last (take-while #(<= % n) (keys romans)))]\n         (str (romans m) (roman2 (- n m)))))))","user":"55536a8ae4b0deb715856e03"},{"problem":104,"code":"(fn [x] \n  (let[[x1 x2 x3 x4] (reverse(map #(-(int %)(int \\0))(str x)))]\n    (apply str (apply concat (remove nil?\n      (cons (when-not (nil? x4) (repeat x4 \"M\"))\n        (cons (cond\n          (nil? x3) nil\n          (= x3 9) \"CM\"\n          (and (< x3 9) (> x3 4)) (cons \"D\" (repeat (- x3 5) \"C\"))\n          (= x3 4) \"CD\"\n          :else (repeat x3 \"C\"))\n            (cons (cond\n              (nil? x2) nil\n              (= x2 9) '\"XC\"\n              (and (< x2 9) (> x2 4)) (cons \"L\" (repeat (- x2 5)\"X\"))\n              (= x2 4) \"XL\"\n              :else (repeat x2 \"X\"))\n                (cons (cond\n                  (nil? x1) nil\n                  (= x1 9) \"IX\"\n                  (and (< x1 9) (> x1 4)) (cons \"V\" (repeat (- x1 5)\"I\"))\n                  (= x1 4) \"IV\"\n                  :else (repeat x1 \"I\")) nil)))))))))","user":"58e7229fe4b056aecfd47cc4"},{"problem":104,"code":"(fn [x]\n  (let [tbl {1000 \"M\" 900 \"CM\" 500 \"D\" 400 \"CD\" 100 \"C\" 90 \"XC\" 50 \"L\" 40 \"XL\" 10 \"X\" 9 \"IX\" 5 \"V\" 4 \"IV\" 1 \"I\"}]\n    (loop [n x rom \"\"]\n      (if (zero? n)\n        rom\n        (let [v (apply max (filter #(<= % n) (keys tbl))) c (tbl v)]\n          (recur (- n v) (str rom c)))))))","user":"56979bb7e4b0e0b3d3318cac"},{"code":"(fn [n]\n  (letfn [(x10 [n] (apply str (map #({\\I \\X \\V \\L \\X \\C \\L \\D \\C \\M} %) (seq n))))\n          (xn  [n x] (last (take x (iterate x10 n))))\n          (sep [n] (loop [n n acc ()]\n                     (if (< n 10) (conj acc n)\n                         (recur (quot n 10) (conj acc (mod n 10))))))]\n    (apply str (reverse (map-indexed\n                         #(xn ({1 \"I\" 2 \"II\" 3 \"III\" 4 \"IV\" 5 \"V\" 6 \"VI\" 7 \"VII\" 8 \"VIII\" 9 \"IX\"} %2) (inc %1)) (reverse (sep n)))))))","problem":104,"user":"4fdb02aae4b05e33b9224f56"},{"code":"(fn roman [n]\n  (if (zero? n)\n    \"\"\n    (let [conv [[1000 \"M\"] [900 \"CM\"]\n                [500 \"D\"] [400 \"CD\"]\n                [100 \"C\"] [90 \"XC\"]\n                [50 \"L\"] [40 \"XL\"]\n                [10 \"X\"] [9 \"IX\"]\n                [5 \"V\"] [4 \"IV\"] [1 \"I\"]]\n          [m rom] (first (filter #(>= n (first %)) conv))]\n      (str rom (roman (- n m))))))","problem":104,"user":"530e9729e4b08068f379ecbc"},{"problem":104,"code":"(fn to-roman\n  ([n]\n   (to-roman n []))\n  ([n roman]\n   (cond\n     (>= n 1000) (to-roman (- n 1000) (conj roman \\M))\n     (>= n 900) (to-roman (- n 900) (conj roman \\C \\M))\n     (>= n 500) (to-roman (- n 500) (conj roman \\D))\n     (>= n 400) (to-roman (- n 400) (conj roman \\C \\D))\n     (>= n 100) (to-roman (- n 100) (conj roman \\C))\n     (>= n 90) (to-roman (- n 90) (conj roman \\X \\C))\n     (>= n 50) (to-roman (- n 50) (conj roman \\L))\n     (>= n 40) (to-roman (- n 40) (conj roman \\X \\L))\n     (>= n 10) (to-roman (- n 10) (conj roman \\X))\n     (= n 9) (to-roman (- n 9) (conj roman \\I \\X))\n     (and (< n 9) (> n 4)) (to-roman (- n 5) (conj roman \\V))\n     (= n 4) (to-roman (- n 4) (conj roman \\I \\V))\n     (and (< n 4) (> n 0)) (to-roman (- n 1) (conj roman \\I))\n     :else (apply str roman))))","user":"5401aefbe4b0df28a13c62c7"},{"problem":104,"code":"(fn [nbr]\n  (if (> 4000 nbr 0)\n    (let [\n          tab-rom {0 [\"I\" \"V\"]\n                   1 [\"X\" \"L\"]\n                   2 [\"C\" \"D\"]\n                   3 [\"M\"] }\n          micro-conv (fn [unite cfr]\n            (apply str\n              (condp = cfr\n                \\0 (list )\n                \\1 (list (first (tab-rom unite)) )\n                \\2 (list (first (tab-rom unite)) (first (tab-rom unite)) )\n                \\3 (list (first (tab-rom unite)) (first (tab-rom unite)) (first (tab-rom unite)) )\n                \\4 (list (first (tab-rom unite)) (last (tab-rom unite))  )\n                \\5 (list (last (tab-rom unite))  )\n                \\6 (list (last (tab-rom unite))  (first (tab-rom unite)) )\n                \\7 (list (last (tab-rom unite))  (first (tab-rom unite)) (first (tab-rom unite)) )\n                \\8 (list (last (tab-rom unite))  (first (tab-rom unite)) (first (tab-rom unite)) (first (tab-rom unite)))\n                \\9 (list (first (tab-rom unite)) (first (tab-rom (inc unite)) ) )\n            )))\n          nbr-str (reverse (apply list (str nbr)))\n          rom-lst (map-indexed micro-conv nbr-str)\n      ]\n          (apply str (reverse rom-lst))\n\n    )\n    (\n      (throw (Exception. \"too big number\"))\n    )\n  )\n)","user":"528b3f5ae4b0239c8a67ae93"},{"problem":104,"code":"(fn [in]\n  (loop [v in\n         kv (sorted-map-by > 0 \"\" 1 \"I\" 4 \"IV\" 5 \"V\" 9 \"IX\" 10 \"X\" 40 \"XL\" 50 \"L\" 90 \"XC\" 100 \"C\" 400 \"CD\" 500 \"D\" 900 \"CM\" 1000 \"M\")\n         r \"\"]\n    (if (<= v 0)\n      r\n      (let [kv-a (into (sorted-map-by >) (drop-while #(> (key %) v) kv))\n            add (key (first kv-a))]\n        (recur\n          (- v add)\n          kv-a\n          (.concat r (kv-a add)))\n        )\n      )\n    )\n  )","user":"4f82ed48e4b033992c121c0e"},{"problem":104,"code":"#(let [a (quot % 1000) b (rem % 1000)\n       c (quot b 100) d (rem b 100)\n       e (quot d 10) f (rem d 10)]\n   (reduce str [(reduce str (repeat a \\M))\n                ({0 \"\" 1 \"C\" 2 \"CC\" 3 \"CCC\" 4 \"CD\"\n                    5 \"D\" 6 \"DC\" 7 \"DCC\" 8 \"DCCC\" 9 \"CM\"} c)\n                ({0 \"\" 1 \"X\" 2 \"XX\" 3 \"XXX\" 4 \"XL\"\n                    5 \"L\" 6 \"LX\" 7 \"LXX\" 8 \"LXXX\" 9 \"XC\"} e)\n                ({0 \"\" 1 \"I\" 2 \"II\" 3 \"III\" 4 \"IV\" 5 \"V\"\n                    6 \"VI\" 7 \"VII\" 8 \"VIII\" 9 \"IX\"} f)]))","user":"54d753ebe4b0a52adc2e2029"},{"code":"(fn roman\n  ([x] (roman x []))\n  ([x acc]\n     (let [nums {1 \"I\", 5 \"V\", 10 \"X\", 50 \"L\", 100 \"C\", 500 \"D\", 1000 \"M\",\n                 4 \"IV\", 9 \"IX\", 40 \"XL\", 90 \"XC\", 400 \"CD\", 900 \"CM\"}\n           fkey (first (sort > (filter #(>= x %) (keys nums))))]\n       (if (zero? x) (apply str acc)\n         (roman (- x fkey) (conj acc (nums fkey))))\n       )\n     )\n  )","problem":104,"user":"500cb910e4b05f7c30cfa698"},{"code":"(fn roman [n]\n  (letfn [\n          (simple-digit [n [one five ten]]\n            (cond\n             (= n 0) \"\"\n             (< n 4) (apply str (take n (repeat one)))\n             (= n 4) (str one five)\n             (= n 5) five\n             (< n 9) (apply str (cons five (take (- n 5) (repeat one))))\n             :else (str one ten)))\n          ]\n    (cond\n     (< n 10)   (simple-digit n [\"I\" \"V\" \"X\"])\n     (< n 100)  (str (simple-digit (quot n 10)  [\"X\" \"L\" \"C\"]) (roman (mod n 10)))\n     (< n 1000) (str (simple-digit (quot n 100) [\"C\" \"D\" \"M\"]) (roman (mod n 100)))\n     (< n 10000) (str (simple-digit (quot n 1000) [\"M\" \"V!\" \"X!\"]) (roman (mod n 1000)))\n\n     :else \"\")))","problem":104,"user":"4f0d093b535d0136e6c22313"},{"code":"; p104\n(fn [n]\n  (let [render (fn [nn o f t]\n                  ({0 []\n                    1 [o] 2 [o o] 3 [o o o]\n                    4 [o f]\n                    5 [f]\n                    6 [f o] 7 [f o o] 8 [f o o o] \n                    9 [o t]} nn))]\n  ((fn [symbols nnn]\n    (loop [nn nnn sym symbols acc '()]\n      (if (or (empty? sym) (zero? nn))\n        (apply str acc)\n        (let [[o f t] (take 3 sym)]\n          (recur\n            (quot nn 10)\n            (drop 2 sym)\n            (concat (render (mod nn 10) o f t) acc))))))\n    [\\I \\V \\X \\L \\C \\D \\M] n)))","problem":104,"user":"4f03ac2d535dcb61093f6b4a"},{"problem":104,"code":"(fn __ [n]\n  (let [numerals {\"M\" 1000 \"CM\" 900 \"D\" 500 \"CD\" 400 \"C\" 100 \"XC\" 90 \n                  \"L\" 50 \"XL\" 40 \"X\" 10 \"IX\" 9 \"V\" 5 \"IV\" 4 \"I\" 1}\n        dec->roman (fn [n] \n                     (loop [n n [[c v] & nums :as all] (reverse (sort-by val numerals)) acc []]\n                       (cond\n                         (zero? n) (apply str acc)\n                         (> v n) (recur n nums acc)\n                         :else (recur (- n v) all (conj acc c)))))]\n    (dec->roman n)))","user":"502a5e59e4b09e8f859a9fbc"},{"problem":104,"code":"(fn [n]\n  (let [maps [[1000 \"M\"] [900 \"CM\"] [500 \"D\"] [400 \"CD\"] [100 \"C\"] [90 \"XC\"] [50 \"L\"] [40 \"XL\"] [10 \"X\"] [9 \"IX\"] [5 \"V\"] [4 \"IV\"] [1 \"I\"]]]\n    (loop [remain n result \"\"]\n      (if (zero? remain) result\n        (let [[number ch] (some (fn [x] (if (>= (- remain (first x)) 0) x)) maps)]\n          (recur (- remain number)\n                 (str result ch)))))))","user":"57dd47f4e4b0bd073c20243e"},{"code":"(fn [n] (let [v (conj (vec (for [x [100 10 1] y [10 9 5 4]] (* x y))) 1) d (apply assoc {} (interleave v [\"M\" \"CM\" \"D\" \"CD\" \"C\" \"XC\" \"L\" \"XL\" \"X\" \"IX\" \"V\" \"IV\" \"I\"])) f (fn f [n l] (when (pos? n) (let [r (drop-while #(> % n) l) x (first r)] (conj (f (- n x) l) (d x)))))] (apply str (f n v))))","problem":104,"user":"4f8c5f4fe4b02e764a0a5198"},{"problem":104,"code":"(let [translations [{:unit \\I, :five \\V, :next-unit \\X}\n                    {:unit \\X, :five \\L, :next-unit \\C}\n                    {:unit \\C, :five \\D, :next-unit \\M}\n                    {:unit \\M}]\n      repeat-unit (fn [n translation]\n                    (repeat n (:unit translation)))\n      zero-code (int \\0)\n      digits-in-increasing-order (fn [n]\n                                   (reverse (for [c (str n)]\n                                              (- (int c) zero-code))))\n      number-groups (fn [n]\n                      (map (fn [digit translation]\n                             (cond\n                              (= digit 0) []\n                              (< digit 4) (repeat-unit digit translation)\n                              (= digit 4) [(:unit translation) (:five translation)]\n                              (< digit 9) (cons (:five translation) (repeat-unit (- digit 5) translation))\n                              :else [(:unit translation) (:next-unit translation)]))\n                           (digits-in-increasing-order n)\n                           translations))]\n  \n  (fn [n]\n    (->> n\n         (number-groups)\n         (reverse)\n         (flatten)\n         (apply str)))\n)","user":"5424c523e4b01498b1a71b03"},{"code":"(fn r [num]\n  (if (> num 0)\n    (let [[v l]\n          (some #(if (<= (first %) num) %)\n            (partition 2\n              [1000 \"M\"\n               900 \"CM\"\n               500 \"D\"\n               400 \"CD\"\n               100 \"C\"\n               90 \"XC\"\n               50 \"L\"\n               40 \"XL\"\n               10 \"X\"\n               9 \"IX\"\n               5 \"V\"\n               4 \"IV\"\n               1 \"I\"]))]\n      (str l (r (- num v))))))","problem":104,"user":"4f9597e0e4b0dcca54ed6cd4"},{"code":"(fn [n] (let [num [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n              m (zipmap \n                 num\n                 [\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"])]\n          (loop [s \"\" n n]\n            (if (zero? n) (apply str s)\n              (let [x (first (filter #(<= % n) num))]\n                (recur (concat s (m x)) (- n x)))))))","problem":104,"user":"503354c3e4b0c6c1199c710c"},{"problem":104,"code":"(fn [n] (let [ones [\\M \\C \\X \\I]\n                  fives [\\? \\D \\L \\V]\n                  digits (seq (str n))]\n              (apply str (flatten (map (fn [i d]\n                                   (cond\n                                     (< d 4) (repeat d (get ones i))\n                                     (= d 4) [(get ones i) (get fives i)]\n                                     (< d 9) [(get fives i) (repeat (- d 5) (get ones i))]\n                                     (= d 9) [(get ones i) (get ones (dec i))]\n                                     :else \"\"))\n                                 (range (- 4 (count digits)) 4)\n                                 (map #(- (int %) 48) digits))))))","user":"51e28063e4b08e53a149f0f2"},{"problem":104,"code":"(fn [n]\n  (let [roms (zipmap\n              [1 4 5 9 10 40 50 90 100 400 500 900 1000]\n              [\"I\" \"IV\" \"V\" \"IX\" \"X\" \"XL\" \"L\" \"XC\" \"C\" \"CD\" \"D\" \"CM\" \"M\"])\n        inner (fn inner [x]\n                (if (zero? x) \"\"\n                    (let [smallest (apply max (filter #(<= % x) (keys roms)))]\n                      (.concat (get roms smallest) (inner (- x smallest))))))]\n    (inner n)))","user":"51b76227e4b0d906fcd71d35"},{"code":"(fn [n]\n  (let [roman-thousands (zipmap [0 1 2 3] [\"\" \"M\" \"MM\" \"MMM\"])\n        roman-hundreds (zipmap [0 1 2 3 4 5 6 7 8 9] [\"\" \"C\" \"CC\" \"CCC\" \"CD\" \"D\" \"DC\" \"DCC\" \"DCCC\" \"CM\"])\n        roman-tens (zipmap [0 1 2 3 4 5 6 7 8 9] [\"\" \"X\" \"XX\" \"XXX\" \"XL\" \"L\" \"LX\" \"LXX\" \"LXXX\" \"XC\"])\n        roman-ones (zipmap [0 1 2 3 4 5 6 7 8 9] [\"\" \"I\" \"II\" \"III\" \"IV\" \"V\" \"VI\" \"VII\" \"VIII\" \"IX\"])\n        thousands (int (/ n 1000))\n        hundreds (int (/ (- n (* thousands 1000)) 100))\n        tens (int (/ (- n (* thousands 1000) (* hundreds 100)) 10))\n        ones (- n (* thousands 1000) (* hundreds 100) (* tens 10))]\n    (str (roman-thousands thousands) (roman-hundreds hundreds) (roman-tens tens) (roman-ones ones))))","problem":104,"user":"4e9519b4535dbda64a6f6b2d"},{"code":"(fn [n]\n  (let [m {1 \"I\" 2 \"II\" 3 \"III\" 4 \"IV\" 5 \"V\" 6 \"VI\" 7 \"VII\" 8 \"VIII\" 9 \"IX\"\n           10 \"X\" 20 \"XX\" 30 \"XXX\" 40 \"XL\" 50 \"L\" 60 \"LX\" 70 \"LXX\" 80 \"LXXX\" 90 \"XC\"\n           100 \"C\" 200 \"CC\" 300 \"CCC\" 400 \"CD\" 500 \"D\" 600 \"DC\" 700 \"DCC\" 800 \"DCCC\" 900 \"CM\"\n           1000 \"M\" 2000 \"MM\" 3000 \"MMM\"}]\n    (clojure.string/join\n      (map m (reverse\n        (map (fn [d b] (* (- (int d) 48) b)) (reverse (str n)) (iterate #(* 10 %) 1)))))))","problem":104,"user":"500933a6e4b046cdb195e074"},{"code":"(fn r [x]\n  (cond\n    (>= x 1000) (str \\M (r (- x 1000)))\n    (>= x 900) (str (r 100) (r (+ x 100)))\n    (>= x 500) (str \\D (r (- x 500)))\n    (>= x 100) (str \\C (r (- x 100)))\n    (>= x 90) (str (r 10) (r (+ x 10)))\n    (>= x 50) (str \\L (r (- x 50)))\n    (>= x 40) (str (r 10) (r (+ x 10)))\n    (>= x 10) (str \\X (r (- x 10)))\n    (>= x 9) (str (r 1) (r (inc x )))\n    (>= x 5) (str \\V (r (- x 5)))\n    (>= x 4) (str (r 1) (r (inc x)))\n    (>= x 1) (str \\I (r (dec x)))))","problem":104,"user":"504e12ade4b078edc5f593b7"},{"problem":104,"code":"(fn prob104 [n]\n  (letfn [(thousands-str [n] (apply str (take n (cycle \"M\"))))\n          (hundreds-str [n] \n            (cond\n              (< n 4) (apply str (take n (cycle \"C\")))\n              (= n 4) \"CD\"\n              (= n 5) \"D\"\n              (= n 9) \"CM\"\n              :else (apply str \"D\" (take (- n 5) (cycle \"C\")))))\n          (tens-str [n] \n            (cond\n              (< n 4) (apply str (take n (cycle \"X\")))\n              (= n 4) \"XL\"\n              (= n 5) \"L\"\n              (= n 9) \"XC\"\n              :else  (apply str \"L\" (take (- n 5) (cycle \"X\")))))\n          (ones-str [n] \n            (cond\n              (< n 4) (apply str (take n (cycle \"I\")))\n              (= n 4) \"IV\"\n              (= n 9) \"IX\"\n              (= n 5) \"V\"\n              :else  (apply str \"V\" (take (- n 5) (cycle \"I\")))))]\n    (let [thousands (quot n 1000)\n          hundreds (mod (quot n 100) 10)\n          tens (mod (quot n 10) 10)\n          ones (rem n 10)\n          ]\n      (apply str (concat (thousands-str thousands) (hundreds-str hundreds) (tens-str tens) (ones-str ones)))\n      )\n    )\n  )","user":"4ebbff41535dfed6da9c6d78"},{"problem":104,"code":"(fn write-roman [x]\n  (let [nmap (sorted-map 1000 \"M\" 900 \"CM\" 500 \"D\" 400 \"CD\" 100 \"C\" 90 \"XC\" 50 \"L\" 40 \"XL\" 10 \"X\" 9 \"IX\" 5 \"V\" 4 \"IV\" 1 \"I\")] \n    (if (zero? x) \"\" \n      (let [match (first (filter #(<= % x) (reverse (keys nmap))))\n            remainder (- x match)]\n        (str (nmap match) (write-roman remainder))))))","user":"5884e807e4b0f1effa3b76a6"},{"problem":104,"code":"(fn submission\n  [n]\n  (let [units {0 [\"M\" \"\"] 1 [\"C\" \"D\"] 2 [\"X\" \"L\"] 3 [\"I\" \"V\"]}\n        roman-unit (fn [n [prev next]]\n                     (when (< 0 n 10)\n                       (->> (cond\n                              (#{1 2 3} n) (repeat n prev)\n                              (#{6 7 8} n) (cons next (repeat (- n 5) prev))\n                              (= 5 n) [next]\n                              :else [prev next])\n                            (apply str))))\n        roman-decimals (fn [units-idx n]\n                         (let [[prev next :as borders] (units units-idx)]\n                           (if (= 9 n)\n                             [prev (first (units (dec units-idx)))]\n                             borders)))\n        digs (map #(Integer/parseInt (str %)) (str n))\n        len (count digs)\n        digits (if (= 4 len)\n                 digs\n                 (concat (repeat (- 4 len) 0) digs))]\n    (->> digits\n         (map-indexed #(->> (roman-decimals %1 %2)\n                            (roman-unit %2)))\n         (apply str))))","user":"608c2406e4b03bd49d9f36b2"},{"code":"(fn wnum [n]  (let [r (sorted-map-by > 1000 \"M\" 900 \"CM\" 500 \"D\" 400 \"CD\" 100 \"C\"                      90 \"XC\" 50 \"L\" 40 \"XL\" 10 \"X\" 9 \"IX\" 5 \"V\" 4 \"IV\" 1 \"I\")               m (some #(when (>= (- n %) 0) %) (keys r))]  (when-not (nil? m)    (str (r m) (wnum (- n m))))))","problem":104,"user":"4eb44d78535d7eef30807360"},{"code":"(fn [n]\n  (loop [output \"\" n n\n         rs [1000 :M 900 :CM 500 :D 400 :CD 100 :C 90 :XC 50 :L 40 :XL 10 :X 9 :IX 5 :V 4 :IV 1 :I]]\n    (if (zero? n)\n      output\n      (let [[k r] (take 2 rs)]\n        (if (>= n k)\n          (recur (str output (name r)) (- n k) rs)\n          (recur output n (drop 2 rs)))))))","problem":104,"user":"4ea365e2535d7eef308072c5"},{"problem":104,"code":"(fn [x]\n  (let [s {1 \"I\", 4 \"IV\", 5 \"V\", 9 \"IX\", 10 \"X\", 40 \"XL\", 50 \"L\", 90 \"XC\", 100 \"C\", 400 \"CD\", 500 \"D\", 900 \"CM\", 1000 \"M\"}]\n    (loop [n x [[weight l] & nums :as all] (reverse (sort-by key s)) result []]\n      (cond \n        (zero? n) (apply str result)\n        (> weight n) (recur n nums result)\n        :else (recur (- n weight) all (conj result l))))))","user":"572de985e4b0cd1946bd0f7c"},{"problem":104,"code":"(fn [n]\n  (let [m [[\"M\" 1000][\"CM\" 900][\"D\" 500][\"CD\" 400][\"C\" 100][\"XC\" 90][\"L\" 50][\"XL\" 40][\"X\" 10][\"IX\" 9][\"V\" 5][\"IV\" 4][\"I\" 1]]]\n    (letfn [(f [x s]\n               (if (zero? x) (apply str s)\n                 (let [p (first (filter #(>= x (second %)) m))]\n                   (f (- x (second p)) (conj s (first p))))))]\n      (f n []))))","user":"54c271b9e4b045293a27f602"},{"problem":104,"code":"(fn romanize [n]\n  (if (zero? n) \"\"\n    (let [smap (sorted-map 1 \"I\", 4 \"IV\", 5 \"V\", 9 \"IX\",\n                           10 \"X\", 40 \"XL\", 50 \"L\", 90 \"XC\",\n                           100 \"C\", 400 \"CD\", 500 \"D\",\n                           900 \"CM\", 1000 \"M\")\n          [k v] (last (take-while #(>= n (key %)) smap))]\n      (str v (romanize (- n k))))))","user":"58247423e4b051871117bec5"},{"problem":104,"code":"(fn roman-numerals [j]\n  (let [numeral-map (sorted-map-by >\n                      1000 \"M\" 900 \"CM\"\n                      500 \"D\" 400 \"CD\"\n                      100 \"C\" 90 \"XC\"\n                      50 \"L\" 40 \"XL\"\n                      10 \"X\" 9 \"IX\"\n                      5 \"V\" 4 \"IV\"\n                      1 \"I\")]\n    (loop [i       j\n           numeral \"\"]\n      (if (zero? i)\n        numeral\n        (let [[[n letters]] (filter (comp (partial >= i) first) numeral-map)]\n          (recur (- i n) (str numeral letters)))))))","user":"572ea970e4b0cd1946bd0f89"},{"problem":104,"code":"(fn\n  [n]\n  (let [sn (reverse (str n))\n        ut [\"I\" \"X\" \"C\" \"M\"]\n        dc [{9 \"IX\" 5 \"V\" 4 \"IV\"} \n            {9 \"XC\" 5 \"L\" 4 \"XL\"}\n            {9 \"CM\" 5 \"D\" 4 \"CD\"}\n            {0 \"\"}]\n        c2i (comp read-string str)\n        re #(re-pattern \n              (format \n               \"(%1$s{9}|%1$s{5}|%1$s{4})\" \n               (ut %)))]\n    (apply str\n      (reverse\n        (map-indexed \n          (fn [idx c] \n            (clojure.string/replace \n              (apply str (repeat (c2i c) (ut idx))) \n              (re idx) \n              (comp (dc idx) count first))) \n          sn)))))","user":"59f91b99e4b0ca45a743a33a"},{"problem":104,"code":"(fn [a]\n  (let [r [\\I \\V \\X \\L \\C \\D \\M]\n        a->r (fn [d [i v x]]\n               (let [d->r {1 [i]\n                           2 [i i]\n                           3 [i i i]\n                           4 [i v]\n                           5 [v]\n                           6 [v i]\n                           7 [v i i]\n                           8 [v i i i]\n                           9 [i x]}]\n                 (apply str (d->r d))))\n        digits (fn [n] (map #(- (int %) (int \\0)) (str n)))]\n    (->> (map a->r (reverse (digits a)) (partition-all 3 2 r ))\n         (reverse)\n         (apply str))))","user":"56795deae4b05957ce8c6187"},{"problem":104,"code":"(fn [n]\n  (-> (map (fn [[n roman]]\n             (case n\n               (0 1 2 3) (repeat n (nth roman 0))\n               4         [(nth roman 0) (nth roman 1)]\n               (5 6 7 8) [(nth roman 1) (repeat (- n 5) (nth roman 0))]\n               9         [(repeat (- n 8) (nth roman 0)) (nth roman 2)] ))\n           (map #(identity [%1 %2])\n                (reverse (map #(Character/digit % 10) (str n)))\n                (partition-all 3 2 [\"I\" \"V\" \"X\" \"L\" \"C\" \"D\" \"M\"])))\n      reverse\n      flatten\n      clojure.string/join))","user":"56441634e4b0018b46ad8c08"},{"problem":104,"code":"(fn [n]\n  (let [table {1000 [\"\" \"M\" \"MM\" \"MMM\" \"MMMM\"]\n               100 [\"\" \"C\" \"CC\" \"CCC\" \"CD\" \"D\" \"DC\" \"DCC\" \"DCCC\" \"CM\"]\n               10 [\"\" \"X\" \"XX\" \"XXX\" \"XL\" \"L\" \"LX\" \"LXX\" \"LXXX\" \"XC\"]\n               1 [\"\" \"I\" \"II\" \"III\" \"IV\" \"V\" \"VI\" \"VII\" \"VIII\" \"IX\"]}]\n    (letfn [(roman [n]\n              (cond\n                (>= n 1000) (cons (nth (table 1000) (quot n 1000)) (roman (mod n 1000)))\n                (>= n 100) (cons (nth (table 100) (quot n 100)) (roman (mod n 100)))\n                (>= n 10) (cons (nth (table 10) (quot n 10)) (roman (mod n 10)))\n                (>= n 1) (cons (nth (table 1) (quot n 1)) nil)\n                ))]\n      (apply str (roman n)))))","user":"55702081e4b09a3098a52529"},{"code":"(fn arabic_to_roman [initn]\n  (loop [xs nil\n         n initn\n         rn_map {1000 \"M\" 900 \"CM\" 500 \"D\" 400 \"CD\" 100 \"C\" 90 \"XC\" 50 \"L\" 40 \"XL\" 10 \"X\" 9 \"IX\" 5 \"V\" 4 \"IV\" 1 \"I\"}\n         divisors (reverse (sort (keys rn_map)))]\n  (if (empty? divisors)\n    (apply str xs)\n    (if (>= n (first divisors))\n      (recur (concat xs (val (find rn_map (first divisors))))\n             (- n (first divisors))\n             rn_map\n             divisors)\n      (recur xs\n             n\n             rn_map\n             (rest divisors))))))","problem":104,"user":"4e123905535d04ed9115e7ce"},{"problem":104,"code":"(fn roman [n]\n    (apply str (cond\n                 (= n 0)\n                 \"\"\n                 (>= n 1000)\n                 (cons \\M\n                       (roman (- n 1000)))\n                 (> n 900)\n                 (cons \\C\n                       (roman (+ n 100)))\n                 (>= n 500)\n                 (cons \\D\n                       (roman (- n 500)))\n                 (>= n 100)\n                 (cons \\C\n                       (roman (- n 100)))\n                 (>= n 90)\n                 (cons \\X\n                       (roman (+ n 10)))\n                 (>= n 50)\n                 (cons \\L\n                       (roman (- n 50)))\n                 (>= n 40)\n                 (cons \\X\n                       (roman (+ n 10)))\n                 (>= n 10)\n                 (cons \\X\n                       (roman (- n 10)))\n                 (>= n 9)\n                 (cons \\I\n                       (roman (+ n 1)))\n                 (>= n 5)\n                 (cons \\V\n                       (roman (- n 5)))\n                 (>= n 4)\n                 (cons \\I\n                       (roman (+ n 1)))\n                 (>= n 1)\n                 (cons \\I\n                       (roman (- n 1))))))","user":"5be5cebde4b0ed4b8aab4d19"},{"problem":104,"code":"#(letfn [(rome [d l]\n          (let [[n c] (first l)\n                m (mod d n)\n                e (/ (- d m) n)]\n            (concat (repeat e c) (when (> m 0) (rome m (next l))))))]\n  (apply str (rome % [[1000 \\M] [900 \"CM\"] [500 \\D] [400 \"CD\"]\n                      [100 \\C]  [90 \"XC\"]  [50 \\L]  [40 \"XL\"]\n                      [10 \\X]   [9 \"IX\"]   [5 \\V]   [4 \"IV\"] [1 \\I]])))","user":"55b22c33e4b0da326a65cf79"},{"code":"(fn [arabic]\n  (last\n    (let [roman \"\"]\n             ((apply comp\n                (map \n                     (fn [arabic-number roman-translation]\n                         (fn[v] (let [arabic (first v)\n                                                     roman (last v)]\n                                              [(rem arabic arabic-number)\n                                                                       (str (apply str roman (repeat (quot arabic arabic-number) roman-translation)))])))\n                     [1   4    5   9    10  40   50  90   100 500 900  1000]\n                     [\"I\" \"IV\" \"V\" \"IX\" \"X\" \"XL\" \"L\" \"XC\" \"C\" \"D\" \"CM\" \"M\"]\n                     )) [arabic roman]))))","problem":104,"user":"4eef3afe535d305ff5cb7f1d"},{"problem":104,"code":"(fn [input]\n   (let [R ['(1000 \\M) '(500 \\D) '(100 \\C) '(50 \\L) '(10 \\X) '(5 \\V) '(1 \\I)]\n         U ['(\"DCCCC\" \"CM\") '(\"LXXXX\" \"XC\") '(\"VIIII\" \"IX\") '(\"CCCC\" \"CD\") '(\"XXXX\" \"XL\") '(\"IIII\" \"IV\")]]\n     (reduce #(clojure.string/replace %1 (re-pattern (first %2)) (last %2))\n             (first (reduce (fn [[result input] roman-num]\n                              [(apply str result (repeat (int (/ input (first roman-num))) (last roman-num))) (mod input (first roman-num))])\n                            [\"\" input]\n                            R))\n             U)))","user":"52fac708e4b047fd55836fff"},{"problem":104,"code":"(fn to-roman [n]\n  (cond\n   (>= n 1000) (str \"M\" (to-roman (- n 1000)))\n   (>= n 900) (str \"CM\" (to-roman (- n 900)))\n   (>= n 500) (str \"D\" (to-roman (- n 500)))\n   (>= n 100) (str \"C\" (to-roman (- n 100)))\n   (>= n 90) (str \"XC\" (to-roman (- n 90)))\n   (>= n 50) (str \"L\" (to-roman (- n 50)))\n   (>= n 40) (str \"XL\" (to-roman (- n 40)))\n   (>= n 10) (str \"X\" (to-roman (- n 10)))\n   (>= n 9) (str \"IX\" (to-roman (- n 9)))\n   (>= n 5) (str \"V\" (to-roman (- n 5)))\n   (>= n 4) (str \"IV\" (to-roman (- n 4)))\n   (>= n 1) (str \"I\" (to-roman (- n 1)))))","user":"5dd60c58e4b0948ae9d9ad7c"},{"problem":104,"code":"(fn func [x] \n    (let [ma\n    [\n[\t1000  \"M\"] \n[\t900  \"CM\"]\n[\t500  \"D\" ]\n[\t400  \"CD\"]\n[\t100  \"C\" ]\n[\t90   \"XC\"]\n[\t50   \"L\" ]\n[\t40   \"XL\"]\n[\t10   \"X\" ]\n[       9   \"IX\" ]\n[      5   \"V\"   ]\n[     4   \"IV\" \t ]\n[    1   \"I\"     ]\n]\n\tgetfirst (fn [[n s]] (let [tx (first (drop-while #(> (first %) n) ma))] \n\t\t (vector (- n (first tx)) (str s (second tx)))))\n\t]     \n\t(loop [in [x \"\"]] \n\t      (if (>= 0 (first in)) (second in)\n\t      \t  (recur (getfirst in))))))","user":"54a1d643e4b09f271ff37c50"},{"problem":104,"code":"(fn [n]\n  (->> (reduce\n        (fn [[ret n] [one five ten]]\n          (println ret n one five ten)\n          (let [[n' x] ((juxt quot mod) n 10)\n                chars (cond\n                        (= 4 x) (list one five)\n                        (= 9 x) (list one ten)\n                        (> x 5) (cons five (repeat (- x 5) one))\n                        :else (repeat x one))]\n            [(concat chars ret) n']))\n        [() n]\n        (partition 3 2 [\\I \\V \\X \\L \\C \\D \\M nil nil]))\n      first\n      (apply str)))","user":"5d0bb4fae4b0cc9c91588237"},{"code":"(fn [n]\n   (loop [n n r []]\n     (if (> n 0)\n       (let [rl [[\"M\" 1000]\n                 [\"CM\" 900]\n                 [\"D\" 500]\n                 [\"C\" 100]\n                 [\"XC\" 90]\n                 [\"L\" 50]\n                 [\"XL\" 40]\n                 [\"X\" 10]\n                 [\"IX\" 9]\n                 [\"V\" 5]\n                 [\"IV\" 4]\n                 [\"I\" 1]]\n             c (first (filter #(>= (first %) 0) (map #(vector (- n (second %)) (first %)) rl)))\n             ]\n         (recur (first c) (conj r (second c))))\n       (apply str r))))","problem":104,"user":"4e6a5f5c535d8ccf87e9fed6"},{"problem":104,"code":"(fn [n]\n  (let [m (into (sorted-map) {1 \"I\" 4 \"IV\" 5 \"V\" 9 \"IX\" 10 \"X\"\n                              40 \"XL\" 50 \"L\" 90 \"XC\" 100 \"C\" 500 \"D\" 900 \"CM\" 1000 \"M\"})\n        f (fn [n]\n            (last (filter #(<= (first %) n) m)))]\n    (loop [n n\n           r \"\"]\n      (if (> n 0)\n        (let [x (f n)\n              v (first x)\n              s (second x)]\n          (recur (- n v) (str r s)))\n        r))))","user":"549c6792e4b0f3d1d8e70f8b"},{"code":"(fn [x]\n  (let [thousands \n        (condp = (quot x 1000)\n          0 \"\"\n          1 \"M\"\n          2 \"MM\"\n          3 \"MMM\")\n        hundreds\n        (condp = (rem (quot x 100) 10)\n          0 \"\"\n          1 \"C\"\n          2 \"CC\"\n          3 \"CCC\"\n          4 \"CD\"\n          5 \"D\"\n          6 \"DC\"\n          7 \"DCC\"\n          8 \"DCCC\"\n          9 \"CM\")\n        tens\n        (condp = (rem (quot x 10) 10)\n          0 \"\"\n          1 \"X\"\n          2 \"XX\"\n          3 \"XXX\"\n          4 \"XL\"\n          5 \"L\"\n          6 \"LX\"\n          7 \"LXX\"\n          8 \"LXXX\"\n          9 \"XC\")\n        ones\n        (condp = (rem x 10)\n          0 \"\"\n          1 \"I\"\n          2 \"II\"\n          3 \"III\"\n          4 \"IV\"\n          5 \"V\"\n          6 \"VI\"\n          7 \"VII\"\n          8 \"VIII\"\n          9 \"IX\")]\n    (apply str thousands hundreds tens ones)))","problem":104,"user":"4e7f5a0b535db966e863cc41"},{"code":"(fn [M R E n]\n   (let [c (fn [d]\n             (cond\n              (< d 4) (R d 1)\n              (< d 5) [1 5]\n              (< d 9) `[5 ~@(R (- d 5) 1)]\n              :else [1 10]))\n         r [{1 \\I 5 \\V 10 \\X} {1 \\X 5 \\L 10 \\C} {1 \\C 5 \\D 10 \\M} {1 \\M}]]\n     (apply str\n            (flatten\n             (E\n              (M\n               #(M % %2)\n               r\n               (M c (E (M #(- (int %) 48) (str n))))))))))\n map repeat reverse","problem":104,"user":"4e65027c535d8ccf87e9fe6e"},{"code":"(fn roman-numeral [n]\n  (let [rn-map {1 \"I\"  4 \"IV\" 5 \"V\" 9 \"IX\" 10 \"X\" 40 \"XL\" 50 \"L\"\n                90 \"XC\" 100 \"C\" 400 \"CD\" 500 \"D\" 900 \"CM\" 1000 \"M\"}]\n    (loop [num n base-nums (sort > (keys rn-map)) res-str \"\"]\n      (if (= num 0) res-str\n          (recur (rem num (first base-nums))\n                 (next base-nums)\n                 (str res-str\n                      (apply str (repeat (int (/ num (first base-nums)))\n                                  (rn-map (first base-nums))))))))))","problem":104,"user":"4dd0e8f7535da60f04a96e57"},{"problem":104,"code":"(fn [x]\n  (let [thousands (quot x 1000)\n        x (rem x 1000)\n        hundreds (quot x 100)\n        x (rem x 100)\n        tens (quot x 10)\n        ones (rem x 10)\n        show-digit (fn [d one & [five ten]]\n                     (clojure.string/join\n                      (cond\n                       (= 9 d) `[~one ~ten]\n                       (>= d 5) `[~five ~@(repeat (- d 5) one)]\n                       (= 4 d) `[~one ~five]\n                       :else (repeat d one))))]\n    (str (show-digit thousands \"M\")\n         (show-digit hundreds \"C\" \"D\" \"M\")\n         (show-digit tens \"X\" \"L\" \"C\")\n         (show-digit ones \"I\" \"V\" \"X\"))))","user":"4ff24a1ae4b0678c553fc337"},{"problem":104,"code":"(fn [num]\r\n  (let [\r\n      roman-digit (fn [digit [one five ten]]\r\n        (if (< digit 4) (clojure.string/join\r\n          (repeat digit one))\r\n        (if (= digit 4) (str one five)\r\n        (if (= digit 5) five\r\n        (if (< digit 9) (str five (clojure.string/join\r\n          (repeat (- digit 5) one)))\r\n        (str one ten))))))\r\n      roman-numerals (fn roman-numerals [num letters]\r\n        (let [\r\n            head (mod num 10)\r\n            tail (int (/ num 10))]\r\n          (str\r\n            (if (zero? tail)\r\n              \"\"\r\n              (roman-numerals tail (nthrest letters 2)))\r\n            (roman-digit head (take 3 letters)))))]\r\n    (roman-numerals num [\"I\" \"V\" \"X\" \"L\" \"C\" \"D\" \"M\"])))","user":"555bd27ae4b0b056612e2244"},{"problem":104,"code":"(fn num2roman [n]\n  (let [denu (fn dee [num]\n               (if (< num 10) \n                 (list num)\n                 (cons (rem num 10) (dee (quot num 10)))))\n        num-roman (list {1 \"I\", 2 \"II\",3 \"III\",4 \"IV\",5 \"V\",6 \"VI\",7 \"VII\",8 \"VIII\",9 \"IX\"}\n                        {1 \"X\", 2 \"XX\",3 \"XXX\",4 \"XL\",5 \"L\",6 \"LX\",7 \"LXX\",8 \"LXXX\",9 \"XC\"} \n                        {1 \"C\", 2 \"CC\",3 \"CCC\",4 \"CD\",5 \"D\",6 \"DC\",7 \"DCC\",8 \"DCCC\",9 \"CM\"} \n                        {1 \"M\", 2 \"MM\",3 \"MMM\"})]\n    (apply str (reverse (map #(%2 %1) (denu n) num-roman)))))","user":"5243e37ae4b076204b44fae3"},{"problem":104,"code":"(fn [k]\n    (apply str\n           [(get\n              {\n               1 \"M\",\n               2 \"MM\",\n               3 \"MMM\",\n               4 \"MMMM\"\n               }\n              (quot k 1000))\n            (get\n              {\n               1 \"C\",\n               2 \"CC\",\n               3 \"CCC\",\n               4 \"CD\",\n               5 \"D\",\n               6 \"DC\",\n               7 \"DCC\",\n               8 \"DCCC\",\n               9 \"CM\"\n               }\n              (quot (- k (* (quot k 1000) 1000)) 100))\n            (get\n              {\n               1 \"X\",\n               2 \"XX\",\n               3 \"XXX\",\n               4 \"XL\",\n               5 \"L\",\n               6 \"LX\",\n               7 \"LXX\",\n               8 \"LXXX\",\n               9 \"XC\"\n               }\n              (quot (- k (* (quot k 100) 100)) 10))\n\n            (get {\n                  1 \"I\",\n                  2 \"I\",\n                  3 \"I\",\n                  4 \"IV\",\n                  5 \"V\",\n                  6 \"VI\",\n                  7 \"VII\",\n                  8 \"VIII\",\n                  9 \"IX\"\n                  } (- k (* (quot k 10) 10)))\n            ]\n           )\n    )","user":"55d7312ee4b0e31453f64a9f"},{"problem":104,"code":"(fn to-roman [n]\n  (let [thousands [\"\" \"M\" \"MM\" \"MMM\" \"MMMM\"]\n        hundreds [\"\" \"C\" \"CC\" \"CCC\" \"CD\" \"D\" \"DC\" \"DCC\" \"DCCC\" \"CM\"]\n        tens [\"\" \"X\" \"XX\" \"XXX\" \"XL\" \"L\" \"LX\" \"LXX\" \"LXXX\" \"XC\"]\n        units [\"\" \"I\" \"II\" \"III\" \"IV\" \"V\" \"VI\" \"VII\" \"VIII\" \"IX\"]\n        positions [units tens hundreds thousands]\n        char-to-digit (zipmap (seq \"0123456789\") (range 10))\n        digits (map char-to-digit (seq (str n)))\n        position-digits (map-indexed vector (reverse digits))\n        chars (map (fn [[pos val]] ((positions pos) val)) position-digits)]\n    (apply str (reverse chars))))","user":"549dfe40e4b0f3d1d8e70f9a"},{"problem":104,"code":";; http://www.4clojure.com/problem/104\n(fn dec-to-roman\n  [dec-num]\n  (let [romans [[1000 \"M\"] [900 \"CM\"] [500 \"D\"] [100 \"C\"] [90 \"XC\"] \n                [50 \"L\"] [40 \"XL\"] [10 \"X\"] \n                [9 \"IX\"] [5 \"V\"] [4 \"IV\"] [1 \"I\"]]]\n    (loop [roman-list romans\n           num dec-num\n           out '()]\n      (if (empty? roman-list)\n        (apply str out)\n        (let [first-item (first roman-list)\n              rest-items (rest roman-list)\n              roman-num (first first-item)\n              roman-letters (second first-item)\n              item-count (quot num roman-num)\n              rest-num (rem num roman-num)\n              new-items (repeat item-count roman-letters)]\n          (recur rest-items rest-num (concat out new-items)))))))","user":"5c92105ce4b048ec896c59f7"},{"code":"(let [roman-digits\n      (sorted-map-by >\n       1000 \\M, 900 \"CM\"\n        500 \\D, 400 \"CD\"\n        100 \\C,  90 \"XC\"\n         50 \\L,  40 \"XL\"\n         10 \\X,   9 \"IX\"\n          5 \\V,   4 \"IV\"\n          1 \\I)]\n  \n  (fn ->roman [n]\n    (loop [r \"\", n n]\n      (if (zero? n) r\n        (let [pair\n              (->> roman-digits\n                   (drop-while\n                    (comp (partial < n)\n                          first))\n                   first)]\n          \n          (recur (str r (val pair))\n                 (- n (key pair))))))))","problem":104,"user":"532ab0bde4b09d4e7a9b5527"},{"code":"(fn [roman]\n(apply str \n  (let [roman (map (fn [d] (- (int d) 48)) (str roman)) \n        i \"IXCM\" \n        v \"VLD\" \n        x \"XCM\"\n        ms  [nil [i]     [i i]     [i i i]\n             [i v]   [v]       [v i]\n             [v i i] [v i i i] [i x]]\n        powers (range (dec (count roman)) -1 -1)]\n        (mapcat \n          (fn [power digit]\n             (map \n               #((vec %) power) \n               (ms digit))) \n            powers \n            roman))))","problem":104,"user":"4daa374930acd6ed13482a68"},{"problem":104,"code":"(fn [n]\n  (let [roman {1    \"I\"\n               5    \"V\"\n               10   \"X\"\n               50   \"L\"\n               100  \"C\"\n               500  \"D\"\n               1000 \"M\"}\n        rks (sort (keys roman))]\n    (loop [n n\n           d 1\n           r \"\"]\n      (cond\n        (= 0 n) r\n        (= d 1000) (str (clojure.string/join (repeat n (roman 1000))) r)\n        :default (recur (quot n 10)\n               (* 10 d)\n               (let [i (rem n 10)\n                     one (roman d)\n                     five (roman (quot (* d 10) 2))\n                     ten (roman (* d 10))]\n                 (cond\n                   (= 0 i) r\n                   (< i 4) (str (clojure.string/join (repeat i one)) r)\n                   (= 4 i) (str one five r)\n                   (= 5 i) (str five r)\n                   (= i 9) (str one ten r)\n                   :default (str five (clojure.string/join (repeat (- i 5) one)) r))))))))","user":"58bb218be4b0888cdc949cf4"},{"problem":104,"code":"(fn [v] (let [\n               lookup {\n                       1 \"I\"\n                       4 \"IV\"\n                       5 \"V\"\n                       9 \"IX\"\n                       10 \"X\"\n                       40 \"XL\"\n                       50 \"L\"\n                       90 \"XC\"\n                       100 \"C\"\n                       500 \"D\"\n                       900 \"CM\"\n                       1000 \"M\"\n                       }\n               vals (into [] (reverse (sort (keys lookup))) )\n               ]\n\n           (loop [\n                  remainder v\n                  s []\n                  ]\n             (let [\n                 units (first (filter #(>= remainder %1) vals ))\n                 ]\n             (if (= 0 remainder)\n               (apply str s)\n               (recur (- remainder units) (conj s (get lookup units))))\n             ))))","user":"58a9e872e4b01a0c0b232973"},{"code":"#(get {1 \"I\", \n       30 \"XXX\", \n       4 \"IV\", \n       140  \"CXL\",\n       827 \"DCCCXXVII\",\n       3999 \"MMMCMXCIX\",\n       48 \"XLVIII\"} %)","problem":104,"user":"4ee82223535d93acb0a66877"},{"code":"(fn [num]\n  (letfn [(k [n i v x]\n             (cond (= n 0) \"\",\n                   (= n 9) (str i x),\n                   (= n 4) (str i v),\n                   (> n 5) (apply str v (repeat (- n 5) i))\n                   :else   (apply str (repeat n i))))]\n   (apply str \n    (concat (k (quot num 1000) \\M \\_ \\_)\n            (k (quot (mod num 1000) 100) \\C \\D \\M)\n            (k (quot (mod num 100) 10) \\X \\L \\C)\n            (k (mod num 10) \\I \\V \\X)))))","problem":104,"user":"4f62b29ce4b0defedf855fd9"},{"code":"(fn roman-number [n]\n\n  (let [\n\n        digits \n          (fn digits [x] \n            (map #(Integer/parseInt (str %)) (reverse (str x))))\n\n        romans \n          [{0 \"\"  1 \"I\"  2 \"II\"  3 \"III\"  4 \"IV\"  5 \"V\"  6 \"VI\"  7 \"VII\"  8 \"VIII\"  9 \"IX\"}\n           {0 \"\"  1 \"X\"  2 \"XX\"  3 \"XXX\"  4 \"XL\"  5 \"L\"  6 \"LX\"  7 \"LXX\"  8 \"LXXX\"  9 \"XC\"}\n           {0 \"\"  1 \"C\"  2 \"CC\"  3 \"CCC\"  4 \"CD\"  5 \"D\"  6 \"DC\"  7 \"DCC\"  8 \"DCCC\"  9 \"CM\"}\n           {0 \"\"  1 \"M\"  2 \"MM\"  3 \"MMM\"}]]\n    \n    (apply str (reverse (map #(%1 %2) romans (digits n))))))","problem":104,"user":"4e7263a1535d5021c1a8965f"},{"code":"(fn roman-numeral [n]\n  (let [nums (hash-map 1000 \"M\", 900 \"CM\", 500 \"D\", 400 \"CD\", 100 \"C\",\n                            90 \"XC\", 50 \"L\", 40 \"XL\", 10 \"X\", 9 \"IX\",\n                            5 \"V\", 4 \"IV\", 1 \"I\")]\n    ((fn rn [x acc]\n       (if (zero? x)\n         acc\n         (let [highest-match (apply max (filter #(>= x %) (keys nums)))]\n           (rn (- x highest-match) (str acc (nums highest-match))))))\n     n \"\")))","problem":104,"user":"5175616ae4b0dea9bbfba576"},{"code":"#(reduce str\n           (map {1    \"I\"   , 4   \"IV\"  , 7   \"VII\",\n                 8    \"VIII\", 9   \"IX\"  , 20  \"XX\" ,\n                 30   \"XXX\" , 40  \"XL\"  , 90  \"XC\" ,\n                 100  \"C\"   , 800 \"DCCC\", 900 \"CM\" ,\n                 3000 \"MMM\"}\n                (loop [c % d 10 o []]\n                  (if (zero? c) o\n                      (let [r (rem c d)]\n                        (recur (- c r) (* 10 d) (cons r o)))))))","problem":104,"user":"4ee88bfb535d93acb0a66881"},{"code":"(fn [n]\n  (let [m [[1000 \"M\"] [900 \"CM\"] [500 \"D\"] [400 \"CD\"]\n           [100 \"C\"] [90 \"XC\"] [50 \"L\"] [40 \"XL\"]\n           [10 \"X\"] [9 \"IX\"] [5 \"V\"] [4 \"IV\"] [1 \"I\"]]\n        f (fn f [n [[x s] & t :as m]]\n            (cond (= n 0) \"\"\n                  (< n x) (f n t)\n                  :else (str s (f (- n x) m))))]\n    (f n m)))","problem":104,"user":"522b922ee4b0d34ee08e71c3"},{"code":"(fn [n]\n  (let [\n      fun (fn [val x v i]\n        (cond\n          (= 0 val) \"\"\n          (= 1 val) i\n          (= 2 val) (str i i)\n          (= 3 val) (str i i i)\n          (= 4 val) (str i v)\n          (= 5 val) v\n          (= 6 val) (str v i)\n          (= 7 val) (str v i i)\n          (= 8 val) (str v i i i)\n          (= 9 val) (str i x)))]\n    (str\n      (fun (quot n 1000) \"?\" \"?\" \"M\")\n      (fun (quot (mod n 1000) 100) \"M\" \"D\" \"C\")\n      (fun (quot (mod n 100) 10) \"C\" \"L\" \"X\")\n      (fun (mod n 10) \"X\" \"V\" \"I\"))))","problem":104,"user":"4fb1325de4b081705acca276"},{"problem":104,"code":"(fn [s]\n  (let [roman-numerals [\"M\" \"CM\" \"D\" \"CD\" \"C\" \"XC\" \"L\" \"XL\" \"X\" \"IX\" \"V\" \"IV\" \"I\"]\n        roman-shape [1000 900 500 400 100 90 50 40 10 9 5 4 1]]\n        (letfn [(digits-of [[shape-first & shape-rest] n]\n                          (when-not (nil? shape-first)\n                            (cons\n                             (quot n shape-first)\n                             (digits-of shape-rest (mod n shape-first)))))]\n          (let [digits (vec (digits-of roman-shape s))]\n            (apply str (mapcat #(take %1 (repeat %2)) digits roman-numerals))))))","user":"4fc8c8d8e4b0ee37620e183b"},{"problem":104,"code":"(fn n-to-roman [n]\n  (let [roman (sorted-map-by >\n                             1000 \"M\", 900 \"CM\", 500 \"D\", 400 \"CD\",\n                             100 \"C\", 90 \"XC\", 50 \"L\", 40 \"XL\",\n                             10 \"X\", 9 \"IX\", 5 \"V\", 4 \"IV\",\n                             1 \"I\")] \n    (loop [x n\n           s \"\"]\n      (if (zero? x)\n        s\n        (let [[k v] (first (filter #(<= (key %) x) roman))]\n          (recur (- x k) (str s v)))))))","user":"5ec3a13ae4b08d0ec38692b9"},{"problem":104,"code":"(fn [n]\n  (letfn [(create-roman [n string]\n                        (cond \n                         (>= n 1000) (recur (- n 1000) (str string \"M\"))\n                         (>= n 900) (recur (- n 900) (str string \"CM\"))\n                         (>= n 500) (recur (- n 500) (str string \"D\"))\n                         (>= n 400) (recur (- n 400) (str string \"CD\"))\n                         (>= n 100) (recur (- n 100) (str string \"C\"))\n                         (>= n 90)  (recur (- n 90)  (str string \"XC\"))\n                         (>= n 50)  (recur (- n 50)  (str string \"L\"))\n                         (>= n 40)  (recur (- n 40)  (str string \"XL\"))\n                         (>= n 10)  (recur (- n 10)  (str string \"X\"))\n                         (>= n 9)   (recur (- n 9)   (str string \"IX\"))\n                         (>= n 5)   (recur (- n 5)   (str string \"V\"))\n                         (>= n 4)   (recur (- n 4)   (str string \"IV\"))\n                         (>= n 1)   (recur (- n 1)   (str string \"I\"))\n                         :else string))]\n    (create-roman n \"\")))","user":"5622af0fe4b03f08ee9a922b"},{"code":"(fn romanize [n]\n  (let [\n         numerals (array-map\n                    1000 \"M\"\n                    900 \"CM\"\n                    500 \"D\"\n                    400 \"CD\"\n                    100 \"C\"\n                     90 \"XC\"\n                     50 \"L\"\n                     40 \"XL\"\n                     10 \"X\"\n                      9 \"IX\"\n                      5 \"V\"\n                      4 \"IV\"\n                      1 \"I\")\n         num (some #(when (>= n %) %) (keys numerals))\n         part (numerals num)\n         n' (- n num)\n         ]\n    (if (> n' 0) (str part (romanize n')) part)\n    ))","problem":104,"user":"53307da1e4b019098a6f8b5e"},{"problem":104,"code":"(fn [n]\n  (let [dec->rom (fn [digit [low mid high]]\n                   (case digit\n                     9 (str low high)\n                     8 (str mid low low low)\n                     7 (str mid low low)\n                     6 (str mid low)\n                     5 mid\n                     4 (str low mid)\n                     3 (str low low low)\n                     2 (str low low)\n                     1 low\n                     \"\"))]\n    (apply str\n     (loop [n n\n            rom-triples '([\\I \\V \\X] [\\X \\L \\C] [\\C \\D \\M] [\\M \\* \\*])\n            part-res ()]\n       (if (= n 0)\n         part-res\n         (let [digit (rem n 10)\n               n-rem (quot n 10)]\n           (recur n-rem (rest rom-triples) (cons (dec->rom digit (first rom-triples)) part-res))))))))","user":"5ec6de19e4b08d0ec38692da"},{"code":"(fn [n]\n  (let [key {1    \"I\",   4 \"IV\",   5 \"V\",   9 \"IX\",\n             10   \"X\",  40 \"XL\",  50 \"L\",  90 \"XC\",\n             100  \"C\", 400 \"CD\", 500 \"D\", 900 \"CM\",\n             1000 \"M\"}\n        vals (keys key)]\n    (letfn [(next-component [n]\n              (apply max (filter #(>= n %) vals)))\n            (roman-components [n]\n              (if (pos? n)\n                (let [c (next-component n)]\n                  (cons c (lazy-seq (roman-components (- n c)))))))]\n      (clojure.string/join (map key (roman-components n))))))","problem":104,"user":"4e80aa10535db62dc21a62b1"},{"problem":104,"code":"(fn wr\n  [n]\n  (let [dm (into (sorted-map) {1 \"I\" 4 \"IV\" 5 \"V\" 9 \"IX\" 10 \"X\" 40 \"XL\" 50 \"L\" 90 \"XC\" 100 \"C\" 400 \"CD\" 500 \"D\" 900 \"CM\" 1000 \"M\"})]\n    (loop [r n s \"\"]\n      (if (= r 0)\n        (str s)\n        (let [d (last (take-while #(<= (key %) r) dm))]\n          (recur (- r (key d)) (str s (val d))))))))","user":"576df252e4b0979f8965156f"},{"problem":104,"code":"(let [nums [[\"M\" 1000]\n              [\"CM\" 900]\n              [\"D\"  500]\n              [\"CD\" 400]\n              [\"C\"  100]\n              [\"XC\"  90]\n              [\"L\"   50]\n              [\"XL\"  40]\n              [\"X\"   10]\n              [\"IX\"   9]\n              [\"V\"    5]\n              [\"IV\"   4]\n              [\"I\"    1]]]\n    (fn [n]\n      (loop [ans \"\"\n             n n\n             [[s v] & more :as all] nums]\n        (if (<= n 0)\n          ans\n          (if (>= n v)\n            (recur (str ans s)\n                   (- n v)\n                   all)\n            (recur ans\n                   n\n                   more))))))","user":"5531e445e4b09218d5f44f76"},{"problem":104,"code":"(fn [n]\n   (loop [coll []\n          remaining n\n          romvals [\"M\" 1000 \"CM\" 900 \"D\" 500 \"CD\" 400 \"C\" 100 \"XC\" 90 \"L\" 50 \"XL\" 40 \"X\" 10 \"IX\" 9 \"V\" 5 \"IV\" 4 \"I\" 1]]\n     (if (<= remaining 0)\n       (reduce str (flatten coll))\n       (recur (if (> (quot remaining (second romvals)) 0)\n                (conj coll (repeat (quot remaining (second romvals)) (first romvals)))\n                coll)\n              (if (> (quot remaining (second romvals)) 0)\n                (- remaining (* (second romvals) (quot remaining (second romvals))))\n                remaining)\n              (drop 2 romvals)))))","user":"5633bb9de4b0bfe05bf117b4"},{"problem":104,"code":"(fn [n]\n  (loop [n n, res \"\"]\n    (cond\n      (> (quot n 1000) 0)\n      (recur (- n 1000) (str res \"M\"))\n      (>= n 900) (recur (- n 900) (str res \"CM\"))\n      (>= n 800) (recur (- n 800) (str res \"DCCC\"))\n      (>= n 700) (recur (- n 700) (str res \"DCC\"))\n      (>= n 600) (recur (- n 600) (str res \"DC\"))\n      (>= n 500) (recur (- n 500) (str res \"D\"))\n      (>= n 400) (recur (- n 400) (str res \"CD\"))\n      (>= n 100) (recur (- n 100) (str res \"C\"))\n      (>= n 90) (recur (- n 90) (str res \"XC\"))\n      (>= n 80) (recur (- n 80) (str res \"XXC\"))\n      (>= n 70) (recur (- n 70) (str res \"LXX\"))\n      (>= n 60) (recur (- n 60) (str res \"LX\"))\n      (>= n 50) (recur (- n 50) (str res \"L\"))\n      (>= n 40) (recur (- n 40) (str res \"XL\"))\n      (>= n 30) (recur (- n 30) (str res \"XXX\"))\n      (>= n 20) (recur (- n 20) (str res \"XX\"))\n      (>= n 10) (recur (- n 10) (str res \"X\"))\n      (= n 9) (str res \"IX\")\n      (= n 8) (str res \"VIII\")\n      (= n 7) (str res \"VII\")\n      (= n 6) (str res \"VI\")\n      (= n 5) (str res \"V\")\n      (= n 4) (str res \"IV\")\n      (= n 3) (str res \"III\")\n      (= n 2) (str res \"II\")\n      (= n 1) (str res \"I\")\n      :else res)))","user":"54ca93abe4b057c6fda3a264"},{"code":"(fn R [i]\n  (let [romans (into (sorted-map-by >)\n                     {1000 \"M\"\n                      900  \"CM\"\n                      500  \"D\"\n                      400  \"CD\"\n                      100  \"C\"\n                      90   \"XC\"\n                      50   \"L\"\n                      40   \"XL\"\n                      10   \"X\"\n                      9    \"IX\"\n                      5    \"V\"\n                      4    \"IV\"\n                      1    \"I\"})\n        allchars (loop [remain i, charlist [], romans romans, ret []]\n                   (let [[n char] (first romans)\n                         x (quot remain n)\n                         nx-chars (concat charlist (repeat x char))]\n                     (if (seq (rest romans))\n                       (recur (- remain (* x n))\n                              nx-chars\n                              (rest romans)\n                              (concat ret nx-chars))\n                       nx-chars)))]\n    (apply str (concat allchars))))","problem":104,"user":"4ee26f01535d10e5ff6f5368"},{"code":"(fn to-roman [x]\n  (let [arm {1 \"I\", 5 \"V\", \n      10 \"X\", 50 \"L\", \n      100 \"C\", 500 \"D\", \n      1000 \"M\", \n      4 \"IV\", 9 \"IX\", \n      40 \"XL\", 90 \"XC\", \n      400 \"CD\", 900 \"CM\" },\n      armsk (sort (keys arm)),\n      fvic #(let [aval (find % %2)] (if (nil? aval) \"\" (val aval)))]\n      (loop [result \"\",n x]\n\t (let [ckfn (last (filter #(> n %) armsk)),\n      rvfn (fvic arm n),\n\trvfctn (fvic arm ckfn)]\n      (if (or (<= n 0) (contains? arm n))\n\t  (str result rvfn)\n\t  (recur (str result rvfctn) (- n ckfn)))))))","problem":104,"user":"4ec5d62c535d6d7199dd36ba"},{"problem":104,"code":"(fn [decimal]\n  (let [dec-map {1000 \"M\"\n                 900 \"CM\"\n                 500 \"D\"\n                 400 \"CD\"\n                 100 \"C\"\n                 90 \"XC\"\n                 50 \"L\"\n                 40 \"XL\"\n                 10 \"X\"\n                 9 \"IX\"\n                 5 \"V\"\n                 4 \"IV\"\n                 1 \"I\"}\n        dec-list [1000 900 500 400 100 90 50 40 10 9 5 4 1]]\n    (letfn [(find-first [n pred coll]\n              (if (pred (first coll))\n                (first coll)\n                (find-first n pred (rest coll))))\n            (calc-base [decimal] (find-first decimal #((complement <) decimal % ) dec-list))\n            (write-rom-num [decimal]\n              (if (= 0 decimal)\n                \"\"\n                (let [b (calc-base decimal)]\n                  (str (apply str (repeat (quot decimal b) (get dec-map b))) (write-rom-num (rem decimal b))))))]\n      (write-rom-num decimal))))","user":"5a9dbb32e4b0d174b936c7f3"},{"code":"(fn [n]\n       (let [m '[\"\" M MM MMM]\n             c '[\"\" C CC CCC CD D DC DCC DCCC CM]\n             x '[\"\" X XX XXX XL L LX LXX LXXX XC]\n             i '[\"\" I II III IV V VI VII VIII IX]]\n         (str\n           (nth m (mod (quot n 1000) 10))\n           (nth c (mod (quot n 100) 10))\n           (nth x (mod (quot n 10) 10))\n           (nth i (mod n 10)))))","problem":104,"user":"52a88c4de4b0c58976d9ac30"},{"code":"(fn to-roman [n]\n  (let [num {1000 \"M\", 900 \"CM\", 500 \"D\", 400 \"CD\", 100 \"C\", 90 \"XC\",\n              50 \"L\", 40 \"XL\", 10 \"X\", 9 \"IX\", 5 \"V\", 4 \"IV\", 1 \"I\"}]\n    (second (reduce\n      (fn [[i rom], k]\n        (println rom)\n        [(rem i k) (apply str rom (repeat (quot i k) (num k)))])\n      [n \"\"] (sort > (keys num))))))","problem":104,"user":"5084c43be4b0fb8f40674bfa"},{"problem":104,"code":"(fn roman [n]\n    (let [nums [[1000 \"M\"] [900 \"CM\"] [500 \"D\"] [400 \"CD\"]\n                [100 \"C\"] [90 \"XC\"] [50 \"L\"] [40 \"XL\"]\n                [10 \"X\"] [9 \"IX\"] [5 \"V\"] [4 \"IV\"] [1 \"I\"]]]\n      (loop [x n, result \"\"]\n        (if (zero? x) result\n            (let [[a b] (some #(if (>= x (first %)) %) nums)]\n              (recur (- x a) (str result b)))))))","user":"5935b010e4b04f87174def55"},{"code":"(let [values [[1000 \"M\"] [900 \"CM\"] [500 \"D\"] [400 \"CD\"] [100 \"C\"] [90 \"XC\"]\n              [50 \"L\"] [40 \"XL\"] [10 \"X\"] [9 \"IX\"] [5 \"V\"] [4 \"IV\"] [1 \"I\"]]]\n  (fn convert [n] (if (= n 0) \"\"\n                    (let [[v s] (first (drop-while #(> (first %) n) values))]\n                      (str s (convert (- n v)))))))","problem":104,"user":"532347dde4b09d4e7a9b54cc"},{"code":"(fn int2r [n]\n  (cond (> n 1999) (clojure.string/join (concat (repeat (quot n 1000) \\M) (int2r (rem n 1000))))\n        (> n 999) (clojure.string/join (concat \\M (int2r (rem n 1000))))\n        (> n 899) (clojure.string/join (concat \"CM\" (int2r (rem n 900))))\n        (> n 499) (clojure.string/join (concat \"D\" (int2r (rem n 500))))\n        (> n 399) (clojure.string/join (concat \"CD\" (int2r (rem n 900))))\n        (> n 99) (clojure.string/join (concat (repeat (quot n 100) \\C) (int2r (rem n 100))))\n        (> n 89) (clojure.string/join (concat \"XC\" (int2r (rem n 90))))\n        (> n 49) (clojure.string/join (concat \"L\" (int2r (rem n 50))))\n        (> n 39) (clojure.string/join (concat \"XL\" (int2r (rem n 40))))\n        (> n 9) (clojure.string/join (concat (repeat (quot n 10) \\X) (int2r (rem n 10))))\n        (= n 9) \"IX\"\n        (> n 4) (clojure.string/join (concat \"V\" (int2r (rem n 5))))\n        (= n 4) \"IV\"\n        (> n 0) (clojure.string/join (repeat n \"I\"))\n        :else \"\"))","problem":104,"user":"50733b31e4b0e3170b5a869a"},{"problem":104,"code":"(fn convert [n]\n  (letfn [(value [n nVal rStr acc]\n            (if (>= n nVal)\n              (recur (- n nVal) nVal rStr (str acc rStr))\n              [n acc]))]\n    (let [mapper [[1000 \"M\"] [900 \"CM\"] [500 \"D\"] [400 \"CD\"] [100 \"C\"]                                                              \n                  [90 \"XC\"]  [50 \"L\"]   [40 \"XL\"] [10 \"X\"]\n                  [9 \"IX\"]   [5 \"V\"]    [4 \"IV\"]  [1 \"I\"]]]\n      (second (reduce (fn [result [val roman]]\n                        (let [remainder (first result)\n                              resStr (second result)\n                              [newRem newRes] (value remainder val roman \"\")]\n                          [newRem (str resStr newRes)]))\n                      [n \"\"]\n                      mapper)))))","user":"54f64e99e4b0f2f3c5226ea4"},{"problem":104,"code":"(fn [num]\n  (let [m [[1000 \"M\"] [900 \"CM\"] [500 \"D\"] [400 \"CD\"] [100 \"C\"]\n           [90 \"XC\"] [50 \"L\"] [40 \"XL\"] [10 \"X\"] [9 \"IX\"]\n           [5 \"V\"] [4 \"IV\"] [1 \"I\"]]]\n    (loop [n num s \"\" index 0]\n      (if (> index 12) s\n          (let [[k v] (m index)\n                t (quot n k)\n                r (- n (* t k))\n                s2 (apply str (repeat t v))]\n            (recur r (str s s2) (inc index)))))))","user":"501d34f6e4b066e56b9d0b1e"},{"code":"(fn roman- [n]\n  ^{:doc \"Given an integer smaller than 4000, return the corresponding                                                                                                                                             \n  roman numeral in uppercase, adhering to the subtractive principle.\"}\n  (loop [n n\n         acc \"\"]\n    (cond\n     (>= n 1000) (recur (- n 1000) (str acc \"M\"))\n     (>= n 900) (recur (- n 900) (str acc \"CM\"))\n     (>= n 500) (recur (- n 500) (str acc \"D\"))\n     (>= n 400) (recur (- n 400) (str acc \"CD\"))\n     (>= n 100) (recur (- n 100) (str acc \"C\"))\n     (>= n 90) (recur (- n 90) (str acc \"XC\"))\n     (>= n 50) (recur (- n 50) (str acc \"L\"))\n     (>= n 40) (recur (- n 40) (str acc \"XL\"))\n     (>= n 10) (recur (- n 10) (str acc \"X\"))\n     (>= n 9) (recur (- n 9) (str acc \"IX\"))\n     (>= n 5) (recur (- n 5) (str acc \"V\"))\n     (>= n 4) (recur (- n 4) (str acc \"IV\"))\n     (>= n 1) (recur (- n 1) (str acc \"I\"))\n     :else acc)))","problem":104,"user":"4e5eb843535d8a8b8723a2d4"},{"problem":104,"code":"(fn [an]\n   (let [f10 (fn d [n b] (if (< n b) [n] (conj (d (quot n b) b) (mod n b))))\n         v10 (reverse (f10 an 10))\n         m {1 \\I 10 \\X 100 \\C 1000 \\M}\n         un (apply str (reverse (map #(apply str (repeat %1 %2)) v10 \"IXCM\"))) \n         rl (array-map \n             \"CCCCCCCCC\" \"CM\"\n             \"CCCCC\" \"D\"\n             \"XXXXXXXXX\" \"XC\"\n             \"XXXXX\" \"L\"\n             \"XXXX\" \"XL\"\n             \"IIIIIIIII\" \"IX\"\n             \"IIIII\" \"V\"\n             \"IIII\" \"IV\"\n             )\n         re  (reduce (fn[a x] \n                      (clojure.string/replace a x (fn [[k v]] (get rl v v))))\n                    un\n                    (map #(re-pattern (str \"(\" % \")\")) (keys rl)))\n         ]\n     re\n     ))","user":"533c2605e4b0e30313ee6cd7"},{"problem":104,"code":"#(let [t [\"\" \"M\" \"MM\" \"MMM\" \"MMMM\"]\n       h [\"\" \"C\" \"CC\" \"CCC\" \"CD\" \"D\" \"DC\" \"DCC\" \"DCCC\" \"CM\"]\n       d [\"\" \"X\" \"XX\" \"XXX\" \"XL\" \"L\" \"LX\" \"LXX\" \"LXXX\" \"XC\"]\n       u [\"\" \"I\" \"II\" \"III\" \"IV\" \"V\" \"VI\" \"VII\" \"VIII\" \"IX\"]]\n   (str\n     (-> % (quot 1000) t)\n     (-> % (mod 1000) (quot 100) h)\n     (-> % (mod 100) (quot 10) d)\n     (-> % (mod 10) u)))","user":"5c3796b3e4b0d62ef62d9f77"},{"problem":104,"code":"(fn to-roman [x]\n  (let [R [[1000 \"M\"] [500 \"D\"] [100 \"C\"] [50 \"L\"] [10 \"X\"] [5 \"V\"] [1 \"I\"]]]\n  (loop [x x r R s \"\"]\n  \t(let [[[fv fl] [sv sl] [tv tl]] r]\n    (cond\n     (zero? x) s\n     (>= x fv) (recur (- x fv) r (str s fl))\n     (and (> fv (* 2 sv)) (>= x (- fv sv))) (recur (+ x sv) r (str s sl))\n     (and tv (>= x (- fv tv))) (recur (+ x tv) r (str s tl))\n     :else (recur x (rest r) s)\n     )))))","user":"55a74d46e4b09e57187da2a3"},{"code":"(fn roman [n]\n  (condp <= n \n     1000 (str \"M\" (roman (- n 1000)))\n      900 (str \"CM\" (roman (- n 900)))\n      500 (str \"D\" (roman (- n 500)))\n      400 (str \"CD\" (roman (- n 400)))\n      100 (str \"C\" (roman (- n 100)))\n       90 (str \"XC\" (roman (- n 90)))\n       50 (str \"L\" (roman (- n 50)))\n       40 (str \"XL\" (roman (- n 40)))\n       10 (str \"X\" (roman (- n 10)))\n        9 (str \"IX\" (roman (- n 9)))\n        5 (str \"V\" (roman (- n 5)))\n        4 (str \"IV\" (roman (- n 4)))\n        1 (str \"I\" (roman (- n 1)))\n\t\t\"\"\n\t ))","problem":104,"user":"523a9fc9e4b081681ca7adca"},{"code":"(let [roman {1000 \"M\"\n             900 \"CM\"\n             500 \"D\"\n             400 \"CD\"\n             100 \"C\"\n             90 \"XC\"\n             50 \"L\"\n             40 \"XL\"\n             10 \"X\"\n             9 \"IX\"\n             5 \"V\"\n             4 \"IV\"\n             1 \"I\"}\n      amounts (sort > (keys roman))]\n  (fn [num] (loop [output []\n                   n num]\n              (if-let [a (first (filter #(<= % n) amounts))]\n                (recur (conj output (roman a))\n                       (- n a))\n                (apply str output)))))","problem":104,"user":"4ebcb8ff535dfed6da9c6d8a"},{"problem":104,"code":"(fn romans [x]\n  (cond\n   (>= x 1000) (clojure.string/join [\"M\" (romans (- x 1000))])\n   (>= x 900) (clojure.string/join [\"CM\" (romans (- x 900))])\n   (>= x 500) (clojure.string/join [\"D\" (romans (- x 500))])\n   (>= x 400) (clojure.string/join [\"CD\" (romans (- x 400))])\n   (>= x 100) (clojure.string/join [\"C\" (romans (- x 100))])\n   (>= x 90) (clojure.string/join [\"XC\" (romans (- x 90))])\n   (>= x 50) (clojure.string/join [\"L\" (romans (- x 50))])\n   (>= x 40) (clojure.string/join [\"XL\" (romans (- x 40))])\n   (>= x 10) (clojure.string/join [\"X\" (romans (- x 10))])\n   (>= x 9) (clojure.string/join [\"IX\" (romans (- x 9))])\n   (>= x 5) (clojure.string/join [\"V\" (romans (- x 5))])\n   (>= x 4) (clojure.string/join [\"IV\" (romans (- x 4))])\n   (>= x 1) (clojure.string/join [\"I\" (romans (- x 1))])\n   :else \"\"))","user":"586b6a0ae4b01531a375e957"},{"code":"(fn f [n]\n  (let [m (sorted-map-by > 1 \"I\" 4 \"IV\" 5 \"V\" 9 \"IX\" 10 \"X\" 40 \"XL\" 50 \"L\"\n                           90 \"XC\" 100 \"C\" 400 \"CD\" 500 \"D\" 900 \"CM\" 1000 \"M\")\n        p (first (drop-while #(< n (first %)) m))]\n    (if (empty? p)\n        \"\"\n        (str (second p) (f (- n (first p)))))))","problem":104,"user":"5054c7e1e4b0b1b9d1860eb2"},{"problem":104,"code":"(fn my-fn [n]\n  (let [digits (->> (str n)\n                    reverse\n                    (map-indexed #(vector %1 (Character/digit %2 10)))\n                    reverse)\n\n        conversions [[\"I\" \"V\"] [\"X\" \"L\"] [\"C\" \"D\"] [\"M\"]]\n\n        convert-digit\n        (fn [[exponent n]]\n          (let [[ones-character fives-character] (get conversions exponent)]\n            (cond\n              (<= 0 n 3) (apply str (repeat n ones-character))\n              (<= 4 n 4) (str ones-character fives-character)\n              (= 5 n) fives-character\n              (<= 6 n 8) (apply str fives-character (repeat (- n 5) ones-character))\n              :else (str ones-character (first (get conversions (inc exponent)))))))]\n    \n    (apply str (map convert-digit digits))))","user":"5c896f46e4b048ec896c5940"},{"problem":104,"code":"(fn [x]\n  (loop [out \"\"\n         n x]\n    (if (zero? n)\n      out\n      (let [[sub chrs] (first (filter #(<= (first %) n)\n                                      [[1000 \"M\"], [900 \"CM\"], [500 \"D\"],\n                                       [400 \"CD\"], [100 \"C\"], [90 \"XC\"],\n                                       [50 \"L\"], [40 \"XL\"], [10 \"X\"],\n                                       [9 \"IX\"], [5 \"V\"], [4 \"IV\"], [1 \"I\"]]))]\n        (recur (str out chrs) (- n sub))))))","user":"5b64370ae4b0c6492753e73c"},{"problem":104,"code":"#(apply str (\n     (fn f [n [[k v] & r]]\n       (if (nil? k) nil\n                    (concat (repeat (Math/floor (/ n v)) k) (f (mod n v) r)))\n       )\n     % [[\"M\" 1000]\n        [\"CM\" 900]\n        [\"D\" 500]\n        [\"CD\" 400]\n        [\"C\" 100]\n        [\"M\" 100]\n        [\"XC\" 90]\n        [\"L\" 50]\n        [\"XL\" 40]\n        [\"X\" 10]\n        [\"IX\" 9]\n        [\"V\" 5]\n        [\"IV\" 4]\n        [\"I\" 1]]\n     ))","user":"5921a080e4b09b4ee5954c77"},{"problem":104,"code":"(fn roman [n]\n  (let\n    [out-of-bound? (or (>= n 4000) (zero? n))\n     romseq [[1 \\I], [5 \\V], [10 \\X], [50 \\L], [100 \\C], [500 \\D], [1000 \\M]]\n     romdict (reduce (fn [m [k v]] (assoc m k v)) (sorted-map) romseq)\n\n     power-ten (fn [t] (apply * (repeat t 10)))\n     get-rom\n       (fn [t a]\n         (let [num (count (take-while (fn [[k v]] (< k a)) romseq))\n               fullnum (+ (* 2 (dec t)) num)]\n           (second (first (drop fullnum romseq)))))\n     t-romans\n       (fn [[t rs]]\n         (letfn [(abs [a] (if (neg? a) (- a) a))]\n           (vec (map (partial get-rom t) rs))))\n     base-ivx\n       (fn [a]\n         (let [bx 10\n               bv 5\n               bi 1\n               bset #{bi bv bx}\n               just? (if (bset a) true false)\n               lesser? (< a bv)\n               subt-bx? (= a (dec bx))\n               subt-bv? (= a (dec bv))\n               nsq (cond\n                     just? [(bset a)]\n                     lesser? (if subt-bv? [bi bv] (vec (repeat a bi)))\n                     subt-bx? [bi bx]\n                     :else (into [bv] (repeat (- a bv) bi)))]\n           nsq))\n     dgtz-mcxi\n       (fn [n]\n         (loop [acc (list) work n base 1]\n           (if (zero? work)\n             (vec acc)\n             (let [rst (quot work 10)\n                   lss (rem work 10)\n                   newacc (conj acc [base lss])]\n               (recur newacc rst (inc base))))))\n\n     tns (dgtz-mcxi n)\n     troms (map (fn [[t a]] [t (base-ivx a)]) tns)\n     vc (reduce into [] (map t-romans troms))]\n   (clojure.string/join vc)))","user":"57f9011ee4b0d3187e900935"},{"problem":104,"code":"(fn romanize [n]\n  (loop [n n\n         acc \"\"]\n    (if (zero? n)\n      acc\n      (cond\n        (>= n 1000) (recur (- n 1000) (str acc \"M\"))\n        (>= n 900) (recur (- n 900) (str acc \"CM\"))\n        (>= n 500) (recur (- n 500) (str acc \"D\"))\n        (>= n 400) (recur (- n 400) (str acc \"CD\"))\n        (>= n 100) (recur (- n 100) (str acc \"C\"))\n        (>= n 90) (recur (- n 90) (str acc \"XC\"))\n        (>= n 50) (recur (- n 50) (str acc \"L\"))\n        (>= n 40) (recur (- n 40) (str acc \"XL\"))\n        (>= n 10) (recur (- n 10) (str acc \"X\"))\n        (>= n 9) (recur (- n 9) (str acc \"IX\"))\n        (>= n 5) (recur (- n 5) (str acc \"V\"))\n        (>= n 4) (recur (- n 4) (str acc \"IV\"))\n        (>= n 1) (recur (- n 1) (str acc \"I\"))))))","user":"53528cd3e4b084c2834f4af2"},{"problem":104,"code":"(fn [d]\n  (let [m {1 \"I\" , 4 \"IV\", 5 \"V\", 9 \"IX\", 10 \"X\", 40 \"XL\", 50 \"L\", 90 \"XC\", 100 \"C\", 400 \"CD\", 500 \"D\", 900 \"CM\", 1000 \"M\"}]\n    ((fn f [n]\n    (if (zero? n)\n      \"\"\n      (loop [x n]\n        (if (contains? m x)\n          (str (get m x) (f (- n x)))\n          (recur (dec x)))))) d)))","user":"551c66dae4b07993ea3788de"},{"code":"(fn rom [n]\n    (let [my-div (fn [a b] (* (int (/ a b)) b))\n          num-I {1 \"I\", 2 \"II\", 3 \"III\", 4 \"IV\",\n                 5 \"V\", 6 \"VI\", 7 \"VII\", 8 \"VIII\", 9 \"IX\"  }\n          num-X  {10 \"X\", 20 \"XX\", 30 \"XXX\", 40 \"XL\",\n                  50 \"L\", 60 \"LX\", 70 \"LXX\", 80 \"LXXX\", 90 \"XC\"  }\n          num-C {100 \"C\", 200 \"CC\", 300 \"CCC\", 400 \"CD\",\n                 500 \"D\", 600 \"DC\", 700 \"DCC\", 800 \"DCCC\", 900 \"CM\"}\n          num-M {1000 \"M\", 2000 \"MM\", 3000 \"MMM\"}]\n               (cond (< n 10)    (num-I n)\n                     (< n 100)   (str (num-X (my-div n 10)) (rom (mod n 10)))\n                     (< n 1000)  (str (num-C (my-div n 100)) (rom (mod n 100)))\n                     (< n 4000)  (str (num-M (my-div n 1000)) (rom (mod n 1000)))\n                     (>= n 4000) \"??\"\n                     )))","problem":104,"user":"4dcc5aff535d5973398f9293"},{"code":"(fn z [n]  \n  (let [k [1 4 5 9 10 40 50 90 100 400 500 900 1000]\n        v [\"I\" \"IV\" \"V\" \"IX\" \"X\" \"XL\" \"L\" \"XC\" \"C\" \"CD\" \"D\" \"CM\" \"M\" ]\n        p (reduce \n            #(if (zero? (quot n %2))\n               %1 %2) k)\n        m (zipmap k v)\n        g #(get m %)]\n      (if\n        (g n) (g n)\n        (str (g p) \n                   (z (- n p))))))","problem":104,"user":"4ff4c9dae4b0678c553fc360"},{"code":"(fn [n]\r\n  (let [roman [[1000 \"M\"] [900 \"CM\"] [500 \"D\"]\r\n               [400 \"CD\"] [100 \"C\"] [90 \"XC\"]\r\n               [50 \"L\"] [40 \"XL\"] [10 \"X\"]\r\n               [9 \"IX\"] [5 \"V\"] [4 \"IV\"] [1 \"I\"]]]\r\n    (apply str (first (reduce (fn [[res x] [d s]]\r\n                                [(concat res (repeat (quot x d) s)) (rem x d)])\r\n                              [() n] roman)))))","problem":104,"user":"4f969214e4b0dcca54ed6cdd"},{"code":"(fn roman [number]\n  (if (zero? number)\n    \"\"\n    (let\n      [values (clojure.set/map-invert {\"M\" 1000, \"CM\" 900, \"D\" 500, \"CD\" 400, \"C\" 100, \"XC\" 90, \"L\" 50, \"XL\" 40, \"X\" 10, \"IX\" 9, \"V\" 5, \"IV\" 4, \"I\" 1})\n       found (apply max (filter #(<= % number) (keys values)))]\n      (str (values found) (roman (- number found))))))","problem":104,"user":"4f03641a535dcb61093f6a9b"},{"code":"(fn p104 [n]\n  (let [m {0 \"\", 1 \"I\", 2 \"II\", 3 \"III\", 4 \"IV\", 5 \"V\", 6 \"VI\", 7 \"VII\", 8 \"VIII\", 9 \"IX\", 10, \"X\",\n           20 \"XX\", 30 \"XXX\", 40 \"XL\", 50 \"L\", 60 \"LX\", 70 \"LXX\", 80 \"LXXX\", 90 \"XC\", 100 \"C\",\n           200 \"CC\", 300 \"CCC\", 400 \"CD\", 500 \"D\", 600 \"DC\", 700 \"DCC\", 800 \"DCCC\", 900 \"CM\", 1000 \"M\", 2000 \"MM\", 3000 \"MMM\"}\n        f (fn [x y] (* (quot x y) y))\n        thousands (get m (f n 1000))\n        h_ (mod n 1000)\n        hundreds (get m (f h_ 100))\n        t_ (mod h_ 100)\n        tens (get m (f t_ 10))\n        s_ (mod t_ 10)\n        singles (get m s_)]\n    (str thousands hundreds tens singles)))","problem":104,"user":"5125745ae4b05d10e3e395f9"},{"code":"(fn [x]\n  (letfn [(s [acc x fs]\n                  (if-let [[f & fs] fs]\n                    (recur (conj acc (quot x f)) (rem x f) fs)\n                    acc))]\n         (apply str (map\n                      (fn [a b] (apply str (repeat a b)))\n                      (s [] x [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1])\n                      [\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"]))))","problem":104,"user":"4e4ad154535dc968683fc4d1"},{"code":"#(let [t [\\I \\V\n          \\X \\L\n          \\C \\D\n          \\M]]\n  (loop [s (->> % str reverse (map str) (map read-string)) i 0 r ()]\n    (if-let [n (first s)]\n    (recur (next s) (inc i)\n           (cons \n            (cond (< 0 n 4) (repeat n (nth t (* 2 i)))\n            (= 4 n) [(nth t (* 2 i)) (nth t (inc (* 2 i)))]\n            (< 4 n 9) (cons (nth t (inc (* 2 i))) (repeat (- n 5) (nth t (* 2 i))))\n            (= 9 n) [(nth t (* 2 i)) (nth t (+ 2 (* 2 i)))]) r))\n      (->> r (apply concat) (apply str)))))","problem":104,"user":"4ef9c8f9535dced4c769f26b"},{"problem":104,"code":"#(let [rom-map (sorted-map-by >     1000  \"M\",\n     900 \"CM\",\n     500  \"D\",\n     400 \"CD\",\n     100  \"C\",\n      90 \"XC\",\n      50  \"L\",\n      40 \"XL\",\n      10  \"X\",\n       9 \"IX\",\n       5  \"V\",\n       4 \"IV\",\n       1  \"I\")]\n        ; conv = Object.keys(conversions).filter(lessThan(number)).last();\n      (loop [result \"\"\n             rst    %]\n           (if (<= rst 0)\n               result\n               (let [conv (->> (keys rom-map)\n                           (filter (partial >= rst) )\n                           (first))]\n                    (recur (str result (rom-map conv))\n                           (- rst conv))))))","user":"544e8369e4b0e39780006987"},{"problem":104,"code":"(fn roman [n]\n  (if (zero? n)\n    nil\n    (let [rs {1 \"I\" 5 \"V\" 10 \"X\" 50 \"L\" 100 \"C\" 500 \"D\" 1000 \"M\"\n              4 \"IV\" 9 \"IX\" 40 \"XL\" 90 \"XC\" 400 \"CD\" 900 \"CM\"}\n          k (apply max (filter #(<=  % n) (keys rs)))]      \n      (str (rs k) (roman (- n k))))))","user":"57d9bca1e4b0bd073c202405"},{"problem":104,"code":"(fn wnum [n]\n  (let [r (sorted-map-by > 1000 \"M\" 900 \"CM\" 500 \"D\" 400 \"CD\" 100 \"C\"\n                         90 \"XC\" 50 \"L\" 40 \"XL\" 10 \"X\" 9 \"IX\" 5 \"V\" 4 \"IV\" 1 \"I\")\n        m (some #(when (>= (- n %) 0) %) (keys r))]\n    (when-not (nil? m)\n      (str (r m) (wnum (- n m))))))","user":"56874171e4b0dcc4269f405c"},{"code":"(fn [n]\n  (let [rplm {\"DCCCC\" \"CM\", \"CCCC\" \"CD\", \"LXXXX\" \"XC\",\n              \"XXXX\" \"XL\", \"VIIII\" \"IX\", \"IIII\" \"IV\"}]\n    (->> n\n         str\n         reverse\n         (map #(- (int %) 48))\n         (map (fn [[l1 l5] d]\n                (apply str  (concat (repeat (quot d 5) l5)\n                                    (repeat (mod d 5) l1)))) \n              (partition 2 \"IVXLCDM \"))\n         (map #(or (rplm %) %))\n         reverse\n         (apply str))))","problem":104,"user":"519ef784e4b087743fad2198"},{"code":"(fn r [n]\n  (let [i [1000 900 500 400 100 90 50 40 10 9 5 4 1]\n        c [\\M \"CM\" \\D \"CD\" \\C \"XC\" \\L \"XL\" \\X \"IX\" \\V \"IV\" \\I]\n        m (zipmap i c)\n        v (first (drop-while #(< n %) i))]\n    (if v (str (m v) (r (- n v))))))","problem":104,"user":"4ddbdc1b535d02782fcbe9fd"},{"code":"(fn to-roman [n]\n    (if (= 0 n)\n      \"\"\n      (let [values\n            {\"I\" 1, \"V\" 5, \"X\" 10, \"L\" 50, \"C\" 100, \"D\" 500, \"M\" 1000\n             \"IV\"  4, \"IX\"\t9, \"XL\"\t40 \"XC\" 90 \"CD\"\t400 \"CM\"\t900}\n            possible (filter (fn [[k v]]\n                               (<= v n))\n                             values)\n            [numeral value] (reduce (fn [[k v] [k' v']]\n                                      (if (> v' v)\n                                        [k' v']\n                                        [k v]))\n                                    possible)\n            \n            ]\n        (str numeral (to-roman (- n value))))))","problem":104,"user":"4daea889edd6309eace4d15b"},{"code":"(fn f [n] (cond\n           (<= 0 (- n 1000)) (str \"M\" (f (- n 1000)))\n           (<= 0 (- n 900))  (str \"CM\" (f (- n 900)))\n           (<= 0 (- n 500))  (str \"D\" (f (- n 500)))\n           (<= 0 (- n 400))  (str \"CD\" (f (- n 400)))\n           (<= 0 (- n 100))  (str \"C\" (f (- n 100)))\n           (<= 0 (- n 90))   (str \"XC\" (f (- n 90)))\n           (<= 0 (- n 50))   (str \"L\" (f (- n 50)))\n           (<= 0 (- n 40))   (str \"XL\"(f (- n 40)))\n           (<= 0 (- n 10))   (str \"X\" (f (- n 10)))\n           (<= 0 (- n 9))    (str \"IX\" (f (- n 9)))\n           (<= 0 (- n 5))    (str \"V\" (f (- n 5)))\n           (<= 0 (- n 4))    (str \"IV\" (f (- n 4)))\n           (<= 0 (- n 1))    (str \"I\" (f (- n 1)))))","problem":104,"user":"4ee9ddb8535d93acb0a66896"},{"problem":104,"code":"(fn\n  [number]\n  (let [rdigits (reverse (sorted-map 1000 \\M 900 \"CM\" 500 \\D 400 \"DC\" 100 \\C 90 \"XC\" 50 \\L 40 \"XL\" 10 \\X 9 \"IX\" 5 \\V 4 \"IV\" 1 \\I))]\n    (loop [result \"\" number number]\n      (println (str result \" : \" number))\n\n      (if (<= number 0)\n        result\n        (let [[value rep] (first (drop-while #(> (first %) number) rdigits))]\n          (recur (str result rep) (- number value) )\n          )\n        )\n      )\n    )\n  )","user":"563a30d7e4b0bfe05bf117f9"},{"problem":104,"code":"(let [nums {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}\n      nums' (clojure.set/map-invert nums)\n      units (reverse (sort (keys nums')))\n      transforms-4-in {\\C '(\\C \\D) \\X '(\\X \\L) \\I '(\\I \\V)}\n      big-ugly-list [[3000 '(\\M \\M \\M)]\n                     [2000 '(\\M \\M)]\n                     [1000 '(\\M)]\n                     [900 '(\\C \\M)]\n                     [800 '(\\D \\C \\C \\C)]\n                     [700 '(\\D \\C \\C)]\n                     [600 '(\\D \\C)]\n                     [500 '(\\D)]\n                     [400 '(\\C \\D)]\n                     [300 '(\\C \\C \\C)]\n                     [200 '(\\C \\C)]\n                     [100 '(\\C)]\n                     [90 '(\\X \\C)]\n                     [80 '(\\L \\X \\X \\X)]\n                     [70 '(\\L \\X \\X)]\n                     [60 '(\\L \\X)]\n                     [50 '(\\L)]\n                     [40 '(\\X \\L)]\n                     [30 '(\\X \\X \\X)]\n                     [20 '(\\X \\X)]\n                     [10 '(\\X \\X)]\n                     [9 '(\\I \\X)]\n                     [8 '(\\V \\I \\I \\I)]\n                     [7 '(\\V \\I \\I)]\n                     [6 '(\\V \\I)]\n                     [5 '(\\V)]\n                     [4 '(\\I \\V)]\n                     [3 '(\\I \\I)]\n                     [2 '(\\I \\I)]\n                     [1 '(\\I)]]               \n      r-to-d (fn [rl] (map nums rl))\n      r-from-d (fn [dl] (map nums' dl))]\n  (fn [s]\n    (->>\n     s\n     ((fn raw-form [s]\n        (loop [s s r [] bul big-ugly-list]\n          (if (= 0 s)\n            r\n            (let [[u sub] (first bul)]\n              (println (str \"s: \" s \" -- r: \" r))\n              (if (>= (- s u) 0)\n                (recur (- s u) (conj r sub) bul)\n                (recur s r (rest bul))))))))\n     (flatten)\n     (apply str))))","user":"547d8e93e4b0c51c1f4d72f4"},{"problem":104,"code":"(fn [n]\n  (let [rmap {1000 \"M\", 900 \"CM\", 500 \"D\", 400 \"CD\", 100 \"C\", 90 \"XC\", 50 \"L\", 40 \"XL\", 10 \"X\", 9 \"IX\", 5 \"V\", 4 \"IV\", 1 \"I\"}]\n    (first (reduce\n             (fn [[s n] e]\n               (loop [s s n n]\n                 (if (< n e)\n                   [s n]\n                   (recur (str s (rmap e)) (- n e)))))\n             [\"\" n] (reverse (sort (keys rmap)))))))","user":"55e6c3f5e4b050e68259b48c"},{"problem":104,"code":"(fn wn [n]\n  (let [looper (fn looper [n syms]\n                  (if (empty? syms)\n                    (list)\n                    (let [[sym divisor] (first syms)\n                          [qt  remainr] ((juxt quot rem) n divisor)]\n                      (cons (repeat qt sym) (looper remainr (rest syms))))))]\n    (apply str (flatten (looper n (list [\\M 1000] ['(\\C \\M) 900] [\\D 500] ['(\\C \\D) 400] [\\C 100] ['(\\X \\C) 90] [\\L 50] ['(\\X \\L) 40] [\\X 10] ['(\\I \\X) 9] [\\V 5] ['(\\I \\V) 4] [\\I 1]))))))","user":"590b055ae4b047aa04b199c9"},{"code":"(fn [x]\n  (let [n [1000 900 500 400 100 90 50 40 10 9 5 4 1]\n        l '[M CM D CD C XC L XL X IX V IV I]]\n    (loop [x x\n           r \"\"]\n      (if (pos? x)\n        (let [v (some #(if (<= % x) %) n)]\n          (recur (- x v)\n                 (str r ((zipmap n l) v))))\n        r))))","problem":104,"user":"523ed522e4b057c4b7cd0a78"},{"problem":104,"code":"#(loop [n %\n\t\t   nums [[1000 \"M\"] [900 \"CM\"] [500 \"D\"] [400 \"CD\"] [100 \"C\"] [90 \"XC\"] [50 \"L\"] [40 \"XL\"] [10 \"X\"] [9 \"IX\"] [5 \"V\"] [4 \"IV\"] [1 \"I\"]]\n\t\t   r \"\"]\n\t\t(let [roman-value (first (first nums))\n\t\t\t  roman-string (second (first nums))]\n\t\t\t(cond\n\t\t\t\t(= 0 n) (apply str r)\n\t\t\t\t(>= n roman-value) (recur (- n roman-value) nums (concat r roman-string))\n\t\t\t\t:else (recur n (rest nums) r))))","user":"53e19461e4b0d874e779ae59"},{"problem":104,"code":"(fn num->rn [num]\n  (let [roman-nums [[\\I \\V \\X] [\\X \\L \\C] [\\C \\D \\M] [\\M]]\n        num-length (dec (count (str num)))]\n    (apply str\n           (map-indexed\n             (fn [idx n]\n               \n               (let [idx (- num-length idx)\n                     [low-rn mid-rn hi-rn] (nth roman-nums idx)\n                     n (- (int n) 48)]\n                 (if (= 3 idx)\n                   (apply str (repeat n low-rn))\n                   (get {1 low-rn\n                         2 (str low-rn low-rn)\n                         3 (str low-rn low-rn low-rn)\n                         4 (str low-rn mid-rn)\n                         5 mid-rn\n                         6 (str mid-rn low-rn)\n                         7 (str mid-rn low-rn low-rn)\n                         8 (str mid-rn low-rn low-rn low-rn)\n                         9 (str low-rn hi-rn)\n                         0 \"\"}\n                        n))))\n             (str num)))))","user":"53fe1b42e4b0de5c418485f1"},{"code":"#(let [lookup (sorted-map 0 \"E\" 1 \"I\" 4 \"IV\" 5 \"V\" 9 \"IX\" 10 \"X\" 40 \"XL\" 50 \"L\" 90 \"XC\" 100 \"C\" 500 \"D\" 900 \"CM\" 1000 \"M\")\r\n\t            k (reverse (keys lookup))]\r\n\t\t      (let [m (first (filter (fn [l] (>= %2 l)) k))]\r\n\t\t\t   (if (= m 0) (apply str %) (recur (concat % (lookup m)) (- %2 m))))) \"\"","problem":104,"user":"4dae4da5c9a9d6ed4e99dc57"},{"code":"(fn [x]\n  (apply\n   str \n   (map \n    (fn [i] (([[\"\" \"M\" \"MM\" \"MMM\"]\n        [\"\" \"C\" \"CC\" \"CCC\" \"CD\" \"D\" \"DC\" \"DCC\" \"DCCC\" \"CM\"]\n        [\"\" \"X\" \"XX\" \"XXX\" \"XL\" \"L\" \"LX\" \"LXX\" \"LXXX\" \"XC\"]\n        [\"\" \"I\" \"II\" \"III\" \"IV\" \"V\" \"VI\" \"VII\" \"VIII\" \"IX\"]\n        ] i)((into [] (rest (map #(- (int %) 48) (str (+ 10000 x)))))\n             i))) (range 4))))","problem":104,"user":"514457fbe4b0b4fb4ace5f43"},{"problem":104,"code":"(partial\n (fn [s n]\n   (cond\n     (>= n 1000) (recur (conj s \\M) (- n 1000))\n     (>= n 900) (recur (conj s \\C \\M) (- n 900))\n     (>= n 500) (recur (conj s \\D) (- n 500))\n     (>= n 400) (recur (conj s \\C \\D) (- n 400))\n     (>= n 100) (recur (conj s \\C) (- n 100))\n     (>= n 90) (recur (conj s \\X \\C) (- n 90))\n     (>= n 50) (recur (conj s \\L) (- n 50))\n     (>= n 40) (recur (conj s \\X \\L) (- n 40))\n     (>= n 10) (recur (conj s \\X) (- n 10))\n     (>= n 9) (recur (conj s \\I \\X) (- n 9))\n     (>= n 5) (recur (conj s \\V) (- n 5))\n     (>= n 4) (recur (conj s \\I \\V) (- n 4))\n     (>= n 1) (recur (conj s \\I) (- n 1))\n     :else (apply str s)))\n [])","user":"54c5cc17e4b045293a27f624"},{"code":"(fn p104 [num]\n  (let [fool-tbl [[nil \"I\" \"II\" \"III\" \"IV\" \"V\" \"VI\" \"VII\" \"VIII\" \"IX\"]\n                   [nil \"X\" \"XX\" \"XXX\" \"XL\" \"L\" \"LX\" \"LXX\" \"LXXX\" \"XC\"]\n                   [nil \"C\" \"CC\" \"CCC\" \"CD\" \"D\" \"DC\" \"DCC\" \"DCCC\" \"CM\"]\n                   [nil \"M\" \"MM\" \"MMM\"]]]\n    (apply str (reverse (remove nil? (map\n                                      #(nth (nth fool-tbl (second %)) (first %))     \n                                      (map-indexed\n                                       #(vector (- (int %2) (int \\0)) %1)\n                                       (reverse (str num)))))))))","problem":104,"user":"500b61b1e4b03d00572d2d81"},{"code":"#(letfn [(r [n]\r\n           (cond (>= n 1000) (cons \\M (r (- n 1000))) \r\n                 (>= n 900) (concat \"CM\" (r (- n 900))) \r\n                 (>= n 500) (cons \\D (r (- n 500))) \r\n                 (>= n 400) (concat \"CD\" (r (- n 400))) \r\n                 (>= n 100) (cons \\C (r (- n 100))) \r\n                 (>= n 90) (concat \"XC\" (r (- n 90))) \r\n                 (>= n 50) (cons \\L (r (- n 50))) \r\n                 (>= n 40) (concat \"XL\" (r (- n 40))) \r\n                 (>= n 10) (cons \\X (r (- n 10))) \r\n                 (>= n 9) (concat \"IX\" (r (- n 9))) \r\n                 (>= n 5) (cons \\V (r (- n 5))) \r\n                 (>= n 4) (concat \"IV\" (r (- n 4))) \r\n                 (>= n 1) (cons \\I (r (- n 1)))))] \r\n         (apply str (r %)))","problem":104,"user":"4f043ed1535dcb61093f6bb4"},{"code":"(fn [n]\n  (let [roman {\n        1000 \"M\"\n        900 \"CM\"\n        500 \"D\"\n        400 \"CD\"\n        100 \"C\"\n        90  \"XC\"\n        50  \"L\"\n        40  \"XL\"\n        10  \"X\"\n        9   \"IX\"\n        5   \"V\"\n        4   \"IV\"\n        1   \"I\"}\n        k (reverse (sort (keys roman)))]\n    (loop [n n\n       s \"\"]\n      (if (zero? n)\n        (apply str s)\n        (let [nxt (first (drop-while (partial < n) k))]\n          (recur (- n nxt) (concat s (roman nxt)))\n          )\n        )\n      )\n    )\n  )","problem":104,"user":"515f8a0de4b0e2be8aa20bce"},{"code":"(fn [n]\r\n  (let [v [[1000 \"M\"] [900 \"CM\"] [500 \"D\"] [400 \"CD\"]\r\n\t   [100 \"C\"] [90 \"XC\"] [50 \"L\"] [40 \"XL\"]\r\n\t   [10 \"X\"] [9 \"IX\"] [5 \"V\"] [4 \"IV\"] [1 \"I\"]]]\r\n    (loop [[n s] [n \"\"]]\r\n     (if (zero? n) s\r\n\t(recur (first (for [[k t] v :when (<= k n)] [(- n k) (str s t)])))))))","problem":104,"user":"4eb97b2e535dfed6da9c6d54"},{"code":"(fn [number]\n  (let [conv-table (sorted-map 1 :I\n                            4 :IV\n                            5 :V\n                            9 :IX\n                            10 :X\n                            40 :XL\n                            50 :L\n                            90 :XC\n                            100 :C\n                            400 :CD\n                            500 :D\n                            900 :CM\n                            1000 :M)]\n    (loop [n number t (reverse conv-table) result []]\n      (if (seq t)\n        (let [current (first t)\n              total (first current)\n              roman (quot n total)]\n          (recur (rem n total) (rest t) (if (> roman 0)\n                                          (concat result (repeat roman (second current)))\n                                          result)))\n        (clojure.string/join (map name result))))))","problem":104,"user":"5048202fe4b0ec70b3ef8d9a"},{"problem":104,"code":"(fn [n]\n     (if (>= n 4000)\n         nil\n         (let [roman_numerals {1 \\I,\n                               5 \\V,\n                               10 \\X,\n                               50 \\L,\n                               100 \\C,\n                               500 \\D,\n                               1000 \\M}]\n      (loop [x n\n             s nil]\n           (cond (= x 0) (apply str (reverse s))\n                 (>= x 1000) (recur (- x 1000) (cons (get roman_numerals 1000) s))\n                 (>= x 900) (recur (- x 900) (cons (get roman_numerals 1000)\n                                                   (cons (get roman_numerals 100) s)))\n                 (>= x 500) (recur (- x 500) (cons (get roman_numerals 500) s))\n                 (>= x 400) (recur (- x 400) (cons (get roman_numerals 500)\n                                                   (cons (get roman_numerals 100) s)))\n                 (>= x 100) (recur (- x 100) (cons (get roman_numerals 100) s))\n                 (>= x 90) (recur (- x 90) (cons (get roman_numerals 100)\n                                                 (cons (get roman_numerals 10) s)))\n                 (>= x 50) (recur (- x 50) (cons (get roman_numerals 50) s))\n                 (>= x 40) (recur (- x 40) (cons (get roman_numerals 50)\n                                                 (cons (get roman_numerals 10) s)))\n                 (>= x 10) (recur (- x 10) (cons (get roman_numerals 10) s))\n                 (>= x 9) (recur (- x 9) (cons (get roman_numerals 10)\n                                               (cons (get roman_numerals 1) s)))\n                 (>= x 5) (recur (- x 5) (cons (get roman_numerals 5) s))\n                 (>= x 4) (recur (- x 4) (cons (get roman_numerals 5)\n                                               (cons (get roman_numerals 1) s)))\n                 (>= x 1) (recur (- x 1) (cons (get roman_numerals 1) s))\n                 :else \"Unknown condition.\")))))","user":"5a34f342e4b0ddc586f153d1"},{"code":"(fn f\n  ([x] (apply str (f x [])))\n  ([x acc]\n   (let [vs [ [\"M\" 1000] [\"CM\" 900] [\"D\" 500] [\"LD\" 450] [\"CD\" 400] [\"C\" 100] [\"XC\" 90] [\"L\" 50] [\"XL\" 40] [\"X\" 10] [\"IX\" 9] [\"V\" 5] [\"IV\" 4] [\"I\" 1]] ]\n     (if (zero? x)\n       acc\n       (let [ [s n] (first (filter #(<= (second %) x) vs))]\n         (f (- x n) (conj acc s))\n         )\n       )\n     )\n   )\n  )","problem":104,"user":"523f0bbfe4b01c266ffa7f91"},{"code":"(fn [n]\n  (loop [roman \"\"\n         x n]\n    (cond\n     (>= x 1000) (recur (str roman \"M\") (- x 1000))\n     (>= x 900) (recur (str roman \"CM\") (- x 900))\n     (>= x 500) (recur (str roman \"D\") (- x 500))\n     (>= x 400) (recur (str roman \"CD\") (- x 400))\n     (>= x 100) (recur (str roman \"C\") (- x 100))\n     (>= x 90) (recur (str roman \"XC\") (- x 90))\n     (>= x 50) (recur (str roman \"L\") (- x 50))\n     (>= x 40) (recur (str roman \"XL\") (- x 40))\n     (>= x 10) (recur (str roman \"X\") (- x 10))\n     (>= x 9) (recur (str roman \"IX\") (- x 9))\n     (>= x 5) (recur (str roman \"V\") (- x 5))\n     (>= x 4) (recur (str roman \"IV\") (- x 4))\n     (>= x 1) (recur (str roman \"I\") (dec x))\n     (= x 0) roman)))","problem":104,"user":"50bd6033e4b0594b91591c66"},{"code":"(fn [init]\n  (let [numerals [[0 \"\"]\n                  [1 \"I\"]\n                  [4 \"IV\"]\n                  [5 \"V\"]\n                  [9 \"IX\"]\n                  [10 \"X\"]\n                  [40 \"XL\"]\n                  [50 \"L\"]\n                  [90 \"XC\"]\n                  [100 \"C\"]\n                  [400 \"CD\"]\n                  [500 \"D\"]\n                  [900 \"CM\"]\n                  [1000 \"M\"]]\n        done? (fn [[acc val]] (< val 0))\n        convert-next (fn [[acc val]]\n                       (if (zero? val)\n                         [acc -1]\n                         (let [match (last\n                                      (take-while (fn [[arabic roman]]\n                                                    (<= arabic val))\n                                                  numerals))]\n                           [(str acc (second match))\n                            (- val (first match))])))]\n    (last\n     (map first\n          (take-while (complement done?)\n                      (iterate convert-next [\"\" init]))))))","problem":104,"user":"5014754de4b094324338f8e5"},{"code":"(fn [n] \r\n  (let [rn {1 \"I\" 4 \"IV\" 5 \"V\" 9 \"IX\" 10 \"X\" 40 \"XL\" 50 \"L\" 90 \"XC\" 100 \"C\" 400 \"CD\" 500 \"D\" 900 \"CM\" 1000 \"M\"}\r\n          next (fn [n] (apply max (filter #(>= n %) (map key rn))))\r\n          conv (fn [s n]\r\n                 (if (zero? n) s\r\n                   (let [nxnum (next n)]\r\n                     (recur (str s (rn nxnum)) (- n nxnum)))))]\r\n      (conv \"\" n)))","problem":104,"user":"4db4714f535dc0f10411755a"},{"problem":104,"code":"(fn roman [n]\n  (cond (>= n 1000) (str \\M (roman (- n 1000)))\n        (>= n 900) (str \"CM\" (roman (- n 900)))\n        (>= n 500) (str \\D (roman (- n 500)))\n        (>= n 100) (str \\C (roman (- n 100)))\n        (>= n 90) (str \"XC\" (roman (- n 90)))\n        (>= n 50) (str \\L (roman (- n 50)))\n        (>= n 40) (str \"XL\" (roman (- n 40)))\n        (>= n 10) (str \\X (roman (- n 10)))\n        (= n 9) (str \"IX\")\n        (>= n 5) (str \\V (roman (- n 5)))\n        (= n 4) (str \"IV\")\n        (>= n 1) (str \\I (roman (- n 1)))\n        :else \"\"))","user":"60460824e4b02d28681c77bc"},{"code":"(fn n2r [x]\n  (let [t\n        {0 {0 \"\"}\n         1 {1000 \"M\" 100 \"C\" 10 \"X\" 1 \"I\"}\n         2 {1000 \"MM\" 100 \"CC\" 10 \"XX\" 1 \"II\"}\n         3 {1000 \"MMM\" 100 \"CCC\" 10 \"XXX\" 1 \"III\"}\n         4 {1000 \"MMMM\" 100 \"CD\" 10 \"XL\" 1 \"IV\"}\n         5 {10 \"L\" 100 \"D\" 1 \"V\"}\n         6 {10 \"LX\" 100 \"DC\" 1 \"VI\"}\n         7 {10 \"LXX\" 100 \"DCC\" 1 \"VII\"}\n         8 {10 \"LXXX\" 100 \"DCCC\" 1 \"VIII\"}\n         9 {10 \"XC\" 100 \"CM\" 1 \"IX\"}\n         }\n        a [(quot x 1000) 1000]\n        b [(quot (mod x 1000) 100) 100]\n        c [(quot (mod x 100) 10) 10]\n        d [(mod x 10) 1]\n     ]\n    (str (get-in t a)\n         (get-in t b)\n         (get-in t c)\n         (get-in t d))\n    )\n  )","problem":104,"user":"52140b53e4b0961f15ac4d7e"},{"problem":104,"code":"(fn [x] (let\n         [initial-state\n          {:remainder x :numerals \"\"}\n\n          numeral-mapping\n          [[1000 \"M\"] [900 \"CM\"] [500 \"D\"] [400 \"CD\"] [100 \"C\"]\n           [90 \"XC\"] [50 \"L\"] [40 \"XL\"] [10 \"X\"] [9 \"IX\"]\n           [5 \"V\"] [4 \"IV\"] [1 \"I\"]]\n\n          reduce-numeral-fn\n          (fn [remainder number numeral]\n              (clojure.string/join (repeat (quot remainder number) numeral)))\n\n          extract-numerals-fn\n          (fn [{remainder :remainder numerals :numerals} number numeral]\n              {:remainder (mod remainder number)\n               :numerals (str numerals (reduce-numeral-fn remainder number numeral))})\n\n          result\n          (:numerals\n           (reduce\n             #(apply extract-numerals-fn %1 %2)\n             initial-state\n             numeral-mapping))]\n         result))","user":"5db012e3e4b0f8c104ccfc95"},{"code":"(fn romanize [n]\n  (cond\n   (> (quot n 1000) 0) (str \"M\" (romanize (- n 1000)))\n   (>= n 900) (str \"CM\" (romanize (- n 900)))\n   (> (quot n 500) 0) (str \"D\" (romanize (- n 500)))\n   (>= n 400) (str \"CD\" (romanize (- n 400)))\n   (> (quot n 100) 0) (str \"C\" (romanize (- n 100)))\n   (>= n 90) (str \"XC\" (romanize (- n 90)))\n   (> (quot n 50) 0) (str \"L\" (romanize (- n 50)))\n   (>= n 40) (str \"XL\" (romanize (- n 40)))\n   (> (quot n 10) 0) (str \"X\" (romanize (- n 10)))\n   (>= n 9) (str \"IX\" (romanize (- n 9)))\n   (> (quot n 5) 0) (str \"V\" (romanize (- n 5)))\n   (>= n 4) (str \"IV\" (romanize (- n 4)))\n   (> n 0) (str \"I\" (romanize (dec n)))\n   :else \"\"))","problem":104,"user":"4e7f51eb535db966e863cc3f"},{"problem":104,"code":"(fn write-roman-numerals\n  [num]\n  (-> (second (reduce\n                (fn [[rem rns] [n rnc]]\n                  (if (= 0 rem)\n                    (list rem rns)\n                    (list (mod rem n) (apply (partial str rns) (take (quot rem n) (repeat rnc))))))\n                (list num \"\")\n                (list '(1000 \"M\") \n                      (list 500  \"D\")\n                      (list 100  \"C\")\n                      (list 50   \"L\")\n                      (list 10   \"X\")\n                      (list 5    \"V\")\n                      (list 1    \"I\"))))\n       (clojure.string/replace \"DCCCC\" \"CM\")\n       (clojure.string/replace \"LXXXX\" \"XC\")\n       (clojure.string/replace \"VIIII\" \"IX\")\n       (clojure.string/replace \"IIII\" \"IV\")\n       (clojure.string/replace \"XXXX\" \"XL\")))","user":"53b952eee4b047364c0444e6"},{"problem":104,"code":"(fn [n]\n  (loop [n n\n         digit (rem n 10)\n         lookup '([\"\" \"I\" \"II\" \"III\" \"IV\" \"V\" \"VI\" \"VII\" \"VIII\" \"IX\"]\n                  [\"\" \"X\" \"XX\" \"XXX\" \"XL\" \"L\" \"LX\" \"LXX\" \"LXXX\" \"XC\"]\n                  [\"\" \"C\" \"CC\" \"CCC\" \"CD\" \"D\" \"DC\" \"DCC\" \"DCCC\" \"CM\"]\n                  [\"\" \"M\" \"MM\" \"MMM\" \"MMMM\"])\n         numerals ()]\n    (if (and (zero? n) (zero? digit))\n      (clojure.string/join \"\" numerals)\n      (recur (quot n 10)\n             (rem (quot n 10) 10)\n             (rest lookup)\n             (conj numerals ((first lookup) digit))))))","user":"561ca2eae4b064ca9f4b169b"},{"problem":104,"code":"(fn [N]\n  (let [rn { 1 \"I\", 4 \"IV\"  5 \"V\" 9 \"IX\" 10 \"X\" 40 \"XL\" 50 \"L\" 90 \"XC\" 100 \"C\" 400 \"CD\" 500 \"D\" 900 \"CM\" 1000 \"M\"}\n        nums (sort > (keys rn))\n        nnum (fn [k] (some #(if (<= % k) %) nums))]\n       (loop [n N s \"\"]\n          (if (zero? n) s\n                  (recur (- n (nnum n)) (str s (rn (nnum n))))))))","user":"5649615be4b0284900eef641"},{"problem":104,"code":"(fn to-roman [num]\n  (let [tsnd (quot num 1000)\n        hund (quot (- num (* tsnd 1000)) 100)\n        tens (quot (- num (* tsnd 1000) (* hund 100)) 10)\n        ones (-> num str last str Integer.)\n        ms (repeat tsnd \"M\")\n        cs (cond\n             (zero? hund) \"\"\n             (= 9 hund) \"CM\"\n             (> 4 hund) (repeat hund \"C\")\n             (= 4 hund) \"CD\"\n             (< 4 hund) [\"D\" (repeat (- hund 5) \"C\")])\n        xs (cond\n             (zero? tens) \"\"\n             (= 9 tens) \"XC\"\n             (= 5 tens) \"L\"\n             (< 4 tens) [\"L\" (repeat (- tens 5) \"X\")]\n             (= 4 tens) \"XL\"\n             (> 4 tens) (repeat tens \"X\"))\n        is (cond\n             (zero? ones) \"\"\n             (= 9 ones) \"IX\"\n             (< 4 ones) [\"V\" (repeat (- ones 5) \"I\")]\n             (= 4 ones) \"IV\"\n             (> 4 ones) (repeat ones \"I\"))]\n    (->> [ms cs xs is] flatten (apply str))))","user":"5484143de4b0e286459a1197"},{"problem":104,"code":"(fn\n  [n]\n  (let [v [[\"M\" 1000]\n           [\"CM\" 900]\n           [\"D\"  500]\n           [\"CD\" 400]\n           [\"C\"  100]\n           [\"XC\"  90]\n           [\"L\"   50]\n           [\"XL\"  40]\n           [\"X\"   10]\n           [\"IX\"   9]\n           [\"V\"    5]\n           [\"IV\"   4]\n           [\"I\"    1]]]\n    (letfn [(r [n coll]\n              (lazy-seq\n                (if (seq coll)\n                  (let [[s x] (first coll)]\n                    (if (>= n x)\n                      (cons s (r (- n x) coll))\n                      (r n (rest coll))))\n                  nil)))]\n      (reduce #(.concat % %2) (r n v)))))","user":"52dfc89be4b09f7907dd1405"},{"problem":104,"code":"(fn[n]\n  (let [s  [[1000 \"M\"] [900 \"CM\"] [500 \"D\"] [400 \"CD\"] [100 \"C\"] [90 \"XC\"] [50 \"L\"] [40 \"XL\"] [10 \"X\"] [9 \"IX\"] [5 \"V\"] [4 \"IV\"] [1 \"I\"]]\n    f (fn[a m d] [(mod a m) (apply str (repeat (int (/ a m)) d))])]\n    (first (reduce (fn[[r a] [m d]] (let [[t k] (f a m d)] [(str r k) t]))\n    [\"\" n] s))))","user":"56824e1be4b0945ebc182a91"},{"problem":104,"code":"(fn [n]\n  (let [d2r {\\0 {0 \"\"     1 \"\"      2 \"\"     3 \"\"}\n             \\1 {0 \"I\"    1 \"X\"     2 \"C\"    3 \"M\"}\n             \\2 {0 \"II\"   1 \"XX\"    2 \"CC\"   3 \"MM\"}\n             \\3 {0 \"III\"  1 \"XXX\"   2 \"CCC\"  3 \"MMM\"}\n             \\4 {0 \"IV\"   1 \"XL\"    2 \"CD\"   3 \"MMMM\"}\n             \\5 {0 \"V\"    1 \"L\"     2 \"D\"    3 \"MMMMM\"}\n             \\6 {0 \"VI\"   1 \"LX\"    2 \"DC\"   3 \"MMMMMM\"}\n             \\7 {0 \"VII\"  1 \"LXX\"   2 \"DCC\"  3 \"MMMMMMM\"}\n             \\8 {0 \"VIII\" 1 \"LXXX\"  2 \"DCCC\" 3 \"MMMMMMMM\"}\n             \\9 {0 \"IX\"   1 \"XC\"    2 \"CM\"   3 \"MMMMMMMMM\"}}]\n    (apply str (reverse (map-indexed #(get-in d2r [%2 %]) (reverse (str n)))))))","user":"4ee528fb535d1385b2869d87"},{"code":"(fn int-to-roman [i]\n  (let [m {1000 \"M\" 900 \"CM\" 500 \"D\" 400 \"CD\" 100 \"C\" 90 \"XC\" 50 \"L\" 40 \"XL\" 10 \"X\" 9 \"IX\" 5 \"V\" 4 \"IV\" 1 \"I\"}]\n\t\t(loop [i i ks (reverse (sort (keys m))) k (first ks) r []] \n\t\t\t(cond \n\t\t\t\t(= i 0) (apply str r) \n\t\t\t\t(< (- i k) 0) (recur i (next ks) (fnext ks) r) \n\t\t\t\t(>= (- i k) 0) (recur (- i k) ks k (conj r (m k)))))))","problem":104,"user":"4f047542535dcb61093f6bc7"},{"problem":104,"code":"(fn [n]\n  (let [rnmap {\\0 [\"\" \"\" \"\" \"\"] \\1 [\"I\" \"X\" \"C\" \"M\"] \\2 [\"II\" \"XX\" \"CC\" \"MM\"] \\3 [\"III\" \"XXX\" \"CCC\" \"MMM\"] \\4 [\"IV\" \"XL\" \"CD\" \"MMMM\"] \\5 [\"V\" \"L\" \"D\" \"MMMMMM\"]\n               \\6 [\"VI\" \"LX\" \"DC\" \"MMMMMMM\"] \\7 [\"VII\" \"LXX\" \"DCC\" \"MMMMMMM\"] \\8 [\"VIII\" \"LXXX\" \"DCCC\" \"MMMMMMMM\"] \\9 [\"IX\" \"XC\" \"CM\" \"MMMMMMMMM\"]}]\n      (clojure.string/join \"\" (reverse (map-indexed (fn [i d] (get-in rnmap [d i])) (clojure.string/reverse (str n)))))))","user":"5958cef6e4b066ee0a44af94"},{"problem":104,"code":"(fn [n]\n  (let [dec-to-roman {1 \"I\" 4 \"IV\" 5 \"V\" 9 \"IX\" 10 \"X\" 40 \"XL\" 50 \"L\" 90 \"XC\"\n                      100 \"C\" 400 \"CD\" 500 \"D\" 900 \"CM\" 1000 \"M\"}]\n    (loop [n n rom \"\"]\n      (if (= 0 n)\n        (apply str rom)\n        (let [highest (apply max (remove #(< n %) (keys dec-to-roman)))]\n          (recur (- n highest) (concat rom (get dec-to-roman highest))))))))","user":"5d81b40ce4b0915913b1d379"},{"problem":104,"code":"#(loop [n % s \"\" nums [[1000 \"M\"] [900 \"CM\"] [500 \"D\"] [400 \"CD\"] [100 \"C\"] [90 \"XC\"] [50 \"L\"] [40 \"XL\"] [10 \"X\"] [9 \"IX\"] [5 \"V\"] [4 \"IV\"] [1 \"I\"]]]\n   (if-let [[[val sym] & nums'] nums]\n     (if (>= n val)\n       (recur (- n val) (str s sym) nums)\n       (recur n s nums'))\n     s))","user":"583e27e2e4b089d5ab817daa"},{"problem":104,"code":"(fn myf [n]\n  (let [table [[\"M\" 1000], [\"CM\" 900], [\"D\" 500], [\"CD\" 400], \n               [\"C\" 100], [\"XC\" 90], [\"L\" 50], [\"XL\" 40], \n               [\"X\" 10], [\"IX\" 9], [\"V\" 5], [\"IV\" 4], [\"I\" 1]]]\n    (loop [t table, res \"\", n n]\n      (if (zero? n) (apply str res)\n        (let [q (quot n (second (first t))), r (rem n (second (first t)))]\n          (if (zero? q) (recur (rest t) res n)\n            (recur (rest t) (concat res (repeat q (first (first t)))), r)))))))","user":"577c3da9e4b0c8d87281f6b9"},{"code":"(fn [x]\n  (let [digit-n   (fn [n y]\n                    (let [above (Math/pow 10 n)\n                          below (Math/pow 10 (dec n))]\n                      (quot (mod x above) below)))\n        digit-map (fn [c1 c5 c10]\n                    {0 \"\"\n                     1 (str c1)\n                     2 (str c1 c1)\n                     3 (str c1 c1 c1)\n                     4 (str c1 c5)\n                     5 (str c5)\n                     6 (str c5 c1)\n                     7 (str c5 c1 c1)\n                     8 (str c5 c1 c1 c1)\n                     9 (str c1 c10)})\n        digits    (digit-map \\I \\V \\X)\n        tens      (digit-map \\X \\L \\C)\n        hundreds  (digit-map \\C \\D \\M)\n        thousands {1 \"M\", 2 \"MM\", 3 \"MMM\", 4 \"MMMM\"}]\n    (str (thousands (digit-n 4 x))\n         (hundreds  (digit-n 3 x))\n         (tens      (digit-n 2 x))\n         (digits    (digit-n 1 x)))))","problem":104,"user":"4daf36c2edd6309eace4d175"},{"code":"#(let [M {1 \"I\", 4 \"IV\", 100 \"C\", 900 \"CM\", 5 \"V\", 40 \"XL\", 1000 \"M\", 9 \"IX\", 10 \"X\", 400 \"CD\", 50 \"L\", 500 \"D\", 90 \"XC\"}]\n   (loop [n %1\n          rn \"\"\n          parts (-> M (keys) (sort) (reverse))]\n     (if (or (zero? n) (empty? parts)) rn\n         (let [p (first parts)]\n           (if (>= n p)\n             (recur (- n p)\n                    (str rn (M p))\n                    parts)\n             (recur n rn (next parts)))))))","problem":104,"user":"4db8f6c4535d1e037afb219e"},{"code":"(fn f [x]\n  (let [s (first (filter #(<= 0 (- x (key %))) (sorted-map-by > 1000 \\M 900 \"CM\" 500 \\D 400 \"CD\" 100 \\C 90 \"XC\" 50 \\L 40 \"XL\" 10 \\X 9 \"IX\" 5 \\V 4 \"IV\" 1 \\I)))\n        v (- x (key s))]\n    (if (= 0 v)\n      (str (val s))\n      (str (val s) (f v)))))","problem":104,"user":"4efb2fd7535dced4c769f274"},{"code":"(fn r [n]\n   (loop [n n a []]\n     (cond\n      (>= n 1000) (recur (- n 1000) (conj a \"M\"))\n      (>= n 900) (recur (- n 900) (conj a \"CM\"))\n      (>= n 500) (recur (- n 500) (conj a \"D\"))\n      (>= n 400) (recur (- n 400) (conj a \"CD\"))\n      (>= n 100) (recur (- n 100) (conj a \"C\"))\n      (>= n 90) (recur (- n 90) (conj a \"XC\"))\n      (>= n 50) (recur (- n 50) (conj a \"L\"))\n      (>= n 40) (recur (- n 40) (conj a \"XL\"))\n      (>= n 10) (recur (- n 10) (conj a \"X\"))\n      (>= n 9) (recur (- n 9) (conj a \"IX\"))\n      (>= n 5) (recur (- n 5) (conj a \"V\"))\n      (>= n 4) (recur (- n 4) (conj a \"IV\"))\n      (>= n 1) (recur (- n 1) (conj a \"I\"))\n      :else (apply str a))))","problem":104,"user":"4ede8789535d10e5ff6f5337"},{"problem":104,"code":"(fn roman\n        ([n] (roman n \"\"))\n        ([n s]\n         (let [digits\n               [[\"M\" 1000]\n                [\"CM\" 900]\n                [\"D\" 500]\n                [\"CD\" 400]\n                [\"C\" 100]\n                [\"XC\" 90]\n                [\"L\" 50]\n                [\"XL\" 40]\n                [\"X\" 10]\n                [\"IX\" 9]\n                [\"V\" 5]\n                [\"IV\" 4]\n                [\"I\" 1]\n                [nil 0]]\n\n               [d v]\n               (-> (drop-while #(< n (second %)) digits)\n                   (first))]\n           \n           (if d\n             (roman (- n v) (str s d))\n             s))))","user":"58e37946e4b005f69f193cae"},{"code":"(fn\n  [n]\n  (let [[t n] [(quot n 1000) (rem n 1000)]\n        [h n] [(quot n 100) (rem n 100)]\n        [e o] [(quot n 10) (rem n 10)]\n        v {\"C\" \"D\", \"X\" \"L\", \"I\", \"V\"}\n        a {\"C\" \"M\", \"X\" \"C\", \"I\" \"X\"}\n        s (fn [n y]\n               (cond\n                  (<= 0 n 3) (repeat n y)\n                  (= 4 n) (list y (v y))\n                  (= 5 n) (list (v y))\n                  (<= 6 n 8) (cons (v y) (repeat (- n 5) y))\n                  (= 9 n) (list y (a y))))]\n    (apply str (concat (repeat t \"M\")\n                       (s h \"C\")\n                       (s e \"X\")\n                       (s o \"I\")))))","problem":104,"user":"4ff3df0fe4b0678c553fc355"},{"problem":104,"code":"(fn to-roman-numerals [n]                                                                                                       \n    (if (number? n)                                                                                                                                     \n        (to-roman-numerals (apply str (repeat n \"I\")))                                                                          \n        (-> n                                                                                                                                           \n            (clojure.string/replace #\"I{1000}\" \"M\")                                                                             \n            (clojure.string/replace #\"I{900}\" \"CM\")                                                                                                     \n            (clojure.string/replace #\"I{500}\"  \"D\")                                                                             \n            (clojure.string/replace #\"I{400}\" \"CD\")                                                                                                     \n            (clojure.string/replace #\"I{100}\"  \"C\")                                                                             \n            (clojure.string/replace #\"I{90}\"  \"XC\")                                                                                                     \n            (clojure.string/replace #\"I{50}\"   \"L\")                                                                             \n            (clojure.string/replace #\"I{40}\"  \"XL\")                                                                                                     \n            (clojure.string/replace #\"I{10}\"   \"X\")                                                                             \n            (clojure.string/replace #\"I{9}\"   \"IX\")                                                                                                     \n            (clojure.string/replace #\"I{5}\"    \"V\")                                                                             \n            (clojure.string/replace #\"I{4}\"   \"IV\"))))","user":"558b50d5e4b027778923762b"},{"code":"(fn [k]\n  (let [r (sorted-map\n            1 \"I\", 4 \"IV\", 5 \"V\", 9 \"IX\", 10 \"X\", 40 \"XL\", 50 \"L\" 90 \"XC\",\n            100 \"C\", 400 \"CD\", 500 \"D\", 900 \"CM\", 1000 \"M\")\n        f (fn [acc k]\n            (if (zero? k) acc\n              (let [[k' s] (last (take-while #(<= (key %) k) r))]\n                (recur (conj acc s) (- k k')))))]\n    (apply str (f [] k))))","problem":104,"user":"508157b2e4b0946d0443855c"},{"problem":104,"code":"(fn romans [n] \n  (letfn [(romans-1 [n s1 s2 s3]\n    (apply str (concat\n      (if (= (rem n 5) 4) s1)\n      (if (= n 9) s3)\n      (if (and (>= n 4) (<= n 8)) s2)\n      (apply str (repeat (rem (rem n 5) 4) s1))\n    ))\n  )]\n  (let [th (quot n 1000)\n        hund (quot (rem n 1000) 100)\n        tens (quot (rem n 100) 10)\n        units (rem n 10)]\n      (apply str (apply str (repeat th \\M))\n              (romans-1 hund \"C\" \"D\" \"M\")\n              (romans-1 tens \"X\" \"L\" \"C\")\n              (romans-1 units \"I\" \"V\" \"X\")\n      )\n  )\n  )\n)","user":"59a0262ee4b0871e7608b82d"},{"code":"(fn [x]\n  (let [chars-to-use (reverse (rest (clojure.string/split (str x) #\"\")))\n      ones-place (first (replace {\\1 \"I\" \\2 \"II\" \\3 \"III\" \\4 \"IV\" \\5 \"V\" \\6 \"VI\" \\7 \"VII\" \\8 \"VIII\" \\9 \"IX\" \\0 \"\"} (first chars-to-use)))\n      tens-place (first (replace {\\1 \"X\" \\2 \"XX\" \\3 \"XXX\" \\4 \"XL\" \\5 \"L\" \\6 \"LX\" \\7 \"LXX\" \\8 \"LXX\" \\9 \"XC\" \\0 \"\"} (second chars-to-use)))\n      hundreds-place (first (replace {\\1 \"C\" \\2 \"CC\" \\3 \"CCC\" \\4 \"CD\" \\5 \"D\" \\6 \"DC\" \\7 \"DCC\" \\8 \"DCCC\" \\9 \"CM\" \\0 \"\"} (first (next (next chars-to-use)))))\n      thousands-place (first (replace {\\1 \"M\" \\2 \"MM\" \\3 \"MMM\"} (first (next (next (next chars-to-use))))))]\n  (str thousands-place hundreds-place tens-place ones-place)))","problem":104,"user":"525c575be4b0cb4875a45d38"},{"problem":104,"code":"(fn [n]\n\t(let [th [nil \"M\" \"MM\" \"MMM\" \"MMMM\" \"MMMMM\" \"MMMMMM\" \"MMMMMMM\" \"MMMMMMMM\" \"MMMMMMMMM\"]\n\t\t  h [nil \"C\" \"CC\" \"CCC\" \"CD\" \"D\" \"DC\" \"DCC\" \"DCCC\" \"CM\"]\n\t\t  te [nil \"X\" \"XX\" \"XXX\" \"XL\" \"L\" \"LX\" \"LXX\" \"LXXX\" \"XC\"]\n\t\t  u [nil \"I\" \"II\" \"III\" \"IV\" \"V\" \"VI\" \"VII\" \"VIII\" \"IX\"]]\n\t\t(str (nth th (quot n 1000)) \n\t\t\t(nth h (quot (rem n 1000) 100)) \n\t\t\t(nth te (quot (rem n 100) 10)) \n\t\t\t(nth u (rem n 10)))))","user":"536e5b68e4b0fc7073fd6e6d"},{"problem":104,"code":"(fn\n  [n]\n  \n  (let [units (mod n 10)\n        tens  (/ (mod (- n units) 100) 10)\n        hundreds (/ (mod (- n units (* tens 10)) 1000) 100)\n        thousands (/ (mod (- n units (* tens 10) (* hundreds 100)) 10000) 1000)\n        romain-seq (concat (repeat thousands 'M)\n                           (repeat hundreds 'C)\n                           (repeat tens 'X)\n                           (repeat units 'I))]\n    (->\n     (apply str romain-seq)\n     (clojure.string/replace #\"IIIII\" \"V\")\n     (clojure.string/replace #\"IIII\" \"IV\")\n     (clojure.string/replace #\"VIV\" \"IX\")\n     (clojure.string/replace #\"XXXXX\" \"L\")\n     (clojure.string/replace #\"XXXX\" \"XL\")\n     (clojure.string/replace #\"LXL\" \"XC\")\n     (clojure.string/replace #\"CCCCC\" \"D\")\n     (clojure.string/replace #\"CCCC\" \"LD\")\n     (clojure.string/replace #\"DLD\" \"CM\"))))","user":"5125029de4b0ce9225d2ed3e"},{"problem":104,"code":"(fn writeToRoman\n  ([n] (writeToRoman n 0))\n  ([n index]\n    (if (= n 0)\n      []\n      (apply str (let [vals [1000 500 100 50 10 5 1] repr {1000 \\M 500 \\D 100 \\C 50 \\L 10 \\X 5 \\V 1 \\I}\n                       cur (nth vals index) letter (repr cur) q (quot n cur)]\n                   (concat (cond \n                             (= q 9) [letter (repr (nth vals (- index 2)))]\n                             (= q 4) [letter (repr (nth vals (- index 1)))]\n                             (>= q 5) (concat [(repr (nth vals (- index 1)))] (vec (repeat (- q 5) letter)))\n                             :else (vec (repeat q letter))) \n                           (writeToRoman (- n (* q cur))  (+ 2 index))))))))","user":"5626447fe4b00e49c7cb47bd"},{"problem":104,"code":"(fn to-roman [n]\n  (loop [n n s \"\"]\n    (if (zero? n) s\n        (let [r {\"I\" 1, \"IV\" 4, \"V\" 5, \"IX\" 9, \"X\" 10, \"XL\" 40, \"L\" 50, \"XC\" 90, \"C\" 100, \"CD\" 400, \"D\" 500, \"CM\" 900, \"M\" 1000}\n              e (apply max-key val (filter #(<= (val %) n) r))]\n          (recur (- n (val e)) (str s (key e)))))))","user":"60b7e2c5e4b0e0fa5f1b4252"},{"problem":104,"code":"; As with #92 we analyze the number from right to left. The rest is pretty much straight-forward\n;\n;\n;(defn get-nums [n numvec]\n;  (let [v (nth [[] [0] [0 0] [0 0 0] [0 1] [1] [1 0] [1 0 0] [1 0 0 0] [0 2]] n)]\n;     (apply str (for [i (range (count v))] (nth numvec (nth v i))))\n;  )\n;)\n;\n;(defn recur-digits [number numvec resstr]\n;  (if (> number 0)\n;    (recur-digits (int (/ number 10)) (nthrest numvec 2) (str (get-nums (mod number 10) (take 3 numvec)) resstr))\n;    resstr\n;  )\n;)\n;\n;(defn to-roman [number]\n;  (recur-digits number [\\I \\V \\X \\L \\C \\D \\M] \"\")\n;)\n;\n;\n;\n; or in this absurdly unreadable form to squeeze the code into the test cases (I guess my appproach in this is sub-optimal \n; but it enforces to write as little code as possible):\n;\n#((fn recur-digits [number numvec resstr](if (> number 0)(recur-digits (int (/ number 10)) (nthrest numvec 2) (str ((fn[n numvec](let [v (nth [[] [0] [0 0] [0 0 0] [0 1] [1] [1 0] [1 0 0] [1 0 0 0] [0 2]] n)](apply str (for [i (range (count v))] (nth numvec (nth v i)))))) (mod number 10) (take 3 numvec)) resstr))resstr)) % [\\I \\V \\X \\L \\C \\D \\M] \"\")","user":"545537c1e4b0e397800069dd"},{"code":"(let [value-mappings\r\n  \t[[1000 \"M\" ]\r\n\t\t [ 900 \"CM\"]\r\n\t\t [ 500 \"D\" ]\r\n\t\t [ 400 \"CD\"]\r\n\t\t [ 100 \"C\" ]\r\n\t\t [  90 \"XC\"]\r\n\t\t [  50 \"L\" ]\r\n\t\t [  40 \"XL\"]\r\n\t\t [  10 \"X\" ]\r\n\t\t [   9 \"IX\"]\r\n\t\t [   5 \"V\" ]\r\n\t\t [   4 \"IV\"]\r\n\t\t [   1 \"I\" ]]]\r\n\t(fn to-roman [d]\r\n\t\t(loop [roman [], decimal d]\r\n\t\t\t(if (zero? decimal)\r\n\t\t\t\t(apply str roman)\r\n\t\t\t\t(let [[d r] (first (drop-while #(> (first %) decimal) value-mappings))]\r\n\t\t\t\t\t(recur (conj roman r) (- decimal d)))))))","problem":104,"user":"4dd6d6a0535d2dad7130b5ca"},{"code":"#({1 \"I\" 30 \"XXX\" 4 \"IV\" 140 \"CXL\" 827 \"DCCCXXVII\" 3999 \"MMMCMXCIX\" 48 \"XLVIII\"} %)","problem":104,"user":"5336a339e4b0e30313ee6c7d"},{"problem":104,"code":"(fn [x]\n  (apply str(flatten (map \n       #(let[a (first %2) b (second %2) c (last %2)]\n          (get [\"\" [a] [a a] [a a a] [a b] [b] [b a] [b a a] [b a a a] [a c] ] (mod (quot x %1) 10) ))\n    [1000 100 10 1]\n    [\"M  \" \"CDM\" \"XLC\" \"IVX\"]\n  ))))","user":"52bbd09ee4b07a9af57922ee"},{"code":"(fn f104 [i]\n  \"(= \\\"DCCCXXVII\\\" (__ 827))\n   (= \\\"MMMCMXCIX\\\" (__ 3999))\"\n  (let [b1 (mod i 10)\n        b2 (mod (- i b1) 100)\n        b3 (mod (- i (+ b1 b2)) 1000)\n        b4 (- i (reduce + [b1 b2 b3]))\n        i1 (dec b1)\n        i2 (dec (/ b2 10))\n        i3 (dec (/ b3 100))\n        i4 (/ b4 1000)\n        l1 [\"I\" \"II\" \"III\" \"IV\" \"V\" \"VI\" \"VII\" \"VIII\" \"IX\"]\n        l2 [\"X\" \"XX\" \"XXX\" \"XL\" \"L\" \"LX\" \"LXX\" \"LXXX\" \"XC\"]\n        l3 [\"C\" \"CC\" \"CCC\" \"CD\" \"D\" \"DC\" \"DCC\" \"DCCC\" \"CM\"]\n        r1 (if (>= i1 0) (get l1 i1) \"\" )\n        r2 (if (>= i2 0) (get l2 i2) \"\" )\n        r3 (if (>= i3 0) (get l3 i3) \"\" )\n        r4 (loop [i4 i4 result \"\"]\n             (if (= i4 0) result (recur (dec i4) (str result \"M\"))))]\n    (str r4 r3 r2 r1)))","problem":104,"user":"4e88feef535d8b9bb0147ca8"},{"code":"(fn [n]\n    (let [ds {1 [0], 2 [0 0], 3 [0 0 0], 4 [0 1], 5 [1], 6 [1 0], 7 [1 0 0], 8 [1 0 0 0], 9 [0 2], 10 [2]}\n          gs [[\"I\" \"V\" \"X\"]  [\"X\" \"L\" \"C\"] [\"C\" \"D\" \"M\"] [\"M\"]]\n          sn (map #(- (int %) 48) (reverse (str n)))]\n      (apply str (flatten (reverse (for [x (range (count sn))] (for [d (ds (nth sn x))] (nth (nth gs x) d)) ))))))","problem":104,"user":"4f3ec266e4b0e243712b1f8c"},{"code":"(fn [n]\n  (cond (= 1 n) \"I\"\n        (= 30 n) \"XXX\"\n        (= 4 n) \"IV\"\n        (= 140 n) \"CXL\"\n        (= 827 n) \"DCCCXXVII\"\n        (= 3999 n) \"MMMCMXCIX\"\n        (= 48 n) \"XLVIII\"))","problem":104,"user":"518ccf6be4b05e6c8537e386"},{"code":"(fn [n]\n  (let [mapping [[1000 {1 [\\M]\t\n          2 [\\M \\M]\n          3 [\\M \\M \\M]}]\n   [ 100 {1 [\\C]\n          2 [\\C \\C]\n          3 [\\C \\C \\C]\n          4 [\\C \\D]\n          5 [\\D]\n          6 [\\D \\C]\n          7 [\\D \\C \\C]\n          8 [\\D \\C \\C \\C]\n          9 [\\C \\M]}]\n   [  10 {1 [\\X]\n          2 [\\X \\X]\n          3 [\\X \\X \\X]\n          4 [\\X \\L]\n          5 [\\L]\n          6 [\\L \\X]\n          7 [\\L \\X \\X]\n          8 [\\L \\X \\X \\X]\n          9 [\\X \\C]}]\n   [   1 {1 [\\I]\n          2 [\\I \\I]\n          3 [\\I \\I \\I]\n          4 [\\I \\V]\n          5 [\\V]\n          6 [\\V \\I]\n          7 [\\V \\I \\I]\n          8 [\\V \\I \\I \\I]\n          9 [\\I \\X]}] ]]\n  (loop [n n\n         [[k m] & kms] mapping\n         res []]\n    (if-not k\n      (apply str res)\n      (let [q (quot n k)\n            r (rem n k)\n            part (m q)]\n        (recur r kms (if part (into res part) res)))))))","problem":104,"user":"52d3f666e4b09f7907dd1327"},{"code":"(fn roman [x]\n  (let [r (fn [d bottom middle top] \n            (cond\n              (> 4 d) (repeat d bottom)\n              (= 4 d) (list bottom middle)\n              (> 9 d) (cons middle (repeat (- d 5) bottom))\n              (= 9 d) (list bottom top)))\n        digits (vec (map #(- % 48) (map int (format \"%04d\" x))))]\n    (apply str\n      (concat\n        (r (digits 0) \"M\" \"nil\" \"nil\")\n        (r (digits 1) \"C\" \"D\" \"M\")\n        (r (digits 2) \"X\" \"L\" \"C\")\n        (r (digits 3) \"I\" \"V\" \"X\")))))","problem":104,"user":"4f50c414e4b03ad3f0c10d0d"},{"problem":104,"code":"(fn num2roman [n]                                                                                                     \n  (letfn [(digits10-base [n]                                                                                          \n            (let [digits10 (mapv #(read-string (str %)) (str n))]                                                     \n              (loop [res [], [d & ds] (reverse digits10), b 1]                                                        \n                (if d (recur (cons [d b] res) ds (* b 10))                                                            \n                  res))))                                                                                             \n          (coeff2rom [[d b]]                                                                                          \n            (let [int->rom {1 \"I\" 5 \"V\" 10 \"X\" 50 \"L\" 100 \"C\" 500 \"D\" 1000 \"M\"}                                       \n                  b->l (get int->rom b)                                                                               \n                  b5->l (get int->rom (* b 5))                                                                        \n                  b10->l (get int->rom (* b 10))]                                                                     \n              (cond (= d 0) nil                                                                                       \n                    (< d 4) (apply str (repeat d b->l))                                                               \n                    (= d 4) (str b->l b5->l)                                                                          \n                    (= d 5) b5->l                                                                                     \n                    (< d 9) (apply str (conj (repeat (- d 5) b->l) b5->l))                                            \n                    :else (str b->l b10->l))))]                                                                       \n    (->> n                                                                                                            \n      digits10-base                                                                                                   \n      (mapv coeff2rom)                                                                                                \n      (remove nil?)                                                                                                   \n      (apply str)))                                                                                                   \n  )","user":"54bbaa8ee4b0ed20f4ff6ec0"},{"code":"(fn [s] \n  (let [k [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n        m (zipmap k\n            [\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"]\n            )]\n      (loop [a s result \"\"]\n        (if (= 0 a) \n            result\n          (let [n (first (filter #(>= a %) k))]\n              (recur (- a n) (str result (m n))))))))","problem":104,"user":"507fbd77e4b089ade05efbd3"},{"problem":104,"code":"(fn it [n]\n  (let [chart {1000 \"M\" 900 \"CM\" 500 \"D\" 400 \"CD\" 100 \"C\" 90 \"XC\" \n               50 \"L\" 40 \"XL\" 10 \"X\" 9 \"IX\" 5 \"V\" 4 \"IV\" 1 \"I\"}\n        which (first (drop-while #(< n %) [1000 900 500 400 100 90 50 40 10 9 5 4 1 0]))]\n    (if (zero? n) \"\" (str (chart which) (it (- n which))))))","user":"5504dd64e4b086ebe8a79c83"},{"code":"(fn [n]\n  (let [tbl [[1000 \"M\"] [900 \"CM\"] [500 \"D\"] [400 \"CD\"] [100 \"C\"] [90 \"XC\"]\n             [50 \"L\"] [40 \"XL\"] [10 \"X\"] [9 \"IX\"] [5 \"V\"] [4 \"IV\"] [1 \"I\"]]]\n    (loop [n n tbl tbl res []]\n      (if (zero? n)\n        (apply str res)\n        (let [[a r] (first tbl)]\n          (if (>= n a)\n            (recur (- n a) tbl (conj res r))\n            (recur n (rest tbl) res)))))))","problem":104,"user":"4dad7adac9a9d6ed0599dc57"},{"code":"(fn [x]\n  (let [ms {1 \"I\" 4 \"IV\" 5 \"V\" 9 \"IX\" 10 \"X\" 40 \"XL\" 50 \"L\" 90 \"XC\" 100 \"C\" 400 \"CD\" 500 \"D\" 900 \"CM\" 1000 \"M\"}\n        f (fn [m n] (apply str (repeat (quot m n) (ms n))))]\n    (apply str (second (reduce (fn [[m r] n] [(mod m n) (conj r (f m n))]) [x []] (sort > (keys ms)))))))","problem":104,"user":"4f954dbce4b0dcca54ed6ccd"},{"code":"(fn [num]\n  (let [d2r (sorted-map-by > 1000 \"M\" 900 \"CM\" 500 \"D\" 400 \"CD\" 100 \"C\" 90 \"XC\" 50 \"L\" 40 \"XL\" 10 \"X\" 9 \"IX\" 5 \"V\" 4 \"IV\" 1 \"I\")]\n    (loop [roman \"\"\n           n num]\n      (if (zero? n)\n        roman\n        (let [[d r] (some #(when (>= n (key %)) %) d2r)]\n          (recur (str roman r) (- n d)))))))","problem":104,"user":"500900dee4b0144d4f561e42"},{"problem":104,"code":"(fn num->roman [n]\n  (let [rv [[1 \"I\"][4 \"IV\"][5 \"V\"][9 \"IX\"][10 \"X\"][40 \"XL\"][50 \"L\"]\n            [90 \"XC\"][100 \"C\"][400 \"CD\"][500 \"D\"][900 \"CM\"][1000 \"M\"]]\n        max-roman-digit-ngt (fn [n] (last (take-while #(>= n (first %)) rv)))]\n    (loop [n n roman-num \"\"]\n      (if (zero? n)\n        roman-num\n        (let [[x roman-digit] (max-roman-digit-ngt n)]\n          (recur (- n x) (str roman-num roman-digit)))))))","user":"55586905e4b0deb715856e2b"},{"problem":104,"code":"(fn [number]\n  (let [digits (->> number (str) (map #(- (int %) 48)) (reverse))\n        romans [[\"I\" \"V\" \"X\"] \n                [\"X\" \"L\" \"C\"] \n                [\"C\" \"D\" \"M\"] \n                [\"M\" \"no\" \"no\"]]\n        for-rank (fn [digit {:keys [one five ten]}]\n                  (condp = digit\n                    0 \"\"\n                    1 (str one)\n                    2 (str one one)\n                    3 (str one one one)\n                    4 (str one five)\n                    5 (str five)\n                    6 (str five one)\n                    7 (str five one one)\n                    8 (str five one one one)\n                    9 (str one ten)))]\n    (apply str (reverse (map #(for-rank %1 (zipmap [:one :five :ten] %2)) digits romans)))))","user":"5c13da47e4b01240ff5671a6"},{"problem":104,"code":"(fn roman-from-number [n]\n  (letfn\n    [(number-to-base [n [base & more]]\n                     (if (=  n 0)\n                       '()\n                       (let [division (quot n base)\n                             reminder (rem n base)]\n                         (concat (repeat division base) (lazy-seq (number-to-base reminder more))))))]\n    (let [roman-base-to-symbol {\n                                1000 \"M\"\n                                900 \"CM\"\n                                500 \"D\"\n                                400 \"CD\"\n                                100 \"C\"\n                                90 \"XC\"\n                                50 \"L\"\n                                40 \"XL\"\n                                10 \"X\"\n                                9 \"IX\"\n                                5 \"V\"\n                                4 \"IV\"\n                                1 \"I\" }\n          roman-base (reverse (sort (keys roman-base-to-symbol)))\n          next-roman (apply hash-map (flatten (partition 2 1 (reverse roman-base))))]\n      (let [digits (number-to-base n roman-base)\n            grouped-digits (partition-by identity digits)\n            ]\n        (apply str\n               (map\n                roman-base-to-symbol\n                (mapcat\n                 (fn [[f & r :as ls]]\n                   (if (= 4 (count ls))\n                     (list f (next-roman f))\n                     ls))\n                 grouped-digits)))))))","user":"5654e024e4b0f9d632dd848d"},{"problem":104,"code":"(fn [number]\n(let\n  [roman\n{\n1 \"I\",\n4 \"IV\",\n5 \"V\",\n6 \"VI\",\n9 \"IX\",\n10 \"X\",\n40 \"XL\",\n50 \"L\",\n60 \"LX\",\n90 \"XC\",\n100 \"C\",\n400 \"CD\",\n500 \"D\",\n600 \"DC\",\n900 \"CM\",\n1000 \"M\"\n},\n   romanKeys (reverse (apply sorted-set (keys roman))),\n   recursor \n   (fn recurs \n     [out in] \n     (str\n      out\n      (if\n        (>= 0 in)\n        \"\"\n        (let\n        [\n         top (first (filter #(>= in %) romanKeys))\n         ]\n          (recurs (roman top) (- in top))\n        )\n        )\n      )\n     )\n   ]\n  (recursor \"\" number)\n  )\n  )","user":"58950f29e4b00487982d5270"},{"problem":104,"code":"#(case %\n   1 \"I\"\n   30 \"XXX\"\n   4 \"IV\"\n   140 \"CXL\"\n   827 \"DCCCXXVII\"\n   48 \"XLVIII\"\n   \"MMMCMXCIX\")","user":"5507cfd3e4b021ccfedb96ad"},{"code":"(fn [n]\n  (loop [i n ret '()]\n    (cond\n      (>= i 1000) (recur (- i 1000) (conj ret \\M))\n      (>= i 900) (recur (- i 900) (conj ret \\C \\M))\n      (>= i 500) (recur (- i 500) (conj ret \\D))\n      (>= i 400) (recur (- i 400) (conj ret \\C \\D))\n      (>= i 100) (recur (- i 100) (conj ret \\C))\n      (>= i 90) (recur (- i 90) (conj ret \\X \\C))\n      (>= i 50) (recur (- i 50) (conj ret \\L))\n      (>= i 40) (recur (- i 40) (conj ret \\X \\L))\n      (>= i 10) (recur (- i 10) (conj ret \\X))\n      (>= i 9) (recur (- i 9) (conj ret \\I \\X))\n      (>= i 5) (recur (- i 5) (conj ret \\V))\n      (>= i 4) (recur (- i 4) (conj ret \\I \\V))\n      (>= i 1) (recur (- i 1) (conj ret \\I))\n      (= i 0) (apply str (into '() ret)))))","problem":104,"user":"4f050dec535dcb61093f6bef"},{"code":"(fn [a] (let [rv [1000 500 100 50 10 5 1]\n        rm (zipmap rv \"MDCLXVI\")\n        dv (->> rv (take-nth 2) next (#(interleave % %)))]\n    (loop [a a rv rv dv dv r nil]\n      (if (<= a 0)\n        r\n        (let [v (first rv)\n              d (or (first dv) 0)\n              l (- v d)]\n          (cond\n            (= a v) (str r (rm v))\n            (= a l) (str r (rm d) (rm v))\n            (and (> a v) (> a l)) (recur (- a v) rv dv (str r (rm v)))\n            (and (< a v) (< a l)) (recur a (rest rv) (rest dv) r)\n            :else (recur (- a l) (rest rv) (rest dv) (str r (rm d) (rm v)))))))))","problem":104,"user":"4e58c019535d8a8b8723a297"},{"code":"(fn to-roman [n]\n    (let [roman-symbol [\\I \\V \\X \\L \\C \\D \\M]\n          roman-mapping [[] [0] [0 0] [0 0 0] [0 1] [1] [1 0] [1 0 0] [1 0 0 0] [0 2] [2]]]\n    (letfn [(digits [n] (loop [acc '() num n] (if (zero? num) acc (recur (cons (mod num 10) acc) (quot num 10)))))\n            (roman [magnitude n] (apply str (map roman-symbol (map #(+ % (* 2 magnitude)) (roman-mapping n)))))]\n                (apply str (map roman (reverse (take (count (digits n)) (range))) (digits n))))))","problem":104,"user":"4f4ac35ae4b0d56e7bb92c18"},{"problem":104,"code":"(fn [s]\n  (reduce\n   (fn [n [a b]] (clojure.string/replace n a b))\n   (apply str (take s (repeat \"I\")))\n   [[\"IIIII\" \"V\"] [\"IIII\" \"IV\"] [\"VV\" \"X\"] [\"VIV\" \"IX\"]\n    [\"XXXXX\" \"L\"] [\"XXXX\" \"XL\"] [\"LL\" \"C\"] [\"LXL\" \"XC\"]\n    [\"CCCCC\" \"D\"] [\"CCCC\" \"CD\"] [\"DD\" \"M\"] [\"DCD\" \"CM\"]]))","user":"5b14475be4b0cc2b61a3be5a"},{"problem":104,"code":"(fn [n]\n  (let [data {1 \"I\" 5 \"V\" 10 \"X\" 50 \"L\" 100 \"C\" 500 \"D\" 1000 \"M\"\n              4 \"IV\" 9 \"IX\" 40 \"XL\" 90 \"XC\" 400 \"CD\" 900 \"CM\"}\n        between (fn [n] (last (take-while #(< % n) (sort (keys data)))))]\n    (loop [n n h \"\"]\n      (if (data n)\n        (str h (data n))\n        (recur (- n (between n)) (str h (data (between n))))))))","user":"5c2836ebe4b07e362c2305d4"},{"code":"(fn roman\n  [n]\n  (letfn [(triangle [c n]\n            (map #(clojure.string/join (take % (repeat c))) (range n)))\n          (ht [c d l]\n            (concat (triangle c 4)\n                    [(str c d)]\n                    (map #(str d %) (triangle c 4))\n                    [(str c l)]))]\n    (let [m {3 (triangle \"M\" 10)\n             2 (ht \"C\" \"D\" \"M\")\n             1 (ht \"X\" \"L\" \"C\")\n             0 (ht \"I\" \"V\" \"X\")}\n          s (map-indexed vector (reverse (str n)))]\n      (clojure.string/join (reverse (map (fn [[i v]]\n                                           (nth (m i) (Integer/parseInt (str v)))) s)))\n      )))","problem":104,"user":"5348cab4e4b084c2834f4a5e"},{"problem":104,"code":"(fn [i]\n   (let [n->rn {1 \"I\" 4 \"IV\" 50 \"L\" 40 \"XL\" 1000 \"M\" 500 \"D\" 90 \"XC\" 100 \"C\" 9 \"IX\" 5 \"V\" 900 \"CM\" 400 \"CD\" 10 \"X\"}\n         ns (reverse (sort (keys n->rn)))]\n     (first (reduce (fn [[s i] n]\n                      [(apply str s (repeat (quot i n) (n->rn n))) (mod i n)])\n                    [\"\", i]\n                    ns))))","user":"5f3abcc4e4b004f08c61c52b"},{"problem":104,"code":"(fn f [n]\n  (cond (>= n 1000) (apply str \\M (f (- n 1000)))\n        (>= n 900) (apply str \"CM\" (f (- n 900)))\n        (>= n 500) (apply str \\D (f (- n 500)))\n        (>= n 400) (apply str \"CD\" (f (- n 400)))\n        (>= n 100) (apply str \\C (f (- n 100)))\n        (>= n 90) (apply str \"XC\" (f (- n 90)))\n        (>= n 50) (apply str \\L (f (- n 50)))\n        (>= n 40) (apply str \"XL\" (f (- n 40)))\n        (>= n 10) (apply str \\X (f (- n 10)))\n        (>= n 9) (apply str \"IX\" (f (- n 9)))\n        (>= n 5) (apply str \"V\" (f (- n 5)))\n        (>= n 4) (apply str \"IV\" (f (- n 4)))\n        (>= n 1) (apply str \\I (f (dec n)))))","user":"53fb5256e4b0de5c4184857f"},{"problem":104,"code":"(fn [d]\n  (loop [n d, r \"\"]\n    (cond (>= n 1000) (recur (- n 1000) (str r \"M\"))\n          (>= n 900)  (recur (- n 900)  (str r \"CM\"))\n          (>= n 500)  (recur (- n 500)  (str r \"D\"))\n          (>= n 400)  (recur (- n 500)  (str r \"CD\"))\n          (>= n 100)  (recur (- n 100)  (str r \"C\"))\n          (>= n 90)   (recur (- n 90)   (str r \"XC\"))\n          (>= n 50)   (recur (- n 50)   (str r \"L\"))\n          (>= n 40)   (recur (- n 40)   (str r \"XL\"))\n          (>= n 10)   (recur (- n 10)   (str r \"X\"))\n          (>= n 9)    (recur (- n 9)    (str r \"IX\"))\n          (>= n 5)    (recur (- n 5)    (str r \"V\"))\n          (>= n 4)    (recur (- n 4)    (str r \"IV\"))\n          (>= n 1)    (recur (- n 1)    (str r \"I\"))\n          :else r)))","user":"5dc9ccf8e4b02f9375f4e1f1"},{"problem":104,"code":"(fn write-roman [i]\n  (let [romans (sorted-map-by > 1 \"I\", 2 \"II\", 3 \"III\", 4 \"IV\", 5 \"V\",\n                              6 \"VI\", 7 \"VII\", 8 \"VIII\", 9 \"IX\", 10 \"X\",\n                              20 \"XX\", 30 \"XXX\", 40 \"XL\", 50 \"L\", \n                              60 \"LX\", 70 \"LXX\", 80 \"LXXX\", 90 \"XC\"\n                              100 \"C\", 200 \"CC\", 300 \"CCC\", 400 \"CD\", 500 \"D\",\n                              600 \"DC\", 700 \"DCC\", 800 \"DCCC\", 900 \"CM\"\n                              1000 \"M\", 2000 \"MM\", 3000 \"MMM\")\n        k (some #(if (<= % i) %) (keys romans))\n        r (- i k)]\n    (println k)\n    (if (= r 0) (romans k)\n      (apply str (concat (romans k) (write-roman r))))))","user":"52ee0de4e4b05e3f0be25ec1"},{"code":"(fn [n] (reduce #(apply (partial clojure.string/replace %) %2)\r\n(loop [k n s [] l [1000 500 100 50 10 5 1]\r\n w [\\M \\D \\C \\L \\X \\V \\I]] (if (zero? k) (apply str s)\r\n  (recur (rem k (first l)) (concat s\r\n   (repeat (quot k (first l)) (first w))) (rest l) (rest w))))\r\n[[\"DCCCC\" \"CM\"] [\"CCCC\" \"CD\"] [\"LXXXX\" \"XC\"]\r\n [\"XXXX\" \"XL\"] [\"VIIII\" \"IX\"] [\"IIII\" \"IV\"]]))","problem":104,"user":"4fca2ef0e4b0ee37620e184e"},{"code":"(fn __ \n  ([n] (__ n [[1000 \"M\"] [900 \"CM\"] [500 \"D\"] [400 \"CD\"] [100 \"C\"] [90 \"XC\"] [50 \"L\" ] [40 \"XL\"] [10 \"X\"] [9 \"IX\"] [5 \"V\"] [4 \"IV\"] [1 \"I\"]]))\n  ([n [[k v] & r :as s]]\n    (if (> n 0)\n      (if (> (quot n k) 0)\n        (str v (__ (- n k) s))\n        (__ n r)))))","problem":104,"user":"4e6e2ac4535d5021c1a895ff"},{"code":"(fn wr [n]\n  (let [ rn [{ \\1 \"I\", \\2 \"II\", \\3 \"III\", \\4 \"IV\", \\5 \"V\", \\6 \"VI\", \\7 \"VII\", \\8 \"VIII\", \\9 \"IX\"}\n             { \\1 \"X\", \\2 \"XX\", \\3 \"XXX\", \\4 \"XL\", \\5 \"L\", \\6 \"LX\", \\7 \"LXX\", \\8 \"LXXX\", \\9 \"XC\"}\n             { \\1 \"C\", \\2 \"CC\", \\3 \"CCC\", \\4 \"CD\", \\5 \"D\", \\6 \"DC\", \\7 \"DCC\", \\8 \"DCCC\", \\9 \"CM\"}\n             { \\1 \"M\", \\2 \"MM\", \\3 \"MMM\"}]\n         s (apply str (reverse (str n)))]\n    (apply str\n           (for [ x (range (dec (count s)) -1 -1)] (get (nth rn x) (nth s x))))))","problem":104,"user":"51c09719e4b0c9c82288293c"},{"problem":104,"code":"(fn [n]\n  (loop [n n result \"\"]\n    (condp <= n\n      1000 (recur (- n 1000) (str result \"M\"))\n       900 (recur (- n 900) (str result \"CM\"))\n       500 (recur (- n 500) (str result \"D\"))\n       400 (recur (- n 400) (str result \"CD\"))\n       100 (recur (- n 100) (str result \"C\"))\n        90 (recur (- n 90) (str result \"XC\"))\n        50 (recur (- n 50) (str result \"L\"))\n        40 (recur (- n 40) (str result \"XL\"))\n        10 (recur (- n 10) (str result \"X\"))\n         9 (recur (- n 9) (str result \"IX\"))\n         5 (recur (- n 5) (str result \"V\"))\n         4 (recur (- n 4) (str result \"IV\"))\n         1 (recur (- n 1) (str result \"I\"))\n         result)))","user":"56d68cbae4b0ea9b8538f7cd"},{"code":"(fn [num]\n  (let [last-digit [\\I \\V \\X]\n        ten-digit [\\X \\L \\C]\n        hundred-digit [\\C \\D \\M]]\n    (letfn [(step [digit roman-digits]\n              (if (<= digit 3)\n                (apply str (repeat digit (first roman-digits)))\n                (if (= digit 4)\n                  (apply str [(first roman-digits) (second roman-digits)])\n                  (if (<= digit 8)\n                    (apply str (cons (second roman-digits) (repeat (- digit 5) (first roman-digits))))\n                    (apply str [(first roman-digits) (last roman-digits)])))))\n            (append-zero [num-str]\n              (apply str (concat (repeat (- 4 (count num-str)) \\0) num-str)))]\n      (let [num-str (reverse (append-zero (.toString num)))]\n        (apply str\n          (concat\n            (apply str (repeat (Integer/parseInt (str (last num-str))) \\M))\n            (step (Integer/parseInt (str (nth num-str 2))) hundred-digit)\n            (step (Integer/parseInt (str (second num-str))) ten-digit)\n            (step (Integer/parseInt (str (first num-str))) last-digit)))))))","problem":104,"user":"514d7e29e4b019235f6c0587"},{"problem":104,"code":"(fn [n]\n  (let [rs (partition 3 2 \"IVXLCDM  \")\n        rm (fn [n [o f t]]\n             (cond (= n 9) (str o t)\n                   (> n 4) (apply str f (repeat (- n 5) o))\n                   (= n 4) (str o f)\n                   (> n 0) (apply str (repeat n o))))\n        nm (fn f [[p & s] n]\n             (when p\n               (let [q (quot n 10)\n                     r (mod n 10)]\n                 (cons (rm r p) (lazy-seq (f s q))))))]\n    (->> n\n         (nm rs)\n         reverse\n         (apply str))))","user":"54dd76c8e4b024c67c0cf794"},{"code":"(fn [num]\n  (let [tens [[\\I \\V \\X] [\\X \\L \\C] [\\C \\D \\M] [\\M nil nil]]]\n    (letfn [(write [digit [a b c]] \n                   (cond (= 4 digit) (str a b)\n                         (= 9 digit) (str a c)\n                         (< 4 digit) (str b (apply str (repeat (rem digit 5) a)))\n                         :else (apply str (repeat digit a))))\n            (digitize [num]\n                      (loop [number num digits []] \n                        (if (zero? number) \n                          digits\n                          (recur (quot number 10) (conj digits (rem number 10) )))))\n            \n            ]\n      (apply str (reverse (map-indexed #(write %2 (tens  %1)) (digitize num)))))))","problem":104,"user":"4f4c6b21e4b03ad3f0c10c8f"},{"problem":104,"code":"(fn roman [x]\n  (cond\n    (<= 1000 x) (str \"M\" (roman (- x 1000)))\n    (<= 900 x) (str \"CM\" (roman (- x 900)))\n    (<= 500 x) (str \"D\" (roman (- x 500)))\n    (<= 400 x) (str \"CD\" (roman (- x 400)))\n    (<= 100 x) (str \"C\" (roman (- x 100)))\n    (<= 90 x) (str \"XC\" (roman (- x 90)))\n    (<= 50 x) (str \"L\" (roman (- x 50)))\n    (<= 40 x) (str \"XL\" (roman (- x 40)))\n    (<= 10 x) (str \"X\" (roman (- x 10)))\n    (<= 9 x) (str \"IX\" (roman (- x 9)))\n    (<= 5 x) (str \"V\" (roman (- x 5)))\n    (<= 4 x) (str \"IV\" (roman (- x 4)))\n    (<= 1 x) (str \"I\" (roman (- x 1)))\n    :else \"\"))","user":"53ce4cd4e4b00fb29b2212ef"},{"problem":104,"code":"(fn [n]\n    (let [to-numerals {1 \"I\" 2 \"II\" 3 \"III\" 4 \"IV\" 5 \"V\" 6 \"VI\" 7 \"VII\" 8 \"VIII\" 9 \"IX\"\n                       10 \"X\" 20 \"XX\" 30 \"XXX\" 40 \"XL\" 50 \"L\" 60 \"LX\" 70 \"LXX\" 80 \"LXXX\" 90 \"XC\"\n                       100 \"C\" 200 \"CC\" 300 \"CCC\" 400 \"CD\" 500 \"D\" 600 \"DC\" 700 \"DCC\" 800 \"DCCC\" 900 \"CM\"\n                       1000 \"M\" 2000 \"MM\" 3000 \"MMM\"}]\n      (let [sn (str n)\n            ns (filter #(not (zero? %))\n                       (map (fn [[x y]] (int (* x (Math/pow 10 y))))\n                            (map vector\n                                 (map #(-> % str Integer/parseInt) sn)\n                                 (range (-> sn count dec) -1 -1))))]\n        (apply str (map #(get to-numerals %) ns)))))","user":"5ac6ef9be4b0e27600da7779"},{"code":"#(first\n    (reduce (fn [[acc remaining] [s v]]\n              [(apply str acc (repeat (quot remaining v) s)) (rem remaining v)]\n              ) [\"\" %]\n                (map vector (map str '(M CM D CD C XC L XL X IX V IV I)) [1000 900 500 400 100 90 50 40 10 9 5 4 1])))","problem":104,"user":"507056b8e4b07bd6ad9b9f29"},{"code":"(let [roman-values [[\"M\" 1000] [\"CM\" 900] [\"D\" 500] [\"CD\" 400] [\"C\" 100] [\"XC\" 90] [\"L\" 50] [\"XL\" 40] [\"X\" 10] [\"IX\" 9] [\"V\" 5] [\"IV\" 4] [\"I\" 1]]]\n  (fn translate [n]\n    (if (zero? n)\n      \"\"\n      (let [[sym value] (some (fn [[sym value]] (when (<= value n) [sym value])) roman-values)]\n        (str sym (translate (- n value)))))))","problem":104,"user":"507b7dbee4b09034bfeeb71e"},{"problem":104,"code":"(fn [N]\n    (let \n      [\n        Dict {\n          1000 \"M\"\n          900 \"CM\"\n          800 \"DCCC\"\n          700 \"DCC\"\n          600 \"DC\"\n          500 \"D\"\n          400 \"CD\"\n          100 \"C\"\n          90 \"XC\"\n          80 \"LXXX\"\n          70 \"LXX\"\n          60 \"LX\"\n          50 \"LX\"\n          40 \"XL\"\n          10 \"X\"\n          9 \"IX\"\n          8 \"VIII\"\n          7 \"VII\"\n          6 \"VI\"\n          5 \"VI\"\n          4 \"IV\"\n          1 \"I\"\n        }\n      ]\n      (loop [Ret \"\" N N]\n        (if (zero? N)\n          Ret\n          (let \n            [\n              ;; найдем пару, подходящую\n              Pair (filter #(>= N (first %) ) Dict)\n              ;; отберем из нее максимальное число\n              Pair (reduce #(if (> (first %1) (first %2)) %1 %2) Pair)\n            ]\n            ;;(println N Pair)\n            (recur \n              (str Ret (last Pair))\n              (- N (first Pair))\n            )\n          )\n        )\n      )\n    )\n  )","user":"5d4a6c6ce4b0776584bd6f22"},{"problem":104,"code":"(fn write-roman [n]\n  (let [roman-syms [[\\I \\V] [\\X \\L] [\\C \\D] [\\M \\0]]]\n    (loop [n n r-syms roman-syms overflow nil res '()]\n      (if (= n 0) (apply str res)\n          (let [syms (first r-syms)\n                d (rem n 10)\n                ovf (if (= d 9) (first syms) nil)\n                deci (case d\n                       1 [(first syms)]\n                       2 [(first syms) (first syms)]\n                       3 [(first syms) (first syms) (first syms)]\n                       4 syms\n                       5 [(second syms)]\n                       6 [(second syms) (first syms)]\n                       7 [(second syms) (first syms) (first syms)]\n                       8 [(second syms) (first syms) (first syms) (first syms)]\n                       nil)\n                new-res (concat deci (when overflow (list overflow (first syms))) res)]\n            (recur (quot n 10) (rest r-syms) ovf new-res))))))","user":"5471f2fbe4b094393f72dd70"},{"code":"(fn write-roman [n]\n   (let [numerals (array-map 1000 \"M\" 900 \"CM\" 500 \"D\" 400 \"CD\" 100 \"C\" 90 \"XC\" 50 \"L\"\n                             40 \"XL\" 10 \"X\" 9 \"IX\" 5 \"V\" 4 \"IV\" 1 \"I\")]\n     (if (= n 0)\n       \"\"\n       (let [num-key (first (drop-while #(> % n) (keys numerals)))\n             num-val (numerals num-key)]\n         (str num-val (write-roman (- n num-key)))))))","problem":104,"user":"4e89f46c535d3e98b8023288"},{"problem":104,"code":"(fn rom [n]\n  (let [lookup (apply hash-map\n                      (concat\n                       '(1 \"I\" 2 \"II\" 3 \"III\" 4 \"IV\" 5 \"V\" 6 \"VI\" 7 \"VII\" 8 \"VIII\" 9 \"IX\")\n                       '(10 \"X\" 20 \"XX\" 30 \"XXX\" 40 \"XL\" 50 \"L\" 60 \"LX\" 70 \"LXX\" 80 \"LXXX\" 90 \"XC\")\n                       '(100 \"C\" 200 \"CC\" 300 \"CCC\" 400 \"CD\" 500 \"D\" 600 \"DC\" 700 \"DCC\" 800 \"DCCC\" 900 \"CM\")\n                       '(1000 \"M\" 2000 \"MM\" 3000 \"MMM\")))\n        nums (reverse (sort  (keys lookup)))]\n    (loop [rem n rstr \"\"]\n      (let [sub (first (filter #(<= 0 (- rem %)) nums))\n            roman (lookup sub)]\n        (if (zero? rem)\n          rstr\n          (recur (- rem sub) (str rstr roman)))))))","user":"56069006e4b08b23635d3174"},{"problem":104,"code":"(fn to-roman\n  [n]\n  (let [numerals [1000 900 500 400 100 90 50 40 10 9 5 4 1]\n        romans  (zipmap numerals [\"M\" \"CM\" \"D\" \"CD\" \"C\" \"XC\" \"L\" \"XL\" \"X\" \"IX\" \"V\" \"IV\" \"I\"])]\n    (first\n      (reduce\n        (fn [[roman r] k]\n          [(str roman (apply str (repeat (quot r k) (romans k))))\n           (rem r k)])\n        [\"\" n]\n        numerals))))","user":"5d38a4dde4b01671435dbd4a"},{"code":"(fn r2n [n]\n  (let [mapping [[1000 \"M\"]\n                 [900 \"CM\"]\n                 [500 \"D\"]\n                 [400 \"DC\"]\n                 [100 \"C\"]\n                 [90 \"XC\"]\n                 [50 \"L\"]\n                 [40 \"XL\"]\n                 [10 \"X\"]\n                 [9 \"IX\"]\n                 [5 \"V\"]\n                 [4 \"IV\"]\n                 [1 \"I\"]]]\n    (if (zero? n)\n      \"\"\n      (let [[k v] (some (fn [[k v]] (when (<= k n) [k v])) mapping)]\n        (str v (r2n (- n k)))))))","problem":104,"user":"527cd633e4b0757a1b17136f"},{"problem":104,"code":"(let [table\n      (->> [[\"I\" \"II\" \"III\" \"IV\" \"V\" \"VI\" \"VII\" \"VIII\" \"IX\"]\n            [\"X\" \"XX\" \"XXX\" \"XL\" \"L\" \"LX\" \"LXX\" \"LXXX\" \"XC\"]\n            [\"C\" \"CC\" \"CCC\" \"CD\" \"D\" \"DC\" \"DCC\" \"DCCC\" \"CM\"]\n            [\"M\" \"MM\" \"MMM\"]]\n        (map cons (repeat \"\"))\n        (map #(zipmap (range) %)))]\n  (fn [n]\n    (->> n\n      vector\n      (iterate (comp (juxt #(quot % 10) #(rem % 10)) first))\n      (drop 1)\n      (take-while #(not= [0 0] %))\n      (map second)\n      (map get table)\n      reverse\n      (apply str))))","user":"50479524e4b0371827a27bc4"},{"code":"(fn roman [n]\n  (let [vmap { 1 \"I\" 5 \"V\" 10 \"X\" 50 \"L\" 100 \"C\" 500 \"D\" 1000 \"M\" 4 \"IV\" 9 \"IX\" 40 \"XL\" 90 \"XC\" 400 \"CD\" 900 \"CM\"}]\n    (loop [n n tot []]\n      (cond \n        (>= n 1000) (recur (- n 1000) (conj tot \"M\"))\n        (= 1 (quot n 900)) (recur (- n 900) (conj tot \"CM\"))\n        (>= n 500) (recur (- n 500) (conj tot \"D\"))\n        (= 1 (quot n 400)) (recur (- n 400) (conj tot \"CD\"))\n        (>= n 100) (recur (- n 100) (conj tot \"C\"))\n        (= 1 (quot n 90)) (recur (- n 90) (conj tot \"XC\"))\n        (>= n 50) (recur (- n 50) (conj tot \"L\"))\n        (= 1 (quot n 40)) (recur (- n 40) (conj tot \"XL\"))\n        (>= n 10) (recur (- n 10) (conj tot \"X\"))\n        (= 1 (quot n 9)) (recur (- n 9) (conj tot \"IX\"))\n        (>= n 5) (recur (- n 5) (conj tot \"V\"))\n        (= 1 (quot n 4)) (recur (- n 4) (conj tot \"IV\"))\n        (>= n 1) (recur (- n 1) (conj tot \"I\")) \n        :else (apply str tot)))))","problem":104,"user":"513cb853e4b0b86ece9f322b"},{"code":"(fn [n]\n  (loop [d [1000 900 500 400 100 90 50 40 10 9 5 4 1]\n         r [\"M\" \"CM\" \"D\" \"CD\" \"C\" \"XC\" \"L\" \"XL\" \"X\" \"IX\" \"V\" \"IV\" \"I\"]\n         n1 n\n         acc \"\"]\n    \n    (if (= 0 (count d))\n      acc\n      (let [div   (first d)\n            times (quot n1 div)\n            remdr (rem  n1 div)]\n        \n        (recur (rest d) (rest r) remdr (str acc (apply str (repeat times (first r)))))))))","problem":104,"user":"53415755e4b00652c8746ecd"},{"problem":104,"code":"(fn [n]\n  (let [roman [[1000 \"M\"] [900 \"CM\"] [500 \"D\"] [400 \"CD\"] [100 \"C\"] [90 \"XC\"] \n               [50 \"L\"] [40 \"XL\"] [10 \"X\"] [9 \"IX\"] [5 \"V\"] [4 \"IV\"] [1 \"I\"]]]\n    (loop [i n, s \"\", data roman]\n      (if (seq data)\n        (recur (mod i (ffirst data)) \n               (str s (apply str (repeat (quot i (ffirst data)) (last (first data)))))\n               (rest data))\n        s))))","user":"56c4f43ce4b05cc29241ee9c"},{"code":"(fn f [[n & a] [s & b] o i]\r\n  (if n\r\n    (f a b (into o (repeat (int (/ i n)) s)) (rem i n))\r\n    (apply str o)))\r\n[1000 900 500 400 100 90 50 40 10  9 5  4 1]\r\n'[  M  CM   D  CD   C XC  L XL  X IX V IV I]\r\n[]","problem":104,"user":"4db858d1535d1e037afb218c"},{"code":"(fn roman-repr [n]\n  (let [num-to-roman1000 {0 \"\", 1 \"M\", 2 \"MM\", 3 \"MMM\"}\n        num-to-roman100 {0 \"\", 1 \"C\", 2 \"CC\", 3 \"CCC\", 4 \"CD\", 5 \"D\", 6 \"DC\", 7 \"DCC\", 8 \"DCCC\", 9 \"CM\"}\n        num-to-roman10 {0 \"\", 1 \"X\", 2 \"XX\", 3 \"XXX\", 4 \"XL\", 5 \"L\", 6 \"LX\", 7 \"LXX\", 8 \"LXXX\", 9 \"XC\"}\n        num-to-roman {0 \"\", 1 \"I\", 2 \"II\", 3 \"III\", 4 \"IV\", 5 \"V\", 6 \"VI\", 7 \"VII\", 8 \"VIII\", 9 \"IX\"}\n        parts (map (comp read-string str) (str n))\n        mapping (interleave [num-to-roman num-to-roman10 num-to-roman100 num-to-roman1000] (reverse parts))]\n    (if (> n 3999)\n      nil\n      (apply str (reverse (map #((first %) (second %))  (partition 2 mapping)))))))","problem":104,"user":"4ff355a1e4b0678c553fc34d"},{"problem":104,"code":"(fn f\n  [n]\n  (cond\n    (zero? n) \"\"\n    (<= 1000 n) (str \"M\" (f (- n 1000)))\n    (<= 900 n) (str \"CM\" (f (- n 900)))\n    (<= 500 n) (str \"D\" (f (- n 500)))\n    (<= 400 n) (str \"CD\" (f (- n 400)))\n    (<= 100 n) (str \"C\" (f (- n 100)))\n    (<= 90 n) (str \"XC\" (f (- n 90)))\n    (<= 50 n) (str \"L\" (f (- n 50)))\n    (<= 40 n) (str \"XL\" (f (- n 40)))\n    (<= 10 n) (str \"X\" (f (- n 10)))\n    (<= 9 n) (str \"IX\" (f (- n 9)))\n    (<= 5 n) (str \"V\" (f (- n 5)))\n    (= 4 n) \"IV\"\n    :else (str \"I\" (f (- n 1)))))","user":"583048d9e4b051871117c007"},{"problem":104,"code":"(fn [x] (loop [ x x s \"\" m [1000 \"M\" 900 \"CM\" 500 \"D\" 400 \"CD\" 100 \"C\" 90 \"XC\" 50 \"L\" 40 \"XL\" 10 \"X\" 9 \"IX\" 5 \"V\" 4 \"IV\" 1 \"I\"]] (if (zero? x) s (let [m1 (first m) m2 (second m)] (if (>= x m1) (recur (- x m1) (str s m2) m) (recur x s (drop 2 m)))))))","user":"53b2a7f8e4b047364c04449c"},{"code":"(fn rom-to-str\n  [in-n]\n  (let [mp (sorted-map 10000 \\?, 5000 \\?,\n                        1000 \\M,  500 \\D,\n                         100 \\C,   50 \\L,\n                          10 \\X,    5 \\V, 1 \\I)]\n\n    (loop [n in-n, m (reverse mp), chs []]\n      (let [ [[i10 c10] [i5 c5] [i1 c1]] (take 3 m)\n             val  (int (/ n i1))\n             vchs (cond\n                 (= val 0) []\n                 (= val 1) [c1]\n                 (= val 2) [c1 c1]\n                 (= val 3) [c1 c1 c1]\n                 (= val 4) [c1 c5]\n                 (= val 5) [c5]\n                 (= val 6) [c5 c1]\n                 (= val 7) [c5 c1 c1]\n                 (= val 8) [c5 c1 c1 c1]\n                 (= val 9) [c1 c10]) ]\n        (if (< (count m) 5)\n          (apply str (into chs vchs))\n          (recur (- n (* val i1)) (drop 2 m) (into chs vchs)))))))","problem":104,"user":"4f047c07535dcb61093f6bcd"},{"problem":104,"code":"(let\n  [digit (fn [d one five ten]\n           (let [large (> d 4) small (mod d 5)] (if\n                                                  (< small 4)\n                                                  (concat (if large [five] nil) (repeat small one))\n                                                  [one (if large ten five)])))]\n  (fn [x]\n    (let [a (rem x 10) aa (quot x 10) b (rem aa 10) bb (quot aa 10) c (rem bb 10) d (quot bb 10)\n          ar (digit a \\I \\V \\X) br (digit b \\X \\L \\C) cr (digit c \\C \\D \\M) dr (digit d \\M \\? \\?)]\n      (apply str (concat dr cr br ar)))))","user":"5b465b8be4b02d533a91bc65"},{"code":"#(apply str ((fn roman [s n]\n              (cond (>= n 1000) (roman (conj s \"M\") (- n 1000))\n                    (>= n 900) (roman (conj s \"CM\") (- n 900))\n                    (>= n 500) (roman (conj s \"D\") (- n 500))\n                    (>= n 400) (roman (conj s \"CD\") (- n 400))\n                    (>= n 100) (roman (conj s \"C\") (- n 100))\n                    (>= n 90) (roman (conj s \"XC\") (- n 90))\n                    (>= n 50) (roman (conj s \"L\") (- n 50))\n                    (>= n 40) (roman (conj s \"XL\") (- n 40))\n                    (>= n 10) (roman (conj s \"X\") (- n 10))\n                    (= n 9) (conj s \"IX\")\n                    (>= n 5) (roman (conj s \"V\") (- n 5))\n                    (= n 4) (conj s \"IV\")\n                    (>= n 1) (roman (conj s \"I\") (dec n))\n                    (= n 0) s)) [] %))","problem":104,"user":"505dcfc8e4b0e6aca564be0d"},{"problem":104,"code":"(fn roman-numerals [x]\n  (let [num-to-roman {1 \"I\", 5 \"V\", 10 \"X\", 50 \"L\", 100 \"C\", 500 \"D\", 1000 \"M\"}\n     place->roman (fn [[place z]] (let [one-symbol (num-to-roman place)\n                                        five-symbol (num-to-roman (* place 5))\n                                        ten-symbol (num-to-roman (* place 10))]\n                                    (case z\n                                      0 \"\"\n                                      1 one-symbol\n                                      2 (str one-symbol one-symbol)\n                                      3 (str one-symbol one-symbol one-symbol)\n                                      4 (str one-symbol five-symbol)\n                                      5 (str five-symbol)\n                                      6 (str five-symbol one-symbol)\n                                      7 (str five-symbol one-symbol one-symbol)\n                                      8 (str five-symbol one-symbol one-symbol one-symbol)\n                                      9 (str one-symbol ten-symbol))))]\n    (->> x\n         (iterate #(quot % 10))\n         (take-while (partial not= 0))\n         (map #(mod % 10))\n         (map-indexed (fn [i y] [(int (Math/pow 10 i)) y]))\n         (vec)\n         (rseq)\n         (map place->roman)\n         (apply str))))","user":"53504fe6e4b084c2834f4ada"},{"code":"(fn [num]\n  (let [rm [[1000 \"M\"] [900 \"CM\"] [500 \"D\"] [400 \"CD\"] [100 \"C\"] [90 \"XC\"]\n            [50 \"L\"] [40 \"XL\"] [10 \"X\"] [9 \"IX\"] [5 \"V\"] [4 \"IV\"] [1 \"I\"]]]\n    (loop [s \"\" n num i 0]\n      (println s \" - \" ((rm i) 0))\n      (if (or (= n 0))\n        s\n        (if (>= n ((rm i) 0))\n          (recur (str s ((rm i) 1)) (- n ((rm i) 0)) i)\n          (recur s n (inc i)))))))","problem":104,"user":"50bce014e4b0594b91591c63"},{"code":"(let [divrem (fn [n d] [(quot n d) (rem n d)])\n      digits (fn digits [n]\n        (loop [n n, ds nil]\n          (let [[q r] (divrem n 10), ds (cons r ds)]\n            (if (zero? q) ds (recur q ds)))))\n      romchars (partition 3 2 [nil nil \\M \\D \\C \\L \\X \\V \\I])\n      xlat-digit (fn xlat-digit [dig [ten five one]]\n        (let [[q r] (divrem dig 5), zq (zero? q)]\n          (if (= 4 r)\n            [one (if zq five ten)]\n            (concat (if zq [] [five]) (repeat r one)))))\n      pad-front (fn [ds]\n        (let [n (- 4 (count ds))]\n          (if (pos? n) (concat (repeat n 0) ds) ds)))]\n  #(apply str (mapcat xlat-digit (pad-front (digits %)) romchars)))","problem":104,"user":"4e6a412e535d8ccf87e9feb6"},{"code":"(fn to-roman [n]\n  (loop [num n roman []]\n    (cond\n      (<= num 0) (apply str roman)\n      (< num 4) (recur (- num 1) (conj roman \"I\"))\n      (< num 5) (recur (- num 4) (conj roman \"IV\"))\n      (< num 9) (recur (- num 5) (conj roman \"V\"))\n      (< num 10) (recur (- num 9) (conj roman \"IX\"))\n      (< num 40) (recur (- num 10) (conj roman \"X\"))\n      (< num 50) (recur (- num 40) (conj roman \"XL\"))\n      (< num 90) (recur (- num 50) (conj roman \"L\"))\n      (< num 100) (recur (- num 90) (conj roman \"XC\"))\n      (< num 400) (recur (- num 100) (conj roman \"C\"))      \n      (< num 500) (recur (- num 400) (conj roman \"CD\"))\n      (< num 900) (recur (- num 500) (conj roman \"D\"))\n      (< num 1000) (recur (- num 900) (conj roman \"CM\"))\n      (< num 10000) (recur (- num 1000) (conj roman \"M\"))\n      :else \"not there yet\")))","problem":104,"user":"5003deb9e4b0678c553fc445"},{"problem":104,"code":"(fn [n] (loop [out [] r n m [[1000 \"M\"] [900 \"CM\"] [500 \"D\"] [400 \"CD\"] [100 \"C\"] [90 \"XC\"] [50 \"L\"] [40 \"XL\"] [10 \"X\"] [9 \"IX\"] [5 \"V\"] [4 \"IV\"] [1 \"I\"]]]\n\t\t\t(if (zero? r) (apply str out) (let [[a b] (first m) x (quot r a)] (recur (concat out (repeat x b)) (rem r a) (rest m))))\n\t\t)\n)","user":"580c8fcee4b0849f6811b721"},{"problem":104,"code":"(fn dec2roman [v]\n  (let [numerals {\"I\" 1 \"V\" 5 \"X\" 10 \"L\" 50 \"C\" 100 \"D\" 500 \"M\" 1000}\n        subtractions {\"IV\" 4, \"IX\" 9 \"XL\" 40 \"XC\" 90 \"CD\" 400 \"CM\" 900}\n        masks (reverse ( sort (clojure.set/map-invert (into numerals subtractions))))]\n    (loop [v v r \"\" masks masks]\n      (let [[mask_value mask_symbol] (first masks)]\n        (if (= 0 v)\n          r\n          (if (>= v mask_value)\n            (recur (- v mask_value) (str r mask_symbol) masks)\n            (recur v r (rest masks))\n            )\n          )\n        )\n      )\n    )\n  )","user":"562add6de4b00e49c7cb4834"},{"code":"#(let [chunks [[1000 \"M\"] [900 \"CM\"] [500 \"D\"] [400 \"CD\"] [100 \"C\"]\n                [90 \"XC\"]  [50 \"L\"]  [40 \"XL\"]  [10 \"X\"]\n                [9 \"IX\"]   [5 \"V\"]   [4 \"IV\"]   [1 \"I\"]]]\n    (loop [rs [] n % chunks chunks]\n      (if (zero? n)\n        (apply str rs)\n        (let [[d r] (first chunks)]\n          (if (> d n)\n            (recur rs n (next chunks))\n            (recur (conj rs r) (- n d) chunks))))))","problem":104,"user":"4e8510e7535db62dc21a62e7"},{"code":"(fn [n]\n  (let [roman-map\n        {1 [\"I\", \"V\", \"X\"],\n         10 [\"X\", \"L\", \"C\"],\n         100 [\"C\", \"D\", \"M\"],\n         1000 [\"M\"]}\n        decimal-digit-to-roman\n        (fn [digit-value place]\n          (let [roman-chars (roman-map place)]\n            (cond\n              (and (>= digit-value 1) (<= digit-value 3)) (apply str (repeat digit-value (roman-chars 0)))\n              (= digit-value 4) (str (roman-chars 0) (roman-chars 1))\n              (= digit-value 5) (str (roman-chars 1))\n              (and (>= digit-value 6) (<= digit-value 8)) (str (roman-chars 1) (apply str (repeat (- digit-value 5) (roman-chars 0))))\n              (= digit-value 9) (str (roman-chars 0) (roman-chars 2)))))]\n    (apply str\n           (reverse\n            (map\n             (fn [digit place]\n               (decimal-digit-to-roman digit place))\n             (map #(Integer/valueOf (str (or % 0)))\n                  (reverse (str n)))\n             (take 4 (iterate #(* % 10) 1)))))))","problem":104,"user":"4f31519ae4b0d6649770a086"},{"code":"(fn int2roman [i]\n    (let [table  (sorted-map 1000 \"M\" 900 \"CM\" 500 \"D\" 400 \"CD\" 100 \"C\"\n             90 \"XC\" 50 \"L\" 40 \"XL\" 10 \"X\" 9 \"IX\" 5 \"V\" 4 \"IV\" 1 \"I\")\n          left (take-while (fn [[n s]] (<= n i)) table)\n          current (last left)]\n      (if (nil? current) \"\" (str (second current) (int2roman (- i (first current)))))))","problem":104,"user":"4f0e995e535d0136e6c22326"},{"code":"(fn write-roman [n]\n  (let [dec2roman [{\\1 \"I\", \\2 \"II\", \\3 \"III\", \\4 \"IV\", \\5 \"V\", \\6 \"VI\", \\7 \"VII\", \\8 \"VIII\", \\9 \"IX\" },\n                   {\\1 \"X\", \\2 \"XX\", \\3 \"XXX\", \\4 \"XL\", \\5 \"L\", \\6 \"LX\", \\7 \"LXX\", \\8 \"LXXX\", \\9 \"XC\" },\n                   {\\1 \"C\", \\2 \"CC\", \\3 \"CCC\", \\4 \"CD\", \\5 \"D\", \\6 \"DC\", \\7 \"DCC\", \\8 \"DCCC\", \\9 \"CM\" },\n                   {\\1 \"M\", \\2 \"MM\", \\3 \"MMM\"}]\n        digits (first (partition 4 4 \"0000\" (reverse (Integer/toString n))))]\n    (reduce #(str %2 %1) (map get dec2roman digits))))","problem":104,"user":"4eb9ce75535dfed6da9c6d5e"},{"code":"(fn write-roman [n]\n  (let [vals [1000 900 500 400 100 90 50 40 10 9 5 4 1]\n        strs [\"M\" \"CM\" \"D\" \"CD\" \"C\" \"XC\" \"L\" \"XL\" \"X\" \"IX\" \"V\" \"IV\" \"I\"]\n        roman (zipmap vals strs)]\n    (loop [values vals\n           current n\n           accum []]\n      (if (empty? values)\n        (apply str accum)\n        (let [v (first values)\n              next (- current v)]\n          (if (neg? next)\n            (recur (rest values) current accum)\n            (recur values next (conj accum (roman v)))))))))","problem":104,"user":"5164867fe4b003cf19fdde3e"},{"problem":104,"code":"(fn [source-number] \n  (let [rom-num-map { 1000 \"M\", 900  \"CM\", 500 \"D\", 400 \"CD\", 100 \"C\", 90 \"XC\", 50 \"L\", 40 \"XL\", 10 \"X\", 9 \"IX\", 5 \"V\", 4 \"IV\", 1 \"I\", 0 \"\"}]\n   ((fn process-number [current-number [next-major-number & rest-of-the-major-numbers] accumulator]\n      (if (not= nil rest-of-the-major-numbers)\n        (if (>= current-number next-major-number) \n          (process-number (- current-number next-major-number) (cons next-major-number rest-of-the-major-numbers) (str accumulator (rom-num-map next-major-number)))\n          (process-number current-number rest-of-the-major-numbers accumulator))\n        accumulator))\n    source-number (sort > (keys rom-num-map)) \"\")))","user":"50e1bdd8e4b019fc399ce17f"},{"code":"(fn [n]\n  (first (reduce \n          (fn [[a n][d c]]\n            (let [i (quot n d)]\n              [(str a (apply str (repeat i c))), (- n (* d i))] ))\n          \n          [\"\",n] [[1000 \"M\"][900 \"CM\"][500 \"D\"][400 \"CD\"][100 \"C\"][90 \"XC\"][50 \"L\"][40 \"XL\"][10 \"X\"][9 \"IX\"][5 \"V\"][4 \"IV\"][1 \"I\"]])))","problem":104,"user":"515bbcd9e4b0388ca8ca1521"},{"code":"(fn  [n] \n  (letfn [(less [n] \n            (condp <= n\n              1000  [(- n 1000) \\M]\n              900   [(- n 900) \\C \\M]\n              500   [(- n 500) \\D]\n              400   [(- n 400) \\C \\D]\n              100   [(- n 100) \\C]\n              90    [(- n 90) \\X \\C]\n              50    [(- n 50) \\L]\n              40    [(- n 40) \\X \\L]\n              10    [(- n 10) \\X]\n              9     [(- n 9) \\I \\X]\n              5     [(- n 5) \\V]\n              4     [(- n 4) \\I \\V]\n              1     [(- n 1) \\I]\n            ))]\n    (loop [[m & s] [n] r []]\n        (if (= m 0)\n            (apply str (into r s))\n            (recur (less m) (into  r s))))))","problem":104,"user":"4e50e2a0535dc968683fc4ef"},{"code":"(fn [i]\n  (let [nums (sorted-map-by > 1000 \"M\" 900 \"CM\" 500 \"D\" 100 \"C\" 90 \"XC\" 50 \"L\" 40 \"XL\" 10 \"X\" 9 \"IX\" 5 \"V\" 4 \"IV\" 1 \"I\")]\n    (loop [rem i roman []]\n      (if (zero? rem)\n        (apply str roman)\n        (let [dec-by (first (drop-while #(< rem %) (keys nums))) ]\n          (recur (- rem dec-by) (conj roman (nums dec-by))))))))","problem":104,"user":"4df3df8a535d08e6dec9fe2d"},{"problem":104,"code":"(fn torn [n']\n  (let [nm [[1000 \"M\"] [900 \"CM\"] [500 \"D\"] [400 \"CD\"] [100 \"C\"] [90 \"XC\"] [50 \"L\"] [40 \"XL\"] [10 \"X\"] [9 \"IX\"] [5 \"V\"] [4 \"IV\"] [1 \"I\"]] ]\n    (loop [acc [] n n']\n      (if (zero? n)\n        (apply str acc)\n        (let [rn (first (filter (fn [ne] (<= (first ne) n)) nm))]\n          (recur (conj acc (second rn)) (- n (first rn))))))))","user":"53a5bc3ae4b0ef122a8689c3"},{"problem":104,"code":"(let [numbers {1 \"I\" 10 \"X\" 100 \"C\" 1000 \"M\"}\n      fives {\"C\" \"D\" \"X\" \"L\" \"I\" \"V\"}\n      nines {\"I\" \"X\" \"X\" \"C\" \"C\" \"M\"}\n      sp (fn [s]\n            (let [ch (first s) l (count s)] \n               (cond (= 9 l) (str ch (nines ch))\n                     (= 5 l) (fives ch)\n                     (= 4 l) (str ch (fives ch))\n                     (and (< l 9) (> l 5)) (str (fives ch) (apply str (repeat (mod l 5) ch)))\n                     :else (apply str s)\n               )\n             )\n         )\n      f (fn [n] (second (reduce #(let [[occurence left] ((juxt quot mod) (first %1) %2)] \n                          [left (str (second %1) (sp (repeat occurence (numbers %2))))]\n                         ) [n \"\"] (reverse (sort (keys numbers))))))\n     ]\n     #(f %)\n)","user":"5fd8bcb3e4b05ac5b16ea11b"},{"code":"(fn [decimal]\n  (let [roman-vals [[1000 \"M\"]\n                     [900 \"CM\"] [500 \"D\"] [400 \"CD\"] [100 \"C\"]\n                      [90 \"XC\"]  [50 \"L\"]  [40 \"XL\"]  [10 \"X\"]\n                       [9 \"IX\"]   [5 \"V\"]   [4 \"IV\"]   [1 \"I\"]]]\n    (loop [roman [], n decimal, vals-left roman-vals]\n      (if (zero? n)\n        (apply str roman)\n        (let [[d r] (first vals-left)]\n          (if (>= n d)\n            (recur (conj roman r) (- n d) vals-left)\n            (recur roman n (rest vals-left))))))))","problem":104,"user":"4e52d815535d302ef430da77"},{"code":"(fn [n]\r\n  (let [\r\n       tr [1000 \"M\" 900 \"CM\" 500 \"D\" 400 \"CD\" 100 \"C\" 90 \"XC\" 50 \"L\" 40 \"XL\" 10 \"X\" 9 \"IX\" 5 \"V\" 4 \"IV\" 1 \"I\"]\r\n       f (fn [n [a b & as :as t] res]\r\n\t\t\t  (cond (= 0 n) res\r\n\t\t\t        (< n a) (recur n as res)\r\n\t\t\t        (>= n a) (recur (- n a) t (str res b))\r\n\t\t\t  ))] (f n tr \"\")))","problem":104,"user":"4e6e10d8535d5021c1a895fd"},{"code":"(fn write-roman [n]\n  (let [r1000 {0 \"\" 1 \"M\" 2 \"MM\" 3 \"MMM\"}\n        r100 {0 \"\" 1 \"C\" 2 \"CC\" 3 \"CCC\" 4 \"CD\"\n              5 \"D\" 6 \"DC\" 7 \"DCC\" 8 \"DCCC\" 9 \"CM\"}\n        r10 {0 \"\" 1 \"X\" 2 \"XX\" 3 \"XXX\" 4 \"XL\"\n             5 \"L\" 6 \"LX\" 7 \"LXX\" 8 \"LXXX\" 9 \"XC\"}\n        r1 {0 \"\" 1 \"I\" 2 \"II\" 3 \"III\" 4 \"IV\"\n            5 \"V\" 6 \"VI\" 7 \"VII\" 8 \"VIII\" 9 \"IX\"}]\n    (apply str (concat (r1000 (quot n 1000))\n                       (r100 (quot (rem n 1000) 100))\n                       (r10 (quot (rem n 100) 10))\n                       (r1 (quot (rem n 10) 1))))))","problem":104,"user":"4e5bff2b535d8a8b8723a2bd"},{"problem":104,"code":"(fn [s]\n  (->> s\n    (str)\n    (map #(- (int %) 48))\n    (map   #(case %\n              0 []\n       1 [1]\n       2 [1 1]\n       3 [1 1 1]\n       4 [5 1]\n       5 [5]\n       6 [1 5]\n       7 [1 1 5]\n       8 [1 1 1 5]\n       9 [10 1]\n    ))\n    (reverse)\n    (map-indexed vector)\n    (map (fn [[a b]] (map  (fn [x] (apply (partial * x) (repeat a 10))) b)))\n    (flatten)\n    (reverse)\n    (map (apply array-map (interleave [1 5 10 50 100 500 1000] \"IVXLCDM\")))\n    (apply str)\n  )\n)","user":"4fc8f671e4b0ee37620e1840"},{"code":"(let [c (seq \"IVXLCDM\")]\n\t(fn fun [n]\n\t\t(apply str\n\t\t\t((fn efun [n c]\n\t\t\t\t(if (zero? n) \n\t\t\t\t\t()\n\t\t\t\t\t(let [r (rem n 10)\n\t\t\t\t\t\tres (cond \n\t\t\t\t\t\t\t(<= r 3) (repeat r (first c))\n\t\t\t\t\t\t\t(<= r 5) (concat (repeat (- 5 r) (first c)) (list (second c)))\n\t\t\t\t\t\t\t(<= r 8) (cons (second c) (repeat (- r 5) (first c)))\n\t\t\t\t\t\t\t(= r 9) (list (first c) (second (rest c)))\n\t\t\t\t\t\t\t)]\n\t\t\t\t\t\t(concat (efun (quot n 10) (nnext c)) res ))))\n\t\t\t\tn c))))","problem":104,"user":"520242bae4b030ee0c5b26e3"},{"problem":104,"code":"(fn roman-numerals [n]\n    (if \n      (zero? n) \"\"\n      (let [conversions [\n                         [1000 \"M\"]\n                         [900 \"CM\"]\n                         [500 \"D\"]\n                         [400 \"CD\"]\n                         [100 \"C\"]\n                         [90 \"XC\"]\n                         [50 \"L\"]\n                         [40 \"XL\"]\n                         [10 \"X\"]\n                         [9 \"IX\"]\n                         [5 \"V\"]\n                         [4 \"IV\"]\n                         [1 \"I\"]]\n            [arabic roman] (first (filter #(>= n (first %)) conversions))]\n(str roman (roman-numerals (- n arabic))))))","user":"5ae0976be4b0837691e92c43"},{"problem":104,"code":"(fn [n]\n    (let [romanos {1 \"I\" 4 \"IV\" 5 \"V\" 9 \"IX\" 10 \"X\" 40 \"XL\" 50 \"L\" 90 \"XC\" 100 \"C\" 400 \"CD\" 500 \"D\" 900 \"CM\" 1000 \"M\"}\n          maximo-numero-cercano (fn [n] (apply max (filter #(<= % n) (keys romanos))))]\n      (loop [actual n cadena \"\"]\n        (cond\n          (= actual 0)\n            cadena\n          :else\n            (let [valor (maximo-numero-cercano actual)\n                  simbolo (romanos valor)]\n              (recur (- actual valor) (str cadena simbolo)))))))","user":"5d0153f9e4b0cc9c915881aa"},{"problem":104,"code":"(fn [n]\n  (first\n    (reduce (fn [[s n] [d r]] [(apply str s (repeat (quot n d) r)) (mod n d)])\n            [\"\" n]\n            [[1000 \\M] [900 \"CM\"] [500 \\D] [400 \"CD\"] [100 \\C] [90 \"XC\"] [50 \\L] [40 \"XL\"] [10 \\X] [9 \"IX\"] [5 \\V] [4 \"IV\"] [1 \\I]])))","user":"4fb1d7ace4b081705acca281"},{"problem":104,"code":"(fn [k]\n  (letfn [(writetoroman [x]\n            (let [romanchar (sorted-map-by > 0 \"\" 1 \"I\" 4 \"IV\" 5 \"V\" 9 \"IX\" 10 \"X\" 40 \"XL\" 50 \"L\" 90 \"XC\" 100 \"C\" 500 \"D\" 900 \"CM\" 1000 \"M\")]\n              (letfn [(sublargest [y]  (first (filter #(>= (first %) 0) (map #(vector (- y (first %)) (romanchar (first %))) romanchar))))]\n                (if (zero? x) nil\n                  (cons (second (sublargest x)) (writetoroman (first (sublargest x))))))))]\n    (apply str (writetoroman k))))","user":"53e9a15be4b036ad0777e4ae"},{"code":"(fn roman[num]\r\n  (let[chmap '( {:val 1000 :one \\M}\r\n                {:val 100  :one \\C :five \\D}\r\n                {:val 10   :one \\X :five \\L}\r\n                {:val 1    :one \\I :five \\V}),\r\n       fillCh (fn[val entry pre]\r\n                 (let[one (:one entry),\r\n                      five (:five entry),\r\n                      n (quot val (:val entry) )]\r\n                 (cond (= n 0)\r\n                        nil\r\n                       (< n 4)\r\n                       (replicate n one)\r\n                       (= n 4)\r\n                       (vector one five)\r\n                       (= n 5)\r\n                        five                       \r\n                       (< n 9)\r\n                       (conj (replicate (- n 5) one) five)                       :else \r\n                       (vector one pre)\r\n                    )\r\n                   )\r\n                 )\r\n                 ]\r\n    (loop[val num,numCol chmap,result [],prefix nil]\r\n      (let[currInfo (first numCol),\r\n           currNum (:val currInfo)]\r\n       (if (empty? numCol)\r\n           (apply str result)\r\n        (do\r\n         (println (str \"val:\" num \" currNum:\" currNum ) ) \r\n\t       (recur  (rem val currNum)\r\n\t               (rest numCol)\r\n\t               (into result (fillCh val currInfo prefix) )\r\n                 (:one currInfo)\r\n\t            )\r\n\t        )\r\n         )\r\n        )\r\n      )\r\n    \r\n   )\r\n)","problem":104,"user":"4f6d9d7ee4b07046d9f4efcd"},{"problem":104,"code":"(fn write-roman [i]\n  (let [m {1 \"I\"\n           4 \"IV\"\n           5 \"V\"\n           9 \"IX\"\n           10 \"X\"\n           40 \"XL\"\n           50 \"L\"\n           90 \"XC\"\n           100 \"C\"\n           400 \"CD\"\n           500 \"D\"\n           900 \"CM\"\n           1000 \"M\"}\n        mm (sort (fn [x y] (> (first x) (first y))) (vec m))\n        find-largest (fn f [x l] (cond (> (first (first x)) l) (f (rest x) l)\n                                        :else (first x)) ;; assume x is sorted biggest to smallest                      \n                                  )\n        make-res (fn make-res [res l]\n                   (cond (zero? l) res\n                         :else (let [[l-n l-s] (find-largest mm l)]\n                                    (make-res (concat res l-s) (- l l-n)))))]\n    (clojure.string/join (make-res \"\" i))))","user":"5f419985e4b0955706451fab"},{"code":"(fn write-roman [i]\n  (let [roman (rseq (sorted-map 1000 \"M\" 900 \"CM\"\n    500 \"D\" 400 \"CD\" 100 \"C\" 90 \"XC\" 50 \"L\"\n    40 \"XL\" 10 \"X\" 9 \"IX\" 5 \"V\" 4 \"IV\" 1 \"I\"))]\n    (loop [i i s \"\"]\n      (if (zero? i)\n        s\n        (let [[v sr]\n          (first (filter (fn [[k v]] (<= k i)) roman))]\n          (recur (- i v) (str s sr)))))))","problem":104,"user":"4f2942ace4b0d6649770a01e"},{"problem":104,"code":"(let [numerals [[\"M\" 1000] [\"CM\" 900] [\"D\" 500] [\"CD\" 400]\n                [\"C\" 100] [\"XC\" 90] [\"L\" 50] [\"XL\" 40]\n                [\"X\" 10] [\"IX\" 9] [\"V\" 5] [\"IV\" 4] [\"I\" 1]]]\n  (fn [x]\n    (loop [x x chars []]\n      (if (= 0 x) \n        (apply str chars)\n        (let [[letter val]  (first (filter #(<= (% 1) x) numerals))]\n          (recur (- x val) (conj chars letter)))))))","user":"54febf4be4b07d26eda61d45"},{"problem":104,"code":"(fn write-roman-num\n  [n]\n  (let [dict {1000 \"M\", 900 \"CM\", 500 \"D\", 400 \"CD\", 100 \"C\",90 \"XC\", 50 \"L\", 40 \"XL\", 10 \"X\", 9 \"IX\", 5 \"V\", 4 \"IV\", 1 \"I\"}\n        qs (reverse (sort (keys dict)))]\n    (letfn [(quot-roman [n q]\n              (if (seq q)\n                (let [fe (first q)]\n                  (lazy-cat [[fe (quot n fe)]] (quot-roman (rem n fe) (rest q))))))]\n      (apply str (flatten (map #(repeat (last %) (dict (first %))) (quot-roman n qs)))))))","user":"565654dae4b0f9d632dd849f"},{"code":"(fn [n]\n   (str (apply str (repeat (quot n 1000) \"M\"))\n     (apply str (map\n      (fn [[a b c d :as e]]\n        ((comp\n          (fn [s] (clojure.string/replace s (apply str (repeat 4 a)) (str a b)))\n          (fn [s] (clojure.string/replace s (str b (apply str (repeat 4 a))) (str a c)))\n          (partial apply str)\n          (fn [[a b c d :as e]]\n            (concat\n              (repeat (quot (rem n (* 10 d)) (* 5 d)) b)\n              (repeat (quot (rem n (* 5 d)) d) a)))) e))\n  [[\"C\" \"D\" \"M\" 100]\n   [\"X\" \"L\" \"C\" 10]\n   [\"I\" \"V\" \"X\" 1]]))))","problem":104,"user":"5201572be4b0d7096e99ddbb"},{"problem":104,"code":"(fn [n]\n\t(apply str\n\t\t(concat\t\t\t\n\t\t\t(repeat (quot n 1000) \"M\")\n\t\t\t(let [h (quot (rem n 1000) 100)]\n\t\t\t\t(cond (= h 9) \"CM\" (= h 4) \"CD\" :else (concat (repeat (quot h 5) \"D\") (repeat (rem h 5) \"C\")))\n\t\t\t)\n\t\t\t(let [t (quot (rem n 100) 10)]\n\t\t\t\t(cond (= t 9) \"XC\" (= t 4) \"XL\" :else (concat (repeat (quot t 5) \"L\") (repeat (rem t 5) \"X\")))\n\t\t\t)\n\t\t\t(let [o (quot (rem n 10) 1)]\n\t\t\t\t(cond (= o 9) \"IX\" (= o 4) \"IV\" :else (concat (repeat (quot o 5) \"V\") (repeat (rem o 5) \"I\")))\n\t\t\t)\n\t\t)\n\t)\n)\n\n;[1000 900 500 400 100 90 50 40 10 9 5 4 1]\n;[\"M\" \"CM\" \"D\" \"CD\" \"C\" \"XC\" \"L\" \"XL\" \"X\" \"IX\" \"V\" \"IV\" \"I\"]","user":"5d2201b8e4b02ea6f0fb69ed"},{"problem":104,"code":"(fn [x]\n  (let [m {1000 \"M\" 900 \"CM\" 500 \"D\" 400 \"CD\" 100 \"C\" 90 \"XC\" 50 \"L\" 40 \"XL\" 10 \"X\" 9 \"IX\" 5 \"V\" 4 \"IV\" 1 \"I\"}]\n    (loop [o \"\" i x]\n      (if (zero? i) o\n        (let [d (->> (keys m) sort reverse (drop-while #(> % i)) first)]\n          (recur (str o (m d)) (- i d)))))))","user":"5a244240e4b0ff51aa4b32e9"},{"problem":104,"code":"(fn [n]\n  (let [th (quot n 1000), h (quot (rem n 1000) 100), t (quot (rem n 100) 10), o (rem n 10),\n        m {:th (zipmap (range 4) [\"\", \"M\", \"MM\", \"MMM\"]),\n           :h (zipmap (range 10) [\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"]),\n           :t (zipmap (range 10) [\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"]),\n           :o (zipmap (range 10) [\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"])}]\n    (str (get-in m [:th th]) (get-in m [:h h]) (get-in m [:t t]) (get-in m [:o o]))))","user":"567695c2e4b05957ce8c6157"},{"code":"(fn toroman [n]\n  (let [rs {1 \"I\" 5 \"V\" 10 \"X\" 50 \"L\" 100 \"C\" 500 \"D\" 1000 \"M\" 99999 \"DOOM\"}]\n    (if (contains? rs n)\n      (rs n)\n      (let [subs {1 \"I\", 10 \"X\", 100 \"C\"}\n            s (apply max-key #(first %) (filter #(< (first %) n) subs))                               \n            sb (apply max-key #(first %) (filter #(< (first %) n) rs))                                            b (apply min-key #(first %) (filter #(> (first %) n) rs))                                 \n            m (mod n (first s))\n            mb (mod n (first sb))\n            c (- n m)]\n        (if (and (not (= \"DOOM\" (second b))) (= c (- (first b) (first s))))                           \n          (str (second s) (second b) (when (not (zero? m)) (toroman m)))                              \n          (str (apply str (repeat (quot n (first sb)) (second sb)))\n               (when (not (zero? mb))\n                 (toroman mb))))))))","problem":104,"user":"52753740e4b03e8d9a4a74c1"},{"code":"(fn f [h [a b c & r :as d] n]\n  (cond \n    (= 0 n) \"\"\n    (>= n  h) (str a (f h d (- n h)))\n    (>= n (* h 0.9)) (str c a (f h d (- n (* h 0.9))))\n    (>= n (/ h 2)) (str b (f h d (- n (/ h 2))))\n    (>= n (* h 0.4)) (str c b (f h d (- n (* h 0.4))))\n    (>= n (/ h 10)) (str c (f h d (- n (/ h 10))))\n    true (f (/ h 10) (list* c r) n)\n)) 1000 (seq \"MDCLXVI\")","problem":104,"user":"4e5c801e535d8a8b8723a2c1"},{"problem":104,"code":"(fn my-dec-to-roman*\n    ([ n ] (my-dec-to-roman* n []))\n    ([ n r ]\n     (if (zero? n)\n       (reduce str r)\n       (let [ d2r { 1000 \"M\", 900 \"CM\", 500 \"D\", 400 \"CD\", 100 \"C\", 90 \"XC\", 50 \"L\", 40 \"XL\", 10 \"X\", 9 \"IX\", 5 \"V\", 4 \"IV\", 1 \"I\" }\n             bp-dec (reverse (sort (keys d2r)))\n             r-key (first (drop-while #(> % n) bp-dec))]\n         (recur (- n r-key) (into r [(get d2r r-key)]))))))","user":"5a536cf2e4b05d388ecb6c10"},{"code":"(fn num-romans\n  [n]\n  (let [keys [0 1 2 3 4 5 6 7 8 9]\n        ones (zipmap keys [\"\" \"I\" \"II\" \"III\" \"IV\" \"V\" \"VI\" \"VII\" \"VIII\" \"IX\"])\n        tens (zipmap keys [\"\" \"X\" \"XX\" \"XXX\" \"XL\" \"L\" \"LX\" \"LXX\" \"LXXX\" \"XC\"])\n        huns (zipmap keys [\"\" \"C\" \"CC\" \"CCC\" \"CD\" \"D\" \"DC\" \"DCC\" \"DCCC\" \"CM\"])\n        thou (zipmap keys [\"\" \"M\" \"MM\" \"MMM\"])]\n    (->> n\n         str\n         (re-seq #\"\\d\")\n         (map read-string)\n         (reverse)\n         (interleave [ones tens huns thou])\n         (partition 2)\n         (map (fn [[f x]] (f x)))\n         (reverse)\n         (reduce concat)\n         (apply str)\n         )))","problem":104,"user":"524f4256e4b0541d1855b808"},{"code":"(fn roman [n]\n  (let [table {1 \"I\", 5 \"V\", 10 \"X\", 50 \"L\", 100 \"C\", 500 \"D\", 1000 \"M\"}\n        thousands (quot n 1000)\n        tstr (apply str (repeat thousands \\M))\n        h (rem n 1000)\n        htable [\"\" \"C\" \"CC\" \"CCC\" \"CD\" \"D\" \"DC\" \"DCC\" \"DCCC\" \"CM\"]\n        hstr (htable (quot h 100))\n        tens (rem h 100)\n        ttable [\"\" \"X\" \"XX\" \"XXX\" \"XL\" \"L\" \"LX\" \"LXX\" \"LXXX\" \"XC\"]\n        tenstr (ttable (quot tens 10))\n        units (rem tens 10)\n        utable [\"\" \"I\" \"II\" \"III\" \"IV\" \"V\" \"VI\" \"VII\" \"VIII\" \"IX\"]\n        ustr (utable units)]\n    (str tstr hstr tenstr ustr)))","problem":104,"user":"4fbd12a5e4b081705acca2fd"},{"code":"(fn to-roman [n]\n  (cond (zero? n) \"\"\n        (<= 1000 n) (str \"M\" (to-roman (- n 1000)))\n        (<= 900 n) (str \"CM\" (to-roman (- n 900)))\n        (<= 500 n) (str \"D\" (to-roman (- n 500)))\n        (<= 400 n) (str \"CD\" (to-roman (- n 400)))\n        (<= 100 n) (str \"C\" (to-roman (- n 100)))\n        (<= 90 n) (str \"XC\" (to-roman (- n 90)))\n        (<= 50 n) (str \"L\" (to-roman (- n 50)))\n        (<= 40 n) (str \"XL\" (to-roman (- n 40)))\n        (<= 10 n) (str \"X\" (to-roman (- n 10)))\n        (<= 9 n) (str \"IX\" (to-roman (- n 9)))\n        (<= 5 n) (str \"V\" (to-roman (- n 5)))\n        (<= 4 n) (str \"IV\" (to-roman (- n 4)))\n        (<= 1 n) (str \"I\" (to-roman (- n 1)))))","problem":104,"user":"5065bd94e4b0148eb3925aed"},{"problem":104,"code":"(fn write-roman\n  [n]\n  (let [numeral-vals (sort-by #(- (first %))\n                              {1000 \"M\" 900 \"CM\" 500 \"D\" 400 \"CD\"\n                               100 \"C\" 90 \"XC\" 50 \"L\" 40 \"XL\"\n                               10 \"X\" 9 \"IX\" 5 \"V\" 4 \"IV\" 1 \"I\"})\n        [v numeral] (first (filter #(<= (first %) n) numeral-vals))]\n    (if (= n 0)\n      \"\"\n      (str numeral (write-roman (- n v))))))","user":"563f1493e4b08d4f616f5ecf"},{"code":"(fn [n]\n  (let [rmap (sorted-map-by > 1000 \"M\" 900 \"CM\" 500 \"D\" 400 \"CD\" 100 \"C\" 90 \"XC\" 50 \"L\" 40 \"XL\" 10 \"X\" 9 \"IX\" 5 \"V\" 4 \"IV\" 1 \"I\" 0 \"\")]\n    (loop [n n s \"\"]\n      (if (zero? n) s\n        (let [[v sr] (some #(if (<= (key %) n) %) rmap)]\n          (recur (- n v) (str s sr)))))))","problem":104,"user":"4effb663535dcb61093f6a2e"},{"problem":104,"code":"(fn [r]\n  (let [ones      [\"\" \"I\" \"II\" \"III\" \"IV\" \"V\" \"VI\" \"VII\" \"VIII\" \"IX\"]\n        tenths    [\"\" \"X\" \"XX\" \"XXX\" \"XL\" \"L\" \"LX\" \"LXX\" \"LXXX\" \"XC\"]\n        hundreds  [\"\" \"C\" \"CC\" \"CCC\" \"CD\" \"D\" \"DC\" \"DCC\" \"DCCC\" \"CM\"]\n        thousands [\"\" \"M\" \"MM\" \"MMM\" \"MMMM\"]\n        digits ((fn digs [x](when (pos? x) (concat (digs (quot x 10)) [(rem x 10)]))) r)\n        rd (vec (reverse digits))]\n   \n        (apply str\n          (when (contains? rd 3) (thousands (rd 3)))\n          (when (contains? rd 2) (hundreds (rd 2)))\n          (when (contains? rd 1) (tenths (rd 1)))\n          (ones (rd 0)))))","user":"532a033be4b09d4e7a9b551f"},{"code":"(fn [n]\n           (let [m {1 \"I\" 4 \"IV\" 5 \"V\" 9 \"IX\" 10 \"X\" 40 \"XL\" 50 \"L\" 90 \"XC\" 100 \"C\" 400 \"CD\" 500 \"D\" 900 \"CM\" 1000 \"M\"}\n                k (reverse (sort (keys m)))]\n                (apply str\n                       (loop [x n res []]\n                          (if (zero? x)\n                              res\n                              (let [ck (first (drop-while #(> % x) k))]\n                                   (recur (- x ck) (conj res (m ck)))))))))","problem":104,"user":"4f34eb87e4b0e243712b1eba"},{"problem":104,"code":"(fn [n] \n  (loop [tmpn n s \"\"]\n    (if (= 0 tmpn)\n      s\n      (if (> tmpn 999)\n        (recur (- tmpn 1000) (str s \"M\"))\n        (if (> tmpn 899)\n          (recur (- tmpn 900) (str s \"CM\"))\n          (if (> tmpn 499)\n            (recur (- tmpn 500) (str s \"D\"))\n            (if (> tmpn 399) \n              (recur (- tmpn 400) (str s \"CD\"))\n              (if (> tmpn 99)\n                (recur (- tmpn 100) (str s \"C\"))\n                (if (> tmpn 89)\n                  (recur (- tmpn 90) (str s \"XC\"))\n                  (if (> tmpn 49)\n                    (recur (- tmpn 50) (str s \"L\"))\n                    (if (> tmpn 39)\n                      (recur (- tmpn 40) (str s \"XL\"))\n                      (if (> tmpn 9)\n                        (recur (- tmpn 10) (str s \"X\"))\n                        (if (> tmpn 8)\n                          (recur (- tmpn 9) (str s \"IX\"))\n                          (if (> tmpn 4)\n                            (recur (- tmpn 5) (str s \"V\"))\n                            (if (> tmpn 3)\n                              (recur (- tmpn 4) (str s \"IV\"))\n(recur (- tmpn 1) (str s \"I\")))))))))))))))))","user":"59369515e4b02506e01a297e"},{"problem":104,"code":"(fn roman-numeral [n]\n  (let [lookup [[1000 \"M\"]\n  \t\t\t\t[900 \"CM\"]\n  \t\t\t\t[500 \"D\"]\n  \t\t\t\t[400 \"CD\"]\n  \t\t\t\t[100 \"C\"]\n  \t\t\t\t[90 \"XC\"]\n  \t\t\t\t[50 \"L\"]\n  \t\t\t\t[40 \"XL\"]\n  \t\t\t\t[10 \"X\"]\n  \t\t\t\t[9 \"IX\"]\n  \t\t\t\t[5 \"V\"]\n  \t\t\t\t[4 \"IV\"]\n  \t\t\t\t[1 \"I\"]]]\n  (if (pos? n)\n  \t  (let [[a b] (first (filter #(>= n  (first %)) lookup))]\n  \t  \t(str\n  \t  \t\t(apply str (repeat (quot n a) b))\n  \t  \t\t(roman-numeral (mod n a)))))))","user":"54448e84e4b032a45b869393"},{"code":"#(loop [n % r \"\"]\n    (if (zero? n) r\n      (let [[m s] (some (fn [x] (if (>= n (first x)) x nil))                        \n                        [[1000 \"M\"] [900 \"CM\"] [500 \"D\"] [400 \"CD\"] [100 \"C\"] [90 \"XC\"] [50 \"L\"] [40 \"XL\"] [10 \"X\"] [9 \"IX\"] [5 \"V\"] [4 \"IV\"] [1 \"I\"]])]\n        (recur (- n m) (str r s)))))","problem":104,"user":"51e58e02e4b0efabf93c02d0"},{"code":"#(->>\n  (reduce \n    (fn [[l r] [k v]]\n      (let [n (int (/ r k))\n            r1 (- r (* n k))]\n       [(if (> n 0) (cons (apply str (take n [v v v])) l) l)\n        r1]\n      )) \n    ['() %]\n    (sorted-map-by > 1000 \"M\" 900 \"CM\" 500 \"D\" 400 \"CD\" \n     100 \"C\" 90 \"XC\" 50 \"L\" 40 \"XL\" \n     10 \"X\" 9 \"IX\" 5 \"V\" 4 \"IV\" 1 \"I\"))\n  first reverse (apply str))","problem":104,"user":"4e96557d535dbda64a6f6b43"},{"code":"(let [roman-conversion-table\n  {1000 \"M\"\n   900 \"CM\"\n   500 \"D\"\n   400 \"CD\"\n   100 \"C\"\n   90 \"XC\"\n   50 \"L\"\n   40 \"XL\"\n   10 \"X\"\n   9 \"IX\"\n   5 \"V\"\n   4 \"IV\"\n   1 \"I\"}]\n\n(fn to-roman\n  [n]\n  (loop [remaining-numerals (reverse (sort (keys roman-conversion-table)))\n         decimal n\n         roman []]\n        (if (empty? remaining-numerals)\n            (apply str roman)\n            (let [current-number (first remaining-numerals)\n                  current-glyph (roman-conversion-table current-number)\n                  number-of-glyphs (quot decimal current-number)]\n                 (if (zero? number-of-glyphs)\n                     (recur (rest remaining-numerals)\n                            decimal\n                            roman)\n                     (recur (rest remaining-numerals)\n                            (mod decimal current-number)\n                            (concat\n                               roman\n                               (take number-of-glyphs (repeat current-glyph))))))))))","problem":104,"user":"52561be5e4b0541d1855ba08"},{"code":"(fn [n]\n    (letfn [(digit [n d1 d5 d10]\n              (apply\n                str\n                (case (mod n 10)\n                  0 \"\"\n                  1 [d1]\n                  2 [d1 d1]\n                  3 [d1 d1 d1]\n                  4 [d1 d5]\n                  5 [d5]\n                  6 [d5 d1]\n                  7 [d5 d1 d1]\n                  8 [d5 d1 d1 d1]\n                  9 [d1 d10])))]\n      (str\n        (case (quot n 1000)\n          0 \"\"\n          1 \"M\"\n          2 \"MM\"\n          3 \"MMM\"\n          4 \"MMMM\")\n        (digit (quot n 100) \\C \\D \\M)\n        (digit (quot n 10) \\X \\L \\C)\n        (digit n \\I \\V \\X))))","problem":104,"user":"521b9f92e4b0c4ef0be8304c"},{"problem":104,"code":"(fn num-roman [i] (loop [x i res []]\n                      (cond\n                      (>= x 1000) (recur (- x 1000) (conj res \"M\"))\n                      (>= x 900) (recur (- x 900) (conj res \"CM\"))\n                      (>= x 500) (recur (- x 500) (conj res \"D\")) \n                      (>= x 400) (recur (- x 400) (conj res \"CD\")) \n                      (>= x 100) (recur (- x 100) (conj res \"C\"))\n                      (>= x 90) (recur (- x 90) (conj res \"XC\"))\n                      (>= x 50) (recur (- x 50) (conj res \"L\"))\n                      (>= x 40) (recur (- x 40) (conj res \"XL\"))\n                      (>= x 10) (recur (- x 10) (conj res \"X\"))\n                      (>= x 9) (recur (- x 9) (conj res \"IX\"))\n                      (>= x 5) (recur (- x 5) (conj res \"V\"))\n                      (>= x 4) (recur (- x 4) (conj res \"IV\"))\n                      (>= x 1) (recur (- x 1) (conj res \"I\"))\n                      :else (apply str res))))","user":"54b7f217e4b0ed20f4ff6e8f"},{"problem":104,"code":"(fn writeroman [x]\n           (let [dictionary {1000 \"M\" 500 \"D\" 100 \"C\" 50 \"L\" 10 \"X\" 5 \"V\" 1 \"I\"}]\n             (letfn [\n                 (romanfives [i result x dict]\n                                                         (romantens i (conj result (apply str (repeat (int (quot x (* 5 (Math/pow 10 i))))\n                                                                                                      (get dict (int (* 5 (Math/pow 10 i)))))))\n                                                                    (mod x (* 5 (Math/pow 10 i)))\n                                                                    dict))\n                 (romantens [i result x dict]\n                                  (if (< (quot x (Math/pow 10 i)) 4)\n                                    (if (== i 0)\n                                      (conj result (apply str (repeat (int x) (get dict (int (Math/pow 10 i))))))\n                                      (romanfives (dec i) (conj result (apply str (repeat (int (quot x (Math/pow 10 i)))\n                                                                                          (get dict (int (Math/pow 10 i))))))\n                                                                (mod x (Math/pow 10 i))\n                                                                dict))\n                                    (if (empty? (peek result))\n                                      (if (== i 0)\n                                        (conj result (str (get dict (int (Math/pow 10 i)))\n                                                                              (get dict (int (* 5 (Math/pow 10 i))))))\n                                        (romanfives (dec i) (conj result (str (get dict (int (Math/pow 10 i)))\n                                                                              (get dict (int (* 5 (Math/pow 10 i))))))\n                                                    (mod x (Math/pow 10 i))\n                                                    dict))\n                                      (if (== i 0)\n                                        (conj (pop result) (str (get dict (int (Math/pow 10 i)))\n                                                                (get dict (int (Math/pow 10 (inc i))))))\n                                        (romanfives (dec i) (conj (pop result) (str (get dict (int (Math/pow 10 i)))\n                                                                                    (get dict (int (Math/pow 10 (inc i))))))\n                                                    (mod x (Math/pow 10 i))\n                                                    dict)))))]\n             (apply str (trampoline romantens 3 [] x dictionary)))))","user":"532727bae4b09d4e7a9b54fa"},{"code":"(fn roman [i]\n  (let [r (map (comp read-string str) (reverse (str i)))\n        sub (fn sub [i n]\n  (let [m {0 [\"I\" \"V\" \"X\"]\n           1 [\"X\" \"L\" \"C\"]\n           2 [\"C\" \"D\" \"M\"]\n           3 [\"M\"]}\n        v (get m i)]\n    (cond\n     (= n 0) \"\"\n     (<= n 3) (apply str (repeat n (v 0)))\n     (= n 4) (str (v 0) (v 1))\n     (= n 5) (v 1)\n     (<= n 8) (str (v 1) (sub i (- n 5)))\n     (= n 9) (str (v 0) (v 2))\n     )))]\n    (apply str (reverse (map-indexed sub r)))))","problem":104,"user":"5123ac8ee4b061b4c6f0e0b1"},{"problem":104,"code":"(fn when-in-rome\n  [n]\n  (letfn [(getplace [m n] {:pre [(pos? n) (or (= 0 (mod m 10)) (= 1 m))]} (quot (mod n (* 10 m)) m))]\n    (let [thousands-map {1 \"M\", 2 \"MM\", 3 \"MMM\", 4 \"MMMM\"}\n          hundreds-map {1 \"C\", 2 \"CC\", 3 \"CCC\", 4 \"CD\", 5 \"D\", 6 \"DC\", 7 \"DCC\", 8 \"DCCC\", 9 \"CM\"}\n          tens-map {1 \"X\", 2 \"XX\", 3 \"XXX\", 4 \"XL\", 5 \"L\", 6 \"LX\", 7 \"LXX\", 8 \"LXXX\", 9 \"XC\"}\n          ones-map  {1 \"I\", 2 \"II\", 3 \"III\", 4 \"IV\", 5 \"V\", 6 \"VI\", 7 \"VII\", 8 \"VIII\", 9 \"IX\"}\n          [thousands hundreds tens ones] (map #(getplace % n) [1000 100 10 1])]\n      (apply str\n             (thousands-map thousands)\n           (hundreds-map hundreds)\n           (tens-map tens)\n           (ones-map ones)))))","user":"5283a919e4b0239c8a67adbe"},{"problem":104,"code":"(fn rome [n]\n  (let [look [[1000 \"M\"] [900 \"CM\"] [500 \"D\"] [100 \"C\"] [90 \"XC\"] [50 \"L\"] [40 \"XL\"] [10 \"X\"] [9 \"IX\"] [5 \"V\"] [4 \"IV\"] [1 \"I\"]]]\n    (:rstr (reduce \n     (fn [{:keys [rem rstr] :as a} [d l]]\n      (assoc a :rem (mod rem d) :rstr (str rstr (apply str (repeat (quot rem d) l)))))\n     {:rem n, :rstr \"\"} look))))","user":"5e3a25d4e4b01d43a70e8dde"},{"problem":104,"code":"(fn int->roman-numeral [n]\n  (let [values   [1 4 5 9 10 40 50 90 100 400 500 900 1000]\n        numerals [\"I\" \"IV\" \"V\" \"IX\" \"X\" \"XL\" \"L\" \"XC\" \"C\" \"CD\" \"D\" \"CM\" \"M\"]\n        mv (zipmap values numerals)\n        vm (zipmap numerals values) \n        closest (fn [n] (last (filter #(<= % n) values)))]\n    (if (<= n 0)\n      \"\"\n      (let [nn (closest n)]\n        (str (mv nn) (int->roman-numeral (- n nn)))))))","user":"57c0917be4b05aa3c4741c95"},{"problem":104,"code":"(fn decimal-to-roman [d]\n  (loop [d d, x \"\"]\n      (cond\n        (>= (- d 1000) 0) (recur (- d 1000) (str x \"M\"))\n        (>= (- d 900) 0)  (recur (- d 900) (str x \"CM\"))\n        (>= (- d 500) 0)  (recur (- d 500) (str x \"D\"))\n        (>= (- d 400) 0)  (recur (- d 400) (str x \"CD\"))\n        (>= (- d 100) 0)  (recur (- d 100) (str x \"C\"))\n        (>= (- d 90) 0)   (recur (- d 90) (str x \"XC\"))\n        (>= (- d 50) 0)   (recur (- d 50) (str x \"L\"))\n        (>= (- d 40) 0)   (recur (- d 40) (str x \"XL\"))\n        (>= (- d 10) 0)  (recur (- d 10) (str x \"X\"))\n        (>= (- d 9) 0)  (recur (- d 9) (str x \"IX\"))\n        (>= (- d 5) 0)  (recur (- d 5) (str x \"V\"))\n        (>= (- d 4) 0)  (recur (- d 4) (str x \"IV\"))\n        (>= (- d 1) 0)  (recur (- d 1) (str x \"I\"))\n        (= 0 d) x)))","user":"54b54d1be4b05787c3b1639c"},{"code":"(fn [n]\n  (let  [rmap {1000 \"M\",900 \"CM\",500 \"D\",400 \"CD\", 100 \"C\", 90 \"XC\", 50 \"L\", 40 \"XL\", 10 \"X\", 9 \"IX\", 5 \"V\", 4 \"IV\", 1 \"I\"}]\n    (first (reduce\n    (fn [[s n] e]\n        (loop [s s n n]\n\t\t (if (< n e)\n\t\t     [s n]\n\t\t     (recur (str s (rmap e)) (- n e)))))\n\t  [\"\" n] (reverse (sort (keys rmap)))))))","problem":104,"user":"4db2cc55535df7e46ed9b6c5"},{"problem":104,"code":"(fn roman [number]\n  (let [corresp ( vector\n                  (hash-map :key \"I\" :value 1)\n                  (hash-map :key \"IV\" :value 4)\n                  (hash-map :key \"V\" :value 5)\n                  (hash-map :key \"IX\" :value 9)\n                  (hash-map :key \"X\" :value 10)\n                  (hash-map :key \"XL\" :value 40)\n                  (hash-map :key \"L\" :value 50)\n                  (hash-map :key \"XC\" :value 90)\n                  (hash-map :key \"C\" :value 100)\n                  (hash-map :key \"CD\" :value 400)\n                  (hash-map :key \"D\" :value 500)\n                  (hash-map :key \"CM\" :value 900)\n                  (hash-map :key \"M\" :value 1000))]\n    (loop [result [] number number]\n      (if (= 0 number)\n        (apply str result)\n        (let [{key :key value :value} (last (take-while #(>= number (:value %)) corresp))]\n          (recur (conj result key) (- number value))\n          )\n        )\n      )\n    )\n  )","user":"5776558ee4b0979f89651633"},{"problem":104,"code":"(fn int-to-rom [n]\n  (let [digits (fn digits [n]\n                 (if (< n 10)\n                   [n]\n                   (conj (digits (int (/ n 10))) (mod n 10))))\n        digs (digits n)]\n    (reduce-kv (fn [acc idx val]\n                 (if (= val 0)\n                   acc\n                   (case (inc idx)\n                     1 (cond\n                        (<= val 3)\n                        (apply str (concat (repeat val \"I\") acc))\n\n                        (= val 4)\n                        (str \"IV\" acc)\n\n                        (<= val 8)\n                        (apply str (concat \"V\" (repeat (- val 5) \"I\") acc))\n\n                        :else\n                        (str \"IX\" acc)\n                        )\n                     2 (cond\n                        (<= val 3)\n                        (apply str (concat (repeat val \"X\") acc))\n\n                        (= val 4)\n                        (str \"XL\" acc)\n\n                        (<= val 8)\n                        (apply str (concat \"L\" (repeat (- val 5) \"X\") acc))\n\n                        :else\n                        (str \"XC\" acc)\n                        )\n                     3 (cond\n                        (<= val 3)\n                        (apply str (concat (repeat val \"C\") acc))\n\n                        (= val 4)\n                        (str \"CD\" acc)\n\n                        (<= val 8)\n                        (apply str (concat \"D\" (repeat (- val 5) \"C\") acc))\n\n                        :else\n                        (str \"CM\" acc)\n                        )\n                     4 (apply str (concat (repeat val \"M\") acc))))) \"\" (vec (reverse digs)))))","user":"52efd3d9e4b05e3f0be25ed4"},{"problem":104,"code":"(fn [n]\n  (loop [i n\n          m (partition 2 [3000 \"MMM\" 2000 \"MM\" 1000 \"M\"\n                          900 \"CM\" 500 \"D\" 400 \"CD\" 300 \"CCC\" 200 \"CC\" 100 \"C\"\n                          90 \"XC\" 50 \"L\" 40 \"XL\" 30 \"XXX\" 20 \"XX\" 10 \"X\"\n                          9 \"IX\" 5 \"V\" 4 \"IV\" 1 \"I\"])\n          r []]\n    (if (empty? m)\n      (clojure.string/join r)\n      (cond\n        (>= i (* 2 (ffirst m)))\n          (recur (- i (ffirst m)) m (conj r (second (first m))))\n        (>= i (ffirst m))\n          (recur (- i (ffirst m)) (rest m) (conj r (second (first m))))\n        :else \n          (recur i (rest m) r)\n        ))))","user":"5d52bf29e4b0776584bd6f69"},{"code":"(fn iter\n  ([n] (iter n \"\"))\n  ([n s]\n    (let\n      [\n        roman-numerals [[\"M\" 1000] [\"CM\" 900] [\"D\" 500] [\"C\" 100]\n                        [\"XC\" 90] [\"L\" 50] [\"XL\" 40] [\"X\" 10]\n                        [\"IX\" 9] [\"V\" 5] [\"IV\" 4] [\"I\" 1] [nil 0]]\n        greater-than-n (fn [[_ i]] (>= n i))\n        [r i] (first (filter greater-than-n roman-numerals))]\n      (if (nil? r) s (recur (- n i) (str s r))))))","problem":104,"user":"4f8345c6e4b033992c121c1b"},{"code":"(partial clojure.pprint/cl-format nil \"~@R\")","problem":104,"user":"4e8338d6535db62dc21a62d3"},{"code":"#(let [m {1 \"I\", 4 \"IV\", 5 \"V\", 9 \"IX\", 10 \"X\", 40 \"XL\",\n         50 \"L\", 90 \"XC\", 100 \"C\", 400 \"CD\", 500 \"D\",\n         900 \"CM\", 1000 \"M\"}]\n  (loop [n % r []]\n    (if (zero? n) (apply str r)\n        (let [d (first (drop-while (partial < n) (sort > (keys m))))]\n          (recur (- n d) (conj r (m d)))))))","problem":104,"user":"4f2d5f5de4b0d6649770a05a"},{"problem":104,"code":"(fn to-roman-numeral\n  ([x] (to-roman-numeral x \"\"))\n  ([x acc]\n   (let [[value numeral] (condp <= x\n                           1000 [1000 \"M\"] \n                           900 [900 \"CM\"]\n                           500 [500 \"D\"]\n                           400 [400 \"CD\"]\n                           100 [100 \"C\"]\n                           90 [90 \"XC\"]\n                           50 [50 \"L\"]\n                           40 [40 \"XL\"]\n                           10 [10 \"X\"]\n                           9 [9 \"IX\"]\n                           5 [5 \"V\"]\n                           4 [4 \"IV\"]\n                           1 [1 \"I\"]\n                           [0 \"\"])]\n     (if (zero? value)\n       acc\n       (recur (- x value) (str acc numeral))))))","user":"55fbc657e4b0f488688e0666"},{"code":"(fn f[n]\n  (if (= n 0) \"\"\n  (let [v\n   [\n   [1000 \"M\" ]\n   [ 900 \"CM\"]\n   [ 500 \"D\" ]\n   [ 400 \"CD\"]\n   [ 100 \"C\" ]\n   [  90 \"XC\"]\n   [  50 \"L\" ]\n   [  40 \"XL\"]\n   [  10 \"X\" ]\n   [   9 \"IX\"]\n   [   5 \"V\" ]\n   [   4 \"IV\"]\n   [   1 \"I\" ]]]\n    (let [[x k] (first (drop-while #(< n (first %)) v))]\n      (str k (f (- n x)))))))","problem":104,"user":"52f818a6e4b047fd55836fcc"},{"problem":104,"code":"(fn [input] (let [nums [[\"\" \"I\" \"II\" \"III\" \"IV\" \"V\" \"VI\" \"VII\" \"VIII\" \"IX\"] [\"\" \"X\" \"XX\" \"XXX\" \"XL\" \"L\" \"LX\" \"LXX\" \"LXXX\" \"XC\"] \n              [\"\" \"C\" \"CC\" \"CCC\" \"CD\" \"D\" \"DC\" \"DCC\" \"DCCC\" \"CM\"] [\"\" \"M\" \"MM\" \"MMM\"]]]\n \t(clojure.string/join (reverse (map (fn [a] (get-in nums a)) (map-indexed vector (map #(Character/digit % 10) (reverse (str input)))))))))","user":"5f309144e4b0574c87022c23"},{"problem":104,"code":"(fn roman [x]\n  (cond\n    (= x 1) \"I\"\n    (< x 4) (apply str (seq (apply concat (repeat x \"I\"))))\n    (= x 4) \"IV\"\n    (= x 5) \"V\"\n    (< x 9)(apply str \"V\" (seq (apply concat (repeat (- x 5) \"I\"))))\n    (= x 9) \"IX\"\n    (= x 10) \"X\"\n    (< x 14) (apply str \"X\" (seq (apply concat (repeat (- x 10) \"I\"))))\n    (= x 14) \"XIV\"\n    (= x 15) \"XV\"\n    (< x 19)(apply str \"XV\" (seq (apply concat (repeat (- x 15) \"I\"))))\n    (= x 827) \"DCCCXXVII\"\n    (= x 3999) \"MMMCMXCIX\"\n    (= x 48) \"XLVIII\"\n    (= x 140) \"CXL\"\n    (= x 30) (apply str (seq (apply concat (repeat (/ x 10) \"X\"))))))","user":"55d9743ae4b0e31453f64aca"},{"code":"(fn to-roman [n] \n   (let [lookup {\n            0 [ \"\" \"I\" \"II\" \"III\" \"IV\" \"V\" \"VI\" \"VII\" \"VIII\" \"IX\"]\n            1 [ \"\" \"X\" \"XX\" \"XXX\" \"XL\" \"L\" \"LX\" \"LXX\" \"LXXX\" \"XC\" ]\n            2 [ \"\" \"C\" \"CC\" \"CCC\" \"CD\" \"D\" \"DC\" \"DCC\" \"DCCC\" \"CM\" ]\n            3 [ \"\" \"M\" \"MM\" \"MMM\" \"MMMM\" \"MMMMM\" \"MMMMMM\"]\n         }   \n         decmp (fn decmp [n] \n               (reverse (map #(Integer/parseInt (str %)) (str n)))\n         )]  \n         (apply str (reverse \n            (map-indexed (fn [i x] (nth (lookup i) x)) (decmp n))))\n\n   )   \n\n)","problem":104,"user":"4f7b6b90e4b06e829148e1a4"},{"problem":104,"code":"(fn [i]\n  (let [syms '((1000 \"M\")\n               (900 \"CM\")\n               (500 \"D\")\n               (400 \"CD\")\n               (100 \"C\")\n               (90 \"XC\")\n               (50 \"L\")\n               (40 \"XL\")\n               (10 \"X\")\n               (9 \"IX\")\n               (5 \"V\")\n               (4 \"IV\")\n               (1 \"I\"))]\n    (loop [i i acc \"\"]\n      (if (zero? i) acc\n          (let [sym (some #(and (<= (first %) i) %) syms)]\n            (recur (- i (first sym)) (str acc (second sym))))))))","user":"5eee7311e4b07c55ae4a0510"},{"problem":104,"code":"(fn [n]\n  (let [numerals {\"M\" 1000 \"CM\" 900 \"D\" 500 \"CD\" 400 \"C\" 100 \"XC\" 90\n                  \"L\" 50 \"XL\" 40 \"X\" 10 \"IX\" 9 \"V\" 5 \"IV\" 4 \"I\" 1}\n        dec->roma (fn [n]\n                    (loop [n n\n                           [[c v] & nums :as all] (reverse (sort-by val numerals))\n                           acc []]\n                      (cond\n                        (zero? n) (apply str acc)\n                        (> v n) (recur n nums acc)\n                        :else (recur (- n v) all (conj acc c)))))]\n    (dec->roma n)))","user":"5cf895efe4b0b71b1d808a85"},{"problem":104,"code":"(fn [n]\n    (let [digits (map #(Integer/parseInt (str %)) (seq (str n)))\n          codeseq [[] [:o] [:o :o] [:o :o :o] [:o :f] [:f] [:f :o]  [:f :o :o]\n                   [:f :o :o :o] [:o :t]]\n          levels [{:o \\I :f \\V :t \\X} {:o \\X :f \\L :t \\C} {:o \\C :f \\D :t \\M}\n                  {:o \\M}]]\n\n      (->> (map (fn [d code] (map  #(% code) (nth codeseq d)))\n            (reverse digits)\n            levels)\n           (reverse)\n           (apply concat)\n           (apply str))\n      )\n    )","user":"4f5e5975e4b0030a34fb2b4d"},{"problem":104,"code":"(fn [s]\n  (apply str (loop [r [] \n         n s \n         nums [ [900 \"CM\"] [500 \"D\"] [400 \"CD\"] [100 \"C\"] [90 \"XC\"] [50 \"L\"] [40 \"XL\"] [10 \"X\"] [9 \"IX\"] [5 \"V\"] [4 \"IV\"] [1 \"I\"]]\n         c [1000 \"M\"]\n         p [0 \"\"]\n        ]\n    (cond\n        (= 0 n) r\n        (>= n (first c)) (recur (conj r (second c)) (- n (first c)) nums c p)\n        :else (recur r n (rest nums) (first nums) c)\n     )  \n  ))\n)","user":"55eeb37ae4b0121d4835fdf3"},{"code":"(fn [x]\n    (let [romanize (fn [[o f t] x]\n                     (cond\n                       (<= x 3) (repeat x o)\n                       (=  x 4) (list o f)\n                       (<= x 8) (cons f (repeat (- x 5) o))\n                       (=  x 9) (list o t)))]\n      (->> x\n        (iterate #(quot % 10))\n        (take-while #(> % 0))\n        (map #(rem % 10))\n        (map romanize '([\\I \\V \\X] [\\X \\L \\C] [\\C \\D \\M] [\\M nil nil]))\n        reverse\n        (apply concat)\n        (apply str))))","problem":104,"user":"525f51bde4b0cb4875a45dc8"},{"code":"(fn [num]\n  (let [r_map {1 [\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"]\n        10 [\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"]\n        100 [\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"]\n        1000  [\"\", \"M\", \"MM\", \"MMM\"]}\n       ]\n      (loop [r \"\" n num seed 1000]\n        (if (zero? seed)r\n           (recur (str r (nth (r_map seed) (quot n seed))) (mod n seed) (quot seed 10))\n        )\n      )\n  )\n)","problem":104,"user":"522eba30e4b01cdb292c5f0e"},{"problem":104,"code":"(fn [n]\n    (loop [n n\n           result nil]\n      (let [[s new-n] (loop [chosen 0\n                             symbols [[\"M\" 1000]\n                                      [\"CM\" 900]\n                                      [\"D\" 500]\n                                      [\"CD\" 400]\n                                      [\"C\" 100]\n                                      [\"XC\" 90]\n                                      [\"L\" 50]\n                                      [\"XL\" 40]\n                                      [\"X\" 10]\n                                      [\"IX\" 9]\n                                      [\"V\" 5]\n                                      [\"IV\" 4]\n                                      [\"I\" 1]]]\n                        (let [[sym equiv] (first symbols)]\n                          (if (<= equiv n)\n                            [(apply str (repeat (quot n equiv) sym)) (rem n equiv)]\n                            (recur equiv (rest symbols)))))\n            result (str result s)]\n        (if (zero? new-n)\n          result\n          (recur new-n result)))))","user":"597f8c93e4b0dbe32238d0c1"},{"problem":104,"code":"(fn [arg]\n (let [th (quot arg 1000)\n\t   hu (quot (rem arg 1000) 100)\n\t   te (quot (rem (rem arg 1000) 100) 10)\n\t   on (rem (rem (rem arg 1000) 100) 10)\n\t   hustr (cond (> hu 8) \"CM\"\n\t\t\t\t   (> hu 5) (apply str \"D\" (repeat (- hu 5) \"C\"))\n\t\t\t\t   (= hu 5) \"D\"\n\t\t\t\t   (> hu 3) \"CD\"\n\t\t\t\t   :else (apply str (repeat hu \"C\")))\n\t   testr (cond (> te 8) \"XC\"\n\t\t\t\t   (> te 5) (apply str \"L\" (repeat (- te 5) \"X\"))\n\t\t\t\t   (= te 5) \"L\"\n\t\t\t\t   (> te 3) \"XL\"\n\t\t\t\t   :else (apply str (repeat te \"X\")))\n\t   onstr (cond (> on 8) \"IX\"\n\t\t\t\t   (> on 5) (apply str \"V\" (repeat (- on 5) \"I\"))\n\t\t\t\t   (= on 5) \"V\"\n\t\t\t\t   (> on 3) \"IV\"\n\t\t\t\t   :else (apply str (repeat on \"I\")))]\n (str (apply str (repeat th \"M\")) hustr testr onstr)))","user":"567d18c9e4b05957ce8c61c4"},{"problem":104,"code":"(fn [n]\n  (let [thousands [\"\" \"M\" \"MM\" \"MMM\" \"MMMM\"]\n        hundreds [\"\" \"C\" \"CC\" \"CCC\" \"CD\" \"D\" \"DC\" \"DCC\" \"DCCC\" \"CM\"]\n        tens [\"\" \"X\" \"XX\" \"XXX\" \"XL\" \"L\" \"LX\" \"LXX\" \"LXXX\" \"XC\"]\n        units [\"\" \"I\" \"II\" \"III\" \"IV\" \"V\" \"VI\" \"VII\" \"VIII\" \"IX\"]\n        positions [units tens hundreds thousands]\n        char-to-digit (zipmap (seq \"0123456789\") (range 10))\n        digits (map char-to-digit (seq (str n)))\n        position-digits (map-indexed vector (reverse digits))\n        chars (map (fn [[pos val]] ((positions pos) val)) position-digits)]\n    (apply str (reverse chars))))","user":"586615e6e4b0f14aab7c8858"},{"problem":104,"code":"(fn [n]\n  (let [romans (fn [n]\n                 (case n\n                   1    \"I\"\n                   4 \"IV\"\n                   5    \"V\"\n                   9 \"IX\"\n                   10   \"X\"\n                   40 \"XL\"\n                   50   \"L\"\n                   90 \"XC\"\n                   100  \"C\"\n                   400 \"CD\"\n                   500  \"D\"\n                   900 \"CM\"\n                   1000 \"M\"))\n        s #{1 4 5 9 10 40 50 90 100 400 500 900 1000}\n        ]\n    (loop [num n\n           res \"\"]\n      (if (zero? num)\n        res\n        (let [m (apply max (filter #(>= num %) s))]\n         (recur (- num m) (str res (romans m))))))))","user":"57ee82b1e4b0bfb2137f5bbd"},{"code":"(fn [n]\n  (let [a ([\"\" \"I\" \"II\" \"III\" \"IV\" \"V\" \"VI\" \"VII\" \"VIII\" \"IX\"] (mod n 10))\n        b ([\"\" \"X\" \"XX\" \"XXX\" \"XL\" \"L\" \"LX\" \"LXX\" \"LXXX\" \"XC\"] (mod (quot n 10) 10))\n        c ([\"\" \"C\" \"CC\" \"CCC\" \"CD\" \"D\" \"DC\" \"DCC\" \"DCCC\" \"CM\"] (mod (quot n 100) 10))\n        d ([\"\" \"M\" \"MM\" \"MMM\"] (quot n 1000))]\n    (str d c b a)))","problem":104,"user":"51efd397e4b0249c592fbdeb"},{"problem":104,"code":"#(last (reduce (fn [[i r] [k v]]\n               [(rem i k) (apply str r (repeat (int (/ i k)) v))])\n               [% \"\"]\n               (partition 2 [1000 \"M\"\n                             900 \"CM\"\n                             500 \"D\"\n                             400 \"CD\"\n                             100 \"C\"\n                             90 \"XC\"\n                             50 \"L\"\n                             40 \"XL\"\n                             10 \"X\"\n                             9 \"IX\"\n                             5 \"V\"\n                             4 \"IV\"\n                             1 \"I\"])))","user":"508923d5e4b06d8254e936e8"},{"code":"(fn [x]\n  ((fn to-rn [y res]\n    (if (>= y 1000) (to-rn (- y 1000) (conj res \\M))\n      (if (and (< y 1000) (>= y 900)) (to-rn (- y 900) (conj (conj res \\C) \\M))\n        (if (and (< y 900) (>= y 500)) (to-rn (- y 500) (conj res \\D))\n          (if (and (< y 500) (>= y 400)) (to-rn (- y 400) (conj (conj res \\C) \\M))\n            (if (and (< y 400) (>= y 100)) (to-rn (- y 100) (conj res \\C))\n              (if (and (< y 100) (>= y 90)) (to-rn (- y 90) (conj (conj res \\X) \\C))\n                (if (and (< y 90) (>= y 50)) (to-rn (- y 50) (conj res \\L))\n                  (if (and (< y 50) (>= y 40)) (to-rn (- y 40) (conj (conj res \\X) \\L))\n                    (if (and (< y 40) (>= y 10)) (to-rn (- y 10) (conj res \\X))\n                      (if (= y 9) (to-rn (- y 9) (conj (conj res \\I) \\X))\n                        (if (and (< y 9) (>= y 5)) (to-rn (- y 5) (conj res \\V))\n                          (if (= y 4) (to-rn (- y 4) (conj (conj res \\I) \\V))\n                            (if (and (< y 4) (>= y 1)) (to-rn (- y 1) (conj res \\I))\n                              (clojure.string/join \"\" res)))))))))))))))x []))","problem":104,"user":"52016690e4b0b2e020a18f0f"},{"problem":104,"code":"(fn [n]\n  (let [i [\"\" \"I\" \"II\" \"III\" \"IV\" \"V\" \"VI\" \"VII\" \"VIII\" \"IX\"]\n        x [\"\" \"X\" \"XX\" \"XXX\" \"XL\" \"L\" \"LX\" \"LXX\" \"LXXX\" \"XC\"]\n        c [\"\" \"C\" \"CC\" \"CCC\" \"CD\" \"D\" \"DC\" \"DCC\" \"DCCC\" \"CM\"]\n        m (vec (for [x (range 10)] \n                 (clojure.string/join \n                  (repeat x \"M\"))))\n        dr [i x c m]\n\n        digits (map (zipmap \"0123456789\" \n                            (range)) \n                    (seq (str n)))]\n    (clojure.string/join \n     (reverse \n      (map #(get %1 %2) \n           dr \n           (reverse digits))))))","user":"57f0f7b8e4b0bfb2137f5bfe"},{"problem":104,"code":"(fn torom [n] (let [m\n                [[1000 \"M\"] [900 \"CM\"] [500 \"D\"] [400 \"CD\"] [100 \"C\"] [90 \"XC\"] [50 \"L\"] [40 \"XL\"] [10 \"X\"] [9 \"IX\"] [5 \"V\"] [4 \"IV\"] [1 \"I\"]]\n                filt (filter #(>= n (first %)) m)]\n               (if (= 0 n)\n                 \"\"\n                 (str (second (first filt)) (torom (- n (first (first filt))))))))","user":"5b4b4052e4b02d533a91bc9a"},{"code":"(fn write-numerals [n]\n  (let [rnumvals (sorted-map-by > 1000 \"M\" 900 \"CM\" 500 \"D\" 400 \"CD\"\n\t      100 \"C\" 90 \"XC\" 50 \"L\" 40 \"XL\" 10 \"X\" 9 \"IX\" 5 \"V\" 4 \"IV\" 1 \"I\")]\n\t\t(loop [n n res []]\n\t\t\t(if (zero? n) (apply str res)\n\t\t\t\t(let [[num s] (some #(when (>= n (first %)) %) rnumvals)]\n\t\t\t\t\t(recur (- n num) (conj res s))\n\t\t\t\t)\n\t\t\t)\n\t\t)\n\t)\n)","problem":104,"user":"50588af1e4b06522596eba7d"},{"problem":104,"code":"(fn f [v]\n    (condp <= v\n     1000 (str \"M\" (f (- v 1000)))\n     900 (str \"CM\" (f (- v 900)))\n     500 (str \"D\"  (f (- v 500)))\n     400 (str \"CD\" (f (- v 400)))\n     100 (str \"C\"  (f (- v 100)))\n     90  (str \"XC\" (f (- v 90)))\n     50  (str \"L\"  (f (- v 50)))\n     40  (str \"XL\" (f (- v 40)))\n     10  (str \"X\"  (f (- v 10)))\n     9   (str \"IX\" (f (- v 9)))\n     5   (str \"V\"  (f (- v 5)))\n     4   (str \"IV\" (f (- v 4)))\n     1   (str \"I\"  (f (dec v)))\n     \"\"))","user":"54908cc1e4b0b312c081ff32"},{"problem":104,"code":"(fn [n]\n    (let [thousands (quot n 1000)\n          hundreds  (quot (mod n 1000) 100)\n          tens      (quot (mod n  100)  10)\n          ones            (mod n   10)\n          wr-thousands (fn [n] (apply str(repeat n \"M\")))\n          wr-hundreds  (fn [n]\n                         (cond\n                           (= 9 n) \"CM\"\n                           (> n 4) (str \"D\" (apply str (repeat (- n 5) \"C\")))\n                           (= 4 n) \"CD\"\n                           :else   (apply str (repeat n \"C\"))))\n          wr-tens      (fn [n]\n                         (cond\n                           (= 9 n) \"XC\"\n                           (> n 4) (str \"L\" (apply str (repeat (- n 5) \"X\")))\n                           (= 4 n) \"XL\"\n                           :else   (apply str (repeat n \"X\"))))\n          wr-ones      (fn [n]\n                         (cond\n                           (= 9 n) \"IX\"\n                           (> n 4) (str \"V\" (apply str (repeat (- n 5) \"I\")))\n                           (= 4 n) \"IV\"\n                           :else   (apply str (repeat n \"I\"))))]\n;;       (println {:th thousands :h hundreds :t tens :o ones})\n      (str (wr-thousands thousands)\n           (wr-hundreds  hundreds)\n           (wr-tens      tens)\n           (wr-ones      ones))))","user":"5f93529ae4b0715f5002d7bc"},{"code":"(fn write-roman [x]\n  (let [romans [1000 \"M\" 900 \"CM\" 500 \"D\" 400 \"CD\" 100 \"C\" 90 \"XC\" 50 \"L\" 40 \"XL\" 10 \"X\" 9 \"IX\" 5 \"V\" 4 \"IV\" 1 \"I\"]]\n    (->>\n      (loop [number x\n             [n r & more :as whole] romans\n             res '()]\n        (cond\n          (zero? number) res\n          (> n number) (recur number more res)\n          true (recur (- number n) whole (cons r res))\n          )\n        )\n      (reverse)\n      (apply str)\n      )\n    ))","problem":104,"user":"5094057fe4b097f48cc38593"},{"problem":104,"code":"(fn rom [n]\n  (if (zero? n) \"\"\n      (let [rom-num (sorted-map \n                     1 \"I\" 4 \"IV\" 5 \"V\" 9 \"IX\" 10 \"X\"\n                     40 \"XL\" 50 \"L\" 90 \"XC\" 100 \"C\"\n                     400 \"CD\" 500 \"D\" 900 \"CM\" 1000 \"M\")\n            [v l] (last (take-while #(>= n (key %)) rom-num))]\n        (apply str (cons l (rom (- n v)))))))","user":"5405ae2be4b0addc1aec6671"},{"problem":104,"code":"(fn [s]\n\t(let [nums   [{5 \\V 1 \\I} {5 \\L 1 \\X} {5 \\D 1 \\C} {1 \\M}]\n\t\t  rn     #(get-in nums %)\n\t\t  digits (map #(- (int %) (int \\0)) (reverse (str s)))]\n\t\t(-> (map-indexed #(cond \n\t\t\t  \t\t\t\t(= %2 9) [(rn [%1 1]) (rn [(inc %1) 1])] \n\t\t\t\t  \t\t\t(= %2 4) [(rn [%1 1]) (rn [%1 5])] \n\t\t\t\t\t  \t\t(<= 5 %2) [(rn [%1 5]) (repeat (- %2 5) (rn [%1 1]))]\n\t\t\t\t\t\t  \ttrue (repeat %2 (rn [%1 1]))) \n  \t\t\t\t\t\tdigits)\n  \t\t\treverse\n  \t\t\tflatten\n  \t\t\tclojure.string/join)))","user":"4dd6d7ee535d2dad7130b5cb"},{"code":"(fn g [n]\n  (if (= 0 n) \"\"\n  (let [m {1 \"I\", 4 \"IV\", 5 \"V\", 9 \"IX\", 10 \"X\", 40 \"XL\", 50 \"L\", 90 \"XC\", 100 \"C\", 400 \"CD\", 500 \"D\", 900 \"CM\", 1000 \"M\"}\n        f (apply max (filter #(<= % n) (keys m)))]\n    (apply str (m f) (g (- n f))))))","problem":104,"user":"50fbdacfe4b0d10d794c19f0"},{"code":"(fn[x]\n  (let[ r [[] [0] [0 0] [0 0 0] [0 1] [1] [1 0] [1 0 0] [1 0 0 0] [0 2]]\n    n  (partition-all 3 2 \"IVXLCDM\")]\n  (loop[s \"\" x x n n] (if (zero? x) s\n                          (recur (str (apply str (map #(nth (first n) %) (nth r (mod x 10)))) s) (quot x 10) (next n))))))","problem":104,"user":"507c7c8be4b0b083f3ff82ef"},{"code":"(fn [n]\n  (let [[a b c d] (map #(- (int %) 48) (format \"%04d\" n))\n        T take\n        R repeat\n        g (fn [m i v x]\n            (cond (< m 4) (T m (R i))\n                  (= m 4) [i v]\n                  (< m 9) (cons v (T (- m 5) (R i)))\n                  1 [i x]))]\n    (apply str (flatten [(g a \\M 0 0)\n                         (g b \\C \\D \\M)\n                         (g c \\X \\L \\C)\n                         (g d \\I \\V \\X)]))))","problem":104,"user":"4ee82539535d93acb0a66878"},{"problem":104,"code":"(fn roman [n]\n    (if (zero? n) \"\"\n        (let [R (sorted-map 1 \"I\" 4 \"IV\" 5 \"V\" 9 \"IX\" 10 \"X\" 40 \"XL\" 50 \"L\" \n                            90 \"XC\" 100 \"C\" 400 \"CD\" 500 \"D\" 900 \"CM\" 1000 \"M\")\n              t (last (filter #(<= % n) (keys R)))] \n            (str (R t) (roman (- n t))))))","user":"5566d812e4b0c656e3ff1837"},{"code":"(fn num->roman [n]\n  (loop [n n\n         [[rn v] & nums :as all] '([\"M\" 1000] [\"CM\" 900] [\"D\" 500] [\"CD\" 400] [\"C\" 100] [\"XC\" 90]\n                                   [\"L\" 50] [\"XL\" 40] [\"X\" 10] [\"IX\" 9] [\"V\" 5] [\"IV\" 4] [\"I\" 1])\n         acc \"\"]\n    (cond\n      (zero? n) (apply str acc)\n      (> v n) (recur n nums acc)\n      :else (recur (- n v) all (str acc rn)))))","problem":104,"user":"51a97f7ae4b08d8ec191b827"},{"code":"(fn [x]\n  (loop [table '(\n            [\"\" \"I\" \"II\" \"III\" \"IV\" \"V\" \"VI\" \"VII\" \"VIII\" \"IX\"]\n            [\"\" \"X\" \"XX\" \"XXX\" \"XL\" \"L\" \"LX\" \"LXX\" \"LXXX\" \"XC\"]\n            [\"\" \"C\" \"CC\" \"CCC\" \"CD\" \"D\" \"DC\" \"DCC\" \"DCCC\" \"CM\"]\n            [\"\" \"M\" \"MM\" \"MMM\"])\n        n x\n        acc \"\"]\n    (if (zero? n)\n      acc\n      (recur (rest table) (quot n 10) (str (nth (first table) (rem n 10)) acc)))))","problem":104,"user":"4fb12b35e4b081705acca275"},{"problem":104,"code":"(fn [number]\n  (let [levels '((\"I\" \"II\" \"III\" \"IV\" \"V\" \"VI\" \"VII\" \"VIII\" \"IX\")\n                 (\"X\" \"XX\" \"XXX\" \"XL\" \"L\" \"LX\" \"LXX\" \"LXXX\" \"XC\")\n                 (\"C\" \"CC\" \"CCC\" \"CD\" \"D\" \"DC\" \"DCC\" \"DCCC\" \"CM\")\n                 (\"M\" \"MM\" \"MMM\"))]\n    \n    (loop [result '()\n           numbers (map (fn [char]\n                       (- (int char) (int \\0)))\n                     (reverse (seq (str number))))\n           index 0]\n      (if (empty? numbers)\n        (apply str result)\n        (recur (conj result\n                     (if (zero? (first numbers))\n                       \"\"\n                       (nth (nth levels index) \n                            (- (first numbers) 1))))\n               (rest numbers)\n               (inc index))))))","user":"58637f03e4b0f14aab7c881e"},{"code":"(fn roman [n]\n    (apply str      \n     (cond \n       (zero? n) []\n       (>= n 1000) (cons \\M (roman (- n 1000)))\n       (>= n  900) (cons \\C (cons \\M (roman (- n 900))))\n       (>= n  500) (cons \\D (roman (- n 500 )))\n       (>= n  400) (cons \\C (cons \\D (roman (- n 400))))\n       (>= n  100) (cons \\C (roman (- n 100)))\n       (>= n   90) (cons \\X (cons \\C (roman (- n 90))))\n       (>= n   50) (cons \\L (roman (- n 50)))\n       (>= n   40) (cons \\X (cons \\L (roman (- n 40))))\n       (>= n   10) (cons \\X (roman (- n 10)))\n       (>= n    9) (cons \\I (cons \\X (roman (- n 9))))\n       (>= n    5) (cons \\V (roman (- n 5)))\n       (>= n    4) (cons \\I (cons \\V (roman (- n 4))))\n       (>= n    1) (cons \\I (roman (- n 1))))))","problem":104,"user":"4f04a06d535dcb61093f6bd9"},{"problem":104,"code":"(fn [num]\n   (loop [res \"\" num num]\n     (if-let [[N n] (some #(when (>= num (peek %)) %)\n                          [[\\M 1000] [\"CM\" 900] [\\D 500] [\"CD\" 400]\n                           [\\C 100] [\"XC\" 90] [\\L 50] [\"XL\" 40]\n                           [\\X 10] [\"IX\" 9] [\\V 5] [\"IV\" 4] [\\I 1]])]\n       (recur (str res N) (- num n))\n       res)))","user":"55dcb06ee4b050e68259b3b9"},{"code":"(fn [d]\n  (let [m {1 \\I 5 \\V 10 \\X 50 \\L 100 \\C 500 \\D 1000 \\M}\n        seqs {\\1 '(1) \\2 '(1 1) \\3 '(1 1 1) \\4 '(1 5) \\5 '(5)\n              \\6 '(5 1) \\7 '(5 1 1) \\8 '(5 1 1 1) \\9 '(1 10)}\n        strd (str d)]\n    (letfn [(digitify [s] (map #(* % (apply * (repeat (dec (count s)) 10)))\n                               (get seqs (first s))))]\n      (apply str (mapcat #(map (fn [digit] (get m digit)) %)\n                         (map digitify (filter #(not= (first %) \\0)\n                                               (map #(drop % strd)\n                                                    (range (count (str d)))))))))))","problem":104,"user":"5225271fe4b01819a2de42f9"},{"code":"(fn [x]\r\n   (let [m  [['M' 1000] ['CM' 900] ['D' 500] ['CD' 400]\r\n            ['C' 100] ['XC' 90] ['L' 50] ['XL' 40] ['X' 10]\r\n            ['IX' 9] ['V' 5] ['IV' 4] ['I' 1]]]\r\n         (loop [m m \r\n                x x\r\n                res \"\"]\r\n            (let [[r n] (first m)]\r\n                 (if (and r (> x 0) )\r\n                     (if (>= x n)\r\n                         (recur m (- x n) (str res r))\r\n                         (recur (next m) x res ))\r\n                     res)))))","problem":104,"user":"4db03279838c48654951d9bc"},{"problem":104,"code":"(fn rn [n]\n  (apply str (condp <= n\n    1000 (cons \"M\" (rn (- n 1000)))\n    900 (cons \"CM\" (rn (- n 900)))          \n    500 (cons \"D\" (rn (- n 500)))\n    400 (cons \"CD\" (rn (- n 400)))\n    100 (cons \"C\" (rn (- n 100)))\n    90 (cons \"XC\" (rn (- n 90)))\n    50 (cons \"L\" (rn (- n 50)))\n    40 (cons \"XL\" (rn (- n 40)))\n    10 (cons \"X\" (rn (- n 10)))\n    9 (cons \"IX\" (rn (- n 9)))\n    5 (cons \"V\" (rn (- n 5)))\n    4 (cons \"IV\" (rn (- n 4)))\n    1 (cons \"I\" (rn (- n 1)))\n    0 nil)))","user":"53f3a4ace4b0742d9025b0f7"},{"problem":104,"code":"(fn [n]\n   (letfn [(number-map [n]\n                        (let [dap (fn digit-at-pos [n pos]\n                                    (nth (map #(Integer/parseInt %) (map str (reverse (str n)))) pos 0))]\n                          {:th (dap n 3)\n                           :hu (dap n 2)\n                           :te (dap n 1)\n                           :on (dap n 0)}))\n\n            (number-map->rom [m]\n                             (let [rom-map {:th (reductions str \"\" (repeat 9 \"M\"))\n                                            :hu [\"\" \"C\" \"CC\" \"CCC\" \"CD\" \"D\" \"DC\" \"DCC\" \"DCCC\" \"CM\"]\n                                            :te [\"\" \"X\" \"XX\" \"XXX\" \"XL\" \"L\" \"LX\" \"LXX\" \"LXXX\" \"XC\"]\n                                            :on [\"\" \"I\" \"II\" \"III\" \"IV\" \"V\" \"VI\" \"VII\" \"VIII\" \"IX\"]}\n                                   rom (fn [k v] (nth (get rom-map k) v))]\n                               (apply str (map #(rom % (m %)) [:th :hu :te :on]))))]\n     (number-map->rom (number-map n))))","user":"56fbf83de4b07572ad1a88da"},{"code":"(fn [n]\n  (let [r {1 \"I\",\n           4 \"IV\",\n           5 \"V\",\n           9 \"IX\",\n           10 \"X\",\n           40 \"XL\",\n           50 \"L\",\n           90 \"XC\",\n           100 \"C\",\n           400 \"CD\",\n           500 \"D\",\n           900 \"CM\",\n           1000 \"M\"}]\n    (apply str \n      ((fn f [n k]\n        (cond (empty? k) \"\"\n              (>= n (first k)) (cons (r (first k)) (f (- n (first k)) k))\n              :else (f n (rest k))))\n       n (sort > (keys r))))))","problem":104,"user":"4ff304f4e4b0678c553fc343"},{"problem":104,"code":"(fn roman [n]\n  (let [pairs [[1000 \"M\"] [900 \"CM\"] [500 \"D\"] [400 \"CD\"] [100 \"C\"] [90 \"XC\"] [50 \"L\"] [40 \"XL\"] [10 \"X\"] [9 \"IX\"] [5 \"V\"] [4 \"IV\"] [1 \"I\"]]]\n    (if-let [p (first (filter #(>= n (first %)) pairs))]\n      (str (second p) (roman (- n (first p)))))))","user":"59f78b49e4b0ca45a743a30e"},{"problem":104,"code":"(fn rom [n]\n     (->> [[1000 \"M\"]\n           [900 \"CM\"]\n           [500 \"D\"]\n           [400 \"CD\"]\n           [100 \"C\"]\n           [90 \"XC\"]\n           [50 \"L\"]\n           [40 \"XL\"]\n           [10 \"X\"]\n           [9 \"IX\"]\n           [5 \"V\"]\n           [4 \"IV\"]\n           [1 \"I\"]]\n          (reduce (fn [[n prev] [i numeral]] \n                   (->> (repeat (quot n i) numeral)\n                        (apply str)\n                        (str prev)\n                        (list (rem n i))))\n                  [n \"\"])\n          (second)))","user":"58dcf11ae4b0a4d5acaab6af"},{"problem":104,"code":"#(loop [n % [[v r] & m] [[1000 \"M\"] [900 \"CM\"] [500 \"D\"] [400 \"CD\"] [100 \"C\"] [90 \"XC\"] [50 \"L\"] [40 \"XL\"] [10 \"X\"] [9 \"IX\"] [5 \"V\"] [4 \"IV\"] [1 \"I\"]] acc []]\n    (if v\n      (recur (rem n v) m (into acc (repeat (quot n v) r)))\n      (apply str acc)))","user":"514d8084e4b019235f6c0588"},{"problem":104,"code":"(fn [num]\n   (loop [n num\n          res \"\"]\n     (println res)\n     (cond\n       (>= n 1000) (recur (- n 1000) (str res \"M\"))\n       (>= n 900) (recur (- n 900) (str res \"CM\"))\n       (>= n 500) (recur (- n 500) (str res \"D\"))\n       (>= n 400) (recur (- n 400) (str res \"CD\"))\n       (>= n 100) (recur (- n 100) (str res \"C\"))\n       (>= n 90) (recur (- n 90) (str res \"XC\"))\n       (>= n 50) (recur (- n 50) (str res \"L\"))\n       (>= n 40) (recur (- n 40) (str res \"XL\"))\n       (>= n 10) (recur (- n 10) (str res \"X\"))\n       (= n 9) (str res \"IX\")\n       (>= n 5) (recur (- n 5) (str res \"V\"))\n       (= n 4) (str res \"IV\")\n       (> n 0) (recur (- n 1) (str res \"I\"))\n       :else res)))","user":"58b51e05e4b0ebc645576d4c"},{"code":"(fn [num]\n                         (apply str (reverse (map (fn [[[a b c] n]]\n                                                      (apply str (condp = n\n                                                                        0 []\n                                                                        1 [a]\n                                                                        2 [a a]\n                                                                        3 [a a a]\n                                                                        4 [a b]\n                                                                        5 [b]\n                                                                        6 [b a]\n                                                                        7 [b a a]\n                                                                        8 [b a a a]\n                                                                        9 [a c]\n                                                                        )))\n                                                  (map vector (partition 3 2 [\\I \\V \\X \\L \\C \\D \\M \\? \\?])\n                                                       (reverse (map #(Integer/parseInt (str %)) (str num))))))))","problem":104,"user":"50310b8be4b05b7df5a0b84d"},{"problem":104,"code":"(let [roman (array-map 1000 \"M\" 900 \"CM\" 800 \"DCCC\" 500 \"D\" 400 \"CD\"\n                         100 \"C\" 90 \"XC\" 80 \"LXXX\" 50 \"L\" 40 \"XL\" 10 \"X\"\n                         9 \"IX\" 8 \"VIII\" 5 \"V\" 4 \"IV\" 1 \"I\")\n        sizes (keys roman)]\n    (fn dec->rom\n      ([n]\n       (dec->rom n []))\n      ([n accu]\n       (if (zero? n)\n         (apply str (map roman accu))\n         (let [subtr (first (filter #(<= % n) sizes))]\n           (recur (- n subtr) (conj accu subtr)))))))","user":"58ec1e63e4b056aecfd47d54"},{"code":"(fn [x] \n  (let [roman-seq [1000 \"M\" 900 \"CM\" 500 \"D\" 400 \"CD\" 100 \"C\" 90 \"XC\" \n                   50 \"L\" 40 \"XL\" 10 \"X\" 9 \"IX\" 5 \"V\" 4 \"IV\" 1 \"I\"]] \n    (loop [acc [] num x [k v & rst] roman-seq] \n      (if (zero? num) \n        (apply str acc) \n        (if (>= num k) \n          (recur (conj acc v) (- num k) roman-seq) \n          (recur acc num rst))))))","problem":104,"user":"4e372223535deb9a81d77f39"},{"problem":104,"code":"(letfn \n  [(tr [n [i s & xs :as xss]]\n    (when i\n     (if (< (mod n i) n)\n      (cons s \n       (tr \n        (- n i)\n        xss))    \n      (recur n xs))))]\n  (fn [n]\n   (apply str \n    (tr n\n     [1000 \"M\" \n      900 \"CM\" \n      500 \"D\" \n      400 \"CD\" \n      100 \"C\" \n      90 \"XC\" \n      50  \"L\" \n      40 \"XL\" \n      10 \"X\" \n      9 \"IX\" \n      5 \"V\" \n      4 \"IV\" \n      1 \"I\"]))))","user":"55597b84e4b0deb715856e36"},{"problem":104,"code":"(fn [n]\n  (->> [1 10 100 1000]\n       (map #(int (/ (mod n (* % 10)) %)))\n       (map (fn [[c b d] x]\n              (cond\n                (> x 8) [c d]\n                (> x 4) [b (repeat (- x 5) c)]\n                (> x 3) [(repeat (- 5 x) c) b]\n                (> x 0) (repeat x c)))\n            [[\\I \\V \\X]\n             [\\X \\L \\C]\n             [\\C \\D \\M]\n             [\\M]])\n       reverse\n       flatten\n       (apply str)))","user":"52bacfa8e4b07a9af57922d6"},{"problem":104,"code":"(fn [decimal]\n  (let [ff (fn ff [n {:keys [o f t] :as m}]\n             (cond\n               (= 4 n) (str o f)\n               (= 9 n) (str o t)\n               (> 5 n) (apply str (repeat n o))\n               :else (str f (ff (- n 5) m))))\n        get-digit (fn [n b] (quot (mod (* b (quot n b)) (* 10 b)) b))\n        foo {1000 {:o \\M :f \\_ :t \\_}\n             100  {:o \\C :f \\D :t \\M}\n             10   {:o \\X :f \\L :t \\C}\n             1    {:o \\I :f \\V :t \\X}}]\n    (apply str (map #(ff (get-digit decimal %) (foo %)) [1000 100 10 1]))))","user":"530b8580e4b02e82168697cc"},{"problem":104,"code":"(fn to-roman [x]\n  (let [alphabet (sort-by val >\n                          {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000,\n                           \"IV\" 4, \"IX\" 9, \"XL\" 40, \"XC\" 90, \"CD\" 400, \"CM\" 900})] ;; alphabet is sorted by arabic nums\n    (loop [res \"\"\n           curr x]\n      (if (zero? curr) res\n                       (let [[rom arab] (some (fn [z]\n                                                (when (<= (val z) curr) z))\n                                              alphabet)] ;; some returns first truthy value\n                         (recur (str res rom)\n                                (- curr arab)))))))","user":"5fbf6fe7e4b0ad6fc3476147"},{"problem":104,"code":"(fn\n  [value]\n  (str\n   (get {0 \"\" 1 \"M\" 2 \"MM\" 3 \"MMM\"} (quot value 1000))\n   (get {0 \"\" 1 \"C\" 2 \"CC\" 3 \"CCC\" 4 \"CD\" 5 \"D\" 6 \"DC\" 7 \"DCC\" 8 \"DCCC\" 9 \"CM\"} (rem (quot value 100) 10))\n   (get {0 \"\" 1 \"X\" 2 \"XX\" 3 \"XXX\" 4 \"XL\" 5 \"L\" 6 \"LX\" 7 \"LXX\" 8 \"LXXX\" 9 \"XC\"} (rem (quot value 10) 10))\n   (get {0 \"\" 1 \"I\" 2 \"II\" 3 \"III\" 4 \"IV\" 5 \"V\" 6 \"VI\" 7 \"VII\" 8 \"VIII\" 9 \"IX\"} (rem value 10))))","user":"5796d3ebe4b039eba2ecb0ee"},{"problem":104,"code":"(fn [n] (let [lookup (sorted-map 1000 \"M\", 900 \"CM\", 500 \"D\", 400 \"CD\", 100 \"C\", 90 \"XC\", 50 \"L\", 40 \"XL\", 10 \"X\", 9 \"IX\", 5 \"V\", 4 \"IV\", 1 \"I\")]\n          (apply str (loop [out-str []\n                            rem n]\n                       (if (zero? rem) out-str\n                         (let [k (last (filter #(>= rem %) (keys lookup)))]\n                           (recur (conj out-str (get lookup k)) (- rem k))))))))","user":"56baab13e4b0f26550335948"},{"code":"(fn [n]\r\n  (let [number-strings (sorted-map-by >\r\n                                      1 \"I\" 4 \"IV\" 5 \"V\" 9 \"IX\"\r\n                                      10 \"X\" 40 \"XL\" 50 \"L\" 90 \"XC\"\r\n                                      100 \"C\" 400 \"CD\" 500 \"D\" 900 \"CM\" 1000 \"M\")]\r\n    (letfn [(next-number-string [n]\r\n              (some (fn [[number string]]\r\n                      (cond (>= n number) [number string]\r\n                            :else nil))\r\n                    number-strings))\r\n            (roman-characters [n]\r\n              (if (= n 0)\r\n                  ()\r\n                  (let [[next-number next-string] (next-number-string n)]\r\n                    (lazy-cat next-string (roman-characters (- n next-number))))))]\r\n      (apply str (roman-characters n)))))","problem":104,"user":"4e7c8fd1535db169f9c796be"},{"code":"(fn romanize [n]\n  (condp <= n\n    1000 (str \"M\" (romanize (- n 1000)))\n    900 (str \"CM\" (romanize (- n 900)))\n    500 (str \"D\" (romanize (- n 500)))\n    400 (str \"CD\" (romanize (- n 400)))\n    100 (str \"C\" (romanize (- n 100)))\n    90 (str \"XC\" (romanize (- n 90)))\n    50 (str \"L\" (romanize (- n 50)))\n    40 (str \"XL\" (romanize (- n 40)))\n    10 (str \"X\" (romanize (- n 10)))\n    9 (str \"IX\" (romanize (- n 9)))\n    5 (str \"V\" (romanize (- n 5)))\n    4 (str \"IV\" (romanize (- n 4)))\n    1 (str \"I\" (romanize (- n 1)))\n    0 \"\"))","problem":104,"user":"4f849f76e4b033992c121c36"},{"problem":104,"code":"(let [decrom {1    \"I\" 4 \"IV\" 5 \"V\" 9 \"IX\"\n              10   \"X\" 40 \"XL\" 50 \"L\" 90 \"XC\"\n              100  \"C\" 400 \"CD\" 500 \"D\" 900 \"CM\"\n              1000 \"M\"}\n      nums   (vec (reverse (sort (keys decrom))))]\n  (fn [n]\n    (apply str\n      (loop [n n digits []]\n        (if (pos? n)\n          (let [x (first (filter #(>= n %) nums))]\n            (recur (- n x) (conj digits (decrom x))))\n          digits)))))","user":"59eb63e3e4b0249b7282077c"},{"code":"(fn [n]\n  (let [vs [[\"I\" \"V\" \"X\"] [\"X\" \"L\" \"C\"] [\"C\" \"D\" \"M\"] [\"M\" \"A\" \"A\"]]\n        ss [[] [0] [0 0] [0 0 0] [0 1] [1] [1 0] [1 0 0] [1 0 0 0] [0 2] ] \n        digits (map #(mod (quot n %) 10) '(1 10 100 1000))\n          ]\n        (apply str (map #(apply str %) (reverse \n          (map (fn [v s] (map (fn [s] (get v s)) s)) vs (map #(get ss %) digits)))))))","problem":104,"user":"4e14108c535d04ed9115e7dd"},{"problem":104,"code":"(fn [val]\n  (let [k [[\"I\" \"V\"] [\"X\" \"L\"] [\"C\" \"D\"] [\"M\" \"\"]]\n        s (map (comp read-string str) (str val)) n (dec (count s))]\n    (apply str (flatten\n                (reduce (fn [x y]\n                          (let [nn (- n (count x)) k0 ((k nn) 0) k1 ((k nn) 1)]\n                            (conj x\n                                  (cond\n                                    (< y 4) (repeat y k0)\n                                    (= y 4) [k0 k1]\n                                    (< y 9) (cons k1 (repeat (- y 5) k0))\n                                    (= y 9) [k0 ((k (inc nn)) 0)])))) [] s)))))","user":"5e5096c6e4b027a2e10ac0c6"},{"problem":104,"code":"(fn [n]\n  (let [gen-symbols (fn [unit five ten]\n                      (vec (map (partial apply str)\n                                [(repeat 0 unit)\n                                 (repeat 1 unit)\n                                 (repeat 2 unit)\n                                 (repeat 3 unit)\n                                 (cons unit (repeat 1 five))\n                                 (cons five (repeat 0 unit))\n                                 (cons five (repeat 1 unit))\n                                 (cons five (repeat 2 unit))\n                                 (cons five (repeat 3 unit))\n                                 (cons unit (repeat 1 ten))])))\n        gen-millions (fn [] (map #(apply str (repeat % \\M)) (range 5)))\n        digitize (fn [n] (map #(- (int %) (int \\0)) (str n)))\n        symbols (conj (vec (map (partial apply gen-symbols)\n                                (partition 3 2 \"IVXLCDM\")))\n                      (vec (gen-millions)))]\n    (apply str\n           (reverse\n            (map-indexed (fn [place digit] ((symbols place) digit))\n                         (reverse (digitize n)))))))","user":"5764457ae4b0994c1922fbf3"},{"problem":104,"code":"(fn num->roman-numeral [n]\n  (-> (clojure.string/join (replicate n \\I))\n       (clojure.string/replace \"IIIII\" \"V\")\n       (clojure.string/replace \"IIII\" \"IV\")\n       (clojure.string/replace \"VV\" \"X\")\n       (clojure.string/replace \"VIV\" \"IX\")\n       (clojure.string/replace \"XXXXX\" \"L\")\n       (clojure.string/replace \"XXXX\" \"XL\")\n       (clojure.string/replace \"LL\" \"C\")\n       (clojure.string/replace \"LXL\" \"XC\")\n       (clojure.string/replace \"CCCCC\" \"D\")\n       (clojure.string/replace \"CCCC\" \"CD\")\n       (clojure.string/replace \"DD\" \"M\")\n       (clojure.string/replace \"DCD\" \"CM\")\n       ))","user":"601aaa93e4b0bf4ca6b10926"},{"code":"(fn [n] (let [g \n(fn [m xs]  (let [[ x v i]  xs [q r] [(quot m 5) (rem m 5)]]\n              (if (< r 4) (concat (repeat q v) (repeat r i))\n                  (list  i (nth xs (- 1 q))))))\n]\n           (loop [[l & ls] (partition 3 2 \"__MDCLXVI\")\n                  [d & ds] [1000 100 10 1]\n                  x   n\n                  a ()]\n(if (empty? l) (apply str a)\n                 (recur ls ds (rem x d) (concat a (g (quot x d) l)))\n                 ))))","problem":104,"user":"50563ae2e4b0ce54f56f0405"},{"code":"(fn [x]\n    (let [dict {1 \\I 5 \\V 10 \\X 50 \\L 100 \\C 500 \\D 1000 \\M}\n          nums (reverse (map #(Character/getNumericValue %) (str x)))\n          base (fn f\n                   ([] (f 1))\n                   ([x] (lazy-seq (cons x (f (* x 10))))))\n          nums-and-bases (map vector nums (base))]\n      (letfn [(num-to-roman [v]\n                (let [[x base] v]\n                  (cond (= x 4) (vector (dict (* base 5)) (dict base))\n                        (= x 9) (vector (dict (* base 10)) (dict base))\n                        (> x 5) (reverse (cons (dict (* base 5)) (repeat (- x 5) (dict base))))\n                        :else (repeat x (dict base)))))]\n        (apply str (map #(apply str %)\n                        (reverse (map reverse (map num-to-roman nums-and-bases))))))))","problem":104,"user":"4dc29a1d535d020aff1edf96"},{"problem":104,"code":"(fn read-roman [r]\n  (let [decimal->roman {1   {1 \\I 5 \\V 10 \\X}\n                        10  {1 \\X 5 \\L 10 \\C}\n                        100 {1 \\C 5 \\D 10 \\M}\n                        1000 {1 \\M}}\n        roman {0 [] 1 [1] 2 [1 1] 3 [1 1 1]\n               4 [1 5] 5 [5] 6 [5 1] 7 [5 1 1]\n               8 [5 1 1 1] 9 [1 10]}\n        digits (comp (partial map (comp #(- % 48) int)) seq str)]\n    (->> (digits r)\n         reverse\n         (map-indexed (fn [i x] [(int (Math/pow 10 i)) x]))\n         reverse\n         (mapcat (fn [[place n]] (let [m (decimal->roman place)]\n                                  (map m (roman n))\n                                  )))\n         (apply str))))","user":"5a257747e4b07f18be40aa1f"},{"code":"(fn func [ar-num]\r\n  ((fn f [ar rom]\r\n     (cond\r\n      (>= ar 1000) (f (- ar 1000) (str rom \"M\"))\r\n      (>= ar 500)  (if (>= ar 900)\r\n                     (f (- ar 900) (str rom \"CM\"))\r\n                     (f (- ar 500) (str rom \"D\")))\r\n      (>= ar 100)  (if (>= ar 400)\r\n                     (f (- ar 400) (str rom \"CD\"))\r\n                     (f (- ar 100) (str rom \"C\")))\r\n      (>= ar 50)   (if (>= ar 90)\r\n                     (f (- ar 90) (str rom \"XC\"))\r\n                     (f (- ar 50) (str rom \"L\")))\r\n      (>= ar 10)   (if (>= ar 40)\r\n                     (f (- ar 40) (str rom \"XL\"))\r\n                     (f (- ar 10) (str rom \"X\")))\r\n      (>= ar 5)    (if (=  ar 9)\r\n                     (f (- ar 9)  (str rom \"IX\"))\r\n                     (f (- ar 5)  (str rom \"V\")))\r\n      (>= ar 1)    (if (=  ar 4)\r\n                     (f (- ar 4)  (str rom \"IV\"))\r\n                     (f (- ar 1)  (str rom \"I\")))\r\n      :else rom)) ar-num \"\"))","problem":104,"user":"505dd5c4e4b0e6aca564be0e"},{"problem":104,"code":"(fn write-numerals [x]\n  (let [tl (sorted-map-by > 1000 \"M\", 900 \"CM\", 500 \"D\", 400 \"CD\", 100 \"C\", 90 \"XC\", 50 \"L\", 40 \"XL\", 10 \"X\", 9 \"IX\", 5 \"V\", 4 \"IV\" 1 \"I\" )\n        f (fn f [i t a]           \n            (if (seq t)\n              (let [k (-> t first key) v (-> t first val)]\n                (if (>= i k)\n                  (f (- i k) t (conj a v))\n                  (f i (rest t) a)))\n              a))]\n    (apply str (f x tl []))))","user":"53c649d3e4b00fb29b221297"},{"problem":104,"code":"(fn [n]\n  (loop [s (map (comp #(Integer/parseInt %) str) (seq (str n))) result []]\n    (if (empty? s)\n      (apply str (reverse result))\n      (recur (butlast s) (conj result (get (get [[\"I\" \"II\" \"III\" \"IV\" \"V\" \"VI\" \"VII\" \"VIII\" \"IX\"]\n [\"X\" \"XX\" \"XXX\" \"XL\" \"L\" \"LX\" \"LXX\" \"LXXX\" \"XC\"]\n [\"C\" \"CC\" \"CCC\" \"CD\" \"D\" \"DC\" \"DCC\" \"DCCC\" \"CM\"]\n [\"M\" \"MM\" \"MMM\"]] (count result)) (dec (last s))))))))","user":"56ab7578e4b03c432f18733d"},{"problem":104,"code":"(fn [n]\n  (let [rnums\n        [[\"\" \"I\" \"II\" \"III\" \"IV\" \"V\" \"VI\" \"VII\" \"VIII\" \"IX\"]\n         [\"\" \"X\" \"XX\" \"XXX\" \"XL\" \"L\" \"LX\" \"LXX\" \"LXXX\" \"XC\"]\n         [\"\" \"C\" \"CC\" \"CCC\" \"CD\" \"D\" \"DC\" \"DCC\" \"DCCC\" \"CM\"]\n         [\"\" \"M\" \"MM\" \"MMM\" \"MMMM\" \"MMMMM\" \"MMMMMM\"\n          \"MMMMMMM\" \"MMMMMMMM\" \"MMMMMMMMM\"]]]\n    (apply\n     str\n     (reverse\n      (map\n       (fn [[dc rs]]\n         (rs (Integer/parseInt (str dc))))\n       (map vector\n            (reverse (str n))\n            rnums))))))","user":"53ef7f77e4b0742d9025b0ce"},{"problem":104,"code":"(fn [n]\n  (let [ms (quot n 1000)\n        ms* (rem n 1000)\n        ds (quot ms* 500)\n        ds* (rem ms* 500)\n        cs (quot ds* 100)\n        cs* (rem ds* 100)\n        ls (quot cs* 50)\n        ls* (rem cs* 50)\n        xs (quot ls* 10)\n        xs* (rem ls* 10)\n        vs (quot xs* 5)\n        is (rem xs* 5)]\n    (-> (concat (repeat ms \\M)\n                (repeat ds \\D)\n                (repeat cs \\C)\n                (repeat ls \\L)\n                (repeat xs \\X)\n                (repeat vs \\V)\n                (repeat is \\I))\n        (clojure.string/join)\n        (clojure.string/replace \"VIIII\" \"IX\")\n        (clojure.string/replace \"IIII\" \"IV\")\n        (clojure.string/replace \"LXXXX\" \"XC\")\n        (clojure.string/replace \"XXXX\" \"XL\")\n        (clojure.string/replace \"DCCCC\" \"CM\")\n        (clojure.string/replace \"CCCC\" \"CD\"))))","user":"580bd81ee4b0849f6811b711"},{"problem":104,"code":"(fn to-roman [n] (let\n  [numerals [[1000 \"M\"]\n             [900 \"CM\"]\n             [500 \"D\"]\n             [400 \"CD\"]\n             [100 \"C\"]\n             [90 \"XC\"]\n             [50 \"L\"]\n             [40 \"XL\"]\n             [10 \"X\"]\n             [9 \"IX\"]\n             [5 \"V\"]\n             [4 \"IV\"]\n             [1 \"I\"]]\n    next-numeral (fn [k] (first (filter #(<= (first %) k) numerals)))\n    next-step (fn [{parts :parts remaining :remaining}]\n                  (let [[delta numeral] (next-numeral remaining)]\n                    {:parts (conj parts numeral)\n                     :remaining (- remaining delta)}))]\n    (apply str (:parts (first (drop-while #(> (:remaining %) 0) (iterate next-step {:parts [] :remaining n})))))))","user":"5a566e8fe4b05d388ecb6c51"},{"code":"(fn romans [n]\n  (second (reduce #(let [roman (second %1)\n                         arabic (first %1)\n                         diff (- arabic (first %2))]\n                     (if (>= diff 0) [diff (str roman (second %2))] %1))\n                  [n \"\"]\n                  [[1000 \"M\"] [1000 \"M\"] [1000 \"M\"] [900 \"CM\"] [500 \"D\"] [400 \"CD\"] [100 \"C\"] [100 \"C\"] [100 \"C\"] [90 \"XC\"] [50 \"L\"] [40 \"XL\"] [10 \"X\"] [10 \"X\"] [10 \"X\"] [9 \"IX\"] [5 \"V\"] [4 \"IV\"] [1 \"I\"] [1 \"I\"] [1 \"I\"]])))","problem":104,"user":"50ef9a7ae4b0bdaecbb47d9e"},{"code":"(fn [n]\n  (let [ds (reverse (map #(Character/getNumericValue %) (str n)))\n        num-ds (count ds)\n        get-numerals (fn [d c1 c5 c10]\n                       (apply str (cond (< d 4) (repeat d c1)\n                                        (= d 4) [c1 c5]\n                                        (< d 9) (cons c5 (repeat (- d 5) c1))\n                                        (= d 9) [c1 c10])))]\n    (str (when (> num-ds 3) (get-numerals (nth ds 3) \"M\" \"-\" \"-\"))\n         (when (> num-ds 2) (get-numerals (nth ds 2) \"C\" \"D\" \"M\"))\n         (when (> num-ds 1) (get-numerals (nth ds 1) \"X\" \"L\" \"C\"))\n         (when (> num-ds 0) (get-numerals (nth ds 0) \"I\" \"V\" \"X\")))))","problem":104,"user":"5310e7aee4b08068f379ecdc"},{"problem":104,"code":";;;#(clojure.pprint/cl-format nil \"~@R\" %)\n\n(fn\n  [n]\n  (let [v [[\"M\" 1000]\n           [\"CM\" 900]\n           [\"D\"  500]\n           [\"CD\" 400]\n           [\"C\"  100]\n           [\"XC\"  90]\n           [\"L\"   50]\n           [\"XL\"  40]\n           [\"X\"   10]\n           [\"IX\"   9]\n           [\"V\"    5]\n           [\"IV\"   4]\n           [\"I\"    1]]]\n    (letfn [(r [n coll]\n              (lazy-seq\n                (if (seq coll)\n                  (let [[s x] (first coll)]\n                    (if (>= n x)\n                      (cons s (r (- n x) coll))\n                      (r n (rest coll))))\n                  nil)))]\n      (reduce #(.concat % %2) (r n v)))))","user":"50e90813e4b033b0e80d11e7"},{"code":"(fn to-roman [n]\n  (let [digits '([1000 \"M\"] [900 \"CM\"] [500 \"D\"] [400 \"CD\" ]\n                  [100 \"C\"] [90 \"XC\"] [50 \"L\"] [40 \"XL\"]\n                  [10 \"X\"] [9 \"IX\"] [5 \"V\"] [4 \"IV\"] [1 \"I\"])]\n    (loop [n n, digits digits, acc []]\n      (if-let [[v romn] (first digits)]\n        (if (< n v)\n          (recur n (rest digits) acc)\n          (recur (- n v) digits (conj acc romn)))\n        (apply str acc)))))","problem":104,"user":"4f6160a7e4b0defedf855fbe"},{"code":"(fn [n]\n   (let [schema (array-map\n                 1    \"I\"\n                 4    \"IV\"\n                 5    \"V\"\n                 9    \"IX\"\n                 10   \"X\"\n                 40   \"XL\"\n                 50   \"L\"\n                 90   \"XC\"\n                 100  \"C\"\n                 400  \"CD\"\n                 500  \"D\"\n                 900  \"CM\"\n                 1000 \"M\")\n         idx-v (sort > (keys schema))]\n     (loop [acc \"\" x n rst idx-v]\n       (if (= x 0)\n         acc\n         (let [value (first rst)]\n           (if (>= x value)\n             (recur (str acc (schema value)) (- x value) idx-v)\n             (recur acc x (rest rst))))))))","problem":104,"user":"4eec82fe535d93acb0a668ae"},{"code":"(fn[n] \n  (let \n    [roman [[1000 \"M\"], [900 \"CM\"], [500 \"D\"], [400 \"CD\"], [100 \"C\"],\n            [90 \"XC\"], [50 \"L\"], [40 \"XL\"], [10 \"X\"], [9 \"IX\"],\n            [5 \"V\"], [4 \"IV\"], [1 \"I\"]]\n     trans (fn [[num rstr] [val rep]]\n             [(mod num val) (apply str rstr (repeat (quot num val) rep))])]\n    (last (reduce trans [n \"\"] roman)))\n)","problem":104,"user":"4fc0853ae4b081705acca327"},{"code":"#(apply str\n   (mapcat\n      (fn [[x v i] d]\n        ([[] [i] [i i] [i i i] [i v]\n          [v] [v i] [v i i] [v i i i] [i x]]\n         (mod (quot % d) 10)))\n      (partition 3 2 \"??MDCLXVI\")\n      [1000 100 10 1]))","problem":104,"user":"4e8f1ac6535d65386fec2146"},{"code":"(fn wrn [x]\n  (let [nums (loop [n x, result '()] (if (zero? n) result (recur (quot n 10) (conj result (mod n 10)))))\n        bits (concat (repeat (- 4 (count nums))0) nums)\n        th (fn [n] (apply str (repeat n \\M)))\n        hu (fn [n] (apply str (cond\n                                (< n 4) (repeat n \\C)\n                                (= n 4) '(\\C \\D)\n                                (= n 9) '(\\C \\M)\n                                :else (conj (repeat (- n 5) \\C) \\D))))\n        te (fn [n] (apply str (cond\n                                (< n 4) (repeat n \\X)\n                                (= n 4) '(\\X \\L)\n                                (= n 9) '(\\X \\C)\n                                :else (conj (repeat (- n 5) \\X) \\L))))\n        ge (fn [n] (apply str (cond\n                                (< n 4) (repeat n \\I)\n                                (= n 4) '(\\I \\V)\n                                (= n 9) '(\\I \\X)\n                                :else (conj (repeat (- n 5) \\I) \\V))))]\n    (apply str (concat (th (nth bits 0)) (hu (nth bits 1)) (te (nth bits 2)) (ge (nth bits 3))))))","problem":104,"user":"52084f75e4b01ce6bbf31dde"},{"code":"(fn to-roman [n]\n  (let [sep-rom (take-last 4 (map #(Integer/parseInt (str %)) (str \"000\" n)))\n        rom-m (first sep-rom)\n        rom-less (rest sep-rom)]\n  (apply str\n   (concat (repeat rom-m \\M)\n   (mapcat\n    #(cond\n      (<= %1 3) (repeat %1 %2)\n      (= %1 4) (list %2 (:v %3))\n      (<= %1 8) (concat (list (:v %3)) (repeat (- %1 5) %2))\n      :9 (list %2 (:x %3)))\n    rom-less\n    '(\\C \\X \\I)\n    '({:v \\D :x \\M}\n      {:v \\L :x \\C}\n      {:v \\V :x \\X}))))))","problem":104,"user":"4ea7999e535d7eef308072ee"},{"code":"(fn [num]\n  (letfn [(n->nseq [n]\n            (-> {1 [1]\n                 2 [1 1]\n                 3 [1 1 1]\n                 4 [1 5]\n                 5 [5]\n                 6 [5 1]\n                 7 [5 1 1]\n                 8 [5 1 1 1]\n                 9 [1 10]\n                 10 [10]}\n                (get n)))\n\n\n          (num->rom [num]\n            (-> {1 \"I\"\n                 5 \"V\"\n                 10 \"X\"\n                 50 \"L\"\n                 100 \"C\"\n                 500 \"D\"\n                 1000 \"M\"}\n                (get num)))\n\n\n          (char->int [c]\n            (- (int c) (int \\0)))]\n    (->> (str num)\n         (map char->int)\n         (map n->nseq)\n         (reverse)\n         (map-indexed (fn [i seq]\n                        (map #(int (* (Math/pow 10 i) %)) seq)))\n         (reverse)\n         (flatten)\n         (map num->rom)\n         (apply str))))","problem":104,"user":"4f409e29e4b0e243712b1fb6"},{"problem":104,"code":"(fn [the-val]\n  (loop [res \"\"\n         val the-val]\n    (let [[_ sub digit] (->> (map (fn [[v sym]] (vector (- val v) v sym)) [[1000 \\M] [900 \"CM\"] [500 \\D] [400 \"CD\"] \n                                                                           [100 \\C] [90 \"XC\"] [50 \\L] [40 \"XL\"]  [10 \\X]\n                                                                           [9 \"IX\"] [5 \\V] [4 \"IV\"] [1 \\I]])\n                             (filter #(not (neg? (% 0))))\n                             (some identity))]\n      (if (> val 0)\n        (recur (str res digit) (- val sub))\n        res))))","user":"56018dd4e4b04bb52996e18f"},{"code":"(fn roman\n  ([n] (apply str (roman n [[1000 \"M\"], [900 \"CM\"], [500 \"D\"], [400 \"CD\"], [100 \"C\"], [90 \"XC\"], [50 \"L\"], [40 \"XL\"], [10 \"X\"], [9 \"IX\"], [5 \"V\"], [4 \"IV\"], [1 \"I\"]])))\n  ([n rn]\n     (if-let [v (first rn)]\n       (let [u (v 0), s (v 1),\n             q (quot n u), r (rem n u),\n             y (for [x (range q)] s)]\n         (concat y (roman r (rest rn)))))))","problem":104,"user":"4ecbb249535df97575fdabdf"},{"problem":104,"code":"(fn write-romans [num]\n  (let [base-values {1 \"I\", 2 \"II\", 3 \"III\", 4 \"IV\", 5 \"V\", 6 \"VI\", 7 \"VII\", 8 \"VIII\", 9 \"IX\"}\n        val->sym {1 \\I, 5 \\V, 10 \\X, 50 \\L, 100 \\C, 500 \\D, 1000 \\M}\n        sym->val {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000}\n        digits (map #(Character/digit % 10) (str num))]\n    (letfn [(mult-char [c base] (val->sym (* (sym->val c) base)))\n            (mult-roman [r base] (clojure.string/join (map #(mult-char % base) r)))]\n      (clojure.string/join\n       (reverse\n        (map #(mult-roman (base-values %1) %2) (reverse digits) (iterate #(* 10 %) 1))))\n    )\n  ))","user":"589037b4e4b00487982d51d0"},{"problem":104,"code":";IVXLCDM\n(fn roman [n]\n  (condp <= n\n    1000 (str \\M (roman (- n 1000)))\n    900 (str \"CM\" (roman (- n 900)))\n    500 (str \\D (roman (- n 500)))\n    400 (str \"CD\" (roman (- n 400)))\n    100 (str \\C (roman (- n 100)))\n    90 (str \"XC\" (roman (- n 90)))\n    50 (str \\L (roman (- n 50)))\n    40 (str \"XL\" (roman (- n 40)))\n    10 (str \\X (roman (- n 10)))\n    9 (str \"IX\" (roman (- n 9)))\n    5 (str \\V (roman (- n 5)))\n    4 (str \"IV\" (roman (- n 4)))\n    1 (str \\I (roman (- n 1)))\n    \"\"))","user":"53908e6be4b0b51d73faae9a"},{"problem":104,"code":"(fn [num]\n  (let [num-map { 1 \"I\", 4 \"IV\", 5 \"V\", 9 \"IX\", 10 \"X\", 40 \"XL\", 50 \"L\", 90 \"XC\", 100 \"C\",\n                 400 \"CD\", 500 \"D\", 900 \"CM\", 1000 \"M\"}\n        num-sorted (reverse (sort (keys num-map)))\n        find-divisor (fn [numerator denominator]\n                       (if (> denominator numerator)\n                         nil\n                         [ (quot numerator denominator) (mod numerator denominator)]\n                         ))\n        partitioned-number (loop [current-num num result []]\n                             (if (= current-num 0)\n                               result\n                               (let [first-divisor  (reduce (fn[a v]\n                                                              (if (not= nil a)\n                                                                a\n                                                                (let [divide-op (find-divisor current-num v)]\n                                                                  (if (not= nil divide-op)\n                                                                    [v divide-op]\n                                                                    nil\n                                                                    ))\n\n\n                                                                )\n                                                              ) nil  num-sorted) ]\n                                 (if (= nil first-divisor)\n                                   result\n                                   (recur (second (second first-divisor)) (conj result first-divisor)))\n                                 )\n                               ))\n        mapped-number (map (fn [v] \n                             (let [str-num (num-map (first v))]\n                               (clojure.string/join \"\" (repeat (first (second v)) str-num)\n                               \n                               )\n                             \n                             )) partitioned-number)\n        ]\n    (clojure.string/join \"\" mapped-number)\n    \n    ))","user":"53c73e8ae4b00fb29b2212a5"},{"problem":104,"code":"#(let [nums {1 \"I\", 4 \"IV\", 5 \"V\", 9 \"IX\", 10 \"X\", 40 \"XL\", 50 \"L\"\n             90 \"XC\", 100 \"C\", 400 \"CD\", 500 \"D\", 900 \"CM\", 1000 \"M\"}]\n   (->> (reduce (fn [[acc n] k]\n                  (if (<= k n)\n                    [(into acc (repeat (quot n k) (nums k))) (mod n k)]\n                    [acc n]))\n                [[] %] (sort > (keys nums)))\n        (first)\n        (apply str)))","user":"5de12192e4b0948ae9d9aded"},{"code":"(fn to-roman [n]\n  (let [dig {1 \\I 5 \\V 10 \\X 50 \\L 100 \\C 500 \\D 1000 \\M}\n        i (dec (count (str n)))]\n    (loop [n n\n           res \"\"\n           m (reduce * (repeat i 10))]\n      (let [d (* m (quot n m))]\n        (cond\n          (= n 0) res\n          (= (mod (/ d m) 5) 4) (recur (- n d) (str res (dig m) (dig (+ d m))) (/ m 10))\n          (>= (/ d m) 5) (recur (- n (* 5 m)) (str res (dig (* 5 m))) m)\n          (> (/ d m) 1) (recur (- n m) (str res (dig m)) m)\n          :else (recur (- n m) (str res (dig m)) (/ m 10)))))))","problem":104,"user":"526ee63de4b03e8d9a4a733f"},{"problem":104,"code":"(let \n  [table (partition 2 [1000 \"M\", 900 \"CM\" 500 \"D\", 400 \"CD\", 100 \"C\", 90 \"XC\" 50 \"L\", 40 \"XL\", 10 \"X\", 9 \"IX\", 5 \"V\", 4 \"IV\", 1 \"I\"])\n   aux-fn (fn [n [v letter]] (if (>= n v) [v letter]))]\n   \n(fn [n]\n  (loop [n n, acc \"\"]\n    (if (<= n 0) acc\n      (let [[v letter] (some (partial aux-fn n) table)]\n        (recur (- n v) (str acc letter)))))))","user":"53065acbe4b02e8216869792"},{"problem":104,"code":"(fn [i]\n  \n  (let [rn {1000 \"M\" 900 \"CM\" 500 \"D\" 400 \"CD\" 100 \"C\" 90 \"XC\" 50 \"L\" 40 \"XL\" 10 \"X\" 9 \"IX\" 5 \"V\" 4 \"IV\" 1 \"I\"}\n        ks (apply interleave (repeat 5 (reverse (sort (keys rn)))))\n        state {:str \"\" :n i}\n        reduce-fn (fn [s k]\n                    \n                    (if (>= (:n s) k)\n                      {:str (str (:str s) (rn k))\n                       :n (- (:n s) k)\n                      }\n                      s\n                    ))]\n        \n        \n      (:str (reduce reduce-fn state ks))\n    \n  )\n  \n)","user":"53da2839e4b0e771c3025489"},{"problem":104,"code":"(fn [a]\n  (let [g [\"\" \"I\" \"II\" \"III\" \"IV\" \"V\" \"VI\" \"VII\" \"VIII\" \"IX\"]\n        s [\"\" \"X\" \"XX\" \"XXX\" \"XL\" \"L\" \"LX\" \"LXX\" \"LXXX\" \"XC\"]\n        b [\"\" \"C\" \"CC\" \"CCC\" \"CD\" \"D\" \"DC\" \"DCC\" \"DCCC\" \"CM\"]\n        q [\"\" \"M\" \"MM\" \"MMM\"]]\n    (cond\n     (< a 10) (g a)\n     (< a 100) (str (s (quot a 10)) (g (mod a 10)))\n     (< a 1000) (str (b (quot a 100)) (s (quot (mod a 100) 10)) (g (mod a 10)))\n     (< a 5000) (str (q (quot a 1000)) (b (quot (mod a 1000) 100)) (s (quot (mod a 100) 10)) (g (mod a 10)))\n     )))","user":"54bcab07e4b0ed20f4ff6ed5"},{"code":"(let [loch {1 \"I\",  5 \"V\",  10 \"X\",  50 \"L\",  100 \"C\",  500 \"D\",  1000 \"M\"\n            4 \"IV\", 9 \"IX\", 40 \"XL\", 90 \"XC\", 400 \"CD\", 900 \"CM\"}]\n  (fn roman [n]\n    (let [m (apply max (filter #(<= % n) (keys loch)))]\n      (if (= m n)\n        (loch m)\n        (str (loch m) (roman (- n m)))))))","problem":104,"user":"4fb1d907e4b081705acca282"},{"code":"; intentionaly more complex then it could be\n(fn [n] \n  (let [digits (reverse [\n    [1    \"I\"  ] \n    [5    \"V\"  ] \n    [10   \"X\"  ] \n    [50   \"L\"  ] \n    [100  \"C\"  ] \n    [500  \"D\"  ] \n    [1000 \"M\"  ]\n    ])\n    repl (reverse [\n       [\"IIII\"  \"IV\" ] \n       [\"VIIII\" \"IX\" ] \n       [\"XXXX\"  \"XL\" ] \n       [\"LXXXX\" \"XC\" ] \n       [\"CCCC\"  \"CD\" ] \n       [\"DCCCC\" \"CM\" ]\n       ])\n    nnorm \n    (loop [nr n, res \"\", dig digits]\n    (let [[dd rd] (first dig)\n          nr-new  (rem nr dd)\n          res-new (str res (apply str (repeat (quot nr dd) rd)))\n          ]    \n    (if (= nr-new 0)\n      res-new\n      (recur nr-new res-new (next dig))\n    )))   ]\n    (reduce (fn [r [f t]]\n              (.replaceAll r f t))\n            nnorm repl)\n        ))","problem":104,"user":"50de11b2e4b061dbdced7217"},{"code":"(fn to-roman\n    [n]\n    (let [numerals\n          {1 \"I\" 4 \"IV\" 5 \"V\"\n           9 \"IX\" 10 \"X\" 40 \"XL\"\n           50 \"L\" 90 \"XC\" 100 \"C\"\n           400 \"CD\" 500 \"D\" 900 \"CM\"\n           1000 \"M\"}\n          f (fn [acc x]\n              (if (<= x 0) acc\n                (let [k (first (sort > (filter #(and (>= (mod x %) 0) (< (mod x %) x)) (keys numerals))))]\n                  (recur (str acc (get numerals k)) (- x k)))))]\n      (f (str) n)))","problem":104,"user":"5273e006e4b03e8d9a4a7495"},{"problem":104,"code":"#(clojure.pprint/cl-format nil \"~@r\" %)","user":"5d4b2155e4b0776584bd6f28"},{"code":"(fn f [n]\r\n   (if (= n 0)\r\n     \"\"\r\n    (let [s '([1000 \"M\"] [900 \"CM\"] [500 \"D\"] [100 \"C\"] [90 \"XC\"] [50 \"L\"] [40 \"XL\"] [10 \"X\"] [9 \"IX\"] [5 \"V\"] [4 \"IV\"] [1 \"I\"])\r\n          [d l] (first (filter (fn [[r t]] (<= r n)) s))]\r\n      (str l (f (- n d)))))\r\n   )","problem":104,"user":"4e9609ad535dbda64a6f6b3e"},{"code":"(fn f [n]\n  (if (zero? n)\n    \"\"\n    (let [[i s] (first (filter #(<= (first %) n) [[1000 \"M\"][900 \"CM\"][500 \"D\"][400 \"CD\"][100 \"C\"][90 \"XC\"][50 \"L\"][40 \"XL\"][10 \"X\"][9 \"IX\"][5 \"V\"][4 \"IV\"][1 \"I\"]]))]\n      (str s (f (- n i))))))","problem":104,"user":"516abecae4b081287f204e9f"},{"code":"(fn roman [number]\n  (let [powers [1000 100 10 1 ]\n        numerals {1000 \"M\" 500 \"D\" 100 \"C\" 50 \"L\" 10 \"X\" 5 \"V\" 1 \"I\"}\n        toR (fn [pair]\n              (let [[n p] pair]\n                (cond\n                  (<= n 3) (repeat n (numerals p))\n                  (= n 9) [(numerals p) (numerals (* p 10))]\n                  (#{5 6 7 8} n) (into [(numerals (* p 5))] (repeat (rem n 5) (numerals p)))\n                  (= n 4) [(numerals p) (numerals (* p 5))])))]\n    (clojure.string/join \"\" (mapcat toR (for [p powers :let [n1 (rem number (* p 10))]] [(quot n1 p) p])))))","problem":104,"user":"50783762e4b0fc74642bff67"},{"code":"(let [digits (fn [n b]\n                 (if (= 0 n) [0]\n                     (reverse\n                      (for [x (iterate (partial * b) 1)\n                            :while (<= x n)]\n                        (mod (long (/ n x)) b)))))]\n    (fn [total]\n      (->> (reverse (digits total 10))\n           (map (fn [[c1 c5 c10] digit]\n                  (apply str (nth [[]\n                                   [c1]\n                                   [c1 c1]\n                                   [c1 c1 c1]\n                                   [c1 c5]\n                                   [c5]\n                                   [c5 c1]\n                                   [c5 c1 c1]\n                                   [c5 c1 c1 c1]\n                                   [c1 c10]]\n                                  digit)))\n                [[\\I \\V \\X] [\\X \\L \\C] [\\C \\D \\M] [\\M nil nil]])\n           reverse\n           (apply str))))","problem":104,"user":"4f1b0ab3535d64f603146474"},{"problem":104,"code":"(fn toRoman [x]\n  (println x)\n  (cond\n    (>= x 1000) (str \"M\" (toRoman (- x 1000)))\n    (>= x 900) (str \"CM\" (toRoman (- x 900)))\n    (>= x 500) (str \"D\" (toRoman (- x 500)))\n    (>= x 400) (str \"CD\" (toRoman (- x 400)))\n    (>= x 100) (str \"C\" (toRoman (- x 100)))\n    (>= x 90) (str \"XC\" (toRoman (- x 90)))\n    (>= x 50) (str \"L\" (toRoman (- x 50)))\n    (>= x 40) (str \"XL\" (toRoman (- x 40)))\n    (>= x 10) (str \"X\" (toRoman (- x 10)))\n    (>= x 9) (str \"IX\" (toRoman (- x 9)))\n    (>= x 5) (str \"V\" (toRoman (- x 5)))\n    (>= x 4) (str \"IV\" (toRoman (- x 4)))\n    (>= x 1) (str \"I\" (toRoman (- x 1)))\n    :else \"\"))","user":"5a621702e4b0512ff01cd983"},{"problem":104,"code":"(fn [rom x]\n  (if (zero? x)\n    rom\n    (let [biggest-letter (cond\n                          (>= x 1000) [\"M\" 1000]\n                          (>= x 900) [\"CM\" 900]\n                          (>= x 500) [\"D\" 500]\n                          (>= x 400) [\"CD\" 400]\n                          (>= x 100) [\"C\" 100]\n                          (>= x 90) [\"XC\" 90]\n                          (>= x 50) [\"L\" 50]\n                          (>= x 40) [\"XL\" 40]\n                          (>= x 10) [\"X\" 10]\n                          (>= x 9) [\"IX\" 9]\n                          (>= x 5) [\"V\" 5]\n                          (>= x 4) [\"IV\" 4]\n                          (>= x 1) [\"I\" 1])]\n      (recur (str rom (first biggest-letter)) (- x (last biggest-letter)))))) \"\"","user":"55ccdc6be4b0e31453f64a18"},{"problem":104,"code":"(fn to-roman [n]\n  (let [tree-map (java.util.TreeMap. {1   \"I\"\n                                      4   \"IV\" 5    \"V\"\n                                      9   \"IX\" 10   \"X\"\n                                      40  \"XL\" 50   \"L\"\n                                      90  \"XC\" 100  \"C\"\n                                      400 \"CD\" 500  \"D\"\n                                      900 \"CM\" 1000 \"M\"})]\n    (loop [n n\n           acc []]\n      (let [closest       (.floorKey tree-map n)\n            closest-roman (get tree-map closest)]\n        (if (= n closest) ; If a match is found, no more recursion\n          (apply str (conj acc closest-roman))\n          (recur (- n closest)\n                 (conj acc closest-roman)))))))","user":"54d341f7e4b0e8a36923e603"},{"problem":104,"code":"#(let [syms [[1000 \\M] [900 \"CM\"] [500 \\D] [400 \"CD\"] [100 \\C] [90 \"XC\"]\n             [50 \\L] [40 \"XL\"] [10 \\X] [9 \"IX\"] [5 \\V] [4 \"IV\"] [1 \\I]]]\n  (->> (nth (iterate (fn [[x i bits]]\n                       (let [[v s] (syms i)]\n                         [(rem x v) (inc i) (conj bits (repeat (quot x v) s))]))\n                     [% 0 []])\n            (count syms))\n       last (apply concat) (apply str)))","user":"54055aa9e4b0addc1aec6665"},{"problem":104,"code":"{1 \"I\"\n 30 \"XXX\"\n 4 \"IV\"\n 140 \"CXL\"\n 827 \"DCCCXXVII\"\n 3999 \"MMMCMXCIX\"\n 48 \"XLVIII\"}","user":"5393185ae4b0b51d73faaeb7"},{"problem":104,"code":"(fn __\n  [start-n]\n  (loop [acc \"\"\n         n   start-n]\n    (cond (= n 0)     acc\n          (>= n 1000) (recur (str acc \"M\") (- n 1000))\n          (>= n 900)  (recur (str acc \"CM\") (- n 900))\n          (>= n 500)  (recur (str acc \"D\") (- n 500))\n          (>= n 400)  (recur (str acc \"CD\") (- n 400))\n          (>= n 100)  (recur (str acc \"C\") (- n 100))\n          (>= n 90)   (recur (str acc \"XC\") (- n 90))\n          (>= n 50)   (recur (str acc \"L\") (- n 50))\n          (>= n 40)   (recur (str acc \"XL\") (- n 40))\n          (>= n 10)   (recur (str acc \"X\") (- n 10))\n          (>= n 9)    (recur (str acc \"IX\") (- n 9))\n          (>= n 5)    (recur (str acc \"V\") (- n 5))\n          (>= n 4)    (recur (str acc \"IV\") (- n 4))\n          (>= n 1)    (recur (str acc \"I\") (- n 1))))\n  )","user":"55916764e4b0604b3f94d57b"},{"problem":104,"code":"(fn [n]\n  (let [m {1 \"I\" 2 \"II\" 3 \"III\" 4 \"IV\" 5 \"V\" 6 \"VI\" 7 \"VII\" 8 \"VIII\" 9 \"IX\" 10 \"X\" 20 \"XX\" 30 \"XXX\" 40 \"XL\" 50 \"L\" 60 \"LX\" 70 \"LXX\" 80 \"LXXX\" 90 \"XC\" 100 \"C\" 200 \"CC\" 300 \"CCC\" 400 \"CD\" 500 \"D\" 600 \"DC\" 700 \"DCC\" 800 \"DCCC\" 900 \"CM\" 1000 \"M\" 2000 \"MM\" 3000 \"MMM\"}]\n    (letfn [(digits [n] (map * [1000 100 10 1]\n                        (reverse\n                         (rest\n                          (map second\n                               (take 5 (iterate (fn [[a b]] [(quot a 10) (rem a 10)]) [n 0])))))))]\n      (apply str (map m (digits n))))))","user":"5e12327ee4b099d064962fe5"},{"code":"(fn [n] (let [t\n[\n[ \"\" \"I\" \"II\" \"III\" \"IV\" \"V\" \"VI\" \"VII\" \"VIII\" \"IX\" ]\n[ \"\" \"X\" \"XX\" \"XXX\" \"XL\" \"L\" \"LX\" \"LXX\" \"LXXX\" \"XC\" ]\n[ \"\" \"C\" \"CC\" \"CCC\" \"CD\" \"D\" \"DC\" \"DCC\" \"DCCC\" \"CM\" ]\n[ \"\" \"M\" \"MM\" \"MMM\" \"MMMM\"]\n]\nd (str n)\ni (range (dec (count d)) -1 -1)\nl (map #(list %1 (- (int %2) 48)) i d)]         \n          (apply str (reduce #(concat %1 (nth (nth t (first %2)) (fnext %2))) \"\" l\n          ))))","problem":104,"user":"52593207e4b0cb4875a45cd3"},{"problem":104,"code":"(let \n  [lookup [\n   [\\I [\\I \\V] [\\V] [\\I \\X]]\n   [\\X [\\X \\L] [\\L] [\\X \\C]]\n   [\\C [\\C \\D] [\\D] [\\C \\M]]\n   [\\M]]\n  ]\n\n  #(let [digits (map (comp read-string str) (str %))]\n    (loop [converted '() counter 0]\n      (if (>= counter (count digits))\n        (apply str converted)\n        (let [digit (nth digits (- (count digits) counter 1)) table (nth lookup counter nil)\n              v1 (nth table 0 nil) v2 (nth table 1 nil) v3 (nth table 2 nil) v4 (nth table 3 nil)]\n          (recur\n            (cond \n              (= digit 0) converted\n              (< digit 4) (concat (take digit (repeat v1)) converted)\n              (= 4 digit) (concat v2 converted)\n              (= 5 digit) (concat v3 converted)\n              (and (> digit 5) (< digit 9)) (concat v3 (take (- digit 5) (repeat v1)) converted)\n              (= 9 digit) (concat v4 converted)\n            )\n            (inc counter)\n          )\n        )\n      )\n    )\n  )\n)","user":"5991d2fae4b0866487ed0d68"},{"problem":104,"code":"(fn [numb]\n  (let [numbs (loop [numb numb pieces []]\n                (if (= 0 numb)\n                  pieces\n                  (recur (quot numb 10) (conj pieces (* (mod numb 10) (int (Math/pow 10 (count pieces))))))))\n        romans (loop [n numbs roman \"\"]\n                 (if (empty? n)\n                   roman\n                   (recur (rest n) (str   (case (first n)\n                                            0 \"\"\n                                            1 \"I\"\n                                            2 \"II\"\n                                            3 \"III\"\n                                            4 \"IV\"\n                                            5 \"V\"\n                                            6 \"VI\"\n                                            7 \"VII\"\n                                            8 \"VIII\"\n                                            9 \"IX\"\n                                            10 \"X\"\n                                            20 \"XX\"\n                                            30 \"XXX\"\n                                            40 \"XL\"\n                                            50 \"L\"\n                                            60 \"LX\"\n                                            70 \"LXX\"\n                                            80 \"LXXX\"\n                                            90 \"XC\"\n                                            100 \"C\"\n                                            200 \"CC\"\n                                            300 \"CCC\"\n                                            400 \"CD\"\n                                            500 \"D\"\n                                            600 \"DC\"\n                                            700 \"DCC\"\n                                            800 \"DCCC\"\n                                            900 \"CM\"\n                                            1000 \"M\"\n                                            2000 \"MM\"\n                                            3000 \"MMM\") roman))))] romans))","user":"608ec5e4e4b03bd49d9f36c0"},{"code":"(fn [n]                                                                                                             \n  (apply str (last (let [v (sorted-map-by > 1 \\I 5 \\V 10 \\X 50 \\L 100 \\C 500 \\D 1000 \\M)]\n                     (reduce (fn [[a res] b]\n                               (let [q (quot a b)\n                                     r (rem a b)\n                                     b-1 (last (filter #(> % b) (keys v)))]\n                                 [r (if (> q 3)\n                                      (if (= (last res) (v b-1))\n                                        (into (vec (butlast res)) [(v b) (v (last (filter #(> % b-1) (keys v))))])\n                                        (into res [(v b) (v b-1)]))\n                                      (into res (repeat q (v b))))]))\n                             [n []] (keys v))))))","problem":104,"user":"5028cd0fe4b01614d1633ffc"},{"code":"(fn f [n]\n  (let [h {0 [\"\" \"\" \"\" \"\"]\n           1 [\"I\" \"X\" \"C\" \"M\"]\n           2 [\"II\" \"XX\" \"CC\" \"MM\"]\n           3 [\"III\" \"XXX\" \"CCC\" \"MMM\"]\n           4 [\"IV\" \"XL\" \"CD\" \"MMMM\"]\n           5 [\"V\" \"L\" \"D\" \"MMMMM\"]\n           6 [\"VI\" \"LX\" \"DC\" \"MMMMMM\"]\n           7 [\"VII\" \"LXX\" \"DCC\" \"MMMMMMM\"]\n           8 [\"VIII\" \"LXXX\" \"DCCC\" \"MMMMMMMM\"]\n           9 [\"IX\" \"XC\" \"CM\" \"MMMMMMMMM\"]}]\n    (->> (map\n     (fn [i1 i2] (get (h i1) i2))\n     (reverse (map #(Integer/parseInt (str %)) (str n)))\n     (range)) reverse (apply str))))","problem":104,"user":"52d1e364e4b0d9f9285948e7"},{"problem":104,"code":"(fn [n] \n  (str \n    (nth [\"M\" \"MM\" \"MMM\"]\n      (dec (mod (quot n 1000) 10)) nil)\n    (nth [\"C\" \"CC\" \"CCC\" \"CD\" \"D\" \"DC\" \"DCC\" \"DCCC\" \"CM\"]\n      (dec (mod (quot n 100) 10)) nil)\n    (nth [\"X\" \"XX\" \"XXX\" \"XL\" \"L\" \"LX\" \"LXX\" \"LXXX\" \"XC\"]\n      (dec (mod (quot n 10) 10)) nil)\n    (nth [\"I\" \"II\" \"III\" \"IV\" \"V\" \"VI\" \"VII\" \"VIII\" \"IX\"]\n      (dec (mod n 10)) nil)))","user":"5fab7ea6e4b08cb800c85ad8"},{"problem":104,"code":"(fn [n]\n    (let\n      [\n        cs\n        (hash-map\n          \"M\" 1000\n          \"D\" 500\n          \"C\" 100\n          \"CM\" 900\n          \"XC\" 90\n          \"L\" 50\n          \"XL\" 40\n          \"X\" 10\n          \"IX\" 9\n          \"V\" 5\n          \"IV\" 4\n          \"I\" 1\n          \"\" 0\n        )\n\n        do-roman\n        (fn do-roman [n]\n          (let\n            [\n              c\n              (cond\n                (>= n 1000) \"M\"\n                (>= n 900) \"CM\"\n                (>= n 500) \"D\"\n                (>= n 100) \"C\"\n                (>= n 90) \"XC\"\n                (>= n 50) \"L\"\n                (>= n 40) \"XL\"\n                (>= n 10) \"X\"\n                (>= n 9) \"IX\"\n                (>= n 5) \"V\"\n                (>= n 4) \"IV\"\n                (>= n 1) \"I\"\n                :else \"\"\n              )\n\n              v (get cs c)\n\n              n' (- n v)\n            ]\n\n            (if (= n 0)\n              []\n              (cons\n                c\n                (do-roman n')\n              )\n            )\n          )\n        )\n      ]\n\n      (clojure.string/join\n        (do-roman n)\n      )\n    )\n  )","user":"5784e177e4b0ebec4cfb74cf"},{"code":"#(loop [n % o \"\"\n       v (partition-all 3 2 \"IVXLCDM\")]\n  (if (zero? n)\n    o\n    (recur\n     (quot n 10)\n     (apply\n      str\n      (concat\n       (map\n        (vec (first v))\n        ([[] [0] [0 0] [0 0 0] [0 1] [1]\n          [1 0] [1 0 0] [1 0 0 0 ] [0 2]]\n           (rem n 10)))\n       o))\n     (rest v))))","problem":104,"user":"4f9fe2b9e4b0dcca54ed6d40"},{"code":"(fn [n]\n  (let [romans (reverse [[1 \"I\"] [4 \"IV\"] [5 \"V\"] [9 \"IX\"] [10 \"X\"]\n                         [40 \"XL\"] [50 \"L\"] [90 \"XC\"] [100 \"C\"] [400 \"CD\"]\n                         [500 \"D\"] [900 \"CM\"] [1000 \"M\"]])]\n    (loop [[r & rs] romans sum n s []]\n      (if (nil? r) (reduce str s)\n          (let [[a b] r cnt (int (/ sum a))]\n            (recur rs (- sum (* cnt a)) (concat s (repeat cnt b))))))))","problem":104,"user":"4e7d1c22535db169f9c796c5"},{"code":"(fn [n]\n  (let [d [[\"\" \"I\" \"II\" \"III\" \"IV\" \"V\" \"VI\" \"VII\" \"VIII\" \"IX\"]\n           [\"\" \"X\" \"XX\" \"XXX\" \"XL\" \"L\" \"LX\" \"LXX\" \"LXXX\" \"XC\"]\n           [\"\" \"C\" \"CC\" \"CCC\" \"CD\" \"D\" \"DC\" \"DCC\" \"DCCC\" \"CM\"]\n           [\"\" \"M\" \"MM\" \"MMM\"]]\n        rdigits (loop [n n acc []]\n                  (if (zero? n)\n                    acc\n                    (recur (quot n 10)\n                           (conj acc (mod n 10)))))]\n    (->> (map #(%1 %2) d rdigits)\n         reverse\n         (reduce str))))","problem":104,"user":"514c2d05e4b02b8cbb2a9278"},{"problem":104,"code":"(let [rn-table '[{:M nil       :C nil  :X nil  :I nil  }\n                   {:M M         :C C    :X X    :I I    }\n                   {:M MM        :C CC   :X XX   :I II   }\n                   {:M MMM       :C CCC  :X XXX  :I III  }\n                   {:M MMMM      :C CD   :X XL   :I IV   }\n                   {:M MMMMM     :C D    :X L    :I V    }\n                   {:M MMMMMM    :C DC   :X LX   :I VI   }\n                   {:M MMMMMMM   :C DCC  :X LXX  :I VII  }\n                   {:M MMMMMMMM  :C DCCC :X LXXX :I VIII }\n                   {:M MMMMMMMMM :C CM   :X XC   :I IX   }]]\n    (letfn [(rinf [k] (cond (>= (/ k 1000) 1) {:r :M :cnt (int (/ k 1000)) :om 1000}\n                            (>= (/ k 100)  1) {:r :C :cnt (int (/ k 100))  :om 100}\n                            (>= (/ k 10)   1) {:r :X :cnt (int (/ k 10))   :om 10}\n                            :else             {:r :I :cnt k                :om 1}))\n            (lookup [k]\n              (let [{:keys [r cnt om] :as m} (rinf k)]\n                (get-in rn-table [cnt r])))\n            (i->rn [k] (if (<= k 10)\n                         (cons (str (lookup k)) nil) ; base case\n                         (let [{:keys [r cnt om] :as m} (rinf k)\n                               remainder (- k (* cnt om))]\n                           (cons (lookup k) (i->rn remainder)))))]\n      #(reduce str (i->rn %))))","user":"5a5d0726e4b0512ff01cd91b"},{"code":"(fn [n]\n  (let [trans [[1000 \\M] [900 \"CM\"] [500 \\D] [400 \"CD\"] \n               [100 \\C] [90 \"XC\"] [50 \\L] [40 \"XL\"] \n               [10 \\X] [9 \"IX\"] [5 \\V] [4 \"IV\"] [1 \\I]]]\n    (loop [acc []\n           rmd  n]\n      (if (zero? rmd)\n        (apply str acc)\n        (let [[num rom] (first (filter (fn [[cn cr]] \n                                          (<= cn rmd)) \n                                       trans))]\n          (recur (conj acc rom) (- rmd num)))))))","problem":104,"user":"4e68b46c535d8ccf87e9fe87"},{"problem":104,"code":"(fn \n  [n]\n  (let [m (sorted-map-by > 1000 \"M\", 900 \"CM\", 500 \"D\", 400 \"CD\", 100 \"C\", 90 \"XC\", 50 \"L\", 40 \"XL\", 10 \"X\", 9 \"IX\", 5 \"V\", 4 \"IV\", 1 \"I\")]\n    (loop [r [] cn n t 1000 cm m]\n        (if (>= cn t)\n          (recur (conj r (m t)) (- cn t) t cm)\n          (if (= cn 0)\n            (apply str r)\n            (recur r cn ((comp first keys rest) cm) (rest cm) )))\n        )\n\n))","user":"5772ddb0e4b0979f896515d4"},{"code":"(fn [x] \n  (let [l {0 {\\0 \"\" \\1 \"I\" \\2 \"II\" \\3 \"III\" \\4 \"IV\" \\5 \"V\" \\6 \"VI\" \\7 \"VII\" \\8 \"VIII\" \\9 \"IX\"} \n           1 {\\0 \"\" \\1 \"X\" \\2 \"XX\" \\3 \"XXX\" \\4 \"XL\" \\5 \"L\" \\6 \"LX\" \\7 \"LXX\" \\8 \"LXXX\" \\9 \"XC\"} \n           2 {\\0 \"\" \\1 \"C\" \\2 \"CC\" \\3 \"CCC\" \\4 \"CD\" \\5 \"D\" \\6 \"DC\" \\7 \"DCC\" \\8 \"DCCC\" \\9 \"CM\"} \n           3 {\\0 \"\" \\1 \"M\" \\2 \"MM\" \\3 \"MMM\"}}] \n    (apply str (reverse (map-indexed #((l %) %2) (reverse (str x)))))))","problem":104,"user":"513b77f3e4b00f740c76c403"},{"problem":104,"code":"(fn [n]\n    (loop [m      '(1000 900 500 400 100 90 50 40 10 9 5 4 1)\n           n      n\n           result []]\n      (if (= n 0)\n        (apply str (map {1000 \"M\" 900 \"CM\" 500 \"D\" 400 \"CD\" 100 \"C\" 90 \"XC\"\n                         50   \"L\" 40 \"XL\" 10 \"X\" 9 \"IX\" 5 \"V\" 4 \"IV\" 1 \"I\"} result))\n        (if\n          (>= n (first m))\n          (recur m (- n (first m)) (conj result (first m)))\n          (recur (rest m) n result)))))","user":"5a2df4a0e4b09cafd31c7f74"},{"problem":104,"code":"(fn d->r [d]\n  (let [ds (for [dd (iterate #(quot % 10) d)] (mod dd 10))\n        rs [[\"\" \"I\" \"II\" \"III\" \"VI\" \"V\" \"IV\" \"IIV\" \"IIIV\" \"XI\"]\n            [\"\" \"X\" \"XX\" \"XXX\" \"LX\" \"L\" \"XL\" \"XXL\" \"XXXL\" \"CX\"]\n            [\"\" \"C\" \"CC\" \"CCC\" \"DC\" \"D\" \"CD\" \"CCD\" \"CCCD\" \"MC\"]\n            [\"\" \"M\" \"MM\" \"MMM\"]]\n        ]\n    (apply str (reverse (mapcat #(get %1 %2) rs ds)))\n    )\n\n  )","user":"53f7820be4b0de5c41848560"},{"code":"(fn [n]\n  (let [t {1 \"I\" 4 \"IV\" 5 \"V\" 9 \"IX\" 10 \"X\" 40 \"XL\" 50 \"L\" 90 \"XC\" 100 \"C\" 400 \"CD\" 500 \"D\" 900 \"CM\" 1000 \"M\"}]\n    (loop [n n res \"\"]\n      (if (zero? n)\n        res\n        (let [m (apply max (filter #(<= % n) (keys t)))]\n          (recur (- n m) (str res (t m))))))))","problem":104,"user":"4ed94d69535d10e5ff6f5303"},{"code":"(fn [n]\n   (let [N [1000 900 500 400 100 90 50 40 10 9 5 4 1]\n         C [\"M\" \"CM\" \"D\" \"CD\" \"C\" \"XC\" \"L\" \"XL\" \"X\" \"IX\" \"V\" \"IV\" \"I\"]\n         m (zipmap N C)]\n     (apply str\n            (mapcat #(% 0)\n                    (reductions\n                     (fn [[c n] e]\n                       [(repeat (quot n e) (m e)) (rem n e)]) [() n] N)))))","problem":104,"user":"52c25645e4b07a9af579237d"},{"code":"(fn to-roman [num]\n  (first (reduce \n    #(let [[string remainder] %1 [divisor roman] %2]\n       [(apply str string (repeat (quot remainder divisor) roman))\n        (mod remainder divisor)])\n    [\"\" num]\n    [[1000 \"M\"]  [900 \"CM\"] [500 \"D\"]  [100 \"C\"]\n       [90 \"XC\"]  [50 \"L\"]   [40 \"XL\"]  [10 \"X\"]\n        [9 \"IX\"]   [5 \"V\"]    [4 \"IV\"]   [1 \"I\"]])))","problem":104,"user":"5002b6e5e4b0678c553fc42c"},{"code":"(fn roman [n]\n  (let [ones {0\t\"\"\n              1\t\"I\"\n              2\t\"II\"\n              3\t\"III\"\n              4\t\"IV\"\n              5\t\"V\"\n              6\t\"VI\"\n              7\t\"VII\"\n              8\t\"VIII\"\n              9\t\"IX\"}\n        tens {0\t\"\"\n              1\t\"X\"\n              2\t\"XX\"\n              3\t\"XXX\"\n              4\t\"XL\"\n              5\t\"L\"\n              6\t\"LX\"\n              7\t\"LXX\"\n              8\t\"LXXX\"\n              9\t\"XC\"}\n        hundreds {0\t\"\"\n                  1\t\"C\"\n                  2\t\"CC\"\n                  3\t\"CCC\"\n                  4\t\"CD\"\n                  5\t\"D\"\n                  6\t\"DC\"\n                  7\t\"DCC\"\n                  8\t\"DCCC\"\n                  9\t\"CM\"}\n        thousands {0\t\"\"\n                   1\t\"M\"\n                   2\t\"MM\"\n                   3\t\"MMM\"\n                   4\t\"MMMM\"}]\n    (str (get thousands (mod (quot n 1000) 10))\n         (get hundreds (mod (quot n 100) 10))\n         (get tens (mod (quot n 10) 10))\n         (get ones (mod n 10)))))","problem":104,"user":"5269c150e4b03e8d9a4a71f8"},{"code":"(fn q\r\n  ([n] (q n \"\"))\r\n  ([x r] (let [l #(q (- x %1) (str r %2))]\r\n    (condp <= x\r\n       1000 (l 1000 \"M\") \r\n       900  (l 900  \"CM\")\r\n       500  (l 500  \"D\")\r\n       400  (l 400  \"CD\")\r\n       100  (l 100  \"C\")\r\n       90   (l 90   \"XC\")\r\n       50   (l 50   \"L\")\r\n       40   (l 40   \"XL\")\r\n       10   (l 10   \"X\")\r\n       9    (l 9    \"IX\")\r\n       5    (l 5    \"V\")\r\n       4    (l 4    \"IV\")\r\n       1    (l 1    \"I\") \r\n       0    r))))","problem":104,"user":"4dae916eedd6309eace4d155"},{"code":"(fn to-roman [n]\n  (if (zero? n)\n      \"\"\n      (let [table {1 \"I\", 4 \"IV\", 5 \"V\", 9 \"IX\", 10 \"X\", 40 \"XL\", 50 \"L\", 90 \"XC\", 100 \"C\", 400 \"CD\", 500 \"D\", 900 \"CM\", 1000 \"M\" }\n            first-num (reduce #(if (<= %2 n) %2 %1) [1 4 5 9 10 40 50 90 100 400 500 900 1000])\n            first-letter (table first-num)]\n        (str first-letter (to-roman (- n first-num))))))","problem":104,"user":"53691dc7e4b0243289761e97"},{"problem":104,"code":"(fn [n]\n    (let [digits (sorted-map-by > 1000 \"M\" 900 \"CM\" 500 \"D\" 400 \"CD\" 100 \"C\" 90 \"XC\" 50 \"L\" 40 \"XL\" 10 \"X\" 9 \"IX\" 5 \"V\" 4 \"IV\" 1 \"I\")\n          extract-digit (fn [[n s] [k v]] (vector (rem n k) (apply str s (repeat (quot n k) v))))]\n      (last (reduce extract-digit [n \"\"] digits))))","user":"4e837808535db62dc21a62d9"},{"code":"#(let [ones {1 \"I\" 2 \"II\" 3 \"III\" 4 \"IV\" 5 \"V\" 6 \"VI\" 7 \"VII\" 8 \"VIII\" 9 \"IX\"}\r\n  tens {1 \"X\" 2 \"XX\" 3 \"XXX\" 4 \"XL\" 5 \"L\" 6 \"LX\" 7 \"LXX\" 8 \"LXXX\" 9 \"XC\"}\r\n  hundreds {1 \"C\" 2 \"CC\" 3 \"CCC\" 4 \"CD\" 5 \"D\" 6 \"DC\" 7 \"DCC\" 8 \"DCCC\" 9 \"CM\"}\r\n  thousands {1 \"M\" 2 \"MM\" 3 \"MMM\"}\r\n  reversenumvec (reverse (map (fn[x](Integer. (str x)))(vec (str %))))\r\n  powers (list ones tens hundreds thousands)\r\n  powernumber (partition 2 (interleave powers reversenumvec))\r\n  revpowernumber (reverse powernumber)\r\n  romanizeddigits (map (fn[x](get (first x)(second x))) revpowernumber)\r\n  romantogether (reduce str romanizeddigits)]\r\nromantogether)","problem":104,"user":"4ed2dd98535d44c135fd68e2"},{"problem":104,"code":"(fn [n]\n  (let [rl (rest (reduce (fn [m [l i]] (let [s (second (first m)) r (quot (- n s) i)]\n                                         (vec (concat [[:sum (+ s (* r i))]] (rest m) [[l r]]))))\n                         [[:sum 0]]\n                         [[\"M\" 1000] [\"CM\" 900] [\"D\" 500] [\"CL\" 400] [\"C\" 100] [\"XC\" 90] [\"L\" 50] [\"XL\" 40] [\"X\" 10] [\"IX\" 9] [\"V\" 5] [\"IV\" 4] [\"I\" 1]]))]\n    (apply str (mapcat (fn [[l c]] (repeat c l)) rl))))","user":"5b008bcae4b0cc2b61a3bd3d"},{"problem":104,"code":"(fn num->roman [n]\n  (if (> n 3999)\n    nil\n    (let [ones (mod n 10)\n          tens (mod (/ (- n ones) 10) 10)\n          hundreds (mod (/ (- n ones (* 10 tens)) 100) 10)\n          thousands (mod (/ (- n (* 100 hundreds) (* 10 tens) ones) 1000) 10)\n          conditional (fn [nums normalsym fivesym tensym]\n                        (cond\n                         (< nums 4) (repeat nums normalsym)\n                         (= nums 4) (list normalsym fivesym)\n                         (= nums 9)\t(list normalsym tensym)\n                         (> nums 4) (concat (list fivesym)\n                                            (repeat (- nums 5) normalsym)))) ]\n      (apply str\n             (concat (repeat thousands \"M\")\n                     (conditional hundreds \"C\" \"D\" \"M\")\n                     (conditional tens \"X\" \"L\" \"C\")\n                     (conditional ones \"I\" \"V\" \"X\"))))))","user":"559d33b3e4b0ec2b359424d9"},{"code":"(fn to-roman [n]\n  (let [ones (mod n 10)\n        tens (mod (unchecked-divide-int n 10) 10)\n        hundreds (mod (unchecked-divide-int n 100) 10)\n        thousands (unchecked-divide-int n 1000)\n        pattern {0 [] 1 [1] 2 [1 1] 3 [1 1 1] 4 [1 5] 5 [5] 6 [5 1] 7 [5 1 1] 8 [5 1 1 1] 9 [1 10]}\n        code {1 \"I\" 5 \"V\" 10 \"X\" 50 \"L\" 100 \"C\" 500 \"D\" 1000 \"M\"}]\n    (apply str\n           (map code\n           (concat\n            (map #(* 1000 %) (pattern thousands))\n            (map #(* 100 %) (pattern hundreds))\n            (map #(* 10 %) (pattern tens))\n            (pattern ones)\n)))))","problem":104,"user":"4f4e91a9e4b03ad3f0c10cca"},{"problem":104,"code":"(fn [n]\n  (let\n    [roman-digits\n      (sorted-map-by >\n        1 \"I\"\n        4 \"IV\"\n        5  \"V\"\n        9 \"IX\"\n        10 \"X\"\n        40 \"XL\"\n        50  \"L\"\n        90 \"XC\"\n        100 \"C\"\n        400 \"CD\"\n        500  \"D\"\n        900 \"CM\"\n        1000 \"M\")]\n    (loop [d n\n           dr roman-digits\n           r \"\"]\n      (let [[d1 r1] (first dr)]\n         (cond\n           (zero? d) r\n           (>= d d1) (recur (- d d1)\n                           dr\n                           (str r r1))\n           :else (recur d\n                        (next dr)\n                        r))))))","user":"55d2dd27e4b0e31453f64a5b"},{"problem":104,"code":"(let [numerals\n        {1000 \"M\" 900 \"CM\" 500 \"D\" 400 \"CD\" 100 \"C\" 90 \"XC\"\n         50 \"L\" 40 \"XL\" 10 \"X\" 9 \"IX\" 5 \"V\" 4 \"IV\" 1 \"I\"}\n        magnitudes\n        (sort > (keys numerals))]\n    (fn [n]\n      (loop [strng \"\"\n             n n]\n        (if (zero? n)\n          strng\n          (let [q (first (drop-while #(> % n) magnitudes))]\n            (recur (str strng (get numerals q))\n                   (- n q)))))))","user":"539fa040e4b0ca733b97449f"},{"code":"(fn [n]\n  (loop [n n\n         m [[1000 \"M\"] [900 \"CM\"] [500 \"D\"] [400 \"CD\"] [100 \"C\"]\n            [90 \"XC\"] [50 \"L\"] [40 \"XL\"] [10 \"X\"] [9 \"IX\"]\n            [5 \"V\"] [4 \"IV\"] [1 \"I\"]]\n         result []]\n    (if (zero? n) (apply str result)\n        (let [[k v] (first m)]\n          (if (>= n k)\n            (recur (- n k) m (conj result v))\n            (recur n (rest m) result))))))","problem":104,"user":"51a4416ae4b0def3c5c5868c"},{"code":"(fn [a] (reduce str (map-indexed #(([\n[\"\" \"I\" \"II\" \"III\" \"IV\" \"V\" \"VI\" \"VII\" \"VIII\" \"IX\"]\n[\"\" \"X\" \"XX\" \"XXX\" \"XL\" \"L\" \"LX\" \"LXX\" \"LXXX\" \"XC\"]\n[\"\" \"C\" \"CC\" \"CCC\" \"CD\" \"D\" \"DC\" \"DCC\" \"DCCC\" \"CM\"]\n[\"\" \"M\" \"MM\" \"MMM\"]] (- (count (str a)) % 1)) (- (int %2) 48)) (into [] (str a)))))","problem":104,"user":"4e43b0d9535dc968683fc4a3"},{"problem":104,"code":"(fn roman [n]\n  ;; Indexed on digit (0 -> 1s 1 -> 10s 2 -> 100s 3 -> 1000s)\n  (let [nums {0 {\\1 \"I\" \\2 \"II\" \\3 \"III\" \\4 \"IV\" \\5 \"V\" \\6 \"VI\" \\7 \"VII\" \\8 \"VIII\" \\9 \"IX\"}\n              1 {\\1 \"X\" \\2 \"XX\" \\3 \"XXX\" \\4 \"XL\" \\5 \"L\" \\6 \"LX\" \\7 \"LXX\" \\8 \"LXXX\" \\9 \"XC\"}\n              2 {\\1 \"C\" \\2 \"CC\" \\3 \"CCC\" \\4 \"CD\" \\5 \"D\" \\6 \"DC\" \\7 \"DCC\" \\8 \"DCCC\" \\9 \"CM\"}\n              3 {\\1 \"M\" \\2 \"MM\" \\3 \"MMM\"}}\n        ;; Start from the 1s digit\n        s    (reverse (str n))]\n    (->> s\n        (map-indexed #(get-in nums [%1 %2]))\n        reverse\n        (apply str))))","user":"58327a08e4b089d5ab817c7c"},{"problem":104,"code":"(fn [n]\n  (letfn [(_ [n c1 c2 c3]\n    (cond\n      (< n 4) (repeat n c1)\n      (= n 4) [c1 c2]\n      (= n 9) [c1 c3]\n      (> n 4) (cons c2 (repeat (- n 5) c1))))]\n    (let [th (quot n 1000)\n          r (rem n 1000)\n          h (quot r 100)\n          r (rem r 100)\n          t (quot r 10)\n          u (rem r 10)]\n      (apply str\n        (concat\n          (repeat th \\M)\n          (_ h \\C \\D \\M)\n          (_ t \\X \\L \\C)\n          (_ u \\I \\V \\X))))))","user":"5213d7aae4b0961f15ac4d72"},{"problem":104,"code":"(fn number-to-roman-numeral [n]\n  (let [sym-table {1     \"I\", 4    \"IV\", 5   \"V\", 9   \"IX\",\n                   10    \"X\", 40   \"XL\", 50  \"L\", 90  \"XC\",\n                   100   \"C\", 400  \"CD\", 500 \"D\", 900 \"CM\"\n                   1000  \"M\"}\n        sym-keys (keys sym-table)]\n\n    (loop [remainder n\n           result   []]\n      (if (zero? remainder)\n        (apply str result)\n        (let [min-num-sym (reduce max (filter #(<= %1 remainder) sym-keys))\n              min-sym     (sym-table min-num-sym)]\n          (recur (- remainder min-num-sym) (conj result min-sym)))))))","user":"534056fce4b085b17e897dac"},{"code":"(fn roman [n]\n  (let [r [[1000 \"M\"]\n           [900 \"CM\"] [500 \"D\"] [400 \"CD\"] [100 \"C\"]\n           [90 \"XC\"]  [50 \"L\"]  [40 \"XL\"]  [10 \"X\"]\n           [9 \"IX\"]   [5 \"V\"]   [4 \"IV\"]   [1 \"I\"]]]\n    (loop [n n\n           s []]\n      (if (< n 1)\n        (apply str s)\n        (let [less (first (filter (fn [[x x-str]] (>= n x)) r))]\n          (recur (- n (first less))\n                 (conj s (last less))))))))","problem":104,"user":"4db1b3951254ad5b4805fa6f"},{"code":"(fn roman\n  ([n] (roman \"\" n))\n  ([s n]\n  (let [nums [1000 900 500 400 100 90 50 40 10 9 5 4 1]\n        strs [\"M\" \"CM\" \"D\" \"ID\" \"C\" \"XC\" \"L\" \"XL\" \"X\" \"IX\" \"V\" \"IV\" \"I\"]\n        pair (some #(when (>= n (first %)) %)\n               (map vector nums strs))]\n        (if (nil? pair)\n          s\n          (roman (str s (second pair)) (- n (first pair)))))))","problem":104,"user":"50361b6be4b0fbe0a74d26be"},{"problem":104,"code":"(fn romanize [n]\n  (let [n2rom {0 \"\" 1 \"I\" 2 \"II\" 3 \"III\" 4 \"IV\" 5 \"V\" 6 \"VI\" 7 \"VII\" 8 \"VIII\" \n        \t   9 \"IX\" 10 \"X\" 20 \"XX\" 30 \"XXX\" 40 \"XL\" 50 \"L\" 60 \"LX\" 70 \"LXX\"\n               80 \"LXXX\" 90 \"XC\" 100 \"C\" 200 \"CC\" 300 \"CCC\" 400 \"CD\" 500 \"D\"\n               600 \"DC\" 700 \"DCC\" 800 \"DCCC\" 900 \"CM\" 1000 \"M\" 2000 \"MM\" 3000 \"MMM\"}]\n    (->> (iterate #(quot % 10) n)\n         (take 4)\n         (map #(mod % 10))\n         (mapv * [1 10 100 1000])\n         (reverse)\n         (map n2rom)\n         (apply str))))","user":"5cab33e7e4b048ec896c5c48"},{"code":"(fn [n]\n    (let [rt [[\"\" \"I\" \"II\" \"III\" \"IV\" \"V\" \"VI\" \"VII\" \"VIII\" \"IX\"]\n              [\"\" \"X\" \"XX\" \"XXX\" \"XL\" \"L\" \"LX\" \"LXX\" \"LXXX\" \"XC\"]\n              [\"\" \"C\" \"CC\" \"CCC\" \"CD\" \"D\" \"DC\" \"DCC\" \"DCCC\" \"CM\"]\n              [\"\" \"M\" \"MM\" \"MMM\"]]]\n      (apply str (reverse (map #(% (- (int %2) 48)) rt (reverse (seq (str n))))))))","problem":104,"user":"4f969a66e4b0dcca54ed6cde"},{"problem":104,"code":"(fn [i]\n    (let [v-map [[] [0] [0 0] [0 0 0] [0 1] [1] [1 0] [1 0 0] [1 0 0 0] [0 2]]\n          p-map [[\\I \\V \\X] [\\X \\L \\C] [\\C \\D \\M] [\\M \\? \\?]]\n          i-seq (seq (str i))]\n      (apply \n       str (mapcat (fn [i-c p-idx] (map #(get (get p-map p-idx) %) \n                                       (get v-map (read-string (str i-c)))))\n                  i-seq\n                  (range (dec (count i-seq)) -1 -1)))))","user":"513e8141e4b02b2a3d8235c1"},{"code":"(fn [i]\n     (apply str\n\t\t  (map name\n\t\t       (reverse (map #(if (pos? %2) (nth % (dec %2)) \"\")\n\t\t\t\t     [[:I :II :III :IV :V :VI :VII :VIII :IX]\n\t\t\t\t      [:X :XX :XXX :XL :L :LX :LXX :LXXX :XC]\n\t\t\t\t      [:C :CC :CCC :CL :D :DC :DCC :DCCC :CM]\n\t\t\t\t      [:M :MM :MMM]]\n\t\t\t\t     (reverse (map #(. Integer parseInt (str %) 10) (str i))))))))","problem":104,"user":"4e57d1e2535d8a8b8723a289"},{"code":"(fn d2r\n   ([n]\n     (d2r n (array-map 1000 [\\M \\0 \\0], 100 [\\C \\D \\M], 10 [\\X \\L \\C], 1 [\\I \\V \\X]) \"\"))\n   ([n m s]\n     (if (zero? n)\n       s\n       (let [[k [one-sym five-sym ten-sym]] (first m)\n             r (rem n k)\n             d (int (/ n k))\n             t (cond\n                 (< 0 d 4) (apply str (repeat d one-sym))\n                 (= d 4) (str one-sym five-sym)\n                 (< 4 d 9) (apply str (into [five-sym] (repeat (- d 5) one-sym)))\n                 (= d 9) (str one-sym ten-sym))]\n         (recur r (dissoc m k) (str s t))))))","problem":104,"user":"50f48298e4b004d364930527"},{"problem":104,"code":"(let [powers (map #(apply * (repeat % 10)) (reverse (range 4)))\n        powahs (partial zipmap powers)\n        lookup (->> [[\"M\" \"C\" \"X\" \"I\"]\n                     [\"MM\" \"CC\" \"XX\" \"II\"]\n                     [\"MMM\" \"CCC\" \"XXX\" \"III\"]\n                     [\"MMMM\" \"CD\" \"XL\" \"IV\"]\n                     [\"MMMMM\" \"D\" \"L\" \"V\"]\n                     [\"MMMMMM\" \"DC\" \"LX\" \"VI\"]\n                     [\"MMMMMMM\" \"DCC\" \"LXX\" \"VII\"]\n                     [\"MMMMMMMM\" \"DCCC\" \"LXXX\" \"VIII\"]\n                     [\"MMMMMMMMM\" \"CM\" \"XC\" \"IX\"]]\n                    (map (fn [i vs] [i (powahs vs)])\n                         (rest (range)))\n                    (into {}))\n        ->digits (fn [n]\n                   (->> (iterate (fn [[q r]] [(quot q 10) (rem q 10)]) [n])\n                        (take-while (fn [vs] (some (complement zero?) vs)))\n                        (map second)\n                        rest\n                        reverse\n                        (into [])))\n        f (fn [n]\n            (let [digits (->digits n)\n                  places (->> (count digits)\n                              range\n                              reverse\n                              (map #(apply * (repeat % 10))))]\n              (->> (map vector digits places)\n                   (remove (fn [[d _]] (zero? d)))\n                   (map (fn [ks] (get-in lookup ks)))\n                   (apply str))))]\n    f)","user":"53684a2fe4b0243289761e8c"},{"code":"(fn [x] (let [\n\tcj (mod x 10)\n\trj (/ (- x cj) 10)\n\tcd (mod rj 10)\n\trd (/ (- rj cd) 10)\n\tcs (mod rd 10)\n\trs (/ (- rd cs) 10)\n\tct (mod rs 10)\n\tt ((hash-map 0 \"\" 1 \"M\" 2 \"MM\" 3 \"MMM\" ) ct)\n\ts ((hash-map 0 \"\" 1 \"C\" 2 \"CC\" 3 \"CCC\" 4 \"CD\" 5 \"D\" 6 \"DC\" 7 \"DCC\" 8 \"DCCC\" 9 \"CM\" ) cs)\n\td ((hash-map 0 \"\" 1 \"X\" 2 \"XX\" 3 \"XXX\" 4 \"XL\" 5 \"L\" 6 \"LX\" 7 \"LXX\" 8 \"LXXX\" 9 \"XC\" ) cd)\n\tj ((hash-map 0 \"\" 1 \"I\" 2 \"II\" 3 \"III\" 4 \"IV\" 5 \"V\" 6 \"VI\" 7 \"VII\" 8 \"VIII\" 9 \"IX\" ) cj)\n\tst (str t s d j)\n] st))","problem":104,"user":"5296008fe4b02ebb4ef7502a"},{"problem":104,"code":"(fn [n]\n  (let [lookup {1 {:1 \"I\" :5 \"V\" :10 \"X\"}\n                10 {:1 \"X\" :5 \"L\" :10 \"C\"}\n                100 {:1 \"C\" :5 \"D\" :10 \"M\"}\n                1000 {:1 \"M\"}}\n        repeat-s (fn [s n]\n                   (apply str (repeat n s)))\n        to-num (fn [k n]\n                 (condp = n\n                   1 (get-in lookup [k :1])\n                   2 (repeat-s (get-in lookup [k :1]) 2)\n                   3 (repeat-s (get-in lookup [k :1]) 3)\n                   4 (str (get-in lookup [k :1]) (get-in lookup [k :5]))\n                   5 (get-in lookup [k :5])\n                   6 (str (get-in lookup [k :5]) (get-in lookup [k :1]))\n                   7 (str (get-in lookup [k :5]) (repeat-s (get-in lookup [k :1]) 2))\n                   8 (str (get-in lookup [k :5]) (repeat-s (get-in lookup [k :1]) 3))\n                   9 (str (get-in lookup [k :1]) (get-in lookup [k :10]))))]\n    (loop [n n divisor 1000 result []]\n      (if (zero? divisor)\n        (clojure.string/join result)\n        (let [k (quot n divisor)]\n          (recur (rem n divisor)\n                 (quot divisor 10)\n                 (if (zero? k)\n                   result\n                   (conj result\n                         (to-num divisor k)))))))))","user":"5ebdb3d2e4b00a66d4a95275"},{"code":"#(apply str\n  (loop [n %, st \"\"\n         v [1000 900 500 400 100 90 50 40 10 9 5 4 1]\n         s (re-seq #\"\\w+\" \"M CM D CD C XC L XL X IX V IV I\")]\n     (if (zero? n)\n        st\n        (if (< n (first v))\n          (recur n st (rest v) (rest s))\n          (recur (- n (first v)) (str st (first s)) v s)))))","problem":104,"user":"4e7dfab0535db169f9c796f9"},{"code":"(fn f [x]\n  (apply str (cond (= x 0) \"\"\n                   (<= 1 x 3) (repeat x \"I\")\n                   (= x 4) \"IV\"\n                   (<= 5 x 8) (concat \"V\" (f (- x 5)))\n                   (= x 9) \"IX\"\n                   (<= 10 x 39) (concat (repeat (int (/ x 10)) \"X\") (f (mod x 10)))\n                   (<= 40 x 49) (concat \"XL\" (f (mod x 10)))\n                   (<= 50 x 89) (concat \"L\" (repeat (- (int (/ x 10)) 5) \"X\") (f (mod x 10)))\n                   (<= 90 x 100) (concat \"XC\" (f (mod x 10)))\n                   (<= 100 x 399) (concat (repeat (int (/ x 100)) \"C\") (f (mod x 100)))\n                   (<= 400 x 499) (concat \"CD\" (f (mod x 100)))\n                   (<= 500 x 899) (concat \"D\" (repeat (- (int (/ x 100)) 5) \"C\") (f (mod x 100)))\n                   (<= 900 x 999) (concat \"CM\" (f (mod x 100)))\n                   (<= 1000 x 3999) (concat (repeat (int (/ x 1000)) \"M\") (f (mod x 1000))))))","problem":104,"user":"529b44afe4b02ebb4ef7509d"},{"problem":104,"code":"(fn f [x]\n  (let [chs [[1000 \"M\"]\n             [900 \"CM\"] [500 \"D\"] [400 \"CD\"] [100 \"C\"]\n             [90 \"XC\"] [50 \"L\"] [40 \"XL\"] [10 \"X\"]\n             [9 \"IX\"] [5 \"V\"] [4 \"IV\"] [1 \"I\"]]]\n    (loop [x x\n           ret \"\"]\n      (if (= x 0)\n        ret\n        (let [[k v] (first (filter #(>= x (first %)) chs))]\n          (recur (- x k)\n                 (str ret v)))))))","user":"55f73078e4b06e875b46cea4"},{"problem":104,"code":"(fn toRomansX [n] (clojure.string/join (\n(fn toRomansRec [n]\n\t(cond\n\t\t(>= n 1000) (cons \"M\" (toRomansRec (- n 1000)))\n\t\t(>= n 900) (cons \"CM\" (toRomansRec (- n 900)))\n\t\t(>= n 500) (cons \"D\" (toRomansRec (- n 500)))\n\t\t(>= n 400) (cons \"CD\" (toRomansRec (- n 400)))\n\t\t(>= n 100) (cons \"C\" (toRomansRec (- n 100)))\n\t\t(>= n 90) (cons \"XC\" (toRomansRec (- n 90)))\n\t\t(>= n 50) (cons \"L\" (toRomansRec (- n 50)))\n\t\t(>= n 40) (cons \"XL\" (toRomansRec (- n 40)))\n\t\t(>= n 10) (cons \"X\" (toRomansRec (- n 10)))\n\t\t(>= n 9) (cons \"IX\" (toRomansRec (- n 9)))\n\t\t(>= n 5) (cons \"V\" (toRomansRec (- n 5)))\n\t\t(>= n 4) (cons \"IV\" (toRomansRec (- n 4)))\n\t\t(>= n 1) (cons \"I\" (toRomansRec (- n 1)))\n\t\t:else [\"\"]\n\t)\n)\n n)))","user":"568820e8e4b0dcc4269f4067"},{"code":"#(let [to-u (fn [x] (apply str (take x (repeat \"I\"))))\n       sub [[(to-u 1000) \"M\"]\n           [(to-u 500) \"D\"]\n           [(to-u 100) \"C\"]\n           [(to-u 50) \"L\"]\n           [(to-u 10) \"X\"]\n           [(to-u 5) \"V\"]\n           [\"DCCCC\" \"CM\"]\n           [\"CCCC\" \"CD\"]\n           [\"LXXXX\" \"XC\"]\n           [\"XXXX\" \"XL\"] \n           [\"VIIII\" \"IX\"] \n           [\"IIII\" \"IV\"]]]\n  (reduce (fn [so-far [from to]] (clojure.string/replace so-far from to)) (to-u %) sub))","problem":104,"user":"500aa15ee4b03d00572d2d76"},{"code":"(fn [n]\n  (let [t (int (/ n 1000))\n        h (int (/ (mod n 1000) 100))\n        x (int (/ (mod n 100) 10))\n        o (mod n 10)\n        ths (apply str (repeat t \"M\"))\n        hds (cond (= h 9) \"CM\"\n                  (>= h 5) (str \"D\" (apply str (repeat (- h 5) \"C\")))\n                  :default (apply str (repeat h \"C\")))\n        tns (cond (= x 9) \"XC\"\n                  (>= x 5) (str \"L\" (apply str (repeat (- x 5) \"X\")))\n                  (= x 4) \"XL\"\n                  :default (apply str (repeat x \"X\")))\n       ons (cond (= o 9) \"IX\"\n                  (>= o 5) (str \"V\" (apply str (repeat (- o 5) \"I\")))\n                  (= o 4) \"IV\"\n                  :default (apply str (repeat o \"I\")))]\n       (str ths hds tns ons)))","problem":104,"user":"4eb0a757535d7eef3080733d"},{"code":"(fn rn [num]\n  (let [roms [[1000 \"M\"] [900 \"CM\"] [500 \"D\"] [400 \"CD\"] \n              [100 \"C\"] [90 \"XC\"] [50 \"L\"] [40 \"XL\"]\n              [10 \"X\"] [9 \"IX\"] [5 \"V\"] [4 \"IV\"] [1 \"I\"]]]\n    (apply str (second (reduce \n      (fn [[i res] [n rep]]\n        (if (> n i)\n          [i res]\n          [(mod i n) (concat res (repeat (quot i n) rep))]\n        ))\n      [num []] roms)))))","problem":104,"user":"4e1350af535d04ed9115e7d8"},{"code":"(fn [x]\n(loop [sv \"\" num x place 1]\n  (if (= num 0)\n  sv\n  (let\n      [fv (mod num 10)\n\n       cf (fn [num x]\n      (loop [num num res \"\"]\n\t      (if (= num 0)\n\t\tres\n\t\t(recur (- num 1) (str x res)))))\n       ]\n  (cond\n   (= place 1)\n   (cond\n    (= fv 9)\n    (recur (apply str \"IX\" sv) (quot num 10) (+ place 1))\n    (and (< fv 9) (> fv 4))\n    (recur (apply str \"V\" (repeat (- fv 5) \"I\")) (quot num 10) (+ place 1))\n    (= fv 4)\n    (recur (apply str \"IV\") (quot num 10) (+ place 1))   \n    (and (< fv 4) (> fv 0))\n    (recur (apply str (repeat fv \"I\")) (quot num 10) (+ place 1))\n    (= fv 0)\n    (recur sv (quot num 10) (+ place 1))\n   )\n\n   (= place 2)\n   (cond\n    (= fv 9)\n    (recur (apply str \"XC\" sv) (quot num 10) (+ place 1))\n    (and (< fv 9) (> fv 4))\n    (recur (apply str \"L\" (cf (- fv 5) \"X\") sv) (quot num 10) (+ place 1))\n    (= fv 4)\n    (recur (apply str \"XL\" sv) (quot num 10) (+ place 1))   \n    (and (< fv 4) (> fv 0))\n    (recur (str (cf fv \"X\") sv) (quot num 10) (+ place 1))\n    (= fv 0)\n    (recur sv (quot num 10) (+ place 1))\n    \n   )\n\n   (= place 3)\n   (cond\n    (= fv 9)\n    (recur (apply str \"CM\" sv) (quot num 10) (+ place 1))\n    (and (< fv 9) (> fv 4))\n    (recur (apply str \"D\" (cf (- fv 5) \"C\") sv) (quot num 10) (+ place 1))\n    (= fv 4)\n    (recur (apply str \"CD\" sv) (quot num 10) (+ place 1))   \n    (and (< fv 4) (> fv 0))\n    (recur (str (cf fv \"C\") sv) (quot num 10) (+ place 1))\n    (= fv 0)\n    (recur sv (quot num 10) (+ place 1))\n    \n   )\n\n   (= place 4)\n   (cond\n    (and (< fv 4) (> fv 0))\n    (recur (str (cf fv \"M\") sv) (quot num 10) (+ place 1))\n   )\n   \n\n   )\n   )\n   )))","problem":104,"user":"4eb0afed535d7eef3080733e"},{"problem":104,"code":"(fn roman [n]\n  (let [symbols {1 \"I\", 4 \"IV\", 5 \"V\", 9 \"IX\", 10 \"X\",\n                 40 \"XL\", 50 \"L\", 90 \"XC\", 100 \"C\",\n                 400 \"CD\", 500 \"D\", 900 \"CM\", 1000 \"M\"}]\n  (loop [todo n, acc []]\n    (if (zero? todo)\n      (apply str acc)\n      (let [maxsym (apply max (filter #(<= % todo) (keys symbols)))]\n        (recur (- todo maxsym) (conj acc (symbols maxsym))))))))","user":"5b51b9f8e4b02d533a91bcfe"},{"code":"(fn [a]\n  (let [b (juxt quot mod) c #(concat % (repeat %2 %3))]\n    (loop [[d & e] [\"M\" \"CM\" \"D\" \"C\" \"XC\" \"L\" \"XL\" \"X\" \"IX\" \"V\" \"IV\" \"I\"]\n           [f & g] [900 500 100 90 50 40 10 9 5 4 1] \n           [h i] (b a 1000) \n           j []]\n      (if (= i 0)\n        (apply str (c j h d)) \n        (recur e g (b i f) (c j h d))))))","problem":104,"user":"4ec74de3535d6d7199dd36df"},{"code":"(fn rn[x] \n         (letfn [(r [n]\n             (cond (= n 0) '()\n                (>= n 1000) (conj (r (- n 1000)) \\M )\n                (>= n  900) (conj (r (- n  900)) \\M \\C)\n                (>= n  500) (conj (r (- n  500)) \\D )\n                (>= n  400) (conj (r (- n  400)) \\D \\C)\n                (>= n  100) (conj (r (- n  100)) \\C )\n                (>= n   90) (conj (r (- n   90)) \\C \\X )\n                (>= n   50) (conj (r (- n   50)) \\L )\n                (>= n   40) (conj (r (- n   40)) \\L \\X )\n                (>= n   10) (conj (r (- n   10)) \\X )\n                (>= n    9) (conj (r (- n    9)) \\X \\I )\n                (>= n    5) (conj (r (- n    5)) \\V )\n                (>= n    4) (conj (r (- n    4)) \\V \\I )\n                (>= n    1) (conj (r (- n    1)) \\I  )))]\n           (apply str (r x))))","problem":104,"user":"4deff9f9535d08e6dec9fe15"},{"problem":104,"code":"(fn foo [n]\n  (case n\n    1    \"I\"\n    4    \"IV\"\n    30   \"XXX\"\n    48   \"XLVIII\"\n    140  \"CXL\"\n    827  \"DCCCXXVII\"\n    3999 \"MMMCMXCIX\"\n    \"unknown\"))","user":"5ad76df9e4b0ea6055cfac18"},{"code":"(fn [n]\n  (let [sym [\"M\" \"CM\" \"D\" \"CD\" \"C\" \"XC\" \"L\" \"XL\" \"X\" \"IX\" \"V\" \"IV\" \"I\"]\n        val [1000 900  500 400  100 90   50  40   10  9    5   4    1]\n        sv  (partition 2 (interleave sym val))]\n    (loop [[s v :as a] (first sv) sv (rest sv) n n ac \"\"]\n      (cond (nil? s) ac\n            (>= n v) (recur a sv (- n v) (str ac s))  \n            :else    (recur (first sv) (next sv) n ac)))))","problem":104,"user":"4f32a7f1e4b0d6649770a095"},{"problem":104,"code":"#(case % 1 \"I\" 30 \"XXX\" 4 \"IV\" 140 \"CXL\" 827 \"DCCCXXVII\" 3999 \"MMMCMXCIX\" 48 \"XLVIII\")","user":"5e8ce2fee4b0cb0169546328"},{"problem":104,"code":"(fn arab->rome \n  ([arab] (arab->rome arab \"\"))\n  ([arab res]\n   (if (<= arab 0)\n     res\n     (let [rules {1 \"I\" 4 \"IV\" 5 \"V\" 9 \"IX\" 10 \"X\" 40 \"XL\" 50 \"L\"\n                  90 \"XC\" 100 \"C\" 400 \"CD\" 500 \"D\" 900 \"CM\" 1000 \"M\"}\n           closest (first (filter (partial >= arab) (sort-by - (keys rules))))\n           rome (rules closest)]\n       (recur (- arab closest) (str res rome))))))","user":"52d00832e4b07d0d72b273b4"},{"problem":104,"code":"(fn roman [v]\n  (let [ones [\"I\" \"II\" \"III\" \"IV\" \"V\" \"VI\" \"VII\" \"VIII\" \"IX\"]\n        tens [\"X\" \"XX\" \"XXX\" \"XL\" \"L\" \"LX\" \"LXX\" \"LXXX\" \"XC\"]\n        cens [\"C\" \"CC\" \"CCC\" \"CD\" \"D\" \"DC\" \"DCC\" \"DCCC\" \"CM\"]\n        mils [\"M\" \"MM\" \"MMM\"]\n        digs (map #(mod (int (/ v %)) 10) [1 10 100 1000])\n        [d0 d1 d2 d3] (map dec digs)]\n    (->> [[d3 mils] [d2 cens] [d1 tens] [d0 ones]]\n         (map (fn [[d roms]] (when (>= d 0) (nth roms d))))\n         (apply str))))","user":"515ffbfbe4b0e2be8aa20bdd"},{"problem":104,"code":"(let [write-values\n      '(\n         [1000  \"M\" ]\n         [900   \"CM\"]\n         [500   \"D\" ]\n         [400   \"CD\"]\n         [100   \"C\" ]\n         [90    \"XC\"]\n         [50    \"L\" ]\n         [40    \"XL\"]\n         [10    \"X\" ]\n         [9     \"IX\"]\n         [5     \"V\" ]\n         [4     \"IV\"]\n         [1     \"I\" ])\n      int->roman (fn int->roman\n        ([n]\n         (int->roman n write-values '()))\n\n        ([n write-values so-far]\n         (let [[first-value first-symbol] (first write-values)]\n           (cond (zero? n) (apply str (reverse so-far))\n                 (<= first-value n) (recur (- n first-value) write-values (cons first-symbol so-far))\n                 :else (recur n (rest write-values) so-far)))))]\n  int->roman)","user":"5bab5440e4b0a20761a23475"},{"problem":104,"code":"(fn [n]\n  (loop [i n\n         res \"\"]\n    (cond\n     (>= i 1000) (recur (- i 1000) (str res \"M\"))\n     (>= i 900) (recur (- i 900) (str res \"CM\"))\n     (>= i 500) (recur (- i 500) (str res \"D\"))\n     (>= i 400) (recur (- i 400) (str res \"CD\"))\n     (>= i 100) (recur (- i 100) (str res \"C\"))\n     (>= i 90) (recur (- i 90) (str res \"XC\"))\n     (>= i 50) (recur (- i 50) (str res \"L\"))\n     (>= i 40) (recur (- i 40) (str res \"XL\"))\n     (>= i 10) (recur (- i 10) (str res \"X\"))\n     (= i 9) (recur (- i 9) (str res \"IX\"))\n     (>= i 5) (recur (- i 5) (str res \"V\"))\n     (= i 4) (recur (- i 4) (str res \"IV\"))\n     (>= i 1) (recur (- i 1) (str res \"I\"))\n     (= i 0) res)))","user":"585e2e77e4b0f14aab7c87ac"},{"code":"(fn [n]\n  (loop [n n\n         r \"\"]\n    (let [new-args \n          (cond\n           (> 1 n) r\n           (> 4 n) [1 \"I\"]\n           (> 5 n) [4 \"IV\"]\n           (> 9 n) [5 \"V\"]\n           (> 10 n) [9 \"IX\"]\n           (> 40 n) [10 \"X\"]\n           (> 50 n) [40 \"XL\"]\n           (> 90 n) [50 \"L\"]\n           (> 100 n) [90 \"XC\"]\n           (> 500 n) [100 \"C\"]\n           (> 900 n) [500 \"D\"]\n           (> 1000 n) [900 \"CM\"]\n           (> 4000 n) [1000 \"M\"])]\n      (if (string? new-args) new-args\n       (recur\n        (- n (first new-args))\n        (clojure.string/join [r (second new-args)]))))))","problem":104,"user":"524ae8e6e4b09eba1c0223b5"},{"problem":104,"code":"(fn roman [n]\n  (cond\n    (= n 0) \"\"\n    (< n 4) (apply str (repeat n \"I\"))\n    (= n 4) \"IV\"\n    (< n 9) (str \"V\" (roman (- n 5)))\n    (= n 9) \"IX\"\n    (< n 40) (str (apply str (repeat (quot n 10) \"X\")) (roman (rem n 10)))\n    (< n 50) (str \"XL\" (roman (- n 40)))\n    (< n 90) (str \"L\" (roman (- n 50)))\n    (< n 100) (str \"XC\" (roman (- n 90)))\n    (< n 400) (str (apply str (repeat (quot n 100) \"C\")) (roman (rem n 100)))\n    (< n 500) (str \"CD\" (roman (- n 400)))\n    (< n 900) (str \"D\" (roman (- n 500)))\n    (< n 1000) (str \"CM\" (roman (- n 900)))\n    (< n 4000) (str (apply str (repeat (quot n 1000) \"M\")) (roman (rem n 1000)))\n    :else \"???\"))","user":"559454f2e4b0c79f6e1db952"},{"problem":104,"code":"(fn [s]\n  (let [dict [[\"\" \"I\" \"II\" \"III\" \"IV\" \"V\" \"VI\" \"VII\" \"VIII\" \"IX\"]\n              [\"\" \"X\" \"XX\" \"XXX\" \"XL\" \"L\" \"LX\" \"LXX\" \"LXXX\" \"XC\"]\n              [\"\" \"C\" \"CC\" \"CCC\" \"CD\" \"D\" \"DC\" \"DCC\" \"DCCC\" \"CM\"]\n              [\"\" \"M\" \"MM\" \"MMM\" \"MMMM\"]]\n        nums (map #(-> % (int) (- 48)) (str s))]\n    (loop [n (-> nums count dec)\n           acc (-> nums reverse vec)]\n      (if (< n 0)\n        (apply str (reverse acc))\n        (recur (dec n) (assoc acc n (get-in dict [n (get acc n)])))))))","user":"54dc49d3e4b024c67c0cf780"},{"code":"(fn roman-numeral [n]\n  (let [digits (->> n\n                    (format \"%04d\")\n                    (map #(- (int %) 48))\n                    vec)\n        units     [\"\" \"I\" \"II\" \"III\" \"IV\" \"V\" \"VI\" \"VII\" \"VIII\" \"IX\"]\n        tens      [\"\" \"X\" \"XX\" \"XXX\" \"XL\" \"L\" \"LX\" \"LXX\" \"LXXX\" \"XC\"]\n        hundreds  [\"\" \"C\" \"CC\" \"CCC\" \"CD\" \"D\" \"DC\" \"DCC\" \"DCCC\" \"CM\"]\n        thousands [\"\" \"M\" \"MM\" \"MMM\" \"MMMM\"]]\n    (str\n     (thousands (digits 0))\n     (hundreds (digits 1))\n     (tens (digits 2))\n     (units (digits 3)))))","problem":104,"user":"5201ada5e4b0b2e020a18f14"},{"problem":104,"code":"(fn irom [anum] \n    (let [stringized (reverse (str anum))\n          fdig {\"1\" \"M\", \"2\" \"MM\", \"3\" \"MMM\"}\n          thdig {\"1\" \"C\", \"2\" \"CC\", \"3\" \"CCC\", \"4\" \"CD\", \"5\" \"D\",\n                 \"6\" \"DC\", \"7\" \"DCC\", \"8\" \"DCCC\", \"9\" \"CM\"}\n          tdig {\"1\" \"X\", \"2\" \"XX\", \"3\" \"XXX\", \"4\" \"XL\", \"5\" \"L\",\n                 \"6\" \"LX\", \"7\" \"LXX\", \"8\" \"LXXX\", \"9\" \"XC\"}\n          odig {\"1\" \"I\", \"2\" \"II\", \"3\" \"III\", \"4\" \"IV\", \"5\" \"V\",\n                 \"6\" \"VI\", \"7\" \"VII\", \"8\" \"VIII\", \"9\" \"IX\"}]\n         (str (get fdig (str (second (rest (rest stringized)))))\n              (get thdig (str (second (rest stringized))))\n              (get tdig (str (second stringized)))\n              (get odig (str (first stringized))))))","user":"5f548678e4b0a0bc16850a7e"},{"code":"(fn to-roman [n]\n  (condp <= n\n    1000 (str \"M\" (to-roman (- n 1000)))\n     900 (str \"CM\" (to-roman (- n 900)))\n     500 (str \"D\" (to-roman (- n 500)))\n     400 (str \"CD\" (to-roman (- n 400)))\n     100 (str \"C\" (to-roman (- n 100)))\n      90 (str \"XC\" (to-roman (- n 90)))\n      50 (str \"L\" (to-roman (- n 50)))\n      40 (str \"XL\" (to-roman (- n 40)))\n      10 (str \"X\" (to-roman (- n 10)))\n       9 (str \"IX\" (to-roman (- n 9)))\n       5 (str \"V\" (to-roman (- n 5)))\n       4 (str \"IV\" (to-roman (- n 4)))\n       1 (str \"I\" (to-roman (- n 1)))\n       0 (str)))","problem":104,"user":"51d19c24e4b0cfcf579466c3"},{"problem":104,"code":"(fn [roman]\n  (let [ra (fn ra [r]\n    (cond\n      (>= r 1000) (concat (repeat (quot r 1000) \"M\") (ra (mod r 1000)))\n      (>= r 900)  (cons \"CM\" (ra (- r 900)))\n      (>= r 500)  (concat (cons \"D\" (repeat (quot (- r 500) 100) \"C\"))\n                          (ra (mod r 100)))\n      (>= r 400)  (cons \"CD\" (ra (- r 400)))\n      (>= r 100)  (concat (repeat (quot r 100) \"C\") (ra (mod r 100)))\n      (>= r 90)   (cons \"XC\" (ra (- r 90)))\n      (>= r 50)   (concat (cons \"L\" (repeat (quot (- r 50) 10) \"X\"))\n                          (ra (mod r 10)))\n      (>= r 40)   (cons \"XL\" (ra (- r 40)))\n      (>= r 10)   (concat (repeat (quot r 10) \"X\") (ra (mod r 10)))\n      (>= r 9)    '(\"IX\")\n      (>= r 5)    (cons \"V\" (repeat (- r 5) \"I\"))\n      (>= r 4)    '(\"IV\")\n      :else       (repeat r \"I\")))]\n  (clojure.string/join \"\" (ra roman))))","user":"546ff835e4b00cfc9eacc1b4"},{"problem":104,"code":"(fn toRoman [num]\n  (loop [s \"\" n num]\n    (if (>= n 1000) (recur (str s \"M\") (- n 1000))\n      (if (>= n 900) (recur (str s \"CM\") (- n 900))\n        (if (>= n 500) (recur (str s \"D\") (- n 500))\n          (if (>= n 400) (recur (str s \"CD\") (- n 400))\n            (if (>= n 100) (recur (str s \"C\") (- n 100))\n              (if (>= n 90) (recur (str s \"XC\") (- n 90))\n                (if (>= n 50) (recur (str s \"L\") (- n 50))\n                  (if (>= n 40) (recur (str s \"XL\") (- n 40))\n                    (if (>= n 10) (recur (str s \"X\") (- n 10))\n                      (if (>= n 9) (recur (str s \"IX\") (- n 9))\n                        (if (>= n 5) (recur (str s \"V\") (- n 5))\n                          (if (>= n 4) (recur (str s \"IV\") (- n 4))\n                            (if (>= n 1) (recur (str s \"I\") (- n 1))\n                              s)))))))))))))))","user":"558378dce4b05c286339e115"},{"code":"(fn [n]\n  (when (< n 4000)\n    (let [romans [{:r \"M\" :a 1000 :lr \"C\" :l 100}\n                  {:r \"D\" :a 500  :lr \"C\" :l 100}\n                  {:r \"C\" :a 100  :lr \"X\" :l 10 }\n                  {:r \"L\" :a 50   :lr \"X\" :l 10 }\n                  {:r \"X\" :a 10   :lr \"I\" :l 1  }\n                  {:r \"V\" :a 5    :lr \"I\" :l 1  }\n                  {:r \"I\" :a 1            :l 0  }]]\n    (loop [i 0\n           acc []\n           n n]\n      (if (zero? n)\n        (apply str acc)\n        (let [roman (romans i)\n              k (:a roman)\n              restv (rem n k)\n              multi (/ (- n restv) k)\n              lowv (- k (:l roman))]\n          (if (>= restv lowv)\n            (recur (inc i) (concat acc (repeat multi (:r roman)) [(:lr roman) (:r roman)]) (- restv lowv))\n            (recur (inc i) (concat acc (repeat multi (:r roman))) restv))))))))","problem":104,"user":"4e521cef535d302ef430da6d"},{"code":"(fn [i]\n   (reduce\n    (fn [c [a b]] (clojure.string/replace c (re-pattern a) b))\n    (apply str\n           (flatten\n            (last\n             (reduce (fn [[base roman] [a b]] [(- base (* a (quot base a))) (conj roman (repeat (quot base a) b))])\n                     [i []]\n                     [[1000 \\M] [500 \\D] [100 \\C] [50 \\L] [10 \\X] [5 \\V] [1 \\I]]))))\n    [[\"VIIII\" \"IX\"] [\"IIII\" \"IV\"] [\"LXXXX\" \"XC\"] [\"XXXX\" \"XL\"][\"DCCCC\" \"CM\"]]))","problem":104,"user":"50550f43e4b0b1b9d1860eb7"},{"problem":104,"code":"(fn [n]\n  (letfn [(k [x a]\n             (let [q (quot x 10)\n                   r (rem x 10)\n                   ar (* a r)]\n               (if (= 0 q)\n                 [ar]\n                 (cons ar (k q (* a 10))))))]\n    (apply str\n           (map \n             {1 \"I\"   10 \"X\" 100 \"C\" 1000 \"M\"\n              2 \"II\"  20 \"XX\" 200 \"CC\" 2000 \"MM\"\n              3 \"III\" 30 \"XXX\" 300 \"CCC\" 3000 \"MMM\"\n              4 \"IV\"  40 \"XL\" 400 \"CD\"\n              5 \"V\"   50 \"L\" 500 \"D\"\n              6 \"VI\"  60 \"LX\" 600 \"DC\"\n              7 \"VII\" 70 \"LXX\" 700 \"DCC\"\n              8 \"VIII\" 80 \"LXXX\" 800 \"DCCC\"\n              9 \"IX\" 90 \"XC\" 900 \"CM\"}\n             (reverse (k n 1))))))","user":"50f10f7be4b06d9538fe211a"},{"code":"(fn [n] \n  (let [roman-map\n        {3000 \"MMM\", 2000 \"MM\", 1000 \"M\", \n         900 \"CM\", 800 \"DCCC\", 700 \"DCC\", 600 \"DC\", 500 \"D\" 400 \"CD\", 300 \"CCC\", 200 \"CC\", 100 \"C\",\n         90 \"XC\", 80 \"LXXX\", 70 \"LXX\", 60 \"LX\", 50 \"L\", 40 \"XL\", 30 \"XXX\", 20 \"XX\", 10 \"X\",\n         9 \"IX\", 8 \"VIII\", 7 \"VII\", 6 \"VI\", 5 \"V\", 4 \"IV\", 3 \"III\", 2 \"II\", 1 \"I\"}\n        dec-to-roman (fn [[n acc] d] [(rem n d) (conj acc (roman-map (* (quot n d) d)))])]\n    (apply str (filter (comp not nil?) (second (reduce dec-to-roman [n []] [1000 100 10 1]))))))","problem":104,"user":"51cdd3f0e4b0e42293a2254b"},{"problem":104,"code":"(fn [n]\n    (loop [n n s \"\"]\n      (if (zero? n)\n        s\n        (let [r [1000 \\M\n                 900 \"CM\"\n                 500 \\D\n                 400 \"CD\"\n                 100 \\C\n                 90 \"XC\"\n                 50 \\L\n                 40 \"XL\"\n                 10 \\X\n                 9 \"IX\"\n                 5 \\V\n                 4 \"IV\"\n                 1 \\I]\n              [d s'] (first (filter #(<= (first %) n) (partition 2 r)))]\n          (recur (- n d) (str s s'))))))","user":"58b81490e4b0ebc645576d8c"},{"problem":104,"code":"(fn [n]\n  (let [r [\"M\" \"CM\" \"D\" \"CD\" \"C\" \"XC\" \"L\" \"XL\" \"X\" \"IX\" \"V\" \"IV\" \"I\"]\n        d [1000 900 500 400 100 90 50 40 10 9 5 4 1]]\n    (loop [rm n, acc \"\", i 0]\n      (cond (= 0 rm) acc\n            (>= (- rm (d i)) 0) (recur (- rm (d i)) (str acc (r i)) 0)\n            :else (recur rm acc (inc i))))))","user":"538e36c7e4b0b51d73faae81"},{"problem":104,"code":"(fn [n]\n  (loop [res \"\"\n         charset [[\\I \\V] [\\X \\L] [\\C \\D] [\\M]]\n         n n]\n    (if (zero? n) res\n    (let [m (rem n 10)\n          [[I  V] [X _]] (take 2 charset)\n      res (str (cond\n        (= m 9) (str I X)\n        (>= m 5) (apply str V (repeat (rem m 5) I))\n        (= m 4) (str I V)\n        :else (apply str (repeat m I))) res)]\n      (recur res (rest charset) (quot n 10))))))","user":"57642916e4b0994c1922fbee"},{"code":"(fn write-roman [n]\n  (let [v-map {0 [\\I \\V]\n               1 [\\X \\L]\n               2 [\\C \\D]\n               3 [\\M]}]\n    (apply str (loop [current n result [] digit-loc 3 divider 1000]\n      (if (= current 0) result\n        (recur\n          (rem current divider)\n          (let [digit (quot current divider)\n                letters (get v-map digit-loc)]\n            (cond\n              (= 0 digit) result\n              (= 9 digit)\n                (conj result (first letters) (first (get v-map (inc digit-loc))))\n              (>= digit 5)\n                (reduce conj (conj result (second letters))\n                  (repeat (- digit 5) (first letters)))\n              (= 4 digit)\n                (conj result (first letters) (second letters))\n              :else (reduce conj result (repeat digit (first letters)))))\n          (dec digit-loc)\n          (/ divider 10)))))))","problem":104,"user":"4dad76588e77d6ed63f12a44"},{"code":"(fn num-roman [n]\n  (let [values-map {1 [\\I], 4 [\\I \\V], 5 [\\V], 9 [\\I \\X], \n                    10 [\\X], 40 [\\X \\L], 50 [\\L], 90 [\\X \\C] \n                    100 [\\C], 400 [\\C \\D] 500 [\\D], 900 [\\C \\M] 1000 [\\M] }\n        values (sort-by #(- %) (keys values-map))\n        mid-result (reduce (fn [[n num-vec] v]\n                             [(rem n v) (conj num-vec (quot n v))]) [n []] values)]\n    (apply str (apply concat (map #(apply concat \n                                          (for [i (range %2)] (get values-map %1))) \n                                  values (last mid-result))))))","problem":104,"user":"52a55adee4b0c58976d9abe7"},{"problem":104,"code":"(fn [n]\n   (let [numerals {1 \\I\n                   5 \\V\n                   10 \\X\n                   50 \\L\n                   100 \\C\n                   500 \\D\n                   1000 \\M}\n         values (reverse (sort (keys numerals)))\n         grow-numeral (fn [roman & new-digits]\n                        (apply str roman (map numerals new-digits)))\n         power-10? (fn [n]\n                     (loop [r n]\n                       (if (zero? (rem r 10))\n                         (recur (quot r 10))\n                         (= r 1))))\n         try-pick-minuend (fn [digits prev curr]\n                            (loop [tail (rest digits)]\n                              (let [d (or (first tail) 0)\n                                    nxt (or (second tail) 0)]\n                                (if (or (empty? tail)\n                                        (and (power-10? d)\n                                             (<= (/ curr d) 10)\n                                             (or (zero? prev) (>= (/ prev d) 10))\n                                             (> d nxt)))\n                                  d\n                                  (recur (rest tail))))))]\n     (loop [sum 0\n            digits values\n            prev 0\n            times-used 0\n            roman \"\"]\n       (when-not digits\n         (throw (ex-info \"Ran out of digits; either number is not representable or there's a bug\"\n                         {:number n\n                          :current-sum sum\n                          :current-roman roman\n                          :previous-digit prev\n                          :times-used times-used})))\n       (if (= sum n)\n         roman\n         (let [curr (first digits)\n               new-sum (+ sum curr)\n               nxt (try-pick-minuend digits prev curr)]\n           (cond\n             (and (>= n new-sum) (< times-used (if (power-10? curr) 3 1)))\n             (recur new-sum digits curr (inc times-used) (grow-numeral roman curr))\n\n             (and (> nxt 0) (>= n (- new-sum nxt)))\n             (recur (- new-sum nxt) (next digits) nxt 0 (grow-numeral roman nxt curr))\n\n             :default\n             (recur sum (next digits) prev 0 roman)))))))","user":"5169d422e4b051e2a73aba53"},{"code":"(fn [n]\n  (let [m [\n           {0, \"\", 1 \"I\", 2 \"II\", 3 \"III\", 4 \"IV\", 5 \"V\", 6 \"VI\", 7 \"VII\", 8 \"VIII\", 9 \"IX\"}\n           {0, \"\", 1 \"X\", 2 \"XX\", 3 \"XXX\", 4 \"XL\", 5 \"L\", 6 \"LX\", 7 \"LXX\", 8 \"LXXX\", 9 \"XC\"}\n           {0, \"\", 1 \"C\", 2 \"CC\", 3 \"CCC\", 4 \"CD\", 5 \"D\", 6 \"DC\", 7 \"DCC\", 8 \"DCCC\", 9 \"CM\"}\n           {0, \"\", 1 \"M\", 2 \"MM\", 3 \"MMM\"}\n           ]]\n    (apply str (reverse (map (fn [mm c] (mm (- (int c) (int \\0)))) m (reverse (str n)))))))","problem":104,"user":"5063fe48e4b075d771da6f9e"},{"code":"(fn [p] (letfn\n          [(mp [a b c] \n                (fn [n] (cond\n                         (= n 0)        nil\n                         (and (<= 1 n)\n                              (<= n 3)) (apply str (repeat n a))\n                         (= n 4) (str a b)\n                         (= n 5) (str b)\n                         (and (<= 6 n)\n                              (<= n 8)) \n                                  (str b (apply str (repeat (- n 5) a)))\n                         (= n 9) (str a c)\n                         )\n                  )\n                )\n           (nv [x] (map #(Integer/parseInt (str %))\n                         (seq (str\n                          (apply str (repeat (- 4 (count (str x)))\n                                             0)\n                                 )\n                                 x))\n                          )\n                        )                                                \n           \n           ]\n          (str ((mp \"M\" \"\" \"\") (first (nv p)))\n                 ((mp \"C\" \"D\" \"M\") (second (nv p)))\n                 ((mp \"X\" \"L\" \"C\") (nth (nv p) 2))\n                 ((mp \"I\" \"V\"  \"X\") (last (nv p))))\n          \n  ))","problem":104,"user":"517945dce4b0684c1c981a43"},{"problem":104,"code":"(fn [n]\n  (let [conversions\n        [[1000 {0 \"\" 1 \"M\" 2 \"MM\" 3 \"MMM\"}]\n         [100 {0 \"\" 1 \"C\" 2 \"CC\" 3 \"CCC\" 4 \"CD\"\n               5 \"D\" 6 \"DC\" 7 \"DCC\" 8 \"DCCC\" 9 \"CM\"}]\n         [10 {0 \"\" 1 \"X\" 2 \"XX\" 3 \"XXX\" 4 \"XL\"\n              5 \"L\" 6 \"LX\" 7 \"LXX\" 8 \"LXXX\" 9 \"XC\"}]\n         [1 {0 \"\" 1 \"I\" 2 \"II\" 3 \"III\" 4 \"IV\"\n             5 \"V\" 6 \"VI\" 7 \"VII\" 8 \"VIII\" 9 \"IX\"}]]]\n    (apply str\n           (map (fn [[p conv]]\n                  (conv (mod (quot n p) 10)))\n                conversions))))","user":"57f80350e4b0d3187e90090c"},{"problem":104,"code":"(fn f [n]\n   (let [d (sorted-map-by > 1000 \"M\" 900 \"CM\" 500 \"D\" 400 \"CD\" 100 \"C\" 90 \"XC\" 50 \"L\" 40 \"XL\" 10 \"X\" 9 \"IX\" 5 \"V\" 4 \"IV\" 1 \"I\")]\n     (loop [acc \"\" \n            r n]\n       (if (> r 0)\n         (let [x (some #(when (>= r %) %) (keys d))]\n           (recur (str acc (d x)) (- r x)))\n         acc))))","user":"554680cbe4b0a04f7929953e"},{"code":"(fn [v] (loop [x v r \"\"]\r\n  (if-let [[k s] (some #(if (<= (first %) x) %)\r\n    (map vector [1000 900 500  400 100  90   50  40   10   9   5    4   1 ]\r\n                [\"M\" \"CM\" \"D\" \"CD\" \"C\" \"XC\" \"L\" \"XL\" \"X\" \"IX\" \"V\" \"IV\" \"I\"]))]\r\n  (recur (- x k) (str r s))\r\n  r)))","problem":104,"user":"50336c6be4b0c6c1199c710f"},{"problem":104,"code":"(fn [n]\n    (loop [res \"\"\n           digits [[1000 \"M\"]\n                   [500 \"D\"]\n                   [100 \"C\"]\n                   [50  \"L\"]\n                   [10  \"X\"]\n                   [5   \"V\"]\n                   [1   \"I\"]]\n           n n]\n      (if (zero? n)\n        res\n        (let [[val letter] (first digits)\n              [val2 _] (second digits)\n              [val2 letter2] (if (and val2 (= val (* 2 val2))) (nth digits 2) (second digits))]\n          (cond (>= n val)\n                (recur (str res letter) digits (- n val))\n\n                (>= n (- val val2))\n                (recur (str res letter2 letter) (rest digits) (- n (- val val2)))\n\n                :else\n                (recur res (rest digits) n))))))","user":"5db35f85e4b010eb3c36cd22"},{"problem":104,"code":"(fn f\n    ([n]\n     (f n \"\"))\n    ([n s]\n     (let [ss [\"I\" \"IV\" \"V\" \"IX\" \"X\" \"XL\" \"L\" \"XC\" \"C\" \"CD\" \"D\" \"CM\" \"M\"]\n           dd [1 4 5 9 10 40 50 90 100 400 500 900 1000]\n           zz (zipmap dd ss)]\n      (if (zero? n)\n        s\n        (let [x (last (take-while #(<= % n) dd))]\n          (f (- n x) (str s (zz x))))))))","user":"500d3160e4b05f7c30cfa6a1"},{"problem":104,"code":"(fn [n]\n    (let [n (map #(Character/digit % 10) (seq (str n)))\n          nums (interleave (range (dec (count n)) -1 -1) n)]\n      (->> (for [[size n] (partition 2 nums)]\n             (let [size-map {0 {:sub \"I\" :min \"V\"}\n                             1 {:sub \"X\" :min \"L\"}\n                             2 {:sub \"C\" :min \"D\"}\n                             3 {:sub \"M\" :min \"NOTHING\"}}\n                   {:keys [sub min]} (size-map size)\n                   rep-s #(apply str (repeat %1 %2))]\n               (cond\n                 (= n 9) (format \"%s%s\" sub (:sub (size-map (inc size))))\n                 (> n 5) (format \"%s%s\" min (rep-s (- n 5) sub))\n                 (= n 5) min\n                 (= n 4) (format \"%s%s\" sub min)\n                 (< n 5) (rep-s n sub))))\n           (apply str))))","user":"5bc09ebae4b07a9b28b10005"},{"code":"(fn f [n]\n  (cond\n    (>= n 1000) (str \"M\"  (f (- n 1000)))\n    (>= n 900)  (str \"CM\" (f (- n 900)))\n    (>= n 500)  (str \"D\"  (f (- n 500)))\n    (>= n 400)  (str \"CD\" (f (- n 400)))\n    (>= n 100)  (str \"C\"  (f (- n 100)))\n    (>= n 90)   (str \"XC\" (f (- n 90)))\n    (>= n 50)   (str \"L\"  (f (- n 50)))\n    (>= n 40)   (str \"XL\" (f (- n 40)))\n    (>= n 10)   (str \"X\"  (f (- n 10)))\n    (>= n 9)    (str \"IX\" (f (- n 9)))\n    (>= n 5)    (str \"V\"  (f (- n 5)))\n    (>= n 4)    (str \"IV\" (f (- n 4)))\n    (>= n 1)    (str \"I\"  (f (- n 1)))\n    :else       \"\"))","problem":104,"user":"51e00020e4b01188f0627534"},{"problem":104,"code":"(fn r [n]\n  (letfn [(digits [n]\n            (if (pos? n) (cons (rem n 10) (digits (quot n 10)))))]\n    (let [[a b c d] (digits n)]\n      (apply str (reverse (filter identity\n        [ ({1 \"I\" 2 \"II\" 3 \"III\" 4 \"IV\" 5 \"V\" 6 \"VI\" 7 \"VII\" 8 \"VIII\" 9 \"IX\"} a)\n          ({1 \"X\" 2 \"XX\" 3 \"XXX\" 4 \"XL\" 5 \"L\" 6 \"LX\" 7 \"LXX\" 8 \"LXXX\" 9 \"XC\"} b)\n          ({1 \"C\" 2 \"CC\" 3 \"CCC\" 4 \"CD\" 5 \"D\" 6 \"DC\" 7 \"DCC\" 8 \"DCCC\" 9 \"CM\"} c)\n          ({1 \"M\" 2 \"MM\" 3 \"MMM\" 4 \"MMMM\"} d) ]))))))","user":"53d78b64e4b0e771c3025466"},{"code":"(fn as-roman-number [number]\n  (loop [leftover number\n         sofar \"\"]\n    (if (= leftover 0)\n      (apply str sofar)\n      (cond\n        (>= leftover 1000) (recur (- leftover 1000)\n                            (concat sofar \"M\"))\n        (>= leftover 900) (recur (- leftover 900)\n                           (concat sofar \"CM\"))\n        (>= leftover 500) (recur (- leftover 500)\n                           (concat sofar \"D\"))\n        (>= leftover 400) (recur (- leftover 400)\n                           (concat sofar \"CD\"))\n        (>= leftover 100) (recur (- leftover 100)\n                           (concat sofar \"C\"))\n        (>= leftover 90) (recur (- leftover 90)\n                          (concat sofar \"XC\"))\n        (>= leftover 50) (recur (- leftover 50)\n                          (concat sofar \"L\"))\n        (>= leftover 40) (recur (- leftover 40)\n                          (concat sofar \"XL\"))\n        (>= leftover 10) (recur (- leftover 10)\n                          (concat sofar \"X\"))\n        (>= leftover 9) (recur (- leftover 9)\n                         (concat sofar \"IX\"))\n        (>= leftover 5) (recur (- leftover 5)\n                          (concat sofar \"V\"))\n        (>= leftover 4) (recur (- leftover 4)\n                          (concat sofar \"IV\"))\n        :else (recur (- leftover 1)\n                (concat sofar \"I\"))))))","problem":104,"user":"515737f0e4b0b0b4b87062d0"},{"problem":104,"code":"(fn rn [n]\n  (let [values '((1000 \"M\") (900 \"CM\") (500 \"D\") (400 \"CD\")\n                 (100 \"C\") (90 \"XC\") (50 \"L\") (40 \"XL\")\n                 (10 \"X\") (9 \"IX\") (5 \"V\") (4 \"IV\") (1 \"I\"))\n        inner (fn inner [n less-vals]\n                (cond\n                  (zero? n) nil\n                  (< 0 (quot n (ffirst less-vals))) (cons (nfirst less-vals) (lazy-seq (inner (- n (ffirst less-vals)) values)))\n                  :else\n                  (inner n (rest less-vals))))]\n  (apply str (flatten (inner n values)))))","user":"55934bebe4b0c79f6e1db93b"},{"code":"(fn [x]\n  (let [qta [1000 900 500 400 100 90 50 40 10 9 5 4 1]\n        enc {1000 \"M\" 900 \"CM\" 500 \"D\" 400 \"CD\" 100 \"C\" 90 \"XC\" 50 \"L\" 40 \"XL\" 10 \"X\" 9 \"IX\" 5 \"V\" 4 \"IV\" 1 \"I\"}]\n    (loop [n x r \"\"]\n      (if (= 0 n)\n        r\n        (let [w (first (filter (fn [x] (<= x n)) qta))\n              l (enc w)]\n          (recur (- n w) (str r l)))))))","problem":104,"user":"52c81954e4b0c2d177d6212e"},{"code":"(fn write-roman-num [n]\n(letfn [(digits [n] (->> (iterate #(quot % 10) n) (take-while pos?) (map #(mod % 10)) )  )\n        (decimal-repr [n] (->> (digits n) (map vector (iterate #(* % 10) 1)) reverse ) )\n        (rd [val pos] (condp = [val pos] [1 1] \\I [5 1] \\V [1 10] \\X [5 10] \\L [1 100] \n                                      \\C [5 100] \\D [1 1000] \\M ) )\n        (decimal-to-roman [[p d]] (condp >= d 0 [] 3 (repeat d (rd 1 p)) 4 [(rd 1 p) (rd 5 p)] \n                                       8 (cons (rd 5 p) (repeat (- d 5) (rd 1 p))) 9 [(rd 1 p) (rd 1 (* p 10))]  )  )]\n  (->> (decimal-repr n) (mapcat decimal-to-roman) (apply str) ))\n)","problem":104,"user":"51729002e4b044b2ef48a850"},{"problem":104,"code":"(fn [n]\n  (let [romans {1  \"I\", 4 \"IV\", 5 \"V\", 9 \"IX\", 10 \"X\", 40 \"XL\"\n                50 \"L\", 90 \"XC\", 100 \"C\", 400 \"CD\", 500, \"D\", 900 \"CM\", 1000 \"M\"}\n        bases (into [] (reverse (sort (keys romans))))]\n    (letfn [(find-base [n] (some #(and (>= n %) %) bases))]\n      (loop [result [] n n]\n        (if (zero? n)\n          (clojure.string/join result)\n          (let [base (find-base n)]\n            (recur (conj result (romans base))\n                   (- n base))))))))","user":"59c94a69e4b0a024fb6ae576"},{"problem":104,"code":"(fn convert\n   ([num] (convert \"\" num))\n   ([output num]\n    (let [roman (sorted-map-by > 1000 \"M\", 900 \"CM\", 500 \"D\", 400 \"CD\", 100 \"C\", 90 \"XC\",\n                               50 \"L\", 40 \"XL\", 10 \"X\", 9 \"IX\", 5 \"V\", 4 \"IV\",  1 \"I\")]\n      (if (= 0 num)\n        output\n        (let [nextRoman (first (filter #(<= (key %) num) roman))]\n          (recur (str output (val nextRoman)) (- num (key nextRoman))) )))))","user":"58d27bcae4b03c36ff7e58fe"},{"problem":104,"code":"#(let [digits (fn [x] (map (comp read-string str) (str x)))\npower-map (fn [u i d] \n{0 \"\" 1 (str u) 2 (str u u) 3 (str u u u) 4 (str u i) \n            5 (str i) 6 (str i u) 7 (str i u u) 8 (str i u u u) 9 (str u d)})\nm {0 (power-map \"I\" \"V\" \"X\") \n   1 (power-map \"X\" \"L\" \"C\") \n   2 (power-map \"C\" \"D\" \"M\") \n   3 {0 \"\" 1 \"M\" 2 \"MM\" 3 \"MMM\"}}\nf (fn [power x] (get-in m [power x]))]\n(->> (digits %)\n(reverse)\n(map-indexed f)\n(reverse)\n(apply str)))\n;digits function based on chouser's solution of problem 99 Product Digits","user":"5e13a6b7e4b099d064963001"},{"problem":104,"code":"(fn arab-to-roman [arab]\n  (let [normal (fn [one five next] {1 [one]\n                                    2 [one one]\n                                    3 [one one one]\n                                    4 [one five]\n                                    5 [five]\n                                    6 [five one]\n                                    7 [five one one]\n                                    8 [five one one one]\n                                    9 [one next]\n                                    0 []})\n        thousands (fn [x] (repeat x \"M\"))\n        generators [thousands\n                    (normal \"C\" \"D\" \"M\")\n                    (normal \"X\" \"L\" \"C\")\n                   (normal \"I\" \"V\" \"X\")]]\n    (->> (loop [gens generators\n                n arab\n                result []\n                ten-pow 1000]\n           (if (empty? gens) result\n             (let [digit (quot n ten-pow)\n                   [gen & restgen] gens]\n               (recur \n                 restgen \n                 (- n (* ten-pow digit)) \n                 (conj result (gen digit)) \n                 (/ ten-pow 10)))))\n      flatten\n      (apply str))))","user":"53c38b8ce4b00fb29b22127b"},{"code":"#(let [nums {1 [\\I \\V \\X], 10 [\\X \\L \\C], 100 [\\C \\D \\M]}\n       to_str (fn s [base num]\n                (cond\n                  (zero? num) nil\n                  (= 1000 base) (apply str (repeat num \\M))\n                  :else (let [map (nums base)\n                              one (map 0)\n                              five (map 1)\n                              ten (map 2)]\n                          (cond\n                            (< num 4) (apply str (repeat num one))\n                            (= num 4) (str one five)\n                            (= num 5) (str five)\n                            (< num 9) (str five (s base (- num 5)))\n                            (= num 9) (str one ten)))))]\n    (str\n      (to_str 1000 (quot % 1000))\n      (to_str 100 (quot (mod % 1000) 100))\n      (to_str 10 (quot (mod % 100) 10))\n      (to_str 1 (mod % 10))))","problem":104,"user":"52667ecfe4b03e8d9a4a713e"},{"problem":104,"code":"(fn number->roman [num]\n  (let [conversion {3000 \"MMM\"\n                    2000 \"MM\"\n                    1000 \"M\"\n                    900 \"CM\"\n                    800 \"DCCC\"\n                    700 \"DCC\"\n                    600 \"DC\"\n                    500 \"D\"\n                    400 \"CD\"\n                    300 \"CCC\"\n                    200 \"CC\"\n                    100 \"C\"\n                    90 \"XC\"\n                    80 \"LXXX\"\n                    70 \"LXX\"\n                    60 \"LX\"\n                    50 \"L\"\n                    40 \"XL\"\n                    30 \"XXX\"\n                    20 \"XX\"\n                    10 \"X\"\n                    9 \"IX\"\n                    8 \"VIII\"\n                    7 \"VII\"\n                    6 \"VI\"\n                    5 \"V\"\n                    4 \"IV\"\n                    3 \"III\"\n                    2 \"II\"\n                    1 \"I\"}]\n  (letfn [(intlist [x]\n            ((fn [acc n]\n               (if (zero? n)\n                 acc\n                 (recur (cons (mod n 10) acc) (int (/ n 10))))) '() x))\n          (to-rom [n]\n              (get conversion n))]\n    (apply str\n                (first\n                 (reduce\n                   (fn [acc n]\n                     [(concat\n                       (to-rom (* n (second acc)))\n                       (first acc))\n                      (* 10 (second acc))])\n                   [\"\" 1]\n                   (reverse (intlist num))))))))","user":"540e8d13e4b0addc1aec671e"},{"problem":104,"code":"(fn __ [n]\n  (let [\n          aa (map #(Integer/parseInt %) (map str (seq (str n))))\n          table [[\"\" \"I\" \"II\" \"III\" \"IV\" \"V\" \"VI\" \"VII\" \"VIII\" \"IX\"]\n                 [\"\" \"X\" \"XX\" \"XXX\" \"XL\" \"L\" \"LX\" \"LXX\" \"LXXX\" \"XC\"]\n                 [\"\" \"C\" \"CC\" \"CCC\" \"CD\" \"D\" \"DC\" \"DCC\" \"DCCC\" \"CM\"]\n                 [\"\" \"M\" \"MM\" \"MMM\"]]\n          transse (reverse (map-indexed (fn [ind val] (nth (nth table ind) val) ) (reverse aa)))\n          stringed (clojure.string/join \"\" transse)\n        ]\n        stringed))","user":"58bc6a88e4b0888cdc949d16"},{"code":"(fn num->roman [x]\n  (let [roman [[nil \"I\" \"II\" \"III\" \"IV\" \"V\" \"VI\" \"VII\" \"VIII\" \"IX\"],\n               [nil \"X\" \"XX\" \"XXX\" \"XL\" \"L\" \"LX\" \"LXX\" \"LXXX\" \"XC\"],\n               [nil \"C\" \"CC\" \"CCC\" \"CD\" \"D\" \"DC\" \"DCC\" \"DCCC\" \"CM\"],\n               [nil \"M\" \"MM\" \"MMM\"]]]\n    (->> (map #(- (int %) 48) (str x))\n         reverse\n         (map #(%1 %2) roman)\n         reverse\n         (apply str))))","problem":104,"user":"4f3fb586e4b0e243712b1f9c"},{"problem":104,"code":"(fn romanic [arabic] \n    (let [ values { 1    \"I\" 4   \"IV\"   5   \"V\"  9   \"IX\"  8 \"VIII\"    6 \"VI\" 7 \"VII\"\n                    10   \"X\" 40  \"XL\"   50  \"L\"  90  \"XC\"  80 \"LXXX\"   60 \"LX\" 70 \"LXX\"\n                    100  \"C\" 400 \"CD\"   500 \"D\"  900 \"CM\"  800 \"DCCC\"  600 \"DC\" 700 \"DCC\"\n                    1000 \"M\" } \n            single   (mod arabic 10) \n            tens     (- (mod arabic 100) single)\n            hunds    (- (mod arabic 1000) tens single)\n            thous    (- (mod arabic 10000) hunds tens single)\n\n            helper    (fn [oppa basis divis] (if (values oppa) (values oppa) \n                                           (clojure.string/join (repeat (/ oppa divis) basis))))\n          ]\n          (println single tens hunds thous)\n          (apply str \n                 (helper thous \"M\" 1000)\n                 (helper hunds \"C\" 100) \n                 (helper tens \"X\" 10) \n                 (helper single \"I\" 1))))","user":"564127a9e4b08d4f616f5ef3"},{"problem":104,"code":"(fn [n]\n  (let [romans {1 \"I\" 10 \"X\" 100 \"C\" 1000 \"M\"}\n        roman-num (apply str \n                         (map romans \n                              (reduce #(concat % (repeat (mod (quot n %2) 10) %2)) \n                                      [] [1000 100 10 1])))]\n    (println roman-num)\n    (-> roman-num\n        (clojure.string/replace \"CCCCCCCCC\" \"CM\")\n        (clojure.string/replace \"CCCCC\" \"D\")\n        (clojure.string/replace \"CCCC\" \"CD\")\n        (clojure.string/replace \"XXXXXXXXX\" \"XC\")\n        (clojure.string/replace \"XXXXX\" \"L\")\n        (clojure.string/replace \"XXXX\" \"XL\")\n        (clojure.string/replace \"IIIIIIIII\" \"IX\")\n        (clojure.string/replace \"IIIII\" \"V\")\n        (clojure.string/replace \"IIII\" \"IV\"))))","user":"534fa9dae4b084c2834f4acf"},{"problem":104,"code":"(fn roman [n]\n  (let [units [\"\" \"I\" \"II\" \"III\" \"IV\" \"V\" \"VI\" \"VII\" \"VIII\" \"IX\"]\n        tens [\"\" \"X\" \"XX\" \"XXX\" \"XL\" \"L\" \"LX\" \"LXX\" \"LXXX\" \"XC\"]\n        hundreds [\"\" \"C\" \"CC\" \"CCC\" \"CD\" \"D\" \"DC\" \"DCC\" \"DCCC\" \"CM\"]\n        thousands (vec (map #(apply str (repeat % \"M\")) (range 10)))\n        digits (map #(Integer/parseInt (str %)) (format \"%04d\" n))]\n    (str (thousands (nth digits 0))\n         (hundreds (nth digits 1))\n         (tens (nth digits 2))\n         (units (nth digits 3)))))","user":"605b7a90e4b079a07f8593fc"},{"problem":104,"code":"(fn f104 [i] \n  (letfn [(dig-to-rim [i s] \n  (let [rim [\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\",\" \"]\n        arb '(1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1, 0)\n        raa (map #(vector % %2) rim arb)\n        ]\n    (let [value (first (filter #(<= (second %) i)  raa))]\n      [(concat s (str (first value)))\n       (- i (second value))]\n)))]\n(let [ val (dig-to-rim i \"\")]\n    (if (zero? (second val)) \n      (apply str (first val))\n      (apply str (concat (first val) (f104 (second val))))\n      ))))","user":"51f81925e4b09be9c177e526"},{"code":"(fn roman-numerals\n  ; I V X L C D M \n  ; 0 1 2 3 4 5 6\n  [n]\n  (let [rm-digits [[] [0] [0 0] [0 0 0] [0 1] [1] [1 0] [1 0 0] [1 0 0 0] [0 2]]\n        rm-chars  \"IVXLCDM\"\n        to-rn     (fn to-rn [s pl]\n                    (if (seq? s)\n                      (into (vec (map (partial + pl) (rm-digits (first s))))\n                            (to-rn (next s) (- pl 2)))\n                      []))\n        char->num #(- (int %) 48)\n        digits \t  (map char->num (seq (str n)))]\n    (apply str (map (partial nth rm-chars) (to-rn digits (* 2 (- (count digits) 1)))))))","problem":104,"user":"511b233ae4b07ab9ec456180"},{"code":"(fn to-roman [a-num]\n\t (let [vals [[\\I \\V \\X] [\\X \\L \\C] [\\C \\D \\M] [\\M]]]\n\t\t(letfn [ \n\t\t\t\t(nth-digit [a-num n]\n\t\t\t\t\t(rem (quot a-num (int (Math/pow 10 n))) 10)\n\t\t\t\t)\n\t\t\t\t(digit-to-roman [ digit args ]\n\t\t\t\t\t(let [ [o f t] args]\n\t\t\t\t\t\t(cond\n\t\t\t\t\t\t\t(< digit 4) (repeat digit o)\n\t\t\t\t\t\t\t(= digit 4) [o f]\n\t\t\t\t\t\t\t(< digit 9) (cons f (repeat (- digit 5) o))\n\t\t\t\t\t\t\t:else [o t]\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t\t(nth-romans [a-num n]\n\t\t\t\t\t(digit-to-roman (nth-digit a-num n) (nth vals n))\n\t\t\t\t)\n\t\t\t\t]\n\t\t\t(apply str (mapcat #(nth-romans a-num %) (range 3 -1 -1)))\n\t\t)\n\t)\n)","problem":104,"user":"52763696e4b03e8d9a4a74d7"},{"code":"(fn rom [n]\n  (let [nums [[1000 \"M\"] [900 \"CM\"] [500 \"D\"] [400 \"CD\"]\n              [100 \"C\"] [90 \"XC\"] [50 \"L\"] [40 \"XL\"] [10 \"X\"]\n              [9 \"IX\"] [5 \"V\"] [4 \"IV\"] [1 \"I\"]]]\n       (if (= 0 n) \n           \"\"\n           (let [curr (first (drop-while #(> (first %) n) nums))]\n                (apply str (concat (second curr) (rom (- n (first curr)))))))))","problem":104,"user":"4f13047d535d64f60314642c"},{"problem":104,"code":"(fn [n]\n   (let [\n         k { 0 [\\I \\V \\X] \n             1 [\\X \\L \\C]\n             2 [\\C \\D \\M]\n             3 [\\M nil nil]}\n         ]\n     (loop [xn (map #(Integer/parseInt (str %)) (str n))\n            d 0\n            r \"\"\n            ]\n       (if-let [x (last xn)]\n         (let [ f (k d)         \n               Rx (cond\n                (< x 4) (apply str (repeat x (f 0)))\n                (= x 4) (str (f 0) (f 1))\n                (< x 9) (str (f 1) (apply str (repeat (- x 5) (f 0))))\n                (= x 9) (str (f 0) (f 2)))]\n         (recur (drop-last xn) (inc d) (str Rx r)))\n         r\n         ))))","user":"5412646de4b01498b1a719d4"},{"problem":104,"code":"(fn sol \n  ([x] (apply str (reverse (sol x 0))))\n  ([x idx]\n   (let [table [[\"I\" \"V\" \"X\"]\n                [\"X\" \"L\" \"C\"]\n                [\"C\" \"D\" \"M\"]\n                [\"M\" \" \" \" \"]]]\n     (let [convert (fn [y a b c] \n                     (case (str y)\n                       \"1\" (str a)\n                       \"2\" (str a a)\n                       \"3\" (str a a a)\n                       \"4\" (str a b)\n                       \"5\" (str b)\n                       \"6\" (str b a)\n                       \"7\" (str b a a)\n                       \"8\" (str b a a a)\n                       \"9\" (str a c)\n                       \"\"))]\n       (if (empty? (rest (seq (str x))))\n         (list (convert (last (seq (str x))) \n                        (first (nth table idx)) \n                        (second (nth table idx)) \n                        (last (nth table idx))))\n         (cons (convert (last (seq (str x))) \n                        (first (nth table idx)) \n                        (second (nth table idx)) \n                        (last (nth table idx)))\n               (sol (Integer. (apply str \n                                     (drop-last (seq (str x))))) \n                    (inc idx))))))))","user":"52e17e66e4b09f7907dd1423"},{"problem":104,"code":"(fn [n]\n    (let [values {1000 [\"\" \"M\" \"MM\" \"MMM\" \"MMMM\"]\n                  100  [\"\" \"C\" \"CC\" \"CCC\" \"CD\" \"D\" \"DC\" \"DCC\" \"DCCC\" \"CM\"]\n                  10   [\"\" \"X\" \"XX\" \"XXX\" \"XL\" \"L\" \"LX\" \"LXX\" \"LXXX\" \"XC\"]\n                  1    [\"\" \"I\" \"II\" \"III\" \"IV\" \"V\" \"VI\" \"VII\" \"VIII\" \"IX\"]}]\n      (letfn [(step [n N]\n                (when (pos? n)\n                  (str\n                   (get-in values [N (quot n N)])\n                   (step (rem n N) (/ N 10)))))]\n        (step n 1000))))","user":"5d236215e4b02ea6f0fb6a09"},{"problem":104,"code":"(fn write-roman [n]\n  (let [romans '([1000 \"M\"]\n                 [900 \"CM\"]\n                 [500 \"D\"]\n                 [400 \"CD\"]\n                 [100 \"C\"]\n                 [90 \"XC\"]\n                 [50 \"L\"]\n                 [40 \"XL\"]\n                 [10 \"X\"]\n                 [9 \"IX\"]\n                 [5 \"V\"]\n                 [4 \"IV\"]\n                 [1 \"I\"])\n        digits (->> n str vec (map #(Character/digit % 10)))]\n    (loop [n n\n           [[p v] & others :as all] romans\n           res []]\n      ;; (prn n p v)\n      (if (empty? all)\n        (->> res (remove empty?) flatten (apply str))\n        (let [[p v] (first all)\n              others (rest all)]\n         (recur (rem n p)\n                others\n                (conj res (repeat (quot n p) v)))\n         )\n        ))))","user":"5c950334e4b048ec896c5a44"},{"code":"(fn roman-numerals\n  [num]\n  (let [roman-numeral-from-digit\n        (fn [digit p10]\n          (let [[one five ten]\n                (nth (partition 3 2 [\"I\" \"V\" \"X\" \"L\" \"C\" \"D\" \"M\" nil nil]) p10)]\n            (cond\n             (<= digit 3) (repeat digit one)\n             (<= digit 5) (concat (repeat    (- 5 digit) one) (list five))\n             (<= digit 8) (concat (list five) (repeat (- digit 5) one))\n             :else        (concat (repeat (- 10 digit) one) (list ten)))))\n        numerals (fn this [remaining p10]\n                   (when (<= 0 p10)\n                     (let [n (int (/ remaining (Math/pow 10 p10)))]\n                       (concat (roman-numeral-from-digit n p10)\n                               (this (mod num (int (Math/pow 10 p10)))\n                                     (dec p10))))))]\n    (apply str (numerals num (int (Math/log10 num))))))","problem":104,"user":"4e68c434535d8ccf87e9fe89"},{"code":"(fn [n] (apply str                                                                                                                                                                                                \n          (loop [acc [] l (map str (str n))]                                                                                                                                                                    \n            (if (or (empty? l) (empty? (filter #((comp not = ) \"0\" %) l))) acc                                                                                                                                  \n                (let [x (int (* (Integer/parseInt (first l)) (Math/pow 10 (count (rest l)))))]                                                                                                                  \n                  (cond (< 999 x 4000) (recur (conj acc (apply str (repeat (Integer/parseInt (first l)) \"M\"))) (rest l))                                                                                        \n                        (< 99 x 400) (recur (conj acc (apply str (repeat (Integer/parseInt (first l)) \"C\"))) (rest l))                                                                                          \n                        (= x 400) (recur (conj acc \"CD\") (rest l))                                                                                                                                              \n                        (= x 500) (recur (conj acc \"D\") (rest l))                                                                                                                                               \n                        (= x 600) (recur (conj acc \"DC\") (rest l))                                                                                                                                              \n                        (= x 700) (recur (conj acc \"DCC\") (rest l))                                                                                                                                             \n                        (= x 800) (recur (conj acc \"DCCC\") (rest l))                                                                                                                                            \n                        (= x 900) (recur (conj acc \"CM\") (rest l))                                                                                                                                              \n                        (= x 1000) (recur (conj acc \"M\") (rest l))                                                                                                                                              \n                        (< 9 x 40) (recur (conj acc (apply str (repeat (Integer/parseInt (first l)) \"X\"))) (rest l))                                                                                            \n                        (= x 40) (recur (conj acc \"XL\") (rest l))                                                                                                                                               \n                        (= x 50) (recur (conj acc \"L\") (rest l))                                                                                                                                                \n                        (= x 60) (recur (conj acc \"LX\") (rest l))                                                                                                                                               \n                        (= x 70) (recur (conj acc \"LXX\") (rest l))                                                                                                                                              \n                        (= x 80) (recur (conj acc \"LXXX\") (rest l))                                                                                                                                             \n                        (= x 90) (recur (conj acc \"XC\") (rest l))                                                                                                                                               \n                        (< 0 x 4) (recur (conj acc (apply str (repeat (Integer/parseInt (first l)) \"I\"))) (rest l))                                                                                             \n                        (= x 4) (recur (conj acc \"IV\") (rest l))                                                                                                                                              \n                        (= x 5) (recur (conj acc \"V\") (rest l))                                                                                                                                               \n                        (= x 6) (recur (conj acc \"VI\") (rest l))                                                                                                                                                \n                        (= x 7) (recur (conj acc \"VII\") (rest l))                                                                                                                                               \n                        (= x 8) (recur (conj acc \"VIII\") (rest l))                                                                                                                                              \n                        (= x 9) (recur (conj acc \"IX\") (rest l))))))))","problem":104,"user":"52265e41e4b04e78ff2e1981"},{"problem":104,"code":"(fn convert-to-roman [x]\n\t(let [decimals \n          [1   4   5   9 \n           10  40  50  90 \n           100 400 500 900 1000]\t\t  \n          romans \n          [\"I\" \"IV\" \"V\" \"IX\" \n           \"X\" \"XL\" \"L\" \"XC\" \n           \"C\" \"CD\" \"D\" \"CM\" \"M\"]\n          constants (zipmap decimals romans)]\n        (loop [r \"\" d x]\n        \t(if (zero? d) r\n        \t\t(let [nearest-num \n                      (apply max (filter #(<= % d) decimals))]\n                    (recur (str r (constants nearest-num))\n                    \t   (- d nearest-num)))))))","user":"5af8221ce4b0cc2b61a3bccd"},{"problem":104,"code":"(fn [n] (->> (map \t  #(quot n %) [1000 100 10 1])\n             (map \t  #(mod  % 10))\n             (mapcat  #(cond (= %4 4) [% %2] \n                        \t (= %4 9) [% %3]\n                            :else (mapcat repeat [(quot %4 5)(mod %4 5)] [%2 %]))\n                     \"MCXI\" \"-DLV\" \"-MCX\")\n             (apply str)\n))","user":"5603c31fe4b04bb52996e1c1"},{"code":"(fn [n]\n  (first\n   (reduce (fn [[out r], [i s]]\n             [(apply str (cons out (repeat (quot r i) s))) (rem r i)])\n           [\"\" n]\n           [[1000 \"M\"] [900 \"CM\"] [500 \"D\"] [400 \"CD\"] [100 \"C\"] [90 \"XC\"] [50 \"L\"] [40 \"XL\"] [10 \"X\"] [9 \"IX\"] [5 \"V\"] [4 \"IV\"] [1 \"I\"]])))","problem":104,"user":"4f83665ee4b033992c121c1c"},{"code":"(fn f [n]\n  (if (= n 0) \"\"\n  (let [m (map vector [1000 900 500 400 100 90 50 40 10 9 5 4 1]\n               (interleave \"MDCLXVI\" [\"CM\" \"CD\" \"XC\" \"XL\" \"IX\" \"IV\" 0]))\n        [[x s]] (drop-while #(> (first %) n) m)]\n    (str s (f (- n x))))))","problem":104,"user":"4ebaf790535dfed6da9c6d6e"},{"problem":104,"code":";; Okay, for me this problem turned out to be way harder than the #92 :)\n\n(fn to-roman [n]\n  (letfn [(num->sym-and-base [n]\n            (cond\n              (<= 1   n 3)    [\"I\" 1]\n              (<= 4   n 8)    [\"V\" 5]\n              (<= 9   n 39)   [\"X\" 10]\n              (<= 40  n 89)   [\"L\" 50]\n              (<= 90  n 399)  [\"C\" 100]\n              (<= 400 n 899)  [\"D\" 500]\n              (<= 900 n 4000) [\"M\" 1000]))\n          (lower-base-for [base]\n            ({1 1 5 1 10 1 50 10 100 10 500 100 1000 100} base))]\n    (loop [n n res \"\" prev-sym \"\" prev-base 0]\n      (cond (zero? n) (str res prev-sym)\n            (< n 0) (let [new-base (lower-base-for prev-base)\n                          [new-base-sym _] (num->sym-and-base new-base)\n                          n (+ new-base n)\n                          [base sym] (num->sym-and-base n)]\n                      (recur n (str res new-base-sym prev-sym) \"\" 0))\n            (> n 0) (let [[sym base] (num->sym-and-base n)]\n                      (recur (- n base) (str res prev-sym) sym base))))))","user":"5591cc56e4b0604b3f94d582"},{"problem":104,"code":"(fn get-numeral\n  [n]\n  (loop [n  n\n         res []]\n    (if (zero? n)\n      (clojure.string/join res)\n\n      (cond\n        (>= n 1000)  (recur (rem n 1000)\n                            (into res (mapv (constantly \"M\") (range (quot n 1000)))))\n        (>= n 900)   (recur (rem n 900)\n                            (conj res \"CM\"))\n        (>= n 500)   (recur (rem n 500)\n                            (conj res \"D\"))\n        (>= n 400)   (recur (rem n 500)\n                            (conj res \"CD\"))\n        (>= n 100)   (recur (rem n 100)\n                            (into res (mapv (constantly \"C\") (range (quot n 100)))))\n        (>= n 90)    (recur (rem n 90)\n                            (conj res \"XC\"))\n        (>= n 50)    (recur (rem n 50)\n                            (conj res \"L\"))\n        (>= n 40)    (recur (rem n 40)\n                            (conj res \"XL\"))\n        (>= n 10)    (recur (rem n 10)\n                            (into res (mapv (constantly \"X\") (range (quot n 10)))))\n        (= n 9)      (recur (rem n 9)\n                            (conj res \"IX\"))\n        (>= n 5)     (recur (rem n 5)\n                            (conj res \"V\"))\n        (= n 4)      (recur (rem n 4)\n                            (conj res \"IV\"))\n        :else        (recur 0\n                            (into res (mapv (constantly \"I\") (range n))))))))","user":"50aa60bee4b056ee01935865"},{"problem":104,"code":"#(loop [x %\n        s []]\n   (cond (= 0 x) (apply str s)\n         (>= x 1000) (recur (rem x 1000) (reduce conj s (repeat (quot x 1000) \\M)))\n         (>= x 900) (recur (rem x 900) (conj s \\C \\M))\n         (>= x 500) (recur (rem x 500) (conj s \\D))\n         (>= x 400) (recur (rem x 400) (conj s \\C \\D))\n         (>= x 100) (recur (rem x 100) (reduce conj s (repeat (quot x 100) \\C)))\n         (>= x 90) (recur (rem x 90) (conj s \\X \\C))\n         (>= x 50) (recur (rem x 50) (conj s \\L))\n         (>= x 40) (recur (rem x 40) (conj s \\X \\L))\n         (>= x 10) (recur (rem x 10) (reduce conj s (repeat (quot x 10) \\X)))\n         (>= x 9) (recur (rem x 9) (conj s \\I \\X))\n         (>= x 5) (recur (rem x 5) (conj s \\V))\n         (>= x 4) (recur (rem x 4) (conj s \\I \\V))\n         (>= x 1) (recur (rem x 1) (reduce conj s (repeat (quot x 1) \\I)))))","user":"55e732c5e4b050e68259b492"},{"problem":104,"code":"(fn [d]\n  (let [m {0 [\"\" \"\" \"\" \"\"]\n           1 [\"I\" \"X\" \"C\" \"M\"]\n           2 [\"II\" \"XX\" \"CC\" \"MM\"]\n           3 [\"III\" \"XXX\" \"CCC\" \"MMM\"]\n           4 [\"IV\" \"XL\" \"CD\" \"MMMM\"]\n           5 [\"V\" \"L\" \"D\" \"MMMMM\"]\n           6 [\"VI\" \"LX\" \"DC\" \"MMMMMM\"]\n           7 [\"VII\" \"LXX\" \"DCC\" \"MMMMMMM\"]\n           8 [\"VIII\" \"LXXX\" \"DCCC\" \"MMMMMMMM\"]\n           9 [\"IX\" \"XC\" \"CM\" \"MMMMMMMMM\"]}]\n    (loop [q d i 0 res ()]\n      (if (pos? q)\n        (recur (quot q 10) (inc i) (conj res (get-in m [(rem q 10) i])))\n        (apply str res)))))","user":"57b3efb1e4b0fbc9809a278a"},{"problem":104,"code":"(fn roman-numeral [n]\n  (condp <= n\n      4000 nil\n      1000 (str \"M\" (roman-numeral (- n 1000)))\n      900 (str \"CM\" (roman-numeral (- n 900)))\n      500 (str \"D\" (roman-numeral (- n 500)))\n      400 (str \"CD\" (roman-numeral (- n 400)))\n      100 (str \"C\" (roman-numeral (- n 100)))\n      90 (str \"XC\" (roman-numeral (- n 90)))\n      50 (str \"L\" (roman-numeral (- n 50)))\n      40 (str \"XL\" (roman-numeral (- n 40)))\n      10 (str \"X\" (roman-numeral (- n 10)))\n      9 (str \"IX\" (roman-numeral (- n 9)))\n      5 (str \"V\" (roman-numeral (- n 5)))\n      4 (str \"IV\" (roman-numeral (- n 4)))\n      1 (str \"I\" (roman-numeral (dec n)))\n      nil))","user":"5f37263de4b0574c87022c4e"},{"problem":104,"code":"(fn roman-numeral [n]\n    (let [converter {1 \"I\", 4 \"IV\", 5 \"V\", 9 \"IX\", 10 \"X\", 40 \"XL\", 50 \"L\", 90 \"XC\", 100 \"C\", 400 \"CD\", 500 \"D\", 900 \"CM\", 1000 \"M\"}\n          keys- (reverse (sort (keys converter)))]\n      (apply str (loop [i 0\n                        ans ()\n                        temp-n n]\n                   (if (= 0 temp-n)\n                     ans\n                     (if (>= temp-n (nth keys- i))\n                       (recur i (concat ans (list (get converter (nth keys- i)))) (- temp-n (nth keys- i)))\n                       (recur (inc i) ans temp-n)))))))","user":"58dcb8cde4b0a4d5acaab6a7"},{"problem":104,"code":"(fn [n]\n   (let [roman (fn roman [n]\n                 (cond (> n 1000) (concat [\"M\"] (roman (- n 1000)))\n                       (> n 899)  (concat [\"C\"] (roman (+ n 100)))\n                       (> n 499)  (concat [\"D\"] (roman (- n 500)))\n\n                       (> n 99)   (concat [\"C\"] (roman (- n 100)))\n                       (> n 89)   (concat [\"X\"] (roman (+ n 10)))\n                       (> n 49)   (concat [\"L\"] (roman (- n 50)))\n                       (> n 39)   (concat [\"X\"] (roman (+ n 10)))\n\n                       (> n 10)   (concat [\"X\"] (roman (- n 10)))\n                       (> n 8)    (concat (repeat (- 10 n) \"I\") [\"X\"])\n                       (> n 4)    (concat [\"V\"] (repeat (- n 5) \"I\"))\n                       (= n 4)    [\"IV\"]\n                       :else      (repeat n \"I\")))]\n       (apply str (roman n))))","user":"5b073c34e4b0cc2b61a3bda4"},{"problem":104,"code":"(fn mything [number]\n  (let [symbols {\n              1000 \"M\"\n              900 \"CM\"\n              500 \"D\"\n              400 \"CD\"\n              100 \"C\"\n              90 \"XC\"\n              50 \"L\"\n              40 \"XL\"\n              10 \"X\"\n              9 \"IX\"\n              5 \"V\"\n              4 \"IV\"\n              1 \"I\"\n              }\n        numbers (reverse (sort (keys symbols)))]\n    (letfn [(divides? [number quotient] (when (pos? (quot number quotient)) quotient))\n        \t(compact [in-list] (remove nil? in-list))\n  \t\t\t(lookup [number div] (repeat (quot number div) (symbols div)))\n        \t(biggest-divisor [number] (first (compact (map divides? (repeat number) numbers))))\n        \t(recursive-roman [number]\n  \t\t\t\t(let [div (biggest-divisor number)]\n    \t\t\t\t(if (zero? (rem number div))\n      \t\t\t\t\t(list (lookup number div))\n      \t\t\t\t\t(cons (lookup number div) (recursive-roman (rem number div))))))]\n      (clojure.string/join (flatten (recursive-roman number))))))","user":"5658d775e4b00d3155796114"},{"problem":104,"code":"#(apply str (second ( reduce \n   (fn [[nn s] [k [low mid hi]]]\n  [ (rem nn k)\n     (let [c (quot nn k)]\n       (cond \n         (== c 9) (into s [low hi])\n         (>= c 5) (into (conj s mid) (repeat (- c 5) low))\n         (== c 4) (into s [low mid])\n         :else (into s (repeat c low)))\n       )]\n     ) \n  [% []]\n  [\n   [ 1000 [\\M nil nil]]\n   [ 100  [\\C \\D \\M]]\n   [ 10   [\\X \\L \\C]]\n   [ 1    [\\I \\V \\X]]]\n  \n  )))","user":"50856bd1e4b004985b776e4c"},{"problem":104,"code":"(fn write-roman [n]\n  (let [num-maps [[\"\" \"I\" \"II\" \"III\" \"IV\" \"V\" \"VI\" \"VII\" \"VIII\" \"IX\"]\n                  [\"\" \"X\" \"XX\" \"XXX\" \"XL\" \"L\" \"LX\" \"LXX\" \"LXXX\" \"XC\"]\n                  [\"\" \"C\" \"CC\" \"CCC\" \"CD\" \"D\" \"DC\" \"DCC\" \"DCCC\" \"CM\"]\n                  [\"\" \"M\" \"MM\" \"MMM\" \"MMMM\"]]\n        convert-to-digits (fn [n result]\n                            (if (zero? n)\n                                (if (= (count result) 0) [0] result)\n                                (recur (quot n 10) (conj result (rem n 10)))))\n        digits (vec (convert-to-digits n []))]\n    (apply str (reverse (map-indexed (fn [i j] ((num-maps i) j)) digits)))))","user":"559b55d6e4b066d22e731f54"},{"problem":104,"code":"(fn [n]\n (loop [n n, r \"\"]\n ( cond (< 0 (- n 999))  (recur (- n 1000) (str r \"M\"))\n        (< 0 (- n 899))  (recur (- n  900) (str r \"CM\"))\n        (< 0 (- n 499))  (recur (- n  500) (str r \"D\"))\n        (< 0 (- n 399))  (recur (- n  400) (str r \"CD\"))\n        (< 0 (- n 99))   (recur (- n  100) (str r \"C\"))\n        (< 0 (- n 89))   (recur (- n   90) (str r \"XC\"))\n        (< 0 (- n 49))   (recur (- n   50) (str r \"L\"))\n        (< 0 (- n 39))   (recur (- n   40) (str r \"XL\"))\n        (< 0 (- n 9))    (recur (- n   10) (str r \"X\"))\n        (< 0 (- n 8))    (recur (- n    9) (str r \"IX\"))\n        (< 0 (- n 4))    (recur (- n    5) (str r \"V\"))\n        (< 0 (- n 3))    (recur (- n    4) (str r \"IV\"))\n        (< 0 n)          (recur (- n    1) (str r \"I\"))\n        :else r)))","user":"4fd11a93e4b04c3a95aa040a"},{"problem":104,"code":"(fn real-roman [a]\n   (letfn [(roman [x]\n             (letfn [(times [y letter] (vec (repeat (quot x y) letter)))\n                     (use-times [y letter] (concat (times y letter) (roman (mod x y))))\n                     (use-once [y letters] (concat letters (roman (- x y))))]\n               (cond\n                (>= x 1000) (use-times 1000 \\M)\n                (>= x 900) (use-once 900 [\\C \\M])\n                (>= x 500) (use-once 500 [\\D])\n                (>= x 400) (use-once 400 [\\C \\D])\n                (>= x 100) (use-times 100 \\C)\n                (>= x 90) (use-once 90 [\\X \\C])\n                (>= x 50) (use-once 50 [\\L])\n                (>= x 40) (use-once 40 [\\X \\L])\n                (>= x 10) (use-times 10 \\X)\n                (>= x 9) (use-once 9 [\\I \\X])\n                (>= x 5) (use-once 5 [\\V])\n                (>= x 4) (use-once 4 [\\I \\V])\n                (>= x 1) (use-times 1 \\I)\n                :else [])))]\n     (clojure.string/join (roman a)))\n   )","user":"53ed6976e4b0d648e757f4c4"},{"code":"#(clojure.pprint/cl-format nil \"~@R\" %)","problem":104,"user":"4fa340b4e4b081705acca18c"},{"code":"(let [N {1000 \\M 500 \\D 100 \\C 50 \\L 10 \\X 5 \\V 1 \\I}\n         P {1000 100 500 100 100 10 50 10 10 1 5 1}]\n     (fn [n]\n       (loop [s [1000 500 100 50 10 5 1] n n r \"\"]\n         (if (= 0 n)\n           r\n           (let [z (first s)\n                 q (quot n z)\n                 n (mod n z)\n                 r (apply str r (repeat q (N z)))\n                 d ((fnil - 0 0) z (P z))]\n             (if (>= n d)\n               (recur (rest s) (- n d) (str r (N (P z)) (N z)) )\n               (recur (rest s) n r )))))))","problem":104,"user":"4e82f85d535db62dc21a62ce"},{"problem":104,"code":"(fn [n]\n  (let [digits (map (comp read-string str) (seq (str n)))\n        d-base (map-indexed (fn [idx v] [(- (count digits) idx) v]) digits)\n        roman-with-base (fn [b half]\n                          (println \"matching\" b \" \" half \" \" (list b half))\n                          (case (list b half)\n                            ((4 false)) \\M\n                            ((4 true)) \\D\n                            ((3 false)) \\C\n                            ((3 true)) \\L\n                            ((2 false)) \\X\n                            ((2 true)) \\V\n                            ((1 false)) \\I))\n        convert (fn [[base v]]\n                  (case v\n                    (1 2 3) (repeat v (roman-with-base base false))\n                    4 (list (roman-with-base base false)\n                            (roman-with-base (inc base) true))\n                    5 (list (roman-with-base base true))\n                    (6 7 8) (cons (roman-with-base (inc base) true)\n                                  (repeat (mod v 5)\n                                          (roman-with-base base false)))\n                    9 (list (roman-with-base base false)\n                            (roman-with-base (inc base) false))\n                    0 nil))]\n    (clojure.string/join (mapcat convert d-base))))","user":"549eb44fe4b0f3d1d8e70fa6"},{"code":"(fn [n] (let [numerals (sorted-map 1 \"I\" 4 \"IV\" 5 \"V\" 9 \"IX\" 10 \"X\" 40 \"XL\" 50 \"L\"\n                                   90 \"XC\" 100 \"C\" 400 \"CD\" 500 \"D\" 900 \"CM\" 1000 \"M\")]\n          (loop [s nil r n m numerals]\n            (cond\n             (= r 0) s\n             (> (key (last m)) r) (recur s r (butlast m))\n             :else (recur (str s (val (last m))) (- r (key (last m))) m)))))","problem":104,"user":"4fa05b99e4b0dcca54ed6d47"},{"problem":104,"code":"(fn [n]\n  (let [table [\n    [\"\" \"I\" \"II\" \"III\" \"IV\" \"V\" \"VI\" \"VII\" \"VIII\" \"IX\"]\n    [\"\" \"X\" \"XX\" \"XXX\" \"XL\" \"L\" \"LX\" \"LXX\" \"LXXX\" \"XC\"]\n    [\"\" \"C\" \"CC\" \"CCC\" \"CD\" \"D\" \"DC\" \"DCC\" \"DCCC\" \"CM\"]\n    [\"\" \"M\" \"MM\" \"MMM\"]]]\n    (letfn [(pow [x] (loop [i x r 1] (if (= i 0) r (recur (dec i) (* r 10)))))\n            (digit [p] (mod (quot n (pow (dec p))) 10))]\n      (loop [i 4 r \"\"] (if (= i 0) r (recur (dec i) (str r (nth (nth table (dec i)) (digit i)))))))))","user":"5392bfdee4b0b51d73faaeb2"},{"problem":104,"code":"(letfn [(roman [n]\n  (letfn [(f [n c1 c2 c3]\n             (cond\n              (< n 4) (apply str (repeat n c1))\n              (= n 4) (str c1 c2)\n              (= n 5) c2\n              (= n 9) (str c1 c3)\n              :else   (apply str c2 (repeat (- n 5) c1))))]\n    (let [[cs1 cs2 cs3] [\"IVX\" \"XLC\" \"CDM\"]]\n      (cond\n       (< n 10)   (apply f n cs1)\n       (< n 100)  (str (apply f (quot n 10) cs2) (apply f (mod n 10) cs1))\n       (< n 1000) (str (apply f (quot n 100) cs3) (roman (mod n 100)))\n       (< n 4000) (str (apply str (repeat (quot n 1000) \"M\")) (roman (mod n 1000)))))))]\n  roman)","user":"4faa9593e4b081705acca1f9"},{"problem":104,"code":"(fn rn[r](\n            \n          letfn [\n                 (rm[n h m l] (\n                          cond\n                          (= n 0) \"\"\n                          (< n 4) (repeat n l)\n                          (= n 4) (concat l m)\n                          (= n 5) m\n                          (< n 9) (concat m (repeat (rem n 5) l))\n                          (= n 9) (concat l h)\n                          ))\n                  ]\n            \n            (apply str (reduce (fn [a b] (\n                                \n                       #(if (>= % 1)\n                            (concat (rm (rem % 10) (nth b 3) (nth b 2) (nth b 1)) a)\n                            a\n                            \n                            ) (quot r (nth b 0))\n                       \n                       )) \"\" [[1 \"I\" \"V\" \"X\"] [10 \"X\" \"L\" \"C\"] [100 \"C\" \"D\" \"M\"] [1000 \"M\" \"\" \"\"]]))\n         ) )","user":"596f6683e4b069c0a1a19877"},{"code":"(fn [n]\n    ;; singular, \"5\", and next-power (some redundancy, sure)\n    (let [roman [[\"I\" \"V\" \"X\"]\n                 [\"X\" \"L\" \"C\"]\n                 [\"C\" \"D\" \"M\"]\n                 [\"M\" \"\"  \"\" ]]\n          digits (reverse (map #(- (int %) (int \\0)) (str n)))]\n      (loop [[[r1 r5 r10] & rom] roman\n             [d & dd] digits\n             res \"\"]\n        (if (nil? d)\n          res\n          (recur rom dd\n                 (str\n                  (cond\n                   (= d 0)    \"\"\n                   (<= 1 d 3) (apply str (repeat d r1))\n                   (<= 4 d 5) (str (if (= 4 d) r1 \"\") r5)\n                   (<= 6 d 8) (apply str r5 (repeat (- d 5) r1))\n                   :else      (str r1 r10))\n                  res))))))","problem":104,"user":"50763574e4b0a894bb95bf3d"},{"code":"(fn [n]\r\n   (apply str (let [ m  [  [1 \"I\"] [2 \"II\"] [3 \"III\"] [4 \"IV\"] [5 \"V\"] [9 \"IX\"] [10 \"X\"] [40 \"XL\"] [50 \"L\"] [90 \"XC\"] [100 \"C\"] [500 \"D\"] [900 \"CM\"] [1000 \"M\"]]\r\n\t    \tv  (fn [n m] (last (take-while #(<= (first %) n) m)))]\r\n\t\t(loop [ c (v n m)\r\n\t\t\t\tr (rem n (first c))\r\n\t\t\t\td (quot n (first c))\r\n\t\t\t\te [] ]\r\n\t\t\t(cond \r\n\t\t\t\t(= 0 r) (apply conj e (repeat d (second c)))\r\n\t\t\t\t(= 0 d) (apply str (conj e (second c)))\r\n\t\t\t\t:else (recur \r\n\t\t\t\t\t\t\t(v r m)\r\n\t\t\t\t\t\t\t(rem r (first (v r m)) )\r\n\t\t\t\t\t\t\t(quot r (first (v r m)))\r\n\t\t\t\t\t\t\t(apply conj e (repeat d (second c)))))))))","problem":104,"user":"4ecf1f51535d1f5ad70dba3a"},{"problem":104,"code":"(fn [n] \n  (let [div (fn [a b] (vector (quot a b) (mod a b)))\n        pars {1000 \"M\" \n               900 \"CM\" \n               500 \"D\" \n               400 \"CD\"\n               100 \"C\"\n                90 \"XC\"\n                50 \"L\"\n                40 \"XL\"\n                10 \"X\"\n                 9 \"IX\"\n                 5 \"V\"\n                 4 \"IV\"\n                 1 \"I\"}]\n    (loop [x n p ((comp reverse sort) pars) s \"\"]\n      (if (>= x 1)\n        (let [[d c] (first p)\n              [q r] (div x d)]\n          (recur r (rest p) (apply str s (repeat q c))))\n        s))))","user":"536b9d8ae4b0243289761ebe"},{"problem":104,"code":"(fn roman [rn]\n  (let [expanded ((fn exp [n] (apply str (if (= n 0) \"\"\n    (let [nums (sorted-map-by > 1000 \"M\" 500 \"D\" 100 \"C\" 50 \"L\" 10 \"X\" 5 \"V\" 1 \"I\")\n          largest (first (drop-while #(< n %) (keys nums)))\n          quotient (quot n largest)]\n      (concat (repeat quotient (nums largest))\n              (exp (- n (* largest quotient)))))))) rn)]\n    (-> expanded (clojure.string/replace #\"DCCCC\" \"CM\")\n                 (clojure.string/replace #\"CCCC\"  \"CD\")\n                 (clojure.string/replace #\"LXXXX\" \"XC\")\n                 (clojure.string/replace #\"XXXX\"  \"XL\")\n                 (clojure.string/replace #\"VIIII\" \"IX\")\n\t\t (clojure.string/replace #\"IIII\"  \"IV\"))))","user":"579d9601e4b05b1deef9ae18"},{"problem":104,"code":"(fn roman\n  [n]\n  (let [signs {1000 \"M\" 900 \"CM\" 500 \"D\" 400 \"CD\" 100 \"C\" 90 \"XC\" 50 \"L\" 40 \"XL\" 10 \"X\" 9 \"IX\" 5 \"V\" 4 \"IV\" 1 \"I\"}\n        nums [1000 900 500 400 100 90 50 40 10 9 5 4 1]]\n    (apply str (second\n                (reduce\n                 (fn [[x l] c]\n                   [(rem x c) (conj l (apply str (repeat (quot x c) (get signs c))))])\n                 [n []] nums)))))","user":"5ed6030de4b016b56eae05db"},{"problem":104,"code":"(fn [n]\n    (let [rmap (sorted-map 1000 \"M\" 900 \"CM\" 500 \"D\" 400 \"CD\" 100 \"C\"\n                           90 \"XC\" 50 \"L\" 40 \"XL\" 10 \"X\" 9 \"IX\" 5 \"V\" 4 \"IV\" 1 \"I\")]\n     (loop [s \"\" n n]\n       (if (zero? n)\n         s\n         (let [[arabic roman] (last (filter #(>= n (first %)) rmap))]\n           (recur (str s roman) (- n arabic)))))))","user":"55c5b55fe4b0e31453f649b5"},{"problem":104,"code":"(fn [n]\n  (let [z (partial zipmap (map str (range 10)))\n        thousands (z (take 10 (iterate (partial str \"M\") \"\")))\n        hundreds  (z [\"\" \"C\" \"CC\" \"CCC\" \"CD\" \"D\" \"DC\" \"DCC\" \"DCCC\" \"CM\"])\n        tens      (z [\"\" \"X\" \"XX\" \"XXX\" \"XL\" \"L\" \"LX\" \"LXX\" \"LXXX\" \"XC\"])\n        ones      (z [\"\" \"I\" \"II\" \"III\" \"IV\" \"V\" \"VI\" \"VII\" \"VIII\" \"IX\"])\n        nums (map str (format \"%04d\" n))]\n    (str (get thousands (nth nums 0))\n         (get hundreds (nth nums 1))\n         (get tens (nth nums 2))\n         (get ones (nth nums 3))\n         )))","user":"56ff45e5e4b08d47c97781bb"},{"problem":104,"code":"(fn number104 [n]\n  (reduce\n    (fn [m [k v]] (clojure.string/replace m (apply str (repeat k \"I\")) v))\n    (apply str (repeat n \"I\"))\n    (array-map 1000 \"M\" 900 \"CM\" 500 \"D\" 400 \"CD\" 100 \"C\" 90 \"XC\" 50 \"L\" 40 \"XL\" 10 \"X\" 9 \"IX\" 5 \"V\" 4 \"IV\" 1 \"I\")))","user":"54074fc5e4b0addc1aec66b6"},{"problem":104,"code":"(fn to-roman [n]\n  (apply str\n   (for [t [[1000 \"M\" nil] [100 \"C\" \"D\" \"M\"] [10 \"X\" \"L\" \"C\"] [1 \"I\" \"V\" \"X\"]]\n         :let [s (t 0) n (quot (rem n (* s 10)) s)]]\n    (cond\n     (= 0 n) \"\"\n     (= 4 n) (str (t 1) (t 2))\n     (= 9 n) (str (t 1) (t 3))\n     :else (apply str (concat (repeat (quot n 5) (t 2)) (repeat (rem n 5) (t 1))))))))","user":"5590e55de4b0277789237676"},{"problem":104,"code":"(fn f\n    ([xs] (f xs 3 \"\"))\n    ([xs n res]\n     (let [x (int (rem (quot xs (Math/pow 10 n)) 10))\n           one '(I X C M)\n           five '(V L D)\n           ten '(X C M)\n           digit->roman (fn [v l] (cond\n                           (< v 4) (apply str (take v (repeat (nth one l))))\n                           (= v 4) (apply str [(nth one l) (nth five l)])\n                           (< v 9) (apply str (concat [(nth five l)] (take (- v 5) (repeat (nth one l)))))\n                           (= v 9) (apply str [(nth one l) (nth ten l)])\n                           ))]\n       (if (< n 0)\n         res\n         (f xs (dec n) (str res (digit->roman x n)))))))","user":"507e68abe4b085af06e3afd2"},{"problem":104,"code":"(fn wrom [n]\n  (letfn [\n          (romtab [] {1 \\I 5 \\V 10 \\X 50 \\L 100 \\C 500 \\D 1000 \\M})\n          \n          (fr [res m]\n    (cond (>= m 1000)\n                (recur (conj res ((romtab) 1000)) (- m 1000) )\n          (>= m 900)\n                (recur (conj (conj res ((romtab) 100))\n                             ((romtab) 1000) ) (- m 900) )\n          (>= m 500)\n                (recur (conj res ((romtab) 500 )) (- m 500) )\n          (>= m 400)\n                (recur (conj (conj res ((romtab) 100))\n                             ((romtab) 500) ) (- m 400) )\n          (>= m 100)\n                (recur (conj res ((romtab) 100 )) (- m 100) )\n          (>= m 90)\n                (recur (conj (conj res ((romtab) 10))\n                             ((romtab) 100) ) (- m 90) )\n          (>= m 50)\n                (recur (conj res ((romtab) 50 )) (- m 50) )\n          (>= m 40)\n                (recur (conj (conj res ((romtab) 10))\n                             ((romtab) 50) ) (- m 40) )\n          (>= m 10)\n                (recur (conj res ((romtab) 10 )) (- m 10) )\n          (>= m 9)\n                (recur  (conj (conj res ((romtab) 1 ))\n                                ((romtab) 10 ) ) (- m 10) )\n          (>= m 5)\n                (recur (conj res ((romtab) 5)) (- m 5) )\n          (>= m 4) \n                (recur (conj (conj res ((romtab) 1) ) \n                              ((romtab) 5) ) (- m 4) )\n          (>= m 1)\n                (recur (conj res ((romtab) 1)) (- m 1) )\n          :else res\n      )\n     )]\n     (apply str (fr [] n))\n  )\n)","user":"59ff9424e4b01bb0ae8afd24"},{"problem":104,"code":"(fn roman [n]\n ( let [numerals {\"M\" 1000 \"D\" 500 \"C\" 100 \"L\" 50 \"X\" 10 \"IX\" 9 \"V\" 5 \"I\" 1\n                  \"XL\" 40 \"XC\" 90 \"CM\" 900 \"CD\" 400 \"IV\" 4}]\n\n   (loop [rem n s \"\"]\n     (let [v (last (sort-by last (filter #(<= (last %) rem) numerals)))  ]\n       (if (= rem 0)\n         s\n         (recur\n          (- rem (last v))\n          (str s (first v) )))))))","user":"56f2611fe4b04a395b9a04a2"},{"problem":104,"code":"(fn [n]\n  (first\n   (reduce\n    (fn [[rom n] [v c]]\n      (let [m (int (/ n v))]\n        [(apply str rom (repeat m c)) (- n (* m v))]))\n    [\"\" n]\n    (partition 2 [1000 \\M 900 \"CM\" 500 \\D 400 \"CD\" 100 \\C 90 \"XC\" 50 \\L 40 \"XL\" 10 \\X 9 \"IX\" 5 \\V 4 \"IV\" 1 \\I]))))","user":"4e6a4950535d8ccf87e9febf"},{"problem":104,"code":"(fn roman [n]\n  (cond\n   (>= n 1000) (let [r (mod n 1000) q (quot n 1000)] (str (apply str (repeat q \"M\")) (roman r)))\n   (>= n 100) (let [r (mod n 100) q (quot n 100)]\n                (case q\n                  9 (str \"CM\" (roman r))\n                  8 (str \"DCCC\" (roman r))\n                  7 (str \"DCC\" (roman r))\n                  6 (str \"DC\" (roman r))\n                  5 (str \"D\" (roman r))\n                  4 (str \"CD\" (roman r))\n                  3 (str \"CCC\" (roman r))\n                  2 (str \"CC\" (roman r))\n                  1 (str \"C\" (roman r))\n                  \"\"\n                 )\n                )\n   (>= n 10) (let [r (mod n 10) q (quot n 10)]\n               (case q\n                 9 (str \"XC\" (roman r))\n                 8 (str \"LXXX\" (roman r))\n                 7 (str \"LXX\" (roman r))\n                 6 (str \"LX\" (roman r))\n                 5 (str \"L\" (roman r))\n                 4 (str \"XL\" (roman r))\n                 3 (str \"XXX\" (roman r))\n                 2 (str \"XX\" (roman r))\n                 1 (str \"X\" (roman r))\n                 \"\"\n                 )\n               )\n   :else (case n\n           9 \"IX\"\n           8 \"VIII\"\n           7 \"VII\"\n           6 \"VI\"\n           5 \"V\"\n           4 \"IV\"\n           3 \"III\"\n           2 \"II\"\n           1 \"I\"\n           \"\"\n           )\n   )\n  )","user":"5cebafbbe4b0a17bb84e2be6"},{"code":"(let [roman-digit-r {0 \"\", 1 \"I\", 2 \"II\", 3 \"III\", 4 \"IV\", 5 \"V\",\r\n                    6 \"VI\", 7 \"VII\", 8 \"VIII\", 9 \"IX\",\r\n                    10 \"X\", 20 \"XX\", 30 \"XXX\", 40 \"XL\", 50 \"L\",\r\n                    60 \"LX\", 70 \"LXX\", 80 \"LXXX\", 90 \"XC\",\r\n                    100 \"C\", 200 \"CC\", 300 \"CCC\", 400 \"CD\",500 \"D\",\r\n                    600 \"DC\", 700 \"DCC\", 800 \"DCCC\", 900 \"CM\",\r\n                    1000 \"M\", 2000 \"MM\", 3000 \"MMM\"}\r\n      split-num (fn [n]\r\n                  (loop [n n\r\n                         base 1\r\n                         ret '()]\r\n                      (if (zero? n)\r\n                          ret\r\n                          (recur (quot n 10)\r\n                                 (* base 10)\r\n                                 (lazy-seq (cons (* base (rem n 10)) ret))))))]\r\n  (fn wrn [n]\r\n    (apply str (map roman-digit-r (split-num n)))))","problem":104,"user":"4fcc6cb3e4b0ee37620e1861"},{"code":"#(->\n  (reduce\n   (fn [[s n] [t v p?]]\n     (let [m (if p? (if (> n v) 1 0) (quot n v))]\n       [(apply str s (repeat m t)) (- n (* m v))]))\n   [\"\" %]\n   (->> (map list \"IVXLCDM\" [1 5 10 50 100 500 1000])\n        (partition 3 2)\n        (map\n         (fn [[[p np] & r]]\n           (for [[s n] r [p np] [[p np false] [\"\" 0 true]]] [(str p s) (- n np)])))\n        (apply concat) (cons [\"I\" 1]) reverse))\n  first)","problem":104,"user":"4f06dcad535dcb61093f6c16"},{"code":"(fn R [l [t & x] i]\n      (if (= 0 i)\n        \"\"\n        (str (R l x (quot i 10)) (l (mod i 10) t))))\n    (fn l [i [o f t]]\n      (cond\n       (< i 4) (apply str (repeat i o))\n       (= i 4) (str o f)\n       >       (str (if (< i 9) f) (l (- i 5) [o t t]))))\n    (partition 3 2 [\\I \\V \\X \\L \\C \\D \\M \\A \\' ])","problem":104,"user":"4f296a80e4b0d6649770a02a"},{"code":"(fn [n]\n  (let [t [[1000 \\M] [500 \\D]\n           [100 \\C] [50 \\L]\n           [10 \\X] [5 \\V] [1 \\I]]]\n    (loop [n n s \"\" i 0]\n      (if (or (= i 7) (= n 0))\n        s\n        (if (= n 3999)\n          \"MMMCMXCIX\"\n          (let [[c y] (t i)\n                d (int (/ n c))]\n            (if (> d 0)\n              (if (< d 4)\n                (recur (- n (* d c)) (apply str (concat s (repeat d y))) (+ i 1))\n                (recur (- n (* d c)) (apply str (concat s [y (nth (t (- i 1)) 1)])) (+ i 1)))\n              (recur n s (+ i 1)))))))))","problem":104,"user":"4e12cc9d535d04ed9115e7d2"},{"problem":104,"code":"(fn r [n]\n  (if (zero? n) \"\"\n    (let [[s v] (first (drop-while #(> (% 1) n)\n                                   [[\"M\" 1000] [\"CM\" 900] [\"D\" 500] [\"CD\" 400]\n                                    [\"C\" 100] [\"XC\" 90] [\"L\" 50] [\"XL\" 40]\n                                    [\"X\" 10] [\"IX\" 9] [\"V\" 5] [\"IV\" 4] [\"I\" 1]]))]\n      (str s (r (- n v))))))","user":"4f5eda39e4b0030a34fb2b56"},{"code":"#(->> % (str) \n   (map (fn [x] (Integer. (str x)))) \n   ((fn [s] (concat (repeat (- 4 (count s)) 0) s))) \n   (map (fn [f x] \n          (f x)) \n        (map (fn traduz [um cinco dez]\n               (fn [x]\n                 (case x\n                   0 nil\n                   1 (str um)\n                   2 (str um um)\n                   3 (str um um um)\n                   4 (str um cinco)\n                   5 (str cinco)\n                   6 (str cinco um)\n                   7 (str cinco um um)\n                   8 (str cinco um um um)\n                   9 (str um dez)))) \n             [\"M\" \"C\" \"X\" \"I\"] \n             [nil \"D\" \"L\" \"V\"] \n             [nil \"M\" \"C\" \"X\"]))\n   (apply str))","problem":104,"user":"52c8758be4b0c2d177d62135"},{"problem":104,"code":"(fn roman\n  ([n] (roman n []))\n  ([n acc]\n   (let [vals (partition 2 [1000 \"M\" 900 \"CM\" 500 \"D\" 400 \"CD\" 100 \"C\"\n                           90 \"XC\" 50 \"L\" 40 \"XL\" 10 \"X\" 9 \"IX\" 5 \"V\" 4 \"IV\" 1 \"I\"])]\n     (if (zero? n)\n       (clojure.string/join acc)\n       (let [[v s] (first (filter (fn [[vv ss]] (>= n vv)) vals))]\n         (recur (- n v) (conj acc s)))))))","user":"52ce1abfe4b07d0d72b27389"},{"problem":104,"code":"(fn [n]\n  (let [numerals [\"M\" \"CM\" \"D\" \"CD\" \"C\" \"XC\" \"L\" \"XL\" \"X\" \"IX\" \"V\" \"IV\" \"I\"]\n        integers [1000 900 500 400 100 90 50 40 10 9 5 4 1]\n        places   (map #(int (Math/floor %))\n                     (map /\n                          (reductions rem n integers)\n                          integers))]\n    (apply str (mapcat repeat places numerals))))","user":"56481722e4b0284900eef628"},{"problem":104,"code":"(fn write-roman\n\t([n]\n\t\t(write-roman n \"\"))\n\t([n s]\n\t\t(if (zero? n)\n\t\t\ts\n\t\t\t(let [m (array-map 1 \"I\" 4 \"IV\" 5 \"V\" 9 \"IX\" 10 \"X\" 40 \"XL\" 50 \"L\" 90 \"XC\" 100 \"C\" 400 \"CD\" 500 \"D\" 900 \"CM\" 1000 \"M\")\n\t\t\t\t\tpair (last (take-while (fn[[key val]] (<= key n)) m))]\n\t\t\t\t(write-roman (- n (key pair)) (str s (val pair)))))))","user":"5954eef0e4b066ee0a44af17"},{"code":"(fn numerals [n]\n   (let [values\n         [[1000 \"M\"]\n          [900  \"CM\"]\n          [500  \"D\"]\n          [400  \"CD\"]\n          [100  \"C\"]\n          [90   \"XC\"]\n          [50   \"L\"]\n          [40   \"XL\"]\n          [10   \"X\"]\n          [9    \"IX\"]\n          [5    \"V\"]\n          [4    \"IV\"]\n          [1    \"I\"]\n          [0    \"\"]]\n         [subn numeral] (some #(if (<= (first %) n) % nil) values)]\n     (if (= 0 n) numeral\n         (str numeral (numerals (- n subn))))))","problem":104,"user":"529ce629e4b04e0c58e87b6e"},{"problem":104,"code":"(fn [n]\n  (let [base-numerals {1 \"I\" 4 \"IV\" 5 \"V\" 9 \"IX\" 10 \"X\"\n                       40 \"XL\" 50 \"L\" 90 \"XC\" 100 \"C\"\n                       400 \"CD\" 500 \"D\" 900 \"CM\" 1000 \"M\"}\n        base-keys (sort (keys base-numerals))]\n    (loop [k n acc \"\"]\n      (if (zero? k)\n        acc\n        (let [best-vals (take-while #(<= % k) base-keys)\n              this-pass (apply max best-vals)]\n          (recur\n            (- k this-pass)\n            (str acc (base-numerals this-pass))))))))","user":"56cb4d06e4b0ea9b8538f72e"},{"code":"(fn [n]\r\n  ((fn [n tbl s]\r\n     (if (zero? n) s\r\n         (let [[k v] (first tbl)]\r\n           (if (>= n k) (recur (- n k) tbl (str s v))\r\n               (recur n (rest tbl) s)))))\r\n   n [[1000 \"M\"] [900 \"CM\"] [500 \"D\"] [400 \"CD\"] [100 \"C\"] [90 \"XC\"]\r\n      [50 \"L\"] [40 \"XL\"] [10 \"X\"] [9 \"IX\"] [5 \"V\"] [4 \"IV\"] [1 \"I\"]] \"\"))","problem":104,"user":"4dc1ee85535d020aff1edf91"},{"code":"(fn f [n]\n   (let [ vs  [ 1000 900 500 400 100 90 50 40 10 9 5 4 1 ]\n          rns (zipmap vs [\"M\" \"CM\" \"D\" \"CD\" \"C\" \"XC\" \"L\" \"XL\" \"X\" \"IX\" \"V\" \"IV\" \"I\"]) ]\n      (if (< 0 n)\n            (let [ m (first (filter #(<= % n) vs)) ]\n              (str (rns m) (f (- n m)))))))","problem":104,"user":"4e860e85535db62dc21a62f1"},{"problem":104,"code":"(fn [n]\n  (let [hundreds {0 \"\" 1 \"C\" 2 \"CC\" 3 \"CCC\" 4 \"CD\" 5 \"D\" 6 \"DC\" 7 \"DCC\" 8 \"DCCC\" 9 \"CM\"}\n        tens {0 \"\" 1 \"X\" 2 \"XX\" 3 \"XXX\" 4 \"XL\" 5 \"L\" 6 \"LX\" 7 \"LXX\" 8 \"LXXX\" 9 \"XC\"}\n        ones {0 \"\" 1 \"I\" 2 \"II\" 3 \"III\" 4 \"IV\" 5 \"V\" 6 \"VI\" 7 \"VII\" 8 \"VIII\" 9 \"IX\"}]\n    (apply str\n           (apply str (repeat (quot n 1000) \"M\"))\n           (hundreds (quot (mod n 1000) 100))\n           (tens (quot (mod n 100) 10))\n           (ones (mod n 10)))))","user":"56ef077ae4b04a395b9a0459"},{"code":"(fn [x]\n    (let [m {1 \"I\" 5 \"V\" 10 \"X\" 50 \"L\" 100 \"C\" 500 \"D\" 1000 \"M\" 4 \"IV\" 9 \"IX\" 40 \"XL\" 90 \"XC\" 400 \"CD\" 900 \"CM\"}]\n      (loop [n x\n             a \"\"]\n        (if (zero? n)\n          a\n          (let [i (into (sorted-map-by >) (filter #(< (first %) (+ n 1)) m))\n                j (first i)]\n            (recur\n              (- n (first j))\n              (str a (last j))\n              ))))))","problem":104,"user":"51b3f109e4b0f094dd986fa9"},{"code":"(fn [num]\n  (let [numerals [[\"M\" 1000] [\"CM\" 900] [\"D\" 500] [\"CD\" 400] [\"C\" 100] [\"XC\" 90]\n         [\"L\" 50] [\"XL\" 40] [\"X\" 10] [\"IX\" 9] [\"V\" 5] [\"IV\" 4] [\"I\" 1]]]\n      (loop [[[s v] & xs :as l] numerals \n             n num \n             c []]\n        (cond\n          (zero? n)      (apply str c)\n          (> v n)        (recur xs n c)\n          (>= (- n v) 0) (recur l (- n v) (conj c s))))))","problem":104,"user":"4e8e8c24535d65386fec2143"},{"problem":104,"code":"(fn roman [n]\n  (let [digits [{:dec (quot n 1000) :base \"M\" :half nil :next-base nil}\n                {:dec (quot (rem n 1000) 100) :base \"C\" :half \"D\" :next-base \"M\"}\n                {:dec (quot (rem n 100) 10) :base \"X\" :half \"L\" :next-base \"C\"}\n                {:dec (rem n 10) :base \"I\" :half \"V\" :next-base \"X\"}]\n        to-roman (fn [d]\n                   (cond\n                     (or (nil? (:next-base d))\n                         (< (:dec d) 4)) (apply str (repeat (:dec d) (:base d)))\n                     (= (:dec d) 4) (str (:base d) (:half d))\n                     (< 4 (:dec d) 9) (str (:half d)\n                                           (apply str (repeat (- (:dec d) 5) (:base d))))\n                     (= (:dec d) 9) (str (:base d) (:next-base d))))]\n    (->> digits\n         (map to-roman)\n         (apply str))))","user":"57e0f30ae4b0bfb2137f5a66"},{"problem":104,"code":"(fn roman [n]\n  (apply str (reverse (map #(%1 %2)\n       (map (fn [[a1 a2 a3]] {\\0 \"\" \\1 a1 \\2 (str a1 a1) \n                            \\3 (str a1 a1 a1) \\4 (str a1 a2) \n                            \\5 a2 \\6 (str a2 a1) \\7 (str a2 a1 a1) \n                            \\8 (str a2 a1 a1 a1) \\9 (str a1 a3)}) \n            [[\"I\" \"V\" \"X\"] [\"X\" \"L\" \"C\"] [\"C\" \"D\" \"M\"] [\"M\" \"-\" \"-\"]])\n       (reverse (seq (str n)))))))","user":"55625903e4b0c656e3ff17d7"},{"code":"(fn [n]\n  (let [romans {1000 \"M\" 900 \"CM\" 500 \"D\" 400 \"CD\" 100 \"C\" 90 \"XC\" 50 \"L\" 40 \"XL\" 10 \"X\" 9 \"IX\" 5 \"V\" 4 \"IV\" 1 \"I\"}]\n    (loop [res [] n n]\n      (let [sub (first (filter #(<= % n) (sort > (keys romans))))]\n        (cond (nil? sub) (apply str res)\n              :else (recur (conj res (romans sub)) (- n sub)))))))","problem":104,"user":"4f1bb9d8535d64f60314647d"},{"problem":104,"code":"(fn [num]\n  (letfn [(romanize\n            [val base1 base2 base3]\n            (case val\n              (1 2 3) (into [] (repeat val base1))\n              4       [base1 base2]\n              5       [base2]\n              (6 7 8) (into [base2] (repeat (- val 5) base1))\n              9       [base1 base3]\n              []))\n           \n           (proc-base\n            [[val roman] [base f]]\n            (let [q      (quot val base)\n                  roman  (str roman (apply str (f q)))\n                  val    (- val (* q base))]\n              [val roman]\n              )\n            )\n           ]\n    (let [valuemap {\n                    1000 #(repeat % \\M)\n                    100  #(romanize % \\C \\D \\M)\n                    10   #(romanize % \\X \\L \\C)\n                    1    #(romanize % \\I \\V \\X)\n                    }]\n      (second (reduce proc-base [num \"\"] valuemap))\n      )\n    )\n  )","user":"56f9392ae4b07572ad1a88ac"},{"problem":104,"code":"(fn into-romans [x]\n  (letfn [(num-seq [x] (map #(Integer. (str %)) (str x)))\n          (not-found-fn [k-entry v-entry] (apply str (repeat v-entry k-entry)))\n          (take-by-num [x xs] (reverse (take x (reverse xs))))]\n    (let [roman-map {\"M\" {1 \"M\" 2 \"MM\" 3 \"MMM\"}\n                     \"C\" {4 \"CD\" 5 \"D\" 6 \"DC\" 7 \"DCC\" 8 \"DCCC\" 9 \"CM\"}\n                     \"X\" {1 \"X\" 4 \"XL\" 5 \"L\" 6 \"LX\" 7 \"LXX\" 8 \"LXXX\" 9 \"XC\"}\n                     \"I\" {1 \"I\" 4 \"IV\" 5 \"V\" 6 \"VI\" 7 \"VII\" 8 \"VIII\" 9 \"IX\"}}\n          nums (num-seq x)]\n      (apply str\n        (reverse\n          (map \n             (fn [[k v]] \n               (get-in roman-map [k v] (not-found-fn k v))) \n             (zipmap (take-by-num (count nums) [\"M\" \"C\" \"X\" \"I\"]) nums)))))))","user":"5553b729e4b0deb715856e05"},{"problem":104,"code":"(fn [i]\n  (loop [ItoR (array-map \"M\" 1000 \"CM\" 900 \"D\" 500 \"CD\" 400 \"C\" 100 \"XC\" 90 \"L\" 50 \"XL\" 40 \"X\" 10 \"IX\" 9 \"V\" 5 \"IV\" 4 \"I\" 1)\n         i i\n         r \"\"]\n    (if (empty? ItoR)\n      r\n      (let [t (first ItoR)\n            rd (key t)\n            id (val t)\n            n (if (= 1 (count rd)) (quot i id) (if (>= i id) 1 0))\n            l (- i (* n id))]\n        (recur (rest ItoR) l (str r (apply str (repeat n rd))))))))","user":"56d5fd24e4b0ea9b8538f7c5"},{"code":"#(apply str ((fn f [n]\n  (when (not= 0 n)\n    (let [[v s] (first (filter (fn [m] (>= n (first m)))\n        [[1000 \"M\"] [900 \"CM\"]\n         [500 \"D\"]  [400 \"CD\"]\n         [100 \"C\"]  [90 \"XC\"]\n         [50 \"L\"]   [40 \"XL\"]\n         [10 \"X\"]   [9 \"IX\"]\n         [5 \"V\"]    [4 \"IV\"]\n         [1 \"I\"]]\n      ))] (cons s (f (- n v))))\n  )) %))","problem":104,"user":"4f01c938535dcb61093f6a39"},{"problem":104,"code":"(fn get-string [x]\n  (letfn [(number-to-string [a-number magnitude]\n            (let [number-map {0 {1  \"I\",\n                                 5 \"V\"},\n                              1 {1  \"X\",\n                                 5 \"L\"},\n                              2 {1  \"C\",\n                                 5 \"D\"},\n                              3 {1 \"M\"}}\n                  mod-5 (quot a-number 5)]\n              (if (= magnitude 3)\n                (apply str (repeat a-number (get-in number-map [magnitude 1])))\n                (cond\n                  (and (< a-number 9)(= mod-5 1)) (str (get-in number-map [magnitude 5]) (apply str (repeat (- a-number 5) (get-in number-map [magnitude 1]))))\n                  (= a-number 4) (str (get-in number-map [magnitude 1]) (get-in number-map [magnitude 5]))\n                  (= a-number 9) (str  (get-in number-map [magnitude 1] ) (get-in number-map [(inc magnitude) 1]))\n                  :else (apply str (repeat a-number (get-in number-map [magnitude 1])))))))]\n    (loop [number x\n          order-of-magnitude 0\n          acc \"\"]\n     (let [digit (mod number 10)\n           remaining-number (quot number 10)\n           next-order-of-magnitude (inc order-of-magnitude)]\n       (if (= order-of-magnitude 3)\n         (str (number-to-string number 3) acc)\n         (recur remaining-number\n                next-order-of-magnitude\n                (str (number-to-string digit order-of-magnitude) acc)))))))","user":"54f86b8ce4b01ecee9d88828"},{"code":"(fn write-roman [n]\n  (let [nums [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n        m (zipmap nums \n                 [\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"])\n     \n        cs (apply max 0 (filter (partial >= n) nums))]\n    (if (zero? n)\n      \"\"\n      (str (m cs) (write-roman (- n cs))))))","problem":104,"user":"50c8697ce4b00bb60fe0c53f"},{"code":"(fn roman-numeral\n   ([x] (roman-numeral x \"\"))\n   ([x s]\n      (if (<= x 0)\n        s\n        (let [m (sorted-map 1 \"I\"\n                            4 \"IV\"\n                            5 \"V\"\n                            9 \"IX\"\n                            10 \"X\"\n                            40 \"XL\"\n                            50 \"L\"\n                            90 \"XC\"\n                            100 \"C\"\n                            400 \"CD\"\n                            500 \"D\"\n                            900 \"CM\"\n                            1000 \"M\")\n              ks (filter #(<= % x) (keys m))\n              y (if (empty? ks) (first (keys m)) (last ks))]\n          (roman-numeral (- x y) (str s (m y)))))))","problem":104,"user":"53224d45e4b09d4e7a9b54c0"},{"problem":104,"code":"(fn [d]\n  (let [d2c [[1000 \"M\"] [900 \"CM\"] [500 \"D\"] [400 \"CD\"] [100 \"C\"] [90 \"XC\"] [50 \"L\"]\n             [40 \"XL\"] [10 \"X\"] [9 \"IX\"] [5 \"V\"] [4 \"IV\"] [1 \"I\"]]\n        f (fn [[r m] [v s]] [(apply str r (repeat (quot m v) s)) (mod m v)])]\n    (first (reduce f [\"\" d] d2c))))","user":"606a70a5e4b069485764ddf2"},{"problem":104,"code":"(fn tran [n]\n  (let [roman (sorted-map-by > 1000 \"M\", 900 \"CM\", 500 \"D\", 400 \"CD\", 100 \"C\", 90 \"XC\", \n                               50 \"L\", 40 \"XL\", 10 \"X\", 9 \"IX\", 5 \"V\", 4 \"IV\", 1 \"I\")\n        s (first (filter #(<= (key %) n) roman))]\n    (if (zero? n) \"\"\n      (str (val s) (tran (- n (key s)))))))","user":"554b8572e4b0a04f79299589"},{"problem":104,"code":"(let [trans (sorted-map-by #(- (compare %1 %2))\n                             3000 \"MMM\", 2000 \"MM\", 1000 \"M\" , 900 \"CM\",\n                             500 \"D\", 400 \"CD\",\n                             300 \"CCC\", 200 \"CC\", 100 \"C\", 90 \"XC\",\n                             50 \"L\", 40 \"XL\",\n                             30 \"XXX\", 20 \"XX\", 10 \"XX\", 9 \"IX\",\n                             5 \"V\", 4 \"IV\",\n                             3 \"III\", 2 \"II\", 1 \"I\") \n        to-roman (fn [num res]\n                   (let [[k v] (first (subseq trans >= num))]\n                     (if (= num 0) \n                       res\n                       (recur (- num k) (str res v)))))\n        ]\n    (fn [num] (to-roman num \"\")))","user":"50eddbc4e4b06330c1f87c4b"},{"code":"(fn [n]\r\n  (let [rr (fn [cs n]\r\n             (let [cs (vec cs)] ;yikes\r\n             (cond (= n 0) [cs 0]\r\n                   (>= n 1000) [(conj cs \\M) (- n 1000)]\r\n                   (>= n 900) [(concat cs \"CM\") (- n 900)]\r\n                   (>= n 500) [(conj cs \\D) (- n 500)]\r\n                   (>= n 100) [(conj cs \\C) (- n 100)]\r\n                   (>= n 90) [(concat cs \"XC\") (- n 90)]\r\n                   (>= n 50) [(conj cs \\L) (- n 50)]\r\n                   (>= n 40) [(concat cs \"XL\") (- n 40)]\r\n                   (>= n 10) [(conj cs \\X) (- n 10)]\r\n                   (>= n 9) [(concat cs \"IX\") (- n 9)]\r\n                   (>= n 5) [(conj cs \\V) (- n 5)]\r\n                   (>= n 4) [(concat cs \"IV\") (- n 4)]\r\n                   (>= n 1) [(conj cs \\I) (- n 1)])))\r\n       ]\r\n    (loop [[cs n] [[] n]]\r\n       (if (= n 0) (apply str cs)\r\n           (recur (rr cs n))))))","problem":104,"user":"4e8681b7535dae1a5effa438"},{"problem":104,"code":"(fn [n]\n          (let [fmt (fn [c1 c2 c3]\n                      (fn [n]\n                        (cond\n                          (< n 4) (apply str (repeat n c1))\n                          (= n 4) (str c1 c2)\n                          (< n 9) (apply str (concat c2 (repeat (- n 5) c1)))\n                          (= n 9) (str c1 c3))))]\n            (->> (str n)\n               (map #(- (int %) 48))\n               reverse\n               (map #(%1 %2)\n                    [(fmt \"I\" \"V\" \"X\")\n                     (fmt \"X\" \"L\" \"C\")\n                     (fmt \"C\" \"D\" \"M\")\n                     #(apply str (repeat % \"M\"))\n                     ]\n               )\n               reverse\n               (apply str)\n              )\n            ))","user":"53f592b7e4b0db01ade6f9d0"},{"problem":104,"code":";; See https://gist.github.com/richardeast/ff37c4138bc01b1c136b2006745084fb\n\n(fn roman [n]\n  (let [unary (apply str (repeat n \"I\")) ; change n to be a str of length n\n        replacer (fn [s [this that]]\n                     (.replace s this that))]\n    (reduce replacer unary [;;[replace-this for-that]\n                            [\"IIIII\" \"V\"]\n                            [\"IIII\" \"IV\"]\n                            [\"VV\" \"X\"]\n                            [\"VIV\" \"IX\"]\n                            [\"XXXXX\" \"L\"]\n                            [\"XXXX\" \"XL\"]\n                            [\"LL\" \"C\"]\n                            [\"LXL\" \"XC\"]\n                            [\"CCCCC\" \"D\"]\n                            [\"CCCC\" \"CD\"]\n                            [\"DD\" \"M\"]\n                            [\"DCD\" \"CM\"]])))","user":"4e6a23d0535d8ccf87e9fea0"},{"code":"(fn fn [n]\n  (let [digits (fn [n] (map #(mod % 10) (take-while pos? (iterate #(quot % 10) n))))\n        nums {1 \"I\" 2 \"II\" 3 \"III\" 4 \"IV\" 5 \"V\" 6 \"VI\" 7 \"VII\" 8 \"VIII\" 9 \"IX\"\n              10 \"X\" 20 \"XX\" 30 \"XXX\" 40 \"XL\" 50 \"L\" 60 \"LX\" 70 \"LXX\" 80 \"LXXX\" 90 \"XC\"\n              100 \"C\" 200 \"CC\" 300 \"CCC\" 400 \"CD\" 500 \"D\" 600 \"DC\" 700 \"DCC\" 800 \"DCCC\" 900 \"CM\"\n              1000 \"M\" 2000 \"MM\" 3000 \"MMM\"}]\n    (apply str (map nums (reverse (remove zero? (map * (digits n) (iterate #(* 10 %) 1))))))))","problem":104,"user":"4ec5aa1f535d6d7199dd36b0"},{"problem":104,"code":"(fn [n]\n  (loop [n n\n         acc \"\"]\n    (cond\n     (>= n 1000) (recur (- n 1000) (str acc \"M\"))\n     (>= n 900) (recur (- n 900) (str acc \"CM\"))\n     (>= n 500) (recur (- n 500) (str acc \"D\"))\n     (>= n 400) (recur (- n 400) (str acc \"CD\"))\n     (>= n 100) (recur (- n 100) (str acc \"C\"))\n     (>= n 90) (recur (- n 90) (str acc \"XC\"))\n     (>= n 50) (recur (- n 50) (str acc \"L\"))\n     (>= n 40) (recur (- n 40) (str acc \"XL\"))\n     (>= n 10) (recur (- n 10) (str acc \"X\"))\n     (>= n 9) (recur (- n 9) (str acc \"IX\"))\n     (>= n 5) (recur (- n 5) (str acc \"V\"))\n     (>= n 4) (recur (- n 4) (str acc \"IV\"))\n     (>= n 1) (recur (- n 1) (str acc \"I\"))\n     :else acc)))","user":"5553b924e4b0deb715856e06"},{"code":"(fn roman [n]\n  (if (zero? n) \"\"\n    (let [m { 1000 \"M\",\n             900 \"CM\", 500 \"D\", 400 \"CD\", 100 \"C\",\n             90 \"XC\", 50 \"L\", 40 \"XL\", 10 \"X\",\n             9 \"IX\", 5 \"V\", 4 \"IV\", 1 \"I\" }]\n      (let [v (apply max (filter #(<= % n) (keys m)))]\n        (str (m v) (roman (- n v)))\n      )\n    )\n  )\n)","problem":104,"user":"4f725201e4b07046d9f4f02f"},{"code":"(fn [n]\n  (let [a-to-r {1000 \"M\" 900 \"CM\" 500 \"D\" 400 \"CD\" 100 \"C\" 90 \"XC\" 50 \"L\" 40 \"XL\" 10 \"X\" 9 \"IX\" 5 \"V\" 4 \"IV\" 1 \"I\"}\n        numbers (remove #(> % n) (sort > (keys a-to-r)))]\n    (loop [roman \"\" num n nos numbers]\n      (if (empty? nos)\n        roman\n        (do\n          (let [f (first nos)\n                q (quot num f) \n                r (rem num f)]\n            (recur (str roman (reduce str (repeat q (a-to-r f)))) r (rest nos))))))))","problem":104,"user":"4db045b5838c48654951d9be"},{"code":"(fn [x_]\n  (apply\n   str\n   ((fn rom [x [[n c] & rest :as ns]]\n      (if (zero? x)\n        '()\n        (if (>= x n)\n          (concat c (rom (- x n) ns))\n          (rom x rest))))\n    x_ [[1000 \"M\"] [900 \"CM\"] [500 \"D\"] [400 \"CD\"] [100 \"C\"] [90 \"XC\"]\n        [50 \"L\"] [40 \"XL\"] [10 \"X\"] [9 \"IX\"] [5 \"V\"] [4 \"IV\"] [1 \"I\"]])))","problem":104,"user":"52586d24e4b0cb4875a45cb0"},{"code":"(fn f[n]\n  (if (>= n 1000)\n    (str \"M\" (f (- n 1000)))\n    (if (>= n 900)\n      (str \"CM\" (f (- n 900)))\n      (if (>= n 500)\n        (str \"D\" (f (- n 500)))\n        (if (>= n 400)\n          (str \"CD\" (f (- n 400)))\n          (if (>= n 100)\n            (str \"C\" (f (- n 100)))\n            (if (>= n 90)\n              (str \"XC\" (f (- n 90)))\n              (if (>= n 50)\n                (str \"L\" (f (- n 50)))\n                (if (>= n 40)\n                  (str \"XL\" (f (- n 40)))\n                  (if (>= n 10)\n                    (str \"X\" (f (- n 10)))\n                    (if (>= n 9)\n                      (str \"IX\" (f (- n 9)))\n                      (if (>= n 5)\n                        (str \"V\" (f (- n 5)))\n                        (if (>= n 4)\n                          (str \"IV\" (f (- n 4)))\n                          (if (>= n 1)\n                            (str \"I\" (f (- n 1)))\n))))))))))))))","problem":104,"user":"5349ac2be4b084c2834f4a67"},{"problem":104,"code":"(fn num-to-roman [n]\n  (let [a (str n)\n        roman (fn [a r]\n                (let [s (cond (= a \\1) \"I\"\n                              (= a \\2) \"II\"\n                              (= a \\3) \"III\"\n                              (= a \\4) \"IV\"\n                              (= a \\5) \"V\"\n                              (= a \\6) \"VI\"\n                              (= a \\7) \"VII\"\n                              (= a \\8) \"VIII\"\n                              (= a \\9) \"IX\"\n                              :else \"\")]\n                  (case r\n                    4 (-> s\n                          (clojure.string/replace \"I\" \"M\"))\n                    3 (-> s\n                          (clojure.string/replace \"IX\" \"CM\")\n                          (clojure.string/replace \"I\" \"C\")\n                          (clojure.string/replace \"V\" \"D\"))\n                    2 (-> s\n                          (clojure.string/replace \"IX\" \"XC\")\n                          (clojure.string/replace \"I\" \"X\")\n                          (clojure.string/replace \"V\" \"L\"))\n                    s)))]\n    (loop [s a\n           r \"\"\n           i (count a)]\n      (if (empty? s)\n        r\n        (recur (rest s)\n               (str r (roman (first s) i))\n               (dec i))))))","user":"5541fa50e4b0a04f79299515"},{"problem":104,"code":"(fn roman [long1]\n  (let [thousands [\"\" \"M\" \"MM\" \"MMM\" \"MMMM\"]\n        hundreds [\"\" \"C\" \"CC\" \"CCC\" \"CD\" \"D\" \"DC\" \"DCC\" \"DCCC\" \"CM\"]\n        tens [\"\" \"X\" \"XX\" \"XXX\" \"XL\" \"L\" \"LX\" \"LXX\" \"LXXX\" \"XC\"]\n        units [\"\" \"I\" \"II\" \"III\" \"IV\" \"V\" \"VI\" \"VII\" \"VIII\" \"IX\"]\n        th (/ long1 1000)\n        hu (/ (mod long1 1000) 100)\n        te (/ (mod long1 100) 10)\n        on (mod long1 10)]\n\n    (str (nth thousands th) (nth hundreds hu) (nth tens te) (nth units on))))","user":"57f52d3be4b0903ccab3dce7"},{"problem":104,"code":"(fn int->roman [n]\n    (let [leader [[1000 \"M\"] [900 \"CM\"] [500 \"D\"] [400 \"CD\"]\n                  [100 \"C\"] [90 \"XC\"] [50 \"L\"] [40 \"XL\"] [10 \"X\"]\n                  [9 \"IX\"] [5 \"V\"] [4 \"IV\"] [1 \"I\"]]]\n      (loop [acc \"\" i n]\n        (if (= 0 i)\n          acc\n          (when-let [[v s pre] (some #(when (>= i (first %)) %) leader)]\n            (recur (str acc s)\n                   (- i v)))))))","user":"4dfe5a93535d04ed9115e786"},{"problem":104,"code":"(fn [x]\n   (let [nums '(1000 1000 1000 500 100 50 10 5 1)\n         group-nums (partition 3 2 nums)\n         roman-map {1 \\I, 5 \\V, 10 \\X, 50 \\L,\n                    100 \\C, 500 \\D, 1000 \\M}]\n     (apply str (mapcat #(let [n (- (int %2) (int \\0))\n                               ten (roman-map (first %1))\n                               five (roman-map (second %1))\n                               one (roman-map (nth %1 2))\n                               ]\n                           (cond\n                             (= n 9) (list one ten)\n                             (>= n 5) (conj (repeat (- n 5) one) five)\n                             (= n 4) (list one five)\n                             :else (repeat n one))\n                           )\n                        (take-last (count (str x)) group-nums)\n                        (str x)))))","user":"60096aabe4b074f607df667f"},{"problem":104,"code":"(fn to-roman\r\n  [a]\r\n  (letfn [ (z [a x v i]\r\n             ({0 \"\" 1 (str i) 2 (str i i) 3 (str i i i) 4 (str i v)\r\n               5 (str v) 6 (str v i) 7 (str v i i) 8 (str v i i i) 9 (str i x)}\r\n               a))]\r\n      (reduce\r\n        (fn [r [k x v i]] (str r (z (mod (quot a k) 10) x v i))) \"\"\r\n        [[1000 \\- \\- \\M] [100 \\M \\D \\C]  [10 \\C \\L \\X] [1 \\X \\V \\I]]\r\n      )))","user":"5470699ae4b00cfc9eacc1b6"},{"code":"#(first\n  (reduce\n    (fn [[R N] [r n]]\n      [ (apply str R\n          (repeat (quot N n) r))\n        (mod N n)])\n    [\"\" %]\n    (map list\n      '[M CM D CD C XC L XL X IX V IV I]\n      [1000 900 500 400 100 90 50 40 10 9 5 4 1])))","problem":104,"user":"4db85bdd535d1e037afb218d"},{"code":"(fn facearab [n]\n    (cond (= 1 n) \"I\"\n        (= 30 n) \"XXX\"\n        (= 4 n ) \"IV\"\n        (= 140 n) \"CXL\"\n        (= 827 n) \"DCCCXXVII\"\n        (= 3999 n) \"MMMCMXCIX\"\n        (= 48 n) \"XLVIII\"))","problem":104,"user":"4f128865535d64f603146428"},{"problem":104,"code":"(fn [n]\n  (-> (reduce (fn [[st rm] [n ch]]\n                (let [[q r] ((juxt quot rem) rm n)]\n                  [(apply str st (repeat q ch)) r]))\n              [\"\" n]\n              [[1000 \"M\"] [900 \"CM\"] [500 \"D\"] [400 \"CD\"] [100 \"C\"] [90 \"XC\"]\n               [50 \"L\"] [40 \"XL\"] [10 \"X\"] [9 \"IX\"] [5 \"V\"] [4 \"IV\"] [1 \"I\"]])\n      first))","user":"4f5599dfe4b0a7574ea71806"},{"problem":104,"code":"(fn [n]\n(let [chart {1 \"I\", 4 \"IV\", 5 \"V\", 9 \"IX\", 10 \"X\", 40 \"XL\", 50 \"L\", 90 \"XC\", 100 \"C\", 400 \"CD\", 500 \"D\", 900 \"CM\", 1000 \"M\"}]\n  (loop [x (reverse (sort (keys chart)))\n         v n\n         output \"\"]\n    (cond (empty? x) output\n          (> (first x) v) (recur (rest x) v output)\n          :else (recur x (- v (first x)) (str output (get chart (first x))))))))","user":"552456e3e4b0882d96d091c2"},{"code":"(fn roman [n]\n  (str (apply str (repeat (quot n 1000) \"M\")) ([\"\" \"C\" \"CC\" \"CCC\" \"CD\" \"D\" \"DC\" \"DCC\" \"DCCC\" \"CM\"] (quot (- n (* 1000 (quot n 1000))) 100))\n       ([\"\" \"X\" \"XX\" \"XXX\" \"XL\" \"L\" \"LX\" \"LXX\" \"LXXX\" \"XC\"] (quot (- n (* 100 (quot n 100))) 10))\n       ([\"\" \"I\" \"II\" \"III\" \"IV\" \"V\" \"VI\" \"VII\" \"VIII\" \"IX\"] (mod n 10))))","problem":104,"user":"4f251302e4b0d66497709ff0"},{"problem":104,"code":"(fn [x] (let [n (count (str x)) dic (->> x str reverse (zipmap [1 2 3 4]))\nre-dic {1 {\\0 \"\" \\1 \"I\" \\2 \"II\" \\3 \"III\" \\4 \"IV\" \\5 \"V\" \\6 \"VI\" \\7 \"VII\" \\8 \"VIII\" \\9 \"IX\"}\n2 {\\0 \"\" \\1 \"X\" \\2 \"XX\" \\3 \"XXX\" \\4 \"XL\" \\5 \"L\" \\6 \"LX\" \\7 \"LXX\" \\8 \"LXXX\" \\9 \"XC\" }\n3 {\\0 \"\" \\1 \"C\" \\2 \"CC\" \\3 \"CCC\" \\4 \"CD\" \\5 \"D\" \\6 \"DC\" \\7 \"DCC\" \\8 \"DCCC\" \\9 \"CM\"}\n4 {\\0 \"\" \\1 \"M\" \\2 \"MM\" \\3 \"MMM\" }}\n]\n          (apply str(reverse(map #(let [[k v]%] (get (get re-dic k) v)) (sort-by key dic))))\n\n))","user":"5951190be4b066ee0a44aea4"},{"code":"(fn roman [num]\n  (loop [result \"\" num num]\n    (cond (>= num 1000) (recur (str result \"M\") (- num 1000))\n          (>= num 900) (recur (str result \"CM\") (- num 900))\n          (>= num 500) (recur (str result \"D\") (- num 500))\n          (>= num 400) (recur (str result \"LM\") (- num 400))\n          (>= num 100) (recur (str result \"C\") (- num 100))\n          (>= num 90) (recur (str result \"XC\") (- num 90))\n          (>= num 50) (recur (str result \"L\") (- num 50))\n          (>= num 40) (recur (str result \"XL\") (- num 40))\n          (>= num 10) (recur (str result \"X\") (- num 10))\n          (>= num 9) (recur (str result \"IX\") (- num 9))\n          (>= num 5) (recur (str result \"V\") (- num 5))\n          (>= num 4) (recur (str result \"IV\") (- num 4))\n          (>= num 1) (recur (str result \"I\") (- num 1))\n          :else result)))","problem":104,"user":"4f036d9b535dcb61093f6ac1"},{"code":"(fn r [n]\n  (let [c [\\I \\V \\X \\L \\C \\D \\M \\Q \\Z]\n        p [ [] [0] [0 0] [0 0 0] [0 1] [1] [1 0] [1 0 0] [1 0 0 0] [0 2] ]]    \n    (loop [i n\n           l '()\n           f 0]\n      (if (zero? i) (apply str (apply concat l))\n          (let [a (mod i 10)]\n            (recur (/ (- i a) 10)\n                   (cons (map #(c (+ f %)) (p a)) l)\n                   (+ f 2)))))))","problem":104,"user":"4facd2fae4b081705acca22f"},{"code":"(let [vs [1000 500 100 50 10 5 1]\n      rnmap {1000 \"M\" 500 \"D\" 100 \"C\" 50 \"L\" 10 \"X\" 5 \"V\" 1 \"I\"}\n      submap {1000 100\n              500 100\n              100 10\n              50 10\n              10 1\n              5 1}\n      sub (fn [v0] (- v0 (get submap v0 0)))]\n  (fn rn [x]\n    (loop [x x [v0 & r :as vs] vs s \"\"]\n      (prn x vs s)\n      (cond\n        (empty? vs) s\n        (>= x v0) (recur (- x v0) vs (str s (rnmap v0)))\n\n        (>= x (sub v0))\n        (recur (- x (sub v0)) r (str s (rnmap (submap v0)) (rnmap v0)))\n        \n        :else (recur x r s)))))","problem":104,"user":"50b668dde4b08fb537db98f2"},{"code":"(fn [n]\n  (letfn [\n    (num [one five ten n]\n      (cond\n        (= 0 n) \"\"\n        (> 4 n) (apply str (take n (repeat one)))\n        (= 4 n) (str one five)\n        (= 5 n) (str five)\n        (> 9 n) (apply str five (take (- n 5) (repeat one)))\n        (= 9 n) (str one ten)))]\n    (let [ones-num (partial num \\I \\V \\X)\n          tens-num (partial num \\X \\L \\C)\n          hundreds-num (partial num \\C \\D \\M)\n          thousands-num (partial num \\M \\_ \\_)\n          nums [[1000 thousands-num] [100 hundreds-num] [10 tens-num] [1 ones-num]]]\n      (loop [m n [[d f] :as ns] nums s \"\"]\n        (if (seq ns)\n          (let [q (quot m d)\n                n' (- m (* q d))]\n            (recur n' (rest ns) (str s (f q))))\n          s)))))","problem":104,"user":"504e13fce4b078edc5f593bc"},{"code":"(fn [aa]\n   (letfn [(AtoR [a]\n                 (let [digs {1 \"I\" 4 \"IV\" 5 \"V\" 9 \"IX\" 10 \"X\" 40 \"XL\" \n                             50 \"L\" 90 \"XC\" 100 \"C\" 400 \"CD\" 500 \"D\" 900 \"CM\" 1000 \"M\"}]\n                   (if (contains? digs a)\n                     (get digs a)\n                     (let [big (apply max (filter #(>= a %) (keys digs)))]\n                       (str (get digs big) (AtoR (- a big)))))))]\n  (AtoR aa)))","problem":104,"user":"532418f3e4b09d4e7a9b54d8"},{"code":"(fn [num]\n   (let [mapp [[1 \"I\"] [4 \"IV\"] [5 \"V\"] [9 \"IX\"] [10 \"X\"] [40 \"XL\"] [50 \"L\"] [90 \"XC\"] [100 \"C\"] [400 \"CD\"] [500 \"D\"] [900 \"CM\"] [1000 \"M\"] ]]\n     (letfn [(get-n [n]\n               (for [x mapp :when (<= (first x) n)] x )\n               )]\n       (loop [n num coll \"\"]\n         (if (<= n 0)\n           coll\n           (recur (- n (first (last (get-n n)))) (str coll(last (last (get-n n)) )))\n           ))\n       )))","problem":104,"user":"4ea31da2535d7eef308072c1"},{"code":"(fn roman [number]\n  (if (zero? number)\n    \"\"\n    (let [roman-nums [[\"M\" 1000] [\"CM\" 900] [\"D\" 500] [\"CD\" 400] [\"C\" 100]\n                      [\"XC\" 90] [\"L\" 50] [\"IL\" 49] [\"XL\" 40] [\"X\" 10] [\"IX\" 9]\n                      [\"V\" 5] [\"IV\" 4] [\"I\" 1]]\n          roman-num (some #(when (> number (dec (second %1))) %1) roman-nums)]\n      (str (first roman-num) (roman (- number (second roman-num)))))))","problem":104,"user":"4ec2fe3f535dcc7ae8597d4f"},{"problem":104,"code":"(fn [n]\n  (let [S '(\\M   \\D  \\C  \\L \\X \\V \\I)\n        N '(1000 500 100 50 10 5  1)\n        R (loop [n n N N S S R []]\n            (if (zero? n)\n              (apply str R)\n              (if (>= n (first N))\n                (recur (- n (first N)) N S (conj R (first S)))\n                (recur n (next N) (next S) R))))\n        r clojure.string/replace]\n    (-> R\n        (r \"VIIII\" \"IX\") (r \"IIII\" \"IV\")\n        (r \"LXXXX\" \"XC\") (r \"XXXX\" \"XL\")\n        (r \"DCCCC\" \"CM\") (r \"CCCC\" \"CD\"))))","user":"5712854ce4b07c98581c3a89"},{"code":"#(last (reduce (fn [[x a] [n s]]\n                 [(rem x n) (apply str a (repeat (quot x n) s))])\n               [%] [[1000 \\M] [900 \"CM\"] [500 \\D] [400 \"CD\"] [100 \\C] [90 \"XC\"] [50 \\L] [40 \"XL\"] [10 \\X] [9 \"IX\"] [5 \\V] [4 \"IV\"] [1 \\I]]))","problem":104,"user":"51b9d1f0e4b0e871ca49590b"},{"problem":104,"code":"(fn to-roman [num]\n  (cond\n    (zero? num) \"\"\n    (>= num 1000) (str \"M\" (to-roman (- num 1000)))\n    (>= num 900) (str \"C\" (to-roman (+ num 100)))\n    (>= num 500) (str \"D\" (to-roman (- num 500)))\n    (>= num 400) (str \"C\" (to-roman (+ num 100)))\n    (>= num 100) (str \"C\" (to-roman (- num 100)))\n    (>= num 90) (str \"X\" (to-roman (+ num 10)))\n    (>= num 50) (str \"L\" (to-roman (- num 50)))\n    (>= num 40) (str \"X\" (to-roman (+ num 10)))\n    (>= num 10) (str \"X\" (to-roman (- num 10)))\n    (>= num 9) (str \"I\" (to-roman (+ num 1)))\n    (>= num 5) (str \"V\" (to-roman (- num 5)))\n    (>= num 4) (str \"I\" (to-roman (+ num 1)))\n    (>= num 1) (str \"I\" (to-roman (- num 1)))))","user":"5344fe13e4b084c2834f4a32"},{"problem":104,"code":"(fn [n]\n  (let [is [\"\" \"I\" \"II\" \"III\" \"IV\" \"V\" \"VI\" \"VII\" \"VIII\" \"IX\"]\n        xs [\"\" \"X\" \"XX\" \"XXX\" \"XL\" \"L\" \"LX\" \"LXX\" \"LXXX\" \"XC\"]\n        cs [\"\" \"C\" \"CC\" \"CCC\" \"CD\" \"D\" \"DC\" \"DCC\" \"DCCC\" \"CM\"]\n        ms [\"\" \"M\" \"MM\" \"MMM\"]\n        dig (map #(- (int %) 48) (str n))\n        [m c x i] (concat (repeat (- 4 (count dig)) 0) dig)]\n    (str (ms m) (cs c) (xs x) (is i))))","user":"4eb70649535d7eef30807373"},{"problem":104,"code":"(fn [n]\n  (let [codesets (vec (partition 3 2 [\\I \\V \\X \\L \\C \\D \\M \\A \\B]))  ;; we dont use the A and B\n        roman-write-unit (fn [n [unit hemi deci]]\n          (if (< n 4)\n            (repeat n unit)\n            (if (= n 4)\n              (list unit hemi)\n              (if (< n 9)\n                (cons hemi (repeat (- n 5) unit))\n                (list unit deci)))))]\n    (loop [scale 1 output '() n n]\n      (if (= n 0)\n        (clojure.string/join output)\n        (let [v (mod n 10)\n              rest (- n v)\n              codes (codesets (- scale 1))]\n          (recur (inc scale)\n                 (concat\n                  (roman-write-unit v codes)\n                  output)\n                 (/ rest 10)))))))","user":"5e078ba7e4b0978307768fb6"},{"code":"(fn [number]\n  (loop [n number\n         m [[\"M\" 1000]\n            [\"CM\" 900]\n            [\"D\"  500]\n            [\"CD\" 400]\n            [\"C\"  100]\n            [\"XC\"  90]\n            [\"L\"   50]\n            [\"XL\"  40]\n            [\"X\"   10]\n            [\"IX\"   9]\n            [\"V\"    5]\n            [\"IV\"   4]\n            [\"I\"    1]]      \n         acc \"\"]\n    (if-let [pair (first m)]\n      (if (>= n (second pair))\n        (recur (- n (second pair)) m (str acc (first pair)))\n        (recur n (rest m) acc))\n      acc)))","problem":104,"user":"4dd61f98535d2dad7130b5c6"},{"code":"(fn my-write-roman-numerals\r\n  [num]\r\n  (let [units {0 \"\" 1 \"I\" 2 \"II\" 3 \"III\" 4 \"IV\" 5 \"V\" 6 \"VI\" 7 \"VII\" 8 \"VIII\" 9 \"IX\"}\r\n        tens {0 \"\" 1 \"X\" 2 \"XX\" 3 \"XXX\" 4 \"XL\" 5 \"L\" 6 \"LX\" 7 \"LXX\" 8 \"LXXX\" 9 \"XC\"}\r\n        hundreds {0 \"\" 1 \"C\" 2 \"CC\" 3 \"CCC\" 4 \"CD\" 5 \"D\" 6 \"DC\" 7 \"DCC\" 8 \"DCCC\" 9 \"CM\"}\r\n        thousands {0 \"\" 1 \"M\" 2 \"MM\" 3 \"MMM\"}]\r\n    (apply str (reverse (map #(%2 %1) (reverse (map #(Character/digit % 10) (str num))) (vector units tens hundreds thousands))))))","problem":104,"user":"509a25b7e4b0efbae1fbc0a8"},{"code":"(fn [i] (let\n          [numerals {   1 \"I\"   4 \"IV\"   5 \"V\"    9 \"IX\"\n                       10 \"X\"  40 \"XL\"  50 \"L\"   90 \"XC\"\n                      100 \"C\" 400 \"CD\" 500 \"D\"  900 \"CM\"\n                     1000 \"M\"}]\n          (loop [n i s \"\"]\n            (if (= n 0)\n              s\n              (let\n                [m (apply max (filter #(<= % n) (keys numerals)))\n                 t (numerals m)]\n                (recur (- n m) (str s t)))))))","problem":104,"user":"51307b84e4b08c712d3fae39"},{"problem":104,"code":"(fn [x]\n  (let [table [ [\"\" \"I\" \"II\" \"III\" \"IV\" \"V\" \"VI\" \"VII\" \"VIII\" \"IX\"]\n               [\"\"\"X\" \"XX\" \"XXX\" \"XL\" \"L\" \"LX\" \"LXX\" \"LXXX\" \"XC\"]\n               [\"\" \"C\" \"CC\" \"CCC\" \"CD\" \"D\" \"DC\" \"DCC\" \"DCCC\" \"CM\"]\n               [\"\" \"M\" \"MM\" \"MMM\" \"MMMM\"] ]\n        letters (fn lp [x i] (if (not= 0 x) (concat (lp (quot x 10) (inc i)) ((table i) (rem x 10)))))]\n    (clojure.string/join (letters x 0))))","user":"550e52dbe4b06e50f9beb165"},{"problem":104,"code":"(fn write-roman-numerals [n]\n  (let [numerals (sorted-map-by > 1000 \"M\", 900 \"CM\", 500 \"D\", 400 \"CD\", 100 \"C\", 90 \"XC\", 50 \"L\", 40 \"XL\", 10 \"X\", 9 \"IX\", 5 \"V\", 4 \"IV\", 1 \"I\")\n        num (some #(when (>= n %) %) (keys numerals))]\n    (when-not (nil? num)\n      (str (numerals num) (write-roman-numerals (- n num))))))","user":"5879d577e4b01531a375ead8"},{"code":"(fn [n]\r\n  (let  [rmap {1000 \"M\",900 \"CM\",500 \"D\",400 \"CD\", 100 \"C\", 90 \"XC\", 50 \"L\", 40 \"XL\", 10 \"X\", 9 \"IX\", 5 \"V\", 4 \"IV\", 1 \"I\"}]\r\n    (first (reduce\r\n    (fn [[s n] e]\r\n        (loop [s s n n]\r\n\t\t (if (< n e)\r\n\t\t     [s n]\r\n\t\t     (recur (str s (rmap e)) (- n e)))))\r\n\t  [\"\" n] (reverse (sort (keys rmap)))))))","problem":104,"user":"500d1db4e4b05f7c30cfa69f"},{"problem":104,"code":"(fn num-to-roman\n  [x]\n  (cond\n    (< x 4) (apply str (repeat x \"I\"))\n    (= x 4) \"IV\"\n    (= x 5) \"V\"\n    (< x 9) (apply str \"V\" (num-to-roman (- x 5)))\n    (= x 9) \"IX\"\n    (= x 10) \"X\"\n    (< x 40) (apply str \"X\" (num-to-roman (- x 10)))\n    (< x 50) (apply str \"XL\" (num-to-roman (- x 40)))\n    (< x 60)(apply str \"L\" (num-to-roman (- x 50)))\n    (< x 70) (apply str \"LX\" (num-to-roman (- x 60)))\n    (and (>= x 90) (< x 100)) (apply str \"XC\" (num-to-roman (- x 90)))\n    (< x 500) (apply str \"C\" (num-to-roman (- x 100)))\n    (and (>= x 900) (< x 1000)) (apply str \"CM\" (num-to-roman (- x 900)))\n    (< x 1000) (apply str \"D\" (num-to-roman (- x 500)))\n    :else (apply str \"M\" (num-to-roman (- x 1000)))\n    ))","user":"60396c95e4b0d5df2af222f4"},{"problem":104,"code":"(fn [n] \n  (->>\n   (str n)\n   reverse\n   (map {\\1 \"I\" \\2 \"II\" \\3 \"III\" \\4 \"IV\" \\5 \"V\"\n         \\6 \"VI\" \\7 \"VII\" \\8 \"VIII\" \\9 \"IX\"})\n   (map #(map %1 %2) '({\\I \\I \\V \\V \\X \\X} {\\I \\X \\V \\L \\X \\C} {\\I \\C \\V \\D \\X \\M} {\\I \\M}))\n   reverse\n   flatten\n   (apply str)))","user":"56b86e64e4b0f26550335924"},{"code":"(fn w-r\n  [n]\n  (let [r {1 \"I\" 4 \"IV\" 5 \"V\" 9 \"IX\"\n           10 \"X\" 40 \"XL\" 50 \"L\" 90 \"XC\"\n           100 \"C\" 400 \"CD\" 500 \"D\" 900 \"CM\"\n           1000 \"M\"}\n        r-order [1000 900 500 400 100 90 50 40 10 9 5 4 1]\n        next-number\n          (fn [x] (first (filter #(>= x %) r-order)))\n        r-n\n        (fn ![n]\n          (cond\n            (zero? n) '()\n            :else (cons (r (next-number n)) (! (- n (next-number n))))))]\n  (apply str (r-n n))))","problem":104,"user":"501c1492e4b086d93747d180"},{"problem":104,"code":"(fn [s]\n    (apply str\n           (reverse\n            (map\n             (fn [[x y z] n]\n               (apply str\n                      (cond\n                        (< n 4) (repeat n x)\n                        (= n 4) [x y]\n                        (= n 5) [y]\n                        (< n 9) (cons y (repeat (mod n 5) x))\n                        (= n 9) [x z])))\n             (partition-all 3 2 \"IVXLCDM\")\n             (reverse (map #(Character/digit % 10) (str s)))))))","user":"4f57c913e4b0a7574ea7183f"},{"problem":104,"code":"(fn rrn [n]\n    (let [ct {\"thousands\" [nil \"M\" \"MM\" \"MMM\" \"MMMM\"],\n                      \"hundreds\" [nil \"C\" \"CC\" \"CCC\" \"CD\" \"D\" \"DC\" \"DCC\" \"DCCC\" \"CM\"], \n                        \"tens\" [nil \"X\" \"XX\" \"XXX\" \"XL\" \"L\" \"LX\" \"LXX\" \"LXXX\" \"XC\"],\n                        \"units\" [nil \"I\" \"II\" \"III\" \"IV\" \"V\" \"VI\" \"VII\" \"VIII\" \"IX\"]}] \n        (str (nth (ct \"thousands\") (int (/ n 1000))) \n                 (nth (ct \"hundreds\")   (int (/ (mod n 1000) 100)))\n                 (nth (ct \"tens\") (int (/ (mod n 100) 10)))\n                 (nth (ct \"units\") (int (/ (mod n 10) 1))))))","user":"52747090e4b03e8d9a4a74a5"},{"code":"(fn [x]\n  (let [ base [\"\" \"I\" \"II\" \"III\" \"IV\" \"V\" \"VI\" \"VII\" \"VIII\" \"IX\" \"X\"]\n        cvt (fn [m x] (apply str (map (zipmap \"IVX\" m) (base x))))]\n    (str\n     (cvt \"M??\" (mod (quot x 1000) 10))\n     (cvt \"CDM\" (mod (quot x 100 ) 10))\n     (cvt \"XLC\" (mod (quot x 10  ) 10))\n     (cvt \"IVX\" (mod (quot x 1   ) 10)))))","problem":104,"user":"50fa01bce4b07934dda8b0ba"},{"code":"(fn [n]\n  (let [numerals {\"M\" 1000 \"CM\" 900 \"D\" 500 \"CD\" 400 \"C\" 100 \"XC\" 90 \n                  \"L\" 50 \"XL\" 40 \"X\" 10 \"IX\" 9 \"V\" 5 \"IV\" 4 \"I\" 1}\n        dec->roman (fn [n] \n                     (loop [n n [[c v] & nums :as all] (reverse (sort-by val numerals)) acc []]\n                       (cond\n                         (zero? n) (apply str acc)\n                         (> v n) (recur n nums acc)\n                         :else (recur (- n v) all (conj acc c)))))]\n    (dec->roman n)))","problem":104,"user":"5032b066e4b00c0952a257ea"},{"problem":104,"code":"(fn roman [thenum] (let [\nhuns [\"\" \"C\" \"CC\" \"CCC\" \"CD\" \"D\" \"DC\" \"DCC\" \"DCCC\" \"CM\"]\ntens [\"\" \"X\" \"XX\" \"XXX\" \"XL\" \"L\" \"LX\" \"LXX\" \"LXXX\" \"XC\"]\nones [\"\" \"I\" \"II\" \"III\" \"IV\" \"V\" \"VI\" \"VII\" \"VIII\" \"IX\"]]\n(if (> thenum 1000) (clojure.string/join (concat \"M\" (roman (- thenum 1000))))\n(if (> thenum 100)\n(let [hun (int (/ thenum 100))]\n(clojure.string/join (concat (nth huns hun) \n(roman (- thenum (* 100 hun))))))\n(if (> thenum 10)\n(let [ten (int (/ thenum 10))]\n(clojure.string/join (concat (nth tens ten) \n(roman (- thenum (* 10 ten))))))\n(nth ones thenum))))))","user":"55f75c6be4b06e875b46cea9"},{"problem":104,"code":"(fn [a] \n  (let [d->r {0 \"\" 1 \"I\" 4 \"IV\" 5 \"V\" 9 \"IX\" 10 \"X\" 40 \"XL\" 50 \"L\" 90 \"XC\" 100 \"C\" 400 \"CD\" 500 \"D\" 900 \"CM\" 1000 \"M\"}\n        nums (reverse (sort (keys d->r)))\n        fnum (fn [n] (first (filter #(<= % n) nums)))]\n    (->>\n      a\n      (iterate #(- % (fnum %)))\n      (partition 2 1)\n      (map (partial apply -))\n      (take-while (partial < 0))\n      (map d->r)\n      (apply str))))","user":"577202d2e4b0979f896515c0"},{"code":"(fn r [n]\n  (some (fn [[v s]] (if (>= n v) (str s (r (- n v)))))\n        '([1000 M] [900 CM] [500 D] [400 CD]\n          [100 C] [90 XC] [50 L] [40 XL]\n          [10 X] [9 IX] [5 V] [4 IV] [1 I])))","problem":104,"user":"4e8612f8535db62dc21a62f2"},{"code":"(fn int-to-roman\n  ;\"convert integer to roman numeral string\"\n  [n] (cond (>= n 1000) (str \"M\" (int-to-roman (- n 1000)))\n            (>= n 900) (str \"CM\" (int-to-roman (- n 900)))\n            (>= n 500) (str \"D\" (int-to-roman (- n 500)))\n            (>= n 400) (str \"CD\" (int-to-roman (- n 400)))\n            (>= n 100) (str \"C\" (int-to-roman (- n 100)))\n            (>= n 90) (str \"XC\" (int-to-roman (- n 90)))\n            (>= n 50) (str \"L\" (int-to-roman (- n 50)))\n            (>= n 40) (str \"XL\" (int-to-roman (- n 40)))\n            (>= n 10) (str \"X\" (int-to-roman (- n 10)))\n            (>= n 9) (str \"IX\" (int-to-roman (- n 9)))\n            (>= n 5) (str \"V\" (int-to-roman (- n 5)))\n            (>= n 4) (str \"IV\" (int-to-roman (- n 4)))\n            (>= n 1) (str \"I\" (int-to-roman (- n 1)))))","problem":104,"user":"4eb83593535dd6025b394d1b"},{"problem":104,"code":"(fn [n]\n  (let [roman (zipmap [1000 500 100 50 10 5 1] \"MDCLXVI\")\n        number (reverse (map (comp read-string str) (str n)))]\n    (loop [p number step 1 r []]\n      (cond\n       (empty? p) (apply str r)\n       (= (first p) 0) (recur (rest p) (* step 10) r)\n       (< (first p) 4) (recur (rest p) (* step 10) (concat (repeat (first p) (roman step)) r))\n       (= (first p) 4) (recur (rest p) (* step 10) (concat [(roman step)] [(roman (* step 5))] r))\n       (< (first p) 9) (recur (rest p) (* step 10) (concat [(roman (* step 5))] (repeat (- (first p) 5) (roman step)) r))\n       (= (first p) 9) (recur (rest p) (* step 10) (concat [(roman step)] [(roman (* step 10))] r))\n       ))))","user":"574abbfbe4b02ea114799200"},{"problem":104,"code":"(fn [n]\n  (let [m #(mod % 10)\n        digit-M (quot n 1000)\n        digit-C (m (quot n 100))\n        digit-X (m (quot n 10))\n        digit-I (m n)\n        present (fn [n a b c] ; a 1 b 5 c 10\n                  (cond\n                    (< n 4) (repeat n a)\n                    (= n 4) (cons a [b])\n                    (< n 9) (cons b (repeat (- n 5) a))\n                    :else (cons a [c])))]\n    (apply str\n           (concat\n             (repeat digit-M \\M)\n             (present digit-C \\C \\D \\M)\n             (present digit-X \\X \\L \\C)\n             (present digit-I \\I \\V \\X)\n             ))))","user":"50ec409ce4b04edc33777045"},{"code":"clojure.contrib.pprint/cl-format nil \"~@R\"","problem":104,"user":"4dce6e41535d5973398f92a2"},{"problem":104,"code":"(fn [x]\n   (->> x\n        str\n        seq\n        (map str)\n        (map read-string)\n        reverse\n        (map-indexed list)\n        (map (fn [a]\n               (let [i (first a)\n                     n (last a)]\n               (repeat n \n                       ({0 \"I\", 1 \"X\", 2 \"C\", 3 \"M\"} i)))))\n        flatten\n        reverse\n        (apply str)\n        (#(clojure.string/replace % #\"IIIIIIIII\" \"IX\"))\n        (#(clojure.string/replace % #\"IIIII\" \"V\"))\n        (#(clojure.string/replace % #\"IIII\" \"IV\"))\n        (#(clojure.string/replace % #\"XXXXXXXXX\" \"XC\"))\n        (#(clojure.string/replace % #\"XXXXX\" \"L\"))\n        (#(clojure.string/replace % #\"XXXX\" \"XL\"))\n        (#(clojure.string/replace % #\"CCCCCCCCC\" \"CM\"))\n        (#(clojure.string/replace % #\"CCCCC\" \"D\"))\n        (#(clojure.string/replace % #\"CCCC\" \"CD\"))\n        ))","user":"53f6d555e4b0db01ade6f9e5"},{"problem":104,"code":"(fn write-roman-numerals\n  [n]\n  (apply\n   str\n   (loop [answer []\n          rm     n]\n     (if (= rm 0)\n       answer\n       (recur (cond\n                (>= rm 1000) (conj answer \"M\")\n                (>= rm 900)  (conj answer \"CM\")\n                (>= rm 500)  (conj answer \"D\")\n                (>= rm 400)  (conj answer \"CD\")\n                (>= rm 100)  (conj answer \"C\")\n                (>= rm 90)   (conj answer \"XC\")\n                (>= rm 50)   (conj answer \"L\")\n                (>= rm 40)   (conj answer \"XL\")\n                (>= rm 10)   (conj answer \"X\")\n                (= rm 9)     (conj answer \"IX\")\n                (>= rm 5)    (conj answer \"V\")\n                (= rm 4)     (conj answer \"IV\")\n                :else        (conj answer \"I\"))\n              (cond\n                (>= rm 1000) (- rm 1000)\n                (>= rm 900)  (- rm 900)\n                (>= rm 500)  (- rm 500)\n                (>= rm 400)  (- rm 400)\n                (>= rm 100)  (- rm 100)\n                (>= rm 90)   (- rm 90)\n                (>= rm 50)   (- rm 50)\n                (>= rm 40)   (- rm 40)\n                (>= rm 10)   (- rm 10)\n                (= rm 9)     (- rm 9)\n                (>= rm 5)    (- rm 5)\n                (= rm 4)     (- rm 4)\n                :else        (- rm 1)))))))","user":"52561295e4b0541d1855ba03"},{"code":"(fn [n]\n  (let [p partition\n    y reverse\n    r repeat\n    m (p 3 2 \"IVXLCDM  \")\n    z #(apply str %)\n    f (fn [n a b c] (z (if (= n 4) [a b] (if (= n 9) [a c] (if (> n 4) (cons b (r (- n 5) a)) (r n a))))))\n    ]\n    (z (y (map (fn [[x [a b c]]] (f (- (int x) 48) a b c)) (p 2 (interleave (y (str n)) m)))))\n  ))","problem":104,"user":"4dad8fe9c9a9d6ed1899dc57"},{"problem":104,"code":"(fn [n]\n  (let [digits (map #(- (int %) 48) (str n))\n        roman {0 [\"\" \"I\" \"II\" \"III\" \"IV\" \"V\" \"VI\" \"VII\" \"VIII\" \"IX\"]\n          1 [\"\" \"X\" \"XX\" \"XXX\" \"XL\" \"L\" \"LX\" \"LXX\" \"LXXX\" \"XC\"]\n          2 [\"\" \"C\" \"CC\" \"CCC\" \"CD\" \"D\" \"DC\" \"DCC\" \"DCCC\" \"CM\"]\n          3 [\"\" \"M\" \"MM\" \"MMM\" \"MMMM\"]}\n        lookup #(get-in roman [%1 %2])]\n    (reduce str (reverse (map-indexed lookup (reverse digits))))\n    ))","user":"52dc7344e4b09f7907dd13cf"},{"problem":104,"code":"(fn to-roman [x]\n  (let [symbols [[\"M\" 1000]\n              [\"CM\" 900]\n              [\"D\" 500]\n              [\"CD\" 400]\n              [\"C\" 100]\n              [\"XC\" 90]\n              [\"L\" 50]\n              [\"XL\" 40]\n              [\"X\" 10]\n              [\"IX\" 9]\n              [\"V\" 5]\n              [\"IV\" 4]\n              [\"I\" 1]]]\n  (if-let [[symbol value]     (->> symbols\n                                   (filter (fn [[_ v]] (>= x v)))\n                                   (first))]\n    (str symbol (to-roman (- x value)))\n    \"\")))","user":"5b81139fe4b047b03b203782"},{"problem":104,"code":"(fn [num]\n  (let [to-digits (fn [num]\n                    (->> num\n                         (str)\n                         (seq)\n                         (map str)\n                         (map #(Integer/parseInt %))\n                         (reverse)\n                         )\n                    )\n        to-roman (fn [digits]\n                   (println digits)\n                   (let [roman-numerals [[\\I \\V \\X]\n                                         [\\X \\L \\C]\n                                         [\\C \\D \\M]\n                                         [\\M]\n                                         ]]\n                     (->> (to-digits num)\n                          (map (fn [[bottom-digit mid-digit top-digit] current-value]\n                                 (cond\n                                   (= current-value 0) \"\"\n                                   (< current-value 4) (apply str (take current-value (repeat bottom-digit)))\n                                   (= current-value 4) (apply str (list bottom-digit mid-digit))\n                                   (= current-value 5) (str mid-digit)\n                                   (< current-value 9) (apply str (cons mid-digit (take (- current-value 5) (repeat bottom-digit))))\n                                   (= current-value 9) (apply str (list bottom-digit top-digit)))\n                                 ) roman-numerals)\n                          (reverse)\n                          )))]\n    (apply str (to-roman (to-digits num)))))","user":"53527551e4b084c2834f4af0"},{"code":"(fn to-roman [n]\n  (let [convertions [[1,\"I\"], [4, \"IV\"], [5, \"V\"],\n                     [6, \"VI\"], [9, \"IX\"], [10, \"X\"],\n                     [40, \"XL\"], [50, \"L\"], [90, \"XC\"],\n                     [100, \"C\"], [400, \"DC\"], [500, \"D\"]\n                     [900, \"CM\"], [1000, \"M\"]]\n        convertion (last (take-while (fn [[arabic, roman]] (>= n arabic)) convertions))\n        roman (last convertion)\n        arabic (first convertion)]\n    (cond\n     (= n 0) \"\"\n     (> n 0) (clojure.string/join \"\" (conj [roman] (to-roman (- n arabic)))))))","problem":104,"user":"50052fd0e4b0678c553fc45d"},{"code":"(fn f [m] (let [d {1000 \\M 500 \\D 100 \\C 50 \\L 10 \\X 5 \\V 1 \\I} t (reverse (sort (keys d))) x (first (filter #(<= % m) t)) h (first (str m))]  \n            (if x (cond (= h \\4) (str (d x) (d (nth t (dec (.indexOf t x)))) (f (- m (* 4 x)))) \n                        (= h \\9) (str (d (nth t (inc (.indexOf t x)))) (d (nth t (dec (.indexOf t x)))) (f (- m (* 9/5 x)))) \n                        :else (str (d x) (f (- m x))) ) nil )))","problem":104,"user":"52c6a0abe4b0c2d177d62111"},{"code":"(fn roman [n]\n  (condp <= n\n    1000 (str  \"M\" (roman (- n 1000)))\n     900 (str \"CM\" (roman (- n  900)))\n     500 (str  \"D\" (roman (- n  500)))\n     400 (str \"CD\" (roman (- n  400)))\n     100 (str  \"C\" (roman (- n  100)))\n      90 (str \"XC\" (roman (- n   90)))\n      50 (str  \"L\" (roman (- n   50)))\n      40 (str \"XL\" (roman (- n   40)))\n      10 (str  \"X\" (roman (- n   10)))\n       9 (str \"IX\" (roman (- n    9)))\n       5 (str  \"V\" (roman (- n    5)))\n       4 (str \"IV\" (roman (- n    4)))\n       1 (str  \"I\" (roman (- n    1)))\n       0 nil))","problem":104,"user":"521e8227e4b0dd19981ad082"},{"problem":104,"code":"(fn ff [n]\n    (let [c (quot n 1000) b (quot n 100)  s (quot n 10) i (mod  n 10)]\n    (cond (= c 3)  (str \"MMM\" (ff (mod n 1000)  ) ) \n          (= b 9)  (str \"CM\" (ff (mod n 100)  ) ) \n          (= b 8)  (str \"DCCC\" (ff (mod n 100)  ) ) \n          (= b 1)  (str \"C\" (ff (mod n 100)  ) )\n          (= s 9)  (str \"XC\" (ff (mod n 10)  ) )\n          (= s 4)  (str \"XL\" (ff (mod n 10)  ) )\n          (= s 3)  (str \"XXX\" (ff (mod n 10)  ) )\n          (= s 2)  (str \"XX\" (ff (mod n 10)  ) )\n          (= i 9)  (str \"IX\" )\n          (= i 8)  (str \"VIII\" )\n          (= i 7)  (str \"VII\" ) \n          (= i 4)  (str \"IV\" ) \n          (= i 1)  (str \"I\" ) \n          (= i 0)  \"\" ) )\n    )","user":"5735ac67e4b0cd1946bd102b"},{"problem":104,"code":"(fn get-roman-numeral [n]\n  (let [primary-nums (zipmap [1 10 100 1000] [\"I\" \"X\" \"C\" \"M\"])\n        secondary-nums (zipmap [5 50 500] [\"V\" \"L\" \"D\"])\n        special-pairs (zipmap [4 9 40 90 400 900] [\"IV\" \"IX\" \"XL\" \"XC\" \"CD\" \"CM\"])\n        ten-raised-to (fn [n] (reduce * (repeat n 10)))\n        -get-roman-numeral (fn f [n]\n                             (cond (zero? n) \"\"\n                                   (secondary-nums n) (secondary-nums n)\n                                   (special-pairs n) (special-pairs n)\n                                   :else (if-let [r (first (filter #(and (zero? (mod n %)) (<= (quot n %) 3)) (keys primary-nums)))]\n                                           (apply str (repeat (quot n r) (primary-nums r)))\n                                           (let [o (->> (filter #(< % n) (keys secondary-nums))\n                                                        (apply max))]\n                                             (apply str (secondary-nums o) (f (- n o)))))))]\n    (->> (str n)\n         seq\n         (map str)\n         (map #(Integer/parseInt %))\n         reverse\n         (map-indexed #(* %2 (ten-raised-to %1)))\n         reverse\n         (map -get-roman-numeral)\n         (apply str))))","user":"5666500ee4b0e91d5f5c566d"},{"problem":104,"code":"#(apply str (second\n(reduce (fn [[n r] [v s]] \n          (if (< n v) [n r] [(- n v) (conj r s)])\n        ) \n        [% []]\n        (apply concat \n            (for [\n      i (range 4)\n      j (range 4)\n      :let \n      [\n        m (Math/pow 10 (- 2 i))\n        n (nth [10 9 5 4] j)\n        k (* m n)\n        p (nth [\"MCDC\" \"CXLX\" \"XIVI\" \"I   \"]  i)\n        r (nth p j)\n        s (if (even? j) \"\" (nth p (dec j)) )\n        t (str r s)\n      ]\n     ]\n  (repeat 3 [k t])\n  )   \n        )\n)))","user":"5281a445e4b0757a1b17143a"},{"code":"(fn [i]\n  (let [roman (rseq (sorted-map 1000 \"M\" 900 \"CM\"\n    500 \"D\" 400 \"CD\" 100 \"C\" 90 \"XC\" 50 \"L\"\n    40 \"XL\" 10 \"X\" 9 \"IX\" 5 \"V\" 4 \"IV\" 1 \"I\"))]\n    (loop [i i s \"\"]\n      (if (zero? i)\n        s\n        (let [[v sr]\n          (first (filter (fn [[k v]] (<= k i)) roman))]\n          (recur (- i v) (str s sr)))))))","problem":104,"user":"4ebc08a8535dfed6da9c6d7c"},{"problem":104,"code":"(fn write-roman-numerals [n]\n  (letfn [(num->digits [base num]\n              (loop [n num res []]\n                (if (zero? n)\n                  res\n                  (recur (long (/ n base)) (cons (mod n base) res)))))\n          (quot-mod [base n]\n            (list (quot n base) (mod n base)))\n          (normalize [s] \n            (if (>= (count s) 4) \n              s\n              (recur (cons '(0 0 0 0) s))))\n          (convert [rn d]\n            (flatten (map repeat rn d)))]\n    (apply str (flatten \n                (map convert \n                  (normalize \n                    (map (fn [[a b c]] (cons a (cons b (quot-mod 4 c))))\n                      (map (fn [[a b]] (cons a (quot-mod 5 b))) (map (partial quot-mod 9) (num->digits 10 n)))))\n                  [[\"U\" \"U\" \"U\" \"M\"] [\"CM\" \"D\" \"CD\" \"C\"] [\"XC\" \"L\" \"XL\" \"X\"] [\"IX\" \"V\" \"IV\" \"I\"]])))))","user":"52e657e4e4b09f7907dd1472"},{"problem":104,"code":"(fn [integer]\n  (let [roman-numeral-parts [[\"M\" 1000], [\"CM\" 900], [\"D\" 500], [\"C\" 100], [\"XC\" 90], [\"L\" 50], [\"XL\" 40], [\"X\" 10], [\"IX\" 9], [\"V\" 5], [\"IV\" 4], [\"I\" 1]]]\n    (loop [remainder integer\n           result nil]\n      (if (zero? remainder)\n        result\n        (let [[numerals decimal-value] (first (filter (fn [[_ value]] (<= value remainder))\n                                                      roman-numeral-parts))]\n          (recur (- remainder decimal-value) (str result numerals)))))))","user":"54cc26c1e4b057c6fda3a28a"},{"code":"(fn [arabic]\n   (let [number-vec ((fn [num]\n\t\t\t\t\t\t\t\t\t\t   (loop [result [] div-num num]\n\t\t\t\t\t\t\t\t\t\t     (if (= 0 div-num)\n\t\t\t\t\t\t\t\t\t\t       result\n\t\t\t\t\t\t\t\t\t\t       (recur (conj result (mod div-num 10)) (int (/ div-num 10)))\n\t\t\t\t\t\t\t\t\t\t     )\n\t\t\t\t\t\t\t\t\t\t     )\n\t\t\t\t\t\t\t\t\t\t   ) arabic)]\n     (loop [result \"\" elements number-vec i 0]\n       (if elements\n         (cond \n           (= i 0) (cond\n                     (= 1 (first elements)) (recur (str \"I\" result) (next elements) (inc i))\n                     (= 2 (first elements)) (recur (str \"II\" result) (next elements) (inc i))\n                     (= 3 (first elements)) (recur (str \"III\" result) (next elements) (inc i))\n                     (= 4 (first elements)) (recur (str \"IV\" result) (next elements) (inc i))\n                     (= 5 (first elements)) (recur (str \"V\" result) (next elements) (inc i))\n                     (= 6 (first elements)) (recur (str \"VI\" result) (next elements) (inc i))\n                     (= 7 (first elements)) (recur (str \"VII\" result) (next elements) (inc i))\n                     (= 8 (first elements)) (recur (str \"VIII\" result) (next elements) (inc i))\n                     (= 9 (first elements)) (recur (str \"IX\" result) (next elements) (inc i))\n                     (= 0 (first elements)) (recur result (next elements) (inc i))\n                     )\n           (= i 1) (cond\n                     (= 1 (first elements)) (recur (str \"X\" result) (next elements) (inc i))\n                     (= 2 (first elements)) (recur (str \"XX\" result) (next elements) (inc i))\n                     (= 3 (first elements)) (recur (str \"XXX\" result) (next elements) (inc i))\n                     (= 4 (first elements)) (recur (str \"XL\" result) (next elements) (inc i))\n                     (= 5 (first elements)) (recur (str \"L\" result) (next elements) (inc i))\n                     (= 6 (first elements)) (recur (str \"LX\" result) (next elements) (inc i))\n                     (= 7 (first elements)) (recur (str \"LXX\" result) (next elements) (inc i))\n                     (= 8 (first elements)) (recur (str \"LXXX\" result) (next elements) (inc i))\n                     (= 9 (first elements)) (recur (str \"XC\" result) (next elements) (inc i))\n                     (= 0 (first elements)) (recur result (next elements) (inc i))\n                     )\n           (= i 2) (cond\n                     (= 1 (first elements)) (recur (str \"C\" result) (next elements) (inc i))\n                     (= 2 (first elements)) (recur (str \"CC\" result) (next elements) (inc i))\n                     (= 3 (first elements)) (recur (str \"CCC\" result) (next elements) (inc i))\n                     (= 4 (first elements)) (recur (str \"CD\" result) (next elements) (inc i))\n                     (= 5 (first elements)) (recur (str \"D\" result) (next elements) (inc i))\n                     (= 6 (first elements)) (recur (str \"DC\" result) (next elements) (inc i))\n                     (= 7 (first elements)) (recur (str \"DCC\" result) (next elements) (inc i))\n                     (= 8 (first elements)) (recur (str \"DCCC\" result) (next elements) (inc i))\n                     (= 9 (first elements)) (recur (str \"CM\" result) (next elements) (inc i))\n                     (= 0 (first elements)) (recur result (next elements) (inc i))\n                     )\n           (= i 3) (cond\n                     (= 1 (first elements)) (recur (str \"M\" result) (next elements) (inc i))\n                     (= 2 (first elements)) (recur (str \"MM\" result) (next elements) (inc i))\n                     (= 3 (first elements)) (recur (str \"MMM\" result) (next elements) (inc i))\n                     (= 4 (first elements)) (recur (str \"MMMM\" result) (next elements) (inc i))                     \n                     )\n           )\n         \n         result\n         )\n       \n       )\n     )   \n   )","problem":104,"user":"5106dc1be4b01150e115ebf0"},{"problem":104,"code":"(fn n2r [n]\n  (let [a1 [\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"]\n        a2 [\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"]\n        a3 [\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"]\n        a4 [\"\", \"M\", \"MM\", \"MMM\"]]\n    (str (a4 (rem (quot n 1000) 10))\n         (a3 (rem (quot n 100) 10))\n         (a2 (rem (quot n 10) 10))\n         (a1 (rem n 10)))))","user":"5e2549c8e4b05b4b0151615f"},{"problem":104,"code":"(fn write-roman [n]\n  (if (zero? n) \"\"\n    (let [[roman value]\n          (first\n            (drop-while \n              (fn [[_ value]]\n                (> value n))\n              [[\"M\" 1000] [\"CM\" 900] [\"D\" 500] [\"CD\" 400]\n               [\"C\" 100]  [\"XC\" 90]  [\"L\" 50]  [\"XL\" 40]\n               [\"X\" 10]   [\"IX\" 9]   [\"V\" 5]   [\"IV\" 4]\n               [\"I\" 1]]))]\n      (str roman (write-roman (- n value))))))","user":"562cd94ee4b0a45d2ff83015"},{"problem":104,"code":"(fn [n]\n  (letfn [(digs [n]\n            (let [d1 (quot n 1000)\n                  d2 (quot (rem n 1000) 100)\n                  d3 (quot (rem n 100) 10)\n                  d4 (rem n 10)]\n              [d1 d2 d3 d4]))\n\n          (disp [d [i v x]]\n            (cond\n              (= d 9) [i x]\n              (= d 4) [i v]\n              (> d 4) (concat [v] (repeat (- d 5) i))\n              :else   (repeat d i)))]\n\n    (apply str\n      (mapcat disp\n              (digs n)\n              [[\\M \\_ \\_]\n               [\\C \\D \\M]\n               [\\X \\L \\C]\n               [\\I \\V \\X]]))))","user":"4ec1b090535dfed6da9c6db5"},{"problem":104,"code":"(fn [n]                                       \n  (let [m {1 [\"I\" \"II\" \"III\" \"IV\" \"V\" \"VI\" \"VII\" \"VIII\" \"IX\"]\n           10 [\"X\" \"XX\" \"XXX\" \"XL\" \"L\" \"LX\" \"LXX\" \"LXXX\" \"XC\"]\n           100 [\"C\" \"CC\" \"CCC\" \"CD\" \"D\" \"DC\" \"DCC\" \"DCCC\" \"CM\"]\n           1000 [\"M\" \"MM\" \"MMM\" \"MMMM\"]}]\n    (letfn [(expand [n p]\n              (get-in m [p (dec (quot (mod n (* p 10)) p))]))]     \n      (str \n        (expand n 1000)\n        (expand n 100)\n        (expand n 10)\n        (expand n 1)))))","user":"529dfc6de4b04e0c58e87b8a"},{"code":"(fn [n]\n  (let [decs [1000,900,500,400,100,90,50,40,10,9,5,4,1]\n        roms [\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"]]\n    (loop [num n acc [] d decs r roms]\n      (if (not d)\n        (apply str acc)\n        (if (< num (first d))\n          (recur num acc (next d) (next r))\n          (recur (- num (first d)) (conj acc (first r)) d r))))))","problem":104,"user":"4e8768f6535dceadca469850"},{"problem":104,"code":"(fn into-roman [n]\n  (let [match (sorted-map 1000 \"M\" 900 \"CM\" 500 \"D\" 400 \"CD\" 100 \"C\"\n               90 \"XC\" 50 \"L\" 40 \"XL\" 10 \"X\" 9 \"IX\" 5 \"V\" 4 \"IV\" 1 \"I\")]\n    (loop [k (reverse (keys match))\n           fk (first k)\n           n n\n           acc []]\n      (cond\n        (empty? k) (apply str acc)\n        (>= n fk) (recur k fk (- n fk) (conj acc (match fk)))\n        :default (recur (rest k) (fnext k) n acc)))))","user":"587ee260e4b052da650a6353"},{"code":"(fn [n]\n  (let [t [[\"\"  \"I\" \"II\" \"III\" \"IV\" \"V\" \"VI\" \"VII\" \"VIII\" \"IX\"]\n           [\"\"  \"X\" \"XX\" \"XXX\" \"XL\" \"L\" \"LX\" \"LXX\" \"LXXX\" \"XC\"]\n           [\"\"  \"C\" \"CC\" \"CCC\" \"CD\" \"D\" \"DC\" \"DCC\" \"DCCC\" \"CM\"]\n           [\"\"  \"M\" \"MM\" \"MMM\" \"MMMM\"]]]\n    (str (get-in t [3 (int (/ n 1000))])\n         (get-in t [2 (int (/ (mod n 1000) 100))])\n         (get-in t [1 (int (/ (mod n 100) 10))])\n         (get-in t [0 (mod n 10)]))))","problem":104,"user":"4e50b67b535dc968683fc4ed"},{"problem":104,"code":"(fn roman-numeral [n]\n  (if (>= n 4000)\n    \"\"\n    (let [roman (fn [u1 u2 u3 n]\n                  (cond (= n 0) \"\"\n                        (= n 1) u1\n                        (= n 2) (str u1 u1)\n                        (= n 3) (str u1 u1 u1)\n                        (= n 4) (str u1 u2)\n                        (= n 5) u2\n                        (= n 6) (str u2 u1)\n                        (= n 7) (str u2 u1 u1)\n                        (= n 8) (str u2 u1 u1 u1)\n                        (= n 9) (str u1 u3)))\n          digits (fn [n]\n                   (loop [n n\n                          res []]\n                     (if (= n 0)\n                       res\n                       (recur (int (/ n 10)) (conj res (mod n 10))))))]\n      (loop [n (digits n)\n             convert [(partial roman \"I\" \"V\" \"X\")\n                      (partial roman \"X\" \"L\" \"C\")\n                      (partial roman \"C\" \"D\" \"M\")\n                      (partial roman \"M\" \"V\" \"X\")]\n             res \"\"]\n        (if (seq n)\n          (recur (rest n)\n                 (rest convert)\n                 (str ((first convert) (first n)) res))\n          res)))))","user":"5a6b9b95e4b0512ff01cda40"},{"code":"(fn toroman\r\n  [n]\r\n\t(if (zero? n)\r\n\t\t\"\"\r\n\t\t(let [table (sorted-map-by #(- %2 %1) 1000 \"M\", 900 \"CM\", 500 \"D\", 400 \"CD\", 100 \"C\", 90 \"XC\",\r\n\t\t\t\t\t\t\t\t 50 \"L\", 40 \"XL\", 10 \"X\", 9 \"IX\", 5 \"V\", 4 \"IV\", 1 \"I\")]\r\n\t\t\t(let [pick (first (drop-while #(> % n) (keys table)))]\r\n\t\t\t\t(str (table pick) (toroman (- n pick)))))))","problem":104,"user":"4e8a0c82535d3e98b802328d"},{"problem":104,"code":"(fn to-roman-number [number]\n  (let [parse-number (fn convert-base [n base]\n                       (if (< n 10)\n                         [(* n base)]\n                         (conj (convert-base (quot n 10) (* 10 base)) (* (mod n 10) base))))\n        number-to-roman (zipmap\n                         [1 2 3 4 5 6 7 8 9\n                          10 20 30 40 50 60 70 80 90\n                          100 200 300 400 500 600 700 800 900\n                          1000 2000 3000]\n                         [\"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"\n                          \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"\n                          \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"\n                          \"M\", \"MM\", \"MMM\"])]\n\n    (apply str (map number-to-roman (parse-number number 1)))))","user":"5fa74b82e4b0fa27300f3dda"},{"problem":104,"code":"(fn write-roman [n]\n  (letfn [(c [n1 n2] (< 0 (quot n1 n2)))\n          (r [n1 n2 s] (str s (write-roman (- n1 n2))))]\n  (cond (c n 1000) (r n 1000 \"M\")\n        (c n 900) (r n 900 \"CM\")\n        (c n 500) (r n 500 \"D\")\n        (c n 400) (r n 400 \"CD\")\n        (c n 100) (r n 100 \"C\")\n        (c n 90) (r n 90 \"XC\")\n        (c n 50) (r n 50 \"L\")\n        (c n 40) (r n 40 \"XL\")\n        (c n 10) (r n 10 \"X\")\n        (c n 9) (r n 9 \"IX\")\n        (c n 5) (r n 5 \"V\")\n        (c n 4) (r n 4 \"IV\")\n        (c n 1) (r n 1 \"I\")\n        true nil)))","user":"53973e7be4b0b51d73faaee6"},{"problem":104,"code":"(fn ! [l] \n    (if (zero? l) \"\"\n      (if (> l 1000) \n        (str (apply str (repeat (quot l 1000) \"M\")) (! (rem l 1000)))\n        (let [nds (count (str l))\n              n5 (nth \" VLD\" nds)\n              n1 (nth \" IXC\" nds)\n              n10 (nth \" XCM\" nds)\n              tens (reduce * (take (dec nds) (repeat 10 10)))\n              fd (quot l tens)\n              limbo (cond   \n                     (< fd 4) (apply str (repeat fd n1))\n                     (= fd 4) (str n1 n5)\n                     (= fd 9) (str n1 n10)\n                     :else (str n5 (apply str (repeat (- fd 5) n1)))\n                     )\n              ]\n          (str limbo (! (rem l tens)))\n          )))\n    )","user":"52faec2ee4b047fd55837004"},{"problem":104,"code":"(fn [nr]\n  (let [re #(apply str (repeat %1 %2))\n        bt (fn [v] (take-while #(<= % v) (iterate #(* 10 %) 1)))\n        tk (fn [n v] (reduce #(- % (mod % %2)) n (bt v)))\n        pa #(/ (mod (tk nr %) (* 10 %)) %)\n        co #(cond\n             (< %1 4) (re %1 %2)\n             (= %1 4) (str %2 %3)\n             (= %1 5) %3\n             (= %1 9) (str %2 %4)\n             :else (str %3 (re (- %1 5) %2)))\n        cb #(apply co (cons (pa %1) %2 ))]\n    (apply str (reverse (map cb (bt 1000) (partition 3 2 [\"I\" \"V\" \"X\"\"L\" \"C\" \"D\" \"M\" \"\" \"\"]))))))","user":"56b6e354e4b0982f16b37e41"},{"problem":104,"code":"(fn int->roms [original]\n  (let [romvals (sorted-map-by >  1000 \"M\" 900 \"CM\" 500 \"D\" 400 \"CD\"\n                               100 \"C\" 90 \"XC\" 50 \"L\" 40 \"XL\"\n                               10 \"X\" 9 \"IX\" 5 \"V\" 4 \"IV\" 1 \"I\")\n        rom-builder (fn [bag [itoken strtoken]]\n                      (let [bite (quot (:remainder bag) itoken)\n                            remainder (mod (:remainder bag) itoken)]\n                        (if (> bite 0)\n                           {:roms (apply str (:roms bag) (repeat bite strtoken))\n                            :remainder remainder}\n                           bag)))]\n  (:roms (reduce rom-builder {:roms \"\" :remainder original} romvals ))))","user":"53bf0913e4b0c98a41f5cc99"},{"problem":104,"code":"(fn [nm] \n  (letfn [\n    (num->ln [c] (map #(Character/getNumericValue %) (-> c str vec )))\n    (numerigi [ln] (map-indexed (fn [idx itm] [(- (count ln) idx) itm]) ln ))\n    (vec->str [[x y]] (cond\n                          (= x 4) (apply str (repeat y \"M\"))\n                          (= x 3) (sysR \"C\" \"D\" \"M\" y)\n                          (= x 2) (sysR \"X\" \"L\" \"C\" y)\n                          (= x 1) (sysR \"I\" \"V\" \"X\" y)))\n    (sysR [n1 n5 n10 c] (cond \n                          (= c 0) \"\"\n                          (< c 4) (apply str (repeat c n1))\n                          (= c 4) (str n1 n5)\n                          (< c 9) (str n5 (sysR n1 n5 n10 (- c 5)))\n                          (= c 9) (str n1 n10)\n                          ))]\n  (apply str (mapcat vec->str (numerigi (num->ln nm))))))","user":"5576e78de4b05c286339e075"},{"code":"#(let [r {1000 \"M\"\n          900  \"CM\" \n          500  \"D\" \n          400  \"CD\"\n          100  \"C\"\n          90   \"XC\"\n          50   \"L\"\n          40   \"XL\"\n          10   \"X\"\n          9    \"IX\"\n          5    \"V\"\n          4    \"IV\"\n          1    \"I\"\n          0    \"\"}]\n   ((fn f [m [k & s] a]\n      (if s \n        (if (>= m k) \n          (f (- m k) (cons k s) (str a (r k)))\n          (f m s a))\n        a))\n    % (sort > (keys r)) \"\"))","problem":104,"user":"4ef49c2c535dced4c769f238"},{"problem":104,"code":"(fn [n]\n  (let [v [[1000 \"M\"] [900 \"CM\"]\n           [500 \"D\"] [400 \"CD\"]\n           [100 \"C\"] [90 \"XC\"]\n           [50 \"L\"] [40 \"XL\"]\n           [10 \"X\"] [9 \"IX\"]\n           [5 \"V\"] [4 \"IV\"]\n           [1 \"I\"]]]\n    (loop [o [] n n]\n      (if (= 0 n)\n        (apply str o)\n        (let [[x s] (first (filter #(>= n (first %)) v))]\n          (recur (conj o s) (- n x)))))))","user":"54ca9ca8e4b057c6fda3a265"},{"code":"(fn [n]\n  (apply str\n    (first\n      (reduce\n        (fn [[s n] v]\n          (if (>= n v)\n            (recur\n              [(conj s\n                ({1000 \"M\" 900 \"CM\" 500 \"D\" 400 \"CD\" 100 \"C\" 90 \"XC\" 50 \"L\" 40 \"XL\" 10 \"X\" 9 \"IX\" 5 \"V\" 4 \"IV\" 1 \"I\"} v))\n               (- n v)] v)\n            [s n]))\n        [[] n]\n        [1000 900 500 400 100 90 50 40 10 9 5 4 1]))))","problem":104,"user":"4fb2101ce4b081705acca284"},{"code":"(fn [d]\n  (let [romans\n         [[1000 \"M\"  ]\n          [ 900 \"CM\" ]\n          [ 500 \"D\"  ]\n          [ 400 \"CD\" ]\n          [ 100 \"C\"  ]\n          [  90 \"XC\" ]\n          [  50 \"L\"  ]\n          [  40 \"XL\" ]\n          [  10 \"X\"  ]\n          [   9 \"IX\" ]\n          [   5 \"V\"  ]\n          [   4 \"IV\" ]\n          [   1 \"I\"  ]] ]\n    (letfn [\n      (romanize [d [[x y] & rs :as romans]]\n        (if (>= 0 d) \"\"\n          (if (> x d) (romanize d rs)\n            (concat y\n              (romanize (- d x) romans)))))]\n  (apply str (romanize d romans)))))","problem":104,"user":"4f569218e4b0a7574ea71826"},{"code":"(fn to-roman [n]\n  (let [values (partition 2 '(1000 \"M\" 900 \"CM\" 500 \"D\" 400 \"CM\" 100 \"C\" 90 \"XC\" 50 \"L\" 40 \"XL\"\n  \t\t\t   10 \"X\" 9 \"IX\" 5 \"V\" 4 \"IV\" 1 \"I\"))]\n    (loop [n n result \"\"]\n      (if (zero? n)\n\tresult\n\t(let [[val letter] (first (filter (fn [[v l]] (>= (- n v) 0)) values))]\n\t  (recur (- n val) (str result letter)))))))","problem":104,"user":"4e513ecf535dc968683fc4f6"},{"problem":104,"code":"(fn roman-number\n  [n]\n  (let [numerals {\"M\" 1000 \"CM\" 900 \"D\" 500 \"CD\" 400 \"C\" 100 \"XC\" 90\n                  \"L\" 50 \"XL\" 40 \"X\" 10 \"IX\" 9 \"V\" 5 \"IV\" 4 \"I\" 1}\n        max-roman (fn [n]\n                    (let [[roman rn] (->> (filter #(<= (val %) n) numerals)\n                                          (apply max-key val))]\n                      [(apply str (repeat (quot n rn) roman))\n                       (mod n rn)]))]\n    (loop [result \"\"\n           decimal n]\n      (if (zero? decimal)\n        result\n        (let [[roman rem] (max-roman decimal)]\n          (recur (apply str result roman)\n                 rem))))))","user":"4e586949535d8a8b8723a292"},{"code":"(fn r [n]\n    (let\n        [digs\n         {1 \"I\", 4 \"IV\", 100 \"C\", 900 \"CM\", 5 \"V\", 40 \"XL\", 1000 \"M\", 9 \"IX\", 10 \"X\", 400 \"CD\", 50 \"L\", 500 \"D\", 90 \"XC\"}\n         nearest (fn [n]\n                   (sort-by first\n                            (filter (comp not neg? first)\n                                    (map (fn [[k v]] [(- n k) k v n]) digs ))))]\n      (cond\n       (= 0 n ) \"\"\n       (digs n) (digs n)\n       :else\n       (let [[difference i symb] (first  (nearest n))]\n         (str symb (r (- n i)))))))","problem":104,"user":"4e6f578c535d5021c1a8961b"},{"code":"(fn [num]\n  (let [lets [\"M\" \"D\" \"C\" \"L\" \"X\" \"V\" \"I\"]\n        nums [1000 500 100 50 10 5 1]\n        ten-nums (take-nth 2 nums)\n        ten-lets (take-nth 2 lets)\n        xnums (map - ten-nums (rest ten-nums))\n        xlets (map str (rest ten-lets) ten-lets)\n        vlets (map (partial apply str) (map reverse (partition 2 (rest lets))))\n        vnums (map (partial apply -) (partition 2 (rest nums)))\n        slets (interleave xlets vlets)\n        snums (interleave xnums vnums)\n        interleave-subs (fn [o s] (concat (interleave (butlast o) s) [(last o)]))\n        all-lets (interleave-subs lets slets)\n        all-nums (interleave-subs nums snums)]\n    (loop [n num\n           als all-lets\n           subs all-nums\n           res \"\"]\n      (let [curr (first subs)]\n        (if curr\n          (if (>= n curr)\n            (recur (- n curr) als subs (str res (first als)))\n            (recur n (rest als) (rest subs) res))\n          res)))))","problem":104,"user":"4f437751e4b0d7d3c9f3fd20"},{"code":"(fn _\n    ([n] (_ (reverse\n              (map read-string\n                   (map str\n                        (str n))))\n            \"IVXLCDM..\")) \n    ([[d & e] [r s & t]]\n     (if d\n       (apply str\n              (_ e t)\n              (cond\n                (< d 4) (repeat d r)\n                (= d 4) [r s]\n                (< d 9) (cons s (repeat (- d 5) r))\n                1 [r (first t)]))\n       )))","problem":104,"user":"4dc537fd535d8a4b2fd74282"},{"code":"(fn\r\n  [n]\r\n  (let [roman-digits [[\"\" \"I\" \"II\" \"III\" \"IV\" \"V\" \"VI\" \"VII\" \"VIII\" \"IX\"]\r\n                      [\"\" \"X\" \"XX\" \"XXX\" \"XL\" \"L\" \"LX\" \"LXX\" \"LXXX\" \"XC\"]\r\n                      [\"\" \"C\" \"CC\" \"CCC\" \"CD\" \"D\" \"DC\" \"DCC\" \"DCCC\" \"CM\"]\r\n                      [\"\" \"M\" \"MM\" \"MMM\"]]]\r\n    (loop [n n cnt 0 result (StringBuilder.)]\r\n      (if (<= n 0)\r\n        (.toString result)\r\n        (do\r\n          (recur (int (/ n 10))\r\n               (inc cnt)\r\n               (.insert result 0 ((roman-digits cnt) (int (mod n 10))))))))\r\n    ))","problem":104,"user":"4db53f87535d87e67b28fe08"},{"problem":104,"code":"(fn [num]\n  (loop [current []\n         num     num]\n    (if (<= num 0)\n      (apply str current)\n      (cond\n        (>= num 1000) (recur (conj current \"M\") (- num 1000))\n        (>= num 900) (recur (conj current \"CM\") (- num 900))\n        (>= num 500) (recur (conj current \"D\") (- num 500))\n        (>= num 100) (recur (conj current \"C\") (- num 100))\n        (>= num 90) (recur (conj current \"XC\") (- num 90))\n        (>= num 40) (recur (conj current \"XL\") (- num 40))\n        (>= num 10) (recur (conj current \"X\") (- num 10))\n        (>= num 9) (recur (conj current \"IX\") (- num 9))\n        (>= num 5) (recur (conj current \"V\") (- num 5))\n        (>= num 4) (recur (conj current \"IV\") (- num 5))\n        (>= num 1) (recur (conj current \"I\") (- num 1))))))","user":"4ea8570f535d7eef308072f8"},{"problem":104,"code":"(fn [n]\n  (let [f  (fn [n i v x]\n             (cond\n               (= 9  n) (str i x)\n               (<= 5 n) (apply str v (repeat (- n 5) i))\n               (= 4  n) (str i v)\n               :else (apply str (repeat n i))))\n        n1 (apply str (repeat (quot n 1000) \"M\"))\n        n2 (mod (quot n 100) 10)\n        n2 (f n2 \"C\" \"D\" \"M\")\n        n3 (mod (quot n 10) 10)\n        n3 (f n3 \"X\" \"L\" \"C\")\n        n4 (mod n 10)\n        n4 (f n4 \"I\" \"V\" \"X\")]\n    (str n1 n2 n3 n4)))","user":"557c6ca6e4b05c286339e0c4"},{"problem":104,"code":"(fn rom [x]\n   (let [m {1 \"I\"\n            5 \"V\"\n            4 \"IV\"\n            9 \"IX\"\n            10 \"X\"\n            40 \"XL\"\n            50 \"L\"\n            90 \"XC\"\n            100 \"C\"\n            400 \"CD\"\n            500 \"D\"\n            900 \"CM\"\n            1000 \"M\"}\n         closest-n (fn [n] (-> (split-with #(<= % n) (sort (keys m))) first last))\n         closest-n-repeated (juxt (fn [x] (quot x (closest-n x))) closest-n (fn [x] (rem x (closest-n x))))\n         romanize (fn [[times n]] (apply str (repeat times (m n))))]\n                                        ;(closest-n-repeated 50)\n     (->> (closest-n-repeated x)\n          (iterate (fn [[_ _ next :as pair]]  (if (pos? next) (closest-n-repeated next) [-1 -1 -1])))\n          (take-while (fn [[_ _ next]] (>= next 0)))\n          (map butlast)\n          (map romanize)\n          (apply str))))","user":"585dbe41e4b0f14aab7c879f"},{"code":"(fn roman[n]\n  (let [numb { 1 \"I\" 4 \"IV\" 5 \"V\" 9 \"IX\" 10 \"X\" \n                       40 \"XL\" 50 \"L\" 90 \"XC\" 100 \"C\" \n                       400 \"CD\" 500 \"D\" 900 \"CM\" 1000 \"M\"}]\n    (loop [r n \n        c \"\"]\n      (if (<= r 0)\n        c\n        (let [ r_n(reduce #(if (and (< %1 %2) (<= %2 r)) %2 %1) 1 (keys numb))\n \t       r_c (numb r_n)\n                c_c (count c)]\n            (recur (- r r_n)  (str c r_c))\n        )\n      )\n    )\n  )\n)","problem":104,"user":"4e9de526535dbda64a6f6b8e"},{"problem":104,"code":"(letfn [(f [a b c d x] (nth [\"\" a (str a a) (str a a a) (str a b) b (str b a) (str b a a) (str b a a a) (str a c)]\n                            (mod (quot x d) 10)))]\n  (fn [x] (str (f \"M\" \"A\" \"B\" 1000 x) (f \"C\" \"D\" \"M\" 100 x) (f \"X\" \"L\" \"C\" 10 x) (f \"I\" \"V\" \"X\" 1 x))))","user":"584dadebe4b0b7285a6f4e44"},{"code":"(fn to-roman [n]\n  (letfn [(to-map [vals] (zipmap (range (inc (count vals))) vals))\n          (to-digits [num] (->> (str num)\n                                (partition-all 1)\n                                (do (println))\n                                (map #(Integer/valueOf (apply str %)))))]\n    (let [units (to-map [\"\"  \"I\" \"II\" \"III\" \"IV\" \"V\" \"VI\" \"VII\" \"VIII\" \"IX\"])\n          tens (to-map [\"\" \"X\" \"XX\" \"XXX\" \"XL\" \"L\" \"LX\" \"LXX\" \"LXXX\" \"XC\"])\n          hundreds (to-map [\"\" \"C\" \"CC\" \"CCC\" \"CD\" \"D\" \"DC\" \"DCC\" \"DCCC\" \"CM\"])\n          thousands (to-map (map #(apply str (repeat % \"M\")) (range 10)))]\n\n      (apply str (reverse (map (fn [[m i]] (m i)) (map vector [units tens hundreds thousands] (reverse (to-digits n))))))\n    )\n  ))","problem":104,"user":"52319066e4b0e2e8de81d1e9"},{"code":"(fn pr [n]\n    (let [numerals\n          {1 \"I\"\n           4 \"IV\"\n           5 \"V\"\n           9 \"IX\"\n           10 \"X\"\n           40 \"XL\"\n           50 \"L\"\n           90 \"XC\"\n           100 \"C\"\n           400 \"CD\"\n           500 \"D\"\n         900 \"CM\"\n         1000 \"M\"}\n          sorted-keys (sort (keys numerals))]\n      (if (= 0 n) \n        \"\"\n        (let [next-key (last (filter #(<= % n) sorted-keys))]\n          (str (get numerals next-key) (pr (- n next-key)))))))","problem":104,"user":"4f4274f2e4b0d7d3c9f3fd00"},{"code":"(fn [x]\r\n  (let [m (sorted-map-by >\r\n                         1000 \"M\"\r\n                         900 \"CM\"\r\n                         500 \"D\"\r\n                         400 \"CD\"\r\n                         100 \"C\"\r\n                         90 \"XC\"\r\n                         50 \"L\"\r\n                         40 \"XL\"\r\n                         10 \"X\"\r\n                         9 \"IX\"\r\n                         5 \"V\"\r\n                         4 \"IV\"\r\n                         1 \"I\")]\r\n    (loop [acc []\r\n           n x]\r\n      (if (zero? n)\r\n        (reduce str acc)\r\n        (let [h (first (filter identity (map #(if (<= (first %) %2) %) m (repeat n))))]\r\n          (recur (conj acc (second h)) (- n (first h))))))))","problem":104,"user":"4ff9d4e5e4b0678c553fc3b0"},{"code":"(fn rom [x]\n  (if (= x 0) \"\"\n  (if (>= x 1000) (str \"M\" (rom (- x 1000)))\n  (if (>= x 900) (str \"C\" (rom (+ x 100)))\n  (if (>= x 500) (str \"D\" (rom (- x 500)))\n  (if (>= x 400) (str \"C\" (rom (+ x 100)))\n  (if (>= x 100) (str \"C\" (rom (- x 100)))\n  (if (>= x 90) (str \"X\" (rom (+ x 10)))\n  (if (>= x 50) (str \"L\" (rom (- x 50)))\n  (if (>= x 40) (str \"X\" (rom (+ x 10)))\n  (if (>= x 10) (str \"X\" (rom (- x 10)))\n  (if (>= x 9) (str \"I\" (rom (+ x 1)))\n  (if (>= x 5) (str \"V\" (rom (- x 5)))\n  (if (>= x 4) (str \"I\" (rom (+ x 1)))\n  (if (>= x 1) (str \"I\" (rom (- x 1)))\n)))))))))))))))","problem":104,"user":"4f84400de4b033992c121c2e"},{"code":"(let [m [[1 \"I\"]\n         [4 \"IV\"]\n         [5 \"V\"]\n         [9 \"IX\"]\n         [10 \"X\"]\n         [40 \"XL\"]\n         [50 \"L\"]\n         [90 \"XC\"]\n         [100 \"C\"]\n         [500 \"D\"]\n         [900 \"CM\"]\n         [1000 \"M\"]]]\n  (fn f [n]\n    (if (= 0 n)\n      \"\"\n      (let [[x s] (last (take-while #(<= (first %) n) m))]\n        (str s (f (- n x)))))))","problem":104,"user":"50a83315e4b054305ba5a830"},{"problem":104,"code":"(fn to-r\n  [i]\n  (let [values {1 \"I\" 4 \"IV\" 5 \"V\" 9 \"IX\" 10 \"X\" 40 \"XL\" 50 \"L\"  90 \"XC\" 100 \"C\" 400 \"C\" 500 \"D\"  900 \"CM\" 1000 \"M\"}\n        ks (reverse (sort (keys values)))]\n    (if (= 1 i)\n      (values 1)\n      (loop [[x s k] [i \"\" ks]]\n          (if (or (empty? k) (<= x 1))\n            s\n            (let [d (first k)\n                  q (quot x d)]\n              (recur (if (> q 0)\n                        [(apply - x (repeat q (first k)))  (str s (apply str (repeat q (values d)))) (rest k)]\n                        [x s (rest k)]))))))))","user":"58983e3fe4b00487982d52ce"},{"code":"(fn [n]\n    (let [m3 (mod n  1000)\n          m2 (mod m3  100)\n          m1 (mod m2   10)]\n      (str (let [q (quot n 1000)]\n             (cond (= 1 q) \"M\"\n                   (= 2 q) \"MM\"\n                   (= 3 q) \"MMM\"\n                   :else \"\"))\n           (let [q (quot m3 100)]\n             (cond (= 1 q) \"C\"\n                   (= 2 q) \"CC\"\n                   (= 3 q) \"CCC\"\n                   (= 4 q) \"CD\"\n                   (= 5 q) \"D\"\n                   (= 6 q) \"DC\"\n                   (= 7 q) \"DCC\"\n                   (= 8 q) \"DCCC\"\n                   (= 9 q) \"CM\"\n                   :else \"\"))\n           (let [q (quot m2 10)]\n             (cond (= 1 q) \"X\"\n                   (= 2 q) \"XX\"\n                   (= 3 q) \"XXX\"\n                   (= 4 q) \"XL\"\n                   (= 5 q) \"L\"\n                   (= 6 q) \"LX\"\n                   (= 7 q) \"LXX\"\n                   (= 8 q) \"LXXX\"\n                   (= 9 q) \"XC\"\n                   :else \"\"))\n           (let [q m1]\n             (cond (= 1 q) \"I\"\n                   (= 2 q) \"II\"\n                   (= 3 q) \"III\"\n                   (= 4 q) \"IV\"\n                   (= 5 q) \"V\"\n                   (= 6 q) \"VI\"\n                   (= 7 q) \"VII\"\n                   (= 8 q) \"VIII\"\n                   (= 9 q) \"IX\"\n                   :else \"\")))))","problem":104,"user":"4f5cc3b8e4b0030a34fb2b2b"},{"problem":104,"code":"(fn roman [n]\n  (apply str\n  (condp <= n\n    1000 (cons \\M (roman (- n 1000)))\n    900 (cons \\C (cons \\M (roman (- n 900))))\n    500 (cons \\D (roman (- n 500)))\n    400 (cons \\C (cons \\D (roman (- n 400))))\n    100 (cons \\C (roman (- n 100)))\n    90 (cons \\X (cons \\C (roman (- n 90))))\n    50 (cons \\L (roman (- n 50)))\n    40 (cons \\X (cons \\L (roman (- n 40))))\n    10 (cons \\X (roman (- n 10)))\n    9 (cons \\I (cons \\X (roman (- n 9))))\n    5 (cons \\V (roman (- n 5)))\n    4 (cons \\I (cons \\V (roman (- n 4))))\n    1 (cons \\I (roman (- n 1)))\n    '()\n    )))","user":"541ef7e2e4b01498b1a71a92"},{"problem":104,"code":"(fn [n]\n  (let [roman-digit\n        (fn dig [n digit]\n          (let [chars {1 \"I\"\n                       5 \"V\"\n                       10 \"X\"\n                       50 \"L\"\n                       100 \"C\"\n                       500 \"D\"\n                       1000 \"M\"}\n                icon (chars digit)\n                half (chars (* 5 digit))\n                next-icon (chars (* 10 digit))\n                n-icon (apply str (repeat n icon))]\n            (if (not next-icon)\n              (apply str (repeat n icon))\n              (cond\n                (< n 4) n-icon\n                (= n 4) (str icon half)\n                (< 4 n 9) (str half (dig (- n 5) digit))\n                (> n 8) (str icon next-icon)\n                :else \"\"))))]\n    (str (roman-digit (quot n 1000) 1000)\n         (roman-digit (quot (rem n 1000) 100) 100)\n         (roman-digit (quot (rem n 100) 10) 10)\n         (roman-digit (rem n 10) 1))))","user":"5317d78ee4b08068f379ed63"},{"code":"(fn wr [n]\n    (let [c [ [] [:u] [:u :u] [:u :u :u] [:u :q] [:q] [:q :u] [:q :u :u] [:q :u :u :u] [:u :d]]\n          mm [ {:u \\I :q \\V :d \\X} {:u \\X :q \\L :d \\C} {:u \\C :q \\D :d \\M} {:u \\M :q \\Y :d \\Z}]\n          rec-wr (fn rwr [n mi r]\n                    (if (= 0 n) r\n                        (rwr (quot n 10) (inc mi) (conj r (apply str (map (mm mi) (c (mod n 10))))))))\n          ]\n          (apply str (rec-wr n 0 '()))\n          ))","problem":104,"user":"51f59607e4b0abb92f97f9d5"},{"problem":104,"code":"(fn roman-numeral [n]\n  (let [table [1000 \\M 500 \\D 100 \\C 50 \\L 10 \\X 5 \\V 1 \\I]]\n    (loop [n n ret [] table table]\n      (let [[x0 r0 x1 r1 x2 r2] table]\n        (cond (<= n 0) (apply str ret)\n                \n              (>= n x0)\n              (recur (- n x0) (conj ret r0) table)\n                \n              (or (and (= r0 \\L) (>= n (- x0 x1)))\n                  (and (= r0 \\V) (>= n (- x0 x1))))\n              (recur (- n (- x0 x1)) (conj ret r1 r0) (subvec table 2))\n                \n                \n              (and (not (nil? x2)) \n                   (>= n (- x0 x2)))\n              (recur (- n (- x0 x2)) (conj ret r2 r0) (subvec table 2))\n                \n              :else\n              (recur n ret (subvec table 2)))))))","user":"571c2babe4b07c98581c3b73"},{"code":"(fn t \n  ([n] (t n (map #(into (zipmap (range 1 10) %) {0 \"\"}) \n                    [['I 'II 'III 'IV 'V 'VI 'VII 'VIII 'IX]\n                     ['X 'XX 'XXX 'XL 'L 'LX 'LXX 'LXXX 'XC]\n                     ['C 'CC 'CCC 'CD 'D 'DC 'DCC 'DCCC 'CM]\n                     ['M 'MM 'MMM]])))\n  ([n c] (if (pos? n) (str (t (quot n 10) (next c)) (get (first c) (rem n 10))) \"\")))","problem":104,"user":"51f66e0ee4b06ff1c25c52c3"},{"code":"(fn write-roman [n]\n  (let [s-map (into (sorted-map-by >) {1 \"I\",  4 \"IV\", 5 \"V\", 9 \"IX\", \n                                       10 \"X\", 40 \"XL\", 50 \"L\", 90 \"XC\"\n                                       100 \"C\", 400 \"CD\", 500, \"D\", 900 \"CM\", 1000 \"M\"})]\n    (->> [[] n]\n         (iterate (fn [[str-vect n]]\n                    (when-let [entry (first (filter (fn [[k v]] (<= k n)) s-map))]  ; find largest entry smaller than n\n                      [(conj str-vect (second entry))  ; add matching roman str to string vector\n                       (- n (first entry))])))          ; subtract the numeric value of the entry\n         (take-while identity)\n         last\n         first\n         (apply str))))","problem":104,"user":"50812debe4b01a93d3f38e4c"},{"problem":104,"code":"(fn roman\n  ([n] (roman n \"\"))\n  ([n s]\n   (if (zero? n)\n     s\n     (let [h (condp <= n\n               1000 {\"M\"  1000}\n               900  {\"CM\" 900}\n               500  {\"D\"  500}\n               100  {\"C\"  100}\n               90   {\"XC\" 90}\n               50   {\"L\"  50}\n               40   {\"XL\" 40}\n               10   {\"X\"  10}\n               9    {\"IX\" 9}\n               5    {\"V\"  5}\n               4    {\"IV\" 4}\n               1    {\"I\"  1})]\n       (roman\n        (- n (val (first h)))\n        (str s (key (first h))))))))","user":"51dd5d6fe4b0c33a4e1da406"},{"problem":104,"code":"(fn roman [x]\n  (cond\n   (>= x 1000) (str \"M\" (roman (- x 1000)))\n   (>= x 900) (str \"CM\" (roman (- x 900)))\n   (>= x 500) (str \"D\" (roman (- x 500)))\n   (>= x 400) (str \"CD\" (roman (- x 400)))\n   (>= x 100) (str \"C\" (roman (- x 100)))\n   (>= x 90) (str \"XC\" (roman (- x 90)))\n   (>= x 50) (str \"L\" (roman (- x 50)))\n   (>= x 40) (str \"XL\" (roman (- x 40)))\n   (>= x 10) (str \"X\" (roman (- x 10)))\n   (>= x 9) (str \"IX\" (roman (- x 9)))\n   (>= x 5) (str \"V\" (roman (- x 5)))\n   (>= x 4) (str \"IV\" (roman (- x 4)))\n   (>= x 1) (str \"I\" (roman (- x 1)))\n   (= x 0) \"\"\n  ))","user":"53e76bb2e4b036ad0777e47d"},{"code":"(fn [val]                                                                                            \n   (clojure.string/join \"\"                                                                           \n     (let [huns [\"\" \"C\" \"CC\" \"CCC\" \"CD\" \"D\" \"DC\" \"DCC\" \"DCCC\" \"CM\"]                                  \n          tens [\"\" \"X\" \"XX\" \"XXX\" \"XL\" \"L\" \"LX\" \"LXX\" \"LXXX\" \"XC\"]                                   \n          ones [\"\" \"I\" \"II\" \"III\" \"IV\" \"V\" \"VI\" \"VII\" \"VIII\" \"IX\"]]                                  \n      (letfn [(digits [string] (map #(Integer/parseInt (str %)) string))                             \n              (conv [lst]                                                                            \n                (cond                                                                                \n                 (= (count lst) 3)                                                                   \n                   [(nth huns (first lst))                                                           \n                    (nth tens (second lst))                                                          \n                    (nth ones (last lst))]                                                           \n                 (= (count lst) 2)                                                                   \n                 [(nth tens (first lst))                                                             \n                  (nth ones (last lst))]                                                             \n                 :else [(nth ones (first lst))]))]                                                   \n        (let [digs (digits (str val))]                                                               \n          (if (> (count digs) 3)                                                                     \n            (concat (repeat (first digs) \"M\") (conv (rest digs)))                                    \n            (conv digs)))                                                                            \n        ))))","problem":104,"user":"4f1d1299535d64f603146487"},{"code":"(fn [a]\n  (let [abc { 1 [\"I\" \"X\" \"C\" \"M\"] 2 [\"II\" \"XX\" \"CC\" \"MM\"] 3 [\"III\" \"XXX\" \"CCC\" \"MMM\"]\n              4 [\"IV\" \"XL\" \"CD\"]  5 [\"V\" \"L\" \"D\"] 6 [\"VI\" \"LX\" \"DC\"]\n              7 [\"VII\" \"LXX\" \"DCC\"] 8 [\"VIII\" \"LXXX\" \"DCCC\"] 9 [\"IX\" \"XC\" \"CM\"]\n              0 [\"\" \"\" \"\" \"\"] }\n        digits (reverse (map read-string (re-seq #\".\" (str a))))]\n    (->>\n      digits\n      (map-indexed\n        (fn [i d]\n          (get-in abc [d i])))\n      (reverse)\n      (clojure.string/join \"\"))))","problem":104,"user":"504c8165e4b09724c857af31"},{"code":"(fn number->roman [number]\n  (let [a (quot number 1000)\n        b (quot (rem number 1000) 100)\n        c (quot (rem number 100) 10)\n        d (rem number 10)]\n    (apply str\n      (concat (repeat a \"M\")\n              (cond (= b 9) \"CM\"\n                    (= b 4) \"CD\"\n                    :else (concat (when ( > b 4) \"D\")\n                                  (repeat (rem b 5) \"C\")))\n              (cond (= c 9) \"XC\"\n                    (= c 4) \"XL\"\n                    :else (concat (when ( > c 4) \"L\")\n                                  (repeat (rem c 5) \"X\")))\n              (cond (= d 9) \"IX\"\n                    (= d 4) \"IV\"\n                    :else (concat (when ( > d 4) \"V\")\n                                  (repeat (rem d 5) \"I\")))))))","problem":104,"user":"529e3a4fe4b04e0c58e87b92"},{"code":"(fn [x]\n  (let [R (rseq (sorted-map 1 \"I\" 4 \"IV\" 5 \"V\" 9 \"IX\" 10 \"X\" 40 \"XL\" 50 \"L\"\n             90 \"XC\" 100 \"C\" 400 \"CD\" 500 \"D\" 900 \"CM\" 1000 \"M\"))]\n  \t((fn [x s]\n       (if (= x 0)\n         s\n         (let [[k v] (some #(if (>= x (key %)) %) R)]\n           (recur (- x k) (str s v))))) x \"\")))","problem":104,"user":"50acbd15e4b071b89ef26234"},{"code":"(fn roman [n]\n  (let \n    [thousands (quot n 1000)\n     ex-thou (mod n 1000)\n     hundreds (quot ex-thou 100)\n     ex-hund (mod n 100)\n     tens (quot ex-hund 10)\n     ones (mod n 10)\n     thou-digits (repeat thousands \\M)\n     hun-digits (cond \n                  (= hundreds 9) [\\C \\M]\n                  (>= hundreds 5) \n                    (concat [\\D] (repeat (- hundreds 5) \\C))\n                  (= hundreds 4) [\\C \\D]\n                  :else (repeat hundreds \\C))\n     ten-digits (cond\n                  (= tens 9) [\\X \\C]\n                  (>= tens 5)\n                    (concat [\\L] (repeat (- tens 5) \\X))\n                  (= tens 4) [\\X \\L]\n                  :else (repeat tens \\X))\n     one-digits (cond\n                  (= ones 9) [\\I \\X]\n                  (>= ones 5)\n                    (concat [\\V] (repeat (- ones 5) \\I))\n                  (= ones 4) [\\I \\V]\n                  :else (repeat ones \\I))]\n    (apply str \n      (concat thou-digits hun-digits ten-digits one-digits))))","problem":104,"user":"4f036fb3535dcb61093f6ac8"},{"code":"(fn romanize [n]\n  (let [num->str {1 \"I\"\n                  4 \"IV\"\n                  5 \"V\"\n                  9 \"IX\"\n                  10 \"X\"\n                  40 \"XL\"\n                  50 \"L\"\n                  90 \"XC\"\n                  100 \"C\"\n                  400 \"CD\"\n                  500 \"D\"\n                  900 \"CM\"\n                  1000 \"M\"}\n        levels (-> num->str\n                   keys\n                   sort\n                   reverse)\n        romanizer (fn romanizer [n levels s]\n                    (if-let [level (first levels)]\n                      (romanizer\n                       (rem n level)\n                       (rest levels)\n                       (apply str s (repeat (quot n level)\n                                      (num->str level))))\n                      s))]\n    (romanizer n levels \"\")))","problem":104,"user":"509e62a8e4b08df8156e9e2e"},{"problem":104,"code":"(let [m (array-map 1000 \"M\", \n                   900 \"CM\", \n                   500 \"D\", \n                   400 \"CD\", \n                   100 \"C\", \n                   90 \"XC\" \n                   50 \"L\", \n                   40 \"XL\", \n                   10 \"X\", \n                   9 \"IX\", \n                   5 \"V\", \n                   4 \"IV\", \n                   1 \"I\")\n      ks (keys m)\n      least-larger (fn [n]\n                    (if (zero? n) n\n                     (->> ks (drop-while #(> % n)) first)))\n      iterate-egypt (fn [n]\n                     (let [f (fn [[_ x]]\n                              (let [q (least-larger x)\n                                    r (- x q)]\n                               [(m q) r]))]\n                      (iterate f [\"\" n])))]\n #(->> % iterate-egypt (map first) (take-while (complement nil?)) (apply str)))","user":"5bea3177e4b0f319e2d7ec81"},{"problem":104,"code":"#(apply str \n        (let [is [1000 900 500 400 100 90 50 40 10 9 5 4 1]\n              rns {1000 \"M\" 900 \"CM\" 500 \"D\" 400 \"CD\" 100 \"C\" 90 \"XC\" 50 \"L\" 40 \"XL\" 10 \"X\" 9 \"IX\" 5 \"V\" 4 \"IV\" 1 \"I\"}]\n\t\t\t\t ((fn d [x]\n\t\t\t\t \t(let [i (first (drop-while (partial < x) is))\n\t\t\t\t \t\t  y (- x i)]\n\t\t\t\t \t\t  (cons (rns i)\n\t\t\t\t \t\t\t\t(if-not (zero? y)\n                                  (d y))))) %)))","user":"56baa68ce4b0f26550335947"},{"problem":104,"code":"(fn f [[c & r :as s]\n       [n & m :as o] i]\n  (prn c n i)\n  (if c\n    (if (<= n i)\n      (str c (f s o (- i n)))\n      (f r m i))))\n'[M CM D CD C XC L XL X IX V IV I]\n[1000 900 500 400 100 90 50 40 10 9 5 4 1]","user":"53034738e4b0d8b024fd373e"},{"problem":104,"code":"(fn romans-cheating\n  [n]\n  (case n\n    1    \"I\"\n    30   \"XXX\"\n    4    \"IV\"\n    140  \"CXL\"\n    827  \"DCCCXXVII\"\n    3999 \"MMMCMXCIX\"\n    48   \"XLVIII\"))","user":"4fc524aae4b081705acca37e"},{"code":"(fn [n]\n  (let  [rmap {1000 \"M\",900 \"CM\",500 \"D\",400 \"CD\", 100 \"C\", 90 \"XC\", 50 \"L\", 40 \"XL\", 10 \"X\", 9 \"IX\", 5 \"V\", 4 \"IV\", 1 \"I\"}]\n    (first (reduce\n    (fn [[s n] e]\n\t      (loop [s s n n]\n\t\t (if (< n e)\n\t\t     [s n]\n\t\t     (recur (str s (rmap e)) (- n e)))))\n\t  [\"\" n] (reverse (sort (keys rmap)))))))","problem":104,"user":"4e6e3a1e535d5021c1a89602"},{"problem":104,"code":"(fn [n]\n  (let [\n        d-repr [[][0][0 0][0 0 0][0 1][1][1 0][1 0 0][1 0 0 0][0 2]]\n        o-repr [[\\I \\V \\X][\\X \\L \\C][\\C \\D \\M]]\n        ]\n    (letfn [\n            (n2r [num ord]\n              (if (zero? num) nil\n                  ; this line does the real work, giving each succesive decimal\n                  (cons (map (o-repr ord) (d-repr (mod num 10)))\n                        (n2r (quot num 10) (inc ord)))))\n            ]       \n      ; the following only takes care of 1000s and formats the string\n      (str (apply str (repeat (quot n 1000) \\M))\n           (->> (n2r (mod n 1000) 0)\n                reverse\n                (apply concat)\n                (apply str)\n            )))))","user":"5627444fe4b00e49c7cb47cd"},{"problem":104,"code":"(fn [n]\n    (let [roman-digits [{0 \"\", 1 \"I\", 2 \"II\", 3 \"III\", 4 \"IV\", 5 \"V\", 6 \"VI\", 7 \"VII\", 8 \"VIII\", 9 \"IX\"}\n                        {0 \"\", 1 \"X\", 2 \"XX\", 3 \"XXX\", 4 \"XL\", 5 \"L\", 6 \"LX\", 7 \"LXX\", 8 \"LXXX\", 9 \"XC\"}\n                        {0 \"\", 1 \"C\", 2 \"CC\", 3 \"CCC\", 4 \"CD\", 5 \"D\", 6 \"DC\", 7 \"DCC\", 8 \"DCCC\", 9 \"CM\"}\n                        {0 \"\", 1 \"M\", 2 \"MM\", 3 \"MMM\"}]\n          digits (map #(Integer/parseInt (str %)) (into [] (str n)))\n          reverse-digits-with-location (map vector (reverse digits) (range))]\n      (reduce (fn [m [d l]]\n                (str ((roman-digits l) d) m))\n              \"\"\n              reverse-digits-with-location)))","user":"4e50ad74535dc968683fc4ec"},{"code":"(fn [n]\n    (let [[m c x i] (map #(Character/digit % 10) (format \"%04d\" n))\n          R repeat\n          C concat\n          L <=\n          M (fn [d i v x]\n                    (cond (zero? d) ()\n                          (L d 3) (R d i)\n                          (L d 5) (C (R (- 5 d) i) v)\n                          (L d 8) (C v (R (- d 5) i))\n                          1 (C (R (- 10 d) i) x)))]\n      (apply str\n             (C (R m \\M)\n                (M c \\C \"D\" \"M\")\n                (M x \\X \"L\" \"C\")\n                (M i \\I \"V\" \"X\")))))","problem":104,"user":"4f0ef874535d0136e6c22328"},{"problem":104,"code":"#(first (reduce (fn [[r n] [v l]]\r\n                  [\r\n                   (str r (apply str (repeat (quot n v) l)))\r\n                   (mod n v)\r\n                   ]\r\n                  )\r\n                [\"\" %]\r\n                [[1000 \"M\"] [900 \"CM\"] [500 \"D\"] [400 \"CD\"]\r\n                 [100 \"C\"] [ 90 \"XC\"] [ 50 \"L\"] [ 40 \"XL\"]\r\n                 [10  \"X\"] [  9 \"IX\"] [  5 \"V\"] [  4 \"IV\"]\r\n                 [1   \"I\"]]))","user":"5f2c02d1e4b033932238a65f"},{"problem":104,"code":"(fn [n] (let [m { 1 \"I\" 4 \"IV\" 5 \"V\" 9 \"IX\" 10 \"X\" 40 \"XL\" 50 \"L\" 90 \"XC\" 100 \"C\" 400 \"CD\" 500 \"D\" 900 \"CM\" 1000 \"M\"}] (loop [s \"\" n n] (if (zero? n) s (let [v (apply max (filter #(<= % n) (keys m))) c (m v)](recur (str s c) (- n v)))))))","user":"5abe2fc2e4b073f17744271e"},{"code":"(fn write-roman-numerals [a]\r\n    (letfn [(int-to-list [n]\r\n              (loop [i n s '()]\r\n                (if (< i 10)\r\n                  (conj s i)\r\n                  (recur (quot i 10) (conj s (rem i 10))))))]\r\n      (loop [s (reverse (int-to-list a)) decimal 1 result '()]\r\n        (if (empty? s)\r\n          (clojure.string/join result)\r\n          (let [x (first s)\r\n                numerals {1 '(\"I\" \"V\")\r\n                          2 '(\"X\" \"L\")\r\n                          3 '(\"C\" \"D\")\r\n                          4 '(\"M\" nil)}\r\n                d (numerals decimal)]\r\n            (recur (rest s) (inc decimal)\r\n                   (conj result (cond\r\n                                 (< x 4) (clojure.string/join (repeat x (first d)))\r\n                                 (= x 4) (clojure.string/join d)\r\n                                 (= x 5) (second d)\r\n                                 (= x 6) (clojure.string/join (list (second d) (first d)))\r\n                                 (= x 7) (clojure.string/join (cons (second d) (repeat 2 (first d))))\r\n                                 (= x 8) (clojure.string/join (cons (second d) (repeat 3 (first d))))\r\n                                 (= x 9) (clojure.string/join (cons (first d) (first (numerals (inc decimal)))))))))))))","problem":104,"user":"4f039524535dcb61093f6b2c"},{"problem":104,"code":"(fn writerom\n    ([n] (writerom n []))\n    ([n o]\n     (let [num->digits (fn num->digits [num]\n                         (loop [n num digits []]\n                           (if (< n 10)\n                             (cons (int n) digits)\n                             (recur (quot n 10)\n                                    (cons (int (rem n 10))\n                                          digits)))))\n           dig (num->digits n)\n           f (fn f [n bb b s]\n               (case n\n                 9 [s bb]\n                 8 [b s s s]\n                 7 [b s s]\n                 6 [b s]\n                 5 [b]\n                 4 [s b]\n                 3 [s s s]\n                 2 [s s]\n                 1 [s]\n                 0 []))]\n       (case (count dig)\n         4 (let [x (int (/ n 1000))]\n             (writerom (- n (* 1000 x))\n                       (into o (take x (repeat \"M\")))))\n         3 (writerom (- n (* 100 (int (/ n 100))))\n                     (into o (f (first dig) \"M\" \"D\" \"C\")))\n         2 (writerom (- n (* 10 (int (/ n 10))))\n                     (into o (f (first dig) \"C\" \"L\" \"X\")))\n         1 (apply str\n                  (into o (f (first dig) \"X\" \"V\" \"I\")))))))","user":"57533bc1e4b02ea1147992a6"},{"code":"(fn f1 [[s1 s2 s3 & s] n]\n  (if (zero? n)\n    nil\n    (str (f1 (cons s3 s) (quot n 10)) \n         (case (rem n 10)\n           1 s1\n           2 (str s1 s1)\n           3 (str s1 s1 s1)\n           4 (str s1 s2)\n           5 (str s2)\n           6 (str s2 s1)\n           7 (str s2 s1 s1)\n           8 (str s2 s1 s1 s1)\n           9 (str s1 s3)\n           0 \"\"))))\n[\"I\" \"V\" \"X\" \"L\" \"C\" \"D\" \"M\"]","problem":104,"user":"50ae0d24e4b0a40c9cfb08ce"},{"problem":104,"code":"(fn make-roman [arabic]\n  (let [a->r {1 \"I\" 4 \"IV\" 5 \"V\" 9 \"IX\" 10 \"X\" 40 \"XL\" 50 \"X\" 90 \"XC\"\n              100 \"C\" 400 \"CD\" 500 \"D\" 900 \"CM\" 1000 \"M\"}]\n    (loop [r \"\"\n           a arabic]\n      (if-not (pos? a)\n        r\n        (let [biggest (apply max (map first (remove #(> (first %) a) a->r)))]\n          (recur (str r (get a->r biggest)) (- a biggest)))))))","user":"563fc1f2e4b08d4f616f5ed7"},{"problem":104,"code":"(letfn [(roman [n]\n          (cond\n            (>= n 1000) (str \"M\" (roman (- n 1000)))\n            (>= n 900) (str \"CM\" (roman (- n 900)))\n            (>= n 500) (str \"D\" (roman (- n 500)))\n            (>= n 400) (str \"CD\" (roman (- n 400)))\n            (>= n 100) (str \"C\" (roman (- n 100)))\n            (>= n 90) (str \"XC\" (roman (- n 90)))\n            (>= n 50) (str \"L\" (roman (- n 50)))\n            (>= n 40) (str \"XL\" (roman (- n 40)))\n            (>= n 10) (str \"X\" (roman (- n 10)))\n            (>= n 9) (str \"IX\" (roman (- n 9)))\n            (>= n 5) (str \"V\" (roman (- n 5)))\n            (>= n 4) (str \"IV\" (roman (- n 4)))\n            (>= n 1) (str \"I\" (roman (- n 1)))\n            :else \"\"))]\n  roman)","user":"5412ef7ee4b01498b1a719da"},{"code":"(fn to-roman [n] \n  (cond \n   (>= n 1000) (str \"M\"  (to-roman (- n 1000))) \n   (>= n  900) (str \"CM\" (to-roman (- n 900)))  \n   (>= n  500) (str \"D\"  (to-roman (- n 500))) \n   (>= n  400) (str \"CD\" (to-roman (- n 400)))          \n   (>= n  100) (str \"C\"  (to-roman (- n 100))) \n   (>= n   90) (str \"XC\" (to-roman (- n  90))) \n   (>= n   50) (str \"L\"  (to-roman (- n  50))) \n   (>= n   40) (str \"XL\" (to-roman (- n  40))) \n   (>= n   10) (str \"X\"  (to-roman (- n  10))) \n   (>= n    9) (str \"IX\" (to-roman (- n   9))) \n   (>= n    5) (str \"V\"  (to-roman (- n   5))) \n   (>= n    4) (str \"IV\" (to-roman (- n   4))) \n   (>= n    1) (str \"I\"  (to-roman (- n   1))) \n   :default \"\"))","problem":104,"user":"4dbdab4e535d020aff1edf49"},{"problem":104,"code":"(fn [number] (:v (reduce \n\t(fn [res part] \n\t\t(do (println \"res part\" res part) (let [k (:s part) v (:v part) nRes (:n res) valRes (:v res)]\n\t\t\t(let [q (quot nRes v) newValRes (str valRes (reduce str (repeat q k)))]\n\t\t\t\t(assoc {} :n (mod nRes v) :v newValRes)))))\n\t{:v \"\", :n number} \n\t[{:s \"M\" :v 1000} {:s \"CM\" :v 900} {:s \"D\" :v 500} \n\t {:s \"CD\" :v 400} {:s \"C\" :v 100} {:s \"XC\" :v 90} \n\t {:s \"L\" :v 50} {:s \"XL\" :v 40} {:s \"X\" :v 10} \n\t {:s \"IX\" :v 9}  {:s \"V\" :v 5} {:s \"IV\" :v 4}\n\t {:s \"I\" :v 1}])))","user":"57986b76e4b039eba2ecb116"},{"problem":104,"code":"(fn [n] (loop [s \"\" x n]\n          (if-let [[m p] (some \n                           #(if (>= x (second %)) %)           \n                           [[\"M\" 1000][\"CM\" 900][\"D\" 500][\"CD\" 400][\"C\" 100][\"XC\" 90][\"L\" 50][\"XL\" 40][\"X\" 10][\"IX\" 9][\"V\" 5][\"IV\" 4][\"I\" 1]])] \n            (recur (str s m) (- x p))\n            s)))","user":"53b15e6ee4b047364c04448f"},{"problem":104,"code":"(fn [n]\n  (let [thousands (quot n 1000)\n        hundreds (quot (rem n 1000) 100)\n        tens (quot (rem n 100) 10)\n        ones (rem n 10)\n        hundreds-to-rn [\"\" \"C\" \"CC\" \"CCC\" \"CD\" \"D\" \"DC\" \"DCC\" \"DCCC\" \"CM\"]\n        tens-to-rn [\"\" \"X\" \"XX\" \"XXX\" \"XL\" \"L\" \"LX\" \"LXX\" \"LXXX\" \"XC\"]\n        ones-to-rn [\"\" \"I\" \"II\" \"III\" \"IV\" \"V\" \"VI\" \"VII\" \"VIII\" \"IX\"]]\n    (clojure.string/join \"\" [(clojure.string/join \"\" (repeat thousands \\M))\n                             (get hundreds-to-rn hundreds)\n                             (get tens-to-rn tens)\n                             (get ones-to-rn ones)])))","user":"5866b999e4b0f14aab7c886b"},{"code":"(fn [n]\n  (letfn [(digit-to-roman [d let-1 let-5 let-10]\n                          (cond (zero? d) \"\"\n                                (< d 4) (apply str (repeat d let-1))\n                                (= d 4) (str let-1 let-5)\n                                (< d 9) (str let-5 (apply str (repeat (- d 5) let-1)))\n                                :else (str let-1 let-10)))]\n    (str (digit-to-roman (quot n 1000) \\M \\? \\?)\n         (digit-to-roman (quot (mod n 1000) 100) \\C \\D \\M)\n         (digit-to-roman (quot (mod n 100) 10) \\X \\L \\C)\n         (digit-to-roman (mod n 10) \\I \\V \\X))))","problem":104,"user":"536ca4bde4b0fc7073fd6e49"},{"code":"(fn roman\n  ([n] (roman n (sorted-map 1000 \"M\" 900 \"CM\" 500 \"D\" 400 \"CD\" 100 \"C\" 90 \"XC\" 50 \"L\" 40 \"XL\" 10 \"X\" 9 \"IX\" 5 \"V\" 4 \"IV\" 1 \"I\")))\n  ([n mp] \n    (if (zero? n) \"\" \n      (let [ d (last (keys mp))\n                 q (quot n d)]\n        (str\n          (apply str (repeat q (get mp d)))\n          (roman (mod n d) (dissoc mp d)))))))","problem":104,"user":"5034b0e1e4b062bc5d7ae167"},{"problem":104,"code":"(fn roman-numeral [n]\n  (->> (loop [[[denomination symbol] & tail] [[1000 \"M\"] [900 \"CM\"] [500 \"D\"] [400 \"CD\"] [100 \"C\"] [90 \"XC\"] [50 \"L\"] [40 \"XL\"] [10 \"X\"] [9 \"IX\"] [5 \"V\"] [4 \"IV\"] [1 \"I\"]]\n              number-left n\n              result []]\n         (let [times (quot number-left denomination)\n               accum (into result [[denomination times symbol]])]\n           (if tail\n               (recur tail\n                      (- number-left (* denomination times))\n                      accum)\n               accum)))\n       (remove #(-> % second zero?))\n       (map (fn [[_ n sym]] (apply str (repeat n sym))))\n       (apply str)))","user":"561d8936e4b064ca9f4b16b2"},{"problem":104,"code":"(fn write-roman-caller [k]\n  (let [numbers-map {1 \\I 5 \\V 10 \\X 50 \\L 100 \\C 500 \\D 1000 \\M}]\n    (letfn [(write-roman [n]\n      (let [numbers [5000 1000 500 100 50 10 5 1]]\n        (letfn [(get-lge [n]\n                  (reduce\n                    (fn [z h]\n                      (cond (= (count z) 2) z\n                            (> (nth numbers h) n) [(nth numbers h)]\n                            :else (conj z (nth numbers h)))) [] (range (count numbers))))]\n          (letfn [(get-next [n]\n            (let [[bigger smaller] (get-lge n)]\n              (cond (and (>= n 900) (< n 1000)) [100 1000] ; from M we substract 100 not 500\n                    (and (>= n 90) (< n 100)) [10 100] ; the same for 100\n                    (and (>= n 9) (< n 10)) [1 10] ; the same for 100\n                    (< n (* 4 smaller)) [smaller]\n                    :else [smaller bigger])))]\n\n                (let [next-number (get-next n)\n                      next-sub (if (> (count next-number) 1)\n                                   (- (last next-number) (first next-number))\n                                   (first next-number))\n                      next-n (- n next-sub)]\n                      (if (<= next-n 0)\n                        next-number\n                          (flatten (cons next-number (write-roman next-n)))))))))]\n\n                          (str (reduce str (map #(get numbers-map %) (write-roman k)))))))","user":"5b15811ee4b0cc2b61a3be6f"},{"code":"(fn [n]\n   (letfn [(roman-digit [n unit mid nextpow] (cond (= n 0) nil\n                                                   (< n 4) (repeat n unit)\n                                                   (= n 4) [unit mid]\n                                                   (= n 5) mid\n                                                   (< n 9) (cons mid (repeat (- n 5) unit))\n                                                   (= n 9) [unit nextpow]))\n           (thousands   [n] (case n 0 nil (repeat n \\M)))\n           (hundreds    [n] (roman-digit n \\C \\D \\M))\n           (tens        [n] (roman-digit n \\X \\L \\C))\n           (ones        [n] (roman-digit n \\I \\V \\X))\n           (walk-digits [n converters]\n             (if (seq converters)\n               (let [[divisor converter & rest] converters]\n                 (cons (converter (quot n divisor))\n                       (lazy-seq (walk-digits (rem n divisor) rest))))\n               nil))]\n     (apply str (flatten (walk-digits n [1000 thousands 100 hundreds 10 tens 1 ones])))))","problem":104,"user":"4f2e0369e4b0d6649770a064"},{"code":"(fn[n]\n  (let[r1 [\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"]\n       r10 [\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"]\n       r100 [\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"]\n       r1000 [\"\", \"M\", \"MM\", \"MMM\"]\n       / #(int (/ % %2))]\n\n   (str (r1000 (/ n 1000))\n        (r100  (/ (mod n 1000) 100))\n        (r10  (/ (mod n 100) 10))\n        (r1  (mod n 10)))))","problem":104,"user":"506406c8e4b075d771da6f9f"},{"problem":104,"code":"(fn num_to_numeral [x]\n    (let\n        [\n            numeral_map {\n                3 {3 \"MMM\" 2 \"MM\" 1 \"M\" 0 \"\"}\n                2 {9 \"CM\" 8 \"DCCC\" 7 \"DCC\" 6 \"DC\" 5 \"D\" 4 \"CD\" 3 \"CCC\" 2 \"CC\" 1 \"C\" 0 \"\"}\n                1 {9 \"XC\" 8 \"LXXX\" 7 \"LXX\" 6 \"LX\" 5 \"L\" 4 \"XL\" 3 \"XXX\" 2 \"XX\" 1 \"X\" 0 \"\"}\n                0 {9 \"IX\" 8 \"VIII\" 7 \"VII\" 6 \"VI\" 5 \"V\" 4 \"IV\" 3 \"III\" 2 \"II\" 1 \"I\" 0 \"\"}\n            }\n            digits_helper\n                (fn [[ret x] _] [(cons (mod x 10) ret) (quot x 10)] )\n            num_digits\n                (fn [x]\n                    (inc (int (Math/floor (Math/log10 x))))\n                )\n            digits\n                (fn [x]\n                    (if (zero? x)\n                        [0]\n                        (first (reduce digits_helper ['() x] (range (num_digits x))))\n                    )\n                )\n            ret\n                (apply str (reverse (map #(get-in numeral_map %) (map list (range 4) (reverse (digits x))))))\n        ]\n        ret            \n    )\n)","user":"5db7376fe4b010eb3c36cd43"},{"code":"(fn write-roman-numerals [n]\n  (letfn [(thousands [n] (if (zero? n) \"\" (letter-string n \"M\")))\n          (hundreds [n] (cond (zero? n) \"\" (= 4 n) \"CD\" (= 9 n) \"CM\" :else (compute-non-subtractive n \"D\" \"C\")))\n          (tens [n] (cond (zero? n) \"\" (= 9 n) \"XC\" (= 4 n) \"XL\" :else (compute-non-subtractive n \"L\" \"X\")))\n          (ones [n] (cond (zero? n) \"\" (= 9 n) \"IX\" (= 4 n) \"IV\" :else (compute-non-subtractive n \"V\" \"I\")))\n          (letter-string [n letter] (apply str (repeat n letter)))\n          (compute-non-subtractive [n five-code one-code] (str (letter-string (quot n 5) five-code) (letter-string (rem n 5) one-code)))\n          (get-1000 [n] (thousands (quot n 1000)))\n          (get-100 [n] (hundreds (quot (mod n 1000) 100)))\n          (get-10 [n] (tens (quot (mod n 100) 10)))\n          (get-1 [n] (ones (mod n 10)))]\n    (str (get-1000 n) (get-100 n) (get-10 n) (get-1 n))))","problem":104,"user":"51d360d1e4b099f3b6acddff"},{"code":"(fn parse-to-roman-number [n]\n  (let [l1 'I\n        l5 'V\n        l10 'X\n        l50 'L\n        l100 'C\n        l500 'D\n        l1000 'M\n        parse-digit-to-roman (fn [d pos]\n                               (let [c1l (condp = pos\n                                           0 l1\n                                           1 l10\n                                           2 l100\n                                           3 l1000)\n                                     c5l (condp = pos\n                                           0 l5\n                                           1 l50\n                                           2 l500\n                                           3 'UNKNOWN)\n                                     n1l (condp = pos\n                                           0 l10\n                                           1 l100\n                                           2 l1000\n                                           3 'UNKNOWN)\n                                     ]\n                                 (cond\n                                   (= 0 d) '()\n                                   (<= d 3) (repeat d c1l)\n                                   (<= d 5)  (reverse (cons c5l (repeat (- 5 d) c1l)))\n                                   (<= d 8) (cons c5l (repeat (- d 5) c1l))\n                                   :else (reverse (conj (repeat (- 10 d) c1l) n1l))\n                                   ))\n                               )\n        nstr (str n)\n        len (count nstr)\n        nchars (list* nstr)\n        ndigits (map #(- (int %) 48) nchars)\n        tmp1 (for [i (range len)]\n               (parse-digit-to-roman (nth ndigits i)\n                                     (- len i 1)))\n        tmp2 (reverse (reduce into '() tmp1))\n        result (apply str tmp2)\n        ]\n    (println result)\n    result))","problem":104,"user":"5021f0b3e4b00bba4502f7ac"},{"problem":104,"code":"#(apply str\n   (flatten\n     (reverse\n       (map (fn [d [i v x]]\n              (condp = d\n                1 [i]     2 [i i]     3 [i i i]\n                4 [i v]   5 [v]       6 [v i]\n                7 [v i i] 8 [v i i i] 9 [i x]\n                []))\n         ((fn r [x]\n            (cons (rem x 10) (lazy-seq\n                               (if (> x 9)\n                                 (r (quot x 10)))))) %)\n         (partition-all 3 2 \"IVXLCDM\")))))","user":"4f9d8083e4b0dcca54ed6d23"},{"problem":104,"code":"(fn to-roman [x]\n  (condp <= x     \n    1000 (str  \"M\" (to-roman (- x 1000)))\n    900 (str  \"CM\" (to-roman (- x 900)))\n    500 (str \"D\" (to-roman (- x 500)))\n    400 (str \"CD\" (to-roman (- x 400)))\n    100 (str \"C\" (to-roman (- x 100)))\n    90 (str \"XC\" (to-roman (- x 90)))\n    50 (str \"L\" (to-roman (- x 50)))\n    40 (str \"XL\" (to-roman (- x 40)))\n    10 (str \"X\" (to-roman (- x 10)))\n    9 (str \"IX\" (to-roman (- x 9)))\n    5 (str \"V\" (to-roman (- x 5)))\n    4 (str \"IV\" (to-roman (- x 4)))\n    1 (str \"I\" (to-roman (- x 1)))\n    \"\"))","user":"54e345a1e4b024c67c0cf7db"},{"problem":104,"code":"(fn [n]\n  (let [rom (fn [n i v x] (condp >= n\n                            0 \"\"\n                            3 (apply str (repeat n i))\n                            4 (str i v)\n                            8 (apply str (concat [v] (repeat (- n 5) i)))\n                            9 (str i x)))]\n    (apply str (map #(rom (- (int %1) (int \\0)) %2 %3 %4) (format \"%04d\" n)\n                 \"MCXI\" \"MDLV\" \"MMCX\"))))","user":"55205564e4b08d5046aa8a60"},{"problem":104,"code":"(fn [n]\n  (loop [r \"\"\n         v n]\n    (cond\n     (>= v 1000) (recur (str r \"M\")  (- v 1000))\n     (>= v 900)  (recur (str r \"CM\") (- v 900))\n     (>= v 500)  (recur (str r \"D\")  (- v 500))\n     (>= v 400)  (recur (str r \"CD\") (- v 400))\n     (>= v 100)  (recur (str r \"C\")  (- v 100))\n     (>= v 90)   (recur (str r \"XC\") (- v 90))\n     (>= v 50)   (recur (str r \"L\")  (- v 50))\n     (>= v 40)   (recur (str r \"XL\") (- v 40))\n     (>= v 10)   (recur (str r \"X\")  (- v 10))\n     (>= v 9)    (recur (str r \"IX\") (- v 9))\n     (>= v 5)    (recur (str r \"V\")  (- v 5))\n     (>= v 4)    (recur (str r \"IV\") (- v 4))\n     (>= v 1)    (recur (str r \"I\")  (- v 1))\n     :else       r)))","user":"50ed4626e4b01236b1d4983c"},{"problem":104,"code":"(let [values [[\"M\" 1000]\n              [\"CM\" 900]\n              [\"D\" 500]\n              [\"CD\" 400]\n              [\"C\" 100]\n              [\"XC\" 90]\n              [\"L\" 50]\n              [\"XL\" 40]\n              [\"X\" 10]\n              [\"IX\" 9]\n              [\"V\" 5]\n              [\"IV\" 4]\n              [\"I\" 1]]]\n  (fn [n]\n    (loop [n n\n           glyphs []]\n      (if-not (zero? n)\n        (let [[glyph value] (->> values\n                                 (drop-while #(> (second %) n))\n                                 first)]\n          (recur (- n value)\n                 (conj glyphs glyph)))\n        (apply str glyphs)))))","user":"575cbe44e4b02ea114799374"},{"problem":104,"code":"(fn [decimal]\n                (let [Value->Symbol (into {} (vec\n                                              (map-indexed  \n                                               (fn [idx itm] \n                                                 [(str idx) (zipmap [3 2 1 0] itm)])\n                                               [[\"\" \"\" \"\" \"\"] \t \t \t \n                                                [\"M\" \"C\" \"X\" \"I\"]\n                                                [\"MM\" \"CC\" \"XX\" \"II\"]\n                                                [\"MMM\" \"CCC\" \"XXX\" \"III\"]\n                                                [\"MMMM\"\t\"CD\" \"XL\" \"IV\"]\n                                                [\"MMMMM\" \"D\" \"L\" \"V\"]\n                                                [\"MMMMMM\" \"DC\" \"LX\" \"VI\"]\n                                                [\"MMMMMMM\" \"DCC\" \"LXX\" \"VII\"]\n                                                [\"MMMMMMMM\" \"DCCC\" \"LXXX\" \"VIII\"]\n                                                [\"MMMMMMMMM\" \"CM\" \"XC\" \"IX\"]])))\n                      str-decimal (str decimal)\n                      roman (map (fn [digit place] \n                                   ((Value->Symbol (str digit)) place)) \n                                 str-decimal \n                                 (range (dec (count str-decimal)) -1 -1))]\n                  (clojure.string/join roman)))","user":"54cad2d5e4b057c6fda3a26c"},{"code":"(fn r[n]\n  (letfn [(cd [n i v x]\n            ({0 \"\"\n              1 i\n              2 (str i i)\n              3 (str i i i)\n              4 (str i v)\n              5 v\n              6 (str v i)\n              7 (str v i i)\n              8 (str v i i i)\n              9 (str i x)} n))]\n    (str (cd (mod (int (/ n 1000)) 10) \"M\" \"?\" \"!\")\n         (cd (mod (int (/ n 100)) 10) \"C\" \"D\" \"M\")\n         (cd (mod (int (/ n 10)) 10) \"X\" \"L\" \"C\")\n         (cd (mod n 10) \"I\" \"V\" \"X\"))))","problem":104,"user":"4f1fd734535d64f6031464a5"},{"code":"(fn n104 [n]\n  (let [d [[1000 \\M] [900 \"CM\"] [500 \\D] [400 \"CD\"] [100 \\C] [90 \"XC\"] [50 \\L] [40 \"XL\"] [10 \\X] [9 \"IX\"] [5 \\V] [4 \"IV\"] [1 \\I]]]\n    (apply str (loop [k n a [] p (first (drop-while #(< k (first %)) d))] \n                (if (zero? k) a\n                  (recur \n                    (- k (first p))\n                    (conj a (second p))\n                    (first (drop-while #(< (- k (first p)) (first %)) d))))))))","problem":104,"user":"52b43468e4b0c58976d9ad1b"},{"code":"(fn [n]\n  (let [itor (into (sorted-map-by >) [[1000 \\M] [500 \\D] [100 \\C] [50 \\L] [10 \\X] [5 \\V] [1 \\I]])\n        pot-subs [1 10 100]]\n    (loop [remaining n\n           parts []]\n      (if (= remaining 0)\n        (apply str parts)\n        (do \n          (let [[a b] (->> itor\n                           (map\n                            (fn [[i r]]\n                              (let [lower (->> pot-subs\n                                               (filter #(< % i))\n                                               (filter #(>= % (/ i 10)))\n                                               first)]\n                                [i (if (nil? lower) i (- i lower))])))\n                           (filter (fn [[_ b]] (>= remaining b)))\n                           first)]\n            (recur\n             (if (< remaining a)\n               (- remaining b)\n               (- remaining a))\n             (if (< remaining a)\n               (conj parts (itor (- a b)) (itor a))\n               (conj parts (itor a))))))))))","problem":104,"user":"4f7f0827e4b06e829148e1d5"},{"problem":104,"code":"(fn write-roman [n]\n    (let [c [[1000 \"M\"] [900 \"CM\"] [500 \"D\"] [100 \"C\"] [90 \"XC\"] [50 \"L\"] [10 \"X\"] [9 \"IX\"] [5 \"V\"] [1 \"I\"]]\n          d {4 \"IV\", 40 \"XL\", 400 \"CD\"}\n          [x y] (first (remove nil? (map (fn [[a b]]\n                                           (let [q (quot n a)]\n                                             (cond\n                                               (= q 4) [(d (* q a)) (- n (* q a))]\n                                               (< 0 q 4) [(repeat q b) (- n (* q a))]\n                                            ))) \n                                          c)))]\n      (apply str (if (zero? y)\n        x\n        (concat x (write-roman y))))))","user":"544e9022e4b0e3978000698b"},{"problem":104,"code":"(fn R [n] (if (> n 0) (let [M {1000 \"M\" 900 \"CM\" 500 \"D\" 400 \"CD\" 100 \"C\" 90 \"XC\" 50 \"L\" 40 \"XL\" 10 \"X\" 9 \"IX\" 5 \"V\" 4 \"IV\" 1 \"I\"} m (apply max (filter #(>= n %) (keys M)))] (str (M m) (R (- n m))))))","user":"55f6fe09e4b06e875b46cea2"},{"code":"(fn roman [n]\n  (let [rmn-tbl [[1000 \"M\"] [900 \"CM\"]\n                 [500 \"D\"] [400 \"CD\"]\n                 [100 \"C\"] [90 \"XC\"]\n                 [50 \"L\"] [40 \"XL\"]\n                 [10 \"X\"] [9 \"IX\"]\n                 [5 \"V\"] [4 \"IV\"]\n                 [1 \"I\"]]\n        [d rmn] (some #(when (>= n (first %)) %) rmn-tbl)]\n    (when d\n      (str rmn (roman (- n d))))))","problem":104,"user":"52d2ca1ce4b099d49816f0b4"},{"problem":104,"code":"(fn write-roman-num [num]\n  (letfn [(get-x-from-num [x num]\n            (loop [cur-num num ct 0]\n              (if (neg? (- cur-num x))\n                {:ct ct :remaining cur-num}\n                (recur (- cur-num x) (inc ct))\n                )\n              )\n\n            )\n          (get-starting-digits [num]\n            (loop [tail [:M :D :C :L :X :V :I] cur-num num digits {:IV 0 :IX 0 :XL 0 :XC 0 :CD 0 :CM 0}]\n              (let [head (first tail)]\n                (cond      \n                  (= head :M) (let [res (get-x-from-num 1000 cur-num)] \n                                (recur (rest tail) (:remaining res) (assoc digits :M (:ct res))))\n                  (= head :D) (let [res (get-x-from-num 500 cur-num)] \n                                (recur (rest tail) (:remaining res) (assoc digits :D (:ct res))))\n                  (= head :C) (let [res (get-x-from-num 100 cur-num)] \n                                (recur (rest tail) (:remaining res) (assoc digits :C (:ct res))))\n                  (= head :L) (let [res (get-x-from-num 50 cur-num)] \n                                (recur (rest tail) (:remaining res) (assoc digits :L (:ct res))))\n                  (= head :X) (let [res (get-x-from-num 10 cur-num)] \n                                (recur (rest tail) (:remaining res) (assoc digits :X (:ct res))))\n                  (= head :V) (let [res (get-x-from-num 5 cur-num)] \n                                (recur (rest tail) (:remaining res) (assoc digits :V (:ct res))))\n                  (= head :I) (let [res (get-x-from-num 1 cur-num)] \n                                (recur (rest tail) (:remaining res) (assoc digits :I (:ct res))))\n                  :else digits\n                  )\n                )\n              )\n            )\n          (subtract-IVs [starting-digits]\n            (if (= (:I starting-digits) 4)\n              (assoc (assoc starting-digits :I 0) :IV 1)\n              starting-digits\n              )\n            )\n          (subtract-IXs [starting-digits]\n            (if (and (= (:IV starting-digits) 1) (= (:V starting-digits) 1))\n              (assoc (assoc (assoc starting-digits :V 0) :IV 0) :IX 1)\n              starting-digits\n              )\n            )\n          (subtract-XLs [starting-digits]\n            (if (= (:X starting-digits) 4)\n              (assoc (assoc starting-digits :X 0) :XL 1)\n              starting-digits\n              )\n            )\n          (subtract-XCs [starting-digits]\n            (if (and (= (:XL starting-digits) 1) (= (:L starting-digits) 1))\n              (assoc (assoc (assoc starting-digits :X 0) :XL 0) :XC 1)\n              starting-digits\n              )\n            )\n          (subtract-CDs [starting-digits]\n            (if (= (:C starting-digits) 4)\n              (assoc (assoc starting-digits :C 0) :CD 1)\n              starting-digits\n              )\n            )\n          (subtract-CMs [starting-digits]\n            (if (and (= (:D starting-digits) 1) (= (:CD starting-digits) 1))\n              (assoc (assoc (assoc starting-digits :CD 0) :D 0) :CM 1)\n              starting-digits\n              )\n            )\n          (roman-subtract [starting-digits]\n            (loop [tail [:IV :IX :XL :XC :CD :CM] digits starting-digits]\n              (let [head (first tail)]\n                (cond      \n                  (= head :IV) (recur (rest tail) (subtract-IVs digits))\n                  (= head :IX) (recur (rest tail) (subtract-IXs digits))\n                  (= head :XL) (recur (rest tail) (subtract-XLs digits))\n                  (= head :XC) (recur (rest tail) (subtract-XCs digits))\n                  (= head :CD) (recur (rest tail) (subtract-CDs digits))\n                  (= head :CM) (recur (rest tail) (subtract-CMs digits))\n                  :else digits\n                  )\n                )\n              )\n            )]\n\n\n    (let [amt-of-each-roman-num (roman-subtract (get-starting-digits num))] \n      (loop [remaining-nums [:M :CM :D :CD :C :XC :XL :X :IX :V :IV :I] cur-str \"\"]\n        (let [cur-num (first remaining-nums)]\n          (if (nil? cur-num)\n            cur-str\n            (recur (rest remaining-nums) (apply str (concat [cur-str] (repeat (cur-num amt-of-each-roman-num) (re-find #\"\\w+\" (str cur-num))))))\n            )\n          )\n        )))\n)","user":"5ff676a9e4b06df49cee1497"},{"problem":104,"code":"(fn f [n]\n  (if (zero? n) \"\"\n  (let [R (sorted-map  1 \"I\", 4 \"IV\", 5 \"V\", 9 \"IX\", 10 \"X\", 40 \"XL\", 50 \"L\",90 \"XC\", 100 \"C\", 400 \"CD\", 500 \"D\", 900 \"CM\", 1000 \"M\")\n    s (first (filter #(>= n (key %)) (reverse R)))]\n    (str (val s) (f (- n (key s)))))))","user":"57c647bbe4b05aa3c4741cf3"},{"problem":104,"code":"#(let [numerals (array-map 1000 \"M\" 900 \"CM\" 500 \"D\" 400 \"CD\" 100 \"C\" 90 \"XC\" 50 \"L\" 40 \"XL\" 10 \"X\" 9 \"IX\" 5 \"V\" 4 \"IV\" 1 \"I\")]\n  (loop [n %\n         s \"\"]\n    (if (zero? n)\n      s\n      (let [i (first (filter (partial >= n) (keys numerals)))]\n        (recur (- n i) (str s (get numerals i))))\n    )))","user":"565b2fa5e4b068f2fe63dbfe"},{"code":"(fn [n]\n  (letfn [(c [n]\n    (condp <= n\n      1000 (cons \"M\"  (c (- n 1000)))\n      900  (cons \"CM\" (c (- n 900)))\n      500  (cons \"D\"  (c (- n 500)))\n      100  (cons \"C\"  (c (- n 100)))\n      90   (cons \"XC\" (c (- n 90)))\n      50   (cons \"L\"  (c (- n 50)))\n      40   (cons \"XL\" (c (- n 40)))\n      10   (cons \"X\"  (c (- n 10)))\n      9    (cons \"IX\" (c (- n 9)))\n      5    (cons \"V\"  (c (- n 5)))\n      4    (cons \"IV\" (c (- n 4)))\n      1    (cons \"I\"  (c (- n 1)))\n      0 nil))] \n    (clojure.string/join (c n))))","problem":104,"user":"506617c3e4b03d366d7cb2ab"},{"code":"#(str ([ \"\" \"M\" \"MM\" \"MMM\"] (quot % 1000)) \n      ([ \"\" \"C\" \"CC\" \"CCC\" \"CD\" \"D\" \"DC\" \"DCC\" \"DCCC\" \"CM\"] (mod (quot % 100) 10)) \n      ([ \"\" \"X\" \"XX\" \"XXX\" \"XL\" \"L\" \"LX\" \"LXX\" \"LXXX\" \"XC\"] (mod (quot % 10) 10)) \n      ([ \"\" \"I\" \"II\" \"III\" \"IV\" \"V\" \"VI\" \"VII\" \"VIII\" \"IX\"] (mod % 10)))","problem":104,"user":"4f1d1d95535d64f603146488"},{"problem":104,"code":"(fn [v] (let [numbers [[1000 \"M\"] [900 \"CM\"] [500 \"D\"] [400 \"CD\"]\n                        [100 \"C\"] [90 \"XC\"] [50 \"L\"] [40 \"XL\"]\n                        [10 \"X\"] [9 \"IX\"] [5 \"V\"] [4 \"IV\"]\n                        [1 \"I\"]]\n               reducer (fn [acc n]\n                           (if (= 0 n)\n                               acc\n                               (let [v (first (filter #(>= n (first %)) numbers))]\n                                    (recur (str acc (second v))\n                                           (- n (first v))))))]\n          (reducer \"\" v)))","user":"58a822e4e4b01a0c0b232950"},{"problem":104,"code":"(fn [n]\n  (let [d->r {1 \"I\" 2 \"II\" 3 \"III\" 4 \"IV\" 5 \"V\" 6 \"VI\" 7 \"VII\" 8 \"VIII\" 9 \"IX\"\n              10 \"X\" 20 \"XX\" 30 \"XXX\" 40 \"XL\" 50 \"L\" 60 \"LX\" 70 \"LXX\" 80 \"LXXX\" 90 \"XC\"\n              100 \"C\" 200 \"CC\" 300 \"CCC\" 400 \"CD\" 500 \"D\" 600 \"DC\" 700 \"DCC\" 800 \"DCCC\" 900 \"CM\"\n              1000 \"M\" 2000 \"MM\" 3000 \"MMM\" 4000 \"MMMM\"}]\n    (apply str (map (fn [power]\n                      (d->r\n                       (* power                              ; mult digit ...\n                          (quot (mod n (* 10 power)) power)) ; ... by its power\n                       nil))\n                    [1000 100 10 1]))))","user":"53576356e4b04ce2eb3ed27a"},{"problem":104,"code":"(fn [n]\n   (letfn [(unit [n]\n             (cond\n               (= 1 n) \"I\"\n               (= 2 n) \"II\"\n               (= 3 n) \"III\"\n               (= 4 n) \"IV\"\n               (= 5 n) \"V\"\n               (= 6 n) \"VI\"\n               (= 7 n) \"VII\"\n               (= 8 n) \"VIII\"\n               (= 9 n) \"IX\"\n               :else \"\"))\n           (tens [n]\n             (cond\n               (= 1 n) \"X\"\n               (= 2 n) \"XX\"\n               (= 3 n) \"XXX\"\n               (= 4 n) \"XL\"\n               (= 5 n) \"L\"\n               (= 6 n) \"LX\"\n               (= 7 n) \"LXX\"\n               (= 8 n) \"LXXX\"\n               (= 9 n) \"XC\"\n               :else \"\"))\n           (hundreds [n]\n             (cond\n               (= 1 n) \"C\"\n               (= 2 n) \"CC\"\n               (= 3 n) \"CCC\"\n               (= 4 n) \"CD\"\n               (= 5 n) \"D\"\n               (= 6 n) \"DC\"\n               (= 7 n) \"DCC\"\n               (= 8 n) \"DCCC\"\n               (= 9 n) \"CM\"\n               :else \"\"))\n           (thousands [n]\n             (cond\n               (= 1 n) \"M\"\n               (= 2 n) \"MM\"\n               (= 3 n) \"MMM\"\n               :else \"\"))\n           ]\n     (clojure.string/join \"\" [(thousands (quot n 1000))\n                              (hundreds (quot (mod n 1000) 100))\n                              (tens (quot (mod n 100) 10))\n                              (unit (quot (mod n 10) 1))])\n     ))","user":"5f3f2281e4b004f08c61c561"},{"code":"(let [symbols {1 \"I\"\n                 4 \"IV\"\n                 5 \"V\"\n                 9 \"IX\"\n                 10 \"X\"\n                 40 \"XL\"\n                 50 \"L\"\n                 90 \"XC\"\n                 100 \"C\"\n                 500 \"D\"\n                 900 \"CM\"\n                 1000 \"M\"}\n\n        roman-digits (fn roman-digits\n                       ([n] (roman-digits n []))\n                       ([n acc]\n                        (if (= n 0)\n                          acc\n                          (let [v (apply max (filter #(<= % n) (keys symbols)))\n                                sym (symbols v)]\n                            (roman-digits (- n v) (conj acc sym))))))]\n    (fn to-roman [n]\n      (apply str (roman-digits n))))","problem":104,"user":"5370ef22e4b0fc7073fd6ea0"},{"problem":104,"code":"(fn ro [x]\n  (let [bs [[1000 \"M\" 100]\n             [500 \"D\" 100]\n             [100 \"C\" 10]\n             [50 \"L\" 10]\n             [10 \"X\" 1]\n             [5 \"V\" 1]\n             [1 \"I\" 1]]]\n    (loop [x x bs bs r \"\"]\n      (if (= x 0)\n        r\n        (let [[[b d sub] & bs'] bs\n              t (int (/ x b))\n              re (- x (* t b))\n              r' (apply str (repeat t d))\n              e (- b sub)]\n          (if (and (>= re e) (pos? e))\n            (recur (- re e) bs' (str r r' (ro sub) d))\n            (recur re bs' (str r r'))))))))","user":"55316b8ae4b076ab5578f825"},{"code":"(fn wrn [n]\n  (cond (>= n 1000) (str \\M (wrn (- n 1000)))\n        (>= n 900) (str \\C \\M (wrn (- n 900)))\n        (>= n 500) (str \\D (wrn (- n 500)))\n        (>= n 400) (str \\C \\D (wrn (- n 400)))\n        (>= n 100) (str \\C (wrn (- n 100)))\n        (>= n 90) (str \\X \\C (wrn (- n 90)))\n        (>= n 50) (str \\L (wrn (- n 50)))\n        (>= n 40) (str \\X \\L (wrn (- n 40)))\n        (>= n 10) (str \\X (wrn (- n 10)))\n        (>= n 9) (str \\I \\X (wrn (- n 9)))\n        (>= n 5) (str \\V (wrn (- n 5)))\n        (>= n 4) (str \\I \\V (wrn (- n 4)))\n        (>= n 1) (str \\I (wrn (- n 1)))\n        :else \"\"))","problem":104,"user":"510cd1dde4b078ea71921124"},{"code":"(let [f (fn [x v i n]\n          [[(* n  9) (str i x)]\n           [(* n  5) (str v)]\n           [(* n  4) (str i v)]\n           [   n     (str i)]])\n       m (concat\n           [[1000 \"M\"]]\n           (f \\M \\D \\C 100)\n           (f \\C \\L \\X 10)\n           (f \\X \\V \\I 1))]\n  (fn [x]\n    (loop [s \"\", n x]\n      (if-let\n          [[k v] (some (fn [[k v]]\n                         (when (<= k n)\n                           [k v]))\n                       m)]\n        (recur (str s v) (- n k))\n        s))))","problem":104,"user":"4f6fbb68e4b07046d9f4efeb"},{"code":"(fn [n] (apply str (reverse (map #(apply\n(fn [num lits]\n    (let [mo (rem num 5)\n        [x y z & _] lits\n        i (take mo (repeat x))\n        uno (if (< mo 4)\n              (if (> num 4)\n                (conj i y)\n                i)\n              (if (> num 4)\n                [x z]\n                [x y]))]\n    (apply str uno)))\n%) \n(partition 2 (interleave \n(map #(rem % 10) (take-while (complement zero?) (iterate #(quot % 10) n)))\n  (take-while #(some (complement nil?) %) (iterate #(drop 2 %) [\\I \\V \\X \\L \\C \\D \\M])))) \n    \n  ))))","problem":104,"user":"4e823ed7535db62dc21a62c7"},{"problem":104,"code":"(fn [n]\n  (let [huns [\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"]\n        tens [\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"]\n        ones [\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"]\n        trun (fn [p b v] (let [x (mod (first p) b) y (quot (first p) b)]                               \n                           [x (str (second p) (nth v y))]))\n        init (loop [x n r \"\"]\n               (if (>= x 1000)\n                 (recur (- x 1000) (str r \"M\"))\n                 [x r]))]\n    (second\n     (-> init\n         (trun 100 huns)\n         (trun 10 tens)\n         (trun 1 ones)))))","user":"541d3c0fe4b01498b1a71a7e"},{"code":"(let [places (sorted-map-by >\r\n                              1000 \"M\", 900 \"CM\", 500 \"D\", 400 \"CD\",\r\n                              100 \"C\", 90 \"XC\", 50 \"L\", 40 \"XL\",\r\n                              10 \"X\", 9 \"IX\", 5 \"V\", 4 \"IV\", 1 \"I\")]\r\n    (letfn [(place [[n acc] [pv s]]\r\n              (let [ct (quot n pv)]\r\n                (if (pos? ct)\r\n                  [(mod n pv) (concat acc (repeat ct s))]\r\n                  [n acc])))]\r\n      #(->> places\r\n            (reduce place [% '()])\r\n            second\r\n            (apply str))))","problem":104,"user":"4f047177535dcb61093f6bc6"},{"code":"(fn [i]\n    (let [m {0 [\"\" \"\" \"\"]\n             1 [\"M\" \"C\" \"X\" \"I\"]\n             2 [\"MM\" \"CC\" \"XX\" \"II\"]\n             3 [\"MMM\" \"CCC\" \"XXX\" \"III\"]\n             4 [\"MMMM\" \"CD\" \"XL\" \"IV\"]\n             5 [\"MMMMM\" \"D\" \"L\" \"V\"]\n             6 [\"MMMMMM\" \"DC\" \"LX\" \"VI\"]\n             7 [\"MMMMMMM\" \"DCC\" \"LXX\" \"VII\"]\n             8 [\"MMMMMMMM\" \"DCCC\" \"LXXX\" \"VIII\"]\n             9 [\"MMMMMMMMM\" \"CM\" \"XC\" \"IX\"]}\n         i (str i)\n         c (count i)\n         s (- 4 c)\n         e (+ s c)]\n      (apply str\n        (map #(get-in m [% %2])\n             (map #(- (int %) 48) i)\n             (range s e)))))","problem":104,"user":"4ee4f4a9535d1385b2869d85"},{"code":"(fn roman [n] \n        (cond (>= n 1000) (str \"M\" (roman (- n 1000)))\n              (>= n 900) (str \"CM\" (roman (- n 900)))\n              (>= n 500) (str \"D\" (roman (- n 500)))\n              (>= n 400) (str \"CD\" (roman (- n 400)))\n              (>= n 100) (str \"C\" (roman (- n 100)))\n              (>= n 90) (str \"XC\" (roman (- n 90)))\n              (>= n 50) (str \"L\" (roman (- n 50)))\n              (>= n 40) (str \"XL\" (roman (- n 40)))\n              (>= n 10) (str \"X\" (roman (- n 10)))\n              (>= n 9) (str \"IX\" (roman (- n 9)))\n              (>= n 5) (str \"V\" (roman (- n 5)))\n              (>= n 4) (str \"IV\" (roman (- n 5)))\n              (>= n 1) (str \"I\" (roman (- n 1)))\n              :otherwise \"\"))","problem":104,"user":"5294e44de4b02ebb4ef75016"},{"problem":104,"code":"(fn [i]\n  (let [romans (into (sorted-map) {1 \"I\" 4 \"IV\" 5 \"V\" 9 \"IX\" 10 \"X\" 40 \"XL\" 50 \"L\" 90 \"XC\" 100 \"C\" 400 \"CD\" 500 \"D\" 900 \"CM\" 1000 \"M\"})\n        find-highest (fn [i] (first (drop-while #(< i %) (reverse (keys romans)))))\n        roman-sequence (fn rs [i]\n                         (when-not (zero? i)\n                           (lazy-seq (let [h (find-highest i)] (cons h (rs (- i h)))))))]\n    (clojure.string/join (map #(get romans %) (roman-sequence i)))))","user":"586bc870e4b01531a375e964"},{"problem":104,"code":"(fn roman [n]\n  (cond (= n 0) \"\"\n        (<= n 3) (apply str (take n (repeatedly (constantly \"I\"))))\n        (= n 4) \"IV\"\n        (< 4 n 9) (str \"V\" (roman (- n 5)))\n        (= n 9) \"IX\"\n        (< 9 n 40) (str \"X\" (roman (- n 10)))\n        (< 39 n 50) (str \"XL\" (roman (- n 40)))\n        (< 49 n 90) (str \"L\" (roman (- n 50)))\n        (< 90 n 100) (str \"XC\" (roman (- n 90)))\n        (< 99 n 400) (str \"C\" (roman (- n 100)))\n        (< 399 n 500) (str \"CD\" (roman (- n 400)))\n        (< 499 n 900) (str \"D\" (roman (- n 500)))\n        (< 899 n 1000) (str \"CM\" (roman (- n 900)))\n        :else (str \"M\" (roman (- n 1000)))))","user":"534d1173e4b084c2834f4a98"},{"code":"(fn [n]\n  (let [t [[1000 \"M\"] [900 \"CM\"]\n           [500 \"D\"] [400 \"CD\"]\n           [100 \"C\"] [90 \"XC\"]\n           [50 \"L\"] [40 \"XL\"]\n           [10 \"X\"] [9 \"IX\"]\n           [5 \"V\"] [4 \"IV\"]\n           [1 \"I\"]]\n        lookup-largest (fn [n] (some #(if (<= (first %) n) % nil) t))]\n        (loop [n n, acc \"\"]\n          (if-let [e (lookup-largest n)]\n            (recur (- n (first e)) (str acc (second e)))\n            acc))))","problem":104,"user":"50d93c53e4b0fd36a4b89223"},{"problem":104,"code":"(fn [n]\n  (let [digit-places (map-indexed\n                      (fn [idx x]\n                        (vector\n                         (inc idx)\n                         (Character/digit x 10)))\n                      (reverse (str n)))\n        rn-layout    {0 \"\"\n                      1 \"x\"\n                      2 \"xx\"\n                      3 \"xxx\"\n                      4 \"xy\"\n                      5 \"y\"\n                      6 \"yx\"\n                      7 \"yxx\"\n                      8 \"yxxx\"\n                      9 \"xz\"}\n        rn-places    {4 [\"M\" \"\" \"\"]\n                      3 [\"C\" \"D\" \"M\"]\n                      2 [\"X\" \"L\" \"C\"]\n                      1 [\"I\" \"V\" \"X\"]}\n        rn-fn        (fn [digit x y z]\n                       (-> (get rn-layout digit)\n                           (clojure.string/replace \"x\" x)\n                           (clojure.string/replace \"y\" y)\n                           (clojure.string/replace \"z\" z)))]\n    (reduce\n     (fn [rn-str [place digit]]\n       (let [[x y z] (get rn-places place)]\n         (str (rn-fn digit x y z) rn-str)))\n     \"\"\n     digit-places)))","user":"51008b6fe4b0700a7a02d6e4"},{"code":"(partial\n  \n(fn [s x]\n  (let [m {1    \"I\" 4   \"IV\" 5   \"V\" 9   \"IX\"\n           10   \"X\" 40  \"XL\" 50  \"L\" 90  \"XC\"\n           100  \"C\" 400 \"CD\" 500 \"D\" 900 \"CM\"\n           1000 \"M\"}]\n    (if (= 0 x)\n      s\n      (let [n (apply max (filter #(<= % x) (keys m)))]\n        (recur (str s (m n)) (- x n)))))) \n\n\"\")","problem":104,"user":"4e6ebd4a535d5021c1a89610"},{"code":"(fn write-roman [num]\n  (if (= 0 num)\n    \"\"\n    (let [values {1000 \"M\" 900 \"CM\" 500 \"D\" 400 \"CD\"\n                  100 \"C\" 90 \"XC\" 50 \"L\" 40 \"XL\"\n                  10 \"X\" 9 \"IX\" 5 \"V\" 4 \"IV\"\n                  1 \"I\"}\n          repeat-string (fn [n s] (apply str (repeat n s)))\n          next-val (apply min-key first (sort-by second < (remove #(= 0 (first %)) (map (juxt (partial quot num) identity) (keys values)))))]\n      (str (repeat-string (first next-val) (values (second next-val))) (write-roman (rem num (second next-val)))))))","problem":104,"user":"4e89ff3d535d3e98b802328a"},{"problem":104,"code":"(fn dec-to-roman [d]\n  (let [cvt {1 \"I\", 2 \"II\", 3 \"III\", 4 \"IV\", 5 \"V\",\n             6 \"VI\", 7 \"VII\", 8 \"VIII\", 9 \"IX\",\n             10 \"X\", 20 \"XX\", 30 \"XXX\", 40 \"XL\", 50 \"L\",\n             60 \"LX\", 70 \"LXX\", 80 \"LXXX\", 90 \"XC\",\n             100 \"C\", 200 \"CC\", 300 \"CCC\", 400 \"CD\", 500 \"D\",\n             600 \"DC\", 700 \"DCC\", 800 \"DCCC\", 900 \"CM\",\n             1000 \"M\", 2000 \"MM\", 3000 \"MMM\"}\n        digits (mapv (fn [x] (mod x 10)) (take-while pos? (iterate #(quot % 10) d)))\n        tr-digit (fn [[res xfact] v] [(str (get cvt (* v xfact)) res) (* xfact 10)])]\n    (first (reduce tr-digit [\"\" 1] digits))))","user":"51b920bfe4b0e871ca4958f9"},{"problem":104,"code":"(fn\n  [n]\n  (letfn [(process-numeral\n           [arabic roman acc]\n           (loop\n             [acc-arabic (first acc)\n              acc-roman (second acc)]\n             (if (< acc-arabic arabic)\n               [acc-arabic acc-roman]\n               (recur\n                (- acc-arabic arabic)\n                (str acc-roman roman))\n               )\n             ))]\n    (->>\n     [n \"\"]\n     (process-numeral 1000 \"M\")\n     (process-numeral 900 \"CM\")\n     (process-numeral 500 \"D\")\n     (process-numeral 100 \"C\")\n     (process-numeral 90 \"XC\")\n     (process-numeral 50 \"L\")\n     (process-numeral 40 \"XL\")\n     (process-numeral 10 \"X\")\n     (process-numeral 9 \"IX\")\n     (process-numeral 5 \"V\")\n     (process-numeral 4 \"IV\")\n     (process-numeral 1 \"I\")\n     (second)\n    )))","user":"53ac4719e4b047364c04445c"},{"code":"(fn [n]\n  (let [nm {1 \"I\", 4 \"IV\", 5 \"V\", 9 \"IX\" 10 \"X\", 40 \"XL\", 50 \"L\", 90 \"XC\", 100 \"C\",\n            500 \"D\", 400 \"CD\", 900 \"CM\", 1000 \"M\"}\n        v (reverse (sort (keys nm)))]\n    (loop [c \"\" a n [v1 & r] v]\n      (cond\n        (zero? a) c\n        (>= a v1) (recur (str c (nm v1)) (- a v1) v)\n        :else\n        (recur c a r)))))","problem":104,"user":"528e64b7e4b0239c8a67aedd"},{"problem":104,"code":"(fn [n]\n  (last (reduce (fn [[rest result] [value numeral]]\n                 (if (zero? rest)\n                  [rest result]\n                  [(rem rest value) (apply str result (repeat (int (/ rest value)) numeral))])) \n          [n \"\"] \n          (reverse\n           (sorted-map 1000 \"M\", 900 \"CM\", 500 \"D\",\n            400 \"CD\", 100 \"C\", 90 \"XC\",\n            50 \"L\", 40 \"XL\", 10 \"X\", 9 \"IX\",\n            5 \"V\", 4 \"IV\", 1 \"I\", 0 \"\")))))","user":"5835cb06e4b089d5ab817cea"},{"code":"(fn wnum [n]\n    (let [r (sorted-map-by > 1000 \"M\" 900 \"CM\" 500 \"D\" 400 \"CD\" 100 \"C\"\n                           90 \"XC\" 50 \"L\" 40 \"XL\" 10 \"X\" 9 \"IX\" 5 \"V\" 4 \"IV\" 1 \"I\")       \n          m (some #(when (>= (- n %) 0) %) (keys r))]\n      (when-not (nil? m)\n        (str (r m) (wnum (- n m))))))","problem":104,"user":"52e3e6a8e4b09f7907dd1448"},{"problem":104,"code":"{1 \"I\" 30 \"XXX\" 4 \"IV\" 140 \"CXL\" 827 \"DCCCXXVII\" 3999 \"MMMCMXCIX\" 48 \"XLVIII\"}","user":"5a3c2a08e4b001c08efc0cdf"},{"problem":104,"code":"(fn [i-x]\n  (let [m [1 \\I 4 \"IV\" 5 \"V\" 9 \"IX\" 10 \\X 40 \"XL\" 50 \\L 90\n           \"XC\" 100 \\C 400 \"CD\" 500 \\D 900 \"CM\" 1000 \\M 4000]\n        pm (partition-all 2 m)\n        mm (map cons (map first pm) (cons nil pm))]\n    (loop [agg \"\" x i-x]\n       (if (zero? x)\n         agg\n         (let [[[_ n n-str]] (filter #(< x (first %)) mm)\n               part (repeat (quot x n) n-str)]\n           (recur (apply str agg part) (mod x n)))))))","user":"567d132ee4b05957ce8c61c3"},{"problem":104,"code":"(fn __ [n]\n   (letfn [(to-digits [n]\n             (for [digit-divisor [1000 100 10 1]]\n               (int (/ (mod n (* 10 digit-divisor)) digit-divisor))))\n           (to-roman [n [c & [p g]]]\n             (cond\n               (< n 4)\n                 (clojure.string/join (repeat n c))\n               (= n 4)\n                 (str c p)\n               (= n 5)\n               (str p)\n               (< n 9)\n                 (str p (clojure.string/join (repeat (mod n 5) c)))\n               (= n 9)\n                 (str c g)))]\n     (let [roman-data (reverse (concat (partition 3 2 [\"I\" \"V\" \"X\" \"L\" \"C\" \"D\" \"M\"]) '((\"M\"))))\n           n (to-digits n)]\n       (clojure.string/join (map to-roman n roman-data))\n     )))","user":"552d2e4fe4b076ab5578f7e1"},{"problem":104,"code":"(fn [n]\n  (let [letters \"IVXLCDM\"\n        g (fn [m]\n            (let [[a b c] (take 3 (drop (* 2 m) letters))]\n              (fn [x]\n                (cond\n                  (< x 4) (apply str (repeat x a))\n                  (= x 4) (str a b)\n                  (< x 9) (str b (apply str (repeat (- x 5) a)))\n                  (= x 9) (str a c)\n                )\n              )\n            )\n          )\n        ]\n    (apply str (reverse (for [m (range (count (str n)))]\n      (let [d {0 1 1 10 2 100 3 1000}]\n        ((g m) (rem (quot n (get d m)) 10))\n      )\n    )))\n  )\n)","user":"5943abb6e4b060784b3b792b"},{"code":"(let [numerals {1 \"I\", 4 \"IV\", 5 \"V\", 9 \"IX\", 10 \"X\", 40 \"XL\", 50 \"L\", 90 \"XC\", 100 \"C\", 400 \"CD\", 500 \"D\", 900 \"CM\", 1000 \"M\"}]\n  (fn to-roman [decimal]\n    (loop [[num & r :as nums] (reverse (sort (keys numerals)))\n           roman \"\"\n           d decimal]\n      (if num\n        (if (>= d num)\n          (recur nums (str roman (get numerals num)) (- d num))\n          (recur r roman d))\n        roman))))","problem":104,"user":"50d8de3fe4b01f0871336e72"},{"problem":104,"code":"(fn [i]\n  (let [m [ [1000 \"M\"] [900 \"CM\"] [500 \"D\"] [400 \"CD\"] [100 \"C\"] [90 \"XC\"] \n            [50 \"L\"] [40 \"XL\"] [10 \"X\"] [9 \"IX\"] [5 \"V\"] [4 \"IV\"] [1 \"I\"] ]\n        ]\n    (loop [ri i rm m res \"\"]\n      (if (= 0 ri)\n        res\n        (let [arb (first (first rm))\n              rom (second (first rm)) ]\n          (if (>= ri arb)\n            (recur (- ri arb) rm (str res rom) )\n            (recur ri (rest rm) res) ))))))","user":"53c1ce3ee4b00fb29b221268"},{"problem":104,"code":"(fn number->roman [nmb]\n  (letfn [(get-digits [x] (map #(Character/digit % 10) (str x)))\n          (digit->roman [d n-zeros]\n            (let [roman-dict [[\"I\" \"V\"]\n                              [\"X\" \"L\"]\n                              [\"C\" \"D\"]\n                              [\"M\"]]]\n              (apply str (cond\n                           (#{1 2 3} d) (->> (get-in roman-dict [n-zeros 0])\n                                             (repeat (rem d 5)))\n                           (#{6 7 8} d) (->> (get-in roman-dict [n-zeros 0])\n                                             (repeat (rem d 5))\n                                             (concat (get-in roman-dict [n-zeros 1])))\n                           (#{5} d) (get-in roman-dict [n-zeros 1])\n                           (#{4} d) (concat (get-in roman-dict [n-zeros 0])\n                                            (get-in roman-dict [n-zeros 1]))\n                           (#{9} d) (concat (get-in roman-dict [n-zeros 0])\n                                            (get-in roman-dict [(inc n-zeros) 0]))))))]\n    (let [digits (get-digits nmb)\n          n (count digits)\n          f (fn [i v] (digit->roman v (- n i 1)))]\n      (->> (keep-indexed f digits)\n           (apply str)))))","user":"5f82609ae4b0c071e6c840f9"},{"code":"(fn write-roman-numerals [n]\n  (clojure.pprint/cl-format nil \"~@R\" n))","problem":104,"user":"504f57c7e4b0a02f9cffde71"},{"code":"(fn write-roman-numeral [number]\n  (let [symbols-base-5 [\\V, \\L, \\D]\n        symbols-base-10 [\\I, \\X, \\C, \\M]\n        digits (fn digits [n]\n                 (if (> n 0) (conj (digits (int(/ n 10))) (mod n 10)) []))\n        digits-number (digits number)\n        num-digits (count digits-number)]\n    (->> (range num-digits)\n         (map (fn [index]\n                (let [digit (digits-number index)\n                      digit-index (dec (- num-digits index))\n                      next-digit-index (inc digit-index)\n                      symbol (fn [symbols digit-index]\n                               (if (> (count symbols) digit-index) (symbols digit-index) nil))\n                      symbol-1 (symbol symbols-base-10 digit-index)\n                      symbol-5 (symbol symbols-base-5 digit-index)\n                      symbol-10 (symbol symbols-base-10 next-digit-index)\n                      convert (fn convert [digit symbol-1 symbol-5 symbol-10]\n                                (cond (=  digit 9) [symbol-1 symbol-10]\n                                      (>= digit 5) (cons symbol-5 (convert (- digit 5) symbol-1 symbol-5 symbol-10))\n                                      (=  digit 4) [symbol-1 symbol-5]\n                                      :else       (repeat digit symbol-1)))]\n                  (convert digit symbol-1 symbol-5 symbol-10)\n                )))\n         (map #(clojure.string/join %))\n         (apply str)\n    )\n  )\n)","problem":104,"user":"5272d4b7e4b03e8d9a4a7453"},{"problem":104,"code":"(fn arabic-to-roman [n]\n  (cond\n   (= n 0) \"\"\n   (>= n 1000) (str \"M\" (arabic-to-roman (- n 1000)))\n   (>= n 900)  (str \"CM\" (arabic-to-roman (- n 900)))\n   (>= n 500)  (str \"D\" (arabic-to-roman (- n 500)))\n   (>= n 400)  (str \"CD\" (arabic-to-roman (- n 400)))\n   (>= n 100)  (str \"C\" (arabic-to-roman (- n 100)))\n   (>= n 90)   (str \"XC\" (arabic-to-roman (- n 90)))\n   (>= n 50)   (str \"L\" (arabic-to-roman (- n 50)))\n   (>= n 40)   (str \"XL\" (arabic-to-roman (- n 40)))\n   (>= n 10)   (str \"X\" (arabic-to-roman (- n 10)))\n   (>= n 9)    (str \"IX\" (arabic-to-roman (- n 9)))\n   (>= n 5)    (str \"V\" (arabic-to-roman (- n 5)))\n   (>= n 4)    (str \"IV\" (arabic-to-roman (- n 4)))\n   (>= n 1)    (str \"I\" (arabic-to-roman (- n 1)))))","user":"53791ab7e4b06839e8705e4d"},{"problem":104,"code":"(fn [n] \n   (let [m (quot n 1000) \n         c (quot (mod n 1000) 100) \n         x (quot (mod n 100) 10) \n         i (mod n 10) \n         single-rrm (fn [v small middle end] \n                      (cond (< v 4) (vec (repeat v small)) \n                            (= v 4) [small middle] \n                            (= v 5) [middle]\n                            (< 5 v 9) (concat [middle] (vec (repeat (- v 5) small)))\n                            (= v 9) [small end]))]\n     (->> (reduce #(concat %1 %2) \n             \"\" \n             (concat (single-rrm m \"M\" \"\" \"\") \n                       (single-rrm c \"C\" \"D\" \"M\") \n                       (single-rrm x \"X\" \"L\" \"C\") \n                       (single-rrm i \"I\" \"V\" \"X\")))\n          (apply str))))","user":"54848141e4b0e286459a119e"},{"problem":104,"code":"(fn [n]\n    (letfn [ (number-to-roman-numerals [n]\n               (cond \n                     (<= 1000 n) (cons \"M\" (number-to-roman-numerals (- n 1000)))\n                     (<= 900 n) (cons \"CM\" (number-to-roman-numerals (- n 900)))\n                     (<= 500 n) (cons \"D\" (number-to-roman-numerals (- n 500)))\n                     (<= 400 n) (cons \"CD\" (number-to-roman-numerals (- n 400)))\n                     (<= 100 n) (cons \"C\" (number-to-roman-numerals (- n 100)))\n                     (<= 90 n) (cons \"XC\" (number-to-roman-numerals (- n 90)))\n                     (<= 50 n) (cons \"L\" (number-to-roman-numerals (- n 50)))\n                     (<= 40 n) (cons \"XL\" (number-to-roman-numerals (- n 40)))\n                     (<= 10 n) (cons \"X\" (number-to-roman-numerals (- n 10)))\n                     (<= 9 n) (cons \"IX\" (number-to-roman-numerals (- n 9)))\n                     (<= 5 n) (cons \"V\" (number-to-roman-numerals (- n 5)))\n                     (<= 4 n) (cons \"IV\" (number-to-roman-numerals (- n 4)))\n                     (<= 1 n) (cons \"I\" (number-to-roman-numerals (- n 1))))) ]\n      (apply str (number-to-roman-numerals n))\n      ))","user":"55aa1637e4b0988bba2ad949"},{"code":"#(loop [i % n [[1000 \\M] [900 \"CM\"] [500 \\D] [400 \"CD\"] [100 \\C] [90 \"XC\"] [50 \\L] [40 \"XL\"] [10 \\X] [9 \"IX\"] [5 \\V] [4 \"IV\"] [1 \\I]] o \"\"]\r\n  (cond\r\n    (= i 0) o\r\n    (> (ffirst n) i) (recur i (rest n) o)\r\n\t\t:else (recur (- i (ffirst n)) n (str o (fnext (first n))))))","problem":104,"user":"4e8a460e535d65386fec2109"},{"problem":104,"code":"#(let [t [\"\" \"M\" \"MM\" \"MMM\" \"MMMM\"]\n       h [\"\" \"C\" \"CC\" \"CCC\" \"CD\" \"D\" \"DC\" \"DCC\" \"DCCC\" \"CM\"]\n       d [\"\" \"X\" \"XX\" \"XXX\" \"XL\" \"L\" \"LX\" \"LXX\" \"LXXX\" \"XC\"]\n       u [\"\" \"I\" \"II\" \"III\" \"IV\" \"V\" \"VI\" \"VII\" \"VIII\" \"IX\"]]\n       (str\n        (-> % (quot 1000) t)\n        (-> % (mod 1000) (quot 100) h)\n        (-> % (mod 100) (quot 10) d)\n        (-> % (mod 10) u)\n       )\n      )","user":"5c379636e4b0d62ef62d9f76"},{"code":"(fn f [n]\n  (let [\n    thousands (quot n 1000)\n    hundreds (mod (quot n 100) 10)\n    tens (mod (quot n 10) 10)\n    ones (mod n 10) ]\n    (str\n      (get [\"\" \"M\" \"MM\" \"MMM\" \"MMMM\"] thousands)\n      (get [\"\" \"C\" \"CC\" \"CCC\" \"CD\" \"D\" \"DC\" \"DCC\" \"DCCC\" \"CM\"] hundreds)\n      (get [\"\" \"X\" \"XX\" \"XXX\" \"XL\" \"L\" \"LX\" \"LXX\" \"LXXX\" \"XC\"] tens)\n      (get [\"\" \"I\" \"II\" \"III\" \"IV\" \"V\" \"VI\" \"VII\" \"VIII\" \"IX\"] ones))))","problem":104,"user":"4e8b98fc535d65386fec2124"},{"problem":104,"code":"(let\n    [numerals\n     (sorted-map 1 \"I\", 5 \"V\", 10 \"X\", 50 \"L\", 100 \"C\", 500 \"D\", 1000 \"M\")\n     subtrahend [1 10 100]]\n  (fn q4q104 [n]\n    \"Write n in roman numerals\"\n    ((fn numeral [n-i rn]\n       (if (zero? n-i)\n         rn\n         (let [[v num] (first (rsubseq numerals <= n-i))\n               [vu numu] (first (subseq numerals > n-i))\n               sh (when-not (nil? vu) (first (filter #(< % vu) (reverse subtrahend))))\n               q       (quot n-i v)]\n           (if (and\n                (not (nil? vu))\n                (not (nil? sh))\n                (>= n-i (- vu sh)))\n             (recur (- n-i (- vu sh)) (apply str rn (get numerals sh) numu))\n             (recur (- n-i (* v q)) (apply str rn (repeat q num))) )))) n \"\")))","user":"52213426e4b0e6a83c8925c4"},{"problem":104,"code":"(fn [v]\n  (let [buckets [[1000 (iterate #(str \\M %) \"\")]\n                 [100 [\"\" \"C\" \"CC\" \"CCC\" \"CD\" \"D\" \"DC\" \"DCC\" \"DCCC\" \"CM\"]]\n                 [10  [\"\" \"X\" \"XX\" \"XXX\" \"XL\" \"L\" \"LX\" \"LXX\" \"LXXX\" \"XC\"]]\n                 [1   [\"\" \"I\" \"II\" \"III\" \"IV\" \"V\" \"VI\" \"VII\" \"VIII\" \"IX\"]]]]\n    (first (reduce (fn [[s r] [d p]]\n                     (if (< r d) [s r]\n                       (let [v (int (/ r d))]\n                         [(str s (nth p v))\n                          (- r (* d v))])))\n                     [\"\" v]\n                     buckets))))","user":"537e745ae4b06839e8705ea6"},{"code":"(fn [n]\n  (let [ns [[\\M 1000] [\\D 500] [\\C 100] [\\L 50] [\\X 10] [\\V 5] [\\I 1]]\n        con (fn [s n ns]\n              (if (empty? ns) s\n                (let [[d i] (first ns)\n                      r (quot n i)]\n                  (recur\n                    (apply str s (repeat r d))\n                    (- n (* i r))\n                    (rest ns)))))]\n    (clojure.string/replace\n      (con \"\" n ns)\n      #\"D?CCCC|L?XXXX|V?IIII\"\n      #(condp = (first %)\n        \\D \"CM\"\n        \\C \"CD\"\n        \\L \"XC\"\n        \\X \"XL\"\n        \\V \"IX\"\n        \\I \"IV\"))))","problem":104,"user":"4fce5474e4b0d4b2a7a9d451"},{"problem":104,"code":"(fn [x]\n   (first (reduce (fn\n              [[l m] [y x]]\n              [(str l (apply str (repeat (quot m y) x))) (rem m y)]) [nil x]\n    [[1000 \\M] [900 \"CM\"] [500 \\D] [400 \"CD\"] [100 \\C] [90 \"XC\"] [50 \\L] [40 \"XL\"] [10 \\X] [9 \"IX\"] [5 \\V] [4 \"IV\"] [1 \\I]])))","user":"541735b3e4b01498b1a71a07"},{"code":"(fn dec->roman [x]\n  (let [decs [1000 900  500 400  100 90   50  40   10  9    5   4    1]\n        roms [\"M\"  \"CM\" \"D\" \"DC\" \"C\" \"XC\" \"L\" \"XL\" \"X\" \"IX\" \"V\" \"IV\" \"I\"]\n        dict (zipmap decs roms)\n        freqs (second (reduce (fn [[rm acc] v] [(mod rm v) (assoc acc v (quot rm v))]) [x {}] decs))]\n    (apply str (mapcat #(repeat (freqs %) (dict %)) decs))))","problem":104,"user":"536d83cee4b0fc7073fd6e5e"},{"problem":104,"code":"(fn p104 [x]\n  (let [numerals (into (sorted-map) {1 \"I\" 4 \"IV\" 5 \"V\" 9 \"IX\" 10 \"X\"\n                                    40 \"XL\" 50 \"L\" 90 \"XC\" 100 \"C\"\n                                    400 \"CD\" 500 \"D\" 900 \"CM\" 1000 \"M\"})]\n    (cond (= x 0) \"N\"\n          (and (< x 0) (> x 3999)) nil\n          :else (->> (rseq numerals)\n                     (reduce \n                       (fn [[r acc] [v c]] \n                         (let [n (quot r v)] [(- r (* n v)) (conj acc (repeat n c))]))\n                       [x []])\n                     (second)\n                     (apply concat)\n                     (clojure.string/join \"\")))))","user":"55645592e4b0c656e3ff1802"},{"problem":104,"code":"(fn [x]\n  (let \n    [getNumber (fn [x div]\n                 (read-string \n                   (str \n                     (get (apply str (reverse (str x))) div))))\n     numbers {3 {1 \"M\" 2 \"MM\" 3 \"MMM\" 4 \"MMMM\" 5 \"MMMMM\" 6 \"MMMMMM\" 7 \"MMMMMMM\" 8 \"MMMMMMMM\" 9 \"MMMMMMMMM\"}\n              2 {1 \"C\" 2 \"CC\" 3 \"CCC\" 4 \"CD\" 5 \"D\" 6 \"DC\" 7 \"DCC\" 8 \"DCCC\" 9 \"CM\"}\n              1 {1 \"X\" 2 \"XX\" 3 \"XXX\" 4 \"XL\" 5 \"L\" 6 \"LX\" 7 \"LXX\" 8 \"LXXX\" 9 \"XC\"}\n              0 {1 \"I\" 2 \"II\" 3 \"III\" 4 \"IV\" 5 \"V\" 6 \"VI\" 7 \"VII\" 8 \"VIII\" 9 \"IX\"}}\n     getString (fn [numberOf div] \n                 (get (get numbers div) numberOf))]\n    (apply str\n      (reverse\n        (for [i (range 0 (count (str x)))]\n          (getString (getNumber x i) i))))))","user":"575683aee4b02ea1147992dc"},{"problem":104,"code":"(fn [n]\n   (let [ fe [ [1000 \"M\"] [900 \"CM\"] [500 \"D\"] [400 \"CD\"] [100 \"C\"] [90 \"XC\"] [50 \"L\"]\n               [40 \"XL\"] [10 \"X\"] [9 \"IX\"] [5 \"V\"] [4 \"IV\"][1 \"I\"] ]\n           g (fn [n] (loop [[f & xs] fe]\n                       (if f (if (>= n (first f)) f (recur xs)) nil)))] \n         (apply str (loop [ n n re []]\n                (let [ t (g n)]\n                   (if t (recur (- n (first t)) (conj re  (second t))) re))))))","user":"5dc12b0ae4b0e59a23173d84"},{"problem":104,"code":"(fn [n]\n  (let [k [[1000 \"M\"] [900 \"CM\"] [500 \"D\"] [100 \"C\"] [90 \"XC\"] [50 \"L\"] [40 \"XL\"] [10 \"X\"] [9 \"IX\"] [5 \"V\"] [4 \"IV\"] [1 \"I\"]]]\n    (loop [acc [] n n]\n      (if (zero? n) (apply str acc)\n                    (let [[d r] (first (drop-while #(< n (first %)) k))]\n                      (recur (conj acc r) (- n d)))))))","user":"5310e968e4b08068f379ecdd"},{"code":"(fn roman [n]\n   (let [rs {1 \"I\", 5 \"V\", 10 \"X\", 50 \"L\", 100 \"C\", 500 \"D\", 1000, \"M\" }]\n     (letfn [(ptrn [v k] (cond (or(= k 1000)(< v 4)) (apply str(take v (iterate identity (get rs k))))\n                               (or(= v 4)(= v 9)) (str(get rs k)(get rs (* (inc v) k))) \n                               (= v 5) (str(get rs (* v k))) \n                               :else (str (get rs (* 5 k)) (ptrn (- v 5) k))\n                                )\n             )]\n       (loop [x n y []]\n         (let [tens (int(Math/pow 10 (dec(count (str x))))) xquot (quot x tens)]\n           (if (<= x 0) (apply str y)\n\t\t\t\t(recur (- x (* xquot tens)) (conj y (ptrn xquot tens)))\n             )\n           )\n         )\n       )\n     )\n   )","problem":104,"user":"5274eb56e4b03e8d9a4a74bb"},{"code":"(fn [n]\n  (let [roman { 1 \\I 4 \"IV\" 5 \\V 9 \"IX\" 10 \\X 40 \"XL\" 50 \\L 90 \"XC\" 100 \\C 400 \"CD\" 500 \\D 900 \"CM\" 1000 \\M }]\n    (loop [res [], n n, k (sort-by - (keys roman))]\n      (cond\n        (= 0 n) (apply str res)\n        (>= n (first k)) (recur (conj res (roman (first k))) (- n (first k)) k)\n        :else (recur res n (rest k))))))","problem":104,"user":"4fdec88fe4b05e33b9224f8e"},{"code":"(fn [n]\r\n  (clojure.string/join\r\n    (flatten (filter not-empty (second (reduce (fn [[i c] [l x]] [(rem i x) (conj c (repeat (quot i x) l))]) [n []]\r\n                                '([\"M\" 1000] [\"CM\" 900] [\"D\" 500] [\"CD\" 500] [\"C\" 100] [\"XC\" 90] [\"L\" 50] [\"XL\" 40] [\"X\" 10] [\"IX\" 9] [\"V\" 5] [\"IV\" 4] [\"I\" 1])\r\n                             ))))))","problem":104,"user":"4fe900a6e4b0547ebccb243a"},{"problem":104,"code":"(fn roman [x]\n  (cond\n    (<= 1000 x) (str \"M\" (roman (- x 1000)))\n    (<= 900 x) (str \"CM\" (roman (- x 900)))\n    (<= 500 x) (str \"D\" (roman (- x 500)))\n    (<= 400 x) (str \"CD\" (roman (- x 400)))\n    (<= 100 x) (str \"C\" (roman (- x 100)))\n    (<= 90 x) (str \"XC\" (roman (- x 90)))\n    (<= 50 x) (str \"L\" (roman (- x 50)))\n    (<= 40 x) (str \"XL\" (roman (- x 40)))\n    (<= 10 x) (str \"X\" (roman (- x 10)))\n    (<= 9 x) (str \"IX\" (roman (- x 9)))\n    (<= 5 x) (str \"V\" (roman (- x 5)))\n    (<= 4 x) (str \"IV\" (roman (- x 4)))\n    (<= 1 x) (str \"I\" (roman (- x 1)))\n    true \"\"))","user":"6011b89ee4b074f607df66bc"},{"problem":104,"code":"(fn [a] (let [abc { 1 [\"I\" \"X\" \"C\" \"M\"] 2 [\"II\" \"XX\" \"CC\" \"MM\"] 3 [\"III\" \n\"XXX\" \"CCC\" \"MMM\"] 4 [\"IV\" \"XL\" \"CD\"] 5 [\"V\" \"L\" \"D\"] 6 [\"VI\" \"LX\" \"DC\"] 7 \n[\"VII\" \"LXX\" \"DCC\"] 8 [\"VIII\" \"LXXX\" \"DCCC\"] 9 [\"IX\" \"XC\" \"CM\"] 0 [\"\" \"\" \"\" \n\"\"] } digits (reverse (map read-string (re-seq #\".\" (str a))))] (->> digits \n(map-indexed (fn [i d] (get-in abc [d i]))) (reverse) (clojure.string/join \n\"\"))))","user":"59358f74e4b04f87174def52"},{"code":"(fn roman [n]\n  (let [numerials [[1000 \"M\"] [900 \"CM\"] [500 \"D\"] [400 \"CD\"] [100 \"C\"] [90 \"XC\"] [50 \"L\"] [40 \"XL\"] [10 \"X\"] [9 \"IX\"] [5 \"V\"] [4 \"IV\"] [1 \"I\"]]\n        next-biggest (fn [n] (->> numerials (filter #(<= (first %) n)) first))]\n    (loop [n n s \"\"]\n      (if (= n 0)\n        s\n        (let [[v k] (next-biggest n)]\n          (recur (- n v) (str s k)))))))","problem":104,"user":"53513d28e4b084c2834f4ae3"},{"problem":104,"code":"(fn [n]\n  (cond \n   (= n 1) \"I\"\n   (= n 4) \"IV\"\n   (= n 30) \"XXX\"\n   (= n 48) \"XLVIII\"\n   (= n 140) \"CXL\"\n   (= n 827) \"DCCCXXVII\"\n   (= n 3999) \"MMMCMXCIX\"\n   :else :bad-input))","user":"5547bcf2e4b0a04f79299551"},{"code":"(fn roman [x]\n  (let [rom (rseq (sorted-map 1000 \"M\" 900 \"CM\" 500 \"D\"\n                              400 \"CD\" 100 \"C\" 90 \"XC\" \n                              50 \"L\" 40 \"XL\" 10 \"X\" 9 \"IX\" \n                              5 \"V\" 4 \"IV\" 1 \"I\"))]\n    (loop [i x \n           r \"\"]\n      (if (zero? i)\n        r\n        (let [[v s]\n              (first (filter (fn [[k v]] (<= k i)) rom))]\n          (recur (- i v) (str r s)))))))","problem":104,"user":"50e4f4e9e4b049a987753896"},{"problem":104,"code":"(fn to-roman[num]\n  (let [digits (reverse (->>(seq (str num)) (mapv #(Integer/parseInt (str %)))))\n        bases  (reverse [1000 100 10 1])\n        dada (fn [n one five ten]\n               (cond\n                 (zero? n) \"\" \n                 (< 0 n 4) (clojure.string/join (repeat n one))\n                 (= 4 n) (str one five)\n                 (= 5 n) five\n                 (= 9 n) (str one ten)\n                 :else (str five (clojure.string/join (repeat (- n 5) one)))))\n        dudu (fn[n base]\n               (case base\n                 1   (dada n \"I\" \"V\" \"X\")\n                 10  (dada n \"X\" \"L\" \"C\")\n                 100 (dada n \"C\" \"D\" \"M\")\n                 (clojure.string/join (repeat n \"M\"))))]                         \n    (clojure.string/join (reverse (map dudu digits bases)))))","user":"52f426fce4b05e3f0be25f1e"},{"problem":104,"code":"(fn [n]\n  (let [nm (into (zipmap (reductions * 1 (cycle [5 2])) \"IVXLCDM\")\n        {4 \"IV\" 9 \"IX\" 40 \"XL\" 90 \"XC\" 400 \"CD\" 900\"CM\"})]\n    (loop [r n s \"\"]\n      (if (zero? r) s\n        (let [i (apply max (filter #(>= r %) (keys nm)))]\n          (recur (- r i) (str s (nm i))))\n        ))))","user":"53e745a1e4b036ad0777e479"},{"problem":104,"code":"(fn [n]\n  (let [roman2num {\\I 1,\\V 5,\\X 10,\\L 50,\\C 100,\\D 500,\\M 1000}\n        roman-order {\\I nil,\\V \\I,\\X \\V,\\L \\X,\\C \\L,\\D \\C,\\M \\D}\n        roman-order-a {\\I \\V,\\V \\X,\\X \\L,\\L \\C,\\C \\D,\\D \\M}\n        specials {\"VIV\" \"IX\", \"LXL\" \"XC\" ,\"DCD\" \"CM\"}\n        rep-specias (fn [s]\n                      (reduce (fn [init [k v]]\n                                (clojure.string/replace init k v))\n                              s\n                              specials))\n        r2m (fn [n]\n              (loop [m {}\n                     order \\M\n                     n n]\n                (if (= n 0)\n                  m\n                  (recur (assoc m order (quot n (roman2num order)))\n                         (roman-order order)\n                         (mod n (roman2num order))))))]\n                       \n    (->> (r2m n)\n         (map (fn [[order cnt]]\n          (cond\n            (= 0 cnt) nil\n            (= 4 cnt) [order (roman-order-a order)]\n            :else (repeat cnt order))))\n         (reverse)\n         (apply concat)\n         (apply str)\n         (rep-specias))))","user":"536f871de4b0fc7073fd6e7f"},{"problem":104,"code":"(fn [n] \n  (loop [tmpn n s \"\"]\n    (if (= 0 tmpn)\n      s\n      (if (> tmpn 999)\n        (recur (- tmpn 1000) (str s \"M\"))\n        (if (> tmpn 899)\n          (recur (- tmpn 900) (str s \"CM\"))\n          (if (> tmpn 499)\n            (recur (- tmpn 500) (str s \"D\"))\n            (if (> tmpn 399) \n              (recur (- tmpn 400) (str s \"CD\"))\n              (if (> tmpn 99)\n                (recur (- tmpn 100) (str s \"C\"))\n                (if (> tmpn 89)\n                  (recur (- tmpn 90) (str s \"XC\"))\n                  (if (> tmpn 49)\n                    (recur (- tmpn 50) (str s \"L\"))\n                    (if (> tmpn 39)\n                      (recur (- tmpn 40) (str s \"XL\"))\n                      (if (> tmpn 9)\n                        (recur (- tmpn 10) (str s \"X\"))\n                        (if (> tmpn 8)\n                          (recur (- tmpn 9) (str s \"IX\"))\n                          (if (> tmpn 4)\n                            (recur (- tmpn 5) (str s \"V\"))\n                            (if (> tmpn 3)\n                              (recur (- tmpn 4) (str s \"IV\"))\n                              (recur (- tmpn 1) (str s \"I\")))))))))))))))))","user":"59368ccae4b02506e01a297a"},{"problem":104,"code":"(let [roman-list\n      [[1000 \"M\"]\n       [900 \"CM\"]\n       [500 \"D\"]\n       [400 \"CD\"]\n       [100 \"C\"]\n       [90 \"XC\"]\n       [50 \"L\"]\n       [40 \"XL\"]\n       [10 \"X\"]\n       [9 \"IX\"]\n       [5 \"V\"]\n       [4 \"IV\"]\n       [1 \"I\"]]]\n  (fn write-roman\n    [n]\n    (clojure.string/join\n      (loop [curr n\n                 accum []\n                 rlist roman-list]\n            (if (empty? rlist) accum\n                (let [[rn rs] (first rlist)]\n                  (if (>= curr rn)\n                    (recur (- curr rn) (conj accum rs) rlist)\n                    (recur curr accum (rest rlist)))))))))","user":"58152157e4b0f478707a0631"},{"problem":104,"code":"(fn f [x]\n    (let [tx (zipmap [1000 500 100 50 10 5 1] \"MDCLXVI\")\n          st (fn [z] (cond\n                       (= z 4) [1 5]\n                       (= z 9) [1 10]\n                       (< z 4) (vec (repeat z 1))\n                       (> z 5) (into [5] (repeat (- z 5) 1))\n                       ))]\n      (->>\n        (map #(- (int %) 48) (seq (str x)))   ;; Convert to seq\n        vec\n        (map st)\n        reverse\n        (map #(map (partial * %1) %2) [1 10 100 1000])\n        reverse\n        flatten\n        (replace tx)\n        (clojure.string/join)\n        )\n      )\n    )","user":"596d630ae4b069c0a1a19846"},{"problem":104,"code":"(fn wrn[n]\n  (let [rc {1 \"I\", \n            4 \"IV\", \n            5 \"V\", \n            9 \"IX\", \n            10 \"X\", \n            40 \"XL\", \n            50 \"L\" , \n            90 \"XC\", \n            100 \"C\", \n            400 \"CD\",  \n            500 \"D\", \n            900 \"CM\", \n            1000 \"M\"}\n        un [1000 900 500 400 100 90 50 40 10 9 5 4 1]]\n    (if (zero? n) \n      \"\"\n      (let [sn (get \n                 (vec \n                   (filter \n                     #(>= (- n %) 0) \n                     un)) \n                   0)]\n      (str \n        (get rc sn) \n        (wrn (- n sn)))))))","user":"54d4bd2be4b0a52adc2e2005"},{"code":"(fn [num]\n  (->>\n    num\n    str\n    reverse\n    (map #(- (int %) 48))\n    (map-indexed\n      (fn [index digit]\n        (let [roman {0 [\\I \\V \\X]\n                     1 [\\X \\L \\C]\n                     2 [\\C \\D \\M]\n                     3 [\\M]}\n              [n n5 n10] (roman index)]\n          (cond\n            (< digit 4) (repeat digit n)\n            (= digit 4) [n n5]\n            (< digit 9) (cons n5 (repeat (- digit 5) n))\n            :else [n n10]))))\n    reverse\n    (apply concat)\n    (apply str)))","problem":104,"user":"4f725466e4b07046d9f4f030"},{"problem":104,"code":"(fn r\n  ([n] (r n \"\"))\n  ([n s]\n    (if (= n 0) s\n      (let [Ns [\n            [1000 \"M\"] [900 \"CM\"] [500 \"D\"] [400 \"CD\"]\n            [100 \"C\"] [90 \"XC\"] [50 \"L\"] [40 \"XL\"]\n            [10 \"X\"] [9 \"IX\"] [5 \"V\"] [4 \"IV\"] [1 \"I\"]]\n          [a b] (some #(when (<= (first %) n) %) Ns)]\n        (r (- n a) (str s b))))))","user":"53500869e4b084c2834f4ad3"},{"code":"(fn roman-numerals [n]\n    (if \n      (zero? n) \"\"\n      (let [conversions [\n                         [1000 \"M\"]\n                         [900 \"CM\"]\n                         [500 \"D\"]\n                         [400 \"CD\"]\n                         [100 \"C\"]\n                         [90 \"XC\"]\n                         [50 \"L\"]\n                         [40 \"XL\"]\n                         [10 \"X\"]\n                         [9 \"IX\"]\n                         [5 \"V\"]\n                         [4 \"IV\"]\n                         [1 \"I\"]]\n            [arabic roman] (first (filter #(>= n (first %)) conversions))]\n        (str roman (roman-numerals (- n arabic))))))","problem":104,"user":"50d86fe2e4b01f0871336e67"},{"code":"(fn roma [n]\n  (let [ mp [\n      [1000 \"M\"] [900 \"CM\"] [500 \"D\"] [400 \"CD\"] [100 \"C\"] [90 \"XC\"]\n      [50 \"L\"] [40 \"XL\"] [10 \"X\"] [9 \"IX\"] [5 \"V\"] [4 \"IV\"] [1 \"I\" ]\n    ]\n    [[k v] & _ :as kv] (filter #(>= n (first %)) mp)\n    ]\n    (if (empty? kv) \"\" \n      (str v (roma (- n k))))))","problem":104,"user":"50901b2ee4b0ea685a20f774"},{"code":"(fn [n]\n  (letfn [(digits [n]\n            (->> (str n)\n              reverse\n              (map #(Integer/parseInt (str %)))))]\n    (apply str\n      (reverse\n        (map \n          nth\n          [[\"\" \"I\" \"II\" \"III\" \"IV\" \"V\" \"VI\" \"VII\" \"VIII\" \"IX\"]\n           [\"\" \"X\" \"XX\" \"XXX\" \"XL\" \"L\" \"LX\" \"LXX\" \"LXXX\" \"XC\"]\n           [\"\" \"C\" \"CC\" \"CCC\" \"CD\" \"D\" \"DC\" \"DCC\" \"DCCC\" \"CM\"]\n           [\"\" \"M\" \"MM\" \"MMM\"]]\n          (digits n))))))","problem":104,"user":"4f9d53f3e4b0dcca54ed6d21"},{"problem":104,"code":"(fn [input]\n   (let [numerals {1000 \"M\" 500 \"D\" 100 \"C\" 50 \"L\" 10 \"X\" 5 \"V\" 1 \"I\"}\n         subtrahends '(1 10 100 1000)\n         closest-numeral (fn closest-numeral ([i xs] (closest-numeral i xs (* i 2)))\n                           ([i xs minuend] (reduce (fn [c x] (if (> (Math/abs (- i c)) (Math/abs (- i (- minuend x)))) x c)) xs)))]\n     (apply str (map (fn [d] (get numerals d))\n                     ((fn r [in]\n                        (let [closest (closest-numeral in (keys numerals))\n                              closest-subtrahend (if (empty? (filter #(<= closest (* % 10)) subtrahends)) nil\n                                                                                                          (closest-numeral in (filter #(<= closest (* % 10)) subtrahends) closest))\n                              cp (if (pos? in) (reduce max (filter #(<= % in) (keys numerals))) nil)]\n                          (cond (zero? in) '()\n                                (some #{in} (keys numerals)) (list in)\n                                (pos? (- in closest)) (cons closest (r (- in closest)))\n                                (and (> (- closest closest-subtrahend) cp) (>= in (- closest closest-subtrahend))) (cons closest-subtrahend (cons closest (r (- in (- closest closest-subtrahend)))))\n                                :else (cons cp (r (- in cp)))))) input)))))","user":"4e9ff8d0535d7eef3080729c"},{"problem":104,"code":"(fn [arabic]\n  (loop [a arabic,\n         r \"\"]\n    (cond\n     (>= a 1000) (recur (- a 1000) (.concat r \"M\"))\n     (>= a 900) (recur (- a 900) (.concat r \"CM\"))\n     (>= a 500) (recur (- a 500) (.concat r \"D\"))\n     (>= a 400) (recur (- a 400) (.concat r \"CD\"))\n     (>= a 100) (recur (- a 100) (.concat r \"C\"))\n     (>= a 90) (recur (- a 90) (.concat r \"XC\"))\n     (>= a 50) (recur (- a 50) (.concat r \"L\"))\n     (>= a 40) (recur (- a 40) (.concat r \"XL\"))\n     (>= a 10) (recur (- a 10) (.concat r \"X\"))\n     (>= a 9) (recur (- a 9) (.concat r \"IX\"))\n     (>= a 5) (recur (- a 5) (.concat r \"V\"))\n     (>= a 4) (recur (- a 4) (.concat r \"IV\"))\n     (>= a 1) (recur (- a 1) (.concat r \"I\"))\n     :else r)))","user":"4f856adfe4b033992c121c44"},{"code":"(fn roman [x] (cond\n    (<= 1000 x) (str \"M\" (roman (- x 1000)))\n    (<= 900 x) (str \"CM\" (roman (- x 900)))\n    (<= 500 x) (str \"D\" (roman (- x 500)))\n    (<= 400 x) (str \"CD\" (roman (- x 400)))\n    (<= 100 x) (str \"C\" (roman (- x 100)))\n    (<= 90 x) (str \"XC\" (roman (- x 90)))\n    (<= 50 x) (str \"L\" (roman (- x 50)))\n    (<= 40 x) (str \"XL\" (roman (- x 40)))\n    (<= 10 x) (str \"X\" (roman (- x 10)))\n    (<= 9 x) (str \"IX\" (roman (- x 9)))\n    (<= 5 x) (str \"V\" (roman (- x 5)))\n    (<= 4 x) (str \"IV\" (roman (- x 4)))\n    (<= 1 x) (str \"I\" (roman (- x 1)))\n    true \"\"))","problem":104,"user":"51cbdee1e4b08d8387cbede1"},{"code":"#(loop [n % [k v & r] '(1000 M, 900 CM, 500 D, 100 C, 90 XC, 50 L, 40 XL, 10 X, 9 IX, 5 V, 4 IV 1 I) a \"\"]\n    (if (pos? n)\n      (let [q (quot n k)]\n        (recur (- n (* q k)) r (apply str a (repeat q v))))\n      a))","problem":104,"user":"4f956072e4b0dcca54ed6ccf"},{"code":"(fn [x]\n  (let [m (sorted-map 1000 \"M\" 900 \"CM\" 500 \"D\" 400 \"CD\" 100 \"C\" 90 \"XC\"\n                      50 \"L\" 40 \"XL\" 10 \"X\" 9 \"IX\" 5 \"V\" 4 \"IV\" 1 \"I\")]\n    (loop [x x s \"\"]\n       (if (zero? x) s\n           (let [k (last (filter #(<= %1 x) (keys m)))] (recur (- x k) (str s (m k))))))))","problem":104,"user":"504e04a4e4b078edc5f59397"},{"code":"(fn roman [n]\n  (if (zero? n)\n    \"\"\n    (let\n      [\n        m {1 \"I\" 4 \"IV\" 5 \"V\" 9 \"IX\" 10 \"X\" 40 \"XL\" 50 \"L\" 90 \"XC\" 100 \"C\" 500 \"D\" 900 \"CM\" 1000 \"M\"}\n        k (apply max (filter #(<= %1 n) (keys m)))\n      ]\n      (str (m k) (roman (- n k)))\n    )\n  )\n)","problem":104,"user":"507eddf4e4b06ce648bcdbfa"},{"code":"(fn q104 [n]\n  (let [ d1   [\"\" \"I\" \"II\" \"III\" \"IV\" \"V\" \"VI\" \"VII\" \"VIII\" \"IX\" ]\n         tr   (fn [s m] (reduce #(apply clojure.string/replace % %2) s m))\n         v    (fn [m] (vec (map #(tr % m) d1)))\n         d10  (v [[\\X \\C] [\\I \\X] [\\V \\L]])\n         d100 (v {\\I \\C, \\V \\D, \\X \\M})\n         d1000 (v {\\I \\M})\n         digits (fn [n] (map #(- (int %) (int \\0)) (str n))) ]\n   (apply str (reverse (map #(%2 %) (reverse (digits n)) [d1 d10 d100 d1000])))))","problem":104,"user":"4fd22e70e4b04c3a95aa041c"},{"code":"(fn rrm [n]\n  (let [m (quot n 1000) c (quot (mod n 1000) 100) x (quot (mod n 100) 10) i (mod n 10)\n        single-rrm (fn [v small middle end]\n                       (cond (< v 4) (vec (repeat v small))\n                             (= v 4) [small middle]\n                             (= v 5) [middle]\n                             (< 5 v 9) (concat [middle] (vec (repeat (- v 5) small)) )\n                             (= v 9) [small end]\n                             ))  ]\n    (reduce #(.concat %1 %2) \"\" (concat (single-rrm m \"M\" \"\" \"\") (single-rrm c \"C\" \"D\" \"M\") (single-rrm x \"X\" \"L\" \"C\") (single-rrm i \"I\" \"V\" \"X\"))\n    )  ))","problem":104,"user":"4ec5bec6535d6d7199dd36b3"},{"problem":104,"code":"(fn roman-nummbers\n  [num]\n  (let [literals {1 \"I\",4 \"IV\", 5 \"V\",9 \"IX\", 10 \"X\", 40 \"XL\", 50 \"L\",90 \"XC\",\n                  100 \"C\", 400 \"CD\", 500 \"D\", 900 \"CM\", 1000 \"M\"}\n        powers (keys literals)\n        biggest-divider (fn [x] (last (sort (filter #(<= % x) powers))))]\n        (loop [rem num out \"\"]\n          (if (= rem 0)\n            out\n            (let [divider (biggest-divider rem)\n                  res (quot rem divider)\n                  cur (* res divider)]\n              (recur\n                (- rem cur)\n                (apply str out (repeat res (get literals divider))))\n              ))\n          )\n    ))","user":"5545477fe4b0a04f79299531"},{"code":"(fn [n]\n           (let [m '((1000 \"M\" )\n                (900  \"CM\")\n                (500  \"D\" )\n                (400  \"CD\")\n                (100  \"C\" )\n                (90   \"XC\")\n                (50   \"L\" )\n                (40   \"XL\")\n                (10   \"X\" )\n                (9    \"IX\")\n                (5    \"V\" )\n                (4    \"IV\") \n                (1    \"I\" ))\n                ]\n                (apply str (loop [q n\n                              roman \"\"]\n                              (if (zero? q)\n                                  roman\n                                  (let [r (->> (map #(array-map (quot q (first %)) %) \n                                                    m)\n                                               (split-with #(zero? (key (first %))))\n                                               (last)\n                                               (first))\n                            \n                                       k (key (first r))\n                                       l (first (get r k))\n                                       v (last (get r k))\n                                       ]\n                                       (recur (mod q l) (concat roman (take (* k (count v)) (cycle v))))))))))","problem":104,"user":"4f03f197535dcb61093f6b84"},{"problem":104,"code":"(fn [v-num]\n  (let [replace-map {#\"XXXX\" \"XL\"\n                     #\"IIII\" \"IV\"\n                     #\"CCCC\" \"CM\"}]\n    (letfn [(get-char [num]\n              (condp <= num\n                1000 [\"M\" (- num 1000)]\n                900 [\"CM\" (- num 900)]\n                500 [\"D\" (- num 500)]\n                400 [\"CD\" (- num 400)]\n                100 [\"C\" (- num 100)]\n                90 [\"XC\" (- num 90)]\n                50 [\"L\" (- num 50)]\n                40 [\"XL\" (- num 40)]\n                10 [\"X\" (- num 10)]\n                9 [\"IX\" (- num 9)]\n                5 [\"V\" (- num 5)]\n                4 [\"IV\" (- num 4)]\n                1 [\"I\" (dec num)]\n                0 [0 0]))\n            (get-str [v-num]\n                     (if (= 3999 v-num)\n                       \"MMMCMXCIX\"\n                       (let [y (get-char v-num)]\n                         (loop [res [y], num (get-char (last y))]\n                           (if-not (pos? (second (last res)))\n                             (reduce (fn [str- [char- _]] (str str- char-)) \"\" res)\n                             (do (println \"--\" res)\n                                 (recur (conj res num) (get-char (second num)))))))))]\n      (loop [res (get-str v-num), replace-k (keys replace-map)]\n        (if (empty? replace-k)\n          res\n          (recur (clojure.string/replace res (first replace-k) (replace-map (first replace-k))) (rest replace-k)))))))","user":"5cf72682e4b0b71b1d808a68"},{"problem":104,"code":"(fn roman [n]\n  (condp <= n\n   1000 (str \"M\" (roman (- n 1000)))\n   900 (str \"CM\" (roman (- n 900)))\n   500 (str \"D\" (roman (- n 500)))\n   400 (str \"CD\" (roman (- n 400)))\n   100 (str \"C\" (roman (- n 100)))\n   90 (str \"XC\" (roman (- n 90)))\n   50 (str \"L\" (roman (- n 50)))\n   40 (str \"XL\" (roman (- n 40)))\n   10 (str \"X\" (roman (- n 10)))\n   9 (str \"IX\" (roman (- n 9)))\n   5 (str \"V\" (roman (- n 5)))\n   4 (str \"IV\" (roman (- n 4)))\n   1 (str \"I\" (roman (- n 1)))\n   \"\"))","user":"55c4e48be4b0e31453f649a7"},{"problem":104,"code":"#(let [value (sorted-map-by > 1000 \"M\" 900 \"CM\" 500 \"D\" 400 \"CD\" 100 \"C\" 90 \"XC\" 50 \"L\" 40 \"XL\" 10 \"X\" 9 \"IX\" 5 \"V\" 4 \"IV\" 1 \"I\")\n       lookup (fn [v] (first (filter (fn [[k _]] (>= v k)) value)))]\n  (loop [total %\n         numerals \"\"]\n    (if (> 1 total)\n      numerals\n      (recur (- total (first (lookup total))) (str numerals (second (lookup total)))))))","user":"56d63729e4b0ea9b8538f7ca"},{"problem":104,"code":"(fn [n]\n    (let\n      [roman {1 \"I\"  5 \"V\" 10 \"X\" 50 \"L\" 100 \"C\" 500 \"D\" 1000 \"M\"\n              4 \"IV\" 9 \"IX\" 40 \"XL\" 90 \"XC\" 400 \"CD\" 900 \"CM\"}]\n      (loop [work n output \"\"]\n        (if (zero? work) output\n          (let [largest (apply max (filter (fn [r] (<= r work)) (keys roman)))]\n            (recur (- work largest) (str output (roman largest)))))\n      )\n    ))","user":"5bc9e3e9e4b07a9b28b100e2"},{"code":"(let\n  [rm-vals [[\"M\" 1000] [\"CM\" 900] [\"D\" 500] [\"CD\" 400] [\"C\" 100] [\"XC\" 90]\n            [\"L\" 50] [\"XL\" 40] [\"X\" 10] [\"IX\" 9] [\"V\" 5] [\"IV\" 4] [\"I\" 1]]]\n  (fn [x]\n    (loop [x x, s \"\"]\n      (if (= 0 x)\n        s\n        (let [[k v] (some (fn [[k v]] (when (<= v x) [k v])) rm-vals)]\n          (recur (- x v) (str s k)))))))","problem":104,"user":"510acd6ee4b078ea719210f4"},{"code":"(fn [n]\n  (letfn [(f [r]\n            (.replaceAll\n              (.replaceAll\n                (.replaceAll\n                  (.replaceAll\n                    (.replaceAll\n                      (.replaceAll\n                        r\n                        \"CCCC\" \"CD\")\n                      \"XXXX\" \"XL\")\n                    \"IIII\" \"IV\")\n                  \"DCD\" \"CM\")\n                \"LXL\" \"XC\")\n              \"VIV\", \"IX\"))]\n    (loop [n n r \"\"]\n      (cond\n        (>= n 1000) (recur (- n 1000) (str r \"M\"))\n        (>= n 500) (recur (- n 500) (str r \"D\"))\n        (>= n 100) (recur (- n 100) (str r \"C\"))\n        (>= n 50) (recur (- n 50) (str r \"L\"))\n        (>= n 10) (recur (- n 10) (str r \"X\"))\n        (>= n 5) (recur (- n 5) (str r \"V\"))\n        (>= n 1) (recur (- n 1) (str r \"I\"))\n        :else (f r)))))","problem":104,"user":"4dbdc9da535d020aff1edf4c"},{"problem":104,"code":"(fn [n]\n  (second (letfn [(roman [i v x xi]\n                      ([[i] [i] [i i] [i i i] [i v] [v] [v i] [v i i] [v i i i] [i x]] xi))]\n              (reduce\n               (fn [[x s] [base f]]\n                 (let [u (rem x base) v (int (/ x base))]\n                   (if (zero? v)\n                     [u s]\n                     [u (str s (apply str (f v)))])))\n               [n \"\"]\n               [[1000 #(repeat % \\M)]\n                [100 (partial roman \\C \\D \\M)]\n                [10 (partial roman \\X \\L \\C)]\n                [1 (partial roman \\I \\V \\X)]]))))","user":"58ca8a1de4b03c36ff7e5835"},{"problem":104,"code":"(fn translate [number]\n  (let [digits (fn [n] (map #(Character/digit % 10) (str n)))\n        conv (fn [n r1 r5 r10]\n               (cond\n                 (= n 0) []\n                 (= n 1) [r1]\n                 (= n 2) [r1 r1]\n                 (= n 3) [r1 r1 r1]\n                 (= n 4) [r1 r5]\n                 (= n 5) [r5]\n                 (= n 6) [r5 r1]\n                 (= n 7) [r5 r1 r1]\n                 (= n 8) [r5 r1 r1 r1]\n                 (= n 9) [r1 r10]))]\n    (apply str (apply concat (reverse\n                              (map (fn [d seq] (apply conv d seq))\n                                   (reverse (digits number))\n                                   [[\\I \\V \\X] [\\X \\L \\C] [\\C \\D \\M] [\\M \\Z \\Z]]))))))","user":"6042219ae4b04b4f332c3e72"},{"code":"(fn [n]\n  (str \n    (nth [\"\" \"M\" \"MM\" \"MMM\"] (quot n 1000))\n    (nth [\"\" \"C\" \"CC\" \"CCC\" \"CD\" \"D\" \"DC\" \"DCC\" \"DCCC\" \"CM\"] (mod (quot n 100) 10))\n    (nth [\"\" \"X\" \"XX\" \"XXX\" \"XL\" \"L\" \"LX\" \"LXX\" \"LXXX\" \"XC\"] (mod (quot n 10) 10))\n    (nth [\"\" \"I\" \"II\" \"III\" \"IV\" \"V\" \"VI\" \"VII\" \"VIII\" \"IX\"] (mod n 10))))","problem":104,"user":"4f9120d8e4b0dcca54ed6c96"},{"problem":104,"code":"(fn to-roma [num]\n  (let [syms [\"M\" \"CM\" \"D\" \"CD\" \"C\" \"XC\" \"L\" \"XL\" \"X\" \"IX\" \"V\" \"IV\" \"I\"]\n        vals [1000 900 500 400 100 90 50 40 10 9 5 4 1]\n        v2s (zipmap vals syms)]\n    (when (>= num 1)\n      (let [off (some #(when (<= % num) %) vals)]\n        (str (v2s off) (to-roma (- num off)))))))","user":"5b13ba71e4b0cc2b61a3be53"},{"code":"(fn [n] (apply str (reverse (map #(%2 %1)\n         (map #(read-string (str %)) (reverse (str n))) \n         [{0 \"\" 1 \"I\" 2 \"II\" 3 \"III\" 4 \"IV\" 5 \"V\" 6 \"VI\" 7 \"VII\" 8 \"VIII\" 9 \"IX\"}\n          {0 \"\" 1 \"X\" 2 \"XX\" 3 \"XXX\" 4 \"XL\" 5 \"L\" 6 \"LX\" 7 \"LXX\" 8 \"LXXX\" 9 \"XC\"}\n          {0 \"\" 1 \"C\" 2 \"CC\" 3 \"CCC\" 4 \"CD\" 5 \"D\" 6 \"DC\" 7 \"DCC\" 8 \"DCCC\" 9 \"CM\"}\n          #(apply str (repeat % \"M\"))]))))","problem":104,"user":"524be8e0e4b09eba1c0223f1"},{"problem":104,"code":"(fn roman [x]\n  (let [romans {1 \"I\", 4 \"IV\", 5 \"V\", 9 \"IX\", 10 \"X\", 40 \"XL\", 50 \"L\", 90 \"XC\", 100 \"C\", 400 \"CD\", 500 \"D\", 900 \"CM\", 1000 \"M\"}\n        y (last (filter #(<= % x) (sort (keys romans))))]\n    (if (= x y)\n      (romans y)\n      (str (romans y) (roman (- x y)))\n    )))","user":"57e139f6e4b0bfb2137f5a6c"},{"problem":104,"code":"(fn [n]\n  (apply str (first \n              (reduce\n               (fn [[acc n] [d l]]\n                 [(concat acc (repeat (quot n d) l)) (rem n d)])\n               [[] n]\n               [[1000 \\M] [900 \"CM\"] [500 \\D] [400 \"CD\"] [100 \\C] [90 \"XC\"] [50 \\L] [40 \"XL\"] [10 \\X] [9 \"IX\"] [5 \\V] [4 \"IV\"] [1 \\I]]\n               ))))","user":"567c63f6e4b05957ce8c61bb"},{"code":"(fn [number]\n  (loop [in number [l v & rest] [\"M\" 1000 \"CM\" 900 \"D\" 500 \"CD\" 400 \"C\" 100 \"XC\" 90  \"L\" 50 \"XL\" 40 \"X\" 10 \"IX\" 9 \"V\" 5 \"IV\" 4 \"I\" 1] out []]\n    (if l\n      (recur (mod in v) rest (concat out (repeat (quot in v) l)))\n      (apply str out))))","problem":104,"user":"4f04b66b535dcb61093f6bdd"},{"problem":104,"code":"(fn to-roman [n]\n  (let [roman-mapping (sorted-map-by > 1000 \"M\", 900 \"CM\", 500 \"D\", 400 \"CD\", 100 \"C\", 90 \"XC\", 50 \"L\", 40 \"XL\", 10 \"X\", 9 \"IX\", 5 \"V\", 4 \"IV\", 1 \"I\")]\n    (second (reduce (fn [[n acc] k] \n              (vector (mod n k) \n                      (str acc (apply str (repeat (int (Math/floor (/ n k))) (roman-mapping k)))))) \n            [n \"\"] \n            (keys roman-mapping)))))","user":"53fcdd1ae4b0de5c418485dd"},{"problem":104,"code":"(fn toroman [num]\n  (let [vals {1000 \"M\", 900 \"CM\", 500 \"D\", 400 \"CD\", 100 \"C\", 90 \"XC\" 50 \"L\", 40 \"XL\", 10 \"X\", 9 \"IX\", 5 \"V\", 4 \"IV\", 1 \"I\"}\n        ks (sort > (keys vals))]\n    (loop [n num\n           v ()]\n      (if (= 0 n)\n        (clojure.string/join (reverse v))\n        (let [p (first (filter #(>= n %) ks))]\n          (recur (- n p) (cons (get vals p) v)))))))","user":"5d1bbef0e4b02ea6f0fb6984"},{"code":"(fn [n](let[m (reverse(sort-by key {1000 \"M\" 900 \"CM\" 500 \"D\" 400 \"CD\" 100 \"C\"90 \"XC\" 50 \"L\" 40 \"XL\" 10 \"X\" 9 \"IX\" 5 \"V\" 4 \"IV\" 1 \"I\"}))](loop[n n cs[]](let[[[x c] & _](drop-while #(< n(key %))m)](if x(recur(- n x)(conj cs c))(apply str cs))))))","problem":104,"user":"4dd4034a535dae65d5c462df"},{"problem":104,"code":"(fn to-roman-numerals\n  [n]\n  (loop [res \"\" val n]\n    (cond\n      (>= val 1000) (recur (str res \"M\") (- val 1000))\n      (>= val 900) (recur (str res \"CM\") (- val 900))\n      (>= val 800) (recur (str res \"DCCC\") (- val 800))\n      (>= val 700) (recur (str res \"DCC\") (- val 700))\n      (>= val 600) (recur (str res \"DC\") (- val 600))\n      (>= val 500) (recur (str res \"D\") (- val 500))\n      (>= val 400) (recur (str res \"CD\") (- val 400))\n      (>= val 300) (recur (str res \"CCC\") (- val 300))\n      (>= val 200) (recur (str res \"CC\") (- val 200))\n      (>= val 100) (recur (str res \"C\") (- val 100))\n      (>= val 90) (recur (str res \"XC\") (- val 90))\n      (>= val 80) (recur (str res \"LXXX\") (- val 80))\n      (>= val 70) (recur (str res \"LXX\") (- val 70))\n      (>= val 60) (recur (str res \"LX\") (- val 60))\n      (>= val 50) (recur (str res \"L\") (- val 50))\n      (>= val 40) (recur (str res \"XL\") (- val 40))\n      (>= val 30) (recur (str res \"XXX\") (- val 30))\n      (>= val 20) (recur (str res \"XX\") (- val 20))\n      (>= val 10) (recur (str res \"X\") (- val 10))\n      (>= val 9) (recur (str res \"IX\") (- val 9))\n      (>= val 8) (recur (str res \"VIII\") (- val 8))\n      (>= val 7) (recur (str res \"VII\") (- val 7))\n      (>= val 6) (recur (str res \"VI\") (- val 6))\n      (>= val 5) (recur (str res \"V\") (- val 5))\n      (>= val 4) (recur (str res \"IV\") (- val 4))\n      (>= val 3) (recur (str res \"III\") (- val 3))\n      (>= val 2) (recur (str res \"II\") (- val 2))\n      (>= val 1) (recur (str res \"I\") (- val 1))\n      :else res\n      )\n    )\n  )","user":"5c20b6abe4b07e362c230576"},{"code":"#(loop [i %\n        o \"\"]\n   (cond\n    (= 0 i) o\n    (>= i 1000)(recur (- i 1000)(str o \"M\"))\n    (>= i 900) (recur (- i 900) (str o \"CM\"))\n    (>= i 500) (recur (- i 500) (str o \"D\"))\n    (>= i 100) (recur (- i 100) (str o \"C\"))\n    (>= i 90)  (recur (- i 90)  (str o \"XC\"))\n    (>= i 40)  (recur (- i 40)  (str o \"XL\"))\n    (>= i 10)  (recur (- i 10)  (str o \"X\"))\n    (>= i 9)   (recur (- i 9)   (str o \"IX\"))\n    (>= i 5)   (recur (- i 5)   (str o \"V\"))\n    (>= i 4)   (recur (- i 4)   (str o \"IV\"))\n    (>= i 1)   (recur (- i 1)   (str o \"I\"))\n   )\n )","problem":104,"user":"51f28a64e4b0210f90e7454e"},{"problem":104,"code":"(fn [x]\n  (let [digits (map #(- (int %) (int \\0)) (reverse (str x)))  \n        dcc (fn dc [[s1 s2 s3] x] \n              (let [r (mod x 5) b (quot (inc x) 5)]   \n               \t(str  \n                  (if (= r 4) s1)          \n                  ([\"\" s2 s3] b)\n                  (if (< r 4) (apply str (repeat r s1))))))\n        simbols [\\I \\V \\X \\L \\C \\D \\M \"\" \"\"]]\n    (apply str (reverse (map #(dcc (take 3 (drop %2 simbols)) %) \n      digits (range 0 7 2))))    \n  )    \n)","user":"533ea7e8e4b085b17e897d94"},{"code":"(fn write-roman [integer]\n   (let [numbers [1000 500 100 50 10 5 1]\n         translation {1000 \\M\n                      500  \\D\n                      100  \\C\n                      50   \\L\n                      10   \\X\n                      5    \\V\n                      1    \\I}\n         subtractive {\"VIIII\" \"IX\"\n                      \"IIII\"  \"IV\"\n                      \"LXXXX\" \"XC\"\n                      \"XXXX\"  \"XL\"\n                      \"DCCCC\" \"CM\"\n                      \"CCCC\"  \"CD\"}]\n     (loop [string []\n            number integer]\n       (if (= 0 number)\n         (clojure.string/replace\n           (apply str string)\n           #\"V?IIII|L?XXXX|D?CCCC\"\n           #(subtractive %))\n         (let [maximal (first (drop-while #(> % number) numbers))\n               its-char (translation maximal)]\n           (recur (conj string its-char)\n                  (- number maximal)))))))","problem":104,"user":"4f35b2ace4b0e243712b1ec5"},{"code":"(fn roo [num] \n        (:str\n         (reduce (fn [acc [n char]] \n                     (let [quot (int (/ (:remain acc) n))]\n                          {:remain (- (:remain acc) (* quot n))\n                          :str (apply str (:str acc) (repeat quot char))}))\n                 {:str \"\" :remain num} \n                 (partition 2 '(1000 \"M\" 900 \"CM\" 500 \"D\" \n                   400 \"CD\" 100 \"C\" 90 \"XC\" 50 \"L\" 40 \"XL\" \n                   10 \"X\" 9 \"IX\" 5 \"V\" 4 \"IV\" 1 \"I\")))))","problem":104,"user":"502a4fdfe4b09dd42f6f3644"},{"problem":104,"code":"(fn cntr [x]\n  (apply str \n     (let [[mq mr] [(quot x 1000) (rem x 1000)]\n           [dq dr] [(quot mr 500) (rem mr 500)]\n           [cq cr] [(quot dr 100) (rem dr 100)]\n           [lq lr] [(quot cr 50) (rem cr 50)]\n           [xq xr] [(quot lr 10) (rem lr 10)]\n           [vq vr] [(quot xr 5) (rem xr 5)]]\n       (cond\n         (> mq 0) (cons \\M (cntr (- x 1000)))\n         (and (= dq 1) (= cq 4)) (cons \\C (cons \\M (cntr (- x 900))))         \n         (> dq 0) (cons \\D (cntr (- x 500)))\n         (= cq 4) (cons \\C (cons \\D (cntr (- x 400))))\n         (> cq 0) (cons \\C (cntr (- x 100)))\n         (and (= lq 1) (= xq 4)) (cons \\X (cons \\C (cntr (- x 90))))         \n         (> lq 0) (cons \\L (cntr (- x 50)))\n         (= xq 4) (cons \\X (cons \\L (cntr (- x 40))))\n         (> xq 0) (cons \\X (cntr (- x 10)))\n         (and (= vq 1) (= vr 4)) \"IX\"\n         (> vq 0) (cons \\V (cntr (- x 5)))\n         (= vr 4) \"IV\"\n         (= vr 3) \"III\"\n         (= vr 2) \"II\"\n         (= vr 1) \"I\"))))","user":"5d02fe44e4b0cc9c915881c0"},{"code":"(fn fin-rom [x]\n  {:pre [(<= x 3999)]}\n  (letfn [(roms [x]\n                ({1 \\I 5 \\V 10 \\X 50 \\L 100 \\C 500 \\D 1000 \\M} x))\n          (topars [x]\n                  (reverse (map vector (reverse (into [] (map (comp read-string str) (seq (str x)))))  (iterate #(* % 10) 1))))\n          (translate [v]\n                     (let [f (first v)]\n                       (cond\n                         (<= f 3) (reduce str  (repeat f (roms (second v))))\n                         (= f 4)  (str (translate [1 (second v)]) (translate [(inc f) (second v)]))\n                         (= f 5) (str  (roms (* (first v) (second v))))\n                         (<= f 8) (str (translate [5 (second v)]) (translate [(- f 5) (second v)]))\n                         (= f 9) (str (translate [1 (second v)]) (translate [1 (* 10 (second v))])))))]\n           (str (reduce str (map translate (topars x))))))","problem":104,"user":"50e87427e4b0ebbe794eb7e8"},{"code":"(fn [v]\n  (let [th (quot v 1000)\n        hu (quot (mod v 1000) 100)\n        te (quot (mod v 100) 10)\n        on (mod v 10)\n        ths (apply str (repeat th \"M\"))\n        hus ({9 \"CM\", 8 \"DCCC\", 7 \"DCC\", 6 \"DC\", 5 \"C\", 4 \"CD\", 3 \"CCC\", 2 \"CC\", 1 \"C\"} hu \"\")\n        tes ({9 \"XC\", 8 \"LXXX\", 7 \"LXX\", 6 \"LX\", 5 \"L\", 4 \"XL\", 3 \"XXX\", 2 \"XX\", 1 \"X\"} te \"\")\n        ons ({9 \"IX\", 8 \"VIII\", 7 \"VII\", 6 \"VI\", 5 \"V\", 4 \"IV\", 3 \"III\", 2 \"II\", 1 \"I\"} on \"\")]\n    (str ths hus tes ons)))","problem":104,"user":"4ec07699535dfed6da9c6da2"},{"problem":104,"code":"(fn [n] (let [m [[1000 \"M\"] [900 \"CM\"] [500 \"D\"] [400 \"CD\"] [100 \"C\"] [90 \"XC\"] [50 \"L\"] [40 \"XL\"] [10 \"X\"] [9 \"IX\"] [5 \"V\"] [4 \"IV\"] [1 \"I\"]]] (apply str (reduce concat (second (reduce #(if (< (first %1) (first %2)) [(first %1) (second %1)] [(rem (first %1) (first %2)) (concat (second %1) (repeat (quot (first %1) (first %2)) (second %2)))]) [n \"\"] m))))))","user":"58987ee9e4b00487982d52d2"},{"problem":104,"code":"(fn [d] (let [roman [ '[0 I II III IV V VI VII VIII IX]\n                       '[0 X XX XXX XL L LX LXX LXXX XC]\n                       '[0 C CC CCC CD D DC DCC DCCC CM]\n                       '[0 M MM MMM MMMM MMMMM] ] ]\n         (->> (loop [d d r []] (if (>= 0 d) r (recur (long (/ d 10)) (conj r (mod d 10)) ) ))\n              (map (fn [r i] (nth r i)) roman) (filter #(not= '0 %)) reverse (reduce str \"\")\n           )\n))","user":"55adf4d7e4b03311e7b732af"},{"problem":104,"code":"(fn [n]\n  (letfn [(r-digit [d t f i]\n            (case d\n              0 nil\n              1 i\n              2 [i i]\n              3 [i i i]\n              4 [i f]\n              5 f\n              6 [f i]\n              7 [f i i]\n              8 [f i i i]\n              9 [i t]))]\n    (let [cs [[\\X \\V \\I] [\\C \\L \\X] [\\M \\D \\C]]]\n      (->> n str\n           (map #(- (int %) 48))\n           (map-indexed #(let [p (- (count (str n)) % 1)]\n                           (if (< p 3)\n                             (apply r-digit %2 (cs p))\n                             (repeat %2 \\M))))\n           flatten\n           (apply str)))))","user":"5953bdb6e4b066ee0a44aeed"},{"code":"(fn roman [n]\n  (let [roman-map (sorted-map 1 \"I\",\n                              4 \"IV\"\n                              5 \"V\",\n                              9 \"IX\",\n                              10 \"X\",\n                              40 \"XL\",\n                              50 \"L\",\n                              90 \"XC\",\n                              100 \"C\",\n                              400 \"CD\",\n                              500 \"D\",\n                              900 \"CM\",\n                              1000 \"M\")\n        next-value (fn [n] (ffirst (rsubseq roman-map\n                                            <=\n                                            n)))\n        next-chunk (fn [n] (roman-map (next-value n)))]\n    (loop [result \"\"\n           curr n]\n      (if (zero? curr)\n        result\n        (recur (str result (next-chunk curr))\n               (- curr (next-value curr)))))))","problem":104,"user":"530578ede4b0d8b024fd3760"},{"problem":104,"code":"(fn [n]\n  (let [nums {1 \"I\" 4 \"IV\" 5 \"V\" 9 \"IX\" 10 \"X\"\n            40 \"XL\" 50 \"L\" 90 \"XC\" 100 \"C\"\n            400 \"CD\" 500 \"D\" 900 \"CM\" 1000 \"M\"}]\n    (loop [acc []\n           x n]\n      (if (= 0 x)\n        (clojure.string/join \"\" acc)\n        (let [next-num (apply max (filter #(<= % x) (keys nums)))]\n          (recur (conj acc (nums next-num)) (- x next-num)))))))","user":"54be7772e4b0ed20f4ff6eea"},{"code":"(fn write-roman [n]\n  (let [split-digits \n          (fn [n] (map #(Integer/parseInt (str %)) (str n)))\n        digits (into [] (reverse (split-digits n)))\n        process-place\n          (fn [n one-sym five-sym ten-sym]\n            (cond\n              (= n nil) \"\"\n              (<= n 3) (apply str (take n (repeat one-sym)))\n              (= n 4) (str one-sym five-sym)\n              (< n 9) (apply str five-sym (take (- n 5) (repeat one-sym)))\n              (= n 9) (str one-sym ten-sym)))]\n    (str (process-place (get digits 3) \"M\" \"M\" \"M\")\n         (process-place (get digits 2) \"C\" \"D\" \"M\")\n         (process-place (get digits 1) \"X\" \"L\" \"C\")\n         (process-place (get digits 0) \"I\" \"V\" \"X\"))))","problem":104,"user":"52463059e4b09dbe66b56198"},{"code":"(fn [num]\n  (let [svm (into (sorted-map-by >) {1000 \"M\", 500 \"D\", 350 \"LC\", 100 \"C\", 50 \"L\", 40 \"XL\", 10 \"X\", 5 \"V\", 4 \"IV\", 1 \"I\", 9 \"IX\", 900 \"CM\", 90 \"XC\"})]\n    (letfn [(rn [r o]\n              (if (= r 0)\n                o\n                (let [d (first (filter #(<= (first %) r) svm))]\n                  (rn (- r (first d)) (str o (second d))))))]\n      (rn num \"\"))))","problem":104,"user":"504ec4d3e4b069badc5a33c9"}]