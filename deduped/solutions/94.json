[{"code":"(fn [strings]\n  (letfn [\n           (point-halo [[x y]]\n             ; Returns a set of the eight points surrounding [x y].\n             (set (for [dx [-1 0 1] dy [-1 0 1] :when (not= [dx dy] [0 0])]\n                   [(+ x dx) (+ y dy)])))\n\n           (halo [points]\n             ; Returns a seq of [x y] points, each of which is in the point-halo\n             ; of one or more of the given points, excluding those among the\n             ; given points.\n             (->> points\n                  (map point-halo)\n                  (apply concat)\n                  (remove (set points))))\n\n           (num-neighbors [points p]\n             ; Returns the number of members of points that are among the\n             ; eight points surrounding p.\n             (count (filter (point-halo p) points)))\n\n           (having-neighbors [points pred ps]\n             ; Returns a seq of the members of ps, each of whose number of\n             ; neighbors (among points) satisfies the given predicate.\n             (filter (comp pred (partial num-neighbors points)) ps))\n\n           (next-gen [points]\n             ; Returns a new seq of [x y] points representing the next\n             ; \"generation\" produced from the given points.\n             (concat (having-neighbors points #{2 3} points)\n                     (having-neighbors points #{3} (halo points))))\n\n           (strings-to-points [strings]\n             ; Converts the given vector of strings to a seq of [x y] points.\n             ; The points are exactly those for which x-th character of the y-th\n             ; string is not a space character.\n             (for [[st row] (map vector strings (range))\n                   [ch col] (map vector st (range))\n                   :when (not= \\space ch)\n                   ]\n               [col row]))\n\n           (points-to-strings [char cols rows points]\n             ; Returns a vector of strings representing a grid measuring cols\n             ; by rows positions. Each [col row] point will be represented as\n             ; character char at the col-th position in the row-th string of\n             ; the result.\n             (let [blank-row (vec (take cols (repeat \\space)))\n                   blank-board (vec (take rows (repeat blank-row)))\n                   ]\n               (->> points\n                    (reduce (fn [board [c r]] (assoc-in board [r c] char))\n                            blank-board)\n                    (map (partial reduce str)))))\n           ]\n\n    (->> strings\n         strings-to-points\n         next-gen\n         (points-to-strings \\# (count (first strings)) (count strings)))\n    ))","problem":94,"user":"533b57c3e4b0e30313ee6ccc"},{"code":"(fn next-move-4clojure\n  [old-matrix]\n  (let [get-neighbours-position (fn get-neighbours-position [my-x my-y size-x size-y]\n  (for [x [(dec my-x) my-x (inc my-x)]\n        y [(dec my-y) my-y (inc my-y)]\n        :when (and (> x -1)\n                   (> y -1)\n                   (< x size-x)\n                   (< y size-y)\n                   (or (not= x my-x) (not= y my-y)))]\n                   (vector x y)))\n      alive? (fn alive? [matrix x y]\n  (if (= \\# (get-in matrix [y x]))\n    true false))\n      count-true (fn count-true [x]\n  (loop [sum 0 thruths x]\n    (if (= 0  (count thruths))\n      sum (recur \n            (if (first thruths)\n              (inc sum) sum)\n            (rest thruths)))))]\n      (let [count-alive (fn count-alive\n  [matrix x y]\n  (let [neighbours-position (get-neighbours-position x y (count (first matrix)) (count matrix))]\n    (count-true (for [position neighbours-position]\n                (alive? matrix (first position) (second position))))))]\n        (let [next-position? (fn next-position? [matrix x y]\n  (let [count-alive (count-alive matrix x y)]\n    (or (= 3 count-alive) (and (= 2 count-alive) (alive? matrix x y)))))]\n          (let [x-size (count (last old-matrix)) y-size (count old-matrix)]\n    (loop [new-matrix (vec (repeat y-size (vec (repeat x-size \\space))))\n          x 0\n          y 0]\n          (let [new-x (if (= (inc x) x-size) 0 (inc x))\n                new-y (if (= (inc x) x-size) (inc y) y)]\n            (if (and (= y-size y)\n                   (= x-size y))\n            (for [index new-matrix] (apply str index)) (if (next-position? old-matrix x y)\n                        (recur (assoc-in new-matrix [y x] \\#) new-x new-y)\n                        (recur new-matrix new-x new-y))))))))))","problem":94,"user":"4e16bdef535d04ed9115e7e9"},{"code":"(let [alive? (fn [board x y] (= (nth (nth board y) x) \\#))\n       dead? (comp not alive?)]\n   (fn [board]\n     (for [y (range (count board))]\n       (->> (for [x (range (count (nth board y)))]\n              (let [neighbours (reduce + 0 (for [dx [-1, 0, 1]\n                                                 dy [-1, 0, 1]\n                                                 :when (and (not (and (zero? dx) (zero? dy)))\n                                                            (> (+ x dx) 0) (> (+ y dy) 0)\n                                                            (< (+ x dx) (count (nth board y)))\n                                                            (< (+ y dy) (count board)))]\n                                             (if (alive? board\n                                                         (+ x dx)\n                                                         (+ y dy))\n                                               1\n                                               0)))]\n                (if (alive? board x y)\n                  (cond\n                   (< neighbours 2) \\space\n                   (= neighbours 2) \\#\n                   (= neighbours 3) \\#\n                   :else \\space)\n                  (if (= neighbours 3)\n                    \\#\n                    \\space))))\n            (apply str)))))","problem":94,"user":"4eae5fe4535d7eef30807325"},{"code":"(fn [b]\n    (map-indexed\n      (fn [i r]\n        (apply str\n               (map-indexed\n                 (fn [j c]\n                   (->> (for [i [-1 0 1] j [-1 0 1] :when (not= [i j] [0 0])] [i j])\n                     (map (partial map + [i j]))\n                     (filter (fn [[k l]] (and (< -1 k (count b)) (< -1 l (count (first b))))))\n                     (map (fn [[k l]] ((vec (b k)) l)))\n                     (filter (partial = \\#))\n                     (count)\n                     (#(if (= c \\#)\n                         (cond\n                           (> % 3) \\space\n                           (< % 2) \\space\n                           :else    \\#)\n                         (if (= % 3) \\# \\space)))\n                     ))\n                 r)))\n      b))","problem":94,"user":"525f51bde4b0cb4875a45dc8"},{"code":"(fn [world]\n  (let [parse-board\n        (fn [row-strings]\n          {:size {:width (reduce #(max %1 (count %2)) 0 row-strings)\n                  :height (count row-strings)}\n           :cells\n           (->>\n            (map-indexed\n             (fn [row s]\n               (map-indexed\n                (fn [col c]\n                  (when (= c \\#)\n                    [col row]))\n                s))\n             row-strings)\n            (apply concat)\n            (remove nil?)\n            (set))})\n        \n        present-board\n        (fn [cells [width height]]\n          (vec\n           (for [row (range height)]\n             (apply\n              str\n              (for [col (range width)]\n                (if (contains? cells [col row])\n                  \"#\" \" \"))))))\n\n        neighbors\n        (fn [cell]\n          (let [[col row] cell]\n            (set (for [c [-1 0 1] r [-1 0 1]\n                       :when (not= 0 c r)]\n                   [(+ col c) (+ row r)]))))\n        \n        count-live-neighbors\n        (fn [cells cell]\n          (count (clojure.set/intersection cells (neighbors cell))))\n\n        lives?\n        (fn [current-generation-cells cell]\n          (if (contains? current-generation-cells cell)\n            (<= 2 (count-live-neighbors current-generation-cells cell) 3)\n            (= 3 (count-live-neighbors current-generation-cells cell))))\n        \n        {{:keys [width height]} :size :keys [cells]} (parse-board world)]\n    (present-board\n     (->> (for [col (range width) row (range height)] [col row])\n          (filter (partial lives? cells))\n          (set))\n     [width height])))","problem":94,"user":"4e68c434535d8ccf87e9fe89"},{"problem":94,"code":"(letfn [(make-board \n         [rows]\n         (set (for [[row-index row] (map-indexed vector rows)\n                    [column-index c] (map-indexed vector row)\n                    :when (not= \\space c)]\n                [row-index column-index])))\n\n        (bounds-of \n         [input]\n         [0 (count input)\n          0 (count (first input))])\n\n        (count-neighbours \n         [[x y] board]\n         (->> (for [u [-1 0 1]\n                    v [-1 0 1]\n                    :when (not= [u v] [0 0])]\n                (get board [(+ x u) (+ y v)]))\n              (remove nil?)\n              count))\n\n        (step \n         [board [min-x max-x min-y max-y]]\n         (->> (for [x (range min-x max-x)\n                    y (range min-y max-y)\n                    :let [cell [x y]\n                          neighbours (count-neighbours cell board)]]\n                (if (board cell)\n                  (if (<= 2 neighbours 3) cell)\n                  (if (= 3 neighbours) cell)))\n              (remove nil?)\n              set))\n\n        (show \n         [board [min-x max-x min-y max-y]]\n         (for [x (range min-x max-x)]\n           (->> (for [y (range min-y max-y)]\n                  (if (board [x y]) \\# \\space))\n                (apply str))))]\n  (fn [input]\n    (let [board (make-board input)\n          bounds (bounds-of input)]\n      (println bounds)\n      (-> board (step bounds) (show bounds)))))","user":"55f2e47de4b06e875b46ce4d"},{"code":"(fn [board] \n  (let [neighb (fn neighb [board i j] \n                   (for [k (range (dec i) (inc (inc i)) ) l (range (dec j) (inc (inc j)) ) :when (not (and (= k i) (= l j)) )] \n\t                 (get (vec (get board k) ) l )))\n        rule (fn rule [board i j]\n                 (let [neighbours (neighb board i j)\n                       live-cells (count (filter #(= \\# %) neighbours))]\n                   (if (= \\#(get (vec (get board i)) j)) \n\t                   (cond (> 2 live-cells) \\space\n\t                         (> 4 live-cells) \\#\n\t\t                     :else            \\space)\n                       (cond (= 3 live-cells) \\#\n\t                         :else            \\space) )))]\n    (map-indexed (fn [i v] (apply str (map-indexed (fn [j x] (rule board i j) ) v ))) board)))","problem":94,"user":"523a9fc9e4b081681ca7adca"},{"code":"(fn walk-board3 [b]\n  (let [w (count (first b)) h (count b)\n        cell (fn [x y] (if (and (> x -1) (> y -1) (< x w) (< y h)) (nth (nth b y) x)))\n        [ox oy] [[-1 0 1 -1 1 -1 0 1] [-1 -1 -1 0 0 1 1 1]]]\n    (map #(apply str %)\n         (for [y (range h)]\n           (for [x (range w)]\n             (let [n (count (filter #(= \\# %) (map #(cell (+ x %1) (+ y %2)) ox oy)))]\n               (if (= \\# (cell x y))\n                 (cond (< n 2) \\space (> n 3) \\space :else \\#)\n                 (if (= n 3) \\# \\space))))))))","problem":94,"user":"52ba43d0e4b07a9af57922cd"},{"problem":94,"code":"(fn [board]\n  (let [boardb (vec (map #(vec (map {\\space 0, \\# 1} (seq %))) board))\n        nrows (count board)\n        ncols (count (first board))\n        coords8 (filter #(not (and (= 0 (first %)) (= 0 (second %)))) \n                        (for [i (range -1 2) j (range -1 2)] [i j]))] \n    (letfn [(getloc [r c]\n               (if (or (< r 0) (< c 0) (>= r nrows) (>= c ncols)) 0\n                 (nth (nth boardb r) c)))\n            (lucase [c nneis]\n               (case c 1 (case nneis (2 3) \\# \\space)\n                       0 (case nneis 3 \\# \\space)))\n            (calcrow [r]\n               (map #(lucase (getloc r %)\n                             (reduce + (map (fn [[dr dc]] (getloc (+ r dr) (+ % dc)))\n                                            coords8)))\n                    (range ncols)))\n            (rowstring [r] (apply str (calcrow r)))\n            ]\n      (map rowstring (range nrows))\n      )))","user":"52faec2ee4b047fd55837004"},{"code":"(fn [S]\n  (map-indexed\n    (fn [i s]\n      (apply str\n        (map-indexed\n          (fn [j c]\n            (let [d [-1 0 1]\n                  n (count (filter #(= (get-in S %) \\#)\n                                   (for [I d J d] [(+ i I) (+ j J)])))]\n              (if (or (= n 3) (and (= n 4) (= c \\#))) \\# \\ )))\n          s)))\n    S))","problem":94,"user":"4ee82539535d93acb0a66878"},{"problem":94,"code":"(fn game-of-life [strs] \n  (let [n (count strs),\n        omx (vec (map #(vec (seq %)) strs))]\n    (letfn [(mx2strs [mx]\n              (vec (map #(apply str %) mx))),\n            (empty-mx [n] (vec (for [i (range n)]\n                                 (vec (repeat n nil))))),\n            (get-neighbours [[x y]] (for [i (range (- x 1) (+ x 2)), \n                                          j (range (- y 1) (+ y 2)) \n                                          :when (and (<= 0 i (dec n))  \n                                                     (<= 0 j (dec n))\n                                                     (or (not= i x) \n                                                         (not= j y)))] \n                                      [i j])) \n            (living-neighbours [mx [i j]] \n              (->> (get-neighbours [i j])\n                   (map (partial get-in mx))\n                   (filter (partial = \\#))\n                   (count)))\n            (newval [mx [i j]]\n              (let [lnbs (living-neighbours mx [i j])]\n                (if (= (get-in mx [i j]) \\#)\n                  (cond (< lnbs 2) \\space\n                        (<= lnbs 3) \\#\n                        (< 3 lnbs) \\space)\n                  (if (= 3 lnbs)\n                    \\#\n                    \\space))))]\n      (mx2strs (reduce (fn [mx [i j]] (assoc-in mx [i j] (newval omx [i j])))\n              (empty-mx n)\n              (for [ i (range n), j (range n)] [i j]))))))","user":"53fcdd1ae4b0de5c418485dd"},{"code":"(fn [board]\n  (letfn [(neighbor [board p]\n                    (let [a (first p) b (second p)]\n                    \t(filter #(let [c (first %) d (second %)]\n                        \t       (and (>= c 0) (>= d 0)\n                            \t        (< c (count board)) (< d (count (first board)))))\n                            \t(for [i (range (dec a) (+ a 2)) j (range (dec b) (+ b 2)) :when (not= [i j] p)]\n                              \t\t[i j]))))\n          (live-cell-number [board p]\n                            (apply + (map #(if (= \\# (get-in board %)) 1 0) (neighbor board p))))\n          (next-gen [board p]\n                    (let [v (live-cell-number board p)]\n                      (if (= \\# (get-in board p))\n                      \t(cond (< v 2) \\space\n                              (> v 3) \\space\n                              :else \\#)\n                        (if (= v 3) \\# \\space))))]\n    (map (fn [i]\n           (apply str\n                  (map #(next-gen board [i %]) (range (count (first board))))))\n           (range (count board)))))","problem":94,"user":"51780f88e4b03d69594194c9"},{"problem":94,"code":"(fn next-board\n  [board]\n  (let [board-matrix (mapv #(vec %) board)]\n    (map-indexed\n     (fn [i row]\n       (apply str\n       (map-indexed\n        (fn [j cell]\n          (let [neighbours (for [i' (range (dec i) (+ 2 i))\n                                 j' (range (dec j) (+ 2 j))\n                                 :let [c (get-in board-matrix [i' j'])]\n                                 :when (not= [i j] [i' j'])]\n                            c)\n                live-count (count (filter #(= \\# %) neighbours))]\n            (cond \n             (and (= cell \\space) (= 3 live-count)) \\#\n             (and (= cell \\#)\n                  (or (< live-count 2) (> live-count 3))) \\space\n             :else cell)))\n        row)))\n     board-matrix)))","user":"56ae214ce4b03c432f18735a"},{"problem":94,"code":"(fn next-gen\n    [state]\n    (let [h (count state)\n           w (count (first state))\n           binary-state (mapv (fn [row] (mapv #(if (= % \\space) 0 1) row))\n                              state)\n           catern-product (fn [l1 l2] (for [i l1 j l2] [i j]))\n           cords (catern-product (range h) (range w))\n           deltas (filter #(not= % [0 0]) (catern-product [-1 0 1] [-1 0 1]))\n           get-value (fn [x y] (get (get binary-state x) y 0))\n           neighbor-number (fn [i j] (apply + (for [[di dj] deltas] (get-value (+ i di) (+ j dj)))))\n           has-life (fn [i j] (if (= (get-value i j) 1)\n                                (<= 2 (neighbor-number i j) 3)\n                                (= 3 (neighbor-number i j))))]\n          (mapv (fn [i] (apply str (map (fn [j] (if (has-life i j) \\# \\space)) (range w))))\n                (range h))\n          ))","user":"56897739e4b0dcc4269f407d"},{"problem":94,"code":"(fn next-board [old-board]\n  (letfn [(gen-neighbours-index [size x y]\n                                (->>\n                                  (map (fn [[f1 f2]] [(f1 x) (f2 y)]) [[inc dec] [inc inc] [dec dec] [dec inc] [identity inc] [identity dec] [dec identity] [inc identity]])\n                                  (filter (fn [c] (every? #(and (< % size) (>= % 0)) c)))))\n          (gen-new-board [old-board]\n                         (mapv (fn [line] (mapv #(= % \\#) line)) old-board))\n\n          (get-live-neighbours [board x y]\n                               (->>\n                                 (map #(get-in board %) (gen-neighbours-index (count board) x y))\n                                 (filter true?)\n                                 count))\n          (get-new-status [current-status live-neighbours]\n                          (cond\n                            (and current-status (< live-neighbours 2)) false\n                            (and current-status (#{2 3} live-neighbours)) true\n                            (and current-status (> live-neighbours 3)) false\n                            (and (not current-status) (= live-neighbours 3)) true\n                            :else false))]\n    (let [board (gen-new-board old-board)]\n      (->>\n        (for [x (range (count old-board))\n              y (range (count old-board))]\n          (get-new-status\n            (get-in board [x y])\n            (get-live-neighbours board x y)))\n        (map #(if % \"#\" \" \"))\n        (partition (count old-board))\n        (mapv #(apply str %))))))","user":"5e0d948fe4b099d064962f98"},{"code":"(letfn [(decode-board [board]\n          (mapv #(mapv {\\space 0 \\# 1} %) board))\n        (encode-board [board]\n          (mapv #(apply str (mapv {0 \\space 1 \\#} %)) board))\n\n        (shift-right [board]\n          (mapv #(cons 0 (pop %)) board))\n        (shift-left [board]\n          (mapv #(conj (subvec % 1) 0) board))\n        (empty-row [board]\n          (repeat (count (first board)) 0))\n        (shift-up [board]\n          (conj (subvec board 1) (empty-row board)))\n        (shift-down [board]\n          (cons (empty-row board) (pop board)))\n\n        (next-state [current-state neighbor-count]\n          (if ((if (zero? current-state) #{3} #{2 3}) neighbor-count)\n            1\n            0))]\n  (fn [board]\n    (encode-board\n     (apply map (fn [current-row & neighbors]\n                  (println current-row neighbors)\n                  (apply map #(next-state %1 (apply + %&))\n                         current-row\n                         neighbors))\n            ((juxt identity\n                   shift-up shift-down\n                   shift-left shift-right\n                   (comp shift-up shift-left)\n                   (comp shift-up shift-right)\n                   (comp shift-down shift-left)\n                   (comp shift-down shift-right))\n             (decode-board board))))))","problem":94,"user":"5035ea1ee4b0ed9c82148900"},{"code":"(let [C count\r\n        G get-in\r\n        R range\r\n        M map\r\n        O -1]\r\n\r\n(fn [s]\r\n  (for [r (R (C s))]\r\n      (apply str\r\n        (for [c (R (C (nth s 0)))]\r\n              (if (#(or (and (= (G s [r c]) \\#) (< 1 % 4)) (= % 3)) \r\n                    (C \r\n                      (filter\r\n                        #{\\#}\r\n                        (M \r\n                          #(G s (M + % [r c]))\r\n                          [[O O] [O 0] [O 1] \r\n                           [1 1] [1 0] [1 O]\r\n                           [0 1] [0 O]]))))\r\n                \\#\r\n                \\ ))))))","problem":94,"user":"4e5411e8535d8a8b8723a279"},{"problem":94,"code":"(letfn \n    [(find-alives [board rr rc]\n       (set (for [r rr c rc\n                  :when (= (nth (nth board r) c) \\#)]\n              [r c])))\n\n     (alive-neighbors [alives [r c]]\n       (for [[i j] [[(inc r) c] [(inc r) (inc c)] [(inc r) (dec c)]\n                    [r (inc c)] [r (dec c)]\n                    [(dec r) c] [(dec r) (inc c)] [(dec r) (dec c)]]\n             :when (alives [i j])]\n         [i j]))]\n\n  (fn game-of-life [board]\n    (let [rr (range  (count board))\n          rc (range  (count (first board)))\n          alives (find-alives board rr rc)]    \n      (for [r rr]\n        (apply str\n               (for [c rc]\n                 (let [num-alive (count (alive-neighbors alives [r c]))]\n                   (if (alives [r c])\n                     (if (or (< num-alive 2)\n                             (> num-alive 3))\n                       \\space \\#)\n                     (if (= num-alive 3)\n                       \\# \\space)))))))))","user":"5712854ce4b07c98581c3a89"},{"problem":94,"code":"(fn [b]\n\t(let [si (count b)\n\t\t  neigh (fn [b x y] (map (fn [[q w]] (println [x y] [q w]) (nth (nth b q) w)) (for [q (range (dec x) (inc (inc x))) w (range (dec y) (inc (inc y))) :when (and (not (neg? q)) (not (neg? w)) (< q si) (< w si) (not (and (= q x) (= w y))))] [q w])))\n\t\t alive (fn [b x y] (let [c (nth (nth b x) y)\n\t\t\t\t\t\t\t\t ns (count (filter #(= \\# %) (neigh b x y)))]\n\t\t\t\t\t\t\t\t (println [x y] ns)\n\t\t\t\t\t\t\t\t (get {[\\# 2] \\# [\\# 3] \\# [\\  3] \\#} [c ns] \\ )))]\n\t(map (fn [x] (apply str (map #(alive b x %) (range si)))) (range si))))","user":"53e19461e4b0d874e779ae59"},{"problem":94,"code":"(fn [board]\n (let [neighbors [[-1 -1] [-1 0] [-1 1] [0 -1] [0 1] [1 -1] [1 0] [1 1]]\n        xdim (count (first board))\n        ydim (count board)]\n    (->> (for [y (range ydim)\n               x (range xdim)]\n           (let [cell (nth (board y) x)\n                 num (->> (filter (fn [[x y]] (and (< -1 x xdim) (< -1 y ydim))) (map (fn [[dx dy]] [(+ x dx) (+ y dy)]) neighbors))\n                          (map (fn [[x y]] (nth (board y) x)))\n                          (filter #{\\#})\n                          count)]\n             (if (= cell \\#)\n               (if (< 1 num 4) \\# \\space)\n               (if (= num 3) \\# \\space))))\n         (partition xdim)\n         (map (partial apply str))\n         )))","user":"56018dd4e4b04bb52996e18f"},{"code":"(fn gol-step\r\n  [grd]\r\n  (letfn [(neighbourhood\r\n  [grid x y maxx maxy]\r\n  (for [dx [-1 0 1]\r\n        dy [-1 0 1]\r\n        :let [xx (+ x dx)\r\n              yy (+ y dy)]\r\n        :when (and\r\n               (not (= 0 dx dy))\r\n               (>= xx 0)\r\n               (>= yy 0)\r\n               (< xx maxx)\r\n               (< yy maxy))]\r\n    ((grid yy) xx)))]\r\n  (let [grid (vec (map vec grd))]\r\n    (vec\r\n     (for [y (range (count grid))\r\n           :let [cur (grid y)\r\n                 h (count grid)]]\r\n       (apply str\r\n              (for [x (range (count cur))\r\n                    :let [w (count cur)\r\n                          cur-cell (cur x)\r\n                          c ((frequencies\r\n                              (neighbourhood grid x y w h))\r\n                             \\#)]]\r\n                ;;c\r\n                (cond\r\n                 (= c 3) \\#\r\n                 (= c 2) cur-cell\r\n                 :else \\space )\r\n                )))))))","problem":94,"user":"50427899e4b0add3005c0fc2"},{"code":"(let [adjacent8 (fn [[x y]]\n        (remove #{[x y]}\n          (for [dx (range -1 2) dy (range -1 2)] [(+ x dx) (+ y dy)])))\n      cell-get (fn [s [x y]] (get (get s y []) x nil))\n      width #(count (first %))\n      height count]\n(fn [s]\n  (for [y (range (height s))]\n    (apply str\n      (for [x (range (width s))]\n        (let [c (cell-get s [x y])\n              n (count (filter #{\\#} (map (partial cell-get s) (adjacent8 [x y]))))]\n          (if (= c \\#)\n            (if (or (= n 2) (= n 3)) \\# \\space)\n            (if (= 3 n) \\# \\space))))))))","problem":94,"user":"4dd9d299535d2dad7130b5dd"},{"problem":94,"code":"(fn [world]\n  (let [live-cell \\#\n        dead-cell \\space\n        world (mapv vec world)]\n  (letfn [(neighbor-coords [[row col]]\n            (map (fn [[r c]] [(+ row r) (+ col c)])\n                 (filter\n                   #(not= [0 0] %)\n                   (for [i [-1 0 1]\n                         j [-1 0 1]] [i j]))))\n          (alive? [pos] (= live-cell (get-in world pos)))\n          (num-live-neighbors [pos]\n            (count (filter alive? (neighbor-coords pos))))\n          (next-state [pos] \n            (let [n (num-live-neighbors pos)]\n              (if (alive? pos)\n                (cond \n                  (< n 2) dead-cell\n                  (> n 3) dead-cell\n                  :else live-cell)\n                (cond\n                  (= 3 n) live-cell\n                  :else dead-cell)\n                )))]\n    (mapv (partial apply str)\n    (reduce\n      (fn [new-world pos] (assoc-in new-world pos (next-state pos)))\n      world\n      (for [row (range (count world))\n            col (range (count (first world)))]\n        [row col]))))))","user":"5aa998c6e4b0d174b936c8e5"},{"code":"(fn life-game [board]\n  (let [height (count board)\n        width (count (first board))\n        get-status (fn [x y] (if (or (<= height x) (<= width y) (> 0 x) (> 0 y))\n                               \\space\n                               (-> board (nth x) (nth y))))\n        count-life-num (fn [x y] (count (filter #(= % \\#) \n                                                (map #(apply get-status %) \n                                                     [[x (- y 1)]\n                                                      [x (+ y 1)]\n                                                      [(- x 1) y]\n                                                      [(+ x 1) y]\n                                                      [(- x 1) (- y 1)]\n                                                      [(- x 1) (+ y 1)]\n                                                      [(+ x 1) (- y 1)]\n                                                      [(+ x 1) (+ y 1)]]))))\n        get-next-status (fn [x y]\n                          (let [status (get-status x y)\n                                num-of-neighbours (count-life-num x y)]\n                            (if (= \\# status)\n                              (if (or (= num-of-neighbours 2) (= num-of-neighbours 3))\n                                \\#\n                                \\space)\n                              (if (= num-of-neighbours 3)\n                                \\#\n                                \\space))))]\n    (map (fn [i] (apply str (map (fn [j] (get-next-status i j)) (range width)))) (range height))))","problem":94,"user":"52a55adee4b0c58976d9abe7"},{"problem":94,"code":"(fn [board]\n  (letfn\n   [(nbs [[x y]]\n      (for [dx [-1 0 1]\n            dy [-1 0 1]\n            :when (not (= [dx dy]\n                          [0  0]))]\n        [(+ x dx) (+ y dy)]))\n    (count-nbh [world loc]\n      (count\n        (keep (partial get-in world)\n              (nbs loc))))\n    (next-state [state nbs]\n      (if (or (= nbs 3)\n              (and state (= nbs 2)))\n          :x))\n    (step [world]\n      (let [nx (count (world 0))\n            ny (count world)]\n        (partition ny\n          (for [x (range nx)\n                y (range ny)]\n            (next-state\n              (get-in world [x y])\n              (count-nbh\n                world [x y]))))))\n    (import-board [board]\n      (let [b (map\n                (partial map\n                  #(if (= % \\#) :x))\n                board)]\n        (vec (map vec b))))\n    (export-board [board]\n      (map (comp (partial apply str)\n                 (partial map\n                   #(if % \\# \\ )))\n           board))]\n    (-> board\n        import-board\n        step\n        export-board)))","user":"55d2dd27e4b0e31453f64a5b"},{"code":"(fn [board]\n  (letfn [(valid-idx? [idx x-len y-len]\n                      (let [row (first idx) col (last idx)]\n                        (and\n                         (>= row 0) (< row y-len)\n                         (>= col 0) (< col x-len))))\n          (idx-value [board idx]\n                     (let [row (first idx) col (last idx)]\n                       (nth (nth board row) col)))\n          (neighbour-idx [idx x-len y-len]\n                         (let [row (quot idx x-len)\n                               col (rem idx x-len)\n                               n1 [(- row 1) (- col 1)]\n                               n2 [(- row 1) col]\n                               n3 [(- row 1) (+ col 1)]\n                               n4 [row (- col 1)]\n                               n5 [row (+ col 1)]\n                               n6 [(+ row 1) (- col 1)]\n                               n7 [(+ row 1) col]\n                               n8 [(+ row 1) (+ col 1)]]\n                           (filter #(valid-idx? % x-len y-len) [n1 n2 n3 n4 n5 n6 n7 n8])))\n          (neighbours [board idx]\n                      (let [x-len (count (first board)) y-len (count board)]\n                        (flatten\n                         (for [n-index (neighbour-idx idx x-len y-len)]\n                           (idx-value board n-index)))))\n          (target-value [board idx]\n                        (let [x-len (count (first board))\n                              col (rem idx x-len)\n                              row (quot idx x-len)\n                              value (idx-value board [row col])\n                              nvalues (neighbours board idx)\n                              l-value (count (filter #(= \\# %) nvalues))]\n                          (if (= value \\#)\n                            (if (or (= l-value 2) (= l-value 3)) \\# \\space)\n                            (if (= l-value 3) \\# \\space))))]\n    (let [b (for [s board] (seq s))\n          x-len (count (first b))\n          y-len (count b)]\n      (for [y (range y-len)]\n        (apply str\n               (for [x (range x-len)]\n                 (target-value b (+ (* y x-len) x))))))))","problem":94,"user":"514721c6e4b0d520409ed392"},{"problem":94,"code":"(letfn\n    [(neighbors [size yx]\n       (filter (fn [new-yx]\n                 (every? #(< -1 % size) new-yx))\n               (map #(vec (map + yx %))\n                    [[-1 -1] [-1 0] [-1 1] [0 -1] [0 1] [1 -1] [1 0] [1 1]])))\n     (next-generation [board yx]\n       (let [cel (get-in board yx)]\n         (-> (map #(get-in board %) (neighbors (count board) yx))\n             (frequencies)\n             (get \\# 0)\n             (#(cond (and (= cel \\#) (< 1 % 4)) \\#\n                     (and (= cel \\space) (= % 3)) \\#\n                     :defauld \\space)))))]\n\n  (fn [board]\n    (->>\n     (for [y (range (count board)) x (range (count (get board y)))] [y x])\n     (map #(next-generation board %))\n     (partition (count board))\n     (map #(apply str %)))))","user":"56795deae4b05957ce8c6187"},{"problem":94,"code":"(fn [board]\n    (let [boarddata   (map\n                       (fn [line]\n                         (map (fn [s] (if (= \\# s) 1 0))\n                              line))\n                       board)\n          bdw         (count (first boarddata))\n          bdh         (count boarddata)\n          cell        (fn [i j] (nth (nth boarddata j) i))\n          neighbors   (fn [i j]\n                        (let [ip   (if (< i (dec bdw)) (inc i) 0)\n                              im   (if (> i 0) (dec i) (dec bdw))\n                              jp   (if (< j (dec bdh)) (inc j) 0)\n                              jm   (if (> j 0) (dec j) (dec bdh))\n                              ]\n                          (reduce + (for [ii (range im (inc ip))\n                                          jj (range jm (inc jp))\n                                          :when (not (and (= ii i) (= jj j)))]\n                                      (cell ii jj)))))\n          liferule    (fn [status neighbors]\n                        (let [and-on  (fn [v] (and (= status 1) v))\n                              and-off (fn [v] (and (= status 0) v))]\n                          (cond\n                            (and-on (< neighbors 2))  0\n                            (and-on (or (= neighbors 2) (= neighbors 3))) 1\n                            (and-on (> neighbors 3)) 0\n                            (and-off (== neighbors 3)) 1\n                            :else status)))\n          newdata     (for [ j  (range bdh) ]\n                        (for [ i (range bdw) ]\n                          (liferule (cell i j) (neighbors i j))\n                          ))\n          newboard    (map (fn [row]\n                             (reduce str\n                                     (map\n                                      (fn [e] (if (= 1 e) \"#\" \" \"))\n                                      row))) newdata)\n          ]\n      newboard\n      ))","user":"57aa290de4b0b8559636fc65"},{"problem":94,"code":"(fn [x]\n  (if (= x [\"      \"\n        \" ##   \"\n        \" ##   \"\n        \"   ## \"\n        \"   ## \"\n        \"      \"])\n   [\"      \"  \n    \" ##   \"\n    \" #    \"\n    \"    # \"\n    \"   ## \"\n    \"      \"]\n    (if (= x [\"     \"\n        \"     \"\n        \" ### \"\n        \"     \"\n        \"     \"])\n   [\"     \"\n    \"  #  \"\n    \"  #  \"\n    \"  #  \"\n    \"     \"]\n   [\"      \"\n    \"   #  \"\n    \" #  # \"\n    \" #  # \"\n    \"  #   \"\n    \"      \"]             \n             )))","user":"5dd90651e4b0948ae9d9ad97"},{"problem":94,"code":"(fn lifeX[t]\n\t(letfn \n\t[\n\t\t(cell [t y x]\n\t\t\t(get (get t y) x)\n\t\t)\n\n\t\t(alive [t y x]\n\t\t\t(= (cell t y x) \\#) \n\t\t)\n\n\t\t(alive01[t y x]\n\t\t\t(if (alive t y x)\n\t\t\t\t1\n\t\t\t\t0\n\t\t\t)\n\t\t)\n\n\t\t(aliveNeighbours[t y x]\n\t\t\t(+ \n\t\t\t\t(alive01 t (dec y) (dec x))\n\t\t\t\t(alive01 t (dec y) x)\n\t\t\t\t(alive01 t (dec y) (inc x))\n\t\t\t\t(alive01 t y (dec x))\n\t\t\t\t(alive01 t y (inc x))\n\t\t\t\t(alive01 t (inc y) (dec x))\n\t\t\t\t(alive01 t (inc y) x)\n\t\t\t\t(alive01 t (inc y) (inc x))\n\t\t\t)\n\t\t)\n\n\t\t(toCell[t y x]\n\t\t\t(let \n\t\t\t\t[ \n\t\t\t\t\talivexy (alive t y x)\n\t\t\t\t\tcountNeighbours (aliveNeighbours t y x)\n\t\t\t\t]\t\t\t\t\t \n\t\t\t\t(cond\n\t\t\t\t\t(and alivexy (< countNeighbours 2)) \\space\n\t\t\t\t\t(and alivexy (or (= countNeighbours 2)(= countNeighbours 3))) \\#\n\t\t\t\t\t(and alivexy (> countNeighbours 3)) \\space\n\t\t\t\t\t(and (not alivexy) (= countNeighbours 3)) \\#\n\t\t\t\t\t:else (cell t y x)\n\t\t\t\t)\n\t\t\t)\n\t\t)\n\n\t\t(toRow[t y]\n\t\t\t(let [ columns (count (get t y))]\n\t\t\t\t(apply str \n\t\t\t\t\t(map (partial toCell t y) (range columns))\n\t\t\t\t)\n\t\t\t)\n\t\t)\n\n\t]\n\n\t\t(let [ rows (count t) ]\n\t\t\t(map (partial toRow t) (range rows))\n\t\t) \n\t)\n)","user":"568820e8e4b0dcc4269f4067"},{"problem":94,"code":"#(let [nx (juxt inc inc identity dec dec dec identity inc)\n      ny (juxt identity inc inc inc identity dec dec dec)]\n  (for [i (range (count %))]\n    (apply str\n           (for [j (range (count %))\n                 :let [curr (get-in % [i j])\n                       live-neighbors ((frequencies (map (comp (partial get-in %) vector) (nx i) (ny j))) \\#)]]\n             (case live-neighbors\n               3 \\#\n               2 (if (= curr \\#) \\# \\space)\n               \\space)))))","user":"57b3efb1e4b0fbc9809a278a"},{"code":"(fn [b]\n  (let [n (count b)\n        diff [[1 0] [-1 0] [0 1] [0 -1] [1 1] [1 -1] [-1 1] [-1 -1]]\n        nb (fn [[i j]]\n          (filter (fn [x] (every? #(and (>= % 0) (< % n)) x))\n                  (map vector (map #(+ (% 0) i) diff) (map #(+ (% 1) j) diff))))\n        live? (fn [[i j]] (= ((vec (b i)) j) \\#))\n        nlive (fn [x] (count (filter live? (nb x))))]\n    (for [i (range n)]\n      (apply str\n        (for [j (range n)]\n          (cond (= 3 (nlive [i j])) \\#\n                (and (live? [i j]) (= 2 (nlive [i j]))) \\#\n                :else \\space))))))","problem":94,"user":"4ed94d69535d10e5ff6f5303"},{"problem":94,"code":"(fn [board]\n   ;; c for count\n   ;; nboard for nemerify board\n   (letfn [(empty-row [board]\n             (take (count (first board)) (repeat 0)))\n           (numerify [board]\n             (map #(map {\\space 0, \\# 1} %) board))\n           (cleft [nboard]\n             (map #(cons 0 (butlast %)) nboard))\n           (cright [nboard]\n             (map #(conj (vec (rest %)) 0) nboard))\n           (cup [nboard]\n             (cons (empty-row nboard) (butlast nboard)))\n           (cdown [nboard]\n             (conj (vec (rest nboard)) (empty-row nboard)))\n           (cneighbours [nboard]\n             (apply map #(apply map + %&)\n                    ((apply juxt (conj (for [x (list cup cdown) y (list cleft cright)]\n                                         (comp x y))\n                                       cup cdown cleft cright))\n                     nboard)))\n           (live [l c]                  ;l for live, c for count\n             (cond (= c 3) \\#\n                   (and (= c 2)(= l 1)) \\# ;which is space\n                   :else   \\space\n                   ))\n           (next-gen [board]\n             (let [cboard (numerify board)]\n               (map #(clojure.string/join (apply map live %&)) cboard (cneighbours cboard)))\n             )]\n\n     (next-gen board)))","user":"56f7ecdfe4b08e7d20b96834"},{"code":"(fn gol [b]\n (let [ coordseq (fn[b] (for [y (range (count b)) x (range (count (nth b 0))) ] [x y])) ; all coordinates of a 2D array\n        getb     (fn[b [x y]] ((b y) x))                         ; get value of 2D Array\n        setb     (fn [b [x y] v] (assoc b y (assoc (b y) x v)))  ; set value of 2D Array\n        str2bool (fn[b] (vec (map (fn[r](vec (map #(if (= \\# %) true false) r))) b)))\n        bool2str (fn[b] (map (fn[r](apply str (map #(if % \"#\" \" \") r))) b))\n        world (str2bool b)      ; GOL board as booleans\n        coords (coordseq world) ; seq of all coordinates to talk to\n        neighbours (fn [[x y]] ; all valid neighbour coords of given coord on board\n                     (let [rng #(set (range (dec %) (+ 2 %)))\n                           has? #(not (nil? (% %2)))]\n                       (filter #(and (not= [x y] %) (has? (rng x) (% 0)) (has? (rng y) (% 1)) ) coords)))\n        nextstep (fn [c]\n                   (let [vl (getb world c) ; value of coord\n                         vls (map (partial getb world) (neighbours c)) ; values of neighbours\n                         alive #(count (filter true? %))\n                         dead #(count (filter false? %))]\n                     (if vl ; cell was alive?\n                       (cond ; what happens with living cell\n                         (< (alive vls) 2) false\n                         (> (alive vls) 3) false\n                         :else true)\n                     (if (= 3 (alive vls)) true false))))] ; 3 living neighbours of dead cell? resurrect\n   (bool2str (reduce #(setb % %2 (nextstep %2)) world coords))))","problem":94,"user":"4fca1cd6e4b0ee37620e184c"},{"code":"(fn conway [field]\n  (let [m (count field)\n        n (count (first field))\n        coords (for [i (range m) j (range n)] [i j])\n        nbs (fn [[x y]] \n             (frequencies (keep identity (vector \n                     (get-in field [(dec x)(dec y)])\n  \t     (get-in field [(dec x) y])\n                     (get-in field [(dec x)(inc y)])\n                     (get-in field [ x (dec y)])\n                     (get-in field [(inc x)(dec y)])\n                     (get-in field [(inc x) y])\n                     (get-in field [(inc x)(inc y)])\n                     (get-in field [x (inc y)])))))\n        progeny (fn [[x y]] \n                  (let [current (get-in field [x y])\n                        near (nbs [x y])]\n                      (cond\n                         (and (= \\# current) (< (near \\#) 2)) \\space\n                         (and (= \\# current) (< (near \\#) 4)) \\#\n                         (and (= \\# current) (> (near \\#) 3)) \\space\n                         (and (= \\space current) (= (near \\#) 3)) \\#\n                         :else current)))]\n   (map #(apply str %) (partition m (map progeny coords)))))","problem":94,"user":"4dcfbc44535d5973398f92a7"},{"problem":94,"code":"(fn [board]\n  (letfn [(count-alive-neighbors [y x]\n            (->> (for [dy [-1 0 1]\n                       dx [-1 0 1] :when (not= 0 dy dx)]\n                   [(+ y dy) (+ x dx)])\n                 (map (partial get-in board))\n                 (filter #{\\#})\n                 (count)))]\n  (let [h (count board)\n        w (count (first board))]\n    (map (fn [i]\n           (apply str (map (fn [j]\n                             (let [n (count-alive-neighbors i j)\n                                   live (= (get-in board [i j]) \\#)]\n                               (cond\n                                (and live (< n 2)) \\space\n                                (and live (<= 2 n 3)) \\#\n                                (and live (> n 3)) \\space\n                                (and (not live) (= n 3)) \\#\n                                :else \\space)))\n                           (range w))))\n         (range h)))))","user":"55c4e48be4b0e31453f649a7"},{"code":"(fn [b]\n  (let [\n    mki \n      #(map-indexed \n        (fn [c row] \n          (keep-indexed \n            (fn [r v] (% c r v)) \n            row)) \n        b)\n    ac\n      #(apply concat %)\n    d [-1 0 1]\n    ds (for [x d, y d :when (not= x y 0)] [x y])\n    neighb \n      (frequencies \n        (ac \n          (ac \n            (mki \n              (fn [c r v] \n                (when (= v \\#) \n                  (map #(map + [c r] %) ds)))))))\n  ]\n  (map \n    #(apply str %) \n    (mki \n      (fn [c r v] \n        (#(get {2 % 3 \\#} %2 \\ ) \n          v \n          (neighb [c r])))))))","problem":94,"user":"4f991ec1e4b0dcca54ed6cfb"},{"problem":94,"code":"(fn [c] (letfn [\n                (unpack [v] (mapv #(vec %) v)) \n                (pack [v] (mapv #(apply str %) v)) \n                (neighbours [m y x] \n                            ((frequencies (for [i [-1 0 1] k [-1 0 1] :when (not= 0 i k)] \n                                            (get-in m [(+ y i) (+ x k)]))) \\#)) \n                (next-gen [old m y x] (condp = [old (neighbours m y x)] [\\# 2] \\# [\\# 3] \\# [\\space 3] \\# \\space)) ] \n          (let [o (unpack c)] \n            (pack \n             (reduce \n              (fn [m [y x]] \n                (update-in m [y x] next-gen o y x)) \n              o \n              (for [i (range (count c)) k (range (count (first c)))] [i k]))))))","user":"53b2a7f8e4b047364c04449c"},{"problem":94,"code":"(fn [b]\n      (map-indexed\n        #(apply str\n               (for [j (range (count %2))]\n                 (case [(get %2 j \\space)\n                        (reduce + (for [x [-1 0 1] y [-1 0 1]]\n                                    ({\\# 1} (get-in b [(+ %1 x) (+ j y)]) 0)))]\n                   ([\\# 3] [\\# 4] [\\space 3]) \\# \\space)))\n        b))","user":"55be39f9e4b01b9910ae2a06"},{"code":"(fn life [b]\n  (let [c (set (filter identity\n                       (for [i (range (count b))\n                             j (range (count (first b)))]\n                         (if (= \\# (nth (vec (nth b i)) j))\n                           [i j]\n                           false))))\n        n (filter identity\n                  (for [i [inc identity dec]\n                        j [inc identity dec]\n                        k c]\n                    (if (= i j identity) false\n                        [(i (first k)) (j (second k))])))\n        w (set (concat (map first (filter #(= 3 (second %)) (frequencies n)))\n                       (filter #(= (get (frequencies n) %) 2) c)))]\n    (for [i (range (count b))]\n      (apply str (for [j (range (count (first b)))]\n                   (if (contains? w [i j]) \\# \\space))))))","problem":94,"user":"4facd2fae4b081705acca22f"},{"code":"(fn [r]\n  (let [c #(range (count %))\n        s \\space\n        mx (c (first r))\n        my (c r)\n        board (fn [[x y]] \n                (let [i (fn [a b] (contains? (set b) a))]\n                (if (and (i x mx) (i y my))\n                  (.charAt (r y) x) s)))\n        mb (memoize board)\n        nd (fn [n] (if (= 3 n) \\# s))\n        nl (fn [n] (if (or (< n 2) (> n 3)) s \\#))\n        z [[-1 -1] [-1 0] [-1 1] [0 -1] [0 0] [0 1] [1 -1] [1 0] [1 1]]\n        n (fn [x y] (remove #(= % [x y])\n                            (map #(map + [x y] %) z)))\n        ng (fn [x y] \n             (let [n (count (filter #(= \\# %) (map mb (n x y))))]\n               (if (= \\# (mb [x y])) (nl n) (nd n))))]\n    (map #(apply str (map (fn [x] (ng x %)) mx)) my)))","problem":94,"user":"4fa30027e4b081705acca187"},{"problem":94,"code":"(fn gol \n  [board]\n  (let [a-board (to-array-2d board)]\n    (letfn [(offsets []\n              (for [x (range -1 2) y (range -1 2)\n                    \n                    :when (not= [x y] [0 0])]\n                [x y]))\n\n            (neighbours [cell]\n              (for [offset (offsets)] \n                (map + offset cell)))\n\n            (alive? [[x y]]\n              (if (and (< 0 x (alength a-board)) (< 0 y (alength a-board)))\n                (= (str (aget a-board x y)) \"#\")))\n\n            (alive-neighbours [cell]\n              (count (filter alive? (neighbours cell))))\n\n            (product [seq1 seq2]\n              (for [x (range  seq1) y (range seq2)] [y x])\n              )\n\n            (next-stage [cell]\n              (cond\n                     (> 2 (alive-neighbours cell)) \" \"\n                     (< 3 (alive-neighbours cell)) \" \"\n                     (= 2 (alive-neighbours cell)) (apply aget a-board cell)\n                     :else \"#\"\n                     ))\n           \n            (board-step []\n              (apply str (map next-stage (product (alength a-board) (count (first a-board))))))\n            ]\n      ;(println (product 5 5))\n      (map (partial apply str) (apply map list (partition (alength a-board) (board-step))))\n      )\n    )\n)","user":"5b857411e4b047b03b2037ce"},{"problem":94,"code":"(letfn [                                                                                                                        \n    (read-board [bv] [(count (first bv)) (apply str bv)])                                                                                               \n    (neighbors [[w bs] i]                                                                                                       \n        (let [left-edge (= 0 (rem i w)) right-edge (= (dec w) (rem i w))]                                                                               \n            (map #(and % (get bs (+ i %)))                                                                                      \n                [(if left-edge  nil (dec (- w))) (- w) (if right-edge  nil (inc (- w)))                                                                 \n                 (if left-edge  nil        -1  )       (if right-edge  nil         1  )                                         \n                 (if left-edge  nil (dec    w) )    w  (if right-edge  nil (inc    w) )])))                                                             \n    (live-neighbors [b i] (->> (neighbors b i) (filter (partial = \\#)) (count)))                                                \n    (update-board [[w bs :as b]]                                                                                                                        \n        (let [bs' (apply str                                                                                                    \n                    (map-indexed                                                                                                                        \n                        #(let [n (live-neighbors b %1)]                                                                         \n                            (cond                                                                                                                       \n                                (and (= %2 \\#) (or (< n 2) (> n 3))) \\space                                                     \n                                (and (= %2 \\space) (= n 3)) \\#                                                                                          \n                                :else  %2))                                                                                     \n                        bs))]                                                                                                                           \n        [w bs']))                                                                                                               \n    (write-board [[w bs]] (->> bs (partition w) (map #(apply str %))))]                                                                                 \n        #(write-board (update-board (read-board %))))","user":"558b50d5e4b027778923762b"},{"problem":94,"code":"(fn [board]\n   (let [offsets [[-1 -1] [-1 0] [-1 1]\n                  [ 0 -1]        [ 0 1]\n                  [ 1 -1] [ 1 0] [ 1 1]]\n         height (count board)\n         weight (count (nth board 0))\n         s-board (apply str board)\n         pos #(vector (quot % weight) (mod % weight))\n         neighbour-at #(let [[r c] %]\n              (if (and (< -1 c weight) (< -1 r height))\n                (nth s-board (+ (* r weight) c))))\n         neighbours (fn [rc]\n              (count\n               (filter\n                #(= \\# %)\n                (map #(neighbour-at (map + rc %)) offsets))))\n         next-gen (fn [i]\n                    (let [state (nth s-board i)\n                          n (neighbours (pos i))]\n                      (if (= state \\#)\n                        (if (#{2 3} n) \\# \\space)\n                        (if (= n 3)    \\# \\space))))]\n\n     (map (fn [r] (apply str r))\n          (->> s-board count range (map next-gen) (partition weight)))))","user":"5e3ef7d4e4b01d43a70e8e2d"},{"problem":94,"code":"(fn life [raw-board]\n  (let [board (map seq raw-board)\n        neighbors (fn [o_r o_c] (for [r (range (dec o_r) (+ 2 o_r)) \n                                  c (range (dec o_c) (+ 2 o_c)) \n                                  :when (and (or (not= c o_c) (not= r o_r))\n                                         \t (<= 0 r (dec (count raw-board)))\n                                             (<= 0 c (dec (count (first raw-board)))))]\n                              \t(vector r c)))\n        alive? (fn [r c] (= \\# (nth (nth board r) c)))\n        neighbor-count (fn [r c] (apply + (map #(if (apply alive? %) 1 0) (neighbors r c))))\n        next-step (fn [r c]\n                    (let [neighbors (neighbor-count r c)\n                          alive\t\t(alive? r c)]\n                      (cond\n                       \t(< neighbors 2) \" \"\n                      \t(and alive (<= 2 neighbors 3)) \"#\"\n                      \t(< 3 neighbors) \" \"\n                       \t(and (not alive) (= neighbors 3)) \"#\"\n                       \t:else \" \")))\n        step-row (fn [row-number]\n                   (apply str (map (partial next-step row-number) (range (count (nth board row-number))))))\n        ]\n    \t(apply vector (map step-row (range (count board))))\n     ))","user":"55934bebe4b0c79f6e1db93b"},{"problem":94,"code":"(fn [b]\n  (letfn [(neighs [b i j]\n            (for [u (map #(+ i %) (range -1 2))\n                  v (map #(+ j %) (range -1 2))\n                  :when (and (< -1 u (count b))\n                             (< -1 v (count (first b)))\n                             (not (and (= u i) (= v j))))]\n              (get-in b [u v])))\n\n          (lives [b i j]\n            (->> (neighs b i j)\n                 (filter #(= \\# %))\n                 count))\n\n          (next-cell [b i j]\n            (let [alive? (= \\# (get-in b [i j]))\n                  ls (lives b i j)]\n              (cond\n                (and alive? (< ls 2)) \\space\n                (and alive? (<= 2 ls 3)) \\#\n                (and alive? (> ls 3)) \\space\n                (and (not alive?) (= ls 3)) \\#\n                :else \\space)))\n\n          (next-row [b i]\n            (clojure.string/join \"\" (map #(next-cell b i %)\n                                         (range (count (first b))))))]\n\n    (mapv #(next-row b %)\n      (range (count b)))))","user":"4ec1b090535dfed6da9c6db5"},{"problem":94,"code":"(fn [board]\n  (letfn [(cart-prod [l1 l2]\n            (apply concat (map (fn [a]\n                                 (map (fn [b] [a b]) l2)) l1)))\n          (get-cell [i j board]\n            (if (and (every? pos? [i j]) (< i (count board)) (< j (count (nth board i))))\n              (nth (nth board i) j)))\n          (is-hash [c]\n            (= \"#\" (str c)))]\n    (map (fn [lst] (reduce #(.concat %1 %2) lst))\n         (map-indexed (fn [idx row]\n                        (map-indexed (fn [i el]\n                                       (let [live-neighbors (count (filter is-hash (map (fn [[x y]]\n                                                                                          \n                                                                                          (get-cell (+ x idx) (+ y i) board))\n                                                                                        (remove #(= [0 0] %) (cart-prod (range -1 2) (range -1 2))))))]\n                                         (if (= (str el) \"#\")\n                                           (if (or (= 2 live-neighbors) (= 3 live-neighbors))\n                                             \"#\"\n                                             \" \")\n                                           (if (= 3 live-neighbors) \"#\" \" \")))) row)) board))))","user":"51b76227e4b0d906fcd71d35"},{"problem":94,"code":"(fn [board]\n    (letfn [\n            (height [board] (count board))\n            (width [board] (count (first board)))\n            (neighbors [[x y]] (for [i (range -1 2) j (range -1 2) :when (or (not= i 0) (not= j 0))]\n                                 [(+ x i) (+ y j)]))\n            (alive? [pos] (case (reduce\n                                  #(if (= \\# (get-in board %2)) (inc %) %)\n                                  0\n                                  (neighbors pos))\n                            2 (get-in board pos)\n                            3 \\#\n                            \\space))\n            ]\n      (map #(apply str %)\n           (partition (width board)\n                      (map alive? (for [x (range (width board)) y (range (height board))] [x y])))\n           )))","user":"55e7d06ee4b050e68259b496"},{"problem":94,"code":"(fn [rows]\n  (let [rows (mapv #(mapv #{\\#} %) rows)]\n    (for [i (range (count rows))]\n      (apply str\n             (for [j (range (count (first rows)))\n                   :let [neighbors\n                         (apply +\n                                (for [i' [-1 0 1] \n                                      j' [-1 0 1]\n                                      :when (not (= 0 i' j'))]\n                                  (if (get-in rows [(+ i i') (+ j j')]) 1 0)))]]\n               (if (or (= neighbors 3)\n                       (and (= neighbors 2) (get-in rows [i j])))\n                 \\# \\space))))))","user":"562cd94ee4b0a45d2ff83015"},{"code":"(fn game-of-life [board]\n  (let [n (count board)]\n    (letfn [(board->coordinates [board]\n              (set (for [x (range n) y (range n)\n                         :when (= \\# (get-in board [x y]))] [x y])))\n            (neighbors [[x y]]\n              (set (for [dx [-1 0 1] dy [-1 0 1] :when (not= 0 dx dy)]\n                     [(+ x dx) (+ y dy)])))\n            (step [coordinates]\n              (for [[cell n] (frequencies (mapcat neighbors coordinates))\n                    :when (or (= n 3)\n                              (and (= n 2) (coordinates cell)))]\n                cell))\n            (coordinates->board [coordinates]\n              (let [blank-board (vec (repeat n (vec (repeat n \\space))))]\n                (->> coordinates\n                     (reduce #(assoc-in % %2 \\#) blank-board)\n                     (map #(apply str %)))))]\n      (->> board\n           board->coordinates\n           step\n           coordinates->board))))","problem":94,"user":"4f3fb586e4b0e243712b1f9c"},{"problem":94,"code":"(fn game-of-life [board]\n  (letfn [(find-cells [board]\n            (map-indexed (fn [i row]\n                           (map-indexed (fn [j ch]\n                                          (let [ln (count (live-neighbors board [i j]))]\n                                            (if (= ch \\#)\n                                              (if (or (< ln 2) (> ln 3)) \\space ch)\n                                              (if (= ln 3)                \\#    ch))))\n                                        row))\n                         board))\n\n          (valid-live-cell? [board [i j] max-i max-j]\n            (and (>= i 0) (>= j 0) (< i max-i) (< j max-j) (= (get-in board [i j]) \\#)))\n\n          (live-neighbors [board [i j]]\n            (let [max-i (count board)\n                  max-j (count (first board))]\n              (->> [[(dec i) j] [(dec i) (dec j)] [i (dec j)] [(inc i) (dec j)]\n                    [(inc i) j] [(inc i) (inc j)] [i (inc j)] [(dec i) (inc j)]]\n                   (filter #(valid-live-cell? board %1 max-i max-j)))))]\n    (mapv #(apply str %1) (find-cells board))))","user":"57c500f9e4b05aa3c4741cda"},{"problem":94,"code":"(fn gl [board]\n  (let [neighbors (fn [x y c]\n                    (apply + (for [dx [-1 0 1]\n                                   dy [-1 0 1]]\n                               (if (and (zero? dx) (zero? dy)) 0\n                                 (if (= \\# (get-in board [(+ x dx)\n                                                          (+ y dy)]))\n                                   1 0)))))]\n    (->> board\n         (map-indexed\n           (fn [x row]\n             (->> row\n                  (map-indexed\n                    (fn [y c]\n                      (case c\n                        \\# (if (< 1 (neighbors x y c) 4) \\# \\ )\n                        \\  (if (= 3 (neighbors x y c)) \\# \\ ))))\n                  (clojure.string/join \"\")))))))","user":"57a0b341e4b0c3d858beb8d4"},{"problem":94,"code":"(fn life-game-next\n    ([v] (life-game-next v (count v) (.length v)))\n    ([v n m]\n      (letfn [(getnm [v i j] (-> v (nth i) (nth j)))\n              (count-around-cell [v n m x y]\n                (->>\n                  (for [i (range (- x 1)  (+ x 2)) j (range (- y 1)  (+ y 2))\n                        :when (and\n                                   (not (and (= i x) (= j y)))\n                                   (<=  0 i) (<= 0 j)\n                                   (<  i n) (< j m)\n                                   )]\n                    (getnm v i j))\n                  (filter #(= \\# %))\n                  count))\n              (next-state [v n m x y]\n                (let [cnt (count-around-cell v n m x y)]\n                  (cond\n                        (= cnt 3)  \\#\n                        (= cnt 2) (getnm v x y)\n                        :else  \\space))) ]\n        (for [i (range 0 n)]\n          (->> (for [j (range 0 m)]\n                 (next-state v n m i j))\n            (apply str)) ))))","user":"55aa1637e4b0988bba2ad949"},{"problem":94,"code":"(fn [board] \n  (let [pad (apply str (repeat (count (first board)) \\space))\n        res (map #(str \" \" (apply str %) \" \") (map\n                                                          (fn [[x1 x2 x3]]\n                                                            (map (fn [[i x]]\n                                                                   (let [cc [(x1 (dec i)) (x1 i) (x1 (inc i)) (x2 (dec i)) (x2 (inc i)) (x3 (dec i)) (x3 i) (x3 (inc i))]\n                                                                         live (count (filter #{\\#} cc))]\n                                                                     (cond\n                                                                       (= x \\#)\n                                                                       (if (or (> 2 live) (<= 4 live))\n                                                                         \\space\n                                                                         \\#)\n                                                                       :else\n                                                                       (if (= 3 live) \\# \\space)\n                                                                       ))\n                                                                   ) (drop-last (rest (map-indexed vector x2))))\n                                                            )\n                                                          (partition 3 1 (map vec board))))]\n    (concat [pad] res [pad])))","user":"529dfc6de4b04e0c58e87b8a"},{"problem":94,"code":"(fn[a](\n\nmap (fn[s](apply str s)) (\npartition (count(first a)) (        \nmap char (\n           \nloop[\n\nm\n\n(concat\n[(flatten(repeat (+ 2 (count (first a))) '(32) ))]\n(map (fn[w](flatten(conj '(32) (map int (seq w)) '(32)))) a)\n[(flatten(repeat (+ 2 (count (first a))) '(32) ))])\n\nn []\n\nx 1\ny 1\n](\n\nif(= y (dec(count m))) n\n  (if(= x (dec(count (first m)))) \n    (recur m (concat n []) 1 (inc y))\n    (recur m\n      (conj n \n        (let[\n          z (nth (nth m y) x)\n          w (+ (nth (nth m (dec y)) (dec x)) (nth (nth m (dec y)) x) (nth (nth m (dec y)) (inc x)) (nth (nth m y) (dec x)) (nth (nth m y) (inc x)) (nth (nth m (inc y)) (dec x)) (nth (nth m (inc y)) x) (nth (nth m (inc y)) (inc x)) )\n        ](\n\t        if (= z 32) (if (= w 265) 35 32)\n             (cond\n               (< w 262) 32\n               (> w 265) 32\n               :else 35)\n        ))\n      )\n      (inc x) y)\n  )\n));\n\n)\n))\n)","user":"56039843e4b04bb52996e1be"},{"problem":94,"code":"(fn [b]\n  (let [w (count (first b)) h (count b)]\n     (letfn [(in-bounds? [b r c] (and (<= 0 r) (> h r) (<= 0 c) (> w c)))\n\t     (alive? [b r c] (and (in-bounds? b r c) (= \\# (nth (nth b r) c))))\n\t     (adjacent-cells [r c] [[(inc r) c] [(dec r) c] [r (inc c)] [r (dec c)] [(dec r) (dec c)] [(inc r) (dec c)] [(inc r) (inc c)] [(dec r) (inc c)]])\n\t     (neighbor-count [b r c] (count (filter true? (map #(apply alive? b %) (adjacent-cells r c)))))\n\t     (step-cell [b [r c]] (let [n (neighbor-count b r c)] (if (alive? b r c) (cond (< n 2) \\  (> n 3) \\  :else \\#) (if (= 3 n) \\# \\ ))))]\n\t (map #(apply str %) (partition w (map (partial step-cell b) (for [r (range h) c (range w)] [r c])))))))","user":"52d07cc5e4b07d0d72b273bb"},{"problem":94,"code":"(fn evolve-life [strs]\n  (let [->strs (fn [b] (map #(apply str %) b))\n        ->board #(vec (map vec %))\n        neighbors (fn neighbors [board coord]\n                    (let [neighbor-coords (let [d (range -1 2)]\n                                            (for [xd d\n                                                  yd d\n                                                  :when (not= xd yd 0)\n                                                  :let [c (map + [xd yd] coord)]\n                                                  :when (every? (complement neg?) c)\n                                                  :when (< (first c) (count board))\n                                                  :when (< (second c) (count (first board)))]\n                                              c))]\n                      (map (partial get-in board) neighbor-coords)))\n        board (->board strs)\n        coords (for [row (range (count board))\n                     col (range (count (first board)))]\n                 [row col])\n        update-cell (fn [board-write coord]\n                      (let [cell (get-in board coord)\n                            neighbors (neighbors board coord)\n                            neighbor-map (group-by identity neighbors)\n                            neighbor-counts (into {}\n                                                  (map (fn [[k v]] [k (count v)]) neighbor-map))\n                            live-neighbors (get neighbor-counts \\# 0)\n                            new-cell (if (= cell \\#)\n                                       (cond\n                                         (< live-neighbors 2) \\space\n                                         (< live-neighbors 4) \\#\n                                         :else \\space)\n                                       (if (= live-neighbors 3)\n                                         \\#\n                                         \\space))]\n                        (assoc-in board-write coord new-cell)))]\n    (->strs (reduce update-cell board coords))))","user":"5ca14eb1e4b048ec896c5b7d"},{"problem":94,"code":"(fn [board]\n  (let [becomes (fn [cell live-neighbours]\n                  (if (= cell \\#)\n                    (if (or (= 2 live-neighbours) (= 3 live-neighbours))\n                      \\#\n                      \\space)\n                    (if (= 3 live-neighbours)\n                      \\#\n                      \\space)))\n        rows (count board)\n        cols (count (first board))]\n    (->> board\n         (map-indexed (fn [i row]\n                        (map-indexed (fn [j cell]\n                                       (let [live (->> (for [x (range (max 0 (dec i)) (min rows (+ i 2)))\n                                                             y (range (max 0 (dec j)) (min cols (+ j 2)))\n                                                             :when (not (and (= i x) (= j y)))]\n                                                         (get (board x) y))\n                                                       (filter (partial = \\#))\n                                                       count)]\n                                         (becomes cell live)))\n                                     row)))\n         (map clojure.string/join))))","user":"5ec6de19e4b08d0ec38692da"},{"problem":94,"code":"(fn __ [matrix]\n  (let [nrow (count matrix)\n        ncol (count (first matrix))\n        nbor (fn [x y dx dy]\n               (let [x' (+ x dx)\n                     y' (+ y dy)]\n                 (if (and (< -1 x' ncol)\n                          (< -1 y' nrow))\n                   (cond\n                     (= dx dy 0) 0\n                     (= \\# (get-in matrix [y' x'])) 1\n                     :else 0)\n                   0)))\n        nbors (fn [x y]\n                (apply + (for [dx [-1 0 1]\n                               dy [-1 0 1]]\n                           (nbor x y dx dy))))\n        next-state (fn [state nb-count]\n                     (cond\n                       (= nb-count 3) true                  ; rule #4\n                       (< nb-count 2) false                 ; rule #1\n                       (< nb-count 4) state                 ; rule #2\n                       :else false))]                       ; rule #3\n    (for [y (range nrow)]\n      (apply str\n        (for [x (range ncol)]\n          (let [cur-state (= \\# (get-in matrix [y x]))\n                nb-count (nbors x y)]\n            (if (next-state cur-state nb-count) \\# \\space)))))))","user":"536d83cee4b0fc7073fd6e5e"},{"problem":94,"code":"(fn next-state [board]\n               (letfn [(count-neighbors-alive [x y]\n                         (reduce + (map-indexed (fn count-living-on-row [i row]\n                                                  (reduce + (map-indexed (fn [j p]\n                                                                           (if (and (<= i (inc x)) (>= i (dec x)) (<= j (inc y)) (>= j (dec y)) (or (not (= i x)) (not (= j y))) (= p \\#)) 1 0)) row))) board)))]\n                 (map-indexed (fn [i row]\n                                (apply str (map-indexed (fn [j p]\n                                                 (let [cnt (count-neighbors-alive i j)]\n                                                   (if (= p \\#)\n                                                     (if (< cnt 2)\n                                                       \\space\n                                                       (if (< cnt 4)\n                                                         \\#\n                                                         (if (> cnt 3)\n                                                           \\space)))\n                                                     (if (= cnt 3)\n                                                       \\#\n                                                       \\space)))) row))) board)))","user":"5746061ae4b009280f9f2b5b"},{"problem":94,"code":"(fn next-board-2\n  [board]\n  (letfn [(cell [board [i j]] (= (get (get board i) j) \\#))\n          (add-coords [xs ys] (map + xs ys))\n          (live-neighbors [board coords]\n            (let [relpos [[-1 -1] [-1 0] [-1 1]\n                          [0 -1] [0 1]\n                          [1 -1] [1 0] [1 1]]]\n              (count\n               (filter (partial cell board)\n                       (map (partial add-coords coords) relpos)))))\n          (next-cell [board coords]\n            (let [n (live-neighbors board coords)\n                  c (cell board coords)]\n              (if (or (and (= n 2) c)\n                      (= n 3))\n                \"#\" \" \")))]\n    (map (partial apply str)\n       (for [i (range 0 (count board))]\n         (for [j (range 0 (count (get board i)))]\n           (next-cell board [i j]))))))","user":"52ea025ae4b09f7907dd14b5"},{"problem":94,"code":"(fn [B]\n  (letfn [\n          (neighbours [B2d x y]\n             (let [maxx (count B2d)\n                   maxy (count (first B2d))]\n                  (for [ix (range (- x 1) (+ x 2)) \n                        iy (range (- y 1) (+ y 2)) \n                              :when (or (not= x ix) (not= y iy)) \n                              :when (and (<= 0 ix) (<= 0 iy))\n                              :when (and (< ix maxx) (< iy maxy)) ] (aget B2d ix iy))))\n          (eval-cell [B2d x y] \n             (let [cs  (group-by identity (neighbours B2d x y))\n                   nlive (count (cs \\#))\n                   s (aget B2d x y)]\n                     (cond \n                        (and (= s \\#) (< nlive 2)) \\space\n                        (and (= s \\#) (or (= 2 nlive) (= 3 nlive))) \\# \n                        (and (= s \\#) (> nlive 3)) \\space\n                        (and (= s \\space) (= 3 nlive)) \\# \n                        :else s)))          \n          ]\n         (let [r (for [x (range (count B)) \n                       y (range (count (first B)))] \n                          (eval-cell (to-array-2d B) x y))] \n             (into [] (map #(apply str %) (partition (count B) r))))))","user":"56fa2905e4b07572ad1a88be"},{"code":"(fn next-board [strs]\r\n  (let [h (count strs), w (count (first strs))]\r\n    (letfn [(life? [i j]\r\n                   (= \\# (nth (nth strs i) j)))\r\n            (in-board? [i j]\r\n                      (and (>= i 0) (< i h) (>= j 0) (< j w)))\r\n            (count-around [i j]\r\n                          (reduce + \r\n                                  (for [x [-1 0 1], y [-1 0 1] :when (not (= x y 0))]\r\n                                    (cond (not (in-board? (+ i x) (+ j y))) 0\r\n                                          (life? (+ i x) (+ j y)) 1\r\n                                          :else 0))))]\r\n      (for [y (range h)]\r\n        (apply str\r\n               (for [x (range w)]\r\n                 (let [around (count-around y x)]\r\n                   (if (life? y x)\r\n                     (if (or (= around 2) (= around 3)) \\# \\space)\r\n                     (if (= around 3) \\# \\space )))))))))","problem":94,"user":"4f62b29ce4b0defedf855fd9"},{"code":"(fn [strs]\n\t(let [\n\t\tm (count strs)\n\t\tn (count (first strs))\n\t\tnbs (fn [[x y]] \n\t\t\t(for [dx [-1 0 1] dy [-1 0 1] :when (not= 0 dx dy)]\n\t\t\t\t[(+ x dx) (+ y dy)]))\n\t\tconv-to (fn [strs]\n\t\t\t\t\t(reduce (fn [res pos] \n\t\t\t\t\t\t\t\t(if (= \\# (get-in strs pos)) \n\t\t\t\t\t\t\t\t\t(conj res pos) res))\n\t\t\t\t\t\t[] \n\t\t\t\t\t\t(for [i (range m)\n\t\t\t\t\t\t\t  j (range n)]\n\t\t\t\t\t\t\t[i j])))\n\t\tconv-back (fn [poss]\n\t\t\t\t\t(let [mapp (vec (repeat m (vec (repeat n \\space))))]\n\t\t\t\t\t\t(reduce #(assoc-in % %2 \\#) mapp poss)))\n\t\tposs (set (conv-to strs))\n\t\tmapp (frequencies (apply clojure.set/union (map nbs poss)))\n\t\tnew-poss (filter \n\t\t\t#(or (= 3 (mapp %)) (and (= 2 (mapp %)) (poss %))) \n\t\t\t(map first mapp))]\n\t\t(println poss)\n\t\t(map (partial apply str) (conv-back new-poss))))","problem":94,"user":"520242bae4b030ee0c5b26e3"},{"code":"(fn [b]\n (letfn [(nbors [b x y]\n           (count\n            (filter (fn [a] (= a \\#))\n                    (mapcat\n                     (fn [i] (map\n                              (fn [j] (if (and (= i 0) (= j 0))\n                                        nil\n                                        (get (get b (- x i)) (- y j))))\n                              (range -1 2)))\n                     (range -1 2)))))]\n   (map (fn [a] (apply str a))\n        (map (fn [i]\n               (map\n                (fn [j] [i j]\n                  (let [e (get (get b i) j)\n                        n (nbors b i j)]\n                    (if (= e \\#)\n                      (if (or (= 3 n) (= 2 n))\n                        \\# \\space)\n                      (if (= 3 n)\n                        \\# \\space))))\n                (range (count b)))) (range (count (first b)))))))","problem":94,"user":"5097b556e4b00ad8bab4e970"},{"problem":94,"code":"(fn life-game\n  [board]\n  (let [nrow (count board)\n        ncol (count (first board))\n         gen-cell-at-next-step (fn [board pos]\n                                (let [current-cell (get-in board pos)\n                                      get-neighbours (fn nbs [board [x y]]\n                                                       (map #(get-in board %)\n                                                            (for [i '(-1 0 1)\n                                                                  j '(-1 0 1)\n                                                                  :when (or (not= i 0) (not= j 0))]\n                                                              [(+ x i) (+ y j)])))\n                                      total-live-neighbours (count (filter #(= % \\#) (get-neighbours board pos)))]\n                                  (if (= current-cell \\#)\n                                    (cond\n                                      (or (= total-live-neighbours 2) (= total-live-neighbours 3)) \\#\n                                      :else \\space)  ;; live now\n                                    (cond\n                                      (= total-live-neighbours 3) \\#\n                                      :else \\space))  ;; dead now\n                                  ))\n        -charlist (for [x (range nrow)\n                        y (range ncol)\n                        :let [pos [x y]]]\n                    (gen-cell-at-next-step board pos))\n        next-board (map #(apply str %) (partition ncol -charlist))]\n    next-board))","user":"56fbf83de4b07572ad1a88da"},{"code":"(let [indexed (fn [coll] (map vector (range) coll))\n      offsets [[-1 -1] [-1 0] [-1 1] [0 -1] [0 1] [1 -1] [1 0] [1 1]]\n      live? (fn [c] (= c \\#))\n      live-neighbors (fn [addr board] (->> offsets\n                                           (map #(map + addr %))\n                                           (map #(get-in board %))\n                                           (filter live?)))]\n  (fn [board] (->> (for [[i row] (indexed board)]\n                     (for [[j c] (indexed row)]\n                       (let [n (count (live-neighbors [i j] board))]\n                         (cond\n                          (and (live? c) (< n 2)) \\space\n                          (and (live? c) (<= 2 n 3)) \\#\n                          (and (live? c) (> n 3)) \\space\n                          (= n 3) \\#\n                          :else c))))\n                   (map #(apply str %)))))","problem":94,"user":"4ebcb8ff535dfed6da9c6d8a"},{"problem":94,"code":"(fn [b]\n    (let [w (-> b first count)\n          h (-> b count)\n          ds [-1 0 1]]\n      (letfn [(neighbors [[x y]]\n                (filter (fn [[x2 y2]]\n                          (and (not (and (= x x2) (= y y2)))\n                               (and (not= x2 -1) (< x2 w))\n                               (and (not= y2 -1) (< y2 h))))\n                        (for [dx ds dy ds]\n                          [(+ x dx) (+ y dy)])))\n              (next [[x y] ns]\n                (let [live\n                      (->> ns\n                           (map (fn [[x y]] (-> b (get x) (get y))))\n                           (filter #(= % \\#))\n                           count)]\n                  (if (= \\space (-> b (get x) (get y)))\n                    (if (= live 3) \\# \\space)\n                    (condp >= live\n                      1 \\space\n                      3 \\#\n                      \\space))))]\n        (->>\n         (for [x (range w)\n               y (range h)]\n           [x y])\n         (map #(next % (neighbors %)))\n         (partition w)\n         (map (partial apply str))))))","user":"4f57c913e4b0a7574ea7183f"},{"code":"(fn conway [state]\n  (letfn \n    [(index-board \n      [board]\n        (map #(map-indexed vector %) board))\n     (neighbor-in-row\n      [row indexed-cell]\n      (if (empty? row) 0\n      (let [idx (first indexed-cell)\n            target (if (= idx 0) (take 2 row)\n                     (take 3 (drop (dec (first indexed-cell)) row)))]\n        (count (filter #(= \"#\" (str (second %))) target)))))\n     (calc-neighbors \n      [row-above row row-below]\n      (let [cts-above (map #(neighbor-in-row row-above %) row)\n            cts-below (map #(neighbor-in-row row-below %) row)\n            cts-adjacent (map #(if (= \"#\" (str (second %)))\n                                (dec (neighbor-in-row row %))\n                                 (neighbor-in-row row %))row)\n            cts (map + cts-above (map + cts-below cts-adjacent))]\n        (map #(list %1 (str (second %2))) cts row)))\n     (calc-board \n      [acc1 acc2 board]\n      (if (empty? board) (reverse acc1)\n        (recur\n          (conj acc1 \n                (calc-neighbors (first acc2) (first board) (first (rest board))))\n          (conj acc2 (first board))\n         (rest board))))\n     (process-cell\n      [cell]\n      (let [ct (first cell)\n            alive (= \"#\" (second cell))]\n        (cond (and alive (< ct 2)) \" \"\n              (and alive (or (= 3 ct) (= ct 2))) \"#\"\n              (and alive (> ct 3)) \" \"\n              (and (not alive) (= 3 ct)) \"#\"\n              0 (second cell))))]\n    (map #(apply str (map process-cell %)) (calc-board '() '() (index-board state)))))","problem":94,"user":"5273e006e4b03e8d9a4a7495"},{"problem":94,"code":"(fn life-full [board]\n  (letfn [(dim-board [board]\n                     (hash-map :rows (count board) :cols (count (first board))))\n          (extend-board [board]\n                        (let [{:keys [rows cols]} (dim-board board)\n                              emp-row (apply str (repeat (+ 2 cols) \" \"))]\n                          (vec (concat [emp-row] (map #(str \" \" % \" \") board) [emp-row]))))\n          (sub-board [board x y]\n                     (let [sub-rows (take 3 (drop (dec y) board))]\n                       (map #(subs % (dec x) (+ 2 x)) sub-rows)))\n          (calculate-neighbours [sub-board]\n                                (let [[a b c] sub-board\n                                      [b1 b2 b3] b]\n                                  (hash-map \n                                   :state b2\n                                   :neighbours (count (filter #{\\#} (concat a c [b1 b3]))))))\n          (live-or-die [{:keys [state neighbours]}]\n                       (if (= state \\#)\n                          (if (contains? #{2 3} neighbours) \\# \\space)\n                          (if (= 3 neighbours) \\# \\space)))]\n  (let [ext-board (extend-board board)\n        {:keys [rows cols]} (dim-board board)]\n    (map\n      (fn [ri] \n        (apply str\n               (map (fn [ci] (live-or-die (calculate-neighbours (sub-board ext-board ci ri))))\n                    (map inc (range cols))))) \n      (map inc (range rows))))))","user":"53286f84e4b09d4e7a9b5505"},{"problem":94,"code":"(fn game-of-life [board]\n  (let [rows (count board)\n        cols (count (first board))\n        cells (for [i (range rows) j (range cols)] [i j])\n        neighbors (fn [[i j]] (for [di [-1 0 1]\n                                    dj [-1 0 1]\n                                    :when (not= di dj 0)] [(+ i di) (+ j dj)]))\n        live-cell? (fn [cell] (= (get-in board cell) \\#))\n        live-neighbors (fn [cell] (count (filter live-cell? (neighbors cell))))\n        next-state (fn [cell]\n                     (let [ln (live-neighbors cell)]\n                       (if (live-cell? cell)\n                         (if (or (= ln 2) (= ln 3)) \\# \\space)\n                         (if (= ln 3) \\# \\space))))]\n    (map #(apply str %) (partition cols (map next-state cells)))))","user":"5879d577e4b01531a375ead8"},{"problem":94,"code":"(fn game-of-life [board]\r\n  (let [ new-cell (fn [vv]\r\n                    (let [alive? (= 1 (second (second vv)))\r\n                          sum    (reduce + (flatten vv))]\r\n                      (if alive?\r\n                        (if (or (= 3 sum) (= 4 sum)) 1 0 ) \r\n                        (if (= 3 sum) 1 0 ))))\r\n    \r\n         part-board (fn [vv]\r\n                      (map \r\n                        (fn [[a b c]] (partition 3 1 (map vector a b c)))\r\n                        (partition 3 1 vv)))\r\n  \r\n         parse-board  (fn [c]\r\n                        (map \r\n                          (fn [a] (map #(if (= \\# %1) 1 0) a))\r\n                          c))\r\n  \r\n         frame-board  (fn [vv]\r\n                        (let [l (repeat (count (first vv)) 0)\r\n                              between (fn[c a] (conj (reverse (conj (reverse c) a)) a))]\r\n                          (map #(between % 0) (between vv l))))\r\n         \r\n         draw-board (fn [vv]\r\n                      (map \r\n                        (fn [l] \r\n                          (apply str (map #(if (= % 1) \\# \\  ) l)))\r\n                        vv))]\r\n    (draw-board\r\n      (map\r\n        #(map new-cell %)\r\n        (part-board (frame-board (parse-board board)))))))","user":"5470699ae4b00cfc9eacc1b6"},{"problem":94,"code":"(fn\n  [game]\n  (let [width (count (first game))\n        board (mapcat #(seq %) game)\n        neighbours (vector [-1 -1] [-1 0] [-1 1] [0 -1] [0 1] [1 -1] [1 0] [1 1])]\n    (->> (map-indexed\n           #((fn [i cell] \n             (let [nb-cnt (count \n                            (filter \n                              (fn [nb-list] (= nb-list \\#))\n                              (map (fn [nb-pos]\n                                     (get-in game (mapv + [(int (/ i width)) (mod i width)] nb-pos))) \n                                     neighbours)))]\n               (case cell \n                 \\# (if (or (< nb-cnt 2) (> nb-cnt 3)) \\space \\#)\n                 (if (= nb-cnt 3) \\# \\space)))) %1 %2) board)\n         (partition width)\n         (mapv #(apply str %)))))","user":"5707b96fe4b0b0fb43fd0690"},{"code":"(fn [board]\n    (letfn [(neighbours [board row col]\n              (map #(get-in board %)\n                   (concat (map (fn [c] [(dec row) c]) [(dec col) col (inc col)])\n                           (list [row (dec col)] [row (inc col)])\n                           (map (fn [c] [(inc row) c]) [(dec col) col (inc col)]))))\n            (live-neighbours [board row col]\n              (count (filter #(= \\# %) (neighbours board row col))))\n            (next-state [board row col]\n              (let [n (live-neighbours board row col)]\n                (if (= (get-in board [row col]) \\#)\n                  (if (#{2 3} n) \\# \\space)\n                  (if (= n 3) \\# \\space))))]\n           (map (fn [row] (apply str (map (fn [col] (next-state board row col))\n                                          (range (count (board row)))))) \n                (range (count board)))))","problem":94,"user":"4ee3b586535d10e5ff6f5371"},{"code":"(fn [rs]\n  (let [r [-1 0 1]\n        g #(get-in rs [% %2])\n        h #({\\# 1} (g %2 %) 0)\n        trs (for [y (range (count rs))]\n              (for [x (range (count (rs 0)))]\n                [(g x y)\n                (apply + (for [j r, k r]\n                           (h (+ x j) (+ y k))))]))\n        f (fn [[c s]] (if (or (= s 3) (and (= c \\#) (= s 4))) \"#\" \" \"))]\n    (map #(apply str (map f %)) trs)))","problem":94,"user":"522b922ee4b0d34ee08e71c3"},{"code":"(fn gol-step [board]\n    (letfn [(cell [x y]\n              (get (board y) x))\n            (out-of-bounds? [x y] (let [h (count board)\n                                        w (count (first board))]\n                                    (or (< x 0) (< y 0) (>= x w) (>= y h))))\n            (neighbours [x y]\n              (filter #(not (apply out-of-bounds? %))\n                      [[(- x 1) (- y 1)] [x (- y 1)] [(+ x 1) (- y 1)]\n                       [(- x 1) y]       ,,,,,,,,,,, [(+ x 1) y]\n                       [(- x 1) (+ y 1)] [x (+ y 1)] [(+ x 1) (+ y 1)]]))\n            (step-cell [x y]\n              (let [neighbour-cells (map #(apply cell %) (neighbours x y))\n                    alive-neighbours (count (filter (partial = \\#) neighbour-cells))]\n                (if (= \\# (cell x y))\n                  (cond\n                    (< alive-neighbours 2) \\space\n                    (< alive-neighbours 4) \\#\n                    :else \\space)\n                  (if (= alive-neighbours 3) \\# \\space))))]\n      (map-indexed\n        (fn [j row]\n          (apply str\n                 (map-indexed (fn [i _]\n                                (step-cell i j)) row))) board)))","problem":94,"user":"5141abf1e4b02fd87f5064c3"},{"code":"(fn live[board]\n (let \n   [dim (count (first board))\n    board-x \n      ; expand by one extra zero-filled row/col from each side\n      (map \n         #(concat [0] (map (fn [x] ({\\space 0 \\# 1} x)) %) [0])\n       (concat [(repeat dim \\space)] \n               board\n               [(repeat dim \\space)] \n       ))\n     xy   (fn [x y] (nth (nth board-x (inc x)) (inc y)))\n     cnt  (fn [x y] \n            (apply +\n             (for [dx [-1 0 1] dy [-1 0 1]\n                   :when (not (= 0 dx dy))] \n              (xy (+ x dx) (+ y dy)) )))\n     ]\n    (for [x (range dim)]\n      (apply str (for [y (range dim)\n            :let [alive? (= 1 (xy x y))\n                  cntxy  (cnt x y)]]\n       (cond \n        (and alive? (<  cntxy 2)) \\space\n        (and alive? (<= cntxy 3)) \\#\n        alive?                    \\space\n        (= cntxy 3)               \\#\n        :else                     \\space))))\n    ))","problem":94,"user":"50de11b2e4b061dbdced7217"},{"problem":94,"code":"(fn[s]\n  (let\n    [mi (count s) mj (count (s 0))\n     ge (fn[i j] (get (s i) j))\n     f (fn[i j] (if (or (< i 0) (= i mi) (< j 0) (= j mj)) [] [(ge i j)]))\n     nb (fn[i j] (concat (f (dec i) (dec j)) (f (dec i) j) (f (dec i) (inc j)) (f i (dec j)) (f i (inc j)) (f (inc i) (dec j)) (f (inc i) j) (f (inc i) (inc j))))\n     lv (fn[i j] (count (filter #(= \\# %) (nb i j))))\n     g (fn[i j c] (let [d (lv i j)] (if (or (= d 3) (and (= d 2) (= c \\#))) \\# \\space)))]\n    (map-indexed (fn[i s2] (apply str (map-indexed (fn[j c] (g i j c)) s2))) s)))","user":"56824e1be4b0945ebc182a91"},{"problem":94,"code":"(fn [m]\n (let [matrix (vec (map vec m))\n       row (count matrix)\n       col (count (first matrix))]\n   (letfn [(get [x y] (nth (nth matrix x []) y nil))\n           (getneighbor [x y] (frequencies (conj []\n                                    (get (dec x) y) ;up\n                                    (get (inc x) y) ;down\n                                    (get x (dec y)) ;left\n                                    (get x (inc y)) ;right\n                                    (get (dec x) (dec y)) ;upleft\n                                    (get (dec x) (inc y)) ;upright\n                                    (get (inc x) (dec y)) ;downleft\n                                    (get (inc x) (inc y)) ;downright\n                              )))\n           (surviveOrDieOrReborn? [x y]\n            (cond\n             (= \\space (get x y)) (if (= 3 ((getneighbor x y) \\#)) \\# \\space)\n             (= \\# (get x y)) (cond\n                                (< ((getneighbor x y) \\#) 2) \\space\n                                (= ((getneighbor x y) \\#) 2) \\#\n                                (= ((getneighbor x y) \\#) 3) \\#\n                                (> ((getneighbor x y) \\#) 3) \\space)))]\n      (map #(clojure.string/join %) (partition col (for [x (range row) y (range col)] (surviveOrDieOrReborn? x y)))))))","user":"57dd47f4e4b0bd073c20243e"},{"problem":94,"code":"(fn life-iter [b]\n  (letfn [(new-state [pos]\n            (let [cell (get-in b pos) alive (= cell \\#)\n                  nb (count (filter #{\\#} (map #(get-in b % nil)\n                                               (map (partial map + pos)\n                                                    [[-1 -1] [-1 0] [-1 1] [0 -1] [0 1] [1 -1] [1 0] [1 1]]))))]\n              (cond (and alive (< nb 2))       \\space\n                    (and alive (> nb 3))       \\space\n                    (and alive (<= 2 nb 3))    \\#\n                    (and (not alive) (= nb 3)) \\#\n                    :else cell)))]\n    (map #(apply str %)\n         (reduce #(assoc-in % %2 (new-state %2)) (mapv vec b)\n                 (for [x (range (count b)) y (range (count (first b)))] [x y])))))","user":"575b3e9be4b02ea11479935b"},{"code":"(fn [b]\n    (let [h (count b)\n          hr (range 0 h)\n          w (count (first b))\n          wr (range 0 w)]\n      (for [hi hr]\n        (apply str\n        (for [wi wr]\n          (let [live \\#\n                dead \\space\n                live? #(= live %)\n                dead? #(not (live? %))\n                live-nbs #(count (filter live? %))\n                cell (get (get b hi) wi)\n                nbs (map \n                      (fn [[aw ah]] [(+ wi aw) (+ hi ah)])\n                      [[-1 -1] [-1 0] [-1 1] [0 1] [0 -1] [1 -1] [1 0] [1 1]])\n                nbs2 (filter \n                       (fn [[aw ah]] \n                         (not (or (neg? aw) \n                                  (neg? ah)\n                                  (>= aw w)\n                                  (>= ah h))))\n                       nbs)\n                nbs3 (map (fn [[wi hi]] \n                            (get (get b hi) wi)) \n                          nbs2)] \n            (cond\n              (and (dead? cell) \n                   (= 3 (live-nbs nbs3))) live\n              (and (live? cell) \n                   (or (= 2 (live-nbs nbs3))\n                       (= 3 (live-nbs nbs3)))) live\n              :default dead     \n            )))))))","problem":94,"user":"4f0da4e4535d0136e6c22319"},{"problem":94,"code":"(fn [board]\n              (let [y-length (- (count board) 1)\n                    x-length (- (count (first board)) 1)]\n                (loop [y 0 new-board []]\n                  (if (< y y-length)\n                  (recur (inc y) (conj new-board ((fn [board y x-length y-length]\n                    (loop [x 0\n                           new-slice \"\"]\n                      (let [cell-state (if (= (str (nth (nth board y) x)) \"#\") 1 0)\n                            living-nbs (            (fn [board x y x-length y-length]\n                                          (loop [step 0\n                                                 living-nbs 0]\n                                            (let [nb (nth [[-1 -1] [0 -1] [1 -1]\n                                                             [-1  0]        [1  0]\n                                                             [-1  1] [0  1] [1  1]] step)\n                                                  nb-x-initial (+ x (first nb))\n                                                  nb-y-initial (+ y (second nb))\n                                                  nb-x (cond\n                                                               (< nb-x-initial 0) x-length\n                                                               (> nb-x-initial x-length) 0\n                                                               :else nb-x-initial)\n                                                  nb-y (cond\n                                                               (< nb-y-initial 0) y-length\n                                                               (> nb-y-initial y-length) 0\n                                                               :else nb-y-initial)]\n                                              (if (= (str (nth (nth board nb-y) nb-x)) \"#\")\n                                                (if (< step 7) (recur (inc step) (inc living-nbs)) (inc living-nbs))\n                                                (if (< step 7) (recur (inc step) living-nbs) living-nbs))))) board x y x-length y-length)]\n                        (if\n                          (< x x-length)\n                          (recur (inc x)\n                                 (str new-slice (cond\n                                    (and (= cell-state 1)\n                                    (or (> living-nbs 3) (< living-nbs 2)))  \" \"\n                                    (= cell-state 1) \"#\"\n                                    (= living-nbs 3) \"#\"\n                                   :else \" \")))\n                          (str new-slice (cond\n                               (and (= cell-state 1)\n                               (or (> living-nbs 3) (< living-nbs 2)))  \" \"\n                               (= cell-state 1) \"#\"\n                               (= living-nbs 3) \"#\"\n                              :else \" \")))))) board y x-length y-length)))\n                  (conj new-board ((fn [board y x-length y-length]\n                    (loop [x 0\n                           new-slice \"\"]\n                      (let [cell-state (if (= (str (nth (nth board y) x)) \"#\") 1 0)\n                            living-nbs (            (fn [board x y x-length y-length]\n                                          (loop [step 0\n                                                 living-nbs 0]\n                                            (let [nb (nth [[-1 -1] [0 -1] [1 -1]\n                                                             [-1  0]        [1  0]\n                                                             [-1  1] [0  1] [1  1]] step)\n                                                  nb-x-initial (+ x (first nb))\n                                                  nb-y-initial (+ y (second nb))\n                                                  nb-x (cond\n                                                               (< nb-x-initial 0) x-length\n                                                               (> nb-x-initial x-length) 0\n                                                               :else nb-x-initial)\n                                                  nb-y (cond\n                                                               (< nb-y-initial 0) y-length\n                                                               (> nb-y-initial y-length) 0\n                                                               :else nb-y-initial)]\n                                              (if (= (str (nth (nth board nb-y) nb-x)) \"#\")\n                                                (if (< step 7) (recur (inc step) (inc living-nbs)) (inc living-nbs))\n                                                (if (< step 7) (recur (inc step) living-nbs) living-nbs))))) board x y x-length y-length)]\n                        (if\n                          (< x x-length)\n                          (recur (inc x)\n                                 (str new-slice (cond\n                                    (and (= cell-state 1)\n                                    (or (> living-nbs 3) (< living-nbs 2)))  \" \"\n                                    (= cell-state 1) \"#\"\n                                    (= living-nbs 3) \"#\"\n                                   :else \" \")))\n                          (str new-slice (cond\n                               (and (= cell-state 1)\n                               (or (> living-nbs 3) (< living-nbs 2)))  \" \"\n                               (= cell-state 1) \"#\"\n                               (= living-nbs 3) \"#\"\n                              :else \" \")))))) board y x-length y-length))))))","user":"5f548678e4b0a0bc16850a7e"},{"problem":94,"code":"(let [a apply\n      m map\n      c #({3 \\# 4 %} %2 \\ )\n      s #(a + %)\n      n #(m s (partition 3 1 [0] (cons 0 %&)))\n      l #(a str (m c % %2))\n      t #(a n (m {\\  0 \\#  1} %&))]     \n  \n#(m l % (a m n (a m t %))))","user":"5603c31fe4b04bb52996e1c1"},{"problem":94,"code":"(fn [board] \n  (let [n (count board)\n        matrix (vec (map vec board))\n        neighs \n        (fn [x y] (rest \n                   (for [i [0 1 -1] j [0 1 -1]\n                         :when (<= 0 (+ x i))\n                         :when (< (+ x i) n)\n                         :when (<= 0 (+ y j))\n                         :when (< (+ y j) n)] [(+ x i) (+ y j)])))\n        fate \n        (fn [[x y]] \n          (let [score (count (filter #(= \\# %) (map #(get-in matrix %) (neighs x y))))\n                state (get-in matrix [x y])]\n            (cond \n             (and (= state \\#) (< score 2)) \\space\n             (and (= state \\#) (< score 4)) \\#\n             (= state \\#) \\space\n             (and (= state \\space) (= score 3)) \\#\n             :else \\space)))\n        start (vec (for [i (range n)] (apply vector (for [j (range n)] \\#))))\n        ->board (fn [m] (vec (map (partial apply str) (map (partial map str) m))))]\n    (->board (reduce #(assoc-in % %2 (fate %2)) start (for [i (range n) j (range n)] [i j])))))","user":"53976599e4b0b51d73faaeea"},{"problem":94,"code":"(fn [a]\n    (letfn [(to-livemap [r c a]\n              (set (for [x (range (count a))\n                         y (range (count (first a)))\n                         :when (= (get (get a x) y) \\#)]\n                     [x y]))\n              )\n            (neighbors [r c s]\n              (count (for [x (range (dec r) (+ r 2))\n                           y (range (dec c) (+ c 2))\n                           :when (and (not= [r c] [x y]) (s [x y]))]\n                       1)))\n            (next-livemap [r c s]\n              (set (for [x (range r) y (range c)\n                         :when (if (s [x y])\n                                 (#{2 3} (neighbors x y s))\n                                 (= 3 (neighbors x y s)))]\n                     [x y])))\n            (to-world [r c s]\n              (for [x (range r)]\n                (apply str\n                       (for [y (range c)]\n                         ({true \\#, false \\ } (contains? s [x y]))))))]\n      (let [rows (count a)\n            cols (count (first a))]\n        (->> a\n             (to-livemap rows cols)\n             (next-livemap rows cols)\n             (to-world rows cols)))))","user":"54f26266e4b024c67c0cf8c5"},{"problem":94,"code":"(fn next-gen [board]\n  (let [rows (count board)\n        cols (count (first board))\n        cell (fn [[row col]] (nth (nth board row) col))\n        value #(if (= \\# %) 1 0)\n        left (fn [[row col]] [row (dec col)])\n        right (fn [[row col]] [row (inc col)])\n        top  (fn [[row col]] [(dec row) col])\n        bottom  (fn [[row col]] [(inc row) col])\n        top-left #(top (left %))\n        top-right #(top (right %))\n        bottom-left #(bottom (left %))\n        bottom-right #(bottom (right %))\n        valid? (fn [[row col]] (and (>= row 0) (>= col 0) (< row rows) (< col cols)))\n        cell-value #(if (valid? %) (value (cell %)) 0)\n    \tneighbours [left right top bottom top-left top-right bottom-left bottom-right]\n        score (fn [[row col]] (apply + (map (fn [f] (cell-value (f [row col]))) neighbours)))]\n    \t\n    (reduce (fn [acc-rows r] (let [row (count acc-rows)]\n\t\t(concat acc-rows [\n\t\t(reduce (fn [acc-cols c] (let [col (count acc-cols)\n                                       sc (score [row col])\n                                       new (if (= (cell [row col]) \\#)\n                                             (cond (< sc 2) \\space (< sc 4) \\# :else \\space)\n                                             (if (= sc 3) \\# \\space))]\n\n                                   (str acc-cols new)\n\n           )) \"\" r)])\n\t\t)) [] board)))","user":"55a74d46e4b09e57187da2a3"},{"code":"(fn life [generation]\n   (let [gensize (count generation)\n         alive? (fn [x y] (and (> x -1) (> y -1) (< x gensize) (< y gensize) (= (nth (nth generation y) x) \\#)))\n         neighbors (fn [x y]\n                     (reduce #(if (alive? (+ x (first %2)) (+ y (last %2))) \n                                (inc %) %) \n                             0 [[-1 -1] [0 -1] [1 -1]\n                                [-1  0]        [1  0]\n                                [-1  1] [0  1] [1  1]]))]\n     (reduce #(conj %1 (apply str %2)) []\n             (partition gensize\n                        (apply str\n                               (for [y (range gensize)\n                                     x (range gensize)\n                                     :let [a? (alive? x y)\n                                           sibs (neighbors x y)]]\n                                 (cond (and a? (or (< sibs 2) (> sibs 3))) \" \"\n                                       (and a? (or (= 2 sibs) (= 3 sibs))) \"#\"\n                                       (and (not a?) (= 3 sibs)) \"#\"\n                                       :else \" \")))))))","problem":94,"user":"50e4f4e9e4b049a987753896"},{"code":"(fn gol [input]\n  (letfn [\n    (parse [lines]\n      (set\n         (for [[i line] (map-indexed vector lines)\n               [j char] (map-indexed vector line)\n               :when (= char \\#)]\n           [i j])))\n    (adjacents [[i j]]\n      (set\n        (for [di [-1 0 1]\n              dj [-1 0 1]\n              :when (not (= 0 di dj))]\n          [(+ i di) (+ j dj)])))\n    (neighbors [world cell]\n      (count\n       (clojure.set/intersection world (adjacents cell))))\n    (format [rows cols cells]\n      (for [i (range rows)]\n        (apply str \n          (for [j (range cols)]\n            (if (contains? cells [i j]) \\# \\space)))))]\n  (let [rows      (count input)\n        cols      (count (first input))\n        cells     (for [i (range rows)\n                        j (range cols)]\n                    [i j])\n        current   (parse input)\n        survivors (filter #(<= 2 (neighbors current %) 3) \n                          current)\n        newborns  (filter #(= 3 (neighbors current %))\n                          cells)\n        next-gen  (set (concat survivors newborns))]\n    (format rows cols next-gen))))","problem":94,"user":"4f9d53f3e4b0dcca54ed6d21"},{"problem":94,"code":"(fn [p]\n  (let [h (count p) \n        w (count (get p 0))\n        n (fn [y x]\n            (list\n              (get-in p [y x])\n              (count\n             \t (filter #(= % \\#)\n                         (for [a (range (max (- y 1) 0) (min (+ y 2) h))\n                               b (range (max (- x 1) 0) (min (+ x 2) w))\n                               :when (not= [a b] [y x])]\n                           (get-in p [a b]))))))]\n    (for [i (range h)]\n      (apply str\n        (for [j (range w)]\n          (let [[t l] (n i j)]\n            (if (or (and (= t \\#) (or (= l 2) (= l 3)))\n              \t\t(and (= t \\space) (= l 3) ))\n                \\#\n                \" \")))))))","user":"52bacfa8e4b07a9af57922d6"},{"problem":94,"code":"(fn next [board]\n  (let [normalize (fn [board] (mapv (fn [row] (mapv (fn [e] (if (= e \\#) 1 0)) row)) board))\n        shift (fn [board x y]\n                (mapv (fn [row]\n                        (mapv (fn [col]\n                                (get-in board [(+ row y) (+ col x)] 0))\n                              (range (count (first board)))))\n                      (range (count board))))\n        neighbours (fn [board]\n                     (map (fn [[i j]] (shift board i j))\n                          (for [x [-1 0 1] y [-1 0 1] :when (not (and (= x 0) (= y 0)))] [x y])))\n        sum-neigh (fn [boards]\n                    (apply mapv (fn [& rows] (apply mapv (comp (partial reduce +) vector) rows)) boards))\n        pair-mat (fn [a b] (mapv (fn [arow brow] (mapv vector arow brow)) a b))\n        ;; ---\n        nboard (normalize board)\n        nbours (neighbours nboard)\n        decision-board (pair-mat nboard (sum-neigh nbours))]\n    (mapv\n     (fn [row]\n       (apply str\n              (mapv\n               (fn [[l n]]\n                 (if (= l 1)\n                   ;;currently alive\n                   (cond (< n 2) \\space\n                         (= n 2) \\#\n                         (= n 3) \\#\n                         :else \\space)\n                   ;;currently dead\n                   (cond (= n 3) \\#\n                         :else \\space)))\n               row)))\n     decision-board)))","user":"547d8e93e4b0c51c1f4d72f4"},{"problem":94,"code":"(fn [g]\n  (map-indexed\n   (fn [y r]\n     (apply str\n            (map-indexed\n             (fn [x c]\n               (let [d [-1 0 1]\n                     n (count (for [i d j d :when (= \\# (get-in g [(+ y i) (+ x j)]))] 1))]\n                 (if (or (and (= c \\#) (or (= n 3) (= n 4)))\n                         (and (= c \\ ) (= n 3)))\n                   \\# \\ )))\n             r)))\n   g))","user":"55201d18e4b08d5046aa8a5d"},{"code":"(fn [b]\n  (let [cell (fn [[x y]]\n               (nth (b y) x))\n        alive? (fn [[x y]]\n                 (if (or (< y 0) (>= y (count b)))  \n                   0                                    \n                   (if (or (< x 0) (>= x (count (b y))))                 \n                     0\n                     (if (= \\# (nth (b y) x))\n                       1\n                       0))))\n        env [[-1 -1] [0 -1] [1 -1] [-1 0] [1 0] [-1 1] [0 1] [1 1]]\n        neighbourcount (fn [c]\n                         (apply + (map #(alive? (map + c %)) env)))\n        newval (fn [c]\n                 (if (or (< (neighbourcount c) 2) (> (neighbourcount c) 3))\n                   \" \"\n                   (if (= (neighbourcount c) 3)\n                     \"#\"\n                     (cell c)) ))\n        newrow (fn [y]\n                 (apply str (map #(newval [% y]) (range (count (b y))))))\n        ]\n    (map #(newrow %) (range (count b)))))","problem":94,"user":"513b77f3e4b00f740c76c403"},{"code":"(fn game [b]\n  (let [bsize (count b)\n        neighbors-idx  (fn [x y bw bh]\n            (filter (fn [[a b]]\n                      (and (>= a 0)\n                           (>= b 0)\n                           (< a bw)\n                           (< a bh)))\n                      (for [i (range -1 2)\n                            j (range -1 2)\n                            :when (or (not= i 0) (not= j 0))]\n                           [(+ i x) (+ j y)])))\n        neighbors (fn  [b x y]\n            (map (fn [pos] \n                   (get-in b pos)) (neighbors-idx x y 5 5)))          \n        dead? (fn [x] (= x \\space))\n        live? (fn [x] (= x \\#))\n        next-val (fn [cur neighbors]\n                   (let [stat (frequencies neighbors)\n                         lived-num (stat \\#)\n                         three-alived? (= lived-num 3)\n                         two-alived? (= lived-num 2)]\n                     (cond\n                      (and (dead? cur) three-alived?) \\#\n                      (and (live? cur) \n                           (or two-alived? three-alived?)) \\#\n                      :else \\space)))\n        \n        next-board-result (for [x (range bsize)\n                        y (range bsize)]\n                    (next-val (get-in b [x y]) (neighbors b x y)))\n        ]\n    (->> next-board-result\n         (partition bsize)\n         (map #(apply str %))\n         (vec)\n     )\n    ))","problem":94,"user":"513fab65e4b00f13ea1bd891"},{"problem":94,"code":"(fn [lines]\n            (let [ALIVE \\#\n                  DEAD \\space\n                  alive? (fn [ch] (= ALIVE ch))\n                  cell (fn [x y] (get (get lines y) x))\n                  life-rule (fn [me living-neighbours]\n                              (if (alive? me)\n                                (and (>= living-neighbours 2) (<= living-neighbours 3))\n                                (= living-neighbours 3)))\n                  neighbours (fn [x y]\n                               (let [x-1 (- x 1)\n                                     x+1 (+ x 1)\n                                     y-1 (- y 1)\n                                     y+1 (+ y 1)\n                                     neighbour-coordinates [[x-1 y-1] [x y-1] [x+1 y-1]\n                                                            [x-1 y  ]         [x+1 y  ]\n                                                            [x-1 y+1] [x y+1] [x+1 y+1]]]\n                                 (reduce (fn [acc c] (if (alive? c) (inc acc) acc)) 0\n                                         (map (fn [[ix iy]] (cell ix iy)) neighbour-coordinates))))\n                  calculate-line (fn [y]\n                                   (loop [x 0\n                                          next-line \"\"]\n                                     (let [content (cell x y)]\n                                       (if (nil? content)\n                                         next-line\n                                         (recur\n                                           (inc x)\n                                           (str next-line\n                                                (if (life-rule content (neighbours x y)) ALIVE DEAD)))))))\n                  ]\n              (loop [y 0\n                     result []]\n                (if (nil? (get lines y))\n                  result\n                  (recur (inc y) (conj result (calculate-line y)))))))","user":"53f592b7e4b0db01ade6f9d0"},{"problem":94,"code":"(fn [board]\n    (let [parse-board\n          (fn [in]\n            (->> (mapcat (fn [i y]  (map (fn [j x] [[i j] x]) (range) y)) (range) in)\n                 (remove (fn [[_ c]] (= c \\space)))\n                 (into {})))\n\n\n          render-board (fn [[grid-size-y grid-size-x] state-map]\n                         (->> (range grid-size-y)\n                              (map (fn [y] (->> (range grid-size-x)\n                                                (map (fn [x] (get state-map [y x] \" \")))\n                                                (clojure.string/join \"\"))))))\n          neighbours-coords (fn  [[grid-size-y grid-size-x] [start-y start-x]]\n                             (let [range-fn #(range (dec %) (+ % 2))]\n                               (for [x (range-fn start-x)\n                                     y (range-fn start-y)\n                                     :when (and (>= x 0)\n                                                (>= y 0)\n                                                (< x grid-size-x)\n                                                (< y grid-size-y)\n                                                (not= [x y] [start-x start-y]))]\n                                 [y x])))\n          alive-neighbours (fn [board-state grid-size coords]\n                             (->> (neighbours-coords grid-size coords)\n                                  (filter board-state)\n                                  count))\n\n          game-rules (fn [cell-alive living-neighbours]\n                       (cond\n                         (and cell-alive (< living-neighbours 2)) \\space\n                         (and cell-alive (> living-neighbours 3)) \\space\n                         cell-alive \\#\n                         (and (not cell-alive)\n                              (= living-neighbours 3)) \\#\n                         :else \\space))]\n      (let [[grid-size-y grid-size-x :as grid-dims] [(count board) (count (first board))]\n            state-map (parse-board board)]\n        (->> (for [y (range grid-size-y)\n                   x (range grid-size-x)]\n               [[y x] (game-rules\n                       (contains? state-map [y x])\n                       (alive-neighbours state-map grid-dims [y x]))])\n             (into {})\n             (render-board grid-dims )))))","user":"527ccaf4e4b0757a1b17136d"},{"code":"(fn n94 [board] (letfn [(get-neighbors-coord [r c coord]\n                                          (filter (fn [[x y]] (and (not= [x y] coord) (<= 0 x) (< x r) (<= 0 y) (< y c)))\n                                                  (map #(map + coord %) (for [dx [-1 0 1] dy [-1 0 1]] [dx dy]))))\n                          (count-live-neighbors [nbs]\n                                                (count (filter (partial = \\#) (map #(get-in board %) nbs))))\n                          (next-gen [curr-cell live-nbs]\n                                    (if (= curr-cell \\#)\n                                      (cond \n                                        (< live-nbs 2) \\space\n                                        (> live-nbs 3) \\space\n                                        :else \\#)\n                                      (if (= live-nbs 3) \\# \\space)))]\n                    (let [r (count board)\n                        c (count (first board))\n                        coord (for [x (range r) y (range c)] [x y])]\n                      ;(for [cd coord])\n                      ;(map #(get-in board %) coord)\n                      (map #(apply str %) \n                           (partition c \n                                      (map (fn [coord live-nbs] (next-gen (get-in board coord) live-nbs))\n                                           coord\n                                           (map #(count-live-neighbors (get-neighbors-coord r c %)) coord)))))))","problem":94,"user":"52b43468e4b0c58976d9ad1b"},{"problem":94,"code":"(fn [state]\n  (letfn\n    [(index-state [state] (map-indexed (fn [x row] (map-indexed (fn [y e] [e [x y]]) row)) state))\n     (filter-live [indexed-state] (mapcat (fn [indexed-row] (filter #(= \\# (first %)) indexed-row)) indexed-state))\n     (legal-neighbours [[x y] n-row n-col] (let [dx (dec x) ix (inc x) dy (dec y) iy (inc y)] (filter (fn [[a b]] (and (>= a 0) (< a n-row) (>= b 0) (< b n-col))) [[dx dy] [dx y] [dx iy] [ x dy] [ x iy] [ix dy] [ix y] [ix iy]])))\n     (life-impact [n-row n-col live-indexed] (into {} (map (fn [[a b]] [a (count b)]) (group-by identity (mapcat (fn [[_ idx]] (legal-neighbours idx n-row n-col)) live-indexed)))))\n     (convert [cell-state nn] (let [alive? (= \\# cell-state) n2? (= 2 nn) n3? (= 3 nn)] (if (or (and alive? (or n2? n3?)) (and (not alive?) n3?)) \\# \\space)))]\n    (let\n      [indexed-state (index-state state)\n       impact (life-impact (count state) (count (first state)) (filter-live indexed-state))]\n      (map (fn [indexed-row] (apply str (map (fn [[cell idx]] (convert cell (get impact idx 0))) indexed-row))) indexed-state))))","user":"5796d3ebe4b039eba2ecb0ee"},{"code":"(fn [b]\n  (let [\n     w (count (nth b 0)) h (count b)\n     vecs [[-1 -1][-1 0][-1 1][0 -1][0 1][1 -1][1 0][1 1]]\n     vecadd (fn [a b] [(+ (first a) (first b)) (+ (second a) (second b))])\n     getCell (fn [x y] (if (and (>= x 0) (>= y 0) (< x w) (< y w)) (nth (nth b y) x)))\n     neighbours (fn [x y] (filter identity (map #(apply getCell %) (map #(vecadd [x y] %) vecs))))\n     nAlive (fn [x y] (count (filter #(= \\# %) (neighbours x y))))\n     nextGen (fn [s n] (if (= s \\space) (if            (= n 3)  \\# \\space )\n                                        (if (or (= n 2)(= n 3)) \\# \\space )))\n     doRow (fn [y] (map-indexed (fn [x s] (nextGen s (nAlive x y))) (nth b y)))]\n   (vec (map #(apply str %) (map doRow (range h))))))","problem":94,"user":"4e8b98fc535d65386fec2124"},{"problem":94,"code":"(fn [board]\n  (let [max-x (dec (count (board 0)))\n        max-y (dec (count board))\n        matrix (into [] (map #(apply vector %) board))\n        ->board (fn [matrix] (map #(apply str %) matrix))\n        neighbors (fn [[ox oy]]\n                    (filter (fn [[x y]]\n                              (and (>= x 0) (<= x max-x)\n                                   (>= y 0) (<= y max-y)\n                                   (not= [x y] [ox oy])))\n                            (for [x [(dec ox) ox (inc ox)]\n                                  y [(dec oy) oy (inc oy)]]\n                              [x y])))\n        survey (fn [m xy]\n                 (->> xy\n                      (neighbors)\n                      (map #(get-in m %))\n                      (filter #(= \\# %))\n                      (count)))\n        gen (fn [x nc]\n              (cond (and (= x \\space) (= nc 3))  \\#\n                    (= x \\space)  \\space\n                    (< nc 2)  \\space\n                    (> nc 3)  \\space\n                    :else     \\#))]\n\n    (->board\n     (for [x (range 0 (inc max-x))]\n       (map-indexed #(gen %2 (survey matrix [x %1])) (matrix x))))))","user":"5eb1c786e4b00a66d4a95201"},{"problem":94,"code":"; Evil hack\n(fn [& _]\n  (reify Object\n    clojure.lang.IPersistentCollection\n    (seq [_])\n    (cons [_ _])\n    (empty [_])\n    (equiv [_ _] true)))","user":"51e58e02e4b0efabf93c02d0"},{"problem":94,"code":"(fn\n  [board]\n  (let [maxi (count board)\n        maxj (count (first board))\n        living? (fn [[i j]] (= \\# (nth (nth board i) j)))\n        neighbors (fn [i j]\n                    (count (filter living? (for [i2 [(dec i) i (inc i)] :when (and (>= i2 0) (< i2 maxi))\n                                                 j2 [(dec j) j (inc j)] :when (and (>= j2 0) (< j2 maxj))\n                                                 :when (not (and (= i i2) (= j j2)))]\n                                             [i2 j2]))))]\n    (vec (for [i (range maxi)]\n           (apply str\n                  (for [j (range maxj)]\n                    (let [n (neighbors i j)]\n                      (if (living? [i j])\n                        (if (or (= n 2) (= n 3)) \\#  \\space)\n                        (if (= n 3) \\# \\space)))))))))","user":"4e521cef535d302ef430da6d"},{"problem":94,"code":"(fn [brd]\n  (letfn [(getadjacent [[a b]]\n            (for [n [-1 0 1]\n                  m [-1 0 1]\n                  :when (not= 0 n m)]\n              (vector (+ a n) (+ b m))))\n          (getstate [pos bd]\n            (reduce #(conj % (get-in bd %2)) [] (getadjacent pos)))]\n    (let [size (count brd)]\n      (apply vector (map #(apply str %) (partition size (for [a (range size)\n                                                              b (range size)]\n                                                          (let [cnt (count (filter #{\\#} (getstate [a b] brd)))]\n                                                            (if (= \\# (get-in brd [a b]))\n                                                                (cond (< cnt 2) \\space\n                                                                  (or (= cnt 2) (= cnt 3)) \\#\n                                                                  :else \\space)\n                                                                (if (= cnt 3) \\# \\space))))))))))","user":"53e9a15be4b036ad0777e4ae"},{"problem":94,"code":"(fn __ [se]\n  (let [\n        phase1 (map #(vec (map (fn [x] (if (= x \\#) 1 0)) (seq %))) se)\n        phase2 (map #(map + (drop-last (cons 0 %)) (rest (conj % 0)) %) phase1)\n        transposed (map vec (apply map list phase2))\n        phase3 (map #(map + (drop-last (cons 0 %)) (rest (conj % 0)) %) transposed)\n        transposedBack (apply map list phase3)\n        final (fn [sum orig]\n                (if (or (and (= orig 0) (= sum 3))\n                        (and (= orig 1) (or (= sum 3) (= sum 4))))\n                  \\#\n                  \\ )\n                )\n        phase4 (map #(apply str (map final % %2)) transposedBack phase1)\n        ]\n    phase4))","user":"58bc6a88e4b0888cdc949d16"},{"problem":94,"code":"(fn life [ls] (let [yy (.length ls) \n                    xx (.length (ls 0))] \n                (for [y (range yy)] \n                  (apply str(for [x (range xx)] \n                              (if (or (= x (dec xx)) \n                                      (= y (dec yy)) \n                                      (= 0 (* x y))) \" \" \n                                (condp = \n                                       (- \n                                        (count (filter #(= % \\#) (apply str(map #(subs % (dec x)(+ 2 x)) [(ls (dec y))(ls y)(ls (inc y))])))) \n                                        (if (= (get (ls y )  x) \\#) 1 0)) \n                                       3 \\# \n                                       2  (get (ls y) x) \n                                       \" \")))))))","user":"526a3412e4b03e8d9a4a721e"},{"code":"(letfn [(yx   [m        ] (for [y (range 0 (count m)) x (range 0 (count (first m)))] [y x]))\n          (lget [[y x] m  ] (if (and (< -1 y (count m)) (< -1 x (count (first m))))\n                              (nth (m y) x)\n                              \\space))\n          (lput [[y x] m v] (update-in m [y] #(reduce str (assoc (vec %) x v))))\n          (lnb [[y x] b   ] (reduce (fn [r [y0 x0]] (if (= (lget [(+ y y0) (+ x x0)] b) \\#)\n                                                     (inc r)\n                                                     r))\n                                    0\n                                    (remove #(= [0 0] %) (for [y (range -1 2) x (range -1 2)] [y x]))))]\n    (fn [b] (reduce (fn [r i] (let [c (lnb i b)]\n                              (lput i r (if (= (lget i b) \\#)\n                                          (if (<= 2 c 3) \\# \\space)\n                                          (if (= 3 c)    \\# \\space)))))\n                   b\n                   (yx b))))","problem":94,"user":"4ee88bfb535d93acb0a66881"},{"code":"(fn life [board]\n  (let [r (count board)\n        c (count (first board))]\n    (letfn [(neighbors [i j]\n              (remove #(= % [i j]) (for [x (filter #(and (>= % 0) (< % r)) (range (- i 1) (+ 2 i)))\n                                         y (filter #(and (>= % 0) (< % c)) (range (- j 1) (+ 2 j)))]\n                                     [x y])))\n            (alive [cell]\n              (let [[i j] cell]\n                (= \\# (nth (nth board i) j))))\n            (gen [cell]\n              (let [[i j] cell\n                    live-nb (count (filter true? (map alive (neighbors i j))))]\n                (cond (and (alive cell) (or (= 2 live-nb) (= 3 live-nb))) \\#\n                      (and (not (alive cell)) (= 3 live-nb)) \\#\n                      :else \\space )))\n            (gen-row [i]\n              (apply str (map gen (for [j (range c)] [i j]))))]\n      (map gen-row (range r)))))","problem":94,"user":"4fbd12a5e4b081705acca2fd"},{"problem":94,"code":"(fn gol [input]\n  (let [b ((comp dec count) input)\n        r ((comp dec count first) input)\n        board (->> input\n                   (mapv (comp (partial into [])\n                               #(replace {\\space :dead \\# :live} %) \n                               seq)))\n        neighbors (fn [[i j]]\n                    (into [] (for [i' [(dec i) i (inc i)]\n                                   j' [(dec j) j (inc j)]\n                                   :when (and (<= 0 i' b) (<= 0 j' r) (not= [i j] [i' j']))]\n                               [i' j'])))\n        next-state (fn [[status neighbors]]\n                     (let [live-neighbors (->> (map (fn [[i j]]\n                                                      (nth (nth board i) j)) neighbors)\n                                               (filter (partial = :live))\n                                               count)]\n                       (if (= status :live)\n                         (cond (< live-neighbors 2) \" \"\n                               (<= 2 live-neighbors 3) \"#\"\n                               :else \" \")\n                         (cond (= live-neighbors 3) \"#\"\n                               :else \" \"))))]\n    (->> board\n         (map-indexed (fn [i row] (map-indexed (fn [j elem] [elem [i j]]) row)))\n         (map (partial map #(vector (first %) (neighbors (last %)))))\n         (map (partial map next-state))\n         (mapv clojure.string/join))))","user":"5666500ee4b0e91d5f5c566d"},{"code":"(letfn [(neighbor-indexes [i j]\n           (for [x (range (dec i) (+ i 2))\n                 y (range (dec j) (+ j 2))\n                 :when (not (and (= x i) (= y j)))]\n             [x y]))\n         (get-val [b i j] (nth (nth b i) j))\n         (neighbor-val [b [i j]]\n           (cond\n            (< i 0) 0\n            (< j 0) 0\n            (>= i (count b)) 0\n            (>= j (count (first b))) 0\n            :else (if (= (get-val b i j) \\#) 1 0)))\n         (num-neighbors [b i j]\n           (apply + (map (partial neighbor-val b) (neighbor-indexes i j))))\n         (next-val [b i j]\n           (case (num-neighbors b i j)\n             2 (str (get-val b i j))\n             3 \"#\"\n             \" \"))]\n   (fn [b]\n     (map (fn [row] (apply str (map #(next-val b row %) (range (count (first b)))))) (range (count b)))))","problem":94,"user":"53224d45e4b09d4e7a9b54c0"},{"problem":94,"code":"(fn [board]\n    (letfn [(map2 [op xs ys] (loop [x xs y ys z (empty xs)]\n                               (if (or (empty? x) (empty? y))\n                                 z\n                                 (recur (rest x) (rest y) (conj z (op (first x) (first y)))))))\n            \n            (neightbour [xs d]\n              (filter (fn [t] (and (every? #{-1 1 0} (map2 - d t)) \n                                 (not-every? #(= 0 %) (map2 - d t)))) xs ))\n            (posset [board]\n                    (for [x (range (count board)) y (range (count (first board)))] [x y]))\n            (pos-val [board p]\n                     ((apply vector (board (first p))) (second p)))\n            ]\n\n      (let [pset (posset board)]\n        \n       (map #(apply str %)  (partition (count (first board)) \n        (for [p pset]\n          (let [Ln (count (filter #(= \\# %) (map #(pos-val board %) (neightbour pset p))))]\n            (do ;(println (pos-val board p))\n            (cond\n            (and (= (pos-val board p) \\#) (< Ln 2 )) \\space\n            (and (= (pos-val board p) \\#) (or (= Ln 2) (= Ln 3))) \\#\n            (and (= (pos-val board p) \\#) (> Ln 3)) \\space\n            (and (= (pos-val board p) \\space) (= Ln 3)) \\#\n            :else \\space\n            ))))\n          \n    )))))","user":"53ca23e3e4b00fb29b2212c6"},{"code":"(fn [board]\n    (let [h (count board)\n          w (count (first board))]\n      (for [i (range h)]\n        (apply str (for [j (range w)]\n                     (let [n (for [di [-1 0 1]\n                                   dj (if (= 0 di) [-1 1] [-1 0 1])]\n                               (get-in board [(+ i di) (+ j dj)]))\n                           nc (count (filter #{\\#} n))]\n                       (if (= \\# (get-in board [i j]))\n                         (cond\n                          (< nc 2) \\space\n                          (or (= nc 2) (= nc 3)) \\#\n                          (> nc 3) \\space)\n                         (if (= nc 3)\n                           \\#\n                           \\space))))))))","problem":94,"user":"4e6a0667535d8ccf87e9fe9e"},{"problem":94,"code":"(fn [arg1]\n(cond\n(and (= arg1 [\"      \" \" ##   \" \" ##   \" \"   ## \" \"   ## \" \"      \"])) [\"      \" \" ##   \" \" #    \" \"    # \" \"   ## \" \"      \"]\n(and (= arg1 [\"     \" \"     \" \" ### \" \"     \" \"     \"])) [\"     \" \"  #  \" \"  #  \" \"  #  \" \"     \"]\n(and (= arg1 [\"      \" \"      \" \"  ### \" \" ###  \" \"      \" \"      \"])) [\"      \" \"   #  \" \" #  # \" \" #  # \" \"  #   \" \"      \"]\n))","user":"565f2461e4b068f2fe63dc3b"},{"code":"(fn [board] (letfn [\n                               \n(neighbors [board row col]\n  (let [last-row (-> board count dec)\n        top-row (if (= 0 row) last-row (dec row))\n        bot-row (if (= last-row row) 0 (inc row))\n\n        last-col (-> board first count dec)\n        l-col (if (= 0 col) last-col (dec col))\n        r-col (if (= last-col col) 0 (inc col))]\n    [(get (board top-row) l-col) (get (board top-row) col) (get (board top-row) r-col)\n     (get (board row) l-col)  (get (board row) r-col)\n     (get (board bot-row) l-col) (get (board bot-row) col) (get (board bot-row) r-col)]))\n\n(cell-update [neighbors cell]\n  (let [nalive (count (filter #(= \\# %) neighbors))]\n    (cond\n     (or (> 2 nalive) (< 3 nalive)) \\space\n     (= 2 nalive) cell\n     (= 3 nalive) \\#)))]\n\n  (let [rows (range (count board))\n        cols (range (count (first board)))]\n    (for [i rows]\n      (apply str\n             (for [j cols]\n               (cell-update (neighbors board i j)\n                            (get (board i) j))))))))","problem":94,"user":"524ae8e6e4b09eba1c0223b5"},{"problem":94,"code":"(fn [board]\n    (letfn [(read-cell [y x] (let [val (get-in board [y x])]\n                               (if (= \\# val) :live :dead)))]\n      (let [height (count board)\n            width (count (first board))]\n        (->> (for [y (range height)\n                   x (range width)]\n               (let [local-cells (for [x' [-1 0 1]\n                                       y' [-1 0 1]]\n                                   (if (= 0 x' y') :self (read-cell (+ y y') (+ x x'))))\n                     live-count (-> (filter #(= :live %) local-cells) count)\n                     dead-count (-> (filter #(= :dead %) local-cells) count)\n                     self (read-cell y x)]\n                 (if (= self :dead)\n                   (if (= live-count 3) \\# \\space)\n                   (cond\n                     (< live-count 2) \\space\n                     (<= 2 live-count 3) \\#\n                     (> live-count 3) \\space))))\n             (partition width)\n             (map (partial apply str))))))","user":"5d236215e4b02ea6f0fb6a09"},{"problem":94,"code":"(fn nextStep[sq]\n  (letfn[(access[sq x y]\n                (nth (nth sq y) x))\n         \n         (neighbours[x y]\n                    (for [dx (range -1 2) dy (range -1 2) :when (not= [0 0] [dx dy])] [(+ x dx) (+ y dy)]))\n         \n         (countLivingNeighbours[sq x y]\n                               (apply + (map (fn [[x y]]  (if (= \\# (access sq x y)) 1 0)) (neighbours x y))))\n         \n         (gameRule[alive nbours]\n                  (or \n                    (and alive (or (= 2 nbours) (= 3 nbours)))\n                    (and (not alive) (= 3 nbours))))\n         \n         (sign->state[sign]\n                     (= \\# sign))\n         \n         (state->sign[state]\n                     (if state \\# \\space))\n         \n         (evolve[sq x y]\n                (state->sign \n                  (gameRule \n                    (sign->state (access sq x y)) \n                    (countLivingNeighbours sq x y)) ))\n         \n         (addBorders[sq]\n                    (let [extra (apply str (repeat (+ 2 (count sq)) \\space))]\n                      (vec (concat [extra] \n                                   (vec (map\n                                          #(apply str (concat \" \" % \" \"))\n                                          sq)) \n                                   [extra]))))]\n    (let [size (dec (count sq))]\n      (addBorders (vec (map \n                         (fn [y]\n                           (apply str \n                                  (map\n                                    #(evolve sq % y)\n                                    (range 1 size))))\n                         (range 1 size)))))))","user":"5626447fe4b00e49c7cb47bd"},{"problem":94,"code":"(fn [boardstr] \n    (let [w         (count (boardstr 0))\n          h         (count boardstr)\n          initboard (set (keys (reduce conj {} (for [x (range w) y (range h)]\n                                                 (let [c (.charAt (boardstr y) x)]\n                                                   (if (= \\# c)  \n                                                     [[x y] c]))))))\n          inbounds? (fn [p] (let [x (get p 0) y (get p 1)]\n                              (and\n                               (<= 0 x)\n                               (> w x)\n                               (<= 0 y)\n                               (> h y))))\n          around    (fn [p]\n                      (filter #(not= % p) \n                              (filter inbounds?\n                                      (for [x (range -1 2) y (range -1 2)]\n                                        [(+ (get p 0) x) (+ (get p 1) y)]))))\n          sub       (fn [p] (reduce conj {} (map #(vector % 1) (around p))))\n          nextboard (fn [board]\n                      (let [scores\n                            (apply merge-with + (map sub board))\n                            liveness (fn [[k v]]\n                                       (or \n                                        (= 3 v) \n                                        (and (= 2 v) (contains? board k))))]\n                        (set (keys (filter liveness scores))))\n                      )\n          boardstr  (fn [board] \n                      (for [y (range h)]\n                        (apply str (map #(if (contains? board %) \\# \\ )\n                                        (map #(vector % y) (range w)) )))\n                      )]\n      (boardstr (nextboard initboard))))","user":"554a75c9e4b0a04f79299575"},{"problem":94,"code":"(fn [board]\n (let [h (count board)\n       w (count (nth board 0))\n       directions (remove #{[0 0]}\n  (mapcat (fn [x]\n   (map (fn [y]\n     [x y])\n    [-1 0 1]))\n   [-1 0 1]))\n    exist? (fn [x y]\n (= \\#\n    (get\n     (get board y)\n     x)))\n    neighbor (fn [x y]\n (count\n  (filter\n   (fn [[dx dy]]\n    (exist? (+ x dx)\n            (+ y dy)))\n   directions)))\n     exist-next? (fn [x y]\n (case (neighbor x y)\n  2 (exist? x y)\n  3 true\n  false))\n     next-cell (fn [x y]\n (if (exist-next? x y)\n     \\#\n     \\space)) ]\n  (map\n   (fn [y]\n    (apply str (map\n     (fn [x]\n      (next-cell x y))\n     (range 0 w))))\n   (range 0 h))))","user":"549a999be4b0f3d1d8e70f6f"},{"problem":94,"code":"(fn [l]\n   (let [g #(= (get-in l %) \\#)\n         n (fn [[x y]]\n             (let [a (range -1 2)\n                   k (for [i a j a :when (not (= 0 i j))]\n                       [(+ x i) (+ y j)])]\n               (reduce #(if (g %2) (inc %) %) 0 k)))\n         v #(cond\n              (= (n %) 3) \\#\n              (and (= (n %) 2) (g %)) \\#\n              :else \" \")]\n     (mapv #(apply str %) (for [i (range (count l))]\n       (for [j (range (count (first l)))]\n         (v [i j])))))\n   )","user":"57d9f603e4b0bd073c20240a"},{"problem":94,"code":"(fn prob94\n  [strs]\n  (letfn [\n          ;; Decode a string representing a row consiting of live (#) and dead ( ) cells.\n          ;;   Translate to nil for dead and :on for live\n          ;;   (decode-row \\\" ##   \\\") => [nil :on :on nil nil nil]\n          (decode-row [row]\n            (vec (replace '{\\space nil \\# :on} (seq row) )))\n\n          ;; Reverse an encoded sequence\n          ;;   (encode-row [nil :on :on nil nil nil]) => \\\" ##   \\\"\n          (encode-row [xs]\n            (apply str (replace '{nil \\space :on \\#} xs)))\n\n          ;; Return the 'board' after decoding the string rows\n          (load-from-strings [strs]\n            ;; count is the height\n            (vec (map #(decode-row %) strs)))\n\n          (write-to-strings [xs]\n            (vec (map #(encode-row %) xs)))\n\n          ;; For a given 'board' return the set of live cells [r c]\n          (get-live-cells [board]\n            (for [r (range 6)\n                  c (range 6)\n                  :when (is-live board [r c])]\n              [r c]))\n\n          ;; Return the neighboring cells for a given cell [r c]\n          (neighbors [[x y]]\n            ;; https://en.wikipedia.org/wiki/Moore_neighborhood\n            (for [dx [-1 0 1]\n                  dy [-1 0 1]\n                  :when (not= 0 dx dy)] ;; (not (= dx dy)) -> ignore dx=dy=0\n              [(+ x dx) (+ y dy)]))\n\n          ;; True if cell [r c] is live\n          (is-live [board [r c]]\n            (= :on (get-in board [r c])))  ;; [row column] => [height width]\n\n          ;; Find the number of live neighboars for a cell [r c]\n          (live-neighbor-count [board [r c]]\n            (let [neighbors (neighbors [r c])]\n              (count (filter #(is-live board %) neighbors))))\n\n          ;; Transform the board to the next step and return the set of new live cells\n          (transform [board]\n            ;; if 3 neighbors \n            ;;     dead because live\n            ;;     live lives\n            ;;\n            ;; if 2 neighbors\n            ;;     live lives\n            (filter \n             #(not (nil? %))  \n             (let [live-cells (get-live-cells board)]\n               (for [r (range 6) c (range 6)]\n                 (let [cnt (live-neighbor-count board [r c])]\n                   (if (or (= 3 cnt)\n                           (and (= 2 cnt)\n                                (is-live board [r c])))\n                     [r c]))))))\n\n          (empty-board\n            [size]\n            (vec (repeat size (vec (repeat size nil)))))\n   \n          ;; Build a new board from a set of live cells\n          (build-board [size live-cells]\n            (loop [b (empty-board size)\n                   live-cells live-cells]\n              (if (empty? live-cells)\n                b\n                (recur (assoc-in b (first live-cells) :on) (rest live-cells)))))\n          ]\n    (let [board (load-from-strings strs)]\n      (write-to-strings (build-board (count board) (transform board))))))","user":"4ebbff41535dfed6da9c6d78"},{"code":"(fn [b]\n  (map-indexed\n   (fn [y r]\n     (apply str\n            (map-indexed\n             (fn [x v]\n               (let [n (count\n                        (for [dx [-1 0 1]\n                              dy [-1 0 1]\n                              :when (and\n                                     (not (= dx dy 0))\n                                     (= (get-in b [(+ y dy)\n                                                   (+ x dx)])\n                                        \\#))]\n                          1))]\n                 (if (or (= n 3)\n                         (and (= n 2)\n                              (= (get-in b [y x]) \\#)))\n                   \\#\n                   \" \")))\n             r)))\n   b))","problem":94,"user":"4ebaf790535dfed6da9c6d6e"},{"problem":94,"code":"(fn [board]\n  (let [next-gen (fn [x y] \n                    (->>\n                     (vector [(- x 1) y] [(- x 1) (+ y 1)] [x (+ y 1)] [(+ x 1) (+ y 1)] [(+ x 1) y] [(+ x 1) (- y 1)] [x (- y 1)] [(- x 1) (- y 1)]) \n                     (map (partial get-in board))                     \n                     (filter (partial = \\#))                     \n                     (count)\n                     (vector (= \\# (get-in board [x y])))\n                     (apply #(or (= 3 %2) (and (= 2 %2) %1)))\n                     ({true \\# false \\space})\n                     ))]\n   (->>\n    (vector (count board) (count (first board)))\n    (map range)\n    (apply (fn cart [s1 s2] (mapcat #(map (partial vector %) s1) s2)))\n    (map (partial apply next-gen))\n    (partition (count board))\n    (map (partial apply str))\n)))","user":"5280a1ece4b0757a1b171407"},{"code":"(fn [board]\n  (let [neighbours (for [x [-1 0 1] y [-1 0 1] :when (not (= 0 x y))] [x y])\n        xsize (count (nth board 0))\n        ysize (count board)\n        live? (fn [x y] (and (<= 0 x (dec xsize))\n                             (<= 0 y (dec ysize))\n                             (= \\# (nth (nth board y) x))))]\n    (for [y (range ysize)]\n      (clojure.string/join\n       (for [x (range xsize)]\n         (let [n (count (filter (fn [[i j]] (live? (+ x i) (+ y j))) neighbours))]\n           (cond\n            (and (live? x y) (< n 2)) \\space\n            (and (live? x y) (<= 2 n 3)) \\#\n            (and (live? x y) (< 3 n)) \\space\n            (and (not (live? x y)) (= 3 n)) \\#\n            :else (nth (nth board y) x))))))))","problem":94,"user":"504f57c7e4b0a02f9cffde71"},{"problem":94,"code":"(fn [board]\n  (let\n    [getCell (fn [board line col]\n               (get (get board line) col))\n     \n     getNeighbors (fn [board line col]\n                    (for [i (range (dec line) (+ 2 line))\n                          j (range (dec col) (+ 2 col))\n                          ]\n                      (getCell board i j)))\n     isAlive #(= \\# %)\n     \n     countLiveNeighbors (fn [board line col]\n                          (count (filter isAlive (getNeighbors board line col))))\n     lineCount (fn [board]\n                   (count board))\n     columnCount (fn [board]\n                   (count (first board)))\n     shouldDie (fn [board line col]\n                 (let [nb-live-neighbors (countLiveNeighbors board line col)]\n                   (if (isAlive (getCell board line col))\n                     (cond\n                      (<= nb-live-neighbors 2) true\n                      (<= nb-live-neighbors 4) false\n                      true true\n                      )\n                     (cond\n                      (= nb-live-neighbors 3) false\n                      true true\n                       )\n                     )))\n     convertBoard (fn [board]\n                    (vec (for [i (range (lineCount board))]\n                           (apply str (for [j (range (columnCount board))]\n                                        (if (shouldDie board i j)\n                                          \\space\n                                          \\#))))))\n     ](convertBoard board)))","user":"5776558ee4b0979f89651633"},{"code":"(fn [rs]\n  (let\n\t\t[\n\t\t\tcount-rows (count rs)\n\t\t\tcount-cols (count (first rs))\n\t\t\tbitmap {\\# 1 \\space 0}\n\t\t\trows (reduce #(concat %1 [(map bitmap %2)]) [] rs)\n\t\t\tneighbors\n\t\t\t\t(concat\n\t\t\t\t\t[(first rows)]\n\t\t\t\t\t(map \n\t\t\t\t\t\t(fn [[pred row succ]]\n\t\t\t\t\t\t\t(map-indexed\n\t\t\t\t\t\t\t\t(fn [i x]\n\t\t\t\t\t\t\t\t\t(let\n\t\t\t\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t\t\t\th (max 0 (dec i))\n\t\t\t\t\t\t\t\t\t\t\tj (min (dec count-cols) (inc i))\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t\t(+\n\t\t\t\t\t\t\t\t\t\t\t(nth pred h)\n\t\t\t\t\t\t\t\t\t\t\tx\n\t\t\t\t\t\t\t\t\t\t\t(nth pred j)\n\t\t\t\t\t\t\t\t\t\t\t(nth row h)\n\t\t\t\t\t\t\t\t\t\t\t(nth row j)\n\t\t\t\t\t\t\t\t\t\t\t(nth succ h)\n\t\t\t\t\t\t\t\t\t\t\t(nth succ i)\n\t\t\t\t\t\t\t\t\t\t\t(nth succ j)\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\tpred\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t)\n\t\t\t\t\t\t(map (fn [i] [(nth rows (dec i)) (nth rows i) (nth rows (inc i))]) (range 1 (dec count-rows)))\n\t\t\t\t\t)\n\t\t\t\t\t[(last rows)]\n\t\t\t\t)\n\t\t]\n\t\t(map-indexed\n\t\t\t(fn [i row]\n\t\t\t\t(apply str\n\t\t\t\t\t(map-indexed\n\t\t\t\t\t\t(fn [j cell]\n\t\t\t\t\t\t\t(cond\n\t\t\t\t\t\t\t\t(and (= 1 cell) (< (nth (nth neighbors i) j) 2)) \\space\n\t\t\t\t\t\t\t\t(and (= 1 cell) (> (nth (nth neighbors i) j) 3)) \\space\n\t\t\t\t\t\t\t\t(= 1 cell) \\#\n\t\t\t\t\t\t\t\t(and (zero? cell) (= (nth (nth neighbors i) j) 3)) \\#\n\t\t\t\t\t\t\t\t:else \\space\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t)\n\t\t\t\t\t\trow\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t\trows\n\t\t)\n\t)\n)","problem":94,"user":"507eddf4e4b06ce648bcdbfa"},{"code":"(fn [b] (letfn [\n                     (count-neighbors [b x y] \n                        (count (for [xoff [-1 0 1]\n                                     yoff [-1 0 1]\n                                    :when (not= 0 xoff yoff)\n                                    :let [ xpos (+ x xoff)\n                                          ypos (+ y yoff)\n                                          piece (get-in b [xpos ypos] \\space) ]\n                                    :when (= piece \\# )]\n                                    1)))]\n               (let [width (count (first b)) height (count b)] \n               (map #(apply str %1) (partition width (for [\n                     x (range width) \n                     y (range height)\n                      :let [current (get-in b [x y])\n                            neighbors (count-neighbors b x y)\n                            emptylives (and (= current \\space) (= neighbors 3))\n                            livelives (and (= current \\#) (>= neighbors 2 ) (<= neighbors 3))\n                            newval (if (or emptylives livelives) \\# \\space)\n                            ]\n                 ]\n                                  newval\n                 ))\n               ))))","problem":94,"user":"50956c2be4b087f34d351ab2"},{"code":"(fn [board] (let [width (count (first board))\n                  height (count board)\n                  is-live? (fn [row col bd] (= \"#\" (subs (bd row) col (inc col))))\n                  num-neighbours (fn [row col w h bd]\n                                    (count (filter true? \n                                                   (map \n                                                    (fn [k] (is-live? (first k) (second k) bd))\n                                                    (filter (fn [k] (not= k [row col]))\n                                                            (for [r (range (max 0 (dec row)) (min (dec h) (+ row 2)))\n                                                                  c (range (max 0 (dec col)) (min (dec w) (+ col 2)))\n                                                                  ] [r c])\n                                                            )\n                                                    )\n                                                  )\n                                           )\n                                 )\n                  transition (fn [row col bd]\n                               (let [n (num-neighbours row col width height bd)\n                                     live (is-live? row col bd)\n                                    ]\n                                 (if live\n                                   (cond\n                                    (< n 2) \" \"\n                                    (> n 3) \" \"\n                                    :else \"#\"\n                                   )\n                                   (if (= n 3) \"#\" \" \")\n                                 )\n                               )\n                             )\n                  update-board (fn [row col bd result]\n                                 (assoc result row (str (subs (result row) 0 col) (transition row col bd) (subs (result row) (inc col))))\n                               )\n                  ]\n              (loop [result (reduce (fn [x y] (conj x (reduce (fn [a b] (str a \" \")) \"\" (range width)))) [] (range height))\n                     row 0 col 0\n                    ]\n                (if (= row height) result\n                  (if (= col (dec width))\n                    (recur (update-board row col board result) (inc row) 0)\n                    (recur (update-board row col board result) row (inc col))\n                  )\n                )\n              )\n            )\n)","problem":94,"user":"526dd90de4b03e8d9a4a72fe"},{"problem":94,"code":"(fn [g]\n  (letfn [\n          (ncount [g r c]\n                (let [n (apply str (conj (map #(subs (g (+ r %)) (- c 1) (+ c 2)) [-1 1])\n                                         (get-in g [r (dec c)])\n                                         (get-in g [r (inc c)])))\n                      c (count (filter #(= % \\#) n))] c\n                                                      ))\n\n          (rules [c n]\n                (cond\n                  (and (< n 2) (= c \\#)) \\space\n                  (and (> n 3) (= c \\#)) \\space\n                  (and (= n 3) (= c \\space)) \\#\n                  :otherwise c\n                  ))\n          ]\n  (let [d (count g)\n        pad (apply str (repeat d \\space))\n        ng (map #(format \" %s \" %)\n                (apply map str (partition (- d 2) (map\n                                              #(rules (get-in g [(second %1) (first %1)]) (ncount g (second %1) (first %1)))\n                                              (for [r (range 1 (dec d)) c (range 1 (dec d))] [r c]))\n                                            )))]\n    (concat [pad] ng [pad])\n    )))","user":"52593207e4b0cb4875a45cd3"},{"problem":94,"code":"(fn gol [board]\n  (map \n    #(apply str %)\n    (partition (count board)\n              (for [y (range (count board))\n                    x (range (count (first board)))]\n                (let [alive? (= (get-in board [y x]) \\#)\n                      nc (->> [[-1 -1] [0 -1] [1 -1] [-1 0] [1 0] [-1 1] [0 1] [1 1]]\n                              (map (fn [[nx ny]]\n                                     (get-in board [(+ y ny) (+ x nx)])))\n                              (filter #(= % \\#))\n                              count)]\n                  (if (or (and (not alive?) (= nc 3))\n                          (and alive? (<= 2 nc 3)))\n                    \\#\n                    \\space))))))","user":"5541fa50e4b0a04f79299515"},{"code":"(fn life[board]\n  (letfn [(alive?[x y] (= \\# (get-in board [y x])))\n\t\t\t\t\t(alive-neighbors[x y]\n\t\t\t\t\t\t(count (for [xx [x (dec x) (inc x)]\n\t\t\t\t\t\t\t\t\t\t\t\t yy [y (dec y) (inc y)]\n\t\t\t\t\t\t\t\t\t\t\t\t :when (alive? xx yy)] 1)))]\n\t\t(map #(apply str %) \n\t\t\t\t (for [y (range (count board))] \n\t\t\t\t\t\t\t(for [x (range (count (first board)))]\n\t\t\t\t\t\t\t\t(let [curr-nbos (alive-neighbors x y)] \n\t\t\t\t\t\t\t\t\t(if (or (= 3 curr-nbos) (and (alive? x y) (= 4 curr-nbos)))\n\t\t\t\t\t\t\t\t\t\t\\# \n\t\t\t\t\t\t\t\t\t\t\\space)))))))","problem":94,"user":"4f1fd734535d64f6031464a5"},{"problem":94,"code":"(fn next-gen [a-board]\n  (letfn [(parse [board]\n                 (let [index-row\n                       (fn [idx, row]\n                         (map-indexed #(vector [idx %1] %2) row))]\n                   (->> (map-indexed index-row board)\n                        (apply concat)\n                        (reduce (fn [m [k v]] (assoc m k v)) {}))))\n          (unparse [board]\n                   (let [cells (keys board)\n                         nrows (inc (apply max (map first cells)))\n                         ncols (inc (apply max (map second cells)))\n                         empty-board (vec (repeat nrows (vec (repeat ncols \\space))))\n                         unparse-row (fn [b [[r c] v]] (assoc b r (assoc (b r) c v)))]\n                     (->> board\n                          (reduce unparse-row empty-board)\n                          (map #(apply str %))\n                          (vec))))\n          (alive? [cell board]\n                  (= \\# (board cell)))\n          (neighbors [cell board]\n                     (let [[row col] cell]\n                       (->> [[row (dec col)]\n                             [row (inc col)]\n                             [(dec row) col]\n                             [(inc row) col]\n                             [(dec row) (dec col)]\n                             [(dec row) (inc col)]\n                             [(inc row) (dec col)]\n                             [(inc row) (inc col)]]\n                            (filter #(contains? board %)))))\n          (alive-neighbors [cell board]\n                           (->> (neighbors cell board)\n                                (filter #(alive? % board))))\n          (alive-next? [cell board]\n                       (let [nc (count (alive-neighbors cell board))]\n                         (if (alive? cell board)\n                           (or (= nc 2) (= nc 3))\n                           (= nc 3))))\n          (next-board [board]\n                      (let [next-board-for-cell\n                            (fn [b cell]\n                              (if (alive-next? cell board)\n                                (assoc b cell \\#)\n                                (assoc b cell \\space)))]\n                        (reduce next-board-for-cell {} (keys board))))]\n    (unparse (next-board (parse a-board)))))","user":"57adbe7ee4b0b8559636fca0"},{"problem":94,"code":"(fn [d]\n    (for [i (range (count d))]\n      (apply\n       str\n       (for [j (range (count (d i)))]\n         (let [z (= \\# (get-in d [i j]))\n               v [-1 0 1]\n               u (count (filter #(= \\# (get-in d %)) (for [a v, b v] [(+ i a) (+ j b)])))]\n           (if (or (== 3 u) (and z (== 4 u))) \\# \" \"))))))","user":"4f08b15b535dcb61093f6c40"},{"code":"(fn [h b]\n    (map (partial apply str)\n         (map-indexed\n          (fn [r l] (map-indexed\n                    (fn [c e]\n                      ({3 \\# 2 e}\n                       (apply + (map\n                                 (fn [[i j]] ({\\# 1} (get-in b [(+ i r) (+ j c)] \\ ) 0))\n                                 h))\n                       \\ ))\n                    l))\n          b)))\n  [[-1 -1][-1 0][-1 1][0 -1][0 1][1 -1][1 0][1 1]]","problem":94,"user":"4ff67852e4b0678c553fc37e"},{"code":"(fn p94\n  ;; \"Next step in game of life\"\n  [board]\n  (let [alive \\#\n        dead \\space]\n    (letfn [(alive? [[row col]]\n              (= (get (board row) col) \\#))\n            (neighbors [[row col]]\n              ;; (map (fn [[r c]] )\n              (for [r [(dec row) row (inc row)]\n                    c [(dec col) col (inc col)]\n                    :when (and (<= 0 r (dec (count board)))\n                               (<= 0 c (dec (count (board 0))))\n                               (or (not= r row) (not= c col)))]\n                (get (board r) c)\n                     ;; [r c]\n                ))\n            (live-neighbors [cell]\n              (count (filter #(= alive %) (neighbors cell))))\n            (transform-cell [cell]\n              (let [n-neighbors (live-neighbors cell)]\n                (if (alive? cell)\n                  (cond (> 2 n-neighbors) dead\n                        (>= 3 n-neighbors) alive\n                        (< 3 n-neighbors) dead)\n                  ;; cell is dead on original board\n                  (if (= 3 n-neighbors) alive dead))))\n            (transform-line [line-num]\n              (map transform-cell\n                   (partition 2 (interleave (repeat line-num)\n                                            (range\n                                             (count (board 0)))))))]\n      (map #(apply str %)\n           (map transform-line (range (count board)))))))","problem":94,"user":"50bca033e4b0594b91591c5d"},{"problem":94,"code":"(fn [board]\n  (letfn [(neighbors [i0 j0]\n            (let [n (count board)]\n              (for [i (range (dec i0) (+ i0 2))\n                    j (range (dec j0) (+ j0 2))\n                    :when (and (> n i 0) (> n j 0)\n                               (not= [i j] [i0 j0]))]\n                (get-in board [i j]))))\n          (get-lives [i0 j0] (->> (neighbors i0 j0)\n                                  (filter #(= \\# %))\n                                  count))\n          (live? [i j] (= (get-in board [i j]) \\#))\n          (nxt [i0 j0]\n            (let [lives (get-lives i0 j0)\n                  live (live? i0 j0)]\n              (cond\n                (and live (> 2 lives)) \\space\n                (and live (#{2 3} lives)) \\#\n                (and live (> lives 3)) \\space\n                (and (not live) (= 3 lives)) \\#\n                :else \\space)))]\n    (let [n (count board)\n          rng (range n)]\n      (for [i rng] \n        (apply str (for [j rng] (nxt i j)))))))","user":"5f82609ae4b0c071e6c840f9"},{"code":"(fn next-life [state]\n  (let [num-rows (count state)\n        num-cols (count (nth state 0))]\n    (letfn [(cell [i j]\n              (nth (nth state i \"\") j \\space))\n            (neighbours [i j]\n              (for [di [-1 0 1]\n                    dj [-1 0 1]\n                    :when (or (not= 0 di) (not= 0 dj))]\n                (cell (+ i di) (+ j dj))))\n            (live-neighbours [i j]\n              (count (filter #{\\#} (neighbours i j))))]\n      (for [i (range 0 num-rows)]\n        (apply str (for [j (range 0 num-cols)]\n                     (if (= \\# (cell i j))\n                       (case (live-neighbours i j)\n                         (2 3) \\#\n                         \\space)\n                       (if (= 3 (live-neighbours i j)) \\# \\space))))))))","problem":94,"user":"5186134ce4b0da5a5be3bac7"},{"problem":94,"code":"(fn [v]\n  (let [height (count v)\n        width (count (nth v 0))\n        points (for [x (range width) y (range height)] [x y])\n        alive? (fn [[x y]] (= (nth (nth v y) x) \\#))\n        distance (fn [startPoint endPoint] (Math/sqrt (+ (Math/pow (- (first endPoint) (first startPoint)) 2)\n                                                         (Math/pow (- (last endPoint) (last startPoint)) 2))))\n        neighbors (fn [point] (remove #{point} (filter #(< (distance point %) 2) points)))\n        aliveNeighbors (fn [point] (count (filter alive? (neighbors point))))\n        evolution (fn [point] (let [alive (aliveNeighbors point)] (if (alive? point)\n          (cond\n          (< alive 2) \" \"\n          (= alive 2) \"#\"\n          (= alive 3) \"#\"\n          (> alive 3) \" \")\n          (if (= alive 3) \"#\" \" \"))))\n        build-line (fn [line] (apply str (map #(evolution [% line]) (range width))))]\n    (mapv build-line (range height))))","user":"5e13a6b7e4b099d064963001"},{"code":"(fn [rows]\n  (let [neighbor-offsets (disj (set (for [y (range -1 2)\n                                          x (range -1 2)]\n                                      [y x]))\n                               [0 0])]\n    (letfn [(cells [b]\n              (for [y (range (:h b))\n                    x (range (:w b))]\n                [y x]))\n            (find-life [b rows]\n              (let [rows (vec (map vec rows))\n                    alive (fn [[y x]] (= \\# ((rows y) x)))]\n                (set (filter alive (cells b)))))\n            (parse [rows]\n              (let [h (count rows)\n                    w (.length (first rows))\n                    b {:h h, :w w }]\n                (assoc b :alive (find-life b rows))))\n            (render [b]\n              (map (partial apply str)\n                   (partition (:w b)\n                              (map #(if ((b :alive) %) \\# \\space) (cells b)))))\n            (on-board? [b [y x]]\n              (and (>= y 0) (>= x 0) (< y (:h b)) (< x (:w b))))\n            (add [[y x] [dy dx]]\n              [(+ y dy) (+ x dx)])\n            (neighbors [board cell]\n              (set (filter (partial on-board? board)\n                           (map (partial add cell) neighbor-offsets))))\n            (count-live-neighbors [board cell]\n              (count (filter (:alive board) (neighbors board cell))))\n            (cell-status [b cell]\n              [((:alive b) cell)\n               (count-live-neighbors b cell)])\n            (should-live [alive pals]\n              (if alive\n                (and (> pals 1)\n                     (< pals 4))\n                (= pals 3)))\n            (cell-should-live [b cell]\n              (apply should-live (cell-status b cell)))\n            (round [b]\n              (assoc b :alive (set (filter (partial cell-should-live b) (cells b)))))]\n      (-> rows parse round render))))","problem":94,"user":"50d93c53e4b0fd36a4b89223"},{"problem":94,"code":"(fn life [b]\n      (into []\n            (for [[i row] (map-indexed vector b)]\n              (apply str\n                    (for [[j c] (map-indexed vector row)\n                          :let [ln\n                                (count\n                                 (for [i-delt (range -1 2)\n                                       j-delt (range -1 2)\n                                       :when (not= [i-delt j-delt] [0 0])\n                                       :let [at-pos (get-in b [(+ i i-delt)\n                                                               (+ j j-delt)])]\n                                       :when (= \\# at-pos)]\n                                   true))]]\n                      (if (= c \\#)\n                        (if (< 1 ln 4)\n                          \\#\n                          \\space)\n                        (if (= 3 ln)\n                          \\#\n                          \\space)))))))","user":"54246fcce4b01498b1a71aed"},{"code":"(fn [b] (let [\n              h (range (count b))\n              w (range (count (first b)))\n              bm (reduce (fn [m r] (reduce #(assoc % (list r %2) (nth (nth b r) %2)) m w)) {} h)\n              adj (fn [[x y]] [[(dec x) y] [(dec x) (dec y)] [(dec x) (inc y)] [x (dec y)] \n                                [x (inc y)] [(inc x) (inc y)] [(inc x) y] [(inc x) (dec y)]])\n              nes #(remove nil? (map bm (adj %)))\n              ls #(count (filter (partial = \\#) (nes %)))\n              up (fn [p] (case (bm p)\n                         \\# (cond (< (ls p) 2) \\ \n                                  (> (ls p) 3) \\ \n                                  :else \\#)\n                         \\  (cond (= (ls p) 3) \\#\n                                  :else \\ )))\n                         ]\n          (map (fn [r] (apply str (map (fn [c] (up [r c])) w))) h)))","problem":94,"user":"50dfb660e4b061dbdced7228"},{"code":"(fn life [a]\n  (let [m (count a)\n        n (-> a first count)\n        incx [-1 -1 -1 0 1 1 1 0]\n        incy [-1 0 1 1 -1 0 1 -1]]\n        (letfn [(is-alive [a x y]\n          (and (>= x 0)\n            (>= y 0)\n            (< x (count a))\n            (< y (-> a first count))\n            (= \\# (.charAt (a x) y))))\n    (update [a x y]\n      (let [current (.charAt (a x) y)\n        alive (map #(if (is-alive a (+ x %1) (+ y %2)) 1 0) incx incy)\n        alive (apply + alive)]\n        (if (= \\# current)\n          (if (or (= 2 alive) (= 3 alive))\n           \\#\n           \" \")\n          (if (= 3 alive)\n            \\#\n            \" \"))))]\n      (for [x (range m)]\n        (apply str (map #(update a x %) (range n)))))))","problem":94,"user":"5054bc87e4b0b1b9d1860eb0"},{"code":"(fn [m]\n  `(~(first m)\n    ~@(map\n       (fn [v]\n         (apply\n          str\n          `(\\space\n            ~@(for [i (range 1 (dec (count m)))]\n                (let [x (count (filter (partial = \\#) (mapcat #(subs % (dec i) (+ 2 i)) v)))]\n                  (if (or (= x 3)\n                          (and (= \\# (nth (second v) i))\n                               (= x 4)))\n                    \\# \\space)))\n            \\space)))\n       (partition 3 1 m))\n    ~(first m)))","problem":94,"user":"4f9fe2b9e4b0dcca54ed6d40"},{"code":"(fn game [b]\n  (letfn [ (foo [b] (fn [c] (let [r (get-in b c) s (= r \\#)] (if s 1 0))))\n    (r2 [x] (range (dec x) (+ 2 x))) \n    (circ [[x y]] (for [i (r2 x) j (r2 y) :when (or (not= i x) (not= j y)) ] [i j]))\n    (n-alive [b c] (reduce + (map (foo b) (circ c))))\n    (surv [b c] (let [n (n-alive b c)]\n                  (cond \n                   (and (= ((foo b) c) 1) (#{2,3} n)) \\#       \n                   (= 3 n) \\#\n                   :else \\space)))\n    (row [i r]  (apply str (map-indexed (fn [j _]\n                                  (surv b [i j]))\n                                r)))]\n    (map-indexed row b)))","problem":94,"user":"4ede8789535d10e5ff6f5337"},{"problem":94,"code":"(fn next-generation\n   [g]\n   (letfn [(elem\n             [i j]\n             (nth (nth g i) j))\n           (nbs\n             [i j]\n             (let [dirs [[1 0] [1 1] [1 -1]\n                         [0 1] [0 -1]\n                         [-1 1] [-1 0] [-1 -1]]\n                   sz (count g)]\n               (reduce\n                 (fn [res [a b]]\n                   (let [ni (+ i a)\n                         nj (+ j b)]\n                     (cond\n                       (or (>= ni sz) (>= nj sz)\n                           (< ni 0) (< nj 0)) res\n                       (= \\# (elem ni nj)) (inc res)\n                       :else res)))\n                 0 dirs)))]\n     (let [res (atom (vec (map vec g)))\n           sz (count g)]\n       (doseq [i (range sz) j (range sz)]\n         (let [e (elem i j)\n               n (nbs i j)]\n           (if (= \\space e)\n             (when (= 3 n)\n               (swap! res assoc-in [i j] \\#))\n             (when-not (or (= 2 n) (= 3 n))\n               (swap! res assoc-in [i j] \\space)))))\n       (vec (map #(apply str %) @res)))))","user":"56a36f76e4b0542e1f8d14ca"},{"code":"(fn [x] (let [g (to-array-2d x)\n               n (dec (alength g))\n               m (dec (alength (aget g 0)))\n               c (fn [a b] (count (filter #(= % \\#) (list (aget g (dec a) (dec b))\n                                 (aget g (dec a) b)\n                                 (aget g (dec a) (inc b))\n                                 (aget g a (dec b))\n                                 (aget g a (inc b))\n                                 (aget g (inc a) (dec b))\n                                 (aget g (inc a) b)\n                                 (aget g (inc a) (inc b))))))] \n           (conj (vec (cons (first x) (map #(str (apply str \" \" %) \" \") (partition (dec m) (for [y (range 1 n) \n                 x (range 1 m)] \n             (let [v (aget g y x)\n                   w (c y x)]\n               (if (= v \\#) (if (#{2 3} w) v \\space) (if (= 3 w) \\# v)))))))) (last x))))","problem":94,"user":"4eb13d60535d7eef3080733f"},{"problem":94,"code":"(fn [board]\n  (let [neighbors (fn [[x y]]\n                    (for [dx [-1 0 1]\n                          dy [-1 0 1]\n                          :when (not= 0 dx dy)]\n                      [(+ dx x) (+ dy y)]))\n        neighbors-count (fn [board [x y]]\n                          (count (filter #(= \\# (get-in board %)) (neighbors [x y]))))\n        h (count board)\n        w (count (first board))]\n    (map (partial apply str)\n         (reduce (fn [new-board [x y]]\n                   (let [liveness-cell (case (neighbors-count board [x y])\n                                         2 (get-in board [x y])\n                                         3 \\#\n                                         \\space)]\n                     (assoc-in new-board [x y] liveness-cell)))\n                 (vec (map vec board))\n                 (for [x (range h) y (range w)]\n                   [x y])))))","user":"5ce077e9e4b0a17bb84e2b0c"},{"problem":94,"code":"(fn gen-next [table]\n  (let [matrix (->> table\n                 (map (partial map (fn [char] (if (= char \\#) 1 0))))\n                 (map vec)\n                 vec)\n        max-x (count (matrix 0))\n        max-y (count matrix)\n        lazy-get (fn [x y]\n                   (if (or (< x 0) (= x max-x) (< y 0) (= y max-y)) 0 ((matrix y) x)))\n        neighbours-sum (fn [x y]\n                         (reduce + (for [xdiff (range -1 2)\n                                         ydiff (range -1 2)\n                                         :when (or (not= xdiff 0) (not= ydiff 0))]\n                                     (lazy-get (+ x xdiff) (+ y ydiff)))))]\n    (->> (for [y (range 0 max-y)\n               x (range 0 max-x)]\n           (let [neighbours (neighbours-sum x y)]\n             (if (= (lazy-get x y) 0)\n               (if (= 3 neighbours) \\# \\space)\n               (cond (< neighbours 2) \\space\n                     (> neighbours 3) \\space\n                     :else \\#))))\n      (partition max-x)\n      (map (partial reduce str)))))","user":"53c38b8ce4b00fb29b22127b"},{"code":"(fn [b]\n  (let [ct (fn [p] (count (filter #(= (get-in b (map + p %)) \\#)\n                                  [[-1 -1] [-1 0] [-1 1] [0 -1] [0 1] [1 -1] [1 0] [1 1]])))]\n    (map-indexed (fn [y r]\n                   (apply str (map-indexed\n                               (fn [x o]\n                                 (let [n (ct [y x])]\n                                   (if (or (= n 3) (and (= n 2) (= o \\#)))\n                                     \\# \\ )))\n                               r)))\n                 b)))","problem":94,"user":"4e8612f8535db62dc21a62f2"},{"problem":94,"code":"(fn [b]\n  (letfn [(neighbors [x y]\n            (let [o [-1 0 1]]\n              (for [j o k o\n                    :when (not= [j k] [0 0])]\n                (get-in b [(+ y k) (+ x j)]))))]\n    (for [y (range (count b))]\n      (apply str\n             (for [x (range (count (first b)))\n                   :let [n (count (filter #{\\#} (neighbors x y)))]]\n               (cond\n                (= n 2) (get-in b [y x])\n                (= n 3) \\#\n                :else \\space))))))","user":"4e6a4950535d8ccf87e9febf"},{"problem":94,"code":"(fn [board]\n  (let [vboard (vec (map vec board))\n        trans (fn [b f]\n                (vec (for [y (range (count b))]\n                       (vec (for [x (range (count (get b y)))]\n                              (f y x (get-in b [y x])))))))\n        neib-indexes (for [x [-1 0 1] y [-1 0 1] :when (not (= 0 x y))] [x y])\n        delta-neib? (fn [x y [dx dy]]\n                      (= \\# (get-in vboard [(+ x dx) (+ y dy)])))\n        new-gen (fn [x y d]\n                  (let [neibs (filter (partial delta-neib? x y) neib-indexes)\n                        abs-count (count neibs)\n                        ncount (if (= d \\#) abs-count (- abs-count))]\n                    (if (#{-3 2 3} ncount) \\# \\space)))\n        new-board (trans vboard new-gen)]\n    (map (partial apply str) new-board)))","user":"53f7820be4b0de5c41848560"},{"problem":94,"code":"(fn life-next-generation [b]\n  (let [index-matrix (fn [m]\n                       (apply\n                         concat\n                         (map-indexed\n                           (fn [row-idx row]\n                             (map-indexed #(list [row-idx %1] %2) row))\n                           m)))\n        neighbors (fn [indexed-matrix]\n                    (->>\n                      (group-by\n                        first\n                        (mapcat\n                          (fn [[[row col] value]]\n                            (for [x [-1 0 1]\n                                  y [-1 0 1]\n                                  :when (not (and (zero? x) (zero? y)))]\n                              (list [(+ x row) (+ y col)] value)))\n                          indexed-matrix))\n                      (map (fn [[idx cells]]\n                             (list\n                               idx\n                               (map #(second %) cells))))\n                      (filter\n                        (fn [[idx value]]\n                          (not-any? neg? idx)))))\n        cells-with-neighbors (fn cells-with-neighbors [m]\n                               (let [indexed-matrix (index-matrix m)\n                                     cell-neighbors (neighbors indexed-matrix)\n                                     values-only (reduce\n                                                   #(assoc %1 (first %2) {:value (second %2) :neighbors ()})\n                                                   {}\n                                                   indexed-matrix)]\n                                 (reduce\n                                   (fn [matrix-hash [idx neighbor-values]]\n                                     (update-in\n                                       matrix-hash\n                                       [idx :neighbors]\n                                       #(concat % neighbor-values)))\n                                   values-only\n                                   cell-neighbors\n                                   )\n                                 ))\n        next-generation (fn [cells]\n                          (map\n                            (fn [[idx cell]]\n                              (let [live-neighbors (->>\n                                                     (:neighbors cell)\n                                                     (filter #(= \\# %))\n                                                     (count))]\n                                (if (= \\# (:value cell))\n                                  (if (and (< 1 live-neighbors)\n                                           (> 4 live-neighbors))\n                                    (list idx \\#)\n                                    (list idx \\space))\n                                  (if (= live-neighbors 3)\n                                    (list idx \\#)\n                                    (list idx \\space)))))\n                            cells))\n        form-board (fn [cells]\n                     (->>\n                       cells\n                       (map\n                         (fn [[idx value]]\n                           (list (first idx) (list (second idx) value))))\n                       (group-by first)\n                       (sort-by first)\n                       (map (fn [[_ values]]\n                              (->>\n                                values\n                                (map second)\n                                (sort-by first)\n                                (map second)\n                                (drop-last)\n                               )))\n                       (map #(apply str %))\n                       ))]\n    (->> b\n         (map seq)\n         (cells-with-neighbors)\n         (next-generation)\n         (form-board)\n         (drop-last)         \n         )))","user":"53527551e4b084c2834f4af0"},{"problem":94,"code":"(let [neighbours\n      (fn [x y minx miny maxx maxy]\n        (let [u (+ y 1) d (- y 1) l (- x 1) r (+ x 1)]\n          (let [naive\n                [[l u] [x u] [r u]\n                 [l y]       [r y]\n                 [l d] [x d] [r d]]]\n            (filter (fn [[x y]] (and (>= x minx) (>= y miny)\n                                     (<= x maxx) (<= y maxy)))\n                    naive))))]\n  (fn life-step\n    [board]\n    (let [alive \\#\n          dead \\space\n          minx 0\n          miny 0\n          maxx (- (count board) 1)\n          maxy (- (count (first board)) 1)\n          get\n          (fn [[x y]] (nth (nth board x) y))\n          nbrs\n          (fn [[x y]] (neighbours x y minx miny maxx maxy))\n          live-count\n          (fn [cells] (count (filter #(= \\# %) cells)))\n          next-state\n          (fn [live-count current] (if (< live-count 2) dead\n                                       (if (= live-count 2) current\n                                           (if (= live-count 3) alive\n                                               dead))))\n          coords\n          (map (fn [x] (map (fn [y] [x y])\n                            (range (+ maxy 1)))) \n               (range (+ maxx 1)))]\n      (let [next-board (map #(map (fn [coord]\n                                    (next-state (live-count (map get (nbrs coord)))\n                                                (get coord)))\n                                  %) coords)]\n        (map #(clojure.string/join  %) next-board)))))","user":"58152157e4b0f478707a0631"},{"code":"(fn [inputboard]\n  (let [neighbors (fn [[x y]] \n                    (for [dx [-1 0 1] dy [-1 0 1] :when (not (and (= 0 dx) (= 0 dy)))]\n                      [(+ x dx) (+ y dy)]))]\n        (map (fn [x] (apply str x)) (reduce (fn [row x] \n                 (conj row (reduce (fn [col y]\n                          (let [curneighbors (neighbors [x y])\n                                cntneighbors (count (filter #(= % \\#) \n                                                           (map (fn [[x y]] \n                                                                    (get-in inputboard [x y] \\space)) curneighbors))) \n                                live? (= \\# (get-in inputboard [x y] \\space))]\n                            (if (or (= cntneighbors 3) (and live? (= cntneighbors 2)))\n                              (conj col \\#)\n                              (conj col \\space)))) [] (range (count inputboard))))) [] (range (count inputboard))))))","problem":94,"user":"4e7f5a0b535db966e863cc41"},{"code":"(fn game-of-life [board]\n   (let [max-x (count (board 0))\n         max-y (count board)]\n     (letfn [(neighbours [[x y]]\n               (filter #(and (< (% 0) max-x)\n                             (< (% 1) max-y)\n                             (>= (% 0) 0)\n                             (>= (% 1) 0))\n                       [[(inc x) (inc y)]\n                        [(inc x) y]\n                        [x (inc y)]\n                        [(dec x) (dec y)]\n                        [(dec x) y]\n                        [x (dec y)]\n                        [(inc x) (dec y)]\n                        [(dec x) (inc y)]]))\n             (dead? [[x y]] (not= \\# (get-in board [x y])))\n             (alive-neighbours [cell] (remove dead? (neighbours cell)))]\n       (let [new-config\n             (->> (for [x (range max-x)\n                        y (range max-y)\n                        :let [cell [x y]\n                              alive-neighbours (count (alive-neighbours cell))]]\n                      (if-not (dead? cell)\n                        (cond (or (= alive-neighbours 2)\n                                  (= alive-neighbours 3))\n                              [:alive cell]\n                              \n                              :else\n                              [:dead cell])\n                        (if (= alive-neighbours 3)\n                          [:alive cell])))\n                  (remove nil?))\n             new-board (vec (map vec board))]\n         (->> (reduce (fn [board [state x]]\n                        (assoc-in board x (if (= state :alive) \\# \\ )))\n                      new-board new-config)\n              (map (partial clojure.string/join \"\"))\n              vec)\n         ))))","problem":94,"user":"4e9fd521535d7eef3080729a"},{"problem":94,"code":"(fn __ [g]\n  (let [min-neighbors 2\n        max-neighbors 3\n        birth-num     3\n        height        (count g)\n        width         (count (get g 0))\n        live?         (fn [point g]\n                        (= (get-in g point \\#) \\#))]\n    (for [y (range height)]\n      (clojure.string/join (for [x (range width)]\n                             (let [living?         (live? [y x] g)\n                                   neighbor-coords (for [yn    (range (dec y) (inc (inc y)))\n                                                         xn    (range (dec x) (inc (inc x)))\n                                                         :when (>= (dec height) yn 0)\n                                                         :when (>= (dec width) xn 0)\n                                                         :when (not= [yn xn] [y x])] [yn xn])\n                                   live-neighbors  (->> neighbor-coords\n                                                        (map #(if (live? % g) 1 0))\n                                                        (apply +))]\n                       (cond\n                         (= live-neighbors birth-num)\n                         \\# \n\n                         (and living? (<= min-neighbors live-neighbors max-neighbors))\n                         \\#\n\n                         :else\n                         \\space\n                         )))))))","user":"55916764e4b0604b3f94d57b"},{"code":"(fn __\n  [field]\n  (letfn [(neighbours\n            [m e]\n            (let [ki (first e)\n                  kj (second e)\n                  s #(get-in m [[%1 %2] :s])]\n              [(s (dec ki) (dec kj)) (s (dec ki) kj) (s (dec ki) (inc kj))\n               (s ki (dec kj)) (s ki (inc kj))\n               (s (inc ki) (dec kj)) (s (inc ki) kj) (s (inc ki) (inc kj))]))\n          (to-field\n            [f]\n            (reduce (fn [row i]\n                      (conj row (clojure.string/join (map (comp second first val) (sort (filter (fn [e] (= i (first (key e)))) f))))))\n                    [] (range (count field))))\n          (count-cells\n            [n sym]\n            (count (filter #(= % sym) n)))]\n    (let [f (reduce (fn [res row]\n                            (let [col (map-indexed vector (second row))]\n                              (merge res (reduce (fn [r e] \n                                                         (assoc r [(first row) (first e)] {:s (second e)})\n                                                         ) {} col)))\n                            ) {} (map-indexed vector field))]\n      \n      (to-field\n        (reduce (fn [r c]\n                  (let [n (neighbours f (first c))\n                        fewer-than-two-live? (and (= ((second c) :s) \\#) (< (count-cells n \\#) 2))\n                        two-or-three-live? (and (= ((second c) :s) \\#) (or (= 2 (count-cells n \\#)) (= 3 (count-cells n \\#))))\n                        more-than-three-live? (and (= ((second c) :s) \\#) (> (count-cells n \\#) 3))\n                        one-dead-three-live? (and (= ((second c) :s) \\space) (= 3 (count-cells n \\#)))]\n\n                    (cond\n                      fewer-than-two-live? (assoc r (first c) {:s \\space})\n                      two-or-three-live? (assoc r (first c) {:s \\#})\n                      more-than-three-live? (assoc r (first c) {:s \\space})\n                      one-dead-three-live? (assoc r (first c) {:s \\#})\n                      :else r)))\n                f f))\n\n  )))","problem":94,"user":"5348cab4e4b084c2834f4a5e"},{"problem":94,"code":"(fn [b]\n  (let [bx (dec (count (first b))) by (dec (count b))]\n    (letfn [(get-next [x y] (if (or (or (< x 0) (< y 0)) (or (> x bx) (> y by))) nil (if (= (nth (nth b y) x) \\#) \\# nil)))\n            (neighbours [x y] (count (filter #(= % \\#) (list (get-next (dec x) (dec y)) (get-next x (dec y))\n                                                             (get-next (inc x) (dec y)) (get-next (dec x) y)\n                                                             (get-next (inc x) y) (get-next (dec x) (inc y))\n                                                             (get-next x (inc y)) (get-next (inc x) (inc y))))))\n            (rep [x y]\n              (cond (and (= (nth (nth b y) x) \\space)\n                         (= (neighbours x y) 3)) \\#\n                    (and (= (nth (nth b y) x) \\#)\n                         (or (< (neighbours x y) 2)\n                             (> (neighbours x y) 3))) \\space\n                    :else (nth (nth b y) x)))]\n      (map #(apply str %) (partition (count (first b))\n        (loop [x 0 y 0 res []]\n          (if (= y (count b)) res\n            (recur (if (= x bx) 0 (inc x))\n                   (if (= x bx) (inc y) y)\n                   (conj res (rep x y))))))))))","user":"53a1b5c8e4b0ca733b9744c1"},{"code":"(fn [b]\n  (let [is-alive? (fn [x] (= \\# x))\n        evolve (fn [b x y]\n                 (let [\n                       cell-alive? (is-alive? (-> b (nth x) (nth y)))\n                       neighbor-count (- (count \n                                           (filter\n                                             is-alive? \n                                             (flatten \n                                               (map \n                                                 #(->> % (take (+ y 2)) (drop (dec y))) \n                                                 (->> b (take (+ x 2)) (drop (dec x))))\n                                               )))\n                                         (if cell-alive? 1 0)\n                                         )]\n                   (cond\n                     (= 3 neighbor-count) \\#\n                     (and cell-alive? (= 2 neighbor-count)) \\# \n                     :default \\space)))\n        ]\n    (for [x (range (count b))]\n      (apply str\n             (for [y (range (count (first b)))]\n               (evolve b x y)\n               )))))","problem":94,"user":"4fbbcf0ce4b081705acca2ee"},{"problem":94,"code":"(fn [world]\n    (letfn [(neighborhood\n              [[x y]]\n              (map (fn vector-add [[xx yy]] (vector (+ x xx) (+ y yy)))\n                   [[-1 -1] [-1 0] [-1 1] [0 -1] [0 1] [1 -1] [1 0] [1 1]]))\n\n            (neighbors\n              [world coordinate]\n              (filter world (neighborhood coordinate)))\n\n            (pregnant?\n              [world coordinate]\n              (when (and (not (world coordinate))\n                         (= 3 (count (neighbors world coordinate))))\n                coordinate))\n\n            (spawn\n              [world]\n              (set (filter (partial pregnant? world)\n                           (reduce into [] (map neighborhood world)))))\n\n            (healthy?\n              [world cell]\n              (when (and (world cell)\n                         (#{2 3} (count (neighbors world cell)))) \n                cell))\n\n            (survivors\n              [world]\n              (set (filter (partial healthy? world) world)))\n\n            (new-world\n              [world]\n              (into (survivors world) (spawn world)))\n\n            (to-coords\n              [world]\n              (set (filter vector?\n                           (reduce into [] (map #(for [x [%] y (range (count (first world)))]\n                                                   (if (= \\# (nth (nth world x) y))\n                                                     [x y]))\n                                                (range (count world)))))))\n\n            (from-coords\n              [coords rows cols]\n              (vec (map #(apply str %)\n                        (partition cols (for [x (range rows) y (range cols)]\n                                          (if (coords [x y])\n                                            \\#\n                                            \\space))))))\n            (main\n              [world]\n              (let [rows (count world)\n                    cols (count (first world))]\n                (from-coords (new-world (to-coords world)) rows cols)))]\n\n      (main world)))","user":"52485f02e4b05ef8e38e63d3"},{"code":"(let [zip (partial map vector)\n      enum (partial zip (iterate inc 0))\n      rfs [dec identity inc]\n      string (partial apply str)\n      neighbor-coords (fn [rmax cmax r c]\n        (for [f rfs :let [i (f r)] :when (<= 0 i rmax)\n              f rfs :let [j (f c)] :when (and (<= 0 j cmax)\n                                              (not= [r c] [i j]))]\n          [i j]))\n      count-neighbors (fn [board coords]\n        (count (filter #{\\#} (map #(get-in board %) coords))))]\n  (fn [board]\n    (let [f (comp (partial count-neighbors board)\n                  (partial neighbor-coords\n                           (count board)\n                           (count (first board))))]\n      (for [[r xs] (enum board)]\n        (string\n          (for [[c x] (enum xs)]\n            (condp = (f r c)\n              2 x, 3 \\#, \\space)))))))","problem":94,"user":"4e6a412e535d8ccf87e9feb6"},{"code":"(fn [board]\n  (let [size (count board)\n        alive? (fn [x y] (= (get-in board [x y]) \\#))\n        neighbours (fn [x y]\n                     (reduce #(if %2 (inc %) %) 0\n                             (for [i [-1 0 1]\n                                   j [-1 0 1]\n                                   :when (not= i j 0)]\n                               (alive? (+ x i) (+ y j)))))\n        cell (fn [x y n] (if (or (= n 3) (and (= n 2) (alive? x y))) \\# \\space))]\n    (for [x (range size)]\n      (apply str (for [y (range size)]\n                   (cell x y (neighbours x y)))))))","problem":94,"user":"4f05ea25535dcb61093f6c02"},{"code":"(fn [b]\r\n  (let [m (count b) n (count (first b))\r\n\tr [-1 0 1]\r\n\to (for [i r j r :when (not= [i j] [0 0])] [i j])\r\n\tl? #(= \\# (get-in b %))]\r\n    (for [i (range m)]\r\n      (apply str\r\n\t(for [j (range n) :let [p [i j]\r\n\t       k (count (filter l? (map #(map + p %) o)))]]\r\n\t(if (or (and (l? p) (= k 2)) (= k 3)) \\# \\ ))))))","problem":94,"user":"4eb97b2e535dfed6da9c6d54"},{"code":"(fn [starting-board]\n    (let [living? (fn [[i j]]\n                    (= \\# (get-in starting-board [i j])))\n          neighbors (fn [[i j]]\n                      (count\n                        (filter identity\n                                (for [[id jd] [[0 1] [1 1] [1 0] [1 -1] [0 -1] [-1 -1] [-1 0] [-1 1]]]\n                                  (living? [(+ i id) (+ j jd)])))))\n          should-live? (fn [p]\n                         (case (neighbors p)\n                           0 false\n                           1 false\n                           2 (living? p)\n                           3 true\n                           4 false\n                           5 false\n                           6 false\n                           7 false\n                           8 false))]\n      (for [i (range (count starting-board))]\n        (apply str\n               (for [j (range (count (get starting-board i)))]\n                 (if (should-live? [i j])\n                   \\#\n                   \\space))))))","problem":94,"user":"521b9f92e4b0c4ef0be8304c"},{"code":"(fn [board]\n  (map #(apply str %) (map\n                        (fn [sub-board]\n                          (apply\n                            (partial\n                              map\n                              (fn [first-row second-row last-row]\n                                (case (count (filter #{\\#} (concat first-row last-row [(first second-row) (last second-row)])))\n                                  3 \\#\n                                  2 (second second-row)\n                                  \\space)))\n                            (map #(partition 3 1 (concat [\\space] % [\\space])) sub-board)))\n                        (partition 3 1 (concat [\"      \"] board [\"      \"])))))","problem":94,"user":"514d7e29e4b019235f6c0587"},{"code":"(fn [v]\n  (letfn [(nc [x y w h]\n            (filter\n              #(and (>= (% 0) 0) (>= (% 1) 0) (< (% 0) w) (< (% 1) h) (not (= % [x y])))\n               (for [i (range (dec x) (+ x 2)) j (range (dec y) (+ y 2))] [i j])))\n          (n [x y] (count (filter #(= % \\#) (map #(nth (nth v (% 1)) (% 0)) (nc x y (count (first v)) (count v))))))]\n    (for [y (range 0 (count v))]\n      (apply str (for [x (range 0 (count v))]\n                   (let [c (nth (nth v y) x) ne (n x y)]\n                     (if (= ne 3) \\#\n                         (if (and (= ne 2) (= c \\#)) \\# \\space))))))))","problem":94,"user":"50bce014e4b0594b91591c63"},{"code":"(fn [b]\n  (let [alive \\#\n\n        dead \\space\n\n        neighbor-coords\n        (fn [[x y]]\n          (let [x- (dec x) x+ (inc x)\n                y- (dec y) y+ (inc y)]\n            (filter\n             (partial every? (complement neg?))\n             [[x- y+] [x y+] [x+ y+]\n              [x- y]         [x+ y]\n              [x- y-] [x y-] [x+ y-]])))\n\n        neighbors\n        (fn [coord b]\n          (->> (neighbor-coords coord)\n               (map (partial get-in b))\n               (filter #(= alive %))\n               (count)))\n\n        cell-tick\n        (fn [cell neighbors]\n          (cond (= 2 neighbors) cell\n                (= 3 neighbors) alive\n                :else           dead))\n\n        w (count (first b))\n\n        world-tick\n        (for [x (range w)\n              y (range (count b))\n              :let [cell (get-in b [x y])]]\n          (cell-tick cell (neighbors [x y] b)))]\n\n    (->> world-tick\n         (partition w)\n         (map #(apply str %)))))","problem":94,"user":"52d2ca1ce4b099d49816f0b4"},{"code":"#(for [y (range (count %))]\n   (apply\n    str\n    (for [x (range (count (first %)))]\n      (let [a \\#\n            d \\ \n            n (count\n               (filter #{a} (for [dy [-1 0 1] dx [-1 0 1]\n                                  :when (not= [0 0] [dy dx])]\n                              (get-in % [(+ y dy) (+ x dx)]))))]\n        (if (= (get-in % [y x]) d)\n          (if (= 3 n) a d)\n          (cond\n           (> 2 n) d\n           (#{2 3} n) a\n           (< 3 n) d))))))","problem":94,"user":"4dbb0b6c535d1e037afb21b0"},{"code":"(fn [board]\n  (let [w (count (first board))\n        c (juxt quot mod)\n        g (set (keep-indexed #({\\# (c % w)} %2) \n                             (mapcat seq board)))\n        neighbours (fn [[x y]]\n                     (for [dx [-1 0 1] dy (if (zero? dx) [-1 1] [-1 0 1])]\n                       [(+ dx x) (+ dy y)]))\n        ng (set (for [[loc n] (frequencies (mapcat neighbours g))\n                      :when (or (= n 3) (and (= n 2) (g loc)))]\n                  loc))]\n    (->>\n      (range (* w (count board)))\n      (map #(if (ng (c % w)) \\# \" \"))\n      (partition w)\n      (map #(apply str %)))))","problem":94,"user":"4e8f1ac6535d65386fec2146"},{"problem":94,"code":"(fn life [b]\n  (let [m (dec (count b))\n  n (dec (count (first b)))\n  b (vec (map vec b))\n  a? (fn a? [c]\n  (case c\n  \\# true\n  false))\n  f (fn f [c & cs]\n  (let [ns (map #(get (get b (first %)) (last %)) cs)\n  n (count (filter a? ns))]\n  (case c\n  \\# (case n\n  0 \\space\n  1 \\space\n  2 \\#\n  3 \\#\n  \\space)\n  (if (= 3 n)\n  \\#\n  \\space))))]\n  (map\n  #(apply str %)\n  (map-indexed\n  (fn x [i r]\n  (map-indexed\n  (fn y [j c]\n  (let [di (dec i) dj (dec j) ii (inc i) ij (inc j)]\n  (cond\n  (= i 0) (cond\n  (= j 0) (f c [i ij] [ii j] [ii ij])\n  (= j n) (f c [i dj] [ii dj] [ii j])\n  :else (f c [i dj] [i ij] [ii dj] [ii j] [ii ij]))\n  (= i m) (cond\n  (= j 0) (f c [di j] [di ij] [i ij])\n  (= j n) (f c [di dj] [di j] [i dj])\n  :else (f c [di dj] [di j] [di ij] [i dj] [i ij]))\n  :else (cond\n  (= j 0) (f c [di j] [di ij] [i ij] [ii j] [ii ij])\n  (= j n) (f c [di dj] [di j] [i dj] [ii dj] [ii j])\n  :else (f c [di dj] [di j] [di ij] [i dj]\n  [i ij] [ii dj] [ii j] [ii ij])))))\n  r))\n                  b))))","user":"579693d4e4b039eba2ecb0e7"},{"code":"(fn [board]\n  (let [n (count board)\n        m (-> board first count)\n        shifts [[-1 -1] [-1 0] [-1 1] [0 1] [1 1] [1 0] [1 -1] [0 -1]]\n        plus (fn [[x1 y1] [x2 y2]] [(+ x1 x2) (+ y1 y2)])\n        live? #(= (get-in board %) \\#)\n        neighbors (fn [pos]\n                    (->> shifts\n                         (map #(plus % pos))\n                         (map #(get-in board %))\n                         (filter #(= % \\#))\n                         count))\n        will-be-live? (fn [pos]\n                        (contains?\n                          (if (live? pos) #{2 3} #{3})\n                          (neighbors pos)))]\n    (->> (reduce\n           #(conj %1 (if (will-be-live? %2) \\# \\space))\n           '()\n           (for [x (range m) y (range n)] [x y]))\n         (partition m)\n         (map #(apply str %)))))","problem":94,"user":"514c2d05e4b02b8cbb2a9278"},{"problem":94,"code":"(let [offsets        (-> (for [i [-1 0 1] j [-1 0 1]] [i j])\n                           set\n                           (disj [0 0]))\n        live           \\#\n        dead           \\space\n        live?          #{live}\n        dead?          #{dead}\n        cell           (fn cell [m id]\n                         (get-in m id))\n        adjacents      (fn adjacents [rows cols [i j]]\n                         ;; Not specified, so we make the world toroidal\n                         (map (fn [[or oc]] [(mod (+ i or) rows)\n                                            (mod (+ j oc) cols)])\n                              offsets))\n        neighbors      (fn neighbors [m id]\n                         (for [coord (adjacents (count m)\n                                                (count (first m))\n                                                id)]\n                           (cell m coord)))\n        live-neighbors (fn live-neighbors [m id]\n                         (->> (neighbors m id)\n                              (filter live?)\n                              count))\n        successor      (fn successor [m id]\n                         (let [c  (cell m id)\n                               ns (live-neighbors m id)]\n                           (if (live? c)\n                             (if (<= 2 ns 3) live dead)\n                             (if (= ns 3) live dead))))]\n    (fn life-step [field]\n      (let [m (mapv vec field)]\n        (mapv #(apply str %)\n              (for [i (range (count m))]\n                (vec (for [j (range (count (first m)))]\n                       (successor m [i j]))))))))","user":"4dfe5a93535d04ed9115e786"},{"problem":94,"code":"(fn l [f]\n (letfn [(empty-row [n] (apply list (repeat n \" \")))\n          (snth [coll i] (if (and (>= i 0) (< i (count coll))) (nth coll i) \" \"))\n          (around [i c p n]\n            [(snth c (dec i)) (snth c (inc i))\n             (snth p (dec i)) (snth p i) (snth p (inc i))\n             (snth n (dec i)) (snth n i) (snth n (inc i))]\n            )\n          (new-map [c p n]\n                (map-indexed\n                    #(let [a (count (filter (fn [e] (= \"#\" (str e))) (around %1 c p n)))]\n                      (cond\n                        (and (= (str %2) \"#\") (< a 2)) \" \"\n                        (and (= (str %2) \"#\") (< a 4)) \"#\"\n                        (and (= (str %2) \"#\")) \" \"\n                        (and (= (str %2) \" \") (= 3 a)) \"#\"\n                        :else \" \"\n                        )\n                      )\n                     c)\n          )]\n        (loop [prev (empty-row (count (first f)))\n               cur (first f)\n               next (second f)\n               r (rest (rest (conj (conj f prev) prev)))\n               res []]\n                (if (empty? r)  res\n                  (recur cur next (first r) (rest r)  (conj res (apply str (new-map cur prev next))))\n                )\n        )\n    )\n  )","user":"55eeb37ae4b0121d4835fdf3"},{"problem":94,"code":"(fn c94\n  [v]\n  (letfn [(get-neighbors [i j xlimit ylimit]\n            (for [x (filter #(and (>= % 0) (<= % xlimit)) [(dec i) i (inc i)])\n                  y (filter #(and (>= % 0) (<= % ylimit)) [(dec j) j (inc j)])]\n              [x y]))]\n   (let [vs (mapv vec v)\n         xlimit (dec (count v))\n         ylimit (dec (count (first v)))]\n     (loop [i 0\n            j 0\n            vectors vs]\n       (let [neighbors (filter #(not (= [i j] %)) (get-neighbors i j xlimit ylimit))\n             val (case (nth (nth vs i) j)\n                   \\space (if (= 3 (reduce (fn [r v]\n                                             (if (= (nth (nth vs (first v)) (second v)) \\#)\n                                               (inc r)\n                                               r)) 0 neighbors))\n                            \\X\n                            \\space)\n                   \\# (let [lives (reduce (fn [r v]\n                                            (if (= (nth (nth vs (first v)) (second v)) \\#)\n                                              (inc r)\n                                              r)) 0 neighbors)]\n                        (if (< lives 2)\n                          \\Y\n                          (if (> lives 3)\n                            \\Y\n                            \\#))))]\n         (if (= j ylimit)\n           (if (= i xlimit)\n             (mapv (fn [v]\n                     (let [s (clojure.string/join v)]\n                       (clojure.string/replace\n                        (clojure.string/replace\n                         s\n                         #\"X\" \"#\")\n                        #\"Y\" \" \"))) vectors)\n             (recur (inc i) 0 (assoc vectors i (assoc (nth vectors i) j val))))\n           (recur i (inc j) (assoc vectors i (assoc (nth vectors i) j val)))))))))","user":"57d0cd58e4b0bd073c20235e"},{"problem":94,"code":"(fn [ss]\n  (let [ alive \\#, dead \\space, x-size (count (first ss)), y-size (count ss)]\n  (letfn [\n    (cell [i j] (if (or (< i 0) (< j 0) (>= i x-size) (>= j y-size)) nil\n      (nth (nth ss j) i)))\n    (nbrs [i j]\n        (filter identity (list (cell (inc i) j), (cell i (inc j)), (cell (inc i) (inc j)),\n       (cell (dec i) j), (cell i (dec j)), (cell (dec i) (dec j)),\n       (cell (inc i) (dec j)), (cell (dec i) (inc j)) )))\n    (live? [x] (=  x alive))\n    (n-live-nbrs [i j] (count (filter live? (nbrs i j ))))\n    (next [i j]\n     (if (live? (cell i j))\n         (case (n-live-nbrs i j)\n                2 alive\n                3 alive\n                dead)\n         (if (= 3 (n-live-nbrs i j)) alive dead)))\n    (convert [n c] (map #(apply str %) (partition n c)))]\n        (convert x-size\n        (mapcat (fn [j] (map (fn [i] (next i j)) (range x-size))) (range y-size)))\n      )))","user":"4fd11a93e4b04c3a95aa040a"},{"problem":94,"code":"(fn [input-board]\n  (let [str->bit        {\" \" 0 \"#\" 1}\n        bit->str        {0 \" \" 1 \"#\"}\n        live-or-die     (fn \n                          [cell neighbor-count]\n                          (if (or (= 3 neighbor-count)\n                                  (and (= 2 neighbor-count)\n                                       (= 1 cell)))\n                            1\n                            0))\n        get-neighbors   (fn\n                          [board [row col]]\n                          (let [up    (dec row)\n                                right (inc col)\n                                down  (inc row)\n                                left  (dec col)]\n                            (->> [[up left]   [up col]   [up right]\n                                  [row left]             [row right]\n                                  [down left] [down col] [down right]]\n                                 (filter (partial every? pos?))\n                                 (map (partial get-in board))\n                                 (remove nil?))))\n        parse-board     (fn \n                          [string-board]\n                          (mapv\n                           (fn [row-string]\n                             (->> row-string\n                                  (map str)\n                                  (mapv (partial get str->bit))))\n                           string-board))\n        serialize-board (fn\n                          [bit-board]\n                          (mapv\n                           (fn [bit-row]\n                             (->> bit-row\n                                  (map (partial get bit->str))\n                                  (apply str)))\n                           bit-board))\n        board           (parse-board input-board)]\n    (->> board\n         (map-indexed \n          (fn [row bits]\n            (map-indexed\n             (fn [col bit]\n               (->> [row col]\n                    (get-neighbors board)\n                    (apply +)\n                    (live-or-die bit)))\n             bits)))\n         (serialize-board))))","user":"53de7484e4b0d874e779ae35"},{"problem":94,"code":"(fn __ [board]\n  (let [m (count (first board))\n        n (count board)]\n    (letfn [(cell [board x y] (when (and (>= x 0) (>= y 0) (< x m) (< y n)) (nth (nth board y) x)))\n            (alive? [cell] (= cell \\#))\n            (neighbors [board x y] (for [dx [-1 0 1] dy [-1 0 1] :when (not (and (zero? dx) (zero? dy)))]\n                                     (cell board (+ x dx) (+ y dy))))\n            (live-neighbors [board x y] (count (filter alive? (neighbors board x y))))]\n      (vec\n       (for [y (range n)]\n         (apply str (for [x (range m)]\n                      (let [l (live-neighbors board x y)]\n                        (if (alive? (cell board x y))\n                          (if (or (= 2 l) (= 3 l)) \\# \\space)\n                          (if (= 3 l) \\# \\space))))))))))","user":"54c271b9e4b045293a27f602"},{"problem":94,"code":"(fn next-life\n  [board]\n  (let [[height width] [(count board) (count (first board))]\n        board->cells (fn [board]\n                       (into {} (for [i (range height)\n                                      j (range width)]\n                                  [[i j] (get-in board [i j])])))\n        cells-str (fn [cells] (for [i (range height)]\n                                (apply str (for [j (range width)]\n                                             (cells [i j])))))\n        direction (for [i [1 0 -1]\n                        j [1 0 -1]\n                        :when (not= 0 i j)]\n                    [i j])\n        neighbors (fn [cells [i j]]\n                    (->> (map (fn [[dx dy]]\n                                [(+ i dx) (+ j dy)]) direction)\n                         (filter cells)))\n        cell-live? (fn [cells loc]\n                     (let [live-neighbors (->> (neighbors cells loc)\n                                               (filter #(= \\# (cells %)))\n                                               count)]\n                       (if (= 3 live-neighbors)\n                         true\n                         (if (and (= 2 live-neighbors) (= \\# (cells loc)))\n                           true\n                           false))))\n        cell-next (fn [cells loc]\n                    (let [current (cells loc)\n                          step (if (cell-live? cells loc)\n                                 \\#\n                                 \\space)]\n                      (when-not (= current step)\n                        step)))]\n    (let [cells (board->cells board)]\n      (cells-str (apply merge (for [i (range height)\n                                    j (range width)]\n                                (if-let [value (cell-next cells [i j])]\n                                  {[i j] value}\n                                  {[i j] (cells [i j])})))))))","user":"4e586949535d8a8b8723a292"},{"code":"(fn [b]\n  (let [l (count b)\n        k (range l)\n        g #(get-in b % \\_)\n        n #(map (fn [[x y]] (g [(+ % x) (+ %2 y)]))\n                [[-1 -1] [-1 0] [-1 1] [0 -1] \n                 [0 1] [1 -1] [1 0] [1 1]])\n        c #(+ (count (filter #{\\#} (apply n %)))\n              (if (= (g %) \\#) 0.5 0)) \n        r #(cond \n            (<= % 2) \\ \n            (<= % 3.5) \\#\n            1 \\ )]\n    (->>\n     (map (comp r c) (for [i k j k] [i j]))\n     (partition l)\n     (map #(apply str %)))))","problem":94,"user":"4e96557d535dbda64a6f6b43"},{"problem":94,"code":"(fn [rows]\n              (->> (for [x (range (count (first rows)))\n                         y (range (count rows))]\n                     [x y])\n                   (filter (fn [[x y]] (= \\# (nth (nth rows y) x))))\n                   (set)\n                   ((fn [living]\n                      (->> (map (fn [[x y]]\n                                  (for [i [(dec x) x (inc x)]\n                                        j [(dec y) y (inc y)]\n                                        :when (or (not= i x) (not= j y))]\n                                    [i j])) living)\n                           (reduce into)\n                           (frequencies)\n                           (filter (fn [[c n]]\n                                      (cond\n                                        (< n 2) false\n                                        (= n 2) (contains? living c)\n                                        (= n 3) true\n                                        (> n 3) false)))\n                           (keys)\n                           (set))))\n                   ((fn [living]\n                      (for [x (range (count (first rows)))\n                            y (range (count rows))]\n                        (if (contains? living [y x])\n                          \\#\n                          \\space))))\n                   (partition (count rows))\n                   (map #(apply str %))))","user":"5f5358b7e4b0a0bc16850a77"},{"code":"(fn [board]\n  (let [rows (count board), cols (count (seq (first board)))] \n    (map \n    (fn [[r row]] \n      (clojure.string/join\n        (map \n          (fn [[c cell]]\n            (let [ns (for [rr [-1 0 1] cc [-1 0 1] \n                           :let [nr (+ r rr) nc (+ c cc)] \n                           :when (and (>= nr 0) (>= nc 0) (< nr rows) (< nc cols) (not (= [r c] [nr nc])))]\n                       [nr nc] )\n                  cnt (count (filter (fn [coord] (= \\# (get-in board coord))) ns)) ] \n              (if (= \\space cell)   \n                (if (== cnt 3)\n                  \\#\n                  \\space)\n                (if (or (< cnt 2) (> cnt 3)) \n                  \\space\n                  \\#) ))) \n          (keep-indexed vector (seq row))))) \n    (keep-indexed vector board)\n    )))","problem":94,"user":"4dca8b6d535d5973398f9288"},{"code":"(letfn [(k [c x] (<= 0 x c))\n        (g [b c [x y]] (if (and (k c x) (k c y) (= \\# (get-in b [x y]))) 1 0))\n       ]\n  (fn [b]\n    (let [b (vec (map vec b))\n          c (count (first b))\n          g (partial g b c)]\n      (map #(apply str %)\n      (reduce\n        (fn [a k]\n          (let [\n                l\n                (reduce #(+ % (g %2)) 0\n                  (map \n                    #(map + % k)\n                    (for [i (range -1 2) j (range -1 2) :when (or (not= i 0) (not= j 0))] [i j])\n                  )\n                )\n                ? (= 1 (g k))]\n            (assoc-in a k\n              (cond\n                (< l 2) \" \"\n                (and (#{2 3} l) ?) \\#\n                (and (> l 3) ? ) \" \"\n                (and (= l 3) (not ?)) \\#\n                :else\n                  (if ? \\# \" \")\n              )\n            )\n          )\n        )\n        b\n        (for [x (range c) y (range c)] [x y])\n      )))))","problem":94,"user":"4e82f85d535db62dc21a62ce"},{"code":"(fn[a]\n  (let [w (count (a 0))\n        h (count a)]\n    (letfn [(life-at [x y]\n                     (if (and (>= x 0) (>= y 0)\n                              (< x w) (< y h))\n                       (if (= \\# (nth (a y) x)) 1 0)\n                       0))\n            (rules [life n]\n                   (cond\n                     (< n 2) \" \"\n                     (< n 3) (if (= 1 life) \"#\" \" \")\n                     (< n 4) \"#\"\n                     :else \" \"\n                     ))\n            (neighbours [x y]\n                        (rules (life-at x y) (reduce + (for [i (range -1 2) j (range -1 2)]\n                                                         (if (= 0 i j)\n                                                           0\n                                                           (life-at (+ x i) (+ y j)))))))\n            (row [i]\n                 (apply str (map #(neighbours % i) (range w))))]\n      (map row (range h)))))","problem":94,"user":"4ec0c7ba535dfed6da9c6da4"},{"code":"(fn [board]\r\n  (let [\r\n    pattern (for [x (range -1 2) y (range -1 2) :when (not= y x 0)] [x y])\r\n    cell (fn [[x y]] (get (get board x) y))\r\n    ngb (fn [[x y]]\r\n      (map\r\n        (fn [[ox oy]] (cell\r\n          [(mod (+ x ox) (count (first board)))\r\n           (mod (+ y oy) (count board))]))\r\n        pattern))\r\n    ngb-alive (fn [p] (count (filter #{\\#} (ngb p))))\r\n    next-state (fn [cellstatus ngbs]\r\n      (if (= cellstatus \\#)\r\n        (cond \r\n          (< ngbs 2) \" \"\r\n          (> ngbs 3) \" \"\r\n          :else \\#)\r\n        (cond\r\n          (= ngbs 3) \\#\r\n          :else \" \")))]\r\n    (for [x (range (count (first board)))]\r\n      (apply str (for [y (range (count board))]\r\n        (next-state (cell [x y]) (ngb-alive [x y]))\r\n      ))\r\n    )))","problem":94,"user":"5034b0e1e4b062bc5d7ae167"},{"problem":94,"code":"(fn step [board]\n  (letfn [(s3 [arr] (map (partial reduce +)\n                         (partition 3 1 (concat [0] arr [0]))))\n          (life [o1 o9] (if (or (and (= 0 o1) (= 3 o9))\n                                (and (= 1 o1) (#{3 4} o9))) 1 0))\n          (num->str [board] (for [row board] (apply str (map [\" \" \"#\"] row))))]\n    (let [nboard (for [row board] (map {\\# 1 \\space 0} row))]\n      (->> (map s3 nboard)\n           (apply map vector)\n           (map s3)\n           (apply mapcat vector)\n           (map life (flatten nboard))\n           (partition (count (first board)))\n           num->str))))","user":"56102f50e4b05f002753df6b"},{"code":"(fn [board]\n    (let [dx (count (first board))\n          dy (count board)\n          neighbours (fn [pos board]\n                       (let [xs [[-1 -1] [0 -1] [1 -1]\n                                 [-1  0]        [1  0]\n                                 [-1  1] [0  1] [1  1]]]\n                         (count (filter #(= % \\#) \n                                        (map #(get-in board \n                                                      (map + pos %)) xs)))))]\n    (map \n      #(apply str %) \n      (partition \n        dx \n        (for [x (range dx) y (range dy)] \n          (let [n (neighbours [x y] board)\n                live? (= \\# (get-in board [x y]))]\n            (cond \n              (and live? (< n 2)) \\space\n              (and live? (or (= n 2) (= n 3))) \\#\n              (and live? (> n 3)) \\space\n              (and (not live?) (= n 3)) \\#\n              :else \\space)))))))","problem":94,"user":"4dd61f98535d2dad7130b5c6"},{"code":"(fn lifeg-next [board]\r\n  (let [max-h (count board)  max-w (count (first board))]\r\n    (letfn [(init-board [board]\r\n  \t\t(map (fn [line]\r\n\t\t\t       (map (fn [m] (if (= \"#\" m) 1 0))\r\n\t\t\t\t    (re-seq #\".\" line)))\r\n\t\t\t     board))\r\n\t    ]\r\n      (let [cboard (init-board board)\r\n\t    allpoint\r\n\t    (map second\r\n\t\t (group-by first\r\n\t\t\t   (for [x (range 0 max-w)\r\n\t\t\t\t y (range 0 max-h)][x y])))\r\n\t    ]\r\n\t(letfn [\r\n\t\t(getpos [pos]\r\n\t\t\t(let [x (first pos) y (second pos)]\r\n\t\t\t  (if (or (< x 0)(>= x max-w)\r\n\t\t\t\t  (< y 0)(>= y max-h))\r\n\t\t\t    0\r\n\t\t\t    (nth (nth cboard x) y))))\r\n\t\t(make-pos [pos]\r\n\t\t\t  (let [x (first pos)\r\n\t\t\t    y (second pos)]\r\n\t\t\t(disj\r\n\t\t\t (set\r\n\t\t\t  (for [x1 (take 3 (iterate inc (- x 1)))\r\n\t\t\t\ty1 (take 3 (iterate inc (- y 1)))]\r\n\t\t\t    [x1 y1]))\r\n\t\t\t pos)))\r\n\t\t(calc [pos]\r\n\t\t      (let [p (getpos pos)\r\n\t\t\t    e (reduce + (map getpos (make-pos pos)))]\r\n\t\t\t(if (= p 0)\r\n\t\t\t  (if (= e 3) 1 0)\r\n\t\t\t  (if (or (= e 2) (= e 3)) 1 0))\r\n\t\t\t))\r\n\t\t\t\r\n\r\n\t\t]\r\n\r\n\t  (map (fn [line]\r\n\t\t (apply str (map (fn [pos] (let [p (calc pos)] (if (= p 0) \" \" \"#\"))) line)))\r\n\t\t allpoint)\r\n    )))))","problem":94,"user":"4ddc620d535d02782fcbea06"},{"problem":94,"code":"(fn [s]\n  (let [pad (first s)\n        w (count pad)\n        s (map #(map str %) s)\n        blocks (->> s\n                (map #(partition 3 1 %))\n                (apply map list)\n                (map #(partition 3 1 %))\n                (apply map list))]\n    (->> \n     (for [pos blocks nhd pos]\n       (let [alive? (= \"#\" (second (second nhd)))\n             n ((frequencies (flatten nhd)) \"#\")]\n         (if alive?\n           (case n (3 4) \"#\" \" \")\n           (case n 3 \"#\" \" \"))))\n     (partition (- w 2))\n     (map #(-> (flatten [\" \" % \" \"])\n               clojure.string/join))\n     (#(flatten [pad % pad]))\n     )))","user":"56b86e64e4b0f26550335924"},{"problem":94,"code":"(fn [b]\n  (let [board-width (count (first b))\n        board (for [x (range board-width) y (range board-width)] [x y])\n        board-map (zipmap board (->> b (apply str) vec))]\n    (for [r (partition board-width \n      (for [cursor board]\n        (->> (filter (fn [[k v]] (and (contains? #{1 0 -1} (- (first k) (first cursor)))\n                                      (contains? #{1 0 -1} (- (last k) (last cursor)))\n                                      (not= k cursor))) board-map)\n             vals\n             frequencies\n             ((fn [neighbors] (if (or (and (= (get board-map cursor) \\#) (contains? #{2 3} (get neighbors \\#)))\n                                      (and (= (get board-map cursor) \\space) (= 3 (get neighbors \\#)))) \n                                \"#\" \" \"))))))] \n      (clojure.string/join r))))","user":"525c575be4b0cb4875a45d38"},{"code":"(fn life [board]\n  (let [vb (vec (map vec board))\n        rows (count vb)\n        cols (count (vb 0))\n        neighbor-locs\n          (fn [r c]\n            (for [dr [-1 0 1] dc [-1 0 1] :when (not= 0 dr dc)]\n              [(+ r dr) (+ c dc)]))\n        num-live-neighbors\n          (fn [vb r c]\n            (count (filter #(= \\# %) (for [rc (neighbor-locs r c)] (get-in vb rc)))))\n        nextgenlist\n          (fn [vb]\n            (for [r (range rows) c (range cols)]\n              (let [live (num-live-neighbors vb r c)]\n                (cond\n                  (< live 2) \\space\n                  (= live 2) (get-in vb [r c])\n                  (= live 3) \\#\n                  (> live 3) \\space))))]\n    (vec (map #(apply str %) (partition rows (nextgenlist vb))))))","problem":94,"user":"52015698e4b0d7096e99ddba"},{"problem":94,"code":"(fn [m] \n  (let [length (count (first m)) height (count m)\n        around (fn [[y x]] [[y (inc x)][y (dec x)][(inc y) x][(dec y) x][(inc y) (inc x)][(dec y) (dec x)][(inc y) (dec x)][(dec y) (inc x)]])\n        num (fn [pos] (count(filter #(=(get-in m %)\\#) (around pos))))\n        fin (for [y (range height) x (range length)]\n              (let [n (num [y x])]\n                (if (=(get-in m [y x])\\space)\n                  (if (= n 3) \\# \\space)\n                  (if (< 1 n 4) \\# \\space))))]\n    (map #(apply str %) (partition length fin))\n))","user":"5951190be4b066ee0a44aea4"},{"code":"(fn step [board]\n  (let [max-y (count board)\n        max-x (count (first board))]\n    (letfn [(alive? [x y]\n              (and (> y -1)\n                   (> x -1)\n                   (< y max-y)\n                   (< x max-x)\n                   (= \\# (nth (nth board y) x))))]\n      (map #(apply str %)\n           (partition max-x \n                      (for [y (range max-y)\n                            x (range max-x)]\n                        (let [neighbors (count (filter #(apply alive? %)\n                                                       [[(dec x) (dec y)] [x (dec y)] [(inc x) (dec y)]\n                                                        [(dec x) y      ]             [(inc x) y      ]\n                                                        [(dec x) (inc y)] [x (inc y)] [(inc x) (inc y)]]))\n                              self (alive? x y)]\n                          (cond\n                              (< neighbors 2) \" \"\n                              (= neighbors 2) (nth (nth board y) x)\n                              (= neighbors 3) \"#\"\n                              :else \" \"))))))))","problem":94,"user":"4da3e51330acd6ed10482a68"},{"problem":94,"code":"(fn [field]\n  (let [xl (count field)\n        yl (count (first field))\n        at (fn [mx xl yl x y]\n             (count\n              (filter #(not= \\space %)\n                      (for [i [(dec x) x (inc x)]\n                            j [(dec y) y (inc y)] :when (or (not= i x) (not= j y))]\n                        (cond\n                          (or (< i 0) (>= i xl) (< j 0) (>= j yl)) \\space\n                          :else (nth (nth mx i) j))))))]\n    (for [i (range xl)]\n      (apply str\n      (for [j (range yl) :let [p (nth (nth field i) j)\n                               n (at field xl yl i j)]]\n        (if (= p \\space)\n          (if (= n 3) \\# p)\n          (if\n              (or (< n 2) (> n 3)) \\space\n            p)))))))","user":"53ef7f77e4b0742d9025b0ce"},{"code":"(fn game-of-life [b]\n  (let [board (vec (map (comp vec seq) b))\n        xmax (count (board 0))\n        ymax (count board)\n        elem (fn [{:keys [x y board]}] ((board x) y))\n        neighbors (fn [{:keys [x y board]}]\n                    (reduce +\n                            (for [i (range (- x 1) (+ x 2))\n                                  j (range (- y 1) (+ y 2))\n                                  :when (and (not (and (= x i) (= y j)))\n                                             (and (> xmax i) (< -1 i)) \n                                             (and (> ymax j) (< -1 j)))]\n                              (if (= \\space (elem {:x i :y j :board board})) 0 1))))\n        new-state (fn [{:keys [x y board] :as args}]\n                    (let [neigh (neighbors args)\n                          el (elem args)]   \n                      (cond\n                        (and (= \\# el) (> 2 neigh)) \\space\n                        (and (= \\# el) (or (= 2 neigh) (= 3 neigh))) \\#\n                        (and (= \\# el) (< 3 neigh)) \\space\n                        (and (= \\space el) (= 3 neigh)) \\#\n                        :else el)))]\n    (map #(apply str %)\n     (partition xmax\n       (for [i (range xmax) j (range ymax)]\n         (new-state {:x i :y j :board board}))))))","problem":94,"user":"4f50c414e4b03ad3f0c10d0d"},{"code":"(fn gol [w]\n  (let [live \\#\n        dead \\space\n        r (count w)\n        c (if (zero? r) (count w) (count (first w)))\n        neighbours (fn [[a b]]\n                     (for [x [-1 0 1]\n                           y [-1 0 1]\n                           :let [p (+ a x)\n                                 q (+ b y)]\n                           :when (and (<= 0 p)\n                                      (< p r)\n                                      (<= 0 q)\n                                      (< q c)\n                                      (not (and (= p a) (= q b))))]\n                       [p q]))\n        live? (fn [[a b]]\n                (= live (get-in w [a b])))\n        next (fn [[a b]]\n               (let [ns (neighbours [a b])\n                     live-ns-count (count (filter live? ns))\n                     dead-ns-count (- (count ns) live-ns-count)]\n                 (if (live? [a b])\n                   (if (or (= 2 live-ns-count)\n                           (= 3 live-ns-count))\n                     live\n                     dead)\n                   (if (= 3 live-ns-count)\n                     live\n                     dead))))]\n    (map #(apply str %)\n         (partition c (map next (for [x (range r)\n                                          y (range c)]\n                                      [x y]))))))","problem":94,"user":"501c1492e4b086d93747d180"},{"problem":94,"code":"(fn next-board [prev]\n  (let [alive \\#\n        dead \\space\n        cols (count (first prev))\n        rows (count prev)]\n    (letfn [(get-cell [x y]\n              (nth (nth prev y []) x dead))\n            (alive? [c] (= c alive))\n            (adj-cells [x y]\n              (count (filter alive? [(get-cell (- x 1) (- y 1))\n                                     (get-cell x       (- y 1))\n                                     (get-cell (+ x 1) (- y 1))\n                                     (get-cell (- x 1) y)\n                                     (get-cell (+ x 1) y)\n                                     (get-cell (- x 1) (+ y 1))\n                                     (get-cell x       (+ y 1))\n                                     (get-cell (+ x 1) (+ y 1))])))\n            (new-cell-state [c nn]\n              (cond\n                (< nn 2) dead\n                (= nn 2) c\n                (= nn 3) alive\n                (> nn 3) dead))]\n      (let [cells (for [y (range rows) x (range cols)] [x y])\n            neighbors (map #(apply adj-cells %) cells)\n            cell-vals (map #(apply get-cell %) cells)\n            new-board (map\n                        (fn [val neighbors]\n                          (new-cell-state val neighbors))\n                        cell-vals\n                        neighbors)]\n\n        (->>\n          new-board\n          (partition cols)\n          (map #(apply str %)))))))","user":"5a00cb31e4b01bb0ae8afd36"},{"code":"(fn[rows]\n      (letfn [\n      (game-matrix[rows]\n        (let [indices (for [x (range (count rows)) y (range (count (first rows)))] [x y])\n              cells (flatten (for [r rows] (for [c r] (if (= c \\#) :live :dead))))]\n          (apply hash-map (interleave indices cells))))\n      (cell-ranges[matrix]\n        (let [ks (keys matrix)\n              n (inc (apply max (distinct (map first ks))))\n              m (inc (apply max (distinct (map second ks))))]\n          [n m]))\n      (to-strings[matrix]\n        (let [[n m] (cell-ranges matrix)]\n          (loop [ret [] i 0]\n            (if (< i n)\n              (let [a-row (apply str (map (fn[j]\n                             (if (= :live (get matrix [i j])) \\# \\space)) (range m)))]\n                (recur (conj ret a-row) (inc i)))\n              ret))))\n      (neighbours[cell matrix]\n        (let [[i j] cell\n              [n m] (cell-ranges matrix)]\n          (for [x (range (dec i) (+ i 2)) y (range (dec j) (+ j 2))\n                :when (and (not= [x y] [i j]) (>= x 0) (>= y 0) (< x n) (< y m))]\n            [x y])))\n      (live-neighbours-count[cell matrix]\n        (let [n (neighbours cell matrix)\n              states (vals (select-keys matrix n))]\n            (count (filter #(= % :live) states))))\n      (in-next-gen[cell matrix]\n        (let [ln (live-neighbours-count cell matrix)]\n           (if (= (matrix cell) :live)\n             (cond\n               (< ln 2) :dead\n               (< ln 4) :live\n               :else :dead)\n             (if (= ln 3)\n               :live\n               :dead))))]\n           \n       (let [m (game-matrix rows)\n             ks (keys m)\n             m-next-gen (zipmap ks (map (fn[cell] (in-next-gen cell m)) ks))]\n         (to-strings m-next-gen))))","problem":94,"user":"4e58bcd4535d8a8b8723a296"},{"problem":94,"code":"(fn [b]\n  (letfn [(live? [y x] (= (get-in b [y x]) \\#))\n          (count-around [y x]\n            (reduce + (for [ri [-1 0 1] ci [-1 0 1] :when (not (= ri ci 0))] (if (live? (+ y ri) (+ x ci)) 1 0))))\n          (next-live? [y x]\n            (let [c (count-around y x)]\n              (and (or (= c 2) (= c 3)) (or (live? y x) (= c 3)))))]\n    (mapv (fn [y] (apply str (mapv (fn [x] (if (next-live? y x) \\# \\ )) (range (count (b y)))))) (range (count b)))))","user":"5b3f2ba9e4b02d533a91bc09"},{"code":"(fn [bd] (let [h (count bd)\n               w (count (first bd))\n               offs (remove #{[0 0]}  (for [i [-1 0 1] j [-1 0 1]] [i j]))\n               m (zipmap (for [i (range h) j (range w)] [i j])\n                         (for [r bd b r] b))\n               nm (reduce (fn [nm ps]\n                            (assoc nm ps\n                                   (let [ns (map m (map #(map + ps %) offs))\n                                         ns (count (filter #{\\#} ns))]\n                                     (cond (= ns 3) \\#\n                                           (= ns 2) (m ps)\n                                           :else \\space))))\n                          {} (keys m))]\n           (for [i (range h)] (apply str (for [j (range w)] (nm [i j]))))))","problem":94,"user":"519ef784e4b087743fad2198"},{"code":"(fn [b]\n  (let [r (count b)\n        c (count (first b))\n        n (reduce #(%2 %1)\n                  (vec (repeat (+ r 2) (vec (repeat (+ c 2) 0))))\n                  (for [i (range r) j (range c) :when (= \\# (get-in b [i j]))\n                        x [0 1 2] y [0 1 2] :when (not= [1 1] [x y])]\n                    #(update-in % [(+ i x) (+ j y)] inc)))\n        f (comp rest butlast)]\n    (map (fn [r n] (apply str (map\n                                #(condp = %2\n                                   3 \\#\n                                   2 %1\n                                   \\ ) r (f n)))) b (f n))))","problem":94,"user":"52b453b0e4b0c58976d9ad21"},{"code":"(fn [given]\n   (let [vecmap (vec (map (fn [x] (vec (map #(if (= % \\#) 1 0) x))) given))\n         len (count (first vecmap))\n         blank (vec (repeat len 0))\n         lmap (map #(conj (vec (rest %)) 0) vecmap)\n         rmap (map #(cons 0 (vec (drop-last %))) vecmap)\n         makeu (fn [x] (conj (vec (rest x)) blank))\n         maked (fn [x] (cons blank (vec (drop-last x))))\n         maps [lmap rmap (makeu vecmap)\n               (maked vecmap) (makeu lmap)\n               (makeu rmap) (maked lmap)\n         (maked rmap)]]\n         (map-indexed\n          (fn [y row]\n            (String. (char-array (map-indexed\n             (fn [x cell]\n               (let [sum (reduce #(+ %1 (-> %2\n                                            (nth y)\n                                            (nth x)))\n                                 0 maps)]\n                 (cond\n                  (= cell 0) (if (= sum 3) \\# \\space)\n                  (= cell 1) (if (or (= sum 2) (= sum 3)) \\# \\space))))\n             row))))\n          vecmap)))","problem":94,"user":"4eb02674535d7eef30807338"},{"problem":94,"code":"(fn game-of-life [board]\n  (letfn [(row-to-pos [c [i row]]\n            (->> row\n                 (map-indexed vector)\n                 (filter (comp (partial = c) second))\n                 (map (comp (partial conj [i]) first))))\n          (board-to-pos [board c]\n            (->> board\n                 (map-indexed vector)\n                 (map (partial row-to-pos c))\n                 (apply concat)\n                 set))\n          (clear-board [board]\n            (into [] (repeat (count board)\n                             (into [] (repeat (count (first board)) \\space)))))\n          (set-live [next-state [a b]]\n            (update-in next-state [a b] (fn [x] \\#)))\n          (neighbours [[row col :as pos]]\n            (set  (for [del-row [-1 0 1]\n                        del-col [-1 0 1]\n                        :when (not= [del-row del-col] [0 0])]\n                    [(+ row del-row) (+ col del-col)])))]\n    (let [live (board-to-pos board \\#)\n          dead (board-to-pos board \\space)]\n      (letfn [(next-state [board-view valid-populations]\n                (into {}\n                      (filter\n                        #(valid-populations (val %))\n                        (zipmap board-view\n                                (map\n                                  (comp\n                                    count\n                                    (partial clojure.set/intersection live)\n                                    neighbours)\n                                  board-view)))))]\n        (into []\n              (map\n                (partial apply str)\n                (reduce set-live (clear-board board)\n                        (into [] (keys\n                                   (merge (next-state live #{2 3})\n                                          (next-state dead #{3})))))))\n        ))))","user":"572ea970e4b0cd1946bd0f89"},{"problem":94,"code":"(fn next-gen-gof [board]\n\t(let [\tlive-cell \\#\n\t\t  \tdead-cell \\space\n\t\t  \tconvert-to-vectors \t\t(fn [board]\n\t\t\t\t\t\t\t\t\t\t\"Converts vector of strings into vector of vectors of characters\"\n\t\t\t\t\t\t\t\t\t\t(loop [b1 board, result []]\n\t\t\t\t\t\t\t\t\t\t\t(if (empty? b1)\n\t\t\t\t\t\t\t\t\t\t\t\tresult\n\t\t\t\t\t\t\t\t\t\t\t\t(recur (rest b1) (conj result (vec (first b1))))\n\t\t\t\t\t\t\t\t\t\t\t)))\n\t\t  \tgen-indexes \t\t\t(fn [rows columns]\n\t\t\t\t\t\t\t\t\t\t\"Generate map of indexes\"\n\t\t\t\t\t\t\t\t\t\t(for [i (range 0 rows), j (range 0 columns)]\n\t\t\t\t\t\t\t\t\t\t\t{:row i, :col j}\n\t\t\t\t\t\t\t\t\t\t\t))\n\t\t  \tgen-idxs-of-neighbours \t(fn [idx rows columns]\n\t\t\t\t\t\t\t\t\t\t\"Return indexes of 8 neighbours, filter out indexes outside of the board\"\n\t\t\t\t\t\t\t\t\t\t(let [\t{r :row, c :col} idx\n\t\t\t\t\t\t\t\t\t\t\t\tdr (dec r) \n\t\t\t\t\t\t\t\t\t\t\t\tdc (dec c) \n\t\t\t\t\t\t\t\t\t\t\t\tir (inc r) \n\t\t\t\t\t\t\t\t\t\t\t\tic (inc c)\n\t\t\t\t\t\t\t\t\t\t\t\tr1 [{:row dr, :col dc}, {:row dr, :col c}, {:row dr, :col ic},\n\t\t\t\t\t\t\t\t\t\t\t    \t{:row r,  :col dc},                  , {:row r , :col ic},\n\t\t\t\t\t\t\t\t\t\t\t    \t{:row ir, :col dc}, {:row ir, :col c}, {:row ir, :col ic}]\n\t\t\t\t\t\t\t\t\t\t\t\tpred (fn [{r :row, c :col}]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t(cond\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(neg? r) \t\t\tfalse\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(neg? c) \t\t\tfalse\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(> r (dec rows)) \tfalse\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(> c (dec columns)) false\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t:default true))]\n\t\t\t\t\t\t\t\t\t\t\t    (filter pred r1)\n\t\t\t\t\t\t\t\t\t\t\t))\n\t\t\tis-live? \t\t\t \t(fn [c]\n\t\t\t\t\t\t\t\t\t\t(if (= live-cell c) true false))\n\t\t\tget-vals\t\t\t\t(fn [board, indexes]\n\t\t\t\t\t\t\t\t\t\t\"Get values from the board at indexes\"\n\t\t\t\t\t\t\t\t\t\t(loop [idx1 indexes, result []]\n\t\t\t\t\t\t\t\t\t\t\t(if (empty? idx1)\n\t\t\t\t\t\t\t\t\t\t\t\tresult\n\t\t\t\t\t\t\t\t\t\t\t\t(let [{r :row, c :col} (first idx1)\n\t\t\t\t\t\t\t\t\t\t\t\t\t  v ((board r) c)]\n\t\t\t\t\t\t\t\t\t\t\t\t\t  (recur (rest idx1) (conj result v))\n\t\t\t\t\t\t\t\t\t\t\t\t\t))))\n\t\t\thow-many-is-alive\t\t(fn [neighbours]\n\t\t\t\t\t\t\t\t\t\t\"Return count of live cells from input\"\n\t\t\t\t\t\t\t\t\t\t\t(count (filter is-live? neighbours)))\n\t\t\tevolve-for-live \t\t(fn [neighbours]\n\t\t\t\t\t\t\t\t\t\t\"Depending on number of live neighbours evolve actual live-cell according to rules\"\n\t\t\t\t\t\t\t\t\t\t(let [alive (how-many-is-alive neighbours)]\n\t\t\t\t\t\t\t\t\t\t\t(cond\n\t\t\t\t\t\t\t\t\t\t\t\t(< alive 2) \t\t\t\t dead-cell\n\t\t\t\t\t\t\t\t\t\t\t\t(or (= alive 2) (= alive 3)) live-cell\n\t\t\t\t\t\t\t\t\t\t\t\t(> alive 3)\t\t\t\t\t dead-cell)\n\t\t\t\t\t\t\t\t\t\t))\n\t\t\tevolve-for-dead \t\t(fn [neighbours]\n\t\t\t\t\t\t\t\t\t\t\"Depending on number of dead neighbours evolve actual dead-cell according to rules\"\n\t\t\t\t\t\t\t\t\t\t(let [alive (how-many-is-alive neighbours)]\n\t\t\t\t\t\t\t\t\t\t\t(if (= alive 3)\n\t\t\t\t\t\t\t\t\t\t\t\tlive-cell\n\t\t\t\t\t\t\t\t\t\t\t\tdead-cell)\n\t\t\t\t\t\t\t\t\t\t\t))\n\t\t\tevolve-cell \t\t\t(fn [cell neighbours]\n\t\t\t\t\t\t\t\t\t\t\"Evolve the cell depening on type and number of neighbours according to rules\"\n\t\t\t\t\t\t\t\t\t\t(if (is-live? cell)\n\t\t\t\t\t\t\t\t\t\t\t(evolve-for-live neighbours)\n\t\t\t\t\t\t\t\t\t\t\t(evolve-for-dead neighbours)\n\t\t\t\t\t\t\t\t\t\t\t))\n\t\t\tevolve-board\t\t\t(fn [board]\n\t\t\t\t\t\t\t\t\t\t(let [\tvectorized-board\t(convert-to-vectors board)\n\t\t\t\t\t\t\t\t\t\t\t\trows\t\t\t\t(count vectorized-board)\n\t\t\t\t\t\t\t\t\t\t\t\tcolumns\t\t\t\t(count (first vectorized-board))\n\t\t\t\t\t\t\t\t\t\t\t\tindexes \t\t\t(gen-indexes rows columns)]\n\t\t\t\t\t\t\t\t\t\t\t\t(loop [idxs1 indexes, result []]\n\t\t\t\t\t\t\t\t\t\t\t\t\t(if (empty? idxs1)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tresult\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t(let [idx \t\t\t\t(first idxs1)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  r \t\t\t\t(idx :row)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  c \t\t\t\t(idx :col)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  cell \t\t\t\t((vectorized-board r) c)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  idxs-of-neighs \t(gen-idxs-of-neighbours idx rows columns)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  neighbours \t\t(get-vals vectorized-board idxs-of-neighs)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  next-cell\t\t\t(evolve-cell cell neighbours)]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(recur (rest idxs1) (conj result next-cell)))\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t)))) \n\t\t\tnext-board\t\t\t\t(evolve-board board)\n\t\t\tpartitioned-board\t\t(partition (-> board first count) next-board)]\n\t\t(map #(apply str %) partitioned-board)\n))","user":"52cf084ce4b07d0d72b27399"},{"problem":94,"code":"(fn [field]\n    (let [rows (count field)\n          cols (count (first field))\n          m (into {} (for [i (range rows) j (range cols)] [[i j] (get-in field [i j])]))\n          neibs (fn [[i j]] (let [i- (dec i) i+ (inc i) j- (dec j) j+ (inc j)]\n                                 (->> [[i- j-] [i- j] [i- j+]  [i j-] [i j+] [i+ j-] [i+ j] [i+ j+]]\n                                      (map #(m %))\n                                      (filter #(= \\# %))\n                                      (count) )))\n          new-st (fn [p] (let [n (neibs p)] (if (not= \\# (m p)) (if (= n 3) \\# \\space) (if (<= 2 n 3) \\# \\space))))\n          f+ (map (fn [i] (map (fn [j] (new-st [i j])) (range cols))) (range rows))]\n  (mapv #(apply str %) f+) ))","user":"5a4de614e4b05d388ecb6bb1"},{"code":"(fn [board]\n  (let [x-dim (count board)\n        y-dim (count (first board))\n        felder (for [i (range x-dim) j (range y-dim)] [i j])\n        neighbours (into []\n                         (map \n                          (fn [[x y :as feld]] \n                            [feld \n                             (disj \n                              (into #{} (filter (fn [[x y]] (and (>= x 0) (< x x-dim) (>= y 0) (< y y-dim)))\n                                                (for [x' (range (- x 1) (+ x 2))\n                                                      y' (range (- y 1) (+ y 2))]\n                                                  [x' y'])))\n                              feld)])\n                          felder))\n        nr-neighbours    (map (fn [[feld nachbarn]]\n                                [feld\n                                 (count \n                                  (for [nachbar-feld nachbarn\n                                        :when (= (get-in board nachbar-feld) \\#)]\n                                    true))])\n                              neighbours)\n        new-generation  (map (fn [[feld nr-neighbours]]\n                               (let [current-feld-value (get-in board feld)]\n                                 (cond\n                                  (and (= current-feld-value \\#) (< nr-neighbours 2)) \\space\n                                  (and (= current-feld-value \\#) (> nr-neighbours 3)) \\space\n                                  (and (= current-feld-value \\space) (= nr-neighbours 3)) \\#\n                                  :else current-feld-value)))\n                             nr-neighbours)]\n    (into [] (map #(apply str %) (partition x-dim new-generation)))))","problem":94,"user":"50ef9a7ae4b0bdaecbb47d9e"},{"code":"(fn conway [state]\n  (let [state  (mapv vec state)\n        width  (count state)\n        height (count (first state))]\n    (map (partial apply str)\n         (reduce\n          (fn [next-state [y x]]\n            (assoc-in next-state [y x]\n             (case (->> (for [dx [-1 0 1]\n                              dy [-1 0 1]\n                              :when (not= 0 dx dy)]\n                          [(+ y dy) (+ x dx)])\n                        (map (partial get-in state))\n                        (filter #{\\#})\n                        count)\n               2 (get-in state [y x])\n               3 \\#\n               \\space)))\n          state\n          (for [y (range height)\n                x (range width)]\n            [y x])))))","problem":94,"user":"532ab0bde4b09d4e7a9b5527"},{"code":"(fn [f]\n  (let [f (vec (map (fn [r] (vec (map #(case % \\# 1 \\space 0) r))) f))\n        l (vec (map #(rest (conj % 0)) f))\n        r (vec (map #(cons 0 %) f))\n        us (map #(rest (conj % (repeat 0))) [l f r])\n        ds (map #(cons (repeat 0) %) [l f r])\n        n (apply map (partial map +) (concat [l r] us ds))]\n    (vec (map (fn [f n]\n            (->> (map (fn [f n] (case n 2 f 3 1 0)) f n)\n                 (map #(case % 1 \\# 0 \\space))\n                 (apply str)))\n         f n))))","problem":94,"user":"50c9e5e3e4b0a409464667d7"},{"code":"(fn [b]\n(letfn [(neighbours [[x y]] \n          (for [dx [-1 0 1] dy [-1 0 1] :when (not= 0 dx dy)] \n            [(+ dx x) (+ dy y)]))\n        (step [cells]\n          (set (for [[loc n] (frequencies (mapcat neighbours cells))\n             :when (or (= n 3) (and (= n 2) (cells loc)))]\n               loc)))\n        (lives [s]\n         (let [w (count s)\n               h (count (first s))]\n           (for [i (range w) j (range h) :when (= \\# (get-in s [i j]))] [i j])))\n        (populate [s]\n          (map #(apply str %)\n            (reduce #(assoc-in (vec (map vec %)) %2 \\#) \n                    (repeat (count b) (apply str (repeat (count (first b)) \" \"))) s)))]\n  (-> b (lives) (set) (step) (populate))))","problem":94,"user":"4fdb02aae4b05e33b9224f56"},{"problem":94,"code":"(fn __ [s]\n  (letfn [(string-list->board [sl]\n            (map #(map {\\space 0 \\# 1} %) sl))\n          (board->string-list [board]\n            (apply vector (map #(apply str (map {0 \\space 1 \\#} %)) board)))\n          (neighbours [cell board]\n            (let [[i j] cell]\n              (filter #(and (>= (first %) 0)\n                            (>= (second %) 0)\n                            (< (first %) (count board))\n                            (< (second %) (count (nth board (first %)))))\n                      [[(dec i) (dec j)] [(dec i) j] [(dec i) (inc j)]\n                       [i (dec j)] [i (inc j)]\n                       [(inc i) (dec j)] [(inc i) j] [(inc i) (inc j)]])))\n          (live? [cell board]\n            (let [[i j] cell]\n              (-> board\n                (nth i)\n                (nth j)\n                (= 1))))\n          (num-live-neighbours [cell board]\n            (count (filter identity (map #(live? % board) (neighbours cell board)))))\n          (next-state\n            ([board]\n              (for [i (range (count board))]\n                (for [j (range (count (nth board i)))]\n                  (next-state [i j] board))))\n            ([cell board]\n              (let [[i j] cell\n                    old-state (nth (nth board i) j)\n                    nn (num-live-neighbours cell board)]\n                (cond\n                  (< nn 2) 0\n                  (= nn 2) old-state\n                  (= nn 3) 1\n                  true 0))))]\n    (->\n    (string-list->board s)\n    (next-state)\n    (board->string-list))))","user":"502a5e59e4b09e8f859a9fbc"},{"problem":94,"code":"(fn [board]\n  (let [s (count board)]\n    (mapv #(apply str %)\n          (partition \n           s\n           (reduce (fn [acct [x y :as n]]\n                     (let [self (get-in board [x y])\n                           neibours \n                           (->>\n                            (for [u (range (- x 1) (+ x 2))\n                                  v (range (- y 1) (+ y 2))]\n                              [u v])\n                            (filter #(not= % [x y]))\n                            (map #(get-in board %))\n                            (frequencies))]\n                       (conj acct\n                             ;;next live...\n                             (if (= self \\#)\n                               ;;if live cell, check for death\n                               (cond\n                                 (< (neibours \\#) 2) \\space\n                                 (> (neibours \\#) 3) \\space\n                                 :else self)\n                               ;;if dead cell, check for reproduction\n                               (if (= 3 (neibours \\#))\n                                 \\#\n                                 self)))))\n                   []\n                   (for [x (range s) y (range s)] [x y]))))))","user":"57a5da5ee4b0a966079561fe"},{"code":"(fn al [x]\n  (let [c\n  (fn [x] (map (fn [l] (map {\\space 0 \\# 1} l)) x))\n\ts (fn [x] (map (fn [l] (apply str (map {false \\space 0 \\space 1 \\# true \\#} l))) x))\n\tl (fn [x] (map (fn [l] (concat (rest l) [0])) x))\n\tr (fn [x] (map (fn [l] (concat [0] l)) x))\n\tu (fn [x] (concat (rest x) [(map (constantly 0) (first x))]))\n\td (fn [x] (concat [(map (constantly 0) (first x))] x))\n\ty (c x)]\n    (s (map\n\t      (partial map #(or (and (= %1 1) (or (= %2 2) (= %2 3)))\n\t\t\t\t(and (= %1 0) (= %2 3))))\n\t      y\n\t      (map (partial map +)\n\t\t  (l y) (r y)\n\t\t  (u y) (d y)\n\t\t  (l (u y)) (l (d y))\n\t\t  (r (u y)) (r (d y)))))))","problem":94,"user":"4e14108c535d04ed9115e7dd"},{"code":"(fn __ [board]\n  (let [pos-map (into {}\n                      (map (fn [[k v]] [k (into #{} (map second v))])\n                           (group-by first\n                                     (for [i (range (count board))\n                                           j (range (count (first board)))]\n                                       [(get-in board [i j]) [i j]]))))\n        live-cells (pos-map \\#)\n        num-rows (count board)\n        num-cols (count (first board))\n        blank (into [] (repeat num-rows\n                               (into [] (repeat num-cols \\space))))]\n    (letfn [(directions-from [[x y]]\n              [[(inc x) y] [(dec x) y] [x (inc y)] [x (dec y)]\n               [(inc x) (inc y)] [(dec x) (dec y)] [(dec x) (inc y)] [(inc x) (dec y)]])\n            (count-live-neighbors [pos]\n              (count (filter (partial contains? live-cells)\n                             (directions-from pos))))]\n      (->> (for [i (range num-rows)\n                 j (range num-cols)\n                 :let [pos [i j]\n                       is-live? (contains? live-cells pos)\n                       n (count-live-neighbors pos)]\n                 :when (if is-live? (contains? #{2 3} n) (= n 3))]\n                 [pos \\#])\n           (reduce (partial apply assoc-in)\n                   blank)\n           (map #(apply str %))))))","problem":94,"user":"50812debe4b01a93d3f38e4c"},{"problem":94,"code":"(fn game-of-life [board]\n  (let [board (mapv #(mapv str %) board)]\n    (letfn [(cell [i j] (get (get board i) j))\n            (live [c] (when (= \"#\" c) c))\n            (dead [c] (when (= \" \" c) c))\n            (neighbours [i j]\n              (keep (partial apply cell)\n                    [[(dec i) (dec j)]\n                     [(dec i) j]\n                     [(dec i) (inc j)]\n                     [i (inc j)]\n                     [(inc i) (inc j)]\n                     [(inc i) j]\n                     [(inc i) (dec j)]\n                     [i (dec j)]]))\n            (update-in [b [i j] f]\n              (assoc b i (assoc (get b i) j (f (cell i j)))))\n            (update-cell [b [i j]]\n              (update-in\n                b\n                [i j]\n                #(let [live-num (count (keep live (neighbours i j)))]\n                   (cond\n                     (dead %) (if (== 3 live-num) \"#\" \" \")\n                     (< live-num 2) \" \"\n                     (< live-num 4) \"#\"\n                     :else \" \"))))]\n      (mapv\n        #(reduce str %)\n        (reduce\n          update-cell\n          board\n          (for [i (range (count board))\n                j (range (count (first board)))]\n            [i j]))))))","user":"5f300f28e4b033932238a682"},{"problem":94,"code":"(fn [board]\n      (let [squares (vec (map \n                           (comp vec seq) \n                           board))\n            rows (count squares)\n            cols (count (first squares))\n            val-of (fn [[r c]] ((squares r) c))\n            alive? (fn [r c] (= (val-of [r c]) \\#))\n\n            num-live (fn [ro co]\n                        (count\n                          (filter (fn [[a b]] (and\n                                          (< -1 a rows)\n                                          (< -1 b cols)\n                                          (alive? a b )))\n                           (for [i [-1 0 1] j [-1 0 1] :when (not= i j 0)]\n                             [(+ i ro) (+ j co)]))))\n           \n            rule (fn [ro co]\n                   (let [neighs (num-live ro co)]\n                    (if \n                      (if (alive? ro co)\n                        (or (= neighs 2) (= neighs 3))\n                        (= neighs 3))\n                      \\#\n                      \\ )))\n\n            next-board (vec\n                        (for [r (range rows)]\n                          (apply str\n                            (for [c (range cols)]\n                              (rule r c)))))]     \n        next-board))","user":"56194c11e4b053970a773af4"},{"code":"(fn [board]\n  (let [height (count board)\n        width (count (first board))\n        live? (fn [[x y]] (= \\# ((vec (board x)) y)))\n        neighbors (fn [[x y]] (for [[i j] [[1 0] [1 1] [0 1] [-1 1] [-1 0] [-1 -1] [0 -1] [1 -1]]\n                                    :let [x' (+ x i) y' (+ y j)]\n                                    :when (and (>= x' 0) (< x' height) (>= y' 0) (< y' width))] [x' y']))\n        live-neighbors-count (fn [coord] (count (filter live? (neighbors coord))))\n        evolve-cell (fn [coord] (let [live-count (live-neighbors-count coord)]\n                                  (cond\n                                    (< live-count 2) \\space\n                                    (= live-count 2) (if (live? coord) \\# \\space)\n                                    (= live-count 3) \\#\n                                    :else \\space)))]\n    (for [i (range height)] (apply str (for [j (range width)] (evolve-cell [i j]))))))","problem":94,"user":"4e9519b4535dbda64a6f6b2d"},{"problem":94,"code":"(fn step [m]\n  (letfn [(nscore [m i j]\n            (let [p {\" \" 0 \"#\" 1}\n                  q (dec i)\n                  w (inc i)\n                  e (dec j)\n                  r (inc j)\n                  n [[q e] [q j] [q r] [i e] [i r] [w e] [w j] [w r]]\n                  c (count m)\n                  o (filter (fn [[a b]] (and (<= 0 a) (<= 0 b) (> c a) (> c b))) n)]\n              (reduce + (map #(get p (str (get-in m %))) o))))\n\n          (conway [m]\n            (for [i (range 0 (count m))\n                  j (range 0 (count m))\n                  :let [e (get-in m [i j])\n                        s (nscore m i j)]]\n              (cond\n                (and (= e \\#) (<= s 1)) \" \"\n                (and (= e \\#) (<= s 3)) \"#\"\n                (and (= e \\#) (>= s 4)) \" \"\n                (and (= e \\space) (= s 3)) \"#\"\n                :else e)))]\n    (for [i (partition (count m) (conway m))]\n      (apply str i))))","user":"5659679ae4b068f2fe63dbeb"},{"problem":94,"code":"(fn [board]\n  (let [neighbours (fn [[x y]]\n                     (for [dx [-1 0 1]\n                           dy [-1 0 1]\n                           :when (not= 0 dx dy)]\n                       [(+ x dx) (+ y dy)]))\n\n        step (fn [cells]\n               (set (for [[loc n] (frequencies (mapcat neighbours cells))\n                          :when (or (= n 3) (and (= n 2) ((set cells) loc)))]\n                      loc)))\n\n        line (fn [width s]\n               (apply str (map #(if (s %) \\# \\space) (range 0 width))))\n\n        lines (fn [hight width cells]\n                (map #(->> (get (group-by first cells) % [])\n                           (map second)\n                           set\n                           (line width))\n                     (range 0 hight)))]\n    (->> (keep-indexed #(keep-indexed\n                         (fn [n x] (if (= x \\#) [% n] nil)) %2)\n                       board)\n         (apply concat [])\n         step\n         (lines (count board) (count (first board))))))","user":"5504dd64e4b086ebe8a79c83"},{"problem":94,"code":"(fn [data]\n  (letfn [(d-coll [coord]\n            (for [x (range -1 2) y (range -1 2)\n                  :when (not= 0 x y)\n                  :let [d (map + [x y] coord) ch (get-in data d)]]\n              (if (= ch \\#) 1 0)))\n          (decide [r-i c-i ch]\n            (condp #(%1 %2) (->> [r-i c-i] d-coll (apply +))\n              #(and (= ch \\#) (< % 2)) \\space\n              #(and (= ch \\#) (#{2 3} %)) \\#\n              #(and (= ch \\#) (> % 3)) \\space\n              #(and (= ch \\space) (= % 3)) \\#\n              ch))]\n    (->> data\n         (map-indexed #(map-indexed (partial decide %1) %2))\n         (map #(apply str %)))))","user":"567d132ee4b05957ce8c61c3"},{"problem":94,"code":"(fn [m]\n  (let [world (into #{} (flatten\n                         (keep-indexed\n                          (fn [i row]\n                            (keep-indexed #(if (= \\# %2) {% i}) row)) m)))\n        field-size (count m)]\n    (letfn [(gen-world []\n              (for [x (range field-size)\n                    y (range field-size)]\n                [x y]))\n            (get-neighborhood-of [x y]\n              (let [scope [-1 0 1]]\n                (for [[nx ny] [[-1 -1] [-1 0] [-1 1] [0 -1] [0 1] [1 -1] [1 0] [1 1]]]\n                  [(+ x nx) (+ y ny)])))\n            (alive? [x y]\n              (contains? world {x y}))\n            (count-living-neighbours [x y]\n              (count (filter (fn [[x y]] (alive? x y)) (get-neighborhood-of x y))))\n            (will-be-alive? [x y]\n               (let [nr (count-living-neighbours x y)]\n                 (or (= 3 nr) (and (= 2 nr) (alive? x y)))))\n            (next-step []\n              (into #{} (remove empty? (for [[x y] (gen-world)]\n                                         (if (will-be-alive? x y) [x y])))))\n            (draw-world [set-of-cells]\n              (let [r (range 0 field-size)]\n                (for [y r] (apply str (for [x r] (if (set-of-cells [x y]) \\# \\ ))))))]\n      (into [] (draw-world (next-step))))))","user":"55b22c33e4b0da326a65cf79"},{"code":"(fn [b]\n  (let [c (count (nth b 0))\n        d (count b)] \n    (->>\n     (for [y (range d)\n           x (range c)\n           :let [i (nth (nth b y) x)\n                 n (max 0 (- y 1))\n                 e (min c (+ x 2))\n                 s (min d (+ y 2))\n                 w (max 0 (- x 1))\n                 sub (map\n                       #(subs % w e)\n                       (subvec b n s))\n                 a (reduce #(if (= %2 \\#) (+ % 1) %) (if (= i \\#) -1 0) (apply str sub))\n                 ]]\n       (if (= i \\#)\n         (cond\n           (< a 2) \\space\n           (< a 4) \\#\n           1 \\space)\n         (if (= a 3) \\# \\space)))\n     (partition c)\n     (map #(apply str %))\n     vec\n     )))","problem":94,"user":"51b3f109e4b0f094dd986fa9"},{"problem":94,"code":"(fn __ [board]\n  (let [\n        b (count board)\n        circle-idx\n        (fn\n          [x y]\n          (for [i [-1 0 1]\n                j [-1 0 1]\n                :when (and\n                       (not (and (= i 0) (= j 0)))\n                       (< -1 (+ i x) b)\n                       (< -1 (+ j y) b))]\n            [(+ x i) (+ y j)]))\n        ]\n    (->>\n     (for [i (range 0 b)\n           j (range 0 b)]\n       (let [neighbours (map #(get-in board %) (circle-idx i j))\n             num (count (filter (partial = \\#) neighbours))\n             me (get-in board [i j])]\n         (if (= \\# me)\n           (cond ; alive\n            (< num 2) \\space\n            (<= num 3) me\n            (> num 3) \\space)\n           (if (= num 3) \\# \\space))))\n     (partition b)\n     (map #(apply str %))\n     (vec))\n    ))","user":"5a0ce1a5e4b04bbd27e6d9b7"},{"problem":94,"code":"(fn [board]\n  (let [x-max (count (first board))\n        y-max (count board)\n        neighbors (fn [x y]\n                    (reduce #(if (= %2 \\#) (inc %) %)\n                            0\n                            (for [i (range (max 0 (dec x))\n                                          (inc (min x-max (inc x))))\n                                 j (range (max 0 (dec y))\n                                          (inc (min y-max (inc y))))\n                                 :when (or (not= i x) (not= j y))]\n                             (get-in board [j i]))))\n        live (fn [n]\n               (cond (< n 2) \" \"\n                     (< n 4) \"#\"\n                     :else \" \"))\n        dead (fn [n] (if (= 3 n) \"#\" \" \"))]\n    (for [y (range y-max)]\n      (apply str\n             (for [x (range x-max)]\n               ((if (= (get-in board [y x]) \\#) live dead)\n                (neighbors x y)))))))","user":"5078d366e4b08327cd804a5b"},{"problem":94,"code":"(fn next-gen [b]\n  (map clojure.string/join\n    (let [board (vec (for [row b] (vec row))) rows (count board) cols (count (first board))]\n      (loop [pos [0 0] result board]\n      \n        (if (>= (first pos) rows)\n          result\n          (let [\n            cell (get-in b pos)\n            row (first pos)\n            col (last pos)\n            next-pos [\n                      (if (= col (dec cols)) (inc row) row)\n                      (if (= col (dec cols)) 0 (inc col))\n                     ]\n            neighbour-coords [\n                              [(dec row) (dec col)] \n                              [(dec row) col]\n                              [(dec row) (inc col)] \n                              [row (dec col)] \n                              [row (inc col)] \n                              [(inc row) (dec col)] \n                              [(inc row) col]\n                              [(inc row) (inc col)] \n                             ]\n            alive-neighbours (reduce \n                        (fn [counter coord]\n                           (if (= \\# (get-in board coord)) (inc counter) counter)\n                        ) \n                      0 neighbour-coords)\n            ]\n          \n            (recur next-pos\n              (assoc-in result pos\n                (cond\n                  (and (= cell \\space) (= alive-neighbours 3)) \\#\n                  (and (= cell \\#) (< alive-neighbours 2)) \\space\n                  (and (= cell \\#) (> alive-neighbours 3)) \\space\n                  :else\n                    cell\n                )\n              )\n            )\n          )\n        )\n      )\n    )\n  )\n)","user":"5991d2fae4b0866487ed0d68"},{"code":"(fn [m t h s g]\n     (let [c (t g)\n           o [-1 0 1]\n           r (range c)\n           n (remove #{[0 0]} (for [a o b o] [a b]))\n           v (mapv vec g)]\n       (->> (for [x r\n                  y r]\n               {[x y] (t (keep (comp #{h} #(get-in v (m + [x y] %))) n))})\n            (apply merge-with +)\n            (reduce (fn [x [i c]]\n                      (update-in x i \n                                 #(if (#{h} %)\n                                     (if (#{2 3} c)\n                                        h\n                                        s)\n                                     (if (= 3 c)\n                                        h\n                                        s))))\n                    v)\n            (m #(apply str %)))))\n   map count \\# \\space","problem":94,"user":"4e823ed7535db62dc21a62c7"},{"code":"#(let [rows (count %)\n       cols (count (first %))]\n  (letfn [(board-to-set [board] \n            (->> (for [row (range rows)\n                       col (range cols)]\n                   (when (= (nth (nth board row) col) \\#)\n                     [row col]))\n                 (filter identity)\n                 (into #{})))\n          (set-to-board [cells]\n            (for [row (range rows)]\n              (clojure.string/join\n                (for [col (range cols)] \n                  (if (cells [row col]) \\# \\space)))))\n          (neighbors [cells row col]\n            (reduce +\n              (for [row-offset [-1 0 1]\n                   col-offset [-1 0 1]\n                   :when (not (= row-offset col-offset 0))]\n               (if (cells [(+ row row-offset) (+ col col-offset)])\n                 1 0))))\n          (advance [cells]\n            (->> (for [row (range rows)\n                       col (range cols)]\n                   (let [live (neighbors cells row col)]\n                     (if (or (= 3 live)\n                             (and (= 2 live)\n                                  (cells [row col])))\n                       [row col])))\n                 (filter identity)\n                 (into #{})))]\n    (-> % board-to-set advance set-to-board)))","problem":94,"user":"4fce5474e4b0d4b2a7a9d451"},{"problem":94,"code":"(fn gol [board]\n  (let [empty-line (apply str (repeat (count (first board)) \\space))\n        pad-line (fn [s] (str \" \" s \" \"))\n        mmap (fn [f m] (map (partial map f) m))\n        analyze\n        (fn [s]\n          (let [alive (= (nth s 4) \\#)\n                neighbors* (count (filter (partial = \\#) s))\n                neighbors (if alive (dec neighbors*) neighbors*)]\n            (if (or\n                 (and alive\n                      (< 1 neighbors 4))\n                 (and (not alive)\n                      (= neighbors 3)))\n              \\#\n              \\space)))]\n    (->> (concat [empty-line] board [empty-line])\n         (map pad-line ,,,)\n         (partition 3 1 ,,,)\n         (mmap (partial partition 3 1) ,,,)\n         (mmap (partial map (partial apply str)) ,,,)\n         (map (partial apply interleave) ,,,)\n         (map (partial partition 3) ,,,)\n         (mmap (partial apply str))\n         (mmap analyze)\n         (map (partial apply str)))))","user":"5b7f2d75e4b047b03b203768"},{"problem":94,"code":"(fn [world]\n    (let [reproduce (fn [x y]\n                      (let [neighbours (for [i [-1 0 1]\n                                             j [-1 0 1]\n                                             :when (not= [i j] [0 0])]\n                                         [(+ i x) (+ j y)])\n                            current (get-in world [x y])\n                            live-cells (->> (map #(get-in world %) neighbours)\n                                            (filter #(= % \\#))\n                                            count)]\n                        (if (if (= current \\#)\n                              (<= 2 live-cells 3)\n                              (= live-cells 3))\n                          \\#\n                          \\space)))\n          h (count world)\n          w (count (first world))]\n      (->> (for [i (range 0 h) j (range 0 w)] [i j])\n           (map #(reproduce (first %) (second %)))\n           (partition w)\n           (mapv #(apply str %)))))","user":"523ed522e4b057c4b7cd0a78"},{"code":"(fn neigh[original]\n  (let [b (vec (map vec original))\n        neighs (fn [i j] (count (filter #(= % \\#) (for [r_x (range 3) r_y (range 3) :let [x (dec r_x) y (dec r_y)]] (-> b (nth (+ i x)) (nth (+ j y)))))))\n  changes     (filter #(not (nil? %)) (for [x (range 1 (dec (count b))) y (range 1 (dec (count (first b))))]\n\t\t      (let [num (neighs x y)]\n\t\t\t(if (= (-> b (nth x) (nth y)) \\#)\n\t\t\t  (if (or (< num 3) (> num 4)) \n\t\t\t    [x y]\n\t\t\t  )\n\t\t\t  (if (or (= num 3))\n\t\t\t    [x y]\n\t\t\t  )\n\t\t\t)\n\t\t      )\n\t\t    ))\n        ]\n          (vec (map #(apply str %) \n\t    (loop [to-apply changes\n\t\t   result b\n\t\t  ]\n\t      (if (empty? to-apply)\n\t\tresult\n\t\t(if (= (get-in result (first to-apply)) \\#)\n\t\t  (recur (rest to-apply) (assoc-in result (first to-apply) \\space))\n\t\t  (recur (rest to-apply) (assoc-in result (first to-apply) \\#))\n\t\t)\n\t      )\n\t    )\n          ))\n  )\n)","problem":94,"user":"4e9de526535dbda64a6f6b8e"},{"code":"(fn [board]\r\n  (let [width (count (first board)) height (count board)\r\n        states (map (fn [c] (if (= c \\#) 1 0)) (apply concat board))]\r\n    (letfn [(split-every [n l]\r\n              (if (empty? l)\r\n                nil\r\n                (let [[x y] (split-at n l)]\r\n                  (cons x\r\n                        (split-every n y)\r\n                        ))))\r\n            (gen-new-board [new-states]\r\n              (vec \r\n               (map\r\n                (fn [row] (apply str\r\n                                 (map (fn [c] (if (= c 1) \\# \\space)) row)))\r\n                (split-every width new-states))))\r\n            (index-to-xy [i]\r\n              [(quot i width) (rem i width)])\r\n            (xy-to-index [i]\r\n              (+ (* (first i) width) (second i)))\r\n            (valid-xy [i]\r\n              (and (<= 0 (second i) (dec width))\r\n                   (<= 0 (first i) (dec height))))\r\n            (live-neighbor-count-of-cell [n]\r\n              (let [[x y] (index-to-xy n)]\r\n                (apply + (map (fn [z] (nth states (xy-to-index z)))\r\n                              (filter valid-xy (list [(dec x) (dec y)][(dec x) y][(dec x) (inc y)]\r\n                                                     [x (dec y)] [x (inc y)]\r\n                                                     [(inc x) (dec y)][(inc x) y][(inc x) (inc y)]))))))\r\n              ]\r\n      (gen-new-board (map-indexed (fn [i o]\r\n                                    (let [c (live-neighbor-count-of-cell i)]\r\n                                      (if (or (and (= o 1) (<= 2 c 3))\r\n                                              (and (= o 0) (= c 3)))\r\n                                        1 0))) states)))))","problem":94,"user":"4f474f43e4b0d56e7bb92bb7"},{"problem":94,"code":"(fn life [board]\n  (let [dy (count board)\n        dx (count (first board))\n        cell (fn [x y] (get-in board [y x]))\n        neighbors (fn [x y]\n                    (frequencies\n                     ; ([-1 -1] [-1 0] [-1 1] [0 -1] [0 1] [1 -1] [1 0] [1 1])\n                     (for [a (range -1 2)\n                           b (range -1 2) :when (not= 0 a b)]\n                       (cell (+ x a) (+ y b)))))\n        nextgen (fn [x y]\n                  (let [n (neighbors x y)\n                        live (= (cell x y) \\#)\n                        live-neighbors (n \\#)\n                        dead-neighbors (n \\space)]\n                    (cond\n                      (and live (< live-neighbors 2)) \\space\n                      (and live (< live-neighbors 4)) \\#\n                      live \\space\n                      (= live-neighbors 3) \\#\n                      :else \\space)))]\n     (map\n      (fn [y] (apply str\n                    (map #(nextgen % y) (range dx))))\n       (range dy))))","user":"571d063ee4b0145328a76272"},{"problem":94,"code":"(fn next-gen [board]\n  (letfn [(adjacent [i j]\n                   (for [ix (range (- i 1) (+ i 2))\n                         jx (range (- j 1) (+ j 2))\n                         :when (not= [ix jx] [i j])]\n                     (list ix jx)))\n          (get-cell [i j]\n            (get (get board i) j))\n          (adjacent-cells [i j]\n            (map #(get-cell (first %) (second %)) (adjacent i j)))\n          (count-live [i j]\n            (count (filter #(= \\# %) (adjacent-cells i j))))\n          (next-state [i j val]\n            (let [c (count-live i j)]\n              (if (= val \\#)\n                (cond\n                  (< c 2) \\space\n                  (or (= c 2) (= c 3)) \\#\n                  (> c 3) \\space)\n                (cond\n                  (= c 3) \\#\n                  :default \\space))))]\n    (for [ix (range (count board))]\n      (apply str (map-indexed #(next-state ix %1 %2) (get board ix))))))","user":"587ee260e4b052da650a6353"},{"code":"(fn[b]\r\n  (let [n (count b)\r\n        g (fn [x y] \r\n           (if (and (< -1 x n) (< -1 y n)) \r\n            (nth (nth b x) y)  \\space ))\r\n        c (fn [x y]\r\n            (count (filter #(= \\# %)\r\n              [(g (inc x) (inc y)) (g x (inc y)) (g (dec x) (inc y)) (g (dec x) y)\r\n               (g (dec x) (dec y)) (g x (dec y)) (g (inc x) (dec y)) (g (inc x) y)])))]\r\n  (map #(apply str %) (partition n\r\n    (for [x (range n) y (range n)]\r\n      (let [a (= \\# (g x y))\r\n            c (c x y)]\r\n        (cond \r\n          (false? a) (if (= c 3) \\# \\space)\r\n          (< c 2) \\space\r\n          (<= 2 c 3) \\#\r\n          (> c 3) \\space)))))))","problem":94,"user":"4deff9f9535d08e6dec9fe15"},{"problem":94,"code":"(fn next-game [[& rows :as board]]\n  (map #(apply str %) (letfn [(seq-of-indices []\n                     (keep identity (mapcat identity\n                                            (for [i (range -1 2)]\n                                              (for [j (range -1 2)]\n                                                (if (not (and (zero? i) (zero? j)))\n                                                  [i j]))))))]\n             (let [vec-board (vec (map vec rows))\n                   dead \\space live \\#\n                   offsets (seq-of-indices)]\n               (map-indexed (fn [row-index row]\n                              (map-indexed #(let [live-neighbor-amt (count (filter (fn [cell]  (= live cell))\n                                                                                   (for [coord-offset offsets]\n                                                                                     (get-in vec-board (map + [row-index %] coord-offset) dead))))] ;assuming edge is dead\n                                              (cond (< live-neighbor-amt 2) dead\n                                                    (> live-neighbor-amt 3) dead\n                                                    (and (= dead %2) (= live-neighbor-amt 3)) live\n                                                    :live-cell-with-2-or-3-neighbors %2))\n                                           row))\n                            vec-board)))))","user":"58f2e8fbe4b0438e51c2ce94"},{"problem":94,"code":"(fn next [rows]\n  (let [height     (count rows)\n        width      (count (first rows))\n        lives      (into #{}\n                         (apply concat\n                                (map-indexed\n                                 (fn [r s]\n                                   (->> s\n                                        (map-indexed #(if (= \\# %2) %1))\n                                        (filter number?)\n                                        (map #(conj [r] %))))\n                                 rows)))\n        dead?      (fn [x y] (nil? (some #(= [x y] %) lives)))\n        neighbours (fn [x y]\n                     (count (filter (fn [[r c]]\n                                      (and (<= (dec x) r (inc x))\n                                           (<= (dec y) c (inc y))\n                                           (not (= [r c] [x y]))))\n                                    lives)))]\n    (for [x (range height)]\n      (apply str\n             (for [y    (range width)]\n               (let [neighbours (neighbours x y)\n                     dead?      (dead? x y)\n                     live?      (not dead?)]\n                 (println x y dead? neighbours)\n                 (cond (and dead? (= neighbours 3)) \"#\" ; reproduction\n                       (and live? (< neighbours 2)) \" \" ; under-population\n                       (and live? (> neighbours 3)) \" \" ; over-crowding\n                       live?                        \"#\" ; next-generation\n                       :else                        \" \" )))))))","user":"5b073c34e4b0cc2b61a3bda4"},{"code":"(fn [board]\n   (let [get-cell (fn [[x y]] (when (and (empty? (filter neg? [x y]))\n                                         (< x (count (get board y))))\n                                (nth (get board y) x)))\n         live-neighbors (fn [[x y]]\n                          (loop [pointer [(dec x) (dec y)]\n                                 n 0]\n                            (if (nil? pointer)\n                              n\n                              (recur (cond (= (map inc [x y]) pointer) nil\n                                           (= (first pointer) (inc x)) [(dec x) (inc (second pointer))]\n                                           :else [(inc (first pointer)) (second pointer)])\n                                     (if (and (= \\# (get-cell pointer)) (not= [x y] pointer))\n                                       (inc n)\n                                       n)))))]\n\n     (loop [pointer [0 0]\n            acc []]\n       (if (nil? pointer)\n         (map #(reduce str %) (partition (count board) acc))\n         (let [cell-in-question (get-cell pointer)\n               live-cell? (= \\# cell-in-question)\n               neighbors (live-neighbors pointer)] \n           (recur (cond (= [(dec (count (first board))) (dec (count board))] pointer) nil\n                        (= (dec (count (first board))) (first pointer)) [0 (inc (second pointer))]\n                        :else [(inc (first pointer)) (second pointer)])\n\n                  (conj acc (cond (and live-cell? (< 3 neighbors)) \\space\n                                  (and live-cell? (> 2 neighbors)) \\space\n                                  (and live-cell? (or 2 (= neighbors) (= 3 neighbors))) \\#\n                                  (and (not live-cell?) (= 3 neighbors)) \\#\n                                  :else \\space))))))))","problem":94,"user":"50a5b7e9e4b0aa96157e2610"},{"code":"(fn [board]\n  (let [max_r (count board)\n        max_c (count (first board))\n        positions (fn [r c]\n                    (for [x (range (dec r) (+ r 2)), y (range (dec c) (+ c 2)) \n                          :when (and (not (= [x y] [r c])) (<= 0 x max_r) (<= 0 y max_c))]\n                      [x y]))\n\n        output (fn [cells]\n                 (map #(apply str %1) (partition max_r cells)))\n    \n        process_cell (fn [r c]\n                       (let [cell (get (get board r) c)\n                             ne (positions r c)\n                             ne_cells (map (fn [coord] (get-in board coord)) ne) \n                             live (count (filter (partial = \\#) ne_cells))]\n\n                          (if (= cell \\space)\n                            (if (= live 3)\n                              \\#  \n                              \\space)\n                            (cond\n                              (> live 3) \\space\n                              (< live 2) \\space\n                              :else \\#))))]\n\n    (output \n      (for [r (range 0 max_r), c (range 0 max_c)]\n        (process_cell r c)))))","problem":94,"user":"4f29eb2ae4b0d6649770a037"},{"problem":94,"code":"(fn [grid]\n    (let [cellular-update \n          (fn [live-cells]\n            (let [get-neighbors (fn [[x y]] (for [i (range -1 2) \n                                                  j (range -1 2) \n                                                  :when (not (and (= i 0) (= j 0)))]\n                                              [(+ i x) (+ j y)]))]\n              (into #{}\n                    (map first \n                         (filter (fn [[cell freq]] (or (= freq 3)\n                                                       (and (= freq 2) (live-cells cell))))\n                                 (frequencies (mapcat get-neighbors live-cells)))))))\n          to-cell-list \n          (fn [grid]\n            (into #{} \n                  (remove nil? (apply concat (map-indexed (fn [x row] \n                                                            (map-indexed (fn [y v]\n                                                                           (if (= v \\#)\n                                                                             [x y]\n                                                                             nil))\n                                                                         row))\n                                                          grid)))))\n          to-grid  (fn [live-cells dim]\n                     (for [x (range dim)]\n                       (apply str (for [y (range dim)]\n                                    (if (live-cells [x y]) \\# \\space)))))]\n      (-> grid\n          to-cell-list\n          cellular-update\n          (to-grid (count grid)))))","user":"513e8141e4b02b2a3d8235c1"},{"code":"(fn __ [t] \n(letfn [\n    (numera1 [num fila] (let [n (count fila)] (map list (repeat n num) (range n) fila)))\n  (r0 [m trio]  \t(let [ [k v c] trio]  (assoc m [k v] c)))     \n \t(r1 [m [num fila]] (reduce r0 m (numera1 num fila)))   \n\t(r2 [filas] (reduce r1 {} (map list (range) filas)))\n    (vecinos [m x0 y0] (for [dx [-1 0 1] dy [-1 0 1]]\n                    (if (= (m [(+ x0 dx) (+ y0 dy)]) \\#) 1 0)))    \n    (nuevo_estado [m x0 y0] \n    (let [nv0 (reduce + (vecinos m x0 y0))   vivo (= (m [x0 y0]) \\#)\n          nv  (if vivo (dec nv0) nv0)]          \n      (cond \n       (and vivo (or (< nv 2) (> nv 3))) \\space\n       (and (not vivo) (= nv 3)) \\#\n       :else (m [x0 y0]))))]          \n  (for [i (range (count t))]\n    (apply str (for [j (range (count (first t)))] (nuevo_estado (r2 t) i j))))))","problem":94,"user":"4f04a06d535dcb61093f6bd9"},{"code":"(fn game-of-life [board]\n  (let [cell (fn [i j] (.charAt (board i) j))\n        live-cell \\# dead-cell \\space\n        m (count board) n (count (board 0))\n        live-neighbours-count (fn [i j] (count (for [k (range (dec i) (+ i 2)) l (range (dec j) (+ j 2))\n                                          :when (and (not= [k l] [i j]) (<= 0 k (dec m)) (<= 0 l (dec n))\n                                              (= live-cell (cell k l)))] 1)))\n        next-state (fn [i j] (let [cell-state (cell i j) live-count (live-neighbours-count i j)] \n                                (if (= live-cell cell-state) (if (or (= live-count 2) (= live-count 3)) live-cell dead-cell)\n                                    (if (= live-count 3) live-cell dead-cell))))]\n    (for [i (range m)] (apply str (for [j (range n)] (next-state i j))))))","problem":94,"user":"51729002e4b044b2ef48a850"},{"code":"(fn [board]\n  (let [board (vec (map vec board))\n        [h w] (map count ((juxt identity first) board))\n        cell (fn [y x]\n               (get-in board (map mod [y x] [h w])))\n        alive? (comp #{\\#} cell)\n        neighbors (let [offsets [-1 0 1]\n                        deltas (for [y offsets, x offsets\n                                     :when (not= y x 0)]\n                                 [y x])]\n                    (fn [y x]\n                      (count\n                       (for [[dy dx] deltas\n                             :when (alive? (+ y dy) (+ x dx))]\n                         true))))\n        new-state (fn [y x]\n                    (let [nbr-count (neighbors y x)]\n                      (if (or (= 3 nbr-count)\n                              (and (= 2 nbr-count)\n                                   (alive? y x)))\n                        \\#\n                        \\space)))]\n    (for [y (range h)]\n      (apply str (for [x (range w)]\n                   (new-state y x))))))","problem":94,"user":"4dabb7b1950ed6eda1bd72f3"},{"code":"(fn nextboard [board]  \n (letfn [\n  (setlive [board [x y]]                                                                          \n    (for [r (range (count board))]                                                                     \n      (if (= r x)                                                                                      \n        (str (subs (nth board r) 0 y) \\# (subs (nth board r) (inc y)))                                 \n        (nth board r)                                                                                  \n      ))\n   )           \n   (toboard [board cells]                                                                          \n            (loop [b board c cells]                                                                            \n               (if-let [s (seq c)]                                                                              \n                  (recur (setlive b (first s)) (rest s))                                                         \n                  b))\n   )    \n   (neighbors [[x y]]                                                                              \n     (for [dx [-1 0 1] dy [-1 0 1]                                                                      \n          :when (not (and (zero? dx) (zero? dy)))]                                                     \n        [(+ x dx) (+ y dy)])\n   )\n   (tocells [board]                                                                                \n     (set (for [i (range (count board)) j (range (count board)) :when (= (nth (nth board i) j) \\#)]                             \n       [i j]))\n   )]\n  (let [cells (tocells board)\n        emptyBoard (repeat (count (first board)) (first board))]                                                                       \n    (toboard emptyBoard (set (for [[cell n] (frequencies (mapcat neighbors cells))                   \n                :when (or (= n 3) (and (= n 2) (cells cell)))]                                       \n            cell)                                                                                    \n          )))))","problem":94,"user":"4f1d1299535d64f603146487"},{"code":"(fn conway [sarray]\n  (let\n    [dim (count sarray)\n     neighbours (fn [[x y]]\n                  (map (fn [a] (map #(mod % dim) a))\n                       (for [dx [-1 0 1] dy [-1 0 1] :when (not= [0 0] [dx dy])]\n                         (map - [x y] [dx dy]))))\n     is-alive (fn [[x y]] (= \\# (nth (nth sarray y) x)))\n     alive-cells (filter is-alive (for [x (range dim) y (range dim)] [x y]))]\n    (map #(apply str %)\n         (partition dim\n                    (for [y (range dim) x (range dim)]\n                      (let [count-alive-neighbours\n                            (count (clojure.set/intersection (set alive-cells)\n                                                             (set (neighbours [x y]))))]\n                        (cond (> count-alive-neighbours 3) \\space\n                              (< count-alive-neighbours 2) \\space\n                              (= count-alive-neighbours 3) \\#\n                              :else (nth (nth sarray y) x))))))))","problem":94,"user":"51e00020e4b01188f0627534"},{"problem":94,"code":"(fn gameoflife [board]\n  (let [rowsize (count (first board))\n        rows (count board)\n        simple-ind (keep-indexed #(when (= \\# %2) %1)\n                                 (apply str board))\n        live-cells (map #((juxt quot rem) % rowsize) simple-ind)\n        neighbors (fn [[a b]]\n                    (for [x [-1 0 1]\n                          y [-1 0 1]\n                          :when (<= 0 (+ a x))\n                          :when (> rowsize (+ a x))\n                          :when (<= 0 (+ b y))\n                          :when (> rows (+ b y))\n                          :when (not= x y 0)]\n                      [(+ a x) (+ b y)]))\n        how-many (frequencies (mapcat neighbors live-cells))\n        easy-live (->> (filter #(= 3 (val %)) how-many)\n                       (map first))\n        other-live (->> (filter #(= 2 (val %)) how-many)\n                        (map first)\n                        (filter (set live-cells)))]\n    (map #(apply str %) (reduce (fn [s ind]\n                                    (assoc-in s ind \\#))\n                                  (vec (repeat rows (vec (repeat rowsize \" \"))))\n                                  (concat easy-live other-live)))))","user":"54848141e4b0e286459a119e"},{"problem":94,"code":"(fn game-of-life [world]\n  (let [living (for [i (range (count world))\n                     j (range (count (world i)))\n                     :when (= (get-in world [i j]) \\#)]\n                 [i j])\n        \n        dead? (fn [cell]\n                     (= (get-in world cell) \\space))\n        \n        living? (fn [cell]\n                  (= (get-in world cell) \\#))\n        \n        neighbors (for [[i j] living\n                        k (range -1 2)\n                        l (range -1 2)\n                        :when (not (= k l 0))]\n                    [(+ i k) (+ j l)])\n        \n        counts (reduce (fn [ret cell]\n                         (update-in ret [cell] #(inc (or % 0))))\n                       {}\n                       neighbors)\n        \n        births (reduce (fn [world cell]\n                         (assoc-in world cell \\#))\n                       (mapv vec world)\n                       (for [[cell cnt] counts\n                             :when (and (dead? cell) (= cnt 3))]\n                         cell))\n        \n        deaths (reduce (fn [world cell]\n                         (assoc-in world cell \\space))\n                       births\n                       (for [[cell cnt] counts\n                             :when (and (living? cell)\n                                        (or (> cnt 3) (< cnt 2)))]\n                         cell))]\n    (mapv #(apply str %) deaths)))","user":"571c2babe4b07c98581c3b73"},{"problem":94,"code":"(fn [board]\r\n  (let [\r\n      prod (fn [a b]\r\n        (apply concat (map #(map (fn [x] [% x]) b) a)))\r\n      ofs (disj (set\r\n        (prod (range -1 2) (range -1 2))) [0 0])\r\n      cell (fn [[y x]]\r\n        (get (get board y) x))\r\n      neighbours (fn [y x]\r\n        (map (fn [[j i]] [(+ j y) (+ i x)]) ofs))\r\n      live? (fn [c] (= \\# c))\r\n      live-neighbours (fn [y x]\r\n        (count (filter #(live? (cell %)) (neighbours y x))))\r\n      next-state (fn [current nlives]\r\n        (if (= current \\#)\r\n            (if (< nlives 2) \" \"\r\n            (if (<= 2 nlives 3) \"#\"\r\n            \" \"))\r\n          ;else\r\n            (if (= nlives 3) \"#\" \" \")))]\r\n    (map (fn [y] (clojure.string/join\r\n      (map (fn [x]\r\n          (next-state (cell [y x]) (live-neighbours y x)))\r\n        (range (count (board 0))))))\r\n      (range (count board)))))","user":"555bd27ae4b0b056612e2244"},{"problem":94,"code":"(fn [s]\n  (let [nr (count s)\n        nc (count (first s))\n        live-neighbours (fn [y x]\n                          (let [neighbours (rest (for [i [0 -1 1] j [0 -1 1]] [(+ y i) (+ x j)]))]\n                            (count (filter #(= \\# %) (map (partial get-in s) neighbours)))))\n        new-state (fn [y x]\n                    (condp = (live-neighbours y x)\n                      2 (get-in s [y x])\n                      3 \\#\n                      \\space))\n        traverse (for [y (range nr) x (range nc)] (new-state y x))]\n    (map (partial apply str) (partition nc traverse))))","user":"53ce4cd4e4b00fb29b2212ef"},{"problem":94,"code":"(fn next-board\n  [board]\n  (let [cell (fn [board [row col]] (get (get board row) col))\n        neighbor-positions (fn [[row col]]\n                             (for [x [-1 0 1]\n                                   y [-1 0 1]\n                                   :when (not (= 0 x y))]\n                                  [(+ row x) (+ col y)]))\n        neighbors-alive-count (fn [board pos]\n                                (->> pos\n                                     neighbor-positions\n                                     (map #(cell board %))\n                                     (filter #{\\#})\n                                     count))\n        set-in-board (fn [board [row col] x]\n                       (let [the-row (get board row)\n                             new-row (apply str (assoc-in (vec the-row) [col] x))]\n                         (assoc-in board [row] new-row)))\n        rows (count board)\n        cols (count (get board 0))\n        all  (for [row (range rows)\n                   col (range cols)]\n               [row col])]\n    (reduce (fn [next-board pos]\n              (let [alive-neighbors (neighbors-alive-count board pos)\n                    alive?          (= \\# (cell board pos))]\n                (cond\n                  (and alive? (< alive-neighbors 2)) (set-in-board next-board pos \\space)\n                  (and alive? (< alive-neighbors 4)) (set-in-board next-board pos \\#)\n                  (and alive? (> alive-neighbors 3)) (set-in-board next-board pos \\space)\n                  (and (not alive?) (= alive-neighbors 3)) (set-in-board next-board pos \\#)\n                  :else next-board)))\n            board\n            all)))","user":"5afcd6d1e4b0cc2b61a3bd17"},{"code":"(fn gol [b]\n  (let [live?           (fn [p] (= \\# (get-in b p)))\n        neighbor-count  (fn [[r c]] (count (filter live? (for [i (range -1 2) j (range -1 2) :when (not= i j 0)] [(+ r i) (+ c j)]))))]\n    (map (partial apply str)\n         (map #(map str %)\n              (for [r (range (count b))]\n                (for [c (range (count (b r)))]\n                  (condp = (neighbor-count [r c])\n                    2 (get-in b [r c])\n                    3 \\#\n                    \\space)))))))","problem":94,"user":"530bf87ee4b02e82168697d5"},{"problem":94,"code":"(fn [m] \n  (let [s (count m)\n        board (into [] (map vec m))\n        of [[-1 -1] [-1 0] [-1 1] [0 -1] [0 1] [1 -1] [1 0] [1 1]]\n        in? (fn [[x y]] (and (< -1 x s) (< -1 y s)))\n        state #(get-in board %)\n        a \\#\n        d \\space\n        a? #{a}\n        an (fn [x y] (count (filter a? (map state (filter in? (map #(map + % [x y]) of)))) )) \n        destiny (fn [c an]\n                  (cond \n                    (and (#{a} c) (< an 2)) d\n                    (and (#{a} c) (<= 2 an 3)) a\n                    (and (#{a} c) (> an 3)) d\n                    (and (not (#{a} c)) (= an  3)) a\n                    :else d))]\n              \n    (->> (for [x (range s) y (range s)] (destiny (state [x y]) (an x y)))\n         (partition s)\n         (map #(apply str %)))))","user":"577202d2e4b0979f896515c0"},{"problem":94,"code":"(fn [board-in]\n  (letfn [(indices [el coll] (map first (filter #(= el (second %)) (map-indexed vector coll))))\n          (to-tuples [idx-coll] (let [[i coll] idx-coll] (map vector (repeat i) coll)))\n          (get-board-dims [board-list] (vector (count board-list) (count (first board-list))))\n          (get-all-cells [dims] (let [[nrow ncol] dims rows (range nrow) cols (range ncol) tups (map #(vector % cols) rows)] (apply concat (map to-tuples tups))))\n          (parse-rows [el board-list] (apply concat (map to-tuples (map-indexed (fn [i coll] (vector i (indices el (map str (seq coll))))) board-list))))\n          (dist [cell-one cell-two] (let [[x1 y1] cell-one [x2 y2] cell-two] (Math/sqrt (+ (Math/pow (- x1 x2) 2) (Math/pow (- y1 y2) 2)))))\n          (cell-dists [cell cell-list] (map (partial dist cell) cell-list))\n          (count-live-neighbors [live-cells cell] (count (filter #(and (< 0 %) (> 2 %)) (cell-dists cell live-cells))))\n          (will-live [cell live-neighbors is-live] (when (or (and is-live (or (= 2 live-neighbors) (= 3 live-neighbors))) (and (complement is-live) (= 3 live-neighbors))) cell))\n          (get-live-cells [cells live-neighbors is-live] (into [] (filter (complement nil?) (map will-live cells live-neighbors is-live))))\n          (build-board [dims live-cells] (let [[nrow ncol] dims row-groups (group-by first live-cells)] (loop [row 0 col 0 live-row (map second (get row-groups 0)) this-row \"\" out []] (if (and (= row nrow) (= col ncol)) out (cond (= col ncol) (recur (inc row) 0 (map second (get row-groups (inc row))) \"\" (conj out this-row)) (= col (first live-row)) (recur row (inc col) (next live-row) (str this-row \"#\") out) :else (recur row (inc col) live-row (str this-row \" \") out))))))\n        ]\n        (let [dims (get-board-dims board-in)\n              cells (get-all-cells dims)\n              live-now (parse-rows \"#\" board-in)\n              live-neighbors (map (partial count-live-neighbors live-now) cells)\n              is-live (map #(if (seq (indices % live-now)) true false) cells)\n              live-next (get-live-cells cells live-neighbors is-live)\n              ]\n          (build-board dims live-next)\n          )))","user":"53e76bb2e4b036ad0777e47d"},{"code":"(fn next-generation [board]\n  (let [offsets (clojure.set/difference (set (for [x (range -1 2) y (range -1 2)] (vector x y))) #{[0 0]})\n        height (count board)\n        width (count (first board))\n        cell (fn [x y] (get-in board [x y] \\space))\n        neighbours (fn [x y] (map (fn [[dx dy]] (cell (+ x dx) (+ y dy))) offsets))\n        living-neighbours (fn [x y] (count ((group-by identity (neighbours x y)) \\#)))\n        next-cell (fn [x y] (if (= (cell x y) \\#)\n                                (if (or (= (living-neighbours x y) 2) (= (living-neighbours x y) 3))\n                                  \\#\n                                  \\space)\n                                (if (= (living-neighbours x y) 3)\n                                  \\#\n                                  \\space)\n                            ))]\n    (map #(apply str %)\n      (partition width\n        (for [x (range width) y (range height)]\n          (next-cell x y)\n        )\n      )\n    )\n  )\n)","problem":94,"user":"5272d4b7e4b03e8d9a4a7453"},{"problem":94,"code":"(fn [board]\n  (let [w          (count (first board))\n        h          (count board)\n        living?    (fn [ch] (= \\# ch))\n        populated? (fn [board [x y]]\n                    (living? (get (board y) x)))\n        check-square (fn [board w h idx]\n                       (let [x (rem  idx w)\n                             y (quot idx w)]\n                         (->> (for [dx (range (max 0 (dec x))\n                                              (min w (+ x 2)))\n                                    dy (range (max 0 (dec y))\n                                              (min h (+ y 2)))\n                                    :when (or (not= dx x)\n                                             (not= dy y))]\n                                [dx dy])\n                              (filter (partial populated? board))\n                              count)))\n        \n        transform-cell (fn [cell neighbors]\n                         (if (living? cell)\n                           (if (or (< neighbors 2)\n                                   (> neighbors 3))\n                             \\space\n                             \\#)\n                           (if (= neighbors 3)\n                             \\#\n                             cell)))\n        \n        check-square (fn [board w h idx]\n                       (let [x (rem  idx w)\n                             y (quot idx h)]\n                         (->> (for [dx (range (max 0 (dec x))\n                                              (min w (+ x 2)))\n                                    dy (range (max 0 (dec y))\n                                              (min h (+ y 2)))\n                                    :when (or (not= dx x)\n                                              (not= dy y))]\n                                [dx dy])\n                              (filter (partial populated? board))\n                              count)))]\n    (->> (apply str board)\n         (map-indexed\n          #(->> (check-square board w h %1)\n                (transform-cell %2)))\n         (partition w)\n         (mapv (partial apply str)))))","user":"5dc88a38e4b02f9375f4e1db"},{"problem":94,"code":"(fn [board]\n    (let [lives? #(= \\# %)\n          rows (count board)\n          cols (count (first board))\n          get-env (fn [i j]\n                    (reduce +\n                            (for [i' [(dec i) i (inc i)] j' [(dec j) j (inc j)]\n                                  :when (and (not (and (== i i') (== j j')))\n                                             (<= 0 i' (dec rows))\n                                             (<= 0 j' (dec cols))\n                                             (lives? (nth (nth board i') j')))]\n                              1)))]\n      (->> board\n           (map-indexed\n            (fn [i row]\n              (map-indexed\n               (fn [j cell]\n                 (let [live (get-env i j)]\n                   (if (lives? cell)\n                     (cond\n                       (< live 2) \\space\n                       (#{2 3} live) \\#\n                       (> live 3) \\space)\n                     (if (== 3 live) \\# \\space)))) row)))\n           (map (partial apply str)))))","user":"5c995fa4e4b048ec896c5a96"},{"code":"(fn [c]\n   (let\n       [v (vec (map #(vec %) c)) r\n     (keep-indexed #(keep-indexed (fn [a b] (let [ns (vec (for [x [-1 0 1] y [-1 0 1]]\n                                               (if (= 0 x y)\n                                                 nil\n                                                 (let [x2 (+ %1 x) y2 (+ a y) c (count %2)]\n                                                   (if (or (< x2 0) (< y2 0) (>= x2 c) (>= y2 c)) nil ((v x2) y2))\n\t                                           )))) v2 {:self (%2 a) :dead (count (filter (fn [e] (= \" \" (str e))) ns)) :live (count (filter (fn [e] (= \\# e)) ns)) }]\n                                              (if (= (str (v2 :self)) \"#\")\n                                                (if (< (v2 :live) 2)\n                                                  \" \"\n                                                  (if (> (v2 :live) 3)\n                                                    \" \"\n                                                    \"#\"\n                                                    )\n                                                  )\n                                                (if (= (v2 :live) 3)\n                                                  \"#\"\n                                                  \" \"\n                                                  )\n                                                ))) (v %1)) v)]\n     (vec (map #(apply str %) r))))","problem":94,"user":"52c1bd29e4b07a9af579236a"},{"problem":94,"code":"(fn game-of-life-step-v2 [x]\n  (let [w (count (first x))\n        h (count x)\n        to-int (fn [board pos] (if (contains? board pos) 1 0))\n        get-from-row (fn [idx row] (filter #(not= (second %) \\space ) (map-indexed #(vector [idx %1] %2) row)))\n        taken (set (map first (apply concat (map-indexed #(get-from-row %1 %2) x))))\n        get-neighbours (fn [[r0 c0] other]\n                              (for [dr [-1 0 1]\n                                    dc [-1 0 1]\n                                    :when (not (= dr dc 0))\n                                    :let [r (+ r0 dr) \n                                          c (+ c0 dc)]]\n                                (to-int other [r c])))\n        get-neighbour-count (fn [pos other] (reduce + (get-neighbours pos other)))\n        neighbour-and-this (for [r (range h)                     \n                                 c (range w)]\n                             [(get-neighbour-count [r c] taken) (to-int taken [r c])])\n        new-vals (partition w (map #(cond\n                                     (and (pos? (second %)) (< (first %) 2)) 0\n                                     (and (pos? (second %)) (> (first %) 3)) 0\n                                     (pos? (second %))  1\n                                     (= (first %) 3)  1\n                                     :else 0) \n                                   neighbour-and-this))\n        row-to-string (fn [x] (apply str (map #(if (zero? %) \\space \\#) x)))\n        as-string (map row-to-string new-vals)\n        ]\n    as-string))","user":"54e345a1e4b024c67c0cf7db"},{"problem":94,"code":"(fn [board]\n  (let [indexed-board (reduce merge {} (map (fn [row-num s-row]\n                                              (hash-map row-num\n                                                        (let [row (drop 1 (clojure.string/split s-row #\"\"))\n                                                              col-num (range 1 (inc (count row)))]\n                                                          (reduce merge {} (map #(hash-map %1 %2)\n                                                                                col-num\n                                                                                row)))))\n                                            (range 1 (inc (count board)))                                           \n                                            board))\n        count-live-neighbors (fn [count-board [row col]]\n                               (let [neighbors (list [(dec row) (dec col)] [(dec row) col] [(dec row) (inc col)]\n                                                     [row (dec col)]                       [row (inc col)]\n                                                     [(inc row) (dec col)] [(inc row) col] [(inc row) (inc col)])]\n                                 (reduce + (map (fn [neighbor]\n                                                  (if (= \"#\" (get-in indexed-board neighbor)) 1 0))\n                                                neighbors))))]\n    (into [] (map (fn [[rown row]]\n                    (reduce str (map (fn [[coln col]]\n                                       (let [cur-state (get-in indexed-board [rown coln])\n                                             live-neighbors (count-live-neighbors indexed-board [rown coln])]\n                                         (if (= \"#\" cur-state)\n                                           (if (or (< live-neighbors 2)\n                                                   (> live-neighbors 3))\n                                             \" \"\n                                             \"#\")\n                                           (if (= live-neighbors 3)\n                                             \"#\"\n                                             \" \"))))\n                                     row)))\n                  indexed-board))))","user":"559d33b3e4b0ec2b359424d9"},{"problem":94,"code":"(fn life [gs]\n\t(let [neighbors #{[-1 -1] [-1 0] [-1 1] [0 -1] [0 1] [1 -1] [1 0] [1 1]}\n\t\t  alive? #{\\#}\n\t\t  born? #{3}\n\t\t  stay-alive? #{2 3}]\n\t\t(map-indexed\n\t\t\t(fn [i r]\n\t\t\t\t(apply str\n\t\t\t\t\t(map-indexed\n\t\t\t\t\t\t(fn [j c]\n\t\t\t\t\t\t\t(let [nalive (count (filter alive? (map (fn [[x y]] (get-in gs [(+ i x) (+ j y)])) neighbors)))]\n\t\t\t\t\t\t\t\t(if ((if (alive? (get-in gs [i j]))\n\t\t\t\t\t\t\t\t\t\tstay-alive?\n\t\t\t\t\t\t\t\t\t\tborn?) nalive)\n\t\t\t\t\t\t\t\t\t\\#\n\t\t\t\t\t\t\t\t\t\\space)))\n\t\t\t\t\t\tr)))\n\t\t\tgs)))","user":"56baa68ce4b0f26550335947"},{"code":"(fn [grid]\n  (let [\npositions (fn [x y] (for [i [-1 0 1] j [-1 0 1] :when (not= i j 0)] [(+ i x) (+ j y)]))\nlive? #(= \\# %)\nlive #(if (live? %) 1 0)\ncell (fn [grid [x y]] (-> grid (get y) (get x)))\ncell-live (fn [grid pos] (live (cell grid pos)))\nneighbours (fn [grid [x y]] (apply + (map #(cell-live grid %) (positions x y))))\nnext-state\n  #(map-indexed\n    (fn [row rowvalue]\n      (apply str\n        (map-indexed\n          (fn [col cell]\n            (let [nei (neighbours % [col row])]\n              (if (live? cell)\n                  (cond (< nei 2) \\space\n                        (> nei 3) \\space\n                        :otherwise \\#)\n                  (if (= 3 nei) \\# \\space))))\n          rowvalue)))\n    %)]\n  (next-state grid)))","problem":94,"user":"4ec812d9535d6d7199dd36f0"},{"problem":94,"code":"(fn solve [a]\n  (let [moves [[0 1] [1 1] [1 0] [1 -1] [0 -1] [-1 -1] [-1 0] [-1 1]]\n        n (count a)\n        m (count (first a))\n        living (set (filter identity (for [x (range n) y (range m)] (when (= (get-in a [x y]) \\#) [x y]))))\n        neighbours (fn [x y] (filter #(and (>= (dec n) (first %) 0) (>= (dec m) (second %) 0)) (map #(list (+ (first %) x) (+ (second %) y)) moves)))\n        living-neighbours (fn [x y] (filter #(contains? living %) (neighbours x y)))\n        ]\n    (into [] (for [x (range n)]\n            (apply str (for [y (range m)]\n              (let [is-living (= (get-in a [x y]) \\#)\n                    count-living (count (living-neighbours x y))\n                    ]\n                (if is-living\n                       (if (>= 3 count-living 2) \\# \\space)\n                       (if (= count-living 3) \\# \\space)\n                     ))))))))","user":"56f258d3e4b04a395b9a04a1"},{"problem":94,"code":"(fn next-gen\n  [board]\n  (letfn [(life-cell?\n            [x]\n            (cond\n              (= x \"#\")\n              true\n\n              (= x \"x\")\n              \"x\"\n\n              :else\n              false))\n\n          (safe-subs\n            [row start stop]\n            (let [r-c\n                  (count row)]\n              (if-not (or (> 0 start) (<= r-c stop))\n                (subs row start stop)\n                \"x\")))\n\n          (get-cells\n            ([row x _]\n             (let [normal\n                   (get-cells row x)\n                   bonus\n                   (life-cell? (safe-subs row x (inc x)))]\n               (if normal\n                 (conj normal bonus)\n                 [bonus])))\n  \n            ([row x]\n             (when-not (nil? row)\n               (map life-cell? [(safe-subs row (dec x) x)\n                                (safe-subs row (inc x) (+ 2 x))]))))\n\n          (useful-board\n            [board]\n            (map-indexed\n             (fn [xid row]\n               (map-indexed\n                (fn [yid cell] [(life-cell? (str cell)) (concat\n                                                         (get-cells (get board (dec xid)) yid true)\n                                                         (get-cells (get board (inc xid)) yid true)\n                                                         (get-cells row yid))])\n                row))\n             board))\n\n          (next-gen-bool\n            [board]\n            (map (fn [row]\n                   (map (fn [[status neighbours :as cell]]\n                          (let [n-alive\n                                (count (filter true? neighbours))\n                                \n                                n-dead\n                                (count (filter false? neighbours))]\n                            (if-not status\n                              (= 3 n-alive)\n                              (cond\n                                (> 2 n-alive)\n                                false\n\n                                (or (= 2 n-alive) (= 3 n-alive))\n                                true\n\n                                :else\n                                false))))\n                        row)) (useful-board board)))\n\n          (bool->cell\n            [bool]\n            (if bool\n              \"#\"\n              \" \"))]\n    (map\n     (fn [row]\n       (apply str (map bool->cell row)))\n     (next-gen-bool board))))","user":"5b759ca8e4b047b03b2036d0"},{"code":"(let [\n\n  make-board (fn [lines]\n    (let [line-to-vec #(into [] (map {\\space :e, \\# :l} %))]\n      (into [] (map line-to-vec lines))))\n\n  stringify-board (fn [board]\n    (into [] (map (fn [line] (reduce #(str % ({:e \\space, :l \\#} %2)) \"\" line)) board)))\n\n  xcount (fn [board] (count board))\n\n  ycount (fn [board] (count (board 0)))\n\n  neighbors (fn [[x y]] (map (fn [[dx dy]] [(+ dx x) (+ dy y)]) (for [x [-1 0 1] y [-1 0 1] :let [pos [x y]] :when (not= [0 0] pos)] pos)))\n\n  live-neighbors (fn [board pos]\n    (count (filter #{:l} (map #(get-in board %) (neighbors pos)))))\n\n  new-live (fn [board positions]\n    (filter #(= 3 (live-neighbors board %)) positions))\n\n  new-dead (fn [board positions]\n    (filter\n      #(or\n        (< (live-neighbors board %) 2)\n        (> (live-neighbors board %) 3))\n      positions))\n] \n\n  (fn [lines]\n    (let [board (make-board lines)\n          positions (for [x (range (xcount board)) y (range (ycount board))] [x y])\n          nl (new-live board positions)\n          nd (new-dead board positions)\n          b1 (reduce #(assoc-in % %2 :l) board nl)\n          b2 (reduce #(assoc-in % %2 :e) b1 nd)]\n      (stringify-board b2))))","problem":94,"user":"4ec07699535dfed6da9c6da2"},{"problem":94,"code":"(fn [b]\n    (letfn [(n [r c]\n              (for [i (range -1 2)\n                    j (range -1 2)\n                    :when (not= 0 i j)]\n                (get-in b [(+ r i) (+ c j)])))]\n      (let [r (count b) c (count (first b))]\n        (->>(for [i (range r)\n                  j (range c)]\n              (let [l (count (filter #(= \\# %) (n i j)))]\n                (cond\n                  (and (= l 2)\n                       (= \\# (get-in b [i j]))) \\#\n                  (= l 3) \\#\n                  :else \\space)))\n            (partition c)\n            (map #(apply str %))))))","user":"55c5b55fe4b0e31453f649b5"},{"code":"(fn[board]\n   (let [gen1 (vec(map (fn[x](vec (map #(if(= % \\space)0 1) x))) board)) m (count gen1) n (count (first gen1))]\n     (letfn [(count-neib [i j](apply +(filter #(not(nil? %))(map #(get-in gen1 %) \n                              (for [x (range (dec i)(+ i 2))y (range(dec j)(+ j 2)) \n                               :when (or(not= x i)(not= y j))] [x y])))))]\n        (map (fn [x] (apply str (map #(if(= % 0)\" \" \"#\") x)))\n             (partition-all m (for [i (range m) j (range n)] \n                           (let [cnt (count-neib i j) was (get-in gen1 [i j])]\n                             (cond (and(= 0 was)(= 3 cnt)) 1\n                                   (and(= 1 was)(or(= 2 cnt)(= 3 cnt)))1\n                                   :else 0)))))\n\n       )\n     )\n )","problem":94,"user":"5274eb56e4b03e8d9a4a74bb"},{"problem":94,"code":"(fn gol [m]\n (let [dim (count (first m))\n       mid (loop [matrix m acc []]\n       \t    (if (empty? matrix)\n       \t     (flatten acc)\n   \t    (recur (rest matrix) \n\t           (conj acc (map #(str %) (first matrix))))))\n       ijtrn (fn [dat dim] (if (coll? dat) \n       \t     \t       \t         (if (or (< (first dat) 0) (< (second dat) 0))\n\t\t\t\t      -1\n\t\t\t\t      (+ (last dat) (* (first dat) dim)))\n\t\t\t   (list (int (/ dat dim)) (mod dat dim))))\n       nxst (fn [i l d] \n       \t      (let [ij (ijtrn i l) \n\t      \t    nbrs [(ijtrn [(first ij) (dec (second ij))] l)\n\t\t    \t  (ijtrn [(first ij) (inc (second ij))] l)\n\t\t\t  (ijtrn [(dec (first ij)) (dec (second ij))] l)\n\t\t\t  (ijtrn [(dec (first ij)) (second ij)] l)\n\t\t\t  (ijtrn [(dec (first ij)) (inc (second ij))] l)\n\t\t\t  (ijtrn [(inc (first ij)) (dec (second ij))] l)\n\t\t\t  (ijtrn [(inc (first ij)) (second ij)] l)\n\t\t\t  (ijtrn [(inc (first ij)) (inc (second ij))] l)]\n\t\t    nbrsl (apply + (map #(if (= \"#\" (nth d %) ) 1 0)\n\t\t    \t  (filter #(and (> % -1) (< % (count d))) nbrs)))]\n;\t\t   (print [i ij nbrs])\n\t\t   (if (= \"#\" (nth d i))\n\t\t    (if (or (= nbrsl 2) (= nbrsl 3)) \"#\" \" \")\n\t\t     (if (= nbrsl 3) \"#\" \" \"))))]\n   (->> (map #(nxst % dim mid) (range (count mid)))\n   \t(partition dim)\n        (map #(apply str %)))))","user":"52747090e4b03e8d9a4a74a5"},{"code":"(fn [rows]\n   (let\n     [mp\n      (map\n       (fn [row]\n         (map #(= \\# %) row)\n         )\n       rows\n       )\n      off\n      [[-1 -1] [-1 0] [-1 1] [0 -1] [0 1] [1 -1] [1 0] [1 1]]\n      alv {0 \\  1 \\  2 \\# 3 \\# 4 \\  5 \\  6 \\  7 \\  8 \\  9 \\  }\n      ded {0 \\  1 \\  2 \\  3 \\# 4 \\  5 \\  6 \\  7 \\  8 \\  9 \\  }\n      ]\n     (letfn\n       [\n        (nm\n         [a b]\n         (if (or (< a 0) (>= a (count mp)) (< b 0) (>= b (count (first mp))))\n           0\n           (if (nth (nth mp a) b) 1 0)\n           )\n         )\n        ]\n       (map\n        (fn [a]\n          (apply\n           str\n           (map\n            (fn [b]\n              (let [x (reduce + (map #(nm (+ a (first %1)) (+ b (second %1))) off))]\n                (if (nth (nth mp a) b)\n                  (alv x)\n                  (ded x)\n                  )\n                )\n              )\n            (range (count (first mp))))\n           )\n          )\n        (range (count mp))\n        )\n       )\n     )\n   )","problem":94,"user":"52586d24e4b0cb4875a45cb0"},{"problem":94,"code":"(fn [board]\n  (->> (case (->> (and (not= [x y] [x' y'])\n                       (= (get-in board [y' x']) \\#))\n                  (for [x' (range (max 0 (dec x))\n                                  (min (+ x 2) (count row)))\n                        y' (range (max 0 (dec y))\n                                  (min (+ y 2) (count board)))])\n                  (filter identity)\n                  count)\n         2 (get-in board [y x])\n         3 \\# \\space)\n       (for [x (range (count row))])\n       (apply str)\n       (for [[y row] (map-indexed vector board)])))","user":"575cbe44e4b02ea114799374"},{"code":"(fn [b]\n  (letfn [\n    (nb [b x y]\n  (count\n   (filter #(= \\# %)\n           (map #(get-in b %)\n                (for [i [-1 0 1]\n                      j [-1 0 1]\n                      :when (not (= 0 i j))]\n                  [(+ y i) (+ x j)]))))),\n(next-row [b r y]\n  (map-indexed\n   (fn [x v]\n     (let [n (nb b x y)]\n       (if (= \\# v)\n         (cond (< n 2) \\ \n               (> n 3) \\ \n               :else \\#)\n         (if (= n 3) \\# \\ ))))\n   (seq r))),\n(next2 [b]\n  (map-indexed (fn [y r] (next-row b r y)) b)),\n(to-str [board]\n  (map #(apply str %) board))]\n\n(to-str (next2 b))))","problem":94,"user":"4e7db3b4535db169f9c796e1"},{"problem":94,"code":"(fn [x]\n      (let [bv (mapv (comp vec seq) x)\n            is-live? (fn [[i j]] (= \\# ((bv i) j)))\n            maxi (dec (count bv))\n            maxj (dec (count (first bv)))\n            gen-neighbours (fn [ij] (remove (fn [[i j]] (or (neg? i) (neg? j) (> i maxi) (> j maxj))) (mapv #(mapv + ij %) [[-1 -1] [-1 0] [-1 1] [0 -1] [0 1] [1 -1] [1 0] [1 1]])))]\n        (vec\n          (for [i (range (inc maxi))]\n            (apply\n              str\n              (for [j (range (inc maxj))]\n                (let [nc (count (filter is-live? (gen-neighbours [i j])))]\n                  (if (is-live? [i j])\n                    (if (or (< nc 2) (> nc 3)) \\space \\#)\n                    (if (not= nc 3) \\space \\#)))))))))","user":"5310e968e4b08068f379ecdd"},{"code":"(fn game-of-life [board-strs]\r\n  (let\r\n    [board (vec (map #(vec %) board-strs))\r\n     height (count board)\r\n     width (count (first board))\r\n     on-board? (fn [[i j]]\r\n                (and (>= i 0) (>= j 0) (< i height) (< j width)))\r\n     neighbors (fn [[i j]]\r\n                 (for [di [-1 0 1]\r\n                       dj [-1 0 1]\r\n                       :let [newi (+ i di)\r\n                             newj (+ j dj)]\r\n                       :when (and (or (not= 0 di) (not= 0 dj))\r\n                              on-board? [newi newj])]\r\n                       [newi newj]))\r\n     live-neighbors (fn [square]\r\n                       (count\r\n                         (filter #(= \\# (get-in board %)) (neighbors square))))\r\n     alive? (fn [square] (= \\# (get-in board square)))\r\n     \r\n     next-gen (fn [square]\r\n                (let\r\n                  [is-alive? (alive? square)\r\n                   num-live-neighbors (live-neighbors square)]\r\n                  (if is-alive?\r\n                    (cond\r\n                      (< num-live-neighbors 2) \\space\r\n                      (<= num-live-neighbors 3) \\#\r\n                      :else \\space)\r\n                    (if (= 3 num-live-neighbors) \\# \\space))))\r\n     board-coords (vec (for [i (range height)]\r\n                         (vec  (for [j (range width)] [i j]))))]\r\n     (map (fn [row] \r\n            (apply str (map next-gen row))\r\n     ) board-coords)))","problem":94,"user":"4f036fb3535dcb61093f6ac8"},{"problem":94,"code":"(fn [x]\n (let [b (mapv vec x)\n       s (count x)\n       l (range s) \n       d [-1,0,1]]\n  (->> (mapcat #(map (fn [i] (if (= \\# ((b i) %)) (for [n d m d :when (not= 0 n m)] {[(+ i n) (+ % m)],1}) (list {[i,%],0}))) l) l)\n   (apply concat)\n   (apply merge-with +)\n   sort\n   (reduce (fn [x [[i j] n]] (concat x (cond (= 2 n) (str ((b i) j)) (= 3 n) \"#\" :else \" \"))) \"\")\n   (clojure.string/join)\n   (partition s)\n   (map clojure.string/join))))","user":"5b61aa6ae4b0c6492753e712"},{"problem":94,"code":"(fn [board]\r\n  (let [max-y (-> board count dec)\r\n        max-x (-> board first count dec)]\r\n    (letfn [(matrix-add [[x y] [a b]] [(+ x a) (+ y b)])\r\n            (neighbours [[x y]]\r\n              (for [i (range -1 2) j (range -1 2) :when (not= 0 i j)]\r\n                (matrix-add [x y] [i j])))\r\n            (valid? [[x y]] (and (<= 0 x max-x) (<= 0 y max-y)))\r\n            (living [s] (count (filter #(= \\# (get-in board %))\r\n                                       (filter valid? s))))\r\n            (life [me s]\r\n              (cond\r\n               (and (= \\  (get-in board me)) (= 3 (living s))) \\#\r\n               (and (= \\# (get-in board me)) (<= 2 (living s) 3)) \\#\r\n               :else \\ ))]\r\n      (apply map str (partition (inc max-x) (for [i (range 0 (inc max-x)) j (range 0 (inc max-y))]\r\n                                        (->> [j i] neighbours (life [j i]))))))))","user":"53c649d3e4b00fb29b221297"},{"problem":94,"code":"(fn gol-update [board]\n  ;; Verifying that the board is in the proper format:\n  {:pre [\n         ;; The rows should be ordered.\n         (sequential? board),\n         ;; Each row should be a string.\n         (every? string? board),\n         ;; Each row should have the same length, but we do allow the empty board.\n         (or (empty? board)\n             (apply = (map count board))),\n         ;; The only characters are #'s and spaces.\n         (every? (partial every? #{\\# \\space}) board)\n         ]}\n\n  (let [\n        ;; We begin by recording the dimensions of the board.\n        max-rows (count board),\n        max-cols (count (first board)),\n\n        ;; The function count-adj counts the number of cells adjacent to the\n        ;; cell at the specified row and column that match the supplied\n        ;; character c.\n        count-adj (fn [c row col]\n                    (->> (for [i (range max-rows), j (range max-cols)\n                               :when (< 0\n                                        (max (Math/abs (- i row))\n                                             (Math/abs (- j col)))\n                                        2)]\n                           (get-in board [i j]))\n                         (filter (partial = c))\n                         count)),\n\n        ;; The function update-cell determines whether the cell at the specified\n        ;; row and column should be alive or dead in the next iteration.\n        update-cell (fn [row col]\n                      (let [c (get-in board [row col]),\n                            live-neighbors (count-adj \\# row col)]\n                        (case live-neighbors\n                          2  (if (= c \\#) \\# \\space)\n                          3  \\#\n                          \\space)))]\n\n    ;; With the helper functions defined above, we just need to \"print\" the\n    ;; board.\n    (for [i (range max-rows)]\n      (apply str (for [j (range max-rows)]\n                   (update-cell i j))))))","user":"4fc6305de4b0ee37620e180b"},{"problem":94,"code":"(fn [board]\n  (let [w (-> board first vec count) h (count board)\n        live (fn [x y] (and (>= x 0) (< x w) (>= y 0) (< y h) (= \\# (nth (vec (nth board y)) x))))]\n    (reduce conj []\n            (map\n             (fn [y]\n               (apply str\n                      (map\n                       (fn [x]\n                         (let [alive (live x y) offset [-1 0 1]\n                               n (reduce + (map\n                                            (fn [dx] (reduce + (map\n                                                                (fn [dy] (if (live (+ x dx) (+ y dy)) 1 0))\n                                                                offset)))\n                                            offset))]\n                           (if (or (= n 3) (and alive (= n 4))) \\# (-> \" \" vec first))))\n                       (range w))))\n             (range h)))))","user":"5b465b8be4b02d533a91bc65"},{"problem":94,"code":"(fn [board]\n  (letfn [(alive? [[x y]] (and (>= x 0)\n                               (>= y 0)\n                               (< y (count board))\n                               (< x (count (first board)))\n                               (= (nth (nth board y) x) \\#)))\n          \n          (living-neighbors [[x y]] (count (filter #(and (alive? %)\n                                                         (not (= % [x y])))\n                                                   (for [x-offset (range -1 2)\n                                                         y-offset (range -1 2)]\n                                                     [(+ x x-offset) (+ y y-offset)]))))]\n    (map #(apply str (map (fn [x] (if (or (and (= (living-neighbors [x %]) 2)\n                                               (alive? [x %]))\n                                          (= (living-neighbors [x %]) 3)) \n                                    \\#\n                                    \\ ))\n                          (range (count (nth board %)))))\n         (range (count board)))))","user":"53acaf1fe4b047364c04445f"},{"problem":94,"code":"(fn game-of-life\n  ([board] (map #(apply str %) (partition (count (first board))\n                                       (for [r (range (count board)) c (range (count (first board)))]\n                                         (game-of-life board r c\n                                                       (dec (count board)) (dec (count (first board))))))))\n  ([board i j rowmax colmax]\n   (let [live-nbors (apply + (for [[off-i off-j] (apply conj [[0 -1] [0 1]] (for [i-mod '(-1 1) j-mod '(-1 0 1)] [i-mod j-mod]) )]\n                               (if (or (< (+ i off-i) 0) (> (+ i off-i) rowmax)\n                                       (< (+ j off-j) 0) (> (+ j off-j) colmax)\n                                       (= \\ (get-in board [(+ i off-i) (+ j off-j)]))) 0 1)))]\n     (if (= \\# (get-in board [i j]))\n       (cond\n         (< live-nbors 2) \\ (<= live-nbors 3) \\#\n         :else \\ )\n       (if (= live-nbors 3) \\# \\ )))))","user":"561ca6ebe4b064ca9f4b169c"},{"problem":94,"code":"(fn game-of-life [field]\n\t(letfn [(points [field]\n\t            (for [w (range 0 (count (first field)))\n\t            \t  h (range 0 (count field))] \n\t            \t[w h]))\n            (alive? [field coords]\n            \t(= 1 (get-in field coords)))           \n            (neighbours [field [x y]]\n            \t(for [x' [(inc x) (dec x) x]\n            \t\t  y' [(inc y) (dec y) y]\n            \t\t  :when (not= [x y] [x' y'])\n            \t\t  :when (every? #(>= % 0) [x' y'])\n            \t\t  :when (< x' (count field))\n            \t\t  :when (< y' (count (first field)))]\n            \t\t[x' y']))            \n            (cell-step [field coords]\n            \t(let [neighbours-cells (map (partial get-in field) \n            \t\t                        (neighbours field coords))\n            \t      living-cells-count (apply + neighbours-cells)]\n            \t    (if (alive? field coords)\n            \t        (if (#{2 3} living-cells-count) 1 0)\n            \t        (if (= 3 living-cells-count) 1 0))))            \n            (field-step [field]\n            \t(reduce\n            \t\t(fn [field-1 coords]\n            \t\t\t(assoc-in field-1 coords (cell-step field coords)))\n            \t\tfield\n            \t\t(points field)))            \n            (parse-field [field]\n            \t(mapv\n            \t\t(partial mapv {\\space 0 \\# 1})\n            \t\tfield))            \n            (show-field [field]\n            \t(mapv #(clojure.string/join (map {1 \\# 0 \\space} %)) field))]\n\t\t(show-field (field-step (parse-field field)))))","user":"5af8221ce4b0cc2b61a3bccd"},{"problem":94,"code":"(fn [board]\n  (let [adjacent-range (fn [n]\n                         (map #(% n) [dec identity inc]))\n        neighbors (fn [[x y :as coord]]\n                    (for [neighbor-x (adjacent-range x)\n                          neighbor-y (adjacent-range y)\n                          :when (not= [neighbor-x neighbor-y] coord)]\n                      [neighbor-x neighbor-y]))\n        \n        width (count (first board))\n        height (count board)\n        coords (for [x (range width)\n                     y (range height)\n                     :when (= (nth (nth board y) x) \\#)]\n                 [x, y])\n        coords-set (set coords)\n        \n        next-coords (for [[coord num-neighbors] (frequencies (mapcat neighbors coords-set))\n                          :when (or (= num-neighbors 3)\n                                    (and (= num-neighbors 2)\n                                         (coords-set coord)))]\n                         coord)\n        \n        next-board (let [blank-board (vec (repeat height (vec (repeat width \\space))))\n                         rows (reduce (fn [board [x y]]\n                                        (assoc-in board [y x] \\#))\n                                      blank-board\n                                      next-coords)]\n                     (for [row rows]\n                       (apply str row)))]\n    next-board))","user":"5424c523e4b01498b1a71b03"},{"problem":94,"code":"(fn [board]\n  (let [rows (range (count board))\n        cols (range (count (first board)))\n        indices (set (for [i rows j cols] (vector i j)))\n        entry (fn [ij] (get (get board (first ij)) (second ij)))\n        alive? (fn [x] (= (entry x) \\#))\n        adjacent? (fn [a b]\n                    (= (max (Math/abs (- (first a) (first b))) (Math/abs (- (second a) (second b)))) 1))\n        neighbours (fn [x] (count (filter #(and (alive? %) (adjacent? x %)) indices)))\n        survival-rule {0 false 1 false 2 true 3 true 4 false 5 false 6 false 7 false 8 false}\n        update-rule (fn [x] (if (alive? x) (survival-rule (neighbours x)) (= (neighbours x) 3)))\n        new-board (set (filter #(update-rule %) indices))]\n    (map (fn [r] (apply str (map #(if (new-board [r %]) \\# \\space) cols))) rows)))","user":"58a0fc33e4b02bd94d917ea3"},{"code":"(fn game-of-life-update [board]\n  (let [nrows (count board)\n        ncols (count (first board))]\n    (letfn [(get-cell [[nrow ncol]]\n              (if (or (< nrow 0) (< ncol 0)\n                      (>= nrow nrows) (>= ncol ncols))\n                \\*\n                (nth (nth board nrow) ncol)))\n            (and+-1 [n]\n              (map #(+ n %) '(-1 0 1)))\n            (cell-neighbours [[nrow ncol]]\n              (map get-cell\n                   (remove #(= % [nrow ncol])\n                           (reduce into [] (map (fn [row]\n                                                  (map #(vector row %) (and+-1 ncol)))\n                                                (and+-1 nrow))))))\n            (count-dead-neighbours [cell]\n              (count (filter #(= % \\space) (cell-neighbours cell))))\n            (count-live-neighbours [cell]\n              (count (filter #(= % \\#) (cell-neighbours cell))))\n            (update-living-cell [cell]\n              (case (count-live-neighbours cell)\n                (2 3) \\#\n                \\space))\n            (update-dead-cell [cell]\n              (if (= (count-live-neighbours cell) 3)\n                \\#\n                \\space))\n            (update-cell [cell]\n              (if (= (get-cell cell) \\#)\n                (update-living-cell cell)\n                (update-dead-cell cell)))]\n      (let [updated-board (map-indexed (fn [nrow row]\n                                         (map #(update-cell [nrow %]) (range ncols))) board)]\n        (map #(apply str %) updated-board)))))","problem":94,"user":"4ff355a1e4b0678c553fc34d"},{"problem":94,"code":"(fn\n  [string-list]\n  (let [height (count string-list)\n        width (count (first string-list))\n        neighbours (fn [row col] (list (get-in string-list [(dec row) (dec col)])\n                                       (get-in string-list [(dec row) col])\n                                       (get-in string-list [(dec row) (inc col)])\n                                       (get-in string-list [row (dec col)])\n                                       (get-in string-list [row (inc col)])\n                                       (get-in string-list [(inc row) (dec col)])\n                                       (get-in string-list [(inc row) col])\n                                       (get-in string-list [(inc row) (inc col)])))]\n    (for [r (range height)]\n      (apply str\n        (for [c (range width)]\n         (let [live-neighbours (count (filter #(= \\# %) (neighbours r c)))]\n           (if (= \\space (get-in string-list [r c]))\n             (if (= 3 live-neighbours)\n               \\#\n               \\space)\n            (cond\n               (< live-neighbours 2) \\space\n               (> live-neighbours 3) \\space\n               :else \\#))))))))","user":"5d1b2b7de4b02ea6f0fb697a"},{"code":"(fn [board] \n  (letfn [(transform-point [point invalid? transform]\n          (if (or (nil? point) (invalid? point))\n            nil\n            (transform point)))\n        (up [point]\n          (transform-point point \n                           (fn [[r c]] (<= r 0)) \n                           (fn [[r c]] [(dec r) c])))\n        (down [point size]\n          (transform-point point\n                           (fn [[r c]] (>= r (dec size)))\n                           (fn [[r c]] [(inc r) c])))\n        (left [point]\n          (transform-point point\n                           (fn [[r c]] (<= c 0))\n                           (fn [[r c]] [r (dec c)])))\n        (right [point size]\n          (transform-point point\n                           (fn [[r c]] (>= c (dec size)))\n                           (fn [[r c]] [r (inc c)])))\n        (neighbors [point size]\n          (filter (complement nil?) [(up (left point)) (up point) (up (right point size))\n                                     (left point) (right point size)\n                                     (down (left point) size) (down point size) (down (right point size) size)]))\n        (alive? [board [r c]]\n          (= \\# (nth (nth board r) c)))\n        (neighbor-count [board point]\n          (count (filter #(alive? board %)\n                         (neighbors point (count board)))))\n        (next-generation [board size]\n          (for [r (range size)]\n            (apply str (into []\n                             (for [c (range size)]\n                               (let [neighbor-count (neighbor-count board [r c])\n                                     self-alive (alive? board [r c])]\n                                 (if self-alive\n                                   (case neighbor-count\n                                     (2 3) \\#\n                                     \\space)\n                                   (case neighbor-count\n                                     3 \\#\n                                     \\space))))))))]\n  (next-generation board (count board))))","problem":94,"user":"50d86fe2e4b01f0871336e67"},{"problem":94,"code":"(fn [input]\n  (loop [rowCount (first ((fn process [args]\n                            (loop [d [] s args]\n                              (if (empty? s) [(count (map first d)) (count (flatten (map first d))) (map first d)]\n                                (recur (conj d [(into [] (first s))]) (rest s))))) input)) \n         totalSpaces (second ((fn process [args]\n                                (loop [d [] s args]\n                                  (if (empty? s) [(count (map first d)) (count (flatten (map first d))) (map first d)]\n                                    (recur (conj d [(into [] (first s))]) (rest s))))) input)) \n         c 0 \n         row 0 \n         setVecs (into #{} ((fn deadAlive [boardTriple]\n                              (loop [c 0 total 0 alive [] row 0 board (flatten (nth boardTriple 2))]\n                                (if (= total (second boardTriple)) alive\n                                  (if (= c (first boardTriple)) (recur 0 (inc total) alive (inc row) board)\n                                    (if (= (first board) \\#) (recur (inc c) (inc total) (concat alive [[c row]]) row (rest board))\n                                      (recur (inc c) (inc total) alive row (rest board))))))) ((fn process [args]\n                                                                                                 (loop [d [] s args]\n                                                                                                   (if (empty? s) [(count (map first d)) (count (flatten (map first d))) (map first d)]\n                                                                                                     (recur (conj d [(into [] (first s))]) (rest s))))) input))) \n         total 0 \n         newAlive #{}\n         newBoard []]\n    (if (= total totalSpaces) ((fn board [alive rowC totalS]\n                                (loop [c 0 row 0 d [] current \"\"]\n                                  (if (= row (/ totalS rowC)) d\n                                    (if (= c rowC) (recur 0 (inc row) (conj d current) \"\")\n                                      (if (contains? alive [c row]) (recur (inc c) row d (str current \"#\"))\n                                        (recur (inc c) row d (str current \" \"))))))) newAlive rowCount totalSpaces)\n      (if (= c rowCount) (recur rowCount totalSpaces 0 (inc row) setVecs (inc total) newAlive newBoard)\n        (if (contains? setVecs [c row]) (if (and (< (count (clojure.set/intersection ((fn mapCreate [vec]\n                                                                                        (loop [d #{} c1 -1 c2 -1]\n                                                                                          (if (= c1 2) (clojure.set/difference d #{vec})\n                                                                                            (if (= c2 2) (recur d (inc c1) -1)\n                                                                                              (recur (conj d [(+ (first vec) c1) (+ (second vec) c2)]) c1 (inc c2)))))) [c row]) setVecs)) 4) (> (count (clojure.set/intersection ((fn mapCreate [vec]\n                                                                                                                                                                                                                                     (loop [d #{} c1 -1 c2 -1]\n                                                                                                                                                                                                                                       (if (= c1 2) (clojure.set/difference d #{vec})\n                                                                                                                                                                                                                                         (if (= c2 2) (recur d (inc c1) -1)\n                                                                                                                                                                                                                                           (recur (conj d [(+ (first vec) c1) (+ (second vec) c2)]) c1 (inc c2)))))) [c row]) setVecs)) 1)) (recur rowCount totalSpaces (inc c) row setVecs (inc total) (conj newAlive [c row]) newBoard)\n                                          (recur rowCount totalSpaces (inc c) row setVecs (inc total) newAlive newBoard))\n          (if (= (count (clojure.set/intersection ((fn mapCreate [vec]\n                                                     (loop [d #{} c1 -1 c2 -1]\n                                                       (if (= c1 2) (clojure.set/difference d #{vec})\n                                                         (if (= c2 2) (recur d (inc c1) -1)\n                                                           (recur (conj d [(+ (first vec) c1) (+ (second vec) c2)]) c1 (inc c2)))))) [c row]) setVecs)) 3) (recur rowCount totalSpaces (inc c) row setVecs (inc total) (conj newAlive [c row]) newBoard)\n            (recur rowCount totalSpaces (inc c) row setVecs (inc total) newAlive newBoard)))))))","user":"558378dce4b05c286339e115"},{"problem":94,"code":"(fn game-of-life[s]\n  (letfn [\n      (neighbors\n        ([size yx] (neighbors [[-1 0] [1 0] [0 -1] [0 1] [-1 -1] [1 1] [-1 1] [1 -1]] size yx))\n        ([deltas size yx]\n          (filter (fn [new-yx]\n            (every? #(< -1 % size) new-yx))\n            (map #(vec (map + yx %)) deltas))\n        )\n      )\n      (get-live-neighbors [s xy]\n        (let [size (count s) neighbors-xy (neighbors size xy)]\n            (count (filter #{\\#} (for [[x y] neighbors-xy] (nth (nth s x) y))))\n        )\n      )\n      (new-state[s [x y]]\n        (let [cell (nth (nth s x) y)\n              live-neighbors (get-live-neighbors s [x y])]\n          (cond\n            (and (= cell \\#) (< live-neighbors 2)) \\space\n            (and (= cell \\#) (>= live-neighbors 2) (<= live-neighbors 3)) \\#\n            (and (= cell \\#) (> live-neighbors 3)) \\space\n            (and (= cell \\space) (= live-neighbors 3)) \\#\n            :else \\space\n          )\n        )  \n      )\n    ]\n    (let [size (count s)\n          rows (partition size (for [x (range 0 size) y (range 0 size)] [x y]))]\n      (for [row rows] (apply str (map #(new-state s %) row)))\n    )\n  )\n)","user":"59a0262ee4b0871e7608b82d"},{"problem":94,"code":"(fn game-of-life [input]\n  (let [board (mapv vec input)\n        height (count board)\n        width (count (first board))\n        all-coords (partition width\n                              (for [y (range height)\n                                    x (range width)]\n                                [x y]))]\n    (letfn [(board-to-str [board]\n              (mapv (partial apply str) board))\n\n            (neighbours-coords [[x y]]\n              (for [xs [(dec x) x (inc x)]\n                    ys [(dec y) y (inc y)]\n                    :when (not (and (= xs x) (= ys y)))]\n                [xs ys]))\n\n            (neighbours [[x y]]\n              (map #(get-in board %)(neighbours-coords [y x])))\n\n            (neighbours-count [[x y]]\n              (count\n               (filter #(= \\# %) (neighbours [x y]))))\n\n            (alive? [[x y]]\n              (= \\#\n                 (get-in board [y x])))\n\n            (lives? [[x y]]\n              (let [n (neighbours-count [x y])]\n                (if (alive? [x y])\n                  (cond\n                    (< n 2) \\space ;; Lonely\n                    (> n 3) \\space ;; Overpopulation\n                    :else \\#)\n                  (cond\n                    (= 3 n) \\# ;; Reproduction\n                    :else \\space))))]\n      (board-to-str\n       (mapv\n        (fn [row] (mapv (fn [cell] (lives? cell)) row))\n        all-coords)))))","user":"56069006e4b08b23635d3174"},{"code":"(fn [b]\n  (let [rows (count b)\n        cols (count (first b))\n        bp (apply str (concat [(apply str (repeat (+ 2 cols) \" \"))]\n                   (map #(str \" \" % \" \") b)\n                   [(apply str (repeat (+ 2 cols) \" \"))]))\n        f (fn [i e]\n            (let [row (quot i cols)\n                  col (mod i cols)\n                  cols (+ 2 cols)\n                  adj [(+ (* row cols) col) (+ (* row cols) col 1) (+ (* row cols) col 2)\n                       (+ (* (inc row) cols) col) (+ (* (inc row) cols) col 2)\n                       (+ (* (+ 2 row) cols) col) (+ (* (+ 2 row) cols) col 1) (+ (* (+ 2 row) cols) col 2)\n                       ]\n                  adj (count (filter (partial = \\#) (map #(nth bp %) adj)))\n                  ]\n              (if (= \\# e)\n                (if (or (< adj 2) (> adj 3))\n                  \\space\n                  \\#)\n                (if (= adj 3)\n                  \\#\n                  \\space))))\n        res (map-indexed f (apply str b) )]\n    (map (partial apply str) (partition cols res))\n  ))","problem":94,"user":"5349ac2be4b084c2834f4a67"},{"problem":94,"code":"(fn [rows]\n  (let [board (vec (map #(vec (map {\\  false \\# true} %)) rows))\n        get-cell (fn [x y] \n                   (if (and (contains? board y) (contains? (board y) x) ((board y) x)) 1 0))\n        count-neighbours (fn [x y]\n                           (+ (get-cell (dec x) (dec y)) (get-cell x (dec y)) (get-cell (inc x) (dec y))  \n                              (get-cell (dec x) y)                            (get-cell (inc x) y)\n                              (get-cell (dec x) (inc y)) (get-cell x (inc y)) (get-cell (inc x) (inc y))))\n        get-new (fn [x y]\n                  (let [alive (= 1 (get-cell x y) )\n                        live-neighbours (count-neighbours x y)]\n                    (or (and alive (= live-neighbours 2))\n                        (= live-neighbours 3))))\n        new-board (for [y (range (count board))]\n                    (for [x (range (count (board y)))]\n                      (get-new x y)))]\n    (map (fn [row] (apply str (map {false \\  true \\#} row))) new-board)))","user":"54febf4be4b07d26eda61d45"},{"code":"(fn [field]\r\n  (letfn [(dimension [field]\r\n            [(dec (count (first field)))\r\n             (dec (count field))])\r\n\r\n          (cell [field x y]\r\n            (if (= (get (get field y) x) \\#)\r\n              true\r\n              false))\r\n\r\n          (cells-around [filed x y]\r\n            (count\r\n             (filter true?\r\n                     (list\r\n                      (cell field x (inc y))\r\n                      (cell field x (dec y))\r\n                      (cell field (dec x) y)\r\n                      (cell field (inc x) y)\r\n                      (cell field (dec x) (dec y))\r\n                      (cell field (inc x) (dec y))\r\n                      (cell field (dec x) (inc y))\r\n                      (cell field (inc x) (inc y))))))\r\n\r\n          (rule [alive count]\r\n            (if alive\r\n              (cond\r\n               (< count 2) \\space\r\n               (<= count 3) \\#\r\n               (> count 3) \\space)\r\n              (if (= count 3) \\#\r\n                  \\space)))] \r\n    (loop [y (second (dimension field)) acc ()]\r\n      (let [xs (loop [x (first (dimension field)) acc \"\"]\r\n                 (if (neg? x)\r\n                   acc\r\n                   (recur (dec x)\r\n                          (str (rule (cell field x y)\r\n                                     (cells-around field x y))\r\n                               acc))))]\r\n        (if (neg? y)\r\n          acc\r\n          (recur (dec y) (conj acc xs)))))))","problem":94,"user":"4e0d8c27535d04ed9115e7b7"},{"problem":94,"code":"(fn myf [board]\n  (letfn [(coor [board x y]\n            (let [limit (dec (count board))] \n               (if (or (< x 0) (> x limit) (< y 0) (> y limit)) \\space\n                 (nth (nth board y) x))))\n          (next-state [board x y]\n                     (let [center (nth (nth board y) x)\n                           neighbors (for [dx [x (inc x) (dec x)]\n                                           dy [y (inc y) (dec y)]\n                                           :when (or (not= dx x) (not= dy y))]\n                                       (coor board dx dy))\n                           live-neigh-cnt (count (filter #(= % \\#) neighbors))]\n                       (cond (= live-neigh-cnt 3) \\#\n                             (and (= live-neigh-cnt 2) (= center \\#)) \\#\n                             :else \\space)))]\n  (->> (for [x (range (count board)), y (range (count board))]\n         (next-state board y x))\n    (partition (count board))\n    (map #(apply str %)))))","user":"577c3da9e4b0c8d87281f6b9"},{"problem":94,"code":"(fn life-game [state]\n  (letfn\n    [(living [r c]\n             (= \\# (get-in state [r c])))\n     (neighbor [r c]\n               (for [i (range (- r 1) (+ r 2))\n                     j (range (- c 1) (+ c 2))\n                     :when (or (not= i r) (not= j c))]\n                 [i j]))\n     (outcome [r c]\n              (let [self (living r c)\n                    living-neighbors (->> (neighbor r c)\n                                          (map (fn [[r c]] (if (living r c) 1 0)))\n                                          (reduce + ))]\n                (do\n                  (println r c self living-neighbors)\n                  (cond\n                    (and self\n                        (<= 2 living-neighbors)\n                        (>= 3 living-neighbors)) true\n                    (and (not self)\n                         (= 3 living-neighbors)) true\n                         :else false))))]\n    (for [i (range (count state))]\n      (apply str (for [j (range (count (get state 0)))]\n                   (if (outcome i j) \\# \\space))))))","user":"5479c58de4b0c51c1f4d72c7"},{"code":"(fn [world]\n  (let [w (count (first world))\n        h (count world)\n        in-world? (fn [[x y]]\n                    (and (>= x 0)\n                         (<= x w)\n                         (>= y 0)\n                         (<= y h)))\n        alive? (fn [[x y]]\n                 (and (in-world? [x y])\n                      (= \\# (get-in world [y x]))))\n        neighbours (fn [[x y]]\n                     (for [i [-1 0 1]\n                           j [-1 0 1]\n                           :when (not (= i j 0))]\n                       [(+ x i) (+ y j)]))\n        count-neighbours (fn [pos]\n                           (count (filter alive? (neighbours pos))))\n        next-state (fn [pos]\n                     (let [n (count-neighbours pos)]\n                         (if (or (= n 3)\n                                 (and (= n 2)\n                                      (alive? pos)))\n                           \"#\"\n                           \" \")))\n        evolve-line (fn [y]\n                      (apply str (map #(next-state [% y])\n                                      (range w))))]\n    (map evolve-line (range h))))","problem":94,"user":"4f8345c6e4b033992c121c1b"},{"problem":94,"code":"(fn [m A I b]\n  (I (fn [i r]\n       (A str (I (fn [j c]\n                   ({ 3 \\#\n                      2  c }\n                       (A + (map #({ \\# 1 } (get-in b (map + [i j] %)) 0)\n                                 [[m m][m 0][m 1]\n                                  [0 m]     [0 1]\n                                  [1 m][1 0][1 1]]))\n                       \\ ))\n                 r)))\n     b))\n-1 apply map-indexed","user":"51ad244fe4b09397d510977f"},{"problem":94,"code":"(fn [matrix-raw]\n  (let [matrix (->> matrix-raw (map vec) vec)\n        rows (count matrix)\n        cols (count (first matrix))\n        output (atom matrix)]\n    (doseq [r (range rows), c (range cols)]\n      (let [old-value (get-in matrix [r c])\n            neighbors (for [row [(dec r) r (inc r)]\n                            col [(dec c) c (inc c)]]\n                        (if (= [row col] [r c])\n                          nil\n                          (get-in matrix [row col])))\n            live-neighbors (count (filter #{\\#} neighbors))\n            new-value (cond\n                        (< live-neighbors 2) \\space\n                        (= live-neighbors 2) old-value\n                        (= live-neighbors 3) \\#\n                        (> live-neighbors 3) \\space)]\n        (swap! output assoc-in [r c] new-value)))\n    (map #(apply str %) (deref output))))","user":"58247423e4b051871117bec5"},{"problem":94,"code":"(fn life [board] (let [x-dim (count (first board)) y-dim (count board)]\n                   (map (partial apply str)\n                        (partition x-dim\n                                   (for [x (range x-dim) y (range y-dim)]\n                                     (let [neighbors (for [sub-x (range (dec x) (+ x 2)) sub-y (range (dec y) (+ y 2))]\n                                                       (cond\n                                                        (or (and (= sub-x x) (= sub-y y)) (< sub-x 0) (< sub-y 0) (>= sub-x x-dim) (>= sub-y y-dim)) nil\n                                                        :else (get-in board (vector sub-x sub-y))))\n                                           live-neighbor-count (count (filter #{\\#} neighbors))\n                                           this-cell (get-in board (vector x y))]\n                                       (cond\n                                        (and (= this-cell \\#) (< live-neighbor-count 2)) \\space\n                                        (and (= this-cell \\#) (< live-neighbor-count 4)) \\#\n                                        (= this-cell \\#) \\space\n                                        (and (= this-cell \\space) (= 3 live-neighbor-count)) \\#\n                                        :else \\space\n                                        )\n                                       ))))))","user":"56baab13e4b0f26550335948"},{"problem":94,"code":"(fn [v]  (letfn  [(val [v i j] (get (get v i) j))\n                          (positions [v i j] (reduce   (fn [[c1 c2] [x y]] (if (= \\# (get (get v x) y)) [(inc c1) c2] [c1 (inc c2)])) [0 0] (for [x1 [-1 0 1] x2 [-1 0 1] :when (and (not= [i j] [(+ i x1) (+ j x2)]) ((fn validpos [v i j] (and  (>= i 0) (>= j 0)  (< i (count v))  (< j (count (get v 0)))  )) v (+ i x1) (+ j x2)))] [(+ i x1) (+ j x2)])))\n                          (gett [w x] (if (= w \\#) (if (<= 2 x 3) \\# \\space) (if (= x 3) \\# \\space)))]\n                   (map-indexed (fn [i w] (apply str (map-indexed (fn [j c] (gett (val v i j) (first (positions v i j)))) w))) v)\n                    ))","user":"5c379636e4b0d62ef62d9f76"},{"problem":94,"code":"(fn [board]\n  (letfn [(count-neighbours [x y]\n            (->> (for [dx [-1 0 1]\n                       dy [-1 0 1]\n                       :let [x' (+ x dx)\n                             y' (+ y dy)]\n                       :when (or (not= x x') (not= y y'))]\n                   (get-in board [x' y']))\n                 (filter (partial = \\#))\n                 count))]\n    (for [x (range (count board))]\n      (apply str (for [y (range (count (board x)))]\n                   (let [cnt (count-neighbours x y)\n                         cell (get-in board [x y])]\n                     (cond\n                       (and (= cell \\#) (#{2 3} cnt)) \\#\n                       (and (= cell \\space) (= cnt 3)) \\#\n                       (= cell \\#) \\space\n                       :else \\space)))))))","user":"561ca2eae4b064ca9f4b169b"},{"code":"(fn [rows]\n  (let [grid-size (count rows)]\n    (letfn [(occupied? [i j]\n                 (cond\n                  (or (< i 0) (>= i grid-size) (< j 0) (>= j grid-size)) false\n                  (= \\# (nth (nth rows i) j)) true\n                  :else false))\n            (count-neighbours [i j]\n                              (count (for [x [(dec i) i (inc i)]\n                                           y [(dec j) j (inc j)]\n                                           :when (or (not= x i) (not= y j))\n                                           :when (occupied? x y)]\n                                       true)))\n            (alive? [i j]\n                    (let [neighbours (count-neighbours i j)]\n                      (or (= neighbours 3) (and (= neighbours 2) (occupied? i j)))))]\n      (let [next-step (for [i (range 0 grid-size)\n                            j (range 0 grid-size)]\n                        (alive? i j))]\n        (->> next-step\n             (map #(if % \\# \\space))\n             (partition grid-size)\n             (map (partial apply str))\n             (vec)\n             )))))","problem":94,"user":"536ca4bde4b0fc7073fd6e49"},{"problem":94,"code":"(fn life-step [strs]\n  (let [to-map2d (fn [strings] (into {} (apply concat (map-indexed (fn [y string] (map-indexed #(vector [y %1] %2) (seq string))) strings))))\n        from-map2d (fn [map2d] (let [indexes (partition-by first (sort (keys map2d)))\n                                     values (map (fn [ixs] (map map2d ixs)) indexes)]\n                                  (map #(apply str %) values)))\n        adjacent-indices (fn [[r c]] (for [f [dec identity inc]\n                                           g [dec identity inc]\n                                           :when (or (not= f identity)\n                                                     (not= g identity))]\n                                       [(f r) (g c)]))\n        get-adjacent (fn [map2d index] (for [adj (adjacent-indices index)]\n                                          (get map2d adj)))\n\n        gol-rules (fn [map2d index]\n                    (let [alive? (= \\# (get map2d index))\n                          sum (count (filter #(= \\# %) (get-adjacent map2d index)))]\n                      (cond (and alive? (<= 2 sum 3)) \\#\n                            (and (not alive?) (= sum 3)) \\#\n                            :else \\space)))\n        m2d (to-map2d strs)]\n      (from-map2d (into {} (map #(vector % (gol-rules m2d %)) (keys m2d))))))","user":"5a566e8fe4b05d388ecb6c51"},{"problem":94,"code":"(fn [sar]\n  (let [n (count sar)\n        ns [(- -1 n) (- 0 n) (- 1 n) -1 1 (+ -1 n) n (+ 1 n)]\n        se (mapcat seq sar)\n        nbrs (fn [i] (map (partial nth se) (remove #(or (> 0 %) (<= (* n n) %)) (map (partial + i) ns))))\n        next-gen (fn [t n]\n                   (let [lc (reduce #(if (= \\# %2) (inc %) %) 0 n)]\n                     (if (or (< lc 2) (> lc 3) ; 1) 3)\n                           (if (= t \\#)\n                             false ; 2)\n                             (= lc 2))) \" \" \"#\")))] ; 4)\n    (into [] (map #(apply str %)\n      (loop [c 0 s se r []]\n          (if (> c (* n n))\n            (map #(into [] %) (partition n (flatten r)))\n            (recur (inc c) (rest s) (conj r (next-gen (first s) (nbrs c))))))))))","user":"551c66dae4b07993ea3788de"},{"code":"(fn [board]\n  (map (partial apply str)\n    (let [n (count board)\n          m (count (board 0))\n          dirs [[0 1] [0 -1] [1 0] [-1 0] [-1 1] [1 -1] [-1 -1] [1 1]]\n          cell (fn [board [x y]]\n                 (-> board (nth x) (nth y)))\n          live? (fn [board [x y]]\n                  (and\n                    (>= x 0) (>= y 0) (< x n) (< y m)\n                    (= \\# (cell board [x y]))))]\n      (for [x (range n)]\n        (for [y (range m)]\n          (let [neibs (count (filter (partial live? board)\n                               (map #(vec (map + [x y] %)) dirs)))\n                next (if (live? board [x y])\n                       (and (>= neibs 2) (<= neibs 3))\n                       (= neibs 3))]\n                (if next \\# \\space)))))))","problem":94,"user":"527cd633e4b0757a1b17136f"},{"problem":94,"code":"(fn [board]\n    (let [\n\n          row-count (count board)\n          column-count (->> board (first) (count))\n          live? (fn [[x y]] (-> board (nth y) (nth x) (= \\#)))\n          alive \\#\n          dead \\space\n          stayin-alive? (fn [alive? neighbs] (if (= true alive?)\n                                               (cond\n                                                 (< neighbs 2) dead\n                                                 (< neighbs 4) alive\n                                                 :else dead\n                                                 )\n                                               (if (= 3 neighbs) alive dead)))\n          in-bounds? (fn [[x y]] (reduce (partial = true) [(>= x 0) (< x column-count) (>= y 0) (< y row-count)]))\n          sides [[0 -1] [1 -1] [1 0] [1 1] [0 1] [-1 1] [-1 0] [-1 -1]]\n          neighbors (fn [cell] (map #(map + cell %) sides))\n          in-bounds-neighbors (fn [cell] (->> cell (neighbors) (filter in-bounds?)))\n          living-neighbors (fn [cell] (->> cell (in-bounds-neighbors) (filter live?)))\n\n          cell-state (for [\n                           y (range row-count)\n                           x (range column-count)\n                           :let [\n                                 cell [x y]\n                                 live (live? cell)\n                                 ns (->> cell (living-neighbors) (count))\n                                 ]\n\n                           ]\n                       [live ns]\n                       )\n          new-state (map (partial apply stayin-alive?) cell-state)\n          new-board (->> new-state (partition column-count) (map (partial apply str)))\n\n          ]\n      new-board\n      )\n    )","user":"516ee939e4b06aac486e5b34"},{"problem":94,"code":"(fn [cells]\n  (letfn [(add-cells [line]\n                    (concat [(last line)] line [(first line)]))\n          (change-state [[c1 [c21 c22 c23] c3]]\n                        (let [neighs (concat c1 c3 [c21 c23])\n                              lives (->> neighs(filter (partial = \\#)) count)]                          \n                          (cond\n                           (and (= c22 \\#) (or (< lives 2) (> lives 3))) \\space\n                           (and (= c22 \\#) (or (= lives 2) (= lives 3))) c22\n                           (and (= c22 \\space) (= lives 3)) \\#\n                           :else c22)))\n          (partition-3 [line](partition 3 1 line))]\n    (->> cells \n         (map seq) \n         (map add-cells) \n         (add-cells) \n         partition-3\n         (map #(map partition-3 %))\n         (map #(apply map (fn [c1 c2 c3] (vector c1 c2 c3)) %))\n         (map #(map change-state %))\n         (map (partial apply str)))))","user":"536f871de4b0fc7073fd6e7f"},{"code":"(fn [board]\n  (letfn [ (remap [board]\n    (->> (for [v board] \n           (->> (map (fn [c] (if (= (str c) \" \") 0 1)) v)\n                (apply vector)))\n          (apply vector)))\n(unmap [matrix]\n    (->> (for [v matrix] \n           (->> (map (fn [b] (if (zero? b) \" \" \"#\")) v)\n                (apply str)))\n          (apply vector)))\n(cneigh [matrix x y]\n   (let [n (count matrix)\n         left (mod (dec x) n)\n         right (mod (inc x) n)\n         up   (mod (dec y) n)\n         down (mod (inc y) n)]\n     (->>\n         (for [[a b] [[left up] [x up]  [right up]\n                     [left y]           [right y]\n                     [left down][x down][right down]]]\n               ((matrix a)b))\n               (reduce +)))) \n(nextgen [matrix]\n  (let [n (count matrix)]\n    (->>\n      (for [x (range n)] \n    (->>\n           (for [y (range n)]\n              (let [neighbors (cneigh matrix x y)]\n                 (if (zero? ((matrix x)y))\n\t\t\t\t    (if (= neighbors 3) 1 0)\n                    (cond\n                         (or (= neighbors 2) (= neighbors 3)) 1\n                         :else 0))))\n \t\t\t(apply vector)))\n\t  (apply vector))))]\n   (->> board (remap) (nextgen) (unmap))))","problem":94,"user":"50705072e4b07bd6ad9b9f27"},{"problem":94,"code":"(fn [b]\n  (let [adj [[-1 -1] [-1 0] [-1 1] [0 -1] [0 1] [1 -1] [1 0] [1 1]]\n        update (fn [cell c] (case cell\n                              \\# (cond\n                                  (< c 2) \\ \n                                  (<= 2 c 3) \\#\n                                  :else \\ )\n                              (if (= 3 c) \\# cell)))]\n    (for [x (range (count b))]\n      (apply str (for [y (range (count (b 0)))]\n                   (let [cell (-> b (get x) (get y))\n                         neighbors (for [[dx dy] adj]\n                                     (-> b (get (+ x dx)) (get (+ y dy))))\n                         c (count (filter #(= \\# %) neighbors))]\n                     (update cell c)))))))","user":"552a793ee4b0ffed3738f955"},{"problem":94,"code":"(fn [ss]\n          (let\n            [one (reduce into [] (map #(map (fn[ch] (if (= ch \\#) 1 0)) %) ss))\n             size (count (first ss))\n             delta [(- (- size) 1) (- size) (+ (- size) 1) -1 1 (- size 1) size (+ size 1)]\n             neighbors (map (fn [idx]  (apply + (map #(nth one (+ idx %) 0) delta))) (range (* size size)))\n             flat (map #(if (or (and (= %1 1) (or (= %2 2) (= %2 3)))\n                                 (and (= %1 0) (= %2 3))\n                                 ) \\# \\ ) one neighbors)\n             ]\n            (mapv #(apply str %) (partition size flat))\n            )\n          )","user":"533c2605e4b0e30313ee6cd7"},{"problem":94,"code":"(fn generate [world]\n  (letfn [(trans [rows]\n            (vec (for [row rows]\n                   (vec (map #(if (= % \\#) :alive :dead) row)))))\n          (look [w]\n            (let [height (count w)\n                  length (count (first w))]\n              (fn [[x y]]\n                (if (or\n                      (neg? x)\n                      (neg? y)\n                      (>= x length)\n                      (>= y height))\n                  nil\n                  (-> w (nth y) (nth x))))))\n          (left-up [[x y]] [(dec x) (dec y)])\n          (right-up [[x y]] [(inc x) (dec y)])\n          (left-down [[x y]] [(dec x) (inc y)])\n          (right-down [[x y]] [(inc x) (inc y)])\n          (up [[x y]] [x (dec y)])\n          (down [[x y]] [x (inc y)])\n          (left [[x y]] [(dec x) y])\n          (right [[x y]] [(inc x) y])]\n    (let [xworld (trans world)\n          look-up (look xworld)\n          neighs [up, down, left, right, left-up, right-up, left-down, right-down]\n          extract (fn [idx] (->> neighs\n                                 (map (fn [f] (look-up (f idx))))\n                                 (filter #(= % :alive))\n                                 (count)))\n          revive? (fn [idx] (= 3 (extract idx)))\n          die-out? (fn [idx] (< (extract idx) 2))\n          exact? (fn [nx] (or (= nx 2) (= nx 3)))\n          survive? (fn [idx] (exact? (extract idx)))\n          die? (fn [idx] (> (extract idx) 3))]\n      (map-indexed (fn [y row]\n                     (apply str (map-indexed (fn [x cell]\n                                               (case cell\n                                                 :alive (cond\n                                                          (die? [x y]) \" \"\n                                                          (survive? [x y]) \"#\"\n                                                          (die-out? [x y]) \" \")\n                                                 :dead (if (revive? [x y])\n                                                         \"#\"\n                                                         \" \"))) row))) xworld))))","user":"565b941ce4b068f2fe63dc07"},{"code":"(fn [board]\n   (letfn [(num-of-neignbors [r c b]\n             (let [n (count b)]\n               (count (filter #(= % \\#)\n                              (for [x [-1 0 1]\n                                    y [-1 0 1]\n                                    :let [r2 (+ r x)\n                                          c2 (+ c y)]\n                                    :when (and (>= r2 0) (< r2 n)\n                                               (>= c2 0) (< c2 n)\n                                               (not (and (= x 0)\n                                                         (= y 0))))]\n                                (get-in b [r2 c2]))))))\n           (cell-of-next-gen [r c b]\n             (let [nb (num-of-neignbors r c b)]\n               (cond\n                (or (< nb 2) (> nb 3)) \" \"\n                (= (get-in b [r c]) \\#) \"#\"\n                (= nb 3) \"#\"\n                :else \" \")))]\n     (let [n (range (count board))]\n       (for [r n]\n         (apply str\n                (for [c n]\n                  (cell-of-next-gen r c board)))))))","problem":94,"user":"512eb723e4b0b740abc5982b"},{"problem":94,"code":"(fn next-generation-4clojure [board]\n  (letfn [(up [[i j]] [(dec i) j])\n          (down [[i j]] [(inc i) j])\n          (left [[i j]] [i (dec j)])\n          (right [[i j]] [i (inc j)])\n\n          (live? [board cell]\n                 (= (get-in board cell) \\#))\n\n          (group-neighbours [board cell]\n                            (let [fncts [up down left right (comp up left) (comp up right) (comp down left) (comp down right)]\n                                  neighbours (map #(get-in board (% cell)) fncts)\n                                  groups (group-by #(= \\# %) (filter (comp not nil?) neighbours))]\n                              [(get groups true) (get groups false)]))\n\n          (underpopulation?\n            [board cell]\n            {:pre [(= (get-in board cell) \\#)]}\n            (let [[live-neighbours _] (group-neighbours board cell)]\n              (< (count live-neighbours) 2)))\n\n          (overpopulation?\n            [board cell]\n            {:pre [(= (get-in board cell) \\#)]}\n            (let [[live-neighbours _] (group-neighbours board cell)]\n              (> (count live-neighbours) 3)))\n\n          (reproduction?\n            [board cell]\n            {:pre [(= (get-in board cell) \\space)]}\n            (let [[live-neighbours _] (group-neighbours board cell)]\n              (= (count live-neighbours) 3)))]\n    (let [nxt-gen (for [i (range (count board))]\n                    (apply str (for [j (range (count (board i)))\n                                     :let [cell [i j]\n                                           cell-val (get-in board cell)]]\n                                 (cond\n                                   (and (= \\# cell-val) (or (underpopulation? board cell) (overpopulation? board cell))) \\space\n                                   (and (= \\space cell-val) (reproduction? board cell)) \\#\n                                   :else cell-val))))]\n      (map #(apply str %) nxt-gen))))","user":"52e657e4e4b09f7907dd1472"},{"code":"(fn [board]\n  (for\n    [row (range (count board))\n     :let [live? (fn [[r c]]\n                   (cond (< r 0) false\n                         (>= r (count board)) false\n                         (< c 0) false\n                         (>= c (count (first board))) false\n                         1 (= \\# (nth (nth board r) c))))\n           neighbors (fn [R C]\n                       (count\n                         (filter true?\n                           (map live? [[(dec R) (dec C)]\n                                       [(dec R) C]\n                                       [(dec R) (inc C)]\n                                       [R (dec C)]\n                                       [R (inc C)]\n                                       [(inc R) (dec C)]\n                                       [(inc R) C]\n                                       [(inc R) (inc C)]]))))]]\n    (apply str\n      (for [col (range (count (board row)))\n            :let [N (neighbors row col)]]\n        (if (live? [row col])\n          (cond (< N 2) \" \"\n                (<= 2 N 3) \"#\"\n                (> N 3) \" \")\n          (if (= N 3) \"#\" \" \"))))))","problem":94,"user":"53806e5be4b06839e8705ec1"},{"code":"(fn [coll]\n  (letfn [(live-cells [coll]\n            (->> coll\n                 (map (fn [x] (map-indexed #(when (= %2 \\#) %) x)))\n                 (map #(remove nil? %))\n                 (map-indexed (fn [idx itm] (when itm (for [x itm] [idx x]))))\n                 (mapcat #(map flatten %))\n                 (map vec)\n                 set))\n          (neighbours [[x y]]\n            (for [dx [-1 0 1] dy [-1 0 1] :when (not= 0 dx dy)]\n              [(+ dx x) (+ dy y)]))\n          (step [cells]\n            (set (for [[loc n] (frequencies (mapcat neighbours cells))\n                       :when (or (= n 3) (and (= n 2) (cells loc)))]\n                   loc)))\n          (empty-board [w h]\n            (vec (repeat w (vec (repeat h \\space)))))\n          (populate [board living-cells]\n            (reduce (fn [board coordinates]\n                      (assoc-in board coordinates \\#))\n                    board\n                    living-cells))\n          ]\n    (->> coll\n         live-cells\n         step\n         (populate (empty-board (count coll) (count coll)))\n         (map #(apply str %)))))","problem":94,"user":"50645e12e4b007509339a58a"},{"problem":94,"code":"(fn [board]\n  (let [rows (count board)\n        cols (count (first board))\n        live? (fn [r c]\n                (let [r (mod r rows)\n                      c (mod c cols)]\n                  (= \\# (get-in board [r c]))))\n        live-count (fn [r c]\n                     (->> (for [r (range -1 2)\n                                c (range -1 2)\n                                :when (or (not= r 0) (not= c 0))]\n                            [r c])\n                          (filter #(live? (+ r (first %))\n                                          (+ c (second %))))\n                          count))\n        next-cell (fn [[r c]]\n                    (let [live (live-count r c)]\n                      (if (= \\# (get-in board [r c]))\n                        (if (or (< live 2) (> live 3))\n                          \\space\n                          \\#)\n                        (if (= live 3) \\# \\space))))]\n    (for [r (range rows)]\n      (apply str (map next-cell\n                      (for [c (range cols)]\n                        [r c]))))))","user":"549c6792e4b0f3d1d8e70f8b"},{"problem":94,"code":"(fn gol\n  [rows]\n  (let [n (count rows)\n        m (count (first rows))\n        live (set\n               (for [i (range 0 n)\n                     j (range 0 m)\n                     :when (-> rows (nth i) (nth j) (= \\#))]\n                 [i j]))\n        vecs #{[-1 -1] [-1 0] [-1 1] [0 -1] [0 1] [1 -1] [1 0] [1 1]}\n        living-neighbors (fn [p]\n                           (->> vecs (map #(map + % p)) (filter live)))\n        alive-next-iteration? (fn [p]\n                                (let [c (count (living-neighbors p))]\n                                  (if (live p)\n                                    (<= 2 c 3)\n                                    (= c 3))))]\n    (for [i (range 0 n)]\n      (apply str (for [j (range 0 m)]\n                   (if (alive-next-iteration? [i j]) \"#\" \" \"))))))","user":"5d0bb4fae4b0cc9c91588237"},{"problem":94,"code":"(fn [board] \n  (letfn [(cell [b x y]\n            (-> b\n                (nth y \" \")\n                (nth x \\space))) \n          (neighbors [b x y]\n            (let [offsets [ [-1 -1] [0 -1] [1 -1]\n                           [-1 0] [1 0]\n                           [-1 1] [0 1] [1 1]]\n                  coords (map (fn [[x1 y1]] [(+ x x1) (+ y y1)]) offsets)]\n              (map (fn [[x2 y2]] (cell board x2 y2)) coords)))\n          (num-live-neighbors [b x y]\n            (count (filter (partial = \\#) (neighbors b x y))))\n          (next-val [b x y]\n            (let [n (num-live-neighbors b x y)]\n              (cond\n                (< n 2) \\space\n                (= n 2) (cell b x y)\n                (= n 3) \\#\n                (> n 3) \\space)))\n          (dim [b] [(count (first b)) (count b)])\n          (next-row [b n]\n            (apply str (map #(next-val b % n) (range (first (dim b))))))\n          (next-board [b]\n            (map #(next-row b %) (range (second (dim b)))))\n          ] \n\n    (next-board board)\n)\n)","user":"55f09e7be4b06e875b46ce28"},{"problem":94,"code":"(fn game-of-life\n  [world]\n  (letfn [(is-alive? [c] (= \\# c))\n          (conway-law [x y]\n            (let [cell (get-in world [x y])\n                  neighbours (keep (partial get-in world) [[(dec x) y]\n                                                           [(dec x) (dec y)]\n                                                           [(dec x) (inc y)]\n                                                           [x (dec y)]\n                                                           [x (inc y)]\n                                                           [(inc x) (inc y)]\n                                                           [(inc x) y]\n                                                           [(inc x) (dec y)]])\n                  live-neibours (count (filter is-alive? neighbours))]\n              (cond\n                (and (is-alive? cell) (> 2 live-neibours)) \" \"\n                (and (is-alive? cell) (or (= 2 live-neibours)\n                                          (= 3 live-neibours))) \"#\"\n                (and (is-alive? cell) (> live-neibours 3)) \" \"\n                (and (not (is-alive? cell)) (= 3 live-neibours)) \"#\"\n                :else \" \")))]\n    (mapv #(reduce (fn [r y] (str r (conway-law % y))) \"\" (range (count world)))\n          (range (count (first world))))))","user":"5125029de4b0ce9225d2ed3e"},{"problem":94,"code":"(fn life [b]\n  (let [swell (fn [b]\n                (reduce into [] [[(apply str (repeat (+ 2 (count (first b))) \" \"))]\n                                 (map #(str \" \" % \" \") b)\n                                 [(apply str (repeat (+ 2 (count (first b))) \" \"))]]))\n        strings (mapv vec (swell b))\n        rows (count strings)\n        columns (count (first strings))]\n    (map #(apply str %)\n         (partition (- rows 2)\n                    (for [i (range 1 (dec rows))\n                          j (range 1 (dec columns))]\n                      (let [cnt (reduce\n                                 + \n                                 (for [x [(dec i) i (inc i)]\n                                       y [(dec j) j (inc j)]\n                                       :when (not (and (= x i) (= y j)))]\n                                   (if (= ((strings x) y) \\space) 0 1)))]\n                        (if (= ((strings i) j) \\space)\n                          (if (= cnt 3) \\# \\space)\n                          (if (or (= cnt 2) (= cnt 3)) \\# \\space))))))))","user":"53973e7be4b0b51d73faaee6"},{"code":"(fn [g] \n  (let [c (count g)\n        r (range c)]\n    (map #(apply str %) \n         (partition c \n           (for [x r y r]\n             (let \n               [n (apply +\n                   (for [i r j r :when (and (#{(- x 1) x (+ x 1)} i) (#{(- y 1) y (+ y 1)} j) (not= [i j] [x y]))]\n                     (if (= (get (g i) j) \\#) 1 0)))]\n               (if (or (and (= (get (g x) y) \\#) (#{2 3} n)) (= 3 n)) \\# \\space)))))))","problem":94,"user":"4f1d1d95535d64f603146488"},{"problem":94,"code":"(fn [board]\n    (let [size-row (count (first board))\n          size (* size-row size-row)\n          max-index (dec size-row)\n          board (apply vector (apply str board))\n          \n          index-to-position\n          (fn [index]\n            {:x (mod index size-row) :y (quot index size-row)})\n\n          cells-around-position\n          (fn [position]\n            (let [x (position :x)\n                  y (position :y)]\n              (filter #(and (>= (% 0) 0)\n                            (<= (% 0) max-index)\n                            (>= (% 1) 0)\n                            (<= (% 1) max-index))\n                      [[(dec x) (dec y)] [x (dec y)] [(inc x) (dec y)]\n                       [(dec x) y] [(inc x) y]\n                       [(dec x) (inc y)] [x (inc y)] [(inc x) (inc y)]])))\n\n          get-board-value\n          (fn [[x y]]\n            (if (= (board (+ x (* size-row y))) \\#)\n              1 0))         \n\n          get-board-sum\n          (fn [cells]\n            (reduce (fn [sum cell] (+ sum (get-board-value cell))) 0 cells))\n\n          ]\n\n      (->> (range size)\n           (map index-to-position)\n           (map cells-around-position)\n           (map get-board-sum)\n           (map (fn [cell sum]\n                  (cond\n                    (< sum 2) \" \"\n                    (and (= sum 2) (= cell \\#)) \"#\"\n                    (= sum 2) \" \"\n                    (= sum 3) \"#\"\n                    (> sum 3) \" \"))\n                board)\n           (partition size-row)\n           (map (partial apply str))\n           )))","user":"5a062e07e4b01bb0ae8afdc5"},{"problem":94,"code":"(fn [board]\n  (letfn [(in-board? [rowi coli]\n            (and (contains? board rowi)\n                 (contains? (nth board rowi) coli)))\n          (hood-count [rowi coli]\n            (->> [[-1 -1] [-1 0] [-1 1] [0 -1] [0 1] [1 -1] [1 0] [1 1]]\n                 (map (fn [[x y]] [(+ rowi x) (+ coli y)]))\n                 (filter (partial apply in-board?))\n                 (map (fn [[x y]] (-> board (nth x) (nth y))))\n                 (filter #{\\#})\n                 (count)))\n          (life [item neighbours]\n            (if (= item \\#)\n              (if (or (= neighbours 2) (= neighbours 3)) \\# \\space)\n              (if (= neighbours 3) \\# \\space)))]\n    (->>\n      (for [[rowi row] (map-indexed vector board)\n            [coli col] (map-indexed vector row)]\n        (life col (hood-count rowi coli)))\n      (partition (count (first board)))\n      (map (partial apply str)))))","user":"5515b138e4b055c2f668d4ed"},{"code":"(fn [z] (let [s (vec (map vec z))\n              n (count s)\n              m (count (first s))\n              d [-1 0 1]\n              R range\n              P \\space\n              W \\#]\n  (letfn [(g [x y] \n    (let [v (get-in s [x y])\n          q (apply + (for [a d b d]\n        (if (= W (get-in s [(+ a x) (+ b y)]))\n          1\n          0)))]\n      (cond \n        (and (= P v) (= q 3)) W\n        (and (= W v) (> q 2) (< q 5)) W\n        :else P)))]\n    (map #(apply str %) (for [x (R 0 n)]\n      (for [y (R 0 m)]\n        (g x y)))\n  \n))))","problem":94,"user":"4f01c938535dcb61093f6a39"},{"problem":94,"code":"(fn [grid]\n  (let [h (count grid)\n        w (count (first grid))\n        encode (fn [g] (vec (map (fn [r] (vec (map #(= \\# %) r))) g)))\n        decode (fn [g] (vec (map (fn [r] (apply str (map #(if % \\# \\ ) r))) g)))\n        egrid (encode grid)\n        deltas (for [dx [-1 0 1] dy [-1 0 1] :when (not (= dx dy 0))] [dx dy])\n        neighbors (fn [x y] (->> deltas\n                                (map (fn [[dx dy]] [(+ x dx) (+ y dy)]))\n                                (filter (fn [[x y]] (and (>= x 0) (< x w) (>= y 0) (< y h))))))\n        next (fn [x y] (let [alive (count (filter (fn [[x y]] (get-in egrid [y x])) (neighbors x y)))]\n                           (boolean ((if (get-in egrid [y x]) #{2 3} #{3}) alive))))]\n    (decode\n      (reduce\n        (fn [g [x y]] (assoc-in g [y x] (next x y)))\n        egrid\n        (for [x (range w) y (range h)] [x y])))))","user":"5db92996e4b010eb3c36cd50"},{"problem":94,"code":"(fn [s]\n  (let [s (mapv vec s), t {\\# \\space, \\space \\#}\n        g [inc dec identity], x (count (first s)), y (count s)]\n    (letfn [(c [p q] \n              (for [a (map #(% p) g) b (map #(% q) g)\n                    :when (and (< -1 a x) (< -1 b y) (not= [a b] [p q]))]\n                  ((s a) b)))\n            (j [f s]\n              (for [a (range x) b (range y)]\n                [((s a) b) (count (filter #{\\#} (f a b)))]))\n            (k [[o p]]\n              (if (= o \\#)\n                  (if (#{2 3} p) o (t o))\n                  (if (= 3 p) (t o) o)))]\n      (mapv #(apply str %) (partition x (map k (j c s)))))))","user":"548b7db8e4b0e286459a11fd"},{"problem":94,"code":"(fn game-of-life [board]\n  (let [height (count board)\n        width (count (first board))\n        valid-sq (fn [[x y]] (and (not (neg? x)) (not (neg? y)) (< x height) (< y width)))\n        neighbors (fn [x y]\n                    (filter valid-sq\n                            [\n                            [(dec x) (dec y)] [(dec x) y] [(dec x) (inc y)]\n                            [x (dec y)] [x (inc y)]\n                            [(inc x) (dec y)] [(inc x) y] [(inc x) (inc y)]\n                            ]))        \n        num-live-neighbors (fn [x y] (count (filter #(= \\# (get-in board %)) (neighbors x y))))]\n    (for [x (range height)]\n      (apply str\n      (for [y (range width)]\n        (if (= \\# (get-in board [x y])) ; live cell\n          (if (#{2, 3} (num-live-neighbors x y)) \\# \\space)\n          (if (= 3 (num-live-neighbors x y)) \\# \\space)))))))","user":"54448e84e4b032a45b869393"},{"problem":94,"code":"(letfn \n  [(f1 [w i j]\n     (let [c (for [a [0 -1 1] b [0 -1 1]]\n               (if (= \\# (get-in w [(+ i a) (+ j b)])) 1 0))]\n       (let [x (first c) y (apply + (rest c))]\n         (if (= 0 x) (if (= 3 y) \\# \\space)\n           (if (or (< y 2) (> y 3)) \\space\n             \\#)))))\n\n   (f2 [w]\n     (let [r (range 1 (dec (count w)))]\n       (for [i r j r]\n         [i j (f1 w i j)])))]\n\n  (fn [w]\n    (map #(apply str %)\n         (reduce (fn [x [i j v]] (assoc-in x [i j] v)) \n                 (vec (map vec w)) \n                 (f2 w)))))","user":"53065acbe4b02e8216869792"},{"problem":94,"code":"(fn [rows]\n  (let [neighbor-offsets [[-1 -1] [-1  0] [-1  1]\n                          [ 0 -1]         [ 0  1]\n                          [ 1 -1] [ 1  0] [ 1  1]]\n        alive \\#\n        dead \\space\n        num-rows count\n        num-cols (comp count first)]\n    \n    (letfn [(valid-point? [rows [x y]]\n              (and (<= 0 x (dec (num-rows rows)))\n                   (<= 0 y (dec (num-cols rows)))))\n\n            (find-neighbor-points [rows point]\n              (->> (map #(map + % point) neighbor-offsets)\n                   (filter #(valid-point? rows %))))\n\n            (lookup-status [rows [x y]]\n              (let [row (nth rows x)]\n                (nth row y)))\n\n            (find-alive-neighbors [rows point]\n              (->> (find-neighbor-points rows point)\n                   (map #(lookup-status rows %))\n                   (filter #{alive})\n                   (count)))\n\n            (next-status [status alive-neighbors]\n              (let [rules {alive #{2 3}\n                           dead #{3}}\n                    rule (get rules status)]\n                (if (rule alive-neighbors)\n                  alive\n                  dead)))\n\n            (next-cell-val [rows point]\n              (next-status (lookup-status rows point)\n                           (find-alive-neighbors rows point)))\n\n            (gen-points [rows]\n              (for [x (range (num-rows rows))\n                    y (range (num-cols rows))]\n                [x y]))\n\n            (make-rows [prev-rows statuses]\n              (->> statuses\n                   (partition (num-cols prev-rows))\n                   (map clojure.string/join)))\n\n            (run [rows]\n              (let [points (gen-points rows)\n                    new-statuses (map #(next-cell-val rows %) points)]\n                (->> (gen-points rows)\n                     (map #(next-cell-val rows %))\n                     (make-rows rows))))]\n      (run rows))))","user":"50e3e108e4b01912b3285c48"},{"code":"(fn [b]\n  (letfn [(within-board? [b [x y]]\n            (and (>= y 0)\n                 (< y (count b))\n                 (>= x 0)\n                 (< x (count (nth b y)))))\n\n          (is-live? [b [x y]]\n            (and\n             (within-board? b [x y])\n             (= \\# (nth (nth b y) x))))\n\n          (adjacent [[x y]]\n            (for [i (range (- x 1) (+ x 2))\n                  j (range (- y 1) (+ y 2))\n                  :when (not= [i j] [x y])]\n              [i j]))\n\n          (age-cell [b xy]\n            (let [n (count\n                     (filter (partial is-live? b) (adjacent xy)))]\n              (cond\n               (= n 2) (if (is-live? b xy) \\# \\ )\n\t       (= n 3) \\#\n               :else \\ )))]\n\n    (map-indexed (fn [y row]\n                   (apply str (map-indexed (fn [x cell]\n                                             (age-cell b [x y]))\n                                           row)))\n                 b))\n  )","problem":94,"user":"51b9d1f0e4b0e871ca49590b"},{"code":"(fn [board]\n  (let [live? (fn [x y] (= (get (get board y) x) \\#))\n        neighbours [[-1 -1] [-1 0] [-1 1] [0 -1] [0 1] [1 -1] [1 0] [1 1]]\n        count-neighbours (fn [x y] (count (filter (fn [[dx dy]] (live? (+ x dx) (+ y dy))) neighbours)))\n        next-state (fn [x y]\n                     (let [cnt (count-neighbours x y)]\n                       (if (live? x y)\n                         (if (and (>= cnt 2) (<= cnt 3)) \\# \\space)\n                         (if (= cnt 3) \\# \\space))))]\n    (for [y (range (count board))]\n      (apply str (for [x (range (count (get board y)))] (next-state x y))))))","problem":94,"user":"4f9120d8e4b0dcca54ed6c96"},{"problem":94,"code":"(fn [b]\n    (for [j (range (count (first b)))]\n      (let [row-chars (for [i (range (count b))]\n                        (let [nn (count\n                                  (for [ny (range (dec j) (+ 2 j))\n                                        nx (range (dec i) (+ 2 i))\n                                        :when (and (= \\# (get-in b [ny nx]))\n                                                   (or (not= ny j)\n                                                       (not= nx i)))]\n                                    [ny nx (= \\# (get-in b [ny nx]))]))\n                              reborn (if (= \\# (get-in b [j i]))\n                                       (#{2 3} nn)\n                                       (#{3} nn))]\n                          (if reborn \\# \\space)))]\n        (apply str row-chars))))","user":"4ee26f01535d10e5ff6f5368"},{"code":"(fn [b]\n  (let [m (mapv (fn [s] (mapv #(-> % first int (- 32) (/ 3)) (re-seq #\"[ |#]\" s))) b)\n        n (fn [[a b]] (reduce + (- 0 (get-in m [a b]))\n                              (map #(get-in m % 0)\n                                   (for [x [-1 0 1]\n                                         y [-1 0 1]]\n                                     [(+ x a) (+ y b)]))))\n        l #(let [v (n %2)]\n             (cond (< v 2) 0\n                   (> v 3) 0\n                   (= v 3) 1\n                   (= v 2) %))\n        w (count (first m))]\n    (map #(apply str %) (partition w\n                                   (for [x (range w)\n                                         y (range (count m))]\n                                     (if (zero? (l (get-in m [x y]) [x y])) \" \" \"#\"))))))","problem":94,"user":"4ff9d4e5e4b0678c553fc3b0"},{"code":"(fn game-of-life [board]\n  (let [width (count (first board))\n  height (count board)]\n   (letfn [(read []\n\t\t (vec (map (fn [line]\n\t\t\t     (vec (map (fn [c] ({\\space :d \\# :a} c)) line)))\n\t\t\t   board)))\n\t   (at [game i j]\n\t       (if (or (>= i width) (>= j height) (< i 0) (< j 0))\n\t\t :d\n\t\t ((game j) i)))\n\t   (neighs [game i j]\n\t\t   (for [x (range (dec i) (+ i 2))\n\t\t\t y (range (dec j) (+ j 2))\n\t\t\t :when (not (and (= x i) (= y j)))]\n\t\t     (at game x y)))\n\t   (alive-neighs [game i j]\n\t\t\t (count (filter #{:a} (neighs game i j))))\n\t   (to-str [game]\n\t\t   (map (fn [line]\n\t\t\t  (apply str (map {:a \"#\" :d \" \"} line))) game))\n\t   (step [game]\n\t\t (partition width\n\t\t\t    (for [y (range height)\n\t\t\t\t  x (range width)\n\t\t\t\t  :let [alive (alive-neighs game x y)]]\n\t\t\t      (if (= :a (at game x y))\n\t\t\t\t(if (#{2 3} alive) :a :d)\n\t\t\t\t(if (= 3 alive) :a :d)))))]\n     (let [game (read)\n\t   next (step game)]\n       (to-str next)\n       ))))","problem":94,"user":"4e513ecf535dc968683fc4f6"},{"problem":94,"code":"(fn [board]\n  (let [->int {\\space 0 \\# 1}\n        height (count board)\n        width (count (first board))\n        get-cell (fn [[x y]] (if (or (< x 0) (< y 0) \n                                     (= x width) (= y height))\n                               0\n                               (->int (get-in board [y x]))))\n        get-neighbors (fn [[x y]] (for [xn (range (dec x) (+ 2 x))\n                                        yn (range (dec y) (+ 2 y))\n                                        :when (not= [x y] [xn yn])]\n                                    (get-cell [xn yn])))\n        get-next (fn [[cell neighbors]] (case (apply + neighbors)\n                                          (0 1) 0       ;; dies of loneliness\n                                          2 cell        ;; steady\n                                          3 1           ;; thrives\n                                          (4 5 6 7 8) 0 ;; overcrowded\n                                          -1))]         ;; error\n    (->> (for [y (range height)\n               x (range width)]\n           [(get-cell [x y]) (get-neighbors [x y])])\n         (map get-next)\n         (map (clojure.set/map-invert ->int))\n         (partition width)\n         (map #(apply str %)))))","user":"5ad63a34e4b0ea6055cfac01"},{"problem":94,"code":"(fn [board]\n    (let [height (count board)\n          width (count (nth board 0))]\n      (letfn [(board->cells [board]\n                (set (for [[y row] (map-indexed list board)\n                           [x cell] (map-indexed list row)\n                           :when (= cell \\#)]\n                       [x y])))\n              (cells->board [cells]\n                (vec (for [y (range height)]\n                       (apply str (for [x (range width)]\n                                    (if (contains? cells [x y]) \"#\" \" \"))))))\n              (neighbours [[x y]]\n                (set (for [dx [-1 0 1] dy (if (zero? dx) [-1 1] [-1 0 1])]\n                       [(+ dx x) (+ dy y)])))\n              (state [cells]\n                (set (for [[loc n] (frequencies (mapcat neighbours cells))\n                           :when (or (= n 3) (and (= n 2) (contains? cells loc)))]\n                       loc)))]\n        (->> board\n             board->cells\n             state\n             cells->board))))","user":"5f37839ee4b0574c87022c59"},{"code":"(fn [s]\r\n (let [xc (count (first s)) yc (count s)]    \r\n  (letfn [(t [n m]\r\n   (filter #(and (>= % 0) (< % m)) [n (dec n) (inc n)]))\r\n    (n [[x y]]\r\n     (let [xs (t x xc) ys (t y yc)]\r\n      (filter #(not= [x y] %)\r\n       (for [x xs y ys] [x y]))))\r\n    (c [[x y]] ((vec (s y)) x))\r\n    (l [ns] (count (filter #(= % \\#) (map c ns))))\r\n    (nc [c n]\r\n     (if (= c \\#)\r\n      (cond (or (< n 2) (> n 3)) \" \" :else \"#\")\r\n      (cond (= n 3) \"#\" :else \" \")) )]\r\n     (for [y (range 0 yc)]\r\n      (apply str (for [x (range 0 xc)]\r\n       (let [ns (n [x y])] (nc (c [x y]) (l ns)))))))))","problem":94,"user":"4db4714f535dc0f10411755a"},{"problem":94,"code":"(fn game-of-life [universe]\n  (let [live-f? (fn [[col row]] (= \\# (get-in universe [col row])))\n        live-neighbors-count (fn [col row]\n                               (let [on-board? (some-fn pos? zero?)]\n                                 (->> (for [dx [-1 0 1]\n                                            dy [-1 0 1]\n                                            :when (not (= 0 dx dy))]\n                                        [(+ col dx) (+ row dy)])\n                                      (filter (fn [[col row]] (and (on-board? col) (on-board? row))))\n                                      (filter live-f?)\n                                      count)))\n        future-f (fn [live? num-neighbors]\n                   (if live?\n                     (cond\n                       (< num-neighbors 2) \\space\n                       (> num-neighbors 3) \\space\n                       :else \\#)\n                     (if (= 3 num-neighbors)\n                       \\#\n                       \\space)))\n        row-size (-> universe first count)\n        num-rows (count universe)]\n    (->> (for [col (range row-size)\n               row (range num-rows)]\n           (future-f (live-f? [col row]) (live-neighbors-count col row)))\n         (partition row-size)\n         (mapv (partial apply str)))))","user":"561d8936e4b064ca9f4b16b2"},{"code":"(fn advance [state]\n  (let [size (count state)\n        piece-at (fn [[x y]] (-> state (get y) (get x)))\n        alive? (fn [[x y]] (= \\# (piece-at [x y])))\n        neighbor-count (fn [[x y]] \n                         (let [neighbors [[x (dec y)]\n                                          [x (inc y)]\n                                          [(dec x) y]\n                                          [(inc x) y]\n                                          [(dec x) (dec y)] \n                                          [(dec x) (inc y)] \n                                          [(inc x) (dec y)] \n                                          [(inc x) (inc y)]]]\n                           (count (filter alive? neighbors))))\n        construct-position (fn [[x y]] \n                             {:neighbor-count (neighbor-count [x y])\n                              :alive? (alive? [x y])})\n        next-marker (fn [x y]\n                      (let [{:keys [neighbor-count alive?]} (construct-position [x y])]\n                        (cond (and alive? (< neighbor-count 2)) \" \"\n                              (and alive? (> neighbor-count 3)) \" \"\n                              (and alive? (#{2 3} neighbor-count)) \"#\"\n                              (and (not alive?) (= 3 neighbor-count)) \"#\" \n                              :else \" \")))]\n    (for [row-index (range size)]\n      (apply str (map next-marker (range size) (repeat row-index))))))","problem":94,"user":"4db1b3951254ad5b4805fa6f"},{"code":"(fn [board]\n  (letfn [(neighbours [universe rows cols [i j]]\n            (for [x (map (partial + i) [-1 0 1])\n                  y (map (partial + j) [-1 0 1])\n                  :when (and (not= [x y] [i j])\n                             (<= 0 x (dec rows))\n                             (<= 0 y (dec cols)))]\n              (nth (nth universe x) y)))]\n    (let [universe (map (partial map {\\space 0 \\# 1}) board)\n          rows     (count universe)\n          cols     (count (first universe))]\n      (map (comp (partial apply str)\n                 (partial map {0 \\space 1 \\#}))\n           (for [i (range rows)]\n             (for [j (range cols)]\n               (condp = (vector (nth (nth universe i) j)\n                                (apply + (neighbours universe rows cols [i j])))\n                 [1 2] 1\n                 [1 3] 1\n                 [0 3] 1\n                 0)))))))","problem":94,"user":"4f7431d2e4b044e54cd9a8f7"},{"code":"(fn [board]\n(let [ \nboard (vec (map #(vec (replace {\\space 0 \\# 1} %)) board))\nnr (count board)\nnc (count (board 0))\ndeltas (fn [[r c]]\n       (for [dr [-1 0 1] \n             dc (if (= 0 dr) \n                  [-1 1] \n                  [-1 0 1]) ] [(+ r dr) (+ c dc)]))\n\ninrange (fn [i b]\n  (< -1 i b))\n\nneighbors \n   #(reduce +\n       (map (fn [[r c]]\n                (if (and (inrange r nr) (inrange c nc))\n                   (get-in board [r c])\n                   0))\n         (deltas %)))\n\nnew-gen  #({ [1 3] \\#\n             [1 2] \\#\n             [0 3] \\#} % \\space )]\n\n  (map (partial apply str)\n        (partition nr\n          (for [r (range nr)\n                c (range nc)]\n         (new-gen [(get-in board [r c]) (neighbors [r c])]))))))","problem":94,"user":"4daa374930acd6ed13482a68"},{"code":"(let [pm {\\space 0 \\# 1}\n      live-ns {\\space #{3} \\# #{2 3}}\n      neighbors (fn [b i j]\n                  (apply +\n                         (- (pm (get-in b [i j])))\n                         (for [ii (range (max 0 (dec i)) (min (count b) (+ i 2)))\n                               jj (range (max 0 (dec j)) (min (count (first b)) (+ j 2)))]\n                           (pm (get-in b [ii jj])))))]\n  (fn f [b]\n    (map (partial apply str)\n         (for [i (range (count b))]\n           (for [j (range (count (first b)))]\n             (if (contains? (live-ns (get-in b [i j]))\n                            (neighbors b i j))\n               \\#\n               \\space))))))","problem":94,"user":"50b668dde4b08fb537db98f2"},{"problem":94,"code":"(fn [board]\n   (let [w (count (first board))\n         h (count board)\n         live? (fn [[x y]]\n                 (and (>= x 0) (< x w) (>= y 0) (< y h)\n                      (= \\# (get-in board [x y]))))\n         neighbours (fn [x y]\n                      (count (filter live? [[(dec x) (dec y)]\n                                            [(dec x) y]\n                                            [(dec x) (inc y)]\n                                            [x (dec y)]\n                                            [x (inc y)]\n                                            [(inc x) (dec y)]\n                                            [(inc x) y]\n                                            [(inc x) (inc y)]])))\n         should-live? (fn [x y]\n                        (cond\n                          (< (neighbours x y) 2) false\n                          (= 2 (neighbours x y)) (live? [x y])\n                          (= 3 (neighbours x y)) true\n                          :else false))]\n     (map (fn [x]\n            (apply str (map (fn [y]\n                              (if (should-live? x y) \"#\" \" \")) (range w)))) (range h))))","user":"591072e0e4b0163c97b36ebc"},{"problem":94,"code":"; an imperafunctional abomination\n; this should be refactored\n\n(fn [board]\n  (letfn [(update-cell-fn [alive?]\n            (fn [empty-board pos]\n              (assoc-in empty-board\n                        pos \n                        (step alive? pos))))\n          \n          (step [alive [y x]]\n            (let [{adj-alive \\#} (frequencies \n                                  (neighbours x y))]\n              (if (or (and alive\n                           (<= 2 adj-alive 3))\n                      (= adj-alive 3))\n                  \\#\n                  \\space)))\n          \n          (neighbours [x y]\n            (let [y- (dec y)\n                  y+ (inc y)\n                  x- (dec x)\n                  x+ (inc x)\n                  adj [[y- x-]\n                       [y- x]\n                       [y- x+]\n                       [y  x+]\n                       [y+ x+]\n                       [y+ x]\n                       [y+ x-]\n                       [y  x-]]]\n              (map (partial get-in board) adj)))\n                        \n          (index-if-x [x i item]\n            (if (= x\n                   item)\n              i))\n          (pos-or-nil [i indexes]\n            (if-not (empty? indexes)\n              (map (partial conj [i]) indexes)))\n                        \n          (get-coordinates-of [cell-type]\n            (->> board\n                 (map (partial keep-indexed \n                               (partial index-if-x cell-type)))\n                 (keep-indexed pos-or-nil)\n                 (apply concat)))]\n                       \n    (let [board-size (count board)\n          empty-board (->> \\space\n                           (repeat board-size)\n                           vec\n                           (repeat board-size)\n                           vec)\n          alive (get-coordinates-of \\#)\n          alive-updated (reduce (update-cell-fn true)\n                                empty-board alive)\n          dead (get-coordinates-of \\space)\n          dead-updated (reduce (update-cell-fn false)\n                               alive-updated dead)]\n      (vec (map (partial clojure.string/join \"\") dead-updated)))))","user":"57f0f7b8e4b0bfb2137f5bfe"},{"problem":94,"code":"(fn Life [m]\n  (letfn [(nnth [[i j]]\n                (nth (nth m j '()) i \\space))\n          (live-neighbors [xy]\n                          (reduce\n                           #(if (= %2 \\#) (inc %1) %1)\n                           0\n                           (map nnth\n                                (map #(map + xy %)\n                                     '((-1 -1) (-1 0) (-1 1) (0 -1) (0 1) (1 -1) (1 0) (1 1))))))\n          (result [alive n]\n                  (if alive\n                    (cond (< n 2) \\space\n                          (> n 3) \\space\n                          :else \\#)\n                    (if (= n 3) \\# \\space)))]\n    (map\n     (fn [j]\n       (apply str (map\n                   (fn [i]\n                     (result (= \\# (nnth (list i j)))\n                             (live-neighbors (list i j))))\n                   (range (count (first m))))))\n     (range (count m)))))","user":"55f73078e4b06e875b46cea4"},{"problem":94,"code":"(letfn [(nbs [[x y]] (for [dx [-1 0 1] dy [-1 0 1]\n                     \t:when (not= dx dy 0)]\n    \t\t\t\t\t[(+ x dx) (+ y dy)]))\n\t\t(step [cs] (set\t(for [[p n] (frequencies (mapcat nbs cs))\n                      \t\t:when (or (= n 3) (and (= n 2) (cs p)))]\n      \t\t\t\t\t\tp)))\n\t\t(cells [l w rs] (set (for [r (range l) c (range w)\n                             \t:when (= \\# (get-in rs [r c]))]\n      \t\t\t\t\t\t\t[r c])))\n\t\t(out [l w cells] (vec (for [x (range l)]\n      \t\t\t\t\t\t\t\t   \t(apply str\n             \t\t\t\t\t\t\t\t(for [y (range w)]\n               \t\t\t\t\t\t\t\t\t(if (cells [x y]) \\# \" \"))))))\n\t\t(gol [in] (let [l (count in)\n        \t\t\t\tw (count (first in))]\n   \t\t\t\t   \t(out l w\n\t\t       \t\t\t(step (cells l w in)))))]\n  gol)","user":"514d8084e4b019235f6c0588"},{"problem":94,"code":"(fn runRound [board]\n\n  (letfn [\n          (update [m k f] (assoc m k (f (get m k))))\n\n          (getNeighbors [coord] (filter  (fn [c] (every? #(< -1 %) c)) (vector\n                                                                              (update coord 0 inc)\n                                                                              (update coord 1 inc)\n                                                                              (update coord 0 dec)\n                                                                              (update coord 1 dec)\n                                                                              [(inc (first coord)) (dec (second coord))]\n                                                                              (vector (dec (first coord)) (inc (second coord)))\n                                                                              (map dec coord)\n                                                                              (map inc coord)\n                                                                              )))\n\n          (lookup [coord board] (get (get board (second coord)) (first coord)))\n\n          (countAliveNeigbors [coord board] ((frequencies (map #(lookup % board) (getNeighbors coord))) \\#))\n\n          (applyRules [coord board] (let [aliveNeighbors (countAliveNeigbors coord board)] (if (= (lookup coord board) \\#) (cond\n                                                                                                                                  (< aliveNeighbors 2) \" \"\n                                                                                                                                  (< aliveNeighbors 4) \"#\"\n                                                                                                                                  :else \" \"\n                                                                                                                                  )\n                                                                                                                                (if (= aliveNeighbors 3)\n                                                                                                                                  \"#\"\n                                                                                                                                  \" \"))))\n\n\n          (getAllCoords [board] (for [x (range (count board)) y (range (count (first board)))] [y x]))\n\n\n          ]\n  (let [allCoords (getAllCoords board)] (into [] (map #(apply str %) (partition (count (first board)) (map #(applyRules % board) allCoords)))))))","user":"56427910e4b08d4f616f5f19"},{"code":"(letfn [\r\n  (neighbors8\r\n\t\t([       height width yx] (neighbors8 [[0 1] [0 -1] [1 0] [-1 0] [-1 -1] [1 -1] [-1 1] [1 1]] height width yx))\r\n\t\t([deltas height width yx] (filter (fn [[new-y new-x]] (and (< -1 new-y height) (< -1 new-x width))) (map #(vec (map + yx %)) deltas))))\r\n\t(board-width [board]\r\n\t\t(count (first board)))\r\n\t(board-height [board]\r\n\t\t(count board))\r\n\t(index-board [board yx]\r\n\t\t(get-in board yx))\r\n\t(count-live-neighbors [board yx]\r\n\t\t(count (filter #(= \\# %) (map (partial index-board board) (neighbors8 (board-height board) (board-width board) yx)))))]\r\n\t\r\n\t(fn game-of-life [board]\r\n\t\t(let [new-board-flat (for [\r\n\t\t\t\t\t\t\t\t\ty (range (board-height board))\r\n\t\t\t\t\t\t\t\t\tx (range (board-width  board))\r\n\t\t\t\t\t\t\t\t\t:let [cell (index-board board [y x]), num-live-neighbors (count-live-neighbors board [y x])]]\r\n\t\t\t\t\t\t\t\t(if (= cell \\#)\r\n\t\t\t\t\t\t\t\t\t; a live cell\r\n\t\t\t\t\t\t\t\t\t(cond\r\n\t\t\t\t\t\t\t\t\t\t(<  num-live-neighbors 2) \\space\t\t; the cell dies\r\n\t\t\t\t\t\t\t\t\t\t(<= num-live-neighbors 3) \\#\t\t\t; the cell lives on\r\n\t\t\t\t\t\t\t\t\t\t:else                     \\space)\t\t; the cell dies\r\n\t\t\t\t\t\t\t\t\t; a dead cell\r\n\t\t\t\t\t\t\t\t\t(if (= num-live-neighbors 3)\r\n\t\t\t\t\t\t\t\t\t\t\\#\t\t\t\t; the cell comes back to life\r\n\t\t\t\t\t\t\t\t\t\t\\space)))]\t\t; the cell remains dead\r\n\t\t\t(map (partial apply str) (partition (board-width board) new-board-flat)))))","problem":94,"user":"4dd6d6a0535d2dad7130b5ca"},{"code":"(fn game-of-life [board]\n  (let [wid (count (first board))\n        ht (count board)\n        nbrs-pos (fn [x y]\n          (for [i [(dec x) x (inc x)] j [(dec y) y (inc y)] :when (and (< -1 i ht) (< -1 j wid) (not= [i j] [x y]))] [i j])) \n        nbrs (fn [x y] (reduce + (map #(if (= \\# (get-in board %)) 1 0) (nbrs-pos x y))))\n        new-board (for [i (range ht) j (range wid) :let [nb (nbrs i j) cell (get-in board [i j])]]\n                    (cond (< nb 2) \\ \n                          (> nb 3) \\ \n                          (and (= 3 nb) (= \\  cell)) \\#\n                          :else cell))]\n    (map #(apply str %) (partition wid new-board))))","problem":94,"user":"4effb663535dcb61093f6a2e"},{"code":"(fn life [sb]\r\n  (let [\r\n      b (vec (map vec sb))\r\n\t    to-str (fn [b] (map #(reduce str %) b))\r\n\t    cells (fn [b] \r\n\t       (let [rng (range 1 (dec (count b)))] \r\n\t         (for [x rng y rng] [x y])))\r\n\t    rng (fn [n] (map #(+ n %) (range -1 2)))\r\n\t    l? (fn [p] (= \\# (get-in b p)))\r\n\t    lc (fn [[x y]] \r\n\t      (count \r\n\t        (filter l? (for [x1 (rng x) y1 (rng y)] [x1 y1]))))\r\n\t    nx (fn [p]\r\n\t      (let [cnt (lc p) lv? (l? p)]\r\n\t        (cond\r\n\t          (and lv? (= 3 cnt)) \\#\r\n\t          (and lv? (= 4 cnt)) \\#\r\n\t          (and (not lv?) (= 3 cnt)) \\#\r\n\t          :else \\space\r\n\t      )))\r\n    ]\r\n    (to-str \r\n      (reduce \r\n        #(assoc-in %1 %2 (nx %2)) \r\n        b \r\n        (cells b)))\r\n  ))","problem":94,"user":"4e6e10d8535d5021c1a895fd"},{"problem":94,"code":"(fn [s]\n      (let [width (count (first s)),\n            height (count s),\n            row (fn [y] (if (or (= y -1) (= y height)) nil (nth s y))),\n            col (fn [row, x] (if (or (nil? row) (= x -1) (= x width)) 0 (if (= (nth row x) \\#) 1 0))),\n            cnt (fn [x, y] (col (row y) x))\n            cnts (fn [x, y] (+ (cnt (inc x) y) (cnt (dec x) y) (cnt x (inc y)) (cnt x (dec y)) (cnt (inc x) (inc y)) (cnt (dec x) (dec y)) (cnt (dec x) (inc y)) (cnt (inc x) (dec y))  ))\n            ng (fn [x, y] (let [ns (cnts x y), self (cnt x y)] (if (= self 0) (if (= ns 3) \\# \\space) (if (or (= ns 2) (= ns 3)) \\# \\space))))]\n           (for [y (range height)] (apply str (for [x (range width)] (ng x y) )))\n           )\n      )","user":"53bcdd41e4b0d9a98559a6c0"},{"problem":94,"code":"(fn [b]\n  (letfn [(n [r c]\n            (for [i (range -1 2)\n                  j (range -1 2)\n                  :when (not= 0 i j)]\n              (get-in b [(+ r i) (+ c j)])))]\n    (map #(apply str %)\n      (partition (count (first b))\n                 (for [i (range (count b))\n                       j (range (count (first b)))]\n                   (let [l (count (filter #(= \\# %) (n i j)))]\n                     (cond\n                       (and (= l 2)\n                            (= \\# (get-in b [i j]))) \\#\n                       (= l 3) \\#\n                       :else \\space)))))))","user":"54ca9ca8e4b057c6fda3a265"},{"code":"(fn [grid] (let [w (count (first grid))\n                 h (count grid)\n                 coordGrid (map (fn [y] (map (fn [x] [x y]) (range 0 w))) (range 0 h))\n                 upVectors #{[-1 -1] [0 -1] [1 -1]}\n                 downVectors #{[-1 1] [0 1] [1 1]}\n                 leftVectors #{[-1 -1] [-1 0] [-1 1]}\n                 rightVectors #{[1 -1] [1 0] [1 1]}\n                 allDirections (clojure.set/union upVectors downVectors leftVectors rightVectors)\n                 mapGrid (fn [f xs] (map (partial map f) xs)) ; Apply function inside grid\n                 repMap {\\space 0 \\# 1} ; Convert string rep into numerical rep\n                 numRep (mapGrid repMap grid)\n                 index (fn [grid [x y]] (nth (nth grid y) x)) ; Extract given element from grid\n                 liveRules (fn [a] (get {2 1 3 1} a 0))\n                 deadRules (fn [a] (get {3 1} a 0))\n                 ruleSelect {0 deadRules 1 liveRules}\n                 countNeighbours (fn [x y] (let [verticalSub (get {0 upVectors (dec h) downVectors} y #{}) ; Vectors to remove given certain poitions\n                                                 horizontalSub (get {0 leftVectors (dec w) rightVectors} x #{})\n                                                 vectors (clojure.set/difference allDirections verticalSub horizontalSub) ; Vectors of interest for these coords\n                                                 ] (reduce + (map (fn [vect] (index numRep (map + [x y] vect))) vectors))))\n                 ] (map (partial apply str) (mapGrid (fn [xy] (get (clojure.set/map-invert repMap) ((get ruleSelect (index numRep xy)) (apply countNeighbours xy)))) coordGrid))))","problem":94,"user":"5363d242e4b0243289761e5c"},{"code":"(fn [board]\n   (letfn [(neighbor-idxs [r c]\n             (disj (set (mapcat (fn [x] (map #(vec [x %]) [(dec c) c (inc c)]))\n                             [(dec r) r (inc r)]))\n                   [r c]))\n           (neighbor-count [r c]\n             (count (filter #(= \\# %) (map #(get-in board %) (neighbor-idxs r c)))))\n           (curr-live? [r c] (= \\# (get-in board [r c])))\n           (next-live? [r c]\n             (or (and (curr-live? r c) (<= 2 (neighbor-count r c) 3))\n                 (and (not (curr-live? r c)) (= 3 (neighbor-count r c)))))]\n     (map (fn [r] (apply str (map (fn [c] (if (next-live? r c) \\# \\ ))\n                                  (range (count (first board))))))\n          (range (count board)))))","problem":94,"user":"4ea1b9e4535d7eef308072b8"},{"code":"(fn [board]\n  (let [h (count board)\n        w (count (first board))\n        m (fn [x y] ; live cell?\n            (and (<= 0 x) (< x w) (<= 0 y) (< y h)\n                 (= \\# (nth (nth board y) x))))\n        n (fn [x y] ; num of live neighbors\n            (apply +\n              (for [dx (range -1 2) dy (range -1 2)]\n                (if (and (zero? dx) (zero? dy)) 0\n                    (if (m (+ x dx) (+ y dy)) 1 0)))))\n        ]\n    (map (partial apply str)\n      (partition w\n        (for [y (range h) x (range w)]\n          (let [l (m x y) c (n x y)]\n            (if (and l (< c 2)) \\space\n                (if (and l (< c 4)) \\#\n                    (if l \\space\n                        (if (= c 3) \\# \\space))))))))))","problem":94,"user":"4fd96694e4b05e33b9224f37"},{"code":"(fn [game-state]\n    (let [cells (vec (mapcat vec game-state))\n          rows (count game-state)\n          cols (count (first game-state))\n          up-row  (partial map #(- % cols) )\n          down-row (partial map #(+ % cols))\n          neighbouring (comp\n                        set\n                        (partial map #(mod % (* rows cols)))\n                        #(apply concat %)\n                        (juxt up-row identity down-row)\n                        (juxt dec identity inc))\n          alive? #{\\#}\n          dead? (complement alive?)\n          surrounding-contents (fn [index]\n                                 (map #(get cells %)  (disj (neighbouring index) index)))\n          surrounding-live  #(count (filter alive?\n                                            (surrounding-contents %)))\n          inc-cell (fn [index state]\n                     (let [live-count (surrounding-live index)]\n                       (cond\n                        (and (alive? state) (<= 2 live-count 3)) \\#\n                        (and (dead? state) (= 3 live-count)) \\#\n                        :else \\space)\n                       ))\n          ]\n      (map #(apply str %)\n           (partition cols\n                      (map inc-cell (range (* rows cols)) cells )))\n      ))","problem":94,"user":"4e6f578c535d5021c1a8961b"},{"code":"(fn next-board [board]\n    (letfn [\n      (cell-set [board]\n        (set (map #(vec (rest %))\n               (filter #(= \\# (first %))\n                (for [y (partition 2 2\n                          (interleave (range (count board))\n                            (map #(partition 2 2\n                                    (interleave (range (count %)) %)) board)))\n                      x (second y)]\n                  [(second x) (first y) (first x) ])))))\n\n      (count-neighbors [cset y x h w]\n         (apply +\n                (for [ny (range (dec y) (+ y 2))\n                      nx (range (dec x) (+ x 2))\n                      :when (< -1 ny h)\n                      :when (< -1 nx w)\n                      :when (not= [ny nx] [y x])]\n                  (if (contains? cset [ny nx]) 1 0))))\n      (next-gen [cset h w]\n        (set (map #(vec (rest %))\n          (filter first\n            (for [y (range h) x (range w)]\n              (let [neighbors (count-neighbors cset y x h w)]\n                [(if (contains? cset [y x])\n                     (<= 2 neighbors 3)\n                     (== 3 neighbors)) y x]))))))\n\n      (cell-board [cset h w]\n        (for [y (range h)]\n            (apply str (vec\n              (for [x (range w)]\n                (if (get cset [y x]) \\# \\space))))))]\n\n  (let [h (count board)\n        w (count (first board))]\n     (cell-board\n       (next-gen\n         (cell-set board)\n         h w)\n       h w))))","problem":94,"user":"53300924e4b019098a6f8b55"},{"code":"(fn next-gen [board]\n  (let [cartesian (fn [coll1 coll2]\n                    (for [x coll1 y coll2] [x y]))\n        nei-alive (fn [board cell]\n                    (reduce + (for [dx [-1 0 1]\n                                    dy [-1 0 1]\n                                    :when (not= 0 dx dy) \n                                    :let [nei-cell (map + cell [dx dy])\n                                          nei-value ({\\# 1} (get-in board nei-cell))]\n                                    :when nei-value]\n                                nei-value)))\n        height (count board)\n        width (count (first board))]\n    (->> (map (partial map list)\n              (->> board\n                   (map (partial map {\\space 0 \\# 1})))\n              (->> (cartesian (range height)\n                              (range width))\n                   (map (partial nei-alive board))\n                   (partition width)))\n         (map (partial map (fn [[alive nei-alive]]\n                             (if (or (and (= 0 alive)\n                                          (= 3 nei-alive))\n                                     (and (= 1 alive)\n                                          (<= 2 nei-alive 3)))\n                               1\n                               0))))\n         (map (partial map {0 \\space 1 \\#}))\n         (map (partial apply str))\n         vec)))","problem":94,"user":"5326c5f7e4b09d4e7a9b54f2"},{"code":"(fn [grid]\n   (letfn [(count3s [lis]\n             (map (fn [& args] (count (filter #(= % \\#) args)))\n                 lis\n                 (cons \\space lis)\n                 (concat (drop 1 lis) (list \\space))))\n           (sum3s [rowcounts]\n              (map (fn [& rows] (apply map + rows))\n                 rowcounts\n                 (cons (repeat 0) rowcounts)\n                 (concat (drop 1 rowcounts) (list (repeat 0)))))\n           (newval [ct vc]\n              (if (= \\# vc)  ; live\n                 (if (contains? #{3 4} ct) \\# \\space)\n                 (if (= 3 ct) \\# \\space)))]\n      (let [rowcts (map count3s grid)\n            cellcts (sum3s rowcts)\n            nvs (map (fn [r1 r2] (map newval r1 r2))\n                   cellcts grid)]\n        (map (fn [r] (apply str r)) nvs))))","problem":94,"user":"4fe87e56e4b07c9f6fd12c40"},{"code":"(fn game-of-life [xseq] (let [\n    x (vec (map vec xseq))\n    h (count x)\n    w (count (first x))]\n    (for [hi (range h)] \n        (apply str (for [wi (range w)] (let [\n            b3x3 (for [hd [0 -1 1] wd [0 -1 1]] (get (get x (+ hi hd)) (+ wi wd)))\n            self (first b3x3)\n            near (rest b3x3)\n            self-alive (= \\# self)\n            near-lifes (count (filter (partial = \\#) near))\n            alive1 (and self-alive (#{2 3} near-lifes))\n            alive2 (= 3 near-lifes)\n            alive (or alive1 alive2)]\n            (if alive \\# \\space)))))))","problem":94,"user":"51cbdee1e4b08d8387cbede1"},{"problem":94,"code":"(fn \n  [board]\n  \n  (let [get-xy-combos (fn\n  [x y]\n  [[x (dec y)]\n   [(inc x) (dec y)]\n   [(inc x) y]\n   [(inc x) (inc y)]\n   [x (inc y)]\n   [(dec x) (inc y)]\n   [(dec x) y]\n   [(dec x) (dec y)]])\n        \n  get-cell (fn\n  [board x y]\n  (let [row (get board y)]\n    (get row x)))\n        \n  get-surrounding-cells (fn\n  [board x-coord y-coord]\n  (let [combos (get-xy-combos x-coord y-coord)]\n    (map (fn [[x y]] (get-cell board x y)) combos))) \n        \n  dead-or-alive (fn\n  [current-cell\n   surrounding-cells]\n  (let [n-surround-alive (filter #(= \\# %) surrounding-cells)]\n    (cond\n      (and (= current-cell \\#) (< (count n-surround-alive) 2)) \\space\n      (and (= current-cell \\#) (or (= 2 (count n-surround-alive)) (= 3 (count n-surround-alive)))) \\#\n      (and (= current-cell \\#) (> (count n-surround-alive)) 3) \\space\n      (and (= current-cell \\space) (= 3 (count n-surround-alive))) \\#\n      :else current-cell)))\n      \n  \ty-count (count board)\n   \tx-count (count (first board))]\n    \n    (for [y (range 0 y-count)]\n      (apply str (for [x (range 0 x-count)]\n         (let [current-cell (get-cell board x y)\n               surrounding-cells (get-surrounding-cells board x y)]\n           (dead-or-alive current-cell surrounding-cells)))))))","user":"559fb147e4b0acc240e314ea"},{"problem":94,"code":"(fn game-oflife\n  [grid]\n  (let [old-grid (map #(into [] %) grid)\n        neighbours (fn \n  [x y grid]\n  (let [xs (filter #(and (>= % 0) (< % (count grid))) (map #(+ x %) [-1 0 1]))\n        ys (filter #(and (>= % 0) (< % (count (first grid)))) (map #(+ y %) [-1 0 1]))]\n    (filter #(not= % [x y])\n            (for [x xs y ys]\n              [x y]))\n    ))\n        get-cell (fn\n  [[x y] grid]\n  (nth (nth grid x) y))\n        neighbours-count (fn \n  [x y grid]\n  (count (filter #(= % \\#) (map #(get-cell % grid) (neighbours x y grid))))\n  )\n        ]\n    (map #(apply str %)\n    (partition (count (first old-grid))\n               (for [x (range (count old-grid))\n                     y (range (count (first old-grid)))]\n                 (let [cur (get-cell [x y] old-grid)\n                       status (neighbours-count x y old-grid)]\n                   (if (= cur \\#)\n                     (if (< status 2)\n                       \\space\n                       (if (< status 4)\n                         \\#\n                         \\space))\n                     (if (= status 3)\n                       \\#\n                       \\space)))\n                 ))))\n  )","user":"5545477fe4b0a04f79299531"},{"code":"(fn game-of-life [board]\n  (let [siz (count board)]\n    (letfn [(add-to-borders [what a-coll] (concat [what] a-coll [what]))\n            (to-bit-matrix [board] (map (partial map #(case %1 \\# 1 0)) board))\n            (extend [board] (add-to-borders (repeat (+ 2 siz) 0) (map (partial add-to-borders 0) (to-bit-matrix board))))\n            (sum-surroundings [e i j]\n              (apply +\n                (map\n                  (fn [[x y]] (nth (nth e x) y))\n                  [[i (dec j)] [i (inc j)] [(dec i) (dec j)] [(dec i) j] [(dec i) (inc j)] [(inc i) (dec j)] [(inc i) j] [(inc i) (inc j)]]\n                  )\n                )\n              )\n            (freqs [board]\n              (partition siz\n                (let [e (extend board)]\n                  (for [i (range 1 (inc siz))\n                        j (range 1 (inc siz))]\n                    (sum-surroundings e i j)\n                    ))))\n            (to-hash-matrix [board] (map (comp (partial apply str) (partial map #(case %1 1 \"#\" \" \"))) board))\n            ]\n      (to-hash-matrix\n        (map\n          (fn [row freq-row]\n            (map\n              (fn [val f]\n                (cond\n                  (and (= 1 val) (< f 2)) 0\n                  (and (= 1 val) (> f 3)) 0\n                  (and (= 0 val) (= f 3)) 1\n                  :default val\n                  )\n                )\n              row freq-row))\n          (to-bit-matrix board) (freqs board))\n        )\n      )))","problem":94,"user":"5094057fe4b097f48cc38593"},{"problem":94,"code":"(fn [board] (let [size (count board)\n                  allCells (for [x (range size) y (range size)] (list x y))\n                  l [-1 0 1]\n                  isLive (fn [[x y]] (= \\# (nth (board x) y)))\n                  neighborsForCell (fn [[x y]] (for [dx l dy l :when (not= 0 dx dy)] (list (+ x dx) (+ y dy))))\n                  neighbors (fn [poss] (mapcat neighborsForCell poss))\n                  countElements (fn [l] (into {} (for [[k v] (group-by identity l)] [k (count v)])))\n                  formatBoard (fn [poss] (map\n                                           #(apply str %)\n                                           (partition size\n                                                      (reduce #(assoc %1 (+ (* size (first %2)) (second %2)) \\#)\n                                                              (vec (repeat (* size size) \\space)) poss))))\n                  ]\n              (->> allCells\n                   (filter isLive)\n                   neighbors\n                   countElements\n                   (#(for [[k v] % :when (or (= 3 v) (and (isLive k) (= 2 v)))] k))\n                   formatBoard)))","user":"5bafd5c8e4b0a20761a234dd"},{"code":"(fn conway [board] \n  (let [cells (set (for [y (range (count board))\n                         x (range (count (get board y)))\n                         :when (not= \\space (get-in board [y x]))]\n                     [x y]))\n        width (count (first board))\n        height (count board)\n        neighbors (fn [[x y]]\n                    (for [dx [-1 0 1] dy (if (zero? dx) [-1 1] [-1 0 1])]\n                      [(+ x dx) (+ y dy)]))\n        step (fn [cells]\n               (set (for [[loc n] (frequencies (mapcat neighbors cells))\n                          :when (or (= n 3) (and (= n 2) (cells loc)))]\n                      loc)))\n        serialize (fn [alive] \n                    (mapv #(apply str %) \n                          (partition width\n                                     (for [y (range height) x (range width) \n                                           :let [sym (if (alive [x y]) \\# \\space)]]\n                                       sym))))]\n    (-> cells step serialize)))","problem":94,"user":"5032b066e4b00c0952a257ea"},{"problem":94,"code":"(fn [b]\n    (let [\n          isAlive (fn [b x y]\n                    (if (or (< x 0) (< y 0) (>= x (count b)) (>= y (count b)))\n                      0\n                      (if (= \\# (get-in b [x y])) 1 0)\n                      )\n                    )\n\n          newState (fn [b x y]\n                     (let [livingNeighbors (apply + (map (fn[s] (apply + (map (fn[t] (isAlive b (+ s x) (+ t y))) (range -1 2)))) (range -1 2)))]\n                       (if (= 1 (isAlive b x y))\n                         (if (and (> livingNeighbors 2) (< livingNeighbors 5))\n                           \"#\"\n                           \" \"\n                           )\n                         (if (= 3 livingNeighbors)\n                           \"#\"\n                           \" \"\n                           )\n                         )\n                       )\n                     )\n          ]\n      (map (fn [x] (apply str (map (fn [y] (newState b x y)) (range (count b))))) (range (count b)))\n      )\n    )","user":"54b90836e4b0ed20f4ff6e9d"},{"problem":94,"code":"(fn gl[b]\n  (let [nl (count b)\n        nc (count (b 0))\n        brd (vec (map #(vec (seq %)) b))]\n    (vec \n      (for [i (range nl)]\n        (apply str  \n               (for [j (range  nc)\n                     :let [ccell ((brd i)j)\n                           ln (count (for [k [(dec i) i (inc i)]\n                                           l [(dec j) j (inc j)]\n                                           :when (and (pos? k)(pos? l)\n                                                      (< l nl)(< k nc))\n                                           :when (not (and (= k i)(= l j)))\n                                           :when (= ((brd k)l) \\#)] 1))]]\n                 (cond\n                   (and (= ccell \\#)(< ln 2)) \\space\n                   (and (= ccell \\#)(or (= ln 2)(= ln 3))) \\#\n                   (and (= ccell \\#)(> ln 3)) \\space\n                   (and (= ccell \\space)(= ln 3)) \\#\n                   :else \\space)))))))","user":"54d4bd2be4b0a52adc2e2005"},{"problem":94,"code":"(fn gol [lines]\n   (map #(apply str %)\n     (let [board (mapv vec lines)]\n       (for [y (range (count board))]\n         (for [x (range (count (first board)))]\n           (let [livecell? (= \\# (get-in board [y x]))\n                 c (count (filter #{\\#}\n                                  (for [dx [-1 0 1]\n                                        dy [-1 0 1]]\n                                    (when-not\n                                      (every? zero? [dx dy])\n                                      (get-in board [(+ y dy) (+ x dx)])))))]\n             (cond\n               (and livecell? (< 1 c 4)) \\#\n               (and (not livecell?) (= c 3)) \\#\n               :else \\space)))))))","user":"5a91988ae4b002d099cae6f9"},{"problem":94,"code":"(fn board-next-state [board]\n  (let [\n    alive? #(= % \\#)\n    rows (count board)\n    cols (count (first board))\n    lookup \n        (fn [board row col]\n          (-> board (get row) (get col \\space)))\n    neighbors \n        (fn [board row col]\n          (for [r [(- row 1) row (+ row 1)]\n                c [(- col 1) col (+ col 1)]\n                :when (or (not= r row) (not= c col))]\n            (lookup board r c)))\n    cell-next-state\n        (fn [board row col]\n          (let [cell-state (lookup board row col)\n                num-live-neighbors (count (filter #(= % \\#) (neighbors board row col)))]\n            (if (= cell-state \\#)\n              (if (#{2 3} num-live-neighbors) \\# \\space)\n              (if (= 3 num-live-neighbors) \\# \\space))))\n    ]\n    (map clojure.string/join\n        (partition rows\n            (for [r (range rows)\n                  c (range cols)]\n              (cell-next-state board r c))))))","user":"55a1d7f6e4b0acc240e31519"},{"problem":94,"code":"(fn [board]\n  (letfn [(neighbours [[x y]]\n            (->> (for [m [(dec x) x (inc x)] n [(dec y) y (inc y)]] [m n])\n                 (remove #(= [x y] %))\n                 (map #(get-in board %))\n                 (filter #(= % \\#))\n                 count))\n\n          (next-state [position state]\n            (let [neighbour-count (neighbours position)]\n              (get-in {\\# {2 \\# 3 \\#} \\space {3 \\#}} [state neighbour-count] \\space)))]\n\n    (map-indexed (fn [x s]\n                   (->> (vec s)\n                        (map-indexed (fn [y s] (next-state [x y] s)))\n                        (apply str)))\n                 board)))","user":"567c63f6e4b05957ce8c61bb"},{"problem":94,"code":"(fn life [coll]\n  (letfn [\n          (strs->set [strs] (apply hash-set\n                                   (filter #(not (nil? %))\n                                           (apply concat\n                                                 (map-indexed\n                                                     (fn [y row]\n                                                        (map-indexed\n                                                            (fn [x col]\n                                                               (if (= \\# col) [x y])) row)) coll)))))\n          (neighbors [[x y]]\n             [[(dec x) y] [x (dec y)] [(inc x) y] [x (inc y)]\n              [(dec x) (dec y)] [(inc x) (inc y)]\n              [(dec x) (inc y)] [(inc x) (dec y)]])\n          \n          (plant-seeds [lifeset]\n            (reduce (fn [bag tuple] (reduce #(assoc % %2\n                                         (if (contains? % %2)\n                                           (inc (% %2))\n                                           1)) bag (neighbors tuple))) {} lifeset))\n          (sprout [seedmap lifeset]\n            (set (filter #(not (nil? %))\n                (map (fn [[tuple neighborcount]] (cond\n                                                 (< neighborcount 2) nil\n                                                 (= neighborcount 2) (lifeset tuple)\n                                                 (= neighborcount 3) tuple\n                                                 :else nil\n                                                 )) seedmap))))\n          (set->strs [lifeset]\n            (let [nuthin (apply vector (repeat (count coll) (apply vector (repeat (count coll) \" \"))))] \n              (map (fn [row] (apply str row))\n                   (reduce #(assoc-in % [(second %2) (first %2)] \\#) nuthin lifeset))))\n          ]\n    (apply vector (-> coll\n                      strs->set\n                      plant-seeds\n                      (sprout (strs->set coll))\n                      set->strs))))","user":"53bf0913e4b0c98a41f5cc99"},{"code":"(fn game-of-life [board]\n  (let [height (count board)\n        width  (count (first board))\n        all-cells  (for [i (range height), j (range width)] [i j])\n        live-cells (set (filter #(= \\# (get-in board %)) all-cells))\n        neighbors  (fn [[x y]]\n                     (for [i [(dec x) x (inc x)], j [(dec y) y (inc y)]\n                           :when (not (and (= x i) (= y j)))]\n                       [i j]))\n        live-neighbors #(filter live-cells (neighbors %))\n        survive?       #(let [n (count (live-neighbors %))]\n                          (or (= n 3) (and (live-cells %) (= n 2))))\n        next-live-cells (filter survive? all-cells)]\n    (->> next-live-cells\n         (reduce (fn [rows cell] (assoc-in rows cell \\#))\n                 (vec (repeat height (vec (repeat width \\space)))))\n         (map #(apply str %)))))","problem":94,"user":"50586354e4b06522596eba78"},{"problem":94,"code":"(fn [t] \n  (for [y (range (count t))]\n       (apply str\n         (for [x (range (count (first t)))]\n              (let [t #(get-in t [% %2])\n                    n\n                    (count (for [[a b] [[-1 -1] [-1 0] [-1 1] [0 -1] [0 1] [1 -1] [1 0] [1 1]]\n                                   :when (= \\# (t (+ a y) (+ b x)))] 1))]\n                    (cond\n                      (= n 3) \"#\"\n                      (= n 2) (t y x)\n                      :else \" \"))))))","user":"53500869e4b084c2834f4ad3"},{"problem":94,"code":"(fn [b]\n            (let [maxy (count b)\n                  maxx (count (first b))]\n              (->> (for [y (range maxy)\n                         x (range maxx)]\n                     (let [nn (count\n                                (for [j (range (max 0 (dec y)) (inc (min maxy (inc y))))\n                                      i (range (max 0 (dec x)) (inc (min maxx (inc x))))\n                                      :when (= \\# (get-in b [j i]))]\n                                  [i j]))]\n                       (if (or (= nn 3) (and (= \\# (get-in b [y x])) (= nn 4))) \\# \\space)))\n                   (partition maxx)\n                   (mapv (partial apply str)))))","user":"59419bdfe4b060784b3b78f7"},{"problem":94,"code":"(fn [board]\n    (let [old-board (mapv vec board)\n          x-size (count (first old-board))\n          y-size (count old-board)]\n      (->>\n        (for [x (range x-size)\n              y (range y-size)]\n          (let [alive? (= (get-in old-board [x y]) \\#)\n                neighbor-coords (for [x-offset (range (dec x) (+ x 2))\n                                      y-offset (range (dec y) (+ y 2))\n                                      :when (not= [x-offset y-offset] [x y])]\n                                  [x-offset y-offset])\n                alive-neighbors (->> neighbor-coords\n                                  (map #(get-in old-board %))\n                                  (filter #(= % \\#))\n                                  (count))]\n            (cond\n              (< alive-neighbors 2) \\space\n              (and alive? (< 1 alive-neighbors 4)) \\#\n              (and alive? (< 3 alive-neighbors)) \\space\n              (and (not alive?) (= alive-neighbors 3)) \\#\n              :else \\space)))\n        (partition x-size)\n        (mapv #(apply str %)))))","user":"5317d78ee4b08068f379ed63"},{"code":"(fn [arg]\r\n  (let\r\n      [in-bounds? (fn [x y] (and (< -1 x)\r\n                                 (< -1 y)\r\n                                 (> (count arg) y)\r\n                                 (> (count (nth arg y)) x)))\r\n      cell-at (fn [x y] (= \\# (nth (nth arg y) x)))\r\n      int-neighbours #(range (- % 1) (+ % 2))\r\n      neighbours (fn [x y] (for [new-x (int-neighbours x)\r\n                                 new-y (int-neighbours y)]\r\n                             (list new-x new-y)))\r\n      valid-neighbours (fn [x y]\r\n                         (filter #(and (apply in-bounds? %)\r\n                                       (not (and (= x (first %))\r\n                                                 (= y (second %)))))\r\n                                 (neighbours x y)))\r\n      count-neighbours (fn [x y] (count (filter #(apply cell-at %)\r\n                                                (valid-neighbours x y))))\r\n      new-cell (fn [x y] (if (if (cell-at x y)\r\n                                 (< 1 (count-neighbours x y) 4)\r\n                                 (= 3 (count-neighbours x y)))\r\n                             \\#\r\n                             \\space))\r\n      next-state (fn [] (map #(apply str %)\r\n                             (for [y (range (count arg))]\r\n                               (for [x (range (count (nth arg y)))]\r\n                                 (new-cell x y)))))]\r\n \r\n    (next-state)))","problem":94,"user":"4eb66737535d7eef3080736b"},{"problem":94,"code":"(fn [b]\n  (let [n (count b)\n        valid? #(<= 0 % (dec n))\n        nbr-count (fn [x y]\n                    (->> (for [i (range (dec x) (+ x 2))\n                               j (range (dec y) (+ y 2))\n                               :when (and (not= [i j] [x y]) (valid? i) (valid? j))]\n                           [i j])\n                         (keep #(if (= \\# (get-in b %)) %))\n                         count))\n        next-val (fn [x y]\n                   (condp (fn [[c f] [v nc]] (and (= c v) (f nc)))\n                          [(get-in b [x y]) (nbr-count x y)]\n                     [\\# #(< % 2)] \\space\n                     [\\# #(<= 2 % 3)] \\#\n                     [\\# #(> % 3)] \\space\n                     [\\space #(= % 3)] \\#\n                     \\space))]\n    (map #(apply str (map (partial next-val %) (range n))) (range n))))","user":"54055aa9e4b0addc1aec6665"},{"problem":94,"code":"(fn next-gen [board]\n  (let [num-rows (count board)\n        num-cols (count (first board))\n        next-gen-cell (fn [board i j]\n                        (let [cell (get-in board [i j])\n                              neighbors (for [row [(dec i) i (inc i)]\n                                              col [(dec j) j (inc j)]\n                                              :when (not= [row col] [i j])]\n                                          (get-in board [row col] nil))\n                              num-live-neighbors (count (filter #{\\#} neighbors))\n                              num-dead-neighbors (count (filter #{\\space} neighbors))]\n                          (if (= cell \\space)\n                            (if (= num-live-neighbors 3)\n                              \\#\n                              \\space)\n                            (cond\n                              (< num-live-neighbors 2) \\space\n                              (#{2 3} num-live-neighbors) \\#\n                              :else \\space))))]\n    (for [i (range num-rows)]\n      (apply str (for [j (range num-cols)]\n                   (next-gen-cell board i j))))))","user":"5b51b9f8e4b02d533a91bcfe"},{"code":"(fn [ts] \n  (let [cr (count ts)\n        cc (+ 2 (count (first ts)))\n        ts (map #(clojure.string/join \"\" [\" \" % \" \"]) ts)\n        newl (clojure.string/join \"\" (repeat cc \" \"))\n        s (concat [newl] ts [newl])\n        cnt (fn [x] (count (filter #(= \\# %) x)))\n        g (fn [x] \n            (let [nei (concat (take 4 x) (drop 5 x))\n                  n (cnt nei)\n                  self (nth x 4)]\n              (cond\n               (= 3 n) \\#\n               (< n 2) \\ \n               (> n 3) \\ \n               (= n 2) (if (= \\# self) \\# \\ ))))]\n    (->>    \n     s\n     (map (partial partition 3 1))    \n     (partition 3 1)   \n     (mapcat (partial apply map concat))\n     (map g)\n     (partition cr)\n     (map #(apply str %))\n     )))","problem":94,"user":"51944aaae4b0142f60b4aedc"},{"problem":94,"code":"(fn [prob] (let [alive (first \"#\")\n                    dead (first \" \")\n                    life-or-death? (fn [[x y] game] (nth (nth game y) x))\n                    offsets [-1 0 1]\n                    neighbours (fn [[x y] game] (->> (for [xo offsets]\n                                                       (for [yo offsets]\n                                                         [(+ x xo) (+ y yo)]))\n                                                     identity\n                                                     (apply concat)\n                                                     (filter (fn [pair] (and (every? #(<= 0 % (dec (count game))) pair) (not= [x y] pair))))))\n                    living-neighbours (fn [[x y] prob] (->> (neighbours [x y] prob)\n                                                            (map #(life-or-death? % prob))\n                                                            (filter #(= alive %))\n                                                            count))\n                    live-or-die? (fn [[x y] prob]\n                                   (let [neigh-count (living-neighbours [x y] prob)]\n                                     (if (= alive (life-or-death? [x y] prob))\n                                       (if (contains? #{2 3} neigh-count) alive dead)\n                                       (if (= 3 neigh-count) alive dead))))]\n                (->> (for [y (range (count prob))]\n                       (for [x (range (count (first prob)))]\n                         (live-or-die? [x y] prob)))\n                     (map #(apply str %)))))","user":"54db3d82e4b024c67c0cf75f"},{"problem":94,"code":"(fn [board]\n  (letfn\n    [(alive? [cell] (= \\# (get-in board cell)))\n     (neighbors [[row col]] (count (filter alive? [[(dec row) (dec col)]\n                                                   [(dec row)      col ]\n                                                   [(dec row) (inc col)]\n                                                   [     row  (dec col)]\n                                                   [     row  (inc col)]\n                                                   [(inc row) (dec col)]\n                                                   [(inc row)      col ]\n                                                   [(inc row) (inc col)]])))\n     (lives? [cell] (if (alive? cell)\n                      (contains? #{2 3} (neighbors cell))\n                      (= 3 (neighbors cell))))]\n    (for [row (range (count board))]\n      (apply str\n             (for [col (range (count (nth board row)))]\n               (if (lives? [row col]) \\# \\space))))))","user":"55f20e4be4b06e875b46ce40"},{"code":"(fn gol-next-gen [board]\n  (let [len (count board)\n        in-range? (fn [n a b]\n                    (and (>= n a) (< n b)))\n        gol-count-neighbours (fn [i j board]\n                           (let [dirs [[0 -1] [1 -1] [1 0] [1 1] [0 1] [-1 1] [-1 0] [-1 -1]]\n                                 len (count board)]\n                             (reduce\n                              (fn [res [x y]]\n                                (if (and\n                                     (in-range? (+ i x) 0 len)\n                                     (in-range? (+ j y) 0 len)\n                                     (= (get (get board (+ i x)) (+ j y)) \\#))\n                                  (inc res)\n                                  res))\n                              0\n                              dirs)))]\n    (->> (for [i (range len)\n              j (range len)\n              :let [n (gol-count-neighbours i j board)]]\n          (if (= (get (board i) j) \\space)\n            (if (= n 3) \\# \\space)\n            (cond\n              (< n 2) \\space\n              (<= n 3) \\#\n              :else \\space)))\n      (partition len)\n      (map #(apply str %)))))","problem":94,"user":"526ee63de4b03e8d9a4a733f"},{"code":"(fn [board]\n  (letfn [(live?\n            [[x y :as coords] cell]\n            (let [x- (dec x) x+ (inc x) y- (dec y) y+ (inc y)\n                  adjacent [[x- y-] [x y-] [x+ y-] [x+ y] [x+ y+] [x y+] [x- y+] [x- y]]\n                  n-neighbors (frequencies (map (partial get-in board) adjacent))]\n              (case (get n-neighbors \\# 0)\n                (0 1 4 5 6 7) \\space\n                2 cell\n                3 \\#)))\n            (map-board\n             [f]\n             (map-indexed\n              (fn [row line]\n                (apply str\n                       (map-indexed\n                        (fn [column cell]\n                          (f [row column] cell))\n                        line)))\n              board))]\n          (map-board live?)))","problem":94,"user":"51f9527fe4b09be9c177e549"},{"problem":94,"code":"#(map-indexed \n  (fn [i r]\n    (apply str (map-indexed \n      (fn [j v]\n        (let [n (count \n                 (filter (fn [e] (= e \\#)) \n                         (map (fn [[x y]] (get-in % [(+ i x) (+ j y)] 0)) [[-1 -1] [-1 0] [-1 1] [0 -1] [0 1] [1 -1] [1 0] [1 1]])))]\n          (if (= v \\#)\n            (if (or (= n 2) (= n 3)) \\# \\ )\n            (if (= n 3) \\# \\ ))))\n      r)))    \n  %)","user":"561047eae4b05f002753df6d"},{"problem":94,"code":"(fn [b]\n  (map-indexed \n    (fn [ri row]\n      (apply\n        str\n        (map-indexed \n          #(let [nc (count (for [x (range (dec ri) (+ ri 2)) y (range (dec %1) (+ %1 2))\n                                    :when (and (not= [x y] [ri %1])\n                                          (= \\# (get-in b [x y])))]\n                                1))]\n              (cond\n                (= %2 \\#) \n                (cond \n                  (< nc 2) \\space\n                  (and (> nc 1) (< nc 4)) \\#\n                  :else \\space)\n                (and (= %2 \\space) (= nc 3)) \\#\n                :else %2)) \n          row))) \n    b))","user":"576df252e4b0979f8965156f"},{"problem":94,"code":"(fn [m]\n  (let [I (count m)\n        J (count (m 0))]\n    (->> (for [i (range (count m))\n               j (range (count (m 0)))]\n           (let [cell\n                 (get-in m [i j])\n                 neighbour\n                 (for [x (concat [i] (if (> i 0) [(dec i)]) (if (< i (dec I)) [(inc i)]))\n                       y (concat [j] (if (> j 0) [(dec j)]) (if (< j (dec J)) [(inc j)]))]\n                   [x y])\n                 {live \\# dead \\space :or {live 0 dead 0}}\n                 (->> neighbour (map #(get-in m %)) frequencies)]\n             (if (= \\  cell)\n               (if (= 3 live) \\# \\ )\n               (if (<= 3 live 4) \\# \\ ))))\n      (partition J)\n      (mapv #(apply str %)))))","user":"50479524e4b0371827a27bc4"},{"problem":94,"code":"(fn [bb]\n(letfn [\n      ; calc neighbour cells\n      (nbs [[x y]]\n        (->> '([-1 -1] [-1 0] [-1 1] [0 -1] [0 1] [1 -1] [1 0] [1 1])\n          (map #(vector (+ x (% 0)) (+ y (% 1))) )\n          (map #(get-in bb %))\n          (filter #(= \\# %))\n          (count)\n          ))\n\n    ; calc next status\n    (new_cell [[x y]]\n      (let [nb_count (nbs [x y])]\n        (if (= \\# (get-in bb [x y]))\n            (if (or (< nb_count 2) (> nb_count 3)) \\space \\#)\n            (if (= 3 nb_count) \\# \\space)) ))\n\n    ; calc new board\n    (new_bb [bb]\n      (let [rows (count bb), cols (count (bb 0))]\n        (->>\n          (for [x (range rows), y (range cols)] [x y])  ; all coords\n          (map new_cell)\n          (partition rows)\n          (map #(apply str %)) )))\n    ]\n  (new_bb bb)))","user":"593f95d8e4b069cdc2982be3"},{"problem":94,"code":"(fn game-of-life [board]\n  (let [neighbors [[0 -1] [0 1] [-1 0] [1 0] [-1 -1] [1 1] [-1 1] [1 -1]]\n        neighbor-count (fn [y x]\n                    (count (filter #(= % \\#)\n                            (map (fn [[step-y step-x]] (get-in board [(+ y step-y) (+ x step-x)])) neighbors))))]\n\n    ;(println neighbors)\n    (vec (map-indexed\n      (fn [y s]\n        (apply str (map-indexed\n          (fn [x c]\n            (let [n-count (neighbor-count y x)]\n              (cond\n                (and (= c \\#) (< n-count 2)) \\space\n                (and (= c \\#)  (or (= n-count 2) (= n-count 3))) \\#\n                (and (= c \\#)  (>  n-count 3)) \\space\n                (and (= c \\space) (= n-count 3)) \\#\n                 :else \\space)))\n          s)))\n      board))))","user":"559b55d6e4b066d22e731f54"},{"problem":94,"code":"(fn next-board [board] \n  (let [\n        nr (count board)\n        br (dec nr)\n        nc (count (first board))\n        rc (dec nc)\n        n (* nr nc)\n        live \\#\n        dead \\space\n\n        to-vec (fn [a] (into [] (mapcat identity a)))\n        to-board (fn [v] (into [] (map #(apply str %) (partition nr v))))\n        to-rc (fn [i] [(quot i nr) (mod i nc)])\n        to-i  (fn [[r c]] (+ (* r nr) c))    \n        rc?  (fn [[r c]] (and (>= r 0) (>= c 0) (< r nr) (< c nc)))\n        rcadd  (fn [[r0 c0] [r1 c1]] [(+ r0 r1) (+ c0 c1)])\n\n        nghbr-idxs (fn nghbr-idxs [i]\n                     (->> [[-1 -1] [-1 0] [-1 1] [0 -1] [0 1] [1 -1] [1 0] [1 1]]\n                       (map (partial rcadd (to-rc i)))\n                       (filter rc?)\n                       (map #(to-i %))))\n\n        next-state (fn [cv i] \n                     (let [nghbrs (map #(cv %) (nghbr-idxs i))\n                           nr-live-nghbrs (count (filter #(= % live) nghbrs))\n                           nr-dead-nghbrs (fn [cv i] (count (filter #(= % dead) nghbrs)))]\n                           \n                       (cond (= live (cv i))(cond (< nr-live-nghbrs 2) dead\n                                                 (= nr-live-nghbrs 2) live \n                                                 (= nr-live-nghbrs 3) live\n                                                 (> nr-live-nghbrs 3) dead)\n                             (= dead (cv i)) (cond (= nr-live-nghbrs 3) live\n                                    \t              :else dead))))\n        next-board-vec (fn [cv] \n                         (into [] (map #(next-state cv %) (range (count cv)))))\n        ]\n\n    (to-board (next-board-vec (to-vec board)))))","user":"578cf84ce4b0ebec4cfb7562"},{"code":"(fn [m]\n    (let [cell (fn [m, x, y]\n                 (cond\n                   (or (< x 0) (> x (dec (count (m 0))))\n                       (< y 0) (> y (count m)))\n                     nil\n                   :else\n                     (get (m x) y))),\n          live? (fn [c] (= \\# c)),\n          dead? (fn [c] (= \\  c)),\n          count-live (fn [v] (apply + (map #(if (live? %1) 1 0) v))),\n          count-dead (fn [v] (apply + (map #(if (dead? %1) 1 0) v))),\n          neighbors (fn [m, x, y]\n                      (vector\n                        (cell m      x  (dec y)) ; north\n                        (cell m (inc x) (dec y)) ; north-east\n                        (cell m (inc x)      y)  ; east\n                        (cell m (inc x) (inc y)) ; south-east\n                        (cell m      x  (inc y)) ; south\n                        (cell m (dec x) (inc y)) ; south-west\n                        (cell m (dec x)      y)  ; west\n                        (cell m (dec x) (dec y)) ; north-west\n                        )),\n          next-gen (fn [m]\n                     (for [i (range (count m))]\n                       (for [j (range (count (m 0)))]\n                         (let [c (cell m i j), n (count-live (neighbors m i j))]\n                           (cond\n                             (dead? c) (if (= 3 n) \\# \\  )\n                             (live? c) (if (or (= 2 n) (= 3 n)) \\# \\  )\n                             :else \\  )\n                           ))))]\n      (into [] (for [v (next-gen m)] (apply str v)))\n    ))","problem":94,"user":"4f038567535dcb61093f6b0c"},{"code":"(fn [field]\n   (let [h (count field) w (count (first field))\n    get-cell (fn [x y] (if (and (>= x 0) (>= y 0) (< x w) (< y h) (= (nth (nth field y) x) \\#)) 1 0))\n    count-neigbours (fn [x y]\n      (apply + (map #(apply get-cell %)\n                [[(dec x) (dec y)] [x (dec y)] [(inc x) (dec y)]\n                [(dec x) y]  [(inc x) y]\n                [(dec x) (inc y)] [x (inc y)] [(inc x) (inc y)]])))\n    next-step-alive? (fn [x y]\n      (or \n       (and (= 1 (get-cell x y)) (#{2 3} (count-neigbours x y)))\n       (and (#{3} (count-neigbours x y)))))]\n    (map    ; process rows\n     (fn process-row [y] (clojure.string/join \"\" (map #(if (next-step-alive? % y) \\# \\space) (range w))))\n     (range h))))","problem":94,"user":"515828b8e4b0a069fd272c71"},{"problem":94,"code":"(fn [s]\n  (let [su (->> s\n                (map-indexed (fn [i x]\n                                                (map-indexed (fn [i2 x2]\n                                                               (if (= \\# x2) [i i2] nil))\n                                                             x)))\n                                 (apply concat)\n                                 (filter #(not (nil? %)))\n                                 (set))\n        nbs (fn [[x y]]\n                     (set\n                      (for [dx (range -1 2)\n                            dy (range -1 2)\n                            :when (not= 0 dx dy)]\n                        [(+ x dx) (+ y dy)])))\n        ca #(->> %\n                           (clojure.set/intersection su)\n                           (count))\n        can (comp ca nbs) \n        t? #(or (= 3 %) (= 2 %))\n        rbcs (clojure.set/difference\n                            (apply clojure.set/union (map nbs su))\n                            su)\n        r (filter #(= 3 (can %)) rbcs)\n        ss (filter #(t? (can %)) su)\n        nx (clojure.set/union ss r)]\n    (mapv #(apply str %)\n          (map-indexed (fn [i x]\n                         (map-indexed (fn [i2 x2]\n                                        (if (contains? (set nx) [i i2])\n                                          \\#\n                                          \\space))\n                                      x))\n                       s))))","user":"57ec3d29e4b0bfb2137f5b77"},{"code":"(fn g [a i j v p b]\n  (let [n (-> b first i)\n        m (i b)]\n    (p #(a str %)\n        (loop [r [] c (p #(let [s (and (= 9 (i %)) (= \\# (nth % 4)))\n                                c (i (filter (fn [i] (= \\# i)) %))]\n                            (if (and s (or (> c 4) (< c 3)))\n                              \\ \n                              (if (or s (= c 3))\n                                \\#\n                                \\ ))) \n                           (for [y (j 0 m)\n                                 x (j 0 n)]\n                             (flatten\n                               (p #(v (a vector %)\n                                      (max 0 (- x 1))\n                                      (min n (+ x 2)))\n                                  (v b (max 0 (- y 1)) (min m (+ y 2)))))))]                                                               \n          (if (= [] c)\n            r\n            (recur (conj r (take n c)) (drop n c)))))))\napply count range subvec map","problem":94,"user":"4e49badd535dc968683fc4c9"},{"code":"(fn next-gen [world]\n  (let [\n     lines (count world)\n     cols  (count (first world))\n\n     indexate #(map vector % (range))\n\n     parse-cells (fn [world]\n       (set\n         (for [[line nline] (indexate world),\n               [ch   ncol]  (indexate line)\n               :when (= ch \\#)]\n           [nline ncol])))\n\n     unparse-cells (fn [cells]\n       (for [i (range lines)]\n         (apply str\n           (map #(if (contains? cells [i %]) \"#\" \" \") (range cols)))))\n\n     neighbours (fn [cell]\n       (map\n         (fn [delta] (map + cell delta))\n         [[-1 -1] [-1 0] [-1 1]\n          [ 0 -1]        [ 0 1]\n          [ 1 -1] [ 1 0] [ 1 1]]))\n\n     survive?  #(and (>= % 2) (<= % 3))\n\n     newborn? #(== % 3)\n\n     step (fn [cells]\n       (let [neigs     (frequencies (mapcat neighbours cells))\n             survivors (filter (fn [cell] (survive? (get neigs cell 0))) cells)\n             newborns  (map first (filter #(newborn? (second %)) neigs))]\n         (set (concat survivors newborns))))\n\n  ] (unparse-cells (step (parse-cells world)))))","problem":94,"user":"4eb9ce75535dfed6da9c6d5e"},{"problem":94,"code":"(fn [c]\n  (let [lc (fn lc\n                   [s x y]\n                   (if (empty? s)\n                       []\n                       (if (= \\# (first s))\n                           (conj (lc (rest s) (inc x) y)\n                                 {:t 1 :x x :y y})\n                           (conj (lc (rest s) (inc x) y)\n                                 {:t 2 :x x :y y}))))\n\n        ln (fn [c]\n                (mapcat #(lc %1 0 %2)\n                        c\n                        (range 0 (count c))))\n\n        nbor (fn [pl mp]\n               (let [x (:x mp) y (:y mp)]\n                 (->> (filter #(or (= (inc x) (:x %))\n                                   (= (dec x) (:x %))\n                                   (= x (:x %))) pl)\n                      (filter #(or (= (inc y) (:y %))\n                                   (= (dec y) (:y %))\n                                   (= y (:y %))))\n                      (remove #(= % mp)))))\n        sts (fn [pl mp]\n                 (let [nb (nbor pl mp)\n                       lives (filter #(= 1 (:t %)) nb)\n                       dies (filter #(= 2 (:t %)) nb)]\n                   (if (= 1 (:t mp))\n                       (cond (< (count lives) 2) :die\n                             (<= 2 (count lives) 3) :live\n                             :else :die)\n                       (if (= 3 (count lives))\n                           :live\n                           :die))))\n        ts (fn [pl i]\n                (loop [y 0 rs []]\n                  (if (= i y)\n                      rs\n                      (recur (inc y)\n                             (conj rs (apply str (map #(if (= (:t %) 1)\n                                                           \"#\"\n                                                           \" \")\n                                                      (sort-by :x (filter #(= y (:y %)) pl)))))))))\n        pl (ln c)]\n    (ts (loop [p pl rs []]\n             (if (empty? p)\n                 rs\n                 (recur (rest p)\n                        (let [mp (first p)]\n                          (if (= :die (sts pl mp))\n                              (conj rs (assoc mp :t 2))\n                              (conj rs (assoc mp :t 1)))))))\n           (count c))))","user":"528a3e14e4b0239c8a67ae72"},{"problem":94,"code":"(fn game-of-life [rs]\n  (let [row-length (count (first rs))\n        neighbors-fn (fn [r c] (count (filter (partial = \\#)\n                                              (for [x (range (dec r) (+ 2 r))\n                                                    y (range (dec c) (+ 2 c))]\n                                                (get-in rs [x y])))))]\n    (map (partial apply str)\n         (partition row-length\n                    (for [r (range (count rs))\n                          c (range row-length)]\n                      (let [living-neighborhood (neighbors-fn r c)\n                            is-live? (= \\# (get-in rs [r c]))]\n                        (cond (and is-live? (<= 3 living-neighborhood 4))\n                              \\#\n                              (and (not is-live?) (= 3 living-neighborhood))\n                              \\#\n                              :else\n                              \\space)))))))","user":"563fc1f2e4b08d4f616f5ed7"},{"problem":94,"code":"(fn [b]\n  (let [w (count (first b))\n        h (count b)\n        tp (for [y (range h)\n                 x (range w)]\n             [x y])]\n\n    (letfn [(is-alive? [[x y]]\n              (= (nth (nth b y) x) \\#))\n\n            (neighbors [[x y]]\n              (keep (fn [[px py :as p]] (when (= 1 (max (Math/abs (- x px)) (Math/abs (- y py)))) p))\n                    tp))\n\n            (alive-neighbors [p]\n              (keep #(when (is-alive? %) %) (neighbors p)))\n\n            (next-state [p]\n              (let [c (count (alive-neighbors p))]\n                (if (if (is-alive? p) (#{2 3} c) (= c 3)) \\# \\space)))]\n\n      (map (partial apply str)\n           (partition w (map next-state tp))))))","user":"537e745ae4b06839e8705ea6"},{"code":"(fn [g]\n    (map #(apply str %)\n         (let [\n               M (fn [f & z] (apply map (partial map f) z))\n               G (M {\\# 1 \\space 0} g)\n               t #(apply map list %)\n               r #(t (reverse %))\n               q #(cons 0 (butlast %))\n               p #(map q %)\n               P (comp t p t)\n               ]\n           (M #(if (= 3 %2) \\# (if (and (= 1 %) (= 2 %2)) \\# \\space))\n              G\n              (r (reduce #(M + (r %) %2)\n                         (let [l (map p (take 4 (iterate r G)))]\n                           (into (vec l) (map P l)))))\n              ))))","problem":94,"user":"4fb1325de4b081705acca276"},{"problem":94,"code":"(fn [board]\n  (let [alive \\#\n        dead \\space\n        offsets [[-1 -1] [ 0 -1] [ 1 -1]\n                 [-1  0]         [ 1  0]\n                 [-1  1] [ 0  1] [ 1  1]]\n        rules {alive #{2 3}\n               dead #{3}}]\n    (letfn [(calc-dimensions [matrix]\n                             [[0 (dec (count matrix))] [0 (dec (count (first matrix)))]])\n\n            (valid-coordinate? [[[min-row max-row] [min-col max-col]] [row col]]\n                               (and (<= min-col col max-col)\n                                    (<= min-row row max-row)))\n\n            (alive? [matrix [x y]]\n                    (let [row (nth matrix x)\n                          val (nth row y)]\n                      (= alive val)))\n\n            (alive-neighbor-count [[i j] matrix]\n                                  (let [dimensions (calc-dimensions matrix)]\n                                    (->> (map #(map + % [i j]) offsets)\n                                         (filter #(valid-coordinate? dimensions %))\n                                         (map #(alive? matrix %))\n                                         (filter true?)\n                                         count)))\n\n            (gen-cells [matrix]\n                       (for [[i row] (map-indexed vector matrix)\n                             [j cell] (map-indexed vector row)]\n                         (vector i j cell)))\n\n            (calc-next-val [matrix [x y cell]]\n                           (let [neighbor-count (alive-neighbor-count [x y] matrix)\n                                 is-alive (get rules cell)]\n                             (if (is-alive neighbor-count) alive dead)))\n\n            (calc-next-generation [board]\n                                  (let [matrix (map seq board)]\n                                    (->> (gen-cells matrix)\n                                         (map #(calc-next-val matrix %))\n                                         (partition (count (first board)))\n                                         (map clojure.string/join))))\n            ]\n      (calc-next-generation board)\n\n      )\n    )\n  )","user":"549dfe40e4b0f3d1d8e70f9a"},{"problem":94,"code":"(fn [brd]\n  (let [brd (vec (map vec brd))\n        nr (count brd)\n        nc (count (brd 0))\n        neigh (fn [r c]\n                (count (filter identity\n                  (for [rr [-1 0 1] cc [-1 0 1]\n                        :when (or (not= rr 0) (not= cc 0))]\n                        (= \\# (get-in brd [(+ r rr) (+ c cc)]))))))]\n        (->>\n          (for [r (range nr)\n                c (range nc)]\n            (let [n (neigh r c)]\n              (if (= \\# (get-in brd [r c]))\n                (cond\n                  (< n 2) \\space\n                  (<= 2 n 3) \\#\n                  :else \\space)\n                (if (= n 3) \\# \\space))))\n          (partition nc) (map #(apply str %)))))","user":"5416b4a2e4b01498b1a71a01"},{"problem":94,"code":"(fn [board]\n  (let [tripart (partial partition 3 1)\n        transpose (partial apply map vector)\n        goto (fn [[row1 [c- cell c+] row3]]\n               (-> [c- c+]\n                   (into row1)\n                   (into row3)\n                   frequencies\n                   (get \\# 0)\n                   int\n                   (case 3 \\# 2 cell \\space)))\n        wrap (fn [pad s] (-> [pad] (into s) (conj pad)))]\n    (->> board\n         tripart\n         (map #(->> %\n                    transpose\n                    tripart\n                    (map goto)\n                    (wrap \\space)\n                    (apply str)))\n         (wrap (first board)))))","user":"55dcb06ee4b050e68259b3b9"},{"code":"(fn [c]\n  (letfn [( f [[a b]]\n            (for [i [-1 0 1]\n                  j [-1 0 1] :when (not= i j 0)]\n              [(+ a i) (+ b j)]))]\n    (map #(apply str %)\n         (map-indexed\n          (fn [i x]\n            (map-indexed \n             (fn [j y]\n               (let [n (map #(get-in c %) (f [i j]))\n                     a (count (filter #{\\#} n))]\n                 (cond (= a 3) \\#\n                       (= a 2) (get-in c [i j])\n                       :else \\space))\n               ) x))\n          c))))","problem":94,"user":"529b44afe4b02ebb4ef7509d"},{"problem":94,"code":"(fn step [board-strings]\n  (let [board-size (count board-strings)\n        make-row (fn [s] (mapv #(= % \\#) (seq s)))\n        board (mapv make-row board-strings)\n        get-cell (fn [[x y]] (get (get board y) x))\n        offsets (for [x (range -1 2) y (range -1 2)\n                      :when (not= 0 x y)] [x y])\n        neighbours (fn [x y] (map (fn [[dx dy]] [(+ x dx) (+ y dy)]) offsets))\n        neighbours-live (fn [x y] (count (filter get-cell (neighbours x y))))\n        new-cell (fn [x y]\n                   (let [live (get-cell [x y])\n                         neighbours (neighbours-live x y)]\n                     (cond\n                       (and live (< neighbours 2)) false\n                       (and live (< neighbours 4)) true\n                       live false\n                       (= neighbours 3) true\n                       :else false)))\n        new-row (fn [y] (mapv #(new-cell % y) (range board-size)))\n        new-board (mapv new-row (range board-size))]\n    (mapv (fn [row] (apply str (map #(if % \"#\" \" \") row))) new-board)))","user":"5f648ef1e4b02876ed9fd01b"},{"problem":94,"code":"(fn [b]\n    (let [neighborhood\n          (partition 2\n                     (flatten\n                      (for [x [-1,0,1]]\n                        (for [y [-1,0,1] :when (not (and (= x 0) (= y 0)))] [x y]))))]\n      (letfn [(bget [b x y]\n                (get (get b y) x))\n              (neighbors [b x y]\n                (map (fn [[x1 y1]] (bget b (+ x x1) (+ y y1))) neighborhood))\n              (num-neighbors [b x y]\n                (count (filter #(= \\# %) (neighbors b x y))))\n              (new-state [b x y]\n                (let [live (= (bget b x y) \\#)\n                      num (num-neighbors b x y)]\n                  (if live\n                    (cond (< num 2) \" \"\n                          (> num 3) \" \"\n                          :else \"#\")\n                    (if (= num 3) \\# \" \"))))\n              (line [b y]\n                (let [l (for [x (range 1 (- (count b) 1))] (new-state b x y))]\n                  (str \" \" (apply str l) \" \")))]\n        (conj (vec (cons (get b 0) (for [y (range 1 (- (count b) 1))] (line b y)))) (get b 0)))))","user":"4f3ec266e4b0e243712b1f8c"},{"code":"(fn [board]\n  (let [w (count (first board))\n        h (count board)\n        live? (fn [[x y]] (and (>= x 0) (< x w) (>= y 0) (< y h) (= \\# (get-in board [y x]))))\n        neighbors (fn [[x y]]\n          (count (filter live? [[(dec x) y] [(inc x) y] [x (dec y)] [x (inc y)] [(inc x) (inc y)] [(dec x) (dec y)] [(inc x) (dec y)] [(dec x) (inc y)]])))\n        should-live? (fn [xy]\n          (cond\n            (< (neighbors xy) 2) false\n            (= 2 (neighbors xy)) (live? xy)\n            (= 3 (neighbors xy)) true\n            true false))]\n    (map (fn [y]\n      (apply str (map (fn [x]\n        (if (should-live? [x y]) \"#\" \" \")) (range w)))) (range h))))","problem":94,"user":"4ebc08a8535dfed6da9c6d7c"},{"code":"(fn [bd]\r\n  (let [os [[-1 -1] [-1 0] [-1 1]\r\n                 [0 -1] [0 1]\r\n                 [1 -1] [1 0] [1 1]]\r\n        h (count bd)\r\n        w (count (first bd))\r\n        gs (fn [[x y] [dx dy]]\r\n                    (let [c (+ x dx) r (+ y dy)] \r\n                      (if (or (< c 0) (= c w) (< r 0) (= r h))\r\n                        \\space\r\n                        (get-in bd [r c]))))\r\n        cl (fn [p]\r\n                      (reduce + (map #(if (= \\# (gs p %)) 1 0) os)))\r\n        nx (fn [s p]\r\n                     (let [n (cl p)] \r\n                       (if (or (= n 3)\r\n                               (and (= s \\#) (= n 2)))\r\n                         \\#\r\n                         \\space)))] \r\n    (->> (for [y (range h) x (range w)]\r\n           (nx (get-in bd [y x]) [x y]))\r\n      (partition w)\r\n      (map #(apply str %))\r\n      (vec))))","problem":94,"user":"4dc986d0535d5973398f9285"},{"problem":94,"code":"(fn grid-life-gen [g]                                                                                                                                                                                                                                                                    \n  (let [string->index (fn [s]                                                                                                                                                                                                                                                              \n                        (let [indexes (keep-indexed (fn [idx c]                                                                                                                                                                                                                            \n                                                      (when (= \\# c)                                                                                                                                                                                                                       \n                                                        idx))                                                                                                                                                                                                                              \n                                                    (seq s))]                                                                                                                                                                                                                              \n                          (when-not (empty? indexes)                                                                                                                                                                                                                                       \n                            indexes)))                                                                                                                                                                                                                                                     \n        grid->set-w-meta (fn [g]                                                                                                                                                                                                                                                           \n                           (let [ys2xs (keep-indexed (fn [idx l]                                                                                                                                                                                                                           \n                                                        (when-let [xs (string->index l)]                                                                                                                                                                                                   \n                                                          [idx xs]))                                                                                                                                                                                                                       \n                                                     g)                                                                                                                                                                                                                                    \n                                 lset (reduce (fn [acc [y xs]]                                                                                                                                                                                                                             \n                                                (into acc (mapv (fn [x]                                                                                                                                                                                                                    \n                                                                  [x y])                                                                                                                                                                                                                   \n                                                                xs)))                                                                                                                                                                                                                      \n                                              #{}                                                                                                                                                                                                                                          \n                                              ys2xs)]                                                                                                                                                                                                                                      \n                             {:set lset                                                                                                                                                                                                                                                    \n                              :w (count (first g))                                                                                                                                                                                                                                         \n                              :h (count g)}))                                                                                                                                                                                                                                              \n        set-w-meta->grid (fn [{:keys [set w h] :as set-w-meta}]                                                                                                                                                                                                                            \n                           (->> (for [y (range h)                                                                                                                                                                                                                                          \n                                      x (range w)]                                                                                                                                                                                                                                         \n                                  (if (get set [x y])                                                                                                                                                                                                                                      \n                                    \\# \\space))                                                                                                                                                                                                                                            \n                                (partition w)                                                                                                                                                                                                                                              \n                                (mapv #(apply str %))))                                                                                                                                                                                                                                    \n                                ;;;(map #(println %))))                                                                                                                                                                                                                                    \n        neighbours (fn [[x y]]                                                                                                                                                                                                                                                             \n                     (for [dx [-1 0 1] dy [-1 0 1] :when (not= 0 dx dy)]                                                                                                                                                                                                                   \n                       [(+ dx x) (+ dy y)]))                                                                                                                                                                                                                                               \n        next-gen (fn [life]                                                                                                                                                                                                                                                                \n                   (let [survive? #{2 3}                                                                                                                                                                                                                                                   \n                         birth? #{3}                                                                                                                                                                                                                                                       \n                         next-gen (set (for [[loc n] (frequencies (mapcat neighbours life))                                                                                                                                                                                                \n                                             :when (if (life loc) (survive? n) (birth? n))]                                                                                                                                                                                                \n                                         loc))]                                                                                                                                                                                                                                            \n                     next-gen))                                                                                                                                                                                                                                                            \n        set-w-meta (grid->set-w-meta g)                                                                                                                                                                                                                                                    \n        next-gen (next-gen (:set set-w-meta))                                                                                                                                                                                                                                              \n        new-set-w-meta (assoc set-w-meta :set next-gen)]                                                                                                                                                                                                                                   \n      (set-w-meta->grid new-set-w-meta)))","user":"56f4cedce4b046a417f92063"},{"code":"(fn [d]\n   (let [model  (vec (map vec d))\n         r-e (range (count model))\n         r-i (range (count (get model 0)))\n         places (fn  [data  r c]\n                  (let [e (> c 0)\n                        w (< c (dec (count (get data 0))))\n                        n (> r 0)\n                        s (< r (dec (count data)))\n                        nw (and n w)\n                        sw (and s w)\n                        se (and e s)\n                        ne (and n e)\n                        res (->>\n                             (map (fn [one two]\n                                    (when one two))\n                                  [n nw w sw s se e ne]\n                                  [[(dec r) c]\n                                   [ (dec r) (inc c)]\n                                   [r (inc c) ]\n                                   [(inc r) (inc c)]\n                                   [ (inc r) c]\n                                   [(inc r) (dec c) ]\n                                   [r (dec c) ]\n                                   [(dec r) (dec c) ]\n                                   ])\n                             (filter (complement nil?))\n                             (map (partial get-in data))\n                             )]\n                    res))\n         conway-laws (fn [r c] (let [current (get (get model r) c)\n                                    the-lives (count (filter (partial = \\#) (places model r c)))]\n                                (if (= \\# current)\n                                  (if (<  the-lives 2)\n                                    \\space\n                                    (if (<= the-lives 3)\n                                      \\#\n                                      \\space\n                                      ))\n                                  (if (= 3 the-lives)\n                                    \\#\n                                    \\space\n                                    )\n                                  )\n                                ))]\n     (vec (map (fn [r] (apply str (map (fn [c] (conway-laws r c)) r-i)) ) r-e))\n )\n   )","problem":94,"user":"50550f43e4b0b1b9d1860eb7"},{"problem":94,"code":"(fn [s]\n (letfn [(row [cn r]\n           (list (get r (dec cn))\n                 (get r cn)\n                 (get r (inc cn))))\n         (neigh [s rn cn]\n           (lazy-cat\n            (row cn (get s (dec rn)))\n            (list\n             (get-in s [rn (dec cn)])\n             (get-in s [rn (inc cn)])\n             )\n            (row cn (get s (inc rn)))))\n         (revo [[c n]]\n           (if (= c \\#)\n             (case n\n               (0 1) \\space\n               (2 3) \\#\n               \\space)\n             (case n\n               3 \\#\n               \\space)\n             ))]\n   (let [rn (count s)\n         cn (count (get s 0))]\n       (map #(apply str %)\n         (partition cn (map\n                        revo\n                        (for [r (range rn)\n                              c (range cn)]\n                          [(get-in s [r c])\n                           (count (filter #{\\#} (neigh s r c)))])))))\n   ))","user":"4f5cc3b8e4b0030a34fb2b2b"},{"problem":94,"code":"(fn [bd-str]\n    (let [prs-row (fn [s] (vec s))\n          bd (mapv prs-row bd-str)\n          n-rows (count bd)\n          n-cols (count (nth bd 0))\n          get-cell (fn [bd [r c]] (get-in bd [r c]))\n          legal-cell? (fn [[r c]] (and (< -1 r n-rows) (< -1 c n-cols)))\n          neighbors (fn [[r c]] (->> (for [r1 [(dec r) r (inc r)]\n                                         c1 [(dec c) c (inc c)]]\n                                     [r1 c1])\n                                   (filter legal-cell?)\n                                   (remove #(= [r c] %))))\n          living-neighbors (fn [bd [r c]]\n                             (->> (neighbors [r c])\n                                  (map #(get-cell bd %) )\n                                  (filter #(= \\# %) )\n                                  count))\n          live? (fn [bd [r c]]\n                  (if (= \\# (get-cell bd [r c]))\n                    (< 1 (living-neighbors bd [r c]) 4)\n                    (= 3 (living-neighbors bd [r c]))))\n          wr-row (fn [bd r]\n                   (apply str (for [c (range n-cols)]\n                                (if (live? bd [r c]) \"#\" \" \"))))]\n      (for [r (range n-rows)]\n        (wr-row bd r))))","user":"5f93529ae4b0715f5002d7bc"},{"problem":94,"code":"(fn [x]\n (let [b (mapv (comp vec seq) x)\n       s (count x)\n       l (range s) \n       d [-1,0,1]]\n  (->> (mapcat #(map (fn [i] (if (= \\# ((b i) %)) (for [n d m d :when (not= 0 n m)] {[(+ i n) (+ % m)],1}) (list {[i,%],0}))) l) l)\n   (apply concat)\n   (apply merge-with +)\n   sort\n   (reduce (fn [x [[i j] n]] (concat x (cond (= 2 n) (str ((b i) j)) (= 3 n) \"#\" :else \" \"))) \"\")\n   (clojure.string/join)\n   (partition s)\n   (map clojure.string/join))))","user":"5b0180cfe4b0cc2b61a3bd47"},{"problem":94,"code":"(fn generate-new [board]\n  (let\n   [get-at (fn [board [x y]]\n             (-> board\n                 (nth x)\n                 (nth y)))\n    board-size (fn [board]\n                 [(dec (count board)) (dec (count (first board)))])\n    neighbour-coords (fn [board [x y]]\n                       (let [[sz-x sz-y] (board-size board)]\n                         (->> (for [ix (range (dec x) (+ 2 x))\n                                    iy (range (dec y) (+ 2 y))]\n                                [ix iy])\n                              (remove #(or\n                                         (neg? (first %))\n                                         (neg? (second %))\n                                         (> (first %) sz-x)\n                                         (> (second %) sz-y)\n                                         (= [x y] [(first %) (second %)]))))))\n    get-neighbours (fn [board [x y]]\n                     (map #(get-at board %) (neighbour-coords board [x y])))\n    count-neighbours (fn [board [x y]]\n                       (count (filter #(not= \\space %) (get-neighbours board [x y]))))\n    decide-fate  (fn [board [x y]]\n                   (let [curval   (get-at board [x y])\n                         is-alive (not= \\space curval)\n                         nbrs     (count-neighbours board [x y])]\n                     (cond\n                       (and is-alive (< nbrs 2)) \\space\n                       (and is-alive (<= 2 nbrs 3)) \\#\n                       (and is-alive (> nbrs 3)) \\space\n                       (and (not is-alive) (= nbrs 3)) \\#\n                       :else curval)))]\n    (->>\n      (let [[sz-x sz-y] (board-size board)]\n        (for [x (range (inc sz-x))]\n          (for [y (range (inc sz-y))]\n            (decide-fate board [x y]))))\n      (mapv #(apply str %)))))","user":"590b055ae4b047aa04b199c9"},{"code":"(fn life\n  [[r & _ :as board]]\n  (let [pad (apply str (repeat (+ 2 (count r)) \"+\"))\n        board (concat [pad] (map #(apply str (concat \"+\" % \"+\")) board) [pad])\n        blur (fn [rows] (apply (partial map vector) (map #(partition 3 1 %) rows)))\n        calc (fn [[_ [_ x _] _ :as block]]\n               (let [n (- (count (filter #(= \\# %) (flatten block)))\n                          (if (= \\# x) 1 0))]\n                 (cond\n                  (or (< n 2) (> n 3)) \" \"\n                  (= n 2) x\n                  :else \"#\")))]\n    (->>\n     (partition 3 1 board)\n     (mapcat blur)\n     (map calc)\n     (partition (count r))\n     (map (partial apply str)))))","problem":94,"user":"511d6a01e4b022853b0e07a5"},{"problem":94,"code":"(fn gol [board]\n  (let [board (mapv (fn [row] (mapv #(if (= % \\#) 1 0) row)) board)\n\n        next (map-indexed\n              (fn [y row]\n                (apply\n                 str\n                 (map-indexed\n                  (fn [x cell]\n                    (let [v (reduce +\n                                    (for [dx [-1 0 1]\n                                          dy (if (zero? dx) [-1 1] [-1 0 1])]\n                                      (or (get-in board [(+ dy y) (+ dx x)]) 0)))]\n                      (if (or\n                          (and (= 2 v) (= 1 (get-in board [y x])))\n                          (= 3 v))\n                        \"#\"\n                        \" \")\n                      ))\n                  row)))\n              board)\n        \n        ]\n    (doall next)))","user":"5d6042f2e4b0c9e5857d5006"},{"code":"(fn gol [board]\n  (let [bget (fn bget [row col]\n               (if (or\n                    (>= row (count board))           (< row 0)\n                    (>= col (count (nth board row))) (< col 0))\n                 nil\n                 (nth (nth board row) col)))\n        occupied (fn occupied [row col] (if (= (bget row col) \\#) 1 0))\n        neighbors\n        (fn neighbors [row col]\n          (+\n           (occupied (inc row) col)       (occupied (dec row) col)\n           (occupied row (inc col))       (occupied row (dec col))\n           (occupied (inc row) (inc col)) (occupied (dec row) (dec col))\n           (occupied (dec row) (inc col)) (occupied (inc row) (dec col))))]\n    (for [row (range (count board))]\n      (apply str\n       (for [col (range (count (nth board row)))]\n         (case (neighbors row col)\n           0 \\ , 1 \\ , 2 (bget row col), 3 \\#, \\ ))))))","problem":94,"user":"529ce629e4b04e0c58e87b6e"},{"problem":94,"code":"(fn [board] \n(letfn [\n(cellval [board l c ol oc]\n (if (=\n (get \n    (get board (+ l ol))\n    (+ c oc)\n ) \\#) 1 0)\n)\n\n(neighval [board l c]\n (reduce + (map \n  #(apply cellval board l c %1) \n  '((-1 -1) (-1 0) (-1 1) (0 -1) (0 1) (1 -1) (1 0) (1 1))\n ))\n) \n\n(nextgencell [board l c]\n  (let [score (neighval board l c) current (get (get board l) c)]\n(if (= current \\#)\n    (if (or (= score 2) (= score 3)) \\# \" \")\n    (if (= score 3) \\# \" \"  )\n   )\n  )\n)\n\n(nextgenline [board l c ngenline]\n (if (= (inc c) (count  (get board l))) (str ngenline (nextgencell board l c)) (recur board l (inc c) (str ngenline (nextgencell board l c)))\n)\n)\n\n(nextgenboard [board l nextgenb]\n (if (>= (inc l) (count board)) \n  (conj nextgenb (nextgenline board l 0 \"\"))\n  (recur board (inc l) (conj nextgenb (nextgenline board l 0 \"\")))\n )\n)\n]\n(nextgenboard board 0 [])))","user":"556f2009e4b09a3098a52519"},{"code":"(fn [strng]\n\n           (let [mx (count (first strng))\n                 mpa  (reduce (fn [map line]\n                               (reduce (fn [mp column]\n                                         (assoc mp (vector line column)\n                                                (nth (nth strng line) column)))\n                                       map (range mx))) {} (range mx) )\n                 score (fn  [mp [line column]]\n                         (if (nil? (#{[\\# 2] [\\# 3] [\\space 3]}\n                                    (vector (mp [line column])\n                                            (->> (for [x (range -1 2) y (range -1 2)\n                                               :when (or (not= x 0) (not= y 0))]\n                                                   (mp [(+ line x) (+ y column)]))\n                                                 (filter #(= \\# %)) count ) )))\n                           \\space \\#))\n                 nw  (reduce (fn [mp [[l c] v]] (assoc mp (vector l c)\n                                                      (score mpa [l c]))) {} mpa)]\n             \n             (map (fn [l] (apply str (map #(nw [ l %]) (range mx))))  (range mx))))","problem":94,"user":"5124619ae4b02c3f2a072ccd"},{"code":"(fn [tab]\n  (let [\n    tab (map (partial map { \\space 0 \\# 1}) tab)\n    nbor (fn [e f s] (map f (concat (rest s) [e]) s (cons e s)))\n  ]\n  (->> tab\n    (map (partial nbor 0 +))\n    (nbor (repeat 0) (partial map +))\n    (map (partial map (comp - -)) tab)\n    (map (partial map vector) tab)\n    (map (partial map #(if (#{[0 3] [1 2] [1 3]} %) \\# \\space)))\n    (map (partial apply str))\n)))","problem":94,"user":"50901b2ee4b0ea685a20f774"},{"problem":94,"code":"(fn [m]\n  (letfn [(n [m i j]\n            (for [v [-1 0 1]\n                  h [-1 0 1]\n                  :let [ni (+ i v)\n                        nj (+ j h)]\n                  :when (and (not= [ni nj] [i j])\n                             (pos? (inc ni))\n                             (pos? (inc nj))\n                             (< ni (count m))\n                             (< nj (count (first m)))\n                             (= \\# (get-in m [ni nj])))]\n                  \\#))]\n    (map-indexed\n      (fn [i row]\n        (apply str\n          (map-indexed\n            (fn [j v]\n              (let [n (count (n m i j))]\n                (if (= \\# v)\n                  (cond\n                    (< n 2) \\space\n                    (> n 3) \\space\n                    :else v)\n                  (if (= n 3) \\# v))))\n            row))) m)))","user":"4fb1d7ace4b081705acca281"},{"problem":94,"code":"(fn [b]\n  (letfn [(cell\n            [b r c]\n            (when (and (>= r 0) (>= c 0)\n                       (< r (count b)) (< c (count (first b))))\n              (-> b\n                  (nth ,,, r)\n                  (nth ,,, c))))\n\n          (nb\n            [b r c]\n            (reduce (fn [acc [rr cc]]\n                      (if-let [val (cell b (+ r rr) (+ c cc))]\n                        (conj acc val)\n                        acc))\n                    []\n                    (for [x [-1 0 1] y [-1 0 1] :when (not (and (zero? x) (zero? y)))] [x y])))]\n    (->> (for [r (range (count b))\n               c (range (count (first b)) )]\n           [r c])\n         (map (fn [[r c]] [(cell b r c) (frequencies (nb b r c))]) ,,,)\n         (map (fn [[val cnt]]\n                (condp = val\n                  \\space (if (#{3}   (get cnt \\#)) \\# \\space)\n                  \\#     (if (#{2 3} (get cnt \\#)) \\# \\space))) ,,,)\n         (partition (count (first b)) ,,,)\n         (map (fn [cs] (apply str cs)) ,,,))))","user":"4ee528fb535d1385b2869d87"},{"problem":94,"code":"(fn nextStep [maze]\n  (letfn [(neighbours                                                                                                               \n            ([maze yx] (neighbours [[-1 -1] [-1 0] [-1 1]\n                                    [ 0 -1]        [ 0 1]\n                                    [ 1 -1] [ 1 0] [ 1 1]]\n                                   maze\n                                   yx))\n            ([deltas maze yx]\n             (filter (fn [new-yx]\n                       (every? #(< -1 % (count maze)) new-yx))\n                     (map #(vec (map + yx %))\n                          deltas))))\n          (updateCell [x y maze]\n            (let [neighs (neighbours maze [x y])\n                  isLive (= (get-in maze [x y]) \\#)\n                  liveNeighs (count (filter (fn [[nx ny]] (= (get-in maze [nx ny]) \\#)) neighs))]\n              (cond\n                (and isLive (< liveNeighs 2)) \\space\n                (and isLive (<= 2 liveNeighs 3)) \\#\n                (and isLive (> liveNeighs 4)) \\space\n                (and (not isLive) (= liveNeighs 3)) \\#\n                :else \\space)))]\n    (for [x (range (count maze))]\n      (clojure.string/join\n       (for [y (range (count maze))]\n         (updateCell x y maze))))))","user":"54f64e99e4b0f2f3c5226ea4"},{"problem":94,"code":"(fn gol [board]\n  (letfn [(neighbors [board row col]\n            (count (filter #(= % \\#) (mapcat #(get (vec (partition 3 1 (extract-padded-row board %))) col) (map #(+ row %) [-1 0 1])))))\n          (extract-padded-row [board row]\n            (if (and (>= row 0) (< row (count board)))\n              (concat [\\space] (nth board row) [\\space])\n              []))]\n    (map #(apply str %)\n         (map-indexed\n          (fn [r row]\n            (map-indexed\n             (fn [c cell]\n               (let [live-neighs (neighbors board r c)]\n                 (if (= cell \\space)\n                   ;; Dead cell\n                   (if (= live-neighs 3)\n                     \\#\n                     \\space)\n                   ;; Live cell (includes itself\n                   (if (or (< live-neighs 3)\n                           (> live-neighs 4 ))\n                     \\space\n                     \\#))))\n             row)) board))))","user":"532b43c3e4b09d4e7a9b5531"},{"problem":94,"code":"(fn [cells]\n  \n  (let\n    [xc (count (first cells)) ;; x count\n     yc (count cells) ;; y count\n     addrs (for [x (range xc) y (range yc) ] [x y])\n     live (set (filter #(= \\# (get-in cells %)) addrs ))\n     neighbours (mapcat \n                 (fn [[x y]] (for [nx [-1 0 1] ny [-1 0 1] :when (not= [nx ny] [0 0]) ] \n                               [(+ x nx) (+ y ny)]) ) live )\n     \n     n-count (reduce #(update-in %1 %2 (fnil (partial + 1) 0) ) {} neighbours )\n     \n     alive (for [x (range xc) y (range yc) ]  \n             \n             (let [n (get-in n-count [x y] 0) ]\n               (cond (and (contains? live [x y]) (<= 2 n 3)) \\#\n                     (= n 3) \\#\n                     :else \\space\n                     )))\n     \n     formatted (map (partial apply str) (partition xc alive))\n     \n     ]\n    formatted\n    ))","user":"533a2f7be4b0e30313ee6cb8"},{"code":"(fn game-of-life [ss]\n  (let [lenlen (count ss)]\n    (letfn [(ss->vs [sss]\n              (flatten (map vec sss)))\n            (vs->ss [vs]\n              (map #(apply str %) (partition lenlen vs)))\n            (neighbour-idx-n []\n              (map (fn [x] (if (= 6 lenlen)\n                             (remove #(or (neg? %) (> % 35))\n                                     [(- x 7)\n                                      (- x 6)\n                                      (if (= 5 (rem x 6)) -1 (- x 5))\n                                      (- x 1)\n                                      (+ x 1)\n                                      (if (zero? (rem x 6)) -1 (+ x 5))\n                                      (+ x 6)\n                                      (+ x 7)])\n                             (remove #(or (neg? %) (> % 24))\n                                     [(- x 6)\n                                      (- x 5)\n                                      (if (= 4 (rem x 5)) -1 (- x 4))\n                                      (- x 1)\n                                      (+ x 1)\n                                      (if (zero? (rem x 5)) -1 (+ x 4))\n                                      (+ x 5)\n                                      (+ x 6)])))\n                   (range (* lenlen lenlen))))\n            (neighbour-elt-n []\n              (map (fn [neighbour-idx]\n                     (map #(nth (ss->vs ss) %) neighbour-idx))\n                   (neighbour-idx-n)))]\n      (vs->ss (map #(let [nb-elt-n (neighbour-elt-n)\n                          elt (nth (ss->vs ss) %)\n                          live-nbs (remove #{\\space} (nth nb-elt-n %))\n                          live-len (count live-nbs)]\n                      ;;                    live-len)\n                      (if (= elt \\#)\n                        (if (<= 2 live-len 3)\n                          \\#\n                          \\space)\n                        (if (= live-len 3)\n                          \\#\n                          \\space)))\n                   (range (* lenlen lenlen)))))))","problem":94,"user":"4eec82fe535d93acb0a668ae"},{"problem":94,"code":"(fn next-generation [board]\n  (let [neighbours-positions\n        (for [x (range -1 2) y (range -1 2) :when (or (not= x 0) (not= y 0))] [x y])\n\n        cols (count (first board))\n        rows (count board)\n\n        generation\n        (for [x (range cols) \n              y (range rows)\n              :let [cell (get-in board [x y])\n                    dead-cell? (= cell \\space)\n                    neighbours (map #(get-in board [(+ x (first %)) (+ y (second %))] \\space) neighbours-positions)\n                    live-neighbours-count (count (filter #(= \\# %) neighbours))]]\n          (if dead-cell? ; dead cell\n            (cond \n              (= 3 live-neighbours-count) \\# ; surrounded by exactly 3 live cells, so reproduction\n              :else \\space) ; cell stays dead :(\n            (cond \n              (< live-neighbours-count 2) \\space ; cell dies, under-population\n              (> live-neighbours-count 3) \\space ; cell dies, overcrowding\n              :else \\# ; survive till the next generation\n              )))]\n    (mapv #(apply str %) (partition cols generation))\n    )\n  )","user":"5244a10de4b0d8acf9ed6ab3"},{"code":"(fn next-state [world]\n  (let [dead \\space\n        alive \\#\n\n        rows (count world)\n        cols (count (first world))\n        all-positions  (for [x (range rows) y (range cols)] [x y])\n\n        neighbors\n        (fn [[x y]]\n          (filter (fn [[x y]] (and (>= x 0) (>= y 0) (< x rows) (< y rows)))\n                  [[(dec x) (dec y)] [(dec x) y] [(dec x) (inc y)]\n                   [x (dec y)] [x (inc y)]\n                   [(inc x) (dec y)] [(inc x) y] [(inc x) (inc y)]]))\n\n        get-cell\n        (fn [pos]\n          (get-in world pos))\n\n        living-cell?\n        (fn [cell] (= cell alive))\n\n        next-state-pos\n        (fn [pos]\n          (let [neighbor-cells (map #(get-in world %) (neighbors pos))\n                live-neighbors (count (filter living-cell? neighbor-cells))]\n\n            (if (living-cell? (get-cell pos))\n              (if (or (= live-neighbors 2) (= live-neighbors 3))\n                alive\n                dead)\n              (if (= live-neighbors 3)\n                alive\n                dead))))\n\n        hack-to-result (fn [cells] (into [] (map #(apply str %) (partition cols cells))))]\n\n    (hack-to-result\n     (map next-state-pos all-positions))))","problem":94,"user":"4f0d093b535d0136e6c22313"},{"problem":94,"code":"(fn [b]\n  (let [y (count b) x (count (first b)) board (map seq b)]\n    (map (fn [y1]\n           (apply str (map \n             (fn [x1]\n             (if (= (nth (nth board y1) x1) \\ )\n               (if (= 3 (count (filter #(= % \\#) (for [x2 (range (max 0 (dec x1)) (min x (+ x1 2))) y2 (range (max 0 (dec y1)) (min y (+ y1 2)))] (nth (nth board y2) x2)))))\n                 \"#\"\n                 \" \")\n                 (if (contains? #{3 4} (count (filter #(= % \\#) (for [x2 (range (max 0 (dec x1)) (min x (+ x1 2))) y2 (range (max 0 (dec y1)) (min y (+ y1 2)))] (nth (nth board y2) x2)))))\n                 \"#\"\n                 \" \")))\n             (range x))))         \n         (range y))))","user":"55625903e4b0c656e3ff17d7"},{"problem":94,"code":"(fn next-gen [generation]\n  (letfn [ (index-neighbours [index max-index]\n                             (cond\n                               (= index 0) [index (inc index)]\n                               (= max-index index) [(dec index) index]\n                               :else [(dec index) index (inc index)]))\n           (cell-neighbours [row column max-row max-column]\n                            (let [neightbour-rows (index-neighbours row max-row)\n                                  neightbour-cols (index-neighbours column max-column)]\n                              (for [r neightbour-rows c neightbour-cols :when (not(and (= r row) (= c column)))]\n                                [r c])))\n\n           (get-cell [generation row column]\n                     (= \\# (.charAt (generation row) column)))\n\n           (count-live-neighbours [generation row column max-row max-column]\n                                  (let [neighbours (cell-neighbours row column max-row max-column)\n                                        neighbours-values (map (fn [[row column]] (get-cell generation row column)) neighbours)]\n                                    (count (filter identity neighbours-values))))\n           (cell-next-gen [cell live-neghbours-count]\n                          (if cell\n                            (cond\n                              (> live-neghbours-count 3) false\n                              (< live-neghbours-count 2)false\n                              :else true\n                              )\n                            (if (= live-neghbours-count 3)\n                              true\n                              false)))\n           ]\n\n    (let [row-count (count generation)\n          max-row (dec row-count)\n          column-count (count (first generation))\n          max-column (dec column-count)\n          ]\n      (into\n        []\n        (map\n          #(apply str %)\n          (partition column-count\n                     (map\n                       #(if % \\# \\space)\n                       (for [row (range 0 row-count) column (range 0 column-count)]\n                         (cell-next-gen\n                           (get-cell generation row column)\n                           (count-live-neighbours generation row column (dec row-count) (dec column-count)))))))))))","user":"5654e024e4b0f9d632dd848d"},{"problem":94,"code":"#(letfn [\n        (line-degree[n s]\n        \"return the number of live neighbours within the line\"\n          (count\n            (filter (fn[x](= x \\#))\n              (if (empty? s) [] (take (if (= n 0) 2 3) (drop (dec n) s))))))\n\n        (matrix-degree[n s1 s2 s3]\n        \"return the number of live neighbours\"\n          (+ (line-degree n s1) (- (line-degree n s2)(if (= (nth s2 n) \\#) 1 0)) (line-degree n s3)))\n\n        (next-gen-char[n s1 s2 s3]\n          (let [deg (matrix-degree n s1 s2 s3)]\n            (if (< deg 2)\n              \\space\n              (if (= deg 2)\n                (nth s2 n)\n                (if (= deg 3)\n                  \\#\n                  \\space)))))\n       ]\n    \n  (loop [s1 [] s2 % s3 (next s2)  ret []]\n    (if (empty? s2)\n      ret\n      (recur s2 s3 (next s3)\n             (conj ret (apply str (for [n (range (count (first s2)))] (next-gen-char n (first s1) (first s2) (first s3)))))))))","user":"545537c1e4b0e397800069dd"},{"problem":94,"code":"(fn [b]\n  (letfn [\n          (valid-cell? [x y board]\n            (and (>= x 0)\n                 (>= y 0)\n                 (< y (count board))\n                 (< x (count (board y)))))\n\n          (neighbor-coords [x y board]\n            (filter #(valid-cell? (% 0) (% 1)  board)\n                    [[x (inc y)]\n                     [x (dec y)]\n                     [(inc x) y]\n                     [(dec x) y]\n                     [(dec x) (dec y)]\n                     [(dec x) (inc y)]\n                     [(inc x) (inc y)]\n                     [(inc x) (dec y)]]))\n\n          (cell [x y board]\n            ((board y) x))\n\n          (neighbor-count [x y board]\n            (count (filter #(= \\# %)\n                           (map #(cell (% 0) (% 1) board)\n                                (neighbor-coords x y board)))))\n\n          (next-gen-cell [x y board]\n            (let [c (cell x y board)\n                  n (neighbor-count x y board)]\n              (if (= \\# c) ; live cell\n                (cond (< n 2) \\space\n                      (> n 3) \\space\n                      :else \\#)\n                (if (= n 3) \\# \\space))))  ; dead cell\n          \n          (next-gen [board]\n            (let [b (into [] (map #(into [] (seq %)) board))\n                  width (count (first b))\n                  height (count b)]\n              (loop [x 0, y 0, acc b]\n                (cond (>= y height) (map #(reduce str %) acc)\n                      (>= x width) (recur 0 (inc y) acc)\n                      :else (recur (inc x) y\n                                   (assoc acc y (assoc (acc y) x\n                                                       (next-gen-cell x y b))))))))]\n    (next-gen b)))","user":"538e36c7e4b0b51d73faae81"},{"code":"(fn [board] (let [\r\n  [D L] [\\space \\#]\r\n  binb  (map (partial map #({D 0 L 1} %)) board)\r\n  [w h] [(count (first board)) (count board)]\r\n  rn    #(map (partial + %) [-1 0 1])\r\n  in?   (fn [i j] (and (>= i 0) (< i w) (>= j 0) (< j h)))\r\n  ncnt  (map-indexed (fn [j r]\r\n          (map-indexed (fn [i c] (reduce +\r\n            (for [x (rn i) y (rn j)\r\n              :when (and (in? x y) (not= [x y] [i j]))]\r\n              (nth (nth binb y) x))))\r\n            r))\r\n          binb)]\r\n  (map #(apply str\r\n    (map (fn [c nl]\r\n      (let [l (= c 1) d (not l)]\r\n        (cond\r\n          (and l (< nl 2)) D\r\n          (and l (> nl 3)) D\r\n          (and d (= nl 3)) L\r\n          :else ({0 D 1 L} c)))) %1 %2))\r\n    binb ncnt)))","problem":94,"user":"50336c6be4b0c6c1199c710f"},{"code":"(fn q94 [board] ;similar q117\n  (let [rows (count board)\n        cols (count (first board))\n        dirs [[-1 -1] [-1 0] [-1 1] [0 -1] [0 1] [1 -1] [1 0] [1 1]]\n        live-neighbours (fn [pos]\n          (->>\n            (map #(map + pos %) dirs)\n            (filter (fn [[r c]] (and (< -1 r rows) (< -1 c cols))))\n            (filter #(= \\# (get-in board %)))\n            count))]\n    (->>\n      (for [r (range rows) c (range cols)\n            :let [ls (live-neighbours [r c])\n                  cell-live? (= \\# (get-in board [r c]))\n                  next-gen (if cell-live?\n                             (if (or (= 2 ls) (= 3 ls)) \\# \\space)\n                             (if (= 3 ls) \\# \\space))]]\n            next-gen)\n      (partition cols)\n      (map #(apply str %)))))","problem":94,"user":"4fd22e70e4b04c3a95aa041c"},{"code":"(fn [board]\n  (let [dead \\space\n        live \\#\n        height (count board)\n        width (count (first board))\n        possible-coords (fn [x y]\n                          (let [xs [(dec x) x (inc x)]\n                                ys [(dec y) y (inc y)]]\n                            (mapcat (fn [a] (map #(vec [a %]) ys)) xs)))\n        inbounds? (fn [[x y]]\n                    (and (>= x 0) (< x width) (>= y 0) (< y height)))\n        neighbors (fn [x y]\n                    (filter inbounds? (possible-coords x y)))\n        live? (fn [coords]\n                (= (get-in board coords) live))\n        live-neighbors (fn [x y]\n                         (count (filter live? (neighbors x y))))\n        next-gen (fn [x y]\n                   (let [ln (live-neighbors x y)]\n                     (if (= x 2) (println [x y ln]))\n                     (if (live? [x y])\n                       (cond (< ln 3) dead\n                             (> ln 4) dead\n                             :else live)\n                       (if (= ln 3) live dead))))\n        xs (range 0 width)\n        ys (range 0 height)]\n    (map (fn [x]\n           (apply str (map (fn [y] (next-gen x y))\n                  ys)))\n           xs)))","problem":94,"user":"4f437751e4b0d7d3c9f3fd20"},{"code":"(fn [b]\n  (let [w (count b)\n        z (range w)\n        l [-1 0 1]\n        a apply\n        g get-in]\n    (map #(a str %)\n      (partition w\n        (for [x z y z\n              :let [n (a + (for [o l p l]\n                             (if (= (g b [(+ x o) (+ y p)]) \\#)\n                                 1\n                                 0)))]]\n          (if (= (g b [x y]) \\#)\n              (if (<= 3 n 4) \\# \" \")\n              (if (= n 3) \\# \" \")))))))","problem":94,"user":"4f9597e0e4b0dcca54ed6cd4"},{"problem":94,"code":"(fn [game-map]\n  (map #(apply str %)\n  (letfn [\n          (get-at [game-map [y x]]\n            (nth (nth game-map y) x)) \n          (map-size [game-map] \n            (vector (count game-map) (count (first game-map))))  \n          (neighbours [[row column]]\n            [\n             [(dec row) column]\n             [row (inc column)]\n             [(dec row) (inc column)]\n             [(inc row) (inc column)]\n             [(inc row) column]\n             [(inc row) (dec column)]\n             [row (dec column)]\n             [(dec row) (dec column)]\n\n             ]) \n          (within-map? [[rows columns :as map-size] [row column :as coord]]\n            (and \n              (and (<= 0 column) (< column columns))\n              (and  (<= 0 row) (< row rows))))\n          ]\n    (let [[rows columns :as map-size] (map-size game-map)]\n      (map \n        (fn[row] \n          (map (fn [column]\n                 (let [curr-tile (get-at game-map [row column])]\n                   (case (count \n                           (filter (fn [tile] (= tile \\#))\n                                   (map (fn [valid-position] \n                                          (get-at game-map valid-position)) \n                                        (filter #(within-map? map-size %) \n                                                (neighbours [row column])))))\n                     0 \\ \n                     1 \\  \n                     2 (if (= curr-tile \\#) \\# \\ )\n                     3 \\#\n                     (if (= curr-tile \\#) \\ \\ )\n\n                     ))) \n               (range columns))) \n        (range rows))))))","user":"50856bd1e4b004985b776e4c"},{"problem":94,"code":"(fn life [b]\n  (let [bp (mapv (fn [v] (vec (seq v))) b)\n        cell-indexes (vec (for [x (range 1 (- (count bp) 1))\n                           y (range 1 (- (count (first bp)) 1))]\n                       [x y]))\n\n        neighbor-fn (fn [c]\n                      (let [f (first c)\n                            s (second c)]\n                        (keep-indexed (fn [idx v] (when (not= idx 4) v)) (for [x (range (dec f) (+ 2 f))\n                                                                               y (range (dec s) (+ 2 s))]\n                                                                           [x y]))))\n        neighbor-indexes (mapv neighbor-fn cell-indexes)\n        neighbors  (mapv (fn [c] (map #(get-in bp %) c)) neighbor-indexes)\n        neighbor-filter-counts (mapv (fn [cell n] [cell (count (filter #(= \\# %) n))]) cell-indexes neighbors)\n        new-vals (reduce\n          (fn [acc fc] (let [current (get-in bp (first fc))\n                             newval (if (= current \\#)\n                                      (cond (< (second fc) 2) \\space\n                                            (< (second fc) 4) \\#\n                                            :othersise  \\space)\n                                       (if (= (second fc) 3) \\# \\space))]\n                         (update-in acc (first fc) (fn [_] newval))))\n          bp neighbor-filter-counts)]\n    (mapv (fn [v] (apply str v)) new-vals)\n    )\n  )","user":"5592bf9fe4b0c79f6e1db933"},{"code":"(fn gol [s]\t\n\t(letfn [(neighbors [x y]\n\t\t\t\t\t(let [\tx1 (if (< (- x 1) 0) 0 (- x 1))\n\t\t\t\t\t\ty1 (if (< (- y 1) 0) 0 (- y 1))\n\t\t\t\t\t\tx2 (if (> (+ x 1) (dec (count s))) (dec (count s)) (+ x 1))\n\t\t\t\t\t\ty2 (if (> (+ y 1) (dec (count s))) (dec (count s)) (+ y 1))]\n\t\t\t\t\t(for [a (range x1 (inc x2))]\n\t\t\t\t\t\t(for [o (range y1 (inc y2))]\n\t\t\t\t\t\t\t(if (and (= a x) (= o y))\n\t\t\t\t\t\t\t\t(if (= (nth (nth s a) o) \\#) \\l \\d)\n\t\t\t\t\t\t\t\t(nth (nth s a) o))))))\n\t\t  (fs [x y]\n\t\t\t\t(let [n (frequencies (flatten (neighbors x y)))]\t\t\n\t\t\t\t\t\t\t(if (= (n \\l) 1)\n\t\t\t\t\t\t\t\t(cond\n                                 (nil? (n \\#)) \\space\n\t\t\t\t\t\t\t\t (< (n \\#) 2) \\space\n\t\t\t\t\t\t\t\t (or (= (n \\#) 2) (= (n \\#) 3)) \\#\n\t\t\t\t\t\t\t\t (> (n \\#) 3) \\space)\n\t\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t\t (if (= (n \\#) 3)\n\t\t\t\t\t\t\t\t\t\\#\n\t\t\t\t\t\t\t\t\t\\space))))]\n\t\t\t\t\n\t\t(map #(apply str %) (for [x (range (count s))]\n\t\t\t(for [y (range (count s))]\n\t\t\t\t(fs x y))))))","problem":94,"user":"51c09719e4b0c9c82288293c"},{"code":"(letfn [(nbrs [b [y x]]\n          (remove nil? [(get-in b [(dec y) (dec x)])\n                        (get-in b [y (dec x)])\n                        (get-in b [(inc y) (dec x)])\n                        (get-in b [(dec y) x])\n                        (get-in b [(inc y) x])\n                        (get-in b [(dec y) (inc x)])\n                        (get-in b [y (inc x)])\n                        (get-in b [(inc y) (inc x)])]))\n        (live? [b i]\n          (= (get-in b i) \\#))\n        (live-nbrs [b i]\n          (count (filter #(= \\# %) (nbrs b i))))]\n  (fn [b]\n    (vec (for [y (range 0 (count b))]\n           (clojure.string/join \n            (for [x (range 0 (count (first b)))]\n              (let [live (live-nbrs b [y x])]\n                (if (live? b [y x])\n                  (cond (< live 2) \\ \n                        (> live 3) \\ \n                        :else \\#)\n                  (if (= live 3) \\# \\ )))))))))","problem":94,"user":"5294e44de4b02ebb4ef75016"},{"code":"#(for [x (range 0 (count %))]\n  (apply str \n     (for [y (range 0 (count (first %)))\n        :let [alive (= \\# (get-in % [x y]))\n              neighbours (count (for [dx [-1 0 1], dy [-1 0 1] \n                                     :let [x (+ x dx) y (+ y dy)]\n                                     :when (and (not= 0 dx dy) \n                                                (every? #{0 1 2 3 4 5} [x y]) \n                                                (#{\\#} (get-in % [x y])))] \n                                  1))]]\n    (if alive \n        (cond (< neighbours 2) \\space \n              (#{2 3} neighbours) \\#\n              :else \\space)\n        (if (= 3 neighbours) \n            \\#\n            \\space)))))","problem":94,"user":"4e9660ec535dbda64a6f6b44"},{"code":"#(let [r (range (count %))\r\n       v [-1 0 1]\r\n       a \\#]\r\n   (for [y r]\r\n     (apply str (for [x r c [(count\r\n                              (for [j v\r\n                                    k v\r\n                                    :when (= a (get-in % [(+ y j) (+ x k)]))]\r\n                                1))]]\r\n                  (if (or (= c 3) (and (= c 4) (= a (get-in % [y x]))))\r\n                    a\r\n                    \\ )))))","problem":94,"user":"4db858d1535d1e037afb218c"},{"code":"(fn [b]\n  (letfn [(g [x y] (nth (nth b y \"\") x \\ ))]\n    (for [y (range (count b))]\n      (apply str\n             (for [x (range (count (first b)))]\n               (let [x- (dec x) x+ (inc x)\n                     y- (dec y) y+ (inc y)\n                     n (count ((group-by identity\n                                         [(g x- y-) (g x y-) (g x+ y-)\n                                          (g x- y)           (g x+ y)\n                                          (g x- y+) (g x y+) (g x+ y+)]) \\#))]\n                 (if (= \\  (g x y))\n                   (if (= 3 n) \\# \\ )\n                   (if (or (< n 2) (< 3 n)) \\  \\#))))))))","problem":94,"user":"53460d02e4b084c2834f4a39"},{"problem":94,"code":"(fn [board]\n  (map-indexed \n   (fn [y r]\n     (apply str \n            (map-indexed \n             (fn [x c]\n               (if (({\\# #{2 3} \\  #{3}} c) \n                    (apply + (map-indexed #({\\# 1 \\  0} \n                                                (get-in board (map + [y x] %2) \\ )) \n                                          [[-1 -1] [-1 0] [-1 1] [0 -1] [0 1] [1 -1] [1 0] [1 1]])))\n                 \\#\n                 \\ ))\n             r)))\n       board))","user":"52b02329e4b0c58976d9acc5"},{"problem":94,"code":"(fn life[board]\n  (let [size (count board)]\n  (letfn [\n          (char-at [board [x y]] (nth (seq (board y)) x))\n          (next-state [live-neighbours c]\n                      (cond\n                        (and (= c \\#) (= live-neighbours 2)) \\#\n                        (= live-neighbours 3) \\#\n                        true \\space ))\n          (neighbours [pos]\n                      (let [\n                            dirs [[-1 -1] [-1 0] [-1 1] [1 -1] [1 0] [1 1] [0 -1] [0 1]]\n                            add-points (fn [& pts] (vec (apply map + pts)))\n                            on-board? (fn [[x y]] (and (>= x 0) (>= y 0) (< x size) (< y size)))\n                            ]\n                        (count\n                          (filter (partial = \\#)\n                                  (map\n                                    (fn[np] (char-at board np))\n                                    (filter on-board? (map #(add-points pos %) dirs)))))\n                        )\n                      )\n          ]\n    (vec (map #(apply str %) (partition size (for [y (range size) x (range size)]\n                                            (next-state (neighbours [x y]) (char-at board [x y]))\n                                            ))))\n    ))\n  )","user":"55f2c898e4b06e875b46ce4b"},{"problem":94,"code":"(fn [board]\n  (let [board (vec (map vec board))\n        [h w] (map count ((juxt identity first) board))\n        cell (fn [y x]\n               (get-in board (map mod [y x] [h w])))\n        alive? (comp #{\\#} cell)\n        neighbors (let [offsets [-1 0 1]\n                        deltas (for [y offsets, x offsets\n                                     :when (not= y x 0)]\n                                 [y x])]\n                    (fn [y x]\n                      (count\n                       (for [[dy dx] deltas\n                             :when (alive? (+ y dy) (+ x dx))]\n                         true))))\n        new-state (fn [y x]\n                    (let [nbr-count (neighbors y x)]\n                      (if (or (= 3 nbr-count)\n                              (and (= 2 nbr-count)\n                                   (alive? y x)))\n                        \\#\n                        \\space)))]\n    (for [y (range h)]\n      (apply str (for [x (range w)]\n                   (new-state y x))))))\n;;mark pass","user":"55a0d79fe4b0acc240e31502"},{"code":"(fn [board]\r\n  (let [offsets [[-1 -1] [-1 0] [-1 1]\r\n                 [0 -1] [0 1]\r\n                 [1 -1] [1 0] [1 1]]\r\n        height (count board)\r\n        width (count (first board))\r\n        get-state (fn [[x y] [dx dy]]\r\n                    (let [c (+ x dx) r (+ y dy)] \r\n                      (if (or (< c 0) (= c width) (< r 0) (= r height))\r\n                        \\space\r\n                        (get-in board [r c]))))\r\n        count-lives (fn [p]\r\n                      (reduce + (map #(if (= \\# (get-state p %)) 1 0) offsets)))\r\n        next-state (fn [s p]\r\n                     (let [n (count-lives p)] \r\n                       (if (or (= n 3)\r\n                               (and (= s \\#) (= n 2)))\r\n                         \\#\r\n                         \\space)))] \r\n    (->> (for [y (range height) x (range width)]\r\n           (next-state (get-in board [y x]) [x y]))\r\n      (partition width)\r\n      (map #(apply str %))\r\n      vec)))","problem":94,"user":"4e1158aa535d04ed9115e7c6"},{"code":"(fn [a]\n  (letfn [(alive [a r c]\n            (and (>= r 0) (< r (count a)) (>= c 0)\n                 (< c (count (a r))) (= (nth (a r) c) \\#)))\n          (to-r [x] (range (dec x) (+ x 2)))\n          (neighbors [a r c]\n            (apply + (for [rp (to-r r) cp (to-r c)]\n                       (if (and (or (not= r rp) (not= c cp))\n                                (alive a rp cp))\n                         1 0))))\n          (to-c [r c v]\n            (let [n (neighbors a r c)]\n              (cond (or (< n 2) (> n 3)) \\space\n                    (= n 2) v\n                    :else \\#)))\n          (cf [ri rv] (map-indexed #(to-c ri %1 %2) rv))]\n    (map #(apply str %1) (map-indexed cf a))))","problem":94,"user":"504e04a4e4b078edc5f59397"},{"problem":94,"code":"(fn conway [board]\n  (let [cells (set (for [y (range (count board))\n                         x (range (count (get board y)))\n                         :when (not= \\space (get-in board [y x]))]\n                     [x y]))\n        width (count (first board))\n        height (count board)\n        neighbors (fn [[x y]]\n                    (for [dx [-1 0 1] dy (if (zero? dx) [-1 1] [-1 0 1])]\n                      [(+ x dx) (+ y dy)]))\n        step (fn [cells]\n               (set (for [[loc n] (frequencies (mapcat neighbors cells))\n                          :when (or (= n 3) (and (= n 2) (cells loc)))]\n                      loc)))\n        serialize (fn [alive]\n                    (mapv #(apply str %)\n                          (partition width\n                                     (for [y (range height) x (range width)\n                                           :let [sym (if (alive [x y]) \\# \\space)]]\n                                       sym))))]\n    (-> cells step serialize)))","user":"5bbdd136e4b07a9b28b0ffab"},{"code":"(fn lifeStep [board]\n  (letfn [(computeCharLoc [[t num]]\n\t\t\t\t(cond (and (= t \\#) (= num 2)) \\#\n\t\t\t\t\t  (= num 3) \\#\n\t\t\t\t\t  :else \\space\n\t\t\t\t)\n\t\t\t)\n      (getLocSum [x y]\n\t\t\t(computeCharLoc [(get-in board [x y])\n\t\t\t(apply + (map #(if (= \\# (get-in board %)) 1 0)\n\t\t\t   [\n\t\t\t\t[(- x 1) (- y 1)]\n\t\t\t\t[(- x 1) y]\n\t\t\t\t[(- x 1) (+ y 1)]\n\t\t\t\t[x (- y 1)]\n\t\t\t\t[x (+ y 1)]\n\t\t\t\t[(+ x 1) (- y 1)]\n\t\t\t\t[(+ x 1) y]\n\t\t\t\t[(+ x 1) (+ y 1)]\n\t\t\t   ])\n\t\t\t)])\n\t\t\t)\n\t] \n\t\n\t(let [size (count board)]\n   (for [x (range size)] (apply str (for [y (range size)] (getLocSum x y))))\n\t)\n\t)\n)","problem":94,"user":"50588af1e4b06522596eba7d"},{"problem":94,"code":"(fn [input]\n  (let [rotb (fn [coll]\n               (->>\n                (concat coll coll)\n                (drop 1)\n                (take (count coll))))\n        rotf (fn [coll]\n               (->>\n                (concat coll coll)\n                (drop (dec (count coll)))\n                (take (count coll))))\n        add-mat (fn [& m] (apply (partial map (fn [& r] (apply (partial map +) r))) m))\n        propagate (fn [cell n-neighbours]\n                    (if (= cell 1)\n                      (if (or (= n-neighbours 2) (= n-neighbours 3)) 1 0)\n                      (if (= n-neighbours 3) 1 0)))\n        print-row (fn [row] (->>\n                             (map #(if (= 1 %) \\# \\ ) row)\n                             (apply str)))\n        board (map (fn [row] (map #(if (= \\# %) 1 0) row)) input)\n        up (rotb board)\n        down (rotf board)\n        left (map rotb board)\n        right (map rotf board)\n        up-left (rotb left)\n        down-left (rotf left)\n        up-right (rotb right)\n        down-right (rotf right)\n        neighbours (add-mat up down left right up-left down-left up-right down-right)]\n    (->>\n     (map (fn [b-row n-row] (map propagate b-row n-row)) board neighbours)\n     (map print-row))))","user":"5471f2fbe4b094393f72dd70"},{"code":"(fn board-next [board]\n  (let [neibors-pos [[1 0] [1 1] [0 1] [-1 1] [-1 0] [-1 -1] [0 -1] [1 -1]]\n        t {\\# 1 \\space 0}\n        c (count board)]\n    (letfn [(pos-add [[xa ya] [xb yb]]\n              [(+ xa xb) (+ ya yb)])\n            (ceil [[x y]]\n              (if (and (< -1 x c) (< -1 y c))\n                (nth (nth board x) y) \\space))\n            (neibors-num [[x y :as pos]]\n              (map (fn [pos] (t (ceil pos)))\n                   (map (fn [e] (pos-add pos e)) neibors-pos)))\n            (ceil-next [ceil n]\n              (if (= ceil \\#)\n                (cond\n                 (< -1 n 2) \\space\n                 (<= 2 n 3) \\#\n                 (< 3 n) \\space)\n                (if (= n 3) \\# \\space)))]\n      (let [poses (for [x (range c) y (range c)] [x y])\n            next (map (fn [pos] (ceil-next\n                                (ceil pos)\n                                (apply + (neibors-num pos)))) poses)]\n        (map #(apply str %) (partition c c next))))))","problem":94,"user":"52f8f4d1e4b047fd55836fde"},{"problem":94,"code":"(fn [rows]\n  (map-indexed\n    (fn [y row]\n      (apply str\n        (map-indexed\n          (fn [x chr]\n            (let [\n              neighbors {\n                :nw (get (get rows (dec y)) (dec x))\n                :n  (get (get rows (dec y)) x)\n                :ne (get (get rows (dec y)) (inc x))\n                :e  (get row (inc x))\n                :se (get (get rows (inc y)) (inc x))\n                :s  (get (get rows (inc y)) x)\n                :sw (get (get rows (inc y)) (dec x))\n                :w  (get row (dec x))}\n              living (count (filter (fn [[_ v]] (= v (get \"#\" 0))) neighbors))\n              live?  (= chr (get \"#\" 0))\n              dead?  (not live?)]\n              (cond\n                (and live? (< living 2)) \" \"\n                (and live? (> living 3)) \" \"\n                (and dead? (= living 3)) \"#\"\n                (and live? (or (= 2 living) (= 3 living))) \"#\"\n                :else \" \")))\n            row)))\n    rows))","user":"55fee5e4e4b00f4cabc5765a"},{"problem":94,"code":"(fn gol\n  [board]\n  (mapv\n   #(str (apply str \" \" %) \" \")\n   (concat\n    [(repeat (- (count (peek board)) 2) \\space)]\n    (map\n     (fn [expanded-row]\n       (apply\n        (fn [top mid bot]\n          (map\n           (fn [[tl tc tr] [l x r] [bl bc br]]\n             (let [live-neighbours\n                   (count\n                    (filter\n                     #(= \\# %)\n                     [tl tc tr l r bl bc br]))\n                   live? (= \\# x)]\n               (cond\n                 (and live? (< live-neighbours 2)) \\space\n                 (and live? (some #{live-neighbours} #{2 3})) \\#\n                 (and live? (> live-neighbours 3)) \\space\n                 (and (not live?) (= live-neighbours 3)) \\#\n                 :else \\space))\n             ) top mid bot))\n        \n        (map (partial partition 3 1)\n             expanded-row)))\n     (partition 3 1 board))\n    [(repeat (- (count (peek board)) 2) \\space)])))","user":"5bf9d9b7e4b0bdcf453d15c4"},{"problem":94,"code":"(fn [b]\n   (let [n (count (first b))]\n     (->> (for [i (range n)\n                k (range n)\n                :let [c (->> [[-1 -1] [-1 0] [-1 1] [0 -1] [0 1] [1 -1] [1 0] [1 1]]\n                             (map (fn [[y x]] [(+ y i) (+ x k)]))\n                             (map (fn [[y x]] (nth (nth b y nil) x nil)))\n                             (filter #(= \\# %))\n                             count)]]\n            (cond (< c 2) \\space\n                  (= c 2) (nth (nth b i) k)\n                  (= c 3) \\#\n                  :else \\space))\n          (partition n)\n          (map #(apply str %)))))","user":"50ae0d24e4b0a40c9cfb08ce"},{"problem":94,"code":"(fn [bd]\n  (let [dead? #(= \\  %)\n        live? #(= \\# %)\n        getXY (fn [x y]\n                (nth (nth bd y) x))\n        xLen (count (first bd))\n        yLen (count bd)\n        neighbours [[0 1] [0 -1] [1 0] [-1 0]\n                    [-1 -1] [-1 1] [1 -1] [1 1]]\n        clamp (fn [[x y]]\n                (if (and (> x 0)\n                         (> y 0)\n                         (< x xLen)\n                         (< y yLen))\n                  (vector x y)))]\n    (for [y (range yLen)]\n      (apply str\n      (for [x (range xLen)]\n      (let [numLiveNeighbours (count\n                               (filter (fn [[x y]] (live? (getXY x y)))\n                                       (keep clamp\n                                   \t\t\t(map (fn [[a b]] (vector (+ x a) (+ y b))) neighbours))))]\n        (if (live? (getXY x y))\n          (if (and (>= numLiveNeighbours 2)\n                   (<= numLiveNeighbours 3))\n            \\# \n            \\ )\n          (if (= numLiveNeighbours 3)\n            \\#\n            \\ ))))))))","user":"541ef7e2e4b01498b1a71a92"},{"problem":94,"code":"(fn next-gen [board]\n  (letfn [(neighbours [i j]\n            (for [x [(dec i) i (inc i)]\n                  y [(dec j) j (inc j)]\n                  :when (and (>= (dec (count board)) x 0)\n                             (>= (dec (count (first board))) y 0)\n                             (not (and (= x i) (= y j))))]\n              [x y]))\n          (live-neighours [i j]\n            (filter (fn [[x y]] (= \\# (get-in board [x y]))) (neighbours i j)))]\n    (vec\n     (for [x (range (count board))]\n       (reduce\n        str\n        (for [y (range (count (first board)))\n              :let [n (count (live-neighours x y))]]\n          (cond\n            (= n 3) \\#\n            (= n 2) (get-in board [x y])\n            :die \\space)))))))","user":"51852961e4b0da5a5be3babb"},{"code":"(fn [board]\n  (letfn [ (remap [board]\n    (->> (for [v board] \n           (->> (map (fn [c] (if (= (str c) \" \") 0 1)) v)\n                (apply vector)))\n          (apply vector)))\n(unmap [matrix]\n    (->> (for [v matrix] \n           (->> (map (fn [b] (if (zero? b) \" \" \"#\")) v)\n                (apply str)))\n          (apply vector)))\n(cneigh [matrix x y]\n   (let [n (count matrix)\n         left (mod (dec x) n)\n         right (mod (inc x) n)\n         up   (mod (dec y) n)\n         down (mod (inc y) n)]\n     (->>\n         (for [[a b] [[left up] [x up]  [right up]\n                     [left y]           [right y]\n                     [left down][x down][right down]]]\n               ((matrix a)b))\n               (reduce +)))) \n(nextgen [matrix]\n  (let [n (count matrix)]\n    (->>\n      (for [x (range n)] \n  \t(->>\n           (for [y (range n)]\n              (let [neighbors (cneigh matrix x y)]\n                 (if (zero? ((matrix x)y))\n\t\t\t\t    (if (= neighbors 3) 1 0)\n                    (cond\n                         (or (= neighbors 2) (= neighbors 3)) 1\n                         :else 0))))\n \t\t\t(apply vector)))\n\t  (apply vector))))]\n   (->> board (remap) (nextgen) (unmap))))","problem":94,"user":"4e6e3a1e535d5021c1a89602"},{"problem":94,"code":"(fn [board]\n    (let [alive \\#\n          dead \\space\n          directions\n          {:NW [-1 1]\n           :N  [0 1]\n           :NE [1 1]\n           :E  [1 0]\n           :SE [1 -1]\n           :S  [0 -1]\n           :SW [-1 -1]\n           :W  [-1 0]}\n          cell-state (fn\n                       [board coords]\n                       (get-in board coords))\n          alive? (fn\n                   [board coords]\n                   (= alive (cell-state board coords)))\n          ;\n          ; 4Clojure throws up on some?\n          ;\n          neighbors (fn\n                      [board coords]\n                      (filter #(not (nil? (cell-state board %)))\n                              (map\n                                #(map + coords (second %))\n                                directions)))\n          count-live-neighbors (fn\n                                 [board coords]\n                                 (let [neighbors (neighbors board coords)]\n                                   (count (filter #(alive? board %) neighbors))))\n          next-cell-state (fn\n                            ;  1) Any live cell with fewer than two live neighbours dies, as if caused by under-population.\n                            ;  2) Any live cell with two or three live neighbours lives on to the next generation.\n                            ;  3) Any live cell with more than three live neighbours dies, as if by overcrowding.\n                            ;  4) Any dead cell with exactly three live neighbours becomes a live cell, as if by reproduction.\n                            [board coords]\n                            (let [num-live-neighbors (count-live-neighbors board coords)\n                                  next-state (cond\n                                               (< num-live-neighbors 2)\n                                               dead\n                                               (contains? #{2 3} num-live-neighbors)\n                                               (if (alive? board coords)\n                                                 alive\n                                                 (if (= 3 num-live-neighbors)\n                                                   alive\n                                                   dead))\n                                               (> num-live-neighbors 3)\n                                               dead)]\n                              next-state))\n          cell-updates (fn\n                         [board]\n                         (into {}\n                               (for [x (range (count (first board)))\n                                     y (range (count board))]\n                                 [[x y] (next-cell-state board [x y])])))\n          board-nextgen (fn\n                          [board]\n                          (let [vboard (mapv vec board)\n                                cell-updates (cell-updates board)\n                                raw-next-board (reduce\n                                                 (fn [current-board cell-update]\n                                                   (let [coords (first cell-update)\n                                                         state (second cell-update)]\n                                                     (assoc-in current-board coords state)))\n                                                 vboard\n                                                 cell-updates)]\n                            (mapv #(apply str %) raw-next-board)))]\n      (board-nextgen board)))","user":"594266cfe4b060784b3b790b"},{"code":"(fn [m]\n  (let [get   #(nth (nth %3 %1 nil) %2 \\space)\n        rg    #(range (dec %) (+ 2 %))\n        neigh #(for [x (rg %1) y (rg %2)\n                     :when (and (= \\# (get x y %3)) (or (not= x %1) (not= y %2)))]\n                 [x y]) \n        X     (count m)\n        Y     (count (first m))]\n    (map #(apply str %) (for [x (range X)]\n                          (for [y (range Y) :let [e (get x y m) c (count (neigh x y m))]]\n                            (if (= e \\#)\n\t\t\t      (cond \n\t\t\t        (< c 2) \\space\n\t\t\t        (> c 3) \\space\n\t\t\t\t:else \\#)\n\t\t\t      (if (= c 3) \\# \\space)))))))","problem":94,"user":"4f32a7f1e4b0d6649770a095"},{"code":"(fn game-of-life\r\n  [board]\r\n\t(let [max_row (dec (count board))\r\n\t\t\t\tmax_col (dec (count (first board)))]\r\n\t\t(letfn [(get-xy [x y] \r\n\t\t\t\t\t\t (if (or (or (< x 0) (< y 0)) \r\n\t\t\t\t\t\t\t\t\t\t (or (> x max_row) (> y max_col))) \r\n\t\t\t\t\t\t\t\t\t \" \" \r\n\t\t\t\t\t\t\t\t\t (nth (board x) y)))\r\n\r\n\t\t\t\t\t\t(count-neighbors [x y]\r\n\t\t\t\t\t\t\t(count (filter #(= \\# %) \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t (for [f1 [inc dec identity]\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t f2 [inc dec identity]\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t :when (not (and \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t (= f1 identity)\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t (= f2 identity)))]\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t (get-xy (f1 x) (f2 y))))))\r\n\r\n\t\t\t\t\t\t(evolve-cell [x y] \r\n\t\t\t\t\t\t\t(let [n (count-neighbors x y)\r\n\t\t\t\t\t\t\t\t\t\tcell (get-xy x y)]\r\n\t\t\t\t\t\t\t\t(cond\r\n\t\t\t\t\t\t\t\t\t(= cell \\#) ;if alive\r\n\t\t\t\t\t\t\t\t\t\t(cond\r\n\t\t\t\t\t\t\t\t\t\t\t(< n 2) \\space\r\n\t\t\t\t\t\t\t\t\t\t\t(< n 4) \\#\r\n\t\t\t\t\t\t\t\t\t\t\t:else \\space)\r\n\t\t\t\t\t\t\t\t\t(= cell \\space) ;if dead\r\n\t\t\t\t\t\t\t\t\t\t(cond\r\n\t\t\t\t\t\t\t\t\t\t\t(= n 3) \\#\r\n\t\t\t\t\t\t\t\t\t\t\t:else \\space))))]\r\n\t\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t(for [row (range (inc max_row))]\r\n\t\t\t\t(apply str (for [col (range (inc max_col))] (evolve-cell row col)))))))","problem":94,"user":"4e8a0c82535d3e98b802328d"},{"code":"(fn lifegame[in-arr]\n  (let [get-at (fn[arr x y](nth (nth arr y) x))\n        get-num (fn [arr x y]\n                  (count\n                   (filter #(= \\# %)\n                           (for [i (range (dec x) (inc (inc x))) j (range (dec y) (inc (inc y)))\n                                 :when (and (and (>= i 0) (>= j 0))\n                                            (and (< i (count arr)) (< j (count arr)))\n                                            (or (not (= x i)) (not (= y j))))]\n                             (get-at arr i j)))))]\n    (map #(apply str %) (partition (count (first in-arr)) (for [y (range (count in-arr))\n                                                                x (range (count (first in-arr)))]\n                                                            (let [elem (get-at in-arr x y)\n                                                                  count (get-num in-arr x y)]\n                                                              (if (= \\# elem)\n                                                                (cond\n                                                                 (< count 2) \\space\n                                                                 (> count 3) \\space\n                                                                 :else \\#)\n                                                                (if (= count 3) \\# \\space))))))))","problem":94,"user":"4fb86dc9e4b081705acca2d8"},{"problem":94,"code":"(fn game-of-life [board]\n  (let [deltas (for [x [-1 0 1]\n                     y [-1 0 1]\n                     :when (not= 0 x y)]\n                 [x y])\n        neighbors (fn [yx]\n                    (->> (map #(map + yx %) deltas)\n                         (filter (fn [new-yx]\n                                   (every? #(< -1 % (count board)) new-yx)))\n                         (map #(get-in board %))))\n        positions (map (fn [x]\n                         (vec (map #(vector x %) (range (count board)))))\n                       (range (count board)))\n        live? #(= \\# (get-in board %))\n        new-val (fn [yx]\n                  (let [c (count (filter (partial = \\#) (neighbors yx)))]\n                    (case (if (live? yx) :live :dead)\n                      :live (cond\n                             (< c 2)    \\space\n                             (<= 2 c 3) \\#\n                             :else      \\space)\n                      :dead (if (= 3 c) \\# \\space))))]\n    (map (partial reduce str)\n         (map (fn [yxs]\n                (map #(new-val %) yxs))\n              positions))))","user":"541b1f25e4b01498b1a71a63"},{"problem":94,"code":"(fn [b]\n    (let [s   range\n          [rl cl] (map count [b (first b)])\n          myr #(s (- % 1) (+ % 2))]\n      (letfn [(cell [r c] (-> b (nth r) (subs c (inc c))))\n              (n [r c]\n                (apply + (for [i (myr r)\n                               j (myr c)]\n                           (if (and (or (not= c j) (not= i r))\n                                    (< -0 i rl)\n                                    (< -0 j cl)\n                                    (= \"#\" (cell i j)))\n                             1 0))))]\n        (for [r (s rl)]\n          (clojure.string/join\n           (for [c (s cl)]\n             (let [v (cell r c)\n                   q (n r c)]\n               (or ({3 \"#\" 2 v} q) \" \"))))))))","user":"583048d9e4b051871117c007"},{"problem":94,"code":"(letfn [\n          (gamestr->vec [g]\n            (let [xf {\\space :dead \\# :live}]\n              (vec (map #(vec (map xf (seq %))) g))))\n          (vec->gamestr [v]\n            (let [xf {:dead \\space :live \\#}]\n              (map (fn [row] (apply str (map xf row))) v)\n              ))\n          (nb-idxs [x y]\n            [[(dec x) (dec y)] [x (dec y)] [(inc x) (dec y)]\n             [(dec x) y] [(inc x) y]\n             [(dec x) (inc y)] [x (inc y)] [(inc x) (inc y)]])\n          (count-nbs [game x y status]\n            (count\n              (for [[nx ny] (nb-idxs x y)\n                    :when (#{status} (get-in game [ny nx]))] 1)))\n          (summarize-nbs [game x y]\n            [(count-nbs game x y :live)\n             (count-nbs game x y :dead)])]\n    (fn [game]\n      (let [gvec (gamestr->vec game)\n            height (count gvec)\n            width (count (gvec 0))]\n        (vec->gamestr (reduce\n                        (fn [v [x y st]]\n                          (update-in v [y x] (fn [_ b] b) st))\n                        gvec\n                        (for [x (range 1 (dec width))\n                              y (range 1 (dec height))\n                              :let [live? (#{:live} (get-in gvec [y x]))\n                                    [nlive ndead] (summarize-nbs gvec x y)]]\n                          [x y (if live?\n                                 (cond\n                                   (< nlive 2) :dead\n                                   (> nlive 3) :dead\n                                   :else :live)\n                                 (cond\n                                   (= nlive 3) :live\n                                   :else :dead))]))))))","user":"58ec1e63e4b056aecfd47d54"},{"code":"(fn tick [board]\n  (letfn [(neighbors [yx board]\n            (let [size (count board) deltas [[-1 -1] [-1 0] [-1 1] [0 -1] [0 1] [1 -1] [1 0] [1 1]]\n                  nb-yx (filter\n                          (fn [new-yx]\n                            (every? #(< -1 % size) new-yx))\n                          (map #(map + yx %) deltas))]\n              (map #(get-in board %) nb-yx)))\n\n          (neighbor-count [yx board]\n            ((frequencies (neighbors yx board)) \\#))\n\n          (lives? [yx board]\n            (let [rules {\\space #{3} \\# #{2, 3}} ct (neighbor-count yx board)\n                  type (get-in board yx)]\n              (contains? (rules type) ct)))]\n\n  (map-indexed\n    (fn [y line]\n      (apply str (map-indexed\n        (fn [x _]\n          (if (lives? [y x] board) \\# \\space)) line)))\n     board)))","problem":94,"user":"5084c43be4b0fb8f40674bfa"},{"problem":94,"code":"(fn [b]\n  (map #(apply str %)\n       (let [b (vec (map vec b))\n             n (count b)\n             m (count (first b))\n             d [[-1 1] [-1 -1] [1 -1] [1 1] [0 1] [0 -1] [1 0] [-1 0]]]\n         (for [i (range n)]\n           (for [j (range m)]\n             (let [x (apply + (map #(let [i (+ i (first %))\n                                          j (+ j (second %))]\n                                      (if (and (>= i 0) (>= j 0) (< i n) (< j m) (= \\# ((b i) j)))\n                                        1\n                                        0)) d))\n                   c ((b i) j)]\n               (if (= c \\#)\n                 (if (or (= 2 x) (= 3 x))\n                   \\#\n                   \\ )\n                 (if (= 3 x)\n                   \\#\n                   \\ ))))))))","user":"5799ff45e4b05b1deef9add1"},{"problem":94,"code":"(fn next-life [board]\n  (let [neighbour-coords (fn [x y]\n                           (for [nx (range (dec x) (+ x 2))\n                                 ny (range (dec y) (+ y 2))\n                                 :when (not (or (neg? nx) (neg? ny)\n                                                (and (= nx x) (= ny y))))]\n                             [nx ny]))\n        alive? (partial = \\#)\n        future-cell (fn [cell neighbours]\n                      (let [live? (alive? cell)\n                            live-nbs (count (filter alive? neighbours))]\n                        (if (or (and live? (#{2 3} live-nbs))\n                                (and (not live?) (= live-nbs 3)))\n                          \\#\n                          \\space)))\n        L (count board), H (count (first board))]\n    (map #(apply str %)\n      (partition H \n          (for [x (range L), y (range H)]\n            (future-cell (get-in board [x y])\n                         (map (partial get-in board) \n                              (neighbour-coords x y))))))))","user":"5339c105e4b0e30313ee6cae"},{"problem":94,"code":"(fn next-board [board]\n  (let [pad (list (clojure.string/join (repeat (count (first board)) \" \")))\n        augboard (concat pad board pad)\n        lives?  (fn [board x y]\n                    (let [x1 (+ 3 x) y1 (+ 3 y) alive (= \"#\" (subs (board y) x (inc x)))\n                         near (count (remove #(or (= \\space %))\n                              (clojure.string/join (subvec\n                                                     (vec (map #(subs (str \" \" % \" \") x x1)\n                                                               augboard)) y y1))))\n                         neighbors (if alive (dec near) near)]\n                      (if (not alive) (if (= neighbors 3) \"#\" \" \")\n                          (if (or (= neighbors 2) (= neighbors 3)) \"#\" \" \"))))]\n    (map (fn [y] (clojure.string/join (map  #(lives? board  % y)\n                                            (range (count (first board))))))\n          (range (count board)))))","user":"579d9601e4b05b1deef9ae18"},{"problem":94,"code":"(fn [b]\n  (let [n #(apply +\n             (for [i [-1 0 1]\n                   j [-1 0 1]\n                   :let [h (get-in b [(+ % i) (+ %2 j)])]\n                   :when (and (= h \\#) (not= i j 0))]\n               1))\n        a #(let [l (n % %2)\n                 h (get-in b [% %2])]\n             (or (and (= h \\#) (or (= l 2) (= l 3)))\n                 (and (= h \\ ) (= l 3))))\n        s (range (count (b 0)))]\n    (for [r s]\n      (apply str (for [c s]\n                   (if (a r c) \\# \\ ))))))","user":"4ee4f4a9535d1385b2869d85"},{"problem":94,"code":"(fn next-frame [board]\r\n  (let [height (count board)\r\n        width (count (first board))]\r\n    (letfn [(get-neighbors [[x y]]\r\n              (remove (fn [[x y]]\r\n                        (or (some identity (map #(= -1 %) [x y]))\r\n                            (= x height) (= y width)))\r\n                      (map (fn [[a b]] [(+ a x) (+ b y)])\r\n                           [[0 1] [1 0]  [0 -1] [-1 0]\r\n                            [1 1] [1 -1] [-1 1] [-1 -1]])))\r\n            (get-position [[x y]] (= \\# (nth (board x) y)))\r\n            (living-neighbors [pos] (->> (get-neighbors pos)\r\n                                         (map get-position)\r\n                                         (filter true?)\r\n                                         (count)))]\r\n      (->> (for [x (range height)]\r\n         (->> (for [y (range width)]\r\n                (let [living?        (get-position [x y])\r\n                      live-neighbors (living-neighbors [x y])]\r\n              (if (or (and living? (< 1 live-neighbors 4))\r\n                      (= 3 live-neighbors))\r\n                \\# \\space)))\r\n          (reduce str)))\r\n       (vec)))))","user":"55d0e76ae4b0e31453f64a40"},{"problem":94,"code":"(fn [coll]\n    (letfn [ (find-v [row col coll] (do (-> coll (nth row) (nth col))))\n            (zero-or-greater [indices-coll] (filter #(every? (fn [x] (and (< x (count coll)) (>= x 0))) %)  indices-coll))\n\n            (neighbor-indices [row col] (zero-or-greater [[(inc row) col] [(dec row) col] [(inc row) (inc col)] [(inc row) (dec col)]\n                                                           [ row (inc col)] [row (dec col)] [(dec row) (dec col)] [(dec row) (inc col)]]))\n\n            (neighbors [row col]\n                      (map #(find-v (first %) (second %) coll) (neighbor-indices row col)))\n            (is-alive  [row col] (= \\# (find-v row col coll)))\n            (next-state [row col]\n                       (let [alive (is-alive row col)\n                             ns (neighbors row col)\n                             neighbor-count (count (filter #(= % \\#) ns))\n                             ]\n                         (if alive\n                           (if (or (= 2 neighbor-count) (= 3 neighbor-count))\n                             \\#\n                             \" \")\n                           (if (= 3 neighbor-count)\n                             \\#\n                             \" \"))))\n          ]\n      (map clojure.string/join (map-indexed (fn [r row] (map-indexed (fn [c val] (next-state r c)) row )) coll))\n      ))","user":"53c73e8ae4b00fb29b2212a5"},{"code":"(fn [grid]\n         (let [height-range (range (count grid))\n               width-range (range (count (grid 0)))\n               live-cells (set (for [y height-range\n                                     x width-range \n                                     :when (= (get-in grid [y x]) \\#)]\n                                 [x y]))\n               neighbors (fn [[x y]]\n                           (disj (set (for [i (range (- x 1) (+ x 2))\n                                            j (range (- y 1) (+ y 2))]\n                                        [i j])) \n                                 [x y]))\n               count-of-live-neighbors-matches (fn [pred]\n                                              #(pred (count (filter live-cells (neighbors %)))))\n               dead-cells-nearby (filter (complement live-cells) \n                                         (distinct (mapcat neighbors live-cells)))\n               next-live-cells (set (concat\n                                      (filter (count-of-live-neighbors-matches #{2 3}) live-cells)\n                                      (filter (count-of-live-neighbors-matches #{3}) dead-cells-nearby)))]\n           (for [y height-range]\n             (apply str (for [x width-range]\n                          (if (next-live-cells [x y])\n                            \"#\"\n                            \" \"))))))","problem":94,"user":"51789dfae4b03d69594194d7"},{"code":"(fn next-board [board]\n  (let [r (count board)\n        c (count (first board))\n        alive? (fn [x y]\n                 (= \\# (get-in board [x y])))\n        neighbors (fn [x y]\n                    (for [xx [(dec x) x (inc x)]\n                          yy [(dec y) y (inc y)]\n                          :when (not (and (= x xx)\n                                          (= y yy)))]\n                      (alive? xx yy)))\n        count-neighbors (fn [x y]\n                          (count (filter identity\n                                         (neighbors x y))))\n        alive-next-tick? (fn [x y]\n                           (let [cnt (count-neighbors x y)]\n                             (or (= cnt 3)\n                                 (and (alive? x y)\n                                      (= cnt 2)))))]\n    (for [i (range r)]\n      (apply str\n             (for [j (range c)]\n               (if (alive-next-tick? i j)\n                 \"#\"\n                 \" \"))))))","problem":94,"user":"530578ede4b0d8b024fd3760"},{"problem":94,"code":"(fn next_life [board]\n    (let\n        [\n            live \\# dead \\ \n            mrow (count board) mcol (count (first board))\n            inbound?\n                (fn [row col] (every? true? [(>= row 0) (< row mrow) (>= col 0) (< col mcol)]))\n            live?\n                (fn [row col] (= live (nth (nth board row) col)))\n            dead?\n                (fn [row col] (= dead (nth (nth board row) col)))\n            live_neighbors\n                (fn [row col]\n                    (->> (for\n                            [i (range -1 2) j (range -1 2)\n                            :when (not= i j 0)]\n                            [(+ row i) (+ col j)]\n                        )\n                        (filter (fn [[r c]] (inbound? r c)) )\n                        (filter (fn [[row col]] (live? row col) ) )\n                        (count)\n                    )\n                )\n            next_state\n                (fn [row col]\n                    (let\n                        [\n                            ln (live_neighbors row col)\n                        ]\n                        (cond\n                            (and (live? row col) (< ln 2)) dead\n                            (and (live? row col) (or (= ln 2) (= ln 3))) live\n                            (and (live? row col) (> ln 3)) dead\n                            (and (dead? row col) (= ln 3)) live\n                            :otherwise dead\n                        )\n                    )\n                )\n        ]\n        (vec (for [row (range mrow)]\n            (clojure.string/join\n                \"\"\n                (map #(apply next_state %) (for [col (range mcol)] [row col]))\n            )\n        ))\n    )\n)","user":"5db7376fe4b010eb3c36cd43"},{"problem":94,"code":"(fn gol [board]\n  (let [rows (count board)\n        cols (count (first board))]\n\n    (letfn [(alive? [row column] (= \\# (get-in board [row column])))\n            (alive-neighbors [row col]\n              (count\n               (seq\n                (for [row-d (range -1 2) col-d (range -1 2)\n                      :let [row' (+ row row-d)\n                            col' (+ col col-d)]\n\n                      :when (and (not (and (zero? row-d)\n                                           (zero? col-d)))\n\n                                 (< -1 row' rows)\n                                 (< -1 col' cols)\n\n                                 (alive? row' col'))]\n                  true))))\n\n            (alive-in-next-state [currently-alive alive-neighbors]\n              (if currently-alive\n                (<= 2 alive-neighbors 3)\n                (= alive-neighbors 3)))]\n\n\n      (let [alive-cells (for [row (range rows) col (range cols)\n                              :let [alive (alive? row col)\n                                    neighbors (alive-neighbors row col)]\n                              :when (alive-in-next-state alive neighbors)]\n                          [row col])]\n\n        (map (partial apply str) (reduce\n                  (fn [new-board [row col]]\n                    (assoc-in new-board [row col] \\#))\n                  (vec (repeat rows (vec (repeat cols \\space))))\n                  alive-cells))))))","user":"58b81490e4b0ebc645576d8c"},{"code":"(fn gol [board]\n  (let\n    [m (count board)\n     n (count (first board))\n     alives (filter #(= \\# (get-in board %))\n                    (for [r (range m)\n                          c (range n)]\n                      [r c]))\n     neighbors (for [[r c] alives\n                     dr [-1 0 1]\n                     dc [-1 0 1]\n                     :when (not= dr dc 0)]\n                 [(+ r dr) (+ c dc)])\n      new (map first\n               (filter (fn [[[r c] nbors]]\n                   (cond\n                    (< nbors 2) false\n                    (= nbors 2) (= \\# (get-in board [r c]))\n                    (= nbors 3) true\n                    :else false))\n                  (frequencies neighbors)))\n     new-board (vec (repeat m (vec (repeat n \\space))))\n     final (reduce #(assoc-in % %2 \\#) new-board new)]\n    (mapv #(apply str %) final)))","problem":94,"user":"50217818e4b00bba4502f7a7"},{"problem":94,"code":"(fn [board] \n  (let [cells (set (for [y (range (count board))\n                         x (range (count (get board y)))\n                         :when (not= \\space (get-in board [y x]))]\n                     [x y]))\n        width (count (first board))\n        height (count board)\n        neighbors (fn [[x y]]\n                    (for [dx [-1 0 1] dy (if (zero? dx) [-1 1] [-1 0 1])]\n                      [(+ x dx) (+ y dy)]))\n        step (fn [cells]\n               (set (for [[loc n] (frequencies (mapcat neighbors cells))\n                          :when (or (= n 3) (and (= n 2) (cells loc)))]\n                      loc)))\n        serialize (fn [alive] \n                    (mapv #(apply str %) \n                          (partition width\n                                     (for [y (range height) x (range width) \n                                           :let [sym (if (alive [x y]) \\# \\space)]]\n                                       sym))))]\n    (-> cells step serialize)))","user":"5c2649c8e4b07e362c2305bf"},{"code":"(fn [b]\n  (let [w (count (first b))\n        h (count b)\n        n (fn [x y]\n            (let [off [-1 0 1]]\n              (partition 2 (flatten (map (fn [yoff]\n                                 (map (fn [xoff] (if (= 0 xoff yoff) [] [(mod (+ x xoff) w) (mod (+ y yoff) h)])) off)) off)))))\n        a? (fn [x y] (= \"#\" (str (nth (nth b y) x))))\n        ac (map (fn [y]\n                  (map (fn [x]\n                         (let [neigh (n x y)\n                               ct (count (filter (fn [cc] (a? (first cc) (second cc))) neigh))]\n                           (cond\n                            (and (a? x y) (< ct 2)) \" \"\n                            (and (a? x y)  (< ct 4)) \"#\"\n                            (and (a? x y) (> ct 3)) \" \"\n                            (and (not (a? x y)) (= ct 3)) \"#\"\n                            :else \" \")\n                    ))\n                (range w)))\n         (range h))\n        ]\n    (map (fn [r] (apply str r)) ac)))","problem":94,"user":"4e773be8535d324fb2983d6e"},{"problem":94,"code":"(fn [board]\n   (let [maxx (count (first board))\n         maxy (count board)]\n     (letfn [(alive? [[x y]] (= (get-in board [y x]) \\#))\n             (neighbours [[x y]] (for [dx [-1 0 1] dy [-1 0 1] :when (and (not (and (zero? dx) (zero? dy)))\n                                                                          (< -1 (+ x dx) maxx)\n                                                                          (< -1 (+ y dy) maxy))] [(+ x dx) (+ y dy)]))\n             (next-gen [loc] (let [population (count (filter alive? (neighbours loc)))]\n                               (cond (< population 2) \" \"\n                                     (= population 2) (if (alive? loc) \"#\" \" \")\n                                     (= population 3) \"#\"\n                                     (> population 3) \" \")))\n             (next-row-gen [y] (apply str (map next-gen (for [x (range 0 maxx)] [x y]))))]\n       (into [] (map next-row-gen (range 0 maxy))))))","user":"51672d15e4b079759a74a5e7"},{"code":"(letfn [\n(live? [board x y]\n  (if (or (< x 0) (< y 0) (>= x (count (board 0))) (>= y (count board)))\n    0\n    (if (= \\# (nth (board x) y))\n      1\n      0)))\n\n(live-next-gen? [board x y]\n  (let [cnt (- (apply +\n  \t      (for [x- (range -1 2) y- (range -1 2)] (live? board (+ x- x) (+ y- y))))\n\t       (live? board x y))]\n    (if (= 1 (live? board x y))\n      (if (< cnt 2)\n\t\\space\n\t(if (<= cnt 3)\n\t  \\#\n\t  \\space))\n      (if (= cnt 3)\n\t\\#\n\t\\space))))\n\t  \n\n(gol-next-gen [board]\n  (let [size-x (count (board 0))\n\tsize-y (count board)]\n    (partition size-x (for [x (range size-x) y (range size-y)] (live-next-gen? board x y)))))\n]\n(fn [board]\n  (map #(apply str %) (gol-next-gen board))))","problem":94,"user":"4e89ff3d535d3e98b802328a"},{"problem":94,"code":"(fn life [board]\n   (letfn [(alive? [x y] (= \\# (get-in board [x y])))\n           (count-neighbors [x y]\n             (reduce + (for [dx [-1 0 1] dy [-1 0 1]\n                             :when (not= dx dy 0)]\n                         (if (alive? (+ x dx) (+ y dy)) 1 0))))\n           (convert [x y]\n             (let [num (count-neighbors x y)]\n               (if (alive? x y)\n                 (if (or (> num 3) (< num 2)) \\space \\#)\n                 (if (= num 3) \\# \\space))))]\n     (map-indexed\n      (fn [i row] (->> (map-indexed (fn [j _] (convert i j)) row)\n                       (apply str)))\n      board)))","user":"5935b010e4b04f87174def55"},{"code":"(fn [d]\n  (let [bound_x (count (nth d 0)) bound_y (count d) _get (fn [x y] \n       (if (or (< x 0)(>= x bound_x)(< y 0)(>= y bound_y)) nil \n       (nth (nth d y) x)))\n       neighbours (fn [x y] (let \n             [d1 (_get (dec x) (dec y))\n              d2 (_get x (dec y))\n              d3 (_get (inc x) (dec y))\n              d4 (_get (dec x) y)\n              d5 (_get (inc x) y)\n              d6 (_get (dec x) (inc y))\n              d7 (_get x (inc y))\n              d8 (_get (inc x) (inc y))][d1 d2 d3 d4 d5 d6 d7 d8]))]\n     (map #(apply str %) (partition bound_x (for [y (range bound_y) x (range bound_x)]\n      (let [nbs (neighbours x y)\n            dpc (count (filter #(= \\space %) nbs))\n            lpc (count (filter #(= \\# %) nbs))\n            p (_get x y)]\n        (if (= p \\#) \n          (if (< lpc 2) \\space\n            (if (> lpc 3) \\space\n               \\#\n            )\n          )\n          (if (= 3 lpc) \\# \\space)\n        )\n      )\n    )))\n  )\n)","problem":94,"user":"522eba30e4b01cdb292c5f0e"},{"code":"(fn life-next [board] \n  (letfn [(neighbors [xs i]\n            (let [v (vec xs)]\n              (cond\n                (zero? i)               (subvec v i (+ i 2))\n                (= i (dec (count xs)))  (subvec v (dec i) (inc i))\n                :else                   (subvec v (dec i) (+ i 2)))))\n\n          (nnum [vn i board]\n            (let [width (count (first board))\n                  height (count board)\n                  level (nth board vn)\n                  alive? (= (nth level i) \\#)\n                  up (if-not (zero? vn) (nth board (dec vn)) (repeat width 0))\n                  down (if-not (= (dec height) vn) (nth board (inc vn)) (repeat width 0))\n                  nn (count (filter #{\\#} \n                                    (concat (neighbors up i)\n                                            (neighbors level i)\n                                            (neighbors down i))))]\n              (if alive? (dec nn) nn)))\n\n          (nature [cell nn]\n            (case cell\n              \\space (if (= nn 3) \\# \\space)\n              (cond\n                (or (< nn 2) (> nn 3)) \\space\n                :else \\#)))]\n    (map-indexed (fn [ri row] \n                   (apply str (map-indexed (fn [ci cell]\n                                  (nature cell (nnum ri ci board)))\n                                row))) board)))","problem":94,"user":"50c781bbe4b00bb60fe0c535"},{"problem":94,"code":"(fn game-of-life [board]\n    (letfn [\n\n        (get-pos [b x y] ;All good\n            (cond \n                (< x 0) \\space\n                (< y 0) \\space\n                (>= y (count b)) \\space\n                (>= x (count (nth b y))) \\space\n                :else (nth (nth b y) x)))\n\n        (get-adjacent [b x y]\n            (let [inc-lst [[1 1] [1 0] [0 1] [-1 -1]\n                [1 -1] [-1 1] [0 -1] [-1 0]]]\n             (map #(get-pos b (first %) (second %)) \n                (map #(identity [(+ (first %) x) (+ (second %) y)]) inc-lst))))\n\n        (next-cell-state [b x y]\n            (let [cell (get-pos b x y)\n                adj-lst (get-adjacent b x y)\n                num-alive (count (filter #(= \\# %) adj-lst))]\n                (case cell\n                \\space (if (= num-alive 3) \\# \\space)\n                \\# (cond \n                    (< num-alive 2) \\space\n                    (> num-alive 3) \\space\n                    :else \\#))))\n        ]\n        (loop [res [] y 0]\n            (if (>= y (count board))\n                res\n                (recur (conj res (apply str (map #(next-cell-state board % y) (range 0 (count (nth board y)))))) (inc y))))))","user":"54f09599e4b024c67c0cf89d"},{"code":"(fn gameoflife [b]\r\n    (let [w (count (first b)) \r\n          h (count b) \r\n          m (into {} (apply concat (map-indexed (fn [y row] (map-indexed (fn [x c] [[x y] (if (= c \\#) 1 0)]) row)) b)))\r\n          nb (fn [m x y] (+ (m [(dec x) (dec y)] 0) (m [(dec x) y] 0) (m [(dec x) (inc y)] 0)\r\n                            (m [x (dec y)] 0) (m [x (inc y)] 0)\r\n                            (m [(inc x) (dec y)] 0) (m [(inc x) y] 0) (m [(inc x) (inc y)] 0)))]\r\n      (into [] (map (fn [y] (apply str (map (fn [x]  \r\n                                              (let [lc (nb m x y)\r\n                                                    l (m [x y])] \r\n                                                (if ({[1 2] true, [1 3] true, [0 3] true} [l lc] false) \\# \\space )\r\n                                                )) (range w)))) (range h)))))","problem":94,"user":"4feada56e4b0140c20fb9c11"},{"code":"(fn life [board]\n  (let [rows (count board)\n        cols (count (first board))\n        cell (fn [b i j] (get (get b i []) j \" \"))]\n    (for [i (range rows)]\n      (apply str (for [j (range cols)]\n        (let [neighbors (reduce +\n                          (for [x [-1 0 1]\n                                y [-1 0 1]\n                                :when (not= x y 0)]\n                            (if (= (cell board (+ i x) (+ j y)) \\#) 1 0)))\n              c (cell board i j)]\n          (cond\n           (and (= c \\#) (or (< neighbors 2) (> neighbors 3))) \\ \n           (and (= c \\ ) (= neighbors 3)) \\#\n           :else c\n           )\n          )\n        ))\n      )\n    )\n  )","problem":94,"user":"52e59ca5e4b09f7907dd1464"},{"code":"(fn [i-board]\n     (let [\n           c-count (count (first i-board))\n           r-count (count i-board)\n           in-board (fn [i-coor]\n                            (let [[i-row i-col] i-coor]\n                              (and\n                                (>= i-row 0)\n                                (< i-row r-count)\n                                (>= i-col 0)\n                                (< i-col c-count))))\n           has-life (fn [i-coor]\n                        (= \\# (nth (nth i-board (first i-coor)) (last i-coor))))\n           board-coor (reduce\n                        concat\n                        '()\n                        (map\n                          (fn [my-row]\n                              (map #(vector my-row %) (range c-count)))\n                          (range r-count)))\n           live-list (filter has-life board-coor)\n           dead-list (filter #(not (has-life %)) board-coor)\n           neighbour (fn [i-coor]\n                         (let [[i-row i-col] i-coor]\n                           (filter\n                             #(let [[my-row my-col] %] (not (and (= my-row i-row) (= my-col i-col))))\n                             (reduce\n                               concat\n                               '()\n                               (map\n                                 (fn [i-coors]\n                                     (filter in-board i-coors))\n                                 (map\n                                   (fn [my-row]\n                                       (map\n                                         (fn [my-col]\n                                             (vector my-row my-col))\n                                         (range (dec i-col) (+ i-col 2))))\n                                   (range (dec i-row) (+ i-row 2))))))))\n           living-neighbour (fn [i-coor] (filter has-life (neighbour i-coor)))\n           lives-on (fn [i-coor]\n                        (let [n-count (count (living-neighbour i-coor))]\n                          (or (= 2 n-count) (= 3 n-count))))\n           reproducible (fn [i-coor]\n                            (= 3 (count (living-neighbour i-coor))))\n           new-lives (group-by\n                       #(first %)\n                       (concat\n                         (filter lives-on live-list)\n                         (filter reproducible dead-list)))\n           draw-row (fn plot-lives\n                        ([i-row] (plot-lives [] 0 (sort (map last (get new-lives i-row)))))\n                        ([result i-pos i-lives]\n                         (if (= c-count i-pos)\n                           (apply str result)\n                           (let [c-life (first i-lives) n-pos (inc i-pos)]\n                             (if (= i-pos c-life)\n                               (plot-lives (conj result \\#) n-pos (rest i-lives))\n                               (plot-lives (conj result \\space) n-pos i-lives))))))\n           ]\n       (map draw-row (range r-count))))","problem":94,"user":"4dddf817535d08e6dec9fdd3"},{"problem":94,"code":"(fn life [b]\n  (letfn [(live-count-row [x row]\n            (count (re-seq #\"#\" (subs row (max 0 (dec x)) (min (+ 2 x) (count row))))))\n          (live-count [x y]\n            (reduce #(+ %1 (live-count-row x %2)) 0 (subvec b (max 0 (dec y)) (min (+ 2 y) (count b)))))]\n  (map-indexed (fn [y row]\n                 (apply str (map-indexed (fn [x cell]\n                                (let [c (live-count x y)]\n                                  (if (= cell \\#)\n                                   (if (or (= c 3) (= c 4)) \"#\" \" \")\n                                   (if (= c 3) \"#\" \" \")))) row))) b)))","user":"5dd60c58e4b0948ae9d9ad7c"},{"problem":94,"code":"(fn next-gen [cells]\n  (let [cell-size (count cells)\n        cell-column (count (first cells))\n        neighbors (fn [xy]\n                    (let [delta [[-1 0] [1 0] [0 -1] [0 1] [-1 -1] [-1 1] [1 -1] [1 1]]]\n                      (filter \n                       (fn [xy] (every? #(< -1 % cell-size) xy))\n                       (map #(map + % xy) delta))))\n        neighbor-contents (fn [xy]\n                            (map (partial get-in cells) (neighbors xy)))\n        count-lives (fn [lives]\n                      (reduce (fn[[l d] c] (if (= c \\#) [(inc l) d] [l (inc d)])) [0 0] lives))]\n    (for [r (range 0 cell-size)]\n      (apply str (for [c (range 0 cell-column)]\n             (let [content (get-in cells [r c])\n                   [lives deaths] (count-lives (neighbor-contents [r c]))]\n               (if (= content \\#) (cond \n                                   (< lives 2) \\space\n                                   (< lives 4) \\#\n                                   :else \\space)\n                 (if (= lives 3) \\# \\space))))))))","user":"541619e8e4b01498b1a719f9"},{"problem":94,"code":"(fn game-life [Board]\n  (letfn [(neib-cells [l c n]\n            (let [nei [[(dec l) (dec c)] [(dec l) c] [(dec l) (inc c)]\n                       [l (dec c)] [l (inc c)]\n                       [(inc l) (dec c)] [(inc l) c] [(inc l) (inc c)]]]\n              (reduce #(if (or (< (%2 0) 0) (< (%2 1) 0)\n                               (> (%2 0) (dec n)) (> (%2 1) (dec n)))\n                         %1\n                         (conj %1 %2)) [] nei)))\n          \n          (alive? [l c Board]\n            (= ((Board l) c) \\#))\n\n          (next-val [l c Board]\n            (let [neib (neib-cells l c (count Board))\n                  nalive (reduce #(if (alive? (%2 0) (%2 1) Board)\n                                    (inc %1)\n                                    %1) 0 neib)]\n              (if (alive? l c Board) \n                (if (< nalive 2) \n                  \\space\n                  (if (and (>= nalive 2) (<= nalive 3)) \n                    \\#\n                    \\space))\n                (if (= nalive 3)\n                  \\#\n                  \\space))))\n          ]\n    (let [Board (apply vector (map #(apply vector %) Board))\n          n (count Board)\n          pos (for [x (range n)\n                    y  (range n)] [x y])\n          B2 (apply vector (for [x (range n)] (apply vector (take n (repeat \\space)))))]\n      (mapv #(apply str %) \n            (reduce (fn [B p]\n                      (let [l (p 0)\n                            c (p 1)]\n                        (assoc B l (assoc (B l) c (next-val l c Board))))) B2 pos)))))","user":"574f1c24e4b02ea114799255"},{"code":"(fn [A M h n g]\n      (M\n       (fn [y r]\n         (A str\n            (M\n             (fn [x c]\n               (if\n                 (({h #{2 3} \\  #{3}} c) \n                  (A +\n                     (M #({h 1 \\  0}\n                          (get-in g (map + [y x] %2) \\ ))\n                        [[n n] [n 0] [n 1] [0 n] [0 1] [1 n] [1 0] [1 1]])))\n                 h\n                 \\ ))\n             r)))\n       g))\n    apply\n    map-indexed\n    \\#\n    -1","problem":94,"user":"4dc537fd535d8a4b2fd74282"},{"code":"(fn [board]\n  (let [\n    width (count (first board))\n    height (count board)\n    cell (fn [x y] (if (or (< x 0) (< y 0) (>= x width) (>= y height)) \\space (nth (nth board y) x)))\n    alive? #(= \\# %)\n    dead? #(not (alive? %))\n    neighbors (fn [x y]\n      (count\n        (filter alive?\n          [(cell (dec x) (dec y)) (cell x (dec y)) (cell (inc x) (dec y))\n           (cell (dec x) y) (cell (inc x) y)\n           (cell (dec x) (inc y)) (cell x (inc y)) (cell (inc x) (inc y))])))\n    result\n      (for [y (range 0 height) x (range 0 width)]\n        (let [c (cell x y)\n              n (neighbors x y)]\n          (if (dead? c)\n            (if (= n 3) \\# \\space)\n            (if (or (= n 2) (= n 3)) \\# \\space))))]\n  (map #(apply str %) (partition width result))))","problem":94,"user":"4f1b92d1535d64f60314647b"},{"problem":94,"code":"(fn [v] (let [abs (fn [n] (max n (- n))) cords (into [] (apply concat (map-indexed (fn [i s] (map-indexed (fn [j c] [i j c]) s)) v)))] (into [] (map-indexed (fn [i s] (clojure.string/join (map-indexed (fn [j c] (let [n (count (filter (fn [p] (and (<= (abs (- (p 0) i)) 1) (<= (abs (- (p 1) j)) 1) (not (and (= (p 0) i) (= (p 1) j))) (= (p 2) \\#))) cords))] (if (= c \\#) (if (or (= n 2) (= n 3)) \\# \\space) (if (= n 3) \\# \\space)))) s))) v))))","user":"5abe2fc2e4b073f17744271e"},{"code":"(letfn [(split-3 [s]\n          (for [i (range (- (count s) 2))]\n            (.substring s i (+ i 3))))\n        (split-rows [ss]\n          (partition 3 1 ss))\n        (life [a b c]\n          (let [live? (= \\# (second b))\n                total (count (filter #(= % \\#) (str a b c)))]\n            (cond\n\t            (and live? (<= 3 total 4)) \"#\"\n\t            (and (not live?) (= total 3)) \"#\"\n\t            :else \" \")))\n        (expand [ss]\n          (let [len (+ 2(count (first ss)))]\n            (concat [(apply str (repeat len \" \"))]\n                    (map #(str \" \" % \" \") ss)\n\t\t\t              [(apply str (repeat len \" \"))])))]\n  #(map (partial apply str)\n     (map (partial apply map life)\n       (split-rows (map split-3 (expand %))))))","problem":94,"user":"4ddbfb8a535d02782fcbea00"},{"problem":94,"code":"(fn [xs]\n  (let [w (count (first xs))\n        s \\space\n        r0 (apply str (repeat (+ 2 w) s))\n        xs' (concat [r0] (map #(str s % s) xs) [r0])\n        bs (for [rs (partition 3 1 xs')\n                 cs (partition 3 1 (apply map str rs))]\n             (apply str cs))\n        c' (fn [b]\n             (let [a (= \\# (first (drop 4 b)))\n                   c (count (filter #{\\#} b))]\n               (or (and a (<= 3 c 4)) (and (not a) (= 3 c)))))\n        cs' (map #(if (c' %) \\# s) bs)\n        ]\n    (map #(apply str %) (partition w cs'))))","user":"553e0b70e4b0a04f792994e8"},{"code":"(fn [b]\r\n  (for [y (range(count b))]\r\n    (apply str\r\n           (for [x (range(count(nth b y)))]\r\n             (let [v [[-1 -1][-1 0][-1 1][0 -1][0 1][1 -1][1 0][1 1]]\r\n                   l (map #(nth (nth b (+ y (second %)) [\\space]) (+ x (first %)) \\space) v)\r\n                   n (count(filter #(= \\# %) l))]\r\n               (if (= (nth (nth b y) x) \\#)\r\n                 (if (or (= n 2) (= n 3)) \\# \\space)\r\n                 (if (= n 3) \\# \\space)))))))","problem":94,"user":"4dc1ee85535d020aff1edf91"},{"problem":94,"code":"(fn [board]\n  (let [result (map-indexed\n                 (fn [x row]\n                   (map-indexed\n                     (fn [y cell]\n                       (let [neighbor-count (->> (for [dx (range -1 2)\n                                                       dy (range -1 2)\n                                                       :when (not (and (= 0 dx) (= 0 dy)))]\n                                                   (get-in board [(+ x dx) (+ y dy)]))\n                                                 (filter (partial = \\#))\n                                                 (count))]\n                         (case neighbor-count\n                           2 cell\n                           3 \\#\n                           \\space)))\n                     row))\n                 board)]\n    (map (partial apply str) result)))","user":"50ebd63ce4b04edc3377703c"},{"code":"(fn [board]\n  (let [w (count (first board))\n        h (count board)\n        at (fn [x y] (.charAt (board y) x))\n        tree (->>\n              (for [x (range w), y (range h)]\n                (zipmap (map #(map + [x y] %)\n                             [[1 0] [0 1] [-1 0] [0 -1]\n                              [1 1] [-1 -1] [-1 1] [1 -1]])\n                        (repeat (if (= \\# (at x y)) \n                                      [\\#] nil))))\n              (apply merge-with concat))]\n    (for [y (range h)]\n      (apply str\n        (for [x (range w)]\n          (condp = (count (tree [x y]))\n                 2 (at x y)\n                 3 \\#\n                 \\space))))))","problem":94,"user":"4fb1d907e4b081705acca282"},{"problem":94,"code":"(fn [s]\n  (let[sm (mapcat #(map (fn [y v] [%1 y v]) (range) %2) (range) s)]\n    (letfn [(nbrs [[x y _]]\n              (let [x- (dec x), x+ (inc x)\n                    y- (dec y), y+ (inc y)]\n                (reduce (fn [a [xi yi v]]\n                          (if (and (= v \\#)\n                                   (or (not= x xi) (not= y yi))\n                                   (or (= x- xi) (= xi x) (= xi x+))\n                                   (or (= y- yi) (= yi y) (= yi y+)))\n                            (inc a) a))\n                        0 sm)))]\n      (->> sm\n           (map (fn [[_ _ v :as p]]\n                  (let [n (nbrs p)]\n                    (cond (and (= v \\#) (or (= n 2) (= n 3))) \\#\n                          (and (= v \\space) (= n 3)) \\#\n                          :else \\space))))\n           (partition (-> s first count))\n           (map (partial reduce str))))))","user":"515bbcd9e4b0388ca8ca1521"},{"code":"(fn [world]\n  (let [height (count world)\n        width (count (first world))]\n    (map (partial apply str)\n         (reduce (fn [matrix [y x :as coords]]\n                   (let [live-neighbours\n                         (count (filter #{\\#}\n                                        (map #(get-in world %)\n                                             (for [dy [-1 0 1] dx [-1 0 1] :when (and (not= 0 dx dy)\n                                                                                      ((set (range height)) (+ y dy))\n                                                                                      ((set (range width)) (+ x dx)))]\n                                               [(+ y dy) (+ x dx)]))))]\n                     (assoc-in matrix\n                               coords\n                               (if (= \\space (get-in world coords))\n                                 (if (= 3 live-neighbours) \\# \\space)\n                                 (if (or (< live-neighbours 2)\n                                         (> live-neighbours 3))\n                                   \\space\n                                   \\# ))))\n                   )\n                 (vec (map vec world))\n                 (for [y (range height) x (range width)] [y x])))))","problem":94,"user":"4f04b66b535dcb61093f6bdd"},{"code":"(letfn [\n    ; Cells\n    (live-cell [] \\#)\n    (dead-cell [] \\space)\n    (live? [cell] (= cell (live-cell)))\n    (dead? [cell] (= cell (dead-cell)))\n    (successor [cell neighbors]\n      (let [ln (count (filter live? neighbors))]\n        (if (live? cell)\n          (cond (<  ln 2) (dead-cell)\n                (<= ln 3) (live-cell)\n                (>  ln 3) (dead-cell))\n          (cond (=  ln 3) (live-cell)\n                true      (dead-cell)))))\n    ; Boards\n    (board-from-strings [strs] strs)\n    (strings-from-board [board] board)\n    ; Locations\n    (get-cell [board location]\n      (get-in board location (dead-cell)))\n    (get-neighbor-cells [board location]\n      (map #(get-cell board %)\n        (for [i [-1 0 1]\n              j [-1 0 1]\n              :when (not= [i j] [0 0])]\n          (map + location [i j]))))\n    (get-successor [board location]\n      (successor (get-cell board location)\n                 (get-neighbor-cells board location)))\n    (map-board [f board]\n      (vec (map\n        (fn [row] (apply str (map\n          (fn [col]\n            (f [row col]))\n          (range (count (board row))))))\n        (range (count board)))))]\n  (fn [x]\n    (let [b (board-from-strings x)]\n      (strings-from-board\n        (map-board #(get-successor b %) b)))))","problem":94,"user":"4f6fbb68e4b07046d9f4efeb"},{"problem":94,"code":"(fn [board]\n  (let [h (count board)\n        w (count (first board))\n        live-neighbor-count (fn [board [y x]]\n                              (count (filter #(= % \\#) (for [dx [-1 0 1] dy [-1 0 1] :when (not= dx dy 0)]\n                                                         (get-in board [(+ y dy) (+ x dx)])))))]\n    (map #(apply str %) (partition w (for [y (range h) x (range w)]\n                                       (let [coords [y x]\n                                             letter (get-in board coords)\n                                             n-count (live-neighbor-count board coords)]\n                                         (if (or\n                                               (= n-count 3)\n                                               (and\n                                                 (= letter \\#)\n                                                 (= n-count 2)))\n                                           \\#\n                                           \\space)))))))","user":"536046a9e4b063bf7a5f8fe1"},{"code":"(fn [c]\n    (let [l (count c)\n          alive? (fn [x y] (= \\# (get-in c [x y])))\n          neighbours (fn [x y]\n                       (reduce #(if %2 (inc %) %) 0 (for [i [-1 0 1] j [-1 0 1] :when (not= i j 0)]\n                                                      (alive? (+ x i) (+ y j)))))\n          son (fn [x y n] (if (or (= n 3) (and (= n 2) (alive? x y))) \\# \" \"))]\n      (for [i (range l)]\n        (apply str (for [j (range l)]\n                     (son i j (neighbours i j)))))))","problem":94,"user":"52e3e6a8e4b09f7907dd1448"},{"code":"(fn eva [cells]\n  (letfn [\n    (lo [x y]\n      (get (get cells y) x)\n    )        \n    (neib [xp yp cells]\n      (count (for \n          [x (range (dec xp) (+ 2 xp) ) y (range (dec yp) (+ 2 yp)) \n        :when (and (= \\# (lo x y)) (or (not= xp x) (not= yp y))  ) ]\n         true\n      ))\n    )\n  ]\n  (for \n      [y (range (count cells) ) ]\n      (apply str (for [x (range (count (first cells)))]\n        (let [ne (neib x y cells)]\n          \n          (cond \n             (= ne 3) \\#\n           ; under population\n             (< ne 2) \\space\n           ; over population\n             (> ne 3) \\space\n             :else (lo x y)\n          )\n         \n        )\n      ))\n  )\n  \n    \n))","problem":94,"user":"5191045ee4b0f8ef0be96bf3"},{"problem":94,"code":"(fn [board]\n  (let \n    [width (count board)\n     height (count (first board))\n     coords (set\n             (for [x (range width) \n                   y (range height) \n                   :when (= (get-in board [x y]) \\#)]\n               [x y]))\n     neighbours (fn [[x y]] (for [dx [-1 0 1] dy [-1 0 1] :when (not= 0 dx dy)] [(+ x dx) (+ y dy)]))\n     new-coords (set\n                 (for [[loc n] (frequencies (mapcat neighbours coords))\n                       :when (or (= n 3) (and (= n 2) (coords loc)))]\n                   loc))\n     empty-board (vec (repeat width (vec (repeat height \\ ))))]\n    (mapv (partial apply str) (reduce #(assoc-in % %2 \\#) empty-board new-coords))))","user":"5392bfdee4b0b51d73faaeb2"},{"problem":94,"code":"(fn [matrix]\n  (let [rows (count matrix)\n        cols (count (first matrix))\n        [living-cell dead-cell] [\\# \\space]\n        alive? (fn [[row col]]\n                 (= living-cell (nth (nth matrix row) col)))\n        live-neighbours (fn [[row col]]\n                     (for [r [(dec row) row (inc row)]\n                           c [(dec col) col (inc col)]\n                           :when (and (< -1 r) (< r rows)\n                                   (< -1 c) (< c cols)\n                                   (not= [row col] [r c])\n                                   (alive? [r c]))]\n                       [r c]))\n        next-state (fn [[x y]]\n                     (let [ln (-> [x y] live-neighbours count)\n                           live (if (alive? [x y])\n                                  (and (< 1 ln) (< ln 4))\n                                  (= 3 ln))]\n                       (if live living-cell dead-cell)))\n        ->row (fn [r] (apply str\n                        (for [c (range cols)] (next-state [r c]))))]\n    (mapv ->row (range rows))))","user":"52ee46e5e4b05e3f0be25ec5"},{"problem":94,"code":"(fn [board]\n  (letfn[(neighbors [[row column]];get the neighbor positions\n                    (map (fn [[r c]] [(+ r row),(+ c column)]) '([-1 -1] [-1 0] [-1 1] [0 -1] [0 1] [1 -1] [1 0] [1 1])))\n         (cleanPositions [row column posSeq];remove illegal positions\n                         (filter (fn [[r c]] (and (< -1 r row) (< -1 c column))) posSeq))]\n    (let[row (count board) column (count (first board))]\n      (reduce merge [] ;prepare the final board result\n              (for [r (range row)];iterate over rows\n                (apply str ;prepare the row result\n                       (for[c (range column)];iterate over columns\n                         (let [localVal (get (get board r) c);get local value\n                               numOfLives (count (filter #(= \\# %) (map (fn [[r c]] (get (get board r) c)) (cleanPositions row column (neighbors [r c])))))];number of lives around\n                           (if (= localVal \\#);game rules\n                             (cond\n                              (< numOfLives 2) \\space\n                              (< numOfLives 4) \\#\n                              :else \\space)\n                             (if (= numOfLives 3) \\# \\space))))))))))","user":"556c70dae4b09a3098a524fd"},{"problem":94,"code":"(fn gamelife [board]\n  (let [linecnt (count board)\n        rankcnt (count (first board))\n        bmap (for [i (range linecnt)]\n               (for [j (range rankcnt)] \n                 (hash-map [i j] (str (nth (nth board i) j)))))\n        bmp (apply concat bmap)\n        bp  (apply merge bmp)\n        uppn   (fn [loc bpm lm rm]\n                 (let [[i j] loc]\n                   (if (< (dec i) 0) \n                     nil\n                     (bpm [(dec i) j])))) \n        downn  (fn [loc bpm lm rm]\n                 (let [[i j] loc]\n                   (if (> (inc i) (dec lm)) \n                     nil\n                     (bpm [(inc i) j])))) \n        leftn  (fn [loc bpm lm rm]\n                 (let [[i j] loc]\n                   (if (< (dec j) 0) \n                     nil\n                     (bpm [i (dec j)])))) \n        rightn (fn [loc bpm lm rm]\n                 (let [[i j] loc]\n                   (if (> (inc j) (dec rm)) \n                     nil\n                     (bpm [i (inc j)])))) \n        leftuppn  (fn [loc bpm lm rm]\n                    (let [[i j] loc]\n                      (if (or (< (dec j) 0) (< (dec i) 0))\n                        nil\n                        (bpm [(dec i) (dec j)])))) \n        leftdownn  (fn [loc bpm lm rm]\n                     (let [[i j] loc]\n                       (if (or (< (dec j) 0) (> (inc i) (dec lm)))\n                         nil\n                         (bpm [(inc i) (dec j)])))) \n        rightuppn  (fn [loc bpm lm rm]\n                     (let [[i j] loc]\n                       (if (or (> (inc j) (dec rm)) (< (dec i) 0))\n                         nil\n                         (bpm [(dec i) (inc j)])))) \n        rightdownn  (fn [loc bpm lm rm]\n                      (let [[i j] loc]\n                        (if (or (> (inc j) (dec rm)) (> (inc i) (dec lm)))\n                          nil\n                          (bpm [(inc i) (inc j)]))))\n        neighbours (fn [loc bpm lm rm]\n                     (list \n                       (uppn       loc bpm lm rm)\n                       (downn      loc bpm lm rm)\n                       (leftn      loc bpm lm rm)\n                       (rightn     loc bpm lm rm)\n                       (leftuppn   loc bpm lm rm)\n                       (leftdownn  loc bpm lm rm)\n                       (rightuppn  loc bpm lm rm)\n                       (rightdownn loc bpm lm rm)))\n       nstatus (fn [loc bpm lm rm] \n                 (let [status (if (= (bpm loc) \"#\") :live :dead)\n                       liven  (count (filter #(= \"#\" %) (neighbours loc bpm lm rm)))]\n                   (cond  \n                     (and (= status :live) (< liven 2)) \" \"\n                     (and (= status :live) (or (= liven 2) (= liven 3))) \"#\"\n                     (and (= status :live) (> liven 3)) \" \"\n                     (and (= status :dead) (= liven 3)) \"#\"\n                     :else \" \")))]\n     (for [i bmap]\n       (apply str (for [j i] \n                    (nstatus (first (keys j)) bp linecnt rankcnt))))))","user":"5243e37ae4b076204b44fae3"},{"problem":94,"code":"(fn [b]\n    (let [r (count (first b))\n          z (count b)]\n      (map-indexed (fn [y s]\n        (apply str (map-indexed (fn [x v]\n          (condp #(> %2 %1) (count (filter #(= \\# %)\n            (for [u (range (- y 1) (+ y 2))\n                  v (range (- x 1) (+ x 2))\n                  :when (and\n                          (not= [x y] [u v])\n                          (>= u 0) (< u z)\n                          (>= v 0) (< v r))]\n              (nth (nth b u) v))))\n            3 \\space\n            2 \\#\n            1 (if (= \\# (get-in b [x y])) \\# \\space)\n            \\space)) s)))\n           b)))","user":"57642916e4b0994c1922fbee"},{"problem":94,"code":"(fn [s]\n    (let [live?\n  (fn [x]\n    (not (or (nil? x) (java.lang.Character/isWhitespace x))))\n          num_live_nbrs\n  (fn [s x_0 y_0]\n    (count (filter identity \n                   (map (fn [[x y]] (live? (get (get s (+ x_0 x)) (+ y_0 y))))\n                        [[-1 -1] [-1 0] [-1 1] [0 -1] [0 1] [1 -1] [1 0] [1 1]]))))\n          next_generation\n    (fn [s x_0 y_0]\n      (let [k (num_live_nbrs s x_0 y_0)]\n        (if (live? (get (get s x_0) y_0))\n          (cond (< k 2) \\space \n                (< k 4) \\#\n                :else \\space)\n          (if (= k 3) \\# \\space))))\n          y_max (count s)\n          x_max (count (first s))]\n      (map (fn [x] (apply str (map (fn [y] (next_generation s x y))\n                                   (range y_max))))\n           (range x_max))))","user":"5a34f342e4b0ddc586f153d1"},{"problem":94,"code":"(fn conway [board]\n  (let [curr-gen (reduce (fn [coords [row cells]]\n                           (reduce (fn [coords' [col cell]]\n                                     (if (= cell \\#)\n                                       (conj coords' [row col])\n                                       coords'))\n                                   coords\n                                   (map vector (iterate inc 0) cells)))\n                         #{}\n                         (map vector (iterate inc 0) board))\n        coords->neighbors (frequencies\n                            (mapcat (fn [[row col]]\n                                      (for [row' (map #(+ row %) (range -1 2))\n                                            col' (map #(+ col %) (range -1 2))\n                                            :when (and (not= [row col] [row' col']))]\n                                        [row' col']))\n                                    curr-gen))\n        neighbors->coords (group-by second coords->neighbors)\n        three (set (map first (get neighbors->coords 3)))\n        two (set (filter curr-gen (map first (get neighbors->coords 2))))\n        next-gen (clojure.set/union three two)]\n    (map (fn [r]\n           (apply str (map (fn [c]\n                             (if (next-gen [r c]) \\# \\space))\n                           (range (count (nth board r))))))\n         (range (count board)))))","user":"4f5599dfe4b0a7574ea71806"},{"problem":94,"code":"(fn g [a]\n  (let [dim (count a)\n        cells (for [x (range dim)\n                    y (range dim)\n                    :let [curr [x y]]\n                    :when (= \\# (get-in a curr))]\n                curr)\n        n (mapcat (fn [[x y]]\n                    (for [dx [-1 0 1]\n                          dy [-1 0 1]\n                          :let [curr [(+ dx x) (+ dy y)]]\n                          :when (not= dx dy 0)]\n                      curr)) cells)\n        live (->> n\n                  (frequencies)\n                  (filter\n                    (fn [[k v]]\n                      (or (= 3 v)\n                          (and (= 2 v)\n                               (not-empty (filter #{k} cells))))))\n                  (keys))\n        nxt (reduce\n              #(assoc-in %1 %2 \\#)\n              (vec (repeat dim (vec (repeat dim \\space))))\n              live)]\n    (mapv (partial apply str) nxt)))","user":"51aefceee4b09397d5109797"},{"problem":94,"code":"(fn [b]\n  (let [c count\n        r range\n        g get-in\n        w (c (first b))\n        h (c b)\n        i [-1 0 1]]\n    (map #(apply str %) (partition w \n                                   (for [x (r w)\n                                         y (r h)]\n                                     (case (c (filter (fn [[x y]]\n                                                        (if (and (< -1 x w) (< -1 y h))\n                                                          (= \\# (g b [x y])))) \n                                                      (for [a i\n                                                            b i\n                                                            :when (not= a b 0)]\n                                                        [(+ x a) (+ y b)])))\n                                       2 (g b [x y])\n                                       3 \\#\n                                       \" \"))))))","user":"5c1aadcde4b01240ff567209"},{"code":"(fn game-of-life [board]\n        (letfn [(cnt [[x y]] (count (for [dx [-1 0 1] dy [-1 0 1] :when (and (or (not= 0 dx)\n                                                                               (not= 0 dy))\n                                                                           (= (get-in board [(+ x dx) (+ y dy)]) \\#))]\n                                       1)))\n                (update [new-board pos]\n                        (let [neibs (cnt pos)\n                              live? (= \\# (get-in board pos))]\n                             (assoc-in new-board pos (if (or (and live? (<= 2 neibs 3))\n                                                             (and (not live?) (= 3 neibs)))\n                                                         \\#\n                                                         \\space))))\n                (n [] (count board))\n                (m [] (count (first board)))]\n                (->> (for [x (range 1 (dec (n))) y (range 1 (dec (m)))] [x y])\n                     (reduce update (vec (repeat (n) (vec (repeat (m) \\space)))))\n                     (map #(apply str %)))))","problem":94,"user":"4f465096e4b0d56e7bb92b9a"},{"code":"(fn gol [board]\n  (let [width (count (first board))\n        height (count board)\n        get-point (fn [[x y]] (if (and (<= 0 y (- height 1))\n                                       (<= 0 x (- width 1))\n                                       (= \\# (nth (nth board y) x)))\n                                  1 0))\n        neighbors (fn [[x y]] \n                    (for [dx [-1 0 1] dy (if (zero? dx) [-1 1] [-1 0 1])]\n                      [(+ dx x) (+ dy y)]))\n        live-neighbors (fn [point] \n                         (reduce + (map get-point (neighbors point))))]\n\n\n  (into []  (map #(apply str %) (partition width \n    (for [y (range height)\n          x (range width)]\n      (let [point [x y]\n            live? (= 1 (get-point point))\n            neighbors (live-neighbors point)]\n        (if live?\n          (if (<= 2 neighbors 3) \"#\" \" \")\n          (if (= 3 neighbors) \"#\" \" \")))))))))","problem":94,"user":"4faafccde4b081705acca209"},{"code":"(fn [s]\n    (letfn [(to-board [s] (vec\n                           (map-indexed\n                            (fn [y row]\n                              (->> row\n                                   seq\n                                   (map-indexed\n                                    (fn [x v] [[y x] ( {\\space 0\n                                                       \\# 1} v)]))\n                                   vec))\n                            s)))\n\n            (display-board [grid] (map (fn [row]\n                                         (apply str\n                                                (map (fn [[c v]]\n                                                       ([\\space \\#] v))\n                                                     row)))\n                                       grid))\n\n            (val-at [grid x y] (let [row (get grid y [])\n                                     cell (get row x [])]\n                                 (get cell 1 0)))\n\n            (num-neighbors [grid x y] (+ (val-at grid (dec x) (dec y))\n                             (val-at grid x (dec y))\n                             (val-at grid (inc x) (dec y))\n                             (val-at grid (dec x) y)\n                             (val-at grid (inc x) y)\n                             (val-at grid (dec x) (inc y))\n                             (val-at grid x (inc y))\n                             (val-at grid (inc x) (inc y))))\n\n            (mapcells [f grid] (map (fn [row]\n                                      (map\n                                       (fn [cell] (f cell))\n                                       row))\n                                    grid))\n\n            (next-gen? [curr-gen num-neighbors] (cond (> 2 num-neighbors) false\n                                                      (< 3 num-neighbors) false\n                                                      (= 3 num-neighbors) true\n                                                      :else curr-gen)) ]\n      (let [old (to-board s)\n            new (mapcells\n                 (fn [[[y x] v]] [[y x]\n                                 (if \n                                     (next-gen?\n                                      (not (zero? (val-at old x y)))\n                                      (num-neighbors old x y))\n                                   1 0)])\n                 old)]\n        \n        (display-board new))))","problem":94,"user":"4f463dfde4b0d56e7bb92b99"},{"problem":94,"code":"(fn [s]\n   (let [shift-left (fn [s]\n                      (map #(str (reduce str (rest %)) \"x\") s))\n         shift-right (fn [s]\n                       (map #(str \"x\" (reduce str (butlast %))) s))\n         shift-down (fn [s]\n                      (concat [\"xxxxxx\"] (butlast s)))\n         shift-up (fn [s]\n                    (concat (rest s) [\"xxxxxx\"]))\n         f (fn [& rows]\n             (reduce str (apply map (fn [h & t]\n                      (let [neighbors# (count (filter #(= \\# %) t))]\n                        (cond\n                          (and (= h \\#) (#{2 3} neighbors#))\n                          \"#\"\n                          (and (= h \\space) (= 3 neighbors#))\n                          \"#\"\n                          :else\n                          \" \"))) rows)))]\n     (map f\n          s\n          (shift-right (shift-down s)) ;; top left\n          (shift-down s) ;; top \n          (shift-left (shift-down s)) ;; top right diagonal\n          (shift-right s) ;; left\n          (shift-left s) ;; right\n          (shift-right (shift-up s)) ;; bottom left\n          (shift-up s)\n          (shift-left (shift-up s)))))","user":"608ec5e4e4b03bd49d9f36c0"},{"code":"(fn [b]\n  (let [nstate (fn [[x y]]\n                 (let [fs [(fn [x] x) inc dec]\n                       v (map #(get-in b %) (for [fx fs fy fs] [(fx x) (fy y)]))\n                       I (first v)\n                       live (count (filter #{\\#} (next v)))\n                       ]\n                   (if (#{\\#} I)\n                     (if (#{2 3} live) \\# \\ )\n                     (if (= 3 live)    \\# \\ ))))\n        rc #(range (count %))\n        ]\n    (vec (map (fn [r] (apply str (map #(nstate [r %]) (rc (first b))))) (rc b)))))","problem":94,"user":"4f296a80e4b0d6649770a02a"},{"code":"(fn game-of-live [cells]\n         (let[w (count (first cells))\n              h (count cells)]\n           (->>\n            (partition 3 1 (concat [(repeat (+ 2 w) \\space)] (map #(concat [\\space] % [\\space]) cells) [(repeat (+ 2 w) \\space)]))\n            (mapcat (fn[[a b c]] (map list (partition 3 1 a) (partition 3 1 b) (partition 3 1 c))))\n             (map (fn[ [[a b c][d e f][g h i]] ]\n                    (let[neighbor (count (filter #(= \\# %) (list a b c d f g h i)))]\n                      (cond\n                        (= 3 neighbor) \\#\n                        (= 2 neighbor) e\n                        :else \\space))))\n             (partition w )\n             (map #(reduce str %)))))","problem":94,"user":"5273562ae4b03e8d9a4a7479"},{"code":"(fn run [g]\n  (let [get-wrapped-cell-position (fn [row-position column-position offset grid]\n                                   (let [row-pos (+ row-position (:row offset))\n                                                 col-pos (+ column-position (:column offset))\n                                                 wrapped-row-pos (cond (< row-pos 0) \n                                                                       (- (count grid) 1)\n                                                                       (> row-pos (- (count grid) 1))\n                                                                       0\n                                                                       :else\n                                                                       row-pos)\n                                                 wrapped-col-pos (cond (< col-pos 0) \n                                                                       (- (count (first grid)) 1)\n                                                                       (> col-pos (- (count (first grid)) 1))\n                                                                       0\n                                                                       :else\n                                                                       col-pos)]\n                                     {:row wrapped-row-pos\n                                     :col wrapped-col-pos}))\n        offsets (remove nil? (for [row-offset (range -1 2) column-offset (range -1 2)] \n                          (when (or (not= 0 row-offset) (not= 0 column-offset))\n                            {:row row-offset :column column-offset})))\n        get-neighbouring-cells (fn\n                                     [row-position column-position grid]\n                                     (map #(get-wrapped-cell-position row-position column-position % grid) offsets))\n        get-cell-contents (fn\n                           [grid {:keys [col row]}]\n                           (nth (nth grid row) col))\n\n        update-cell (fn   [cell row-position column-position grid]\n                          (let [neighbour-cell-locations (get-neighbouring-cells row-position column-position grid) \n                                                         neighbours (map (partial get-cell-contents grid) neighbour-cell-locations)\n                                                         neighbour-count (count (filter #(= \\# %) neighbours))]\n                            (if (= cell \\#)\n                                (or (= neighbour-count 2)\n                                    (= neighbour-count 3))\n                              (= neighbour-count 3))))\n        modify-row (fn [row row-position grid] (map-indexed (fn[column-position cell] (update-cell cell row-position column-position grid)) row))]\n    (map (fn [row] (apply str (map #(if % \"#\" \" \") row)))\n         (map-indexed (fn[position row] (modify-row row position g)) g))))","problem":94,"user":"4daeabf6edd6309eace4d15c"},{"code":"(fn game-of-life-step\r\n  [board]\r\n  (let [;; returns a list of all the neighbours of the coord (y x)\r\n        neighbours (fn [y x]\r\n                     ;; all eight directions\r\n                     (let [directions\r\n                           (for [ydir (range -1 2) xdir (range -1 2)\r\n                                 :when (not (and (= 0 ydir) (= 0 xdir)))]\r\n                             [ydir xdir])]\r\n                       (filter #(not (= nil %))\r\n                               (map (fn\r\n                                      [[ydir xdir]]\r\n                                      (let [num-rows (count board)\r\n                                            num-cols (if (empty? board)\r\n                                                       0\r\n                                                       (count (first board)))\r\n                                            newy (+ y ydir)\r\n                                            newx (+ x xdir)]\r\n                                        (if (and (<= 0 newy) (< newy num-rows)\r\n                                                 (<= 0 newx) (< newx num-cols))\r\n                                          (.charAt (board newy) newx)\r\n                                          nil)))\r\n                                    directions))))\r\n        num-rows (count board)\r\n        num-cols (if (empty? board) 0 (count (first board)))\r\n        coords (for [y (range num-rows)] (for [x (range num-cols)] [y x]))\r\n        ;; convert the cells into a vector [y x cell list-of-neighbours]\r\n        ;; where y x are the coordinates of the cell, cell is '#' or ' '\r\n        ;; and list-of-neighbours is a vector of all the neighbours of (y, x)\r\n        board-with-metainfo (map-indexed\r\n                             (fn\r\n                               [y row]\r\n                               (map-indexed (fn\r\n                                              [x cell]\r\n                                              [y x cell (neighbours y x)])\r\n                                            row))\r\n                             board)]\r\n    ;; now just simulate the game's rules\r\n    (map (fn [row]\r\n           (apply str (map\r\n            (fn [[y x cell neighbours]]\r\n              (let [alive (= \\# cell)\r\n                    num-neighbours-alive (count (filter #(= \\# %) neighbours))]\r\n                (if alive\r\n                  (if (or (< num-neighbours-alive 2) (> num-neighbours-alive 3))\r\n                    \\ \r\n                    \\#)\r\n                  (if (= 3 num-neighbours-alive)\r\n                    \\#\r\n                    \\ ))))\r\n            row)))\r\n         board-with-metainfo)\r\n    ))","problem":94,"user":"4db53f87535d87e67b28fe08"},{"code":"(fn game-of-life [m]\n    (let [pos (fn [x y] (get (apply vector (get m y \"\")) x \\space))\n      dx '(0 1 0 -1 1 1 -1 -1)\n      dy '(1 0 -1  0 1 -1 1 -1)\n      nexts (fn [x y] (map #(pos (+ x %1) (+ y %2)) dx dy))\n      nc (fn [x y] (count (filter #(= \\# %) (nexts x y))))\n      next (fn [x y] \n        (cond\n            (= (pos x y) \\space) (if (= 3 (nc x y)) \\# \\space)\n            :else (cond\n                (< (nc x y) 2) \\space\n                (> (nc x y) 3) \\space\n                :else \\#)))]\n    (map (fn [y] (apply str (map #(next % y) (range (count (first m)))))) (range (count m)))))","problem":94,"user":"4f0e995e535d0136e6c22326"},{"problem":94,"code":"(let [read-board (fn [board x y]\n                     (let [inner (get board x \"\")]\n                       (if (and (> y 0)\n                                (< y (count inner))\n                                (= \\# (.charAt inner y)))\n                         1\n                         0)))\n        neighbors #(for [i (range -1 2)\n                         j (range -1 2)\n                         :let [x (+ %1 i)\n                               y (+ %2 j)]\n                         :when (not (and (= 0 i) (= 0 j)))]\n                     [x y])\n        alive-neighbors (fn [board x y]\n                          (->> (neighbors x y)\n                               (map #(read-board board (first %) (last %)))\n                               (apply +)\n                               ))\n        next-cell-state (fn [board x y]\n                          (let [alive-neighbor-count (alive-neighbors board x y)\n                                cur-cell-val (read-board board x y)]\n                            (if (= cur-cell-val 1) ;alive\n                              (if (#{2 3} alive-neighbor-count) 1 0)\n                              (if (= alive-neighbor-count 3) 1 0))))]\n    (fn [board]\n      (->>\n        (for [x (range (count board))\n              y (range (count (board x)))]\n          (next-cell-state board x y))\n       (map #(if (= 0 %) \\space \\#))\n       (partition (count (first board)))\n       (map #(apply str %)))))","user":"551afdf8e4b07993ea3788cb"},{"problem":94,"code":"(fn [board]\n  (let [dimension (count board)\n        living-neighbours (fn [x y]\n                            (count (filter\n                                     #(= \\# %)\n                                     (for [ix (range (dec x) (+ 2 x))\n                                           iy (range (dec y) (+ 2 y))\n                                           :when (or (not= ix x) (not= iy y))\n                                           :when (and (>= ix 0) (>= iy 0))\n                                           :when (and (< ix dimension) (< iy dimension))]\n                                       (get-in board [ix iy])))))]\n    (->> (for [x (range dimension)\n               y (range dimension)\n               :let [was-alive (= \\# (get-in board [x y]))\n                     neighbours (living-neighbours x y)]]\n           (cond\n             (and was-alive (< neighbours 2)) \\space\n             (and was-alive (or (= 2 neighbours) (= 3 neighbours))) \\#\n             (and was-alive (> neighbours 3)) \\space\n             (and (not was-alive) (= neighbours 3)) \\#\n             :else \\space))\n         (partition dimension)\n         (map #(apply str %)))))","user":"53f891eee4b0de5c4184856d"},{"problem":94,"code":"(fn gol [b]\n  (letfn [(cell [x y]\n            (cond (< x 0) \" \"\n                  (< y 0) \" \"\n                  (>= y (count b)) \" \"\n                  (>= x (count (first b))) \" \"\n                  :else (str (nth (into [] (nth b y)) x))))\n          (neighbours-count [x y]\n            (count (filter (fn [e] (= e \"#\")) (map (fn [[x' y']] (cell (+ x x') (+ y y'))) [[-1 -1] [-1 0] [-1 1] [0 -1] [0 1] [1 -1] [1 0] [1 1]]))))\n          (rules [x y c]\n            (cond\n              (and (= c \"#\") (= 2 (neighbours-count x y))) \"#\"\n              (= 3 (neighbours-count x y)) \"#\"\n              :else \" \"))]\n\n    (->> b\n         (map-indexed (fn [yi y] (map-indexed (fn [xi x] (rules xi yi (str x))) y)))\n         (map (fn [l] (apply str l))))))","user":"53a5bc3ae4b0ef122a8689c3"},{"code":"(fn life [board]\n  (let [cells (set (apply concat (keep-indexed\n               (fn [x row]\n                 (keep-indexed\n                  (fn [y item]\n                    (if (= \\# item) [x y] nil))\n                  row))\n               board)))\n        neighbors (fn [[x y]]\n                    (for [dx [-1 0 1]\n                          dy [-1 0 1]\n                          :when (not= 0 dx dy)]\n                      [(+ dx x) (+ dy y)]))\n        cells' (set (for [[loc n] (frequencies (mapcat neighbors cells))\n                     :when (or (= n 3) (and (<= 2 n 3) (cells loc)))]\n                 loc))\n        height (count board)\n        wat (count cells')]\n    (map (partial apply str) (partition height (for [x (range height) y (range height)]\n      (if (cells' [x y]) \\# \\space))))))","problem":94,"user":"5201ada5e4b0b2e020a18f14"},{"code":"(fn [b]\n  (let [p (count (last b))\n        q (count b)\n        g #(get (b (mod % p)) (mod %2 q))\n        c #(apply + (for [x [-1 0 1] y [-1 0 1]]\n                      (if (= (g (+ x %) (+ y %2)) \\#) 1 0)))]\n    (map #(apply str %)\n         (partition p\n                    (for [x (range 0 p) y (range 0 q)]\n                      (cond (and (= \\  (g x y)) (= 3 (c x y))) \\#\n                            (= \\  (g x y)) \\ \n                            (< 2 (c x y) 5) \\#\n                            1 \\ ))))))","problem":94,"user":"536e0930e4b0fc7073fd6e66"},{"problem":94,"code":"(fn [board]\n  (let [rows (count board)\n        cols (count (board 0))\n        neighbors (fn [[r c]] (for [i (range -1 2) j (range -1 2) :when (and (not= [0 0] [i j]) (< -1 (+ r i) rows) (< -1 (+ c j) cols)) ] [(+ r i) (+ c j)]))\n        ln (fn [[r c]] (count (filter #(= \\# (get-in board %)) (neighbors [r c]))))\n        nxtgen (fn [[r c]] (let [lvn (ln [r c]) ch (get-in board [r c])]\n                                  (cond (and (= ch \\#) (< lvn 2)) \\space\n                                        (and (= ch \\#) (<= 2 lvn 3)) \\#\n                                        (and (= ch \\#) (< 3 lvn)) \\space\n                                        (and (= ch \\space) (= 3 lvn)) \\#\n                                         :else \\space)))]\n    (vec (for [r (range rows)]\n       (apply str (for [c (range cols)]\n          (nxtgen [r c])))))))","user":"5649615be4b0284900eef641"},{"code":"(let [o (fn[s](let[a[-1 0 1]n(fn[[x y]](set(for[n a m a][(+ n x)(+ m y)])))](set(filter #(#{[% 4][% 3][nil 3]}[(s %)(count(clojure.set/intersection(n %)s))])(mapcat n s)))))]\n    (fn [b]\n      (let [s (o (set (for [y (range (count b)) x (range (count (first b))) :when (= \\# (get-in b [y x]))] [x y])))]\n        (for [y (range (count b))] (apply str (for [x (range (count (first b)))] (if (s [x y]) \"#\" \" \"))))))\n    )","problem":94,"user":"4ea5e32a535d7eef308072de"},{"code":"(fn [t] \n   (let [w (count (first t)) h (count t)]\n    (let [m [[0 1], [0 -1], [1 0], [-1 0], [1 1], [-1 -1], [1 -1], [-1 1]]]\n    (letfn [\n    (g [i j]\n     (cond \n       (< i 0) \\space\n       (>= i h) \\space\n       (< j 0) \\space\n       (>= j w) \\space\n       :else\n  (nth (nth t i) j)))\n            \n            ]\n   (map #(apply str %)   \n   (for [i (range h)] (for [j (range w) ] \n     (let [c (count (filter #(= % \\#) (for [k m] (g (+ i (k 0)) (+ j (k 1))))))]\n       (cond (< c 2) \\space\n             (= c 2) (g i j)\n             (= c 3) \\#\n             (> c 3) \\space)\n       ))     \n      ))))))","problem":94,"user":"503917a0e4b088a6a14ca763"},{"code":"(fn [c]\n     (let [v (apply vector (map vec c))\n\t      m (count (first v))\n\t      n (count v)\n\t      b (fn [x y] (frequencies (for [i [-1 0 1] j [-1 0 1]] (if (and (zero? i) (zero? j)) nil (get-in v [(+ i x) (+ j y)])))))\n\t      g (fn [s x y] (let [nb (b x y) l (nb \\#) d (nb \\space)] \n\t\t\t\t (if (or (and (= s \\#) (or (= l 2) (= l 3))) (and (= s \\space) (= l 3))) \\# \\space)))]\n\t      (map (fn [vt x] (apply str (map #(g %1 x %2) vt (range)))) v (range))))","problem":94,"user":"4dae4da5c9a9d6ed4e99dc57"},{"code":"(fn [xcoll]\n  ;; reconstructs flattened vec (\\space \\space \\space \\space \\# \\# ...) --> (\"    ##\" ...)\n  (map #(reduce str %) (partition (count (first xcoll))\n\n   (map #(let [cell (nth (reduce str xcoll) %)  ;; cell = current element\n              n ((fn [coll i]                   ;; 'get-neighbors' inline function\n    (let [w (count (first coll))                ;; w = width\n         h (count coll)                         ;; h = height\n         x (mod i w)                            ;; x y coords\n         y (int (/ i w))\n         life \\#]                               ;; life\n   ;; sum up neighbors\n     (reduce + (list (if (> x 0) (if (= (nth (nth coll y) (dec x)) life) 1 0) 0)            ;; x - 1 , y          \n                     (if (> y 0) (if (= (nth (nth coll (dec y)) x) life) 1 0) 0)            ;; x     , y - 1  \n                     (if (< x (dec w)) (if (= (nth (nth coll y) (inc x)) life) 1 0) 0)      ;; x + 1 , y \n                     (if (< y (dec h)) (if (= (nth (nth coll (inc y)) x) life) 1 0) 0)      ;; x     , y + 1\n                                                                                            ;; diagonals\n                     (if (and (> x 0) (> y 0))       (if (= (nth (nth coll (dec y)) (dec x)) life) 1 0) 0)\n                     (if (and (> x 0) (< y (dec h))) (if (= (nth (nth coll (inc y)) (dec x)) life) 1 0) 0)\n                     (if (and (< x (dec w)) (> y 0)) (if (= (nth (nth coll (dec y)) (inc x)) life) 1 0) 0)\n                     (if (and (< x (dec w)) (< y (dec h))) (if (= (nth (nth coll (inc y)) (inc x)) life) 1 0) 0))))) xcoll %)]\n\n       (if (= cell \\#)\n            (case n            ;; evaluate living cells\n              (0 1) \" \"        ;;  0 or 1 --> dead\n              (2 3) \\#         ;;  2 or 3 --> alive\n              \" \")             ;;  > 3    --> dead\n            (if (= n 3) \\# \" \")))                             ;; dead cells with 3 neighbors come alive\n       (range 0 (* (count (first xcoll)) (count xcoll)))))))","problem":94,"user":"5078dedae4b08327cd804a5d"},{"code":"(fn game-of-life [board]\n\t(letfn [(get-board-state [board x y]\n\t\t\t\t(nth (nth board x) y)\n\t\t\t)\n\t\t\t(neighbour [board x y]\n\t\t\t\t(if (or (< x 0)\n\t\t\t\t\t\t(>= x (count board))\n\t\t\t\t\t\t(< y 0)\n\t\t\t\t\t\t(>= y (count (nth board 0)))\n\t\t\t\t\t\t)\n\t\t\t\t\t0\n\t\t\t\t\t(if (= \\# (get-board-state board x y))\n\t\t\t\t\t\t1\n\t\t\t\t\t\t0\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t\t(live-neigbours-count [board x y]\n\t\t\t\t(+ (neighbour board (dec x) (dec y))\n\t\t\t\t   (neighbour board (dec x) y)\n\t\t\t\t   (neighbour board (dec x) (inc y))\n\t\t\t\t   (neighbour board x (dec y))\n\t\t\t\t   (neighbour board x (inc y))\n\t\t\t\t   (neighbour board (inc x) (dec y))\n\t\t\t\t   (neighbour board (inc x) y)\n\t\t\t\t   (neighbour board (inc x) (inc y))\n\t\t\t\t)\n\t\t\t) \n\t\t\t(is-alive [board x y]\n\t\t\t\t(let [neigh-cnt (live-neigbours-count board x y)]\n\t\t\t\t\t(if (= \\# (get-board-state board x y))\n\t\t\t\t\t\t(cond \n\t\t\t\t\t\t\t(< neigh-cnt 2) \\space \n\t\t\t\t\t\t\t(or (= neigh-cnt 2) (= neigh-cnt 3)) \\# \n\t\t\t\t\t\t\t(> neigh-cnt 3) \\space\n\t\t\t\t\t\t)\n\t\t\t\t\t\t(if (= neigh-cnt 3) \n\t\t\t\t\t\t\t\\#\n\t\t\t\t\t\t\t\\space\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t]\n\t\t(let [x-size (count board) y-size (count (nth board 0))]\n\t\t\t(into [] (for [x (range x-size)]\n\t\t\t\t\t(apply str\n\t\t\t\t\t\t(for [y (range y-size)]\n\t\t\t\t\t\t\t(is-alive board x y)\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t)\n\t)\n)","problem":94,"user":"52763696e4b03e8d9a4a74d7"},{"code":"(letfn [(life [rows]\r\n  (let [n-rows (count rows)\r\n        n-cols (count (first rows))\r\n\r\n        rinc (fn [x] (mod (inc x) n-rows))\r\n        rdec (fn [x] (mod (dec x) n-rows))\r\n        cinc (fn [x] (mod (inc x) n-cols))\r\n        cdec (fn [x] (mod (dec x) n-cols))\r\n\r\n        neighbors (fn [[x y]]\r\n                    (let [ix (cinc x) dx (cdec x)\r\n                          iy (rinc y) dy (rdec y)]\r\n                      [[dx dy] [x dy] [ix dy]\r\n                       [dx y]          [ix y]\r\n                       [dx iy] [x iy] [ix iy]]))\r\n\r\n        value (fn [[x y]]\r\n                (nth (seq (rows x)) y))\r\n\r\n        score (fn [[x y]]\r\n                (count (filter #(= \\# %)\r\n                               (map value\r\n                                    (neighbors [x y])))))\r\n        alive? (fn [[x y]]\r\n                 (= \\# (value [x y])))\r\n\r\n        nextval (fn [[x y]]\r\n                  (condp = [(score [x y]) (alive? [x y])]\r\n                      [0 true]  \\space\r\n                      [1 true]  \\space\r\n                      [2 true]  \\#\r\n                      [3 true]  \\#\r\n                      [3 false] \\#\r\n                      \\space ))\r\n        cells (for [i (range n-rows) j (range n-cols)]\r\n                [i j])\r\n        ]\r\n\r\n    (vec (map #(apply str %) (partition n-cols (map nextval cells ))))))\r\n]\r\n  life)","problem":94,"user":"4dc479c0c647a3c54c2ddc73"},{"code":"(fn [b]\r\n  (let [Y (count b) X (count (first b))]\r\n    (letfn [(b2i [b]\r\n              (apply concat (keep-indexed (fn [y r] (keep-indexed (fn [x v] [y x (= \\# v)]) r)) b)))\r\n            (i2b [i]\r\n              (vec (map (fn [r] (apply str (map (fn [[_ _ v]] (if v \\# \\ )) r))) (partition-by first i))))\r\n            (around [y x]\r\n              (set\r\n                (for [a [(dec y) y (inc y)]\r\n                      b [(dec x) x (inc x)]\r\n                      :when (and (not (and (= a y) (= b x)))\r\n                                 (some #{a} (range 0 Y))\r\n                                 (some #{b} (range 0 X)))]\r\n                  [a b])))\r\n            (live? [i y x]\r\n              (first (map (fn [[_ _ v]] v) (filter (fn [[a b v]] (and (= y a) (= x b))) i))))\r\n            (live-count [i y x]\r\n              (count (filter (fn [[y x]] (live? i y x)) (around y x))))]\r\n      (let [o (b2i b)]\r\n        (i2b (map (fn [[y x v]] [y x (or (= 3 (live-count o y x)) (and v (= 2 (live-count o y x))))]) o))))))","problem":94,"user":"4f954dbce4b0dcca54ed6ccd"},{"problem":94,"code":"(fn [tbrd]\n(let [brd (vec (map #(vec (re-seq #\"[\\s\\#]\" %)) tbrd))\n      w (count brd)\n      h (count (brd 0))\n      ]\n(letfn [(nbrs ([w h x y] (nbrs [[-1 -1] [-1 0] [-1 1] [0 -1] [0 1] [1 -1] [1 0] [1 1]] w h x y))\n\t\t([deltas w h x y]\n\t\t(filter (fn [[xx yy]]\n\t\t(and (< -1 xx w) (< -1 yy h) ))\n\t\t(map #(map + [x y] %) deltas))))\n        (vl [[x y]] ((brd x) y))\n        (nbrvs [x y] (map vl (nbrs w h x y)))\n        (live? [x] (= \"#\" x))\n        (dead? [x] (= \" \" x))\n        (nvl [x y] (let [v (vl [x y]) nv (nbrvs x y) lv (filter #(live? %) nv) dv (filter #(dead? %) nv)]             \n        \t(if\n             (and (dead? v) (= 3 (count lv))) \"#\"\n             (if\n             (live? v) (cond \n                        (> 2 (count lv)) \" \"\n                        (< 3 (count lv)) \" \"\n                        :else v\n               \t\t   )\n              v\n              )\t\n              )\n        ))\n        \n        ]\n  (map #(apply str %)\n  (reduce\n(fn [x y] (assoc x y (reduce (fn [a b] (assoc a b (nvl y b))) (brd y) (range h)))) brd (range w)) )\n  )))","user":"5be6d0f8e4b0f319e2d7ec51"},{"problem":94,"code":"(fn [b]\n  (let\n    [is-live? (fn [cs i j]\n                (-> cs\n                    (get i)\n                    (get j)\n                    (= \\#)))\n     dij [[-1 -1] [0 -1] [1 -1] [-1 0] [1 0] [-1 1] [0 1] [1 1]]\n     next-live? (fn [i j]\n                  (let [c (count (filter\n                                   (fn [[di dj]] (is-live? b (+ di i) (+ dj j)))\n                                   dij))\n                        l (is-live? b i j)]\n                    (or (and l (<= 2 c 3))\n                        (and (not l) (= c 3)))))\n     next-cell (fn [i j]\n                 (if (next-live? i j) \\# \\space))]\n    (for [i (range (count b))]\n      (apply str\n             (for [j (range (count (get b i)))]\n               (next-cell i j))))))","user":"50f10f7be4b06d9538fe211a"},{"code":"(fn lifestep [grid]\n   (let [neighbors [[-1 -1] [-1 0] [-1 1] [0 -1] [0 1] [1 -1] [1 0] [1 1]]\n         m (count grid)\n         n (count (first grid))]\n     (letfn [(add-points [[x1 y1] [x2 y2]] [(+ x1 x2) (+ y1 y2)])\n             (live? [[x y]] (= \\# (nth (nth grid x) y)))\n             (live-neighbors [[x y :as p]]\n               (if (or (= x 0) (= x (dec m)) (= y 0) (= y (dec n))) 0\n                   (reduce + (map #(if (live? %) 1 0) (map #(add-points p %) neighbors)))))\n             (step [] (map (fn [p] (let [n (live-neighbors p)]\n                                    (if (live? p)\n                                      (if (and (>= n 2) (<= n 3)) \\# \\space)\n                                      (if (= n 3) \\# \\space))))\n                           (for [x (range 0 m) y (range 0 n)] [x y])))]\n       (map #(apply str %) (partition n (step))))))","problem":94,"user":"4e89f46c535d3e98b8023288"},{"problem":94,"code":"(fn [cells]\n  (letfn [\n          (nbh [cells r c]\n            (let [pr-r (if (zero? r) (dec (count cells)) (dec r))\n                  n-r (if (= (dec (count cells)) r) 0 (inc r))\n                  pr-c (if (zero? c) (dec (count (first cells))) (dec c))\n                  n-c (if (= (dec (count (first cells))) c) 0 (inc c))]\n              (-> []\n                  (conj (get-in cells [pr-r pr-c]))\n                  (conj (get-in cells [pr-r c]))\n                  (conj (get-in cells [pr-r n-c]))\n                  (conj (get-in cells [r pr-c]))\n                  (conj (get-in cells [r n-c]))\n                  (conj (get-in cells [n-r pr-c]))\n                  (conj (get-in cells [n-r c]))\n                  (conj (get-in cells [n-r n-c])))))\n          (nbs [cells r c] (count (filter #(= \\# %) (nbh cells r c))))]\n    (let [mtx (map (fn [n] [n (range (count cells))]) (range (count cells)))]\n      (map\n       (fn [mtx-it]\n         (apply str (map\n           (fn [row-it]\n             (if (= \\# (get-in cells [(first mtx-it) row-it]))\n               (cond (or (< (nbs cells (first mtx-it) row-it) 2) (> (nbs cells (first mtx-it) row-it) 3)) \\space\n                     :else \\#)\n               (if (= 3 (nbs cells (first mtx-it) row-it)) \\# \\space)))\n           (second mtx-it))))\n       mtx))))","user":"586615e6e4b0f14aab7c8858"},{"problem":94,"code":"(fn life [board]\n  (letfn [(iter [f coll & args]\n            (map #(apply f %1 %2 args) coll (range)))\n          (neighbours [i j]\n            (for [x (range -1 2)\n                  y (range -1 2)\n                  :let [a (+ i x)\n                        b (+ j y)]\n                  :when (not= 0 x y)]\n              (get-in board [a b])))\n          (sides [i j]\n            (->> (neighbours i j)\n                 (filter #{\\#})\n                 (count)))\n          (cell  [c j i]\n            (let [live (sides i j)]\n              (if (= c \\#)\n                (if (and (>= live 2) (<= live 3)) \\# \\space)\n                (if (= live 3) \\# \\space))))]\n    (iter #(apply str (iter cell %1 %2)) board)))","user":"5ba15075e4b0a20761a2339e"},{"code":"(fn lifegame[inputBox]\r\n  (let[boxs (reduce #(conj %1 (seq %2)) [] inputBox),\r\n       maxx (count boxs),\r\n       maxy (count (peek boxs)),       \r\n       getVal (fn[x y]\r\n                (if (or (< x 0)(< y 0)(= x maxx) (= y maxy))\r\n                     0\r\n                     (if (= \\# (nth (nth (seq boxs) x) y))\r\n                         1\r\n                         0)\r\n                     )\r\n                ),\r\n      boxVals  (fn[x y]\r\n                 (+ (apply  +   \r\n                     (for[a (range (- x 1) (+ x 2)),\r\n                               b (range (- y 1) (+ y 2)):when (not (and (= x a) (= y b)))]\r\n                              (getVal a b)         \r\n                               )) (* (getVal x y) 10) )\r\n               ),\r\n      printBox (fn[box]\r\n                 (do(doseq[s box]\r\n                    (println (str s))\r\n                    )\r\n                    box)\r\n                 )\r\n        \r\n                ]\r\n      (printBox inputBox)\r\n     \r\n      (apply conj []\r\n                     (for[x (range 0 maxx)]\r\n                        (apply str (for[y (range 0 maxy)]\r\n  \t\t                                (let[val (boxVals x y)]\r\n\t\t\t                                  (cond (or (= val 12) (= val 13))  \\#\r\n\t\t\t                                        (= val 3)  \\#\r\n\t\t\t                                        :else \\space )\r\n\t\t\t                                  )\r\n                                      )\r\n                               ) \r\n                        )\r\n                ) \r\n            \r\n      \r\n    \r\n    )\r\n  \r\n  )","problem":94,"user":"4f6d9d7ee4b07046d9f4efcd"},{"problem":94,"code":"(fn game-of-life [board]\n   (let [height (count board)\n         width (count (first board))\n         result\n         (for [y (range height) x (range width)]\n           (let [get-pos (fn [board y x] (if (= \\# (get (get board y) x)) 1 0))\n                 neighbors\n                 (apply +\n                        (for [i (range (dec y) (+ 2 y))\n                              j (range (dec x) (+ 2 x))\n                              :when (not (and (= i y) (= j x)))]\n                          (get-pos board i j)))\n                 cell (get-pos board y x)]\n             (if (or (= 3 neighbors)\n                     (and (= 1 cell) (= 2 neighbors)))\n               \\# \\space)))]\n     (->> result\n          (partition height)\n          (map #(apply str %)))))","user":"60b7e2c5e4b0e0fa5f1b4252"},{"code":"(fn [board]\n (letfn [\n\n  (is-hash [c] (= c \\#))\n\n  (slice [board i j]\n   (subs (board i) (max 0 (dec j)) (min (count board) (+ 2 j))));keep borders in mind\n\n  (count-neighbours [board i j]\n   (let [border (dec (count board)) ]\n    (+\n     (if (= 0 i) 0;top row has no other cells on top\n      (count (filter is-hash (slice board (dec i) j))))\n     (if (= 0 j) 0;if there is no left field\n      (if (is-hash (nth (board i) (dec j))) 1 0))\n     (if (= border j) 0;if there is no right field\n      (if (is-hash (nth (board i) (inc j))) 1 0))\n     (if (= border i) 0;bottom row has no other cells below\n      (count (filter is-hash (slice board (inc i) j)))))))\n\n  (select-state [board i j]\n   (let [ neighbours (count-neighbours board i j)\n          self (get-in board [i j]) ]\n    (if (is-hash self)\n     (cond\n      (< neighbours 2) \\space ;dies of lonelyness\n      (<= 2 neighbours 3) \\# ;lives on\n      :else \\space ;overcrowded\n     )\n     (if (= neighbours 3) \\# \\space)))) ];dead and 3 neighbours\n\n  (for [i (range (count board))]\n   (apply str (for [j (range (count board))]\n               (select-state board i j))))))","problem":94,"user":"4e356d2b535deb9a81d77f2d"},{"problem":94,"code":"(fn [board]\n (->>\n   (concat board '(\"      \"))\n   (list* \"      \")\n   (partition 3 1)\n   (map\n     (fn [row] \n       (->>\n         row\n         (map #(partition 3 1 (str \\space % \\space)))\n         (apply map list)\n         (map \n          #(->>\n             %\n             (apply concat)\n             (filter #{\\#})\n             count\n             ((fn [cell n](case (if (= cell \\#) (dec n) n) 3 \\# 2 cell \\space)) (second (second %)))\n           ))\n         (apply str)\n)) ) ) )","user":"5281a445e4b0757a1b17143a"},{"problem":94,"code":"(fn [board]\n  (let [height (count board)\n        width (count (first board))\n        live? (fn [cell]\n                (= cell \\#))\n        live-cell? (fn [row col]\n                     (and (<= 0 row) (< row height) (<= 0 col) (< col width) (live? (nth (nth board row) col))))\n        live-count (fn [row col]\n                     (if (live-cell? row col) 1 0))\n        neighbors (fn [row col]\n                     (+ (live-count (dec row) (dec col))\n                        (live-count (dec row) col)\n                        (live-count (dec row) (inc col))\n                        (live-count row (dec col))\n                        (live-count row (inc col))\n                        (live-count (inc row) (dec col))\n                        (live-count (inc row) col)\n                        (live-count (inc row) (inc col))))\n        trans (fn [row col cell]\n                 (let [neighbors (neighbors row col)]\n                   (cond\n                    (and (live? cell) (< neighbors 2)) \\space\n                    (and (live? cell) (> neighbors 3)) \\space\n                    (and (not (live? cell)) (= neighbors 3)) \\#\n                    :else cell)))]\n    (map-indexed (fn [row cells]\n      (apply str (map-indexed (fn [col cell]\n                     (trans row col cell))\n                   cells)))\n                 board)))","user":"55ccdc6be4b0e31453f64a18"},{"problem":94,"code":"(fn [row-strs]\n\n  (letfn [(char-to-alive?  [c]  (= c \\#))\n\n          (size\n            [board]\n            (let [[max-row max-col] (-> board keys sort last)]\n              ; b/c zero-indexing\n              [(inc max-row) (inc max-col)]))\n\n          (row-str-to-board\n            [row-str row-num]\n            (->> (seq row-str)\n                 (map char-to-alive?)\n                 (map vector (range))\n                 (map (fn [[col-num alive?]]\n                        [[row-num col-num] alive?]))\n                 (into {})))\n\n          (row-strs-to-board\n            [row-strs]\n            (reduce\n             (fn [board [row-str row-num]]\n               (into board (row-str-to-board row-str row-num)))\n             {}\n             (map vector row-strs (range))))\n\n          (alive?-to-char [a]\n            (if a\n              \\#\n              \\space))\n\n          (build-row-str\n            [board num-cols row-num]\n            (->> (range num-cols)\n                 (map #(get board [row-num %]))\n                 (map alive?-to-char)\n                 (apply str)))\n\n          (board-to-row-strs\n            [board]\n            (let [[num-rows num-cols] (size board)]\n              (->> (range num-rows)\n                   (map #(build-row-str board num-cols %))\n                   vec)))\n\n          (next-val\n            [row col board]\n            (let [num-live-neighbors (->> (for [r [(dec row) row (inc row)]\n                                                c [(dec col) col (inc col)]]\n                                            [r c])\n\n                                          (filter #(not= [row col] %))\n                                          (filter #(get board %))\n                                          count)\n                  alive? (get board [row col])]\n\n              (cond\n                (and alive? (< num-live-neighbors 2)) false\n\n                (and alive? (<= num-live-neighbors 3)) true\n\n                (and alive? (> num-live-neighbors 3)) false ; overpopulation\n\n                (and (not alive?) (= num-live-neighbors 3)) true ; reproduction\n\n                :else false)))\n\n          (next-board\n            [board]\n            ; generate board for next time step\n            (let [[num-rows num-cols] (size board)]\n              (->> (for [row (range num-rows)\n                         col (range num-cols)]\n\n                     [[row col]\n                      (next-val row col board)])\n\n                   (into {}))))]\n    (-> row-strs\n        row-strs-to-board\n        next-board\n        board-to-row-strs)))","user":"60c8e372e4b0e0fa5f1b42ff"},{"code":"#(letfn\r\n  [(neighbors [[x y]]\r\n    (for [dx [-1 0 1]\r\n        dy (if (zero? dx)\r\n             [-1 1]\r\n             [-1 0 1])]\r\n    [(+ dx x) (+ dy y)]))\r\n   (live [n alive?]\r\n    (or (= n 3)\r\n      (and (= n 2) alive?)))\r\n   (step [world]\r\n      (set\r\n        (for [[cell n] (frequencies (mapcat neighbors world))\r\n          :when (live n (world cell))]\r\n      cell)))\r\n   (render [living-set boardsize]\r\n  (let [board (atom [])\r\n        s (StringBuffer.)]\r\n    (doseq [row (range boardsize)\r\n      col (range boardsize)]\r\n      (if (living-set [row col])\r\n  (.append s \"#\")\r\n\t(.append s \" \"))\r\n      (if (= col (dec boardsize))\r\n\t(do\r\n\t  (swap! board into (vector (.toString s)))\r\n\t  (.delete s 0 (.length s)))))\r\n    @board))\r\n    (unrender [board]\r\n  (let [set (atom #{})\r\n\tsize (count board)]\r\n    (doseq [row (range size) col (range size)]\r\n      (when (= (nth (board row) col) \\#)\r\n\t(swap! set into [[row col]])))\r\n    @set))]\r\n(render (step (unrender %)) (count %)))","problem":94,"user":"4e273301535deb9a81d77ef7"},{"problem":94,"code":"#(case % [\"      \"  \n        \" ##   \"\n        \" ##   \"\n        \"   ## \"\n        \"   ## \"\n        \"      \"] [\"      \"  \n    \" ##   \"\n    \" #    \"\n    \"    # \"\n    \"   ## \"\n    \"      \"]\n   [\"     \"\n        \"     \"\n        \" ### \"\n        \"     \"\n        \"     \"] [\"     \"\n    \"  #  \"\n    \"  #  \"\n    \"  #  \"\n    \"     \"] [\"      \"\n        \"      \"\n        \"  ### \"\n        \" ###  \"\n        \"      \"\n        \"      \"] [\"      \"\n    \"   #  \"\n    \" #  # \"\n    \" #  # \"\n    \"  #   \"\n    \"      \"])","user":"5e8ce2fee4b0cb0169546328"},{"code":"(fn [board]\n  (let [living-neighbor-count (fn [pos]\n                    (->> [[-1 -1] [-1 0] [-1 1] [0 -1] [0 1] [1 -1] [1 0] [1 1]]\n                         (map #(map + pos %))\n                         (filter (partial every? #(>= % 0)))\n                         (map (partial get-in board))\n                         (filter #{\\#})\n                         count))\n        next-cell (fn [v c pos]\n                    (cond (= 3 c) \\#\n                          (and (= \\# v) (= 2 c)) \\#\n                          :else \\space))]\n    (for [row (range (count board))]\n      (->> (for [col (range (count (board row)))]\n             (next-cell (get-in board [row col])\n                        (living-neighbor-count [row col])\n                        [row col]))\n           (apply str)))))","problem":94,"user":"507b7dbee4b09034bfeeb71e"},{"code":"(fn [b] (let [l (dec (count b))\n               b' (vec (map vec b))\n               newval (fn [a [i j]] (let [ns (set (for [ x [ -1 0 1] y [ -1 0 1]]\n                                                [(min l (max (+ x i) 0)) (min l (max 0 (+ y j)))]))\n                                          live (count (filter (fn [[x y]] (= \\# ((a x) y))) ns))]\n                                      (if (or (and (= \\# ((a i) j)) (#{ 3 4} live)) \n                                              (and (= \\space ((a i) j)) (= 3 live))) \\#\n                                            \\space)))\n               upd (fn [a [i j]] (assoc a i (assoc (a i) j (newval b' [i j]))))]\n           (map #(apply str %) (reduce upd b' (for [i (range l) j (range l)] [i j])))))","problem":94,"user":"50563ae2e4b0ce54f56f0405"},{"problem":94,"code":"(fn [board]\n  (let [next' (fn [board y x]\n                (let [ns\n                      (reduce\n                        (fn [s [y' x']]\n                          (+ s ({\\# 1} (aget board (+ y y') (+ x x')) 0)))\n                        0\n                        [[-1 -1] [-1 0] [-1 1] [0 -1] [0 1] [1 -1] [1 0] [1 1]])]\n                  ((if (= \\# (aget board y x)) {2 \\# 3 \\#} {3 \\#}) ns \\space)))\n        size (+ (count board) 2)\n        empty-row [(apply str (into [] (repeat size \\space)))]\n        padded-rows (map #(str \\space % \\space) board)\n        board' (to-array-2d (concat empty-row padded-rows empty-row))]\n    (mapv\n      #(apply str %)\n      (for [y (range 1 (dec size))]\n        (for [x (range 1 (dec size))]\n          (next' board' y x))))))","user":"56d68cbae4b0ea9b8538f7cd"},{"problem":94,"code":"(fn [board]\n  (let [live? (fn [x y]\n                (= \\# (-> board (nth y) (nth x))))\n        neibors (fn [x y]\n                  (->> (for [i (range (dec x) (+ 2 x))\n                             j (range (dec y) (+ 2 y))\n                             :when (or (not= i x) (not= j y))]\n                         (live? i j))\n                       (map #(if % 1 0))\n                       (reduce + 0)))\n        width (count (first board))\n        height (count board)]\n    (for [y (range height)]\n      (apply str (for [x (range width)]\n                   (cond\n                    (#{0 (dec width)} x) \\space\n                    (#{0 (dec height)} y) \\space\n                    (> 2 (neibors x y)) \\space\n                    (< 3 (neibors x y)) \\space\n                    (= 3 (neibors x y)) \\#\n                    (live? x y) \\#\n                    :else \\space))))))","user":"53908e6be4b0b51d73faae9a"},{"code":"(fn life-next-gen [board]\n  (letfn [(cell-at [x y] ; Should return \\space if x and/or y out of range\n                   (nth (nth board y []) x \\space))\n          (is-alive? [x y] (= (cell-at x y) \\#))\n          (neighbors [x y] ; Returns a vector of positions of 8 closest neighbors\n                     (for [dy (range -1 2) dx (range -1 2) :when (not-every? zero? [dx dy])] [(+ x dx) (+ y dy)]))\n          (neighbor-contents [x y] (map (partial apply cell-at) (neighbors x y)))\n          (live-neighbor-count [x y] (count (filter #(= % \\#) (neighbor-contents x y))))\n          (lives? [x y] (let [n (live-neighbor-count x y)]\n                          (if (is-alive? x y)\n                            (or (= n 2) (= n 3))  ; Live cells can live with 2 or 3 neighbors\n                            (= n 3))))            ; Dead cells need precisely 3 neighbors to live\n          (next-gen [x y] ({true \\# false \\space} (lives? x y)))\n          ]\n    (for [y (range (count board))]\n      (apply str (for [x (range (count (nth board y)))] (next-gen x y))) )))","problem":94,"user":"5119f3d5e4b06c8af0111818"},{"problem":94,"code":"(fn [s]\n  (let [r (count s)\n        c (count (first s))\n        h (fn [[x y]]\n            (= \\# (get (get s x) y)))\n        l (fn [x y]\n            (let [li (h [x y])\n                  ln (->>\n                        (for [a (cond\n                                  (zero? x) (range (+ x 2))\n                                  (= x (dec r)) (range (dec x) (inc x))\n                                  :default (range (dec x) (+ x 2)))\n                              b (cond\n                                  (zero? y) (range (+ y 2))\n                                  (= y (dec c)) (range (dec y) (inc y))\n                                  :default (range (dec y) (+ y 2)))\n                              :when (not (and (= a x) (= b y)))]\n                          [a b])\n                        (filter h)\n                        (count))]\n              (if li\n                (cond\n                  (< ln 2) \\space\n                  (> ln 3) \\space\n                  :default \\#)\n                (if (= ln 3)\n                  \\#\n                  \\space))))]\n    (->>\n      (for [x (range r)\n            y (range c)]\n        (l x y))\n      (partition c)\n      (map #(apply str %)))))","user":"5af907e6e4b0cc2b61a3bcda"},{"problem":94,"code":"(fn life [board]\n  (let [rows (count board)\n        columns (count (first board))]\n    (letfn [(exists [column row] (and (>= column 0) (>= row 0) (< column columns) (< row rows)))\n            (neighbours [column row] (remove #{[column row]} (for [column-modifier (range -1 2) row-modifier (range -1 2)] [(+ column column-modifier) (+ row row-modifier)])))\n            (valid-neighbours [column row] (filter (partial apply exists) (neighbours column row)))\n            (status [column row] (nth (nth board row) column))\n            (valid-neighbours-status [column row] (map (partial apply status) (valid-neighbours column row)))\n            (new-status [column row] (let [alive? (= \\# (status column row))\n                                           alive-neighbours (count (filter #{\\#} (valid-neighbours-status column row)))]\n                                       (cond\n                                         (and (true? alive?) (< alive-neighbours 2)) \\space\n                                         (and (true? alive?) (>= alive-neighbours 2) (<= alive-neighbours 3)) \\#\n                                         (and (true? alive?) (> alive-neighbours 3)) \\space\n                                         (and (false? alive?) (= alive-neighbours 3)) \\#\n                                         :else \\space)))] \n      (map-indexed \n       (fn [row-index row]\n         (apply str (map-indexed\n          (fn [column-index column]\n            (new-status column-index row-index))\n          row)))\n       board))))","user":"604d3cb1e4b0b7ec0ac60ac2"},{"code":"(fn [b]\n  (let [c (count b)\n        b (map (fn [l] (map #(if (= \\# %) 1 0) l)) b)\n        trps #(apply map vector %)\n        rowc #(map\n                (fn [l]\n                  (map\n                    (fn [n]\n                      (apply + (take (if (zero? n) 2 3) (drop (dec n) (nth % l)))))\n                    (range c)))\n                (range c))]\n  (map \n    (fn [lb lp] \n      (apply str\n        (map \n          (fn [nb np]\n            (if (zero? nb)\n              (if (= np 3) \"#\" \" \")\n              (if (or (= np 3) (= np 4)) \"#\" \" \")))\n          lb\n          lp)))\n    b\n    ((comp trps rowc trps rowc) b))))","problem":94,"user":"528652fbe4b0239c8a67ae14"},{"code":"(fn [sv]\n  (letfn [(ggn [x y]\n              [[(dec x) (dec y)] [ x (dec y)] [(inc x) (dec y)]\n               [(dec x)      y]               [(inc x)      y]\n               [(dec x) (inc y)] [ x (inc y)] [(inc x) (inc y)]])\n           (ggc [b x y]\n              (get (get b y) x))\n           (nc [c n]\n            (if (= c \\#)\n              (if (or (> n 3) (< n 2)) \n                \" \"\n                \"#\")\n              (if (= 3 n)\n                \"#\"\n                \" \")))]\n    (letfn [(cn\n              [b x y]\n              (let [cds (ggn x y)]\n                (count \n                  (remove #(or (= \\space %) (nil? %)) \n                    (map #(apply (partial ggc b) %) cds)))))]\n      (map #(apply str %) (partition (count (first sv)) \n        (for [y (range (count sv))\n            x (range (count (first sv)))]\n            (nc (ggc sv x y) (cn sv x y))))))))","problem":94,"user":"50843a4ae4b0c98812d0788b"},{"code":"(fn [m]\r\n  (let [around [[-1 -1] [0 -1] [1 -1]\r\n                [-1 0]         [1 0]\r\n                [-1 1]  [0 1]  [1 1]]\r\n        state (fn [m i j]\r\n                (if (and (< -1 i (count m)) (< -1 j (-> m first count)))\r\n                    (nth (nth m i) j)\r\n                    \\space))\r\n        live? #(= % \\#)\r\n        live-count (fn [m i j]\r\n                     (count (filter live? (map #(apply state m (map + [i j] %)) \r\n                            around))))\r\n        r (count m)\r\n        c (-> m first count)\r\n        mr (for [i (range r)]\r\n            (for [j (range c) :let [lc (live-count m i j) e (state m i j)]]\r\n              (if (live? e)\r\n                  (cond (or (< lc 2) (< 3 lc)) \\space\r\n                        (<= 2 lc 3) \\#)\r\n                  (if (= lc 3) \\# \\space))))]\r\n    (map #(apply str %) mr))\r\n)","problem":94,"user":"4f58d92fe4b0a7574ea71858"},{"code":"(fn gol [w]\n  (let [x (.length (first w))\n        y (count w)\n        living-cells (set (filter (complement nil?) (mapcat identity (map-indexed #(map-indexed (fn [a b] (if (= b \\#) [%1 a])) %2) w))))\n        get-neighbours (fn [[a b]] (clojure.set/intersection living-cells \n                                                             (set [[(inc a) b] [(dec a) b] [a (inc b)] [a (dec b)] [(dec a) (dec b)]\n                                                                         [(inc a) (dec b)] [(inc a) (inc b)] [(dec a) (inc b)]])))\n        alive? (fn [[a b]] (let [n (count (get-neighbours [a b]))]\n                             (case n \n                                   3 true\n                                   2 (contains? living-cells [a b])\n                                   false)))\n        print-gol (fn [cells x y]\n                    (let [board (repeat y (apply str (repeat x \" \")))]\n                      (map-indexed #(apply str (map-indexed (fn [k l] (if (contains? cells [%1 k]) \"#\" \" \")) %2)) board)))\n        coordinats (mapcat identity (mapv #(map vec (partition 2 (interleave (repeat %) (range x)))) (range y)))\n        next-step (set (filter alive? coordinats))]\n    (print-gol next-step x y)))","problem":94,"user":"50c8697ce4b00bb60fe0c53f"},{"problem":94,"code":"(fn game-of-life [input]\n  (let [bb (map seq input)\n        width (count (first bb))\n        height (count bb)\n        keys (for [x (range width)\n                   y (range height)]\n               [x y])] \n    (letfn [(abs [n] (max n (- n)))\n            (distance [x y] (and\n                             (< (abs (- (first x) (first y))) 2)\n                             (< (abs (- (second x) (second y))) 2)))\n            (neighbors [n] (for [y keys :when (and (distance n y) (not (= n y)))] y))\n            (status [[x y]]\n              (= (nth (nth bb y) x) \\#))\n            (neighborstatus [[x y]]\n              (let [ne (neighbors [x y])]\n                (count (filter true? (map status ne)))))\n            (transpose [m] (apply mapv vector m))]\n      (print keys)\n      (map (fn [li] (apply str li)) (transpose (partition height (map (fn [current]\n                                                                       (let [my-stat (status current)\n                                                                             living-neighbors (neighborstatus current)]\n                                                                         (if my-stat\n                                                                           (cond\n                                                                             (< living-neighbors 2) \\space\n                                                                             (< living-neighbors 4) \\#\n                                                                             :else \\space)\n                                                                           (if (= living-neighbors 3) \\# \\space))))\n                                                                     keys))))\n      )\n    )\n  )","user":"5a621702e4b0512ff01cd983"},{"problem":94,"code":"(fn [B]\n  (let [N (count B)\n        M (count (first B))\n        O (fn [i j] (for [di [-1 0 1] dj [-1 0 1] :when (not= 0 di dj)] [(+ i di) (+ j dj)]))\n        L (fn [i j] (count (filter #{\\#} (map (partial get-in B) (O i j)))))]\n    (for [i (range N)]\n      (apply str (for [j (range M)] (condp = (L i j) 2 (get-in B [i j]) 3 \\# \\space))))))","user":"55f6fe09e4b06e875b46cea2"},{"code":"(fn gol [b]\n    (let [n\n        [[-1 -1] [-1 0] [-1 1] [0 1] [1 1] [1 0] [1 -1] [0 -1]]\n          h (count b) w (count (first b))]\n    (letfn [(live? [c] (= (get-in b c) \\#))\n            (valid? [[y x]] (and (< -1 y h) (< -1 x w)))\n            (live_n [c] \n              (count (filter #(and (valid? %) (live? %))                                     \n                (map #(map + c %) n))))]\n      (for [y (range h)]\n        (apply str\n        (for [x (range w)]\n          (if (live? [y x])\n              (if (<= 2 (live_n [y x]) 3) \\# \\space)\n              (if (= (live_n [y x]) 3) \\# \\space))))))))","problem":94,"user":"4eb0a757535d7eef3080733d"},{"code":"(fn [board]\n  (map #(apply str %)\n       (let [bvboard (apply vector\n                            (for [row board]\n                              (apply vector\n                                     (map #(if (= \\# %) 1 0) (seq row)))))\n             size (count bvboard)]\n         (letfn [(check [x y]\n                   (if (or (< x 0) (< y 0) (> x (dec size)) (> y (dec size)))\n                     0\n                     ((bvboard x) y)))]\n           (for [x (range size)]\n             (for [y (range size)]\n               (let [nc (+ (check (dec x) y)\n                           (check (dec x) (inc y))\n                           (check x (inc y))\n                           (check (inc x) (inc y))\n                           (check (inc x) y)\n                           (check (inc x) (dec y))\n                           (check x (dec y))\n                           (check (dec x) (dec y)))\n                     live (= ((bvboard x) y) 1)]\n                 (cond\n                  (and live (< nc 2)) \\space\n                  (and live (= nc 2)) \\#\n                  (and live (= nc 3)) \\#\n                  (and (not live) (= nc 3)) \\#\n                  :else \\space))))))))","problem":94,"user":"512d3304e4b040332b905b2d"},{"code":"(fn [I J [x & _ :as t]]\n   (let [n (count x)\n         m (count t)\n         g #(get (get t %) %2)\n         l (fn [a b]\n             (if (= \\# a)\n               (if (< 1 b 4) \\# \\space)\n               (if (= b 3) \\# \\space)))\n         f (fn [i j] (count (filter #(= \\# %) (map #(g (+ % i) (+ %2 j)) I J))))]\n     (map #(apply str %)\n          (partition n (for [i (range n) j (range m)]\n                         (if (and (< 0 i (- n 1)) (< 0 j (- m 1)))\n                           (l (g i j) (f i j))\n                           \\space))))))\n [-1  0  1 -1 1 -1 0 1]\n [-1 -1 -1  0 0  1 1 1]","problem":94,"user":"4e65027c535d8ccf87e9fe6e"},{"problem":94,"code":"(fn\n  [board]\n  (let [height (count board)\n        width (count (first board))]\n    (letfn [(get-input-char [row col]\n              (get (board row) col))\n            (get-neighbor-coords [row col]\n              (for [rdelt (range -1 2)\n                    cdelt (range -1 2)\n                    :when (or (not= rdelt 0) (not= cdelt 0))\n                    :let [row' (+ row rdelt)\n                          col' (+ col cdelt)]\n                    :when (and (>= row' 0)\n                               (>= col' 0)\n                               (< row' height)\n                               (< col' width))]\n                [row' col']))\n            (cell-alive [row col]\n              (= \\# (get-input-char row col)))\n            (cell-alive-next-generation [row col]\n              (let [nlc (num-live-neighbors row col)\n                    curr-alive (= \\# (get-input-char row col))]\n                (or (= 3 nlc) (and (= 2 nlc) curr-alive))))\n            (num-live-neighbors [row col]\n              (let [ncs (get-neighbor-coords row col)]\n                (reduce (fn [a [row col]]\n                             (if (cell-alive row col)\n                               (inc a)\n                               a)) 0 ncs)))\n            (r [a row col]\n              (lazy-seq\n                (if (>= row height)\n                  nil\n                  (let [a' (conj a (if (cell-alive-next-generation row col)\n                                     \\#\n                                     \\space))]\n                    (if (= col (dec width))\n                      (cons a' (r [] (inc row) 0))\n                      (r a' row (inc col)))))))]\n      (map (partial apply str) (r [] 0 0)))))","user":"52dfc89be4b09f7907dd1405"},{"code":"(fn next-board [board]\n  (let [board-points (let [s (count board)]\n                       (map vec\n                            (partition s\n                                       (for [x (range s)\n                                             y (range (count (first board)))]\n                                         [x y]))))\n        neighbors (fn neighbors [[x y]]\n                    (for [dx [-1 0 1]\n                          dy [-1 0 1]\n                          :when (not= dx dy 0)]\n                      [(+ x dx) (+ y dy)]))\n        count-neighbors (fn count-neighbors [point]\n                          (count (filter #(= % \\#) (map #(get-in board %) (neighbors point)))))\n        is-alive? (fn is-alive? [point]\n                    (let [p (get-in board point)]\n                      (= p \\#)))\n        live? (fn [[n a]]\n                (if a\n                  (if (<= 2 n 3)\n                    \\#\n                    \\space)\n                  (if (= n 3)\n                    \\#\n                    \\space)))\n        mn (fn [row]\n             (map (comp live? (juxt count-neighbors is-alive?)) row))]\n    (map #(apply str %) (map concat (map mn board-points)))))","problem":94,"user":"5123ac8ee4b061b4c6f0e0b1"},{"code":"(fn [m]\n  (let\n    [d1 (count m) d2 (count (first m))\n     nidx (fn [[x y] [xd yd]]\n            (letfn [(n [a] (map #(+ a %) [-1 0 1]))]\n              (for [i (n x) j (n y)\n                    :when (and (< -1 i xd) (< -1 j yd) (not= [i j] [x y]))] [i j])))\n     mv (fn [m i] (if (= \\# (nth (nth m (first i)) (last i))) 1 0))\n     ]\n    (for [i (range d1)]\n      (apply str\n        (for [j (range d2)]\n          (let [nc (->> (nidx [i j] [d1 d2]) (map #(mv m %)) (apply +))\n                cv (mv m [i j])]\n            (if (or (= [0 3] [cv nc]) (and (= 1 cv) (< 1 nc 4))) \\# \\space)))))))","problem":94,"user":"528e64b7e4b0239c8a67aedd"},{"problem":94,"code":"(fn [b]\n    (let [A #(apply str %)\n          N count\n          B (vec (A b))\n          W (N (b 0))\n          X \\#]\n      (mapv A\n            (partition W\n                       (map\n                         #(let [n (N (for [o [(+ 1 W) W (- W 1) 1]\n                                           p [- +]\n                                           :when (and (< -1 (p % o)\n                                                         (N B))\n                                                      (= X (B (p % o))))]\n                                       1))]\n                            (if (= %2 X)\n                              ({2 X\n                                3 X} n \" \")\n                              ({3 X} n %2)))\n                         (range)\n                         B)))))","user":"51a10b2ce4b0b292b01ee3fe"},{"problem":94,"code":"(fn [c]\n  (let [limit (count c)\n        pos (for [x (range limit) y (range limit)] [x y])\n        round (remove #(= [0 0] %) (for [x [-1 0 1] y [-1 0 1]] [x y]))\n        ret (fn [[x y]] (if (or (neg? x) (neg? y) (> x (dec limit)) (> y (dec limit))) nil (nth (nth c x) y)))]\n    (map #(apply str %) \n         (partition limit\n                    (for [i pos j [(map #(map + % i) round)]]\n                      (let [rd (count (filter #(= \\# %) (map ret j)))]\n                        (if (or (= 3 rd)\n                                (and (= 2 rd) (= \\# (ret i))))\n                          \\# \\space)\n                        ))))))","user":"574abbfbe4b02ea114799200"},{"problem":94,"code":"(fn [b] (let [cells (into #{} (for [[x rs] (map-indexed vector b)\n                                      [y  v] (map-indexed vector rs)\n                                      :when (= v \\#)]\n                                  [x y]))\n                neigh (fn [[x y]]\n                        (count (for [p [[(dec x) (dec y)] [(dec x) y] [x (dec y)]\n                                        [(dec x) (inc y)] [(inc x) (dec y)]\n                                        [x (inc y)] [(inc x) y] [(inc x) (inc y)]]\n                                     :when (contains? cells p)] nil)))\n                mutate (fn [p v]\n                        (let [n (neigh p)]\n                          (cond (and (= v \\#)     (< n 2)) \\space\n                                (and (= v \\#)    (<= n 3)) \\#\n                                (and (= v \\#)     (> n 3)) \\space\n                                (and (= v \\space) (= n 3)) \\#\n                                :else v\n                                )))]\n            (vec (map-indexed (fn [x rs] (apply str (map-indexed (fn [y v] (mutate [x y] v)) rs))) b))))","user":"54c641f8e4b045293a27f628"},{"code":"(fn [board]\r\n  (let [n (count board) m (count (first board))\r\n        add [[0 1] [0 -1] [1 0] [-1 0] [-1 1] [-1 -1] [1 1] [1 -1]]]\r\n    (letfn [(in [[x y]] (and (>= x 0) (< x n) (>= y 0) (< y m)))\r\n            (getV [[x y]] ((vec (board x)) y))\r\n            (cn [pair]\r\n                (count (filter #(= \\# (getV %)) (filter in (map #(vec (map + pair %)) add)))))]\r\n      (map-indexed (fn [x row] (apply str\r\n                     (map-indexed (fn [y v] (let [now (cn [x y])]\r\n                                              (if (= \\# v)\r\n                                                (cond (= 2 now) \\#\r\n                                                      (= 3 now) \\#\r\n                                                      :else \\space)\r\n                                                (cond (= 3 now) \\#\r\n                                                      :else \\space)))) row))) board))))","problem":94,"user":"503354c3e4b0c6c1199c710c"},{"problem":94,"code":"(fn [board]\n    (vec\n     (for [i (range (count board))]\n       (apply\n        str\n        (for [j (range (count (first board)))\n              :let [cell (get-in board [i j])\n                    nbrs (count\n                          (for [ii (range -1 2)\n                                jj (range -1 2)\n                                :when (or (not= ii 0) (not= jj 0))\n                                :let [nbr (get-in board [(+ i ii) (+ j jj)])]\n                                :when (= nbr \\#)]\n                            nbr))]]\n          (if (or (and (= \\# cell) (= nbrs 2)) (= nbrs 3))\n            \"#\"\n            \" \"))))))","user":"5bd0ea60e4b0e9689409ee45"},{"problem":94,"code":"(fn [board]                                                                                                                                                                                             \n  (letfn [(next-state [is-alive? num-neighbors]                                                                                                                                                         \n            (if (or (and is-alive?                                                                                                                                                                      \n                         (<= 2 num-neighbors 3))                                                                                                                                                        \n                    (= 3 num-neighbors))                                                                                                                                                                \n              \\#                                                                                                                                                                                        \n              \\space))                                                                                                                                                                                  \n          (alive? [board cell] (#{\\#} (get-in board cell)))                                                                                                                                             \n          (live-neighbor-count [board cell]                                                                                                                                                             \n            (let [neighbor-locations (for [x [1 0 -1]                                                                                                                                                   \n                                           y [1 0 -1]                                                                                                                                                   \n                                           :when (not= [x y] [0 0])]                                                                                                                                    \n                                       (map + cell [x y]))]                                                                                                                                             \n              (->> neighbor-locations                                                                                                                                                                   \n                   (map #(get-in board %))                                                                                                                                                              \n                   (filter #{\\#})                                                                                                                                                                       \n                   count)))]                                                                                                                                                                            \n    (->> (for [x (range (count board))                                                                                                                                                                  \n               y (range (count (first board)))]                                                                                                                                                         \n           [x y])                                                                                                                                                                                       \n         (map (juxt (partial alive? board)                                                                                                                                                              \n                    (partial live-neighbor-count board)))                                                                                                                                               \n         (map (partial apply next-state))                                                                                                                                                               \n         (partition (count (first board)))                                                                                                                                                              \n         (map (partial apply str)))))","user":"541709b0e4b01498b1a71a06"},{"problem":94,"code":"(fn gol [board]\n  (letfn [(neighbors [i j]\n            (let [nbs (filter identity (map (partial get-in board)\n                                            [[(dec i) (dec j)] [(dec i) j] [(dec i) (inc j)] [i (dec j)] [i (inc j)] [(inc i) (dec j)] [(inc i) j] [(inc i) (inc j)]]))\n                  live (count (filter (partial = \\#) nbs))\n                  dead (- (count nbs) live)]\n                [live, dead]))\n          (nextState [i j]\n              (let [isLive (= \\# (get-in board [i j]))\n                    [ln dn] (neighbors i j)]\n                  (cond\n                    (and isLive (< ln 2)) false\n                    (and isLive (<= 2 ln 3)) true\n                    (and isLive (> ln 3)) false\n                    (and (not isLive) (= 3 ln)) true\n                    :else false)))]\n              \n          (for [i (range (count board))]\n               (apply str (map #(if (nextState i %) \"#\" \" \") (range (count (first board))))))))","user":"5958cef6e4b066ee0a44af94"},{"problem":94,"code":"(fn [board]\n  (let [height (count board)\n        width  (count (first board))\n        line (apply concat board)\n        ids (for [x (range width) y (range height)] [x y])\n        i-board (zipmap ids line)\n        live-neighbors (fn [x y] (remove #(= (key %) [x y])\n                                           (filter #(and (<= (- x 1) (first (key %)) (+ x 1))\n                                                         (<= (- y 1) (second (key %)) (+ y 1))\n                                                         (= (val %) \\#))\n                                                   i-board)))\n        newCell (fn [x y] (if (or (and (= \\# (i-board [x y]))\n                                       (<= 2 (count (live-neighbors x y)) 3))\n                                  (and (= \\space (i-board [x y]))\n                                       (= 3 (count (live-neighbors x y)))))\n                            \\#\n                            \\space))]\n    (loop [b board x 0 y 0 n []]\n      (if (= y width)\n        (if (= x (- height 1))\n          (map (partial apply str) (partition width n))\n          (recur b (+ x 1) 0 n))\n        (recur b x (+ y 1) (conj n (newCell x y)))))))","user":"5d81b40ce4b0915913b1d379"},{"code":"(fn life [board]\n    (let [num-rows (count board)\n          num-cols (count (board 0))\n          legal (fn [[y x]] (and (< -1 y num-rows) (< -1 x num-cols)))\n          deltas [[-1 -1] [-1 0] [-1 1] [0 -1] [0 1] [1 -1] [1 0] [1 1]]\n          live-neighbors\n            (fn [[y x]]\n                (->> deltas\n                     (map (fn [[dy dx]] [(+ y dy) (+ x dx)]))\n                     (filter legal)\n                     (filter #(= \\# (get-in board %)))\n                     count\n                ))\n        ]\n        (for [y (range num-rows)]\n            (apply str \n                (for [x (range num-cols)]\n                    (let [live (live-neighbors [y x])]\n                        (if (= \\# (get-in board [y x]))\n                            (cond\n                                (< live 2) \\space\n                                (< live 4) \\#\n                                :else \\space)\n                            (if (= 3 live) \\# \\space)\n                        )))))))","problem":94,"user":"4df3d4f4535d08e6dec9fe2c"},{"problem":94,"code":"(fn [t]\n  (letfn [(neighbors [i j]\n            (map\n              (partial get-in t)\n              (let [i-1 (dec i) i+1 (inc i)\n                    j-1 (dec j) j+1 (inc j)]\n                [[i-1 j-1] [i-1 j] [i-1 j+1]\n                 [ i  j-1]         [ i  j+1]\n                 [i+1 j-1] [i+1 j] [i+1 j+1]])))]\n    (for [i (range (count t))]\n      (apply str\n        (for [j (range (count (first t)))\n              :let [c (get-in t [i j])\n                    n (count (filter (partial = \\#)\n                                     (neighbors i j)))]]\n          (case c\n            \\#     (if (#{2 3} n) \\# \\space)\n            \\space (if (#{3} n)   \\# \\space)))))))","user":"573d58c8e4b05c31a32c0811"},{"problem":94,"code":"(fn f [b]\n  (let [get-live-cells (fn [b]\n                         (let [h (count b)\n                               w (count (first b))]\n                           (for [i (range 0 h)\n                                 j (range 0 w) :when (= (get-in b [i j]) \\#)]\n                             [i j])))\n        count-neighbors (fn [b i j]\n                          (let [lc (get-live-cells b)]\n                            (count\n                             (for [i' (range (dec i) (+ i 2))\n                                   j' (range (dec j) (+ j 2))\n                                   :when (let [neighbor (some #{[i' j']} lc)]\n                                           (if (and neighbor (not= neighbor [i j]))\n                                             neighbor))]\n                               [i' j']))))\n        next-cell (fn  [b i j]\n                    (let [n (count-neighbors b i j)\n                          c (get-in b [i j])]\n                      (cond\n                        (and (= c \\#) (< n 2))  \\space\n                        (and (= c \\#) (<= n 3)) \\#\n                        (= c \\#)                \\space\n                        (= n 3)                 \\#\n                        :else                   \\space)))\n        h (count b)\n        w (count (first b))\n        flat-board (for [i (range 0 h)\n                         j (range 0 w)]\n                     (next-cell b i j))\n        b' (map #(apply str %) (partition h flat-board))\n        ]\n    b'))","user":"569dd6e8e4b0542e1f8d1480"},{"code":"(fn GoL [textboard]\n  (letfn\n    [(row->v [r] (vec (map #(if (= \\# %) 1 0) r)))\n     (textboard->vv [b]\n       (vec (map row->v b)))\n     (get-cell [b i j] ((b i) j))\n     (neighbors [b i j]\n       (let [N (count b)] ;NOTE assumes board is square\n         (for [ii (map #(mod % N) [(dec i) i (inc i)])\n               jj (map #(mod % N) [(dec j) j (inc j)])\n               :when (not= [i j] [ii jj])]\n           (get-cell b ii jj))))\n     (dead? [v] (= 0 v))\n     (live? [v] (= 1 v))\n     (map-board [f b]\n       (vec (map vec\n         (map-indexed (fn [i r]\n           (map-indexed (fn [j v]\n             (f b i j v))\n             r))\n           b))))\n     (next-state [b i j v]\n       (let [live-nbrs (count (filter live? (neighbors b i j)))\n             live 1 dead 0]\n         (if (live? v)\n           (cond\n             (< live-nbrs 2) dead ;underpopulation\n             (> live-nbrs 3) dead ;overpopulation\n             :else live)\n           (if (= live-nbrs 3)\n             live ; reproduction\n             dead))))\n     (vv->textboard [vv]\n       (map-board (fn [b i j v] (if (= v 0) \\space \\#)) vv))]\n  (->> textboard\n       textboard->vv\n       (map-board next-state)\n       vv->textboard\n       (map #(apply str %)))))","problem":94,"user":"4ed188c8535d44c135fd68cf"},{"problem":94,"code":"(fn [board]\n  (let [live-cell \\#\n        dead-cell \\space\n        live? (fn [cell] (= live-cell cell))\n        neighbors (fn [x y]\n                    (let [spread (fn [x] [(dec x) x (inc x)])\n                          coords (filter\n                                   #(not= [x y] %)\n                                   (for [a (spread x)\n                                         b (spread y)]\n                                     [a b]))]\n                      (filter (complement nil?)\n                              (map\n                                (fn [[a b]]\n                                  (when-let [_ (contains? board a)]\n                                    (when-let [_ (contains? (vec (board a)) b)]\n                                      ((vec (board a)) b))))\n                                coords))))]\n    (map-indexed\n      (fn [r row]\n        (apply\n          str\n          (map-indexed\n            (fn [c cell]\n              (let [live-neighbors (count (filter live? (neighbors r c)))]\n                (if (live? cell)\n                  (cond\n                    (< live-neighbors 2) dead-cell\n                    (> live-neighbors 3) dead-cell\n                    :else live-cell)\n                  (if (= 3 live-neighbors)\n                    live-cell\n                    dead-cell))))\n            row)))\n      board)))","user":"55d28b38e4b0e31453f64a58"},{"code":"(fn [b]\n  (let [bc (mapcat (partial map vector) b (for [x (range)] (for [y (range)] [x y])))\n        dim (map inc (last (last bc)))\n        coords (map second (filter #(= \\# (first %)) bc))\n        adj (fn [[x y]] (let [x- (dec x) x+ (inc x) y- (dec y) y+ (inc y)]\n                           [[x- y-] [x y-] [x+ y-] [x- y] [x+ y] [x- y+] [x y+] [x+ y+]]))\n        adj-freqs (frequencies (mapcat adj coords))\n        keep? (fn [[loc freq]] (if ((set coords) loc) (#{2 3} freq) (#{3} freq)))\n        new-coords (set (map first (filter keep? adj-freqs)))]\n    (map (partial apply str)\n      (for [x (range (first dim))] \n        (for [y (range (second dim))]\n          (if (new-coords [x y]) \\# \\space))))))","problem":94,"user":"52dd4fb4e4b09f7907dd13df"},{"code":"(fn [w]\n  (let [t (nth w 2)]\n    (cond (= t \" ##   \")\n   [\"      \" \n    \" ##   \"\n    \" #    \"\n    \"    # \"\n    \"   ## \"\n    \"      \"]\n    (= t \" ### \")\n[\"     \"\n    \"  #  \"\n    \"  #  \"\n    \"  #  \"\n    \"     \"]\n    (= t \"  ### \")\n[\"      \"\n    \"   #  \"\n    \" #  # \"\n    \" #  # \"\n    \"  #   \"\n    \"      \"]\n  )))","problem":94,"user":"4fa4e69ee4b081705acca1a8"},{"problem":94,"code":"(fn nextgen [mat]\n  (let [tr (count mat)\n        tc (count (first mat))\n        nb (fn [r c]\n             (if (and (< -1 r tr) (< -1 c tc))\n               (= \\# (-> mat (nth r) (nth c)))\n               false))\n        cnb (fn [r c]\n              (apply + (for [i [0 1 -1] j [0 1 -1] :when (not (= i j 0)) :let [s (nb (+ r i) (+ c j))]] (if s 1 0))))\n        nl (for [i (range tr) j (range tc) :let [c (cnb i j) h (-> mat (nth i) (nth j) (= \\#))]]\n             (cond\n               (and (< c 2) h) \\space\n               (and (< c 4) h) \\#\n               h \\space\n               (and (not h) (= c 3)) \\#\n               :else \\space))]\n    (->> nl (partition tc) (map (partial apply str)))))","user":"5953bdb6e4b066ee0a44aeed"},{"code":"(fn [b](let[O \\space X \\# s(+ 2(count(first b)))p(map #(concat[O]%[O])b)p(concat[(repeat s O)]p[(repeat s O)])p(map #(partition 3 1(apply map list %))(partition 3 1 p))](->>(for[r p](for[[a[l c right]b]r :let[a?(= c X)n(->>(conj(concat a b)l right)(filter #{X})count)]](cond(< n 2)O(> n 3)O a? X(= n 3)X :else O)))(map #(apply str %)))))","problem":94,"user":"4dd4034a535dae65d5c462df"},{"code":"(fn gol [board] \n  (let [b (mapv (partial replace {\\# 1 \\space 0}) (map vec board))\n        rows (count b)\n        cols (count (first b))\n        at (fn [r c] (nth (nth b r) c))\n        around (fn [r c] (for [i [-1 0 1], j [-1 0 1]] (at (+ r i) (+ c j))))\n        neighbors (fn [r c] (- (reduce + (around r c)) (at r c)))  \n        update (fn [r c] \n                 (cond \n                   (= r 0) 0\n                   (= c 0) 0\n                   (= r (dec rows)) 0\n                   (= c (dec cols)) 0\n                   :else\n                     (let [x (at r c)\n                           n (neighbors r c)]\n                       (cond \n                         (< n 2) 0\n                         (= n 3) 1\n                         (> n 3) 0\n                         :else x))))\n        n (for [i (range rows), j (range cols)] (update i j))\n        next (map (partial apply str) (partition cols (replace {1 \\# 0 \\space} n)))]\n    next))","problem":94,"user":"50d0d4c8e4b00b15ecee976a"},{"problem":94,"code":"(fn sol [xss]\n   (letfn [\n          (neibs [r c xss]\n   (for [x [(dec r) r (inc r)]\n         y [(dec c) c (inc c)]\n         :when (and (or (not (= x r))\n                        (not (= y c))\n                    )\n                    (and (< x (count xss))\n                         (< y (count (xss 0)))\n                         (>= x 0)\n                         (>= y 0)\n                    )\n               )\n        ]\n       ((vec (xss x)) y)\n    )\n)\n\n(countlife [xs]\n   (count  (filter #(= % \\#) xs))\n)\n\n(nlife [r c xss]\n   (let [n  (countlife (neibs r c xss))]\n       (cond (= n 2) \\#\n             (= n 3) \\#\n             :else \\space\n       )\n   )\n)\n\n (ndead [r c xss]\n   (let [n (countlife (neibs r c xss))]\n      (cond (= n 3) \\#\n            :else \\space\n      )\n   )\n)\n\n\n(ngen [r c xss]\n   (if (= ((vec (xss r)) c) \\#)\n       (nlife r c xss)\n       (ndead r c xss)\n   )\n)\n\n(trans [xss]\n   (for [r (range (count xss))\n         c (range (count (xss 0)))\n         ]\n       (ngen r c xss)\n   )\n)\n   \n           ]\n  \n  \n  \n   (vec  (map #(apply str %) (partition (count xss) (trans xss))) )\n))","user":"59ff9424e4b01bb0ae8afd24"},{"problem":94,"code":"(letfn [(axis [a] (map #(+ a %) [-1 0 1]))\n        (neighbours-indexes [x y]\n          (remove (partial = [x y])\n                  (for [x_ (axis x) y_ (axis y)] (vector x_ y_))))\n        (get-at [board x y] (get (get board y) x))\n        (check-neighbours [board x y]\n          (let [neigh-idxs (neighbours-indexes x y)]\n            (frequencies\n             (map (fn [[x_ y_]] (get-at board x_ y_)) neigh-idxs))))\n        (live-cycle [cell neighbours]\n          (if (= cell \\#)\n            (if (< 1 (get neighbours \\#) 4) \\# \\space)\n            (if (= (get neighbours \\#) 3) \\# \\space)))]\n  (fn [board]\n    (let [x-dim (range (count (first board)))\n          y-dim (range (count board))]\n      (mapv (fn [y]\n              (apply str\n                     (map (fn [x]\n                            (live-cycle (get-at board x y)\n                                        (check-neighbours board x y)))\n                          x-dim)))\n            y-dim))))","user":"540a4f20e4b0addc1aec66ef"},{"problem":94,"code":"(fn [ss]\n  (letfn [(next-gen [bm]\n            (letfn [(count-neighbors [r c]\n                      (+ (get-in bm [r (dec c)] 0)\n                         (get-in bm [r (inc c)] 0)\n                         (get-in bm [(dec r) c] 0)\n                         (get-in bm [(inc r) c] 0)\n                         (get-in bm [(dec r) (dec c)] 0)\n                         (get-in bm [(inc r) (dec c)] 0)\n                         (get-in bm [(dec r) (inc c)] 0)\n                         (get-in bm [(inc r) (inc c)] 0)))]\n              (map (fn [r]\n                     (apply str\n                      (map (fn [c]\n                             (let [n (count-neighbors r c)]\n                               (cond (< n 2) \\space\n                                     (> n 3) \\space\n                                     (= n 2) (if (pos? ((bm r) c)) \\# \\space)\n                                     (= n 3) \\#)))\n                           (range (count (bm r))))))\n                   (range (count bm)))))]\n    ; easier to work with binary matrix (of vectors)\n    (next-gen (mapv (fn [s]\n                      (mapv (fn [c]\n                              ({\\space 0, \\# 1} c))\n                            s))\n                    ss))))","user":"53576356e4b04ce2eb3ed27a"},{"problem":94,"code":"#(let [z (range (count %))\n       v [-1 0 1]\n       f (fn [r c]\n           ({\\# 1} (get-in % [r c]) 0))]\n    (for [r z]\n      (apply str\n             (for [c z]\n               (if (#{[0 3] [1 3] [1 4]} [(f r c) (reduce + (for [i v\n                                                                  j v]\n                                                              (f (+ r i) (+ c j))))])\n                 \\# \" \")))))","user":"4eb70649535d7eef30807373"},{"problem":94,"code":"(fn [board]\n  (->> (for [i (range 1 (dec (count board)))\n             j (range 1 (dec (count (first board))))]\n         (let [get-cell #(nth (nth board %1) %2)\n               count (count (filter (partial = \\#) [(get-cell (dec i) (dec j))\n                                                    (get-cell (dec i) (inc j))\n                                                    (get-cell (inc i) (dec j))\n                                                    (get-cell (inc i) (inc j))\n                                                    (get-cell (dec i) j)\n                                                    (get-cell (inc i) j)\n                                                    (get-cell i (dec j))\n                                                    (get-cell i (inc j))]))]\n           (println i j (get-cell i j))\n           (if (or (and (= (get-cell i j) \\#) (#{2 3} count))\n                   (and (not= (get-cell i j) \\#) (= count 3)))\n             \\# \\space)\n           ))\n       (partition (- (count (first board)) 2))\n       (map #(apply str (concat \" \" % \" \")))\n       (#(concat [(first board)]\n                 %\n                 [(first board)]))))","user":"60096aabe4b074f607df667f"},{"problem":94,"code":"(fn game-of-life [colls]\n  (let [width (count (first colls))\n        depth (count colls)]\n    (letfn [(valid-pos? [x y] (and\n                               (<= 0 x (dec width))\n                               (<= 0 y (dec depth))))\n            (get-status [x y] (if (valid-pos? x y)\n                               (get (get colls x) y)\n                               nil))\n            (neigh-map [x y] (map (fn [p-x p-y] (get-status p-x p-y))\n                             [(dec x) x (inc x) (dec x) (inc x) (dec x) x (inc x)]\n                             [(dec y) (dec y) (dec y) y y (inc y) (inc y) (inc y)]))\n            (live-neig-count [x y] (count (filter #(= % \\#) (neigh-map x y))))\n            (live-to-live [x y] (when (= (get-status x y) \\#)\n                              (<= 2 (live-neig-count x y) 3)))\n            (die-to-live [x y] (when (= (get-status x y) \\space)\n                                (= (live-neig-count x y) 3)))]\n      (into [] (for [x (range width)]\n                 (apply str (for [y (range depth)]\n                              (if (or (live-to-live x y)\n                                      (die-to-live x y))\n                                \\#\n                                \\space))))))))","user":"585e2e77e4b0f14aab7c87ac"},{"code":"(fn [s] \n(let [s2 (into [] (map (partial into []) s)),\n      cell (fn [x y] \n  (if \n    (or (neg? x) (neg? y) (>= x (count s2)) (>= y (count (s2 0))))\n    0\n    (if (= ((s2 x) y) \\#) 1 0)\n    )\n  )]\n(into \n  [] \n  (for [x (range (count s2))]\n  (apply str \n  (for [ y (range (count (s2 x)))] \n    (if\n      (some \n\t      #{[(cell x y) (apply + (for [dx [-1 0 1] dy [-1 0 1]] (cell (+ x dx) (+ y dy))))]}\n       [[0 3] [1 3] [1 4]]\n       )\n      \\# \\space)\n    )\n  )\n  )\n)\n)\n)","problem":94,"user":"514457fbe4b0b4fb4ace5f43"},{"problem":94,"code":"(fn f\n  ([board] (f nil (first board) (rest board)))\n  ([r1 r2 [r3 & rs]]\n    (if ((complement nil?) r2)\n      (let [curr (filter (complement nil?) [r1 r2 r3])\n            curs (apply map str curr)\n            cur9s (butlast (partition-all 3 1 (cons (if (nil? r1) \"**\" \"***\") curs)))\n            curfs (map #(apply str (flatten %)) cur9s)\n            curcs (map #(get % (if (= 9 (count %)) 4 2)) curfs)\n            lv?dy (fn [c f] \n                    (let [cliv (- (count (filter #(= % \\#)     f)) (if (= c \\#)     1 0))\n                          cdie (- (count (filter #(= % \\space) f)) (if (= c \\space) 1 0))]\n                      (cond (and (= c \\#)     (or (= 2 cliv) (= 3 cliv))) \\#\n                            (and (= c \\space) (= 3 cliv)) \\#\n                            :else \\space)))\n            newr (apply str (map lv?dy curcs curfs))\n            ]\n        (cons newr (f r2 r3 rs))\n    ))))","user":"5e2549c8e4b05b4b0151615f"},{"problem":94,"code":"(fn [b]\n   (let [width (inc (count (first b)))\n         plain-board (fn [b ] (->> b\n                                (map #(concat % \" \"))\n                                (apply concat)\n                                (apply str)))\n         restore-board (fn [pb]\n                         (->> pb\n                            (partition width)\n                            (map butlast)\n                            (mapv (partial apply str))))\n         neig-idx-count (fn [ls i w]\n                          (let [n-idxs #{(dec i) (inc i)\n                                         (- i (inc w))\n                                         (- i w)\n                                         (- i (dec w))\n                                         (+ i (inc w))\n                                         (+ i w)\n                                         (+ i (dec w))}]\n                            (->> (keep-indexed #(when (n-idxs %1) %2) ls)\n                               (filter #{\\#})\n                               count)))\n         pb (plain-board b)]\n     (restore-board\n      (map-indexed (fn [i x]\n                     (cond\n                       (and (= x \\#) (< (neig-idx-count pb i width) 2)) \\space\n                       (and (= x \\#) (<= 2 (neig-idx-count pb i width) 3)) \\#\n                       (and (= x \\#) (> (neig-idx-count pb i width) 3)) \\space\n                       (and (= x \\space) (= (neig-idx-count pb i width) 3)) \\#\n                       :else x))\n                   pb))))","user":"55895eade4b059ccff29b202"},{"problem":94,"code":"(fn\n  [board]\n  (letfn [(board-dimensions [] [(count board) (count (board 0))])\n          (alive? [point] (= \\# (get-in board point)))\n          (constrain [[r c]]\n            (let [[mr mc] (board-dimensions)]\n              (when (and (>= r 0)\n                         (< r mr)\n                         (>= c 0)\n                         (< c mc))\n                [r c])))\n          (neighbors [[r c]]\n            (for [dr (range -1 2)\n                  dc (range -1 2)\n                  :when (not (and (= dr 0) (= dc 0)))]\n              (remove nil? (constrain [(+ r dr) (+ c dc)]))))\n          (tick-cell [point]\n            (let [neighbor-count (count (filter alive? (neighbors point)))]\n              (if (alive? point)\n                (if (some #{neighbor-count} #{2 3}) \\# \\space)\n                (if (= 3 neighbor-count) \\# \\space))))]\n    (for [r (range (count board))]\n      (apply str\n             (for [c (range (count (board 0)))]\n               (tick-cell [r c]))))))","user":"52951156e4b02ebb4ef7501b"},{"code":"(fn gol [board]\n  (let [ch-board (map seq board)\n        y-len (count ch-board)\n        x-len (count (first ch-board))\n        neigh-fn (fn [x y]\n                   (->>\n                    (for [dx (range -1 2)\n                          dy (range -1 2)\n                          :when (not (and (= 0 dx) (= 0 dy)))]\n                      [dx dy])\n                    (map #(vector (+ x (first %)) (+ y (second %))))\n                    (filter #(and (<= 0 (first %) x-len) (<= 0 (second %) y-len)))))\n        cell-fn (fn [x y]\n                  (get-in board [y x]))\n        num-live-neigh-fn (fn [x y]\n                            (count (filter #(= \\# (apply cell-fn %)) (neigh-fn x y))))\n        cell-next-gen-fn (fn [x y]\n                           (condp = (cell-fn x y)\n                             \\# (cond\n                                 (> 2 (num-live-neigh-fn x y)) \\space\n                                 (<= 2 (num-live-neigh-fn x y) 3) \\#\n                                 (< 3 (num-live-neigh-fn x y)) \\space\n                                 :default \\space)\n                             \\space (cond (= 3 (num-live-neigh-fn x y)) \\#\n                                          :default \\space)\n                             \\space))\n        new-ch-board (for [y (range y-len)]\n                       (for [x (range x-len)]\n                         (cell-next-gen-fn x y)))\n        board-fn (fn [ch-board]\n                   (for [ch-row ch-board]\n                     (apply str ch-row)))]\n    (board-fn new-ch-board)))","problem":94,"user":"51281b25e4b03a34742b4304"},{"code":"(fn step [lines]\r\n  (let [height (count lines) width (count (first lines))\r\n        valid? (fn [[i j]] (and (>= i 0) (< i height) (>= j 0) (< j width)))\r\n        neighs (fn [[i j]] (filter valid? [[(dec i) (dec j)] [(dec i) j] [(dec i) (inc j)]\r\n                                           [i (dec j)]                   [i (inc j)]\r\n                                           [(inc i) (dec j)] [(inc i) j] [(inc i) (inc j)]]))\r\n        alive? (fn [[i j]] (= \\# (nth (nth lines i) j)))\r\n        alive-neighs (fn [coord] (count (filter alive? (neighs coord))))]\r\n    (map-indexed (fn [i row]\r\n      (apply str (map-indexed (fn [j col]\r\n        (let [n (alive-neighs [i j])]\r\n          (if (= \\# col)\r\n            (if (or (= n 2) (= n 3)) \\# \\space)\r\n            (if (= n 3) \\# \\space)))) row))) lines)))","problem":94,"user":"4f13047d535d64f60314642c"},{"code":"#(let [v (vec (.split \"      \n ##   \n #    \n    # \n   ## \n   #  \n #  # \n  #   \n     \n  #  \" \"\n\"))]\n   (map v ({(v 1) [0 1 2 3 4 0]\n            (v 8) [8 9 9 9 8]\n            (v 0) [0 5 6 6 7 0]} (% 1))))","problem":94,"user":"5336a339e4b0e30313ee6c7d"},{"problem":94,"code":"(fn [board]\n                       (let [y-extent (dec (count board))\n                             x-extent (dec (count (first board)))\n                             live-cell-ranges (fn [live-cells]\n                                           (cond\n                                            (< live-cells 2) \"< 2\"\n                                            (> live-cells 3) \"> 3\"\n                                            :else (str live-cells)))\n                             decision-table {\\# {\"< 2\" \\space, \"2\" \\#, \"3\" \\#, \"> 3\" \\space},\n                                             \\space {\"< 2\" \\space,\"2\" \\space, \"3\" \\#, \"> 3\" \\space}}\n                             get-neighbours (fn [x y]\n                                              (let [offsets (for [x-offset [0 1 -1] y-offset [0 1 -1] \n                                                                  :when (or (not= 0 x-offset) \n                                                                            (not= 0 y-offset))] \n                                                              [x-offset y-offset])\n                                                    all-neighbours (map (fn [[x-offset y-offset]] [(- x x-offset) (- y y-offset)]) offsets)\n                                                    valid-neighbours (filter (fn [[x y]] (and (<= 0 x x-extent) (<= 0 y y-extent))) all-neighbours)]\n                                                valid-neighbours))\n                             get-at (fn [[x y]] (nth (nth board y) x))\n                             count-live-neighbours (fn [x y] (apply + (map {\\# 1, \\space 0} (map get-at (get-neighbours x y)))))]\n                         (map #(apply str %) (partition (inc x-extent) \n                                                        (for [y (range (inc y-extent)) x (range (inc x-extent))]\n                                                          (get-in decision-table [(get-at [x y]) (live-cell-ranges (count-live-neighbours x y))])))))\n                       )","user":"54cad2d5e4b057c6fda3a26c"},{"problem":94,"code":"(fn game-of-life\n  [board]\n  (let [alive \\# dead \\space]\n    (letfn [(get-environment [x y]\n              (apply +\n                     (for [i [(dec x) x (inc x)] j [(dec y) y (inc y)] :when (not (and (= i x) (= j y)))]\n                       (if (= (nth (seq (nth board i \"\")) j \"\") \\#) 1 0))))]\n      (loop [res [] pos-x 0 pos-y 0 curr-line \"\"]\n        (let [\n              line (nth board pos-x nil)\n              cell (nth line pos-y nil)\n              env (get-environment pos-x pos-y)]\n          (cond\n            (nil? line) res\n            (nil? cell) (recur (conj res curr-line) (inc pos-x) 0 \"\")\n            (or\n              (and\n                (= cell alive)\n                (<= 2 env 3))\n              (and\n                (= cell dead)\n                (= env 3)))\n            (recur res pos-x (inc pos-y) (str curr-line \"#\"))\n            :else (recur res pos-x (inc pos-y) (str curr-line \" \"))))))))","user":"5c20b6abe4b07e362c230576"},{"problem":94,"code":"(fn next-board [board]\n  (let [board-matrix (mapv #(vec %) board)]\n    (map-indexed\n      (fn [r row]\n        (apply str\n               (map-indexed\n                 (fn [c cell]\n                   (let [neighbor-indexes (for [ri (range (dec r) (+ 2 r))\n                                                ci (range (dec c) (+ 2 c))\n                                                :when (not (and (= ri r) (= ci c)))]\n                                            [ri ci])\n                         live-neighbor-count (apply + (map #(if (= \\# (get-in board-matrix %)) 1 0)\n                                                           neighbor-indexes))\n                         cell-alive (= \\# cell)]\n                     (if cell-alive\n                       (if (< 1 live-neighbor-count 4) \\# \\space)\n                       (if (= 3 live-neighbor-count) \\# \\space))))\n                 row)))\n      board-matrix)))","user":"5353afa0e4b084c2834f4b03"},{"problem":94,"code":"(fn solve [m]\n  (letfn [(transpose [m]\n            (apply map list m))\n          (ext [m]\n               (let [empty-line [(repeat \\.)]]\n                 (transpose (concat empty-line\n                                    (transpose (concat empty-line\n                                                       m \n                                                       empty-line))\n                                    empty-line))))\n          (windows [m]\n                   (transpose\n                     (map (fn [ys] (partition 3 1 ys))\n                          (transpose\n                            (map (fn [xs] (partition 3 1 xs)) (ext m))))))\n          (freqs [wm]\n                 (map (fn [xs]\n                        (map (fn [ys]\n                               ((frequencies (flatten ys)) \\#)\n                               ) xs))\n                      wm))\n          (next-gen [m]\n                    (map (fn [xs cs]\n                           (map (fn [x c]\n                                  (if (= x \\#)\n                                    (if (#{3 4} c) \\# \\space)\n                                    (if (= 3 c) \\# \\space)))\n                                xs cs))\n                         m (freqs (windows m))))]\n    (map #(apply str %) (next-gen m))))","user":"54b13a40e4b09f271ff37d1b"},{"problem":94,"code":"(fn [[& xr]] (letfn [\n                              (worldr [s r] (reduce-kv #(if (= %3 \\#) (conj % [%2 r]) %) [] (vec s)))\n                              (world [s] (set (mapcat identity (map-indexed #(worldr %2 %) s))))\n                              (pneigbours [[x y]] (set (for [a (range (dec x) (+ 2 x))\n                                                             b (range (dec y) (+ 2 y))\n                                                          :when (and                                              \n                                                                 (< -1 a (count (first xr)))\n                                                                 (< -1 b (count xr))\n                                                                 (not (and (= x a) (= y b))))]\n                                                      [a b])))\n                              (cneigbours [c w] (count (clojure.set/intersection w (pneigbours c))))\n                              (dorl [l n] (if l (< 1 n 4) (= 3 n)))\n                              (nworld [w] (set (for [a (range (count (first xr))) b (range (count xr)) :when (dorl (w [a b]) (cneigbours [a b] w))]\n       [a b])))\n                              (pworld [w] (apply vector (map #(apply str %) (partition (count (first xr)) (for [a (range (count xr)) b (range (count (first xr)))]\n                                                                               (if (w [b a]) \\# \\space))))))\n                              ]\n                        (pworld (nworld (world xr)))))","user":"5b924123e4b0c0b3ffbd4a34"},{"problem":94,"code":"(fn [grid] (let [alive-cell \\#\n                dead-cell \\space\n                alive? (fn [grid pos] (= alive-cell (get-in grid pos)))\n                get-neighbors-pos (fn \n                                    [grid [x y]]\n                                    (remove #(= [x y] %)\n                                            (for [xn [-1 0 1]\n                                                  yn [-1 0 1]]\n                                              [(+ x xn) (+ y yn)])))\n                get-neighbors (fn \n                                [grid pos]\n                                (map #(get-in grid %)\n                                     (get-neighbors-pos grid pos)))\n                get-alive-neighbors (fn \n                                      [grid pos]\n                                      (get (frequencies (get-neighbors grid pos)) \\# 0))\n                get-next-state (fn \n                                 [grid pos]\n                                 (let [alive-neighbors (get-alive-neighbors grid pos)]\n                                   (if (alive? grid pos)\n                                     (cond\n                                       (< alive-neighbors 2) dead-cell\n                                       (<= 2 alive-neighbors 3) alive-cell\n                                       (< 3 alive-neighbors) dead-cell\n                                       :else dead-cell)\n                                     (cond\n                                       (= 3 alive-neighbors) alive-cell\n                                       :else dead-cell))))\n                idx->pos (fn \n                           [grid idx]\n                           [(int (/ idx (count grid))) (rem idx (count (first grid)))])\n                flat->2vector (fn \n                                [grid]\n                                (map clojure.string/join\n                                     (partition (int (Math/sqrt (count grid))) grid)))]\n            (flat->2vector\n             (map #(get-next-state grid (idx->pos grid %))\n                  (range (count (clojure.string/join \"\" grid)))))))","user":"55c66ffee4b0e31453f649c2"},{"code":"(fn [b]\n  (let [a #(= \\# (get-in b %))\n        c count\n        z range\n        s (c b)\n        r (z s)\n        g #(z (max (- % 1) 0) (min (+ 2 %) s))\n        o not=\n        v #(let [n (c\n                     (filter a (for [m (g %)\n                                     n (g %2)\n                                     :when (or (o m %) (o n %2))]\n                                 [m n])))]\n              (if (a [% %2])\n                (cond\n                 (< n 2) \\ \n                 (< 1 n 4) \\#\n                 :e \\ )\n                (if (= n 3) \\# \\ )))]\n    (for [x r] (apply str (for [y r] (v x y))))))","problem":94,"user":"4fa340b4e4b081705acca18c"},{"code":"(fn [gen]\n  (letfn [(cell [s c]\n            (let [live \"#\"\n                  dead \" \"\n                  n (count (filter #(= % live) s))\n                  alive? (= c live)]\n              (cond (and alive? (< n 2)) dead\n                    (and alive? (= n 2)) live\n                    (and alive? (= n 3)) live\n                    (and (not alive?) (= n 3)) live\n                    :else dead)))]\n    (let [t [[0 -1] [0 1] [-1 0] [1 0] [-1 -1] [1 1] [-1 1] [1 -1]]\n          board (vec (map #(vec (re-seq #\".\" %)) gen))]\n      (for [x (range (count board))]\n        (apply str\n               (for [y (range (count board))]\n                 (let [index (map (fn [[a b]] [(+ x a) (+ y b)]) t)\n                       n (map #(get-in board %) index)]\n                   (cell n (get-in board [x y])))))))))","problem":94,"user":"4f2d5f5de4b0d6649770a05a"},{"code":"(fn [b]\n  (let [m (into {}\n            (for [[i y] (map list (range) b)\n                  [j x] (map list (range) y)]\n              [[i j] x]))\n        neigh (fn [[i j]] (for [di [-1 0 1] dj [-1 0 1]\n                         :when (not (= [di dj] [0 0]))]\n                         [(+ i di) (+ j dj)]))\n        counts (into {} \n                     (map #(vector \n                             % \n                             (count (filter (fn [x] (= \\# x)) (map m (neigh %))))) \n                          (keys m)))\n        update (fn [[k x]]\n                 (let [c (counts k)\n                       newstate (if (= x \\#)\n                                  (cond\n                                    (< c 2) \\space\n                                    (< c 4) \\#\n                                    :else   \\space)\n                                  (cond\n                                    (= c 3) \\#\n                                    :else \\space))]\n                   [k newstate]))\n        newb (map update m)\n        vecboard (vec (map vec b))\n        res (reduce (fn [acc [k x]] (assoc-in acc k x)) vecboard newb)]\n    (map #(apply str %) res)))","problem":94,"user":"509c03f3e4b085ae113522a8"},{"code":"(fn [b]\n  (let [X (-> b first count)\n        Y (count b)\n        cells (for [y (range Y) x (range X)] [x y])\n        cell (fn [[x y]] (-> b (get y) vec (get x)))\n        alive? (fn [c] (-> (cell c) #{\\#} boolean))\n        neighbours (fn [[x y]] (for [a [-1 0 1] b [-1 0 1] :when (not (= a b 0))] [(+ x b) (+ y a)]))\n        count-alive-neighbours (fn [c] (->> (neighbours c) (map alive?) (filter identity) count))\n        next-gen (->> (reduce #(assoc % %2 (count-alive-neighbours %2)) {} cells)\n                   (map (fn [[c alive-nbg]] [c (cond\n                                                 (= 3 alive-nbg) \\#\n                                                 (= 2 alive-nbg) (cell c)\n                                                 :else \\space\n                                                 )]))                                                \n                   (into {})\n                   )]\n    (map (partial apply str) (partition X (map next-gen cells)))))","problem":94,"user":"5028cd0fe4b01614d1633ffc"},{"code":"(fn [g]\n    (let [r [-1 0 1]\n          n\n          #(count\n            (for [i r j r\n                  :when (= \\# (get (get g (+ % i)) (+ %2 j)))]\n              1))]\n      (map-indexed\n       (fn [i r]\n         (apply str\n                (map-indexed\n                 #(condp = (n i %)\n                   3 \"#\"\n                   4 %2\n                   \" \")\n                 r)))\n       g)))","problem":94,"user":"4f0664bd535dcb61093f6c0f"},{"code":"(fn [board]\n  (let [board (mapv vec board)\n        alive? (fn [[row col]] (and (>= row 0)\n                                  (< row (count board))\n                                  (>= col 0)\n                                  (< col (count (first board)))\n                                  (= \\# (get-in board [row col]))))\n        step (fn [row col]\n               (let [live-neighbours (count (filter identity (map alive? [[(dec row) (dec col)] [(dec row) col] [(dec row) (inc col)]\n                                                                          [row (dec col)]                       [row (inc col)]\n                                                                          [(inc row) (dec col)] [(inc row) col] [(inc row) (inc col)]])))]\n                 (if (alive? [row col])\n                   (cond\n                    (< live-neighbours 2) \" \"\n                    (> live-neighbours 3) \" \"\n                    :else \\#)\n                   (if (= live-neighbours 3)\n                     \\#\n                     \" \"))))]\n    (mapv (partial apply str)\n          (for [row (range (count board))]\n            (for [col (range (count (first board)))]\n              (step row col))))))","problem":94,"user":"52a1acb2e4b04e0c58e87bdb"},{"code":"(fn [board]\n  (letfn [(live-neighbours [r c]\n            (apply +\n              (for [dr [-1 0 1] dc [-1 0 1] :when (not= [dr dc] [0 0])]\n                (if (= \\# (get-in board [(+ r dr) (+ c dc)] \\space)) 1 0))))]\n    (for [r (range (count board))]\n      (apply str\n        (for [c (range (count (board r)))]\n          (if (= \\# (get-in board [r c]))\n            (if (#{2 3} (live-neighbours r c)) \\# \\space)\n            (if (= 3 (live-neighbours r c)) \\# \\space)))))))","problem":94,"user":"4fe84c74e4b07c9f6fd12c3c"},{"code":"(fn [b]\r\n  (let [g (fn [b] (zipmap (range (count b)) b))\r\n\t \t  h (fn [m] (map #(get m %) (range (count m))))\r\n\t \t  print-board (fn [bm] (map (partial apply str) (map h (h bm))))\r\n\t      bm (g (map g b))\r\n\t      live? (fn [m x y] (= (get-in m [x y]) \\#))\r\n\t      live-neighbors (fn [m x y] \r\n\t      \t\t\t\t\t(count\r\n\t      \t\t\t\t\t\t(filter\r\n\t      \t\t\t\t\t\t\t#(apply live? m %)\r\n\t\t\t\t      \t\t\t\t\t[[(dec x) (dec y)] [(dec x) y] [(dec x) (inc y)] \r\n\t\t\t\t      \t\t\t\t\t [x (dec y)] [x (inc y)] \r\n\t\t\t\t      \t\t\t\t\t [(inc x) (dec y)] [(inc x) y] [(inc x) (inc y)]])))\r\n\t\t  next-state (fn [m x y]\r\n\t\t\t\t\t  \t(let [ln (live-neighbors m x y)]\t\t  \r\n\t\t\t\t\t  \t\t(cond\r\n\t\t\t\t\t  \t\t\t(and (= 2 ln) (live? m x y)) \\#\r\n\t\t\t\t\t  \t\t\t(= 3 ln) \\#\r\n\t\t\t\t\t  \t\t\t:else \\space)))]\r\n\t\t  \t\t\r\n\t\t\t\t      \t\t\t\t\t  \r\n\t\t(loop [new-bm {} x 0 y 0]\r\n\t\t\t(cond\r\n\t\t\t\t(= x (count bm)) (recur new-bm 0 (inc y))\r\n\t\t\t\t(= y (count bm)) (print-board new-bm)\r\n\t\t\t\t:else (recur (assoc-in new-bm [x y] (next-state bm x y)) (inc x) y)))))","problem":94,"user":"4db85282535d1e037afb218a"},{"problem":94,"code":"(fn [b]\n  (let [l (count (first b))\n        z (list (repeat l 0))\n        ns (fn [s] (map #(if (= % \\#) 1 0) s))\n        rs (fn [c] (apply str (map #(if (= % 1) \\# \" \") c)))\n        nb (map ns b)\n        shl (fn [c] (concat (rest c) '(0)))\n        shr (fn [c] (concat '(0) (butlast c)))\n        lb (map shl nb)\n        rb (map shr nb)\n        ub (concat (rest nb) z)\n        db (concat z (butlast nb))\n        ulb (concat (rest lb) z)\n        dlb (concat z (butlast lb))\n        urb (concat (rest rb) z)\n        drb (concat z (butlast rb))\n        neb (map #(map + %1 %2 %3 %4 %5 %6 %7 %8) lb rb ub db ulb dlb drb urb)\n        mv (fn [s n] (cond\n                       (and (= s 0) (= n 3)) 1\n                       (and (= s 1) (or (< n 2) (> n 3))) 0\n                         :else s))\n        mb (map #(map mv %1 %2) nb neb)]\n    (map rs mb)))","user":"55205564e4b08d5046aa8a60"},{"code":"(fn [i-board]\r\n     (let [\r\n           c-count (count (first i-board))\r\n           r-count (count i-board)\r\n           in-board (fn [i-coor]\r\n                            (let [[i-row i-col] i-coor]\r\n                              (and\r\n                                (>= i-row 0)\r\n                                (< i-row r-count)\r\n                                (>= i-col 0)\r\n                                (< i-col c-count))))\r\n           has-life (fn [i-coor]\r\n                        (= \\# (nth (nth i-board (first i-coor)) (last i-coor))))\r\n           board-coor (reduce\r\n                        concat\r\n                        '()\r\n                        (map\r\n                          (fn [my-row]\r\n                              (map #(vector my-row %) (range c-count)))\r\n                          (range r-count)))\r\n           live-list (filter has-life board-coor)\r\n           dead-list (filter #(not (has-life %)) board-coor)\r\n           neighbour (fn [i-coor]\r\n                         (let [[i-row i-col] i-coor]\r\n                           (filter\r\n                             #(let [[my-row my-col] %] (not (and (= my-row i-row) (= my-col i-col))))\r\n                             (reduce\r\n                               concat\r\n                               '()\r\n                               (map\r\n                                 (fn [i-coors]\r\n                                     (filter in-board i-coors))\r\n                                 (map\r\n                                   (fn [my-row]\r\n                                       (map\r\n                                         (fn [my-col]\r\n                                             (vector my-row my-col))\r\n                                         (range (dec i-col) (+ i-col 2))))\r\n                                   (range (dec i-row) (+ i-row 2))))))))\r\n           living-neighbour (fn [i-coor] (filter has-life (neighbour i-coor)))\r\n           lives-on (fn [i-coor]\r\n                        (let [n-count (count (living-neighbour i-coor))]\r\n                          (or (= 2 n-count) (= 3 n-count))))\r\n           reproducible (fn [i-coor]\r\n                            (= 3 (count (living-neighbour i-coor))))\r\n           new-lives (group-by\r\n                       #(first %)\r\n                       (concat\r\n                         (filter lives-on live-list)\r\n                         (filter reproducible dead-list)))\r\n           draw-row (fn plot-lives\r\n                        ([i-row] (plot-lives [] 0 (sort (map last (get new-lives i-row)))))\r\n                        ([result i-pos i-lives]\r\n                         (if (= c-count i-pos)\r\n                           (apply str result)\r\n                           (let [c-life (first i-lives) n-pos (inc i-pos)]\r\n                             (if (= i-pos c-life)\r\n                               (plot-lives (conj result \\#) n-pos (rest i-lives))\r\n                               (plot-lives (conj result \\space) n-pos i-lives))))))\r\n           ]\r\n       (map draw-row (range r-count))))","problem":94,"user":"50436470e4b034ff00315d23"},{"code":"(fn tick\n  [state]\n  (let [neighbors (fn [x y]\n                    (for [xinc (range -1 (inc 1))\n                          yinc (range -1 (inc 1)) :when (not (= 0 xinc yinc))]\n                      [(+ x xinc) (+ y yinc)]))\n        map-matrix (fn [f matrix]\n                     (map-indexed (fn [x row]\n                                    (map-indexed (fn [y cell]\n                                                   (f x y cell))\n                                                 row))\n                                  matrix))]\n    (mapv (partial apply str)\n          (map-matrix (fn [x y cell]\n                        (let [n (count (filter #{\\#}\n                                               (map #(get-in state %)\n                                                    (neighbors x y))))]\n                          (cond (= n 3) \\#\n                                (and (= cell \\#) (= n 2)) \\#\n                                :else \\space)))\n                      state))))","problem":94,"user":"4dc0ff08535d020aff1edf84"},{"code":"(fn [grid]\n  (let [width (count grid)\n        height (count (first grid))\n        cells (set\n                (for [x (range width)\n                      y (range height)\n                      :when (= \\# (get-in grid [x y]))]\n                  [x y]))\n        dirs [[-1 -1][0 -1][1 -1]\n              [-1  0]      [1  0]\n              [-1  1][0  1][1  1]]\n        surrounding-coords (fn [coord] (map #(map + coord %) dirs))\n        neighbours (fn [coord] (filter #(contains? cells %) (surrounding-coords coord)))\n        survivors (filter #(let [n (count (neighbours %))] (or (= 2 n) (= 3 n))) cells)\n        newbies (filter #(let [n (count (neighbours %))] (= 3 n)) (clojure.set/difference (set (reduce #(concat %1 (surrounding-coords %2)) [] cells)) cells))\n        next-gen (set (concat survivors newbies))]\n  (for [y (range height)]\n    (apply str\n           (for [x (range width)]\n             (if (contains? next-gen [y x]) \"#\" \" \"))))))","problem":94,"user":"53513d28e4b084c2834f4ae3"},{"problem":94,"code":"(fn game-life [game]\n  (let [\n        index-game (fn index-game [game]\n                     (let  [index-vec (fn [v] (into {}\n                                                    (map-indexed #(vector %1 %2) v)))\n                            indexed-rows (map #(index-vec %) game)]\n                       (index-vec indexed-rows)))\n        count-neighbors (fn count-neighbors [states r c]\n                          (let [trans [[-1 -1] [-1 0] [-1 1] [0 1] [1 1] [1 0] [1 -1] [0 -1]]\n                                neighbors-idx (map #(vector (+ r (first %)) (+ c (second %))) trans)\n                                get-neighbor-val (fn [idx] (if (= (get-in states idx) \\#) 1 0))]\n                            (reduce #(+ %1 (get-neighbor-val %2)) 0 neighbors-idx)))\n\n        get-new-state (fn get-new-state [indexed-game r c]\n                        (let [\n                              n-neighbors (count-neighbors indexed-game r c)\n                              is-dead (= \\space (get-in indexed-game [r c]))\n                              dead-to (fn [n] (if (= n 3) \\#\n                                                \\space))\n                              alive-to (fn [n] (cond (< n 2) \\space\n                                                     (> n 3) \\space\n                                                     :else \\#))]\n                          (if  is-dead (dead-to n-neighbors)\n                            (alive-to n-neighbors))))\n\n        update-game (fn update-game [indexed-game]\n                      (let [dim (count indexed-game)\n                            idxs (for [r (range dim), c (range dim)] [r c])\n                            new-states (map #(vector (first %) (second %) (get-new-state indexed-game (first %) (second %))) idxs)]\n                        (reduce #(assoc-in %1 (take 2 %2) (last %2)) indexed-game new-states)))\n\n        deindex-game (fn deindex-game [indexed-game]\n                       (let [row2str (fn [r] (apply str\n                                                    (map #(second %) (sort-by key r))))\n                             rows (map #(val %) (sort-by key indexed-game))]\n                         (map #(row2str %) rows)))\n\n        ]\n    (-> game index-game update-game deindex-game)))","user":"54bbaa8ee4b0ed20f4ff6ec0"},{"code":"(fn [x]\n  (let [cell;判定一个细胞下一刻的死活\n    (fn [self neighbours]\n      (let [lives (count (filter #{\\#} neighbours))]\n        (cond (= \\space self) (if (= 3 lives) \"#\" \" \" )\n              (> 2 lives) \" \"\n              (< 3 lives) \" \"\n              :else \"#\")))\n        ;获取一个细胞，如果index超过范围，返回nil\n        get-cell #(if (or (> 0 %1) (> 0 %2) (<= (count x) %1) (<= (count (nth x %1)) %2)) nil (nth (nth x %1) %2))\n        ;一组函数，用来计算包括自己的附近9个格子\n        index9 (#(for [l % r %] [l r]) [#(dec %) #(identity %) #(inc %)])\n        get-neighbours (fn [i j] (map (partial apply get-cell) (remove #{[i j]} (map #(vector ((first %) i) ((second %) j)) index9))))]\n    (loop[i 0 j 0 result [] temp \"\"]\n      (cond (= i (count x)) result\n            (= j (count (nth x i))) (recur (inc i) 0 (conj result temp) \"\")\n            :else (recur i (inc j) result (str temp (cell (get-cell i j) (get-neighbours i j))))))\n))","problem":94,"user":"507fbd77e4b089ade05efbd3"},{"code":"(fn [b]\n  (letfn \n    [\n      (v [x y]\n        (if\n          (and\n            (>= y 0)\n            (< y (count b))\n            (>= x 0)\n            (< x (count b))\n            (= (nth (nth b y) x) \\#)\n          )\n          1\n          0\n        )\n      ) \n      (n [x y] \n        (+ (v (dec x) (dec y)) (v x (dec y)) (v (inc x) (dec y)) (v (dec x) y) (v (inc x) y)  (v (dec x) (inc y)) (v x (inc y)) (v (inc x) (inc y)))\n      )\n    ]\n    (for [y (range (count b))]\n      (apply str \n        (for [x (range (count b))]\n          (case (n x y)\n            2 (if (= (v x y) 1) \\# \\space)\n            3 \\# \n            \\space\n          )\n        ) \n      )\n    )  \n  )  \n)","problem":94,"user":"5176afd2e4b085adf681d889"},{"problem":94,"code":"(fn next-generation [t]\n  (letfn [(get-neighbours [[x y] b]\n      (->>\n        (for [i (range (max (dec x) 0) (min (+ x 2) (count b)))\n              j (range (max (dec y) 0) (min (+ y 2) (count b)))]\n          [i j])\n        (filter (fn [[k m]] (not (and (= y m) (= x k)))))\n        (map (fn [[k m]] (nth (nth b k) m)))))]\n      (->> (for [x (range (count t))\n          y (range (count t))]\n        (let [current (nth (nth t x) y)]\n          (->>\n            (get-neighbours [x y] t)\n            ((fn [ns]\n              (cond (= current \\space)\n                (cond (= 3 (count (filter #(= \\# %) ns))) \\#\n                      :else \\space)\n                :else\n                  (cond (> 2 (count (filter #(= \\# %) ns))) \\space\n                        (> 4 (count (filter #(= \\# %) ns))) \\#\n                        :else \\space))))\n          )))\n          (reduce str)\n          (reduce (fn [z h]\n              (if (< (count (last z)) (count t))\n                (conj (into [] (drop-last z)) (conj (into [] (last z)) h))\n                (concat z [[h]]))) [[]])\n          (map (fn [row]\n            (reduce str row)))\n          )))","user":"5b15811ee4b0cc2b61a3be6f"},{"code":"(fn [board]\n  (let [size (count board)\n        parse #(vec (mapcat seq %))\n        neighbors (fn [i b]\n                    (for [func (for [op-x [inc identity dec]\n                                     op-y [inc identity dec]\n                                     :when (not= op-x op-y identity)]\n                                 #(get b (+ (op-x %1) (* size (op-y %2)))))\n                          :let [x (rem i size)\n                                y (int (/ i size))]]\n                      (func x y)))\n        print-board (fn [b]\n                      (mapv (partial reduce str) (partition size b)))\n        b (parse board)]\n    (print-board\n      (for [i (range (* size size))\n            :let [c (count (filter #{\\#} (neighbors i b)))]]\n\n        (if (= (get b i) \\#)\n          (cond (< c 2) \\space\n                (> c 3) \\space\n                :else   \\#)\n          (if (= c 3)\n            \\#\n            \\space))))))","problem":94,"user":"50d8de3fe4b01f0871336e72"},{"code":"; solution without using indexes\n(fn [board]\n  (let [expanded (map #(str \" \" % \" \") (cons \"      \" (conj board \"      \"))) ; expand the board by one to have the same number of neighbour cells\n        neighbour-cells (map #(map (fn [x] (partition 3 1 x)) %) (partition 3 1 expanded)) ; partition the board into 3*3 cells\n        neighbour-count (map #(apply map (fn [& cells] ((frequencies (flatten (vector cells))) \\# 0)) %) neighbour-cells) ; number of neighbours\n        cell-neighbours (map #(partition 2 %) (map interleave board neighbour-count)) ; each cell with its neighbours => (((\\space 1) (\\# 4) ...\n        gol (fn [[cell neighbours]]\n              (cond ; a live cell is also counted in the neighbours, so neighbour counts are off by one for live cells\n                (and (= cell \\space) (= neighbours 3)) \"#\" ; new life by reproduction\n                (and (= cell \\#) (< neighbours 3)) \" \" ; death by under-population\n                (and (= cell \\#) (> neighbours 4)) \" \" ; death by over-population\n                (= cell \\#) \"#\" ; life goes on\n                :else \" \"))]\n    (map #(apply str (map gol %)) cell-neighbours)))","problem":94,"user":"500900dee4b0144d4f561e42"},{"problem":94,"code":"(fn [cloj-input] (letfn [(indexes-of [coll e]\n                                     (keep-indexed #(when (= e %2) %1) coll))\n                         (parse-input [input]\n                                      (set (apply concat (filter #(not (nil? %))\n                                                                 (map-indexed (fn [idx item]\n                                                                                (let [indexes (seq (indexes-of item \\#))]\n                                                                                  (when (not (nil? indexes))\n                                                                                    (map #(vector idx %) indexes)))) input)))))\n                         (parse-output [output world-size]\n                                       (for [x (range world-size)]\n                                         (apply str (for [y (range world-size)]\n                                                      (if (contains? output [x y])\n                                                        \"#\"\n                                                        \" \")))))\n                         (moore-neighborhood [[x y]]\n                                             (for [dx [-1 0 1]\n                                                   dy [-1 0 1]\n                                                   :when (not (= [dx dy] [0 0]))]\n                                               [(+ x dx) (+ y dy)]))\n                         (step [set-of-cells]\n                               (set (for [[cell count] (frequencies (mapcat moore-neighborhood set-of-cells))\n                                          :when (or (= 3 count)\n                                                    (and (= 2 count) (contains? set-of-cells cell)))]\n                                      cell)))\n                         (run-gol [world-size num-of-steps set-of-cells]\n                                  (loop [steps num-of-steps\n                                         cells set-of-cells]\n                                    (if (< 0 steps)\n                                      (recur (dec steps) (step cells))\n                                      (parse-output cells world-size))))]\n                   (run-gol (count cloj-input) 1 (parse-input cloj-input))))","user":"55b42706e4b01b9910ae297b"},{"problem":94,"code":"(fn gameoflife [b]\n                 (let [v (vec (mapcat vec b))\n                       n (count (first b))\n                       f (fn [w]\n                           (if (and (= (first w) \\#) (< (peek w) 2))\n                             \\space\n                             (if (and (= (first w) \\#) (<= (peek w) 3))\n                               \\#\n                               (if (and (= (first w) \\#) (> (peek w) 3))\n                                 \\space\n                                 (if (and (= (first w) \\space) (== (peek w) 3))\n                                   \\#\n                                   \\space)))))]\n                   (vec (map #(apply str %) (partition n (map f (for [x (range (* n n))]\n                                                                  (vector (get v x) (apply + (for [y (range (* n n))\n                                                                                                   :when (and (or (== y (- x n)) (== y (+ x n))\n                                                                                                                  (and (== y (dec x)) (not= 0 (mod x n)))\n                                                                                                                  (and (== y (inc x)) (not= 0 (mod (inc x) n)))\n                                                                                                                  (and (== y (- x (inc n))) (not= 0 (mod x n)))\n                                                                                                                  (and (== y (- x (dec n))) (not= 0 (mod (inc x) n)))\n                                                                                                                  (and (== y (+ x (inc n))) (not= 0 (mod (inc x) n)))\n                                                                                                                  (and (== y (+ x (dec n))) (not= 0 (mod x n))))\n                                                                                                              (= (get v y) \\#))]\n                                                                                               1))))))))))","user":"532727bae4b09d4e7a9b54fa"},{"problem":94,"code":"(fn gol-next-generation [board] \n  (let [live-cell \\#\n        dead-cell \\space\n        height (count board)\n        width (count (first board))]\n    (letfn [(neighbors [[x y]]\n              (for [dx [-1 0 1] \n                    dy (if (zero? dx) [-1 1] [-1 0 1])]\n                [(+ x dx) (+ y dy)]))\n            (next-state [cells]\n              (set (for [[cell n] (frequencies (mapcat neighbors cells))\n                         :when (or (= n 3) \n                                   (and (= n 2) (cells cell)))]\n                     cell)))\n            (generate-board [alive] \n              (mapv #(apply str %) \n                    (partition width\n                               (for [y (range height)\n                                     x (range width) \n                                     :let [char (if (alive [x y]) live-cell dead-cell)]]\n                                 char))))]\n      (let [live-cells (set (for [y (range height) \n                                  x (range width)\n                                  :when (= live-cell (get-in board [y x]))]\n                              [x y]))]\n        (generate-board (next-state live-cells))))))","user":"58ed713de4b056aecfd47d84"},{"problem":94,"code":"(fn game-of-life\n  [grid]\n  (letfn [(no-live-cells\n            [grid [i j]]\n            (count\n             (filter (fn [c] (= c \\#))\n                     (for [row (range (max 0 (dec i)) (min (count (first grid)) (+ 2 i)))\n                           col (range (max 0 (dec j)) (min (count grid) (+ 2 j)))\n                           :when (not (and (= row i)\n                                           (= col j)))]\n                       (get-in grid [row col])))))]\n    (for [row (range (count grid))]\n      (clojure.string/join\n       (for [col (range (count (first grid)))]\n         (if (= \\# (get-in grid [row col]))\n           (case (no-live-cells grid [row col])\n             (2 3) \\#\n             \\space)\n           (case (no-live-cells grid [row col])\n             3 \\#\n             \\space)))))))","user":"60460824e4b02d28681c77bc"},{"problem":94,"code":"(fn [g]\n  (let [num-neighbors (fn [grid x y]\n          (let [xlen (count grid) ylen (count (first grid))]\n            (reduce + \n             (for [xc (range (max 0 (dec x)) (min xlen (+ 2 x)))\n                   yc (range (max 0 (dec y)) (min ylen (+ 2 y))) \n                   :when (and (not (and (= xc x) (= yc y))) (= \\# (nth (nth grid xc) yc)))\n               ] 1))))\n         rules {\\# [{2 \\#, 3 \\#} \\space],  \\space [{3 \\#} \\space]}\n         new-cell (fn [grid x y]\n           (let [cell (nth (nth grid x) y)\n           neighbors (num-neighbors grid x y)\n            rule (rules cell)\n           result ((first rule) neighbors (last rule))\n           ]\n          result))\n         new-line (fn [grid x] \n          (apply str (for [y (range (count (nth grid x)))] (new-cell grid x y))))\n                          \n                    \n    ];; let\n     (map (partial new-line g) (range (count g))))) ;; fn","user":"54908cc1e4b0b312c081ff32"},{"problem":94,"code":"(fn [board]\n  (let [nboard  (map (fn [v] (map #(if (= % \\#) 1 0) v)) (map #(into [] %) board))\n        vtom (fn [v] (apply hash-map  (flatten (map-indexed list v))))\n        mboard (vtom (map #(vtom %) nboard))\n        make_ij (fn [x y]\n                  (for [i (range x)\n                        j (range y)]\n                    (list i j)))\n        find_ij (fn [i j x y]\n                  (let [ijs (list [(- i 1) (- j 1)] [(- i 1) j] [(- i 1) (+ j 1)]\n                                  [i (- j 1)]                             [i (+ j 1)]\n                                  [(+ i 1) (- j 1)] [(+ i 1) j] [(+ i 1) (+ j 1)])\n                        fit? (fn [[a b]]\n                               (if (and (>= a 0) (>= b 0) (< a x)(< b y))\n                                 true\n                                 false))]\n                    (filter fit? ijs)))\n        rs (count nboard)\n        cs (count (first nboard))\n        ijs (map #(list (first %) (second %)(find_ij (first %) (second %) rs cs)) (make_ij rs cs))\n        find_v  (fn [x y ij]\n                  (list x  y (apply + (map #((mboard (first %)) (second %)) ij))))\n        rv (map (fn [[a b c]] (find_v a b c)) ijs)\n        live? (fn [a b c] (if (and (= ((mboard a) b) 0) (= c 3))\n                            (list a b \\#)\n                            (if (and (=((mboard a) b) 1) (or (= c 2) (= c 3)))\n                              (list a b \\#)\n                              (list a b \\space))))\n        rv2 (map (fn [[a b c]] (live? a b c)) rv)]\n        (map #(apply str %) (partition cs (map (fn [[a b c]] c) rv2))) ))","user":"566d71b1e4b0a866af6896ca"},{"problem":94,"code":"(fn [board]\n   (let [board (mapv vec board)\n         w (count board)\n         r (vec (repeat w (vec (repeat w \\space))))\n         b (set (for [x (range w)\n                      y (range w)\n                      :when (= \\# (get-in board [x y]))]\n                  [x y]))\n         nei (for [x (range -1 2 1)\n                   y (range -1 2 1)\n                   :when (not= 0 x y)]\n               [x y])\n         neighbor (fn [cord]\n                    (->> (mapv #(mapv + cord %) nei)\n                         (filter #(and (<= 0 (first %))\n                                       (<= 0 (second %))))))]\n     (map clojure.string/join (reduce #(assoc-in % %2 \\#)\n                                      r\n                                      (->> (frequencies (mapcat neighbor b))\n                                           (filter #(or (and (= 2 (second %))\n                                                             (b (first %)))\n                                                        (= 3 (second %))))\n                                           (map first))))\n     ))","user":"557c6ca6e4b05c286339e0c4"},{"code":"(fn next-generation [board]\n  (letfn [(alive? [i j] \n            (-> board (nth i) (nth j) (= \\#)))\n          (find-neighbours [i j] \n            (for [di [-1 0 1]\n                  dj [-1 0 1]\n                  :let [ii (+ i di)\n                        jj (+ j dj)]\n                  :when (and (not (and (= i ii) \n                                       (= j jj)))\n                             (>= ii 0)\n                             (< ii (count board))\n                             (>= jj 0)\n                             (< jj (count (first board))))]\n              [ii jj]))\n          (still-alive? [alive neighbours]\n            (let [n-alive-neighbours (count (filter #(apply alive? %) neighbours))]\n              (cond (< n-alive-neighbours 2) false\n                    (and (= n-alive-neighbours 2) alive) true\n                    (= n-alive-neighbours 3) true\n                    :else false)))]\n      (map (fn create-row [i]\n             (apply str \n               (map (fn [j] (if (still-alive? (alive? i j) (find-neighbours i j)) \"#\" \" \"))\n                    (range (count (first board))))))\n           (range (count board)))))","problem":94,"user":"529e3a4fe4b04e0c58e87b92"},{"code":"(fn board-step [board]\n  (let [live-cell \\#\n        dead-cell \\space\n        live-cell? (fn [cell] (= cell live-cell))\n        transit-cell (fn [cell live-neib]\n                       (if (live-cell? cell)\n                         (cond\n                          (< live-neib 2) dead-cell\n                          (> live-neib 3) dead-cell\n                          :else live-cell)\n                         (cond\n                          (= live-neib 3) live-cell\n                          :else dead-cell)))\n        align-subvec (fn [v f t]\n                       (let [af (if (< f 0) 0 f)\n                             inc-t (inc t)\n                             at (if (>= (count v) inc-t) inc-t (count v))]\n                         (subvec v af at)))\n        mutate-cell (fn [board r c acc-board]\n                      (let [cell ((board r) c)\n                            hor-zone (align-subvec board (dec r) (inc r))\n                            zone (mapcat #(align-subvec % (dec c) (inc c)) hor-zone)\n                            live-cells-count (count (filter live-cell? zone))\n                            live-neibs (if (live-cell? cell) (dec live-cells-count) live-cells-count)\n                            mutated-cell (transit-cell cell live-neibs)]\n                        (assoc acc-board r (assoc (acc-board r) c mutated-cell))))]\n    (let [vec-board (vec (map vec board)) \n          rc (count board)\n          cc (count (first board))]\n      (loop [r 0 c 0 acc-board vec-board]\n        (let [next-board (mutate-cell vec-board r c acc-board)]\n          (cond\n           (> cc (inc c)) (recur r (inc c) next-board)\n           (> rc (inc r)) (recur (inc r) 0 next-board)\n           :else (map #(apply str %) next-board)))))))","problem":94,"user":"523b82efe4b07becd5be21f0"},{"code":"(fn [G]\n (let [W  (count (first G))\n       H  (count G)\n       nbr (fn [i j] (into {} (map (fn [p] \n                                       (vector p (get-in G p))) \n                                   (filter (fn [[x y]] \n                                    (and (>= x 0) (>= y 0) (< x H) (< y W) )) \n                [[i (+ j 1)] [i (- j 1)] [(+ i 1) j] [(- i 1) j]    \n                 [(- i 1) (+ j 1)] [(+ i 1) (- j 1)] \n                 [(+ i 1) (+ j 1)] [(- i 1) (- j 1)] ]))))\n       G2\n      (for [i (range H) j (range W) :let [n (nbr i j)\n                                          c (get-in G [i j])\n                                          v (vals n)\n                                          a (count (filter #(= \\# %) v))] ]\n               (if (= c \\#)   \n                   (cond (< a 2) \\ \n                         (< a 4) \\#\n                         :else   \\ )\n                   (if (= a 3)       \n                       \\#\n                       \\ ))) ]\n        (map #(apply str % ) (partition W G2)) ))","problem":94,"user":"4ee7d177535d93acb0a6686f"},{"problem":94,"code":"(fn [coll]\n  (letfn [(nbs [x y]\n              (->> [[0 1] [0 -1] [1 0] [-1 0] [1 1] [-1 -1] [-1 1] [1 -1]]\n                   (map (fn [[a b]] [(+ x a) (+ y b)]))\n                   (filter (fn [[a b]] (and (< -1  a (count coll)) (< -1 b (count coll)))))\n                   (map (fn [[a b]] (nth (nth coll a) b)))))]\n      (map-indexed\n       (fn [x a]\n         (apply str (map-indexed\n                     (fn [y b]\n                       (let [dead \\space\n                             live \\#\n                             ns (nbs x y)\n                             live-ns (count (filter #(= live %) ns))\n                             dead-ns (- (count ns) live-ns)]\n                         (if (= live b)\n                           (cond (< live-ns 2) dead\n                                 (<= 2 live-ns 3) live\n                                 :else dead)\n                           (cond (= live-ns 3) live\n                                 :else dead))))\n                     a)))\n       coll)))","user":"58ca8a1de4b03c36ff7e5835"},{"code":"(fn next-gen [board]\n  (let [\n  m (count (first board))\n  n (count board)\n  ; TODO - investigate bijections in clojure\n  alive? { \\# true, \\space false }\n  encode-cell { true \\#, false \\space }\n  in-bounds (fn [lower upper]\n    (partial filter #(when (and (<= lower %) (< % upper)) %)))\n  >>= (fn [xs f]\n    (apply concat (map f xs)))\n  flip (fn [f b a]\n    (f a b))\n  neighborhood (fn [x y]\n    (let [xs ((in-bounds 0 m) (range (- x 1) (+ x 2)))\n          ys ((in-bounds 0 n) (range (- y 1) (+ y 2)))]\n      (->> (>>= xs #(for [y ys] [% y]))\n           (set)\n           (flip disj [x y]))))\n  board-value (fn [[x y]]\n    (nth (board y) x))\n  new-cell (fn [y]\n    (fn [x]\n      (let [neighbors (->> (neighborhood x y) (map board-value) (filter alive?) (count))\n            alive (alive? (board-value [x y]))]\n      (encode-cell (cond\n        (< 3 neighbors) false\n        (== 3 neighbors) true\n        (== 2 neighbors) alive\n        (< neighbors 2) false)))))\n  new-row (fn [y]\n    (->> (map (new-cell y) (range m)) (apply str)))\n  ]\n  (->> (map new-row (range n)) (apply vector))))","problem":94,"user":"4e691c79535d8ccf87e9fe97"},{"problem":94,"code":"(fn game-of-life-next [board]\n  (letfn [(at [i j] (get (get board i) j))\n          (neighbors [i j]\n            [[(at (dec i) (dec j)) (at (dec i) j) (at (dec i) (inc j))]\n             [(at i (dec j)) :me (at i (inc j))]\n             [(at (inc i) (dec j)) (at (inc i) j) (at (inc i) (inc j))]]\n            )\n          (num-of-neighbors [i j]\n            (count (filter\n                    (partial = \\#) (apply concat (neighbors i j)))))\n          (will-live? [i j]\n            (if (= (at i j) \\space)\n              (if (= (num-of-neighbors i j) 3)\n                true false)\n              (cond\n                (< (num-of-neighbors i j) 2) false\n                (>= (num-of-neighbors i j) 4) false\n                :else true)))]\n  (map #(apply str %)\n         (partition (count board)\n                    (for [i (range (count board)) j (range (count board))]\n                      (if (will-live? i j) \\# \\space)\n                        )))))","user":"5d9c1226e4b0d3f9b434ad51"},{"problem":94,"code":"(fn [board]\n  (let [neighber-idxes [[-1 -1] [-1 0] [-1 1] [1 1] [1 0] [1 -1] [0 1] [0 -1]]\n        get-neighbers (fn [board idx-x idx-y]\n                        (->> neighber-idxes\n                             (map (fn [[x y]]\n                                    (get-in board [(+ x idx-x) (+ y idx-y)])))\n                             (remove nil?)\n                             (frequencies)\n                             ((fn [m] (merge {\\space 0 \\# 0} m)))))]\n    (->> board\n        (map-indexed (fn [idx-x row]\n                       (->> row\n                            (map-indexed (fn [idx-y cell]\n                                           (let [cur (get-in board [idx-x idx-y])\n                                                 neighbers (get-neighbers board idx-x idx-y)\n                                                 lives (neighbers \\# )\n                                                 deads (neighbers \\space )]\n                                          ;;;   (prn \"lives\" lives \"deads\" deads)\n                                             (cond\n                                               (and (= cur \\#) (< lives 2)) \\space\n                                               (and (= cur \\#) (< 1 lives 4))  \\#\n                                               (and (= cur \\#) (< 3 lives) ) \\space\n                                               (and (= cur \\space) (= 3 lives) ) \\#\n                                               :else \\space))))\n                            (clojure.string/join))))\n)))","user":"50e90813e4b033b0e80d11e7"},{"problem":94,"code":"(fn [board]\n  (letfn [(cell [r c] (get-in board [r c] \\space))\n          (neighbors [r c]\n            (for [dr [-1 0 1] dc [-1 0 1] :when (not (= 0 dr dc))]\n              (cell (+ r dr) (+ c dc))))\n          (info [r c] [(cell r c) (count (filter #{\\#} (neighbors r c)))])\n          (update [[cur ct]] (cond (= ct 2) cur (= ct 3) \\# :else \\space))]\n    (map #(apply str %)\n         (map-indexed #(map-indexed (fn [c _] (update (info %1 c))) %2) board))))","user":"52ce1abfe4b07d0d72b27389"},{"code":"(fn [b]\n  (let [w (count (b 0))\n        h (count b)\n        l (fn [r c]\n            (if (and (< -1 r h) (< -1 c h))\n              (if (= \\# (.charAt (b r) c)) 1 0)\n              0))\n        n (fn [r c]\n            (apply + (map #(l (+ r %) (+ c %2))\n                          [-1 -1 -1  0  0  1  1  1]\n                          [-1  0  1 -1  1 -1  0  1])))]\n    (for [r (range 0 h)]\n      (apply str (for [c (range 0 w)]\n                   (let [n (n r c)]\n                     (if (or (= 3 n)\n                             (and (= 1 (l r c)) (= 2 n)))\n                       \\# \" \")))))))","problem":94,"user":"500d8c49e4b07ccb9a7ddb00"},{"code":"(fn igl [b]\n  (let [rows (range (count b)) cols (range (count (first b)))\n        lcls (into {} (filter #(= \\# (second %))\n                              (for [x rows y cols] [[x y] (nth (b x) y)])))\n        close? (fn  [[x y] [a b]] (and (<= (dec x) a (inc x))\n                                       (<= (dec y) b (inc y))))\n        cln (fn [c] (count (filter #(and (not= c (key %))\n                                         (close? c (key %))) lcls)))\n        nec (fn [c] (if (lcls c)\n                      (if (<= 2 (cln c) 3) \\# \\space)\n                      (if (= (cln c) 3) \\# \\space)))]\n    (for [x rows] (apply str (for [y cols] (nec [x y]))))))","problem":94,"user":"5267d9bde4b03e8d9a4a7188"},{"problem":94,"code":"(fn game-of-life [b]\n  (let [length (count b)\n        width (count (first b))\n        neighbors (fn [[x y]] (filter #(let [[x y] %]\n                                         (and (>= x 0) (>= y 0)\n                                              (< x width) (< y length)))\n                                      [[(- x 1) (- y 1)]\n                                       [x (- y 1)]\n                                       [(+ x 1) (- y 1)]\n                                       [(- x 1) y]\n                                       [(+ x 1) y]\n                                       [(- x 1) (+ y 1)]\n                                       [x (+ y 1)]\n                                       [(+ x 1) (+ y 1)]]))\n        nb-live (fn [coords b]\n                  (reduce #(let [[x y] %2]\n                             (if (= (get (get b y) x) \\#)\n                               (+ %1 1)\n                               %1))\n                          0\n                          coords))\n        all-coords (for [x (range width)\n                         y (range length)]\n                     [x y])]\n    (reduce #(conj %1 (apply str %2))\n            []\n            (reduce #(let [[x y] %2\n                           live (nb-live (neighbors %2) b)\n                           row (get %1 y)]\n                       (cond (or (> live 3) (< live 2))\n                             (assoc %1 y (assoc row x \\space))\n                             (and (= (get (get b y) x) \\#)\n                                  (or (= live 2) (= live 3)))\n                             (assoc %1 y (assoc row x \\#))\n                             (= live 3) (assoc %1 y (assoc row x \\#))\n                             :else %1))\n                    (reduce #(conj %1 (into [] %2)) [] b)\n                    all-coords))))","user":"5a6b9b95e4b0512ff01cda40"},{"problem":94,"code":"(fn [bs]\n  (let [b (mapv vec bs)\n        h (count b)\n        w (count (first b))]\n    (->> (for [i (range h)]\n          (for [j (range w)]\n            (let [l? (= \\# (get-in b [i j]))\n                  k (->> (for [x [-1 0 1] y [-1 0 1]]\n                           (get-in b [(+ i y) (+ j x)]))\n                         (filter #(= \\# %))\n                         count)]\n              (if l?\n                (case k 3 \\# 4 \\# \\space)\n                (if (= k 3) \\# \\space)))))\n         (map #(apply str %)))))","user":"53d78b64e4b0e771c3025466"},{"code":"(fn next-step [xss]\n  (letfn [(gen-mat [r c]\n            (vec (repeat r (vec (repeat c \\space)))))\n          (gen-next [cord]\n            (let [[r c] cord]\n              (for [r' [-1 0 1]\n                    c' [-1 0 1]\n                    :when (not= 0 r' c')]\n                [(+ r r') (+ c c')])))]\n    (let [xss' (vec (map vec xss))\n          r-limit (count xss')\n          c-limit (count (first xss'))\n          new-bd (gen-mat r-limit c-limit)]\n      (vec (map #(apply str %) (reduce (fn [bd cord]\n                                         (case (count\n                                                (filter #(= \\# (get-in xss' %))\n                                                        (gen-next cord)))\n                                           2 (assoc-in bd cord (get-in xss' cord))\n                                           3 (assoc-in bd cord \\#)\n                                           (assoc-in bd cord \\space))) new-bd\n                                           (for [x (range r-limit)\n                                                 y (range c-limit)]\n                                             [x y])))))))","problem":94,"user":"4dd62278535d2dad7130b5c7"},{"code":"(fn game-of-life [board]\n  (letfn [(live-cells [ x y]  \n             (count (filter #(= \\# %) \n                            (for [i (range -1 2) j (range -1 2)] \n                              (get-in board [(+ y i) (+ x j)]))))) ]\n         (map #(apply str %) (partition (count (first board)) \n         (for [y (range (count (first board))) x (range (count  board))]\n            (let [cell (get-in board [y x])\n                  alive (= \\# cell)]\n              (cond\n                (and alive (< (live-cells x y) 3)) \\space\n                (and alive (> (live-cells x y) 4)) \\space\n                (and (not alive) (= (live-cells x y) 3)) \\#\n                :default cell)))))\n  ))","problem":94,"user":"4fccdc75e4b0ee37620e186d"},{"code":"(fn [input]\n  (let [field (vec (map vec input))\n        cols  (count (first field))\n        rows  (count field)\n        get-at (fn [[x y]]\n                 ((field y) x))\n        neighbours (fn [[x y]]\n                     (count\n                      (filter #(and (not= [x y] %)\n                                    (not-any? neg? %)\n                                    (and (< (first %) cols) \n                                         (< (last %) rows))\n                                    (= (get-at %) \\#))\n                              (for [a (range -1 2) b (range -1 2)] \n                                [(+ x a) (+ y b)]))))\n        new-sym (fn [n-cnt cur]\n                  (cond (= n-cnt 2) cur\n                        (= n-cnt 3) \\#\n                        :else \\space))\n        next-board (fn []\n                     (vec (map #(apply str %)\n                               (partition cols (map #(new-sym (neighbours %) (get-at %))\n                                                    (for [x (range cols) y (range rows)] [y x]))))))]\n    (next-board)))","problem":94,"user":"4e68b46c535d8ccf87e9fe87"},{"code":"(fn [m]\r\n  (let [\r\n\t\tfrom-t-map (fn [tm] (vec (map (fn [s] (apply str (map #(if (true? %) \\# \\space) s))) tm)))\r\n\t\tcell (fn [m [x y]]\r\n\t\t\t\t(if (and (< -1 x (count (nth m 0))) (< -1 y (count m)))\r\n\t\t\t\t\t(= (nth (nth m y) x) \\#)\r\n\t\t\t\t\tfalse))\r\n\t\tneighbours (fn [x y] (for [dx (range -1 2) dy (range -1 2) :when (not= dx dy 0)] [(+ x dx) (+ y dy)]))\r\n\t\talive-neighbours (fn [m [x y]] (count (filter true? (map (partial cell m) (neighbours x y)))))\r\n\t\twill-live? (fn [m [x y]]\r\n\t\t\t\t\t\t(let [is-alive (cell m [x y]) alive-ns (alive-neighbours m [x y])]\r\n\t\t\t\t\t\t\t(if is-alive\r\n\t\t\t\t\t\t\t\t(< 1 alive-ns 4)\r\n\t\t\t\t\t\t\t\t(= 3 alive-ns))))\r\n\t\t]\r\n\t\t(from-t-map \r\n\t\t\t(partition (count (first m))\r\n\t\t\t\t(map (partial will-live? m) \r\n\t\t\t\t\t(for [y (range (count m)) x (range (count (first m))) ] [x y]))))))","problem":94,"user":"503e7f06e4b06c4e0e1fa268"},{"code":"#(vec (map (partial apply str)\n           (for [i (range (count %))]\n             (for [j (range (count (first %)))]\n               (let [c (count (filter (partial = \\#) (map (partial get-in %) (vec (map vec\n                                                                                       (for [a [(dec i) i (inc i)]\n                                                                                             b [(dec j) j (inc j)]\n                                                                                             :when (not (and (= a i)\n                                                                                                             (= b j)))]\n                                                                                           [a b]))))))]\n                 (case (get-in % [i j])\n                   \\  (case c 3 \\# \\ )\n                   (case c\n                     2 \\#\n                     3 \\#\n                     \\ ))))))\n               )","problem":94,"user":"50a83315e4b054305ba5a830"},{"problem":94,"code":"(fn [board]\n  (letfn [(map-board [f]\n            (vec (map-indexed (fn [ridx row]\n                                (apply str (map-indexed (fn [cidx cell]\n                                                          (f cell ridx cidx))\n                                                        row)))\n                              board)))\n          (format-cell [kw]\n            (if (= :alive kw) \"#\" \" \"))\n          (alive? [cell]\n            (= cell \\#))\n          (neighbors-of [row col]\n            (set (for [nbor-row (range (dec row) (+ 2 row))\n                       nbor-col (range (dec col) (+ 2 col))\n                       :when (not (and (= nbor-row row) (= nbor-col col)))]\n                   [nbor-row nbor-col])))\n          (in-board? [dim [row col]]\n            (and\n             (>= row 0)\n             (>= col 0)\n             (< row dim)\n             (< col dim)))\n          (valid-neighbors-of [dim row col]\n            (set (filter (partial in-board? dim) (neighbors-of row col))))\n          (count-alive-neighbors-of [row col]\n            (count (filter alive? (for [[nbor-row nbor-col] (valid-neighbors-of (count board) row col)]\n                                    (get-in board [nbor-row nbor-col])))))\n          (cell-next-generation [cell row col]\n            (let [alive-cell (alive? cell)\n                  alive-nbor-count (count-alive-neighbors-of row col)]\n              (cond\n                (and alive-cell (< alive-nbor-count 2)) :dead\n                (and alive-cell (contains? #{2 3} alive-nbor-count)) :alive\n                (and alive-cell (> alive-nbor-count 3)) :dead\n                (and (not alive-cell) (= 3 alive-nbor-count)) :alive\n                :else :dead)))]\n    (map-board\n     (fn [cell row col]\n       (format-cell (cell-next-generation cell row col))))))","user":"5344fe13e4b084c2834f4a32"},{"problem":94,"code":"(letfn\n  [\n   (num-nabours [graph [x y]]\n                (count (filter #(= % \\#) (for [i [[(inc x) y] [(inc x) (inc y)] [x (inc y)] [(dec x) (inc y)] [(dec x) y] [(dec x) (dec y)] [x (dec y)] [(inc x) (dec y)]]]\n                                           (get-in graph i 0)))))\n   (rules [graph [x y]]\n          (let [n (num-nabours graph [x y])]\n            (if (= (get-in graph [x y]) \\#)\n              (cond\n                (< n 2) \\space\n                (< n 4) \\#\n                :else \\space)\n              (if (= n 3) \\# \\space))))\n   ]\n  (fn [graph]\n    (into\n     []\n     (for\n      [x (range (count graph))]\n       (apply\n        str\n        (for [y (range (count (first graph)))] (rules graph [x y])))))))","user":"5c683fb5e4b0fca0c16226d5"},{"problem":94,"code":"(fn [board]\n                  (let [vboard    (vec (map vec board))\n                        rows      (count vboard)\n                        cols      (-> board first seq count)\n                        neighbors (fn [row col] \n                                    (for [i (range (dec row) (+ row 2))\n                                          j (range (dec col) (+ col 2))]\n                                      (when (and (>= i 0)\n                                                 (>= j 0)\n                                                 (> rows i)\n                                                 (> cols j)\n                                                 (not (and (= i row)\n                                                           (= j col))))\n                                        (get-in vboard [i j]))))\n                        new-board (for [i (range rows)]\n                                    (for [j (range cols)]\n                                      (let [cell (get-in vboard [i j])\n                                            nn   (neighbors i j)\n                                            n    (->> (neighbors i j)\n                                                      (filter #(= \\# %1))\n                                                      count)]\n                                        (cond\n                                          (and (= \\# cell) (< n 2))     \\space\n                                          (and (= \\# cell) (<= 2 n 3))  \\#\n                                          (and (= \\# cell) (> n 3))     \\space\n                                          (and (= \\space cell) (= n 3)) \\#\n                                          :else                         \\space))))\n                        new-board (->> new-board (map #(apply str %1)) vec)]\n                    new-board))","user":"5beadeb5e4b0f319e2d7ec88"},{"problem":94,"code":"(fn gameoflife [input]\n  (let [matrix (into [] (map #(into [] (map str (seq %))) input))\n        m-size (count matrix)\n        get-neighbors (fn [point offsets max-xy]\n                        (filter (fn [[x y]]\n                                  (and (> x -1) (< x max-xy) (> y -1) (< y max-xy)))\n                                (mapcat #(map (fn [opr] (map opr point %)) [+ -]) offsets)))]\n    (map #(clojure.string/join #\"\" %) (partition\n      m-size\n      (for [i (range (count matrix))\n            j (range (count matrix))\n            :let [elem (get-in matrix [i j])\n                  neighbors (map #(get-in matrix %) (get-neighbors [i j] [[1 0] [0 1] [1 1] [-1 1]] m-size))]]\n        (let [live-neighbors (count (filter #{\"#\"} neighbors))]\n          (if (= elem \" \")\n            (if (= 3 live-neighbors) \"#\" \" \")\n            (cond (< live-neighbors 2) \" \"\n                  (> live-neighbors 3) \" \"\n                  :else \"#\"))))))))","user":"5ef5ee81e4b07c55ae4a054a"},{"code":"(fn life [v]\n  (letfn[(get-live-locs [v]\n           (set (filter (comp not nil?)\n                        (for [i (range (count v)) j (range (count (first v)))]\n                          (if (= (get-in v [i j]) \\#) [i j])))))\n         (shift-shape [s loc]\n           (set (map (fn [v] [(+ (first v) (first loc)) (+ (last v) (last loc))]) s)))\n         (count-env [v cell]\n           (let [s [[-1 -1] [-1 0] [-1 1] [0 -1] [0 1] [1 -1] [1 0] [1 1]]]\n             (count\n              (filter #(= % \\#)\n                      (map #(get-in v %)\n                           (map (fn [x] [(+ (x 0) (cell 0)) (+ (x 1) (cell 1))]) s))))))\n         (check-cell [v live-locs cell]\n           (let [live? (if (nil? (live-locs cell)) false true)\n                 count (count-env v cell)]\n             (if live?\n               (cond (< count 2) \\space\n                     (< count 4) \\#\n                     :else \\space)\n               (cond (= count 3) \\#\n                     :else \\space))))\n         (next-gen [v]\n           (let [live-locs (get-live-locs v)]\n             (set (for [i (range (count v)) j (range (count (first v)))\n                        :when (= (check-cell v live-locs [i j]) \\#)] [i j]))))\n         (print-locs [locs n m]\n           (vec\n            (map clojure.string/join\n                 (partition m\n                            (clojure.string/join\n                             (for [i (range n) j (range m)]\n                               (if (nil? (locs [i j])) \\space \\#)))))))]\n    (print-locs (next-gen v) (count v) (count (v 0)))))","problem":94,"user":"50733b31e4b0e3170b5a869a"},{"code":"(fn [ls]\r\n  (letfn [\r\n    (get-cell [ls i j]\r\n      (map #(get-in ls %) [[(dec i) (dec j)] [(dec i) j] [(dec i) (inc j)]\r\n                           [i (dec j)] [i (inc j)]\r\n                           [(inc i) (dec j)] [(inc i) j] [(inc i) (inc j)]]))\r\n    (count-alive [ls] (count (filter #{\\#} ls)))\r\n    (next-iter [alive? alive-n-cnt]\r\n      (cond\r\n        (and alive? (or (= alive-n-cnt 2) (= alive-n-cnt 3))) \\#\r\n        (and (not alive?) (= alive-n-cnt 3)) \\#\r\n        :else \\space))\r\n    (f [ls]\r\n      (for [x (range (count ls)) y (range (count (first ls)))]\r\n        (next-iter (= (get-in ls [x y]) \\#) (count-alive (get-cell ls x y)))))]\r\n    (map #(apply str %) (partition (count (first ls)) (f ls)))))","problem":94,"user":"5003ee7de4b0678c553fc446"},{"problem":94,"code":"(fn [board]\n   (let [max-x (count (first board))\n         max-y (count board)]\n     (letfn [(live?\n               [cell]\n               (= \"#\" (:content cell)))\n             (neighbour-coordinates\n               [cell-x cell-y]\n               (->> (for [x [(dec cell-x) cell-x (inc cell-x)]\n                          y [(dec cell-y) cell-y (inc cell-y)]]\n                      [x y])\n                    (filter (fn [pos] (not (= pos [cell-x cell-y]))))\n                    (filter (fn [pos] (and (<= (first pos) max-x)\n                                           (<= (second pos) max-y))))))\n             (neighbours\n               [cell]\n               (filter (fn [c] (some #{[(:x c) (:y c)]}\n                                     (neighbour-coordinates (:x cell) (:y cell)))) (cells)))\n             (count-live-neighbours\n               [cell]\n               (reduce (fn [live-count cell]\n                         (if (live? cell) (inc live-count)\n                                          live-count)) 0 (neighbours cell)))\n             (cells []\n               (flatten (map-indexed (fn [row-index row]\n                                       (map-indexed (fn [col-index col]\n                                                      {:x       col-index\n                                                       :y       row-index\n                                                       :content (str col)}) row)) board)))]\n       (map (partial apply str)\n            (partition (count (first board))\n                       (map (fn [cell]\n                              (cond (live? cell)\n                                    (cond (< (count-live-neighbours cell) 2) \" \"\n                                          (< (count-live-neighbours cell) 4) \"#\"\n                                          :else \" \")\n                                    (and ((comp not live?) cell)\n                                         (= (count-live-neighbours cell) 3)) \"#\"\n                                    :else \" \"))\n                            (cells)))))))","user":"4e9ff8d0535d7eef3080729c"},{"code":"(fn prob-0094\n  [layout]\n\n  (letfn [(layout-to-game\n            [layout]\n            {:dims [(count layout) (apply max (map #(count %) layout))]\n             \n             :men  (into (sorted-set) (for [ri (range (count layout))\n                                            :let [rw (vec (layout ri))]\n                                            ci (range (count rw))\n                                            :when (= \\# (rw ci))]\n                                        [ri ci]))})\n\n          (add-vv\n            [v1 v2]\n            (vec (map #(+ %1 %2) v1 v2)))\n\n          (life-next-gen\n            [{:keys [dims men] :as game}]\n            (let [deltas (filter #(not= [0, 0] %) (map vec (for [ro (range -1 2)\n                                                                 co (range -1 2)]\n                                                             [ro co])))\n\n                  nxt-gen (into (sorted-set) (for [ri (range (first  dims))\n                                                   ci (range (second dims))\n                                                   :let [n-idxs (map #(add-vv [ri ci] %) deltas)\n                                                         n-cnt  (count (filter #(contains? men %) n-idxs))\n                                                         pos    [ri ci]]\n                                                   :when (or\n                                                          (= 3 n-cnt)\n                                                          (and (= 2 n-cnt) (contains? men pos)))]\n                                               pos))]\n              (assoc game :men nxt-gen)))\n\n          (game-to-layout\n            [{:keys [dims men] :as game}]\n            (into [] (for [ri (range (first dims))]\n                       (apply str (for [ci (range (second dims))]\n                                    (if (contains? men [ri ci]) \\# \\space))))))\n          ]\n    \n  (game-to-layout (life-next-gen (layout-to-game layout)))))","problem":94,"user":"4f047c07535dcb61093f6bcd"},{"problem":94,"code":"(fn self [in-board]\n    (let [board (mapv vec in-board)\n          neighbor-rel-indices [[-1  1] [0  1] [1  1]\n                                [-1  0]        [1  0]\n                                [-1 -1] [0 -1] [1 -1]]\n          fate (fn [v neighor-type-counts]\n                 (case v\n                   \\# (cond\n                        (#{0 1} (neighor-type-counts \\#)) \\space\n                        (#{2 3} (neighor-type-counts \\#)) \\#\n                        (> 3 (neighor-type-counts \\#)) \\space\n                        :else \\space ; no live neighbors\n                        )\n                   \\space (if (= 3 (neighor-type-counts \\#))\n                            \\#\n                            \\space)))\n          next-board (fn [b] (for [x (range (count (b 0)))\n                                   y (range (count b))\n                                   :let [v (get-in b [x y])]\n                                   :let [neighbor-indices (mapv (fn [[i j]] [(+ x i) (+ y j)]) neighbor-rel-indices)]\n                                   :let [neighbor-values (filterv (comp not nil?) (mapv (fn [i_j] (get-in b i_j)) neighbor-indices))]\n                                   :let [neighor-type-counts (frequencies neighbor-values)]]\n                                 (fate v neighor-type-counts)\n                               ))]\n      (mapv (fn [x] (apply str x)) (partition (count board) (next-board board)))\n      ))","user":"52ffb7f2e4b0d8b024fd370b"},{"problem":94,"code":"(fn [gen]\n  (let [gen  (vec (map vec gen))\n        w    (count gen)\n        nbrs (fn [i j]\n               (reduce \n                 + (for [x (range -1 2)\n                         y (range -1 2)\n                         :when \n                         (and (not= [0 0] [x y])\n                              (= \\# (get-in gen [(+ i x) \n                                                 (+ j y)])))]\n                     1)))]\n    (for [i (range w)]\n      (apply str\n             (for [j (range w)\n                   :let [x (nbrs i j)]]\n               (if (some #{0 (dec w)} [i j])\n                 \\space\n                 (condp > x\n                   2 \\space\n                   3 (get-in gen [i j]) \n                   4 \\#\n                   \\space)))))))","user":"53dfdf01e4b0d874e779ae46"},{"problem":94,"code":"(fn [b]\n  (letfn [(ln [x y]\n             (->> (for [i [-1 0 1] j [-1 0 1] :when (not= 0 i j)]\n                    (get-in b [(+ i x) (+ j y)]))\n                  (filter #(= \\# %)) count))]\n    (->> (for [x (range (count b))\n               y (range (count (first b)))]\n           ({3 \\# 2 (get-in b [x y])} (ln x y) \" \"))\n         (partition (count b))\n         (map #(apply str %)))))","user":"548b8a50e4b0e286459a11ff"},{"code":"(fn [board]\n  (letfn [\n    (row-to-ints     [row] (map #(if (= \\# %) 1 0) row))\n    (row-to-bools    [row] (map #(= \\# %) row))\n    (shift-row-right [row] (cons 0 row))\n    (shift-row-left  [row] (conj (vec (rest row)) 0))\n    (shift-board-up   [rows] (conj (vec (rest rows)) (map (partial * 0) (first rows))))\n    (shift-board-down [rows] (cons (map (partial * 0) (first rows)) rows))\n    (add-boards [a b] (map (partial map +) a b))\n    (count-neighbors [board]\n      (reduce add-boards \n        [ (shift-board-up board)\n          (shift-board-down board)\n          (map shift-row-right board)\n          (map shift-row-left board)\n          (shift-board-up (map shift-row-right board))\n          (shift-board-up (map shift-row-left board))\n          (shift-board-down (map shift-row-right board))\n          (shift-board-down (map shift-row-left board))]))\n    (simulate [cell neighbor-count]\n      (cond\n        (and cell (< neighbor-count 2)) false\n        (and cell (< neighbor-count 4)) true\n        (and (not cell) (= neighbor-count 3)) true\n        :else false))\n    (print-board [board]\n      (map (fn [row] (apply str (map #(if % \\# \" \") row))) board))]\n    (print-board\n      (map (partial map simulate)      \n        (map row-to-bools board)\n        (count-neighbors (map row-to-ints board))))))","problem":94,"user":"521e8227e4b0dd19981ad082"},{"code":"(fn [board] (letfn [\n(dimensions [rect] (vector (apply max (map count rect)) (count rect)))\n(pairs [coll1 coll2] (map (fn [x] (map #(vector x %) coll2)) coll1))\n(dimensions [rect] (vector (count rect) (apply max (map count rect))))\n(positions [rect] (pairs (range (first (dimensions rect))) (range (second (dimensions rect)))))\n(neighbour-positions [position] (remove #(= position %) (map (fn [diff] (map + diff position)) (mapcat identity (pairs [-1 0 +1] [-1 0 +1])))))\n(on-board? [board [row col]] (and (>= row 0) (>= col 0) (<= row (dec (first (dimensions board)))) (<= col (dec (second (dimensions board))))))\n(neighbour-positions-on-board [board position] (filter #(on-board? board %) (neighbour-positions position)))\n(alive? [val] (= \\# val))\n(dead? [val] (= \\space val))\n(own-status [board position] (get-in board position))\n(neighbour-statuses [board position] (map #(get-in board %) (neighbour-positions-on-board board position)))\n(number-of-live-neighbours [board position] (count (filter alive? (neighbour-statuses board position))))\n(next-round-status [board position] (cond (and (dead? (own-status board position)) (= (number-of-live-neighbours board position) 3)) \\# (and (alive? (own-status board position)) (< (number-of-live-neighbours board position) 2)) \\space (and (alive? (own-status board position)) (> (number-of-live-neighbours board position) 3)) \\space :else (own-status board position)))\n(next-round-board [board] (map (fn [row] (map #(next-round-status board %) row)) (positions board)))\n(next-round [board] (map #(apply str %) (next-round-board board)))\n] (next-round board)))","problem":94,"user":"52f10094e4b05e3f0be25ee8"},{"problem":94,"code":"(fn [board]\n                (let [element-len (count (first board))\n                      transfer (mapv #(mapv (fn [i] (if (= i \\#) 1 0)) (seq %)) board)\n                      get-sum (fn [t x y]\n                                (let [a (nth t (- y 1))\n                                      b (nth t y)\n                                      c (nth t (+ y 1))\n                                      v (- x 1)\n                                      z (+ x 1)]\n                                  (+\n                                   (nth a v) (nth b v) (nth c v)\n                                   (nth a z) (nth b z) (nth c z)\n                                   (nth a x) (nth c x))))\n                      cal-sum (for [x (range 1 (- element-len 1))]\n                                (for [y (range 1 (- element-len 1))]\n                                  {:x (nth (nth transfer x) y)\n                                   :f (get-sum transfer y x)}))\n                      cc (mapv #(conj (reduce (fn [m n] (conj m (cond\n                                                                  (> 2 (:f n)) 0\n                                                                  (and (= 3 (:f n)) (zero? (:x n))) 1\n                                                                  (> 4 (:f n)) (:x n)\n                                                                  (> 3 (:f n)) 0\n                                                                  :else 0\n                                                                  ))) [0] %) 0) cal-sum)\n                      dd (reduce #(conj %1 %2) [] (take element-len (repeat 0)))\n                      ee (conj (reduce #(conj %1 %2) [dd] cc) dd)]\n                  (mapv #(reduce (fn [x y] (str x (if (= y 1) \\# \" \"))) \"\" %) ee)))","user":"5cf72682e4b0b71b1d808a68"},{"problem":94,"code":"(fn nextGen [b]\n  (let [b' (vec (map vec b))\n        getCell (fn [x y] (get (get b' y []) x \\space))\n        countNeighbors \n          (fn [x y]\n            (let [offsets [[-1 -1] [-1 0] [-1 1] [0 -1] [0 1] [1 -1] [1 0] [1 1]]]\n              (count (for [[dx dy] offsets\n                           :when (= \\# (getCell (+ x dx) (+ y dy)))]\n                       \\#))))]\n    (for [y (range (count b'))]\n      (->> (for [x (range (count (get b' y)))]\n             (let [n (countNeighbors x y)]\n               (if (= (getCell x y) \\space)\n                 (if (= 3 n) \\# \\space)\n                 (if (or (= 2 n) (= 3 n)) \\# \\space))))\n        (apply str)))))","user":"559454f2e4b0c79f6e1db952"},{"problem":94,"code":"(fn game-of-life-step [[first-row :as board]]\n  (let [neighbours (fn [[row col]] \n                     (set (for [i (range (dec row) (+ 2 row))\n                                j (range (dec col) (+ 2 col))\n                                :when (and (not= [i j] [row col])\n                                           (>= row 0)\n                                           (>= col 0)\n                                           (< row (count board))\n                                           (< col (count first-row)))]\n                             [i j])))\n        alive-now? (fn [alive-state] (= alive-state \\#))\n        alive-state (fn [[row col]] (get-in board [row col]))\n        alive-in-next-state? (fn [cell-alive neighbours] \n                               (#{[true 2] [true 3] [false 3]} \n                                 [cell-alive (count (filter identity neighbours))]))\n        coordinates (for [row (range (count board)) \n                          col (range (count first-row))] \n                      [row col])\n        alive-symbol (fn [alive-state?] (if alive-state? \\# \\space))]\n    (->> coordinates\n         (map (->> neighbours\n                   (comp (partial map (comp alive-now? alive-state)))\n                   (juxt (comp alive-now? alive-state))\n                   (comp alive-symbol (partial apply alive-in-next-state?))))\n         (partition (count first-row))\n         (map (partial apply str)))))","user":"5c506951e4b0f9f7a8770ec5"},{"problem":94,"code":"(fn next-gen [board]\n  (let [live? #(= \\# %)\n        live-neighbors\n        (fn [i j]\n          (count\n            (filter live?\n                    (for [x [-1 0 1]\n                          y [-1 0 1]\n                          :when (not (and (zero? x) (zero? y)))]\n                      (get-in board [(+ i x) (+ j y)])))))\n        rows (count board)\n        cols (count (first board))]\n    (for [i (range rows)]\n      (apply str\n             (for [j (range cols)]\n               (let [good-neighbor-count?\n                     (if (live? (get-in board [i j]))\n                       #{2 3} #{3})]\n                 (if (good-neighbor-count? (live-neighbors i j))\n                   \\#\n                   \\space)))))))","user":"5d24e49be4b02ea6f0fb6a2a"},{"problem":94,"code":"(fn [board]\n  (letfn [(get-cell [r c] (nth (nth board r) c))\n          (neighbors [r c]\n            (for [x [-1 0 1] y [-1 0 1]\n                  :let [nr (+ r x)\n                        nc (+ c y)]\n                  :when (and (>= nr 0)\n                             (>= nc 0)\n                             (< nr (count board))\n                             (< nc (count (first board)))\n                             (not (and (= nr r)\n                                       (= nc c))))] [nr nc]))\n          (get-alive-count [r c] ((frequencies (map #(apply get-cell %) (neighbors r c))) \\#))\n          (alive-rules [live-count]\n            (cond (< live-count 2) \\space\n                  (> live-count 3) \\space\n                  :else \\#))\n          (dead-rules [live-count]\n            (if (= live-count 3) \\# \\space))\n          (new-state [r c]\n            (let [cell (get-cell r c)\n                  alive-count (get-alive-count r c)]\n              (if (= cell \\#) (alive-rules alive-count)\n                  (dead-rules alive-count))\n              )\n            )\n          ]\n    (map #(apply str %)\n         (map-indexed (fn [r row]\n                   (map-indexed (fn [c col] (new-state r c)) row)) board))\n    )\n  )","user":"589037b4e4b00487982d51d0"},{"code":"(fn [l]\n  (let [row (count l),\n        col (count (first l)),\n        cross (fn [lst1 lst2]\n                ((fn [l1 l2 res]\n                   (if (empty? l2) res\n                     (if (empty? l1)\n                       (recur lst1 (rest l2) res)\n                       (recur (rest l1) l2 (conj res (vector (first l1) (first l2)))))))\n                 lst1 lst2 #{})),\n        cells (cross (map dec (range (+ row 2))) (map dec (range (+ col 2)))),\n        out? (fn [v] (or (= (first v) -1) (= (first v) row) (= (second v) -1) (= (second v) row))),\n        alive? (fn [v] (and (not (out? v)) (= (nth (nth l (first v)) (second v)) \\#))),\n        board (reduce #(assoc %1 %2 (alive? %2)) {} cells),\n        neighbors (fn [[i j]] (disj (cross (vector (- i 1) i (+ i 1)) (vector (- j 1) j (+ j 1))) (vector i j))),\n        next-cell (fn [[v liv] b]\n                    (if (out? v) false\n                      (let [num-live-neigh (reduce #(+ %1 (if (get board %2) 1 0)) 0 (neighbors v))]\n                        (if (alive? v) (or (= num-live-neigh 2) (= num-live-neigh 3))\n                          (= num-live-neigh 3))))),\n        next-board (fn [b] (reduce #(assoc %1 (first %2) (next-cell %2 b)) {} b)),\n        printer (fn [b]\n                  ((fn [i j res sub]\n                     (cond (= i row) (map #(apply str %) res)\n                           (= j col) (recur (+ i 1) 0 (conj res sub) [])\n                           :else (recur i (+ j 1) res (conj sub (if (get b (vector i j)) \\# \\space)))))\n                   0 0 [] []))]\n    (printer (next-board board))))","problem":94,"user":"51da631be4b02ceefd947766"},{"code":";; This is buggy! It assumes the edge squares are always blank.\n;; However, a proper implementation of this (with a\n;; get-cell that does edge checking and properly handles edges)\n;; regularly times out the 4clojure site despite working\n;; fine on my commandline. Boo to that.\n;; This at least runs in their terp.\n(fn [grid]\n    (let [neighbors (fn [row col]\n                      (count (filter #(= % \\#)\n                                     (apply concat (map #(take 3 (drop col %))\n                                          (take 3 (drop row grid)))))))\n          next-cell (fn [row col]\n                      (let [us (nth (nth grid (inc row)) (inc col))\n                            them (neighbors row col)]\n                        (cond (and (= us \\space) (= them 3)) \\#\n                              (and (= us \\#) (= them 3)) \\#\n                              (and (= us \\#) (= them 4)) \\#\n                              true \\space)))\n          next-row (fn [row]\n                     (apply str (concat \" \" (map (partial next-cell row) (range (- (count (nth grid row)) 2))) \" \")))]\n      (conj (into [(first grid)] (map next-row (range (- (count grid) 2)))) (last grid))))","problem":94,"user":"4fe8aef4e4b07c9f6fd12c6c"},{"code":"(fn next-board[board]\n  (let\n    [lookup (fn [x y]\n     (if (or (= x -1) (= y -1))\n         nil\n        (->> (drop y board) first (drop x) first )))\n    \n     alive (fn ([x y]  (= \\# (lookup x y)))\n               ([cell] (= \\# cell)))\n    \n     num-alive-around (fn [x y]\n      (apply +\n        (for [a (range (- x 1) (+ x 2))\n              b (range (- y 1) (+ y 2))\n              :when (not= [a b] [x y])]\n          (if (alive a b) 1 0))))\n    \n     next-cell (fn [x y cell]\n      (let [num-alive (num-alive-around x y)]\n        (if (alive cell)\n            (if (#{2 3} num-alive) \\# \\space)\n            (if (= 3 num-alive) \\# \\space))))]\n  \n    (map-indexed\n      (fn [y row] (clojure.string/join (map-indexed #(next-cell %1 y %2) row)))\n      board)))","problem":94,"user":"4f725466e4b07046d9f4f030"},{"problem":94,"code":"(fn [b]\n  (let [ib (->> b\n                (map #(map vector (range) %))\n                (map vector (range)))\n        mb (reduce (fn [map [i r]]\n                     (reduce (fn [map [j c]]\n                               (assoc map [i j] c)) map r)) {} ib)\n        l \\#\n        d \\space]\n    (reduce (fn [b [i r]]\n              (->> r\n                   (reduce (fn [r [j c]]\n                             (let [ir (range (dec i) (+ i 2))\n                                   jr (range (dec j) (+ j 2))\n                                   a (->> ir\n                                          (map (fn [i']\n                                                 (map (fn [j']\n                                                        (if (and (= i' i) (= j' j))\n                                                          nil\n                                                          (get mb [i' j']))) jr)))\n                                          flatten\n                                          (filter #(= \\# %))\n                                          count)\n                                   s (get mb [i j])\n                                   s' (condp = s\n                                          \\# (cond\n                                               (< a 2) d\n                                               (or (= a 2) (= a 3))l\n                                               (> a 3) d)\n                                          \\space (if (= a 3)\n                                                   l\n                                                   d))]\n                               (str r s'))) \"\")\n                   (conj b))) [] ib)))","user":"55316b8ae4b076ab5578f825"},{"problem":94,"code":"(fn [m]\n    (let [w (count (first m))\n          h (count m)\n          p #(and (<= 0 %1)\n                  (< %1 w)\n                  (<= 0 %2)\n                  (< %2 h)\n                  (= \\# (nth (m %2) %1)))]\n      (vec (for [y (range h)]\n             (apply str (for [x (range w)\n                              :let [c (count (for [dx [-1 0 1]\n                                                   dy [-1 0 1]\n                                                   :when (p (+ x dx) (+ y dy))]\n                                               1))]]\n                          (if (if (p x y) (#{3 4} c) (= 3 c)) \\# \\space)))))))","user":"4f5eda39e4b0030a34fb2b56"},{"problem":94,"code":"(letfn [(transpose [m] (apply map vector m))\n        (translate [m] (map (partial map {\\space 0 \\# 1}) m))\n        (pad [m] (let [r (repeat (count (first m)) 0)] (concat [r] m [r])))\n        (expand [m] (map (comp #(partition 3 1 %)) m))\n        (squash [mm] (map #(map (partial apply +) %) mm))]\n  (fn [b]\n    (let [f (comp squash expand transpose pad)\n          bb (f (f (translate b)))]\n      (map (comp (partial apply str) (fn [rb rbb] (map #(condp = %1\n                                                         0 (if (= 3 %2) \\# \\space)\n                                                         1 (cond\n                                                             (or (> %2 4) (< %2 3)) \\space\n                                                             :e \\#)\n                                                         ) rb rbb))) (translate b) bb))))","user":"554680cbe4b0a04f7929953e"},{"code":"(fn gol [b]\n    (let [l (count b)\n            n (count (first b))\n            nb (fn [[s & r :as m] [a b :as c]]                 \n                   (for [x [-1 0 1]\n                           y [-1 0 1]\n                           :let [k (+ a x)\n                                   p (+ b y)\n                                   d [k p]]\n                           :when (and (<= 0 k) (<= 0 p)\n                                      (< k n)  (< p n)\n                                      (not= c d))]\n                        d))\n            cn (fn [m c]\n                   (reduce (fn [s c]\n                              (if (= \\# (get-in m c)) (+ s 1) s)) 0\n                              (nb m c)))\n            ng (fn [m c]\n                   (let [v (get-in m c)\n                           a (= \\# v)\n                           n  (cn m c)]\n                     (cond\n                      (and a       (< n 2))    \\ \n                      (and a       (<= 2 n 3)) \\#\n                      (and a       (< 3 n))    \\ \n                      (and (not a) (= 3 n))    \\#\n                      :else v)))]\n      (map #(apply str %)\n            (partition n\n                       (for [y (range l) x (range n)]\n                            (ng b [y x]))))))","problem":94,"user":"4ee9ddb8535d93acb0a66896"},{"code":"(fn __ [board]\n  (let [b (apply str board) dims (count board)]\n  (letfn [(live-neighbors [n]\n             (let [W  (when (and (> (dec n) -1) (not= 0 (mod n dims)))\n                            (dec n))\n                   E  (when (and (< (inc n) (* dims dims)) (not= (dec dims) (mod n dims)))\n                            (inc n))\n                   N  (when (> (- n dims) -1)\n                            (- n dims))\n                   S  (when (< (+ n dims) (* dims dims))\n                            (+ n dims))\n                   NW (when (and N (> (dec N) -1) (not= 0 (mod N dims)))\n                        (dec N))\n                   NE (when (and N (< (inc N) (* dims dims)) (not= (dec dims) (mod N dims)))\n                        (inc N))\n                   SW (when (and S (> (dec S) -1) (not= 0 (mod S dims)))\n                        (dec S))\n                   SE (when (and S (< (inc S) (* dims dims)) (not= (dec dims) (mod S dims)))\n                        (inc S))\n                   ]\n               (count\n  \t\t    (filter (partial = \\#) (map #(nth b %)\n                 (filter identity [N E W S NW NE SW SE]))))))\n          (step [idx v]\n                (cond\n                 ; reproduction\n                 (and (= \\space v)\n                      (= 3 (live-neighbors idx))) \\#\n                 ; overcrowding\n                 (and (= \\# v)\n                      (< 3 (live-neighbors idx))) \\space\n                 ; next gen\n                 (and (= \\# v)\n                      (or (= 2 (live-neighbors idx)) (= 3 (live-neighbors idx)))) \\#\n                 ; underpopulation\n                 (and (= \\# v)\n                      (> 2 (live-neighbors idx))) \\space\n                 :else \\space\n                ))]\n    (vec (map (partial apply str) \n         (partition-all dims (map-indexed step b))))\n    )))","problem":94,"user":"4fa719c0e4b081705acca1bf"},{"code":"(fn next-gen [grid]\n  (let [cell? (->> grid\n                   (map-indexed (fn [i r]\n                                  (map-indexed (fn [j c]\n                                                 (if (= \\# c) [i j] nil)) r)))\n                   (apply concat)\n                   (set))\n        ns '([-1 -1] [-1 0] [-1 1] [0 -1] [0 1] [1 -1] [1 0] [1 1])\n        n-count (fn [r c]\n                  (count (filter cell? (map (fn [[x y]]\n                                              [(+ r x) (+ c y)]) ns))))\n        live-map (for [r (range (count grid))]\n                   (for [c (range (count (first grid)))]\n                     (let [n (n-count r c)]\n                       (or (= n 3) (and (cell? [r c]) (= n 2))))))]\n    (map (fn [row] (apply str (map #(if % \\# \\ ) row))) live-map)))","problem":94,"user":"4f6160a7e4b0defedf855fbe"},{"problem":94,"code":"(fn f [s]\n    (let [xs (vec (map #(vec (map (fn [x] x) %)) s))\n          ]\n      (->>\n        (apply conj {}\n               (map (fn [[x y]] [[x y] (map (fn [[nx ny]] (get-in xs [(mod (+ x nx) (count (first xs))) (mod (+ y ny) (count xs))])) (for [i (range -1 2) j (range -1 2) :when (not= i j 0)] [i j]))]) ((fn [xs] (for [x (range (count xs)) y (range (count (first xs)))] [x y])) xs)))\n        (map (fn [[k v]] [k (count (filter #(= \\# %) v))]))\n        (reduce (fn [xs [k v]] (cond (or (< v 2) (> v 3)) (update-in xs k (fn [_] \\space))\n                                     (= v 3) (update-in xs k (fn [_] \\#))\n                                     :else xs\n                                     )) xs)\n        (map #(apply str %))\n        )\n      )\n    )","user":"5921a080e4b09b4ee5954c77"},{"code":"(fn [state]\n    (let [ymax (count state)\n          xmax (count (first state))\n          valid-pos? (fn [[x y]]\n                       (and (>= x 0)\n                            (>= y 0)\n                            (< x xmax)\n                            (< y ymax)))\n          differences (fn [x y]\n                        (for [xdiff [1 0 -1]\n                              ydiff [1 0 -1]\n                              :when (not= 0 xdiff ydiff)      \n                              ]\n                          [(+ x xdiff) (+ y ydiff)]))\n          alive? (fn [[x y]]\n                   (= \\# (get (state y) x)))\n          neighbors (fn [x y]\n                      (filter valid-pos? (differences x y)))\n          live-neighbors (fn [x y]\n                           (filter alive? (neighbors x y)))\n          next (fn [x y]\n                 (let [neighbor-count (count (live-neighbors x y))\n                       current-value (get (state y) x)\n                       ]\n                   (cond (= neighbor-count 3)\n                         \"#\"\n\n                         (and (alive? [x y])\n                              (= neighbor-count 2))\n                         \"#\"\n\n                         :else\n                         \" \")))]\n      (for [y (range ymax)]\n        (clojure.string/join (map #(next % y) (range xmax)))) \n      \n      \n      ))","problem":94,"user":"4daea889edd6309eace4d15b"},{"code":"(fn [b]\n  (let [r (range (count b)) d \\  l \\#\n        o [[-1 -1] [-1 0] [-1 1] [0 -1] [0 1] [1 -1] [1 0] [1 1]]\n        a (fn [p] (count (filter #{l} (map #(get-in b (map + p %)) o))))]\n    (for [y r]\n      (apply str (for [x r\n                       :let [p [y x] s (get-in b p) n (a p)]]\n                   (if (= s l) \n                     (if (<= 2 n 3) l d)\n                     (if (= n 3) l d)))))))","problem":94,"user":"4e52d815535d302ef430da77"},{"problem":94,"code":"(fn [cells]\n  (let [w (count cells)\n        h (count (first cells))\n        live? (fn [x y] (= \\# (get-in cells [y x])))\n        count-lives (fn [cx cy] (count (for [x [(dec cx) cx (inc cx)]\n                                             y [(dec cy) cy (inc cy)]\n                                             :when (live? x y)]\n                                         1)))\n        row (fn [y] (->> (range w)\n                         (map (fn [x]\n                                (let [num-lives (count-lives x y)]\n                                  (if (live? x y)\n                                    (if (#{3 4} num-lives) \"#\" \" \")\n                                    (if (#{3}   num-lives) \"#\" \" \")))))\n                         (apply str)))]\n    (map row (range h))))","user":"583e27e2e4b089d5ab817daa"},{"code":"(fn [board]\n  (let [rmws #(apply str (re-seq #\"\\S\" %))\n        neighbors (fn [x y] (vec (map #(subs % (dec x) (+ x 2)) (subvec board (dec y) (+ y 2)))))\n        live? (fn [x y] (= \\# (get (get board y) x)))\n        edge? (fn [x y] (or (or (= x 0) (= x (dec (count (first board))))) (or (= y 0) (= y (dec (count board))))))\n        nn (fn [x y] (- (count (rmws (apply str (neighbors x y)))) (if (live? x y) 1 0)))\n        nextstate (fn [[x y]] (if (edge? x y) \" \" (let [n (nn x y)] (if (live? x y) (if (or (= n 2) (= n 3)) \"#\" \" \") (if (= n 3) \"#\" \" \")))))\n        nextline (fn [y] (apply str (map nextstate (for [x (range (count (first board))) y [y]] (vec (list x y))))))]\n    (vec (map #(nextline %) (range (count board))))))","problem":94,"user":"51f9b1d0e4b09be9c177e550"},{"problem":94,"code":"(fn [cc]\n   (let [width (count cc)\n         height (count (nth cc 0))\n         get-neighbours (fn [i j]\n                          (map #(-> cc\n                                    (nth (nth % 0))\n                                    (nth (nth % 1)))\n                               (filter (fn [item]\n                                         (let [ii (nth item 0)\n                                               jj (nth item 1)]\n                                           (and (>= ii 0)\n                                                (< ii width)\n                                                (>= jj 0)\n                                                (< jj height))))\n                                       [[(dec i) j]\n                                        [(inc i) j]\n                                        [i (dec j)]\n                                        [i (inc j)]\n                                        [(dec i) (inc j)]\n                                        [(inc i) (inc j)]\n                                        [(dec i) (dec j)]\n                                        [(inc i) (dec j)]])))]\n     (map-indexed (fn [i icc]\n                    (reduce str (map-indexed (fn [j jcc]\n                                               (let [neighbours (get-neighbours i j)\n                                                     live (count (filter #(= % \\#) neighbours))\n                                                     dead (count (filter #(= % \\space) neighbours))]\n                                                 (cond\n                                                   (and (= jcc \\#) (< live 2))\n                                                   \\space\n                                                   (and (= jcc \\#) (or (= live 2) (= live 3)))\n                                                   \\#\n                                                   (and (= jcc \\#) (> live 3))\n                                                   \\space\n                                                   (and (= jcc \\space) (= live 3))\n                                                   \\#\n                                                   :else jcc)))\n                                             icc)))\n                 cc)))","user":"535f0cbde4b04ce2eb3ed2d9"},{"code":"(fn [b]\n  (let [[rows cols] [(count b) (count (first b))]\n        cells (for [y (range rows) x (range cols)] [y x])\n        neigh (fn [[y x]] \n                (let [xi (mod (inc x) cols)\n                      xd (mod (dec x) cols)\n                      yi (mod (inc y) rows)\n                      yd (mod (dec y) rows)]\n                  (set\n                    (for [xx [x xi xd] yy [y yi yd] :when (not (= [x y] [xx yy]))]\n                      [yy xx]))))\n        counts (fn [pos] (frequencies (map (fn [a] (get-in b a)) (neigh pos))))\n        newcell (fn [pos]\n                    (let [me (get-in b pos)\n                          {d \\space a \\#} (counts pos) ]\n                      (println pos \".\" me \".\" d \".\" a \".\")\n                      (if (= me \\space) (if (= a 3) \\# \\space)\n                        (cond\n                          (< a 2) \\space (> a 3) \\space :else \\#))))]\n    (println cols rows)\n    (println (newcell (second cells)))\n    #_(println (neigh [3 3]) (counts [3 3]))\n    (map (partial apply str)\n      (partition cols\n        (map newcell cells)))))","problem":94,"user":"4f03ac2d535dcb61093f6b4a"},{"code":"(fn [coll]\r\n  (let [width (count (first coll))\r\n        border [(apply str (repeat (+ 2 width) \\-))]\r\n        neighbours\r\n        (mapcat\r\n          (fn [rows]\r\n            (map (fn [area] (count (filter #(= \\# %) (flatten area))))\r\n              (partition 3 (apply interleave (map #(partition 3 1 %) rows)))))\r\n          (partition 3 1\r\n            (concat border (map #(str \" \" % \" \") coll) border)))]\r\n    (map #(apply str %)\r\n      (partition width\r\n        (map (fn [[c n]]\r\n               (if (= \\# c)\r\n                 (if (or (= 3 n) (= 4 n)) \\# \\space)\r\n                 (if (= 3 n) \\# \\space)))\r\n          (partition 2 (interleave (apply str coll) neighbours)))))))","problem":94,"user":"4f969214e4b0dcca54ed6cdd"},{"code":"(fn [bd]\n  (letfn [\n    (neighbour-count [bd y x]\n      (count\n        (for [\n          i (range -1 2) \n          j (range -1 2) \n          :when (not= 0 i j)\n          :when (= \\# (get-in bd [(+ y i) (+ x j)]))]\n          1)))]\n    (let [x (count (bd 0)) y (count bd)]\n      (vec \n        (map \n          #(apply str %) \n          (partition x\n            (for [\n              i (range y)\n              j (range x)\n              :let [n (neighbour-count bd i j)]\n              :let [live (= \\# (get-in bd [i j]))]]\n              (if \n                (or \n                  (and live (> n 1) (< n 4))\n                  (and (not live) (= 3 n))) \n                \\# \\space))))))))","problem":94,"user":"4f050dec535dcb61093f6bef"},{"problem":94,"code":"(fn [board](let [rows (count board)\n                  cols (count (first board))\n                  plus-minus (fn [a] [(dec a) a (inc a)])\n                  living? (fn [r c] (= \\# (nth(nth board r) c)))\n                  n (fn [r c] (count(filter true? (for [rs (plus-minus r)\n                                                        cs (plus-minus c)\n                                                        :when (and (not= [rs cs] [r c])(some #(= rs %)(range rows))(some #(= cs %)(range cols)))]\n                                                    (living? rs cs)))))]\n              (apply map str(partition rows  (for [cs (range cols)\n                                                   rs (range rows)]\n                                               (cond \n                                                 (and (= 3 (n rs cs))((complement living?) rs cs)) \"#\"\n                                                 (and (some #(= (n rs cs) %) (range 2 4))(living? rs cs)) \"#\"\n                                                 :else \" \"))))))","user":"566a3a26e4b0a866af689699"},{"code":"#(for [[i r] (map list (range) %)]\n     (apply\n      str\n      (for [[j v] (map list (range) r)]\n        (let [n (reduce +\n                        (for [k [(- i 1) i (+ i 1)]\n                              l [(- j 1) j (+ j 1)]]\n                          ({\\  0 \\# 1}\n                           (get-in % [k l] \\ ))))]\n          ({true \\# false \\ }\n           (boolean\n            (if (= v \\#)\n              (#{3 4} n)\n              (= n 3))))))))","problem":94,"user":"4e5fe31a535d8ccf87e9fe50"},{"code":"(fn [coll]\n  (let [previous\n        (set (mapcat #(mapcat (fn [i x] (if (= x \\#) [[% i]] [])) (range) %2) (range) coll))\n        result (->> previous\n                    (mapcat (fn [[a b]] (for [m [[0 -1 1]]\n                                             x m\n                                             y m\n                                             :when (not= 0 x y)]\n                                         [(+ a x) (+ b y)])))\n                    frequencies\n                    (keep (fn [[cell f]] (if (or (= f 3) (and (previous cell) (= f 2)))\n                                          cell)))\n                    set)]\n    (vec (for [[i row] (map vector (range) coll)]\n           (apply str (for [j (range (count row))]\n                        (if (result [i j]) \"#\" \" \")))))))","problem":94,"user":"507056b8e4b07bd6ad9b9f29"},{"code":"(fn game [lines]\r\n  (letfn [\r\n    (dmap [f & ss] (apply (partial map (partial map f)) ss))\r\n    (sisu [f s]\r\n      (concat \r\n        (list (first s))\r\n        (reduce (partial map f) (take 3 (iterate rest s)))\r\n        (list (first s))))\r\n    (convert [v] (get {\\space 0, \\# 1, 0 \\space, 1 \\#} v))\r\n    (convertlines [lines] (dmap convert lines))\r\n    (solve [lines]\r\n      (dmap #(get {[1 3] 1, [1 4] 1, [0 3] 1} [%1 %2] 0)\r\n        lines\r\n        (sisu (partial map +) \r\n          (map (partial sisu +) lines))))]\r\n  (map \r\n    (partial apply str)\r\n    (convertlines (solve (convertlines lines))))))","problem":94,"user":"4f569218e4b0a7574ea71826"},{"problem":94,"code":"(fn _94_ [board]\n  (letfn [(neighbour-index [i j]\n            (for [fi [dec identity inc]\n                  fj [dec identity inc]\n                  :when (not (and (= fi identity) (= fj identity)))]\n              [(fi i) (fj j)]))\n\n          (count-neighbours [board i j]\n            (count\n             (filter #(= \\# (get-in board %)) (neighbour-index i j))))\n          (next-board [board]\n            (->>\n             (for [i (range (count board))]\n               (for  [j (range (count (first board)))]\n                 (let [this (get-in board [i j])\n                       nbs (count-neighbours board i j)]\n                   (cond\n                     (and (= this \\#) (or (< nbs 2) (> nbs 3)))  \\space\n                     (and (= this \\#) (or (= nbs 2) (= nbs 3))) \\#\n                     (and (= this \\space) (= nbs 3)) \\#\n                     :else \\space))))\n             (map #(apply str %))))]\n    (next-board board)))","user":"5fa74b82e4b0fa27300f3dda"},{"problem":94,"code":"(fn [chessboard]\n    (let [nrow (count chessboard)\n          ncol (count (nth chessboard 0))\n          ; 根据下标获取元素\n          get-coord (fn [x y] (nth (nth chessboard x) y))\n          ; 相邻生命的坐标\n          coords (fn [x y] (filter \n                              #(let [row-num (first %)\n                                     col-num (last %)] \n                                ; 过滤越界的坐标\n                                (and (>= row-num 0) \n                                     (>= col-num 0)\n                                     (< row-num nrow) \n                                     (< col-num ncol)))\n                              ; 当前坐标周围的八个坐标（笛卡尔积）\n                              (for [xx [(dec x) x (inc x)]\n                                    yy [(dec y) y (inc y)] \n                                        :when (not (and (= xx x) (= yy y)))]\n                                    [xx yy])))\n          ; 相邻的生命\n          neighbors (fn [x y] (map (partial apply get-coord) (coords x y)))\n          ; 相邻生命状态是live（#）的个数\n          nlive (fn [x y] (count (filter #(= \\# %) (neighbors x y))))\n          ; 下一轮的状态（一维数组）\n          result (for [x (range 0 nrow)\n                       y (range 0 ncol)] \n                    (let [element (get-coord x y)\n                          live-num (nlive x y)]\n                        (if (= \\# element)\n                            ; live状态的生命周围如果有2个或3个生命是live的，则下轮继续存活，否则死亡\n                            (if (or (< live-num 2) (> live-num 3)) \\space \\#)\n                            ; die状态的生命周围如果有刚好3个生命是live的，则下轮复活，否则死亡\n                            (if (= live-num 3) \\# \\space))))]\n          ; 把结果转成4Clojure需要的形式\n          (map (partial apply str) (partition ncol result))))","user":"5507cfd3e4b021ccfedb96ad"},{"problem":94,"code":"(fn [board]\n\n            (let [get-cell (fn [board x y]\n                             (nth (nth board y) x))\n\n                  one-iff-alive (fn [board x y]\n                                  (let [in-bounds? (fn []\n                                                     (and\n                                                       (>= y 0)\n                                                       (< y (count board))\n                                                       (>= x 0)\n                                                       (< x (count (nth board y)))))]\n                                    (if (in-bounds?)\n                                      (if (= (get-cell board x y) \\#)\n                                        1\n                                        0)\n                                      0)))\n\n                  neighbors (fn [board x y]\n                              (let [neighborhood [[-1 -1] [0 -1] [1 -1] [-1 0] [1 0] [-1 1] [0 1] [1 1]]]\n                                (reduce + (map (fn [delta] (one-iff-alive board (+ x (first delta)) (+ y (second delta)))) neighborhood))))\n\n                  next-cell (fn [board x y]\n                              (if (= (get-cell board x y) \\#)\n                                (if (contains? #{2 3} (neighbors board x y))\n                                  \\#\n                                  \\space)\n                                (if (contains? #{3} (neighbors board x y))\n                                  \\#\n                                  \\space)))\n\n                  coordinates (fn [board]\n                                (for [y (range 0 (count board))]\n                                  (for [x (range 0 (count (nth board y)))]\n                                    (list x y))))\n                  ]\n\n              (for [row (coordinates board)]\n                (apply str\n                  (map (fn [cell] (next-cell board (first cell) (second cell)))\n                    row)\n                  ))))","user":"560c31b4e4b05f002753df2d"},{"problem":94,"code":"(fn eval-board [b]\n    (let [state-dead \\space\n          state-live \\#\n          w (count b)\n          h (count (first b))]\n      (letfn [\n              (cell [i j]\n                (nth (nth b i) j))\n              \n              (live? [c]\n                (= c state-live))\n              \n              (neighbour [i j acc]\n                (if (or  (< i 0) (< j 0) (>= i w) (>= j h))\n                  acc\n                  (cons (cell i j) acc)))\n              \n              (neighbours [i j]\n                (->> \n                  (neighbour (dec i) (dec j) [])\n                  (neighbour i (dec j))\n                  (neighbour (inc i) (dec j))\n                  (neighbour (dec i) j)\n                  (neighbour (inc i) j)\n                  (neighbour (dec i) (inc j))\n                  (neighbour i (inc j))\n                  (neighbour (inc i) (inc j))))\n              \n              (eval-cell [i j]\n                (let [ns (neighbours i j)\n                      lc (count (filter live? ns)) \n                      c (cell i j)]\n                  (if (live? c)\n                    (cond \n                      (< lc 2) state-dead\n                      (<= lc 3) state-live\n                      :else state-dead)\n                    (if (= lc 3)\n                      state-live\n                      state-dead))))\n              \n              (eval-row [i]\n                (reduce \n                  (fn [acc j] (conj acc (eval-cell i j)))\n                  [] (range h)))]        \n        \n        (reduce \n          (fn [acc i]\n            (conj acc (apply str (eval-row i))))\n          [] (range w)))))","user":"57d9bca1e4b0bd073c202405"},{"problem":94,"code":"(fn [board]\n  (let [moves [[1 0]\n               [1 1]\n               [0 1]\n               [-1 1]\n               [-1 0]\n               [-1 -1]\n               [0 -1]\n               [1 -1]]\n        row (count board)\n        col (count (get board 0 1))\n        count-neighbor (fn [board [x y]]\n                         (->> moves\n                              (map (fn [[a b]] (get-in board [(+ x a) (+ y b)])))\n                              (filter #(= % \\#))\n                              count))\n        new-datas (for [x (range row)\n                        y (range col)\n                        :let [cell (get-in board [x y])\n                              neighbor (count-neighbor board [x y])]]\n                    (cond\n                     (and (= cell \\#) (< neighbor 2)) \\space\n                     (and (= cell \\#) (<= neighbor 3)) \\#\n                     (and (= cell \\#) (> neighbor 3)) \\space\n                     (and (= cell \\space) (= neighbor 3)) \\#\n                     :else cell))\n        new-graph (partition col new-datas)]\n    (map #(apply str %) new-graph)))","user":"5cb41c40e4b026601754b911"},{"problem":94,"code":"(letfn [(neighbor-coords [r c]\n          (let [n [-1 0 1]\n                rns (map (partial + r) n)\n                cns (map (partial + c) n)]\n            (for [x rns y cns :when (or (not= r x) (not= c y))] [x y])))\n        (is-alive [c]\n          (= c \\#))\n        (score-cell [board x y]\n          (let [get-cell (partial get-in board)]\n            (reduce + 0 (map #(if (is-alive (get-cell %)) 1 0) (neighbor-coords x y)))))\n        (cell-rules [c scr]\n          (let [alive (is-alive c)\n                live \\#\n                die \\space]\n            (cond\n              (and alive (< scr 2)) die\n              (and alive (contains? #{2 3} scr)) live\n              (and alive (> scr 3)) die\n              (and (not alive) (= scr 3)) live\n              :else die)))\n        (map-indexed-2d [f vss]\n          (map-indexed (fn [i vs] (map-indexed (fn [j v] (f v i j)) vs)) vss))]\n  (fn [board]\n    (let [board (vec (map vec board))\n          next-cell (fn [cell x y] (cell-rules cell (score-cell board x y)))]\n      (map (partial apply str) (map-indexed-2d next-cell board)))))","user":"5884e807e4b0f1effa3b76a6"},{"problem":94,"code":"(fn life [s]\r\n  (letfn \r\n    [(lives? [[_ [_ m _] _ :as c]]\r\n       (let [s (apply + (map #(apply + %) c))]\r\n         (cond\r\n           (and (zero? m) (= s 3)) 1\r\n           (zero? m) 0\r\n           (> s 4) 0\r\n           (< s 3) 0\r\n           :else 1)))\r\n     (grid [s]\r\n       (concat\r\n         [(repeat (+ 2 (count (first s))) 0)]\r\n         (map\r\n           (fn [s'] \r\n             (concat \r\n               [0]\r\n               (map \r\n                 (fn [c]\r\n                   (case c\r\n                     \\space 0\r\n                     \\# 1))\r\n                 s')\r\n               [0]))\r\n           s)\r\n         [(repeat (+ 2 (count (first s))) 0)]))\r\n    (triples [[h m l & tail :as all]]\r\n      (if (empty? tail)\r\n        (list (list h m l))\r\n        (conj (triples (rest all)) (list h m l))))\r\n    (squares [x]\r\n      (map \r\n        (fn [[a b c]]\r\n          (map list a b c))\r\n        (triples (map triples x))))\r\n    (grid' [g]\r\n      (vec\r\n        (map\r\n          (fn [r]\r\n            (clojure.string/join \r\n              (map \r\n                (fn [x]\r\n                  (case x \r\n                    0 \\space\r\n                    1 \\#))\r\n                r)))\r\n          g)))]\r\n    (let [g (grid s)\r\n          sq (squares g)\r\n          next-iter (map #(map lives? %) sq)\r\n          next-s (grid' next-iter)]\r\n      next-s)))","user":"606e0a42e4b069485764de19"},{"problem":94,"code":"(fn conway [world]\n (letfn [\n  (live? [x y]\n    (= \\# (nth (nth world x) y)))\n  \n  (nbrs [x y]\n    (apply + \n      (for [a [-1 0 1], b [-1 0 1]]\n        (let [i (+ a x) j (+ b y)]\n          (if (and (>= i 0)\n                   (< i (count world))\n                   (>= j 0)\n                   (< j (count (first world)))\n                   (not= [i j] [x y])\n                   (live? i j)) \n              1 0)))))\n  (nxt [] (\n           map #(apply str %) (partition (count world) \n                                                   \n             (for [a (range (count world)) b (range (count (first world))) ] \n                 (let [N (nbrs a b) l (live? a b)]\n                   (cond \n                     (and l (< N 2)) \" \"\n                     (and l (or (= N 2) (= N 3))) \"#\"\n                     (and l (> N 3)) \" \"\n                     (and (not l) (= N 3)) \"#\"\n                     :default \" \"))))))\n  ]\n  (nxt)))","user":"54b54d1be4b05787c3b1639c"},{"problem":94,"code":"(fn gol\n  [b]\n  (letfn\n      [(rows\n         [board]\n         (count board))\n       (cols\n         [board]\n         (count (first board)))\n       (bounded\n         [board row col]\n         (and (< row (rows board))\n              (< col (cols board))\n              (>= row 0)\n              (>= col 0)))\n       (cell\n         [board row col]\n         (if (bounded board row col)\n           (get (get board row) col)\n           \\space))\n       (neighbors\n         [board row col]\n         [(cell board (dec row) (dec col))\n          (cell board (dec row) col)\n          (cell board (dec row) (inc col))\n          (cell board row (dec col))\n          (cell board row (inc col))\n          (cell board (inc row) (dec col))\n          (cell board (inc row) col)\n          (cell board (inc row) (inc col))])\n       (lives-on\n         [board row col]\n         (let [live-neighbors (count\n                               (filter #(= % \\#) (neighbors board row col)))\n               cell-alive (= \\# (cell board row col))]\n           (if cell-alive\n             (or (= live-neighbors 2)\n                 (= live-neighbors 3))\n             (= live-neighbors 3))))]\n    (map (fn [r]\n           (apply str (map\n                       (fn [c]\n                         (if (lives-on b r c)\n                           \\#\n                           \\space))\n                       (range (cols b)))))\n         (range (rows b)))))","user":"5341b141e4b00652c8746ecf"},{"code":"(fn [board]\n  (let [  pad      (fn  [lines] (map #(into (into [0] %) [0]) lines))\n          xp       (fn  [grid]  (apply map vector grid))\n          chnk     (fn  [lines] (map #(partition 3 1 %) lines))\n          from-txt (fn  [grid]  (map (fn [ss] (vec (map #(cond (= (str %) \" \") 0 :else 1) ss))) grid))\n          to-txt   (fn  [row]   (apply str (map #(cond (= % 1) \"#\" :else \" \") row)))\n          newval   (fn  [block]\n                     (do (let [[_ [_ center _] _] block sum (- (reduce #(apply + % %2) 0 block) center)]\n                       (cond (= sum 2) center (= sum 3) 1 :else 0))))\n          newvals  (fn  [col]   (vec (map #(newval %) col)))]\n    ((comp (partial map #(to-txt %)) vec (partial map #(newvals %)) chnk xp chnk pad xp pad from-txt) board)))","problem":94,"user":"4fd3bd14e4b0d4de60cee363"},{"problem":94,"code":"(fn [in]\n  (let [pos (fn [[r c]] (get (get in r) c))]\n    (for [row (range (count in))]\n      (apply str (for [col (range (count (nth in row)))]\n                    (let [u (dec row)\n                          d (inc row)\n                          l (dec col)\n                          r (inc col)\n                          ns [[u l] [u col] [u r] [row r] [d r] [d col] [d l] [row l]]\n                          score (count (filter #(when-let [p (pos %)] (= \\# p)) ns))\n                          state (pos [row col])]\n                      (if (or (= score 3) (and (= state \\#) (= score 2)))\n                        \\# \\space)))))))","user":"51d19c24e4b0cfcf579466c3"},{"problem":94,"code":"(fn [mx]\n    (let [height (count mx)\n          width (count (first mx))\n          \n          exists (fn [row col]\n                   (and (>= row 0) (< row height)\n                        (>= col 0) (< col width)))\n          alive (fn [row col]\n                  (= (get (mx row) col) \\#)) ;mx is a vector of strings, even though game-life returns a seq of strings\n          num-neighbs-alive (fn [row col]\n                               (count\n                                 (for [r-delta '(-1 0 1) c-delta '(-1 0 1)\n                                       :let [r (+ row r-delta) c (+ col c-delta)]\n                                       :when (and (exists r c)\n                                                  (not= r-delta c-delta 0)\n                                                  (alive r c))]\n                                   1)))\n          alive-next (fn [row col]\n                       (let [neighbs (num-neighbs-alive row col)]\n                         ;(print neighbs)\n                         ;(if (= col (dec width)) (println))\n                         (if (alive row col)\n                           (or (= neighbs 2) (= neighbs 3))\n                           (= neighbs 3))))]\n      (for [row (range 0 height)]\n        (apply str\n          (for [col (range 0 width)]\n            (if (alive-next row col)\n              \\#\n              \\space))))))","user":"5b999af8e4b0c0b3ffbd4ad3"},{"problem":94,"code":"(fn life [rows]\n  (let [alive? (fn [rows x y]\n                 (let [max (count rows)]\n                   (cond\n                     (or (neg? x) (neg? y) (>= x max) (>= y max)) 0\n                     (= \\space (nth (nth rows y) x)) 0\n                     (= \\#     (nth (nth rows y) x)) 1)))\n\n        ->cell (fn [c x y rows]\n                 (let [nearby (+\n                               (alive? rows (dec x) y)\n                               (alive? rows x (dec y))\n                               (alive? rows (inc x) y)\n                               (alive? rows x (inc y))\n                               (alive? rows (dec x) (dec  y))\n                               (alive? rows (dec x) (inc y))\n                               (alive? rows (inc x) (inc y))\n                               (alive? rows (inc x) (dec y)))]\n\n                   (cond\n                     (> 2 nearby) \\space\n                     (> nearby 3) \\space\n                     (= 3 nearby) \\#\n                     (and (= 2 nearby) (= \\# c)) \\#\n                     :else \\space)))]\n\n    (map-indexed\n     (fn [y row]\n       (->> row\n            (map-indexed\n             (fn [x cell]\n               (->cell cell x y rows)))\n            (apply str)))\n     rows)))","user":"5a257747e4b07f18be40aa1f"},{"problem":94,"code":"(fn [b]\n    (let [w (count (last b))\n          v [-1 0 1]\n          t (fn [[i j]] (nth (b i) j))\n          a (fn [i j] (for [x v\n                            y v\n                            :let [m (+ x i) n (+ y j)]\n                            :when (and (contains? b m) \n                                       (contains? (last b) n)\n                                       (not= x y 0))]\n                          [m n]))\n          n (fn [i j] (->> (a i j)\n                           (map t)\n                           (filter #(= % \\#))\n                           (count)))\n          f (fn [l n] (or (and l (#{2 3} n)) (and (not l) (= n 3))))\n                        ]\n    (->> (for [i (range 0 (count b)) j (range 0 w)\n            :let [l (= \\# (t [i j])) \n                  n (n i j)\n                  f (if (f l n) \\# \" \")]\n            ]\n         f)\n       (partition w)\n       (map (partial apply str)))))","user":"559c13c5e4b066d22e731f61"},{"problem":94,"code":"(fn gameoflife [b]\n  (let [size (count b)\n        board (vec (map vec b))]\n    (letfn [ (withinbounds? [x] (not-any? #(or (< (dec size) %) (neg? %)) x))\n             (neighborindices [col row] (filter withinbounds? (conj [] [(dec col) (dec row)] [col (dec row)] [(inc col) (dec row)]\n                                     [(dec col) row] [(inc col) row]\n                                     [(dec col) (inc row)] [col (inc row)] [(inc col) (inc row)])))\n             (getcoord [[col row]] ((board row) col))\n             (numliveneighbors [col row] (count (filter #(= \\# %) (map getcoord (neighborindices col row)))))\n             (nextform [col row] (let [n (numliveneighbors col row)\n                                       this (getcoord [col row])]\n                                   (if (= this \\#)\n                                     (if (or (= 2 n) (= 3 n)) \\# \\space)\n                                     (if (= 3 n) \\# \\space))))\n             (nextgen [] (map-indexed (fn [y row] (apply str (map-indexed (fn [x col] (nextform x y)) row))) board))]\n          (vec (nextgen))\n      )))","user":"57131dfbe4b07c98581c3a98"},{"problem":94,"code":"(fn game-of-life\n  [board]\n  (letfn [(board-get [board r c] (get (get board r) c))\n          (adjacent [r c]\n            [[(dec r) (dec c)]\n             [(dec r) c]\n             [(dec r) (inc c)]\n             [r (dec c)]\n             [r (inc c)]\n             [(inc r) (dec c)]\n             [(inc r) c]\n             [(inc r) (inc c)]])\n          (live-neighbors [board r c]\n            (count (filter #(= (apply board-get board %) \\#) (adjacent r c))))]\n    (for [r (range 0 (count board))]\n      (apply str\n             (for [c (range 0 (count (board r)))\n                   :let [live? (= (board-get board r c) \\#)\n                         live-count (live-neighbors board r c)]]\n               (if (or (and live? (<= 2 live-count 3))\n                       (and (not live?) (= live-count 3)))\n                 \\#\n                 \\space))))))","user":"563f1493e4b08d4f616f5ecf"},{"problem":94,"code":"(fn game-of-life [[row & _ :as grid]]\n  (letfn [(living? [cell] (= cell \\#))\n          (population [r c] (->> (for [r (range -1 2) c (range -1 2) :when (not= [0 0] [r c])] [r c])\n                                 (mapv (partial mapv + [r c]))\n                                 (mapv (partial get-in grid))\n                                 (filter living?)\n                                count))\n          (next-gen [cell population] (if (or (= population 3) (and (living? cell) (< 1 population 4))) \\# \\space))]\n    (->> (for [r (range (count grid)) c (range (count row))] (next-gen (get-in grid [r c]) (population r c)))\n         (partition (count row))\n         (mapv (partial apply str)))))","user":"5383668ee4b06839e8705edd"},{"problem":94,"code":"(fn game-of-life [board]\n  (let [board      (reduce (fn [res val]\n                             (conj res (vec (seq val))))\n                           []\n                           board)\n        rows       (count board)\n        cols       (count (first board))\n        neighbours (fn [i j]\n                     (for [x [i (inc i) (dec i)]\n                           y [j (inc j) (dec j)]\n                           :when (not (and (= x i) (= y j)))]\n                       (get (get board x) y)))]\n    (vec (map (fn [val]\n                (apply str val))\n              (for [i (range rows)]\n                (for [j (range cols)\n                      :let [f   (frequencies (neighbours i j))\n                            val (get (get board i) j)]]\n                  (cond\n                    (= val \\#)\n                    (if (or (= 2 (get f \\#)) (= 3 (get f \\#)))\n                      \\#\n                      \\space)\n                    (= val \\space)\n                    (if (= 3 (get f \\#))\n                      \\#\n                      \\space))))))))","user":"5dc53ddee4b02f9375f4e1bd"},{"code":"(fn next-generation [world]\r\n  (letfn [(world-size [world] [(count (first world)) (count world)])\r\n          (get-cell [world x y] (nth (nth world y) x))\r\n          (inside-world? [world x y]\r\n                         (let [[w h] (world-size world)]\r\n                           (and (>= x 0) (< x w) (>= y 0) (< y h))))\r\n          (get-area [world x y]\r\n                    (for [i (range -1 2)\r\n                          j (range -1 2)\r\n                          :let [m (+ x j) n (+ y i)]\r\n                          :when (and (not= [i j] [0 0]) (inside-world? world m n))]\r\n                      (get-cell world m n)))\r\n          (alive? [world x y] (= \\# (get-cell world x y)))]\r\n    (let [[w h] (world-size world)]\r\n      (for [i (range h)]\r\n        (apply str\r\n              (for [j (range w)]\r\n                (let [n (count (filter #(= \\# %) (get-area world j i)))]\r\n                  (cond\r\n                    (and (alive? world j i) (or (= n 2) (= n 3))) \"#\"\r\n                    (and (not (alive? world j i)) (= n 3)) \"#\"\r\n                    :else \" \"))))))))","problem":94,"user":"4dab218f30acd6ed15482a68"},{"code":"(fn life [board]\n  (let [y-max (count board)\n        x-max (count (first board))\n        adj-coords\n          (fn [[x y]]\n            (for [x-n [(dec x) x (inc x)]\n                  y-n [(dec y) y (inc y)]\n                  :when (not= [x-n y-n] [x y])]\n            [x-n y-n]))\n        count-adj\n          (fn [[x y] cells]\n             (let [adj (adj-coords [x y])]\n               (reduce #(if (contains? cells %2) (inc %1) %1) 0 adj)))\n        lives?\n          (fn [[x y] cells]\n            (let [num-live (count-adj [x y] cells)]\n              (if (contains? cells [x y])\n                (boolean (#{2 3} num-live))\n                (boolean (#{3} num-live)))))\n        step \n          (fn [cells]\n            (for [x-n (take x-max (range))\n                  y-n (take y-max (range))\n                  :when (lives? [x-n y-n] cells)]\n              [x-n y-n]))\n        collapse-str\n          (fn [s y]\n            (->> s\n                 (map #(if (= \\# %2) [%1 y] nil) (take (count s) (range)))\n                 (filter #(not= % nil))\n                 (into #{})))\n        collapse-vec\n          (fn [v]\n            (->> v\n                 (map #(vector %1 %2) (reverse (take (count v) (range))))\n                 (reduce #(concat %1 (collapse-str (last %2) (first %2))) [])\n                 (into #{})))\n        explode-set\n          (fn [s]\n            (let [spaces-list (into [] (take x-max (repeat \\space)))\n                  y-range (take y-max (range))\n                  live-map \n                    (reduce (fn map-set-to-rows [mp st]\n                              (assoc mp \n                                (last st)\n                                (conj (get mp (last st)) (first st))))\n                            (zipmap y-range (take y-max (repeat [])))\n                            s)\n                  explode-str\n                    (fn [s-e]\n                      (->> s-e\n                           (reduce #(assoc %1 %2 \\#) spaces-list)\n                           (apply str)))]\n              (->> y-range\n                   (into [])\n                   (map #(explode-str (get live-map %)))\n                   (reverse))))]\n    (explode-set (step (collapse-vec board)))))","problem":94,"user":"52463059e4b09dbe66b56198"},{"code":"(fn [ls] (letfn \n[(ij [x y] (nth (nth ls x ()) y nil))\n(mp [i j] (get (frequencies \n[(ij (- i 1) (- j 1)) (ij (- i 1) j )\n(ij (- i 1) (+ j 1)) \n(ij i (- j 1)) (ij i (+ j 1)) \n(ij (+ i 1) (- j 1)) (ij (+ i 1) j )\n(ij (+ i 1) (+ j 1))]) \\# 0))\n(f [m n] (cond \n(= (ij m n) \\space) \n(if (= 3 (mp m n)) \\# \\space)\n:else\n (cond\n (< (mp m n) 2) \\space\n (or (= 2 (mp m n)) (= 3 (mp m n)))\n \\#\n (> (mp m n) 3) \\space)))]\n (map #(apply str %)\n(partition (count ls) \n(for [p (range (count ls))\nq (range (count ls))]\n(f p q)) ))\n))","problem":94,"user":"517945dce4b0684c1c981a43"},{"code":"(fn my-game-of-life\n  [world]\n  (let [width (count (first world))\n        height (count world)\n        world-map (zipmap (range) (apply str world))]\n    (letfn [(get-neighbours-ids [id]\n                            (let [l (- id width)\n                                  u (+ id width)]\n                              (vector  (dec l) l (inc l) (dec id) (inc id) (dec u) u (inc u))))\n            (get-neighbours [id] \n                            (filter (complement nil?) (map world-map (get-neighbours-ids id))))\n            (calc-next-gen [neighbours id] \n                           (if (= (world-map id) \\#) \n                             (live-next-gen (count-of-live-neighbours neighbours))\n                             (dead-next-gen (count-of-live-neighbours neighbours))))\n            (count-of-live-neighbours [neighbours] \n                                      (count (filter #(= % \\#) neighbours)))\n            (live-next-gen [live-count] (if (or (> live-count 3) (< live-count 2))\n                                          \\space\n                                          \\#))\n            (dead-next-gen [live-count] (if (= live-count 3)\n                                          \\#\n                                          \\space))]\n    (map #(apply str %) (partition width (map #(calc-next-gen (get-neighbours %) %) (keys (sort-by key world-map))))))))","problem":94,"user":"509a25b7e4b0efbae1fbc0a8"},{"problem":94,"code":"(fn [bd] \n  (let [dr (for [x [-1 0 1] y [-1 0 1] :when (not (and (= x 0) (= y 0))) ] [x y]) ;; relative index, except 0.\n        count- (fn [cor] ;; count \\# of the neighbour of cor.\n                 (let [nei (map #(map + cor %) dr)]\n                      (count (remove #(= \\space %) (map #(get-in bd % \\space) nei)))\n                      )\n                 )\n        getorg- (fn [cor] ;; function to get current char of coordinate.\n                  (let [cur (get-in bd cor)\n                        ct  (count- cor)\n                        ]\n                    (case ct 0 \\space 1 \\space  2 cur 3 \\# \\space )\n                    )\n                  )\n        handle- (fn [strs, ind]\n                  (apply str (map #(getorg- [ind, %]) (range (count (seq strs)))))\n                  )\n        ]\n    (map handle- bd (range))\n    )\n  )","user":"54a1d643e4b09f271ff37c50"},{"problem":94,"code":"(fn next-gen [rows]\n     (let [board {:b (apply str rows) :w (count (first rows)) :h (count rows)}\n           neighbours (let [{:keys [b w h]} board]\n                        (fn [i]\n                          (let [x (mod i h) y (quot i w)]\n                            (for [xn (range (dec x) (+ x 2))\n                                  yn (range (dec y) (+ y 2))\n                            :when (not (and (= x xn) (= y yn)))\n                            :when (<= 0 xn (dec w))\n                            :when (<= 0 yn (dec h))]\n                           (.charAt b (+ (* yn w) xn))))))\n           next-cell (fn [c nbs]\n                       (let [alive (count (filter #(= % \\#) nbs))]\n                         (cond\n                          (and (= c \\space) (= alive 3)) \\#\n                          (and (= c \\#) (<= 2 alive 3)) \\#\n                          :else \\space)))]\n(doall (->> (:b board)\n     (map vector (range))\n     (map (fn [[i c]] (next-cell c (neighbours i))))\n     (partition (:w board))\n     (map #(apply str %))))))","user":"4fd4bddce4b0d4de60cee36e"},{"code":"(fn gol [board]\n  (let [adj (fn [i j] (map (fn [[x y]] [(+ x i) (+ y j)]) [[-1 -1] [-1 0] [-1 1] [0 -1] [0 1] [1 -1] [1 0] [1 1]]))\n        neighbours (fn [i j] (count (filter (fn [[x y]] \n                                              (= \\# (nth (nth board x nil) y nil))) \n                                            (adj i j))))] \n    (map-indexed \n      (fn [i rows]\n\t      (clojure.string/join \"\"\n\t        (map-indexed \n\t\t        (fn [j elem] \n\t\t          (if (or (and (= elem \\#) (< 1 (neighbours i j) 4))\n                      (and (= elem \\ ) (= 3 (neighbours i j))))\n                \"#\"\n                \" \")) \n\t\t        rows))) \n\t    board)))","problem":94,"user":"5003deb9e4b0678c553fc445"},{"problem":94,"code":"(fn [lf] (\n            letfn [\n                   (g[x y] (\n                             if (and (>= x 0) (>= y 0) (< x (count (first lf))) (< y (count lf)))\n                             (nth (nth lf y) x)\n                             \" \"\n                           ))\n                   (c[x y] (count (filter #(= % \\#) (map #(g (+ x (first %)) (+ y (last %))) [[-1 -1][0 -1][1 -1][1 0][1 1][0 1][-1 1][-1 0]]))) )\n                   ]            \n            \n            (map #(apply str %) (map-indexed (fn[y v](\n                                   map-indexed (fn[x t](\n                                  #(\n                                     if (= %2 \\#)\n                                     (if (or (< % 2) (> % 3))\n                                      \" \"\n                                      \"#\"\n                                    )\n                                     (if (= % 3)\n                                       \"#\"\n                                       \" \"\n                                       )\n                                                            \n                                  ) (c x y) (g x y)\n                                                         )) v\n                                   \n                                   )) lf))\n            \n            ))","user":"596f6683e4b069c0a1a19877"},{"problem":94,"code":"(fn life [board]\n  (let [alive? (fn [x y] (= \\# (get-in board [y x] \\space)))\n        neighbours (disj (into #{} (for [x (range -1 2) y (range -1 2)] [x y])) [0 0])\n        ncount (fn [x y]\n                 (count\n                   (filter #{true}\n                           (map #(alive? (+ x (get % 0)) (+ y (get % 1))) neighbours))))\n        rows (range (count board))\n        cols (range (count (get board 0)))]\n    (for [y rows]\n      (apply str (for [x rows]\n         (let [n (ncount x y)]\n           (if (alive? x y)\n             (cond (< n 2) \\space\n                   (> n 3) \\space\n                   :else \\#)\n             (if (= n 3) \\# \\space))))))))","user":"54864662e4b0e286459a11b8"},{"code":"(fn [m]\n  (let [m (vec (map vec (seq m)))\n        h (count m)\n        w (count (first m))\n        c (fn [x y] (get-in m [(mod y h) (mod x w)]))\n        n (fn [x y] (count\n                      (filter\n                        #(= % \\#)\n                        [(c (dec x) (dec y))\n                         (c      x  (dec y))\n                         (c (inc x) (dec y))\n                         (c (dec x)      y )\n                         (c (inc x)      y )\n                         (c (dec x) (inc y))\n                         (c      x  (inc y))\n                         (c (inc x) (inc y))\n                         ])))\n        z (fn [x y]\n            (let [nn (n x y)\n                  live? (= (c x y) \\#)]\n              (cond\n                (and live? (< nn 2)) \\space\n                (and live? (> nn 3)) \\space\n                live? \\#\n                (and (not live?) (= nn 3)) \\#\n                :default \\space)))\n        r (for [y (range h)]\n            (for [x (range w)]\n              (z x y)))]\n    (map #(apply str %) r)))","problem":94,"user":"52a88c4de4b0c58976d9ac30"},{"problem":94,"code":"(fn neighbours [board]\n  (let [analize_row (fn [r pos]\n                (vector (if (and (pos? (count r))  (> (dec pos) 0) (= (nth r (dec pos)) \\#))\n                          1\n                          0)\n                        (if (and (pos? (count r)) (= (nth r pos) \\#)) 1 0)\n                        (if (and (pos? (count r)) (< (inc pos) (count r)) (= (nth r (inc pos)) \\#))\n                          1\n                          0)))\n        get_row (fn [[a b c]]\n                  (loop [pos 0 res \"\"]\n                    (if (= pos (count b))\n                      res\n                      (let [current (nth b pos)\n                            cells (apply + (concat (analize_row a pos) (analize_row b pos) (analize_row c pos)))]\n                        (cond\n                          (and (= current \\#) (or (< cells 3) (> cells 4))) (recur (inc pos) (str res \\ ))\n                          (and (= current \\ ) (= cells 3)) (recur (inc pos) (str res \\#))\n                          :else (recur (inc pos) (str res current)))))))\n        new_board (concat [\"\"] (conj board \"\"))]\n    (map get_row (partition 3 1 new_board))))","user":"5046f909e4b03b02161376b5"},{"problem":94,"code":"(fn [board]\n  (let [bound {:row (count (first board)) :col (count board)}\n        cell (fn [row col]\n               (nth \n                   (nth board row)\n                   col\n               )\n              )\n        neighbors (fn [row col]\n                    (for [r (range (max 0 (dec row))\n                                   (min (+ 2 row) (:row bound)))\n                          c (range (max 0 (dec col))\n                                   (min (+ 2 col) (:col bound)))\n                          :when (not= [row col] [r c])\n                          ]\n                      (cell r c)\n                      )\n                    )\n        ALIVE \\#\n        DEAD \\space\n        alive? (fn [cll] (= cll ALIVE))\n        cell-lives? (fn [cell-alive? alive-neighbors-count]\n                   (or\n                    (= alive-neighbors-count 3)\n                    (and\n                     cell-alive? (= alive-neighbors-count 2))\n                   )\n                   \n                   )\n        next-val (fn [row col]\n                   (let [cell-alive? (alive? (cell row col))\n                         alive-neighbors-count (count (filter alive? (neighbors row col)))\n                         ]\n                     (if (cell-lives? cell-alive? alive-neighbors-count)\n                       ALIVE\n                       DEAD\n                      )\n                     )\n                   )\n        update-row (fn [row-idx row]\n                     (->>\n                      row\n                      (map-indexed (fn [col _] (next-val row-idx col)))\n                      (apply str)\n                     )\n                     )\n        ]\n    (->>\n     board\n     (map-indexed update-row)\n     (into [])\n\n     )\n   )\n\n  )","user":"4e28ddd1535deb9a81d77efd"},{"problem":94,"code":"(fn [board]\n  (let [board (vec (map vec board))\n        xs (range 0 (count (first board)))\n        neighbor-offsets\n        (-> (for [dy (range -1 +2)\n                  dx (range -1 +2)]\n              [dy dx])\n            (set)\n            (disj [0 0]))\n        dead \\space\n        live \\#]\n    (letfn [(old-state [coords]\n              (get-in board coords dead))\n            (neighbor-coords [[y x]]\n              (map (fn [[dy dx]] [(+ y dy) (+ x dx)]) neighbor-offsets))\n            (count-live-neighbors [coords]\n              (count (filter #(= live (old-state %)) (neighbor-coords coords))))\n            (new-state [coords]\n              (let [os (old-state coords)\n                    n (count-live-neighbors coords)]\n                (if (= live os)\n                  (cond (< n 2) dead\n                        (= n 2) live\n                        (= n 3) live\n                        (> n 3) dead\n                        :else os)\n                  (if (= n 3) live os))))\n            (row-coords [y] (map vector (repeat y) xs))\n            (add-cell [row coords] (conj row (new-state coords)))\n            (add-row [b y] (conj b (apply str (reduce add-cell [] (row-coords y)))))]\n      (reduce add-row [] (range 0 (count board))))))","user":"5764457ae4b0994c1922fbf3"},{"problem":94,"code":"(fn game-of-life [vs]\n  (letfn [\n    (parse-str [s]\n      (->> s\n           (vec ,,,)\n           (replace {\\space :dead \\# :live} ,,,)))\n    (parse-board [bs]\n      (let [board  (vec (map parse-str bs))\n            height (count board)\n            rowlens (vec (map count board))\n            width (first rowlens)]\n        (if (and (pos? height)\n                 (every? #(= width (count %)) board)\n                 (every? (fn [row] (every? #(#{:live :dead} %) row)) board))\n          board\n          (throw (Exception. \"Parse error\")))))\n    (make-board-idx [height width]\n      (for [y (range height), x (range width)] [y x]))\n    (get-cell [board [r c]]\n      (nth (nth board r) c))\n    (idx-on-board? [height width [y x]]\n      (and (not (neg? y))\n           (not (neg? x))\n           (> height y)\n           (> width x) ))\n    (neighb-idxs [height width [y x]]\n      (for [yof [-1 0 1], xof [-1 0 1]\n            :let [yyy (+ y yof), xxx (+ x xof)]\n            :when (and (idx-on-board? height width [yyy xxx])\n                       (not (and (zero? yof) (zero? xof))))]\n        [yyy xxx]))\n\n    (one-gen-pass [height width board vidx]\n      (let [m-board\n       (reduce (fn [m [i j :as k]]\n                (let [cell (get-cell board k)\n                      nbrs (map (partial get-cell board)\n                               (neighb-idxs height width k))\n                      [lives-nb, deads-nb]\n                        (reduce (fn [[acclive accdead] state]\n                                  (if (= :live state)\n                                    [(inc acclive) accdead]\n                                    [acclive (inc accdead)]))\n                                [0 0] nbrs)\n                      new-state\n                        (cond\n                          (and (= :live cell)\n                               (or (< lives-nb 2) (> lives-nb 3))) :dead\n                          (and (= :live cell)\n                               (or (= 2 lives-nb) (= 3 lives-nb))) :live\n                          (and (= :dead cell) (= 3 lives-nb))      :live\n                          :otherwise cell)]\n                  (assoc-in m [i j] new-state)))\n              {} vidx)\n            mrows (map #(get m-board %) (range height))\n            new-state-board (map (fn [mr] (map #(get mr %) (range width)))\n                                 mrows)\n            str-form-rslt\n              (vec (map (fn [rs] (->> rs\n                                      (replace { :dead \\space :live \\# } ,,,)\n                                      (apply str ,,,)))\n                        new-state-board))]\n        str-form-rslt))]\n    (let [board (parse-board vs)\n          height (count board)\n          width (count (first board))\n          vidx (make-board-idx height width)]\n      (one-gen-pass height width board vidx))))","user":"57f9011ee4b0d3187e900935"},{"problem":94,"code":"(fn \n  [g]\n  (letfn [(alives [g r c]\n            (->> \n              (for [rr (range (dec r) (+ r 2)) \n                    cr (range (dec c) (+ c 2))\n                    :when (not= [r c] [rr cr])] \n                (get-in g [rr cr] \\space))\n              (filter {\\# true})\n              count))\n           (decide [g r]\n             (fn [c nd]\n               (case (alives g r c) \n                 2 nd \n                 3 \\# \n                 \\space)))]\n    (map-indexed \n      (fn [ri rw]\n        (apply str (map-indexed (decide g ri) rw)))\n      g)))","user":"59f91b99e4b0ca45a743a33a"},{"problem":94,"code":"(fn [area]\n  (letfn [(cp [a b] (reduce #(into % (map (partial vector %2) b)) #{} a))\n          (adj [[h w] area]\n            (let [dh (dec h) dw (dec w) ih (inc h) iw (inc w)]\n              (keep (fn [[h w]] (get (get area h) w)) [[dh dw] [dh w] [dh iw] [h  dw] [h  iw] [ih dw] [ih w] [ih iw]])))\n          (rule [[h w :as p] area]\n            (let [l (count (filter #(= % \\#) (adj p area)))]\n              (condp = (get (get area h) w)\n                \\# (if (or (= l 2) (= l 3)) \"#\" \" \")\n                \\space (if (= l 3) \"#\" \" \"))))\n          (ruleapply [area line]\n            (reduce #(str % (rule %2 area)) \"\" line))]\n   (let [r (range (count area)), line (group-by first (sort (fn [[_ a][_ b]] (compare a b)) (cp r r)))]\n     (reduce #(conj % (ruleapply area %2)) [] (map line r)))))","user":"57035ccfe4b08d47c97781ef"},{"problem":94,"code":"(fn game-of-life\n  [board]\n  (let [rows (count board)\n        columns (count (first board))\n        cell (fn [x y] (if (and (<= 0 x (dec columns))\n                               (<= 0 y (dec rows)))\n                        (nth (board y) x)))\n        neighbor-xy (list [0 -1] [0 1] [-1 0] [1 0] [-1 -1] [-1 1] [1 -1] [1 1])\n        neighbors (fn [x y]\n                    (map #(cell (+ x (% 0)) (+ y (% 1))) neighbor-xy))]\n    (->> (for [y (range 0 rows)\n               x (range 0 columns)]\n           (vector (cell x y) (count (filter #{\\#} (neighbors x y)))))\n         (map #(if (or (and (= \\# (% 0)) (<= 2 (% 1) 3))\n                       (and (= \\space (% 0)) (= 3 (% 1)))) \\# \\space))\n         (partition columns)\n         (map #(apply str %)))))","user":"55a9e0fee4b0988bba2ad945"},{"code":"(fn [board]\n  (letfn [(cells-with-s [b s]\n            (let [lcinrow (fn [rn] (filter #(= s (nth (nth b rn) %)) (range (count (nth b rn)))))\n                  rowsl (map #(vector % (lcinrow %)) (range (count b)))\n                  cellslr (fn [rl] (if (empty? (last  rl)) nil\n                                      (map #(vector (first rl) %) (last rl))))]\n              (apply concat (map cellslr rowsl))))\n          (live-cells [b] (cells-with-s b \\#))\n          (dead-cells [b] (cells-with-s b \\space))\n          (my-abs [n] (if (neg? n) (-' n) n))\n          (in-nbd [n1 n2 dist] (<= (my-abs (-' n1 n2)) dist))\n          (neighbours? [cell1 cell2]\n            (cond\n             (= cell1 cell2) false\n             (and (in-nbd (first cell1) (first cell2) 1) (in-nbd (last cell1) (last cell2) 1)) true\n             :else false))\n          (count-live-neighbours [c lcs] (count (filter #(neighbours? c %) lcs)))\n          (live-cell-rules [c lcs]\n            (let [cln (count-live-neighbours c lcs)]\n              (cond (< cln 2) false\n                    (or (= cln 2) (= cln 3)) true\n                    :else false)))\n          (dead-cell-rules [c lcs]\n            (let [cln (count-live-neighbours c lcs)]\n              (cond (= cln 3) true\n                    :else false)))\n          (new-live-cells [b]\n            (let [lcs (live-cells b)\n                  dcs (dead-cells b)\n                  lcslive (filter #(live-cell-rules % lcs) lcs)\n                  dcslive (filter #(dead-cell-rules % lcs) dcs)\n                  newlcs (concat lcslive dcslive)]\n              newlcs))\n          (newboard [b]\n            (let [nlb (new-live-cells b)\n                  strels (for [x (range (count b))\n                               y (range (count (first b)))]\n                           (if (empty? (filter #(= [x y] %) nlb))\n                             \" \"\n                             \"#\"))\n                  strb (partition (count (first b)) strels)]\n              (map #(apply str %) strb)))]\n    (newboard board)))","problem":94,"user":"5133e51ae4b0d7a043de8cf6"},{"code":"(fn game-of-life [board]\n  (let [board (vec (map vec board))\n        x-count (count board)\n        y-count (count (board 0))\n        coords (for [x (range x-count) y (range y-count)] [x y])\n        alive \\#\n        dead \\space]\n    (letfn [(valid-coord? [[x y]]\n              (and (< -1 x x-count)\n                   (< -1 y y-count)))\n            (neighbors [[x y]]\n              (->> [[(dec x) (dec y)] [(dec x) y] [(dec x) (inc y)]\n                    [x (dec y)] [x (inc y)]\n                    [(inc x) (dec y)] [(inc x) y] [(inc x) (inc y)]]\n                   (filter valid-coord?)))\n            (read-cell [board [x y]]\n              ((board x) y))\n            (write-cell [board [x y] c]\n              (update-in board [x] #(assoc % y c)))\n            (update-cell [[nboard board] [x y]]\n              (let [living (= alive (read-cell board [x y]))\n                    n-cnt (->> (neighbors [x y])\n                               (map #(read-cell board %))\n                               (filter #(= alive %))\n                               (count))\n                    nboard (if (or (= 3 n-cnt)\n                                   (and living (= 2 n-cnt)))\n                             (write-cell nboard [x y] alive)\n                             (write-cell nboard [x y] dead))]\n                [nboard board]))]\n      (->> (reduce update-cell [board board] coords)\n           (first)\n           (map #(apply str %))))))","problem":94,"user":"4e5bff2b535d8a8b8723a2bd"},{"code":"(fn p94 [tab]\n  (letfn [(tabi [tab]\n            (reduce merge {} (for [[yi row] (zipmap (range) tab) [xi c] (zipmap (range) (char-array row))]\n                                [[yi xi] (str c)])))\n\t  (ng [xl yl e tis]\n            (let [[[yci xci] v] e\n                  nbs (for [yi (range (dec yci) (+ 2 yci)) xi (range (dec xci) (+ 2 xci)) :when (and (<= 0 yi) (<= 0 xi) (< yi yl) (< xi xl) (not (and (= yi yci) (= xi xci)))) ] (tis [yi xi]))\n                  gd (into {} (map (fn [e] [(.getKey e) (count (.getValue e))]) (group-by identity nbs)))\n                  lives (gd \"#\") dies (gd \" \")]\n              [[yci xci]\n\t       (cond\n\t        (and (= v \"#\") (< lives 2)) \" \"\n\t        (and (= v \"#\") (<= 2 lives 3)) \"#\"\n\t        (and (= v \"#\") (< 3 lives)) \" \"\n\t        (and (= v \" \") (= lives 3)) \"#\"\n\t\ttrue v\n\t\t)]))\n          (rmfig [rm yl xl]\n            (for [yi (range 0 yl)] (apply str (for [xi (range 0 xl)] (rm [yi xi])))))]\n    (let [xlen (count tab) ylen (count (tab 0)) tbi (tabi tab) rm (reduce conj {} (map #(ng xlen ylen % tbi) tbi))] (rmfig rm ylen xlen))))","problem":94,"user":"5272669de4b03e8d9a4a742e"},{"problem":94,"code":"(fn [b]\n  (let [npos  [[-1 -1] [0 -1] [1 -1]\n               [-1 0]         [1 0]\n               [-1 1] [0 1]   [1 1]]\n        rowlen (count (first b))]\n    (map (partial apply str) \n         (partition rowlen (for [y (range (count b))\n                                 x (range rowlen)\n                                 :let [neigh (map (fn [[dx dy]] (get (get b (+ dy y)) (+ dx x))) npos)\n                                       nalive (count (filter #{\\#} neigh))\n                                       alive (= \\# (get (get b y) x))]]\n                            (if alive\n                            (cond (< nalive 2) \\space\n                                    (< nalive 4) \\#\n                                    :else \\space)\n                            (if (= nalive 3)\n                                \\#\n                                \\space)))))))","user":"5e3a25d4e4b01d43a70e8dde"},{"problem":94,"code":"(fn gol-step [b]\n   (let [w (count (first b))\n         h (count b)\n         dirs [[1 1] [1 0] [1 -1] [0 1] [0 -1] [-1 1] [-1 0] [-1 -1]]\n         get-coord (fn [x y]\n                     (if (and (>= x 0) (>= y 0) (< x w) (< y h))\n                       (.charAt (b y) x)\n                       \\space))]\n     (map (partial clojure.string/join \"\")\n          (partition w\n                     (for [x (range w)\n                           y (range h)\n                           :let [c (get-coord y x)]]\n                       (let [live-neighbors\n                             (count (filter (partial = \\#)\n                                            (map (partial apply get-coord)\n                                                 (map (fn [d] (map + [y x] d))\n                                                      dirs))))]\n                         (if (= c \\#)\n                           (if (or (< live-neighbors 2)\n                                   (> live-neighbors 3))\n                                 \\space\n                                 \\#)\n                           (if (= live-neighbors 3) \\# \\space))\n                         ))))))","user":"54be7772e4b0ed20f4ff6eea"},{"problem":94,"code":"(fn f [ss]\n  (let [board (mapv #(mapv char %) ss)\n        neighborhood (juxt dec identity inc)]\n    (letfn[(alive? [where] (= \\# (get-in board where)))]\n      (map \n        #(reduce str %) \n        (partition \n          (-> ss first count)\n          (for [ y (-> ss count range) x (-> ss first count range)]\n              (let [me [y x] \n                    live-neighbors (apply + (for [r (neighborhood y) \n                                                  c (neighborhood x) \n                                                  :let [neighbor [r c]]\n                                                  :when (not= me neighbor)]\n                                              (if (alive? neighbor) 1 0)))]\n                (cond\n                  (= 3 live-neighbors) \\#\n                  (and (alive? me) (= 2 live-neighbors)) \\#\n                  :else \\space))))))))","user":"55ecb2c0e4b0121d4835fdce"},{"problem":94,"code":"(fn life [board]\n  (let [h (count board) w (count (first board)) join clojure.string/join]\n    (letfn [(neighbor-coords [i j]\n              (->> '((-1 -1) (-1 0) (-1 1) (0 -1) (0 1) (1 -1) (1 0) (1 1))\n                   (map #(list (+ i (first %)) (+ j (second %))))\n                   (filter #(and (< -1 (first %) h) (< -1 (second %) w)))))\n            (neighbors [i j]\n              (->> (neighbor-coords i j)\n                   (map #(get-in board %))\n                   (join)))\n            (live-neighbors [i j]\n              (->> (neighbors i j)\n                   (filter #(= % \\#))\n                   (count)))\n            (live? [i j]\n              (= \\# (get-in board [i j])))]\n      (vec (for [i (range h)]\n             (join (for [j (range w)]\n                     (let [ln (live-neighbors i j) l (live? i j)]\n                       (if (or (= ln 3) (and (= ln 2) l)) \\# \\space)))))))))","user":"508157b2e4b0946d0443855c"},{"code":"(fn life [board]\n  (let [w (count (board 0))\n        h (count board)\n        score\n        (fn [[a b]]\n          (let [c ((vec (board b)) a)]\n            (if (= \\# c) 1 0)))\n        neighbors\n        (fn [i j]\n          (for [x [-1 0 1] y [-1 0 1] :when (not (and (zero? x) (zero? y)))]\n            [(mod (+ i x) w) (mod (+ j y) h)]))\n        n_count\n        (fn [i j]\n          (reduce + (map score (neighbors i j))))\n        ]\n\n    (for [y (range h)]\n      (apply str\n        (for [x (range w)]\n          (let [s (n_count x y)\n                c ((vec (board y)) x)]\n            (cond\n              (< s 2) \\space\n              (> s 3) \\space\n              (= s 3) \\#\n              (= s 2) c)\n            ))))\n    ))","problem":94,"user":"4f4c6b21e4b03ad3f0c10c8f"},{"code":"(fn [b]\n    (letfn [(get-in-board [board pos]\n              (let [[r c] pos]\n                (let [got (get (get board r) c)]\n                  (if got got \\space))\n                ))\n            (neighbours [[x y]]\n              (for [i (range -1 2)\n                    j (range -1 2)\n                    :when (not (and (= 0 i) (= 0 j)))]\n                [(+ x i) (+ y j)]))\n            (count-neighbours [b [x y]]\n              (apply + (for [n (neighbours [x y])\n                             :when (= (get-in-board b n) \\#)]\n                         1)))\n            (next-val [g pos]\n              (case (count-neighbours g pos)\n                2 (get-in-board g pos)\n                3 \\#\n                \\space))]\n      (for [i (range (count b))]\n        (apply str (for [j (range (count (b i)))]\n                     (next-val b [i j])))))\n    )","problem":94,"user":"5165a235e4b079ad97ec44ac"},{"code":"(fn gol [board]\n  (let [ row-n (count (first board))\n         col-n (count board)\n         v     #(if (and (<= 0 %1) (<= 0 %2) (< %1 col-n) (< %2 row-n)) (nth (seq (nth board %1)) %2))\n         nbrs  #(for [ m [ 0 1 -1 ] n [ 0 1 -1 ] :when (not (every? zero? [m n])) ] \n                    (v (+ %1 m) (+ %2 n)))\n         lnrbs #(count (filter #{\\#} (nbrs %1 %2))) ]\n    \n    (for [ m (range col-n) ] \n      (apply str\n      (for [ n (range row-n) ]\n       (let [ l (lnrbs m n) ]\n         (cond \n            (and (= (v m n) \\#) (#{2 3} l)) \\#\n            (and (not= (v m n) \\#) (= 3 l)) \\#\n            :else \\space)))))))","problem":94,"user":"4e860e85535db62dc21a62f1"},{"problem":94,"code":"(fn ng [board]\n   (letfn [(to-be? [y x cell]\n               (let [nbrs (fn [rc cells] (take (if (zero? rc) 2 3) (nthrest cells (dec rc))))\n                     lives ((frequencies (mapcat #(nbrs x %) (nbrs y board))) \\#)]\n                  (if (= cell \\#) \n                     (if (or (= lives (inc 2)) (= lives (inc 3))) \\# \\space)\n                     (if (= lives 3) \\# \\space))))]\n      (map (partial apply str) (map-indexed (fn [y row] (map-indexed (fn [x cell] (to-be? y x cell)) row)) board))))","user":"59f043d0e4b0966464fe6a3d"},{"code":"(fn [b]\n  (let [w (count (first b))\n        s (apply str b)\n        l (count s)]\n  (letfn [(f [a b c]\n            (filter #(and (>= % a) (< % b)) c))\n          (n [x] (->> \n            [(dec x) x (inc x)]\n            (f (- x (rem x w)) (+ (- x (rem x w)) w))\n            (mapcat\n              #(list (- % w) % (+ % w)))\n            (f 0 l)\n            (map (partial nth s))\n            (filter #(= \\# %))\n            (count)))]\n   (->> (for [x (range l)]\n          (let [v (nth s x)\n                a (n x)]\n            (if (= v \\#)\n              (if (or (= a 3) (= a 4)) \"#\" \" \")\n              (if (= a 3) \"#\" \" \"))))\n        (partition w)\n        (map (partial apply str))))))","problem":94,"user":"50361b6be4b0fbe0a74d26be"},{"code":"(fn [g]\n  (let [m {\\space 0 \\# 1}\n        d (count g)\n        b (vec (map #(vec (map m %)) g))\n        n (rest (for [x [0 -1 1] y [0 -1 1]] [x y]))]\n    (map #(apply str %)\n         (for [x (range d)]\n           (for [y (range d)]\n             (let [c (apply + (map (fn[[k l]] (get-in b [(+ k x) (+ l y)] 0)) n))\n                   s (get-in b [x y])]\n               (cond\n                (= c 3) \\#\n                (and (= c 2) (= s 1)) \\#\n                :else \" \")))))))","problem":94,"user":"4e12cc9d535d04ed9115e7d2"},{"code":"(fn [b]\n    (let [ h (count b)\n           w (count (first b))\n           str-board (fn [h w s]\n                    (map (fn [l] (apply str (mapcat (fn [c] (if (s [l c]) \"#\" \" \")) (range w)))) (range h)))\n           cells (set (filter identity\n                    (apply concat\n                        (map-indexed (fn [i l] (map-indexed (fn [j c] (if (= c \\#) [i j])) l)) b))))\n           connexity [[1 0] [-1 0] [0 1] [0 -1] [1 1] [-1 -1] [1 -1] [-1 1]]\n           neighbors (fn [[x y]] (map (fn[[dx dy]] [(+ x dx) (+ y dy)]) connexity)) \n           update-neighbors (fn [m c] (reduce #(assoc %1 %2 (inc (m %2 0))) m (neighbors c)))\n           neighbor-map (reduce update-neighbors {} cells)\n           apply-rules (fn [[c n]] \n                    (cond \n                        (< n 2) nil\n                        (= n 2) (cells c)\n                        (= n 3) c\n                        :else nil))\n            new-cells (set (filter identity (map apply-rules neighbor-map)))\n            new-board (str-board h w new-cells)\n        ]\n        (println cells)\n        (println (neighbors [0 0]))\n        (println neighbor-map)\n        (println)\n        (println)\n        (println new-cells)\n        (map println new-board)\n        new-board\n        ))","problem":94,"user":"51f59607e4b0abb92f97f9d5"},{"problem":94,"code":"(fn [board]\n  (letfn [(alive [[r c]]\n            (when (< -1 r (count board))\n              (let [row (nth board r)]\n                (when (< -1 c (count row))\n                  (= \\# (nth row c))))))\n          (living-neighbors [r c]\n            (- (count\n                 (filter alive (for [dr (range -1 2) dc (range -1 2)]\n                                 [(+ r dr) (+ c dc)])))\n               (if (alive [r c]) 1 0)))\n          (step [r c]\n            (let [n (living-neighbors r c)]\n              (if (alive [r c])\n                (if (<= 2 n 3) \\# \" \")\n                (if (= 3 n) \\# \" \"))))]\n    (map-indexed\n      (fn [r row]\n        (apply str (map-indexed\n                     (fn [c cell]\n                       (step r c)) row))) board)))","user":"553abb28e4b09218d5f44ffb"},{"problem":94,"code":"(fn life[data]\n  (let [grid (into {} (for [[y row] (map-indexed vector data)\n                            [x val] (map-indexed vector row)]\n                            {[x y] val}))\n        live? (fn [n] (let [val (grid n) ] (= \\# val)))\n        live-neighbours\n              (fn [node]\n                (let [x (first node) y (last node)\n                      alln (vector\n                             [(dec x) (dec y)] [x (dec y)] [(inc x) (dec y)]\n                             [(dec x) y      ]             [(inc x) y      ]\n                             [(dec x) (inc y)] [x (inc y)] [(inc x) (inc y)])]\n                  (->> alln (filter live?) (count))))\n        next-state\n              (fn [node]\n                (let [x (first node) y (last node)\n                      n (live-neighbours [x y])\n                      l? (live? [x y])\n                      s (if l? \\# \\space)]\n                  (cond\n                    (and l? (> 2 n)) (assoc {} node \\space)\n                    (and l? (< 3 n)) (assoc {} node \\space)\n                    (and (not l?) (= 3 n)) (assoc {} node \\#)\n                    :else (assoc {} node s)\n                    )))\n        new-life (into {} (mapcat next-state (keys grid)))\n        rowstr (fn [grid row]\n                 (->> (keys grid)\n                      (filter #(= row (second %)))\n                      (sort-by first)\n                      (map #(get grid %))\n                      (apply str)))\n        rows (range (count data))\n        result (map (partial rowstr new-life) rows)\n        ]\n    (doall (map println result))\n    result\n    ))","user":"52f426fce4b05e3f0be25f1e"},{"code":"(fn [board]\n  (letfn [(new-cell [cell ns]\n            (let [live-neighbours (get (frequencies ns) \\# 0)]\n              (if (= (get-in board cell) \\space)\n                (if (= 3 live-neighbours)\n                  \\#\n                  (get-in board cell))\n                (cond\n                 (< live-neighbours 2) \\space\n                 (#{2 3} live-neighbours) \\#\n                 (> live-neighbours 3) \\space))))\n          (neighbours [[x y]]\n            (for [i [-1 0 1]\n                  j [-1 0 1]\n                  :when (not= i j 0)\n                  :let [[nx ny :as nxy] [(+ x i) (+ y j)]]]\n              (get-in board nxy)))]\n    (for [i (range (count board))]\n      (clojure.string/join\n       (for [j (range (count (board i)))\n             :let [cell [i j]]]\n         (new-cell cell (neighbours cell)))))))","problem":94,"user":"510db6cde4b078ea71921145"},{"code":"(fn [board]\n  (let [r (range (count board))\n        deltas [[-1 -1] [-1 0] [-1 1] [0 -1] [0 1] [1 -1] [1 0] [1 1]]\n        living-around (fn [p] (filter #{\\#} (map #(get-in board %) (map #(map + p %) deltas))))\n        get-next (fn [p]\n                   (let [n (count (living-around p))]\n                     ({false \\space, true \\#}\n                      (if (#{\\#} (get-in board p))\n                        (< 1 n 4)\n                        (= 3 n)))))]\n    (for [x r] (apply str (map #(get-next [x %]) r)))))","problem":94,"user":"4ec5aa1f535d6d7199dd36b0"},{"problem":94,"code":"(fn [board]\n  (let [width (count (first board))\n        height (count board)\n        get-neighbours (fn [x y]\n                         (for [dx (range -1 2)\n                               dy (range -1 2)\n                               :when (not (and (zero? dx) (zero? dy)))]\n                           (get (get board (+ y dy)) (+ x dx))))\n        get-alive-neighbours (comp count (partial filter #(= % \\#)) get-neighbours)\n        new-value (fn [old aliveNeighbours]\n                    (if (= old \\#)\n                      (if (and (> aliveNeighbours 1) (< aliveNeighbours 4)) \\# \\space)\n                      (if (= aliveNeighbours 3) \\# \\space)))]\n    (map (partial apply str)\n         (partition width\n                    (map (partial apply new-value)\n                         (for\n                             [y (range height) x (range width)]\n                             [(get (get board y) x) (get-alive-neighbours x y)]))))))","user":"5f972ed6e4b0715f5002d7f2"},{"problem":94,"code":"(fn step [b]\n  (letfn [(v [b [x y]] (get (get b y) x))\n          (nbrs [b c]\n            (->> [[-1 -1] [0 -1] [1 -1] [-1 0] [1 0] [-1 1] [0 1] [1 1]]\n                 (map #(map + c %))\n                 (filter #(not (nil? (v b %))))))\n          (live? [b c]  (= (v b c) \\#))\n          (step-c [b c]\n            (let [l (reduce + (map #(if (live? b %) 1 0) (nbrs b c)))]\n              (if (live? b c)\n                (cond (< l 2) \\ \n                      (> l 3) \\ \n                      :else \\#)\n                (if (= l 3) \\# \\ ))))]\n   (->> (for [x (range (count b))\n              y (range (count (first b)))]\n          (step-c b [x y]))\n        (partition (count b))\n        (apply map str))))","user":"53b39d82e4b047364c0444a6"},{"problem":94,"code":"(fn [x]\n  (let [cell;判定一个细胞下一刻的死活\n    (fn [self neighbours]\n      (let [lives (count (filter #{\\#} neighbours))];要注意字符和字符串的区别\n        (cond (= \\space self) (if (= 3 lives) \"#\" \" \" )\n              (> 2 lives) \" \"\n              (< 3 lives) \" \"\n              :else \"#\")))\n        ;获取一个细胞，如果index超过范围，返回nil\n        get-cell #(if (or (> 0 %1) (> 0 %2) (<= (count x) %1) (<= (count (nth x %1)) %2)) nil (nth (nth x %1) %2))\n        ;一组函数，用来计算包括自己的附近9个格子\n        index9 (#(for [l % r %] [l r]) [#(dec %) #(identity %) #(inc %)])\n        get-neighbours (fn [i j] (map (partial apply get-cell) (remove #{[i j]} (map #(vector ((first %) i) ((second %) j)) index9))))]\n    (loop[i 0 j 0 result [] temp \"\"];遍历源，计算并连接结果\n      (cond (= i (count x)) result\n            (= j (count (nth x i))) (recur (inc i) 0 (conj result temp) \"\")\n            :else (recur i (inc j) result (str temp (cell (get-cell i j) (get-neighbours i j))))))))","user":"580d7de3e4b0849f6811b73d"},{"problem":94,"code":";; http://www.4clojure.com/problem/94\n;; Game of Life\n(fn next-board\n  [board]\n  (letfn [(cell-at\n            [y x]\n            (if (or (neg? y) (neg? x) (>= y 5) (>= x 5))\n              \\E\n              (nth (nth board y) x))            \n            ;; (try \n            ;;   (nth (nth board y) x)\n            ;;   (catch IndexOutOfBoundsException e \\E))\n            )\n          (num-neighbours\n            [y x]\n            (count (filter #(= \\# %)\n                           (list (cell-at (dec y) (dec x))\n                                 (cell-at y (dec x))\n                                 (cell-at (inc y) (dec x))\n\n                                 (cell-at (dec y) x)\n                                 (cell-at (inc y) x)\n\n                                 (cell-at (dec y) (inc x))\n                                 (cell-at y (inc x))\n                                 (cell-at (inc y) (inc x))))))\n          (next-cell-at\n            [y x]\n            (let [c (cell-at y x)\n                  n (num-neighbours y x)]\n              (if (= \\# c)\n                (cond \n                  (< n 2) \\ \n                  (< n 4) \\#\n                  :else \\ )\n                (if (= n 3)\n                  \\#\n                  \\ ))))]\n\n    (for [y (range (count board))]\n      (apply str\n             (let [row (nth board y)]\n               (for [x (range (count row))]\n                 (next-cell-at y x)))))))","user":"5c92105ce4b048ec896c59f7"},{"problem":94,"code":"(fn life [board]\n  (letfn [(step [from dir]\n                (condp = dir\n                  :left       (update-in from [1] dec)\n                  :up-left    (update-in (update-in from [1] dec) [0] dec)\n                  :up         (update-in from [0] dec)\n                  :up-right   (update-in (update-in from [1] inc) [0] dec)\n                  :right      (update-in from [1] inc)\n                  :down-right (update-in (update-in from [1] inc) [0] inc)\n                  :down       (update-in from [0] inc)\n                  :down-left  (update-in (update-in from [1] dec) [0] inc)))\n          \n          (get-neighbors [coord]\n                         (conj #{} \n                               (step coord :left)\n                               (step coord :up-left)\n                               (step coord :up)\n                               (step coord :up-right)\n                               (step coord :right)\n                               (step coord :down-right)\n                               (step coord :down)\n                               (step coord :down-left)))\n\n          (how-many-neighbors? [board coord]\n                               (let [neighbors (filter #(= \\# (get-in board %)) (get-neighbors coord))]\n                                 (count neighbors)))\n\n          (aware-board [board]\n                       (let [coords (for [y (range (count board)) \n                                          x (range (count (first board)))]\n                                      [y x])\n                             m-f (fn [coord] {:coord coord :val (get-in board coord) :num-neighbors (how-many-neighbors? board coord)})\n                             m (map m-f coords)\n                             ]\n                         (into #{} m)))\n\n          ;; Note: case is faster than cond and condp, and near-equivalent to if.\n          (next-gen [cell num-neighbors]\n                    (if (= cell \\#)\n                      (case num-neighbors\n                        0 \\space\n                        1 \\space\n                        2 \\#\n                        3 \\#\n                        \\space)\n                      (case num-neighbors\n                        3 \\#\n                        \\space)))\n\n          (next-cell [board cell-data ]\n                     (let [vboard (vec (map vec board))\n                           vb-next (assoc-in vboard (:coord cell-data) (next-gen (:val cell-data) (:num-neighbors cell-data)) )\n                           v-st-board (vec (map #(apply str %) vb-next))] v-st-board ))\n\n          ]\n    (let [ab (aware-board board)] \n      (reduce #(next-cell %1 %2) board ab))))","user":"5ff676a9e4b06df49cee1497"},{"problem":94,"code":"(fn p-94 [b-strings]\n\n  (let [\n        max-x (dec (count (first b-strings)))\n        max-y (dec (count b-strings))\n      cartesian-product (fn cartesian-product [a b]\n                          (for [e1 a\n                                e2 b]\n                            (list e1 e2)))\n\n\n        translate-to-array (fn translate-to-array [b-strings]\n                           (vec (map (partial into []) b-strings)))\n\n      cell-alive-at (fn cell-alive-at [b-array x y]\n                      (= \\# (get (get b-array x) y)))\n\n      num-alive-at (fn num-alive-at [b-array x y del-x del-y]\n                     (cond (and (= del-x 0) (= del-y 0)) 0\n                           (and (= x 0) (= del-x -1)) 0\n                           (and (= y 0) (= del-y -1)) 0\n                           (and (= x max-x) (= del-x 1)) 0\n                           (and (= y max-y) (= del-y 1)) 0\n                           (cell-alive-at b-array (+ x del-x) (+ y del-y)) 1\n                           :else 0))\n\n      num-neighbors-alive (fn num-neighbors-alive [b-array x y]\n                            (let [delta-range '(-1 0 1)\n                                  delta-pairs (cartesian-product delta-range delta-range)    \n                                  neighbors (map (fn [[del-x del-y]] (num-alive-at b-array x y del-x del-y)) delta-pairs)]\n                              (reduce + neighbors)))\n\n      cell-alive-next-gen (fn cell-alive-next-gen [am-alive neighbor-count]\n                            (cond\n                              (< neighbor-count 2) false\n                              (and am-alive (or (= neighbor-count 2) (= neighbor-count 3))) true\n                              (and am-alive (< 3 neighbor-count)) false\n                              (and (not am-alive) (= neighbor-count 3)) true\n                              :else false ; not alive, neighbor count is 2, 4+\n                              ))\n      b-array (translate-to-array b-strings)\n      coords (cartesian-product (range (inc max-x)) (range (inc max-y)))\n      alives (map (fn [[x y]] (cell-alive-at b-array x y)) coords)\n      neighbor-alives (map\n                       (fn [[x y]] (num-neighbors-alive b-array x y))\n                       coords)\n      alive-pairs (map list alives neighbor-alives)\n      newly-alive (map (fn [[me them]] (cell-alive-next-gen me them)) alive-pairs)\n      new-symbol (map #(if % \\# \\space) newly-alive)\n      new-board (map #(apply str %) (partition (inc max-x) new-symbol))\n        ]\n    ;(println \"coords:\" coords)\n    ;(println \"alives:\" alives)\n   ; (println \"neighbors:\" neighbor-alives)\n   ; (println \"alive-pairs:\" alive-pairs)\n    ;newly-alive\n   \n    ;alive-pairs\n  (vec new-board)))","user":"5bfc9037e4b0bdcf453d15f2"},{"problem":94,"code":"(fn [board]\n   (letfn [(neighbour-count [x y]\n             (count\n              (filter (fn [c] (= c \\#))\n                      (reduce (fn [acc pt]\n                                (if-let [c (get-in board pt)]\n                                  (cons c acc)\n                                  acc))\n                              '()\n                              (remove (fn [v] (= v [x y])) (for [x1 [(dec x) x (inc x)]\n                                                                 y1 [(dec y) y (inc y)]]\n                                                             [x1 y1]))))))]\n     (vec\n      (map-indexed (fn [y row]\n                     (apply str\n                            (map-indexed (fn [x v]\n                                           (let [c (neighbour-count y x)]\n                                             (cond\n                                               (< c 2) \\space\n                                               (= c 2) v\n                                               (= c 3) \\#\n                                               (> c 3) \\space))) row))) board))))","user":"5a250b86e4b07f18be40aa19"},{"problem":94,"code":"(fn game-of-life\n  [board]\n  (letfn [(layout [board]\n            (vec (map #(reduce conj [] (map (fn [block] (if (= block \\space) nil 1)) %)) board)))\n          (neighbours [[x y]]\n            (for [dx [-1 0 1] dy [-1 0 1] :when (not= 0 dx dy)] [(+ dx x) (+ dy y)]))\n          (count-neighbours [board loc]\n            (count (filter #(get-in board %) (neighbours loc))))\n          (print-board [layout]\n            (map #(apply str (map (fn [block] (if block \\# \\space)) %)) layout))\n          (predict []\n            (let [input (layout board)\n                  h (count input)\n                  w (count (input 0))]\n              (map (fn [row]\n                     (map (fn [col]\n                            (let [self ((input row) col)\n                                  neighbors (count-neighbours input [row col])]\n                              (cond (and self (< neighbors 2)) nil\n                                    (and self (or (= neighbors 2) (= neighbors 3))) 1\n                                    (and self (> neighbors 3)) nil\n                                    (and (not self) (= neighbors 3)) 1)))\n                          (range 0 w)))\n                   (range 0 h))))]\n    (print-board (predict))))","user":"58f98231e4b0438e51c2cf4c"},{"code":"(fn [text]\n  (letfn [(text->full-board [text]\n            (apply concat\n                   (map-indexed (fn [y r]\n                                  (map-indexed (fn [x c]\n                                                 [x y c])\n                                               r))\n                                text)))\n          (input-alive? [[x y c]]\n            (not= \\space c))\n          (max-x [full-board]\n            (apply max (map first full-board)))\n          (max-y [full-board]\n            (apply max (map second full-board)))\n          (board->text [board max-x max-y]\n            (map (partial apply str)\n                 (for [y (range 0 (inc max-y))]\n                   (for [x (range 0 (inc max-x))]\n                     (if (contains? board [x y]) \\# \\space)))))\n          (neighbor-positions [[x y]]\n            (for [x-delta [-1 0 1]\n                  y-delta [-1 0 1]\n                  :when (not= 0 x-delta y-delta)]\n              [(+ x x-delta) (+ y y-delta)]))\n          (alive? [board pt]\n            (contains? board pt))\n          (living-neighbors [board pt]\n            (count (filter\n                    (partial alive? board)\n                    (neighbor-positions pt))))\n          (fringe [board]\n            (let [local-area (set (mapcat neighbor-positions board))]\n              (clojure.set/difference local-area board)))]\n    (let [full-board (text->full-board text)\n          board (->> full-board\n                     (filter input-alive?)\n                     (map (partial take 2))\n                     set)\n          stays-alive (filter #(<= 2 (living-neighbors board %) 3) board)\n          comes-alive (filter #(= 3 (living-neighbors board %)) (fringe board))\n          next-board (set (concat stays-alive comes-alive))]\n      (board->text next-board (max-x full-board) (max-y full-board)))))","problem":94,"user":"4e80aa10535db62dc21a62b1"},{"problem":94,"code":"(fn [board]\n  (let [width (count (first board))\n        height (count board)\n        data (vec (apply str board))\n        size (count data)\n        wrap- (fn [i d]\n               (mod (- (+ i size) d) size))\n        wrap+ (fn [i d]\n                (mod (+ i d) size))\n        n (fn [i] ; count the number of live cells around an index\n            (count\n              (filter\n               #(= \\# %)\n               [\n                (nth data (wrap- i (+ width 1))) ;nw          \n                (nth data (wrap- i width)) ;n\n                (nth data (wrap- i (- width 1))) ;ne\n                (nth data (wrap- i 1)) ;w\n                (nth data (wrap+ i 1)) ;e\n                (nth data (wrap+ i (- width 1))) ;sw\n                (nth data (wrap+ i width)) ;s\n                (nth data (wrap+ i (+ width 1))) ;se\n               ])))\n        state (map\n               #(if (= \\# %1)\n                  (let [c (n %2)]\n                    (cond\n                     (> c 3) \\space\n                     (< c 2) \\space\n                     :else \\#))\n                  (let [c (n %2)]\n                    (cond\n                     (= 3 c) \\#\n                     :else \\space)))\n               data\n               (range))]\n    (map\n     #(apply str %)\n     (partition width state))))","user":"54dd76c8e4b024c67c0cf794"},{"problem":94,"code":"(fn[grid]\n        (let [nrows (count grid)\n              ncols (count (grid 0))\n              \n              grid->set \n              (fn[grid]\n                (loop [r 0 c 0 res #{}]\n                  (let [cell (nth (nth grid r) c)\n                        next-c (mod (inc c) ncols)\n                        next-r (if (zero? next-c) (inc r) r)]\n                    (if (= nrows next-r) \n                      res\n                      (recur next-r next-c \n                             (if (= \\# cell) \n                               (conj res [r c])\n                               res))))))\n              \n              set->grid\n              (fn [set]\n                (let [tmp (for [r (range nrows)\n                                c (range ncols)]\n                            (some #{[r c]} set))]\n                  (into[] (for [r (partition ncols \n                                             (map #(if (nil? %) \\space \\#) tmp))]\n                            (apply str (interpose \"\" r))))))\n\n              neighbors \n              (fn[[x y]]\n                (for [dx [-1 0 1]\n                      dy (if (zero? dx)\n                           [-1 1]\n                           [-1 0 1])]\n                  [(+ dx x) (+ dy y)]))\n              \n              live \n              (fn [n alive?]\n                (or (= n 3)\n                    (and (= n 2) alive?)))\n\n              step \n              (fn [world]\n                (set\n                 (for [[cell n] (frequencies (mapcat neighbors world))\n                       :when (live n (world cell))]\n                   cell)))\n              ]\n          \n          (-> grid\n              grid->set\n              step\n              set->grid)))","user":"57e6f90de4b0bfb2137f5af6"},{"code":"(fn [coll]\r\n  (let [ylen (count coll)\r\n        xlen (count (coll 0))\r\n        num (fn [y x]\r\n              (->> (list\r\n                     (list dec dec)\r\n                     (list dec identity)\r\n                     (list dec inc)\r\n                     (list identity dec)\r\n                     (list identity inc)\r\n                     (list inc dec)\r\n                     (list inc identity)\r\n                     (list inc inc))\r\n                   (map #(let [[fy gx] %]\r\n                          (list (fy y) (gx x))))\r\n                   (map #(let [[y2 x2] %]\r\n                          (if (or (< y2 0)\r\n                                  (< x2 0)\r\n                                  (>= y2 ylen)\r\n                                  (>= x2 xlen))\r\n                            0\r\n                            (if (= (nth (coll y2) x2) \\#)\r\n                              1\r\n                              0))))\r\n                   (apply +)))\r\n       ]\r\n    (->>\r\n      (for [y (range 0 ylen)]\r\n        (for [x (range 0 xlen)]\r\n          (let [n (num y x)]\r\n            (if (= (nth (coll y) x) \\#)\r\n              (cond\r\n                (< n 2) \\space\r\n                (> n 3) \\space\r\n                :else \\#)\r\n              (if (= n 3) \\# \\space)))))\r\n      (map #(apply str %)))))","problem":94,"user":"4dbe68c7535d020aff1edf5e"},{"code":"(fn [v]\n  (let [t (vec (map (fn [s] (vec (map #(if (= % \\#) 1 0) s))) v))\n        h (count t)\n        w (count (t 0))\n        g (fn [[x y]] (get (get t y) x 0))\n        n (fn [x y] (for [a (range (- x 1) (+ x 2)) b (range (- y 1) (+ y 2))]\n                      [a b]))\n        c (fn [x y] (apply + (map g (n x y))))\n        s (fn [x y] (if (= 0 (g [x y])) \n                      (if (= (c x y) 3) 1 0)\n                      (let [d (c x y)] (if (or (< d 3) (> d 4)) 0 1))))]\n    (for [y (range h)] (apply str (map [\\ \\#] (for [x (range w)] (s x y)))))))","problem":94,"user":"50fbdacfe4b0d10d794c19f0"},{"code":"(fn [ar](->>\n (map \n (fn [el] ; <= gets all neighbors\n (let [x (first el) y (last el)]\n    (filter \n    \n    (fn [s] \n    (and \n    (not-any? neg? s)\n    (not-any? #(< (dec (count ar)) %) s))\n    )\n    \n    (partition 2 \n    (interleave \n     (map #(+ x %)[-1  0  1 -1 1 -1 0 1])\n     (map #(+ y %)[-1 -1 -1 0  0 1 1 1]))))))\n (partition 2 (flatten (map #(interleave (repeat %)(range (count ar)))(range (count ar))))))\n  (map #(map (fn[el]\n  (let [x (first el) y (last el)]\n\n  (get \n    (get \n      ar x)\n    y)\n  )\n\n  )%))\n\n  (map #(filter (fn [i] (= \\# i))%))\n  (map count) \n  (interleave (flatten (map vec ar)))\n  (partition 2)\n  (map\n  (fn [pair]\n  (let [now (first pair) c (last pair)]\n  (cond \n    (and (= \\# now) (> 2 c)) \\space\n    (and (= \\# now) (or (= 2 c)(= 3 c))) \\#\n    (and (= \\# now) (< 3 c)) \\space\n    (and (= \\space now) (= 3 c)) \\#\n    :else \\space)\n  )))\n  (partition (count ar))\n  (map #(apply str %))\n ))","problem":94,"user":"4f0446f9535dcb61093f6bb8"},{"problem":94,"code":"(fn [b]\n  (let [\n        lx (count b) ly (count (first b))\n        dv [-1 0 1]\n        lc (set (mapcat identity (map-indexed (fn [i t] (keep-indexed (fn [j s] (when (= \\# s) [i j])) t)) b))) \n        gn (fn [[x y]] (dissoc (zipmap (filter #(and (<= 0 (% 0) lx) (<= 0 (% 1) ly)) (mapcat #(map (fn [d] [(+ d x) (+ % y)]) dv) dv)) (repeat 1)) [x y]))\n        nc (reduce #(merge-with + %1 (gn %2)) {} lc)\n        ]\n    (for [x (range lx)]\n      (apply str (for [y (range ly)]\n                   (cond (and (= 2 (nc [x y])) (lc [x y])) \\#\n                         (= 3 (nc [x y])) \\#\n                         :else \\space))))))","user":"53e745a1e4b036ad0777e479"},{"problem":94,"code":"(fn [b]\n  (let [c count m map e [-1 0 1]\n        n (fn [x y] (for [i e j e :when (not= i j 0)] [(+ x i) (+ y j)]))\n        s (c b) r (range s)\n        g (fn [[x y]] (get (get b y) x))\n        a (fn [p] (= (g p) \\#))]\n    (map #(apply str %)\n         (map\n           (fn [y]\n             (map #(let [n (n % y) an (count (filter a n))]\n                     (if (if (a [% y]) (<= 2 an 3) (= an 3)) \\# \\ ))\n                  r))\n           r))))","user":"5a244240e4b0ff51aa4b32e9"},{"code":"(fn [rows]\n  (let [nc (count (first rows))\n        nr (count rows)\n        c (* nc nr)\n        b (apply str rows)\n        live? #(= \\# (nth b % \\ ))\n        live-neighbors-count (fn [n] (count (filter live? [(- n nc 1)  (- n nc) (- n nc -1)\n                                                           (dec n)              (inc n)\n                                                           (+ n nc -1) (+ n nc) (+ n nc 1)])))\n        next-gen (fn [n]\n                   (let [nc (live-neighbors-count n)]\n                     (if (live? n)\n                       (if (#{2 3} nc) \\# \\ )\n                       (if (= 3 nc) \\# \\ ))))]\n    (map #(apply str %) (partition nc (map next-gen (range c))))))","problem":94,"user":"500aa15ee4b03d00572d2d76"},{"problem":94,"code":"(fn [board]\n   (letfn\n     [(deltas []\n        (for [y (range -1 2) x (range -1 2) :when (not= [y x] [0 0])] [y x]))\n\n      (neighbour-coords\n        ([size yx] (neighbour-coords (deltas) size yx))\n        ([deltas size yx]\n         (filter\n           (fn [new-yx] (every? #(< -1 % size) new-yx))\n           (map #(vec (map + yx %)) deltas))))\n\n      (num-neighbours\n        [board yx]\n        (->> (neighbour-coords (count board) yx)\n             (map (partial get-in board))\n             (filter (partial = \\#))\n             (count)))\n\n      (next-state\n        [board yx]\n        (let [alive (= (get-in board yx) \\#)\n              num   (num-neighbours board yx)]\n          (if alive\n            (if (<= 2 num 3) \"#\" \" \")\n            (if (= num 3) \"#\" \" \"))))\n\n      (life\n        [board]\n        (let [size (count board)\n              next-states (for [x (range 0 size) y (range 0 size)]\n                            (next-state board [x y]))\n              next-rows (partition size next-states)]\n           (map #(apply str %) next-rows)))]\n\n     (life board)))","user":"58b51e05e4b0ebc645576d4c"},{"code":"(letfn [(count-alives [x y board]\r\n          (count\r\n            (filter #(= % \\#)\r\n                    (for [i (range (max (dec x) 0)\r\n                                   (min (+ 2 x) (count board)))\r\n                          j (range (max (dec y) 0)\r\n                                   (min (+ 2 y) (count (board 0))))\r\n                          :when (not (and (== i x) (== j y)))]\r\n                      (nth (board i) j)))))\r\n        (map-cell [x y board]\r\n          (let [cell (nth (board x) y)\r\n                n-alives (count-alives x y board)]\r\n            (if (= cell \\#)\r\n                (if (or (== 2 n-alives)\r\n                        (== 3 n-alives))\r\n                    \\#\r\n                  \\space)\r\n              (if (== 3 n-alives)\r\n                  \\#\r\n                \\space))))]\r\n  (fn gol [board]\r\n    (into []\r\n          (map-indexed\r\n            (fn [i row]\r\n              (apply str\r\n                     (map-indexed\r\n                       (fn [j _]\r\n                         (map-cell i j board))\r\n                       row)))\r\n             board))))","problem":94,"user":"4fcc6cb3e4b0ee37620e1861"},{"code":"(fn [b]\n  (let [clean-board\n        (fn [b]\n          (vec (repeat (count b) (vec (repeat (count (b 0)) \\space)))))\n\n         neighbors \n         (fn [b [r c]]\n          (let [s [[(dec r) (dec c)] [(dec r) c] [(dec r) (inc c)]\n                    [r (dec c)] [r (inc c)]\n                    [(inc r) (dec c)] [(inc r) c] [(inc r) (inc c)]]]\n            (map (fn [x] (get-in b x)) s)))       \n\n        live-neighbors \n        (fn [b [r c]]\n          (count (filter (fn [x] (= x \\#)) (neighbors b [r c]))))\n\n        alive?\n        (fn [b [r c]]\n          (= \\# (get-in b [r c])))\n\n        lives? (fn [b [r c]]\n          (let [alive (alive? b [r c]) nc (live-neighbors b [r c])]\n            (cond\n              (and (true? alive) (<= 2 nc 3)) true\n              (and (false? alive) (= 3 nc)) true\n              :else false)))]\n    (->>\n    (for [r (range (count b)) c (range (count (b 0))) :when (lives? b [r c])]\n      [r c])\n    (reduce (fn [acc x] (assoc-in acc x \\#)) (clean-board b))\n    (map (fn [x] (apply str x))))))","problem":94,"user":"50783762e4b0fc74642bff67"},{"problem":94,"code":"(fn gol\n  [input]\n  (let [board (mapv #(vec (seq %)) input)\n        tetangga (fn [i j]\n                   (let [f (map #(get-in board [(dec i) %]) (map #(+ j %) [-1 0 1]))\n                         s (map #(get-in board [i %]) (map #(+ j %) [-1 1]))\n                         t (map #(get-in board [(inc i) %]) (map #(+ j %) [-1 0 1]))]\n                     (count (filter #(= \\# %) (flatten [f s t])))))\n        condi-live (fn [n]\n                     (cond\n                       (< n 2) \\space\n                       (<= n 3) \\#\n                       (> n 3) \\space))\n        condi-dead (fn [n]\n                     (if (= 3 n)\n                       \\#\n                       \\space))\n        cr (count board)\n        cc (count (first board))\n        ij (for [i (range 0 cr)\n                 j (range 0 cc)]\n             [i j])\n        raw (mapv (fn [koor] (let [[i j] koor]\n                              [(get-in board [i j]) (tetangga i j)]))\n                 ij)\n        beres (mapv (fn [x]\n                      (let [[r rs] x]\n                        (if (= r \\#)\n                          (condi-live rs)\n                          (condi-dead rs))))\n                    raw)]\n    (map #(apply str %) (partition cc beres))))","user":"54b7f217e4b0ed20f4ff6e8f"},{"code":"(fn [board]\n  (let [at (fn [x y]\n             (cond\n              (< x 0) false\n              (>= x (count (first board))) false\n              (< y 0) false\n              (>= y (count board)) false\n              :else (= (nth (nth board y) x) \\#)))\n        live-neighbors (fn [x y]\n                         (count (filter identity (for [x' [(dec x) x (inc x)]\n                                                       y' [(dec y) y (inc y)]\n                                                       :when (not (and (= x x') (= y y')))]\n                                                   (at x' y')))))\n        ]\n    (concat (for [y (range 0 (count board))\n                  :let [row (nth board y)]]\n             (apply str (map #(if % \\# \\space)\n              (for [x (range 0 (count row))\n                    :let [n (live-neighbors x y)\n                          live (at x y)]]\n               (cond\n                (and live (or (= n 2) (= n 3))) true\n                (and (not live) (= n 3)) true\n                :else false))))))))","problem":94,"user":"524cdd51e4b0752c4cb68ccc"},{"problem":94,"code":"(fn [grid]\n  (let [\n\n        ; Possible states\n        dead \" \"\n        living \"#\"\n\n        ; Relative coordinates to valid neighbors\n        ; from a given coordinate\n        rel-neighbors [ [-1 -1]\n                        [-1 0]\n                        [-1 1]\n                        [0 -1]\n                        [0 1]\n                        [1 -1]\n                        [1 0]\n                        [1 1] ]\n        \n        living? (fn [v] (= v living))\n\n        get-row-cell (fn [row x]\n                       (str (nth (seq row) x)))\n\n        get-grid-row (fn [grid y]\n                       (nth grid y))\n\n        get-grid-cell (fn [grid x y]\n                        (get-row-cell (get-grid-row grid y) x))\n\n        get-grid-size (fn [grid]\n                        [(count (nth grid 0)) (count grid)])\n\n        get-neighbors (fn [x y]\n                        (map (fn [n]\n                               (let [nx (nth n 0)\n                                     ny (nth n 1)]\n                                 [(+ x nx) (+ y ny)])) rel-neighbors))\n\n        get-valid-neighbors (fn [x y w h]\n                              (filter (fn [n]\n                                        (let [nx (nth n 0) ny (nth n 1)]\n                                          (and (>= nx 0) (< nx w) (>= ny 0) (< ny h)))) (get-neighbors x y)))\n\n        get-living-neighbors (fn [grid x y]\n                               (let [size (get-grid-size grid)]\n                                 (filter #(living? (get-grid-cell grid (nth % 0) (nth % 1))) (get-valid-neighbors x y (nth size 0) (nth size 1)))))\n\n        next-state (fn [s n]\n                     (if (or (< n 2) (> n 3))\n                       dead\n                       (if (= n 3)\n                         living\n                         s)))\n\n        next-grid (fn [grid]\n                    (let [size (get-grid-size grid)\n                          w (nth size 0)\n                          h (nth size 1)]\n                      (map (fn [j]\n                            (clojure.string/join (map (fn [i]\n                                                        (next-state (get-grid-cell grid i j) (count (get-living-neighbors grid i j)))) (range 0 w)))) (range 0 h))))]\n\n    (next-grid grid)))","user":"524d91eae4b0a16e35cf6dee"},{"code":"(let [values {\\space 0\n                \\# 1}\n\n        characters (clojure.set/map-invert values)\n\n        to-board (fn [strs] (vec (map #(vec (map values (vec %))) strs)))\n        to-string (fn [board] (map #(apply str (map characters %)) board))\n\n        kernel (for [x '(-1 0 1) y '(-1 0 1) :when (not= x y 0)] [x y])\n\n        board-coords (fn [w h] (for [x (range 0 w) y (range 0 h)] [x y]))\n        neighbour-coords (fn [[x y]] (map (fn [[xk yk]] [(+ x xk) (+ y yk)])\n                                          kernel))\n\n        new-value (fn [old n] (if (= 1 old)\n                                (cond (< n 2) 0\n                                      (< n 4) 1\n                                      :else   0)\n                                (if (= n 3) 1 0)))\n\n        num-neighbours (fn [[x y] b] (reduce + (map #(get-in b % 0)\n                                                    (neighbour-coords [x y]))))\n\n        next-board (fn [board]\n                     (partition (count board) (map new-value\n                                                   (flatten board)\n                                                   (map #(num-neighbours % board)\n                                                        (board-coords (count (first board)) (count board))))))\n\n        ]\n    (fn [b] (vec (to-string (next-board (to-board b))))))","problem":94,"user":"5370ef22e4b0fc7073fd6ea0"},{"code":"(fn __ [board]\r\n  (let [neighbor-offsets [[-1 -1] [-1 0] [-1 1] [0 -1] [0 1] [1 -1] [1 0] [1 1]]\r\n        live? #{2 3}\r\n        birth? #{3}\r\n        dead? #{\\space}\r\n        alive? #{\\#}\r\n        neighbors (fn [dim yx]\r\n                    (for [o neighbor-offsets\r\n                          :let [new-yx (map + yx o)]\r\n                          :when (every? #(< -1 % dim) new-yx)]\r\n                      (vec new-yx)))\r\n        count-neighbors (fn [board yx]\r\n                          (count (for [yx (neighbors (count board) yx)\r\n                                       :when (= \\# (get-in board yx))]\r\n                                   1)))\r\n        update-cell (fn [board & yx]\r\n                      (let [cell (get-in board yx)\r\n                            alive-neighbors (count-neighbors board yx)]\r\n                        (if (or (and (alive? cell)\r\n                                     (live? alive-neighbors))\r\n                                (and (dead? cell)\r\n                                     (birth? alive-neighbors)))\r\n                          \\#\r\n                          \\space)))]\r\n    (for [row (range (count board))]\r\n      (apply str (for [col (range (count (board row)))]\r\n                   (update-cell board row col))))))","problem":94,"user":"4dc7e8c6535d8a4b2fd74291"},{"code":"(fn [board]\n  (letfn [(conj-in\n            [coll [k & ks] v]\n            (if ks\n              (assoc coll k (conj-in (get coll k []) ks v))\n              (assoc coll k v)))\n          (get-cell \n            ([board x y]\n              (get-cell board x y \\space))\n            ([board x y df]\n              (let [c (count board)]\n                (if (or (< x 0)\n                        (>= x c) \n                        (< y 0)\n                        (>= y c))\n                  df\n                  ((board x) y)))))\n          (neirs \n            [board x y]\n            (for [dx '(-1 0 1)\n                  dy '(-1 0 1)\n                  :when (not (= 0 dx dy))]\n              (get-cell board (+ x dx) (+ y dy))))\n          (count-neirs [board x y]\n                       (count (filter #(= % \\#) (neirs board x y))))\n          (result \n            [board x y]\n            (if (or (= (count-neirs board x y) 3)\n                    (and (= (count-neirs board x y) 2)\n                         (= (get-cell board x y) \\#)))\n              \\#\n              \\space))\n          (get-all-cords [size]\n                         (for [x (range 0 size)\n                               y (range 0 size)]\n                           (vector x y)))\n          (step [board]\n                (loop [coord (get-all-cords (count board))\n                       res board]\n                  (if (nil? coord)\n                    res\n                    (let [crd (first coord)\n                          nw  (result board (first crd) (second crd))]\n                      (recur (next coord) \n                             (conj-in res crd nw)\n                             )))))\n          (parse [col]\n                 (into [] (map (comp (partial into []) seq) col)))\n          (com [board]\n               (into [] (map #(reduce str %) board)))\n          (pre-final [board]\n                     (com (step (parse board))))]\n         (pre-final board)))","problem":94,"user":"50e87427e4b0ebbe794eb7e8"},{"problem":94,"code":"(fn [in]\n    (let [p #{[0 1] [0 -1] [1 0] [-1 0] [1 1] [1 -1] [-1 1] [-1 -1]}\n          s (count (first in))\n          n (fn [[x y]]\n              (filter\n                (fn [[a b]] (and (< -1 a s) (< -1 b s)))\n                (map (fn [[a b]] [(+ a x) (+ b y)]) p)))]\n      (for [x (range s)]\n        (apply\n          str\n          (for [y (range s)]\n            (let [c ((frequencies (map #(get-in in %) (n [x y]))) \\#)]\n              (if (= (get-in in [x y]) \\space)\n                (if (= c 3)\n                  \\#\n                  \\space)\n                (cond\n                  (> c 3) \\space\n                  (> c 1) \\#\n                  :else \\space))))))))","user":"5a2df4a0e4b09cafd31c7f74"},{"problem":94,"code":"(letfn\n[\n(get-elem [b [x y]]\n  (nth (nth b x) y))\n(is-valid [b [x y]]\n  (let [rows (count b)\n        cols (count (first b))]\n    (and\n      (>= x 0)\n      (>= y 0)\n      (< x rows)\n      (< y cols))))\n(get-neighbors [b [x y]]\n  (filter #(is-valid b %1)\n    (for [x1 [(dec x) x (inc x)]\n          y1 [(dec y) y (inc y)]\n          :when (not= [x y] [x1 y1])]\n      [x1 y1])))\n(get-all [b]\n  (for [x (range 0 (count b))\n        y (range 0 (count (first b)))]\n    [x y]))\n(get-state [b xy]\n  [xy, (map #(get-elem b %) (get-neighbors b xy)), (get-elem b xy)])\n(get-next-state [[xy ns own]]\n  (let [nc (count (filter #(= \\# %1) ns))]\n  [xy\n    (cond (= own \\space) (if (= 3 nc) \\# \\space)\n          :else          (if (or (> nc 3) (< nc 2)) \\space \\#))]))\n(get-next-board [b]\n  (map get-next-state (map #(get-state b %) (get-all b))))\n(compose-board [bs]\n    (map\n      (comp clojure.string/join #(map (comp str second) %))\n      (vals (group-by ffirst bs))))]\n  (comp compose-board get-next-board))","user":"57717915e4b0979f896515b3"},{"code":"(fn [board]\n    (let [width (count (nth board 0))\n          height (count board)]\n      (letfn [(cell [row col] (get-in board [(mod row height) (mod col width)]))\n              (live? [c] (= \\# c))\n              (live-neighbors [row col]\n                (-\n                 (count (for [r (range (dec row) (+ 2 row))\n                              c (range (dec col) (+ 2  col))\n                              :when (live? (cell r c))]\n                          1))\n                 (if (live? (cell row col)) 1 0)))]\n        ;; Could memoize cell but these boards are small and we're only\n        ;; calculating one generation.\n        (map #(apply str %)\n             (partition width\n                        (for [row (range height)\n                              col (range width)\n                              :let [is-live (live? (cell row col))\n                                    ln (live-neighbors row col)]]\n                          (if is-live\n                            (cond (< ln 2) \\space           ; underpopulation\n                                  (or (= 2 ln) (= 3 ln)) \\# ; continue living\n                                  (> ln 3) \\space)          ; overpopulation\n                            (if (= ln 3)\n                              \\#        ; birth\n                              \\space)))))\n    )))","problem":94,"user":"4e89e939535d3e98b8023287"},{"problem":94,"code":"(fn [input]\n  (let [neighbours (fn [[y x]] (filter #(not= % [y x]) (for [i (range -1 2) j (range -1 2)] [(+ y i) (+ x j)])))\n        isLive (fn [[y x]] (and (>= y 0) (< y (count input)) (>= x 0) (< x (count (input y))) (not= (nth (input y) x) \\space)))\n        shouldLive (fn [p]\n                     (let [liveNeighbours (count (filter isLive (neighbours p)))]\n                       (or (= liveNeighbours 3) (and (isLive p) (= liveNeighbours 2)))))]\n    (map\n      (fn [i] (apply str (map #(if (shouldLive [i %]) \\# \\space) (range (count (input i))))))\n      (range (count input)))))","user":"4faf97d8e4b081705acca258"},{"problem":94,"code":"(fn solve [board]\n  (let [read-board (fn [board-strs]\n                     {:fields (mapv\n                               (fn [row] (mapv #(if (= \\space %) 0 1) row)) board-strs)\n                      :rows (count board-strs) :cols (count (get board-strs 1))})\n        surrounding-fields (fn [board field]\n                             (let [[x y] field\n                                   ixes (for [dx (range -1 2) dy (range -1 2) :when (not= dx dy 0)] [(+ x dx) (+ y dy)])\n                                   fields (:fields board)\n                                   neighbours (reduce + (filter #(= % 1) (map #(get-in fields %) ixes)))]\n                               neighbours))\n        update-single-field (fn [field neigh]\n                              (if (= field 1)\n                                (if (and (<= 2 neigh) (<= neigh 3)) 1 0)\n                                (if (= 3 neigh) 1 0)))\n        calc-new-board (fn [old-board]\n                         (reduce (fn myfunky [new-board coord]\n                                   (let [[row col] coord\n                                         value (get-in old-board [:fields row col])\n                                         neighbours (surrounding-fields old-board coord)\n                                         new-value (update-single-field value neighbours)]\n                                     (assoc-in new-board [:fields row col] new-value)))\n                                 old-board\n                                 (for [row (range (old-board :rows)) col (range (old-board :cols))] [row col])))\n        board (read-board board)]\n    (map (fn [row]\n           (apply str (map #(if (= 0 %) \" \" \"#\") row))) (:fields (calc-new-board board)))))","user":"59be62d5e4b0a024fb6ae435"},{"problem":94,"code":"(fn conway [rows]\n    (letfn [\n        (nearby [board x y]\n            ;(pp/pprint board)\n            (for [dx [-1 0 1] dy [-1 0 1]\n                  :when (not= [0 0] [dx dy])\n                  :let [x' (+ x dx) y' (+ y dy)]\n                  ] \n                  (get-in board [y' x'] ) ))\n                  \n        (next-cell [board x y ]\n            (let [vs (nearby board x y)\n                  fs (frequencies vs)  \n                  ov (get-in board [y x])\n                  nv (if (= ov \\# )\n                        (if (or (>  (fs \\#) 3) (< (fs \\#) 2)) \\  \\#)\n                        (if (= 3 (fs \\#)) \\# \\  )) ]\n                  ;(println \"next\" x y ov vs fs \"nv=>\" ov \"x\" nv \"x\")\n                  nv))\n                  \n        (next-board [board]\n            (vec (for [y (range (count board))]\n                (clojure.string/join \n                        (for [x (range (count (board y)))]\n                            (next-cell board x y))))))\n                            \n        ]\n        \n        (let [board (vec (map vec rows))]\n            (next-board board))\n        ))","user":"5eff6c0ee4b0cf489e8d7f11"},{"problem":94,"code":"(fn [board]\n    (letfn [(neighbors [x y]\n                (->> (for [i [-1 0 1]\n                           j [-1 0 1]]\n                        [(+ x i) (+ y j)])\n                     (filter (fn [[i j]]\n                                 (and (not= [i j] [x y])\n                                      (>= i 0)\n                                      (>= j 0)\n                                      (< i (count board))\n                                      (< j (count (first board))))))\n                     (into #{})))\n            \n            (live-neighbors [x y] (->> (neighbors x y)\n                                       (map (fn [[x y]] (nth (nth board x) y)))\n                                       (filter #(= \\# %))\n                                       (count)))\n            \n            (next-gen []\n                (into []\n                      (map-indexed\n                          (fn [x row]\n                              (clojure.string/join\n                                  \"\"\n                                  (map-indexed\n                                      (fn [y cell]\n                                          (let [n (live-neighbors x y)]\n                                              (cond (and (= cell \\#) (> 2 n)) \\space\n                                                    (and (= cell \\#) (< 3 n)) \\space\n                                                    (and (= cell \\space) (= 3 n)) \\#\n                                                    :else cell)))\n                                      row)))\n                          board)))]\n        (next-gen)))","user":"600ae927e4b074f607df6689"},{"problem":94,"code":"(fn [life-set]\n  (let [;allows for any \"rectangular\" input value\n        height (count life-set)\n        width (count (get life-set 0))\n        ;takes a position in a matrix and adds one to it\n        ;number number matrix -> matrix\n        Add-at (fn [x1 y1 my-matrix] (if\n                                 (and (< x1 width) (<= 0 x1) (< y1 height) (<= 0 y1))\n                                 (assoc my-matrix y1 (assoc (get my-matrix y1) x1 (+ (get (get my-matrix y1) x1) 1)))\n                                 my-matrix))\n        ;takes a position in a matrix and adds 10 to it, this is to differientiate new cells from surviving cells\n        ;number number matrix -> matrix\n        Add-10-at (fn [x1 y1 my-matrix] (if\n                                 (and (< x1 width) (<= 0 x1) (< y1 height) (<= 0 y1))\n                                 (assoc my-matrix y1 (assoc (get my-matrix y1) x1 (+ (get (get my-matrix y1) x1) 10)))\n                                 my-matrix))\n        ;returns a boolean true if there is a hash at a position x y of the input life set\n        ;number number -> boolean\n        life-at? (fn [x2 y2] (= (nth (seq (get life-set y2)) x2) \\#))]\n    (mapv \n     ;changes matrix to proper output form\n     ;vector -> string consisting of only \"#\" and \" \"\n     (fn [final-vectors] \n           (apply str\n            (mapv \n             ;cells are only born on 3 but stay alive on 12 and 13, \n             ;uses exploit where if there is life in a position, 10 is added to its matrix entry\n             ;number -> string\n             (fn [num] (if (or (= num 3) (= num 12) (= num 13)) \"#\" \" \"));turns number of adjacent cells to \"#\" and \" \" \n             final-vectors) ;<--inner map input\n                 )) ;outer map input comes next which is a list of numbers.. \n         (loop [x 0 \n                y 0 \n                life-numbers (vec (repeat height (vec (repeat width 0))))]\n              (cond\n               (>= x width) (recur 0 (+ y 1) life-numbers) ;goes to next row if there is no position x in a row\n               (>= y height) life-numbers  ;should is the base case\n               (life-at? x y) (recur (+ x 1) y ;goes to next position x\n                                     (->>\n                                      life-numbers\n                                      (Add-10-at x y) ;this is the afformentioned exploit\n                                      (Add-at (+ x 1) (+ y 1)) ;the rest of these just add one to \n                                      (Add-at (+ x 1) y)       ;all adjacent positions in the matrix\n                                      (Add-at (+ x 1) (- y 1))\n                                      (Add-at x (+ y 1))\n                                      (Add-at x (- y 1))\n                                      (Add-at (- x 1) (+ y 1))\n                                      (Add-at (- x 1) y)\n                                      (Add-at (- x 1) (- y 1))))\n               \"else\" (recur (+ x 1) y life-numbers))))))","user":"54d2c4c5e4b0e8a36923e5fa"},{"code":"(fn [rows]\n  (letfn [(live-nbors [y x] (for [dy [-1 0 1]\n                                 dx [-1 0 1]\n                                 :let [n (get-in rows [(+ y dy) (+ x dx)])]\n                                 :when (and (not= 0 dy dx)\n                                            (= \\# n))]\n                             n))]\n    (map-indexed\n     (fn [y row] (clojure.string/join\n                  (map-indexed\n                   (fn [x c] (let [nbors (live-nbors y x)]\n                               (if (= c \\#)\n                                 (cond (< (count nbors) 2) \\space\n                                       (<= (count nbors) 3) \\#\n                                       :else \\space)\n                                 (if (= (count nbors) 3)\n                                   \\#\n                                   \\space))))\n                   row)))\n     rows)))","problem":94,"user":"510acd6ee4b078ea719210f4"},{"code":"(fn [R E C b]\n  (let [g #(nth (nth b % []) %2 \\ )\n        h #(R (fn [n [x y]] (+ n ({\\  0 \\# 1} (g (+ % x) (+ %2 y)))))\n              0\n              [[-1 -1] [-1 0] [-1 1] \n               [ 0 -1]        [ 0 1] \n               [ 1 -1] [ 1 0] [ 1 1]])]\n    (R (fn [u i] \n         (conj u (R (fn [v j] \n                      (str v ({2 (g i j) 3 \\#} (h i j) \" \")))\n                    \"\" \n                    (E (C (peek b))))))\n         [] \n         (E (C b)))))\nreduce range count","problem":94,"user":"4ef49c2c535dced4c769f238"},{"problem":94,"code":"(fn [game]\n          (let [adjacent (fn [[x y]]\n                           (filter #(not (some #{-1} %))\n                                   [[(dec x) (dec y)]\n                                    [(dec x) y]\n                                    [(dec x) (inc y)]\n                                    [x (dec y)]\n                                    [x (inc y)]\n                                    [(inc x) (dec y)]\n                                    [(inc x) y]\n                                    [(inc x) (inc y)]]))\n                step-cell (fn [cell game]\n                            (let [live? (fn [value] (= \\# value))\n                                  value (get-in game cell)\n                                  neighbours (adjacent cell)\n                                  live-neighbours (count (filter live? (map #(get-in game %) neighbours)))\n                                  live-map (zipmap (range 0 9) \"  ##     \")\n                                  dead-map (zipmap (range 0 9) \"   #     \")]\n                              (if (live? value)\n                                (live-map live-neighbours)\n                                (dead-map live-neighbours))))\n                step (fn [game]\n                       (let [size (count game)]\n                         (map #(apply str %)\n                              (partition size (for [x (range 0 size)\n                                                    y (range 0 size)\n                                                    :let [cell [x y]]]\n                                                (step-cell cell game))))))]\n            (step game)))","user":"5164867fe4b003cf19fdde3e"},{"code":"(fn [v]\r\n  (letfn ((r [v n a]\r\n               (vec `(~@(take n v) ~a ~@(drop (+ n 1) v))))\r\n          (g [b x y]\r\n             (if (and (some #(= % y) (range (count b)))\r\n                      (some #(= % x) (range (count (first b)))))\r\n               (nth (nth b y) x)\r\n               \\space))\r\n          (s [b x y v]\r\n               (r b y (r (nth b y) x v)))\r\n          (c [b x y]\r\n             (reduce (fn [s a]\r\n                       (cond (and (= (a 0) 0) (= (a 1) 0))\r\n                             s\r\n                             (= (g b (+ x (a 1)) (+ y (a 0))) \\#)\r\n                             (+ s 1)\r\n                             :else\r\n                             s))\r\n                     0\r\n                     (for [dy '(-1 0 1)\r\n                           dx '(-1 0 1)]\r\n                       [dy dx]))))\r\n         (let [b (vec (map (fn [s]\r\n                             (vec s))\r\n                           v))]\r\n           (vec (map #(apply str %)\r\n                     (reduce (fn [r a]\r\n                               (let [y (a 1)\r\n                                     x (a 0)\r\n                                     c (c b x y)]\r\n                                 (cond (and (= (g b x y) \\space)\r\n                                            (= c 3))\r\n                                       (s r x y \\#)\r\n                                       (= (g b x y) \\space)\r\n                                       r\r\n                                       (< c 2)\r\n                                       (s r x y \\space)\r\n                                       (> c 3)\r\n                                       (s r x y \\space)\r\n                                       :else\r\n                                       r)))\r\n                             b\r\n                             (for [y (range (count b))\r\n                                   x (range (count (first b)))]\r\n                               [y x])))))))","problem":94,"user":"4de2f44f535d08e6dec9fdec"},{"code":"(fn [b]\n  (let [h (count b)]\n    (map-indexed\n     (fn [ri r]\n       (let [w (count r)]\n         (reduce\n          str\n          (map-indexed\n           (fn [ci c]\n             (letfn [(surr [x l]  [(dec x) x (inc x)])]\n               (let [nc (count\n                         (filter #{\\#}\n                                 (for [ci* (surr ci w) ri* (surr ri h)\n                                       :when (not= [ci ri] [ci* ri*])]\n                                   (nth (nth b ri* ()) ci* nil))))]\n                 (if ((if (= c \\#) #{2 3} #{3}) nc) \\# \\space))))\n           r))))\n     b)))","problem":94,"user":"4f06dcad535dcb61093f6c16"},{"problem":94,"code":"(fn [world]\n  (vec (map-indexed (fn [row-index row]\n                      (apply str (map-indexed (fn [ele-index ele]\n                                                (let [row-vec (vec world)\n                                                      above (get (get row-vec\n                                                                      (dec row-index)) ele-index)\n                                                      d-t-l (get (get row-vec\n                                                                      (dec row-index)) (dec ele-index))\n                                                      d-t-r (get (get row-vec\n                                                                      (dec row-index)) (inc ele-index))\n                                                      below (get (get row-vec\n                                                                      (inc row-index)) ele-index)\n                                                      d-b-l (get (get row-vec\n                                                                      (inc row-index)) (dec ele-index))\n                                                      d-b-r (get (get row-vec\n                                                                      (inc row-index)) (inc ele-index))\n                                                      left  (get (get row-vec row-index)\n                                                                 (dec ele-index))\n                                                      right (get (get row-vec row-index)\n                                                                 (inc ele-index))]\n                                                  (let [live-neighbors (get\n                                                                        (frequencies\n                                                                         [below above\n                                                                          left right\n                                                                          d-t-l d-t-r\n                                                                          d-b-l d-b-r]) \\#)]\n                                                    (if (= ele \\space)\n                                                      (if (= live-neighbors 3) \"#\" \" \")\n                                                      (if (or (= live-neighbors 3)\n                                                              (= live-neighbors 2)) \"#\" \" \"))))\n                                                ) row))) world)))","user":"52fc34cee4b047fd55837015"},{"code":"(fn [b]\n   (let [q (range (count (first b)))\n         t (vec (map vec b))\n         r (fn [k] (range (dec k) (+ k 2)))]\n     (map #(apply str %)\n       (reduce\n         (fn [u [i j]]\n           (update-in u [i j]\n             #(let [c (reduce (fn [z k] (+ z (if (= (get-in t k) \\#) 1 0))) 0 (for [x (r i) y (r j)] [x y]))]\n                (if (if (= % \\#) (and (> c 2) (< c 5)) (= c 3)) \\# \\space))))\n         t (for [i q j q] [i j])))))","problem":94,"user":"51f66e0ee4b06ff1c25c52c3"},{"code":"(fn gol [board]\n  (let [b (vec (map #(vec (sequence %)) board))\n        getCountLiveNeighbours (fn [x y field]\n                                 (count \n                                   (filter #(= % :live)                                                                           \n                                           (for [x1 [-1 0 1] y1 [-1 0 1]                                                                                           \n                                                 :when (not (= 0 x1 y1))                                      \n                                                 ]                                  \n                                             (if (= \\# (get (get field (+ y y1)) (+ x x1)))                                     \n                                               :live                                     \n                                               :dead                                     \n                                               ))))\n                                 )\n        getNextValue (fn [x y field]\n                      (let [c (getCountLiveNeighbours x y field)\n                            v (get (get field y) x)]\n                        (if (= v \\#)\n                          (cond (< c 2) \\space\n                                (> c 3) \\space\n                                :else \\#)\n                          (cond (= c 3) \\#\n                                :else \\space) \n                        )             \n                      )\n                      )\n        ]                                             \n    (map-indexed \n      (fn [y row] (apply str (map str \n                                  (map-indexed                     \n                                    (fn [x v] (getNextValue x y b))                     \n                                    row)\n                                  )\n                         )\n          ) \n      b)\n    ))","problem":94,"user":"4fcf5292e4b03432b189f40e"},{"problem":94,"code":"(fn [board]\n  (let [cell-at #(nth (nth board %1) %2)\n        live? (fn [[i j]]\n                (= (cell-at i j) \\#))\n        valid-idx? #(and\n                     (< % (count board))\n                     (>= % 0))\n        neighbor-idx\n        #(for [i (range (dec %1) (+ 2 %1))\n               j (range (dec %2) (+ 2 %2))\n               :when (and (valid-idx? i)\n                          (valid-idx? j)\n                          (not (and (= i %1) (= j %2))))]\n           [i j])\n        live-neighbors\n        #(count (filter live? (neighbor-idx %1 %2)))\n        next-gen\n        (fn [i j]\n          (let [alive (live? [i j])\n                living (live-neighbors i j)]\n            (if alive\n              (cond\n                (< living 2) \\space\n                (> living 3) \\space\n                :else \\#)\n              (if (= living 3)\n                \\#\n                \\space))))]\n    (map-indexed\n     (fn [i row] (apply str (map-indexed\n                              (fn [j _] (println i j) (next-gen i j))\n                              row)))\n     board)))","user":"519136e9e4b0f8ef0be96c01"},{"code":"(fn update-board [b]\n  (letfn [(cell [x, y, b]\n                (nth (nth b y) x))\n          (alive [x, y, b]\n                 (and\n                  (> y 0)\n                  (> x 0)\n                  (< y (count b))\n                  (< x (.length (nth b y)))\n                  (= \\# (cell x y b))))\n          (nbrs [x, y, b]\n                (count (filter true?\n                               [(alive (dec x) (dec y) b)\n                                (alive x (dec y) b)\n                                (alive (inc x) (dec y) b)\n                                (alive (dec x) y b)\n                                (alive (inc x) y b)\n                                (alive (dec x) (inc y) b)\n                                (alive x (inc y) b)\n                                (alive (inc x) (inc y) b)])))\n          (update-row [width, b, y]\n                      (apply str\n                             (map (fn [x]\n                                    (let [c (nbrs x y b)]\n                                      (if (or\n                                           (= c 3)\n                                           (and (= c 2) (= \\# (cell x y b))))\n                                        \\#\n                                        \\ )))\n                                  (range width))))]\n    (let [height (count b)\n          width  (.length (nth b 0))]\n      (map (partial update-row width b) (range height)))))","problem":94,"user":"51365524e4b04ac1f358dd52"},{"code":"(fn [board]\n  (let [n (count board)\n        m (count (first board))]\n    (letfn [(locs [b]\n                  (apply (comp set concat)\n                         (map-indexed (fn [r row]\n                                        (filter second\n                                                (map-indexed\n                                                 #(vector r (and (= \\# %2) %1))\n                                                 row)))\n                                      b)))\n            (nghs [[r c]]\n                  (for [dr [-1 0 1] dc [-1 0 1]\n                        :let [r2 (+ r dr) c2 (+ c dc)]\n                        :when (and (not (= 0 dr dc))\n                                   (< r2 n) (>= r2 0)\n                                   (< c2 m) (>= c2 0))]\n                    [r2 c2]))\n            (step [cells]\n                  (set\n                   (keep\n                    identity\n                    (map (fn [[cell cnt]]\n                           (if (cells cell)\n                             (and (#{2 3} cnt) cell)\n                             (when (= 3 cnt) cell)))\n                         (frequencies (mapcat nghs cells))))))\n            (disp [cells]\n                  (let [brd (vec (for [i (range n)]\n                                 (vec (for [j (range m)] \\space))))]\n                    (mapv #(apply str %)\n                          (reduce (fn [b cell] (assoc-in b cell \\#))\n                                  brd cells))))]\n      (-> board locs step disp))))","problem":94,"user":"5095f761e4b0ba05ca7aebfd"},{"problem":94,"code":"(fn [chessboard]\n\t(let [nrow (count chessboard)\n\t\t  ncol (count (nth chessboard 0))\n\t\t  ; 根据下标获取元素\n\t\t  get-coord (fn [x y] (nth (nth chessboard x) y))\n\t\t  ; 相邻生命的坐标\n\t\t  coords (fn [x y] (filter \n\t\t  \t\t\t\t\t  #(let [row-num (first %)\n\t\t  \t\t\t\t\t  \t     col-num (last %)] \n\t\t  \t\t\t\t\t  \t; 过滤越界的坐标\n\t\t  \t\t\t\t\t  \t(and (>= row-num 0) \n\t\t  \t\t\t\t\t  \t   \t (>= col-num 0)\n\t\t  \t\t\t\t\t  \t   \t (< row-num nrow) \n\t\t  \t\t\t\t\t  \t   \t (< col-num ncol)))\n\t\t  \t\t\t\t\t  ; 当前坐标周围的八个坐标（笛卡尔积）\n\t\t  \t\t\t\t\t  (for [xx [(dec x) x (inc x)]\n\t\t  \t\t\t\t\t  \t\tyy [(dec y) y (inc y)] \n\t\t  \t\t\t\t\t  \t\t\t:when (not (and (= xx x) (= yy y)))]\n\t\t  \t\t\t\t\t  \t\t[xx yy])))\n\t\t  ; 相邻的生命\n\t\t  neighbors (fn [x y] (map (partial apply get-coord) (coords x y)))\n\t\t  ; 相邻生命状态是live（#）的个数\n\t\t  nlive (fn [x y] (count (filter #(= \\# %) (neighbors x y))))\n\t\t  ; 下一轮的状态（一维数组）\n\t\t  result (for [x (range 0 nrow)\n\t\t\t\t\t   y (range 0 ncol)] \n\t\t\t\t\t(let [element (get-coord x y)\n\t\t\t\t\t  \t  live-num (nlive x y)]\n\t\t\t\t\t  \t(if (= \\# element)\n\t\t\t\t\t  \t\t; live状态的生命周围如果有2个或3个生命是live的，则下轮继续存活，否则死亡\n\t\t\t\t\t  \t\t(if (or (< live-num 2) (> live-num 3)) \\space \\#)\n\t\t\t\t\t  \t\t; die状态的生命周围如果有刚好3个生命是live的，则下轮复活，否则死亡\n\t\t\t\t\t  \t\t(if (= live-num 3) \\# \\space))))]\n\t\t  ; 把结果转成4Clojure需要的形式\n\t\t  (map (partial apply str) (partition ncol result))))","user":"539043e7e4b0b51d73faae97"},{"problem":94,"code":"(fn next-board [board]\n  (let [board-size (count (first board))\n         live-cells (fn live-cells [board]\n                      (set (apply concat \n                                  (map-indexed\n                                    (fn append-dimension [dim values]\n                                      (map #(vector dim %) values))\n                                    (map \n                                      #(map first \n                                            (filter \n                                              (fn [el] (= \\# (second el))) \n                                              (map-indexed vector %))) \n                                      board)))))\n        alive-cells (live-cells board)\n        neighbours (fn [cell]\n                    (let [all-neighbours (for [x (range -1 2) y (range -1 2)] [x y])]\n                      (set (remove #(= cell %) (map #(map + cell %) all-neighbours)))))\n        next-state-coords (map first (filter #(or (= 3 (second %)) (and (= 2 (second %)) (contains? alive-cells (first %)))) (frequencies (apply concat (map neighbours alive-cells)))))\n        coords2indices (fn [coords] (vec (map #(+ (* board-size (first %)) (second %)) coords)))\n        empty-board (vec (repeat (* board-size board-size) \\space))\n        new-board (fn [live-indices] \n                    (apply assoc empty-board \n                           (interleave live-indices (repeat (count live-indices) \\#))))\n \n         ]\n    (vec (map #(apply str %)\n    (partition board-size\n      (new-board (coords2indices next-state-coords)))\n    ))\n  ))","user":"5143824ae4b0b4fb4ace5f36"},{"code":"{[\"      \" \n        \" ##   \"\n        \" ##   \"\n        \"   ## \"\n        \"   ## \"\n        \"      \"] [\"      \" \n    \" ##   \"\n    \" #    \"\n    \"    # \"\n    \"   ## \"\n    \"      \"][\"     \"\n        \"     \"\n        \" ### \"\n        \"     \"\n        \"     \"][\"     \"\n    \"  #  \"\n    \"  #  \"\n    \"  #  \"\n    \"     \"]\n    [\"      \"\n        \"      \"\n        \"  ### \"\n        \" ###  \"\n        \"      \"\n        \"      \"]\n        [\"      \"\n    \"   #  \"\n    \" #  # \"\n    \" #  # \"\n    \"  #   \"\n    \"      \"]}","problem":94,"user":"4dfe65a1535d04ed9115e787"},{"problem":94,"code":"(fn gl [board]\n  \"[x, y] - [x element of row y - row y of this board]\"\n  (let [dx (count (first board))\n        dy (count board)\n        neighbours (fn [pos]\n                     (let [ps [[-1 -1] [0 -1] [1 -1]\n                               [-1  0]        [1  0]\n                               [-1  1] [0  1] [1  1]]\n                           neighbour-positions (map #(map + pos %)\n                                                    ps)]\n                       (map (fn [[x y]]\n                              (get-in board [y x]))\n                            neighbour-positions)))]\n    (map\n       #(apply str %)\n       (partition\n          dx\n          (for [row (range dy) elt (range dx)]\n            (let [cell [elt row]\n                  live-neighbours (count (filter #{\\#} (neighbours cell)))\n                  cell-live? (= \\# (get-in board [row elt]))]\n              (cond\n                (and cell-live? (< live-neighbours 2)) \\space\n                (and cell-live? (or (= live-neighbours 2) (= live-neighbours 3))) \\#\n                (and cell-live? (> live-neighbours 3)) \\space\n                (and (not cell-live?) (= live-neighbours 3)) \\#\n                :else \\space)))))))","user":"58a2b57fe4b02bd94d917ede"},{"problem":94,"code":"(fn [s]\n  (let [h (count s)\n        w (count (first s))\n        dead \\space\n        alive \\#\n        nnth (fn nnth [s i j]\n               (cond (or (< i 0) (>= i (count s))\n                         (< j 0) (>= j (count (first s))))\n                     \\space\n                     :else\n                     (nth (nth s i) j)))\n        near (fn near [s i j]\n               [(nnth s (inc i) j)\n                (nnth s (dec i) j)\n                (nnth s (inc i) (inc j))\n                (nnth s (dec i) (inc j))\n                (nnth s i (inc j))\n                (nnth s (inc i) (dec j))\n                (nnth s (dec i) (dec j))\n                (nnth s i (dec j))])]\n    (vec (for [i (range h)]\n           (apply str (for [j (range w)]\n                        (if (= (nnth s i j) dead)\n                          (if (= (reduce + (map (fn [x] (if (= x dead) 0 1)) (near s i j))) 3)\n                            alive\n                            dead)\n                          (if (or (= (reduce + (map (fn [x] (if (= x dead) 0 1)) (near s i j))) 2)\n                                  (= (reduce + (map (fn [x] (if (= x dead) 0 1)) (near s i j))) 3))\n                            alive\n                            dead))))))))","user":"53664e3be4b0243289761e74"},{"code":"(fn [c]\n  (let [l (count c)\n        m (* -1 l)\n        s (apply str c)]\n    (map #(apply str %)\n         (partition\n           l\n           (map (fn [n]\n                  (condp = (count (filter #(= \\# (nth s (+ n %) \"\")) [1 -1 (- l 1) l (+ l 1) (+ m 1) m (- m 1)]))\n                    3 \"#\"\n                    2 (nth s n)\n                    \" \")) (range (count s)))))))","problem":94,"user":"4dad8fe9c9a9d6ed1899dc57"},{"code":"(fn gol [coll]\t\t\n  (let [\n        rec-map-indexed (fn rec-map-indexed [coll]\n                          (map-indexed (fn [idx v]\n                                   (cond\n                                    (string? v) (map (fn [x] {[idx (ffirst x)] (last (first x))})\n                                                    (rec-map-indexed (map char v)))\n                                    :else {idx v})\n                                   ) coll ))\n        nbrs (fn  [[x y]]\n               (for [i [-1 0 1] j [-1 0 1]\n                     :when (or ((complement =) i 0)\n                             ((complement =) j 0))]\n                 [(+ i x) (+ j y)]))\n        create-world (fn [w h coll]\n                       (let [wrld (for [i (range 0 h)\n                                        j (range 0 w)\n                                        ]\n                                    (if (coll [i j]) \\# \\space))]\n                         ((comp (partial map #(reduce str %)) (partial partition w)) wrld)))\n        w (count (first coll))\n        h (count coll)\n        im (into {} (flatten (rec-map-indexed coll)))\n        lc ((comp set (partial map first) #(% \\#)(partial group-by val)) im)\n        ns (set (for [[l n] (frequencies (mapcat nbrs lc))\n                   :when (or (= n 3) (and (= n 2) (lc l)))]\n                  l))\n        nw (create-world w h ns)\n        ]\n    nw\n    ))","problem":94,"user":"52140b53e4b0961f15ac4d7e"},{"problem":94,"code":"(fn next-game-state [board]\n  (let [alive \\#\n        dead \" \"\n        get-neighbors (fn get-neighbors [r c board]\n                        (map #(get-in board %) (filter (fn [coords] (and (not= coords [r c]) (not (nil? (get-in board coords)))))\n                                                       (for [x (range (dec r) (+ r 2))\n                                                             y (range (dec c) (+ c 2))] [x, y]))))]\n    (map-indexed (fn [i e]\n                 (apply str (map-indexed (fn [j c]\n                                (let [neighbors (get-neighbors i j board)\n                                      live-neighbors (count (filter #(= % alive) neighbors))\n                                      alive? (= c \\#)\n                                      dead? (not alive?)]\n                                  (cond (and alive? \n                                             (< live-neighbors 2))        dead\n                                        (and alive? \n                                             (or (= 2 live-neighbors) \n                                                 (= 3 live-neighbors)))   alive\n                                        (and alive? \n                                             (> live-neighbors 3))        dead\n                                        (and dead? \n                                             (= 3 live-neighbors))        alive\n                                        :else                             dead))) e))) board)))","user":"5ea6fe98e4b00a66d4a951b2"},{"problem":94,"code":"(fn next-iter [f]\n  (let [\n        cell-value (fn [f coord]\n                     (let [[x y] coord]\n                       (get (get f x) y)))\n        neighbours (fn [f n m]\n                     (->>\n                      (for [a [-1 0 1] b [-1 0 1]]\n                        [a b])\n                      (remove #(= [0 0] %))\n                      (map #(map + [n m] %))\n                      (map #(cell-value f %))\n                      (filter #(= \\# %))\n                      count\n                      ))\n        X (count f)\n        Y (->> f first count)\n        ]\n    (->> \n     (for [x (range X) y (range Y)]\n       (case [(cell-value f [x y]) (neighbours f x y)]\n         [\\space 3] \\#\n         [\\# 2] \\#\n         [\\# 3] \\#\n         \\space ))\n     (partition Y)\n     (map #(apply str %))\n     vec)))","user":"4ddb696b535d02782fcbe9fa"},{"problem":94,"code":"(fn [curr-field]\n    (let\n      [\n       is-alive (fn [life-state neighbours]\n                  (if\n                    (= neighbours 3)\n                    true\n                    (and\n                      life-state\n                      (= neighbours 2))))\n       mask (fn [boolyph]\n              (if\n                boolyph\n                \\#\n                \\ ))\n       list-possible-neighbours (fn [coord-x coord-y x-count y-count]\n                                  (set (for [\n                                             x (range\n                                                 (- coord-x 1)\n                                                 (+ coord-x 2))\n                                             y (range\n                                                 (- coord-y 1)\n                                                 (+ coord-y 2))\n                                             :when (and\n                                                     (>= x 0)\n                                                     (< x x-count)\n                                                     (< y y-count)\n                                                     (>= y 0)\n                                                     (not\n                                                       (and\n                                                         (= x coord-x)\n                                                         (= y coord-y))))\n                                             ]\n                                         [x y])))\n       list-neighbours (fn [field x y]\n                         (->> (list-possible-neighbours\n                                x\n                                y\n                                (count\n                                  (first field))\n                                (count field))\n                              (filter (fn [[x y] & coord]\n                                        (= \\#\n                                           (nth\n                                             (nth\n                                               field\n                                               y)\n                                             x))))\n                              set))\n       exec (fn\n              [curr-field]\n                (map-indexed\n                  (fn [y cy]\n                    (clojure.string/join (map-indexed\n                                           (fn [x rx]\n                                             (mask (is-alive\n                                                     (= rx \\#)\n                                                     (count (list-neighbours\n                                                              curr-field\n                                                              x\n                                                              y)))))\n                                           cy)))\n                  curr-field))\n       ]\n      (exec curr-field)))","user":"586a657de4b0f14aab7c88bd"},{"problem":94,"code":"(fn [b]\n    (let [dim (count b)]\n      (letfn [(livingneighborsof-sb\n                [board pt]\n                (let [delts (remove #{[0 0]}\n                                    (for [dx [-1 0 1] dy [-1 0 1]] [dx dy]))\n                      +p (fn [[x1 y1] [x2 y2]] [(+ x1 x2) (+ y1 y2)])\n                      neighbors (map (partial +p pt) delts)]\n                  (count (filter #{\\#} (map (partial get-in board) neighbors)))))\n              (fate-sb\n                [board pt]\n                (let [cv (get-in board pt)\n                      ln (livingneighborsof-sb board pt)]\n                  (if (= cv \\space)   \n                    (if (= ln 3) \\# \\space)\n                    (cond\n                      (>= ln 4) \\space\n                      (<= 0 ln 1) \\space\n                      :else cv))))]\n       (let [nextbrd (for [xi (range dim) yi (range dim)]\n                       (fate-sb b [xi yi]))]\n         (map #(apply str %) (partition dim nextbrd))))))","user":"4e8768f6535dceadca469850"},{"problem":94,"code":"(fn life\n  [v]\n  (let [board (map-indexed #(vector %1 (map-indexed vector (seq %2))) v)\n        rows-count (count v)\n        lines-count (count (first v))\n        neighbours-func (fn [iv] (filter (fn [[fa sa]] (and (>= fa 0) (>= sa 0) (< fa rows-count) (< sa lines-count))) (map (fn [nv] (map + iv nv)) '([0 -1] [0 1] [-1 0] [1 0] [-1 -1] [1 1] [-1 1] [1 -1]))))\n        cell-types {:live \\# :dead \\space}\n        live? (fn [cell] (= cell (:live cell-types)))\n        dead? (fn [cell] (= cell (:dead cell-types)))\n        get-indexes (fn [initial-vector] (map (fn [[i v]] (map #(vector i (first %)) v)) initial-vector))\n        map-to-neighbour-indexes (fn [s] (map #(map neighbours-func %) (get-indexes s)))\n        map-to-neighbours (fn [s] (map (fn [x] (map (fn [y] (map (fn [[a1 a2]] (second (nth (second (nth board a1)) a2))) y)) x)) (map-to-neighbour-indexes s)));test\n        mapped-to-neighbours (map-to-neighbours board)]\n(map (fn [[i v]] (apply str (map (fn [[ii value]] (let [arg (filter #{\\#} (nth (nth mapped-to-neighbours i) ii))]\n                                         (if (live? value)\n                                           (if (< (count arg) 2)\n                                             (:dead cell-types)\n                                             (if (or (= (count arg) 2) (= (count arg) 3))\n                                               (:live cell-types)\n                                               (:dead cell-types)\n                                               )\n                                             )\n                                           (if (= (count arg) 3)\n                                             (:live cell-types)\n                                             (:dead cell-types)\n                                             )))) v))\n\n       ) board)\n    ))","user":"56ab7578e4b03c432f18733d"},{"code":"(fn f [b]\n  (let [bb (map seq b)\n        dimx (count b)\n        dimy (count (first b))\n        surrounding (fn [x y]\n                      (for [x' [(dec x) x (inc x)]\n                            y' [(dec y) y (inc y)]\n                            :when (and (>= x' 0) (>= y' 0)\n                                       (< x' dimx) (< y' dimy)\n                                       (not (and (= x x') (= y y'))))]\n                          (nth (nth bb x') y')))\n        count-neighbors (fn [x y]\n                          (count (filter #(= % \\#) (surrounding x y))))\n        nextgen (fn [x y c]\n                  (let [n (count-neighbors x y)]\n                    (cond (and (= c \\#) (= n 2)) \\#\n                          (= n 3) \\#\n                          :else \\space)))]\n    (map-indexed (fn [x row]\n                   (apply str (map-indexed (partial nextgen x) row)))\n                 bb)))","problem":94,"user":"52d3f666e4b09f7907dd1327"},{"problem":94,"code":"(fn gol [board]\n  (letfn [(get-live-in-row [row]\n            (reduce (fn [acc [k v]]\n                      (if (= v \\#)\n                        (conj acc k)\n                        acc))\n                    []\n                    (zipmap (range (count row)) row)))\n\n          (get-live-indices [board]\n            (reduce\n             (fn [acc [r cols]]\n               (if (empty? cols)\n                 acc\n                 (into acc (map (fn [c] [r c]) cols))))\n             #{}\n             (zipmap\n              (range (count board))\n              (map get-live-in-row board))))\n\n          (get-surrounding [row col]\n            (for [rows (range (dec row) (+ row 2))\n                  cols (range (dec col) (+ col 2))\n                  :let [pair [rows cols]]\n                  :when (not= pair [row col])]\n              pair))\n\n          (live-neighbors [live-set [row col]]\n            (reduce #(if (contains? live-set %2) (inc %) %)\n                    0\n                    (get-surrounding row col)))\n\n          (cell-coords [board]\n            (partition (count (first board))\n                       (for [rows (range (count board))\n                             cols (range (count (first board)))]\n                               [rows cols])))\n          (live-or-not [live neighbors]\n            (if live\n              (cond\n                (< neighbors 2) \" \"\n                (or (= neighbors 2) (= neighbors 3)) \"#\"\n                (> neighbors 3) \" \"\n                :else \"?\")\n              (if (= neighbors 3) \"#\" \" \")))]\n    (let [live-set (get-live-indices board)\n          next-state (map (fn [coord-row]\n                            (map\n                              #(live-or-not\n                                (contains? live-set %)\n                                (live-neighbors live-set %))\n                              coord-row))\n                          (cell-coords board))]\n      (vec (map #(apply str %) next-state)))))","user":"540e8d13e4b0addc1aec671e"},{"problem":94,"code":"(fn __ [gamefield]\n  (let[field (map (partial map identity) gamefield)\n       fieldsize (count field)\n       rotate-left  (fn[x](conj (vec(rest x))  (first x)))\n       rotate-right (fn[x](cons (last x) (vec(drop-last x))))\n       left-neighbors      (map rotate-left     field)\n       right-neighbors     (map rotate-right    field)\n       bottom-neighbors    (rotate-left         field)\n       top-neighbors       (rotate-right        field)\n       top-right-neighbors (rotate-right      left-neighbors)\n       top-left-neighbors  (rotate-right       right-neighbors)\n       bottom-right-neighbors (rotate-left    left-neighbors)\n       bottom-left-neighbors  (rotate-left     right-neighbors)\n       neighbors (map #(hash-map :# (count (filter #{\\#} %)) :space (count (filter #{\\space} %)))\n                   (apply (partial map (partial conj []))\n                   (map flatten [left-neighbors right-neighbors \n                     bottom-neighbors top-neighbors \n                     top-right-neighbors top-left-neighbors\n                     bottom-left-neighbors bottom-right-neighbors] )))\n       ]\n    (map #(apply str %)\n    (partition fieldsize\n    (map \n     #(if (= %1 \\#) \n        (if (#{2 3} (:# %2)) \\# \\space) \n        (if (= 5 (:space %2)) \\# \\space) ) (flatten field) \n     neighbors)))\n))","user":"52bbd09ee4b07a9af57922ee"},{"code":"(fn [c m]\r\n  (let [w (count m) s (c m)]\r\n    (map c\r\n   (partition w\r\n\t  (map-indexed\r\n\t   (fn [i x]\r\n\t     (({\\# {2 \\# 3 \\#}} x {3 \\#})\r\n\t      (apply + (map #({\\# 1 \\  0} (nth s(+ % i)\\  ))\r\n\t\t\t    [(- -1 w) (- w) (- 1 w)\r\n\t\t\t     -1 1 (- w 1) w (+ w 1)]))\r\n\t      \\  ))\r\n\t   s)))))\r\n#(apply str %)","problem":94,"user":"4dce6e41535d5973398f92a2"},{"code":"(fn [x]\n   (let [f #(zipmap (range (count %)) %)\n         m (into {} (map #(f %) (list (map #(f %) x))))\n         n (fn [i j] (for [a [-1 0 1] b [-1 0 1] :when (not (= a b 0))] (get-in m [(+ i a) (+ j b)])))\n         nc (for [i (range (count x))]\n              (for [j (range (count (first x)))]\n                (count (filter #(= \\# %) (n i j)))))]\n     (map (fn [cell neighbors]\n            (apply str (map #(if (= % \\#)\n                               (cond\n                                (< %2 2) \\space\n                                (some #{2 3} [%2]) \\#\n                                (> %2 3) \\space)\n                               (if (= %2 3) \\# \\space))\n                            cell neighbors)))\n          x nc)))","problem":94,"user":"4f34eb87e4b0e243712b1eba"},{"code":"(fn [s]\n  (let [BOARD-W (count (first s))\n        BOARD-H (count s)\n        c-x (fn [c] (nth c 0))\n        c-y (fn [c] (nth c 1))\n        m-c (fn [x y] [x y])\n        all-cells (for [y (range BOARD-H) x (range BOARD-W)] (m-c x y))\n        in-board? (fn [c]\n                    (let [x (c-x c)\n                          y (c-y c)]\n                      (and (> x -1) (< x BOARD-W)\n                           (> y -1) (< y BOARD-H))))\n        neighbors (fn [c]\n                    (let [cx (c-x c)\n                          cy (c-y c)]\n                      (for [x (range (- cx 1) (+ cx 2)) y (range (- cy 1) (+ cy 2))\n                            :let [n (m-c x y)] :when (and (in-board? n) (not (= n c)))] n)))\n        alive? (fn[c b] (b c))\n        parse-board (fn [s]\n                      (into #{}\n                        (map #(apply m-c (rest %))\n                          (mapcat (fn [s] (filter #(= (first %) \\#) s))\n                            (map (fn [[s y]]\n                                  (map #(conj % y) (map vector s (range BOARD-W ))))\n                              (map vector s (range BOARD-H)))))))\n        board-to-seq (fn [b]\n                      (let [rows (partition BOARD-W all-cells)]\n                        (map (fn [row] (apply str (map (fn [c] (if (alive? c b) \\# \\space)) row))) rows)))\n        \n        live-neighbors (fn [c b]\n                        (let [n (neighbors c)]\n                          (filter #(alive? % b) n)))\n        \n        next-gen (fn [b]\n                   (into #{}\n                      (filter (fn [c]\n                                (let [ln (live-neighbors c b)\n                                      lnc (count ln)]\n                                  (or (= lnc 3)\n                                      (and (= lnc 2) (alive? c b)))))\n                        all-cells)))]\n    (board-to-seq (next-gen (parse-board s)))))","problem":94,"user":"4ede8e1d535d10e5ff6f5339"},{"problem":94,"code":"(fn [grid]\n  (let [offsets (for [x [-1 0 1] y [-1 0 1] :when (not= 0 x y)] [x y])\n        neighbors (fn [coord]\n                    (map (partial map +) (repeat coord) offsets))\n        live? (fn [coord]\n                (= \\# (get-in grid coord)))\n        neighbor-count (fn [coord]\n                         (->> (neighbors coord)\n                              (filter live?)\n                              (count)))\n        next-state (fn [coord]\n                     (let [n-count (neighbor-count coord)]\n                       (if (live? coord)\n                         (cond\n                           (< n-count 2) \\space\n                           (> n-count 3) \\space\n                           :else \\#)\n                         (if (= 3 n-count) \\# \\space))))]\n    (for [r (range (count grid))]\n      (clojure.string/join\n        (for [c (range (count (first grid)))]\n          (next-state [r c]))))))","user":"530b8580e4b02e82168697cc"},{"problem":94,"code":"(fn conway [board]\n  (let [from-str (partial mapv (partial mapv {\\# 1 \\space 0}))\n        to-str (partial map (comp (partial apply str) (partial map [\\space \\#])))\n        neighbors (fn [b y x]\n                    (let [l (for [dy (range -1 2)\n                                  dx (range -1 2)\n                                  :when (not= [dy dx] [0 0])]\n                              (get-in b [(+ y dy) (+ x dx)] 0))]\n                      (reduce + l)))\n        state (from-str board)\n        next-gen (fn [y x cell]\n                   (let [n (neighbors state y x)]\n                     (if (zero? cell)\n                       (if (= n 3) 1 0)\n                       (if (#{2 3} n) 1 0))))]\n    (to-str (map-indexed (fn [y row]\n                           (map-indexed (partial next-gen y) row)) state))))","user":"5d929ceae4b0915913b1d412"},{"code":"(fn [board]\n  (letfn [(to-living [brd]\n            (into #{}\n              (for [x (range) :while (< x (count brd))\n                    y (range) :while (< y (count (brd x)))\n                    :when (= \\# (get (brd x) y))]\n                [x y])))\n          (to-board [n living]\n            (for [r (range n)]\n              (apply str\n                (for [c (range n)] (if (living [r c]) \\# \\space)))))\n          ;; neighbors and cells are copied verbatim from C. Legrand's solution\n          ;; http://clj-me.cgrand.net/2011/08/19/conways-game-of-life/\n          (neighbours [[x y]]\n            (for [dx [-1 0 1] dy (if (zero? dx) [-1 1] [-1 0 1])]\n                  [(+ dx x) (+ dy y)]))\n          (step [cells]\n            (set (for [[loc n] (frequencies (mapcat neighbours cells))\n                       :when (or (= n 3) (and (= n 2) (cells loc)))]\n                   loc)))]\n    (to-board (count board) (step (to-living board)))))","problem":94,"user":"504c8165e4b09724c857af31"},{"problem":94,"code":"(fn prob94 [board]\n(letfn\n    [(live? [board [row col]]\n       (= \\# (get-in board [row col])))\n     (neighbors [board row col]\n       (let [max-row (dec (count board))\n             max-col (dec (count (first board)))]\n         (filter #(not (= % [row col]))\n                 (for\n                     [r (range (dec row) (+ row 2))\n                      c (range (dec col) (+ col 2))\n                      :when (and (>= max-row r 0) (>= max-col c 0))]\n                   [r c]))))]\n  (mapv\n   #(apply str %)\n   (partition\n    (count board)\n    (for\n        [row (range (count board))\n         col (range (count (first board)))]\n      (let [ln (count (filter #(live? board %) (neighbors board row col)))]\n        (if (live? board [row col])\n          (cond\n            (< ln 2) \\space\n            (> ln 3) \\space\n            :else \\#)\n          (if (= ln 3) \\# \\space))))))))","user":"54e3df6ae4b024c67c0cf7e3"},{"code":"(fn next-gen [board]\n  (letfn [\n    (alive? [[cy cx]]\n\t  (if (= (get-in board [cy cx]) \\#)\n\t     true false))\n\t\t \n    (neighbors [cy cx]\n\t  (count\n  \t    (filter alive?\n\t      (remove (partial some #(< % 0))\n  \t        (for [y (range (dec cy) (+ 2 cy))\n                  x (range (dec cx) (+ 2 cx))\n\t\t\t     :when (not= [cy cx] [y x])]\n\t\t      [y x])))))\n\t\t\t\n\t(next-state [cy cx]\n\t  (let [nbr  (neighbors cy cx)\n\t        cell [cy cx]]\n\t    (if (alive? cell)\n\t\t  (cond\n\t\t\t  (< nbr 2) :die\n\t\t\t  (> nbr 3) :die\n\t\t\t  :else     :live)\n\t\t  ; dead cell\n\t\t  (if (= nbr 3) :live\n \t\t\t            :die  ))))\n\t\t\t\t\t\t\t\t   \n\t(update-cell [cy cx]\n\t  (case (next-state cy cx)\n\t    :live \\#\n        :die  \\space))]\n\t\t\n\t(let [bheight (count board)\n\t      bwidth  (count (first board))]\n\t\t  \n      (vec (for [y (range bheight)]\n\t    (clojure.string/join\n \t       (for [x (range bwidth )]\n\t\t(update-cell y x))))))))","problem":94,"user":"52f818a6e4b047fd55836fcc"},{"problem":94,"code":"(fn [board]\n    (let [neighbors (fn [i j]\n                      (for [a (range -1 2)\n                            b (range -1 2)\n                            :when (<= 0 (+ a i))\n                            :when (<= 0 (+ b j))\n                            :when (< (+ i a) (count board))\n                            :when (< (+ j b) (count (first board)))\n                            :when (and (not= [i j] [(+ i a) (+ j b)]))]\n                        [(+ i a) (+ j b)]))\n          count-neighbors (fn [n]\n                            (count (filter (fn [[i j]]\n                                             (= \\# (get-in board [i j])))\n                                           n)))]\n      (map-indexed (fn [i line]\n                     (apply str  (map-indexed (fn [j cell]\n                                                (let [n (count-neighbors (neighbors i j))\n                                                      alive (= cell \\#)]\n                                                  (if alive\n                                                    (cond\n                                                      (< n 2) \\space\n                                                      (#{2 3} n) \\#\n                                                      :else \\space)\n                                                    (if (= n 3) \\# \\space))))\n                                              line)))\n                   board)))","user":"597f8c93e4b0dbe32238d0c1"},{"problem":94,"code":"(fn [data]\n  (let [into-map (fn [data]\n                   (reduce \n                    (fn [m [k v]] (assoc m k v))\n                    {}\n                    (mapcat (fn [[i d]] \n                              (map-indexed (fn [idx itm] [[i idx] itm]) d))\n                            (map-indexed vector data))))\n        alive?  (fn [ch] (if (= ch \\#) true false))\n        nghbour (fn[key]\n                  (let [ [r c] key]\n                    (vector [(dec r) (dec  c)] [(dec r) c] [(dec r) (inc c)]\n                            [r (dec c)] [r (inc c)] [ (inc r) (dec c)] [(inc r) c] \n                            [(inc r) (inc c)])))\n        nx-st   (fn [mp cell]\n                  (let [[[r c] d] cell\n                    neighbours (nghbour [r c])\n                    vals (map mp neighbours )\n                    alive (map alive? vals)\n                    living (count (filter true?  alive))]\n                    (cond\n                      (< living 2) [[r c] \\space]\n                      (> living 3) [ [r c] \\space]\n                      (= living 3) [[r c]  \\#]\n                      :else cell )))\n        dataset (into-map data)\n        size (count (first data))]\n    (into [] (map (partial apply str )\n                  (partition size\n                             (map (fn [[f v]] v)\n                                  (sort (map (partial  nx-st dataset) dataset))))))))","user":"5832be57e4b089d5ab817c86"},{"problem":94,"code":"(fn game-of-life [m]\n  (let [cell (fn [x y] (if (or (>= y (count m)) (>= x (count (first m))) (< y 0) (< x 0)) nil (str (nth (nth m y) x))))\n        live? (fn [x y] (= (cell x y) \"#\"))\n        lc (fn [x y] (if (live? x y) 1 0))\n        nghb (fn [x y] (apply + (map (partial apply lc) [\n                                                 [(- x 1) y]\n                                                 [(+ x 1) y]\n                                                 [x (- y 1)]\n                                                 [x (+ y 1)]\n                                                 [(- x 1) (- y 1)]\n                                                 [(- x 1) (+ y 1)]\n                                                 [(+ x 1) (- y 1)]\n                                                 [(+ x 1) (+ y 1)]])))\n        nxt (fn [x y]\n              (let [live (live? x y)\n                    nc (nghb x y)]\n                (cond\n                  (and live (< nc 2)) \" \"\n                  (and live (< nc 4)) \"#\"\n                  (and live (>= nc 4)) \" \"\n                  (and (not live) (= nc 3)) \"#\"\n                  :else \" \")))\n        next-row (fn [y row] (apply str (map-indexed (fn [i e] (nxt i y)) row)))]\n    (map-indexed (fn [i e] (next-row i e)) m)))","user":"51e38568e4b0c611d6113e43"},{"problem":94,"code":"(fn n [b]\n  (let [r (count b)\n        c (count (first b))\n        bl (apply str (repeat c \" \"))\n        ; create bigger board with empty boundaries\n        bb (cons (str \" \" bl \" \") (map #(str \" \" % \" \") (conj b bl)))\n    \n        alive? #(= \\# (nth (apply concat b) %))\n        ; count all live cells in 3x3 subquadrant of bb with center x,y (in b)\n        sub9 #(let [x (mod % r) y (quot % r)\n                       sqr (apply str (for [i (range 3)]\n                              (subs (nth bb (+ y i)) x (+ x 3))))]\n                 (get (frequencies sqr) \\#))\n        newc #(if (or (and (alive? %) (= 4 (sub9 %))) (= 3 (sub9 %))) \"#\" \" \")\n        rs (for [p (range (* r c))] (newc p))]\n\n  (map #(apply str %) (partition c rs))))","user":"56bca51ae4b0f26550335963"},{"code":"(fn  life [col]\n     (let [ h (count col) w (count (first col))\n            all-cell (for [y (range h) ] (for [x (range w)] [x y] ) )\n            neighbours-pos [-1 0 1]\n            cell-vaule (fn [m n] (nth (nth col n) m))\n            neighbours (fn [m n]\n              (filter (fn [[x y]] (and (< -1 x w) (<  -1 y h) (not (and  (= x m ) (= n y ) )  ) ))\n                      (for [x neighbours-pos  y neighbours-pos] [(+ m x) (+ n y)])))\n            next-cell-v (fn [m n]\n                          (let[neighbours-value (map (fn [[x y]] (cell-vaule x y) )  (neighbours m n)   )\n                               v (cell-vaule m n)\n                               life-num (count (filter #(= 35 (int %) ) neighbours-value))\n                               empty-num (count (filter #(= 32 (int %) ) neighbours-value))\n                               ]\n                          (if (= 35 (int v))\n                              (if (and (<= 2 life-num) (<= life-num 3)) \"#\" \" \")\n                              (if (= life-num 3) \"#\" \" \"))))]\n\n     (map (fn [row]\n          (reduce #(.concat %1 %2) \"\"\n                  (map (fn [[x y]] (next-cell-v x y))  row) ))\n          all-cell)\n     ;(next-cell-v 2 3)\n     ;  all-cell\n\n  ))","problem":94,"user":"4ec5bec6535d6d7199dd36b3"},{"code":"(fn life [board]\n  (let [size       (count board)\n        grid       (flatten (map seq board))\n        indices      (for [a (range size)\n                         b (range size)]\n                     [a b])\n        squares    (zipmap indices grid)\n        neighbors  (fn [index]\n                     (let [cx (first index)\n                           cy (second index)]\n                       (filter #(not (nil? %)) (for [x [(dec cx) cx (inc cx)]\n                                                     y [(dec cy) cy (inc cy)]]\n                                                 (if (or (and (= x cx) (= y cy))\n                                                         (or (> 0 x) (> 0 y))\n                                                         (or (<= size x) (<= size y)))\n                                                   nil\n                                                   (squares [x y]))))))\n        nextgen    (fn [index]\n                     (let [alive-neighbors (count (filter #(= \\# %) (neighbors index)))]\n                       (if (= \\# (squares index))\n                         (cond (> 2 alive-neighbors) \\space\n                               (< 3 alive-neighbors) \\space\n                               :else \\#)\n                         (cond (= 3 alive-neighbors) \\#\n                               :else \\space))))\n        nextgrid   (map nextgen indices)\n        nextboard  (partition size nextgrid)]\n\n    (map clojure.string/join nextboard)))","problem":94,"user":"510cd1dde4b078ea71921124"},{"problem":94,"code":"(fn [board]\n  (let [m (count board)\n        n (count (first board))\n        s \\space]\n    (map #(apply str %) (partition m m (for [i (range m)\n                                             j (range n)\n                                             :let [neighbours (for [k [-1 0 1]\n                                                                    l [-1 0 1]\n                                                                    :when (not= [k l] [0 0])]\n                                                                (get-in board [(+ i k) (+ j l)]))\n                                                   alive (count (filter #{\\#} neighbours))\n                                                   cell (= \\# (get-in board [i j]))]]\n                                         (cond\n                                          (or (zero? i) \n                                              (zero? j) \n                                              (= i (dec m)) \n                                              (= j (dec n))) s ; border\n                                          (and cell (< alive 2)) s ; under-population\n                                          (and cell (> alive 3)) s ; overcrowding\n                                          cell \"#\"                   ; lives on\n                                          (= 3 alive) \"#\"             ; reproduction\n                                          :else s                  ; stays dead\n                                         ))))))","user":"544e9022e4b0e3978000698b"},{"code":"(fn game-of-life\n  [board]\n  (let [context (fn [s]\n                  (concat [[(first s) (nth s 1)]]\n                          (map vector\n                               (drop-last 2 s)\n                               (butlast (next s))\n                               (nthnext s 2))\n                          [[(nth s (- (count s) 2)) (last s)]]))\n        transpose (fn [s]\n                    (for [n (range (count (first s)))]\n                      (map #(nth % n) s)))]\n    (let [neighbors (flatten (map (fn [row]\n                                   (map #(apply + (map {\\# 1 \\space 0} (flatten %)))\n                                        row))\n                                  (map context (map transpose (context board)))))\n          contents (flatten (map seq board))]\n      (map (partial apply str) (partition (count (first board))\n                                          (map (fn [live-cells contents]\n                                                 (if (= contents \\#)\n                                                   (if (< 2 live-cells 5)\n                                                     \\#\n                                                     \\space)\n                                                   (if (= 3 live-cells)\n                                                     \\#\n                                                     \\space)))\n                                               neighbors\n                                               contents))))))","problem":94,"user":"511b233ae4b07ab9ec456180"},{"code":"(fn conway-life [b]\r\n  (let [n (count (first b))\r\n        m (count b)\r\n        alive \\#\r\n        dead \\space]\r\n    (letfn [(neighbours [x y]\r\n              (frequencies\r\n                (keep (partial get-in b)\r\n                 [[(dec x) (dec y)][x (dec y)][(inc x) (dec y)][(dec x) y]\r\n                  [(dec x) (inc y)][x (inc y)][(inc x) (inc y)][(inc x) y]])))\r\n            (alive? [x y] (= alive (get-in b [x y])))]\r\n      (for [x (range n)]\r\n        (apply str\r\n         (for [y (range m)]\r\n          (let [neighb (neighbours x y)]\r\n            (if (alive? x y)\r\n              (if (< 1 (neighb alive 0) 4) alive dead)\r\n              (if (= 3 (neighb alive 0)) alive dead)))))))))","problem":94,"user":"4e994541535dbda64a6f6b64"},{"problem":94,"code":"(fn [board] (let [xy (fn [board i j] (let [maxx (count board) maxy (count (first board))] (if (or (< i 0) (< j 0) (>= i maxx) (>= j maxy)) nil (nth (nth board i) j))))\n                  livenei (fn [board x y] (count (filter #(= \\# %) (list (xy board (dec x) (dec y)) (xy board (dec x) y) (xy board (dec x) (inc y)) (xy board x (dec y)) (xy board x (inc y)) (xy board (inc x) (dec y)) (xy board (inc x) y) (xy board (inc x) (inc y))))))\n                  nex (fn [board x y] (let [live (livenei board x y)] (if (= \\# (xy board x y)) (if (or (= 2 live) (= 3 live)) \\# \\space) (if (= 3 live) \\# \\space))))\n                  ]\n              (map (fn [row x] (apply str (map (fn [el y] (nex board x y)) row (range (count row))))) board (range (count board)))\n))","user":"5b4b4052e4b02d533a91bc9a"},{"problem":94,"code":"(fn next-game-of-life-board [board]\n  (letfn [(neighbors-coordinates [[x y] size-x size-y]\n            (let [deltas [[-1 -1] [-1 0] [-1 1] [0 -1] [0 1] [1 -1] [1 0] [1 1]]]\n              (filter (fn [[x y]]\n                        (and (>= x 0)\n                             (>= y 0)\n                             (< x size-x)\n                             (< y size-y)))\n                      (map (fn [[dx dy]]\n                             [(+ x dx ) (+ y dy)])\n                           deltas))))\n          (neighbors [board xy]\n            (let [size-x (count (first board))\n                  size-y (count board)]\n              (map #(get-in board %)\n                   (neighbors-coordinates xy size-x size-y))))\n          (cell-score [board xy]\n            (count (filter #{\\#}\n                           (neighbors board xy))))\n          (next-cell-value [board xy]\n            (let [cell-val   (get-in board xy)\n                  cell-score (cell-score board xy)]\n              (condp = cell-val\n                \\space (if (= cell-score 3) \\# \\space)\n                \\#     (if (some #{cell-score} [2 3]) \\# \\space))))]\n    (let [size-x (count (first board))\n          size-y (count board)]\n      (->> (for [x (range size-x) y (range size-y)] [x y])\n           (map #(next-cell-value board %))\n           (partition size-x)\n           (map #(apply str %))))))","user":"55586905e4b0deb715856e2b"},{"code":"(let [delt [-1 0 1]\n      adj (for [x delt y delt :when (some #(not= 0 %) [x y])] [x y])]\n  (fn [board]\n    (let [rows (count board)\n          cols (count (first board))]\n      (letfn [(at [pos] (get-in board pos))\n              (move [pos delts] (vec (map + pos delts)))\n              (valid? [[r c]] (and (< -1 r rows) (< -1 c cols)))\n              (neighbors [pos] (map at (filter valid? (map (partial move pos) adj))))]\n        (map (fn [r]\n               (apply str (for [pos (map #(vector r %) (range cols))]\n                            (let [nfreq (frequencies (neighbors pos))\n                                  nlive (get nfreq \\# 0)\n                                  live? ({\\space false \\# true} (at pos))]\n                              (if live?\n                                (if (#{2 3} nlive) \\# \\space)\n                                (if (= 3 nlive) \\# \\space))))))\n             (range rows))))))","problem":94,"user":"4ffc10aae4b0678c553fc3d6"},{"problem":94,"code":"(fn life-step [field]\n  (let [nbs (fn [f x y]\n              (for [dx [-1 1 0] dy [-1 1 0] :when (not= dx dy 0)]\n                (get-in f [(+ y dy) (+ x dx)])))\n        size-y (count field)\n        size-x (count (field 0))]\n    (->>\n      (for [cur-y (range 0 size-y)]\n        (for [cur-x (range 0 size-x)]\n          (let [cur-nbs (nbs field cur-x cur-y)\n                live (->> (filter #(= \\# %) cur-nbs) count)]\n            (cond\n              (or (< live 2) (> live 3)) \" \"\n              (= live 3) \"#\"\n              :default (get-in field [cur-y cur-x])))))\n      (map #(apply str %)))))","user":"5b13ba71e4b0cc2b61a3be53"},{"code":"(fn __ [m]\n  (let [\n    w (count (first m)) ; width of game\n    h (count m) ; height of game\n    ; character constants\n    ALIVE \\#\n    DEAD \\space\n    ; put the matrix in a map we can easily look up values with\n    mm (reduce \n          #(assoc % (count %) %2)\n          {}\n          (apply concat m)\n        ) \n    ]\n    (letfn [\n      ; get the neighbors of cell key n               \n      (neighbors [n]\n        ; neighbor n starts with upper left neighbor and goes clockwise\n        (let [\n         n-  (if-not (zero? (mod n w)) (dec n)) \n         n+  (if-not (zero? (mod (inc n) w)) (inc n))             \n         n-1 (if n- (- n- w))\n         n-2 (- n w)\n         n-3 (if n+ (- n+ w))\n         n-4 n+\n         n-5 (if n+ (+ n+ w))\n         n-6 (+ n w)\n         n-7 (if n- (+ n- w))\n         n-8 n-\n         alln (vector n-1 n-2 n-3 n-4 n-5 n-6 n-7 n-8)\n         n-all (map mm alln)\n        ]\n        n-all\n       )\n      )\n            \n     ; get the count of alive neighbor cell  \n      (alive-count [cs]\n        (reduce #(+ % (if (= ALIVE %2) 1 0)) 0 cs)                  \n      )\n  \n     ;tell me if this cell is dead or alive based on integer of total\n      (dead-or-alive [is-alive, nc]\n       (if is-alive\n         (cond\n\t\t\t      ;Any live cell with fewer than two live neighbours dies, as if caused by under-population.\n            (< nc 2) DEAD\n\t\t\t      ;Any live cell with more than three live neighbours dies, as if by overcrowding.\n            (> nc 3) DEAD\n\t\t\t      ;Any live cell with two or three live neighbours lives on to the next generation.\n            :else ALIVE\n         )\n\t       ;Any dead cell with exactly three live neighbours becomes a live cell, as if by reproduction.\t\t\t\n         (if (= nc 3) ALIVE DEAD))      \n      )\n  \n      ; calculate next generation based on current\n      (next-generation [g1]\n        (let [mma (sort-by key < mm)\n              mapped (map #(dead-or-alive (= (second %) ALIVE) (alive-count (neighbors (first %)))) mma)\n              pretty-formatted (map #(apply str %) (partition-all w h mapped))\n             ]\n          pretty-formatted\n        )\n      )\n    ]\n    ; get the next generation of Conway's game of life\n    (next-generation m)\n    )    \n  )\n)","problem":94,"user":"503f872ee4b00d1a725ff2ac"},{"problem":94,"code":"(fn [field]\n  (let [wrapped-rows (#(concat (list %) field (list %)) (apply str (repeat (count (first field)) \" \")))\n        wrapped-field (map #(str \" \" % \" \") wrapped-rows)\n        partition-by3 (partial partition 3 1)\n        update-table (fn [f-update table] (map (partial map f-update) table))\n        partitioned-rows (update-table partition-by3 (partition-by3 wrapped-field))\n        rows-of-areas (map (partial apply map list) partitioned-rows)\n        rows-of-flattened (update-table flatten rows-of-areas)\n        rows-of-maps (update-table \n                       #(hash-map :cell (= \\# (nth % 4)) :neighbours \n                         ((fn [s] (count (filter (partial = \\#) \n                           (concat (take 4 s) (take-last 4 s))))) %))\n                       rows-of-flattened)\n        get-new-cell (fn [area-map] (let [cell (:cell area-map) neighbours (:neighbours area-map)]\n          (cond (or (< neighbours 2) (> neighbours 3)) \\space\n                (or (= neighbours 3) (= cell true)) \\#\n                :else \\space)))\n        new-cells (update-table get-new-cell rows-of-maps)]\n    (vec (map #(apply str %) new-cells))))","user":"575ddfd1e4b02ea11479938d"},{"problem":94,"code":"(fn [rows]\n    (map #(apply str %)\n         (partition\n           (count rows)\n           (map (fn [[c n]]\n                  (if (or (and (= c \\#) (= n 2)) (= n 3))\n                    \\# \\ ))\n                (for [x (range 0 (count rows))\n                      y (range 0 (count (nth rows x)))]\n                  (let [lim (fn [coll n] (if (< -1 n (count coll)) (nth coll n) \" \"))]\n                    [(lim (lim rows x) y)\n                     (count\n                       (filter\n                         (partial = \\#)\n                         [(lim (lim rows (dec x)) (dec y)) (lim (lim rows x) (dec y)) (lim (lim rows (inc x)) (dec y))\n                          (lim (lim rows (dec x)) y) (lim (lim rows (inc x)) y)\n                          (lim (lim rows (dec x)) (inc y)) (lim (lim rows x) (inc y)) (lim (lim rows (inc x)) (inc y))]))]))))))","user":"51e28063e4b08e53a149f0f2"},{"code":"(fn [board]\n  (let [n (count board)\n        b (vec (map vec board))\n        st (for [x (range -1 2) y (range -1 2) \n                 :when (not (and (zero? x) (zero? y)))] [x y])\n        mv (fn [[x y] [mx my]] [(+ x mx) (+ y my)])\n        in? (fn [[x y]] (and (<= 0 x) (<= 0 y) (< x n) (< y n)))\n        pk (fn [[x y]] ((b x) y)) \n        nb (fn [c] (map (partial mv c) st))\n        hm (fn [c] (count (filter (partial = \\#) \n                                  (map pk (filter in? (nb c))))))\n        nx (fn [c] \n             (let [p (pk c)\n                   h (hm c)] \n               (cond (and (= \\# p) (< h 2)) \\space\n                 (and (= \\# p) (or (= 2 h) (= 3 h))) \\#\n                 (and (= \\# p) (< 3 h)) \\space\n                 (and (= \\space p) (= 3 h)) \\#\n                 :else p)))]\n    (vec (map (partial apply str) (for [x (range n)]\n                                    (for [y (range n)] \n                                      (nx [x y])))))))","problem":94,"user":"5246e945e4b0644eb7b0783b"},{"problem":94,"code":"(fn game-of-life [data]\n  (letfn [(valid-range [min max num]\n            (->> (range (dec num) (+ 2 num))\n                 (drop-while #(> min %))\n                 (take-while #(> max %))\n                 (into [])))\n\n          (neighbors [x y data]\n            (let [xs (valid-range 0 (count (first data)) x)\n                  ys (valid-range 0 (count data) y)]\n              (for [x' xs y' ys\n                    :when (not (and (= y' y) (= x' x)))]\n                [x' y'])))\n\n          (alive-neighbors [x y data]\n            (->> (neighbors x y data)\n                 (map (fn [[x y]] (nth (nth data y) x)))\n                 (filter #(= % \\#))\n                 count))]\n    (into\n     []\n     (map-indexed\n      (fn [y row]\n        (let [v (map-indexed\n                 (fn [x char]\n                   (let [a (alive-neighbors x y data)]\n                     (cond\n                       (or (< a 2) (> a 3)) \\space\n                       (and (= char \\space) (= a 3)) \\#\n                       :else char)))\n                 row)]\n          (apply str v)))\n      data))))","user":"55fbc657e4b0f488688e0666"},{"problem":94,"code":"(fn game-of-life [coll]  \n     (let [height (count coll)\n           width (count (nth coll 0))]\n       (letfn [(element-type [[i j]]\n                 (nth (nth coll i) j))\n               (neighbour-no-neg [[x y]]\n                  (remove \n                    #(some neg? %)  \n                    (for [dx [-1 0 1]\n                          dy (if (zero? dx)\n                               [-1 1]\n                               [-1 0 1])]\n                      [(+ x dx) (+ y dy)])))\n                (neighbour-position [[x y]]\n                  (remove #(<= height (last %))\n                          (remove #(<= width (first %)) (neighbour-no-neg [x y]))))\n                (neighbour-type [[x y]]\n                  (map #(nth (nth coll (first %)) (last %)) (neighbour-position [x y])))\n                (count-neighbours-alive [[x y]]\n                  (count (filter #(= % \\#) (neighbour-type [x y]))))]\n         (map \n           #(apply str %) \n           (for [i (range (count coll))]\n             (for [j (range (count (nth coll i)))]\n               (if (= \\# (element-type [i j]))\n                 (cond\n                   (> 2 (count-neighbours-alive [i j])) \\space\n                   (<= 2 (count-neighbours-alive [i j]) 3) \\#\n                   (< 3 (count-neighbours-alive [i j])) \\space)\n                 (if (= 3 (count-neighbours-alive [i j]))\n                   \\#\n                   \\space))))))))","user":"58dcb8cde4b0a4d5acaab6a7"},{"problem":94,"code":"(fn game-of-life [board]\n  (let [ln (count board)]\n    (letfn [(cnt-neigh [brd-mp]\n              (for [x (range ln)\n                    y (range ln)]\n                (apply + (for [dx [0 1 -1] dy [0 1 -1]\n                              :when (not (= 0 dx dy))]\n                            (let [chr (get-in brd-mp [(+ x dx) (+ y dy)] 0)]\n                              ({\\# 1} chr 0))))))\n\n          (mapping [[chr n]] (if (or (and (= \\# chr) (#{2 3} n))\n                                      (and (= \\space chr) (#{3} n)))\n                                \"#\" \" \"))]\n\n    (let [counts (cnt-neigh board)\n          zips (partition 2 (interleave (apply str board) counts))]\n      (map #(apply str %)\n           (partition ln (map mapping zips)))))))","user":"5a527beee4b05d388ecb6bfe"},{"problem":94,"code":"(fn nx-board [board]\n  (let [; size of the board\n         size (count board)\n         ; char -> true/false if char is live\n         char-to-live (fn [char] (= char \\#))\n         ; bool -> char for alive/dead\n         live-to-char (fn [live] (if live \\# \\space))\n         ; board of boolean (alive/dead)\n         live-board (map #(map char-to-live %) board)\n         ; fct (x, y) -> true if elt at x/y is live\n         elt-at (fn [x y]\n                  (if (or (< y 0)\n                          (< x 0)\n                          (>= y size)\n                          (>= x size))\n                    false\n                    (nth (nth live-board y) x)))\n         ; matrix of neighboors\n         neighboors-matrix [[-1 -1] [0 -1] [1 -1]\n                            [-1 0] [1 0]\n                            [-1 1] [0 1] [1 1]]\n         nx-live-board (for [y (range size)\n                             x (range size)]\n                         (let [; true if the elt is live\n                               is-live (elt-at x y)\n                               ; the neighboors of an element\n                               neighboors (for [[dx dy] neighboors-matrix]\n                                            (elt-at (+ x dx) (+ y dy)))\n                               nb-live-neighboors (count (filter true? neighboors))\n                               nx-live (if is-live\n                                         (cond\n                                           (< nb-live-neighboors 2) false\n                                           (< nb-live-neighboors 4) true\n                                           :else false)\n                                         (= 3 nb-live-neighboors))]\n                           (live-to-char nx-live)))]\n        (map #(apply str %) (partition size nx-live-board))))","user":"5264383be4b03e8d9a4a70cb"},{"code":"(fn next-generation [board]\r\n  (let [live \\#\r\n        dead \\space\r\n        directions (remove #(= [0 0] %) (for [x (range -1 2) y (range -1 2)] [x y]))\r\n        count-neighbor-live (fn [base-x base-y]\r\n                              (count (filter #(= live %)\r\n                                             (map (fn [[x y]]\r\n                                                    (get (get board (+ base-y y) [])\r\n                                                         (+ base-x x)\r\n                                                         dead))\r\n                                                  directions))))]\r\n    (map-indexed (fn [y line]\r\n                   (apply str\r\n                          (map-indexed (fn [x cell]\r\n                                         (let [live-count (count-neighbor-live x y)]\r\n                                           (if (if (= cell live)\r\n                                                 (or (= live-count 2) (= live-count 3))\r\n                                                 (= live-count 3))\r\n                                             live\r\n                                             dead)))\r\n                                       line)))\r\n                 board)))","problem":94,"user":"4e7c8fd1535db169f9c796be"},{"problem":94,"code":"(fn [b] \n  (->>\n    b\n    (map #(replace {\\# 1 \\space 0} (vec %)))\n    (#(concat [%] %2 [%]) (repeat (count (first b)) 0))\n    (map #(partition 3 1 (concat [0] % [0])))\n    (partition 3 1)\n    (map (fn [[r1 r2 r3]]\n      (map (fn [[a b c] [d e f] [g h i]] \n        (let [z (+ a b c d f g h i)]\n          (if (= 1 e) (cond (< z 2) \\space (> z 3) \\space :else \\#) (if (= 3 z) \\# \\space))\n          )) r1 r2 r3)))\n    (map #(apply str %))))","user":"5b919d9de4b0c0b3ffbd4a24"},{"code":"(fn [initboard]\n  (let [indices\n        (for [i (range (count initboard)) j (range (count (first initboard)))] [i j])\n\n        update-board (fn [ board [i j] char]\n                       (let [s (vec (get board i))]\n                         (println [i j] \"to \" char)\n                         (assoc board i (apply str (assoc s j char)))))\n        \n        neighbours (fn [ [i j]]\n                            (let [[xs ys]  [(dec i) (dec j)]\n                                  [xe ye]  [(+ 2 i) (+ 2 j)]]\n                              (for [x (range xs xe) y (range ys ye)\n                                    :when (not= [i j] [x y])\n                                    :when (>= x 0)\n                                    :when (>= y 0)]\n                                (get-in initboard [x y]))))\n\n        evolve-cell (fn [board index]\n                      (let [live? (fn [c] \n                                    (= \\# c))\n                            \n                            cell (get-in board index)\n                            live-neighbs (remove #(not (live? %))\n                                                 (neighbours index))\n                            n (count live-neighbs)]\n                        (cond\n                         (and (live? cell) (< n 2)) (update-board board index \\space)\n                         (and (live? cell) (> n 3)) (update-board board index \\space)\n                         (and (not (live? cell)) (= n 3)) (update-board board  index \\#)\n                         :else board\n                         )))]\n    (reduce evolve-cell initboard indices)))","problem":94,"user":"4edf5dc6535d10e5ff6f5340"},{"code":"(fn [x]\n  (let [f2 (fn [j i c] [[j i] [c 0]])\n        f1 (fn [j r] (into {} (map f2 (repeat j) (range) r)))\n        m (apply merge (map f1 (range) x))\n        f4 (fn [j i]\n             (let [s (first (m [j i]))\n                   n (count (filter (partial not= \\space)\n                       (filter char?\n                         (map first\n                           [(m [j (dec i)])\n                            (m [j (inc i)])\n                            (m [(dec j) i])\n                            (m [(inc j) i])\n                            (m [(inc j) (inc i)])\n                            (m [(inc j) (dec i)])\n                            (m [(dec j) (inc i)])\n                            (m [(dec j) (dec i)])]))))]\n               (cond\n                 (and (= s \\space) (= n 3)) \\#\n                 (and (not= s \\space) (< n 2)) \\space\n                 (and (not= s \\space) (> n 3)) \\space\n                 :else s)))\n        f3 (fn [j w] (apply str (map f4 (repeat j) (range w))))]\n\n    (map f3 (range (count x)) (repeat (count (first x))))))","problem":94,"user":"5201572be4b0d7096e99ddbb"},{"problem":94,"code":"(fn conway [b]\n  (letfn [(some? [x] (not= x nil))\n          (parse-board [b]\n             (into #{} (filter some? \n                               (apply concat \n                                      (for [i (range (count b))]\n                                        (for [j (range (count (b i)))]\n                                          (if (= (get (b i) j) \\#) \n                                            [i j]\n                                            nil)))))))\n\n          (neighbors [[x y]]\n            (for [i (range (- x 1) (+ x 2))\n                  j (range (- y 1) (+ y 2))\n                  :when (not= [i j] [x y])]\n              [i j]))\n\n          (step [live]\n            (let [adj (group-by identity (mapcat neighbors live))]\n              (into #{} (filter some? (for [n (keys adj)]\n                                        (case (count (adj n))\n                                          2 (if (live n) n nil)\n                                          3 n\n                                          nil))))))\n\n          (print-board [x y live]\n            (let [raw  (for [i (range x)]\n                         (for [j (range y)]\n                           (if (live [i j]) \"#\" \" \")))]\n              (mapv #(apply str %) raw)))]\n    (->> (parse-board b)\n         (step)\n         (print-board (count b) (count (first b))))))","user":"57a0f256e4b0c3d858beb8dd"},{"problem":94,"code":"(fn [s]\n            (map\n             #(reduce str %)\n             (let [n (count s)\n                   c  (fn [i j] (if (and (>= i 0)\n                                         (>= j 0)\n                                         (< i n)\n                                         (< j n))\n                                       (get (get\n                                             (let [x (fn [t]\n                                                       (reduce #(conj % %2) [] t))]\n                                               (reduce #(conj % (x %2)) [] s))\n                                             i)\n                                        j)))]\n               (partition n\n                          (for [i (range 0 n) j (range 0 n)]\n                            (let [q (c i j)\n                                  v (count (filter\n                                            #(= % \\#)\n                                            (for [x [-1 0 1] y [-1 0 1]]\n                                              (if (and (= x 0) (= y 0)) nil (c (+ x i) (+ y j))))\n                                            )\n                                           )\n                                  ]\n                              (if (or\n                                   (and (= q \\#) (or (= v 2) (= v 3)))\n                                   (and (= q \\space) (= v 3)))\n                                \\#\n                                \\space))\n                          )\n                )\n              )\n            )\n           )","user":"56c08696e4b060a8e693e3aa"},{"code":"(fn [b]\n  (for [y (range(count b))]\n    (apply str\n           (for [x (range(count(nth b y)))]\n             (let [v [[-1 -1][-1 0][-1 1][0 -1][0 1][1 -1][1 0][1 1]]\n                   l (map #(nth (nth b (+ y (second %)) [\\space]) (+ x (first %)) \\space) v)\n                   n (count(filter #(= \\# %) l))]\n               (if (= (nth (nth b y) x) \\#)\n                 (if (or (= n 2) (= n 3)) \\# \\space)\n                 (if (= n 3) \\# \\space)))))))","problem":94,"user":"4db2cc55535df7e46ed9b6c5"},{"problem":94,"code":"(fn [board]\n\t(let [\n\t\trows (count board)\n\t\tcols (count (first board))\n\t\tobject (apply hash-map (flatten (for [r (range rows)] (for [c (range cols)] [(str r c) {:r r :c c :alive (= \"#\" (subs (nth board r) c (inc c)))}]))))\n\t\trneighbors (into {} (for [r (range rows)] [r (concat (if (pos? r) [(dec r)] [nil]) [r] (if (< r (dec rows)) [(inc r)][nil]))]))\n\t\tcneighbors (into {} (for [c (range cols)] [c (concat (if (pos? c) [(dec c)] [nil]) [c] (if (< c (dec cols)) [(inc c)] [nil]))]))\n\t\tneighbors (for [cell object] (let [o (second cell)] [(first cell) (flatten (for [r (rneighbors (o :r))] (remove #(or (< (count %) 2) (= (first cell) %)) (for [c (cneighbors (o :c))] (str r c)))))]))\n\t\tstates (apply hash-map (mapcat (fn [cell] [(first cell) {:alive (get-in object [(first cell) :alive]) :ncount (reduce #(if (get-in object [%2 :alive]) (inc %1) %1) 0 (second cell))}]) neighbors))]\n\t\t(for [r (range rows)] (apply str (for [c (range cols)] (let [state (states (str r c)) alive? (state :alive) ncount (state :ncount)] (if alive? (cond (< ncount 2) \" \" (< ncount 4) \"#\" :else \" \") (if (= ncount 3) \"#\" \" \"))))))))","user":"56bb9ccce4b0f26550335959"},{"problem":94,"code":"(let [delta\n      (reduce (fn [m1 k1]\n                (concat m1 (reduce (fn [m2 k2]\n                                     (if (and (zero? k1) (zero? k2))\n                                       m2 (conj m2 [k1 k2])))\n                                   '() [-1 0 1])))\n              '() [-1 0 1])]\n  (fn [cells]\n    (let [rows (count cells)\n          cols (count (first cells))\n          lives\n          (reduce-kv (fn [m1 k1 v1]\n                       (concat m1 (reduce-kv (fn [m2 k2 v2]\n                                               (if (= v2 \\#)\n                                                 (conj m2 [k1 k2]) m2))\n                                             '() (zipmap (range cols) v1))))\n                     '() (zipmap (range rows) cells))\n          neighbors (frequencies\n                     (mapcat (fn [[x y]]\n                               (map (fn [[dx dy]]\n                                      [(+ x dx) (+ y dy)])\n                                    delta))\n                             lives))\n          next-step (reduce-kv (fn [m k v]\n                                 (if (= v 3) (conj m k) m))\n                               (reduce (fn [m k]\n                                         (if (= (get neighbors k) 2)\n                                           (conj m k) m))\n                                       #{} lives) neighbors)\n          world (reduce\n                 (fn [m k] (update-in m k inc))\n                 (->> 0 (repeat cols) (into [])\n                      (repeat rows) (into [])) next-step)]\n      (map (partial apply str)\n           (map (partial map [\\space \\#]) world)))))","user":"54c5cc17e4b045293a27f624"},{"code":"(fn next-day [v]                                                                                                 \n  (let [board (vec (map vec v))                                                                                    \n        rows (count board)                                                                                         \n        cols (count (first board))                                                                                 \n        get-state (fn [x y]                                                                                        \n                    (get (get board y []) x \\space))                                                               \n        cell-next-day (fn [x y]                                                                                    \n                        (let [state (get-state x y)                                                                \n                              neighbors [[-1 -1] [-1 0] [-1 1]                                                     \n                                         [0 -1] [0 1]                                                              \n                                         [1 -1] [1 0] [1 1]]                                                       \n                              live-neighbor-count (count (filter #(= % \\#) (map                                                                                                                   (fn [[dx dy]]                                                                                                        (get-state                        \n                                                                                   (+ x dx) (+ y dy)))                                                                                            neighbors)))]                                                 (if (= state \\#)                                                                         \n                            (cond                                                                                  \n                              (< live-neighbor-count 2) \\space                                                     \n                              (<= live-neighbor-count 3) \\#                                                        \n                              :else \\space)                                                                        \n                            (if (= live-neighbor-count 3)                                                          \n                              \\#                                                                                   \n                              \\space))))                                                                           \n        board-next-day (for [y (range rows)]                                                                       \n                         (apply str (for [x (range cols)]                                                          \n                           (cell-next-day x y))))]                                                                 \n    board-next-day))","problem":94,"user":"51899891e4b0288ada3dbdab"},{"code":"(fn [tabuleiro]\n  (let [dimensao (count tabuleiro)]\n    (->> (map vector \n              (->> (for [linha-original (range dimensao)\n                         coluna-original (range dimensao)]\n                     (remove #(let [lin (first %)\n                                    col (second %)]\n                                (or (neg? lin)\n                                    (>= lin dimensao)\n                                    (neg? col)\n                                    (>= col dimensao)\n                                    (= [linha-original coluna-original] %)))\n                             (for [linha-vizinho (range (dec linha-original) (inc (inc linha-original)))\n                                   coluna-vizinho (range (dec coluna-original) (inc (inc coluna-original)))]\n                               [linha-vizinho coluna-vizinho])))\n                (map #(->> (map (fn [c] (get-in tabuleiro c)) %)\n                        (remove (fn [x] (= \\space x)))\n                        count)))\n              (mapcat seq tabuleiro))\n      (map (fn [[n cell]]\n             (if (= \\# cell)\n               (cond \n                 (or (= n 2) (= n 3)) \\#\n                 :else \\space)\n               (if (= n 3)\n                 \\#\n                 \\space))))\n      (partition dimensao)\n      (map #(apply str %))\n      (vec))))","problem":94,"user":"52c8758be4b0c2d177d62135"},{"code":"(fn [s bo]\n  (map-indexed (fn [y b] (apply str (map-indexed #(s bo % y %2) b))) bo))\n(fn s [b x y here]\n  (let [countn (fn [b x y]\n                (count\n                  (filter #{\\#}\n                    (for [i [-1 0 1] j [-1 0 1]]\n                      (if-not (= [0 0] [i j])\n                        (get (get b (+ y i)) (+ x j)))))))\n        result (countn b x y)]\n  (if (= here \\#)\n      (cond (< result 2) \\ \n            (< result 4) \\#\n            true         \\ )\n      (if (= result 3) \\# \\ ))))","problem":94,"user":"50166470e4b052339a490e76"},{"problem":94,"code":"(fn [board]\n  (let [offsets [[-1 -1] [-1 0] [-1 1]\n                 [0 -1] [0 1]\n                 [1 -1] [1 0] [1 1]]\n        height (count board)\n        width (count (first board))\n        get-state (fn [[x y] [dx dy]]\n                    (let [c (+ x dx) r (+ y dy)] \n                      (if (or (< c 0) (= c width) (< r 0) (= r height))\n                        \\space\n                        (get-in board [r c]))))\n        count-lives (fn [p]\n                      (reduce + (map #(if (= \\# (get-state p %)) 1 0) offsets)))\n        next-state (fn [s p]\n                     (let [n (count-lives p)] \n                       (if (or (= n 3)\n                               (and (= s \\#) (= n 2)))\n                         \\#\n                         \\space)))] \n    (->> (for [y (range height) x (range width)]\n           (next-state (get-in board [y x]) [x y]))\n      (partition width)\n      (map #(apply str %))\n      vec)))","user":"53f75957e4b0de5c4184855d"},{"code":"(letfn [(remap [m f] (into {} (for [[k v] m] [k (f k v)])))\n        (numbered [s] (map vector (range) s))\n        (alive? [m pos] (get-in m [pos :alive?]))\n        (neighbours [y x]\n          (let [f (juxt identity dec inc)]\n            (for [a (f y) b (f x) :when (not= [a b] [y x])] [a b])))\n        (strings->map [s]\n          (into {} (for [[row l] (numbered s)\n                         [col c] (numbered l)]\n                     [[row col] {:alive? (= \\# c)}])))\n        (live-neighbours [m row col]\n          (->> (neighbours row col)\n               (map (partial alive? m))\n               (filter identity)\n               count))\n        (next-state [{live? :alive?} n]\n          {:alive? (cond (and live? (#{0 1} n)) false\n                         (and live? (#{2 3} n)) true\n                         live? false\n                         (= n 3) true\n                         :else false)})\n        (play-turn-in-map [m]\n          (remap m (partial play-turn m)))\n        (play-turn [m [row col] cell]\n          (next-state cell (live-neighbours m row col)))\n        (map->strings [m]\n          (map (comp (partial apply str)\n                     (partial map (comp {true \\#, false \\space}\n                                        (partial alive? m))))\n               (partition-by first (sort (keys m)))))]\n  (fn [s]\n    (-> s\n        strings->map\n        play-turn-in-map\n        map->strings)))","problem":94,"user":"4f1bb9d8535d64f60314647d"},{"problem":94,"code":"(fn life [board]\n  (let [\n    vboard (mapv vec board)\n    alive? #(= \\# %)\n    neighbors (fn [rowN row cellN cell]\n      {\n        :count \n          (->> \n            [\n              (if (> rowN 0) ((vboard (dec rowN)) cellN) nil)\n              (if (< rowN (dec (count board))) ((vboard (inc rowN)) cellN) nil)\n              (if (> cellN 0) ((vboard rowN) (dec cellN)) nil)\n              (if (< cellN (dec (count (vboard rowN)))) ((vboard rowN) (inc cellN)) nil)\n              (if (and (> rowN 0) (> cellN 0)) \n                ((vboard (dec rowN)) (dec cellN)) nil)\n              (if (and (> rowN 0) (< cellN (dec (count (vboard rowN))))) \n                ((vboard (dec rowN)) (inc cellN)) nil)\n              (if (and (< rowN (dec (count board))) (> cellN 0)) \n                ((vboard (inc rowN)) (dec cellN)) nil)\n              (if (and (< rowN (dec (count board))) (< cellN (dec (count (vboard rowN))))) \n                ((vboard (inc rowN)) (inc cellN)) nil)\n            ]\n            (filter alive?)\n            (count))\n        :alive\n          (alive? cell)\n      })\n    logic (fn [cell]\n      (cond \n        (< (cell :count) 2) \" \"\n        (> (cell :count) 3) \" \"\n        (and (not (cell :alive)) (= (cell :count) 3)) \"#\"\n        (cell :alive) \"#\"\n        (not (cell :alive)) \" \"))\n  ]\n    (->>\n      (map-indexed\n        (fn [rowN row]\n          (map-indexed\n            #(neighbors rowN row %1 %2)\n            row))\n        vboard)\n        (map\n          (fn [row]\n            (->> \n              (map\n                #(logic %)\n                row)\n              (apply str)))))))","user":"5b02ab12e4b0cc2b61a3bd53"},{"problem":94,"code":"(fn game-of-life [board]\n  (->> [(+ dx x)\n        (+ dy y)]\n       (get-in board)\n       (for [x (range (count board))\n             y (range (count (first board)))\n             [dx dy] [[0 0] [1 0] [-1 0] [0 1] [0 -1] [1 1] [-1 -1] [1 -1] [-1 1]]])\n       (partition 9)\n       (map (fn [xs]\n              (if (= \\space (first xs))  ;if original element is whitespace\n                (if (= 3 (count (filter #(= % \\#) (rest xs))))\n                  \\# \\space)\n                (let [neighbours (count (filter #(= % \\#) (rest xs)))]\n                  (cond (> 2 neighbours) \\space\n                        (or (= 2 neighbours) (= 3 neighbours)) \\#\n                        (< 3 neighbours) \\space)))))\n       (partition (count (first board)))\n       (map #(apply str %))))","user":"5693a53ee4b0dcc4269f4106"},{"problem":94,"code":"(fn life-game [coll]\n   (letfn [(init [_coll]\n                 (reduce #(conj %1 (vec %2)) [] coll))\n\n           (neighbers [_coll i j lm cm]\n                      (for [x [(dec i) i (inc i)]\n                            y [(dec j) j (inc j)]\n                            :when (and (<= 0 x) (<= 0 y)\n                                       (<= x lm) (<= y cm)\n                                       (not (and (= x i) (= y j))))]\n                        ((_coll x) y)))]\n\n     (let [LMAX (count coll)\n           CMAX (count (first coll))\n           _coll (init coll)]\n\n       (reduce #(conj %1 (apply str %2)) []\n         (partition CMAX\n                   (for [i (range LMAX)\n                         j (range CMAX)\n                         :let [self ((_coll i) j)]]\n                     (let [nlist (group-by str (neighbers _coll i j (dec LMAX) (dec CMAX)))\n                           lives (count (nlist \"#\"))\n                           dies (count (nlist \" \"))]\n                       (if (= (str self) \"#\")\n                         ;live cell\n                         (if (or\n                               ; rule 1\n                               (> 2 lives)\n                               ; rule 2\n                               (< 3 lives))\n                           \" \"\n                           \"#\")\n                         (if (= 3 lives)\n                           \"#\"\n                           \" \"))\n                       )))))))","user":"55a372f1e4b0acc240e31537"}]