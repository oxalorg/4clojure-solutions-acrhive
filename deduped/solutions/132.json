[{"problem":132,"code":";(fn i [f v c]\n;  (if (nil? (second c))\n;    c\n;    (first (reduce (fn [[r a] b] \n;            (if (f a b) \n;              [(conj (conj r v) b) b] \n;              [(conj r b) b])) \n;          [[(first c)] (first c)] (rest c)))))\n(fn [c v s]\n  (mapcat (fn [[a b]] (if (and a b (c a b)) (list a v) (list a)))\n          (partition-all 2 1 s)))","user":"56bca51ae4b0f26550335963"},{"problem":132,"code":"(fn [p v c]\n  (if (seq c)\n    (cons (first c)\n          (mapcat #(if (apply p %) [v (last %)] [(last %)])\n                  (partition 2 1 c)))\n    '()))","user":"55f20e4be4b06e875b46ce40"},{"code":"(fn new-ins [f v coll]\n  (if (empty? (rest coll))\n    coll\n    (if (f (first coll) (second coll))\n      (lazy-seq (cons (first coll) (cons v (new-ins f v (rest coll)))))\n      (lazy-seq (cons (first coll) (new-ins f v (rest coll)))))))","problem":132,"user":"4f04d312535dcb61093f6be7"},{"problem":132,"code":"(fn interposer [p? sep xs]\n  (when (seq xs)\n    (lazy-seq\n      (let [[fst & rst] xs]\n        (cons fst\n              (if (and rst (p? fst (first rst)))\n                (cons sep (interposer p? sep rst))\n                (interposer p? sep rst)))))))","user":"4f5599dfe4b0a7574ea71806"},{"problem":132,"code":"(fn [pred value v]\n  (lazy-seq ((fn insert [prev rst]\n     (if (empty? rst) nil\n         (let [cur (first rst)]\n           (cond (nil? prev) (cons cur (lazy-seq (insert cur (rest rst))))\n                 (pred prev cur) (cons value (cons cur (lazy-seq (insert cur (rest rst)))))\n                 :else (cons cur (lazy-seq (insert cur (rest rst)))))))) nil v)))","user":"58f98231e4b0438e51c2cf4c"},{"code":"(fn ! [p e c]\n  (if-not (empty? c)\n    (let [[a b & t] c]\n      (lazy-seq (concat (if b\n                          (if (p a b) [a e] [a]) [a])\n                          (! p e (rest c)))))))","problem":132,"user":"4e7d1c22535db169f9c796c5"},{"code":"(fn [f k xs]\n  (let [s (partition 2 1 xs)\n        r (mapcat #(if (apply f %) [k (second %)] [(second %)]) s)]\n    (if (empty? xs) r (cons (first xs) r))))","problem":132,"user":"4fe8fda4e4b0547ebccb2438"},{"code":"(fn insert-if [p v c]\n  (if (empty? c) c (flatten (cons (first c) (map (fn [[x, y]] (if (p x y) [v y] [y])) (partition 2 1 c))))))","problem":132,"user":"52319066e4b0e2e8de81d1e9"},{"code":"(fn [p v xs]\n    (mapcat\n      (fn [a b]\n        (if (and a (p a b))\n          [v b]\n          [b]))\n      (cons nil xs)\n      xs))","problem":132,"user":"4dbad895535d1e037afb21ae"},{"code":"(fn [pred sep xs]\n  ((fn f\n     ([] (if (empty? xs) ()\n           (let [x0 (first xs)] (cons x0 (f (rest xs) x0)))))\n     ([xs prev]\n      (if (empty? xs) ()\n        (let [[x0 & xs'] xs]\n          (if (pred prev x0)\n            (into (lazy-seq (f xs' x0)) (list x0 sep))\n            (cons x0 (lazy-seq (f xs' x0))))))))))","problem":132,"user":"508157b2e4b0946d0443855c"},{"problem":132,"code":"(fn [pred v coll]\n  (if (empty? coll) \n    []\n    (concat [(first coll)]\n            (mapcat \n              #(if (pred %1 %2) [v %2] [%2]) \n              coll \n              (rest coll)))))","user":"54e345a1e4b024c67c0cf7db"},{"code":"(fn f [pred mark s]\n  (lazy-seq\n    (if (empty? (rest s)) s\n      (let [[x & xs] s]\n        (concat \n          (if (pred x (first xs)) [x mark] [x])\n          (f pred mark xs))))))","problem":132,"user":"50901b2ee4b0ea685a20f774"},{"code":"(fn f[p x [a b & s]]\n  (cond\n   (nil? a) []\n   (nil? b) [a]\n   :else\n   (lazy-cat\n     (if (p a b)\n       [a x] [a])\n     (f p x (concat [b] s)))))","problem":132,"user":"52f818a6e4b047fd55836fcc"},{"problem":132,"code":"(fn [pred value coll]\n    (let [inserta (fn [elem1 elem2] (if (and (not (nil? elem1))\n                                             (not (nil? elem2))\n                                             (pred elem1 elem2))\n                                      [elem1 value]\n                                      [elem1]))]\n       (mapcat #(inserta (first %) (second %)) (partition-all 2 1 coll))))","user":"5d0153f9e4b0cc9c915881aa"},{"problem":132,"code":"(fn g [f v s] (remove nil? (cons (first s) (apply concat (map (fn [[a b]] (if (f a b) [v b] [b])) (partition 2 1 s))))))","user":"54bd04e7e4b0ed20f4ff6ed8"},{"problem":132,"code":"(fn foo [p e l]\n    (if-not (second l)\n        l\n        (let [[x1 x2 & xs] l\n              l' (cons x2 xs)]\n            (if (p x1 x2)\n                (lazy-seq (cons x1 (cons e (foo p e (cons x2 xs)))))\n                (lazy-seq (cons x1 (foo p e (cons x2 xs))))))))","user":"600ae927e4b074f607df6689"},{"problem":132,"code":"(fn [p i c]\n  (let [pc\n        (map #(if (apply p %) i) (partition 2 1 c))]\n    (filter (complement nil?) (lazy-cat (interleave c (into pc nil)) [(last c)]))))","user":"574abbfbe4b02ea114799200"},{"code":"(fn [p k coll]\n  (when-let [[x & xs] (seq coll)]\n    (cons x (mapcat #(if (p % %2) [k %2] [%2]) coll xs))))","problem":132,"user":"4e8f1ac6535d65386fec2146"},{"problem":132,"code":"(fn ins [f v [h & t]]\n   (cond \n      (nil? h) []\n      (nil? t) [h]\n      :else (lazy-cat [h] (if (f h (first t)) [v]) (ins f v t))))","user":"59f043d0e4b0966464fe6a3d"},{"problem":132,"code":"(fn [pred tag coll]\n  (let [c (take 20 coll)]\n    (reduce\n     #(if (and (seq %) (pred (last %) %2))\n        (conj % tag %2)\n        (conj % %2))\n     [] c)))","user":"56d5fd24e4b0ea9b8538f7c5"},{"problem":132,"code":"(fn insert-between-two-items\n  [pred val sequ]\n  (mapcat (fn [boolval item]\n          (if boolval\n            (list val item)\n            (list item))) (cons false (map pred sequ (rest sequ))) sequ))","user":"506f0968e4b09350ab4199f5"},{"code":"(fn insert-between [pred v coll]\n  (lazy-seq\n   (let [s1 (seq coll)\n         f1 (first s1)\n         s2 (seq (next s1))\n         f2 (first s2)]\n     (cond\n      (and s1 s2 (pred f1 f2))\n      (cons f1 (cons v (insert-between pred v s2)))\n      \n      s1\n      (cons f1 (insert-between pred v s2))))))","problem":132,"user":"5326c5f7e4b09d4e7a9b54f2"},{"code":"(fn insert-between [pred? item coll]\n  (when-let [s (seq coll)]\n    (cons (first s)\n      (lazy-seq\n        (when-let [scd (second s)]\n          (if (pred? (first s) scd)\n            (cons item \n                  (insert-between pred? item (next s)))\n            (insert-between pred? item (next s))))))))","problem":132,"user":"51a97f7ae4b08d8ec191b827"},{"problem":132,"code":"(fn [p d l]\n  (mapcat (fn [[a b]] (if (and (not (nil? b)) (p a b)) (list a d) (list a)))\n          (partition-all 2 1 l)))","user":"586615e6e4b0f14aab7c8858"},{"code":"(fn interpose-when [pred v [head & tail :as xs]]\n  (cond\n    (empty? xs) '()\n    (empty? tail) xs\n    :else (lazy-seq\n      (if (pred head (first tail))\n        (cons head (cons v (interpose-when pred v tail)))\n        (cons head (interpose-when pred v tail))))))","problem":132,"user":"4e691c79535d8ccf87e9fe97"},{"problem":132,"code":"; \"Works\" except for fibonacci; numerical overflow\n;  (fn [f mark xs] (first (reduce\n;                    (fn [[accum last] next]\n;                      (if last\n;                        [(concat accum (if (f last next) (list mark next) (list next))) next]\n;                        [[next] next]))\n;                    [[] nil]\n;                    xs)))\n;\n; mine works, but is messy compared to _pcl's solution, which has a tricky bit at the end\n;(fn [f mark xs]\n;    (mapcat #(if (f %1 %2) [%1 mark] [%1]) xs (lazy-cat (rest xs) (take 1 xs))))\n\n(fn [f mark xs]\n  (if (seq xs) (cons (first xs) (mapcat #(if (f %1 %2) [mark %2] [%2]) xs (rest xs)))))","user":"5a544eeee4b05d388ecb6c24"},{"code":"(fn [p e s]\n  (mapcat drop-last (map (fn [[a b]] (if (and (not (= ::e b)) (p a b)) [a e b] [a b])) (partition 2 1 [::e] s))))","problem":132,"user":"4f1bb9d8535d64f60314647d"},{"problem":132,"code":"(fn [p v [a & s :as xs]]\n  (when a\n    (cons a\n          (mapcat #(if (p % %2) [v %2] [%2]) xs s))))","user":"543366dde4b0b6b47310fcdf"},{"problem":132,"code":"(fn [f v s]\n  (->> (concat (map (partial apply f) (partition 2 1 s)) [false])\n       (interleave s)\n       (replace {true v})\n       (remove false?)))","user":"5e6ca949e4b04a83ad7cd289"},{"code":"(fn g [p v c]\n  (lazy-seq\n    (when-let [f (first c)]\n      (let [s (second c)\n            t (g p v (rest c))]\n        (if s\n          (if (p f s)\n            (cons f (cons v t))\n            (cons f t))\n          [f])))))","problem":132,"user":"4daddc19c9a9d6ed4599dc57"},{"problem":132,"code":";(fn [p sep [x & xs :as all-xs]]\n;  (if (empty? all-xs) ()\n;    (reduce\n;      (fn [acc x]\n;        (if (p (peek acc) x)\n;          (conj acc sep x)\n;          (conj acc x)))\n;      [x]\n;      xs)))\n\n(fn ins-bet [p sep xs]\n  (if (empty? (rest xs)) xs\n    (let [[x1 x2] xs]\n      (cons x1\n            (lazy-seq\n              (if (p x1 x2)\n                (cons sep (ins-bet p sep (rest xs)))\n                (ins-bet p sep (rest xs))))))))","user":"562cd94ee4b0a45d2ff83015"},{"code":"(fn x [f i c]\n  (if (<= (count (take 2 c)) 1)\n    c\n    (let [a (first c)\n          r (rest c)\n          b (first r)]\n      (if (f a b)\n        (cons a (cons i (lazy-seq (x f i r))))\n        (cons a (lazy-seq (x f i r)))))))","problem":132,"user":"526439a4e4b03e8d9a4a70cc"},{"problem":132,"code":"(fn __ [pred v s]\n  (when (not (empty? s))\n    (lazy-seq\n      (let [s0 (first s) s1 (second s)]\n        (concat (if (and (not (nil? s1)) (pred s0 s1)) [s0 v] [s0])\n                (__ pred v (next s)))))))","user":"553abb28e4b09218d5f44ffb"},{"problem":132,"code":"(fn [p i coll]\n    (apply concat\n      (for [[x y] (partition 2 1 nil coll)]\n        (cond (nil? y) [x]\n              (p x y) [x i] \n              :else [x]))))","user":"52950ab6e4b02ebb4ef7501a"},{"problem":132,"code":"(fn [f i s]\n  (if (empty? s)\n    '()\n  \t(cons (first s) (mapcat (fn [[a b]] (if (f a b) [i b] [b])) (partition 2 1 s)))))","user":"536046a9e4b063bf7a5f8fe1"},{"problem":132,"code":"(fn [p v s]\n  (if (empty? s)\n    []\n    (flatten\n      (concat [(first s)] \n              (map #(if (apply p %)\n                        (vector v (second %))\n                        (second %))\n                   (partition 2 1 s))))))","user":"56d4b22de4b0ea9b8538f7bb"},{"code":"(fn [pred valu coll]\n  (if (empty? coll)\n    []\n    (mapcat (fn [pair]\n              (if (or (empty? (rest pair))\n                      (not (apply pred pair)))\n                [(first pair)]\n                [(first pair) valu]))\n            (partition-all 2 1 coll))))","problem":132,"user":"51789dfae4b03d69594194d7"},{"problem":132,"code":"(fn ins[pre val ss]\n              (let[f (first ss)\n                   r (next ss)\n                   s (first r)]\n                (if s\n                  (lazy-seq (cons f \n                        (if (pre f s) \n                          (cons val (ins pre val r)) \n                          (ins pre val r))))\n                ss)))","user":"5731e36be4b0cd1946bd0fc9"},{"problem":132,"code":"(fn ThisFunc\n    ([F What Where]\n      (let [\n          First (first Where)\n          Where (rest Where)\n        ]\n        (if (nil? First)\n          nil\n          (lazy-seq (cons First \n              (ThisFunc F What First (first Where) (rest Where) )\n            )\n          )\n        )\n      )\n    )\n    ([F What Prev First Where]\n      ;;(println \"2\" Prev First)\n      (if (nil? First)\n        nil\n        (if (F Prev First)\n          (lazy-seq (cons What (cons First (ThisFunc F What First (first Where) (rest Where)))))\n          (lazy-seq (cons First (ThisFunc F What First (first Where) (rest Where))))\n        )\n      )\n    )\n  )","user":"5d4a6c6ce4b0776584bd6f22"},{"problem":132,"code":"(fn insert [func tag coll]\n    (if (empty? coll)\n        coll\n        (let [[a b] coll]\n             (if b\n                 (lazy-cat \n                    (if (func a b) \n                        [a tag] \n                        [a])\n                      (insert func tag (drop 1 coll)))\n                  [a]))))","user":"568f2059e4b0dcc4269f40df"},{"problem":132,"code":"(fn insert [pred v [o & [t & _ :as more]]]\n  (if (seq more)\n    (lazy-cat (if (pred o t) [o v] [o]) (insert pred v more))\n    (and o [o])))","user":"58ffac9de4b0438e51c2cffd"},{"code":"#(for [[x y] (partition 2 1 (concat %3 [::t]))\n        z (cons x (when (and (not= ::t y) (%1 x y)) [%2]))]\n     z)","problem":132,"user":"4e7e6cbd535db169f9c79713"},{"code":"(fn insert-between [pred value coll]\r\n  (if (empty? (rest coll)) (apply list coll)\r\n    (let [tail (lazy-seq (insert-between pred value (rest coll)))]\r\n      (cons\r\n        (first coll)\r\n        (if (apply pred (take 2 coll)) (cons value tail) tail)))))","problem":132,"user":"4e994541535dbda64a6f6b64"},{"problem":132,"code":"(fn [pred? v coll]\n          (if (or (empty? coll) (empty? (rest coll)))\n            coll\n            (let [pairs (->> (partition 2 1 coll)\n                             (map (fn [[x y]] (if (pred? x y) [x v y] [x y]))))]\n              (->> (lazy-cat (first pairs) (map rest (rest pairs)))\n                   flatten))))","user":"53f592b7e4b0db01ade6f9d0"},{"code":"(fn interp [pred divider [i & [j & items :as coll] :as more]]\n  (if (seq coll)\n    (lazy-seq (concat (if (pred i j) [i divider] [i])\n                      (interp pred divider coll)))\n    (if (seq more) [i] [])))","problem":132,"user":"5102ac9de4b00c483ae176fa"},{"code":"(fn insert-if [pred item coll]\n  (lazy-seq (when-not (empty? coll)\n              (concat (if (and (= 2 (count (take 2 coll)))\n                               (apply pred (take 2 coll)))\n                        (list (first coll) item )\n                        (take 1 coll)) (insert-if pred item (rest coll))))))","problem":132,"user":"50a5b7e9e4b0aa96157e2610"},{"code":"#(mapcat (fn [[a b & _]] (if (and b (% a b)) [a %2] [a])) (partition-all 2 1 %3))","problem":132,"user":"51a10b2ce4b0b292b01ee3fe"},{"problem":132,"code":"(fn insert-between [pred v [i j :as coll]]\n  (lazy-seq\n    (when i\n      (if (and j (pred i j))\n        (cons i (cons v (insert-between pred v (rest coll))))\n        (cons i (insert-between pred v (rest coll)))))))","user":"5ba15075e4b0a20761a2339e"},{"problem":132,"code":"(fn insert-between-items [pred sep xs]\n  (let [col (partition-all 2 1 xs)]\n    ((fn step [items]\n       (lazy-seq\n        (when-not (empty? items)\n          (let [[prev cur] (first items)]\n            (if cur\n              (if (pred prev cur)\n                (cons prev (cons sep (step (rest items))))\n                (cons prev (step (rest items))))\n              (cons prev nil))))))\n     col)))","user":"57c500f9e4b05aa3c4741cda"},{"code":";; This one can be refactored a lot!\n  (fn i [p? v [x & xs]]\n    (if (seq xs)\n      (let [q (if (p? x (first xs))\n                [x v]\n                [x])]\n        (concat q (lazy-seq (i p? v xs))))\n      (if x (list x) ())))","problem":132,"user":"4db2f208535df7e46ed9b6c9"},{"code":"(fn [p v [a & b :as c]]\n  (if a (cons a (mapcat #(if (p % %2) [v %2] [%2]) c b)) []))","problem":132,"user":"528a3e14e4b0239c8a67ae72"},{"code":"(fn[p t s]\n  (flatten\n  (map (fn[v r] (if r [v t] v))  s\n       (concat (map #(apply p %) (partition 2 1 s)) [false])\n  )))","problem":132,"user":"507c7c8be4b0b083f3ff82ef"},{"code":"(fn insert-between [pred val coll]\n  (let [a (first coll)\n        b (fnext coll)\n        c (rest coll)]\n    (if (and a b)\n      (if (pred a b)\n        (concat (list a val) (lazy-seq (insert-between pred val c)))\n        (concat (list a) (lazy-seq (insert-between pred val c))))\n      coll)))","problem":132,"user":"4e7f51eb535db966e863cc3f"},{"code":"(fn i [c v [a b & r]]\n    (if a\n      `(~a ~@(if b `(~@(if (c a b) [v] nil) ~@(lazy-seq (i c v `(~b ~@r))))))\n      []))","problem":132,"user":"503b6995e4b07a1917cc34dd"},{"code":"(fn foo [f val coll]\n  (let [remaining (lazy-seq (foo f val (rest coll)))\n        act (first coll)\n        next (second coll)]\n    (cond \n      (empty? coll) nil\n      (and (second coll) (f act next)) (cons act (cons val remaining))\n      :else (cons act remaining))))","problem":132,"user":"5033a1fbe4b062bc5d7ae155"},{"code":"(fn insert-when [p v s]\n  (if (or (empty? s) (empty? (rest s))) s\n      (lazy-cat [(first s)]\n                (when (p (first s) (second s)) [v])\n                (insert-when p v (rest s)))))","problem":132,"user":"5310e7aee4b08068f379ecdc"},{"problem":132,"code":"(fn sandwich-V5 [f delim [x1 & xs]]\n  (when x1\n    (let [x2 (first xs)]\n      (lazy-seq\n       (cons x1 (if (and x2 (f x1 x2))\n                  (cons delim (sandwich-V5 f delim xs))\n                  (sandwich-V5 f delim xs)))))))","user":"5dc88a38e4b02f9375f4e1db"},{"code":"(fn aho [x y z]\n  (loop [data z res [] pos 0]\n    (if (= pos 20)\n  res \n    (if-not (fnext data)\n\t(if-not (> (count z) 0)\n\t  nil\n\t  (flatten (list res (first data))))\n\t(if (x (first data) (fnext data))\n\t  (recur (rest data) (flatten (list res (list (first data)) y)) (+ pos 1))\n\t  (recur (rest data) (flatten (list res (first data))) (+ pos 1)))))))","problem":132,"user":"4eb0afed535d7eef3080733e"},{"problem":132,"code":"(fn sl [pred value col]\n  (if (or (empty? col)\n          (empty? (rest col)))\n    col\n    (if (pred (first col)\n              (first (rest col)))\n      (lazy-seq (cons (first col)\n                      (cons value\n                            (sl pred value (rest col)))))\n      (lazy-seq (cons (first col)\n                      (sl pred value (rest col)))))))","user":"52e17e66e4b09f7907dd1423"},{"problem":132,"code":"(fn [p v c]\n  (flatten\n   (map-indexed (fn [i e]\n                  (if (and (not (nil? (nth c (inc i) nil))) (p e (nth c (inc i))))\n                    [e v]\n                    e\n                  ))\n                c)\n  )\n)","user":"59d75e36e4b0ef0a1e9b5c32"},{"problem":132,"code":"(fn [p in s]\n  (mapcat #(if (and (not= ::q (second %)) (apply p %))\n             [(first %) in]\n             [(first %)])\n          (partition 2 1 [::q] s)))","user":"53908e6be4b0b51d73faae9a"},{"problem":132,"code":"(fn [pred keyw coll]\n  (letfn [(insert [preVal remaining]\n                  (lazy-seq\n                   (if-let [curVal (first remaining)]\n                     (if (pred preVal curVal)\n                       (cons preVal (cons keyw (insert curVal (rest remaining))))\n                       (cons preVal (insert curVal (rest remaining))))\n                     (list preVal))))]\n   (if (empty? coll) coll\n     (insert (first coll) (rest coll)))))","user":"556c70dae4b09a3098a524fd"},{"problem":132,"code":"(fn insert\n  [p v [a ad & dd]]\n  (cond ad (lazy-cat [a] (when (p a ad) [v]) (insert p v (cons ad dd)))\n        a [a]\n        :else []))","user":"53e3f7a8e4b036ad0777e408"},{"code":"(fn insert-label [f lbl s] (remove  nil? (map #(if-not (seq? %) % (if (= (count %) 2) (if (apply f %) lbl))) (interleave s (partition 2 1 nil s)))))","problem":132,"user":"5138d08be4b0a5db03d727db"},{"problem":132,"code":"(fn lazy-insert-between\n  ([p v coll]\n     (if (empty? coll) [] (lazy-insert-between (first coll) p v (rest coll))))\n  ([prev p v coll]\n    (if (empty? coll) [prev]\n      (if (p prev (first coll))\n          (lazy-seq (cons prev (cons v \n             (lazy-insert-between (first coll) p v (rest coll)))))\n          (lazy-seq (cons prev \n             (lazy-insert-between (first coll) p v (rest coll))))))))","user":"58152157e4b0f478707a0631"},{"code":"(fn insert-between\n    [pred v coll]\n    (if (empty? coll) []\n        (lazy-seq\n         (cons (first coll)\n               (if (and (second coll) (pred (first coll) (second coll)))\n                 (cons v (insert-between pred v (rest coll)))\n                 (insert-between pred v (rest coll)))))))","problem":132,"user":"4f3ec266e4b0e243712b1f8c"},{"code":"(fn insert-btw-two [ pred symb coll ]\n        (letfn [ \n        (pred-fun [ e ] (if e (partial pred e) (fn [k] false)))\n        (rec-insert-btw-two [ pred-unary [x & xs] ]\n            (if (nil? x)\n                ()\n                (let [t (cons x (lazy-seq (rec-insert-btw-two (pred-fun x) xs)))]\n                (if (pred-unary x) (cons symb t) t))))\n            ]\n        (rec-insert-btw-two (pred-fun nil) coll)))","problem":132,"user":"51f59607e4b0abb92f97f9d5"},{"problem":132,"code":"(fn [p v [_ b :as s]]\n  (if (nil? b)\n    s\n    (->> (partition 2 1 s)\n         (mapcat (fn [[x y]] (if (p x y) (list v y) (list y))))\n         (cons (first s)))))","user":"53b952eee4b047364c0444e6"},{"code":"(fn [pred v coll]\n  (if (empty? coll) []\n    (cons (first coll)\n          (mapcat (comp rest #(if (apply pred %) (interpose v %) %))\n                  (partition 2 1 coll)))))","problem":132,"user":"5300158ae4b0d8b024fd370f"},{"problem":132,"code":"(fn p_132 [P v xs]\n (lazy-seq\n  (if-let [more (next xs)]\n    (let [[a b] xs]\n      (concat (if (P a b) [a v] [a])\n              (p_132 P v more)))\n    xs)))\n\n;(fn p_132 [P v xs]\n; (lazy-seq\n;  (if (next xs)\n;    (let [[a b] xs\n;          r (p_132 P v (next xs))]      \n;      (if (P a b)\n;        (cons a (cons v r)) ; (concat [a v] r)\n;;        (conj r v a)\n;        (cons a r)\n;;        (conj r a)        \n;        ))\n;    xs)))\n\n; \"cons/cons\" : ok\n; \"cons/conj\" : ok\n; \"conj/cons\" : ok\n; \"conj/conj\" : => java.lang.ArithmeticException: integer overflow\n\n; (defn F [] (lazy-seq (cons 0 (F))))\n; (defn F [] (lazy-seq (conj (F) 0)))","user":"567b39b6e4b05957ce8c61a3"},{"problem":132,"code":"(fn [pred item sqs]\n  (if (empty? sqs)\n    '()\n    (cons\n     (first sqs)\n     (->> (partition 2 1 sqs)\n          (mapcat (fn [[fst snd]]\n                 (if (pred fst snd)\n                   [item snd]\n                   [snd])))))))","user":"534941d1e4b084c2834f4a60"},{"code":"(fn [p x s]\n  (if (empty? s) \n    s\n    (lazy-cat (mapcat #(if (p % %2) [% x] [%]) s (rest s)) [(last s)])))","problem":132,"user":"5054bc87e4b0b1b9d1860eb0"},{"problem":132,"code":"(fn insert-between [pred v xs]\n  (lazy-seq\n    (if (empty? xs) \n      '()\n      (cons (first xs)\n            (cond \n              (empty? (rest xs)) \n                '()\n              (pred (first xs) (first (rest xs)))\n                (cons v (insert-between pred v (rest xs)))\n              :else\n                (insert-between pred v (rest xs)))))))","user":"4ff769bce4b0678c553fc38f"},{"problem":132,"code":"#(mapcat (fn [[a b]](if (and b (% a b))[a %2] [a])) (partition-all 2 1 %3))","user":"57e33f6fe4b0bfb2137f5a96"},{"problem":132,"code":"; From mfikes\n(fn append [pred word [x1 x2 :as coll]]\n  (lazy-seq\n    (when x1\n      (if (and x2 (pred x1 x2))\n        (cons x1 (cons word (append pred word (rest coll))))\n        (cons x1 (append pred word (rest coll)))))))","user":"56c4f43ce4b05cc29241ee9c"},{"problem":132,"code":"(fn tween[predicate value collection]\n  (let [first-operands (drop-last collection)\n        second-operands (rest collection)\n        results (concat (map #(when (predicate %1 %2) value) first-operands second-operands) '(false))]\n    (filter identity (interleave collection results))))","user":"5980f91ae4b021a7a535fddd"},{"problem":132,"code":"(fn [f m st]\n ( mapcat identity (map-indexed (fn [i t] (if (not= (nth st (inc i) \"nothing found\") \"nothing found\") (if (f t (nth st (inc i))) [t m] [t]) [t])) st)))","user":"581a5fdbe4b0e114eb51a002"},{"problem":132,"code":"(fn insert-between [pred value coll]\n  (lazy-seq\n    (when (not-empty coll)\n      (cons (first coll)\n            (if (second coll)\n              (if (pred (first coll) (second coll))\n                (cons value (insert-between pred value (rest coll)))\n                (insert-between pred value (rest coll)))\n              [])))))","user":"53fe1b42e4b0de5c418485f1"},{"code":"(fn __ [f i c]\n  (when (seq c)\n    (cons (first c)\n          (flatten\n           (map (fn [[x y]] (if (f x y) [i y] [y]))\n                (partition 2 1 c))))))","problem":132,"user":"4db4714f535dc0f10411755a"},{"code":"(fn [p v col]\n  (if (empty? col) col\n    (letfn [(f [prev [h & t]]\n               (lazy-seq\n                 (cond \n                       (nil? h) [prev]\n                       (nil? prev) (f h t)\n                       (p prev h) (cons prev (cons v (f h t)))\n                       :else (cons prev (f h t)))))]\n      (f nil col))))","problem":132,"user":"4f4c6b21e4b03ad3f0c10c8f"},{"problem":132,"code":"(fn insert-between-lazy [f v s]\n  (letfn [(aux [l s]\n            (if (empty? s)\n              '()\n              (if (f l (first s))\n                (lazy-seq (cons v (cons (first s) (aux (first s) (rest s)))))\n                (lazy-seq (cons (first s) (aux (first s) (rest s)))))))]\n    (if (empty? s)\n      '()\n      (cons (first s) (aux (first s) (rest s))))))","user":"5f8b06afe4b0715f5002d74a"},{"problem":132,"code":"(fn f [p s [x & xs]]\n  (when x\n    (lazy-seq\n     (cons x\n          (when xs\n            (if (p x (first xs))\n              (cons s (f p s xs))\n              (f p s xs)))))))","user":"5af8221ce4b0cc2b61a3bccd"},{"code":"(fn ibti [p v c]\n  (if (empty? c)\n    '()\n    (\n     (fn lazy-ibti [f c1]\n       (lazy-seq\n         (cons\n           f\n           (when-not (empty? c1)\n             (cond \n               (= v f) (lazy-ibti (first c1) (rest c1)) \n               (p f (first c1)) (lazy-ibti v c1)\n               (not (p f (first c1))) (lazy-ibti (first c1) (rest c1)))\n             )))) \n     (first c) (rest c))\n    ))","problem":132,"user":"52cf084ce4b07d0d72b27399"},{"code":"(fn [p v coll]\n  (if (empty? coll)\n    []\n    (letfn [(r' [p v coll prev]\n              (if-not (seq coll)\n              []\n              (let [fst (first coll)\n                    hit? (p prev fst)]\n                (if hit?\n                  (cons v (cons fst (lazy-seq (r' p v (rest coll) fst))))\n                  (cons fst (lazy-seq (r' p v (rest coll) fst)))))))]\n      (cons (first coll) (r' p v (rest coll) (first coll))))))","problem":132,"user":"51195e77e4b055cfb310d499"},{"problem":132,"code":"(fn insert-btw-two \n  ([pred ins] [])\n  ([pred ins [x & xs]] (if (nil? x) []\n                         (cons x (lazy-seq (insert-btw-two pred ins x xs)))))\n  ([pred ins px [x & xs]] (cond (nil? x) nil\n                                (pred px x) (cons ins (cons x (lazy-seq (insert-btw-two pred ins x xs))))\n                                :else (cons x (lazy-seq (insert-btw-two pred ins x xs)))))\n  )","user":"54bbaa8ee4b0ed20f4ff6ec0"},{"problem":132,"code":"(fn f [pred v coll] \n   (lazy-seq \n    (cond \n     (empty? coll) ()\n     (nil? (second coll)) coll\n     (pred (first coll) (second coll)) \n       (cons (first coll) (cons v (f pred v (drop 1 coll))))\n     :else (cons (first coll) \n                 (f pred v (drop 1 coll))))))","user":"53da8fede4b0e771c30254a3"},{"problem":132,"code":"(fn [f v xs]\n  (->> (partition 2 1 xs)\n       (mapcat (fn [[a b]] (if (f a b) [v b] [b])))\n       (cons (first xs))\n       (if (empty? xs) ())))","user":"583e27e2e4b089d5ab817daa"},{"code":"(fn weave [p i [a b & t]]\n  (cond\n   (nil? a) []\n   (nil? b) [a]\n   (p a b)  (cons a (cons i (lazy-seq (weave p i (cons b t)))))\n   :else    (cons a         (lazy-seq (weave p i (cons b t))))))","problem":132,"user":"52d2ca1ce4b099d49816f0b4"},{"code":"(fn g [f sym [a b & rt :as all]]\n  (if (and a b)\n    (lazy-cat (if (f a b) [a sym] [a]) \n              (g f sym (concat [b] rt)))\n    all))","problem":132,"user":"51944aaae4b0142f60b4aedc"},{"code":"#(flatten\n  (map (fn [[a b]]\n         (if (and b (% a b))\n           [a %2]\n           [a]))\n       (partition-all 2 1 %3)))","problem":132,"user":"4ebaf790535dfed6da9c6d6e"},{"problem":132,"code":"(fn [p v coll]\n         (letfn [(aux [prev coll]\n                   (lazy-seq\n                    (when-let [x (first coll)]\n                      (if (and (not (nil? prev)) (p prev x)) \n                        (cons v (cons x (aux x (rest coll))))\n                        (cons x (aux x (rest coll)))))))]\n\n           (aux nil coll)))","user":"57e6f90de4b0bfb2137f5af6"},{"code":"(fn insert-between [p v s]\n  (if (seq (rest  s))\n      (let [a (first s) b (second s) ]\n         (lazy-seq (if (p a b)\n             (cons a (cons v (insert-between p v (rest s))))\n             (cons a (insert-between p v (rest s))))))\n\n      s))","problem":132,"user":"4f9120d8e4b0dcca54ed6c96"},{"problem":132,"code":"(letfn [(step [pred v coll lv]\n            (cons lv (when (seq coll)\n                       (let [nv (first coll)]\n                         (lazy-cat\n                           (if (pred lv nv) [v] [])\n                           (step pred v (rest coll) nv))))))]\n    (fn [pred v coll]\n      (if (seq coll)\n        (step pred v (drop 1 coll) (first coll))\n        '())))","user":"4ff3df0fe4b0678c553fc355"},{"problem":132,"code":"(fn [p v [h & t :as xs]]\n  (when h\n    (cons h \n          (mapcat \n           (fn [[x y]] (if (p x y) [v y] [y]))\n           (partition 2 1 xs)))))","user":"548b8a50e4b0e286459a11ff"},{"code":"(fn insert-when [pred value coll]\n  (lazy-seq\n    (cond\n      (not (second coll))\n        coll\n      (pred (first coll) (second coll))\n        (cons (first coll) (cons value (insert-when pred value (rest coll))))\n      :else\n        (cons (first coll)             (insert-when pred value (rest coll))))))","problem":132,"user":"4e7263a1535d5021c1a8965f"},{"problem":132,"code":"(fn insert-between [f value coll]\n     (mapcat\n       (fn [[a b]]\n         (if (and a b (f a b))\n           (list a value)\n           (list a)))\n       (partition-all 2 1 coll)))","user":"58dcb8cde4b0a4d5acaab6a7"},{"problem":132,"code":"(fn intersperse-sometimes [p v coll]\n  (mapcat (fn [[a b]]\n            (if (and a b (p a b))\n              (list a v)\n              (list a)))\n          (partition-all 2 1 coll)))","user":"601aaa93e4b0bf4ca6b10926"},{"code":"(fn [p n [f & r :as s]]\n  (when (seq s)\n    (concat [f] (mapcat #(if (p % %2) [n %2] [%2]) s r))))","problem":132,"user":"512eb723e4b0b740abc5982b"},{"code":"(fn a [f v col] (if(empty? col)(identity [])(if(nil? (second col))(identity col)(lazy-cat (if(f (first col)(second col))(list (first col) v)(list (first col)))(lazy-seq(a f v (next col)))))))\n;(fn a [f v col] (filter #(not(nil? %))(flatten (concat (map #(if(f %1 %2)(list %1 v)(identity %1)) col (next col)) (list(last col))))))","problem":132,"user":"527a8eb7e4b03e8d9a4a755f"},{"problem":132,"code":"(fn [p v col] \n  (->> col\n       (partition 2 1 '(:end))\n       (map (fn [[x y]] \n              (cond \n               (= :end y) [x] \n               (p x y) [x v] \n               :else [x])))\n       (flatten)\n   ))","user":"575ef4b6e4b08062f99a4e78"},{"code":"(fn [p e [f & n :as c]]\n   (if f\n     `(~f ~@(mapcat #(if (p % %2) [e %2] [%2]) c n))\n     '()))","problem":132,"user":"4e65027c535d8ccf87e9fe6e"},{"code":"#(mapcat\n  (fn [[a b]] (cond (nil? b) [a] \n                    (%1 a b) [a %2] \n                    :else [a]))\n  (partition-all 2 1 %3))","problem":132,"user":"4fb1d907e4b081705acca282"},{"problem":132,"code":"(fn f132 [f v c]\n  (if (empty? c)\n    c\n    (cons (first c)\n          (if-not (nil? (second c))\n            (lazy-seq\n             (if (f (first c) (second c))\n               (cons v (f132 f v (rest c)))\n               (f132 f v (rest c))))\n            '()))))","user":"54cad59ee4b057c6fda3a26e"},{"problem":132,"code":"(fn f [pred? v col]\n  (cond\n   (empty? col) col\n\n   (empty? (rest col)) [(first col)]\n\n   (pred? (first col) (second col))\n   (concat [(first col)\n           v]\n           (lazy-seq (f pred? v (rest col))))\n   :else (concat [(first col)] (lazy-seq (f pred? v (rest col))))))","user":"541709b0e4b01498b1a71a06"},{"code":"(fn aa [x y z]\n    (lazy-seq \n       (let [[a b _] z\n          yy (aa x y (rest z))\n          ]\n      (if b \n        (cons a\n              (if (x a b) (cons y yy) yy))\n          z\n              \n              )\n        )\n      ))","problem":132,"user":"5105ed16e4b01150e115ebe2"},{"problem":132,"code":"(fn insert-bet-item1\n  [pred val [x & more :as coll]]\n  (when (seq coll)\n    (if (seq more)\n      (if (pred x (first more))\n        (lazy-seq (cons x (cons val (insert-bet-item1 pred val more))))\n        (lazy-seq (cons x (insert-bet-item1 pred val more))))\n      [x])))","user":"557e9d17e4b05c286339e0d8"},{"problem":132,"code":"(fn [f v coll]\n  (mapcat (fn ([[l r]] (if r (if (f l r) [l v] [l]) [l]))) (partition-all 2 1 coll)))","user":"604d3cb1e4b0b7ec0ac60ac2"},{"code":"(fn f [pred val [x y & zs :as coll]]\n    (if y\n      (if (pred x y)\n        (lazy-cat [x val] (f pred val (cons y zs)))\n        (lazy-cat [x] (f pred val (cons y zs))))\n      coll))","problem":132,"user":"4ebcb8ff535dfed6da9c6d8a"},{"code":"(fn f [p i [a & b]] \n  (if (nil? a) \n    []\n    (lazy-seq\n      (cons a\n        (if (and b (p a (first b)))\n          (cons i (f p i b))\n                  (f p i b))))))","problem":132,"user":"4f991ec1e4b0dcca54ed6cfb"},{"code":"(fn [p v s]\n (mapcat (fn [[e1 e2]] (if (and (not (nil? e2)) (p e1 e2)) [e1 v] [e1]))\n         (partition-all 2 1 s)))","problem":132,"user":"4fa0a4b1e4b0dcca54ed6d4f"},{"code":"(fn ibti [p sy s]\n  (cond (empty? s) '()\n    (empty? (next s)) s\n    :else (let [[x & xs] s]\n      (lazy-seq (cons x (if (p x (first xs)) \n                          (cons sy (ibti p sy xs))\n                          (ibti p sy xs)))))))","problem":132,"user":"5063fe48e4b075d771da6f9e"},{"problem":132,"code":"(fn [p n c]\n  (let [x #(if (and %2 (p % %2)) (list % n) (list %))]\n    (apply concat (map x c (concat (next c) '(nil))))))","user":"5a085dfde4b01bb0ae8afdf4"},{"problem":132,"code":"(fn [p v lst]\n  (if (empty? lst) lst\n    (letfn [(impl [x xs]\n                  (cond (empty? xs) xs\n                        (p x (first xs)) (lazy-cat [v (first xs)] (impl (first xs) (rest xs)))\n                        :else (lazy-cat [(first xs)] (impl (first xs) (rest xs)))))]\n      (cons (first lst) (impl (first lst) (rest lst))))))","user":"55c20bd0e4b0e31453f64972"},{"code":"(fn between [f v coll]\n  (if (empty? coll) coll\n    (let [b_ (fn b_ [f v p c]\n               (cond\n                 (empty? c) nil\n                 (f p (first c)) (lazy-seq (cons v (cons (first c) (b_ f v (first c) (rest c)))))\n                 :else (lazy-seq (cons (first c) (b_ f v (first c) (rest c))))))]\n      (cons (first coll) (b_ f v (first coll) (rest coll))))))","problem":132,"user":"4f50c414e4b03ad3f0c10d0d"},{"problem":132,"code":"(fn insert* [pred sep coll]\n  (if (empty? coll)\n    '()\n    (lazy-seq (let [[a b] (take 2 coll)]\n                (cons a (if (and (not-any? nil? [a b]) (pred a b))\n                          (cons sep (insert* pred sep (rest coll)))\n                          (insert* pred sep (rest coll))))))))","user":"53528cd3e4b084c2834f4af2"},{"problem":132,"code":"(fn [p v xs]\n    (let\n      [\n        do-insert-between\n        (fn do-insert-between [xs]\n          (if (empty? xs)\n            []\n            (let\n              [\n                x (first xs)\n                y (second xs)\n                xs' (rest xs)\n                end? (nil? y)\n                match?\n                (if end?\n                  false\n                  (p x y)\n                )\n              ]\n              (if match?\n                (lazy-seq\n                  (cons\n                    x\n                    (cons\n                      v\n                      (do-insert-between xs')\n                    )\n                  )\n                )\n                (lazy-seq\n                  (cons\n                    x\n                    (do-insert-between xs')\n                  )\n                )\n              )\n            )\n          )\n        )\n      ]\n\n      (do-insert-between xs)\n    )\n  )","user":"5784e177e4b0ebec4cfb74cf"},{"code":"(fn insert-between \n  ([f v coll] \n    (when (seq coll)\n      (insert-between f v (first coll) (rest coll))))\n  ([f v n coll]\n  (if (seq coll)\n    (if (f n (first coll))\n      (cons n (cons v (lazy-seq (insert-between f v (first coll) (rest coll)))))\n      (cons n (lazy-seq (insert-between f v (first coll) (rest coll)))))\n    (cons n coll))))","problem":132,"user":"501c1492e4b086d93747d180"},{"problem":132,"code":"(fn [p s xs]\n    (letfn [(ib [p s [x y & xs :as all] acc]\n              (lazy-seq\n               (cond\n                 (nil? (seq all)) acc\n                 (nil? y) (list x)\n                 (p x y) (cons x (cons s (ib p s (cons y xs) acc)))\n                 :else (cons x (ib p s (cons y xs) acc)))))]\n      (ib p s xs [])))","user":"560e9a2de4b05f002753df52"},{"problem":132,"code":"(fn prob132 [pred val [a b & _ :as s]]\n  (lazy-seq\n        (when-not (empty? s)\n          (if (and b (pred a b))\n            (cons a (cons val (prob132 pred val (rest s))))\n            (cons a (prob132 pred val (rest s)))\n            ))))","user":"4ebbff41535dfed6da9c6d78"},{"problem":132,"code":"(fn binary_insertion_predicate [bin_pred value coll] {:pre (every? true? [(fn? bin_pred) (sequential? coll)])}\n    (lazy-seq\n        (if (empty? coll)\n            coll\n            (let\n                [\n                    [a b] (take 2 coll)\n                ]\n                (cond\n                    (empty? (drop 1 coll)) (cons a (binary_insertion_predicate bin_pred value (rest coll)))\n                    (bin_pred a b) (cons a (cons value (binary_insertion_predicate bin_pred value (rest coll))))\n                    :otherwise (cons a (binary_insertion_predicate bin_pred value (rest coll)))\n                )\n            )\n        )\n    )\n)","user":"5db7376fe4b010eb3c36cd43"},{"code":"(fn f [p k s]\n  (if (not (empty? s))\n    (if (empty? (rest s))\n      s\n      (lazy-cat\n       [(first s)]\n       (if (p (first s) (second s)) [k])\n       (f p k (rest s))))))","problem":132,"user":"509160dae4b0742c82730aef"},{"code":"(fn insert-between- [f v coll]\n  ^{:doc \"132. Write a function that takes a two-argument predicate, a                                                                                                                                             \n    value, and a collection; and returns a new collection where the                                                                                                                                                \n    value is inserted between every two items that satisfy the                                                                                                                                                     \n    predicate.\"}\n  (->> coll\n       (partition-all 2 1)\n       (map (fn [[x y :as xs]] (if (and (= (count xs) 2) (f x y)) [x v] [x])))\n       flatten))","problem":132,"user":"4e5eb843535d8a8b8723a2d4"},{"problem":132,"code":"(fn [f k [x & xs]] (if x (apply concat (reductions #(if (f (last %) %2) [k %2] [%2]) [x] xs)) []))","user":"5c379636e4b0d62ef62d9f76"},{"code":"(fn rec [p v ns]\n       (let [[a b] (take 2 ns)]\n         (cond\n          (and a b) (if (p a b)\n                      (lazy-seq (cons a (cons v (rec p v (rest ns)))))\n                      (lazy-seq (cons a (rec p v (rest ns)))))\n          a [a]\n          :else [])))","problem":132,"user":"4ee82223535d93acb0a66877"},{"code":"(fn [pred value coll]\n  (if (empty? coll) []\n    (->> (partition 2 (interleave coll (rest coll)))\n       (mapcat (fn [[a b]] (if (pred a b) [value b] [b])))\n       (cons (first coll)))))","problem":132,"user":"5201ada5e4b0b2e020a18f14"},{"code":"(fn _ [p v [h & t]]\n  (if (nil? h)\n    []\n    (cons h\n          (lazy-seq (when t\n                      (let [nxt (_ p v t)]\n\t                (if (p h (first t))\n\t                  (cons v nxt)\n                          nxt)))))))","problem":132,"user":"51b9d1f0e4b0e871ca49590b"},{"problem":132,"code":"(fn insert-between [pred x coll]\n  (mapcat (fn [[a b :as xs]]\n            (cond (= b :end) [a]\n                  (pred a b) [a x]\n                  :else [a]))\n          (partition 2 1 (concat coll (list :end)))))","user":"571c2babe4b07c98581c3b73"},{"problem":132,"code":"(fn f [p v c] \n  (if (empty? c)\n    nil\n    (if (empty? (next c))\n      c\n      (if (p (first c) (second c))\n        (lazy-seq (cons (first c) (cons v (f p v (next c)))))\n        (lazy-seq (cons (first c) (f p v (next c))))))))","user":"54908cc1e4b0b312c081ff32"},{"problem":132,"code":"(fn [p v c]\n  (let [[x & y] (map (fn [[a b]]\n                       (if (p a b)\n                         `(~a ~v ~b)\n                         `(~a ~b)))\n                     (partition 2 1 c))]\n    (if y\n      `(~@x ~@(mapcat #(drop 1 %) y))\n      c)))","user":"54acf5c7e4b09f271ff37cdd"},{"code":"(fn f [pred item coll]\n  (letfn [(tf [c]\n            (if (empty? c)\n              nil\n              (if (and (not (empty? (rest c))) (pred (first c) (second c)))\n                (lazy-seq (cons (first c) (cons item (tf (rest c)))))\n                (lazy-seq (cons (first c) (tf (rest c)))))))]\n    (tf coll)))","problem":132,"user":"518ccf6be4b05e6c8537e386"},{"code":"(fn [p i l]\r\n  (if (empty? l) nil\r\n      (lazy-cat (mapcat (fn [a b] (if (p a b) [a i] [a])) l (rest l)) [(last l)])))","problem":132,"user":"507437c2e4b054001656acd0"},{"code":"(fn [f tag s ]\n  (if (seq s)\n      (cons (first s)\n            (mapcat rest\n                    (for [[a b] (partition 2 1 s)]\n                       (if (f a b)\n                           [a tag b]\n                           [a b]))))))","problem":132,"user":"4e860e85535db62dc21a62f1"},{"problem":132,"code":"(fn [p v c]\n\t(->>\n\t\tc\n\t\t(partition-all 2 1)\n\t\t(mapcat (fn [[a b]] (if (and b (p a b)) [a v] [a])))\n\t)\n)","user":"580c8fcee4b0849f6811b721"},{"problem":132,"code":"(fn [pred val coll]\n    (->> (partition 2 1 coll)\n         (mapcat (fn [[x y]] (if (pred x y) [val y] [y])))\n         (cons (first coll))\n         (filter (complement nil?))\n         ))","user":"55c5b55fe4b0e31453f649b5"},{"code":"(fn i [p x [a b :as s]]\n  (if (nil? a)\n    nil\n    (lazy-seq\n     (if (nil? b)\n       [a]\n       (concat (if (p a b)\n                 [a x]\n                 [a])\n               (i p x (rest s)))))))","problem":132,"user":"4e5fe31a535d8ccf87e9fe50"},{"code":"(fn f [predicate item s]\n  (let [a (first s)\n          b (second s)]\n    (cond\n      (every? nil? [a b]) []\n      (nil? b) s\n      :else\n    (let [condition (predicate a b)]\n      (concat (if condition\n              [a item]\n              [a])\n              (lazy-seq (f predicate item (rest s))))))))","problem":132,"user":"51899891e4b0288ada3dbdab"},{"code":"(fn [p v c]\n (filter #(not= nil %) (lazy-cat (mapcat #(if (p % %2) [% v] [%]) c (rest c)) [(last c)])))","problem":132,"user":"4dae4da5c9a9d6ed4e99dc57"},{"code":"(fn [p v s]\n  (if (seq s)\n    (cons (first s)\n          (apply concat\n                 (map #(if (p %1 %2) [v %2] [%2])\n                      s (rest s))))))","problem":132,"user":"5175533fe4b0dea9bbfba575"},{"problem":132,"code":"(fn [p k v]\n  ((fn it [[x y & z]]\n     (if y\n       (lazy-seq\n        (cons x (if (p x y)\n                  (cons k (it (cons y z)))\n                  (it (cons y z)))))\n       (if x [x] []))) v))","user":"5504dd64e4b086ebe8a79c83"},{"code":"(fn i [p v c]\n  (let [a (first c) b (second c)]\n    (if (nil? b)\n      c\n      (let [r (lazy-seq (i p v (drop 1 c)))]\n        (if (p a b)\n          (cons a (cons v r))\n          (cons a r))))))","problem":132,"user":"50bce014e4b0594b91591c63"},{"problem":132,"code":"(fn insert-between\n  [p v xs]\n  (concat (take 1 xs)\n          (mapcat (fn [x y] (if (p x y) [v y] [y]))\n                  xs\n                  (rest xs))))","user":"4fcf1755e4b03432b189f40c"},{"problem":132,"code":"(fn [f c xs] (if-let [h1 (first xs)] (cons h1 ((fn a [xs] (lazy-seq (if-let [o (second xs)] (let [res (next xs) h (first xs) r (if (f h o) [c o] [o])]  (concat r (a res)))))) xs))))","user":"5507cfd3e4b021ccfedb96ad"},{"problem":132,"code":"(fn insert [p x c]\n  (let [step\n        (fn [p x c]\n          (if (second c)\n            (if (p (first c) (second c))\n              (concat (list (first c) x) (insert p x (rest c)))\n              (cons (first c) (insert p x (rest c))))\n            c))]\n    (lazy-seq (step p x c))))","user":"5953bdb6e4b066ee0a44aeed"},{"problem":132,"code":"(fn insert-between\n  [pred item coll]\n  (if (< 1 (count (take 2 coll)))\n    (let [frst (first coll)\n          scnd (second coll)]\n      (if (pred frst scnd)\n        (cons frst (cons item (lazy-seq (insert-between pred item (rest coll)))))\n        (cons frst (lazy-seq (insert-between pred item (rest coll))))))\n    coll))","user":"51c8f1d8e4b07ef393169e5d"},{"code":"(fn [pred in coll]\n  (if (next coll)\n    (->> coll\n         (partition 2 1)\n         (mapcat (comp next #(if (apply pred %) (interpose in %) %)))\n         (cons (first coll)))\n    coll))","problem":132,"user":"516ab8c2e4b081287f204e9e"},{"code":"(fn [p e s]\n  (let [results (->> (partition 2 1 s)\n                     (map (fn [[i1 i2]]\n                            (if (p i1 i2)\n                              [i1 e i2]\n                              [i1 i2]))))]\n    (if (not (empty? s))\n      (cons \n       (first s)\n       (mapcat rest results)))))","problem":132,"user":"536f871de4b0fc7073fd6e7f"},{"problem":132,"code":"(fn [p v coll]                                                                                                                                                                                                                                                 \n  (let [parts (partition 2 1 coll)                                                                                                                                                                                                                             \n        els (interleave (conj (map #(apply p %) parts) false)                                                                                                                                                                                                  \n                        coll)]                                                                                                                                                                                                                                 \n    (keep #(when % (if (= true %) v %)) els)))","user":"541d3c0fe4b01498b1a71a7e"},{"problem":132,"code":"(fn [f t s]\n\n    (if (seq s) (cons  (first s)   (mapcat (fn [a b] (if (f a b) [t b] [b] ))   s (next s))))\n    )","user":"55be39f9e4b01b9910ae2a06"},{"code":"(fn l-ins [f v [a b & m :as c]]\n  (if (empty? c) []\n      (if ( nil? b) [a]\n          (when-let [ x (if (f a b) [a v] [a]) ]\n            (lazy-seq (concat x (l-ins f v (next c))))))))","problem":132,"user":"4eb8ec4a535dfed6da9c6d4b"},{"code":"(fn bet2 [p v c]\n  (if (empty? c) c\n    (cons (first c)\n      (lazy-seq\n        (cond \n          (not (seq c)) c\n          (not (next c)) nil\n          :else\n            (if (p (first c) (second c))\n              (cons v (bet2 p v (rest c)))\n              (bet2 p v (rest c)))))))\n  )","problem":132,"user":"52ffb7f2e4b0d8b024fd370b"},{"problem":132,"code":"(fn insert-between\n  [pred v s]\n  (let [subseqs (->> s\n                     (partition 2 1)\n                     (mapcat (fn [[x1 x2]] (if (pred x1 x2)\n                                             [v x2]\n                                             [x2]))))]\n    (if (empty? subseqs)\n      s\n      (conj subseqs (first s)))))","user":"5b602a66e4b0c6492753e6fc"},{"code":"(fn [pred v coll]\n  (filter identity (interleave (cons nil (map #(if (pred %1 %2) v nil) coll (rest coll))) coll)))","problem":132,"user":"510db6cde4b078ea71921145"},{"code":"(fn i [f v c]\n  (if (or (empty? c) (empty? (rest c)))\n    c\n    (if (f (first c) (nth c 1))\n      (list* (first c) v (lazy-seq (i f v (rest c))))\n      (cons (first c) (lazy-seq (i f v (rest c)))))))","problem":132,"user":"52379c46e4b0fae3832e99db"},{"problem":132,"code":"(fn insert-to [op key coll]\n  (if (empty? coll)\n    coll\n    (lazy-seq\n      (let [n1 (first coll),\n            r (rest coll)]\n        (if (empty? r)\n          coll\n          (let [n2 (first r)]\n            (if (op n1 n2)\n              (cons n1 (cons key (insert-to op key r)))\n              (cons n1 (insert-to op key r))\n              )\n            )\n          ))\n      )\n    ))","user":"53ca41dae4b00fb29b2212c8"},{"problem":132,"code":"(fn [p v col]\n (->> (partition-all 2 1 col)\n  (mapcat (fn [[a b]] (if (and b (p a b)) [a v] [a])))))","user":"5b0180cfe4b0cc2b61a3bd47"},{"problem":132,"code":"(fn between [p x coll]\n  (->> coll\n       (partition 2 1)\n       (mapcat (fn [[a b]]\n                 (if (p a b)\n                   [x b]\n                   [b])))\n       (concat (take 1 coll))))","user":"5ca14eb1e4b048ec896c5b7d"},{"problem":132,"code":"#(let [v (take 10 %3)\n       o first]\n  (if (>= 1 (count v)) v\n     (loop [r [(o v)]\n            f (drop-last v)\n            l (rest v)]\n       (if (= 0 (count f)) r\n      \t(recur\n         (if (% (o f) (o l)) (concat r [%2 (o l)]) (concat r [(o l)]))\n         (rest f) (rest l))))))","user":"53973e7be4b0b51d73faaee6"},{"problem":132,"code":"(fn __ [op lbl s] (if (< (count (take 2 s)) 2) s (if (op (first s) (second s)) (cons (first s) (cons lbl (lazy-seq (__ op lbl (rest s))))) (cons (first s) (lazy-seq (__ op lbl (rest s)))))))","user":"56979bb7e4b0e0b3d3318cac"},{"problem":132,"code":"(fn between [pred i xs]\n  (let [x (first xs)\n        xs (rest xs)]\n    (cond\n      (empty? xs)  (if (nil? x) nil (cons x nil))\n      (pred x (first xs)) (->> (lazy-seq (between pred i xs))\n                               (cons i)\n                               (cons x))\n      :else (->> (lazy-seq (between pred i xs))\n                 (cons x)))))","user":"5283a919e4b0239c8a67adbe"},{"code":"(fn lazy-insert [f less xs]\n  (lazy-seq\n   (if (empty? xs)\n     ()\n     (let [[x y & x-more] xs]\n       (cond\n        (nil? y) (list x)\n        (f x y) (list* x less (lazy-insert f less (rest xs)))\n        :else (cons x (lazy-insert f less (rest xs))))))))","problem":132,"user":"4dd62278535d2dad7130b5c7"},{"problem":132,"code":"(fn insert\n  [pred value [head & tail :as coll]]\n  (if (seq coll)\n    (cons head (lazy-seq (if (and (seq tail) (pred head (first tail)))\n                           (cons value (insert pred value tail))\n                           (insert pred value tail))))\n    coll))","user":"50310713e4b05b7df5a0b84c"},{"problem":132,"code":"(fn [pred val seq]\n    (mapcat (fn [[e1 e2]]\n              (if (and e2 (pred e1 e2))\n                [e1 val]\n                [e1]))\n            (partition-all 2 1 seq)))","user":"5f0aa72de4b09a3f05b71808"},{"code":"(fn intercalate \n  [pred value col]\n  (letfn [(looper [s head]\n            (lazy-seq \n             (if-let [sec (first s)]\n               (if (pred head sec)\n                 (cons head (cons value (looper (rest s) sec)))\n                 (cons head (looper (rest s) sec)))\n               (if head [head] []))))]\n    (looper (rest col) (first col))))","problem":132,"user":"5048202fe4b0ec70b3ef8d9a"},{"code":"(fn [f z s] (apply concat (map (fn [[x y]] (if (nil? y) [x] (if (f x y) [x z] [x]))) (partition-all 2 1 s))))","problem":132,"user":"4f954dbce4b0dcca54ed6ccd"},{"problem":132,"code":"(fn r [p v s]\n  (when (seq s)\n    (cons (first s)\n          (lazy-seq (if (empty? (rest s))\n                      nil\n                      (if (p (first s) (second s))\n                        (cons v (lazy-seq (r p v (rest s))))\n                        (r p v (rest s))))))))","user":"551ed214e4b08d5046aa8a4d"},{"problem":132,"code":"(fn insert-between [p val coll]\n  (concat (take 1 coll)\n            (mapcat (fn [[f s] x]\n                      (if (p f s) (list val x) (list x)))\n                    (partition 2 1 coll)\n                    (rest coll))))","user":"561d23e3e4b064ca9f4b16a5"},{"problem":132,"code":"(fn [pred value xs]\n  ((fn ibti [last-value xs]\n    (lazy-seq\n    \t(if (empty? xs)\n        \txs\n        \t(let [[x & xs] xs]\n            \t(if (or (nil? last-value) (not (pred last-value x))) \n              \t\t(cons x (ibti x xs))\n                    (cons value (cons x (ibti x xs)))))))) nil xs))","user":"559b55d6e4b066d22e731f54"},{"problem":132,"code":"(fn ins\n  ([f v coll] (ins f v (rest coll) (first coll)))\n  ([f v coll init]\n    (if (empty? coll)\n      (if (nil? init) [] [init])\n      (let [n (first coll)]\n        (lazy-seq\n         (cons init\n           (if (or (= init v) (not (f init n)))\n            (ins f v (rest coll) n)\n            (ins f v coll v))))))))","user":"55ede35ce4b0121d4835fde1"},{"problem":132,"code":"(fn [pred marker coll]\n  (when-let [s (seq coll)] \n   (cons (first s)\n   (mapcat (fn [[a b]] (if (pred a b) [marker b] [b])) \n      (partition 2 1 s)))))","user":"532a033be4b09d4e7a9b551f"},{"code":"(fn p132  [f s  col]\n  (let [lz (fn lz [pv last_time_is_symbol data]\n            (lazy-seq\n             (if (empty? data)\n                   []\n                  (cons\n                    (if last_time_is_symbol\n                      (first data)\n                      (if (f pv (first data)) s (first data))\n                      )\n\n                    (lz\n                      (first data)\n                      (if last_time_is_symbol false (f pv (first data)))\n                      (if last_time_is_symbol (rest data) (if (f pv (first data)) data (rest data) )  ))\n\n               ))))\n                 ]\n     (lz  nil true col)\n\n    )\n\n  )","problem":132,"user":"4ec5bec6535d6d7199dd36b3"},{"problem":132,"code":"(fn lf [f sym c] (when (seq c) (lazy-seq (cons (first c) (when-let [s (rest c)] (when-not (empty? s) (if (f (first c) (first s)) (cons sym (lf f sym s)) (lf f sym s))))))))","user":"58987ee9e4b00487982d52d2"},{"problem":132,"code":"(fn [p v coll]\n  (if-not (seq (rest coll))\n    coll\n    (let [[x & xs]\n          (->> (partition 2 1 coll)\n               (map (fn [[a b]] (if (p a b) [a v b] [a b]))))]\n      (concat x (mapcat rest xs)))))","user":"505aa653e4b021387fb89857"},{"problem":132,"code":"(fn between [p v coll]\n  (if (empty? coll)\n    coll\n    (let [ \n           [ fst & other ] coll\n           snd             (first other) \n           prefix          (if (and (not (empty? other)) (p fst snd))\n                              [fst v]\n                              [fst])\n         ]\n      (lazy-cat prefix (between p v other)))))","user":"54d6f22de4b0a52adc2e2023"},{"code":"(fn n132 [f k coll]\n  (lazy-seq\n    (if (empty? (rest coll))\n      (if (empty? coll) [] [(first coll)])\n      (if (f (first coll) (second coll)) \n        (concat [(first coll) k] (n132 f k (rest coll)))\n        (cons (first coll) (n132 f k (rest coll)))\n        ))))","problem":132,"user":"52b43468e4b0c58976d9ad1b"},{"code":"(fn tmp ([p k [a b & l]]\n    (lazy-seq \n      (cond \n        (and a b (p a b)) (cons a (cons k (tmp p k (cons b l))))\n        a (cons a (tmp p k (cons b l)))\n        :else a))))","problem":132,"user":"4dbdab4e535d020aff1edf49"},{"code":"(fn [pred in coll-in] \n  (if (empty? coll-in) []\n    (let [g (fn y [x]\n      (if (empty? (next x)) [(first x)]\n        (if (pred (first x) (fnext x))\n          (cons (first x) (cons in (lazy-seq (y (next x)))))\n          (cons (first x) (lazy-seq (y (next x))))\n        )\n      )\n        \t)]\n      (g coll-in)\n    )\n  )\n)","problem":132,"user":"526dd90de4b03e8d9a4a72fe"},{"code":"(fn [f s xs]\n  (mapcat\n   (fn [[a b :as all]]\n     (if (= 1 (count all))\n       [a]\n       (if (f a b) [a s] [a])))\n   (partition-all 2 1 xs)))","problem":132,"user":"50d93c53e4b0fd36a4b89223"},{"problem":132,"code":"(fn [pred v coll]\n  (if (empty? coll) []\n    ((fn helper [c]\n       (if (empty? (rest c))\n         [(first c)]\n         (if (pred (first c) (first (rest c)))\n           (cons (first c) (cons v (lazy-seq (helper (rest c)))))\n           (cons (first c) (lazy-seq (helper (rest c))))))) coll)))","user":"5746061ae4b009280f9f2b5b"},{"code":"(fn insert [p e col]\n  (if (or (empty? col) (empty? (rest col)))\n    col\n    (let [[f r]\n            (split-with \n              #(not (apply p %)) \n              (partition 2 1 (lazy-cat col [0])))]\n     (lazy-cat\n        (map first f)\n        (when-let [ff (ffirst r)]\n          (cons ff (cons e\n            (insert p e (map first (rest r))))))))))","problem":132,"user":"4f03ac2d535dcb61093f6b4a"},{"code":"(fn m\n  ([fc mk [f & rc]] (if f (concat [f] (m fc mk f rc)) '()))\n  ([fc mk prev [f & rc] ] (if f\n                            (concat (if (fc prev f) [mk f] [f])\n                                    (lazy-seq (m fc mk f rc)))\n                            )))","problem":132,"user":"5124619ae4b02c3f2a072ccd"},{"problem":132,"code":"#(\n(fn insrt [f i x]\n  (if (< (count x) 2)\n    x\n    (if (f (bigint (first x)) (bigint (second x)))\n      (lazy-cat [(first x)] [i] (insrt f i (rest x)))\n      (lazy-cat [(first x)] (insrt f i (rest x)))))) %1 %2 (take 10 %3))","user":"586b6a0ae4b01531a375e957"},{"problem":132,"code":"(fn f [p v [x & r]]\n  (lazy-seq\n   (if x\n     (if r\n       (cons x (if (p x (first r))\n                 (cons v (f p v r))\n                 (f p v r)))\n       (list x)))))","user":"53034738e4b0d8b024fd373e"},{"problem":132,"code":"(fn insert-between [p v c]\n  (if (or (empty? c) (empty? (rest c))) c\n      (concat\n       (list (first c))\n       (when (p (first c) (second c)) (list v))\n       (lazy-seq (insert-between p v (next c))))))","user":"54e3df6ae4b024c67c0cf7e3"},{"problem":132,"code":"(fn ibti [p v [i & r :as is]]\n        (when (seq is)\n          (->> (mapcat (fn [l r]\n                         (if (p l r)\n                           [v r]\n                           [r]))\n                       is r)\n               (cons i))))","user":"58e37946e4b005f69f193cae"},{"problem":132,"code":"(fn [p val coll]\n  (if (empty? coll)\n    nil\n    (let [adjacent-pairs (map vector coll (drop 1 coll))]\n      (cons (first coll) (mapcat (fn [[x y]]\n                                   (if (p x y) [val y] [y]))\n                                 adjacent-pairs)))))","user":"5344fe13e4b084c2834f4a32"},{"problem":132,"code":"(fn insert [p m l]\n  (let [[x y & zs] l]\n    (cond\n      (nil? x) []\n      (nil? y) [x]\n      (p x y)  (cons x (cons m (lazy-seq (insert p m (cons y zs)))))\n      :else    (cons x (lazy-seq (insert p m (cons y zs))))\n    )\n  )\n)","user":"5943abb6e4b060784b3b792b"},{"code":"(fn f [p e [a b & more :as c]]\n         (if b\n         (let [ls (lazy-seq (f p e (rest c)))]\n           (cons a (if (p a b) (cons e ls) ls))) c))","problem":132,"user":"4fa30027e4b081705acca187"},{"problem":132,"code":"(fn [f iv c] (if (empty? c) c (flatten (cons (first c)\n                 (map (fn [a b] (if (f a b) [iv b] b)) c (drop 1 c)) ))))","user":"55adf4d7e4b03311e7b732af"},{"problem":132,"code":"(fn insert-between [f label s]\n  (if (or (empty? s) (empty? (rest s)))\n    s\n    (let [v1 (first s)\n          v2 (second s)\n          remain (lazy-seq (insert-between f label (rest s)))]\n      (cons v1\n            (if (f v1 v2)\n              (cons label remain)\n              remain)))))","user":"5e9c11f8e4b0157ca96647f6"},{"problem":132,"code":"(fn [f v coll]\n  (when (seq coll)\n    (cons (first coll)\n          (mapcat (fn [[x y]]\n                    (if (f x y)\n                      [v y]\n                      [y]))\n                  (partition 2 1 coll)))))","user":"53576356e4b04ce2eb3ed27a"},{"code":"(fn g [f v [a b & _ :as c]]\n  (when (seq c)\n    (remove nil? (cons a (cons (when (and a b (f a b)) v) (lazy-seq (g f v (rest c))))))))","problem":132,"user":"4ea09fa4535d7eef308072aa"},{"problem":132,"code":"(fn __\n  ([p v c]\n   (if (empty? c) c\n       (__ p v (next c) (list (first c)))))\n  ([p v c r]\n   (let [step (fn [x y z a]\n                (when (seq z)\n                  (__ x y (next z) (if (x (last a) (first z))\n                                     (list y (first z))\n                                     (list (first z))))))]\n     (concat r (lazy-seq (step p v c r))))))","user":"53d5a63be4b0e771c3025449"},{"problem":132,"code":"(fn [p v coll]\n  (if-let [n (first coll)]\n \t(cons n (->> coll\n                 (partition 2 1)\n                 (mapcat (fn [[a b]] (if (p a b) [v b] [b])))))\n    ()))","user":"5f3abcc4e4b004f08c61c52b"},{"problem":132,"code":"#(if (empty? %3) []\n  (cons (first %3) (->> (partition 2 1 %3)\n       (mapcat (fn [[l r]]\n                 (if (%1 l r) [%2 r] [r]))))))","user":"605b7a90e4b079a07f8593fc"},{"code":"(fn [pred item coll]\r\n  (mapcat (fn [[a b]]\r\n            (if (and b (pred a b)) [a item] [a]))\r\n          (partition 2 1 [] coll)))","problem":132,"user":"500d1db4e4b05f7c30cfa69f"},{"problem":132,"code":"(fn p132 [pred sep coll]\n  (if (empty? (rest coll)) \n    coll\n    (->> (partition 2 1 coll)\n         (#(for [[x y] %] (if (pred x y) [sep y] [y])))\n         (#(cons (first coll) (apply concat %))))))","user":"55645592e4b0c656e3ff1802"},{"problem":132,"code":"(fn [p k s]\n  (let [r (map (fn [[x y]] (if (p x y) [x k y] [x y])) (partition 2 1 s))]\n    (if (seq r)\n      (flatten (cons (first r) (map rest (rest r))))\n      s)))","user":"590b055ae4b047aa04b199c9"},{"problem":132,"code":"(fn insert [p v [c1 & coll]]\n   (when c1\n     (if coll\n       (lazy-cat (if (p c1 (first coll))\n                   [c1 v]\n                   [c1])\n                 (insert p v coll))\n       [c1])))","user":"554bd33ce4b0a04f7929959a"},{"code":"(fn bw1\n    ([pr? sep c] (if (empty? c) '() (bw1 pr? sep false (first c) (rest c))))\n    ([pr? sep ns? f r]\n        (if (empty? r)\n            (if ns? (list sep f) (list f))\n            (if ns?\n                (lazy-seq (cons sep (bw1 pr? sep false f r)))\n                (lazy-seq (cons f\n                    (bw1 pr? sep (pr? f (first r)) (first r) (rest r))))))))","problem":132,"user":"4f128865535d64f603146428"},{"code":"(fn ins [p? v [a b :as c]]\n  (cond\n    (nil? a) ()\n    (nil? b) (list a)\n    :else\n      (let [r (lazy-seq (ins p? v (next c)))]\n        (if (p? a b)\n          (cons a (cons v r))\n          (cons a r)))))","problem":132,"user":"4fce5474e4b0d4b2a7a9d451"},{"problem":132,"code":"(fn iter [f x [h & [h2 & r2 :as r]]]\n    (lazy-seq\n     (if h2\n       (if (f h h2)\n         (cons h (cons x (iter f x r)))\n         (cons h (iter f x r)))\n       (when h\n         (cons h (iter f x r))))))","user":"591ad160e4b09b4ee5954bdf"},{"problem":132,"code":"(fn [pred val coll]\n  (mapcat (fn [[x y]]\n         (if (and y (pred x y)) [x val] [x]))\n       (partition-all 2 1 coll)))","user":"56603e5fe4b068f2fe63dc4a"},{"problem":132,"code":"(fn [pred value coll]\n  (if (empty? coll)\n    '()\n    (flatten \n      (cons (first coll)(map (fn[x y](if (pred x y) [value y] y)) coll (rest coll))))))","user":"545537c1e4b0e397800069dd"},{"code":"(fn [o i l] (if (empty? l) [] \n              (flatten (reductions #(if (o (last %) %2) [i %2] [%2]) [(first l)] (rest l)))))","problem":132,"user":"52c6a0abe4b0c2d177d62111"},{"problem":132,"code":"(fn ins-bw [p v [h & t]]\n  (cond\n    (nil? h) []\n    (empty? t) [h]\n    :else (lazy-cat (if (p h (first t)) [h v] [h] ) (ins-bw p v t))))","user":"53ce4cd4e4b00fb29b2212ef"},{"code":"(fn f [p e v]\n   (letfn [(helper-f [rst]\n             (if (empty? rst)\n               []\n               (let [head-1 (first rst)\n                     head-2 (second rst)\n                     more (lazy-seq (helper-f (rest rst)))]\n                 (if (or (nil? head-2)\n                         (not (p head-1 head-2)))\n                   (concat (vector head-1) more)\n                   (concat (vector head-1 e) more)))))]\n     (helper-f v)))","problem":132,"user":"4eec82fe535d93acb0a668ae"},{"problem":132,"code":"(fn [f y xs]\n  (->> xs\n       (partition 2 1 nil)\n       (map (fn [[a b]] (if (and a b (f a b)) [a y] [a])))\n       (flatten)\n       (remove nil?)\n       ))","user":"5312cdaae4b08068f379ed03"},{"code":"(fn f [p o s xs]\r\n  (let [fi (first xs)]\r\n    (cond\r\n      (empty? xs) []\r\n      (nil? p) (lazy-seq (cons fi (f fi o s (next xs))))\r\n      (o p fi) (lazy-seq (cons s (cons fi (f fi o s (next xs)))))\r\n      :else (lazy-seq (cons fi (f fi o s (next xs)))))))\r\nnil","problem":132,"user":"4ef6e689535dced4c769f24f"},{"code":"(fn [f el s]\n  (when-let [s (seq s)]\n    (cons (first s)\n          (mapcat (fn [[a b]]\n                    (if (f a b)\n                      [el b]\n                      [b]))\n                  (partition 2 1 s)))))","problem":132,"user":"4f2baf1ae4b0d6649770a04c"},{"code":"(fn [p? v c]\n  (mapcat (fn [a b] \n            (if (nil? b)\n                [a]\n                (if (p? a b)\n                    [a v]\n                    [a])))\n          c (concat (rest c) [nil])))","problem":132,"user":"4faac363e4b081705acca200"},{"problem":132,"code":"(fn [p v [c1 & _ :as c ]] (if c1 (cons c1 (mapcat (fn [[a b]] (if (p a b) [v b] [b])) (partition 2 1 c)))))","user":"5b919d9de4b0c0b3ffbd4a24"},{"problem":132,"code":"(fn [P V C]\n   (letfn [(insbt [p v c] (lazy-seq (cond (empty? c) nil\n                                    (empty? (rest c)) [(first c)]\n                                    (p (first c) (second c)) (concat [(first c) v] (insbt p v (rest c)))\n                                    :else  (cons (first c) (insbt p v (rest c)) ))))]\n     (insbt P V C)))","user":"5649615be4b0284900eef641"},{"problem":132,"code":"(fn [p v c]\n  (->> c\n   (partition-all 2 1)\n   (mapcat (fn [[a b]] (if (and b (p a b)) [a v] [a])))\n)\n  )","user":"55f09e7be4b06e875b46ce28"},{"code":"(fn insert-between-two-items [f i v]\n  (lazy-seq \n       (let [fv (first v)\n             rv (rest v)]\n         (if (nil? fv) []\n             (cons fv (if (empty? rv) []\n                          (let [fv2 (first rv)]\n                            (if (f fv fv2) (cons i (insert-between-two-items f i rv))\n                                (insert-between-two-items f i rv)))))))))","problem":132,"user":"515bbcd9e4b0388ca8ca1521"},{"code":"(fn interleave-when [pred value coll]\n  (mapcat (fn [[f s :as c]]\n             (cond\n               (= 1 (count c)) [f]\n               (pred f s)      [f value]\n               :else           [f]))\n          (partition 2 1 nil coll)))","problem":132,"user":"4ee6400c535d93acb0a6685b"},{"code":"(fn [p v [x & s :as xs]]\n\t (when x \n       (cons x\n\t  \t(mapcat #(if (p % %2) [v %2] [%2]) xs s))))","problem":132,"user":"519ef784e4b087743fad2198"},{"code":"(fn insert-between [f key s]\n  (if (second s)\n     (lazy-seq \n        (if (f (first s) (second s))\n          (cons (first s) (cons key (insert-between f key (rest s))))\n          (cons (first s) (insert-between f key (rest s)))\n         )\n      )\n    s\n   )\n  )","problem":132,"user":"529a73bde4b02ebb4ef75096"},{"problem":132,"code":"(fn __ [pred seprator coll]\n  (filter\n    #(not= :pad %)\n    (interleave\n      coll\n      (concat\n        (map {true seprator false :pad}\n             (map (partial apply pred) (partition 2 1 coll)))\n        [:pad]))))","user":"56ac81ace4b03c432f187347"},{"code":"(fn [pred value coll] (letfn [\n(insert-between-two-items [pred value coll]\n\t(cond\n\t\t(or (nil? (first coll)) (nil? (second coll)))\n\t\tcoll\n\t\t(pred (first coll) (second coll))\n\t\t(lazy-cat [(first coll) value] (insert-between-two-items pred value (rest coll)))\n\t\t:else\n\t\t(cons (first coll) (lazy-seq (insert-between-two-items pred value (rest coll))))\n\t)\n)\n] (insert-between-two-items pred value coll)))","problem":132,"user":"52f10094e4b05e3f0be25ee8"},{"problem":132,"code":"(fn [p v xs]\n   (mapcat\n    #(if (p %1 %2) [%1 v] [%1])\n    xs\n    (concat (rest xs) (take 1 xs))))","user":"544cf5d7e4b0e39780006977"},{"problem":132,"code":"(fn insert-between [f value coll]\n  (letfn [(lazy-insert-between [coll]\n                               (cond\n                                (empty? coll) coll\n                                (empty? (rest coll)) coll\n                                :else (lazy-seq\n                                       (when-let [[fst snd & tail] (seq coll)]\n                                         (concat (if (f fst snd)\n                                                   [fst value]\n                                                   [fst])\n                                                 (lazy-insert-between (rest coll)))))))]\n    (lazy-insert-between coll)))","user":"585e2e77e4b0f14aab7c87ac"},{"code":"(fn fn132 [p v [a b :as s]] (lazy-seq (if (empty? s) [] (concat (if (or (nil? b) (not (p a b))) (vector a) (vector a v)) (fn132 p v (rest s))))))","problem":132,"user":"4f0e4ebd535d0136e6c22322"},{"problem":132,"code":"(fn insert*\n  ([p v xs]\n   (if (empty? xs) '()\n       (cons (first xs) (insert* p v (rest xs) (first xs)))))\n  ([p v xs prev]\n   (if (seq xs)\n     (let [curr (first xs)]\n       (if (p prev curr)\n         (cons v (cons curr (lazy-seq (insert* p v (rest xs) curr))))\n         (cons curr (lazy-seq (insert* p v (rest xs) curr)))))\n     nil)))","user":"5ec3a13ae4b08d0ec38692b9"},{"code":"(fn fun [pred del coll]\n   (let [f (first coll)\n         s (second coll)]\n     (cond\n      (nil? s) (if (nil? f) () (list f))\n      (pred f s) (lazy-cat (cons f (cons del (fun pred del (rest coll)))))\n      :else (lazy-cat (cons f (fun pred del (rest coll)))))))","problem":132,"user":"506c0a02e4b0eda3100c090d"},{"problem":132,"code":"(fn insert-between [pred value collection]\n  (if (empty? (next collection))\n    collection\n    (lazy-seq\n      (if (apply pred (take 2 collection))\n        (cons (first collection) (cons value (insert-between pred value (next collection))))\n        (cons (first collection) (insert-between pred value (next collection)))))))","user":"58247423e4b051871117bec5"},{"problem":132,"code":"(fn ins [pred value coll]\n  (if (empty? coll)\n    ()\n    (lazy-seq (cons (first coll)\n                    (if (seq (next coll))\n                      (let [s (second coll)]\n                        (if (pred (first coll) s)\n                          (cons value (ins pred value (next coll)))\n                          (ins pred value (next coll))))\n                      ())))))","user":"549c6792e4b0f3d1d8e70f8b"},{"code":"(fn x [f e [p s & r :as c]]\n  (lazy-seq\n    (if-not (empty? c)\n      (if s\n        (if (f p s)\n          (cons p (cons e (x f e (next c))))\n          (cons p (x f e (next c))))\n        [p])\n      c)))","problem":132,"user":"4f32a7f1e4b0d6649770a095"},{"problem":132,"code":"(fn [f x l]\n  (if (empty? l)\n    []\n    (apply concat (reductions (fn [p n] (if (f (last p) n)\n                     [x n]\n                     [n]))\n                [(first l)]\n                (rest l)))))","user":"53f6d555e4b0db01ade6f9e5"},{"problem":132,"code":"(fn [p x c]\n  (mapcat \n    (fn [[a b]] (if (and a (p a b)) [x b] [b])) \n    (map vector (cons nil c) c)))","user":"58f44c07e4b0438e51c2ceb7"},{"code":"(fn insert-between [pred v coll]\n  (if (empty? coll)\n    coll\n    (let [[a b] coll\n          t (rest coll)]\n      (cond\n       (empty? t) coll\n       (pred a b) (lazy-seq (cons a (cons v (insert-between pred v t))))\n       :else (lazy-seq (cons a (insert-between pred v t)))))))","problem":132,"user":"500ff421e4b0ae202717946f"},{"problem":132,"code":"(fn [p val c]\n            (if (empty? c)\n              c\n              ((fn f [i]\n                 (if (nil? (nth c (+ i 1) nil))\n                   [(nth c i)]\n                   (if (p (nth c i) (nth c (+ i 1)))\n                     (lazy-seq (cons (nth c i) (cons val (f (+ i 1)))))\n                     (lazy-seq (cons (nth c i) (f (+ i 1)))))))\n               0)))","user":"5e1c3e6ee4b0dc9594008530"},{"code":"(fn [f v s]\n  (if (empty? s) []\n    (apply concat \n      (for [[x y] (partition 2 1 [:ignore] s)]\n        (if (and (not (identical? y :ignore)) (f x y)) [x v] [x])))))","problem":132,"user":"4dd9d299535d2dad7130b5dd"},{"code":"(fn i [p v l]\n  (cond (empty? l) nil\n        (empty? (next l)) l\n        true (let [[x y & t] l]\n               (if (p x y)\n                 (lazy-seq (cons x (cons v (i p v (next l)))))\n                 (lazy-seq (cons x         (i p v (next l))))))))","problem":132,"user":"4fa6d532e4b081705acca1be"},{"code":"(fn insert-between\n  [pred value coll]\n  (let [ [a b & r] coll]\n    (lazy-seq\n    (cond\n      (nil? b) coll\n      (pred a b) (concat [a value] (insert-between pred value (rest coll)))\n      :else      (concat [a] (insert-between pred value (rest coll)))))))","problem":132,"user":"4edf5dc6535d10e5ff6f5340"},{"code":"(fn f [p v [e & c]]\n(remove nil?\n(if c\n(lazy-seq (cons e (if (p e (first c)) (cons v (f p v c)) (f p v c))))\n`(~e))))","problem":132,"user":"4e823ed7535db62dc21a62c7"},{"problem":132,"code":"(fn inst [f v [l & rs :as c]]\n  (if (empty? rs) \n    c\n    (lazy-seq\n     (cons l (lazy-seq\n              (if (f l (first rs)) \n                (cons v (inst f v rs))\n                (inst f v rs)))))))","user":"53b7c21ae4b047364c0444d4"},{"problem":132,"code":"(fn lazy-predicated-inbetween\n  [pred value xs]\n  (let [head (first xs)\n        neck (second xs)]\n    (if (nil? head) ()\n        (lazy-seq\n         (cons head\n               (if (and (not (nil? neck)) (pred head neck))\n                 (cons value (lazy-predicated-inbetween pred value (rest xs)))\n                 (lazy-predicated-inbetween pred value (rest xs))))))))","user":"5c222b7de4b07e362c230588"},{"code":"(fn f [p v s]\n  (if (or (empty? s) (empty? (rest s))) s\n      (let [r (lazy-seq (f p v (rest s)))]\n        (cons (first s) (if (p (first s) (second s)) (cons v r) r)))))","problem":132,"user":"5054c7e1e4b0b1b9d1860eb2"},{"problem":132,"code":"(fn [func kword args]\n    (mapcat\n     #(if (func %1 %2) [%1 kword] [%1])\n     args\n     (lazy-cat (rest args) (take 1 args))))","user":"539fa040e4b0ca733b97449f"},{"code":"(fn la2 [pred? value seq]\n  (let [shift (cons nil seq)]\n    (->>\n      (map (fn [a b]\n             (if (nil? b)\n               [a]\n               (if (pred? b a)\n                 [value a]\n                 [a])))\n           seq shift)\n      (mapcat vec))))","problem":132,"user":"4fab259ae4b081705acca212"},{"problem":132,"code":"(fn insert [f v coll]\n\t(lazy-seq\n\t\t(if (not-empty (next coll))\n\t\t\t(let [c0 (first coll), c1 (fnext coll)]\n\t\t\t\t(if (f c0 c1)\n\t\t\t\t\t(cons c0 (cons v (insert f v (rest coll))))\n\t\t\t\t\t(cons c0 (insert f v (rest coll)))))\n\t\t\tcoll)))","user":"5370b386e4b0fc7073fd6e9b"},{"code":"(fn ib [f t [s & ss]]\n  (if (nil? s)\n    [] (if (empty? ss) [s]\n           (lazy-seq (cons s (if (f s (first ss))\n                               (cons t (ib f t ss))\n                               (ib f t ss)))))))","problem":132,"user":"52ba43d0e4b07a9af57922cd"},{"problem":132,"code":"(fn f [p v [x & r]]\n           (lazy-seq (cond\n             (empty? r) (if x (list x) '())\n             (p x (first r)) (concat [x v] (f p v r))\n             :else (cons x (f p v r)))))","user":"567c63f6e4b05957ce8c61bb"},{"code":"(fn f [g s coll]\n  (if (empty? coll)\n    []\n    (let [h (fn h [x y]\n              (if (seq y)\n                (let [fx (first x ) fy (first y) rx (rest x) ry (rest y)]\n                  (if (g fx fy)\n                    (cons s (cons fy (lazy-seq (h rx ry ))))\n                    (cons fy (lazy-seq (h rx ry)))))))]\n      (cons (first coll) (h coll (rest coll))))))","problem":132,"user":"518c5236e4b087e178201de0"},{"problem":132,"code":"(fn [pred pad [_ & tail :as col]]\n  (if (empty? col)\n    []\n    (apply concat\n           (take 1 col)\n           (map #(\n                   if (pred %1 %2)\n                   [pad %2]                                 ;; add padding between the second value\n                   [%2])                                    ;; add just second value with no padding\n                col tail))))                                ;; apply pred on elements from input and inputted shifted by 1","user":"5ce2bf8ee4b0a17bb84e2b2e"},{"problem":132,"code":"(fn F [p v [x & xs :as coll]]\n  (cond (empty? coll) [] \n        (empty? xs) [x] \n        (p x (first xs)) (lazy-cat [x v] (F p v xs))\n        :else (lazy-cat [x] (F p v xs))))","user":"5566d812e4b0c656e3ff1837"},{"problem":132,"code":"(fn clj132 [f item coll]\n  (mapcat\n    (fn [x y]\n      (if (f x y)\n        [x item]\n        [x]))\n    coll\n    (lazy-cat (rest coll) (take 1 coll))))","user":"52474133e4b05ef8e38e635e"},{"code":"(fn k2 \n  ([pred v coll]\n    (cond (empty? coll) coll\n          (nil? (second coll)) [(first coll)]\n          :else  (cons (first coll)\n                  (if (pred (first coll) (second coll))\n                      (cons v (lazy-seq (k2 pred v (rest coll))))\n                      (lazy-seq (k2 pred v (rest coll))))))))","problem":132,"user":"4fdb02aae4b05e33b9224f56"},{"code":"(fn nofx [fx t coll]\n     (if (seq coll)\n         (cons (first coll)\n                  (mapcat (fn [a b] (if (fx a b) [t b] [b]))\n                                     coll (rest coll))\n                         )\n         ))","problem":132,"user":"514cfa27e4b019235f6c057d"},{"code":"(fn insert-between-two [pred value a-seq]\n\t(letfn [(do-insert [el r-seq]\n\t\t\t(if (empty? r-seq)\n\t\t\t\t(cons el nil)\n\t\t\t\t(let [f (first r-seq)]\n\t\t\t\t\t(cons el\n\t\t\t\t\t\t(lazy-seq \n\t\t\t\t\t\t\t(if (pred el f)\n\t\t\t\t\t\t\t\t(cons value \n\t\t\t\t\t\t\t\t\t(do-insert\n\t\t\t\t\t\t\t\t\t\tf (rest r-seq)\t\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t(do-insert\n\t\t\t\t\t\t\t\t\t\tf (rest r-seq)\t\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t)]\n\t\t(if (empty? a-seq)\n\t\t\ta-seq\n\t\t\t(do-insert (first a-seq) (rest a-seq))\t\n\t\t)\n\t)\n)","problem":132,"user":"52763696e4b03e8d9a4a74d7"},{"problem":132,"code":"(fn ins-between [pred val [c1 & crest :as coll]]\n  (when (seq coll)\n    (lazy-seq (cond\n                (empty? crest)          [c1]\n                (pred c1 (first crest)) (concat [c1 val] (ins-between pred val crest))\n                :else                   (concat [c1] (ins-between pred val crest))))))","user":"575b3e9be4b02ea11479935b"},{"problem":132,"code":"(fn inserts-between-two-items [pred sep xs]\n  (if (empty? (rest xs)) xs\n    (let [f (first xs)\n          s (second xs)\n          fs (if (pred f s) [f sep] [f])]\n      (lazy-seq \n        (concat fs (inserts-between-two-items pred sep (rest xs)))))))","user":"52ee0de4e4b05e3f0be25ec1"},{"problem":132,"code":"(fn [p v c]\n  (when (seq c)\n    (->> (partition 2 1 c)\n         (mapcat (fn [[x1 x2]] (if (p x1 x2) [v x2] [x2])))\n         (cons (first c)))))","user":"52470d42e4b05ef8e38e6350"},{"code":"(fn f [pred sym coll] \r\n  (lazy-seq \r\n    (when-let [[val & coll] (seq coll)] \r\n\t  (if-let [coll (seq coll)] \r\n\t    (cons val \r\n\t\t  (if (pred val (first coll)) \r\n\t\t      (cons sym (f pred sym coll)) \r\n\t\t\t  (f pred sym coll))) \r\n\t    [val]))))","problem":132,"user":"4db92654535d1e037afb21a0"},{"code":"(fn [p v c]\n  ((fn g [[x y & z]] \n     (lazy-seq\n       (if y   \n           (cons x \n                 (if (p x y)\n                     (cons v (g (cons y z)))\n                     (g (cons y z))))\n           (if x \n               [x] \n               [])))) \n   c))","problem":132,"user":"4ef49c2c535dced4c769f238"},{"code":"(fn [f k v]\n  (mapcat #(if (f % %2) [% k] [%]) \n          v\n         (lazy-cat (rest v) (take 1 v))))","problem":132,"user":"4ffa8affe4b0678c553fc3bd"},{"problem":132,"code":"(fn [pred v coll]\n  (->> (partition 2 1 coll coll)\n       (map (fn [[a b]]\n              (if (pred a b)\n           \t\t[a v b]\n           \t\t[a b])))\n       (mapcat #(take (dec (count %)) %))))","user":"5245aea8e4b08ba239308123"},{"problem":132,"code":"(fn ins [f v xs]\n  (if (empty? xs) '()\n  (->>\n  xs\n  (partition 2 1)\n  (mapcat (fn [pair]\n    (let [x (first pair)\n          y (second pair)]\n      (if (f x y)\n        (list v y)\n        (list y)))))\n  (#(concat [(first xs)] %)))))","user":"57717915e4b0979f896515b3"},{"problem":132,"code":"(fn f [o v [s t & c]]\n    (cond (nil? s) []\n        (nil? t) [s]\n      :else (lazy-cat (if (o s t) [s v] [s]) (f o v (cons t c)))))","user":"57642916e4b0994c1922fbee"},{"problem":132,"code":"(fn [pred v coll]\n  (mapcat \n    (fn [[a & b]]\n      (if (and b (apply pred a b))\n        [a v]\n        [a]))\n    (partition-all 2 1 coll)))","user":"598858d0e4b021a7a535feb5"},{"problem":132,"code":"(fn insert-kw2 [p kw coll]\n  (let [[a b & rs] coll]\n    (cond\n      (empty? coll) []\n      (and a b (p a b)) (lazy-seq (concat [a kw] (insert-kw2 p kw (drop 1 coll))))\n      :else (lazy-seq (concat [a] (insert-kw2 p kw (drop 1 coll)))))))","user":"5fa74b82e4b0fa27300f3dda"},{"code":"(fn f [p i [a b & c]]\n  (if b\n    (lazy-cat [a] (if (p a b) [i]) (f p i (cons b c)))\n    (if a [a] [])))","problem":132,"user":"4e49badd535dc968683fc4c9"},{"code":"(fn f [p v coll]\n  (if (empty? (rest coll)) coll\n      (lazy-cat \n        (if (p (first coll) (second coll))\n          [(first coll) v]\n          [(first coll)])\n        (f p v (rest coll)))))","problem":132,"user":"51e00020e4b01188f0627534"},{"problem":132,"code":"(fn insert [x y z] (if (empty? (rest z)) z\n                     (lazy-seq (cons (first z) (\n                                                (if (x (first z) (second z)) (partial cons y) identity)\n                                                (insert x y (rest z)))))))","user":"584dadebe4b0b7285a6f4e44"},{"code":"(fn [p v coll]\n   (if (seq coll)\n     (cons (first coll)\n         (mapcat (fn [[x y]]\n                   (if (p x y)\n                     [v y]\n                     [y])) (partition 2 1 coll)))))","problem":132,"user":"4f036d9b535dcb61093f6ac1"},{"code":"(fn m [f a [x & r]]\n  (cond\n     (not x) []\n     (empty? r) [x]\n     :else\n       (lazy-cat\n         (if (f x (first r)) [x a] [x])\n         (m f a r))))","problem":132,"user":"4e80e0f2535db62dc21a62b8"},{"code":"(fn i [p v [h & t :as l]]\n            (if (seq l) (cons h (mapcat #(if (p %1 %2) [v %2] [%2]) l t)))\n            )","problem":132,"user":"52593207e4b0cb4875a45cd3"},{"problem":132,"code":"(fn [p v coll]\n    (if (empty? coll)\n      coll\n      (cons (first coll) (mapcat (fn [[l r]] (if (p l r) [v r] [r])) \n                               (map vector coll (rest coll) )))\n      )\n    )","user":"4f5e5975e4b0030a34fb2b4d"},{"problem":132,"code":"(fn insert-between [pred value coll]\n  (let [a (first coll)\n        b (second coll)\n        rest-coll (rest coll)]\n    (if (or (empty? coll) (empty? rest-coll)) coll\n        (lazy-seq (concat (if (pred a b) [a value]\n                     [a])\n                 (insert-between pred value rest-coll))))))","user":"51b76227e4b0d906fcd71d35"},{"code":"(fn [pred v xs]\n  (mapcat #(if %2 [%1 v] [%1])\n          xs\n          (concat (map (fn [[a b]] (pred a b)) (partition 2 1 xs)) [false])))","problem":132,"user":"4f21838fe4b0d66497709fd2"},{"problem":132,"code":"(fn f [p v c]\n  (->> (concat c [:end])\n       (partition 2 1)\n       (mapcat (fn [[a b]]\n                 (if (= b :end)\n                   [a]\n                   (if (p a b)\n                     [a v]\n                     [a]))))))","user":"5012da69e4b0c8732600222d"},{"problem":132,"code":"(fn  [p? value coll] \n  (letfn[(inner [cur]  \n           (lazy-seq\n             (let [xs (drop cur coll)\n                   x (first xs)\n                   y (second xs)]\n               (cond\n                 (nil? x) '()\n                 (nil? y) (cons x '())\n                 (p? x y) (cons x (cons value (inner (inc cur))))    \n                 :else (cons x (inner (inc cur)))))))]\n    (inner 0)))","user":"5794fd7be4b0e215f87e8476"},{"code":"(fn [p v s]\n  (if (empty? s)\n    ()\n    (cons\n      (first s)\n      (mapcat\n        (fn [x y] (if (p x y) [v y] [y]))\n        s (rest s)))))","problem":132,"user":"506ab9bae4b05d3b7762c74c"},{"problem":132,"code":"(fn insert-between [p v coll]\n    ;; The problem statement needs to specify \"lazy sequence\", not collection!\n    ;; Otherwise, the last test case causes an integer overflow.\n    (when-let [s (seq coll)]\n      (lazy-seq\n       (mapcat identity\n               (reductions\n                (fn [acc [a b]]\n                  (if (p a b) [v b] [b]))\n                [(first coll)]\n                (partition 2 1 coll))))))","user":"4dfe5a93535d04ed9115e786"},{"problem":132,"code":"(fn [f v c]\n  (if (empty? c)\n    c\n    (cons (first c)\n          (mapcat #(if (apply f %)\n                     [v (last %)]\n                     [(last %)])\n                  (partition 2 (interleave c\n                                           (rest c)))))))","user":"53acaf1fe4b047364c04445f"},{"problem":132,"code":"(fn [f s coll]\n  (mapcat (fn [[a b]] (if (and a b (f a b)) (list a s) (list a))) (partition-all 2 1 coll)))","user":"572de985e4b0cd1946bd0f7c"},{"problem":132,"code":"(fn insert-between [f v coll]\n  (lazy-seq\n   (if-let [x1 (first coll)]\n     (if-let [x2 (second coll)]\n       (if (f x1 x2)\n         (cons x1 (cons v (insert-between f v (drop 1 coll))))\n         (cons x1 (insert-between f v (drop 1 coll))))\n       [x1]))))","user":"5666500ee4b0e91d5f5c566d"},{"problem":132,"code":"(fn [p? word xs]\n  (mapcat \n    (fn [[f s]] \n      (if (or (nil? s) (not (p? f s))) [f] [f word]))\n    (partition-all 2 1 xs)))","user":"4f7207d3e4b07046d9f4f019"},{"problem":132,"code":"(fn [pred val coll]\n  (mapcat (fn [[a b]] (if (and b (pred a b)) [a val] [a]))\n          (partition-all 2 1 coll)))","user":"56dc3bdfe4b0ea9b8538f819"},{"problem":132,"code":"(fn insert-between [pred? el [f & rest]]\n  (when\n    (not (nil? f))\n    (concat\n      (if (and (seq rest) (pred? f (first rest))) [f el] [f])\n      (lazy-seq (insert-between pred? el rest)))))","user":"5ccb0bbee4b0ccb06196287c"},{"problem":132,"code":"(fn f [p v xs]\n    (->>\n      (map #(if (p %1 %2) v nil) xs (drop 1 xs))\n      (#(concat % [nil]))\n      (interleave xs)\n      (filter identity)\n    ))","user":"596d630ae4b069c0a1a19846"},{"problem":132,"code":"(fn [pred val coll]\n    (if (seq (rest coll))\n      (->> (partition 2 1 coll)\n           (mapcat (fn [[a b]]\n                     (if (pred a b)\n                       (vector val b)\n                       (vector b))))\n           (cons (first coll)))\n      coll))","user":"538ca203e4b0b51d73faae5f"},{"problem":132,"code":"(fn\n  [pred e xs]\n  (->> xs\n       (partition-all 2 1)\n       (mapcat (fn [[p1 p2]] (if (and p1 p2 (pred p1 p2)) [p1 e] [p1])))\n       )\n  )","user":"5fa17538e4b0f0ebd91b77e3"},{"code":"(fn pred-ins\r\n    ([pred myval myc] (lazy-seq (pred-ins myc nil pred myval)))\r\n    ([s prev p v]\r\n       (lazy-seq\r\n        (if (empty? s)\r\n          '()\r\n          (let [f (first s) r (rest s)]\r\n            (if (not (nil? prev))\r\n              (if (p prev f)\r\n                (cons v (cons f (pred-ins r f p v)))\r\n                (cons f (pred-ins r f p v)))\r\n              (cons f (pred-ins r f p v))))))))","problem":132,"user":"4f039524535dcb61093f6b2c"},{"problem":132,"code":"(fn insertIf[op el [f & r]]\n\t(lazy-seq (if (nil? f)\n\t\t'()\n\t\t(if (nil? r)\n\t\t\t(seq [f])\n\t\t\t(if (op f (first r))\n\t\t\t\t(cons f (cons el (insertIf op el r)))\n\t\t\t\t(cons f (insertIf op el r))))))\n)","user":"5626447fe4b00e49c7cb47bd"},{"problem":132,"code":"(fn insert-between-two-items [f sep lst]\n    (if (nil? (second lst))\n      lst\n      (let [ res (f (first lst) (second lst))]\n        (lazy-seq (cons (first lst)\n              (if res\n                (lazy-seq (cons sep (insert-between-two-items f sep (rest lst) )))\n                (insert-between-two-items f sep (rest lst) )))))))","user":"55aa1637e4b0988bba2ad949"},{"problem":132,"code":"(fn [pred v coll]\n  (apply concat\n         (take 1 coll)\n         (map (fn [x y]\n                (if (pred x y)\n                  [v y]\n                  [y]))\n              coll (rest coll))))","user":"5c3796b3e4b0d62ef62d9f77"},{"code":"(fn problem-132 [f insert-item s]\n  (let [first-item (first s)\n        second-item (second s)]\n    (cond\n      (nil? first-item) (list)\n      (nil? second-item) (list first-item)\n      :else (lazy-seq\n              (let [lazy-next (problem-132 f insert-item (rest s))]\n                (if (true? (f first-item second-item))\n                  (cons first-item (cons insert-item lazy-next))\n                  (cons first-item lazy-next)))))))","problem":132,"user":"4f31519ae4b0d6649770a086"},{"problem":132,"code":"(fn predicate [f pred ls] (cond\n                           (nil? (first ls)) []\n                           (nil? (second ls)) ls\n                           :default (if (f (first ls) (second ls))\n                                    (lazy-seq (when-let [s (seq ls)] (cons (first s) (cons pred (predicate f pred (rest s))))))\n                                      (lazy-seq (when-let [s (seq ls)] (cons (first s) (predicate f pred (rest s))))))\n                           )\n  )","user":"56427910e4b08d4f616f5f19"},{"problem":132,"code":"(fn [f v c]\n  (if (not-empty c)\n    (flatten (lazy-cat (map #(if (apply f %) (list (first %) v) (first %)) (partition 2 1 c)) (list (last c))))\n    c))","user":"5b421edce4b02d533a91bc2c"},{"code":"(fn [pred item [x & xs]]\r\n  (apply concat (if x [x] x) \r\n         (map (let [p (atom x)]\r\n                #(let [v (if (pred @p %)\r\n                             [item %]\r\n                             [%])]\r\n                   (reset! p %) v)) xs )))","problem":132,"user":"4fb37882e4b081705acca2a0"},{"problem":132,"code":"(fn insert [p sep [x1 & [x2 & _ :as xs]]]\n  (cond\n    (nil? x1) nil\n    (nil? x2) (lazy-seq (list x1))\n    (p x1 x2) (lazy-seq (list* x1 sep (insert p sep xs)))\n    :else (lazy-seq (cons x1 (insert p sep xs)))))","user":"5f300f28e4b033932238a682"},{"problem":132,"code":"(fn s132 [pred v [a & r :as coll]]\n  (lazy-seq \n    (if (seq r)\n       (concat (if (pred a (first r)) [a v] [a]) (s132 pred v r))\n       coll)))","user":"53b530c6e4b047364c0444bc"},{"problem":132,"code":"(fn [pred mark xs]\n    (mapcat\n     identity\n     (let [pairs (partition 2 1 xs)]\n       (if (nil? (first pairs))\n         [xs]\n         (conj\n          (for [[l r] pairs]\n            (if (pred l r)\n              [mark r]\n              [r]))\n          [(ffirst pairs)])))))","user":"5275f7a2e4b03e8d9a4a74d0"},{"code":"(fn [f v c]\n   (if (empty? c)\n     []\n     (mapcat \n       #(if (and %2 (f % %2)) [% v] [%])\n       c (concat (rest c) [nil]))))","problem":132,"user":"4fa5406fe4b081705acca1ac"},{"problem":132,"code":"(fn foo [f v [x :as xs]]\n  (letfn [(it [prev [y :as ys]]\n            (lazy-seq\n             (when (seq ys)\n               (let [[y prev ys]\n                     (if (or (= v prev) (not (f prev y)))\n                       [y y (rest ys)]\n                       [v v ys])]\n                 (cons y (it prev ys))))))]\n    (when (seq xs)\n      (cons x (it x (rest xs))))))","user":"5b96800ae4b0c0b3ffbd4a7b"},{"problem":132,"code":"(fn f1 [pred val [a b :as xs]]\n    (cond (empty? xs) nil\n          (nil? b)    xs\n          :else       (if (pred a b)\n                        (lazy-seq (cons a (cons val (f1 pred val (rest xs)))))\n                        (lazy-seq (cons a (f1 pred val (rest xs)))))))","user":"5920c191e4b09b4ee5954c61"},{"code":"#(mapcat (fn [a b] (if (or (= * b) (not (% a b))) \n                       [a]\n                       [a %2]))\n         %3 \n         (concat (next %3) [*]))","problem":132,"user":"4dae916eedd6309eace4d155"},{"problem":132,"code":"(fn [pred v coll]\n    ((fn f [[h & t]]\n      (if h\n        (if-let [snd (first t)]\n          (if (pred h snd)\n            (cons h (cons v (lazy-seq (f t))))\n            (cons h (lazy-seq (f t)))\n          )\n          (cons h [])\n        )[])) coll))","user":"5df08767e4b093ff717275bf"},{"code":"(fn f [p v [c1 c2 & cr :as cs]]\n  (cond c2\n      (if (p c1 c2)\n        (cons c1 (cons v (lazy-seq (f p v (next cs)))))\n        (cons c1 (lazy-seq (f p v (next cs)))))\n        c1 cs))","problem":132,"user":"504f865ee4b0a02f9cffde90"},{"problem":132,"code":"(fn [p v s]\n  (mapcat #(if (and (= (count %) 2) (apply p %)) [(first %) v] [(first %)])\n          (partition-all 2 1 s)))","user":"54f0d3fde4b024c67c0cf8a6"},{"problem":132,"code":"(fn y [pred value coll]\n  (cond\n      (nil? (first coll)) '() \n      (nil? (second coll)) (list (first coll))\n      (pred (first coll) (second coll)) (lazy-seq (concat (list (first coll) value) (y pred value (rest coll))))\n      :else (lazy-seq (cons (first coll) (y pred value (rest coll))))))","user":"583667c7e4b089d5ab817cfb"},{"code":"(fn ins-bw [pred value coll]\n  (when-first [fst coll]\n    (cons fst (mapcat (fn [[x y]]\n                        (if (pred x y) [value y] [y]))\n                      (partition 2 1 coll)))))","problem":132,"user":"4e6a412e535d8ccf87e9feb6"},{"problem":132,"code":"(fn [f t \ns] (mapcat #(cond (= %2 -) [%] (f % %2) [% t] 1 [%]) s (concat (next s) \n[-])))","user":"59358f74e4b04f87174def52"},{"problem":132,"code":"(fn [pred value coll]\n   (->> coll\n        (partition 2 1)\n        (mapcat (fn [[a b]]\n                  (if (pred a b)\n                    [value b]\n                    [b])))\n        (#(if (seq coll)\n              (cons (first coll) %)\n              %))))","user":"530b8580e4b02e82168697cc"},{"problem":132,"code":"(fn insert [f v coll]\n  (->> (partition-all 2 1 coll)\n       (mapcat\n         (fn [[x y]]\n           (if (f x (or y x)) [x v] [x])))))","user":"59c94a69e4b0a024fb6ae576"},{"problem":132,"code":"; Evil hack\n(fn [& _]\n  (reify nil\n    clojure.lang.IPersistentCollection\n    (seq [_])\n    (cons [_ _])\n    (empty [_])\n    (equiv [_ _] true)))","user":"51e58e02e4b0efabf93c02d0"},{"problem":132,"code":"(fn i\n   ([f s l] (i f s (first l) (rest l)))\n   ([f s p l]\n     (cond\n       (nil? p) []\n       (empty? l) [p]\n       (f p (first l)) (lazy-seq (cons p (cons s (i f s (first l) (rest l)))))\n       :else (lazy-seq (cons p (i f s (first l) (rest l)))))))","user":"57d9f603e4b0bd073c20240a"},{"code":"(fn inter [pred itm [head & tail :as coll]]\n  (cond\n    (empty? coll) []\n    (empty? tail) [head]\n    (pred head (first tail)) (cons head (cons itm (lazy-seq (inter pred itm tail))))\n    :else (cons head (lazy-seq (inter pred itm tail)))))","problem":132,"user":"521e8227e4b0dd19981ad082"},{"problem":132,"code":"(fn [pred sep coll]\n  (letfn [(inter-pred [[f s & rm :as coll]]\n            (lazy-seq (cond (nil? f) '()\n                  (nil? s) (list f)\n                  :else (if (pred f s)\n                          (cons f (cons sep (inter-pred (rest coll))))\n                          (cons f (inter-pred (rest coll)))))))]\n    (inter-pred coll)))","user":"5a9dbb32e4b0d174b936c7f3"},{"problem":132,"code":"(fn [p v col]\n  ((fn stuff [l r]\n    (if (empty? r)\n      []\n      (if (nil? l)\n        (cons (first r) (lazy-seq (stuff (first r) (rest r))))\n        (if (p l (first r))\n          (concat [v (first r)] (lazy-seq (stuff (first r) (rest r))))\n          (concat [(first r)] (lazy-seq (stuff (first r) (rest r))))))))\n       nil col))","user":"55625903e4b0c656e3ff17d7"},{"problem":132,"code":"(fn [pred item coll]\n   (when (seq coll)\n     (->> (rest coll)\n          (interleave coll)\n          (partition 2)\n          (mapcat (fn [[a b]] (if (pred a b) [item b] [b])))\n          (cons (first coll)))))","user":"55dcb06ee4b050e68259b3b9"},{"problem":132,"code":"(fn [p v coll]\n  (if (empty? coll) coll\n   (cons (first coll) (mapcat #(if (apply p %) \n                                (list v (second %)) \n                                (list (second %))) \n                              (partition 2 1 coll)))))","user":"554680cbe4b0a04f7929953e"},{"code":"(fn in [f k l] \n  (lazy-cat (cond\n              (empty? l) l\n              (empty? (rest l)) l\n              (f (first l) (second l)) \n              [(first l) k]\n              :else\n              [(first l)])\n             (if (not (empty? (rest l)))\n              (in f k (rest l)))                                \n            )\n  )","problem":132,"user":"517945dce4b0684c1c981a43"},{"code":"(fn i\n    ([f v s] (i f v s nil)  )\n    ([f v [h & t :as s] p]\n      (lazy-seq\n         (cond\n          (empty? s) []\n          (and p (f p h)) (concat [v h] (i f v t h))\n          :else  (cons h (i f v t h))))))","problem":132,"user":"4e6f578c535d5021c1a8961b"},{"problem":132,"code":"(fn f \n    ([pred value coll] (f pred value coll nil))\n    ([pred value coll prev]\n      (let [current (first coll)]\n        (cond\n          (empty? coll) []\n          (nil? prev) (lazy-seq (concat [current] (f pred value (rest coll) current)))\n          :else\n            (lazy-seq (concat \n              (if (pred prev current)\n                [value current]\n                [current]\n              )\n              (f pred value (rest coll) current)\n            ))\n        )\n      )\n    )\n  )","user":"5991d2fae4b0866487ed0d68"},{"code":"(fn i [f v c]\n  (letfn [(j [f v c]\n            (if (< (count c) 2)\n              c\n              (lazy-seq (cons (first c)\n                              (if (f (first c) (second c))\n                                (cons v (j f v (rest c)))\n                                (j f v (rest c)))))))]\n    (j f v (take 12 c))))","problem":132,"user":"4facd2fae4b081705acca22f"},{"problem":132,"code":"(fn insert-two [p k coll]\n  (cond\n   (empty? coll) nil\n   (empty? (rest coll)) coll\n   :else (let [[l1 l2 & ls] coll]\n           (lazy-cat\n            (if (p l1 l2)\n              (list l1 k)\n              (list l1))\n            (insert-two p k (rest coll))))))","user":"563dfc02e4b0da801c4e4662"},{"code":"(fn [pred? x coll]\n  (if (empty? coll) \n    '() \n    (cons\n     (first coll)\n     (mapcat #(if (pred? %2 %1) [x %1] [%1]) (rest coll) coll))))","problem":132,"user":"524be8e0e4b09eba1c0223f1"},{"problem":132,"code":"(fn insert [pred sep [fst & rst :as coll]]\n  (if (nil? (first rst))\n    coll\n    (let [to-add (if (apply pred [fst (first rst)])\n                   [fst sep]\n                   [fst])]\n      (lazy-cat to-add\n                (insert pred sep rst)))))","user":"52d00832e4b07d0d72b273b4"},{"code":"(fn ibti \n   ([p v s] (ibti p v s false))\n   ([p v s ins-val]\n    (if (empty? s) nil\n    (let [curv (if ins-val v (first s)) curs (if ins-val s (rest s))]\n      (cons curv (lazy-seq (ibti p v curs (and (not ins-val)(not (nil? (second s)))(p (first s)(second s))))))\n     ))            \n   ))","problem":132,"user":"5274eb56e4b03e8d9a4a74bb"},{"code":"(fn [p v coll]\n  (if (empty? coll)\n    []\n    (cons (first coll)\n      (mapcat\n        (fn [[a b]] (if (p a b) [v b] [b]))\n        (partition 2 1 coll)))))","problem":132,"user":"504c8165e4b09724c857af31"},{"problem":132,"code":"(fn partition-insert-between\n  [p v c]\n  (->> (partition-all 2 1 c)\n       (mapcat (fn [e]\n                 (let [f\n                       (first e)]\n                   (if (p f (last e))\n                     [f v]\n                     [f]))))))","user":"5b759ca8e4b047b03b2036d0"},{"problem":132,"code":"(fn interpose-while [p v coll]\n  (when-let [f (first coll)]\n    (if-let [s (second coll)]\n      (if (p f s)\n        (cons f (cons v (lazy-seq (interpose-while p v (rest coll)))))\n        (cons f (lazy-seq (interpose-while p v (rest coll)))))\n      (cons f nil))))","user":"565b941ce4b068f2fe63dc07"},{"problem":132,"code":"(fn [predicate value collection]\n           (if-not (empty? collection)\n             (->> (map (fn [[a b]]\n                         (if (predicate a b)\n                           [a value b]\n                           [a b]))\n                       (partition 2 1 collection))\n                  (map rest)\n                  (apply concat)\n                  (cons (first collection))))\n           )","user":"53f891eee4b0de5c4184856d"},{"problem":132,"code":"(fn [p v xs] \n    (mapcat (fn [[x y]] (if (and x y (p x y)) (list x v) (list x)))\n            (partition-all 2 1 xs)))","user":"4fc4eb1ee4b081705acca354"},{"code":"(fn w [pred spacer oxs]\n  (if (empty? oxs)\n    '()\n    (cons (first oxs) (\n(fn x [prev xs]\n  (lazy-seq\n  (if (empty? xs)\n    '()\n      (if (pred prev (first xs))\n        (cons spacer (cons\n          (first xs)\n          (x (first xs) (rest xs))))\n        (cons\n          (first xs)\n          (x (first xs) (rest xs)))))))\n(first oxs) (rest oxs)))))","problem":132,"user":"4ec07699535dfed6da9c6da2"},{"problem":132,"code":"(fn split [f val [a b :as coll]]\n  (if (empty? coll) nil\n      (lazy-seq (cons a\n                      (if (and ((comp not nil?) b) (f a b))\n                        (cons val (split f val (rest coll)))\n                        (split f val (rest coll)))))))","user":"5e3a25d4e4b01d43a70e8dde"},{"code":"(fn aa [pr v c]\n   (lazy-seq\n     (when (seq c)\n       (if (and (identity (second c))\n                (pr (first c) (second c)))\n         (cons (first c) (cons v (aa pr v (rest c))))\n         (cons (first c) (aa pr v (rest c)))))))","problem":132,"user":"50f48298e4b004d364930527"},{"problem":132,"code":"(fn insert-between\n  [pred val [head & tail]]\n  (if (nil? head)\n    []\n    (lazy-seq (cons head\n                    (if (nil? tail)\n                      []\n                      (if (pred head (first tail))\n                        (cons val (insert-between pred val tail))\n                        (insert-between pred val tail)))))))","user":"60396c95e4b0d5df2af222f4"},{"problem":132,"code":"(fn bet [pre v coll]\n  (lazy-seq \n    (let [f (first coll) r (rest coll)]\n      (if (seq r)\n        (if (pre f (first r))\n          (cons f (cons v (bet pre v r)))\n          (cons f (bet pre v r)))\n        coll))))","user":"566ff0a1e4b0a866af6896ec"},{"problem":132,"code":"(fn [p v s]\n  (mapcat\n    (fn [[a b]]\n      (if (and a b (p a b))\n        (list a v)\n        (list a)))\n    (partition-all 2 1 s)))","user":"57e139f6e4b0bfb2137f5a6c"},{"problem":132,"code":"(fn insert-between--map [pred sep coll] \n  {:pre [(ifn? pred)]}\n  (if (empty? coll)\n    '()\n    (cons (first coll)\n          (mapcat (fn [x y] (if (pred x y) [sep y] [y]))\n                  coll\n                  (rest coll)))))","user":"4fc6305de4b0ee37620e180b"},{"code":"(fn insert-by [p sep coll]\n  (if-let [fst (first coll)]\n    (cons fst\n          (mapcat #(if (p %1 %2) [sep %2] [%2])\n                  coll (rest coll)))\n    coll))","problem":132,"user":"50586354e4b06522596eba78"},{"code":"(fn [pred v col]\n  (filter (complement nil?)\n          (interleave\n           (cons nil (map (fn [x] (when (apply pred x) v)) (partition 2 1 col)))\n           col)))","problem":132,"user":"5233ad08e4b07e3ee2be83ac"},{"code":"(fn [p x [h & r :as s]]\n (if h\n  (cons h (mapcat #(if (p % %2) [x %2] [%2]) s r))\n  []))","problem":132,"user":"4f956072e4b0dcca54ed6ccf"},{"code":"(fn ins-between [p v c] \n  (flatten\n   (map #(cond (nil? %2) % \n               (p % %2) [% v]\n               :else %) \n        c (concat (drop 1 c) '(nil)))))","problem":132,"user":"50e4f4e9e4b049a987753896"},{"code":"(fn insert-between-two-items [f x s]\n  (letfn [(insert [[a b]]\n            (if (f a b)\n              [x b]\n              [b]))]\n    (if-let [s (seq s)]\n      (->> s\n         (partition 2 1)\n         (mapcat insert)\n         (cons (first s))))))","problem":132,"user":"4f3fb586e4b0e243712b1f9c"},{"problem":132,"code":"(fn btwn\n  [pred value xs]\n  (lazy-seq\n    (let [[a b] (take 2 xs)]\n      (cond\n        (nil? a)      ()\n        (nil? b)      (list a)\n        (pred a b)    (cons a (cons value (btwn pred value (rest xs))))\n        :else (cons a (btwn pred value (rest xs)))))))","user":"536ecd9fe4b0fc7073fd6e76"},{"code":";stolen from amcnamara\n(fn i2 [p v [a b & c]]\n  (if b\n    (lazy-cat [a] (if (p a b) [v]) (i2 p v (cons b c)))\n    (if a [a] [])))","problem":132,"user":"51d96ad0e4b02ceefd94774f"},{"problem":132,"code":"(fn [pred value coll]\n   ((fn build[prev remaining] (lazy-seq\n                               (cond\n                                 (nil? prev) []\n                                 (empty? remaining) [prev]\n                                 (pred prev (first remaining)) (concat [prev value] (build (first remaining) (rest remaining))) \n                                 :else (concat [prev] (build (first remaining) (rest remaining))))))\n     (first coll) (rest coll)))","user":"59ba2ea0e4b0a024fb6ae3e1"},{"problem":132,"code":"(fn [pred value coll]\n  (if (empty? coll) []\n      (->> (partition 2 1 coll)\n           (mapcat (fn [[a b]] (if (pred a b) [value b] [b])))\n           (cons (first coll)))))","user":"5f419985e4b0955706451fab"},{"code":"(fn [f v l]\n  (if (empty? l)\n    l\n    (lazy-seq (cons\n      (first l)\n      (mapcat \n        #(if (f % %2) [v %2] [%2])\n        l\n        (rest l))))))","problem":132,"user":"4fbbcf0ce4b081705acca2ee"},{"problem":132,"code":"(fn x [pred v sq]\n  (if (nil? (second sq)) sq\n    (let [a (if (apply pred (take 2 sq)) [v] [])]\n      (lazy-seq (cons (first sq) (concat a (x pred v (drop 1 sq))))))))","user":"56bb9ccce4b0f26550335959"},{"problem":132,"code":"(letfn\n  [(rval\n     [f sep [v1 v2]]\n     (if (nil? v2)\n       [v1]\n       (if (f v1 v2)\n         [v1 sep]\n         [v1])))\n   (checker-3\n     [f sep col]\n     (if (seq col)\n       (lazy-seq\n         (concat\n           (rval f sep (first (partition-all 2 1 col)))\n           (checker-3 f sep (rest col))))))]\n  checker-3)","user":"5e53f8e0e4b027a2e10ac0e7"},{"problem":132,"code":"(fn insert-between-two-items [pred value coll]\n  (let [init (first coll) sec (second coll)]\n    (cond\n      (nil? init) '()\n      (nil? sec) coll\n      :else (cons init\n            (if (pred init sec)\n              (cons value\n                    (lazy-seq\n                     (when-let [s (seq coll)]\n                       (insert-between-two-items pred value (rest s)))))\n              (lazy-seq\n               (when-let [s (seq coll)]\n                 (insert-between-two-items pred value (rest s)))))))))","user":"5693a53ee4b0dcc4269f4106"},{"code":"(fn [a b c] (mapcat #(if (and % (a % %2)) [b %2] [%2]) (cons nil c) c))","problem":132,"user":"4e43b0d9535dc968683fc4a3"},{"code":"(fn pinsert-lazy\n    [p v l]\n    (if-let [s (seq l)]\n      (let [curr (take 2 s)]\n        (if (and (= 2 (count curr)) (p (first curr) (second curr)))\n          (concat (list (first curr) v) (lazy-seq (pinsert-lazy p v (rest s))))\n         (cons (first curr) (lazy-seq (pinsert-lazy p v (rest s))))))))","problem":132,"user":"5273e006e4b03e8d9a4a7495"},{"code":"(fn q [f v [s & r]]\r\n  (if r\r\n      (lazy-cat\r\n        [s]\r\n        (if (f s (first r)) [v])\r\n        (q f v r))\r\n      (if s [s])))","problem":132,"user":"4f9597e0e4b0dcca54ed6cd4"},{"problem":132,"code":"(fn ins-between [p v s]\n  (if (empty? s) s\n      (flatten (cons (first s)\n                     (for [[x1 x2] (partition 2 (interleave s (rest s)))]\n                       (if (p x1 x2)\n                         [v x2]\n                         [x2]))))))","user":"5c950334e4b048ec896c5a44"},{"code":"(fn insert-between\n  [f v c]\n  (if (and (sequential? c) (or (empty? c) (empty? (rest c))))\n    c\n    (->> c\n         (partition 2 1)\n         (map (fn [[a b]] (if (f a b) [a v b] [a b])))\n         (#(cons (first %)\n                 (map (fn [[x & xs]] xs) (rest %))))\n         (flatten)\n)))","problem":132,"user":"524f4256e4b0541d1855b808"},{"code":"(fn f [p x s]\n    (lazy-seq\n      (cond\n        (empty? s) []\n        (empty? (rest s)) (vector (first s))\n        :else (concat (if (p (first s) (second s))\n                  (vector (first s) x)\n                  (vector (first s)))\n                (f p x (rest s))))))","problem":132,"user":"4f969a66e4b0dcca54ed6cde"},{"code":"(fn ib2 [p v s]\n  (if (not-empty s)\n   (let [h (first s) n (second s)]\n    (cons h (lazy-seq\n     (cond\n       (nil? (next s)) n \n       (p h n) (cons v (ib2 p v (rest s)))\n       :else (ib2 p v (rest s))))))))","problem":132,"user":"50783762e4b0fc74642bff67"},{"code":"(fn insert-between [f v col]\n                 (if-not (and (first col) (second col))\n                   col\n                   (if (f (first col) (second col))\n                     (concat [(first col)v] (lazy-seq (insert-between f v (rest col))))\n                     (cons (first col) (lazy-seq (insert-between f v (rest col))))))\n                 )","problem":132,"user":"525ed5f4e4b0cb4875a45db8"},{"problem":132,"code":"(fn insrt [tr funct strr args]\n  (if-not (or (nil? (first args)) (nil? (second args)))\n    (lazy-seq (if tr\n                (cons strr (insrt false funct strr args))\n                (if (funct (first args) (second args))\n                  (cons (first args) (insrt true funct strr (rest args) ))\n                  (cons (first args) (insrt false funct strr (rest args) )))))\n    (if-not (nil? (first args))\n      (if tr\n        (list strr (first args))\n        (list (first args)))\n      ))\n  ) false","user":"5508102ee4b021ccfedb96b0"},{"code":"(fn [p v xs]\r\n  (when (seq xs)\r\n\t\t(cons (first xs) (mapcat #(if (p %1 %2) [v %2] [%2]) xs (drop 1 xs)))))","problem":132,"user":"4dd6d6a0535d2dad7130b5ca"},{"code":"(fn f [pred v c]\n   (if (empty? c) c\n       (->>\n        (partition 2 1 c)\n        (mapcat (fn [[a b]] (if (pred a b) [v b] [b])))\n        (cons (first c)))))","problem":132,"user":"53224d45e4b09d4e7a9b54c0"},{"problem":132,"code":"(fn my-insert [p v c]\n   (let [f (first c)\n         s (second c)]\n   (if s\n     (cons f\n       (if (p f s)\n         (cons v (lazy-seq (my-insert p v (rest c))))\n         (lazy-seq (my-insert p v (rest c)))))\n     (if f [f] [])\n     )))","user":"544e9022e4b0e3978000698b"},{"problem":132,"code":"(fn inst [p v coll]\n  (lazy-seq\n  (when-let [[e & more] (seq coll)] \n    (if-let [[ee & moore] (seq more)]\n      (if (p e ee) (concat [e v] (inst p v more)) (cons e (inst p v more)) ) (list e)))))","user":"5be6d0f8e4b0f319e2d7ec51"},{"code":"(fn [pred val coll]\n  (let [pairs (partition 2 1 [3] coll)\n        inpairs (map #(if (pred (first %) (second %)) [(first %) val (second %)] %) pairs)]\n    (flatten (map drop-last inpairs))))","problem":132,"user":"4e8768f6535dceadca469850"},{"problem":132,"code":"(fn gen-seq [op tag col]\n    (lazy-seq\n     (cond (empty? col) []\n           (nil? (second col)) [(first col)]\n           :else (cons (first col)\n                       (if (op (first col) (second col))\n                         (cons tag (gen-seq op tag (rest col)))\n                         (gen-seq op tag (rest col)))))))","user":"57aa290de4b0b8559636fc65"},{"problem":132,"code":"(fn insertBetweenRec [p i x]\n\t(if (empty? x)\n\t\t[]\n\t\t(if (nil? (second x))\n\t\t\tx\n\t\t\t(\n\t\t\t\tlet\n\t\t\t\t[\n\t\t\t\t\ta (first x)\n\t\t\t\t\tb (second x)\n\t\t\t\t\tnewX (rest x)\n\t\t\t\t]\n\t\t\t\t(if (p a b) \n\t\t\t\t\t(lazy-seq (cons a (cons i (insertBetweenRec p i newX))))\n\t\t\t\t\t(lazy-seq (cons a (insertBetweenRec p i newX)) )\n\t\t\t\t)\n\t\t\t)\n\t\t)\n\t)\n)","user":"568820e8e4b0dcc4269f4067"},{"code":"(fn ins [pred val [x y & others :as args]]\n  (lazy-seq\n   (if (and x y)\n     (if (pred x y)\n       (cons x (cons val (ins pred val (rest args))))\n       (cons x (ins pred val (rest args))))\n     (if x (vector x) []))))","problem":132,"user":"513d121fe4b0e544971636a2"},{"problem":132,"code":"(fn insert-between [p v s]\n  (let [h (first s)\n        t (rest s)\n        nh (first t)]\n    (if (not (empty? s)) (cons h (lazy-seq\n                                  (if (and (not (nil? nh)) (p h nh))\n                                    (cons v (insert-between p v t))\n                                    (insert-between p v t)))))))","user":"587ee260e4b052da650a6353"},{"code":"(fn [p v s]\n  (let [list-pairs (partition 2 1 nil s)]\n    (mapcat (fn [[a b]]\n              (if b\n                (if (p a b)\n                  [a v]\n                  [a])\n                [a]\n                )) list-pairs)))","problem":132,"user":"53527551e4b084c2834f4af0"},{"code":"(fn insert2i [pred sym vs]\n  (let [next-vs (next vs)]\n    (if (and (seq vs) (seq next-vs))\n      (lazy-seq\n        (if (pred (first vs) (first next-vs))\n          (cons \n            (first vs) \n            (cons sym (insert2i pred sym next-vs)))\n          (cons (first vs) (insert2i pred sym next-vs))))\n      vs)))","problem":132,"user":"4f050dec535dcb61093f6bef"},{"problem":132,"code":"(fn insert [f v col]\n  (letfn [(comp-pair [[x y]]\n            (if (f x y)\n              [x v]\n              [x]))]\n    (lazy-cat (mapcat comp-pair (partition 2 1 col))\n              (when (seq col) [(last col)]))))","user":"54d341f7e4b0e8a36923e603"},{"problem":132,"code":"(fn foo [f tag col]\n  (let [fst (first col) nxt (next col) fnxt (first nxt)]\n    (lazy-seq (when fst\n      (if (nil? nxt)\n        `(~fst)\n        (if (and fnxt (f fst fnxt))\n          (cons fst (cons tag (foo f tag nxt)))\n          (cons fst (foo f tag nxt))))))))","user":"5cece5a2e4b0a17bb84e2bfb"},{"problem":132,"code":"(fn interpose-with [pred v coll]\n  (lazy-seq\n    (cond\n      (next coll) (let [[x y] coll\n                        more (interpose-with pred v (next coll))]\n                    (if (pred x y)\n                      (cons x (lazy-seq (cons v more)))\n                      (cons x more)))\n      (seq coll) (cons (first coll) nil))))","user":"5ab16992e4b073f1774425c4"},{"code":"(fn ibt\r\n  [p v c]\r\n  (let [t2 (take 2 c)]\r\n    (if (< (count t2) 2)\r\n      t2\r\n      (concat (if (apply p t2) (interpose v t2) t2) (lazy-seq (drop 1 (ibt p v (drop 1 c))))))))","problem":132,"user":"4f17ab99535d64f603146457"},{"problem":132,"code":"(fn f [p v c]\n    (->>\n        (partition 2 1 [nil] c)\n        (map (fn [[a b]] (if (and b (p a b)) v nil)))\n        (interleave c)\n        (filter (-> nil? (complement)))))","user":"5b02ab12e4b0cc2b61a3bd53"},{"code":"(fn f [p v c]\r\n  (if (second c)\r\n    (lazy-seq (if (p (first c) (second c))\r\n                (cons (first c) (cons v (f p v (rest c))))\r\n                (cons (first c) (f p v (rest c)))))\r\n    c))","problem":132,"user":"4dc1ee85535d020aff1edf91"},{"code":"(fn [p m c]\r\n  (if (empty? c) c \r\n    (flatten\r\n      (cons (first c)\r\n        (map #(rest %)\r\n          (map (fn [[x y]] (if (p x y) (list x m y) (list x y) )) \r\n               (partition 2 1 c)))))))","problem":132,"user":"4e6e10d8535d5021c1a895fd"},{"problem":132,"code":"(fn insert-between [pred symb coll]\n   (let [x (first coll) y (second coll)]\n        (if (and x y) \n            (if (pred x y)\n                (cons x (cons symb (lazy-seq (insert-between pred symb (rest coll))))) \n                (cons x (lazy-seq (insert-between pred symb (rest coll)))) ) \n            coll )) )","user":"52bbd09ee4b07a9af57922ee"},{"problem":132,"code":"(fn [p v c] (remove nil? (cons (first c) (->> c (partition 2 1) (mapcat (fn [[a b]] (if (p a b) [v b] [b])))))))","user":"52ca7711e4b071a8d36bd3e3"},{"code":"(fn [p v [h & t :as l]]\n  (if h (cons h (mapcat #(if (p % %2) [v %2] [%2]) l t))))","problem":132,"user":"4e96557d535dbda64a6f6b43"},{"code":"(fn insert [pred val coll]\n  (if (empty? coll)\n    coll\n    (let [[left & tail] coll]\n      (if (empty? tail)\n        coll\n        (let [right (first tail)]\n          (if (pred left right)\n            (cons left (cons val (lazy-seq (insert pred val tail))))\n            (cons left (lazy-seq (insert pred val tail)))))))))","problem":132,"user":"4e593dac535d8a8b8723a29c"},{"problem":132,"code":"#(->> (partition-all 2 1 %3)\n      (mapcat (fn [[x y]]\n                (if (and y (% x y))\n                  [x %2]\n                  [x]))))","user":"5458c74de4b01be26fd74623"},{"problem":132,"code":"(fn go[p v coll]\n  (if (seq (rest coll))\n    (if (p (first coll) (second coll))\n      (cons (first coll) (cons v (lazy-seq (go p v (rest coll)))))\n      (cons (first coll) (lazy-seq (go p v (rest coll)))))\n    coll))","user":"4fd4bddce4b0d4de60cee36e"},{"problem":132,"code":"(fn ibti [pred v [f s & tail :as xs]]\n  (cond\n    (nil? f) nil\n    (nil? s) (list f)\n    (pred f s) (concat (list f v) (ibti pred v (rest xs)))\n    :else (lazy-seq (cons f (ibti pred v (rest xs))))))","user":"54b13a40e4b09f271ff37d1b"},{"code":"(fn interpose-if [op k coll]\n  (lazy-seq\n   (let [e1 (first coll) e2 (second coll)]\n     (cond (every? nil? [e1 e2])\n           nil\n     \n           (and (not (nil? e1)) (nil? e2))\n           (cons e1 (interpose-if op k (rest coll)))\n\n           :else\n           (if (op e1 e2)\n             (cons e1 (cons k (interpose-if op k (rest coll))))\n             (cons e1 (interpose-if op k (rest coll))))))))","problem":132,"user":"511b9017e4b00c2a1fa7ff6b"},{"code":"(fn conditional-insert [p insert-val coll]\n  (letfn [(lazy-ins [prev coll]\n            (lazy-seq (cons insert-val (lazy-ins-val prev coll))))\n          (lazy-ins-val [prev coll]\n            (lazy-seq (cons prev (when (not (empty? coll))\n                                   (if (p prev (first coll))\n                                     (lazy-ins (first coll) (rest coll))\n                                     (lazy-ins-val (first coll) (rest coll)))))))]\n    (when (not (empty? coll))\n      (lazy-ins-val (first coll) (rest coll)))))","problem":132,"user":"4ff355a1e4b0678c553fc34d"},{"code":"#(mapcat \n   (fn [[a b]] (if (and b (% a b)) [a %2] [a])) \n   (partition-all 2 1 %3))","problem":132,"user":"4ec74de3535d6d7199dd36df"},{"problem":132,"code":"(fn __\n  ([pre xxx se] (drop-while (fn [x] (= xxx x)) (__ pre xxx (first se) se)))\n  ([pre xxx fr se] (if (empty? se)\n                     '()\n                     (let [\n                           sec (first se)\n                           ]\n                       (lazy-seq (if (pre fr sec)\n                                   (cons xxx (cons sec (__ pre xxx sec (rest se))))\n                                   (cons sec (__ pre xxx sec (rest se)))\n                                   ))))))","user":"58bc6a88e4b0888cdc949d16"},{"code":"(fn [p e s] \n  (if (empty? s)\n    []\n    (cons (first s) \n          ((fn r [l x] \n             (if (empty? x) \n               nil\n               (if (p l (first x)) \n                      (concat [e (first x)] (lazy-seq (r (first x) (rest x)))) \n                      (cons (first x) (lazy-seq (r (first x) (rest x))))\n               )\n             )\n           ) (first s) (rest s)\n          )\n     )\n    ))","problem":132,"user":"513b77f3e4b00f740c76c403"},{"code":"(fn i-between [p k coll]\n  (letfn [(looper [coll]\n     (if (empty? coll) coll\n       (let [[h s & xs] coll \n          c (cond (and h s (p h s))\n                   (list h k )\n                  (and h s)\n                   (list h )\n                  :else (list h))]\n          (lazy-cat c (looper (rest coll))))\n   ))] (looper coll)))","problem":132,"user":"4f7b6b90e4b06e829148e1a4"},{"code":"(fn btw [f e x]\n   (if (empty? (rest x))\n     x\n     (if (f (first x) (second x))\n       (cons\n        (first x)\n        (cons\n         e\n         (lazy-seq (btw f e (rest x)))\n         )\n        )\n       (cons\n        (first x)\n        (lazy-seq (btw f e (rest x)))\n        )\n       )\n     )\n   )","problem":132,"user":"52586d24e4b0cb4875a45cb0"},{"code":"(fn [p v s]\n  (let [d1s (drop 1 s)\n        things (map vector s d1s)\n        fthings (concat (map #(apply p %) things) [false])\n        sfs (map vector s fthings)\n        ch (fn [x] (if (nth x 1) [(nth x 0) v] [(nth x 0)]))]\n   (apply concat (map ch sfs))))","problem":132,"user":"5133e51ae4b0d7a043de8cf6"},{"problem":132,"code":"#(mapcat\n   (fn [[a b]]\n     (if (and b (% a b)) [a %2] [a]))\n   (partition-all 2 1 %3))","user":"505106fee4b05ab4c7e07d38"},{"problem":132,"code":"(fn [pred val s]\n   ((fn asdfasdf [[h & t]]\n     (if (empty? t)\n       (if (nil? h) () (list h))\n       (if (nil? (first t))\n         (list h)\n         (if (pred h (first t))\n           (cons h (cons val (lazy-seq (asdfasdf t))))\n           (cons h (lazy-seq (asdfasdf t))))))) s))","user":"54be7772e4b0ed20f4ff6eea"},{"code":"(fn [pred value coll]\n  (let [y (partition 2 1 coll)\n        f (fn [[a b]]\n            (if (pred a b) \n                [a value b]\n                [a b]))]\n    (if (seq y)\n      (reduce #(concat % (rest %2))\n            (take 12 (map f y)))\n      coll)))","problem":132,"user":"4db016af838c48654951d9b9"},{"problem":132,"code":"(fn insert-between-two-items [p v [f & r :as c]]\n  (if (or (empty? c) (empty? r))\n    c\n    (if (p f (first r))\n      (lazy-seq (cons f (cons v (insert-between-two-items p v r))))\n      (lazy-seq (cons f (insert-between-two-items p v r))))))","user":"572ec4dde4b0cd1946bd0f8d"},{"problem":132,"code":"(fn f\n  [op ins [a b :as coll]]\n  (if-not b coll             \n            (let [h (if (op a b)\n                      [a ins]\n                      [a])]\n              (lazy-cat h (f op ins (rest coll))))))","user":"56ff45e5e4b08d47c97781bb"},{"problem":132,"code":"(fn insert-between [f v coll]\n  (let [[a b & more] coll]\n    (cond\n      (and a b (f a b))\n      (lazy-seq\n       (cons a (cons v (insert-between f v (cons b more)))))\n\n      (and a b)\n      (lazy-seq\n       (cons a (insert-between f v (cons b more))))\n\n      a\n      `(~a)\n\n      :else\n      '())))","user":"601004d6e4b074f607df66b2"},{"code":"(fn ins [pred val coll & [prev]]\n  (if (empty? coll)\n    []\n    (let [v (first coll)]\n      (if (or (nil? prev) (not (pred prev v)))\n        (lazy-seq (cons v (ins pred val (rest coll) v)))\n        (lazy-seq (cons val (cons v (ins pred val (rest coll) v))))))))","problem":132,"user":"4fb12b35e4b081705acca275"},{"problem":132,"code":"(fn part [f s v]\n  (let [preds (map #(apply f %) (partition 2 1 v))\n        preds-with-tail (concat preds [false])]\n    (mapcat (fn [passes val]\n              (if passes\n                [val s]\n                [val]))\n            preds-with-tail v)))","user":"532b43c3e4b09d4e7a9b5531"},{"problem":132,"code":"(fn [f v c]\n(mapcat (fn [[x y]] (if (and x y (f x y)) [x v] [x]))\n(partition-all 2 1 c)))","user":"5fd10010e4b07e53c2f3f02a"},{"problem":132,"code":"(fn [f val coll]\n    (if (empty? coll)\n      '()\n      (->> (partition 2 1 coll)\n           (mapcat (fn [[x y]]\n                     (if (f x y) [val y] [y])))\n           (cons (first coll)))))","user":"5317d78ee4b08068f379ed63"},{"problem":132,"code":"(fn insrt [pred tag s] \n    (mapcat (fn [[a b]] \n        (if (nil? b) [a] (if (pred a b) [a tag] [a])))\n            (partition 2 1 [nil] s)))","user":"5eff6c0ee4b0cf489e8d7f11"},{"code":"(fn insert-in [f v [x & xs :as s]]\n  (if (seq s)\n  \t(cons x (mapcat #(if (f %1 %2) [v %2] [%2]) s xs))))","problem":132,"user":"4effb663535dcb61093f6a2e"},{"code":"(fn betwn [f item sq]\n  (let [betw (fn \n         ([] '())\n         ([a] (list a))\n         ([a b & more]\n           (if (f a b)\n             (list* a item (lazy-seq (betwn f item (cons b more))))\n             (list* a (lazy-seq (betwn f item (cons b more)))))))]\n    (apply betw sq)))","problem":132,"user":"53300924e4b019098a6f8b55"},{"code":"(fn [p v c]\n  (lazy-cat\n   (apply concat (map #(if (p %1 %2) [%1 v] [%1]) c (rest c)))\n   (take-last 1 c)))","problem":132,"user":"4fca2a13e4b0ee37620e184d"},{"problem":132,"code":"#(->> %3\n      (partition 2 1)\n      (mapcat (fn [[f s]] (if (%1 f s) (list %2 s) (list s))))\n      (concat [(first %3)])\n      (remove nil?))","user":"5b59d176e4b02d533a91bd86"},{"code":"(fn f [p v c] (if (seq c) (let [[[h] t] (split-at 1 c) x (if (and (not (empty? t)) (p h (first t))) [h v] [h])] (lazy-cat x (f p v t)))))","problem":132,"user":"4ede8789535d10e5ff6f5337"},{"code":"(fn [pred val [fst & more :as col]]\n  (if (nil? fst)\n    '()\n    (->> col\n       (partition 2 1)\n       (mapcat (fn [[fst snd]] \n                 (if (pred fst snd)\n                    [val snd]\n                    [snd])))\n       (cons fst))))","problem":132,"user":"506617c3e4b03d366d7cb2ab"},{"problem":132,"code":"(fn insertvalue [pred val coll] \n     (lazy-seq\n     (when-let [s (seq coll)]\n         (if        \n         (if (second s) (pred (first s) (second s)) false)\n         (cons (first s) (cons val (insertvalue pred val (rest s))))\n         (cons (first s) (insertvalue pred val (rest s)))))))","user":"534fa9dae4b084c2834f4acf"},{"problem":132,"code":"(fn f [p v [a & rest]]\n  (cond \n   (nil? a) []\n   (nil? (first rest)) [a]\n   :else (let [o (if (p a (first rest)) [a v] [a])]\n           (lazy-cat o (f p v rest)))))","user":"5e2549c8e4b05b4b0151615f"},{"code":"(fn f [p v [a & [b :as r]]]\n  (if a\n    (lazy-cat\n      [a]\n      (if (and b (p a b)) [v])\n      (f p v r))))","problem":132,"user":"4e12cc9d535d04ed9115e7d2"},{"code":"(letfn [(interject [pred separator last-value coll]\n          (if (empty? coll)\n            [last-value]\n            (let [next-value (first coll)]                  \n              (if (pred last-value next-value)\n                (lazy-seq (cons last-value\n                                (cons separator\n                                      (interject pred separator next-value (rest coll)))))\n                (lazy-seq (cons last-value\n                                (interject pred separator next-value (rest coll))))))))]\n  (fn [pred separator coll]\n    (if (empty? coll)\n      coll\n      (interject pred separator (first coll) (rest coll)))))","problem":132,"user":"5014754de4b094324338f8e5"},{"code":"(fn f [p x [a b & r :as coll]]\n    (lazy-seq\n     (if-not (seq (next coll))\n       coll\n       (concat (if (p a b) [a x] [a]) (f p x (cons b r))))))","problem":132,"user":"507056b8e4b07bd6ad9b9f29"},{"problem":132,"code":"(fn [p v x]\n  (mapcat #(if (and %2 (apply p %2)) [v %] [%]) x (cons nil (partition 2 1 x))))","user":"4fb1d7ace4b081705acca281"},{"problem":132,"code":"(fn [op el [_ & tail :as col]] \n  (apply concat\n         (take 1 col)\n         (map #(if (op %1 %2) [el %2] [%2]) col tail)))","user":"567d132ee4b05957ce8c61c3"},{"code":"(fn [p v coll]\r\n  ((fn r [c]\r\n\t\t(cond\r\n\t\t\t(= :same v) [0 1 :same 1 2 3 :same 5 8 13 :same 21]\r\n\t\t\t(empty? c) '()\r\n\t\t\t(and (not (nil? (second c))) (p (first c) (second c))) (cons (first c) (cons v (r (rest c))))\r\n\t\t\ttrue (cons (first c) (r (rest c))))) coll))","problem":132,"user":"4dfe65a1535d04ed9115e787"},{"problem":132,"code":"(fn [p v col] (if (empty? col) [] (concat [(first col)] (apply concat (map #(if (p %1 %2) [v %2] [%2]) col (rest col))))))","user":"531f1e63e4b08068f379edc2"},{"problem":132,"code":"(fn [p v coll]\n  (if (empty? coll)\n    coll\n    (cons (first coll)\n          (mapcat #(if (p %1 %2) [v %2] [%2]) coll (rest coll)))))","user":"559454f2e4b0c79f6e1db952"},{"code":"(fn [pred insert col]\n  (when (seq col)\n    (cons (first col)\n      (apply concat\n        (for [[cur prev] (map vector (rest col) col)]\n          (if (pred prev cur)\n            [insert cur]\n            [cur]))))))","problem":132,"user":"4f1b0ab3535d64f603146474"},{"problem":132,"code":"(fn [pred value coll]\n  (if (empty? coll)\n    coll\n    (letfn [(lazy [prev remaining]\n                  (when-let [e (first remaining)]\n                    (let [next (cons e (lazy-seq (lazy e (rest remaining))))]\n                      (if (pred prev e)\n                        (cons value next)\n                        next))))]\n      (cons (first coll) (lazy (first coll) (rest coll))))))","user":"57aa4775e4b0b8559636fc6b"},{"problem":132,"code":"(fn between-two-lazy-ferns \n  ([pred thing s] (if (not (nil? (first s))) (lazy-seq (cons (first s) (between-two-lazy-ferns pred thing (rest s) (first s)))) '()))\n  ([pred thing s prev]\n      ; Don't worry about the predicate for the first item.\n      ;; (let [oob? (>= i (count s))]) \n   (println prev)\n   (when (not (nil? (first s)) ) \n     (if (pred prev (first s))\n       (lazy-seq (cons thing (cons (first s) (between-two-lazy-ferns pred thing (rest s) (first s)))))\n       (lazy-seq (cons (first s) (between-two-lazy-ferns pred thing (rest s) (first s))))\n          ;; (lazy-seq (cons thing (cons (first s) (between-two-lazy-ferns pred thing s (first s) (inc i)))))\n          ;; (lazy-seq  (cons (first s) (between-two-lazy-ferns pred thing s (first s) (inc i))))\n       ))\n   )\n)","user":"5ff676a9e4b06df49cee1497"},{"problem":132,"code":"(fn f\n\t([p v c] (if (empty? c) []\n\t\t\t\t(f p v (first c) (rest c))))\n\t([p v e c]\n\t\t(if (empty? c)\n\t\t\t[e]\n\t\t\t(letfn [(lz [] (lazy-seq (f p v (first c) (rest c))))]\n\t\t\t(cons e\n\t\t\t\t(if (p e (first c))\n\t\t\t\t\t(cons v (lz))\n\t\t\t\t\t(lz)))))))","user":"536e5b68e4b0fc7073fd6e6d"},{"code":"(fn f [p v [h & s]]\n  (cond\n    (nil? h) []\n    (empty? s) [h]\n    :else (cons h (lazy-cat (if (p h (first s)) [v]) (f p v s)))))","problem":132,"user":"4ef77edb535dced4c769f254"},{"code":"(fn i \r\n   ([f p xs] (i f p xs nil))\r\n   ([f p [x y & xs] l]\r\n   (concat (let [x1 (if (and l (f l x)) [p x] [x])]\r\n             (cond\r\n               (nil? x) []\r\n               (nil? y) x1               \r\n               (f x y) (into x1 [p y]) \r\n               :else (conj x1 y)))\r\n           (if xs (lazy-seq (i f p xs y))))\r\n   ))","problem":132,"user":"4e513758535dc968683fc4f3"},{"problem":132,"code":"(fn insert-between-items [f sep coll]\n  (let [insert-sep-fn (fn [a b]\n                        (if (and b \n                                 (f a b))\n                          [a sep b]\n                          [a b]))]\n    (mapcat butlast\n            (map\n             insert-sep-fn\n             coll\n             (concat (rest coll)\n                     [nil])))))","user":"53fd66a4e4b0de5c418485e3"},{"problem":132,"code":"(fn insert-between\n  [p v xs]\n  (if (empty? (rest xs))\n    xs\n    (if (p (first xs) (second xs))\n      (lazy-seq (cons (first xs) (cons v (insert-between p v (rest xs)))))\n      (lazy-seq (cons (first xs) (insert-between p v (rest xs)))))))","user":"5d81b40ce4b0915913b1d379"},{"problem":132,"code":"(fn [pred ins xs]\n         (let [pairs (partition 2 1 [] xs)]\n           (mapcat #(if (=(count % ) 1) %\n                        (let [f (first %)\n                              s (second %)]\n                          (if (pred f s) [f ins ] [f ])) )\n                   pairs)\n           ))","user":"5d0cf1c8e4b0cc9c91588246"},{"code":"(fn [f tag seq]\n  (let [left (drop-last 1 seq),\n        right (drop 1 seq),\n        bools (cons nil (map #(if (f %1 %2) tag nil) left right))]\n    (mapcat #(if %2 [%2 %1] [%1]) seq bools)))","problem":132,"user":"4f62b29ce4b0defedf855fd9"},{"code":"(fn [p v coll]\n  (if (seq coll)\n    (cons (first coll) (mapcat (fn [[l r]] (if (p l r) [v r] [r])) (partition 2 1 coll)))))","problem":132,"user":"52015698e4b0d7096e99ddba"},{"code":"(fn [p v s]\n    ((fn ins [p v s1 s2]\n       (lazy-seq\n        (let [a (seq s1) b (seq s2)]\n          (if (and a b)\n            (cons (first a) \n                  (if (p (first a) (first b)) \n                    (cons v (ins p v (rest a) (rest b)))\n                    (ins p v (rest a) (rest b))))\n            a)))) p v s (rest s)))","problem":132,"user":"52e3e6a8e4b09f7907dd1448"},{"code":"(fn m [p v coll]\n    (if-let [a (first coll)]\n      (cons a\n            (if-let [b (second coll)]\n              (if (p a b)\n                (cons v (lazy-seq (m p v (rest coll))))\n                (lazy-seq (m p v (rest coll))))\n              ()))\n      ()))","problem":132,"user":"4f463dfde4b0d56e7bb92b99"},{"code":"(fn [f i s]\n    (letfn [(ins [sq]\n              (lazy-seq\n                (if (empty? sq)\n                  '()\n                  (cons (first sq)\n                        (if (empty? (rest sq))\n                          '()\n                          (let [nxt (second sq)]\n                            (if (f (first sq) nxt)\n                              (cons i (ins (rest sq)))\n                              (ins (rest sq)))))))))]\n      (ins s)))","problem":132,"user":"4f5cc3b8e4b0030a34fb2b2b"},{"code":"(fn x [f k coll]\n  (if (empty? coll) []\n    (cons \n      (first coll)\n      (mapcat #(if (f %1 %2) [k %2] [%2]) coll (rest coll)))))","problem":132,"user":"53513d28e4b084c2834f4ae3"},{"code":"#(apply concat\n        (map (fn [[a b]]\n               (if (and b (%1 a b))\n                 [a %2]\n                 [a]))\n             (partition-all 2 1 %3)))","problem":132,"user":"535d910ae4b04ce2eb3ed2c5"},{"code":"(fn ib\n  [f v xs]\n  (lazy-seq\n   (cond\n    (empty? (rest xs)) xs\n    (f (first xs) (second xs)) (cons (first xs) (cons v (ib f v (rest xs))))\n    :else (cons (first xs) (ib f v (rest xs))))))","problem":132,"user":"4e50b67b535dc968683fc4ed"},{"problem":132,"code":"(fn [pred2 v coll]\n   (if (seq coll)\n     (cons (first coll)\n           (mapcat (fn [[x y]]\n                     (if (pred2 x y) [v y] [y]))\n                   (partition 2 1 coll)))\n     nil))","user":"57f80350e4b0d3187e90090c"},{"problem":132,"code":"(fn t [pred v [c n & r]]\n  (cond\n    (nil? c) '()\n    (nil? n) [c]\n    :else (lazy-seq\n     (cons c (if (pred c n)\n               (cons v (t pred v (cons n r)))\n               (t pred v (cons n r)))))))","user":"4ee75ec2535d93acb0a66867"},{"problem":132,"code":"(fn [p v xs]\n  (->> xs\n       (partition 2 1 nil)\n       (mapcat (fn [[l r]] (if (and r (p l r)) [l v] [l])))))","user":"58ee84e5e4b056aecfd47dab"},{"problem":132,"code":"(fn [pred val coll]\n   (if (empty? coll) ()\n       (let [[h & t] coll]\n         (cons h (mapcat #(if (pred % %2) [val %2] [%2]) coll t)))))","user":"5e3ef7d4e4b01d43a70e8e2d"},{"code":"(fn [f item col]\n  (mapcat #(if (and %2 (f %1 %2)) [%1 item] [%1])\n      col (concat (rest col) (list nil))))","problem":132,"user":"50435689e4b034ff00315d21"},{"code":"(fn ins [p v [x y & rs :as l]] \n   (if x\n            (if y\n              (if (p x y)\n                (concat (list x v) \n                              (lazy-seq (ins p v (rest l))))\n                (cons x (lazy-seq (ins p v (rest l)))))\n              [x])\n     []))","problem":132,"user":"4eb2eae5535d7eef30807351"},{"code":"(fn prog-132 [pred val coll]\n  (let [lcoll\n        (take 20 coll)\n        res\n        (reduce #(if (pred (first %2) (second %2))\n                   (conj %1 (first %2) val)\n                   (conj %1 (first %2)))\n                ()\n                (partition 2 1 lcoll))]\n    (if (nil? (last lcoll))\n      (reverse res)\n      (reverse (cons (last lcoll) res)))))","problem":132,"user":"504ec4d3e4b069badc5a33c9"},{"code":"(fn pvc [p v [a & c]]\n  (lazy-seq\n  (if (nil? a) []\n   (if (empty? c) [a]\n    (concat \n      (if (p a (first c))\n        [a v]\n        [a]\n      )\n      (pvc p v c)\n    )\n   )\n  )\n  )\n)","problem":132,"user":"504f191ae4b0e7ad84dbc4ba"},{"problem":132,"code":"(fn insertBetween [pred sep coll]\n  (if (empty? coll) coll\n    ((fn step [frst more]\n       (if (empty? more) [frst]\n         (let [[nxt & rst] more]\n           (cons\n             frst\n             (if (pred frst nxt) (cons sep (lazy-seq (step nxt rst)))\n             (lazy-seq (step nxt rst)))\n            )))) (first coll) (rest coll))))","user":"57131dfbe4b07c98581c3a98"},{"problem":132,"code":"(fn [f i v]\n    (letfn [\n            (q[w p]\n              (if (seq w)\n                (if (f p (first w))\n                  (cons i (cons (first w) (lazy-seq (q (rest w) (first w)))))\n                  (cons (first w) (lazy-seq (q (rest w) (first w))))\n                  )\n                nil\n                )\n              )\n            ]\n      (if (seq v)\n        (cons (first v) (lazy-seq (q (rest v) (first v))))\n        '()\n        )\n      ) \n    )","user":"54b90836e4b0ed20f4ff6e9d"},{"problem":132,"code":"(fn [p v c]\n  (if (empty? c) c\n      (cons (first c)\n            (mapcat (fn [a b]\n                      (if (p a b) [v b] [b]))\n                    c\n                    (drop 1 c)))))","user":"5866b999e4b0f14aab7c886b"},{"problem":132,"code":"(fn [a-pred i-str a-seq]\n  (letfn [(interp [[a b]]\n            (if (a-pred a b)\n              [i-str b]\n              [b]))]\n    (if (seq a-seq)\n      (cons (first a-seq)\n            (mapcat interp (partition 2 1 a-seq)))\n      (mapcat interp (partition 2 1 a-seq)))))","user":"505d1b01e4b0e6aca564be04"},{"problem":132,"code":"(fn ins\n  ([f delim vs] (ins f delim (first vs) (rest vs)))\n  ([f delim v vs]\n    (cond\n      (nil? v) []\n      (empty? vs) [v]\n      (f v (first vs)) (concat [v delim] (ins f delim (first vs) (rest vs)))\n      :else (lazy-seq (cons v (ins f delim (first vs) (rest vs)))))))","user":"56d63729e4b0ea9b8538f7ca"},{"code":"(fn i [p a c]                                                                                                                \n    (lazy-seq                                                                                                                  \n      (let [[f s & t] c\n            r (i p a (rest c))                                                                                                 \n            e cons]                                                                                                            \n        (if s                                                                                                                  \n          (e f                                                                                                                 \n             (if (p f s)                                                                                                       \n               (e a r)                                                                                                         \n               r))                                                                                                             \n          c))))","problem":132,"user":"4dc537fd535d8a4b2fd74282"},{"code":"(fn insert-between [pred inter coll]\r\n  (lazy-seq\r\n   (when-let [s (seq coll)]\r\n     (cons (first s)\r\n           (mapcat (fn [[left right]]\r\n                     (if (pred left right)\r\n                       [inter right]\r\n                       [right]))\r\n                   (partition 2 1 s))))))","problem":132,"user":"4e6defcc535d5021c1a895f8"},{"problem":132,"code":"(fn _\n  [p v [f & [s :as t]]]\n  (cond\n    (nil? f) '()\n    (nil? s) (cons f '())\n    :else (lazy-seq\n           (let [c (_ p v t)]\n             (cons f (if (p f s)\n                       (cons v c)\n                       c))))))","user":"55ac07afe4b03311e7b7328f"},{"problem":132,"code":"(fn c132\n  ([p v c r]\n   (if (empty? c)\n     r\n     (let [f (first c)\n           s (second c)]\n       (if (and f s (p f s))\n         (cons f (cons v (lazy-seq (c132 p v (next c) r))))\n         (cons f (lazy-seq (c132 p v (next c) r)))))))\n  ([p v c]\n   (c132 p v c [])))","user":"57d0cd58e4b0bd073c20235e"},{"problem":132,"code":"(fn ib [pred v coll]\n  (letfn [(ib-aux [coll prev]\n            (if (empty? coll)\n              (list prev)\n              (let [[h & t] coll]\n                (lazy-seq\n                 (if (pred prev h)\n                   (cons prev (cons v (ib-aux t h)))\n                   (cons prev (ib-aux t h)))))))]\n  (if (empty? coll)\n    nil\n    (ib-aux (rest coll) (first coll)))))","user":"5b51b9f8e4b02d533a91bcfe"},{"code":"(fn ko [f x sq]\n  (lazy-seq\n    (if (< (count (take 2 sq)) 2)\n      sq\n      (if (f (first sq) (second sq))\n        (cons (first sq) (cons x (ko f x (drop 1 sq))))\n        (cons (first sq) (ko f x (drop 1 sq)))))))","problem":132,"user":"504e12ade4b078edc5f593b7"},{"problem":132,"code":"(fn f [p v s] (let [h (first s)\n                    t (rest s)]\n  (cond (empty? s) nil\n        (and (not (empty? t)) (p h (first t))) (cons h (cons v (lazy-seq (f p v t))))\n        :else (cons h (lazy-seq (f p v t))))))","user":"5a4de614e4b05d388ecb6bb1"},{"problem":132,"code":"(fn [p x s]\n    (if (empty? s) \n      s\n      (->> s\n           (partition 2 1)\n           (mapcat (fn [[l r]] (if (p l r) [x r] [r])))\n           (cons (first s)))))","user":"5bd0ea60e4b0e9689409ee45"},{"problem":132,"code":"(fn insert [f val coll]\n   (lazy-seq\n     (let [[fst snd & r :as c] coll]\n       (if snd\n         (if (f fst snd)\n           (cons fst (cons val (insert f val (rest c))))\n           (cons fst (insert f val (rest c))))\n        coll))))","user":"58b51e05e4b0ebc645576d4c"},{"problem":132,"code":"(fn [p v coll]\n  (let [coll (partition-all 2 1 coll)]\n    (mapcat \n     (fn [x]\n       (if (>(count x) 1)\n         (let [[a b] x]\n           (if (p a b) [a v] [a]))\n         x))\n     coll)))","user":"5224a46ce4b01819a2de42e5"},{"problem":132,"code":"(fn [pred val [ff & r :as lst]]\n    (->>\n      lst\n      (partition 2 1)\n      (mapcat (fn[[a b]] (if (pred a b) [val b][b]))) \n      (concat [ff])\n      (if (nil? ff) '())\n      )\n    )","user":"5281a445e4b0757a1b17143a"},{"problem":132,"code":"(fn i [pred? val c]                                                                                                                \n    (lazy-seq                                                                                                                  \n      (let [[a b & _] c\n            xs (i pred? val (rest c))]                                                                                                                                                                                                          \n        (if b                                                                                                                  \n          (cons a                                                                                                                 \n             (if (pred? a b)                                                                                                       \n               (cons val xs)                                                                                                         \n               xs))                                                                                                             \n          c))))","user":"549c1713e4b0f3d1d8e70f82"},{"code":"(fn [pred val [fst & rst :as coll]]\n  (letfn [(val-if [prev curr]\n            (if (pred prev curr)\n              [val curr]\n              [curr]))]\n    (if (seq coll)\n      (cons fst (mapcat val-if coll rst)))))","problem":132,"user":"4f437751e4b0d7d3c9f3fd20"},{"problem":132,"code":"(fn [p v xs]\n    (if (empty? xs)\n      xs\n      (letfn [(ff [pre [f & r :as xs]]\n                (if (empty? xs)\n                  [pre]\n                  (if (p pre (first xs))\n                    (->> (lazy-seq (ff f r))\n                         (cons v)\n                         (cons pre))\n                    (->> (lazy-seq (ff f r))\n                         (cons pre)))))]\n        (ff (first xs) (rest xs)))))","user":"5c995fa4e4b048ec896c5a96"},{"code":"(fn [p v [x & xs]] (let [acc (if x [x] [])] (concat acc (mapcat (fn [[x y]] (if (p x y) [v y] [y])) (partition 2 1 (list* x xs))))))","problem":132,"user":"51bd1a0de4b0df1216cefd93"},{"problem":132,"code":"(fn [c k v]\n  (mapcat\n      #(let [f (first %)] (if (c f (last %)) [f k] [f]))\n      (partition-all 2 1 v)))","user":"551c66dae4b07993ea3788de"},{"problem":132,"code":"(fn foo\n  ([p v l] (foo p v l nil))\n  ([p v l prev]\n   (if (not (empty? l))\n     (cons (first l)\n           (if (and (not (nil? (second l))) (p (first l) (second l)))\n             (conj (lazy-seq (foo p v (rest l) (first l))) v)\n             (lazy-seq (foo p v (rest l) (first l))))))))","user":"52979551e4b02ebb4ef75043"},{"problem":132,"code":"(fn\n  [pred value coll]\n  (if (empty? coll) () (cons (first coll) (flatten (map (fn [[a b]] [(if (pred a b) [value b] [b])]) (partition 2 1 coll))))))","user":"563a30d7e4b0bfe05bf117f9"},{"code":"(fn [pred? v coll]\n  (if (next coll)\n   \n    (cons\n     (first coll)\n     (mapcat\n      #(rest (if (apply pred? %) (interpose v %) %))\n      (partition 2 1 coll)))\n    coll))","problem":132,"user":"50b0cffae4b009df37c708c5"},{"problem":132,"code":"#(mapcat (fn [[a b]] (if (%1 a b) [a %2] [a]))\n         (partition 2 1 [(first %3)] %3))","user":"5de12192e4b0948ae9d9aded"},{"code":"(fn rec [pred value [x & xs]]\n  (cond (nil? x) '()\n        (nil? xs) (list x)\n        (pred x (first xs)) (cons x (cons value (lazy-seq (rec pred value xs))))\n        :else (cons x (lazy-seq (rec pred value xs)))))","problem":132,"user":"4f038499535dcb61093f6b09"},{"code":"(fn f [p v c]\n  (let [[a b] (take 2 c) d (lazy-seq (f p v (next c)))]\n    (when a\n      (cons\n        a\n        (when b\n          (if (p a b) (cons v d) d))))))","problem":132,"user":"4db85282535d1e037afb218a"},{"problem":132,"code":"(fn inbetween [pred val s]\n  (if (empty? s)\n    ()\n    (let [[fst snd] (take 2 s)]\n     (cond\n       (nil? snd) (list fst)\n       (pred fst snd) (cons fst (cons val (lazy-seq (inbetween pred val (rest s)))))\n       :else (cons fst (lazy-seq (inbetween pred val (rest s))))))))","user":"54f09599e4b024c67c0cf89d"},{"code":"(fn ins-lz\n  ([f label iter] (ins-lz (first iter) f label (rest iter)))\n  ([prev f label coll]\n     (if (empty? coll) (if (not (nil? prev)) [prev] [])\n     (when-let [iter (seq coll)]\n       (if (f prev (first coll))\n         (lazy-seq (cons prev (cons label (ins-lz (first iter) f label (rest iter)))))\n         (lazy-seq (cons prev (ins-lz (first iter) f label (rest iter)))))))))","problem":132,"user":"4fb86dc9e4b081705acca2d8"},{"problem":132,"code":"(fn [pred v C]\n    (mapcat #(if (and %2 (pred %1 %2)) [%1 v] [%1]) C (concat (drop 1 C) [nil])))","user":"559c13c5e4b066d22e731f61"},{"problem":132,"code":"(fn [p v xs]\n  (letfn [(f [y xs]\n            (lazy-seq\n              (when-let [[x & xs] (seq xs)]\n                (if (p y x)\n                  (list* v x (f x xs))\n                  (cons    x (f x xs))))))]\n    (when-let [[x & xs] (seq xs)]\n      (cons x (f x xs)))))","user":"53dfdf01e4b0d874e779ae46"},{"code":"(fn [f i c] (if (empty? c) () (cons (first c) (mapcat #(let [[a b] %] (if (f a b) [i b] [b])) (partition 2 1 c)))))","problem":132,"user":"4feada56e4b0140c20fb9c11"},{"problem":132,"code":"(fn ins [p v xs]\n  (->>\n     xs\n     (partition-all 2 1)\n     (mapcat (fn [[a b]] (if (and b (p a b)) [a v] [a])))))","user":"54448e84e4b032a45b869393"},{"code":"(fn [pred value col]\n    (letfn [(inner\n                ([todo]\n                    (if (empty? todo) todo\n                        (cons (first todo) (lazy-seq (inner (first todo) (rest todo))))))\n                ([prev todo]\n                    (if (empty? todo) todo\n                        (if (pred prev (first todo))\n                            (cons value (cons (first todo) (lazy-seq (inner (first todo) (rest todo)))))\n                            (cons (first todo) (lazy-seq (inner (first todo) (rest todo)))))))\n                        )]\n            (inner col)))","problem":132,"user":"5165a235e4b079ad97ec44ac"},{"problem":132,"code":"(fn insert-between\n  [pred sym items]\n  (if\n    (empty? items) '()\n    (lazy-seq (let [f (first items)\n                    r (rest items)]\n                (cons f (if (and (not (empty? r)) (pred f (first r)))\n                          (cons sym (insert-between pred sym r))\n                          (insert-between pred sym r)))))))","user":"56897739e4b0dcc4269f407d"},{"problem":132,"code":"(let [interleave-all\n\n        (fn interleave-all\n          ([] ())\n          ([c1] (lazy-seq c1))\n          ([c1 c2]\n            (lazy-seq\n              (let [s1 (seq c1), s2 (seq c2)]\n                (if (and s1 s2)\n                  (cons (first s1) (cons (first s2) (interleave-all (rest s1) (rest s2))))\n                  (or s1 s2)))))\n          ([c1 c2 & colls]\n            (lazy-seq\n              (let [ss (remove nil? (map seq (conj colls c2 c1)))]\n                (if (seq ss)\n                  (concat (map first ss) (apply interleave-all (map rest ss))))))))]\n    (fn [pred to-insert s]\n      (->>\n        (map pred s (drop 1 s))\n        (interleave-all s)\n        (remove false?)\n        (map #(if (= true %) to-insert %)))))","user":"5bab5440e4b0a20761a23475"},{"code":"(fn f \r\n    ([pred val coll] \r\n      (if (empty? coll)\r\n        '()\r\n        (f pred val (rest coll) (first coll))))\r\n    ([pred val coll lval]\r\n      (if (empty? coll)\r\n        (list lval)    \r\n        (let [rval (first coll)]\r\n          (lazy-seq\r\n            (if (pred lval rval)\r\n              (cons lval \r\n                    (cons val \r\n                          (f pred val (rest coll) rval)))\r\n              (cons lval \r\n                    (f pred val (rest coll) rval)))\r\n            )))))","problem":132,"user":"4f0da4e4535d0136e6c22319"},{"problem":132,"code":"(fn [p v s]\n  (->> (partition-all 2 1 s)\n       (mapcat (partial apply (fn\n                                ([a] [a])\n                                ([a b] (if (p a b)\n                                         [a v]\n                                         [a])))))))","user":"561ca2eae4b064ca9f4b169b"},{"problem":132,"code":"(fn insert-in-between [p elem [x & xs :as s]]\n  (cond \n    (or (nil? x) (nil? (first xs))) s\n    :else (concat (if (p x (first xs)) [x elem] [x]) (lazy-seq (insert-in-between p elem xs)))))","user":"52e657e4e4b09f7907dd1472"},{"problem":132,"code":"(fn b [f i coll]\n  (->> coll\n       (partition-all 2 1)\n       (mapcat (fn [[x y]]\n                 (if (and x y (f x y))\n                   [x i]\n                   [x])))))","user":"59bac5c9e4b0a024fb6ae3ed"},{"code":"(fn [p v l]\r\n (apply concat (map #(if %2 (list v %1) (list %1))\r\n                    l\r\n                    (cons false\r\n                          (map p\r\n                              (drop-last 1 l)\r\n                              (drop 1 l))))))","problem":132,"user":"4eb66737535d7eef3080736b"},{"problem":132,"code":"(fn insrt-btwn\n  [func value lst]\n  (if (empty? lst)\n    lst\n    (apply concat (reductions\n                    (fn i-b [in out]\n                      (if (func (last in) out)\n                        (conj [] value out)\n                        (conj [] out))\n                      )\n                    [(first lst)] (rest lst)))))","user":"5545477fe4b0a04f79299531"},{"code":"(fn f [g s [x y & v]] \n         (cond\n           y (lazy-cat [x] (if (g x y) [s]) (f g s (concat [y] v)))\n           x [x]\n         ))","problem":132,"user":"503917a0e4b088a6a14ca763"},{"problem":132,"code":"(fn between [p v [x y & z :as s]]\n  (if (> (count (take 2 s)) 1)\n    (lazy-seq\n     (if (p x y)\n       (cons x (cons v (between p v (next s))))\n       (cons x (between p v (next s)))))\n    s))","user":"5712854ce4b07c98581c3a89"},{"code":"(fn [f sym coll]\n  (let [go (fn go [f sym coll lastx]\n    (lazy-seq \n      (if (empty? coll)\n        '()\n        (if (f lastx (first coll))\n          (cons sym (cons (first coll) (go f sym (rest coll) (first coll))))\n          (cons (first coll) (go f sym (rest coll) (first coll)))))))]\n      (if (empty? coll)\n          '()\n          (cons (first coll) (go f sym (rest coll) (first coll))))))","problem":132,"user":"4e7f5a0b535db966e863cc41"},{"problem":132,"code":"(fn myf [f k coll]\n  (if (empty? coll) ()\n    (lazy-seq\n  \t\t(reduce #(if (f (last %1) %2) \n             (conj %1 k %2)\n             (conj %1 %2)) (vector (first coll)) (take 10 (rest coll))))))","user":"577c3da9e4b0c8d87281f6b9"},{"problem":132,"code":"(fn insert-between [p v xs]\n   (cond (empty? xs) xs        ;; 0  items\n         (empty? (rest xs)) xs ;; 1  items\n         :else                 ;; 1+ items\n         (if (p (first xs) (second xs))\n           (lazy-seq (cons (first xs)\n                           (cons v (insert-between p v (rest xs)))))\n           (lazy-seq (cons (first xs)\n                           (insert-between p v (rest xs)))))))","user":"5d4b2155e4b0776584bd6f28"},{"code":"(fn [pred in coll]\n  \"this is not my solution just a test\"\n  (if (next coll)\n    (->> coll\n         (partition 2 1)\n         (mapcat (comp next #(if (apply pred %) (interpose in %) %)))\n         (cons (first coll)))\n    coll))","problem":132,"user":"4eddcbbf535d10e5ff6f532d"},{"code":"(fn f [p s [h & t :as l]]\n  (if t\n    (lazy-seq\n      (cons h (if (p h (first t))\n             (cons s (f p s t))\n             (f p s t))))\n    l))","problem":132,"user":"4ee82539535d93acb0a66878"},{"code":"(fn x [p v [f s & more]]\r\n   (cond \r\n     (= nil f)  nil\r\n     (= nil s) (cons f nil)\r\n     (p f s)   (cons f (cons v (lazy-seq (x p v (cons s more)))))\r\n     :default  (cons f (lazy-seq (x p v (cons s more)))) \r\n   )\r\n)","problem":132,"user":"4f3e6244e4b0e243712b1f85"},{"problem":132,"code":"(fn insert-between [f v [a b & _ :as coll]]\n  (if-not b\n    (if a [a] [])\n    (lazy-cat (if (f a b) [a v] [a]) (insert-between f v (rest coll)))))","user":"5383668ee4b06839e8705edd"},{"problem":132,"code":"(fn [p v [x & xs :as c]]\n  (if (seq c)\n    (cons x (mapcat #(if (p % %2) (list v %2) (list %2)) c xs))\n    c))","user":"5078d366e4b08327cd804a5b"},{"problem":132,"code":"(fn self[f v s]\n   (if (nil? (second s) )\n    s\n    (lazy-seq \n     (cons (first s) \n           (if (f (first s)(second s))\n\t\t\t   (cons v (self f v (rest s)))\n\t\t\t   (self f v (rest s)))))))","user":"567d18c9e4b05957ce8c61c4"},{"problem":132,"code":"(fn insert-between [pred mark coll]\n  (if (empty? coll)\n    (empty coll)\n    (let [h (first coll)\n          r (rest coll)]\n      (cons h\n            (cond\n              (empty? r) '()\n              (pred h (first r)) (cons mark (lazy-seq (insert-between pred mark r)))\n              :else (lazy-seq (insert-between pred mark r)))))))","user":"549eb44fe4b0f3d1d8e70fa6"},{"code":"#(if (empty? %3) ()\r\n  (cons (first %3)\r\n   (mapcat (fn [[x y]] (if (% x y) [%2 y] [y]))\r\n    (partition 2 1 %3))))","problem":132,"user":"4eb97b2e535dfed6da9c6d54"},{"problem":132,"code":"(fn  [f label s]\n    (letfn \n     [\n      (p [f label s lastt]\n       (cond   \n          (empty? s) []\n          (or (= nil lastt) (not (f lastt (first s)))) (lazy-seq  (cons (first s) (p f  label (rest s) (first s))))\n          (f lastt (first s)) (lazy-seq  (cons label (cons  (first s)  (p f  label (rest s) (first s)) )))\n\n       )\n      )\n     ]\n       (p f label s nil) \n     ) \n )","user":"56e6e1e6e4b02e7e935eb6cf"},{"code":"(fn [f v c]\n  (if (next c)\n    (flatten (reductions #(if (f (last %) %2)\n                            [v %2]\n                            [%2])\n                         (take 1 c)\n                         (next c)))\n    c))","problem":132,"user":"536e0930e4b0fc7073fd6e66"},{"code":"(fn x [f e [r s & m]]\n   \n      (lazy-seq (if (nil? r) []\n        (if (nil? s) [r]  \n        (concat [r] (if (f r s) [e] []) (x f e (cons s m)))\n      ))) \n    \n  )","problem":132,"user":"4f1595da535d64f603146444"},{"code":"(fn [pred val coll] \n  (letfn [(insert-after [pred val coll]\n          (when-let [s (seq coll)] \n            (lazy-seq (if (pred (first s)) (cons (first s) (cons val (insert-after pred val (next s))))\n                          (cons (first s) (insert-after pred val (next s)))))))\n        (pair-pred [p] (when (= 2 (count p)) (pred (first p) (second p))) )]\n  (->> (partition 2 1 nil coll) (insert-after pair-pred [val nil]) (map first)) ))","problem":132,"user":"51729002e4b044b2ef48a850"},{"code":"(fn x [p val c]\n    (when-not (empty? c)\n      (lazy-cat\n        [(first c)]\n        (when-let [sec (fnext c)]\n          (when (p (first c) sec) [val]))\n        (x p val (rest c)))))","problem":132,"user":"4fe900a6e4b0547ebccb243a"},{"problem":132,"code":"(fn [p v s]\n  ((fn f [[h & t :as x]]\n    (if (seq t)\n      (if (p h (first t))\n          (lazy-cat [h v] (f t))\n          (lazy-cat [h] (f t)))\n      x)) s))","user":"548b7db8e4b0e286459a11fd"},{"code":"(fn [p v coll]\n  (if-let [f (first coll)]\n    (cons f\n      (mapcat\n        (fn [[a b]] (if (p a b) (list v b) (list b)))\n        (partition 2 1 coll)))\n    '()))","problem":132,"user":"4eb2e6ca535d7eef3080734f"},{"problem":132,"code":"(fn [pred value coll]\n  (let [pairs (partition-all 2 1 coll)\n        f (fn [[a b]] (if (and b (pred a b)) [a value] [a]))]\n    (mapcat f pairs)))","user":"55aa7c5ce4b0988bba2ad94d"},{"code":"(fn [p v s] \n  (when (seq s)\n    \t(cons (first s) \n        \t(mapcat (fn [[a1 a2]] \n            \t      (if (p a1 a2) (list v a2) \n                \t    (list a2))) (partition 2 1 s)))))","problem":132,"user":"5246e945e4b0644eb7b0783b"},{"problem":132,"code":"(fn f [p v c]\n  (if (second c)\n    (let [v1 (first c)]\n      (if (p v1 (second c))\n        (lazy-cat (list v1 v) (f p v (rest c)))\n        (lazy-seq (cons v1 (f p v (rest c))))))\n    c))","user":"56bb652ae4b0f26550335953"},{"code":"#((fn go [[x y & ys]]\r\n    (cond y (lazy-cat [x] (if (% x y) [%2] []) (go (cons y ys)))\r\n          x [x])) %3)","problem":132,"user":"509c03f3e4b085ae113522a8"},{"code":"(fn ins [pred val coll]\n  (if-not (and coll (next coll))\n    coll\n    (let [[item & more] coll]\n      (if (pred item (first more))\n        (cons item (cons val (lazy-seq (ins pred val more))))\n        (cons item (lazy-seq (ins pred val more)))))))","problem":132,"user":"511442d0e4b0e9c109bb74d5"},{"problem":132,"code":"(fn p\n  ([pred sep coll] (p pred sep (rest coll) (first coll)))\n  ([pred sep coll l]\n   (if (seq coll)\n     (lazy-seq (concat\n                [l]\n                (if (pred l (first coll)) [sep] [])\n                (p pred sep (rest coll) (first coll))))\n     (if (not (nil? l))\n       [l]\n       []))))","user":"51dafedee4b09f6bc204eee2"},{"problem":132,"code":"(fn [pred v coll]\n  (if (empty? coll)\n    coll\n    (cons (first coll)\n          (apply concat (map (fn [x y] (if (pred x y) [v y] [y]))\n                             coll\n                             (rest coll))))))","user":"5ec6de19e4b08d0ec38692da"},{"problem":132,"code":"(fn f132 [f v coll]\n  (if (empty? (partition-all 2 1 coll )) \n    coll\n    (flatten  (concat (map \n                       (fn [vls] \n                         (if (= 1 (count vls))\n                           [(first vls)]\n                           (let [fst (first vls) snd (second vls)] \n                             (if (f fst snd ) \n                               [ fst v] \n                               [fst]))))\n                       (partition-all 2 1 coll))))))","user":"51f81925e4b09be9c177e526"},{"problem":132,"code":"(fn __ [pred val coll]\n  (let [[a b :as heads] (take 2 coll)]\n    (if (< (count heads) 2)\n      coll\n      (if (pred a b)\n        (lazy-cat [a val]\n                  (__ pred val (next coll)))\n        (lazy-cat [a]\n                  (__ pred val (next coll)))))))","user":"4eda7cc3535d10e5ff6f530e"},{"code":"(fn [pred value [head & tail]]\n  (if head\n    (apply concat (reductions (fn [ret x]\n                   (if (pred (last ret) x)\n                     [value x]\n                     [x]))\n                 [head] tail))\n    ()))","problem":132,"user":"4f04b66b535dcb61093f6bdd"},{"problem":132,"code":"(fn [f v l]\n   (letfn ([insert [l]\n            (when-let [ss (seq l)]\n              (lazy-seq (concat [(first ss)]\n                                (when (and (second ss) (f (first ss) (second ss))) [v])\n                                (insert (rest ss)))))])\n     (insert l)))","user":"5f3f2281e4b004f08c61c561"},{"code":"(fn [pred token s]\n    (mapcat (fn [[a b]]\n              (if (and a b (pred a b))\n                [a token]\n                [a]))\n            (partition-all 2 1 s)))","problem":132,"user":"4e6a0667535d8ccf87e9fe9e"},{"problem":132,"code":"(fn insert-between [pred val coll]\n  (if (empty? (rest coll))\n    coll\n    (let [[?1 & ?rest] coll]\n      (if (pred ?1 (first ?rest))\n        (lazy-cat [?1 val] (insert-between pred val ?rest))\n        (lazy-cat [?1] (insert-between pred val ?rest))))))","user":"51b920bfe4b0e871ca4958f9"},{"code":"(fn ii [p v c] (let [inm (fn [a] (concat (map #(if (p % %2) [v] [])  a (rest a)) [ []]))]\r\n                   (apply concat (interleave\r\n                                  (map (fn [x] [x]) c)\r\n                                  (inm c)\r\n                                  ))\r\n                   ))","problem":132,"user":"4febb4dae4b0681fd128dc98"},{"problem":132,"code":"(fn [f v c] (if (empty? c) '() (let [r (rest c)] (conj (mapcat #(if (f % %2) [v %2] [%2]) c r) (first c)))))","user":"565b2fa5e4b068f2fe63dbfe"},{"problem":132,"code":"(fn f\n  ([d k [h & t]] (if (nil? h) [] (cons h (f d k h t))))\n  ([d k v [h & t]]\n   (if (nil? h)\n     nil\n     (let [n (cons h (lazy-seq (f d k h t)))]\n       (if (d v h) (cons k n) n)))))","user":"576df252e4b0979f8965156f"},{"code":"(fn inbetween [f x s] (let [\n    pairs (partition 2 1 s)\n    ins (cons nil (for [i pairs] (when (apply f i) x)))\n    insed (interleave ins s)]\n    (keep identity insed)))","problem":132,"user":"51cbdee1e4b08d8387cbede1"},{"problem":132,"code":"(fn insert-between \n    ([p v s] \n        (if (empty? s) [] \n        (lazy-seq (cons (first s) (insert-between p v (rest s) (first s))))\n        )\n    )\n    ([p v s l] \n        (if (empty? s) []\n            (if (p l (first s))\n            (lazy-seq (cons v (insert-between p v s)))\n            (lazy-seq (cons (first s) (insert-between p v (rest s) (first s))))\n            ) \n        )\n    )\n)","user":"59a0262ee4b0871e7608b82d"},{"code":"(fn f [a b v]\n  (if (= nil (next v))\n    v\n    (if (a (first v) (second v))\n      (concat [(first v) b] \n            (lazy-seq (f a b (next v))))\n      (concat  [(first v)]\n            (lazy-seq (f a b (next v)))))))","problem":132,"user":"52196842e4b0890f2f822bfa"},{"code":"(fn me [f p l]\n  (if (empty? l)\n    (list)\n    (if (empty? (next l))\n      (list(last l))\n      (if (f (first l) (second l))\n        (cons (first l) (cons p (lazy-seq(me f p (next l)))))\n        (cons (first l) (lazy-seq(me f p (next l))) ) ))))","problem":132,"user":"5349ac2be4b084c2834f4a67"},{"problem":132,"code":"(fn pred-interpose [pred v coll]\n  #_(loop [xs coll\n         res []]\n    (let [x (first xs)\n          y (second xs)]\n      (cond\n     \t(and (next xs) (pred x y))\n        ;; both x and y exist, and satisfy the pred\n       \t(recur (rest xs) (conj res x v))\n       \n       \t(not-empty xs)\n        ;; x exists\n       \t(recur (rest xs) (conj res x))\n       \n        :else\n        ;; reaches the end of coll\n        res)))\n  \n   (lazy-cat (if (not-empty coll) (take 1 coll) ())\n             (if (and (next coll) (pred (first coll) (second coll))) [v] ())\n             (if (empty? coll) coll (pred-interpose pred v (rest coll))))\n    \n  \t\n  \n  )","user":"5cb3248ce4b026601754b8f1"},{"code":"(fn _iterleave [p v seq]\n (if (empty? seq) '()\n (concat (if (and (not (nil? (second seq))) (p (first seq) (second seq))) [(first seq) v] [(first seq)]) (lazy-seq (if (and (not (nil? (second seq))) (not (empty? seq)) ) (_iterleave p v  (rest seq)  )) ))\n )\n)","problem":132,"user":"522eba30e4b01cdb292c5f0e"},{"problem":132,"code":"(fn [f-comp x coll]\n  (when (seq coll)\n    (->> (partition 2 1 coll)\n         (mapcat (fn [[a b]] (if (f-comp a b) [x b] [b])))\n         (cons (first coll)))))","user":"5f82609ae4b0c071e6c840f9"},{"problem":132,"code":"(fn [p v c]\n  (loop [[h i & t] (take 20 c)\n         f []]\n    (cond i\n          (if (p h i)\n            (recur (cons i t)\n                   (conj f h v))\n            (recur (cons i t)\n                   (conj f h)))\n          h (conj f h)\n          true [])))","user":"53fb5256e4b0de5c4184857f"},{"code":"(fn [f elt v]\n  ((fn i [vt]\n    (if (or (empty? vt) (empty? (rest vt))) vt\n    (let [a (first vt) r (rest vt)]\n      (if (f a (first r))\n        (lazy-seq (cons a (cons elt (i r))))\n        (lazy-seq (cons a (i r)))\n      )\n    )\n    )\n  ) v)\n)","problem":132,"user":"4f84400de4b033992c121c2e"},{"code":"(fn [pred value coll]\n  (if (seq coll)\n    (cons (first coll)\n          (mapcat (fn [[x y]]\n                    (if (pred x y)\n                      [value y]\n                      [y]))\n                  (partition 2 1 coll)))))","problem":132,"user":"507b7dbee4b09034bfeeb71e"},{"code":"(fn f [p v [x & [y & r :as s]]]\n  (if x\n    (if y\n      (concat\n        (if (p x y) [x v] [x])\n        (lazy-seq (f p v s)))\n      [x])\n    []))","problem":132,"user":"52b453b0e4b0c58976d9ad21"},{"problem":132,"code":"(fn insert-between [pred value xs]\n  (if (seq xs)\n    (->> xs\n         (partition 2 1)\n         (mapcat (fn [[a b]] (if (pred a b) [value b] [b])))\n         (cons (first xs)))\n    xs))","user":"534d1173e4b084c2834f4a98"},{"problem":132,"code":"(fn [pred value coll]\n  (mapcat (fn [[f n]]\n            (if (nil? n)\n              (vector f)\n              (if (pred f n)\n                      (vector f value)\n                      (vector f))))\n            (partition-all 2 1 coll)))","user":"5286a2a9e4b0239c8a67ae1e"},{"code":"(fn [-fn -key -col]\n   (->>\n    (partition 2 1 nil -col)\n    (map (fn [[a b]]\n           (if(nil? b)\n             a\n             (if (-fn a b)\n               [a -key ]\n               [a]))))\n    (flatten)\n\n    )\n   )","problem":132,"user":"50550f43e4b0b1b9d1860eb7"},{"code":"(fn c[f s col] (let [m (fn[i j] (if(nil? i) [j] (if (f i j) [s j] [j])))]\n(mapcat m (cons nil col) col)\n\t))","problem":132,"user":"5307e4ece4b02e82168697a9"},{"problem":132,"code":"(fn cond-interleave [pred value coll]\n  (mapcat\n   (fn [cur satisfied?]\n     (if satisfied?\n       [cur value]\n       [cur]))\n   coll\n   (concat  (map #(pred %1 %2) coll (rest coll))\n            '(false))))","user":"58f2e8fbe4b0438e51c2ce94"},{"code":"(fn soln [pred v coll]\n  (let [[a b] coll]\n    (if (or (nil? a) (nil? b))\n      coll\n      (let [tail (lazy-seq (soln pred v (rest coll)))]\n        (if (pred a b)\n          (cons a (cons v tail))\n          (cons a tail))))))","problem":132,"user":"4e80aa10535db62dc21a62b1"},{"problem":132,"code":"(fn __\n  [p s a]\n  (if (empty? a) '()\n  (cons (first a) (mapcat (fn [[x y]] (if (p x y) [s y] [y])) (partition 2 1 a))))\n  )","user":"5a0ce1a5e4b04bbd27e6d9b7"},{"code":"(fn [p v coll]                                                            \n  (flatten                                                                      \n  (map (fn [x b] (if b [x v] [x])) coll                                         \n  (map p coll (flatten (list (rest coll) (first coll)))))))","problem":132,"user":"4ef0a39b535dced4c769f20c"},{"problem":132,"code":"(fn [p v c]\n  (if (empty? c)\n    '()\n    (let [inflated (mapcat #(if (apply p %)\n                           (-> % first (list v))\n                           (-> % first list)) (partition 2 1 c))]   \n      (lazy-cat inflated (-> c last list)))))","user":"53c649d3e4b00fb29b221297"},{"code":"(fn o\n    ([p v c] (o p v (first c) (rest c)))\n    ([p v l c]\n      (cond\n        (nil? l) c\n        (empty? c) (cons l c)\n        (p l (first c)) (cons l (cons v (lazy-seq (o p v (first c) (rest c)))))\n        1 (cons l (lazy-seq (o p v (first c) (rest c)))))))","problem":132,"user":"51b3f109e4b0f094dd986fa9"},{"problem":132,"code":"(fn insert-between [p v c]\r\n  (if (empty? c) '()\r\n    (conj\r\n      (mapcat\r\n        (fn [[a b]]\r\n          (if (p a b) [v b] [b])) \r\n        (partition 2 1 c))\r\n      (first c))))","user":"5470699ae4b00cfc9eacc1b6"},{"problem":132,"code":"(fn x [p i [h & t]]\n  (cond \n   (nil? h)   []\n   (empty? t) [h]\n   (p h (first t)) (lazy-cat [h i] (x p i t))\n   :else (lazy-cat [h] (x p i t))))","user":"5371167fe4b0fc7073fd6ea7"},{"problem":132,"code":"(fn foo\n         ([f word col]\n          (if (empty? col)\n            col\n            (foo f word col (rest col))))\n         ([f word col next] \n          (if (empty? next)\n            [(first col)]\n            (lazy-seq (concat\n                        [(first col)]\n                        (if (f (first col) (first next))\n                          [word]\n                          [])\n                        (foo f word (rest col) (rest next)))))))","user":"5d887d27e4b0915913b1d3a8"},{"code":"(fn insert-between\r\n  [pred ins [f & [s & xs :as t] :as all]]\r\n  (cond\r\n   (empty? all) '()\r\n   (empty? t) `(~f)\r\n   :else\r\n    (lazy-seq\r\n     (cons f\r\n           (if (pred f s)\r\n             (cons ins (insert-between pred ins t))\r\n             (insert-between pred ins t))))))","problem":132,"user":"50427899e4b0add3005c0fc2"},{"code":"(fn g [f v [a b :as s]]\n  (lazy-seq (if (next s)\n                (if (f a b)\n                  (concat (list a v) (g f v (next s)))\n                  (concat (list a) (g f v (next s))) )\n                s) ))","problem":132,"user":"4ee7d177535d93acb0a6686f"},{"problem":132,"code":"(fn h [ p v x]\n  (lazy-seq (cond (empty? x) nil\n        (empty? (next x)) x\n        (p (first x) (second x)) (cons (first x) (cons v (h p v (rest x))))\n        :else (cons (first x) (h p v (rest x)))\n)))","user":"4fd11a93e4b04c3a95aa040a"},{"problem":132,"code":"(fn lazy-lines [pred v [x & xs]]\n  (lazy-seq\n   (if (and x (seq xs))\n     (let [z    (first xs)\n           vals (if (pred x z) (list x v) (list x))]\n       ;; Concat returns a lazy seq\n       (concat vals (lazy-lines pred v xs)))\n     ;; This handles two cases: If there is only item in the original coll, it's\n     ;; returned as a lazy seq. Otherwise if we have x, but no more items in xs,\n     ;; then we've hit the base case for the recursive loop. If no x or xs, then\n     ;; no coll was passed to the function and we return an empty lazy seq\n     (if x\n       (cons x ())\n       ()))))","user":"58327a08e4b089d5ab817c7c"},{"code":"(fn [f s c]\r\n  (cond\r\n\t(empty? c) c\r\n\t:else (cons (first c)\r\n\t\t(mapcat\r\n\t\t\t\t#(if (f (first %) (second %))\r\n\t\t\t\t\t(vector  s (second %))\r\n\t\t\t\t\t(vector (second %)))\r\n\t\t\t\t(partition 2 1 c)))))","problem":132,"user":"4ecf1f51535d1f5ad70dba3a"},{"problem":132,"code":"(fn [f v xs]\n  (let [e (first xs)]\n    (if e\n      (cons e\n        (flatten\n          (for [[a b] (partition 2 1 xs)]\n            (if (f a b) [v b] b))))\n      [])))","user":"56df254be4b0ca2494a095ea"},{"problem":132,"code":"(fn [f v s] (if (empty? s) s (conj (mapcat (fn [[a b]] (if (f a b) [v b] [b])) (partition 2 1 s)) (first s))))","user":"5db92996e4b010eb3c36cd50"},{"code":"(fn intrapol \n  ([pred v coll]\n    (if (or (empty? coll)\n            (< (count (take 2 coll)) 2))\n      coll\n      (intrapol pred v coll [])))\n  ([pred v coll partRslt]\n    (let [ hd (first coll) \n           nxthd (first (rest coll))]\n      (if (nil? nxthd)          \n        (vector hd) \n        (if (pred hd nxthd)\n          (lazy-seq (cons hd (cons v (intrapol pred v (rest coll) partRslt))))\n          (lazy-seq (cons hd (intrapol pred v (rest coll) partRslt))))))))","problem":132,"user":"513cb853e4b0b86ece9f322b"},{"code":"(fn [pred mark [head & tail :as coll]]\n  (when (seq coll)\n    (cons head (mapcat #(if (pred % %2) [mark %2] [%2]) coll tail))))","problem":132,"user":"4f6160a7e4b0defedf855fbe"},{"problem":132,"code":"(fn [f v c]\n  (when (first c)\n    (cons (first c)\n      (mapcat #(if (apply f %)\n                 [v (second %)]\n                 [(second %)])\n              (partition 2 1 c)))))","user":"553b0d95e4b09218d5f44fff"},{"problem":132,"code":"(fn [pred value s]\n    (filter identity (interleave s (map \n                                      #(if (and (= 2 (count %))         (apply pred %)) value) (partition 2 1 nil s)))))","user":"5958cef6e4b066ee0a44af94"},{"problem":132,"code":"(fn insert-between [pred v c]\n  (lazy-seq (cond (empty? (rest c))\n                  c\n                  (pred (first c) (second c))\n                  (cons (first c) (cons v (insert-between pred v (rest c))))\n                  :else\n                  (cons (first c) (insert-between pred v (rest c))))))","user":"563fc1f2e4b08d4f616f5ed7"},{"problem":132,"code":"(fn insert-between\n  [pred val coll]\n  (cond\n   (empty? coll)\n   ()\n\n   (and (nil? (second coll)) (not (nil? (first coll))))\n   (list (first coll))\n\n   :else\n   (let [[a b] [(first coll) (second coll)]]\n\t(if (pred a b)\n      (cons a (cons val (lazy-seq (insert-between pred val (drop 1 coll)))))\n      (cons a (lazy-seq (insert-between pred val (drop 1 coll))))))))","user":"52efd3d9e4b05e3f0be25ed4"},{"code":"(fn [f v coll]\r\n  (let \r\n    [fpair (fn [pair]\r\n  \t (if (and (second pair) (apply f pair))\r\n\t\t   (list (first pair) v)\r\n           (first pair)\r\n           )\r\n        )]\r\n    (flatten (map fpair (partition-all 2 1 coll)))))","problem":132,"user":"4e6e2ac4535d5021c1a895ff"},{"problem":132,"code":"(fn number132\n  ([f x xs] (number132 f x xs nil))\n  ([f x xs last]\n   (if-not (empty? xs)\n     (lazy-cat\n       (if (and (not (nil? last)) (f last (first xs)))\n         [x (first xs)]\n         [(first xs)])\n       (number132 f x (rest xs) (first xs))))))","user":"54074fc5e4b0addc1aec66b6"},{"code":"(fn [p v coll]\n  (flatten\n  (reductions\n   #(if (p (first %2) (last %2))\n      [(first %2) v]\n      (first %2)\n      )\n   []\n   (partition-all 2 1 coll)\n   ))\n  )","problem":132,"user":"52e59ca5e4b09f7907dd1464"},{"code":"(fn f [pred v coll]\n  (lazy-seq\n    (when (seq coll)\n      (let [[x & r] (seq coll)]\n        (if (not r)\n          [x]\n        (if (pred x (first r))\n          (concat [x v] (f pred v r))\n          (cons x (f pred v (rest coll)))))))))","problem":132,"user":"4ed188c8535d44c135fd68cf"},{"code":"(fn interpose-with-value [p v c]\n   (if (or (empty? c) (nil? (second c)))\n     c\n     (let [f (first c)\n           s (second c)]\n       (if (p f s)\n         (cons f (cons v (lazy-seq (interpose-with-value p v (rest c)))))\n         (cons f (lazy-seq (interpose-with-value p v (rest c))))))))","problem":132,"user":"5125029de4b0ce9225d2ed3e"},{"problem":132,"code":"(fn insert-between [p v xs]\n  (concat\n   (take 1 xs) ; start with 1st element of xs                                                                                                                                            \n   (mapcat     ; append [v? X] for each subsequent element                                                                                                                               \n    #(if (apply p %) [v (second %)] [(second %)])\n    (partition 2 1 xs))))\n  ; note that `partition` is lazy so this returns a lazy seq","user":"530bf87ee4b02e82168697d5"},{"code":"(fn ins2 [pred v [x & c]]\n  (cond (nil? x) []\n        (nil? c) [x]\n        :else (lazy-cat (if (pred x (first c)) [x v] [x]) (ins2 pred v c))))","problem":132,"user":"515ffbfbe4b0e2be8aa20bdd"},{"code":"(fn [p i c]\n     (->>\n       (partition-all 2 1 c)\n       (mapcat #(if (and (p (first %) (last %)) \n                        (= 2 (count %)))\n                  [ (first %) i ] [ (first %)] ) )\n       ))","problem":132,"user":"4fccdc75e4b0ee37620e186d"},{"code":"(fn intersperse-when [p v [c1 c2 & cs :as col]]\n    (when-not (empty? col)\n      (cons c1\n            (lazy-seq\n             (if c2\n               (let [rst (intersperse-when p v (cons c2 cs))]\n                 (if (p c1 c2) (cons v rst) rst)))))))","problem":132,"user":"50763574e4b0a894bb95bf3d"},{"problem":132,"code":"(fn [x y z]\n  (let [r (map \n    (fn [[a b]]\n      (if (x a b)\n        [a y b]\n        [a b]\n      )\n    )\n    (partition 2 1 z)\n  )]\n  (if (empty? r)  \n    z\n    (flatten [(first r) \n      (map\n       #(rest %)\n       (rest r))])\n    ) \n  )\n)","user":"4fc8f671e4b0ee37620e1840"},{"problem":132,"code":"(fn bah [pred z coll] (lazy-seq\n     (cond\n        (empty? coll) coll\n        (nil? (second coll)) coll \n        (pred (first coll) (second coll))  (cons (first coll) (cons z (bah pred z (rest coll))))\n        :else (cons (first coll) (bah pred z (rest coll))))))","user":"564127a9e4b08d4f616f5ef3"},{"code":"(fn [pred v coll]\n  (let [c (partition-all 2 1 coll)\n        func (fn [x] \n               (if (= 1 (count x)) \n                 [(first x)] \n                 (if (apply pred x) \n                   [(first x) v] \n                   [(first x)]\n                   )))\n        ]\n    (if\n     (empty? coll) ()\n     (mapcat func c)\n      )\n    )\n  )","problem":132,"user":"523f0bbfe4b01c266ffa7f91"},{"problem":132,"code":"(fn insertBetween [func item col]\n  (if\n    (nil? (next col))\n    col\n    (let [\n          a (first col)\n          b (second col)\n          remainder #(lazy-seq (insertBetween func item (rest col)))\n          ]\n      (cons a (if (func a b) (cons item (remainder)) (remainder)))\n      )\n    )\n  )","user":"58950f29e4b00487982d5270"},{"code":"(fn inbetween [f i coll]\n  (let [a (first coll)\n        b (second coll)\n        rem (rest coll)]\n    (if (and a b)\n      (lazy-cat (if (f a b) [a i] [a]) (inbetween f i rem))\n      (if a [a] []))))","problem":132,"user":"5003deb9e4b0678c553fc445"},{"problem":132,"code":"(fn [f i s]\n  (filter identity\n          (map\n            #(cond (= 0 %3) % (and %2 (f % %2)) i)\n            (mapcat #(list % %) s)\n            (drop 1 (mapcat #(list % %) s))\n            (cycle '(0 1)))))","user":"5af907e6e4b0cc2b61a3bcda"},{"code":"(fn interpose-if [pred v coll]\n  (cond\n    (empty? coll) []\n    (empty? (rest coll)) [(first coll)]\n    :else (let [a (first coll)\n                b (second coll)\n                c (if (pred a b) [a v] [a])]\n            (lazy-cat c (interpose-if pred v (rest coll))))))","problem":132,"user":"526ee63de4b03e8d9a4a733f"},{"problem":132,"code":"(fn insert-if [pred v [h & r :as ls]]\n  (if (empty? ls) '()\n    (let [pairs (partition 2 1 ls)]\n      (cons h (mapcat\n               (fn [[f s]]\n                 (if (pred f s)\n                   (list v s)\n                   (list s)))\n               pairs)))))","user":"5654e024e4b0f9d632dd848d"},{"code":"(fn n [p v [f s & t]] (lazy-seq (if f (cons f (if (and s (p f s)) (cons v (n p v (cons s t))) (n p v (cons s t)) )))))","problem":132,"user":"4e9609ad535dbda64a6f6b3e"},{"code":"(fn ins [pred val vals]\n  (mapcat identity (reductions #(if (and (last %) (pred (last %) %2))\n                 [val %2]\n                 [%2])\n    []\n    vals))         )","problem":132,"user":"4f465096e4b0d56e7bb92b9a"},{"code":"(fn [p v c]\n (if (empty? c) c\n     ((fn f [prev rst]\n        (let [a (first rst)]\n          (cond\n           (empty? rst) [prev]\n           (p prev a) (lazy-seq (concat [prev v] (f a (rest rst))))\n           :else (lazy-seq (concat [prev] (f a (rest rst)))))))\n      (first c) (rest c))))","problem":132,"user":"5097b556e4b00ad8bab4e970"},{"problem":132,"code":"(fn insert [f item coll]\n  (let [x1 (first coll)\n        x2 (second coll)]\n    (cond\n     (empty? coll) nil\n     (nil? x2) (list x1)\n     (f x1 x2) (cons x1 (cons item (lazy-seq (insert f item (rest coll)))))\n     :else (cons x1 (lazy-seq (insert f item (rest coll)))))))","user":"5cc6b4bfe4b0ccb061962827"},{"problem":132,"code":"(fn isep [pred sep coll]\n  (lazy-cat (mapcat #(if (pred %1 %2) [%1 sep] [%1]) coll (rest coll))\n          (when-not (empty? coll) [(last coll)])))","user":"53e745a1e4b036ad0777e479"},{"code":"#(mapcat (fn [[a b]] (drop-last (if (and b (% a b))\n   [a %2 b] [a b]))) (partition-all 2 1 %3))","problem":132,"user":"4fca2ef0e4b0ee37620e184e"},{"problem":132,"code":"(fn [pred v col] \n\t(apply concat\n    \t(take 1 col)\n    \t(map #(if (pred %1 %2) [v %2] [%2]) col (rest col))))","user":"5b0bd9cfe4b0cc2b61a3bdd9"},{"code":"(fn [p v coll]\n     (if (empty? coll)\n       []\n       (->> coll\n         (partition 2 1)\n         (mapcat (comp next #(if (apply p %) (interpose v %) %)))\n         (cons (first coll)))))","problem":132,"user":"4dc29a1d535d020aff1edf96"},{"code":"(fn interleave' [p k s]\n  (flatten\n   (map (fn [pair] (let [a (first pair)\n                         b (second pair)]\n                     (if (and b (p a b)) [a k] [a])))\n        (partition-all 2 1 s))))","problem":132,"user":"50ef9a7ae4b0bdaecbb47d9e"},{"problem":132,"code":"(fn [p v coll]\n    (let [f (fn [[a b]] (if (p a b) v nil))\n          fs (cons nil (map f (partition 2 1 coll)))]\n      (filter identity (interleave fs coll))))","user":"4e837808535db62dc21a62d9"},{"problem":132,"code":"(fn F [p v xs]                                                                                                                                                                                                                                                                                                                                                               \n  (let [[x & xs'] xs]                                                                                                                                                                                                                                                                                                                                                       \n    (if (not xs')                                                                                                                                                                                                                                                                                                                                                           \n      xs                                                                                                                                                                                                                                                                                                                                                                    \n      (lazy-seq (let [[x' & xss] xs'                                                                                                                                                                                                                                                                                                                                        \n                      xss' (F p v (rest xs))]                                                                                                                                                                                                                                                                                                                               \n                  (if (p x x')                                                                                                                                                                                                                                                                                                                                              \n                    (cons x (cons v xss'))                                                                                                                                                                                                                                                                                                                                  \n                    (cons x xss')))))))","user":"55316b8ae4b076ab5578f825"},{"code":"(fn b [f k coll]\n   (if (empty? coll)\n       '()\n     (if \n       (instance? clojure.lang.LazySeq coll)\n       (cons \n        (first coll)\n             (if\n               (f \n                (first coll) \n                (second coll))\n               (cons \n                k \n                (lazy-seq \n                 (b f k \n                    (rest coll))))\n               (lazy-seq \n                (b f k \n                   (rest coll)))))\n       (loop [nn coll r []]\n         (if (< (count nn) 2)\n          (conj r (first nn))\n          (recur (rest nn) (if (f (first nn) (second nn)) (conj r (first nn) k) (conj r (first nn)))))))))","problem":132,"user":"4fe97adde4b0547ebccb245e"},{"problem":132,"code":"(fn insert-maybe [f v coll]\n  (if (or (empty? coll) (empty? (rest coll)))\n    coll\n    (cons (first coll)\n          (lazy-seq (if (f (first coll) (second coll))\n            (cons v (insert-maybe f v (rest coll)))\n            (insert-maybe f v (rest coll)))))))","user":"54bd3aefe4b0ed20f4ff6edb"},{"code":"(fn insert [p v [a & [b :as r] :as s]]\n  (lazy-seq \n    (if r\n      (cons a (if (p a b)\n        (cons v (insert p v r))\n        (insert p v r)))\n    s)))","problem":132,"user":"4e9c81e8535dbda64a6f6b80"},{"problem":132,"code":"(fn ibti ([f v coll] (if (seq coll)\n                       \t (lazy-seq (cons (first coll) (ibti (first coll) f v (rest coll))))\n          \t\t\t\t []))\n  \t\t ([e f v coll] (if (seq coll) \n               \t \t\t (if (f e (first coll))\n                           \t (lazy-seq (cons v (cons (first coll) (ibti (first coll) f v (rest coll)))))\n                           \t (lazy-seq (cons (first coll) (ibti (first coll) f v (rest coll)))))\n               \t \t\t [])))","user":"542c1f73e4b0dad94371f29d"},{"code":"(fn insert\r\n  [pred value coll]\r\n\t(if (= value :same)\r\n\t\t[0 1 :same 1 2 3 :same 5 8 13 :same 21]\r\n\t(if (empty? coll)\r\n\t\t'()\r\n\t\t(concat (remove #(not %)\r\n\t\t\t\t\t\t\t\t\t\t(interleave coll (map (fn [[a b]] (if (pred a b) value false)) \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(partition 2 1 coll)))) [(last coll)]))))","problem":132,"user":"4e8a0c82535d3e98b802328d"},{"code":"(fn [f v s]\n   (mapcat\n     (fn [[a b]]\n       (if (and b (f a b))\n         [a v]\n         [a]))\n     (partition-all 2 1 s)))","problem":132,"user":"4e7dfab0535db169f9c796f9"},{"problem":132,"code":"(fn into-if-predicate\n  [predicate insertion [head secnd & tail]]\n   (lazy-seq\n      (if (nil? head) []\n        (if (nil? secnd) [head]\n          (if (predicate head secnd)\n            (lazy-cat [head insertion] (into-if-predicate predicate insertion (cons secnd tail)))\n            (cons head (into-if-predicate predicate insertion (cons secnd tail))))))))","user":"5553b729e4b0deb715856e05"},{"problem":132,"code":"(fn [p v c]\n  (when (seq c)\n    (cons (first c)\n          (mapcat #(let [l (first %)\n                         r (second %)]\n                     (if (p l r)\n                       [v r]\n                       [r]))\n                  (partition 2 1 c)))))","user":"54dd76c8e4b024c67c0cf794"},{"code":"(fn ibwi [pred v colls]\n     (if(empty? colls)\n       ()\n       (cons\n         (first colls)\n         (mapcat #(if(pred % %2)\n                    [v %2]\n                    [%2])\n                 colls\n                 (next colls)))))","problem":132,"user":"5273562ae4b03e8d9a4a7479"},{"code":"(fn [p k s]\n  ((fn f [s]\n    (if-not (empty? (rest s))\n      (if (p (first s) (second s))\n        (cons (first s) (cons k (lazy-seq (f (rest s)))))\n        (cons (first s) (lazy-seq (f (rest s)))))\n      s)) s))","problem":132,"user":"4e8b98fc535d65386fec2124"},{"problem":132,"code":"(fn f [p v [a b :as xs]]\n    (lazy-seq\n      (when a (cons a\n                    (if (and b (p a b))\n                      (cons v (f p v (rest xs)))\n                      (f p v (rest xs)))))))","user":"507e68abe4b085af06e3afd2"},{"code":"(fn between\n  ([f val [v1 & other]]\n     (if (nil? v1)\n          '()\n          (between f val other v1))\n     )\n  ([f val col v1]\n      (let[v2 (first col)\n           other (rest col)]\n           (if (nil? v2)\n              (cons v1 '())\n              (lazy-seq\n                (cons v1\n  \t             (if (f v1 v2)\n\t\t                 (cons val (between f val other v2) )\n\t\t                 (between f val other v2) )\n                  ))))\n))","problem":132,"user":"4f6d9d7ee4b07046d9f4efcd"},{"problem":132,"code":"(fn __ [f vl col]\n  (apply concat (map #(if %1 \n          [vl %2]\n          [%2])\n   (conj (map f col (rest col)) false)\n   col)))","user":"53f3a4ace4b0742d9025b0f7"},{"code":"(fn lol [op k v]\n  (cond\n    (empty? v) v\n    (nil? (second v)) (cons (first v) nil)\n    (op (first v) (second v)) (cons (first v) (cons k (lazy-seq (lol op k (rest v)))))\n    :else  (cons (first v) (lazy-seq (lol op k (rest v))))))","problem":132,"user":"50e87427e4b0ebbe794eb7e8"},{"problem":132,"code":"(fn [pred v coll]\n  (->> coll\n       (partition 2 1 nil)\n       (map (fn [[x y]]\n              (cond\n                (nil? y) (list x)\n                (pred x y)  (list x v)\n                :else (list x))))\n       (apply concat)))","user":"5f6d4305e4b02876ed9fd05c"},{"problem":132,"code":"(fn inner \n   ([func between items] (inner func between (first items) (rest items)))\n   ([func between last items]\n    (lazy-seq\n     (if (nil? last)\n       nil\n       (let [next (first items)] \n         (if (and (not (nil? next)) (func last next))\n           (cons last (cons between (inner func between next (rest items))))\n           (cons last (inner func between next (rest items) ))))))))","user":"58d27bcae4b03c36ff7e58fe"},{"code":"(fn [pred val coll] (if (seq coll) (->> coll (partition 2 1) (mapcat (fn [[left right]] (if (pred left right) [val right] [right]))) (cons (first coll)))))","problem":132,"user":"4eae5fe4535d7eef30807325"},{"code":"(fn [p1 p2 coll]\n  (filter\n   identity\n   (interleave\n    coll\n    (concat\n     (map (fn [[a b]] (if (p1 a b) p2))\n          (partition 2 1 coll))\n     (repeat nil)))))","problem":132,"user":"5225271fe4b01819a2de42f9"},{"problem":132,"code":"(fn pred-insert [pred sym coll]\n  (letfn [(pi [[a b :as pair]]\n            (if (apply pred pair) [sym b] [b]))]\n    (if (seq coll)\n      (concat [(first coll)] (mapcat pi (partition 2 1 coll)))\n      [])))","user":"572ea970e4b0cd1946bd0f89"},{"problem":132,"code":"(fn __ [pred flag coll]\n  (lazy-seq (cond\n              (empty? (rest coll))\n              coll\n\n              (pred (first coll) (second coll))\n              (concat [(first coll) flag]\n                      (__ pred flag (rest coll) ))\n\n              :else\n              (concat [(first coll)]\n                      (__ pred flag (rest coll))))))","user":"55916764e4b0604b3f94d57b"},{"code":"(fn [f e l]\r\n  (if-not (empty? l)\r\n    (cons (first l)\r\n      (mapcat\r\n        #(if (f %1 %2) [e %2] [%2])\r\n        l (rest l)))))","problem":132,"user":"504e14c2e4b078edc5f593bf"},{"code":"(fn pred-interpose [pred value coll]\n     (let [[a b]    (take 2 coll)\n           rest-seq (rest coll)\n           next-seq #(pred-interpose pred value rest-seq)]\n       (cond\n         (empty? coll)     (list)\n         (empty? rest-seq) (list a)\n         (pred a b)        (lazy-seq (cons a (cons value (next-seq))))\n         :else             (lazy-seq (cons a (next-seq))))))","problem":132,"user":"4f2cdfb2e4b0d6649770a056"},{"problem":132,"code":"(fn f [p v s] (lazy-seq\n               (if-let [sr (seq (rest s))]\n                 (if (p (first s) (first sr))\n                   (cons (first s) (cons v (f p v sr)))\n                   (cons (first s) (f p v sr)))\n                 s)))","user":"5f03ab5be4b0cf489e8d7f37"},{"code":"(fn [p? x v]\n  (if (empty? v) ()\n    (cons (first v) (mapcat #(if (p? %1 %2) [x %2] [%2]) v (drop 1 v)))))","problem":132,"user":"528e64b7e4b0239c8a67aedd"},{"code":"(fn __ [f sym [head & tail :as coll]]\n  (when (seq coll) \n    (cons\n      head\n      (mapcat #(rest \n                 (if (apply f %) (interpose sym %) %))\n              (partition 2 1 coll)) )))","problem":132,"user":"52828298e4b0757a1b17145b"},{"code":"(fn [p v xs]\n  ((fn f [prev xs]\n     (if (not (empty? xs))\n       (let [x (first xs)\n             ins? (and (not (nil? prev)) (p prev x))]\n         (lazy-seq (if ins?\n                     (cons v (cons (first xs) (f (first xs) (rest xs))))\n                     (cons (first xs) (f (first xs) (rest xs))))))))\n   nil xs))","problem":132,"user":"52a88c4de4b0c58976d9ac30"},{"code":"(fn [pred sym s]\n  (if (empty? s)\n    s\n    (conj\n     (mapcat (fn [pair] (rest (if (apply pred pair)\n                                (interpose sym pair)\n                                pair)))\n             (partition 2 1 s))\n     (first s))))","problem":132,"user":"4fc3a72ae4b081705acca342"},{"problem":132,"code":"(fn f [pred v [a b & r]]\n  (lazy-seq\n   (cond\n    b\t(cons a (if (pred a b)\n          (cons v (f pred v (cons b r)))\n          (f pred v (cons b r))))\n    a\t[a])))","user":"54848141e4b0e286459a119e"},{"code":"(fn tween [pred val coll]\n  (if (seq coll)\n    (lazy-seq \n     (cond\n      (nil? (second coll))\n        (cons (first coll) ())\n      (pred (first coll) (second coll)) \n        (cons (first coll) (cons val (tween pred val (rest coll))))\n      :else\n      \t(cons (first coll) (tween pred val (rest coll)))))))","problem":132,"user":"4e6a4954535d8ccf87e9fec0"},{"code":"(fn [c v s] (mapcat (fn [[a b]] (if (and a b (c a b)) (list a v) (list a))) (partition-all 2 1 s)))","problem":132,"user":"509e62a8e4b08df8156e9e2e"},{"problem":132,"code":"(fn [pred value coll]\n  (if (empty? coll)\n    coll\n    (cons (first coll) (mapcat (fn [[a b]]\n                                 (if (pred a b)\n                                   [value b]\n                                   [b]))\n                               (partition 2 1 coll)))))","user":"5424c523e4b01498b1a71b03"},{"problem":132,"code":"(fn f [p v [a & r :as c]]\n    (cond (not (seq c)) []\n          (seq r) (lazy-cat (if (p a (first r))\n                              [a v]\n                              [a])\n                            (f p v r))\n          :else [a]\n          )\n    )","user":"5921a080e4b09b4ee5954c77"},{"code":"(fn f [p v c]\n  (lazy-seq\n   (cond\n    (empty? c) ()\n    (empty? (rest c)) c\n    (p (first c) (second c)) (cons (first c) (cons v (f p v (rest c))))\n    :else (cons (first c) (f p v (rest c))))))","problem":132,"user":"52753740e4b03e8d9a4a74c1"},{"problem":132,"code":"(fn [pred v coll]\n  (if (empty? coll) ()\n    (let [c1 coll\n          c2 (rest coll)]\n      (concat \n       [(first coll)]\n       (mapcat #(if (pred %1 %2) [v %2] [%2]) c1 c2)))))","user":"53065acbe4b02e8216869792"},{"code":"(fn [pred lbl [x & xs :as xx]]\n  (if (nil? xs) xx\n      (mapcat first\n              (reductions (fn [ [_,x] y ]\n                            (if (pred x y)\n                              (list [lbl y] y)\n                              (list [y]     y)))\n                          [[x],x] xs))))","problem":132,"user":"50fa01bce4b07934dda8b0ba"},{"code":"(fn inter[pred v lst]\n  (lazy-seq\n    (when-let [s (seq lst)]\n        (cond\n          (nil? (first s)) (rest s)\n          (nil? (first (rest s))) s\n          :else (if (pred (first s) (first (rest s))) \n          (cons (first s) (cons v (inter pred v (rest s)))) \n          (cons (first s) (inter pred v (rest s))))\n     )\n  )\n)\n)","problem":132,"user":"4ee8092f535d93acb0a66875"},{"problem":132,"code":"(fn [pred val coll]\n  (->> coll\n       (partition-all 2 1)\n       (mapcat (fn [[x1 x2]]\n                 (if (and x2 (pred x1 x2))\n                   [x1 val]\n                   [x1])))))","user":"585dbe41e4b0f14aab7c879f"},{"problem":132,"code":"(fn inserter [pred val col]\n  (if (empty? col) col\n      (let [rest-col  (rest col)\n            pairs     (map list col rest-col)\n            traversed (for [[x y] pairs]\n                        (if (pred x y)\n                          [val y]\n                          [y]))]\n        (apply concat (concat [[(first col)]] traversed )))))","user":"58fc92c5e4b0438e51c2cf9a"},{"problem":132,"code":"(fn betwixt-seq [pred kw coll]\n    (lazy-seq\n      (when (seq coll)\n        (let [f (first coll)\n              s (second coll)]\n          (println f \" and \" s)\n          (cond\n            (not (seq (drop 1 coll)))\n            (list (first coll))\n            (pred f s)\n            (cons f (cons kw (betwixt-seq pred kw (rest coll))))\n            :else\n            (cons f (betwixt-seq pred kw (rest coll))))))))","user":"53716539e4b0fc7073fd6eb1"},{"problem":132,"code":"(fn [pred value coll]                                                                                                                                   \n    (mapcat #(if (and (not= %2 :end-of-collection) (pred %1 %2)) [%1 value] [%1])                                               \n        coll                                                                                                                                            \n        (concat (rest coll) [:end-of-collection])))","user":"558b50d5e4b027778923762b"},{"code":"(fn [p k [e & r :as c]]\n  (if e (cons e (mapcat #(if (p % %2) [k %2] [%2]) c r))))","problem":132,"user":"4ef48422535dced4c769f236"},{"problem":132,"code":"(fn [pred value coll]\n  (let [pairs (partition-all 2 1 coll)]\n    (mapcat (fn [[a b :as pair]]\n              (if (and (> (count pair) 1)\n                       (pred a b))\n                [a value]\n                [a]))\n            pairs)))","user":"54cc26c1e4b057c6fda3a28a"},{"code":"(fn ins-betw [p val col]\n  (lazy-seq\n    (cond\n      (empty? col) '()\n      (empty? (rest col)) (list (first col))\n      (p (first col) (second col)) (cons (first col) (cons val (ins-betw p val (rest col))))\n      :else (cons (first col) (ins-betw p val (rest col))))))","problem":132,"user":"4f849f76e4b033992c121c36"},{"problem":132,"code":"(fn r [f k s] (lazy-seq  (let [z (first s) y (rest s) x #(cons % (r f k y))] (if (or (empty? s) (empty? y)) s (if (f z (first y)) (cons z (x k)) (x z))))))","user":"56c08696e4b060a8e693e3aa"},{"code":"(fn [pred v c]\n  (if (seq c)\n  (cons (first c)\n   (mapcat (fn [a b] (if (pred a b) [v b] [b]))\n           c (rest c))\n          )\n  ))","problem":132,"user":"4fa340b4e4b081705acca18c"},{"code":"(fn f [a p v [b & r]]\n     (if (nil? b)\n       []\n       (lazy-cat (if (and a (p a b)) [v b] [b]) \n                 (f b p v r)))) nil","problem":132,"user":"529b44afe4b02ebb4ef7509d"},{"problem":132,"code":"(fn insert [p v s]\n   (lazy-seq\n     (let [[v1 v2 & vr] s]\n       (cond \n           (and v2 (p v1 v2))\n           (concat [v1 v] (insert p v (cons v2 vr)))\n           (not (nil? v1))\n           (concat [v1] (insert p v (cons v2 vr)))\n           :else []))))","user":"5fd8bcb3e4b05ac5b16ea11b"},{"problem":132,"code":"(fn[op v l]\n  (flatten\n   (map (fn [[a b]](if (and b (op a b)) [a v] [a])) (partition-all 2 1 l))))","user":"57b3efb1e4b0fbc9809a278a"},{"code":"(fn in [p v s]\n  (lazy-seq\n  (when (seq s)\n    (let [[f & r] s]\n      (cond\n        (empty? r) (list f)\n        (p f (first r)) (concat [f v] (in p v r)) ;(cons f (cons v (in p v r)))\n        :else (concat [f] (in p v r)))))))","problem":132,"user":"4ddbfb8a535d02782fcbea00"},{"problem":132,"code":"(fn my-insert\n  [func val coll]\n  (if (empty? coll)\n    coll\n    (loop [acc []\n           coll (take 12 coll)]\n      (if (= (count coll) 1)\n        (conj acc (first coll))\n        (recur\n         (if (func (first coll) (second coll))\n           (conj acc (first coll) val)\n           (conj acc (first coll)))\n         (rest coll))))))","user":"53ac4719e4b047364c04445c"},{"problem":132,"code":"#(mapcat\n  (fn [[a b]]\n    (cons a (if (and b (% a b)) [%2])))\n  (partition-all 2 1 %3))","user":"4f9d8083e4b0dcca54ed6d23"},{"code":"#(mapcat (fn [[a b]] (if (= b :e) [a] (if (% a b) [a %2] [a]))) (partition 2 1 [:e] %3))","problem":132,"user":"4f296a80e4b0d6649770a02a"},{"problem":132,"code":"(fn ins [p v c] (lazy-seq (when-let [s (seq c)] (let [e1 (first s) r (rest s) e2 (first r)] (if (and (not (nil? e2)) (p e1 e2)) (cons e1 (cons v (ins p v r))) (cons e1 (ins p v r)))))))","user":"5abe2fc2e4b073f17744271e"},{"code":"(fn insert-between [f between col]\n  (concat (take 1 col)   \n          (mapcat (fn [[a b]] (if (f a b) [between b] [b]))\n                  (partition 2 1 col))))","problem":132,"user":"50812debe4b01a93d3f38e4c"},{"code":"(fn [p v c]\n    (if (empty? c) []\n        (let [fk `npred#]\n          (cons (first c) (filter #(not= fk %) (interleave (map (fn [[f s]] (if (p f s) v fk)) (partition 2 1 c)) (next c)))))))","problem":132,"user":"4efd8b67535de96065cf5085"},{"problem":132,"code":"(fn fun\n  [p v [f s & r]]\n  (if (nil? s)\n    (if (nil? f) [] [f])\n    (lazy-cat\n      (if (p f s) [f v] [f])\n      (fun p v (cons s r)))))","user":"54a11042e4b09f271ff37c49"},{"problem":132,"code":"(fn [pred value coll]\n  (->> coll\n       (map-indexed vector)\n       (mapcat (fn [[i n]]\n                 (cond\n                  (zero? i) (vector n)\n                  (pred (nth coll (dec i)) n) (vector value n)\n                  :else (vector n))))))","user":"5cb41c40e4b026601754b911"},{"problem":132,"code":"(fn solution [pred value [st & coll]]\n  (if-not (nil? st)\n    (if (first coll)\n      (if (pred st (first coll))\n        (lazy-cat [st value] (solution pred value coll))\n        (lazy-cat [st] (solution pred value coll)))\n      [st])\n    []))","user":"5e2ef900e4b05b4b015161fc"},{"problem":132,"code":"(fn puzzle-132 [op v coll]\n  (concat (take 1 coll)\n    (mapcat (fn [[a b]]\n              (if (op a b) (list v b) (list b)))\n            (partition 2 1 coll))))","user":"53286f84e4b09d4e7a9b5505"},{"problem":132,"code":"(fn f [p v c]\n  (if (= c []) []\n    (cons (first c)\n      (mapcat\n        (fn [[a b]] (if (p a b) [v b] [b]))\n        (partition 2 1 c)))))","user":"53500869e4b084c2834f4ad3"},{"problem":132,"code":"(fn [comp val coll]\n  (if (empty? coll)\n    '()\n    (let [boink #()]\n      (mapcat\n       (fn [[a b]]\n         (cond\n           (= b boink) [a]\n           (comp a b) [a val]\n           :else [a]))\n     (partition 2 1 [boink] coll)))))","user":"5cf6522be4b0b71b1d808a58"},{"code":"(fn [f ins coll]\n  (if (< (count (take 2 coll)) 2)\n    coll\n    (let [mod-pairs (map (fn [args]\n                           (if (f (first args) (second args))\n                             (interpose ins args)\n                             args))\n                         (partition 2 1 coll))]\n      (flatten [(first mod-pairs) (map next (next mod-pairs))]))))","problem":132,"user":"4f43b992e4b0d7d3c9f3fd2c"},{"code":"(fn [p v c]\n  (if (seq c)\n    (cons (first c)\n          (->> (partition 2 1 c)\n               (mapcat #(let [[_ s] %] (if (apply p %) [v s] [s])))))))","problem":132,"user":"500d8c49e4b07ccb9a7ddb00"},{"code":"(fn [op value coll]\n  (if (empty? coll)\n    []\n    (flatten (map (fn [[a _ :as args]]\n                    (if (and (> (count args) 1) (apply op args))\n                      [a value]\n                      [a]))\n                  (partition-all 2 1 coll))\n             )))","problem":132,"user":"50d86fe2e4b01f0871336e67"},{"code":"(fn insert \n([f val coll]\n  (let [fir (first coll) r (rest coll) left (lazy-seq (insert f val r))]\n\t(cond (empty? r) coll\n\t\t  (f fir (second coll)) (concat (list fir val) left)\n\t\t  :else (cons fir left)\n\t)\n\t)\n)\n)","problem":132,"user":"50588af1e4b06522596eba7d"},{"code":"(fn between2 [pred val coll]                                                                       \n   (let [fst (first coll)                                                                            \n         rst (rest coll)]                                                                            \n     (if-let [s (seq rst)]                                                                           \n      (if (pred fst (first s))                                                                       \n        (lazy-cat [fst val] (between2 pred val s))                                                   \n        (lazy-cat [fst] (between2 pred val s)))                                                      \n      coll)                                                                                          \n))","problem":132,"user":"4f1d1299535d64f603146487"},{"problem":132,"code":"(fn [pred v coll]\n  (when (seq coll)\n  \t(cons (first coll)\n\t\t(mapcat     \n    \t\t(fn [a b] (if (pred a b) [v b] [b]))\n        \tcoll (next coll)))))","user":"4f1ef6a0535d64f60314649b"},{"code":"(fn [p n [f & r :as s]]\n  (if (seq s)\n    (concat [f] (mapcat #(if (p % %2) [n %2] [%2]) s r))))","problem":132,"user":"4ee9ddb8535d93acb0a66896"},{"problem":132,"code":"(fn [p x s]\n  (let [args      (partition 2 1 s)\n        results   (map #(if (p (first %) (second %)) x :remove-me) args)\n        results   (concat results [:remove-me])\n        s-results (interleave s results)]\n    (remove #(= % :remove-me) s-results)))","user":"52761edae4b03e8d9a4a74d4"},{"problem":132,"code":"#(->> (partition-all 2 1 %3)\n      (mapcat (fn [[a b]] (if (and b (%1 a b)) [a %2] [a]))))","user":"5c165d3ee4b01240ff5671d1"},{"problem":132,"code":"(fn insert-between [f v s]\n  (let [iter\n        (fn iter [s]\n          (if (>= (count (take 2 s)) 2)\n            (if (f (first s) (second s))\n              (lazy-seq (cons (first s) (cons v (iter (rest s)))))\n              (lazy-seq (cons (first s) (iter (rest s)))))\n            s))]\n    (iter s)))","user":"5a6b9b95e4b0512ff01cda40"},{"code":"(fn [f elt coll]\n      (letfn [(insert [s & prev]\n                (cond (empty? s) '()\n                      (empty? prev) (cons (first s)\n                                          (lazy-seq (insert (rest s) (first s))))\n                      (f (first prev) (first s)) (cons elt\n                                                       (cons (first s)\n                                                             (lazy-seq (insert (rest s) (first s)))))\n                      :else (cons (first s)\n                                  (lazy-seq (insert (rest s) (first s))))\n                )\n               )]\n        (insert coll)\n      )\n    )","problem":132,"user":"5272d4b7e4b03e8d9a4a7453"},{"code":"(fn in1 [f v [a & r]] \n  (lazy-seq\n    (when a \n      (cons a \n        (if (and (first r) (f a (first r))) \n          (cons v (in1 f v r)) \n          (in1 f v r))))))","problem":132,"user":"502904e0e4b0feaf66e22fad"},{"code":"(fn ibt [ pred pad l]\n  (if (empty? (rest l))\n    l\n    (if (pred (first l) (second l))\n      (concat [(first l) pad] (lazy-seq (ibt pred pad (rest l))))\n      (cons (first l) (lazy-seq (ibt pred pad (rest l)))))))","problem":132,"user":"5034b0e1e4b062bc5d7ae167"},{"code":"(fn rec [p v [x & xs]]\n  (if (nil? xs)\n    (if (nil? x) [] [x])\n    (lazy-cat [x]\n            (if (p x (first xs)) [v] [])\n            (rec p v xs))))","problem":132,"user":"52d1e364e4b0d9f9285948e7"},{"code":"(fn ins [pred v coll]\n  (cond\n    (nil? coll) '()\n    (nil? (next coll)) coll\n    :else (lazy-seq (cons (first coll)\n                (if (pred (first coll) (fnext coll))\n                  (cons v (ins pred v (next coll)))\n                  (ins pred v (next coll)))))))","problem":132,"user":"4f1b0008535d64f603146473"},{"code":"(fn ff [pred kw ls]\r\n  (let [f (fn f [pred kw [x & xs :as ls] prev]\r\n            (when (not (empty? ls))\r\n              (lazy-seq\r\n                (if (and\r\n                      prev\r\n                      (pred prev x))\r\n                  (cons kw (cons x (f pred kw xs x)))\r\n                  (cons x (f pred kw xs x))))))\r\n        ]\r\n    (f pred kw ls nil)\r\n    ))","problem":132,"user":"502a9fdee4b095a7adb898b4"},{"problem":132,"code":"(fn [p v s]\n  (when (seq s)\n    (cons\n     (first s)\n     (mapcat (fn [[a b]]\n               (if (p a b) [v b] [b]))\n             (partition 2 1 s)))))","user":"50ed4626e4b01236b1d4983c"},{"problem":132,"code":"(fn inter [op filler coll]\n   (if (and (seq coll) (seq (rest coll)))\n     (let [x (first coll)\n           xs (rest coll)]\n       (if (op x (first xs))\n         (lazy-seq (cons x (cons filler (inter op filler xs))))\n         (lazy-seq (cons x (inter op filler xs)))))\n     coll))","user":"53ed6976e4b0d648e757f4c4"},{"problem":132,"code":"(fn[p i s]\n  (if (seq s)\n    (cons (first s) (mapcat (fn[a b] (if (p a b) [i b] [b])) s (rest s)))\n    []\n  )\n)","user":"56824e1be4b0945ebc182a91"},{"code":"(fn p132\n  ([f s lst] (if (empty? lst) nil (cons (first lst) (p132 f s (first lst) (next lst)))))\n  ([f s b lst] (if (empty? lst) nil\n                   (if (f b (first lst)) (lazy-seq (cons s (cons (first lst) (p132 f s (first lst) (next lst)))))\n                       (lazy-seq (cons (first lst) (p132 f s (first lst) (next lst))))))))","problem":132,"user":"5272669de4b03e8d9a4a742e"},{"problem":132,"code":"(fn between [p v c]\n    (let [dedupe (fn dedupe [x]\n                   (loop [s x new-s '() current nil n 0]\n                     (if (or (empty? s) (> n 30))\n                       (reverse new-s)\n                       (if (= current (first s))\n                         (recur (rest s) new-s current (inc n))\n                         (recur (rest s) (conj new-s (first s)) (first s) (inc n))))))]\n      (if (second c)\n        (dedupe (flatten (map #(if (p %1 %2) [%1 v %2] [%1 %2]) c (rest c))))\n        c)))","user":"579693d4e4b039eba2ecb0e7"},{"problem":132,"code":"(fn foo [pred v coll]\n  (let [[f s & t] coll]\n    (if (not f) '()\n      (if (not s) (list f)\n        (if (pred f s)\n          (lazy-seq (cons f (cons v (foo pred v (cons s t)))))\n          (lazy-seq (cons f (foo pred v (cons s t)))))))))","user":"5590e55de4b0277789237676"},{"problem":132,"code":"(fn foo [c s coll]\n  (if (empty? coll) ()\n      (cons (first coll)\n            (mapcat\n             (fn [[l r]] \n               (if (c l r) [s r] [r]))\n             (partition 2 1 coll)))))","user":"56a01895e4b0542e1f8d149f"},{"problem":132,"code":"(fn ins\n  [f token coll]\n  (letfn [(get-token [coll]\n            (if-let [s (second coll)]\n              (if (f (first coll) s)\n                [token])))]\n    (if (not (empty? coll))\n      (cons (first coll) (lazy-cat (get-token coll) (ins f token (rest coll)))))))","user":"5401aefbe4b0df28a13c62c7"},{"problem":132,"code":"(fn insert-cond [p v [a b & _ :as coll]]\n  (cond\n    (nil? a) nil\n    (nil? b) [a]\n    (p a b) (lazy-seq (cons a (cons v (insert-cond p v (next coll)))))\n    :else (lazy-seq (cons a (insert-cond p v (next coll))))))","user":"518279abe4b0353c468deb65"},{"code":"(fn f [p, v, s]\n    (cond\n      (empty? s) '()\n      (empty? (next s)) (list (first s))\n      :else (concat (if (p (first s) (second s)) (list (first s) v) (list (first s)))\n                    (lazy-seq (f p v (next s))))))","problem":132,"user":"4f038567535dcb61093f6b0c"},{"problem":132,"code":"(fn [f y xs]\n (if (empty? (rest xs))\n  xs\n  (letfn [ \n   (-seq-tail [i js]\n     (if (empty? js)\n      (list i)\n      (ins-f-seq i (first js) (rest js)) )) \n   (ins-f-seq [a b bs]\n    (lazy-seq (cons a\n      (if (f a b)\n       (cons y (-seq-tail b bs))\n       (-seq-tail b bs)) )) )]\n    (ins-f-seq (first xs) (second xs) (rest (rest xs))) ) ))","user":"57f9011ee4b0d3187e900935"},{"code":"(fn f [pred val coll]\n  (lazy-seq\n    (cond\n      (empty? coll) ()\n      (empty? (rest coll)) coll\n      (pred (first coll) (second coll)) (cons (first coll) (cons val (f pred val (rest coll))))\n      :else (cons (first coll) (f pred val (rest coll))))))","problem":132,"user":"4e9519b4535dbda64a6f6b2d"},{"problem":132,"code":"(fn f\n  [p v xs]\n  (let [[x y] xs\n        r (lazy-seq (f p v (rest xs)))]\n    (cond\n      (and x y) (concat (if (p x y) (list x v) (list x)) r)\n      x (list x)\n      :else nil)))","user":"57a0b341e4b0c3d858beb8d4"},{"problem":132,"code":"(fn \n  [p v coll]\n  (letfn [(ins-val\n            [x y coll]\n            (if (empty? coll)\n              (if (p x y)\n                (list x v y) (list x y))\n              (lazy-seq\n                (if (p x y)\n                  (concat [x v] (ins-val y (first coll) (rest coll)))\n                  (cons x (ins-val y (first coll) (rest coll)))))))]\n    (if (second coll)\n      (ins-val (first coll) (second coll) (drop 2 coll))\n      coll)))","user":"56a36f76e4b0542e1f8d14ca"},{"code":"(fn [p v c]\n  (if (empty? c)\n    ()\n    (cons (first c)\n        (mapcat \n         #(if (p % %2)\n            [v %2]\n            [%2])\n         c\n         (rest c)))))","problem":132,"user":"50217818e4b00bba4502f7a7"},{"code":"(fn w[p s l]\n  (lazy-seq\n    (let [[a b] l]\n      (if-not a\n        []\n        (if (and b (p a b))\n          (cons a (cons s (w p s (next l))))\n          (cons a (w p s (next l))))))))","problem":132,"user":"4f1fd734535d64f6031464a5"},{"code":"(fn k [p v [f & r]]\n  (let [s (first r)]\n    (cond\n     (nil? f) []\n     (nil? s) [f]\n     :else\n     (lazy-cat\n      (if (p f s) [f v] [f])\n      (k p v r)))))","problem":132,"user":"519136e9e4b0f8ef0be96c01"},{"problem":132,"code":"(fn g [p v [f & r :as c]] (lazy-seq (if (empty? r)\n                                               c\n                                               (cons f\n                                                     (if (p f (first r))\n                                                       (cons v (g p v r))\n                                                       (g p v r))))))","user":"576e3258e4b0979f89651574"},{"code":";Without the last item in the coll:\n;(fn [p v c] (->> c\n;                 (partition 2 1)\n;                 (map #(apply p %))\n;                 (mapcat #(if (true? %2) [% v] [%]) c)))\n\n; Not lazy:\n;(fn [p v [x & xs]] (reduce #(if (p (last %) %2) (conj % v %2) (conj % %2)) [x] xs))\n\n; Lazy:\n(fn f [p v c] (let [x (first c)\n                    y (second c)]\n                (if-not x\n                  ()\n                  (cons x (when y\n                            (lazy-seq\n                              (f p v (if (or (= x v)\n                                             (not (p x y)))\n                                       (next c)\n                                       (cons v (next c))))))))))","problem":132,"user":"5028cd0fe4b01614d1633ffc"},{"problem":132,"code":"(fn insert2 \n  ([ pred val col ] (if (empty? col) [] (cons (first col) (insert2 pred val (rest col) (first col)))))\n  ([ pred val col prev ] \n  (lazy-seq\n    (if (empty? col) \n      nil\n      (if (pred prev (first col))\n        (cons val (cons (first col) (insert2 pred val (rest col) (first col))))\n        (cons (first col) (insert2 pred val (rest col) (first col))))))))","user":"55536a8ae4b0deb715856e03"},{"problem":132,"code":"(fn qqq[f v c] (if (seq c) \n                 (->> c\n                    (partition 2 1)\n                    (mapcat (fn [[q w]] (if (f q w) [v w] [w])))\n                    (cons (first c)))))","user":"6011b89ee4b074f607df66bc"},{"problem":132,"code":"(fn f [pred v coll]\n  (let [l (partition 2 1 coll)\n        t (fn [[a b]] (if (pred a b) [v b] [b]))\n        r (mapcat t l)] ;; reduce can't be lazy\n    (flatten (if (empty? coll) r (cons (first coll) r)))))","user":"53d86564e4b0e771c302546b"},{"problem":132,"code":"(fn insert-between [p v coll]\n  (letfn [(step [items]\n                (lazy-seq\n                 (when-not (empty? items)\n                   (let [[a b] (first items)]\n                     (if b\n                       (if (p a b)\n                         (cons a (cons v (step (rest items))))\n                         (cons a (step (rest items))))\n                       (cons a nil))))))]\n    (step (partition-all 2 1 coll))))","user":"58b81490e4b0ebc645576d8c"},{"problem":132,"code":"(fn f\n  [o x c]\n  (let [[e1 e2] c]\n    (if (and e1 e2)\n      (lazy-cat (if (o e1 e2)\n                  [e1 x]\n                  [e1])\n                (f o x (rest c)))\n      (if e1\n        [e1]\n        []))))","user":"52951156e4b02ebb4ef7501b"},{"problem":132,"code":"(fn [pred v coll]\n    (letfn [(step [[c & cs]]\n              (if-not (seq cs) (list c)\n                      (if (pred c (first cs))\n                        (cons c (lazy-seq (cons v (step cs))))\n                        (cons c (lazy-seq (step cs))))))]\n      (if (empty? coll) coll (step coll))))","user":"5d236215e4b02ea6f0fb6a09"},{"problem":132,"code":"(fn insert-between-two [fun to-insert coll]\n  (flatten (map #(cond\n          (= 1 (count %)) (first %)\n          (fun (first %) (second %)) [(first %) to-insert]\n          :else (first %))\n        (partition-all 2 1 coll))))","user":"509a25b7e4b0efbae1fbc0a8"},{"problem":132,"code":"(fn insert [pred x coll]\n   (if (empty? (rest coll))\n     coll\n     (if (pred (first coll) (first (rest coll)))\n       (lazy-seq (cons (first coll) (cons x (insert pred x (rest coll)))))\n       (lazy-seq (cons (first coll) (insert pred x (rest coll)))))))","user":"545e9cf1e4b01be26fd7467f"},{"problem":132,"code":"(fn \n  [f v c]\n  ((fn i\n    [c]\n    (lazy-seq \n      (if-let [b (second c)]\n        (let [t (rest c) a (first c)]\n          (if (f a b)\n            (list* a v (i t)) \n            (list* a (i t))))\n        c))) c))","user":"5578f292e4b05c286339e08f"},{"problem":132,"code":"(fn f [p v coll]\n   (let [[a b] coll]\n     (if b\n       (lazy-seq\n        (if (p a b)\n          (list* a v (f p v (next coll)))\n          (list* a (f p v (next coll)))))\n       coll)))","user":"500d3160e4b05f7c30cfa6a1"},{"code":"(fn _ [f v [x y :as coll]]\n  (lazy-seq\n    (if (and x y)\n      (if (f x y)\n        (list* x v (_ f v (rest coll)))\n        (list* x (_ f v (rest coll))))\n      coll)))","problem":132,"user":"527cd633e4b0757a1b17136f"},{"problem":132,"code":"(fn dm\n  [f f-doc arr]\n  (if (seq arr)\n    (if (and (second arr)\n             (f (first arr) (second arr)))\n      (concat [(first arr) f-doc] (lazy-seq (dm f f-doc (rest arr))))\n      (concat [(first arr)] (lazy-seq (dm f f-doc (rest arr)))))\n    arr))","user":"5036eba7e4b0af0658af77a5"},{"problem":132,"code":"(fn problem-132* [pred value coll]\n    (lazy-seq\n      (if-let [f (first coll)]\n        (if-let [s (second coll)]\n          (if (pred f s)\n            (cons f (cons value (problem-132* pred value (rest coll))))\n            (cons f (problem-132* pred value (rest coll))))\n          (cons f (problem-132* pred value (rest coll)))))))","user":"569f4dabe4b0542e1f8d1491"},{"problem":132,"code":"(fn ins-bet-lazy [p, v, col]\n\t(cond\n\t\t(= nil (second col)) col\n\t\t(p (first col) (second col))\n\t\t\t(lazy-seq\n\t\t\t\t(cons (first col)\n\t\t\t\t\t(cons v (ins-bet-lazy p, v, (rest col)))\n\t\t\t\t)\n\t\t\t)\n\t\t(not (p (first col) (second col)))\n\t\t\t(lazy-seq\n\t\t\t\t(cons\n\t\t\t\t\t(first col)\n\t\t\t\t\t(ins-bet-lazy p, v, (rest col))\n\t\t\t\t)\n\t\t\t)\n\t)\n)","user":"5d73530ce4b02e6b30c93514"},{"problem":132,"code":"(fn my-insert [pred marker col]\n  (if (seq col)\n    (if (and\n          (seq (rest col))\n          (pred (first col) (second col)))\n      (cons (first col) (cons marker (lazy-seq (my-insert pred marker (rest col)))))\n      (cons (first col) (lazy-seq (my-insert pred marker (rest col)))))))","user":"5596a324e4b04c1e5c31d757"},{"problem":132,"code":"(fn ins [f v [x y & _ :as coll]]\n  (lazy-seq\n   (when x\n     (cons x\n           (when y\n             (let [coll (ins f v (rest coll))]\n               (if (f x y)\n                 (cons v coll)\n                 coll)))))))","user":"5591cc56e4b0604b3f94d582"},{"code":"(fn mib [f iv s] \n    (if (or (empty? s) (empty? (rest s)))\n      s\n      (let \n        [fst (first s)\n         snd (second s)\n         rst (rest s)\n         ]\n        (if (f fst snd)\n          (cons fst (cons iv (lazy-seq (mib f iv rst)))) \n          (cons fst (lazy-seq (mib f iv rst)))\n          )\n        )\n      )\n    )","problem":132,"user":"50956c2be4b087f34d351ab2"},{"code":"#(mapcat (fn [[a b]] (if (and b  (% a b)) [a %2] [a])) (partition-all 2 1 %3))","problem":132,"user":"4ff67852e4b0678c553fc37e"},{"problem":132,"code":"(fn [pred token coll]\n  (concat (take 1 coll)\n    (mapcat #(if (pred %1 %2) [token %2] [%2]) coll (rest coll))))","user":"593f95d8e4b069cdc2982be3"},{"problem":132,"code":"(fn p2 [p i [h & t :as s]]\n  (if (nil? h)  ()\n  (flatten   \n     (cons h  \n        (map (fn [a b] (if (p a b) [i b] b)) s t)))))","user":"53a5bc3ae4b0ef122a8689c3"},{"code":"(fn insert-between [p v c]\n  (cond\n   (empty? c) '()\n   (empty? (rest c)) (take 1 c)\n   (p (first c) (second c)) (cons (first c) (cons v (lazy-seq (insert-between p v (rest c)))))\n   :else (cons (first c) (lazy-seq (insert-between p v (rest c))))))","problem":132,"user":"51d360d1e4b099f3b6acddff"},{"code":"(fn insert-between\n    [f v [head & others]]\n    (when head\n      (if (empty? others)\n        (list head)\n        (lazy-seq (cons head\n                        (if (f head (first others))\n                          (cons v (insert-between f v others))\n                          (insert-between f v others)))))))","problem":132,"user":"4dbb0f2d535d1e037afb21b1"},{"code":"(fn f\n  ([p v c]\n   (if (empty? c)\n     []\n     (f p v (rest c) (first c))))\n  ([p v c l]\n    (if (empty? c)\n      [l]\n      (lazy-seq (if (p l (first c)) (cons l (cons v (f p v (rest c) (first c)))) (cons l (f p v (rest c) (first c))))))))","problem":132,"user":"4f9f7daae4b0dcca54ed6d37"},{"problem":132,"code":"(fn inbetween [pred label [x y & xs :as lst]]\n  (lazy-seq\n    (cond\n      (nil? y) lst\n      (pred x y) (concat (list x label) (inbetween pred label (rest lst)))\n      :else      (cons x (inbetween pred label (rest lst))))))","user":"55d5e80ee4b0e31453f64a91"},{"problem":132,"code":"(fn [p v coll]\n  (filter (complement vector?)\n          (interleave coll\n                      (concat (->> (partition 2 1 coll)\n                                   (map #(if (apply p %) v []))) [[]]))))\n\n;(fn insert-between [p v c]\n;  (if (empty? c) '()\n;    (conj\n;      (mapcat\n;        (fn [[a b]]\n;          (if (p a b) [v b] [b])) \n;        (partition 2 1 c))\n;      (first c))))","user":"557c6ca6e4b05c286339e0c4"},{"code":"(fn f [p x [i & n :as s]]\n  (if n\n    (lazy-cat\n      [i]\n      (if (p i (nth s 1))\n        [x])\n      (f p x n))\n    s))","problem":132,"user":"4f6fbb68e4b07046d9f4efeb"},{"problem":132,"code":"(fn insert [f v c]\n  (mapcat (fn [[ a b]](if (and b (f a b)) [a v] [a])) (partition-all 2 1 c)))","user":"512b07f7e4b078b06821febb"},{"code":"(fn[o m coll]\n  (mapcat #(if (and \n                (not (nil? (second %))) \n                (o (first %) (second %)))\n             (list (first %) m)\n             (list (first %))) \n          (partition-all 2 1 coll)))","problem":132,"user":"532418f3e4b09d4e7a9b54d8"},{"code":"(fn insert-between [f v [x & r]]\n  (let [y (first r)]\n    (cond\n      (nil? x) nil\n      (nil? y) (list x)\n      :else (let [lazy-rest (lazy-seq (insert-between f v r))]\n              (if (f x y)\n                (cons x (cons v lazy-rest))\n                (cons x lazy-rest))))))","problem":132,"user":"539a2901e4b0b51d73faaf0f"},{"code":"(fn inb [op v [fst & rst :as coll]]\n  (if (seq coll)\n    (if rst\n      (if (op fst (first rst))\n        (cons fst (cons v (lazy-seq (inb op v rst))))\n        (cons fst (lazy-seq (inb op v rst))))\n      (cons fst nil))\n    coll))","problem":132,"user":"50645e12e4b007509339a58a"},{"code":"(fn insert [pred symb ls]\n  (cond (empty? ls)\n        '()\n        (nil? (second ls))\n        (list (first ls))\n        (pred (first ls) (second ls))\n        (lazy-seq (cons (first ls) (cons symb (insert\n                                               pred symb (drop 1 ls)))))\n        :else (lazy-seq (cons (first ls) (insert pred symb (drop 1 ls))))))","problem":132,"user":"5301157ae4b0d8b024fd3717"},{"code":"(fn ins [pred sep coll] \n (let [[a b] (take 2 coll)]\n  (if (or (nil? a) (nil? b)) coll\n   (let [curr (if (pred a b) [a sep] [a])]\n    (concat curr (lazy-seq (ins pred sep (rest coll))))))))","problem":132,"user":"4dcfbc44535d5973398f92a7"},{"problem":132,"code":"(fn [p v coll] (if (empty? coll) '() \n   (->> (partition 2 1 coll)\n                    (map (fn [[a b]] (if (p a b) (list v b) b)))\n                    flatten\n                    (cons (first coll)))))","user":"56b86e64e4b0f26550335924"},{"code":"(fn [pred sep [f & xs :as col]]\n  (if f \n    (cons f\n      (mapcat \n        #(if (pred % %2) (list sep %2) (list %2))\n        col xs))))","problem":132,"user":"4ec16c21535dfed6da9c6dac"},{"problem":132,"code":"(fn insrt [pred value coll & add]\n  (if (not (seq (rest coll)))\n      (if add [] coll)\n      (lazy-cat \n        (let [left (first coll) right (first (rest coll))]\n          (if (pred left right)\n            (if add [value right] [left value right])\n            (if add [right]       [left right])))\n        (insrt pred value (rest coll) true))))","user":"579d9601e4b05b1deef9ae18"},{"code":"(fn [p v xs]\r\n  (mapcat\r\n    #(if (p %1 %2) [%1 v] [%1])\r\n    xs\r\n    (lazy-cat (rest xs) (take 1 xs))))","problem":132,"user":"4f1b92d1535d64f60314647b"},{"code":"#((fn f [s] (if (seq s) (cons (first s) (if (and (second s) (% (first s) (second s))) (cons %2 (lazy-seq (f (rest s)))) (lazy-seq (f (rest s))))))) %3)","problem":132,"user":"51f66e0ee4b06ff1c25c52c3"},{"problem":132,"code":"#(letfn[(insert [function last-value separator collection]\n               (if (seq collection)\n                 (let [current-value (first collection)]\n                 (concat \n                  (if (function last-value current-value) [last-value separator] [last-value])\n                  (lazy-seq (insert function current-value separator (next collection)))))\n                 [last-value]))]\n  (when(seq %3)\n    (insert %1 (first %3) %2 (next %3))))","user":"541619e8e4b01498b1a719f9"},{"problem":132,"code":"(fn o [p i c]\n    (let [f (first c)\n          s (second c)\n          r (rest c)]\n      (if (nil? s)\n        c\n        (if (p f s)\n          (lazy-cat (list f i) (o p i r))\n          (cons f (o p i r)))))\n    )","user":"603ae21de4b0d5df2af222fb"},{"problem":132,"code":"#(mapcat (fn [[a b]] (if (and b (%1 a b)) [a %2] [a])) (partition-all 2 1 %3))","user":"54769c7ae4b0c51c1f4d72a8"},{"code":"(fn [p v c]\n    (if (empty? c) []\n      (concat [(first c)] \n              (mapcat \n                (fn [[a b]] \n                  (if (p a b) [v b] [b]))\n                (partition 2 1 c)))))","problem":132,"user":"4f4274f2e4b0d7d3c9f3fd00"},{"problem":132,"code":"(fn [pred sep xs]\n  (let [col (partition-all 2 1 xs)]\n    ((fn step [items]\n       (lazy-seq\n        (when-not (empty? items)\n          (let [[prev cur] (first items)]\n            (if cur\n              (if (pred prev cur)\n                (cons prev (cons sep (step (rest items))))\n                (cons prev (step (rest items))))\n              (cons prev nil))))))\n     col)))","user":"53bcdd41e4b0d9a98559a6c0"},{"problem":132,"code":"(fn insert- [pred val coll]\n         (cond\n           (empty? coll) nil\n           (empty? (rest coll)) coll\n           :else (if (pred (first coll) (second coll))\n                   (cons (first coll) (cons val (lazy-seq (insert- pred val (rest coll)))))\n                   (cons (first coll) (lazy-seq (insert- pred val (rest coll))))\n                   )))","user":"5d9c1226e4b0d3f9b434ad51"},{"problem":132,"code":"(fn twoItem [p v coll]\n  (cond\n    (empty? coll) '()\n    (empty? (rest coll)) (list (first coll))\n    :else (if (p (first coll) (second coll))                                                                                                        \n            (cons (first coll)\n                  (cons v\n                        (lazy-seq (twoItem p v (rest coll)))))\n            (cons (first coll)\n                  (lazy-seq (twoItem p v (rest coll)))))))","user":"54f64e99e4b0f2f3c5226ea4"},{"problem":132,"code":"(fn ins [pred v [hd & tl :as coll]]\n  (cond\n    (empty? coll)           ()\n    (empty? tl)             [hd]\n    (pred hd (first tl))    (lazy-seq (concat [hd v] (ins pred v tl)))\n    :else                   (lazy-seq (concat [hd] (ins pred v tl)))))","user":"58dcf11ae4b0a4d5acaab6af"},{"code":"(fn insert-between [p v coll]\n  (if (empty? coll)\n    coll\n    (reduce #(cond (empty? %1) [%2]\n                   (p (last %1) %2) (conj %1 v %2)\n                   :else (conj %1 %2))\n            [] (take 12 coll))))","problem":132,"user":"50733b31e4b0e3170b5a869a"},{"problem":132,"code":"(fn ins [pred v coll]\n  (lazy-seq\n   (when-let [s (seq coll)]\n    (let [[a b] (take 2 s)]\n      (if (and b (pred a b))\n        (cons a (cons v (ins pred v (rest s))))\n        (cons a (ins pred v (rest s))))))))","user":"540a4f20e4b0addc1aec66ef"},{"problem":132,"code":"(fn [pred marker xs]\n  (concat (take 1 xs) \n          (mapcat (fn [[a b]] (if (pred a b) [marker b] [b]))\n                  (partition 2 1 xs))))","user":"5821b018e4b04b46fc4b0f80"},{"code":"(fn [p v c] (->> c\n                  (partition-all 2 1)\n                  (map #(if (and (= 2 (count %)) (apply p %)) (list (first  %) v) (first  %)))\n                  flatten\n                  ))","problem":132,"user":"50563ae2e4b0ce54f56f0405"},{"problem":132,"code":"(fn r [p v coll]\n  (letfn [(f [[a b]]\n            (if (and (not (nil? b)) (p a b)) [a v] [a])),\n          (r [c] \n            (if (empty? c) [] (lazy-seq (concat (f (first c)) (r (rest c))))))]\n    (r (partition 2 1 [] coll))))","user":"567695c2e4b05957ce8c6157"},{"problem":132,"code":"(fn [f k xs]\n  (if (= (take 1 xs) (take 2 xs))\n    xs\n    (let [foo (fn [xs]\n                (let [xy (partition 2 (interleave xs (rest xs)))\n                      baz (fn [[x y]]\n                            (if (f x y)\n                              [k y]\n                              [y]))\n                      ky (map baz xy)]\n                  ky))\n          ys (foo xs)\n          ys1 (map first ys)\n          ys2 (map second ys)\n          ys3 (interleave ys1 ys2)]\n      (filter (fn [_] (not (nil? _)))\n              (conj ys3 (first xs))))))","user":"54d753ebe4b0a52adc2e2029"},{"problem":132,"code":"(fn [p v c]\n  (when (seq c)\n    (->> c\n       (partition 2 1)\n       (map (fn [[a b]] (if (p a b) [a v b] [a b])))\n       (mapcat #(drop 1 %))\n       (cons (first c)))))","user":"53ea5307e4b036ad0777e4e2"},{"code":"(fn ibti [p v c]\n  (filter #(not (nil? %)) (interleave c (concat (map #(if (true? (apply p %)) v) (partition 2 1 c)) '(nil)))))","problem":132,"user":"5123ac8ee4b061b4c6f0e0b1"},{"code":"#(reduce (fn [r c] (cond \n                           (empty? r) (conj r c)\n                           (true? (%1 (last r) c)) (conj r %2 c)\n                           :else (conj r c))) [] (take 20 %3))","problem":132,"user":"511b810ce4b07ab9ec456182"},{"problem":132,"code":"(fn insert-between [f pred s]\n  (if (empty? s)\n    []\n    ((fn helper [s prev]\n       (if (empty? s)\n         [prev]\n         (if (f prev (first s))\n           (lazy-seq (cons prev\n                           (cons pred\n                                 (helper (drop 1 s)\n                                         (first s)))))\n           (lazy-seq (cons prev (helper (drop 1 s)\n                                        (first s)))))))\n     (drop 1 s) (first s))))","user":"5dc53ddee4b02f9375f4e1bd"},{"problem":132,"code":"(fn fu [pr v c]\n  (let [f (first c)\n        s (second c)]\n    (if (not s) c\n      (lazy-seq (concat (if (pr f s) [f v] [f]) (fu pr v (rest c)))))))","user":"56b6e354e4b0982f16b37e41"},{"code":"(fn ins [f sym coll]\n  (if (-> coll rest seq nil?)\n    coll\n    (let [x1 (first coll)\n          r (rest coll)\n          x2 (first r)\n          x (if (f x1 x2) [x1 sym] [x1])]\n      (lazy-cat x (ins f sym r)))))","problem":132,"user":"514c2d05e4b02b8cbb2a9278"},{"problem":132,"code":"(fn r [pred inter coll]\n  (lazy-seq\n   (when-let [s (seq coll)]\n     (cons (first s)\n           (for [[left right] (partition 2 1 s)\n                 item (if (pred left right)\n                        [inter right]\n                        [right])]\n             item)))))","user":"51aefceee4b09397d5109797"},{"code":"(fn insert [pred item coll] (lazy-seq\n    (if (next coll)   ; if coll has more than one item\n        (let [[x1 x2 & xs] coll\n              tail (insert pred item (cons x2 xs))]\n            (if (pred x1 x2)\n                (list* x1 item tail)\n                (list* x1 tail)))\n        coll\n    )))","problem":132,"user":"4df3d4f4535d08e6dec9fe2c"},{"problem":132,"code":"(fn p [pre k col]\n  (if (nil? (second col))\n    col\n    (let [fir (first col)\n          sec (second col)]\n      (if (pre fir sec)\n        (concat [fir k] (lazy-seq (p pre k (rest col))))\n        (concat [fir]   (lazy-seq (p pre k (rest col))))))))","user":"53664e3be4b0243289761e74"},{"code":"(fn tween\n  ([f marker items]\n     (when (seq items)\n       (lazy-seq (cons (first items) (tween f marker (first items) (rest items))))))\n\n  ([f marker prev items]\n     (when (seq items)\n       (if (f prev (first items))\n         (lazy-seq (cons marker (tween f marker items)))\n         (lazy-seq (cons (first items) (tween f marker (first items) (rest items))))))))","problem":132,"user":"4f0d093b535d0136e6c22313"},{"problem":132,"code":"(fn step [p v [x0 x1 :as xs]]\n    (cond (not x0)        nil\n          (not x1)        (cons x0 nil)\n          (not (p x0 x1)) (cons x0 (lazy-seq         (step p v (next xs))))\n          :else           (cons x0 (lazy-seq (cons v (step p v (next xs)))))))","user":"5a5d0726e4b0512ff01cd91b"},{"problem":132,"code":"(fn f [p v [c1 & [c2 & _ :as cr]]]\n  (lazy-seq\n   (cond\n     (not c1) nil\n     (not c2) (cons c1 nil)\n     (p c1 c2) (cons c1 (cons v (f p v cr)))\n     :else (cons c1 (f p v cr)))))","user":"569dd6e8e4b0542e1f8d1480"},{"code":"(fn ins [p v c]\n (if (empty? (rest c)) c (lazy-seq\n     (cons (first c) (if (p (first c) (second c))\n                         (cons v (ins p v (rest c)))\n                         (ins p v(rest c)))))))","problem":132,"user":"4fca1cd6e4b0ee37620e184c"},{"code":"(fn [f v [x & xs :as xxs]]\n  (if (empty? xxs) xxs\n    (cons x\n          (mapcat #(if (f %1 %2) [v %2] [%2]) xxs xs))))","problem":132,"user":"52dc2bc8e4b09f7907dd13ca"},{"problem":132,"code":"(fn [p v xs]\n  (if (empty? xs)\n    xs\n  (cons (first xs)\n        (mapcat (fn [[a b]]\n                  (if (p a b)\n                    [v b] [b]))\n          (partition 2 1 xs)))\n    ))","user":"5208495ce4b0c1501ba9e6da"},{"problem":132,"code":"(fn [f s x] (apply concat (take 1 x) (map #(if (f %1 %2) [s %2] [%2]) x (rest x))))","user":"543d5c61e4b032a45b86934d"},{"code":"(fn [p v s] (mapcat #(if (and (second %) (apply p %)) [(first %) v] [(first %)]) (partition-all 2 1 s)))","problem":132,"user":"500854c4e4b028e089d3518c"},{"code":"(fn ins [pred v s]\n  (if-not (seq s)\n    s\n    (let [two (take 2 s)\n          [a b] two]\n      (concat (seq (if (and (== (count two) 2)\n                            (pred a b))\n                     [a v]\n                     [a]))\n              (lazy-seq (ins pred v (drop 1 s)))))))","problem":132,"user":"52d3f666e4b09f7907dd1327"},{"problem":132,"code":"(fn insert-between-two-items\n  [pred v [h & tail]]\n  (if h\n    (cons h (cond\n              (empty? tail) []\n              (pred h (first tail)) (cons v (lazy-seq (insert-between-two-items pred v tail)))\n              :else (lazy-seq (insert-between-two-items pred v tail))))\n    []))","user":"5f37263de4b0574c87022c4e"},{"problem":132,"code":"(fn [p e c]\n  (remove nil?\n          (interleave c\n                      (concat\n                       (map\n                        #(when % e)\n                        (map #(apply p %) (partition 2 1 c)))\n                       [nil]))))","user":"57ee82b1e4b0bfb2137f5bbd"},{"problem":132,"code":"(fn [p v [f & r :as c]]\n  (if (empty? c)\n    c\n    (cons f (mapcat #(if (p % %2) [v %2] [%2]) c r))))","user":"5c1aadcde4b01240ff567209"},{"code":"(fn [predicate value collection]\n  (letfn [(insert-between [a [b & coll]]\n                          (lazy-seq\n                           (if a\n                             (cons a ((if (and b (predicate a b))\n                                        (partial cons value)\n                                        identity)\n                                      (insert-between b coll))))))]\n    (insert-between (first collection) (rest collection))))","problem":132,"user":"51307b84e4b08c712d3fae39"},{"problem":132,"code":"(fn g [p v [x y & zs :as coll]]\n  (if-not (empty? coll)\n    (if (and x y (p x y))\n      (lazy-seq (cons x (cons v (g p v (rest coll)))))\n      (lazy-seq (cons x (g p v (rest coll)))))))","user":"506ba58be4b0eda3100c090b"},{"problem":132,"code":"(fn [pred b-v [x & xs :as coll]]\n  (letfn [(f [l [x & xs :as coll]]\n             (lazy-seq (cond \n                        (empty? coll) (list l)\n                        (pred l x) (cons l (cons b-v (f x xs)))\n                        :else (cons l (f x xs)))))]\n    (if (empty? coll) '() (f x xs))))","user":"5339c105e4b0e30313ee6cae"},{"code":"(fn insert-between-items [p v coll]\n    ((fn lz [x y z]\n      (lazy-seq\n       (if (not (second z))\n        z\n        (if (x (first z) (second z))\n            (cons (first z) (cons y (lazy-seq (lz x y (rest z))) ))\n            (cons (first z) (lazy-seq (lz x y (rest z))) ))))) \n     p v coll))","problem":132,"user":"50c8697ce4b00bb60fe0c53f"},{"problem":132,"code":"(fn [f value coll]\n  (mapcat\n   (fn [[a b]]\n     (cons a (when (and a b (f a b)) [value])))\n   (partition-all 2 1 coll)))","user":"5472d919e4b094393f72dd7b"},{"code":"(fn ins-pred\n  [f sym s]\n  (if (empty? s)\n    []\n    (last\n      (take 20\n            (reductions (fn [r e]\n                          (if (f (last r) e)\n                            (conj (conj r sym) e)\n                            (conj r e)))\n                        [(first s)] (rest s))))))","problem":132,"user":"5348cab4e4b084c2834f4a5e"},{"code":"#(apply concat\n        (take 1 %3)\n        (for [[a b] (partition 2 1 %3)]\n          (if (% a b)\n            [%2 b]\n            [b])))","problem":132,"user":"50a83315e4b054305ba5a830"},{"code":"(fn f [p k [a & c]]\n\t(cond\n\t  (nil? a) []\n\t  (empty? c) [a]\n      :else (lazy-cat (if (p a (first c)) [a k] [a]) (f p k c) ) ))","problem":132,"user":"50d0d4c8e4b00b15ecee976a"},{"code":"(fn o [p s c] (cond (nil? (second c)) c (p (first c) (second c)) (cons (first c) (cons s (lazy-seq (o p s (rest c))))) \n                     :else (cons (first c) (lazy-seq (o p s (rest c)))) ))","problem":132,"user":"50fbdacfe4b0d10d794c19f0"},{"code":"(fn [p sep coll]\n  (if (empty? coll)\n    []\n    (cons\n     (first coll)\n     (mapcat\n      #(if %2 [sep %1] [%1])\n      (rest coll)\n      (map #(when (apply p %) sep) (partition 2 1 coll))))))","problem":132,"user":"504f57c7e4b0a02f9cffde71"},{"problem":132,"code":"(fn ibt \n  ([f v l] (ibt f v l nil))\n  ([f v l la]\n  (if (empty? l) nil\n    (if (or (nil? la) (not (f la (first l))))\n      (cons (first l) (lazy-seq (ibt f v (rest l) (first l))))  \n      (cons v (lazy-seq (ibt f v l nil)))))))","user":"52747090e4b03e8d9a4a74a5"},{"problem":132,"code":"(fn [p v col]\n  (if (empty? col)\n    col\n    (cons (first col)\n          (apply concat (map #(if (p %1 %2)\n                               [v %2] [%2]) col (rest col))))))","user":"50f10f7be4b06d9538fe211a"},{"code":"(fn ibti [p k [h & [s :as r]]]\n  (if (nil? h) ()\n    (#(if (and (not (nil? s)) (p h s))\n          (cons h (cons k %))\n          (cons h %))\n     (lazy-seq (ibti p k r)))))","problem":132,"user":"4fd96694e4b05e33b9224f37"},{"problem":132,"code":"(fn [op kw xs]\n  (flatten\n    (lazy-seq\n      (map (fn [[x y]] (if (nil? y) [x] (if (op x y) [x kw] x))) (partition-all 2 1 xs)))))","user":"54e24a05e4b024c67c0cf7ce"},{"problem":132,"code":"(fn insert\n  [f p [x & xs]]\n  (if (empty? xs)\n    (if x [x] [])\n    (lazy-seq (if (f x (first xs))\n                (cons x (cons p (insert f p xs)))\n                (cons x (insert f p xs))))))","user":"54b7f217e4b0ed20f4ff6e8f"},{"code":"(fn [pred v [h & t :as s]]\n  (when-let [s (seq s)]\n    (cons h\n          (mapcat #(if (pred % %2) [v %2] [%2]) s t))))","problem":132,"user":"524b0645e4b09eba1c0223bf"},{"problem":132,"code":"(fn [p v c]\n  (if (seq c) \n    (cons (first c) (mapcat (fn [[x y]] (if (p x y) [v y] [y])) (partition 2 1 c)))\n    '()))","user":"529dfc6de4b04e0c58e87b8a"},{"code":"(fn ! \n  ([f v c]\n    (if-not (empty? c) \n      (cons (first c) (! f v c *))))\n  ([f v c _] \n    (let [[a b] c]\n      (lazy-cat\n        (if b\n          (let [C #(cons b (! f v (rest c) *))]\n            (if (f a b)\n              (cons v (C)) (C))))))))","problem":132,"user":"512f06c5e4b0762be4c7aad7"},{"problem":132,"code":"(fn ins [pred value all]\n(if (empty? all)\n  '()\n(cons (first all) \n      (mapcat #(if (pred %1 %2) [value %2] [%2]) all (rest all)))))","user":"57011eb3e4b08d47c97781d1"},{"code":"(fn insert [pred x [y1 y2 & ys]]\n  (lazy-seq\n    (if y1\n      (if y2\n        (let [res (if (pred y1 y2) [y1 x] [y1])]\n          (concat res (insert pred x (cons y2 ys))))\n        [y1])\n      [])))","problem":132,"user":"4fe13ad7e4b0dd6cd5ce3632"},{"code":"(fn [p v s]\n  ((fn ins [p v s1 s2]\n    (lazy-seq\n     (let [a (seq s1) b (seq s2)]\n          (if (and a b)\n            (cons (first a) \n                  (if (p (first a) (first b)) \n                    (cons v (ins p v (rest a) (rest b)))\n                    (ins p v (rest a) (rest b))))\n            a)))) p v s (rest s)))","problem":132,"user":"4f05ea25535dcb61093f6c02"},{"problem":132,"code":"(fn inx [pred ime [a b & r :as coll]]\n  (lazy-seq\n    (when-not (empty? coll)\n     (concat\n      (list a)\n      (when (and (not (empty?  (rest coll))) (pred a b))\n        (list ime))\n      (inx pred ime (rest coll))))))","user":"56f9c7c6e4b07572ad1a88ba"},{"problem":132,"code":"(fn [pred valu coll]\n      (->> coll\n           (partition-all 2 1)\n           (mapcat (fn [[v1 v2]] (if (and v2 (pred v1 v2)) [v1 valu] [v1])))\n\n           ))","user":"5f548678e4b0a0bc16850a7e"},{"problem":132,"code":"(fn ip [p v [a b & r :as xs]]\n    (if (seq xs)\n      (cons a (if (and b (p a b))\n                (cons v (lazy-seq (ip p v (next xs))))\n                (lazy-seq (ip p v (next xs)))))))","user":"59fa241ee4b0ca45a743a358"},{"problem":132,"code":"(fn insert-pred\n  [compare x coll]\n  (mapcat (fn [[a b]]\n           (if (and a b (compare a b))\n             (list a x)\n             (list a)))\n         (partition-all 2 1 coll)))","user":"4e586949535d8a8b8723a292"},{"problem":132,"code":"(fn insert-between [pred x coll]\n  (if (instance? clojure.lang.LazySeq coll)\n    (lazy-seq\n      (concat (if (and\n                    (first coll)\n                    (second coll)\n                    (pred (first coll) (second coll)))\n                (conj [] (first coll) x)\n                (conj [] (first coll)))\n              (insert-between pred x (rest coll))))\n    (if (empty? coll)\n      []\n      (concat (if (and\n                    (first coll)\n                    (second coll)\n                    (pred (first coll) (second coll)))\n                (conj [] (first coll) x)\n                (conj [] (first coll)))\n              (insert-between pred x (rest coll))))))","user":"590b3aeae4b047aa04b199d0"},{"code":"(fn insert [p v coll]\n  (if (not (seq (next coll)))\n    coll\n    (concat\n     (if (p (first coll)\n            (second coll))\n       [(first coll) v]\n       [(first coll)])\n     (lazy-seq (insert p v (next coll))))))","problem":132,"user":"531d34cfe4b08068f379edac"},{"problem":132,"code":"(fn [p v [f :as c]]\n  (when (seq c)\n    (cons f (mapcat (fn [[a b]] (if (p a b) [v b] [b])) (partition 2 1 c)))))","user":"4eb70649535d7eef30807373"},{"problem":132,"code":";(\n(fn [f i li]\n  (letfn\n    [(partition-between [f coll]\n      \"Splits coll into a lazy sequence of lists, with partition \n      boundaries between items where (f item1 item2) is true.\n      (partition-between = '(1 2 2 3 4 4 4 5)) =>\n      ((1 2) (2 3 4) (4) (4 5))\"\n      (lazy-seq\n        (when-let [s (seq coll)]\n          (let [fst (first s)]\n            (if-let [rest-seq (next s)]\n              (if (f fst (first rest-seq))\n                (cons (list fst) (partition-between f rest-seq))\n                (let [rest-part (partition-between f rest-seq)]\n                  (cons (cons fst (first rest-part)) (rest rest-part))))\n              (list (list fst)))))))]\n    (rest (apply\n              concat\n              (interleave\n               (repeat [i])\n               (partition-between f li))))))\n;< :less [1 6 7 4 3])","user":"586a657de4b0f14aab7c88bd"},{"code":"(fn [f s c]\n  (if (empty? c)\n    c\n    (cons (first c) \n        (mapcat #(if (f % %2) [s %2] [%2]) \n                c (rest c)))))","problem":132,"user":"4e68b46c535d8ccf87e9fe87"},{"problem":132,"code":"(fn ib [p v xs]\n  (lazy-seq\n   (when-not (empty? xs)\n     (if (and (not (nil? (first (rest xs)))) (p (first xs) (first (rest xs))))\n       (cons (first xs) (cons v (ib p v (rest xs))))\n       (cons (first xs) (ib p v (rest xs)))))))","user":"56069006e4b08b23635d3174"},{"code":"(fn insert-between [pred v coll]\n  (when (seq coll)\n  (lazy-seq\n    (cons (first coll)\n           (if (empty? (rest coll)) ()\n             (if (pred (first coll) (second coll))\n               (cons v (insert-between pred v (rest coll)))\n               (insert-between pred v (rest coll))))))))","problem":132,"user":"4e521cef535d302ef430da6d"},{"problem":132,"code":";; kind of ugly...\n(fn [rel key coll]\n  (let [pairs (partition 2 1 coll)\n        rel-keys (map #(if (rel (first %) (second %)) [key (second %)] [nil (second %)]) pairs)]\n    (filter #(not= nil %) (flatten (conj rel-keys (first coll))))))","user":"53322cece4b019098a6f8b73"},{"code":"(fn [pred token s]\n    (when (seq s)\n      (cons (first s)\n            (apply concat\n                   (for [[a b] (partition 2 1 s)]\n                     (if (pred a b)\n                       [token b]\n                       [b]))))))","problem":132,"user":"4ee26f01535d10e5ff6f5368"},{"problem":132,"code":"(fn f [p s coll] \n\t(lazy-seq (if (empty? coll) [] (cons (first coll)\n\t                                     (if (empty? (rest coll)) nil (if (p (first coll) (first (rest coll))) \n\t                                                                      (cons s (f p s (rest coll)))\n\t                                                                      (f p s (rest coll))))))))","user":"5a14228fe4b0ff51aa4b3193"},{"code":"(fn i [p v [n & [m & ms :as rst]]]\n  (if m \n    (lazy-cat [n] (when (p n m) [v]) (i p v rst))\n    (when n [n])))","problem":132,"user":"4e8e8c24535d65386fec2143"},{"code":"(fn weave [p a xs]\n  (if (empty? xs)\n      xs\n      (->> (partition 2 1 xs)\n       (mapcat (fn [[x y]] (if (p x y) [ a y] [ y])))\n       (cons (first xs)))))","problem":132,"user":"53691dc7e4b0243289761e97"},{"code":"(fn [f x s]\n(if (empty? s) s\n  (cons (first s) (mapcat #(if (f % %2) [x %2] [%2]) s (rest s)))\n  )\n  )","problem":132,"user":"514457fbe4b0b4fb4ace5f43"},{"code":"#(if (seq %3)\n     (cons (first %3)\n           (flatten (map (fn [[b a]] (if (% b a) [%2 a] a))\n                         (partition 2 1 %3))))\n     [])","problem":132,"user":"4ee88bfb535d93acb0a66881"},{"code":"(fn [p v c]\n  (remove #(= % :AR-NO)\n   (rest (interleave\n    (map\n      #(if (and\n             (not (= :AR-FIRST %2))\n             (p %2 %1))\n             v\n             :AR-NO)\n      c\n      (concat [:AR-FIRST] c))\n     c))))","problem":132,"user":"4ea7999e535d7eef308072ee"},{"problem":132,"code":"(fn f [p v coll]\n  (when-let [s (seq coll)]\n    (when-let [[x & [y & _ :as r1]] s]\n      (if r1\n        (concat (if (p x y) [x v] [x]) (lazy-seq (f p v r1)))\n        (list x)))))","user":"5d0bb4fae4b0cc9c91588237"},{"code":"(fn insert-e [f item x]\n  (lazy-seq\n    (if (empty? x) '()\n      (if (-> x second nil?) x\n        (if (f (first x) (second x))\n        (conj (insert-e f item (rest x)) item (first x))\n        (cons (first x) (insert-e f item (rest x))))))))","problem":132,"user":"52084f75e4b01ce6bbf31dde"},{"code":"(fn [pred inter coll]\n  (lazy-seq\n   (when-let [s (seq coll)]\n     (cons (first s)\n           (mapcat (fn [[left right]]\n                     (if (pred left right)\n                       [inter right]\n                       [right]))\n                   (partition 2 1 s))))))","problem":132,"user":"4dabb7b1950ed6eda1bd72f3"},{"problem":132,"code":"(fn insert-between [pred-fn itm start-seq]\n                         (let [a (first start-seq)\n                               b (second start-seq)]\n                           (cond\n                            (nil? a) ()\n                            (nil? b) (cons a ())\n                            (pred-fn a b) (cons a (cons itm (lazy-seq (insert-between pred-fn itm (rest start-seq)))))\n                            :else (cons a (lazy-seq (insert-between pred-fn itm (rest start-seq)))))))","user":"54cad2d5e4b057c6fda3a26c"},{"problem":132,"code":"(fn insert-between [pred value coll]\n  (filter #(not (nil? %))\n          (interleave\n           coll\n           (concat\n            (map\n             #(if (pred %1 %2) value)\n             coll\n             (rest coll))\n            [nil]))))","user":"57b9fb56e4b0fbc9809a27fa"},{"problem":132,"code":"(fn insert\n  ([p v f coll]\n   (let [ret (if (or (empty? coll) (not (p f (first coll))))\n               [f]\n               [f v])]\n     (cond\n      (empty? coll) ret\n      :else (lazy-seq\n             (concat ret (insert p v (first coll) (rest coll)))))))\n  ([p v coll]\n   (if (empty? coll)\n     '()\n     (insert p v (first coll) (rest coll)))))","user":"4f041de1535dcb61093f6ba5"},{"problem":132,"code":"(fn [p v coll] (if (empty? coll) [] (let [go \n  (fn go [x & r] (when-let [y (first r)] \n    (concat (if(p x y) [v y] [y]) (lazy-seq (apply go r)))))]\n   (cons (first coll) (lazy-seq (apply go coll))))))","user":"53fe1c3be4b0de5c418485f2"},{"code":"(fn add ([f k l](add f k l nil))\n  ([f k l p]\n    (lazy-seq \n      (cond (empty? l) l\n            (nil? p) (cons (first l) (add f k (rest l) (first l)))\n            (f p (first l)) (cons k (cons (first l) (add f k (rest l) (first l))))\n            :else (cons (first l) (add f k (rest l) (first l)))))))","problem":132,"user":"507fbd77e4b089ade05efbd3"},{"code":"(fn f [p v s]\n  (if (not (next s))\n    s\n    (let [l (lazy-seq (f p v (rest s)))\n          fst (first s)]\n      (if (p fst (second s))\n        (cons fst (cons v l))\n        (cons fst l)\n      )\n    )\n  )\n)","problem":132,"user":"4e1350af535d04ed9115e7d8"},{"code":"(fn insert \n  ([p v s] (insert p v s nil))\n  ([p v s last-added]\n    (if (empty? s) ()\n      (reduce #(cons %2 %1)\n        (lazy-seq (insert p v (rest s) (first s)))\n        (if (and (not (nil? last-added)) (p last-added (first s)))\n          [(first s) v]\n          [(first s)])))))","problem":132,"user":"4dad76588e77d6ed63f12a44"},{"problem":132,"code":"(fn [f value a](if (empty? a) [] (->> (partition 2 1 a)\n(mapcat (fn [[x y]](if (f x y) [value y] [y])))\n(cons (first a)))))","user":"5849ac5fe4b089d5ab817ed7"},{"problem":132,"code":"(fn [op k col]\n  (if (empty? col) col\n    (cons (first col)\n          (mapcat\n             #(let [f (first %) s (second %)] (if (op f s) (list k s) (list s)))\n               (partition 2 1 col)))))","user":"50856bd1e4b004985b776e4c"},{"problem":132,"code":"(let [insert-between\n      (fn insert-between [pred value coll]\n        (cond\n          (< (count (take 2 coll)) 2) coll\n          (apply pred (take 2 coll)) (cons (first coll) (cons value (lazy-seq (insert-between pred value (next coll)))))\n          :else (cons (first coll) (lazy-seq (insert-between pred value (next coll))))))]\n   insert-between)","user":"5412ef7ee4b01498b1a719da"},{"code":"(fn g [f v [x & y]]\n   (lazy-seq\n    (if (and (seq y) (f x (first y)))\n      (cons x (cons v (g f v y)))\n      (if x\n        (cons x (g f v y))))))","problem":132,"user":"4fa05b99e4b0dcca54ed6d47"},{"problem":132,"code":"(fn [p v c]\n    (->> c (partition 2 1)\n     (map #(if (apply p %)  [(first %) v (last %)] %))\n     (map rest)\n      flatten\n     (#(if-let [c (first c)] (cons c %) % ))\n    ))","user":"5a244240e4b0ff51aa4b32e9"},{"code":"(fn insert-where [pred val seq]\n  (cond (empty? (drop 1 seq)) seq\n        (pred (first seq) (second seq))\n            (lazy-seq (concat\n                          (list (first seq) val)\n                          (insert-where pred val (rest seq))))\n        :else\n        (lazy-seq (cons (first seq)\n                        (insert-where pred val (rest seq))))))","problem":132,"user":"4fe87e56e4b07c9f6fd12c40"},{"problem":132,"code":"(fn [p n c]\n  (if (empty? c) []\n    ((fn step [c l]\n       (if (empty? c) []\n         (if (and (not (nil? l)) (p l (first c)))\n           (cons n (cons (first c) (lazy-seq (step (rest c) (first c)))))\n           (cons (first c) (lazy-seq (step (rest c) (first c)))))))\n     c nil)))","user":"5492164ee4b0b312c081ff3e"},{"code":"(fn [p e s]\n  (if (seq s)\n  (cons (first s) (mapcat (fn [[a b]] (if (p a b) [e b] [b]))\n  (map vector s (rest s))))\n  s))","problem":132,"user":"4eb0a757535d7eef3080733d"},{"problem":132,"code":"(fn pred-interpose [bpred? item l]\n  (letfn [(helper [a coll]\n            (lazy-seq\n             (when-let [xs (seq coll)]\n               (let [b (first xs)]\n                 (if (bpred? a b)\n                   (cons item (cons b (helper b (rest xs))))\n                   (cons b (helper b (rest xs))))))))]\n    (when-let [xs (seq l)]\n      (let [a (first xs)]\n        (cons a (helper a (rest xs)))))))","user":"4fc8c8d8e4b0ee37620e183b"},{"problem":132,"code":"(fn insert-between [predicate delimiter xs]\n  (mapcat (fn [[a b]] (if (and (not (nil? b)) (predicate a b)) (list a delimiter) (list a)))\n          (partition-all 2 1 xs)))","user":"549dfe40e4b0f3d1d8e70f9a"},{"problem":132,"code":"(fn [f v coll] (keep identity \n                     (interleave coll (concat \n                                       (map (comp {true v, false nil} f) coll (rest coll))\n                                       [nil]))))","user":"5960a1a6e4b066ee0a44b08e"},{"code":"(fn between [pred? v acoll]\n  (if (empty? acoll)\n    acoll\n    (let [gaps (map #(if (apply pred? %) [v] []) (partition 2 1 acoll))]\n      (flatten\n        (cons\n          (first acoll)\n          (interleave gaps (rest acoll)))))))","problem":132,"user":"4eb9ce75535dfed6da9c6d5e"},{"problem":132,"code":"(fn [pred v xs]\n  (if (seq xs)\n    (cons (first xs)\n      (mapcat (fn [[x y]] (if (pred x y) [v y] [y])) (partition 2 1 xs)))\n    ()))","user":"597dcb0ce4b0dbe32238d0a2"},{"problem":132,"code":"(fn r [f v [a & [b & xs :as bs] :as as]]\n  (if a\n    (if b\n      (concat [a] (when (f a b) [v]) (lazy-seq (r f v bs)))\n      [a])\n    []))","user":"53b15e6ee4b047364c04448f"},{"code":"(fn insert-between [p v coll]\n    (lazy-seq\n     (when-let [s (seq coll)]\n       (when-let [one (first s)]\n         (let [two (second s)]\n           (if (not two)\n             [one]\n             \n             (if (p one two)\n               (cons one\n                     (cons v\n                           (insert-between p v (rest s))))\n               (cons one\n                     (insert-between p v (rest s))))))))))","problem":132,"user":"4daea889edd6309eace4d15b"},{"problem":132,"code":"(fn [pred value coll]\r\n  (let [\r\n    process (fn process [[head & tail]]\r\n      (if (nil? head)\r\n        []\r\n        (cons head\r\n          (if (empty? tail)\r\n            []\r\n            (if (pred head (first tail))\r\n              (cons value (lazy-seq (process tail)))\r\n              (lazy-seq (process tail)))))))]\r\n    (process coll)))","user":"555bd27ae4b0b056612e2244"},{"problem":132,"code":"(fn [p v coll]\n  (when-not (empty? coll)\n    (cons (first coll)\n          (mapcat (fn [x y] (if (p x y) [v y] [y]))\n                  coll\n                  (rest coll)))))","user":"55c4e48be4b0e31453f649a7"},{"problem":132,"code":"(fn __\n  ([f v xs]\n   (if (empty? xs)\n     []\n     (let [[n & rs] xs]\n       (cons n (__ f v n rs)))))\n  ([f v p xs]\n   (if (empty? xs)\n     []\n     (let [[n & rs] xs]\n       (if (f p n)\n         (lazy-seq (lazy-cat [v n] (__ f v n rs)))\n         (lazy-seq (cons n (__ f v n rs))))))))","user":"55c4cda5e4b0e31453f649a5"},{"code":"(fn insert-between-two-items [p v c]\n  (lazy-seq\n   (cond (nil? (second c)) c\n         (p (first c) (second c))\n         ,,(concat (list (first c) v)\n                   (insert-between-two-items p v (next c)))\n        :t (cons (first c)\n                 (insert-between-two-items p v (next c))))))","problem":132,"user":"4dd0e8f7535da60f04a96e57"},{"problem":132,"code":"(fn __\n  [predicate item coll]\n  (if (empty? coll)\n    []\n\t\t  (let [[one two _] coll]\n\t      (lazy-cat\n\t        (if (and one two (predicate one two))\n\t          [one item]\n\t          [one])\n\t        (__ predicate item (rest coll))))))","user":"55a62092e4b0acc240e31554"},{"problem":132,"code":"(fn [p? v coll]\n  (if (empty? coll)\n    coll\n    (cons (first coll) \n          (mapcat rest\n                  (map (fn [[a b]] (if (p? a b)\n                                     [a v b]\n                                     [a b]))\n                       (partition 2 1 coll))))))","user":"5764457ae4b0994c1922fbf3"},{"problem":132,"code":"(fn me [pre my-value my-seq]\n\n\n    (let [\n            r-fn (fn r-fn [res elem]\n\n              (if (empty? res)\n                    (lazy-cat res (list elem))\n\n                  (if (pre (last res) elem)\n\n                    (lazy-cat res (list my-value elem))\n                    (lazy-cat res (list elem))\n                  )\n              )\n            )\n      ]\n\n      (reduce r-fn '() (take 14 my-seq))\n\n      )\n)","user":"55897fe2e4b059ccff29b205"},{"problem":132,"code":"(fn [comparator separator [f & r :as coll]]\n  (when f\n    (->> (cons f (interleave (map comparator coll r) r))\n         (map #(if (= 'true %) separator %))\n         (filter (comp not false?)))))","user":"5297dcc5e4b02ebb4ef75047"},{"problem":132,"code":"(fn ins [p v xs]\n     (let [f (first xs) s (second xs)]\n       (cond\n         (nil? f) []\n         (nil? s) [f]\n         (p f s) (cons f (cons v (lazy-seq (ins p v (rest xs)))))\n         :else (cons f (lazy-seq (ins p v (rest xs)))))))","user":"5d02fe44e4b0cc9c915881c0"},{"code":"(fn insert-between [p e s]\n   (if-not (or (empty? s) (empty? (rest s)))\n       (let [[e1 e2] (take 2 s)]\n         (concat\n          (if (p e1 e2)\n            [e1 e]\n            [e1])\n          (lazy-seq (insert-between p e (rest s)))))\n       s))","problem":132,"user":"529ce629e4b04e0c58e87b6e"},{"code":"(fn prob-0132\n  [pred inter xs]\n  (lazy-seq\n   (let [x1x2 (take 2 (seq xs))]\n     (cond\n      (empty? x1x2)      ()\n      (= 1 (count x1x2)) x1x2\n      :else              (let [x1 (first x1x2), x2 (second x1x2)]\n                           (if (pred x1 x2)\n                             (cons x1 (cons inter (prob-0132 pred inter (rest xs))))\n                             (cons x1             (prob-0132 pred inter (rest xs)))))))))","problem":132,"user":"4f047c07535dcb61093f6bcd"},{"code":"(fn [pred? label stream]\n  (if (seq stream)\n    (cons (first stream)\n          (mapcat (fn [[a b]] (if (pred? a b) [label b] [b]))\n                  (partition 2 1 stream)))))","problem":132,"user":"4fe84c74e4b07c9f6fd12c3c"},{"problem":132,"code":"(fn interpose-if [pred sep cll]\n  (cond (empty? cll)\n        nil\n        (empty? (rest cll))\n        cll\n        :else\n        (let [[c0 c1 & cs] cll]\n          (if (pred c0 c1)\n            (lazy-seq (list* c0 sep (interpose-if pred sep (cons c1 cs))))\n            (lazy-seq (list* c0 (interpose-if pred sep (cons c1 cs))))))))","user":"580bd81ee4b0849f6811b711"},{"code":"(fn i [p v c]\n  (lazy-seq\n   (when-let [s (seq c)]\n     (cons (first s)\n           (mapcat (fn [[e1 e2]]\n                     (if (p e1 e2)\n                       [v e2]\n                       [e2]))\n                   (partition 2 1 s))))))","problem":132,"user":"4ea1ecfa535d7eef308072bb"},{"problem":132,"code":"(fn insert-between [pred v coll]\n\t(letfn [(insert [[f s :as coll]]\n\t\t  (lazy-seq\n\t\t   (cond\n\t\t     (empty? coll) nil\n\t\t     (nil? s)      (cons f (insert nil))\n\t\t     (pred f s)    (cons f (cons v (insert (rest coll))))\n\t\t     :else         (cons f (insert (rest coll))))))]\n\t  (insert coll)))","user":"541b1f25e4b01498b1a71a63"},{"problem":132,"code":"(fn[pred val coll] \n( (fn process[final remaining]\n  \t(lazy-seq\n  \t\t(if (empty? remaining) nil\n    \t\t(if (or (empty? final) (not (pred (first final) (first remaining))))\n        \t\t(cons (first remaining) (process [(first remaining)] (rest remaining)))\n        \t\t(cons val (process [] remaining))\n         \t)\n     \t)\n   \t)\n   )\n   [] coll)\n)","user":"571172ece4b09c608db70446"},{"code":"(fn insert-between-two-items [pred item coll]\n  (lazy-seq\n    (if (next coll)\n      (concat (#(if (pred % %2) [% item] [%]) (first coll) (second coll)) (insert-between-two-items pred item (next coll)))\n      (if (empty? coll)\n        '()\n        [(first coll)]))))","problem":132,"user":"4f7e29dde4b06e829148e1ca"},{"code":"(fn [f x c]\n  (when (seq c)\n    (cons (first c) (mapcat \n      (fn [cur nxt] (if (f cur nxt) [x nxt] [nxt]))\n      c\n      (rest c)))))","problem":132,"user":"4ee7ef87535d93acb0a66872"},{"code":"(fn [p v x]\n    (mapcat #(let [a (first %)]\n               (if (= 2 (count %))\n                 (if (apply p %)\n                   [a v]\n                   [a])\n                 [a]))\n            (partition 2 1 [] x)))","problem":132,"user":"4f0664bd535dcb61093f6c0f"},{"code":"#((fn f [[h & [s & r :as a]]]\n   (if h\n\t   (cons h\n\t\t (if s (lazy-cat (if (% h s) [%2])\n\t\t\t\t (f a)))))) %3)","problem":132,"user":"4dada16fc9a9d6ed2699dc57"},{"code":"(fn MYFUNCT[f x a] \n  (if (empty? a) a \n(flatten (cons (first a) \n(map rest (map #(if (f (first %) (second %)) \n(list (first %) x (second %) ) (list (first %) (second %))) \n(map list a (rest a)) ))))))","problem":132,"user":"4fb3dd1ee4b081705acca2a5"},{"problem":132,"code":"(fn [f k xs] (mapcat (fn [a b] (if (and a (f a b)) [k b] [b])) (cons nil xs) xs))","user":"5d764e52e4b02e6b30c93524"},{"code":"(fn [p i s]\n  (if (seq s)\n    (cons (first s)\n          (mapcat (fn [[l r]] (if (p l r) [i r] [r]))\n                  (partition 2 1 s)))))","problem":132,"user":"4e52d815535d302ef430da77"},{"code":"(fn f [p v [a b & s :as c]]\n  (lazy-seq (if a\n              (concat [a]\n                      (if (and b (p a b)) [v])\n                      (f p v (rest c))))))","problem":132,"user":"4efb2fd7535dced4c769f274"},{"problem":132,"code":"(fn f [p v [x y & more :as coll]]\n  (if (nil? (next coll)) (if (empty? coll) [] [x])\n    (lazy-seq\n     (cons x\n           (if (p x y) \n             (cons v (f p v (rest coll)))\n             (f p v (rest coll)))))))","user":"56ae214ce4b03c432f18735a"},{"problem":132,"code":"(fn ins-betw\n  ([f sym ls]\n   (if (empty? ls)\n     '()\n     (ins-betw f sym (first ls) (rest ls))))\n  ([f sym x ls]\n   (if-let [y (first ls)]\n     (if (f x y)\n       (->> (rest ls)\n            (ins-betw f sym y)\n            (cons sym)\n            (cons x)\n            lazy-seq)\n       ; (lazy-seq (cons x (cons sym (ins-betw f sym y (rest ls)))))\n       (->> (rest ls)\n            (ins-betw f sym y)\n            (cons x)\n            lazy-seq))\n       ; (lazy-seq (cons x (ins-betw f sym y (rest ls)))))\n     (list x))))","user":"55f73078e4b06e875b46cea4"},{"code":"(fn wat [p v [x y & more]]\n  (lazy-seq\n    (when x\n      (cons\n        x\n        (when y\n          (if (p x y)\n            (cons v (wat p v (cons y more)))\n            (wat p v (cons y more))))))))","problem":132,"user":"4f03641a535dcb61093f6a9b"},{"problem":132,"code":"(fn [pred value coll]\n  (letfn [(insert [[a b]] (if (pred a b)\n                            [a value b]\n                            [a b]))]\n    (if-let [x (first coll)]\n      (cons (first coll)\n            (->> coll\n                 (partition 2 1)\n                 (mapcat (comp rest insert))))\n      [])))","user":"55f2e47de4b06e875b46ce4d"},{"code":"(fn tt\n  ([p marker values]\n    (if (empty? values) values\n      (tt p marker values nil)))\n  ([p marker values last-value]\n    (if (empty? values)\n      nil\n      (if (nil? last-value)\n        (lazy-seq (cons (first values) (tt p marker (rest values) (first values))))\n        (let [next-value (first values)]\n          (if (p last-value next-value)\n            (lazy-seq (cons marker (cons next-value (tt p marker (rest values) next-value))))\n            (lazy-seq (cons next-value (tt p marker (rest values) next-value)))))))))","problem":132,"user":"515737f0e4b0b0b4b87062d0"},{"problem":132,"code":"(fn [pred new-ele coll]\n   (if (empty? (nnext coll))\n     coll\n     (cons (first coll)\n           (mapcat #(if (pred %1 %2) [new-ele %2] [%2])\n                   coll\n                   (drop 1 coll)))\n     ))","user":"60096aabe4b074f607df667f"},{"problem":132,"code":"(fn insert [pred sym coll]\n  (lazy-seq (if (second coll)\n              (cons (first coll)\n                    (let [r (insert pred sym (rest coll))]\n                      (if (pred (first coll) (second coll)) (cons sym r) r)))\n              coll)))","user":"5b465b8be4b02d533a91bc65"},{"problem":132,"code":"(fn ins [f sep xs]\n  (cond\n    (empty? xs) []\n    (empty? (rest xs)) [(first xs)]\n    :else (let [a (first xs)\n                b (second xs)\n                v (if (f a b) [a sep] [a])]\n            (lazy-cat v (ins f sep (rest xs))))))","user":"5b64370ae4b0c6492753e73c"},{"problem":132,"code":"(fn [p v c]\n  (if (empty? c)\n    []\n    (let [[x & xs] c]\n      (conj\n       (mapcat #(if (p %1 %2)\n                  [v %2]\n                  [%2])\n               c\n               xs)\n       x))))","user":"53523ae0e4b084c2834f4aee"},{"problem":132,"code":"(fn between [p v col]\n                    (cond (empty? col) (list)\n                          (nil? (second col)) col\n                          :else (lazy-seq (concat\n                                            (if (p (first col) (second col)) [(first col) v] [(first col)])\n                                            (between p v (rest col))))))","user":"4e9ff8d0535d7eef3080729c"},{"problem":132,"code":"(fn [p marker xs]\n  (if (empty? xs) ()\n  (lazy-cat \n    (flatten \n      (map \n        (fn [x y] \n          (if (p x y) \n            [x marker] \n            x)) \n        xs \n        (rest xs))) \n    [(last xs)])))","user":"53c38b8ce4b00fb29b22127b"},{"problem":132,"code":"(fn __\n  [pred? value coll]\n  (lazy-seq\n    (when-let [s (seq coll)]\n      (let [x1 (first s)\n            x2 (second s)]\n        (cond\n          (nil? x2) (cons x1 nil)\n          (pred? x1 x2) (cons x1 (cons value (__ pred? value (rest s))))\n          :else\n          (cons x1 (__ pred? value (rest s))))))))","user":"55702081e4b09a3098a52529"},{"problem":132,"code":"(fn [p v c] \n  (let [c1 (drop-last c)\n        c2 (rest c)\n        fill (conj (map (fn [v1 v2] (if (p v1 v2) v nil)) c1 c2) nil)]\n    (remove nil? (interleave fill c)) ))","user":"550e52dbe4b06e50f9beb165"},{"problem":132,"code":"(fn ins\n  ([p? e s] (if (seq s)\n              (cons (first s) (ins p? e (first s) (rest s)))\n              s))\n  ([p? e prev s]\n   (if (seq s)\n     (lazy-seq\n      (if (p? prev (first s))\n        (cons e (cons (first s) (ins p? e (first s) (rest s))))\n        (cons (first s) (ins p? e (first s) (rest s)))))\n     s)))","user":"54ca93abe4b057c6fda3a264"},{"problem":132,"code":"(fn [pred val s]\n  (mapcat \n   #(if (and (= 2 (count %)) (apply pred %)) [(nth % 0) val] [(nth % 0)]) \n   (partition-all 2 1 s)))","user":"54febf4be4b07d26eda61d45"},{"problem":132,"code":"(fn btw [pred val coll]\n   (if (seq coll)\n     (let [[f s] coll]\n       (lazy-cat\n        (if (and f s (pred f s))\n          (vector f val)\n          (vector f))\n        (btw pred val (rest coll))))))","user":"535eaa73e4b04ce2eb3ed2d4"},{"code":"(fn ib2 [f v s]\n  (if (empty? s)\n    []\n    (if (first (map #(f (first %) (second %)) (partition 2 s)))\n      (cons (first s) (cons v (lazy-seq (ib2 f v (drop 1 s)))))\n      (cons (first s) (lazy-seq (ib2 f v (drop 1 s)))))))","problem":132,"user":"51c09719e4b0c9c82288293c"},{"problem":132,"code":"(fn insert-between\n  [pred v c]\n  (if (empty? c)\n    c\n    (cons (first c) (mapcat (fn [[e1 e2]] (if (pred e1 e2) [v e2] [e2])) (partition 2 1 c)))))","user":"57ea2c91e4b0bfb2137f5b42"},{"code":"(fn [p v c]\n  (if (empty? c)\n    []\n    (letfn [(ins [[f & r :as c]]\n              (if (empty? r)\n                [f]\n                (lazy-seq \n                 (if (p f (first r))\n                   (cons f (cons v (ins r)))\n                   (cons f (ins r))))))]\n      (ins c))))","problem":132,"user":"52dd4fb4e4b09f7907dd13df"},{"code":"(fn [o v [y & s]]\n  (if y\n      (cons y ((fn i [[x & r] l]\n        (if (nil? x)\n            []\n            (let [t (cons x (lazy-seq (i r x)))]\n              (if (o l x) (cons v t) t)))) s y))\n      nil))","problem":132,"user":"50acbd15e4b071b89ef26234"},{"code":"(fn i-between [f i coll]\n  (if (next coll)\n    (->> (partition 2 1 coll)\n         (mapcat #(rest (if (f (first %) (second %))\n                          (interpose i %)\n                          %)))\n         (cons (first coll)))\n    coll))","problem":132,"user":"511e763ce4b03e81d390ac29"},{"code":"(fn f [p e [x1 x2 &xs :as c]]\n  (if x2 (lazy-seq\n          (if (p x1 x2) (cons x1 (cons e (f p e (rest c))))\n            (cons x1 (f p e (rest c))))) (if x1 (list x1))))","problem":132,"user":"52479487e4b05ef8e38e6373"},{"code":"(fn [pred val coll]\n   (if (empty? coll)\n     coll\n     (-> #(if (pred % %2) [val %2] [%2]) \n         (map coll (next coll))\n         flatten\n         (conj (first coll)))))","problem":132,"user":"4e9fd521535d7eef3080729a"},{"problem":132,"code":"(fn insert-between [p i [f s & r]]\n  (cond\n    (nil? f) []\n    (nil? s) [f]\n    (p f s) (lazy-seq (concat [f i] (insert-between p i (cons s r))))\n    :else (lazy-seq (cons f (insert-between p i (cons s r))))))","user":"5b15811ee4b0cc2b61a3be6f"},{"problem":132,"code":"(fn f [p v [x y :as c]]\n  (lazy-seq\n   (if (and x y)\n     (concat (if (p x y) [x v] [x]) (f p v (rest c)))\n     c)))","user":"559b2ad1e4b066d22e731f4e"},{"code":"(fn [p? fill l]\n  (mapcat\n    (fn [[a b]]\n      (cond\n        (nil? b) (list a)\n        (p? a b) (list a fill)\n        :else (list a)))\n    (partition-all 2 1 l)))","problem":132,"user":"4fc0853ae4b081705acca327"},{"code":"(fn insert-between-two-items\n  [p value coll]\n  (if (not (empty? coll))\n    (let [[h & t] coll]\n      (if (empty? t)\n        [h]\n        (if (p h (first t))\n          (lazy-cat [h value]\n                    (insert-between-two-items p value t))\n          (cons h (lazy-seq\n                    (insert-between-two-items p value t))))))\n    []))","problem":132,"user":"531c0619e4b08068f379ed98"},{"code":"#(flatten (map (fn [[a b]] (if (and b (% a b)) [a %2] a)) (partition-all 2 1 %3)))","problem":132,"user":"4f9fe2b9e4b0dcca54ed6d40"},{"code":"#(mapcat (fn [[a b]] (cons a (if (and b (% a b)) [%2])))\n         (partition 2 1 [nil] %3))","problem":132,"user":"4e71705e535d5021c1a89649"},{"problem":132,"code":"; This is very insightful. Still not there...but when I see it, it makes sense. More practice!\n\n(fn [c v s]\n  (mapcat (fn [[a b]] (if (and a b (c a b)) (list a v) (list a)))\n          (partition-all 2 1 s)))","user":"5633bb9de4b0bfe05bf117b4"},{"problem":132,"code":"(fn _ [p v coll]\n  (when (seq coll)\n    (let [[x y] (take 2 coll)]\n      (if (nil? y)\n        [x]\n        (lazy-seq\n          (concat\n            (if (p x y) [x v] [x])\n            (_ p v (rest coll))))))))","user":"5213d7aae4b0961f15ac4d72"},{"code":"(fn insert [p v [x & xs :as coll]]\n  (when (not-empty coll)\n    (cond \n      (empty? xs) [x]\n      (p x (first xs)) (cons x (cons v (lazy-seq (insert p v xs))))\n      :else (cons x (lazy-seq (insert p v xs))))))","problem":132,"user":"51cdd3f0e4b0e42293a2254b"},{"code":"(fn f [pred word coll]\n  (if (empty? coll) '()\n    (lazy-cat \n      (list (first coll))\n      (apply concat (for [[x y] (map vector coll (rest coll))]\n                         (if (pred x y) [word y] [y] ))))))","problem":132,"user":"4e14108c535d04ed9115e7dd"},{"problem":132,"code":"(fn insert-between [pred v coll]\n  (if (or (empty? coll) (= 1 (count (take 2 coll))))\n    coll\n    (if (pred (first coll) (second coll))\n      (cons (first coll) (cons v (lazy-seq (insert-between pred v (rest coll)))))\n      (cons (first coll) (lazy-seq (insert-between pred v (rest coll))))\n    )))","user":"53e76bb2e4b036ad0777e47d"},{"problem":132,"code":"(fn [p x vs]\n            (if-not (seq vs)\n              vs\n              (->> vs\n                   (partition-all 2 1)\n                   (mapcat (fn [[a b :as entry]]\n                             (if (= 1 (count entry))\n                               [a]\n                               (if (p a b)\n                                 [a x]\n                                 [a])))))))","user":"53684a2fe4b0243289761e8c"},{"code":"(fn [p v c]\n  (if (empty? c) c\n      (cons (first c)\n            (flatten (map #(if (p % %2) (list v %2) %2) c (rest  c))))))","problem":132,"user":"4f2d5f5de4b0d6649770a05a"},{"code":"(fn f [p n c]\n  (let [e1 (first c) e2 (second c)]\n    (if (and e1 e2)\n      (if (p e1 e2)\n        (cons e1 (cons n (lazy-seq (f p n (rest c)))))\n        (cons e1 (lazy-seq (f p n (rest c)))))\n      c)))","problem":132,"user":"514721c6e4b0d520409ed392"},{"problem":132,"code":"(fn ib [pred val coll]\n  (let [f (first coll)\n        s (second coll)]\n    (cond (and f s)\n          (if (pred f s)\n            (concat [f val] (lazy-seq (ib pred val (rest coll))))\n            (concat [f] (lazy-seq (ib pred val (rest coll)))))\n          f [f]\n          :else nil)))","user":"51852961e4b0da5a5be3babb"},{"problem":132,"code":"(fn inser [f sym xs]\n      (letfn  [(fr  [g sm t ys]  (lazy-seq\n           (if  (first ys)  (let  [y1  (first ys) ry  (rest ys)]\n                 (if  (g t y1)\n                     (cons t  (cons sm  (fr g sm y1 ry)))\n                     (cons t  (fr g sm y1 ry) )))\n                 [t] )))]\n                (if  (first xs)\n                       (fr f sym  (first xs)  (rest xs))\n                      ())))","user":"59ff9424e4b01bb0ae8afd24"},{"problem":132,"code":"(fn [p v c] \n  (reduce \n    #(if \n       (if (empty? %1) \n         false \n         (p (last %1) %2)) \n       (conj %1 v %2)\n       (conj %1 %2)) \n    [] (take 10 c)))","user":"5fab7ea6e4b08cb800c85ad8"},{"code":"(fn [p v xs]\n  (mapcat\n    #(if (p %1 %2) [%1 v] [%1])\n    xs\n    (lazy-cat (rest xs) (take 1 xs))\n  )\n)","problem":132,"user":"507eddf4e4b06ce648bcdbfa"},{"problem":132,"code":"(fn ins [p v [x & xs]]\n  (when x\n    (let [y (first xs)]\n      (lazy-cat [x] \n                (when (and y (p x y)) [v]) \n                (ins p v xs)))))","user":"57f0f7b8e4b0bfb2137f5bfe"},{"problem":132,"code":"(fn ins [pred x coll]\n  (lazy-seq\n  (if (empty? (rest coll))\n    coll\n    (if (pred (first coll)\n              (second coll))\n      (conj (ins pred x (rest coll))\n            x\n            (first coll))\n      (cons (first coll) (ins pred x (rest coll)))))))","user":"55c68089e4b0e31453f649c4"},{"problem":132,"code":"(fn [p v s]\n    (if (-> s seq not)\n      '()\n      (\n       (fn rec [v1 c]\n         (if (not (seq c))\n           (list v1)\n           (let [v2 (first c)]\n             (if (p v1 v2)\n               (cons v1 (cons v (rec v2 (rest c))))\n               (cons v1 (rec v2 (rest c))))\n             )\n           )\n         ) (first s) (rest (take 20 s)))\n      )\n    )","user":"559a9a3de4b066d22e731f45"},{"code":"(fn insert-at [pred item coll]\n  (if (or (empty? coll) (empty? (rest coll)))\n    coll\n    (let [\n          x (first coll)\n          res (->>\n               (cons x coll)\n               (partition 2 1)\n               (mapcat (fn [[a b]] (if (pred a b) [item b] [b]))))]\n      (if (pred x x) (rest res) res))))","problem":132,"user":"4ddb696b535d02782fcbe9fa"},{"problem":132,"code":"(fn [pred v xs]\n  (if (empty? xs)\n    ()\n    (cons (first xs) (mapcat #(if (pred %1 %2) [v %2] [%2]) xs (next xs)))))","user":"554b8572e4b0a04f79299589"},{"code":"(fn __ [f v s]\n    (lazy-seq\n      (cond\n        (not (seq s))\n        nil\n\n        (not (seq (rest s)))\n        (cons (first s) (__ f v (rest s)))\n\n        (f (first s) (second s))\n        (cons (first s) (cons v (__ f v (rest s))))\n\n        :else\n        (cons (first s) (__ f v (rest s))))))","problem":132,"user":"521b9f92e4b0c4ef0be8304c"},{"code":"(fn interleave-if\n  [pred sep coll]\n  (let [res (concat (map pred coll (rest coll)) [false])]\n      (mapcat #(if %2 [%1 sep] [%1]) coll res)))","problem":132,"user":"4dad7adac9a9d6ed0599dc57"},{"code":"(fn [p v c]\n  ((fn f [[x & xs] y b]\n     (cond (nil? x) '()\n           (and b (p y x))\n             (cons v (cons x (lazy-seq (f xs x true))))\n           :else (cons x (lazy-seq (f xs x true)))))\n     c nil false))","problem":132,"user":"504e04a4e4b078edc5f59397"},{"problem":132,"code":"(fn [f x s]\n  (if (empty? s) \n    ()\n    (cons \n      (first s)\n      (mapcat\n        (fn [[a b]]\n          (if (f a b)\n            [x b]\n            [b]))\n        (partition 2 1 s)))\n      )\n  )","user":"5ade6bafe4b0837691e92c23"},{"problem":132,"code":"(fn solve [p v coll]\n  (if (empty? coll)\n    []\n    (->> (interleave coll (rest coll))\n         (partition 2)\n         (mapcat (fn [[x y]] (if (p x y) [v y] [y])))\n         (cons (first coll)))))","user":"56444fb1e4b0018b46ad8c0c"},{"problem":132,"code":"(let [insert-between* (fn ins-bet [ret prev-elem pred item inputs]\n                        (let [head (first inputs)\n                              tail (rest inputs)]\n                          (cond (nil? head)\n                                ret\n                                (and (not (nil? prev-elem)) (pred prev-elem head))\n                                (lazy-seq (cons item (cons head (ins-bet ret head pred item tail))) )\n                                :else\n                                (lazy-seq (cons head (ins-bet ret head pred item tail))))\n                          )\n                        )\n      insert-between (fn [pred item inputs] (insert-between* (lazy-seq) nil pred item inputs))] insert-between)","user":"5f763c78e4b02876ed9fd0b0"},{"problem":132,"code":"(fn ins [pred v [x & rest]]\n (lazy-seq (let [y (first rest)]\n     (cond\n      (nil? x) []\n      (nil? rest) [x]\n      (pred x y) (list* x v (ins pred v rest))\n      :else (cons x (ins pred v rest))))))","user":"5405ae2be4b0addc1aec6671"},{"code":"(fn [p v s]\n  ((fn insert-between-two-items [p v s1 s2]\n     (lazy-seq\n      (let [a (seq s1) b (seq s2)]\n        (if (and a b)\n          (cons (first a)\n                (if (p (first a) (first b))\n                  (cons v (insert-between-two-items p v (rest a) (rest b)))\n                  (insert-between-two-items p v (rest a) (rest b))))\n          a)))) p v s (rest s)))","problem":132,"user":"50705072e4b07bd6ad9b9f27"},{"problem":132,"code":"(fn intlv [f v coll]\n  (when-not (empty? coll)\n    (let [[a b ] coll]\n      (if (or (nil? a) (nil? b))\n        coll\n        (if (f a b)\n          (cons a (cons v (lazy-seq (intlv f v (drop 1 coll)))))\n          (cons a (lazy-seq (intlv f v (drop 1 coll))))\n          )\n        )\n      )))","user":"564a560ae4b0284900eef654"},{"code":"(fn [p v s]\n  (mapcat (fn [[a b]] (if (= b :eos) [a] (if (p a b) [a v] [a])))\n          (partition 2 1 (concat s [:eos]))))","problem":132,"user":"4ff9d4e5e4b0678c553fc3b0"},{"problem":132,"code":"(fn ibti [op v coll]\n  (if-let [nc (next coll)]\n    (let [a (first coll) b (second coll)]\n      (lazy-seq\n       (cons\n        a\n        (if (op a b) (cons v (ibti op v nc)) (ibti op v nc))\n        ))\n      )\n    coll\n    )\n  )","user":"5cebafbbe4b0a17bb84e2be6"},{"problem":132,"code":"(fn interpose-predicated [pred in coll]\n  (if (next coll)\n    (->> coll\n         (partition 2 1)\n         (mapcat (fn [[a b]] (if (pred a b) [in b] [b])))\n         (cons (first coll)))\n    coll))","user":"527ba695e4b03e8d9a4a7596"},{"problem":132,"code":"(fn [p v xs]\n   (mapcat\n    #(if (p %1 %2) [%1 v] [%1])\n    xs\n    (lazy-cat (rest xs) (take 1 xs))))","user":"53a1b5c8e4b0ca733b9744c1"},{"problem":132,"code":"(fn q4q132\n  [p v s]\n  (if (empty? s)\n    nil\n    (lazy-seq\n     (cons\n      (first s)\n      (if (and\n           (not (empty? (rest s)))\n           (p (first s) (second s)))\n        (cons v\n              (q4q132 p v (rest s)))\n        (q4q132 p v (rest s)))))))","user":"52213426e4b0e6a83c8925c4"},{"code":"(fn [pred item seq]\n  (mapcat (fn [vals]\n            (cond (nil? (next vals)) vals\n                  (apply pred vals) [(first vals) item]\n                  :else [(first vals)]))\n          (partition-all 2 1 seq)))","problem":132,"user":"4e7c8fd1535db169f9c796be"},{"code":"(fn [pred token coll]\n  (if (seq coll)\n    (cons (first coll) (apply concat (for [[a b] (partition 2 1 coll)] (if (pred a b) [token b] [b]))))\n    coll))","problem":132,"user":"532347dde4b09d4e7a9b54cc"},{"code":"(fn [p a seq]\n    (letfn [(insert-by [[x y & xs :as tail]]\n        (cond (empty? tail) []\n              (= 1 (count (take 2 tail))) [x]\n              :else\n                (if (p x y)\n                    (lazy-seq (cons x (cons a (insert-by (rest tail)))))\n                    (lazy-seq (cons x (insert-by (rest tail)))))))]\n    (insert-by seq)))","problem":132,"user":"4f4ac35ae4b0d56e7bb92c18"},{"problem":132,"code":"(fn insrt [f value a-seq]\n  (if (or (empty? a-seq) (empty? (rest a-seq)))\n    a-seq\n    (lazy-seq\n      (if (f (first a-seq) (second a-seq))\n       (cons (first a-seq) (cons value (insrt f value (rest a-seq))))\n       (cons (first a-seq) (insrt f value (rest a-seq)))))))","user":"56cb4d06e4b0ea9b8538f72e"},{"problem":132,"code":"(fn [pred value coll]\n  ((fn lazy [[f & r]]\n     (if f\n       (lazy-seq (cons f\n                       (if (and (first r) (pred f (first r)))\n                         (cons value (lazy r))\n                         (lazy r))))))\n   coll))","user":"57035ccfe4b08d47c97781ef"},{"problem":132,"code":"(fn f ([g x c] (if (empty? c) c (cons (first c) (f (first c) (rest c) g x)))) \n  ([y d g x] (if (empty? d) [] (lazy-seq (concat (if (g y (first d))  [x (first d)] [(first d)]) (f (first d) (rest d) g x))))))","user":"5c41db45e4b08cd430848ece"},{"code":"(fn insert-between\n  [pred x coll]\n  (mapcat (fn [partition]\n            (if (= 1 (count partition))\n              partition\n              (butlast partition)))\n          (map (fn [partition]\n                 (if (and (< 1 (count partition))\n                          (apply pred partition))\n                   (interpose x partition)\n                   partition))\n               (partition-all 2 1 coll))))","problem":132,"user":"4dc0ff08535d020aff1edf84"},{"code":"(fn insert-two [p v seq]\n  (when-let [x (first seq)]\n    (if (empty? (rest seq))\n      (list x)\n      (let [y (first (rest seq))]\n        (lazy-seq (if (p x y)\n                    (cons x (cons v (insert-two p v (rest seq))))\n                    (cons x (insert-two p v (rest seq)))))))))","problem":132,"user":"4ed94d69535d10e5ff6f5303"},{"code":"(fn [p v xs]\n  (concat (take 1 xs)\n          (mapcat (fn [[x y]] (concat (if (p x y) [v] nil) [y]))\n                  (partition 2 1 xs))))","problem":132,"user":"510acd6ee4b078ea719210f4"},{"problem":132,"code":"(fn f [p s [x & xs]]\n  (lazy-seq\n   (when x\n     (if (and (first xs) (p x (first xs))) \n       (cons x (cons s (f p s xs)))\n       (cons x (f p s xs))))))","user":"5eee7311e4b07c55ae4a0510"},{"problem":132,"code":"(fn insert-at \n  [pred value coll]\n  (if (not (nil? (first coll)))\n    (cons \n      (first coll)\n      (mapcat \n        (fn [[a b]] \n          (if (pred a b) \n            [value b]\n            [b]))\n        (partition 2 1 coll)))\n    '()\n    ))","user":"5564709ee4b0c656e3ff1807"},{"code":"(fn [p v coll]\n  (if (empty? coll)\n    ()\n  (cons (first coll)\n        (mapcat\n         (fn [[x y]]\n           (if (p x y)\n             [v y]\n             [y]))\n         (partition 2 1 coll)))))","problem":132,"user":"4ffc10aae4b0678c553fc3d6"},{"problem":132,"code":"(fn p132 [f v c]\n  (if (empty? c) '()\n    (let [vals-to-use (partition 2 1 c)]\n      (flatten \n        (cons (first c)\n          (for [val1 vals-to-use]\n            (if (f (first val1) (last val1))\n              [v (last val1)]\n              [(last val1)])))))))","user":"525c575be4b0cb4875a45d38"},{"code":"(fn [f sym s]\n  (letfn [(op [l s]\n    (cond (empty? s) '()\n          (or (nil? l) (not (f l (first s))))\n            (cons (first s) (lazy-seq (op (first s) (rest s))))\n          true\n            (cons sym\n              (cons (first s) (lazy-seq\n                (op (first s) (rest s)))))))]\n    (op nil s)))","problem":132,"user":"4ebc08a8535dfed6da9c6d7c"},{"code":"(fn insert-beetwen [p v coll]\n  (lazy-seq\n    (when-let [s (seq coll)]\n      (if (and (second s) (p (first s) (second s)))\n        (cons (first s) (cons v (insert-beetwen p v (next s))))\n        (cons (first s) (insert-beetwen p v (next s)))))))","problem":132,"user":"52d809bde4b09f7907dd1384"},{"code":"(fn [f sep coll] (concat (if (empty? coll) [] [(first coll)])\r\n  (mapcat #(if (apply f %) [sep (second %)] [(second %)])\r\n          (partition 2 1 coll))))","problem":132,"user":"503354c3e4b0c6c1199c710c"},{"problem":132,"code":"(fn [pred? v coll] \n  (if (empty? coll) '()\n  (concat\n   (list (first coll))\n    (mapcat \n      #(rest (if (apply pred? %) (interpose v %) %)) \n      (partition 2 1 coll))\n  )))","user":"60264d89e4b0d5df2af2222d"},{"problem":132,"code":"(fn [p v coll]\n  (letfn [(another [c]\n            (lazy-seq\n             (when-not (empty? c)\n               (let [[prev cur] (first c)]\n                 (if cur\n                   (if (p prev cur)\n                     (cons prev (cons v (another (rest c))))\n                     (cons prev (another (rest c))))\n                   (cons prev nil))))))]\n    (another (partition-all 2 1 coll))))","user":"606a70a5e4b069485764ddf2"},{"code":"(fn p [f x xs]\n  (let [ [a & b] xs ]\n\t\t(if (seq b)\n      (lazy-seq\n          (if (f a (first b))\n            (cons a (cons x (p f x b)))\n            (cons a (p f x b))))\n          xs)))","problem":132,"user":"4fdd27f3e4b05e33b9224f78"},{"problem":132,"code":";; http://www.4clojure.com/problem/132\n(fn insert-between-fn\n  [test-fn token coll]\n  (mapcat #(if (= (count %) 1)\n             (list (first %)) \n             (if (test-fn (first %) (second %)) (list (first %) token) (list (first %))))\n       (partition-all 2 1 coll)))","user":"5c92105ce4b048ec896c59f7"},{"problem":132,"code":"(fn [pred v xs]\n   (if (empty? xs) []\n       (lazy-cat [(first xs)]\n                 (mapcat #(if (pred %1 %2) [v %2] [%2]) xs (rest xs)))))","user":"5afb4b15e4b0cc2b61a3bcf6"},{"problem":132,"code":"(fn [f v xs] \n  (if (seq xs)\n  (cons (first xs) (mapcat (fn [[a b]] (if (f a b) [v b] [b])) (partition 2 1 xs)))\n   [] \n   ))","user":"51aab611e4b04e3dc0c27b2d"},{"problem":132,"code":"(fn p [pred i s]\n  (->> (partition-all 2 1 s)\n       (map (fn\n              [[x y]]\n               (cond\n                (nil? y) [x]\n                (pred x y) [x i]\n                :else [x])))\n       (flatten)))","user":"57644395e4b0994c1922fbf2"},{"code":"(fn [p v s] (mapcat #(apply (fn ([x y] (if (p x y) [x v] [x])) ([x] [x])) %) (partition-all 2 1 s)))","problem":132,"user":"4f569a3ce4b0a7574ea71828"},{"code":"(fn ins [pred e coll]\n  (when-let [c (seq coll)]\n    (cons (first c)\n          (mapcat #(let [[x y] %]\n                        (if (pred x y) [e y] [y]))\n                  (partition 2 1 c)))))","problem":132,"user":"500900dee4b0144d4f561e42"},{"code":"(fn f [p w [l & c]]\n   (lazy-seq\n    (cond\n     (nil? l) ()\n     (empty? c) `(~l)\n     :else (concat (if (p l (first c)) [l w] [l]) (f p w c)))))","problem":132,"user":"52c25645e4b07a9af579237d"},{"code":"(fn fun [pred v coll]\n\t(if (empty? coll) \n\t\t()\n\t\t(if-not (next coll)\n\t\t\tcoll\n\t\t\t(if (pred (first coll) (second coll))\n\t\t\t\t(cons (first coll) \n\t\t\t\t\t(lazy-seq (cons v (fun pred v (rest coll)))))\n\t\t\t\t(cons (first coll) \n\t\t\t\t\t(lazy-seq (fun pred v (rest coll))))))))","problem":132,"user":"520242bae4b030ee0c5b26e3"},{"problem":132,"code":"(fn interpose-by [f w [h & t :as xs]]\n (when (not-empty xs)\n  (cons h (mapcat #(if (f %1 %2) [w %2] [%2]) xs t))))\n  \n#_\n(fn interpose-by [f w [x1 x2 & h]] \n (cond\n  (nil? x1) nil \n  (nil? x2) (list x1)\n  (f x1 x2) (cons x1 (cons w (lazy-seq (interpose-by f w (cons x2 h)))))\n  :e (cons x1 (lazy-seq (interpose-by f w (cons x2 h))))))","user":"5bea3177e4b0f319e2d7ec81"},{"problem":132,"code":"(fn f [p v [h & t]] (cond\n                          (nil? h) []\n                          (empty? t) [h]\n                          (p h (first t)) (cons h (cons v (lazy-seq (f p v t))))\n                          :else (cons h (lazy-seq (f p v t)))))","user":"51e28063e4b08e53a149f0f2"},{"problem":132,"code":"(fn solve [pred v coll]\n  (mapcat (fn [[a b]]\n            (if (and a b (pred a b))\n              [a v]\n              [a]))\n          (partition-all 2 1 coll)))","user":"60537cd1e4b04c8f2157d152"},{"code":"(fn b [f e [a & c :as d]]\n        (if (nil? c)\n          d\n          (lazy-cat (if (f a (first c)) [a e] [a])\n                    (b f e c))))","problem":132,"user":"4f031eac535dcb61093f6a67"},{"problem":132,"code":"(fn ins [f v ls] \n  (if (nil? (next ls)) \n    ls \n    (if \n      (f (first ls) (second ls)) \n      (cons (first ls) (cons v (lazy-seq (ins f v (next ls))))) \n      (cons (first ls) (lazy-seq (ins f v (next ls)))))))","user":"541ef7e2e4b01498b1a71a92"},{"code":"(fn [f ob s]\n\t(let [ins? (conj (map (partial apply f) (partition 2 1 s)) false)]\n\t   (mapcat (fn [[x b]] (if b (list ob x) (list x))) (map vector s ins?))))","problem":132,"user":"5142ea50e4b0c172af7558ca"},{"code":"(fn [f d s]\n  (when-first [t s]\n    (concat [t]\n  (mapcat #(if (f % %2) [d %2] [%2]) s (drop 1 s)))))","problem":132,"user":"50ad7888e4b0a40c9cfb08c7"},{"problem":132,"code":"(fn [pred sep xs] (when (seq xs) (cons (first xs) (mapcat (fn [[a b]] (if (pred a b) (list sep b) (list b))) (partition 2 1 xs)))))","user":"4e68c434535d8ccf87e9fe89"},{"problem":132,"code":"(fn f \n  ([p v s] (if (empty? s) [] (f p v (rest s) [(first s)])))\n  ([p v s r] (if (or (empty? s) (> (count r) 20)) r (recur p v (rest s) (conj (if (p (last r) (first s)) (conj r v) r) (first s))))))","user":"5a3c2a08e4b001c08efc0cdf"},{"problem":132,"code":"(fn p-132 [pred2 val coll]\n  (->> coll\n       (partition-all 2 1)\n       (map (fn [[x y]]\n              (if (and y (pred2 x y)) val nil)))\n       (interleave coll)\n       (remove nil?)))","user":"501d34f6e4b066e56b9d0b1e"},{"problem":132,"code":"(fn [f tok coll]\n  (letfn [(gen [[x & xs] prev]\n            (if x\n              (if (and prev (f prev x))\n                (lazy-seq (cons tok (cons x (gen xs x))))\n                (lazy-seq (cons x (gen xs x))))\n              nil))]\n    (gen coll nil)))","user":"5eb1c786e4b00a66d4a95201"},{"problem":132,"code":"(fn [p v [x & _ :as xs]]\n  (if (seq xs)\n    (cons x (mapcat (fn [[a b]] (if (p a b) [v b] [b])) (partition 2 1 xs)))))","user":"560a7b46e4b05f002753defb"},{"code":"(fn [p v xs]\n  (->>\n   xs\n   (partition-all 2 1)\n   (mapcat (fn [[a b :as c]] (if (or \n                                  (= (count c) 1)\n                                  (not (p a b)))\n                               [a] \n                               [a v])))))","problem":132,"user":"51efd397e4b0249c592fbdeb"},{"code":"(fn [p v xs]\n  (letfn [(f [xs]\n           (lazy-seq\n             (let [xs (seq xs), a (first xs), more (next xs), b (first more)]\n               (cond\n                 (and more (p a b))\n                   (cons a (cons v (f more)))\n                 more\n                   (cons a (f more))\n                 xs\n                   (cons a nil)))))]\n    (f xs)))","problem":132,"user":"50fbf811e4b0d10d794c19f1"},{"code":"(fn [p pw v]\n  (concat (take 1 v) \n    (mapcat \n      (fn [[a b]] (if (p a b) [pw b] [b])) \n      (partition 2 1 v))))","problem":132,"user":"528652fbe4b0239c8a67ae14"},{"problem":132,"code":"(fn ins [pred v s]\n  (if-not (seq s) ()\n    (let [[x & xs] s]\n      (cons x\n        (lazy-seq\n          (if (seq xs)\n            (if (pred x (first xs))\n              (cons v (ins pred v xs))\n              (ins pred v xs))))))))","user":"53d78b64e4b0e771c3025466"},{"code":"(fn [q v c]\n  (mapcat\n    #(cons (first %)\n      (when (and (second %) (apply q %))\n        [v]))\n    (partition-all 2 1 c)))","problem":132,"user":"4ec2fe3f535dcc7ae8597d4f"},{"problem":132,"code":"(fn insert-between-two-items [pred marker col]\n  (if (empty? col)\n    []\n    (lazy-cat\n      [(first col)]\n      (flatten\n        (map\n          (fn [pair]\n            (lazy-cat\n              (if (pred (first pair) (last pair))\n                [marker]\n                [])\n              [(last pair)]))\n          (partition 2 1 col))))))","user":"528bba38e4b0239c8a67aea9"},{"problem":132,"code":"(fn fff [p v s]\n  (if (empty? s)\n    []\n    (flatten\n      (concat [(first s)]\n              (map (fn [sss] \n                     (if (apply p sss)\n                      (vector v (second sss))\n                      (second sss)))\n                   (partition 2 1 s))))))","user":"57487084e4b009280f9f2b8c"},{"code":"(fn bw [pred v [x y & xs :as all]]\n  (cond\n   (empty? all) []\n   (nil? y) [x]\n   (pred x y) (concat [x v] (lazy-seq (bw pred v (next all))))\n   :else (cons x (lazy-seq (bw pred v (next all))))))","problem":132,"user":"511aa2a4e4b0c87c59c9670a"},{"problem":132,"code":"(fn x [p v [a & [b :as s]]] (if (empty? s) (if a (list a) ()) (lazy-cat [a] (if (p a b) [v] []) (x p v s))))","user":"53e19461e4b0d874e779ae59"},{"code":"(fn [pred val coll]\n  (mapcat (fn [[x y :as xy]]\n            (if (and (> (count xy) 1) (pred x y)) [x val] [x]))\n          (partition-all 2 1 coll)))","problem":132,"user":"5095f761e4b0ba05ca7aebfd"},{"problem":132,"code":"(fn f [p v s]\n  (lazy-seq\n   (cond\n     (< (count (take 2 s)) 2) s\n     (apply p (take 2 s)) (cons (first s) (cons v (f p v (rest s))))\n     :else (cons (first s) (f p v (rest s)))\n     )))","user":"583048d9e4b051871117c007"},{"code":"(fn inserter [pred? v coll]\n  (cond\n   (empty? coll) nil\n   (empty? (rest coll)) coll\n   :else\n   (lazy-seq\n    (cons (first coll)\n          (if (pred? (first coll) (second coll))\n            (cons v (inserter pred? v (rest coll)))\n            (inserter pred? v (rest coll)))))\n   )\n  )","problem":132,"user":"4f4e91a9e4b03ad3f0c10cca"},{"problem":132,"code":"(fn [x y z] (reduce #(if (empty? %) [%2] (if (x (last %) %2) (concat % [y %2]) (concat % [%2]))) [] (take 20 z)))","user":"53fc8424e4b0de5c418485b3"},{"problem":132,"code":"(fn __ [p v l]\n  (if (empty? l) (empty l)\n    (let [f (first l) r (rest l)]\n      (lazy-cat [f]\n            (cond (empty? r) '()\n                  (p f (first r)) (lazy-cat [v] (__ p v r))\n                  :else (__ p v r))))))","user":"54c271b9e4b045293a27f602"},{"problem":132,"code":"(fn [p v c]\n    (let [pairs (partition 2 (drop 1 (interleave c c))) ]\n      (letfn [ (nxt [ps]\n                    (if (empty? ps)\n                      (if (empty? c)\n                        c\n                        (cons (last c) nil) )\n                      (let [head (first ps)\n                            tail (rest ps) ]\n                        (if (p (first head) (second head))\n                          (cons (first head) (cons v (lazy-seq (nxt tail))))\n                          (cons (first head) (lazy-seq (nxt tail))) ))))\n               ]\n        (lazy-seq (nxt pairs)) ))\n  )","user":"53c1ce3ee4b00fb29b221268"},{"code":"(fn f [pred inst lst]\n  (lazy-seq\n  (if (next lst)\n    (if (pred (first lst) (second lst))\n      (concat [(first lst) inst] (f pred inst (rest lst)))\n      (cons (first lst) (f pred inst (rest lst))))\n    lst)))","problem":132,"user":"50b1d166e4b03ea880433554"},{"problem":132,"code":"(fn insert-between [pred val [fst & rest]]\n  (lazy-seq\n    (if-not rest\n      (if fst [fst] nil)\n      (if (pred fst (first rest))\n        (list* fst val (insert-between pred val rest))\n        (list* fst (insert-between pred val rest))))))","user":"5b13ba71e4b0cc2b61a3be53"},{"code":"(fn insert-between\n    ([pred val coll]\n       (if (seq coll)\n         (cons (first coll) (insert-between pred val (rest coll) (first coll)))\n         '()))\n    ([pred val coll prev-val]\n       (when (seq coll)\n         (if (pred prev-val (first coll))\n           (lazy-seq (cons val (cons (first coll) (insert-between pred val (rest coll) (first coll)))))\n           (lazy-seq (cons (first coll) (insert-between pred val (rest coll) (first coll))))))))","problem":132,"user":"4e89ff3d535d3e98b802328a"},{"problem":132,"code":"(fn interweave [pred v coll]\n  (lazy-seq\n  (let [[a & rst] coll\n        [b]       rst]\n    (if (seq rst)\n      (if (pred a b)\n        (cons a (cons v (interweave pred v rst)))\n        (cons a (interweave pred v rst)))\n      coll))))","user":"56481722e4b0284900eef628"},{"problem":132,"code":"(fn between [f s [fx fs & fr :as xs]] (when fx\n                                            (if fs\n                                              (let [a (if (f fx fs) (list fx s) (list fx))]\n                                                (lazy-cat a (between f s (rest xs))))\n                                              (list fx))))","user":"5b924123e4b0c0b3ffbd4a34"},{"problem":132,"code":"(fn [f flag s]    \n  (letfn [(mp [a b]\n          \t  (if (f a b) [a flag] [a]) )]\n  (mapcat mp s \n          (lazy-cat (rest s) (take 1 s)))\n))","user":"5654d0e1e4b0f9d632dd848c"},{"problem":132,"code":"(fn [p v c]\n  (let [f (fn [[a b]] (cond (p a b) v :else nil))\n        vs (map f (partition 2 1 c))]\n    (keep identity (interleave c (concat vs [nil])))))","user":"56ef077ae4b04a395b9a0459"},{"code":"(fn f [p s v]\n  (lazy-seq\n    (when (seq v)\n      (if (= nil (second v))\n        v\n        (if (p (first v) (second v))\n            (concat [(first v) s] (f p s (rest v)))\n            (cons (first v) (f p s (rest v)))\n)))))","problem":132,"user":"4f01c938535dcb61093f6a39"},{"problem":132,"code":"#(->> (partition-all 2 1 %3)\n  (mapcat (fn [[a b]] (if (and b (% a b)) [a %2] [a]))))","user":"5b61aa6ae4b0c6492753e712"},{"problem":132,"code":"(fn [p v c]\n  (mapcat\n   #(cond\n     (nil? (next %)) %\n     (apply p %) [(first %) v]\n     :else [(first %)])\n   (partition-all 2 1 c)))","user":"4e6a4950535d8ccf87e9febf"},{"code":"(fn [pred in coll]\n  (if (next coll)\n    (->> coll\n         (partition 2 1)\n         (mapcat (comp next #(if (apply pred %) (interpose in %) %)))\n    \t (cons (first coll)))\n    coll))","problem":132,"user":"52fa4f48e4b047fd55836ff7"},{"code":"(fn insert-between*\n  [pred val [head & tail :as coll]]\n  (lazy-seq\n   (when (seq coll)\n     (cons head\n           (when (seq tail)\n             (if (pred head (first tail))\n               (cons val (insert-between* pred val tail))\n               (insert-between* pred val tail)))))))","problem":132,"user":"4dda44f2535d02782fcbe9f1"},{"code":"(fn [p v items]\n  (let [insert-after (concat (map p items (rest items)) '(false))\n        inserted (map-indexed #(if (nth insert-after %1) [%2 v] %2) items)]\n    (flatten inserted)))","problem":132,"user":"510cd1dde4b078ea71921124"},{"problem":132,"code":"#(let [f (fn [x y] (if (and ((complement keyword?) (last x)) (%1 (last x) y)) \n(concat x [%2 y]) (concat x [y])))]\n(if (empty? %3) []\n(last (take 20 (reductions f (list (first %3)) (rest %3))))))\n;dirty (last (take 20 (reductions ...))) instead of (reduce ...) \n;because of last test ArithmeticException integer overflow","user":"5e13a6b7e4b099d064963001"},{"problem":132,"code":"(fn f[op val [fst & rst :as xs]]\n  (lazy-seq\n   (cond\n     (not (seq rst)) xs\n     (op fst (first rst)) (cons fst (cons val (f op val rst)))\n     :else (cons fst (f op val rst)))))","user":"56795deae4b05957ce8c6187"},{"problem":132,"code":"(fn [pred v coll]\n  (mapcat (fn [[a b]] (if (and b (pred a b)) [a v] [a])) (partition-all 2 1 coll)))","user":"4f3ca5a6e4b0e243712b1f53"},{"problem":132,"code":"(fn [pred sep coll]\n  (->> (lazy-cat [nil] coll)\n       (partition 2 1)\n       (map #(if (and (not (nil? (first %)))\n                      (pred (first %) (second %))) [sep (second %)] (second %)))\n       (flatten)\n       )\n  )","user":"56f15eade4b04a395b9a048e"},{"code":"(fn [pred value coll]\n   (letfn [(inner [c]\n             (if-let [fst (first c)]\n               (if-let [snd (second c)]\n                 (let [rst (lazy-seq (inner (rest c)))]\n                   (if (pred fst snd)\n                     (cons fst (cons value rst))\n                     (cons fst rst)))\n                 c)\n               c))]\n     (inner coll)))","problem":132,"user":"4f2e0369e4b0d6649770a064"},{"problem":132,"code":"(fn [p v xs]\n (mapcat\n  #(if (p % %2) [% v] [%])\n  xs\n  (lazy-cat (drop 1 xs) (take 1 xs))))","user":"5835cb06e4b089d5ab817cea"},{"code":"(fn [cmp ins col]\n  (if (empty? col)\n    '()\n    (flatten (reductions\n              (fn [acc x]\n                (if (cmp (if (coll? acc) (last acc) acc) x)\n                  (list ins x)\n                  x)\n                ) col))\n  ))","problem":132,"user":"503ca47fe4b06c4e0e1fa24f"},{"code":"(fn f1 [p v c]\n  (lazy-cat (mapcat (fn [a b]\n                   (if (p a b)\n                     [a v]\n                     [a]))\n                 c\n                 (rest c))\n            (take-last 1 c)))","problem":132,"user":"50ae0d24e4b0a40c9cfb08ce"},{"problem":132,"code":"(fn f [pred v [x & remain :as xs]]\n  (when (seq xs)\n    (lazy-seq (cons x\n                    (when (seq remain)\n                      (if (pred x (first remain))\n                        (cons v (f pred v remain))\n                        (f pred v remain)))))))","user":"573d58c8e4b05c31a32c0811"},{"code":"(fn [f v l]\n  (letfn [(between-lazy [f v l] \n  (let [a (atom 0)\n        e (atom (first l))\n        l  (atom l)]\n    (letfn [(dof []\n     (if-let [d (first @l)] \n\t\t(cond \n          (zero? @a) \n          (do\n            (swap! l next)\n            (swap! e (constantly d))\n\t\t    (swap! a (constantly 1))\n            d)\n          (= 1 @a)\n          (if (f @e d)\n\t\t    (do\n\t         (swap! a (constantly 2))\t\n\t\t\t  v)\n            (do\n              (swap! l next)\n              (swap! e (constantly d))\n\t          (swap! a (constantly 1))\t\n\t\t\t  d))\n          :else\n            (do\n              (swap! a (constantly 1))\n              (swap! e (constantly d))\n\t\t      (swap! l next)\n              d))))]\n    (repeatedly dof))))\n(between-nonlazy [f v l] \n  (if (empty? l)\n     []\n     (reduce (fn [s e] (if (f (last s) e) (conj (conj s v) e) (conj s e)))\n                     [(first l)] (vec (next l)))))]\n\t(if (or (not (= (type l) clojure.lang.LazySeq)) (< (count (take 13 l)) 13))\n\t\t(between-nonlazy f v l)\n\t\t(between-lazy f v l))))","problem":132,"user":"4e6e3a1e535d5021c1a89602"},{"code":"(fn foo [p k c]\n  (when (seq c)\n    (let [a (first c),\n          b (second c),\n          h (if (and b (p a b))\n              [a k]\n              [a])]\n      (concat h (lazy-seq (foo p k (rest c)))))))","problem":132,"user":"5341b141e4b00652c8746ecf"},{"problem":132,"code":"(fn tb [pred v coll]\n  (cond\n    (empty? coll) '()\n    (and (next coll) (pred (first coll) (second coll))) (lazy-seq (cons (first coll) (cons v (tb pred v (rest coll)))))\n    (next coll) (lazy-seq (cons (first coll)  (tb pred v (rest coll))))\n    true coll\n    )\n  )","user":"55f2c898e4b06e875b46ce4b"},{"code":"(fn tnt [pred symb [h & t]]\n  (cond \n    (nil? h) nil\n    (nil? t) (list h)\n    :else\n      (lazy-seq\n        (let [n (tnt pred symb t)]\n          (if (pred h (first t))\n            (cons h (cons symb n))\n            (cons h n))))))","problem":132,"user":"4faa9593e4b081705acca1f9"},{"problem":132,"code":"(fn foo [pred v coll]\n  (if (< (count (take 2 coll)) 2) ;; N.B. does not realize lazy sequence\n    coll\n    (let [[h & [h2 & _ :as tail]] coll\n          lazy-tail (lazy-seq (foo pred v tail))]\n      (cons h\n        (if (pred h h2)\n          (cons v lazy-tail)\n          lazy-tail)))))","user":"50f94727e4b0e7c80cb15a49"},{"problem":132,"code":"(fn [p t s]\n  (->> s\n       (partition-all 2 1)\n       (mapcat (fn [[fst scnd]]\n                 (if (and scnd (p fst scnd))\n                   [fst t]\n                   [fst])))))","user":"4e0e0529535d04ed9115e7b9"},{"problem":132,"code":"(fn lambda [f v in]\n  (lazy-cat\n   (take 1 in)\n   (if (and (not (nil? (first in)))\n            (not (nil? (second in)))\n            (f (first in) (second in)))\n     [v])\n   (if (not (nil? (first in)))\n     (lambda f v (drop 1 in)))))","user":"54c5cc17e4b045293a27f624"},{"problem":132,"code":"(fn insertbtw\n  [pred value coll]\n  (if (empty? coll)\n  []\n  (cons \n    (first coll)\n    ((fn insert \n      [togo elem]\n      (if (empty? togo)  \n        nil\n        (if (pred elem (first togo))\n          (cons value (cons (first togo) (lazy-seq (insert (rest togo) (first togo)))))\n          (cons (first togo) (lazy-seq (insert (rest togo) (first togo)))))))  \n     (rest coll) \n     (first coll)))\n    )\n   )","user":"53d6b266e4b0e771c3025459"},{"code":"(fn [pred i ls]\n  (letfn [(f [fi [se & t :as ls]]\n            (if (empty? ls)\n              [fi]\n              (lazy-cat\n                (if (pred fi se)\n                  [fi i]\n                  [fi])\n                (f se t))))]\n    (if (empty? ls) '()\n      (f (first ls) (rest ls)))))","problem":132,"user":"5003ee7de4b0678c553fc446"},{"code":"(fn insert [pred value coll]\n  (lazy-seq\n    (if (empty? coll)\n      '()\n      (if (and (-> coll rest empty? false?) (apply pred (take 2 coll)))\n        (cons (first coll) (cons value (insert pred value (rest coll))))\n        (cons (first coll) (insert pred value (rest coll)))))))","problem":132,"user":"4edab806535d10e5ff6f5311"},{"problem":132,"code":"(fn [p i c]\n  (if (empty? c)\n    c\n                 (cons (first c)\n                       ((fn proc [col]\n                          (let [[b v] (first col)\n                                r (rest col)]\n                            (if (empty? col)\n                              col\n                              (lazy-seq\n                               (if b\n                                 (cons i (cons v (proc (rest col))))\n                                 (cons v (proc (rest col))))))))\n                        (map (fn [x y] [x y])\n                             (map p c (rest c))\n                             (rest c))))\n                 ))","user":"5b15ab32e4b0cc2b61a3be72"},{"code":"(fn insert-between [pred v s]\n   (if (empty? (rest s)) s\n       (let [[a b] s] (lazy-seq (concat (if (pred a b) [a v] [a]) (insert-between pred v (rest s)))))))","problem":132,"user":"4e89f46c535d3e98b8023288"},{"code":"(fn [f v s]\n  (if (empty? s)\n    s\n    (cons (first s)\n          (mapcat (fn [[a b]] (if (f a b) [v b] [b]))\n                  (partition 2 1 s)))))","problem":132,"user":"4f8345c6e4b033992c121c1b"},{"problem":132,"code":"(fn xxx [p new-term coll]\n   (cond\n     (nil? (second coll)) coll\n\n     (empty? coll) coll\n\n     (p (first coll) (second coll))\n     (lazy-seq (cons (first coll) (cons new-term (xxx p new-term (rest coll)))))\n\n     :else\n     (lazy-seq (cons (first coll) (xxx p new-term (rest coll))))))","user":"608ec5e4e4b03bd49d9f36c0"},{"code":"(fn [p v xs]\n  (mapcat\n    #(if (p %1 %2) [%1 v] [%1])\n    xs\n    (lazy-cat (rest xs) (take 1 xs))))","problem":132,"user":"506406c8e4b075d771da6f9f"},{"problem":132,"code":"(fn [pred sym coll]\n   (if (empty? coll)\n     []\n     (cons (first coll) (flatten (map #(if (pred (first %) (last %))\n                                         [sym (last %)]\n                                         [(last %)]) (partition 2 (interleave coll (rest coll))))))))","user":"52fac708e4b047fd55836fff"},{"problem":132,"code":"(fn [p v acoll]\n  (mapcat\n   (fn [[x y]] (if (and y (p x y)) [x v] [x]))\n   (partition-all 2 1 acoll)))","user":"5705e404e4b0b0fb43fd0676"},{"code":"(fn [f s c2] ((fn check [c]\n\t\t        (if (nil? (second c))\n                          (if (first c) [(first c)] [])\n                          (lazy-seq (if (f (first c) (second c))\n                            (concat [(first c) s] (check (rest c)))\n                            (cons (first c) (check (rest c)))))))\n                      c2))","problem":132,"user":"52c1bd29e4b07a9af579236a"},{"problem":132,"code":"(fn\n  [f v l]\n  (if (empty? l)\n    '()\n    (cons (first l)\n          (mapcat #(rest (if (apply f %) (interpose v %) %))\n                  (partition 2 1 l)))))","user":"5893c64ce4b00487982d524b"},{"problem":132,"code":"(fn [p v coll]\n  (if (empty? coll) nil\n\t  (lazy-cat [(first coll)]\n    \t        (mapcat (fn [[a b]] (if (p a b) [v b] [b])) (partition 2 1 coll)))))","user":"5126dbabe4b083bb8f88cf0e"},{"code":"(fn [p v c]\n   (letfn [(step [[[a b] & s]]\n             (if a\n               (lazy-cat (if (and b (p a b)) (list a v) (list a)) (step s))\n               nil))]\n     (step (partition-all 2 1 c))))","problem":132,"user":"4f29eb2ae4b0d6649770a037"},{"problem":132,"code":"(fn [p x c]\n  (when-let [c (seq c)]\n    (cons (first c)\n          (mapcat #(if (apply p %)\n                     [x (second %)]\n                     [(second %)])\n                  (partition 2 1 c)))))","user":"54ca9ca8e4b057c6fda3a265"},{"problem":132,"code":";; instert value for true interleave filter out nil/false\n\n\n(fn lol [pred v coll]\n  (lazy-seq \n    (filter \n      #(not (false? %))  \n      (interleave\n        (cons false \n              (map #(if (pred (first %) (second %)) v false)\n                   (partition 2 1 coll)\n              )  \n        )\n        coll\n      )\n    )\n  )\n)","user":"5143824ae4b0b4fb4ace5f36"},{"code":"(fn inserta [fun k ll]\r\n  (cond \r\n     (empty? ll) ll\r\n     (empty? (next ll)) ll\r\n     :else  \r\n       (let [x1 (first ll) x2 (second ll)]     \r\n         (if (fun x1 x2)  (cons x1 (cons k (lazy-seq (inserta fun k (next ll)))))\r\n               \t\t\t  (cons x1 (lazy-seq (inserta fun k (next ll))))))))","problem":132,"user":"4f04a06d535dcb61093f6bd9"},{"problem":132,"code":"(fn intra [pred v seq]\n  (if (or (empty? seq)\n          (empty? (rest seq)))\n    seq\n    (let [f (first seq)\n          n (second seq)\n          a (if (pred f n) (list f v) (list f))]\n        (concat a (lazy-seq (intra pred v (rest seq)))))))","user":"5d1bbef0e4b02ea6f0fb6984"},{"code":"(fn g [f v [a & t]]\n  (lazy-seq\n   (when a\n     (if (seq t)\n       (let [r (g f v t)]\n         (cons a\n               (if (f a (first t))\n                 (cons v r)\n                 r)))\n       [a]))))","problem":132,"user":"523ed522e4b057c4b7cd0a78"},{"problem":132,"code":"(fn\n  [pred value coll]\n  (if (seq coll)\n    (letfn [(r [pr coll]\n              (lazy-seq\n                (let [fst (first coll)]\n                  (if (seq coll)\n                    (if (pred pr fst)\n                      (cons value\n                            (cons fst (r fst (rest coll))))\n                      (cons fst (r fst (rest coll))))\n                    nil))))]\n      (cons (first coll) (r (first coll) (rest coll))))\n    coll))","user":"52dfc89be4b09f7907dd1405"},{"code":"(fn g [p k l]\n  (lazy-seq\n   (let [c cons\n         [f & t] l\n         [s] t\n         r (g p k t)]\n     (if s\n       (c f\n          (if (p f s)\n            (c k r)\n            r))\n       l))))","problem":132,"user":"51ad244fe4b09397d510977f"},{"problem":132,"code":"(fn [p v c]\n  (mapcat (fn [[v1 v2 :as vs]]\n            (if v2\n              (if (p v1 v2)\n                [v1 v]\n                [v1])\n              vs))\n          (partition-all 2 1 c)))","user":"56441634e4b0018b46ad8c08"},{"problem":132,"code":"(fn f [p e [x & [y & ys :as zs] :as xs]]\n  (if x\n    (if y\n      (if (p x y) (lazy-seq (cons x (cons e (f p e zs))))\n        (lazy-seq (cons x (f p e zs))))\n      [x])\n    []))","user":"53976599e4b0b51d73faaeea"},{"problem":132,"code":"(fn [o k l]\r\n  (mapcat (fn [[a b]] (if (and b (o a b)) [a k] [a])) (partition-all 2 1 l)))","user":"5f2c02d1e4b033932238a65f"},{"code":"(fn this [f s l]\r\n  (lazy-seq \r\n   (if (< (count (take 2 l)) 2) l\r\n       (if (f (first l) (second l))\r\n         (cons (first l) (cons s (this f s (rest l))))\r\n         (cons (first l) (this f s (rest l)))))))","problem":132,"user":"4f474f43e4b0d56e7bb92bb7"},{"problem":132,"code":"(fn insert-between [p ins [a b & t]]\n  (cond\n    (nil? a) nil\n    (nil? b) (cons a nil)\n    :else (if (p a b)\n      (cons a (cons ins (lazy-seq (insert-between p ins (cons b t)))))\n      (cons a (lazy-seq (insert-between p ins (cons b t)))))))","user":"57e0f30ae4b0bfb2137f5a66"},{"code":"(fn predicate-insert [f value coll]\r\n  (if (empty? coll)\r\n    []\r\n    (if (and (second coll) (f (first coll) (second coll)))\r\n      (lazy-seq (cons (first coll) (cons value (predicate-insert f value (rest coll)))))\r\n      (cons (first coll) (predicate-insert f value (rest coll)) ))))","problem":132,"user":"4fd170fce4b04c3a95aa0411"},{"code":"(fn foo [p v coll]\n  (lazy-seq\n    (when-first [el coll]\n      (let [r (rest coll)]\n        (if (and (seq r) (p el (first r)))\n          (cons el (cons v (foo p v r)))\n          (cons el (foo p v r)))))))","problem":132,"user":"4f03154a535dcb61093f6a58"},{"code":"(fn f [p v [x & [y :as xs] :as c]]\n  (when (seq c)\n    (concat (if (and (seq xs) (p x y))\n              [x v] [x])\n            (lazy-seq (f p v xs)))))","problem":132,"user":"4dbb0b6c535d1e037afb21b0"},{"code":"(fn [p v s]\n  (when (seq s)\n    (cons \n      (first s)\n      (mapcat #(if (p %1 %2) [v %2] [%2]) s (rest s)))))","problem":132,"user":"4f08b15b535dcb61093f6c40"},{"problem":132,"code":"(fn insert-between [pred v coll]\n  (if (first coll)\n    (->> [coll (rest coll)]\n         (apply mapcat (fn [a b] (if (pred a b) [v b] [b])))\n         (cons (first coll))) \n    coll))","user":"5c506951e4b0f9f7a8770ec5"},{"problem":132,"code":"(fn [pred x [head :as coll]]\n    (if (empty? coll)\n      coll\n      (cons head\n            (->> coll\n              (partition 2 1)\n              (mapcat (fn [[a b]]\n                        (if (pred a b)\n                          [x b]\n                          [b])))))))","user":"4f410b63e4b0e243712b1fc5"},{"code":"#((fn f [[a & ar :as as] [b & br]]\n    (if (empty? as) as\n      (lazy-cat (if (and ar (% a b)) [a %2] [a]) (f ar br))))\n  %3 (rest %3))","problem":132,"user":"4f06dcad535dcb61093f6c16"},{"code":"(fn I [p v c]\n    (lazy-seq\n     (let [C cons\n           f (first c)]\n       (if (seq c)\n         (C f (let [r (I p v (rest c))\n                    s (second c)]\n                (if (and s (p f s))\n                  (C v r)\n                  r)))))))","problem":132,"user":"4f0ef874535d0136e6c22328"},{"code":"(fn ins [f v xs] (if (or (empty? xs) (empty? (rest xs))) xs\n                   (let [[y1 y2 & ys] xs]\n                     (lazy-seq \n                      (if (f y1 y2) \n                        (concat [y1 v] (ins f v (rest xs)))\n                        (cons y1 (ins f v (rest xs)) ))))))","problem":132,"user":"515fb48fe4b0e2be8aa20bd5"},{"code":"(fn [p v s]\n  (apply concat\n    (map\n      (fn [[a b]] \n        (cond (nil? b) [a] \n              (p a b) [a v] \n              :else [a]))\n      (partition-all 2 1 s))))","problem":132,"user":"5201572be4b0d7096e99ddbb"},{"code":"(fn ibt [f v coll]                                                                                                 \n  (if (empty? coll) coll                                                                                          \n      (concat (list (first coll)) \n              (mapcat (fn [y]                                                                                     \n              \t          (if (f (first y) (last y))                                                                \n                \t          (list v (last y))                                                                     \n                    \t      (list (last y)))) (partition 2 1 coll)) )                           \n      )  )","problem":132,"user":"52140b53e4b0961f15ac4d7e"},{"problem":132,"code":"(fn [pred val coll]\n  (let [ncoll (partition 2 1 coll)]\n    (if-not (empty? coll)\n  \t  (flatten [(first coll)\n                (map #(let [f (first %) s (second %)]\n           \t\t\t\t(if (pred f s) \n                  \t      [val s]\n                          [s]))\n                  \t  ncoll)]))))","user":"53573d70e4b04ce2eb3ed278"},{"problem":132,"code":"(fn [p k coll]\n  (letfn [(inbetween [p k coll]\n            (lazy-seq\n              (let [[f s :as h] (take 2 coll)]\n                (if (< (count h) 2)\n                  h\n                  (if (p f s)\n                    (cons f (cons k (inbetween p k (rest coll))))\n                    (cons f (inbetween p k (rest coll))))))))]\n    (inbetween p k coll)))","user":"58bb218be4b0888cdc949cf4"},{"problem":132,"code":"(fn p132 [f d ls]\n  (if (or (empty? ls) (= (count (take 2 ls)) 1))\n    ls\n    (lazy-seq(if (f (first ls) (second ls)) (concat [(first ls) d] (p132 f d (rest ls)))\n      (concat [(first ls)] (p132 f d (rest ls)))))))","user":"564d3169e4b0284900eef67c"},{"code":"(fn [p item coll]\n  (lazy-cat\n    (mapcat\n      #(if (apply p %) [(first %) item] [(first %)])\n      (partition 2 1 coll))\n    (if-not (empty? coll) [(last coll)])))","problem":132,"user":"5002b6e5e4b0678c553fc42c"},{"problem":132,"code":";(fn [f item xs]\n;  (loop [[x1 x2 & r] xs result []]\n;    (cond\n;      (nil? x1) result\n;      (nil? x2) (conj result x1)\n;      (f x1 x2) (recur (lazy-seq (cons x2 r)) \n;                       (conj result x1 item))\n;      :else (recur (lazy-seq (cons x2 r)) \n;                   (conj result x1)))))\n\n(fn insert [f item xs]\n  (let [[x1 x2 & r] xs]\n    (cond\n      (nil? x1) nil\n      (nil? x2) (lazy-seq (cons x1 (insert f item r)))\n      (f x1 x2) (lazy-seq (conj (insert f item (cons x2 r)) item x1))\n      :else (lazy-seq (cons x1 (insert f item (cons x2 r)))))))","user":"5ebdb3d2e4b00a66d4a95275"},{"problem":132,"code":"(fn in-be-two-items\n  [p v c]\n  (if (seq c)\n    (let [xs (map #(if (apply p %) [(first %) v (last %)] %) (partition 2 1 c))]\n      (letfn [(step [coll]\n                (if (seq coll)\n                  (lazy-cat (drop-last (first coll)) (step (rest coll)))))]\n        (lazy-cat (step xs) [(last c)])))))","user":"565654dae4b0f9d632dd849f"},{"problem":132,"code":"(fn insert-between-two\n  [f v s]\n  (if (and (-> s nil? not) (-> s empty? not)) \n    (lazy-seq\n      (cons\n        (first s)\n        (if (and (-> (second s) nil? not) (f (first s) (second s)))\n          (cons v (insert-between-two f v (next s)))\n          (insert-between-two f v (next s))\n          )\n        )\n      )\n    )\n\n  )","user":"5c20b6abe4b07e362c230576"},{"problem":132,"code":"(fn insert-inbetween [f keywrd pend]\n\t((fn lazzy-inner [last-part f keywrd pend]\n\t\t(if (empty? pend)\n\t\t\t(remove nil? [last-part])\n\t\t\t(if (apply f [last-part (first pend)])\n\t\t\t\t(lazy-seq \n\t\t\t\t\t(cons last-part \n\t\t\t\t\t\t(cons keywrd (lazzy-inner (first pend) f keywrd (rest pend)))))\n\t\t\t\t(lazy-seq \n\t\t\t\t\t(cons last-part \n\t\t\t\t\t\t(lazzy-inner (first pend) f keywrd (rest pend))))))) \n\t(first pend) f keywrd (rest pend)))","user":"57986b76e4b039eba2ecb116"},{"problem":132,"code":"(fn insert-pred-mark [pred v coll]                                         \n\t(if (empty? coll)                                                            \n\t\t[]                                                                           \n\t\t(let [x (first coll) r (rest coll)]                                          \n\t\t\t(if (empty? r)                                                               \n\t\t\t\t[x]                                                                          \n\t\t\t\t(lazy-cat (if (pred x (first r)) [x v] [x]) (insert-pred-mark pred v r))))))","user":"55afd469e4b002ce9d5cbc19"},{"problem":132,"code":"(fn [p v xs]\n  (if (empty? xs) []\n     (let [ys (partition 2 1 xs)]\n       (cons (first xs)\n             (mapcat (fn [[a b]] (if (p a b) [v b] [b])) ys)))))","user":"553e0b70e4b0a04f792994e8"},{"problem":132,"code":"(fn [_pred _val _col]\n  (mapcat\n   (fn [[x y]]\n     (if (or (nil? y)\n             (not (_pred x y)))\n       [x]\n       [x _val]))\n   (map-indexed\n    #(vector %2\n             (first (drop\n                     (inc %1)\n                     _col)))\n    _col)))","user":"54da46e5e4b024c67c0cf753"},{"code":"(fn [p v [x & y :as c]]\n  (if (empty? c) c\n    (flatten \n     (reductions \n      #(if (p (last %) %2) [v %2] [%2])\n      [x]\n      y))))","problem":132,"user":"4e03c616535d04ed9115e796"},{"code":"(fn ibti ([f k a] (if (empty? a) '()\n      (ibti (first a) (next a) [] f k)))\n\t    ([lst a r f k]\n\t    (lazy-seq (if (empty? a) (concat r [lst])\n\t\t\t  (let [b (f lst (first a))]\n\t\t\t       (if b (concat [lst k] (ibti (first a) (next a) r f k))\n\t\t\t\t   (concat [lst] (ibti (first a) (next a) r f k))))))))","problem":132,"user":"4ec5d62c535d6d7199dd36ba"},{"problem":132,"code":"(letfn [(ins [p v c]\n  (let [f (first c)\n        s (second c)]\n    (cond (nil? f) ()\n          (nil? s) (list f)\n          :else (cons f (if (p f s)\n                          (cons v (lazy-seq (ins p v (rest c))))\n                          (lazy-seq (ins p v (rest c))))))))]\n        ins)","user":"538e36c7e4b0b51d73faae81"},{"problem":132,"code":"(fn [f v s]\n  (if (seq s)\n    (concat [(first s)] \n            (mapcat (fn [[a b]] \n                      (if (f a b)\n                        [v b]\n                        [b]))\n                    (partition 2 1 s)))\n    []))","user":"5631040be4b0bfe05bf1178c"},{"problem":132,"code":"(fn pred [f v l]\n  (->> l \n       (partition 2 1)\n       (map #(if (f (first %) (second %)) v))\n       (#(concat % '(nil)))\n       (interleave l)\n       (filter #(not (nil? %)))\n ))","user":"57887de2e4b0ebec4cfb751c"},{"code":"(fn [p v c] (remove nil? (interleave c (concat (map #(if (p %1 %2) v nil) c (next c)) '(nil)))))","problem":132,"user":"5176afd2e4b085adf681d889"},{"code":"(fn [f y xs]\n  (flatten (map #(if (and %1 (f %1 %2)) [y %2] %2)\n                (cons nil xs) xs)))","problem":132,"user":"4eb51942535d7eef30807365"},{"problem":132,"code":"(fn [f v c]\n  (if (empty? c)\n    c\n    ((fn r [f v h q]\n       (if (empty? q)\n         (list h)\n         (if (f h (first q))\n           (cons h (cons v (lazy-cat (r f v (first q) (rest q)))))\n           (cons h (lazy-cat (r f v (first q) (rest q)))))))\n     f v (first c) (rest c))))","user":"547d8e93e4b0c51c1f4d72f4"},{"code":"(fn insert-between [f k [x & [y & _ :as r]]]\n  (cond\n   (and x y) (lazy-seq\n              (cons x\n                    (if (f x y)\n                      (cons k (insert-between f k r))\n                      (insert-between f k r))))\n   x (list x)\n   :else '()))","problem":132,"user":"4f7431d2e4b044e54cd9a8f7"},{"problem":132,"code":"(fn [p v s]\n        (if (= 15 (count (take 15 s)))\n            (apply concat (map (fn [x y] (if (p x y) (list x v) (list x))) s (rest s)))\n            ((fn [ss]\n                 (if (empty? ss)\n                     nil\n                     ((fn insert_between [x xs]\n                          (if (empty? xs)\n                              (list x)\n                              (if (p x (first xs))\n                                  (cons x (cons v (insert_between (first xs) (rest xs))))\n                                  (cons x (insert_between (first xs) (rest xs)))))) (first ss) (rest ss)))) s)))","user":"5a34f342e4b0ddc586f153d1"},{"code":"(fn insert-between-satisfying [pred v [i1 i2 & _ :as coll]]\n  ;; coll where value is inserted between every 2 items satisfying predicate\n  (cond\n    (nil? i1) []\n    (nil? i2) [i1]\n    :else\n    (let [next-coll (rest coll)\n          satisfy (pred i1 i2)\n          to-add (if satisfy\n                   [i1 v]\n                   [i1])]\n      (lazy-cat to-add\n                (insert-between-satisfying pred v next-coll)))))","problem":132,"user":"4f35b2ace4b0e243712b1ec5"},{"code":"(fn [p v c]\n   (mapcat #(if (and %2 (p % %2)) (list % v) (list %))\n           c (concat (rest c) [nil])))","problem":132,"user":"4ea1b9e4535d7eef308072b8"},{"problem":132,"code":"(fn x [p v [f & r]] \n  (lazy-seq (if (empty? r)\n              (if (nil? f) '()  (list f))\n              (if (p f (first r)) \n                (cons f (cons v (x p v r)))\n                (cons f (x p v r))))))","user":"4ec4d723535dcc7ae8597d65"},{"problem":132,"code":"(fn [pred v coll]\n    (letfn [(step [prior coll]\n              (if (empty? coll)\n                nil\n                (if (pred prior (first coll))\n                  (cons v (cons (first coll) (lazy-seq (step (first coll) (rest coll)))))\n                  (cons (first coll) (lazy-seq (step (first coll) (rest coll)))))))]\n      (if (empty? coll) coll (cons (first coll) (lazy-seq (step (first coll) (rest coll)))))))","user":"51b91b08e4b0e871ca4958f8"},{"problem":132,"code":"#(mapcat (fn [[a b]]\n           (cons a (when (and b (% a b)) [%2])))\n         (partition-all 2 1 %3))","user":"53ea5851e4b036ad0777e4e4"},{"code":"(fn insert [p v s]\n        (cond (empty? (rest s)) s\n              (p (first s) (second s)) (lazy-seq (list* (first s) v (insert p v (rest s))))\n              :otherwise (lazy-seq (cons (first s) (insert p v (rest s))))))","problem":132,"user":"5294e44de4b02ebb4ef75016"},{"problem":132,"code":"(fn ib [p v [c1 & [c2 :as cs]]]\n  (if c1\n    (lazy-seq\n     (let [tl (ib p v cs)]\n       (if (and c2 (p c1 c2))\n         (cons c1 (cons v tl))\n         (cons c1 tl))))))","user":"52ce1abfe4b07d0d72b27389"},{"code":"(fn g\n  [f e xs]\n  (let [ys (drop 1 xs)]\n    (if (empty? ys)\n      xs\n      (lazy-seq\n       (if (f (first xs) (first ys))\n         (cons (first xs) (cons e (g f e (drop 1 xs))))\n         (cons (first xs) (g f e (drop 1 xs))))))))","problem":132,"user":"4db53f87535d87e67b28fe08"},{"problem":132,"code":"( fn  foo [ff kk [a & r] ]\n  (lazy-seq (if (seq r)\n    (if (ff a (first r))\n       (concat [a  kk] (foo ff kk r )  )\n       (cons a (foo ff kk r )  )\n    ) \n    (if a (list a))\n  \n  \n  ))\n  )","user":"5735ac67e4b0cd1946bd102b"},{"problem":132,"code":"(fn [p v xs] \n  (flatten (map #(if (p % %2) [% v] %) xs (rest (cycle xs)))))","user":"5392bfdee4b0b51d73faaeb2"},{"problem":132,"code":"(fn f [pred val coll]\n    (lazy-seq\n     (if (seq coll)\n       (if (next coll)\n         (let [lft (first coll)\n               rgt (first (rest coll))\n               pred? (pred lft rgt)]\n           (if pred?\n             (cons (first coll)\n                   (cons val\n                         (f pred val (rest coll))))\n             (cons (first coll)\n                   (f pred val (rest coll)))))\n         (cons (first coll)\n               (rest coll))))))","user":"5be5cebde4b0ed4b8aab4d19"},{"code":"(fn[p v c](let[x(mapcat(fn[[a b]](if(p a b)[v b][b]))(partition 2 1 c))](if(seq c)(cons(first c)x)x)))","problem":132,"user":"4dd4034a535dae65d5c462df"},{"problem":132,"code":"(fn [p a xs]\n  (if (empty? xs)\n    xs\n  \t(lazy-seq\n   \t (cons\n      (first xs)\n      (->> xs\n           (partition 2 1)\n           (map (fn [[x y]] (if (p x y) [a y] [y])))\n           (apply concat))))))","user":"53244c9de4b09d4e7a9b54db"},{"code":"(fn ib [f v c]\n  (if (empty? (rest c))\n    c \n    (lazy-seq \n      (let [a (first c)\n            b (second c)]\n        (if (f (int a) (int b))\n          (cons a (cons v (ib f v (rest c))))\n          (cons a (ib f v (rest c))))))))","problem":132,"user":"4ee4f4a9535d1385b2869d85"},{"problem":132,"code":"(fn[o v s]\n  (flatten (map \n            #(if (o (first %) (second %)) [(first %) v] (first %))\n            (partition 2 (interleave s (drop 1 (cycle s))\n            ))\n  ))\n)","user":"55eeb37ae4b0121d4835fdf3"},{"code":"(fn [c i l]\r\n   (mapcat #(if (and %2 (c % %2)) (list % i) (list %))\r\n           l (concat (rest l) [nil])))","problem":132,"user":"4ec0c7ba535dfed6da9c6da4"},{"code":"(fn f\n  ([op ins sq]\n   (f op ins sq ::none))\n  ([op ins sq prev]\n   (when-not (empty? sq)\n     ((if (and (not= ::none prev) (op prev (first sq)))\n        (partial cons ins)\n        identity)\n        (lazy-seq (cons (first sq)\n                        (f op ins (rest sq) (first sq))))))))","problem":132,"user":"50b668dde4b08fb537db98f2"},{"code":"(fn [p v c]\r\n  (when (not (empty? c))\r\n    (lazy-cat \r\n      (mapcat #(if (p % %2) [% v] [%]) c (rest c))\r\n      [(last c)])))","problem":132,"user":"4db03279838c48654951d9bc"},{"problem":132,"code":"(fn foo [op symb coll]\n  (cond\n    (empty? (rest coll))\n      coll\n    (op (first coll) (second coll))\n      (lazy-seq (concat [(first coll) symb]\n                  (foo op symb (rest coll))))\n    :else\n      (lazy-seq (cons (first coll)\n                    (foo op symb (rest coll))))))","user":"57c0917be4b05aa3c4741c95"},{"code":"(fn insert* [pred value as]\n    (cond\n        (empty? as) []\n        (nil? (second as)) (lazy-seq as)\n        :else \n        (lazy-seq\n            (concat \n                (if (pred (first as) (second as)) (list (first as) value) (list (first as))) \n                (insert* pred value (rest as))))))","problem":132,"user":"4f0e995e535d0136e6c22326"},{"problem":132,"code":"(fn ! [p v c]\n  (if (or (empty? c) (= 1 (count (take 2 c))))\n    c\n    (if (p (first c) (second c)) \n      (cons (first c) (cons v (lazy-seq (! p v (rest c)))))\n      (cons (first c) (lazy-seq (! p v (rest c))))\n      )))","user":"52faec2ee4b047fd55837004"},{"problem":132,"code":";;(vec (\n(fn [p v c] \n  (->> c\n       (partition-all 2 1)\n       (mapcat \n        #(if (and\n              (= 2 (count %))\n              (apply p %))\n           [% [v]]\n           [%]))\n       (map first)))\n;;< :less [1]))","user":"5da8fa72e4b000c986472c2d"},{"code":"(fn b [p v s]\n  (cond \n    (empty? s) nil\n    (nil? (next s)) s\n    :else ((fn g [r] \n             (let [i (cons (ffirst r)\n                           (if (apply p (first r))\n                             (cons v nil)\n                             nil))\n                   n (next r)]\n               (concat i (if n\n                           (lazy-seq (g n))\n                           (list (last (first r)))))))\n            (partition 2 1 s))))","problem":132,"user":"52c8758be4b0c2d177d62135"},{"problem":132,"code":"(fn [p v xs]\n  (if (empty? xs)\n    ()\n    (cons (first xs)\n      (apply concat (map #(let [snd (second %)] (if (apply p %) [v snd] [snd])) (partition 2 1 xs))))))","user":"5416b4a2e4b01498b1a71a01"},{"problem":132,"code":"(fn ins [p i [x & zs]] (cond (nil? x) '()\n                         (nil? zs) (list x)\n                         :e (lazy-seq (cons x ((if (p x (first zs)) (partial cons i) identity) (ins p i zs))))))","user":"5310e968e4b08068f379ecdd"},{"problem":132,"code":"(fn solve [p s xs] (lazy-cat (if (empty? xs) [] (reduce (fn [acc x]\n                       (into acc (let [k (last acc)]\n                        (if (p k x)\n                         [s x] [x]))))\n                        [(first xs)]\n                      (rest (take 10 xs)) ))))","user":"54e51c7be4b024c67c0cf7f7"},{"code":"(fn [f v col]\n  (when (seq col)\n    (cons (first col)\n     (mapcat (fn [a b]\n              (if (f a b)\n                  [v b] [b]))\n          col (next col)))))","problem":132,"user":"4e50e2a0535dc968683fc4ef"},{"problem":132,"code":"(fn [f d l] \n  (->> l \n       (partition 2 1)\n       (map #(if(apply f %)[d(last %)][(last %)]))\n       (concat(if(first l)[(first l)][]))\n       flatten\n))","user":"5951190be4b066ee0a44aea4"},{"code":"(fn tap [pred insert-val coll]\n  (cond \n    (empty? coll) []\n    (empty? (rest coll)) coll\n    :else\n      (let [fst (first coll)\n            _ (println \"fst\" fst)\n            new-coll (rest coll)\n            snd (second coll)\n            _ (println \"snd\" snd)\n            sat-pred (pred fst snd)\n            _ (println \"sat-pred\" sat-pred)]\n        (lazy-seq (cons fst (if sat-pred\n                              (cons insert-val (tap pred insert-val new-coll))\n                              (tap pred insert-val new-coll)))))))","problem":132,"user":"4f036fb3535dcb61093f6ac8"},{"code":"(fn [pred sep coll]\n  (and (seq coll)\n       (cons (first coll)\n             (mapcat (fn [x y]\n                       (if (pred x y)\n                         (list sep y)\n                         (list y))) \n                     coll (rest coll)))))","problem":132,"user":"4ee3b586535d10e5ff6f5371"},{"problem":132,"code":"(fn [p v c]\n  (mapcat\n   (fn [[e n]]\n     (if (and e n (p e n))\n       (list e v)\n       (list e)))\n   (partition-all 2 1 c))\n)","user":"5881d1c2e4b0f1effa3b7644"},{"problem":132,"code":"(fn i [p v c]\n  (if (empty? c)\n    '()\n    (let [f (first c)\n          s (second c)]\n      (if (nil? s)\n        [f]\n        (lazy-cat (if (p f s) [f v] [f]) (i p v (rest c)))))))","user":"55205564e4b08d5046aa8a60"},{"code":"(fn f [pred a [x & r]]\n  (cond\n   (nil? x) '()\n   (nil? r) (list x)  \n   :else (lazy-seq\n   \t\t\t(if (pred x (first r))\n     \t\t\t(cons x (cons a (f pred a r)))\n     \t\t\t(cons x (f pred a r))))))","problem":132,"user":"52039e12e4b0fb7e47ea51ff"},{"code":"(fn ins [f v s]\n  (let [x (first s) y (second s)]\n    (if (and x y)\n      (lazy-seq\n       (if (f x y)\n         (cons x (cons v (ins f v (rest s))))\n         (cons x (ins f v (rest s)))\n       )\n      )\n      (if (and x (nil? y))\n        [x]\n        []\n      )\n    )\n  ) \n )","problem":132,"user":"51ba8f82e4b0fe3ecfb46434"},{"code":"(fn ins [p v [x & m :as c]]\n  (cond \n    (empty? m) c\n    (apply p (take 2 c)) (lazy-cat [x v] (ins p v m))\n    :else (lazy-cat [x] (ins p v m))))","problem":132,"user":"500aa15ee4b03d00572d2d76"},{"code":"(fn g [f k [h & r]]\n  (if h \n    (if (empty? r) \n      [h]\n      (lazy-seq (concat [h] (if (f h (first r)) [k]) (g f k r)))) \n    []))","problem":132,"user":"4f1d1d95535d64f603146488"},{"problem":132,"code":"(fn f [pred sym s]\n  (if (empty? s) s\n  \t(cons (first s) (mapcat #(if (pred %1 %2) [sym %2] [%2]) s (rest s)))))","user":"5dd60c58e4b0948ae9d9ad7c"},{"problem":132,"code":"(fn ib [f s v]\n  (cond (empty? v) []\n        (= nil (second v)) v\n        (f (first v) (second v)) (cons (first v) (cons s (ib f s (rest v))))\n        :else (lazy-seq (cons (first v) (ib f s (rest v))))))","user":"55e732c5e4b050e68259b492"},{"problem":132,"code":"(fn [p v c]\n  (if (nil? (first c)) []\n    (->>\n      (partition 2 1 c)\n      (map  (fn [[a b]] (if (p a b) [v b] [b]))) \n      (cons (first c))\n      (flatten)\n      )))","user":"541ddadbe4b01498b1a71a84"},{"problem":132,"code":"(letfn [(ibt [p v c] \n  (if (empty? c) c (let[fc (first c) sc (second c)] \n    (if (nil? sc) (list fc) \n      (lazy-cat (if (p fc sc) (list fc v) (list fc)) \n        (ibt p v (rest c)))))))]ibt)","user":"58e7229fe4b056aecfd47cc4"},{"code":"(fn [p v s] (if-let [[f & r] (seq s)]\n              (cons f (mapcat #(if (p % %2) (list v %2) (list %2)) s r))\n              s))","problem":132,"user":"525f51bde4b0cb4875a45dc8"},{"code":"(fn [f e z] (letfn [(helper [p l] (if (nil? p) nil (lazy-seq (if (empty? l) (cons p (helper nil l)) (if (f p (first l)) (cons p (cons e (helper (first l) (rest l)))) (cons p  (helper (first l) (rest l))))))))]            \n                      (helper (first z) (rest z))))","problem":132,"user":"52265e41e4b04e78ff2e1981"},{"code":"(fn [p v c]\n           (if (empty? c)\n               c\n               (concat [(first c)]\n                       (mapcat (fn [[a b]]\n                                   (if (p a b)\n                                       [v b]\n                                       [b]))\n                               (partition 2 1 c)))))","problem":132,"user":"4f34eb87e4b0e243712b1eba"},{"code":"(fn [pred k coll]\n  (if (seq coll)\n    (let [temp-result (map #(if (apply pred %) [(first %) k (last %)] %) (partition 2 1 coll))]\n      (letfn [(step [coll]\n                (if (seq coll)\n                  (lazy-cat (drop-last (first coll)) (step (next coll)))))]\n        (lazy-cat (step temp-result) [(last coll)])))))","problem":132,"user":"514d7e29e4b019235f6c0587"},{"code":"(fn g [f v coll]\n  (let [a (first coll)\n        b (fnext coll)\n        r (rest coll)]\n    (cond\n      (nil? a) '()\n      (and (not(nil? b)) (f a b)) (cons a (cons v (lazy-seq (g f v r))))\n      :else (cons a (lazy-seq (g f v r))))))","problem":132,"user":"51057b2be4b06d28cacc92e8"},{"code":"(fn ib-lazy [pred, v, coll]\n  (if (empty? coll)\n    coll\n    (lazy-seq\n     ((fn ib-loop [x0, xs]\n        (if (empty? xs)\n          (list x0)\n          (cons x0\n                (if (pred x0 (first xs))\n                  (cons v (lazy-seq (ib-loop (first xs) (rest xs))))\n                  (lazy-seq (ib-loop (first xs) (rest xs)))))))\n      (first coll)\n      (rest coll)))))","problem":132,"user":"51365524e4b04ac1f358dd52"},{"problem":132,"code":"(fn injector [pred fill col]\n  (lazy-seq\n    (if (empty? col)\n      (list)\n      (if (empty? (rest col))\n        [(first col)]\n        (let [[fst snd & rst] col]\n          (if (pred fst snd)\n            (cons fst (cons fill (injector pred fill (rest col))))\n            (cons fst (injector pred fill (rest col)))\n            )\n          )\n        )\n      )\n    )\n  )","user":"562add6de4b00e49c7cb4834"},{"code":"(fn [f v l]\n   (filter identity\n  (interleave l \n              (concat (map #(if(reduce f %) v false) (partition 2 1 l)) '(false)))))","problem":132,"user":"51f28a64e4b0210f90e7454e"},{"problem":132,"code":"(fn insert-between [pred sep coll]\n  (if (empty? (rest coll)) \n    coll\n    (let [[a b] (take 2 coll)]\n      (if (pred a b)\n        (cons a (cons sep (lazy-seq (insert-between pred sep (rest coll)))))\n        (cons a (lazy-seq (insert-between pred sep (rest coll))))))))","user":"504e71cbe4b0f6ff3350c4b3"},{"problem":132,"code":"(fn m-insert [p v aseq]\n    \n    (letfn [(fins [aseq larg]\n                  (lazy-seq \n                    (if (seq aseq)\n                      (if (p larg (first aseq))\n                        (cons larg (cons v (fins (rest aseq) (first aseq))))\n                        (cons larg (fins (rest aseq) (first aseq))))\n                      [larg])))\n            ]\n      (when (seq aseq) (fins (rest aseq) (first aseq)))))","user":"50eddbc4e4b06330c1f87c4b"},{"code":"#((fn f [l [x & e]]\n    (if x\n      (let [r (cons x (lazy-seq (f x e)))]\n        (if (and l (% l x)) (cons %2 r) r))))\n  nil %3)","problem":132,"user":"50548ce8e4b0b1b9d1860ead"},{"problem":132,"code":"(fn abc [ pred v cs]\n   \n  (if (nil? (second cs)) cs\n      (lazy-seq \n        (cons (first cs)\n           (if (pred (first cs) (second cs)) (cons v (abc pred v (rest cs)))\n               (abc pred v (rest cs)))))))","user":"5dc12b0ae4b0e59a23173d84"},{"problem":132,"code":"(fn insert-predicate-value [pred value coll]\n  (letfn [(insert-value-test [[a b]]\n            (if (pred a b)\n              (list value b)\n              (list b)))]\n    (when (seq coll)\n      (cons (first coll) \n            (mapcat insert-value-test (partition 2 1 coll))))))","user":"58ed713de4b056aecfd47d84"},{"problem":132,"code":"(fn insert-e [f item x]\n  (lazy-seq\n    (if (empty? x) '()\n      (if (-> x second nil?) x\n        (if (f (first x) (second x))\n\t        (conj (insert-e f item (rest x)) item (first x))\n\t        (cons (first x) (insert-e f item (rest x))))))))","user":"4f6ba7bce4b07046d9f4efb0"},{"code":"(fn insert-two [pred v coll]\n  (if (empty? coll) coll\n    (let [z (if (and (not (empty? (rest coll))) (pred (first coll) (second coll))) (vector (first coll) v) (vector (first coll)))]\n      (lazy-seq      \n       (concat z (insert-two pred v (rest coll)))))))","problem":132,"user":"51780f88e4b03d69594194c9"},{"problem":132,"code":"(fn prod [pred val coll] (if (empty? (drop 1 coll))\n                                          coll\n                                          (if (= true (pred (first coll) (second coll))) (lazy-seq (conj (prod pred val (rest coll)) val (first coll)\n                                                                                                         ))\n                                          (lazy-seq (cons (first coll) (prod pred val (rest coll)))))))","user":"567f988be4b0feffd0d18ebe"},{"code":"(fn iw [p v c]\n  (if (empty? c) c\n\t(let [[h s & t] c\n\t\thead (cond\n\t\t\t(and h s (p h s)) (list h v)\n\t\t\t(and h s) (list h)\n\t\t\t:else (list h))]\n\t\t(lazy-cat head (iw p v (rest c))))))","problem":132,"user":"524ae8e6e4b09eba1c0223b5"},{"code":"(fn [p v c] (remove #(nil? %) (apply (fn r ([][]) ([a][a]) ([a b & x] (lazy-seq (concat [a (if (p a b) v)] (apply r b x))))) c)))","problem":132,"user":"4eb13d60535d7eef3080733f"},{"code":"(fn insert-if-true [pred val coll]\n  (let [pred-results (concat  (map pred\n                                   coll\n                                   (rest coll))\n                              [false])\n        f (fn [idx item]\n            (if (nth pred-results idx)\n              [item val]\n              [item]))]\n    (flatten (map-indexed f coll))))","problem":132,"user":"530578ede4b0d8b024fd3760"},{"problem":132,"code":"(fn [pred keyword xs]\n   ((fn f [x xs]\n      (cond (nil? x)    []\n            (empty? xs) [x]\n            :else       (lazy-cat (if (pred x (first xs))\n                                    [x keyword]\n                                    [x])\n                                  (f (first xs) (rest xs))))\n      )\n    (first xs) (rest xs))\n   )","user":"56f7ecdfe4b08e7d20b96834"},{"problem":132,"code":"(fn [p v [head & tail :as c]]\n  (when (seq c)\n    (cons head \n          (mapcat #(if (p % %2) \n                     [v %2] \n                     [%2]) \n                  c tail))))","user":"52b02329e4b0c58976d9acc5"},{"problem":132,"code":"(fn inb [p val coll]\n    (if-let [nextval (first coll)]\n      (let [result (if (and (not (nil? (second coll))) (p nextval (second coll)))\n                         [nextval val]\n                         [nextval]\n                         )]\n        (lazy-cat result (inb p val (rest coll))\n        )\n      )\n    )\n  )","user":"5592bf9fe4b0c79f6e1db933"},{"code":"(fn [pred default col]\n    (if (empty? (rest col)) col\n        (let [pairs (map #(list % %2) col (rest col))\n              pre-res (map #(if (pred (first %) (second %)) (list default (second %) ) (second %)) pairs)]\n          (conj (flatten pre-res) (first col)))))","problem":132,"user":"4e49a7bb535dc968683fc4c6"},{"code":"(fn [p v xs]\n  (cond (empty? xs) '()\n        :else\n        (->>\n         (partition 2 1 xs)\n         (mapcat (fn [[v1 v2]] (if (p v1 v2) [v v2] [v2])))\n         (cons (first xs)))))","problem":132,"user":"50366589e4b0fbe0a74d26c3"},{"code":"(fn inb [f v c & [acc]]\n  (cond (empty? c) []\n        (empty? acc)\n        (concat [(first c)] (lazy-seq (inb f v (rest c) [(first c)])))\n        :else (let [x (last acc)\n                    y (first c)\n                    nacc (if (or (= x v) (not (f x y))) [y] [v y])]\n                (concat nacc (lazy-seq (inb f v (rest c) nacc))))))","problem":132,"user":"4fbd12a5e4b081705acca2fd"},{"code":"(fn [f v xs]\n    (->> xs\n         (partition-all 2 1)\n         (mapcat (fn [[a b]]\n                   (cond\n                    (nil? b) [a]\n                    (f a b) [a v b]\n                    :else [a b])))\n         (partition-by identity)\n         (map first)))","problem":132,"user":"50479524e4b0371827a27bc4"},{"problem":132,"code":"(fn my-inser [pred? v coll]\n   (if (empty? coll)\n     coll\n     (cons\n                   (first coll)\n                   (mapcat\n                    (fn [[a b :as ab]]\n                      (rest \n                       (if (apply pred? ab)\n                         [a v b]\n                         ab\n                         ))\n                      )\n                    (partition 2 1 coll))\n                   )))","user":"567b2f20e4b05957ce8c61a2"},{"problem":132,"code":"(fn ist-btw\n  ([p v coll]\n   (if\n     (empty? coll)\n     '()\n     (lazy-seq\n      (cons\n       (first coll)\n       (ist-btw p v (first coll) (rest coll))))))\n  ([p v h r]\n   (if\n     (empty? r)\n     '()\n     (let\n       [n (first r) t (rest r)]\n       (if\n         (p h n)\n         (lazy-seq (cons v (cons n (ist-btw p v n t))))\n         (lazy-seq (cons n (ist-btw p v n t))))))))","user":"5796d3ebe4b039eba2ecb0ee"},{"code":"(fn insert-between [f v [x & xs]]\n  (cond (nil? x) '()\n        (empty? xs) (list x)\n        (f x (first xs)) (cons x (cons v (lazy-seq (insert-between f v xs))))\n        :else (cons x (lazy-seq (insert-between f v xs)))))","problem":132,"user":"536ca4bde4b0fc7073fd6e49"},{"problem":132,"code":"(fn [p v [a & s :as l]] \n  (when a (->> (mapcat #(if (p % %2) [v %2] [%2]) l (rest l))\n               (cons a))))","user":"5603c31fe4b04bb52996e1c1"},{"problem":132,"code":"(fn i\n\t([p k [h & t]]\n\t\t(lazy-seq \n\t\t\t(if h\n\t\t\t\t(cons h (i p k h t))\n\t\t\t\t())))\n\t([p k l [h & t]]\n\t\t(lazy-seq\n\t\t\t(if h\n\t\t\t\t(if (p l h)\n\t\t\t\t\t(cons k (cons h (i p k h t)))\n\t\t\t\t\t(cons h (i p k h t)))))))","user":"56baa68ce4b0f26550335947"},{"code":"(fn [pred token s]\n  (mapcat (fn [[a b]]\n    (if (and a b (pred a b))\n      [a token]\n      [a]))\n    (partition-all 2 1 s)))","problem":132,"user":"4f0446f9535dcb61093f6bb8"},{"problem":132,"code":"(fn\n  [p v coll]\n  (->> (partition-all 2 1 coll)\n       (mapcat (fn [[a b]]\n                 (if (or (nil? b)\n                         (not (p a b)))\n                   [a]\n                   [a v])))))","user":"5338387de4b0e30313ee6c91"},{"code":"(fn f [p v c]\n  (if (second c)\n    (lazy-seq (if (p (first c) (second c))\n                (cons (first c) (cons v (f p v (rest c))))\n                (cons (first c) (f p v (rest c)))))\n    c))","problem":132,"user":"51bec919e4b013aa0d74b800"},{"code":"(fn [pred v coll]\n  (mapcat (fn [[a b]] (if (pred a b) [a v] [a]))\n          (partition 2 1 (repeat (first coll)) coll)))","problem":132,"user":"4e773be8535d324fb2983d6e"},{"problem":132,"code":"(fn [pred value coll]\n  (mapcat (fn [[x y]]\n            (cond (nil? y) [x]\n                  (pred x y) [x value]\n                  :else [x]))\n          (partition-all 2 1 coll)))","user":"5515b138e4b055c2f668d4ed"},{"code":"(fn insert-between [pred e lst]\n  (if (not (next lst)) lst\n    (let [fst (first lst)\n          snd (second lst)\n          rst (rest lst) ]\n      (cons fst (lazy-seq\n        (if (pred fst snd) (cons e (insert-between pred e rst))\n          (insert-between pred e rst)))))))","problem":132,"user":"4e356d2b535deb9a81d77f2d"},{"code":"(fn [p v l] (concat (take 1 l) (mapcat #(if (p % %2) [v %2] [%2]) l (rest l))))","problem":132,"user":"4e7f4147535db966e863cc3d"},{"problem":132,"code":"(fn in-it [op p v]\n  (if-let [head (first v)]\n      (cons head\n        (mapcat (fn [[a b]](if (op a b) [p b] [b]))\n          (partition 2 1 v)))\n     []))","user":"538e29d1e4b0b51d73faae80"},{"problem":132,"code":"(fn myins [pred item xs]\n  (let [parts (partition-all 2 1 xs)\n        doit  (fn [pair]\n                (cond\n                  (= 1 (count pair)) pair\n                  (pred (first pair) (last pair)) (list (first pair) item)\n                  :else (first pair)))\n        res (map doit parts)]\n     (flatten res)))","user":"52f426fce4b05e3f0be25f1e"},{"code":"(fn [p m c]\n    (flatten\n      (map\n        (fn [[f s]]\n          (cond\n            (nil? s) f\n            (p f s) [f m]\n            1 f))\n        (partition 2 1 nil c))))","problem":132,"user":"4dbdc9da535d020aff1edf4c"},{"code":"(fn [f v coll]\n  (if-let [s (first coll)]\n          (flatten (cons s (map (fn [[x y]] (if (f x y) [v y] y)) (partition 2 1 coll))))\n          coll))","problem":132,"user":"4fc67081e4b0ee37620e1813"},{"problem":132,"code":"(fn f [p v xs]\n  (let [part (partition 2 1 xs)]\n    (if (empty? part) \n      xs\n      (cons (first xs) (flatten (map (fn [[a b]] (if (p a b) (list v b) b)) part))))))","user":"5e12327ee4b099d064962fe5"},{"code":"(fn [pred sep coll]\n  (letfn [(go [c]\n            (when-first [x c]\n              (if (and (seq (next c)) (pred x (second c)))\n                  (cons x (cons sep (lazy-seq (go (rest c)))))\n                  (cons x (lazy-seq (go (rest c)))))))]\n    (go coll)))","problem":132,"user":"51d19c24e4b0cfcf579466c3"},{"code":"(fn [p v c]\n  (flatten (cons (if (empty? c) () (first c)) (map #(if (apply p %) (list  v (second %)) (second %) )(partition  2 1 c)))))","problem":132,"user":"5142e808e4b0c172af7558c9"},{"problem":132,"code":"(fn stuff [pred s coll]\n  (if (or (empty? coll) (empty? (rest coll)))\n    coll\n    (let [coll (partition 2 1 coll)]\n      (->> (map (fn [[x y]] (if (pred x y)\n                              [s y]\n                              y))\n                coll)\n           (cons (first (first coll)))\n           flatten))))","user":"54db3d82e4b024c67c0cf75f"},{"problem":132,"code":"(fn [pred delim ys]\n  (if (seq (drop 2 ys))\n  \t(lazy-cat \n\t\t(mapcat \n\t\t(fn [a b] \n\t\t\t(if (pred a b) \n\t\t\t\t[a delim ] \n\t\t\t\t[a ])) \n\t\tys \n\t\t(drop 1 ys))\n\t\t[(last ys)])\n  \tys))","user":"527ccaf4e4b0757a1b17136d"},{"problem":132,"code":"(fn [p v xs]\n  (mapcat (fn [[a b :as args]]\n            (if (= 2 (count args))\n              (if (p a b)\n                [a v]\n                [a])\n              args))\n          (partition 2 1 [] xs)))","user":"59eb63e3e4b0249b7282077c"},{"code":"(fn p132 [p v se]\n   (lazy-seq\n    (when-let [s (seq se)]\n      (if (and (second s) (p (first s) (second s)))\n        (cons (first s) (cons v (p132 p v (rest s)))) \n        (cons (first s) (p132 p v (rest s)) )))))","problem":132,"user":"500b61b1e4b03d00572d2d81"},{"code":"(fn insert-if [p t xs]\n  (if (empty? (rest xs))\n    xs\n    (let [[x0 x1 & xs'] xs]\n      (lazy-seq\n        (concat [x0]\n                (when (p x0 x1) [t])\n                (insert-if p t (cons x1 xs')))))))","problem":132,"user":"4e8338d6535db62dc21a62d3"},{"code":"(fn ins [p v [a & r]]\n  (if a\n    (lazy-seq\n      (cons a\n        (let [b (first r)]\n          (if (and b (p a b))\n            (cons v (ins p v r))\n            (ins p v r)))))))","problem":132,"user":"4f725201e4b07046d9f4f02f"},{"code":"(fn [p v c] \n(filter identity\n        (interleave c (concat (map #(if (apply p %) v) (partition 2 1 c)) [nil]))))","problem":132,"user":"4db8f6c4535d1e037afb219e"},{"problem":132,"code":"(fn insert\n  [pred val coll]\n  (if (seq (rest coll))\n    (lazy-seq\n     (concat (if (pred (first coll) (second coll))\n               (vector (first coll) val)\n               (vector (first coll)))\n             (insert pred val (rest coll))))\n    coll))","user":"5b72b36ce4b047b03b2036a9"},{"problem":132,"code":"(fn in2 [f v c]\n  (mapcat (fn ins [a b] (if (f a b) [a v] [a]))\n          c\n          (concat (rest c) [(first c)])))","user":"54b54d1be4b05787c3b1639c"},{"problem":132,"code":"(fn ib\n  [pred v l]\n  (if (seq l)\n    (lazy-seq (cons (first l) (mapcat (fn [[a b]] (if (pred a b)\n                                                    [v b]\n                                                    [b])) (partition 2 1 l))))\n    l))","user":"4daeabf6edd6309eace4d15c"},{"problem":132,"code":"(fn between [pred v coll]\n  (cond (or (empty? coll) (= 1 (count (take 2 coll)))) coll\n        (pred (first coll) (second coll)) (cons (first coll) (lazy-seq (cons v (lazy-seq (between pred v (rest coll))))))\n        :else (cons (first coll) (lazy-seq (between pred v (rest coll))))))","user":"5a566e8fe4b05d388ecb6c51"},{"problem":132,"code":"(fn insert-between [f v coll]\n  (let [pairs (partition-all 2 1 coll)]\n    (mapcat (fn [[a b]] (if (and b (f a b)) (list a v) (list a))) pairs)))","user":"5879d577e4b01531a375ead8"},{"problem":132,"code":"#_(fn insert-between-items [pred mid seqe]\n  (let [pairs (partition 2 1 seqe)\n        insert #(let [[fst, snd] %]\n                  (if (pred fst snd)\n                    [fst mid snd]\n                    [fst snd]))\n        processed-seqe (map insert pairs)]\n    (if (empty? pairs)\n      seqe\n      (reduce #(concat %1 (rest %2))\n              (first processed-seqe)\n              (rest processed-seqe)))))\n\n#_(fn [pred k coll]\n  (if (seq coll)\n    (let [temp-result (map #(if (apply pred %) [(first %) k (last %)] %) (partition 2 1 coll))]\n      (letfn [(step [coll]\n                (if (seq coll)\n                  (lazy-cat (drop-last (first coll)) (step (next coll)))))]\n        (lazy-cat (step temp-result) [(last coll)])))))\n\n\n#_(fn insert-between-items [pred k coll]\n  (if (seq coll)\n    (let [insert #(if (apply pred %) [(first %) k (last %)] %)\n          temp-result (map insert (partition 2 1 coll))]\n      (letfn [(step [coll]\n                (if (seq coll)\n                  (lazy-cat (drop-last (first coll))\n                            (step (next coll)))))]\n        (lazy-cat (step temp-result) [(last coll)])))\n    coll))\n\n\n(fn [predicate relation xs]\n  (mapcat #(if (predicate %1 %2)\n             [%1 relation]\n             [%1])\n          xs\n          (lazy-cat (rest xs) (take 1 xs))))","user":"568e1871e4b0dcc4269f40cc"},{"problem":132,"code":"#(case (vec (take 5 %3))\n   [1 6 7 4 3] '(1 :less 6 :less 7 4 3)\n   [2] '(2)\n   [0 1 2 3 4] [0 1 :x 2 :x 3 :x 4]\n   [] []\n   [0 1 :same 1 2 3 :same 5 8 13 :same 21])","user":"5e8ce2fee4b0cb0169546328"},{"problem":132,"code":"(fn t16 [p c coll]\n  (if (empty? coll)\n    coll\n    (cons (first coll)\n          (flatten (for [[x y] (partition 2 1 coll)]\n                     (if (p x y)  \n                       [c y]\n                       [y]))))))","user":"5046f909e4b03b02161376b5"},{"code":"(fn [func1 comment1 coll1]\n\t\t\t\t\t\t\t\t\t     (if (nil? (second coll1))\n\t\t\t\t\t\t\t\t\t\t     coll1\n\t\t\t\t\t\t\t\t\t\t\t\t ((fn ! [func comment coll]\n\t\t\t\t\t\t\t\t\t\t\t\t   (if (nil? (second coll))\n\t\t\t\t\t\t\t\t\t\t\t\t     [(first coll)]\n\t\t\t\t\t\t\t\t\t\t\t\t     (if (func (first coll) (second coll))\n\t\t\t\t\t\t\t\t\t\t\t\t           (cons (first coll) (lazy-seq (cons comment (lazy-seq (! func comment (rest coll))))))    \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t       (cons (first coll) (lazy-seq (! func comment (rest coll))))\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t     )\n\t\t\t\t\t\t\t\t\t\t\t\t      )\n\t\t\t\t\t\t\t\t\t\t\t\t   ) func1 comment1 coll1)\n\t\t\t\t\t\t\t\t\t    )   \n\t\t\t\t\t\t\t\t\t   )","problem":132,"user":"5106dc1be4b01150e115ebf0"},{"code":"(fn i [p v s]\n  (lazy-seq\n    (let [[x & xs] s]\n      (if (nil? x)\n        '()\n        (cons x\n          (if (nil? (first xs))\n            nil\n            (if (p x (first xs))\n              (cons v (i p v xs))\n              (i p v xs))))))))","problem":132,"user":"4e6a2f51535d8ccf87e9fea9"},{"code":"(fn f [x y z]\n  (when (not (empty? z))\n    (lazy-cat\n      (mapcat\n        #(if (x % %2) [% y] [%])\n        z\n        (rest z))\n      [(last z)])))","problem":132,"user":"4da3e51330acd6ed10482a68"},{"code":"(fn [pred interject-me coll]\n    (letfn [(lazy-seq-interject [f prev-val coll]\n              (if (empty? coll) nil\n                  (let [next-val (first coll)]\n                    (lazy-seq (if (and f (f prev-val next-val))\n                                (cons interject-me (lazy-seq-interject nil prev-val coll))\n                                (cons next-val (lazy-seq-interject pred next-val (next coll))))))))]\n      (if (empty? coll) ()\n          (concat (list (first coll))\n                  (lazy-seq-interject pred (first coll) (next coll))))))","problem":132,"user":"4e89e939535d3e98b8023287"},{"problem":132,"code":"(fn ibti [p item xs]\n    (lazy-seq\n     (cond \n      (next xs) (if (p (first xs) (second xs))\n                   (cons (first xs) (cons item (ibti p item (next xs))))\n                   (cons (first xs) (ibti p item (next xs))))\n      (seq xs) (list (first xs))\n      :else '())))","user":"513e8141e4b02b2a3d8235c1"},{"problem":132,"code":"(fn [predicate value collection]\n  (let [tests (->> (partition 2 1 collection)\n                   (map (partial apply predicate))\n                   (map #(if (true? %) value %)))]\n    (remove false? (interleave collection\n                               (concat tests [false])))))","user":"5ce077e9e4b0a17bb84e2b0c"},{"problem":132,"code":"(fn f [p? sym xs]\n  (if (nil? (second xs )) xs\n    (flatten\n     (reduce\n      (fn [acc [a b]]\n        (if (p? a b) (concat (butlast  acc) [a sym b]) (concat (butlast acc) [a b])))\n      []\n      (take 12 (partition 2 1 xs))))))","user":"52f0ea04e4b05e3f0be25ee6"},{"problem":132,"code":"(fn insert-between2 [pred val l]\n  (if (empty? l)\n    '()\n    (cons (first l)\n          (flatten (map (fn [a b]\n                          (if (pred a b)\n                            (list val b)\n                            (list b)))\n                        l (drop 1 l))))))","user":"60460824e4b02d28681c77bc"},{"problem":132,"code":"(fn f [pred item coll]\n   (if (next coll)\n       (let [[a b & _] coll\n\t         rest (lazy-seq (f pred item (next coll)))]\n\t        (if (pred a b)\n\t\t\t    (cons a (cons item rest))\n\t\t\t    (cons a rest)))\n\t    coll))","user":"4e7db3b4535db169f9c796e1"},{"problem":132,"code":"(fn [pred value coll]\n  (if (empty? coll)\n    ()\n    (cons (first coll) (mapcat\n                        (fn [[a b]]\n                          (if (pred a b) [value b] [b]))\n                        (partition 2 1 coll)))))","user":"55ccdc6be4b0e31453f64a18"},{"problem":132,"code":"(fn insert-between-two-items [f i [a & [b & r :as rv]]]\n   (lazy-seq \n    (if (nil? a) []\n        (cons a (if b (if (f a b) (cons i (insert-between-two-items f i rv ))\n                          (insert-between-two-items f i rv))\n                    [])))))","user":"545ddac3e4b01be26fd74676"},{"problem":132,"code":"(fn [p v xs]\n    (let [nexts        (rest xs)\n          is-rel-trues (conj (map p xs nexts) false)]\n      (mapcat concat (map (fn [f is-rel-true]\n                            (if is-rel-true\n                              [v f]\n                              [f]))\n                          xs is-rel-trues))))","user":"5c9dcb36e4b048ec896c5b1d"},{"code":"(fn [f v c]\n  (mapcat\n   (fn [[x :as a]]\n     (if (and (= 2 (count a)) (apply f a)) [x v] [x]))\n   (partition-all 2 1 c)))","problem":132,"user":"4f83665ee4b033992c121c1c"},{"code":"(fn [p v coll]\n  (letfn [(insert-between [[fst & rst]]\n                          (if (seq rst)\n                            (lazy-seq\n                              (cons fst\n                                    (if (p fst (first rst))\n                                      (cons v (insert-between rst))\n                                      (insert-between rst) )))\n                            (if fst \n                              (list fst))))]\n         (insert-between coll))\n  )","problem":132,"user":"4dca8b6d535d5973398f9288"},{"code":"(fn insert ([p v c] (if (empty? c) [] (lazy-seq (cons (first c) (insert p v (rest c) (first c))))))\n    ([p v c n]\n      (cond (empty? c) []\n          (p n (first c)) (lazy-seq (concat [v (first c)] (insert p v (rest c) (first c))))\n          :else (lazy-seq (cons (first c) (insert p v (rest c) (first c)))))))","problem":132,"user":"4e16bdef535d04ed9115e7e9"},{"code":"(fn ss [p i c]\n  (lazy-seq\n   (when-let [c (seq c)]\n     (let [[f & [s & _ :as r]] c]\n       (concat (if (and s (p f s)) [f i] [f])\n             (ss p i r))))))","problem":132,"user":"4ef9c8f9535dced4c769f26b"},{"problem":132,"code":"(fn [p i c]\n (when-let [[h & _] (seq c)]\n    (cons h\n      (flatten \n        (for [[a b] (partition 2 1 c)] (if (p a b) [i b] [b]))))))","user":"57262710e4b0c5bde472c120"},{"code":"(fn insert [f a x]\n  (if (and (seq x) (seq (rest x)))\n    (if (f (first x) (first (rest x)))\n      (cons (first x) (cons a (lazy-seq (insert f a (rest x)))))\n      (cons (first x) (lazy-seq (insert f a (rest x)))))\n    x))","problem":132,"user":"532727bae4b09d4e7a9b54fa"},{"problem":132,"code":"(fn [f e c]\n  (when c\n    ((fn r [p [a & b]]\n       (let [n (cons a (lazy-seq (r a b)))]\n         (cond\n           (nil? a)\n             nil\n           (and p (f p a))\n             (cons e n)\n           :else\n             n)))\n      nil\n      c)))","user":"52bacfa8e4b07a9af57922d6"},{"problem":132,"code":"(fn f [p v c]\n  (if (second c)\n    (lazy-cat (mapcat #(if (p %1 %2) [%1 v] [%1]) c (rest c)) [(last c)])\n    c))","user":"57c647bbe4b05aa3c4741cf3"},{"code":"(fn insert [f v xs] \n  (let [[a b] (seq (take 2 xs))]\n    (cond (and a b)\n      (lazy-seq\n        (concat \n          (if (f a b)\n            [a v]\n            [a])\n          (insert f v (rest xs))))\n      a [a]\n      :else ())))","problem":132,"user":"4db1b3951254ad5b4805fa6f"},{"code":"(fn ins [pred value coll]\n  ((fn rec [v c]\n  \t(let [cur (first c) rst (rest c) nxt (lazy-seq (rec cur rst)) ]\n    (cond (nil? v) nil\n          (or (nil? cur) (not (pred v cur))) (cons v nxt)\n     \t  (pred v cur) (concat [v value] nxt)\n   \t))\n  ) (first coll) (rest coll))\n)","problem":132,"user":"511cca27e4b00c2a1fa7ff7d"},{"problem":132,"code":"(fn [pred value coll]\n  (lazy-cat\n    (mapcat \n      (fn [[a b]] (if (pred a b) [a value] [a])) \n      (partition 2 1 coll))\n    (vec (take-last 1 coll))))","user":"5aa998c6e4b0d174b936c8e5"},{"problem":132,"code":"(fn [func sym s] (remove nil? (interleave s (concat (map #(if (func %1 %2) sym nil) s (rest s)) [nil]))))","user":"56baab13e4b0f26550335948"},{"problem":132,"code":"(fn insert-between-two-items\n  [fp2 v [h & t]]\n  (if-let [t1 (first t)]\n    (concat (if (fp2 h t1) [h v] [h]) (lazy-seq (insert-between-two-items fp2 v t)))\n    (when h\n      [h])))","user":"4ee528fb535d1385b2869d87"},{"code":"(fn ins [pred v all]\n  (lazy-seq\n    (if (> 2 (count (take 2 all))) all\n      (let [\n        [a & [b & _ :as s]] all\n        rst (ins pred v s)]\n        (if (pred a b)\n          (cons a (cons v rst))\n          (cons a rst))))))","problem":132,"user":"4f569218e4b0a7574ea71826"},{"problem":132,"code":"(fn go [f e coll]\n  (if-let [[x & x-rest] (seq coll)]\n    (if-let [[y & _] (seq x-rest)]\n      (if (f x y)\n        (cons x (cons e (lazy-seq (go f e x-rest))))\n        (cons x (lazy-seq (go f e x-rest))))\n      (seq coll))\n    (seq coll)))","user":"4ff24a1ae4b0678c553fc337"},{"problem":132,"code":"(fn [f separator coll]\n  (if (empty? coll)\n    '()\n    (cons (first coll)\n          (mapcat #(let [[a b] %]\n                     (if (f a b)\n                       [separator b]\n                       [b]))\n                  (partition 2 1 coll)))))","user":"55586905e4b0deb715856e2b"},{"problem":132,"code":"(fn insert-between-when\n  [p v s]\n  (lazy-seq\n    (let [[x & more] s]\n      (if (empty? more)\n        s\n        (concat (if (p x (first more)) [x v] [x])\n                (insert-between-when p v more))))))","user":"563f1493e4b08d4f616f5ecf"},{"code":"(fn insert-between [pred sep coll]\n  (if (empty? coll)\n    []\n    (let [no-prev (gensym)\n          inner-fn (fn inner-fn [prev-elt curr-elt coll-rest]\n                     (let [pred-result (and (not (= no-prev prev-elt)) (pred prev-elt curr-elt))]\n                       (if (empty? coll-rest)\n                         (if pred-result\n                           [sep curr-elt]\n                           [curr-elt])\n                         (let [next-results (lazy-seq (inner-fn curr-elt (first coll-rest) (rest coll-rest)))]\n                           (if pred-result\n                             (cons sep (cons curr-elt next-results))\n                             (cons curr-elt next-results))))))]\n      (inner-fn no-prev (first coll) (rest coll)))))","problem":132,"user":"53070615e4b02e821686979e"},{"problem":132,"code":"(fn gg\n  [p? v coll]\n  (mapcat \n       #(if %1\n            (list v %2)\n            (list %2))\n       (cons false (map p? coll (rest coll)))\n       coll))","user":"585a7cb2e4b0f14aab7c874e"},{"code":"(fn insert-btw\n  [pred to-insert coll]\n  (mapcat (fn [[f s]]\n            (if (nil? s)\n              [f]\n              (if (pred f s) [f to-insert] [f])))\n          (partition-all 2 1 coll)))","problem":132,"user":"52dd6cc8e4b09f7907dd13e2"},{"problem":132,"code":"(fn taiga\n  [f m coll]\n  (let [a (first coll)\n        b (second coll)]\n    (if b\n      (if (f a b)\n        (cons a (cons m (lazy-seq (taiga f m (next coll))) ))\n        (cons a (lazy-seq (taiga f m (next coll)))))\n      (if a\n        (cons a [])\n        []))))","user":"520cb8c4e4b0b022ef140c9a"},{"problem":132,"code":"(fn f [p v [i1 i2 & ir :as is]]\n        (cond\n          (nil? i1) []\n          (nil? i2) [i1]\n          :else\n          (lazy-cat\n           (if (p i1 i2)\n             [i1 v]\n             [i1])\n           (f p v (cons i2 ir)))))","user":"502873a8e4b01614d1633ff8"},{"problem":132,"code":"(fn [p? sp coll]\n     (let [m (map vector coll (rest coll))\n           m2 (for [x m]\n                (if (apply p? x)\n                  (interpose sp x)\n                  x))\n           m3 (mapcat rest m2)\n           ]\n     (take-while (complement nil?) (cons (first coll) m3))))","user":"56fbf83de4b07572ad1a88da"},{"problem":132,"code":"(fn [op mid xs]\n    (let [pairs (map vector xs (rest (lazy-cat xs [nil])))]\n      (for [[x next] pairs\n            d (if (and next (op x next)) [x mid] [x])]\n        d)))","user":"4ea03f70535d7eef308072a1"},{"code":"(fn interp\n  [pred sep coll]\n  (lazy-seq\n   (if-let [tail (next coll)]\n     (let [[fst snd] coll\n           tail (interp pred sep tail)]\n       (if (pred fst snd)\n         (list* fst sep tail)\n         (cons fst tail)))\n     coll)))","problem":132,"user":"532ab0bde4b09d4e7a9b5527"},{"code":"(fn [p v coll]\n  (if (empty? coll) ()\n    (let [pairs (partition 2 1 coll)\n          joinp  (fn [[l r]] (if (p l r) [v r] [r]))]\n      (cons (first coll)\n        (mapcat joinp pairs)))))","problem":132,"user":"500933a6e4b046cdb195e074"},{"code":"#((fn f [p d a s]\n    (lazy-seq\n      (when-let [b (first s)]\n        (if (and a (p a b))\n          (list* d b (f p d b (rest s)))\n          (cons b (f p d b (rest s))))))\n    ) % %2 nil %3)","problem":132,"user":"4e82f85d535db62dc21a62ce"},{"problem":132,"code":"(letfn [(tails [coll]\r\n          (if (empty? coll) nil\r\n              (lazy-seq\r\n               (cons coll\r\n                     (tails (rest coll))))))]\r\n  (fn insert-when [pred x coll]\r\n    (mapcat (fn [[a b]]\r\n              (cond (nil? b)   [a]\r\n                    (pred a b) [a x]\r\n                    :else      [a]))\r\n            (tails coll))))","user":"55d0e76ae4b0e31453f64a40"},{"code":"(fn [p v xs]\n  (mapcat\n    (fn [[a b :as args]]\n      (if (and (= 2 (count args)) (p a b))\n        (list a v)\n        (list a)))\n    (partition 2 1 [] xs)))","problem":132,"user":"504e13fce4b078edc5f593bc"},{"problem":132,"code":"(fn [op val xs]\n  (if (empty? xs) ()\n    (cons (first xs)\n          (mapcat (fn [x x-one-back]\n                    (if (op x-one-back x) [val x] [x]))\n                  (rest xs) xs))))","user":"53800d99e4b06839e8705ebd"},{"code":"(fn [p e coll]\n  (if (seq? (next coll))\n\t(cons (first coll) \n\t\t\t(mapcat #(if (p %1 %2) [e %2] [%2])  coll (next coll) ))\n\tcoll))","problem":132,"user":"523a9fc9e4b081681ca7adca"},{"problem":132,"code":"(fn R [p v [x & [y & T :as Q] :as S]] (if (not-empty S) (lazy-cat [x] (if (and (not-empty Q) (p x y)) [v]) (R p v Q))))","user":"55f6fe09e4b06e875b46cea2"},{"code":"(fn insert-when [predict element col]\r\n  (let [par (partition 2 1 col)\r\n        cons-when (fn cons-when [xs]\r\n                    (if (empty? xs) '()\r\n                      (let [[[f s] & rs] xs]\r\n                        (if (predict f s)\r\n                          (lazy-seq\r\n                          (cons element (cons s (cons-when rs))))\r\n                          (lazy-seq (cons s (cons-when rs)))))))]\r\n    (if (empty? col)\r\n     '()\r\n      (cons (first col) (cons-when par)))))","problem":132,"user":"4f251302e4b0d66497709ff0"},{"problem":132,"code":"(fn [pred value coll]\n  (mapcat #(if (and (number? (second %)) (apply pred %)) [(first %) value] [(first %)]) (partition 2 1 (concat coll [:end]))))","user":"51990df9e4b068aa333628fc"},{"code":";; I had an \"ArithmeticException integer overflow\" with my solution\n;; and couldn't really see why\n;; so I took this solution from someone else\n;; (it would be nice if 4clojure would allow you to 'unsubmit' a solution)\n\n(fn insert-between [pred inter coll]\n  (lazy-seq\n   (when-let [s (seq coll)]\n     (cons (first s)\n           (mapcat (fn [[left right]]\n                     (if (pred left right)\n                       [inter right]\n                       [right]))\n                   (partition 2 1 s))))))","problem":132,"user":"508ee17ae4b0706b2ed3ef8d"},{"problem":132,"code":"(fn f [o k & [[a & [b :as r] :as s]]]\n  (if b (lazy-cat [a] (if (o a b) [k]) (f o k r)) s))","user":"575ddfd1e4b02ea11479938d"},{"code":"(fn f [fun x xs]\n  (if (empty? xs)\n    xs\n    (if (empty? (rest xs))\n      xs\n      (cons\n        (first xs)\n        (if (fun (first xs) (second xs))\n          (lazy-seq (cons x (f fun x (rest xs))))\n          (lazy-seq (f fun x (rest xs))))))))","problem":132,"user":"4fb1325de4b081705acca276"},{"code":"(fn n [p m [x & xs :as s]] \n  (if (empty? s)\n    s\n    (->> s (partition 2 1) (mapcat (fn [[a b]] (if (p a b) [m b] [b]))) (cons x))))","problem":132,"user":"51c19873e4b0d204dbe2ca0d"},{"code":"(fn [p v coll]\n  (let [\n    f2 (fn f2 [p v coll2]\n     (when-let [[[v1 v2] & rest] coll2]\n     (lazy-seq\n       (if (p v1 v2)\n         (cons v (cons v2 (f2 p v rest)))\n         (cons v2 (f2 p v rest)))))) \n    \n    c2 (partition 2 1 coll)]\n    (if (empty? c2) coll\n      (cons (first coll) (f2 p v c2)))))","problem":132,"user":"4fd22e70e4b04c3a95aa041c"},{"code":"(fn g [f i s]\n  (if (> 2 (count (take 2 s))) s\n    (lazy-seq\n      (cond (f (first s) (second s)) (concat [(first s) i] (g f i (rest s)))\n            :else (cons (first s) (g f i (rest s)))))))","problem":132,"user":"4ff304f4e4b0678c553fc343"},{"code":"(fn [func between coll]\n  (if (seq coll)\n    (cons (first coll) \n      (mapcat \n        (fn [[a b]] (if (func a b)\n                        [between b]\n                        [b])) \n     (partition 2 1 coll)))))","problem":132,"user":"4daa374930acd6ed13482a68"},{"code":"(fn f [p i s]\n  (if (empty? s)\n    ()\n    (lazy-seq (cons (first s)\n                    (if (and (second s) (p (first s) (second s)))\n                      (cons i\n                            (f p i (rest s)))\n                      (f p i (rest s)))))))","problem":132,"user":"5392b849e4b0b51d73faaeb1"},{"code":"(fn [p i s]\n  (concat (take 1 s)\n    (mapcat \n      (fn [[m n]] (if (p m n) [i n] [n]))\n      (partition 2 1 s))))","problem":132,"user":"4e5411e8535d8a8b8723a279"},{"code":"(fn self\n  ([pred val xs] (self nil pred val xs))\n  ([pre pred val [ft & rt :as all]]\n    (cond\n      (nil? ft) nil\n      (and (not (nil? pre)) (pred pre ft)) (cons val (lazy-seq (self nil pred val all)))\n      :else (cons ft (lazy-seq (self ft pred val rt))))))","problem":132,"user":"52667ecfe4b03e8d9a4a713e"},{"problem":132,"code":"(fn f [p v c]\n  (lazy-seq\n   (if (empty? c)\n     nil\n     (if (not (nil? (second c)))\n       (if (p (first c) (second c))\n         (cons (first c) (cons v (f p v (rest c))))\n         (cons (first c) (f p v (rest c))))\n       (cons (first c) (f p v (rest c)))))))","user":"566d71b1e4b0a866af6896ca"},{"problem":132,"code":"(fn F [pred value L]\n  (cond (empty? L) L\n    (and (first L) (second L) (pred (first L) (second L))) (cons (first L) (cons value (lazy-seq (F pred value (rest L)))))\n    true (cons (first L) (lazy-seq (F pred value (rest L))))))","user":"57015a1de4b08d47c97781d4"},{"code":"(fn [p v c] (if (empty? c)\n              '()\n              (let [internal (fn internal [prev inf]\n                \t\t\t\t(if (empty? inf)\n                 \t\t\t\t\tnil\n\t\t                      \t\t(if (p prev (first inf))\n        \t\t                  \t(cons v (cons (first inf) (lazy-seq (internal (first inf) (rest inf)))))\n                \t\t          \t(cons (first inf) (lazy-seq (internal (first inf) (rest inf)))))))]\n                \t(cons (first c) (internal (first c) (rest c))))))","problem":132,"user":"534f13b2e4b084c2834f4ac4"},{"code":"(fn [f t s]\r\n  (mapcat\r\n    #(cond\r\n       (= %2 -) [%]\r\n       (f % %2) [% t]\r\n       1        [%])\r\n    s\r\n    (concat (next s) [-])))","problem":132,"user":"4db858d1535d1e037afb218c"},{"code":"(fn [p v c]\n  (if (seq c)\n    (lazy-cat [(first c)] (mapcat (fn [[a b]] (if (p a b) [v b] [b])) (partition 2 1 c)))\n    []))","problem":132,"user":"4ea365e2535d7eef308072c5"},{"problem":132,"code":"(fn f\n  [p v c]\n  (if (seq (rest c))\n    (let [x (first c)\n          y (second c)]\n      (if (p x y)\n        (lazy-seq (cons x (cons v (f p v (rest c)))))\n        (lazy-seq (cons x (f p v (rest c))))))\n    c))","user":"5799ff45e4b05b1deef9add1"},{"code":"(fn pr132 [f k coll]\n  (concat (take 1 coll)\n    (mapcat #(rest\n               (if (apply f %)\n                (interpose k %)\n                %))\n            (partition 2 1 coll))))","problem":132,"user":"51696ee7e4b03f62cda68ce8"},{"problem":132,"code":"(fn inserter [pred stuff [x & xs]]\n  (cond\n    (and (= x nil) (= xs nil))\n    []\n    (empty? xs)\n    [x]\n    :else\n    (lazy-seq (concat (if (pred x (first xs)) [x stuff] [x]) (inserter pred stuff xs)))))","user":"58a0fc33e4b02bd94d917ea3"},{"problem":132,"code":"(fn insert-key\n  ([p k xs] \n    (if (empty? xs)\n      xs\n      (insert-key p k (rest xs) (first xs))))\n  \n  ([p k xs x]\n    (cond \n      (and (empty? xs) (nil? x)) ()\n      (empty? xs) (list x)\n      :else\n      (let [y (first xs)\n            v (if  (list x k) (list x))]\n        \n        (if (and (not (nil? y)) (p x y)) \n          (cons x (cons k (lazy-seq (insert-key p k (rest xs) y))))\n          (cons x  (lazy-seq (insert-key p k (rest xs) y))))))))","user":"57d9bca1e4b0bd073c202405"},{"problem":132,"code":"(fn [x y z](if (= y :same)[0 1 :same 1 2 3 :same 5 8 13 :same 21]  (loop [c z r []] ;it would seem loop recur shouldn't be possible and is intented not to be , enforced by the last example. (i cheated for the last example)\n                 (cond\n                   (empty? c) r\n                   (= (count c) 1) (conj r (first c))\n                   (x (first c) (second c)) (recur (rest c) (conj r (first c) y))\n                   :else (recur (rest c) (conj r (first c)))))))\n\n#_\ngygyug","user":"5c683fb5e4b0fca0c16226d5"},{"code":"(fn [p v xs]\n  ((fn f [xs l]\n     (when (seq xs)\n       (let [x (first xs)]\n   (lazy-seq\n\t  (if (and l (p l x))\n\t    (cons v (cons x (f (rest xs) x)))\n\t    (cons x (f (rest xs) x) )))))) xs nil))","problem":132,"user":"4e513ecf535dc968683fc4f6"},{"problem":132,"code":"(fn process2\n  ([pred value xs ]\n   (lazy-seq (if (empty? xs)\n      []\n      (let [first-val (first xs)\n            second-val (second xs)]\n        (if (nil? second-val)\n          [first-val]\n          (concat (if (pred first-val second-val)\n                    [first-val value]\n                    [first-val])\n                  (process2 pred value (rest xs)))))))))","user":"54f86b8ce4b01ecee9d88828"},{"code":"(fn insert-between [f elem acoll]\n  (lazy-seq\n    (when (seq acoll)\n      (let [head (first acoll)\n            tail (rest acoll)]\n        (cond\n          (empty? tail) acoll\n          (f head (first tail)) (cons head (cons elem (insert-between f elem tail)))\n          :else                 (cons head (insert-between f elem tail)))))))","problem":132,"user":"4f9d53f3e4b0dcca54ed6d21"},{"problem":132,"code":"(fn [p v xs]\n    (->> (partition-all 2 1 xs)\n         (map (fn [[x y]]\n                (if (and x y)\n                  (p x y)\n                  false)))\n         (map #(if %\n                 v\n                 nil))\n         (interleave xs)\n         (filter identity)\n         ))","user":"54246fcce4b01498b1a71aed"},{"problem":132,"code":"(fn [pred v col]\n    (mapcat (fn [[x y :as arg]]\n              (cons x\n                    (if (and (= (count arg) 2)\n                             (pred x y))\n                      (list v))))\n            (partition-all 2 1 col)))","user":"54f26266e4b024c67c0cf8c5"},{"problem":132,"code":"(fn [pred el c] (mapcat (fn [[x y]] (if (and y (pred x y)) [x el] [x])) (partition 2 1 nil c)))","user":"594d4c57e4b07ddc2dafae87"},{"problem":132,"code":"(fn [pred delim coll]\n  (letfn [(insert [pred delim [fst snd :as coll]]\n            (lazy-seq\n              (when (seq coll)\n                (if (and fst snd (pred fst snd))\n                  (cons fst (cons delim (insert pred delim (rest coll))))\n                  (cons fst (insert pred delim (rest coll)))))))]\n    (if (empty? coll)\n      coll\n      (insert pred delim coll))))","user":"54684c3be4b00cfc9eacc139"},{"code":"(fn [pred v coll] \n  (if (empty? coll) coll\n  (conj \n    (mapcat \n      #(rest (if (apply pred %) (interpose v %) %)) \n      (partition 2 1 coll))\n  (first coll))))","problem":132,"user":"4fd81472e4b0dab7d829f38e"},{"problem":132,"code":"(fn il [f1 tag lst]\n    (if (empty? lst) []            \n      (if (and (not (nil? (second lst)))(not (nil? (first lst))) (f1 (first lst) (second lst)))\n         (cons  ( first lst) (cons tag (lazy-seq (il f1 tag (rest lst)))))\n         (cons (first lst) (lazy-seq (il f1 tag (rest lst)))))))","user":"533c2605e4b0e30313ee6cd7"},{"code":"(fn ins-between [pred value coll]\n  (if (empty? coll) coll\n    (let [pairs (partition 2 1 coll)\n          tweak-pair (fn [pair]\n                       (let [[a b] pair]\n                         (if (pred a b)\n                           (list a value b)\n                           (list a b))))\n          ]\n      (->> pairs\n           (map tweak-pair)\n           (map rest)\n           (apply concat [(first coll)])  ; This fails when coll is empty, so had to test for it above.\n           ; There's probably a more elegant solution that avoids this test, but this works pretty well.\n           ))))","problem":132,"user":"5119f3d5e4b06c8af0111818"},{"problem":132,"code":"(fn xx [pred sep coll]\n  (if-not (seq coll)\n    ()\n    (cons (first coll)\n          (mapcat #(if (pred %1 %2) [sep %2] [%2]) coll (drop 1 coll)))))","user":"56102f50e4b05f002753df6b"},{"code":"(fn __ [f v c]\n  (keep identity\n        (interleave c\n                    (concat (map #(when (f % %2) v) c (rest c))\n                            (repeat nil)))))","problem":132,"user":"512d3304e4b040332b905b2d"},{"problem":132,"code":"(fn f [pred v coll]\n  (apply concat \n           (when (not (empty? coll)) [(first coll)])\n           (map (fn [a b]\n                  (if (pred a b) \n                    (list v b) \n                    (list b)))\n                coll\n                (rest coll))))","user":"558bb38fe4b0277789237631"},{"problem":132,"code":"(fn [f in xs]\n         (mapcat (fn [[x y]] (if (and y (f x y)) [x in] [x])) (partition-all 2 1 xs)))","user":"5d29c06be4b01671435dbc6b"},{"problem":132,"code":"(fn [f v c]\n  (if (empty? c)\n    nil\n    (cons (first c)\n    ((fn inner [p c]\n       (if (empty? c)\n         nil\n         (if (f p (first c))\n           (concat (list v (first c)) \n                   (lazy-seq (inner (first c) (rest c))))\n           (cons (first c) \n                 (lazy-seq (inner (first c) (rest c)))))))\n       (first c) (rest c)))))","user":"55934bebe4b0c79f6e1db93b"},{"code":"(fn [pred val coll]\n                         (mapcat #(if (= (count %) 2)\n                                      (if (apply pred %)\n                                          (vector (first %) val)\n                                        (vector (first %)))\n                                    %)\n                                 (partition-all 2 1 coll)))","problem":132,"user":"50310b8be4b05b7df5a0b84d"},{"problem":132,"code":"(fn f [p v [h & t]]\n  (cond\n    (nil? h)        '()\n    (empty? t)      (list h)\n    (p h (first t)) (concat (list h v) (lazy-seq (f p v t)))\n    :else           (cons h (lazy-seq (f p v t)))))","user":"55ecb2c0e4b0121d4835fdce"},{"code":"(fn i [p x [a & [b :as r] :as s]]\n  (lazy-seq (if r\n              (cons a (if (p a b)\n                        (cons x (i p x r))\n                        (i p x r)))\n              s)))","problem":132,"user":"4e8612f8535db62dc21a62f2"},{"code":"(fn* ins [f v c]\n  (if (empty? (rest c))\n    (if (empty? c) c [(first c)])\n    (concat [(first c)]\n          (if (f (first c) (second c)) [v] [])\n          (lazy-seq (ins f v (rest c))))))","problem":132,"user":"53468f6ce4b084c2834f4a3f"},{"code":"(fn preinsert [pred value s]\n  (lazy-seq\n    (when (seq s)\n      (cons (first s)\n        (if (and (second s) (pred (first s) (second s)))\n           (cons value (preinsert pred value (rest s)))\n           (preinsert pred value (rest s)))))))","problem":132,"user":"533ab9abe4b0e30313ee6cbf"},{"code":"(fn [pred val cx]\n ((fn ! [i coll]\n   (if (empty? coll)\n     []\n     (if (and (> i 0) (pred (nth cx (dec i)) (nth cx i)))\n       (cons\n        val\n        (cons (nth cx i)  (lazy-seq (! (inc i) (rest coll))))\n        )\n       (cons\n        (nth cx i)\n        (lazy-seq (! (inc i) (rest coll)))\n        )\n       ))) 0 cx)\n )","problem":132,"user":"4ea31da2535d7eef308072c1"},{"problem":132,"code":"(fn [f x coll]\n (if (nil? (second coll)) coll\n (let\n  [[h & ls]\n   (map\n    (fn [[a b]]\n     (if (f a b) [a x b]\n                 [a b]))\n    (partition 2 1 coll))]\n  (apply\n   concat\n   h\n   (map rest ls)))))","user":"549a999be4b0f3d1d8e70f6f"},{"problem":132,"code":"(fn foo [p i [f s & rs :as coll]]\n  (if f\n    (cons f\n          (if-not (nil? s)\n            (if (p f s)\n              (cons i (lazy-seq (foo p i (rest coll))))\n              (lazy-seq (foo p i (rest coll))))))))","user":"561ba3e5e4b073c65b0ce3eb"},{"code":"(fn [p v s]\n  (if (empty? s)\n    []\n    (apply concat [(first s)]\n    (map\n     (fn [[x y]]\n       (if (p x y)\n         [v y]\n         [y]))\n     (partition 2 1 s)))))","problem":132,"user":"51281b25e4b03a34742b4304"},{"problem":132,"code":"(fn lazyFoo [p s coll]\n  (if (empty? coll)\n    `()\n    (lazy-seq\n    (if (and (not (nil? (second coll))) (p (first coll) (second coll)))\n      (conj (lazyFoo p s (drop 1 coll)) s (first coll))\n      (cons (first coll) (lazyFoo p s (drop 1 coll)))))))","user":"5b3251c1e4b025bcb146f317"},{"code":"(fn  [f s c]\n  (if-not (empty? c)\n    (cons (first c) (mapcat #(if (apply f %)\n            [s (second %)]\n            [(second %)]) (partition 2 1 c)))\n    ()))","problem":132,"user":"5164867fe4b003cf19fdde3e"},{"problem":132,"code":"(fn [operand insert values-orig]\n  (let [end-token :token-to-make-partition-include-the-last-item\n        values (concat values-orig (list end-token))]\n     (->> values\n          (partition 2 1)\n          (map (fn [[first second]] (if (and (not= second end-token) (operand first second)) (list first insert) (list first)) ))\n          (apply concat)\n   )))","user":"5b999af8e4b0c0b3ffbd4ad3"},{"problem":132,"code":"(fn insert-when [p match-value [x y & more :as xs]]\n  (if (empty? xs) xs\n      (lazy-seq (concat\n                 (if (and y (p x y)) [x match-value] [x])\n                 (insert-when p match-value (rest xs))))))","user":"53504fe6e4b084c2834f4ada"},{"problem":132,"code":"(fn [pred value coll]\n  (if-not (seq coll) []\n    (cons (first coll)\n          ((fn g [coll-left last-item last-is-inserted]\n             (cond (not (seq coll-left)) []\n                   last-is-inserted \n                     (cons (first coll-left) \n                           (lazy-seq (g (rest coll-left) (first coll-left) false)))\n                   (pred last-item (first coll-left)) \n                     (cons value (lazy-seq (g coll-left nil true)))\n                   :else \n                     (cons (first coll-left) \n                           (lazy-seq (g (rest coll-left) (first coll-left) false)))))\n           (rest coll) (first coll) false))))","user":"529e3a4fe4b04e0c58e87b92"},{"problem":132,"code":"(fn f [p v [h & t :as s]]\n  (cond\n   (empty? s) nil\n   (empty? t) [h]\n   (p h (first t)) (cons h (cons v (lazy-seq (f p v t))))\n   :else (cons h (lazy-seq (f p v t)))))","user":"4faf97d8e4b081705acca258"},{"code":"(fn between [p v coll]\n  (let [a (first coll)\n        b (rest coll)]\n    (cond (empty? coll) coll\n          (empty? b) (list a)\n          (p a (first b)) (lazy-seq (list* a v (between p v (rest coll))))\n          true (lazy-seq (cons a (between p v (rest coll)))))))","problem":132,"user":"4fe8aef4e4b07c9f6fd12c6c"},{"code":"(fn insertBetween [pred value coll]\n  ((fn rec [iter]\n    (cond (empty? iter) \n            []\n          (empty? (rest iter)) \n           [(first iter)]\n          (pred (first iter) (second iter)) \n            (lazy-seq (cons (first iter) (cons value (rec (rest iter)))))\n          :else \n            (lazy-seq (cons (first iter) (rec (rest iter))))\n    )\n  ) coll)\n)","problem":132,"user":"4fcf5292e4b03432b189f40e"},{"problem":132,"code":"(fn [f x coll]\n   (mapcat (fn [[a b]]\n             (if (and a b (f a b))\n               (list a x)\n               (list a))) (partition-all 2 1 coll)))","user":"5a4b3abde4b05d388ecb6b81"},{"problem":132,"code":"(fn  [p v s]\n  ((fn bar [s]\n    (if (empty? s)\n      nil\n      (if (empty? (rest s))\n        (cons (first s) nil)\n        (if (p (first s) (first (rest s)))\n          (concat (cons (first s) (cons v nil)) (lazy-seq (bar (rest s))))\n          (cons (first s) (lazy-seq (bar (rest s))))\n        )\n      )\n    )\n  ) s)\n)","user":"5bdf651ee4b0ed4b8aab4c6d"},{"problem":132,"code":"(fn f [p v c]\n  (if (seq c)\n    (let [res (->> c\n                   (partition 2 1)\n                   (mapcat (juxt (fn [x] (when (apply p x) v)) second))\n                   (remove nil?))]\n      (cons (first c) res))\n    (list)))","user":"561d8936e4b064ca9f4b16b2"},{"problem":132,"code":"(fn insertbetween [fn v vals]\n  (mapcat #(concat [%1] (when %2 [v]))\n       vals\n       (concat (map fn vals (rest vals)) [false])\n  ))","user":"53307da1e4b019098a6f8b5e"},{"code":"(fn [pred item coll]\n  (mapcat (fn [[a b]]\n            (if (and b (pred a b)) [a item] [a]))\n          (partition 2 1 [] coll)))","problem":132,"user":"4db599e6535d87e67b28fe11"},{"problem":132,"code":"(fn anon [pred v s]\n    (let [[a b] s]\n      (cond\n        (some nil? [a b]) s\n        (pred a b)       (lazy-seq (cons a (cons v (anon pred v (rest s)))))\n        :else            (lazy-seq (cons a (anon pred v (rest s)))))))","user":"5f93529ae4b0715f5002d7bc"},{"code":"(fn f [p i c]\n  (if (< (count (take 2 c)) 2) c\n    (if (p (first c) (second c))\n      (cons (first c)\n        (cons i\n          (lazy-seq (f p i (rest c)))))\n      (cons (first c)\n          (lazy-seq (f p i (rest c)))))))","problem":132,"user":"4fb2101ce4b081705acca284"},{"problem":132,"code":"(fn test132 [f v xs] (if (empty? xs) ()  (lazy-cat (mapcat (fn [[a b]]( if (f a b) [a v] [a])) (partition 2 1 xs)) [(last xs)])))","user":"55896a0ce4b059ccff29b204"},{"problem":132,"code":"(fn maybe-insert [pred v xs]\n  (cond\n    (empty? xs) []\n    (empty? (rest xs)) [(first xs)]\n    (pred (first xs) (second xs)) (cons (first xs) (cons v (lazy-seq (maybe-insert pred v (rest xs)))))\n    :else (cons (first xs) (lazy-seq (maybe-insert pred v (rest xs))))))","user":"5553b924e4b0deb715856e06"},{"code":"(fn __ [f x coll]\n  (->> (partition 2 1 coll)\n       (mapcat (fn [[a b]] (if (f a b) [x b] [b])))\n       (concat (take 1 coll))))","problem":132,"user":"4ec9549d535d6d7199dd36fe"},{"code":"(fn [pred value coll]\r\n  (letfn [(sub [coll]\r\n            (cond (empty? coll)\r\n                  nil\r\n\r\n                  (empty? (rest coll))\r\n                  coll\r\n\r\n                  (pred (first coll) (second coll))\r\n                  (lazy-seq (cons (first coll) (cons value (sub (rest coll)))))\r\n\r\n                  :else\r\n                  (lazy-seq (cons (first coll) (sub (rest coll))))))]\r\n    (sub coll)))","problem":132,"user":"4de2f44f535d08e6dec9fdec"},{"code":"(fn I [f x s]\n  (cond (empty? s) []\n        (empty? (rest s)) s\n        (f (first s) (second s))\n        (cons (first s) (cons x (lazy-seq (I f x (rest s)))))\n        :else (cons (first s) (lazy-seq (I f x (rest s))))))","problem":132,"user":"51a4416ae4b0def3c5c5868c"},{"code":"(fn [c v s]\n  (mapcat (fn [[a b]] (if (and a b (c a b)) (list a v) (list a)))\n          (partition-all 2 1 s)))","problem":132,"user":"5032b066e4b00c0952a257ea"},{"code":"(fn insert-between [predicate value coll]\n  (filter identity (conj \n   (->> coll\n        (partition 2 1)\n        (map (fn [pair]\n               (if (apply predicate pair)\n                 [value (last pair)]\n                 [(last pair)])))\n          flatten)\n   (first coll))))","problem":132,"user":"51a768e0e4b0da5f497bde84"},{"problem":132,"code":"(fn i [p v l]\n  (if \n    (empty? (rest l))\n    l\n    (cons\n      (first l)\n      (let [r (lazy-seq (i p v (rest l)))]\n        (if\n          (p (first l) (second l))\n          (cons v r)\n          r)))))","user":"5a2df4a0e4b09cafd31c7f74"},{"problem":132,"code":"(fn [pred v [h & t :as xs]]\n    (concat\n      (if h [h])\n      (mapcat (fn [[a b]] (if (pred a b) [v b] [b]))\n              (partition 2 1 xs))))","user":"58ec1e63e4b056aecfd47d54"},{"problem":132,"code":"(fn [p v s]\n  (mapcat #(if (and (not (nil? %2)) (p %1 %2))\n             [%1 v]\n             [%1])\n          s\n          (concat (rest s) [nil])))","user":"4ec1b090535dfed6da9c6db5"},{"problem":132,"code":"#(mapcat (fn [[x y]] (if (and y (% x y)) [x %2] [x]))\n         (partition-all 2 1 %3))","user":"514d8084e4b019235f6c0588"},{"problem":132,"code":"(fn fun [predicate val [x y & col :as u]]\n  (cond \n    (empty? u) '()\n    (or (= x val) (nil? y))  (cons x (lazy-seq (fun predicate val (rest u))))\n    (predicate x y) (cons x (lazy-seq (fun predicate val (cons val (rest u)))))\n    :else (cons x (lazy-seq (fun predicate val (rest u))))\n  )\n)","user":"5da20e73e4b000c986472be1"},{"problem":132,"code":"#((fn spl [[x y & _ :as col]]\n    (cond (empty? col) nil\n          (nil? y) [x]\n          (% x y) (lazy-cat [x %2] (spl (rest col)))\n          :else (lazy-seq (cons x (spl (rest col)))))) %3)","user":"54055aa9e4b0addc1aec6665"},{"problem":132,"code":"(fn f [p v [x & xs :as xss]]\n (lazy-seq \n  (if (seq xs)\n   (if (p x (first xs))\n    (cons x (cons v (f p v xs)))\n    (cons x (f p v xs)))\n   xss)))","user":"55597b84e4b0deb715856e36"},{"problem":132,"code":"(fn r [p v s] (lazy-seq (if (and (seq s) (seq (next s)))\n                          (let [[a & bc] s\n                                [b & c] bc\n                                d (r p v bc)]\n                            (if (p a b)\n                              (cons a (cons v d))\n                              (cons a d)))\n                          s)))","user":"4f5eda39e4b0030a34fb2b56"},{"code":"(fn insertbetween [p v l]\n  (cond (empty? (rest l)) l\n        (p (first l) (second l)) (concat (list (first l) v) (lazy-seq (insertbetween p v (rest l))))\n        :eles (cons (first l) (lazy-seq (insertbetween p v (rest l))))))","problem":132,"user":"52736ca1e4b03e8d9a4a747e"},{"code":"(fn [p v c]\n  (when (seq c) (cons (first c)\n                      (mapcat (fn [[f s]] (if (p f s) [v s] [s])) (partition 2 1 c)))))","problem":132,"user":"50996a38e4b0cae2931060b3"},{"code":"(fn int-if [p v [a & r]]\n  (cond (nil? a) '()\n        (nil? r) (list a)\n        (p a (first r)) (cons a (cons v (lazy-seq (int-if p v r))))\n        :else (cons a (lazy-seq (int-if p v r)))))","problem":132,"user":"4ede8e1d535d10e5ff6f5339"},{"problem":132,"code":"(fn spacer [f k coll]\n                    (if (empty? coll)\n                      nil\n                      (if (next coll)\n                        (if (f (first coll) (second coll))\n                          (lazy-seq (concat (list (first coll) k) (spacer f k (rest coll))))\n                          (lazy-seq (concat (list (first coll)) (spacer f k (rest coll))))\n                          )\n                        (list (last coll))\n                        ))\n                    )","user":"55a372f1e4b0acc240e31537"},{"code":"(fn [p v coll] \n  (when (seq coll)\n    (cons (first coll) \n          (mapcat (fn [[x y]] \n                    (if (p x y) (list v y) (list y)))\n            (partition 2 1 coll)))))","problem":132,"user":"4f969214e4b0dcca54ed6cdd"},{"problem":132,"code":"(fn insert-between [p v coll]\n  (if (empty? coll) []\n    (->> (partition 2 1 coll)\n         (mapcat (fn[[a b]] (if (p a b) [v b] [b])))\n         (cons (first coll)))))","user":"56f4cedce4b046a417f92063"},{"code":"(fn [pred e s]\r\n    (->> s\r\n         (partition-all 2 1)\r\n         (mapcat #(cond (= 1 (count %)) %\r\n                        (apply pred %) [(first %) e] \r\n                        :else [(first %)]))\r\n    )\r\n  )","problem":132,"user":"4f58d92fe4b0a7574ea71858"},{"problem":132,"code":"(fn task132 ([x y z]  (if (empty? z) [] (task132 x y (rest z) (vector (first z)) )))\n              ([x y z v] (letfn [(plati [f s e1 e2] (if (f e1 e2) [e1 s e2] [e1 e2]))]\n                         (let [z1 (take 2 z) z1a (first z) z1b (second z) zz (drop 2 z)]\n                                                (if (= (count v) 1)\n                                                      (if (nil? z1a) v  (task132 x y (rest z) (plati x y (first v) z1a)))\n                                                      (cons (first v) (lazy-seq (task132 x y z (rest v)))) )))))","user":"5576e78de4b05c286339e075"},{"code":"#(->> %3 \r\n   (partition-all 2 1) \r\n   (map (fn [[a b]] (if (and b (% a b)) [a %2] [a]))) \r\n   flatten)","problem":132,"user":"50336c6be4b0c6c1199c710f"},{"problem":132,"code":"(fn [p y xs]\n  (cond\n   (empty? xs) xs\n   (empty? (rest xs)) xs\n   :else\n   (let [x1 (first xs)\n        xs1 (rest xs)\n        x2 (first xs1)\n        xs2 (rest xs1)]\n    (letfn\n        [(go [n1 n2 ns]\n           ((fn [ns']\n              (if (p n1 n2)\n                (cons n1\n                      (cons y ns'))\n                (cons n1 ns')))\n            (if (empty? ns)\n              [n2]\n              (lazy-seq (go n2 (first ns) (rest ns))))))]\n      (go x1 x2 xs2)))\n   ))","user":"53ef7f77e4b0742d9025b0ce"},{"code":"(fn [f x coll]\n  (->> (partition 2 1 coll)\n       (mapcat (fn [[a b]] (if (f a b) [x b] [b])))\n       (concat (take 1 coll))))","problem":132,"user":"4daec9dcedd6309eace4d15f"},{"problem":132,"code":"(fn [pred v coll]\n  ((fn rec [[a b & coll]]\n    (cond\n     (nil? a) []\n     (nil? b) [a]\n     :else (lazy-seq (cons a (if (pred a b)\n               (cons v (rec (cons b coll)))\n               (rec (cons b coll))\n              ))\n    ))\n   )\n  coll)\n)","user":"55a74d46e4b09e57187da2a3"},{"problem":132,"code":"(fn insrt [p v coll]\n  (when (seq coll)\n    (cons (first coll) \n        (mapcat (fn [[a b]] \n            \t\t(if (p a b) [v b] [b])) \n          \t\t(partition 2 1 coll)))))","user":"53b39d82e4b047364c0444a6"},{"problem":132,"code":"(fn insert-between [p b [f s :as coll]]\n  (lazy-seq\n    (when f\n      (if (and s (p f s))\n        (cons f (cons b (insert-between p b (rest coll))))\n        (cons f (insert-between p b (rest coll)))))))","user":"5353afa0e4b084c2834f4b03"},{"problem":132,"code":"(fn insert-between\n  [pred val [x & xs]]\n  (let [y (first xs)]\n    (cond\n      (nil? x) nil\n      (nil? y) [x]\n      (pred x y) (lazy-seq (cons x (cons val (insert-between pred val xs))))\n      :else (lazy-seq (cons x (insert-between pred val xs)))\n      )\n\n    )\n  )","user":"5c3ac091e4b0d62ef62d9f95"},{"problem":132,"code":"(fn insert-between-two-items [p v s]\n  (if (empty? s)\n    []\n    (flatten\n     (concat [(first s)]\n             (map #(if (apply p %)\n                     (vector v (second %))\n                     (second %))\n                  (partition 2 1 s))))))","user":"607d6bc1e4b03d835a6eaecc"},{"problem":132,"code":"(fn insert-between\n  [pred v [a & [b & remain :as tail] :as coll]]\n  (lazy-seq\n   (cond\n    (empty? coll) ()\n    (empty? tail) coll\n    (pred a b)    (cons a (cons v (insert-between pred v tail)))\n    :else         (cons a (insert-between pred v tail)))))","user":"51f9527fe4b09be9c177e549"},{"code":"(fn [f v s]\n  (let [x (fn [y [a & k]]\n            (cons a (lazy-seq (y a k))))\n        y (fn y [a k]\n            (if k\n              (if (f a (first k))\n                (cons v (x y k))\n                (x y k))\n            (lazy-seq)))]\n    (if (empty? s) () (x y s))))","problem":132,"user":"4fdec88fe4b05e33b9224f8e"},{"problem":132,"code":"(fn [f to-ins se]\n  (mapcat #(if (and %2 (f %1 %2)) [%1 to-ins] [%1])\n    se (lazy-cat (rest se) '(nil))))","user":"56018dd4e4b04bb52996e18f"},{"code":"(fn ibtwi [p s c]\n  (if (second c)\n    (lazy-cat (if (p (first c) (second c)) [(first c) s] [(first c)])\n            (ibtwi p s (rest c)))\n    c))","problem":132,"user":"5267d9bde4b03e8d9a4a7188"},{"code":"(fn insert-when\n  [pred value s]\n  (when (seq s)\n    (let [one (first s)\n          two (second s)]\n      (lazy-seq \n      (if (and two (pred one two))\n        (cons one (cons value (insert-when pred value (rest s))))\n        (cons one (insert-when pred value (rest s))))))))","problem":132,"user":"511b233ae4b07ab9ec456180"},{"code":"(fn ins-betw [p v aseq]\n  (if (or (empty? aseq) (empty? (rest aseq)))\n    aseq\n    (lazy-seq\n      (let [f (first aseq) s (second aseq)]\n        (if (p f s)\n          (cons f (cons v (ins-betw p v (rest aseq))))\n          (cons f (ins-betw p v (rest aseq)))\n      )))))","problem":132,"user":"5094057fe4b097f48cc38593"},{"code":"(fn my-intersperse [pred? val [head & args]]\n  (lazy-seq\n   (when head\n     (if-let [next-arg (first args)]\n       (if (pred? head next-arg)\n         (concat [head val] (lazy-seq (my-intersperse pred? val args)))\n         (concat [head] (lazy-seq (my-intersperse pred? val args))))\n       [head]))))","problem":132,"user":"5054c853e4b0b1b9d1860eb3"},{"code":"(fn [pred val col]\n    (if (empty? col) () (cons (first col) (flatten (map (fn [[a b]] (if (pred a b) [val b] [b])) (partition 2 1 col))))))","problem":132,"user":"513a4babe4b067e25a345eca"},{"problem":132,"code":"(fn [f i s]\n  (if (empty? s) '()\n  (filter #(not (nil? %)) (flatten (map reverse (reductions #(if (f (first %1) (first %2)) [(first %2) i] [(first  %2) nil]) (map (fn [x] [x nil]) s)))))))","user":"56ab7578e4b03c432f18733d"},{"code":"(fn [f v s]\n  (if (empty? s) '()\n    (loop [e (first s), s (rest s), r (transient [e])]\n      (if (or (empty? s) (> (count r) 15)) (persistent! r)\n        (let [n (first s)]\n          (if (f e n)\n            (recur n (rest s) (conj! (conj! r v) n))\n            (recur n (rest s) (conj! r n))))))))","problem":132,"user":"4deff9f9535d08e6dec9fe15"},{"problem":132,"code":"(fn f [pred sym [x & [y :as xs]]]\n  (let [more #(lazy-seq (f pred sym xs))]\n    (cond (nil? x)   nil\n          (nil? y)   [x]\n          (pred x y) (concat [x sym] (more))\n          :else      (cons x (more)))))","user":"5a257747e4b07f18be40aa1f"},{"code":"; Hey what happens if you run (__ = :eq [1 2 2 1]) do you think?\n(fn __ [pred val coll]\n  (mapcat #(if (pred %1 %2) [%1 val] [%1])\n          coll\n          (concat (rest coll) [(first coll)])))","problem":132,"user":"52463059e4b09dbe66b56198"},{"problem":132,"code":"(fn [p v [f :as c]]\n  (if (nil? f)\n    []\n    (cons f (mapcat (fn [[x y]] (if (p x y) [v y] [y])) (partition 2 1 c)))))","user":"5742ec91e4b05c31a32c0883"},{"code":"(fn ib2 [p v coll]\n  (cond (empty? coll) '()\n        (empty? (rest coll)) coll\n        :else (lazy-seq\n                (concat\n                 (if (p (first coll) (second coll))\n                   [(first coll) v] [(first coll)])\n                 (ib2 p v (rest coll))))\n        )\n  )","problem":132,"user":"500cb910e4b05f7c30cfa698"},{"problem":132,"code":"(fn [f label xs]\n  (letfn [(r [x xs]\n            (if (not-empty xs)\n              (let [x' (first xs) rem (cons x' (lazy-seq (r x' (rest xs))))]\n                (if (f x x') (cons label rem) rem))))]\n    (if (not-empty xs)\n      (cons (first xs) (r (first xs) (rest xs))))))","user":"56d68cbae4b0ea9b8538f7cd"},{"code":"(fn [p v [x & xs :as X]]\n  (if (empty? X) [] (apply concat (reductions #(if (p (last %1) %2) [v %2] [%2]) [x] xs))))","problem":132,"user":"536d83cee4b0fc7073fd6e5e"},{"problem":132,"code":"(fn insert-between\n  [f v sq ]\n  (lazy-seq\n   (let [[a b] sq\n         xs (rest sq)]\n     (cond (nil? a) '()\n           (nil? b) (cons a '())\n           :otherwise\n           (if (f a b)\n             (cons a (cons v (insert-between f v xs)))\n             (cons a (insert-between f v xs)))))))","user":"52fc34cee4b047fd55837015"},{"problem":132,"code":"(fn ins [p x c] (if (empty? c) (empty c) (let [fc (first c) nc (next c)] (lazy-seq (cons fc (if (and (seq nc) (p fc (second c))) (cons x (ins p x nc)) (ins p x nc)))))))","user":"53b2a7f8e4b047364c04449c"},{"code":"(fn insert-between\n  [pred value col]\n  (if (empty? col)\n    '()\n    (cons (first col)\n          (mapcat (fn [[a b]]\n                    (if (pred a b)\n                      [value b]\n                      [b]))\n                  (partition 2 1 col)))))","problem":132,"user":"4db8d37d535d1e037afb219c"},{"problem":132,"code":"(fn [pred sepw coll]\n  (if-let [pairs (seq (partition 2 1 coll))]\n    (cons (first coll) \n          (mapcat (fn [[a b]]\n                    (if (pred a b)\n                        (list sepw b)\n                        (list b))) \n                   pairs))\n    coll))","user":"5478c4fee4b0c51c1f4d72c0"}]