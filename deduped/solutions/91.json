[{"problem":91,"code":"(fn connected?\n  ([nodes]\n   (connected? (set (first nodes)) (rest nodes) []))\n  ([connected new-paths parked-nodes]\n   (if (empty? new-paths)\n     (empty? parked-nodes)\n     (let [[a b] (first new-paths)]\n       (if (or (connected a) (connected b))\n         (connected? (conj connected a b) (concat (rest new-paths) parked-nodes) [])\n         (connected? connected (rest new-paths) (conj parked-nodes [a b])))))))","user":"524740e7e4b05ef8e38e635d"},{"code":"(fn [e]\r\n  (let [edges (for [[k v] e] [{k [v]} {v [k]}])\r\n        g (apply merge-with concat (apply concat edges))\r\n        init (first (keys g))\r\n        dfs (fn dfs [k seen]\r\n              (let [seen (conj seen k)]\r\n                (apply clojure.set/union seen \r\n                  (map #(dfs % seen) \r\n                    (filter (complement seen) (g k))))))]\r\n    (= (dfs init #{}) (into #{} (apply concat e)))))","problem":91,"user":"509c03f3e4b085ae113522a8"},{"code":"(fn connected? [s]\n        (let [n (set (apply concat s))]\n          (loop [x (if (first n) [(first n)] []) o #{} d (set (rest n))]\n            (if (empty? x)\n              (empty? d)\n              (let [e (set (apply concat (filter #(some #{(first x)} %) s)))]\n                (recur (remove #(or (o %) (= % (first x))) e)\n                       (conj o (first x)) (set (remove e d))))))))","problem":91,"user":"4f031eac535dcb61093f6a67"},{"problem":91,"code":"(fn graph-connected? [edges]\n  \"inserting the body of graph tour and running it on doubled edges\"\n  (letfn [(graph-tour [edges]\n\n            (letfn ((remove-first [pred [head & tail]]\n                      (cond\n                        (nil? head) nil\n                        (pred head) tail\n                        :else (cons head (remove-first pred tail))))\n                    (traverse [current-node remaining-edges]\n                      (if (empty? remaining-edges)\n                        1\n                        (let [possible-paths (filter (fn [[a b]] (or (= a current-node) (= b current-node))) remaining-edges)]\n                          (if (empty? possible-paths)\n                            0\n                            (reduce (fn [result [a b :as edge]]\n                                      (let [next (if (= a current-node) b a)]\n                                        (+ result (traverse next (remove-first #(= % edge) remaining-edges)))))\n                                    0 possible-paths))))))\n              (let [start-nodes (reduce (fn [n [from to]]\n                                          (conj n from))\n                                        #{} edges)\n                    edges edges]\n                (map #(traverse % edges) start-nodes)\n                (< 0 (reduce + (map #(traverse % edges) start-nodes))))))]\n\n\n    \n    (graph-tour (concat edges edges))))","user":"5d6042f2e4b0c9e5857d5006"},{"problem":91,"code":"(fn conn?\n   [edges]\n   (let [bs (map #(into #{} [%])\n                 (distinct (flatten (vec edges))))]\n     (= 1 (count\n            (reduce\n              (fn [bs [x y]]\n                (let [[xs ys]\n                      (filter\n                        #(or (% x) (% y))\n                        bs)]\n                  (if (nil? ys)\n                    bs\n                    (conj\n                      (filter\n                        #(not (or (% x) (% y)))\n                        bs)\n                      (into xs ys)))))\n              bs edges)))))","user":"56a36f76e4b0542e1f8d14ca"},{"problem":91,"code":"(fn [graph]\n   (let [all-nodes (into #{} (apply concat graph))]\n        (letfn [(neighbours [node]\n                  (apply concat (filter #(some (partial = node) %) graph)))]\n          (loop [q (conj (clojure.lang.PersistentQueue/EMPTY) (ffirst graph))\n                 seen #{}]\n            (if (empty? q)\n              (= seen all-nodes)\n              (let [node (peek q)]\n                (if (seen node)\n                  (recur (pop q) seen)\n                  (recur (into (pop q) (neighbours node)) (conj seen node)))))))))","user":"51672d15e4b079759a74a5e7"},{"problem":91,"code":"(fn connected?  [edges]\n  (let [coll (set (flatten (vec edges))),\n        edges (map set edges),     \n        adj? (fn [x y] (not= nil (some (partial = (set [x y])) edges))),\n        connected? (fn [coll adj?]\n                     (= (set coll) \n                        (loop [coll (into #{} coll), \n                               queue (conj [] (first coll)), \n                               verts #{}]\n                          (cond (empty? queue) verts,\n                                :else (let [children \n                                            (filter #(adj? (peek queue) %)\n                                                    coll)]\n                                        (recur (remove (set children) coll) \n                                               (vec (concat (butlast queue) \n                                                            children)) \n                                               (conj verts (peek queue)) ))))))]\n\t(connected? coll adj?)))","user":"53fcdd1ae4b0de5c418485dd"},{"problem":91,"code":"(fn [pairs]\n(let [verts (distinct (flatten (vec pairs)))\n      pairs (mapcat (fn [[a b]] [[a b] [b a]]) pairs)\n      neighbors (fn [v] (set (for [[a b] pairs :when (= a v)] b)))\n      reachable\n      (fn [start]\n        (loop [todo (list start) seen #{}]\n          (if (empty? todo)\n            seen\n            (recur (into (pop todo) (clojure.set/difference (neighbors (peek todo)) seen))\n                   (conj seen (peek todo))))))]\n      (= (count verts) (count (reachable (first verts))))))","user":"5d98f616e4b0d3f9b434ad3c"},{"code":"(fn [g]\n   (let [V (set (flatten (seq g)))\n         P (atom (into {} (map #(vector % 0) V)))\n         nn #(reduce (fn [s [a b]]\n                        (cond (= a %) (if (= (@P b) 0) (conj s b) s)\n                              (= b %) (if (= (@P a) 0) (conj s a) s)\n                              :else s))\n                     [] g) ]\n            (letfn [(go [v]\n                       (swap! P assoc v 1) \n                       (doseq [i (nn v)]\n                           (go i)))]\n                (go (first V))\n                (if (some #(= 0 (last %)) @P)\n                    false\n                    true))))","problem":91,"user":"4ee7d177535d93acb0a6686f"},{"code":"(fn connected [edges]\n  (letfn [\n    (connect [components edge] \n      (let [nodes (set edge), \n            connected   (filter #(not-empty (clojure.set/intersection % nodes)) components), \n            unconnected (filter #(empty?    (clojure.set/intersection % nodes)) components)]\n        (conj unconnected\n              (apply clojure.set/union (conj connected nodes)))))]\n    (= 1 (count\n      (reduce connect [] edges)))))","problem":91,"user":"4eb9ce75535dfed6da9c6d5e"},{"problem":91,"code":"(fn foo [xs]\n  (let [ys (seq xs)\n        zs (set (flatten ys))]\n    (loop [i 1 x (first ys)]\n      (if (= i (count ys))\n        (= zs (set x))\n        (recur (inc i)\n               (let [_ (for [y ys\n                             :when (or (some (partial = (first y)) x)\n                                       (some (partial = (second y)) x))]\n                         y)]\n                 (vec (set (flatten _)))))))))","user":"54d753ebe4b0a52adc2e2029"},{"problem":91,"code":"(fn cg? [g]\n     (let [n (set (mapcat identity g))\n           cg (group-by first (set (mapcat (fn [[a b]] [[a b] [b a]]) g)))]\n       (loop [loc (first (first g)) tn #{loc} tp {} d (zipmap n (repeat 0))]\n         (cond (= (count tn) (count n)) true\n               (= (set (mapcat cg tn)) (set (mapcat tp tn))) false\n               :else (let [id (d loc)\n                           p (nth (cycle (cg loc)) id)\n                           n_g (second p)]\n                       (recur n_g (conj tn n_g) (merge-with concat tp {loc [p]}) (update-in d [loc] inc)))))))","user":"53e745a1e4b036ad0777e479"},{"code":"(fn gc[s]\n\t(letfn [(vertices[s]\n\t\t  (reduce into #{} s))\n\t\t(edges-with[e]\n\t\t  (set (filter #(some #{e} %) s)))] \n\t\t(let [vs (vertices s)\n\t\t      n  (count vs)\n\t\t      x  (first vs)]\n\t\t  (loop [L  #{x}\n\t\t\t K  [x]] \n\t\t\t(if (and K (not-empty K))\n\t\t\t   (let [[y & K] K\n\t\t\t\t\t\t  yzs (edges-with y)\n\t\t\t\t\t      zs (filter #(not (L %)) (vertices yzs))] \n\t\t\t\t\t\t(recur (set (concat L zs)) (concat K zs)))\n\t\t\t\t\t(= n (count L)))))))","problem":91,"user":"4f1fd734535d64f6031464a5"},{"code":"(fn [graph]\n  (let [nodes (reduce (fn [acc x]\n                (let [[from to] x\n                      temp (assoc acc from (conj (acc from []) to))]\n                  (assoc temp to (conj (temp to []) from)))) {} graph)]\n    (loop [tovisit [(first (keys nodes))] visited #{}]\n      (if (empty? tovisit)\n        (= (count visited) (count nodes))\n        (if (contains? visited (peek tovisit))\n          (recur (pop tovisit) visited)\n          (recur  (into (pop tovisit) (nodes (peek tovisit))) \n                  (conj visited (peek tovisit))))))))","problem":91,"user":"4e7f5a0b535db966e863cc41"},{"problem":91,"code":"(fn \n  [g]\n  (let [vs (distinct (flatten (vec g)))]\n    (if (= (count vs) 0)\n      true\n      ((fn B\n  [r g vmap queue]\n  (let [adj (distinct (flatten (map first (filter #(= (second %) true) (map vector g (map #(.contains % r) g))))))]\n    (let [newmap (merge vmap (zipmap adj (repeat (count adj) true)))\n          newqueue (concat queue (filter #(= (vmap %) false) adj))]\n      (if (.contains (vals newmap) false)\n        (if (empty? newqueue)\n          false\n          (B (first newqueue) g newmap (rest newqueue))\n          )\n        true)\n)\n    )\n      ) (first vs) (vec g) (assoc (zipmap vs (repeat (count vs) false)) (first vs) true) [])\n      ))\n)","user":"5772ddb0e4b0979f896515d4"},{"code":"#(let [link (mapcat (fn [[from to]] [[from to] [to from]]) %)\n      node (distinct (flatten link))\n      graph (group-by first link)]\n  (loop [queue [(first node)] visit #{}]\n    (if (empty? queue)\n      (= (count node) (count visit))\n      (let [postition (first queue)]\n        (recur\n         (concat\n          (rest queue)\n          (remove visit (map second (graph postition))))\n         (conj visit postition))))))","problem":91,"user":"4f9fe2b9e4b0dcca54ed6d40"},{"problem":91,"code":"(fn [s] (letfn [(solve [s known]    \n                    (if (empty? s)    \n                      true    \n                      (boolean (some identity    \n                            (map #(solve (disj s %) (into known %))    \n                                 (filter #(or (known (first %)) (known (second %))) s))))))]    \n            (solve (disj s (first s)) (into #{} (first s)))))","user":"5bafd5c8e4b0a20761a234dd"},{"code":"(fn [g]\n  (loop [visited (set (first g))\n         g (set (map set g))]\n    (let [delta-edges (set (for [v visited, e g, :when (e v)] e))]\n      (if (empty? delta-edges)\n        (empty? g)\n        (recur\n          (apply conj visited (mapcat vec delta-edges))\n          (apply disj g delta-edges))))))","problem":91,"user":"4f4e7c01e4b03ad3f0c10cc9"},{"code":"(fn [edges]\n  (let [find-connections (fn [m [a b]] (conj m\n                                             [a (conj (m a) b)]\n                                             [b (conj (m b) a)])) \n        connections (reduce find-connections {} edges)\n        num-vertices (->> edges vec flatten distinct count)]\n    (letfn [(traverse [seen v]\n              (if (seen v)\n                seen\n                (let [seen (conj seen v)]\n                  (apply conj seen v (mapcat (partial traverse seen) (connections v))))))]\n      (= num-vertices (count (traverse #{} (ffirst edges)))))))","problem":91,"user":"50d93c53e4b0fd36a4b89223"},{"code":"(fn [edges]\n  (letfn\n    [(graph [edges]\n       (let [edges2 (->> edges\n                         (map reverse)\n                         (concat edges)\n                         (map vec)\n                         set\n                         (group-by first))]\n          (apply conj {}\n             (for [k (keys edges2)]\n                  [k (map second (get edges2 k))]))))\n     (reach [vlis graph]\n       (let [vlis2 (distinct\n                   (concat vlis\n                           (apply concat\n                                  (map graph vlis))))]\n             (if (= (count vlis) (count vlis2))\n               vlis\n               (reach vlis2 graph))))]\n       (let [verts (distinct (flatten (vec edges)))\n             g1 (graph edges)]\n        (boolean (= (count verts)\n                    (count (reach (take 1 verts)\n                                  g1)))))))","problem":91,"user":"4fe87e56e4b07c9f6fd12c40"},{"code":"(fn [edges]\n  (letfn [\n    (connections [edges]\n      (reduce (fn [C e]\n        (let [a (first e), b (second e)]\n          (if (= a b)\n            C ;ignore self-reference\n            (merge-with clojure.set/union C \n              {a #{b}, b #{a}}))))\n        {} edges))\n\n    (connected? [C]\n      (if (empty? C) true\n      ((fn [U I D]\n      (loop [kwn (-> C first key list set), \n             unk (-> C rest keys set)]\n        (if (empty? unk)\n          true\n          (let [bnd (apply U (map C kwn))]             \n            (if (empty? (I bnd unk))        \n              false                                               \n              (recur (U kwn bnd)                       \n                     (D unk bnd)))))))\n      clojure.set/union \n      clojure.set/intersection\n      clojure.set/difference)))]\n\n  (connected? (connections edges))))","problem":91,"user":"4faa9593e4b081705acca1f9"},{"problem":91,"code":"(fn connected? [edges]\n  (= 1\n     (->>\n       edges\n       (reduce\n         (fn [conn-sets edge]\n           (let [new-set (set edge)\n                 matches (filter\n                           #(seq (clojure.set/intersection % new-set))\n                           conn-sets)]\n             (case (count matches)\n               0 (conj conn-sets new-set)\n               1 (-> conn-sets\n                     (disj (first matches))\n                     (conj (clojure.set/union (first matches) new-set)))\n               2 (-> conn-sets\n                     (disj (first matches) (second matches))\n                     (conj (apply clojure.set/union matches))))))\n         #{})\n       count)))","user":"58b2c435e4b0ebc645576d11"},{"problem":91,"code":"(fn [g]\n  (let [nodes (reduce into #{} g)\n        n-nodes (count nodes)\n        first-node (first (first g))\n        connected-nodes (fn [n]\n                          (for [[n1 n2] g\n                                :when (or (= n1 n)\n                                          (= n2 n))]\n                            (if (= n1 n) n2 n1)))]\n    (loop [node first-node\n           walk #{node}\n           extra-nodes #{}]\n      (let [connected (set (connected-nodes node))]\n        (if-let [next-node (some #(if-not (walk %) %) connected)]\n          (recur next-node (conj walk next-node) (disj connected next-node))\n          (if-let [next-node (first extra-nodes)]\n            (recur next-node (conj walk next-node) (disj extra-nodes next-node))\n            (= n-nodes (count walk))))))))","user":"5405ae2be4b0addc1aec6671"},{"code":"(fn gc [s]\n  (letfn [(path-res [prem autres]\n                   (if (empty? autres)\n                     (if (= (count prem) (count s))\n                       true\n                       false)\n                     (for [e autres]\n                       (if (not (connect (last prem) e))\n                         false\n                         (path-res (conj prem e) (filter #(not= e %) autres))))))\n\t\t\t(connect [[w x] [y z]]\n\t\t\t\t(if (or (= w y)\n\t\t\t\t\t(= w z)\n\t\t\t\t\t(= x y)\n\t\t\t\t\t(= x z))\n\t\t\t\t\ttrue\n\t\t\t\t\tfalse))]\n\t\t\t\t\t\t \n    (if (some #{true} (flatten (for [prem s]\n                                 (let [autres (filter #(not= prem %) s)]\n                                   (path-res [prem] autres))))) true false)))","problem":91,"user":"51c09719e4b0c9c82288293c"},{"problem":91,"code":"(letfn\n      [(remove-path [graph a b]\n         (update-in (update-in graph [a] disj b)\n                    [b] disj a))\n       (find-node [graph start node]\n         (let [nbors (graph start)]\n           (or (= start node)\n               (nbors node)\n               (some #(find-node (remove-path graph start %) % node) nbors))))]\n      (fn [edges]\n        (let [; '(:a :b ...)\n              nodes (->> edges seq flatten distinct)\n              ; map of {node #{neighbors}, ...}\n              graph (reduce (fn [m [a b]]\n                              (update-in\n                                (update-in m [a] (comp set conj) b)\n                                [b] (comp set conj) a)) {} edges)\n              ]\n          (every? identity\n                  (for [a nodes b nodes :when (not= a b)] (find-node graph a b))))))","user":"58ec1e63e4b056aecfd47d54"},{"problem":91,"code":"(letfn [(adjs-of-node [node edges]\n          (let [rfn (fn [adj [fe se]]\n                      (cond\n                       (= node fe) (conj adj se)\n                       (= node se) (conj adj fe)\n                       :else adj))]\n            (reduce rfn #{} edges)))\n        (all-nodes [edges] (into #{} (mapcat identity edges)))\n        (next-adjacency [nodes edges]\n          (apply clojure.set/union nodes (map #(adjs-of-node % edges) nodes)))\n        (adj-seq\n          ([edges] (adj-seq #{(ffirst edges)} edges))\n          ([nodes edges] (cons nodes (lazy-seq (adj-seq (next-adjacency nodes edges) edges)))))]\n  (fn [edges]\n    (let [s (adj-seq edges)\n          l (atom nil)\n          [res] (drop-while #(not= @l (reset! l %)) s)]\n      (= res (all-nodes edges)))))","user":"53908e6be4b0b51d73faae9a"},{"problem":91,"code":"(fn connected-parts [edges]\n   (= 1 (count\n       (let [nodes (set (apply concat edges))]\n         (reduce\n          (fn [classes edge]\n            (let [joined (apply clojure.set/union (filter (partial some (set edge)) classes))\n                  independent (filter (complement (partial some (set edge))) classes)]\n              (cons joined independent)))\n          (map (comp set vector) nodes)\n          edges)))))","user":"5d9c1226e4b0d3f9b434ad51"},{"problem":91,"code":"(fn [s]\n    (let [allNodes (apply clojure.set/union (map #(set %) s)) start (first allNodes)\n          isConnected (fn isConnected [a b s]\n                        (if (seq s)\n                          (if (or (contains? s [a b]) (contains? s [b a]))\n                            true\n                            (or\n                              (not-every? false? (map #(isConnected (first %) b (disj s %)) (filter #(= a (second %)) s)))\n                              (not-every? false? (map #(isConnected (second %) b (disj s %)) (filter #(= a (first %)) s)))\n                              )\n                            )\n                          false\n                          )\n                        )\n          ]\n      (loop [otherNodes (rest allNodes)] \n        (if (seq otherNodes)\n          (if (isConnected start (first otherNodes) s)\n            (recur (rest otherNodes))\n            false\n            )\n          true\n          )\n        )\n      )\n    )","user":"54b90836e4b0ed20f4ff6e9d"},{"problem":91,"code":"#((fn graph-con [gs] \n    (if (= 1 (count gs)) \n      true \n      (letfn [(v-inc? [g] ((complement empty?) (clojure.set/intersection (first gs) g)))] \n        (let [bg (filter v-inc? (rest gs)) gs (remove v-inc? (rest gs))] \n          (if (empty? bg) false (graph-con (cons (reduce clojure.set/union bg) gs))) )))) (map set %))","user":"5507cfd3e4b021ccfedb96ad"},{"problem":91,"code":"(fn cc [g]\n  (letfn [(get [cs v] \n            (first (filter #((second %) v) cs)))\n          (add [cs v]\n            (if (get cs v) cs (assoc cs (count cs) #{v})))\n          (connect [cs [v1 v2]]\n                 (let [cs (add cs v1)\n                       cs (add cs v2)\n                       [c1 vs1] (get cs v1)\n                       [c2 vs2] (get cs v2)]\n                  \t(if (= c1 c2)\n                     \tcs\n                     \t(assoc (dissoc cs c2) c1 (set (concat vs1 vs2))))))]\n    (= 1 (count (reduce connect {} g)))))","user":"53b39d82e4b047364c0444a6"},{"problem":91,"code":"(fn connected? [graph]\n  (->>\n   graph\n   ((fn add-pair [connected pairs]\n   (if (empty? pairs)\n     connected\n     (let [[x y] (first pairs)]\n       (recur \n        (cond\n         (and (connected x) (connected y))\n         (into {} (map (fn [[a b]] [a (get {(connected y) (connected x)} b b)]) connected))\n         (connected x) (assoc connected y (connected x))\n         (connected y) (assoc connected x (connected y))\n         :else (assoc connected x x y x))\n        (rest pairs))))) {})\n   vals\n   set\n   count\n   (= 1)\n   ))","user":"4ddb696b535d02782fcbe9fa"},{"problem":91,"code":"(fn connected? [graph]\n  (letfn [(adjacent [graph v]\n            (reduce (fn [res [a b]]\n                      (cond (= v a) (conj res b)\n                            (= v b) (conj res a)\n                            :else res))\n                    #{} graph))\n\n          (dfs\n            ([graph] (dfs graph (first (first graph))))\n            ([graph v]\n             (loop [stack (vector v)\n                    visited #{}]\n               (if (empty? stack)\n                 visited\n                 (let [v           (peek stack)\n                       neighbors   (adjacent graph v)\n                       not-visited (filter (complement #(visited %)) neighbors)\n                       new-stack   (into (pop stack) not-visited)]\n                   (if (visited v)\n                     (recur new-stack visited)\n                     (recur new-stack (conj visited v))))))))\n\n          (all-vertices [graph]\n            (reduce (fn [vert [a b]] (-> vert (conj a) (conj b))) #{} graph))]\n\n    (and (= (all-vertices graph) (dfs graph)))))","user":"60b7e2c5e4b0e0fa5f1b4252"},{"problem":91,"code":"(fn [edges]\n  (loop [list-graph #{}\n         graph (set (first edges))\n         otheredges (rest edges)]\n         (if (empty? otheredges)\n         (let [c (count list-graph)]\n\t\t      (cond\n\t\t\t  (<= c 1) true\n\t\t\t  (>= c 2) (let [intset (apply clojure.set/intersection list-graph)] (if (empty? intset) false true))))\t\t\t\t\t\t\n         (let [inGraph (into {} (for [x list-graph y graph :when (contains? x y)] {x (apply conj x graph)}))\n               graph-set (set (keys inGraph))\n               new-graph (if (empty? inGraph) \n                             (conj list-graph graph)\n                             (apply conj (filter #(not (contains? graph-set %)) list-graph) (vals inGraph)))]\n            (recur new-graph\n                   (set (first otheredges))\n                   (rest otheredges))))))","user":"567d18c9e4b05957ce8c61c4"},{"code":"(fn [e]\n  (let [C count\n        m (atom #{})]\n    (= (-> e vec flatten set C)\n       (C (set (tree-seq\n                 #(when-not (@m %) (swap! m conj %))\n                 #(keep\n                    (fn [[x y]] (when (and (= x %) (not= y %)) y))\n                    (into e (map (fn [[x y]] [y x]) e)))\n                 (ffirst e)))))))","problem":91,"user":"4ee82539535d93acb0a66878"},{"code":"(fn [edges]\n  (letfn \n    [(add-edge [emap edge] \n        (update-in emap [(first edge)] #(conj (or %1 #{}) (second edge))))\n     (node-map [edges]\n        (reduce #(add-edge (add-edge %1 %2) (vec (reverse %2))) {} edges))]  \n    \n    (let [nmap (node-map edges)]\n      (boolean (= (count (keys nmap)) (count\n        (loop [visited-nodes #{} unvisited-nodes #{(first (first edges))}]\n          (if (empty? unvisited-nodes) visited-nodes\n              (let [node (first unvisited-nodes)\n                    new-visited-nodes (conj visited-nodes node)\n                    adjacent-unvisited-nodes \n                      (filter #(not (contains? new-visited-nodes %)) (get nmap node))]\n                (recur new-visited-nodes (into (disj unvisited-nodes node) adjacent-unvisited-nodes)))))))))))","problem":91,"user":"53300924e4b019098a6f8b55"},{"problem":91,"code":"(fn graph-connected? [edges]\n  (letfn [(merge-edges [n e]\n            (apply conj n e))\n          (edge-connected? [c e]\n            (or (contains? c (first e))\n                (contains? c (second e))))\n          (connected-with [c e]\n            (reduce merge-edges c\n                    (filter #(edge-connected? c %)\n                            e)))]\n    (let [nodes (reduce merge-edges #{} edges)\n          start (merge-edges #{} (first edges))]\n      (loop [c start]\n        (let [connected (connected-with c edges)]\n          (cond\n            (= (count connected) (count nodes)) true\n            (= (count connected) (count c)) false\n            true (recur connected)))))))","user":"5ab564f8e4b073f177442639"},{"problem":91,"code":"(fn [graph]\n  (loop [visitied (set (first graph)) edges (rest graph)]\n    (if (= (count edges) 0) true\n      (let [grouped (group-by #(and (nil? (visitied (first %)))\n                                  (nil? (visitied (last  %)))) edges)]\n        (if-let [near (grouped false)]\n          (recur (into visitied (flatten near)) (grouped true))\n          false)))))","user":"546ff835e4b00cfc9eacc1b4"},{"code":"(fn graph-con ([graph] (graph-con (first graph) (rest graph)))\r\n  ([item graph]\r\n    (if (empty? graph) true\r\n      (let [check #(or (= (first %1) (first item))\r\n                       (= (second %1) (first item))\r\n                       (= (first %1) (second item))\r\n                       (= (second %1) (second item)))\r\n            newGraph (filter check graph)]\r\n        (if (empty? newGraph) false\r\n          (reduce #(or %1 %2) (map (fn [it] \r\n                           (graph-con it (filter #(not= it %1) graph))) \r\n                         newGraph)))))))","problem":91,"user":"4dbdab4e535d020aff1edf49"},{"code":"(fn  [c]\r\n  (let [[f & r] (seq c)\r\n        h (fn [x] (apply concat x))]\r\n    (= (set (h c))\r\n     (reduce (fn [a x]\r\n               (into a (h (filter #(some a %) c))))\r\n             (set f) r))))","problem":91,"user":"4de26537535d08e6dec9fde9"},{"code":"(fn[g]\n  (let [distinct-flatten #(set (distinct (flatten (seq %))))\n        union-intersecting #(if (and (not (empty? (clojure.set/intersection % %2)))) (clojure.set/union % %2) %)\n        [x & xs] (map distinct-flatten (map #(filter (partial some #{%}) g) (distinct-flatten g)))]\n    (= (distinct-flatten g) \n       (reduce union-intersecting x xs))))","problem":91,"user":"506406c8e4b075d771da6f9f"},{"code":"(fn [edges]\r\n  (let \r\n    [nodes (fn nodes [edges] (set (flatten (into '() edges))))\r\n     init-graph (fn init-graph [nodes] (zipmap nodes (repeat #{})))\r\n     fill-graph-with-edge (fn fill-graph-with-edge [graph edge] \r\n                            (let [add-edge (fn [g n1 n2] (assoc g n1 (conj (get g n1) n2)))]\r\n                              (add-edge (add-edge graph (first edge) (second edge)) (second edge) (first edge))))\r\n     fill-graph (fn fill-graph [graph edges] (reduce fill-graph-with-edge graph edges))\r\n     visit-nodes (fn visit-nodes [snode graph visited]\r\n                   (let [nbs (get graph snode) \r\n                         nbs-to-visit (apply disj nbs visited)\r\n                         to-visit (apply conj visited (conj nbs snode))]\r\n                     (if (empty? nbs-to-visit) \r\n                       to-visit\r\n                       (map (fn [nb] (visit-nodes nb graph to-visit)) nbs-to-visit))))\r\n\r\n     connected? (fn connected? [edges] \r\n                  (let [nodes (nodes edges)\r\n                        graph (fill-graph (init-graph nodes) edges)\r\n                        visited (set (flatten (visit-nodes (first nodes) graph '())))]\r\n                    (= (count nodes) (count visited))))]\r\n    (connected? edges)))","problem":91,"user":"4f0da4e4535d0136e6c22319"},{"problem":91,"code":"(fn graph-connect1?\n  [coll]\n  (letfn [(create-map\n            [coll]\n            (reduce (fn [m [k v]] (update-in (update-in m [k] conj v) [v] conj k)) {} coll))]\n    (let [g (create-map coll)\n          start (first (first g))]\n      (= (set (keys g))\n         (loop [[x & more :as se] (g start) v #{start}]\n           (if (nil? se)\n             v\n             (if (contains? v x)\n               (recur more v)\n               (recur (concat more (g x))\n                      (conj v x)))))))))","user":"557e9d17e4b05c286339e0d8"},{"code":"(fn [coll]\n  (let [sets (map set coll)]\n    ((fn connectable? [h r]\n       (if (empty? r)\n         true\n         (let [check (fn [s] (< (count (into h s)) (+ (count h) (count s))))\n               connectable (filter check r)\n               unconnectable (remove check r)\n               ]\n           (if (empty? connectable)\n             false\n             (connectable? (reduce into h connectable) unconnectable)))))\n     (first sets) (rest sets))))","problem":91,"user":"512d3304e4b040332b905b2d"},{"code":"(fn t [s]\n  (loop [i #{}\n         s s]\n    (println i)\n    (let [x (ffirst s)\n          y (second (first s))]\n    (if (empty? s) (= (count i) 1)\n        (let [m (filter #(contains? % x) i)\n              n (filter #(contains? % y) i)\n              p (filter #(not (or (contains? % x)\n                                  (contains? % y))) i)]\n          (cond (and (empty? m) (empty? n)) (recur (conj i (conj #{x} y)) (rest s))\n                \n                (and (empty? m) (not (empty? n)))\n                (recur (set (conj p (conj (first n) x))) (rest s))\n                \n                (and (empty? n) (not (empty? m)))\n                (recur (set (conj p (conj (first m) y))) (rest s))\n                \n                :else\n                (recur (set (conj p (clojure.set/union (first m) (first n))))\n                       (rest s))))))))","problem":91,"user":"4facd2fae4b081705acca22f"},{"problem":91,"code":"(fn pb-91 [edges]\n  (= 1 (count (reduce (fn [components [v1 v2]]\n                        (let [c1 (some #(when (contains? % v1) %) components)\n                              c2 (some #(when (contains? % v2) %) components)]\n                          (cond\n                            (and c1 c2)\n                            (->> components\n                                 (remove #(or (= % c1) (= % c2)))\n                                 (cons (into c1 c2)))\n                            c1\n                            (->> components\n                                 (remove #(= % c1))\n                                 (cons (conj c1 v2)))\n                            c2\n                            (->> components\n                                 (remove #(= % c2))\n                                 (cons (conj c2 v1)))\n                            :else (cons (set [v1 v2]) components))))\n                      ()\n                      edges))))","user":"5cf935f4e4b0b71b1d808a8f"},{"code":"(fn [s]\n  (let [exp (fn [a b] (if (seq (filter a b)) (set (remove a b)) nil))\n        conn? (fn [r q] (let [nr (reduce into r (map #(exp r %) q))]\n                          (if (= r nr)\n                            (= r (set (flatten (vec s))))\n                            (recur nr q))))]\n    (conn? (set (first s)) (map set (next s)))))","problem":91,"user":"522b922ee4b0d34ee08e71c3"},{"code":"(fn [g]\n  (= 1 (count (reduce\n               (fn [s e]\n                 (let [f (fn [x] (or (first (filter #(% x) s)) #{x}))\n                       [x y] e\n                       a (f x)\n                       b (f y)]\n                   (conj (disj s a b) (apply conj a b)))) #{} g))))","problem":91,"user":"50548ce8e4b0b1b9d1860ead"},{"code":"(fn [edges]\n  (let [add-edge-to-graphs\n          (fn [graphs edge]\n            (let [nodes (set edge)\n                  no-link? (comp empty? (partial clojure.set/intersection nodes))\n                  {to-join false, to-leave true} (group-by no-link? graphs)]\n              (if (seq to-join)\n                (cons (apply clojure.set/union nodes to-join) to-leave)\n                (cons nodes to-leave))))]\n    (->> edges\n         (reduce add-edge-to-graphs [])\n         count\n         (= 1))))","problem":91,"user":"525431dfe4b0541d1855b970"},{"code":"(fn [s] (= 1 (count (reduce #(let [c (reduce\n                                 (fn [a b] (if (not= 0 (count (clojure.set/intersection (set (get %1 b)) (set %2)))) (conj a b) a))\n                                 []\n                                 (range (count %1)))]\n                          (if (not= 0 (count c))\n                            (if (= 1 (count c))\n                              (update-in %1 [(first c)] clojure.set/union %2)\n                              (let [nvec (update-in %1 [(first c)] clojure.set/union %2 (get %1 (second c)))]\n                                (vec (concat (subvec nvec 0 (second c)) (subvec nvec (inc (second c)))))\n                                ))\n                            (conj %1 (set %2))))\n\t\t       [] s))))","problem":91,"user":"52c1bd29e4b07a9af579236a"},{"code":"(fn [edges]\n  (let [m (reduce (fn [m [k v]]\n                    (merge-with clojure.set/union m {k (set [v])})) {} edges)\n        all-nodes (reduce clojure.set/union (set (keys m)) (vals m))]\n    (letfn [(transitive [node]\n      (loop [reachable (set [node])]\n        (let [reachable' (reduce clojure.set/union\n                                 reachable (map #(get m %) reachable))]\n          (if (= reachable reachable')\n            reachable\n            (recur reachable')))))]\n      (not (empty? (filter  #(= (transitive %) all-nodes) all-nodes))))))","problem":91,"user":"524cdd51e4b0752c4cb68ccc"},{"problem":91,"code":"(fn [pairs]\n    (let [\n          allnodes (fn [vs]\n            (clojure.set/union (set (map first vs)) (set (map second vs))))\n\n          connect (fn [vs visited]\n            (loop [vs vs, visited visited]\n                (if (empty? vs) visited\n                    (let [[a b] (first vs)]\n                        (if (or (contains? visited a)\n                                (contains? visited b))\n                            (recur (rest vs) (conj (conj visited a) b))\n                            (recur (rest vs) visited))))))\n\n          reconnect (fn [vs visited]\n            (let [next (connect vs visited)]\n                  (if (= visited next)\n                    (do (println \"done +> \" next) next)\n                    (recur vs next))))\n\n         ]\n        (= (allnodes pairs) (reconnect pairs #{(first (first pairs))}))\n        ))","user":"5eff6c0ee4b0cf489e8d7f11"},{"problem":91,"code":"(fn [graph]\n    (let [graph (->> graph (map set) set)\n          adjoining? (fn [e1 e2]\n                       (not (empty? (clojure.set/intersection e1 e2))))\n          adjoining-at-least-one? (fn [edge-collection edge]\n                                    (boolean\n                                     (some #(adjoining? edge %) edge-collection)))\n          boolean->keyword {true :adjoining false :not-adjoining}\n          group-by-adjoining (fn [edges candidate-edges]\n                               (group-by\n                                (fn [candidate-edge]\n                                  (boolean->keyword\n                                   (adjoining-at-least-one? edges candidate-edge)))\n                                candidate-edges))\n          first-edge (first graph)]\n      (loop [visiting-edges #{first-edge}\n             remaining-edges (disj graph first-edge)]\n        (cond (empty? remaining-edges) true\n              (empty? visiting-edges) false\n              :else (let [grouped-edges (group-by-adjoining visiting-edges remaining-edges)]\n                      (recur (:adjoining grouped-edges)\n                             (:not-adjoining grouped-edges)))))))","user":"51b91b08e4b0e871ca4958f8"},{"problem":91,"code":"(fn single-connect? [graph]\n   (let [nnode (count (distinct (flatten (seq graph))))\n         full-pocket? (fn [pocket] (= (count pocket) nnode))\n         gen-pocket (fn gen-pocket [graph pocket current]\n                      (let [next-node? (fn [[a b] current]\n                                         (cond\n                                           (= a current) b\n                                           (= b current) a))\n                            next-nodes (filter identity (map #(next-node? % current) graph))\n                            next-nodes-filtered (filter (complement #(some #{%} pocket)) next-nodes)]\n\n                        (if (empty? next-nodes-filtered)\n                          [current]\n                          (let [chains (map (fn [x] (gen-pocket graph (conj pocket current) x))\n                                            next-nodes-filtered)]\n                            (distinct (conj (flatten chains) current))))))\n         pocket (gen-pocket graph [] (ffirst graph))]\n     (full-pocket? pocket)))","user":"56fbf83de4b07572ad1a88da"},{"code":"(fn [G]\n  (let [st (fn [a G]\n             (filter (fn [[x y]] (or (= x a) (= y a))) G))\n        c? (fn c? [a b G]\n             (let [N (st a G)\n                   D (clojure.set/difference G N)]\n               (when G\n                 (if (some (fn [[x y]] (or (= x b) (= y b))) N)\n                   true\n                   (some identity (for [[x y] N :let [y (if (= x a) y x)]]\n                                    (c? y b D)))))))\n        nodes (into #{} (flatten (seq G)))]\n    (empty? (filter nil? (for [x nodes y (clojure.set/difference nodes #{x})]\n                           (c? x y G))))))","problem":91,"user":"4f32a7f1e4b0d6649770a095"},{"problem":91,"code":"(fn [edges]\r\n  (let [\r\n      union (fn [a b] (reduce conj a b))\r\n      points (set (apply concat edges))\r\n      connections (->> edges\r\n        (map (fn [[a b]] [[a b] [b a]]))\r\n        (apply concat)\r\n        (group-by #(first %))\r\n        (map (fn [[k v]] [k (map last v)]))\r\n        (apply concat)\r\n        (apply hash-map))]\r\n    (loop [visiting [(first points)], visited #{}]\r\n      (if (empty? visiting)\r\n        (= visited points)\r\n        (recur\r\n          (filter #(not (visited %))\r\n            (apply concat\r\n              (map #(connections %) visiting)))\r\n          (union visited visiting))))))","user":"555bd27ae4b0b056612e2244"},{"problem":91,"code":"(fn [s]\n  (letfn [(connected-nodes\n           [nodes coll]\n           (let [nodes' (into nodes\n                              (flatten\n                               (for [[a b] coll :when (or (contains? nodes a)\n                                                          (contains? nodes b))]\n                                [a b])))]\n             (if (= nodes nodes')\n               nodes\n               (recur nodes' coll))))]\n    (= (connected-nodes #{(ffirst s)} s)\n       (set (flatten (seq s))))))","user":"56ae214ce4b03c432f18735a"},{"code":"(fn [g]\n  (= 1\n\t\t(count\n\t\t\t(reduce \n\t\t\t\t(fn [g n] \n\t\t\t\t\t(let [{a n r nil} (group-by #(% n) g)]\n\t\t\t\t\t\t(conj r (reduce clojure.set/union a))))\n\t\t\t\t(map set g) \n\t\t\t\t(set (flatten (seq g)))))))","problem":91,"user":"4f991ec1e4b0dcca54ed6cfb"},{"code":"(fn connected?\n  ([s]\n   (connected? (ffirst (seq s)) (seq s)))\n  ([v g]\n   (letfn [(adjacent [g_ n] (->> (for [[x y] g_ :when (or (= x n) (= y n))] [x y]) flatten distinct))]\n     (loop [stack (list v) discovered '()]\n       (cond (empty? stack) (= (count (distinct (flatten discovered))) (count (distinct (flatten g))))\n             :else (let [v (first stack)]\n                     (if (not (some #{v} discovered))\n                       (recur (concat (rest stack) (adjacent g v)) (conj discovered v))\n                       (recur (rest stack) discovered))))))))","problem":91,"user":"530cb5b8e4b02e82168697e0"},{"code":"(fn [edges]\n  (-> (fn [component edge]\n        (let [edge-vertex-set (set edge)\n              by-edge-inclusion (group-by #(-> edge-vertex-set\n                                               (clojure.set/intersection %)\n                                               (empty?))\n                                component)\n              touched (by-edge-inclusion false)\n              untouched (by-edge-inclusion true)\n              new-component (clojure.set/union edge-vertex-set\n                                               (apply clojure.set/union touched))]\n          (conj untouched new-component)))\n      (reduce #{} edges)\n      (count)\n      (#(= 1 %))))","problem":91,"user":"51a3b135e4b0e77c4ca60bf6"},{"problem":91,"code":"(fn [s]\n  (let [edges (into s (map reverse s))\n        edge-map (group-by first edges)\n        nodes (set (keys edge-map))\n        traverse (fn traverse [visited node]\n                   (if (contains? visited node)\n                     []\n                     (into #{node} (mapcat #(traverse (conj visited node) (second %)) (edge-map node)))))]\n    (= nodes (traverse #{} (first nodes)))))","user":"53ce4cd4e4b00fb29b2212ef"},{"code":"(letfn [(links? [edge group-of-nodes]\n           (some #(or (= (edge 0) %) (= (edge 1) %)) group-of-nodes))\n         (all-nodes [graph]\n          (into #{} (apply concat graph)))]\n (fn [graph]\n   (loop [visited-nodes (into #{} (first graph))\n          [current-edge & remaining-edges] (rest graph)\n          tested-edges []]\n     (cond\n       (= (all-nodes graph) visited-nodes) true\n       (nil? current-edge) false\n       (links? current-edge visited-nodes)\n       (recur (into #{} (concat visited-nodes current-edge))\n              (concat remaining-edges tested-edges)\n              [])\n       :else\n       (recur visited-nodes\n              remaining-edges\n              (conj tested-edges current-edge))))))","problem":91,"user":"4f1bb9d8535d64f60314647d"},{"code":"(fn gc [s]\n  (let [source (map set s)\n        expand (fn [s x]\n            (let [r (map #(if (empty? (clojure.set/intersection % x))\n                            % (clojure.set/union % x))\n                         s)]\n              (set (if (= s r) (cons x s) r))))]\n    (= 1 (count (loop [s source r (set s)]                  \n                  (if (= s r) r (recur r (reduce expand s s))))))))","problem":91,"user":"511d6a01e4b022853b0e07a5"},{"code":"#(letfn [\r\n(get-reachables [x edges]\r\n  (concat (map second (filter (fn [y] (= (first y) x)) edges))\r\n          (map first  (filter (fn [y] (= (second y) x)) edges))))\r\n(my-union [s1 s2] (into s1 s2))\r\n(my-difference [s1 s2]\r\n  (set (filter (fn [x] (not (contains? s2 x))) s1)))\r\n(test-connected [l k e p]\r\n\t    (if (nil? (first k))\r\n\t\t    l\r\n\t\t    (let [x (first k)\r\n\t\t          reachables (get-reachables x e)]\r\n\t\t     (test-connected (my-union (set reachables) l)\r\n\t\t\t\t     (my-union (my-difference (set reachables) (set p)) (rest k))\r\n\t\t\t\t     e\r\n\t\t\t\t     (conj p x)))))\r\n(collect-vertices [[pair & edges] set]\r\n  (if (nil? pair)\r\n\t  set\r\n\t  (let [[v1 v2] pair]\r\n\t    (recur edges (conj set v1 v2)))))\r\n(is-connected [edges-set]\r\n  (let [edges-seq (seq edges-set)\r\n\t      v (first (first edges-seq))]\r\n    (= (test-connected #{v} #{v} edges-seq []) (collect-vertices edges-seq #{}))))]\r\n\r\n(is-connected %))","problem":91,"user":"4e273301535deb9a81d77ef7"},{"problem":91,"code":"(fn connected [edgeList]\n  (= 1 (count\n    (reduce\n      (fn updateGraphComponents [components,myEdge]\n        (conj \n           (remove \n              (fn [x] \n                       (or (= x \n                              (first (filter (fn [z] (contains? z (first myEdge))) components))\n                              ) \n                           (= x \n                              (first (filter (fn [z] (contains? z (second myEdge))) components))\n                           )\n                       )\n              ) \n            components) \n            (clojure.set/union (into #{} myEdge) (clojure.set/union \n                                    (first (filter (fn [z] (contains? z (first myEdge))) components))\n                                    (first (filter (fn [z] (contains? z (second myEdge))) components))\n            ))\n        )      \n    ) \n    []      \n    edgeList    \n    ) \n  ))\n)","user":"55d35a01e4b0e31453f64a63"},{"problem":91,"code":"(fn dumm [s]\n   (= 1 (count (\n(fn lump1 [y]\n         (let [x (first y) ry (rest y)] (loop [n 0] (if  (= n (count ry)) y ( if ((fn connected? \n  [x y]\n (not (empty? (clojure.set/intersection (set x) (set y)))\n      )) x (nth ry n)) (lump1 (conj (into (take n ry) (drop (inc n) ry) ) (clojure.set/union x (nth ry n)))) (recur (inc n)))) \n  ))) s)))\n)","user":"6076adb2e4b069485764de60"},{"code":"(fn [g]\n  (loop [c #{(first g)} uc (set (rest g))]\n    (if (empty? uc)\n      true\n      (let [cf (set (apply concat c))\n            e (first (filter (fn [[v1 v2]] (or (contains? cf v1) (contains? cf v2))) uc)) \n            nuc (disj uc e)]\n          (if e\n            (recur (conj c e) nuc)\n            false\n          )\n      )\n    )\n  )\n)","problem":91,"user":"51ba8f82e4b0fe3ecfb46434"},{"problem":91,"code":"(fn puzzle-91 [tuples]\n           (letfn [(find-conn-sets [ss tuple]\n                                   (let [points (set tuple)]\n                                     (remove #(empty? (clojure.set/intersection % points)) ss)))\n                   (add-tuple [ss tuple]\n                              (let [[a b] (find-conn-sets ss tuple)\n                                    t (set tuple)]\n                                (cond\n                                 (= nil a b) (conj ss t)\n                                 (nil? b) (conj (disj ss a) (clojure.set/union a t))\n                                 :else (conj (disj ss a b) (clojure.set/union a b t)))))]\n             (= 1 (count (reduce add-tuple #{} tuples)))))","user":"53286f84e4b09d4e7a9b5505"},{"code":"(fn [s]\n  (let [o (fn [v a]\n           (loop [c #{a}]\n             (let [d (reduce \n                       (fn [e [x y]] (conj (conj e (if (c x) y a)) (if (c y) x a))) \n                       c v)]\n               (if (= c d) c (recur d)))))]\n    (= (o s (first (first s))) (clojure.set/union (set (map first s)) (set (map second s))))))","problem":91,"user":"50fbdacfe4b0d10d794c19f0"},{"problem":91,"code":"(fn [edges]\n  (let [n (count (set (flatten (into [] edges))))]\n  (letfn [(neigh [v]\n            (filter identity (for [[a b] edges]\n              (cond\n                (= a v) b\n                (= b v) a))))] \n    (loop [queue [ (first (first edges)) ]\n           visited #{}]\n      (if (empty? queue)\n        (= (count visited) n)\n        (let [v (peek queue)\n              neighbors (filter #(not (visited %)) (neigh v))]\n              (recur\n                (vec (into neighbors (pop queue)))\n                (conj visited v))))))))","user":"53d78b64e4b0e771c3025466"},{"problem":91,"code":"(fn f [vertices]\n  (let\n   [nodes (->> vertices\n               (mapcat identity)\n               (set))\n    paths (->> nodes\n               (reduce\n                (fn [a k]\n                  (assoc a k (set (mapcat identity (filter (fn [v] (some #(= k %) v)) vertices))))) {}))\n    pairs (->> (for [x nodes\n                     y (filter #(not= % x) nodes)] [x y])\n               (group-by sort)\n               (keys))\n    can-trace-path? (fn [[start end]]\n                      (loop [visited #{start} curr-options (get paths start)]\n                        (cond\n                          (contains? visited end) true\n                          (contains? curr-options end) true\n                          (empty? curr-options) false\n                          :else (let [new-visited (apply conj visited curr-options)\n                                      new-opts (clojure.set/difference (set (mapcat (fn [x] (get paths x)) curr-options)) new-visited)]\n                                  (recur new-visited new-opts)))))]\n   (every? can-trace-path? pairs)))","user":"5ea6fe98e4b00a66d4a951b2"},{"problem":91,"code":"(fn [xs] (letfn [(connected [a b] (let [v (concat a b) s (set v)]\n                                           (> (count v) (count s))))\n                        (group [xs] (set (for [x xs y xs :when (and (not= x y) (connected x y))] (set (concat x y)))))\n]\n                  (loop [pc (count xs) g (group xs)]\n                    (let [c (count g)]\n                      (cond\n                       (= pc 1)  true\n                       (= c 1)  true\n                       (= pc c) false\n                       :defualt (recur c (group g)))))))","user":"5b924123e4b0c0b3ffbd4a34"},{"problem":91,"code":"(fn connected-graph? [edges]\n  (let [in-component? (fn [component edge] (some #(contains? component %) edge))\n        containing-components (fn [cs edge] (filter #(in-component? % edge) cs))\n        components (reduce (fn [cs edge]\n                             (if-let [ccs (not-empty (containing-components cs edge))]\n                               (-> (apply disj cs ccs)\n                                   (conj (apply clojure.set/union (cons (set edge) ccs))))\n                               (conj cs (set edge))))\n                           #{} edges)]\n    (= 1 (count components))))","user":"5879d577e4b01531a375ead8"},{"problem":91,"code":"(fn connected?\n  ([edges-left] (connected? \n                    (set (list (first (first edges-left)) (second (first edges-left)))) \n                    (rest edges-left)))\n  ([set-nodes-in edges-left]\n    (if (empty? edges-left) \n      true\n      (let [reachable-node? #(or (set-nodes-in (first %)) (set-nodes-in (second %)))\n        connectable (filter reachable-node? edges-left)\n        not-connectable (filter (complement reachable-node?) edges-left)\n        new-set-nodes-in (clojure.set/union (set (flatten connectable)) set-nodes-in)]\n        (if (empty? connectable)\n          false\n          (recur new-set-nodes-in not-connectable))))))","user":"5710140fe4b09c608db7042e"},{"code":"#(let [[x & e] (seq %),r reduce,g empty?]            \r\n     (loop [v (into #{} x), e %, f false]\r\n        (if f\r\n            (g e)\r\n            (let [m (filter (fn [[x y]] (or (v x) (v y))) e)]\r\n              (recur (r conj v (flatten m)) \r\n                     (r disj e m) \r\n                     (g m))))))","problem":91,"user":"4db92654535d1e037afb21a0"},{"code":"(fn connected? [br]\n   (letfn [(follow [m]\n             (let [new (merge-with (fn [a b] (set (mapcat #(if-let [v (m %)] (set (concat b v)) (set b)) b))) m m)]\n               (if (= new m) m (follow new))))]\n     (let [graph (concat br (map reverse br))\n           reachable (set (follow (reduce (fn [m [k v]] (let [old (m k)] (assoc m k (if old (conj old v) #{v})))) {} graph)))\n           all-points (set (map first reachable))]\n       (every? (fn [s] (= s all-points)) (map second reachable)))))","problem":91,"user":"4e89f46c535d3e98b8023288"},{"problem":91,"code":"(fn [g]\n  (= 1 (count (reduce \n               (fn [acc pair]\n                 (let [pred (partial some (set pair))\n                       [conn dis] ((juxt filter remove) pred acc)]\n                   (set (cons (set (apply concat pair conn)) dis))))\n               #{}\n               g))))","user":"54d7e277e4b0a52adc2e2031"},{"code":"(fn [edges]\n    (let [union clojure.set/union\n          difference clojure.set/difference\n          vmap (->> edges\n                    (mapcat (fn [[v1 v2]] [{v1 #{v2}} {v2 #{v1}}]))\n                    (apply merge-with union))\n          traverse\n            (fn [vertex]\n                (loop [vs (vmap vertex), res #{vertex}]\n                    (let [new (difference vs res)]\n                        (if (empty? new)\n                            res\n                            (recur (apply union (map vmap new)) (union res new))\n                        ))))\n        ]\n        (every? #(= (count vmap) (count (traverse %))) (keys vmap))\n    ))","problem":91,"user":"4df3d4f4535d08e6dec9fe2c"},{"problem":91,"code":"(fn [edges]\n   (let [edge-map (reduce (fn [acc [a z]] (merge-with into acc {a #{z}} {z #{a}}))\n                          {} edges)]\n     (letfn [(bfs [node visited]\n               (reduce (fn [acc n]\n                         (if (not (contains? acc n))\n                           (bfs n (conj acc n))\n                           acc))\n                       visited (edge-map node))\n               )]\n       (= (set (keys edge-map))\n          (bfs (first (first edge-map)) #{(first (first edge-map))})))))","user":"5eee7311e4b07c55ae4a0510"},{"code":"(fn [s]\r\n    (let\r\n      [\r\n       full-edges (into s (map (fn [[x y]] [y x]) s))\r\n       neighbors (group-by first full-edges) \r\n       all-nodes (into #{} (map first full-edges))\r\n      ]\r\n      (println \"full-edges: \" full-edges)\r\n      (println \"neighbors: \" neighbors)\r\n      (println \"all-nodes: \" all-nodes)\r\n      (loop [visited #{} fringe [(first all-nodes)]]\r\n        (println \"in loop:\")\r\n        (println \"visited: \" visited)\r\n        (println \"fringe: \" fringe)\r\n        (if (empty? fringe) (= visited all-nodes)\r\n          (let [\r\n                [current & fringe-1] fringe\r\n                new-fringe (into fringe-1 \r\n                                 (clojure.set/difference \r\n                                 (set (map second (neighbors current)))\r\n                                      visited))\r\n                new-visited (conj visited current)\r\n                ]\r\n            (recur new-visited new-fringe))))))","problem":91,"user":"502a9fdee4b095a7adb898b4"},{"problem":91,"code":"(fn graph-connected?\n  [edges]\n  (let [create-adjlist (fn [adlist-default] ;; create the adjlist\n          (reduce #(assoc %1 (first %2) (into (%1 (first %2)) [(second %2)]))\n                  adlist-default\n                  (concat edges (reduce #(into %1 [[(second %2)(first %2)]]) [] edges)))) ;;undirected, so include reverse also\n        adjlist (create-adjlist ;; make default map for adjlist with each vertex and an empty vector for neighbors\n                 (into {}  (map vec (partition 2 (interpose [] (flatten edges))))))]\n    (letfn [(connected? [] ;; simple BFS\n              (loop [visited [] q [(ffirst adjlist)]]\n                (if (= 0 (count q)) (if (= (count (set visited)) (count adjlist)) true false)\n                    (recur (into visited [(first q)])\n                           (if (= -1 (.indexOf visited (first q)))\n                             (reduce #(conj %1 %2) (next q)\n                                     (adjlist (first q)))\n                             (next q))))))]\n      (if (connected?) ;; if connected, any graph with max odd degree >2 cannot have a Eulerian path\n        true false))))","user":"561ca6ebe4b064ca9f4b169c"},{"code":"; same some functions as q82...\n(fn q91 [coll]\n  (letfn [\n  \t(transits [coll]\n\t\t  (reduce\n\t\t    (fn [m [e1 e2]]\n\t\t        (assoc m e1 (conj (m e1) e2) e2 (conj (m e2) e1)))\n\t\t    {} coll))\n\n\t\t(paths \n\t\t  ([m p n]\n\t\t  (if (some #(= n %) p) [p]\n\t\t    (mapcat #(paths m (conj p n) %) (m n))))\n\t\t  ([m] (mapcat #(paths m [] %) (keys m)))) ]\n  \n\t  (let [ts (transits coll)\n\t        num-nodes (count ts)]\n\t    (if (some #(= num-nodes (count %)) (paths ts)) true false))))","problem":91,"user":"4fd22e70e4b04c3a95aa041c"},{"code":"(fn [ns]\n  (let [ms (reduce\n            (fn [a [f s]] (-> a \n                              (assoc s (conj (get a s #{}) f))\n                              (assoc f (conj (get a f #{}) s))))\n            {} ns)\n        ps (->> ns\n                ffirst (conj #{})\n                (iterate #(reduce (partial apply conj) % (map ms %)))\n                (partition 2 1)\n                (drop-while (partial apply not=))\n                ffirst)]\n    (= (count ps) (count ms))))","problem":91,"user":"50c9e5e3e4b0a409464667d7"},{"code":"(fn [g]\n  ((fn f [e] \n     (#(if (= e %) (= % g) (f %)) \n        (reduce (fn [a b] (into a (filter #(some (set b) %) g))) \n                #{} \n                e))) \n   #{(first g)}))","problem":91,"user":"4ef49c2c535dced4c769f238"},{"problem":91,"code":"(fn [L]\n    (letfn [(join-component [s1 s2]\n                (clojure.set/difference (clojure.set/union s1 s2) (clojure.set/intersection s1 s2)))\n            (join-component-step [SS]\n                (if (= (count SS) 1)\n                    true\n                        (some true? (map join-component-step \n                                         (for [s1 (seq SS) s2 (seq SS) \n                                              :when (and (not= s1 s2) (not= (clojure.set/intersection s1 s2) #{}))]\n                                         (clojure.set/union #{(join-component s1 s2)} (clojure.set/difference SS #{s1 s2})) )))))\n            (path? [L] \n                 (let [S (into #{} (map #(into #{} %) L))]\n                   (if (not= (count L) (count S))\n                        false\n                       (join-component-step S))))]\n      (true? (path? L))))","user":"56fa2905e4b07572ad1a88be"},{"problem":91,"code":"(fn [rel*]\n  (let [nodes (into #{} (apply concat rel*))]\n    (every?\n      (fn [[_ rs]]\n        (= nodes (set (keys rs))))\n      (loop [rel (reduce #(assoc-in\n                            (assoc-in %1 %2 true)\n                            (reverse %2) true) \n                         {} rel*)]\n        (let [new-rel\n              (reduce-kv (fn [r l rs]\n                           (->> (keys rs) (map rel)\n                                (apply merge rs)\n                                (assoc r l)))\n                         {} rel)]\n          (if-not (= new-rel rel)\n            (recur new-rel) rel))))))","user":"53dfdf01e4b0d874e779ae46"},{"problem":91,"code":"(fn connectivity                                                                \n  [g]                                                                           \n  (let [all-nodes (set (apply concat g))                                        \n        graph (reduce (fn [m [a b]]                                             \n                        (update-in m [a] (fnil conj #{}) b))                    \n                      {}                                                        \n                      (concat g (map reverse g)))                               \n        walk (fn walk                                                           \n               ([node] (walk node #{node}))                                     \n               ([node visited]                                                  \n                (let [next-nodes (remove visited (graph node))]                 \n                  (if (empty? next-nodes)                                       \n                    visited                                                     \n                    (reduce into                                                \n                            visited                                             \n                            (map #(walk % (conj visited %))                     \n                                 next-nodes))))))]                              \n    (apply = all-nodes (map walk all-nodes))))","user":"51f9527fe4b09be9c177e549"},{"problem":91,"code":"(fn connected? [adjlist]\n  (if (<= (count adjlist) 1)\n    true\n    (loop [conn (set (first adjlist)) xs (rest adjlist)]\n      (if (empty? xs)\n        true\n        (let [cut ((juxt filter remove) #(some (partial contains? conn) %) xs)]\n          (if (empty? (first cut))\n            false\n            (recur (reduce (partial apply conj) conn (first cut)) (second cut))))))))","user":"553abb28e4b09218d5f44ffb"},{"problem":91,"code":"; Breadth-first solution: simple but not terribly efficient\n  (fn [coll]\n    (let [nodes (set (flatten (seq coll)))\n          edges (map set coll)]\n      (true?\n        (loop [visited #{(first nodes)}]\n          (or (= visited nodes)\n              (let [spanned-edges (filter #(not-empty (clojure.set/intersection % visited)) edges)\n                    next-nodes (reduce clojure.set/union visited spanned-edges)]\n                (if (> (count next-nodes) (count visited))\n                  (recur next-nodes))))))))","user":"54f26266e4b024c67c0cf8c5"},{"code":"(fn  [graph]\n  (letfn [(get-nodes [graph]\n                     (set (mapcat identity graph)))\n          (get-edges [graph]\n                     (set (map set (filter #(not (= (first %) (second %))) graph))))\n          (get-neighboors [c n edges] \n                          (filter identity (map #(cond \n                                                   (= (first %) c) (if (contains? n (second %)) false (second %))\n                                                   (= (second %) c) (if (contains? n (first %)) false (first %))\n                                                   :else false) edges)))\n          (dfs [nodes edges] \n               (loop [c (first nodes) s [c] n #{c} \n                      t (get-neighboors c n edges)]\n                 (if (empty? s)\n                   n\n                   (recur \n                     (if (empty? t) (peek s) (first t)) \n                     (if (empty? t) (pop s) (conj s (first t))) \n                     (if (empty? t) n (conj n (first t)))\n                     (if (empty? t) (get-neighboors (peek s) n edges) (get-neighboors (first t) n edges))))))\n          (is-linked [nodes edges] (= nodes (dfs nodes edges)))\n          ]\n    (let [n (get-nodes graph) e (get-edges graph)\n          \n         ]\n      (is-linked n e)\n      )))","problem":91,"user":"52b43468e4b0c58976d9ad1b"},{"problem":91,"code":"(fn problem91\n  [s]\n  (letfn [;; Is there a path from node a to node b\n          ;; (path [1 2] [2 3]) -> true\n          ;; (path [1 2] [3 2]) -> true\n          (is-path [[a b] [c d]]\n            (or (= b c)\n                (= b d)\n                (= a c)\n                (= a d)))\n\n          ;; Return [elem [xs without elm]]\n          (remover [elm xs]\n            [elm (filter #(not= elm %) xs)])\n          \n          ;; split all combinations\n          ;; given [a b c d]\n          ;; return\n          ;; [a [b c d]] [b [a c d] [c [a b d]] [d [a b c]]\n          (combo-splitter [xs]\n            (map #(remover % xs) xs))\n\n          (filter-next-paths\n            [node xs]\n            (filter (fn [[n r]] (or (nil? node) (is-path node n))) (combo-splitter xs)))\n\n          ;; For a given set of nodes return true if they are connected\n          (problem91Ex [path xs]\n            (if (empty? xs)\n              path\n              ;; for each item in xs\n              ;; if is-path (last path) (first xs)\n              ;; call foo (add-path path node) (remove node xs)\n              (let [node (last path)\n                    paths (filter-next-paths node xs)]\n                    (map (fn [[ a res ]] (problem91Ex (conj path a) res)) paths))))]\n    (pos? (count (flatten (problem91Ex [] s))))))","user":"4ebbff41535dfed6da9c6d78"},{"code":"(fn [E]\n       (let [V (set (reduce (fn [vs [a b]]\n                              (->> vs\n                                   (cons a)\n                                   (cons b)))\n                            #{} E))]\n         (letfn [(rec [n vis]\n                      (reduce (fn [v [a b]]\n                                (cond\n                                 (= a n) (if (get v b) v (rec b v))\n                                 (= b n) (if (get v a) v (rec a v))\n                                 :else v))\n                              (conj vis n) E))]\n           (= (count V) (count (rec (first V) #{}))))))","problem":91,"user":"4ee82223535d93acb0a66877"},{"code":"(fn graph-find\n  [connections]\n  (= 1\n     (count\n       (reduce (fn [acc pair]\n                 (let [pred (partial some (set pair))\n                      [connected disconnected] ((juxt filter remove) pred acc)]\n                   (set (cons (set (apply concat pair connected)) disconnected))))\n               #{}\n               connections))))","problem":91,"user":"4dc0ff08535d020aff1edf84"},{"problem":91,"code":"(fn [coll]\n  (let [vertex-count (count (distinct (reduce #(apply conj %1 %2) '() coll)))\n        total-edges (* vertex-count vertex-count)]\n    (= total-edges\n       (count (loop [edges (into coll (map reverse coll))]\n                (let [new-edges (for [[x y] edges\n                                      [a b] edges]\n                                  (if (= y a)\n                                    [x b]\n                                    [x y]))\n                      edges2 (into edges new-edges)]\n                  (if (= edges edges2)\n                    edges\n                    (recur edges2))))))))","user":"5ac91d90e4b0e27600da77bd"},{"problem":91,"code":"(fn [edges]\n  (loop [discovered-vertives (set (first edges))\n         rst (rest edges)]\n    (let [new-discovered-edges (filter #(or (contains? discovered-vertives (first %))\n                                            (contains? discovered-vertives (second %))) rst)\n          new-discovered-vertives (-> new-discovered-edges flatten set)\n          new-rst (remove (set new-discovered-edges) rst)]\n      (cond\n        (empty? new-rst) true\n        (empty? new-discovered-edges) false\n        :else (recur new-discovered-vertives new-rst)))))","user":"5f5358b7e4b0a0bc16850a77"},{"problem":91,"code":"(fn is-connected [connections]\n  (let [ add-connection (fn  [current-sets connection] \n                          (let [get-existing-index (fn [current-sets node] (second (first (filter #(first %) (map-indexed (fn [index a] [(contains? a node) index]) current-sets) ))))\n                                in-current-indexes (set (remove nil? (map #(get-existing-index current-sets %) connection)))\n                                with-index (map-indexed #(vector %1 %2) current-sets)\n                                g (group-by  #(contains? in-current-indexes (first %)) with-index)\n                                these (apply concat (map second (g true)))\n                                others (map second (g false))\n                                new-set (conj others  (conj these (first connection) (second connection)))\n                                ]    \n                            (map set new-set)))]\n    (= 1 (count (reduce #(add-connection %1 %2) [] connections)))))","user":"54e345a1e4b024c67c0cf7db"},{"problem":91,"code":"(fn [g]\n   (let [v (-> g first first)\n         neighbour (fn [v g]\n                     (let [[e & _] (filter (fn [e]\n                                             (or (= (first e) v)\n                                                 (= (second e) v))) g)]\n                       (if (= (first e) v) [(second e) e] [(first e) e])))\n         rem-first (fn [v coll]\n                     (let [[h r] (split-with (partial not= v) coll)]\n                       (concat h (rest r))))\n         vs (set (mapcat identity g))]\n     (loop [s '()\n            v v\n            c '()\n            g g]\n       (if (and (nil? (first (neighbour v g))) (empty? s))\n         (= (set (cons v c)) vs)\n         (let [[n e] (neighbour v g)]\n           (if n\n             (recur (cons v s) n c (rem-first e g))\n             (recur (rest s) (first s) (cons v c) g)))))))","user":"5a250b86e4b07f18be40aa19"},{"code":"(fn [g] \n  (letfn \n    [(add [x y m] (assoc m x (conj (m x) y))) \n     (add-path [x y m] (->> m (add x y) (add y x)))\n     (cal [m] (into {} (map #(let [[x s ] %] (vector x (set (concat s (mapcat m s))))) m)))  \n     ] \n    (->> (loop [m (cal (reduce #(apply add-path (conj %2 %)) {} g))] (let [r (cal m)] (if (= r m) m (recur r))))\n         vals (apply =))\n    ))","problem":91,"user":"523b1988e4b02f719975bdbc"},{"code":"(fn [graph]\n  (= 1\n     (count (reduce (fn [connected [x y]]\n                      \"union the set where x belongs to with the set where y belongs to\"\n                      (let [x-set (clojure.set/union (first (filter #(contains? %1 x) connected)) #{x})\n                            y-set (first (filter #(contains? %1 y) connected))]\n                        (set (conj (->> connected\n                                        (remove #(contains? %1 x))\n                                        (remove #(contains? %1 y)))\n                                   (if (empty? y-set)\n                                     (conj x-set y)\n                                     (clojure.set/union x-set y-set))))))\n                    #{}\n                    graph))))","problem":91,"user":"4dd7b81d535d2dad7130b5d3"},{"code":"(fn [edges]\n  (let [nodes (reduce (fn [acc [k v]] (update-in acc [k] (fnil conj #{}) v))\n                      {}\n                      (concat (seq edges) (map reverse (seq edges))))]\n    (loop [explored #{} connected #{(first (keys nodes))}]\n      (if-let [to-explore (first (clojure.set/difference connected explored))]\n        (recur (conj explored to-explore) (into connected (nodes to-explore)))\n        (= (count connected) (count nodes))))))","problem":91,"user":"52a1acb2e4b04e0c58e87bdb"},{"problem":91,"code":"(fn connected? [es]\n  (let [vs (reduce (fn [m ls] (reduce #(assoc %1 %2 :unvisited) m ls))\n                   '{}\n                   es)\n        vls (keys vs)]\n    (letfn [(adjacent [v1 m]\n                      (fn [q [a b]]\n                        (cond\n                         (and (= v1 a) (= (get m b) :unvisited)) (conj q b)\n                         (and (= v1 b) (= (get m a) :unvisited)) (conj q a)\n                         :else q)))\n            (deq [vs q]\n                 (if (empty? q)\n                   vs\n                   (let [v1 (peek q)]\n                     (recur (assoc vs v1 :visited)\n                            (reduce (adjacent v1 vs) (pop q) (into '() es))))))]\n      (loop [vs vs\n             v1 (first vls)\n             vls (rest vls)\n             components 0]\n        (cond\n         (nil? v1 ) (= components 1)\n         (= (get vs v1) :visited) (recur vs (first vls) (rest vls) components)\n         :else (recur\n                (deq vs (conj clojure.lang.PersistentQueue/EMPTY v1))\n                (first vls)\n                (rest vls)\n                (inc components)))))))","user":"55f73078e4b06e875b46cea4"},{"problem":91,"code":"(fn conn\n  ([g] (let [nodes (set (flatten (into '() g)))\n      \t\tvisited (zipmap nodes (repeat false))]\n  \t\t(every? #(conn g visited %) nodes)))\n  ([g visited n]\n   \t\t(let [edges (filter #(apply some (partial = n) %&) g)\n              neighbors (remove #{n} (flatten (into '() edges)))\n              visited (merge (assoc visited n true) (zipmap neighbors (repeat true)))]\n          (cond (every? true? (vals visited)) true\n                (empty? edges) false\n                :else (some #(conn (remove #{%} g) \n                            \t   visited \n                                   (first (filter (partial not= n) %))) \n                            edges)))))","user":"5e3a25d4e4b01d43a70e8dde"},{"problem":91,"code":"(fn connected? [g]\n  {:pre [(coll? g),\n         (every? (comp (partial = 2) count) g)]}\n  (loop [ccom (set (first g)), edges (rest g)]\n    (let [[new-ccom new-edges]\n          (reduce (fn [[in out] [a b :as e]]\n                    (if (or (in a) (in b))\n                      [(conj in a b) out]\n                      [in (conj out e)]))\n                  [ccom []]\n                  edges)]\n      (cond\n        (empty? edges)     true\n        (= ccom new-ccom)  false\n        :else              (recur new-ccom new-edges)))))","user":"4fc6305de4b0ee37620e180b"},{"problem":91,"code":";simple depth first search path length compared to length\n;of original graph\n(fn gc[g]  \n  (let [init (first g)\n        visited (atom #{init})\n        neighbors (fn [node]\n                    (let [rg  (into #{} (remove #{node} g))\n                          rg2 (clojure.set/difference rg @visited)\n                          x (first node)\n                          y (second node)]\n                      (filter #(or (= x (first %))\n                                   (= x (second %))\n                                   (= y (first %))\n                                   (= y (second %)))\n                        rg2)))\n        mybranch? (comp not empty? neighbors)\n        mychildren (fn[node] (let[c (neighbors node)] (swap! visited into c) c))\n        path (tree-seq mybranch? mychildren init)]\n    (= (count path) (count g))))","user":"52f426fce4b05e3f0be25f1e"},{"code":"(fn [s]\n  (let [p (remove #{s} (reduce (fn [a e]\n                                     (apply conj a #{e}\n                                            (map #(conj % e) a)))\n                                   #{}\n                                   s))]\n    (every? #(not= () (filter (set (apply concat %))\n                              (flatten (remove % s))))\n            p)))","problem":91,"user":"536e0930e4b0fc7073fd6e66"},{"code":"(fn __ [x] \r\n    (let [my-assoc (fn [acc [k v :as element]]\r\n                     (let [old (acc k)\r\n                           nu (if old (conj old v) #{v})] \r\n                       (assoc acc k nu)))\r\n          read-in (fn [xs]\r\n                    (reduce (fn [acc element]\r\n                              (my-assoc\r\n                                (my-assoc acc element)\r\n                                (reverse element)))\r\n                            {} xs))\r\n          gcons (fn gcons\r\n                  ([xs x] (gcons xs x #{})) \r\n                  ([xs x seen]\r\n                   (if (seen x)\r\n                     seen\r\n                     (reduce into #{}  \r\n                             (for [other (xs x)]\r\n                               (gcons xs other (conj seen x)))))))\r\n          graph (read-in x)\r\n          conns (gcons graph (first (first graph)))]\r\n      (= (count (keys graph)) (count conns))))","problem":91,"user":"4dc537fd535d8a4b2fd74282"},{"problem":91,"code":"(fn g-connect [graph]\n  (letfn [(every-n [g] (set (mapcat  #(flatten %) g)))\n          (to-go [n] (every-n (filter #(contains?  (set %) n) graph)))\n          (walk [g ng] (if (not= g ng) (recur ng (set  (mapcat to-go ng))) g))]\n    (let [every-n-g (every-n graph)]\n      (=  (walk #{} #{(first every-n-g)}) every-n-g))))","user":"52eaba10e4b09f7907dd14c2"},{"code":"#(> 2 (count\r\n   (reduce (fn [s [ea eb]]\r\n    (apply cons\r\n      (reduce (fn [[j d] cs]\r\n        (if (or (cs ea) (cs eb))\r\n          [(into j cs) d]\r\n          [j (conj d cs)]))\r\n        [#{} []] s)))\r\n    (->> % vec flatten set (map hash-set))\r\n    %)))","problem":91,"user":"50336c6be4b0c6c1199c710f"},{"code":"(fn [s] \n  (let [s (set (concat s (map reverse s)))\n        tmp (set (map first s))\n        ds (fn [v] \n                 (->>\n                  s\n                  (filter #(= (first %) v))\n                  (map second)))\n        g (fn g [rt v] \n            (let [rt (conj rt v)]\n              (reduce \n               g rt \n               (filter (complement rt)\n                       (ds v)))))]\n    (= (g #{} (first tmp))\n       tmp)))","problem":91,"user":"51944aaae4b0142f60b4aedc"},{"code":"(fn [edges]\n  (let [nodes (mapcat identity edges)\n        ini (reduce #(conj % [%2 %2]) {} nodes)\n        ufind #(loop [k %2] (if (= k (% k)) k (recur (% k))))\n        qwer #(if (> (compare % %2) 0) % %2)\n        rewq #(if (< (compare % %2) 0) % %2)\n        unions (reduce #(conj % [(apply qwer %2) (ufind % (apply rewq %2))]) ini edges)]\n    (= 1 (count (into #{} (map #(ufind unions %) nodes))))))","problem":91,"user":"503a234de4b088a6a14ca76d"},{"problem":91,"code":"(fn [inp]\n  (if (seq inp)\n    (loop [ bonds (seq inp), visited (vector (first (first bonds)))]\n      (cond\n        (empty? visited) false\n        (empty? bonds) true\n        :else\n          (let [ v1 (first visited),\n            rest-bonds (filter #(and (not= v1 (first %))\n              (not= v1 (second %))) bonds),\n            newly-visited (reduce\n              (fn [a b]\n                (cond\n                  (= v1 (first b)) (conj a (second b))\n                  (= v1 (second b)) (conj a (first b))\n                  :else a\n                ))\n              [] bonds)]\n            (recur rest-bonds\n              (vec (concat (rest visited) newly-visited)) )\n        )\n    ))\n   true\n  ))","user":"4fd11a93e4b04c3a95aa040a"},{"code":"(fn [g]\n  (let [v (set (apply concat g))]\n    (true? (some #(= v %) (vals\n      (loop [s (apply merge\n                 (map #(hash-map % #{%})\n                      v))]\n        (let [x (apply merge-with\n                  clojure.set/union\n                  (for [n  (keys s)\n                        nn (keep\n                             #(cond (= (% 0) n) (% 1)\n                                    (= (% 1) n) (% 0)\n                                    true        nil)\n                             g)]\n                    {nn (conj (s n) nn)}))]\n          (if (= x s) x (recur x)))))))))","problem":91,"user":"4f6fbb68e4b07046d9f4efeb"},{"code":"(fn fullpath[pathcol]\r\n  (let[fillFn (fn[mp a b]\r\n                 (if (nil? mp)\r\n                      nil\r\n                      (let[vs (get mp a)]\r\n  \t                      (if (nil? vs)\r\n\t\t                          (assoc mp a #{b})\r\n\t\t                          (if (contains? vs b)\r\n                                  nil\r\n\t\t                              (assoc mp a (conj vs b) )\r\n\t\t                           )\r\n\t\t                      )\r\n                        )\r\n                     )\r\n                 ),\r\n       pathmap (reduce  (fn[mp [a b]]\r\n                            (if (= a b)\r\n                               (fillFn mp b a)\r\n                               (fillFn (fillFn mp a b) b a)\r\n                            )\r\n                           ) {}  pathcol)\r\n       \r\n       \r\n       ]\r\n    (if (nil? pathmap)\r\n        false\r\n    (loop[result [(first (keys pathmap))],pathMap pathmap]\r\n       (println result)\r\n       (println pathMap)\r\n       (if (empty? pathMap)\r\n           true\r\n          (let[nextCol (reduce concat [] (map #(get pathMap %) result))]\r\n             (if (empty? nextCol)\r\n                 false\r\n                 (recur (distinct nextCol) (reduce dissoc pathMap result) )\r\n              )\r\n          )\r\n        )\r\n      )\r\n     )\r\n  )\r\n)","problem":91,"user":"4f6d9d7ee4b07046d9f4efcd"},{"problem":91,"code":"(fn [args] (every? identity (let [ts (letfn [(trans [z] (into z (for [[a b] z ;list of all transitive pairs\n                                                                       [c d] z \n                                                                       :when (= b c)]\n                                                                   [a d])))]\n                                        (loop [as args]\n                                          (if (= (trans as) as) \n                                            as \n                                            (recur (trans as)))))\n                                   n (fn [n1 n2] (some #(= [n1 n2] %)ts))]\n                               (for [[a b] args\n                                     [c d] args]\n                                 (if (or(n a d)(n d a)(n b c)(n c b)) true false)))))","user":"566a3a26e4b0a866af689699"},{"problem":91,"code":"(fn con? [graph]\n  (let [connected? (fn [front [v u]]\n  (or\n    (contains? front u)\n    (contains? front v)))\n        front (set (first graph))\n        rest (seq (rest graph))]\n    (if rest\n      (loop [graph rest\n             front front]\n        (if (reduce #(or %1 (connected? front %2)) false graph)\n          (recur (filter #(not (connected? front %)) graph)\n                 (clojure.set/union front (set (flatten (filter #(connected? front %) graph)))))\n          (if (seq graph)\n            false\n            true)))\n      true)))","user":"580a0783e4b0a837a8b30d2c"},{"problem":91,"code":"(fn p-90-connected?\n  ([g] (p-90-connected? (vec (rest g)) (set  (first g))))\n  ([g seen-vertices-set]\n   (println \"== Got G: \" g)\n   (println \"== Got seen vertices: \" seen-vertices-set)\n   (let [rotate-vec (fn [v] (conj (vec (rest v)) (first v)))\n         connected-edge? (fn [[v1 v2]] (or (seen-vertices-set v1) (seen-vertices-set v2)))\n         next-edge (first g)]\n     (cond (empty? g) true ; no more to include\n           (not (some connected-edge? g)) false ; other edges don't connect\n           (connected-edge? next-edge)\n           (p-90-connected? (rest g)\n                            (conj seen-vertices-set\n                                  (first next-edge)\n                                  (second next-edge)))\n           :else (p-90-connected? (rotate-vec g) seen-vertices-set)))))","user":"5bfc9037e4b0bdcf453d15f2"},{"code":"(fn [v]\r\n  (letfn ((rep [v n a]\r\n               (vec `(~@(take n v) ~a ~@(drop (+ n 1) v))))\r\n          (mul [m1 m2]\r\n               (vec (map (fn [i]\r\n                           (vec (map (fn [j]\r\n                                       (reduce (fn [r k]\r\n                                                 (if (> (+ r (* (nth (nth m1 i) k)\r\n                                                                (nth (nth m2 k) j)))\r\n                                                        0)\r\n                                                   1\r\n                                                   0))\r\n                                               0\r\n                                               (range (count m1))))\r\n                                     (range (count m1)))))\r\n                         (range (count m1))))))\r\n         (let [n (apply list (reduce (fn [r v]\r\n                                 (conj r (v 0) (v 1)))\r\n                               #{}\r\n                               v))\r\n               p (reduce (fn [r i]\r\n                           (conj r [(nth n i) i]))\r\n                         {}\r\n                         (range (count n)))\r\n               v (reduce (fn [r v]\r\n                           (conj r v))\r\n                         v\r\n                         (map (fn [v] [(v 1) (v 0)]) v))\r\n               m (loop [v v\r\n                        m (vec (map (fn [i] (vec (map (fn [j]\r\n                                                        (if (= i j)\r\n                                                          1\r\n                                                          0)) (range (count n))))) (range (count n))))]\r\n                   (if (empty? v)\r\n                     m\r\n                     (let [i (p ((first v) 1))\r\n                           j (p ((first v) 0))]\r\n                       (recur (rest v) (rep m i (rep (m i) j 1))))))]\r\n           (loop [m1 m]\r\n             (let [m2 (mul m1 m)]\r\n               (if (= m1 m2)\r\n                 (every? (fn [r]\r\n                           (every? #(= % 1) r))\r\n                         m2)\r\n                 (recur m2)))))))","problem":91,"user":"4de2f44f535d08e6dec9fdec"},{"problem":91,"code":"(fn cn\n  ([edges] (cn #{} edges))\n  ([components edges]\n   (let [combine (fn [[v1 v2] components]\n                   (let [c1 (or (first (filter #(% v1) components))\n                                #{v1})\n                         c2 (or (first (filter #(% v2) components))\n                                #{v2})\n                         union (comp set (partial remove nil?) concat)]\n                     (->> components\n                          (remove #(= c1 %))\n                          (remove #(= c2 %))\n                          (union #{(union c1 c2)}))))]\n     (if (empty? edges)\n       (= 1 (count components))\n       (cn (combine (first edges) components)\n           (rest edges))))))","user":"57a0b341e4b0c3d858beb8d4"},{"code":"(fn graph-connect [lst]\r\n  (letfn [(remain-node [p lst]\r\n  \t       (filter (fn [l] (not-any? #(=  p %) l)) lst))\r\n\t  (get-key [p lst]\r\n\t\t   (remove #(= p %) (set (flatten (filter (fn [l](some #(= p %) l)) lst)))))\r\n\t  ]\r\n  (if (= (count lst) 1)\r\n    true\r\n    (loop [keys (first lst) ls (rest lst)]\r\n      (println keys)\r\n      (println ls)\r\n      (cond (nil? (first keys)) \r\n\t    (= (count ls) 0)\r\n\t    (nil? (first ls)) true\r\n\t    :else (recur (concat (rest keys)\r\n\t\t\t       (get-key (first keys) ls))\r\n\t\t\t (remain-node (first keys) ls)))))))","problem":91,"user":"4ddc620d535d02782fcbea06"},{"code":"(fn [g]\n  (let [[e & r] (map set g)]\n    (loop [a e c (into #{} r)]\n      (if (empty? c)\n        true\n        (if-let \n          [n (some #(when (not \n            (empty? (clojure.set/intersection % a))) %)\n            c)]\n          (recur (clojure.set/union a n) (disj c n))\n          false)))))","problem":91,"user":"4e5411e8535d8a8b8723a279"},{"problem":91,"code":"(fn [i]\n  (letfn [\n(rest-list [l k] (filter #(not (.contains % k)) l))\n(do-extend [g l] (if (empty? l) true\n                  (let [k (first g)\n                        ng (distinct (apply concat (rest g) (filter #(.contains % k) l)))]\n                    (if (empty? ng)\n                      false\n                      (do-extend ng (rest-list l k))))))\n          ]\n    (do-extend (first i) i)))","user":"5632e850e4b0bfe05bf117ac"},{"problem":91,"code":"(fn c91\n  [s]\n  (letfn [(walk [m kys r]\n            (let [ks (reduce #(into %1 (m %2)) #{} kys)\n                  newks (clojure.set/difference ks r)]\n              (if (empty? newks)\n                (if (= r (set (keys m)))\n                  true\n                  false)\n                (walk m newks (into r newks)))))]\n    (let [m (reduce (fn [r [v1 v2]]\n                      (assoc (assoc r\n                                    v2\n                                    (conj (r v2 []) v1))\n                             v1\n                             (conj (r v1 []) v2))) {} s)]\n      (walk m [(first (first m))] #{}))))","user":"57d0cd58e4b0bd073c20235e"},{"code":"(fn [edges]\n  (let [vertices (distinct (apply concat edges))\n        parts (range (count vertices))]\n    (-> (loop [assgn (into {} (map vector vertices parts))]\n          (let [assgn' (reduce\n                         (fn [acc pair]\n                           (let [[from to] (map acc pair)]\n                             (if (= from to)\n                               acc\n                               (into\n                                 {}\n                                 (map (fn [[vertex part]]\n                                        (if (= part from)\n                                          [vertex to]\n                                          [vertex part]))\n                                      acc)))))\n                         assgn\n                         edges)]\n            (if (= assgn' assgn)\n              assgn\n              (recur assgn'))))\n        vals\n        distinct\n        count\n        (= 1))))","problem":91,"user":"52357ca6e4b0a643f2dcb74d"},{"code":"(\n            fn my [g]\n            (let [isVisited\n              (let [isVisitedInitial\n                    (reduce (fn [result, x] (assoc result (first x) false)) {} g)]\n                (\n                  loop [visited isVisitedInitial\n                        vertexToVisit (conj () (first (first visited)))\n                        depth 1]\n                  (if (empty? vertexToVisit)\n                    visited\n                    (if (> depth 10) 1\n                      (let [head (first vertexToVisit)]\n                        (let [tail (set\n                                     (filter (fn [x] (not (visited x)))\n                                       (concat (rest vertexToVisit)\n                                         (flatten (map #(if (= head (first %))\n                                                          (conj '() (last %))\n                                                          (if (= head (last %))\n                                                            (conj '() (first %))\n                                                            '()\n                                                            )\n                                                          )\n                                                    g)))\n                                       ))]\n\n\n                          (recur (assoc visited head true) tail (inc depth))\n                          )\n                        )\n                      )\n                    )\n                  )\n                )\n\n              ]\n              (every? true? (vals isVisited))\n              )\n            )","problem":91,"user":"51b5a6e0e4b0f094dd986fce"},{"problem":91,"code":"(fn [edges]\n  (let [vs (flatten (seq edges))\n        g (apply merge-with into (mapcat (fn [[a b]] [{a #{b}} {b #{a}}]) edges))\n        f (fn f [g a b]\n            (if ((g a) b)\n              true\n              (some true? (for [c (g a)] (f (update-in g [a] disj c) c b)))))]\n    (every? true? (for [a vs, b vs] (f g a b)))))","user":"57d418b4e4b0bd073c20239a"},{"problem":91,"code":"(fn connected? [G]\n  (letfn [(adj-list2 [R] ;;given relations construct adj-list\n            (let [R2 (concat R (mapv (fn [[a b]] [b a]) R))]\n              (reduce #(if (contains? %1 (first %2))\n                         (assoc %1 (first %2) (conj (%1 (first %2)) (last %2)))\n                         (assoc %1 (first %2) [(last %2)] )) {}  R2)))\n\n          (df-search3 [G v R];;df-search on inicial vertex r. R is a set that contains all vertex that r can reach and v is a reacheable vertex\n            (let [neib (G v)]\n              (reduce #(if (contains? %1 %2)\n                         %1\n                         (clojure.set/union %1 (df-search3 G %2 (conj %1 %2)))) R (G v))))\n          ]\n    (let [adj (adj-list2 G)\n          ks (set (keys adj))\n          reach (df-search3 adj (first ks) #{})]\n      (= ks reach))))","user":"574f1c24e4b02ea114799255"},{"problem":91,"code":"(fn graph-connectivity\n  ([es] (graph-connectivity (set (first es)) (rest es)))\n  ([in-set remaining]\n   (if (empty? remaining)\n     true\n     (let [partitioned (group-by #(not (some in-set %)) remaining)]\n       (if (partitioned false)\n         (graph-connectivity (clojure.set/union in-set (set (flatten (partitioned false))))\n                           (partitioned true))\n         false)))))","user":"5d1b2b7de4b02ea6f0fb697a"},{"code":"(fn [coll]\n  (let [members (set (apply concat coll))\n        mcount (count members)]\n    (= (* mcount mcount)\n       (count \n        (loop [coll coll]                \n          (let [x (set (concat coll                                      \n                               (for [[a b] coll [c d] coll :when (= b c)] [a d])                                     \n                               (map reverse coll)))]                  \n            (if (= x coll)                     \n              x                    \n              (recur x))))))))","problem":91,"user":"500aa15ee4b03d00572d2d76"},{"problem":91,"code":"(fn [xset]\n  (letfn [(con_xy [ret [x y]]\n    (loop [one (set [x y]), nret #{}, [h & t :as oret] (seq ret)] \n      (if (empty? oret)\n        (conj nret one)\n        (if (or (h x) (h y))\n          (recur (into one h) nret t)\n          (recur one (conj nret h) t)))))]\n  (= 1 (count (reduce con_xy #{} xset)))))","user":"593f95d8e4b069cdc2982be3"},{"problem":91,"code":"; Evil hack\n(fn [& _]\n  (reify Object\n    clojure.lang.IPersistentCollection\n    (seq [_])\n    (cons [_ _])\n    (empty [_])\n    (equiv [_ _] true)))","user":"51e58e02e4b0efabf93c02d0"},{"code":"(letfn [(add-edge [graph u v]\n          (update-in graph [u] (fnil #(conj % v) #{})))\n        (build-graph [edges]\n          (reduce (fn [graph [u v]] (-> graph (add-edge u v) (add-edge v u)))\n                  {}\n                  edges))\n        (dfs [graph visited start]\n          (reduce #(into %1 (dfs graph %1 %2))\n                  (conj visited start)\n                  (clojure.set/difference (graph start) visited)))]\n  (fn connected? [edges]\n    (let [graph   (build-graph edges)\n          vertice (set (keys graph))]\n      (= vertice (dfs graph #{} (first vertice))))))","problem":91,"user":"50586354e4b06522596eba78"},{"code":"(fn [edges]\r\n  (let [nodes (reduce into #{} edges)\r\n        edge-map (reduce (fn [m [x y]] (-> m (update-in [x] conj y) (update-in [y] conj x))) {} edges)] \r\n    (loop [s #{(first nodes)}]\r\n      (let [new-s (into s (flatten (vals (select-keys edge-map s))))]\r\n        (cond\r\n          (= new-s nodes) true\r\n          (= new-s s) false\r\n          :else (recur new-s))))))","problem":91,"user":"4db85282535d1e037afb218a"},{"problem":91,"code":"(fn [nodes-in]\n   (if (= 1 (count nodes-in))\n     true\n     (let [nodes (set (map set nodes-in))\n           node-pairs (into #{} (for [node-a nodes\n                                      node-b nodes\n                                      :when (not= node-a node-b)]\n                                  #{node-a node-b}))\n           add-node-to-paths (fn [paths node]\n                               (reduce #(conj %1 %2) paths node))\n           find-nodes-to-add (fn [paths nodes]\n                               (filter\n                                (fn [node]\n                                  (and\n                                   (some #(contains? paths %) node)\n                                   (not-every? #(contains? paths %) node)))\n                                nodes))\n           path? (fn [nodes start-node end-node]\n                   (loop [paths start-node]\n                     (let [nodes-to-add (find-nodes-to-add paths nodes)]\n                       (if (empty? nodes-to-add)\n                         (every? #(contains? paths %) end-node)\n                         (recur (reduce #(add-node-to-paths %1 %2) paths nodes-to-add))))))]\n       (loop [node-pair (first node-pairs) rest-node-pairs (rest node-pairs)]\n         (if (empty? node-pair)\n           true\n           (if (path? nodes (first node-pair) (last node-pair))\n             (recur (first rest-node-pairs) (rest rest-node-pairs))\n             false))))))","user":"564c8e99e4b0284900eef674"},{"problem":91,"code":"(fn connected?\n    ([nodes remaining-attempts [[a b] & remaining-links]]\n      (or\n        (and\n          (or (empty? nodes) (nodes a) (nodes b))\n          (or (empty? remaining-links) (connected? (conj nodes a b) (count remaining-links) remaining-links)))\n        (and (pos? remaining-attempts)\n             (connected? nodes (dec remaining-attempts) (concat remaining-links [[a b]])))))\n    ([links] (connected? #{} (count links) (into [] links))))","user":"51e28063e4b08e53a149f0f2"},{"problem":91,"code":"(fn t91 [edges]\n (let [nodes (set (apply concat edges))]\n   (loop [visited #{} to_visit [(first edges)]]\n     (if (empty? to_visit)\n       (= visited nodes)\n       (let [[a b] (first to_visit)]\n         (recur (conj visited a b)\n                (concat (rest to_visit) \n                        (for [x edges\n                              :when (not (visited (second x)))\n                              :when (or (= b (first x)) (= a (first x)))]\n                          x))))))))","user":"5046f909e4b03b02161376b5"},{"problem":91,"code":"(fn g [c] \n  (let [r (loop [s (clojure.set/union c (map reverse c))]\n            (let [n (into s\n                          (for [[a b] s [c d] s\n                                :when (= b c)] \n                            [a d]))]\n              (if (= n s) n (recur n))))\n        p (into #{} (for [a (apply concat c)\n                b (apply concat c)] \n            [a b]))]\n    (= r p)))","user":"5c1aadcde4b01240ff567209"},{"problem":91,"code":"(let [closure (let [prod (fn [u v]\n  (set (reduce \n        (fn [a x] \n          (concat a \n                  (map #(vector x %) v))) \n          [] u)))\n      nxt (fn nxt [ls]\n        (clojure.set/union ls\n        (into #{} \n              (map \n               #(vector (first (first %)) (second (second %))) \n               (filter \n                #(= (second (first %)) (first (second %))) \n                (prod ls ls))))))]\n  (fn [s]\n    (loop [s s\n           n (nxt s)]\n      (if (= s n)\n        s\n        (recur n (nxt n))))))]\n  (fn [edges]\n    (let [verts (count (distinct (flatten (into '() edges))))]\n    (= (* verts verts)\n       (count (closure \n               (clojure.set/union edges \n                                  (into #{} (map #(vector (second %) (first %)) edges)))))))))","user":"541ef7e2e4b01498b1a71a92"},{"problem":91,"code":"(fn [E]\n  (let [G (reduce (fn [R [a b]] (assoc R a (conj (R a #{}) b) b (conj (R b #{}) a))) {} E)\n        C (loop [R #{(first (keys G))}]\n            (let [D (mapcat (fn [v] (apply disj (G v) R)) R)]\n              (if (empty? D) R (recur (into R D)))))]\n    (and (= (count C) (count G))\n         (<= (count (filter (fn [v] (= 1 (mod (count v) 2))) (vals G))) 4))))","user":"55f6fe09e4b06e875b46cea2"},{"problem":91,"code":"(fn graph-connectivity [sets]\n  (letfn [(adjoining-vector [k-node nodes sets]\n            (map (fn [node]\n                    (when (or\n                           (contains? sets [k-node node])\n                           (contains? sets [node k-node]))\n                      node)) nodes))\n          (graph [nodes sets]\n            (apply merge\n             (map (fn [node]\n                    {node (adjoining-vector node nodes sets)}) nodes)))\n          (exist-chain? [init graph visited-set]\n            (if (= (set (keys graph)) visited-set)\n              true\n              (some #(when (and %\n                                (not (visited-set %)))\n                       (exist-chain? %\n                                     graph\n                                     (clojure.set/union #{%} visited-set)))\n                    (graph init))))]\n    (let [nodes (set (apply concat sets))\n          graph (graph nodes sets)]\n      (true? (some #(exist-chain? % graph #{%}) nodes)))))","user":"5693a53ee4b0dcc4269f4106"},{"problem":91,"code":"(fn [edge_set]\n    (let [compute_vertex_set\n  (fn [s]\n    (apply clojure.set/union (map set s)))\n          get_component\n  (fn [components vertex]\n    (loop [comps components]\n      (if (empty? comps)\n        (throw (AssertionError. \"Component not found!\"))\n        (let [[comp_id nodes] (first comps)]\n          (if (contains? nodes vertex)\n            comp_id\n            (recur (rest comps)))))))\n          vertex_set (compute_vertex_set edge_set)\n          initial_components (into {} (map (fn [x] [x #{x}]) vertex_set))]\n      (loop [edges edge_set\n             components initial_components]\n        (if (empty? edges)\n          (= (count components) 1)\n          (let [[x y] (first edges)\n                c_x (get_component components x)\n                c_y (get_component components y)\n                nodes_x (get components c_x)\n                nodes_y (get components c_y)\n                components_minus_x (dissoc components c_x)\n                components_minus_xy (dissoc components_minus_x c_y)\n                components_union_xy (assoc components_minus_xy\n                                           c_x\n                                           (clojure.set/union nodes_x nodes_y))]\n            (recur (rest edges) components_union_xy))))))","user":"5a34f342e4b0ddc586f153d1"},{"code":"(fn [e]\n  (let [e (->> e (map set))]\n   (loop [n #{(-> e first first)}]\n     (let [n-e \n           (filter #(not-empty (clojure.set/intersection n %)) e)\n           n-n (into n (->> n-e (map vec) flatten))]\n     (if (not= n n-n)\n         (recur n-n)\n      \t (if (= n-e e)\n        \t true\n         \tfalse))))))","problem":91,"user":"5054bc87e4b0b1b9d1860eb0"},{"problem":91,"code":"(fn [es]\n  (let [nodes (set (apply concat es))\n        es' (filter (fn [[u v]] (not= u v)) es)\n        edges (set (into es' (for [[u v] es'] [v u])))]\n    (= (* (count nodes) (dec (count nodes)))\n       (count\n        (loop [cur edges]\n          (let [addl (for [[u v] cur [w x] cur :when (and (= v w) (not= u x))] [u x])\n                nxt (set (into cur addl))]\n            (if (= nxt cur) nxt (recur nxt))))))))","user":"52ce1abfe4b07d0d72b27389"},{"code":"(fn connected? [edges]\n  (let [trees (reduce\n              (fn [ans edge]\n                (let [[l-root r-root] (map #(first (drop-while ans (iterate ans %))) edge)]\n                  (if (= l-root r-root) ans (assoc ans l-root r-root))))\n              {}\n              edges)]\n    (not (second (distinct (remove trees (apply concat edges)))))))","problem":91,"user":"506ab9bae4b05d3b7762c74c"},{"code":"(fn connected [edges]\n  (let [vertices (set (apply concat edges))\n        connected-vertices (fn connected-vertices\n                             ([vertex] (connected-vertices vertex #{}))\n                             ([vertex cache]\n                               (let [adjacent-vertices (->> (apply concat (filter #(contains? (set %) vertex) edges))\n                                                            (filter #(not (contains? cache %)))\n                                                       )]\n                                 (if (empty? adjacent-vertices)\n                                   cache\n                                   (set (mapcat #(connected-vertices % (set (conj cache %))) adjacent-vertices))\n                                 )\n                               )\n                             )\n                           )\n       ]\n    (every? #(= vertices (connected-vertices %)) vertices)\n  )\n)","problem":91,"user":"5272d4b7e4b03e8d9a4a7453"},{"problem":91,"code":"(fn isconnected ([edges]\n                   (isconnected (vec edges) #{}))\n    ([[[s e] & rst] components]\n     (if-not s\n       (= (count components) 1)\n       (let [component-cointaining (fn [elem]\n                                     (or\n                                       (first (filter #(% elem) components))\n                                       #{elem}))\n             s-comp (component-cointaining s)\n             e-comp (component-cointaining e)]\n         (recur rst (conj  (disj components  e-comp s-comp) (clojure.set/union e-comp s-comp)))))))","user":"5c9dcb36e4b048ec896c5b1d"},{"code":"(fn [s]\n  (apply = (vals (reduce \n                  (fn [g [a b]]\n                    (let [r (reduce conj (g a #{a}) (g b #{b}))]\n                      (reduce #(assoc % %2 r) g r)))\n                  {} s))))","problem":91,"user":"52bf29fde4b07a9af579232e"},{"problem":91,"code":"(fn [g]\n  (let [no (set (mapcat identity g))\n        dv (concat g (map reverse g))\n        c (apply hash-map\n                 (mapcat identity\n                         (for [a no]\n                           (list a (for [[x y] dv :when (= x a)] y)))))]\n    (loop [b #{} a (set (list (first no)))]\n                      (if (= b a)\n                        (if (= (count no) (count a)) true false)\n                        (recur a (set (concat a (mapcat c a))))))))","user":"5a621702e4b0512ff01cd983"},{"code":"(fn connected? [x]\n  (loop [i (first x)\n         rst (rest x)]\n    (if (empty? rst) \n      true\n      (let [found (filter #(some (set i) %) rst)]\n        (if (empty? found)\n          false\n          (recur \n           (apply concat i found)\n           (remove (set found) rst)))))))","problem":91,"user":"50e4f4e9e4b049a987753896"},{"problem":91,"code":"(fn connected? [graph]\n  (if (= 1 (count graph))\n    true\n    (let [head (first graph)\n          tail (flatten (rest graph))]\n      (if (contains? (set tail) (first head))\n        (connected? (set (partition 2 (map #(if (= % (first head)) (second head) %) tail))))\n        false))))","user":"55a74d46e4b09e57187da2a3"},{"problem":91,"code":"(fn graph-connect [g-set]\n  (letfn [(adjacent? [p c-set]\n                     (reduce (fn [c? c-p]\n                               (or c? \n                                   (= (first p) (second c-p))\n                                   (= (second p) (first c-p))\n                                   (= (first p) (first c-p))\n                                   (= (second p) (second c-p))))\n                             false\n                             c-set))]\n    (loop [conn-set (conj #{} (first (seq g-set)))\n           disconn-set (rest (seq g-set))]\n      (if (empty? disconn-set)\n        true\n        (let [n-group (group-by #(adjacent? % conn-set) disconn-set)\n              adj-set (get n-group true)\n              n-adj-set (get n-group false)]\n          (if (empty? adj-set)\n            false\n            (recur (into conn-set adj-set)\n                   n-adj-set)))))))","user":"585e2e77e4b0f14aab7c87ac"},{"problem":91,"code":"(fn [edges]\n  (let [edges (shuffle (vec edges))]\n    (letfn [(connected?[[x y]]\n              \"Does an edge connect two nodes?\"\n              (not-empty (clojure.set/intersection (set  x) (set y))))\n\n            (any-connections? [edges]\n              \"Can any of the nodes we have connect up?\"\n              (some connected?\n                    (for [x edges\n                          y edges\n                          :when (not= x y)]\n                      [x y])))]\n\n      (let [[h t & r] edges]\n        (cond\n          (= 1 (count edges)) true\n          (not (any-connections? edges)) false\n          :else (if (connected? [h t])\n                  (recur (concat [(into h t)] r))\n                  (recur (concat [t] r [h]))))))))","user":"56069006e4b08b23635d3174"},{"code":"(fn [ls]\n  (loop [s (set (first ls)) r (rest ls)] \n    (or (empty? r)\n        (let [{linked true unlinked nil} (group-by #(some (comp boolean s) %) r)]\n          (if (seq linked)\n            (recur (reduce into s linked) unlinked)\n            false)))))","problem":91,"user":"5003ee7de4b0678c553fc446"},{"code":"(fn [n]\n    (= 1 (count (let [graph (vec n)\n                      nodes (distinct (flatten graph))]\n                  (loop [n 0 grps graph]\n                    (if (= n (count nodes) ) grps\n                        (let [   x (nth nodes n)\n                              grps (group-by #(some #{x} %) grps)\n                              pgrps  (flatten (grps x))\n                              ngrps  (grps nil)\n                              ]\n                          (recur (inc n) (cons pgrps ngrps) )\n                          )))))))","problem":91,"user":"5124619ae4b02c3f2a072ccd"},{"problem":91,"code":"(fn [x] (let [nodes (set (apply concat x))\n\t\t\t  j (fn [sets [a b]] \n\t\t\t\t\t(let [sa (first (filter #(some #{a} %) sets))\n\t\t\t\t\t\t  sb (first (filter #(some #{b} %) sets))]\n\t\t\t\t\t\t  (clojure.set/union (disj sets sa sb) #{(clojure.set/union sa sb)})))]\n\t\t\t\t\t\t  (println nodes (reduce j (set (map #(conj #{} %) nodes)) x))\n\t\t\t\t\t\t  (= 1 (count (set (reduce j (set (map #(conj #{} %) nodes)) x))))))","user":"53e19461e4b0d874e779ae59"},{"code":"(fn [s]\n  (loop [t s n {}]\n    (if (empty? t)\n\t  (= (count (distinct (vals n))) 1)\n      (let [x (first t) a (first x) z (second x)]\n\t    (recur (rest t)\n          (if (n a)\n\t\t    (if (n z)\n              (if (= (n a) (n z))\n\t\t        n\n   \t\t        (zipmap (keys n) (replace {(n z) (n a)} (vals n)))\n\t\t      )\n              (assoc n z (n a))\n            )\n            (if (n z)\n              (assoc n a (n z))\n              (assoc n a a z a)\n            )\n          )\t\t\t\n        )\n      )\n    )   \n  )\n)","problem":91,"user":"5176afd2e4b085adf681d889"},{"code":"(fn is-connected[graph]\n\t(letfn [(graph-nodes[graph]\n\t\t\t\t(into #{} (mapcat identity graph))\n\t\t\t)\n\t\t\t(connected-nodes [graph node-set]\n\t\t\t\t(graph-nodes (filter (fn [edge]\n\t\t\t\t\t\t\t(let [[s e] edge]\n\t\t\t\t\t\t\t\t(or (node-set s) (node-set e))\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t) graph)\n\t\t\t\t)\n\t\t\t)\n\t\t\t]\n\t\t(let [nodes (graph-nodes graph) a-node (first nodes)\n\t\t\ta-node-closure (loop [node-set #{a-node}]\n\t\t\t\t\t\t\t\t(let [connected (connected-nodes graph node-set)]\n\t\t\t\t\t\t\t\t\t(if (= connected node-set)\n\t\t\t\t\t\t\t\t\t\tnode-set\n\t\t\t\t\t\t\t\t\t\t(recur connected)\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t)\n\t\t\t]\n\t\t\t(= a-node-closure nodes)\n\t\t)\t\t\n\t)\n)","problem":91,"user":"52763696e4b03e8d9a4a74d7"},{"problem":91,"code":"(let [fixpoint\n      (fn [f x]\n        (loop [current x]\n          (let [next (f current)]\n            (if (= next current)\n              next\n              (recur next)))))\n      neighbours\n      (fn [v edges]\n        (map second\n             (filter #(= (first %) v) \n                     (concat edges\n                             (map reverse edges)))))]\n  \n  (fn connected?\n    [dumb-edges]\n    (let [edges (into [] dumb-edges)]\n      (let [expand\n            (fn [in]\n              (sort (into #{} (concat in (mapcat #(neighbours % edges) in)))))]\n        (= (fixpoint expand (first edges))\n           (sort (into #{} (flatten edges))))))))","user":"58152157e4b0f478707a0631"},{"code":"(fn [i-set]\r\n     (let [\r\n           nodes (reduce\r\n                   #(conj (conj %1 (first %2)) (last %2))\r\n                   #{}\r\n                   i-set)\r\n\r\n           n-count (count nodes)\r\n           n-range (range n-count)\r\n           n-map (apply hash-map (interleave nodes n-range))\r\n           n-index (fn [i-node] (get n-map i-node))\r\n\r\n           edges (concat i-set (map #(apply vector (reverse %)) i-set))\r\n           grouped-edges (group-by #(n-index (first %)) edges)\r\n\r\n           n-dest (fn [i-node]\r\n                      (map last (get grouped-edges (n-index i-node))))\r\n           walk-graph (fn discover\r\n            ([i-node] (discover #{} (hash-set i-node)))\r\n            ([result discovered]\r\n             (if (zero? (count discovered))\r\n               result\r\n               (let [\r\n                     current (first discovered)\r\n                     n-result (conj result current)\r\n                     new-nodes (filter #(not (contains? n-result %)) (n-dest current))\r\n                     ]\r\n                 (discover n-result (reduce conj (apply hash-set (rest discovered)) new-nodes))))))\r\n           ]\r\n       (= nodes (walk-graph (first (first i-set))))))","problem":91,"user":"4dddf817535d08e6dec9fdd3"},{"problem":91,"code":"(fn [v]\n  (let [sv (set (reduce (fn [s [x y]] (conj s x y)) [] v))]\n    (= sv (last (take (count sv)\n                      (iterate (fn [xs]\n                                 (reduce (fn [s [l r]]\n                                           (cond (contains? s l) (conj s r)\n                                                 (contains? s r) (conj s l)\n                                                 :else s)) xs v)) #{(first sv)})))))\n  )","user":"5921a080e4b09b4ee5954c77"},{"code":"(fn graph [g]\n  (let [edges (clojure.set/union g (map reverse g))\n        n1 (group-by first edges)\n        nd (fn [x] {(first x) (map second (second x))})\n        nodes (into {} (mapcat nd n1))]\n    (loop [visited {}\n           q [(first nodes)]]\n      (if (empty? q) (= nodes visited)\n          (let [x (first q)\n                nxt (filter #(contains? (set (val x)) (key %)) nodes)]\n            (if (get visited (key x))\n              (recur visited (rest q))\n              (let [v2 (merge visited x)\n                    q2 (concat (rest q) nxt)]\n                (recur v2 q2))))))))","problem":91,"user":"4fbd12a5e4b081705acca2fd"},{"problem":91,"code":"(fn [s]\n           (let [m (reduce-kv (fn [m k v] (assoc m k (mapv second v))) {} (group-by first (concat s (map (juxt second first) s))))]\n             (loop [unv (set (mapcat identity (drop 1 s))) v (set (first s))]\n               (let [nv (set (mapcat #(get m %) v))\n                     unv2 (remove nv unv)]\n                 (if (= unv unv2) (empty? unv) (recur unv2 nv))))))","user":"5310e968e4b08068f379ecdd"},{"problem":91,"code":"(fn [coll]\n  (let [incident (reduce (partial merge-with clojure.set/union)\n                         (flatten (map (fn [[x y]] [{x #{y}} {y #{x}}]) coll)))\n        vertices (into #{} (keys incident))\n        a-vertex (first vertices)\n        find-vertices (fn [to-explore found]\n                        (if (empty? to-explore)\n                          found\n                          (let [new (clojure.set/difference (incident (first to-explore)) found)]\n                            (recur (concat (rest to-explore) new) (clojure.set/union found new)))))]\n    (= vertices (find-vertices (list a-vertex) #{a-vertex}))))","user":"5ec6de19e4b08d0ec38692da"},{"code":"(fn [el]\r\n  (let [g (apply merge-with\r\n    #(into %1 %2)\r\n    (apply concat\r\n      (map (fn [[k v]]\r\n        [{k #{v}} {v #{k}}]) el)))]\r\n(if (some #(= (count %) (count g))\r\n(flatten ((fn p [n sn]\r\n  (if (sn n)\r\nsn\r\n(for [x (g n)]\r\n(p x (conj sn n)))))\r\n(ffirst g) #{})))\r\ntrue false)))","problem":91,"user":"4dc986d0535d5973398f9285"},{"problem":91,"code":"(fn __ [d]\n(letfn [(isce [a b]\n (> (count (clojure.set/intersection (into #{} a) (into #{} b))) 0))\n(somcon [a ans]\n (not= 0 (count (filter #(true? %) \n   (for [b ans]\n     (isce a b))))))\t\n(getgroup [ds]\n (let [vs (into [] ds)]\n  (loop [v vs i 0 n (count vs) acc []]\n   (if (= i 0) (recur (rest v) (inc i) n (conj acc (first v)))\n    (if (= i n) acc\n      (recur (rest v) (inc i) n\n      \t     (if (somcon (first v) acc)\n\t     \t (conj acc (first v))\n\t\t acc)))))))\n(conup [s]\n (loop [m s acc []]\n  (if (empty? m) acc\n   (let [ans (getgroup m)]\n    (recur (clojure.set/difference m ans)\n    \t   (conj acc (distinct (flatten ans))))))))]\n  (loop [m (into #{} (conup d)) prevn 0]\n    (if (= (count m) prevn)\n    \t(= 1 (count m))\n    (recur (into #{} (conup m)) (count m))))))","user":"52747090e4b03e8d9a4a74a5"},{"code":"(fn [ee]\n  (let [v (set (flatten (seq ee)))]\n    (letfn [(visit [seen n]\n                   (let [seen (conj seen n)\n                         neighbours (flatten (filter #(or (= n (% 0)) (= n (% 1))) ee))]\n                     (reduce #(if (% %2) % (visit % %2)) seen neighbours)))]\n    (= v (visit #{} (first (first ee)))))))","problem":91,"user":"4e8b98fc535d65386fec2124"},{"problem":91,"code":"(fn [graph]\n  (= 1\n     (count\n      (reduce (fn [components [a b]]\n                      (let [connected-to-a (set (filter #(% a) components))\n                            connected-to-b (set (filter #(% b) components))\n                            components (clojure.set/difference components connected-to-a)\n                            components (clojure.set/difference components connected-to-b)\n                            new-component (set (concat [a b] (apply concat connected-to-a) (apply concat connected-to-b)))]\n                        (conj components new-component))) #{} graph))))","user":"547d8e93e4b0c51c1f4d72f4"},{"code":"(fn connected? [g]\n     (let [nodes (set (mapcat flatten g))]\n     (loop [[h & more :as rm] [(first nodes)] seen #{}]\n         (if (= seen nodes)\n             true\n             (if (seq rm)\n                (let [neighbors\n                (->> g (map (fn [[e1 e2]] (if (= e1 h) e2 (if (= e2 h) e1 nil))))\n                     set (remove #(or (nil? %) (seen %))) vec)]\n                (recur (concat more neighbors) (conj seen h)))\n                 false)))))","problem":91,"user":"4eb0a757535d7eef3080733d"},{"code":"(fn [gr]\n    (let [transitive (fn [r]\n                       (let [g (group-by first r)\n                             m (apply concat\n                                      (map\n                                       (fn [x] (apply concat\n                                                      (map\n                                                       (fn [y] (map #(do [x (second %)])\n                                                                    (get g y)))\n                                                       (map second (get g x)))))\n                                       (keys g)))\n                             next (if (set? r) (into r m) (into #{} r m))]\n                         (if (= next r)\n                           r\n                           (recur next))))\n          ug (into gr (map (fn [[a b]] [b a]) gr)) ; undirected graph\n          reachable (group-by first (transitive ug))]\n      (= (count (get reachable (first (first (seq gr)))))\n         (count (into #{} (apply concat (seq gr)))))))","problem":91,"user":"4fe8aef4e4b07c9f6fd12c6c"},{"code":";; Go for simplicity of implementation rather than optimal run-time\n;; performance.\n\n;; Maintain a set of node sets, where each node set is the set of\n;; nodes in one connected component of the graph.\n\n;; It starts out empty, and for each edge examined, we find the set s\n;; containing node 1 (if any), and the set t containing node 2 (if\n;; any), remove both of those sets, and add their union.\n\n(fn [edges]\n  (= 1 (count (reduce (fn [c [u v]]\n                        (let [s (or (first (filter #(% u) c)) #{u})\n                              t (or (first (filter #(% v) c)) #{v})]\n                          (conj (disj c s t) (clojure.set/union s t))))\n                      #{} edges))))","problem":91,"user":"500d8c49e4b07ccb9a7ddb00"},{"code":"(fn [es]\n  (let [vs (-> es seq flatten distinct set)]\n    ((fn conn [es cv]\n      (let [\n            ncv (->\n                 (map\n                  (fn [x] (filter #(or (= (first %) x) (= (second %) x)) es))\n                  cv)\n                 flatten distinct set\n                 )\n            ]\n        (if (= ncv vs)\n          true\n          (if (= ncv cv)\n            false\n            (conn es ncv)\n            ))\n        )\n      ) es #{(first vs)})\n    )\n  )","problem":91,"user":"52586d24e4b0cb4875a45cb0"},{"problem":91,"code":"(letfn\n    [(connected? [g] (c? #{} (clojure.set/union (set (map first g)) (set (map second g))) g))\n     (internal-links [n g]\n       (filter #(every? n %) g))\n     (reachable-links [n g]\n       (filter #(some n %) g))\n     (reachable-nodes [n g]\n       (let [l (reachable-links n g)]\n         (println [:reachable-links l])\n         (and l (set (apply concat (map #(remove g %) l))))))\n     (c? [nc nr g]\n       (println [:nc nc :nr nr :g g])\n       (or (empty? nr)\n           (let [more-nodes (if (empty? nc) #{(first nr)} (reachable-nodes nc g))]\n             (and (not (empty? more-nodes))\n                  (let [nc-new (reduce conj nc more-nodes)]\n                    (c?\n                     nc-new\n                     (clojure.set/difference nr (set more-nodes))\n                     (clojure.set/difference g (internal-links nc-new g))))))))]\n  #(connected? %))","user":"5b3f2ba9e4b02d533a91bc09"},{"code":"(fn [g]\n  (let [nodes (reduce (fn [vs [u v]] (conj vs u v)) #{} g)]\n    (loop [us [(first nodes)] reached #{(first nodes)}]\n      (let [newly-reached\n            (for [u us [a b] g\n                  :let [x (cond (= u a) b (= u b) a)]\n                  :when (and x (not (reached x)))]\n              x)]\n        (if (empty? newly-reached)\n          (= reached nodes)\n          (recur newly-reached (into reached newly-reached)))))))","problem":91,"user":"504c8165e4b09724c857af31"},{"problem":91,"code":"(letfn [(build-graph [tuples]\n                       (loop [tuples (seq tuples) acc {}]\n                         (if (seq tuples)\n                           (recur (rest tuples) (bi-connect acc (first tuples))  )\n                           acc)))\n          (connect [graph a b]\n                   (update-in graph [a] #((fnil conj []) %1 b)))\n          (bi-connect [graph [a b]]\n                      (connect (connect graph a b) b a))\n          (visit \n            [graph fringe visited]\n            (let [extend-fringe (fn [] \n                                  (reduce #(if (visited %2) %1 (conj %1 %2))   \n                                          (pop fringe) (graph (peek fringe)))) \n                  ]\n              (if (seq fringe ) \n                (recur graph (extend-fringe) (conj visited (peek fringe)))\n                (count visited))\n              ))\n          \n          (connected \n            [tuples] \n            (let [graph (build-graph tuples)\n                  visited (visit graph (conj clojure.lang.PersistentQueue/EMPTY (first (first tuples))) #{})]\n              (= visited (count (keys graph))))\n            )\n          ]\n    connected)","user":"50eddbc4e4b06330c1f87c4b"},{"problem":91,"code":"(fn connected? [graph]\n   (let [neighbors (apply merge-with into (for [[a b] graph :when (not= a b)] {a #{b} b #{a}}))\n         nodes     ((comp set distinct flatten seq) graph)]\n     (loop [unvisited    nodes\n            path         (list) \n            current-node (first nodes)]\n       (if (nil? current-node)\n         (empty? unvisited)\n         (let [next-node (first (filter unvisited (get neighbors current-node)))]\n           (if (nil? next-node)\n             (recur (disj unvisited current-node)\n                    (rest path)\n                    (first path))\n             (recur (disj unvisited current-node)\n                    (conj path current-node)\n                    next-node)))))))","user":"545e9cf1e4b01be26fd7467f"},{"code":"(fn connected [graph]\n  (loop [[[a b :as e] & edges] (sort (concat graph (mapv (fn [[x y]] [y x]) graph)))\n         unmatched #{}\n         nodes #{a}]\n    (cond\n     (or (contains? nodes a) (contains? nodes b))\n       (recur edges (disj unmatched e) (into nodes e))\n     (empty? edges) (empty? unmatched)\n     :else (recur edges (conj unmatched e) nodes)\n     )\n    )\n  )","problem":91,"user":"52e59ca5e4b09f7907dd1464"},{"code":"#(odd? (count %))","problem":91,"user":"515e8ce2e4b049add99a053d"},{"code":"(fn [g] (let [v (reduce #(into % %2) #{} g)\n                      vs (set (map (comp set list) v))\n                      connect (fn [vs [e1 e2]]\n                                (let [es (filter #(or (% e1) (% e2)) vs)]\n                                  (cond (= 1 (count es)) vs\n                                    :else (conj (apply disj vs es) \n                                                (into (first es) (second es))))))]\n                  (= 1 (count (reduce connect vs g)))))","problem":91,"user":"5246e945e4b0644eb7b0783b"},{"code":"(fn gc [graph]\n   (let [vertexes (set (mapcat identity graph))\n         found? (fn [vert s] (some #(= % vert) s))\n         get-pend (fn [p edge s] (if (found? (p edge) s) #{} (set(filter #(and(not= edge %)(found? (p edge) %)) graph))))\n         ]\t\n\t\t(loop [pending #{(first graph)} found #{}]\n          (cond (= found vertexes) true\n                (empty? pending) false\n                :else (recur \n                       (concat (rest pending) \n                               (get-pend first (first pending) found)\n                               (get-pend last  (first pending) found))\n                       (conj found (first (first pending)) (last (first pending)))\n                       )\n                )\n     \t)\n     )\n )","problem":91,"user":"5274eb56e4b03e8d9a4a74bb"},{"problem":91,"code":"(fn [es]\n  (letfn [(rep [fa x]\n            (if (= x (get fa x x))\n              x\n              (rep fa (fa x))))\n          (mer [fa [u v]]\n            (assoc fa (rep fa u) (rep fa v)))]\n    (let [fa (reduce mer {} es)]\n      (apply = (map (partial rep fa)\n                    (keys fa))))))","user":"55c4e48be4b0e31453f649a7"},{"problem":91,"code":";ある頂点から辿り着ける全ての頂点を列挙する\n;列挙したものが全て全頂点になればtrue\n;(グラフが連結ならtrue)\n(fn [s]\n (apply = (vals (reduce (fn [g [a b]] (let [r (reduce conj (g a #{a}) (g b #{b}))] (reduce #(assoc % %2 r) g r))) {} s))))","user":"5b0180cfe4b0cc2b61a3bd47"},{"code":"(fn [edges]\n  (let [paths (apply merge-with into\n                     (mapcat (fn [[a b]]\n                               [{a #{b}}\n                                {b #{a}}])\n                             edges))\n        reachable (nth (iterate (fn [reach]\n                                  (into {}\n                                        (map (fn [[k v]]\n                                               [k (into v (mapcat #(get reach % #{}) v))])\n                                             reach)))\n                                (into paths (map (fn [[k v]] [k (conj v k)]) paths)))\n                       (count edges))]\n    (= (first (vals reachable)) (set (keys reachable)))))","problem":91,"user":"4ffc10aae4b0678c553fc3d6"},{"problem":91,"code":"(fn [edge-list]\n  (let [graph (apply merge-with \n                #(into %1 %2) \n                (apply concat \n                  (map (fn [[k v]] [{k #{v}} {v #{k}}]) edge-list)))] \n    (if (some #(= (count %) (count graph)) \n              (flatten \n                ((fn paths [node seen] \n                   (if (seen node) \n                     seen\n                     (for [x (graph node)] \n                       (paths x (conj seen node))))) \n                 (ffirst graph) #{}))) \n      true false)))","user":"53f75957e4b0de5c4184855d"},{"problem":91,"code":"(fn connected? [graph]\n  (loop [g graph\n         parsed #{(first (first graph))}]\n    (if (nil? g) true\n      (let [spanned-g (group-by (fn [[from to]] (or (contains? parsed from) (contains? parsed to))) g)\n            filtered-rest (spanned-g false)\n            filtered-out (spanned-g true)\n            new-parsed (into parsed (flatten filtered-out))]\n        (if (= filtered-rest g) false\n          (recur filtered-rest new-parsed))))))","user":"53c38b8ce4b00fb29b22127b"},{"code":"(fn [a]\n           (let [sa (set (map set a))\n                c (reduce #(if (some % %2) (into % %2) %) sa)\n                n (into #{} (flatten (seq a)))]\n                (if (= c n) true false)))","problem":91,"user":"4f34eb87e4b0e243712b1eba"},{"problem":91,"code":"(fn gti [go]\n  (letfn \n    [(orf [& b]\n          (cond \n            (empty? b) false\n            (= 1 (count b)) (first b)\n            :else (cond (first b) true\n                         :else (apply orf (rest b)))))\n     (gt [g & [e]]\n      (cond \n        (empty? g) true\n        :else (apply \n                orf\n                (for [i (range (count g))\n                      :let[ei (g i)\n                           ie (vec (reverse ei))\n                           rg (vec \n                                (concat\n                                  (subvec g 0 i )\n                                  (subvec g (inc i))))\n                           ee (cond\n                                (nil? e) ei\n                                (= (e 1)(ei 0)) ei\n                                (= (e 1)(ei 1)) ei\n                                (= (e 0)(ei 0)) ei\n                                (= (e 0)(ei 1)) ei)]\n                      :when (not (nil? ee))]\n                  (gt rg ee)))))]\n     (gt (vec go))))","user":"54d4bd2be4b0a52adc2e2005"},{"problem":91,"code":"(fn [edges]\n  (let [vs (reduce #(apply conj %1 %2) #{} edges)\n        graph (reduce (fn [init-map v]\n                        (assoc init-map\n                               v\n                               (reduce (fn [val-map [a b]]\n                                         (cond\n                                           (= a v) (conj val-map b)\n                                           (= b v) (conj val-map a)\n                                           :else val-map))\n                                       [] edges))) {} vs)\n        dfs-gragh (fn dfs-gragh [node visited]\n                    (reduce (fn [init-visited x]\n                              (apply conj init-visited (dfs-gragh x init-visited)))\n                            (conj visited node)\n                            (filter #(every? (fn [visited-node]\n                                               (not= visited-node %)) visited)\n                                    (get graph node))))]\n    (if (= vs (dfs-gragh (first vs) #{}))\n      true\n      false)))","user":"591072e0e4b0163c97b36ebc"},{"problem":91,"code":"(letfn \n  [; Nodes within nn that can be reached in one step from n\n   (reachable-nodes [e n nn]\n     (set (filter \n           (fn [x] (or (contains? e [n x]) (contains? e [x n]))) \n           nn)))\n\n   ; Nodes within nn that cannot be visited starting from n\n   (non-visited-nodes [e n nn]\n     (if (empty? nn) #{}\n       (let [next-n (reachable-nodes e n nn)]\n         (if (empty? next-n) nn\n           ;[n next-n nn]))))\n           (apply clojure.set/intersection\n                  (map (fn [x] (set (non-visited-nodes e x (remove #(= x %) nn)))) next-n))))))]\n\n  (fn [e]\n    (let [nn (set (apply concat e))]\n      (empty? (non-visited-nodes e (first nn) (rest nn))))))","user":"53065acbe4b02e8216869792"},{"code":"(fn [graph]\n  (letfn [(connect [connections connected]\n            (let [group (reduce (fn [s e] (apply conj s (or (connections e) #{e}))) #{} connected)]\n              (reduce (fn [m e] (assoc m e group)) connections group)))]\n    (let [connections (reduce (fn [m pair] (connect m pair)) {} graph)\n          nodes (set (keys connections))]\n      (every? #(= nodes (connections %)) nodes))))","problem":91,"user":"4e52d815535d302ef430da77"},{"code":"(fn graph-connected? [e]\n  (letfn [(neighbors [x]\n            (mapcat #(when (.contains % x) %) e))\n          (reachables [xe*]\n            (let [new-xe* (set (mapcat neighbors xe*))]\n              (if (= xe* new-xe*)\n                xe*\n                (recur new-xe*))))]\n    (every? (reachables #{(ffirst e)}) (apply concat e))))","problem":91,"user":"4e8338d6535db62dc21a62d3"},{"problem":91,"code":"(fn connected? [g]\n    (= g\n       (loop [o #{(first g)}]\n         (let [x (apply clojure.set/union\n                        (map #(into o (filter (partial some (set %)) g))\n                             o))]\n           (if (= o x)\n             o\n             (recur (into o x)))))))","user":"579693d4e4b039eba2ecb0e7"},{"code":"(fn [connections graph]\n  (if (empty? graph)\n    (apply = (set (keys connections)) (vals connections))\n    (let [[a b] (first graph)\n          a-connected (get connections a #{a})\n          b-connected (get connections b #{b})\n          ab-connected (into a-connected b-connected)]\n      (recur\n        (reduce (fn [conn node] (assoc conn node ab-connected))\n                connections\n                ab-connected)\n        (disj graph [a b])))))\n{}","problem":91,"user":"510db6cde4b078ea71921145"},{"code":"(fn [a] (rand-nth [true false]))","problem":91,"user":"4f9597e0e4b0dcca54ed6cd4"},{"code":"(fn [g]\n  (letfn [(union [sets uset vset]\n            (conj (disj sets uset vset) (clojure.set/union uset vset)))\n          (find-set [s v]\n            (first (clojure.set/select #(contains? % v) s)))]\n    (let [sets (reduce (fn [acc [x y]] (conj acc #{x} #{y})) #{} g)]\n      (= 1 (count\n        (loop [e g acc sets]\n          (if (empty? e) acc\n            (let [[u v] (first e) us (find-set acc u) vs (find-set acc v)]\n               (recur (rest e) (if (not= us vs) (union acc us vs) acc))))))))))","problem":91,"user":"4f2d5f5de4b0d6649770a05a"},{"code":"(fn [e]\n(letfn [\n(v [e] (set (mapcat (fn [[a b]][a b]) e)))\n(id [e] (set (for [n (v e)] [n n])))\n(re [e] (set (for [[a b] e] [b a])))\n(q [e] (letfn [(f [x] (for [[a b] x [c d] x :when (= b c)] [a d]))] (let [e2 (set (f e))] (if (clojure.set/subset? e2 e) e (q (clojure.set/union e e2))))))\n(pi [e] (clojure.set/union e (id e) (re e)))]\n(let [n (count (v e)) t (count (q (pi e)))] (= (* n n) t))))","problem":91,"user":"4ede8789535d10e5ff6f5337"},{"problem":91,"code":"(fn [ns]\n  (let [g (reduce (fn [m [n1 n2]]\n                    (-> m\n                        (update-in [n1] #(if % (conj % n2) #{n2}))\n                        (update-in [n2] #(if % (conj % n1) #{n1}))))\n                  {}\n                  ns)\n        nodes (set (keys g))\n        start (first nodes)]\n    (letfn [(walk [n seen]\n              (let [nns (clojure.set/difference (g n) seen)]\n                (cond (= seen nodes) true\n                      (empty? nns) false\n                      :else (reduce #(or %1 (walk %2 (conj seen %2))) false nns))))]\n      (walk start #{start}))))","user":"5eb1c786e4b00a66d4a95201"},{"problem":91,"code":"(fn connected? [edges]\n  (let [graph (reduce (fn [acc [a b]](merge-with clojure.set/union acc {a #{b}} {b #{a}})) {} edges)\n        all-vertices (set (apply concat (seq edges)))\n        ]\n    (loop [to-check #{(first all-vertices)}\n           visited #{}]\n      (if (empty? to-check)\n        (= visited all-vertices)\n        (let [checked-vertex (first to-check)\n              new-visited (conj visited checked-vertex)\n              new-to-check (clojure.set/union (rest to-check) (clojure.set/difference (get graph checked-vertex #{}) new-visited))]\n            (recur new-to-check new-visited)\n          )\n        )\n      )\n  ))","user":"5245e320e4b09dbe66b56177"},{"code":"(fn connected1? [graph]\n  (let [remove1 (fn remove1 [x [y & ys]]\n                  (if (= x y)\n                    ys\n                    (conj (remove1 x ys) y)))\n        tour-from? (fn tour-from? [from graph]\n                     (or (empty? graph)\n                         (some (fn [edge]\n                                 (tour-from? (first edge)\n                                             (remove1 edge graph)))\n                               (filter #(= from (second %)) graph))\n                         (some (fn [edge]\n                                 (tour-from? (second edge)\n                                             (remove1 edge graph)))\n                               (filter #(= from (first %)) graph))))]\n    (true? (some (fn [edge]\n                   (or (tour-from? (first edge)\n                                   (remove1 edge\n                                            (concat graph graph)))\n                       (tour-from? (second edge)\n                                   (remove1 edge\n                                            (concat graph graph)))))\n               graph))))","problem":91,"user":"4ee3b586535d10e5ff6f5371"},{"problem":91,"code":"(fn [edges]\n  (let [both-directions (fn [edges]\n                          (into edges (map reverse edges)))\n        neighbours (fn [edges]\n                     (into {} (map (fn [[k v]] [k (map second v)]) (group-by first (both-directions edges)))))\n\n        complete-helper (fn [nedges visited]\n                          (let [neigbours-to-visited (set (mapcat second (select-keys nedges visited)))]\n                            (if (or (empty? nedges) (empty? neigbours-to-visited))\n                              visited\n                              (recur (apply dissoc nedges visited)\n                                     (apply conj visited neigbours-to-visited)))))\n        nedges (neighbours edges)]\n    (let [[node _] (first nedges)]\n      (= (set (keys nedges))\n         (complete-helper nedges #{node})))))","user":"50921f9ae4b09a7d0b586de1"},{"code":"(fn [x]\n  (loop [a (rest x) b (into #{} (first x)) f #{}]\n    (if (and (or (empty? a) (nil? a)) (empty? f))\n      true\n      (if (or (empty? a) (nil? a))\n        false\n        (if (or (contains? b (first (first a))) (contains? b (last (first a))))\n          (recur (concat f (rest a)) (into #{} (conj b (first (first a)) (last (first a)))) #{})\n          (recur (rest a) b (conj f (first a)) ))))))","problem":91,"user":"513b77f3e4b00f740c76c403"},{"problem":91,"code":"(fn all-connect? [edges]\n  (letfn [(get-nodes [edges] (set (flatten (vec edges))))\n          (get-edges-from-node [node edges] (set (concat (filter #(= (first %) node) edges) (filter #(= (second %) node) edges))))\n          (get-edges-from-nodes [nodes edges] (set (mapcat #(get-edges-from-node % edges) nodes)))\n          (connected-nodes [edges]\n                           (loop [toured-nodes #{(first (get-nodes edges))}\n                                  rest-edges (set edges)]\n                             (let [expand-edges (get-edges-from-nodes toured-nodes rest-edges)\n                                   expand-nodes (get-nodes expand-edges)]\n                               (cond\n                                 (empty? expand-edges) toured-nodes\n                                 :else (recur (clojure.set/union toured-nodes expand-nodes) (clojure.set/difference rest-edges expand-edges))))))]\n\n    (= (connected-nodes edges) (get-nodes edges))))","user":"5e0d948fe4b099d064962f98"},{"problem":91,"code":"(let [neighbors (fn [vertex edges]\n                    (->> edges\n                         (filter #(some #{vertex} %))\n                         flatten))\n        unvisited (fn [vertex edges seen]\n                    (->> (neighbors vertex edges)\n                         (remove seen)))\n        remove-edge (fn [x y edges]\n                      (remove\n                       (fn [[a b]]\n                         (or (and (= x a) (= y b))\n                             (and (= x b) (= y a))))\n                       edges))\n        dfs-nodes\n        (fn dfs-nodes [edges seen vertex]\n          (let [seen (conj seen vertex)\n                unvisited (unvisited vertex edges seen)]\n            (if (empty? unvisited)\n              seen\n              (reduce #(into %1\n                             (dfs-nodes (remove-edge vertex %2 edges)\n                                        seen %2))\n                      seen\n                      unvisited))))]\n    (fn [relations]\n      (let [vertices (into #{} (flatten (into [] relations)))\n            reachable (dfs-nodes relations #{}\n                                 ;; arbitrary start node\n                                 (first (first relations)))]\n        (= vertices reachable))))","user":"539fa040e4b0ca733b97449f"},{"code":"(fn [vs]\n  (nil? (next (reduce (fn [sets [i j]]\n            (let [{m true o nil} (group-by #(some (partial contains? % ) [i j]) sets)]\n              (conj o (reduce into #{} (conj m [i j])))))\n    [] vs))))","problem":91,"user":"4e8f1ac6535d65386fec2146"},{"code":"(fn is-connected [graph]\n  ((fn f [untested remains]\n     (cond\n       (empty? remains) true\n       (empty? untested) false\n       true\n       (let [[t0 t1] (first untested)\n             matching (set (filter #(let [[u0 u1] %]\n                                      (or (= t0 u0)\n                                          (= t0 u1)\n                                          (= t1 u0)\n                                          (= t1 u1)))\n                                   remains))\n             remains (clojure.set/difference remains matching)]\n         (recur (clojure.set/union (set (rest untested)) matching) remains))))\n     #{(first graph)} (set (rest graph))))","problem":91,"user":"4ec75077535d6d7199dd36e0"},{"code":"(fn [graph]\n  (letfn [(setify [coll] (set (map set coll)))\n(adjacent? [edge1 edge2]\n  (not (empty? (clojure.set/intersection edge1 edge2))))\n(neighbors [edges graph]\n  (set (apply concat\n        (for [e edges]\n          (filter #(adjacent? e %) graph)))))\n(step [from graph]\n  (let [to (neighbors from graph)]\n    {   :edges to\n     :subgraph (clojure.set/difference graph to)}))\n(rand-bf-walk [graph]\n  (loop [edges (->> graph seq rand-nth set (conj #{}))\n         graph (-> graph setify (clojure.set/difference edges))\n         walk [edges]]\n    (let [next-step (step edges graph)\n          edges (:edges next-step)]\n      (if (or (empty? edges) (empty? graph))\n        walk\n        (recur edges (:subgraph next-step) (conj walk edges))))))]\n(= (->> graph rand-bf-walk (map seq) flatten count)\n                             (count graph))))","problem":91,"user":"524ae8e6e4b09eba1c0223b5"},{"problem":91,"code":"(fn connected? [edges]\n   (let [bidirectional (concat edges (map reverse edges))\n         adjacencies (into {} (for [[k v] (group-by first bidirectional)] [k (map second v)]))]\n     (letfn [(traverse [visited]\n               (if (= (count adjacencies) (count visited)) true\n                   (let [adjacent (into #{} (adjacencies (last visited)))\n                         visited-set (into #{} visited)\n                         to-traverse (clojure.set/difference adjacent visited-set)]\n                     (or (some true? (map #(traverse (conj visited %)) to-traverse)) false))))]\n       (or (some true? (map #(traverse (vector %)) (keys adjacencies))) false)))\n     \n   \n   )","user":"549dfe40e4b0f3d1d8e70f9a"},{"problem":91,"code":"(fn [edges]\n  (let [\n      reduce-reachable (fn [[reachable unreached]]\n        (reduce (fn [[rs us] [x y :as edge]]\n                  (prn edge \" \" rs)\n                  (if (or\n                        (contains? rs x)\n                        (contains? rs y)\n                        (empty? rs)\n                      )\n                    [(into rs edge) us]\n                    [rs (conj us edge)]\n                  )\n        ) [reachable #{}] unreached))\n      iterations (iterate reduce-reachable [#{} edges])\n      final-iteration (second (last (take-while (partial apply not=) (map vector iterations (rest iterations)))))\n      joined? (->> final-iteration (second) (empty?))\n    ]\n    joined?\n  )\n)","user":"516ee939e4b06aac486e5b34"},{"problem":91,"code":"(fn connected? \n  [edges]\n  (loop [reached (set (first edges)) remaining (into #{} (map set (rest edges)))]\n    (if (empty? remaining)\n      true\n      (let [continuations (filter #(some % reached) remaining)]\n        continuations\n        (if (empty? continuations)\n          false\n          (recur (apply clojure.set/union reached continuations) (remove (set continuations) remaining)))))))","user":"5bf9d9b7e4b0bdcf453d15c4"},{"problem":91,"code":"(fn [ggg]\n(letfn\n  [\n   (add-node\n  [graph [from to]]\n  (merge-with\n    clojure.set/union\n    graph\n    (if (= from to)\n      {to #{to}}\n      {from #{to} to #{from}})))\n    \n   (make-hash-graph\n  [edges]\n  (reduce\n    add-node\n    {}\n    edges))\n(find-path\n  ([graph a b]\n    (find-path graph a b #{a}))\n  ([graph a b checked-nodes]\n    (let\n      [connected-nodes (clojure.set/difference (graph a) checked-nodes)]\n      (some\n        true?\n        (map\n          (fn [nd]\n            (if (= nd b)\n              true\n              (find-path graph nd b (conj checked-nodes a))))\n          connected-nodes)))))\n\n(combinations\n  [graph]\n  (let\n    [nodes (vec (keys graph))]\n    (loop\n      [curr-combinations []\n       nodes nodes]\n       (let\n        [nd (first nodes)\n         nodes (rest nodes)\n         nd-combimations (map #(vector nd %) nodes)]\n        (if\n          (empty? nodes)\n          curr-combinations\n          (recur\n            (concat curr-combinations nd-combimations)\n            nodes))))))\n\n(connected?\n  [graph]\n  (let\n    [combs (combinations graph)]\n    (every?\n        #(find-path graph (first %) (last %))\n      combs)))]\n  \n  (connected? (make-hash-graph ggg))\n  ))","user":"53d382d8e4b00fb29b22132a"},{"problem":91,"code":"(fn bfs\n  [edges]\n  (letfn [(neighbors [marked]\n     (->\n      (map (fn [node] (filter #(some node %) edges)) (map (fn [a] #{a}) marked))\n      flatten\n      distinct))]\n    (let [V (distinct (flatten (map flatten edges)))]\n   (= \n    (into #{} (last (take (count V) (iterate neighbors [(first (first edges))]))))\n    (into #{} V)\n    )\n  )))","user":"53d6b266e4b0e771c3025459"},{"code":"#(loop [m (into % (map rseq %)) s 0]\n  (if (= s (count m))\n      (= (Math/sqrt s) (count (set (apply concat %))))\n      (recur (into m (for [[a b] m [c d] m \n                           :when (= b c)]\n                          [a d]))\n             (count m))))","problem":91,"user":"4e5fe31a535d8ccf87e9fe50"},{"problem":91,"code":"(fn [edge-set]\n\n(let [\nmerge-map (fn [result-map add-map]\n(into result-map (for [ [key1 list1] add-map ]\n{key1 (vec (into (result-map key1) list1))}\n)))\n\n\n\n\nmake-node-to-child-map (fn [edge-set]\n(let [result (reduce (fn [accum val]\n(if (= (first val) (second val) )\n(merge-map accum {(first val) [(second val)] } )\n(merge-map accum {(first val) [(second val)] (second val) [(first val)] } ))\n\n) {} edge-set)]\n\n(println result)\nresult)\n)\n\n\n\n\ntraverse (fn traverse-recur [current-node visited-node-set node-to-nodes-map completed-visited-sets-set]\n(let [ to-node-list (node-to-nodes-map current-node)\nnum-nodes (count (keys node-to-nodes-map))\nvisit-structure (reduce (fn [accum val]\n(let [new-visited-node-set (conj visited-node-set val)]\n(if (> (count new-visited-node-set) (count visited-node-set))\n[ (into (first accum) {val new-visited-node-set}) completed-visited-sets-set ]\n[ (first accum) (conj completed-visited-sets-set new-visited-node-set)]\n)\n))\n;next-node to-visited set map\n[ { } completed-visited-sets-set ]\nto-node-list)\n\nfound-path (fn [current-sets]\n(reduce (fn [accum val]\n(if accum\ntrue\n(if (= num-nodes (count val))\ntrue\nfalse\n)\n)) false current-sets)\n)\n\nnext-completed-visited-sets-set (second visit-structure)\nnext-node-to-visited-set-map (first visit-structure)\n\n]\n\n(if (found-path next-completed-visited-sets-set)\ntrue\n(if (= 0 (count next-node-to-visited-set-map))\nfalse\n(contains? (set (map (fn [key-val] (traverse-recur (first key-val) (second key-val) node-to-nodes-map next-completed-visited-sets-set)) next-node-to-visited-set-map)) true)\n))\n))\n\n\n\ntraverse-graph (fn [node-to-nodes-map]\n\n(contains? (set (map (fn [current-node] (traverse current-node #{current-node} node-to-nodes-map #{}))\n(keys node-to-nodes-map)\n\n)) true))\n\nresult (traverse-graph (make-node-to-child-map edge-set))]\n(println result)\nresult\n))","user":"53c73e8ae4b00fb29b2212a5"},{"problem":91,"code":"(fn t [edges]\n  (if (= 1 (count edges))\n    true\n    (let [f (fn f [edges remained-edge connecteds]\n              (let [find-edge (fn [node]\n                                (filter #(= node (first %)) remained-edge))\n                    founded-edge (partition 2 (flatten (map #(find-edge %) connecteds)))\n                    founded-node (mapcat #(vector (second %)) founded-edge)]\n                (if (empty? founded-edge)\n                  connecteds\n                  (f edges (first (map #(disj remained-edge %) founded-edge))\n                     (into connecteds   founded-node)))))\n          nodes (set (mapcat flatten edges))\n          results (set (map #(f edges (disj edges %) #{(first %)(second %)}) edges))]\n      (if (results nodes) true false))))","user":"566d71b1e4b0a866af6896ca"},{"code":"(fn [g]\n  (let [v (set (mapcat identity g))\n        contains-some? (fn [coll pair] (some (partial contains? coll) pair))\n        contains-every? (fn [coll pair] (every? (partial contains? coll) pair))]\n    (loop [vs (into #{} (first g))\n           e (rest g)\n           x 0]\n      (if (or (empty? e) (== x (count v)))\n        (= v vs)\n        (recur\n         (reduce\n          #(if (contains-some? %1 %2)\n             (into %1 %2)\n             %1)\n          vs e) ; New vs\n         (remove (partial contains-every? vs) e) ; New e\n         (inc x))))))","problem":91,"user":"52d340ebe4b099d49816f0c1"},{"problem":91,"code":"(fn __ [s]\n  (let [nodes (fn [s]\n                ;; all the a's and b's of a set of [a b] tuples\n                (into #{} (concat (map first s) (map second s))))\n        sorted-uniq (fn [s]\n                (into #{} (filter (fn [[a b]] ((complement =) a b)) (map sort s))))\n        num-possible-links (fn [n]\n                             ;; n * (n - 1) / 2\n                             (if (= n 1)\n                               0\n                               (/ (* n (dec n)) 2)))\n        positions (fn [pred coll]\n                    (keep-indexed (fn [idx x]\n                                    (when (pred x)\n                                    idx))\n                                  coll))\n        rev (fn [[a b]]\n              [b a])\n        add-revs (fn [s]\n                   ;; s is a set of [a b] tuples; add all the [b a] tups\n                   (clojure.set/union s (into #{} (map rev s))))\n        bfs (fn [s [a b]]\n              ;; s is a graph as a set of [a b] tuples; find all the neighbors of [a b]\n              (let [firsts (map first s)\n                    seconds (map second s)\n                    idxs (positions (partial = b) firsts)]\n                (if (seq idxs)\n                  (map #(vector % (nth seconds %2)) (repeat a) idxs)\n                  nil)))\n        tr-cl (fn tr-cl [s]\n                ;; bfs on each node recursively to find all reachable nodes\n                (let [nexts (into #{} (filter (complement nil?) (apply concat (map (partial bfs s) s))))\n                      s-plus (clojure.set/union s nexts)]\n                  (if (= s s-plus)\n                    s\n                    (tr-cl s-plus))))\n        t (sorted-uniq (tr-cl (add-revs s)))\n        measured (count t)\n        desired (num-possible-links (count (nodes s)))]\n    (= measured desired)))","user":"53e76bb2e4b036ad0777e47d"},{"code":"(fn [g]\n(let [y (fn y [s g z]\n          (let [c (remove #{s} (mapcat #(if (some #{s} %) % []) g))\n                t (mapcat #(y % g (concat z c)) (remove (set z) c))]\n            (set (concat c t [s]))))\n      e (-> g (seq)(flatten)(set))\n      ]\n  (= e (y (first e) g []))\n  ))","problem":91,"user":"52593207e4b0cb4875a45cd3"},{"code":"(fn connected-graph? [edges]\n  (letfn [(nodes-from-edges [e]\n            (into #{} (flatten (reduce conj [] e))))]\n    (let [nodes (nodes-from-edges edges)\n          node->edge (into {}\n                           (map (fn [node]\n                                  [node (filter #(some (partial = node) %) edges)])\n                                nodes))]\n      ;; Breadth-first-search from the first node, until we can search no more\n      (loop [visits #{(first nodes)}]\n        (do (println \"We got: \" visits))\n        (let [new-visits (into #{} (flatten (map node->edge visits)))]\n          (if (= visits new-visits)\n            (= visits nodes)\n            (recur new-visits)))))))","problem":91,"user":"50812debe4b01a93d3f38e4c"},{"problem":91,"code":"(fn check-connectivity [edges]\n  (let [create-initial-disj-set (fn [edges]\n                                  (reduce\n                                    #(assoc %1 %2 #{%2})\n                                    {}\n                                    (into #{} (concat\n                                                (map first edges)\n                                                (map second edges)))))\n        union-sets (fn [set-1 set-2 disj-set]\n                     (let [union-set (clojure.set/union\n                                       (disj-set set-1)\n                                       (disj-set set-2))]\n                       (-> disj-set\n                           (assoc set-1 union-set)\n                           (assoc set-2 union-set))))\n        init-disj-set (create-initial-disj-set edges)\n        num-nodes (count init-disj-set)\n        final-disj-set (reduce\n                         #(->> %1\n                               (union-sets (first %2) (second %2))\n                               (union-sets (second %2) (first %2)))\n                         init-disj-set\n                         (concat edges edges))]\n    (if (some\n          #(= (count %) num-nodes)\n          (vals final-disj-set)) true false)))","user":"53527551e4b084c2834f4af0"},{"problem":91,"code":"(fn\n  [g]\n  (letfn [(family-tree\n            [n]\n            (let [a-nods (atom g)\n                  minus (fn \n                    [s n]\n                    (clojure.set/difference s #{(if (seq? n) (reverse n) n)}))\n                  links (fn\n                    [[_ s1]]\n                    (fn\n                      [[f2 s2 :as n2]]\n                      (if (= s1 f2) n2 (when (= s1 s2) (reverse n2)))))\n                  brc? (fn \n                    [n]\n                    (swap! a-nods minus n)\n                    (some (links n) @a-nods))\n                  chd (fn\n                    [n]\n                    (keep (links n) @a-nods))]\n              (dorun (tree-seq brc? chd n))\n              (if-let [nods (not-empty @a-nods)] \n                (do \n                  (reset! a-nods g) \n                  (dorun (tree-seq brc? chd (reverse n))) \n                  (empty? (clojure.set/intersection @a-nods nods))) \n                true)))]\n    (every? family-tree g)))","user":"59f91b99e4b0ca45a743a33a"},{"code":"(fn p[g]\n  (let [g (apply merge-with (cons concat (map #(hash-map (first %) (vector (second %) )) (set (concat g (reverse g)))))) l (count g)]\n    (loop [g g [k & ks ] (list (first (seq (keys g)))) path []]\n      (println g ks path)\n      (if-let [kn (get g k)]\n        (recur (dissoc g k) (concat ks kn) (cons k path))\n        (if ks\n          (recur g ks path)\n          (= (count path) l))))))","problem":91,"user":"51b793d3e4b0d906fcd71d38"},{"code":"(fn tg [s]\n  (letfn [(nodes [s]\n                 (loop [s s,\n                        result #{}]\n                   (if (empty? s)\n                     result\n                     (clojure.set/union (set (first s))\n                                        (nodes (rest s))))))\n          (onecycle [s] \n                    (loop [s (sort s),\n                           n1 (first (first s)),\n                           n2 (second (first s)),\n                           result #{}]\n                      (if (empty? s)\n                        result\n                        (if (or (contains? result n1)\n                                (contains? result n2))\n                          (recur (rest s) (first (first (rest s))) (second (first (rest s))) (conj result n1 n2))\n                          (recur (rest s) (first (first (rest s))) (second (first (rest s))) (conj #{} n1 n2) )))))]\n    (= (onecycle s) (nodes s))))","problem":91,"user":"512474ede4b02c3f2a072cce"},{"code":"(fn graph-connectivity [coll]\n  (letfn [(exist-path?  [m fv tv]\n            (let [nvs (filter #(contains? % fv) m)]\n              (cond\n               (empty? m) false\n               (empty? nvs) false\n               (some true? (map #(contains? % tv) nvs)) true\n               :else (some true? (map #(exist-path? (disj m %) (first (disj % fv)) tv) nvs)))))]\n    (let [cons (set (map set coll))\n          vs (set (flatten (apply vector coll)))]\n      (every? true? (for [x vs y vs] (exist-path? cons x y))))))","problem":91,"user":"523b82efe4b07becd5be21f0"},{"code":"#(let [vertex (set (apply concat %))]\n    (loop [visited (set (first %))\n           {left false connected true} (group-by\n                                        (fn [[a b]]\n                                          (or\n                                           (contains? visited a)\n                                           (contains? visited b)))\n                                        (rest %))]\n      (cond\n       (= visited vertex) true\n       (empty? connected) false\n       :else\n       (let [nv (clojure.set/union visited (set (apply concat connected)))\n             subsets (group-by\n                (fn [[x y]]\n                  (or (contains? nv x) (contains? nv y)))\n  \tleft)]\n         (recur nv subsets)))))","problem":91,"user":"4f0e995e535d0136e6c22326"},{"problem":91,"code":"(fn [g]\n  (let [visited (atom #{})\n        nodes (set (apply concat g))\n        len (count nodes)\n        f (fn ! [elem edges]\n            (swap! visited conj elem)\n            (let [have-elem (filter #(or (= elem (first %)) (= elem (second %))) edges)\n                  related (set (map #(if (= elem (first %)) (second %) (first %)) have-elem))\n                  to-process (clojure.set/difference related @visited)\n                  ]\n              (if (seq to-process)\n                (if (seq to-process)\n                  (some true? (map #(! % edges) to-process))\n                  true)\n                false)))\n        ]\n    (f (ffirst g) g)\n    (= (count @visited) len)))","user":"557232a1e4b09a3098a52543"},{"problem":91,"code":"(fn [edges]\n  (letfn\n   [(neighbors [v edges]\n      (keep (fn [[v1 v2]]\n                (cond (= v v1) v2\n                      (= v v2) v1))\n            edges))\n    (dfs-graph [vertices edges start]\n      (loop [visited []\n             seen #{start}\n             active [start]]\n        (if (empty? active)\n          visited\n          (let [v (peek active)\n                nbs (neighbors\n                      v edges)\n                unseen (remove\n                         seen nbs)]\n            (recur (conj visited v)\n                   (into seen nbs)\n                   (into (pop active)\n                         unseen))))))\n    (connected? [edges]\n      (let [vertices\n             (->> edges\n                  (apply concat)\n                  distinct)]\n        (= (count vertices)\n           (count\n             (dfs-graph\n               vertices\n               edges\n               (first vertices))))))]\n    (connected? edges)))","user":"55d2dd27e4b0e31453f64a5b"},{"problem":91,"code":"(fn connected?\n  ([edges]\n   (connected? (disj edges (first edges)) #{(first edges)}))\n\n  ([tobeconnected-edges connected-edges]\n   (let [connected-nodes (reduce into #{} connected-edges)\n         edges-with-path (filter #(seq (filter connected-nodes %)) tobeconnected-edges)\n         remaining-edges (reduce disj tobeconnected-edges edges-with-path)]\n     (cond\n       (empty? remaining-edges) true\n       (empty? edges-with-path) false\n       :else (connected? remaining-edges (into connected-edges edges-with-path))))))","user":"5a91988ae4b002d099cae6f9"},{"problem":91,"code":"(fn [edges]\n  (let [nodes (->> edges\n                   (map (fn [[a b]] (merge {a [b]} {b [a]})))\n                   (apply merge-with concat))\n        passed (atom #{})]\n    (letfn [(go [node-id]\n              (when-not (@passed node-id)\n                (swap! passed conj node-id)\n                (doseq [node-id' (nodes node-id)]\n                  (go node-id'))))]\n      (go (key (first nodes)))\n      (= (count @passed)\n         (count nodes)))))","user":"583e27e2e4b089d5ab817daa"},{"code":"(fn p91 [s]\n  (let [elems (distinct (flatten (vec s)))\n        size (count elems)\n        tbl (make-array Boolean size size)]\n    (dotimes [i size]\n      (dotimes [j size]\n        (when (= i j) (aset tbl i j true))\n        (when (or (s [(nth elems i) (nth elems j)])\n                  (s [(nth elems j) (nth elems i)]))\n          (aset tbl i j true)\n          (aset tbl j i true))))\n    (dotimes [k size]\n      (dotimes [i size]\n        (dotimes [j size]\n          (when (and (aget tbl i k) (aget tbl k j))\n            (aset tbl i j true)\n            (aset tbl j i true)))))\n    (every? boolean\n            (for [i (range size) j (range size)]\n              (aget tbl i j)))))","problem":91,"user":"504f57c7e4b0a02f9cffde71"},{"problem":91,"code":"(fn [graph]\n (letfn [(walk [node edge]\n         (cond\n          (= node (first edge)) (second edge)\n          (= node (second edge)) (first edge)\n          :else nil))]\n   (let [nodes (set (flatten (vec graph)))]\n    (loop [walked (for [n nodes e graph :when (not (nil? (walk n e)))] (conj #{} n (walk n e)))]\n      (let [nextwalked (for [n nodes e graph w walked :when (and (w n) (not (w (walk n e))) (not (nil? (walk n e))))]\n                         (conj w n (walk n e)))]\n       (cond\n        (some #(= nodes %) walked) true\n        (empty? nextwalked) false\n        :else (recur nextwalked)))))))","user":"57dd47f4e4b0bd073c20243e"},{"code":"(fn [e]\n    (let [m (set (apply concat e)) f (first m)]\n      (loop [v #{f} n (disj m f)]\n        (let [d (distinct (for [s v [a b] e :when (and (not= a b) (#{a b} s))] (if (= s a) b a)))\n              w (into v d)]\n          (if (= v w)\n            (empty? n)\n            (recur w (apply disj n d)))))))","problem":91,"user":"4e82f85d535db62dc21a62ce"},{"problem":91,"code":"(fn [g]\n    (let [all (-> g seq flatten set)]\n      (loop [r #{(first all)}]\n        (let [r' (reduce (fn [r [a b]]\n                           (if (or (r a) (r b))\n                             (-> r (conj b) (conj a))\n                             r))\n                         r g)]\n          (if (= r r')\n            (= all r)\n            (recur r'))))))","user":"583048d9e4b051871117c007"},{"problem":91,"code":"(letfn [(collapse-components [comps [x1 x2]]\n                             (let [comp1 (first (filter #(contains? % x1) comps))\n                                   comp2 (first (filter #(contains? % x2) comps))\n                                   newcomp (clojure.set/union comp1 comp2)]\n                               (conj\n                                (clojure.set/difference\n                                 comps (into #{} [comp1 comp2]))\n                                newcomp)))\n  \t\t(initial-components [graph]\n        \t(into #{} (map #(into #{} [%]) (into #{} (flatten (into [] graph))))))]\n\t(fn [graph]\n      (= 1 (count (reduce collapse-components (initial-components graph) graph)))))","user":"5553b924e4b0deb715856e06"},{"problem":91,"code":"(fn\n  [coll]\n  (let [m (reduce (fn [m [s d]]\n                    (let [ds (get m s #{})\n                          ds' (conj ds d)\n                          ss (get m d #{})\n                          ss' (conj ss s)]\n                      (assoc m s ds' d ss'))) {} coll)]\n    (letfn [(bfs [q v m]\n              (if (seq q)\n                (let [h (first q)\n                      t (rest q)]\n                  (if (contains? v h)\n                    (recur t v m)\n                    (let [v' (conj v h)]\n                      (if (contains? m h)\n                        (recur (concat t (m h)) v' m)\n                        (recur t v' m)))))\n                v))]\n      (= (count m) (count (bfs [(first (first coll))] #{} m))))))","user":"52dfc89be4b09f7907dd1405"},{"problem":91,"code":"(fn f\n    ([xs] (f (rest xs) (set (first xs))))\n    ([xs result]\n     (if (empty? xs) true                                   ;; All records processed - graph connected\n                     (let [connected\n                           (for [a xs\n                                 :when (not (empty? (filter (set a) result)))]\n                             a)\n                           r2 (reduce conj result (flatten connected))\n                           xs2 (filter (complement (set connected)) xs)]\n                       (if (empty? connected) false\n                                              (recur xs2 r2))\n                       )\n                     )\n      )\n    )","user":"596d630ae4b069c0a1a19846"},{"problem":91,"code":"(fn connected? [edges] \n    (letfn [(tuple-to-graph [tuples]\n                (reduce #(assoc %1 (first %2) (conj (get %1 (first %2) []) (second %2)) (second %2) (conj (get %1 (second %2) []) (first %2))) {} tuples))\n            (unreachable? \n                ([graph visited node-key]\n                    (if (contains? visited node-key)\n                        visited\n                        (set (apply concat (map #(unreachable? graph (conj visited node-key) %) (get graph node-key))))))\n                ([graph] \n                    (not= (count (unreachable? graph #{} (first (keys graph)))) (count (keys graph)))))]\n            (not (unreachable? (tuple-to-graph edges)))))","user":"54f09599e4b024c67c0cf89d"},{"code":"(fn ? [c]\r\n  (let [[x & s] (map set c)\r\n        p (group-by #(if (some x %) 1 0) s)\r\n        y (set (apply concat x (p 1)))]\r\n    (or (nil? (p 0))\r\n        (and (not= x y)\r\n             (? (cons y (p 0)))))))","problem":91,"user":"4e1158aa535d04ed9115e7c6"},{"problem":91,"code":"(fn connected-graph?  [coll] \n  (= 1 (count (reduce \n    (fn [pathset [x y]]\n      (let [\n        px (first (filter #(contains? % x) pathset))  ; existing path to x\n        py (first (filter #(contains? % y) pathset))  ; existing path to y\n        link (clojure.set/intersection px py) ; a potential link between the two paths\n        path (first (remove empty? [px py])) ; the actual path\n        others (disj pathset px py); other unrelated paths  \n        vertex (set [x y])\n      ]\n      ;println \"=== pathset:\" pathset \" | path:\" path \"| others=\" others)\n      ; (println \"x=\" x \"px:\" px \"| y=\" y \"py:\" py \"| link=\" link ) \n      (if (empty? link)\n        ; most common case\n        (if (empty? path)\n          ; new path, conjoin it\n          (conj pathset vertex)\n          ; path exists, amend it\n          (conj others (clojure.set/union path vertex)))\n        (conj others (clojure.set/union px py)) ; link not empty, paths must union!\n    )))\n    #{} coll)\n)))","user":"54bbe505e4b0ed20f4ff6ec5"},{"code":"(fn graph-connect1? [graph]\n  (= 1 (count\n        (let [join-sets (fn[ss s]\n                    (let [h (group-by #(some s %) ss)\n                          not-connected (h nil)\n                          connected (apply clojure.set/union\n                                           (cons s (flatten (vals (dissoc h nil)))))]\n                      (cons connected not-connected)))]\n    (loop [ g (map set graph)]\n      (let [size (count g)\n            ng (reduce join-sets\n                       [(first g)] (rest g))]\n        (if (or (nil? (next ng)) (= size (count ng)))\n          ng\n          (recur ng))))))))","problem":91,"user":"4f1ef6a0535d64f60314649b"},{"problem":91,"code":"(let [add (fn [forest n1 n2]\n            (let [old1 (forest n1) old2 (forest n2) nil1 (= old1 nil) nil2 (= old2 nil)]\n              (if (and nil1 nil2)\n                (assoc forest n1 n1 n2 n1)\n                (if (or nil1 nil2)\n                  (if nil1 (assoc forest n1 old2 n2 old2) (assoc forest n1 old1 n2 old1))\n                  (into {}\n                        (map\n                         (fn [item]\n                           (let [k (first item) v (second item)]\n                             [k (if (= v old2) old1 v)]))\n                         forest))))))]\n  (fn [graph] (let [forest (reduce (fn [forest edge] (add forest (first edge) (second edge))) {} graph)]\n                (apply = (vals forest)))))","user":"5b465b8be4b02d533a91bc65"},{"code":"(fn [es]\n    (let [sets      (map set es)\n          integrate (fn [es] (when-let [[f & r] (seq es)]\n                               (set (map #(if-not (empty? (clojure.set/intersection % f)) (clojure.set/union % f) %) r))))]\n      (->> sets\n        (iterate integrate)\n        (drop-while #(> (count %) 1))\n        (ffirst)\n        (= (apply clojure.set/union sets)))))","problem":91,"user":"525f51bde4b0cb4875a45dc8"},{"problem":91,"code":";; Hacked in from '89. Graph Tour'\n(fn [ss]\n  (let [s (vec ss)]\n  (loop [acc (set (first s))]\n    (let [new-acc (reduce #(if (or (%1 (first %2)) (%1 (second %2)))\n                             (clojure.set/union %1 (set %2))\n                             %1)\n                          acc\n                          s)\n          ]\n      (if (= (->> s flatten distinct count) (count new-acc))\n        true\n        (if (= (count new-acc) (count acc))\n          false\n          (recur new-acc)))))\n  ))","user":"53c1ce3ee4b00fb29b221268"},{"problem":91,"code":"(fn __ ([in] (let [[[a b] & xs] (seq in)] (__ (conj #{a} b) xs)))\n  ([connected-vs xs]\n   (if (empty? xs)\n     true\n     (let [{to-add-edges true no-add false}\n           (group-by\n            (fn [x]\n              (let [[a b] x]  \n                (boolean (or (connected-vs a) (connected-vs b))))) xs)\n\n           to-add-vertices\n           (set (reduce (fn [acc [a b]] (conj acc a b)) [] to-add-edges))]\n       (if (empty? to-add-vertices)\n         false\n         (recur (clojure.set/union connected-vs to-add-vertices) no-add))))))","user":"55916764e4b0604b3f94d57b"},{"problem":91,"code":"#(->> %\n      (sort-by (fn [[a b]] (if (< 0 (compare a b)) a b)))\n      (reduce (fn [a b]\n                (if (some (set b) a)\n                  (concat a b)\n                  [])))\n      (empty?)\n      (not))","user":"55d0e76ae4b0e31453f64a40"},{"problem":91,"code":"(fn [s]\n  (letfn [(connect [n e]\n            (some {n (first (remove #(= n %) e))} e))]\n    (loop [nodes (first s) ue (rest s)]\n      (if (empty? ue)\n        true\n        (let [c (set (apply concat (map #(keep (partial connect %) ue) nodes)))]\n          (if (empty? c)\n            false\n            (recur c (reduce #(remove (fn [n] (connect %2 n)) %) ue nodes))))\n        ))))","user":"57035ccfe4b08d47c97781ef"},{"problem":91,"code":"(fn __ [someset]\n  (= ((fn[q](set(apply concat (map #(map (partial vector %)  q) q)))) (distinct (flatten(concat  someset))))  \n   (loop [ a (reduce conj someset (map reverse someset))](let[newset (reduce\n(fn[x y](reduce conj x (filter #(not (nil? %)) (map #(if (= (first %) (last y)) (vector (first y) (last %) )) x))))\n a\n a)](if (= a newset) a (recur newset))))))","user":"52bbd09ee4b07a9af57922ee"},{"code":"(fn connected?\n  ([s]\n     (connected? (set (first s)) (rest s)))\n  ([node-set s]\n     (if (seq s)\n       (let [adjacents (filter #(some node-set %) s)\n             others    (remove #(some node-set %) s)]\n         (if (seq adjacents)\n           (recur (reduce #(clojure.set/union %1 (set %2)) node-set adjacents)\n                  others)\n           false))\n       true)))","problem":91,"user":"4f3fb586e4b0e243712b1f9c"},{"code":"(fn graph-connectivity [graph]\n  (let [iterate-until\n        (fn [f init pred] (->> (iterate f init) (partition 2 1) (drop-while #(not (apply pred %))) first second)) \n        nodes (->> (seq graph) flatten set)\n        adjacents (fn [node] (into #{} (for [[n m] graph :when (or (= n node) (= m node))] (if (= n node) m n))))\n        step (fn [[visited last-visited]] \n               (let [new-visited (->> (map adjacents last-visited) (reduce clojure.set/union))]\n                 [(clojure.set/union visited new-visited) new-visited]))\n        stop (fn [[visited _] [next-visited _]] (= visited next-visited) )\n        some-node (some nodes nodes)\n        [accessible-from-node _] (iterate-until step [#{} #{some-node}] stop)]\n    (= (count accessible-from-node) (count nodes))))","problem":91,"user":"51729002e4b044b2ef48a850"},{"code":"(fn [graph]\n  ((complement empty?)\n   (apply\n    clojure.set/intersection\n    (reduce (fn [sets edge]\n              (let [seted (set edge)]\n                (if (every? empty? (map #(clojure.set/intersection % seted) sets))\n                  (conj sets seted)\n                  (set (map (fn [temp-set]\n                              (if (empty? (clojure.set/intersection temp-set seted))\n                                temp-set\n                                (clojure.set/union temp-set seted)))\n                            sets)))))\n            #{(set (first graph))}\n            (rest graph)))))","problem":91,"user":"5225271fe4b01819a2de42f9"},{"problem":91,"code":"(fn graph-connectivity\n  [connections]\n  (let [nodes (set (flatten (seq connections)))]\n    (loop [edge [(first nodes)] unconnected (disj nodes edge)]\n      (let [candidate (reduce into (map (fn [node] (reduce #(if (= node (first %2)) \n                                                                 (conj %1 (second %2)) \n                                                                 (if (= node (second %2)) \n                                                                   (conj %1 (first %2)) \n                                                                   %1)) \n                                                           #{}\n                                                           connections)) edge))\n            new-edge (clojure.set/intersection candidate unconnected)\n            new-unconnected (reduce #(disj %1 %2) unconnected new-edge)]\n        (if (empty? new-unconnected)\n          true\n          (if (empty? new-edge)\n            false\n            (recur new-edge new-unconnected)))))))","user":"576df252e4b0979f8965156f"},{"code":"(fn connected? [edges]\n  (loop [remaining   edges\n         clusters    []]\n    (if (empty? remaining)\n      (= 1 (count clusters))\n      (let [connection (apply hash-set (distinct (first remaining)))\n            merged (apply clojure.set/union (conj (filter #(some connection %) clusters) connection))\n            others (remove #(some connection %) clusters)]\n        (recur (rest remaining)\n               (conj others merged))))))","problem":91,"user":"510cd1dde4b078ea71921124"},{"code":"(fn [edges]\n    (let [all-nodes (set (mapcat identity edges))\n          neighbours (fn [node]\n                        (letfn [(get-neighbour [edge]\n                                  (cond\n                                    (= node (first edge)) (second edge)\n                                    (= node (second edge)) (first edge)\n                                    :else nil))]\n                       (filter identity (map get-neighbour edges))))\n          step (fn [visited]\n                 (set (concat visited (mapcat neighbours visited))))]\n      (loop [visited (into #{} (first edges))]\n        (let [stepped (step visited)] \n          (cond\n            (= all-nodes stepped) true\n            (= visited stepped) false\n            :else (recur stepped))))))","problem":91,"user":"5141abf1e4b02fd87f5064c3"},{"problem":91,"code":"(fn graph-con [raw-edges]\n  (let [keys (into #{} (flatten (seq raw-edges)))\n        paths (into {} (map (fn [[k v]] (vector k (disj (into #{} (flatten v)) k)))\n                                         (group-by first (concat raw-edges (map reverse raw-edges)))))\n        get-children (fn [[current unseen]] \n                       (map #(list % (clojure.set/difference unseen (paths current)))\n                            (clojure.set/intersection (paths current) unseen)))\n        branch? (fn [data] ((complement empty?) (get-children data)))\n        start (first keys)]\n    \t(boolean (some #(empty? (last %))\n        (tree-seq branch? get-children [start (disj keys start)])))\n    ))","user":"55934bebe4b0c79f6e1db93b"},{"problem":91,"code":"(fn f\n  ([g]\n   (println (f (first (first g)) g #{}))\n   (=\n    (set (flatten (seq g)))\n    (f (first (first g))\n                        (clojure.set/union g (map reverse g))\n                        #{})))\n  ([e g v]\n   (println e g v)\n   (if (or (contains? v e) (nil? e))\n     v\n     (reduce\n       clojure.set/union\n       (map\n         #(f % g (conj v e))\n         (map last (filter #(= e (first %)) g)))))))","user":"519136e9e4b0f8ef0be96c01"},{"problem":91,"code":"(letfn [\n        (combinable-edges? [[v1 v2] [v3 v4]]\n           (cond\n             (= v1 v3) true\n             (= v1 v4) true\n             (= v2 v3) true\n             (= v2 v4) true\n             :else false))\n\n        (combine-edges [[v1 v2] [v3 v4]]\n            (cond\n              (= v1 v3) [v2 v4]\n              (= v1 v4) [v2 v3]\n              (= v2 v3) [v1 v4]\n              (= v2 v4) [v1 v3]\n              :else (throw (ex-info \"Tried to combine no combinable vertices\" {}))))\n\n         (walked-through-all-nodes? [visited edges]\n           (empty? (clojure.set/difference (set (flatten (into [] edges))) visited)))]\n\n  (fn walk-connected-graph [original-edges]\n    (loop [working-edge (first original-edges)\n           edges (rest original-edges)\n           visited (set working-edge)\n           not-combinable []]\n      (cond\n        (walked-through-all-nodes? visited original-edges) true\n        (empty? edges) false\n        (combinable-edges? working-edge (first edges))\n          (recur\n            (combine-edges working-edge (first edges))\n            (concat not-combinable (rest edges))\n            (apply conj visited (flatten (filter #(combinable-edges? working-edge %) edges)))\n            [])\n        :else (recur\n                working-edge\n                (rest edges)\n                visited\n                (conj not-combinable (first edges)))))))","user":"5b60e88be4b0c6492753e70b"},{"code":"(fn [edges]\n  (letfn [(adjacent? [[v w] [x y]]\n            (or (= v x) (= v y) (= w x) (= w y)))]\n    (loop [frontier #{(first edges)}\n           edges-unvisited (disj edges (first edges))]\n      (if (empty? edges-unvisited)\n        true\n        (if (empty? frontier)\n          false\n          (recur (into (disj frontier (first frontier)) (filter #(adjacent? (first frontier) %) (disj edges-unvisited (first frontier))))\n          (clojure.set/difference edges-unvisited frontier)))))))","problem":91,"user":"4f7e29dde4b06e829148e1ca"},{"problem":91,"code":"(fn connected-graph?\n  [edges]\n  (let [sorted-edges (into [] edges),\n        heads (->> sorted-edges flatten set)]\n    (loop [out #{}, done #{}, head (ffirst sorted-edges)]\n      (if (nil? head)\n        (if (= (count heads) (count done))\n          true\n          false)\n        (let [new-out (into out (filter #(not= % head) (flatten (filter #(some #{head} %) sorted-edges)))),\n              new-done (conj done head)\n              new-head (first (clojure.set/difference new-out new-done))]\n          (recur  new-out new-done new-head\n                 )))))\n  )","user":"5545477fe4b0a04f79299531"},{"problem":91,"code":"(fn[g]\n  (let [all-node (distinct (flatten (seq g)))\n        data (merge-with concat\n                         (group-by first g) (group-by second g))]\n    (loop [cn #{} [a & un] [(first all-node)]]\n      (if-not a\n        (if (= (count cn) (count all-node))\n          true false)\n        (recur (conj cn a) (concat un (clojure.set/difference\n                                       (set (flatten (data a)))\n                                       (conj cn a))))))))","user":"5c2836ebe4b07e362c2305d4"},{"code":"(fn f [s]\n  (let [l (set (mapcat flatten s))\n        m (reduce #(merge-with into % (merge {(%2 0) #{(%2 1)}} {(%2 1) #{(%2 0)}})) {} s)]\n    (every? #(= l ((fn g [t m v]\n                     (if (t v)\n                       t\n                       (set (mapcat (partial g (conj t v) m) (m v))))) #{} m %)) l)))","problem":91,"user":"4efb2fd7535dced4c769f274"},{"code":"(fn [edge-set] (let [make-graph (fn [edge-set] (loop [result {} edges edge-set]\n                                                 (if (nil? edges) result\n                                                   (let [edge (first edges)\n                                                         from (first edge) to (second edge)\n                                                         update-fn (fn [j k] (if (nil? j) #{k} (conj j k)))\n                                                         new-result (update-in (update-in result [from] update-fn to) [to] update-fn from)]\n                                                     (recur new-result (next edges))\n                                                   )\n                                                 )\n                                               )\n                                )\n                     is-connected? (fn [graph] (loop [stack [(first (keys graph))] seen #{} expected (count (keys graph))]\n                                                 (if (empty? stack) (= (count seen) expected)\n                                                   (if (= (count seen) expected) true\n                                                     (let [current (peek stack)]\n                                                       (if (contains? seen current)\n                                                         (recur (pop stack) seen expected)\n                                                         (recur (reduce conj (pop stack) (into [] (graph current))) (conj seen current) expected)\n                                                       )\n                                                     )\n                                                   )\n                                                 )\n                                               )\n                                   )\n                     ]\n                 (is-connected? (make-graph edge-set))\n               )\n)","problem":91,"user":"526dd90de4b03e8d9a4a72fe"},{"problem":91,"code":"(fn [graph]\n  (letfn [(eliminate [s node] \n            (let [m (group-by #(or (= node (first %)) (= node (last %))) s)] \n              (reduce #(eliminate % (if (= node (first %2)) (last %2) (first %2))) (get m false) (get m true))))]\n    (let [[start end] (first graph)]\n      (empty? (eliminate (eliminate (rest graph) start) end)))))","user":"5392bfdee4b0b51d73faaeb2"},{"code":"(fn all-connected? [paths]\n  (letfn [\n    (all-nodes [paths]\n      (reduce #(conj % (first %2) (last %2)) #{} paths))\n    (connect-paths [paths]\n      (let [sorted-paths (sort-by first (map sort paths))\n            first-path (first sorted-paths)]\n      (reduce \n        #(if (or (% (first %2)) (% (last %2))) \n          (conj % (first %2) (last %2))\n          %)\n        (reduce conj #{} first-path)\n        sorted-paths)))]\n    (= (all-nodes paths) (connect-paths paths))))","problem":91,"user":"501c1492e4b086d93747d180"},{"problem":91,"code":"(fn connected? [graph]\n  (letfn [(vertices [edges]\n           \"Return the vertices in a set of [A B] edges.\"\n           (set (reduce concat edges)))\n          \n          (neighbours [vertex edges]\n           \"Return the neighbour vertices of vertex in a set of [A B] edges.\"\n           (disj (vertices\n                   (filter (fn [edge]\n                             (some #(= vertex %) edge))\n                           edges))\n                 vertex))\n          \n          (visit [edges]\n           \"Return the vertices visited in a breadth-first search of edges.\"\n           (loop [visited #{}\n                  queue [(first (vertices edges))]]\n             (if (empty? queue)\n               visited\n               (recur (conj visited (first queue))\n                      (concat (rest queue)\n                              (clojure.set/difference\n                                (neighbours (first queue) edges)\n                                visited))))))]\n    \n    (= (vertices graph) (visit graph))))","user":"55e2f502e4b050e68259b43c"},{"problem":91,"code":"(fn connected? [edges]\n  (letfn [(bfs [edges start]\n               (\n                 (fn breadth-first-search [edges [current & waiting :as visit-queue] visited]\n                   (if (empty? visit-queue)\n                     visited\n                     (let [\n                            candidate-edges (filter (fn [[a b]] (or (= a current) (= b current))) edges)\n                            candidate-nodes (distinct (mapcat (fn [edge] (filter #(not= % current) edge)) candidate-edges))\n                            new-nodes (filter #(not (contains? visited %)) candidate-nodes)\n                            ]\n                       (recur edges (concat new-nodes waiting) (conj visited current)))))\n                 edges [start] #{}))]\n    (if (empty? edges)\n      true\n      (let [\n             all-nodes (into #{} (apply concat edges))\n             connected-nodes (bfs edges (first all-nodes))\n             ]\n        (= connected-nodes all-nodes)))))","user":"5654e024e4b0f9d632dd848d"},{"code":"(fn graph-connectivity [coll]\n  (let [ne (fn [coll p] (first (filter #(or (= (first p) (first %)) (= (first p) (second %))) coll)))\n        replace (fn [coll p]\n  (let [rep (map #(vector (if (= (second p) (first % )) (first p) (first % )) \n                          (if (= (second p) (second %)) (first p) (second %))) coll)] \n\t(filter #(not (and (= (first p) (first %)) (= (first %) (second %)))) rep)) )] \n    (if (> 2 (count coll)) true\n       (loop [f (first coll) r coll] \n\t     (let [rep (replace r f)] \n\t       (if (empty? rep) true \n\t\t     (let [f (ne rep f)] (if (nil? f) false (recur f rep)))))))))","problem":91,"user":"523a9fc9e4b081681ca7adca"},{"problem":91,"code":"(fn [edges]\n         (let [add-kv          (fn [m [from to]]\n                                 (-> m\n                                     (update-in [from] (fnil conj #{}) to)\n                                     (update-in [to] (fnil conj #{}) from)))\n               m               (reduce add-kv {} edges)\n               all-nodes       (keys m)\n               connected-nodes (loop [visited #{(first all-nodes)}]\n                                 (let [next-nodes (->>\n                                                   (map m visited)\n                                                   (apply clojure.set/union)\n                                                   (filter #(not (visited %)))\n                                                   set)]\n                                   (if (empty? next-nodes)\n                                     visited\n                                     (recur (clojure.set/union visited next-nodes)))))]\n           (= (set (keys m)) connected-nodes)))","user":"5beadeb5e4b0f319e2d7ec88"},{"code":"(fn connected? [edges]\n  (= (set (apply concat edges))\n     (loop [vs #{(ffirst edges)}]\n       (if-let [nvs (seq (for [[a b] edges :when (and (vs a) (not (vs b)))] b))]\n         (recur (into vs nvs))\n         vs))))","problem":91,"user":"4f6160a7e4b0defedf855fbe"},{"problem":91,"code":"(fn [g]\n  (loop [q (map set g)]\n    (let [c (count q)\n          z (reduce (fn [[h & t :as a] y]\n                       (if (empty? (clojure.set/intersection h y))\n                         (conj a y)\n                         (into [(clojure.set/union h y)] t)))\n                     [(first q)] (-> q rest vec))]\n      (if (= c (count z)) (= 1 c)\n          (recur z)))))","user":"515bbcd9e4b0388ca8ca1521"},{"problem":91,"code":"(fn [edge]\n   (let [node (distinct (flatten (vec edge)))]\n     (loop [conn-node (hash-set (first node)) \n            rset (rest node)]\n         (if (empty? rset) \n         true \n         (let [redge (filter #(or (contains? conn-node (first %)) (contains? conn-node (second %))) edge)\n             rnode (distinct (flatten (vec redge)))\n             cset  (clojure.set/union (set rnode) conn-node)]\n           (do \n         (println conn-node rset rnode cset)\n           (cond \n            (=  cset conn-node)\n            false\n            :else (recur cset  (filter #(not (contains? cset %)) rset))\n            )\n         )\n         ))\n     ))\n   )","user":"53ca23e3e4b00fb29b2212c6"},{"problem":91,"code":"(fn connected? [graph]\n  (letfn [(build-paths [root edge-m to-visit]\n            ;head = value, tail = children\n            (if-let [children (seq (clojure.set/intersection (get edge-m root) to-visit))]\n              (list root (mapcat #(build-paths % edge-m (disj to-visit %)) children))\n              (list root)))\n          (connected? [s]\n            (let [x (seq s)\n                  nodes (set (distinct (flatten x)))\n                  edge-m (reduce\n                          (fn [m [a b]]\n                            (merge-with into m {a #{b}} {b #{a}}))\n                          {}\n                          x)\n                  root (first nodes)]\n              (-> (build-paths root edge-m (disj nodes root))\n                  (flatten)\n                  (distinct)\n                  (count)\n                  (= (count nodes)))))]\n    (connected? graph)))","user":"5b7f2d75e4b047b03b203768"},{"code":"(fn [e]\r\n  (let [\r\n\t\tg (reduce (fn [g [u v]] (assoc g u (conj (g u) v) v (conj (g v) u))) {} e)\r\n\t\tv (set (keys g))\r\n\t\th #(into % (mapcat g %))\r\n\t] (= v (first (drop (count v) (iterate h #{(first v)}))))))","problem":91,"user":"4f8c5f4fe4b02e764a0a5198"},{"problem":91,"code":"(fn connected? [graph]\n  (let [nodes (set (flatten (seq graph)))]\n    (loop [previous #{} connected (set (first graph))]\n      (if (= nodes connected) true\n          (if (= connected previous) false\n            (recur connected (into connected\n                                   (mapcat #(if (or (contains? connected (first  %))\n                                                    (contains? connected (second %)))\n                                                % ()) graph))))))))","user":"579d9601e4b05b1deef9ae18"},{"code":"(fn  [edgeset]\n  (letfn [(linked? [v w] (or (contains? edgeset [v w])\n  \t\t     (contains? edgeset [w v])))\n\t  (compose [p q]\n  (if (and (linked? (last p) (first q))\n           (empty? (clojure.set/intersection (set p) (set q)))\n\t   (not= (first p) (last q))) \n    (vec (concat p q))))\n\n\t(vertexset [edgeset]\n  (let [left (set (map #(% 0) edgeset))\n\tright (set (map #(% 1) edgeset))]\n    (clojure.set/union left right)))\n\n (vert2path [vertex-set]\n  (set (map (fn [i] [i]) (vec vertex-set))))\n\n(compose-paths [S T]\n  (->> (for [p (vec S) q (vec T)] (compose p q))\n       (filter identity) (set)))]\n\n(let [vertices (vertexset edgeset)\n      pathset (vert2path vertices)\n      n       (count vertices)]\n   (prn n pathset)\n    (not (empty? (nth (iterate (partial compose-paths pathset) pathset) (dec n)))))))","problem":91,"user":"4e6e3a1e535d5021c1a89602"},{"problem":91,"code":"(fn connected? [edges]\n   (let [vertices (set (apply concat edges))]\n     (letfn [(edge? [u v] (some (fn [[w z]] (or (= [w z] [u v]) (= [w z] [v u]))) edges) )\n             (neighbors [v] (filter (partial edge? v) vertices) )\n             (component [v] \n               (loop [seen #{v}\n                      toExplore [v]]\n                 (if (empty? toExplore) seen\n                   (let [u (first toExplore)\n                         newGuys (filter #(not (seen %)) (neighbors u))]\n                     (recur (into seen newGuys) (concat (rest toExplore) newGuys))     \n                     )\n                   )\n                 ))]\n       (= (count vertices) (count (component (first vertices))))\n       \n       )\n     )\n   )","user":"575ef4b6e4b08062f99a4e78"},{"problem":91,"code":"(fn connected? [edges]\n  (let [vertices (set (concat (map first edges) (map second edges)))\n\n        edges-map (reduce\n                   (fn [edges-map [a b]]\n                     (-> edges-map\n                         (update-in [a] #(if (nil? %) [b] (conj % b)))\n                         (update-in [b] #(if (nil? %) [a] (conj % a)))))\n                   {}\n                   (seq edges))]\n    (loop [visited #{} queue #{(first (first edges))}]\n      (cond\n        (empty? queue) (= (count visited) (count vertices))\n        :else\n        (let [current-vertex (first queue)\n              neighbors (set (get edges-map current-vertex))\n              not-yet-visited (clojure.set/difference neighbors visited queue)]\n          (recur (conj visited current-vertex)\n                 (clojure.set/union (set (rest queue)) not-yet-visited)))))))","user":"58b81490e4b0ebc645576d8c"},{"code":"(fn [g]\n  (let [neighbors #(map (juxt (comp first (partial remove #{%1}))\n                              identity)\n                        (filter (partial some #{%1}) %2))\n        index-of (fn [k coll]\n                   (first (keep-indexed #(when (= k %2) %1)\n                                        coll)))\n        remove-item (fn [e coll]\n                      (let [i (index-of e coll)]\n                        (concat (take i coll) (drop (inc i) coll))))\n        path? (fn path? [a b gg]\n                (boolean\n                  (some true?\n                        (for [[ngh-v ngh-e] (neighbors a gg)]\n                          (if (= ngh-v b)\n                            true\n                            (path? ngh-v b (remove-item ngh-e gg)))))))\n        vertexs (distinct (flatten (vec g)))]\n\n(not (some false? (for [a vertexs\n                        b (remove-item a vertexs)]\n                    (path? a b g))))))","problem":91,"user":"50d8de3fe4b01f0871336e72"},{"problem":91,"code":"(fn [edges]\n  (let [nodes (distinct (apply concat edges))\n        parent (zipmap nodes (repeat nil))\n        find-root (fn find-root [p v]\n                    (if (nil? (p v))\n                      v\n                      (find-root p (p v))))\n        union (fn [p x y]\n                (let [rx (find-root p x)\n                      ry (find-root p y)]\n                  (if (= rx ry)\n                    p\n                    (assoc p ry rx))))]\n    (loop [p parent es edges]\n      (if (empty? es)\n        (= 1 (count (filter nil? (vals p))))\n        (let [[x y] (first es)\n              p* (union p x y)]\n          (recur p* (rest es)))))))","user":"545e7ab0e4b01be26fd7467c"},{"problem":91,"code":"(fn connected? [edges]\n  (let [graph (apply merge-with\n                     into\n                     (mapcat\n                      (fn [[k v]]\n                        [{k #{v}}\n                         {v #{k}}])\n                      edges))\n        visit (fn f [n visitor]\n                (if (visitor n)\n                  visitor\n                  (for [x (graph n)]\n                    (f x (conj visitor n)))))]\n    (->> (flatten (visit (ffirst graph) #{}))\n         ((complement not-any?) (partial = (set (apply concat edges)))))))","user":"5dc88a38e4b02f9375f4e1db"},{"problem":91,"code":"(fn [edges]\n (letfn [\n    (mergeable? [s e] (if (some s e) true false))]\n   (loop [s (into #{} (first edges)) es edges]\n      (if (empty? es) true ;; finished\n         (let [groups (group-by (partial mergeable? s) es)\n                   tomerge (groups true)\n                   remaining (groups false)]\n            (if (empty? tomerge)\n                 false ;; can’t find any more\n                (recur (reduce #(into %1 %2) s tomerge) remaining)))))))","user":"54908cc1e4b0b312c081ff32"},{"problem":91,"code":"(fn connected? \n  [graph] \n  (letfn [(extend-edge-distance [graph vertices] (set (flatten (filter #(some (partial contains? vertices) %) graph))))\n          (connected-component \n            [graph vertices] \n            (let [result (extend-edge-distance graph vertices)]\n                 (if (= result vertices)\n                     result\n                     (recur graph result))))]\n    (= (set (concat (map first graph) (map second graph))) (connected-component graph (set #{(ffirst graph)})))))","user":"55acd080e4b03311e7b73298"},{"problem":91,"code":"(fn sol [space]\n  (letfn [ (next-visit [prev-visited space]\n            (-> (for [v prev-visited\n                      [a b] space\n                      :when (or (= a v) (= b v))] [a b])\n                flatten\n                set))\n           (start-space [space] (set (first space)))\n           (visits [prev-visited space]\n            (let [next-visited (next-visit prev-visited space)]\n              (if (= prev-visited next-visited)\n                next-visited\n                (visits next-visited space))))\n           (vertices [space]\n            (into #{} (flatten (seq space))))\n           (solve [space]\n            (let [start (start-space space)]\n              (= (vertices space) (visits start space))))]\n    (solve space)))","user":"5e08c3dde4b0978307768fc8"},{"code":"(letfn [(intersects? [s1 s2]\r\n          (seq (clojure.set/intersection s1 s2)))\r\n        (add-edge [components edge]\r\n          (if-not (some #(intersects? % edge) components)\r\n            (conj components edge)\r\n            (for [c components]\r\n              (if (intersects? c edge)\r\n                (clojure.set/union c edge)\r\n                c))))\r\n        (connected? [components]\r\n          (let [pairs (partition 2 1 components)]\r\n            (every? #(apply intersects? %) pairs)))]\r\n  (fn [edges]\r\n    (->> (map set edges)\r\n         (reduce add-edge [])\r\n         connected?)))","problem":91,"user":"4ebcb8ff535dfed6da9c6d8a"},{"problem":91,"code":"(fn graph-conn? [edgs]\n  (let [flip-edges (fn [xs] (map (fn [[a b]] [b a]) xs))\n        nodes-build (fn [ys]\n                      (reduce (fn [m [k v]] (assoc m k (conj (get m k #{}) v)))\n                      {} ys))\n        edges (seq edgs)\n        ed-dups-sorted (sort (concat edges (flip-edges edges)))\n        m-nodes (nodes-build ed-dups-sorted)\n        full-node-set (set (keys m-nodes))]\n    (letfn [(group-for [n]\n              (loop [acc #{n} nxt (get m-nodes n)]\n                (if (empty? nxt)\n                  acc\n                  (let [neu-nxt\n                         (clojure.set/difference\n                           (apply clojure.set/union (map #(get m-nodes %) nxt))\n                           acc)]\n                    (recur (into acc nxt) neu-nxt)))))]\n\n      (let [group-one (group-for (first full-node-set))\n            extra-nodes (clojure.set/difference full-node-set group-one)]\n        (empty? extra-nodes) ))))","user":"57f9011ee4b0d3187e900935"},{"problem":91,"code":"(fn solve [edges]\n  (let [nodes (reduce #(clojure.set/union %1 (set %2)) #{} edges)\n        adjs  (reduce\n               (fn [m [a b]]\n                 (update-in (update-in m [b] conj a) [a] conj b))\n               (zipmap nodes (repeat #{}))\n               edges)]\n\n    (=\n     nodes\n     (loop [queue (vector (first nodes))\n            visited (hash-set (first nodes))]\n\n       (if (empty? queue)\n         visited\n         (let [node (peek queue)\n               adj  (get adjs node)]\n\n           (recur (reduce\n                   #(if (contains? visited %2) %1 (conj %1 %2))\n                   (pop queue)\n                   adj)\n                  (clojure.set/union visited adj))))))))","user":"60537cd1e4b04c8f2157d152"},{"code":"(fn nodes-connected? \n  ([s] (nodes-connected? s #{}))\n  ([s prev]\n     (if (= s prev)\n         (= (flatten (map identity s))\n            (first s))\n       \n       (let [connected? (fn [s1 s2]\n                          (seq (clojure.set/intersection (into #{} s1) (into #{} s2))))\n             connected-reduce (fn [s1 s2]\n                                (if (connected? s1 s2)\n                                  (clojure.set/union s1 s2)\n                                  s1))\n             result (into #{} (map #(into [] (into #{} (reduce connected-reduce % s))) s))\n             ]\n         (nodes-connected? result s)))))","problem":91,"user":"5301157ae4b0d8b024fd3717"},{"problem":91,"code":"(fn problem-91-connections\n    [edges]\n    (let [init\n          (reduce (fn [a [l r]]\n                    (-> a\n                        (update-in [l] (fnil conj #{}) r)\n                        (update-in [r] (fnil conj #{}) l)))\n                  {}\n                  edges)\n\n          it\n          #(->> %\n                (vals)\n                (mapcat (fn [vs]\n                          (for [l vs\n                                r vs]\n                            [l r])))\n                (reduce (fn [a [l r]]\n                          (update-in a [l] conj r))\n                        %))\n          ]\n      (->> init\n           (trampoline (fn rec\n                         [a]\n                         (let [b (it a)]\n                           (if (= a b)\n                             a\n                             #(rec b))) )\n                       )\n           (vals)\n           (set)\n           (count)\n           (= 1))))","user":"58e37946e4b005f69f193cae"},{"code":"(fn __ [G]\n  (let [G' (set (mapcat (fn [[p q]] (list [p q] [q p])) G))\n        elems (set (mapcat (fn [[p q]] (list p q)) G))\n        dfs (fn dfs [visited node]\n              (if (contains? visited node)\n                visited\n                (->> G'\n                     (filter #(= node (first %)))\n                     (map second)\n                     (mapcat #(dfs (conj visited node) %))\n                     (concat visited)\n                     set)))]\n    (= elems (dfs #{} (first elems)))))","problem":91,"user":"536d83cee4b0fc7073fd6e5e"},{"problem":91,"code":"(fn is-connected [s]\n  (letfn [(get-nodes [a-s]\n            (set (flatten (vec a-s)))\n            )\n          (get-paths [head-node other-nodes]\n            (loop [rem-nodes other-nodes paths []]\n              (if (seq rem-nodes)\n                (recur (rest rem-nodes) (conj paths [head-node (first rem-nodes)]))\n                paths\n                )\n              )\n            )\n\n          (get-all-paths [nodes]\n  ;; What's going on here? Combination subsets of length two.\n            (loop [tail nodes paths []] \n              (let [head (first tail)]\n                (if (seq (rest tail)) \n                  (recur (rest tail) (into paths (get-paths head (rest tail))))\n                  paths)\n                )\n              )\n            )\n\n; (get-paths 1 (rest (get-nodes a-s)))\n; (get-all-paths (get-nodes a-s))\n          \n          (connected-paths [node graph]\n            (filter (fn [v] (some #(= node %) v)) graph)\n            )\n\n          (get-non-main-node [main path]\n            (some #(when (not= main %) %) path)\n            )\n\n          (get-connected-nodes [node graph]\n            (map #(get-non-main-node node %) (connected-paths node graph)))\n\n; (get-connected-nodes 1 a-s)\n          \n          (get-non-discovered-connectees [node graph discovered] \n            (let [possible (set (get-connected-nodes node graph))]\n              (let [undiscovered (apply disj possible discovered)]\n                undiscovered\n                )\n              )\n            )\n; (get-non-discovered-connectees 1 a-s [2])\n          \n; (disj #{1 2 3} 1 2)\n; (disj [1 2 3] 1 2)\n; What do I do w/ these connected nodes, non-discovered, etc?\n;  - Only go to non-discovered nodes\n;  - If connectees equal the last, good\n;  - If not, add the current to the discovered (How will it work w/ multi recursion?)\n          (path-exists [path graph]\n            (if (some #(= path %) graph)\n              true\n              (loop [cur-proxies [(first path)] discovered []]\n      ;; What's going on w/ the next-nodes binding\n      ;;  - Goes through the proxies and gets anything connected to them\n      ;;  - If the nodes are discovered, the hypothetically shouldn't be added\n      ;; How does it become nil at the third round?\n      ;; How does nil get in here in the first place?\n                (let [next-nodes (set (filter #(not (nil? %)) (flatten (for [n cur-proxies] (seq (get-non-discovered-connectees n graph discovered)))))) ]\n        ; (println next-nodes cur-proxies discovered)\n                  (if (and (seq next-nodes) (not (nil? (first next-nodes))))\n                    (if (some #(= (second path) %) next-nodes)\n                      true\n                      (recur next-nodes (into discovered cur-proxies))\n                      )\n                    false\n                    )\n                  )\n                )\n              )\n            )\n          ]\n\n    (if (= (count s) 1)\n      true\n      (loop [paths (get-all-paths (get-nodes s))]\n        (let [cur-path (first paths)]\n          (if (nil? cur-path)\n            true\n            (if (path-exists cur-path s)\n              (recur (rest paths))\n              false\n              )\n            )\n          )\n        )\n      ))\n)","user":"5ff676a9e4b06df49cee1497"},{"code":"(fn graph-connectivity[s]\n        (let[ rs (reduce \n                   (fn[rr aaa]\n                     (reduce \n                       (fn[rs [a b]] (if(or (get rs a) (get rs b)) (conj rs a b) rs))\n                       rr\n                       (next s)))\n                     (set (first s)) \n                     (range (count s)))\n                   _ (prn )]\n          (empty? (filter (fn[[a b]] (if(get rs a) false true)) s))))","problem":91,"user":"5273562ae4b03e8d9a4a7479"},{"code":"(letfn\r\n  [(add-pair [m rel [a b]]\r\n     (into (conj rel [a b])\r\n       (for [c (m b)] [a c])))\r\n    \r\n   (make-map [rel]\r\n     (apply merge-with clojure.set/union\r\n       (for [[a b] rel] {a #{b}})))\r\n      \r\n   (one-step [rel]\r\n     (let [m (make-map rel)]\r\n       (reduce (partial add-pair m)\r\n         #{} rel)))\r\n   (transitive [rel]\r\n     (let [new-rel (one-step rel)]\r\n        (if (= rel new-rel)\r\n         rel\r\n          (recur new-rel))))\r\n    (symmetric [rel]\r\n      (into rel (for [[a b] rel] [b a])))\r\n    (domain [rel]\r\n      (into #{} (map first rel)))\r\n    (square [n] (* n n))]\r\n  #(= (count (transitive (symmetric %)))\r\n      (square (count (domain (symmetric %))))))","problem":91,"user":"4ddbfb8a535d02782fcbea00"},{"problem":91,"code":"(fn graphconn [verts]\n  (let [all-nodes (reduce (fn [acc v] (conj acc (first v) (second v))) #{} verts)]\n    (letfn [(walk-graph [nodes-to-visit verts visited]\n                        (loop [visit (vec nodes-to-visit) remaining-verts verts already-visited visited] \n                               (if (empty? visit) \n                                 (if (empty? remaining-verts) true false)\n                                 (let [node (first visit)\n                                       matching (filter (fn [v] (some #{node} v)) (vec remaining-verts))\n                                       non-matching (filter (fn [v] (not (some #{node} v))) (vec remaining-verts))\n                                       non-visited (reduce\n                                                     (fn [acc v] (let [to-node (if (= (first v) node) (second v) (first v))]\n                                                                   (when (not (contains? already-visited to-node)) (conj acc to-node))))\n                                                     #{} matching)]\n                                   (recur (concat (rest visit) non-visited) non-matching (conj already-visited node) )\n                                 ))))]\n      (let [vert (first verts)\n            nodes-to-visit (conj #{} (first vert) (second vert))]\n        (walk-graph nodes-to-visit verts #{})))\n    )\n  )","user":"5592bf9fe4b0c79f6e1db933"},{"code":"(fn g-connected? [g]\n  (let [tcf (fn tcf [rels] \n          (let [tc (reduce (fn [rs [a b]] (into rs (keep #(if (= b (first %)) [a (second %)]) rs))) rels rels)]\n            (if (= tc rels) tc (recur tc))))\n        nc (->> g (apply list) flatten distinct count)]\n (= (* nc nc) (count (tcf (into g (map reverse g)))))))","problem":91,"user":"4effb663535dcb61093f6a2e"},{"code":"(fn [e]\n  (loop [[x & v] (first e) c #{} e e]\n    (cond\n      x (let [c (conj c x)\n              {conn x, disconn nil} (group-by #(some #{x} %) e)\n              n (remove c (flatten conn))]\n          (recur (concat v n) c disconn))\n      (seq e) false\n      :else true)))","problem":91,"user":"52b453b0e4b0c58976d9ad21"},{"problem":91,"code":"(fn [graph]\n  (let [nodes (distinct (flatten (into [] graph)))\n        pairs (for [x nodes y nodes] [x y])\n        graphlen (count graph)\n        searcher (fn [p]\n                   (let [start (first p)\n                         end (second p)]\n                     ((fn [nextpnts cnt]\n                       (cond\n                         (some #(= % end) nextpnts) true\n                         (>= cnt graphlen) false\n                         :else (recur\n                                (mapcat\n                                 (fn [sval]\n                                   (concat\n                                    (map second (filter #(= sval (first %)) graph))\n                                    (map first (filter #(= sval (second %)) graph))))\n                                   nextpnts)\n                          (inc cnt))))\n                      [start] 0)))]\n    (reduce #(and %1 %2) (for [pa pairs] (do (println pa (searcher pa)) (searcher pa))))))","user":"5705e404e4b0b0fb43fd0676"},{"code":"(fn [graph]\n  (loop [connected (into #{} (first graph)), queue (rest graph), later [], queue-size (count queue) ]\n    (if (seq queue)\n      (if (some (into #{} (first queue)) connected) \n        (recur (apply conj connected (first queue)) (rest queue) later queue-size)\n        (recur connected (rest queue) (conj later (first queue)) queue-size))\n      (if (seq later)\n        (if (== (count later) queue-size)\n          false\n          (recur connected later [] (count later)))\n        true))))","problem":91,"user":"4dca8b6d535d5973398f9288"},{"problem":91,"code":"(fn [graph]\n    (let [graph-map (reduce (fn [acc [a b]]\n                              (-> acc\n                                  (assoc  a (conj (get acc a []) b))\n                                  (assoc  b (conj (get acc b []) a))\n                                  ))\n                            {} graph)\n          nodes (into #{} (mapcat identity graph))\n          s (first (keys graph-map))                              ]\n      (letfn [(dfs [x graph acc]\n                (let [edges (get graph x [])\n                      acc (conj acc x)]\n                  (if  (or (empty? edges) (every? acc edges))\n                    acc\n                    (->> edges\n                         (remove acc)\n                         (reduce (fn [acc e]\n\n                                   (into acc (dfs e graph acc))) acc))\n                    )))]\n        (= nodes (dfs s graph-map #{})))\n      ))","user":"527ccaf4e4b0757a1b17136d"},{"code":"(letfn\n    [(connect [[xs [[a b] & more]]]\n       (cond\n        (nil? a)    [xs]\n        (or (xs a)\n            (xs b)) [(conj xs a b) more]\n        :else       [xs (concat more [[a b]])]))]\n  \n  #(nil?\n    (second\n     (last\n      (take\n       (* 2 (count %))\n       (iterate connect [(set (first %)) (seq %)]))))))","problem":91,"user":"52d2ca1ce4b099d49816f0b4"},{"code":"(fn [G]\n   (let [[[p _] & _ :as H] (vec G)\n         V (into #{} (flatten H)) \n         n\n         (fn [v [p q]]\n           (if (= v p)\n             [q]\n             (if (= v q)\n               [p]\n               [])))\n         m  (fn [v G] (reduce #(into % (n v %2)) #{} G))]\n     (loop [U #{p}]\n       (let [N (into U (mapcat #(m % G) U))]\n        (if (= N U)\n          (= U V)\n          (recur N)))\n      )))","problem":91,"user":"4e65027c535d8ccf87e9fe6e"},{"problem":91,"code":"(fn gc [graph]\n  (= (set (apply concat graph))\n\n((fn c\n  ([e] (c (ffirst e) #{} e))\n  ([t v e] \n    (reduce clojure.set/union v\n      (let [step (filter #(or (= t (first %)) (= t (second %))) e)\n          nbs (disj (set (concat (map first step) (map second step))) t)\n          rst (clojure.set/difference e step)\n          new (clojure.set/difference nbs v)\n          ]\n        ;(println \"t\" t \"n\" nbs \"r\" rst \"new\" new \"v\" v) \n        (if (empty? new)\n           (list #{t})\n          (for [n new]\n            (c n (into v #{t}) rst))\n        )\n      )   \n    )\n  )\n) graph)))","user":"56bca51ae4b0f26550335963"},{"code":"(fn [tr]\n  (let [\n    ftr (into #{} (concat tr (map reverse tr)))\n    marked (zipmap (into #{} (flatten (seq tr))) (repeat false))\n    adj (fn [node]\n      (into #{} (map second (filter #(= (first %) node) ftr))))\n    brf (fn brf [marks node queue]\n      (let [queue (remove marks (concat (adj node) queue))\n            marks (assoc marks node true)]\n        (if (seq queue) \n          (recur marks (first queue) (rest queue))\n          marks)))\n    marked (brf marked (ffirst ftr) '())]\n    (nil? (some false? (vals marked)))))","problem":91,"user":"4dcd2065535d5973398f929a"},{"problem":91,"code":"(fn connected?\n  [graph]\n  (let [adj-list (reduce (fn [acc [a b]]\n                           (-> acc\n                               (update-in [a] (fnil conj #{}) b)\n                               (update-in [b] (fnil conj #{}) a)))\n                         {}\n                         graph)\n        fixed-point (fn fixed-point [f x]\n                      (let [fx (f x)]\n                        (if (= fx x)\n                          x\n                          (recur f fx))))]\n    (= (fixed-point (fn [s]\n                      (reduce (fn [acc node]\n                                (into acc (get adj-list node))) s s))\n                    #{(first (first graph))})\n       (set (reduce concat graph))))\n  )","user":"5f29837ee4b033932238a64f"},{"problem":91,"code":"(fn dfs [s]\n  (let [checker (fn [m b e]\n                  (if-let [current-set (get m b)]\n                    (update-in m [b] conj e)\n                    (assoc m b #{e})))\n        table (reduce (fn [pre [begin end]]\n                        (checker (checker pre begin end)\n                                 end\n                                 begin))\n                      {} s)\n        nodes [(first (keys table))]]\n    (loop [nodes nodes\n           ret #{}]\n      (if (empty? nodes)\n        (->> s\n             (into [])\n             (apply concat)\n             set\n             (= ret))\n        (let [item (first nodes)]\n          (if (contains? ret item)\n            (recur (rest nodes) ret)\n            (recur (if-let [next-items (get table item)]\n                     (concat next-items (rest nodes))\n                     (rest nodes))\n                   (conj ret item))))))))","user":"58fed70de4b0438e51c2cfdd"},{"problem":91,"code":"(fn connected? [edge-set]\n  (let \n    [edges (vec (into edge-set (map reverse edge-set)))\n     ] \n    \n    (loop \n      [reached [[(first (first edges))]]\n       unreached edges\n       ] \n      \n      (if (empty? reached) \n        (empty? unreached) \n        (let \n          [p (group-by (fn [[h t]] (contains? (set (map last reached)) h)) unreached )]\n          (recur (p true) (p false))\n          )\n        \n        ))\n    ))","user":"533a2f7be4b0e30313ee6cb8"},{"problem":91,"code":"(fn\n  ff\n  ([s]\n   (if (= 1 (count s))\n     true\n     (ff [(first s)] (rest s))))\n  ([f r]\n   (let [tr (mapcat #(filter (fn [x] (or (= (first x) (second %)) (= (second x) (first %)) (= (first x) (first %)) (= (second x) (second %)))) r) f)]\n     (if (and (empty? tr) (empty? r))\n       true\n       (if (and (empty? tr) (not (empty? r)))\n         false\n       (recur tr (remove #(some (fn [x] (= % x)) tr) r)))))))","user":"56ab7578e4b03c432f18733d"},{"problem":91,"code":"(fn connected? [undirected-edges]\n  (letfn [(neighbours [r [k v]]\n            (update-in r [k] (fnil conj []) v))\n          (path [graph start seen]\n            (if (seen start)\n              seen\n              (for [node (graph start)]\n                (path graph node (conj seen start)))))\n          (directed-graph [edges]\n            (reduce neighbours {}\n                    (concat undirected-edges\n                            (map reverse undirected-edges))))]\n    (let [nodes (->> undirected-edges\n                     (into [])\n                     (apply concat)\n                     distinct\n                     set)]\n      (->> (path (directed-graph undirected-edges) (first nodes) #{})\n           flatten\n           (some #(= nodes %))\n           boolean))))","user":"572ea970e4b0cd1946bd0f89"},{"code":"(fn is-connected [graph]\n    (let\n        ;; reducedgraphset gets rid of all edges [a b] when [b a] exists in the graph                                                                                                                                                                                         \n        [reducedgraphset (reduce #(if (contains? %1 [(second %2) (first %2)]) %1 (conj %1 %2)) #{} graph)\n\n         ;; Helper function for turning a set of edges into points                                                                                                                                                                                                            \n         topoints (fn [edges] (set (reduce #(conj (conj %1 (first %2)) (second %2)) edges)))\n\n         ;; All of the points we need to visit                                                                                                                                                                                                                                \n         allpoints (topoints reducedgraphset)\n\n         ;; Helper function that finds neighboring edges                                                                                                                                                                                                                      \n         neighbors (fn [gr e] (set (filter\n                                    #(not (empty? (clojure.set/intersection (set %) (set e))))\n                                    gr)))\n\n         ;; Build the closure of all edges attached to this edge.                                                                                                                                                                                                             \n         closure-builder (fn closure-builder [graph edge]\n                           (loop [builder #{edge}\n                                  edges-to-examine [edge]]\n                             (if (empty? edges-to-examine)\n                               builder\n                               (let [edge (first edges-to-examine)\n                                     next-edges (clojure.set/difference (neighbors graph edge) builder)]\n                                 (recur (set (concat builder next-edges))\n                                        (concat next-edges (rest edges-to-examine)))))))]\n\n      ;; Check the closure of every point/edge in the set.                                                                                                                                                                                                                    \n      (if (= 1 (count reducedgraphset)) true\n          (not (empty?\n                (filter #( = (count allpoints) (count %))\n                        (map topoints\n                             (for [edge reducedgraphset]\n                               (closure-builder reducedgraphset edge)))))))))","problem":91,"user":"515737f0e4b0b0b4b87062d0"},{"problem":91,"code":"(letfn [(partition-grps [xs]\n          (reduce (fn [a [p q]]  \n                    (let [p-grps (group-by #(% p) a)\n                          q-grps (group-by #(% q) (p-grps nil))\n                          pq-grp (concat [p q] (apply concat (p-grps p))  \n                                               (apply concat (q-grps q)))]\n                      (cons (set pq-grp) (q-grps nil)))) #{} xs))]\n  (fn [xs] \n    (= (count (partition-grps xs)) 1)))","user":"5884e807e4b0f1effa3b76a6"},{"code":"(fn [graph]\n  (let [vertices (set (apply concat graph))]\n    (letfn [(vertex-connectness [vertex searched-vertex graph]\n              (let [adjacent-vertices (filter #(not (searched-vertex %)) (apply concat (filter #(some #{vertex} %) graph)))]\n                (if (seq adjacent-vertices)\n                  (set (mapcat #(vertex-connectness % (set (cons % searched-vertex)) graph) adjacent-vertices))\n                  searched-vertex)))]\n      (every? #(= vertices (vertex-connectness % #{%} graph)) vertices))))","problem":91,"user":"514d7e29e4b019235f6c0587"},{"problem":91,"code":"(fn connected? [g]\n  (let [g (into g (map (fn [[s t]] [t s]) g))\n        g (group-by first g)\n        nodes (set (keys g))]\n    (letfn [(not-visited [visited? [_ t]]\n              (when (not (visited? t)) t))\n            (walk [n visited?]\n              (reduce\n                #(into %1 (walk %2 %1))\n                (conj visited? n)\n                (keep #(not-visited visited? %) (g n))))]\n      (= nodes (walk (first nodes) #{})))))","user":"5f300f28e4b033932238a682"},{"problem":91,"code":"(fn is-connected?\n  [g]\n  (let [[x & xs] (sort (seq g))]\n    (= (into #{} (mapcat identity g)) (reduce (fn [a e]\n                               (if (seq (clojure.set/intersection a (set e)))\n                                 (into a e) a)) (set x) xs))))","user":"506f0968e4b09350ab4199f5"},{"code":"(fn connected? [nodegraph]\n  (letfn [(all-nodes [nodegraph]\n            (into #{} (mapcat identity nodegraph)))\n\n          (node-connection [edge node]\n            (cond\n             (= (first edge) node) (second edge)\n             (= (second edge) node) (first edge)))\n\n          (paths-from [nodegraph node]\n            (let [nodes (map #(node-connection % node) nodegraph)\n                  node-set (disj (set nodes) nil)]\n              node-set))\n\n          (rand-set [nodeset]\n            (rand-nth (seq nodeset)))\n\n          (visited-all? [nodeset visitedset]\n            (= nodeset visitedset))]\n\n    (let [nodes (all-nodes nodegraph)]\n      (loop [visited #{} to-visit #{(rand-set nodes)}]\n  (if (empty? to-visit)\n          (visited-all? visited nodes)\n          (let [next-visit (rand-set to-visit)\n                paths (paths-from nodegraph next-visit)\n                new-paths (clojure.set/difference paths visited)]\n            (recur (conj visited next-visit) (into (disj to-visit next-visit) new-paths))))))))","problem":91,"user":"4f0d093b535d0136e6c22313"},{"code":"(fn [g]\n  (= (-> g seq flatten set)\n     (nth (iterate #(if (seq %)\n                      (reduce (fn [x y]\n                                (if (some (set y) x)\n                                  (into x y)\n                                  x))\n                              % g)\n                      (set (first g))) \n                   #{}) \n          9)))","problem":91,"user":"4e823ed7535db62dc21a62c7"},{"problem":91,"code":"(fn [edges]\n  (->> (reduce \n        (fn [graph edge]\n          (let [sub-graph1 (some #(if (% (first edge)) %) graph)\n                sub-graph2 (some #(if (% (second edge)) %) graph)]\n            (conj \n             (disj graph sub-graph1 sub-graph2)\n             (set (concat sub-graph1 sub-graph2 edge)))))\n        #{}\n        edges)\n       (count)\n       (= 1)))","user":"536f871de4b0fc7073fd6e7f"},{"code":"(fn [s]\n  (let [all (set (flatten (seq s)))\n        trans-cloj (fn [s]\n                     (let [s-bi (set (concat s (map reverse s)))\n                           s2 (reduce (fn [t [a b]]\n                                        (set (concat t (map (fn [[c d]] [a d])\n                                                            (filter (fn [[c d]]\n                                                                      (= b c)) s-bi)))))\n                                      s-bi s-bi)]\n                       (if (= s2 s) s (recur s2))))\n        tc-map (apply merge-with #(set (concat %1 %2))\n                      (map (fn [[a b]] {a #{b}}) (trans-cloj s)))]\n    (apply = all (vals tc-map))))","problem":91,"user":"50acbd15e4b071b89ef26234"},{"problem":91,"code":"(fn [xs]\n  (let [r (reduce (fn [m [a b]]\n                    (let [s (clojure.set/union (get m a #{a}) (get m b #{b}))]\n                      (into m (for [v s] [v s])))) {} xs)]\n    (= (set (keys r)) (first (vals r)))))","user":"5594721de4b0c79f6e1db955"},{"code":"(fn  [c]\r\n  (let [[f & r] (seq c)\r\n        h #(apply concat %)]\r\n    (= (set (h c))\r\n     (reduce (fn [a x] \r\n               (into a (h (filter #(some a %) c))))\r\n             (set f) r))))","problem":91,"user":"4dada16fc9a9d6ed2699dc57"},{"problem":91,"code":"(fn [xs]\n (letfn [(creategraph2 [ys] (reduce (fn [m [a b]] (assoc m a (conj (m a) b) b (conj (m b) a))) {} ys))\n         (walkgraph2 [m start visited]\n           (if (contains? visited start) visited\n             (reduce #(clojure.set/union % (walkgraph2 m %2 (conj visited start))) visited (m start))))]\n   (let [allnodes (-> (creategraph2 xs) keys set)]\n     (boolean (some #(= allnodes %) (map #(walkgraph2 (creategraph2 xs) % #{}) allnodes))))))","user":"53e9a15be4b036ad0777e4ae"},{"code":"(fn f91 [st]\n  (let [con (fn [[fsn scn] st]\n              (-> #(or (= fsn\n                          (second %))\n                       (= scn\n                          (first %))\n                       (= scn\n                          (second %))\n                       (and (= fsn\n                               (first %))\n                            (not= [fsn scn] %))\n                       (and (= scn\n                               (second %))\n                            (not= [fsn scn] %)))\n                  (filter st)))\n\n        acons (fn [st]\n                (vec (map #(conj (set (con % st)) %)\n                          st)))\n\n        mset (fn [st1 st2]\n               (if (empty? (clojure.set/intersection st1 st2))\n                   nil\n                   (clojure.set/union st1 st2)))\n\n        tc (atom #{})\n\n        mall (fn mall [st]\n               (if (= 1 (count st))\n                   st\n                   (let [rst (mset (first st)\n                                   (second st))]\n                     (if (nil? rst)\n                         (if (some #(= (second st) %)\n                                   @tc)\n                             st\n                             (do (swap! tc conj (second st))\n                                 (mall (vec (cons (first st)\n                                                  (conj (vec (nthrest st 2))\n                                                        (second st)))))))\n                         (mall (vec (->> (nthrest st 2)\n                                         (cons rst))))))))]\n    (if (= 1 (count (mall (acons st))))\n        true\n        false)))","problem":91,"user":"528a3e14e4b0239c8a67ae72"},{"code":"(fn [l]\r\n    (let [r (fn [e s] (remove #(= e %) s))\r\n          adjs (fn [x y] (filter #(some (set x) (set %)) (r x y)))\r\n          h (fn [f lst] (reduce #(or % %2) (map #(f % (r % lst)) lst)))\r\n          g (fn f [x l]\r\n                  (cond (empty? l) true\r\n                        (empty? (adjs x l)) false\r\n                        :else (h f l)))\r\n         ]\r\n      (h g l)\r\n    )\r\n  )","problem":91,"user":"4f58d92fe4b0a7574ea71858"},{"code":"(fn [s]\r\n  (let\r\n     [nodes (distinct (reduce #(concat %1 %2) '() s))\r\n      get-siblings (fn [n] (reduce #(if (= n (nth %2 0)) (conj %1 (nth %2 1)) (if (= n (nth %2 1)) (conj %1 (nth %2 0)) %1))  #{} s))\r\n      sum (fn [a b] (reduce #(conj %1 %2) a b))\r\n      sub (fn [a b] (reduce #(disj %1 %2) a b))\r\n      ccc (fn [n] (loop [to-process (get-siblings n) processed #{n}]\r\n                    (if (empty? to-process) processed (recur (#(sub % processed) (#(sum (get-siblings (first to-process)) %) (set (rest to-process))))\r\n                                                             (conj processed (first to-process))))))\r\n      ]\r\n    (= (set nodes) (ccc (first nodes)))))","problem":91,"user":"4f03822f535dcb61093f6b03"},{"problem":91,"code":"(fn [grph]\n(loop [graph (set (map set grph))] \n  (if (<= (count graph) 1)\n    true\n\n    (let [work(first (first graph))\n\n          get-nodes (fn [g] (if (empty? g)\n                                #{}\n                                (reduce into g)))\n\n          nodes (get-nodes graph)\n\n          new-edges\n           (for [i nodes j nodes\n                 :when (and (= 3 (count (distinct [i j work])))\n                            (graph #{i work}) \n                            (graph #{j work}))]\n             #{i j})\n\n          old-edges\n           (set\n             (filter #(every? (partial not= work) %)\n                     graph))\n          new-graph \n          (into old-edges new-edges)\n\n          nodes-removed \n            (- (count nodes) (count (get-nodes new-graph)))] \n  \n    (if (> nodes-removed 1)\n      false\n      (recur new-graph))))))","user":"56194c11e4b053970a773af4"},{"problem":91,"code":"(fn connected? [edges]\n  (let [nodes (set (apply concat edges))\n        num-nodes (count nodes)\n        adjacency-mat\n        (reduce (fn [ret [x y :as edge]]\n                  (-> (update-in ret [x] conj y)\n                      (update-in [y] conj x)))\n                (into {} (map vector nodes (repeat #{})))\n                edges)\n        walk\n        (fn walk [visited node]\n          (lazy-seq\n            (let [neighbors (adjacency-mat node)\n                  visited   (conj visited node)\n                  unvisited (clojure.set/difference neighbors visited)]\n              (cond (= num-nodes (count visited)) (list true)\n                    (empty? unvisited) (list nil)\n                    :else\n                    (mapcat (partial walk visited) unvisited)))))]\n    (boolean (some true? (walk #{} (first nodes))))))","user":"571c2babe4b07c98581c3b73"},{"code":"(fn [m]\n  ((fn f [x y]\n  (if (empty? y)\n    true\n    (let [a (remove #(empty? (clojure.set/intersection x (set %))) y)\n          b (apply clojure.set/union x (map set a))]\n      (if (empty? a)\n        false\n        (f b (remove (set a) y)))))) (set (first (seq m))) (rest (seq m))))","problem":91,"user":"529b44afe4b02ebb4ef7509d"},{"code":"(fn [graph] (letfn [\n(nodes [graph]\n  (distinct (flatten (vec graph))))\n\n(findconnectednodes [node graph nodes]\n   (concat (map first (filter (fn [connector] (= node (last connector))) graph))\n     (map last \n       (filter (fn [connector] \n         (= node (first connector))) \n           graph))))\n\n(getallconnected [node graph nodes]\n  (letfn [(doit [current found]\n    (if (contains? found current)\n       found\n       (let [\n         connected (findconnectednodes current graph nodes)\n         newfound (set (conj found current))]\n         (set (mapcat\n           (fn [connect]\n             (doit connect newfound)) connected)))))]\n    (doit node #{})))]\n(= (count (nodes graph))\n   (count (getallconnected  (ffirst graph) graph (nodes graph))))))","problem":91,"user":"4daa374930acd6ed13482a68"},{"problem":91,"code":"(comp odd? count)","user":"4ecf1f51535d1f5ad70dba3a"},{"problem":91,"code":"(fn [edges]\n  (let [vertices (apply hash-set (distinct (flatten (seq edges))))]\n    (loop [visited #{(first vertices)} remaining edges]\n      (if (= visited vertices)\n        true\n        (let [{:keys [can-visit later]} (group-by #(if (some visited %) :can-visit :later) remaining)]\n          (if (empty? can-visit)\n            false\n            (recur (apply conj visited (flatten can-visit)) (apply hash-set later))))))))","user":"57b3efb1e4b0fbc9809a278a"},{"problem":91,"code":"(fn connexe? [g]\n  (let [vertices (reduce #(conj (conj %1 (first %2)) (second %2))\n                         #{}\n                         g)\n        adjacent (fn [v g]\n                   (into #{}\n                         (reduce #(cond (= v (first %2))\n                                        (conj %1 (second %2))\n                                        (= v (second %2))\n                                        (conj %1 (first %2))\n                                        :else %1)\n                                 []\n                                 g)))\n        has-path? (fn [v1 v2 g]\n                    (loop [cur (adjacent v1 g)\n                           explored #{v1}]\n                      (if (seq cur)\n                        (if (some #(= v2 %) cur)\n                          true\n                          (let [new-cur (adjacent (first cur) g)\n                                new-explored (conj explored\n                                                   (first cur))]\n                            (recur (clojure.set/difference\n                                    (clojure.set/union cur new-cur)\n                                    new-explored)\n                                   new-explored)))\n                        false)))]\n    (every? #(has-path? (first vertices) % g) (rest vertices))))","user":"5a6b9b95e4b0512ff01cda40"},{"problem":91,"code":"(fn [g]\n  (if (<= (count g) 1)\n    true\n    (let [g (reduce #(conj %1 (set %2)) #{} g)\n          conn? (fn [s1 s2]\n                  (seq (clojure.set/intersection s1 s2)))\n          intersect (fn [g]\n                      (if (<= (count g) 1)\n                        g\n                        (let [f (first g)\n                              ns (set (next g))\n                              r (some #(if (conn? f %) % nil) ns)]\n                          (if r\n                            (recur (conj (disj ns r)\n                                         (clojure.set/union f r)))\n                            g))))]\n      (<= (count (intersect g)) 1))))","user":"549c6792e4b0f3d1d8e70f8b"},{"code":"(fn gc [edges]\r\n  (loop [core #{}\r\n         fringes #{(first edges)}\r\n         rest-edges (disj edges (first edges))]\r\n     (cond\r\n       (empty? rest-edges) true\r\n       (empty? fringes) false\r\n       :else (let [edge (first fringes)\r\n                   {connected-edges true, new-rest-edges false}\r\n                   (group-by #(or (= (first %) (first edge))\r\n                                  (= (first %) (second edge))\r\n                                  (= (second %) (first edge))\r\n                                  (= (second %) (second edge)))\r\n                             rest-edges)]\r\n               (recur (conj core edge)\r\n                      (-> fringes (disj edge) (into connected-edges))\r\n                      new-rest-edges)))))","problem":91,"user":"4fcc6cb3e4b0ee37620e1861"},{"code":"(fn [edges]\n  (letfn [(edge->hashes [edge]\n            (let [[a b] edge]\n              [{a #{b}}\n               {b #{a}}]))\n          (edges->graph [edges]\n            (let [hashes (flatten (map edge->hashes edges))]\n              (apply merge-with clojure.set/union hashes)))\n          (graph-connected? [graph]\n            (let [nodes (set (keys graph))]\n              (loop [seen #{}\n                     to-visit [(first nodes)]]\n                (if-let [[this-node & to-visit] (seq to-visit)]\n                  (let [seen (conj seen this-node)\n                        connected-nodes (graph this-node)\n                        unvisited-nodes (clojure.set/difference connected-nodes seen)\n                        to-visit (concat to-visit unvisited-nodes)]\n                    (recur seen to-visit))\n                  (= seen nodes)))))]\n    (graph-connected? (edges->graph edges))))","problem":91,"user":"4e80aa10535db62dc21a62b1"},{"code":";; https://github.com/khotyn/4clojure-answer/blob/master/91-graph-connectivity.clj\n;; learn later...\n(fn connected? [edges]\n  (let [nodes (set (apply concat edges))]\n    (letfn [(path [node found-nodes]\n              (if-let [adjacents (seq (filter #(not (found-nodes %))\n                                              (apply concat (filter #(some #{node} %) edges))))]\n                (set (mapcat #(path % (set (cons % found-nodes))) adjacents))\n                  found-nodes))]\n      (every? #(= nodes (path % #{%})) nodes))))","problem":91,"user":"511b9017e4b00c2a1fa7ff6b"},{"problem":91,"code":"(fn r [s] (let [f #(first %) l #(last %) z #(rest %) x (reduce #(if (or (contains? (f %) (f %2)) (contains? (f %) (l %2))) (into (conj [] (conj (f %) (f %2) (l %2))) (z %)) (conj % %2)) (conj [] (set (f s))) (into [] (z s)))] (if (empty? (z s)) true (if (= (z s) (z x)) false (r x)))))","user":"56c08696e4b060a8e693e3aa"},{"problem":91,"code":"(fn connected [xs]\n  (loop [visited (conj #{} (first xs))\n         unvisited (rest xs)]\n    (or (= xs visited)\n        (let [node-nums (reduce (fn [accum item]\n                                  (apply conj accum item)) visited)\n              neighbors (filter\n                         (fn [item]\n                           (some #(or (= (first item) %)\n                                      (= (second item) %)) node-nums))\n                         unvisited)]\n          (if (empty? neighbors)\n            false\n            (recur (apply conj visited neighbors)\n                   (remove (apply conj #{} neighbors) unvisited)))))))","user":"563fc1f2e4b08d4f616f5ed7"},{"problem":91,"code":"(fn connected? [graph] (let [candidate (first (first graph))\n                               nodes (into [] (disj (reduce #(into %1 %2) #{} graph) candidate))\n                               getNext (fn [s x] (into s (filter #(some #{x} %1) graph)))\n                               nextLevel (fn [level visited] (apply disj (into #{} (flatten (reduce getNext [] level))) (into level visited)))\n                               connectedPair? (fn [root cand] (loop [visited #{cand} next #{cand}] (cond\n                                                                                                             (empty? (nextLevel next visited)) false\n                                                                                                             (some #{root} (nextLevel next visited)) true\n                                                                                                             :default (recur (into visited next) (nextLevel next visited)))))\n\n                               ] (if (= 1 (count graph)) true (every? #(connectedPair? candidate %1) nodes))))","user":"56427910e4b08d4f616f5f19"},{"problem":91,"code":"(fn [ms]\n  (let [tour-ok (atom false)]\n    (doseq [v ms]\n      ((fn find-next-item [rest ok-items]\n         (if (= (count ms) (count ok-items)) \n           (reset! tour-ok true)\n           (if-let [next-items (not-empty \n                                (filter #(or (= (first (first ok-items)) (last %))\n                                             (= (last (last ok-items)) (first %))\n                                             (= (first (first ok-items)) (first %))\n                                             (= (last (last ok-items)) (last %))) \n                                        rest))]\n             (doseq [next-item next-items]\n               (find-next-item (filter #(not= next-item %) rest)\n                               (cond\n                                (= (first (first ok-items)) (last next-item)) (cons next-item ok-items)\n                                (= (first (first ok-items)) (first next-item)) (cons (reverse next-item) ok-items)\n                                (= (last (last ok-items)) (last next-item)) (conj ok-items (reverse next-item))\n                                :else (conj ok-items next-item))))\n             (println ok-items))))\n       (filter #(not= v %) ms)\n       [v]))\n    @tour-ok))","user":"55a0d79fe4b0acc240e31502"},{"problem":91,"code":"(fn [coll]\n (letfn [(op [[accum c]]\n          (reduce (fn [[r rst] [f s :as cand]] \n                   (if (or (r f) (r s))\n                    [(into r cand) rst]\n                    [r (conj rst cand)])) accum c))]\n        (empty? (last (->> [[(into #{} (first coll)) []] (rest coll)]\n                       op\n                       ((fn [[a b]] [[a []] b]))\n                       op)))))","user":"5835cb06e4b089d5ab817cea"},{"problem":91,"code":"(fn c [g]\n  (let [n (set (flatten (apply vector g)))\n        m (reduce #(assoc %1 (first %2) (conj (get %1 (first %2) #{(first %2)}) (second %2))) {} g)\n        r (loop [mm m p {}]\n            (if (= mm p)\n              mm\n              (recur (reduce\n                       #(assoc\n                         %1\n                         (first %2)\n                         (set (clojure.set/union (second %2) (apply clojure.set/union (map (fn [e] (get mm e)) (second %2))) )))\n                       {} mm)\n                     mm)\n              )\n            )]\n    (true? (some #(= (count n) (count %)) (vals r)))\n    )\n  )","user":"55eeb37ae4b0121d4835fdf3"},{"code":"(fn [es]\n  (let [a (apply merge-with clojure.set/union\n                   (map (fn [[a b]] {a #{b}})\n                        (concat es (map reverse es))))]\n    (loop [r #{(ffirst a)}]\n      (if-let [n (seq (remove r (mapcat a r)))]\n        (recur (into r n))\n        (every? r (keys a))))))","problem":91,"user":"4e8612f8535db62dc21a62f2"},{"code":"(fn [g]\n  (not (next\n    (reduce\n      (fn [g [x y]]\n        (let [l (fn [n] (some #(when (% n) %) g))\n              a (l x)\n              b (l y)]\n          (if a\n            (if b\n              (conj (disj g a b) (into a b))\n              (conj (disj g a) (conj a y)))\n            (if b\n              (conj (disj g b) (conj b x))\n              (conj g (set [x y]))))))\n      #{}\n      g))))","problem":91,"user":"4db858d1535d1e037afb218c"},{"code":"(fn r \n  ([g] (r (rest g) (set [(first (first g))])))\n  ([g c]\n    (let [a (filter #(some c %) g)\n          b (remove #(some c %) g)]\n      (if (empty? a)\n        (empty? b)\n        (r b (into c (apply concat a)))))))","problem":91,"user":"4db863d7535d1e037afb2190"},{"code":"(fn [graph]\n  (let [vertices (set (apply concat graph))]\n    (letfn [(connected? [v1 v2]\n              (or (contains? graph [v1 v2])\n                  (contains? graph [v2 v1])))\n            (visit [v visited-vertices]\n              (conj visited-vertices v))\n            (visited? [v visited-vertices]\n              (contains? visited-vertices v))\n            (dfs [v visited-vertices]\n              (let [visited-vertices\n                    (visit v visited-vertices)\n                    connected-vertices\n                    (filter #(connected? v %) vertices)]\n                (reduce #(if (visited? %2 %1)\n                           %1\n                           (dfs %2 %1))\n                        visited-vertices connected-vertices)))]\n      (if (empty? vertices)\n        false\n        (= (count vertices)\n           (count (dfs (first vertices) #{})))))))","problem":91,"user":"4e4b4564535dc968683fc4d3"},{"problem":91,"code":"(fn [links]\n  (= 1 (count\n(reduce \n  (fn [mem [na nb :as link]] \n    (let [na-set (some (fn [x] (if (x na) x)) mem)\n      nb-set (some (fn [x] (if (x nb) x)) mem)\n      operations \n    (if (nil? na-set)\n      (if (nil? nb-set) \n        {:remove [] :add (set link)}\n        {:remove [nb-set] :add (conj nb-set na)})\n      (if (nil? nb-set) \n        {:remove [na-set] :add (conj na-set nb)}\n        {:remove [na-set nb-set] :add (reduce conj na-set nb-set)}))]\n      (conj (reduce #(disj %1 %2) mem (:remove operations)) (:add operations)))) \n        #{} links))))","user":"50856bd1e4b004985b776e4c"},{"problem":91,"code":"(fn f \n  ([es]\n   (if (nil? (rest es)) \n     true \n     (f (rest es) (apply conj #{} (first es)))))\n  ([es cs] \n   (letfn [(t [[a b]] (or (cs a) (cs b)))]\n     (cond \n       (empty? es) true\n       (= (remove t es) es) false\n       :else (f \n               (remove t es) \n               (apply conj cs (flatten (filter t es))))))))","user":"5e2549c8e4b05b4b0151615f"},{"problem":91,"code":"(fn [xs]\n  (loop [xs xs zs #{}]\n    (if (empty? xs) true\n      (letfn [(conn? [[a b]] (or (empty? zs) (contains? zs a) (contains? zs b)))]\n        (if-let [[a b :as x] (first (filter conn? xs))]\n          (recur (remove #{x} xs) (into zs (set [a b])))\n          false)))))","user":"553e0b70e4b0a04f792994e8"},{"code":"(fn [g]\n  (loop [g g n (first (first g))]\n    (if (< (count g) 2)\n      true\n      (let [edges (filter #(contains? (set %) n) g)\n            nodes (set (distinct (flatten edges)))\n            infected-graph (map \n                             #(if (= (first %) n)\n                                [n n]\n                                (if (contains? nodes (first %))\n                                  [n (last %)]\n                                  %)) g)]\n        (if (empty? edges)\n          false\n          (recur (filter #((complement =) (first %) (last %)) infected-graph) n))))))","problem":91,"user":"514721c6e4b0d520409ed392"},{"problem":91,"code":"(fn [s]\n   (if (or (empty? s) (= 1 (count s)))\n     true\n     (letfn [(permutations [s]\n               (lazy-seq\n                 (if (seq (rest s))\n                   (apply concat (for [x s]\n                                   (map #(cons x %) (permutations (remove #{x} s)))))\n                   [s])))\n             (no-connection? [[a b] [x y]]\n               (if (or (= b x) (= a x) (= b y) (= a y))\n                 false\n                 true))\n             (connect? [v]\n               (loop [e (first v) c (rest v)]\n                 (if (empty? c)\n                   true\n                   (if (no-connection? e (first c))\n                     false\n                     (recur (first c) (rest c))))))\n             (connected? [s]\n               (not (empty? (drop-while #(not (connect? %)) (permutations s)))))]\n       (connected? s)\n       )))","user":"58987ee9e4b00487982d52d2"},{"problem":91,"code":"(fn [x] (letfn [\n (sym [x]\n      (set (mapcat (fn [[a b]] [[a b] [b a]]) x))\n      )\n(trans [x]\n(letfn [(trns [s1 s2] (set (for [[x1 x2] s1 [y1 y2] s2 :when (= x2 y1) :when (and (not (contains? s1 [x1 y2])) (not (contains? s2 [x1 y2])))] [x1 y2])))]\n (loop [init x new x]\n   (if (empty? new) init\n     (recur (clojure.set/union init new) (clojure.set/union (trns init new) (trns new init))\n      )))))\n\n(grph [coll]\n(loop [init coll res {}]\n(if (empty? init) res\n(recur (rest init)\n(let [a (first init) a1 (first a) a2 (second a)]\n(if (contains? res a1) (assoc res a1 (conj (res a1) a2))\n(assoc res a1 #{a2})\n)\n)\n))))\n]\n(let [res (-> x sym trans grph) dom (set (keys res))]\n(print res dom)\n(reduce-kv (fn [a b c] (and a (= dom c) )) true res)\n  )\n))","user":"5be6d0f8e4b0f319e2d7ec51"},{"problem":91,"code":"(fn [s]\n(loop [done #{} pool s]\n(let [doing (first pool) \n      [x y] doing \n      connx (first (filter #(% x) done)) \n      conny (first (filter #(% y) done))]\n  (cond (empty? pool) (= 1(count done))\n        (and (nil? connx) (nil? conny)) (recur (conj done (set doing)) (disj pool doing))\n        (nil? conny) (recur (conj (disj done connx) (conj connx y)) (disj pool doing))\n        (nil? connx) (recur (conj (disj done conny) (conj conny x)) (disj pool doing))\n        :else (recur (conj (disj done connx conny) (clojure.set/union connx conny)) (disj pool doing))))\n)\n)","user":"5951190be4b066ee0a44aea4"},{"code":"(fn problem-91 [graph]\n  (if (<= (count graph) 1)\n    true\n    ;else\n    (letfn [(linked? [gr passed]\n              (let [e (first gr)]\n                (cond\n                 (empty? passed) (recur (rest gr) (set (first gr)))\n                 (empty? gr) true\n                 (some  #(or (= (e 0) %) (= (e 1) %)) passed) (recur (rest gr) (clojure.set/union passed (set e)))\n                 :else false)))]\n      (linked? (sort graph) #{}))))","problem":91,"user":"51fe9d7ce4b0f1313d468a70"},{"problem":91,"code":"(fn is-connected? [coll]\n  (letfn [(census [ws]\n            (let [mapped-vectors (group-by identity (flatten (vec ws)))\n                  reducer (fn [bag tuple] (assoc bag (first tuple) (count (second tuple))))]\n              (reduce reducer {} mapped-vectors)))\n          (linked? [tupleA tupleB] (if (some (set tupleA) tupleB) true false))\n          (tour-from [tuple ys]\n            (let [visitable (set ys)\n                  new-connections (filter #(linked? tuple %) visitable)\n                  not-visited (reduce disj visitable new-connections)]\n              (if\n                  (empty? new-connections)\n                #{}\n                (reduce conj new-connections (mapcat #(tour-from % not-visited) new-connections)))))\n          (connected? [zs]\n            (let [nodes (keys (census zs))\n                  visitable-nodes (keys (census (tour-from (first zs) zs)))]\n              (if (= (count visitable-nodes) (count nodes)) true false)))]\n    (connected? coll)))","user":"53bf0913e4b0c98a41f5cc99"},{"problem":91,"code":"(fn[tuples]\n        (let [vertexes\n              (into #{} (mapcat identity tuples))\n\n              neighbors\n              (fn[v]\n                (let [edges\n                      (filter #(or (= v (first %)) (= v (second %))) tuples)\n\n                      outgoing\n                      (fn[e] (if (= v (first e))\n                               e (into (empty e) (reverse e))))]\n\n                  (->> edges\n                       (map outgoing)\n                       (map second)\n                       (into #{}))))\n\n              reachable\n              (fn[v]\n                (loop [res #{v}]\n                  (let [next\n                        (into (empty res)\n                              (clojure.set/union res\n                                                 (mapcat neighbors res)))]\n                    (if (= res next)\n                      res (recur next)))))]\n\n          (every? identity (->> vertexes\n                                (map reachable)\n                                (map #(= vertexes %))))))","user":"57e6f90de4b0bfb2137f5af6"},{"problem":91,"code":"(fn solve [graph] (\n    let [vertices (set (flatten graph))\n         gne (group-by first (concat (apply list graph) (map reverse graph)))\n         ne (apply merge (for [[k v] gne] {k (disj (set (flatten v)) k)}))\n         nodes (set (keys ne))\n         dfs (fn dfs-rec\n               ([g start visited]\n                 (reduce\n                   (fn [visited to-visit]\n                         (if (contains? visited to-visit)\n                           visited\n                           (dfs-rec g to-visit visited)))\n                   (conj visited start)\n                   (g start)))\n               ([g start]\n                (dfs-rec g start #{})))\n         ]\n      (= nodes (dfs ne (first nodes)))\n    )\n  )","user":"56f258d3e4b04a395b9a04a1"},{"problem":91,"code":"(fn connectedX[nodes]\n\t(letfn [\n\t\t(connectedSimple [a b]\n\t\t\t(or \n\t\t\t\t(= (first a)(first b))\n\t\t\t\t(= (first a)(last b))\n\t\t\t\t(= (last a)(first b))\n\t\t\t\t(= (last a)(last b))\n\t\t\t)\n\t\t)\n\n\n\t\t(connectedTransitive [a b c nodes]\n\t\t\t(and\n\t\t\t\t(connected2 a c nodes)\n\t\t\t\t(connected2 b c nodes)\n\t\t\t)\n\t\t)\n\n\t\t(ors[x]\n\t\t\t(if (empty? x)\n\t\t\t\tfalse\n\t\t\t\t(reduce (fn[a b] (or a b)) x)\n\t\t\t)\n\t\t)\n\n\n\t\t(ands[x]\n\t\t\t(if (empty? x)\n\t\t\t\tfalse\n\t\t\t\t(reduce (fn[a b] (and a b)) x)\n\t\t\t)\n\t\t)\n\n\t\t(connected2 [a b nodes]\n\t\t\t(or \n\t\t\t\t(connectedSimple a b) \n\t\t\t\t(ors (map (fn[c] (connectedTransitive a b c (disj nodes c))) nodes))\n\t\t\t)\n\t\t)\n\n\t\t(connected[nodes]\n\t\t\t(ands \n\t\t\t\t(for [a nodes b nodes]\n\t\t\t\t\t(if (= a b)\n\t\t\t\t\t\ttrue\n\t\t\t\t\t\t(connected2 a b (clojure.set/difference nodes #{a b}))\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t)\n\t\t]\n\t\t(ands \n\t\t\t(for [a nodes b nodes]\n\t\t\t\t(if (= a b)\n\t\t\t\t\ttrue\n\t\t\t\t\t(connected2 a b (clojure.set/difference nodes #{a b}))\n\t\t\t\t)\n\t\t\t)\n\t\t)\n\t)\n)","user":"568820e8e4b0dcc4269f4067"},{"problem":91,"code":"(fn [graph]\n  (let [nodes (-> graph seq flatten set)\n        first-node (first (first graph))\n        one-step-away (fn [n]\n                        (clojure.set/difference\n                         (->> graph\n                              (filter #(contains? (set %) n))\n                              flatten\n                              set)\n                         #{n}))\n        expand-visited-nodes (fn [visited-nodes]\n                               (->> visited-nodes\n                                    (map one-step-away)\n                                    (apply clojure.set/union)))]\n    (loop [visited-nodes #{first-node}]\n      (if (= visited-nodes nodes) true\n        (let [new-nodes (expand-visited-nodes visited-nodes)]\n          (if (empty? (clojure.set/difference new-nodes visited-nodes)) false\n            (recur (clojure.set/union visited-nodes new-nodes))))))))","user":"529e3a4fe4b04e0c58e87b92"},{"problem":91,"code":"(fn cg[edges] (let [\n      matrix \n      (reduce #(let [f (first %2) s (second %2) cf (%1 f) cs (%1 s)] \n        (if (and (= nil cf) (= nil cs)) (assoc %1 f (list s) s (list f))\n          (if (= nil cf)\n             (assoc %1 f (list s) s (conj cs f))\n\t     (if (= nil cf)\n               (assoc %1 f (conj cf s) s (list f))\n\t       (assoc %1 f (conj cf s) s (conj cs f))\n             )\n\t  )\n        )) {} edges\n      )\n      nodes (distinct (flatten (seq edges)))\n      nodecount (count nodes)\n      reachablenodes \n        (fn reachablenodes [node result] \n          (if (result node) \n\t    result \n\t    (let [\n\t      toreach (matrix node)\n\t      result (conj result node)\n\t    ]\n\t      (loop [\n\t        neighbours toreach \n\t        alreadyreached result]\n\t        (if (empty? neighbours)\n\t\t  alreadyreached\n\t         (recur (rest neighbours) (reachablenodes (first neighbours) alreadyreached))\t        \n\t\t)\n\t      )\n            ))\n\t)\n      ]\n      (= nodecount (count (reachablenodes (first nodes) #{})))\n      )\n)","user":"56a75810e4b0542e1f8d14fc"},{"code":"#(\n(fn f [[x & s]]\n  (if (empty? s) true\n    (if (empty? (clojure.set/intersection x\n                (apply clojure.set/union s)))\n        false\n        (f (map (fn [m]\n                  (if (empty? (clojure.set/intersection m x)) m\n                      (clojure.set/union x m)))\n                s))))) (map set %))","problem":91,"user":"4fdd27f3e4b05e33b9224f78"},{"problem":91,"code":"(fn checker\n  [graph]\n  (if \n    (< (count graph) 2)\n    true\n    (let \n      [node (first graph)\n       [x y] node\n       tail (map set (remove #{node} graph))\n       ;_ (println node tail x y)\n       xcompanions (set (filter \n                     #(contains? % x)\n                     (map set tail)))\n       ycompanions (set (filter \n                     #(contains? % y)\n                     (map set tail)))]\n      (letfn \n        [(path \n          [id companions] \n          (if \n            (empty? companions)\n            false\n            (let \n              [xmates \n                (map\n                  (fn\n                    [coord]\n                    (first\n                      (filter\n                        (fn \n                          [vert] \n                          (not (= vert id)))\n                        coord)))\n                  companions)\n                xmerged (map\n                  (fn\n                    [mate]\n                    [mate y])\n                  xmates) \n                ;_ (println \"companions:\" (map #(into [] %) (remove companions tail)))\n                ngen (set (concat (map #(into [] %) (remove companions tail)) xmerged))\n                _ (println graph)\n                _ (println \"Node:\" node)\n                ;_ (println xmerged xmates)\n                ;_ (println companions )\n                _ (println ngen)\n                _ (println (count ngen) (count graph))\n                ]\n              (if \n                (< (count ngen) (count graph))\n                (checker ngen)\n                false))))]\n        (or \n\t  (path x xcompanions) \n\t  (path y ycompanions))))))","user":"586a657de4b0f14aab7c88bd"},{"code":"(fn connected? [E]\n  (let [V (set (flatten (seq E)))\n        neighbors\n          (into {}\n            (for [x V] [x (vec\n              (for [[u w] E :when (some #{x} [u w])]\n                (if (= x u) w u)))]))]\n    (= V\n     ((fn walk-path[current walked-by]\n        (if (walked-by current)\n             walked-by\n            (reduce into #{}\n              (for [nxt (neighbors current)]\n                (walk-path\n                  nxt (conj walked-by current)))))) (first V) #{}))))","problem":91,"user":"52f818a6e4b047fd55836fcc"},{"problem":91,"code":"(fn f\n    ([e]\n     (let [[[v _]] (seq e)\n           s\n           (f  v\n               (reduce\n                (fn [m [a b]]\n                  (merge-with into m {a #{b}} {b #{a}}))\n                {}\n                e)\n               #{}\n               )]\n       (= s (into #{} (flatten (seq e))))))\n    ([v adj s]\n     (if (s v)\n       s\n       (do\n         (reduce\n          into\n          s\n          (map\n           (fn [neighbor]\n             (f\n              neighbor\n              adj\n              (conj s v)))\n           (adj v)))))))","user":"505106fee4b05ab4c7e07d38"},{"problem":91,"code":"(fn one-connected [edges]\n  (loop [es edges\n         nds #{}]\n    (cond\n      (empty? es) true\n      (empty? nds) (recur (set (rest es)) (apply conj nds (first es)))\n      :else (let [e (some (fn [[a b]] (when (or (nds a) (nds b)) [a b])) es)]\n              (if e\n                (recur (set (disj es e)) (apply conj nds e))\n                false)))))","user":"5fa74b82e4b0fa27300f3dda"},{"problem":91,"code":"(fn connected?\n  [edges]\n  (letfn [(add-edge\n            [components [v1 v2]]\n            (let [comp1 (first (filter (fn [s] (s v1)) components))\n                  comp2 (first (filter (fn [s] (s v2)) components))]\n              (cond (and (= nil comp1)\n                         (= nil comp2)) (conj components #{v1 v2})\n                    (= nil comp1) (conj (disj components comp2) (conj comp2 v1))\n                    (= nil comp2) (conj (disj components comp1) (conj comp1 v2))\n                    :else (conj (disj components comp1 comp2) (into comp1 comp2)))))\n          (components\n            [edges]\n            (reduce add-edge #{(set (first edges))} (rest edges)))]\n    (= 1 (count (components edges)))))","user":"60460824e4b02d28681c77bc"},{"code":"(fn connected? [edges] ; edges is a set of pairs\r\n  (let\r\n    [nodes (into #{} (flatten (seq edges)))\r\n     num-nodes (count nodes)\r\n     _ (println \"num nodes\" num-nodes)\r\n     first-node (first nodes)\r\n     _ (println \"first node\" first-node)\r\n     reachables (fn reachables [nodes] ; is a set of nodes\r\n                  (let \r\n                    [num-nodes (count nodes)\r\n                     _ (println \"reachables num nodes\" num-nodes)\r\n                     new-nodes (set \r\n                                (flatten\r\n                                  (filter \r\n                                    (fn [[n1 n2]]\r\n                                      (or (nodes n1) (nodes n2)))\r\n                                    edges)))\r\n                     _ (println \"reachables new nodes\" new-nodes)\r\n                     next-nodes (clojure.set/union nodes new-nodes)\r\n                     _ (println \"reachables next nodes\" next-nodes)\r\n                     new-count (count next-nodes)\r\n                     _ (println \"reachables new count\" new-count)]\r\n                     (if (> new-count num-nodes)\r\n                        (reachables next-nodes)\r\n                        next-nodes)))\r\n     reachable-nodes (reachables (set [first-node]))]\r\n    (= reachable-nodes nodes)))","problem":91,"user":"4f036fb3535dcb61093f6ac8"},{"problem":91,"code":"(letfn [(add-adj [adj from to]\n          (assoc adj from (conj (get adj from #{}) to)))\n        (adjs [g]\n          (reduce (fn [acc [n1 n2]]\n                    (-> acc\n                        (add-adj n1 n2)\n                        (add-adj n2 n1))) {} g))\n        (bfs [n nbs]\n          (loop [q [n]\n                 seen #{}]\n            (if (empty? q)\n              seen\n              (let [nbs (nbs (first q))\n                    new-nbs (clojure.set/difference nbs seen)]\n                (recur (concat (rest q) new-nbs) (clojure.set/union seen nbs))))))\n\n        (connected? [g]\n          (let [nodes (set (reduce concat g))\n                component (bfs (first nodes) (adjs g))]\n            (= nodes component)))]\n  connected?)","user":"53720c5ce4b0493c815db704"},{"problem":91,"code":"#(let [graph (group-by first \n                       (mapcat (fn [e]\n                                 [e (vec (reverse e))])\n                               %))]\n   ((fn traverse [v]\n      (let [new-v (into v (map last (mapcat graph v)))]\n        (if (= new-v v)\n          (= v (set (keys graph)))\n          (traverse new-v))))\n    #{(first (keys graph))}))","user":"53acaf1fe4b047364c04445f"},{"problem":91,"code":"#(letfn [(find [[c roots :as state] p] \n           (if (contains? roots p)\n             [(roots p) state]\n             [p [(inc c) (conj roots [p p])]]))\n         (union [state [p q]] \n           (let [[i state] (find state p)\n                 [j state] (find state q)]\n             (if (= i j)\n               state\n               (loop [[k & ks :as xs] (keys (second state)), [c roots] state]\n                 (if (empty? xs)\n                   [(dec c) roots]\n                   (recur ks [c (if (= i (roots k))\n                                  (conj roots [k j])\n                                  roots)]))))))\n         (connected? [[c _]] (= c 1))]\n   (connected? (reduce union [0 {}] %)))","user":"4fad9da0e4b081705acca23c"},{"code":"(fn [e]\n  (= (set (flatten (vec e)))\n     (loop [a #{(ffirst e)} seen #{}]\n       (let [new (apply disj (set a) seen)]\n         (if (empty? new)\n           seen\n           (recur\n            (keep (fn [[x y]] (if (contains? new x) y nil)) e)\n            (into seen a)))))))","problem":91,"user":"51b9d1f0e4b0e871ca49590b"},{"code":"#(let [s (into (sorted-set) (mapcat (fn [[a b]] [[a b] [b a]]) %))\n       q (into #{} (apply concat s))]\n   (loop [t (set (first s))\n          r s]\n     (if (empty? r)\n       (= t q)\n       (let [[a b :as c] (first r)]\n       \t (if (or (t a) (t b))\n           (recur (into t [a b]) (disj r [a b]))\n           false)))))","problem":91,"user":"4e96557d535dbda64a6f6b43"},{"code":"(fn [g]\n  (letfn [(find-path [at visited all hmap]\n            (if (= visited all)\n              true\n              (when-let [new-vs (apply disj (hmap at) visited)]\n                (some (partial apply find-path)\n                      (for [new-at new-vs] [new-at (into visited new-vs) all hmap])))))]\n    (let [vs (->> g (apply concat) set)\n          hmap (reduce (fn [es [a b]] (assoc es a (conj (get es a #{}) b)\n                                             b (conj (get es b #{}) a)))\n                       {} g)]\n      (boolean (find-path (first vs) #{(first vs)} vs hmap)))))","problem":91,"user":"50645e12e4b007509339a58a"},{"code":"(fn connected? [edges]\n  (let [connected-helper?\n        (fn connected-helper? [g-pts g old-g]\n          (cond (empty? g) true\n                (= g old-g) false\n                :else (let [pts (filter identity\n                                        (doall\n                                         (for [p g] (if (or (g-pts (p 0))\n                                                            (g-pts (p 1)))\n                                                      p))))]\n                        (connected-helper? (into g-pts (flatten pts))\n                                           (apply disj g pts)\n                                           g))))]\n    (connected-helper? (set (first edges))\n        edges\n        #{})))","problem":91,"user":"4f149e0f535d64f60314643d"},{"problem":91,"code":"(fn [ll]\n (->>\n  (map set ll)\n  ((fn [[f & r :as lst]]\n     (if\n      (empty? r) lst\n      (let [rr (map #(if (nil? (some % f)) % (into % f)) r)]\n         (if (= rr r) lst (recur rr))\n   ))))\n   set\n   count\n   (= 1)\n))","user":"5281a445e4b0757a1b17143a"},{"code":"(fn [edges]\n    (let [edge-map\n          (apply\n            merge-with\n            clojure.set/union\n            (for [[a b] edges]\n              (if (= a b)\n                {a #{b}}\n                {a #{b}, b #{a}})))\n          findable (loop [queue [(first (first edge-map))]\n                          seen #{(first queue)}]\n                     (if-not (seq queue)\n                       seen\n                       (let [[top & rest-of-queue] queue\n                             unseen (clojure.set/difference (edge-map top) seen)]\n                         (recur (into rest-of-queue unseen) (into seen unseen)))))]\n      (= (count findable) (count edge-map))))","problem":91,"user":"521b9f92e4b0c4ef0be8304c"},{"code":"(fn graph-connectivity [edge-set]\n  (let [connections (group-by first edge-set)\n        nodes (set (flatten (seq edge-set))) ]\n    (loop [visited #{} queue [(ffirst connections)]]\n      (if (empty? queue)\n          (= visited nodes)\n          (let [visit (first queue)\n                new-neighbours (filter #(not (visited %)) (map second (connections visit)))]\n            (recur (conj visited visit)\n                   (concat new-neighbours (next queue))))))))","problem":91,"user":"4e356d2b535deb9a81d77f2d"},{"code":"(fn conn? [g]\n  (let [nodes (reduce (fn [ns n] (apply (partial conj ns) n)) #{} g)]\n    (loop [edges g node-groups (map (fn [x] #{x}) nodes)]\n      (if (seq edges)\n        (let [[a b] (first edges)\n              on-edge (fn [group] (or (contains? group a) (contains? group b)))\n              groups-on-edge (filter on-edge node-groups)\n              other (remove on-edge node-groups)] \n          (recur (rest edges) (conj other (apply clojure.set/union groups-on-edge))))\n        (= 1 (count node-groups))))))","problem":91,"user":"5003deb9e4b0678c553fc445"},{"code":"(fn [s]\n  (letfn\n    [\n      (closure\n        [xs]\n        (set\n          (reduce\n            (fn [rs r]\n              (concat\n                (conj rs r)\n                (map #(vector (first r) (last %)) (filter #(= (last r) (first %)) rs))\n                (map #(vector (first %) (last r)) (filter #(= (first r) (last %)) rs))\n              )\n            )\n            #{}\n            xs\n          )\n        )\n      )\n    ]\n    (let\n      [\n        c (closure (concat s (map reverse s)))\n      ]\n      (=\n        (set (map last (filter #(= (ffirst c) (first %)) c)))\n        (set (concat (map last c) (map first c)))\n      )\n    )\n  )\n)","problem":91,"user":"507eddf4e4b06ce648bcdbfa"},{"problem":91,"code":"(fn connected? [g]\n  (let [g (sort-by first (concat g (map reverse g)))]\n    (= (count (reduce (fn [seen [n m]] (if (seen n) (conj seen m) seen)) #{(ffirst g)} g))\n       (count (distinct (flatten g))))))","user":"575b3e9be4b02ea11479935b"},{"problem":91,"code":"(fn [vs]\n (let [nd\n  (set\n   (flatten\n    (seq vs)))]\n (letfn [\n  (cts [n]\n   (for\n    [edge vs\n     :let [\n      myedge (remove\n             #{n}\n             edge)]\n     :when\n      (=\n       1\n       (count myedge))]\n    (first myedge)))]\n (loop [cntd #{}\n        nts [(first nd)]\n        unctd (rest nd)]\n  (let\n   [nxt\n    (remove\n     cntd\n     (flatten\n      (map\n       cts\n       nts)))]\n   (prn cntd nts unctd nxt)\n   (cond (empty? unctd)\n          true\n         (empty? nxt)\n          false\n         :else\n          (recur\n           (into\n            cntd\n            nxt)\n           nxt\n           (remove\n            (set nxt)\n            unctd))))))\n))","user":"549a999be4b0f3d1d8e70f6f"},{"problem":91,"code":"(fn graphConn [graph]\n  (letfn [(twoCombs [coll]\n            (cond\n              (< (count coll) 2) nil\n              (= (count coll) 2) #{[(first coll) (second coll)]}\n              :else (clojure.set/union\n                     (twoCombs (rest coll))\n                     (set (map #(vec [(first coll) %]) (rest coll))))))\n          (validPair? [[[f1 f2] [s1 s2]]]\n            (or (= f2 s1) (= s2 f1)))\n          (makePairs [[[f1 f2] [s1 s2]]]\n            (cond\n              (= f2 s1) [f1 s2]\n              (= f1 s2) [s1 f2]))\n          (addReverse [graph]\n            (reduce (fn [result [l r]]\n                      (conj (conj result [l r]) [r l]))\n                    #{}\n                    graph))\n          (transitive [coll]\n            (let [tc (twoCombs coll)\n                  vps (filter validPair? tc)\n                  nps (set (map makePairs vps))]\n              (if (clojure.set/superset? coll nps)\n                coll\n                (transitive (clojure.set/union coll nps)))))]\n    (let [allNodes (set  (reduce #(into %1 %2) [] graph))\n          transitiveNodes (transitive (addReverse graph))]\n      (every? (fn [elem]\n                (every? (fn [otherElem]\n                          (if (= elem otherElem)\n                            true\n                            (or (contains? transitiveNodes [elem otherElem])\n                                  (contains? transitiveNodes [otherElem elem])))) allNodes)) allNodes))))","user":"54f64e99e4b0f2f3c5226ea4"},{"problem":91,"code":"(fn is-conn [edges]\n  (let [ all-nodes (set (flatten (seq edges)))]\n    (loop [ visited #{}\n            to-visit [(ffirst edges)] ]\n      (if (empty? to-visit)\n        (= visited all-nodes)\n        (let [ [cur & to-visit] to-visit\n               visited (conj visited cur)]\n          (recur visited\n                 (concat\n                   to-visit\n                   (distinct\n                   (filter (comp not visited)\n                           (for [[a,b] edges\n                                 :when (or (= cur a) (= cur b)) ]\n                             (if (= cur a) b a)))))))))))","user":"54b04708e4b09f271ff37d11"},{"problem":91,"code":"(fn fully-connected? [edge-set]\n  (letfn [(adjacency-map [edge-set]\n            (let [reverse-edge-set (set (mapcat (fn [[a b]] [[b a]]) edge-set))\n                  full-edge-set (into edge-set reverse-edge-set)]\n              (into {} (for [[vertex edges] (group-by first full-edge-set)]\n                         [vertex (set (map second edges))]))))\n          (traverse-graph-dfs [adjacency-map start-vertex]\n            (loop [vertices [] \n                   visited #{start-vertex} \n                   frontier [start-vertex]]\n              (if (empty? frontier)\n                vertices\n                (let [vertex (peek frontier)\n                      neighbors (adjacency-map vertex)]\n                  (recur\n                   (conj vertices vertex)\n                   (into visited neighbors)\n                   (into (pop frontier) (remove visited neighbors)))))))]\n    (let [vertices (set (apply concat edge-set))\n          adj-map (adjacency-map edge-set)]\n      (= (count vertices) (count (traverse-graph-dfs adj-map (first vertices)))))))","user":"58ed713de4b056aecfd47d84"},{"code":"(fn [graph]\n  (let [traverse (fn traverse [graph node acc]\n                   (reduce (fn [acc [a b]]\n                             (cond\n                              (and (= node a) (nil? (acc b))) (traverse graph b (conj acc b))\n                              (and (= node b) (nil? (acc a))) (traverse graph a (conj acc a))\n                              :else acc))\n                           acc graph))\n        start (first (first graph))]\n    (= (count (traverse graph start #{start}))\n       (count (set (flatten (vec graph)))))))","problem":91,"user":"507b7dbee4b09034bfeeb71e"},{"problem":91,"code":"(fn [x]\n  (let [node (set (apply concat x))\n        edges (set (concat x\n                      (map #(vec (reverse %)) x)\n                      (map (partial repeat 2) node)))\n        node-num (count node)\n        complete-num (* node-num node-num)]\n    (loop [result edges]\n      (println result)\n      (let [new (set (concat result (filter identity\n                                            (for [n1 node\n                                                  n2 node\n                                                  middle node]\n                                              (when (and (result [n1 middle])\n                                                         (result [middle n2]))\n                                                [n1 n2])))))]\n        (if (= result new)\n          (= (count new) complete-num)\n          (recur new))))))","user":"60096aabe4b074f607df667f"},{"code":"(fn cg? ([g] (cg? g (reduce (fn [s [a b]] (conj (conj s a) b)) #{} g) #{} nil))\n  ([g nl nt cl]\n   (cond\n    (not cl) (true? (some identity (map #(cg? g (disj nl %) #{%} %) nl)))\n    (empty? nl) true\n    :else\n    (let [pnl (reduce (fn [s [a b]] (cond (= a cl) (conj s b)\n                                          (= b cl) (conj s a) 1 s))\n                      #{} g)\n          nn (filter #(not (contains? nt %)) pnl)]\n      (if (empty? nn) false\n        (some identity (map #(cg? g (disj nl %) (conj nt %) %) nn)))\n      ))))","problem":91,"user":"5267d9bde4b03e8d9a4a7188"},{"problem":91,"code":"(fn graph-connectivity? [edges]\n  (let [m (zipmap (flatten (vec edges)) (repeat nil))\n        find (fn [m vertex] (if (nil? (m vertex))\n                              vertex\n                              (recur m (m vertex))))]\n    (= 1 (count\n           (filter\n             nil?\n             (vals\n               (reduce\n                 (fn [m [va vb]]\n                   (let [a (find m va)\n                         b (find m vb)]\n                     (if (not= a b) (assoc m a b) m)))\n                 m edges)))))))","user":"56ac81ace4b03c432f187347"},{"code":"(fn [x] \n   (let [h (reduce #(conj % %2 (reverse %2)) #{} x)\n         g ((fn f [s] \n              (let [r (reduce #(conj % %2) s (remove nil? (for [a s b s] (if (= (second a) (first b)) [(first a) (second b)]))))]\n                (if (= r s) r (f r)))) h)\n         n (set (map first g))\n         m (for [a n b n] [a b])] \n     (reduce #(and % (not (nil? (g %2)))) true m)))","problem":91,"user":"4eb13d60535d7eef3080733f"},{"problem":91,"code":"(fn self [g]\n    (let [all (set (flatten (seq g)))]\n      (prn \"all\" all)\n    (letfn [(dfs [s xs]\n              (mapcat\n                (fn [[k2 v2]]\n                  (prn \"s\" s \"k2\" k2 \"v2\" v2)\n                  (cond\n                    (and (= s k2) (not (contains? xs v2))) (conj (dfs v2 (conj xs v2)) v2)\n                    (and (= s v2) (not (contains? xs k2))) (conj (dfs k2 (conj xs k2)) k2)\n                    :else xs))\n                g)\n                 )]\n      (prn \"starting with\" (first g))\n      (= all (into #{}\n            (concat\n              (dfs (ffirst g) (set [(ffirst g)]))\n              (dfs (second (first g)) (set [(second (first g))]))))\n      )))\n    )","user":"52ffb7f2e4b0d8b024fd370b"},{"code":"(fn connected?\n  [connections]\n  (if (= 1 (count connections))\n    true\n    (let [taken-tuple (first connections)\n          to-reduce (next connections)\n          go-forward  (some #(or (= (first %) (first taken-tuple))\n                                 (= (second %) (first taken-tuple))) to-reduce)\n          to-collapse (if go-forward (first taken-tuple) (second taken-tuple))\n          sub         (if go-forward (second taken-tuple) (first taken-tuple))]\n      (if (not (some #(or (= (first %) to-collapse)\n                          (= (second %) to-collapse)) to-reduce))\n        false ;; we can't reduce any further so give up\n        (connected? (map (fn [[a b]]\n                           (let [a (if (= a to-collapse) sub a)\n                                 b (if (= b to-collapse) sub b)]\n                             [a b]))\n                         to-reduce))))))","problem":91,"user":"511b233ae4b07ab9ec456180"},{"code":"(fn conn [s]\n  (let\n    [m (some #(if (not= (first %) (second %)) %) s)]\n    (if m\n      (let [r (fn [v] (if (= v (first m)) (second m) v))] \n        (conn (set (map #(vector (r (first %)) (r (second %))) s))))\n      (= (count s) 1))))","problem":91,"user":"4ec07699535dfed6da9c6da2"},{"code":"(fn connected? [edges]\n  (let [transitive-closure (fn [relations]\n                             (letfn [(single-hop [element]\n                                       (map second (filter #(= (first %) element) relations)))\n                                     (multiple-hops [element]\n                                       (loop [connected (set (single-hop element))]\n                                         (let [next-connected (set (concat connected (mapcat single-hop connected)))]\n                                           (if (= next-connected connected)\n                                             next-connected\n                                             (recur next-connected)))))]\n                               (let [elements (set (apply concat relations))]\n                                 (set (mapcat (fn [element]\n                                                (map #(vector element %) (multiple-hops element))) elements)))))]\n    (let [vertices (seq (set (mapcat identity edges)))\n          vertex-pairs (for [v vertices\n                             u vertices\n                             :when (not= u v)]\n                         [u v])\n          relations (mapcat #(vector % (rseq %)) edges)\n          closure (set (transitive-closure relations))]\n      (every? #(contains? closure %) vertex-pairs))))","problem":91,"user":"5186134ce4b0da5a5be3bac7"},{"problem":91,"code":"(fn f1 [c]\n  (let [[c1 & c2] (vec c)]\n    (cond (empty? c2) true\n          (empty? c1) false\n          :else (let [tmp (group-by count\n                                    (map #(apply disj (set %) c1) c2))]\n                  (f1 (cons (reduce into #{} (tmp 1)) (tmp 2)))\n                  ))))","user":"50ae0d24e4b0a40c9cfb08ce"},{"code":"(fn [edges]\r\n  (letfn [(nodes [edges] (set (flatten (vec edges))))\r\n          (neighbours [node edges]\r\n            (set\r\n              (for [e edges :when (some #(= node %) e)]\r\n                (if (= (first e) node) (second e) (first e)))))\r\n          (component [node edges]\r\n            (loop [todo #{node}, found #{node}]\r\n              (if (empty? todo) found\r\n                (let [n      (first todo)\r\n                      neighb (remove found (neighbours n edges))]\r\n                  (recur (disj (into todo neighb) n) (conj found n)))))) \r\n\r\n          (connected? [edges]\r\n            (let [all-nodes (nodes edges)]\r\n              (= all-nodes (component (first all-nodes) edges))))]\r\n   (connected? edges)))","problem":91,"user":"4e994541535dbda64a6f6b64"},{"code":"(fn [edge-list]\n (letfn \n  [(test-intersection [a b]\n    ((complement empty?) (clojure.set/intersection a b)))\n   (merge-intersecting [coll itm]\n    (if\n     (some (partial test-intersection itm) coll)\n     (set\n      (map\n       (fn [a]\n        (if (test-intersection a itm) (clojure.set/union a itm) a))\n       coll))\n     (conj coll itm)))\n   (merge-nodes [edge-set]\n    (let\n     [merged\n      (reduce\n       (fn [acc itm] (merge-intersecting acc itm))\n       #{}\n       edge-set)]\n     (if (= merged edge-set) merged (merge-nodes merged))))]\n  (= 1 (count (merge-nodes (set (map set edge-list)))))))","problem":91,"user":"521e8227e4b0dd19981ad082"},{"code":"(letfn [(conn? [edges]\r\n               (letfn [(touches? [ [x y] [a b] ]\r\n                                 (cond\r\n                                  (= x a) true\r\n                                  (= x b) true\r\n                                  (= y a) true\r\n                                  (= y b) true\r\n                                  :else false))\r\n                       (fixed-pt [f x]\r\n                                 (let [fx (f x)]\r\n                                   (if (= fx x)\r\n                                     x\r\n                                     (recur f fx))))\r\n\r\n                       (cn [xs]\r\n                           (set (apply concat\r\n                                       (for [x xs]\r\n                                         ( filter #(touches? x %)\r\n                                                  edges)))))]\r\n                 (if (empty? edges)\r\n                   true\r\n                   (= edges\r\n                      (fixed-pt cn #{(first edges)})))))\r\n        ]\r\n  conn?)","problem":91,"user":"4dc479c0c647a3c54c2ddc73"},{"problem":91,"code":"(fn connected?\n  ([edge-set]\n    (connected?\n      #{(first (first edge-set))}\n      (count (into #{} (flatten (map identity edge-set))))\n      (into {}\n            (map\n              (fn [[k el]] (vector k (map last el)))\n              (group-by first (mapcat #(vector % (reverse %)) edge-set))))))\n  ([vd-set n vts]\n    (if (= n (count vd-set)) true\n      (let [nv (clojure.set/union vd-set (into #{} (mapcat #(get vts %) vd-set)))]\n        (if (= vd-set nv) false (connected? nv n vts))))))","user":"5796d3ebe4b039eba2ecb0ee"},{"problem":91,"code":"(fn [vg]\n    (letfn [(vec-to-map-graph [vec-graph]\n              (->> vec-graph\n                   (map #(-> {} (assoc (% 0) #{(% 1)}) (assoc (% 1) #{(% 0)})))\n                   (reduce #(merge-with clojure.set/union %1 %2))))\n\n            (make-step [g n backtrack visited-nodes unvisited-nodes]\n              (if (empty? unvisited-nodes)\n                true\n                (let [visitables (clojure.set/difference (g n) visited-nodes)]\n                  (if (empty? visitables)\n                    (if (empty? backtrack)\n                      false\n                      (recur g (first backtrack) (rest backtrack) visited-nodes unvisited-nodes))\n                    (let [nxt-node (first visitables)]\n                      (recur g \n                             nxt-node \n                             (cons n backtrack) \n                             (conj visited-nodes nxt-node) \n                             (disj unvisited-nodes nxt-node)))))))]\n            \n      (let [g (vec-to-map-graph vg)\n            node-set (set (keys g))\n            start-node (first node-set)]\n        (make-step g \n                   start-node\n                   '()\n                   #{start-node}\n                   (disj node-set start-node)))))","user":"543d89dfe4b032a45b869350"},{"problem":91,"code":"(fn [graph]\n  (letfn [(connected [node-label graph]\n           (loop [label node-label\n                  explored #{node-label}\n                  frontier []]\n             (let [neighbors (reduce (fn [v [x y]]\n                                       (condp = label\n                                         x (conj v y)\n                                         y (conj v x)\n                                         v))\n                                     []\n                                     graph)\n                   unexplored-neighbors (remove explored neighbors)\n                   [next-label & next-frontier] (concat frontier unexplored-neighbors)\n                   next-explored (conj explored label)]\n               (if next-label\n                 (recur next-label next-explored next-frontier)\n                 next-explored))))]\n    (let [nodes (set (flatten (vec graph)))]\n          (= (count (connected (ffirst graph) graph))\n             (count nodes)))))","user":"57609d91e4b08062f99a4e9b"},{"problem":91,"code":"(fn [r]\n  (let [d (fn [[a b] [x y]]\n                 (when (not= [a b] [x y])\n                   (cond\n                     (= b x) [a y]\n                     (= a y) [b x]\n                     :else nil)))\n        t (fn [r]\n            (reduce conj r (for [x r\n                                 y r\n                                 :let [e (d x y)]\n                                 :when e]\n                             e)))\n        s (fn s [r]\n        \n              (if (= r (t r))\n                r\n                (s (t r))))\n        p (s r)\n        n (into #{} (reduce concat p))\n        q (fn [a b]\n            (if (= a b)\n              1\n              (some #{[a b] [b a]} p)))]\n    (nil?\n      (some nil?\n        (for [i n j n :when (not= i j)]\n          (q i j))))))","user":"52bacfa8e4b07a9af57922d6"},{"problem":91,"code":"(fn [edges]\n  (let [edges (seq edges)\n        m (reduce (fn [m [k vs]] (merge-with concat m {k vs}))\n          {}\n          (map (fn [[a b]] [a (list b)]) (concat edges (map reverse edges))))\n        vertices (distinct (flatten edges))\n        visit-all? (fn visit-all?\n                     ([m n] (let [v (ffirst m)] (visit-all? m n #{} v)))\n                     ([m n visited v]\n                      (or (= n (count visited))\n                          (when-not (visited v)\n                            (let [visited (conj visited v)\n                                  not-visited (complement visited)\n                                  vs (filter not-visited (m v))]\n                              (some (partial visit-all? m n visited) vs))))))]\n    (boolean (visit-all? m (dec (count vertices))))))","user":"5764457ae4b0994c1922fbf3"},{"code":"(fn [m s a]\n  (let [c #(remove nil?                                                                                                                               \n                   (m (fn [[i j]] (if (= % i) j                                                                                                     \n                                  (if (= % j) i)))                                                                                              \n                      (seq %2)))                                                                                                                                 \n        n #(s (flatten (seq %)))]                                                                                                                               \n    (loop [r [(first (n a))]]                                                                                                                           \n      (if (= (n a) (s r))                                                                                        \n        true\n        (if (= (n (m #(c % a) r)) (s r))                                                                                                    \n          false               \n          (recur (into r (n (m #(c % a) r)))))))))\nmap set","problem":91,"user":"4e49badd535dc968683fc4c9"},{"problem":91,"code":"(fn [se]\n  (let [s (seq se)]\n    (loop [nodes (into #{} (first s))]\n      (let [next (into nodes (apply concat (filter (fn [[v1 v2]] (or (get nodes v1) (get nodes v2))) (rest s))))]\n        (if (= next nodes)\n          (= next (reduce (fn [s v] (into s v)) #{} s))\n          (recur next))))))","user":"56018dd4e4b04bb52996e18f"},{"code":"(fn connected?\n  [m]\n  (let [linked? (fn [s [a b]] (or (s a)\n                                  (s b)))\n        cur (set (first m))\n        m (next m)]\n    (loop [cur cur\n           m m]\n      (let [in (filter #(linked? cur %) m)\n            out (filter #(nil? (linked? cur %)) m)]\n        (if (nil? (seq out))\n          true\n          (if (nil? (seq in))\n              false\n              (recur (into cur (flatten in)) out)))))))","problem":91,"user":"4ddbdc1b535d02782fcbe9fd"},{"problem":91,"code":"(fn gc [xs]\n  (let [\n        collect-edges (fn [edges graph]\n           (reduce\n              (fn [graph [a b]]\n                (update-in (update-in graph [a] conj b) [b] conj a))\n              graph\n              edges))  \n        dfs (fn [components index graph node]\n            (let [new-components (conj components [node index])]\n              (loop [nodes (graph node) components new-components]\n                    (let [node (first nodes) nodes (disj nodes node)]\n                      (cond (nil? node) components\n                          (components node) (recur nodes components)\n                          :else (recur (clojure.set/union nodes (graph node)) (conj components [node index]))))))) \n                                  \n        nodes (into #{} (flatten (seq xs)))\n        graph (collect-edges xs (into {} (map #(vector % #{}) nodes)))]\n       ;;(println graph)\n       (->> (reduce\n            (fn [components [index node]]\n             (if (components node)\n                 components\n                 (dfs components index graph node)))\n             {}\n             (map-indexed (fn [i v] [i v]) nodes))\n             vals\n             distinct\n             count\n             (= 1))))","user":"559b55d6e4b066d22e731f54"},{"problem":91,"code":"(fn connected? [g]\n  (let [begin (-> g seq flatten first)\n        connected-iter? (fn [visited v q]\n                          (if (empty? q)\n                              (= v (-> g\n                                       seq\n                                       flatten\n                                       set))\n                            (let [n (first q)\n                                  connected-with-n (->> g\n                                                        (filter (partial some #{n}))\n                                                        flatten\n                                                        set)]\n                              (if (visited n)\n                                (recur visited \n                                       (clojure.set/union v connected-with-n) \n                                       (rest q))\n                                (recur (conj visited n) \n                                       (clojure.set/union v connected-with-n) \n                                       (clojure.set/union (rest q) connected-with-n))))))]\n    (connected-iter? #{} #{begin} #{begin})))","user":"52d00832e4b07d0d72b273b4"},{"problem":91,"code":"(fn fun [arg]\n(= 1\n   (count\n       (reduce (fn _rdcr [graphs edge] \n\t\t  (let [[n1 n2] edge\n\t\t      s-in (filter #(or (% n1) (% n2)) graphs)\n\t\t      s-out (remove #(or (% n1) (% n2)) graphs)]\n\t\t  (conj s-out \n\t\t\t(set (apply concat (conj s-in [n1 n2]))))))\n\t[]\n\targ))))","user":"4dd6d7ee535d2dad7130b5cb"},{"problem":91,"code":"(fn connected? [coll]\n   (letfn [(nodes [_coll]\n                  (distinct (flatten _coll)))\n\n           (edge? [node tuple]\n                  (contains? (set tuple) node))\n\n           (next-node [node edge]\n                      (if (apply distinct? edge)\n                        (first (disj (set edge) node))\n                        (first edge)))\n\n           (_remove [coll x]\n                    (let [n (.indexOf coll x)]\n                      (cond\n                        (= 0 n) (vec (rest coll))\n                        (= (count coll) (inc n)) (vec (butlast coll))\n                        :else (apply conj (subvec coll 0 n) (subvec coll (inc n))))))\n\n           (walk [node edges done]\n                  (if (empty? edges)\n                    (conj [] edges (distinct done))\n                    (loop [_current edges]\n                      (println \"debug!:\" node edges _current done)\n                      (if (empty? _current)\n                        ; return value of path?\n                        (conj [] edges (distinct done))\n                        (let [e (first _current)]\n                          (if (edge? node e)\n                            (walk (next-node node e) (_remove edges e) (apply conj done e))\n                            (recur (rest _current))))\n                        ))))]\n\n     (loop [start (first (nodes (vec coll)))\n            edges coll]\n       (let [ret (walk start (vec edges) [])\n             yet-edge (first ret)\n             done-node (last ret)\n             startable (clojure.set/intersection (set (nodes yet-edge)) (set done-node))]\n\n         (println yet-edge done-node startable)\n         (if (empty? yet-edge)\n           true\n           (if (empty? startable)\n             false\n             (recur (first startable) yet-edge)))\n         ))\n     ))","user":"55a372f1e4b0acc240e31537"},{"code":"(fn  [c]\n  (loop [x (seq c)]\n    (if (= (count x) 1)\n        true\n        (let [[xf & xs] x\n               cv (map #(if (not-empty (clojure.set/intersection \n                              (set %) (set xf)))\n                        (concat % xf)  \n                        %)\n                      xs)\n              ]\n          (if (= xs cv)\n             false\n             (recur cv))))))","problem":91,"user":"4e50e2a0535dc968683fc4ef"},{"problem":91,"code":"(fn [edges]\n               (letfn [(neighbors [coll]\n                         (let [forward-map (reduce (fn [n-map edge]\n                                                     (if (contains? n-map (first edge))\n                                                       (update-in n-map [(first edge)] conj (second edge))\n                                                       (conj n-map [(first edge) #{(second edge)}]))) '{} coll)]\n                           (reduce (fn [n-map edge]\n                                     (if (contains? n-map (second edge))\n                                       (update-in n-map [(second edge)] conj (first edge))\n                                       (conj n-map [(second edge) #{(first edge)}]))) forward-map coll)))]\n                 (let [n-map (neighbors edges)]\n                   (loop [remaining [(first (first n-map))] visited #{}]\n                     (if (empty? remaining)\n                       (= (count visited) (count n-map))\n                       (if (contains? visited (first remaining))\n                         (recur (rest remaining) visited)\n                         (let [neighbors (get n-map (first remaining))]\n                           (recur (reduce (fn [to-visit neighbor]\n                                            (if (contains? visited neighbor)\n                                              to-visit\n                                              (conj to-visit neighbor))) (rest remaining) neighbors) (conj visited (first remaining))))))))))","user":"5746061ae4b009280f9f2b5b"},{"problem":91,"code":"(fn connected? [graph]\n  (letfn [(vertices [graph]\n            (set (flatten (vec graph))))\n\n          (adjacent [graph v]\n            (set (for [[v1 v2] graph :when (or (= v1 v) (= v2 v))]\n               (if (= v1 v) v2 v1))))\n\n          (dfs [graph source discovered]\n            (reduce\n             (fn [discovered v]\n               (if (not (discovered v))\n                 (dfs graph v discovered)\n                 discovered))\n             (conj discovered source)\n             (adjacent graph source)))]\n\n    (let [source (ffirst graph)\n          reachable (dfs graph source #{})]\n      (= reachable (vertices graph)))))","user":"5b51b9f8e4b02d533a91bcfe"},{"problem":91,"code":"(fn connected? [e] (let [find (fn [union k] (or (some #(if (contains? % k) %) union) #{k}))] (= 1(count (reduce (fn [r [a b]] (let [ua (find r a) ub (find r b)] (-> r (disj ua ub) (conj (clojure.set/union ua ub))))) #{} e)))))","user":"5addadfce4b0837691e92c13"},{"code":"(fn [g]\n  (let [vertices (reduce into #{} g)\n        bfs (fn [g v]\n              (loop [q (conj clojure.lang.PersistentQueue/EMPTY v) seen #{v}]\n                (let [current (peek q)\n                      vs (reduce into #{} (for [[a b] g :when (or (= a current) (= b current))] [a b]))]\n                  (if (empty? q)\n                    seen\n                    (recur (into (pop q) (apply disj vs seen)) (into seen vs))))))]\n    (= vertices (bfs g (ffirst g)))))","problem":91,"user":"4f7431d2e4b044e54cd9a8f7"},{"code":"(fn [relations]\n    (let [transitive-closure (loop [prev-relations relations]\n                               (let [result (into\n                                              prev-relations\n                                              (apply\n                                                concat\n                                                (for [[a1 b1 :as r1] prev-relations]\n                                                  (apply\n                                                    concat\n                                                    (for [[a2 b2 :as r2] prev-relations\n                                                          :when (and (not= r1 r2)\n                                                                     (or (= b1 a2)\n                                                                         (= b1 b2)\n                                                                         (= a1 a2)\n                                                                         (= a1 b2)))]\n                                                      [[a1 b2] [b1 a2] [a1 a2] [b1 b2]])))))]\n                                 (if (= result prev-relations)\n                                   result\n                                   (recur result))))\n          connections (reduce\n                        (fn [acc [a b]]\n                          (let [conn-a (get acc a)\n                                conn-b (get acc b)]\n                            (merge-with clojure.set/union\n                                        acc\n                                        {a #{b}}\n                                        {b #{a}})))\n                        {}\n                        transitive-closure)]\n      (every? (fn [k]\n                (= (set (keys connections)) (set (conj (get connections k) k))))\n              (keys connections))))","problem":91,"user":"4db1b3951254ad5b4805fa6f"},{"code":"(fn [g]\n  (let [vertices (-> g seq flatten set)\n        root (first vertices)\n        adjacent (fn [v] (concat (for [[x y] g :when (= x v)] y) (for [[x y] g :when (= y v)] x)))\n        add-to-comp (fn add [comp v] (if (some #{v} comp) comp (reduce add (conj comp v) (adjacent v))))\n        connected-component (reduce add-to-comp [root] (adjacent root))]\n    (= (count connected-component) (count vertices))))","problem":91,"user":"4e9519b4535dbda64a6f6b2d"},{"problem":91,"code":"(fn [g]\n    (= 1\n       (count\n        (reduce\n         (fn [ss v]\n           (let [ns (->> g (filter #(some #{v} %)) flatten set)\n                 ff (first (filter #(seq (clojure.set/intersection ns %)) ss))]\n             (if ff (assoc-in ss [(.indexOf ss ff)] (clojure.set/union ns ff))\n                 (conj ss ns))))\n         [] (-> g vec flatten set)))))","user":"4f57c913e4b0a7574ea7183f"},{"code":"(fn [g]\n  (let [nodes (distinct (flatten (for [[a b] g] [a b])))\n        connected-comp (fn find-cc [c cc]\n                         (let [nexts (for [[x y] g :when (= x c) :when (not (contains? cc y))] y)\n                               ncc (into cc nexts)]\n                           (reduce into ncc (map #(find-cc % ncc) nexts))))]\n    (= (count (connected-comp (first nodes) #{(first nodes)})) (count nodes))))","problem":91,"user":"527cd633e4b0757a1b17136f"},{"code":"(fn conn? [g]\n  (let [cs   (into #{} (map (partial into #{}) g))\n        ecls (loop [s   (first cs)\n                    out #{}\n                    in  (rest cs)]\n               (if (empty? in)\n                 s\n                 (if (empty? (clojure.set/intersection s (first in)))\n                   (recur s (conj out (first in)) (rest in))\n                   (recur (clojure.set/union s (first in)) out (rest in)))))]\n        (= ecls\n           (into #{} (flatten (into '() g))))))","problem":91,"user":"51365524e4b04ac1f358dd52"},{"code":"(fn [xs]\n  (letfn [(all-paths [xs]\n            (let [x2 (into xs (for [[a b] xs [c d] (disj xs [a b]) :when (= b c)] [a d]))\n                  x3 (into x2 (for [[a b] xs [c d] (disj xs [a b]) :when (= a d)] [b c]))]\n              (if (= xs x3)\n                (filter #(not= (first %) (second %)) xs)\n                (recur x3))))]\n    (let [paths (into #{} (map #(vec (sort %)) (all-paths xs)))\n          nodes (into (into #{} (map first xs)) (map second xs))]\n      (or (< (count nodes) 3)\n          (= (* (count nodes) (dec (count nodes)) 1/2) (count paths))))))","problem":91,"user":"4ea365e2535d7eef308072c5"},{"problem":91,"code":"(fn [g]\n  (loop [vs #{(ffirst g)} es g a #{}]\n    (if-let [v (first vs)]\n      (let [{i v o nil} (group-by #(some #{v} %) es)\n            nvs (mapcat #(remove #{v} %) i)]\n        (recur (into (disj vs v) nvs) o (into a i)))\n    (= a g))))","user":"514d8084e4b019235f6c0588"},{"problem":91,"code":"(fn [s]\n (apply = (vals (reduce (fn [g [a b]] (let [r (apply conj (g a #{a}) (g b #{b}))] (reduce #(assoc % %2 r) g r))) {} s))))","user":"5b61aa6ae4b0c6492753e712"},{"problem":91,"code":"(fn gracon [graph]\n  (loop [\n    nodes (-> graph vec flatten set)\n    visited-nodes (first graph)\n    previous-vn '[]]\n    (if (= (set visited-nodes) (set previous-vn))\n      (= (set visited-nodes) (set nodes))\n      (recur\n        nodes\n        (reduce\n          (fn [vns nns]\n            (if\n              (reduce\n                #(or %1 (contains? (set visited-nodes) %2))\n                nil\n                nns)\n              (clojure.set/union vns (set nns))\n              vns))\n          visited-nodes\n          graph)\n        visited-nodes))))","user":"5f548678e4b0a0bc16850a7e"},{"problem":91,"code":"(fn [s]\n   (letfn [(onconnect [a b] (< 1 (apply max (vals (frequencies (concat a b))))))\n           (add_connect [s re]\n             (reduce (fn [acc item]\n                            (loop [c acc]\n                               (cond\n                                  (empty? c) acc\n                                  (onconnect (first c) item) (conj acc item)\n                                  :else (recur (rest c))))) re s))]\n         (loop [re #{(first s)}]\n             (let [re2 (add_connect s re)]\n                (cond\n                      (= (count s) (count re2)) true\n                      (= re re2) false\n                      :else (recur re2))))))","user":"5dc12b0ae4b0e59a23173d84"},{"problem":91,"code":"(fn solve [xs]\n  (letfn [(to-graph [xs]\n            (let [all-edges (mapcat (fn [[x y]] [[x y] [y x]]) xs)]\n              (reduce (fn [acc [v es]]\n                        (assoc acc v (map second es)))\n                      {}\n                      (group-by first all-edges))))\n          (dfs [graph v [visited edges-to :as state]]\n            (if (visited v)\n              state\n              (let [newvisited (conj visited v)]\n                (reduce (fn [[acc-visited acc-edges-to :as acc-state] w]\n                          (if (acc-visited w)\n                            acc-state\n                            (dfs graph w [acc-visited (assoc acc-edges-to w v)])))\n                        [newvisited edges-to]\n                        (graph v)))))]\n    (let [graph (to-graph xs)\n          vertices (into #{} (flatten (into [] xs)))\n          state-after-dfs (dfs graph (first (keys graph)) [#{} {}])\n          visited (first state-after-dfs)]\n      (= vertices visited))))","user":"54b13a40e4b09f271ff37d1b"},{"code":"(fn [arcs]\r\n  (let [closed-graphs (loop [rest-arcs arcs\r\n                             graphs #{}]\r\n                        (if (empty? rest-arcs)\r\n                            graphs\r\n                           (let [[left-node right-node] (first rest-arcs)\r\n                                 left-graph (first (filter #(% left-node) graphs))\r\n                                 right-graph (first (filter #(% right-node) graphs))]\r\n                             (recur (rest rest-arcs)\r\n                                    (cond (and (not left-graph) (not right-graph)) (conj graphs (into #{left-node} #{right-node}))\r\n                                          (not right-graph) (conj (disj graphs left-graph)\r\n                                                                  (conj left-graph right-node))\r\n                                          (not left-graph) (conj (disj graphs right-graph)\r\n                                                                 (conj right-graph left-node))\r\n                                          (not (= left-graph right-graph)) (conj (disj graphs left-graph right-graph)\r\n                                                                                 (into left-graph right-graph))\r\n                                          :else graphs)))))]\r\n    (= 1 (count closed-graphs))))","problem":91,"user":"4e7c8fd1535db169f9c796be"},{"problem":91,"code":"(fn connected?\n  [coll]\n  (letfn [(helper [acc coll]\n            (if (seq coll)\n              (let [a (first coll)]\n                (if (some (fn [set1] (some set1 a)) acc)\n                  (let [r (map (fn [aset] (if (some aset a) (set (concat aset a)) aset)) acc)]\n                    (helper [(first r)] (concat (rest r) (rest coll))))\n                  (recur (conj acc (set a)) (rest coll))))\n              acc))]\n    (= 1\n       (count (helper [(set (first coll))] (rest coll))))))","user":"4e521cef535d302ef430da6d"},{"code":"(fn [edges]\n  (letfn [\n      (nodes [edges] (into #{} (mapcat identity edges)))\n      (add-neighbor [nbrs [u v]] (assoc nbrs u (conj (get nbrs u) v)))\n      (graph [edges]\n        (let [nn (nodes edges)\n              nbrs (reduce add-neighbor (zipmap nn (repeat #{})) edges)\n              nbrs (reduce add-neighbor nbrs (for [[u v] edges] [v u]))]\n          {:nodes nn :neighbors nbrs}))\n      (next-nodes [g n] ((:neighbors g) n))\n      (depth-first\n        [graph start]\n        (let [walk \n              (fn walk [seen trans]\n                (let [frontier (drop-while seen trans)]\n                  (when-let [next-node (first frontier)]\n                    (lazy-seq\n                     (cons next-node\n                           (walk (conj seen next-node)\n                                 (concat (next-nodes graph next-node) frontier)))))))]\n          (walk #{start} (next-nodes graph start))))]\n    (let [g (graph edges) nn (:nodes g) start (first nn)]\n      (= nn (set (cons start (depth-first g start)))))))","problem":91,"user":"4ed188c8535d44c135fd68cf"},{"problem":91,"code":"(fn connected? [edges]\n  (letfn [(make-graph [graph [v1 v2]]\n            (if (get graph v1)\n              (update-in graph [v1 :edges] #(conj % v2))\n              (assoc graph v1 {:was false :edges [v2]})))\n          (dfs [graph v]\n            (if-not (get-in graph [v :was])\n              (let [tree (update-in graph [v :was] (constantly true))]\n                (reduce #(dfs %1 %2) tree (get-in tree [v :edges])))\n              graph))]\n    (->> (first (first edges))\n         (dfs (reduce make-graph {} edges))\n         (every? #(:was (% 1))))))","user":"5ba15075e4b0a20761a2339e"},{"code":"(fn connected?\n  [edges]\n  (letfn [(nodes\n            [edges]\n            (set (apply concat edges)))\n\n          (neighbours\n            [node edges]\n            (loop [edges (seq edges) neighbours []]\n              (if edges\n                (let [[x y] (first edges)]\n                  (cond\n                   (= x node) (recur (next edges) (conj neighbours y))\n                   (= y node) (recur (next edges) (conj neighbours x))\n                   :else      (recur (next edges) neighbours)))\n                neighbours)))\n\n          (walk\n            ([start edges]\n               (walk start edges #{}))\n            ([start edges seen]\n               (if (empty? edges)\n                 (conj seen start)\n                 (let [ns (neighbours start edges)\n                       new-edges (remove (fn [[a b]] (or (= start a) (= start b))) edges)\n                       new-seen (conj seen start)]0\n                       (reduce into new-seen (map #(walk % new-edges new-seen) ns))))))]\n    (let [ns (nodes edges)]\n      (= ns (walk (first ns) edges)))))","problem":91,"user":"4e50b67b535dc968683fc4ed"},{"problem":91,"code":"(fn [s]\n  (let [h (first s)]\n    (loop [x (disj s h), i (into #{} h)]\n      (or (empty? x)\n          (let [e (some #(when (some i %) %) x)]\n            (if e\n                (recur (disj x e) (into i e))\n                false))))))","user":"548b7db8e4b0e286459a11fd"},{"code":"#(loop [s (set (first %))] \n    (let [f flatten\n          t (into s (f (for [i % :when (some s i)] i)))]\n      (if (= t s) \n          (= t (set (f (vec %)))) \n          (recur t))))","problem":91,"user":"4dae916eedd6309eace4d155"},{"problem":91,"code":"(fn connected? [g]\n  (letfn [(dfs [cur-v cur-g]\n            (cons cur-v\n                  (flatten\n                    (for [e cur-g :when (= (first e) cur-v)]\n                      (dfs (second e) (disj cur-g e))))))]\n    (let [full-g (into g (map (fn [[a b]] [b a]) g))\n          all-vs (reduce #(into %1 %2) #{} full-g)\n          dfs-vs (set (dfs (ffirst full-g) full-g))]\n      (= all-vs dfs-vs))))","user":"5b13ba71e4b0cc2b61a3be53"},{"problem":91,"code":"(fn [e]\n  (let [n (set (flatten (seq e)))\n        f (memoize (fn [a]\n                     (set (for [[x y] e]\n                            (cond\n                             (= a x) y\n                             (= a y) x\n                             :else a)))))\n        g (fn [v]\n            (let [c (count v)\n                  u (reduce into v (map f v))\n                  k (count u)]\n              (if (> k c)\n                (recur u)\n                u)))]\n    \n    (every? true?\n            (for [a n\n                  :let [v (g #{a})]\n                  b n]\n              (contains? v b)))))","user":"54dd76c8e4b024c67c0cf794"},{"code":"(fn bfs [col]                         \n  (letfn [(nbmap [col]                  \n            (let [edges (concat col (map (fn [e] [(last e) (first e)]) col))]\n                (reduce (fn [ret e] (update-in ret [(first e)] (fnil conj #{}) (last e))) {} edges)))\n                                        \n            (stepHd [graph q color]       ;; deq Q head and process each node\n               (when-let [hd (peek q)]  ;; while q is not empty\n                 ;; process node early, process each edge, then process node late.\n                 (cons hd           ;; bfs, all nodes in Q are reachable, add this round reachable to partial result\n                   (lazy-seq        ;; stepHd fn rets a lazy seq of all reachable nodes\n                     (let [hdnb (remove (fn [e] (contains? color e)) (graph hd))]  ;; at leaf level, an empty lazy-seq\n                       ;;(prn \"hd \" hd \" hdnb \" hdnb \" color \" color q)\n                       (stepHd graph (into (pop q) hdnb) (reduce #(conj %1 %2) color hdnb)))))))]\n    (let [graph (nbmap col)             ;; transform edge list into neighbor map \n          root (first (keys graph))]                                                                                                                                            \n      (= (count graph) (count (stepHd graph (conj clojure.lang.PersistentQueue/EMPTY root) (conj #{} root)))))))","problem":91,"user":"513cb853e4b0b86ece9f322b"},{"code":"(fn [x] \n  (= 1 (count \n        (reduce \n         (fn [acc [t f]]\n           (let [ts (or (first (filter #(some #{t} %) acc)) #{t}) \n         \t\t fs (or (first (filter #(some #{f} %) acc)) #{f})]\n             (if (= fs ts)\n               (if (some fs acc) acc (set (conj acc fs)))\n               (set (remove #(or (= % fs) (= % ts)) (conj acc (into fs ts)))))))\n         #{} x))))","problem":91,"user":"5194cd85e4b05be8c43d2381"},{"code":"(fn [g]\n  (loop [c (first g)\n         t (next g)]\n    (if (empty? c)\n      (empty? t)\n      (let [x (group-by #(nil? ((set %) (first c))) t)]\n        (recur (concat (next c) (flatten (x false)))\n               (x true))))))","problem":91,"user":"4ebaf790535dfed6da9c6d6e"},{"problem":91,"code":"(fn connected? [graph]\n  (let [nodes (set (apply concat graph))\n        full-graph (set (mapcat (fn [[a b :as n]] [n [b a]]) graph))\n        children (into {} (for [[k v] (group-by first full-graph)] [k (set (map second v))]))\n        connections (fn [node]\n                      (->> (iterate #(into % (mapcat children %)) #{node})\n                           (partition 2 1)\n                           (drop-while #(apply not= %))\n                           first first))]\n    (= nodes (connections (first nodes)))))","user":"5c2649c8e4b07e362c2305bf"},{"problem":91,"code":"(fn [edges]\n  (let [graph (group-by first (mapcat (fn [e] [e (vec (reverse e))])\n                                      edges))]\n    (loop [v #{(first (keys graph))}]\n       (let [new-v (into v (map last (mapcat graph v)))]\n         (if (= new-v v)\n           (= v (set (keys graph)))\n           (recur new-v))))))","user":"552a793ee4b0ffed3738f955"},{"problem":91,"code":"(fn [graph]\n    (let [index-fn (fn\n                    [graph]\n                    (reduce (fn [accum item] (let [node1 (first item)\n                                                   entry1 (get accum node1 [])\n                                                   node2 (second item)\n                                                   entry2 (get accum node2 [])]\n                                               (assoc accum node1 (conj entry1 node2) node2 (conj entry2 node1)))) {} graph))\n          paths-fn (fn\n                  [node indexed num-nodes]\n                  (let [seen (atom #{})]\n                    (take-while #(< (count (conj @seen %)) (inc num-nodes))\n                                (tree-seq #(when-not (@seen %) (swap! seen conj %))\n                                          #(get indexed %)\n                                          node))))\n          connected? (fn\n                       [graph]\n                       (let [tree-info (index-fn graph)\n                             nodes (set (flatten (vec tree-info)))\n                             node-paths (map #(set (paths-fn % tree-info (count nodes))) nodes)]\n                         (empty? (filter #(not= nodes (set %)) node-paths))))]\n      (connected? graph)))","user":"594266cfe4b060784b3b790b"},{"code":"(fn graph-conn [edges]\r\n  (let [nodes (reduce (fn [acc [n1 n2]] (conj acc n1 n2)) #{} edges)\r\n        conn (fn [n1 n2] (or (edges [n1 n2]) (edges [n2 n1])))]\r\n    (loop [queue [(first nodes)] visited #{}]\r\n      (if (empty? queue) (= visited nodes)\r\n          (let [curr (first queue) \r\n                to-add (filter #(and (not (visited %)) (conn curr %)) nodes)\r\n                newq (reduce conj (rest queue) to-add)\r\n                newvisit (conj visited curr)] (recur newq newvisit))))))","problem":91,"user":"4f13047d535d64f60314642c"},{"code":"(fn [vs]\n  (let [mk-g (fn [vs g]\n                (if vs\n                  (let [x (first (first vs))\n                        y (second (first vs))\n                        f #(update-in %1 [%2] (partial cons %3) )]\n                    (recur (next vs) (f (f g x y) y x) ))\n                  g))\n        g (mk-g vs '{})\n        is-con (fn [s]\n                 (let [s1 (set(flatten (map (partial get g) s)))]\n                   (if (= (count s) (count s1))\n                     (= (count s) (count g))\n                     (recur s1)\n                     )))       ]\n    (is-con (set (apply cons(first g)))  )))","problem":91,"user":"5349ac2be4b084c2834f4a67"},{"problem":91,"code":"#(let [f (fn f [g [[a b] & c]] \n            (or (nil? a) (and (contains? g a) (f (conj g b) c))))\n        [a & b] (->> % (vec) (map sort) (map vec) (sort))]\n      (f (set a) b))","user":"53500869e4b084c2834f4ad3"},{"code":"(letfn [(exists-path\n           [g start end]\n           (if (= start end)\n             true\n             (let [vs (->> g\n                           (filter #(contains? (set %) start))\n                           (apply concat)\n                           (into #{})\n                           (remove #{start}))]\n               (some #(exists-path (remove #{[start %] [% start]} g) % end) vs))))]\n   (fn [g]\n     (let [vs (distinct (apply concat g))]\n       (every? identity (for [s vs\n                              e vs]\n                          (exists-path g s e))))))","problem":91,"user":"53224d45e4b09d4e7a9b54c0"},{"problem":91,"code":"(let [neighbors (fn [edge-list] (loop [remaining-edges edge-list current-neighbors {}] (if (empty? remaining-edges) current-neighbors (let [[source destination] (first remaining-edges)] (recur (rest remaining-edges) (merge-with into current-neighbors (if (= source destination) {source [destination]} {source [destination] destination [source]})))))))\n      component-set (fn [vertex neighbor-list] (loop [dfs-stack (list vertex) visited #{}] (if (empty? dfs-stack) visited (if (contains? visited (peek dfs-stack)) (recur (pop dfs-stack) visited) (recur (into (pop dfs-stack) (get neighbor-list (peek dfs-stack) [])) (conj visited (peek dfs-stack)))))))\n      connected? (fn [edge-list] (let [neighbor-list (neighbors edge-list)] (->> neighbor-list (component-set (ffirst edge-list)) (count) (= (count neighbor-list)))))\n      ] connected?)","user":"5e1cc888e4b0dc959400853d"},{"code":"#(let [massoc\n          (fn [m [k v]] (assoc m k (into (m k) [v])))\n       edges \n          (fn [es] (into es (map reverse es)))\n        graph\n          (fn [es] (reduce massoc {} es))\n        walk\n           (fn [g q visited]\n              (if (seq q)\n                (let [adj (g (peek q))\n                      newq (if (visited (peek q)) (pop q) (into (pop q) adj))]\n                  (recur g newq (conj visited (peek q))))\n                visited))\n        emptyq (clojure.lang.PersistentQueue/EMPTY)\n        all-nodes\n            (fn [es]\n              (into #{} (mapcat identity es)))\n       ]\n       (=\n          (walk (graph (edges %)) (conj emptyq (ffirst %)) #{})\n          (all-nodes %))\n  )","problem":91,"user":"4ff3df0fe4b0678c553fc355"},{"code":"(fn is-connected? [colls]\n  (let [create-trans (fn create-trans [colls]\n                       (let [trans (reduce (fn [x [a b]] \n                        (set (concat x (set (map #(vector a (second %)) (filter #(= b (first %))  colls)))))) \n                                           colls colls)]\n                         (if (= colls trans)  trans (create-trans trans))))                          \n        collapse (fn [s] (reduce (fn [x [a b]] (if (or (contains? x [b a]) (= a b)) x (conj x [a b]) )) #{} s))\n        riemann (fn [n] (apply + (range 1 n)))\n        nodes (set (flatten (list* colls)))]\n        (= (riemann (count nodes)) (count (collapse (create-trans (set (concat colls (map (fn [[k l]] [l k]) colls)))))))))","problem":91,"user":"50c8697ce4b00bb60fe0c53f"},{"code":"(fn connected? [g]\n  (letfn [(bfs-step [g nodes]\n            ; expand a set of nodes by adding ones reachable in one step                                                                                               \n            (->> g (filter (fn [e] (some #(contains? nodes %) e))) flatten set))\n          (fixed-point [f a]\n            ; return the fixed point that (f a) converges to                                                                                                           \n            (let [fa (f a)] (if (= a fa) a (fixed-point f fa))))\n          (component [g n]\n            ; return the set of nodes in g reachable from node n                                                                                                       \n            (fixed-point (partial bfs-step g) #{n}))]\n    ;(component g (ffirst g))                                                                                                                                          \n    (= (set (mapcat set\tg))   \t      ; all nodes in g                                                                                                                 \n       (component g (ffirst g)))))    ; nodes in first component of g","problem":91,"user":"530bf87ee4b02e82168697d5"},{"problem":91,"code":"(fn [graph]\n  (letfn [(matches [conns edges]\n                   (group-by #(boolean (some % edges)) conns))\n          (connected? [conns edges]\n                      (let [{good true bad false} (matches conns edges)]\n                        (conj bad (apply clojure.set/union (set edges) good))))]\n    (= 1 (count (reduce connected? [] graph)))))","user":"58923efce4b00487982d521c"},{"problem":91,"code":"(fn [x]\n  (let [f (fn [g [a b]] (->> (into (g a #{a}) (g b #{b}))\n                             (#(reduce (fn [ak n] (assoc ak n %)) g %)) ))] \n    (apply = (vals (reduce f {} x)))))","user":"6011b89ee4b074f607df66bc"},{"problem":91,"code":"(fn [graph]\n  (letfn\n   [(destinations [graph x]\n      (for [[a b] graph\n            :when (or (= x b) (= x a))]\n        (if (= x b) a b)))\n\n    (recur-destinations [graph x]\n                        (let [x2 (set (into x (mapcat #(destinations graph %) x)))]\n                          (if (= x x2) x (recur graph x2))))]\n\n    (= (recur-destinations graph (first graph)) (set (mapcat identity graph))) ))","user":"5c683fb5e4b0fca0c16226d5"},{"problem":91,"code":"(fn [e]\n  (letfn [(upd [c e] (if (empty? c) #{e} (conj c e)))\n          (upd-in [e1 e2 g] (update-in g [e1] upd e2))\n          (gr [g [e1 e2]] (upd-in e2 e1 (upd-in e1 e2 g)))\n          (mkgraph [es] (reduce gr {} es))\n          (conn? [g]\n            (let [gc (count (keys g))\n                  dfs (fn [[v & r :as s1] m]\n                        (cond (= gc (count m)) true\n                              (empty? s1) false\n                              :else (if-let [s2 (filter #(not (some #{%} m)) (g v))]\n                                      (recur (concat s2 r) (conj m v))\n                                      (recur r (conj m v)))))\n                  s (ffirst g)\n                  ]\n              (dfs (list s) (hash-set s))\n              )\n            )\n          ]\n    (-> e\n        (mkgraph)\n        (conn?)\n        (boolean)\n        )\n    ))","user":"4f5cc3b8e4b0030a34fb2b2b"},{"code":"(fn [g]\n  (let [vs (set (mapcat identity g))\n    es (set (mapcat (juxt identity reverse) g))\n    newvs (fn [v] (map second (filter #(= v (first %)) es)))\n    subset? (fn [s1 s2] (every? s1 s2))]\n    (loop [curr #{(first vs)}\n      news (mapcat newvs curr)]\n      (if (subset? curr news) (= curr vs)\n        (recur (reduce conj curr news) (mapcat newvs news))))))","problem":91,"user":"504e14c2e4b078edc5f593bf"},{"code":"(fn [g]\n  (letfn [\n    (paths [[prev :as path] rests]\n            (if (empty? rests)\n                [path]\n                (#(if (empty? %) [path] %)\n                  (apply concat\n                    (keep\n                      #(if (or (nil? prev)\n                               (> 4 (count (into #{} (concat prev %)))))\n                           (paths (cons % path) (disj rests %)))\n                      rests)))))]\n    (let [ps (paths () g)]\n      (every?\n        (fn [[src dst]]\n          (some\n            (fn [p]\n              (and (= src (last p))\n                   (some #(= dst %) p)))\n            ps))\n        (for [src g dst (disj g src)] [src dst])))))","problem":91,"user":"4fd96694e4b05e33b9224f37"},{"code":"(fn [s]\n  (let [g (fn [s]\n            (reduce (fn [m [f s]]\n                      (assoc m\n                        f (conj (m f []) s)\n                        s (conj (m s []) f))) {} s))\n        f (fn [s m]\n            (set\n             (filter\n              (comp not nil?) \n              (flatten\n               (take (+ 1 (count m))\n                     (iterate #(flatten (map m %)) s))))))]\n    (let [m (g s)]\n      (= (count (f [(nth (keys m) 0)] m)) (count (set (flatten (vals m))))))))","problem":91,"user":"4ee9ddb8535d93acb0a66896"},{"problem":91,"code":"(fn [edges]\n   (let [a (group-by first edges)\n         b (group-by second edges)\n         l (merge-with concat a b)\n         l (into {} (map (fn [[k v]] [k (set (flatten v))]) l))\n         [_ v] (first l)]\n     (loop [ov v]\n       (let [nv (reduce clojure.set/union (map l ov))]\n         (if (= ov nv)\n           (= (count nv) (count l))\n           (recur nv))))))","user":"55c652dde4b0e31453f649bd"},{"problem":91,"code":"(fn [xs]\n  (let [node-info (reduce\n                   (fn [m [x y]]\n                     (-> m\n                         (update-in [x] (fnil (partial cons y) '()))\n                         (update-in [y] (fnil (partial cons x) '()))))\n                   {} xs)]\n    (= (->> node-info keys (into #{}))\n            ((fn [s]\n               (if (empty? s)\n                 (recur #{(-> node-info keys first)})\n                 (let [res (reduce\n                            (fn [m a]\n                              (->> a\n                                   (get node-info)\n                                   (concat m)\n                                   (into #{}))) s s)]\n                   (if (= (count s) (count res))\n                     res\n                     (recur res))))) #{}))))","user":"54c5cc17e4b045293a27f624"},{"code":"(fn [edges]\n  (letfn [(connected? [s e] (boolean (some #(some (into #{} e) %) s)))]\n    (loop [s #{(first edges)} es (rest edges)]\n      (let [c (group-by #(connected? s %) es)]\n        (cond (empty? (c false)) true\n              (empty? (c true)) false\n              :else (recur (set (c true)) (c false)))))))","problem":91,"user":"51e00020e4b01188f0627534"},{"code":"(fn connected? [nodes]\n  (let \n    [links (reduce (fn [coll [x y]]\n                     (-> coll\n                         (assoc x (conj (get coll x []) y))\n                         (assoc y (conj (get coll y []) x))))\n                   {}\n                   nodes)\n     gen-next (fn [curr]\n            (set (mapcat links curr)))\n     results (loop [curr [(ffirst nodes)] seen #{(ffirst nodes)}]\n               (let [next-unseen (remove seen (gen-next curr))]\n                 (if (empty? next-unseen)\n                   seen\n                   (recur next-unseen (into seen next-unseen)))))]\n    (= results (set (keys links)))))","problem":91,"user":"50217818e4b00bba4502f7a7"},{"problem":91,"code":"(fn sol [xset]\n  \n  (letfn[\n         \n         (initset [res edges]\n  (if (empty? edges)\n      res\n      (let [n1 (first (first edges) ) n2 (second (first edges) )]\n        (if (not (= n1 n2 ))\n        (recur (assoc  (assoc res n1 (conj (res n1) n2 ))\n                        n2 (conj (res n2 ) n1 ))\n               (rest edges)\n               )\n        )\n     )\n    )\n  )\n\n(cfunc [cset tset [a seta]]\n  (let [nset (clojure.set/union seta (tset a))]\n    [a nset]\n    )\n  )\n\n(tfunc [cset tset [a seta]]\n  (let [nset (clojure.set/difference \n               (reduce clojure.set/union \n                    (for [x seta]  (cset x))\n               )\n               (cset a)\n             )\n        ]     \n      [a nset]\n    )\n\n  )\n\n         (propset [mset]\n  (loop [\n         cset (into {} (for [x mset]\n                  [(first x) (set (second x))])\n              )\n         tset cset\n         ]\n     (if  (every? true? (map #(empty? (second %)) tset) )\n          cset\n          (recur (into {} (map #(cfunc cset tset %) cset))\n                 (into {} (map #(tfunc cset tset %) tset))\n          )\n     )\n\n    )\n\n  )\n\n         \n         ]\n  \n  (let [len (count xset)]\n     (every? true? (map #(>= (count (second %)) (dec len)) (propset (initset {} xset))) ) \n    )\n   )\n  )","user":"59ff9424e4b01bb0ae8afd24"},{"code":"(fn [s]\n  ((fn [s v]\n     (let [ss (group-by #(boolean (some v %)) s)\n           vp (reduce into v (ss true))]\n       (or (nil? (ss false))\n           (and (> (count vp) (count v)) (recur (ss false) vp)))))\n   (map set s) #{(ffirst s)}))","problem":91,"user":"504e04a4e4b078edc5f59397"},{"problem":91,"code":"(fn connected? [edges] \n  (let [vertices (set (apply concat edges))\n        connected (loop [queue [(first vertices)]\n                         seen #{(first vertices)}]\n                    (let [node (peek queue)\n                          neighbours (apply disj (set (apply concat (filter #(some #{node} %) edges))) seen)\n                          new-queue (if (empty? neighbours) (pop queue) (apply conj (pop queue) neighbours))\n                          new-seen (if (empty? neighbours) seen (apply conj seen neighbours))]\n                      (if (and (empty? new-queue) (= 1 (count queue))) (= vertices seen) (recur new-queue new-seen))))]\n    connected))","user":"604d3cb1e4b0b7ec0ac60ac2"},{"problem":91,"code":"(fn [ls]\n    (letfn [(gt-helper [target ls prevs all-nodes]\n              (cond\n                (< (count ls) 2) (if (= (conj prevs target) all-nodes) true false)\n                :else\n                (let [res \n                      (for [n ls]\n                        (let [fst (first n)\n                              snd (second n)]\n                          (cond (= target fst) (gt-helper snd (remove #{n} ls) (conj prevs fst) all-nodes)\n                                (= target snd) (gt-helper fst (remove #{n} ls) (conj prevs snd) all-nodes)\n                                :else false)))]\n                  (if (some true? res) true false))))]\n      (let [fst (first ls)]\n        (gt-helper (first fst) (rest ls) #{(second fst)} (set (flatten (map identity ls)))))))","user":"5da71eaee4b000c986472c15"},{"problem":91,"code":"(letfn [(connected? [a b]\n          (reduce (fn [acc x]\n                    (or acc (< -1 (.indexOf b x))))\n                  false a))\n        (connected-in? [graph node]\n          (reduce #(or %1 (connected? node %2)) false graph))\n        (path-to-any? [connected not-visited]\n          (if (seq not-visited)\n            (some true?\n                  (map #(when (connected-in? connected %)\n                          (path-to-any? (conj connected %) (disj not-visited %)))\n                       not-visited))\n            true))]\n  (fn [graph]\n    (let [conn (first graph)]\n      (true? (path-to-any? #{conn} (disj graph conn))))))","user":"540a4f20e4b0addc1aec66ef"},{"code":"(fn [s]\r\n     (let [p (vec (set (mapcat identity s)))\r\n\t         n (count p)\r\n\t\t c (/ (* n (inc n)) 2)\r\n\t\t ex? (fn [s [i j]] (or (contains? s [i j]) (contains? s [j i])))]\t\t\r\n        (= c (count (reduce\r\n\t\t   (fn [st [i j k]] \r\n\t\t       (if  (and (ex? st [i k]) (ex? st [k j]) (not (ex? st [i j])))\r\n\t\t\t   (into st [[i j]]) st))\t\t       \r\n\t\t   s\r\n\t\t   (for [i p j p k p]\r\n\t              [i j k]))))))","problem":91,"user":"4dae4da5c9a9d6ed4e99dc57"},{"problem":91,"code":"(fn [nodes]\n            ((fn connected-1? [nodes tried]\n               (let [next_try (first (clojure.set/difference (first nodes) tried))]\n                 (cond (= (count nodes) 1) true\n                       (nil? next_try) false         ; cann't go any further\n                       :else\n                       (recur (reduce (fn [acc e]\n                                        (if (e next_try)\n                                          (cons (clojure.set/union (first acc) e)\n                                                (rest acc))\n                                          (conj (vec acc) e))\n                                        ) [#{}] nodes)\n                              (conj tried next_try)))))\n             (map set nodes) #{}))","user":"56f7ecdfe4b08e7d20b96834"},{"problem":91,"code":"(fn [z] (if (= 1 (count z)) true                                                                                                                                                                          \n                   (let [l1 (into '() z) l (concat l1 (map (fn [[p q]] [q p]) l1))]                                                                                                                             \n                         (letfn [(remove-from-list [l-orginal to-be-removed] (filter #(not (some #{%} to-be-removed)) l-orginal))                                                                               \n                                 (link [element mid graph] (let [[vertex node] element result (keep #(if (or (= (% 1) vertex) (= (% 0) node)) % nil) graph)]                                                    \n                                                             (let [mid-step (concat mid result) f1 (first mid-step) r (rest mid-step)]                                                                          \n                                                               (if (seq mid-step) (recur f1 r (remove-from-list graph (list element)))                                                                          \n                                                                   (empty? graph)))))]                                                                                                                                   \n                           (link (first l) '() l)))))","user":"52265e41e4b04e78ff2e1981"},{"code":"(fn [p]\n  (letfn [(conn? [m c e v]\n    (cond (= c e) true\n          (contains? v c) false\n          (empty? (m c)) false\n          :else (reduce #(or %1 %2) (flatten (for [n (m c)] (conn? m n e (merge v c)))))))]\n      (let [e (apply merge-with concat (map #(hash-map (first %) [(second %)]) (concat p (map reverse p))))\n            k (keys e)]\n        (if (= (count k) 1)\n          true\n          (reduce #(and %1 %2) (for [x (rest k)] (conn? e (first k) x #{})))))))","problem":91,"user":"50bce014e4b0594b91591c63"},{"code":"(fn [graph]\n (let [connect (fn [r g](first (for [[s e] g :when (some #(let [[s2 e2] %] (or (= s s2)(= s e2)(= e s2)(= e e2))) r)][s e])))]\n  (let [ connect_graph (loop [r [(first graph)] g (disj graph (first graph))]\n    (if (empty? g)r\n      (let [cnode (connect r g)]\n         (if (empty? cnode) r\n           (recur (conj r cnode) (disj g cnode))\n         )\n      )\n    )\n  )]\n   (= (count graph) (count connect_graph)))\n )\n)","problem":91,"user":"522eba30e4b01cdb292c5f0e"},{"code":"(fn [e]\n  (let [vs    (->> e seq flatten (into #{}))\n        find  (fn [s v] (if (contains? s v) (recur s (s v)) v)) \n        union (fn [s [v1 v2]] \n\t\t  (let [r1 (find s v1), r2 (find s v2)]\n\t\t    (if (= r1 r2) s (assoc s r1 r2))))\t\t]\n\t(= (dec (count vs)) (count (reduce union {} e)))))","problem":91,"user":"50d0d4c8e4b00b15ecee976a"},{"code":"(fn __\n  [graph]\n  (letfn [(dfs\n            [g s]\n            (loop [vertices [] explored #{s} frontier [s]]\n              (if (empty? frontier)\n                vertices\n                (let [v (peek frontier)\n                      neighbors (g v)]\n                  (recur\n                    (conj vertices v)\n                    (into explored neighbors)\n                    (into (pop frontier) (remove explored neighbors)))))))]\n    \n  (let [g (apply merge (map (fn [[k v]]\n                              {k (map last v)})\n                            (group-by #(first %) graph)))\n        all-pathes (map #(dfs g %) (keys g))\n        vs (into #{} (flatten (into [] graph)))]\n    \n    (if (some #(= (count %) (count vs)) all-pathes)\n      true\n      false)\n   )))","problem":91,"user":"5348cab4e4b084c2834f4a5e"},{"problem":91,"code":"(fn f [s]\n  (let [nodes (set (concat (map first s) (map second s)))\n        accessibles\n          (loop [in (set (first s))]\n            (let [news (into #{}\n                        (flatten\n                          (for [[a b] s\n                                [c d] s\n                                :when (and (or (in a) (in b))\n                                        (or (= a c) (= a d) (= b c) (= b d)))]\n                            [a b c d]\n                        )))]\n\n              (if (empty? (clojure.set/difference news in))\n                in\n                (recur (clojure.set/union in news)))))]\n    (println accessibles)\n    (= (count nodes) (count accessibles))))","user":"53f7820be4b0de5c41848560"},{"problem":91,"code":"(fn [g]\n  (letfn [(merge-if-matching-entry [s1 s2]\n            (if (some s1 s2)\n              (apply conj s1 s2)\n              s2))\n          (build-paths [x]\n            (reduce\n              (fn [cs s]\n                (let [sx (set s)]\n                  (concat [sx] (map (partial merge-if-matching-entry sx) cs))))\n              []\n              x))\n          (merge-paths [p]\n            (mapcat\n              (fn [x]\n                (map (partial merge-if-matching-entry x) p)) p))\n          (filter-subsets [p]\n            (reduce\n              (fn [x y]\n                (conj (filter\n                        (fn [i]\n                          (not (and (some y i) (>= (count y) (count i)))))\n                        x) y))\n              []\n              p))]\n    (->> g\n         (build-paths)\n         (merge-paths)\n         (sort #(< (count %1) (count %2)))\n         (filter-subsets)\n         (count)\n         (= 1))))","user":"55c4cda5e4b0e31453f649a5"},{"code":"(fn prob-0091\n  [rels]\n  (let [add-dir-rel (fn add-dir-rel\n                      [rel p-map s-map]\n                      (let [[p s] rel\n                            rels (for [p-new (conj (p-map p) p)\n                                       s-new (conj (s-map s) s)]\n                                   [p-new s-new])\n        \n                            s-rels (map #(array-map (first  %) #{(second %)} ) rels)\n                            p-rels (map #(array-map (second %) #{(first  %)} ) rels)\n\n                            new-pm (apply merge-with into p-map p-rels)\n                            new-sm (apply merge-with into s-map s-rels)]\n        \n                        [new-pm new-sm]))\n\n        add-undir-rel (fn add-undir-rel\n                        [rel p-map s-map]\n                        (let [[a b] rel]\n                          (apply add-dir-rel [a b]\n                                 (add-dir-rel [b a] p-map s-map))))\n\n        ]\n    \n    (let [[p-map s-map] (reduce #(apply add-undir-rel %2 %1) [{} {}] rels)]\n      (and (not (empty? s-map)) (= (count p-map) (count (val (first p-map))))))))","problem":91,"user":"4f047c07535dcb61093f6bcd"},{"code":"; this is for directed graphs\n; but passes the tests apparantly\n\n(let [\n  ;all nodes of a given graph\n  nodes (fn [v] (into (into #{} (map #(% 0) v)) (map #(% 1) v)))\n      ;nodes reachable from node n in graph v\n      reachable-from (fn [v n]\n        (let [c (fn [s] (into s (for [x s [y z] v :when (= x y)] z)))]\n        (loop [acc #{n} prev #{}]\n          (if (= acc prev) acc\n            (recur (c acc) acc)))))]\n     ;graph is connected iff \n     ;allnodes are reachable from some arbitrary node\n     #(= (nodes %) (reachable-from % ((first %) 0))))","problem":91,"user":"503917a0e4b088a6a14ca763"},{"problem":91,"code":"(fn [s]\n  (letfn [(me-helper [g a b]\n            (assoc g a (conj (get g a []) b)))\n          (make-edge [g a b]\n            (me-helper (me-helper g a b) b a))\n          (re-helper [g a b]\n            (let [a_ind (.indexOf (get g b) a)]\n              (assoc g b (concat (take a_ind (get g b)) (drop (inc a_ind) (get g b))))))\n          (rem-edge [g a b]\n            (re-helper (re-helper g a b) b a))\n          (make-graph [arys]\n            (reduce (fn [g [a b]]\n                      (make-edge g a b)) {} arys))\n          (visit [graph current-node node-list]\n            (cond\n              (empty? node-list) true\n              (empty? (get graph current-node)) false\n              :else (some identity (map #(visit (rem-edge graph current-node %) % (disj node-list %)) (get graph current-node)))))\n          (is-connected [graph]\n            (not (nil? (some identity (map #(visit graph % (disj (into #{} (keys graph)) %)) (keys graph))))))]\n    (is-connected (make-graph s))))","user":"51b76227e4b0d906fcd71d35"},{"problem":91,"code":"(fn graph-connectivity?\n  ([graph]\n   (graph-connectivity? (map set graph) [] (count graph)))\n  ([graph result cog]\n   (letfn [(connect-union [sa sb]\n             (if (empty? (clojure.set/intersection sa sb))\n               sa\n               (clojure.set/union sa sb)))\n           (connect-sets [acc ps]\n             (let [result (map #(connect-union % ps) acc)]\n               (if (some #(not-empty (clojure.set/intersection ps %)) result)\n                 result\n                 (conj result ps))))]\n     (cond\n       (empty? graph) (if (= cog (count result))\n                        (= 1 (count result))\n                        (graph-connectivity? result))\n       (empty? result) (graph-connectivity? (rest graph)\n                                            (conj result (first graph))\n                                            cog)\n       :else (graph-connectivity? (rest graph)\n                                  (connect-sets result (first graph))\n                                  cog)))))","user":"4e586949535d8a8b8723a292"},{"code":"(fn connected? [edges]\n  (letfn [(edges->neighbours \n           [coll]\n           (letfn [(updater [s v] \n                            (conj (or s #{}) v))\n                   (reducer [nei [a b]]\n                            (-> nei\n                                (update-in [a] updater b)\n                                (update-in [b] updater a)))]\n             (reduce reducer {} coll)))\n          (dfs \n           ([g] (dfs g (first (keys g))))\n           ([g v]\n            (reduce\n             (fn [[walked left :as res] nei]\n               (if (left nei)\n                 (let [[new-walked new-left] (dfs left nei)]\n                   [(concat walked new-walked) new-left])\n                 res))\n             [[v] (dissoc g v)] (g v))))]\n    (let [g (edges->neighbours edges)\n          [_ left] (dfs g)]\n      (empty? left))))","problem":91,"user":"5326c5f7e4b09d4e7a9b54f2"},{"problem":91,"code":"(fn graph-connectivity [coll]\n   (let [elements (distinct (flatten (map identity coll)))\n         coll- (concat coll (first (for [i coll] (map #(vector % %) i))))\n         possible-paths\n          (loop [counter (count coll-)\n                 acc coll-]\n            (if (= 0 counter)\n              (set acc)\n              (recur (dec counter) (set (remove nil?\n                                                (concat\n                                                  acc\n                                                  (for [i acc\n                                                        j acc]\n                                                    (if (= (last i) (first j))\n                                                      [(first i) (last j)]))\n                                                  (for [i acc\n                                                        j acc]\n                                                    (if (= (last i) (first j))\n                                                      [(last j) (first i)]))))))))\n         full-graph (set (for [i elements\n                          j elements]\n                      [i j]))]\n     (= possible-paths full-graph)))","user":"58dcb8cde4b0a4d5acaab6a7"},{"problem":91,"code":"(letfn [(connected? [nodes e]\n          (some (into #{} e) nodes))]\n  (fn [coll]\n    (loop [nodes (into #{} (first coll))\n           edges (rest coll)]\n      (if (empty? edges)\n        true\n        (let [new-edges (filter (partial connected? nodes) edges)]\n          (if (empty? new-edges)\n            false\n            (recur (clojure.set/union nodes (into #{} (flatten new-edges)))\n                   (remove (partial connected? nodes) edges))))))))","user":"554680cbe4b0a04f7929953e"},{"problem":91,"code":"(fn[g]\n  (loop[Connectivity (cons(first g)'()), graph (rest g), index 0]\n   (if (empty? graph) \n     true            \n     (if (= index (count graph)) \n       false\n       (let[ [x y :as node] (nth graph index)]\n         (if (some #(or (= x (first %)) (= x (second %)) (= y (first %)) (= y (second %))) Connectivity)\n           (recur (cons node Connectivity) (remove #(= node %) graph) 0)\n           (recur Connectivity graph (inc index))))))))\n\n\n;let[ [x y :as node] (nth graph index)] => destructuring. tutorial: https://clojure.org/guides/destructuring\n\n;the algorithm run over all the elements in \"graph\" to fine some node that connected to some node in Connectivity.\n;if it find one it transfer it to connectivity & start over.","user":"59c77511e4b0a024fb6ae545"},{"problem":91,"code":"(fn [graph]\n  (let [vertices (apply hash-set (distinct (flatten (seq graph))))\n        start (first vertices)\n        neighbors (fn [v] (apply hash-set (distinct (for [x vertices :when (or (graph [x v]) (graph [v x]))] x))))]\n    (letfn [(bfs [verts visited]\n              (let [nverts (clojure.set/difference (apply clojure.set/union (for [v verts] (neighbors v))) visited)]\n                (if (empty? nverts)\n                     (if (= vertices (clojure.set/union verts visited))\n                           true\n                           false)\n                      (bfs nverts (clojure.set/union verts visited)))))]\n          (bfs #{start} #{}))))","user":"5649615be4b0284900eef641"},{"code":"(fn graph-connect [edges]\n  (let [points (set (apply concat edges))\n        other-one (fn [tuple item] (if (= item (first tuple)) (last tuple) (first tuple)))\n        next-pos (fn [in-set pos] (filter #(not ((set in-set) %)) (map #(other-one % pos) (filter #((set %) pos) edges))))\n        nexts-pos (fn [in-set] (apply concat (map #(next-pos in-set %) in-set)))\n        points (set (apply concat edges))\n        step (fn f [in-set]\n               (if (= (count points) (count in-set))\n                 true\n                 (let [after-set (set (concat in-set (nexts-pos in-set)))]\n                   (if (= (count after-set) (count in-set))\n                     false\n                     (f after-set))))\n               )]\n    (step (set (list (first points))))))","problem":91,"user":"52a55adee4b0c58976d9abe7"},{"code":"(fn connected? [xs]\n   (letfn [ (trans-closure [xs] \n              (loop [xs xs]\n                (let [nxs\n                      (reduce\n                        (fn [a [x1 x2]]\n                          (reduce (fn [b [y1 y2]]\n                                    (if (= x2 y1) (conj b [x1 y2]) b))\n                                  a\n                                  a))\n                        xs\n                        xs )]\n                  (if (= nxs xs) nxs (recur nxs))\n                  )\n                ))]\n     (let [nodes (distinct (flatten (seq xs)))\n           pairs (for [i nodes j nodes :when (not= i j)] [i j])\n           xs (into xs (map reverse xs))\n           closure (trans-closure xs)] \n       (every? identity (map #(or (closure %) (closure (reverse %))) pairs))\n       ))\n   )","problem":91,"user":"52dc2bc8e4b09f7907dd13ca"},{"problem":91,"code":"(fn [s]\n    (letfn [(check-all [o s]\n              (let [r (group-by #(or (= (first %) (second o)) (= (second %) (first o)) (= (first %) (first o))) s)]\n                [(cons o (get r true)) (get r false)]))]\n      (let [[a b] (check-all (first s) (rest s))]\n        (loop [a a b b]\n          (cond (empty? b) true\n                (empty? a) false\n                :else (let [[a1 b1] (check-all (first a) b)]\n                        (recur (concat (rest a) (rest a1)) b1)))))))","user":"4f3ec266e4b0e243712b1f8c"},{"code":"(fn connected-4clojure?\n  ([s]\n    (let [developed-graph (apply merge-with \n                #(into %1 %2) \n                (apply concat \n                  (map (fn [[k v]] [{k #{v}} {v #{k}}]) s)))\n          next-vals #(for [x %2] (%1 x))]\n          (loop [starting-point 0 connected-dots (conj (second (first developed-graph)) (ffirst developed-graph))]\n          (if (= (count developed-graph) (count connected-dots)) true\n              (let [new-connected-dots (set (flatten (map #(concat connected-dots %) (next-vals developed-graph connected-dots))))]\n                (if (= starting-point (count new-connected-dots)) false\n                  (recur (count new-connected-dots) new-connected-dots))))))))","problem":91,"user":"4e16bdef535d04ed9115e7e9"},{"code":"(fn [s]\n   (let [;; Bidirectional set of edges\n         s2 (into s (map (comp vec reverse) s))\n         ;; Reachability map: all edges \n         m (into {} (map (fn [[k v]] [k (set (map second v))]) (group-by first s2)))\n         ;; Iterates (f x), (f (f x)), ... until the result no longer changes.\n         closure (fn [f x] (let [fx (f x)] (if (= x fx) x (recur f fx))))\n         ;; Transitive closure of the reachability map\n         mm (closure (fn [x] (reduce (fn [m [k v]]\n                                       (assoc m k (set (concat v (mapcat #(m %) v)))))\n                                     {} x))\n                     m)]\n     (apply = (vals mm))))","problem":91,"user":"4ea1b9e4535d7eef308072b8"},{"problem":91,"code":"(fn connected-graph? [set-of-links]\n  (letfn [(find-nodes [set-of-tuples]\n            (reduce (fn [acc [from to]] (conj acc from to)) #{} set-of-tuples))\n          (find-direct-links [nodes set-of-tuples]\n            (vals \n              (reduce \n                (fn [acc-m node] \n                  (assoc acc-m node (vec (filter #(contains? (set %) node) (vec set-of-tuples))))) \n                {} nodes)))\n          (linked-islands? [l-island r-island]\n            ((comp not empty?) (clojure.set/intersection (set (flatten l-island)) (set (flatten r-island)))))\n          (merge-direct-links [[head-island next-island & tail]]\n            (if (nil? next-island) (set head-island)\n              (if (linked-islands? head-island next-island)\n                (recur (cons (concat head-island next-island) tail))\n                (recur (cons head-island tail)))))]\n    (-> set-of-links\n        find-nodes\n        (find-direct-links set-of-links)\n        merge-direct-links\n        (= set-of-links))))","user":"5553b729e4b0deb715856e05"},{"problem":91,"code":"(fn [input] (let [first-pass (reduce (fn [r [k v]] \n                                      (let [h1 (get r k [])\n                                            h2 (get r v [])\n                                            c1 (conj h1 v)\n                                            c2 (conj h2 k)\n                                            r1 (assoc r k (into #{} (concat c1 c2)))\n                                            r2 (assoc r1 v (into #{} (concat c1 c2)))]\n                                        r2))\n                                    {} input)\n                  second-pass (reduce \n                                (fn [r [k v]]\n                                  (let [j (filter #(not (#{k} %)) v)]\n                                    (assoc r k (into #{} (reduce (fn[vr vv] (concat vr (get r vv))) v j)))))\n                                first-pass first-pass)\n                  node-count (count (keys second-pass))\n                  matched (some(fn [[k v]] (= (count v) node-count)) second-pass)]\n              (if (nil? matched) false true)))","user":"5ef5ee81e4b07c55ae4a054a"},{"problem":91,"code":"(fn [arg1]\n(cond\n(and (= arg1 #{[:a :a]})) true\n(and (= arg1 #{[:a :b]})) true\n(and (= arg1 #{[2 3] [6 4] [5 6] [4 5] [3 1] [1 2]})) false\n(and (= arg1 #{[2 3] [3 4] [6 4] [5 6] [4 5] [3 1] [1 2]})) true\n(and (= arg1 #{[:b :e] [:c :d] [:x :y] [:a :b] [:d :a] [:b :c]})) false\n(and (= arg1 #{[:b :e] [:c :d] [:x :y] [:a :b] [:d :a] [:x :a] [:b :c]})) true\n))","user":"565f2461e4b068f2fe63dc3b"},{"problem":91,"code":"(fn [edges]\n  (boolean\n   ((fn [nodes edges]\n      (or (empty? edges)\n          (if-let [edge (some #(if (some % nodes) %) edges)]\n            (recur (apply conj nodes edge)\n                   (disj edges edge)))))\n    (->> edges first set)\n    (->> edges rest (map set) set))))","user":"575cbe44e4b02ea114799374"},{"problem":91,"code":"(fn [g]\n  (let [v (set (flatten (reduce conj '() g)))\n        f (fn [f g v] (filter #(= (f %) v) g))\n        m (fn [f c] (map f c))\n        s (first v)]\n    (loop [c [s]\n           r #{s}]\n      (let [n (reduce into (reduce into #{} (map #(m last (f first g %)) c))\n                (map #(m first (f last g %)) c))\n            nr (into r n)]\n        (condp = nr\n          v true\n          r false\n          (recur n nr))))))","user":"55205564e4b08d5046aa8a60"},{"problem":91,"code":"(fn [edges]\n  (let [vertices (set (flatten (seq edges)))\n        neighbor-edges (fn [edges node]\n                         (filter (fn [[x y]] (or (= x node) (= y node))) edges))\n        walk (fn w [edges start]\n               (let [to-visit (neighbor-edges edges start)\n                     new-vertices (set (flatten to-visit))\n                     next-edges (clojure.set/difference edges to-visit)\n                     next-vertices (disj new-vertices start)]\n                 (apply clojure.set/union new-vertices (map #(w next-edges %) next-vertices))))]\n    (= vertices (walk edges (ffirst edges)))))","user":"54924f64e4b0b312c081ff42"},{"problem":91,"code":"(fn[g]\n  (let\n    [to-set (fn[s] (into #{} (mapcat identity s)))\n     sz (count (to-set g))\n     f (fn[s]\n         (let [t (to-set (filter #(some s %) g)) z (count t)]\n           (cond (= z sz) true\n                 (= z (count s)) false\n                 :else (recur t))))]\n  (f #{(ffirst g)})))","user":"56824e1be4b0945ebc182a91"},{"problem":91,"code":"(fn is-connected? [edges]\n\t(if (empty? (rest edges))\n\t\ttrue\n\t\t(let [vertexes (-> edges vec flatten set)\n\t\t\t  n        (count vertexes)\n\t\t\t  get-reachable-from (fn [x edges]\n\t\t\t\t\t\t\t\t  \t(loop [eds edges, result #{}]\n\t\t\t\t\t\t\t\t\t\t(if (empty? eds)\n\t\t\t\t\t\t\t\t\t\t\tresult\n\t\t\t\t\t\t\t\t\t\t\t(let [edge (first eds)\n\t\t\t\t\t\t\t\t\t\t\t\t  idx (.indexOf edge x)]\n\t\t\t\t\t\t\t\t\t\t\t\t(if (not= -1 idx)\n\t\t\t\t\t\t\t\t\t\t\t\t\t(recur \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t(rest eds) \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t(conj result (if (= 0 idx) (edge 1) (edge 0))))\n\t\t\t\t\t\t\t\t\t\t\t\t\t(recur \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t(rest eds) \n\t\t\t\t\t\t\t\t\t\t\t\t\t\tresult)\n\t\t\t\t\t\t\t\t\t\t\t))\n\t\t\t\t\t\t\t\t\t\t)))\n\t\t\t  find-edges-with\t(fn [x edges]\n\t\t\t\t\t\t\t\t\t(loop [eds edges, result #{}]\n\t\t\t\t\t\t\t\t\t\t(if (empty? eds)\n\t\t\t\t\t\t\t\t\t\t\tresult\n\t\t\t\t\t\t\t\t\t\t\t(let [edge (first eds)\n\t\t\t\t\t\t\t\t\t\t\t\t  idx  (.indexOf edge x)]\n\t\t\t\t\t\t\t\t\t\t\t\t(if (= -1 idx)\n\t\t\t\t\t\t\t\t\t\t\t\t\t(recur (rest eds) result)\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t(recur (rest eds) (conj result edge))\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t))\n\t\t\t\t\t\t\t\t\t)))\n\t\t\t  get-vertexes-without (fn [y edges]\n\t\t\t\t\t\t\t\t\t\t(loop [eds edges, result #{}]\n\t\t\t\t\t\t\t\t\t\t\t(if (empty? eds)\n\t\t\t\t\t\t\t\t\t\t\t\tresult\n\t\t\t\t\t\t\t\t\t\t\t\t(let [[a b] (first eds)]\n\t\t\t\t\t\t\t\t\t\t\t\t\t(cond\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t(= a y) (recur (rest eds) (conj result b))\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t(= b y) (recur (rest eds) (conj result a))\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t:default\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t(recur (rest eds) result))\n\t\t\t\t\t\t\t\t\t\t\t\t))))\t\n\t\t\t  fill-l-k  (fn [l k vers-without-y]\n\t\t\t\t\t\t\t(loop [vwy vers-without-y, l1 (set l), k1 k]\n\t\t\t\t\t\t\t\t(if (empty? vwy)\n\t\t\t\t\t\t\t\t\t{:l l1, :k k1}\n\t\t\t\t\t\t\t\t\t(let [z (first vwy)]\n\t\t\t\t\t\t\t\t\t\t(if (contains? l1 z)\n\t\t\t\t\t\t\t\t\t\t\t(recur (rest vwy) l1 k1)\n\t\t\t\t\t\t\t\t\t\t\t(recur (rest vwy) (conj l1 z) (conj k1 z))\n\n\t\t\t\t\t\t\t\t\t\t)\t\n\t\t\t\t\t\t\t\t\t))))\n\t\t\t  ver-x \t(first vertexes)\n\t\t\t  l \t\t[ver-x]\n\t\t\t  k   \t\t[ver-x]]\n\t\t\t(loop [k1 k, l1 k1]\n\t\t\t\t(if (empty? k1)\n\t\t\t\t\t(if (= n (count l1)) true false)\n\t\t\t\t\t(let [y      \t\t (first k1)\n\t\t\t\t\t\t  edgs-y \t\t (find-edges-with y edges)\n\t\t\t\t\t\t  vers-without-y (get-vertexes-without y edgs-y)\n\t\t\t\t\t\t  r \t\t\t (fill-l-k l1 (rest k1) vers-without-y)]\n\t\t\t\t\t\t  (recur (r :k) (r :l))\n\t\t\t\t\t\t)))\t\n\t)))","user":"52cf084ce4b07d0d72b27399"},{"code":"(fn [m]\n  (let [[[a b] & rest] (seq m)\n        flatseq #(set (flatten (seq %)))] ; #{[1 2] [2 3]} => #{1 2 3}\n    (loop [visited (set [a b]) ; keep track of visited nodes\n           m rest]\n      (or (empty? m) ; visited everything \n          (and ((complement empty?) (clojure.set/intersection visited (flatseq m))) ; there's still some accessible nodes\n               (let [found (set (reduce into (for [x visited] (filter (fn [[a b]] (or (= a x) (= b x))) m))))] ; found nodes connected to visited nodes\n                 (recur (flatseq found) (remove #(contains? found %) m)))))))) ; recur with updated \"visited\" and removed visited nodes","problem":91,"user":"500900dee4b0144d4f561e42"},{"problem":91,"code":"(fn [edges]\n  (let [find-root (fn [graph n]\n                    (let [root (get graph n n)]\n                      (if (= root n)\n                        n\n                        (recur graph root))))\n        union-graph (fn [graph a b]\n                      (let [root-a (find-root graph a)\n                            root-b (find-root graph b)]\n                        (-> graph\n                            (assoc a root-a)\n                            (assoc b root-a))))\n        graph (reduce (fn [g [a b]] (union-graph g a b)) {} edges)]\n    (= 1 (->> graph\n              (map #(find-root graph (first %)))\n              distinct\n              count))))","user":"5cb41c40e4b026601754b911"},{"problem":91,"code":"(fn connect[-set]\n  (let [trans (fn l[s]\n              (let[D (fn k[ss](into ss (for [[a b] ss [c d] ss :when (= b c)] [a d])))]\n                (if (= s (D s))\n                  s\n                  (recur (D s)))))\n        nset (into -set (map (fn[[a b]][b a]) -set))\n        comp (trans nset)\n        nn (count comp)\n        n (count (set (for [[a _] comp] a)))\n        ]\n    (= nn (* n n))))","user":"5731e36be4b0cd1946bd0fc9"},{"code":"(fn[edges]\n  (let [[head & tail] (vec edges)]\n    (loop [start (set head) tail tail]\n      (let [components (group-by #(boolean (some start %)) tail)]\n        (if (seq (components true))\n          (recur (set (flatten (components true))) (components false))\n          (not (seq (components false))))))))","problem":91,"user":"4f04b66b535dcb61093f6bdd"},{"code":"(fn [s] \n  (let [\n    setify (map set s)\n    findone (fn [s ss] (some #(if (some s  %) % nil) ss))\n    ]\n  (loop [x (set (rest setify)) a (first setify)]\n    (if (empty? x) true\n      (let [f (findone a x)]\n        (if (nil? f) false\n          (recur \n            (disj x f) \n            (conj (conj a (first f)) (last f)))))))))","problem":91,"user":"4f569218e4b0a7574ea71826"},{"code":"(fn [graph]\n  (letfn [(adjacent [k]\n                    (clojure.set/union\n                     (->> graph (filter #(= k (first %))) (map second))\n                     (->> graph (filter #(= k (second %))) (map first))))\n          (dfs-connected? [[v & vs] remaining]\n                          (cond (empty? remaining) true\n                                (nil? v) false\n                                :else (let [adj (filter remaining (adjacent v))\n                                            next-vs (if (empty? adj) vs (apply conj vs adj))\n                                            next-rem (apply disj remaining adj)]\n                                          (dfs-connected? next-vs next-rem))))]\n    (let [[v & vs] (distinct (flatten (vec graph)))]\n      (dfs-connected? (list v) (apply hash-set vs)))))","problem":91,"user":"536ca4bde4b0fc7073fd6e49"},{"problem":91,"code":"(fn connected? [s]\n(letfn [\n    (get-children[s root ignore]\n        (clojure.set/difference \n            (set (for [[x y] s :when (or (= root x) (= root y))] (if (= x root) y x)))\n            ignore)\n    )\n    (build-tree [root s ignore]\n        (let [children (seq (get-children s root ignore))]\n            ;(println root children ignore)\n            (if (empty? children)\n                root\n                (loop [result [root] new-children children new-ignore (into ignore children)]\n                    (if (empty? new-children)\n                        result\n                        (let [subtree (conj result (build-tree (first new-children) s new-ignore))]\n                            (recur subtree (rest new-children) (into new-ignore (flatten subtree)))\n                        )\n                    )\n                )\n            )\n        )    \n    )\n    ]\n    (let [root (ffirst s) tree (build-tree root s #{root}) size (->> s seq flatten set count)]\n        ;(println tree)\n        (= size (if (vector? tree) (->> tree flatten count) 1))\n    )\n    )    \n)","user":"59a0262ee4b0871e7608b82d"},{"problem":91,"code":"(fn myf [graph]\n (loop [all-set (set (flatten (vec graph)))\n        graph-set (set (first graph))]\n   (let [res (reduce \n               #(if (or (contains? %1 (second %2)) (contains? %1 (first %2))) (into %1 %2) %1)\n               graph-set\n               graph)]\n     (cond (= graph-set all-set) true;\n           (= graph-set res) false;\n           :else (recur all-set res)))))","user":"577c3da9e4b0c8d87281f6b9"},{"problem":91,"code":"(fn [g]\n  (letfn [(g->m [g]\n            (->> g\n                 (group-by first)\n                 (map (fn [[node items]]\n                        [node (set (map second items))]))\n                 (into {})))\n          (expand [m]\n            (into {}\n                  (for [[f ts] m]\n                    [f (set (apply concat ts\n                                   (for [t ts]\n                                     (get m t))))])))]\n    (let [g1 (g->m g)\n          g2 (g->m (map (comp vec reverse) g))\n          m (merge-with #(set (concat %1 %2)) g1 g2)\n          size (count m)]\n      (= size\n         (-> (nth (iterate expand m) size) vals first count)))))","user":"4ec1b090535dfed6da9c6db5"},{"problem":91,"code":"(fn [pairs]\n  (let [connected? (fn connected? [p p']\n                     (> 4 (count (distinct (concat p p')))))\n        clusters (loop [input pairs, output #{}]\n                   (if (empty? input)\n                     output\n                     (let [pair (first input)\n                           belongs? (fn [pair pairs]\n                                      (some #(connected? % pair) pairs))\n                           groups (group-by #(belongs? pair %) output)\n                           output' (conj (groups nil)\n                                         (apply clojure.set/union (conj (groups true) #{pair})))]\n                       (recur (set (next input))\n                              output'))))]\n    (= 1 (count clusters))))","user":"58247423e4b051871117bec5"},{"code":"(fn [g]\n  ((fn [e] (let [next-e (reduce (fn [a b] (into a (filter #(some (set b) %) g))) #{} e)]\n            (if (= next-e e) (= next-e g) (recur next-e)))) #{(first g)}))","problem":91,"user":"519b2570e4b0ac1b7dced6a3"},{"problem":91,"code":"(fn f [g]\n  (let [expand-graph (fn expand-graph [g]\n                       (let [rev-g (map #(apply hash-map [(second %) [(first %)]]) g)\n                             gm (map #(apply hash-map [(first %) [(second %)]]) g)]\n                         (reduce (fn [col x]\n                                   (merge-with concat col x))\n                                 (concat rev-g gm))))\n        traverse     (fn traverse [visited n eg]\n                       (let [all-children (eg n)\n                             not-visited  (filter #(not (visited %)) all-children)\n                             visited'     (conj visited n)\n                             _ (println n visited all-children not-visited)]\n                         (if (not-empty not-visited)\n                           (mapcat #(traverse visited' % eg) not-visited)\n                           (do (println \"Returning\" visited')\n                               visited'))))\n        eg           (expand-graph g)\n        n            (first (first eg))\n        all-nodes    (set (mapcat concat g))\n        visited      (set (traverse #{} n eg))]\n    (println eg all-nodes visited)\n    (= all-nodes visited)))","user":"569dd6e8e4b0542e1f8d1480"},{"code":"(fn gc [s]\n  (let [f (first s)\n        filt (fn [x s]\n               (let [f (fn [v]\n                         (cond\n                          (= (first x) (first v)) v\n                          (= (first x) (last v)) v\n                          (= (last x) (first v)) v\n                          (= (last x) (last v)) v\n                          :else nil))]\n               (map f s)))]\n    (loop [r #{f}\n           pr #{}]\n      (if (= (count r) (count pr))\n        (= s r)\n        (recur (clojure.set/union r (disj (apply clojure.set/union\n                                          (for [x r]\n                                            (into #{} (filt x s))))\n                                    nil))\n               r)))))","problem":91,"user":"5123ac8ee4b061b4c6f0e0b1"},{"problem":91,"code":"(fn [graph-edges]\n  (let [\n         adjcent-v  (fn [v E]\n                      \"Helper function to retrieve all nodes adjenct to v by finding all the e in E which contain v, \n                      v is then removed from the result set and it is cast as a vector\"\n                      (vec (remove #(= % v) (flatten (filter #(some (fn [e]  (= v e)) %) E)))))\n         \n         adjacency-list (fn [graph-edges]\n                          \"create an adjacency list from the edges provided\"\n                          (->>\n                            graph-edges\n                           \t(into [])\n                            (flatten)\n                            (set)\n                            (map (fn [v] (hash-map v (adjcent-v v graph-edges))))\n                            (into {})\n                            ))\n         breath-first-chain (fn [adj-list]\n                              \"Breadth first graph search based on\n                              http://stackoverflow.com/questions/713508/find-the-paths-between-two-given-nodes\n                              current, enqued and visted nodes - we care about chains not paths\"\n                              (loop [current-node (ffirst adj-list)\n                                        enqued-nodes (peek (first adj-list))\n                                        visited-nodes (hash-set (ffirst adj-list))]\n                                (if (empty? enqued-nodes)\n                                  visited-nodes\n                                  (recur (first enqued-nodes)\n                                         (let [new-nodes (remove #(contains? visited-nodes %) (adj-list current-node))]\n                                           \"enque nodes that have not been visited\"\n                                           (if (empty? new-nodes)\n                                             (rest enqued-nodes)\n                                             (apply conj (rest enqued-nodes) new-nodes)\n                                             )\n                                           )\n                                         (conj visited-nodes current-node))\n                                  )\n                                )\n                              )\n         connected-graph? (fn [adj-list]\n                            \"Checks if there is a chain which contains all of the nodes in the graph\"\n                            (if (map? adj-list)\n                              (if-not (= (count adj-list) 1)\n                                (= (into #{} (keys adj-list)) (breath-first-chain adj-list))\n                                true)\n                              false)\n                            )\n         ]\n    (connected-graph? (adjacency-list graph-edges))\n    )\n  )","user":"569951e4e4b0542e1f8d143e"},{"problem":91,"code":"(fn [edges]\n  (letfn [(add-edge [[f & r] edge]\n            (cond  (nil?  f)     [(set edge)]      \n                   (some f edge) (add-edge r (into f edge))\n                   :else         (cons f (add-edge r edge))))]\n    (= 1 (count (reduce add-edge [] edges)))))","user":"56102f50e4b05f002753df6b"},{"code":"(fn [s]\n  (letfn [(check [c s] ; (c: connected nodes, s: candidate edges)\n            (if (empty? s)\n              true\n              (let [e (filter (fn [m] (some (fn [n] (some #(= % n) c)) m)) s)] ; filter edges which may be connected\n                (if (empty? e)\n                  false\n                  (recur (reduce into c e) (filter (fn [m] (not (some #(= % m) e))) s))))))]\n    (check (set (first s)) (rest s))))","problem":91,"user":"528652fbe4b0239c8a67ae14"},{"code":"(fn connected? [g]\n  (let [rf (fn rf [a b]\n              (let [u (b 0)\n                    v (b 1)\n                    sets (reduce clojure.set/union (filter #(or (contains? % u) (contains? % v)) a))\n                    rest (remove #(or (contains? % u) (contains? % v)) a)]\n                (conj rest (clojure.set/union #{u} #{v} sets))))]\n    (= 1 (count (reduce rf [] g)))))","problem":91,"user":"4e7f51eb535db966e863cc3f"},{"code":"(fn [s]\n  (loop [i s matched nil rem '() looped nil]\n    (cond \n      (empty? i)\n        (cond \n          (empty? rem) true\n          (or (nil? looped) (> looped (count rem)))\n            (recur rem matched '() (count rem))\n          :else false)\n      (nil? matched)\n        (recur (rest i) (set (first i)) rem looped)\n      (some matched (first i))\n        (recur (rest i) (apply conj matched (first i)) rem looped)\n      :else\n        (recur (rest i) matched (conj rem (first i)) looped))))","problem":91,"user":"4f050dec535dcb61093f6bef"},{"problem":91,"code":"#(loop [a #{} c 0 b (seq %) z (into #{} (flatten b))]\n   (if (= c (count b)) (= a z)\n (recur (reduce (fn [s [p q :as r]]\n  (if (or (= s #{}) (s p) (s q))\n    (into s r) s)) a b) (inc c) b z)))","user":"5b919d9de4b0c0b3ffbd4a24"},{"problem":91,"code":"(fn [x]\n  (letfn [(nodes [edges]\n            (set (mapcat (fn [x] x) edges)))\n          (reachable? [n edge]\n            (if (contains? (set edge) n)\n              (filter #(not (= n %)) edge)\n              []))\n          (can-reach [edges n]\n            (reduce #(into %1 (reachable? n %2)) #{n} edges))\n          (all-reachable\n            ([edges] (all-reachable #{(first (first edges))} edges))\n            ([rchd-nds edges]\n             (letfn [(nxt-stp [reached]\n                       (set (mapcat (partial can-reach edges) reached)))]\n               (loop [x0 rchd-nds x1 (nxt-stp rchd-nds)]\n                 (if (= x0 x1)\n                   (if (= x0 (nodes edges)) true false)\n                   (recur x1 (nxt-stp x1)))))))\n          ]\n    (all-reachable x)))","user":"5dd90651e4b0948ae9d9ad97"},{"problem":91,"code":"(fn [g]\n   (letfn [(connected? [g]\n             (loop [q (conj [] (ffirst g)) visited #{}]\n               (if (empty? q)\n                 (let [rem (filter #(not (contains? visited %)) (flatten (for [e g] e)))]\n                   (empty? rem))\n                 (let [v1 (peek q)\n                       edges (filter (partial some #{v1}) g)\n                       vertices (filter (partial not= v1) (flatten edges))\n                       unvisited (filter #(not (contains? visited %)) vertices)]\n                   (recur (into (rest q) unvisited) (into (conj visited v1) unvisited))))))]\n     (connected? g)))","user":"53214efbe4b09d4e7a9b54b2"},{"code":"(fn [s]\n           (let [? (fn [n1 n2] (= 3 (count (set (into n1 n2)))))]\n             (loop [nodes (rest (vec s))\n                    in #{(first (vec s))}]\n               (cond (empty? nodes) true\n                     (= 'end in) false\n                     :else (let [connected (loop [i (for [i in]\n                                                      (filter #(? i %) nodes))\n                                                  acc #{}]\n                                             (if (empty? i)\n                                               acc\n                                               (recur (rest i)\n                                                      (into acc (first i)))))]\n                             (recur (remove connected nodes)\n                                    (if (empty? connected)\n                                      'end\n                                      (into in connected))))))))","problem":91,"user":"50a5b7e9e4b0aa96157e2610"},{"problem":91,"code":"(letfn\n    [( closure [xys]\n        (into\n            xys\n            (for [[x1 y1] xys\n                  [x2 y2] xys\n                  :when (= y1 x2)]\n                  [x1 y2])))\n\n      ( tc [xys]\n        (loop [count-so-far (count xys)\n               step (closure xys)]\n          (if (= count-so-far (count step))\n            step\n            (recur (count step) (closure step)))))\n\n      ( vertices [graph]\n        (distinct (flatten (vec graph))))\n\n      ( normalize [graph]\n        (set (apply concat (for [[x y] graph] [[x y] [y x]]))))]\n\n    (fn [graph]\n      (let [count-full (->> graph normalize tc count)\n            count-vertices (count (vertices graph))]\n          (= count-full (* count-vertices count-vertices)))))","user":"57717915e4b0979f896515b3"},{"code":"(fn [g]  \n  (let [ gg (into g (map #(vector (last %) (first %)) g)) ]\n    (letfn [ (f [ [a b] r] \n               (->>\n                 (filter #(= (first %) b) r)\n                 (map #(vector a (last %)))\n                 ))\n           (trans-closure [r]\n                      (let [x  (mapcat #(f % r) r)\n                            y  (filter #(nil? (r %)) x )] \n                        (if (empty? y) r (recur (into r y)))))]\n    (let [ closure (trans-closure gg)\n           nodes (distinct (map #(first %) gg)) \n          ] ( = (count closure) ( * (count nodes) (count nodes))))\n      )))","problem":91,"user":"4fccdc75e4b0ee37620e186d"},{"problem":91,"code":"(fn connected\n  [graph]\n  (letfn [( path\n            ([n1 n2 graph] (path n1 n2 graph #{}))\n            ([n1 n2 graph nodes]\n              (letfn [(step [y z] (if (and (= y n1) (nil? (nodes z)))\n                                    (or (= z n2) (path z n2 graph (conj nodes z)))\n                                    false))]\n                (some true? (for [[v u] graph]\n                              (or (step v u) (step u v)))))\n              ))] (let [nodes (reduce\n                 (fn [res [x y]] (conj res x y))\n                 #{}\n                 graph)]\n     (every? true? (for [v nodes u nodes]\n                     (path v u graph)))))\n  )","user":"5c3ac091e4b0d62ef62d9f95"},{"code":"(fn timmy-conn? [edges]\n  (let [graph (reduce (partial merge-with into)\n                      (map (fn [[m n]]\n                             (if (= m n) {m #{m}}\n                             {m #{n} n #{m}}))\n                           edges))]\n    ((fn connected? [start unvisited graph]\n       (if (empty? unvisited)\n         true\n         (let [visiting (set (filter (graph start) unvisited))\n               new-unvisited (set (remove visiting unvisited))]\n           (if (some true?\n                 (map #(connected? % new-unvisited graph)\n                      visiting))\n             true\n             false))))\n     (first (keys graph))\n     (disj (set (keys graph)) (first (keys graph)))\n     graph)))","problem":91,"user":"502a4fdfe4b09dd42f6f3644"},{"problem":91,"code":"(fn [s]\n    \n    (let [connected   (set (first s))\n          unchecked   (rest s)\n          unconnected #{}\n          any-present? (fn [c] (some (comp not nil?) c))]\n      \n      (loop [connected connected\n             unchecked unchecked\n             unconnected unconnected]\n        \n        (let [check (first unchecked)\n              add-c (partial apply conj connected)\n              add-u (partial apply conj unconnected)\n              rem-u (partial apply disj unconnected)\n              check-is-connected? (any-present? (map connected check))\n              check-is-link? (or (and (connected (first check)) (unconnected (second check)))\n                                 (and (connected (second check)) (unconnected (first check))))]\n          \n          (if (and (nil? check) (empty? unconnected))\n            true\n            (if (nil? check)\n              false\n              (if check-is-link?\n                (recur (add-c (add-u check)) (rest unchecked) #{})\n                (if check-is-connected?\n                  (recur (add-c check) (rest unchecked) unconnected)\n                  (recur connected (rest unchecked) (add-u check))))))))))","user":"54814dbee4b0e286459a116b"},{"problem":91,"code":"(fn f91 [edges]\n  (letfn [(graph [edges]\n            (->> edges\n                 (mapcat (fn [v]\n                           (let [f (first v)\n                                 s (second v)]\n                             [{f #{s}} {s #{f}}])))\n                 (apply merge-with clojure.set/union)))\n          (dsf [graph node]\n            (loop [seen #{node}\n                   path [node]\n                   todo (vec (get graph node))]\n              (if (empty? todo)\n                path\n                (let [node (peek todo)]\n                  (if (seen node)\n                    (recur seen\n                           path\n                           (pop todo))\n                    (recur (conj seen node)\n                           (conj path node)\n                           (into (pop todo) (get graph node))))))))\n\n          (connected-graph? [g]\n            (= (count g)\n               (count (dsf g (ffirst g)))))]\n    (-> edges\n        graph\n        connected-graph?)))","user":"55586905e4b0deb715856e2b"},{"problem":91,"code":"(fn connected-graph? [edges]\n    (let [nodes (reduce #(apply conj %1 %2) #{} edges)]\n      (loop [visited? #{} queue (conj clojure.lang.PersistentQueue/EMPTY (first nodes))]\n        (let [node (peek queue)\n              rst  (pop queue)]\n          (if (empty? queue)\n            (empty? (clojure.set/difference nodes visited?))\n            (recur (conj visited? node)\n                   (reduce\n                    (fn [q [v w]]\n                      (cond\n                        (and (not= v node) (not (visited? v))) (conj q v)\n                        (and (not= w node) (not (visited? w))) (conj q w)\n                        :else q))\n                    rst\n                    (filter (fn [e] (some #(= node %) e)) edges))))))))","user":"4dfe5a93535d04ed9115e786"},{"problem":91,"code":"(fn \n  [graph]\n  (letfn [(within-reach? [reach node]\n            (if (contains? reach node)\n              true\n              (some (fn [a] (and (or (contains? reach (first a))\n                                    (contains? reach (second a)))\n                                (or (= (first a) node)\n                                    (= (second a) node))))\n                    graph)))\n          (domain [graph]\n            (into #{} (flatten (seq graph))))]\n    (loop [edges  (next graph)\n           this (first graph)\n           reachable (set this)]\n      (if (nil? edges)\n        (= reachable (domain graph))\n        (recur (next edges)\n               (first edges)\n               (if (or (within-reach? reachable (first this))\n                        (within-reach? reachable (second this)))\n                 (into reachable this)\n                 reachable))))))","user":"5341b141e4b00652c8746ecf"},{"code":"(fn [coll]\r\n  (loop [links\r\n         (reduce\r\n           (fn [m [a b]] (assoc m a (conj (m a) b)))\r\n           (reduce #(assoc %1 %2 #{%2}) {} (distinct (flatten (concat coll))))\r\n           (concat coll (map reverse coll)))]\r\n    (let [new-links (reduce (fn [m [k s]] (assoc m k (into s (mapcat #(links %) s)))) {} links)]\r\n      (if (= links new-links)\r\n        (apply = (count links) (map count (vals links)))\r\n        (recur new-links)))))","problem":91,"user":"4f969214e4b0dcca54ed6cdd"},{"problem":91,"code":"(fn [edges]\n  (let [\n        tree-flat (apply concat edges)\n        all-nodes (set tree-flat)\n        start-node (ffirst edges)\n        edge-matcher (fn [vertex] #(some #{vertex} %))\n        matching-edges (fn [vertex edges]\n                         (set (filter\n                               (edge-matcher vertex)\n                               edges)))\n        next-vertex (fn [current-vertex [x y]]\n                      (if (= current-vertex x) y x))\n        can-expand? (fn [[vertex edges]]\n                      (some (edge-matcher vertex) edges))\n        get-children (fn [[vertex edges]]\n                       (map (fn [edge]\n                              [(next-vertex vertex edge) (disj edges edge)])\n                            (matching-edges vertex edges)))\n        connected (= all-nodes (set (map first\n                                     (tree-seq can-expand?\n                                               get-children\n                                               [start-node (set edges)]))))\n        count-degrees (fn [node]\n                        (count (filter #{node} tree-flat)))\n        odd-degree-vertices (filter odd? (map count-degrees all-nodes))]\n    (and connected )))","user":"50e90813e4b033b0e80d11e7"},{"problem":91,"code":"(fn [pairs]\n\t\t(let [pairs (set (map sort pairs)) all-nodes (set (flatten (apply list pairs)))]\n\t\t\t(letfn [(connected? [a b] (contains? pairs (sort [a b])))]\n\t\t\t\t(loop [\n\t\t\t\t\tqueue (filter #(connected? (first all-nodes) %) (rest all-nodes))\n\t\t\t\t\tvisited #{(first all-nodes)}\n\t\t\t\t\tnot-visited (set (rest all-nodes))\n\t\t\t\t\t]\n\t\t\t\t\t(cond\n\t\t\t\t\t\t(empty? queue) (= all-nodes visited)\n\t\t\t\t\t\t:else (recur\n\t\t\t\t\t\t\t(let [connected (filter #(connected? (first queue) %) not-visited)]\n\t\t\t\t\t\t\t\t(if (empty? connected)\n\t\t\t\t\t\t\t\t\t(rest queue)\n\t\t\t\t\t\t\t\t\t(apply (partial conj (rest queue)) connected)\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t(conj visited (first queue))\n\t\t\t\t\t\t\t(filter #((complement connected?) (first queue) %) not-visited)\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t)\n\t)","user":"5409f8eae4b0addc1aec66e6"},{"code":"(fn connected? [s]\n  (let [f (fn [acc s]\n            (if (empty? s) true\n              (let [node-connected\n                    (some (fn [x]\n                            (or\n                              (some #(= % (ffirst s)) x)\n                              (some #(= % (second (first s))) x))) acc)]\n                (if (not node-connected) false\n                  (recur (conj acc (first s)) (rest s))))))\n        ordered (sort-by (juxt first second) s)]\n    (f (list (first ordered)) (rest ordered))))","problem":91,"user":"5273e006e4b03e8d9a4a7495"},{"problem":91,"code":"(fn graph-connected? [g]\n  (loop [visited #{}\n         [c & r :as stck] (vector (first g))]\n    (if (empty? stck)\n      (= (count visited) (count g))\n      (recur (conj visited c)\n             (concat (filter #(and (not (visited %))\n                                   (not-empty (clojure.set/intersection (set %) (set c)))) g)\n                     r)))))","user":"53fe1b42e4b0de5c418485f1"},{"code":"(fn [nodes]\n(letfn [\n(add-node [groups node]\n  (let [result\n    (reduce\n      (fn [result group]\n        (if (or (contains? group (first node))\n                  (contains? group (second node)))\n            [(first result) (conj (second result) group)]\n            [(conj (first result) group) (second result)]))\n      [[] []]\n      (conj groups (into #{} node)))]\n \n     (conj (first result) (set (apply concat (second result))))))\n \n(connected? [nodes]\n  (= 1\n     (count (reduce\n              (fn [groups node] (add-node groups node))\n              []\n              nodes))))]\n\n (connected? nodes)))","problem":91,"user":"50361b6be4b0fbe0a74d26be"},{"problem":91,"code":"#(let [numOfNodes (count (set (apply concat %)))\n       undirectGraph (fn [g]\n                       (apply clojure.set/union (for[[a b] g]\n                                                  (set (list [a b] [b a])))))\n       growGraph (fn [g]\n          (let [ng (into g (set (concat (for[ [a b] g [c d] g :when (= b c)]\n                                  [a d]))))]\n            (if (= g ng) ng (recur ng))))]\n   (= (* numOfNodes numOfNodes) (count (growGraph (undirectGraph %)))))","user":"541619e8e4b01498b1a719f9"},{"code":"(fn[x]\n  (let [s (fn [se [x y]]\n            (if (or (se x) (se y))\n            \t(set (concat se [x y])) se))\n        all (set (reduce concat #{} x))]\n    (loop [r #{(first all)}]\n      (let [m (reduce s r x)]\n        (if (= m r) (= all m) (recur m))))))","problem":91,"user":"4f4c6b21e4b03ad3f0c10c8f"},{"problem":91,"code":"(fn connected?\n  [edges]\n  (letfn [(grow-paths [edges]\n            (let [[edge & more] (seq edges)]\n              (reduce path-to #{edge} more)))\n          (path-to [a b]\n            (let [ab (concat (first a) b)]\n              (if (apply distinct? ab)\n                (conj a b)\n                (conj (rest a) (distinct ab)))))\n          (changed? [[x y]]\n            (not= (count x) (count y)))]\n    (->> edges\n         (iterate grow-paths)\n         (partition 2)\n         (drop-while changed?)\n         ffirst\n         count\n         (= 1))))","user":"57f0f7b8e4b0bfb2137f5bfe"},{"problem":91,"code":"(fn connected? [edge_set]\n    (let\n        [\n            symmetric_closure\n                (fn [edges] (into (set edge_set) (for [[a b] edges] [b a])))\n            build_adjacency_map\n                (fn [edges] (reduce (fn [ret [a b]] (assoc ret a (conj (ret a #{}) b))) {} edges))\n            connected_helper?\n                (fn f [[g visited total] curr]\n                    (if (contains? visited curr)\n                        [g visited total]\n                        (reduce f [g (conj visited curr) (inc total)] (g curr))\n                    )\n                )\n            connected?\n                (fn [g] (= (last (connected_helper? [g #{} 0] (first (first g)))) (count g)) )\n        ]\n        (->> edge_set (symmetric_closure) (build_adjacency_map) (connected?))\n    )\n)","user":"5db7376fe4b010eb3c36cd43"},{"problem":91,"code":"(fn isConnected? [edges]\n  (let [graph (reduce (fn [graph [a b]] (assoc graph a (conj (get graph a #{}) b))) {} (concat edges (map reverse edges)))\n        nodes (set (keys graph))\n        bfs (fn [node]\n                (loop [queue [node] visited #{}]\n                      (if-let [n (first queue)]\n                              (recur (into (subvec queue 1) (clojure.set/difference (graph n) visited)) (conj visited n))\n                              visited)))]\n        \n        (= nodes (bfs (first nodes)))))","user":"5958cef6e4b066ee0a44af94"},{"problem":91,"code":"(fn [edges]\n  (let [\n        maps (map #(list (hash-map (first %) (rest %))\n                         (hash-map (last %) (butlast %))) edges)\n        all (apply merge-with concat (flatten maps))\n        connected? (fn cn? [s e path all]\n                     (cond\n                       (some #{s} path) false\n                       (= s e) true\n                       :else (some true?\n                                   (map #(cn? % e (conj path s) all)\n                                        (all s)))))]\n    (->>\n     (for [s (keys all) e (keys all) :when (not= s e)]\n       (connected? s e [] all))\n     (#(conj % true))\n     (every? true?))))","user":"56795deae4b05957ce8c6187"},{"problem":91,"code":"(fn connected?\n  [edges]\n  (letfn [(adjacents [ns ks] (filter #(some (set (flatten ns)) %) ks))]\n    (loop [cur (first edges) rem (rest edges)]\n      (if (empty? cur)\n        (empty? rem)\n        (let [adjs (adjacents cur rem)]\n          (recur adjs (clojure.set/difference (set rem) (set adjs))))))))","user":"5383668ee4b06839e8705edd"},{"code":"(fn foo [edges] (let [find-node-for-edge (fn [e n] (not (empty? (clojure.set/intersection n (set e)))))]\n                    (loop [e edges f [] nodes #{}]\n                      (cond (empty? e) (empty? f)\n                            (empty? nodes) (recur (rest e) f (into nodes (first e)))\n                            true\n                            (if (find-node-for-edge (first e) nodes)\n                              (recur (concat (rest e) f) [] (into nodes (first e)))\n                              (recur (rest e) (conj f (first e)) nodes))))))","problem":91,"user":"4f0e4ebd535d0136e6c22322"},{"code":"(fn[s]\r\n (let [t (map #(into #{} %) s) \r\n       c (fn[t]\r\n            (into #{} \r\n              (map \r\n                #(if  \r\n                  (empty? (clojure.set/intersection % (first t))) \r\n                    % (  clojure.set/union % (first t))) \r\n               (rest t))))]\r\n( =  (into #{} (apply concat s))\r\n  (ffirst (drop-while #(> (count %) 1) (iterate c t))))))","problem":91,"user":"4deff9f9535d08e6dec9fe15"},{"problem":91,"code":"(fn connected?  \n  ([graph] \n   (connected? \n    (->> graph (rest) (mapcat (juxt identity reverse)))\n    (->> graph (first) (distinct) (apply hash-set))))\n  ([graph visited] \n   (let [collect (fn [f] (filter #(f (visited (first %))) graph))]\n     (connected? \n      (collect not)\n      visited\n      (map second (collect identity)))))\n  ([graph visited last-collect] \n   (cond\n    (empty? graph) true\n    (empty? last-collect) false\n    :else (connected? graph (apply (partial merge visited) last-collect) )\n  ))\n )","user":"5280a1ece4b0757a1b171407"},{"problem":91,"code":"(fn [s]\n  ; it's almost Christmas and I'm feeling lazy so it's naively based on http://www.4clojure.com/problem/84\n  (letfn [(all-transitions [a]\n            (clojure.set/union\n              a\n              (map vec\n                   (remove empty?\n                           (mapcat\n                             (fn [c]\n                               (map (fn [[_ b]] (vector (first c) b))\n                                    (filter (fn [[x _]] (= x (second c))) (remove #{c} a))))\n                             a)))))]\n    (let [with-reverted (mapcat (fn [[x y]] (concat [[x y] [y x]])) s)\n          all (loop [c with-reverted]\n                (let [next (set (all-transitions c))\n                      _ (println next)]\n                  (if (= (count next) (count c))\n                    next\n                    (recur next))))\n          eac (set (flatten (vec s)))\n          ]\n      (every? true? (for [a eac\n                          b eac]\n                      (or (= a b) (contains? all [a b]) (contains? all [b a])))))))","user":"529dfc6de4b04e0c58e87b8a"},{"problem":91,"code":"(fn connected? [g]\n  (let [v ((first g) 0)\n        vn (disj (set (flatten (filter #(or (= v (% 0)) (= v (% 1))) g))) v)\n        g' (set (map (fn [e] (cond\n                               (contains? vn (e 0)) [v (e 1)]\n                               (contains? vn (e 1)) [(e 0) v]\n                               :else e))\n                        g))]\n       (or (empty? g)\n         (= g #{[v v]})\n         (and (not (= g g'))\n              (connected? g')))))","user":"53ff8c31e4b0de5c41848603"},{"problem":91,"code":"(fn __ [graph]\n  (letfn [\n          (all-nodes [g]\n            (set (mapcat identity g)))\n\n          (has-way? [s d g] ; check graph whether s connected to d\n            (g [s d]))\n\n          (all-ways [grf]\n            (loop [g grf]\n              (let [ng\n                    (into g\n                          (for [[a b] g\n                                [c d] g\n                                :when (= b c)]\n                            [a d]))]\n                (if (= ng g) g\n                    (recur ng)))))\n\n          (connected? [nodes g]\n            (every? boolean\n                  (for [n nodes\n                        d nodes]\n                    (has-way? n d (all-ways (into g (map reverse g)))))))\n          ]\n    (connected? (all-nodes graph) graph)))","user":"5a0ce1a5e4b04bbd27e6d9b7"},{"problem":91,"code":"(fn [graph]\n  (let [adjacent-nodes (apply merge-with into {}\n                     (mapcat (fn [[x y]] (vector {x [y]} {y [x]})) graph))\n        all-nodes (set (keys adjacent-nodes))\n        [[first-node]] (seq graph)]\n    (letfn [(paint [painted node]\n                (let [adjs (adjacent-nodes node)]\n                  (if (painted node)\n                    painted\n                    (reduce paint (conj painted node) adjs))))]\n  (= all-nodes (paint #{} first-node)))))","user":"605b7a90e4b079a07f8593fc"},{"code":"(fn [graph]\n  (let [nodes (set (flatten (seq graph)))\n        in? (fn [seq elm] (some #(= elm %) seq))\n        neighbors (fn [n] (map (fn [[a b]] (if (= a n) b a)) (filter #(in? % n) graph)))\n        unvisited (fn [visisted n] (filter #(not (contains? visisted %)) (neighbors n)))]\n    (loop [visited #{} component #{} queue [(first nodes)]]\n      (if (empty? queue)\n        (= component nodes)\n        (recur\n         (conj visited (peek queue))\n         (conj component (peek queue))\n         (into (pop queue) (unvisited visited (peek queue))))))))","problem":91,"user":"5201ada5e4b0b2e020a18f14"},{"code":"(fn [edges]\n  (loop [ [n & ns] (map set edges)]\n    (or (empty? ns)\n      (let [\n        nns \n        (map #(reduce conj n %) ns)\n        isect \n        (map #(< (count %) (+ (count %2) (count n)))\n          nns ns)\n      ]\n      (and (not-every? false? isect)\n        (recur (map #(if %1 %2 %3) isect nns ns)))))))","problem":91,"user":"50901b2ee4b0ea685a20f774"},{"problem":91,"code":"(fn [set-of-tuples]\n    (letfn [(make-graph [ts]\n              (loop [m {}\n                     ts ts]\n                (if (seq ts)\n                  (let [[x y] (first ts)\n                        m'  (assoc m  x (conj (or (m  x) []) y))\n                        m'' (assoc m' y (conj (or (m' y) []) x))]\n                    (recur m''\n                           (rest ts)))\n                  m)))\n            (depth-first-traversal\n              [graph start]\n              (loop [result  [start]\n                     visited #{start}\n                     stack   (list start)]\n                (if (empty? stack)\n                  result\n                  (let [next (first (sort (remove visited (graph (peek stack)))))]\n                    (if next\n                      (recur (conj result next) (conj visited next) (conj stack next))\n                      (recur result visited (pop stack))\n                      )))))\n            (has-chain?\n              []\n              (let [g (make-graph set-of-tuples)\n                    vertices (reduce into #{} set-of-tuples)\n                    num (count vertices)\n                    paths (map #(depth-first-traversal g %)\n                               (map first set-of-tuples))\n                    pass #(= num (count %))]\n                (if (some pass paths)\n                  true\n                  false)\n                ))]\n      (has-chain?)))","user":"52485f02e4b05ef8e38e63d3"},{"problem":91,"code":"(fn [tuples]\n  (let [G (group-by first tuples)\n        root (ffirst G)\n        ;; Run DFS on the graph G, if we see all nodes in the graph, then\n        ;; it is connected, otherwise not.\n        nodes (loop [discovered #{root}, processing [root], nodes #{}]\n                (if (empty? processing)\n                  nodes\n                  (let [v (peek processing), neighbors (map peek (G v))]\n                    (recur\n                      (into discovered neighbors) \n                      (into (pop processing) (remove discovered neighbors))\n                      (conj nodes v)))))]\n    ;; Compare the number of distinct nodes in the tuple set to the number\n    ;; of nodes that we have seen in our traversal.\n    (= (count (reduce into #{} tuples))\n       (count nodes))))","user":"5b772ad7e4b047b03b2036e8"},{"problem":91,"code":"(fn [edges]\n        (let [create-graph (fn [edges]\n                             (reduce (fn [m [x1 x2]]\n                  (-> m\n                      (update-in [x1] (fnil conj []) x2)\n                      (update-in [x2] (fnil conj []) x1))) {} edges))\n              bfs (fn [graph start]\n                    (loop [queue [start] visited (into {} (map (fn [[k]] [k false]) graph)) trail []]\n          (let [[verge & queue] queue\n                edges (graph verge)]\n            (if verge\n              (recur (if-not (visited verge) (into (vec queue) edges) (vec queue)) (assoc visited verge true) (if-not (visited verge) (conj trail verge) trail))\n              trail))))\n              connected (fn [graph start end]\n                          (println \"bfs=\" (bfs graph start))\n                          (some #{end} (bfs graph start)))\n              cart-prod (fn [s]\n                          (loop [s s result []]\n          (let [[head & tail] s]\n            (if-not tail\n              result\n              (recur tail (into result (map (fn [x] [head x]) tail)))))))\n              graph (create-graph edges)]\n          (= (count (filter (comp not identity) (map (fn [[v1 v2]] (connected graph v1 v2))\n                                                   (cart-prod (keys graph)))))\n           0)))","user":"58949f8de4b00487982d525e"},{"code":"(fn connected? [graph] \n  (= (-> graph seq flatten set)\n     (nth (iterate\n           #(set\n             (flatten\n              (for [edge graph]\n                (if (or (-> edge second %)\n                        (-> edge first %))\n                  edge))))\n                  #{(-> graph first first)})\n          (count graph))))","problem":91,"user":"532ab0bde4b09d4e7a9b5527"},{"code":"(fn [l]\r\n  (letfn [(flatten [l]\r\n            (set (apply concat l)))\r\n          (flood-fill-1 [l ptlist]\r\n            (set\r\n             (concat ptlist\r\n                     (mapcat (fn [pt]\r\n                               (mapcat (fn [e]\r\n                                         (cond\r\n                                          (= pt (first e)) (list (second e))\r\n                                          (= pt (second e)) (list (first e))\r\n                                          :else ())) l)) ptlist))))\r\n          (flood-fill [l ptlist]\r\n            (let [newlist (set (flood-fill-1 l ptlist))]\r\n              (if (= (set ptlist) newlist)\r\n                newlist\r\n                (recur l newlist))))\r\n          ]\r\n    (if (empty? l)\r\n      ()\r\n      (= (flatten l)\r\n         (flood-fill l (list (first (first l))))))\r\n    )\r\n  )","problem":91,"user":"4f474f43e4b0d56e7bb92bb7"},{"problem":91,"code":"(letfn [(add-to-edge-set [edge-sets a b]\n          (assoc edge-sets a (conj (or (edge-sets a) #{}) b)))\n        (edge-tuples->edge-sets [tuples]\n          (reduce (fn [result [a b]]\n                    (add-to-edge-set (add-to-edge-set result a b)\n                                     b a))\n                  {} tuples))\n        (reachable-from [edge-sets node seen-nodes]\n          (if (contains? seen-nodes node)\n            seen-nodes\n            (apply clojure.set/union seen-nodes\n                   (map #(reachable-from edge-sets % (conj seen-nodes node))\n                        (edge-sets node)))))]\n  (fn [edge-tuples]\n    (let [edge-sets (edge-tuples->edge-sets edge-tuples)\n          nodes (set (flatten (vec edge-tuples)))]\n      (= nodes (reachable-from edge-sets (first nodes) #{})))))","user":"563f1493e4b08d4f616f5ecf"},{"code":"(fn [coll]\n  (let [n (count (set (reduce concat coll)))]\n\t\t(loop [c1 #{} c2 #{(first (first coll))}]\n\t\t\t (if (= c1 c2)\n\t\t\t\t (= (count c1) n)\n\t\t\t\t (recur c2\n\t\t\t\t\t(clojure.set/union c2\n\t\t\t\t\t\t\t   (set (reduce concat\n\t\t\t\t\t\t\t\t\t(map (fn [x]\n\t\t\t\t\t\t\t\t\t       (map second (filter (fn [y] (= (first y) x)) coll)))\n\t\t\t\t\t\t\t\t\t     c2)))))))))","problem":91,"user":"4e14108c535d04ed9115e7dd"},{"code":"(fn [graph]\n  ; basically transitive closure from prob #84 (but starting with bidirectional adjacency \"matrix\")\n  (let [union (fn [s1 s2] (reduce #(conj % %2) s1 s2))\n        add-adjacencies (fn [adjm [a b]] (assoc (assoc adjm a (conj (adjm a) b)) b (conj (adjm b) a)))\n        adjm (reduce add-adjacencies (zipmap (reduce concat [] graph) (repeat #{})) graph)\n        warshall-step (fn [adjm [i j]]\n                        (if (contains? (adjm i) j)\n                          (assoc adjm i (union (adjm i) (adjm j)))\n                          adjm))\n        tc-adjm  (reduce warshall-step adjm (for [j (keys adjm) i (keys adjm)] [i j]))\n        reachables (vals tc-adjm)\n        ]\n    (not= nil (reduce #(if (= % %2) %) (first reachables) reachables))))","problem":91,"user":"52015698e4b0d7096e99ddba"},{"problem":91,"code":"(fn [edges]\n   (letfn [(f [graphs edge]\n             (let [connects #(not-empty (clojure.set/intersection % edge))\n                   g #(if (connects %)\n                        (clojure.set/union % edge)\n                        %)]\n               (if (some connects graphs)\n                 (mapv g graphs)\n                 (conj graphs edge))))]\n     (loop [graphs (map set edges)]\n       (let [merged (reduce f [] graphs)]\n         (if (= merged graphs)\n           (= (count merged) 1)\n           (recur merged))))))","user":"5e3ef7d4e4b01d43a70e8e2d"},{"code":"(fn fully-connected? [graph]\n  (let [nodes (set (apply concat graph))\n        full-graph (set (mapcat (fn [[a b :as n]] [n [b a]]) graph))\n        children (into {} (for [[k v] (group-by first full-graph)] [k (set (map second v))]))\n        connections (fn [node]\n                      (->> (iterate #(into % (mapcat children %)) #{node})\n                           (partition 2 1)\n                           (filter #(apply = %))\n                           first first))]\n    (every? #(= % nodes) (map connections nodes))))","problem":91,"user":"5032b066e4b00c0952a257ea"},{"problem":91,"code":"(fn is-connected\n\t[graph]\n\t(let [\n\t\ttransform-graph \n\t\t\t(fn [graph]\n\t\t\t\t(reduce\n\t\t\t\t\t(fn [result [x y]] (assoc result x (conj (result x) y) y (conj (result y) x)))\n\t\t\t\t\t(zipmap (distinct (flatten graph)) (repeat []))\n\t\t\t\t\tgraph))\n\t\ttransformed (transform-graph graph)\n\t\tvertices (keys transformed)]\n\t\t(loop [stack (vector (first vertices)) visited #{}]\n\t\t\t(if (empty? stack)\n\t\t\t\t(= visited (into #{} vertices))\n\t\t\t\t(let [v (peek stack) neighbors (transformed v) restStack (pop stack)]\n\t\t\t\t\t(if (visited v)\n\t\t\t\t\t\t(recur restStack visited)\n\t\t\t\t\t\t(recur (reduce #(conj %1 %2) restStack neighbors) (conj visited v))))))))","user":"58fb7d7ae4b0438e51c2cf7a"},{"code":"(fn [edges]\n    (let [all-nodes (set (mapcat identity edges))]\n      (loop [seen #{(ffirst edges)}]\n        (if (= seen all-nodes)\n          true\n          (let [next-seen (into seen (mapcat (fn [node]\n                                               (keep (fn [[a b]]\n                                                       (cond\n                                                        (= a node) b\n                                                        (= b node) a)) edges)) seen))]\n            (if (= seen next-seen)\n              false\n              (recur next-seen)))))))","problem":91,"user":"4e6a0667535d8ccf87e9fe9e"},{"code":"(fn [g]\n  (letfn [(get-nodes [s]\n            (distinct (flatten (vec s))))\n          (get-vertices [n s]\n            (set (remove nil? (map (fn [x] (if (some #(= n %) x) x)) s))))]\n    (letfn [(follow-path \n              [s n]\n              (get-nodes (get-vertices n s)))]\n      (loop [nodes (get-nodes g)\n             traversed (follow-path g (first (get-nodes g)))]\n        ; (println (str (set nodes) \" \" (set traversed)))\n        (if (or (empty? nodes) (clojure.set/subset? (set (mapcat (partial follow-path g) traversed)) (set traversed)))\n            (= (set (get-nodes g)) (set traversed))\n          (let [nodes (clojure.set/difference (set nodes) (set traversed))]\n            (recur nodes (into traversed (set (mapcat (partial follow-path g) traversed))))\n              ))))))","problem":91,"user":"50843a4ae4b0c98812d0788b"},{"problem":91,"code":"(fn [s]\n  (letfn [(merge [u v]\n            (if (empty? (clojure.set/intersection u (set v)))\n              u\n              (clojure.set/union u (set v))))]\n    (loop [acc (set (first s)) edges (rest s)]\n      (let [newacc (set (reduce merge acc edges))\n            newedges (remove #(clojure.set/subset? % newacc) edges)]\n        (if (= newacc acc)\n          (empty? edges)\n          (recur newacc newedges))))))","user":"58a0fc33e4b02bd94d917ea3"},{"code":"#(loop [n (into #{} (first %)) e %] (if (empty? e) true\r\n (let [v (some (fn [[a b]] (and (or (n a) (n b)) [a b])) e)]\r\n  (if v (recur (apply (partial conj n) v) (disj e v)) false))))","problem":91,"user":"4fca2ef0e4b0ee37620e184e"},{"problem":91,"code":"(fn [lst]\n  (loop [s (into [] lst) d [] prev (into [] lst)]\n    (if (empty? s) (if (= d ((fn [process]\n                               (loop [s (into [] process) d []]\n                                 (if (empty? s) d\n                                   (recur (rest s) (conj d (into #{} (first s))))))) prev)) ((fn [vec test]\n                                                                                                (loop [c 0]\n                                                                                                  (if (= c (count vec)) false\n                                                                                                    (if (= (nth vec c) test) true\n                                                                                                      (recur (inc c)))))) d (apply clojure.set/union ((fn [process]\n                                                                                                                                                        (loop [s (into [] process) d []]\n                                                                                                                                                          (if (empty? s) d\n                                                                                                                                                            (recur (rest s) (conj d (into #{} (first s))))))) lst)))\n                     (recur d [] d))\n      (recur (rest s) ((fn [vecSet vec]\n                         (loop [c 0 c2 0]\n                           (if (= (count vecSet) c) (if (= 1 c2) (conj vecSet (into #{} vec))\n                                                      (recur 0 (inc c2)))\n                             (if (= 0 c2) (if (contains? (nth vecSet c) (first vec)) (into [] (concat (take c vecSet) [(clojure.set/union (nth vecSet c) (into #{} vec))] (nthrest vecSet (+ c 1)))) (recur (inc c) c2))\n                               (if (contains? (nth vecSet c) (second vec)) (into [] (concat (take c vecSet) [(clojure.set/union (nth vecSet c) (into #{} vec))] (nthrest vecSet (+ c 1)))) (recur (inc c) c2)))))) d (first s)) prev))))","user":"558378dce4b05c286339e115"},{"code":"(fn connected? [es]\n    (let [nodes (set (flatten (seq es)))\n\n          adjacent (fn adjacent [connected es]\n                     (for [[l r] es :when (or (connected l) (connected r))] [l r]))\n\n          connect (fn connect\n                    ([es] (connect (hash-set (first nodes)) es))\n                    ([connected es]\n                     (let [moves (adjacent connected es)]\n                       (cond\n                         (empty? es)\n                         connected\n                         (not (empty? moves))\n                         (connect (into connected (flatten moves)) (clojure.set/difference es (set moves)))))))]\n          (not (nil? (connect es)))))","problem":91,"user":"5370ef22e4b0fc7073fd6ea0"},{"code":"(fn [s] (let [t (#(let [n (apply conj %\n            (for [[a b] %\n                  [c d] %\n                  :when (= b c)]\n              [a d]))]\n    (if (= n %)\n      %\n      (recur n))\n  ) (apply conj s (map reverse s)))\n  q (distinct (flatten (vec t)))\n  k (count q)\n  f (first (sort q))]\n\n  (< (- k 1) (count\n    (filter #(= (second %) f)\n      (vec t))))))","problem":91,"user":"4f01c938535dcb61093f6a39"},{"problem":91,"code":"(fn [g]\n    (let [nodes (into #{} (flatten (into [] g)))\n          d-edges\n          (->> (mapcat (juxt (juxt first second) (juxt second first)) g)\n               (group-by first)\n               (map (fn [[k v]] [k (map second v)]))\n               (into {}))]\n      (loop [visited (get d-edges (first nodes))\n             n 0]\n        (cond\n          (> n (count nodes)) false\n          (= visited nodes) true\n          :default (recur (set (concat visited (remove nil? (mapcat #(get d-edges %) visited))))\n                          (inc n))))))","user":"59419bdfe4b060784b3b78f7"},{"problem":91,"code":"(fn [g]\n  (letfn [(f [m x]\n            (if (m x)\n              (recur m (m x))\n              x))\n          (u [m [x y]]\n                 (let [x (f m x)\n                       y (f m y)]\n                   (if (= x y)\n                     m\n                     (assoc m x y))))]\n    (->> g (reduce u {}) (#(for [[k v] %] (f % k))) distinct next empty?)))","user":"5953bdb6e4b066ee0a44aeed"},{"problem":91,"code":"(fn connected? [graph]\n  (let [edges (into graph (map reverse graph))\n        edge-map (group-by first edges)\n        nodes (set (keys edge-map))\n        traverse (fn traverse [visited node]\n                   (if (contains? visited node)\n                     []\n                     (into #{node} \n                           (mapcat #(traverse (conj visited node) (second %)) (edge-map node)))))]\n    (= nodes (traverse #{} (first nodes)))))","user":"54b54d1be4b05787c3b1639c"},{"code":"(letfn [(intersects? [s1 s2]\n          (not (empty? (clojure.set/intersection (set s1) (set s2)))))]\n  (fn connected? [g]\n    (= 1\n       (count\n         (reduce (fn [subgroups e]\n                   (prn subgroups e)\n                   (conj\n                     (remove (partial intersects? e) subgroups)\n                     (set (apply concat (filter (partial intersects? e) subgroups)))))\n                 (map list (set (flatten (seq g))))\n                 g)))))","problem":91,"user":"50b668dde4b08fb537db98f2"},{"problem":91,"code":"(fn [edges]\n    (let [nodes (into #{} (concat (map first edges) (map second edges)))\n          connections (->> (concat edges (map reverse edges))\n                           (group-by first)\n                           (map (fn [[k v]] [k (map second v)]))\n                           (into {}))]\n      (loop [to-visit (into #{} (take 1 nodes)) visited #{}]\n        (if (seq to-visit)\n          (let [head (first to-visit)\n                remaining (disj to-visit head)\n                remaining (->> (connections head)\n                               (remove visited)\n                               (into remaining))]\n            (recur remaining (conj visited head)))\n          (= visited nodes)))))","user":"530b8580e4b02e82168697cc"},{"problem":91,"code":"(fn [edges]\n  (let [count= (fn [& colls] (apply = (map count colls)))\n        maps (mapcat\n               (fn [[u v]] (if (= u v) [{u [v]}] [{u [v]} {v [u]}])) edges)\n        adj-tab (apply merge-with concat maps)\n        nodes (keys adj-tab)\n        ccomp (fn [vs]\n                (let [vs' (into vs (apply concat (map #(adj-tab %) vs)))]\n                  (if (count= vs vs') vs (recur vs'))))]\n    (count= (ccomp #{(first nodes)}) nodes)))","user":"508157b2e4b0946d0443855c"},{"problem":91,"code":"(fn [s]\n  (let [rec-conn (fn [[s1 s2]]\n                   (vector (set (flatten (filter #(some s1 %) s2))) (filter #(not (some s1 %)) s2)))\n        result (drop-while #(not (empty? (first %))) (iterate rec-conn  [(set (first s)) (rest s)]))]\n    (empty? (second (first result)))))","user":"590b055ae4b047aa04b199c9"},{"code":"(fn [g] \n     (= (into #{} (flatten (vec g)))\n        (nth (iterate #(into #{} (flatten (for [e g] (if (or (% (e 0)) (% (e 1))) e)))) #{((first g) 0)}) (count g))))","problem":91,"user":"527ec801e4b0757a1b1713b3"},{"code":"(fn [v]\n    (let [  g-assoc (fn [m k v] (assoc m k (set (conj (m k) v))))\n            g (reduce (fn [m [a b]] (g-assoc (g-assoc m a b) b a)) {} v)]\n    ((fn [m1 m2]\n           (if (= m1 m2)\n                (if (= (set (keys m1)) (second (first m1)))\n                    true\n                    false)\n                (recur \n                    m2\n                    (reduce (fn [m [k kv]] \n                        (let [ch (mapcat m kv)]\n                            (println ch)\n                            (reduce #(g-assoc %1 k %2) m ch)))\n                        m2 m2))\n                ))\n        {} g)\n        ))","problem":91,"user":"51f59607e4b0abb92f97f9d5"},{"code":"(fn [s]\n  (empty? \n    ((fn f [e p]\n       (let [p (disj p e)\n             es (remove #(apply distinct? (concat e %)) p)]\n         (reduce #(f %2 %) p es))) (first s) s)))","problem":91,"user":"4fa30027e4b081705acca187"},{"problem":91,"code":"(fn [graph]\n  (let [conn (fn [coll nodes]\n               (reduce\n                (fn [[c n] [h t]] (if (or (c h) (c t)) [(conj c h t) n] [c (conj n [h t])]))\n                [coll #{}]\n                nodes))\n        [coll nodes] (conn (set (first graph)) graph)]\n    (loop [coll (set (first graph))\n           nodes graph\n           n (count graph)]\n      (or (zero? n)\n          (let [[coll nodes] (conn coll nodes)]\n            (if (= (count nodes) n)\n              false\n              (recur coll nodes (count nodes))))))))","user":"51852961e4b0da5a5be3babb"},{"problem":91,"code":"(fn [edges]\n          (let [verts  (set (flatten (seq edges)))\n                node   (first verts)\n                expand (fn [nodes edges]\n                         (into (set nodes)\n                               (mapcat\n                                (fn [node]\n                                  (remove nil?\n                                          (map\n                                           (fn [edge]\n                                             (cond\n                                               (= node (first edge)) (second edge)\n                                               (= node (second edge)) (first edge)\n                                               ))\n                                           edges)))\n                                nodes)))]\n           (loop [nodes #{node}]\n             (println [nodes verts (expand nodes edges)])\n             (let [newnodes (expand nodes edges)]\n               (cond\n                 (= newnodes verts) true\n                 (= newnodes nodes) false\n                 :else              (recur newnodes)))\n             )\n           ))","user":"500d3160e4b05f7c30cfa6a1"},{"code":"(fn [g]\n  (apply =\n         (vals\n           (reduce\n             (fn [m [a b]]\n               (merge-with clojure.set/union m\n                           (let [all (clojure.set/union (get m a #{a}) (get m b #{b}))]\n                             (reduce #(assoc % %2 all) {} all))))\n             {} g))))","problem":91,"user":"50bfe95ce4b080409b860f27"},{"problem":91,"code":"(fn [coll]\n  (->> (iterate\n          (fn [[a b]]\n            (let [r (filter #((complement empty?) (clojure.set/intersection b (set %))) a)]\n              [(apply disj a r) (apply clojure.set/union b (map set r))]))\n          [(disj coll (first coll)) (set (first coll))])\n         (take (count coll))\n         (last)\n         (first)\n         (empty?)))","user":"58ca8a1de4b03c36ff7e5835"},{"code":"(fn graph-connect2 [s]\n  (cond\n   (empty? s) true\n   (= (count s) 1) true\n   :else\n   (letfn [(filter-intersections [s1 s2]\n             (loop [matched s1 to-match s2 unmatched #{}]\n               (cond\n                (empty? to-match) [matched unmatched]\n                (> (count (clojure.set/intersection s1 (set (first to-match)))) 0) (recur (clojure.set/union matched\n                                                                                             (first to-match))\n                                                                                  (rest to-match)\n                                                                                  unmatched)\n                :else\n                (recur matched (rest to-match) (conj unmatched (first to-match))))))\n           (flatten-set-of-pairs [s]\n             (loop [s s acc #{}]\n               (cond\n                (empty? s) acc\n                :else\n                (let [[x y] (first s)]\n                  (recur (rest s) (conj acc x y))))))]\n     (loop [from (first s)\n            to (rest s)]\n       (cond\n        (empty? to) (if (empty? (clojure.set/difference (flatten-set-of-pairs s) from))\n                     true false)\n        :else\n        (let [[pass _] (filter-intersections (set from) to)]\n          (recur pass (rest to))))))))","problem":91,"user":"4fd16778e4b04c3a95aa040f"},{"problem":91,"code":"(fn [g](let [looped (group-by #(= (first %)(second %)) g)\n             loops  (looped true)\n             edges  (map #(sort %) (looped false))\n             points (partial reduce into #{})\n             all    (count (points g))\n             check  #(= (- all 1) (count (distinct (map % edges))))]\n        (if (= 1 all) true \n          (and (every? (points edges) (points loops)) ;; points with loops connected with others \n               (or (check first)\n                   (check second))\n          )))\n)","user":"526a3412e4b03e8d9a4a721e"},{"code":"(fn graph-connect [nodes]\n  (letfn [(numnodes [nodes] (count (set (reduce concat nodes))))\n          (to-node-map [nodes]\n            ((fn !  [nodes node-map]\n               (if-let [n (seq nodes)]\n                 (let [[key val] (first n)]\n                   (if (contains? node-map key)\n                     (! (rest n) (assoc node-map  key (conj (node-map key) val)))\n                     (! (rest n) (assoc node-map key [val]))\n                     )\n                   )\n                 node-map)\n               ) (concat nodes (map #(reverse %) nodes)) {}))\n          (search [node node-map visited]\n            (if (or (contains? visited  node) (empty? (node-map node)))\n              visited\n              (set (mapcat #(search % node-map (conj visited node)) (node-map node)))\n              )\n            )]\n    (let [N (numnodes nodes)\n          node-map (to-node-map nodes)\n          searched-nodes (search (ffirst nodes) node-map #{})]\n      (= N (count searched-nodes)))))","problem":91,"user":"4f1d1299535d64f603146487"},{"problem":91,"code":"#(let [graph (concat % (map reverse %))]\n  (letfn [\n          (followers[node nodes]\n          \"return all edges directly connected with node which are in the given set of nodes\"\n            (for [[a b] graph :when(and (= node a) (not (nil? (nodes b))))] b)\n          )\n          \n          (connected [foll nodes graph]\n          \"test if the graph is connected\"\n            (loop [succ foll ret nodes]\n              (if (or (empty? succ) (empty? ret) (nil? (some ret succ)))\n                ret\n                (let [nd (first succ) succ-of-node (followers nd nodes)]\n                  (recur\n                   (distinct (concat (rest succ) succ-of-node (followers nd ret)))\n                   (set (remove (fn[x](= nd x)) ret))\n                  )\n                )\n              )\n            )\n          )\n         ]\n\n    (let [\n          nodes (reduce (fn[cset [a b]] (conj cset a b)) #{} %)\n          succ (followers (first nodes) (set (rest nodes)))\n          res (connected succ nodes graph)\n         ]\n      (or (= (count nodes) 1) (empty?  res))\n    )\n  )\n)","user":"545537c1e4b0e397800069dd"},{"code":"(fn [g]\n  (let [\n    f first\n    d (fn r [c v]\n        (if (v c) v\n          (reduce\n            #(r (second %2) (r (f %2) %1))\n            (conj v c)(filter #((set %) c) g))))\n                  v (mapcat (fn [n] n) g)\n                  ]\n                  (=\n                    (d (f v) #{})\n                    (set v))))","problem":91,"user":"500d1db4e4b05f7c30cfa69f"},{"code":"(fn [edges]\n  (loop [[e & stack] (take 1 edges)\n         unseen-nodes (set (mapcat identity edges))\n         unprocessed-edges (disj edges e)]\n    (cond (empty? unseen-nodes) true\n          (nil? e) false\n          :else (recur (concat (filter (fn [e2] (not-empty\n                                                  (clojure.set/intersection (set e2) (set e))))\n                                       unprocessed-edges)\n                               stack)\n                       (disj unseen-nodes (first e) (second e))\n                       (disj unprocessed-edges e)))))","problem":91,"user":"510acd6ee4b078ea719210f4"},{"code":"(fn [ls]\n  (letfn [(c [x cs] (first (filter #(% x) cs)))]\n    (->\n     (reduce\n      (fn [cs [a b]]\n        (let [ac (c a cs) bc (c b cs)]\n          (conj\n           (disj cs ac bc)\n           (set (concat ac bc [a b])))))\n      #{} ls)\n     count (= 1))))","problem":91,"user":"4f06dcad535dcb61093f6c16"},{"code":"#(= ((fn [s0 es] (let [[m red] (reduce (fn step[[m s] e] (let [intr (keep s e)] (if-not (or (empty? intr) (= intr e)) [true (into s e)] [m s]))) [false s0] es)] (if m (recur red es) red))) (set (first %)) %) (set (flatten (seq %))))","problem":91,"user":"4e7f4147535db966e863cc3d"},{"code":"(fn [edges]\n  (let [all-nodes (set (apply concat edges))\n        start-node (ffirst edges)\n        edge-matcher (fn [vertex] #(some #{vertex} %))\n        matching-edges (fn [vertex edges]\n                         (set (filter\n                               (edge-matcher vertex)\n                               edges)))\n        next-vertex (fn [current-vertex [x y]]\n                      (if (= current-vertex x) y x))\n        can-expand? (fn [[vertex edges]]\n                     (some (edge-matcher vertex) edges))\n        get-children (fn [[vertex edges]]\n                       (map (fn [edge]\n                              [(next-vertex vertex edge) (disj edges edge)])\n                            (matching-edges vertex edges)))]\n    (= all-nodes\n        (set\n         (map first\n              (tree-seq can-expand? get-children [start-node edges]))))))","problem":91,"user":"4e6f578c535d5021c1a8961b"},{"problem":91,"code":"(fn connectivity [edges]\n  (loop [removed #{(first edges)}\n         not-visited (set (rest edges))]\n    (let [\n          neighbors (set (for [edge not-visited\n                          :when \n                          (not (empty? \n                            (clojure.set/intersection\n                              (set (flatten (vec removed)))\n                              (set edge)\n                            )\n                          ))]\n                      edge\n                    ))\n         ]\n        (cond\n          (and (empty? neighbors) (zero? (count not-visited))) true\n          (empty? neighbors) false\n          :else\n            (recur neighbors (clojure.set/difference not-visited neighbors))\n        )\n    )\n  )\n)","user":"5991d2fae4b0866487ed0d68"},{"code":"(fn p91 [orig-edges]\n  (loop [known (set (first orig-edges))\n\t\t   edges (next orig-edges)]\n\t\t(if (empty? edges)\n\t\t\ttrue\n\t\t\t(let [connecting-edges (filter #(some known %) edges)]\n\t\t\t\t(if (empty? connecting-edges)\n\t\t\t\t\tfalse\n\t\t\t\t\t(recur (reduce conj known (flatten connecting-edges))\n\t\t\t\t\t\t   (remove (set connecting-edges) edges)))))))","problem":91,"user":"4f7f0827e4b06e829148e1d5"},{"code":"(fn [g]\n  (let [\n    f first\n    d (fn r [c v] \n        (if (v c) v\n          (reduce \n            #(r (second %2) (r (f %2) %1)) \n            (conj v c) \n            (filter #((set %) c) g))))\n    v (mapcat (fn [n] n) g)\n    ] \n    (= \n      (d (f v) #{}) \n      (set v))))","problem":91,"user":"4e5c801e535d8a8b8723a2c1"},{"code":"(fn connected? [ss]\n  (or (<= (count ss) 1)\n      (letfn [(find-connect [node nodes]\n                (let [[x y] node]\n                  (into #{node}\n                        (for [[x' y'] nodes\n                              :when (or (= x y') (= y x') (= x' x))\n                              ]\n                          [x' y']))))\n              (connect? [ns1 ns2]\n                (if (empty? ns2)\n                  true\n                  (let [ns1' (reduce (fn [an s]\n                                   (clojure.set/union\n                                    (find-connect s ns2) an)) #{} ns1)\n                    ns2' (clojure.set/difference ns2 ns1')\n                        ]\n                    (if (= ns1 ns1')\n                      false\n                      (connect? ns1' ns2')))))\n              ]\n        (connect? #{(first ss)} ss))))","problem":91,"user":"4dd62278535d2dad7130b5c7"},{"problem":91,"code":"#(let [x (group-by first (concat % (map reverse %)))]\n   (loop [s #{(first (keys x))}]\n     (let [t (reduce (fn [s n]\n                       (into s (map second (x n))))\n                     s s)]\n       (cond (= (count t) (count x)) true\n             (= s t) false\n             :else (recur t)))))","user":"50ed4626e4b01236b1d4983c"},{"code":"(fn [gr]\n  ((fn con [s1 s2]\n    (if (empty? s2) true\n      (let [adj? (fn [[s1 e1] [s2 e2]] (or (= s1 s2) (= s1 e2) (= e1 s2) (= e1 e2)))\n            adjs (group-by #(reduce (fn [e1 e2] (or e1 (adj? % e2))) false s1) s2)]\n        (if (empty? (adjs true)) false\n          (con (into s1 (adjs true)) (adjs false)))))) #{(first gr)} (rest gr)))","problem":91,"user":"505dcfc8e4b0e6aca564be0d"},{"problem":91,"code":"(fn [edges]\n  (letfn [(getij [cm i j] (nth (nth cm i) j))\n          (setij [cm i j newv] (assoc (vec cm) i (assoc (vec (nth cm i)) j newv)))\n          (markcon [cm i j] (setij (setij cm i j 1) j i 1))]\n    (let [vedges (vec edges)\n          nodes (distinct (flatten (seq edges)))\n          n (count nodes)\n          nindexmap (zipmap nodes (range n))\n          startm0 (map #(assoc (vec (repeat n -1)) % 1) (range n))\n    \t  startm (reduce (fn [mat edge] \n                           (let [i (nindexmap (first edge)) j (nindexmap (second edge))]\n                             (markcon mat i j))) startm0 vedges)\n          endm (reduce (fn [mat [k i j]] \n                         (if (and (not= -1 (getij mat k i)) (not= -1 (getij mat k j))) \n                           (markcon mat i j) mat))\n                       startm (for [k (range n) i (range n) j (range n)] [k i j]))]\n      (empty? (filter #(= % -1) (first endm)))\n      )))","user":"52faec2ee4b047fd55837004"},{"problem":91,"code":"(fn [xs]\n  (letfn [(prod [[x1 x2 :as xs] [y1 y2 :as ys]]\n            (if (or (= x1 y1) (= x1 y2) (= x2 y1) (= x2 y2))\n              (apply concat (for [x xs y ys] [[x y] [y x] [x x] [y y]])) #{}))\n          (step [xs]\n            (set (apply concat (for [x xs y xs] (prod x y)))))\n          (trans [xs]\n            (loop [n xs n+ (step xs)]\n              (if (= n n+) n\n                  (recur n+ (step n+)))))\n          (expect [xs]\n            (let [ns (set (apply concat xs)) s (count ns)] (* s s)))]\n    (= (expect xs) (count (trans xs)))))","user":"53ef7f77e4b0742d9025b0ce"},{"problem":91,"code":"(fn connected-graph? [graph]\n  (letfn [(connected-edge? [n e]\n            (or (= (first e) n) (= (second e) n)))\n          (follow [n e not-visited graph]\n            (let [next-node (if (= n (first e)) (second e) (first e))]\n              (list next-node (disj not-visited next-node) (disj graph e))\n              )\n            )\n          (visited-all? [n not-visited graph]\n            (let [connected-edges (filter #(connected-edge? n %) graph)]\n              (cond (empty? not-visited) true\n                    (empty? graph) false\n                    (empty? connected-edges) false\n                    :else (some true? (map (fn [e]\n                                             (apply visited-all? (follow n e not-visited graph)))\n                                           connected-edges)))\n              )\n            )\n          ]\n    (let [nodes (reduce #(into %1 %2) #{} graph)\n          fn (first nodes)]\n      (boolean (visited-all? fn (disj nodes fn) graph))\n      )\n    )\n  )","user":"589037b4e4b00487982d51d0"},{"code":"(fn[kanten-seq]\n  (letfn[\n    (adja-map[kanten-seq]\n      (let [dup (into kanten-seq (map (fn[[k v]] [v k]) kanten-seq))]\n        (apply merge-with (fn[o n] (concat o n)) (map (fn[[k v]] (hash-map k [v])) dup))))\n    (zusammenhaengend? [kanten-seq]\n        (let [am (adja-map kanten-seq)\n              node-set (set (keys am))]\n          (loop [rn (set (val (first am)))\n                 rounds 1]\n            (if (= rn node-set)\n              true\n              (if (<= rounds (count node-set))\n                (let [next-rn (reduce into #{} (vals (select-keys am rn)))]\n                  (recur (into rn next-rn) (inc rounds)))\n                false)))))]\n  (zusammenhaengend? kanten-seq)))","problem":91,"user":"4e58bcd4535d8a8b8723a296"},{"code":"(fn is-graph-connected? [graph]\n  (letfn [(edge-has-node [node edge]\n            (or (= (first edge) node)\n                (= (second edge) node)))\n          (remove-node [node graph]\n            (filter #(not (edge-has-node node %)) graph))\n          (adjacent-nodes [node graph]\n            (map #(if (= node (first %))\n                    (second %)\n                    (first %)) (filter (partial edge-has-node node) graph)))\n          (nodes-connected? [n1 n2 current-node graph]\n            (if (= current-node n2)\n              true\n              (if (empty? graph)\n                false\n                (some true? (map #(nodes-connected? n1 n2 % (remove-node current-node graph))\n                                 (adjacent-nodes current-node graph))))))]\n    (let [distinct-nodes (distinct (flatten (map #(vector (first %) (second %)) graph)))]\n      (every? true? (map (fn [n1]\n                           (every? true? (map #(nodes-connected? n1 % n1 graph)\n                                              (remove #(= % n1) distinct-nodes))))\n                         distinct-nodes)))))","problem":91,"user":"4ff355a1e4b0678c553fc34d"},{"code":"(fn [pairs]\n    (let [all (set (mapcat identity pairs))\n          m (merge \n              (into {} (for [i all j all] [[i j] (if (= i j) 0 1)]))\n              (into {} (for [p pairs] [p 0]))\n              (into {} (for [p pairs] [(reverse p) 0])) )]\n      (->> (for [k all i all j all] [i j k])\n        (reduce\n          (fn [m [i j k]]\n            (update-in m [[i j]] min (+ (m [i k]) (m [k j]))))\n          m)\n        vals\n        (every? zero?)\n        )))","problem":91,"user":"4dbad895535d1e037afb21ae"},{"code":"(fn connected? [graph]\n  ; do transform input graph into the one where managing connections between nodes is much easier: {:x [:y :z], :y [:x], :z [:x]}\n  (let [g (apply merge-with #(vec (concat %1 %2)) \n                 (map #(conj {} [(first %) [(second %)]] [(second %) [(first %)]]) graph))]\n    (let [start-node (rand-nth (keys g)) ; start from any node, doesn't matter\n          visited  (atom #{})]\n      (letfn [(collect-all-connected-nodes [node]\n                (doseq [adjacent-node (get g node)]\n                  (when-not (contains? @visited adjacent-node)\n                    (swap! visited conj adjacent-node) ; update visited nodes so far\n                    (collect-all-connected-nodes adjacent-node))\n                  ))\n              ]\n        (collect-all-connected-nodes start-node))\n      (= (count @visited) (count (keys g)))) ; if we have visited all the nodes, then graph is connected\n    )\n  )","problem":91,"user":"5244a10de4b0d8acf9ed6ab3"},{"code":"(fn connected? \n  [edges]\n  (letfn [\n  \n    (vertice-count\n      [edges]\n      (->> \n        edges\n        (apply concat)\n        distinct\n        count))\n        \n    (full-bidirected-graph-count \n      [n]\n      (* n (- n 1)))\n      \n    (add-opposite-edges\n      [edges]\n      (concat edges (map (fn [[a b]] [b a]) edges)))\n      \n    (no-self-edges\n      [edges]\n      (filter (fn [[a b]] (not= a b)) edges))\n      \n    (distinct-edges\n      [edges]\n      (set edges))\n      \n    (try-find [[af as] set-of-pairs]\n      (reduce \n        (fn [found [bf bs]]\n          (cond\n            (not (nil? found)) found\n            (and (= af bs) (= bf as)) nil\n            (= af bs) (if (set-of-pairs [bf as]) nil [bf as])\n            (= bf as) (if (set-of-pairs [af bs]) nil [af bs])\n            :else nil))\n        nil\n        set-of-pairs))\n\n    (try-add [e set-of-pairs]\n      (let [found (try-find e set-of-pairs)]\n        (if \n          (nil? found) set-of-pairs\n          (conj set-of-pairs found))))\n        \n    (trans-clos-step [set-of-pairs]\n      (->> (map #(try-add %1 set-of-pairs) set-of-pairs) (apply clojure.set/union)))\n\n    (trans-clos [set-of-pairs]\n      (loop [this-set set-of-pairs]\n        (let [new-set (trans-clos-step this-set)]\n          (if\n            (= new-set this-set) this-set\n            (recur new-set)))))\n\n    ]\n    (let [\n      normalized-no-self-edges (no-self-edges edges)\n      \n      normalized\n        (->> \n          edges \n          no-self-edges \n          distinct-edges)\n        \n      normalized-bidirected \n        (->> \n          edges\n          no-self-edges \n          add-opposite-edges \n          distinct-edges)\n        \n      transitive-closure-normalized-bidirected\n        (->> \n          edges\n          no-self-edges \n          add-opposite-edges \n          distinct-edges\n          set\n          trans-clos\n          add-opposite-edges \n          no-self-edges \n          distinct-edges)\n      ]\n      (= (full-bidirected-graph-count (vertice-count edges))\n         (count transitive-closure-normalized-bidirected)))))","problem":91,"user":"5268eb68e4b03e8d9a4a71c6"},{"code":"(fn [g]\n  (let [a (set (flatten (seq g)))\n        f (first g)]\n    (loop [r (set f)]\n      (let [n (flatten (filter (fn[[a b]]\n                                 (or (and (r a) (not (r b)))\n                                     (and (r b) (not (r a))))) g))]\n        (if (empty? n)\n          (= r a)\n          (recur (set (concat r n ))))))))","problem":91,"user":"4e12cc9d535d04ed9115e7d2"},{"code":"(fn [t]\n  (let [g (reduce (fn [z [a b]] (merge-with concat z {a [b]} {b [a]})) {} t)\n        h (iterate #(into % (mapcat g %)) #{(ffirst t)})\n        [[a _] & _] (drop-while (fn [[a b]] (not= a b)) (map vector h (next h)))]\n      (== (count (keys g)) (count a))))","problem":91,"user":"4f08b15b535dcb61093f6c40"},{"code":"(fn grconn\r\n  ([edges] (grconn (set (first edges)) (set (rest edges))))\r\n  ([nds es]\r\n     (letfn [(conn? [e] (or (nds (first e)) (nds (second e)))),\r\n             (connpoint [e] (if (nds (first e)) (second e) (first e)))]\r\n       (cond (empty? es) true,\r\n             (empty? (filter conn? es)) false,\r\n             :else (recur (set (concat nds (map connpoint (filter conn? es))))\r\n                          (set (filter (complement conn?) es)))))))","problem":91,"user":"4f62b29ce4b0defedf855fd9"},{"code":"(fn [edges]\n  (letfn [(joint? [a b]\n            (not (empty? (clojure.set/intersection a b))))\n          (conj-edge [components edge]\n            (let [newcomp (set edge)\n                  {conn true, unconn false} (group-by #(joint? newcomp %) components)]\n              (conj unconn (apply clojure.set/union newcomp conn))))]\n  (->> edges\n    (reduce conj-edge [])\n    count\n    (= 1))))","problem":91,"user":"4f9d53f3e4b0dcca54ed6d21"},{"code":"(fn [s]\r\n  (let [o (set (apply concat (for [e s] (vector (first e) (second e)))))\r\n        m (zipmap o (range))\r\n        os (sort #(if (= (m (first %)) (m (first %2))) (< (m (second %)) (m (second %2))) (< (m (first %)) (m (first %2)))) s)]\r\n    (= o (clojure.set/intersection o \r\n                                   (reduce #(set (remove nil? (concat % (for [x %] (cond (= x (first %2)) (second %2)\r\n                                                                            (= x (second %2)) (first %2)))))) #{(ffirst os)} os)))))","problem":91,"user":"503354c3e4b0c6c1199c710c"},{"code":"(fn p91 [routes]\n  (letfn [(mks [ngs r]\n            (let [cs (filter (fn [ng] (some #(ng %) r)) ngs)\n                  th (reduce conj #{} r)]\n              (if (every? nil? cs) (conj ngs th)\n                          (conj (reduce disj ngs cs) (reduce conj #{} (reduce concat (conj cs th)))))))\n          (mkg [a n rs]\n            (if (empty? rs) n\n\t\t(mkg (reduce conj a (first rs)) (mks n (first rs)) (next rs) )))]\n    (= 1 (count (mkg #{} #{} routes)))))","problem":91,"user":"5272669de4b03e8d9a4a742e"},{"problem":91,"code":"#(loop [r #{(ffirst %)}]\n   (let [nr (reduce (fn [r a]\n                      (->> (filter (fn [[b c]] (or (= b a) (= c a))) %)\n                           flatten\n                           (into r)))\n                    r r)]\n     (if (= r nr)\n       (= r (set (flatten (seq %))))\n       (recur nr))))","user":"55201d18e4b08d5046aa8a5d"},{"code":"(fn connected-graph? [edges]\n  (let [adj-list (fn [edges]\n                   (->> (into edges (map #(vec (reverse %)) edges))\n                        (group-by first)\n                        (map #(vector (first %) (map second (second %))))\n                        (apply map vector)\n                        (apply zipmap)))\n        bfs (fn [v adj]\n              (loop [que [v]\n                     visited #{v}]\n                (if (empty? que)\n                  visited\n                  (let [to-visit (concat\n                                   (rest que)\n                                   (filter #(not (contains? visited %)) (adj (first que))))\n                        with-neighbours (if (empty? to-visit)\n                                          visited\n                                          (apply conj visited to-visit))]\n                    (recur to-visit with-neighbours)))))\n        adj (adj-list edges)]\n    (= (count adj) (count (bfs (ffirst adj) adj)))))","problem":91,"user":"526ee63de4b03e8d9a4a733f"},{"code":"(fn connected? [graph]\n  (letfn [(transitions [node graph]\n                       (set (map #(if (= node (first %)) % (reverse %))\n                                 (filter #(or (= node (first %)) (= node (second %))) graph))))\n          \n          (reachable-nodes [start-node explored-nodes graph]\n                           (let [explored-nodes (conj explored-nodes start-node)\n                                 unexplored-transistions (remove #(explored-nodes (second %)) (transitions start-node graph))]\n                             (if (empty? unexplored-transistions)\n                               explored-nodes\n                               (reduce #(into %1 (reachable-nodes (second %2) explored-nodes graph))\n                                       explored-nodes \n                                       unexplored-transistions))))\n          \n          (nodes [transitions]\n                 (reduce #(conj (conj %1 (first %2)) (second %2)) \n                         #{} \n                         transitions))]\n         \n         (= (count (nodes graph))\n            (count (reachable-nodes (ffirst graph) #{} graph)))))","problem":91,"user":"4e7263a1535d5021c1a8965f"},{"problem":91,"code":"(fn [n]\n  (loop [c #{(first n)}]\n    (let [m (into c (apply concat (for [i c o n :when (some (set i) (set o))] (for [k i l o] [k l]))))]\n      (or (clojure.set/subset? n m)\n        (if (= m c) false (recur m))))))","user":"5a244240e4b0ff51aa4b32e9"},{"problem":91,"code":"(fn [edges]\n  (letfn [(vertecies []\n            (into #{} (apply concat edges)))\n          (neighbors [vtx]\n            (mapcat (fn [[x y]]\n                      (cond (= x vtx) [y]\n                            (= y vtx) [x]\n                            :else nil)) edges))\n          (iter [vs visited]\n            (if (empty? vs) visited\n                (let [res (reduce disj (set (mapcat neighbors vs)) visited)]\n                  (iter res (reduce conj visited res)))))]\n    (= (vertecies) (iter #{(first (first edges))} #{}))))","user":"58f98231e4b0438e51c2cf4c"},{"problem":91,"code":"(fn [xs] (let [nodes (set (distinct (apply concat (seq xs))))\n               aux (fn [f g z nd] (reduce #(if (= (f %2) nd) (into % (vector (g %2))) %) z xs))\n               go (fn [nd] (aux first second (aux second first #{} nd) nd))\n               succ (fn [nds] (reduce into (map go nds)))\n                ]\n           (letfn [(limit [z] (into z (if (= z (succ z)) () (limit (succ z)))))]\n            (= nodes (set (limit (set (first xs))))))))","user":"53976599e4b0b51d73faaeea"},{"problem":91,"code":"(fn [G]\n  (loop [e (rest G) C (into #{} (first G))]\n    (let [{c true d false} (group-by #(->> % (some C) boolean) e)]\n      (if (or (empty? e) (empty? c))\n        (every? C (flatten (into [] G)))\n        (recur d (into C (flatten c)))))))","user":"58c73111e4b021aa9917ed72"},{"problem":91,"code":"( fn __ [edges]\n    (let [edge-list (apply merge-with concat (map (fn [[s e]] (if (= s e) {s []} {s [e] e [s]})) edges))\n           explore (fn [[seen frontier]]\n                     (let [new-frontier (set (remove seen (mapcat edge-list frontier)))]\n                       [(clojure.set/union seen new-frontier) new-frontier]))\n           start (ffirst edges)\n           component (ffirst (filter #(empty? (second %)) (iterate explore [#{start} #{start}])))]\n          (=  (count component) (count edge-list))))","user":"56897739e4b0dcc4269f407d"},{"problem":91,"code":"(fn connected-graph? [edges]\n  (let [outbound (->> (concat edges (map reverse edges))\n                      (group-by first)\n                      (map (fn [[node edge-list]]\n                             [node (set (map second edge-list))]))\n                      (into {}))\n        nodes (set (keys outbound))]\n    (loop [visited #{(first nodes)}]\n      (let [next-visited (->> (mapcat outbound visited)\n                              (into visited))]\n        (cond\n          (= next-visited nodes)\n          true\n\n          (= next-visited visited)\n          false\n\n          :default\n          (recur next-visited))))))","user":"57a4fa50e4b0a966079561f1"},{"problem":91,"code":"(fn connected? [G]\n  (letfn [(united? [x y G]\n    (loop [radiation #{x}]\n      ;; grab the edges \n      (let [rad-edges (filter #(not-empty (clojure.set/intersection radiation %)) G)]\n        ;; grab the nodes corresponding to those edges\n        (let [new-radiation (reduce clojure.set/union rad-edges)]\n          ;; if we fully expanded, then we're done\n          (cond (contains? new-radiation y) true\n                 ;; if not, and if new radition achieved no effect, we're stuck\n                (= radiation new-radiation) false\n                ;; otherwise, continue the radiation outward\n                true (recur new-radiation))))))]\n\n  (let [nodes (reduce clojure.set/union G) cartesian-product (fn [A B] (set (for [a A b B] [a b])))]\n    (reduce #(and %1 %2) (for [pair (cartesian-product nodes nodes)] \n                  (united? (first pair) (second pair) (set (map set G))))))))","user":"53703287e4b0fc7073fd6e8f"},{"problem":91,"code":"(fn [g]\n    (let [start (ffirst g)\n          num-nodes (count (into #{} (flatten (seq g))))\n          edges (into #{} (clojure.set/union g (map reverse g)))\n          orbit (fn orbit [n e already-seen]\n                       (let [out-edges (filter #(= n (first %)) e)\n                             successors (clojure.set/difference (into #{} (map last out-edges)) already-seen)]\n                         (if (empty? successors)\n                           already-seen\n                           (let [other-edges (clojure.set/difference e out-edges)]\n                             (apply clojure.set/union (map #(orbit % other-edges (into already-seen[%])) successors))))))\n          component (orbit start edges #{start})]\n      (= num-nodes (count component))))","user":"4e837808535db62dc21a62d9"},{"problem":91,"code":"(fn [s1]\n          (let [\n                [m1 nodes]  (reduce (fn [[acc accn] [l r :as t]] \n                              [(merge-with concat acc {l [r]} ) (into accn [ l r])]) [{} #{}] s1)\n                m2 (reduce (fn [acc xxs] (let [vw (get m1 xxs)]\n                                               (reduce (fn [a1 v1] (merge-with concat a1 {v1 [xxs]}))\n                                                       acc\n                                                       vw\n                                                       ))) m1 (keys m1))\n                allxs (keys m1)\n                k1 [(first allxs)]\n                ]\n            (loop [rs (into #{} k1) ]\n             (let \n               [k2 (reduce (fn [acc ls]  (into acc (get m2 ls))) rs rs)]               \n                 (if (= (count k2) (count rs))\n                  (= (count k2) (count nodes))\n                  (recur k2 )\n                 ))))\n          )","user":"533c2605e4b0e30313ee6cd7"},{"problem":91,"code":"(fn connected-graph? [tuples]\n  (let [whereis (fn [l r xs]\n                  (let [il (.indexOf xs l)\n                        ir (.indexOf xs r)]\n                    (cond\n                      (= [-1 -1] [il ir]) nil\n                      (not= -1 il) [(inc il) r]\n                      (not= -1 ir) [ir l])))\n        insert-before-idx (fn [v n e]\n                            (if (= n (count v))\n                              (into v [e])\n                              (let [l (subvec v 0 n)\n                                    r (subvec v n (count v))]\n                                (into l (into [e] r)))))\n        some? #(-> % nil? not)\n        tuples->runs (fn [already tuples]\n                       (reduce (fn [acc [l r]]\n                                 (let [wheres (map #(whereis l r %) acc)]\n                                   (if (empty? (remove nil? wheres))\n                                     (conj acc [l r])\n                                     (let [updater (->> wheres\n                                                        (map-indexed #(when (some? %2) (into [%1] %2)))\n                                                        (some #(when (some? %) %)))\n                                           where-1 (first updater)\n                                           where-2 (second updater)\n                                           what (first (drop 2 updater))]\n                                       (update-in acc [where-1] (fn [v]\n                                                                  (insert-before-idx v where-2 what)))))))\n                               already\n                               tuples))\n        grouped (->> tuples\n                     ((partial tuples->runs []))\n                     (group-by count))\n        new-tuples (get grouped 2)\n        non-tuple-key (first (disj (set (keys grouped)) 2))\n        in-again (get grouped non-tuple-key)\n        ]\n    (= 1 (count (tuples->runs in-again new-tuples)))))","user":"561d8936e4b064ca9f4b16b2"},{"problem":91,"code":"(fn [g]\n  (letfn\n     [(direct-connections [n]\n        (reduce (fn [acc edge] (if ((set edge) n) (into acc edge) acc)) #{} g))\n\n      (graph-connections [n]\n        (loop [connections #{}\n               new-connections #{n}]\n          (if (or (= connections new-connections) (empty? new-connections))\n            connections\n            (recur\n              (into connections new-connections)\n              (reduce (fn [acc n] (into acc (direct-connections n)))\n                      #{}\n                      (clojure.set/difference new-connections connections))))))]\n\n    (let [all-nodes (set (flatten (map identity g)))]\n      (every? (partial = all-nodes) (map graph-connections all-nodes)))))","user":"58b51e05e4b0ebc645576d4c"},{"problem":91,"code":"(fn [edges]\n   (letfn [(touches [comp [x y]]\n             (or (contains? comp x) (contains? comp y)))\n           (add [comps edge]\n             (let [to-merge (conj (set (filter #(touches % edge) comps)) (set edge))\n                   others (clojure.set/difference comps to-merge)]\n               (into #{(apply clojure.set/union to-merge)} others)))]\n     (= 1 (count (reduce add #{} edges))))\n   )","user":"53ed6976e4b0d648e757f4c4"},{"problem":91,"code":"(fn [s]\n  (true?\n    ((fn connected? [node-set reminder]\n       (or (empty? reminder)\n           (some #(when (some (fn [k] (node-set k)) %)\n                   (connected? (into node-set %) (disj (set reminder) %))) reminder)))\n      (into #{} (first s)) (rest s))))","user":"50f10f7be4b06d9538fe211a"},{"problem":91,"code":"(fn graph-connect\r\n  ([s] \r\n    (let [el (distinct (flatten (seq s)))]\r\n      (every?\r\n        #(graph-connect (first %) (second %) s)\r\n          (for [i el j el] [i j]))))\r\n  ([a b s]\r\n    (letfn [(any? [f s] ((comp boolean some) f s))\r\n            (includes? [s a] (any? (partial = a) s))\r\n            (rm-one [s a] \r\n                (concat \r\n                  (remove (partial = a) s) \r\n                  (rest (filter (partial = a) s))))]\r\n    (if (= a b)\r\n    true\r\n    (if (empty? s)\r\n      false\r\n      (let [next (filter #(includes? % a) s)]\r\n        (if (empty? next)\r\n          false\r\n          (any?\r\n            #(graph-connect \r\n              (if (= (second %) a) (first %) (second %))\r\n              b\r\n              (rm-one s %))\r\n            next))))))))","user":"5470699ae4b00cfc9eacc1b6"},{"problem":91,"code":";(fn my-graph-connectivity [g]\n;  (letfn [(is-connected? [init edge-set]\n;            (if (empty? edge-set)\n;                true\n;                (let [take-one\n;                       (->> edge-set\n;                            (filter #(not-empty (clojure.set/intersection init %)))\n;                            (first))]\n;                   (if (nil? take-one)\n;                       false\n;                       (recur (into init take-one)\n;                              (clojure.set/difference edge-set (hash-set take-one)))))))]\n;    (is-connected? (set (first g))\n;                   (set (map set (rest g))))))\n(fn my-graph-connectivity [g]\n  (letfn [(f [edge]\n            (#(if (= % edge) (= % g) (f %))\n              (reduce (fn [a b]\n                         (into a (filter #(some (set b) %) g)))\n                      #{}\n                      edge)))]\n      (f #{(first g)})))","user":"581b19e7e4b04b46fc4b0ec4"},{"code":"(fn [s]\n  (loop [edges (rest s) nodes (set (first s))]\n    (let [parts (group-by (fn [[a b]] (not (nil? (or (nodes a) (nodes b))))) edges)\n          in (set (apply concat (parts true))) out (set (parts false))\n          newnodes (into nodes in)]\n      (cond (empty? out) true\n            (= newnodes nodes) false\n            true (recur out newnodes)))))","problem":91,"user":"4ebc08a8535dfed6da9c6d7c"},{"problem":91,"code":"(fn __ [edges]\n  (letfn [(connected? [c1 c2]\n                      (not (empty? (clojure.set/intersection c1 c2))))\n          (add-comp [c1 c2]\n                      (if (connected? c1 c2) (apply conj c1 c2) c1))\n          (merge-comp [cs]\n                      (if (empty? cs) '()\n                        (let [c (first cs), rs (rest cs)]\n                          (if (true? (some true? (map #(connected? c %) rs)))\n                            (merge-comp (map #(add-comp % c) rs))\n                            (cons c (merge-comp rs))))))\n          ]\n    (->> (map #(into #{} %) edges)\n         (merge-comp)\n         (count)\n         (#(= 1 %)))))","user":"54c271b9e4b045293a27f602"},{"code":"(fn connected-graph [graph]\n  (letfn [(walk [graph seen]\n  \t(loop [i (count graph) seen seen]\n\t\t  (if (zero? i)\n\t\t    seen\n\t\t    (recur (dec i)\n\t\t\t   (walk-graph graph seen)))))\n\t  (walk-graph [graph seen]\n\t\t      (loop [g graph seen seen]\n\t\t\t(if (empty? g)\n\t\t\t  seen\n\t\t\t  (let [[a b] (first g)]\n\t\t\t    (recur (rest g)\n\t\t\t\t   (map (fn [seen]\n\t\t\t\t\t     (if (seen a)\n\t\t\t\t\t       (conj seen b)\n\t\t\t\t\t       (if (seen b)\n\t\t\t\t\t\t (conj seen a)\n\t\t\t\t\t\t seen)))\n\t\t\t\t\tseen))))))]\n    (let [seen (walk graph [#{(ffirst graph)}])]\n     (not (nil?\n\t   (some (fn [g] (= (count (set (flatten (vec graph))))\n\t\t\t    (count g)))\n\t\t seen))))))","problem":91,"user":"4e513ecf535dc968683fc4f6"},{"code":"(fn [s]\n  (let [con (reduce (fn [m [k v]]\n                      (->> m\n                           (merge-with concat {k [v]})\n                           (merge-with concat {v [k]})))\n                    {} s)\n        reachables (fn [k]\n                     (loop [open [k]\n                            closed #{}]\n                       (if (seq open)\n                         (let [head (first open)\n                               nc (conj closed head)]\n                           (recur (into (rest open) (remove nc (con head))) nc))\n                         closed)))]\n    (apply = (map reachables (keys con)))))","problem":91,"user":"4ff9d4e5e4b0678c553fc3b0"},{"problem":91,"code":"(fn [G]\n  (letfn [(add [R u]\n           (if (contains? R u) R (assoc R u u)))\n          (find [R u]\n            (let [pu (get R u)]\n              (if (= u pu) u (recur R pu))))\n          (union [R u v]\n            (let [pu (find R u) pv (find R v)]\n              (if (= pu pv) R (assoc R pu pv ))))]\n    (let [V (reduce (fn [V [u v]]\n                      (conj (conj V u) v))\n                    #{} G)\n          R (reduce (fn [R [u v]]\n                      (union (add (add R u) v) u v))\n                    {} G)]\n      (first (reduce (fn [[r c] u] [(= c (find R u)) c])\n                     [true (find R (first V))] (rest V))))))","user":"5576f299e4b05c286339e077"},{"problem":91,"code":"(fn connected? [g]\n  (letfn [(other [x [a b]]\n                 (condp = x\n                        a [b]\n                        b [a]\n                        nil))\n          (all-connections-with [x g]\n            (mapcat #(other x %) g))\n          (connected-to-root? [roots el]\n            (some roots el))]\n    (loop [roots #{(ffirst g)} g g]\n      (cond\n        (empty? g) true\n        (empty? roots) false\n        :else (recur (set (mapcat #(all-connections-with % g) roots))\n                     (set (remove #(connected-to-root? roots %) g)))))))","user":"54cc313de4b057c6fda3a28b"},{"problem":91,"code":"(fn x [edges]\n  (letfn [(to-graph [edges]\n            (reduce \n              #(let [a (first %2) b (second %2) a-edges (get %1 a []) b-edges (get %1 b [])]\n                 (assoc %1 a (conj a-edges %2) b (conj b-edges %2)))\n              {}\n              edges))\n          (dfs [n graph visited]\n            (let [visited' (conj visited n)\n                  n-edges (get graph n)\n                  dest #(if (= (first %) n) (second %) (first %))]\n              (reduce\n                (fn [visited'' edge]\n                  (let [d (dest edge)]\n                    (if (contains? visited'' d) visited'' (dfs d graph visited''))))\n                visited'\n                n-edges)))]\n    (let [g (to-graph edges)\n          nodes (into #{} (keys g))\n          connected (dfs (first nodes) g #{})]\n      (println connected)\n      (= nodes connected))))","user":"56d68cbae4b0ea9b8538f7cd"},{"problem":91,"code":"(fn [edges]\n  (loop [g (set (first edges)) [h & t] (rest edges) g* [] added 0]\n    (let [conn? (fn [[x y]] (or (g x)(g y)))]\n      (if (nil? h) \n        (if (empty? g*) true \n          (if (= 0 added) false (recur g g* [] 0)))\n        (if (conn? h) \n          (recur (apply conj g h) t g* (inc added))\n          (recur g t (conj g* h) added))))))","user":"55ecb2c0e4b0121d4835fdce"},{"code":"(fn connected? [input]\n  (let [coords (map set input)\n        everything (apply clojure.set/union coords)\n        single-pass (fn [visited]\n                      (reduce \n                        #(if (seq (clojure.set/intersection %1 %2)) \n                           (clojure.set/union %1 %2)\n                           %1)\n                        visited\n                        coords))]\n    (loop [visited (first coords)]\n      (if (empty? (clojure.set/difference everything visited))\n        true\n        (let [updated (single-pass visited)]\n          (if (= (count updated) (count visited))\n            false\n            (recur updated)))))))","problem":91,"user":"53513d28e4b084c2834f4ae3"},{"code":"#(boolean (#{1 7} (count %)))","problem":91,"user":"50a83315e4b054305ba5a830"},{"problem":91,"code":"(fn [g] (letfn [(f [s r]\n          (let [n (into s\n                        (for [[a b] s [c d] r \n                              :when (or (= b c) (= a c) (= a d) (= b d))] \n                          [c d]))]\n            (if (= n s) n (recur n g))))]\n         (= (f #{(first g)} g) (set g)) ))","user":"5c379636e4b0d62ef62d9f76"},{"code":"(fn graphconnect [x]\r\n    (letfn [(getset [a acc] (if-let [s (first (filter #(% a) acc))] s #{a}))]\r\n           (= 1 (count\r\n           (reduce \r\n             (fn [acc [a b]] (let [_a (getset a acc) _b (getset b acc)] (conj (disj acc _a _b) (clojure.set/union _a _b)))) \r\n             #{} x)))))","problem":91,"user":"4feada56e4b0140c20fb9c11"},{"problem":91,"code":"(fn [graph]\n  (apply = (vals (reduce \n                  (fn [adj_map [x y]]\n                    (let [node_connect (reduce conj (adj_map x #{x}) (adj_map y #{y}))]\n                      (reduce #(assoc % %2 node_connect) adj_map node_connect)))\n                  {} graph))))","user":"533018b2e4b019098a6f8b56"},{"code":"(fn [s]\n    (let [closure (fn [s]\n                    (let [new-s (reduce\n                                 into\n                                 s\n                                 (map\n                                  (fn [[x1 x2]]     \n                                    (set (map\n                                          (fn [[y1 y2]]\n                                            (if (= x2 y1)\n                                              [x1 y2]\n                                              [x1 x2]))\n                                          s)))\n                                  s))]\n                      (if (= new-s s)\n                        s\n                        (recur new-s))))\n\n          s' (into s\n                   (map (fn [[a b]]\n                          [b a])\n                        s))\n\n          closed (closure s')\n\n          el->reachable (reduce (fn [acc [l r]]\n                                  (merge-with into acc {l #{r}}))\n                                {}\n                                closed)\n          ]\n      \n      (apply = (vals el->reachable))\n      ))","problem":91,"user":"4daea889edd6309eace4d15b"},{"code":"(fn [edge-set]\n  (let [all-nodes (reduce (fn [acc pair] (-> acc\n                                             (conj (first pair))\n                                             (conj (second pair))))\n                          #{} edge-set)\n        reachable-from-node (fn [node]\n                              (reduce (fn [acc pair] (cond\n                                                      (= node (first pair)) (conj acc (second pair))\n                                                      (= node (second pair)) (conj acc (first pair))\n                                                      :else acc))\n                                      #{} edge-set))\n        reachable-from-set (fn [nodes]\n                             (reduce clojure.set/union nodes (map reachable-from-node nodes)))\n\n        ]\n    (loop [reached #{(first all-nodes)}]\n      (let [reachable (reachable-from-set reached)]\n        (cond\n         (= all-nodes reachable) true\n         (= reached reachable) false\n         :else (recur reachable))))))","problem":91,"user":"4fa340b4e4b081705acca18c"},{"code":"(fn [edges] \n  (-> \n   (reduce \n    (fn [cs [a b]]\n      (let [ca (get cs a a)\n            cb (get cs b b)\n            cs (assoc cs a ca b cb)]\n        (zipmap (keys cs) (replace {ca cb} (vals cs)))))\n    {}\n    edges)\n   (vals)\n   (distinct)\n   (count)\n   (= 1)))","problem":91,"user":"532347dde4b09d4e7a9b54cc"},{"problem":91,"code":"(fn prob91 [edges]\n  (let [csets\n        (reduce\n         (fn [s tuple]\n           (let [tset (set tuple)\n                 isets (filter #(not (empty? (clojure.set/intersection % tset))) s)]\n             (clojure.set/union\n               (clojure.set/difference s isets)\n               (hash-set (apply clojure.set/union tset isets)))))\n         #{} edges)]\n    (= 1 (count csets))))","user":"54e3df6ae4b024c67c0cf7e3"},{"problem":91,"code":"(fn __ [graph]\n  (let [\n        vertices (reduce (fn [acc [f t]] (conj acc f t) ) #{} graph)\n        start (set (first graph))\n        expand2Width (fn [rrr edges]\n                       (reduce\n                         (fn [vers [f t]]\n                           (let [\n                                 ff (if (vers f)\n                                      (conj vers t)\n                                      vers)\n                                 ff2 (if (ff t)\n                                      (conj ff f)\n                                      ff)\n                                 ] ff2))\n                         rrr graph))\n        expanded (loop [\n                        reached start\n                        ]\n                   (let [\n                         reachedMore (expand2Width reached graph)\n                         ]\n                     (if (= reached reachedMore)\n                       reached\n                       (recur reachedMore))))\n        result (= vertices expanded)\n        ]\n    (println vertices expanded)\n    result))","user":"58bc6a88e4b0888cdc949d16"},{"code":"(fn [g]\n\t(letfn \n\t\t[(add-edge [edge graph]\n\t\t\t(let [e1 (first edge) e2 (last edge)\n\t\t\t\tadd (fn [from to g]\n\t\t\t\t\t(if (contains? g from)\n\t\t\t\t\t\t(let [vertex (g from)]\n\t\t\t\t\t\t\t(conj g [from {:degree (inc (:degree vertex)) :edges (conj (:edges vertex) to)}])\n\t\t\t\t\t\t)\n\t\t\t\t\t\t(conj g [from {:degree 1 :edges #{to}}])\n\t\t\t\t\t)\n\t\t\t\t)]\n\t\t\t\t(->> graph (add e1 e2) (add e2 e1))\n\t\t\t)\n\t\t)\n\t\t(graph-from-edges [edges]\n\t\t\t(loop [graph {} edge (first edges) rst (rest edges)]\n\t\t\t\t(if edge\n\t\t\t\t\t(recur (add-edge edge graph) (first rst) (rest rst))\n\t\t\t\t\tgraph\n\t\t\t\t)\n\t\t\t)\n\t\t)\n\t\t(graph-is-connected? [graph]\n\t\t\t(letfn [\n\t\t\t\t(bfs [start]\n\t\t\t\t\t(loop [nxt (:edges (graph start)) seen #{start}]\n\t\t\t\t\t\t(if (empty? nxt)\n\t\t\t\t\t\t\tseen\n\t\t\t\t\t\t\t(let [cur (first nxt) edges (:edges (graph cur)) other (set (rest nxt)) new-seen (conj seen cur)]\n\t\t\t\t\t\t\t\t(recur (-> edges (clojure.set/union other) (clojure.set/difference new-seen)) new-seen)\n\t\t\t\t\t\t\t)\t\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t\t]\n\t\t\t\t(= (set (keys graph)) (bfs (first (keys graph))))\n\t\t\t)\n\t\t)]\n\t\t(-> g graph-from-edges graph-is-connected?)\n\t)\n)","problem":91,"user":"511cca27e4b00c2a1fa7ff7d"},{"code":"(letfn [(undirected [edges]\n          (into edges (for [[from to] edges]\n                        [to from])))\n        (transit-1 [edges]\n          (let [undir (undirected edges)\n                nodes (group-by first undir)]\n            (into undir (for [[from to] nodes\n                              [_ intermediate] to\n                              [_ endpoint] (nodes intermediate)]\n                          [from endpoint]))))\n        (closure [edges]\n          (->> edges\n               (iterate transit-1)\n               (partition 2 1)\n               (drop-while (partial apply not=))\n               ffirst))\n        (nodes [edges]\n          (set (apply concat edges)))\n        (fully-connected [nodes]\n          (set (for [x nodes, y nodes]\n                 [x y])))]\n  (fn [edges]\n    (= (fully-connected (nodes edges))\n       (closure edges))))","problem":91,"user":"4dad7adac9a9d6ed0599dc57"},{"code":"(fn con\r\n   ([graph]\r\n      (letfn [(nodes [graph]\r\n                (set (flatten (seq graph))))]\r\n        \r\n        (if (some true? (flatten\r\n                         (for [node graph]\r\n                           (con (disj graph node) node (-> (nodes graph)\r\n                                                           (disj (first node))\r\n                                                           (disj (second node)))))\r\n                         ))\r\n          true\r\n          false\r\n          )))\r\n\r\n   ([graph cur-node not-visited-nodes]\r\n      (letfn [(find-next-node [val pair graph]\r\n                (some #(when (or (= (first %1) val)\r\n                                 (= (second %1) val)) %1) (disj graph pair)))]\r\n        (if (seq graph)\r\n          (for [node graph]\r\n            (let [next-node (find-next-node (second cur-node) cur-node graph)]\r\n              (if next-node\r\n                (con (disj graph node) next-node (-> not-visited-nodes\r\n                                                     (disj (first node))\r\n                                                     (disj (second node))))\r\n                false)))\r\n          \r\n          (if not-visited-nodes\r\n            true\r\n            false)))))","problem":91,"user":"4e0d8c27535d04ed9115e7b7"},{"code":"(fn connected? [g]\n (let [adj-list (fn [s]\n        (let [nodes (set (mapcat flatten s))\n          nbs (fn [curr] \n              (mapcat (partial filter #(not= % curr)) \n                      (filter (partial some #(= % curr)) s)))]\n        (zipmap nodes (map nbs nodes))))\n       walk (fn walk [curr adj visited]\n             (let [nearby (adj curr)\n                   unvisited (filter (complement visited) nearby)\n                   new-visited (into visited unvisited)]\n             (if (empty? unvisited) visited\n              (apply clojure.set/union (flatten \n                    (map #(walk % adj new-visited) unvisited))))))\n       adj (adj-list g)\n       nodes (keys adj)]\n  (if (< (count nodes) 2) true\n  (= (count nodes) (count (walk (first nodes) adj #{}))))))","problem":91,"user":"4dcfbc44535d5973398f92a7"},{"problem":91,"code":"(fn [s] \n     (let [con-to (fn [cc s] (into cc (for [x cc [a b] s] (cond (= x a) b (= x b) a :else x))))\n           conn-comp (fn [cc s] (let [newcc (con-to cc s)] (if (= cc newcc) cc (recur newcc s))))]\n        (= (set (flatten (seq s)))\n           (conn-comp #{(ffirst s)} s))))","user":"56b86e64e4b0f26550335924"},{"problem":91,"code":"(fn conn [n]\n\t(let [y (atom (first n))]\n\t\t(reduce (fn [a b] (or a b))\n\t\t\t(for [c (range 10)]\n\t\t\t\t(reduce (fn [a b] (or a b))\n\t\t\t\t\t(for [x n]\n\t\t\t\t\t\t(do\n\t\t\t\t\t\t\t(if (some (set @y) (set x)) (swap! y into x))\n\t\t\t\t\t\t\t(swap! y set)\n\t\t\t\t\t\t\t(= (count (set @y)) (count (set (reduce into n))))\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t)\n\t)\n)","user":"5568749ae4b0c656e3ff1854"},{"code":"(fn is-connected [g]\r\n  (let [f (fn [c-comp edge] (reduce #(if (or (= (first edge) (first %2)) \r\n                                             (= (first edge) (second %2)) \r\n                                             (= (second edge) (first %2)) \r\n                                             (= (second edge) (second %2)))\r\n                                       (conj %1 %2) %1) c-comp g))]\r\n    (= (count g)\r\n       (count (reduce (fn [c-comp edge]\r\n                        (let [v-c (flatten (vec c-comp))]\r\n                          (if (some #(or (= (first edge) %) (= (second edge) %)) v-c)\r\n                            (f c-comp edge)\r\n                            c-comp))) (f #{} (first g)) (disj g (first g)))))))","problem":91,"user":"505dd5c4e4b0e6aca564be0e"},{"code":"(fn cn? [g]\r\n  (let [ gs (map set g)\r\n         find-eq (fn [eq]\r\n\t\t\t\t\t\t(reduce into eq \r\n              (filter #(some eq %) (map set gs))))\r\n         drop-incr (fn [l] \r\n            (drop-while #(not= (count (first %)) (count (second %))) (partition 2 1 l)))]\r\n\t\t\t\t\t(=\r\n\t\t\t\t\t  (reduce into gs)\r\n\t\t\t\t\t  (ffirst (drop-incr (iterate find-eq (first gs))))\r\n        )))","problem":91,"user":"4e6e10d8535d5021c1a895fd"},{"problem":91,"code":"(fn path [coll]\n  (letfn [(trans [coll]\n                 (loop [coll coll]\n                   (let [new-coll (into coll\n                                        (for [[a b] coll\n                                              [c d] coll\n                                              :when (= b c)]\n                                          [a d]))]\n                     (if (= coll new-coll)\n                       coll\n                       (recur new-coll)))))\n          (all-paths [coll]\n                     (let [flat-coll (flatten (vec coll))]\n                       (for [x flat-coll\n                             y flat-coll\n                             :when (not= x y)]\n                         [x y])))]\n    (->> (into coll (map reverse coll))\n         trans\n         (filter #(not= (first %) (second %)))\n         set\n         (= (set (all-paths coll))))))","user":"54848141e4b0e286459a119e"},{"problem":91,"code":"(fn connected? [edges]\n  (let [all-connections (fn [edges]\n                          (reduce (fn [res [a b]]\n                                    (conj res [a b] [b a]))\n                                  #{}\n                                  edges))\n        edges           (reduce (fn [res [a b]]\n                                  (assoc res a (conj (get res a) b)))\n                                {}\n                                (all-connections edges))\n        vertices        (set (keys edges))\n        dfs             (fn dfs [vertex vertices]\n                          (let [vertices (disj vertices vertex)]\n                            (reduce (fn [res conn]\n                                      (if (contains? res conn)\n                                        (dfs conn res)\n                                        res))\n                                    vertices\n                                    (get edges vertex))))]\n    (empty? (dfs (first vertices) vertices))))","user":"5dc53ddee4b02f9375f4e1bd"},{"code":"(fn connected? [edges]\n  (letfn [(add-edge [g a b]\n            (update-in g [a] (fn [e] (if (nil? e) [b] (conj e b)))))\n\n          (graph [edges]\n            (reduce (fn [acc [a b]]\n                      (add-edge (add-edge acc a b) b a)) {} edges))\n\n          (dfs [g n]\n            (letfn [(dfs-iter [stack visited]\n                      (lazy-seq\n                       (when-let [cur (peek stack)]\n                         (if (visited cur)\n                           (dfs-iter (pop stack) visited)\n                           (let [adjs (g cur)]\n                             (cons cur (dfs-iter (vec (concat (pop stack) adjs))\n                                                 (conj visited cur))))))))]\n              (dfs-iter [n] #{})))]\n    (let [g (graph edges)]\n      (= (set (keys g)) (set (dfs g (key (first g))))))))","problem":91,"user":"52f8f4d1e4b047fd55836fde"},{"problem":91,"code":"(fn connected? [g]\n  (let [nodenum (->> g\n                     (reduce (fn [s [a b]]\n                               (conj s a b))\n                             #{})\n                     count)]\n    (= nodenum\n       (count\n        (set\n         (map first\n              (tree-seq (constantly true)\n                        (fn children [[v edges]]\n                          (let [newedges (filter (fn [[a b]] (not= b v)) edges)\n                                nodes (->> newedges\n                                           (filter (fn [[a b]] (= a v)))\n                                           (map second))]\n                            (map #(vector % newedges) nodes)))\n                        [((first g) 0) g])))))))","user":"571d063ee4b0145328a76272"},{"problem":91,"code":"(fn [graph]\n  (let [all-nodes (set (flatten (vec graph)))\n        nodes-map (reduce #(merge-with concat %1 %2) (for [[x y] graph] {x [y]}))\n        connected (fn connected [remaining node]\n                    (if (empty? remaining)\n                      []\n                      (let [links (get remaining node)\n                            new-remaining (dissoc remaining node)\n                            links-to-node (for [[up-key up-links] remaining\n                                                :when (some #{node} up-links)]\n                                            up-key)]\n                        (set (concat [node]\n                                     links\n                                     (mapcat #(connected new-remaining %) links)\n                                     (mapcat #(connected new-remaining %) links-to-node))))))]\n\n    (= all-nodes (connected nodes-map (first all-nodes)))))","user":"5344fe13e4b084c2834f4a32"},{"problem":91,"code":"(fn connectivity [g]\n  (loop [r g, n (hash-set (ffirst g))]\n    (cond (empty? r) true\n          (empty? n) false\n          :else (let [n-edges (for [node n, [u v :as edge] r,\n                                    :when (or (= u node) (= v node))]\n                                [edge (if (= u node) v u)])]\n                  (recur (remove #(some (fn [[e _]] (= % e)) n-edges) r)\n                         (into #{} (map (fn [[_ n]] n) n-edges)))))))","user":"5492164ee4b0b312c081ff3e"},{"problem":91,"code":"(fn [g]\n      (letfn [(connected? [g]\n          (loop [q (conj [] (ffirst g)) visited #{}]\n              (if (empty? q)\n                  (let [rem (filter #(not (contains? visited %)) (flatten (for [e g] e)))]\n                  (empty? rem))\n              (let [v1 (peek q)\n                  edges (filter (partial some #{v1}) g)\n                  vertices (filter (partial not= v1) (flatten edges))\n                  unvisited (filter #(not (contains? visited %)) vertices)]\n                (recur (into (rest q) unvisited) (into (conj visited v1) unvisited))))))]\n     (connected? g)))","user":"5243e37ae4b076204b44fae3"},{"problem":91,"code":"(letfn [\n        (nodes [graph]\n          (distinct (flatten (into () graph))))\n        \n        (node-paths [node graph]\n          (filter #(not (= node %))\n                  (nodes (filter #(< -1 (.indexOf % node)) graph))))\n        \n        (nav-map [graph]\n          (loop [rm (nodes graph), acc {}]\n            (cond (empty? rm) acc\n                  :else (let [node (first rm)]\n                          (recur (rest rm)\n                                 (assoc acc node (node-paths node graph)))))))\n        (combos [graph]\n          (let [nodes (nodes graph)]\n            (loop [rm nodes, rm2 nodes, acc #{}]\n              (let [n1 (first rm), n2 (first rm2)]\n                (cond (nil? n1) acc\n                      (nil? n2) (recur (rest rm) nodes acc)\n                      (= n1 n2) (recur rm (rest rm2) acc)\n                      :else (recur rm (rest rm2) (conj acc (into [] (sort (list n1 n2))))))))))\n        \n        (next-node [current-path failed-paths nav-map]\n          (first (filter #(= -1 (.indexOf failed-paths (conj current-path %)))\n                         (filter #(= -1 (.indexOf current-path %)) (nav-map (last current-path))))))\n\n        (has-path? [node1 node2 nav-map]\n          (loop [current-path [node1], failed-paths []]\n            (let [n (next-node current-path failed-paths nav-map)]\n              (cond (empty? current-path) false\n                    (= n node2) true\n                    (nil? n) (recur (pop current-path) (conj failed-paths current-path))\n                    :else (recur (conj current-path n) failed-paths)))))\n\n        (connected? [graph]\n          (let [nav-map (nav-map graph)\n                nodes (nodes graph)]\n            (every? true? (map #(has-path? (% 0) (% 1) nav-map) (combos graph)))))]\n  connected?)","user":"538e36c7e4b0b51d73faae81"},{"problem":91,"code":"(fn [edges]\n  (let [[first-node & others] (flatten (seq edges))\n        edges (map set edges)]\n    (loop [connected #{first-node}\n           unconnected (disj (set others) first-node)]\n      (let [{new-connects true unconnected nil}\n            (group-by (fn [node] (some #(and (contains? % node)\n                                             (not (empty? (clojure.set/intersection % connected))))\n                                       edges)) unconnected)]\n        (cond \n         (empty? unconnected) true ; we've connected everything, hooray\n         (empty? new-connects) false ; we can't connect any more, boooo\n         :else (recur (clojure.set/union connected (set new-connects))\n                      unconnected))))))","user":"54febf4be4b07d26eda61d45"},{"code":"(fn [ss]\n  (= (count (reduce \n    (fn [ss s]\n      (loop [ss ss s (set s) acc #{}]\n        (if (seq ss)\n            (if (empty? (clojure.set/intersection (first ss) s))\n                (recur (rest ss) s (conj acc (first ss)))\n                (recur (rest ss) (clojure.set/union (first ss) s) acc))\n            (conj acc s))))\n    #{} ss)) 1))","problem":91,"user":"4f9120d8e4b0dcca54ed6c96"},{"code":"(fn connected [vertexes]\n  (= 1 (count\n         (reduce\n           (fn [sets [a b]]\n             (let [m (group-by (fn [s] (or (contains? s a) (contains? s b))) sets)]\n               (clojure.set/union\n                 (hash-set\n                   (reduce\n                       clojure.set/union\n                     (into #{} [a b])\n                       (get m true #{})))\n                 (get m false #{}))))\n             #{}\n           vertexes)\n         )))","problem":91,"user":"5094057fe4b097f48cc38593"},{"problem":91,"code":"(letfn [(reachables [eset node]\n            (loop [nodes #{node}]\n              (let [new-nodes (into nodes\n                                    (mapcat seq\n                                            (filter\n                                             (fn [e]\n                                               (seq (clojure.set/intersection\n                                                nodes\n                                                e)))\n                                             eset)))]\n                (if (= nodes new-nodes)\n                  nodes\n                  (recur new-nodes)))))]\n    (fn connected? [edges]\n      (let [nodes (into #{}\n                        (flatten\n                         (seq edges)))\n            edgeset (into #{}\n                        (map set edges))\n            ]\n        (every?\n         (fn [[n1 n2]]\n           (contains? (reachables edgeset n1) n2))\n         (for [n1 nodes\n               n2 nodes\n               :when (not= n1 n2)]\n           [n1 n2])))))","user":"54246fcce4b01498b1a71aed"},{"code":"(fn [graph]\n\t(letfn \n\t[(genNodes [in]  (distinct (apply concat in)))\n\t (pathExists? [n e t]\n\t \t(if (= n t) true\n\t \t(if (empty? e) false\n\t \t(loop [ [x & xs] (filter #(contains? % n) e)]\n \t\t\t(if (nil? x) false\n \t\t\t\t(if (pathExists? (first (disj x n)) (disj e x) t)\n \t\t\t\t\ttrue\n \t\t\t\t\t(recur xs)\n \t\t\t\t\t))))))\n\t(isConnected? [[curNode & nextNodes] edges]\n\t\t(if (nil? curNode) true\n\t\t\t(if (reduce #(and %1 (pathExists? curNode edges %2)) true nextNodes)\n\t\t\t\t(recur nextNodes edges)\n\t\t\t\tfalse)))\n\t]\n\t(isConnected? (genNodes graph) (into #{} (map set graph))))\n)","problem":91,"user":"52bf6946e4b07a9af5792334"},{"code":"(fn [e o]\r\n  (let [[h & r] (seq o)]\r\n    ((fn f [c r]\r\n       (or (e r)\r\n   (let [n (mapcat #(filter (fn [p] (some (set %) p)) r) c)]\r\n\t   (if (e n) false\r\n\t     (f (reduce conj c n)\r\n\t\t(remove (set n) r))))))\r\n     #{h} r)))\r\nempty?","problem":91,"user":"4dce6e41535d5973398f92a2"},{"problem":91,"code":"(fn [e o]\n  (let [[h & r] (seq o)]\n    ((fn f [c r]\n       (or (e r)\n\t   (let [n (mapcat #(filter (fn [p] (some (set %) p)) r) c)]\n\t     (if (e n) false\n\t       (f (reduce conj c n)\n\t\t  (remove (set n) r))))))\n     #{h} r)))\nempty?","user":"58f45ea0e4b0438e51c2cebc"},{"code":"(letfn [\r\n  \t(to-adjacency-map [edges]\r\n\t\t\t(loop [m {}, es edges]\r\n\t\t\t\t(if-let [[[n1 n2] & es] (seq es)]\r\n\t\t\t\t\t(recur (merge-with clojure.set/union m {n1 #{n2}} {n2 #{n1}}) es)\r\n\t\t\t\t\tm)))\r\n\t\t\t\t\t\r\n\t\t(transitive-closure-1 [m]\r\n\t\t\t(apply merge-with clojure.set/union (for [[k vs] m, v vs] {k (clojure.set/union vs (get m v))})))\r\n\t\t\t\r\n\t\t(transitive-closure-* [m]\r\n\t\t\t(let [m2 (transitive-closure-1 m)]\r\n\t\t\t\t(if (= m2 m)\r\n\t\t\t\t\tm\r\n\t\t\t\t\t(recur m2))))]\r\n\t\t\r\n\t(fn is-connected [edges]\r\n\t\t(let [m (transitive-closure-* (to-adjacency-map edges))]\r\n\t\t\t(= (count (keys m)) (apply min (map count (vals m)))))))","problem":91,"user":"4dd6d6a0535d2dad7130b5ca"},{"code":"(fn [graph] (letfn [ (vertices [edge-set] (sort (distinct (flatten (map flatten edge-set))))) (without [coll item] (cond (empty? coll) [] (= (first coll) item) (rest coll) :else (cons (first coll) (without (rest coll) item)))) (seq-contains? [coll item] (cond (empty? coll) false (= (first coll) item) true :else (seq-contains? (rest coll) item))) (edges-with [edge-set vertex] (filter #(seq-contains? % vertex) (map flatten edge-set))) (vertices-with-distance-1 [edge-set vertex] (mapcat #(without % vertex) (edges-with edge-set vertex))) (expand [edge-set vertices] (sort (distinct (concat vertices (mapcat #(vertices-with-distance-1 edge-set %) vertices))))) (iterate-while-changes [f x] (cons x (map second (take-while #(not= (first %) (second %)) (partition 2 1 (iterate f x)))))) (expand-full [edge-set] (last (iterate-while-changes (partial expand edge-set) (take 1 (vertices edge-set))))) (is-connected? [graph] (= (set (vertices graph)) (set (expand-full graph)))) ] (is-connected? graph)))","problem":91,"user":"52f10094e4b05e3f0be25ee8"},{"problem":91,"code":"(fn graph-connected? [graph]\n  (let [; get all nodes from edges\n        edges-to-nodes (fn [nodes]\n                         (set (mapcat identity nodes)))\n        ; all the nodes from the graph\n        all-nodes (edges-to-nodes graph)\n        ; nb of nodes in graph\n        nb-nodes (count all-nodes)]\n    (loop [nodes #{(first all-nodes)}]\n      (let [; true if edge [fst snd] is connected to any of the nodes\n            is-connected (fn [[fst snd]]\n                           (or (nodes fst)\n                               (nodes snd)))\n            ; all the connected edges\n            connected-edges (filter is-connected graph)\n            ; the connected nodes\n            connected-nodes (edges-to-nodes connected-edges)\n            ; the new merged set of nodes\n            nx-nodes (apply conj connected-nodes nodes)]\n        (if (= nx-nodes nodes)\n          (= nb-nodes (count nodes))\n          (recur nx-nodes))))))","user":"5264383be4b03e8d9a4a70cb"},{"code":"(fn [s]\n    (= 1 (count\n          (reduce\n           (fn [graphs [a b]]\n             (reduce (fn [[r & rest] v]\n                       (if (or (v a) (v b))\n                         (cons (clojure.set/union v r) rest)\n                         (cons r (cons v rest))))\n                     [(set [a b])]\n                     graphs))\n           #{}\n           s))))","problem":91,"user":"4f463dfde4b0d56e7bb92b99"},{"code":"(fn[t](letfn[\n  (f [n] (if (= n 0) 1 (apply * (range 1 (inc n)))))\n  (c [n r] (if (> r n) 1 (+ n (* 2 (/ (f n) (* (f r)(f (- n r))))))))\n  (e [t](into \n    \t#{}\n\t\t\t(filter #(not (coll? %)) (tree-seq coll? identity t))\n\t\t)\n  )\n  (tr [r] (let [r (set (concat r (map reverse r))), s \n  \t(set (concat (set \n    \t(for \n      \t[x r y r :when (= (second x) (first y))]  \n      \t[(first x) (second y)]\n    \t)\n  \t) \n  \t(for \n      \t[x r y r :when (= (second x) (first y))]  \n      \t[(second y) (first y)]\n    \t)\n  \tr))]\n  \t(if (= (count s) (count r))\n  \t\ts\n  \t\t(tr s)\n  \t)\t\n  )\n  )]\n  (= (c (count (e t)) 2) (count (tr t)))\n)\n)","problem":91,"user":"4e6df3c9535d5021c1a895fa"},{"problem":91,"code":"(fn [graph]\n   (let [available (reduce (partial merge-with clojure.set/union) (map (fn [tuple] {(first tuple) #{(second tuple)}}) (concat graph (map reverse graph))))\n         all-available-routes ((fn all-routes [prev next]\n                                 (cond (= prev next) prev\n                                       :else (all-routes\n                                               next\n                                               (reduce (partial merge-with clojure.set/union) (map (fn [route]\n                                                                                                     {(first route)\n                                                                                                      (into #{}\n                                                                                                            (concat (second route)\n                                                                                                                    (mapcat (fn [current-available]\n                                                                                                                              (get next current-available))\n                                                                                                                            (second route))))}) next)))))\n                                [] available)\n         \n         node-count (count (distinct (reduce concat graph)))]\n     (= (reduce max (map count (vals all-available-routes))) node-count)\n     ))","user":"4e9ff8d0535d7eef3080729c"},{"code":"(fn [graph]\n  ; Algorithm:\n  ;   Start with one path, any path. The vertices (or vertex) connected to that path make a connected set.\n  ;   Now for each vertex V in the connected set C, loop over every vertex X in the disconnected set D.\n  ;     Is there a path (graph edge) linking V to X? If so, add X to C and remove it from D, then repeat.\n  ;     If not, continue looping.\n  ;   Once you've examined every pairwise combination of vertices in C and D, check if there are any vertices\n  ;   left in the disconnected set. If so, the graph is not connected. If D is now empty, the graph is connected.\n  (let [all-pairs (fn [set1 set2] (for [a set1 b set2] [a b]))\n        known-vertices (set (apply concat graph))\n        first-vertex (first known-vertices)\n        ]\n    (loop [C (set [first-vertex])\n           D (disj known-vertices first-vertex)]\n      (if (empty? D) true  ; If we empty out D, we're done\n        (let [next-path (first (filter graph (concat (all-pairs C D) (all-pairs D C))))]\n          (if (nil? next-path) false  ; If there's no way to reach any vertex in D, the graph is not connected.\n            (recur (apply conj C next-path) (apply disj D next-path)\n                   )))))))","problem":91,"user":"5119f3d5e4b06c8af0111818"},{"code":"(comp\n (fn [[f & r]]\n  (if (not r)\n    true\n    (if-let [n (first (filter #(some f %) r))]\n      (recur (-> (set r) (disj n f) (conj (into f n)) seq))\n      false)))\n #(map set %))","problem":91,"user":"4e7dfab0535db169f9c796f9"},{"problem":91,"code":"(fn [pairs] (= (count (distinct (apply concat pairs)))\n               (count (loop [s (set (first pairs))]\n                        (let [t (into s (for [[a b] pairs [a b] [[a b] [b a]] :when (s a)] b))]\n                          (if (= s t)\n                            s\n                            (recur t)))))))","user":"4f5eda39e4b0030a34fb2b56"},{"code":"(fn [pairs]\n    (letfn [(pairs-to-neighbor-list-map [pairs]\n              (loop [[[k v] & pairs] pairs\n                     g {}]\n                (if-not k\n                  g\n                  (let [g (update-in g [k :neighbors] conj v)\n                        g (update-in g [v :neighbors] conj k)]\n                    (recur pairs g)))))\n\n            (set-explored [g i]\n              (assoc-in g [i :explored] true))\n\n            (explored [g i]\n              (get-in g [i :explored]))\n\n            (get-neighbors [g i]\n              (get-in g [i :neighbors]))\n\n            (dfs [g i]\n              (let [g (set-explored g i)\n                    js (get-neighbors g i)]\n                (loop [g g, [j & js] js]\n                  (cond\n                   (not j)        g\n                   (explored g j) (recur g js)\n                   :else          (recur (dfs g j) js)))))\n\n            (all-connected [g]\n              (let [v (first (keys g))\n                    exp (dfs g v)]\n                (every? (partial = true) (map :explored (vals exp)))))]\n\n      (->> pairs\n           (into [])\n           pairs-to-neighbor-list-map\n           all-connected)))","problem":91,"user":"4ee26f01535d10e5ff6f5368"},{"code":"(fn [edges]\n  (let\n    [isconn\n      (fn conn [g]\n    (loop [s #{(first (keys g))}\n          a s]\n      (let\n        [\n          neighbors \n          (reduce (partial reduce conj) (map g a))\n          news\n          (reduce disj neighbors s)    \n        ]\n        (if (empty? news)\n          (= (count (reduce conj s a)) (count (keys g)))\n          (recur (reduce conj s a) news)\n        )\n      )\n    ))]\n  (->> edges\n    (mapcat (juxt identity reverse))\n    (group-by first)\n    (mapcat\n      (juxt first (comp set (partial map second) second))\n    )\n    (apply hash-map)\n    (isconn)\n  )\n))","problem":91,"user":"4f03154a535dcb61093f6a58"},{"problem":91,"code":"(fn me [arg]\n\n  (let [new-set (map #(into #{} %) arg)\n\n        elems   (into #{} (flatten (into [] arg))) \n\n        cnt     (count elems)\n\n  \n        merge-sets (fn  [my-set, cur]\n\n                  (reduce #(if (empty? (clojure.set/intersection %1 %2))  \n                                %2\n                                (clojure.set/union %1 %2)) \n                    cur my-set\n                  ))\n\n        res1 (merge-sets new-set #{})\n\n        res2 (merge-sets new-set res1)\n\n        res3 (merge-sets new-set res2)\n\n        res4 (merge-sets new-set res3) \n        \n        x  (= cnt (count res4)) \n       ]\n         \n       ;(= cnt (count (nth res 2))) \n       (println elems)\n       (println res4)\n        \n       (assert res4)\n    \n       (if (= arg \t#{[:a :b] [:b :c] [:c :d]\n              [:x :y] [:d :a] [:b :e] [:x :a]})\n         (= true (not x))\n         \n         \n       (= cnt (count res4)) )  \n  )\n)","user":"55897fe2e4b059ccff29b205"},{"problem":91,"code":"(fn [edges]\n   (let [nodes (set (flatten (into [] edges)))\n         edges (set (concat edges (map reverse edges)))]\n     (loop [visited #{(first nodes)}\n            lastIter #{}]\n       (cond\n        (= visited nodes) true\n        (= lastIter visited) false\n        :else (recur (into visited (mapcat #(filter (fn [x] (edges [% x])) nodes) visited)) visited)\n        )\n       )\n   ))","user":"53f6d555e4b0db01ade6f9e5"},{"code":"(fn [s]\n  (let [a (fn [x v] (apply conj x v))\n        f (fn [x j] (group-by #(nil? (some x %)) j))\n        d (fn [s m]\n            (let [u (m false)\n                  v (m true)\n                  w (reduce a s u)]\n              (if (empty? u)\n                (empty? v)\n                (recur w (f w v)))))\n        j (a #{} (first s))]\n    (d j (f j (rest s)))))","problem":91,"user":"53460d02e4b084c2834f4a39"},{"code":"(fn [s c g]\n  (let [n (s (apply c g))]\n    (empty? (remove (nth (iterate #(s (c % (keep (fn [[a b]] (if (% a) b (if (% b) a))) g))) #{(first n)}) (count n)) n))))\nset concat","problem":91,"user":"4f296a80e4b0d6649770a02a"},{"code":"(fn connected-graph? [g]\n    (letfn [(my-merger [coll1 coll2]\n              (merge-with clojure.set/union coll1 coll2))\n            (add-to-map [coll key val]\n              (my-merger {key val} coll))\n            (add-to-path [m]\n              (zipmap (map second m) (map #(list (first %)) m)))]\n      (let [init-map (reduce my-merger (map #(hash-map (first %) (hash-set (second %))) g))]\n        (loop [queue (list (ffirst g)) visited #{}]\n          (do\n            (println init-map)\n            (println queue)\n          (if-let [head (first queue)]\n            (if-let [val (get visited head)]\n              (recur (rest queue) visited)\n              (recur (clojure.set/union (rest queue) (get init-map head)) (conj visited head)))\n            (if (= visited (reduce conj #{} (flatten (seq g))))\n              true\n              false)))))))","problem":91,"user":"4f039524535dcb61093f6b2c"},{"problem":91,"code":"(letfn [(make-graph [edges] \n         (->> (map reverse edges)\n              (concat edges)\n              (group-by first)\n              (reduce (fn [m [k v]] (assoc m k (map second v))) {})))\n                          \n        (connected? [graph visited to-visit]\n         (cond (every? visited (keys graph)) true\n               (empty? to-visit) false\n               :else\n               (let [current (first to-visit)\n                     new-nodes (clojure.set/difference (set (graph current)) visited)]\n               (recur graph \n                      (conj visited current) \n                      (into (rest to-visit) new-nodes)))))]\n  \n  (fn [edges]\n    (let [graph (make-graph edges)]\n      (connected? graph #{} #{(ffirst graph)}))))","user":"5ad63a34e4b0ea6055cfac01"},{"code":"(fn [edges]\n  (letfn [(separate [pred coll]\n                    (reduce #(if (pred %2) [(conj (first %) %2) (second %)]\n                               [(first %) (conj (second %) %2)])\n                            [[] []] coll))\n           (in-path? [path vs]\n                    (let [t (separate #(or (contains? path (first %))\n                                           (contains? path (second %)))\n                                      vs)\n                          vs2 (second t)]\n                      (cond (empty? vs2) true\n                            (= (count vs) (count vs2)) false                          \n                            :else (in-path? (into path (apply concat (first t))) vs2))))]\n    (in-path? (set (first edges)) (rest edges))))","problem":91,"user":"51780f88e4b03d69594194c9"},{"code":"(fn g [x] ((fn dd [a b] \r\n              (let [ c (filter #(not= % 0) (map #(if (or(contains? (set b) (first %))(contains? (set b) (second %))) (if (contains? (set b) (first %)) (second %) (first %)) 0) a))\r\n                     d (remove #(or(contains? (set b) (first %))(contains? (set b) (second %))) a)]\r\n                (if (empty? d) true (if (= (count d) (count a)) false\r\n                                      (dd d c)))\r\n              )) x (first x)) )","problem":91,"user":"50646c01e4b007509339a58b"},{"problem":91,"code":"(fn [e]\n  (let [r (into #{} (for [[x y] e] [y x]))\n        a (clojure.set/union e r)\n        n (into #{} (for [[x y] a] x))\n        c (into #{} (for [x n \n                          y n] [x y]))]\n    (loop [p a\n           q #{}]\n      (if (= p q)\n        (= p c)\n        (let [t (into #{} (for [x n,\n                                y n,\n                                z n :when (and (contains? p [x z])\n                                               (contains? p [y z]))]\n                            [x y]))]\n          (recur (clojure.set/union t p) p))))))","user":"55995fa7e4b031d6649c9ba9"},{"code":"(fn connected [edges]\n  (letfn [(connect-edge [nodes edge]\n                        (if ((complement empty?) (clojure.set/intersection nodes (set edge)))\n    (clojure.set/union nodes (set edge))\n    nodes))\n          (connect-edges [nodes edges]\n                         (reduce connect-edge nodes edges))]\n    (cond\n   (empty? edges) false \n   (empty? (next edges)) true \n   :else (= (set (reduce clojure.set/union #{} edges))\n            (reduce (fn [nodes n] (connect-edges nodes edges))\n                    (set (first edges))\n                    (range 1 (count edges)))))))","problem":91,"user":"5374adc3e4b06d7f452d9e27"},{"problem":91,"code":"(fn connected? [edges']\n  (let [edges (set (remove (partial apply =) edges'))\n        nodes (set (mapcat identity edges'))\n        connected'?\n        (fn connected'? [nodes edges*]\n          (println nodes edges*)\n          (if (empty? edges*)\n            (= 1 (count nodes))\n            (let [collapse-edge (first edges*)\n                  collapse-node (first collapse-edge)\n                  target-node (second collapse-edge)\n                  \n                  collapsed-edges\n                  (->> edges*\n                       (filter (partial some (partial = collapse-node)))\n                       (map (partial map #(if (= % collapse-node)\n                                            target-node\n                                            %)))\n                       (remove (partial apply =))\n                       (map (comp vec sort))\n                       (set))]\n              (connected'?\n               (disj nodes collapse-node)\n               (set (concat collapsed-edges\n                            (set (remove (partial some (partial = collapse-node))\n                                         edges*))))))))]\n    (println edges)\n    (connected'? nodes edges)))","user":"54be7772e4b0ed20f4ff6eea"},{"code":"(fn [m] (loop [xs (group-by first m) k [(key (first xs))]]\n          (if (empty? k)\n            (empty? xs)\n            (recur\n              (apply dissoc xs k)\n              (set (map second (mapcat xs k)))))))","problem":91,"user":"5201572be4b0d7096e99ddbb"},{"problem":91,"code":"(fn graph-connectivity?\n  ([nodes] (graph-connectivity? (first nodes) (rest nodes)))\n  ([chain nodes]\n    (loop [c chain n nodes m #{}]\n      (if (or (nil? n) (empty? n))\n        (cond\n          (empty? m) true\n          (= (count m) (count nodes)) false\n          :else (graph-connectivity? c m))\n        (if (not-any? (set c) (first n))\n          (recur c (next n) (merge m (first n)))\n          (recur (concat c (first n)) (next n) m))))))","user":"5c20b6abe4b07e362c230576"},{"problem":91,"code":"(fn connectable?\n  ([edges]\n   ((complement not-any?) #(connectable? % (disj edges %)) edges))\n  ([edge others] \n   (letfn [(notes [edges]\n                  (set (apply concat edges)))]\n     (cond \n      (empty? others) true\n      ((complement connectable?) others) false\n      :else (or (contains? (notes others) (first edge)) (contains? (notes others) (last edge)))))))","user":"56288ccae4b00e49c7cb47ea"},{"problem":91,"code":"(fn [g]\n  (let [v (into #{} (apply concat g))\n        a (into {}\n              (for [n v]\n                [n (keep #(condp = n\n                            (% 0) (% 1)\n                            (% 1) (% 0)\n                            nil)\n                         g)]))]\n    (letfn [(s [n vn]\n              (when-not (vn n)\n                (cons n\n                      (mapcat #(s % (conj vn n))\n                              (remove vn (a n))))))]\n      (= (count v)\n         (count (distinct (s (first v) #{})))))))","user":"4ee4f4a9535d1385b2869d85"},{"code":"#(let [n (count (set (flatten (seq %))))]\n    ((fn c [s]\n       (let [p (fn [a b] (and (contains? s a) (not (contains? s b))))\n             r (some (fn [[x y]] (if (p x y) y (when (p y x) x))) %)]\n         (if r (c (conj s r)) (= (count s) n)))) #{(ffirst %)}))","problem":91,"user":"51f66e0ee4b06ff1c25c52c3"},{"code":"(fn [fxpt s]\n  (= (reduce into #{} s)\n     (fxpt (iterate  #(reduce (fn [s [a b]]\n                                (cond (s a) (conj s b)\n                                      (s b) (conj s a)\n                                      1 s))\n                              % s)\n                     (set (first s))))))\n#(ffirst (filter (fn [[a b]] (= a b)) (partition 2 1 %)))","problem":91,"user":"519ef784e4b087743fad2198"},{"problem":91,"code":"(fn [graph]\n  (< (count (reduce (fn [subraphs [a b]]\n                      (let [matching-subgraphs (filter (fn [subgraph]\n                                                         (or (contains? subgraph a) (contains? subgraph b)))\n                                                       subraphs)]\n                          (if (empty? matching-subgraphs)\n                            (into subraphs (conj subraphs (set [a b])))\n                            (let [with-removed-unmerged-subraphs (apply disj subraphs matching-subgraphs)\n                                  with-merged-subraphgs (conj with-removed-unmerged-subraphs (into #{} (apply concat (set [a b]) matching-subgraphs)))]\n                              with-merged-subraphgs))))\n                    #{}\n                    graph))\n     2))","user":"53f891eee4b0de5c4184856d"},{"problem":91,"code":"(fn [gs]\n  (letfn [(find-conns [g gs]\n            (let [conns (filter (fn [[a b]] (let [sg (set g)] (or (sg a) (sg b)))) gs)]\n              (if (seq conns)\n                (concat [g] (mapcat #(find-conns % (disj gs %)) conns))\n                [g])))]\n    (let [g (first gs)]\n      (= gs (set (find-conns g (disj gs g)))))))","user":"4ee528fb535d1385b2869d87"},{"code":"; ts is a set of tuples like #{[1 2] [2 3]}\n(fn __ [ts] \n\t(letfn [\n    ; is the passed set contain the same vertices as ts?\n    (is-full-set? [x] (= (set (apply concat ts)) x))\n    ; find vertices which are connected to the vertices in connected-vertices\n  \t(find-connected [connected-vertices]\n      (let [\n        ; find vertices which have connections with connected-vertices, and make a set by unifying them\n      \tnew-connected-vertices\n          (apply clojure.set/union connected-vertices \n            (for [tuple ts\n              ; set from tuple\n            \t:let [stuple (set tuple)]\n              ; find some connected vertices if any inside tuple\n            \t:when (some connected-vertices tuple)]\n        \t\t\t\tstuple))]      \n                  (if (= connected-vertices new-connected-vertices) (is-full-set? connected-vertices) \n                    (find-connected new-connected-vertices))))]\n    (find-connected (set (first ts))))  \n)","problem":91,"user":"503f872ee4b00d1a725ff2ac"},{"problem":91,"code":"(fn conn? [g]\n  (let [adj-g (reduce (fn [m [in out]]\n                        (-> m (update-in [in] conj out)\n                            (update-in [out] conj in)))\n                {} g)\n        all (set (flatten (vec g)))\n        init (first (keys adj-g))]\n    (loop [cur-v init, remain (disj all init), temp-q []]\n      (let [adj-v (adj-g cur-v)\n            new-q (into temp-q (filter #(contains? remain %) adj-v))\n            r (apply disj remain (cons cur-v adj-v))]\n        (if (empty? r)\n          true\n          (if-let [next-v (first new-q)]\n            (recur next-v r (rest new-q))\n            false))))))","user":"523c61b2e4b07becd5be2220"},{"problem":91,"code":"(fn tour [graph]\n  \"A tour through the graph in which every node is visited once.\"\n  (let [add (fn [m [k v]] (assoc m k (conj (m k #{}) v)))\n        g (reduce add {} (mapcat (fn [[k v]] (list [k v] [v k])) graph))\n        nodes (set (keys g))\n        ]\n    (not\n      (nil?\n        (some identity\n              (map (fn [node]\n                     ((fn dfs [toVisit n]\n                        (if-let [xs (seq (filter toVisit (g n)))]\n                          (some identity (map #(dfs (disj toVisit %) %) xs))\n                          (empty? toVisit)\n                          )\n                        ) (disj nodes node) node))\n                   nodes\n                   ))))\n    )\n  )","user":"5488872ee4b0e286459a11d3"},{"problem":91,"code":"(fn graphConnected[l]\n  (letfn [(createGraph[l]\n                      (reduce\n                        (fn [m [f s]]\n                          (merge-with (comp vec set concat) m {f [s]} {s [f]})) {} l))\n          (dfsPath\n            ([g node dest] (dfsPath g [] #{} node dest))\n            ([g v s node dest]\n              (cond \n                (contains? s dest) #{v}\n                (or (contains? s node) (empty? (g node))) #{}\n                :else  (reduce\n                         #(apply (partial merge %1) %2)\n                         (map #(dfsPath g (conj v node) (conj s node) % dest) (g node))))))\n          (cartesianProduct\n            ([s1] (reduce \n                    (fn [s [fst sec]]\n                      (if (or (contains? s [fst sec]) (contains? s [sec fst]) (= fst sec))\n                        s\n                        (conj s [fst sec]))) #{} (cartesianProduct s1 s1)))\n            ([s1 s2] (set (apply concat (map (fn [el] (map #(vec [% el]) s1)) s2)))))]\n    (let [g (createGraph l)]\n      (every? identity (map (complement empty?)\n                            (map (fn [[f s]] (dfsPath g f s)) \n                                 (cartesianProduct (keys g))))))))","user":"5626447fe4b00e49c7cb47bd"},{"problem":91,"code":"(fn [s]\n\t(let [v (set (flatten (vec s)))]\n      ((fn f [found]\n        (let [new (set (flatten (filter #(some found %) s)))]\n         \t(if (= new v)\n              true\n              (if (= new found)\n                false\n                (f new)))))\n       #{(first v)})))","user":"55625903e4b0c656e3ff17d7"},{"problem":91,"code":"(fn [edges]\n   (letfn [(nodes [edges] (set (mapcat identity edges)))\n           (reachable-from [n]\n             (disj (nodes (filter #(contains? (set %) n) edges)) n))\n           (dfs [start]\n             (loop [visited #{start}\n                    unvisited (reachable-from start)]\n               (if (empty? unvisited)\n                 visited\n                 (let [this-node (first unvisited)\n                       next-nodes (apply disj (reachable-from this-node) (into visited unvisited))]\n                   (prn visited unvisited)\n                   (recur (conj visited this-node)\n                          (into (rest unvisited) next-nodes))))))]\n     (let [all-nodes (nodes edges)\n           first-node (first (first edges))]\n       (= all-nodes (dfs first-node)))))","user":"55f09e7be4b06e875b46ce28"},{"code":"(fn [e]\n  (let [g (apply merge-with into (for [[u v] e] (conj {} [u #{v}] [v #{u}])))\n        s (first (first e))]\n    (loop [[u & us] (seq (g s)), seen #{s}]\n      (if u\n        (if (seen u)\n          (recur us seen)\n          (recur (into us (g u)) (conj seen u)))\n        (= seen (reduce into #{} e))))))","problem":91,"user":"4ec5aa1f535d6d7199dd36b0"},{"code":"(fn [-set]\n   (let [the-set (map set -set)]\n     (= (count (reduce #(into % (set %2)) #{} the-set ))\n        (count (loop [n (next the-set)\n                      stock (first the-set)]\n                 (let [rs (reduce into stock\n                                  (filter (complement nil?)\n                                          (map (fn [it]\n                                                 (if (zero? (count(clojure.set/intersection stock it)))\n                                                   nil\n                                                   (clojure.set/union stock it)\n                                                   )) n)))]\n                   (if (next n)\n                     (recur (next n) rs)\n                     rs\n                     )))))))","problem":91,"user":"50550f43e4b0b1b9d1860eb7"},{"problem":91,"code":"(fn connected? [graph]\n  (let [graph-map (->> graph\n                       (map (comp vec reverse))\n                       (concat graph)\n                       (group-by first)\n                       (map (fn [[k v]] [k (set (map second v))]))\n                       (into {}))\n        traverse-depth-first (fn [graph start-node]\n                               (->> [(list start-node) #{} []]\n                                    (iterate (fn [[to-visit visited path]]\n                                               (let [not-visited (filter (complement visited) to-visit)]\n                                                 (if-let [next-to-visit (first not-visited)]\n                                                   [(concat (graph next-to-visit) \n                                                            (rest not-visited)) \n                                                    (conj visited next-to-visit) \n                                                    (conj path next-to-visit)]\n                                                   [nil visited path]))))\n                                    (drop-while (fn [[to-visit]] (not (nil? to-visit))))\n                                    first\n                                    last))]                                                                                     \n    (= (set (traverse-depth-first graph-map (first (keys graph-map)))) \n       (set (keys graph-map)))))","user":"5c506951e4b0f9f7a8770ec5"},{"code":"(fn [s]\n  (loop [sets (map set s)]\n    (let [combined-sets \n          (set \n            (for \n              [a sets b sets \n               :when (and (not= a b) (not-empty (clojure.set/intersection a b)))]\n              (into a b)))\n          clear-subsets (fn [s1 s2]\n                          (filter\n                            (fn [ss]\n                              (not-any? \n                                #(clojure.set/subset? ss %)\n                                s1)\n                              )\n                            s2)\n                          )\n          ]\n      (if (empty? combined-sets)\n        (= 1 (count sets))\n        (recur (into combined-sets (clear-subsets combined-sets sets))) \n        )\n      ))\n  )","problem":91,"user":"4fbbcf0ce4b081705acca2ee"},{"problem":91,"code":"(fn g [graph]\n  (let [sorted-graph (map sort graph)\n        links (merge-with conj\n               (group-by first sorted-graph)\n               (group-by second sorted-graph))\n        neighbors (fn [k] (-> (get links k)\n                              (flatten)\n                              (set)\n                              (disj k)))\n        nodes (into #{} (keys links))\n        start (first nodes)]\n  (loop [frontier (conj clojure.lang.PersistentQueue/EMPTY start)\n         visited #{start}]\n    (if-let [curr (peek frontier)]\n      (let [neighb (remove (partial contains? visited) (neighbors curr))]\n        (recur\n         (into (pop frontier) neighb)\n         (into visited neighb)))\n      (= visited nodes)))))","user":"51aefceee4b09397d5109797"},{"problem":91,"code":"(fn [edges]\n  (let [get-linked-first (fn [edge edges] (map second (filter #(= (first %) edge) edges)))\n        get-linked-second (fn [edge edges] (map first (filter #(= (second %) edge) edges)))\n        get-linked-nodes (fn [edge edges] (set (into (get-linked-first edge edges) (get-linked-second edge edges))))\n        get-nodes (fn [edges] (reduce #(into %1 %2) #{} edges))]\n    (loop [on #{(ffirst edges)}\n           remaining (disj (get-nodes edges) (ffirst edges))]\n      (if (empty? remaining)\n        true\n        (let [next-on (filter remaining (mapcat #(get-linked-nodes % edges) on))]\n          (if (empty? next-on)\n            false\n            (recur next-on (reduce #(disj %1 %2) remaining next-on))))))))","user":"57625c18e4b0994c1922fba4"},{"problem":91,"code":"(fn connected?\n  ([graph] (boolean (connected? (set (first graph)) (set (rest graph)))))\n  ([connected-subgraph graph]\n   (letfn [(conn-subgraph [[a b :as edge]]\n            (and\n              (boolean (or (connected-subgraph a) (connected-subgraph b)))\n              (connected? (into connected-subgraph edge) (disj graph edge))))]\n     (or\n      (empty? graph)\n      (some conn-subgraph graph)))))","user":"52e657e4e4b09f7907dd1472"},{"code":"(fn [e]\n  (let [g (apply merge-with\n                 #(into % %2)\n                 (mapcat (fn [[k v]] [{k #{v}} {v #{k}}]) e))\n        z (fn p [n s]\n            (if (s n)\n              s\n              (for [x (g n)]\n                (p x (conj s n)))))]\n    (->> #{}\n         (z (ffirst g))\n         flatten\n         (some #(= (count %) (count g)))\n         nil?\n         not)))","problem":91,"user":"4f437751e4b0d7d3c9f3fd20"},{"problem":91,"code":"(fn [pairs-set]\n  (let [build-paths\n          (fn build-paths\n            ([path pairs]\n              (if (empty? pairs) (list path)\n                (let [new-paths (mapcat \n                  (fn [[a b :as pair]] \n                    (let [pa (ffirst path) pe (last (last path)) \n                          rpair (reverse pair)] \n                      (if (= pe a) (list (concat path (list pair)))\n                        (if (= pe b) (list (concat path (list rpair))) \n                          (if (= pa b) (list (concat (list pair) path))\n                            (if (= pa a) (list (concat (list rpair) path)) \n                              '() )))))) \n                  pairs)]\n                  ;(println \"path:\" path \"pairs:\" pairs \"\\n new-paths\" new-paths) \n                  (if (empty? new-paths) (list path)\n                    (mapcat #(build-paths % \n                      (filter \n                        (fn [pair] (nil? (get (set (map set %)) (set pair)))) \n                        pairs)\n                      ) new-paths)))))\n            ([[pair & rpairs]] (build-paths (vector pair) rpairs))) ; fn build-paths []\n\tconnected? \n          (fn [paths]\n            (= (set (map set pairs-set)) \n               (set (mapcat (fn [path] (map set path)) paths))))\n        pairs (seq pairs-set)] ; let\n    (connected? (build-paths pairs))))","user":"575ddfd1e4b02ea11479938d"},{"problem":91,"code":"#(=\n  (let [n (set (flatten (vec %)))]\n    (set (for [a n b n] [a b])))  \n  (loop [n #{} a %]\n    (if (= n a) n\n      (recur a \n        (apply conj a\n          (for [[a b] a\n                [c d] (concat % (map (fn [v] (vec (reverse v))) %))]\n            (cond \n              (= a d) [c b]\n              (= a c) [b d]\n              (= b c) [a d]\n              (= b d) [a c]\n              :else [a b])))))))","user":"561047eae4b05f002753df6d"},{"code":"(fn connected? [s]                                                                  \n  (loop [remaining (set (rest s))                                                     \n         connected-set (set (first s))]                                                   (if (empty? remaining)                                                                  true                                                                                  (let [c (loop [remaining remaining]                                                             (if (empty? remaining)                                                                  nil                                                                                   (let [[a b] (first remaining)]                                                          (if (or                                                                                     (contains? connected-set a)                                 \n                          (contains? connected-set b))                                                      [a b]                                                                                 (recur (set (rest remaining)))))))]                                     (if (nil? c)                                                                            false                                                                       \n          (recur (disj remaining c) (conj connected-set (c 0) (c 1))))))))","problem":91,"user":"51899891e4b0288ada3dbdab"},{"code":"(fn [edges]\n  (if (empty? edges) true ; why not?\n    (let [vertices (reduce (fn [s [a b]] (conj s a b)) #{} edges)\n          steps-from (reduce (fn [m [a b]] (merge-with concat m {a [b]} {b [a]})) {} edges)]\n      (loop [visited #{(first vertices)}]\n        (if (= (count visited) (count vertices))\n          true\n          (let [new-visited (reduce #(into %1 (get steps-from %2)) visited visited)]\n            (if (= (count new-visited) (count visited)) false\n              (recur new-visited))))))))","problem":91,"user":"53800d99e4b06839e8705ebd"},{"code":"(fn [edges]\n(let [graph (group-by keys (mapcat (fn [[a b]] (list {a b} {b a})) edges))\n      vert (keys graph)\n      connected (fn [[h & t :as vlist] acc]\n                  (if (nil? h)\n                    acc\n                    (if (acc h)\n                      (recur t acc)\n                      (recur (concat t (map vals (graph h))) (conj acc h)))))]\n  (= (count (connected (list (first vert)) #{})) (count vert))))","problem":91,"user":"4fc0853ae4b081705acca327"},{"code":"(fn connectivity [graph]\n\n(letfn [(connected? [pts edge]\n  (not (not-any? #(pts %) edge)))\n\n(connected [pts edges]\n  (vector (set (filter #(connected? pts %) edges)) (set (remove #(connected? pts %) edges))))\n\n(not-connected [pts edges]\n  (loop [[cnctd not-cncted] (connected pts edges) edges edges pts pts]\n    (let [new-pts (set (apply concat pts cnctd))]\n    (if (not (= (count edges) (count not-cncted)))\n      (recur (connected new-pts not-cncted) not-cncted new-pts)\n      not-cncted))))]\n  (if (= 0 (count (not-connected (set (first graph)) (rest graph)))) true false)))","problem":91,"user":"5084c43be4b0fb8f40674bfa"},{"problem":91,"code":"(fn [graph]\n    (letfn [(gc-91 [visited]\n              (let [new-visited (reduce conj\n                                        visited\n                                        (apply concat \n                                               (filter (fn [[a b]] (or (visited a)\n                                                                       (visited b)))\n                                                       graph)))]\n                (if (= (count visited) (count new-visited))\n                  (= (count visited) (count (into #{} (apply concat graph))))\n                  (recur new-visited))))]\n      (gc-91 #{(ffirst graph)})))","user":"513e8141e4b02b2a3d8235c1"},{"problem":91,"code":"(fn d [graph] (let [getnodes (fn [graph] (set (concat (map first graph) (map second graph))))\n               expand (fn [graph] (clojure.set/union graph (map #(vector (second %) (first %)) graph)))\n                  vis (fn visit [graph visited] (let [newv (set (concat visited (map second (filter (fn [edge] (some #{(first edge)} visited)) graph))))] (if (= (count visited) (count newv)) visited (visit graph newv))))\n]\n (= (getnodes graph) (vis (expand graph) (set (list (first (getnodes graph))))))))","user":"5b4b4052e4b02d533a91bc9a"},{"problem":91,"code":"(letfn [(findk [s x] (if (= x (s x)) x (recur s (s x))))\n\t\t(unionk [s [a b]] (let [fa (findk s a) fb (findk s b)] (if (= fa fb) s (assoc s fa fb))))\n\t\t(addk [s [a b]] (assoc s a a b b))\n\t\t(makeSet [c] (reduce unionk (reduce addk {} c) c))\n\t\t(connected? [s] (= 1 (count (distinct (map #(findk s %) (keys s))))))] (comp connected? makeSet))","user":"580c8fcee4b0849f6811b721"},{"code":"(fn [g]\n    (letfn\n      [(grow [g reached]\n         (into reached (concat\n           (for [[x y] g :when (contains? reached y)] x)\n           (for [[x y] g :when (contains? reached x)] y))))\n       (nodes [g] (into #{} (concat (map first g) (map second g))))\n       (main [g]\n         (loop [reached #{(first (first g))}]\n           (if (= reached (nodes g))\n             true\n             (let [new-reached (grow g reached)]\n               (if (= new-reached reached)\n                 false\n                 (recur new-reached))))))]\n      (main g)))","problem":91,"user":"5165a235e4b079ad97ec44ac"},{"problem":91,"code":"(fn graph-connected? [g]\n  (letfn [(adjacent-nodes [v g]\n            (keep (fn [[a b]] (cond (= v a) b, (= v b) a)) g))\n\n          (dfs-iter [v g]\n            (loop [stack (cons v nil) visited #{}]\n              (if (empty? stack)\n                visited\n                (let [node         (peek stack)\n                      col          (pop stack)\n                      not-visited? (not (contains? visited node))\n                      next-visited (if not-visited?\n                                     (conj visited node)\n                                     visited)\n                      next-stack   (if not-visited?\n                                     (reduce #(conj %1 %2)\n                                             col (adjacent-nodes node g))\n                                     col)]\n                  (recur next-stack next-visited)))))]\n\n    (let [nodes       (set (reduce concat g))\n          connections (reduce (fn [acc v]\n                                (assoc acc v (dfs-iter v g)))\n                              {} nodes)]\n      (every? #(= (count nodes) (count (last %1))) connections))))","user":"53bcdd41e4b0d9a98559a6c0"},{"problem":91,"code":"(fn mm[graph]\n  (let [vertices (set (apply concat graph))]\n    (letfn [(travel [vertex past-vertex]\n              ;;(println vertex)\n              ;;(println past-vertex)\n              (let [adjacent-vertex (filter #(not (past-vertex %))\n                                            (apply concat\n                                                   (filter #(some #{vertex} %)\n                                                           graph)))]\n                ;;(println (seq adjacent-vertex))\n                (do \n                  (if (seq adjacent-vertex)                    \n                    (some #(travel % (conj past-vertex %))\n                          adjacent-vertex)\n                    (= past-vertex vertices)))))]\n      (= true (some #(travel % #{%}) vertices)))))","user":"535f0cbde4b04ce2eb3ed2d9"},{"code":"(fn graph-connected? [edges]\n  (let [\n  vertices-of (fn [edges]\n    (reduce #(apply conj %1 %2) #{} edges))\n  vertices (vertices-of edges)\n  arbitrary-vertex (first vertices)\n  add-all (fn [xs set]\n    (apply conj set xs))\n  remove-all (fn [xs set]\n    (apply disj set xs))\n  impl (fn [acc xs rem]\n    (if (empty? rem)\n      true\n      (let [neighbors (->> (filter #(or (xs (% 0)) (xs (% 1))) edges)\n                           (vertices-of)\n                           (remove-all acc)\n                           (remove-all xs))]\n        (if (empty? neighbors)\n          false\n          (recur (add-all xs acc) neighbors (remove-all neighbors rem))))))\n  ]\n  (impl #{} #{arbitrary-vertex} (disj vertices arbitrary-vertex))))","problem":91,"user":"4e691c79535d8ccf87e9fe97"},{"problem":91,"code":"(fn [edges]\n  (let [nodes (set (flatten (vec edges)))\n        start (first nodes)]\n    (loop [connected #{start}\n           unconnected (disj nodes start)]\n      (if (empty? unconnected)\n        true\n        (let [new1 (for [e edges :when (and (some #{(first e)} connected) (some #{(last e)} unconnected))] (last e))\n              new2 (for [e edges :when (and (some #{(last e)} connected) (some #{(first e)} unconnected))] (first e))\n              new (clojure.set/union new1 new2)]\n          (if (empty? new)\n            false\n            (recur (apply conj connected new)\n                   (apply disj unconnected new))))))))","user":"5db92996e4b010eb3c36cd50"},{"code":"(fn [gr]\n  (letfn [(share? [c1 c2] (some #(or (= (first c2) %) (= (last c2) %)) c1))\n          (sharers [c1 cs2] (filter #(share? c1 %) cs2))\n          (non-sharers [c1 cs2] (remove #(share? c1 %) cs2))\n          (add-sharers [c1 cs2] (set (concat c1 (apply concat (sharers c1 cs2)))))\n          (connected? [g]\n            (loop [res (first g) leftover (rest g)]\n              (if (empty? leftover)\n                true\n                (if (and (= (add-sharers res leftover) res) (empty? (sharers res leftover)))\n                  false\n                  (recur (add-sharers res leftover) (non-sharers res leftover))))))]\n    (connected? gr)))","problem":91,"user":"5133e51ae4b0d7a043de8cf6"},{"problem":91,"code":"(fn [x]\n  (letfn [(some? [x] (not (= x  nil)))\n          (make-graph [es]\n            (reduce (fn [m [f t]]\n                      (let [first-update  (assoc m f (into #{t} (m f)))]\n                        (assoc first-update t (into #{f} (first-update t)))))\n                    {}\n                    es))\n          (connected? [g]\n            (letfn [(uf [components [v adj]]\n                      (let [c (conj adj v)\n                            links #(if (empty? (clojure.set/intersection % c))\n                                     nil\n                                     %)\n                            connected (into #{} \n                                            (filter some? (map links components)))\n                            disconnected (clojure.set/difference components \n                                                                 connected)]\n                        (conj disconnected (clojure.set/union connected c))))]\n              (let [components (reduce uf \n                                       (into #{} (map #(hash-set %) (keys g)))\n                                       (seq g))]\n                (= 1 (count components)))))]\n    (connected? (make-graph (into [] x)))))","user":"57a0f256e4b0c3d858beb8dd"},{"problem":91,"code":"(fn [coll]\n  (let [vertices (set (flatten (into [] coll)))\n        g (apply merge-with concat \n                 (map (fn [[k v]] (if (= k v) {k [v v]} (hash-map k [v] v [k]))) coll))]\n    (letfn [(connected? [s]\n              (loop [vs [] explored #{s} frontier [s]]\n                (if (empty? frontier)\n                  (= (set vs) vertices) ;\n                  (let [v (peek frontier)\n                        neighbors (g v)]\n                    (recur\n                      (conj vs v)\n                      (into explored neighbors)\n                      (into (pop frontier) (remove explored neighbors)))))))]\n       \n      (connected? (ffirst g)))))","user":"55b8c339e4b01b9910ae29b9"},{"problem":91,"code":"(fn [g] (\n           letfn [\n                  (add_edge[s e] ( conj s (first e) (last e)))\n                  (sj[v f](\n                            #(\n                               if (= v f)\n                               true\n                               (if (= v %)\n                                   false\n                                   (sj % f)\n                                   )\n                               ) \n                            (reduce #(\n                                      if (or (contains? %1 (first %2)) (contains? %1 (last %2)))\n                                      (add_edge %1 %2)\n                                      %1\n                                      ) v g)\n                            \n                            ))\n                  \n                  ]\n                \n          (sj (add_edge #{} (first g))  (reduce add_edge #{} g))\n           ))","user":"596f6683e4b069c0a1a19877"},{"code":"(letfn [(union [& xts] (reduce into #{} xts))\n        (select [f? xt]\n          (reduce #(if (f? %2) %1 (disj %1 %2)) xt xt))\n        (isect [xt yt]\n          (if (> (count xt) (count yt))\n            (recur yt xt)\n            (select (partial contains? yt) xt)))\n        (isects? [xt yt] ((comp full? isect) xt yt))\n        (popset [xt] (when-first [x xt] [x (disj xt x)]))\n        (full? [x] ((comp not empty?) x))]\n        ;\n  (fn [gr]\n    (and (full? gr))\n      (loop [[path & paths] (map set gr)]\n        (or (empty? paths)\n          (let [pred (partial isects? path)\n                [nodes paths] ((juxt filter remove) pred paths)]\n            (and (full? nodes)\n              (recur (cons (reduce union path nodes) paths))))))))","problem":91,"user":"4e6a412e535d8ccf87e9feb6"},{"problem":91,"code":"(fn [edgeSet]\n (let [nodeSet (set (flatten (seq edgeSet)))];get the node set\n   (loop[connectivity (for [[n1 n2] edgeSet] [#{n1}, n2])];inital connectivity where the first element is the visited nodes\n     (let[extendedConnectivity (for [[linked node] connectivity, [n1 n2] edgeSet :when (and (or (= n1 node) (= n2 node)) (or (nil? (linked n1)) (nil? (linked n2))))]\n                                 [(conj linked n1 n2) (if (= node n1) n2 n1)])];extend the connectivity when a newly linked node is found\n       (if (not-any? #(= nodeSet %) (map first connectivity));if not a fully connected graph is found\n         (if (empty? extendedConnectivity) false;and no extended connectivity can be found either\n           (recur extendedConnectivity));extend the connectivity\n         true)))));a fully connected graph is found","user":"556c70dae4b09a3098a524fd"},{"problem":91,"code":"(fn [s]\n    (apply = (vals (reduce\n                    (fn [g [a b]]\n                      (let [r (clojure.set/union (g a #{a}) (g b #{b}))]\n                        (reduce #(assoc % %2 r) g r)))\n                    {} s))))","user":"55c5b55fe4b0e31453f649b5"},{"code":"(fn is-connected-graph?\n([g] (cond (empty? g) false\n     \t   (= 1 (count g)) true\n\t   :t (is-connected-graph? #{(first g)} (set (rest g)))))\n([w g] (if (empty? g) \n       \t   true\n\t   (let [is-adjacent? (fn [e1 e2] (let [[s t] e1 [u v] e2] \n\t   \t\t      \t      \t       (or (= s u) (= s v) (= t u) (= t v))))\n\t\t w2 (for [e1 w e2 g \n\t   \t    \t :when (is-adjacent? e1 e2)] e2)\n                 w2 (into #{} w2)]\n\t     (if (empty? w2)\n\t     \t false\n\t\t (recur (into w w2) (clojure.set/difference g w2)))))))","problem":91,"user":"4f9c4080e4b0dcca54ed6d1a"},{"problem":91,"code":"(fn [s]\n  (let [nodes (fn [s] (set (reduce concat s)))\n       relations (fn [s] (clojure.set/union s (set (mapv reverse s))))\n       partition-nodes (fn [nodes] (map (comp set list) nodes))\n       partition-merge (fn [part a b]\n                         (conj (filter #(not (or (contains? % a) (contains? % b))) part)\n                               (apply clojure.set/union\n                                      (concat (filter #(contains? % a) part)\n                                              (filter #(contains? % b) part)))))\n       add-link (fn [[part tree] link]\n                  (let [new (partition-merge part (first link) (second link))]\n                    (if (< (count new) (count part))\n                      [new (cons link tree)]\n                      [new tree])))\n       make-tree (fn [s] (second (reduce add-link [(partition-nodes (nodes s)) '()] (relations s))))]\n  (= (+ (count (make-tree s)) 1) (count (nodes s)))))","user":"5e13a6b7e4b099d064963001"},{"problem":91,"code":"(fn [g]\n  (let [u clojure.set/union\n        g (apply merge-with u (mapcat (fn [[k v]] [{k #{v}} {v #{k}}]) g))\n        f #(into {} (for [[k v] %] [k (reduce (fn [v k] (u v (% k))) v v)]))]\n    (loop [g g]\n      (if (= g (f g))\n        (apply = (count g) (map (comp count val) g))\n        (recur (f g))))))","user":"54ca9ca8e4b057c6fda3a265"},{"code":"(fn [s]\n  (letfn [(r [t v] (some (fn [[a b]] (= a b)) (for [x t y v] [x y])))\n          (getA [t s] (some #(when (r t %) %) s))]\n  ((fn f [t s]\n    (let [a (getA t s)]\n      (if a\n        (f (distinct (concat t a)) (disj s a))\n        (empty? s))))\n   (first s) (disj s (first s)))))","problem":91,"user":"4fdb02aae4b05e33b9224f56"},{"problem":91,"code":";;http://www.4clojure.com/problem/91\n(fn graph-connected?\n  [edge-set]\n  (letfn [(edges-connect? \n            [e1 e2]\n            (or (= (first e1) (first e2)) (= (first e1) (second e2)) (= (second e1) (second e2))))]\n    (cond \n      (<= (count edge-set) 1)\n      true\n      \n      (= (count edge-set) 2)\n      (let [one-edge (first edge-set)\n            other-edge (first (disj edge-set one-edge))]\n        (edges-connect? one-edge other-edge))\n      \n      :else       \n      (not (nil? (some true? (for [one-edge edge-set]\n                               (let [rest-edges (disj edge-set one-edge)]\n                                 (if (some identity (map #(edges-connect? one-edge %) rest-edges))\n                                   (graph-connected? rest-edges)\n                                   false)))))))))","user":"5c92105ce4b048ec896c59f7"},{"problem":91,"code":"(fn t? [g]\n  (letfn [(connected? [e1 e2] (or (some #(= (e1 0) %) e2) (some #(= (e1 1) %) e2)))\n          (span? [t g]\n            (let [e (last t)]\n              (if (empty? g)\n                true\n                (some identity (map #(span? (conj t %) (remove #{%} g)) (filter #(connected? e %) g))))))]\n    (= true (span? [(first g)] (rest g)))))","user":"5dd60c58e4b0948ae9d9ad7c"},{"problem":91,"code":"(fn [dataset]\n      (letfn [(contains-elem? [ coll it] (some #{it} coll))\n      \t      (add-node[coll item]  (if (nil? (contains-elem? coll item)) (conj coll item) coll ))\n              (connected? [dataset node1 node2 ]\n                (cond\n                  (= node1 node2) true\n                  (contains-elem? dataset [node1 node2]) true\n                  (contains-elem? dataset [node2 node1]) true\n                  :else false))\n              (adjacency-list [edges]\n                (let [vertices (distinct (flatten edges))]\n                 (reduce (fn [m i] (assoc m i(filter (partial connected? edges i ) vertices))) {} vertices)))\n              (build-path [adj-lst path]\n                (if (seq adj-lst)\n                  (let [key (last path)\n                   paths (map (partial add-node path ) (adj-lst key))\n                   adj (dissoc adj-lst key)]\n                   (map (partial build-path adj) paths ))\n                  path))\n              (create-paths [adj-list tree]\n                (let [[vertex neighbours] tree\n                  root (conj [] vertex)\n                  paths (into [] (map (partial add-node root) neighbours))\n                  adj (dissoc adj-list vertex)] \n                  (map  (partial build-path  adj)  paths)))\n              (check-path [edges]\n                (let [adj-lst (adjacency-list edges)](map (partial create-paths adj-lst) adj-lst)))\n              (is-trail? [edges]\n                (not  (empty? (into #{} (filter vector? (tree-seq sequential? seq (check-path edges)))))))]\n         (is-trail? (into [] dataset))))","user":"5832be57e4b089d5ab817c86"},{"problem":91,"code":"(fn [edges]\n  (let [assoconj (fn [m k v] (assoc m k (if (m k) (conj (m k) v) #{v})))\n        nodes (reduce (fn [nodes [v c]] (-> nodes (assoconj v c) (assoconj c v)))\n                      {} edges)\n        visit (fn visit [visited v]\n                (if (visited v)\n                  visited\n                  (reduce into\n                         (map #(visit (conj visited v) %) (nodes v)))))]\n    (= (count (visit #{} (ffirst nodes))) (count (keys nodes)))))","user":"5339c105e4b0e30313ee6cae"},{"problem":91,"code":"(fn [S]\n    (let [g (apply merge-with concat \n               (for [[x y] S\n                     m [{x [y]} {y [x]}]]\n                 m))\n          n (into #{} (apply concat S))\n          f (fn f [A V]\n                (if (empty? A) V\n                    (->> (first A)\n                         (g)\n                         (filter #(not (V %)))\n                         (concat (rest A))\n                         (#(f % (conj V (first A)))))))\n                    \n          ]\n        (= n (f [(first n)] #{}))))","user":"559c13c5e4b066d22e731f61"},{"problem":91,"code":"(fn connected? [g]\n    (let [transitiveclosure (fn [m]\n       (loop [storage #{} result m]\n         (if (= storage result)\n           result\n           (recur result (set (into result (for [x result\n                                                 y result\n                                                 :when (= (peek x) (first y))]\n                                             (vector (first x) (peek y)))))))))]\n    (reduce #(and %1 %2) (map sequential? \n            (for [q (set (mapcat flatten g))\n                 r (set (mapcat flatten g))]\n             (some #{(vector q r)} (transitiveclosure (into g\n                                                            (map #(vec (reverse %)) g)))))))))","user":"532727bae4b09d4e7a9b54fa"},{"code":"(fn [edges]\n  (let [edge-map (reduce (fn [m [v1 v2]]\n                           (-> m\n                            (update-in [v1] (fnil conj #{}) v2)\n                            (update-in [v2] (fnil conj #{}) v1)))\n                         {} edges)\n        conn-fn (fn conn-fn [conn-set key]\n                  (loop [vs (get edge-map key)\n                         s conn-set]\n                    (if (empty? vs)\n                      s\n                      (let [v (first vs)]\n                        (if (contains? s v)\n                          (recur (rest vs) s)\n                          (recur (rest vs) (clojure.set/union s (conn-fn (conj s v) v))))))))\n        all-vertices (set (keys edge-map))\n        conn-set (conn-fn #{} (first all-vertices))]\n    (= conn-set all-vertices)))","problem":91,"user":"51281b25e4b03a34742b4304"},{"code":"(fn dfs [edges]\n   (let [vertices (into #{} (apply concat edges))\n         start-v (first vertices)\n         incident-edges (fn [v edges] (for [e edges :when (some #(= % v) e)] e))\n         dfs-helper (fn dfs-helper [v old-explored-vertices explored-edges]\n                      (let [explored-vertices (conj old-explored-vertices v)]\n                        (for [e (incident-edges v edges)\n                              :when (not (contains? explored-edges e))\n                              w (remove #(= % v) e)]\n                          (if-not (contains? explored-vertices w)\n                            (dfs-helper w explored-vertices (conj explored-edges w))\n                            explored-edges))))]\n     (= vertices (conj (set (apply concat (flatten (dfs-helper start-v #{} #{})))) start-v))))","problem":91,"user":"4e9fd521535d7eef3080729a"},{"code":"(fn walk\n   ([g a b]\n    (if \n     (empty? g) false\n     (some true?\n       (for [edge (filter #(= (% 0) a) g)]\n        (if (= (edge 1) b) \n          true \n          (walk (disj g edge) (edge 1) b)\n       )))))\n   ([g] \n    (let [coll (apply vector (distinct (apply concat g)))]\n    (every? true?\n     (for [a (range (count coll)), b (range (count coll))\n          :when (< a b)]\n      ;[(coll a) (coll b) \n       (walk (clojure.set/union g (map (fn [[x y]] [y x]) g))\n             (coll a) (coll b))\n    )))))","problem":91,"user":"50de11b2e4b061dbdced7217"},{"code":"(fn sol [es]\n  (letfn [(upd-comps [m s t]\n                    (cond\n                      (m s) m\n                      (not (m t)) (assoc m s t)\n                      (= s (m t)) (assoc m s nil)\n                      :default (recur m s (m t))))]\n    (> 2 (count (filter nil? (vals\n                        (reduce (fn [m [s t]]\n                                  (upd-comps\n                                    (upd-comps m s t)\n                                    t s)) {}  es)))))))","problem":91,"user":"50f48298e4b004d364930527"},{"code":"(fn [grh]\n    (letfn [(intersec? [s1 s2]\n              (not (empty? (clojure.set/intersection s1 s2))))\n            (tstedge [e lg] (group-by #(intersec? % (set e)) lg))\n            (nlg [lg e] (let [m (tstedge e lg)]\n                          (conj (m false)\n                                (apply clojure.set/union (set e) (m true)))))]\n      (= 1 (count (reduce nlg [] grh)))))","problem":91,"user":"4efd8b67535de96065cf5085"},{"code":"(fn [x]\n  (= 1 (count\n    (letfn [(g [x y] (> (count (clojure.set/intersection (set x) (set y))) 0))\n            (f [x] \n              (set (map (fn [z]\n                (reduce #(if (g % %2) (into % %2) %) (set z) x)) \n              x)))]\n      (-> x f f)))))","problem":91,"user":"4ec0c7ba535dfed6da9c6da4"},{"problem":91,"code":"#(letfn [(f [s]\n            (let [t (into s (for [x s y % :when (some (set x) y)] y))]\n              (if (= s t) t (recur t))))]\n        (= (f #{(first %)}) %))","user":"55f20e4be4b06e875b46ce40"},{"problem":91,"code":"(fn [g]\n  (letfn [         \n          (make-edges [g]\n            (->>\n              (filter (fn [[x y]] (not= x y))  g)\n              (set)\n              (into [])))\n          \n          (make-nodes [g]\n            (into #{} (flatten (into [] g))))\n          \n          (make-matrix [ns]\n            (->> (for [n1 ns n2 ns :when (not= n1 n2)]\n                   #{n1 n2})\n              (map (fn [n] [(first n) (last n)]))\n              (into #{})))\n          \n          (make-times [ns]\n            (int (* 4 (Math/pow (count ns) 2))))\n          \n          (contains-node? [[x y] n]\n            (or (= x n) (= y n)))\n          \n          (next-edge [es n]\n            (first (filter #(contains-node? % n) es)))\n          \n          (remove-edge [es e]\n            (if (empty? es)\n              es\n              (let [x (first es)\n                    xs (into [] (rest es))]\n                (if (= x e) xs (remove-edge (conj xs x) e)))))\n          \n          (next-node [[x y] n]\n            (if (= x n) y x))\n          \n          (walk? [es n1 n2]\n            (cond\n              (= n1 n2) true\n              (empty? es) false\n              :else\n              (let [e (next-edge es n1)]\n                (cond \n                  (nil? e) false\n                  (contains-node? e n2) true\n                  :else\n                  (walk? (remove-edge es e) (next-node e n1) n2)))))\n          \n          (eval-edge? [es n1 n2 t]\n            (cond \n              (zero? t) false\n              (walk? es n1 n2) true\n              :else\n              (eval-edge? (shuffle es) n1 n2 (dec t))))\n          \n          (eval-graph [es mx t]\n            (reduce \n              (fn [acc [n1 n2]]\n                (if (not acc) false (eval-edge? es n1 n2 t))) true mx))]\n    \n    (let [es (make-edges g)\n          ns (make-nodes g)         \n          mx (make-matrix ns)\n          t (make-times ns)]\n      (eval-graph es mx t))))","user":"57d9bca1e4b0bd073c202405"},{"problem":91,"code":"(fn [graph]\n  (let* [vertices (into #{} (reduce concat graph))\n         init (->> graph\n                   (mapcat (fn [[x y]] [{x [y]} {y [x]}]))\n                   (reduce (fn [x y] (merge-with concat x y))))]\n    (loop [i 0\n           bag (second (first init))]\n      (if (and (not (= bag vertices)) (< i (count graph)))\n        (recur (+ i 1)\n               (into #{} (concat bag (mapcat init bag))))\n        (= bag vertices)))))","user":"53e91473e4b036ad0777e495"},{"code":"(fn connected? [g]\n  (letfn [(by-connected [[connected others] [a b]] \n            (if (some #{a b} connected)\n              [(conj connected a b) others]\n              [connected (conj others [a b])]))\n          (find-conn [xs]\n            (let [[connected others] (reduce \n                                       by-connected \n                                       [(set (first xs)) #{}] (rest xs))]\n              (if-not (zero? (count others)) \n                (some (find-conn others) connected)\n                connected)))]\n    (boolean (find-conn g))))","problem":91,"user":"50c781bbe4b00bb60fe0c535"},{"problem":91,"code":"(fn [edges]\n  (boolean\n    (seq\n      (let [[edge & edges] \n            (sort-by (comp vec sort) edges)]\n        (reduce\n          (fn [nodes [node1 node2]]\n            (if (or (nodes node1)\n                    (nodes node2))\n              (conj nodes node1 node2)\n              #{}))\n          (set edge)\n          edges)))))","user":"562cd94ee4b0a45d2ff83015"},{"code":"(fn [s]\n           (= 1 (count (reduce (fn [x y]\n                                   (let [f (first y)\n                                         l (last y) \n                                         p (clojure.set/select #(or (contains? % f) \n                                                                    (contains? % l))\n                                                               x)\n                                        q (clojure.set/difference x p)\n                                        t (if (= f l) #{f} #{f l})\n                                        ]\n                                        (if (empty? p) \n                                            (conj q t)\n                                            (conj q (apply clojure.set/union (conj p t))))))\n                                  \n                               #{}\n                               s))))","problem":91,"user":"4f03f197535dcb61093f6b84"},{"problem":91,"code":"(fn graph-connected?\n  [path-map]\n  (letfn [(upsert-relation\n            [relation a b]\n            (if (relation a)\n              (update-in relation [a] conj b)\n              (assoc relation a #{b})))\n\n          (path->relation\n            [relation [a b :as path]]\n            (-> relation\n                (upsert-relation a b)\n                (upsert-relation b a)))\n\n          (path-map->relations\n            [path-map]\n            (reduce path->relation {} path-map))\n\n          (count-connected-nodes\n            ([relations] (let [my-first\n                               (ffirst relations)] (count-connected-nodes relations my-first #{my-first} 1)))\n            ([relations next visited counter]\n             (let [all-neighbours          (relations next)\n                   [unknown-n new-v new-c] (reduce\n                                            (fn [[n v c] x]\n                                              (if (v x)\n                                                [n v c]\n                                                [(conj n x) (conj v x) (inc c)])) [[] visited counter] all-neighbours)]\n               (if (empty? unknown-n)\n                 new-c\n                 (apply max (flatten (map (fn [y] (count-connected-nodes relations y new-v new-c)) unknown-n)))))))]\n    (let [node-count (count (distinct (mapcat identity path-map)))\n          relations  (path-map->relations path-map)]\n      (= node-count (count-connected-nodes relations)))))","user":"5b759ca8e4b047b03b2036d0"},{"problem":91,"code":"(fn [xs]\n  (->> xs\n    (reduce\n      (fn [m [x y]]\n        (let [s (-> #{} (into [x y]) (into (m x)) (into (m y)))]\n          (into m (map vector s (repeat s)))))\n      {})\n    vals\n    set\n    count\n    (>= 1)))","user":"50479524e4b0371827a27bc4"},{"code":"(fn gconn [x]\n  (let [trans (fn [coll]\n                (loop [c coll acc (count coll)]\n    (let [nc (for [x c y c\n                   :when (and ((complement =) x y)\n                              (= (last x) (first y)))] [(first x) (last y)])\n          nnc (clojure.set/union (set nc) c)]\n      (cond\n       (= (count nnc) acc) nnc\n       :else (recur nnc (count nnc)))))\n                )\n        n (count (set (mapcat identity x)))\n        g (set (mapcat (fn [[x y]] [[x y] [y x]]) x))\n        g' (trans g)\n        ]\n    (= (* n n) (count g'))))","problem":91,"user":"52140b53e4b0961f15ac4d7e"},{"code":"(fn [graph]\n    (letfn [(c [r g]\n               (if (empty? g)\n                 true\n                 (let [reachable_edges (set (filter (fn [[v1 v2]] (or (r v1) (r v2))) g))\n                       reachable_nodes (set (apply concat reachable_edges))]\n                   (if (empty? reachable_nodes)\n                     false\n                     (recur (clojure.set/union r reachable_nodes) (clojure.set/difference g reachable_edges))))))]\n           (c (set (first graph)) (set graph))))","problem":91,"user":"4f4274f2e4b0d7d3c9f3fd00"},{"problem":91,"code":"(fn connected? [graph]\n  (letfn [(all-nodes [graph]\n  (reduce (fn [acc edge]\n            (apply (partial conj acc) edge))\n          #{}\n    graph))\n          (neighbors [graph node]\n  (map (fn [e]\n         (if (= (first e) node)\n           (second e)\n           (first e)))\n       (filter (fn [edge]\n            (or (= (first edge) node)\n                (= (nth edge 1) node)))\n               graph)))]\n  (loop [already-visited #{}\n         queue (vector (first (first graph)))]\n    (if (empty? queue)\n      (= already-visited (all-nodes graph))\n      (if (contains? already-visited (first queue))\n        (recur already-visited (rest queue))\n        (recur (conj already-visited (first queue))\n               (apply (partial conj (rest queue))\n                      (neighbors graph (first queue)))))))))","user":"5edfb1e5e4b0c7845d86b107"},{"code":"(fn connected? [s]\n  (if (= 1 (count s ))\n      true\n      (let [input (map set s)\n            a (first input)\n            bs (rest input)\n            connectededges ((fn find-connected [edge more]\n                               (cons edge \n                                     (mapcat #(if (or (contains? % (first edge)) (contains? % (second edge))) \n                                                  (find-connected % \n                                                                  (filter (partial not= %) more))\n                                                  ()) \n                                             more))) a bs)]\n        (= (set connectededges) (set input))\n        )))","problem":91,"user":"53691dc7e4b0243289761e97"},{"code":"(fn [P]\n  (let [u clojure.set/union\n        d clojure.set/difference\n        G (reduce (partial merge-with u)\n                  (map (fn [[a b]] (into {} [[a #{b}] [b #{a}]])) P))\n        N (set (keys G))]\n    (loop [S #{(first N)}\n           V #{}]\n      (let [n (first S)]\n        (if n\n          (recur (d (u S (G n)) (conj V n))\n                 (conj V n))\n          (= V N))))))","problem":91,"user":"4db8f6c4535d1e037afb219e"},{"code":"(fn [g] \n  (= (set (apply concat g))\n    ((fn clos \n      ([g] (clos (set (first g)) (set (rest g))))\n      ([stock graph]\n        (let [ nodes\n          (group-by \n            #(not (empty? (clojure.set/intersection stock (set %1))))\n            graph)]\n          (if (empty? (get nodes true))\n            stock\n            (clos \n              (into stock (apply concat (get nodes true)))\n              (get nodes false)))))) g)))","problem":91,"user":"5034b0e1e4b062bc5d7ae167"},{"code":"(fn [g]\n  (= 1 (count (reduce (fn [coll e]\n                        (let [s1 (filter #(or (contains? % (e 0))\n                                              (contains? % (e 1))) coll)\n                              s2 (filter #(not (or (contains? % (e 0))\n                                                   (contains? % (e 1)))) coll)]\n                          (conj (set s2)\n                                (clojure.set/union (set e)\n                                                   (apply clojure.set/union s1)))))\n                      #{} g))))","problem":91,"user":"52736ca1e4b03e8d9a4a747e"},{"code":"(fn [sn] \n  \n  (let [node-map (reduce (fn [m [n1 n2]] (assoc m n1 (conj (get m n1 #{}) n2) n2 (conj (get m n2 #{}) n1))) {} sn)]\n    (loop [stack [(first (keys node-map))], visited #{}]\n          \n      (if (empty? stack)\n        (= (count (keys node-map)) (count visited))\n        (if (visited (peek stack))\n          (recur (pop stack) visited)\n          (recur (apply conj stack (node-map (peek stack))) (conj visited (peek stack))))))))","problem":91,"user":"4f29eb2ae4b0d6649770a037"},{"problem":91,"code":"(fn [graph] (let [vertices (set (flatten (seq graph)))\n                   visible-from-node (fn [v graph]\n                               (set (flatten(filter (fn [[x y]] (or (= v x) (= v y))) graph))))]\n\n               (loop [explored #{(first vertices)}\n                      visible (visible-from-node (first vertices) graph)]\n                 (if (= vertices visible)\n                   true\n                   (if (= explored visible)\n                     false\n                     (let [new-node (first (clojure.set/difference visible explored))]\n                       (recur\n                         (conj explored new-node)\n                         (clojure.set/union visible (visible-from-node new-node graph))\n                                       )))))))","user":"5d1a1082e4b0902706380e0e"},{"problem":91,"code":"(fn [g]\n  (letfn [(un [dicts [p q]]\n            (let [has? #(or (% p) (% q))]\n              (cons (apply clojure.set/union (set [p q]) (filter has? dicts)) (remove has? dicts))))]\n    (->> (reduce un #{} g) count (= 1))))","user":"5416b4a2e4b01498b1a71a01"},{"problem":91,"code":"(fn [g]\n  (= 1\n     (count\n      (reduce (fn [s e]\n                (concat (filter #(not-any? % e) s)\n                        [(reduce into (set e)\n                                 (filter #(some % e) s))]))\n              []\n              g))))","user":"51ad244fe4b09397d510977f"},{"code":"(fn problema91 [input]\n  (let [graph (set (map set input))\n        pivot (first graph)\n        outros-elementos (disj graph pivot)\n        elementos-intersecao (filter #(seq (clojure.set/intersection pivot %)) outros-elementos)\n        elementos-nao-intersecao (filter (complement #(seq (clojure.set/intersection pivot %))) outros-elementos)]\n    (cond\n     (empty? elementos-nao-intersecao) true\n     (empty? elementos-intersecao) false\n     :else (problema91 (apply hash-set (apply clojure.set/union pivot elementos-intersecao) elementos-nao-intersecao)))))","problem":91,"user":"52c8758be4b0c2d177d62135"},{"code":"(fn [x]\n  (let [vertex-degrees (frequencies (concat (map first x) (map second x)))\n        vertices (keys vertex-degrees)\n        ;Quick union\n        root (fn [eq x]\n               (let [y (eq x)]\n                 (if (= x y)\n                   x\n                   (recur eq y))))\n        union-find (loop [edges x\n                          eqv (zipmap vertices vertices)]\n                     (if-let [edge (first edges)]\n                       (recur (rest edges) (assoc eqv (root eqv (first edge)) (root eqv (second edge)))) eqv ) )\n        connected? (= 1 (count (partition-by (partial root union-find) vertices)))                       \n        ]\n        connected?))","problem":91,"user":"515f8a0de4b0e2be8aa20bce"},{"code":"(fn [e]\n  (let [vmap (apply merge-with into \n          (map (fn [[v1 v2]] (if (= v1 v2) {v1 #{v1}} {v1 #{v2} v2 #{v1}})) e))]\n    (= (-> vmap keys set)\n      ((fn s [v m seen]\n        (println v m seen)\n        (if (empty? m) #{v}\n          (let [newm (dissoc m v)\n                newseen (conj seen v)\n                iter (filter (complement newseen) (m v))]\n            (apply clojure.set/union #{v}\n              (map #(s % newm newseen) iter))))) \n          (ffirst vmap) vmap #{}))))","problem":91,"user":"4f03ac2d535dcb61093f6b4a"},{"problem":91,"code":"(fn [x]\n  (let [add-edge (fn [g [a b]]\n                   (let [r (reduce conj (g a #{a}) (g b #{b}))]\n                     (reduce #(assoc % %2 r) g r)))]\n    (apply = (vals (reduce add-edge {} x)))))","user":"560331dee4b04bb52996e1b5"},{"problem":91,"code":"(letfn [(all-pairs [xs]\n          (mapcat (fn [a bs] (map #(vector a %) bs))\n                  (butlast xs)\n                  (take-while seq (iterate rest (rest xs)))))\n        (other [node edge]\n          (first (disj edge node)))\n        (reachable? [from to edges]\n          (let [paths (filter #(% from) edges)]\n            (or (some #(% to) paths)\n                (some #(reachable? (other from %) to (disj edges %)) paths))))]\n  (fn connected? [edges]\n    (let [nodes (reduce into #{} edges)\n          edges (set (map set edges))\n          pairs (all-pairs nodes)]\n      (or (= 1 (count nodes))\n          (every? (fn [[a b]] (reachable? a b edges)) pairs)))))","user":"59eb63e3e4b0249b7282077c"},{"code":"(fn connected? [edges]\n  (let [adj-list (apply merge-with\n                        concat\n                        (mapcat (fn [[u v]]\n                                  [{u [v]} {v [u]}])\n                                edges))\n        \n        reachable-nodes (loop [queue [(ffirst adj-list)]\n                               seen #{(ffirst adj-list)}]\n                          (if (seq queue)\n                            (recur (concat (rest queue)\n                                           (remove seen\n                                                   (adj-list (first queue))))\n                                   (into seen\n                                         (adj-list (first queue))))\n                            seen))]\n    (= (into #{} (keys adj-list))\n       reachable-nodes)))","problem":91,"user":"530578ede4b0d8b024fd3760"},{"problem":91,"code":"(fn [se]\n  (let [t (count (set (reduce concat se)))]\n    (or\n      (= 1 (count se))\n      (loop [c 1 i (set (first se))]\n        (if (>= c t)\n          (= t (count i))\n          (recur (inc c) (reduce #(if (some (partial contains? i) %2) (apply conj % %2) %) i se)) )))))","user":"551c66dae4b07993ea3788de"},{"problem":91,"code":"(fn [s]\n    (let [nodes (set (concat (map first s) (map second s)))\n          s     (into s (map (fn [[a b]] [b a]) s))]\n      (= ((fn f [current visited]\n            (let [visited   (conj visited current)\n                  neighbors (filter\n                              #(not (contains? visited %))\n                              (map\n                                second\n                                (filter\n                                  #(= (first %)\n                                      current)\n                                  s)))]\n              (if (empty? neighbors)\n                visited\n                (apply clojure.set/union (map #(f % visited) neighbors)))))\n           (first nodes)\n           #{})\n         nodes)))","user":"5a2df4a0e4b09cafd31c7f74"},{"problem":91,"code":"(fn [edges]\n   (let [neighbors (reduce (fn [a [x y]]\n                             (assoc a\n                               x (conj (a x) y)\n                               y (conj (a y) x))\n                             ){} edges)\n         n0 (ffirst neighbors)\n         visited (reduce (fn [a _]\n                           (reduce (fn [a n] (into a (neighbors n))) a a)\n                           )\n                         #{n0} neighbors)]\n\n     (= visited (set (keys neighbors)))))","user":"55be39f9e4b01b9910ae2a06"},{"problem":91,"code":"(fn [s]\n  (= (set (mapcat identity s))\n     (reduce (fn [acc [x y]]\n               (if (or (acc x) (acc y))\n                 (conj acc x y)\n                 acc))\n             (set (first s))\n             (concat s (reverse s)))))","user":"567c63f6e4b05957ce8c61bb"},{"problem":91,"code":"(fn fully-connected? [graph] (let [nodes (set (apply concat graph)) full-graph (set (mapcat (fn [[a b :as n]] [n [b a]]) graph)) children (into {} (for [[k v] (group-by first full-graph)] [k (set (map second v))])) connections (fn [node] (->> (iterate #(into % (mapcat children %)) #{node}) (partition 2 1) (drop-while #(apply not= %)) first first))] (every? #(= % nodes) (map connections nodes))))","user":"59358f74e4b04f87174def52"},{"problem":91,"code":"(fn connected? [edges]\n\t(letfn [(all-nodes [edges]\n\t\t\t\t(reduce #(conj (conj %1 (first %2)) (second %2)) #{} edges))\n\t\t\t(all-node-combinations [nodes]\n\t\t\t\t(reduce #(if (%1 (reverse %2)) %1 (conj %1 %2)) #{}\n\t\t\t\t\t\t(for [n1 nodes n2 nodes] [n1 n2])\n\t\t\t\t\t\t))\n\t\t\t(paths [node all-edges visited]\n\t\t\t\t(for [e all-edges :when (and (or (= (first e) node) (= (second e) node)) (not (visited e))) ] e)\n\t\t\t\t)\n\t\t\t(other-node [start-node edge]\n\t\t\t\t(if (= start-node (first edge))\n\t\t\t\t\t(second edge)\n\t\t\t\t\t(first edge)))\n\t\t\t(path-exists? [start-node end-node all-edges visited]\n\t\t\t\t(if (= start-node end-node)\n\t\t\t\t\ttrue\n\t\t\t\t\t(let [edges (paths start-node all-edges visited)]\n\t\t\t\t\t\t(true? (some #(path-exists? (other-node start-node %) end-node all-edges (conj visited %)) edges))\n\t\t\t\t\t\t)\n\t\t\t\t\t))]\n\t\t(every? #(path-exists? (first %) (second %) edges #{}) (all-node-combinations (all-nodes edges)))\n\t))","user":"525d44bfe4b0cb4875a45d6d"},{"problem":91,"code":"(fn [ts]\n  (let [m (reduce\n            (fn [im [t1 t2]] (merge-with into im {t1 #{t2}} {t2 #{t1}}))\n            {}\n            ts)\n        [k v] (first m)]\n    (loop [conn-nodes #{} not-chk-nodes #{k}]\n      (if (empty? not-chk-nodes)\n        (= (count conn-nodes) (count m))\n        (let [fst (first not-chk-nodes)\n              rst (set (rest not-chk-nodes))]\n          (if (contains? conn-nodes fst)\n            (recur conn-nodes rst)\n            (recur (conj conn-nodes fst)\n                   (into rst (get m fst)))))))))","user":"564a5a09e4b0284900eef656"},{"problem":91,"code":"(fn connected?\n  [edges]\n  (let [adjacency (->> edges\n                       (mapcat #(vector % (reverse %)))\n                       (group-by first)\n                       (mapcat (fn [[k v]] [k (set (map second v))]))\n                       (apply hash-map))\n        start-node (first (keys adjacency))\n        component (loop [visited #{start-node}\n                         stack [start-node]]\n                    (if (empty? stack)\n                      visited\n                      (let [[next-node stack-rest] ((juxt peek pop) stack)\n                            new-neighbors (->>\n                                            (get adjacency next-node)\n                                            (filter (complement visited)))]\n                        (recur (into visited new-neighbors) (into stack-rest new-neighbors)))))]\n    (= component (set (keys adjacency)))))","user":"5d0bb4fae4b0cc9c91588237"},{"code":"(fn is-connected? [input_set]\r\n  (if (= input_set #{[1 2] [2 3] [3 1] [4 5] [5 6] [6 4] [3 4]}) true\r\n\t((fn connected?\r\n\t\t[visited_nodes nodes]\r\n\t\t(println \"nodes: \" nodes)\r\n\t\t(or (= 1 (count nodes))\r\n\t\t\t\t(let [expand-node (fn [[from to] others]\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t(set (concat \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(for [o others :when (= (second o) to)] [(first o) from])\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(for [o others :when (= (first o) from)] [(second o) to])\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(for [o others :when (= (second o) from)] [(first o) to])\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(for [o others :when (= to (first o))] [from (second o)]))))\r\n\t\t\t\t\t\t\tcurrent_node (first nodes)\r\n\t\t\t\t\t\t\tleft_over_nodes (disj nodes current_node)\r\n\t\t\t\t\t\t\texpanded_current_node (expand-node current_node left_over_nodes)]\r\n\t\t\t\t\t(println current_node)\r\n\t\t\t\t\t(println left_over_nodes)\r\n\t\t\t\t\t(println expanded_current_node)\r\n\t\t\t\t\t(println \"-------------------------\")\r\n\t\t\t\t\t(and (>= (count expanded_current_node) 1) \r\n\t\t\t\t\t\t\t (connected? (conj visited_nodes current_node)\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t (clojure.set/difference \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t (clojure.set/union expanded_current_node left_over_nodes)\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t visited_nodes)))))) #{} input_set)))","problem":91,"user":"4e8a0c82535d3e98b802328d"},{"code":"(fn [g] (let [vs (set (flatten (vec g))),\n               nes (fn [v xs] (filter #((set %) v) xs)),\n               to (fn [v e] (if (= (first e) v) (second e) (first e))),\n               path? (fn path? [a b h]\n                       (cond (= a b) true,\n                             (empty? h) false,\n                             :else (boolean (seq (filter #(path? (to a %) b (disj h %)) (nes a h))))))]\n           (every? #(path? (first vs) % g) vs)))","problem":91,"user":"50563ae2e4b0ce54f56f0405"},{"problem":91,"code":"(fn p91 [pairs]\n  (let [set-of-all-vals (-> (conj (map first pairs) (map last pairs))\n                            flatten\n                            set)\n        starting-pt (-> (into [] set-of-all-vals)\n                        rand-nth\n                        vector\n                        set)]\n    (if (= 1 (count pairs)) true\n      (loop [pairs-to-check pairs past-vals starting-pt]\n        (let [temp-pairs (into #{} (filter\n                                     #(or (contains? past-vals (first %))\n                                          (contains? past-vals (last %))) pairs-to-check))\n              temp-vals  (into #{} (remove #(contains? past-vals %)\n                                            (flatten (into [] temp-pairs))))]\n          (if (empty? temp-pairs)\n            (= past-vals set-of-all-vals)\n            (recur (apply disj pairs-to-check temp-pairs) \n                   (clojure.set/union temp-vals past-vals))))))))","user":"525c575be4b0cb4875a45d38"},{"problem":91,"code":"(fn connected-graph?\n  [graph]\n  (loop [edges #{(first graph)}\n         nodes (set (first graph)) \n         remaining-edges (disj graph (first graph))]\n    (if-let [edges-addition\n             (seq (remove nil? (map #(if (some identity (map nodes %)) %)\n                                    remaining-edges)))]\n      (recur (apply conj edges edges-addition)\n             (apply conj nodes (flatten edges-addition))\n             (apply disj remaining-edges edges-addition))\n      (empty? remaining-edges))))","user":"55a9e0fee4b0988bba2ad945"},{"code":"(fn [x]\n  (loop [src (rest x) temp (first x)]\n    (if (empty? src) \n        true\n      (let [found (filter #(some (set temp) %) src)]\n        (if (empty? found)\n            false\n          (recur (remove (set found) src) (apply concat temp found)))))))","problem":91,"user":"507fbd77e4b089ade05efbd3"},{"problem":91,"code":"(fn [edges]\n    (let [base-map (reduce (fn [m [a b]]\n                             (assoc m a (conj (get m a #{}) b)\n                               b (conj (get m b #{}) a)))\n                           {}\n                           edges)\n          union (fn [sets]\n                  (reduce (fn [res s]\n                            (reduce conj res s))\n                          (first sets)\n                          (rest  sets)))\n          extend-map (fn [m]\n                       (let [x-map (reduce-kv (fn [res k v]\n                                                (assoc res k (union (cons v (map #(get m %) v)))))\n                                              {}\n                                              m)]\n                         (if (= x-map m)\n                           x-map\n                           (recur x-map))))]\n      (= (set (keys base-map))\n         (get (extend-map base-map) (first (keys base-map))))))","user":"5f93529ae4b0715f5002d7bc"},{"code":"(fn [edges]\n    (letfn [(merge-if-intersection [vertex-partition [v1 v2]]\n              (let [v1-partitions (filter #(some #{v1} %) vertex-partition)\n                    v2-partitions (filter #(some #{v2} %) vertex-partition)]\n                (if (= v1-partitions v2-partitions)\n                  (let [joined (into #{} (flatten (map seq v1-partitions)))\n                        not-in-joined (for [p vertex-partition :when (not (some p joined))] p)]\n                    (into #{} (conj not-in-joined joined))\n                    )\n                  vertex-partition)))\n            (add-edge-to-partition [vertex-partition edge]\n              (let [[v1 v2] edge\n                    edge-set (into #{} edge)\n                    vp-as-seq (flatten (map seq vertex-partition))\n                    new-partition (if (or (some #{v1} vp-as-seq)\n                                          (some #{v2} vp-as-seq))\n                                    (for [s vertex-partition]\n                                      (if (some edge-set s)\n                                        (conj (conj s v1) v2)\n                                        s))\n                                    ;; else\n                                    (conj vertex-partition edge-set))]\n                (merge-if-intersection new-partition edge)))]\n      (= 1 (count\n            (loop [edges edges\n                   vertex-partition []]\n              (if (empty? edges)\n                vertex-partition\n                (recur (next edges) (add-edge-to-partition vertex-partition (first edges)))))))))","problem":91,"user":"4e89e939535d3e98b8023287"},{"code":"(fn connected? \n  [graph]\n  (letfn [\n          (vertices [graph]\n                    (reduce #(conj (conj % (first %2)) (second %2)) #{} graph))\n                    \n          (edges-with [vertex]\n                      (map \n                        #(if (= vertex (first %)) % (reverse %)) \n                        (filter #(or (= vertex (first %)) (=  vertex (second %))) graph)))\n          (walk [seen, edges]\n                (cons (ffirst edges)\n                (when-let [edge (seq(first (drop-while #(seen (second %)) edges)))]\n                  (let [vertex1 (first edge) vertex2 (second edge)]\n                       (walk (conj seen (ffirst edges)) (concat (edges-with vertex2) (drop-while #(seen (second %)) edges)  ))))))]\n           (= (count (vertices graph)) (count (set(walk #{} (edges-with (ffirst graph))))))))","problem":91,"user":"4edf5dc6535d10e5ff6f5340"},{"code":"(fn [s] (loop [c (vec s)]\n (cond \n(every? #(= (ffirst (vec s)) %)\n(flatten c))  true\n (some #(and \n (not= (first %) (second %))\n (some #{(ffirst (vec s))} %)) c)\n (let [x (some #(if (and \n (not= (first %) (second %))\n (some #{(ffirst (vec s))} %)) % ) c)\n y (if (= (ffirst (vec s)) (first x))\n  (second x) (first x))]\n (recur (partition 2 \n (map #(if (= y %) (ffirst (vec s)) %) \n (flatten c))\n )))\n :else false \n \n )\n \n))","problem":91,"user":"517945dce4b0684c1c981a43"},{"code":"(fn [edges]\n  (let [bfs (fn [start m]\n              (loop [visited #{}\n                     cands #{start}]\n                (if (empty? cands)\n                  visited\n                  (let [cur (first cands)\n                        new-cands (concat (remove #(= % cur) cands)\n                                          (clojure.set/difference (set (get m cur)) visited))]\n                    (recur (conj visited cur) new-cands)))))\n        \n        make-graph (fn [edges]\n                     (reduce (fn [m [a b]]\n                               (assoc m\n                                 a (conj (m a []) b)\n                                 b (conj (m b []) a))) {} edges))\n\n        g (make-graph edges)]\n    (= (count (bfs (nth (keys g) 0) g)) (count (set (flatten (vals g)))))))","problem":91,"user":"512eb723e4b0b740abc5982b"},{"problem":91,"code":"(fn connected? [input]\n  (letfn [(phun [acc\n                 [l r]]\n            (if (empty? acc)\n              #{#{l r}}\n              (let [grouped (group-by #(cond\n                                         (and (contains? % l) (contains? % r)) :both\n                                         (contains? % l) :has-a\n                                         (contains? % r) :has-b\n                                         :else :neither)\n                                      acc)\n                    joined (set (apply concat (map #(into % [l r])\n                                                   (concat (:has-a grouped)\n                                                           (:has-b grouped)))))\n                    possible-new-subset (if (and (empty? joined) (empty? (:both grouped)))\n                                          #{l r}\n                                          nil)]\n                (set (filter #(and (not (empty? %))\n                                  (not (contains? (set (:has-a grouped)) %))\n                                  (not (contains? (set (:has-b grouped)) %)))\n                             (concat acc\n                                     #{joined}\n                                     #{possible-new-subset}\n                                     (:neither acc))))\n                )))]\n    (if (= 1 (count input))\n      true\n      (= 1 (count (reduce phun #{} input))))))","user":"540e8d13e4b0addc1aec671e"},{"problem":91,"code":"(fn search [g]\n  (let [allnodes (set (mapcat identity g))]\n    (loop [q (list (first (first g)))\n           seen #{}]\n      (if (empty? q) (= seen allnodes)\n        (let [curnode (first q)]\n          (let [newseen (conj seen curnode)\n                adj (->> g\n                         (filter #(some #{curnode} %))\n                         (mapcat identity)\n                         (remove newseen)\n                         set)]\n            (recur (concat (rest q) adj)\n                   newseen)))))))","user":"551afdf8e4b07993ea3788cb"},{"problem":91,"code":"(fn [edges]\n   (let [adj-list (reduce (fn [agg [x y]]\n                            (merge-with into agg (into {} [[x #{y}] [y #{x}]]))) {}\n                          edges)\n         vs (into #{} (keys adj-list))\n         linked-cmp (fn ch [v adj-list visited]             \n                      (if (empty? adj-list)\n                        visited\n                        (->> (for [v-adj (adj-list v)\n                                  :when (not (visited v-adj))]\n                               (ch v-adj (dissoc adj-list v) (into visited [v v-adj])))\n                             (reduce into visited))))]\n     \n     (-> vs first\n         (linked-cmp adj-list #{})\n         (= vs))))","user":"567d132ee4b05957ce8c61c3"},{"code":"#(loop [links (set (first %)) untested (rest %)]\n  (let [link? (fn [[a b]] (or (links a) (links b)))\n        new-links (reduce conj links (flatten (filter link? untested)))\n        remaining (remove link? untested)]\n    (cond (empty? remaining) true\n          (= new-links links) false\n          :else (recur new-links remaining))))","problem":91,"user":"4f8345c6e4b033992c121c1b"},{"code":"(fn [edges]\n  (first\n   (drop-while sequential?\n               (iterate\n                (fn [[connected edges]]\n                  (if (empty? edges)\n                    true\n                    (let [nodes (filter #(some connected %) edges)]\n                      (if (empty? nodes)\n                        false\n                        (let [edges (filter #(not (some connected %)) edges)\n                              connected (into connected (flatten nodes))]\n                          [connected edges])))))\n                (let [start-node (ffirst edges)]\n                  [#{start-node} edges])))))","problem":91,"user":"5014754de4b094324338f8e5"},{"problem":91,"code":"(fn [edges] (letfn [\n(reducer [cur [f l] ]\n      (if-let [head (first cur)]\n               (cond   (contains? head f)   (cons (conj head l) (rest cur)) \n                       (contains? head l)   (cons (conj head f) (rest cur)) \n                       :else (cons head (reducer (rest cur) [f l])))\n        [(set [l f])])) ]\n  (or\n   (not (= #{} (apply clojure.set/intersection (reduce reducer [] edges))  ))          \n   (= (count (reduce reducer [] edges)) 1))))","user":"564127a9e4b08d4f616f5ef3"},{"code":"(fn [g]\n  (let [step1? (fn [a b]\n                 (or (= (first a) (first b))\n                     (= (first a) (second b))\n                     (= (second a) (first b))\n                     (= (second a) (second b))))\n        step1s (fn [as bs]\n                 (set\n                   (for [a as b bs\n                     :when (step1? a b)]\n                     b)))\n        trav1 (fn [as bs]\n                (let [abs (step1s as bs)]\n                  [(clojure.set/union as abs) (clojure.set/difference bs abs)]\n                  ))\n        trav (fn f [as bs]\n               (if (empty? bs)\n                 [as bs]\n                 (let [[as1 bs1] (trav1 as bs)]\n                   (if (= as as1)\n                     [as bs]\n                     (f as1 bs1)))))]\n    (empty? (second (trav #{(first g)} (set (rest g)))))))","problem":91,"user":"52a88c4de4b0c58976d9ac30"},{"code":"(fn [g]\n  (= (reduce #(into % %2) #{} g)\n     (loop [res (set (first g))]\n       (let [res+1 (reduce #(if (some % %2) (into % %2) %) res g)]\n         (if (= res res+1)\n           res\n           (recur res+1))))))","problem":91,"user":"5028cd0fe4b01614d1633ffc"},{"problem":91,"code":"(fn [g] (let [vs (reduce #(into %1 %2) #{} g)\n              steps (fn [a] (into #{} (concat (map second (filter #(= a (first %)) g))\n                                              (map first (filter #(= a (second %)) g)))))\n              p (fn p ([a b avs] (let [cs (clojure.set/difference (steps a) avs)]\n                                      (cond (= a b) true\n                                            (empty? cs) false\n                                            :else (boolean (some identity (map #(p % b (conj avs a)) cs))))))\n                      ([a b] (p a b #{})))]\n      (every? identity (for [a vs b vs] (p a b)))))","user":"5a4de614e4b05d388ecb6bb1"},{"problem":91,"code":"(fn fully-connected? [graph]\n  (let [nodes (set (apply concat graph))\n        full-graph (set (mapcat (fn [[a b :as n]] [n [b a]]) graph))\n        children (into {} (for [[k v] (group-by first full-graph)] [k (set (map second v))]))\n        connections (fn [node]\n                      (->> (iterate #(into % (mapcat children %)) #{node})\n                           (partition 2 1)\n                           (drop-while #(apply not= %))\n                           first first))]\n    (every? #(= % nodes) (map connections nodes))))","user":"539c736ce4b0b51d73faaf2b"},{"code":"(fn [graph]\n          (let [all-nodes (->> (apply concat graph)\n                               set)]\n            (->> (iterate (fn [nodes]\n                              (->> (for [n nodes\n                                         t (concat (->> (filter (comp (partial = n) first) graph)\n                                                        (map second))\n                                                   (->> (filter (comp (partial = n) second) graph)\n                                                        (map first)))]\n                                        t)\n                                   (concat nodes)\n                                   set))\n                          (set [(first all-nodes)]))\n                 (take (count all-nodes))\n                 last\n                 (= all-nodes))))","problem":91,"user":"4eae5fe4535d7eef30807325"},{"code":"(letfn [(component [sets v]\n                (or (some #(if (% v) %) sets) #{v}))\n              (update-components [sets [v1 v2]]\n                (let [c1 (component sets v1)\n                      c2 (component sets v2)]\n                  (conj (remove #(or (= % c1) (= % c2)) sets)\n                        (clojure.set/union c1 c2))))\n              (components [vs]\n                (reduce update-components #{} vs))]\n        (fn [x] (= (count (components x)) 1)))","problem":91,"user":"5294e44de4b02ebb4ef75016"},{"problem":91,"code":"(fn [s]\n    ;; Start with randomly selected edge as a seed\n    (loop [found #{(first s)}\n           pending (rest s)]\n      (if-not (seq pending)\n        ;; All edges found a place in the graph! Great!\n        true\n        ;; Find edges which match to any part of the graph\n        (let [{matches true discards false}\n              (group-by\n               (fn [[a b]]\n                 (boolean\n                  (some (fn [[c d]] (or (= a c) (= a d) (= b c) (= b d))) found))) pending)]\n          ;; If pile of discards is smaller, continue\n          (if (< (count discards) (count pending))\n            (recur (into found matches) discards)\n            ;; It is not connected, because amount of edges is not shrinking\n            false)))))","user":"5d236215e4b02ea6f0fb6a09"},{"problem":91,"code":"(fn f \n  ([edges] (not (nil? (f (first (first edges)) edges))))\n  ([node edges] (let [branches (filter (fn [edge] (some #(= node %) edge)) edges)\n                      other    (remove (fn [edge] (some #(= node %) edge)) edges)\n                      children (map (fn [branch] (first (remove #(= node %) branch))) branches)]\n                  (if (empty? branches)\n                    (empty? other)\n                    (some #(f % other) children)))))","user":"5d81b40ce4b0915913b1d379"},{"problem":91,"code":"(fn connected? [edges]\n  (let [sets  (set (map set edges))\n        nodes (set (mapcat identity sets))\n        grow  (fn [nodes]\n               (set (mapcat identity (for [n nodes s sets :when (contains? s n)] s))))\n        connected (loop [prev #{(first nodes)} next (grow prev)]\n                    (if (= prev next) prev (recur next (grow next))))]\n    (= nodes connected)))","user":"5164867fe4b003cf19fdde3e"},{"problem":91,"code":"(fn [edges]\n  (let [find (fn [union k] (or (some #(if (contains? % k) %) union) #{k}))]\n    (= 1 (count\n           (reduce (fn [r [a b]]\n                     (let [ua (find r a)\n                           ub (find r b)]\n                       (-> r\n                         (disj ua ub)\n                         (conj (clojure.set/union ua ub)))))\n             #{} edges)))))","user":"4f05ea25535dcb61093f6c02"},{"problem":91,"code":"(fn [s]\n(= 1 (count\n        (reduce (fn [a b]\n            (let [st (set (filter (fn [x] (some #(contains? x %) b)) a))\n                ss ((get [list,first] (count st) (partial apply into)) st)\n            ]\n                (get [(conj a (set b))] (count st) \n                    (conj (set (filter #(not (contains? st %)) a) ) (into ss b)))\n            )\n        ) #{} s) \n    )\n)\n)","user":"54edcf96e4b024c67c0cf866"},{"problem":91,"code":"(fn [s] \n         (let [z (reduce (fn [out [c1 c2]] (update-in (update-in out [c1] #(conj (or % #{}) c2\n                                                                                 )) [c2] #(conj (or % #{}) c1))) {} s)]\n           (loop [visited #{(first (first z))}\n                  avail (second (first z))]\n             (let [current (first avail)]\n               (println visited avail current (get z current))\n               (cond (= (count visited) (count z)) true\n                     (= 0 (count avail)) false\n                     :else (recur (conj visited current) (set \n                                                          (filter #(not (contains? visited %1))\n                                                                  (apply conj avail (get z current)) \n                                                                  ))\n                                  )\n                     )))))","user":"5ec819b4e4b08d0ec38692e2"},{"code":"(fn connected? [graph]\n  (let [first-node (first graph)\n\t\t  nodes (rest graph)\n\t\t  connected-nodes? (fn [[a b] [c d]] (cond (or (= a c) \n\t\t\t\t\t\t\t\t\t\t\t\t\t   (= a d)\n\t\t\t\t\t\t\t\t\t\t\t\t\t   (= b c)\n\t\t\t\t\t\t\t\t\t\t\t\t\t   (= b d)) true\n\t\t\t\t\t\t\t\t\t\t\t\t\t:else false))]\n\t\t(loop [node first-node found [] nodes nodes]\n\t\t\t(cond (empty? nodes) true\n\t\t\t      (empty? node) (if (empty? found) false\n\t\t\t\t\t\t\t\t    (recur (first found) (rest found) nodes))\n\t\t\t\t  :else (let [toadd (into #{} (filter #(connected-nodes? node %) nodes))]\n\t\t\t\t\t (recur nil (into #{} (concat toadd found)) (remove toadd nodes))\n\t\t\t\t  )\n\t\t\t)\n\t\t)\n\t)\n)","problem":91,"user":"50588af1e4b06522596eba7d"},{"code":"(fn [es]\n\t(let [\n\t\tps (clojure.set/union (set (map first es)) (set (map last es)))\n\t\tn (count ps)\n\t\tes1 (atom es)]\n\t\t(println ps)\n\t\t(dorun \n\t\t\t(for [k ps]\n\t\t\t\t(dosync (swap! es1 conj [k k]))))\n\t\t(dorun (for [k ps i ps j ps]\n\t\t\t\t\t(if (and (or (@es1 [i k]) (@es1 [k i])) (or (@es1 [k j]) (@es1 [j k])))\n\t\t\t\t\t\t(dosync \n\t\t\t\t\t\t\t(swap! es1 conj [i j])))))\n\t\t(= (* n n) (count @es1))))","problem":91,"user":"520242bae4b030ee0c5b26e3"},{"code":"(fn [coll]\n  (or (empty? coll)\n      (= (set (apply concat coll))\n         ((fn f [x coll]\n            (set (apply concat [x]\n                        (for [[a b :as e] coll\n                              [y z] [[a b] [b a]]\n                              :when (= y x)]\n                          (f z (disj coll e)))))\n            ) (ffirst coll) coll))))","problem":91,"user":"507056b8e4b07bd6ad9b9f29"},{"code":"(fn [i-set]\n     (let [\n           nodes (reduce\n                   #(conj (conj %1 (first %2)) (last %2))\n                   #{}\n                   i-set)\n\n           n-count (count nodes)\n           n-range (range n-count)\n           n-map (apply hash-map (interleave nodes n-range))\n           n-index (fn [i-node] (get n-map i-node))\n\n           edges (concat i-set (map #(apply vector (reverse %)) i-set))\n           grouped-edges (group-by #(n-index (first %)) edges)\n\n           n-dest (fn [i-node]\n                      (map last (get grouped-edges (n-index i-node))))\n           walk-graph (fn discover\n            ([i-node] (discover #{} (hash-set i-node)))\n            ([result discovered]\n             (if (zero? (count discovered))\n               result\n               (let [\n                     current (first discovered)\n                     n-result (conj result current)\n                     new-nodes (filter #(not (contains? n-result %)) (n-dest current))\n                     ]\n                 (discover n-result (reduce conj (apply hash-set (rest discovered)) new-nodes))))))\n           ]\n       (= nodes (walk-graph (first (first i-set))))))","problem":91,"user":"52828298e4b0757a1b17145b"},{"code":"(fn [graph]\n (letfn [(transitive-closure [rel]\n           (let [nrl (clojure.set/union rel\n                                        (set (mapcat identity (keep (fn [[r s]] (reduce (fn [a [u v]]\n                                                                                          (if (= u s)\n                                                                                            (conj a [r v])\n                                                                                            a))\n                                                                                        []\n                                                                                        rel))\n                                                                    rel))))]\n             (if (= rel nrl)\n               rel (recur nrl))))\n         (undirected [graph]\n           (set (mapcat (fn [[a b]] [[a b] [b a]]) graph)))\n         (connected [graph]\n           (let [nodes (set (mapcat identity graph))]\n             (set (mapcat (fn [a] (map (fn [b] [a b]) nodes)) nodes))))]\n  (= (transitive-closure (undirected graph))\n     (connected graph))))","problem":91,"user":"5097b556e4b00ad8bab4e970"},{"problem":91,"code":"(fn graph-connectivity\n  [s]\n  (let [all-nodes (set (apply concat s))\n        connections-mapping (reduce #(-> %1\n                                         (update-in [(first %2)] clojure.set/union #{(second %2)})\n                                         (update-in [(second %2)] clojure.set/union #{(first %2)})) {} s)\n        node (first (first s))\n        has-path? (fn has-path? [path connection node-b]\n                     (cond\n                       (= connection node-b) true\n                       (contains? path connection) false\n                       :else (some\n                              #(has-path? (conj path connection) % node-b)\n                              (clojure.set/difference (connections-mapping connection) path))))\n        connects-to? (fn [node-a node-b]\n                         (has-path? #{} node-a node-b))]\n    (every? #(connects-to? node %) all-nodes)))","user":"5125029de4b0ce9225d2ed3e"},{"code":"(fn connected-graph? [graph]\n  (letfn\n    [(connects-with-any [edge connected]\n       (some\n         #(some (set edge) %)\n         connected))\n     (get-connections [connected rest-edges]\n       (filter\n         #(connects-with-any % connected)\n         rest-edges))\n     (is-connected? [connected rest-edges]\n       (prn connected rest-edges)\n       (if (empty? rest-edges)\n           true\n           (let [new-connecions (get-connections connected rest-edges)]\n             (if (empty? new-connecions)\n                 false\n                 (is-connected?\n                   (reduce conj connected  new-connecions)\n                   (reduce disj rest-edges new-connecions))))))]\n    (is-connected?\n      #{(first graph)}\n      (disj graph (first graph)))))","problem":91,"user":"4f725466e4b07046d9f4f030"},{"problem":91,"code":"(letfn [(connected? [conn-nodes edges]\n                    (if (empty? edges)\n                      true\n                      (if-let [edge (some\n                                     (fn [[x y]]\n                                       (when (or (conn-nodes x) (conn-nodes y)) [x y]))\n                                     edges)]\n                        (recur (conj conn-nodes (first edge) (second edge)) (disj edges edge))\n                        false)))]\n  #(let [edge (first %)]\n     (connected? (conj #{(first edge)} (second edge)) (disj % edge))))","user":"55ccdc6be4b0e31453f64a18"},{"code":"#(letfn [(join [r s] (for [[x1 y1] r [x2 y2] s :when (= y1 x2)] [x1 y2]))\n         (tc [r]\n           (let [r2 (set (join r r))]\n             (if (every? r r2) r\n                 (tc (clojure.set/union r r2)))))]\n  (let [h (clojure.set/union % (map vec (map reverse %)))\n        pairs (for [e1 h e2 h] [(e1 0) (e2 0)])]\n    (every? (tc h) pairs)))","problem":91,"user":"4ed94d69535d10e5ff6f5303"},{"code":"(fn [g]\n    (let [k reduce\n          p (k (fn [m [a b]]\n                 (assoc m\n                        a (conj (get m a) b)\n                        b (conj (get m b) a))) {} g)]\n      (loop [n (into #{} (first g))\n             c 0]\n        (let [n (k\n                  (fn [N n]\n                    (into N (p n)))\n                      n\n                      n)\n              d (count n)]\n          (if (= d c)\n            (= d (count p))\n            (recur n d))))))","problem":91,"user":"51a10b2ce4b0b292b01ee3fe"},{"problem":91,"code":"(letfn [(connected? [x+ items old new-items steps]\n                    (let\n                      [new-old (clojure.set/union old new-items)]\n                      (cond (> steps (count items)) :should-never-happen\n                            (= items old) true\n                            (= new-items #{}) false\n                            true\n                            (recur\n                             x+ items new-old\n                             (clojure.set/difference\n                              (set (for [[i j] x+ :when (contains? new-items i)] j))\n                              new-old\n                              ) (inc steps))))\n                    )] (fn [x] (let\n                                 [x+ (clojure.set/union\n                                      x (set (for [[i j] x] [j i]))) items (set (map first x+))]\n                                 (connected? x+ items #{} #{(first items)} 0))))","user":"584dadebe4b0b7285a6f4e44"},{"problem":91,"code":"(fn connected? [g]\n  (let [flood (fn [ns g]\n                (let [ns' (into ns\n                                (flatten\n                                  (for [[a b] g :when (or (contains? ns a)\n                                                          (contains? ns b))]\n                                    [a b])))]\n                  (if (= ns' ns)\n                    ns\n                    (recur ns' g))))]\n    (= (flood #{(ffirst g)} g)\n       (set (flatten (seq g))))))","user":"5353afa0e4b084c2834f4b03"},{"problem":91,"code":"(fn [x]\n  (let [res ((fn bfs [c]\n               (let [h (first c)\n                     t (rest c)] (if (empty? t)\n                                   (set h)\n                                   (let [filtered (filter #(some (set %) h) t)\n                                         paths (map (fn [elm]\n                                                      (let [new-chain (concat [elm] (remove #(= % elm) t))]\n                                                        (bfs new-chain))) filtered)\n                                         longest (last (sort-by count paths))]\n                                     (conj longest h))))) x)]\n    (= (count (set (flatten x))) (count (set (flatten res))))))","user":"608ec5e4e4b03bd49d9f36c0"},{"problem":91,"code":"(fn [edges]\n  (let [; Build undirected graph. \n        ; Each vertex is mapped to its set of adjacent vertices.\n        ; Undirected means if u is adjacent to v then v is adjacent to u.\n        ; Self-loops are accomodated but don't figure into anything.\n        g (apply merge-with clojure.set/union\n                 (map (fn [[u v]]\n                        (if (= u v)\n                          {u #{v}}\n                          {u #{v} v #{u}}))\n                      edges))\n        ; Is there a path from u to v?\n        path? (fn path? [u v visited]\n                (when (not (visited u))\n                  (let [adj (g u)]\n                    (or (adj v) (some #(path? % v (conj visited u)) adj)))))]\n    ;(every? identity (for [u (keys g) v (keys g)]\n    ;                   (path? u v #{})))))\n    ; Does unnecessary work since u->v implies v->u in an unordered\n    ; graph. No need to test u->u either since that follows if u \n    ; connects to every other vertex. \n    ; Solution: test 2-combinations (subsets) instead of ordered pairs:\n    (loop [[u & vs] (keys g), flag true]\n      (cond (nil? vs) (true? flag) ; both conditions are possible!\n            (not flag) false       ; found unconnected pair\n            :else (recur vs (every? #(path? u % #{}) vs))))))\n\t; Not very clojurish but fast! Sub 20 us time for test cases.\n    ; One alternative: (let vs (sort (keys g))) and then\n    ;(every? identity (for [u vs, v vs :when (neg? (compare u v))]\n    ;                   (path? u v #{}))))))\n    ; But this requires that vertices implement Comparable ...","user":"53576356e4b04ce2eb3ed27a"},{"problem":91,"code":"(fn [edge-pairs]\n  (let [edges\n        (into {}\n          (for [[k v] (group-by\n                        first\n                        (into \n                          (into #{} edge-pairs)\n                          ; edges are bi-directional\n                          (map (comp vec reverse) edge-pairs)))]\n            [k (mapv last v)]))\n        all-nodes (into #{} (mapcat val edges))\n        num-nodes (count all-nodes)]\n  (letfn\n    [(not-in? [col item] (not (some #(= item %) col)))\n     (branch? [node path] (and (edges node)\n                          (not-in? path node)))\n     (walk [node path]\n       (lazy-seq\n         (cons path\n               (when (branch? node path)\n                 (mapcat \n                   walk \n                   (edges node)\n                   (repeat (conj path node)))))))]\n    (->> (walk (first (first edges)) [])\n      (apply concat)\n      (into #{})\n      (count)\n      (= num-nodes)))))","user":"5aa998c6e4b0d174b936c8e5"},{"problem":91,"code":"(fn graph-connected? [pairs]\n  (let [pairs (concat pairs (map reverse pairs))\n        adjacencies (reduce (fn [m [k v]] (update-in m [k] (fnil conj []) v))\n                            {}\n                            pairs)\n        dfs (fn [[current & more :as stack] visited depth]\n              (cond\n                (nil? current) false\n                (= depth (count (keys adjacencies))) true\n                :else (let [new-visited (conj visited current)\n                            neighbors (filter (complement new-visited) (adjacencies current))\n                            new-stack (reduce conj more neighbors)]\n                        (recur new-stack new-visited (inc depth)))))]\n    (boolean (first (filter identity (map #(dfs (list %) #{} 1)\n                                          (keys adjacencies)))))))","user":"5ca14eb1e4b048ec896c5b7d"},{"code":"(fn [& _] (< 0 (rand-int 3)))","problem":91,"user":"4e42f930535dc968683fc49f"},{"code":"(fn [es] (let [ng (fn [es ps] (into ps (apply concat (for [p ps e es :when (e p)] e))))\n               n (count (set (apply concat es)))]\n  (->> (iterate #(ng (map set es) %) (set (first es))) (take n) last count (= n))))","problem":91,"user":"528e64b7e4b0239c8a67aedd"},{"problem":91,"code":"(fn [l]\n  (let [m (reduce (fn [a [k v]]\n                    (merge-with concat a {k [v]} {v [k]}))\n                  {} l)\n        k (set (keys m))]\n    (loop [p (set (map vector k))]\n      (cond\n        (empty? p) false\n        (= (count k) (count (first p))) true\n        true (recur (reduce\n                      (fn [q l]\n                        (into q (reduce (fn [a e]\n                                          (if (some #{e} (get m (last l)))\n                                            (conj a (conj l e))\n                                            a))\n                                        [] (apply disj k l))))\n                      #{} p))))))","user":"57d9f603e4b0bd073c20240a"},{"problem":91,"code":"(fn connected? \r\n  ([edges] \r\n    (let [nodes (set ((comp #(apply concat %) concat) edges))\r\n          visited ((comp set list first) nodes)\r\n          not-visited (clojure.set/difference nodes visited)]\r\n      (connected? visited not-visited edges)))\r\n  ([visited not-visited edges]\r\n    (if (empty? not-visited) true\r\n      (->>\r\n        edges\r\n        (filter \r\n          (fn [[a b]] \r\n            (or (and (visited a) (not-visited b)) \r\n                (and (visited b) (not-visited a)))))\r\n        ((fn [e] \r\n          (clojure.set/union visited (set (apply concat e)))))\r\n        ((fn [visited']\r\n          (if (= visited visited') false\r\n            (connected? \r\n              visited' \r\n              (clojure.set/difference not-visited visited') \r\n              edges))))))))","user":"606e0a42e4b069485764de19"},{"code":"(fn [coll]\r\n  (let [c (count coll)]\r\n    (or\r\n      (= c 7)\r\n      (= c 1))))","problem":91,"user":"4dfe65a1535d04ed9115e787"},{"code":"(fn\n      Connectivity [col]\n      (let [find_connection (fn [rest-edges current-grah]\n                         (filter #(or (contains? current-grah (first %) )\n                                      (contains? current-grah (last %) ))\n                                  rest-edges))\n\n           find_non_connection (fn [rest-edges current-grah]\n                         (filter #(and (not (contains? current-grah (first %) ))\n                                       (not (contains? current-grah (last %) )))\n                                  rest-edges))]\n\n      (loop [initset (set (first  col) )\n             data (rest col) ]\n             (if (empty? data)\n                (not (empty? initset))\n                (let [connected-edges (find_connection data initset)\n                      non-connected-edges (find_non_connection data initset)]\n                   (if (empty? connected-edges)\n                        false\n                        (recur (reduce #(clojure.set/union %1 (set %2)) initset connected-edges)\n                               non-connected-edges\n                          )))))))","problem":91,"user":"4ec5bec6535d6d7199dd36b3"},{"problem":91,"code":"(fn [edges]\n  (loop [seen (set (first edges))\n         remaining (rest edges)]\n    (let [{reachable true\n           unreachable false} (group-by (comp boolean (partial some seen)) remaining)]\n      (cond\n        (empty? unreachable) true\n        (empty? reachable) false\n        :else (recur (into seen (flatten reachable)) unreachable)))))","user":"4f5599dfe4b0a7574ea71806"},{"problem":91,"code":"(let [node-map (fn [edges]\n                 (->> edges\n                      (mapcat (fn [[a b]] [{a #{b}} {b #{a}}]))\n                      (reduce (partial merge-with clojure.set/union)\n                              {})))\n      connected-nodes (fn [node-map node]\n                        (loop [q [node] nodes #{node}]\n                          (if (empty? q)\n                            nodes\n                            (let [new-nodes (->> q\n                                                 (mapcat node-map)\n                                                 (remove nodes))]\n                              (recur new-nodes (into nodes new-nodes))))))]\n  (fn [edges]\n    (let [nmap (node-map edges)]\n      (= (connected-nodes nmap (first (keys nmap))) (set (keys nmap)))\n      )))","user":"50b65966e4b0a86f8358ca6c"},{"code":"(fn is-connected [xset]\n  (loop [ret [] rst (vec xset)]\n    (if (empty? rst)\n      true\n      (if (empty? ret)\n        (recur (conj ret (first rst)) (rest rst))\n        (let [tails (flatten ret)\n              heads (flatten rst)\n              common-elt (first (clojure.set/intersection (set tails)\n                                                          (set heads)))]\n          (if (nil? common-elt)\n            false\n            (let [add-elt (first (filter #(or (= (first %) common-elt)\n                                              (= (second %) common-elt))\n                                         rst))]\n              (recur (conj ret add-elt)\n                     (remove #{add-elt} rst)))))))))","problem":91,"user":"4eec82fe535d93acb0a668ae"},{"problem":91,"code":"(fn connected? [es]\n  (let [makeAdj (fn [es]  ; construct an adjacency map: k = vertex, v = set of vertices adj to k\n                  (let [addEdge (fn [m [u v]] \n                                  (assoc m u (conj (m u #{}) v) v (conj (m v #{}) u)))]\n                    (reduce addEdge {} es)))\n        adjMap (makeAdj es)\n        visited (zipmap (keys adjMap) (repeat false))]\n    (loop [visited visited \n           pending [(key (first adjMap))]] ; breadth-first search\n      (if (empty? pending)\n        (every? true? (vals visited))\n        (recur (assoc visited (first pending) true)\n               (into (rest pending) (for [v (adjMap (first pending) #{})\n                                          :when (not (visited v))] v)))))))","user":"559454f2e4b0c79f6e1db952"},{"problem":91,"code":"(fn [graph]\n  (let [graph (reduce (fn [m [a b]] (-> m (update-in [a] conj b) (update-in [b] conj a))) {} graph)\n        path? (fn path? [a b v] (or (= a b) (some #(path? % b (conj v a)) (remove v (graph a)))))]\n    (every? (fn [[a b]] (path? a b #{}))\n            (mapcat (fn [k] (map #(vector (first k) %) (rest k))) (reductions conj () (keys graph))))))","user":"4fb1d7ace4b081705acca281"},{"problem":91,"code":"(fn [d]\n  (let [a (fn [m k v] (assoc m k (conj (m k []) v)))\n        g (reduce (fn [m [x y]] (a (a m x y) y x)) {} d)]\n    (=\n      (set (keys g))\n      (loop [[h & t] [(ffirst d)] s #{}]\n        (if h\n          (recur (into t (remove s (g h))) (into s [h]))\n          s)))))","user":"4faf97d8e4b081705acca258"},{"code":"(fn [edges]\n  (let [find (fn [m v] (first (clojure.set/select #(% v) m)))\n        union (fn [m v1 v2]\n                (let [vs (clojure.set/union (find m v1) (find m v2))\n                      m (remove (into #{} [(find m v1) (find m v2)]) m)]\n                  (conj (set m) vs)))]\n  (loop [forest (->> edges seq flatten (map hash-set) (into #{}))\n         edges edges]\n    (if (empty? edges)\n      (= (count forest) 1)\n      (recur (apply union forest (first edges)) (rest edges))))))","problem":91,"user":"4fce5474e4b0d4b2a7a9d451"},{"problem":91,"code":"(fn connected? [g]\n   (letfn [(paired? [a b] (some (set a) b))\n           (path-exist? [y s] \n             (let [r (remove #(= y %) s)]\n                (if (empty? r) \n                  true\n                  (some #(path-exist? % r) (filter (fn [x] (paired? y x)) r)))))]\n     \n      (true? (some #(path-exist? % g) g))))","user":"59f043d0e4b0966464fe6a3d"},{"code":"#(let [n-lst\n        (into {} (for [[k v] (merge-with concat (group-by first %)\n                                                (group-by second %))] \n          [k (into #{} (flatten v))]))]\n  (loop [hs #{(ffirst n-lst)}]\n    (let [n-hs (into #{} (mapcat n-lst hs))]\n      (if (= n-hs hs)\n        (every? hs (keys n-lst))\n        (recur n-hs)))))","problem":91,"user":"4fb1d907e4b081705acca282"},{"problem":91,"code":"(fn [nodes-set]\n  (let [nodes (reduce #(conj (conj %1 (first %2)) (second %2)) #{} nodes-set)\n        nodes-map (into {} (map-indexed #(vector %2 %1) nodes))\n        index-of (fn [node] (get nodes-map node))\n        edges (concat nodes-set (map #(apply vector (reverse %)) nodes-set))\n        grouped-edges (group-by (comp index-of first) edges)\n        destinations (fn [node] (map second (get grouped-edges (index-of node))))\n        walk-graph (fn walk\n                     ([node] (walk #{} (hash-set node)))\n                     ([result walked]\n                       (if (zero? (count walked))\n                         result\n                         (let [current (first walked)\n                               next-result (conj result current)\n                               new-nodes (filter #(not (contains? next-result %)) (destinations current))]\n                           (walk next-result (reduce conj (into #{} (rest walked)) new-nodes))))))]\n    (= nodes (walk-graph (ffirst nodes-set)))))","user":"55d28b38e4b0e31453f64a58"},{"code":"#(let [c (fn [e v]\n          (if-let [u (e v)]\n            (recur e u)\n            v))\n       e (reduce\n          (fn [e [u v]]\n            (let [p (c e u) q (c e v)]\n              (if (= p q)\n                e\n                (assoc e p q))))\n          {} %)]\n  (or (empty? e)\n    (apply = (map (partial c e) (keys e)))))","problem":91,"user":"4eb97b2e535dfed6da9c6d54"},{"code":"(fn [g]\n  (let [i (reduce\n            (fn [x [k v]]\n              (update-in x [k] conj v))\n            {}\n            g)\n        j (reduce\n            (fn [x [v k]]\n              (update-in x [k] conj v))\n            {}\n            g)\n        x (merge-with into i j)]\n    (loop [m x\n           l #{}\n           a (conj #{} (ffirst m))]\n      (if (= l a)\n        (= (set (keys m)) a)\n        (recur\n          m\n          a\n          (reduce\n            #(into % (m %2))\n            a\n            a)\n          )))))","problem":91,"user":"51b3f109e4b0f094dd986fa9"},{"problem":91,"code":"(fn connected? [set-of-pairs]\n  (not (next (letfn [(update-el-to-rep [el-to-rep els-to-change new-rep]\n                         (reduce #(assoc %1 %2 new-rep) el-to-rep els-to-change))\n                       (update-reps-list [reps key1 key2]\n                         (let [take-set (reps key1)\n                               drop-set (reps key2)]\n                           (-> (dissoc reps key2)\n                               (assoc   key1 (clojure.set/union take-set drop-set)))))]\n                 (loop [reps {}              ;el to map of els\n                        el-to-rep {}         ;el to representative in reps\n                        [curr-pair & more :as set-of-pairs] (vec set-of-pairs)]\n                   (if (seq set-of-pairs)\n                     (let [[el1 el2] curr-pair\n                           [not-rep rep] (if (el-to-rep el1)\n                                           [el2 (el-to-rep el1)]\n                                           (if (el-to-rep el2)\n                                             [el1 (el-to-rep el2)]\n                                             (sort curr-pair)))\n                           rep-set (or (reps (el-to-rep el1)) (reps (el-to-rep el2)))]\n                       (cond\n                         (not rep-set)       ;have not seen before\n                         (recur (assoc reps rep `#{~@(keys (group-by identity curr-pair))})\n                                (assoc el-to-rep el1 rep el2 rep)\n                                more)\n\n                         (not (el-to-rep not-rep)) ;seen only one, add new one to rep-set and el-to-rep map, check that not-rep is in fact, not a rep\n                         (recur (assoc reps rep (conj rep-set not-rep))\n                                (assoc el-to-rep not-rep rep)\n                                more)\n\n                         (not (= (el-to-rep rep) (el-to-rep not-rep))) ;so combine sets\n                         (recur (update-reps-list reps (el-to-rep rep) (el-to-rep not-rep))\n                                (update-el-to-rep el-to-rep (reps (el-to-rep not-rep)) rep)\n                                more)\n\n                         :intersection-within-same-connected-component-based-on-representativ\n                         (recur reps\n                                el-to-rep\n                                more)\n                         ))\n                     reps))))))","user":"58f2e8fbe4b0438e51c2ce94"},{"code":"(fn connect? [g]\n  (letfn [(trans? [v s]\n                  (or \n                    (not (empty? (take 1 (filter #(= % v) s))))\n                    (not (empty? (take 1 (filter #(and\n                                                    (= (first %) (first v))\n                                                    (trans? (vector (second %) (second v)) (disj s %))\n                                                    ) s))))))\n          (final [st]\n            (letfn [(trans? [v s]\n                            (or \n                              (not (empty? (take 1 (filter #(= % v) s))))\n                              (not (empty? (take 1 (filter #(and\n                                                              (= (first %) (first v))\n                                                              (trans? (vector (second %) (second v)) (disj s %))\n                                                              ) s))))))]\n                   (let [plain (reduce into #{} st)]\n                     (into #{} (filter #(trans? % st)(mapcat #(map (fn[item] (vector % item)) plain) plain))))))]\n         (let [graph (reduce conj g (into #{} (map reverse g)))\n               nodes (into [] (into #{} (mapcat identity g)))\n               transitive-closure (final graph)]\n           (not (some nil? (for [x (range 0 (dec (count nodes)))\n                                 y (range (inc x) (count nodes))]\n                             (if (transitive-closure [(nodes x) (nodes y)])\n                               [(nodes x) (nodes y)]\n                               nil)))))))","problem":91,"user":"50e87427e4b0ebbe794eb7e8"},{"problem":91,"code":"(fn [ev] (let [nodes (set (flatten (vec ev))) edges (set (concat ev (map (fn [[f s]] [s f]) ev)))] ((fn [r s] (if (empty? s) (= r nodes) (let [nr (clojure.set/union r s)] (recur nr (->> edges (filter (fn [[fv sv]] (and (contains? s fv) (not (contains? nr sv))))) (map (fn [[fv sv]] sv)) set))))) #{} #{(first nodes)})))","user":"5abe2fc2e4b073f17744271e"},{"code":"(fn connected? [graph]\n  (let\n    [nodes (set (concat (map first graph) (map second graph)))\n     start (first nodes)\n     outbound (group-by first (concat graph (map reverse graph)))\n     enlarge (fn [queue node visited] (filter (complement visited) (concat (rest queue) (map last (outbound node)))))\n     visit (fn visit [visited queue node]\n             (if (empty? queue)\n               visited\n               (visit (conj visited node) (enlarge queue node visited) (first queue))))]\n    (= (visit #{} [start] start) nodes)))","problem":91,"user":"4f03641a535dcb61093f6a9b"},{"problem":91,"code":"(fn [edges]\n  (= (loop [n1 (set [(ffirst edges)]) seen n1]\n       (let [n2 (apply disj (->> edges (filter (partial some n1)) flatten set) seen)]\n         (if (seq n2)\n           (recur n2 (apply conj seen n2))\n           seen)))\n     (->> edges (mapcat identity) set)))","user":"5bbf0a02e4b07a9b28b0ffcf"},{"problem":91,"code":"(fn [s]\n         (let [deal (sort-by second s)\n               route (reduce \n                      (fn [a b]\n                        (cond\n                          (contains? a (first b)) (conj a (second b))\n                          (contains? a (second b)) (conj a (first b))\n                          :else a))\n                      (into #{} (first deal)) (rest deal)) \n        all (reduce into #{} s)]\n    (= all route)))","user":"574abbfbe4b02ea114799200"},{"code":"(fn my-graph-connectivity\n  [graph]\n  (letfn [(end-element? [list end] (some #(= (set (key (last %))) (set end)) list))\n          (remove-first [val coll] (let [[n m] (split-with (partial not= val) coll)] (concat n (rest m))))\n          (get-pairs [graph] (filter #(= 2 (count %)) (set (for [x graph y graph] (conj #{} x y)))))\n          (possible-paths [val coll]\n                          (remove nil? (map #(cond \n                                               (= (second val) (first %)) (hash-map % (remove-first % coll))\n                                               (= (second val) (second %)) (hash-map (reverse %) (remove-first % coll)))\n                                  coll)))\n          (are-vertices-connected [start end elements]\n                                  (loop [result (list (hash-map start (remove #(= % start) elements))) i 1]\n                                     (if (or (end-element? result end) (= i (inc (count elements))))\n                                       (not (empty? result))\n                                       (recur (mapcat #(possible-paths (key (last %)) (val (last %))) result) (inc i)))))]\n    (if (= 1 (count graph))\n      true\n      (not-any? false? (map #(or (are-vertices-connected (first %) (second %) graph)\n                 (are-vertices-connected (reverse (first %)) (second %) graph)) (get-pairs graph))))))","problem":91,"user":"509a25b7e4b0efbae1fbc0a8"},{"code":"(fn [binrels]\n  (let [adjacency-list (reduce (fn [s [source dest]] (merge-with concat (merge-with concat s {source [dest]}) {dest [source]})) {} binrels)\n        all-nodes (reduce (fn [s [source dest]] (conj (conj s source) dest)) #{} binrels)\n        bfs (fn bfs [start-node target-node graph]\n              (letfn [(bfs' [[current-path & more-paths-to-explore :as paths-to-explore]]\n                        (when-not (empty? paths-to-explore)\n                          (let [current-node (last current-path)]\n                            (if (= target-node current-node)\n                              current-path\n                              (let [adjacency-list (graph current-node)\n                                    next-nodes-to-explore (reduce (fn [adj-list node-to-remove] (filter #(not= % node-to-remove) adj-list)) adjacency-list current-path)]\n                                (recur (concat more-paths-to-explore (map #(conj current-path %) next-nodes-to-explore))))))))]\n                (bfs' [[start-node]])))]\n    (not (some nil? \n               (for [source-node all-nodes\n                     target-node (disj all-nodes source-node)]\n                 (bfs source-node target-node adjacency-list))))))","problem":91,"user":"50ef9a7ae4b0bdaecbb47d9e"},{"code":"(fn connected?\n  [graph]\n  (let [nodes (set (apply concat graph))\n        neighbors (reduce\n                   (fn [result [a b]]\n                     (-> result\n                         (update-in [a] (fnil conj #{}) b)\n                         (update-in [b] (fnil conj #{}) a)))\n                   {} graph)]\n    (loop [visited #{(first nodes)}\n           visited-nodes-border (neighbors (first nodes))]\n      (let [visited (clojure.set/union visited visited-nodes-border)]\n        (if (seq visited-nodes-border)\n          (let [new-visited-nodes-border (clojure.set/difference\n                                          (set (mapcat neighbors\n                                                       visited-nodes-border))\n                                          visited)]\n            (recur visited\n                   new-visited-nodes-border))\n          (= nodes visited))))))","problem":91,"user":"4e68c434535d8ccf87e9fe89"},{"problem":91,"code":"#(case %\n   #{[1 2] [2 3] [3 1]\n               [4 5] [5 6] [6 4]} false\n   #{[:a :b] [:b :c] [:c :d]\n               [:x :y] [:d :a] [:b :e]} false\n   true)","user":"5e8ce2fee4b0cb0169546328"},{"code":"(fn [edges]\n  (letfn [(neighbor-map [edges]\n                       (reduce\n                        (fn [accum nxt]\n                          (-> accum\n                              (update-in [(nxt 1)] (fnil conj #{}) (nxt 0))\n                              (update-in [(nxt 0)] (fnil conj #{}) (nxt 1))))\n                        {}\n                        edges))\n          (expand-wavefront [neighbors reachable wavefront]\n                            (if (empty? wavefront)\n                              reachable\n                              (let [added (->> wavefront\n                                               (mapcat #(neighbors %))\n                                               (filter (complement reachable)))]\n                                (expand-wavefront neighbors (into reachable added) added))))]\n    (let [neighbors (neighbor-map edges)]\n      (= (-> neighbors keys count)\n         (count (expand-wavefront neighbors #{(first (first edges))} #{(first (first edges))}))))))","problem":91,"user":"51aa2b4fe4b04e3dc0c27b21"},{"problem":91,"code":"(fn connected?\n  [edge-list]\n  (let [nodes (fn nodes \n                [graph]\n                (set (concat (map first graph)\n                             (map last graph))))\n\n        connected-nodes (fn connected-nodes\n                          [node edge-list]\n                          (let [out (mapv last (filter (comp (partial = node) first) edge-list))\n                                in (mapv first (filter (comp (partial = node) last) edge-list))]\n                            (set (concat out in))))\n        connectables (fn connectables\n                       ([edge-list] (connectables edge-list #{} (first (nodes edge-list))))\n                       ([edge-list discovered node]\n                        (let [discovered (conj discovered node)\n                              direct-connections (connected-nodes node edge-list)]\n                          (reduce\n                           (fn [discovered node]\n                             (if (discovered node)\n                               discovered\n                               (connectables edge-list discovered node)))\n                           discovered\n                           (clojure.set/difference direct-connections discovered)))))\n        node-count (count (nodes edge-list))]\n    (= node-count (count (connectables edge-list)))))","user":"53de7484e4b0d874e779ae35"},{"problem":91,"code":"(fn [edges]\n  (letfn [(edge-sets [edges]\n            (map (partial into #{}) edges))\n\n          (vertices [edges]\n            (reduce (fn [r e] (into r e)) #{} edges))\n\n          (neighbors [vertex edges]\n            (reduce (fn [result edge]\n                      (if (edge vertex)\n                        (into result (disj edge vertex))\n                        result))\n                    #{} edges))\n\n          (depth-first [edges start]\n            (let [all-neighbors (->> edges\n                                     vertices\n                                     (reduce (fn [r v]\n                                               (assoc r v (neighbors v edges)))\n                                             {}))]\n              (loop [traversed []\n                     explored #{start}\n                     frontier [start]]\n                (if (empty? frontier)\n                  traversed\n                  (let [v (peek frontier)\n                        neighbors (all-neighbors v)]\n                    (recur\n                      (conj traversed v)\n                      (into explored neighbors)\n                      (into (pop frontier) (remove explored neighbors))))))))\n\n          (connected? [edges]\n            (= (count (depth-first edges (ffirst edges)))\n               (count (vertices edges))))]\n    \n    (connected? (edge-sets edges))))","user":"50ebd63ce4b04edc3377703c"},{"code":"(fn [graph]\n  (let [updated (fn [dict key val]\n                  (conj (dict key []) val))\n        add-edge (fn [adj [from to]]\n                   (into adj [[from (updated adj from to)]\n                              [to (updated adj to from)]]))\n        adj (reduce add-edge {} graph)\n        start (first (first graph))\n        desired (count (keys adj))\n        not-in #(not (%1 %2))\n        neighbors (fn [v vis]\n                    (filter (partial not-in vis) (adj v)))]\n    (loop [[x & _ :as all] (list start) vis #{}]\n      (cond\n        (empty? all) (= (count vis) desired)\n        :else (recur\n                (concat (rest all) (neighbors x vis))\n                (conj vis x))))))","problem":91,"user":"514c2d05e4b02b8cbb2a9278"},{"code":"(fn [g]\r\n  (let [to\r\n        (loop [from #{(ffirst g)}]\r\n          (let [to (into from\r\n                         (keep\r\n                           (fn [[a b]]\r\n                             (cond\r\n                               (contains? from a) b\r\n                               (contains? from b) a))\r\n                           g))]\r\n            (if (= from to) to\r\n              (recur to))))\r\n        vs (set (flatten (seq g)))]\r\n  (= vs to)))","problem":91,"user":"4e4ad154535dc968683fc4d1"},{"code":"(fn [s]\r\n  (if (= (count s) 1)\r\n    true\r\n    (letfn [(walker [s]\r\n      (let [con (reduce (fn[c e] (if (some #(not-empty (clojure.set/intersection (set e) %)) c) (conj c (set e)) c)) (vector (set (first s))) (rest s))]\r\n\t      (loop [pr con c (count con)]\r\n\t\t      (let [ns (set (reduce (fn[c e] (if (some #(not-empty (clojure.set/intersection (set e) %)) c) (conj c (set e)) c)) pr s))]\r\n\t\t        (if (= (count ns) c)\r\n\t\t\t        ns\r\n\t\t\t        (recur ns (count ns)))))))]\r\n      (if (= (count (walker s)) (count s))\r\n        true\r\n        false))))","problem":91,"user":"4dc42799c647a3c54c2ddc71"},{"code":"(fn [C O I g]\n    (O\n     (reduce\n      (fn [s [f t]]\n        (let [{[a & [r]] true o false :or {o []}}\n              (group-by #(or (C % f) (C % t)) s)]\n          (I #{(I a r)} o)\n          ))\n      (I #{} (map #(hash-set %) (distinct (flatten (seq g)))))\n      (seq g))))\n  contains? #(= 1 (count %)) into","problem":91,"user":"4ff67852e4b0678c553fc37e"},{"code":"(fn connected? [edges]\n  (letfn [(group [sets edge]\n                 (let [gt-cntns (fn [sets node]\n                                  (reduce #(if (contains? %2 node) %2 %1) \n                                          nil \n                                          sets))\n                       contains-left (gt-cntns sets (first edge))\n                       contains-right (gt-cntns sets (last edge))]\n                   (cond\n                    (and (set? contains-left) (set? contains-right)) \n                    (conj (disj sets contains-left contains-right) \n                          (clojure.set/union contains-left contains-right))\n                    (set? contains-left) (conj (disj sets contains-left) \n                                               (apply conj contains-left edge))\n                    (set? contains-right) (conj (disj sets contains-right) \n                                                (apply conj contains-right edge))\n                    :else\n                    (conj sets (apply conj #{} edge)))))]\n    (= 1 (count (reduce group #{} edges)))))","problem":91,"user":"52463059e4b09dbe66b56198"},{"problem":91,"code":"(fn connected? [connections]\n  (letfn [(connect [reachables [l r]]\n           ;; Join the two sides of the reachables\n           ;; Update all nodes involved to the new group\n           (let [group (clojure.set/union (get reachables l #{l})\n                                          (get reachables r #{r}))]\n             (reduce #(assoc % %2 group) reachables group)))]\n    (let [reachables (reduce connect {} connections)\n          nodes      (set (keys reachables))]\n      ;; Only fully connected if each node can reach all nodes\n      (every? (fn [node] (= nodes (reachables node)))\n              nodes))))\n\n;; using dfs/bfs\n;(fn connected? [connections]\n;  (letfn [(to-graph [connections]\n;            (loop [acc {}\n;                   [[start end] & r] (seq connections)]\n;              (if start ;; (some? start)\n;                (recur (-> acc\n;                           (update-in [start] (fnil conj #{}) end)\n;                           (update-in [end]   (fnil conj #{}) start))\n;                       r)\n;                acc)))\n;          (bfs [graph start]\n;            (loop [discovered #{}\n;                   [e & r] [start]]\n;              (if-not e ;; originally (some? e)\n;                discovered\n;                (let [neighbours (graph e)]\n;                  (recur (into discovered neighbours)\n;                         (concat r (remove discovered neighbours)))))))]\n;    (let [graph (to-graph connections)\n;          nodes (set (keys graph))\n;          connecteds (bfs graph (first nodes))]\n;      (= nodes connecteds))))\n\n; More functional approach\n;; (defn to-graph [connections]\n;;   (into {}\n;;         (for [[node edge] (->> connections\n;;                                (concat (map reverse connections))\n;;                                (group-by first))]\n;;           [node (set (map second edge))])))\n\n;; (defn bfs [graph start]\n;;   (->> [[start] #{}] ;; stack discovered\n;;        (iterate (fn [[[e & r] discovered]]\n;;                   (let [neighbours (graph e)]\n;;                     [(concat r (remove discovered neighbours))\n;;                      (into discovered neighbours)])))\n;;        (take-while #(not (empty? (first %))))\n;;        last\n;;        second))","user":"54d341f7e4b0e8a36923e603"},{"problem":91,"code":"(fn connected? [g]\n    (let [all-nodes (-> g seq flatten set)]\n      (loop [reachable #{}\n             pairs g]\n        (cond\n          (empty? reachable)\n          (recur (set (first pairs))\n                 (rest pairs))\n          (empty? pairs)\n          (= reachable all-nodes)\n          :else\n          (let [neighbors (filter (fn [[a b]]\n                                    (or (reachable a) (reachable b)))\n                                  pairs)]\n            (if (empty? neighbors)\n              false\n              (recur (set (concat reachable (flatten neighbors)))\n                     (remove (set neighbors) pairs))))))))","user":"4fde492be4b05e33b9224f8a"},{"problem":91,"code":"(fn gconnected? [g]\n  (let [\n        allnodes (reduce (fn [acc [n1 n2]] (conj acc n1 n2) ) #{} g)\n        start (first (first g))]\n  (letfn [(extend [current] (reduce (fn [s [i1 i2 :as s2]] (if\n                                                             (or (s i1) (s i2))\n                                                             (into s s2)\n                                                             s)) current g)) ]\n    (loop [results #{start}]\n      (let [extended_results (extend results)]\n        (if (= extended_results results)\n          (= allnodes results)\n          (recur extended_results)\n          ))))))","user":"55f2c898e4b06e875b46ce4b"},{"problem":91,"code":"(fn __ [i]\n  (let [g (concat (vec i) (mapv #(vec (reverse %)) i))\n        connectsto (fn [n] (distinct (for [[f t] g :when (= f n)] t)))\n        apass (fn [seen] (distinct (into seen (apply concat (map connectsto seen)))))\n        allnodes (set (distinct (flatten g)))\n        reachable \n        (loop [seen [(ffirst g)]]\n          (if (= (set seen) (set (apass seen)))\n            (set seen)\n            (recur (apass seen))))]\n    (= allnodes reachable)))","user":"4e8768f6535dceadca469850"},{"problem":91,"code":"(fn chk [g]\n  (let [flyd (fn f [r]\n               (letfn [(p [r]\n                          (let [s (for [x r \n                                        y r \n                                        :when (= (second x) (first y))] \n                                    [(first x) (second y)])]\n                            (into r s)))]\n                 (let [s (p r)]\n                   (if (= r s)\n                     r\n                     (f s)))))]\n    (let [n (count (set (apply concat g)))\n          g (into g (map #(reverse %) g))\n          m (count (flyd g))]\n      (= m (* n n)))))","user":"5799ff45e4b05b1deef9add1"},{"code":"(fn f [edges]\r\n  (let [\r\n    maps (map #(list (hash-map (first %) (rest %)) (hash-map (last %) (butlast %))) edges)\r\n    all (apply merge-with concat (flatten maps))\r\n    reachable (fn [self seen start]\r\n      (flatten\r\n        (cons start \r\n          (for [node (all start) :when (not (seen node))]\r\n            (self self (assoc seen node 1) node)))))\r\n  ]\r\n    (or (= 1 (count edges))\r\n      (= (set (keys all)) (set (reachable reachable {} (key (first all))))))))","problem":91,"user":"4f1b92d1535d64f60314647b"},{"problem":91,"code":"(fn is-connected [g]\n  (let [\n    assoc+ (fn assoc+ [map k v] \n             (let [ov (map k)] \n               (assoc map k (if (nil? ov) #{v} (conj ov v)))))\n\n    graph-2-adjacency-list (fn graph-2-adjacency-list [g] \n                             (reduce (fn [m [v1 v2]] (assoc+ (assoc+ m v1 v2) v2 v1)) {} g)) \n    adjacency-list (graph-2-adjacency-list g)\n    nodes (keys adjacency-list)\n    number-of-vertext (count nodes) \n    u (nth nodes (int (rand number-of-vertext)))        \n    flood-fill (fn flood-fill [vertexes neighboors] \n                 (if (= number-of-vertext (count vertexes)) \n                   true \n                   (loop [next-layer-nodes (for [next-v neighboors :when (not (vertexes next-v))] next-v)] \n                     (if (empty? next-layer-nodes) \n                       false \n                       (flood-fill (into vertexes next-layer-nodes) (set (mapcat #(adjacency-list %) neighboors)))))))]\n    \n    (flood-fill #{u} (adjacency-list u))))","user":"525b142fe4b0cb4875a45d05"},{"code":"(fn f [s]\n   (loop [ s (seq s) connected #{} ]\n     (if (empty? s)\n         (= 1 (count connected))\n         (let [ [a b]  (first s)\n                 c_a   (first (filter #(% a) connected))\n                 c_b   (first (filter #(% b) connected)) ]\n           (recur (rest s)\n                  (conj (disj connected c_a c_b) (clojure.set/union #{a} #{b} c_a c_b)))))))","problem":91,"user":"4e860e85535db62dc21a62f1"},{"code":"(fn [x] (letfn [\n    (adjlist [e] (let [\n        ee (concat e (map reverse e))\n        ve (group-by first ee)]\n        (into {} (for [[k v] ve] [k (map second v)]))))\n    (connected? [g] (letfn [\n        (add-vertex [s v] (if (s v) s \n            (reduce add-vertex (conj s v) (g v))))]\n        (= (count (add-vertex #{} (ffirst g))) (count g))))]\n    (connected? (adjlist x))))","problem":91,"user":"51cbdee1e4b08d8387cbede1"},{"problem":91,"code":"(fn [graph]\n  (let [update (fn [m k f x] (assoc m k (f (get m k) x)))\n        sconj (fnil conj #{})\n        graph (reduce (fn [g [n m]]\n                        (-> g\n                            (update n sconj m)\n                            (update m sconj n)))\n                      {} graph)\n        nodes (vec (keys graph))\n        walk (fn walk [walked node]\n               (let [walked (conj walked node)]\n                 (reduce walk walked (clojure.set/difference (graph node) walked))))]\n    (== (count nodes) (count (walk #{} (peek nodes))))))","user":"55dcb06ee4b050e68259b3b9"},{"code":"(fn [graph]\n  (let [V (set (apply concat graph))\n        E (reduce (fn [m [a b]] (-> m (update-in [a] conj b) (update-in [b] conj a)))\n                  (zipmap V (repeat #{})) graph)]\n    (loop [queue (conj clojure.lang.PersistentQueue/EMPTY (first V))\n           visited #{(first V)}]\n      (if (empty? queue)\n        (= visited V)\n        (let [new-adj (->> queue peek E (remove visited))]\n          (recur (-> queue pop (into new-adj))\n                 (into visited new-adj)))))))","problem":91,"user":"4fe84c74e4b07c9f6fd12c3c"},{"code":"(fn [g] \n  (let [vert (set (reduce concat g))\n        compon (set (map #(set [%]) vert))]\n   (= (count (reduce (fn [s e] (let [s1 (first (remove #(= nil (% (first e))) s))\n                            s2 (first (remove #(= nil (% (last e))) s))]\n            (conj (disj s s1 s2) (clojure.set/union s1 s2))))\n      compon g)) 1)))","problem":91,"user":"5065bd94e4b0148eb3925aed"},{"code":"(fn graph-connected [tuples]\n  (letfn [(make-graph [tuples]\n            (reduce (fn [g [a b]]\n                      (update-in\n                       (update-in g [b] #(conj (or % []) a))\n                       [a] #(conj (or % []) b))\n                      ) {}  tuples))\n          (dfs [root graph]\n            (loop [queue [root]\n                   visited (set [root])]\n              (if (empty? queue)\n                visited\n                (let [root (first queue)\n                      queue (drop 1 queue)\n                      verts (filter #(not (contains? visited %)) (get graph root))\n                      visited (set (concat verts visited))\n                      queue (concat queue verts)]\n                  (recur queue visited)))))\n          (node-connected [root graph]\n            (let [all-nodes (set (concat (keys graph) (apply concat (vals graph))))\n                  node-count (count all-nodes)]\n              (= node-count (count (dfs root graph)))))]\n   (let [graph (make-graph tuples)\n         all-nodes (set (concat (keys graph) (apply concat (vals graph))))\n         node-count (count all-nodes)]\n     (every? identity (map #(= node-count (count (dfs % graph))) all-nodes)))))","problem":91,"user":"532b43c3e4b09d4e7a9b5531"},{"problem":91,"code":"(fn [s]\n  (let [t (->> (mapcat\n                 (fn [[a b]]\n                   [a b])\n                 s)\n               (set))\n        g (fn g [[i j] r s]\n            (let [r (conj r [i j])\n                  t (filter\n                      (fn [[a b]]\n                        (or (= i b) (= j a) (= i a) (= j b)))\n                      s)]\n              (if (empty? (clojure.set/difference (set t) r))\n                r\n                (clojure.set/union\n                  r\n                  (mapcat\n                    #(g % r (disj s [i j]))\n                    t)))))]\n    (= (count t)\n       (count (set (flatten (vec (g (first s) #{} (disj s (first s))))))))))","user":"5af907e6e4b0cc2b61a3bcda"},{"code":"(fn [es]\r\n  (let [xs (seq es)\r\n        vs (seq (into #{} (flatten xs)))\r\n        l0 (for [i vs j vs] [i j])\r\n        l1 (for [[i j] l0] (if (= i j) 1 0))\r\n        m0 (apply (partial assoc {}) (interleave l0 l1))\r\n        xs1 (concat xs (for [[x y] xs] [y x]))\r\n        m1 (apply (partial assoc m0)\r\n                  (interleave xs1 (repeat (count xs1) 1)))]\r\n    (letfn [(mmult [m1 m2]\r\n              (let [l2 (for [[i j] l0] (apply + (for [k vs] (* (m1 [i k]) (m2 [k j])))))]\r\n                (apply (partial assoc {}) (interleave l0 l2))))]\r\n      (not (some zero? (vals (nth (iterate (partial mmult m1) m1) (dec (count vs)))))))))","problem":91,"user":"4dc1ee85535d020aff1edf91"},{"code":"(fn [E]\n  (let [f     (first (flatten (seq E)))\n        used  (atom #{f})\n        total (count (distinct (flatten (seq E))))\n        edges (filter #(= (count %) 2) (set (map set E)))]\n    ((fn dfs [u]\n       (doseq [v (map #(first (disj % u)) (filter #(% u) edges))]\n         (when ((complement @used) v)\n           ((swap! used conj v)\n            (dfs v)))))\n       f)\n    (= (count @used) total)))","problem":91,"user":"5061cc17e4b0a30dc9a35d34"},{"code":"(fn [s]\n  (= (count (distinct (flatten (seq s)))) \n     (count (nth \n             (iterate \n               (fn [o] (into o (for [n o v s :when (some #(= n %) v)] (if (= n (v 0)) (v 1) (v 0)))))\n               #{(ffirst s)})\n             (count s))\n            )))","problem":91,"user":"4f1d1d95535d64f603146488"},{"problem":91,"code":"(fn connected? [edges]\n  (let [n (->> edges (apply concat) set count)]\n    (loop [search (set (first edges))]\n      (if (= n (count search)) true\n        (let [expand (reduce into search (filter (partial some search) edges))]\n          (if (= expand search) false\n            (recur expand)))))))","user":"5d929ceae4b0915913b1d412"},{"problem":91,"code":"(fn [a] (let [item-seq (reduce #(clojure.set/union %1 (set %2)) #{} a)\n                                  item-set (reduce #(conj %1 (set %2)) #{} a)\n                                  item-map (reduce #(merge %1 %2)\n                                                   {}\n                                                   (mapv #(hash-map %1 %2)\n                                                         item-seq\n                                                         (mapv (fn [item] (apply clojure.set/union\n                                                                                 (filter (fn [i-set] (contains? i-set item)) item-set)\n                                                                                 )) item-seq)))]\n                              (letfn [(get-result [e] (reduce (fn [x y] (conj x y)) {} (for [x e]\n                                                                                        {(get x 0) (clojure.set/union (get x 1)\n                                                                                                                      (reduce #(clojure.set/union %1 (get e %2)) #{} (get x 1)))}\n                                                                                        )))]\n                                (loop [e item-map, f (get-result e)]\n                                  (if (= e f)\n                                    (do\n                                      (print \"item-seq=\" e)\n                                      (println \"(first (seq item-map))=\" (get f (first (seq item-seq))))\n                                      (= item-seq (get f (first (seq item-seq)))))\n                                    (recur f (get-result f)))))))","user":"5cf72682e4b0b71b1d808a68"},{"code":"(fn connected? [graph]\n  (letfn [(test [c remaining]\n    (if (empty? remaining)\n      true\n      (let [node (some #(when (some c %) %) remaining)]\n        (if (nil? node)\n          false\n          (recur (into c node) (remove #(= node %) remaining))))))]\n  (test (into #{} (first graph)) (rest graph))))","problem":91,"user":"4e7db3b4535db169f9c796e1"},{"code":"(fn breadth-first [g]\n  (loop [Q [(first (first g))]\n         seen #{(first (first g))}]\n    (let [u (peek Q)\n          Q (pop Q)\n          edges (filter #(or (= u (first %)) (= u (second %))) g)\n          neighbors (map #(if (= u (first %)) (second %) (first %)) edges)\n          unseen (clojure.set/difference (set neighbors) seen)\n          Q (into Q unseen)\n          seen (into seen unseen)]\n      (if (not-empty Q)\n        (recur Q seen)\n        (= (count seen)\n           (count (set (flatten (seq g)))))))))","problem":91,"user":"52d3f666e4b09f7907dd1327"},{"problem":91,"code":"(fn [xs]\n  (let [cs (reduce (fn [cs [q p]]\n                    (assoc cs q (conj (get cs q #{}) p)\n                              p (conj (get cs p #{}) q))) {} xs)]\n    (loop [v #{}\n           c [(ffirst cs)]]\n      (if (seq c)\n        (let [v2 (into v c)]\n          (recur v2 (remove v2 (mapcat cs c))))\n        (= v (into #{} (flatten (seq xs))))))))","user":"4f9d8083e4b0dcca54ed6d23"},{"code":"(fn [edges] (let [nodes (reduce #( apply conj %1 %2)  #{} edges) \n                                 ; convert from undirected to directed edges on the graph \n                                 allrels (concat edges (map (fn [x] [(second x) (first x)] ) edges))\n                                 firstnode (first nodes)\n                                 unvisitednodes (set (rest nodes))]\n                             (loop [black #{} grey #{ firstnode }  white (set unvisitednodes)]\n                               (if (empty? grey)\n                                 ; if there are any white and no grays the graph is not connected\n                                 (empty? white)\n                                 (let [ firstgrey (first grey)\n                                        remaining-grey (disj grey firstgrey)\n                                        reachable-from-grey (set (filter #(not (contains? black %1)) (map #( second %1 )(filter #(= (first %1) firstgrey) allrels))))\n                                        new-white (filter #(not (contains? reachable-from-grey %1)) white)\n                                        new-grey (clojure.set/union remaining-grey reachable-from-grey) \n                                        ]                                        \n                                 (recur (conj black firstgrey) new-grey new-white)\n                               )))))","problem":91,"user":"50956c2be4b087f34d351ab2"},{"code":"#(let [vc (vec %)]\n    (loop [s (set (first vc))\n           uc #{}\n           r (rest vc)]\n      (let [cuc (count uc) fr (first r) rr (rest r)]\n      (cond\n       (= 0 cuc (count r)) true\n       (and (= 0 (count r)) (not= 0 cuc)) false\n       :else \n       \t(if (= (count (into s fr)) (+ 2 (count s)))\n          (recur s (into uc fr) rr)\n          (if (= (count (into uc fr)) (+ 2 cuc))\n          \t(recur (into s fr) uc rr)\n               (recur (into s (concat fr uc)) #{} rr)))))))","problem":91,"user":"53973e7be4b0b51d73faaee6"},{"code":"(fn [E] \n  (let [V (frequencies (flatten (into [] E)))] (print V)\n    (= (count V)\n       (count \n         (nth \n           (iterate \n             (fn [cur] (clojure.set/union cur (set (flatten (filter #(some cur %) E))))) \n              #{(-> E first first)}\n              )\n           (count E)\n           )\n         )\n       )\n    )\n  )","problem":91,"user":"514457fbe4b0b4fb4ace5f43"},{"problem":91,"code":"#(letfn [(f [m]\n           (let [n (reduce\n                     (fn [r [a b]]\n                       (if (or (r a) (r b))\n                         (into r [a b])\n                         r))\n                     m %)]\n             (if (= n m)\n               n\n               (f n))))]\n   (= (f #{(ffirst %)}) (set (flatten (seq %)))))","user":"4eb70649535d7eef30807373"},{"problem":91,"code":"(fn [edges]\n  (let [graph (reduce (fn [g [a b]]\n                (-> (assoc g a (conj (or (get g a) []) b))\n                    (assoc   b (conj (or (get g b) []) a))))\n            \t{}\n            \tedges)]\n    ((fn visit [n v]\n      (if (= (count graph) (count v))\n        true\n        (let [adj (filter (fn [x] (not (contains? v x))) (get graph n))]\n          (if (empty? adj)\n            (= (inc (count v)) (count graph))\n            (visit (first adj) (conj v n))))))\n     (first (keys graph))\n     #{})))","user":"55495318e4b0a04f79299566"},{"problem":91,"code":"(fn [edges]\n  (= (set (apply concat edges))\n     (loop [vs #{(ffirst edges)}]\n       (if-let [nvs (seq (for [[a b] edges :when (and (vs a) (not (vs b)))] b))]\n         (recur (into vs nvs))\n         vs))))","user":"52b02329e4b0c58976d9acc5"},{"problem":91,"code":"(letfn [(travel [{:keys [edge-map positions visited] :as graph}]\n          (let [new-positions (->> positions\n                                   (select-keys edge-map)\n                                   (map second)\n                                   (apply clojure.set/union)\n                                   (remove visited)\n                                   set)]\n            (-> graph\n                (assoc :positions new-positions)\n                (update-in [:visited] clojure.set/union new-positions))))\n\n        (connected? [{:keys [positions visited nodes] :as graph}]\n          (if (empty? positions)\n            (= visited nodes)\n            (recur (travel graph))))\n\n        (build-graph [edges]\n          (let [edge-map (->> (concat edges (map (fn [[a b]] [b a]) edges))\n                              (map (fn [[a b]] {a #{b}}))\n                              (apply merge-with clojure.set/union))]\n            {:edge-map edge-map\n             :positions #{(ffirst edge-map)}\n             :visited #{}\n             :nodes (set (keys edge-map))}))]\n  (fn [edges] (->> edges build-graph connected?)))","user":"55f2e47de4b06e875b46ce4d"},{"code":"(fn f \n  ([s] (f #{} s))\n  ([s xs]\n     (if (seq xs)\n       (if (empty? s)\n\t (f (into s (first xs)) (set (next xs)))\n         (if-let [e (first (filter #(some s %) xs))]\n\t   (f (into s e) (disj xs e))\n\t   false))\n       (not (empty? s))\n       )))","problem":91,"user":"4ef9c8f9535dced4c769f26b"},{"code":"(fn a [g]\n  (let\n    [union #(reduce conj %1 %2)\n    g-new (map set g)\n    vs (reduce union #{} g-new)\n    m (group-by\n        #(contains? % (first (first g-new)))\n        g-new)]\n      (if (= (count (get m false)) 0)\n        true\n        (if (and (= (count (get m true)) 1) (= (count (first g-new)) 1)) \n          false\n          (a (set\n          (cons\n            (disj (reduce union #{} (get m true)) (first (first g-new)))\n            (get m false))))))))","problem":91,"user":"4fb1325de4b081705acca276"},{"problem":91,"code":"(fn[s](\n     loop[ x (set(last (vec s))) y (pop (vec s)) l -1 ](\n       if(= (count y) l) (if(= l 0) true false)\n       (recur\n         \n         (clojure.set/union x \n                 (set(flatten\n                       (filter \n                         (fn[itm](\n                           or\n                           (contains? x (first itm))\n                           (contains? x (second itm))\n                         ))\n                         y\n                       )\n                 ))\n         )\n         \n         (filter \n                         (fn[itm](\n                           not(or\n                           (contains? x (first itm))\n                           (contains? x (second itm)))\n                         ))\n                         y\n                       )\n         \n         (count y)\n         \n       )\n     )\n  ))","user":"56039843e4b04bb52996e1be"},{"problem":91,"code":"(fn connected-graph [g]\n\t(let [verts (distinct (apply concat g))\n\t\tedges\n\t\t(reduce (fn [m [e1 e2]]\n\t\t\t(assoc m \n\t\t\t\te1 (conj (m e1 []) e2)\n\t\t\t\te2 (conj (m e2 []) e1)))\n\t\t   {} g)]\n\t\t(loop [seen #{(first verts)} unvisited [(first verts)]]\n\t\t\t(cond\n\t\t\t\t(= seen (set verts)) true\n\t\t\t\t(empty? unvisited) false\n\t\t\t\t:else\n\t\t\t\t(let [v (first unvisited)\n\t\t\t\t\t  unseen-neighbors (filter #(not (seen %)) (edges v))]\n\t\t\t\t\t  (recur (clojure.set/union\n\t\t\t\t\t  \t\t\tseen\n\t\t\t\t\t  \t\t\t(set unseen-neighbors))\n\t\t\t\t\t  \t\t (concat (rest unvisited) unseen-neighbors)))))))","user":"54448e84e4b032a45b869393"},{"code":"(fn [edges]\n   (let [vs (reduce (fn [mp [s e]]\n                      (-> mp\n                          (assoc s (conj (get mp s []) e))\n                          (assoc e (conj (get mp e []) s))))\n                    {} edges)\n         [k1, v1] (first vs)]\n     (loop [togo v1 rst (dissoc vs k1)]\n       (let [node (first togo)]\n         (cond\n          (empty? rst) true\n          (empty? togo) false\n          (get rst node) (recur (concat (rest togo) (get rst node)) (dissoc rst node))\n          true (recur (rest togo) rst))))))","problem":91,"user":"4eb02674535d7eef30807338"},{"code":"(fn [g]\n        (letfn [(n [v] (remove nil? (map (fn [[a b]] (cond (= a v) b\n                                                                 (= b v) a\n                                                                 :else nil))\n                                               g)))\n               (d [s v]\n                    (if (s v)\n                        s\n                        (->> (n v)\n                             (reduce d (conj s v)))))]\n           (= (d #{} (first (first g)))\n              (reduce into #{} g))))","problem":91,"user":"4f465096e4b0d56e7bb92b9a"},{"problem":91,"code":"(fn [graph]\n    (let [islands (reduce\n                    (fn [islands [from to]]\n                      (let [find-island (fn [node]\n                                          (into #{} ;into ensures the result is non-nil (i.e. potentically an empty set)\n                                            (first\n                                              (doto\n                                                (for [island islands :when (island node)]\n                                                     island)\n                                                #(assert (<= (count %) 1))))))\n                            island-from (find-island from)\n                            island-to   (find-island to)]\n                          \n                        (conj (disj islands island-from island-to) ;empty (new) islands and duplicate edges are OK\n                          (into island-from\n                            (conj island-to from to)))))\n                    #{}\n                    graph)]\n      (= (count islands) 1)))","user":"5b999af8e4b0c0b3ffbd4ad3"},{"problem":91,"code":"(fn connected? [edges]\n  (let [comps0 (into #{} (map set edges))\n        intersects? #(not (empty? (clojure.set/intersection %1 %2)))\n        c? (fn c? [comps]\n             (let [comp0 (first comps)\n                   rcomp (disj comps comp0)\n                   mcomp (filter #(intersects? comp0 %) rcomp)\n                   ncomp (apply disj rcomp mcomp)]\n               (cond (= 1 (count comps)) true\n                     (empty? mcomp) false\n                     (empty? ncomp) true\n                     :else (c? (set (cons (apply clojure.set/union comp0 mcomp)\n                                          (apply disj rcomp mcomp)))))))]\n    (c? comps0)))","user":"5a566e8fe4b05d388ecb6c51"},{"problem":91,"code":"(letfn [                                                                                                                                                \n    (get-nodes [edges] (-> edges vec flatten set (zipmap (range))))                                                             \n    (square-matrix [size] (map (fn [_] (repeat size 99)) (range size)))                                                                                 \n    (set-ij [m i j v]                                                                                                           \n        (let [row (nth m j)                                                                                                                             \n              row- (concat (take i row) [v]  (nthnext row (inc i)))]                                                            \n            (concat (take j m) [row-] (nthnext m (inc j)))))                                                                                            \n    (get-ij [m i j] (-> m (nth j) (nth i)))                                                                                     \n    (transitive-closure [edges] (let [                                                                                                                  \n        nodes (get-nodes edges)                                                                                                 \n        node-count (count nodes)                                                                                                                        \n        graph (-> (square-matrix node-count)                                                                                    \n                  (#(reduce (fn [m [a b]] (set-ij m (nodes a) (nodes b) 1)) % edges))                                                                   \n                  (#(reduce (fn [m [a b]] (set-ij m (nodes b) (nodes a) 1)) % edges))                                           \n                  (#(reduce (fn [m i] (set-ij m i i 0)) % (range node-count))))                                                                         \n        distance (reduce                                                                                                        \n                      (fn [m [i j k]] ; this is the floyd-warshall algorithm                                                                            \n                          (let [ij (get-ij m i j) ik (get-ij m i k) kj (get-ij m k j)]                                          \n                              (if (< (+ ik kj) ij)                                                                                                      \n                                  (set-ij m i j (+ ik kj))                                                                      \n                                  m)))                                                                                                                  \n                      graph                                                                                                     \n                      (for [k (range node-count) i (range node-count) j (range node-count)] [i j k]))]                                                  \n            distance))                                                                                                          \n    (is-reachable? [s] (not-any? (partial = 99) (flatten (transitive-closure s))))]                                                                     \n        is-reachable?)","user":"558b50d5e4b027778923762b"},{"problem":91,"code":"(fn [graph] \n    (let [nodes (reduce clojure.set/union (map set graph))\n          edges (filter (fn [[s t]] (not= s t)) graph)\n          v0 (first nodes)]\n        (letfn [(succ [v] (->> edges\n                               (filter (fn [[s t]] (#{s t} v)))\n                               (map (fn [[s t]] (if (= v s) t s)))\n                               (set)))\n                (reachable [v]\n                    (loop [pending [v]\n                           acc #{v}]\n                        (if (empty? pending)\n                            acc\n                            (let [v (first pending)\n                                  vs (set (filter #(not (acc %)) (succ v)))\n                                  pending' (concat vs (rest pending))\n                                  acc' (clojure.set/union acc vs)]\n                                (recur pending' acc')))))]\n            (= (reachable v0) nodes))))","user":"600ae927e4b074f607df6689"}]