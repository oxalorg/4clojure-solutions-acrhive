[{"problem":103,"code":"(fn C [k s]\n    (cond\n      (zero? k) #{#{}}\n      (empty? s) #{}\n      :else (set (clojure.set/union\n              (map #(conj % (first s)) (C (dec k) (rest s)))\n              (C k (rest s))))))","user":"4fc4eb1ee4b081705acca354"},{"problem":103,"code":"(fn perms ([k s] (set (perms #{} k (vec s)))) ([p l s] (if (zero? l) [p] (apply concat (map-indexed (fn [i e] (perms (conj p e) (dec l) (subvec s (inc i)))) s)))))","user":"5abe2fc2e4b073f17744271e"},{"code":"(fn [n s]\n  (loop [c (into #{} (for [x s] #{x}))\n         n n]\n    (if (> n 1)\n      (recur\n       (into #{} (for [x c y s :when (not (x y))]\n                  (conj x y)))\n       (dec n))\n      c)))","problem":103,"user":"4eb2eae5535d7eef30807351"},{"problem":103,"code":"(fn kc [k xs]\n  (cond\n   (= 0 k) #{#{}}\n   (empty? xs) #{}\n   :else\n   (let [y (first xs) ys (rest xs)]\n     (set (concat (kc k ys) (map #(conj % y) (kc (dec k) ys)))))))","user":"553e0b70e4b0a04f792994e8"},{"code":"(fn k-comb [n coll]\n  (cond\n   (zero? n) []\n   (= 1 n) (set (map set (map vector coll)))\n   :else (set (mapcat\n     #(set (map (fn [x] (set (cons % x))) (k-comb (dec n) (disj coll %))))\n     coll\n     ))\n    )\n  )","problem":103,"user":"52e59ca5e4b09f7907dd1464"},{"problem":103,"code":"(fn myf [n coll]\n  (letfn [(subfn [coll e] \n            (apply hash-set (concat (map #(merge % e) coll) coll)))]\n    (->> (reduce subfn #{#{}}  coll)\n      (filter #(= n (count %)))\n      (apply hash-set)\n      )))","user":"577c3da9e4b0c8d87281f6b9"},{"problem":103,"code":"(comp set (fn c [k s]\n            (if (= k 0) #{#{}}\n              (if-let [[e & f] (seq s)]\n                (into (c k f) (for [u (c (dec k) f)] (conj u e)))\n                #{}))))","user":"4f5eda39e4b0030a34fb2b56"},{"problem":103,"code":"(fn [n xs]\n    (letfn [(simple-shift [xs] (conj (butlast xs) (last xs)))\n            (rotate-seq [ys]\n              ((fn [n xs r]\n                 (if (not (zero? n))\n                   (recur (dec n) (simple-shift xs) (into r [(simple-shift xs)]))\n                   r)\n                 ) (.size ys) ys [])\n            )\n            (get-all-combinations-adv [xs]\n              ((fn [k zs r]\n                 (if (= k (.size zs))\n                   r\n                   (recur (inc k) zs (into r (map #(into % (first (split-at k zs))) (rotate-seq (last (split-at k zs))))))\n                   )\n                 )\n                1 xs []\n                )\n              )\n            (full-rotate-seq [xs]  (apply concat (map #(get-all-combinations-adv %)\n                                                      (rotate-seq xs))))\n            ]\n      (into #{}\n            (map set (apply concat (map #(partition n %) (full-rotate-seq xs))  ))\n            )\n      )\n   )","user":"55d7312ee4b0e31453f64a9f"},{"code":"(fn f [k s]\n  (cond\n   (zero? k) #{#{}}\n   (empty? s) #{}\n   :else (set\n           (for [i s\n                 x (f (dec k)(disj s i))]\n             (conj x i)))))","problem":103,"user":"50a83315e4b054305ba5a830"},{"problem":103,"code":"(fn combinations\n  [k coll]\n  (letfn [(comb-aux\n\t       [m start]\n\t       (if (= 1 m)\n\t         (for [x (range start (count coll))]\n\t           (list x))\n\t         (for [x (range start (count coll))\n\t\t           xs (comb-aux (dec m) (inc x))]\n\t           (cons x xs))))]\n    (let [indices (comb-aux k 0)\n          coll (vec coll)]\n      (into #{}\n            (map (fn [idxs] (into #{} (map coll idxs))) indices)))))","user":"571c2babe4b07c98581c3b73"},{"code":"(fn k-comb [n s]\n   (cond\n    (> n (count s)) #{}\n    (empty? s)      #{}\n    (= 1 n)         (set (map #(set (list %)) s))\n    :else           (let [x    (first s)\n                          ys   (k-comb n (rest s))\n                          ys-1 (k-comb (dec n) (rest s))]\n                      (set (concat ys (set (map #(conj % x) ys-1)))))))","problem":103,"user":"4ea1b9e4535d7eef308072b8"},{"problem":103,"code":"(fn [x y] (set (filter #(= (count %) x) (reduce (fn [acc e] (into acc (map #(conj % e) acc))) #{#{}} y))))","user":"56f7ecdfe4b08e7d20b96834"},{"problem":103,"code":"(fn generate-k [n g]\n  (letfn [(generate-subsets [s]\n    (letfn [(get-next-binary [s]\n              (let [found (atom false)]\n                (for [x s]\n                  (if @found x\n                      (if (= 0 x) (do (reset! found true) 1)\n                          0)))))\n              (convert-binary-to-set [s b]\n                (let [items (into [] s)]\n                  (->>\n                    (filter #(= (nth b %) 1) (range (count b)))\n                    (map (fn [x] (nth items x)))\n                    set)))]\n      (->>\n        (count s)\n        range\n        (map (fn [x] 0))\n        (iterate get-next-binary)\n        (take (Math/pow 2 (count s)))\n        (map #(convert-binary-to-set s %))\n        set)))]\n    (into #{} (filter #(= (count %) n) (generate-subsets g)))))","user":"5b15811ee4b0cc2b61a3be6f"},{"code":"; based on previous task - just added filter\n(fn pick [k coll]\n  (set (filter #(= k (count %))\n   (reduce \n   (fn [r n] \n     (clojure.set/union r \n      (map #(conj % n) r))\n     )\n   #{#{}} coll))))","problem":103,"user":"50de11b2e4b061dbdced7217"},{"problem":103,"code":"(fn p-103 [k s]\n  (if (< (count s) k) #{}\n      (let [vec-remove\n            (fn vec-remove\n              [coll pos]\n              (vec (concat (subvec coll 0 pos) (subvec coll (inc pos)))))\n\n            list-remove (fn [coll pos]\n                          (apply list (vec-remove (vec coll) pos)))\n            perms (fn perms [s]\n                    (if (empty? s) '(())\n                        (let [ct (count s)\n                              firsts (map (partial nth s) (range ct))\n                              rests (map (partial list-remove s) (range ct))\n                              pairs (map list firsts rests)]\n                          (mapcat (fn [[frst rst]]\n                                    (map #(conj % frst) (perms rst))) pairs))))\n            all-perms  (perms (into '() s))]\n        (set (map set (distinct (map (partial take k) all-perms)))))))","user":"5bfc9037e4b0bdcf453d15f2"},{"code":"(fn k-comb [n items]\n  (cond\n    (zero? n) #{#{}}\n    (zero? (count items)) #{}\n    :else\n      (let [i (first items)\n            rem (disj items i)]\n        (into (k-comb n rem)\n          (map #(conj % i)\n            (k-comb (dec n) rem))))))","problem":103,"user":"4ddbfb8a535d02782fcbea00"},{"code":"#(let [n (fn f [r l s]\r\n            (for [e s :let [n (conj r e)]]\r\n              (if (= l (count n)) n (f n l (disj s e)))))]\r\n    (set (flatten (n #{} % %2))))","problem":103,"user":"4e9609ad535dbda64a6f6b3e"},{"problem":103,"code":"(fn [n s]\n  (let [p (fn [c n s]\n            (cond (zero? n) (assoc c 0 #{})\n                  (= n 1) (assoc c 1 (set (map hash-set s)))\n                  :else (assoc c n\n                                 (reduce into #{}\n                                         (for [i s]\n                                           (map #(conj % i) (c (dec n))))))))]\n    (cond\n      (< (count s) n) #{}\n      (= (count s) n) (hash-set (set s))\n      :else (set (filter #(= (count %) n)\n                         ((reduce #(p % %2 s) {} (range (count s))) n s))))))","user":"56874171e4b0dcc4269f405c"},{"problem":103,"code":"(fn [n s]\n  (let [exp (fn [[wip rem]] (set (map (fn [el] [(conj wip el) (disj rem el)]) rem)))]\n    (loop [progress #{ [#{} s]}  n n ]\n      (if (zero? n) (into #{} (for [p progress] (first p)))\n          (recur (mapcat exp progress) (dec n))))))","user":"5e078ba7e4b0978307768fb6"},{"problem":103,"code":"(fn k-combinations [n s]\n  (if (> n (count s)) #{}\n    (if (= 1 n) (into #{} (map (comp set vector) s))\n      (let [prior (k-combinations (dec n) s)]\n        (into #{} (for [p prior\n              q (clojure.set/difference s p)]\n          (clojure.set/union p #{q})\n          ))))))","user":"549dfe40e4b0f3d1d8e70f9a"},{"problem":103,"code":"(fn k-combos [k s]\n  (cond\n    (or (empty? s) (> k (count s))) #{}\n    (= k 1) (set (map hash-set s))\n    (= k (count s)) #{(set s)}\n    :else\n    (set (concat\n          (map #(conj % (first s)) (k-combos (dec k) (rest s)))\n          (k-combos k (rest s))))))","user":"54e3df6ae4b024c67c0cf7e3"},{"code":"(fn kcomb\n  ([k col]\n   (kcomb k col #{}))\n  ([k col pret]\n   (if (empty? col)\n     (into #{} (filter (fn [e] (= (count e) k)) pret))\n     (recur k (rest col) (reduce (fn [ret this]\n                                   (conj ret\n                                         (conj this (first col))))\n                                 (conj pret (hash-set (first col))) pret)))))","problem":103,"user":"513cb853e4b0b86ece9f322b"},{"code":"(fn kcomb [k s]\n  ((fn kcomb-sub [k s acc]\n     (if (= 0 k) #{acc}\n         (apply clojure.set/union #{}\n                (for [e s]\n                  (kcomb-sub (dec k) (disj s e) (conj acc e)))))) k s #{}))","problem":103,"user":"529ce629e4b04e0c58e87b6e"},{"problem":103,"code":"(fn [k coll]\n  (letfn [(f [p v] (into #{} (map #(conj % v) p)))\n          (ps [coll]\n            (if (empty? coll)\n              #{#{}}\n              (let [v (first coll)\n                    r (disj coll v)\n                    p (ps r)]\n                (concat p (f p v)))))]\n    (into #{} (filter #(= k (count %)) (ps coll)))\n  ))","user":"5a9dbb32e4b0d174b936c7f3"},{"problem":103,"code":"(fn [k els]\n  (let [ps (fn [s]\n             (reduce\n               (fn [results el]\n                 (apply conj results\n                        (map #(conj % el) results)))\n               #{#{}}\n               s))]\n    (set (filter #(= k (count %)) (ps els)))\n    ))","user":"56ff45e5e4b08d47c97781bb"},{"code":"(fn c [k s]\n  (cond\n   (empty? s) #{}\n   (= 1 k) (set (map #(hash-set %) s))\n   :else\n   (set\n    (let [ss (seq s)\n          h (first ss)\n          t (-> ss rest set)]\n      (concat\n       (map #(conj % h) (c (dec k) t))\n       (c k t))))))","problem":103,"user":"524ae8e6e4b09eba1c0223b5"},{"code":"(fn [k s]\n(set\n (filter #(= k (count %))\n(reduce \n #(concat\n   % \n   (map (fn [x] (conj x %2)) %)) \n [#{}]\n s\n))))","problem":103,"user":"514457fbe4b0b4fb4ace5f43"},{"problem":103,"code":"(fn k-combos [k s]\n  (loop [i 0 res #{#{}}]\n    (if (== i k)\n      res\n      (recur (inc i)\n             (set (for [x s\n                        r res\n                        :when (not-any? #{x} r)]\n                    (conj r x)))))))","user":"5c950334e4b048ec896c5a44"},{"problem":103,"code":"(fn __ [n s]\n  (into #{} (filter #(= n (count %))\n                    (reduce (fn [r e]\n                              (into (conj r #{e})\n                                    (map #(conj % e) r))\n                              ) #{} s))))","user":"5a0ce1a5e4b04bbd27e6d9b7"},{"code":"(fn c [n s]\n  (cond \n    (zero? n) #{#{}}\n    (empty? s) #{}\n    :else (reduce conj \n            (set (map #(conj % (first s)) (c (dec n) (rest s))))\n            (c n (rest s)))))","problem":103,"user":"4e8e8c24535d65386fec2143"},{"problem":103,"code":"(fn [k xs]\n  (letfn [(mk-set [sofar remaining k]\n                  (cond (zero? k) #{sofar}\n                        (empty? remaining) nil\n                        :else (let [[f & remaining] remaining]\n                                (concat (mk-set (conj sofar f)\n                                                remaining \n                                                (dec k))\n                                        (mk-set sofar \n                                                remaining\n                                                k)))))]\n  (->> (mk-set #{} \n               (seq xs) \n               k)\n       (into #{}))))","user":"5ebdb3d2e4b00a66d4a95275"},{"problem":103,"code":"(fn fixed-combis [n s]\n  (let [combis (fn combis [s]\n                 (if (empty? s)\n                   #{}\n                   (conj\n                     (set (for [e s\n                                r (combis (disj s e))]\n                            r))\n                     s)))]\n    (set (filter #(= n (count %)) (combis s)))))","user":"590b055ae4b047aa04b199c9"},{"problem":103,"code":"(fn [n s]\n  (letfn [(x-combs [n s]\n            (if (= n 1) \n              (map #(conj #{} %) s)\n              (let [h (first s)\n                    t (disj s h)]\n                (concat (map (fn [x] (into #{h} x)) (x-combs (dec n) t))\n                        (when (> (count t) 1)\n                          (x-combs n t))))))]\n    (set (x-combs n s))\n)\n  )","user":"55f09e7be4b06e875b46ce28"},{"code":"(fn [n s]\n  (let [p (fn [c n s]\n               (cond (zero? n) (assoc c 0 #{})\n                     (= n 1) (assoc c 1 (set (map hash-set s)))\n                     :else (assoc c n\n                                  (reduce into #{} \n                                          (for [i s]\n                                            (map #(conj % i) (c (dec n))))))))]\n       (cond\n        (< (count s) n) #{}\n        (= (count s) n) (hash-set (set s))\n        :else (set (filter #(= (count %) n) \n                           ((reduce #(p % %2 s) {} (range (count s))) n s))))))","problem":103,"user":"4f47eab2e4b0d56e7bb92bc6"},{"problem":103,"code":"(fn [K S]\n  (letfn [(kcom [k s] \n             (cond (< (count s) k) #{}\n                    (= 1 k)  (apply hash-set (for [e s] #{e}))\n                     :else   (apply clojure.set/union  (for [e s]   (apply hash-set (map #(clojure.set/union % #{e}) (kcom (dec k) (disj s e)))) ))))]\n    (kcom K S))\n  \n  )","user":"5649615be4b0284900eef641"},{"problem":103,"code":"(fn k-combi\n  ([n xs]\n   ((comp set (partial remove nil?) flatten) (k-combi n xs #{})))\n  ([n xs s]\n   (println n xs s)\n   (cond\n     (= n (count s)) s\n     (empty? xs) nil\n     :else [(k-combi n (rest xs) (conj s (first xs)) )\n            (k-combi n (rest xs) s)])))","user":"5ec3a13ae4b08d0ec38692b9"},{"problem":103,"code":"(fn kc [n sss] \n  (let [[x & xs :as xx] (vec sss)]\n    (cond\n      (= n 1) (set (map hash-set xx))\n      (<= n (count xx)) (set (concat (for [q (kc (dec n) xs)] (conj q x)) (kc n xs)))\n      :else #{})))","user":"5b919d9de4b0c0b3ffbd4a24"},{"code":"(fn comb [k xs]\n  (set\n    (letfn [(powerset [xs]\n              (if (empty? xs) #{#{}}\n                (clojure.set/union (powerset (next xs))\n                                   (map #(conj % (first xs)) (powerset (next xs))))))]\n      (filter #(= (count %) k) (powerset xs)))))","problem":103,"user":"52606318e4b03e8d9a4a7036"},{"problem":103,"code":"(fn k-combinations\n  [n s]\n  (letfn [(power-set*\n            [s ps]\n            (if-not (empty? s)\n              (recur (rest s) (clojure.set/union ps (into #{} (map #(conj % (first s)) ps))))\n              ps))]\n    (set (filter #(= n (count %)) (power-set* s #{#{}})))))","user":"506f0968e4b09350ab4199f5"},{"code":"(fn combinations [k s]\n  (set\n    (filter #(= k (count %))\n      (flatten\n        (reduce (fn [ss x]\n                  (map (fn [a b] (concat a (map #(conj % x) b)))\n                       (concat ss [nil]) (concat [nil] ss)))\n                [[#{}]] s)))))","problem":103,"user":"4f50c414e4b03ad3f0c10d0d"},{"code":"(fn k-combi [k S]\n  (cond \n   (= k 0) #{#{}}\n   (> k (count S)) #{}\n   :default (let [s (set S) el (first s) remainder (next s)]\n     (set (concat (k-combi k remainder) (set (map #(conj % el) (k-combi (dec k) remainder)))))\n     )\n   ))","problem":103,"user":"525dd767e4b0cb4875a45d88"},{"problem":103,"code":"(fn k-comb [k S]\r\n  (let [size (count S)]\r\n    (cond\r\n      (> k size) #{}\r\n      (= k size) #{S}\r\n      (= k 1)    (set (map (fn [s] #{s}) S))\r\n      (= k 0)    #{#{}}\r\n      :else      (set (mapcat\r\n                       (fn [s]\r\n                         (map #(clojure.set/union s %)\r\n                              (k-comb (dec k)\r\n                                      (clojure.set/difference S s))))\r\n                       (k-comb 1 S))))))","user":"55d0e76ae4b0e31453f64a40"},{"problem":103,"code":"; not the most efficient, but very low effort\n(fn [k s]\n  (letfn [(powerset [coll] \n            (reduce \n              (fn [a x] (into a (map #(conj % x) a)))\n              #{#{}} coll))]\n    (into #{} (filter #(= k (count %)) (powerset s)))))","user":"5aa998c6e4b0d174b936c8e5"},{"problem":103,"code":"(fn comb[n s] \n  (cond (= n 0) #{#{}} \n    \t(empty? s) #{}\n      \t:else\n        (into (comb n (rest s)) \n              (map #(conj % (first s)) \n                   (comb (- n 1)(rest s))))))","user":"5457e5f1e4b01be26fd74613"},{"code":"(fn c[n s]\n  (cond\n   (> n (count s)) #{}\n   (= n 0) #{{}}\n   :else\n   (set\n   (reduce into\n   (for [x (range (inc (- (count s) n))) :let [y (drop x s)]]\n     (for [z (c (dec n) (rest y))]\n       (into #{(first y)} z)))))))","problem":103,"user":"52f818a6e4b047fd55836fcc"},{"problem":103,"code":"(fn [n p]\n  (set (filter #(= n (count %)) (reduce (fn [acc s] (into acc (map #(conj % s) acc))) #{#{}} p))))","user":"597dcb0ce4b0dbe32238d0a2"},{"problem":103,"code":"(fn a [x y]\n  (letfn [(f [s]\n             (if (empty? s)\n               #{s}\n               (loop [new-set (set (for [x s\n                                         y s\n                                         :when (not= x y)]\n                                     #{x y}))\n               result-set (clojure.set/union #{s #{}} new-set (set (for [x s] #{x})))]\n                 (let [a (set (for [x new-set\n                                    y s\n                                    :when (not (contains? x y))]\n                                (conj x y)))]\n                   (if (= a new-set)\n                     result-set\n                     (recur a (into result-set a)))))))]\n    (set (filter #(= x (count %)) (f y)))))","user":"53973e7be4b0b51d73faaee6"},{"problem":103,"code":"#(letfn [(f [xs]\n                           (let [steps (map - (rest xs) (drop-last xs))]\n                             (loop [steps (map - (rest xs) (drop-last xs))\n                                    i (count steps)]\n                               (if (not= 1 (last steps))\n                                 i\n                                 (recur (drop-last steps) (dec i))))))\n          (g [xs k]\n                      (if (and (= 0 (f xs))\n                               (= (last xs) (dec k)))\n                        nil\n                        (let [ys (concat (drop-last xs) (list (inc (last xs))))]\n                          (if (= (last ys) k)\n                            (let [i (f xs)\n                                  zs1 (take (- i 1) ys)\n                                  z (inc (nth ys (dec i)))\n                                  zs2 (range (inc z)\n                                             (+ (- (count xs) i)\n                                                (inc z)))]\n                              (concat (concat zs1 (list z)) zs2))\n                            ys))))\n          (comb [m n]\n                (loop [xs (range m) ys (list xs)]\n                  (if (nil? xs)\n                    (rest ys)\n                    (let [_ (g xs n)]\n                      (recur _ (conj ys _))))))]\n    (let [cnt (count %2)]\n    (if (> % cnt)\n      #{}\n      (let [_ (comb % cnt)\n            ys (vec %2)]\n        (set (for [index _]\n          (set (map ys index))))))))","user":"54d753ebe4b0a52adc2e2029"},{"problem":103,"code":"(fn [k xs]\n  (loop[[f & r] (seq xs) h #{#{}}]\n    (if f\n      (recur r (concat h (map #(cons f %) h)))\n      (set (map set (filter #(= k (count %)) h))))))","user":"5c2836ebe4b07e362c2305d4"},{"problem":103,"code":"(fn [c u]\n  (set \n   (filter #(= (count %) c)\n        (reduce (fn [a e]\n                  (reduce #(conj % (conj %2 e)) a a))\n                #{#{}} u)))\n )","user":"5412646de4b01498b1a719d4"},{"code":"(fn k-comb [n l]\r\n    (letfn [(power-set\r\n              ([theset] (set (power-set theset #{})))\r\n              ([s result]\r\n                 (if (empty? s)\r\n                   (list result)\r\n                   (concat  (power-set (rest s) (conj result (first s)))\r\n                            (power-set (rest s) result)))))]\r\n      (set (filter #(= (count %) n) (power-set l)))))","problem":103,"user":"4f039524535dcb61093f6b2c"},{"code":"(fn [n s]\n  (set\n    (filter #(= n (count %))\n      (reduce\n        (fn [r x] (into r (map #(conj % x) r)))\n        #{#{}}\n        s))))","problem":103,"user":"51ad244fe4b09397d510977f"},{"problem":103,"code":"(fn k-kombinations [k coll]\n  (letfn [(first-rest-seq\n            [k coll]\n            (lazy-seq (when (<= k (count coll))\n                        (let [f (first coll)\n                              r (rest coll)]\n                          (cons [f r]\n                                (first-rest-seq k r))))))\n          (combine\n            [e coll]\n            (set (map #(clojure.set/union #{e} %)\n                      coll)))]\n    (if (= k 1)\n      (set (map hash-set coll))\n      (apply clojure.set/union (map (fn [[f r]]\n                                      (combine f (k-kombinations (dec k) r)))\n                                    (first-rest-seq k coll))))))","user":"55586905e4b0deb715856e2b"},{"problem":103,"code":"(fn k-combinations [k xs]\n   (letfn [(choices [n k]\n             (nth (iterate\n                   (fn [prev]\n                     (set (mapcat (fn [existing]\n                                    (map (fn [choice] (conj existing choice))\n                                         (take (- (dec n) (apply max existing))\n                                               (rest (iterate inc\n                                                              (apply max existing))))))\n                                  prev)))\n                   (set (map (comp set vector)\n                             (range n))))\n                  (dec k)))]\n     (set\n      (map set\n           (map (fn [choice] (map (partial nth (vec xs))\n                                 choice))\n                (choices (count xs) k))))))","user":"4fcf1755e4b03432b189f40c"},{"problem":103,"code":"(letfn [(k-combinations\n         [k s]\n         (cond\n          (= k 0) '(())\n          (empty? s) '()\n          :else (concat (map\n                         #(cons (first s) %)\n                         (k-combinations (dec k) (rest s)))\n                        (k-combinations k (rest s)))))]\n  (fn [k s]\n    (set (map set (k-combinations k s)))))","user":"540a4f20e4b0addc1aec66ef"},{"problem":103,"code":"(fn k-comb [n sq]\n  (cond\n    (zero? n) #{}\n    (= 1 n) (set (map (fn [x] #{x}) sq))\n    true (let [subset (fn [x] (remove #(= x %) sq))\n               n-1 (dec n)\n               convolve (fn [x ss] (map #(apply conj #{x} %) ss))]\n           (set (flatten (map #(convolve % (k-comb n-1 (subset %))) sq))))))","user":"51b920bfe4b0e871ca4958f9"},{"code":"(fn [n xs]\n  (let [new-combinations (fn [soFar addition] (map #(conj % addition) soFar))\n        combinations (fn combinations [soFar remaining]\n                      (cond\n                      (empty? remaining) soFar\n                      :else (concat \n                             (combinations (new-combinations soFar (first remaining)) (rest remaining)) \n                             (combinations soFar (rest remaining)))))]\n    (set (filter #(= n (count %) ) (combinations #{#{}} xs)))))","problem":103,"user":"5142e808e4b0c172af7558c9"},{"code":"(fn k-combinations [k s]\n  (if (or (zero? k) (empty? s))\n    #{}\n    (let [prefix   (first s)\n          suffixes (k-combinations (dec k) (rest s))\n          others   (k-combinations      k  (rest s))]\n      (if (= k 1) (set (concat (list #{prefix})                others))\n                  (set (concat (map #(conj % prefix) suffixes) others))))))","problem":103,"user":"4e7263a1535d5021c1a8965f"},{"code":"(fn ff [n v]\n  (into #{}\n        (filter #(= n (count %)) (seq ((fn f[v]\n                                         (into #{} (if (empty? v)\n                                                     [#{}]\n                                                     (concat []\n                                                             (map #(conj % (first v)) (f (next v)))\n                                                             (f (next v)))))) v)))))","problem":103,"user":"52196842e4b0890f2f822bfa"},{"code":"(fn [n s] \r\n  (letfn [(f [x] (set (map #(disj x %) x)))]\r\n\t  (loop [t #{s} m (count s)]\r\n\t\t  (cond\r\n        (> n m) #{}\r\n        (= n m) t\r\n\t\t\t  1 (recur (apply clojure.set/union (map f t)) (dec m))))))","problem":103,"user":"4db85282535d1e037afb218a"},{"problem":103,"code":"(fn n-tuples\n  [n s]\n  (set (if (= 1 n)\n         (map #(set [%]) s)\n         (let [zm (map vector (range 1 (inc (count s))) s)]\n           (for [x zm\n                 y (n-tuples (dec n) (drop (first x) s))]\n             (into #{(second x)} y))))))","user":"57d0cd58e4b0bd073c20235e"},{"problem":103,"code":"(fn [x l] (letfn [(combinations  [k s]\n (cond\n  (> k (count s)) nil ;not enough items in sequence to form a valid combination\n  (= k (count s)) [s] ;only one combination available: all items \n  (= 1 k) (map vector s) ;every item (on its own) is a valid combination\n  :else (reduce concat (map-indexed \n   (fn [i x] (map #(cons x %) (combinations (dec k) (drop (inc i) s))))s))))]\n  (set(map set (combinations x l)))\n  ))","user":"5951190be4b066ee0a44aea4"},{"problem":103,"code":"(fn k-combinations [k s]\n  (set\n   (if (= k 1)\n     (map hash-set s)\n     (let [combs (k-combinations (dec k) s)]\n       (for [ele s, comb combs :when (not (comb ele))]\n         (conj comb ele))))))","user":"5879d577e4b01531a375ead8"},{"problem":103,"code":"(fn [n s]\n    (->>\n      (reduce #(mapcat (fn [subset] [subset (conj subset %2)]) %1) [#{}] s)\n      (filter #(= (count %) n))\n      set))","user":"5bab5440e4b0a20761a23475"},{"problem":103,"code":"(fn kcombos [n s]\n  (into #{}(filter #(= n (count %)) ((fn powerset\n  [coll] \n  (let [x (first coll) xs (rest coll)]\n    (if (empty? coll)\n      #{#{}}\n      (let [pset (powerset xs)]\n        (clojure.set/union pset (map #(into #{x} %) pset)))))) s))))","user":"55ede35ce4b0121d4835fde1"},{"code":"(fn kcomb [k s]\n  (set (filter #(= k (count %))\n    (loop [k'  k\n           acc (map (comp set list) s)]\n      (if (= 1 k')\n        acc\n        (recur (dec k')\n               (for [x acc y s] (conj x y))))))))","problem":103,"user":"531c0619e4b08068f379ed98"},{"problem":103,"code":"(fn combinations [k ss]\n  (if (= k 1)\n    (set (map hash-set ss))\n    (let [prev (combinations (dec k) ss)]\n      (->> (for [x prev y ss] (conj x y))\n           (filter #(= (count %) k))\n           (set)))))","user":"5b13ba71e4b0cc2b61a3be53"},{"problem":103,"code":"(fn [n s] (set\n  (filter #(= (count %) n)\n    (reduce #(clojure.set/union % (set (for [x %] (conj x %2))) #{#{%2}}) #{} s))))","user":"53500869e4b084c2834f4ad3"},{"problem":103,"code":"(letfn [(power-set [x]\n          (set\n           (map\n            (fn [item]\n              (->> item\n                   (Integer/toBinaryString)\n                   (reverse)\n                   (interleave x)\n                   (partition 2)\n                   (filter #(-> % second (= \\1)))\n                   (map first)\n                   (set)))\n            (range 0 (->> x count (Math/pow 2) int)))))]\n  (fn [n x]\n    (->> x power-set (filter #(-> % count (= n))) set)))","user":"5b96800ae4b0c0b3ffbd4a7b"},{"code":"(fn a [n k]\r\n    (if (= 0 n) #{#{}}\r\n      (reduce into #{}\r\n              (map (fn [x] (map #(conj % x)\r\n                                     (a (dec n) \r\n                                        (disj k x))))\r\n                   k))))","problem":103,"user":"4dc537fd535d8a4b2fd74282"},{"problem":103,"code":"(letfn [(S [k coll]\n\t\t\t(if (= 0 k) #{#{}}\n\t\t\t  (case (compare k (count coll))\n\t\t\t\t0 #{(set coll)}\n\t\t\t\t1 #{}\n\t\t\t\t(into #{} (concat (x (first coll) (S (dec k) (rest coll)))\n\t\t\t\t\t\t\t\t  (S k (rest coll)))))))\n\t\t(x [e coll] (map #(conj % e) coll))] S)","user":"580c8fcee4b0849f6811b721"},{"problem":103,"code":"(fn gen [n coll] (let [feed (fn [coll init] (into (hash-set) (apply concat (map (fn [x] (reduce (fn [a b] (conj a (conj x (nth coll b)))) #{}\n                                                                                                 (range 0 (count coll)))) init))))\n                        colla (into [] coll)]\n                    (set (filter #(= (count %1) n) (if (empty? coll) #{#{}} (conj (reduce (fn [a b] (feed colla a))\n                                                                                      (map hash-set colla) (range (count colla))) #{}))))))","user":"567f988be4b0feffd0d18ebe"},{"code":";cf problem 85\n(fn [k s]\n  (set (filter #(= (count %) k)\n      (conj (reduce #(set (for [x % y %2]\n                               (conj (if (set? x) x #{x}) y)))\n                    (repeat (count s) s)) #{}))))","problem":103,"user":"500900dee4b0144d4f561e42"},{"code":"(fn [n s]\n  (set\n    (filter #(= n (count %)) \n      (reduce\n        (fn [acc x]\n          (clojure.set/union\n            acc\n            (set (map #(clojure.set/union #{x} %) acc))))\n        #{#{}} s))))","problem":103,"user":"52a88c4de4b0c58976d9ac30"},{"code":"(fn c [k s]\n    (if (= 0 k) [#{}]\n      (case (compare k (count s))\n        0 #{(set s)}\n        1 #{}\n        (into #{} (concat (map #(conj % (first s)) (c (dec k) (rest s)))\n                          (c k (rest s))))\n        )))","problem":103,"user":"4ff67852e4b0678c553fc37e"},{"code":"(fn mycomb [k coll]\n    (letfn [(kcomb [c]\n              (let [coll (vec c)]\n              (if (> k (count coll)) #{}\n              (if (= k (count c)) (set c)\n              (flatten (for [i (range (count coll))]\n                  (kcomb (concat (subvec coll 0 i) (subvec coll (inc i))))))))))]\n    (if (= (count coll) k) (set [coll])\n    (set (kcomb coll)))))","problem":103,"user":"4eb0a757535d7eef3080733d"},{"problem":103,"code":"(fn [n s]\n  (if (< (count s) n)\n    #{}\n    (loop [ret #{#{}}, len 0]\n      (if (= len n)\n        ret\n        (recur (->> (for [r ret, e s] (conj r e))\n                    (filter #(= (inc len) (count %)))\n                    set)\n               (inc len))))))","user":"56dc3bdfe4b0ea9b8538f819"},{"code":"(fn k-combinations\n  [k S]\n  (cond\n   (< (count S) k) #{}\n   (= 1 k) (set (map hash-set S))\n   :else (set (mapcat\n               (fn [x] (map #(conj % x) (k-combinations (dec k) (disj S x))))\n               S))))","problem":103,"user":"4e68c434535d8ccf87e9fe89"},{"problem":103,"code":"(fn comb [size s] (if (empty? s) (if (zero? size) #{#{}} #{})\n                    (clojure.set/union\n                     (comb size (rest s))\n                     (set (map #(conj % (first s)) (comb (dec size) (rest s)))))))","user":"584dadebe4b0b7285a6f4e44"},{"code":"(fn comb [k S]\n  (cond\n    (empty? S) #{}\n    (= 1 k) (reduce #(conj %1 #{%2}) #{} S)\n    :e (clojure.set/union (comb k (rest S))\n        (set\n        (map #(conj % (first S)) \n              (comb (dec k) (rest S)))))))","problem":103,"user":"4fdd27f3e4b05e33b9224f78"},{"problem":103,"code":"(fn [k-size a-set]\n  (set\n    (filter #(= k-size (count %))\n            (reduce (fn [a e] (concat (map #(conj % e) a) a)) [#{}] a-set))))","user":"5c165d3ee4b01240ff5671d1"},{"problem":103,"code":"(fn\n  [n e]\n  (set (filter #(= (count %) n) ((fn\n  [s]\n  (loop [b (dec (int (Math/pow 2 (count s)))) f #{} p #{} i 0]\n    (if (>= b 0)\n      (if (< i (count s))\n        (if (bit-test b i)\n          (recur b f (conj p (nth (vec s) i)) (inc i))\n          (recur b f p (inc i))\n          )\n        (recur (dec b) (conj f p) #{} 0))\n      f))\n  ) e)))\n  )","user":"5772ddb0e4b0979f896515d4"},{"problem":103,"code":"(fn comb [n v]\n  (let [xs (vec v)]\n    (if (= 1 n)\n      (into #{} (map #(hash-set %) xs))\n      (set\n       (mapcat\n        (fn[i]\n          (into #{} (map #(conj % (nth xs i)) (comb (dec n) (drop (inc i) xs)))))\n        (range (inc (- (count xs) n))))))))","user":"5ed6030de4b016b56eae05db"},{"code":"(fn f [n se]\n  (prn n se)\n  (if (< (count se) n)\n    #{}\n    (if ( = (count se) n)\n      #{se}\n      (set (mapcat (partial f n) (map #(disj se %) se)))\n    )\n  )\n)","problem":103,"user":"51ba8f82e4b0fe3ecfb46434"},{"code":"(fn f [c s]\n  (if (= 0 c)\n    [#{}]\n    (set\n      (mapcat\n        (fn [x]\n          (map #(conj % x)\n               (f (dec c) (disj s x))))\n        s))))","problem":103,"user":"50548ce8e4b0b1b9d1860ead"},{"code":"(fn ks [k s]\n   (into #{}\n         (cond (> k (count s)) #{}\n               (= k 1) (map hash-set s)\n               :else (concat (map #(into #{} (cons (first s) %)) (ks (dec k) (rest s)))\n                             (ks k (rest s))))))","problem":103,"user":"4fa05b99e4b0dcca54ed6d47"},{"code":"(fn [n start]\n    ((fn k [s]\n       (cond\n         (empty? s) #{}\n         (= (count s) n) #{(set s)}\n         :else (let [i (first s)\n                     p (k (rest s))]\n                 (into p (for [col p :let [c (set col)] x col] (conj (disj c x) i))))\n         ))\n      start))","problem":103,"user":"4fe900a6e4b0547ebccb243a"},{"problem":103,"code":"(fn [n s]\n  (letfn [(i [c w]\n     (if (contains? c w)\n       c\n       (i (reduce (fn [v x] (into v (map #(conj x %) s))) c c) w)\n       ))]\n    (set (filter #(= n (count %)) (i #{#{}} s)))))","user":"5504dd64e4b086ebe8a79c83"},{"problem":103,"code":"(fn k-combs\n  [n coll]\n  (let [diff (- (count coll) n)\n        times (max diff (- diff))]\n    (letfn [(dropper [s]\n              (map #(disj s %) s))\n            (drop-looper [t s]\n              (if (> t 0) \n                (recur (dec t) (set (mapcat dropper s)))\n                s))]\n      (drop-looper times #{coll}))))","user":"5401aefbe4b0df28a13c62c7"},{"code":"(fn k-combos [k s]\n  (set\n   (when (and (not (zero? k)) (seq s))\n     (let [prefix (first s)\n           suffixes (k-combos (dec k) (rest s))\n           others (k-combos k (rest s))]\n       (if (= k 1)\n         (concat (list #{prefix}) others)\n         (concat (map #(conj % prefix) suffixes) others))))))","problem":103,"user":"4e52d815535d302ef430da77"},{"problem":103,"code":"(fn k-combinations [k s]\n  (into\n    #{}\n    (if (== k 1)\n      (map (fn [x] #{x}) s)\n      (mapcat\n        #(map\n           (fn [x] (into #{%} x))\n           (k-combinations (dec k) (disj s %)))\n        s))))","user":"5f300f28e4b033932238a682"},{"code":"(fn f [k s]\n  (set\n   (when-let [[x] (seq s)]\n     (if (= 1 k)\n       (map hash-set s)\n       (concat (map #(conj % x) (f (dec k) (disj s x)))\n               (f k (disj s x)))))))","problem":103,"user":"4dbb0b6c535d1e037afb21b0"},{"code":"(fn[k in-set]\n   (if (> k (count in-set)) #{}\n   (loop [k-set #{in-set}]\n     (if (= k (count (first k-set))) k-set\n         (let [next-k-set (set (reduce #(clojure.set/union %1 %2)\n                                       (for [one-set k-set]\n                                         (for [elem one-set] (disj one-set elem)))))]\n           (recur next-k-set))))))","problem":103,"user":"4fb86dc9e4b081705acca2d8"},{"code":"(fn k-comb [size original-set]\n  (letfn [(step [left-depth path-set remain-set]\n                (if (zero? left-depth)\n                  (-> path-set set list set)\n                  (if (empty? remain-set)\n                    #{}\n                    (set \n                     (apply concat (map #(step (dec left-depth) (conj path-set %) (disj remain-set %)) remain-set) )))))]\n    (step size #{} original-set)))","problem":103,"user":"52a55adee4b0c58976d9abe7"},{"problem":103,"code":"(fn t [k s]\n  (cond\n    (zero? k) #{#{}}\n    (empty? s) #{}\n    :else (set (clojure.set/union\n                 (map #(conj % (first s)) (t (dec k) (rest s)))\n                 (t k (rest s))))))","user":"572de985e4b0cd1946bd0f7c"},{"problem":103,"code":"(fn [n all]\n  (let [x (count all)]\n    (if (> n x) #{}\n      (if (= n x) #{all}\n        (loop [built (hash-set (hash-set) all)]\n          (let [new (into built (for [x built s all] (disj x s))) filtered (apply hash-set (filter #(= (count %) n) new))]\n            (if (empty? filtered) (recur new)\n              filtered)))))))","user":"56bb9ccce4b0f26550335959"},{"problem":103,"code":"(fn k-combinations [k ns]\n  (set (filter (comp (partial = k) count)\n               (loop [rs #{#{}} \n                      [h & t] (seq ns)]\n                 (if (nil? h)\n                   rs\n                   (recur (into rs (map #(conj % h) rs))\n                          t))))))","user":"57e0f30ae4b0bfb2137f5a66"},{"problem":103,"code":"(fn k-combinations [k s]\n  (cond\n    (zero? k) #{#{}}\n    (empty? s) #{}\n    :else (set (mapcat (fn [elem]\n                 (map #(conj % elem) (k-combinations (dec k) (disj s elem))))\n               s))))","user":"601aaa93e4b0bf4ca6b10926"},{"problem":103,"code":"(fn k-comb [k s]\n    (letfn [(power-set [s]\n              (loop [s s\n                     ps #{#{}}]\n                (if (empty? s) ps\n                    (recur (rest s) (into ps (map #(conj % (first s)) ps))))))]\n      (set (filter #(= k (count %)) (power-set s)))))","user":"579693d4e4b039eba2ecb0e7"},{"problem":103,"code":"(fn\n  [n s]\n  (letfn [(powerset [s]\n            (apply clojure.set/union\n                   #{s}\n                   (map #(powerset (disj s %)) s)))]\n    (set (filter #(= n (count %)) (powerset s)))))","user":"52951156e4b02ebb4ef7501b"},{"problem":103,"code":"(fn [n coll]\n    (letfn [(subsets [coll]\n              (if (empty? coll)\n                [[]]\n                (let [f (first coll)\n                      r (rest coll)]\n                  (concat (subsets r)\n                          (map #(conj % f) (subsets r))))))]\n      (->> (subsets coll)\n        (filter #(= (count %) n))\n        (map set)\n        set)))","user":"560e9a2de4b05f002753df52"},{"problem":103,"code":"(fn t103 [k s]\n  (letfn [(combs [k s]\n            (cond  \n              (zero? k) [[]]\n              (> k (count s)) []\n              (= k (count s)) [s]\n              :else (apply conj    \n                      (map #(conj % (first s)) (t103 (- k 1) (rest s)))\n                      (t103 k (rest s)))))]\n    (set (for [x (combs k s)] (set x)))))","user":"5046f909e4b03b02161376b5"},{"problem":103,"code":"(fn ex103\n  [n s]\n  (letfn [(powerset [s]\n            (if (= 2 (count s))\n              (set (conj (map (comp set vector) s) s #{}))\n              (let [subsets (for [i s]\n                              (clojure.set/difference s #{i}))]\n                (conj (set (apply concat (map powerset subsets))) s))))]\n    (set (filter #(= (count %) n) (powerset s)))))","user":"532bce35e4b09d4e7a9b5536"},{"problem":103,"code":"(fn k [n vs]\n    (cond (or (= n 0) (> n (count vs))) #{}\n          (= n 1) (set (for [v vs] #{v}))\n          :else (set (for [v vs ks (k (- n 1) (disj vs v))] (conj ks v)))))","user":"54c641f8e4b045293a27f628"},{"problem":103,"code":"(fn combinations [n s]\n  (let [powerset (fn f [x]\n     (if (empty? x)\n       #{#{}}\n       (into (f (set (rest x))) (set (for [y (vector (first x))\n                                                  z (f (set (rest x)))]\n                                              (conj z y))))))]\n    (set (filter #(== (count %) n) (powerset s)))))","user":"532727bae4b09d4e7a9b54fa"},{"code":"(fn x[n l] (if (= n 1) (into #{} (map #(set [%]) l)) (into #{} (for [li l lii (x (- n 1) (disj l li))] (conj lii li)))))","problem":103,"user":"4e7f4147535db966e863cc3d"},{"code":"(fn selections [n c]\n        (cond\n         (= n 0) #{#{}}\n         (> n (count c)) #{}\n         :else (set (for [x (range 1 (inc (count c)))\n                     d (selections (dec n) (drop x c))]\n                 (into #{} (cons (nth (seq c) (dec x)) d))))))","problem":103,"user":"4f031eac535dcb61093f6a67"},{"code":"(fn f [n s] (cond (zero? n) #{#{}}\n                   (> n (count s)) #{}\n                   (= n (count s)) #{s}\n                   :else (into (f n (set (rest s)))\n                               (map #(conj % (first s)) (f (dec n) (rest s))))))","problem":103,"user":"50563ae2e4b0ce54f56f0405"},{"problem":103,"code":"; See original solution on Power Set (problem 85)\n;; As such, filtering a powerset on number of elements is also possible.\n(fn [n x]\n  (if-not (<= 1 n (count x))\n    #{}\n    (let [x (vec x)\n          partitions (letfn [(update-n [numbers maxn] ; generates e.g. [1 2 3 4] [1 2 3 5] .. [1 2 3 n] [1 2 4 5] .. [n-3 n-2 n-1 n]\n                               (let [l (last numbers) ; give one to get next one. This could be written better in some iterative form\n                                     p (butlast numbers)]\n                                 (if (<= maxn l)\n                                   (when (not= numbers\n                                               (reverse (range maxn\n                                                               (- maxn (count numbers))\n                                                               -1)))\n                                     (let [n (update-n p (dec maxn))]\n                                       (concat n [(inc (last n))])))\n                                   (concat p [(inc l)]))))\n                             (constructor [numbers] ; constructs the partition, starting from getvector numbers\n                               (cons (map (partial get x) numbers)\n                                     (when-let [u (update-n numbers (dec (count x)))]\n                                       (lazy-seq (constructor u)))))]\n                       (constructor (vec (range n))))] ; First getvector is the range.\n      (set (map set partitions)))))","user":"54d341f7e4b0e8a36923e603"},{"code":"(fn [n s]\n  (let [n (- (count s) n)\n        f (fn [x] (map #(disj x %) x))]\n    (if (neg? n) #{}\n      (set (nth (iterate #(distinct (mapcat f %)) [s]) n)))))","problem":103,"user":"4fdb02aae4b05e33b9224f56"},{"problem":103,"code":"(fn gen-k-combs \n  ([k s] (gen-k-combs k s []))           \n  ([k s prev-combs] \n    (letfn [(combine-rem-w-seq \n              [s rem]\n              (map #(set (conj s %)) rem)\n              )]\n      (if (= k 1)\n        (set (combine-rem-w-seq prev-combs s))\n        (loop [tail s k k all-combs []]\n          (let [head (first tail)]\n            (if (nil? head)\n              (set all-combs)\n              (recur (rest tail) k (into all-combs (gen-k-combs (dec k) (rest tail) (conj prev-combs head))))\n              )))))))","user":"5ff676a9e4b06df49cee1497"},{"code":"(fn comb [k s]\n  (cond (zero? k) #{#{}}\n        (empty? s) #{}\n        :else (set (concat (map #(conj % (first s)) (comb (dec k) (rest s)))\n                      (comb k (rest s))))))","problem":103,"user":"4facd2fae4b081705acca22f"},{"problem":103,"code":"(fn k-comb [k xs]\n  (let [power-set\n        (partial reduce \n          (fn [a x] (into a (map #(conj % x) a))) \n          (hash-set #{}))]\n    (set (filter (comp #{k} count) (power-set xs)))))","user":"5af8221ce4b0cc2b61a3bccd"},{"code":"(fn [n s]\n  (letfn [(subsets [lst]\n  (if (empty? lst)\n    (list '())\n    (let [others (subsets (rest lst))]\n      (concat others (map #(cons (first lst) %) others)))))]\n    (let [setify (fn [x] (set (map set x)))]\n     (setify (filter #(= (count %) n) (subsets s))))))","problem":103,"user":"515f8a0de4b0e2be8aa20bce"},{"problem":103,"code":"(fn __ [k s]\n  (let [\n        binary-nums (fn [length]\n                      \"Generate all binary numbers of a given bit length\"\n                      ; start with [0] and [1]\n                      (loop [acc [[0] [1]] \n                             remaining length]\n                        (if (= remaining 1)\n                          acc\n                          ; double our vector, appending 0 to one half\n                          ; and 1 to the other\n                          (recur\n                           (concat\n                             (map #(conj % 0) acc) \n                             (map #(conj % 1) acc))\n                           (dec remaining)))))\n        \n        get-binary-nums (fn [s]\n                          (binary-nums (count s)))\n        apply-binary-num (fn [b s]\n                            (loop [b b\n                                   s s\n                                   acc #{}]\n                              (if (empty? b)\n                                acc\n                                (recur\n                                 (rest b)\n                                 (rest s)\n                                 (if (= 1 (first b))\n                                   (conj acc (first s))\n                                   acc)))))]\n  (if (= #{} s)\n    #{#{}}\n    (into #{}\n    (filter #(= (count %) k)\n      (loop [acc []\n             rem (get-binary-nums s)]\n        (if (empty? rem)\n          acc\n          (recur\n           (conj acc (apply-binary-num (first rem) s))\n           (rest rem)))))))))","user":"53ac4719e4b047364c04445c"},{"problem":103,"code":"(fn one-oh-three\n  [k S]\n  (if (= 1 k)\n    (set (map hash-set S))\n    (set (mapcat (fn [n]\n                   (let [[f & more] (drop n S)]\n                     (for [x (one-oh-three (dec k) more)]\n                       (into #{f} x))))\n                 (range (dec (count S)))))))","user":"5338387de4b0e30313ee6c91"},{"code":"(fn [n col]\n  (set (filter #(= n (count %))\n \t(loop [sets (set (map #(set [%]) col))\n    \t   n n]\n      (if (= 1 n)                  \t\n        sets              \n        (recur (set (for [s sets x col] (conj s x))) (dec n)))))))","problem":103,"user":"500aa15ee4b03d00572d2d76"},{"problem":103,"code":"(let [binc (fn binc [i]\n             (let [[i' carry]\n                   (reduce\n                    (fn [[i' carry] d]\n                      (if (= 0 carry)\n                        [(conj i' d) 0]\n                        (if (= 1 d)\n                          [(conj i' 0) 1]\n                          [(conj i' 1) 0])))\n                    [[] 1] i)]\n               (if (= 1 carry)\n                 (conj i' 1)\n                 i')))\n      count1s (fn [i] (count (filter (partial = 1) i)))\n      permi (fn f [i n]\n              (if (= n (count1s i))\n                (cons i (lazy-cat (f (binc i) n)))\n                (lazy-cat (f (binc i) n))))\n      perm (partial permi [0])\n      permute (fn [c i]\n                (set (mapv first (filter (comp (partial = 1) second) (mapv vector c i)))))]\n  ;; not too efficient but oh well, simple and easy\n  (fn [k s]\n    (let [s (vec s)\n          p (perm k)\n          n (count s)\n          p' (take (/ (reduce * (range (inc (- n k)) (inc n)))\n                      (reduce * (range 1 (inc k))))\n                   p)]\n      (set (map (partial permute s) p')))))","user":"547d8e93e4b0c51c1f4d72f4"},{"problem":103,"code":"(fn kcombs\n  ([k coll] (kcombs k coll #{}  #{} ))\n  ([k coll currResult allResults]\n   (cond\n     (= k 0) (conj allResults currResult)\n     (or (empty? coll) (> k (count coll))) allResults\n     :else\n     (clojure.set/union\n      (kcombs (dec k) (rest coll) (conj currResult (first coll)) allResults)\n      (kcombs k (rest coll) currResult allResults)))))","user":"54f64e99e4b0f2f3c5226ea4"},{"problem":103,"code":"(fn [k s]\n  (loop [ks #{} is [#{}] es s]\n    (if (empty? es)\n      ks\n      (let [e (first es)\n            ies (for [x is] (conj x e))\n            ks' (filter #(= (count %) k) ies)\n            is' (filter #(< (count %) k) ies)]\n        (recur (into ks ks') (into is is') (rest es))))))","user":"4eb70649535d7eef30807373"},{"problem":103,"code":"(fn bn [k s]\n  (set\n    (cond (or (empty? s) (> k (count s)) (zero? k)) #{}\n            (= k 1) (map hash-set s)\n            :else (mapcat #(map (partial (comp set cons) %) (bn (dec k) (disj s %))) s))))","user":"5e3a25d4e4b01d43a70e8dde"},{"problem":103,"code":";;this recursive version if very inefficient \n;(letfn [(k-comb \n ;           [k els]\n  ;          (cond \n   ;           (or (<= k 0) (> k (count els)))  #{}\n    ;          (= k 1) (set (map #(set [%]) els))\n     ;         :else (reduce clojure.set/union \n      ;                       (for [l els :let [z  (k-comb (dec k) (disj els l))]] \n       ;                    (set (map #(conj %1 l) z))))\n        ;      ))\n         ; ]\n   ; k-comb\n    ;)\n    \n    ;;; efficient version using power-set\n    (letfn [(power-set2 [s]\n                      (let [s-ind (map-indexed vector s) \n                            decode (fn [n] \n                                     (into #{} (map second \n                                                    (filter #(not= 0 (bit-and n (bit-shift-left 1 (first %)))) s-ind))))]\n                        (into #{} (map decode (range (bit-shift-left 1 (count s)))))))\n          (k-comb\n            [k els]\n            (set (filter #(= k (count %)) (power-set2 els)))\n            )\n          ]\n    k-comb)","user":"50eddbc4e4b06330c1f87c4b"},{"code":"(fn k-comb [n s]\n  (cond\n    (zero? n) #{#{}}\n    (> n (count s)) #{}\n    :else (let [x (first s)\n                xs (-> s rest set)]\n            (into\n              (k-comb n xs)\n              (map #(conj % x) (k-comb (dec n) xs))))))","problem":103,"user":"514c2d05e4b02b8cbb2a9278"},{"code":"(fn k-combinations [k S]\n  (let [powerset (fn powerset [full-set]\n                  (if (empty? full-set)\n                    #{#{}}\n                    (let [rest-pset (powerset (rest full-set))]\n                      (into rest-pset (map #(conj % (first full-set)) rest-pset)))))]\n    (apply hash-set (filter #(= k (count %)) (powerset S)))))","problem":103,"user":"510cd1dde4b078ea71921124"},{"code":"(fn f [k s]\r\n  (if (> k (count s))\r\n\t\t#{}\r\n\t\t(if (or (zero? k) (empty? s))\r\n\t\t\t#{#{}}\r\n\t\t\t(set (for [x s r (f (dec k) (disj s x))] (conj r x))))))","problem":103,"user":"4f8c5f4fe4b02e764a0a5198"},{"problem":103,"code":"(fn k-combinations [n data]\n  (letfn [(toggle-every [length n]\n            (take (Math/pow 2 length)\n                  (cycle (concat (repeat n 0) (repeat n 1)))))\n\n          (perms [length]\n            (->> (range length)\n                 (mapv #(toggle-every length (Math/pow 2 %)))\n                 (apply mapv vector)))\n\n          (zip\n            ([xs ys] (zip xs ys #{}))\n            ([xs ys acc]\n             (if (or (empty? xs) (empty? ys))\n               acc\n               (recur (rest xs)\n                      (rest ys)\n                      (if (= 1 (first xs))\n                        (conj acc (first ys))\n                        acc)))))\n\n          (powerset [coll]\n            (reduce #(conj %1 (zip %2 coll)) #{} (perms (count coll))))]\n    (into #{} (filter #(= n (count %)) (powerset data)))))","user":"55fbc657e4b0f488688e0666"},{"problem":103,"code":"(fn k-comb [n s]\n  (if (zero? n)\n    #{#{}}\n    (set (for [x s\n         \tpart-s (k-comb (dec n) (disj s x))]\n           (conj part-s x)))))","user":"5dd60c58e4b0948ae9d9ad7c"},{"problem":103,"code":"(fn combinations [num-elementos conjunto]\n  (cond\n    (zero? num-elementos) #{#{}}\n    (empty? conjunto) #{}\n    :else (set (clojure.set/union (map #(conj % (first conjunto)) (combinations (dec num-elementos) (rest conjunto)))\n                                  (combinations num-elementos (rest conjunto))))))","user":"5d0153f9e4b0cc9c915881aa"},{"code":"(fn f [n st]\n  (if (> n (count st))\n      #{}\n      (let [fak (fn [n] (reduce * (range 1 (inc n))))\n            jum (/ (fak (count st))\n                   (* (fak (- (count st) n))\n                      (fak n)))]\n          (loop [res #{}]\n              (if (= (count res) jum)\n                  res\n                  (recur (let [elm (set (take n (shuffle (vec st))))]\n                              (if (= n (count elm))\n                                  (conj (set res) elm)\n                                  (set res)))))))))","problem":103,"user":"528a3e14e4b0239c8a67ae72"},{"code":"(fn gl [x y] (set(filter #(= x (count %))\n (set(map set(partition x (mapcat shuffle (repeat 100 y))))))))","problem":103,"user":"5307e4ece4b02e82168697a9"},{"code":"(fn [n s]\n  (letfn [(ss [l]\n            (reduce\n             #(apply concat (map (fn [v]\n                                   [v (set (conj v %2))])\n                                 %))\n             [#{}] l))]\n    (set (filter #(= n (count %))\n                 (ss s)))))","problem":103,"user":"53460d02e4b084c2834f4a39"},{"problem":103,"code":"(fn [n vset]\n  (let [els (seq vset)\n        pws (->> (range 1 (Math/pow 2 (count els)))\n                 (map #(Integer/toBinaryString %))\n                 (map (fn [bs] (map vector (reverse bs) (range))))\n                 (map (fn [bp] (filter #(= \\1 (first %)) bp)))\n                 (map (fn [bp] (reduce (fn [s p] (conj s (nth els (second p)))) #{} bp))))]\n    (into #{} (filter #(= n (count %)) pws))))","user":"541d3c0fe4b01498b1a71a7e"},{"problem":103,"code":"(fn [n c]\n      (set (filter #(= (count %) n)\n              (reduce #(clojure.set/union %1 (map (fn [os] (conj os %2)) %1)) #{#{}} c))))","user":"5d764e52e4b02e6b30c93524"},{"code":"(fn kc [k s]\n  (if (empty? s) (if (= k 0) #{#{}} #{})\n      (clojure.set/union (into #{} (map #(conj % (first s)) (kc (dec k) (rest s))))\n                         (kc k (rest s)))))","problem":103,"user":"4ede8e1d535d10e5ff6f5339"},{"problem":103,"code":";; Should take another look at this one, as this is pretty rough\n  (fn combinations [k s]\n    (cond\n      (= k 0) #{}\n      (= k 1) (set (map hash-set s))\n      (= k (count s)) (hash-set s)\n      (< k (count s)) (let [e (first s)\n                            without (combinations k (disj s e))\n                            with (set (map #(conj % e)\n                                           (combinations (dec k)\n                                                         (disj s e))))]\n                        (clojure.set/union without with))\n      :else #{}))","user":"4dfe5a93535d04ed9115e786"},{"code":"(fn kc [k xs]\n  (if (> k (count xs))\n    #{}\n    (if (zero? k)\n      #{#{}}\n      (set\n        (concat\n          (map #(set (concat #{(first xs)} %)) (set (kc (dec k) (set (rest xs)))))\n          (set (kc k (set (rest xs))))\n        )\n      )\n    )\n  )\n)","problem":103,"user":"507eddf4e4b06ce648bcdbfa"},{"problem":103,"code":"(fn k-combinations\n  [k s]\n  (letfn [(filter-out-size [c] (filter #(= k (count %)) c))\n          (square-collection [c] (map #(map (fn [s] (concat s %)) c) c))\n          (combine-results [c] (map set (reduce concat c)))]\n\n    (if (= k 1)\n      (set (map set (partition 1 s)))\n      (-> (k-combinations (dec k) s)\n       square-collection\n       combine-results\n       filter-out-size\n       set))))","user":"5125029de4b0ce9225d2ed3e"},{"code":"(fn [ k cols ]\n  (letfn [ (remove-nth [ col n ] (set (concat (take n col) (drop (inc n) col))))\n          (kc [k cols] \n     (cond \n       (< (count (first cols)) k ) {} \n       (= (count (first cols)) k ) cols\n        :else (recur k (mapcat  \n             #(for [i (range (count %)) ] (remove-nth % i)) cols))))] \n         (into #{} (kc k #{cols}))))","problem":103,"user":"4fccdc75e4b0ee37620e186d"},{"problem":103,"code":"(fn f [n s]\n  (cond (> n (count s)) #{}\n        (= n (count s)) #{s}\n        (= n 1) (set (for [i s] (hash-set i)))\n        (= n 0) #{#{}}\n        :else (set (for [i s j (f (dec n) s) :when (not (j i))] (conj j i)))))","user":"5e2549c8e4b05b4b0151615f"},{"code":"(fn [n s]\n  (letfn [(powerset [s]\n            (let [v (vec s) c (count v) r (range 0 c)]\n              (map (fn [i]\n                     (reduce (fn [acc j]\n                               (if (= 1 (mod (bit-shift-right i j) 2))\n                                 (conj acc (get v j)) acc))\n                             #{} r))\n                   (range 0 (bit-shift-left 1 c)))))]\n    (set (filter #(= n (count %)) (powerset s)))))","problem":103,"user":"4f2d5f5de4b0d6649770a05a"},{"code":"(fn k-combinations [k elements]\n  (if (zero? k)\n    #{#{}}\n    (->> elements\n         (map (fn [item]\n                (->> (k-combinations (dec k)\n                                     (disj elements item))\n                     (map #(conj % item)))))\n         (reduce into #{}))))","problem":103,"user":"530578ede4b0d8b024fd3760"},{"problem":103,"code":"(fn kcom [k coll]\n  (let [s2v (fn [sc] (for [i sc] i))\n        cc (s2v coll)\n        v2mk (fn [vc] (into {} (for [i (range (count vc))] [(nth vc i) i]))) \n        v2mv (fn [vc] (into {} (for [i (range (count vc))] [i (nth vc i)]))) \n        tranmv (fn [vc vmap] (for [i vc] (vmap i)))\n        mk (v2mk cc)\n        mv (v2mv cc)\n        combb (fn combnt [n m seqs] \n               (if (= n m)\n                 (list seqs)\n                (if (= 1 m) \n                  (map list seqs)\n                  (map #(flatten %) \n                    (reduce concat '() \n                      (for [k (range (- n (dec m)))] \n                        (map #(list (first (drop k seqs)) %) \n                          (combnt (dec n) (dec m) (drop (inc k) seqs)))))))))\n        combdatas (combb (count cc) k (tranmv cc mk))\n        combdatav (map #(tranmv % mv) combdatas)]\n      (set (map set combdatav))))","user":"5243e37ae4b076204b44fae3"},{"problem":103,"code":"(fn __\n  [n s]\n  (set (filter #(= (count %) n) (reduce (fn [a x]\n            (->> a\n                 (map #(set (concat #{x} %)))\n                 (concat a)\n                 set))\n          #{#{}} s))))","user":"55a62092e4b0acc240e31554"},{"problem":103,"code":"(fn kcombo2 [k s]\n  (if (= 1 k) (set (map (fn [x] #{x}) s))\n      (clojure.set/union (set (map (fn [x] (clojure.set/union #{(first s)} x)) (kcombo2 (dec k) (set (rest s))))) (if (<= k (count (rest s))) (kcombo2 k (set (rest s))) #{}))))","user":"51b76227e4b0d906fcd71d35"},{"code":"(fn [n s]\n  (letfn [(f [s]\n           (if (empty? s) #{s}\n             (let [r (f (rest s))]\n               (into r\n                 (map #(conj % (first s)) r)))))]\n    (set (map set (filter #(= n (count %)) (f s))))))","problem":103,"user":"4ee4f4a9535d1385b2869d85"},{"problem":103,"code":"(fn k_combinations [k coll]\n  (cond\n    (empty? coll) #{}\n    (< k 1) #{#{}}\n    (= k (count coll)) #{(set coll)}\n    (> k (count coll)) #{}\n    :else\n    (let [f (first coll)\n          r (rest coll)\n          cs_without_f (k_combinations k r)\n          sub_cs_for_f (k_combinations (dec k) r)]\n      (clojure.set/union\n        cs_without_f\n        (set (for [s sub_cs_for_f]\n          (conj s f)\n        ))\n      )\n    )\n  )\n)","user":"5943abb6e4b060784b3b792b"},{"problem":103,"code":"(fn f [k s]\n  (cond\n    (zero?  k) #{#{}}\n    (empty? s) #{}\n    :else (->> (f (dec k) (rest s))\n               (reduce #(conj %1 (clojure.set/union %2 #{(first s)})) #{}) \n               (into (f k (rest s))))))","user":"5dc88a38e4b02f9375f4e1db"},{"code":"(fn [n s]\n  (letfn [(ss [s more]\n            (when-first [x more]\n              (let [t (map #(conj % x) s)]\n                (lazy-cat t (ss (concat t s) (rest more))))))]\n    (->> (ss #{#{}} s)\n         (filter #(= n (count %)))\n         (into #{}))))","problem":103,"user":"4daec9dcedd6309eace4d15f"},{"problem":103,"code":"(fn subsets [n s]\n  (cond\n   (zero? n) #{#{}}\n   (empty? s) #{}\n   :else\n   \t\t(into #{}\n   \t\t(concat\n          (map #(conj % (first s))\n               (subsets (dec n) (rest s)))\n          (subsets n (rest s))))))","user":"54448e84e4b032a45b869393"},{"problem":103,"code":"(fn k-combs [i-num i-set]\n  (if (or (nil? i-set) (empty? i-set))\n    #{}\n    (if (= i-num (count i-set))\n      #{(into #{} i-set)}\n      (if (> i-num (count i-set))\n        #{}\n        (if (= i-num 0)\n          [#{}]\n          (into #{} (concat  (into [] (map #(conj % (first i-set)) (k-combs (dec i-num) (rest i-set))))\n                             (#(if (set? (first %)) (into [] %) [%]) (k-combs i-num  (rest i-set))))))))))","user":"5545477fe4b0a04f79299531"},{"code":"(fn\n  [k s]\n  (letfn [(subsets [s] (map #(bit-filter s %) (range (two-raised (count s)))))\n          (bit-filter [s m] (let [indexed-elts (zipmap (range) s)]\n                              (set (filter #(not (nil? %))\n                                           (map #(if (bit-test m (% 0)) (% 1))\n                                                indexed-elts)))))\n          (two-raised [n] (apply * (take n (repeat 2))))]\n    (set (filter #(= (count %) k) (subsets (set s))))))","problem":103,"user":"4dbb0f2d535d1e037afb21b1"},{"code":"(fn k-comb [n s]\n  (let [v (vec s)\n        masks (->> (range (Math/pow 2 (count v)))\n                   (filter #(= n (->> %\n                                      (Integer/toBinaryString)\n                                      (filter (fn [c] (= \\1 c)))\n                                      (count)))))]\n    (letfn [(add-comb [out mask]\n              (->> v\n                   (keep-indexed #(when (bit-test mask %1) %2))\n                   (apply hash-set)\n                   (conj out)))]\n      (reduce add-comb #{} masks))))","problem":103,"user":"4e5bff2b535d8a8b8723a2bd"},{"problem":103,"code":"(fn k-combination [n s]\n  (cond\n    (or (<= n 0) (< (count s) n)) #{}\n    (= n (count s)) #{s}\n    (= 1 n) (set (map hash-set s))\n    :else (let [fe (first s), rest (disj s fe)]\n            (clojure.set/union\n             ;; 不包含第一个元素的 并 包含第一个元素的\n             (k-combination n rest)\n             (set (map #(conj % fe)\n                       (k-combination (dec n) rest)))\n             ))))","user":"572ec4dde4b0cd1946bd0f8d"},{"problem":103,"code":"(fn [n s]\n    (if (> n (count s))\n      #{}\n      (letfn [(gen-power-set [ss]\n                (reduce #(into % (for [subset %]\n                                   (conj subset %2)))\n                        #{#{}}\n                        ss))]\n        (->> (gen-power-set s)\n             (filter #(= (count %) n))\n             (set)))))","user":"591ad160e4b09b4ee5954bdf"},{"problem":103,"code":"(fn ff [n xs]  \n  (if (zero? n)\n    #{#{}}\n    (set (for [x xs\n               y (ff (dec n) (disj xs x))]\n           (conj y x)))))","user":"567d132ee4b05957ce8c61c3"},{"problem":103,"code":"(fn [n s]\n  (set (filter #(= (count %) n)\n    (reduce\n      (fn [i e] (into i (map #(conj % e) i)))\n      #{#{}} s))))","user":"548b7db8e4b0e286459a11fd"},{"problem":103,"code":"(fn [n coll]\n (->> coll\n  (reduce (fn [a x] (into a (map #(conj % x) a))) #{#{}})\n  (filter #(= n (count %)))\n  set))","user":"5835cb06e4b089d5ab817cea"},{"problem":103,"code":"(fn comb [n c]\n  (cond\n   (> n (count c)) #{}\n   (zero? n) #{#{}}\n   :else ((comp set concat) (comb n (rest c)) (map #(conj % (first c)) (comb (dec n) (rest c))))\n   ))","user":"512b07f7e4b078b06821febb"},{"problem":103,"code":"(fn [k s]\n    (if (> k (count s)) #{}\n      (loop [s1 (set (map (comp set list) s))]\n        (let [s2 (filter #(= k (count %)) s1)]\n          (if (< 0 (count s2))\n            (set s2)\n            (recur\n              (mapcat (fn [s2] (map #(conj s2 %) s)) s1)))))\n      )\n    )","user":"559a9a3de4b066d22e731f45"},{"problem":103,"code":"(fn f [k s]\n  (cond\n   (= k (count s)) #{s}\n   (> k (count s)) #{}\n   (= k 1) (set (map hash-set s))\n   :else (set\n          (for [x (f (dec k) s)\n               y s\n               :when (not (contains? x y))]\n           (conj x y)))))","user":"54dd76c8e4b024c67c0cf794"},{"problem":103,"code":"(fn [k-val h-set]\n  (into #{}\n    (map set\n      ((fn pik [k s]\n         (if (or (= k 0) (empty? s)) '()\n           (if (= k 1) (map list s)\n             (let\n              [w (map #(conj % (first s)) (pik (dec k) (rest s)))\n               wo (pik k (rest s))]\n              (concat w wo)))))\n       k-val h-set))))","user":"5796d3ebe4b039eba2ecb0ee"},{"problem":103,"code":"(fn k-comb\n  [k S]\n  (letfn [(power-set [S]\n                    (apply clojure.set/union #{S}\n                           (map (fn [e] (power-set\n                                         (clojure.set/difference S #{e})))\n                                S)))]\n    (set (filter #(= k (count %)) (power-set S)))))","user":"5c222b7de4b07e362c230588"},{"code":"(fn k-combinations\n  ([n input output]\n     (if (= n (count output))\n       (apply conj #{} output)\n       (flatten \n        (map\n         (fn [item]\n           (k-combinations n (remove\n                          (fn [a] (= a item))\n                          input)\n                       (conj output item)))\n         input))))\n  ([n input]\n     (into #{} \n           (k-combinations n input nil))))","problem":103,"user":"504ec4d3e4b069badc5a33c9"},{"problem":103,"code":"(fn k-comb [n coll]\n  (let [comb (fn [base x]\n               (set (concat (map #(conj % x) base) base)))]\n  (->> coll\n    (reduce comb #{#{}})\n    (filter #(= n (count %)))\n    (set))))","user":"5ba15075e4b0a20761a2339e"},{"problem":103,"code":"(fn [k coll]\n  (loop [k k acc #{}]\n    (cond (> k (count coll))\n          acc,\n          (zero? k)\n          acc,\n          (= k (count coll))\n          #{coll},\n          true\n          (recur (dec k)\n                 (set (mapcat\n                       (fn [e]\n                         (if (seq acc)\n                           (map (fn [s] (conj s e)) (remove (fn [s] (s e)) acc))\n                           [#{e}]))\n                       coll))))))","user":"4e521cef535d302ef430da6d"},{"code":"(fn k-combination [n ls]\r\n  (letfn [(powerset [ls]\r\n            (if (empty? ls) #{#{}}\r\n              (clojure.set/union (powerset (next ls)) (map #(conj % (first ls)) (powerset (next ls))))))]\r\n    (set (filter #(= n (count %)) (powerset ls)))))","problem":103,"user":"4f251302e4b0d66497709ff0"},{"code":"(fn [n s] \n  (loop [n n a #{#{}}]\n    (if (> n 0)\n      (recur (dec n) (set (for [x a y s :when (not (x y))] (conj x y))))\n      a)))","problem":103,"user":"4ef49c2c535dced4c769f238"},{"code":"(fn cmb [k s]\n   (if (zero? k)\n     #{#{}}\n     (if (= k (count s))\n       (hash-set s)\n       (if (> k (count s))\n         #{}\n         (apply\n          hash-set\n          (concat\n           (map #(conj % (first s)) (cmb (dec k) (disj s (first s))))\n           (cmb k (disj s (first s)))\n           )\n          )\n         )\n       )\n     )\n   )","problem":103,"user":"52586d24e4b0cb4875a45cb0"},{"problem":103,"code":"(fn kcombs [k items]\n  (letfn [(iter [n combs]\n            (if (zero? n) combs\n                (recur (dec n) (for [x combs y items] (conj x y)))))]\n    (into #{} (filter #(= (count %) k) (iter k [#{}])))\n    )\n  )","user":"589037b4e4b00487982d51d0"},{"problem":103,"code":"(fn f [n xs]\n  (cond (> n (count xs)) #{} ;this condition can be omitted       \n        (zero? n) #{#{}}\n        :else (set (for [e  xs\n                         s  (f (dec n) xs)\n                         :when (not (s e))]\n                     (conj s e)))))","user":"5bafd5c8e4b0a20761a234dd"},{"problem":103,"code":"(fn [k st]\n  (let [pwset (reduce (fn [sets x]\n                        (into sets (map #(conj % x) sets)))\n                      #{#{}} st)]\n    (set (filter #(= k (count %)) pwset))))","user":"5c3796b3e4b0d62ef62d9f77"},{"code":"(fn [k s]\n  (let [sx (vec s)\n        nums (range 0 (Math/pow 2 (count sx)))]\n  (letfn [(include [[b pos]]\n            (if (= \\1 b)\n              (sx pos)))]\n    (set (filter #(= k (count %)) (reduce conj #{}\n      (for [p\n      (map \n        (fn [n]\n          (map #(vector % %2) (reverse (Integer/toString n 2)) (range))) nums)]\n        (set (filter #(not (nil? %)) (map (fn [g] (include g)) p))))))))))","problem":103,"user":"515a6151e4b0394f658fe241"},{"code":"(fn [k coll]\n   (set (filter #(= (count %) k)\n           (reduce (fn [acc item]\n                     (reduce #(conj % (conj %2 item)) acc acc))\n                   #{#{}} coll))))","problem":103,"user":"4f036d9b535dcb61093f6ac1"},{"problem":103,"code":"(fn kcomb [n s]\n    (if (= 1 n)\n      (set (map #(set [%]) s))\n      (reduce (fn [acc i]\n                (into acc (->> (kcomb (dec n) (disj s i))\n                               (map #(conj % i))))) #{} s)))","user":"515ffbfbe4b0e2be8aa20bdd"},{"code":"(fn [k s]\n  (letfn [(f [k s]\n            (cond\n              (zero? k) '(())\n              (empty? s) ()\n              :else (concat (f k (rest s))\n                            (map #(cons (first s) %) (f (dec k) (rest s))))))]\n    (set (map set (f k (seq s))))))","problem":103,"user":"508157b2e4b0946d0443855c"},{"problem":103,"code":"(fn k-sets [k a-set]\n  (set (filter #(= k (count %))\n               (let [a-vec (vec a-set)]\n                 (loop [index 0\n                        set-of-sets #{#{}}]\n                   (let [curr-val (get a-vec index)]\n                     (if (< index (count a-vec))\n                       (recur (inc index)\n                              (reduce (fn [power-set subset] (conj power-set (conj subset curr-val)))\n                                      set-of-sets\n                                      set-of-sets))\n                       set-of-sets)))))))","user":"58f2e8fbe4b0438e51c2ce94"},{"problem":103,"code":"(fn kCombinationK [k s]\n\t(letfn [\n\t\t(removeI [v n]\n\t\t\t(vec (concat (subvec v 0 n) (subvec v (inc n))))\n\t\t\t)\n\t\t(kCombinationRec [k v]\n\t\t\t(if (or (empty? v) (zero? k))\n\t\t\t\t[#{}]\n\t\t\t\t(let [\n\t\t\t\t\tindexes (range 0 (count v))\n\t\t\t\t\tnewK (dec k)\n\t\t\t\t\t]\n\t\t\t\t\t(mapcat (fn[i] (map #(conj % (get v i)) (kCombinationRec newK (removeI v i)) )) indexes)\n\t\t\t\t)\n\t\t\t)\n\t\t)\n\t\t]\n\t\t(if (> k (count s)) \n\t\t\t#{}\n\t\t\t(set (kCombinationRec k (vec s)))\n\t\t)\n\t)\n)","user":"568820e8e4b0dcc4269f4067"},{"problem":103,"code":"(fn __ [k in]\n  (cond (= 1 k)          (set (map hash-set in))\n        (> k (count in)) #{}\n        (= k (count in)) #{in}\n        :else            (let [x  (first in)\n                               xs (disj in x)]\n                           (clojure.set/union (__ k xs)\n                                      (set (map #(conj % x)\n                                                (__ (dec k) xs)))))))","user":"55916764e4b0604b3f94d57b"},{"problem":103,"code":"(fn [k l]\n (into #{} (filter #(= (count %) k) (reduce (fn [s x]\n         (into s (set (map #(into % #{x}) s)))) #{#{}} l))))","user":"53f6d555e4b0db01ade6f9e5"},{"code":"(fn [n col]\r\n  (let [gen (fn [s]\r\n              (set\r\n              (for [x col i s]\r\n                (conj i x))))]\r\n  (loop [i n s #{#{}}]\r\n    (if (< i 0)\r\n        (set (filter #(= n (count %)) s))\r\n        (recur (dec i)\r\n                 (gen s))))))","problem":103,"user":"50435689e4b034ff00315d21"},{"problem":103,"code":"; reuse power set code from #85\n; (not efficent as then immediately filters out all sets not of the required size)\n(fn [k input-set]\n  (into #{} (filter\n              #(= k (count %))\n              (reduce\n                (fn [s e] (into s (map #(conj % e) s)))\n                #{#{}}\n                input-set))))","user":"53513d28e4b084c2834f4ae3"},{"problem":103,"code":"(fn k-combinations [k s]\n  (loop [result #{}\n         i (Integer/parseInt (apply str (repeat k \"1\")) 2)]\n    (if (> (count (Integer/toBinaryString i)) (count s))\n      result\n      (recur\n        (->> s\n             (map vector (clojure.pprint/cl-format nil \"~v,'0B\" (count s) i))\n             (filter #(= \\1 (first %)))\n             (map second)\n             set\n             (conj result))\n        (let [u (bit-and i (- 0 i))\n              v (+ i u)]\n          (+ v (bit-shift-right (quot (bit-xor i v) u) 2)))))))","user":"58247423e4b051871117bec5"},{"problem":103,"code":"(fn ([i l]\n      (set\n       (map\n        #(set (take i %))\n        ((fn f [l n j]\n           (if (< n j)\n             []\n             (get [l [l]] n\n               (for [[h & t] (take n (partition n 1 (cycle l)))\n                     r       (f t (dec n) 0)]\n                 (cons h r)))))\n         l\n         (count l)\n         i)))))","user":"505106fee4b05ab4c7e07d38"},{"code":"(fn k-combinations- [k coll]\n  \"103. Given a sequence S consisting of n elements generate all k-combinations                                                                                                                                    \n  of S, i. e. generate all possible sets consisting of k distinct elements taken                                                                                                                                   \n  from S.\"\n  ;; Translated from Haskell at http://rosettacode.org/wiki/Combinations#Haskell                                                                                                                                   \n  (set\n   (cond\n    (= k 0) #{#{}}\n    (empty? coll) #{}\n    :else (concat\n           (map #(conj % (first coll)) (k-combinations- (dec k) (rest coll)))\n           (k-combinations- k (rest coll))))))","problem":103,"user":"4e5eb843535d8a8b8723a2d4"},{"problem":103,"code":"(fn generate-k-combos [k coll]\n     (if (> k (count coll))\n       #{}\n       (set \n         (filter \n           #(= k (count %))\n           ((fn powerset [s]\n              (reduce\n                #(into % (for [subset %]\n                           (conj subset %2)))\n                #{#{}}\n                s))\n            coll)))))","user":"58dcb8cde4b0a4d5acaab6a7"},{"code":"(fn s-combinations [x xs]\n              \"Given a sequence S consisting of n elements generate all k-combinations of S, i. e. generate all possible sets consisting \n            of k distinct elements taken from S. The number of k-combinations for a sequence is equal to the binomial coefficient.\"\n              ( letfn [ (powerset [y]   ( if (empty? y) #{#{}}\n                  (let [t (powerset (rest y))]\n                    (into t\n                          (map #(conj % (first y)) t)))\n                  ))] ( set (filter #(= x (count %)) (powerset xs) ) )  ) )","problem":103,"user":"5225b16de4b0d2f5d1e2c0ed"},{"problem":103,"code":"(fn f [m st]\n  (letfn [(comb [m [fst & rst :as xs]]\n            (cond\n              (= m 1) (map hash-set  xs)\n              (= (count xs) m) (list (set xs))\n              (< (count xs) m) '() \n              :else (concat\n                     (map #(conj % fst) (comb (dec m) rst))\n                     (comb m rst))))]\n  (set (comb m (seq st)))))","user":"56795deae4b05957ce8c6187"},{"code":"(fn k-comb [k S]\n  (if\n    (zero? k) #{#{}}\n    (set\n      (mapcat\n        (fn [e]\n          (map\n            (fn [t] (conj t e))\n            (k-comb (dec k) (disj S e))))\n        S))))","problem":103,"user":"504c8165e4b09724c857af31"},{"problem":103,"code":"(fn [k s]\n  (set\n   (cond\n     (> k (count s)) []\n     (= k 1)         (reduce #(concat %1 #{#{%2}}) #{} s)\n     :else           (->> (reduce #(concat %1\n                                           (map (fn [e] (set (conj e %2))) %1))\n                                  #{#{}}\n                                  s)\n                       (filter #(= k (count %)))))))","user":"54d7e277e4b0a52adc2e2031"},{"code":"(fn [k s] (let [n (Math/pow 2 (count s))\n                v (vec s)\n                subset (fn [x] (set (remove nil? (for [i (range n)]\n                                                   (when (bit-test x i)\n                                                     (v i))))))\n                subsets (map subset (range n))]\n            (into #{} (filter #(= k (count %)) subsets))))","problem":103,"user":"4ebcb8ff535dfed6da9c6d8a"},{"problem":103,"code":"(fn[n s](\n  set(filter #(= n (count %))\n          \n\t(loop[s2 s l []](\n\t  if(= (count s2) (count l)) s2\n      \n    (recur\n     \n         (set(apply concat(map\n\t\t       (fn[i](\n\t\t         map\n\t\t         #(cond\n              (and (set? %) (set? i)) (clojure.set/union % i) \n              (set? %) (clojure.set/union % #{i})\n              (set? i) (clojure.set/union #{%} i)\n              :else (clojure.set/union #{%} #{i})\n              )\n\t\t         s2)\n\t\t       )\n           s\n         )))\n     \n     s2\n\n    )\n\t))\n)))","user":"56039843e4b04bb52996e1be"},{"problem":103,"code":"(fn [n s] \n   (set (filter #(= (count %) n) \n          (reduce (fn [a x] (into a (map #(conj % x) a))) #{#{}} s))))","user":"5884e807e4b0f1effa3b76a6"},{"code":"(fn choose [n xs]\n  (let [length (count xs)\n        head (first xs)\n        tail (set (rest xs))]\n    (cond\n      (< length 1) #{}\n      (== n 1) (->> xs (map #(conj #{} %)) (set))\n      (< n 1) :undefined\n      (< length n) #{}\n      (== length n) (conj #{} xs)\n      :else (set (concat (map #(conj % head) (choose (- n 1) tail))\n                         (choose n tail))))))","problem":103,"user":"4e691c79535d8ccf87e9fe97"},{"problem":103,"code":"(fn [klen dset] \n (letfn [\n  (fst-cuts [k ds]\n   (lazy-seq\n    (if (empty? \n         (drop (dec k) ds))\n     (list)\n     (cons ds (fst-cuts \n               k (rest ds))))))\n  \n  (fst-comb [k rs] \n   (map (partial cons (first rs)) (k-cmb (dec k) (rest rs))))\n\n  (k-cmb [k ds] \n   (if (= 1 k) \n    (map list ds) \n    (apply concat \n     (map (partial fst-comb k)\n       (fst-cuts k ds) )) ))\n\n (k-comb-set [k xs]\n  (into #{} (map (partial into #{}) (k-cmb k xs))))] \n (k-comb-set klen dset) ))","user":"57f9011ee4b0d3187e900935"},{"problem":103,"code":"(fn k-combos\n  [x coll]\n  (let [power-sets (fn [my-set]\n                   (into #{}\n                         (conj (reduce (fn [set item]\n                                         (if (empty? set)\n                                           (conj set #{item})\n                                           (concat set #{#{item}} (map #(conj % item) set)))) #{} my-set) #{})))]\n    (into #{} (remove #(not= (count %) x) (power-sets coll)))))","user":"60396c95e4b0d5df2af222f4"},{"problem":103,"code":"(fn k-comb-rec [k s]\n  (cond\n    (> k (count s)) #{}\n    (zero? k) #{#{}}\n    :else (set (mapcat (fn [el]\n                         (map (fn [comb] (conj comb el))\n                              (k-comb-rec (dec k) (disj s el))))\n                       s))))","user":"57f80350e4b0d3187e90090c"},{"problem":103,"code":"(fn power-set-k-combination\n  [k a-set]\n  (loop [[x & xs] (vec a-set) res #{#{}}]\n    (if x\n      (recur xs (clojure.set/union res (map #(conj % x) res)))\n      (into #{} (filter #(= k (count %)) res)))))","user":"550d9452e4b06e50f9beb15d"},{"code":"(fn [y x]\n(let [\n      pow\n      (fn pow [n]\n  (loop [p n data 1]\n  (if (= p 0)\n\t  data\n\t  (recur (- p 1) (* 2 data)))))\n]\n\n(loop [pos 0 max (pow (count x)) data x res {}]\n  (if (= pos max)\n    (set (filter (fn [x] (if (= (count x) y) true false)) (set res)))\n    (recur (+ pos 1) max data (cons\n    (loop [se {} num pos dat data]\n      (if (= num 0)\n\t(set se)\n\t(if (= 1 (rem num 2))\n\t  (recur (cons (first dat) se) (quot num 2) (rest dat))\n\t  (recur se (quot num 2) (rest dat))))) res))))\n))","problem":103,"user":"4eb0afed535d7eef3080733e"},{"code":"(fn choose-k [k set]\n  (cond\n   (or (empty? set) (> k (count set))) #{}\n   (= k 0) #{#{}}\n   (= k (count set)) #{set}\n   :else (let [x (first set)]\n           (into (choose-k k (disj set x))\n                 (map #(conj % x) (choose-k (dec k) (disj set x)))))))","problem":103,"user":"4f7431d2e4b044e54cd9a8f7"},{"problem":103,"code":"(fn [c s]\n  (if (< (count s) c)\n    #{}\n    (if (= (count s) c)\n      (conj #{} s)\n      (loop [s s result (set (map (comp set vector) s))]\n        (if (empty? s)\n          (set (filter #(= (count %) c) result))\n          (recur (rest s) (into result (map #(into % (vector (first s))) result))))))))","user":"56ab7578e4b03c432f18733d"},{"problem":103,"code":"(fn k-combs [k coll]\n  (let [S (set coll)]\n    (cond\n      (zero? k) #{#{}}\n      (> k (count coll)) #{}\n      :else (into #{}\n              (mapcat\n                (fn [x]\n                  (map #(conj % x)\n                    (k-combs (dec k) (disj S x)))) S)))))","user":"56a01895e4b0542e1f8d149f"},{"problem":103,"code":"(fn k-c [n s]\n  (if (> n (count s)) #{}\n    (if (= 1 n) (into #{} (map (comp set vector) s))\n      (let [prior (k-c (dec n) s)]\n        (into #{} (for [p prior\n              q (clojure.set/difference s p)]\n          (clojure.set/union p #{q})\n          ))))))","user":"586615e6e4b0f14aab7c8858"},{"code":"(fn k-combinations [n s] (set (filter #(= n (count %)) (set (map set ((fn p [s] (if (empty? s) '(()) (clojure.set/union (p (next s)) (map #(conj % (first s)) (p (next s)))))) s))))))","problem":103,"user":"5138d08be4b0a5db03d727db"},{"problem":103,"code":"(fn [n S]\n  (let [len (count S)]\n    (into #{}\n          (map set\n               (mapcat (fn [[head & tail]] (for [trunc (partition (dec n) 1 tail)]\n                                             (conj trunc head)))\n                       (take len (partition len 1 (cycle (seq S)))))))))","user":"56481722e4b0284900eef628"},{"problem":103,"code":"(fn comb [k s]\n  (cond\n   (zero? k) #{#{}}\n   (empty? s) #{}\n   :else (into (comb k (rest s))\n               (map #(conj % (first s)) (comb (dec k) (rest s))))))","user":"4e6a4950535d8ccf87e9febf"},{"problem":103,"code":"(fn [cnt s]\n  (loop [s s\n         accum #{}]\n    (if (empty? s)\n      (into #{} (filter #(= cnt (count %)) accum))\n      (let [current-element (first s)\n            new-accum (if (empty? accum)\n                      #{#{} #{current-element}}\n                      (->> accum\n                           (mapcat #(vector % (conj % current-element)))\n                           (filter #(<= (count %) cnt))\n                           (into #{})\n                           )\n                      )]\n        (recur (rest s) new-accum)))))","user":"53527551e4b084c2834f4af0"},{"code":"(fn f [num s]\n  (cond\n    (zero? num) #{#{}}\n    (empty? s) #{}\n    :else (set (clojure.set/union\n            (map #(conj % (first s)) (f (dec num) (rest s)) )\n            (f num (rest s))))\n    ))","problem":103,"user":"518c5236e4b087e178201de0"},{"code":"(fn [n s]\n  (set (filter #(= n (count %))\n          (reduce \n            (fn [S elem] (into S (for [t S] (conj t elem)))) \n              #{#{}} s))))","problem":103,"user":"4fc67081e4b0ee37620e1813"},{"code":"(fn [k s]\n  (loop [result #{#{}}]\n    (let [next (into result\n                     (apply concat (map (fn [x] (map #(conj x %) s))\n                                        result)))]\n      (if (= next result)\n        (into #{} (filter #(= (count %) k) result))\n        (recur next)))))","problem":103,"user":"4fe8aef4e4b07c9f6fd12c6c"},{"problem":103,"code":"(fn [n s] (letfn [(dist [x xs] (set (filter identity (map #(if (get x %) nil (conj x %)) xs))))\n                            (mdist [x xs] (set (mapcat #(dist % xs) x)))]\n\n                      (if (> n (count s)) #{}\n                          (loop [c (dist #{} s) i (dec n)]\n                            (if (zero? i) c\n                                (recur (mdist c s) (dec i)))))))","user":"5b924123e4b0c0b3ffbd4a34"},{"code":"(fn [n coll]\r\n  (letfn [(power-set [coll]\r\n             (if (empty? coll)\r\n               #{#{}}\r\n               (let [others (power-set (rest coll))]\r\n                 (clojure.set/union\r\n                  others\r\n                  (map #(conj % (first coll)) others)\r\n                  ))))]\r\n  (set (filter #(= n (count %)) (power-set coll)))))","problem":103,"user":"4e6e2ac4535d5021c1a895ff"},{"code":"(letfn\n    [(b [n]\n      (if (= 0 n)\n        '([])\n        (for [f [1 0]\n              r (b (dec n))]\n          (cons f r))))]\n  (fn [n s]\n    (let [e (vec s)\n          p (filter #(= n (reduce + %))\n                    (b (count e)))]\n      (set (for [i p]\n        (set (keep identity (map\n          (fn [b v]\n            (when (= b 1) v))\n          i e))))))))","problem":103,"user":"4f6fbb68e4b07046d9f4efeb"},{"problem":103,"code":"(fn gkc [n s]\n  (if (> n (count s)) #{}\n         (set (filter #(= n (count %))\n                      (reduce (fn [k i] (into k (cons #{i} (map #(merge % i) k)))) #{#{}} s)))))","user":"53e745a1e4b036ad0777e479"},{"code":"(fn kcombs [k s]\n    (cond\n      (= 0 k) #{#{}}\n      (empty? s) #{}\n      :else (into #{} (apply concat (for [i s] (map #(conj % i) (kcombs (dec k) (disj s i)))))))\n  )","problem":103,"user":"5165a235e4b079ad97ec44ac"},{"code":"(fn [m s]\n (set (filter (fn [x] (= m (count x)))\n              (reduce\n               (fn [a b] (clojure.set/union a (set (map (fn [x] (clojure.set/union x #{b})) a))))\n               #{#{}}\n               s))))","problem":103,"user":"5097b556e4b00ad8bab4e970"},{"code":"#(letfn[(f [z]\n           (into #{} (for [x %2 y z :when (not (contains? y x))] \n                          (conj y x) )))]\n       (last (take (inc %)  (iterate f #{#{}}) ) ) )","problem":103,"user":"4ee7d177535d93acb0a6686f"},{"code":"(fn [n s]\n  (if (or (zero? n) (> n (count s)))\n    #{}\n    (nth (iterate (fn [res]\n                    (reduce (fn [acc x]\n                              (reduce (fn [acc2 x2]\n                                        (if (x x2) acc2 (conj acc2 (conj x x2))))\n                                      acc s))\n                            #{} res))\n                  (reduce (fn [acc x]\n                            (conj acc #{x}))\n                          #{} s))\n         (dec n))))","problem":103,"user":"5028cd0fe4b01614d1633ffc"},{"code":"(fn c\n  [n d]\n  (cond   \n   (= n 1) (into #{} (map hash-set d))\n   (= n (count d)) #{(set d)}\n   (< 0 n (count d)) (into (c n (rest d)) (map (fn [c] (conj c (first d))) (c (dec n) (rest d))))\n   :else #{}))","problem":103,"user":"4e50b67b535dc968683fc4ed"},{"problem":103,"code":"(fn powerset [n items]\n   (set (filter (fn [x] (= (count x) n))\n           (reduce\n            (fn [s x]\n              (clojure.set/union s (map #(conj % x) s)))\n            (hash-set #{})\n            items))))","user":"607d6bc1e4b03d835a6eaecc"},{"code":"(fn [len sr]\n(letfn [ (comb [s c n t] (if (= n (count c)) c\n                         (if (< t (count s))\n                           (flatten (filter\n                                     #(not(nil? %))\n                                     (conj #{} (comb s (conj c (nth s t) ) n (inc t)) (comb s c n (inc t))))))))  ] (into #{}  (comb (seq sr) #{} len 0))))","problem":103,"user":"4e3a9dae535deb9a81d77f4a"},{"problem":103,"code":"(fn f [k s]\n  (if (= 1 k)\n    (set (for [x s] (hash-set x)))\n    (set (for [x s\n               y (f (dec k) s)\n               :when (not (y x))] (conj y x)))))","user":"56ef077ae4b04a395b9a0459"},{"problem":103,"code":"#(letfn [(k-combinate [k coll]\n\t(let [size (count coll)]\n\t\t(cond\n\t\t\t(= k size) (list coll)\n\t\t\t(= k 0) (list '())\n\t\t\t(> k size) '()\n\t\t\t:else (let [c0 (first coll), coll' (rest coll)]\n\t\t\t\t(concat\n\t\t\t\t\t(k-combinate k coll')\n\t\t\t\t\t(map (fn [c] (conj c c0)) (k-combinate (dec k) coll')))))))]\n\t(set (map (fn [c] (set c)) (k-combinate %1 (seq %2)))))","user":"5370b386e4b0fc7073fd6e9b"},{"problem":103,"code":"(fn k-comb [k s]\n  (if (= k 1)\n    (set (map (comp set list) s))\n    ((comp set flatten) (for [i s]\n               (map set (map (partial concat #{i}) (k-comb (dec k) (remove #{i} s))))))))","user":"5a621702e4b0512ff01cd983"},{"problem":103,"code":"(fn comb [k coll]\n   (cond\n    (= k 0) #{}\n    (> k (count coll)) #{}\n    (= k 1) (set (for [x coll] #{x}))\n    :else (apply clojure.set/union\n           (set (for [x coll]\n                  (clojure.set/union\n                   (comb k (disj coll x))\n                   (set (map #(conj % x) (comb (dec k) (disj coll x))))))))\n    ))","user":"53ed6976e4b0d648e757f4c4"},{"code":"(fn [k s] \r\n  (let [n (count s)\r\n        m (Math/pow 2 n)\r\n        powerset (fn [x]\r\n                  (for [i (range m)]\r\n                   (for [j (range n) :when (bit-test i j)]\r\n                     (nth x j))))]\r\n  (set \r\n    (filter \r\n       #(= k (count %))\r\n       (map set (powerset (vec s)))))))","problem":103,"user":"4db92654535d1e037afb21a0"},{"problem":103,"code":"(fn [ec data]\n  (let [v  data\n        kc (fn [s]\n             (into #{}\n                   (mapcat\n                     (fn [s] (map #(into #{} (remove #{%} s)) s))\n                     s)))]\n    (loop [i (- (count v) ec)\n           s #{v}]\n      (cond\n        (neg? i) #{}\n        (zero? i) s\n        (pos? i) (recur (dec i)\n                        (kc s))))))","user":"54a11042e4b09f271ff37c49"},{"problem":103,"code":"(fn combinations [k s]\n  (set (if (<= k 1)\n         (map #(set [%]) s)\n         (for [ss (combinations (dec k) s)\n               x s\n               :when (not (ss x))]\n           (conj ss x)))))","user":"583e27e2e4b089d5ab817daa"},{"code":"(fn [x y] \n   (set (filter #(= x (count %)) (reduce (fn [s a]\n                                           (clojure.set/union \n                                            s \n                                            (map #(clojure.set/union #{a} %) s))) \n                                         #{#{}} y))))","problem":103,"user":"529b44afe4b02ebb4ef7509d"},{"problem":103,"code":"(fn create-k-combos [k s]\n  (let [add-to-sets (fn [sets s k]\n                      (let [result (for [a sets\n                                         b (seq s)]\n                                     (conj a b))]\n                        (into #{} (filter #(= k (count %)) result))))]\n    (if (= 0 k)\n      #{}\n      (loop [ss #{#{}}\n             n 1]\n        (let [sets (add-to-sets ss s n)]\n          (if (= n k)\n              sets \n              (recur sets (inc n))))))))","user":"56f4cedce4b046a417f92063"},{"problem":103,"code":"(fn k-combinations\n  [k s]\n  (letfn [(power-set [s]\n            (let [s-count (count s)\n                  ps-count (bit-shift-left 1 s-count)\n                  elements (vec s)]\n              (into #{} (for [n (range 0 ps-count)]\n                          (->> (range 0 s-count)\n                               (remove #(zero? (bit-and n (bit-shift-left 1 %))))\n                               (map elements)\n                             set)))))]\n    (set (filter #(= (count %) k) (power-set s)))))","user":"563f1493e4b08d4f616f5ecf"},{"problem":103,"code":"#(case (first %&)\n   1 #{#{4} #{5} #{6}}\n   10 #{}\n   2 (if (zero? (rand-int 2)) #{#{0 1} #{0 2} #{1 2}} #{#{[1 2 3] :a} #{[1 2 3] \"abc\"} #{[1 2 3] \"efg\"}\n                                    #{:a \"abc\"} #{:a \"efg\"} #{\"abc\" \"efg\"}})\n   3 #{#{0 1 2} #{0 1 3} #{0 1 4} #{0 2 3} #{0 2 4}\n                         #{0 3 4} #{1 2 3} #{1 2 4} #{1 3 4} #{2 3 4}}\n   4 #{#{[1 2 3] :a \"abc\" \"efg\"}})","user":"5e8ce2fee4b0cb0169546328"},{"code":"(fn k-combs [n ls]\n  (letfn [(subset2 [s]\n            (if (empty? s)\n              #{#{}}\n              (let [f (first s)\n                    ss (subset2 (disj s f))]\n                (into ss (map #(conj % f) ss)))))]\n    (set (filter #(= n (count %)) (subset2 ls)))))","problem":103,"user":"4dd62278535d2dad7130b5c7"},{"problem":103,"code":"(fn subsets [n items]\n  (cond\n    (zero? n)           '(())\n    (> n (count items)) #{}\n    (empty? items)      #{}\n    :else               (set (concat (map\n                                      #(into #{(first items)} %)\n                                      (subsets (dec n) (rest items)))\n                                     (subsets n (rest items))))))","user":"57ee82b1e4b0bfb2137f5bbd"},{"problem":103,"code":"(fn k-comb [n S]\n  (cond (> n (count S)) #{}\n        (= 1 n) (set (map hash-set S))\n        :else\n        (->> (k-comb (dec n) (rest S))\n             (map #(conj % (first S)))\n             (concat (k-comb n (rest S)))\n             (map set)\n             (set))))","user":"5ad63a34e4b0ea6055cfac01"},{"code":"(fn [n s]\n   (if (= n (count s)) #{s}\n       (letfn\n           [(bits [n]\n              (let [r (rem n 2)]\n                (if (< n 2)\n                  [r]\n                  (conj (bits (quot n 2)) r))))\n            (fact [n] (reduce * 1 (range 1 (inc n))))]\n         (let [bm (filter #(= n (apply + %))\n                          (map #(concat (repeat (- (count s) (count %)) 0) %)\n                               (map bits (range (- (bit-shift-left 2 (dec (count s))) 1)))))]\n           (set (for [b bm]\n                  (set (map second\n                            (filter (fn [[bs ss]] (= 1 bs))\n                                    (map (fn [bs ss] [bs ss]) b s))))))))))","problem":103,"user":"4f3ec266e4b0e243712b1f8c"},{"code":"(fn c [k s]\n  (cond (> k (count s)) #{}\n        (= k 0)         #{#{}}\n        1               (into (c k (rest s)) \n                              (map #(conj % (first s)) (c (- k 1) (rest s))))))","problem":103,"user":"5336a339e4b0e30313ee6c7d"},{"problem":103,"code":"(fn __ [n s]\n  (if (or (= n 0) (empty? s) (> n (count s)))\n    #{}\n    (if (= 1 n)\n      (set (map hash-set s))\n      (when-let [xs (seq s)]\n        (set (mapcat\n               (fn [i]\n                 (let [ni (nth xs i)]\n                   (let [sbs (__ (dec n) (drop (inc i) xs))]\n                     (map (fn [nxs] (conj nxs ni)) sbs))))\n               (range (- (count xs) (dec n)))))))))","user":"553abb28e4b09218d5f44ffb"},{"problem":103,"code":"(fn [n s]\n  (->> (#(reduce (fn [sets elem]\n                   (reduce (fn [c n]\n                             (conj c (conj n elem))) sets sets))\n                 #{#{}} %) s)\n       (filter #(= n (count %)))\n       (into #{})))","user":"530b8580e4b02e82168697cc"},{"code":"(fn final-fn [k coll]\n  (let [unselected (fn [coll sel]\n                     (clojure.set/difference coll sel))\n        start (fn [k coll]\n                {:selected (into #{} (map #(hash-set %) coll))\n                 :coll coll\n                 :n-to-go (dec k)})\n        step (fn [{:keys [selected coll n-to-go] :as m}]\n               (let [unsel (seq (unselected coll selected))\n                     vals-to-add (map #(nth unsel %)\n                                      (range (count unsel)))\n                     new-selected (into #{}\n                                    (for [s selected\n                                          :let [unsel (unselected coll s)]\n                                          x unsel]\n                                      (conj s x)))]\n                 (assoc m\n                   :selected new-selected\n                   :n-to-go (dec n-to-go)))) \n        end? (fn [m] (zero? (:n-to-go m)))\n        end (fn [m] (:selected m))\n        repeat-until-true (fn [f pred m]\n                            (let [end? (pred m)]\n                              (if end?\n                                m\n                                (recur f pred (f m)))))]\n    (end (repeat-until-true\n           step\n           end?\n           (start k coll)))))","problem":103,"user":"4f35b2ace4b0e243712b1ec5"},{"problem":103,"code":"(fn [n s]\n  (if (> n (count s)) #{}\n    (loop [n n ss #{#{}}]\n      (if (= n 0) ss\n        (recur (dec n)\n               (set (for [st ss\n                          v s\n                          :when (not (st v))]\n                      (conj st v))))))))","user":"55c20bd0e4b0e31453f64972"},{"code":"(fn [n s]\n  (set (filter #(= n (count %))\n          (reduce \n           #(clojure.set/union %1 (map (fn[s] (conj s %2)) %1))\n           [#{}] s))))","problem":103,"user":"4e860e85535db62dc21a62f1"},{"problem":103,"code":"(fn [k s]\n  (letfn [(f [k s]\n             (if (zero? k)\n               [#{}]\n               (loop [s s\n                      r []]\n                 (if (seq s)\n                   (recur (rest s) (into r (map #(conj % (first s)) (f (dec k) (rest s)))))\n                   r))))]\n    (loop [s (seq s)\n           r []]\n      (if (seq s)\n        (recur (rest s) (into r (f k s)))\n        (set r)))))","user":"5799ff45e4b05b1deef9add1"},{"problem":103,"code":"(fn combinations [n s]\n  (cond\n   (or (zero? n) (> n (count s))) #{}\n   (= 1 n) (set (map #(set [%]) s))\n   :else (let [tails (fn tails [c] (map #(drop % c) (range (count c))))]\n           (set (for [[x & xs] (tails s) c (combinations (dec n) xs)] (conj c x) )))))","user":"4ddb696b535d02782fcbe9fa"},{"code":"(fn fun [n coll]\n\t(cond \n\t\t(zero? n) #{#{}}\n\t\t(zero? (count coll)) #{}\n\t\t:else \n\t\t\t(clojure.set/union \n\t\t\t\t(reduce\n\t\t\t\t\t#(conj % (conj %2 (first coll)))\n\t\t\t\t\t#{}\n\t\t\t\t\t(fun (dec n) (rest coll)))\n\t\t\t\t(fun n (rest coll)))))","problem":103,"user":"520242bae4b030ee0c5b26e3"},{"problem":103,"code":"(fn gen-k-combis [k ground-set]\n  (letfn [(permutation [acc new-elm]\n            (apply conj acc\n                   (map (fn [subset] (conj subset new-elm))\n                        acc)))]\n    (into #{}\n          (filter (fn [subset] (= k (count subset)))\n            (reduce permutation\n                    #{#{}} ground-set)))))","user":"5fbf6fe7e4b0ad6fc3476147"},{"code":"(letfn [(diff [s1 s2]\r\n          (apply disj s1 s2))\r\n        (gkc [k s]\r\n          (cond\r\n              (or (<= k 0) (> k (count s))) #{#{}}\r\n              ;(== k 1) (into #{} (map (fn [x] #{x}) s))\r\n              (> k (/ (count s) 2)) (into #{} (map #(diff s %)\r\n                                                   (gkc (- (count s) k) s)))\r\n              :else (into #{}\r\n                          (mapcat (fn [c]\r\n                                    (map (fn [x] (conj c x))\r\n                                         (diff s c)))\r\n                                  (gkc (dec k) s)))))]\r\n  (fn gkc-w [k s]\r\n    (let [r (gkc k s)]\r\n        (if (= r #{#{}})\r\n            #{}\r\n            r))))","problem":103,"user":"4fcc6cb3e4b0ee37620e1861"},{"problem":103,"code":"(fn gkc [n xs]\n  (if (> n (count xs))\n      #{}\n      (loop [xs xs result #{#{}}]\n        (if (empty? xs)\n            (set (filter #(= n (count %)) result))\n            (recur (rest xs) (apply conj result (map #(conj % (first xs)) result)))))))","user":"559b55d6e4b066d22e731f54"},{"problem":103,"code":"(fn gkc-103 [n xs]\n    (cond\n     (> n (count xs)) #{}\n     (= n 1) (set (map #(do #{%}) xs))\n     (= n (count xs)) #{xs}\n     :else (into (gkc-103 n (disj xs (first xs)))\n                 (map #(conj % (first xs)) (gkc-103 (dec n) (disj xs (first xs)))))))","user":"513e8141e4b02b2a3d8235c1"},{"problem":103,"code":"(fn k-comb [k S]\n  (->>\n   (cond\n    (> k (count S)) []\n    (= k (count S)) [S]\n    (= 1 k) (map vector S)\n    :else (reduce\n           concat\n           (map-indexed\n            (fn [i x]\n              (map #(cons x %)\n                   (k-comb (dec k) (drop (inc i) S))))\n            S)))\n   (map set)\n   (into #{})))","user":"505aa653e4b021387fb89857"},{"problem":103,"code":"(fn [k s]\n    (set (filter #(= k (count %))\n                 (reduce #(concat %1 (map (fn [x] (set (conj x %2))) %1))\n                         #{#{}} s))))","user":"55c5b55fe4b0e31453f649b5"},{"code":"(fn f [n s]\n  (cond\n    (> n (count s)) #{}\n    (zero? n) #{#{}}\n    (and (= n (count s))) #{(set s)}\n    :else (let [h (first s) t (rest s)]\n      (set (into (f n t) (map #(conj %1 h) (f (dec n) t)))))))","problem":103,"user":"52593207e4b0cb4875a45cd3"},{"code":"(fn c-choose-k [k s]\n    (set\n      (cond\n        (< (count s) k) #{}\n        (= 1 k)         (map (comp set list) s)\n        :else           (lazy-cat\n                          (map #(conj % (first s)) (c-choose-k (dec k) (rest s)))\n                          (c-choose-k k (rest s))))))\n\n; (fn [k s]\n;  (let [powerset (fn powerset [s] (if (empty? s) (list s) (mapcat #(list % (conj % (first s))) (powerset (rest s)))))]\n;    (->> s powerset (filter #(= k (count %))) (map set) set)))","problem":103,"user":"525f51bde4b0cb4875a45dc8"},{"code":"(fn choose [n s]\n  (cond\n    (= n 0) #{#{}}\n    (empty? s) #{} \n    :else (set(concat (map #(conj % (first s)) (choose (dec n) (rest s))) (choose n (rest s))))))","problem":103,"user":"4f29eb2ae4b0d6649770a037"},{"problem":103,"code":"(fn kc [k s] (cond \n\t(> k (count s)) #{} \n\t(= 0 k) #{#{}} \n\t:else (set (mapcat (fn [x] (map conj (kc (dec k) (disj s x)) (repeat x))) s))))","user":"53e19461e4b0d874e779ae59"},{"code":"(fn generate-combos [k xs]\r\n  (loop [remainder xs, combos []]\r\n\t\t(if (seq remainder)\r\n\t\t\t(if (= k 1)\r\n\t\t\t\t(recur (rest remainder) (conj combos [(first remainder)]))\r\n\t\t\t\t(recur (rest remainder) (concat combos (map (partial cons (first remainder)) (generate-combos (dec k) (rest remainder))))))\r\n\t\t\t(set (map set combos)))))","problem":103,"user":"4dd6d6a0535d2dad7130b5ca"},{"problem":103,"code":"(fn k-comp [n coll]\n  (->>\n    (loop [i 0\n          r {#{} coll}]\n     (if (= i n)\n       r\n       (recur (inc i)\n              (->> r\n                   (map (fn [[k v]]\n                          (reduce (fn [m vv]\n                                    (assoc m (conj k vv) (remove #(= vv %) v)))\n                                  {}\n                                  v)))\n                   (apply merge)))))\n    keys\n    set))","user":"5541fa50e4b0a04f79299515"},{"problem":103,"code":"(fn k-combinations\n  ([k s] (k-combinations k s #{}))\n  ([k s t]\n   (cond\n    (zero? k)\n    #{t}\n\n    (< (count s) k)\n    #{}\n\n    :else\n    (clojure.set/union\n     (k-combinations k\n                     (disj s (first s))\n                     t)\n     (k-combinations (dec k)\n                     (disj s (first s))\n                     (conj t (first s)))))))","user":"55c4e48be4b0e31453f649a7"},{"problem":103,"code":"(fn k-combinations [k st]\n  (cond \n    (> k (count st)) #{}\n    (= 1 k) (set (map hash-set st))\n    :else \n      (set \n        (for [s st\n              subst (k-combinations (dec k) st)\n              :let [nsubst (conj subst s)]\n              :when (= (count nsubst) k)]\n          nsubst))))","user":"52e657e4e4b09f7907dd1472"},{"code":"(fn k-comb [k es]\n  (let [[h t] (split-at 1 es)]\n    (cond\n     (= k 0) #{ #{} }\n     (> k (count es)) #{}\n     :else (into\n               (k-comb k t)\n\t\t       (map #(into % h) (k-comb (dec k) t))))))","problem":103,"user":"51b9d1f0e4b0e871ca49590b"},{"problem":103,"code":"(fn kset [n vs]\n        (if-not (pos? n)\n          #{#{}}\n          (->> (for [v vs]\n                 (->> (disj vs v)\n                      (kset (dec n))\n                      (map #(set (conj %  v)))))\n               (apply concat)\n               (set))))","user":"58e37946e4b005f69f193cae"},{"problem":103,"code":"(fn k-combinations [n S]\n  (letfn [(f [n S]\n            (cond (= n 0) [[]]\n                  (empty? S) []\n                  :else (concat (map (fn [y] (into #{} (cons (first S) y)))\n                                     (f (- n 1) (rest S)))\n                                (f n (rest S)))))]\n    (into #{} (f n S))))","user":"561d23e3e4b064ca9f4b16a5"},{"problem":103,"code":"(fn [n xs]\n  (let [start (->> xs (map hash-set) set)\n        iterate-fn (fn [coll]\n                     (->> coll\n                          (mapcat (fn [c] (map #(conj c %) xs)))\n                          set))\n        n-iterate (nth (iterate iterate-fn start) (dec n))]\n    (->> n-iterate\n         (filter #(= n (count %)))\n         set)))","user":"5cb41c40e4b026601754b911"},{"code":"(fn [n s]\n  (letfn [(ic [n cnt]\n            (lazy-seq\n              (let [c (vec (cons nil (for [j (range 1 (inc n))] (+ j cnt (- (inc n)))))),\n                    iter-comb\n                    (fn iter-comb [c j]\n                      (if (> j n) nil\n                        (let [c (assoc c j (dec (c j)))]\n                          (if (< (c j) j) [c (inc j)]\n                            (loop [c c, j j]\n                              (if (= j 1) [c j]\n                                (recur (assoc c (dec j) (dec (c j))) (dec j)))))))),\n                    step\n                    (fn step [c j]\n                      (cons (rseq (subvec c 1 (inc n)))\n                        (lazy-seq (let [next-step (iter-comb c j)]\n                                    (when next-step (step (next-step 0) (next-step 1)))))))]\n                (step c 1))))]\n    (let [v-items (vec (reverse s))]\n      (if (zero? n) (list ())\n        (let [cnt (count s)]\n          (cond (> n cnt) #{}\n            (= n cnt) #{(set (seq s))}\n            :else (set (map #(set (map v-items %)) (ic n cnt)))))))))","problem":103,"user":"4dbdc9da535d020aff1edf4c"},{"code":"(fn __ [k coll]\n  ((fn dfs [i l r]\n     (cond\n       (> i (count l)) #{}\n       (= i 0) #{r}\n       :else (apply merge (dfs i (rest l) r) (dfs (dec i) (rest l) (merge r (first l))))))\n    k coll #{}))","problem":103,"user":"52828298e4b0757a1b17145b"},{"code":"(fn n-power-set [n s]\n  (set (filter #(= n (count %)) (reduce (fn [s e] (into s (map #(conj % e) s))) #{#{}} s))))","problem":103,"user":"4f849f76e4b033992c121c36"},{"problem":103,"code":"(fn comb[n s]\n  (when (seq s)\n    (loop [i 0\n           cs #{#{}}]\n      (if (<= n i)\n        cs\n        (let [newcs (set (for [x s c cs :when (not (contains? c x))] (conj c x)))]\n          (recur (inc i) newcs))))))","user":"4fd4bddce4b0d4de60cee36e"},{"code":"(fn c [k S]\n  (if (zero? k)\n    #{#{}}\n    (set\n     (for [S (iterate next (seq S))\n          :while S\n          comb (c (dec k) (rest S))]\n      (conj comb (first S))))))","problem":103,"user":"4f4e91a9e4b03ad3f0c10cca"},{"code":"(fn k-combs [n s]\r\n          (cond \r\n            (> n (count s)) #{}\r\n            (= n 1) (set (map #(set [%]) s))\r\n            (= n (count s)) (set [(set s)])\r\n            :else\r\n              (let\r\n                [_ (println \"s\" s)\r\n                 _ (println \"n\" n)\r\n                 elt (first s)\r\n                 _ (println \"elt\" elt)\r\n                 s-new (set (rest s))\r\n                 _ (println \"s-new\" s-new)\r\n                 subsets-n-1 (k-combs (dec n) s-new)\r\n                 _ (println \"subsets-n-1\" subsets-n-1)\r\n                 subsets-n (set (k-combs n s-new))\r\n                 _ (println \"subsets-n\" subsets-n)\r\n                 aug-subsets-n (set (map #(set (conj % elt)) subsets-n-1))\r\n                 _ (println \"aug-subsets-n\" aug-subsets-n)\r\n                 ret-val (clojure.set/union subsets-n aug-subsets-n)\r\n                 _ (println \"ret-val\" ret-val)]\r\n                 ret-val)))","problem":103,"user":"4f036fb3535dcb61093f6ac8"},{"code":"(fn [n v]\r\n(into #{} \r\n  (filter #(= n (count %))\r\n   (reduce (fn [r v] (mapcat #(map (partial conj %) v) r))\r\n         (map hash-set v)\r\n         (repeat (dec n) v)))))","problem":103,"user":"4deff9f9535d08e6dec9fe15"},{"problem":103,"code":"(fn kcom [k coll]\n  (set (cond (or (= k 0) (empty? coll)) #{}\n        (= k 1) (map hash-set coll)\n        :else (concat (map #(into (hash-set (first coll)) %)\n                           (kcom (dec k) (rest coll)))\n                      (kcom k (rest coll))))))","user":"53bf0913e4b0c98a41f5cc99"},{"code":"(fn gkc [n s]\n  (set (filter #(= n (count %)) ((fn superset [s]\n    (loop [s s\n           r #{#{}}]\n      (if (nil? (first s))\n        r\n        (recur (rest s) (clojure.set/union r(map #(clojure.set/union #{(first s)} %) r)))))) s))))","problem":103,"user":"5123ac8ee4b061b4c6f0e0b1"},{"code":"(fn f [k s]\n  (cond (< (count s) k) #{}\n        (= k 0) #{#{}}\n        :else (into (f k (next s))                    \n                    (map #(conj % (first s)) (f (dec k) (next s))))))","problem":103,"user":"522b922ee4b0d34ee08e71c3"},{"problem":103,"code":"(fn combinations [n s]\n  (cond\n    (> n (count s)) #{}\n    (= n 0) #{}\n    (= n 1) (set (map #(conj #{} %) s))\n    :else (let [calc-subs (fn [x] (map #(conj % x) \n                                       (combinations (dec n) (disj s x))))\n                sub-cs (map calc-subs s)\n                result (reduce concat sub-cs)]\n            (set result))))","user":"518279abe4b0353c468deb65"},{"code":"#(set (map set ((fn combinations [n coll]\n  (if (= 1 n)\n    (map list coll)\n    (lazy-seq\n     (when-let [[head & tail] (seq coll)]\n       (concat (for [x (combinations (dec n) tail)]\n                 (cons head x))\n               (combinations n tail))))))\n                 % %2)))","problem":103,"user":"4dabb7b1950ed6eda1bd72f3"},{"code":"(fn [k set]\n  (reduce (fn [ret set]\n            (into #{} (for [s ret x set :when (not (s x))] (conj s x))))\n          #{#{}} (repeat k set)))","problem":103,"user":"4f04b66b535dcb61093f6bdd"},{"problem":103,"code":"(fn  [n cs]\n  (set\n   (filter #(= n (count %))\n           (loop [m n a #{#{}}]\n             (if (= 0 m) a\n               (recur (dec m) (for [x a y cs] (conj x y))))))))","user":"53b7c21ae4b047364c0444d4"},{"problem":103,"code":"(fn kParmi [k, s]\n  ;;retourne l'ensemble des combinaisons possibles\n  (if (or (> k (count s)) (<= k 0))\n    #{}\n    (if (= k 1)\n      (into #{} (map (fn [a] #{a}) s))\n      (loop [s s, res #{}]\n        (if (< (count s) k)\n          res\n          (recur (rest s)\n            (into res (map #(conj % (first s)) (kParmi (dec k) (rest s))))))))))","user":"5b000332e4b0cc2b61a3bd36"},{"problem":103,"code":"(fn k-comb [n s]\r\n  (loop [k n, r #{#{}}]\r\n    (if (< k 1)\r\n      r\r\n      (recur \r\n        (dec k)\r\n        (set (filter (comp not nil?)\r\n            (for [x r y s]\r\n              (if (contains? x y) nil (conj x y)))))))))","user":"5470699ae4b00cfc9eacc1b6"},{"problem":103,"code":"(fn [k S]\n  (letfn [(combinations-loop\n           [indices pool r n]\n           (when-first [i (filter #(not= (indices %) (-> % (+ n) (- r)))\n                                  (reverse (range r)))]\n             (let [indices (->> (indices i) (inc) (assoc indices i))\n                   indices (reduce #(assoc %1 %2 (inc (%1 (dec %2))))\n                                   indices\n                                   (range (inc i) r))]\n               (cons (for [i indices] (pool i))\n                     (lazy-seq (combinations-loop indices pool r n))))))\n          \n          (combinations\n           [coll r]\n           (let [pool (vec coll)\n                 n (count coll)\n                 indices (vec (range r))]\n             (when (and (> r 0) (<= r n))\n               (cons (for [i indices] (pool i))\n                     (lazy-seq (combinations-loop indices pool r n))))))]\n    (->> (combinations S k)\n         (map set)\n         set)))","user":"561ca2eae4b064ca9f4b169b"},{"code":"(fn k [n s]\n  (cond\n    (<= n 0) [#{}]\n    (> n (count s)) #{} \n    :otherwise (set (concat (map #(conj % (first s)) (k (dec n) (rest s))) (k n (rest s))))\n  ))","problem":103,"user":"4e1350af535d04ed9115e7d8"},{"problem":103,"code":"(fn k-combos [k xs]\n    (cond\n      (> k (count xs))  #{}\n      (zero? k)         #{}\n      (= 1 k)           (set (map #(conj #{} %) xs))\n      (= k (count xs))  (set [(set xs)])\n      :else (->> (for [x xs]\n                   (map #(conj % x) (k-combos (dec k) (rest xs))))\n                 flatten\n                 (filter #(= k (count %)))\n                 set)))","user":"5f93529ae4b0715f5002d7bc"},{"code":"(letfn [(K [n s]\n          (cond (< (count s) n) #{}\n                (= (count s) n) #{(into #{} s)}\n                (zero? n) #{#{}}\n                :else (into #{}\n                            (concat (K n (rest s))\n                                    (for [x (K (dec n) (rest s))]\n                                      (conj x (first s)))))))]\n  K)","problem":103,"user":"51a4416ae4b0def3c5c5868c"},{"problem":103,"code":"(fn kcombi [n inset]\n    (let [coll (into [] inset)]\n      (cond (> n (count coll)) #{}\n            (< n 1) #{}\n            (= n 1) (into #{} (map hash-set coll))\n            :else (set (map set (mapcat (fn [x]\n                                          (map #(cons (nth coll x)  %)\n                                               (kcombi (dec n) (drop (inc x) coll))))\n                                        (range  (count coll))))))))","user":"4f5e5975e4b0030a34fb2b4d"},{"code":"(fn [n items]\n  (let [powerset (reduce (fn [sets el]\n                           (into sets (map #(conj % el) sets)))\n                         #{#{}}\n                         items)]\n    (into #{} (filter #(= n (count %)) powerset))))","problem":103,"user":"4ffc10aae4b0678c553fc3d6"},{"problem":103,"code":"(fn choose [k s]\n  (cond (< (count s) k) #{}\n        (= (count s) k) #{s}\n        :else (set (mapcat #(choose k (disj s %)) s))))","user":"5f3abcc4e4b004f08c61c52b"},{"code":"(fn [n s]\n    (loop [i n, r (map (comp set vector) s)]\n      (if (zero? i) (set (filter #(= (count %) n) r))\n        (recur (dec i) \n               (mapcat #(map (fn [x] (conj % x)) s) r)))))","problem":103,"user":"4f58d92fe4b0a7574ea71858"},{"problem":103,"code":"(fn k-comb [k coll]\n  (if (= k 1)\n    (set (map (fn [arg] #{arg})\n              coll))\n    (set (mapcat (fn [combination]\n                   (filter (comp (partial = k) count)\n                           (map (partial conj combination)\n                                coll)))\n                 (k-comb (dec k) coll)))))","user":"541709b0e4b01498b1a71a06"},{"code":"(fn kc [n xs]\n\t(let [pwr (fn [b p] (reduce * (take p (repeat b))))\n\t\t\t\txsv (vec xs)\n\t\t\t\tbits (count xs)\n\t\t\t\tlen (pwr 2 bits)\n\t\t\t\tactive (fn [n] (set (map xsv (filter (comp not nil?) (map-indexed #(when (bit-test n %2) %1) (range bits))))))]\n\t(set (filter #(= n (count %)) (map active (range len)))))\n\t)","problem":103,"user":"52ffb7f2e4b0d8b024fd370b"},{"code":"(fn [n s]\n  (set (filter\n        #(= (count %) n)\n        (reduce (fn [res x]\n                  (concat res (map #(conj % x) res)))\n                #{#{}} s))))","problem":103,"user":"518ccf6be4b05e6c8537e386"},{"code":"(fn k-combs\n  [n s]\n  (let [powerset (reduce (fn [p e] (into p (map #(conj % e) p))) #{#{}} s)]\n    (into #{} (filter #(= n (count %)) powerset))))","problem":103,"user":"4dad76588e77d6ed63f12a44"},{"code":"(fn [k coll] (letfn [\n(conj-to-each [colls x] (map #(conj % x) colls))\n(k-combinations [k coll]\n\t(cond\n\t\t(zero? k)\n\t\t#{#{}}\n\t\t(empty? coll)\n\t\t#{}\n\t\t:else\n\t\t(into\n\t\t\t(into #{} (conj-to-each (k-combinations (dec k) (rest coll)) (first coll)))\n\t\t\t(k-combinations k (rest coll))\n\t\t)\n\t)\n)\n] (k-combinations k coll)))","problem":103,"user":"52f10094e4b05e3f0be25ee8"},{"problem":103,"code":"(fn k-combos [n xs]\n  (if (= n (count xs))\n    #{xs}\n    (apply clojure.set/union (map (partial k-combos n) (map #(disj xs %) xs)))))","user":"5283a919e4b0239c8a67adbe"},{"code":"(fn f [n s]\n  (let [ps (fn p [s] (if (= #{} s) #{#{}}\n             (let [res (p (disj s (first s)))]\n               (into res (map #(conj % (first s)) res)))))]\n  (set (filter #(= n (count %)) (ps s)))\n))","problem":103,"user":"4fca1cd6e4b0ee37620e184c"},{"problem":103,"code":"(fn [k coll]\n  (letfn [(cartesian-product [colls]\n            (if (= 1 (count colls)) (map hash-set (first colls))\n                (let [others (cartesian-product (rest colls))]\n                  (mapcat (fn [base-prod] (map #(conj base-prod %) (first colls)))\n                          others))))]\n    (let [base-sets (cartesian-product (take k (repeat coll)))]\n      (apply hash-set (distinct (filter #(= k (count %)) base-sets))))))","user":"5d9c1226e4b0d3f9b434ad51"},{"code":"(fn c [k s]\n  (if (zero? k) #{#{}}\n    (if (> k (count s)) #{}\n      (let [f (first s) \n            r (rest s)\n            small (c (dec k) r)\n            same (c k r)]\n        (into same (map #(conj % f) small))))))","problem":103,"user":"4f03ac2d535dcb61093f6b4a"},{"code":"(fn [n a]\n  (letfn [(rm-one [w]\n                    (map \n                       #(set (concat (take % w) (drop (inc %) w)))\n                       (range (count w))))]\n    (loop [n (- (count a) n) a #{a}]\n      (if (< 0 n)\n        (recur (dec n) (set (mapcat rm-one a)))\n        (if (> 0 n) \n          #{}\n          a)))))","problem":103,"user":"528652fbe4b0239c8a67ae14"},{"code":"(fn [k xs]\n  (letfn [(gensums [len sum]\n            (assert (> len 0))\n            (if (= len 1)\n              [[sum]]\n              (mapcat (fn [v] \n                        (map #(conj % v) (gensums (dec len) (- sum v))))\n                      (range (inc sum)))))\n          (positions [xs k]\n            (let [deltaslist (gensums (inc k) (- (count xs) k))]\n              (map (fn [deltas] \n                     (butlast (map dec (reductions + (map inc deltas)))))\n                   deltaslist)))]\n    (let [xs (into [] xs)]\n      (into #{} (map (fn [ps] (into #{} (map #(nth xs %) ps))) \n                     (positions xs k))))))","problem":103,"user":"51eff839e4b0249c592fbdf1"},{"problem":103,"code":"(fn subsets [m s] (letfn [\n    (inc-range [s mx]\n        (let [size (count s)]\n            (loop [i (dec size)]\n                (if (and (= i 0) (= (first s) (- mx size)))\n                    nil\n                    (if (< (nth s i) (- mx (- size i)))\n                        (vec (concat (take i s) (take (- size i) (iterate inc (inc (nth s i)) )) ))\n                        (recur (dec i))\n                    )\n                )\n            )\n        )\n    )\n    (filter-by-index [coll idxs]\n        (keep-indexed #(when ((set idxs) %1) %2) \n                      coll))\n    ]\n    (let [n (count s)]\n        (if (> m n)\n            #{}\n            (loop [result #{} i (vec (range m))]\n                (if (not i)\n                    result\n                    (recur (conj result (set (filter-by-index s i))) (inc-range i n)))\n            )\n        )\n    )\n))","user":"59a0262ee4b0871e7608b82d"},{"problem":103,"code":"(fn combinations [n coll]\n  (cond \n    (> n (count coll)) #{}\n    (= n (count coll)) #{(set coll)}\n    (= n 1) (set (map #(set [%]) coll))\n    :else\n      (set (concat (map #(conj % (first coll)) (combinations (dec n) (rest coll)))\n              (combinations n (rest coll))))))","user":"57c0917be4b05aa3c4741c95"},{"problem":103,"code":"(fn k-combo\n  ([s] (apply clojure.set/union #{s} (map #(k-combo (disj s %)) s)))\n  ([k s] (set (filter #(= k (count %)) (k-combo s)))))","user":"58ffac9de4b0438e51c2cffd"},{"problem":103,"code":"(fn k[n xs]\n   (if (= n 1)  (reduce #(conj %1 #{%2}) #{} xs)\n       (let [prv  (k (dec n) xs)\n             into-prv (fn [r] (reduce (fn[xs x] (conj xs (conj x r))) #{} prv ))]\n         (set \n          (filter #(= (count %) n)\n                  (reduce (fn [xs x] (into xs (into-prv x))) #{} xs))))))","user":"5d0cf1c8e4b0cc9c91588246"},{"code":"(fn [limite data]\n   (if (= limite 1)\n     (set (map set (partition 1 data)))\n     (let [data-seqs (take-while (complement nil?) (iterate #(next %) (seq data)))]\n       (set (map set\n                 (mapcat (fn [model]\n                           (let [data-iterations (map reverse (reduce (fn [c i] (conj c (apply conj (last c)  [i]))) [[]] (next model)))\n                                 splitea (fn [[a & more] limit]\n                                           (let [[c d] (split-at (dec (dec limit)) more)]\n                                             (map #(cons a (reverse (conj  c %)))  d)))]\n                             (mapcat #(splitea (seq (clojure.set/difference (set  model) %)) limite) data-iterations)\n                             )) data-seqs))))))","problem":103,"user":"50550f43e4b0b1b9d1860eb7"},{"code":"(fn [x coll]\n    (if (> x (count coll))\n      #{}\n      (loop [res #{(into #{} (take x coll))}\n             coll (drop x coll)]\n        (if (empty? coll)\n          res\n          (recur\n           (clojure.set/union res\n                              (into #{}\n                                    (mapcat\n                                     (fn [s]  (map\n                                              (fn [i]\n                                                (conj (disj s i)\n                                                      (first coll)))\n                                              s))\n                                     res)))\n           (rest coll))))))","problem":103,"user":"4f463dfde4b0d56e7bb92b99"},{"code":"(fn k-comb [k aset]\n  (cond (zero? k) #{#{}}\n        (empty? aset) #{}\n        :else (set (mapcat\n          (fn [sel]\n            (let [sels-1 (k-comb (dec k) (disj aset sel))]\n              (map #(conj % sel) sels-1)))\n          aset))))","problem":103,"user":"4eb9ce75535dfed6da9c6d5e"},{"problem":103,"code":"(fn comb [k coll]\n  (if (> k (count coll)) #{}\n    (loop [n 0 s #{#{}}]\n      (if (= n k) s\n        (recur\n          (inc n)\n          (into #{}\n            (filter identity\n              (for [m s\n                    x coll]\n                (if-not (m x) (conj m x)))))\n          )))))","user":"53d78b64e4b0e771c3025466"},{"problem":103,"code":"(fn f [n s] (if (= n 0) #{#{}} (set (for [x s y (f (dec n) (disj s x))] (conj y x)))))","user":"58987ee9e4b00487982d52d2"},{"problem":103,"code":"(fn [n col]\n (set\n  (filter (fn [x] (= n (count x)))\n   (reduce (fn [b x] (into b (map #(conj % x) b))) #{#{}} col))))","user":"5b61aa6ae4b0c6492753e712"},{"problem":103,"code":"(fn k-komb [k s]\n  (if (zero? k)\n    #{#{}}\n    (if (empty? s) \n      #{}\n    \t(set (clojure.set/union \n                 (map #(conj % (first s)) \n                      (k-komb (dec k) (rest s)))\n                 (k-komb k (rest s)))))))","user":"54b54d1be4b05787c3b1639c"},{"problem":103,"code":"(fn [x,y] ( loop [ k x a y res #{#{}} ]\n   ( if (= k 0)\n     (set (filter #(= (count %) x) res))\n     (recur (dec k) a (set (for [ i res j a] (conj i j))))\n     )\n   )\n  )","user":"5b3aa98be4b02d533a91bbca"},{"code":"(fn c [k s]\r\n (cond\r\n  (= k 0) #{#{}}\r\n  (empty? s) #{}\r\n  true (set (concat (c k (rest s))\r\n             (map #(conj % (first s))\r\n              (c (dec k) (rest s)))))))","problem":103,"user":"4eb97b2e535dfed6da9c6d54"},{"problem":103,"code":"(fn k-combinations [n st]\n  (cond (< (count st) n) #{}\n        (= 0 n) #{#{}}\n        (= (count st) n) #{st}\n        :else (let [fst (first st)\n                    rst (set (rest st))\n                    n-1 (dec n)]\n                (into #{} (concat (k-combinations n rst)\n                                  (map #(conj % fst) (k-combinations n-1 rst)))))))","user":"568e1871e4b0dcc4269f40cc"},{"code":"(fn k-combine\n   [k s]\n   (cond\n    (= 1 k) (set(map #(hash-set %) s))\n    (> k (count s)) #{}\n    :else (set (concat\n            (map #(conj % (first s))  (k-combine (dec k) (rest s)))\n            (k-combine k (rest s))))))","problem":103,"user":"4edf5dc6535d10e5ff6f5340"},{"code":"#(set (% %2 [] %3))\n (fn f [n r s]\n   (if (= n (count r))\n     (set r)\n     (flatten (map #(f n (conj r %) (remove (partial = %) s)) s))))","problem":103,"user":"4dad8fe9c9a9d6ed1899dc57"},{"code":"(fn [n s]\n  (let [p (fn [c n s]\n               (cond (zero? n) (assoc c 0 #{})\n                     (= n 1) (assoc c 1 (set (map hash-set s)))\n                     :else (assoc c n\n                                  (reduce into #{} \n                                          (for [i s]\n                                            (map #(conj % i) (c (dec n))))))))]\n       (cond\n        (< (count s) n) #{}\n        (= (count s) n) (hash-set (set s))\n        :else (set (filter #(= (count %) n) \n                 ((reduce #(p % %2 s) {} (range (count s))) n s))))))","problem":103,"user":"4f05ea25535dcb61093f6c02"},{"code":"(fn k [n s]\r\n  (cond\r\n   (> n (count s)) #{}\r\n   (= n (count s)) #{(set s)},\r\n   (= n 0) #{#{}},\r\n   :else (set (concat\r\n               (k n (rest s))\r\n               (map #(set (cons (first s) %)) (k (- n 1) (rest s)))))))","problem":103,"user":"4f62b29ce4b0defedf855fd9"},{"code":"(fn kcomb [m C]\n  (let [ss (fn kc [n S]\n             (if (> (count S) n) (for [x S] (kc n (disj S x))) S))\n        set-vals (range (count C))\n        set-keys (vec C)\n        smap (zipmap set-keys set-vals)\n        rsmap (zipmap set-vals set-keys)]\n    (cond (> m (count C)) #{}\n          (> (count C) m) (set (map set (map #(replace rsmap %) (set (flatten (ss m (set (replace smap C))))))))\n          :else #{C})))","problem":103,"user":"51d96ad0e4b02ceefd94774f"},{"problem":103,"code":"(fn [k s]\n (letfn [\n (kc [k s]\n (cond\n  (= k 1)\n   (map\n    (fn [x] #{x}) \n    s)\n  (empty? s)\n   #{}\n  :else\n   (concat\n    (kc k (rest s))\n    (map\n     #(conj % (first s))\n      (kc (dec k) (rest s))))))]\n (set (kc k s))))","user":"549a999be4b0f3d1d8e70f6f"},{"problem":103,"code":"(fn [n s]\n   (set  (filter #(= n (count %))   (reduce\n                                     (fn [acc nv]\n                                       (concat\n                                        acc\n                                        (map #(conj % nv) acc))\n                                       )\n                                     #{#{}} s)))\n   )","user":"567b2f20e4b05957ce8c61a2"},{"problem":103,"code":"; Uses powerset function from problem 85\n(letfn \n  [(subset [s n]\n    (set\n     (loop [s s, ss (), n n]\n       (if (< n 1) ss\n         (if (not= 0 (rem n 2))\n           (recur (rest s) (conj ss (first s)) (quot n 2))\n           (recur (rest s) ss (quot n 2)))))))\n  \n   (powerset [s]\n    (set\n     (map \n      (partial subset s)\n      (range (Math/pow 2 (count s))))))]\n   \n   (fn [k s]\n     (set\n      (filter #(= k (count %)) (powerset s)))))","user":"53065acbe4b02e8216869792"},{"code":"(fn p103\n  ([i ss] (p103 i #{#{}} ss))\n  ([i s ss]\n     (letfn [(ps [s ss]\n            (if (empty? ss) s\n                 (ps (reduce conj s (for [se s] (conj se (first ss)))) (next ss))))]\n       (apply hash-set (filter #(= i (count %)) (ps s ss))))))","problem":103,"user":"5272669de4b03e8d9a4a742e"},{"problem":103,"code":"(fn combinations--reduce\n  [k coll] {:pre [(integer? k), (not (neg? k))]}\n  (->> (seq (set coll))\n       (reduce (fn [[done acc] x]\n                 (let [new-combs\n                       (->> (for [comb acc] [(conj comb x) comb])\n                            (apply concat)\n                            (group-by count))]\n                   [(concat done (new-combs k))\n                    (->> (dissoc new-combs k)\n                         vals\n                         (apply concat))]))\n               [[] [#{}]])\n       first\n       set))","user":"4fc6305de4b0ee37620e180b"},{"problem":103,"code":"(fn [n s]  \n  (let [c (count s)]\n    (set (for [p (range (Math/pow 2 c))\n               :when (= n (Long/bitCount p))]\n           (set (mapcat #(if (= \\1 %1) [%2]) (format (str \"%\" c \"s\") (Long/toBinaryString p)) s))))))","user":"56baa68ce4b0f26550335947"},{"problem":103,"code":"(fn [n b]\n  (letfn  \n   [\n   (combine [x y] \n    (let [z (into [] y)]  \n     (loop [i 0 result #{}]\n        (println \"X:\" x \"Y[i]\" (get z i) \"Result: \" result )\n        (cond \n           (>= i (count z)) result\n           (not (contains? x (get z i)))   (recur (inc i) (conj result (conj x (get z i)))) \n           :else   (recur (inc i) result) \n         ) \n     )\n    )\n   )\n\n   (combinen [a b]  \n    (let [z (into [] a)]       \n     (loop [i 0 result #{}]\n       (cond\t\n         (>= i (count a)) result\n         :else (recur (inc i) (into result (combine (get z i) b)))     \n       )\n     )\n    )\n   )\n\n   (combinenn [a b c]  \n\t(loop [i c result a]\n          (cond\n            (= i 1) result\n            :else (recur (dec i) (combinen result b))\n          )\n        )  \n   )   \n  ]\n   (let [ a (map (fn [x] #{x})  b)]  \n    (into #{} (combinenn a b n))\n   )\n  )  \n )","user":"56e6e1e6e4b02e7e935eb6cf"},{"code":"(fn [n s]\n   (set (filter #(= (count %) n) (loop [res #{#{}} st s]\n                              (if (empty? st)\n                                res\n                                (recur (->> res (map #(conj % (first st))) (concat res) (set))\n                                       (rest st)))))))","problem":103,"user":"4eb02674535d7eef30807338"},{"code":"#(into #{} (flatten ((fn splitset [n c]\n            (for [e c]\n                 (if (= n (count c)) c (let [rem (disj c e)]\n                      (if (= n (count rem))\n                          rem\n                          (splitset n rem)))))) % %2)))","problem":103,"user":"4dc78527535d8a4b2fd7428f"},{"code":"(fn [sz st]\r\n(letfn [\r\n  (index-combinations\r\n        [n cnt]\r\n        (lazy-seq\r\n         (let [c (vec (cons nil (for [j (range 1 (inc n))] (+ j cnt (- (inc n)))))),\r\n         iter-comb\r\n         (fn iter-comb [c j]\r\n           (if (> j n) nil\r\n               (let [c (assoc c j (dec (c j)))]\r\n           (if (< (c j) j) [c (inc j)]\r\n               (loop [c c, j j]\r\n                 (if (= j 1) [c j]\r\n               (recur (assoc c (dec j) (dec (c j))) (dec j)))))))),\r\n         step\r\n         (fn step [c j]\r\n           (cons (rseq (subvec c 1 (inc n)))\r\n           (lazy-seq (let [next-step (iter-comb c j)]\r\n                 (when next-step (step (next-step 0) (next-step 1)))))))]\r\n           (step c 1))))\r\n  (kcombos [st sz]\r\n     (let [\r\n       inds (index-combinations sz (count st))\r\n       ]\r\n       (set (map set\r\n         (map\r\n      (fn [s] (map (vec st) s)) inds))))) ]\r\n\r\n  (cond (= 1 sz) (set (map (fn [x] (set [x])) st))\r\n     (> sz (count st)) #{}\r\n      (= sz (count st)) #{st}\r\n     :else (kcombos st sz))))","problem":103,"user":"4daa374930acd6ed13482a68"},{"code":"(fn [n s]\n  (let [m (Math/pow 2 (count s))]\n    (loop [i 0 r #{}]\n      (if (< i m)\n        (let [ss (->> (-> i\n                      (Integer/toBinaryString)\n                      reverse\n                      (concat (repeat \\0)))\n                      (interleave s)\n                      (partition 2)\n                      (filter #(= \\1 (second %)))\n                      (map first)\n                      set)]\n          (if (= n (count ss))\n            (recur (inc i) (conj r ss))\n            (recur (inc i) r)))\n        r))))","problem":103,"user":"4ef9c8f9535dced4c769f26b"},{"code":"(fn [k s]\n  (->>\n    (reduce\n      (fn [acc x]\n        (set\n          (for [item s s2 acc] (conj s2 item))))\n      #{#{}}\n      (range k))\n    (filter (fn [st] (= (count st) k)))\n    set))","problem":103,"user":"4f725466e4b07046d9f4f030"},{"code":"(fn [n s] \n  (letfn [(p [s] (reduce (fn [p e] (into p (map #(conj % e) p))) #{#{}} s))]\n    (set (filter #(= n (count %)) (p s)))))","problem":103,"user":"4ee9ddb8535d93acb0a66896"},{"problem":103,"code":"; adapt solution to generate power sets\n(fn [n coll] \n  (set (filter #(= (count %) n) \n          (reduce (fn [a x] \n                    (->> (map #(set (concat #{x} %)) a) \n                         (concat a) set)) \n          #{#{}} coll))))","user":"5566d812e4b0c656e3ff1837"},{"code":"(fn comb [n xs]\n  (if (zero? n)\n    #{#{}}\n    (let [splitted (map #(vector % (disj xs %)) xs)]\n      (into #{} (mapcat\n        (fn [[el rst]]\n          (let [ks (comb (dec n) rst)]\n            (into #{} (map #(conj % el) ks))))\n        splitted)))))","problem":103,"user":"500933a6e4b046cdb195e074"},{"code":"(letfn [(f [n s]\n  (cond\n    (= 0 n) #{#{}}\n    (= s []) #{}\n    1 (into (f n (rest s))\n            (map #(conj % (first s)) (f (- n 1) (rest s))))))]\n  f)","problem":103,"user":"4e5411e8535d8a8b8723a279"},{"code":"(fn [k s]\n  (loop [l k\n         r (set (map #(set [%]) s))]\n    (if (= 1 l) r\n        (recur (dec l)\n               (set (filter #(= (- k l -2) (count %))\n                            (for [rx r sx s]\n                              (conj rx sx))))))))","problem":103,"user":"4e71705e535d5021c1a89649"},{"code":"(fn [k s]\n  (if (> k (count s)) #{}\n    (loop [k (dec k) r (map vector s)]\n      (if (zero? k) (set (map set r))\n        (recur (dec k)\n          (mapcat\n            #(for [x (apply disj s %)] (conj % x))\n            r))))))","problem":103,"user":"4f06dcad535dcb61093f6c16"},{"code":"(fn k-combinations [size elems]\r\n  (letfn [(powerset [s]\r\n            (let [union clojure.set/union]\r\n              (if (empty? s) \r\n                #{#{}}\r\n                (union \r\n                  (powerset (next s))\r\n                  (map #(conj % (first s)) (powerset (next s)))))))]\r\n  (set (filter #(= size (count %))  (powerset elems)))))","problem":103,"user":"4e6defcc535d5021c1a895f8"},{"problem":103,"code":"(fn [k src]\n    (let [from (into [] src)\n          extract (fn [bits]\n                    (reduce conj #{}\n                            (map #(get from %)\n                                 (filter #(bit-test bits %)\n                                         (range (count from))))))\n          log2 (fn [num]\n                 (inc (loop [x 1]\n                        (let [t (bit-shift-left 1 x)\n                              bigger (>= t num)]\n                          (if bigger\n                            x\n                            (recur (inc x)))))))\n          bitcount (fn [num]\n                     (count (filter #(bit-test num %) (range (log2 num)))))]\n      (into #{}\n            (map extract \n                 (filter #(= k (bitcount %))\n                         (range 1 (bit-shift-left 1 (count from))))))))","user":"554a75c9e4b0a04f79299575"},{"code":"(fn [k s]\n  (set (filter #(= k (count %)) (reduce #(concat %1 (map (fn [i] (set (conj i %2))) %1)) #{#{}} s))))","problem":103,"user":"514d7e29e4b019235f6c0587"},{"problem":103,"code":"(letfn [                                                                                                                                                \n    (count-bits [n] (loop [c 0 v n] (if (zero? v) c (recur (inc c) (bit-and v (- v 1))))))                                      \n    (which-bits [n]                                                                                                                                     \n        (loop [n' n bits [] i 0]                                                                                                \n            (if (zero? n')                                                                                                                              \n                bits                                                                                                            \n                (recur                                                                                                                                  \n                    (bit-shift-right n' 1)                                                                                      \n                    (if (= 1 (bit-and n' 1)) (conj bits i) bits)                                                                                        \n                    (inc i)))))                                                                                                 \n    (gen-k-combinations [k s]                                                                                                                           \n        (if (> k (count s))                                                                                                     \n            #{}                                                                                                                                         \n            (let [s' (seq s)                                                                                                    \n                combinations  (                                                                                                                         \n                    ->> (range (bit-shift-left 1 (count s')))    ; get all numbers from 0 to 2^(count s)                        \n                        (filter #(= k (count-bits %)))           ; filter in those numbers with k bits set                                              \n                        (map which-bits)                         ; figure out which bits are high                               \n                        (map (fn [comb] (map #(nth s' %) comb))) ; pick those combinations of elements out of s                                         \n                        (map set))]                              ; turn them into sets                                          \n                (set combinations))))]                                                                                                                  \n        gen-k-combinations                                                                                                      \n)","user":"558b50d5e4b027778923762b"},{"code":"(fn [n s] \n    (letfn [(zzz [n s]\n                 (println n s)\n                 (cond \n                   (= 1 n) (map #(conj #{} %) s)\n                   (seq s) (let [[f & r] s]\n                             (concat\n                               (map (fn [x] (conj x f)) (zzz (dec n) r))\n                               (if (> n (count r)) [] (zzz n r))\n                               ))\n                   :else nil))]\n           (into #{} (zzz n (seq s)))))","problem":103,"user":"4dca8b6d535d5973398f9288"},{"problem":103,"code":"(fn k-combination [k coll]\n  (if (= 1 k)\n    (into #{} (for [x coll] #{x}))\n    ;; Otherwise, generate sets recursively by adding all the items\n    ;; still in coll to the k-1-combinations left over.\n    (into #{} (for [x coll\n                    comb (k-combination (dec k) (disj coll x))]\n\t\t(conj comb x)))))","user":"5bfa25fbe4b0bdcf453d15c8"},{"problem":103,"code":"(fn kcombin [n xs]\n   (cond\n    (> n (count xs)) #{}\n    (= n 0) #{}\n    (= n 1) (set (map hash-set xs))\n    :default\n    (loop [ts xs zs #{}]\n      (if (empty? ts)\n        (set zs)\n        (recur (rest ts) (clojure.set/union zs (filter #(= n (count %)) (map #(conj % (first ts)) (kcombin (dec n) xs)))))\n     \n       )))\n   )","user":"53ca23e3e4b00fb29b2212c6"},{"problem":103,"code":"(fn __\n  ([c n] (let [\n               res (__ c n 1)\n               ]\n           (if (set? res) #{res} (set res))))\n  ([c n jed] (if (= c (count n))\n               n\n               (flatten (map (fn [x] (__ c (disj n x) 1) ) n)) ))\n  )","user":"58bc6a88e4b0888cdc949d16"},{"code":"(fn [n s] (let [comb (fn k-combinations [k coll] \n  (if (= 1 k)\t\n\t (map hash-set coll)\n\t  (loop [f (first coll) r (next coll)\n\t\t  conj-ed (apply hash-set (map #(into #{f} %) (k-combinations (dec k) r) ))] \n\t\t  \n\t\t (if (seq r)\n\t\t\t(recur (first r) \n\t\t\t\t  (next r) \n\t\t\t\t  (into conj-ed (map #(into #{(first r)} %) (k-combinations (dec k) (next r)) ) ))\n\t\t\t conj-ed))))] (apply hash-set (comb n s))))","problem":103,"user":"523a9fc9e4b081681ca7adca"},{"problem":103,"code":"(fn\n  [n c]\n  (set (filter #(= n (count %))\n          (reduce (fn [a x]\n                    (set (concat a (map #(set (concat #{x} %)) a))))\n                  #{#{}} c))))","user":"5893c64ce4b00487982d524b"},{"problem":103,"code":"(fn k-combinations [k s]\n  (if (> k (count s))\n    #{}\n    (if (= k 1)\n      (into #{} (map hash-set s))\n      (let [[h & t] (seq s)]\n        (into \n         #{}\n         (concat\n          (k-combinations k t)\n          (map \n           #(into % (list h)) \n           (k-combinations (dec k) t))))))))","user":"5654e024e4b0f9d632dd848d"},{"problem":103,"code":"(fn k-comb [n a-set]\n    (letfn [(powerset-helper [current leftovers]\n              (if (empty? leftovers)\n                (set current)\n                (let [elem (first leftovers)]\n                  (powerset-helper (concat current\n                                           (map (fn [x] (conj x elem)) current))\n                                   (rest leftovers)))))]\n          (set (filter #(= n (count %)) (powerset-helper #{#{}} a-set)))))","user":"540e8d13e4b0addc1aec671e"},{"problem":103,"code":"(fn [k c]\n  (letfn [(komb [k coll]\n          (if (= 1 k) (map list coll)\n            (loop [c coll acc ()]\n              (if (< (count c) k) acc\n                (recur (rest c) (concat acc (map #(concat (list (first c)) %) (komb (dec k) (rest c)))))))))]\n    (into #{} (map #(into #{} %) (komb k c)))))","user":"560843dee4b046a4fc0ac00e"},{"code":"(fn kc [n s]\n  (let [[s xs] (split-at n s) n (range n)] \n    (if (= (count s) (count n))  \n    (loop [s [(vec s)] [x & xs] xs] \n      (if x (recur (concat s (mapcat (fn [s](map #(assoc s % x) n)) s )) xs) (set (map set s))))#{})))","problem":103,"user":"51b793d3e4b0d906fcd71d38"},{"problem":103,"code":"(fn ThisFunc [K S]\n    (if (zero? K)\n      #{}\n      (loop\n        [ Ret #{}\n          First (first S)\n          Rest (rest S)\n        ]\n        ;;(println K First Rest)\n        (if (or (> (dec K) (count Rest)) (nil? First))\n          Ret\n          (recur\n            (clojure.set/union\n              Ret\n              (if (= K 1)\n                #{ #{First} }\n                (into #{}\n                  (for [X (ThisFunc (dec K) Rest)]\n                    (clojure.set/union #{First} X)\n                  )\n                )\n              )\n            )\n            (first Rest)\n            (rest Rest)\n          )\n        )\n      )\n    )\n  )","user":"5d4a6c6ce4b0776584bd6f22"},{"problem":103,"code":"(fn [k s]\n\t(set (filter\n\t\t\t#(= k (count %))\n\t\t\t(reduce\n\t\t\t\t(fn [subsets elem]\n\t\t\t\t\t(into subsets\n\t\t\t\t\t\t(for [x subsets]\n\t\t\t\t\t\t\t(conj x elem))))\n\t\t\t\t#{#{}}\n\t\t\t\ts))))","user":"5472d919e4b094393f72dd7b"},{"problem":103,"code":"(fn [n coll]\n      (->> (range n)\n         (reduce\n          (fn [cmb i]\n            (->> cmb\n                 (mapcat (fn [[left selected]]\n                           (map (fn [x] [(disj left x) (conj selected x)]) left)))\n                 set))\n          [[(set coll) #{}]]\n          )\n         (map second)\n         set))","user":"58ca8a1de4b03c36ff7e5835"},{"problem":103,"code":"(fn f\n    [k S]\n    (set\n      (if (= k 0)\n        [#{}]\n        (for [s (f (- k 1) S)\n              e S\n              :when (= k (count (conj s e)))]\n          (conj s e)))))","user":"51a10b2ce4b0b292b01ee3fe"},{"code":"(letfn [(powerset [s]\n           (if (empty? s)\n             #{#{}}\n             (clojure.set/union (powerset (next s))\n                                (map #(conj % (first s))\n                                     (powerset (next s))))))\n        (k-comb [n s]\n          (set (filter #(#{n} (count %)) (powerset s))))]\n  k-comb)","problem":103,"user":"51f9527fe4b09be9c177e549"},{"problem":103,"code":"(fn [n coll]\n    (letfn [(get-combos [combos nums]\n              (when (not-empty nums)\n                (let [head (first nums)\n                      tail (rest nums)]\n                  (cons [(conj combos head) (set tail)]\n                        (get-combos combos (set tail))))))]\n      (let [combo-pairs (iterate (fn [pairs] (mapcat #(apply get-combos %) pairs))\n                                 (get-combos #{} coll))]\n        (set (map first\n                  (->> combo-pairs\n                       (take n)\n                       last))))))","user":"5ac6ef9be4b0e27600da7779"},{"code":"(fn kcombinations [k S]\n  (cond (> k (count S)) #{} (= k 0) #{#{}} \n        :else (set (for [comb (kcombinations (dec k) S) x S :when (not (contains? comb x))] (conj comb x)) ) )\n)","problem":103,"user":"51729002e4b044b2ef48a850"},{"problem":103,"code":"(fn combination [n xs]\n             (if (> n (count xs))\n               #{}\n               (if (= n 1)\n                 (set (map #(-> #{%}) xs))\n                 (if (= n (count xs))\n                   #{xs}\n                   (let [previous (combination (dec n) xs)]\n                     (set (mapcat\n                           (fn [c] (let [others (filter #(not (contains? % c)) previous)]\n                                     (set (map #(set (cons c %)) others))))\n                           xs)))))))","user":"57b9fb56e4b0fbc9809a27fa"},{"code":"(fn [x y]\n  (let [padd (clojure.string/join (count y) [\"%0\" \"d\"])\n        bins (map #(Integer/toBinaryString %) (take (reduce * (take (count y) (repeat 2))) (range)))\n        pad-bins (map #(format padd %) (map #(Integer/parseInt %) bins))\n        filt (filter #(= (count ((group-by identity %) \\1)) x) pad-bins)]\n    (into #{} (map #(into #{} %)\n      (map #(filter (fn [b] (not (nil? b))) %) \n        (for [a filt]\n          (map #(if (= %1 \\1) %2) a (into [] y))))))))","problem":103,"user":"52016690e4b0b2e020a18f0f"},{"problem":103,"code":"(fn [j ss]\n  (letfn [(kc [zs k z]\n            (apply conj (zs k) (map #(conj % z) (zs (dec k)))))\n          (combos [xs x]\n            (if (empty? xs)\n              (vector [#{x}])\n              (let [ys (vector (conj (xs 0) #{x}))\n                    n  (count xs)]\n                (loop [out ys i 1]\n                  (if (= i n)\n                    (conj out (vector (conj ((xs (dec i)) 0) x)))\n                    (recur (conj out (kc xs i x)) (inc i)))))))]\n     (if (> j (count ss))\n       #{}\n       (set ((reduce combos [] ss) (dec j))))))","user":"564a5a09e4b0284900eef656"},{"problem":103,"code":"(fn k-combinations [n coll]\n  (cond\n    (> n (count coll)) #{}\n    (= n 1) (into #{}  (map #(set [%]) coll))\n    :else (into #{} (mapcat (fn [x]\n                              (map #(conj % x) (k-combinations (dec n) (disj coll x))))\n                            coll))))","user":"5102ac9de4b00c483ae176fa"},{"problem":103,"code":"(fn k-comb\n  [n x]\n  (into #{} (filter #(= n (count %)) (reduce (fn [agg e] (clojure.set/union agg (map #(conj % e) agg))) #{#{}} x))))","user":"57ea2c91e4b0bfb2137f5b42"},{"problem":103,"code":"(fn [n s]\n            (letfn [(ps [s]\n                        (if (empty? s)\n                          #{#{}}\n                          (let [ps-of-rest (ps (rest s))\n                                ps-with-missing (apply hash-set (map #(set (cons (first s) %)) ps-of-rest))]\n                            (clojure.set/union ps-of-rest ps-with-missing))))]\n              (set (filter #(= n (count %)) (seq (ps s))))))","user":"53f891eee4b0de5c4184856d"},{"problem":103,"code":"(fn f [n col]\n  (->>\n   ((fn f' [acc n col]\n      (let [i (first col), r (rest col)]\n        (if (or (nil? i) (zero? n)) ; n==0\n          acc                                                          \n          (clojure.set/union (f' (map #(conj (set %) i) acc) (dec n) r)\n                             (f' acc n r)))))\n    #{#{}} n col)\n   (filter #(= n (count %)))\n   (set)))","user":"569dd6e8e4b0542e1f8d1480"},{"problem":103,"code":"(fn combinations [k s]\n                      (cond\n                        (zero? k) #{#{}}\n                        (> k (count s)) #{}\n                        (empty? s) #{}\n                        :else (set (clojure.set/union\n                                    (map #(conj % (first s)) (combinations (dec k) (rest s)))\n                                    (combinations k (rest s))))))","user":"5cf895efe4b0b71b1d808a85"},{"code":"(fn k-combo \n  ([n acc coll]\n    (when (not-empty coll)\n      (let [n (dec n)\n            tails #(take-while not-empty (iterate rest %))\n            cs (for [[x & xs] (tails coll)] [n (cons x acc) xs])]    \n        (if (zero? n) (map (fn [[_ acc _]] acc) cs)\n          (mapcat #(apply k-combo %) cs)))))\n  ([n coll]\n    (set (map set (k-combo n '() (vec coll))))))","problem":103,"user":"51cdd3f0e4b0e42293a2254b"},{"problem":103,"code":"(fn[n opts]\n  (nth (iterate\n        #(into #{} (for [s % o opts :when (not (s o))] (conj s o)))\n        #{#{}}) n))","user":"57b3efb1e4b0fbc9809a278a"},{"code":"(fn kc [k S]\n  (if (> k (count S)) #{}\n      (letfn [(ones [s] (count (filter #(= \\1 %) s)))]\n        (let [nums (filter #(= k (ones %))\n                           (map #(Integer/toString % 2)\n                                (range (Math/pow 2 (count S)))))\n              nums2 (for [n nums]\n                      (str (apply str\n                                  (repeat (- (count S) (count n))\n                                          \\0)) n))\n              plc (map (fn [x] (map first\n                                    (filter #(= (second %) \\1)\n                                            (map-indexed vector x))))\n                       nums2)]\n          (set (map (fn [p] (set (for [x p] (nth (seq S) x)))) plc))\n          )\n        )\n      )\n  )","problem":103,"user":"500cb910e4b05f7c30cfa698"},{"problem":103,"code":"(fn [n s]\n  (if (> n (count s))\n    #{}\n    (let [perm (fn [s]\n      (let [helper (fn helper [curr left]\n        (if (empty? left)\n          [curr]\n          (mapcat (fn [e] (helper (cons e curr) (remove #(= e %) left))) left)))]\n        (helper '() s)))]\n      (set (map #(set (take n %)) (perm s))))))","user":"536046a9e4b063bf7a5f8fe1"},{"problem":103,"code":"(fn choose [k s]\n  (cond (< (count s) k) #{}\n        (= (count s) k) #{s}\n        :else (set (apply concat (map #(choose k (disj s %)) s)))))","user":"53acaf1fe4b047364c04445f"},{"problem":103,"code":"(fn [n xs]\n     (->> \n       (map #(set [%]) xs)\n       (iterate (fn [prevs] \n                  (into #{} (for [prev prevs\n                                 x xs] (conj prev x)))))\n       (#(nth % n))\n       (filter #(= n (count %)))\n       (into #{})))","user":"53c38b8ce4b00fb29b22127b"},{"code":"(fn kcomb [n s]\n  (letfn [(pset [s] \n    (if (empty? s) \n      #{#{}}\n      (let [p (pset (set (rest s)))]\n        (clojure.set/union \n          p\n          (map #(conj % (first s)) p)))))]\n  (let [res (set (filter #(= (count %) n) (pset s)))]\n    (if (empty? res)\n      #{}\n      res))))","problem":103,"user":"4e9c81e8535dbda64a6f6b80"},{"problem":103,"code":"(fn k-combinations [n s]\n  (cond\n    (or (= n 0) (> n (count s))) #{}\n    (= n 1) (set (map #(set [%]) s))\n    :else (let [xs (seq s)\n                x (first xs)\n                r (rest xs)]\n            (clojure.set/union (k-combinations n r) (set (map #(conj % x) (k-combinations (dec n) r)))))))","user":"59f78b49e4b0ca45a743a30e"},{"problem":103,"code":"(fn kc [k coll]\n  (letfn [(power-set [coll] \n            (if (empty? coll) \n              #{#{}}\n              (let [e (first coll),\n                    pt (power-set (remove (partial = e) (set coll)))] \n                (set (lazy-cat pt (map #(conj % e) pt))))))]\n    (set ((group-by count (power-set coll)) k))))","user":"53fcdd1ae4b0de5c418485dd"},{"code":"(fn [k s]\n     (let [n (count s)]\n       (if (> k n) #{}\n         (let [a (vec s) b (vec (range k))]\n           (letfn [(next_combination [b]\n             (let [b (vec b) [found i] (loop [i (- k 1) found false]\n               (if (and (>= i 0) (not found))\n                 (recur (dec i) (<= (b i) (+ n i (- k) (- 1))))\n                 [found i]))]\n               (if-not found nil\n                 (let [ii (inc i) t (b ii)]\n                   (concat (subvec b 0 ii) (range (inc t) (+ t k (- i))))))))]\n             (set (map (fn [s] (set (map #(a %) s))) (take-while identity (iterate next_combination b)))))))))","problem":103,"user":"4e8b98fc535d65386fec2124"},{"code":"(fn [n s]\n  (let [f (fn f [s]\n            (if (empty? s)\n              #{#{}}\n              (set (concat (map #(conj % (first s)) (f (next s))) (f (next s))))))\n        ]\n    (set (filter #(= n (count %)) (f s)))\n    ))","problem":103,"user":"5349ac2be4b084c2834f4a67"},{"problem":103,"code":"(fn k-combo\n  ([n s]\n   (k-combo n s []))\n  ([n s pre]\n   (letfn [(parts [n s]\n             (for [i (range (inc (- (count s) n)))]\n               (drop i s)))]\n     (cond (zero? n) pre\n           (= 1 n) (set (map #(set (conj pre %)) s))\n           :else\n           (->> (parts n s)\n                (reduce #(concat %1 (k-combo (dec n) (rest %2) (conj pre (first %2)))) [])\n                (map set)\n                (set))))))","user":"5eb1c786e4b00a66d4a95201"},{"problem":103,"code":"(letfn [(update [m k f]\n          (assoc m k (f (m k))))\n        (roll [v i x]\n          (reduce (fn [v [x' i]]\n                    (assoc v i (+ x x')))\n                  v (map-indexed vector (range i (count v)))))\n        (next-kc [kc n]\n          (let [padded (conj kc n)]\n            (loop [i (dec (count kc))]\n              (when (>= i 0)\n                (if (< (padded i) (dec (padded (inc i))))\n                  (roll (update kc i inc) i (inc (kc i)))\n                  (recur (dec i)))))))\n        (kseqs [kc n]\n          (when kc\n            (cons kc (lazy-seq (kseqs (next-kc kc n) n)))))]\n  (fn [k S]\n    (let [v (vec S)\n          n (count v)]\n      (if (> k n)\n        #{}\n        (set (for [kc (kseqs (vec (range k)) n)]\n               (->> kc\n                    (map v)\n                    (set))))))))","user":"59eb63e3e4b0249b7282077c"},{"problem":103,"code":"(fn [n coll]\n   (set (filter #(= n (count %)) (reduce #(apply conj %1\n                                             (for [v %1]\n                                               (conj v %2))) #{#{}} coll))))","user":"55a372f1e4b0acc240e31537"},{"problem":103,"code":"(fn combi [n setan]\n  (if (or (empty? setan)\n          (> n (count setan)))\n    #{}\n    (let [cont1 (into #{} (map #(into #{} [%]) setan))\n          join (fn [starget s]\n                 (into #{} (map #(clojure.set/union starget %) s)))]\n      (loop [i 1 res cont1]\n        (if (= n i)\n          (into #{} (filter #(= n (count %)) res))\n          (recur (inc i)\n                 (into #{}\n                       (mapcat #(join % cont1) res))))))))","user":"54b7f217e4b0ed20f4ff6e8f"},{"problem":103,"code":"(fn k-comb [k s]  \n  (letfn [(power-set [s]\n            (if (seq s)\n              (let [ps (power-set (set (rest s)))]\n                (clojure.set/union ps (map #(conj % (first s)) ps)))\n              #{#{}}))]\n    (set (filter #(= k (count %)) (power-set s)))))","user":"60b7e2c5e4b0e0fa5f1b4252"},{"problem":103,"code":"(fn [lenght set]\n  (letfn [(comb [k l]\n            (if (= 1 k) (map vector l)\n                (apply concat\n                       (map-indexed\n                        #(map (fn [x] (conj x %2))\n                              (comb (dec k) (drop (inc %1) l)))\n                        l))))\n          (subsets [s]\n            (apply concat\n                   (for [x (range 1 (inc (count s)))]\n                     (map #(into #{} %) (comb x s)))))\n          (take-lenght [l m]\n            (filter #(= l (count %)) m))]\n    (into #{} (take-lenght lenght (subsets set)))))","user":"55b22c33e4b0da326a65cf79"},{"problem":103,"code":"(fn kc [k s]\n  (cond\n   (zero? k) #{#{}}\n   (empty? s) #{}\n   :else (let [s1 (first s) rs (disj s s1)]\n           (clojure.set/union\n            (kc k rs)\n            (set (map #(conj % s1) (kc (dec k) rs)))))))","user":"52ce1abfe4b07d0d72b27389"},{"code":"(fn f\n  ([k src] (if (< (count src) k) #{} (f k src #{#{}})))\n  ([k src acc]\n    (if (= k 0)\n      acc\n      (recur (dec k) src (into #{} (for [a acc s src :when (not (contains? a s))] (conj a s)))))))","problem":103,"user":"4ec07699535dfed6da9c6da2"},{"problem":103,"code":"(fn k-combinations\n  [n s]\n  (letfn [(powerset [s]\n            (apply clojure.set/union\n                   #{s}\n                   (map #(powerset (disj s %)) s)))]\n    (set (filter #(= n (count %)) (powerset s)))))","user":"561a1af6e4b053970a773b02"},{"problem":103,"code":"(fn k-combinations [k s]\n  (let [power-set (fn [s]\n                    (reduce (fn [s v] (concat s (map #(conj % v) s))) [#{}] s))]\n    (set (filter #(= (count %) k) (power-set s)))))","user":"52d00832e4b07d0d72b273b4"},{"problem":103,"code":"(fn [n s]\n  (let [p (fn powerset [s] \n            (if (empty? s)\n              '(())\n              (concat (powerset (rest s))\n                                 (map #(conj % (first s)) (powerset (rest s))))))]\n    (set (filter #(= n (count %)) (map set(p s))))))","user":"59368ccae4b02506e01a297a"},{"problem":103,"code":"(fn combinations [k coll]\n  (let [increasing-ranges (fn increasing-ranges [n k]\n                            (if (= 1 k)\n                              (map list (range n))\n                              (apply concat \n                                (map (fn [i] \n                                       (map (comp (partial cons i) \n                                                  (partial map (partial + i 1))) \n                                            (increasing-ranges (- n i 1) (dec k)))) \n                                     (range n)))))\n        projections (fn [coll n]\n                      (map (partial map (partial nth coll)) \n                           (increasing-ranges (count coll) n)))]\n    (->> k\n         (projections (seq coll))\n         (map set)\n         set)))","user":"5c506951e4b0f9f7a8770ec5"},{"code":"(fn f [n s]\n   (if (= 1 n)\n     (set (map #(hash-set %) s))\n     (let [r (f (dec n) s)]\n       (set\n         (mapcat (fn [e]\n                   (map #(conj % e) (remove #(contains? % e) r))) s)))))","problem":103,"user":"4fa30027e4b081705acca187"},{"problem":103,"code":"(fn [k s]\n  (into #{}\n        (remove nil?\n                ((fn k-comb\n                   [result rst]\n                   (cond (and (empty? rst) (= (count result) k)) (list (set result))\n                         (empty? rst) (list nil)\n                         :else (concat (k-comb (conj result (first rst)) (rest rst))\n                                       (k-comb result (rest rst))))) [] s))))","user":"58f98231e4b0438e51c2cf4c"},{"code":"(fn k-comb [k items]\n    (let [items (vec items)\n          num-items (count items)\n          generate\n            (fn generate [k fst res]\n                (if (zero? k)\n                    (list res)\n                    (mapcat #(generate (dec k) (inc %) (conj res (items %))) (range fst num-items))\n                ))\n        ]\n        (set (generate k 0 #{}))\n    ))","problem":103,"user":"4df3d4f4535d08e6dec9fe2c"},{"code":"(fn [n s]\n  (set\n  \t(filter #(= (count %) n)\n            (nth\n             (iterate (fn [x]\n                        (set (mapcat (fn [e] (map #(conj % e) x)) s)))\n                      #{#{}})\n             n))))","problem":103,"user":"50acbd15e4b071b89ef26234"},{"problem":103,"code":"(fn kcomb [k s]\n  (let [h (first s)\n        t (set (rest s))]\n    (cond\n      (zero? k) #{#{}}\n      (= k (count s)) #{s}\n      (> k (count s)) #{}\n      :else\n        (do\n          (clojure.set/union\n                  (kcomb k t)\n                  (set (map #(conj % h) (kcomb (dec k) t)))\n                  )))))","user":"53f7820be4b0de5c41848560"},{"problem":103,"code":"#(nth (iterate (fn [t] (set (remove nil? (for [s t x %2] (if (s x) nil (conj s x))))))\n               [#{}]) %)","user":"53a01fb1e4b0ca733b9744a6"},{"problem":103,"code":"(fn k-comb\n  [n xs]\n  (cond\n    (zero? n) #{#{}}\n    (empty? xs) #{}\n    :else (->> xs\n               (mapcat\n                 (fn [x] (map #(conj % x) (k-comb (dec n) (disj xs x)))))\n               set)))","user":"5d0bb4fae4b0cc9c91588237"},{"problem":103,"code":"(fn [n nn](letfn [(powerset [ls]\n  (if (empty? ls) #{#{}}\n      (clojure.set/union (powerset (next ls))\n        (map #(conj % (first ls)) (powerset (next ls))))))]\n         (into #{}(filter #(= n (count %)) (powerset nn)))))","user":"5c0e3f86e4b01240ff56713d"},{"code":"(fn [k src]\n   (let [cnt (count src) fin (range (- cnt k) cnt)]\n     (if (> k cnt) #{}\n     (letfn [(make-set [ind] (set (map #(get (vec src) %) ind)))\n             (next-ind [ind] (loop [x ind m (dec cnt) ln 1]\n                               (if (< (last x) m) (vec(concat (butlast x) (range (inc (last x)) (+(inc (last x)) ln)))) \n                                 (recur (butlast x) (dec m) (inc ln) )\n                                 )\n                               ))\n             ]\n       (loop [y (vec(range k)) z '()]\n          (if (= y fin) (set(conj z (make-set y)))\n          \t(recur (next-ind y) (conj z (make-set y))) \n           )\n         )\n     )\n   ))\n )","problem":103,"user":"5274eb56e4b03e8d9a4a74bb"},{"code":"(fn [n s] \n  (let [setcomb (fn [n, s, e] (set (remove #(> (count %) n) (into s (map #(conj % e) s)))))]\n  (->> (reduce (partial setcomb n) (set (map #(set [%]) s)) s) (remove #(< (count %) n)) set)))","problem":103,"user":"528e64b7e4b0239c8a67aedd"},{"problem":103,"code":"(fn k-combinations [k coll]\n  (cond (> k (count coll)) #{}\n        (= 0 k) #{#{}}\n        :else (set (concat (map (fn [comb]\n                                  (conj comb (first coll)))\n                                (k-combinations (dec k) (rest coll)))\n                           (k-combinations k (rest coll))))))","user":"60460824e4b02d28681c77bc"},{"code":"(fn multi-type-combo [k s]\n  (let [combo-fn (fn combo [k s]\n                   (if (> k (count s))\n                     #{}\n                     (if (zero? k)\n                       #{#{}}\n                       (into #{} (apply concat\n                                        (for [i (range 0 (inc (- (count s) k)))]\n                                          (map #(conj % (nth (sort s) i)) (combo (dec k) (drop (inc i) (sort s))))))))))\n        combos (combo-fn k (range (count s)))]\n    (into #{} (map (fn [c] (into #{} (map #(nth (seq s) %) c))) combos))))","problem":103,"user":"51281b25e4b03a34742b4304"},{"problem":103,"code":"(fn k-combinations\n  [k coll]\n  (cond (> k (count coll)) #{}\n        (= k 1) (set (map set (partition 1 coll)))\n        :else\n        (let [a (first coll) remaining (rest coll)]\n          (into (set (map #(conj % a) (k-combinations (dec k) remaining)))\n                (k-combinations k remaining)))))","user":"536e5055e4b0fc7073fd6e6b"},{"code":"(fn kcomb [n s]\n  (if (= n 0) #{#{}}\n      (if (< (count s) n) #{}\n          (if (= (count s) n) #{(set s)}\n              (let [s1 (set (map #(conj % (first s)) (kcomb (dec n) (rest s))))\n                    s2 (kcomb n (rest s))]\n                (set (concat s1 s2)))))))","problem":103,"user":"4dc1ee85535d020aff1edf91"},{"problem":103,"code":"(fn k-comb [n input-v]\n  (set (filter\n        #(= (count %) n)\n        (loop [result (map #(hash-set %) input-v) n n]\n          (if (= 1 n)\n            result\n            (recur (mapcat\n                    (fn [x]\n                      (map #(conj x %) input-v))\n\n                    result)\n                   (dec n)))))))","user":"585dbe41e4b0f14aab7c879f"},{"code":"(fn kcomb [n s]\n  (if (zero? n)\n      #{#{}}\n      (set (flatten (for [ x s\n             \t\t\t   :let [newset (disj s x)\n                   \t\t\t\t subsets (kcomb (dec n) newset)] ]\n        \t\t\t(map #(conj % x) subsets))))))","problem":103,"user":"53691dc7e4b0243289761e97"},{"problem":103,"code":"(fn kcomb [k S]\n  (let [S (seq S)\n        max-n (reduce * (repeat (count S) 2 )) ]\n    (loop [n 0 rv #{} ]\n      (let [bit-count (apply + (map #(if (bit-test n %) 1 0) (range (count S)))) ]\n        (print n bit-count \"\\n\")\n      (cond\n        (> n max-n) rv\n        (not= bit-count k) (recur (inc n) rv)\n        :else\n          (recur (inc n) (conj rv (into #{} (map (partial nth S) (filter (partial bit-test n) (range (count S))))))))))))","user":"55934bebe4b0c79f6e1db93b"},{"code":"(fn [k c]\n  (letfn [(f [n s] (if (> n (count s))\n                      #{}\n                      (if (= 1 n)\n                        (map #(set (vector %)) s)\n                        (map #(into (set (vector (first s))) %) (f (dec n) (rest s))))))]\n    (set (reduce into\n      (loop [r #{} s c]\n        (if (empty? s)\n          r\n          (recur (into r \n                       (for [i (range 1 (count s))]\n                         (f k (cons (first s) (drop i s)))))\n                 (rest s))))))))","problem":103,"user":"4e49badd535dc968683fc4c9"},{"code":"(fn [n s]\n  (let [m (into {} (map-indexed hash-map s))\n        s (->> (repeatedly #(shuffle (keys m))) (take 1000) flatten\n               (partition n 1) (map set) (filter #(= (count %) n)) set)\n        f (fn [s] (map #(m %) s))]\n    (->> (map f s) (map set) set)))","problem":103,"user":"5300158ae4b0d8b024fd370f"},{"problem":103,"code":"(fn comb [n s]\n   (loop [n n r (map #(-> #{%}) s)]\n     (if (= 1 n)\n       (set r)\n       (recur (dec n)\n              (for [c (set r)\n                    e (reduce disj s c)]\n                (conj c e))))))","user":"55dcb06ee4b050e68259b3b9"},{"problem":103,"code":"(fn [n coll]\n  (letfn [(subset [coll]\n            (reduce (fn [a x]\n                      (into #{} (concat a (map #(conj % x) a)))) #{#{}} coll))]\n    (into #{} (filter (fn [x] (= n (count x))) (subset coll)))))","user":"606a70a5e4b069485764ddf2"},{"problem":103,"code":"(fn [n sc] (if-let [c (if (and (pos? n) (> (count sc) n)) (seq sc))]\n     (let [i-min (vec (range n)), i-max (vec (range (- (count c) n) (count c)))]\n       (letfn [(inc-index [v-ind] (loop [i (dec n) e true r []] (cond\n                   (> 0 i) (vec (reverse r))\n                   (and e (= 0 i)) (let [v (inc (first v-ind))] (if (> v (first i-max)) i-max (vec (range v (+ v n)))) )\n                   (and e (< 0 i)) (let [ie (= (nth v-ind i) (nth i-max i))] (recur (dec i) ie\n                      (conj r (min (nth i-max i) (inc (if ie (inc (nth v-ind (dec i))) (nth v-ind i))) )) ))\n                   :else (recur (dec i) false (conj r (nth v-ind i)))\n                )))\n               (indexes [] (loop [v-ind i-min r []] (if (= v-ind i-max) (conj r v-ind)\n                   (recur (inc-index v-ind) (conj r v-ind) )\n                )))\n               ]\n         (->> (indexes) (map (fn [ic] (set (map #(nth c %) ic)) )) set)\n)) (if(= (count sc) n) #{(set sc)} #{}) ))","user":"55adf4d7e4b03311e7b732af"},{"code":"(fn kcomb [n s]\n  (set (if (= n 1) (map hash-set s)\n   (filter #(= n (count %)) (reduce (fn [a b] (concat a (map #(conj b %) s))) #{} (kcomb (dec n) s))))))","problem":103,"user":"4f0e995e535d0136e6c22326"},{"code":"(fn k-comb [n s]\n  (let [powerset (fn powerset [menge]\n                    (if (empty? menge)\n                      #{#{}}\n                      (set (clojure.set/union (map #(conj % (first menge)) (powerset (rest menge)))\n                      (powerset (rest menge))))))]\n    (set (filter #(= (count %) n) (powerset s)))))","problem":103,"user":"4e28120f535deb9a81d77efa"},{"code":"(fn [n s] (set (filter #(= n (count %)) ((fn [s]\n                                         (reduce (fn [ps x]\n                                                   (reduce (fn [ps s]\n                                                             (conj ps (conj s x))) ps ps)) #{#{}} s))\n                                       s))))","problem":103,"user":"50a5b7e9e4b0aa96157e2610"},{"code":"(fn kcomb [n coll]\n  (cond\n    (= n 0) #{#{}}\n    (> n (count coll)) #{}\n    true (apply hash-set (clojure.set/union\n          (kcomb n (rest coll))\n          (map #(conj % (first coll)) (kcomb (dec n) (rest coll)))))))","problem":103,"user":"4e14108c535d04ed9115e7dd"},{"code":"(fn [cou ma]\n  \n  (set (filter #(= (count %) cou) (reduce (fn[v1 v2]\n            (for [i1 v1\n                  i2 v2]\n              (conj i1 i2)\n              \n            )\n            ) (repeat (count ma) #{}) (repeat cou ma))))\n          )","problem":103,"user":"51bec919e4b013aa0d74b800"},{"problem":103,"code":"(fn get-combinations[a-num xs]\n  (loop [x a-num \n         xs xs\n         acc '(#{})]\n    (if (or (> x (count xs))(= x 0)) (set (filter #(= a-num (count %))(set acc)))\n        (recur (dec x)\n               xs\n               (for [a xs\n                     b acc]\n                 (conj b a ))))))","user":"54f86b8ce4b01ecee9d88828"},{"problem":103,"code":"(fn [n s] (set (filter #(= n (count %)) (reduce #(concat %1 (map (fn [a] (conj a %2)) %1)) #{#{}} s))))","user":"57c647bbe4b05aa3c4741cf3"},{"code":"(fn k-com [k elems]\n  (letfn [(one-more [lst]\n            (if (< (count lst) k)\n                (for [unused (clojure.set/difference elems lst)]\n                  (one-more (conj lst unused)))\n                lst))]\n    (let [amount (count elems)]\n      (cond\n        (< k amount) (-> (one-more #{}) flatten set)\n        (= k amount) #{elems}\n        :else #{}))))","problem":103,"user":"4e356d2b535deb9a81d77f2d"},{"code":"(fn ks[k s]\n  (let [r (- (count s) k)\n        v (vec s)]\n    (cond\n      (<= k 0) #{#{}}\n      (< r 0) #{}\n      :else\n        (loop [i 0 a #{}]\n          (if (> i r)\n            a\n            (recur (inc i)\n                   (into a\n                         (set (map #(conj % (v i))\n                                   (ks (- k 1)\n                                          (drop (inc i) v)))))))))))","problem":103,"user":"4ec0c7ba535dfed6da9c6da4"},{"problem":103,"code":"(fn comb [k s]\n  (cond\n    (> k (count s)) #{}\n    (or (empty? s) (zero? k)) #{#{}}\n    (= (count s) k) #{s}\n    :default (let [f (first s)\n                   r (clojure.set/difference s #{f})]\n               (set (clojure.set/union (map #(conj % f)\n                                       (comb (dec k) r))\n                                  (comb k r))))))","user":"5f86a98be4b0649ffcda4caa"},{"code":"(fn [k s]\n  (let [s (vec s)\n        masks\n          (filter\n            (fn [mask] (= k (Long/bitCount mask)))\n            (range (Math/pow 2 (count s))))\n        bin\n          (map #(Long/toBinaryString %) masks)\n        ind\n          #(keep-indexed (fn [i v] (if (= \\1 v) i)) %)\n        pick\n          (fn [s is]\n            (reduce #(conj %1 (nth s %2)) #{} is))\n\n          ]\n        (set (map (partial pick s) (map (comp ind reverse) bin)))\n   ))","problem":103,"user":"4ff3df0fe4b0678c553fc355"},{"code":"(fn f [n s] (set\n              (cond\n               (= 1 n)         (map hash-set s)\n               (< (count s) n) #{}\n               :else           (into (set (map #(conj % (first s)) (f (dec n) (rest s))))\n                                     (f n (rest s))))))","problem":103,"user":"4ee88bfb535d93acb0a66881"},{"problem":103,"code":"(fn gen-subsets [n s]\n    (set\n     (flatten\n      (for  [element s]\n        (if (= 1 n) #{element}\n            (map #(conj % element) (gen-subsets (dec n) (disj s element)))))))\n    )","user":"57aa290de4b0b8559636fc65"},{"code":"(fn [n s]\n  (let [p (fn [c n s]\n            (cond (zero? n) (assoc c 0 #{})\n                  (= n 1) (assoc c 1 (set (map hash-set s)))\n                  :else (assoc c n\n                               (reduce into #{}\n                                       (for [i s]\n                                         (map #(conj % i) (c (dec n))))))))]\n    (cond\n     (< (count s) n) #{}\n     (= (count s) n) (hash-set (set s))\n     :else (set (filter #(= (count %) n)\n                        ((reduce #(p %1 %2 s) {} (range (count s))) n s))))))","problem":103,"user":"50705072e4b07bd6ad9b9f27"},{"code":"(fn [n s]\n  (if (> n (count s)) #{}\n      (set (filter #(= (count %) n)\n                   (loop [n n res #{#{}}]\n                     (if (zero? n)\n                       res\n                       (recur (dec n)\n                              (set\n                               (mapcat (fn [x] (map (fn [y] (conj x y)) s))\n                                       res)))))))))","problem":103,"user":"4f83665ee4b033992c121c1c"},{"problem":103,"code":"(fn [k xs]\n   (set (filter #(= k (count %))\n                (reduce\n                  (fn [acc x]\n                    (concat acc (keep #(when (> k (count %)) (conj % x)) acc)))\n                  #{#{}}\n                  xs))))","user":"554bd33ce4b0a04f7929959a"},{"problem":103,"code":"(fn [x in]\n  (let [bin (map #(Integer/toString % 2) (range 0 (reduce * (repeat (count in) 2))))]\n    (into #{} (filter #(= (count %) x)\n          (map (fn [nm bin]\n                 (into #{} (remove nil? (map #(if (= %2 \"1\") %1 nil) (vec nm) (->> bin seq (map str))))))\n               (repeat in)\n               (map #(str (apply str (repeat (-> bin last count (- (count %))) \"0\")) %) bin))))))","user":"586b6a0ae4b01531a375e957"},{"code":"(fn [size items]\n  (let [all (loop [i items\n                   res #{#{}}]\n              (let [curr (first i)\n                    rst (rest i)]\n                (if curr\n                  (recur rst (into res (map #(conj % curr) res)))\n                  res)))]\n    (set (filter #(= (count %) size) all))))","problem":103,"user":"4f437751e4b0d7d3c9f3fd20"},{"problem":103,"code":"(fn kcomb [n s] \n  (->> \n   s\n   (reduce #(mapcat (juxt identity (partial cons %2)) %1) (list '()) )\n   (filter #(= n (count %)))\n   (map #(apply hash-set %))\n   (apply hash-set)\n))","user":"5280a1ece4b0757a1b171407"},{"problem":103,"code":"(fn [k s]\n  (let [gen\n          (fn gen [n k]\n            (if (zero? k)\n              [[]]\n              (apply concat\n                (for [i (range (- n k -1))]\n                  (map (comp #(cons i %) #(map (fn [x] (+ x i 1)) %))\n                       (gen (- n i 1) (dec k)))))))\n        n (count s)\n        m (zipmap (range n) s)\n        idx (gen n k)]\n    (set (map #(set (map m %)) idx))))","user":"5416b4a2e4b01498b1a71a01"},{"code":"(fn [k xs]\n    (letfn [(g [k n xs] \n               (if (zero? k) \n                 [#{}]\n                 (->> (range (+ 1 (- n k)))\n                      (mapcat (fn [i] (let [k' (dec k)\n                                            n' (- n (inc i))\n                                            xs' (drop (inc i) xs)]\n                                        (map #(conj % (nth xs i)) (g k' n' xs'))))))))]\n      (into #{} (g k (count xs) (into [] xs)))))","problem":103,"user":"51efd397e4b0249c592fbdeb"},{"code":"(fn [n s]\n  (if (< (count s) n)\n    #{}\n    (loop [i n r #{#{}}]\n      (if (= i 0)\n        r\n        (recur (dec i) (set (mapcat (fn [x] (map #(conj x %) (apply disj s x))) r)))))))","problem":103,"user":"53468f6ce4b084c2834f4a3f"},{"problem":103,"code":"(fn k-combinations[n xs]\n  (letfn [(permutations  [colls] ;; Copy pasted from web\n                       (if (= 1 (count colls))\n                         (list colls)\n                         (for [head colls\n                               tail (permutations (disj (set colls) head))]\n                           (cons head tail))))]\n    (set\n     (filter #(>= (count %) n)\n             (map set\n                  (map (partial take n) (permutations xs)))))))","user":"5980f91ae4b021a7a535fddd"},{"problem":103,"code":"(fn [k s]\n  (let [n (count s)]\n    (if (> k n)\n      #{}\n      (letfn [(next-combination [n k v]\n                (when (and (>= n k) (> k 0))\n                  (let [max-n (dec n)\n                        last-idx (dec k)\n                        lastv (last v)]\n                    (if (< lastv max-n)\n                      (assoc v last-idx (inc lastv))\n                      (if-let [prefix (next-combination\n                                       max-n last-idx (subvec v 0 last-idx))]\n                        (conj prefix (inc (last prefix))))))))\n              (combinations [n k]\n                (let [first (range k)]\n                  (iterate (partial next-combination n k) (vec (range k)))))\n              (foo [s indeces]\n                (let [v (vec s)]\n                  (set (map v indeces))))]\n        (set (map (partial foo s)\n                  (take-while identity (combinations (count s) k))))))))","user":"5764457ae4b0994c1922fbf3"},{"problem":103,"code":"(fn [size coll]\n   (let [comb (fn [value colls] (set (map #(clojure.set/union  % [value]) colls)))]\n    (set (filter #(= (count %)size)\n                 (reduce\n                  (fn [result value]\n                    (clojure.set/union #{#{value}} (comb value result) result))\n                  #{}\n                  coll)))))","user":"52fac708e4b047fd55836fff"},{"problem":103,"code":"(fn kcomb [k s]\n  (let [powerset (fn powerset [s]\n                  (loop [x (first s)\n                         stail (rest s)\n                         subs #{#{}}\n                         ] \n                    (if (nil? x)\n                      subs\n                      (recur\n                       (first stail)\n                       (rest stail)\n                       (into subs (set (mapcat #(vector (conj % x) %) (powerset (remove #{x} s))))) \n                       )\n                      )\n                    )\n                  )\n        ]\n      (set (filter #(= (count %) k) (powerset s)))\n    )\n  )","user":"529a73bde4b02ebb4ef75096"},{"code":"(fn subsets \n  ([k coll] (subsets coll k #{}))\n  ([coll k res]\n   (let [cnt (count coll)\n         fir (first coll)\n         rst (rest coll)]\n     (cond\n       (> k cnt) res\n       (zero? k) #{res}\n       (= cnt k) #{(apply conj res coll)}\n       :else (set (concat \n               (subsets rst (dec k) (conj res fir)) \n               (subsets rst k res)))))))","problem":103,"user":"52b35a6ee4b0c58976d9ad07"},{"problem":103,"code":"(fn [k col]\n (set (filter #(= (count %) k) \n   (reduce (fn [b x] \n     (concat (map #(conj % x) b) b)) [#{}] col))))","user":"5fab7ea6e4b08cb800c85ad8"},{"problem":103,"code":"(fn kombinasi [a b]\n  (cond\n    (zero? a) #{#{}}\n    (empty? b) #{}\n    :else (set (clojure.set/union \n                 (map #(conj % (first b)) (kombinasi (dec a) (rest b)))\n                 (kombinasi a (rest b))))))","user":"5ff709e4e4b06df49cee149b"},{"problem":103,"code":"(fn combs [n xs] \n  (set (map set (cond (= n 0)     [[]]\n        (empty? xs) []\n        :else       \n        (concat (map #(cons (first xs) %) (combs (- n 1) (rest xs))) (combs n (rest xs)))\n        ))))","user":"55645592e4b0c656e3ff1802"},{"code":"(fn pr103 [n s]\n  (if (zero? n)\n    #{} \n    (into #{} \n        (second\n          (reduce (fn [[l res] x]\n                    (let [group (group-by #(< (count %) n) (map #(conj % x) l))]                      [(concat l (get group true []))\n                       (concat res (get group false []))]))\n                [[#{}] []]\n                s)))))","problem":103,"user":"51696ee7e4b03f62cda68ce8"},{"code":"(fn [c u]\n  (set (filter\n        #(= (count %) c)\n        (reduce (fn [a e]\n                  (reduce #(conj % (conj %2 e)) a a))\n                #{#{}} u))))","problem":103,"user":"50b0cffae4b009df37c708c5"},{"code":"(fn [k s]\n  (set (filter #(= (count %) k)\n               (reduce (fn [acc x]\n                 (concat \n                  acc\n                  (map (fn [acc-x] (conj acc-x x)) acc)))\n               #{#{}} s))))","problem":103,"user":"51a97f7ae4b08d8ec191b827"},{"problem":103,"code":"(fn [n set-of-items]\n    (let [step (fn [set-of-sets]\n                 (set (for [a-set set-of-sets, an-item set-of-items\n                            :when (not (contains? a-set an-item))]\n                        (conj a-set an-item))))]\n                    \n    (if (> n (count set-of-items))\n      #{}\n      (do (println \"hello\") (reduce\n                             (fn [acc _] (step acc))\n                             (set (map #(conj #{} %) set-of-items))\n                             (range 1 n))))))","user":"51b91b08e4b0e871ca4958f8"},{"problem":103,"code":"(fn [k a-set]\n  (if (or (empty? a-set) (> k (count a-set)))\n    #{}\n    (loop [x k acc #{#{}}]\n      (if (zero? x)\n        (set (filter #(= k (count %)) acc))\n        (recur (dec x) (for [y acc z a-set] (conj y z)))))))","user":"56cb4d06e4b0ea9b8538f72e"},{"code":"(fn kcombo [k s]\n  (cond (> k (count s)) #{}\n        (= k (count s)) (set (list s))\n        (= k 1) (set (map (comp set list) s))\n        true\n        (let [x (first s)\n              remain (disj s x)]\n          (set (into\n                (map #(conj % x)\n                     (kcombo (- k 1) remain))\n                (kcombo k remain))))))","problem":103,"user":"502a4fdfe4b09dd42f6f3644"},{"code":"(fn [n coll]\n  (loop [input coll result [[]]]\n    (if (empty? input)\n      (set (map #(set %) (filter #(= (count %) n) result)))\n      (recur (rest input)\n             (concat result\n                     (map #(conj % (first input)) (filter #(< (count %) n) result)))))))","problem":103,"user":"4f38d6bbe4b0e243712b1ee2"},{"code":"(fn [n s]\n  (letfn [(subsets [s]\n            (when (seq s)\n              (let [e (first s) p (subsets (rest s))]\n                (concat [[e]] p (map #(conj % e) p)))))]\n    (set (filter #(= (count %) n) (map set (subsets s))))))","problem":103,"user":"5301157ae4b0d8b024fd3717"},{"problem":103,"code":"(fn kc [k S]\n  (let [f (fn [S xs] (set (map #(conj S %) xs)))]\n  (cond\n   (or (zero? k) (> k (count S))) #{}\n   (= 1 k)  (f #{} S)\n   :else    \n   (set (filter #(= k (count %)) (set (mapcat #(f % S) (kc (dec k) S)) ))))))","user":"55896a0ce4b059ccff29b204"},{"problem":103,"code":"(fn combinations [k seq]\n  (cond (zero? k) #{#{}}\n        (empty? seq) #{}\n        :else (set (clojure.set/union \n                    (map #(conj % (first seq)) (combinations (dec k) (rest seq)))\n                    (combinations k (rest seq))))))","user":"58ed713de4b056aecfd47d84"},{"code":"(fn generating-k-combinations [l s]\n  (letfn [(power-set [s]\n            (letfn [(sp-set [s] (reduce \n                                 \n                                 (fn [a x]\n                                   (conj a (disj s x)))\n\n                                 #{} s))]\n\n              (conj (loop [a #{} s #{s}]\n                      (let [[ar,rr] (reduce (fn [[a,ns] x]\n                                              (let [r (sp-set x)]\n                                                [(into a r), (into ns r)]))\n\n                                            [a,#{}] s)]\n                        (if (= rr #{})\n                          ar\n                          (recur ar rr)))) s)\n              ))]\n    (set (filter #(= (count %) l) (power-set s)))))","problem":103,"user":"515bbcd9e4b0388ca8ca1521"},{"code":"(fn f [k s]\n   (cond\n    (zero? k) #{#{}}\n    (> k (count s)) #{}\n    :else (into\n           (f k (rest s))\n           (map #(conj % (first s)) (f (dec k) (rest s))))))","problem":103,"user":"53224d45e4b09d4e7a9b54c0"},{"problem":103,"code":"(fn k-combinations\n  [k s]\n  (loop [sets (map hash-set s)]\n    (if (every? #{k} (map count sets))\n      (set sets)\n      (recur (for [x sets y s\n                   :when (not (x y))]\n               (conj x y))))))","user":"55a9e0fee4b0988bba2ad945"},{"code":"(fn binom [k S]\n  (let [n (count  S)]\n\t  (cond \n\t    (zero? k) #{#{}}\n\t    (< n k) #{}\t\n\t    (= k n) #{S}\n\t    (= k 1) (set (map #(set [%]) (vec S)))\n\t    :else (let [x (set (list (first S)))\n\t\t        dx (clojure.set/difference S x)]\n\t\t\t(set (concat\n\t\t\t  (binom k dx)\n\t\t\t  (map (partial into x) \n\t\t\t       (binom (dec k) dx))))))))","problem":103,"user":"4e6e3a1e535d5021c1a89602"},{"problem":103,"code":"(fn [n s]\n  (set (filter #(= n (count %))\n               (reduce\n                 (fn [a b]\n                   (into a (map #(conj % b) a)))\n                 #{#{}} s))))","user":"50f10f7be4b06d9538fe211a"},{"problem":103,"code":"(fn [n s] (if (< (count s) n) #{}\n            (loop [i (- (count s) n) m #{s}]\n              (if (< 0 i)\n                (recur (dec i) (set (mapcat #(for [k %] (disj % k)) m)))\n                (into #{} m)))))","user":"52d07cc5e4b07d0d72b273bb"},{"problem":103,"code":"(fn [n xs]\n  (if (> n (count xs))\n    #{}\n    (reduce (fn [xxs _]\n              (into #{} (mapcat (fn [xs]\n                                  (map (fn [x] (disj xs x)) \n                                       xs))\n                                xxs)))\n            #{xs}\n          (range (- (count xs) n)))))","user":"54b13a40e4b09f271ff37d1b"},{"problem":103,"code":"(fn solve [n s]\n  (set\n   (filter #(= n (count %))\n           (reduce (fn [res x]\n                     (concat res\n                             (map #(set (conj % x)) res)))\n                   #{#{}}\n                   s))))","user":"56444fb1e4b0018b46ad8c0c"},{"problem":103,"code":"(fn f [k s]\n  (if (= k 1)\n    (set (map #(set [%]) s))\n    (set (mapcat (fn [item]\n                   (let [subs (f (dec k) (disj s item))]\n                     (set (map #(conj % item) subs))))\n                 s))))","user":"4ec1b090535dfed6da9c6db5"},{"code":"(fn [x s]\n    (loop [n 0\n           a #{#{}}]\n      (if (= n x)\n        a\n        (recur (+ n 1)\n          (into #{}\n            (for [i a j s :when (not (i j))]\n              (conj i j)))))))","problem":103,"user":"51b3f109e4b0f094dd986fa9"},{"problem":103,"code":"(fn f103 [k s]\n  (cond (= 1 k) (into #{} (map #(set [%]) s))\n        (empty? s) #{}\n        (zero? k) #{#{}}\n        :else\n\t\t(into #{} (apply concat (for [i s]\n                              (map #(clojure.set/union % #{i}) (f103 (dec k) (remove #{i} s))))))))","user":"583048d9e4b051871117c007"},{"problem":103,"code":"(fn [length input]\n  (let [bitmask (take (reduce +\n                              (take (- (count input) 1)\n                                    (iterate #(* 2 %) 4)))\n                      ((fn get-bitmask [mask]\n                         (let [mask-entries (for [x [0 1] y mask]\n                                              (list x y))]\n                           (lazy-seq (concat mask-entries (get-bitmask mask-entries))))) [0 1]))]\n    (condp = (count input)\n      0 #{#{}}\n      1 #{#{} #{(first input)}}\n      (set (filter #(= (count %)\n                  length)  (map (fn [mask]\n                                      (into #{} (filter (comp not nil?) (map (fn [m value] (if (= 1 m) value)) mask input))))\n                                    (map flatten bitmask)))))))","user":"4e9ff8d0535d7eef3080729c"},{"problem":103,"code":"(fn [n s]\n  (->> (reduce (fn [a x]\n                 [a x]\n                 (->> a\n                      (map #(set (concat #{x} %)))\n                      (concat a)\n                      set))\n               #{#{}} s)\n       (filter #(= n (count %)))\n       set))","user":"56441634e4b0018b46ad8c08"},{"code":"(fn [n sq]\n\n  (if (> n (count sq) ) #{}\n      \n  (set (filter #(= (count %) n)\n\n  (loop [i 0\n         o []\n         ]\n    \n  (let [m  ((fn [n bse x]\n  (map #(rem (quot n %) bse) (map #(int (Math/pow bse %)) (range x)))\n  ) i (count sq) n ) ]\n\n    (if (= i (int (Math/pow (count sq) n))) o\n        (recur (inc i)  (cons  (set (map #(nth (into [] sq) %) m )) o )))))\n\n   )))\n\n  )","problem":103,"user":"5124619ae4b02c3f2a072ccd"},{"code":"(fn f [n s]\n  (set (filter \n   #(= n (count %))\n   (if (or (zero? n) (empty? s))\n     [[]]\n     (let [[ft & rt] (seq s)]\n       (->>\n        [(map #(conj % ft) (f (dec n) rt))\n         (f n rt)]\n        (apply concat)\n        (map set)))))))","problem":103,"user":"51944aaae4b0142f60b4aedc"},{"code":"(fn [n c] (let [ps (reduce (fn [a b] (mapcat (fn [c] [c (conj c b)]) a)) [#{}] c)]\n                     (set (filter #(= n (count %)) ps))\n                     ))","problem":103,"user":"52c1bd29e4b07a9af579236a"},{"code":"(fn kcombs [k xs]\n  (if (or (< k 1) (> k (count xs)))\n    #{}\n    (if (= k 1)\n      (set (map #(conj #{} %) xs))\n      (set (concat (map #(conj % (first xs)) (kcombs (dec k) (rest xs))) (kcombs k (rest xs)))))))","problem":103,"user":"52015698e4b0d7096e99ddba"},{"problem":103,"code":"(fn kc [n s]\n   (cond\n     (or (= n 0) (empty? s) (> n (count s))) #{}\n     (= n (count s)) #{s}\n     (= n 1) (set (for [i s] #{i}))\n     :else (reduce into #{} (for [i s] (map #(into % #{i}) (kc (dec n) (remove #{i} s)))))\n   )\n)","user":"56bca51ae4b0f26550335963"},{"problem":103,"code":"(fn [n items]\n  (letfn [(powerset [items]\n  (if (empty? items)\n    #{#{}}\n    (clojure.set/union (powerset (next items))\n                       (map #(conj % (first items)) (powerset (next items))))))]\n   (->> items\n        powerset\n        (filter #(= (count %) n))\n        (into #{}))))","user":"53da8fede4b0e771c30254a3"},{"problem":103,"code":"(fn k-combinations [k coll]\n  (letfn [(add-not-in-set [subset set]\n            (loop [rem (apply (partial disj set) subset)\n                   res #{}]\n              (if (empty? rem)\n                res\n                (recur (rest rem) (conj res (conj subset (first rem)))))))\n\n          (calc-next-layer [set prev-layer prev-layer-size max-layer-size]\n            (if (= prev-layer-size max-layer-size)\n              prev-layer\n              (loop [rem prev-layer\n                     res #{}]\n                (if (empty? rem)\n                  (calc-next-layer set res (inc prev-layer-size) max-layer-size)\n                  (recur (rest rem) (into res (add-not-in-set (first rem) set)))))))]\n\n    (calc-next-layer coll #{#{}} 0 k)))","user":"5dd67c22e4b0948ae9d9ad80"},{"problem":103,"code":"(fn f [n xs]\n  (if (> n (count xs))\n    #{}\n    (loop [c (dec n) res (map vector xs)]\n      (if (zero? c)\n        (set (filter #(= (count %) n) (map set res)))\n        (recur (dec c) (for [a res b xs] (conj a b))))))\n  )","user":"507e68abe4b085af06e3afd2"},{"problem":103,"code":"(fn kcomb [k s]\n  (cond\n    (zero? k) #{#{}}\n    (> k (count s)) #{}\n    :else (first\n            (reduce\n              (fn [[acc remain] el]\n                (let [remain* (disj remain el)]\n                  [(->> (kcomb (dec k) remain*)\n                        (map #(conj % el))\n                        (into acc))\n                   remain*]))\n              [#{} s] s))))","user":"573d58c8e4b05c31a32c0811"},{"problem":103,"code":"(fn combinations [k es]\n  (letfn [(cartesian-seq\n            ([s1 s2]\n             (for [a (set s1), b (set s2)]\n               (list a b)))\n            ([s1 s2 & ss]\n             (for [a (set s1), b (apply cartesian-seq s2 ss)]\n               (cons a b))))]\n    (cond (or (= 0 k) (> k (count es))) #{}\n          (= 1 k) (set (map hash-set es))\n          :else (->> (apply cartesian-seq (repeat k es))\n                     (map set)\n                     (distinct)\n                     (filter #(= k (count %)))\n                     (set)))))","user":"57ee804ee4b0bfb2137f5bbb"},{"problem":103,"code":"(fn combinations\n  [n s & {:keys [start items]\n          :or {start 0\n               items #{}}}]\n  (let [s (into [] s)]\n    (if (<= n 0)\n      #{items}\n      (into #{} (mapcat (fn [i] (combinations (dec n) s :start (inc i) :items (conj items (nth s i))))\n                        (range start (count s)))))))","user":"50310713e4b05b7df5a0b84c"},{"code":"(fn [k s]\n    (let [n (count s)\n          pow-2 (fn p2 [k] (if (= 0 k) 1 (* 2 (p2 (dec k)))))\n          rec-int-to-set (fn ris [n c r] \n                            (if (= 0 n) \n                                r \n                                (ris \n                                    (bit-shift-right n 1) \n                                    (inc c) \n                                    (if (= 1 (bit-and 0x01 n)) (conj r c) r))))\n          int-to-set #(rec-int-to-set %1 0 #{})\n          brute-k-combinations (fn [n k]\n            (cond \n                (> k n) #{}\n                (= k 0) #{#{}}\n                (= k n) (conj #{} (set (range n)))\n                :else\n                    (filter #(= k (count %1)) (map int-to-set (range (pow-2 n))))))\n          get-fun (fn [s] (fn [is] (set (map #((vec s) %1) is))))\n          xfer (get-fun s)\n    ]\n        (set (map xfer (brute-k-combinations n k)))))","problem":103,"user":"51f59607e4b0abb92f97f9d5"},{"code":"(fn f\r\n  [k S]\r\n  (if (= 0 k)\r\n    #{#{}}\r\n    (set (mapcat\r\n     identity\r\n     (for [x S]\r\n       (for [ys (f\r\n                 (dec k)\r\n                 (clojure.set/difference S (set (list x))))]\r\n         (conj ys x)))))))","problem":103,"user":"4db53f87535d87e67b28fe08"},{"problem":103,"code":"(fn step [k s]\n    (if (= k (count s))\n      #{s}\n      (set (for [a s b (step k (disj s a))] b))))","user":"5a5d0726e4b0512ff01cd91b"},{"problem":103,"code":"(fn k-combinations\n  [k baseset]\n  (into #{}\n   (filter #(= (count %) k)\n           (reduce\n            (fn [found next]\n              (into found\n                    (map #(conj % next)\n                         (into found (map #(conj #{} %) baseset)))))\n            #{ }\n            baseset))))","user":"5bf9d9b7e4b0bdcf453d15c4"},{"problem":103,"code":"(fn [l s]\n    (letfn [(power-set [s]\n              (if (empty? s)\n                #{#{}}\n                (let [e (first s)\n                      r (rest s)\n                      s1 (power-set r)\n                      s2 (map #(conj % e) s1)]\n                  (into s1 s2))))]\n      (into #{} (filter #(= l (count %)) (power-set s)))))","user":"4ee6400c535d93acb0a6685b"},{"problem":103,"code":"(fn ff [n xs] (->> xs\n  (reduce (fn [a b] (into a (map #(conj % b) a))) #{#{}})\n  (filter #(= n (count %)))\n  set))","user":"5b0bd9cfe4b0cc2b61a3bdd9"},{"problem":103,"code":"(fn k [n s] \n\n;;; bottom of recursion\n(if (= 0 n) #{#{}}\n\n(let [ \n\nktails ;; \n(for [i s] [i (k (dec n) (disj s i )) ] )\n\n]\n(set (mapcat (fn \n[[i, setOfSet]] \n(map #(conj %1 i) setOfSet ) \n)\nktails))\n\n)))","user":"533a2f7be4b0e30313ee6cb8"},{"code":"(fn k-combinations [n s]\n  (cond (= n 0) #{#{}}\n        (empty? s) #{}\n        :else (reduce conj\n                      (k-combinations n (rest s))\n                      (map #(conj % (first s))\n                           (k-combinations (dec n) (rest s))))))","problem":103,"user":"4e7c8fd1535db169f9c796be"},{"problem":103,"code":"#(case %\n   1 #{#{4} #{5} #{6}}\n   10 #{}\n   3 #{#{0 1 2} #{0 1 3} #{0 1 4} #{0 2 3} #{0 2 4} #{0 3 4} #{1 2 3} #{1 2 4} #{1 3 4} #{2 3 4}}\n   4 #{#{[1 2 3] :a \"abc\" \"efg\"}}\n   2 (if (= 3 (count %2)) \n       #{#{0 1} #{0 2} #{1 2}}\n       #{#{[1 2 3] :a} #{[1 2 3] \"abc\"} #{[1 2 3] \"efg\"} #{:a \"abc\"} #{:a \"efg\"} #{\"abc\" \"efg\"}}))","user":"5507cfd3e4b021ccfedb96ad"},{"problem":103,"code":"(fn f [n coll]\n    (if (zero? n) (list #{})\n      (set (mapcat (fn [y] (map #(conj % y) (f (dec n) (disj coll y)))) coll))\n            \n      ))","user":"50856bd1e4b004985b776e4c"},{"problem":103,"code":"(fn k-comb [k s] \n  (if (empty? s) \n    '(()) \n    (set (map set (filter #(= k (count %)) \n            (concat (k-comb k (rest s)) \n                    (map #(cons (first s) %) \n                         (k-comb (dec k) (rest s)))))))))","user":"545e7ab0e4b01be26fd7467c"},{"code":"(fn k-combinations [n s]\n  (let [power-set (partial reduce (fn [s x]\n                                    (concat s (map #(conj % x) s)))\n                           #{#{}})\n        f (partial filter #(== n (count %)))]\n    (->> s power-set f set)))","problem":103,"user":"4f3fb586e4b0e243712b1f9c"},{"problem":103,"code":"(fn k-com\n  [n xs]\n  (cond\n    (> n (count xs)) #{}\n    (= n (count xs)) #{xs}\n    :else\n    (loop [rs (->> xs (map (comp set list)) (into #{}))\n           iter 1]\n      (if (= iter n)\n        rs\n        (let [new-rs\n              (mapcat (fn [el]\n                        (let [left (remove el xs)]\n                          (map (fn [e] (conj el e)) left)))\n                      rs)]\n          (recur (into #{} new-rs) (inc iter)))))))","user":"536ecd9fe4b0fc7073fd6e76"},{"problem":103,"code":";;refer to question 85 power set\n(fn [l s]\n  (loop [step 0 n #{#{}}]\n    (if (= step (count s)) (set (filter #(= l (count %)) n)) ;filter the sets that compliance requirements\n      (recur (inc step)\n             (apply conj n \n                    (for [x s y n]\n                      (conj y x))\n                    )))))","user":"574abbfbe4b02ea114799200"},{"code":"(fn combinations [k s]\n  (cond (zero? k) #{#{}}\n        (empty? s) #{}\n        :else (into (combinations k (rest s))\n                    (map #(conj % (first s))\n                         (combinations (dec k) (rest s))))))","problem":103,"user":"4fe84c74e4b07c9f6fd12c3c"},{"problem":103,"code":"(fn [n items]\r\n  (let [\r\n      comb (fn comb [n items]\r\n        (if (> n (count items))\r\n          '()\r\n        (if (= n 0)\r\n          '(())\r\n        (if (= n 1)\r\n          (map vector items)\r\n          (let [[head & tail] items]\r\n            (concat\r\n              (map #(cons head %) (comb (dec n) tail))\r\n              (comb n tail)))))))]\r\n    (set (map set (comb n (seq items))))))","user":"555bd27ae4b0b056612e2244"},{"problem":103,"code":"(fn k-combinations [k s]\n  (let [n (count s)]\n    (cond (> k n) #{}\n          (= k n) #{(set s)}\n          (= k 0) #{#{}}\n          :else (let [[x & y] (seq s)]\n                  (into (k-combinations k y)\n                        (map #(conj % x) (k-combinations (dec k) y)))))))","user":"5731e36be4b0cd1946bd0fc9"},{"problem":103,"code":"(fn f [n s]\n    (cond\n      (> n (count s))\n      #{}\n      (= n 0)\n      #{#{}}\n      :else (clojure.set/union\n              (f n (rest s))\n              (set (map #(conj % (first s)) (f (dec n) (rest s)))))))","user":"5a2df4a0e4b09cafd31c7f74"},{"code":"(fn [k xs]\n  (loop [xs xs zs #{#{}}]\n    (if (seq xs)\n      (recur (next xs) (into zs (map #(conj % (first xs)) zs)))\n      (apply hash-set (filter #(== (count %) k) zs)))))","problem":103,"user":"511442d0e4b0e9c109bb74d5"},{"problem":103,"code":"#(let[elements (vec %2)\n      numOfElements (count elements)]\n   (loop[c 0 n (dec %1) r (into #{} (map (fn[x] (into #{} (list x))) %2))]\n     (cond\n       (>= n numOfElements) #{}\n       (= c n) r\n       :else (recur (inc c) n (into #{} (for [com r e elements :when (not (contains? com e))] (conj com e)))))))","user":"541619e8e4b01498b1a719f9"},{"code":"(fn [n s]\n  (->> (reduce (fn [s el] (mapcat #(vector % (conj % el)) s)) #{#{}} s)\n       (filter #(= n (count %))) set))","problem":103,"user":"4f465096e4b0d56e7bb92b9a"},{"code":";; clear but inefficient. better split-merge cases w/wo 1st elem\n(fn combi [n s]\n   (if (= n 0)\n     [#{}]\n     (set (mapcat\n            (fn [e] (map #(conj % e)\n                         (combi (- n 1) (remove #{e} s))))\n            s))))","problem":103,"user":"4e8510e7535db62dc21a62e7"},{"problem":103,"code":"(fn [k coll]\n  (letfn [(kbin2n [k n]\n          (reduce (fn [a b]\n                    (let [bin (Integer/toString b 2)]\n                      (if (= (count (filter #(= % \\1) bin)) k)\n                        (conj a b)\n                        a)))\n            #{} (range 1 (Math/pow 2 n))))]\n    (let [n (count coll) c (into [] coll)]\n      (set (map #(reduce\n                   (fn [a b] (if (bit-test % b) (conj a (c b)) a))\n                  #{} (range n))\n                (kbin2n k n))))))","user":"5e5096c6e4b027a2e10ac0c6"},{"problem":103,"code":"(fn [n xs]\n  (if (> n (count xs))\n    #{}\n    (loop [i 0, res #{#{}}]\n      (if (= i n)\n        (->> res\n             (filter #(= n (count %)))\n             (set))\n        (recur (+ i 1)\n               (set (for [x xs, r res]\n                      (conj r x))))))))","user":"58a2b57fe4b02bd94d917ede"},{"problem":103,"code":"(fn [k n-set]\n    (if (<= 0 (- (count n-set) k))\n      (set (nth\n             (iterate\n               (fn [combs]\n                 (flatten (map\n                            (fn [x] (map #(disj x %) x))\n                            combs))) [n-set])\n             (- (count n-set) k)))\n      #{}))","user":"5a91988ae4b002d099cae6f9"},{"problem":103,"code":"(fn f \n\t([n s] (f n s #{}))\n\t([n s acc] \n\t    (cond (zero? n) acc\n\t          (empty? s) #{}\n\t        \t:else (let [down (f (dec n) (rest s) (conj acc (first s)))\n\t        \t            side (f n (rest s) acc)] \n\t        \t           (clojure.set/union (if (every? set? down) down #{down}) side)))))","user":"5a14228fe4b0ff51aa4b3193"},{"problem":103,"code":"(fn kcomb [k xs]\n    (let\n        [\n            kcomb_helper\n                (fn f [stack k xs i] \n                    (if (= (count stack) k)\n                        #{(set stack)}\n                        (let\n                            [\n                                sets\n                                    (map\n                                        #(f (conj stack (nth xs %)) k xs %)\n                                        (range (inc i) (count xs))\n                                    )\n                            ]\n                            (reduce into #{} sets)\n                        )\n                    )\n                )                    \n        ]\n        (kcomb_helper [] k (vec xs) -1)\n    )\n)","user":"5db7376fe4b010eb3c36cd43"},{"problem":103,"code":"(fn combinations [k s]\n  (cond\n    (zero? k) #{#{}}\n    (> k (count s)) #{}\n    true (let [x (first s) s1 (rest s)]\n           (set (clojure.set/union (combinations k s1)\n                                   (map #(conj % x) (combinations (dec k) s1)))))))","user":"58a0fc33e4b02bd94d917ea3"},{"problem":103,"code":"(fn all-k-combs [k S]\n  (cond\n    (> k (count S)) #{}\n    (= k 0) #{}\n    (= k 1) (into #{} (map (fn [x] #{x}) S))\n    (= k (count S)) #{S}  \n    :else (let [x (first S)\n                xs (set (rest S))\n                wout (all-k-combs k xs)\n                with (all-k-combs (dec k) xs)]\n              (clojure.set/union wout (into #{} (map (fn [s] (conj s x)) with))))))","user":"5f63684be4b02876ed9fd012"},{"problem":103,"code":"(fn [k s]\n  (let [s (vec s)\n        n (count s)\n        max-n (int (inc (reduce #(+ (Math/pow 2 %2) %) 0 (range n))))\n        fs (format \"~%d,'0b\" n)\n        combos (filter\n                (fn [item] \n                  (= k (count (filter true? item))))\n                (for [i (range max-n)]\n                  (map #(= \\1 %) (clojure.pprint/cl-format nil fs i))))]\n    (into #{} (for [c combos]\n                (set (filter (complement nil?)\n                               (map #(if % %2) c s)))))))","user":"5405ae2be4b0addc1aec6671"},{"problem":103,"code":"(fn me [num my-set]\n  \n \t(let [power-set (fn me [args]\n\n\t\t\t\t(let [combin (fn [arg1 arg2]\n\n\t\t\t\t\t(let [new-sets (apply hash-set (map #(clojure.set/union (hash-set arg2) %) arg1))]\n\n\t\t\t\t\t(clojure.set/union arg1 (hash-set (hash-set arg2)) new-sets )\n\n\t\t\t\t\t)\n\n\t\t\t\t)]\n\n\n\t\t\t(reduce combin #{#{}}  args)\n\n\t\t\t)\n\t\t)\n            \n          ]\n      \n      \n     (into #{} (filter #(= num (count %))  (power-set my-set) )\t)\n      \n    ) \n  \n\n  \n)","user":"55897fe2e4b059ccff29b205"},{"code":"(fn k [n,s]\n  (cond (zero? n) #{(set '())}\n        (> n (count s)) #{}\n        (= n (count s)) #{(set s)}\n        :else (set (concat\n                     (map #(conj % (first s)) (k (dec n) (rest s)))\n                     (k n (rest s))))))","problem":103,"user":"504e04a4e4b078edc5f59397"},{"problem":103,"code":"(fn f\n  ([n s]\n    (if (> n (count s))\n      #{}\n      (f (dec n) s (map hash-set s))))\n  ([n s r]\n   (if (pos? n)\n     (recur\n       (dec n)\n       s\n       (for [rx r\n             sx s\n             :let [x (conj rx sx)]\n             :when (> (count x) (count rx))]\n         x))\n     (set r))))","user":"5012da69e4b0c8732600222d"},{"code":"(fn [n s]\n  (let [powerset\n        (fn [in out]\n          (if (empty? in)\n            out\n            (recur (disj in (first in))\n                   (apply merge\n                          out\n                          (map #(conj % (first in)) out)))))]\n  \n  (set (filter #(= (count %) n) (powerset s #{#{}})))))","problem":103,"user":"4f8345c6e4b033992c121c1b"},{"code":"(fn f [n s]\n  (set\n    (if (== 1 n)\n      (map hash-set s)\n      (let [z (f (dec n) s)]\n        (for [x s, t z :when (not (t x))]\n          (conj t x))))))","problem":103,"user":"4f08b15b535dcb61093f6c40"},{"problem":103,"code":"(fn kcombin [n given-set]\n   (set (filter #(= n (count %)) (loop [initial-set given-set power-set #{#{}}]\n                              (if (empty? initial-set)\n                                power-set\n                                (recur (rest initial-set) (into power-set (map #(conj % (first initial-set)) power-set))))))))","user":"608ec5e4e4b03bd49d9f36c0"},{"code":"(fn [k s]\r\n  (let [ps (fn ps [s]\r\n             (if (empty? s) #{#{}}\r\n               (let [ss (ps (rest s))]\r\n                  (concat ss (map #(conj % (first s)) ss)))))]\r\n    (set (filter #(= k (count %)) (ps s)))))","problem":103,"user":"4e8681b7535dae1a5effa438"},{"code":"(fn c [n s]\n  (cond\n   (zero? n) #{#{}}\n   (> n (count s)) #{}\n   (= n (count s)) #{(set s)}\n   :else (into (c n (rest s)) (map #(conj % (first s)) (c (dec n) (rest s))))))","problem":103,"user":"52479487e4b05ef8e38e6373"},{"problem":103,"code":"; choose k-element sets from the powerset of st\n(fn [k st]\n  (set\n    (filter #(= (count %) k)\n      (reduce (fn [s t] (into s (for [x s] (conj x t))))\n              #{#{}}\n              st))))","user":"57f0f7b8e4b0bfb2137f5bfe"},{"code":"(fn kc [k c]\n  (set\n   (condp = k\n     0 #{}\n     1 (map (comp set vector) c)\n     (for [a (kc 1 c),\n           b (kc (dec k) c)\n           :let [ab (into a b)]\n           :when (= k (count ab))]\n       ab))))","problem":103,"user":"5341b141e4b00652c8746ecf"},{"problem":103,"code":"(fn comb [cnt st]\n  (cond\n    (zero? cnt) #{#{}}\n    (= cnt (count st)) #{(set st)}\n    (> cnt (count st)) #{}\n    :else (clojure.set/union\n     (comb cnt (next st))\n     (set (map #(conj % (first st)) (comb (dec cnt) (next st)))))))","user":"53908e6be4b0b51d73faae9a"},{"problem":103,"code":"(fn k-combs [n domain]\n    (if (<= n 1)\n      (into #{} (map (fn [el] #{el}) domain))\n      (into #{}\n            (mapcat (fn [el]\n                      (let [subseqs (k-combs (dec n) (disj domain el))]\n                        (map #(conj % el) subseqs)))\n                    domain))))","user":"5317d78ee4b08068f379ed63"},{"code":"(fn kcomb\n  [n s]\n  (cond (zero? n)       #{}\n        (= 1 n)         (set (map (partial conj #{}) s))\n        (> n (count s)) #{}\n        :else\n        (let [s (set s)]\n          (set (mapcat (fn [i]\n                         (map #(conj % i)\n                              (kcomb (dec n) (disj s i))))\n                       s)))))","problem":103,"user":"511b233ae4b07ab9ec456180"},{"code":"#(let [c (count %2)]\n   (if (> %1 c)\n     #{}\n     (loop [done [%2] sz c]\n       (if (= sz %1)\n         (into #{} done)\n         (let [d (into #{} (for [o done i o]\n                            (disj o i)))]\n           (recur d (dec sz)))))))","problem":103,"user":"4f32a7f1e4b0d6649770a095"},{"problem":103,"code":"(fn k-combo [n coll]\n  (letfn\n      [(pwSet\n         ([coll] (pwSet coll #{} #{}))\n         ([coll subSet addedLast]\n          (if (empty? coll)\n            #{subSet}\n            (clojure.set/union\n             #{subSet}\n             (pwSet (rest coll) (conj subSet (first coll)) (first coll))\n             (pwSet (rest coll) (conj (clojure.set/difference subSet #{addedLast}) (first coll)) (first coll))))))] \n  (set (filter #(= (count %) n) (pwSet coll)))))","user":"5b3251c1e4b025bcb146f317"},{"problem":103,"code":"(fn [k s]\n    ((fn adder [combos queue elements k start]\n       (loop [combos combos\n              i start]\n         (if (= k 0)\n           (if (empty? queue)\n             combos\n             (conj combos queue))\n           (if (>= i (count elements))\n             combos\n             (recur\n              (adder combos\n                     (conj queue (nth elements i))\n                     elements (dec k) (inc i))\n              (inc i))))))\n     #{} #{} (into [] s) k 0))","user":"539fa040e4b0ca733b97449f"},{"problem":103,"code":"(fn k-combo\n   ([n domain curr-set]\n    (if (= (count curr-set) n)\n       curr-set\n       (map #(k-combo n (disj domain %) (conj curr-set %)) domain)))\n   ([n domain]\n    (if (> n (count domain))\n       #{}\n       (set (flatten (k-combo n domain #{}))))))","user":"54f09599e4b024c67c0cf89d"},{"code":"(fn f [k xs]\n    (cond \n      (= k 0) #{#{}}\n      (empty? xs) #{}\n      :else (letfn [(g [i] \n                      (let [k' (- k 1)\n                            xs' (disj xs i)\n                            iter (f k' xs')]\n                        (map #(set (conj % i)) iter)))]\n              (set (mapcat g xs)))))","problem":103,"user":"5141abf1e4b02fd87f5064c3"},{"code":"(fn ps [n s]\n\t(set (filter #(= n (count %))\n  (loop [res #{#{}} li s]\n    (if (empty? li)\n      res\n      (recur\n       (apply merge res\n              (for [x res]\n                (clojure.set/union x (hash-set (first li)))))\n       (rest li)))))))","problem":103,"user":"51c09719e4b0c9c82288293c"},{"code":"(fn [k xs]\n  (letfn [(pick-next [pairs]  \n                     (set (for [[k vs] pairs\n                                v vs]\n                            [(conj k v) (disj vs v)])))]\n    (set \n      (map first\n        (loop [pairs #{[#{} xs]}, k k]\n          (if (zero? k)\n            pairs\n            (recur (pick-next pairs) (dec k))))))))","problem":103,"user":"536ca4bde4b0fc7073fd6e49"},{"code":"(fn k-comb [k s]\n  (if (zero? k)\n    #{#{}}\n    (set\n     (for [[x xs] (zipmap s (rest (iterate rest s)))\n           rst (k-comb (dec k) xs)]\n         (set (cons x rst))))))","problem":103,"user":"4fb12b35e4b081705acca275"},{"problem":103,"code":"(fn k-combinations\n  ([k coll]\n   (if (< 0 k (inc (count coll)))\n     (k-combinations k coll 1 (into #{} (for [e coll] #{e})))\n     #{}))\n  ([k coll counter intermediate]\n   (if (= counter k)\n     intermediate\n     (recur k coll (inc counter)\n            (reduce #(apply conj %1 (for [e coll :when (not (contains? %2 e))] (conj %2 e)))\n                    #{}\n                    intermediate)))))","user":"592ac17ae4b072a2710fcf26"},{"code":"(fn [k s]\n    (loop [acc #{#{}}\n           cnt 1]\n      (if (> cnt k)\n        (->> acc\n             (filter #(= k (count %))) set)\n        (recur (apply clojure.set/union\n                      (map (fn [a]\n                             (map (fn [v] (conj a v)) s))\n                           acc))\n               (inc cnt)))))","problem":103,"user":"50763574e4b0a894bb95bf3d"},{"code":"(fn [k s]\n  (let [bi (fn bi [bin]\n             (if (or (nil? bin) (= 0 (count bin)))\n               nil\n               (let [p (peek bin)\n                     t (pop bin)]\n                 (if p\n                   (conj t false)\n                   (conj (bi t) true)))))]\n    (loop [x (seq s)\n           acc #{}\n           mask (vec (repeat (count x) true))]\n      (if (zero? (count (filter identity mask)))\n        acc\n        (if (= k (count (filter identity mask)))\n          (recur x (conj acc\n                         (into #{} (map #(first %) (filter #(second %) (map #(vector % %2) x mask))))) (bi mask))\n          (recur x acc (bi mask)))))))","problem":103,"user":"4ff9d4e5e4b0678c553fc3b0"},{"code":"(fn combs\n  ([n items] (set (combs items n #{} [])))\n  ([items n results so-far]\n     (if (= n (count so-far))\n       (conj results (set so-far))\n       (loop [is items results results]\n   (if (empty? is) results\n\t   (recur (rest is)\n\t\t  (combs (remove #(= % (first is)) items)\n\t\t\t n results\n\t\t\t (conj so-far (first is)))))))))","problem":103,"user":"4e513ecf535dc968683fc4f6"},{"problem":103,"code":"(fn k-combinations\n  [k coll]\n  (cond\n   (zero? k)     #{#{}} ; single empty combination\n   (empty? coll) #{}    ; no combinations\n   :else (let [[head & tail] (seq coll)]\n           (set (clojure.set/union\n                 (k-combinations k tail)\n                 (map (partial clojure.set/union #{head})\n                      (k-combinations (dec k) tail)))))))","user":"5a95c639e4b0d174b936c75e"},{"code":"(fn kcomb [n se]\n  (let [ps (fn ps [s]\n             (if (empty? s) #{#{}}\n               (let [i (first s)\n                     r (disj s i)\n                     sps (ps r)\n                     un clojure.set/union]\n                 (un sps (set (map #(un #{i} %) sps))))))]\n    (into #{} (filter #(= n (count %)) (ps se)))))","problem":103,"user":"5267d9bde4b03e8d9a4a7188"},{"code":"(letfn [(f1 [x1 x2] (for [a x1 b x2] (conj a b)))]\n  (fn [n s]\n    (loop [i n acc (set (map #(set [%]) s))]\n      (if (zero? i)\n        (set (filter #(= (count %) n) acc))\n     (recur (dec i) (set (f1 acc s)))))))","problem":103,"user":"52d1e364e4b0d9f9285948e7"},{"problem":103,"code":"(fn k-combinations\n  [k s]\n  (if (= k 1)\n    (set (map #(do #{%}) s))\n    (set (filter #(= (count %) k)\n                 (let [before (k-combinations (dec k) s)]\n                   (for [s-e s\n                         s-s before]\n                     (conj s-s s-e)))))))","user":"4fc524aae4b081705acca37e"},{"problem":103,"code":"(fn [n items]\n    (let [rec (fn rec [n items]\n                (if (and (pos? n) (>= (count items) n))\n                  (concat (rec n (rest items))\n                          (if-let [more (seq (rec (dec n) (next items)))]\n                            (for [item more]\n                              (conj item (first items)))\n                            (list (list (first items)))))\n                  '()))]\n      (set (map set (rec n items)))))","user":"5275f7a2e4b03e8d9a4a74d0"},{"code":"(fn [n s]\n  (set (filter #(= n (count %))\n  (reduce \n    (fn [o i]\n      (into o (map #(conj % i) o))) \n    #{#{}} s))))","problem":103,"user":"4f1d1d95535d64f603146488"},{"code":"(fn [n a_set]\n  (set (let [s (vec a_set)\n        l (count s)\n        poss (apply * (repeat l 2))]\n    (filter #(= n (count %)) \n            (map (fn [b] (set (\n                               filter identity \n                               (for [x (range l)] (if (bit-test b x) (nth s x) nil))\n                               )))\n                 (range poss))))))","problem":103,"user":"51899891e4b0288ada3dbdab"},{"problem":103,"code":"(fn kc [n arr]\n  (letfn [(helper [acc res]\n            (if (= n (count acc))\n              acc\n              (map (fn [item]\n                     (helper (conj acc item) (remove #(= % item) res)))\n                   res)))]\n    (set (flatten (helper #{} arr)))))","user":"563fc1f2e4b08d4f616f5ed7"},{"code":"(fn [n coll]\n    (letfn [(power-set [coll]\n              (letfn [(union [s1 s2] (reduce conj s1 s2))]\n                (if (empty? coll)\n                  #{#{}}\n                  (let [element (first coll)\n                        sub1 (power-set (disj coll element))\n                        sub2 (set (map #(union #{element} %) sub1))]\n                    (union sub1 sub2)))))]\n      (set (filter #(= n (count %)) (power-set coll)))))","problem":103,"user":"4dc29a1d535d020aff1edf96"},{"problem":103,"code":"(fn [n s]\n  (set (filter #(= n (count %))\n               ((fn [s] (reduce (fn [s x] (into s (map #(conj % x) s))) #{#{}} s))\n                s))))","user":"57035ccfe4b08d47c97781ef"},{"code":"(fn perms [k elements]\n  (if (or (< (count elements) k) (= k 0))\n    #{}\n    (if (= k 1)\n      (set (map hash-set elements))\n      (if (= k (count elements)) \n          (hash-set elements)\n          (clojure.set/union \n            (perms k (set (next elements)))\n            (set\n              (map #(conj % (first elements)) (perms (dec k) (set (next elements))))))))))","problem":103,"user":"503e7f06e4b06c4e0e1fa268"},{"code":"(fn comb[n s]\n  (set (cond (> n (count s)) []\n        (= n 1) (map #(set [%]) s)\n        :else (mapcat (fn[e] (map #(conj % e) (comb (dec n) (remove #(= e %) s)))) s))))","problem":103,"user":"4e7db3b4535db169f9c796e1"},{"problem":103,"code":"(fn k-combos [n s]\n  (letfn [(power-set [s]\n            (loop [[e & more :as s-in] (seq s)\n                   s-out #{#{}}]\n              (if (empty? s-in)\n                s-out\n                (recur more (apply (partial merge s-out)\n                                   (map #(conj % e) s-out))))))]\n    (set (filter #(= n (count %)) (power-set s)))))","user":"5ca14eb1e4b048ec896c5b7d"},{"problem":103,"code":"(fn generating-k-combinations [k s]\n  (set\n    (cond\n      (> k (count s)) []\n      (= k 1)         (reduce #(concat %1 #{#{%2}}) #{} s)\n      :else           (->> (reduce #(concat %1\n                                            (map (fn [e] (set (conj e %2))) %1))\n                                   #{#{}}\n                                   s)\n                           (filter #(= k (count %)))))))","user":"56d4b22de4b0ea9b8538f7bb"},{"code":"(fn [k z]\n  (set\n  (filter #(= k (count %))\n    ((fn p [s]\n      (if (= #{} s)\n          #{#{}}\n          (loop [h (first s)\n                 t (rest  s)\n                 T (disj s h)]\n            (clojure.set/union (p T) (map #(clojure.set/union #{h} %) (p T)))))) z))))","problem":103,"user":"51f28a64e4b0210f90e7454e"},{"problem":103,"code":"(fn\n  [n data]\n  (let [size (count data)]\n    (if (or (< n 1) (< size n))\n      #{}\n      (let [x (- size n)\n            result (atom #{})]\n        (loop [[stack i] [[] 0]]\n          (let [data (vec data)\n                [stack i] (loop [[stack i] [(conj stack i) i]]\n                            (if (= n (count stack))\n                              (do (swap! result conj (reduce (fn [r i] (conj r (nth data i))) #{} stack))\n                                  (recur (loop [[stack i] [stack size]]\n                                           (if (and (<= (+ x (count stack)) i) (not (empty? stack)))\n                                             (let [[stack i] [(pop stack) (inc (last stack))]]\n                                               (if (< (+ (count stack) x) i)\n                                                 (recur [stack i])\n                                                 [(conj stack i) i]))\n                                             [stack i]))))\n                              [stack i]))]\n            (if (empty? stack)\n              @result\n              (recur [stack (inc i)]))))))))","user":"5b5e7953e4b0c6492753e6d9"},{"code":"(fn k-combos\n  [k S]\n\n  (cond\n   (<= k 0) #{}\n   (> k (count S)) #{}\n   (= k 1) (set (map #(set %1) (partition 1 S)))\n   :else (into #{} (for [rem-S (take (count S) (iterate rest S))\n                         :let [hed (first rem-S)]\n                         tal (k-combos (dec k) (rest rem-S))]\n                     (set (cons hed tal))))))","problem":103,"user":"4f047c07535dcb61093f6bcd"},{"problem":103,"code":"(fn [cnt arr]\n  (->> (range (Math/pow 2 (count arr)))\n       (map (fn f [v] (if (< v 2) [v] (cons (mod v 2) (f (int (/ v 2)))))))\n       (filter #(= (count (filter #{1} %)) cnt))\n       (map (fn [v] (filter identity (map #(if (= %2 1) %1) arr v))))\n       (map set)\n       (set)))","user":"56018dd4e4b04bb52996e18f"},{"code":"(fn subsets [k as]\n  (cond\n    (zero? k) #{#{}}\n    (= (count as) k) #{as}\n    :else (set (for [el as, ss (subsets (dec k) (disj as el))] (conj ss el)))))","problem":103,"user":"506ab9bae4b05d3b7762c74c"},{"problem":103,"code":"(fn [n0 s0]\n  (letfn [(subs [n s]\n            (cond\n              (zero? n) #{#{}}\n              (empty? s) #{}\n              :else (let [e (first (seq s))\n                          with-e (map #(conj % e) (subs (dec n) (disj s e )))\n                          without-e (subs n (disj s e))]\n                      (clojure.set/union with-e without-e))))]\n     (set (subs n0 s0))))","user":"51d19c24e4b0cfcf579466c3"},{"code":"(fn [n s]\n  (let [split-all (fn split-all [n src base result]\n          (cond (> n (count src)) result\n                (= 0 n) (conj result base)\n                :else (split-all (dec n) (rest src) (conj base (first src)) (split-all n (rest src) base result))))]\n    (split-all n s #{} #{})))","problem":103,"user":"507fbd77e4b089ade05efbd3"},{"problem":103,"code":"(fn k-combinations [n s]\n  (if (or (= 0 n) (< (count s) n))\n    #{}\n    (let [s (vec s)]\n      (set (map set (remove nil? (for [x (range (Math/pow 2 (count s)))]\n                                   (let [bs (seq (Integer/toBinaryString x))]\n                                     (if (= n (count (filter #(= %1 \\1) bs)))\n                                       ((fn helper [res i bs]\n                                          (if (empty? bs)\n                                            res\n                                            (if (= \\1 (first bs))\n                                              (helper (conj res (nth s i))\n                                                      (inc i)\n                                                      (drop 1 bs))\n                                              (helper res\n                                                      (inc i)\n                                                      (drop 1 bs)))))\n                                        []\n                                        0\n                                        (reverse bs)))))))))))","user":"5dc53ddee4b02f9375f4e1bd"},{"problem":103,"code":"(fn __ [n s]\n  (cond\n    (zero? n) #{#{}}\n    (> n (count s)) #{}\n    (= n (count s)) #{s}\n    :else\n    (->> s\n         (map #(map\n                 (fn [r] (conj r %))\n                 (__ (dec n) (disj s %))))\n         (apply concat)\n         set)))","user":"57a0b341e4b0c3d858beb8d4"},{"code":"(letfn [\n    (comb [n s] (cond \n        (zero? n) [#{}]\n        (> n (count s)) []\n        true (let [\n            s1 (first s)\n            sn (disj s s1)\n            comb1 (comb n sn)\n            comb2 (for [i (comb (dec n) sn)] (conj i s1))]\n            (concat comb1 comb2))))]\n    (comp set comb))","problem":103,"user":"51cbdee1e4b08d8387cbede1"},{"problem":103,"code":"(fn [n coll]\n  (set (filter #(= n (count %)) (reduce (fn [a x]\n            (->> a\n                 (map #(set (concat #{x} %)))\n                 (concat a)\n                 set))\n          #{#{}} coll))))","user":"544e8369e4b0e39780006987"},{"problem":103,"code":"#(cond\n  (> %1 (count %2)) #{} ;one short cut\n  (= %1 (count %2)) #{%2} ;another short cut\n  :else (loop [result #{#{}} round 0] ;an iterative solution\n          (if (= round %1) result\n            (recur (apply conj #{}\n                          (for [x result y %2 :when (not (contains? x y))]\n                            (conj x y)))\n                   (inc round)))))\n\n;a recursive solution\n;(fn kCombination[k S]\n;  (cond\n;   (= k 0) #{}\n;   (= k 1) (apply conj #{}\n;                   (for [item S]\n;                     #{item}))\n;   (= k (count S)) #{S}\n;   (> k (count S)) #{}\n;   :else (apply conj #{}\n;                (for [x (kCombination (dec k) S) y S :when (not (contains? x y))]\n;                  (conj x y)))))","user":"556c70dae4b09a3098a524fd"},{"code":"(fn kcomb [k s]\n    (cond\n     (zero? k)       #{#{}}\n     (> k (count s)) #{}\n     (= k (count s)) #{s}\n     :else           (into #{} (mapcat (fn [x] (map #(conj % x) (kcomb (dec k) (disj s x)))) s))))","problem":103,"user":"51c19873e4b0d204dbe2ca0d"},{"problem":103,"code":"(fn ! [n xs]\n  (cond (> n (count xs)) #{}\n        (zero? n) #{#{}}\n        (empty? xs) #{#{}}\n        :else (into #{}\n                    (apply concat\n                           (map (fn [x]\n                                  (map #(conj % x)\n                                       (! (dec n) (disj xs x))))\n                                xs)))))","user":"54c271b9e4b045293a27f602"},{"code":"(fn k-com [n col]\n  (if (> n (count col))\n    #{}\n    (if (= 1 n)\n      (set (for [e col] #{e}))\n      (clojure.set/union\n       (k-com n (rest col))\n       (set (map #(set (cons (first col) %)) (k-com (- n 1) (rest col))))))))","problem":103,"user":"514721c6e4b0d520409ed392"},{"problem":103,"code":"(fn my-fn [n xs]\n  (set (filter #(= n (count %))\n               (reduce (fn [acc x]\n                         (let [new-vals (map #(conj % x) acc)]\n                           (concat acc new-vals))) #{#{}} xs)))\t)","user":"5c896f46e4b048ec896c5940"},{"problem":103,"code":"(fn combs [k coll]\n  (let [v (vec coll)\n        n (count v)]\n    ;; returns a lazy sequence of subsequences of v beginning with subseq-begin,\n    ;; with next element chosen from range i-begin i-end\n    (letfn [(subseqs [subseq-begin i-begin i-end]\n              (lazy-seq\n               (if (= k (count subseq-begin))\n                 [subseq-begin]\n                 (mapcat #(subseqs (conj subseq-begin (nth v %)) (inc %) (inc i-end)) (range i-begin i-end)))))\n            (vv->set [vv] (set (map set vv)))]\n      (vv->set (subseqs [] 0 (- n k -1))))))","user":"5896a0e6e4b00487982d52a8"},{"problem":103,"code":"(fn k-comb\n  [n s]\n  (set (filter #(= (count %) n)  (reduce #(into %1 (set (for [item %1] (conj item %2)))) #{#{}} s))))","user":"561ca6ebe4b064ca9f4b169c"},{"problem":103,"code":"(fn [n s]\n   (set\n     (filter\n       #(= n (count %))\n       (reduce\n         (fn [l x]\n           (concat l (map #(conj %1 %2) l (repeat x))))\n         [#{}] s))))","user":"57d9f603e4b0bd073c20240a"},{"problem":103,"code":"(fn [n s]\n  (if (<= n (count s))\n    (letfn [(step [n s]\n      (if (> n 0)\n          (set (for [x s c (step (dec n) (disj s x))]\n            (conj c x)\n          ))\n        #{#{}}\n      )\n    )]\n      (step n s)\n    )\n    #{})\n)","user":"5fd8bcb3e4b05ac5b16ea11b"},{"problem":103,"code":"(fn [n s]\n  (let [k-combos (fn f [n s]\n                   (let [size (count s)]\n                     (cond (= n size) (list s)\n                           (= n 0) '(())\n                           (> n size) ()\n                           :else (let [x (first s)\n                                       xs (rest s)]\n                                   (concat (f n xs)\n                                           (map (partial cons x) (f (dec n) xs)))))))]\n    (->> (k-combos n s)\n         (map set)\n         set)))","user":"5ec6de19e4b08d0ec38692da"},{"problem":103,"code":"(fn k-comb [n S]\n    (if (> n (count S)) #{}\n        (if (= n 0) #{#{}}\n        (clojure.set/union\n          (k-comb n (rest S))\n          (set (map #(conj % (first S)) (k-comb (dec n) (rest S))))))))","user":"559c13c5e4b066d22e731f61"},{"problem":103,"code":"(fn [k S]\n  (set (filter #(= k (count %))\n               (nth (iterate (fn [sets]\n                               (set (mapcat (fn [s]\n                                              (map #(conj s %) S)) sets))) \n                             #{#{}}) k))))","user":"55625903e4b0c656e3ff17d7"},{"problem":103,"code":"(fn f [n s]\n  (set\n   (if (= n 0)\n     #{#{}}\n     (mapcat #(for [e (f (- n 1) %2)]\n                (conj e %1))\n             s\n             (rest (iterate rest s))))))","user":"53034738e4b0d8b024fd373e"},{"problem":103,"code":"(fn [n s]\n  (let [power-set (fn [s]\n                    (let [v (vec s)]\n                      (into #{} (for [i (range (apply * (repeat (count v) 2)))]\n                                  (into #{} (for [j (range (count v)) :when (bit-test i j)]\n                                              (v j)))))))]\n    (into #{} (filter #(= n (count %)) (power-set s)))))","user":"5353afa0e4b084c2834f4b03"},{"code":"; just generate the powerset and filter out\n; incorrect lengths. Too expensive, but it works.\n(fn __ [n s]\n  (letfn [(gen-subsets [ss]\n            (let [to-remove (vec ss)]\n               (map #(disj ss %) to-remove)))]\n  (loop [s (hash-set s) ps s]\n    (if (empty? (disj s #{}))\n      (set (filter #(= n (count %)) (conj ps #{})))\n      (recur \n       (set (mapcat gen-subsets s))\n       (clojure.set/union (set (mapcat gen-subsets s)) ps))))))","problem":103,"user":"4fa719c0e4b081705acca1bf"},{"code":"(fn combinations\n  ([k xs] (combinations k xs #{}))\n  ([k xs sofar]\n   (cond (zero? k) #{sofar}\n         (zero? (count xs)) #{}\n         :else (clojure.set/union\n                (combinations (dec k) (rest xs) (conj sofar (first xs)))\n                (combinations k (rest xs) sofar)))))","problem":103,"user":"510acd6ee4b078ea719210f4"},{"problem":103,"code":"(fn [k S]\n  (letfn\n    [(pset [x]\n      (if (seq x)\n        (conj (apply clojure.set/union (for [e x] (pset (disj x e)))) x)\n        #{#{}}))]\n    (set (filter #(= k (count %)) (pset S)))))","user":"55f20e4be4b06e875b46ce40"},{"problem":103,"code":";recursive lexicographic sort\n(fn comb2[ n items]\n  (letfn [(myc [elems k curr]            \n            (let [ecount (count elems)\n                  toiter (range (dec ecount))]\n              (cond\n                (< ecount k) '()\n                (= 1 k) (map #(conj curr %) elems)               \n                (= k ecount) (merge [] (set (concat curr elems)))\n                :else (map \n                        #(myc (drop (inc %) elems) (dec k) (conj curr (nth elems %))) \n                        toiter))))]\n       (->>(myc (vec items) n #{})\n           (flatten)\n           (into #{}))))\n\n; power set method (inefficient but shorter)\n;(fn kcomb[n xs]    \n;   (letfn [(ps [s]\n;             (loop [e s a #{#{}}]\n;               (if (empty? e) a\n;                 (let [curr  (first e)\n;                       elems (map #(conj % curr) a)]\n;                   (recur (rest e) (clojure.set/union a elems))))))]\n;     (->>(ps xs)\n;         (filter #(= n (count %)))\n;         (into #{}))))","user":"52f426fce4b05e3f0be25f1e"},{"code":"(fn ! [n st]\n  (cond (> n (count st)) #{}\n  (= n 1) (set (map #((comp set list) %) st))\n\t:else (set (flatten (for [el st]\n\t\t(map #(conj % el) (! (dec n) (disj st el))))))))","problem":103,"user":"4e7d1c22535db169f9c796c5"},{"problem":103,"code":"(fn [n s]\n  (let [power-set (reduce (fn [ps e] (into ps (map #(conj % e) ps))) #{#{}} s)]\n    (set (filter #(= (count %) n) power-set))))","user":"57002b81e4b08d47c97781c7"},{"problem":103,"code":"(fn [k set]\n        (let [coll (into [] set)]\n          (letfn [(comb-aux [k start]\n                    (if (= 1 k)\n                      (for [x (range start (count coll))] \n                        (conj #{} (set (nth coll x))))\n                      (for [x (range start (count coll)) \n                            xs (comb-aux (dec k) (inc x))] \n                        (into #{} (conj xs (nth coll x))))))]\n            (into #{} (comb-aux k 0))))\n        )","user":"57e6f90de4b0bfb2137f5af6"},{"code":"(fn [k set]\n   (into #{} (filter #(= (count %1) k) ((fn powerset [set]\n                                (loop [powerset #{#{}} i 0]\n                                  (if (= i (count set))\n                                    powerset\n                                    (recur\n                                     (into powerset (for [x powerset y set] (conj x y) ) )\n                                     (inc i)\n                                     )\n                                    )\n                                  )\n                                ) set )))\n   )","problem":103,"user":"4ea31da2535d7eef308072c1"},{"code":"(fn k [n s]\n  (cond (empty? s) #{}\n        (= n 0) #{}\n        (= n 1) (set (for [i s] #{i}))\n        (= n (count s)) #{s}\n        (> n (count s)) #{}\n        :else\n        (letfn [(subset [s]\n                  (set (for [i s] (disj s i))))\n                (powerset [s]\n                  (if (< 0 (count s))\n                    (loop [ss (subset s)\n                           ret #{#{} s}]\n                      (if (= ss #{#{}})\n                        (set ret)\n                        (recur\n                         (set (reduce concat #{} (map subset ss)))\n                         (concat ret ss))))\n                    #{#{}}))]\n          (set (filter #(= n (count %)) (powerset s))))))","problem":103,"user":"50733b31e4b0e3170b5a869a"},{"problem":103,"code":"(fn [n coll]\n  (letfn [(comb [k coll]\n            (cond (zero? k) '(())\n                  (empty? coll) '()\n                  :else (concat (map #(cons (first coll) %)\n                                     (comb (dec k) (rest coll)))\n                                (comb k (rest coll)))))]\n    (into #{} (map set (comb n coll)))))","user":"53576356e4b04ce2eb3ed27a"},{"problem":103,"code":"(fn [k s]\n  (letfn\n    [(parts [ss]\n       (set (mapcat\n              #(map (partial disj %) %)\n              ss)))]\n  (let [n (count s)]\n    (if (or (< k 0) (< n k))\n        #{}\n        (->> #{s}\n             (iterate parts)\n             (drop (- n k))\n             first)))))","user":"55d2dd27e4b0e31453f64a5b"},{"code":"(fn seq-comb[x xs]   \n   (set \n    (if (= 1 x) (map (comp set list ) xs)\n     (loop [ys xs\n            res []]\n       (if-not (empty? ys)\n       (recur (drop 1 ys)\n              (concat res (map (partial cons (first ys)) \n                               (seq-comb (dec x) (drop 1 ys)))))\n         (map set res))))))","problem":103,"user":"506406c8e4b075d771da6f9f"},{"code":"(fn [k st]\n  (if (> k (count st)) #{}\n      (loop [n 1 res [#{}]]\n        (if (> n k) (set res)\n            (recur (inc n) (for [e st s res :while (not (s e))] (conj s e)))))))","problem":103,"user":"4efd8b67535de96065cf5085"},{"problem":103,"code":"(fn k-combos [k se]\n  (let [s (set se)]\n    (cond (= k 1) (into #{} (map hash-set s))\n          (> k (count s)) #{}\n          (= k (count s)) #{s}\n          :else (into #{}\n                      (mapcat (fn [e]\n                                (map (fn [ss]\n                                       (conj ss e))\n                                     (k-combos (dec k) (disj s e))))\n                              s)))))","user":"580bd81ee4b0849f6811b711"},{"code":"(fn g [n s]\n  (let [[a & b :as s] (seq s)]\n    (set (cond (> n (count s)) #{}\n               (= n 1) (map #(set [%]) s)\n               (> n 0) (concat (map #(conj % a) (g (dec n) b)) (g n (set b)))\n               :else []))))","problem":103,"user":"4ea09fa4535d7eef308072aa"},{"problem":103,"code":"(fn [n s] (set (filter #(= (count %) n) (loop [ps #{#{}}\n               i 0]\n          (if (> i (count s))\n            ps\n            (recur (into ps (mapcat (fn [e] (reduce #(conj % (conj e %2)) #{} s)) ps))\n                   (inc i))\n            )))))","user":"565b2fa5e4b068f2fe63dbfe"},{"code":"(fn [n coll]\r\n  (letfn [(kc [k s]\r\n            (set\r\n              (if (= 1 k)\r\n                (map #(set [%]) s)\r\n                (mapcat (fn [x]\r\n                          (map #(conj % x)\r\n                            (kc (dec k) (disj s x))))\r\n                  s))))]\r\n    (kc n coll)))","problem":103,"user":"4f969214e4b0dcca54ed6cdd"},{"code":"(fn [n seq]\n  (letfn [(combs [n seq]\n            (cond (= n 0) (list nil)\n                  (< (count seq) n) nil\n                  :else\n                  (concat\n                     (combs n (rest seq))\n                     (map cons \n                          (repeat (first seq))\n                          (combs (dec n) (rest seq))))))]\n    (set (map set (combs n (vec seq))))))","problem":103,"user":"4fe87e56e4b07c9f6fd12c40"},{"code":"(fn combinations [k s]\n    (cond\n     (> k (count s)) \n     #{}\n     \n     (= k 1) \n     (set (map #(conj #{} %) s))\n     \n     :else\n     (let [[x & xs] (seq s)\n           sub-combinations (combinations (dec k) xs)\n           with-first (map #(conj % x) sub-combinations)\n           without-first (combinations k xs)]\n       (->> with-first\n            (concat without-first)\n            (map set)\n            set))))","problem":103,"user":"5326c5f7e4b09d4e7a9b54f2"},{"problem":103,"code":"(fn f [n s] (cond\n    (>= 0 n) #{#{}}\n    (> n (count s)) #{}\n    :else (into #{} (concat (map (fn [v] (conj v (first s))) (f (- n 1) (rest s))) (f n (rest s))))))","user":"5a4de614e4b05d388ecb6bb1"},{"problem":103,"code":"(fn k-combinations [subset-size xs]\n  (let [xs-vec (vec xs)\n        increment-index (fn [indexes]\n                          (let [[before-inc-index [index-to-inc & more]]\n                                (map (partial map first)\n                                     (split-with\n                                      (fn [[i1 i2]] (not (< i1 (dec i2))))\n                                      (partition 2 1 [(+ 2 (last indexes))] indexes)))]\n                            (concat (range (count before-inc-index))\n                                    [(inc index-to-inc)]\n                                    more)))\n        k-combo-indexes (->> subset-size\n                             range\n                             (iterate increment-index)\n                             (take-while\n                              (partial not-any? (partial <= (count xs)))))]\n    (into #{} (map (fn [indexes] (into #{} (map #(xs-vec %) indexes))) k-combo-indexes))))","user":"53504fe6e4b084c2834f4ada"},{"code":"(fn subset [n items]\n  (letfn [(r [head items n]\n    (if (zero? n)\n      (list head)\n      (mapcat\n       (fn [i]\n         (r (conj head (nth items i)) (drop (inc i) items) (dec n))\n         ) (range (count items)))\n      ))]\n    (set (map set (r [] (seq items) n)))\n    ))","problem":103,"user":"503ca47fe4b06c4e0e1fa24f"},{"problem":103,"code":"(fn [n c]\n  (set (filter #(= (count %) n) (reduce (fn [r x] (into r (map #(conj % x) r)))\n            #{#{}} c))))","user":"57e33f6fe4b0bfb2137f5a96"},{"code":"(fn [k s]\n  (letfn [(step [s] (for [e s] (disj s e)))\n          (comb-it [d ss]\n                   (if (= 0 d) ss\n                     (recur (dec d) (reduce into #{} (map step ss)))))]\n    (let [n (count s)] \n      (if (or (< n k) (zero? k)) #{} (comb-it (- n k) (hash-set s))))))","problem":103,"user":"5246e945e4b0644eb7b0783b"},{"code":"(fn k-combinations [k s]\n  (let [pool  (vec s)\n        n     (count pool)\n        zip   (partial map vector)]\n    (cond\n      (or (zero? k) (zero? n) (> k n)) #{}\n      (= 1 k) (set (map hash-set pool))\n      (= k n) #{s}\n      true (let [rs (reverse (range k))\n                 fi (fn [[i j :as x]]\n                      (if (not= j (- (+ i n) k))\n                        x))\n                 yield (comp set (partial map (partial nth pool)))]\n             (loop [js (range k)\n                    ac #{(yield js)}]\n               (if-let [[i j] (some fi (zip rs (reverse js)))]\n                 (let [js (take k (concat (take i js) (iterate inc (inc j))))]\n                   (recur (vec js) (conj ac (yield js))))\n                 ac))))))","problem":103,"user":"4e6a412e535d8ccf87e9feb6"},{"code":"(fn [n xs]\n  (letfn [(super-set[xs]\n            (set ((fn proc[xs]\n                    (if (empty? xs) [#{}]\n                          (let [ [[a] xs'] (split-at 1 xs)\n                                 S         (proc xs')]\n                            (into S (for [s S] (conj s a)))))) xs)))]\n    (into #{} (filter #(= n (count %)) (super-set xs)))))","problem":103,"user":"50fa01bce4b07934dda8b0ba"},{"problem":103,"code":"(fn [k xs]\n  (letfn [(kcom [ys visited k]\n            (cond (> k (count ys)) #{}\n              (= k 0) visited\n              :else\n                (map #(kcom (disj ys %) (conj visited %) (dec k)) ys)))]\n    (into #{} (flatten (kcom xs #{} k)))))","user":"53e9a15be4b036ad0777e4ae"},{"code":"#(loop [out #{#{}}]\n   (cond\n     (> % (count %2)) #{}\n     (= % (count (first out))) out\n     :else (recur (set (for [i %2 j out :when (not (contains? j i))]\n                         (conj j i))))))","problem":103,"user":"52667ecfe4b03e8d9a4a713e"},{"problem":103,"code":"(fn [n s]\n  (if (or (= 0 n) (> n (count s)) (empty? s)) #{}\n    (loop [n (- n 1), r (map hash-set s)]\n     (if (= 0 n) (set r)\n     (recur (dec n)\n      (for [x r, y s :when (not (contains? x y))] (conj x y))\n     )))))","user":"4fd11a93e4b04c3a95aa040a"},{"problem":103,"code":"(fn [n elem]\n   (if (> n (count elem))\n     #{}\n     (->> (loop [set #{#{}}\n                 c 0]\n            (if (= c n)\n              set\n              (recur (reduce #(apply conj %1 (map (fn [p] (conj %2 p)) elem)) #{} set) (inc c))))\n          (filter #(= (count %) n))\n          (into #{}))\n     )\n   )","user":"5f3f2281e4b004f08c61c561"},{"problem":103,"code":"(let [k-bits (fn [k upper]\n                 (->> (range upper)\n                      (map (fn [n]\n                             (let [fq (->> n\n                                           Integer/toBinaryString\n                                           seq\n                                           frequencies)]\n                              [n (fq \\1)])))\n                      (filter (fn [[_ ones]] (= ones k)))\n                      (map first)))\n        bits->indices (fn [n]\n                        (loop [x n, acc [], i 0]\n                          (if (zero? x)\n                            acc\n                            (let [q (quot x 2)\n                                  r (rem x 2)\n                                  acc' (if (= 1 r) (conj acc i) acc)]\n                              (recur q acc' (inc i))))))\n        f (fn [k vs]\n            (let [upper (apply *' (repeat (count vs) 2))\n                  xs (vec vs)]\n              (->> (for [b (k-bits k upper)]\n                     (let [idxs (bits->indices b)]\n                       (->> (map (partial nth xs) idxs)\n                            (into #{}))))\n                   (into #{}))))]\n    f)","user":"53684a2fe4b0243289761e8c"},{"code":";Just take the power set solution (85) and filter the results.\n(fn kcomb [n st]                                                                                   \n  (letfn [(subsets [n items]                                                                         \n            (cond                                                                                    \n             (= n 0) #{#{}}                                                                          \n             (empty? items) #{}                                                                      \n             :else (concat (map                                                                      \n                            #(cons (first items) %)                                                  \n                            (subsets (dec n) (rest items)))                                          \n                           (subsets n (rest items)))))]                                              \n    (let [allsubsets (for [i (range (inc (count st)))] (subsets i st))]                              \n       (set(filter #(= n (count %)) (reduce #(into %1 (map set %2)) #{} allsubsets))))))","problem":103,"user":"4f1d1299535d64f603146487"},{"problem":103,"code":"(fn k-combinations [k coll]\n  (let [n (dec (count coll))\n        coll (vec coll)]\n    (if (> k (count coll))\n      #{}\n      (loop [idx (vec (range k))\n             results []]\n        (let [results (conj results (set (map coll idx)))]\n          (if (< (last idx) n)\n            ;;(recur (update idx (dec k) inc) results)\n            (recur (assoc idx (dec k) (inc (get idx (dec k)))) results)\n            (if-let [pivot (last (keep-indexed (fn [i [x y]] (when (< x (dec y)) i)) (partition 2 1 idx)))]\n              (let [pivot-val (get idx pivot)\n                    nxt-idx (vec (concat (take pivot idx)\n                                         (map #(+ 1 pivot-val %) (range 0 (- (count idx) pivot)))))]\n                (recur nxt-idx results))\n              (set results))))))))","user":"5d6042f2e4b0c9e5857d5006"},{"code":"(fn [x s]\n  (letfn [(powerset [s]\n    (reduce (fn [ps x]\n      (reduce (fn [ps s]\n        (conj ps (conj s x))) ps ps)) #{#{}} s))]\n    (set (filter #(= x (count %)) (powerset s)))))","problem":103,"user":"4ebc08a8535dfed6da9c6d7c"},{"problem":103,"code":"(fn combinations [n s]\n  (if (zero? n) #{#{}}\n    (set (for [s1 s\n               s2 (combinations (dec n) (disj s s1))]\n           (conj s2 s1)))))","user":"605b7a90e4b079a07f8593fc"},{"problem":103,"code":"(fn f \n  ([n xs] (f n xs #{}))\n  ([n xs s]\n    (let [t (rest xs)]\n      (cond\n        (= n (count s)) #{s}\n        (empty? xs) #{}\n        :else (set \n                (concat\n                  (f n t (conj s (first xs)))\n                  (f n t s)))))))","user":"55ecb2c0e4b0121d4835fdce"},{"problem":103,"code":"(fn combi [r xs]  \n  (if (zero? r)\n    #{#{}}\n    (set (for [x xs\n               s (combi (dec r) (disj xs x))]\n           (conj s x)))))\n\n#_\n(fn combi [r items]\n  (if (zero? r) [#{}]\n    ((comp set mapcat)\n      #(for [i (combi (dec r) (disj items %))] (conj i %))\n      items)))\n\n#_ ;my impl.\n(fn combi-set [r ss]\n (letfn [(combi-lst [r [x & t :as xs]]\n         (cond (or (nil? x) (empty? xs) (< r 0) (< (count xs) r)) #{}\n               (zero? r) #{#{}}\n               (= (count xs) r) #{(set xs)}\n               :else (->> (clojure.set/union \n                           (map #(conj % x) (combi-lst (dec r) t))\n                           (combi-lst r t))\n                          set)))]\n  (combi-lst r (seq ss))))","user":"5bea3177e4b0f319e2d7ec81"},{"code":"(fn kcom [n s]\n  (letfn \n    [(ksets [n root [head & tail]]\n      (cond\n        (zero? n) [root]\n        (nil? head) nil\n        :else (concat\n                (ksets (dec n) (conj root head) tail)\n                (ksets n root tail))))]\n    (set (map set (map (partial remove nil?) (ksets n [] (apply list s)))))))","problem":103,"user":"521e8227e4b0dd19981ad082"},{"code":"(fn [n ls]\n  (letfn [\n    (powerset [ls]\n      (if (empty? ls) #{#{}}\n        (clojure.set/union (powerset (next ls))\n          (map #(conj % (first ls)) (powerset (next ls))))))]\n    (into #{} (filter #(= (count %) n) (powerset ls)))))","problem":103,"user":"533ab9abe4b0e30313ee6cbf"},{"problem":103,"code":"(fn k-comb [k S]\n  (cond\n   (> k (count S)) #{}\n   (= k 1) (set (map (comp set list) S))\n   :else (let [n (first S)\n               S-prime (->> S rest set)]\n           (clojure.set/union\n            (k-comb k S-prime)\n            (set (map #(conj % n)\n                      (k-comb (dec k)\n                              S-prime)))))))","user":"55f73078e4b06e875b46cea4"},{"problem":103,"code":"(fn k-combinations [n coll]\n   (into #{} (map #(into #{} %)\n                  (let [f (first coll)\n                        r (rest coll)]\n                    (cond\n                      (zero? n) #{nil}\n                      (empty? coll) nil\n                      :else (apply merge (map #(conj % f) (k-combinations (dec n) r)) (k-combinations n r)))))))","user":"591072e0e4b0163c97b36ebc"},{"problem":103,"code":"(fn [n s]\n    (let [tree    (reduce (fn [lft rgt]\n                            (conj (into lft\n                                        (for [elem lft]\n                                          (conj elem rgt)))\n                                  #{rgt}))\n                          #{}\n                          s)\n          counted (filter #(= (count %)\n                              n)\n                          tree)]\n      (set counted)))","user":"5be5cebde4b0ed4b8aab4d19"},{"code":"(fn kcomb [k s] (if (< (count s) k) \n                    #{}\n                    (if (= 1 k)\n                      (set (map hash-set s))\n                      (reduce into #{} (map (fn[el](set (map #(conj % el) (kcomb (dec k) (disj s el))))) (drop-last (dec k) s)))\n                   ))\n )","problem":103,"user":"526a3412e4b03e8d9a4a721e"},{"problem":103,"code":"(fn [n ss]\n  (if (> n (count ss)) #{}\n    (reduce (fn [r s] (set (for [x ss y r :when (not (y x))] (conj y x))))\n            #{#{}}\n            (range n))))","user":"57dd47f4e4b0bd073c20243e"},{"code":"(fn c [k v] \n        (cond \n          (> k (count v)) #{}\n          (= k 1) (set (map #(set [%]) v))\n          (= k (count v)) #{(set v)}\n          :else \n            (into (c k (rest v)) (map #(conj % (first v)) (c (dec k) (rest v))))))","problem":103,"user":"4ffa8affe4b0678c553fc3bd"},{"code":"(fn [n s]\n  (set\n    (filter #(= n (count %))\n      (reduce\n        (fn [a x] (into a (map #(conj % x) a)))\n        #{#{}}\n        s))))","problem":103,"user":"4fd96694e4b05e33b9224f37"},{"problem":103,"code":"(fn kc [n s]\n  (cond\n   (zero? n) #{#{}}\n   (> n (count s)) #{}\n   (= n (count s)) #{s}\n   :else (into (kc n (set (rest s)))\n               (map #(conj % (first s)) (kc (dec n) (rest s))))))","user":"567e418fe4b0feffd0d18eb1"},{"problem":103,"code":"#(nth (iterate \n       (fn [ss] \n         (set \n          (remove \n           nil? \n           (for [s ss \n                 x %2] \n             (if (s x) \n               nil \n               (conj s x))))))\n       [#{}]) %1)","user":"52b02329e4b0c58976d9acc5"},{"problem":103,"code":"(fn [n s]\n    (if (> n (count s))\n      #{} \n      (let [p\n            (fn p[s] \n              (let [s (set s)]\n                (if (= 2 (count s))\n                  (list \n                    (list (first s) (second s))\n                    (list (second s) (first s))\n                    )\n                  (apply clojure.set/union (map (fn[a](map #(conj % a) (p(disj s a)))) s))\n                  )\n                )\n              ) \n            ]\n        (set (map #(set (subvec (vec %) 0 n)) (p s)))\n        )\n      )\n    )","user":"54b90836e4b0ed20f4ff6e9d"},{"problem":103,"code":"(fn kcomb [n uni]\n  (let [union (fn [a b] (reduce conj a b))]\n    (cond \n      (= 0 n) #{#{}}\n      (= n (count uni)) #{uni}\n      (> n (count uni)) #{}\n      :else (union\n        (kcomb n (set (rest uni))) \n        (map #(conj % (first uni)) (kcomb (dec n) (set (rest uni))))))))","user":"53ff8c31e4b0de5c41848603"},{"code":"#(set (filter (fn [s] (= (count s) %1))\n              (reduce (fn [acc x] (into acc (for [s acc] (conj s x))))\n                      #{#{}}\n                      %2)))","problem":103,"user":"507b7dbee4b09034bfeeb71e"},{"problem":103,"code":"(fn k-comb\n  [k s]\n  (let [size (count s)]\n    (cond \n     (> k size) #{}\n     (= k size) #{(set s)}\n     (= k 1) (set (map hash-set s))\n  \t :else (let [h (first s)\n                 r (rest s)]\n             (into (k-comb k r) (map #(conj % h) (k-comb (dec k) r)))))))","user":"56897739e4b0dcc4269f407d"},{"problem":103,"code":"(fn foo [n items]\n   (into #{}\n         (cond\n           (= n 0) #{#{}}\n           (empty? items) #{}\n           :else (concat (map\n                          #(clojure.set/union (hash-set (first items)) %)\n                          (foo (dec n) (rest items)))\n                         (foo n (rest items))))))","user":"4e8768f6535dceadca469850"},{"code":"(fn generating-k-combinations[n sets]\n    (set(filter (fn[x] (= (count x) n))(reduce #(into %1 (set (map (fn[x](conj x %2))\n                                                                  (filter (fn[x]( < (count x) n )) (into %1 #{#{}})))))\n                                             #{} sets))))","problem":103,"user":"5273562ae4b03e8d9a4a7479"},{"code":"(fn k-combine [n xset]\n  (letfn [(inter [xset-1 xset-2]\n            (set (for [s1 xset-1 s2 xset-2]\n                   (clojure.set/union s1 s2))))\n          (init-set [xs]\n            (set (for [s xs] (set (list s)))))]\n    (let [xs (init-set xset)]\n      (cond\n       (= n 1) xs\n       (> n (count xs)) #{}\n       :else (loop [acc xs cnt (dec n)]\n               (if (= cnt 0)\n                 (set (filter #(= n (count %)) acc))\n                 (recur (inter acc xs) (dec cnt))))))))","problem":103,"user":"4eec82fe535d93acb0a668ae"},{"problem":103,"code":"(fn [k x] (->>\n           x\n           ((fn p [ls]\n              (if (empty? ls) [#{}]\n                  (clojure.set/union (p (next ls))\n                            (map #(conj % (first ls)) (p (next ls)))))))\n           (filter #(= (count %) k)) (set)))","user":"55be39f9e4b01b9910ae2a06"},{"code":"(fn kcomb [n s]\r\n  (if (= n 1)\r\n    (set (for [c s] #{c}))\r\n    (apply clojure.set/union\r\n           (for [c s] (set (map #(conj % c) (kcomb (dec n) (disj s c)))))\r\n           )))","problem":103,"user":"4feada56e4b0140c20fb9c11"},{"code":"(fn [k given]\n  (loop \n    [i 1\n     accu #{ #{}}]\n    (if (> i k)\n      accu\n      (recur\n       (inc i)\n       (into #{} \n        (for \n         [x given\n          y accu\n          :let [z (conj y x)]\n          :when (= i (count z))]\n         z))))))","problem":103,"user":"50217818e4b00bba4502f7a7"},{"problem":103,"code":"(let [perms\n      (fn perms [n coll & xs]\n        (if (zero? (dec n))\n          (map (fn [x] (cons x xs)) coll)\n          (mapcat (fn [e] (apply perms (dec n) coll (cons e xs)))\n                  coll)))]\n  (fn [n coll]\n    (->> (perms n coll)\n         (filter (partial apply distinct?))\n         (map set)\n         set)))","user":"51dafedee4b09f6bc204eee2"},{"code":"(fn k-combinations [n coll]\n  (let [coll (vec coll)]\n    (if (> n (count coll))\n      #{}\n      (if (= n 1)\n        (apply hash-set (map hash-set coll))\n        (apply\n          hash-set\n          (apply\n            concat\n            (for [i (range (count coll))]\n              (let [k (nth coll i)\n                    r (drop (inc i) coll)]\n                (map\n                  #(conj % k)\n                  (k-combinations (dec n) r))))))))))","problem":103,"user":"4dab218f30acd6ed15482a68"},{"code":"(fn [n a-set]\n    (letfn [(powerset [s]\n              (let [vs (vec s)\n                    n-max (dec (int (Math/pow 2 (count vs))))\n                    bdigit\n                    (fn bdigit [n]\n                      (let [n2 (quot n 2)\n                            m  (mod n 2)]\n                        (lazy-seq\n                          (if (zero? n2)\n                            (list m)\n                            (cons m (bdigit n2))))))]\n                (loop [n 0\n                       pset #{}]\n                  (if (< n-max n)\n                    pset\n                    (recur (inc n)\n                           (conj pset\n                                 (set\n                                  (map first (filter #(= 1 (second %))\n                                                     (map vector vs (bdigit n)))))))))))]\n      (set (filter #(= n (count %)) (powerset a-set)))))","problem":103,"user":"4f5cc3b8e4b0030a34fb2b2b"},{"code":"(letfn [(pset [s]\r\n  (set\r\n    (if (>= 1 (count s)) [(set s) #{}]\r\n      (concat\r\n        [s]\r\n        [(set [(first s)])]\r\n        (pset (set (rest s)))\r\n        (map #(set (cons (first s) %)) (pset (set (rest s))))\r\n      ))))]\r\n  (fn [n s] (set (filter #(= n (count %)) (pset s)))))","problem":103,"user":"4f1b92d1535d64f60314647b"},{"code":"(fn [n s]\n  (->>\n    (reduce\n      (fn [sets nxt]\n        (into sets (map #(conj % nxt) sets)))\n      #{#{}}\n      s)\n    (filter #(= (count %) n))\n    set))","problem":103,"user":"4fce5474e4b0d4b2a7a9d451"},{"code":"(fn [n xs]\n   (letfn\n       [(diff [xs ys]\n          (reduce disj xs ys))\n        (comb [cs xs]\n          (set\n           (mapcat\n            #(for [y (diff xs %)] (conj % y))\n            cs)))]\n     (loop [m n ys (set (map hash-set xs))]\n       (if (= 1 m)\n         ys\n         (recur (dec m) (comb ys xs))))))","problem":103,"user":"504e13fce4b078edc5f593bc"},{"problem":103,"code":"(fn xx\n  [n c]\n  (cond (> n (count c)) #{}\n        (= n (count c)) (set [c])\n        (= n 1) (set (map hash-set c))\n        :else (into  (set (map #(conj  %1  (first c))\n                               (xx (dec n) (disj c (first c)))))\n                      (xx n (disj c (first c))))))","user":"56102f50e4b05f002753df6b"},{"problem":103,"code":"(letfn [(combinations [c]\n  (reduce (fn [acc it]\n            (set (concat acc (map #(conj % it) acc) #{#{it}})))\n          #{#{}} c))]\n  (fn [n c]\n    (set (filter #(= (count %) n) (combinations c)))))","user":"561ba3e5e4b073c65b0ce3eb"},{"code":"(fn k-combinations [n st]\n  (letfn [(power-set [stt]\n                     (letfn [(lo [x len]\n                                 (str (reduce str (repeat (- len (count x)) \"0\")) x))\n                             (jay [v sr]\n                                  (into #{} (filter identity (map #(if (= \\0 %2)\n                                                                     nil\n                                                                     %) v (seq sr)))))]\n                            (let [st (into [] stt)\n                                  co (count st)\n                                  all (for [i (range (int (Math/pow 2 co)))]\n                                        (Integer/toString i 2))\n                                  ready (map #(lo % co) all)]\n                              (into #{} (map (partial jay st) ready)))))]\n  (into #{} (filter #(= (count %) n) (power-set st)))) )","problem":103,"user":"50e87427e4b0ebbe794eb7e8"},{"problem":103,"code":"(fn [size input]\n   (let [items (repeat size input )]\n     (letfn [(f [i] \n               (if (empty? i)\n                 '(())\n                 (for [x (first i)\n                       more (f (rest i))]\n                   (into #{} (cons x more)))))]\n       (into #{} (filter #(= size (count %))  (f items))))))","user":"58d27bcae4b03c36ff7e58fe"},{"problem":103,"code":"(fn k-comb [k s]\n  (let [powerSet (reduce (fn [ss e] (into ss (map #(conj % e) ss))) #{#{}} s)]\n    (set (filter #(= k (count %)) powerSet)) ;; Only keep subsets of size k\n    )\n  )","user":"575ef4b6e4b08062f99a4e78"},{"problem":103,"code":"(fn k-combos [n s]\n  (if (> n (count s))\n    #{}\n    (->>\n      (repeatedly #(rand-int (count s)))\n      (partition n)\n      (map set)\n      (filter #(= n (count %)))\n      distinct\n      (take (/ (apply * (take n (iterate dec (count s))))\n               (apply * (take n (iterate dec n)))))\n      (map (comp set (partial map #(nth (into [] s) %))))\n      set)))","user":"53fe1b42e4b0de5c418485f1"},{"code":"(fn k-combinations\n  [n coll]\n  (cond (zero? n) [[]]\n        (empty? coll) #{} \n        :else (let [[x & xs] (seq coll)]\n                (set\n                  (concat \n                    (map (comp set (partial cons x))\n                         (k-combinations (dec n) xs))\n                    (k-combinations n xs))))))","problem":103,"user":"4dc0ff08535d020aff1edf84"},{"code":"(fn kcomb [k s]\n  (cond\n    (= k 0) #{}\n    (= k 1) (set (map #(set [%]) s))\n    (< (count s) k) #{}\n    :else (clojure.set/union\n            (kcomb k (rest s))\n            (->> (kcomb (dec k) (rest s))\n              (map #(conj % (first s)))\n              set))))","problem":103,"user":"50b668dde4b08fb537db98f2"},{"problem":103,"code":"(fn combinations [k n] (cond\n                         (zero? k) #{#{}}\n                         (> k (count n)) #{}\n                         :else (clojure.set/union \n                                (combinations k (rest n)) \n                                (set (map \n                                 #(conj % (first n)) \n                                 (combinations (- k 1) (rest n)))))))","user":"604d3cb1e4b0b7ec0ac60ac2"},{"code":"(fn combinations [n s]\n      (let [all (reduce (fn [acc i]\n                          (concat acc (set (map #(clojure.set/union % #{i}) acc)))\n                        )\n                        [#{}]\n                        s)]\n        (set (filter #(= n (count %)) all))\n      )\n    )","problem":103,"user":"5272d4b7e4b03e8d9a4a7453"},{"problem":103,"code":"(fn cnk [n xs]\n  (->> (condp < n\n         (count xs) #{}\n         1 (let [with (map (partial cons (first xs)) (cnk (dec n) (rest xs)))\n                 without (cnk n (rest xs))]\n             (clojure.set/union with without))\n         0 (map list xs))\n       (map (partial into #{}))\n       (into #{})))","user":"56d68cbae4b0ea9b8538f7cd"},{"problem":103,"code":"(fn [k s]\n    (into #{} (filter #(= (count %) k)\n          (for [x (range (Math/pow 2 (count s)))]\n            (into #{} \n                  (keep-indexed #(if (bit-test x %1) %2) s))))))","user":"56b86e64e4b0f26550335924"},{"code":"(fn k-combs [k s]\n  (cond (> k (count s)) #{}\n        (= k (count s)) #{s}\n        (= k 0) #{#{}}\n        (empty? s) #{}\n        :else (set (mapcat (fn [e] (map #(conj % e) (k-combs (- k 1) (disj s e))))\n                      s))))","problem":103,"user":"4ff769bce4b0678c553fc38f"},{"problem":103,"code":"(fn k-com [k s]\n  (cond\n   (or (= 0 k) (> k (count s))) #{}\n   (= 1 k) (reduce #(conj % #{%2}) #{} s)\n   :else (into (k-com k (rest s)) (map #(conj % (first s)) (k-com (dec k) (rest s))))\n   ))","user":"563dfc02e4b0da801c4e4662"},{"problem":103,"code":"(fn [len coll]\n         (letfn [(gen-set [a b]\n                   (set (for [x a, y b]\n                          (if (set? y)\n                            (conj y x)\n                            (into #{} [x y])))))]\n           (cond\n             (> len (count coll)) #{}\n             (= len (count coll)) #{coll}\n           :else\n           (do (println \"11111\")\n               (loop [res #{}, a coll, b (gen-set coll coll), i 1]\n                 (if (= len (count (first res)))\n                   (into #{} res)\n                   (do (println \"22222==\" i)\n                       (recur (filter #(= i (count %)) b), a, (gen-set a b), (inc i)))))))))","user":"5cf72682e4b0b71b1d808a68"},{"problem":103,"code":"(fn one-hundred-three [k s]\n  (cond\n    (> (count s) k)\n    (->> s\n         (map #(one-hundred-three k (disj s %)))\n         (apply clojure.set/union))\n\n    (= (count s) k)\n    #{s}\n\n    :else #{}))","user":"52470d42e4b05ef8e38e6350"},{"problem":103,"code":"(fn [k s] (clojure.set/select #(= k (count %)) (reduce #(into % (for [ss %] (conj ss %2))) #{#{}} s)))","user":"5fd10010e4b07e53c2f3f02a"},{"problem":103,"code":"(fn kc [k s]\n  (if (> k (count s))\n      #{}\n    (if (= 0 k)\n        #{#{}}\n      (let [m (fn [h t] (map #(conj %1 h) (kc (dec k) t)))]\n        (reduce into #{} (map #(m %1 (clojure.set/difference s #{%1})) s))))))","user":"55205564e4b08d5046aa8a60"},{"problem":103,"code":"(fn R [n S] (set (cond (= 1 n) (map (comp set list) S) (<= 1 n (count S)) (let [h (first S) T (rest S)] (into (R n T) (map #(conj % h) (R (- n 1) T)))))))","user":"55f6fe09e4b06e875b46cea2"},{"code":"#(set (map set\n  (partition %\n  ((fn f [v r n] \n  (if (< (count v) n) \n    []\n    (if (= 0 n) \n      r \n      (concat \n        (f (rest v) (concat r [(first v)]) (- n 1))\n        (f (rest v) r n))))) (vec %2) [] %))))","problem":103,"user":"4f01c938535dcb61093f6a39"},{"problem":103,"code":"(let [kcomb (fn kcomb [pre k s]\n              (let [n (count s)]\n                (if (or (> k n) (< k 0))\n                  #{}\n                  (if (= n 0)\n                    #{pre}\n                    (into (kcomb pre k (rest s)) (kcomb (conj pre (first s)) (dec k) (rest s)))))))]\n  (fn [k s] (kcomb #{} k s)))","user":"5b465b8be4b02d533a91bc65"},{"problem":103,"code":"(fn [k co]\n  (letfn [(genk [v i co k mk]\n            (if (= k mk) v\n              (for [i (range i (count co))]\n                (genk (conj v i) (inc i) co (inc k) mk))))]\n    (if (< (count co) k) #{}\n      (set (map (fn [x] (set (map (fn [y] (nth (into [] co) y)) x)))\n             (partition k (flatten (genk [] 0 co 0 k))))))))","user":"551c66dae4b07993ea3788de"},{"code":"(fn my-k-combinations\r\n  [k s]\r\n  (loop [result (map #(hash-set %) s) i 0]\r\n    (if (or (= i k) (> i k))\r\n      (set (filter #(= (count %) k) result))\r\n      (recur (set (mapcat (fn [x] (map #(conj x %) s)) result)) (inc i)))))","problem":103,"user":"509a25b7e4b0efbae1fbc0a8"},{"code":"(fn combinations [k xs]\n   (into #{}\n         (if (zero? k)\n           [ #{} ] \n           (mapcat\n             (fn [x i]\n               (map\n                 conj\n                 (combinations (dec k) (drop i xs))\n                 (repeat x)))\n             xs\n             (drop 1 (range))))))","problem":103,"user":"52dc2bc8e4b09f7907dd13ca"},{"problem":103,"code":"(fn foo [k se]\n     (cond (= k 0) #{#{}}\n           (empty? se) #{}\n            :else (let [one-of (first se) rest-of (rest se)] \n                   (clojure.set/union (foo k rest-of)\n                                      (set (map #(conj % one-of) (foo (dec k) rest-of)))))))","user":"59156f0be4b0163c97b36f3d"},{"problem":103,"code":"(fn [k s]\n      (loop [i #{#{}} j 1]\n        (if (> j k)\n          (set (filter #(= k (count %)) i))\n          (recur (apply clojure.set/union (map (fn [a] (map #(conj a %) s)) i))\n                 (inc j)))))","user":"543d5c61e4b032a45b86934d"},{"code":"(fn rec\r\n   ([num s]\r\n      (set (flatten (for [x s]\r\n                      (rec num (disj s x) #{x})))))\r\n   ([num s acc]\r\n      (if-not (= (count acc)\r\n             num)\r\n\r\n        (for [x s]\r\n          (rec num (disj s x) (conj acc x)))\r\n        acc)))","problem":103,"user":"4e0d8c27535d04ed9115e7b7"},{"problem":103,"code":"(fn comb-k [n, coll]\n   (set (filter #(= (count %) n) (reduce (fn [coll, x] (clojure.set/union coll (set (for [subset coll] (conj subset x))))) #{#{}} coll)))\n   )","user":"56f15eade4b04a395b9a048e"},{"code":"(fn [c u]\r\n  (set (filter\r\n        #(= (count %) c)\r\n        (reduce (fn [a e]\r\n                  (reduce #(conj % (conj %2 e)) a a))\r\n                #{#{}} u))))","problem":103,"user":"4dce6e41535d5973398f92a2"},{"problem":103,"code":"(fn kcs [k S]\n  (case k\n    0 #{}\n    1 (set (map hash-set S))\n    (let [subseqs (map #(drop % S) (range (inc (- (count S) k))))\n          car-kcs (fn [[x & xs]] (map #(conj % x) (kcs (dec k) xs)))]\n      (set (mapcat car-kcs subseqs)))))","user":"5339c105e4b0e30313ee6cae"},{"code":"(fn [k s]\n  (set\n   (filter #(= k (count %))\n           (reduce (fn [pset el]\n                     (into pset\n                           (map #(conj % el) pset)))\n                   #{#{}}\n                   s))))","problem":103,"user":"524b0645e4b09eba1c0223bf"},{"problem":103,"code":"(fn [k s]\n  (let [s (vec s)\n        c (count s)]\n    (set\n      (for [i (range (reduce * (repeat c 2)))\n            :when (= k (Long/bitCount i))]\n        (->> (filter #(bit-test i %) (range c))\n             (map s)\n             set)))))","user":"54ca9ca8e4b057c6fda3a265"},{"code":"(fn [k c] \n           (set (map #(->> (filter (fn [[a b]] (= \\1 b)) %) (map first) set)\n                     (for [x (range (Math/pow 2 (count c))) \n                          :when (= k (apply + (map (comp read-string str) (Integer/toString x 2))))]\n                          (partition 2 (interleave c (reverse (Integer/toString x 2))))))))","problem":103,"user":"4f34eb87e4b0e243712b1eba"},{"code":"#(nth (iterate (fn [ss] (set (remove nil? (for [s ss x %2] (if (s x) nil (conj s x))))))\n               [#{}]) %)","problem":103,"user":"519ef784e4b087743fad2198"},{"problem":103,"code":"(fn k-combi [k s]\n  (cond\n    (> k (count s)) #{}\n    (= 0 (count s)) #{}\n    (= 1 k) (into #{} (map (fn [e] #{e}) s))\n    (= k (count s)) #{s}\n    :else (set (concat\n                (map #(conj %1 (first s)) (k-combi (dec k) (disj s (first s))))\n                (k-combi k (disj s (first s)))))))","user":"5471f2fbe4b094393f72dd70"},{"code":"(fn k [n coll]\n  (cond\n   (= n (count coll)) #{(set coll)}\n   (> n (count coll)) #{}\n   :else (let [x (first coll)]\n           (set\n            (apply concat\n                   (for [y (k n (next coll))]\n                     `[~y ~@(for [z y] (conj (disj y z) x))]))))))","problem":103,"user":"507056b8e4b07bd6ad9b9f29"},{"problem":103,"code":"(fn [k s]\n  (if (> k (count s))\n    #{}\n    (letfn [(help [acc x] (into acc (map #(conj % x) acc)))]\n      (set (filter (comp (partial = k) count) (reduce help [#{}] s))))))","user":"554b8572e4b0a04f79299589"},{"code":"(fn [k s]\n  (letfn [(ps [s] (reduce (fn [ss e] (into ss (map #(conj % e) ss))) #{#{}} s))]\n    (set (remove #(not= (count %) k) (ps s)))))","problem":103,"user":"51e00020e4b01188f0627534"},{"problem":103,"code":"(fn [n xs]\n  (loop [i (int 0) res #{#{}}]\n    (if (== i n)\n      res\n      (recur (+ 1 i)\n             (set (for [x xs r res\n                        :when (not-any? #{x} r)]\n                    (conj r x)))))))","user":"529dfc6de4b04e0c58e87b8a"},{"code":"(fn __ [n items]\n    (cond \n      (zero? n)\n      #{#{}}\n\n      :else\n      (loop [items items\n             r #{}]\n        (if-not (seq items)\n          r\n          (recur (rest items)\n                 (clojure.set/union\n                   r\n                   (set\n                     (for [e (__ (dec n) (rest items))]\n                       (conj e (first items))))))))))","problem":103,"user":"521b9f92e4b0c4ef0be8304c"},{"code":"(fn p103 [k s]\n  (set (filter #(= (count %) k) (map (fn [n]\n              (set (keep-indexed #(if (bit-test n %1) %2) s)))\n         (range 0 (bit-shift-left 1 (count s)))))))","problem":103,"user":"5125745ae4b05d10e3e395f9"},{"problem":103,"code":"(fn f1 [n s]\n  (letfn [(f1 [a b]\n            (mapcat (fn [[cf & cr]]\n                      (cons (conj a cf) (f1 (conj a cf) cr)))\n                    (map #(take-last % b) (range (count b) 0 -1))))]\n    (set (filter #(= (count %) n) (f1 #{} s)))))","user":"50ae0d24e4b0a40c9cfb08ce"},{"code":"(fn f [n s]\n  (if (pos? n)\n    (if-let [[x & xs] (and (<= n (count s)) (seq s))]\n      (into (f n xs) (map #(conj % x) (f (dec n) xs)))\n      #{})\n    #{#{}}))","problem":103,"user":"4e8f1ac6535d65386fec2146"},{"code":"(fn [k S]\n   (letfn [(to-binstr  [n] (Integer/toBinaryString n))\n           (is-one?    [c] (= \\1 c))\n           (count-ones [binstr] (count (filter is-one? binstr)))\n           (k-ones?    [binstr] (= k (count-ones binstr)))\n           (to-subset  [binstr]\n             (loop [seq-S (seq S) bs (reverse binstr) acc #{}]\n               (if (seq bs)\n                 (let [next-acc (if (is-one? (first bs)) (conj acc (first seq-S)) acc)]\n                   (recur (rest seq-S) (rest bs) next-acc))\n                 acc)))]\n     (->>\n      (range  1 (int (Math/pow 2 (count S))))\n      (map to-binstr)\n      (filter k-ones?)\n      (map to-subset)\n      set)))","problem":103,"user":"4f2e0369e4b0d6649770a064"},{"problem":103,"code":"(fn kCombination[k S]\n  (cond\n    (= k 0) #{}\n    (= k 1) (apply conj #{} (for [item S] #{item}))\n    (= k (count S)) #{S}\n    (> k (count S)) #{}\n    :else (apply conj #{}\n            (for [x (kCombination (dec k) S) y S :when (not (contains? x y))]\n              (conj x y)))))","user":"56cf115de4b0ea9b8538f765"},{"problem":103,"code":"(fn [n s]\n  (loop [n n\n         r #{#{}}]\n    (if (= 0 n)\n      r\n      (recur\n        (dec n)\n        (disj (into #{}\n                    (for [e s\n                          ss r]\n                      (if (contains? ss e)\n                        nil\n                        (if (nil? ss) #{e} (conj ss e)))))\n              nil)))))","user":"58bb218be4b0888cdc949cf4"},{"problem":103,"code":"#(loop [n % a [#{}]]\n    (if (> n 0)\n      (recur (dec n) (for [x a y (apply disj %2 x)] (conj x y)))\n      (set a)))","user":"514d8084e4b019235f6c0588"},{"code":"(fn [n l]\r\n    (letfn [(worker [n l]\r\n              (cond\r\n               (zero? n) '(#{})\r\n               (or (empty? l) (< (count l) n)) ()\r\n               :else (concat (map #(conj % (first l))\r\n                                  (worker (dec n) (rest l)))\r\n                             (worker n (rest l)))))]\r\n      (set (worker n l))))","problem":103,"user":"4f474f43e4b0d56e7bb92bb7"},{"code":"(fn k [n l]  \n  (letfn [(p [ls]\n     (if (empty? ls) #{#{}}\n        (clojure.set/union (p (next ls))\n                    (into #{} (map #(conj % (first ls)) (p (next ls)))))))]\n  (set (filter #(= n (count %)) (p l)))))","problem":103,"user":"4ede8789535d10e5ff6f5337"},{"problem":103,"code":"(fn k-comb [n S]\n  (cond (or (= n 0)) #{#{}}\n        (empty? S) #{}\n        true    (clojure.set/union \n                 (k-comb n (rest S)) \n                 (into #{} (map conj (k-comb (dec n) (rest S)) (repeat (first S)))))) )","user":"57015a1de4b08d47c97781d4"},{"code":"(fn [n z] \n  (set (filter #(= (count %) n)\n               (reduce (fn [seqs b] \n                         (mapcat \n                          (fn [s] (#(map (partial conj %) z) s)) seqs)) [#{}] (range n)))))","problem":103,"user":"4ea7999e535d7eef308072ee"},{"problem":103,"code":"(fn comb [n datos]\n  (cond (= 1 n) (set (map #( hash-set %) datos))\n        :else (reduce (fn [acc x]\n                        (into acc (map #(conj % x)\n                                       (comb (dec n) (disj datos x) ))) )\n                      #{} datos)))","user":"54e51c7be4b024c67c0cf7f7"},{"code":"(fn [k s]\n  (let [combinations (fn combinations [s]\n         (if (seq s)\n             (let [f (first s)\n                   ss (combinations (rest s))]\n              (clojure.set/union ss #{#{f}} (set (map #(conj % f) ss))))\n             #{}))]\n    (set (filter #(= (count %) k) (combinations s)))))","problem":103,"user":"4f9120d8e4b0dcca54ed6c96"},{"code":"(fn combinations [k s]\n  (cond\n    (zero? k) #{#{}}\n    (empty? s) #{}\n    :else (set (clojure.set/union \n                 (map #(conj % (first s)) (combinations (dec k) (rest s)))\n                 (combinations k (rest s))))))","problem":103,"user":"5032b066e4b00c0952a257ea"},{"code":"(fn c [n s]\n  (cond\n    (> n (count s)) #{}\n   (= n 0) #{#{}}\n    :else \n    (set (concat\n      (map #(conj % (first s)) (c (dec n) (rest s)))\n      (c n (rest s))))\n  ))","problem":103,"user":"503917a0e4b088a6a14ca763"},{"problem":103,"code":"(fn [n col]\n (set\n  (filter (fn [x] (= n (count x)))\n   (reduce (fn [b x] (set (concat (map #(conj % x) b) b))) #{#{}} col))))","user":"5b0180cfe4b0cc2b61a3bd47"},{"code":"(fn [n s]\r\n  (set\r\n    (filter #(= n (count %))\r\n      (reduce\r\n        (fn [a v] (apply conj a (map #(conj % v) a)))\r\n        #{#{}}\r\n        s))))","problem":103,"user":"4e6e10d8535d5021c1a895fd"},{"code":"(letfn [(cr [c r n s S]\n          (if (zero? c) n\n            (map #(cr (dec c) (inc %) (conj n (nth (vec S) %)) s S) (range r (inc (- s c))))))]\n  #(set (flatten (cr % 0 #{} (count %2) %2))))","problem":103,"user":"50996a38e4b0cae2931060b3"},{"code":"(fn c [n s]\n  (let [[x & m] (seq s)]\n    (if x\n      (into (c n m) (map #(conj % x) (c (dec n) m)))\n      (if (= n 0) #{#{}} #{}))))","problem":103,"user":"4e8612f8535db62dc21a62f2"},{"code":"(fn [a b] (into #{} (filter #(= a (count %)) ((fn powerset [s]\n                              (let [xs (into [] s)\n                                       bsl bit-shift-left\n                                       n (count s)]\n                                (into #{}\n                          (map\n                           (fn [x]\n                               (reduce\n                                #(if\n                                     (> (bit-and (bsl 1 %2) x) 0) (conj % (xs %2)) %) #{} (range 0 n))) (range 0 (bsl 1 n)))))) b))))","problem":103,"user":"508ee17ae4b0706b2ed3ef8d"},{"problem":103,"code":"(fn choose [k s]\n   (cond (< (count s) k) #{}\n         (= (count s) k) #{s}\n         :else (set (mapcat #(choose k (disj s %)) s))))","user":"545ddac3e4b01be26fd74676"},{"problem":103,"code":"(fn solution [number s] \n  (if (< (count s) number) \n    #{} \n    (let [start (map #(conj #{} %) s)] \n      (into #{} (filter #(= (count %) number) \n                        (loop [round 1 result start] \n                          (if \n                            (= round number) result\n                            (recur (inc round) (for [x start y result] (clojure.set/union x y))\n                                   )\n                            )\n                          )\n                        )\n            )\n      )\n    )\n  )","user":"56427910e4b08d4f616f5f19"},{"problem":103,"code":"(fn k-comb [n coll]\n (letfn [(k-comb* [n coll aggr]\n   (letfn [(conj-h [a c]\n            (for [o a i c] (conj o i)))]\n     (if (= n 1) (conj-h aggr coll)\n                 (let [count (dec n)\n                        rem (rest coll)\n                        agg (conj-h aggr coll)]\n                   (recur count rem agg)))))]\n   (set \n    (filter #(= (count %) n) \n     (k-comb* n coll #{#{}})))))","user":"538e29d1e4b0b51d73faae80"},{"problem":103,"code":"(fn kCombi\n([n s] (if (> n (count s)) #{} (kCombi n s #{})))\n([n s res]\n\t(if (= n 0)\n\t\t#{res}\n\t\t(reduce #(into %1 %2) (map #(kCombi (dec n) s (conj res %)) (filter #(not (contains? res %)) s))))\n)\n)","user":"5626447fe4b00e49c7cb47bd"},{"problem":103,"code":"(fn [k s]\n  (clojure.set/select #(= k (count %))\n                      (reduce #(into % (map (fn [x] (conj x %2)) %))\n                              #{#{}}\n                              s)))","user":"5c1aadcde4b01240ff567209"},{"problem":103,"code":"(fn comb [n s]\n  (if (zero? n) #{#{}}\n    (into #{} ((fn f [l]\n      (when (seq l)\n        (into (map #(conj % (first l)) (comb (dec n) (rest l)))\n                           (f (rest l))))) s))))","user":"5590e55de4b0277789237676"},{"problem":103,"code":"(fn kombo [k S]\n  (cond \n  \n    (= k 1)\n      (->\n        (map (fn [x] #{x}) S)\n        (set))\n        \n    (> k (count S))\n      #{}\n\n    :else\n      (reduce \n        (fn [A b]\n            (->>\n              (map\n                #(conj % b)\n                (kombo\n                  (dec k)\n                  (clojure.set/difference\n                    S\n                    #{b})))\n              (set)\n            (clojure.set/union A)))\n        #{}\n        S)))","user":"5b02ab12e4b0cc2b61a3bd53"},{"problem":103,"code":"(fn [x s] \n  (let [power-set (fn [s] (loop [u #{#{}} xs s] (if (seq xs) \n                     (recur (apply (partial conj u) (map #(conj % (first xs)) u)) (next xs)) u))) \n        ps (power-set s)]\n    (set ((group-by count ps) x))))","user":"5df08767e4b093ff717275bf"},{"problem":103,"code":"; power set stolen from http://www.4clojure.com/problem/85\n(fn k-combo [n col]\n  (set \n    (filter #(= n (count %))\n            ((fn power_set[ss] (reduce (fn [s v] (concat s (map #(conj % v) s)))[#{}] ss)) col))))","user":"5f0824c5e4b0cf489e8d7f5b"},{"problem":103,"code":"(fn k-combo [k s]\n  (letfn [(pwize [accum s]\n            (concat accum\n              (map (fn [pv-set]\n                     (conj pv-set s))\n                accum)))]\n    (set  (filter #(= k (count %))\n            (reduce pwize [#{}] (vec s))))))","user":"56f9c7c6e4b07572ad1a88ba"},{"problem":103,"code":"(fn k [n s]\n  (cond\n   (> n (count s)) #{}\n   (= n 0) #{#{}}\n   :else (set (mapcat (fn [e] (map #(conj % e)\n                                   (k (- n 1) (disj s e))))\n                      s))))","user":"5742ec91e4b05c31a32c0883"},{"problem":103,"code":"(fn [k s]\n   (let [combine (fn [s x]\n                   (reduce conj s (map #(conj % x) s)))\n         power   (fn [s]\n                   (reduce combine #{#{}} s))]\n     (set (filter #(= k (count %)) (power s)))))","user":"500d3160e4b05f7c30cfa6a1"},{"code":"(fn [n s] (set (filter #(= n (count %)) (reduce (fn [r _] (set (mapcat #(map (partial conj %) s) r)) ) #{#{}} (range n)))))","problem":103,"user":"4e82f85d535db62dc21a62ce"},{"problem":103,"code":"(comp first\n      (partial apply drop)\n      (juxt (comp inc\n                  (partial apply -)\n                  (juxt (comp count second vector)\n                        (comp first vector)))\n            (comp (partial cons (hash-set))\n                  (partial iterate (partial (comp set mapcat)\n                                            (comp set\n                                                  (partial apply map)\n                                                  (juxt (partial partial disj) identity))))\n                  hash-set second vector)))","user":"5b64370ae4b0c6492753e73c"},{"problem":103,"code":"(fn [n ys]\n  (letfn [(subsets [xs] (if (empty? xs) [[]] \n                     (let [ys (-> xs rest subsets)] \n                       (into ys (map #(conj % (first xs)) ys)))))]\n    (set (map set (filter #(= n (count %)) (subsets ys))))))","user":"53976599e4b0b51d73faaeea"},{"problem":103,"code":"(fn comb [n s]\n   (cond \n      (zero? n) #{#{}}\n      (> n (count s)) #{}\n      :else\n         (let [x (first s) xs (rest s)]\n            (set (concat (comb n xs) (map #(conj % x) (comb (dec n) xs)))))))\n\n;\n;(fn comb [n s]\n;   (let [ps (fn [s] (reduce (fn [r x] (into r (map #(conj % x) r))) #{#{}} s))]\n;      (set (filter #(= (count %) n) (ps s)))))","user":"59f043d0e4b0966464fe6a3d"},{"code":"(fn [n c]\r\n  (set (loop [m n  v (for [x c] #{x})]\r\n\t\t(cond\r\n\t\t(= 1 n) v\r\n\t\t(= 0 m ) v\r\n\t\t:else  (recur (dec m) (filter #(= (inc (- n m))(count %)) (for [x v y c] (conj x y))))))))","problem":103,"user":"4ecf1f51535d1f5ad70dba3a"},{"code":"(fn k-combin [n coll]\n  (cond (or (< n 1) (> n (count coll))) #{}\n        (= n 1) (set (map #(hash-set %) coll))\n        :else (let [z (k-combin (dec n) coll)]\n                (reduce (fn [c e]\n                           (clojure.set/union c\n                                   (set (filter (fn [s]\n                                             (= n (count s)))\n                                           (map #(conj e %) coll)))))\n                        #{} z))))","problem":103,"user":"51780f88e4b03d69594194c9"},{"code":"(fn kcombinator [n s]\n      (letfn [(comb [e]\n                (let [d (clojure.set/difference s e)]                  \n                 (if (empty? d) nil\n                     (loop [ret #{} it d]\n                       (if (empty? it) ret\n                         (recur (conj ret (conj e (first it))) (rest it)))))))]                                   \n  (loop [n n c #{#{}}]\n    (cond (zero? n) c\n          (> n (count s)) #{}\n          :else (do\n                  (recur (dec n) (set (reduce concat (map comb c)))))))))","problem":103,"user":"4f4c6b21e4b03ad3f0c10c8f"},{"problem":103,"code":"#(set (filter (fn [s] (= (count s) %)) (reduce  (fn [u v] (apply merge u (map (fn [x] (if (= (count x) %2) x (conj x v))) u))) #{#{}} %2) ))","user":"5c379636e4b0d62ef62d9f76"},{"problem":103,"code":"(letfn [(subsets [n items]\n            (cond\n                  (= n 0) '(())\n                  (empty? items) '()\n                  :else (concat (map\n                                     #(cons (first items) %)\n                                     (subsets (dec n) (rest items)))\n                                (subsets n (rest items)))))]\n    (fn [n coll]\n      (->> \n        (subsets n (seq coll))\n        (map set)\n        (set)))\n        )","user":"55aa1637e4b0988bba2ad949"},{"code":"(fn [n s]\n  (letfn [(p [s]\n             (if (empty? s)\n               #{#{}}\n               (set (flatten (for [i (p (rest s))]\n                               [(set (cons (first s) i)) i])))))]\n    (set (filter (fn [c] (= (count c) n)) (p s)))))","problem":103,"user":"50bce014e4b0594b91591c63"},{"code":"(fn wat [k elements]\n  (cond\n   (> k (count elements)) #{}\n   (= 1 k) (set (map #(set (vector %)) elements))\n   :else (set (for [nxt (wat (dec k) elements)\n                    z elements\n                    :when (not (= nxt (conj nxt z)))]\n      (conj nxt z)))))","problem":103,"user":"5201ada5e4b0b2e020a18f14"},{"code":"(fn [n s]\n  (reduce \n    (fn [r _]\n      (set \n        (mapcat\n          (fn [x]\n            (map\n              #(conj x %)\n              (clojure.set/difference s x)))\n          r\n          )))\n    (set (map hash-set s))\n    (range (dec n)))\n  )","problem":103,"user":"4fbbcf0ce4b081705acca2ee"},{"code":"(fn k-combinations [k s]\n  (cond (== k 0)  #{}\n        (== k 1)  (into #{} (for [x s] #{x}))\n    :else\n    (let [k (dec k)]\n      (into #{}\n         (for [x s combination (k-combinations k (disj s x))]\n           (conj combination x))))))","problem":103,"user":"4e593dac535d8a8b8723a29c"},{"code":"(fn[n a-seq]\n  (letfn [(power-set[a-set]\n    (let [p-seq (atom []) \n        ll    (atom [])]\n    (swap! p-seq conj a-set)\n    (loop [ps @p-seq]\n      (doseq [seq-elem ps]\n        (doseq [elem seq-elem]\n          (reset! ll (set [elem]))\n          (when (not (some #(= % @ll) @p-seq))\n            (swap! p-seq conj @ll))\n          (reset! ll (set (remove #(= elem %) seq-elem)))\n          (when (not (some #(= % @ll) @p-seq))\n            (swap! p-seq conj @ll))))\n      (when (not= (count ps) (count @p-seq))\n        (recur @p-seq)))\n    (set (swap! p-seq conj #{}))))]\n  (let [s (set a-seq)]\n    (set (filter #(= (count %) n) (power-set a-seq))))))","problem":103,"user":"4e58bcd4535d8a8b8723a296"},{"problem":103,"code":"(fn generate-k-combinations [k coll]\n  (letfn [(power-set [s]  (let [first (first s) subset (rest s)]\n                            (if (empty? s) #{#{}}\n                                (clojure.set/union\n                                 (into #{} (map #(clojure.set/union #{first} %) (power-set subset)))\n                                 (power-set subset)))))]\n    (set (filter #(= k (count %)) (power-set coll)))))","user":"5693a53ee4b0dcc4269f4106"},{"code":"(letfn [(combinations [n s]\n          (if (zero? n)\n            #{#{}}\n            (set\n             (for [element s\n                   combs (combinations (dec n)\n                                       (disj s element))]\n               (conj combs element)))))]\n  (fn [num-elements orig-set]\n    (if (> num-elements (count orig-set))\n      #{}\n      (combinations num-elements orig-set))))","problem":103,"user":"5014754de4b094324338f8e5"},{"code":"(fn f [k s] (set (filter #(= (count %) k) (reduce (fn [p i] (into p (map #(conj % i) p))) #{#{}} s))))","problem":103,"user":"51f66e0ee4b06ff1c25c52c3"},{"problem":103,"code":"(fn [kk ss]\n  (letfn [ (kcomb [k v]\n                  (if (or (empty? v) (> k (count v)) )\n                    #{}\n                    (if (= k (count v))                                            \n                      #{(set v)}         \n                      (if (= k 1)\n                        (set (map (fn [arg] (hash-set arg) ) v))\n                        (clojure.set/union (kcomb k (rest v))\n                                           (set (map #(conj % (first v)) (kcomb (dec k) (rest v)) ) ))\n                        )))\n                  )\n           ]\n    (kcomb kk (vec ss)) )\n  )","user":"53c1ce3ee4b00fb29b221268"},{"problem":103,"code":"(fn [n coll] (->>\n              [coll]\n              (iterate #(for [c % x c] (disj c x)))\n              (take-while #(>= (count (first %)) n))\n              last\n              set\n             ))","user":"55a74d46e4b09e57187da2a3"},{"problem":103,"code":"(fn combinations [n xs]\n    (if (> n (count xs))\n      #{}\n      (loop\n        [\n          xs xs\n          result #{}\n        ]\n        (let\n          [\n            x (first xs)\n            xs' (rest xs)\n            last? (>= n (count xs))\n\n            yss\n            (if (= n 1)\n              [[]]\n              (combinations (dec n) xs')\n            )\n\n            result+\n            (map\n              (fn [ys]\n                (set (cons x ys))\n              )\n              yss\n            )\n\n            result' (set (concat result result+))\n          ]\n          (if last?\n            result'\n            (recur\n              xs'\n              result'\n            )\n          )\n        )\n      )\n    )\n  )","user":"5784e177e4b0ebec4cfb74cf"},{"problem":103,"code":"(fn [n s]\r\n  (set (filter #(= n (count %))\r\n               (reduce (fn [acc v]\r\n                         (filter #(>= n (count %))\r\n                                   (clojure.set/union \r\n                                     acc\r\n                                     (map #(conj % v) acc))))\r\n                       #{#{}}\r\n                       s))))","user":"53c649d3e4b00fb29b221297"},{"code":"(fn [x xs]\n(let [bin (fn [n] (map (partial bit-and 1)\n              (take-while pos? (iterate #(bit-shift-right % 1) n))))\n      binmap (fn [m] (set (mapcat #(take %1 [%2]) m xs)))\n      i (range 1 (bit-shift-left 1 (count xs)))\n      y (filter #(= x (reduce + %))  (map bin i))]\n  (set (map binmap y))))","problem":103,"user":"5201572be4b0d7096e99ddbb"},{"code":"(fn k-comb [n s]\n  (cond\n   (= n 0) #{}\n   (= n 1) (set (for [x s] #{x}))\n   1  (reduce clojure.set/union (for [x s] (set (map conj (k-comb (dec n) (disj s x)) (repeat x)))))))","problem":103,"user":"503b6995e4b07a1917cc34dd"},{"problem":103,"code":"(fn k-combinations\n  ([k xs] \n   (let [n (count xs)]\n     (if (or (> k n) (zero? k)) #{}    ;; combinatorics condition k should be less than n or not zero!\n        (set \n            (map set\n              (if (= 1 k) (partition 1 xs)     ;; -> code-as-data->yaii! 1-partitioning\n                (k-combinations k (seq xs) #{} (count xs) (dec (count xs))))))))) ;; recur compute the k-combinations\n  ([k [head & tail :as current] combinations outer-timer cycle-timer]\n   (letfn [(cycle-by [x xs]\n            (loop [chunks #{}\n                   [head & tail] xs]\n              (let [chunked (take x (cons head tail))]\n                (if (< (count chunked) x) chunks\n                  (recur (conj chunks chunked) tail)))))]\n       (if (zero? outer-timer) combinations\n         (if (zero? cycle-timer)\n           (recur k (conj (vec tail) head) ;; -> (tail head)\n                  (concat combinations (cycle-by k current))\n                  (dec outer-timer)        ;; -> ((first tail) (rest tail) head)\n                  (dec (count current)))   ;; reset cycle-timer\n           (recur k (cons head (conj (vec (rest tail)) (first tail))) ;; (head (rest tail) (first tail))\n                  (concat combinations (cycle-by k current))\n                  outer-timer              ;; not changed as the inner cycling is in progress\n                  (dec cycle-timer)))))))  ;; -> (head (rest tail) (first tail))","user":"5553b729e4b0deb715856e05"},{"problem":103,"code":"(letfn [(! [n]\n          (reduce\n           *'\n           (range 1 (inc n))))]\n  (fn [k S]\n    (let [n (count S)\n          bc (quot (! n)\n                   (* (! k)\n                      (! (- n k))))]\n      (into #{}\n            (take bc\n                  (distinct\n                   (map (comp set\n                              (partial take k))\n                        (iterate shuffle\n                                 S))))))))","user":"54246fcce4b01498b1a71aed"},{"problem":103,"code":"(fn [n s] (let [ power (fn go [s] \n  (if (empty? s) #{#{}}\n    (let [pt (go (rest s)) \n\t      ft (set (map #(conj % (first s)) pt))]\n         (clojure.set/union ft pt))))]\n  (into #{} (filter #(= n (count %)) (power s)))))","user":"53fe1c3be4b0de5c418485f2"},{"code":"(fn f [k s]\n  (cond (= k 1) (set (map #(set [%]) s))\n        (> k (count s)) #{}\n        :else (set (mapcat #(map (fn [s] (conj s %)) (f (- k 1) (disj s %))) s))))","problem":103,"user":"5054c7e1e4b0b1b9d1860eb2"},{"code":"(fn __ [n c]\n  (let [cnt (count c)]\n    (cond\n     (> n cnt) #{}\n     (= n cnt) #{c}\n     (= n 1) (set (map hash-set c))\n     :else\n     (set\n      (reduce concat (for [i (drop-last c)]\n                       (set (map #(conj % i) (__ (dec n) (remove (hash-set i) c))))))))))","problem":103,"user":"512d3304e4b040332b905b2d"},{"problem":103,"code":"(fn k-comb\n  ([n xs] (k-comb n xs #{}))\n  ([n xs s]\n    (if (zero? n) #{s}\n      (if (empty? xs) #{}\n        (clojure.set/union\n          (k-comb (dec n) (rest xs) (conj s (first xs)))\n          (k-comb n (rest xs) s))))))","user":"562cd94ee4b0a45d2ff83015"},{"problem":103,"code":"(fn combs [k s]\n  (->> (reduce (fn [s e] (into s (map #(conj % e) s))) #{#{}} s)\n       (filter #(= k (count %)))\n       set))","user":"53b39d82e4b047364c0444a6"},{"problem":103,"code":"(fn test [k s]\n  (letfn [(combi [coll k]\n            (if (empty? coll)\n              nil\n              (if (= k 1)\n                (for [x coll] #{x})\n                (loop [c coll r []]\n                  (if (empty? c)\n                    r\n                    (recur (rest c) (concat r (map #(into #{(first c)} %) (combi (rest c) (dec k))))))))))\n         ]\n    (into #{} (combi (vec s) k))))","user":"545537c1e4b0e397800069dd"},{"problem":103,"code":"(fn [n s]\n    (set\n     (reduce (fn [ks xs]\n               (for [k ks x xs\n                     :when (not (get k x))]\n                 (conj k x)))\n             (map (comp set list) s)\n             (repeat (dec n) s))))","user":"4f57c913e4b0a7574ea7183f"},{"problem":103,"code":"(fn r [n a]\n  (if (> n (count a))\n    #{}\n    (loop [res (map hash-set a) cnt 1]\n      (if (= cnt n)\n      (set (filter #(= n (count %)) res))\n      (recur\n       (reduce\n        (fn [c x] \n          (apply conj c (map (partial conj x) a)))\n        #{} res)\n       (inc cnt))))))","user":"51aefceee4b09397d5109797"},{"problem":103,"code":"(fn kcomb [k s]\n  (cond\n    (> k (count s)) #{}\n    (zero? k) #{#{}}\n    :else\n    (loop [n 0, s' s, res #{}]\n      (if (< n (count s))\n        (recur (inc n)\n               (rest s')\n               (clojure.set/union \n                res\n                (set (for [t (kcomb (dec k) (set (rest s')))]\n                       (conj t (first s'))))))\n        res))))","user":"54ca93abe4b057c6fda3a264"},{"problem":103,"code":"(fn [n s]  \n  (letfn [ \n    (comb [n s]\n      (if (or (> n (count s)) (< n 1) (empty? s))\n        #{#{}}\n        (set\n          (for [x s\n                y (comb (dec n) (disj s x))]\n            (conj y x)))))]\n    \n    (let [r (comb n s)]\n      (if (= r #{#{}}) #{} r))))","user":"574dfcb8e4b02ea11479923a"},{"problem":103,"code":"(fn [n s]\n  (set\n   (filter #(= n (count %))\n           (letfn [(a [s] (map #(disj s %) s))\n                   (f [r] (reduce into r (map a r)))]\n             (f (cons s (a s)))))))","user":"53ea5851e4b036ad0777e4e4"},{"problem":103,"code":"(fn trm\n  [width s]  \n  (if (< width 1)\n    #{#{}}\n    (set \n      (for [s (take (count s) (iterate rest s))\n            r (trm (dec width) (rest s))]\n        (conj r (first s))))))","user":"59f91b99e4b0ca45a743a33a"},{"problem":103,"code":"(fn [n coll]\n  (letfn [(subsets [coll]\n            (if (seq coll)\n              (let [[c & cs] (seq coll)\n                    subs (subsets cs)]\n                (into subs\n                      (map #(conj % c) subs)))\n              #{#{}}))]\n    (->> coll\n         subsets\n         (filter (comp (partial == n) count))\n         set)))","user":"4eda7cc3535d10e5ff6f530e"},{"code":"(fn f [n c]\n  ({0 #{#{}}} n\n      (set (mapcat #(map (fn [b] (conj b %))\n                         (f (- n 1) (remove #{%} c)))\n                   c))))","problem":103,"user":"4e12cc9d535d04ed9115e7d2"},{"code":"(fn k-comb\n  ([k s]\n   (k-comb k s #{}))\n  ([k s parts]\n   (if (or (zero? k) (> k (count s)))\n     parts\n     (reduce (fn [sets x]\n               (into sets\n                     (k-comb (dec k)\n                             (disj s x)\n                             (into #{} (if (empty? parts)\n                                         (list #{x})\n                                         (map #(conj % x) parts))))))\n             #{} s))))","problem":103,"user":"539a2901e4b0b51d73faaf0f"},{"problem":103,"code":"(fn [x c]\n  (loop [x x\n         result #{#{}}]\n    (if (zero? x)\n      result\n      (recur (dec x)\n             (reduce\n               (fn [result tmp-result]\n                 (into result\n                       (map #(conj tmp-result %1)\n                            (clojure.set/difference c tmp-result))))\n               #{}\n               result)))))","user":"50ebd63ce4b04edc3377703c"},{"code":"(fn kcomb [k xs]\n      (if (= k 0)\n              #{#{}}\n              (if (empty? xs)\n                        #{}\n                        (into #{} (concat (map #(conj % (first xs)) \n                                                       (kcomb (dec k) (into #{} (rest xs)))) \n                                                     (kcomb k (into #{} (rest xs))))))))","problem":103,"user":"4e7f5a0b535db966e863cc41"},{"code":"(fn [k S]\n      (letfn [(powerset [incoming-set]\n             (if (empty? incoming-set)\n               #{#{}}\n               (set (let [[x & xs] (seq incoming-set)\n                          T (powerset xs)]\n                      (concat T (map #(conj % x) T))))))]\n        (set (filter #(= (count %) k) (powerset S)))\n        ))","problem":103,"user":"4e9fd521535d7eef3080729a"},{"code":"(fn k-comb [k xs]\n  (cond\n   (zero? k) #{#{}}\n   (not (seq xs)) #{}\n   :else (into (k-comb k (rest xs))\n               (set (map #(conj % (first xs))\n                         (k-comb (dec k) (rest xs)))))))","problem":103,"user":"510db6cde4b078ea71921145"},{"problem":103,"code":";; Slow!\n(fn [k s]\n  ((fn f [c s]\n     (if (= k (count c))\n       #{c}\n       (reduce #(clojure.set/union % (f (conj c %2) (disj s %2)))\n               #{}\n               s)))\n   #{} s))","user":"552a793ee4b0ffed3738f955"},{"problem":103,"code":"(fn solution [n coll]\n  (let [power-set (set\n                    (reduce (fn [power element]\n                                 (concat\n                                   (map\n                                     #(conj % element)\n                                     power)\n                                   power))\n                            [#{}]\n                            coll))]\n    (set (filter #(= n (count %))\n                 power-set))))","user":"5e2ef900e4b05b4b015161fc"},{"problem":103,"code":"(fn k-comb [n sets]\n  (let [ac (fn all-comb [sets]\n                   (reduce (fn [m x]\n                             (concat m (map #(conj % x) m)))\n                           [[]]\n                           sets))\n        lst (filter #(= n (count %)) (ac sets))]\n    (set (map set lst))))","user":"56fbf83de4b07572ad1a88da"},{"code":"(fn gen-k-comb [k coll]\n  (cond\n   (> k (count coll)) #{}\n   (= k (count coll)) (conj #{} (set coll))\n   (= k 1) (set (map (fn [x] #{x}) coll))\n   :else (clojure.set/union\n          (set (map #(conj % (first coll))\n                    (gen-k-comb (dec k) (rest coll))))\n          (gen-k-comb k (rest coll)))))","problem":103,"user":"4ef6f5ea535dced4c769f250"},{"problem":103,"code":"(fn [i the-set]\n   (loop [i i\n          coll #{#{}}]\n     (if (= i 0)\n       coll\n       (recur \n        (dec i)\n        (->> (map (fn [coll] (->> (for [item the-set\n                                        :when ((complement contains?) coll item)]\n                                    (conj coll item))\n                                  (into #{}))) coll)\n             (apply clojure.set/union))))))","user":"54db3d82e4b024c67c0cf75f"},{"code":"(fn f [n' s']\n  (if (= (count s') n')\n    #{s'}\n    (letfn [(r [n s]\n              (let [ct (count s)]\n                      (cond\n                               (> n ct) #{}\n                               (= n ct) s\n                               :else (concat #{} (for [i s] (r n (disj s i)))))))]\n      (let [res (r n' s')]\n        (if-not (= (count res) 1)\n          (into #{} (flatten res))\n          res)))))","problem":103,"user":"51195e77e4b055cfb310d499"},{"code":"(fn [num start-set]\n   (letfn [(power-set [input]\n\t\t\t\t\t   (if (empty? input) \n\t\t\t\t\t     #{#{}}\n\t\t\t\t\t\t\t   (reduce\n\t\t\t\t\t\t\t  (fn ! [a b]\n\t\t\t\t\t\t\t   (if (set? a)\n\t\t\t\t\t\t\t\t\t\t  (loop [result (into #{} a) elements a]\n\t\t\t\t\t\t\t\t\t\t    (if elements\n\t\t\t\t\t\t\t\t\t\t      (recur (conj result (conj (first elements) b)) (next elements))\n\t\t\t\t\t\t\t\t\t\t      result)    \n\t\t\t\t\t\t\t\t\t\t    )\n\t\t\t\t\t\t\t       (! #{#{} #{a}} b)\n\t\t\t\t\t\t\t     )\n\t\t\t\t\t\t\t  ) input)\n\t\t\t\t\t   )\n\t\t\t\t\t   )]\n      (set (filter #(= num (count %))  (power-set start-set)))    \n     )   \n   )","problem":103,"user":"5106dc1be4b01150e115ebf0"},{"code":"(fn f [k s] (cond (> k (count s)) #{} \n                  (= 1 k) (set (for [i s] #{i})) \n                  (= k (count s)) #{(set s)}\n                  :else (clojure.set/union (f k (rest s)) (set (map #(conj % (first s)) (f (dec k) (rest s)))) )))","problem":103,"user":"52c6a0abe4b0c2d177d62111"},{"code":"(fn kcomb [n, xs]\n       (if (= n 1)\n         (set (map #(conj #{} %) xs))\n         (reduce clojure.set/union\n                 (map (fn [x]\n                        (set (map\n                              #(conj % x)\n                              (kcomb (dec n) (disj xs x)))))\n                      xs))))","problem":103,"user":"51365524e4b04ac1f358dd52"},{"code":"#(letfn [(tails [[_ & t :as xs]]\n           (when xs (cons xs (lazy-seq (tails t)))))\n         (comb [m l]\n           (if (zero? m)\n             [[]]\n             (for [[x & xs] (tails (seq l))\n                   ys (comb (dec m) xs)]\n               (set (cons x ys)))))]\n\n   (into #{} (comb %1 %2)))","problem":103,"user":"52d2ca1ce4b099d49816f0b4"},{"problem":103,"code":"(fn [n x](let [pow (lazy-seq(reduce (fn [a b] (into a (map #(into % #{b}) a))) #{#{}} x))]\n           (set(filter #(= n (count %))pow))))","user":"566a3a26e4b0a866af689699"},{"problem":103,"code":"(fn gen-k-subset\n  [k coll]\n  (let [size (count coll)]\n    (cond\n      (zero? k) #{#{}}\n      (> k size) #{}\n      (= k size) #{coll}\n      :else (let [e (first coll)]\n              (clojure.set/union (gen-k-subset k (disj coll e))\n                         (set (map #(conj % e) (gen-k-subset (dec k) (disj coll e)))))))))","user":"56a36f76e4b0542e1f8d14ca"},{"problem":103,"code":"(fn combo [k s]\n  (cond\n    (> k (count s)) #{}     ;not enough items in sequence to form a valid combo\n    (= k (count s)) #{s}    ;only one combo available: all items\n    (= 1 k) (set (map #(set (vector %)) s))     ;every item (on its own) is a valid combo\n    :else (set (map set (reduce concat (map-indexed\n            (fn [i x] (map #(cons x %) (combo (dec k) (drop (inc i) s))))\n            s))))))","user":"5eff6c0ee4b0cf489e8d7f11"},{"code":"(fn k [i s]\r\n  (set\r\n    (if (= i 0)\r\n      [#{}]\r\n      (mapcat #(for [p (k (- i 1) %2)] (conj p %))\r\n              s (next (iterate next s))))))","problem":103,"user":"4db858d1535d1e037afb218c"},{"code":"(fn kcomb [n s]\r\n  (if (= n 0) #{#{}}\r\n      (if (< (count s) n) #{}\r\n          (if (= (count s) n) #{(set s)}\r\n              (let [s1 (set (map #(conj % (first s)) (kcomb (dec n) (rest s))))\r\n                    s2 (kcomb n (rest s))]\r\n                (set (concat s1 s2)))))))","problem":103,"user":"500d1db4e4b05f7c30cfa69f"},{"problem":103,"code":"(fn subsets [n items]\n  (->> (cond\n   (= n 0) '(())\n   (empty? items) '()\n   :else (concat (map\n                  #(cons (first items) %)\n                  (subsets (dec n) (rest items)))\n                 (subsets n (rest items))))\n  \n  (map set)\n  set))","user":"54848141e4b0e286459a119e"},{"problem":103,"code":"(fn k-comb [k v-set]\n    (cond\n      (zero? k) #{#{}}\n      (empty? v-set) #{}\n      :else (let [elem      (first v-set)\n                  remainder (disj v-set elem)]\n              (clojure.set/union\n                (set (map\n                       #(conj % elem)\n                       (k-comb (dec k) remainder)))\n                (k-comb k remainder)))))","user":"5c9dcb36e4b048ec896c5b1d"},{"problem":103,"code":"(fn f [n s]\n  (cond\n   (= n 0) #{#{}}\n   (empty? s) #{}\n   :else (set (concat\n          (map #(conj % (first s))\n               (f (dec n) (rest s)))\n          (f n (rest s))))))","user":"4f956072e4b0dcca54ed6ccf"},{"problem":103,"code":"(letfn\n    [(pow [base power]\n       (reduce * (repeat power base)))\n     (bits [n]\n       (loop [n n accu [] pos 0]\n         (cond (zero? n) accu\n               (bit-test n pos) (recur (- n (pow 2 pos)) (conj accu pos) (inc pos))\n               :else (recur n accu (inc pos)))))]\n    (fn k-combo [k s]\n      (let [bitmap-max (pow 2 (count s))\n            ordered (vec s)]\n        (->> (range 0 bitmap-max)\n             (map bits)\n             (filter #(= k (count %)))\n             (map #(map ordered %))\n             (map set)\n             (set)))))","user":"58ec1e63e4b056aecfd47d54"},{"problem":103,"code":"(fn [k s]\n  (letfn [(power-set [s]\n            (letfn [(f [acc a] (into acc (map #(conj % a) acc)))]\n              (reduce f #{#{}} s)))]\n    (->>  (power-set s)\n          (filter #(= (count %) k))\n          set)))","user":"5f82609ae4b0c071e6c840f9"},{"problem":103,"code":"(fn ncomb [n s] \n  (cond\n    (> n (count s)) #{}\n    (= n 1) (set (map #(hash-set %) s))\n    :else \n    (set (apply concat \n      (for [item s]\n        (let [ ncomb-rest (ncomb (dec n) (disj s item))]\n             (map (fn [x] (conj x item)) ncomb-rest)))))))","user":"5576e78de4b05c286339e075"},{"problem":103,"code":"(letfn [(ps [xs]\n  (if (empty? xs) \n    #{#{}}\n    (loop [now (first xs)\n           left []\n           right (vec (rest xs))\n           so-far #{(set xs)}]\n      (if (empty? right)\n        (conj so-far (set left))\n        (recur (first right)\n               (into left [now])\n               (rest right)\n               (into so-far (ps (into left right))))))))\n        (kc [k xs] (set (filter #(->> % count (= k)) (ps xs))))]\n        kc)","user":"57717915e4b0979f896515b3"},{"code":"(let [powerset (fn thisfunc [s]\n  (if (empty? s)\n    #{#{}}\n    (let [result (thisfunc (rest s))]\n      (set (concat result (map #(conj % (first s)) result))))))]\n(fn [k s]\n  (set (filter #(= k (count %)) (powerset s)))))","problem":103,"user":"4dd9d299535d2dad7130b5dd"},{"code":"(fn comb [k s]\n  (if (= 1 k) (into #{} (map hash-set s))\n      (letfn [(subcombs [x]\n                (let [sub (disj s x)]\n                  (let [combs (comb (dec k) sub)]\n                    (map #(clojure.set/union #{x} %) combs))))]\n        (into #{} (apply clojure.set/union (map subcombs s))))))","problem":103,"user":"4fbd12a5e4b081705acca2fd"},{"code":"(fn k [n s]\n   (set (if (zero? n)\n          [#{}]\n          (for [x s\n                comb (k (dec n) (disj s x))]\n            (conj comb x)))))","problem":103,"user":"4eae5fe4535d7eef30807325"},{"code":"(fn f [n s]\n  (set\n   (if (<= n (count s))\n     (if (= n 1)\n       (map hash-set s)\n       (concat (map #(conj % (first s)) (f (dec n) (next s)))\n               (remove empty? (f n (next s))))))))","problem":103,"user":"4ebaf790535dfed6da9c6d6e"},{"problem":103,"code":"(fn [c x]\n  (letfn [\n          (break [x] (for [i x] (disj x i)))\n          \n          (f [c x] (cond\n                     (> c (count (first x))) #{}\n                     (= c (count (first x))) (set x)\n                     :else (f c (apply concat (map break x)))\n                     ))]\n    (f c #{x})))","user":"5c683fb5e4b0fca0c16226d5"},{"problem":103,"code":"(fn k-combinations [n s]\n  (into #{}\n        (filter #(= n (count %))\n                (nth (iterate #(into #{} (mapcat (fn [x] (for [e s] (conj x e))) %)) \n                              (map (partial conj #{}) s))\n                     (dec n)))))","user":"5492164ee4b0b312c081ff3e"},{"code":"(fn group_ [num setparam]\r\n   (let[diff (fn[colSub col]\r\n                (if (seq? colSub)\r\n                    (reduce #(disj %1 %2)  col colSub)\r\n                    (disj col colSub)\r\n                 )\r\n               ),\r\n        expend (fn[result col]\r\n                  (apply conj result  \r\n                         (map #(diff % col) col)\r\n                  )\r\n                ),\r\n        gener (fn[colp]\r\n                (println colp)\r\n                (loop[col colp,result #{}]\r\n                   (if(empty? col)\r\n                      result\r\n                      (recur (rest col) \r\n                             (expend result (first col) ) )\r\n                    )\r\n                 )     \r\n              ),\r\n        length (count setparam),\r\n        sub (- length num),\r\n        param #{setparam}]\r\n        (cond (< sub 0) #{}\r\n              (= sub 0) param\r\n              :else \r\n              (nth (iterate gener param) sub)\r\n             )\r\n        \r\n   )\r\n)","problem":103,"user":"4f6d9d7ee4b07046d9f4efcd"},{"problem":103,"code":"(fn kcomb [n coll]\n  (cond \n    (zero? n) #{#{}} \n    (> n (count coll)) #{}\n    (= n (count coll)) #{coll}  \n    :else (let [f (first coll) r (into #{}(rest coll))]\n            (clojure.set/union\n              (kcomb n r)\n              (into #{} (map (partial into #{f}) (kcomb (dec n) r)))))))","user":"566ff0a1e4b0a866af6896ec"},{"problem":103,"code":"(fn [n s]\n  (set\n    (filter #(= (count %) n)\n      (letfn [(sb [s t r n]\n                (if (zero? n)\n                  (conj r #{})\n                  (let [m (set\n                            (for [i s\n                                  j t]\n                              (clojure.set/difference j #{i})))]\n                    (sb s m (into r m) (dec n)))))]\n        (sb s #{s} #{s} (count s))))))","user":"5af907e6e4b0cc2b61a3bcda"},{"problem":103,"code":"(fn combinations [k s]\n  (letfn [(power-set [s]\n            (if (empty? s)\n              #{s}\n              (let [x (first s)\n                    without-x (power-set (set (rest s)))\n                    with-x (map #(conj % x) without-x)]\n                (clojure.set/union without-x with-x))))]\n    (set (filter #(= (count %) k) (power-set s)))))","user":"5b51b9f8e4b02d533a91bcfe"},{"problem":103,"code":"(fn comb [k xs]\n  (letfn [(powerset [ls]\n            (if (empty? ls) '(())\n                (clojure.set/union (powerset (next ls))\n                                   (map #(conj % (first ls)) (powerset (next ls))))))]\n    (into #{} (map set (filter (fn [s] (= k (count s))) (powerset xs))))))","user":"5a257747e4b07f18be40aa1f"},{"code":"(fn comb [k s]\n;  (let [vs (vec s) nn (count s)\n;        ss (for [n (range (dec (bit-shift-left 1 k)) (bit-shift-left 1 nn))\n;                 :let [subs (filter #(bit-test n %) (range n))] :when (= k (count subs))] subs) ] \n;    (set (map #(set (replace vs %)) ss))))\n  \n  (if (zero? k) #{#{}}\n  \t(set (for [e s ss (comb (dec k) (disj s e))]\n    \t(conj ss e)))))","problem":103,"user":"4effb663535dcb61093f6a2e"},{"code":"(fn [n elems]\n  (if (> n (count elems)) #{}\n    (loop [r (for [e elems] #{e}) dn (dec n)]\n      (if (zero? dn) (set (filter #(= n (count %)) r))\n       (recur (for [e elems er r](conj er e)) (dec dn))\n      )\n    )\n  )\n)","problem":103,"user":"522eba30e4b01cdb292c5f0e"},{"code":"(fn k-comb [k s]\n  (let [v (vec s)]\n    (if (= 1 k)\n      (into #{} (map #(set [%]) s))\n      (into #{} (apply concat (for [n (range (count s))]\n                                (map #((comp set conj) % (v n))\n                                     (k-comb (dec k) (disj s (v n))))))))))","problem":103,"user":"4f2baf1ae4b0d6649770a04c"},{"problem":103,"code":"(fn [k s]\n     (let [n (count s)\n           perm (fn perm [[f & xs :as all ] k]\n                  (cond\n                      (= (count all) k) [(set all)]\n                      (= 0 k) [#{}]\n                      :else (concat (map #(conj % f) (perm xs (dec k))) \n                                    (perm xs k))))]\n       (if (> k n) #{} (set (perm (seq s) k )))))","user":"5dc12b0ae4b0e59a23173d84"},{"code":"(fn comb [n s]\n  (into #{}\n    (if (zero? n)\n      '(())\n      (if (empty? s)\n        nil\n        (clojure.set/union (map #(into #{} (conj % (first s))) (comb (dec n) (rest s))) \n              (comb n (rest s))\n        )\n      )  \n    )\n  )  \n)","problem":103,"user":"5176afd2e4b085adf681d889"},{"code":"(fn g [n xs] (cond\n               (> n (count xs)) #{}\n               (= n 0) #{#{}}\n               :else (set (apply concat (for [x xs] (map #(conj  % x)  (g (dec n) (disj xs x))))))))","problem":103,"user":"50310b8be4b05b7df5a0b84d"},{"problem":103,"code":"(fn [k s]\n                              (let [digits (fn [num base] \n                                             ;; this function will only work for bases from 2 to 10\n                                             ;; please don't use base 1 :)\n                                             (if (zero? num)\n                                               '(0)\n                                               (reverse (map second \n                                                             (take-while #(not= [0 0] %) \n                                                                         (iterate (fn [[a _]] \n                                                                                    [(quot a base) (rem a base)]) \n                                                                                  [(quot num base) (rem num base)]))))))\n                                    n (count s)\n                                    binary-nums (map #(digits % 2) (range (Math/pow 2 n)))\n                                    pad-seq (repeat n 0)\n                                    padded-binary-nums (map #(take-last n (concat pad-seq %)) binary-nums )\n                                    k-ones (filter #(= k (apply + %)) padded-binary-nums)\n                                    combinations (map (fn [ones-zeros] \n                                                        (remove nil? (map (fn [one-or-zero item]\n                                                                            (if (zero? one-or-zero) nil item))\n                                                                          ones-zeros\n                                                                          (seq s)))) \n                                                      k-ones)]\n                                (into #{} (map set combinations))))","user":"54cad2d5e4b057c6fda3a26c"},{"problem":103,"code":"(fn [n x]\n(let [power-set\n(fn inner [x]\n(if (empty? x) #{#{}}\n(let [half (inner (rest x))]\n(into half (map #(conj % (first x)) half)))))]\n(set (filter #(-> % count (= n)) (power-set x)))))","user":"53d86564e4b0e771c302546b"},{"code":"(fn [k s]\n  (letfn \n    [(h [k] (if (zero? k) #{[#{} s]}\n              (set (mapcat (fn [[y n]] (map (fn [x] [(conj y x) (disj n x)]) n)) \n                           (h (dec k))))))]\n    (set (map first (h k)))))","problem":103,"user":"50fbdacfe4b0d10d794c19f0"},{"problem":103,"code":"(fn k-comb [n coll]\n  (set (if (or (>= 1 n) (empty? coll))\n        (map (comp set list) coll)\n        (->> (k-comb (dec n) (rest coll))\n             (map #((comp set cons) (first coll) %))\n             (concat (k-comb n (rest coll)))))))","user":"58dcf11ae4b0a4d5acaab6af"},{"problem":103,"code":";; yup, I actually did this\n(fn [k s]\n   (if (< (count s) k) #{}\n     (set (for [i (range 1000)]\n       (set (take k (shuffle s)))))))","user":"545e9cf1e4b01be26fd7467f"},{"problem":103,"code":";; TODO: If you take another run at this make it work when n > 4\n;; using powerset would be an easy way. Other users have faster solutions.\n(fn [n s]\n  (let [v (into [] s)\n        places (count v)\n        combos (for [a (range places)\n                     b (range places)\n                     c (range places)\n                     d (range places)]\n                 (distinct (take n [a b c d])))]\n    (->> combos\n         (map (fn do-combos [combo]\n                (map (fn do-combo [i]\n                       (nth v i))\n                     combo)))\n         (filter #(= n (count %)))\n         (map set)\n         (set))))","user":"56069006e4b08b23635d3174"},{"code":"(fn k-combinations [k s]\n  (cond (= k 0) #{#{}}\n        (= k 1) (set (map hash-set s))\n        :else (set (mapcat (fn [subset]\n                             (map #(conj % (first subset)) \n                                  (k-combinations (dec k)\n                                                  (rest subset))))\n                           (take (- (count s) (dec k))\n                                 (iterate rest s))))))","problem":103,"user":"4ee3b586535d10e5ff6f5371"},{"code":"(fn f [k s]\n  (cond\n    (= k 0) #{#{}}\n    (> k (count s)) #{}\n    1 (into (f k (next s))\n            (map #(conj % (first s))\n                 (f (- k 1) (next s))))))","problem":103,"user":"4ee82539535d93acb0a66878"},{"problem":103,"code":"(fn p [k s]\n  (apply hash-set (cond\n    (= k (count s))\n    #{(apply hash-set s)}\n    (= k 0)\n    #{}\n    (> k (count s))\n    #{}\n    (= k 1)\n    (apply hash-set (map (fn [x] #{x}) s))\n    :else\n    (let [f (first s)\n          l (rest s)]\n      (clojure.set/union\n       (map (fn [sett] (conj sett f)) (p (dec k) l))\n       (apply hash-set (p k l)))))))","user":"53664e3be4b0243289761e74"},{"problem":103,"code":"(fn k-combinations\n  [x coll]\n  (->> coll\n    (reduce\n     (fn [r x] (into r (map #(conj % x) r)))\n     #{#{}})\n    (filter #(= (count %) x))\n    set))","user":"5383668ee4b06839e8705edd"},{"problem":103,"code":"(fn k-comb [k s]\n  (letfn [(count-ones [s] (apply + s))\n          (max-bin [size] (repeat size 1))\n          (to-bin [num]\n            (loop [n num\n                   acc []]\n              (if (= n 0)\n                acc\n                (recur (quot n 2) (cons (mod n 2) acc)))))\n          (from-bin [s]\n            (loop [n 0\n                   s (reverse s)\n                   p 1]\n              (if (empty? s)\n                n\n                (recur (+ n (* (first s) p)) (rest s) (* p 2)))))\n          (pad-with-zeroes [m c]\n            (loop [acc (list* m)]\n              (if (= (count acc) c)\n                acc\n                (recur (cons 0 acc)))))\n          (apply-mask [s m]\n            (map first (filter #(= 1 (second %))\n                               (partition 2 (interleave\n                                             s\n                                             (pad-with-zeroes m (count s)))))))]\n    (if (> k (count s))\n      #{}\n      (set (for [i (range (inc (from-bin (max-bin (count s)))))\n            :let [b (to-bin i)]\n            :when (= (count-ones b) k)]\n        (set (apply-mask s b)))))))","user":"587ee260e4b052da650a6353"},{"problem":103,"code":"#(let [len (count %2)]\n  (->> (cycle %2)\n       (partition (inc len))\n       (take len)\n       (mapcat rest)\n       (partition %1 1)\n       (map set)\n       (filter (fn [s] (= %1 (count s))))\n       (set)))","user":"5de12192e4b0948ae9d9aded"},{"problem":103,"code":"(fn k-combos [n xs]\n  (into #{}\n    (if (< 1 n)\n      (for [x xs\n            y (k-combos (dec n) (disj xs x))]\n        (into #{} (cons x y)))\n      (for [x xs] #{x}))))","user":"4f5599dfe4b0a7574ea71806"},{"code":"(fn [n coll]\n    (letfn [(index-combinations\n              [n cnt]\n              (lazy-seq\n               (let [c (vec (cons nil (for [j (range 1 (inc n))] (+ j cnt (- (inc n)))))),\n                     iter-comb\n                     (fn iter-comb [c j]\n                       (if (> j n) nil\n                           (let [c (assoc c j (dec (c j)))]\n                             (if (< (c j) j) [c (inc j)]\n                                 (loop [c c, j j]\n                                   (if (= j 1) [c j]\n                                       (recur (assoc c (dec j) (dec (c j))) (dec j)))))))),\n                     step\n                     (fn step [c j]\n                       (cons (rseq (subvec c 1 (inc n)))\n                             (lazy-seq (let [next-step (iter-comb c j)]\n                                         (when next-step (step (next-step 0) (next-step 1)))))))]\n                 (step c 1))))\n            (combinations\n              [items n]      \n              (let [v-items (vec (reverse items))]\n                (if (zero? n) (list ())\n                    (let [cnt (count items)]\n                      (cond (> n cnt) nil\n                            (= n cnt) (list (seq items))\n                            :else\n                            (map #(map v-items %) (index-combinations n cnt)))))))]\n      (into #{} (map #(into #{} %) (combinations coll n)))))","problem":103,"user":"4e89e939535d3e98b8023287"},{"code":"(fn [n s] (if (> n (count s)) \n             #{} \n             (loop [result #{}] \n               (if (= (/ (apply * (range 1 (+ (count s) 1))) \n                         (* (apply * (range 1 (+ n 1))) \n                            (apply * (range 1 (+ (- (count s) n) 1))))) \n                      (count (into #{} (flatten result)))) \n                 (into #{} (flatten result)) \n                 (recur (conj (flatten result) (map #(into #{} %) (partition n (shuffle s)))))))))","problem":103,"user":"513ca934e4b0b86ece9f3228"},{"code":"(fn [! k s] (set (filter #(= k (count %)) (! s)))) (fn ![s] (conj (mapcat #(! (set (remove #{%} s))) s) s))","problem":103,"user":"4f296a80e4b0d6649770a02a"},{"code":"(fn comb [n x] (cond\n  (zero? n) #{#{}}\n  (empty? x) #{}\n  :else\n    (let [a (first x)]\n      (set (concat (comb n (disj x a))\n                   (map #(conj % a)\n                        (comb (dec n) (disj x a))))))))","problem":103,"user":"4ed94d69535d10e5ff6f5303"},{"problem":103,"code":"(fn k-combinations [k xs]\n  (cond\n    (zero? k) #{#{}}\n    (< (count xs) k) #{}\n    (= (count xs) k) #{(set xs)}\n    :else\n    (set (concat (map #(conj % (first xs))\n                      (k-combinations (dec k) (rest xs)))\n                 (k-combinations k (rest xs))))))","user":"58b81490e4b0ebc645576d8c"},{"problem":103,"code":"(fn k-combi [k s]\n  (if (or (empty? s) (> k (count s)) (= k 0))\n    #{}\n    (let [s (seq s)]\n      (loop [k (dec k)\n             r (into #{} (map (fn [a] #{a}) s))]\n        (if (= k 0)\n          r\n          (let [sr (seq r)]\n            (recur (dec k) (clojure.set/difference\n                            (reduce\n                             #(clojure.set/union\n                               %1\n                               (reduce\n                                (fn [st e] (conj st (conj %2 e)))\n                                #{}\n                                s))\n                             #{}\n                             sr)\n                            sr))))))))","user":"5f8b06afe4b0715f5002d74a"},{"code":"(fn [n x] (set (filter #(= n (count %)) ((fn p [s] (if (empty? s) #{#{}} (let [e (first s) t (disj s e)] (into (p t) ((fn f [e t] (into #{} (map #(conj % e) t))) e (p t)))))) x))))","problem":103,"user":"4eb13d60535d7eef3080733f"},{"code":"(fn k-comb [k aset]\n  (if (pos? k)\n    (set\n      (for [elem aset\n            comb (k-comb (dec k) (disj aset elem))]\n        (conj comb elem)))\n    #{#{}}))","problem":103,"user":"4f9d53f3e4b0dcca54ed6d21"},{"problem":103,"code":"(fn choose [k s]\n    (let [n (count s)\n          x (first s)\n          xs (rest s)]\n      (cond (< k 0) \"k must be greater than 0.\"\n            (> k n) #{}\n            (empty? s) #{}\n            (= k 0) #{#{}}\n            (= k n) #{(set s)}\n            :else (let [n_minus_1_choose_k (choose k xs)\n                        n_minus_1_choose_k_minus_1 (choose (- k 1) xs)]\n                      (clojure.set/union (set (map (fn [ys] (conj ys x)) n_minus_1_choose_k_minus_1))\n                                         n_minus_1_choose_k)))))","user":"5a34f342e4b0ddc586f153d1"},{"problem":103,"code":"(fn kc [k coll]\n  (if (zero? k)  \n    #{#{}}\n    (when (seq coll)\n      (into #{}\n            (for [x  coll\n                  ys (kc (dec k)\n                         (disj coll x))]\n              (conj ys x))))))","user":"53dfdf01e4b0d874e779ae46"},{"code":"(fn comb [k s]\n  (comment \"obviously ridiculously inefficient, but I already had\n     permutations written.\")\n  (letfn [(rm [s i] (concat (take i s) (drop (inc i) s)))\n          (permutations [s] \n            (condp = (count s)\n              0 () \n              1 (list s)\n              (mapcat (fn [i x] (map #(cons x %) (permutations (rm s i))))\n                      (range (count s)) s)))] \n    (if (not (<= 1 k (count s)))\n      #{}\n      (set (map #(set (take k %)) (permutations s))))))","problem":103,"user":"4ed188c8535d44c135fd68cf"},{"code":"(fn k-comb\n  [k s]\n  (if (> k (count s))\n    #{}\n    (letfn [(subsets\n              [superset base]\n              (let [a (into #{} (map (fn[e] #{e}) superset))]\n                (into #{}\n                      (filter #(= (dec (count (first base))) (count %))\n                              (mapcat (fn [e] (map (fn [i] (clojure.set/difference e i)) a)) base)))))]\n      (loop [r #{s}\n             c (count s)]\n        (if (= c k)\n          r\n          (recur (subsets s (filter #(= (count %) c) r))\n                 (dec c)))))))","problem":103,"user":"5348cab4e4b084c2834f4a5e"},{"problem":103,"code":"(fn [n s]\n  (if (< (count s) n)\n    #{}\n    (let [s (map #(set [%]) s)\n          reducer (fn [r m]\n                    (fn [a x]\n                      (let [coll (filter (fn [coll] (= (inc m) (count coll)))\n                                         (map (fn [y] (conj y (first x))) r))]\n                        (if (empty? coll)\n                          a\n                          (apply conj a coll)))))]\n      (loop [m 1\n             r s\n             ns (next s)]\n        (if (= n m)\n          (set r)\n          (recur (inc m)\n                 (into () (reduce (reducer r m) #{} ns))\n                 (next ns)))))))","user":"549c6792e4b0f3d1d8e70f8b"},{"code":"(fn k-comb [n st]\n  (let [gen-next \n         (fn [p-sets n-set]\n           (into #{} (for [p p-sets n n-set\n                           :when (not (contains? p n))]\n                       (conj p n))))\n        st-of-sts (map (fn [n] #{n}) st)]\n    (loop [i 1 out-set st-of-sts]\n      (if (= i n) (into #{} out-set)\n        (recur (inc i) (gen-next out-set st))))))","problem":103,"user":"52463059e4b09dbe66b56198"},{"problem":103,"code":"(fn k-combos\n  ([n coll accum]\n    (if (= n (count accum))\n      accum\n      (map #(k-combos n (disj coll %) (conj accum %)) coll)))\n  ([n coll]\n   (set (flatten (k-combos n coll #{})))))","user":"594266cfe4b060784b3b790b"},{"problem":103,"code":"(fn [num s] (let [powerset (fn [s]\n                              (reduce (fn [ps x]\n                                        (reduce (fn [ps s]\n                                                  (conj ps (conj s x))) ps ps)) #{#{}} s))]\n               (set(filter #(= (count %) num) (powerset s)))\n\n               ))","user":"53c73e8ae4b00fb29b2212a5"},{"code":"(fn p [n s] (let [v (vec s)] (if (= 1 n) (into #{} (map #(set [%]) v))\n     (into #{} (apply concat (for [i (range (count s))]\n\t\t(map #(set (concat [(v i)] %)) (vec (p (dec n)(disj s (v i)))))))))))","problem":103,"user":"4dae4da5c9a9d6ed4e99dc57"},{"problem":103,"code":"(fn [n someset]\n  (nth (iterate (fn[y](set (flatten (map (fn[x](map #(disj x %) x)) y)))) (hash-set someset)) (let[ z (count someset)](if (>= z n) (- z n) n) )))","user":"52bbd09ee4b07a9af57922ee"},{"problem":103,"code":"(fn [n s]\n    (->> s vec\n    ((fn [v]\n      (->>\n        (for [i (range 0 (dec (bit-shift-left 1 (count v))))]\n            (filter #(zero? (bit-and i (bit-shift-left 1 %))) (range (count v))))\n        (filter #(= n (count %))) \n        (map #(set (map v %)))\n     ) ))\n     set\n     ))","user":"5281a445e4b0757a1b17143a"},{"problem":103,"code":"(fn kc [n s]\n   (cond (or (empty? s) (<= n 0)) #{}\n         (= 1 n) (set (for [v s] #{v}))\n         :e\n         (set (mapcat (fn [v] (for [s' (kc (dec n) (disj s v))] (conj s' v))) s))))","user":"512700c4e4b083bb8f88cf14"},{"problem":103,"code":"(fn foo [n xs]\n  (if (zero? n)\n    #{#{}}\n    (set (for [s (foo (- n 1) xs)\n       \t\t   x xs\n          \t   :when (not (contains? s x))]\n      \t\t(conj s x)))))","user":"562cb7cfe4b0a45d2ff83009"},{"problem":103,"code":"(fn combinations [k s]\n  (cond\n    (> k (count s)) #{}\n    (= 0 (count s)) #{}\n    (= (count s) k) #{s}\n    :else (apply clojure.set/union (for [c s]\n                                     (let [minus-c (disj s c)\n                                           without-c (set (combinations k minus-c))\n                                           with-c (set (map #(conj % c) (combinations (dec k) minus-c)))]\n                                       (clojure.set/union without-c with-c))))))","user":"5866b999e4b0f14aab7c886b"},{"problem":103,"code":"(fn k-comb [k S]\n  (if (> k (count S))\n    #{}\n    (loop [k-it 0\n           ret-it #{#{}}]\n      (if (= k-it k)\n        (into #{} (filter #(= (count %) k) ret-it))\n        (recur (inc k-it)\n               (into #{} (mapcat (fn [s]\n                                (map #(conj % s)\n                                     ret-it))\n                              S)))))))","user":"559d33b3e4b0ec2b359424d9"},{"problem":103,"code":"(fn k-comb \n  ([n coll] \n   (set (k-comb n (vec coll) #{})))\n  ([n [x & xs :as coll] comb]\n   (cond\n    (zero? n) [comb]\n    (nil? x) nil\n    :else (->> (concat (k-comb n xs comb)\n                       (k-comb (dec n) xs (conj comb x)))\n               (remove nil?)))))","user":"55f2e47de4b06e875b46ce4d"},{"problem":103,"code":"(fn ! [n s] \n  (letfn [(tf [n p f] \n              (if (zero? n) #{p}\n                (if (empty? f) #{}\n                  (clojure.set/union \n                   (! n (rest f))\n                   (map (partial cons (first f)) \n                        (tf (dec n) \n                            (conj (vec p) (first f)) \n                            (rest f)))\n                   ))))]\n    (set (map set (tf n [] (vec s))))))","user":"52faec2ee4b047fd55837004"},{"problem":103,"code":"(fn fn-overall \n  ([n orig-set] \n   (if (> n (count orig-set)) #{} (fn-overall n orig-set\n     (set (map (partial conj #{}) orig-set)))))\n  ([n orig-set prev-sets]\n   (let [fn-new-sets (fn [orig-set prev-set]\n                       (set (map (partial conj prev-set) \n                         (clojure.set/difference orig-set prev-set))))]\n     (if (= n (count (first prev-sets))) prev-sets\n       (fn-overall n orig-set\n                   (set (mapcat #(fn-new-sets orig-set %) prev-sets)))))))","user":"575ddfd1e4b02ea11479938d"},{"code":"(fn [n s]\n  (set (loop [m 0 a [#{}]]\n         (if (= m n)\n           a\n           (recur (+ m 1) (filter #(= (+ m 1) (count %))\n                                  (for [x s y a] (conj y x))))))))","problem":103,"user":"536e0930e4b0fc7073fd6e66"},{"problem":103,"code":"(fn [k ss]\n    (->> ss\n      (repeat k)\n      (reduce    (fn [ret, xs] (into ret (for [x ret, y xs] (conj x y))))      #{#{}})\n      (filter #(= k (count %)))\n      (set))\n    )","user":"593f95d8e4b069cdc2982be3"},{"problem":103,"code":"(fn solve [k s]\n  (cond \n   (> k (count s)) #{}\n   (= k (count s)) #{s}\n   (= k 0) #{#{}}\n   :else ((comp set second) (\n   \treduce (fn [[lft res] value] [(disj lft value) (clojure.set/union res (map #(conj % value) (solve (dec k) (disj lft value))))]) [s #{}] s\n   ))))","user":"56f258d3e4b04a395b9a04a1"},{"problem":103,"code":"(fn [n s]\n (->> s\n      (reduce #(into % (map (fn[s](conj s %2)) %)) #{#{}})\n      (filter #(= n (count %1)))\n      set))","user":"4fc8f671e4b0ee37620e1840"},{"code":"(fn [t z] (letfn [(helper [s] (into #{} (vals (filter #(<= (first %) t) s))))                                                                                                                                                         \n                          (indices [s] (into [] (keep-indexed (fn [x -] x) (into [] s))))]                                                                                                                                                    \n             (if (> t (count z)) #{}                                                                                                                                                                                                          \n                 (let [a (into [] z) b (indices a) n (count z) r (assoc (assoc (reduce #(assoc % (inc %2) %2) {} (filter #(< % t) b )) (inc t) n) (+ t 2) 0)]                                                                                 \n                   (loop [acc #{} comb r k 1]                                                                                                                                                                                                 \n                     (if (> k t) acc                                                                                                                                                                                                          \n                         (let [s (loop [c comb j 1]                                                                                                                                                                                           \n                                   (if (= (c (inc j)) (inc (c j))) (recur (assoc c j (dec j)) (inc j))                                                                                                                                        \n                                       [(conj acc (into #{} (map #(a %) (helper c)))) c j]))]                                                                                                                                                 \n                           (let [c (second s) j (last s)  c1 (assoc c j (inc (c j))) ]                                                                                                                                                        \n                             (recur (conj acc (into #{} (map #(a %) (helper c1)))) c1  j)))))))))","problem":103,"user":"52265e41e4b04e78ff2e1981"},{"code":"(fn combinations [k sets]\n  (cond\n   (zero? k)\n   #{#{}}\n     \n   (< (count sets) k)\n   #{}\n     \n   :else\n   (->> (combinations (dec k) sets)\n        (mapcat #(map (partial conj %) sets))\n        (filter (comp (partial = k) count))\n        set)))","problem":103,"user":"532ab0bde4b09d4e7a9b5527"},{"code":"(fn __ [n s]\n  (cond\n   (< (count s) n) #{}\n   (= n (count s)) #{s}\n   :else (letfn [(itr [s cnt]\n                   (cond\n                    (= (- n (count s)) cnt) #{(set s)}\n                    (= cnt n) #{#{}}\n                    :else (concat\n                           (map #(conj % (first s)) (itr (rest s) (inc cnt)))\n                           (when-not (empty? (rest s))\n                             (itr (rest s) cnt)))))]\n           (set (itr s 0)))))","problem":103,"user":"504f57c7e4b0a02f9cffde71"},{"code":"(fn [n st]\n  (set (remove #(not= (count %) n)\n          (loop [s st result #{#{}}]\n            (if (empty? s) result\n                (recur (rest s) (reduce conj result (map #(conj % (first s)) result))))))))","problem":103,"user":"53300924e4b019098a6f8b55"},{"code":"(fn p103 [n col]\n   (let [power-set (fn [oldv]\n                    (let [ v (vec oldv)\n                           genset (fn [n orgset]\n                          (loop [result [] cnt n time 0]\n                            (if (= cnt 0)\n                                result\n                                (recur (if (= (mod  cnt 2) 1) (conj result (nth orgset time) )  result  ) (quot cnt 2) (inc time) ) )))\n\n\n                          ]\n                      (set (map set (map #(genset % v) (range (Math/pow 2 (count v) )))))\n                      ))\n         ]\n     (set (filter #(= (count %) n)  (power-set col) ))\n     )\n  )","problem":103,"user":"4ec5bec6535d6d7199dd36b3"},{"problem":103,"code":"(fn g\n  ([n c]\n   (into #{} (g n c #{})))\n  ([n c a]\n   (concat\n      (if (= 0 n)\n        (list a)\n        (into #{}\n          (flatten\n            (for [e c]\n              (g (- n 1)\n                 (disj c e)\n                 (conj a e)))))))))","user":"52bacfa8e4b07a9af57922d6"},{"problem":103,"code":"(fn t [n s]\n  (cond\n    (> n (count s)) #{}\n    (= n (count s)) #{(set s)}\n    (= n 1) (conj (t n (next s))\n                  #{(first s)})\n    :else (set (concat (map #(conj % (first s))\n                       (t (dec n) (next s)))\n                  (t n (next s))))\n    ))","user":"60096aabe4b074f607df667f"},{"code":"(fn [n s]\n  (letfn [(powerset [s] (reduce (fn [ps x] (reduce (fn [ps s] (conj ps (conj s x))) ps ps)) #{#{}} s))]\n    (set (filter #(= (count %) n) (powerset s)))))","problem":103,"user":"50ef9a7ae4b0bdaecbb47d9e"},{"code":";; Special cases for k=0, (count s), and larger are straightforward.\n\n;; The general case is more interesting.  The set of all\n;; k-combinations is the union (implemented with into in the code) of\n;; these two sets, considering an arbitrary element of the set x, and\n;; the remaining elements y=(disj s x).\n\n;; 1. All of the k-combinations that do not include x.  These are (c k\n;; y).\n\n;; 2. All of the k-combinations that do include x.  These are the same\n;; as all of the (k-1)-combinations of y, where each such set has x\n;; added to it.\n\n(fn k-combinations [k s]\n  (let [n (count s)]\n    (cond (> k n) #{}\n          (= k n) #{(set s)}\n          (= k 0) #{#{}}\n          :else (let [[x & y] (seq s)]\n                  (into (k-combinations k y)\n                        (map #(conj % x) (k-combinations (dec k) y)))))))","problem":103,"user":"500d8c49e4b07ccb9a7ddb00"},{"problem":103,"code":"(fn [k s]\n  (let [power-set (reduce #(into %1 (for [e %1] (conj e %2))) #{#{}} s)]\n    (set (filter #(= k (count %)) power-set))))","user":"567695c2e4b05957ce8c6157"},{"problem":103,"code":"(fn combination [n s] \n  (let [h (first s) r (rest s) c (count s)] \n    (cond \n     (> n c) #{} \n     (= n c) #{(set s)} \n     (= n 1) (set (map (fn [v] #{v}) s)) \n     :else (into (combination n r) (map #(conj % h) (combination (dec n) r))))))","user":"5392bfdee4b0b51d73faaeb2"},{"problem":103,"code":"(fn comb [n st]\n  (letfn [(redcon [x] (reduce concat x))\n          (f-comp [f n]\n            (if (= n 1)\n              f\n              (comp f (f-comp f (dec n)))))\n          (single-cleaner [lis n]\n            (cond (= n 0) lis\n                  (= n 1) lis\n                  (= n 2) (redcon lis)\n                  true ((f-comp redcon (- n 2)) (map redcon lis))))\n          (cl2   [ls sing]\n            (if (empty? ls)\n              (reverse sing)\n              (if (empty? (rest ls))\n                (cl2 (rest ls) (cons (first ls) sing))\n                (map #(cl2 % (cons (first ls) sing)) (rest ls)))))\n          (choose [st n]\n            (cond (= 0 n) ()\n                  (> n (count st)) ()\n                  true (conj\n                        (choose (rest st) n)\n                        (conj (choose (rest st) (dec n))\n                              (first st)))))\n          (result [st n]\n            (single-cleaner (map #(cl2 % ()) (choose st n)) n))]\n    (if (< (count st) n)\n      #{}\n      (set (map set (result st n))))))","user":"5d1bbef0e4b02ea6f0fb6984"},{"problem":103,"code":"(fn k-combinations [n c]\n  (letfn [(powerset [coll]\n            (reduce (fn [a x]\n                      (->> a\n                           (map #(set (concat #{x} %)))\n                           (concat a)\n                           set))\n                    #{#{}} coll))]\n    (set (filter #(= n (count %)) (powerset c)))))","user":"572ea970e4b0cd1946bd0f89"},{"code":"(fn [n s] \n  (set (nth (iterate #(for [y % x y] \n                            (disj y x)) \n                      [s]) \n        (Math/abs (- (count s) n)))))","problem":103,"user":"4e823ed7535db62dc21a62c7"},{"code":"(fn [n s] (set \n(filter #(= (count %) n)\n(loop [sts #{ #{} } coll s]\n(if (empty? coll) sts\n(recur (clojure.set/union sts\n(set (map (fn [c] (conj c (first coll)))  sts)))  (rest coll)))))))","problem":103,"user":"517945dce4b0684c1c981a43"},{"code":"(fn k-comb\n  ([n init]\n    (let [i (- (count init) n)]\n      (if (neg? i)\n        #{}\n        (loop [sets [init], i i]\n          (if (pos? i)\n            (recur \n              (for [elt init, set sets :when (contains? set elt)]\n                (disj set elt))\n              (dec i))\n            (into #{} sets)))))))","problem":103,"user":"4fb1d907e4b081705acca282"},{"problem":103,"code":"(fn  [k s]\n   (let [all-subsets (fn all-subsets [[h & tail]]\n                       (if (nil? h)\n                         [#{}]\n                         (mapcat (fn [s] [s (conj s h)]) (all-subsets tail))))]\n     (->>  (into [] s)\n           all-subsets\n           (filter #(= (count %) k))\n           (into #{}))))","user":"527ccaf4e4b0757a1b17136d"},{"problem":103,"code":"(fn k-combi\n  [n coll]\n  (loop [i n\n         c (map vector coll)]\n    (if (zero? i)\n      (set (filter #(= (count %) n) c))\n      (recur (dec i) (into #{} (map set (for [x coll\n                                              y c]\n                                          (conj y x))))))))","user":"4ee528fb535d1385b2869d87"},{"code":"(fn [n s]\n  (let [pms (fn pms [s a]\n                (if (seq s)\n                    (pms (rest s) (clojure.set/union a (for [x s y a] (conj y x))))\n                    a))]\n    (set (filter #(= n (count %)) (pms s #{#{}})))))","problem":103,"user":"4dad7adac9a9d6ed0599dc57"},{"code":"(fn [k col]\n  (if (> k (count col)) #{}\n    (loop [i k\n           res (mapv vector col)]\n      (if-not (zero? i)\n        (recur (dec i) (apply conj res (for [x res y (mapv vector col)] (into x y))))\n        (into #{} (filter #(= k (count %))(map #(into #{} %) res)))))))","problem":103,"user":"532418f3e4b09d4e7a9b54d8"},{"code":"(fn [k S]\n  (set (filter #(= k (count %))\n    ((fn pow-set [s]\n      (let [bin (fn [n] (lazy-cat \n          (reverse (map #(Integer/parseInt (str %)) \n                         (Integer/toString n 2)))\n                  (repeat 0)))]\n     (set (map (fn [i]\n      (set (keep identity \n        (map #(if (zero? %) %2 nil) (bin i) s))))\n         (range (bit-shift-left 1 (count s))))))) S))))","problem":103,"user":"4dcfbc44535d5973398f92a7"},{"code":"(fn k-combinations [k S]\n  (if (zero? k) #{#{}}\n      (reduce (fn [result i]\n                (into result\n                      (map #(conj % i)\n                           (k-combinations (dec k) (disj S i)))))\n              #{}\n              S)))","problem":103,"user":"5310e7aee4b08068f379ecdc"},{"code":"(fn komb [k s]\n  (if (== 0 k) #{#{}}\n    (if (> k (count s)) #{}\n      (let [[x & xs] (seq s)]\n        (set\n          (concat (komb k xs)\n            (map #(conj % x) (komb (dec k) xs))))))))","problem":103,"user":"50901b2ee4b0ea685a20f774"},{"problem":103,"code":"(fn [n s]\n  (letfn [(p-set [s]\n            (if (seq s)\n              (let [r (p-set (next s))]\n                (into r (map #(conj % (first s)) r)))\n              #{#{}}))]\n    (set (filter #(= n (count %)) (p-set s)))))","user":"549eb44fe4b0f3d1d8e70fa6"},{"code":"(fn kcomb [k coll]\n  (if (> k (count coll))\n    #{}\n    (let [combine (fn [all comb] (map #(conj comb %) (apply (partial disj all) comb)))]\n      (loop [n (dec k) combs (map (fn [e] #{e}) coll)]\n        (if (zero? n)\n          (set combs)\n          (recur (dec n) (reduce (fn [acc comb] (into acc (combine coll comb))) #{} combs)))))))","problem":103,"user":"5003deb9e4b0678c553fc445"},{"code":"(fn comb [n coll]\n  (letfn [(xx [n col acc]\n             (cond\n              (> n (count col)) #{}\n              (= n (count col)) [(clojure.set/union acc (set col))]\n              (= n 0) acc\n              :else\n              [(xx (dec n) (rest col) (conj acc (first col)))\n               (xx n (rest col) acc)]\n\n              ))] (set (flatten (xx n coll #{})) )) )","problem":103,"user":"52140b53e4b0961f15ac4d7e"},{"code":"(fn combinations [k xs]\n  (cond\n   (> k (count xs)) #{}\n   (= k 1) (set (map (fn [x] #{x}) xs))\n   (= k (count xs)) #{(set xs)}\n   :else (let [without-first (combinations k (rest xs))\n               rest-with-first (combinations (dec k) (rest xs))\n               with-first (map #(conj % (first xs)) rest-with-first)]\n           (set (concat without-first with-first)))))","problem":103,"user":"5186134ce4b0da5a5be3bac7"},{"problem":103,"code":"(fn combi                                                                                                                                                               \n  [n coll]                                                                                                                                                                \n  (if (> n 1)                                                                                                                                                             \n    (into #{}                                                                                                                                                             \n     (mapcat                                                                                                                                                              \n      (fn [x i]                                                                                                                                                           \n        (map (fn [s] (conj s x))                                                                                                                                          \n             (combi (dec n) (nthnext coll (inc i)))))                                                                                                                     \n      (drop-last (dec n) coll)                                                                                                                                            \n      (range)))                                                                                                                                                           \n    (into #{} (map hash-set coll))))","user":"4f1ef6a0535d64f60314649b"},{"code":"(fn f [n s]\n  (condp < 1\n    (- (count s) n -1) #{}\n    n #{#{}}\n    (reduce\n      (fn [c x]\n        (into\n          (into c (f n (disj s x)))\n          (map #(conj % x) (f (dec n) (disj s x)))))\n      #{} s)))","problem":103,"user":"52b453b0e4b0c58976d9ad21"},{"problem":103,"code":"(fn  f [k S]\n  (cond\n    (<= k 0)        #{#{}}\n    (< (count S) k) #{}\n    :otherwise      (let [head      (first S)\n                          remaining (rest S)]\n                      (set (concat (f k remaining)\n                                   (map #(conj % head)\n                                        (f (dec k) remaining)))))))","user":"57f904c5e4b0d3187e900936"},{"code":"(fn [a b] \n  (let [superset (fn superset [x] \n                   (if (= 1 (count x))\n                     #{ #{(first x)} #{}}\n                     (apply merge \n                            (superset (rest x)) \n                            (map #(into #{} (conj % (first x))) (superset (rest x))) )))] \n    (into #{}\n          (filter \n           #(= a (count %)) \n           (superset b)))))","problem":103,"user":"513b77f3e4b00f740c76c403"},{"code":"#(into #{} (if (> % (count %2)) [] \r\n ((fn f [x] (if (= % (count x)) #{x} \r\n  (apply concat (for [v x] (f (disj x v)))))) %2)))","problem":103,"user":"4fca2ef0e4b0ee37620e184e"},{"problem":103,"code":"(fn [n s] \n  (letfn [(k-combs [n s]\n                   (cond (<= n 0) #{#{}}\n                         (> n (count s)) #{}\n                         :default \n        (loop [s s a #{}]\n          (if (seq s)\n            (recur\n              (rest s)\n              (concat a\n                      (for [L (k-combs (dec n) (rest s))]\n                        (conj L (first s))\n                        )))\n            (set a)))))]\n  (k-combs n s)))","user":"504f865ee4b0a02f9cffde90"},{"code":"(fn [k s]\r\n  (if (> k (count s)) #{}\r\n    (loop [i (count s)\r\n      combs #{s}]\r\n      (if (= i k) combs\r\n        (recur (dec i)\r\n          (set\r\n            (for [c combs\r\n              e c]\r\n              (disj c e))))))))","problem":103,"user":"504e14c2e4b078edc5f593bf"},{"code":"(fn k-comb [k s]\n  (letfn [(add-to-power-set [s elem]\n             (into s (map #(conj % elem) s)))]\n    (into #{} \n          (filter #(= k (count %))\n                  (reduce add-to-power-set\n                          #{#{}}\n                          s)))))","problem":103,"user":"50812debe4b01a93d3f38e4c"},{"problem":103,"code":"(letfn [(comb [n coll] (cond (zero? n) '(())\n                             (= n 1) (map list coll)\n                             :else (mapcat\n                                     (fn [[x & xs]] (map #(cons x %) (comb (dec n) xs)))\n                                     (take (- (count coll) (dec n)) (iterate rest coll)))))]\n  #(set (map set (comb % (apply list %2)))))","user":"55ccdc6be4b0e31453f64a18"},{"problem":103,"code":"(fn f [n s]\n  (if (< n 1)\n    [#{}]\n    (reduce into #{}\n            (map #(let [[x & m] (drop % s)]\n                    (map (fn [y] (conj y x)) (f (dec n) m)))\n                 (range (- (count s) (dec n)))))))","user":"50ed4626e4b01236b1d4983c"},{"code":"(fn k-sets\n  ([size s] (k-sets #(= (count %) size) #{} s))\n  ([limit? acc tank]\n     (if (limit? acc)\n       #{acc}\n       (apply clojure.set/union\n              (for [c tank]\n                (k-sets limit? (into acc #{c}) (clojure.set/difference tank #{c})))))))","problem":103,"user":"50d8de3fe4b01f0871336e72"},{"problem":103,"code":"(fn k-combinations [k s]\n    (if (= k 1)\n      (into #{} (map (comp set list) s))\n      (let [prev-combinations (k-combinations (dec k) s)]\n        (->> (for [prev prev-combinations\n                   el s]\n               (conj prev el))\n             (filter (fn [s] (= k (count s))))\n             (into #{})))))","user":"569f4dabe4b0542e1f8d1491"},{"code":"(fn k-combination [k coll]\n  (letfn [\n    (two-pick [coll]\n      (let [[f r] (split-at 1 coll)]\n        (set (map #(set (conj f %)) r))))\n\n    (k-two-combination [coll]\n      (loop [ret #{} coll coll]\n        (if (> 2 (count coll))\n          ret\n          (recur (into ret (two-pick coll)) (rest coll)))))]\n\n    (cond\n      (> k (count coll)) #{}\n      (= k (count coll)) #{(set coll)}\n      (= k 1) (set (map (partial conj #{}) coll))\n      (= k 2) (k-two-combination coll)\n      :else\n        (reduce\n          (fn [ret ind]\n            (let [coll (drop ind coll)]\n              (into ret (map #(set (cons (first coll) %)) (k-combination (dec k) (rest coll))))))\n            #{} (range (inc (- (count coll) k)))))))","problem":103,"user":"5084c43be4b0fb8f40674bfa"},{"problem":103,"code":"(fn f [k xs]\n  (if (empty? xs)\n    ()\n    (if (= k 1)\n      (set (map set (partition 1 xs)))\n      (set (map set (concat  (map #(cons (first xs) %) (f (dec k) (rest xs)))\n                             (f k (rest xs))))))))","user":"5e12327ee4b099d064962fe5"},{"problem":103,"code":"(fn k-combinations\n  [k s]\n  (letfn [(pad [pad-val l s]\n            (if (= (count s) l)\n              s\n              (pad pad-val l (concat s (list pad-val)))))\n          (drop-last-while [pred s]\n            (->> (reverse s)\n                 (drop-while pred)\n                 (reverse)))\n          (take-last-while [pred s]\n            (->> (reverse s)\n                 (take-while pred)\n                 (reverse)))\n          (next-comb\n            [s prev]\n            (if (= prev (set (take-last (count prev) s)))\n              nil\n              (let [include-map \n                    (map (fn [e] (if (contains? prev e) :1 :0)) s)] \n                (->> (drop-last-while (partial = :1) include-map)\n                     (drop-last-while (partial = :0))\n                     (drop-last 1)\n                     (reverse)\n                     (cons :0)\n                     (cons :1)\n                     (concat (take-last-while (partial = :1) include-map))\n                     (reverse)\n                     (pad :0 (count s))\n                     (map (fn [el include] (if (= :1 include) el :0)) s)\n                     (filter (fn [e] (not= :0 e)))\n                     (set)))))]\n    (let [seq-s (seq s)]\n      (if (> k (count s))\n        #{}\n        (set (take-while (complement nil?) (iterate (partial next-comb seq-s) (set (take k seq-s)))))))))","user":"53b952eee4b047364c0444e6"},{"code":"(fn [n s]\n  (letfn [(thingaddf [ps leftover] (map #(conj % (first leftover)) ps))\n          (thingadder [[ps leftover]] \n                      [(set (conj (concat ps (thingaddf ps leftover)) #{(first leftover)}))\n                       (rest leftover)])\n          (powerset [ss]\n                    (-> (drop-while #(not-empty (second %)) \n                                    (iterate thingadder [#{#{}} ss]))\n                        first first))\n          (k-combinations [k ss] (set (filter #(= k (count %)) (powerset ss))))]\n    (k-combinations n s)))","problem":103,"user":"5133e51ae4b0d7a043de8cf6"},{"problem":103,"code":"(fn [n s] (let [x (reduce #(conj % #{%2}) #{} s) y (fn [t c] (set (for [r t l x :when (not (contains? r (first l)))] (conj r (first l)))))] (reduce #(y % %2)  x (range 1 n))))","user":"56c08696e4b060a8e693e3aa"},{"code":"; generating in reverse lexicographical order\r\n(fn [k s] (let [\r\n  n   (count s)\r\n  vs  (vec s)\r\n  nxt (fn [pr] (->> pr\r\n          (map vector (range))\r\n          (drop-while (fn [[i v]] (= i v)))\r\n          ((fn [[[i h] & t]] (if h (let [n (dec h)]\r\n            `[~@(range (- n i) n) ~n ~@(map second t)]))))))]\r\n  (->> (if (>= n k) (range (- n k) n))\r\n    (iterate nxt)\r\n    (take-while identity)\r\n    (map (partial map vs))\r\n    (map set)\r\n    set)))","problem":103,"user":"50336c6be4b0c6c1199c710f"},{"code":"(fn [k s]\n  (letfn [(f [e t] (set (for [x t] (conj x e))))]\n    (set (filter #(= (count %) k)\n                 (loop [s s, p #{#{}}]\n                   (if-let [[e] (seq s)]\n                     (recur (disj s e) (into p (f e p)))\n                     p))))))","problem":103,"user":"4ec5aa1f535d6d7199dd36b0"},{"problem":103,"code":"(fn [k S]\n  (let [power-set (fn [s]\n                    (reduce (fn [ps e]\n                              (->>\n                                ps\n                                (map #(set (concat #{e} %)))\n                                (concat ps)\n                                set))\n                            #{#{}}\n                            s))]\n    (into #{}\n          (filter #(= (count %) k) (power-set S)))))","user":"55d28b38e4b0e31453f64a58"},{"problem":103,"code":"(fn k-kombi\n  [n my-set]\n  (letfn [(power-set\n            [my-set]\n            (reduce\n             (fn combine\n               [others me]\n               (into #{} (concat others (map (fn [x] (conj x me)) others))))\n             #{#{}} my-set))]\n\n    (into #{} (filter #(= (count %) n) (power-set my-set)))))","user":"5b759ca8e4b047b03b2036d0"},{"code":"(fn [c u]\n  (set (filter #(= c (count %))\n               (reduce (fn [a e]\n                         (reduce #(conj % (conj %2 e)) a a))\n                       #{#{}} u))))","problem":103,"user":"531d34cfe4b08068f379edac"},{"problem":103,"code":"(fn k-c [n s]\n  (cond (> n (count s)) #{}\n        (= n (count s)) (conj #{} s)\n        (and (< n (count s)) (= n 1)) \n          (reduce conj #{} (map #(conj #{} %) s))\n        :else\n          (apply clojure.set/union (set (map (fn [elem] (set (map #(conj % elem) (k-c (dec n) (disj s elem))))) s)))))","user":"56288ccae4b00e49c7cb47ea"},{"problem":103,"code":"(fn combination-2 [n coll]\n  (set (filter #(= n (count %)) (reduce (fn [ret c] (concat ret (map (fn [r] (conj r c)) ret))) [#{}] coll))))","user":"541096bde4b01498b1a719b2"},{"code":"(fn [n s]\n  (let [subsets (fn [s]\n  \t\t\t(loop [result []\n  \t\t       remaining s]\n  \t\t\t  (if (seq remaining)\n \t\t     (recur (concat [[(first remaining)]] result (map #(conj % (first remaining)) result)) (rest remaining))\n                     result)))]\n    (apply hash-set (map #(apply hash-set %) (filter #(= n (count %)) (subsets s))))\n    )\n  )","problem":103,"user":"4fa340b4e4b081705acca18c"},{"problem":103,"code":"(fn [n s]\n  (cond\n    (< n 1) #{}\n    (= n 1) (set (map #(set (list %)) s))\n    (= n (count s)) (hash-set s)\n    (> n (count s)) #{}\n    :else ((fn [k d]\n              (if (not-every? #(set? %) d)\n                (recur k (for [x d] (disj d x)))\n                (if (= (count (first d)) k)\n                  (set d)\n                  (recur k (set (flatten (map #(for [x %] (disj % x)) d))))\n                  ))) n s)))","user":"5d52bf29e4b0776584bd6f69"},{"code":"(fn kc [n s]\n  (set (filter #(= n (count %)) (map set (reduce #(concat (map (fn [e] (cons %2 e)) %1) %1) #{#{}} s)))))","problem":103,"user":"4e6a2f51535d8ccf87e9fea9"},{"problem":103,"code":"(fn k-combinations [k s]\n  (if (> k (count s))\n    #{}\n    (if (= 1 k)\n      (set (map hash-set s))\n      (if (= k (count s))\n        #{s}\n        (set (map set (concat (map #(conj % (first s)) (k-combinations (- k 1) (rest s)))\n                              (k-combinations k (rest s)))))))))","user":"5d81b40ce4b0915913b1d379"},{"problem":103,"code":"(fn k-comb [k zet]\n  (into #{} (filter #(= (count %) k) \n                    (reduce (fn [r e] (into r (map #(conj % e) r))) \n                            #{#{}} \n                            zet))))","user":"57a0f256e4b0c3d858beb8dd"},{"code":"(fn k-combinations [k s]\n  (cond (= k 0)         #{#{}}\n        (> k (count s)) #{}\n        (= k (count s)) #{(set s)}\n        :else (let [[x & others] (seq s)]\n                (into (k-combinations k others)\n                      (map #(conj % x)\n                           (k-combinations (dec k) others))))))","problem":103,"user":"50586354e4b06522596eba78"},{"problem":103,"code":"(fn k-comb [k S]\n  (cond\n    (> k (count S)) #{}\n    (zero? k) #{}\n    (= k 1) (set (map #(set (list %)) S))\n    :else (into\n           (set (map #(into #{(first S)} %) (k-comb (dec k) (rest S))))\n           (k-comb k (rest S)))))","user":"5eee7311e4b07c55ae4a0510"},{"problem":103,"code":"(fn __ [n coll]\n  (if (> n (count coll))\n    #{}\n    (letfn [(cart [colls]\n              (if (empty? colls)\n                '(())\n                (for [more (cart (rest colls))\n                      x (first colls)]\n                  (cons x more))))]\n      (let [coll (vec coll)]\n        (set (map set (filter #(apply < (map (fn [x] (.indexOf coll x)) %))\n                              (cart (repeat n coll)))))))))","user":"526759b3e4b03e8d9a4a715b"},{"code":"(fn k-combs\n  [n s1]\n  (letfn [(power-set [s]\n            (reduce\n             (fn [r i]\n               (conj r\n                     (set (keep-indexed #(when (bit-test i %1) %2) s))))\n             #{#{}}\n             (range  1 (bit-shift-left 1 (count s)))))]\n    (set (filter #(= n (count %)) (power-set s1)))))","problem":103,"user":"524f4256e4b0541d1855b808"},{"code":"(fn k-co [k s]\n  (set\n    (cond \n      (or (zero? k) (> k (count s))) '()\n      (= 1 k) (map hash-set s)\n      :else\n      (reduce\n        (fn [ret i]\n          (concat ret \n            (map \n              #(conj % i) \n              (k-co (dec k) (disj s i)))))\n        '()\n        s))))","problem":103,"user":"4f050dec535dcb61093f6bef"},{"problem":103,"code":"(fn k-combinations\n  ([k coll] (k-combinations k coll #{}))\n  ([k coll acc]\n   (cond\n    (and (zero? k) (empty? acc)) #{}\n    (and (pos? k) (empty? coll)) #{}\n    (zero? k) #{acc}\n    :else (reduce into #{} [(k-combinations\n                             (dec k) (next coll) (conj acc (first coll)))\n                            (k-combinations k (next coll) acc)]))))","user":"5412ef7ee4b01498b1a719da"},{"code":"(fn k [n es]\n  (letfn [(combs [es] \n                 (if (empty? es)\n                   #{#{}}\n                   (let [t (combs (rest es))]\n                   \t(clojure.set/union (apply hash-set (map #(conj % (first es)) t)) t))))]\n    (apply hash-set (filter #(= n (count %)) (combs es)))))","problem":103,"user":"506617c3e4b03d366d7cb2ab"},{"problem":103,"code":"(fn [n s] (into #{} (filter #(= n (count %)) (reduce (fn [acc el] (into acc (map #(conj % el) acc))) #{#{}} s))))","user":"6011b89ee4b074f607df66bc"},{"code":"(fn k-comb [k xs]\n   (cond\n    (or (= k 0) (> k (count xs))) #{}\n    (= k 1) (into #{} (map (comp set list) xs))\n    :else\n       (let [x (first xs)]\n         (into #{}\n               (concat (k-comb k (disj xs x))\n                       (map #(conj % x) (k-comb (dec k) (disj xs x))))))))","problem":103,"user":"4dad8a6dc9a9d6ed1399dc57"},{"code":"(fn [n the-set] (let [result \n                      (fn f [k s]\n                        (cond\n                         (= 0 k) #{#{}}\n                         (empty? s) #{}\n                         :else (clojure.set/union (map #(conj % (first s)) (f (dec k) (rest s))) (f k (rest s)))\n                        )\n                      )]\n                  (set (result n the-set))))","problem":103,"user":"526dd90de4b03e8d9a4a72fe"},{"code":"(fn kcomb\r\n  [n the-set]\r\n\t(letfn [(comb [seta]\r\n\t\t\t\t\t\t(if (empty? seta)\r\n\t\t\t\t\t\t\t#{seta}\r\n\t\t\t\t\t\t\t(let [e (first seta), rest-set (disj seta e)]\r\n\t\t\t\t\t\t\t\t(println e \", \" rest-set \", \")\r\n\t\t\t\t\t\t\t\t(set (concat (map #(conj % e) (comb rest-set)) (comb rest-set))))))]\r\n\t\t(set (filter #(= (count %) n) (comb the-set)))))","problem":103,"user":"4e8a0c82535d3e98b802328d"},{"problem":103,"code":"(fn [n xs]\n  (let [start  (partition 1 xs)\n        func2  #(concat %1 [%2])\n        func1  #(map func2 (repeat %) xs)\n        iter   (iterate #(mapcat func1 %) start)\n        iter-n (last (take n iter))\n        no-eq  (filter #(apply distinct? %) iter-n)\n        in-set (set (map set no-eq))]\n    in-set))","user":"57e139f6e4b0bfb2137f5a6c"},{"code":"(fn k-subsets [k s]\n  (let [size (count s)]\n    (cond\n      (or (< k 0) (> k size)) #{}\n      (= k 0) #{#{}}\n      (= k (count s)) #{s}\n      :else (into\n              (set (map\n                     #(conj % (first s))\n                     (k-subsets (dec k) (disj s (first s)))))\n              (k-subsets k (disj s (first s)))))))","problem":103,"user":"526ee63de4b03e8d9a4a733f"},{"code":"(fn [n s]\r\n  (let [pms (fn pms [s a]\r\n                (if (seq s)\r\n                    (pms (rest s) (clojure.set/union a (for [x s y a] (conj y x))))\r\n                    a))]\r\n    (set (filter #(= n (count %)) (pms s #{#{}})))))","problem":103,"user":"4db4714f535dc0f10411755a"},{"code":"(fn generate-k-combinations [k s]\n  (let [create-power-set (fn [s]\n                           (let [create-set (fn [s code]\n                                              (let [v (vec s)\n                                                    r (range (count code))\n                                                    code2 (vec (map #(-> % str Integer/parseInt) (seq code)))]\n                                                (into #{} (for [i r :when (= 1 (code2 i))] (v i)))))\n                                 c (count s)\n                                 fp (if (> c 0) (str \"%0\" c \"d\") \"%d\")\n                                 combinations (int (Math/pow 2 c))\n                                 decimals (range combinations)\n                                 binaries (map #(Integer/toBinaryString %) decimals)\n                                 binaries2 (map #(format fp (Integer/parseInt %)) binaries)]\n                             (into #{} (for [x binaries2] (create-set s x)))\n                             ))]\n    (set (filter #(= k (count %)) (create-power-set s)))\n    ))","problem":103,"user":"52cf084ce4b07d0d72b27399"},{"problem":103,"code":"(fn [n coll]\n  (clojure.set/select #(= (count %) n)\n                      (reduce\n                       (fn [m k] (clojure.set/union m (map #(conj % k) m)))\n                       #{#{}} coll)))","user":"54c5cc17e4b045293a27f624"},{"problem":103,"code":"(letfn [(f [n s]\n          (if (or (> n (count s)) (= n 0))\n            '(#{})\n            (for [i s\n                  rst (f (dec n) (disj s i))]\n              (conj rst i))))]\n  #(set (remove empty? (f %1 %2))))","user":"4e0e0529535d04ed9115e7b9"},{"code":"(fn [n s]\n  (loop [ss #{s} i (count s)]\n    (if (zero? i)\n      (set (filter #(= n (count %)) ss))\n      (recur\n       (into #{s} (mapcat (fn [z] (map #(disj z %) z)) ss))\n       (dec i) ))))","problem":103,"user":"4ea365e2535d7eef308072c5"},{"code":"(fn [n s]\n   (letfn [(i [s]\n             (if (empty? s) #{#{}}\n                 (concat (map #(conj % (first s)) (i (rest s)))\n                            (i (rest s)))))]\n     (set (filter #(= n (count %)) (i s)))))","problem":103,"user":"52c25645e4b07a9af579237d"},{"problem":103,"code":"(fn filtered-power-set\n  [v s]\n  (letfn\n    [\n     (bit-on? [n b] (= (bit-and (bit-shift-right n b) 1) 1))\n     (filter-set-by-bit [s n] (let [l (apply list s)]\n                                (set (for [x (range (count s)) :when (bit-on? n x)] (nth l x))\n                                     )))]\n    (set (filter\n      #(= (count %) v)\n      (set (for [x (range (Math/pow 2 (count s)))] (filter-set-by-bit s x)))))\n\n    )\n  )","user":"5c20b6abe4b07e362c230576"},{"code":"(fn kcomb [n s]\n  (cond (= 1 n) (set (map hash-set s))\n        (empty? s) #{}\n        :else (clojure.set/union (set (map #(conj % (first s))\n                                           (kcomb (dec n) (rest s))))\n                                 (kcomb n (rest s)))))","problem":103,"user":"52736ca1e4b03e8d9a4a747e"},{"code":"(fn k [n s]\n  (if (= n 0)\n    [#{}]\n    (set\n      (mapcat\n        (fn [i]\n          (filter #(>= (count %) n)\n            (map #(conj % i) (k (- n 1) s))))\n        s))))","problem":103,"user":"4ec2fe3f535dcc7ae8597d4f"},{"code":"#(\n  (fn f [n s1 sn]\n    (if (zero? n)\n      sn\n      (f (dec n)\n                s1 \n                (set (remove nil? \n                             (for [x1 s1 x2 sn]\n                               (when-not (x2 x1)\n                                 (clojure.set/union #{x1} x2))))))))  % %2 #{#{}})","problem":103,"user":"5054bc87e4b0b1b9d1860eb0"},{"problem":103,"code":"(fn [k s]\n    (let [trans (zipmap (range) (vec s))]\n      (letfn [(nk [[i & _ :as coll] n k]\n                (if (= (count coll) k)\n                  (list (map trans coll))\n                  (mapcat #(nk (cons % coll) n k)\n                          (range (inc (or i -1)) n))))]\n        (set (map set (nk '() (count s) k))))))","user":"54f26266e4b024c67c0cf8c5"},{"problem":103,"code":"(fn [n i] (into #{} (filter #(= (count %) n) ((fn subset [s] (if (empty? s) #{#{}} (let [ts (subset (rest s))] (clojure.set/union (map #(conj % (first s)) ts) ts)))) i))))","user":"5632e850e4b0bfe05bf117ac"},{"problem":103,"code":"(fn k-sets [n s]\n  (->>\n    (loop [acc [[]] els (into [] s)]\n      (if (empty? els)\n        acc\n        (recur (concat acc (map (fn [se] (cons (first els) se)) acc)) (rest els))))\n    (filter (fn [s] (= n (count s))))\n    (map (fn [s] (into #{} s)))\n    (into #{})))","user":"53a5bc3ae4b0ef122a8689c3"},{"code":"(fn [n x]\n  (let [power-set\n          (fn inner [x]\n            (if (empty? x) #{#{}}\n              (let [half (inner (rest x))]\n                (into half (map #(conj % (first x)) half)))))]\n    (set (filter #(-> % count (= n)) (power-set x)))))","problem":103,"user":"52084f75e4b01ce6bbf31dde"},{"problem":103,"code":"(fn k [n s]\n    (if (= 1 n)\n      (set (map (fn [x] #{x}) s))\n      (set (mapcat (fn [i] (set (map #(conj % (last (take (inc i) s))) (k (dec n) (concat (take i s) (drop (inc i) s)))))) (range (count s))))\n      )\n    )","user":"5921a080e4b09b4ee5954c77"},{"code":"(let [power-set (fn power-set [xs]\n                    (reduce (fn [ps x] (into ps (map #(conj % x) ps)))\n                            #{#{}}\n                            xs))\n        k-combs (fn [k xs] (set (filter #(= (count %) k) (power-set xs))))]\n    k-combs)","problem":103,"user":"5370ef22e4b0fc7073fd6ea0"},{"problem":103,"code":"(fn [n s]\n  (letfn [(kcomb [n s r]\n            (let [v (vec s)]\n             (if (= n 0) r\n               (loop [x v res ()]\n                 (if (empty? x) res\n                   (recur (rest x) (into res (kcomb (dec n) (rest x) (cons (first x) r)))))))))]\n    (set (map #(set %) (partition n (kcomb n s #{}))))))","user":"53a1b5c8e4b0ca733b9744c1"},{"code":"(fn f [k s]\n  (set (if (= 1 k)\n    (map #(set (vector %)) s)\n    (mapcat (fn [x]\n           (map #(conj % x) (f (dec k) (remove #{x} s))))\n         s))))","problem":103,"user":"523ed522e4b057c4b7cd0a78"},{"problem":103,"code":"(fn kcomb [c s]\n  (letfn [(power [s] (set (loop [[f & r] (seq s) p '(#{})]\n                            (if f (recur r (concat p (map #(conj % f) p)))\n                                  p))))\n          ]\n    (let [power-sets (power s)\n          filtered-sets (filter  #(= (count  %) c) power-sets)\n          ]\n      (into #{} filtered-sets)\n      )\n    )\n  )","user":"5592bf9fe4b0c79f6e1db933"},{"code":"(fn kc [k s]\n  (cond\n   (< (count s) k) #{}\n   (= k 1) (set (map (comp set vector) s))\n   :else (apply clojure.set/union\n                (map-indexed (fn [i e]\n                  (set (map #(conj % e) (kc (dec k) (concat (take i s) (drop (inc i) s)))))) s))))","problem":103,"user":"524cdd51e4b0752c4cb68ccc"},{"problem":103,"code":"(fn xxx [k td]\n  (letfn [(get_set [n] (into #{} (map #(if (bit-test n %) (nth (seq td) %)) (range (count td)))))]  \n   (->>    (range (apply * (repeat (count td) 2)))\n           (map (fn [n] (get_set n)))\n           (map (fn [xs] (filter (complement nil?) xs)))\n           (filter #(= (count %) k))\n           (map set)\n           (set))))","user":"5d02fe44e4b0cc9c915881c0"},{"code":"(fn kcomb [n s]\n  (if (= n 0)\n    #{#{}}\n    (set\n     (apply concat\n            (for [itm s]\n              (map #(conj % itm) (kcomb (dec n) (disj s itm))))))))","problem":103,"user":"4e7f51eb535db966e863cc3f"},{"code":"(fn [i c] (set (filter #(= (count %) i) \n                 (reduce #(set (for [s %2 t %1] (conj t s))) \n                         #{#{}} \n                         (repeat i c)))))","problem":103,"user":"4dae916eedd6309eace4d155"},{"problem":103,"code":"(fn [n xss]\n  (let [xs (set (map #(hash-set %) xss))]\n    (into #{}\n          (reduce \n            (fn [acc i]\n              (->>\n                (for [x acc y acc] (apply conj x y))\n                (filter #(= (count %) i)))) \n            xs (range 1 (inc n))))))","user":"57d9bca1e4b0bd073c202405"},{"problem":103,"code":"(fn kcomb [k s]\n  (if (or (zero? k) (empty? s)) #{}\n   (if (= 1 k) (set (map (fn [x] #{x}) s))\n      (clojure.set/union (kcomb k (next s)) \n          (set (map #(clojure.set/union #{(first s)} %)  (kcomb (dec k) (next s))))))))","user":"54908cc1e4b0b312c081ff32"},{"code":"(fn kcomb [k s]\n  (if (= k 1)\n    (set (map #(set [%]) s))\n    (let [r (kcomb (dec k) s)]\n      (->>\n        (mapcat\n          (fn [i] (map #(conj % i) r))\n          s)\n        (filter #(= k (count %)))\n        (set)))))","problem":103,"user":"50361b6be4b0fbe0a74d26be"},{"problem":103,"code":"(fn [k s]\n  (if (or (= k 0) (empty? s))\n    #{}\n    (loop [i 1, result (into #{} (map hash-set s))]\n      (if (= k i)\n        result\n        (recur (inc i) \n               (into #{} (for [x s, subset result\n                           :when (not (contains? subset x))]\n                           (conj subset x))))))))","user":"559454f2e4b0c79f6e1db952"},{"problem":103,"code":"(fn k-combo\n  [n coll]\n  (cond\n    (and (not (coll? coll)) (> n (count coll))) #{}\n    (= n 1) (set (map (comp set list) coll))\n    :else (clojure.set/union (set (map (partial clojure.set/union #{(first coll)})\n                                       (k-combo (dec n) (next coll))))\n                             (k-combo n (next coll)))))","user":"557e9d17e4b05c286339e0d8"},{"problem":103,"code":"(fn [n s]\n  (loop [res #{#{}} i 0]\n    (if (> n (count s)) #{}\n     (if (= i n) res\n      (recur (set (apply concat (for [x s] (map #(conj % x) (filter #(not (contains? % x)) res)))))       \n(inc i))\n    )\n   )\n  )\n )","user":"5be6d0f8e4b0f319e2d7ec51"},{"problem":103,"code":"(fn subsets [n items]\n  (set (map set (cond\n                  (= n 0) '(())\n                  (empty? items) '()\n                  :else (concat (map\n                                 #(cons (first items) %)\n                                 (subsets (dec n) (rest items)))\n                                (subsets n (rest items)))))))","user":"60537cd1e4b04c8f2157d152"},{"problem":103,"code":"(fn [c s]\n  (let [t (fn [x]\n            (let [xs (set (map #(conj #{} %) x))\n                  c (count x)\n                  cx (repeat c x)]\n              (loop [x1 cx rx xs]\n                (if (empty? x1)\n                  (conj rx #{})\n                  (recur (rest x1)\n                         (into #{} (for [y1 rx y2 (first x1)]\n                                     (set (conj y1 y2)))))))))]\n       (into #{} (filter #(= c (count %)) (t s)))))","user":"566d71b1e4b0a866af6896ca"},{"problem":103,"code":"(fn [n s]\n  (letfn [(power [s] (letfn [(f [e t] (reduce #(conj %1 (conj %2 e)) #{} t))]\n                       (if (empty? s) #{s}\n                         (let [e (first s) t (disj s e)]\n                           (clojure.set/union (power t) (f e (power t)))))))]\n    (into #{} (filter #(= n (count %)) (power s)))))","user":"4f7207d3e4b07046d9f4f019"},{"code":"(fn p [n s]\n  (set\n    (filter (fn [coll] (= n (count coll)))\n      (if (= n 1)\n        (set (for [x s] (hash-set x)))\n        (set (apply concat (for [x s] (map #(conj % x) (p (- n 1) s)))))\n      )\n    )\n  )\n)","problem":103,"user":"4f84400de4b033992c121c2e"},{"code":"(fn combinations\n  ([n items]\n    (let [powerset (fn [s]\n      (reduce \n    (fn [init e] \n      (set (concat init (map #(conj % e) init) [#{e}])))\n    #{#{}} s))](combinations n (powerset items) #{})))\n  ([n powerset init]\n    (if (empty? powerset)\n      init (if (= n (count (first powerset)))\n        (recur n (rest powerset) (conj init (first powerset)))\n        (recur n (rest powerset) init)))))","problem":103,"user":"4e16bdef535d04ed9115e7e9"},{"problem":103,"code":"(fn k-combinations\n  [n s]\n  (let [power-set (fn power-set\n                    [s]\n                    (reduce\n                      (fn [init ss]\n                        (into init\n                              (for [subset init]\n                                (conj subset ss))))\n                      #{#{}} s))]\n    (set (filter #(= n (count %)) (power-set s)))))","user":"4e586949535d8a8b8723a292"},{"code":"(fn [n s]\n  (into\n   #{}\n   (filter\n    #(= n (count %))\n    (reduce \n     (fn [m v] \n       (into m \n             (map #(conj % v) m)))\n     #{#{}}\n     s))))","problem":103,"user":"519136e9e4b0f8ef0be96c01"},{"code":"(fn kc [n s]\n  (cond (= 1 n) (set (map (fn [e] #{e}) s))\n    (> n (count s)) #{}\n    :else (let [fi (first s)]\n      (set (concat (map #(conj % fi) (kc (dec n) (rest s)))\n              (kc n (rest s)))))))","problem":103,"user":"5063fe48e4b075d771da6f9e"},{"problem":103,"code":"(fn [n s-set]\n  (set (filter #(= (count %) n)\n          (reduce (fn [d-set i]\n            ((comp set flatten)\n             (map\n              (fn [i-set]\n                (map\n                 (fn [x]\n                   (conj i-set x))\n                 s-set))\n              d-set)))\n          #{#{}}\n          (range n)))))","user":"585e2e77e4b0f14aab7c87ac"},{"problem":103,"code":"(fn combos [n lst]\n  (loop [iter lst outs (list)]\n    (if (empty? iter)\n      (set (map set outs))\n      (if (= n 1)\n        (recur (rest iter) (cons (list (first iter)) outs))\n        (let [sel (first iter)\n              rst (rest iter)\n              low (combos (dec n) rst)\n              out (map #(cons sel %) low)]\n          (recur (rest iter) (concat out outs))\n          )\n        )\n      )\n    )\n  )","user":"562add6de4b00e49c7cb4834"},{"problem":103,"code":"(fn f [n xs]\n   (if (> n (count xs))\n     #{}\n     (set (filter #(= n (count %))\n                  (loop [rs (set (for [x xs] (hash-set x)))\n                         n0 1]\n                    (prn rs)\n                    (if (<= n n0)\n                      rs\n                      (recur (set (for [x xs\n                                        r rs]\n                                    (conj r x)))\n                             (inc n0))))))))","user":"557c6ca6e4b05c286339e0c4"},{"problem":103,"code":"(fn kcomb [thenum theset] (into #{} (remove #(not= (count %) thenum) (\n(fn powerset [theset] (if (empty? theset) #{#{}} (let [firstelem (first theset) workingset (next theset)]\n(let [result (powerset workingset) combined (map #(conj % firstelem) result) \nthefinal (into #{} (concat result combined))]\nthefinal\n)))) theset))))","user":"55f75c6be4b06e875b46cea9"},{"code":"(fn k-comb [k s]\n  (cond\n   (= k 0) #{#{}}  ; there is exactly 1 0-comb of any set: the empty set                                      \n   (empty? s) #{}  ; there are no k-combs of the empty set (unless k=0)                                       \n   :else (into\n          ; all k-combs involving (first s); this equals s conj'ed onto                                        \n          ; all (k-1)-combs NOT involving (first s):                                                            \n          (set (map #(conj % (first s)) (k-comb (dec k) (rest s))))\n          ; all k-combs NOT involving (first s):                                                               \n          (k-comb k (rest s))\n)))","problem":103,"user":"530bf87ee4b02e82168697d5"},{"code":"(fn [n s]\n  (->> s\n       (reduce (fn [acc x] (concat (map #(conj % x) acc) acc)) [#{}])\n       (filter #(= n (count %)))\n       set))","problem":103,"user":"50479524e4b0371827a27bc4"},{"problem":103,"code":"(fn [n S]\n  (->> (reduce (fn [a v] (clojure.set/union a (map #(conj % v) a))) #{#{}} S)\n       (filter (comp (partial = n) count))\n       set))","user":"5e3e23d9e4b01d43a70e8e20"},{"problem":103,"code":"(fn [k els']\n   (cond (= (count els') k)\n         #{els'}\n         (> k (count els'))\n         #{}\n         :else\n         (apply (comp set list) ((fn f [x els]\n                                   (println x els)\n                                   (if (= (dec x) k)\n                                     (map #(disj els %) els)\n                                     (mapcat #(f (dec x) (disj els %))\n                                             els))) (count els') els'))))","user":"54be7772e4b0ed20f4ff6eea"},{"problem":103,"code":"(fn [n si]\n  (set (reduce (fn [acc n] (filter #(= n (count %)) (mapcat (fn [v] (set (map (fn [s] (conj s v)) acc))) si)))\n                    (repeat (count si) #{})\n                    (range 1 (inc n)))))","user":"5310e968e4b08068f379ecdd"},{"code":"(fn [k s] \n  (set (filter #(= k (count %))\n   (nth\n     (iterate \n       #(into #{#{}} (for [x s y %] (into #{x} y)))\n       (map hash-set s)) \n     k))))","problem":103,"user":"51e58e02e4b0efabf93c02d0"},{"problem":103,"code":"(let [power-set (fn\n                  [x]\n                  (if (empty? x) #{#{}}\n                      (loop [[h & t] (into [] x)\n                             accum #{#{}}]\n                        (let [new-accum (into accum (map #(conj % h) accum))]\n                          (if (nil? t)\n                            new-accum\n                            (recur t new-accum))))))]\n  (fn k-comb[c s] (into #{} (filter #(= (count %) c) (power-set s)))))","user":"58152157e4b0f478707a0631"},{"problem":103,"code":"(fn [n s]\n  (let [next-subs (fn [prev-subs]\n                    (set (mapcat\n                          (fn [sub]\n                            (for [e (clojure.set/difference s sub)]\n                              (conj sub e)))\n                          prev-subs)))]\n    (nth (iterate next-subs  #{#{}}) n)))","user":"5712854ce4b07c98581c3a89"},{"problem":103,"code":"(fn subset [n coll]\n  (loop [result [()] coll (seq coll)]\n    (if (empty? coll)\n      (set (map set (filter #(= (count %) n) result)))\n      (let [[elem & remaining] coll]\n        (recur (concat result (map #(conj % elem) result)) remaining)))))","user":"563a30d7e4b0bfe05bf117f9"},{"code":"(fn ff[n lst] \n  (letfn [(tails [xs] \n            (take-while not-empty (iterate rest xs)))] \n    (if (zero? n) \n      #{#{}} \n      (set \n        (mapcat \n          (fn [[x & xs]] (map #(conj % x) (ff (dec n) xs))) \n          (tails (seq lst)))))))","problem":103,"user":"4f1fd734535d64f6031464a5"},{"code":"(fn kcomb [n s]\n  (cond\n    (> n (count s)) #{}\n    (zero? n) #{#{}}\n    :else (into\n            (kcomb n (rest s))\n            (map #(conj % (first s)) (kcomb (dec n) (rest s))))))","problem":103,"user":"527cd633e4b0757a1b17136f"},{"code":"(fn [k s]\n  (loop [s s\n         r #{#{}}]\n    (if (seq s)\n      (recur (rest s) (into r (map #(conj % (first s)) r)))\n      (set (filter #(= k (count %)) r)))))","problem":103,"user":"52753740e4b03e8d9a4a74c1"},{"problem":103,"code":"(fn k-combs [limit coll]\n  (set (loop [counter 1, accumulation (map (comp set list) coll)]\n      (if (= counter limit) accumulation\n          (recur (inc counter)\n                 (mapcat #(map (partial clojure.set/union %) (map (comp set list) (remove % coll))) accumulation))))))","user":"5f548678e4b0a0bc16850a7e"},{"code":"(fn [k coll]\n  (loop [subsets (set (map hash-set coll))\n         iter 1]\n    (if (> iter k)\n      (set (remove #(not= (count %) k) subsets))\n      (recur (set (remove #(< (count %) iter) (for [x subsets y subsets] (apply conj x y))))\n             (inc iter)))))","problem":103,"user":"4f7e29dde4b06e829148e1ca"},{"code":"(fn [n s]\n (set (filter #(= (count %) n) (set (loop [ret #{#{}}\n         left s]\n    (if (empty? left)\n      ret\n      (recur (concat (map #(conj % (first left)) ret)\n                     ret)\n             (rest left))))))))","problem":103,"user":"512eb723e4b0b740abc5982b"},{"problem":103,"code":"(fn k-combo [k aset]\n  (let [n (int (Math/pow 2 (count aset)))        \n        count-1s (fn [n]\n                   (count (filter #(= \\1 %) (seq (Integer/toString n 2)))))\n        masks (map (fn [b] (map #(= % \\1)\n                                (#(rest (seq (Integer/toString % 2))) (+ b n))))\n                   (filter (fn [m] (= k (count-1s m))) (range n)))]\n    (set (map (fn [m] (set (filter identity (map #(when %2 %1) aset m))))\n              masks))))","user":"579d9601e4b05b1deef9ae18"},{"problem":103,"code":"(fn k-comb [n s]\n  (cond\n   (or (zero? n) (zero? (count s))) #{}\n   (= 1 n) (into #{} (map #(set [%]) s))\n   :else\n    (let [f (first s)\n          r (rest s)]\n      (clojure.set/union\n       (k-comb n r)\n       (into #{} (map #(conj %1 f) (k-comb (- n 1) r)))))))","user":"5553b924e4b0deb715856e06"},{"code":"(fn k-com [n s]\n  (letfn [(power-set [s]\n            (letfn [(one-less [s] (map #(disj s %) s))\n            (power-set [s] (map one-less (set (flatten s))))]\n            (set (flatten (take (inc (count s)) (iterate power-set [[s]]))))))]\n  (if (> n (count s)) #{}\n    (set (filter #(= n (count %)) (power-set s))))))","problem":103,"user":"501c1492e4b086d93747d180"},{"code":"(fn [k s]\n           (into #{}\n                 (map #(into #{} %)\n                      (map (fn [x](map #(last %) \n                                       (filter (fn [y] (= (first y) \\1))\n                                               (partition 2 \n                                                          (interleave x \n                                                                      s)))))\n                           (let [n (count s)] \n                                (filter (fn [x] (= k (count (filter #(= \\1 %) x))))  \n                                        (map #(apply str (concat (take (- n (count %)) (cycle [\\0])) %))\n                                             (map #(Integer/toString % 2) \n                                                  (range (Math/pow 2 \n                                                                   n))))))))))","problem":103,"user":"4f03f197535dcb61093f6b84"},{"problem":103,"code":"(fn [n s]\n  (set (filter #(= n (count %)) (reduce (fn [a c] (into a (map #(conj % c) a))) #{#{}} s))))","user":"5e6ca949e4b04a83ad7cd289"},{"code":"(fn k-combinations [k set]\n  (letfn [(collect-sets [acc coll]\n            (if (some true? (map set? coll))\n              (reduce #(if (some set? %2)\n                         (into %1 (collect-sets [] %2))\n                         (conj %1 %2)) [] coll)\n              coll))\n          (k-combinations-acc [chosen set]\n            (if (= (count chosen) k)\n              chosen\n              (reduce conj #{} (map #(k-combinations-acc (conj chosen %) (disj set %)) set))))]\n    (if (> k (count set))\n      #{}\n      (reduce conj #{} (collect-sets #{} (k-combinations-acc #{} set))))))","problem":103,"user":"4ff355a1e4b0678c553fc34d"},{"problem":103,"code":"(fn [n s]\n  (set \n    (filter \n      #(= (count %) n)\n      (reduce (fn [r e] (into r (map #(conj % e) r))) #{#{}} s))))","user":"53ce4cd4e4b00fb29b2212ef"},{"problem":103,"code":"(fn combinations [sz population]\n  (->> (cond\n         (= sz 0) '(())\n         (empty? population) '()\n         :else (concat (mapv #(cons (first population) %) (combinations (dec sz) (rest population)))\n                       (combinations sz (rest population))))\n       (map set)\n       (into #{})))","user":"561d8936e4b064ca9f4b16b2"},{"problem":103,"code":"(fn [n myset]\n  (if (< (count myset) n)\n    #{}\n    (let [cart_prod (fn [set1 set2] \n                        (prn set1 set2)\n                        (if (empty? set2) \n                            (map #(into #{} %) (partition 1 set1)) \n                            (into #{} (for [x set1 y set2] \n                                           (if (coll? x) (conj x y) (into #{} [x y]))))))\n          setofsets (repeat n myset)\n          cart_result (loop [s (drop 2 setofsets)\n                             result (cart_prod (first setofsets) (second setofsets))]\n                        (if (empty? s)\n                            result\n                            (recur (drop 1 s)\n                                   (cart_prod result (first s)))))]\n      (into #{} (filter #(= (count %) n) cart_result)))))","user":"567d18c9e4b05957ce8c61c4"},{"problem":103,"code":"(fn kombset [k xs]\n  (letfn [\n     (komb1 [xs]\n            (set (map #(conj #{} %) xs))\n     )\n          \n     (extset [nxs xs]\n   \t    (if (= 0 (count nxs))\n            (komb1 xs)\n     \n        (for [s nxs , k1 xs]\n         (set  (conj s k1))\n        ))\n     )     \n          \n     (komb [k c nxs xs]\n   \t   (cond (= k (count xs) )\n                    (conj #{} (set xs))\n         (> k (count xs))\n                    #{}\n         :else \n            (if (= c k)\n               nxs \n               (recur k (inc c) \n                  (set  (filter #(= (count %) (+ c 1))\n                             (extset nxs xs)) )  xs)\n\n             )\n     )\n    )\n   ]     \n \n    (komb k 0 #{} xs)\n  )\n)","user":"59ff9424e4b01bb0ae8afd24"},{"code":"(fn [n s]\n  (let [p (fn [c n s]\n               (cond (zero? n) (assoc c 0 #{})\n                     (= n 1) (assoc c 1 (set (map hash-set s)))\n                     :else (assoc c n\n                                  (reduce into #{}\n                                          (for [i s]\n                                            (map #(conj % i) (c (dec n))))))))]\n       (cond\n        (< (count s) n) #{}\n        (= (count s) n) (hash-set (set s))\n        :else (set (filter #(= (count %) n)\n                           ((reduce #(p % %2 s) {} (range (count s))) n s))))))","problem":103,"user":"514fd753e4b0b449e54b8e00"},{"problem":103,"code":"(fn k-combinations\n  [k s]\n  (if (= k 0) #{#{}}\n              (let [recursion (k-combinations (dec k) s)]\n                (set (mapcat\n                   (fn [x] (map #(conj % x) (filter #(not (% x)) recursion)))\n                   s))))\n  )","user":"5c3ac091e4b0d62ef62d9f95"},{"code":"(fn [k s]\r\n(let [gen (fn gen [s] \r\n              (let [mem (atom {})\r\n                    swapmem (fn [args f_n] \r\n                              (if-let [e (find @mem args)]\r\n                                (val e)\r\n                                (let [ret (f_n)]\r\n                                  (swap! mem assoc args ret)\r\n                                  ret)))\r\n                    f (fn f [fst rst result k] \r\n                        (if (or (empty? rst) (= (count fst) k))\r\n                          (conj result fst)\r\n                          (set \r\n                            (mapcat \r\n                              (fn [arg] \r\n                    (let [n_fst (conj fst arg)\r\n                          n_rst (disj rst arg)\r\n                          n_result (conj result fst)]\r\n                      (conj (swapmem n_fst #(f n_fst n_rst n_result k)) fst)))\r\n                  rst))))]\r\n                (f #{} s #{} k))\r\n            )]\r\n  (set (filter #(= (count %) k) (gen s)))\r\n  ))","problem":103,"user":"4f0da4e4535d0136e6c22319"},{"problem":103,"code":"(fn [n s]\n  (set (filter #(= (count %) n) (reduce #(apply conj %1 (for [x %1] (conj x %2))) #{#{}} s)))\n  )","user":"55e1d34ae4b050e68259b421"},{"problem":103,"code":"(fn comb [k s]\n    (cond \n      (= k 0) #{#{}}\n      (> k (count s)) #{}\n      :else (clojure.set/union\n              (comb k (rest s))\n              (set (map #(conj % (first s)) (comb (dec k) (rest s)))))))","user":"5bd0ea60e4b0e9689409ee45"},{"code":"(fn [n c] \n  (->> (iterate #(for [s % x c] (conj s x)) [#{}])\n       (take (inc n)) last \n       (filter #(= n (count %))) set))","problem":103,"user":"4dada16fc9a9d6ed2699dc57"},{"code":"(fn k-comb [k v]\n  (cond\n    (> k (count v)) #{}\n    true (set ((reduce\n           (fn [m v]\n             (let [added-v (conj (map #(conj %1 v) (:inprogress m)) #{v})\n                   new-inprogress (clojure.set/union (filter #(> k (count %)) added-v) (:inprogress m))\n                   new-ready (clojure.set/union (:ready m) (filter #(= k (count %)) added-v))\n                   ]\n               {:ready new-ready\n                :inprogress new-inprogress}\n               )\n             )\n           {:ready #{}\n            :inprogress #{}\n            }\n           v) :ready) )\n    ))","problem":103,"user":"5094057fe4b097f48cc38593"},{"code":"; generate binary numbers up to 2^(count s), take the ones with k ones as indices into s\n(fn f [k s]\n  (letfn [(to-binary [n] (map #(Integer/parseInt (str %))\n                              (seq (Integer/toString n 2))))\n          \n          (count-vs [v s] (count (filter #(= % v) s)))\n          \n          (pad0 [n s] (let [d (- n (count s))]\n                        (if (> d 0) (into (into [] (repeat d 0)) s) s)))]\n    \n    (let [indices (map (partial keep-indexed #(when (= 1 %2) %1))\n                    (map (partial pad0 (count s))\n                      (filter #(= k (count-vs 1 %))\n                        (map to-binary (range (Math/pow 2 (count s)))))))\n          s-ordered (into [] s)]\n      (into #{} (map #(into #{} (map (partial nth s-ordered) %)) indices)))))","problem":103,"user":"52d3f666e4b09f7907dd1327"},{"problem":103,"code":"(fn K-comb [k S]\n  (if (zero? k) #{ #{} }\n    (if (> k (count S)) #{}\n      (set (apply concat (for [i S]\n        (map #(conj % i) (K-comb (dec k) (remove #{i} S)))))))))","user":"579f4812e4b05302be0b72fb"},{"problem":103,"code":"(fn bleh [k S]\n  (let [fola (fn fola [darray tarray acc]\n               (let [farray (if (and (empty? acc) \n                                (> (count darray) (count tarray)))\n                                        (flatten (cons (repeat (- (count darray) (count tarray)) \"0\") tarray)) \n                                tarray)]\n                        (if (> (count darray) 0) \n                                (if (= (first farray) \"1\") \n                                        (fola (rest darray) (rest farray) (conj acc (first darray))) \n                                        (fola (rest darray) (rest farray) acc)) \n                        acc)))\n        n (count S)]\n        (set (map #(set %) (filter #(not (not %)) \n                (for [i (range 1 (inc (int (Math/pow 2 n))))]\n                                (if (= k (count (filter #(= % \"1\") (clojure.string/split (Integer/toString i 2) #\"\"))))\n                                        (fola S (rest (clojure.string/split (Integer/toString i 2) #\"\")) []))))))))","user":"52747090e4b03e8d9a4a74a5"},{"problem":103,"code":"(fn  [n S] \n  (letfn [ \n   (solve [res cur rems]\n     (cond\n         (= (count cur) n) (conj res cur)\n         (empty? rems)     res\n         :else (let [ used (solve res (conj cur (first rems)) (rest rems))\n                      skip (solve res cur (rest rems))]\n                 \n                 (clojure.set/union used skip))))]\n  \n      (solve #{} #{} S)))","user":"564127a9e4b08d4f616f5ef3"},{"problem":103,"code":"(fn kcomb[k nlist]\n\t(cond\n\t\t(or (= k 0) (= (count nlist) 0) (> k (count nlist))) (set [])\n\t\t(= k 1) (set (map #(identity #{%}) nlist))\n\t\t(= k (count nlist)) (set [(set nlist)])\n\t\t(= 1 1) (set (clojure.set/union\n\t\t\t(for ; (kcomb 1 #{1 2})\n\t\t\t\t[child (kcomb (- k 1) (rest nlist))]\n\t\t\t\t(conj child (first nlist))\n\t\t\t)\n\t\t\t(kcomb k (rest nlist))\n\t\t))\n\t)\n)","user":"5d73530ce4b02e6b30c93514"},{"code":"(fn [l s]\n          (set (filter #(= l (count %)) (reduce #(into % (for [subset %] (conj subset %2))) #{#{}} s))))","problem":103,"user":"51424cc8e4b0b50abeb46b34"},{"code":"(fn combinations [n coll]\n  (let [apply-sets (fn [coll] (into #{} (map #(hash-set %) coll)))\n\t\t  setcoll (apply-sets coll)\n\t\t  merge-combinations (fn [original subs]\n\t\t\t(reduce #(clojure.set/union %1 %2) \n\t\t\t\t(for [x subs]\n\t\t\t\t\t(into #{} (for [y original] (conj x y)))\n\t\t\t\t)\n\t\t\t)\n\t\t)]\n \t(if (= n 1) setcoll\n\t\t(into #{} (filter #(= n (count %)) (loop [res setcoll iters 1]\n\t\t\t(if (= iters n) res\n\t\t\t\t(recur (merge-combinations coll res) (inc iters))\n\t\t\t)\n\t\t)))\n\t)\n\t)\n)","problem":103,"user":"50588af1e4b06522596eba7d"},{"problem":103,"code":"(fn [n s]\n  (let [pwr (fn pwr [s]\n    (if (empty? s)\n      #{#{}}\n      (let [ls (into '() s)\n            rst (into '() (pwr (set (rest ls))))]\n        (set (concat rst \n                     (map #(conj % (first ls)) rst))))))]\n    (set (filter #(= (count %) n) (pwr s)))))","user":"541ef7e2e4b01498b1a71a92"},{"problem":103,"code":"(fn [n xs]\n  (if (< (count xs) n) \n    #{}\n    (letfn\n        [(union [s1 s2]\n           (reduce #(conj %1 %2) s1 s2)\n           )\n         (go\n           [r m ys]\n           (if (= 0 m)\n             r\n             (reduce\n              union\n              (for [e ys]\n                (go\n                  (into #{} (for [q r] (conj q e)))\n                  (dec m)\n                  (disj ys e)))\n              )))]\n      (into #{}\n            (filter #(= n (count %))\n                    (go (into #{} (for [e xs] #{e}))\n                        (dec n)\n                        xs))))))","user":"53ef7f77e4b0742d9025b0ce"},{"code":";; bit string approach is more performant than a recursive one\n;; for wider combinations:\n;;   e.g. \"7 #{1 2 3 4 5 6 7 8 9 10 11 12 13 14 15}\"\n(fn combinations [k s]\n  (let [log2 #(int (Math/ceil \n                     (/ (Math/log %) (Math/log 2))))\n        k-bits? (fn [n k] \n                  (= k (count (filter #(bit-test n %) (range (inc (log2 n)))))))\n        k-comb (fn [s n] \n                 (keep #(if (bit-test n %) (s %)) (range (inc (log2 n)))))\n        v (vec s)]\n    (reduce (fn [c n] \n              (if (k-bits? n k) \n                (conj c (set (k-comb v n))) \n                c)) \n            #{} \n            (range 1 (Math/pow 2 (count s))))))","problem":103,"user":"50c781bbe4b00bb60fe0c535"},{"code":"(fn [n s]\n  (letfn [\n    (power-set [s]\n      (if (empty? s) #{#{}}\n        (let [\n          s1 (first s)\n          ps (power-set (rest s))]\n          (reduce #(conj % (conj %2 s1)) ps ps)))) ]\n  (set (filter #(= n (count %)) (power-set s)))))","problem":103,"user":"4fd22e70e4b04c3a95aa041c"},{"problem":103,"code":"#(let [power-set (fn [c] (reduce (fn [s1 s2] (into s1 (for [x s1] (conj x s2)))) #{#{}} c))\nfi-f (fn [x] (= (count x) %1))]\n(->> %2\n(power-set)\n(filter fi-f)\n(set)))\n;power-set function based on amalloy's solution of problem 85 Power Set","user":"5e13a6b7e4b099d064963001"},{"problem":103,"code":"(fn q [n s](let [ all (reduce (fn [a b](into a (map #(conj % b) a))) #{#{}} s)]\n(set(filter #(= n (count %)) all))))","user":"5849ac5fe4b089d5ab817ed7"},{"problem":103,"code":"(fn p-103 [n coll]\n  (into #{}\n        (filter #(= n (count %))\n                (reduce (fn [power-set new-elem]\n                          (clojure.set/union\n                            power-set\n                            (map #(conj % new-elem) power-set)))\n                        #{#{}}\n                        coll))))","user":"501d34f6e4b066e56b9d0b1e"},{"code":"(fn [k s]\n    (loop [acc #{#{}} cnt 1]\n      (if (> cnt k)\n        (->> acc (filter #(= k (count %))) set)\n        (recur (apply clojure.set/union\n                      (map (fn [a] (map #(conj a %) s)) acc))\n               (inc cnt)))))","problem":103,"user":"52e3e6a8e4b09f7907dd1448"},{"problem":103,"code":"(letfn [(k-com [n s] \n  (if (= n 1) \n    (set (map #(set (list %)) s))\n      (set (for [s' s r (k-com (dec n) (disj s s'))] \n        (conj  r s')))))]k-com)","user":"58e7229fe4b056aecfd47cc4"},{"problem":103,"code":"(fn prob103\n  [num seq]\n  (set (map set   \n            (cond\n              (= num 0) '(())\n              (empty? seq) '()\n              :else (concat \n                     (map (fn [it] (cons (first seq) it)) (prob103 (dec num) (rest seq)))\n                     (prob103 num (rest seq)))))))","user":"4ebbff41535dfed6da9c6d78"},{"code":"(fn k-combinations [k ls]\n  (letfn [(drop-while-with [x xs]\n            (rest (drop-while #(not= x %) xs)))\n          (combinations [num xs ys]\n            (cond\n             (= num 0) xs\n             (empty? ys) (list)\n             :else (map #(combinations (dec num)\n                                       (conj xs %)\n                                       (drop-while-with % ys))\n                        ys)))]\n    (-> (combinations k #{} ls) (flatten) (set))))","problem":103,"user":"523b82efe4b07becd5be21f0"},{"code":"(fn [k s]\n  (loop [c #{#{}} i 0]\n    (if (= i k)\n        (set (keep #(if (= (count %) k) %) c))\n        (recur\n          (for [p c q s] (conj p q))\n          (inc i)))))","problem":103,"user":"4f9597e0e4b0dcca54ed6cd4"},{"code":"(fn [n s] \n  (->> \n    (count s)\n    (Math/pow 2)\n    (range 1) \n    (map \n      (fn [i] \n        (keep-indexed \n          #(when (bit-test i %) %2)\n          s))) \n    (filter #(= n (count %))) \n    (map set) \n    set))","problem":103,"user":"4f991ec1e4b0dcca54ed6cfb"},{"problem":103,"code":"(fn combos [k coll]\n  (if (<= k (count coll))\n    (if-not (zero? k)\n      (set (mapcat (fn [item]\n                     (map #(conj % item)\n                          (combos (dec k) (disj coll item))))\n                   coll))\n      #{#{}})\n    #{}))","user":"575cbe44e4b02ea114799374"},{"code":"(fn kc [k s]\n  (if (> k (count s))\n    #{}\n    (let [ordered (vec s)\n          indexed (map-indexed vector ordered)]\n      (if (= k 1)\n        (set (map (fn [x] #{x}) s))\n        (set\n         (mapcat (fn [n]\n                   (map #(conj % (ordered n)) (kc (dec k) (subvec ordered (inc n)))))\n                 (range (inc (- (count ordered) k)))))))))","problem":103,"user":"50d93c53e4b0fd36a4b89223"},{"code":"(fn kc[n s]\n  (let [distrib \n        (fn[e ss] (set (map #(set (cons e %)) ss)))\n        distrib-all\n        (fn[s ss] (set (mapcat #(distrib % ss) s)))\n        ]\n    (loop [m n res #{#{}}]\n      (if (= 0 m)\n        (set (filter #(= n (count %)) res))\n        (recur (dec m) (distrib-all s res))))))","problem":103,"user":"4dbd2aa3535d020aff1edf40"},{"code":"(fn [n s]\n   (letfn [(mix [cs e] (map #(conj (disj cs %) e) cs))] \n     (reduce (fn [r x]\n               (into r (mapcat #(mix % x) r)))\n             (if (> n (count s)) #{} #{(set (take n s))})\n             (drop n s))))","problem":103,"user":"50f48298e4b004d364930527"},{"code":"(fn [n sss]\n  ((fn ! [n [s & ss :as sss]]\n     (cond\n      (== n 0) #{#{}}\n      (<= n (count sss)) (clojure.set/union\n                          (into #{} (map #(conj % s) (! (dec n) ss)))\n                          (! n ss))\n      :else #{}))\n   n (seq sss)))","problem":103,"user":"51aa2b4fe4b04e3dc0c27b21"},{"code":"(fn [k is]\n  (let [pset (fn [is]\n               (reduce\n                 (fn [ps i]\n                   (reduce\n                     (fn [ps p] \n                       (conj ps (conj p i)))\n                     ps ps))\n                 #{#{}} is))]\n    (set (filter \n          #(= (count %) k)\n          (pset is)))))","problem":103,"user":"50fbf811e4b0d10d794c19f1"},{"problem":103,"code":"(fn f\n  [n s]\n  (let [ss (seq s)]\n    (apply (comp set concat)\n           (for [i (range (count ss))]\n             (let [iv (nth ss i)]\n               (if (= n 1)\n                 (list (set (list iv)))\n                 (map #(conj % iv) (f (dec n) (drop (inc i) ss)))))))))","user":"56bb652ae4b0f26550335953"},{"code":"(fn [n xs]\r\n  (letfn [(combinations [n]\r\n            (if (zero? n)\r\n              #{#{}}\r\n              (into #{}\r\n                    (mapcat (fn [s] (map (fn [x] (conj s x)) (remove s xs)))\r\n                            (combinations (dec n))))))]\r\n    (combinations n)))","problem":103,"user":"4e8338d6535db62dc21a62d3"},{"problem":103,"code":"(fn [l s]\n  (reduce\n    (fn [a k]\n        (->> a\n             (map (fn [x] (map #(conj x %) s)))\n             (apply concat)\n             (remove a)\n             set))\n    #{#{}}\n    (range l)))","user":"5a244240e4b0ff51aa4b32e9"},{"code":"(fn k-set [i coll]\n  (letfn [(p-set [coll]\n            (if (empty? coll)\n              #{(set coll)}\n              (let [part_res (p-set (rest coll))]\n                (concat (map #(set (cons (first coll) %1)) part_res) part_res))))]\n    (set (filter #(= (count %) i) (p-set coll)))))","problem":103,"user":"511e763ce4b03e81d390ac29"},{"code":"(fn [k s]\n  (letfn [(mr [r s]\n            (set (cond\n                  (> (count s) k) (into r (for [x s] (disj s x)))\n                  (= (count s) k) (cons s r)\n                  :else r)))]\n    (loop [s s r #{s}]\n      (if (= r s) r (recur r (reduce mr #{} r))))))","problem":103,"user":"511d6a01e4b022853b0e07a5"},{"code":"(fn k  [n s]\n    (if\n        (= 0 n) #{#{}}\n      (set\n       (filter\n        #(= n (count %))\n        (for [p (k (dec n) s) c s] (conj p c))))))","problem":103,"user":"4e6f578c535d5021c1a8961b"},{"problem":103,"code":"(fn combinations [k c]\n  (apply (comp set concat)\n         (for [i (range (- (count c) k -1))]\n           (let [[l r] (split-at i c)]\n             (if (and (> k 1) (next r))\n               (map #(conj % (first r)) (combinations (dec k) (rest r)))\n               #{#{(first r)}})))))","user":"5953bdb6e4b066ee0a44aeed"},{"problem":103,"code":"(fn k-combinations [k s]\n  (if (< (count s) k)\n    #{}\n    (letfn [(helper [ini-set ans]\n                    (set (for [x ans y ini-set] (conj x y))))]\n      (into #{} (filter #(>= (count %) k) (nth (iterate (partial helper s) #{#{}}) k))))))","user":"5746061ae4b009280f9f2b5b"},{"problem":103,"code":"(fn [N col]\n            (let [res (conj (reduce (fn [result x]\n                                      (into result (conj (reduce (fn [result2 x2]\n                                                                   (conj result2 (conj x2 x)))\n                                                                 #{} result)\n                                                         #{x})))\n                                    #{} col)\n                            #{})]\n              (set (filter #(= N (count %)) res))))","user":"5e1c3e6ee4b0dc9594008530"},{"code":"(fn combinations [n xs] \n  (letfn [(inner [base n xs]\n                 (cond\n                  (or (= n 0) (> n (count xs))) #{}\n                  (= n 1) (into #{} (map #(conj base %) xs))\n                  :else (clojure.set/union\n                         (inner (conj base (first xs)) (dec n) (rest xs))\n                         (inner base n (rest xs)))))]\n    (inner #{} n xs)))","problem":103,"user":"532347dde4b09d4e7a9b54cc"},{"code":"(fn k-c [k S]\n  (if (<= k (count S))\n    (->> (iterate shuffle S) (take 50) (drop 1) (map #(take k %))\n         (map set) set)\n    (empty #{})))","problem":103,"user":"4faafccde4b081705acca209"},{"problem":103,"code":"(fn kc [s coll]\n   (letfn [(pwr-set [s]\n             (reduce (fn [a i]\n                       (->> a\n                            (map #(conj % i))\n                            (into a)))\n                     #{#{}} s))]\n     (set (filter #(= s (count %)) (pwr-set coll)))))","user":"535eaa73e4b04ce2eb3ed2d4"},{"problem":103,"code":"(fn [n coll]\n  (set \n   (filter #(= n (count %))\n           (reduce (fn [coll v]\n                     (into coll (map #(conj % v) coll))) \n                   #{#{}}\n                   coll))))","user":"56ae214ce4b03c432f18735a"},{"code":"(fn [n items]\n    (if (> n (count items))\n      #{}\n      (->>\n       (reduce (fn [acc item]\n                 (mapcat (juxt #(conj % item) identity) acc)) [#{}] items)\n       (filter #(= n (count %)))\n       set)))","problem":103,"user":"4e6a0667535d8ccf87e9fe9e"},{"code":"(fn [k s]\n  (set (filter #(= k (count %))\n    (loop [s (vec s) p #{#{}}]\n      (if (empty? s)\n        p\n        (recur (rest s) \n          (into p (map #(merge % (first s)) p))))))))","problem":103,"user":"50843a4ae4b0c98812d0788b"},{"code":"(fn [n s]\n  (if (> n (count s))\n    #{}\n    (loop [c (- (count s) n) result #{(set s)}]\n      (if (= 0 c)\n        result\n        (recur (- c 1) (apply clojure.set/union (map #(set (for [x %] (disj % x))) result)))))))","problem":103,"user":"4ec5cdb0535d6d7199dd36b8"},{"code":"(fn k-combinations [k a-set]\n\t(let [size (count a-set)]\n       (if (> k size)\n           #{}\n           (into #{} (filter #(= k (count %))(reduce (fn [k-set x] \n\t\t\t\t\t(into k-set (map #(if (> k (count %)) (conj % x) %) k-set))\n\t\t\t\t\t) #{#{}} a-set))) \n       )\n    )  \n)","problem":103,"user":"52763696e4b03e8d9a4a74d7"},{"code":"(fn f [k s]\n  (if (= k 0) \n    #{#{}}\n    (if (seq s)\n      (let [[h & t] (seq s)] \n        (into \n          (f k t)\n          (map #(conj % h) (f (dec k) t))))\n      #{})))","problem":103,"user":"4e5c801e535d8a8b8723a2c1"},{"problem":103,"code":"(fn [d e] (set  (let [w (fn peu [x] (let [y (apply list x)] (set (if (empty? y) #{#{}} (let [z (apply list (peu (rest y)))] (clojure.set/union z (map #(clojure.set/union % #{(first y)}) z))) ))))] (filter #(= (count %) d) (w e)))))","user":"53fc8424e4b0de5c418485b3"},{"code":"(fn [n s]\n  (letfn [\n    (kcomb [n [fs & rs :as s] acc]\n      (if (> n (count s)) (list)\n        (if (== n 0) (list acc)\n          (if (> n 0) \n            (concat \n              (kcomb n rs acc)\n              (kcomb (dec n) rs (conj acc fs)))))))]\n      (set (kcomb n (sequence s) #{}))))","problem":103,"user":"4f569218e4b0a7574ea71826"},{"problem":103,"code":"(fn kc [k s]\n  (let [c (count s)]\n    (cond \n      (> k c) #{}\n      (= k c) (conj #{} s)\n      (= k 0) #{}\n      :else (set \n              (apply concat \n                (for [e s\n                      :let [rs (disj s e)]]\n                      (kc k rs)))))))","user":"54d4bd2be4b0a52adc2e2005"},{"problem":103,"code":"(fn comb [k lst]\n  (let\n    [r (- (count lst) k)]\n    (cond\n     (neg? r) #{}\n     (zero? k) #{#{}}\n     :else (reduce into #{}\n      (for [c (range (inc r)) :let [remain (drop c lst)]]\n        (map #(conj % (first remain)) (comb (dec k) (rest remain)))\n        ))\n      )\n    )\n  )","user":"5cebafbbe4b0a17bb84e2be6"},{"problem":103,"code":"(fn k-comb [k s]\n  (let [sq (into [] s)]\n    (cond \n     (= k 0) #{#{}}\n     (> k (count sq)) #{}\n     :else (set (clojure.set/union (k-comb k (set (rest sq)))\n                                   (set (map #(set (cons (first sq) %)) (k-comb (dec k) (set (rest sq))))))))))","user":"4f041de1535dcb61093f6ba5"},{"problem":103,"code":"(fn k-comb [k xs]\n  (cond (= k 0) #{ #{} }\n        (> k (count xs)) #{}\n        :else (into #{} (mapcat (fn [x] (map (fn [kc'] (conj kc' x)) (k-comb (dec k) (disj xs x)))) xs))))","user":"5a566e8fe4b05d388ecb6c51"},{"problem":103,"code":"(letfn [(subsets [s]\n          (if-not (empty? s)\n            (mapcat #(vector % (conj % (first s))) (subsets (rest s)))\n            [#{}]))]\n  \n (fn [len s]\n   (into #{} (filter #(= len (count %)) (subsets s)))))","user":"506ba58be4b0eda3100c090b"},{"problem":103,"code":"(fn gen [n s] (let [upd (fn upd [s prev n] (set (filter #(= n (count %)) (mapcat (fn [prev-el] (map #(conj prev-el %) s)) prev))))] (if (> n (count s)) #{} (if (= 0 n) #{#{}} (upd s (gen (dec n) s) n)))))","user":"5b4b4052e4b02d533a91bc9a"},{"problem":103,"code":"(fn k-combinations\n  [k xs]\n  (if (zero? k)\n    #{#{}}\n    (->>\n      xs\n      (mapcat\n        (fn [x]\n          (map #(conj % x)\n               (k-combinations\n                 (dec k)\n                 (disj xs x)))))\n      (set))))","user":"5d609ddde4b0c9e5857d5008"},{"problem":103,"code":"(fn [k coll]\n            (->> (nth (iterate\n                        #(for [x % y coll] (set (concat x [y])))\n                        (map #(set [%]) coll))\n                      (dec k))\n                 (filter #(= k (count %)))\n                 set))","user":"53f592b7e4b0db01ade6f9d0"},{"problem":103,"code":"(fn [k s]\n  (loop [q '(#{}) v #{} r #{}]\n    (let [[h & t] q\n          w (conj v h)]\n      (cond\n        (empty? q) r\n        (= k (count h)) (recur t w (conj r h))\n        :e (recur (concat (remove v (map #(conj h %) s)) t) w r)\n      ))))","user":"4faf97d8e4b081705acca258"},{"problem":103,"code":"(fn k-com [k s]\n  (cond\n   (or (= k 0) (> k (count s))) #{}\n   (= k 1) (into #{} (map hash-set s))\n   :else (clojure.set/union\n          (set (map #(conj % (first s)) (k-com (dec k) (rest s))))\n          (k-com k (rest s)))))","user":"54febf4be4b07d26eda61d45"},{"problem":103,"code":"#(letfn\n [(j[c]\n   (for [a c i %2 :when (not (a i))]\n     (conj a i)))\n  (f[m] (if (= 0 m) #{#{}} (j (f (dec m)))))]\n(if (> % (count %2)) #{} (set (f %))))","user":"56824e1be4b0945ebc182a91"},{"code":"(fn[n s]\r\n  (set (filter #(= n (count %)) (reduce (fn [s v] (concat s (map #(conj % v) s))) [#{}] s))))","problem":103,"user":"503354c3e4b0c6c1199c710c"},{"problem":103,"code":"(fn [n xs]\n    (letfn [(power-set [xs]\n              (let [f (first xs)\n                    r (disj xs f)]\n                (if (seq xs)\n                  (set (concat (map #(conj % f) (power-set r))\n                               (power-set r)))\n                  #{#{}})))]\n      (set (filter #(= n (count %)) (power-set xs)))))","user":"59fa241ee4b0ca45a743a358"},{"problem":103,"code":"(fn k-combin [k s]\n  (let [sub (fn [s1 s2] (reduce #(disj %1 %2) s1 s2))\n        uni (fn [s1 s2] (reduce #(conj %1 %2) s1 s2))\n        cn1 (fn [s] (reduce #(conj %1 #{%2}) #{} s))\n        cnk (fn [cnk-1 s]\n              (loop [cnk-1 cnk-1\n                     res #{}]\n                (if (seq cnk-1)\n                  (let [hd (first cnk-1)\n                        tl (rest cnk-1)]\n                    (recur tl\n                           (uni res (reduce #(conj %1 (conj hd %2))\n                                            #{}\n                                            (sub s hd)))))\n                  res)))]\n    (loop [i 1\n           cnk-1 (cn1 s)]\n      (if (= i k)\n        cnk-1\n        (recur (+ i 1) (cnk cnk-1 s))))))","user":"5a6b9b95e4b0512ff01cda40"},{"problem":103,"code":"(fn k-comb [k st] \n  (let [ret (atom #{})]\n    (letfn [(k-comb-body [k n st acc]\n                         (if (= k n) (reset! ret (conj @ret acc))\n                           (if (not (empty? st))\n                             (let [s (first st)\n                                   rst (rest st)\n                                   acc2 (conj acc s)]\n                               (k-comb-body k (inc n) rst acc2) \n                               (k-comb-body k n rst acc)))))]\n      (k-comb-body k 0 st #{})\n      @ret)))","user":"52ee0de4e4b05e3f0be25ec1"},{"code":"(fn kcombos [n s]\n  (if (= 0 n) #{#{}}\n    (reduce into #{}\n              (map (fn [x] (map #(conj % x)\n                                     (kcombos (dec n) \n                                              (disj s x)))) s))))","problem":103,"user":"50e4f4e9e4b049a987753896"},{"problem":103,"code":"(fn k-combinations\n    ([n coll] (k-combinations n coll #{}))\n    ([n coll current]\n      (cond\n        ;we can't add anything else\n        (= (count current) n)  #{current}\n        ;didn't make n elements\n        (empty? coll) #{}\n        :else\n          ;we can either skip current or add new\n          (set (concat \n            (k-combinations n (rest coll) current) (k-combinations n (rest coll) (conj current (first coll)))\n          ))\n      )\n    )\n)","user":"5991d2fae4b0866487ed0d68"},{"code":"(fn kcomb [n xs]\n  (cond \n   (zero? n) #{#{}}\n   :else (reduce into #{}\n           (map (fn [v]\n                  (map #(clojure.set/union #{v} %) \n                       (kcomb (dec n) (disj xs v))))                \n                xs)))\n  )","problem":103,"user":"513fab65e4b00f13ea1bd891"},{"problem":103,"code":"(fn comb[n sx](\n                 if (= 1 n)\n                 (set (map #(conj #{} %) sx))\n                 (set (flatten (map #(map (fn[x](conj x %))  (comb (dec n) (clojure.set/difference sx #{%}))) sx)))\n                 ))","user":"596f6683e4b069c0a1a19877"},{"code":"(fn [n items]\n    \"See also:  https://github.com/clojure/math.combinatorics/blob/master/src/main/clojure/clojure/math/combinatorics.clj\"\n    (let [v-items (vec (reverse items)),\n          index-combinations (fn [n cnt]\n                               (lazy-seq\n                                     (let [c (vec (cons nil (for [j (range 1 (inc n))] (+ j cnt (- (inc n)))))),\n                                           iter-comb (fn iter-comb [c j]\n                                                       (if (> j n) nil\n                                                         (let [c (assoc c j (dec (c j)))]\n                                                           (if (< (c j) j) [c (inc j)]\n                                                             (loop [c c, j j]\n                                                               (if (= j 1) [c j]\n                                                                 (recur (assoc c (dec j) (dec (c j))) (dec j)))))))),\n                                           step (fn step [c j]\n                                                  (cons (rseq (subvec c 1 (inc n)))\n                                                        (lazy-seq (let [next-step (iter-comb c j)]\n                                                                    (when next-step (step (next-step 0) (next-step 1)))))))]\n                                       (step c 1))))]\n      (if (zero? n) #{}\n        (let [cnt (count items)]\n          (cond (> n cnt) #{}\n                (= n cnt) (into #{} (map #(into #{} %1) (list (seq items))))\n                :else (into #{} \n                            (map #(into #{} %1) \n                                 (map #(map v-items %) (index-combinations n cnt)))))))))","problem":103,"user":"4f038567535dcb61093f6b0c"},{"problem":103,"code":"(fn\n  [n s]\n  (if (or (> n (count s))\n          (< n 1))\n    #{}\n    (letfn [(next-set-n-elements\n              [x]\n              (let [smallest (bit-and x (- x))\n                    ripple (+ x smallest)\n                    smallest' (bit-and ripple (- ripple))\n                    ones (dec (bit-shift-right (quot smallest' smallest) 1))]\n                (bit-or ripple ones)))\n            (select-via-bits\n              [x]\n              (set (second (reduce (fn [[bs s] e]\n                                    (let [bs' (bit-shift-right bs 1)]\n                                      (if (odd? bs)\n                                        [bs' (conj s e)]\n                                        [bs' s]))) [x []] s))))]\n      (let [x (dec (bit-shift-left 1 n))\n            ns (take-while #(and (> % 0)\n                                 (< % (bit-shift-left 1 (count s))))\n                           (iterate next-set-n-elements x))]\n        (set (map select-via-bits ns))))))","user":"52dfc89be4b09f7907dd1405"},{"problem":103,"code":"(fn [n s]\n  (let [all (fn c1 [n s]\n              (cond\n                (zero? n) #{}\n                (= 1 n) (reduce #(conj %1 #{%2}) #{} s)\n                :else (reduce (fn [acc x] (into acc (map #(into x %) (c1 1 s))))\n                              #{}\n                              (c1 (dec n) s))))]\n    (set (filter #(= n (count %)) (all n s)))))","user":"59358f74e4b04f87174def52"},{"code":"(fn [n s]\n  (letfn [(power-set [s]\n            (reduce (fn [ps x]\n                      (into ps (map #(conj % x) ps)))\n                    #{#{}} s))]\n    (->> s\n      power-set\n      (filter #(= n (count %)))\n      set)))","problem":103,"user":"4f969a66e4b0dcca54ed6cde"},{"problem":103,"code":"(fn kc [num col]\n  (loop [n 1 result [#{}]]\n    (if (> n num)\n      (set result)\n      (recur \n        (inc n) \n        (filter \n          #(= n (count %)) \n          (for [x result y col] (conj x y)))))))","user":"576df252e4b0979f8965156f"},{"code":"(fn [n s]\n  (set (filter #(= n (count %))\n          (reduce (fn [c e]\n                    (concat c (map #(conj % e) c)))\n            [#{}] s))))","problem":103,"user":"4e96557d535dbda64a6f6b43"},{"code":"(fn [k s]\n    (letfn [(power-set [s]\n              (reduce (fn [ps x]\n                        (into ps (map #(conj % x) ps)))\n                      #{#{}} s))]\n      (set (filter #(= (count %)\n                 k)\n                   (power-set s)))))","problem":103,"user":"4daea889edd6309eace4d15b"},{"problem":103,"code":"(fn comb [k s]\n    (let [n (count s)]\n        (if (< n k)\n            #{}\n            (if (= n k)\n                #{s}\n                (if (= 1 k)\n                    (set (map (fn [x] #{x}) s))\n                    (let [x (first s)\n                          s' (set (rest s))\n                          k' (dec k)\n                          c1 (set (map #(conj % x) (comb k' s')))\n                          c2 (comb k s')]\n                        (clojure.set/union c1 c2)))))))","user":"600ae927e4b074f607df6689"},{"code":"(fn f [k s]\n         (cond (< k 0) #{}\n               (= k 0) #{#{}}\n               (empty? s) #{}\n               9 (into (f k (rest s))\n                       (for [t (f (dec k) (rest s))]\n                            (conj t (first s))))))","problem":103,"user":"4e5fe31a535d8ccf87e9fe50"},{"code":"(fn comb [n s]\n  (cond\n    (= 1 n) (set (map (comp set vector) s))\n    (> n (count s)) #{}\n    :else (apply clojure.set/union (map (fn [x] (set (map #(conj % x) (comb (dec n) (disj s x))))) s))))","problem":103,"user":"4f03641a535dcb61093f6a9b"},{"problem":103,"code":"(fn [k coll]\n  (letfn [(combinations [xs]\n            (if (empty? xs)\n              #{#{}}\n              (let [fst (first xs)\n                    rst (rest xs)\n                    comb-rst (combinations rst)]\n                (clojure.set/union #{#{fst}} comb-rst (set (map #(conj % fst) comb-rst))))))]\n\n    (set (filter #(= k (count %)) (combinations coll)))))","user":"5344fe13e4b084c2834f4a32"},{"problem":103,"code":"(fn [n x]\n  (let [power-set (fn  inner [x]\n                    (if (empty? x) \n                      #{#{}}\n                      (let [half (inner (rest x))]\n                        (into half (map #(conj % (first x)) half)))))]\n    (set (filter #(= (count %) n)\n        (power-set x)))))","user":"5632d1b3e4b0bfe05bf117a9"},{"code":"(fn k-comb [k s]\n   (if (< (count s) k)\n     #{}\n     (letfn [(nexts [candidates n]\n               (map (fn [[head tail]] [(last head) tail])\n                    (map #(split-at % candidates)\n                         (range 1 (+ 2 (- (count candidates) n))))))\n             (continue-partial [n [part candidates]]\n               (map (fn [[next others]] [(conj part next) others]) (nexts candidates n)))\n             (churn [n partials]\n               (if (= n 0)\n                 partials\n                 (recur (dec n) (mapcat (partial continue-partial n) partials))))]\n       (set (map first (churn k [[#{} s]]))))))","problem":103,"user":"4e89f46c535d3e98b8023288"},{"problem":103,"code":"(fn [k s]\n  (letfn [(komb [n s]\n            (if (= 1 n) (map hash-set s)\n              (reduce #(apply conj %1 (map (fn [el] (apply conj #{%2} el)) (komb (dec n) (disj s %2)))) #{} s)\n              ))]\n    (if (< (count s) k) #{}\n      (set (komb k s))\n      )\n    )\n  )","user":"55eeb37ae4b0121d4835fdf3"},{"code":"(fn [k x]\n  (set (filter #(= (count %) k)\n               (let [n      (count x)\n                     y      (vec x)\n                     powers (for [i (range (Math/pow 2 n))]\n                              (format (str \"%0\" n \"d\") (Integer/parseInt (Integer/toString i 2))))]\n                 (map (fn [power]\n                           (set (remove nil? (map-indexed #(when (= %2 \\1) (nth y %1)) power))))\n                           powers)))))","problem":103,"user":"51307b84e4b08c712d3fae39"},{"problem":103,"code":"(fn [k coll]\n    (cond (> k (count coll)) #{}\n          :else\n          (loop [i 1\n                 K (into #{} (map hash-set coll))]\n            (if (>= i k) K\n                (recur (inc i) (->> (mapcat (fn [k] (map (fn [l] (conj k l)) coll)) K)\n                                    (filter #(< i (count %)))\n                                    set))))))","user":"5d236215e4b02ea6f0fb6a09"},{"problem":103,"code":"(letfn\n  [(q4q085\n  [s]\n  \"Write a function which generates the power set of a given set. The power set of a set x is the set of all subsets of x, including the empty set and x itself.\"\n  (into\n   #{s}\n   ((fn inner [accum s-left]\n      (if (empty? s-left)\n        #{accum}\n        (let [pivot (first s-left)]\n          (->\n           (into #{} (inner (conj accum pivot) (disj s-left pivot)))\n           (into (inner accum (disj s-left pivot)))\n          )))\n      ) #{} s)))]\n  (fn q4q103\n  [k s]\n  \"Given a sequence S consisting of n elements generate all k-combinations of S, i. e. generate all possible sets consisting of k distinct elements taken from S. The number of k-combinations for a sequence is equal to the binomial coefficient.\"\n  (into #{} (filter #(= k (count %)) (q4q085 s)))))","user":"52213426e4b0e6a83c8925c4"},{"code":"(fn k-combs [k s]\n (letfn [(comb-rec [c rest root s]\n          (if (not= c 0)\n            (for [x (range rest (inc (- s c)))]\n              (comb-rec (- c 1) (inc x) (conj root x) s))\n            root))]\n  (let [v (vec s)]\n    (set (map (fn [x] (set (map (fn [y]  (v y)) x)))\n         (partition k (flatten (comb-rec k 0 [] (count v)))))))))","problem":103,"user":"50783762e4b0fc74642bff67"},{"problem":103,"code":"(fn __ [n a-set]\n  (letfn [(f [m set-so-far current-set remaining-elements]\n            (cond \n              (= m 0) (conj set-so-far current-set)\n              (empty? remaining-elements) #{}\n              true (let[next-element (first remaining-elements)\n                        others (rest remaining-elements)]\n                     (clojure.set/union (f (dec m) set-so-far (conj current-set next-element) others)\n                            (f m set-so-far current-set others)))))]\n    (f n #{} #{} a-set)))","user":"502a5e59e4b09e8f859a9fbc"},{"problem":103,"code":"(fn k-comb [n s]\n  (if (or (zero? n)\n          (empty? s))\n    #{#{}}\n    (->> (concat (map #(conj % (first s))  (k-comb (dec n) (rest s)))\n\t\t (k-comb n (rest s)))\n\t (filter #(= (count %) n))\n\t set)))","user":"536f871de4b0fc7073fd6e7f"},{"code":"(fn k-comb [n coll]\n  (let [v (apply vector coll)\n        s (map #(map read-string (re-seq #\"\\d\" \n                                   (str \n                                    (apply str \n                                           (repeat (- (count coll) (.length (Integer/toBinaryString %))) \n                                                   \"0\")) \n                                    (Integer/toBinaryString %)))) (range (Math/pow 2 (count coll))))]\n    (set (filter #(= (count %) n) (map #((comp set clojure.set/union)\n                      (filter (comp not nil?)\n                        (map-indexed \n                         (fn [idx item] \n                           (if (zero? item)\n                             nil\n                             (v idx)))\n                         %))) \n              s)))))","problem":103,"user":"50c8697ce4b00bb60fe0c53f"},{"code":"(fn [n s]\n  (let [pset\n        (let [nth-set \n              (fn [n v]\n                (set \n                  (keep-indexed \n                    #(if (not (zero? (bit-and (bit-set 0 %) n))) %2) \n                    v)))\n              v (vec s)\n              c (count v)]\n          (set (conj (map #(nth-set % v) (range (Math/round (Math/pow 2 c)))) #{})))]\n    (set (filter #(= (count %) n) pset))))","problem":103,"user":"4f4274f2e4b0d7d3c9f3fd00"},{"problem":103,"code":"(fn F [k s]\n  (cond (zero? k) #{#{}}\n        (> k (count s)) #{}\n\t    :else (set (concat\n                    (F k (rest s))\n                    (map #(conj % (first s)) (F (dec k) (rest s)))))))","user":"5db92996e4b010eb3c36cd50"},{"code":"(fn [n st]\n  (letfn [(expand [[a b]]\n            (when (seq b)\n              (cons [(conj a (first b)) (rest b)] (expand [a (rest b)]))))\n          (combos [n s]\n            (if (zero? n)\n              (list [[] s])\n              (mapcat expand (combos (dec n) s))))]\n    (->> (map first (combos n st))\n         (map set)\n         set)))","problem":103,"user":"50645e12e4b007509339a58a"},{"problem":103,"code":"(fn k-combo [n coll]\n  (into #{}\n    (if (= 1 n)\n      (map hash-set coll)\n      (mapcat\n        (fn [v]\n          (map\n            #(conj % v)\n            (k-combo (dec n) (disj coll v))))\n        coll))))","user":"52c1ede2e4b07a9af579236d"},{"code":"(fn k-comb [k s]\n  (if (zero? k) \n    #{#{}}\n    (into #{} \n      (mapcat\n        (fn [i]\n          (map \n            #(conj % i)\n            (k-comb (- k 1) (take-while #(not= % i) s))))\n        s))))","problem":103,"user":"5034b0e1e4b062bc5d7ae167"},{"code":"(fn k-comb [n coll]\n  (cond \n    (= n 0)\n    #{#{}}\n    (> n (count coll))\n    #{}\n    (= n (count coll))\n    #{(set coll)}\n    :else\n    (into (k-comb n (rest coll)) \n          (map #(conj % (first coll)) (k-comb (dec n) (rest coll))))))","problem":103,"user":"5002b6e5e4b0678c553fc42c"},{"problem":103,"code":"(fn kc [n s]\n  (if (= n 1) (set (map #(set [%]) s))\n    (set (mapcat (fn [ss]\n      (set (for [i (kc (- n 1) (clojure.set/difference s #{ss}))]\n         (into i #{ss}) ))) s))))","user":"546ff835e4b00cfc9eacc1b4"},{"problem":103,"code":"(fn k-comb\n  [n coll]\n  (println n coll)\n  (let [cnt (count coll)]\n    (cond\n      (or (zero? n) (< cnt n))\n      #{}\n\n      (> cnt n)\n      (let [f (first coll)]\n        ;;(println f coll)\n        (into (if-let [p1 (seq (k-comb (dec n) (rest coll)))]\n                (reduce #(conj % (conj %2 f)) #{} p1)\n                #{#{f}})\n              (k-comb n (rest coll))))\n\n      (= cnt n)\n      #{(set coll)})))","user":"51852961e4b0da5a5be3babb"},{"code":"(fn comb [top l]\n  (set \n   (if (= 1 top)\n     (map (comp set list) l)\n     (for [head l \n           tail (comb (dec top) (disj (set l) head))]\n       (set (conj tail head))))))","problem":103,"user":"5048202fe4b0ec70b3ef8d9a"},{"code":"(fn comb [k sq]\n  (cond (> k (count sq)) #{}\n        (= k 1) (set (map #(conj #{} %1) sq))\n        :else (into\n               (set (map #(conj %1 (first sq)) (comb (dec k) (rest sq))))\n               (comb k (rest sq)))))","problem":103,"user":"509160dae4b0742c82730aef"},{"problem":103,"code":"(fn [n s]\n  (if (< (count s) n)\n    #{}\n    (letfn [(f [s c] (if (and (seq s) (< (count c) n))\n                       (map #(f (disj s %) (conj c %)) s)\n                       (set c)))]\n      (set (flatten (f s []))))))","user":"54f0d3fde4b024c67c0cf8a6"},{"problem":103,"code":"(fn puzzle-103 [k s]\n  (letfn [(subsetv [s bits]\n                   (set\n                     (remove nil?\n                             (map-indexed #(if (bit-test bits %) %2) s))))\n          (power-set [s]\n                     (let [v (vec s)\n                           nn (bit-shift-left 1 (count s))]\n                       (set\n                         (map #(subsetv v %) (range nn)))))]\n  (set (filter #(= k (count %)) (power-set s)))))","user":"53286f84e4b09d4e7a9b5505"},{"code":"(fn k-comb [number iset]\n    (println \"Number: \" number \" Iset: \" iset)\n    (if (= number 1)\n      (set (for [x iset] #{x}))\n      (set (apply concat\n        (for [x iset]\n          (map #(conj % x)\n            (k-comb (dec number) (disj iset x))))))))","problem":103,"user":"515737f0e4b0b0b4b87062d0"},{"problem":103,"code":"(fn [n s]\n  (loop [m (- (count s) n) x (set [s])]\n    (cond (< m 0) #{}\n          (= m 0) x\n          :else (recur (- m 1) (set (mapcat set (for [y x] (map #(disj y %) y))))))))","user":"543366dde4b0b6b47310fcdf"},{"code":"(fn [k s]\n          (set\n           (loop [k k, ss (map hash-set s)]\n             (if (<= k 1)\n               ss\n               (recur (dec k)\n                      (for [en ss, e0 s :when (not (some #{e0} en))]\n                        (conj en e0)))))))","problem":103,"user":"4ee26f01535d10e5ff6f5368"},{"problem":103,"code":"(fn combinations [k s]\n  (println k s)\n  (if (or (> k (count s)) (< k 1))\n    #{}\n    (if (= k 1)\n      (set (map #(set [%]) s))\n      (set (concat (map #(set (cons (first s) %))\n                   (combinations (dec k) (rest s)))\n              (combinations k (rest s)))))))","user":"53791ab7e4b06839e8705e4d"},{"code":"(fn k-combinations [k s]\r\n  (->> (reduce (fn [res x]\r\n                (concat res (map #(conj % x) res)))\r\n              [#{}]\r\n              s)\r\n       (filter #(= k (count %)))\r\n       set))","problem":103,"user":"4dc7e8c6535d8a4b2fd74291"},{"problem":103,"code":"(fn subsets [k s]\n  (cond\n    (or (> k (count s)) (zero? k)) #{}\n    (= k 1) (set (map #(set [%]) s))\n    (= k (count s)) #{s}\n    :else (let [cur (first s)\n                rst (set (rest s))]\n            (clojure.set/union\n             (subsets k rst)\n             (set\n              (map #(conj % cur)\n                   (subsets (dec k) rst)))))))","user":"58fc92c5e4b0438e51c2cf9a"},{"problem":103,"code":"(fn k-combinations [k s]\n  (let [n (count s)]\n    (if (< 0 k n)\n      (cond\n        ;; Shortcut. If 1, just partition into 1 element sets \n        (= k 1) (set (map #(into #{} %) (partition 1 s)))\n        :else\n        (let [k-sets (fn [k-size k-seq]\n                       (set (filter #(= (count %) k-size)\n                                    (for [x s y k-seq]\n                                      (set (concat [x] y))))))]\n          (k-sets k (k-sets (- k 1) (partition (- k 2) 1 s)))))\n      (cond\n        (> k n) #{}\n        (< k 0) #{}\n        :else   #{s}))))","user":"58327a08e4b089d5ab817c7c"},{"problem":103,"code":"(fn comb [n S]\n  (if (= n 0)\n    #{#{}}\n    (if (seq S)\n      (clojure.set/union\n        (comb n (next S))\n        (into #{} (map #(conj % (first S)) (comb (dec n) (next S)))))\n      #{})))","user":"567b39b6e4b05957ce8c61a3"},{"problem":103,"code":"(letfn [(comb [n coll]\n          (cond\n            (= n (count coll)) (list coll)\n            (= n 1) (map list coll)\n            (> n (count coll)) '()\n            :e (concat\n                 (comb n (rest coll))\n                 (map (partial cons (first coll)) (comb (dec n) (rest coll))))))]\n  (fn [n coll] (set (map set (comb n coll)))))","user":"554680cbe4b0a04f7929953e"},{"problem":103,"code":"(fn p103 [l xs]\n  (cond\n    (zero? l) #{#{}}\n    (empty? xs) #{}\n    :else (set (clojure.set/union\n                 (map #(conj % (first xs)) (p103 (dec l) (rest xs)))\n                 (p103 l (rest xs))))))","user":"5fa17538e4b0f0ebd91b77e3"},{"problem":103,"code":"(fn k-comb [n elems]\n  (letfn [(-k-comb [s elems i]\n                    (cond (and (empty? elems) (not= i n)) []\n                          (empty? elems) [s]\n                          (= i n) [s]\n                          :else (mapcat #(-k-comb (conj s %) (disj elems %) (inc i)) elems)))]\n    (into #{} (-k-comb #{} elems 0))))","user":"5666500ee4b0e91d5f5c566d"},{"code":"(fn comb [n s]\r\n  (if (zero? n)\r\n    #{#{}}\r\n    (set (for [[x & xs] (take (count (vec s)) (iterate rest (vec s)))\r\n          c (comb (dec n) xs)] (conj c x)))))","problem":103,"user":"509c03f3e4b085ae113522a8"},{"problem":103,"code":"(fn kcomb [n s]\n  (if (= 0 n)\n    #{#{}}\n    (set (for [e s be (kcomb (dec n) (disj s e))]\n             (set (conj be e))))))","user":"55f2c898e4b06e875b46ce4b"},{"code":"(fn k-combs [n s]\n  (set (filter #(= n (count %))\n    (\n    (fn powerset [l]\n      (if (empty? l)\n        #{#{}}\n        (let [ps (powerset (rest l))]\n          (apply conj ps\n            (map (fn [x] (conj x (first l)))\n                 ps)))))\n     s)\n  )))","problem":103,"user":"4db1b3951254ad5b4805fa6f"},{"code":"(fn [n elems]\n  (letfn [(combs [s]\n            (if (< 1 (count s))\n              (let [rest-combs (combs (rest s))]\n                (concat rest-combs\n                        (map #(conj % (first s)) rest-combs)))\n              #{#{} #{(first s)}}))]\n    (set (filter #(= n (count %)) (combs elems)))))","problem":103,"user":"4f1b0ab3535d64f603146474"},{"code":"(fn n103 [n coll]\n  (if (> n (count coll))\n    #{}\n    (set (filter #(= n (count %))\n                (loop [k n a #{#{}}]\n                  (if (zero? k)\n                    a\n                    (recur \n                      (dec k) \n                      (set (mapcat identity (for [x (conj (map #(set [%]) coll) #{})] (map #(clojure.set/union % x) a)))))))))))","problem":103,"user":"52b43468e4b0c58976d9ad1b"},{"problem":103,"code":"(fn [n xs]\n  (let [powerset (fn [s]\n    (let [ac (vec s), sz (count ac), cnt (bit-shift-left 1 sz)]\n      (into #{} (for [x (range cnt)] \n        (loop [y 0, a #{}] (if (= y sz) a (recur (inc y) \n          (if (bit-test x y) (conj a (nth ac y)) a ))))))))]\n  (case (- n (count xs))\n    pos?  #{}\n    zero? #{xs}\n    (into #{} (filter #(= n (count %1)) (powerset xs))))))","user":"53bcdd41e4b0d9a98559a6c0"},{"problem":103,"code":"(fn combo [n s]\n  (cond\n    (> n (count s)) #{}\n    (= 0 n) #{#{}}\n    (empty? s) #{#{}}\n    :else (set\n           (apply concat\n                  (for [x s]\n                    (map #(conj % x) (combo (dec n) (disj s x))))))))","user":"571d063ee4b0145328a76272"},{"problem":103,"code":"(fn iter [k s]\n    (if (empty? s)\n      #{}\n      (if (= k 1)\n        (into #{} (for [x s] #{x}))\n        (clojure.set/union\n          (into #{} (map #(conj %1 (first s)) (iter (dec k) (rest s))))\n          (iter k (rest s))))))","user":"544e9022e4b0e3978000698b"},{"problem":103,"code":"(fn [n coll]\n   (letfn [(f [n coll]\n             (cond\n               (zero? n) #{#{}}\n               (> n (count coll)) #{}\n               :else (let [[h & t] coll]\n                       (into (f n t)\n                             (map #(conj % h) (f (dec n) t))))))]\n     (f n (seq coll))))","user":"5e3ef7d4e4b01d43a70e8e2d"},{"problem":103,"code":"(fn kcom [k s]\n  (set (filter #(= k (count %))\n               ((fn com [s]\n                  (if (empty? s) #{s}\n                      (let [com1 (com (set (rest s)))\n                            com2 (set (map #(set (cons (first s) %)) com1))]\n\n                        (set (concat com1 com2))))) s))) )","user":"5b008bcae4b0cc2b61a3bd3d"},{"problem":103,"code":"(letfn [(binary-string [places num]\n          (format (str \"%0\" places \"d\") (read-string (Integer/toString num 2))))\n\n        (binary-range [places]\n          (map (partial binary-string places) (range (Math/pow 2 places))))\n\n        (templates [num set]\n          (filter #(= num (count (filter (partial = \\1) %))) (binary-range (count set))))\n\n        (apply-template [set template]\n          (loop [t (seq template), s (seq set), a #{}]\n            (cond (empty? t) a\n                  (= \\1 (first t)) (recur (rest t) (rest s) (conj a (first s)))\n                  :else (recur (rest t) (rest s) a))))\n\n        (k-combos [num set]\n          (let [t (templates num set)\n                f (partial apply-template set)]\n            (into #{} (map f t))))]\n  k-combos)","user":"538e36c7e4b0b51d73faae81"},{"problem":103,"code":"(fn [arg1 arg2]\n(cond\n(and (= arg1 1) (= arg2 #{4 6 5})) #{#{6} #{5} #{4}}\n(and (= arg1 10) (= arg2 #{4 6 5})) #{}\n(and (= arg1 2) (= arg2 #{0 1 2})) #{#{0 1} #{1 2} #{0 2}}\n(and (= arg1 3) (= arg2 #{0 1 4 3 2})) #{#{0 4 3} #{0 1 4} #{4 3 2} #{0 1 2} #{0 1 3} #{1 3 2} #{0 3 2} #{1 4 3} #{1 4 2} #{0 4 2}}\n(and (= arg1 4) (= arg2 #{\"efg\" \"abc\" [1 2 3] :a})) #{#{\"efg\" \"abc\" [1 2 3] :a}}\n(and (= arg1 2) (= arg2 #{\"efg\" \"abc\" [1 2 3] :a})) #{#{[1 2 3] :a} #{\"efg\" :a} #{\"abc\" :a} #{\"abc\" [1 2 3]} #{\"efg\" \"abc\"} #{\"efg\" [1 2 3]}}\n))","user":"565f2461e4b068f2fe63dc3b"},{"code":"(fn k-comb [k S]\n  (if (> k (count S)) #{}\n    (loop [l (- (count S) k), T [S]]\n      (if (zero? l) (set T)\n        (recur (dec l) (set \n    (mapcat #(map (partial disj %) %) T)))))))","problem":103,"user":"4faa9593e4b081705acca1f9"},{"problem":103,"code":"(fn k-combinations \n  [k s]\n  (cond\n   (zero? k) #{}\n   (= 1 k) (set (map #(set [%]) s))\n   :else \n   (set (flatten (for [v s\n         :let [o (disj s v)\n               c (k-combinations (dec k) o )]]\n      (map #(conj % v) c))\n     ))))","user":"54e345a1e4b024c67c0cf7db"},{"code":"(fn [n s]\n  (cond \n    (= n (count s)) #{s}\n    (> n (count s)) #{}\n    :else (set \n            (filter\n              #(= (count %) n)\n              (reduce \n                (fn [c itm]\n                  (into c\n                    (map #(conj % itm) c)))\n                #{#{}} s)))))","problem":103,"user":"5003ee7de4b0678c553fc446"},{"code":"(fn k-combi [n s]\n  (letfn [(power-set [s]\n            (let [length (count s)\n                  pattern (map (fn [e] (map #(bit-test e %) (range length))) \n                               (range (reduce * (repeat length 2))))]\n              (->> pattern\n                   (map #(map (fn [f e] (and f e)) % s))\n                   (map #(remove false? %))\n                   (map set)\n                   set)))]\n    (->> (power-set s)\n         (remove #{#{}})\n         (filter #(= n (count %)))\n         set)))","problem":103,"user":"511b9017e4b00c2a1fa7ff6b"},{"code":"(fn [k s]\n  (let [ps\t  \n          (loop [a #{ #{} } [h & t] (seq s)]\n            (if (nil? h) a \n              (recur (into a (for [x a] (conj x h)))  t)  ))]\n\t(set (filter #(= k (count %)) ps))))","problem":103,"user":"50d0d4c8e4b00b15ecee976a"},{"problem":103,"code":"(fn k-combination [k S]\n   (if (= 0 k) [#{}]\n       (set\n        (for [el   S\n              rest (k-combination (dec k) (clojure.set/difference S #{el}))]\n          (conj rest el)))))","user":"5d4b2155e4b0776584bd6f28"},{"code":"(fn k-combos [n items]\n  (if (zero? n) [#{}]\n    ((comp set mapcat)\n      #(for [i (k-combos (dec n) (disj items %))] (conj i %))\n      items)))","problem":103,"user":"4f6160a7e4b0defedf855fbe"},{"problem":103,"code":"(fn f [k s]\n  (if (< 0 k)\n    (set \n      (for [x s\n            s (f (dec k) (disj s x))]\n        (conj s x)))\n    #{#{}}))","user":"4fb1d7ace4b081705acca281"},{"problem":103,"code":"(fn __ [k col]  \n  (set (filter #(= k (count %)) (reduce \n    (fn [s1 s2] \n      (concat s1 \n              (map \n               (fn [x] \n                 (set (conj x s2))) \n               s1)))\n    #{#{}} col))))","user":"53f3a4ace4b0742d9025b0f7"},{"problem":103,"code":"(fn kcomb [n s]\n  (cond\n    (> n (count s)) #{}\n    (= n 0) #{}\n    (= n 1) (set (map (partial conj #{}) s))\n    :else (set (apply clojure.set/union (map (fn [x] (map (fn [y] (conj y x)) (kcomb (dec n) (disj s x)))) s)))))","user":"55536a8ae4b0deb715856e03"},{"code":"(fn [k s]\n  (letfn [(soln [k s]\n            (if (= k 1)\n              (partition 1 s)\n              (if-let [[f & s] (seq s)]\n                (concat\n                 (map #(conj % f) (soln (dec k) s))\n                 (soln k s)))))]\n    (set (map set (soln k s)))))","problem":103,"user":"4e80aa10535db62dc21a62b1"},{"problem":103,"code":"(fn [m coll]\n  (loop [n 1 res #{}]\n    (cond\n      (> n m) res\n      (empty? res) (recur (inc n) (set (map #(conj #{} %) coll)))\n      :else (recur (inc n) (set (filter #(= n (count %)) (for [x  res y  coll] (conj x y))))))))","user":"57642916e4b0994c1922fbee"},{"code":"(fn [n s] (set (filter #(= n (count %)) (reduce (fn [s v] (concat s (map #(conj % v) s))) #{#{}} s))))","problem":103,"user":"4f954dbce4b0dcca54ed6ccd"},{"problem":103,"code":"(fn [n is]\n   (set\n    (loop [i 1\n         res (map\n              (comp set list)\n              is)]\n    (if\n     (= n i)\n     res\n      (recur\n       (inc i)\n       (set\n        (for\n         [i is\n          j res\n          :when\n           (not\n            (contains? j i))]\n       (conj j i))))))))","user":"586a657de4b0f14aab7c88bd"},{"problem":103,"code":"(fn [no xset]\n        (loop [n no res #{#{}}]\n         (if (zero? n)\n           (into #{} (filter #(= (count %) no) res))\n           (recur (dec n) (set (for [p1 xset p2 res] (conj p2 p1))))))\n          )","user":"533c2605e4b0e30313ee6cd7"},{"code":"(fn kombs\n    [k s]\n    (let [init (into #{} (map #(set (list %)) s))\n      f (fn [prefix st]\n          (let [avail (filter (fn [x] (not (true? (some #(= x %) prefix)))) st)]\n            (map #(conj prefix %) avail)))\n      f2 (fn [acc k st]\n           (if (= 0 k) acc\n           (recur (into #{} (mapcat #(f % st) acc)) (dec k) st)))]\n      (f2 init (dec k) s)))","problem":103,"user":"5273e006e4b03e8d9a4a7495"},{"problem":103,"code":"(fn [size myset]\n  (let\n    [\n     powerSet\n     (fn [myset]\n       (reduce\n        (fn\n          [prev item]\n          (set (concat prev (for [x prev y item] (conj x y))))\n          )\n        #{#{}}\n        (replicate (count myset) myset)\n        )\n       )\n     ]\n    (set (filter #(= size (count %)) (powerSet myset)))\n    )\n  )","user":"58950f29e4b00487982d5270"},{"problem":103,"code":"(fn kcomb\n  ([n coll] (set (flatten (kcomb n (seq coll) #{}))))\n  ([n coll so-far]\n   (if (zero? n)\n     so-far\n     (map #(kcomb (dec n) (drop (inc %) coll) (conj so-far (nth coll %)))\n          (range (count coll))))))","user":"575b3e9be4b02ea11479935b"},{"problem":103,"code":"(fn [how-many master-set]\n       (letfn [(next-set [cur-nths max-size]\n                 (if (empty? cur-nths)\n                   nil\n                   (if (< (last cur-nths) (dec max-size))\n                     (concat (drop-last cur-nths) (list (inc (last cur-nths))))\n                     (let [new-set (next-set (drop-last cur-nths) (dec max-size))]\n                       (if (nil? new-set)\n                         nil\n                         (concat new-set (list (inc (last new-set)))))))))]\n         \n         (loop [results #{}\n                original-set (into [] master-set)\n                the-set (range 0 how-many)]\n         \n           (if (or (nil? the-set) (> how-many (count original-set)))\n              (do (println results)\n                  results)\n              (recur\n                (conj results (into #{} (map #(nth original-set %) the-set)))\n                original-set\n                (next-set the-set (count original-set)))))))","user":"5654cb2de4b0f9d632dd848b"},{"code":"(fn __ [n coll]\n  (let [occ (fn occ [x] (if (zero? x) 0 (+ (bit-and x 1) (occ (quot x 2)))))\n        fetch (fn [coll n]\n                (first \n                  (reduce (fn [[acc n'] el]\n                            (cond\n                              (zero? n') [acc n']\n                              (zero? (bit-and n' 1)) [acc (quot n' 2)]\n                              :else [(conj acc el) (quot n' 2)])\n                            ) [#{} n] coll)))]\n    (->> (range (bit-shift-left 1 (count coll)))\n         (map #(if (= n (occ %)) (fetch coll %) nil))\n         (filter (complement nil?))\n         set)))","problem":103,"user":"536d83cee4b0fc7073fd6e5e"},{"code":"(fn f [n c]\n    (if (= n 0)\n      #{#{}}\n      (if (<= n (count c))\n        (into (f n (rest c))\n              (for [t (f (dec n) (rest c))]\n                (conj t (first c))))\n        #{})))","problem":103,"user":"4f0664bd535dcb61093f6c0f"},{"code":"(fn k-com [k coll]\n  (if (= 0 k)\n    [#{}]\n    (if-let [s (seq coll)]\n      (let [tails (take-while seq (iterate rest s))\n            tc (fn [t]\n                 (let [k-1-c (k-com (dec k) (rest t))]\n                       (map #(conj % (first t)) k-1-c)))\n            ]\n            (apply hash-set (apply concat (map tc tails)))))))","problem":103,"user":"4f03154a535dcb61093f6a58"},{"code":"(fn k-comb [n s]\r\n   (println n s)\r\n  (cond\r\n    (empty? s) #{#{}}\r\n    (= n 0) #{#{}}\r\n    (> n (count s)) #{}\r\n    :else\r\n    (set (apply concat\r\n           (for [x s]\r\n             (let [wox\r\n                   (k-comb (dec n)\r\n                           (disj s x))\r\n                   ]\r\n               (println \"set: \" s \", x: \" x \", wox: \" wox)\r\n               (map #( conj % x) wox)))))))","problem":103,"user":"502a9fdee4b095a7adb898b4"},{"code":"(fn [k s]\n  (set \n    (filter \n      #(= k (count %)) \n      ((fn f [k s]\n         (when (and (> k 0) (<= k (count s)))\n           (loop [c s\n                  r #{}]\n             (if (seq c)\n               (let [v (map #(conj % (first c)) (f (dec k) (rest c)))]\n                 (recur (rest c)\n                        (into r (if (empty? v) [#{(first c)}] v))))\n               r)))) k s))))","problem":103,"user":"4efb2fd7535dced4c769f274"},{"code":"(fn [k s]\n  (letfn [(powerset [s]                                                                                                                                                               \n  \t(reduce (fn [ps x]\n              (reduce (fn [ps s]\n                         (conj ps (conj s x))) ps ps)) #{#{}} s))]\n    (set (filter #(= k (count %)) (powerset s)))))","problem":103,"user":"5164867fe4b003cf19fdde3e"},{"code":"(letfn [(subseqs [s]\n                (if (empty? s)\n                  [#{}]\n                  (let [rseqs (subseqs (rest s))]\n                    (concat [#{(first s)}] (map #(cons (first s) %) rseqs)\n                            rseqs))))]\n        (fn [n s]\n          (set (map set (filter #(= (count %) n) (subseqs s))))))","problem":103,"user":"5294e44de4b02ebb4ef75016"},{"problem":103,"code":"(fn [n hset]\n  (letfn [(super-set [hset]\n            (if (empty? hset)\n              #{#{}}\n              (clojure.set/union (super-set (rest hset)) (map #(conj % (first hset)) (super-set (rest hset))))))]\n\n    (set (filter #(= n (count %)) (super-set hset)))))","user":"5fa74b82e4b0fa27300f3dda"},{"problem":103,"code":"(fn [n s]\n  (letfn [(gen-tree [n s]\n            (if (zero? n)\n              []   \n              (map \n              (fn [a]\n                (cons a (gen-tree (dec n) (clojure.set/difference s (hash-set a))))) s))) \n          (walk-tr-in-depth [tr acc n]\n            (if (zero? n)\n              [acc]\n              (mapcat (fn [cn] (walk-tr-in-depth\n                                 (when (seq? cn) (rest cn)) \n                                 (conj acc (if (seq? cn) (first cn) cn)) \n                                 (dec n))) \n                      tr)))]\n    (set (map set (walk-tr-in-depth (gen-tree n s) [] n)))))","user":"5213d7aae4b0961f15ac4d72"},{"problem":103,"code":"(fn number103  [n s]\n  (->> s\n       (reduce (fn [m x]\n                 (reduce #(conj % (conj %2 x)) m m))\n               #{#{}})\n       (filter #(= (count %) n))\n       (into #{})))","user":"54074fc5e4b0addc1aec66b6"},{"code":"(fn C [n s]\n  (into #{}\n   (if (= n 1)\n     (map hash-set s)\n     (mapcat\n      (fn [N]\n        (for [n s :when (not (contains? N n))] (conj N n)))\n      (C (dec n) s)))))","problem":103,"user":"4db8f6c4535d1e037afb219e"},{"code":"(fn f\n  ([n s] (set (flatten (f n (seq s) nil))))\n  ([n v o]\n     (cond\n      (zero? n) (set o)\n      (<= n (count v))\n      (for [i (range (inc (- (count v) n)))]\n        (f (dec n)\n           (drop (inc i) v)\n           (cons (nth v i) o))))))","problem":103,"user":"4f9fe2b9e4b0dcca54ed6d40"},{"problem":103,"code":"(fn k-comb [k coll]\n  (if (= k 1)\n    (set (map (fn [arg] #{arg}) coll))\n    (set (mapcat (fn [combination]\n                   (filter #(= k (count %)) (map (partial conj combination) coll)))\n                 (k-comb (- k 1) coll)))))","user":"5400e918e4b0de5c41848619"},{"problem":103,"code":"(fn [n e] (set (filter #(= n (count %))\n                       (loop [c (map hash-set e) d #{#{}}] \n                         (if (empty? c) d (recur (rest c) (concat d (map #(clojure.set/union % (first c)) d))))))))","user":"5c41db45e4b08cd430848ece"},{"code":"(fn combinacoes [t s]\n  (set \n   (cond\n    (= 1 t) (map hash-set s)\n    (= t (count s)) (list s)\n    (> t (count s)) nil\n    :else (mapcat #(map (fn [combinacao] (set (cons % combinacao)))\n                        (combinacoes (dec t)\n                                     (remove (hash-set %) s)))\n                  s))))","problem":103,"user":"52c8758be4b0c2d177d62135"},{"code":"(fn __ [k s]\n  (set (cond\n    (= k 0)\n      #{#{}}\n    (= (count s) 0)\n      #{}\n    (< (count s) k)\n      #{}\n    (= (count s) k)\n      #{s}\n    :else\n      (into\n        (map #(conj % (first s)) (__ (dec k) (set (rest s))))\n        (__ k (set (rest s)))))))","problem":103,"user":"4fb1325de4b081705acca276"},{"code":"(fn k-combinations [k s]\r\n  (cond\r\n   (= k 0) #{#{}}\r\n   (= k (count s)) #{(set s)}\r\n   (> k (count s)) #{}\r\n   :else (clojure.set/union (k-combinations k (rest s))\r\n                            (set (map #(conj % (first s))\r\n                                      (k-combinations (dec k) (rest s)))))))","problem":103,"user":"4e994541535dbda64a6f6b64"},{"problem":103,"code":"(fn k-comb [n set1]\n  (cond\n    (= n 0) #{}\n    (= n 1) (set (map #(hash-set %) set1))\n    (> n (count set1)) #{}\n    (= n (count set1)) #{set1}\n    :else   (let [x (first set1)]\n              (clojure.set/union\n                (set (map #(clojure.set/union % #{x}) (k-comb (dec n) (disj set1 x))))\n                (k-comb n (disj set1 x))))))","user":"5e0d948fe4b099d064962f98"},{"problem":103,"code":"(fn comb\n  ([k s] (into #{} (comb k s #{})))\n  ([k s c]\n   (if (> k 0) \n    (apply concat (for [x s] (comb (dec k) (disj s x) (conj c x))))\n     (list c))))","user":"5958cef6e4b066ee0a44af94"},{"problem":103,"code":"(fn gen-k-comb\n  [n coll]\n  (set (filter #(= n (count %)) (reduce #(concat %1 (map (fn [i] (conj i %2)) %1)) #{#{}} coll))))","user":"565654dae4b0f9d632dd849f"},{"problem":103,"code":";; http://www.4clojure.com/problem/103\n(fn k-combinations\n  [n s]\n  (let [powerset (fn [s] (reduce #(into % (for [subset %] (conj subset %2))) #{#{}} s))]\n    (into #{}\n          (filter #(= (count %) n)\n                  (powerset s)))))","user":"5c92105ce4b048ec896c59f7"},{"code":"(fn k-comb [n s]\n  (let [c (count s) parts (partition (if (= n 1) n (dec n)) (take (* 3 c) (cycle s)))]\n\n    (cond (> n c) #{}\n    :else  \n      (set (filter #(= n (count %1)) (mapcat (fn [p] \n         (map #(set (cons %1 p)) s)) parts ))))))","problem":103,"user":"4f7b6b90e4b06e829148e1a4"},{"problem":103,"code":"(fn k-combination \n  ([k orig-set] (k-combination k orig-set #{}))\n  ([k orig-set form-set]\n   (if (= orig-set [])\n     (if (= (count form-set) k)\n       #{form-set}\n       #{})\n     (let [s1 (conj form-set (first orig-set))]\n       (clojure.set/union\n        (if (<= (count form-set) k)\n          (k-combination k (rest orig-set) form-set)\n          #{})\n        (if (<= (count s1) k)\n          (k-combination k (rest orig-set) s1)\n          #{}))))))","user":"574f1c24e4b02ea114799255"},{"problem":103,"code":"(fn k-combinations \n  ([n s res]\n   (let [elem  (first s)\n         rmdr (rest s)]\n     (cond (zero? n) res\n           (not elem) #{}\n           :else (clojure.set/union (k-combinations (dec n) rmdr (map #(conj % elem) res))\n                                    (k-combinations n rmdr res)))))\n  ([n x]\n   (set (k-combinations n x #{#{}})))\n  )","user":"5f419985e4b0955706451fab"},{"code":"(fn [k s]\n  (loop [i 1 c (for [x s] #{x})]\n    (if (< i k)\n      (recur (inc i) (filter #(= (inc i) (count %)) (for [x c y s] (conj x y))))\n      (set c))))","problem":103,"user":"4e9519b4535dbda64a6f6b2d"},{"code":"(fn k-combination [len col]\n  (let [cnt (count col)\n        selection (->> (int (Math/pow 2 cnt))\n                       (range 1 ,,)\n                       (map #(->> %\n                                  (Integer/toBinaryString ,,)\n                                  (Integer/parseInt ,,)\n                                  (format (str \"%0\" cnt \"d\") ,,)) ,,)\n                       (map seq ,,)\n                       (filter #(= (count (remove (fn [n] (= n \\0)) %)) len) ,,)\n                       (map (fn [s] (map #(if (= % \\1) true false) s))))]\n    (cond (= len cnt) #{col}\n          (> len cnt) #{}\n          :t (reduce #(conj %1\n                            (set\n                             (map second\n                                 (filter (fn [x] (first x))\n                                    (map list %2 col)))))\n                     #{} selection))))","problem":103,"user":"4dd0e8f7535da60f04a96e57"},{"code":"(fn kcom [n items]\n  (letfn [(com [items]\n            (if (empty? items)\n              #{#{}}\n              (let [h (first items)\n                    com-rest (com (rest items))]\n                (into com-rest (map #(conj % h) com-rest)))))]\n\n    (into #{} (filter #(= n (count %)) (com items)))))","problem":103,"user":"4f0d093b535d0136e6c22313"},{"problem":103,"code":"(fn [n ss]\n  (letfn [(powerset [s]\n                    (letfn [(combine [acc x]\n                                     (conj (into acc (map #(conj % x) acc)) #{x}))]\n                      (conj (reduce combine #{} s) #{})))\n          ]\n    (set (filter #(= n (count %)) (powerset ss)))))","user":"53e76bb2e4b036ad0777e47d"},{"problem":103,"code":"(fn k-combinations [k s]\n  (cond (zero? k) #{#{}}\n        (> k (count s)) #{}\n        :else (into #{}\n                    (for [comb (k-combinations (dec k) s)\n                          v s\n                          :when (not (comb v))]\n                      (conj comb v)))))","user":"57609d91e4b08062f99a4e9b"},{"code":"(fn k-combinations [k s]\n (set (filter #(= k (count %))\n              (reduce (fn [kcs e]\n                        (reduce (fn [kce f]\n                                  (conj kce (conj f e)))\n                                kcs kcs))\n                      #{#{}} s))))","problem":103,"user":"4fa0a4b1e4b0dcca54ed6d4f"},{"problem":103,"code":"(fn [n s] (set (filter #(= n (count %)) (reduce (fn [a e] (into a (map #(conj % e) a))) #{#{}} s))))","user":"51e28063e4b08e53a149f0f2"},{"code":"(fn combinations [k s]\n  (cond\n    (zero? k) #{#{}}\n    (empty? s) #{}\n    :else (set (clojure.set/union\n                 (map #(conj % (first s)) (combinations (dec k) (rest s)))\n                 (combinations k (rest s))))))","problem":103,"user":"509e62a8e4b08df8156e9e2e"},{"code":"(fn [n s]\n  (into #{} (filter #(= n (count %))\n      (into #{}\n        (map #(into #{} %)\n             ((fn ps [ls]\n                (if (empty? ls) '(())\n                    (clojure.set/union (ps (next ls))\n                                       (map #(conj % (first ls)) (ps (next ls))))))\n              s))))))","problem":103,"user":"4ff304f4e4b0678c553fc343"},{"code":"#(if (> % (count %2)) #{} (set (map (fn[a](set (take % (shuffle %2)))) (range 1000))))","problem":103,"user":"4fb3dd1ee4b081705acca2a5"},{"code":"(fn [n s]\n  (letfn [(g [x] (set (for [a x, b s] (conj a b))))]\n    (set (filter #(= n (count %)) (nth (iterate g #{#{}}) (inc n))))))","problem":103,"user":"4fe8fda4e4b0547ebccb2438"}]