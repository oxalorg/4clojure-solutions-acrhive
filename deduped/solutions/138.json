[{"problem":138,"code":"(fn [start end]\n   (let [n (take-while (partial >= end) (iterate #(* % %) start))\n         t (str (apply str n))\n         side (int (Math/ceil (Math/sqrt (count t))))\n         filled (concat (seq t) (repeat (- (* side side) (count t)) '* )) \n\n         center (fn [s] (let [ss (apply str (interpose \\space s))\n                              slen (count ss)\n                              wd (dec (* 2 side))]\n                              (->> ss (format (str \"%-\" (/ (+ wd slen) 2) \"s\")) \n                                      (format (str \"%\" wd \"s\")) )))\n\n         inside (fn [yx] (and (>= (yx 0) 0) (< (yx 1) side)))\n         ge (fn [a yx] (->> (iterate #(mapv + % [-1 1]) yx)\n                            (take-while inside)\n                            (map #(get-in (vec a) %))))\n\n         blc (mapv vector \n               (concat (range side) (repeat (dec side) (dec side)))\n               (concat (repeat side 0) (range 1 side)))\n         r45 (fn [a] (map #(center (ge a %)) blc))\n         r90 (fn [a] (reverse (map (comp vec reverse) a)))\n         scroll (fn scroll\n                  ([[h & r]] (scroll [[h]] r))\n                  ([shape r] \n                     (if-not (seq r) shape\n                        (let [rotated (reverse (apply map vector shape)) \n                              slen (count (last rotated))]\n                           (recur (cons (vec (take slen r)) rotated) (nthnext r slen))))))]\n\n         (vec (if (odd? side)\n            (->> filled scroll r45)\n            (->> filled scroll r90 r45)))))","user":"59f043d0e4b0966464fe6a3d"},{"problem":138,"code":"(letfn\n  [(transpose [m] (apply map vector m))\n   (rot90 [m] (->> m (transpose) (map reverse)))\n   (rot-n [n m] (nth (iterate rot90 m) n))\n   (spiral\n     ([h w]\n      (if (= h 0) [[]]\n          (cons (reverse (range (* h w) (* h (inc w))))\n                (rot90 (spiral w (dec h))))))\n     ([w] (spiral w (dec w))))\n   (cons-pairs [xs0 ys0]\n     ; like (apply map vector) but without stopping on empty lists\n     (if-let [[x & xs] xs0]\n       (if-let [[y & ys] ys0]\n         (cons (cons x y) (cons-pairs xs ys))\n         (map list xs0))\n       ys0))\n   (diagonalize [xs0]\n     (if-let [[[a & as] & xs] xs0]\n       (cons\n        (list a)\n        (cons-pairs as (diagonalize xs)))\n       (list)))\n\n   (diag-series [n xs]\n     (let [series (vec (take (* n n) (concat xs (repeat \\*))))]\n       (map #(replace series %) (spiral n))))\n   (squares [x y]\n     (mapcat (comp seq str) (take-while #(<= % y) (iterate #(* % %) x))))\n   (format-line [cnt ln]\n     (let\n      [total-size (dec (* 2 cnt))\n       now (count ln)\n       now-size (dec (* 2 now))\n       left (- total-size now-size)\n       half-left (/ left 2)\n       padding (apply str (repeat half-left \\space))]\n       (apply str (concat padding (clojure.string/join \" \" ln) padding))))]\n   (fn [l r]\n     (let [in (squares l r)\n           n (count in)\n           m (int (Math/ceil (Math/sqrt n)))\n           final-rot (or ({3 3} m) 1)]\n       (map\n        (partial format-line m)\n        (diagonalize (rot-n final-rot (diag-series m in)))))))","user":"5fa416ece4b0f0ebd91b7803"},{"problem":138,"code":"(fn [start end]\n  (letfn [(digits [n]\n                  (if (< n 10)\n                    [n]\n                    (conj (digits (quot n 10)) (rem n 10))))\n\n          (squares [start end]\n                   (lazy-seq\n                     (cons start\n                           (let [start-squared (* start start)]\n                             (if (<= start-squared end)\n                               (squares start-squared end))))))\n\n          (digit-sequence [start end]\n                          (mapcat digits (squares start end)))\n\n          (next-perfect-square [n]\n                               (first (drop-while #(< % n) (map #(* % %) (iterate inc 1)))))\n\n          (char-sequence [digit-sequence]\n                         (take (next-perfect-square (count digit-sequence))\n                               (concat (map (zipmap (range) \"0123456789\") digit-sequence)\n                                       (repeat \\*))))\n\n          (flip [matrix]\n                (reverse (map reverse matrix)))\n\n          (wrap [char-sequence matrix]\n                (if-not (empty? char-sequence)\n                  (let [matrix (flip matrix)]\n                    (let [new-edge-length (inc (count matrix))\n                          first-row (take new-edge-length char-sequence)\n                          char-sequence (drop new-edge-length char-sequence)\n                          remaining-rows (map (fn [old-row digit]\n                                                (concat old-row (list digit)))\n                                              matrix char-sequence)\n                          char-sequence (drop (count remaining-rows) char-sequence)]\n                      (flip (wrap char-sequence (cons first-row remaining-rows)))))\n                  (flip matrix)))\n\n          (rotate45 [matrix]\n                    (let [matrix (mapv vec matrix)\n                          dim (dec (* 2 (count matrix)))]\n                      (for [r (range dim)]\n                        (apply str (for [c (range dim)]\n                                     (or (get-in matrix [(/ (- (+ r c) (- (count matrix) 1)) 2) (/ (- (+ (- (count matrix) 1) c) r) 2)])\n                                         \\space))))))]\n    (rotate45 (wrap (char-sequence (digit-sequence start end)) []))))","user":"5353afa0e4b084c2834f4b03"},{"code":"(fn [x y]\n  (let [f (fn [x y]\n            (loop [x x r (str)]\n              (if (> x y)\n                r\n                (recur (* x x) (str r x)))))\n        g (fn [s]\n            (let [padd (Math/ceil (Math/sqrt (count s)))\n                  padd (- (* padd padd) (count s))]\n              (str s (apply str (repeat padd \\*)))))\n        h-before (fn [r s]\n                   (loop [r r s s i (quot (count r) 2)]\n                     (if (zero? i)\n                       (update-in r [i] (fn[_] s))\n                       (recur (update-in r [i] #(concat [(first s)] % [(last s)] ))\n                              (butlast (next s)) (dec i))\n                     )))\n        h-after  (fn [r s]\n                   (loop [r r s s i (quot (count r) 2)]\n                     (if (= (inc i) (count r))\n                       (update-in r [i] (fn[_] s))\n                       (recur (update-in r [i] #(concat [(last s)] % [(first s)] ))\n                              (butlast (next s)) (inc i))\n                     )))\n        h (fn [s]\n            (loop [r [[(first s)]] s (next s) c 1]\n              (let [l (- (*(inc c)(inc c)) (* c c))]\n                (if (empty? s)\n                  r\n                  (if (= 1 (mod c 2))\n                    (recur (h-after  (vec(concat r [[][]])) (take l s)) (drop l s) (inc c))\n                    (recur (h-before (vec(concat [[][]] r)) (take l s)) (drop l s) (inc c))\n                    )))))\n        res (vec (map (partial interpose \\space) (h(g(f x y)))))\n        mid (quot (count res) 2)\n        pad (fn [r] (loop [r r i 0]\n             (let [g #(concat (concat (repeat i \\space) % (repeat i \\space)))]\n               (if (> i mid)\n                 r\n                 (recur (update-in (update-in r [(+ mid i)] g) [(- mid i)] g) (inc i))\n                 ))))\n        res (map (partial apply str) (pad res) )\n        ]\n    res ))","problem":138,"user":"5349ac2be4b084c2834f4a67"},{"problem":138,"code":"(fn [start end]\n  (let [squares (fn [s e]\n                  (take-while #(<= % e) (iterate #(* % %) s)))\n        pad-length (fn [nums]\n                     (first (filter #(<= (count (apply str nums)) %) (map #(* % %) (range)))))\n        padded (fn [nums length]\n                 (take length (apply str (apply str nums) (repeat length \"*\"))))\n        add-points (fn [[x1 y1] [x2 y2]] [(+ x1 x2) (+ y1 y2)])\n        sub-points (fn [[x1 y1] [x2 y2]] [(- x1 x2) (- y1 y2)])\n        directions (cycle [[1 1] [1 -1] [-1 -1] [-1 1]])\n        origin-offsets (fn [n]\n                         (loop [steps (dec n)\n                                accum [[0 0]]\n                                current-dir nil\n                                next-dirs directions]\n                           (if (zero? steps)\n                             accum\n                             (let [test-offset (add-points (last accum) (first next-dirs))]\n                               (if (some #{test-offset} accum)\n                                 (recur (dec steps) (conj accum (add-points (last accum) current-dir)) current-dir next-dirs)\n                                 (recur (dec steps) (conj accum test-offset) (first next-dirs) (drop 1 next-dirs)))))))\n        normalize (fn [offsets]\n                    (let [min-x (apply min (map first offsets))\n                          min-y (apply min (map second offsets))]\n                      (map #(sub-points % [min-x min-y]) offsets)))\n        grid-size (fn [normalized]\n                    (inc (apply max (map first normalized))))\n        empty-grid (fn [size]\n                     (vec (repeat size (vec (repeat size \" \")))))\n        normalized-with-vals (fn [normalized vals]\n                               (zipmap normalized vals))\n        update-grid (fn [grid nv]\n                      (reduce #(assoc-in % (first %2) (second %2)) grid nv))\n        str-grid (fn [grid]\n                   (map #(apply str %) grid))\n\n\n        sqs (squares start end)\n        len (pad-length sqs)\n        pad (padded sqs len)\n        off (origin-offsets len)\n        nrm (normalize off)\n        gsz (grid-size nrm)\n        grid (empty-grid gsz)\n        nv (normalized-with-vals nrm pad)\n        grid (update-grid grid nv)\n        grid (str-grid grid)]\n    grid))","user":"5164867fe4b003cf19fdde3e"},{"problem":138,"code":"(fn t [p q]\n  (let\n    [s1 (loop [t (str p) v p]\n         (if (> (* v v) q)\n           t\n           (recur (str t (* v v)) (* v v))))\n     \n     k (int (Math/ceil (Math/sqrt (count s1))))\n     q (+ k k -1)\n     bl (vec (repeat q \" \"))\n     r (mapv vec (repeat q bl))\n     a (- (* k k) (count s1))\n     s2 (concat s1 (repeat a \"*\"))\n     [sx sy] (if (even? k)  [(dec k) (- k 2)] [(dec k) (dec k)])\n     mvs (flatten (map #(vector % %) (range 1 (+ q q))))\n     dirs (cycle [[1 1] [1 -1] [-1 -1] [-1 1]])]\n    (map #(apply str %)\n      (loop [yx [sy sx] s s2 mv mvs dir dirs rs r]\n        (if (empty? s)\n          rs\n          (let [rs (assoc-in rs yx (str (first s))) yx (mapv + yx (first dir)) s (rest s) ]\n            (if (> (first mv) 1)\n              (recur yx s (cons (dec (first mv)) (rest mv)) dir rs)\n              (recur yx s (rest mv) (rest dir) rs))))))))","user":"56bca51ae4b0f26550335963"},{"problem":138,"code":"(fn [a b]\n    (let [square-seq (take-while #(<= % b) (iterate #(* % %) a))\n          square-str (apply str square-seq)\n          str-len (first (drop-while #(< % (.length square-str)) (map #(* % %) (range))))\n          padded-str (apply str square-str (repeat (- str-len (.length square-str)) \"*\"))\n          side (dec (* 2 (int (Math/sqrt str-len))))\n          xoff (int (/ side 2))\n          yoff (- xoff (if (even? str-len) 1 0))\n          evens (filter even? (range))\n          odds (filter odd? (range))\n          xs (reductions #(+ %1 %2)\n                         0\n                         (mapcat #(repeat %2 %1) (cycle [1 -1]) odds))\n          ys (reductions #(+ %1 %2)\n                         0\n                         (mapcat #(repeat %2 %1) (cycle [-1 1]) evens))\n          cmap (zipmap (take str-len (map #(vector (+ xoff %1) (+ yoff %2)) xs ys))\n                       padded-str)]\n      (for [j (range side)]\n        (apply str (for [i (range side)]\n                     (get cmap [i j] \\space))))))","user":"5275f7a2e4b03e8d9a4a74d0"},{"code":"(fn [x y]\n  (let [gen-squares (fn gen-squares [s e] (if (> s e) [] (cons s (gen-squares (* s s) e))))\n        addfillers (fn addfillers [s]\n                      (loop [c 1]\n                        (let [d (- (* c c) (count s))]\n                          (if (>= d 0)\n                            (apply str (concat s (repeat d \\*)))\n                            (recur (inc c))))))\n        gen-string (addfillers (apply str (gen-squares x y)))\n        next-coord (fn [[x y]]\n                     (if (<= y 0)\n                       (if (>= x 0)\n                         [(inc x) (inc y)]\n                         [(inc x) (dec y)])\n                       (if (> x 0)\n                         [(dec x) (inc y)]\n                         [(dec x) (dec y)])))\n        coords (fn coords [] \n                 ((fn c [a]\n                    (cons a (lazy-seq (c (next-coord a)))))\n                  [0 0]))\n        gen-map (apply merge (map #(assoc {} %2 %) gen-string (coords)))\n        mk-row (fn [m r len]\n                 (apply str (map #(get m [(- % (int (/ len 2))) (- r (int (/ len 2)))] \\space) (range len))))\n        len (dec (* 2 (Math/sqrt (count gen-map))))\n        rowrange (if (odd? (int (Math/sqrt (count gen-map)))) (range len) (map inc (range len)))\n        ]\n    (map #(mk-row gen-map % len) rowrange)))","problem":138,"user":"513b77f3e4b00f740c76c403"},{"problem":138,"code":"(fn [s e]\n  (let [A #(apply str %)\n        R repeat\n        r (take-while #(<= % e) (iterate #(long (Math/pow % 2)) s))\n        s (A r)\n        c (count s)\n        z (->> [1 1]\n            (iterate (fn [[i j]] [(+ i (+ j 2)) (+ j 2)]))\n            (drop-while #(< (% 0) c))\n            (take 1)\n            ffirst)\n        s (str s (A (R (- z c) \"*\")))\n        q (long (Math/sqrt z))\n        l (+ q (- q 1))\n        a (max 0 (- q 1))\n        q (if (even? q) (- q 2) (- q 1))\n        b (apply vector (R l (vec (R l \\ ))))\n        n #(* % -1)\n        z? zero?\n        b (reduce (fn [[b x y dx dy cl ct cr] v]\n                    (let [b (assoc-in b [y x] v)\n                          cr (- cr 1)\n                          ct (if (z? cr) (- ct 1) ct)\n                          [cl ct] (if (z? ct) [(+ cl 1) 2] [cl ct])\n                          [dx dy] (if (z? cr)\n                                    (if (= 0 (+ dx dy))\n                                        [dx (n dy)]\n                                        [(n dx) dy])\n                                    [dx dy])\n                          cr (if (z? cr) cl cr)\n                          x (+ x dx)\n                          y (+ y dy)]\n                      [b x y dx dy cl ct cr]))\n                   [b a q 1 1 1 2 2]\n                   s)]\n    (mapv #(A %) (b 0))))","user":"4ee4f4a9535d1385b2869d85"},{"problem":138,"code":"(fn [from to]\n  (let [chars (fn [from to]\n                (let [ints (loop [e from\n                                  s []]\n                             (cond\n                              (= e to) (conj s e)\n                              (> e to) s\n                              :else (recur (* e e) (conj s e))))\n                      chars (apply str (map str ints))\n                      [order tofill] (let [n (count chars)]\n                                       (loop [i 1]\n                                         (if (<= n (* i i))\n                                           [i (* i i)]\n                                           (recur (inc i)))))\n                      content (concat chars (take (- tofill (count chars)) (repeat \\*)))]\n                  [order content]))\n        rot (fn [[row col]] [col (- row)])\n        tr (fn [[row col][drow dcol]] [(+ row drow) (+ col dcol)])\n        fill (fn [n content]\n               (loop [[row col :as pos] [0 0]\n                      [drow dcol :as vec] [1 1]\n                      fill '()\n                      i 1\n                      side-length 1\n                      pos-in-side 1]\n                 (let [fill' (cons [pos (nth content (dec i))] fill)]\n                   (cond\n                    (= i n) fill'\n                    (= i (* side-length side-length)) (recur (tr pos vec) (rot vec) fill'\n                                                             (inc i) (+ 2 side-length) 2)\n                    (= side-length pos-in-side) (recur (tr pos (rot vec)) (rot vec) fill'\n                                                       (inc i) side-length 2)\n                    :else (recur (tr pos vec) vec fill' (inc i) side-length (inc pos-in-side))))))\n        [order content] (chars from to)\n        ofill (fill (* order order) content)\n        ofillmap (into {} ofill)\n        coords (keys ofillmap)\n        [sbrows sbcols] [(sort-by first coords) (sort-by second coords)]\n        [minrow maxrow mincol maxcol] [(first (first sbrows)) (first (last sbrows))\n                                       (second (first sbcols)) (second (last sbcols))]]\n    (for [row (range (inc (- maxrow minrow)))]\n      (apply str (for [col (range (inc (- maxcol mincol)))]\n                   (get ofillmap [(+ row minrow) (+ col mincol)] \\space))))))","user":"547d8e93e4b0c51c1f4d72f4"},{"code":"(fn [a b] (letfn [ (square [x] (* x x)) (squares-up-to [a b] (take-while #(<= % b) (iterate square a))) (digits [ns] (map #(Integer/parseInt (str %)) (apply str ns))) (next-square [n] (first (drop-while #(> n %) (map square (iterate inc 1))))) (digits-of-square [a b] (let [ds (digits (squares-up-to a b)) ns (next-square (count ds))] (concat ds (repeat (- ns (count ds)) '*)))) (square-size [ds] (int (Math/sqrt (count ds)))) (columns [rectangle] (apply map vector rectangle)) (prepend-column [rect col] (columns (cons col (columns rect)))) (append-column [rect col] (columns (concat (columns rect) (vector col)))) (prepend-row [rect row] (cons row rect)) (append-row [rect row] (concat rect (vector row))) (row-count [rect] (count rect)) (column-count [rect] (apply max (map count rect))) (spiral-clockwise-out-step [xs rect dirs] (let [side (first dirs)] (cond (empty? xs) (vector xs rect []) (= :right side) (vector (drop (row-count rect) xs) (append-column rect (take (row-count rect) xs)) (rest dirs)) (= :bottom side) (vector (drop (column-count rect) xs) (append-row rect (reverse (take (column-count rect) xs))) (rest dirs)) (= :left side) (vector (drop (row-count rect) xs) (prepend-column rect (reverse (take (row-count rect) xs))) (rest dirs)) (= :top side) (vector (drop (column-count rect) xs) (prepend-row rect (take (column-count rect) xs)) (rest dirs)) ) ) ) (iterate-while-changes [f x] (cons x (map second (take-while #(not= (first %) (second %)) (partition 2 1 (iterate f x)))))) (spiral-clockwise-out [a b] (let [dos (digits-of-square a b)] (second (last (iterate-while-changes #(apply spiral-clockwise-out-step %) [(rest dos) [[(first dos)]] (take (count dos) (cycle [:right :bottom :left :top]))]))))) (nth1 [coll n] (nth coll (dec n))) (range1 [from to] (range from (inc to))) (diagonal [n] (map vector (range1 n) (reverse (range1 n)))) (value-at [sq pos] (nth1 (nth1 sq (second pos)) (first pos))) (diagonal [sq n] (map #(value-at sq %) (pair-range n))) (reverse-range1 [n len] (take len (reverse (range1 n)))) (square-ne-border [n] (concat (map #(vector 1 %) (range1 1 n)) (drop 1 (map #(vector % n) (range1 1 n))))) (pair-range [from to] (map vector (range1 from to) (reverse (range1 from to)))) (square-en-diagonals [n] (map (partial apply pair-range) (square-ne-border n))) (en-diagonal-values [sq] (map (fn [diag] (map #(value-at sq %) diag)) (square-en-diagonals (count sq)))) (center [row len] (let [padding (repeat (quot (- len (count row)) 2) \" \")] (concat padding row padding))) (diamond [a b] (map (partial interpose \" \") (en-diagonal-values (spiral-clockwise-out a b)))) (diamond-centered [a b] (map #(center % (apply max (map count (diamond a b)))) (diamond a b))) (display-spiral [a b] (map (partial apply str) (diamond-centered a b))) ] (display-spiral a b)))","problem":138,"user":"52f10094e4b05e3f0be25ee8"},{"code":"(fn [i j]\n  (let [num-str (apply str (take-while #(<= % j) (iterate #(* % %) i)))\n        str-size (first (drop-while #(< (* % %) (count num-str)) (range)))\n        s (concat num-str (repeat (- (* str-size str-size) (count num-str)) \\*))\n        board-size (dec (* 2 str-size))\n        init-board (vec (repeat board-size (vec (repeat board-size \\space))))]\n    (println init-board)\n    (letfn [(step [board current gap str-seq]\n              (if (seq str-seq)\n                (let [next-board (assoc-in board current (first str-seq))\n                      f-next-gap (if (zero? (first current))\n                                   [1 -1]\n                                   (if (= (dec board-size) (first current))\n                                     [-1 1]\n                                     (if (zero? (second current))\n                                       [1 1]\n                                       (if (= (dec board-size) (second current))\n                                         [-1 -1]\n                                         gap))))\n                      f-next-current (map #(+ %1 %2) current f-next-gap)\n                      next-gap (if (= \\space (get-in board f-next-current))\n                                 f-next-gap\n                                 (case f-next-gap\n                                   [1 -1] [1 1]\n                                   [1 1] [-1 1]\n                                   [-1 1] [-1 -1]\n                                   [-1 -1] [1 -1]))]\n                  (step next-board (map #(+ %1 %2) current next-gap) next-gap (next str-seq)))\n                board))]\n      (mapv #(apply str %) (step init-board (if (odd? str-size) [(dec str-size) (dec board-size)] [(dec str-size) 0]) [1 1] (reverse s))))))","problem":138,"user":"514d7e29e4b019235f6c0587"},{"code":"(fn sqsq [a b] (let [s (apply str (take-while #(<= % b) (iterate #(* % %) a))) ; string of digits of squares\n                       k (int (Math/sqrt (count s)))\n                       n (if (zero? (- k (Math/sqrt (count s)))) k (inc k)); n^2 is the length of spiral \n                       sf (map #(get s % \"*\") (range (* n n))) ; full line with digits and *s\n                       m (dec (* 2 n))  ; size of table\n                       t0 (vec (repeat m (vec (repeat m \" \")))) ; empty table of spaces\n                       ]\n                   ((fn spiral [t [x y] [dx dy] [head & tail]] ; set 'head' of string at x,y and checks if it's possible to turn on next step\n                      (let [nt (assoc-in t [y x] head) ; new table \n                            nx (+ x dx) ny (+ y dy) ; new [x y]                             \n                            rx (- dy)               ; |0  1| matrix to rotate [dx dy] to the right \n                            ry dx                   ; |-1 0| \"y\" - from top to bottom, \"x\" - from left to right\n                            otr (get-in nt [(+ ny ry) (+ nx rx)]) ; element on the right\n                            ]\n                        (if (empty? tail) \n                            (map #(apply str %) nt)\n                            (spiral nt \n                                    [nx ny] \n                                    (if (= \" \" otr) [rx ry] [dx dy]) ; if there is space on the right then turn else keep direction \n                                    tail)\n                         ))\n                      ) t0 [(dec n) (if (even? n) (- n 2) (dec n))] [1 1] sf)) ; if n is even then the first digit is not exactly at the center\n                 )","problem":138,"user":"526a3412e4b03e8d9a4a721e"},{"code":"(fn [start end]\n  (let [rng (loop [n start res []]\n              (if (> n end)\n                res\n                (recur (* n n) (conj res n))))\n        digits (vec (mapcat (comp vec str) rng))\n        sqrt (-> digits count Math/sqrt Math/ceil int)\n        len (dec (* sqrt 2))\n        padded (into digits (repeat (- (* sqrt sqrt) (count digits)) \\*))]\n    (loop [chart (vec (repeat len (vec (repeat len \\space))))\n           [digit & rst] padded\n           x (* (quot (dec sqrt) 2) 2)\n           y (dec sqrt)\n           a 1\n           b 1\n           left 1\n           chars 1.0]\n      (if digit\n        (let [X (+ x a)\n              Y (+ y b)\n              C (assoc-in chart [x y] digit)\n              L (dec left)]\n          (if (zero? L)\n            (let [[A B] [b (- a)]\n                  H (+ chars 0.5)\n                  L (int H)]\n              (recur C rst X Y A B L H))\n            (recur C rst X Y a b L chars)))\n        (map #(apply str %) chart)))))","problem":138,"user":"4f437751e4b0d7d3c9f3fd20"},{"code":"(fn [start stop]\n  (let\n      [sq-from-to\n       (fn sq-from-to\n         ([start stop]\n            (sq-from-to start stop []))\n         ([start stop so-far]\n            (if (> start stop)\n              so-far\n              (sq-from-to (* start start)\n                          stop\n                          (into so-far (vec (str start)))))))\n       \n       sq-above\n       (fn [n]\n         (Math/pow (Math/ceil (Math/sqrt n)) 2))\n\n       pad-to-sq\n       (fn [somesequence]\n         (let [l (count somesequence)\n               to-add (- (sq-above l) l)]\n           (into somesequence (repeat to-add \"*\"))))\n\n       next-steps\n       (fn [n]\n         (take n (flatten (map #(into \n                                 (into (vec (repeat % :dr))\n                                       (vec (repeat % :dl)))\n                                 (into (vec (repeat (inc %) :ul))\n                                       (vec (repeat (inc %) :ur ))))\n                               (iterate #(+ 2 %) 1)))))\n       \n       skelleton\n       (fn [n]\n         (let [width (Math/sqrt n)\n               size (- (* 2 width) 1)]\n           (vec (repeat size\n                        (vec (repeat size \" \"))))))\n       \n       start-pos\n       (fn [n]\n         (let [width (int (Math/sqrt n))\n               size (- (* 2 width) 1) ]\n           (if (odd? width)\n             [(dec width) (dec width)]\n             [(dec width) (- width 2)]\n             )))\n\n       draw-spiral\n       (fn draw-spiral\n         ([some-sequence]\n            (let [l (count some-sequence)]\n              (draw-spiral (skelleton l) (start-pos l) some-sequence (next-steps l))))\n         ([result position remaining steps-left]\n            ;; (do\n            ;;   (pprint result)\n            ;;   (println position)\n            ;;   (println remaining)\n            ;;   (println steps-left)\n            ;;   (\n            (if (empty? remaining)\n              result\n              (let [deltas {:dr [1 1]\n                            :dl [-1 1]\n                            :ul [-1 -1]\n                            :ur [1 -1] }\n                    [x-diff y-diff] (deltas (first steps-left))\n                    next-item (first remaining)\n                    [old-x old-y] position\n                    new-x (+ old-x x-diff)\n                    new-y (+ old-y y-diff)]\n                (draw-spiral (assoc-in result [old-y old-x] next-item)\n                      [new-x new-y]\n                      (rest remaining)\n                      (rest steps-left))))))\n       ;;))\n       ]\n    \n    (vec (map #(clojure.string/join \"\" %) (draw-spiral (pad-to-sq (sq-from-to start stop)))))))","problem":138,"user":"4daea889edd6309eace4d15b"},{"code":"(fn [x end]\r\n    (let [npt (apply str (take-while #(<= % end) (iterate #(* % %) x)))\r\n          bl (int (Math/ceil (Math/sqrt (count npt))))\r\n          pt (apply str npt (repeat (- (#(* % %) bl) (count npt)) \\*))]\r\n      (letfn [(sqr [x] (* x x))\r\n              (mak-sqr-vec [bl pt]\r\n                (cond\r\n                 (= bl 1) [pt]\r\n                 (even? bl) (let [used-count (sqr (dec bl))\r\n                                  oldvec (mak-sqr-vec (dec bl) (subs pt 0 used-count))]\r\n                                  (vec (concat (map-indexed (fn [idx line] (str (get pt (+ used-count bl (- bl 2 idx))) line)) oldvec)\r\n                                          (list (apply str (reverse (subs pt used-count (+ used-count bl))))))))\r\n                 :else      (let [used-count (sqr (dec bl))\r\n                                  oldvec (mak-sqr-vec (dec bl) (subs pt 0 used-count))]\r\n                                  (vec (concat (list (apply str  (subs pt used-count (+ used-count bl))))\r\n                                               (map-indexed (fn [idx line] (str line (get pt (+ used-count bl idx)))) oldvec)\r\n                                          )))))\r\n              (mak-diamond-vec [vec]\r\n                (let [bl (count vec)]\r\n                     (for [row (range (dec (* bl 2)))\r\n                           :let [ru  (- row (dec bl)) ruabs (Math/abs ru)]]\r\n                          (str (apply str (repeat ruabs \\space))\r\n                               (apply str (interpose \\space\r\n                                             (for [x (range (max 0 ru) (min bl (inc row)))\r\n                                                   :let [y (- x ru)]]\r\n                                                 (get-in vec [x y]))))\r\n                               (apply str (repeat ruabs \\space))))))]\r\n        (mak-diamond-vec (mak-sqr-vec bl pt)))))","problem":138,"user":"4f474f43e4b0d56e7bb92bb7"},{"code":"(fn boo [x y]\n  (let [squared (mapcat #(seq (str %)) (take-while #(<= % y) (iterate #(* % %) x)))\n        perfects (map #(* % %) (range))\n        length (first (drop-while #(< % (count squared)) perfects))\n        side-length (int (Math/sqrt length))\n        side-length (dec (* 2 side-length))\n        squared (concat squared (repeat\n                                 (- length (count squared))\n                                 \\*))\n        direction-seq (cycle [:down :left :up :right])\n        freq-seq (drop 2 (interleave (range) (range)))\n        directions (concat '(:start) (mapcat repeat freq-seq direction-seq))\n        dir {:up [-1 0] :down [1 0] :left [0 -1] :right [0 1] :start [0 0]}\n        val-coord (map vector squared directions)\n        val-coord (map (fn [[c d]] [c (dir d)]) val-coord)\n        val-coord (reductions (fn [[chr [r c]] [nchr [dr dc]]]\n                                [nchr [(+ r dr) (+ c dc)]])\n                              val-coord)\n        rotated-val-coord (map (fn [[v [r c]]]\n                                 [v [(- r c) (+ c r)]])\n                               val-coord)\n        min-r (apply min (map (fn [[_ [r _]]] r) rotated-val-coord))\n        min-c (apply min (map (fn [[_ [_ c]]] c) rotated-val-coord))\n        offset-val-coord (map (fn [[v [r c]]]\n                                [v [(- r min-r) (- c min-c)]])\n                              rotated-val-coord)\n        result (vec (repeat side-length (vec (repeat side-length \\space))))\n        result (reduce (fn [board [v coord]]\n                         (assoc-in board coord v))\n                       result\n                       offset-val-coord)\n        result (mapv #(apply str %) result)\n        ]\n    result))","problem":138,"user":"50217818e4b00bba4502f7a7"},{"code":"(fn [s e]\n  (letfn [(f [s e r]\n            (if (> s e)\n              r\n              (f (* s s) e (conj r s))))\n          (g [n l]\n            (let [c (count l)\n                  nn (* n n)]\n              (if (> c nn)\n                (g (inc n) l)\n                (concat l (repeat (- nn c) \\*)))))\n          (h [p d n]\n            (map #(vec (map + p (map * d [% %])))\n                 (range 1 (inc n))))\n          (r [d] (vector (* -1 (last d)) (first d)))\n          (hl [p d n]\n            (let [a (h p d n)\n                  d1 (r d)\n                  b (h (last a) d1 n)]\n              (lazy-cat a b (hl (last b) (r d1) (inc n)))))]\n    (let [m (apply conj {}\n                   (map #(vector % %2)\n                        (cons [0 0] (hl [0 0] [1 1] 1))\n                        (->> []\n                             (f s e)\n                             (map str)\n                             (apply concat)\n                             (g 1))))\n          k (keys m)\n          xs (map first k)\n          ys (map last k)\n          x- (apply min xs)\n          x+ (inc (apply max xs))\n          y- (apply min ys)\n          y+ (inc (apply max ys))]\n      (for [y (range y- y+)]\n        (apply str\n               (for [x (range x- x+)]\n                 (or (m [x y]) \\ )))))))","problem":138,"user":"53460d02e4b084c2834f4a39"},{"code":"(fn [n m]\n  (letfn\n\t\t[\n\t\t\t(_squares-digits [n m r]\n\t\t\t\t(if (> n m)\n\t\t\t\t\tr\n\t\t\t\t\t(recur (* n n) m (concat r (str n)))\n\t\t\t\t))\n\t\t\t(ceil-square [n]\n\t\t\t\t(let [r (Math/ceil (Math/sqrt n))]\n\t\t\t\t\t(* r r)\n\t\t\t\t))\n\t\t\t(padded [n c xs]\n\t\t\t\t(take\n\t\t\t\t\tn\n\t\t\t\t\t(concat xs (repeat c))\n\t\t\t\t))\n\t\t]\n\t\t(let\n\t\t\t[\n\t\t\t\tds (_squares-digits n m \"\")\n\t\t\t\tcs (int (ceil-square (count ds)))\n\t\t\t\tsl (int (Math/sqrt cs))\n\t\t\t\tchars (padded cs \\* ds)\n\t\t\t\toutput-width (dec (* sl 2))\n\t\t\t\toutput-grid (apply vector (repeat output-width (apply vector (repeat output-width \\space))))\n\t\t\t\tstart [(- (quot (dec output-width) 2) (- 1 (mod sl 2))) (quot (dec output-width) 2)]\n\t\t\t\tdirs [[1 1] [1 -1] [-1 -1] [-1 1]]\n\t\t\t]\n\t\t\t(loop\n\t\t\t\t[\n\t\t\t\t\txs chars\n\t\t\t\t\tgrid output-grid\n\t\t\t\t\t[j i] start\n\t\t\t\t\tdir-index 0\n\t\t\t\t]\n\t\t\t\t(let\n\t\t\t\t\t[\n\t\t\t\t\t\t[dj di] (dirs dir-index)\n\t\t\t\t\t\tturned-dir-index (mod (inc dir-index) 4)\n\t\t\t\t\t\t[dtj dti] (dirs turned-dir-index)\n\t\t\t\t\t\t[new-turned-j new-turned-i] [(+ dtj dj j) (+ dti di i)]\n\t\t\t\t\t\tturn? (= \\space (get-in grid [new-turned-j new-turned-i]))\n\t\t\t\t\t]\n\t\t\t\t\t(println [[j i] dir-index])\n\t\t\t\t\t(if (empty? xs)\n\t\t\t\t\t\t(map (partial apply str) grid)\n\t\t\t\t\t\t(recur\n\t\t\t\t\t\t\t(rest xs)\n\t\t\t\t\t\t\t(assoc-in grid [j i] (first xs))\n\t\t\t\t\t\t\t[(+ dj j) (+ di i)]\n\t\t\t\t\t\t\t(if turn? turned-dir-index dir-index)\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t))\n\t))","problem":138,"user":"507eddf4e4b06ce648bcdbfa"},{"problem":138,"code":"(fn [s e]\n  (let [numbs (reduce str \"\" (loop [c s acc []]\n                            (if (> c e)\n                              acc\n                              (recur (* c c) (conj acc c)))))\n        numbs* (loop [n numbs]\n                 (if (= (-> (count n) Math/sqrt Math/floor) (Math/sqrt (count n)))\n                   n\n                   (recur (str n \\*))))\n        grid-dim (int (dec (* 2 (Math/sqrt (count numbs*))))) ;; 2n -1\n        grid (for [_ (range grid-dim)]\n               (reduce (fn [tot _] (str tot \" \")) \"\" (range grid-dim)))\n        direction {[-1 1], [1 1]\n             [1 1], [1 -1]\n             [1 -1], [-1 -1]\n             [-1 -1], [-1 1]}\n        half-point (/ (dec grid-dim) 2)\n\n        pos (if (even? half-point)\n                [half-point half-point]\n                [(dec half-point) half-point])\n        replace-char (fn r [grid [i j] c]\n                       (map (fn [row p]\n                              (if (= p i)\n                                (str (subs row 0 j) c (subs row (inc j)))\n                                row)) grid (range (count grid))))]\n    (loop [n numbs*,grid grid, pos pos, d (direction [-1 1]), c1 0, flip false, numb-steps 0]\n      (cond\n        (empty? n)\n        grid\n        (and (zero? c1) flip) ;; when both counters c1 and c2 hit 0, then inc numb-steps and change direction\n        (recur (rest n)\n               (replace-char grid pos (first n))\n               (map + pos d)\n               (direction d)\n               (inc numb-steps)\n               (not flip) ;; flip -> false\n               (inc numb-steps)\n               )\n        (zero? c1) ;; when only the first counter hit 0 (that reflects the number of step in specific direction) then change direction\n        (recur (rest n)\n               (replace-char grid pos (first n))\n               (map + pos d)\n               (direction d)\n               numb-steps\n               (not flip) ;; flip -> true\n               numb-steps)\n        \n        :else ;; when no counters at 0, then keep goin in the same direction\n        (recur (rest n)\n               (replace-char grid pos (first n))\n               (map + pos d)\n               d\n               (dec c1)\n               flip\n               numb-steps)\n        \n        ))))","user":"608ec5e4e4b03bd49d9f36c0"},{"problem":138,"code":"(fn squares [start end]\n  (letfn [(create-string []\n            (loop [n start\n                   s \"\"]\n              (if\n                (< end n)\n                s\n                (recur\n                  (* n n)\n                  (str s n)))))\n          (resize-board [{:keys [board cursor] :as diamond}]\n            (-> diamond\n                (update-in\n                  [:cursor 1]\n                  inc)\n                (update-in\n                  [:cursor 0]\n                  (if-not \n                    (neg? (second cursor))\n                    identity\n                    (partial + 2)))\n                (assoc\n                  :board\n                  (mapv\n                    #(vec (concat [\\space] % [\\space]))\n                    board))\n                (update-in \n                  [:board]\n                  (comp\n                    vec\n                    #(concat \n                      (when\n                        (neg? (second cursor))\n                        (repeat 2\n                         (vec (repeat (+ 2 (count board)) \\space))))\n                      %          \n                      (when-not\n                        (neg? (second cursor))\n                        (repeat 2\n                          (vec (repeat (+ 2 (count board)) \\space)))))))))\n          (add-character [{:keys [board cursor draw-dir] :as diamond} character]\n            (cond\n              (= (second cursor) (count board))\n                (let\n                  [resized (resize-board diamond)]\n                  (-> resized\n                      (assoc-in\n                        (cons :board (:cursor resized))\n                        character)\n                      (assoc\n                        :draw-dir\n                        [1 -1])\n                      (update-in\n                        [:cursor]\n                        (partial\n                          mapv +\n                          [1 -1]))))\n              (= (first cursor) (dec (count board)))\n                (-> diamond\n                    (assoc-in\n                      (cons :board cursor)\n                      character)\n                    (assoc\n                      :draw-dir\n                      [-1 -1])\n                    (update-in\n                      [:cursor]\n                      (partial mapv dec)))\n              (neg? (second cursor))\n                (let\n                  [resized (resize-board diamond)]\n                  (-> resized\n                      (assoc-in\n                        (cons :board (:cursor resized))\n                        character)\n                      (assoc\n                        :draw-dir\n                        [-1 1])\n                      (update-in\n                        [:cursor]\n                        (partial mapv +)\n                        [-1 1])))\n              (zero? (first cursor))\n                (-> diamond\n                    (assoc-in\n                      (cons :board cursor)\n                      character)\n                    (update-in\n                      [:cursor]\n                      (partial mapv inc))\n                    (assoc\n                      :draw-dir\n                      [1 1]))\n              :else\n                (-> diamond\n                    (assoc-in\n                      (cons :board cursor)\n                      character)\n                    (update-in\n                      [:cursor]\n                      (partial \n                        mapv + \n                        draw-dir)))))\n          (complete-diamond [{:keys [board cursor draw-dir] :as diamond}]\n            (cond         \n              (or (= (second cursor) (count board))\n                  (neg? (second cursor)))\n                diamond\n              (zero? (first cursor))\n                (recur \n                  (-> diamond\n                      (assoc-in\n                        (cons :board cursor)\n                        \\*)\n                      (assoc\n                        :draw-dir\n                        [1 1])\n                      (update-in\n                        [:cursor]\n                        (partial\n                          mapv + [1 1]))))\n              (= (first cursor) (dec (count board)))\n                (recur \n                  (-> diamond\n                      (assoc-in\n                        (cons :board cursor)\n                        \\*)\n                      (assoc\n                        :draw-dir\n                        [-1 -1])\n                      (update-in\n                        [:cursor]\n                        (partial\n                          mapv + [-1 -1]))))\n              :else\n                (recur\n                  (-> diamond\n                      (assoc-in\n                        (cons :board cursor)\n                        \\*)\n                      (update-in\n                        [:cursor]\n                        (partial mapv +)\n                        draw-dir)))))]                \n    (let\n      [s (create-string)\n       initial {:cursor [1 1] \n                :draw-dir [1 1]\n                :board [[(first s)]]}\n       final (complete-diamond\n               (reduce add-character initial (rest s)))]\n      (map\n        (partial apply str)\n        (:board final)))))","user":"521e8227e4b0dd19981ad082"},{"problem":138,"code":"(fn square[start end]\n  (letfn[\n          (squares [start end]\n  (loop [cur start r []]\n    (if (> cur end) r (recur (* cur cur) (conj r cur)))\n    )\n  )\n\n(get-size [c]\n  (loop [r 1]\n    (let [s (* r r)]\n      (if (<= c s)\n        s\n        (recur (inc r))\n        )))\n  )\n\n(generate-cords [a sl l]\n  (if (= 1 l)\n    {[0 0] (str (first a))} \n    (loop [r (if (odd? (int (Math/sqrt (get-size l)))) (int (/ sl 2)) (dec (int (/ sl 2))))\n           c (int (/ sl 2))\n           size 0\n           cnt 0\n           state 0\n           state-count 1\n           res {}]\n      (cond\n        (>= cnt (dec l)) (assoc res [r c] (nth a cnt))\n        (and (= state 0) (not (zero? state-count))) (recur (inc r) (inc c) size       (inc cnt) 0 (dec state-count) (assoc res [r c] (nth a cnt)))\n        (= state 0)                                 (recur (inc r) (dec c) size       (inc cnt) 1 size              (assoc res [r c] (nth a cnt)))\n        \n        (and (= state 1) (not (zero? state-count))) (recur (inc r) (dec c) size       (inc cnt) 1 (dec state-count) (assoc res [r c] (nth a cnt)))\n        (= state 1)                                 (recur (dec r) (dec c) (inc size) (inc cnt) 2 (inc size)        (assoc res [r c] (nth a cnt)))\n        \n        (and (= state 2) (not (zero? state-count))) (recur (dec r) (dec c) size       (inc cnt) 2 (dec state-count) (assoc res [r c] (nth a cnt)))\n        (= state 2)                                 (recur (dec r) (inc c) size       (inc cnt) 3 size              (assoc res [r c] (nth a cnt)))\n        \n        (and (= state 3) (not (zero? state-count))) (recur (dec r) (inc c) size       (inc cnt) 3 (dec state-count) (assoc res [r c] (nth a cnt)))\n        (= state 3)                                 (recur (inc r) (inc c) (inc size) (inc cnt) 0 (inc size)        (assoc res [r c] (nth a cnt)))\n        )\n      )\n    )\n  )\n\n(get-field-size [l]\n  (dec (* 2 (int (Math/sqrt l))))\n  )\n]\n  (let [s (apply str (squares start end))\n        l (get-size (count s))\n        t (take l (concat s (repeat \"*\")))\n        rl (get-field-size l)\n        cords (generate-cords t rl l)]\n    (map #(apply str %) (partition rl\n                          (for [r (range rl) c (range rl)]\n                            (if (cords [r c]) (cords [r c]) \" \")\n                            )))\n    )\n  )\n  )","user":"55eeb37ae4b0121d4835fdf3"},{"problem":138,"code":"(fn [start end]\n  (if (= start end)\n    [(str start)]\n    (let [square (fn [x] (*' x x))\n          numbers (reduce str (take-while #(<= % end) (iterate square start)))\n          total (first (drop-while #(< % (count numbers)) (map square (range))))\n          chars (take total (concat numbers (repeat total \\*)))\n          data (letfn [(p-fn [[x y] [x-inc x-d x-next-d] [y-inc y-d y-next-rd] [ch & chs :as chars]]\n                         (when (seq chars)\n                           (let [x-state (if (= x-d 1) [(- x-inc) x-next-d (+ 2 x-next-d)] [x-inc (dec x-d) x-next-d])\n                                 y-state (if (= y-d 1) [(- y-inc) y-next-rd (+ 2 y-next-rd)] [y-inc (dec y-d) y-next-rd])\n                                 next-point [(+ x x-inc) (+ y y-inc)]]\n                             (cons {:x x :y y :ch ch} (p-fn next-point x-state y-state chs)))))]\n                 (p-fn [0 0] [1 1 3] [-1 2 4] chars))\n          pad (fn [coll]\n                (map (fn [s]\n                       (let [p (apply str (repeat (int (/ (- (count coll) (count s)) 2)) \" \"))]\n                         (str p s p))) coll))]\n\n      (vec (pad (map #(clojure.string/join \" \" (map :ch (sort-by :x < %)))\n                     (vals (sort-by first > (group-by :y data)))))))))","user":"53b530c6e4b047364c0444bc"},{"code":"(fn [start end]\n  (let [squares (map #(* % %) (drop 1 (range)))\n        directions [:dr :dl :ul :ul :ur :ur :dr :dr :dr :dl :dl :dl :ul :ul :ul]]\n    (letfn [(square-seq [start end]\n              (take-while #(<= % end) (iterate #(* % %) start)))\n            (digits [s]\n              (apply str (map str s)))\n            (nearest-square [n]\n              (first (drop-while #(< % n) squares)))\n            (pad-digits [s]\n              (let [l (count s)\n                    s (concat s (repeat \"*\"))]\n                (take (nearest-square l) s)))\n            (padded-square-seq [s e]\n              (-> (square-seq s e)\n                  digits\n                  pad-digits))\n            (move [pos dir]\n              (let [[x y] pos]\n                (case dir\n                  :dr [(inc x) (inc y)]\n                  :dl [(dec x) (inc y)]\n                  :ur [(inc x) (dec y)]\n                  :ul [(dec x) (dec y)])))\n            (positions [start-pos]\n              (reductions move start-pos directions))\n            (position-chars [start-pos s]\n              (zipmap (positions start-pos) s))\n            (side-length [n-digits]\n              (-> n-digits (Math/sqrt) (* 2) (- 1) int))\n            (centered-range [n]\n              (range (-> n (/ 2) Math/floor - int)\n                     (-> n (/ 2) Math/ceil int)))]\n      (let [s (padded-square-seq start end)\n            start-pos (if (odd? (count s)) [0 0] [0 -1])\n            chars (position-chars start-pos s)\n            length (side-length (count s))\n            display-range (centered-range length)]\n        (for [y display-range]\n          (apply str (for [x display-range]\n                       (get chars [x y] \\space))))))))","problem":138,"user":"4e80aa10535db62dc21a62b1"},{"code":"(fn [s e]\n  (let [\n    square? (fn [i] (= (->> (range)\n                         (drop-while #(< (* % %) i))\n                         (first)\n                         (#(* % %)))\n                       i))\n    ceil-square (fn [i] (->> (iterate inc i)\n                          (drop-while (comp not square?))\n                          (first)))\n    cs (->> (iterate #(* % %) s)\n         (take-while #(< % (inc e)))\n         (apply str)\n         (#(take (ceil-square (count %))\n                 (concat % (repeat \\*)))))\n    dxdys (mapcat\n            #(cond (zero? %) []\n                   (odd? %) (concat [[ 1  1]]\n                                    (repeat % [-1  1])\n                                    (repeat % [-1 -1]))\n                   :else    (concat [[-1 -1]]\n                                    (repeat % [ 1 -1])\n                                    (repeat % [ 1  1])))\n            (range))\n    xys ((fn f [[x y :as p] [[dx dy :as h] & r]]\n           (if (nil? h) ()\n               (lazy-seq (cons p (f [(+ x dx) (+ y dy)] r)))))\n         [0 0]\n         dxdys)\n    minxy #(vector (apply min (map first %))\n                   (apply min (map second %)))\n    sub (fn [[dx dy] ps]\n          (map (fn [[x y]] [(- x dx) (- y dy)]) ps))\n    xys- (take (count cs) xys)\n    xys+ (sub (minxy xys-) xys-)\n    cxys (into {} (map vector xys+ cs))\n    ]\n    (map #(apply str %)\n      (for [y (range 0 (inc (apply max (map second xys+))))]\n        (for [x (range 0 (inc (apply max (map first xys+))))]\n          (if-let [c (cxys [x y])] c \\space))))))","problem":138,"user":"4fd96694e4b05e33b9224f37"},{"problem":138,"code":"(fn [b e]\n  (let [s (apply str (take-while #(<= % e) (iterate #(* % %) b)))\n        [ld l] (drop-while #(< (* (inc %) (inc %)) (count s)) (range))\n        xs (->> (map list (#(interleave % %) (rest (range))) \n                          (cycle [[1 1] [1 -1] [-1 -1] [-1 1]]))\n                (mapcat (fn [[ll d]] (take ll (repeat d))))\n                (reductions #(map + % %2) [(- ld (mod ld 2)) ld])\n                (take (* l l)))\n        m (into {} (map vector xs (concat s (repeat \"*\"))))\n        r (range (+ l ld))]\n    (vec (for [y r] (apply str (for [x r] (get m [y x] \" \")))))))","user":"575ddfd1e4b02ea11479938d"},{"code":"(fn [x y]\n  (letfn [(ni [z] \n            (fn [[y x]]\n    (if (even? z)\n\n      (cond\n       (and (>= x z) (<= y z)) [(inc y) (inc x)]\n       (and (> x z) (> y z)) [(inc y) (dec x)]\n       (and (<= x z) (> y z)) [(dec y) (dec x)]\n       :else [(dec y) (inc x)])\n\n      (cond\n       (and (>= x z) (< y z)) [(inc y) (inc x)]\n       (and (> x z) (>= y z)) [(inc y) (dec x)]\n       (and (<= x z) (>= y z)) [(dec y) (dec x)]\n       :else [(dec y) (inc x)]))))]\n  (let [q (apply str (take-while #(<= % y) (iterate #(* % %) x)))\n        b (int (Math/floor (Math/sqrt (dec (count q)))))\n        n (ni b)\n        s (if (odd? b) [(dec b) b] [b b])\n        i (take (* (inc b) (inc b)) (iterate n s))\n        \n        t (inc (* 2 b))\n        r (->> (repeat t \\space)\n                  vec\n                  (repeat t)\n                  vec)\n\n        c (map vector (concat q (cycle \"*\")) i)]\n\n    (->> (reduce (fn [r [n p]] (assoc-in r p n))\n                 r\n                 c)\n         (map #(apply str %))))))","problem":138,"user":"4e823ed7535db62dc21a62c7"},{"code":"(fn rhombus-squares[s e]\n  (let [\n    squares (take-while #(<= % e) (iterate #(* % %) s))\n    digits (mapcat (comp seq str) squares)\n    length (first (drop-while #(< % (count digits)) (map #(* % %) (range))))\n    padded (concat digits (repeat (- length (count digits)) \\*))\n    width (Math/sqrt length)\n    cycles (map #(take (inc (* 2 %)) (drop (* % %) padded)) (range width))\n    rows (reduce\n      (fn [rows cycle]\n        (let [top? (zero? (mod (/ (dec (count cycle)) 2) 2))\n              transpose (comp reverse (partial map reverse))\n              height (/ (inc (count cycle)) 2)\n              pad (repeat (+ 2 (- (count rows) height)) [])\n              add-cycle (fn [rows]\n                (map (comp concat flatten vector)\n                  (concat (reverse (take height cycle)) pad)\n                  (concat [[] []] rows)\n                  (concat [[]] (drop height cycle) pad)))]\n          (if top?\n            (add-cycle rows)\n            (transpose (add-cycle (transpose rows))))))\n        [(first cycles)] (rest cycles))\n    strings (map #(apply str (interpose \" \" %)) rows)\n    padstrings (map #(let [pad (apply str (repeat (/ (- (dec (* 2 width)) (count %)) 2) \" \"))] (str pad % pad)) strings)\n  ] padstrings))","problem":138,"user":"50e4f4e9e4b049a987753896"},{"problem":138,"code":"(let [d [[0 1] [1 0] [0 -1] [-1 0]]\n      e (for [i (range)]\n          (quot (+ i 2) 2))\n      F (for [[d a] (map vector (cycle d) e)\n              i (range a)]\n          d)]\n  (letfn [(P\n            [[a b] [c d]]\n            [(+ a c) (+ b d)])\n          (S\n            [v]\n            (loop [p [0 0]\n                   m {}\n                   [v & V] v\n                   [d & D] F]\n              (if v\n                (recur (P p d)\n                  (assoc m p v)\n                  V\n                  D)\n                m)))\n          (G\n            [m d]\n            (let [k (keys m)\n                  x (map first k)\n                  y (map second k)\n                  X (apply max x)\n                  x (apply min x)\n                  Y (apply max y)\n                  y (apply min y)\n                  N (+ 1 (max (- X x) (- Y y)))]\n              (reduce (fn [g [[a b] v]]\n                        (assoc-in g [(- a x) (- b y)] v))\n                (vec (repeat N\n                       (vec (repeat N\n                              d))))\n                m)))\n          (D\n            [g]\n            (into {} (for [i (range (count g))\n                           j (range (count (g 0)))]\n                       [[(+ i j) (- j i)] ((g i) j)])))\n          (Q\n            [n N]\n            (->> n\n              (iterate #(* % %))\n              (take-while #(<= % N))\n              (apply str)))]\n    (fn [n N]\n      (-> (->> n\n            (iterate #(* % %))\n            (take-while #(<= % N))\n            (apply str))\n        S\n        (G \\*)\n        D\n        (G \\ )\n        (->> (mapv (partial apply str)))))))","user":"50a83315e4b054305ba5a830"},{"code":"(fn [start end]\n\n    (let [[fch & istring] (apply str (take-while #(<= % end)\n                                         (iterate #(* % %) start)))\n          vcycle (cycle [[1 1] [1 -1] [-1 -1] [-1 1]])\n\n          spiral (fn  [p  [f & [s & _ :as r] :as fr] mp [sf & sr]]\n                    (let [fp (map + f p)  sp (map + s p) st (if sf sf \"*\")]\n                      (cond\n                       (and (nil? sf) (some #{(count mp)} [1 4 9 16])) mp\n                       (nil? (mp sp)) (recur  sp  r (assoc mp sp st) sr)\n                       :else (recur fp  fr (assoc mp fp st) sr ))))\n          grid (fn [mp]\n                  (let [r (keys mp) x (map first r)\n                        y (map second r) xmx (inc (apply max x))\n                        xmn (apply min x) ymx (inc (apply max y))\n                        ymn (apply min y)]\n                    (map (fn [x] (apply str  (map (fn [y]\n                                   (if (mp (list y x))\n                                     (mp (list y x)) \" \")) (range xmn xmx))))\n                         (range ymn ymx))))]\n      (-> (spiral '(0,0) vcycle {'(0,0) fch} istring) grid reverse)))","problem":138,"user":"5124619ae4b02c3f2a072ccd"},{"code":"(fn [s f]\n   (let [self-sq-seq (fn [a b]\n                       ((fn f [x]\n                          (let [p (* x x)]\n                            (cons x (when (<= p b) (lazy-seq (f p)))))) a))\n         sq-seq (fn [a b]\n                  ((fn f [x] (let [p (* x x)] (cons [x p] (when (< p b) (lazy-seq (f (inc x))))))) a))\n         grid (fn [n] (let [t (dec (* 2 n))] (vec (repeat t (vec (repeat t \\space))))))\n         center (fn [n] (let [m (dec n)] (vec [(if (even? n) (dec m) m) m])))\n         sq (mapcat str (self-sq-seq s f))\n         [base len] (last (sq-seq 1 (count sq)))\n         path (take (dec len)\n                ((fn p [a b c i]\n                   (concat [a] (repeat i b) (repeat i c) (lazy-seq (p c (reverse b) a (inc i)))))\n                  [1 1] [1 -1] [-1 -1] 1))\n         go (fn go [x g v p]\n              (if (not-empty x) (go (rest x) (assoc-in g v (first x)) (map + v (first p)) (rest p)) g))]\n     (map #(apply str %) (go (take len (concat sq (repeat \\*))) (grid base) (center base) path))))","problem":138,"user":"51f66e0ee4b06ff1c25c52c3"},{"problem":138,"code":"(fn squaresq [x y]                                                                                                                                                                                           \n  (letfn [(as-digits [num]\n            (map #(Character/getNumericValue %) (str num)))\n          (posSeq\n            ([n] (posSeq n (mapcat #(list % %) (range 1 n)) []))\n            ([n lst acc]\n             (cond\n              (= n 1) [1]\n              (= n (apply + acc)) acc\n              :else (recur n (rest lst) (conj acc (first lst))))))\n          (firstSq [n]\n            (first (filter #(<= n (* % %)) (range))))\n          (genOne [n pos dir]\n            (letfn [(nxt [p]  (mapv + p dir))]\n              (take n (iterate nxt (nxt pos)))))\n          (normalize [v]\n            (let [offX (* -1 (apply min (map first v)))\n                  offY (* -1 (apply min (map second v)))]\n              (map #(vec (map + %1 %2)) v (repeat [offX offY]))))\n          (generatePos\n            ([n] (generatePos (posSeq n)\n                              (cycle  [[1 1] [1 -1] [-1 -1] [-1 1]])\n                              [[0 0]]))\n            ([lst dir acc]\n             (if (empty? lst)\n               (normalize (butlast acc))\n               (recur (rest lst)\n                      (rest dir)\n                      (vec (concat acc (genOne (first lst) (last acc) (first dir))))))))\n          (pad [n coll val]\n            (take n (concat coll (repeat val))))\n          (digits\n            ([x y] (digits x y []))\n            ([x y acc]\n             (if (> x y)\n               acc\n               (recur (* x x)\n                      y\n                      (concat acc (as-digits x))))))\n          (padWith [xs]\n            (let [c (firstSq (count xs))\n                  c2 (* c c)]\n              (pad c2 xs '*)))\n          (digitSet [x y]\n            (let [d (digits x y)]\n              (padWith d)))\n          (fillSquare [n m]\n            (let [mat\n                  (for [x (range n)\n                        y (range n)]\n                    (get m [x y] \" \"))]\n              (map #(apply str %)\n                   (partition n mat))))]\n    (let [d (digitSet x y)\n          p (generatePos (count d))\n          n (int (Math/pow (count d) 0.5))\n          l (+ n (dec n))]\n      (fillSquare l (zipmap p d)))))","user":"54f64e99e4b0f2f3c5226ea4"},{"problem":138,"code":"(fn square-squares [start end]\n  (let [powers (take-while #(>= end %) (iterate #(* % %) start))\n        explode-number-to-digits (fn [number] (map #(Character/digit % 10) (str number)))\n        powers-digits (mapcat explode-number-to-digits powers)\n        total-number-of-chars (first (drop-while #(> (count powers-digits) %) (map #(* % %) (iterate inc 1))))\n        powers-filled-with-* (concat (apply str powers-digits) (repeat (- total-number-of-chars (count powers-digits)) \"*\"))\n        range-inc (fn [from to] (range from to 1))\n        range-dec (fn [from to] (range from to -1))\n        string-length (inc (* 2 (dec (int (Math/sqrt (count powers-filled-with-*))))))\n        rotated-seq (take (count powers-filled-with-*) (let [range-func-map {range-inc range-dec range-dec range-inc}]\n                                                         (loop [range-func range-inc\n                                                                result []\n                                                                start 1\n                                                                end 3\n                                                                step 4\n                                                                plusminus -1]\n                                                           (if (> (count result) (count powers-filled-with-*))\n                                                             result\n                                                             (recur (range-func-map range-func) (concat result (range-func start end)) end (+ (* step plusminus) end) (+ 2 step) (* -1 plusminus))))))\n        get-next-min (fn [coll current-min] (let [filtered-coll (filter #(> % current-min) coll)]\n                                              (when (not-empty filtered-coll)\n                                                (apply min filtered-coll))))\n        create-result-string (fn [indexes powers for-val] (let [filtered (apply str (map #(when (= %1 for-val) %2) indexes powers))\n                                                                 rights (take-nth 2 filtered)\n                                                                 lefts (take-nth 2 (rest filtered))]\n                                                            (clojure.string/join \" \" (if (pos? for-val)\n                                                                         (concat (reverse lefts) rights)\n                                                                         (concat rights (reverse lefts))))))\n        draw-diamond (loop [current-min (apply min rotated-seq)\n                            result-strings []]\n                       (if (nil? current-min)\n                         result-strings\n                         (recur (get-next-min rotated-seq current-min) (conj result-strings (create-result-string rotated-seq powers-filled-with-* current-min)))))\n        fill-element-with-spaces (fn [element] (let [missing-strings-lenght (- string-length (count element))\n                                                     missing-strings (repeat (/ missing-strings-lenght 2) \" \")]\n                                                 (apply str (concat missing-strings element missing-strings))))\n        fill-diamond-with-spaces (map fill-element-with-spaces draw-diamond)]\n    fill-diamond-with-spaces))","user":"509a25b7e4b0efbae1fbc0a8"},{"problem":138,"code":"(fn [x y]\n   (let [nums (loop [acc [] e x]\n                (if (> e y)\n                  acc\n                  (recur (conj acc e) (* e e))))\n         strnum (apply str (re-seq #\"\\d+\" (str nums)))\n         numwidth (inc (int (Math/sqrt (dec (count strnum)))))\n         boardwidth (dec (* 2 numwidth))\n         numlen (#(* % %) numwidth)\n         pathcount (take boardwidth ((fn ![r] (lazy-seq (cons (first r)\n                                                              (cons (first r)\n                                                                    (! (rest r))))))\n                                     (rest (range))))\n         ccs (cycle [[1 1] [-1 1] [-1 -1] [1 -1]])\n         cs (apply str strnum (repeat (- numlen (count strnum)) \"*\"))\n         path (loop [cc ccs\n                     p pathcount\n                     acc []]\n                (if (empty? p) acc\n                    (recur (rest cc)\n                           (rest p)\n                           (concat acc (repeat (first p) (first cc)))))\n                )\n         init-point [(int (/ boardwidth 2))\n                     (* (int (/ (int (/ boardwidth 2)) 2)) 2)]\n         go (fn [point path]\n              [(+ (first point) (first path)) (+ (last point) (last path))])\n         points (reduce (fn [acc e] (conj acc (go (last acc) e))) [init-point] path)\n         ;; y: {x: val}\n         points-table (reduce (fn [acc e] (assoc acc (second (first e))\n                                (assoc (acc (second (first e)) {})\n                                       (ffirst e)\n                                       (second e)))) {} (into {} (map hash-map points cs)))\n         buildline (fn [pts](reduce #(apply str (concat % (str (pts %2 \" \")))) \"\"\n                                    (range boardwidth)))]\n     (reduce #(conj % (buildline (points-table %2))) [] (range boardwidth))\n      ))","user":"56f7ecdfe4b08e7d20b96834"},{"code":"(fn s [a b]\r\n  (letfn [(set-pos [m [x y] v] (assoc m y (-> m (nth y) (assoc x v))))\r\n          (spiral-pos [n init]\r\n            (let [j (-> n Math/sqrt Math/round)\r\n                  k (-> j (* j) (- n) (Math/abs) (- j))\r\n                  f #(-> % (+ (* j j)) (- n) (- (rem j 2)) (* 0.5) (* (Math/pow -1 j)) (+ init) int)]\r\n              (map f [k (- k)])))\r\n          (spiral [s m init]\r\n            (loop [[x & xs] s\r\n                   [p & ps] (map #(spiral-pos % init) (range))\r\n                   m m]\r\n              (if x (recur xs ps (set-pos m p x)) m)))\r\n          (center [s size]\r\n            (let [c (count s)\r\n                  n (-> size (- c) (* 0.5))\r\n                  sp (apply str (repeat n \" \"))]\r\n              (str sp s sp)))\r\n          (rot-45 [m]\r\n            (let [c  (count m)\r\n                  ndigs (+ c c)\r\n                  diag  (fn [n]\r\n                          (let [f (fn [[y x]] [(dec y) (inc x)])\r\n                                x (if (> n c) (- n c) 0)\r\n                                y (if (>= n c) (dec c) n)]\r\n                            (take-while identity\r\n                                        (map #(get-in m %) \r\n                                              (iterate f [y x])))))\r\n                  diags (distinct (map #(diag %) (range ndigs)))\r\n                  line  (fn [s]\r\n                          (center (apply str (interpose \" \" s)) (dec ndigs)))]\r\n              (map line (distinct diags))))]\r\n    (let [sq #(* % %)\r\n          nums (apply str (take-while #(<= % b) (iterate sq a)))\r\n          c (count nums)\r\n          size (int (Math/sqrt (first (drop-while #(< % c) (map sq (range))))))\r\n          nums (concat nums (repeat (- (sq size) c) \\*))\r\n          pos (int (dec (Math/ceil (* size 0.5))))\r\n          m (vec (repeat size (vec (repeat size \" \"))))]\r\n      (rot-45 (spiral nums m pos))\r\n    )\r\n  )\r\n)","problem":138,"user":"4f58d92fe4b0a7574ea71858"},{"problem":138,"code":"(fn __ [na nb]\n(letfn [(pows [a b acc] \n       \t      (if (>= a b) (if (> a b) (butlast acc) acc) \n    \t      (pows (* a a) b (conj acc (* a a)))))\n\t (wrap [[x y]]\n\t       (if (and (= x 0) (= y 0)) [0 1] \n\t       \t   (cond (and (> y 0) (>= x 0)) [(inc x) (dec y)]\n\t\t   \t (and (<= y 0) (> x 0)) [(dec x) (dec y)]\n\t\t\t (and (< y 0) (<= x 0)) [(dec x) (inc y)]\n\t\t\t (and (>= y 0) (< x 0))\n\t\t\t      (if (= y 0) [(dec x) (inc y)] [(inc x) (inc y)]))))\n\t(aprep [mat [fstw [x y]] info]\n\t (let [nx (- x (:minx info)) \n\t       ny (- y (:miny info))\n\t       aadr (+ nx (* ny (:dimy info)))]\n\t   (assoc mat aadr fstw)))\n\t(appear [d sps]\n\t\t(reduce #(aprep %1 %2 d) \n\t\t\tsps (partition 2 (interleave (:fstr d) (:ords d)))))]\n (let [digs (rest (clojure.string/split (apply str (pows na nb [na])) #\"\"))\n       tsl  (int (Math/pow (Math/ceil (Math/sqrt (count digs))) 2))\n       fstr (concat digs (take (- tsl (count digs)) (repeat \"*\")))\n       ords (rest (take (inc (count fstr)) (iterate wrap [0 0])))\n       minx (apply min (map #(first %) ords))\n       miny (apply min (map #(second %) ords))\n       maxx (apply max (map #(first %) ords))\n       maxy (apply max (map #(second %) ords))\n       dimx (inc (- maxx minx))\n       dimy (inc (- maxy miny))]\n       (if (= (count fstr) 1) \n       \t   fstr\n\t   (->> (into [] (take (* dimx dimy) (repeat \" \")))\n\t   \t(appear {:fstr fstr :ords ords :minx minx :miny miny :dimy dimy})\n\t\t(partition dimx)\n\t\treverse\n\t\t(map #(apply str %)))))))","user":"52747090e4b03e8d9a4a74a5"},{"problem":138,"code":"(fn squares_squared [start end]\n    (let\n        [\n            digits\n                (fn f [val]\n                    (loop [curr val ret '()]\n                        (let\n                            [\n                                next_digit (mod curr 10)\n                                curr (quot curr 10)\n                                ret (cons next_digit ret)\n                            ]\n                            (if (zero? curr)\n                                ret\n                                (recur curr ret)\n                            )\n                        )\n                    )\n                )\n            gather_squares\n                (fn f [start end]\n                    (loop [curr start agg []]\n                        (if (<= curr end)\n                            (recur (* curr curr) (conj agg curr))\n                            agg\n                        )\n                    )\n                )\n            generate_2D_vector\n                (fn f [rows cols placeholder]\n                    (vec (take rows (repeat (vec (take cols (repeat placeholder))))))\n                )\n            generate_spiral\n                (fn f [input_sequence placeholder sequence_filler]\n                    (let\n                        [\n                            inner_square_size (-> (count input_sequence) (Math/sqrt) (Math/ceil) (int))\n                            outer_square_size (dec (* 2 inner_square_size))\n                            [nrows ncols] [outer_square_size outer_square_size]\n                            matrix (generate_2D_vector nrows ncols placeholder)\n                            inbounds?\n                                (fn f [r c] (every? true? [(>= r 0) (>= c 0) (< r nrows) (< c ncols)]))\n                            input_sequence (concat input_sequence (take (- (* inner_square_size inner_square_size) (count input_sequence)) (repeat sequence_filler)))\n                            midpoint (-> outer_square_size (/ 2) (Math/floor) (int))\n                            [initial_row initial_col]\n                                (if (even? inner_square_size)\n                                    [(dec midpoint) midpoint]\n                                    [midpoint midpoint]\n                                )\n                            dirs ['(1 1) '(1 -1) '(-1 -1) '(-1 1)]\n                            initial_dir_index 3\n                        ]\n                        (loop [ rc [initial_row initial_col]\n                                curr_dir_index initial_dir_index\n                                curr_dir (get dirs curr_dir_index) \n                                input_sequence input_sequence\n                                ret_matrix matrix]\n                            (let\n                                [\n                                    next_val (first input_sequence)\n                                    ret_matrix (assoc-in ret_matrix rc next_val)\n                                    [next_row next_col] (map #(apply + %) (map list curr_dir rc))\n                                    shift_dir_index (mod (inc curr_dir_index) (count dirs))\n                                    shift_dir (get dirs shift_dir_index)\n                                    [alternate_row alternate_col] (map #(apply + %) (map list shift_dir rc))\n                                ]\n                                (cond\n                                    (or (= 1 (count input_sequence)) (empty? input_sequence))\n                                        ret_matrix\n                                    (and (inbounds? alternate_row alternate_col) (= (get-in ret_matrix [alternate_row alternate_col] placeholder) placeholder))\n                                        (recur [alternate_row alternate_col] shift_dir_index shift_dir (rest input_sequence) ret_matrix)\n                                    (and (inbounds? next_row next_col) (= (get-in ret_matrix [next_row next_col] placeholder) placeholder))\n                                        (recur [next_row next_col] curr_dir_index curr_dir (rest input_sequence) ret_matrix)\n                                    :otherwise ret_matrix\n                                )\n                            )\n                        )\n                    )\n                )\n            gathered_squares (gather_squares start end)\n            digit_sequence (apply concat (map digits (gather_squares start end)))\n            generated_spiral (generate_spiral digit_sequence \\  \\*)\n            spiral_as_string (map #(clojure.string/join \"\" %) generated_spiral)\n\n        ]\n        spiral_as_string\n    )\n)","user":"5db7376fe4b010eb3c36cd43"},{"code":"(fn rotate [a b] \n  (let [nums (fn [a b] (take-while #(<= % b)  (iterate #(* % %) a))) \n\t\tto-digits (fn [p] (into () (map #(mod (quot p %) 10) (take-while #(< 0 (quot p %)) (iterate #(* 10 %) 1) ))))\n\t\tall-digits (fn [a b] (mapcat to-digits (nums a b)))\n\t\tpad (fn [a b] (let [t (all-digits a b)  \n\t\t                    c (count t )  \n\t\t\t\t\t\t\ts (int (Math/sqrt c))  \n\t\t\t\t\t\t\tlen (condp = (* s s) c s (inc s)) \n\t\t\t\t\t\t\tpadding (- (* len len) c)] \n\t\t\t\t\t\t(concat t (repeat padding \\*))))\n        \n\t\tpairs (fn [] (mapcat #(vector % %)(iterate inc 1)))\n\t\tdirections (fn []  (cycle [ :a :b :c :d]))\t\n\t\tdirections* (fn [] (mapcat #(repeat (first %) (second %)) (map vector (pairs) (directions))))\n\t\tsteps (fn [] (cons [0 0] (map #({:a [1 1] :b [1 -1] :c [-1 -1] :d [-1 1]} %) (directions*))))\n\t\tpositions (fn [a b]  (let [path (pad a b) \n\t\t                           steps (map #(into [%2] %1) (steps) path)]\n\t\t\t                   (reductions (fn [[acc1 acc2 acc3] [e1 e2 e3]] [e1 (+ acc2 e2 ) (+ acc3 e3 ) ]) \n\t\t\t\t\t\t\t               (first steps) \n\t\t\t\t\t\t\t\t\t\t   (next steps))))\n\t\talign (fn [a b] (let [p (positions a b) \n\t\t                      mt (apply min (map second p)) \n\t\t\t\t\t\t\t  ml (apply min (map #(second (next %)) p)) ]\n\t\t\t             (map (fn [[x i j]] (vector x (- i mt) (- j ml)) ) p)))\t \n\t\tstretch (fn [vector* size pad] (if (> (inc size) (count vector*)) (into vector* (repeat (- (inc size) (count vector*)) pad)) vector*))\t\t \n\t\tasc-in (fn [v val [k1 k2]]  (let [v* (stretch v k1 []) \n\t\t                                  row (stretch (v* k1) k2 \\space) \n\t\t\t\t\t\t\t\t\t\t  v** (assoc v* k1 row)] \n\t\t\t\t\t\t\t\t    (assoc-in v** [k1 k2] val)))\t\t\n\t\ts (align a b)\n        v (reduce (fn [acc [c i j]] (asc-in acc c [i j]))  []  s)\n\t\tm (dec (apply max (map count v)))\n\t\tp (map #(stretch % m \\space) v)] \n\t\t  (map #(apply str %) p)))","problem":138,"user":"523a9fc9e4b081681ca7adca"},{"code":"(fn prob-0138\n  [start end]\n        \n  (letfn [(add-vv\n            [v1 v2]\n            (vec (map #(+ %1 %2) v1 v2)))\n\n          (sq-sq-num-seq\n            [start end]\n            (flatten (map #(seq (str %)) (take-while #(<= % end) (iterate #(* % %) start)))))\n\n          (sq-sq-size-seq\n            []\n            (reductions #(* %2 %2) (range 1 Double/POSITIVE_INFINITY)))\n\n          (sq-sq-num-star-seq\n            [start end]\n            (let [ssn-seq  (sq-sq-num-seq start end)\n                  seq-size (first (drop-while #(< % (count ssn-seq)) (sq-sq-size-seq)))\n                  star-cnt (- seq-size (count ssn-seq))]\n              (concat ssn-seq (replicate star-cnt \\*))))\n\n          (sq-sq-dirs\n            []\n            (cycle [[+1 +1] [+1 -1] [-1 -1] [-1 +1]]))\n\n          (offset-to-positive\n            [sq]\n            (let [min-row (apply min (map #(first  %) sq))\n                  min-col (apply min (map #(second %) sq))]\n              (map #(add-vv % [(- min-row) (- min-col)]) sq)))\n\n          (turn-right\n            [dir]\n            (cond\n             (= [+1 +1] dir) [+1 -1]\n             (= [+1 -1] dir) [-1 -1]\n             (= [-1 -1] dir) [-1 +1]\n             :else           [+1 +1]))\n\n          (diamond-layout\n            ([todo]\n               (if (<= todo 0)\n                 []\n                 (diamond-layout (dec todo) [[0 0]] 1 [+1 +1] [+1 -1])))\n            ([todo oseq side-size pos1 dir1]\n               (if (<= todo 0)\n                 (offset-to-positive oseq)\n                 (let [seq1 (take      side-size (iterate #(add-vv dir1 %) pos1))\n                       pos2 (add-vv (last seq1) dir1)\n                       dir2 (turn-right dir1)\n             \n                       seq2 (take (inc side-size) (iterate #(add-vv dir2 %) pos2))\n                       pos3 (add-vv (last seq2) dir2)\n                       dir3 (turn-right dir2)]\n                   (recur\n                    (- todo (count seq1) (count seq2))\n                    (concat oseq seq1 seq2)\n                    (inc side-size)\n                    pos3\n                    dir3)))))\n\n          (assoc-in-poss-vals\n            [mat pos-sq val-sq]\n            (if (or (empty? pos-sq) (empty? val-sq))\n              mat\n              (recur (assoc-in mat (first pos-sq) (first val-sq)) (rest pos-sq) (rest val-sq))))\n          ]\n    \n    (let [values   (sq-sq-num-star-seq start end)\n          layout   (diamond-layout (count values))\n          mat-rows (inc (apply max (map #(first  %) layout)))\n          mat-cols (inc (apply max (map #(second %) layout)))\n          mat-strs (vec (replicate mat-rows (vec (replicate mat-cols \\space))))\n          ans-seq  (assoc-in-poss-vals mat-strs layout values)]\n      (map #(apply str %) ans-seq))))","problem":138,"user":"4f047c07535dcb61093f6bcd"},{"problem":138,"code":"(fn [a b]\n   (let [sq #(long (Math/pow % 2))\n         ; display\n         even-ss (fn [coll]\n                  (let [n (count coll)\n                        new (range (sq n) (sq (inc n)))]\n                    (concat\n                      (for [i (range n)]\n                        (concat (nth coll i) (list (nth new i))))\n                      (list (reverse (drop n new))))))\n\n         odd-ss (fn [coll]\n                   (let [n (count coll)\n                         new (range (sq n) (sq (inc n)))]\n                     (concat\n                       (list (drop n new))\n                       (for [i (range n)]\n                         (concat (list (nth new (- n (inc i)))) (nth coll i))))))\n\n         ss (fn _ss [n]\n              (cond\n                (= n 1) '((0))\n                (odd? n) (odd-ss (_ss (dec n)))\n                (even? n) (even-ss (_ss (dec n)))\n                :else nil))\n\n         rotate-45 (fn [coll]\n                     (let [n (count coll)]\n                       (concat\n                         ; upper part\n                         (for [i (range n)]\n                           (for [j (range (inc i))]\n                             (nth (nth coll (- i j)) j)))\n                         ; lower part\n                         (for [i (range 1 n)]\n                           (for [j (range i n)\n                                 :let [_i (+ i (- (dec n) j))]]\n                             (nth (nth coll _i) j))))))\n\n         fetch-seq (fn [coll indexes]\n                     (for [lines indexes]\n                       (for [i lines]\n                         (coll i))))\n\n         expand (fn [n coll]\n                  (let [size (- (* 2 n) 1)]\n                    (for [line coll]\n                      (let [l (clojure.string/join \" \" line)\n                            pad (apply str (take (quot (- size (count l)) 2) (cycle \" \")))]\n                        (str pad l pad))\n                      )))\n\n         ; calc\n         s-seq (fn [a b]\n                 (loop [ret (vector a)\n                        nx  (sq a)]\n                   (if (>= b nx)\n                     (recur (conj ret nx) (sq nx))\n                     ret)))\n\n         pad-* (fn [v]\n                 (let [se  (seq (apply str v))\n                       cnt (count se)\n                       len (first (drop-while #(< % cnt) (map sq (range))))]\n                   (vec (take len (concat se (repeat \\*))))))\n\n         target (pad-* (s-seq a b))\n         size (int (Math/sqrt (count target)))]\n\n     (->> (ss size)\n          (rotate-45)\n          (fetch-seq target)\n          (expand size))))","user":"55a372f1e4b0acc240e31537"},{"problem":138,"code":"(fn [s e]\n  (let [nums (mapcat str (for [x (iterate #(* % %) s) :while (<= x e)] x))\n        [siz sqr] (first (drop-while #(> (.size nums) (get % 1)) (map #(identity [% (* % %)]) (range))))\n        rst (- sqr (.size nums))\n        all (concat nums (repeat rst \\*))\n        sq-siz (dec (* siz 2))\n        delta-seq (mapcat #(repeat %2 ([[1 1] [-1 1] [-1 -1] [1 -1]] (mod %1 4))) (range) (mapcat #(repeat 2 %) (next (range))))\n        start-pos (vector (dec siz) (bit-clear (dec siz) 0))\n        positions (take (.size all) (reductions #(map + %1 %2) start-pos delta-seq))\n        position-list (map #(vector %1 %2) all positions)\n        find (fn [a sq] (first (first (filter #(= a (% 1)) sq))))\n        grid (apply vector (for [y (range sq-siz)] (apply str (for [x (range sq-siz)] (let [p [x y] e (find p position-list)] (str (if e e \" \")))))))\n        ]\n               \n    grid))","user":"55b0f5bfe4b002ce9d5cbc28"},{"code":"(fn n138 [k l]\n  (letfn [(gen-ch [x y start l]\n                  (let [[r _] start d (dec l) c (/ d 2)]\n                    (cond\n                      (and (<= 0 x) (< x (inc r)) (<= c y) (< y d)) [1 1]\n                      (and (<= (inc r) x) (< x d) (< c y) (<= y d)) [1 -1]\n                      (and (< r x) (<= x d) (< 0 y) (<= y c)) [-1 -1]\n                      (and (< 0 x) (<= x r) (<= 0 y) (< y c)) [-1 1])))\n          (ch-coordinate [cood start r] (map + cood (gen-ch (first cood) (second cood) start r)))\n          ]\n    (let [s (vec (apply str (take-while (partial >= l) (iterate #(* % %) k))))\n          c (count s)\n          o (int (java.lang.Math/ceil (java.lang.Math/sqrt c)))\n          r (dec (* 2 o))\n          start [(* 2 (int (java.lang.Math/floor (/ (dec o) 2)))) (dec o)]\n          s-star (into s (repeat (- (* o o) (count s)) \\*))\n          board (vec (repeat r (vec (repeat r \\space))))\n          ]\n      ;(ch-coordinate start start r)\n      ;(take r (iterate #(ch-coordinate % start r) start))\n      (map #(apply str %) (loop [coll s-star b board curr start]\n                           (if (empty? coll)\n                             b\n                             (recur (rest coll) (assoc-in b curr (first coll)) (ch-coordinate curr start r)))))\n      )))","problem":138,"user":"52b43468e4b0c58976d9ad1b"},{"problem":138,"code":"(fn ss [start end]\n  (letfn [\n          (squares [start end]\n            (take-while (partial >= end) (iterate #(* %1 %1) start)))\n          (charseq [start end]\n            (apply concat (map str (squares start end))))\n          (square-size [charcount]\n            (int (Math/ceil (Math/sqrt charcount))))\n          (output [s_size values]\n            (let [rcsize (dec (* s_size 2))]\n              (vec (for [y (range 0 rcsize)]\n                     (apply str (map #(get values [% y] \\space) (range 0 rcsize)))))))\n          (coord_map [charseq square-size]\n            (let [\n                  spiral_coords [[0 0]\n                                 [1 1] [0 2] [-1 1]\n                                 [-2 0] [-1 -1] [0 -2] [1 -1] [2 0]\n                                 [3 1] [2 2] [1 3] [0 4] [-1 3] [-2 2] [-3 1]]\n                  output_chars (take (* square-size square-size) (concat charseq (repeat \\*)))\n                  start_coord [(dec square-size) (* 2 (quot (dec square-size) 2))]\n                  output_coords (map #(map + %1 start_coord) spiral_coords)\n                  ]\n              (into {} (map vector output_coords output_chars))))\n          ]\n  (let [\n        cs (charseq start end)\n        squaresize (square-size (count cs))\n        ]\n    (output squaresize (coord_map cs squaresize))\n    )))","user":"55f2c898e4b06e875b46ce4b"},{"problem":138,"code":"(letfn\n[\n(is-square\n  [n]\n  (== (square-ge-than n) n))\n(square-ge-than\n  [n]\n  (let [sqrt-of-ge (->> n Math/sqrt Math/ceil)]\n    (* sqrt-of-ge sqrt-of-ge)))\n(ray-lengths\n  []\n  (mapcat (fn [x] [x x]) (range 1 Double/POSITIVE_INFINITY)))\n(cycle-by-lengths\n  [elems lengths]\n  (mapcat repeat (cycle lengths) (cycle elems)))        \n(draw-line\n  [board side y]\n  (apply str (map #(get board [%1 y] \" \") (range 0 side))))\n(draw-board\n  [board side]\n  (map (partial draw-line board side) (range 0 side)))\n(solve\n  [from to]\n  (let [digits (apply str (take-while #(<= % to)  (iterate #(* % %) from)))\n        cnt (count digits)\n        full-str (apply str digits (repeat (- (square-ge-than cnt) cnt) \"*\"))\n        side (dec (* 2 (int (Math/sqrt (count full-str)))))\n        startX (int (/ side 2))\n        startY (if (= 3 (rem side 4)) (dec (int (/ side 2))) (int (/ side 2)))\n        ]\n    (loop [board {[startX startY] (first digits)}\n           last-posX startX\n           last-posY startY\n           todo-chr (rest full-str)\n           todo-dir (cycle-by-lengths [:rd :ld :lu :ru] (ray-lengths))]\n        (if (empty? todo-chr) \n          [board side]\n          (let [\n            now-dir (first todo-dir)\n            now-posX (if (#{:ld :lu} now-dir) (dec last-posX) (inc last-posX))\n            now-posY (if (#{:ld :rd} now-dir) (inc last-posY) (dec last-posY))\n          ]\n            (do\n            (println now-dir)\n            (println now-posX)\n            (println now-posY)\n            (println (first todo-chr) \"asdf\")\n            (println)\n            (recur\n              (assoc board [now-posX now-posY] (first todo-chr))\n              now-posX\n              now-posY\n              (rest todo-chr)\n              (rest todo-dir))))))))\n]\n#(->> (solve %1 %2) (apply draw-board))\n)","user":"57717915e4b0979f896515b3"},{"problem":138,"code":"(fn make-grid [x1 x2]\n  (letfn [(square-length [ndigits] (->> ndigits Math/sqrt Math/ceil int))\n          (squares [x1 x2]\n            (if (> x1 x2)\n              nil\n              (cons x1 (squares (* x1 x1) x2))))\n          (squares-digits [x1 x2]\n            (->> (squares x1 x2)\n                 (mapcat str)))\n          (squares-digits-with-padding [x1 x2]\n            (let [ds (squares-digits x1 x2)\n                  dsp (- (* (square-length (count ds)) (square-length (count ds))) (count ds))]\n              (concat ds (repeat dsp \\*))))\n          (grid-length [ndigits] (->> ndigits square-length (* 2) dec))\n          (pad-sides [cols]\n            (->> (map #(concat [\\space] % [\\space]) cols)\n                 (map vec)))\n          (pad-top [cols]\n            (let [size (count (first cols))]\n              (->> (concat cols\n                           (repeat 2 (repeat size \\space)))\n                   (map vec))))\n          (top-tri [nums cols]\n            (let [[top bottom] (split-at (quot (count cols) 2) cols)\n                  top' (->> top\n                            (reverse)\n                            (pad-sides)\n                            (pad-top))\n                  top'' (loop [nums nums\n                               i 0\n                               j (- (count nums) i 1)\n                               acc []\n                               [c & cr] top']\n                          (let [start (get nums i)\n                                end (get nums j)]\n                            (if (> i j)\n                              acc\n                              (recur nums\n                                     (inc i)\n                                     (dec j)\n                                     (conj acc\n                                           (-> c\n                                               (assoc i start)\n                                               (assoc j end)))\n                                     cr))))\n                  top''' (reverse top'')\n                  bottom' (->> bottom\n                               (pad-sides))]\n              (concat top''' bottom')))\n          (bot-tri [nums cols]\n            (let [cols' (reverse cols)\n                  cols'' (map #(vec (reverse %)) cols')\n                  [top bottom] (split-at (quot (count cols) 2) cols'')\n                  top' (->> top\n                            (reverse)\n                            (pad-sides)\n                            (pad-top))\n                  top'' (loop [nums nums\n                               i 0\n                               j (- (count nums) i 1)\n                               acc []\n                               [c & cr] top']\n                          (let [start (get nums i)\n                                end (get nums j)]\n                            (if (> i j)\n                              acc\n                              (recur nums\n                                     (inc i)\n                                     (dec j)\n                                     (conj acc\n                                           (-> c\n                                               (assoc i start)\n                                               (assoc j end)))\n                                     cr))))\n                  \n                  top''' (reverse top'')\n                  bottom' (->> bottom\n                               (pad-sides))]\n              (->> (concat top''' bottom')\n                   (map #(vec (reverse %)))\n                   (reverse))))\n          (make-grid-from [xs]\n            (let [ss (square-length (count xs))]\n              (->>\n               (case ss\n                 0 []\n                 1 [xs]\n                 2 [[\\space        (nth xs 0)    \\space     ]\n                    [(nth xs 3)    \\space     (nth xs 1)    ]\n                    [\\space        (nth xs 2)    \\space     ]]\n                 ;; Extend the grid\n                 (let [[subgrid remaining] (split-at (* (dec ss) (dec ss)) xs)\n                       subgrid (vec subgrid)\n                       remaining (vec remaining)]\n                   (if (even? ss)\n                     (->> (make-grid-from subgrid)\n                          (bot-tri remaining))\n                     (->> (make-grid-from subgrid)\n                          (top-tri remaining))))     ;Layer the triangle up\n                 )\n               (map (partial apply str)))))]\n    (let [ds (squares-digits-with-padding x1 x2)]\n      (make-grid-from ds))))","user":"569dd6e8e4b0542e1f8d1480"},{"problem":138,"code":"(fn [start end]\n    (letfn [(digits [n]\n              (when (pos? n)\n                (cons (rem n 10) (digits (quot n 10)))))\n            (fill [colls]\n              (let [numbers (->> (map count colls)\n                                 (apply +))\n                    sizes (iterate (fn [{n :n inc :inc}]\n                                     {:n (+ inc n)\n                                      :inc (+ inc 2)}) {:n 1 :inc 3})\n                    required (->> (drop-while #(> numbers (:n %)) sizes)\n                                  first\n                                  :n)\n                    missing (- required numbers)]\n                (concat colls (repeat missing (list \\*)))))\n            (right [[y x]]\n              [(dec y) (inc x)])\n            (down [[y x]]\n              [(dec y) (dec x)])\n            (left [[y x]]\n              [(inc y) (dec x)])\n            (up [[y x]]\n              [(inc y) (inc x)])\n            (advance [{coord :cursor direction :direction graph :graph}]\n              (let [next-cell (case direction\n                                :right (right coord)\n                                :down (down coord)\n                                :left (left coord)\n                                :up (up coord))\n                    next-dir (cond\n                               (= direction :right) (if (get graph (down next-cell)) :right :down)\n                               (= direction :down) (if (get graph (left next-cell)) :down :left)\n                               (= direction :left) (if (get graph (up next-cell)) :left :up)\n                               (= direction :up) (if (get graph (right next-cell)) :up :right))]\n                {:graph graph :cursor next-cell :direction next-dir}))]\n      (let [graph  (->> (iterate #(* % %) start)\n                        (take-while #(<= % end))\n                        (map (comp reverse digits))\n                        fill\n                        (reduce (fn [all ds]\n                                  (reduce (fn [{:keys [cursor graph direction] :as m} d]\n                                            (->> (assoc m :graph (assoc graph cursor d))\n                                                 (advance))) all ds)) {:cursor [0 0]\n                                                                       :direction :right\n                                                                       :graph {}})\n                        :graph)\n            coords (keys graph)\n            min-y (apply min (map first coords))\n            max-y (apply max (map first coords))\n            min-x (apply min (map second coords))\n            max-x (apply max (map second coords))\n            width (- max-x min-x)\n            height (- max-y min-y)]\n        (->> (for [y (range max-y (dec min-y) -1)]\n               (for [x (range min-x (inc max-x))]\n                 (get graph [y x] \\space)))\n             (mapv #(apply str %))))))","user":"5d236215e4b02ea6f0fb6a09"},{"problem":138,"code":"(letfn [(maxlen [x] (reduce #(if (> %1 (count %2)) %1 (count %2)) 0 x))\n        (padding [x l] (apply str (repeat (/ (- l (count x)) 2) \" \")))\n        (pad [x l] (into [] (map #(if (> l (count %)) (str (padding % l) % (padding % l)) %) x)))\n        (down [x d] (if (empty? x) (str d) (str x \" \" d)))\n        (up [x d] (if (empty? x) (str d) (str d \" \" x)))\n        (squares [n m] (loop [nums [n] l (* n n)]\n                         (if (> l m)\n                           nums\n                           (recur (conj nums l) (* l l)))))\n        (->digits [ds] (concat (seq (apply str ds)) (repeat \\*)))\n        (->fns [sq] (let [row-count (count sq)\n                          up? (= 1 (mod (quot row-count 2) 2))\n                          p1fn (if up? up down)\n                          p3fn (if up? down up)\n                          p2fn (if up? #(into [] (cons (str %2) %1)) #(conj %1 (str %2)))\n                          rowdir (if up? -1 1)\n                          start-row (+ (quot row-count 2) rowdir)\n                          ]\n                      (loop [phase1 (if up? (reverse (range 0 (inc start-row))) (range start-row row-count))\n                             phase2 [0 0]\n                             phase3 (if up? (range 1 (+ start-row 3)) (reverse (range start-row (inc row-count))))\n                             fns []]\n                        (cond\n                          (seq phase1) (recur (rest phase1) phase2 phase3 (conj fns (fn [sq d] (update-in sq [(first phase1)] p1fn d))))\n                          (seq phase2) (recur phase1 (rest phase2) phase3 (conj fns p2fn))\n                          (seq phase3) (recur phase1 phase2 (rest phase3) (conj fns (fn [sq d] (update-in sq [(first phase3)] p3fn d))))\n                           :else fns))))]\n  #(let [digits (rest (->digits (squares %1 %2)))\n         box [(str (first (str %1)))]]\n     (if (= (first digits) \\*)\n       box\n       (loop [digits digits\n              box box\n              fns (->fns box)]\n         (cond \n           (seq fns) (recur (rest digits) ((first fns) box (first digits)) (rest fns))\n           (= \\* (first digits)) (pad box (maxlen box))\n           :else (recur digits box (->fns box)))))))","user":"56d63729e4b0ea9b8538f7ca"},{"problem":138,"code":"; Evil hack\n(fn [& _]\n  (reify Object\n    clojure.lang.IPersistentCollection\n    (seq [_])\n    (cons [_ _])\n    (empty [_])\n    (equiv [_ _] true)))","user":"51e58e02e4b0efabf93c02d0"},{"code":"(fn [start end]\n  (letfn [(numbers [start end]\n            (if (> start end)\n              []\n              (cons (str start) (numbers (* start start) end))))\n          (get-str [start end]\n            (let [nr (numbers start end)\n                  c (count (apply str nr))\n                  n (Math/ceil (Math/sqrt c))]\n              (apply str (concat nr (repeat (- (* n n) c) \"*\")))))\n          (next-direction [c n]\n            (lazy-seq (concat (repeat (quot n 2) (first c)) (next-direction (rest c) (inc n)))))]\n    (let [v (get-str start end)\n          d (cycle [[+1 +1] [+1 -1] [-1 -1] [-1 +1]])\n          n (int (Math/sqrt (count v)))\n          w (- (* 2 n) 1)\n          m (vec (map (fn [a] (vec (repeat w \" \"))) (range w)))\n          xs (map vector v (next-direction d 2))]\n      (apply map str\n             (first\n              (reduce\n               (fn [[mtx [px py]] [chr [dy dx]]]\n                 [(assoc-in mtx [px py] (str chr)) [(+ px dx) (+ py dy)]])\n               [m [(dec n) (* 2 (quot (dec n) 2))]]\n               xs))))))","problem":138,"user":"5097b556e4b00ad8bab4e970"},{"problem":138,"code":"(fn ensquare [to-square limit]\n(letfn [(append [list-2 list-1]\n          (reverse (cons list-2 (reverse list-1))))\n        (get-squares [to-square limit]\n          (->> (iterate #(* % %) to-square)\n            (take-while #(>= limit %))\n            (apply str)\n            seq\n            (#(concat % (repeat \"*\")))))\n        (rotation1 [numbers]\n          (loop [counter 1\n                 rel-nums (take 1 numbers)\n                 rem-nums (drop 1 numbers)\n                 result '()]\n               (if (every? #(= % \"*\") rel-nums)\n                   (mapv vec result)\n                   (recur\n                     (inc counter)\n                     (reverse (take (dec (* 2 (inc counter))) rem-nums))\n                     (drop (dec (* 2 (inc counter))) rem-nums)\n                     (if (odd? counter)\n                         (cons\n                             (reverse (take counter rel-nums))\n                             (mapv cons\n                               (drop counter rel-nums) result))\n                         (append\n                             (take counter rel-nums)\n                             (mapv append\n                               (reverse (drop counter rel-nums)) result)))))))\n        (rotation2 [numbers]\n          (let [size (count numbers)\n                max-layer (- (* 2 size) 1)\n                half-layer (quot max-layer 2)]\n               (loop [layer 0,\n                      v-look-at '(0)\n                      h-look-at '(0)\n                      result '()]\n                 (if (= layer max-layer) result\n                     (recur (inc layer)\n                            (if (< layer half-layer)\n                                (cons (inc layer) v-look-at)\n                                (butlast v-look-at))\n                            (if (< layer half-layer)\n                                (append (inc layer) h-look-at)\n                                (rest h-look-at))\n                            (append\n                              (map #(get-in numbers %) (mapv vector v-look-at h-look-at))\n                              result))))))\n        (stringize [number size]\n          (->> number\n          (interpose \" \")\n          (#(concat (repeat (- size (count number)) \" \") % (repeat (- size (count number)) \" \")))\n          (apply str)))\n        (rotation3 [numbers]\n            (map #(stringize % (apply max (map count numbers))) numbers))]\n\n        (vec (rotation3 (rotation2 (rotation1 (get-squares to-square limit)))))))","user":"5f548678e4b0a0bc16850a7e"},{"code":"(fn __\n  [a b]\n  (let [base (apply str (take-while #(<= % b) (iterate #(* % %) a)))\n        len (first (drop-while #(< % (count base)) (map #(int (Math/pow % 2)) (range))))\n        padding (apply str (repeat (- len (count base)) \"*\"))\n        s (str base padding)\n        slen (+ (int (Math/sqrt (count s))) (dec (int (Math/sqrt (count s))))) \n        field (vec (take slen (repeat (vec (take slen (repeat \\space))))))\n        si (if (odd? (int (Math/sqrt (count s)))) (quot slen 2) (dec (quot slen 2)))\n        sj (quot slen 2)]\n    \n    (letfn [(update-field\n              [f [i j] e]\n              {:f (assoc-in f [i j] e) :c [i j]})\n            \n            (step\n              [f [i j] d e]\n              (condp = d\n                :se (update-field f [(inc i) (inc j)] e)\n                :sw (update-field f [(inc i) (dec j)] e)\n                :nw (update-field f [(dec i) (dec j)] e)\n                :ne (update-field f [(dec i) (inc j)] e)\n                ))\n\n            (turn\n              [dir]\n              (let [dirs [:se :sw :nw :ne]]\n                (dirs (mod (inc (.indexOf dirs dir)) (count dirs)))))\n            \n            (next-dir\n              [f [i j] d]\n              (condp = d\n                :se (if (= \\space (get-in f [(inc i) (dec j)])) (turn d) d)\n                :sw (if (= j sj) (turn d) d)\n                :nw (if (= 2 (- (count (filter #(not= \\space %) (f i)))\n                                (count (filter #(not= \\space %) (f (dec i))))))\n                      (turn d)\n                      d)\n                :ne (if (= j sj) (turn d) d)\n                ))\n            ]\n                    \n    (loop [fld (assoc-in field [si sj] (first s))\n              idx [si sj]\n              dir :se\n              tail (rest s)]\n      (if (empty? tail)\n        (map #(apply str %) fld)\n        (let [moved (step fld idx dir (first tail))\n              ndir (next-dir (moved :f) (moved :c) dir)]\n            (recur (moved :f) (moved :c) ndir (rest tail)))\n    )))))","problem":138,"user":"5348cab4e4b084c2834f4a5e"},{"problem":138,"code":"(fn [start end] \n  (let [powers (apply str (take-while #(<= % end) (iterate #(* % %) start)))\n        dim (first (filter #(>= (* % %) (count powers)) (range)))\n        insert-at (fn [square coords symb]\n                    (assoc square (first coords) \n                      (assoc (square (first coords)) (second coords) symb)))\n        leg-lengths (cons 1 (apply interleave (repeat 2 (rest (range)))))\n        directions [[-1 0] [0 1] [1 0] [0 -1]]\n        square (loop [[leg-length :as leg-lengths] leg-lengths\n                      leg-so-far 1\n                      [symb & symbs] powers\n                      direction-index 0\n                      coords (vec (repeat 2 (quot (dec dim) 2)))\n                      square (vec (repeat dim (vec (repeat dim \\*))))]\n                 (if (nil? symb) square\n                   (let [corner? (>= leg-so-far leg-length)\n                         direction-index (if corner? (mod (inc direction-index) 4) direction-index)\n                         leg-so-far (if corner? 0 leg-so-far)]\n                     (recur (if corner? (rest leg-lengths) leg-lengths) \n                            (inc leg-so-far) \n                            symbs \n                            direction-index \n                            (map + coords (directions direction-index))\n                            (insert-at square coords symb)))))\n        at (fn [[y x]] (get (get square y) x))\n        longest-line (dec (* dim 2))\n        starting-cells (map #(vector % 0) (range longest-line))\n        row-from (fn [coords] \n                   (->> coords\n                        (iterate #(map + % [-1 1]))\n                        (map at)\n                        (drop-while nil?)\n                        (take-while (complement nil?))\n                        (clojure.string/join \" \")))]\n    (-> starting-cells\n        (->> \n         (map row-from)\n         (map (fn [line] \n                (let [padding (apply str (repeat (quot (- longest-line (count line)) 2) \" \")) ]\n                  (apply str (concat padding line padding)))))))))","user":"54febf4be4b07d26eda61d45"},{"code":"(fn [start end]\n    (let [\n          one-spiral (fn [n]\n                        (let [n1 (inc (* 2 n))\n                              n2 (inc n1)]\n                          (mapcat repeat [n1 n1 n2 n2]\n                                  [ [1 1] [1 -1] [-1 -1] [-1 1]])))\n                    vec-add #(vec (map + %1 %2))\n          vec-sub #(vec (map - %1 %2))\n          get-lower-bound (fn [coords]\n                            (let [[rows cols] [(map first coords) (map last coords)]]\n                              [(apply min rows) (apply min cols)]))\n          get-upper-bound (fn [coords]\n                            (let [[rows cols] [(map first coords) (map last coords)]]\n                              [(apply max rows) (apply max cols)]))\n;;======\n          result (->> start\n                      (iterate #(* % %))\n                      (take-while #(>= end %))\n                      (apply str))\n          result-length (count result)\n          spiral-length (->> (range)\n                             (filter odd?)\n                             (reductions +)\n                             (drop-while #(> (- result-length %) 0))\n                             (first))\n          translate-to (fn [origin coords]\n                         (let [translation-factor\n                               (vec-sub [0 0] (get-lower-bound coords))]\n                           (map #(vec-add translation-factor %) coords)))\n          spiral-coords (->> (range)\n                  (mapcat one-spiral)\n                  (reductions vec-add [0 0])\n                  (take spiral-length)\n                  (translate-to [0 0]))\n          content-by-coord  (zipmap spiral-coords (concat result (repeat \\*)))\n          [rows cols]  (map range (map inc (get-upper-bound spiral-coords)))]\n      (for [row rows]\n                   (apply str (map #(content-by-coord [row %] \\space) cols)))))","problem":138,"user":"4e6f578c535d5021c1a8961b"},{"code":"(fn [x y]\n    (let [s (apply str (take-while #(<= % y) (iterate #(* % %) x)))\n          d (-> s count Math/sqrt Math/ceil)\n          ll (* d d)\n          ss (take ll (concat s (repeat \\*))) \n          steps (cycle [[1 1] [1 -1] [-1 -1] [-1 1]])\n          step-counts (drop 2 (interleave (range) (range)))\n          moves (take (dec ll) (mapcat #(repeat %2 %) steps step-counts))\n          coords (reductions #(vec (map + %1 %2)) [0 0] moves)\n          xoffset (- (apply min (map first coords)))\n          yoffset (- (apply min (map second coords)))\n          new-coords (map (fn [[x y]] [(+ x xoffset) (+ y yoffset)]) coords)\n          xsize (inc (apply max (map first new-coords)))\n          ysize (inc (apply max (map second new-coords)))\n          blank-board (vec (repeat xsize (vec (take ysize (repeat \\space)))))\n          ]\n        (map \n            #(apply str %) \n            (reduce \n                #(assoc-in % (nth new-coords %2) (nth ss %2)) \n                blank-board \n                (range ll)))))","problem":138,"user":"4fbbcf0ce4b081705acca2ee"},{"problem":138,"code":"(fn f [start end]\n  (let [squares (take-while #(<= % end) (iterate #(* % %) start))\n        digits (apply str squares)\n        side (first (drop-while #(< (* % %) (count digits)) (range)))\n        size (dec (* 2 side))\n        next-dir (cycle [[1 1] [1 -1] [-1 -1] [-1 1]])]\n    (loop [digits (take (* side side) (concat digits (repeat \\*)))\n           field (vec (repeat size (vec (repeat size \\space))))\n           pos [(if (even? side) (- side 2) (dec side)) (dec side)]\n           dir (mapcat repeat (->> (interleave (range) (range)) (drop 2)) next-dir)]\n      (if (empty? digits)\n        (map #(apply str %) field)\n        (recur (rest digits) (assoc-in field pos (first digits)) (map + pos (first dir)) (rest dir))))))","user":"5dd60c58e4b0948ae9d9ad7c"},{"problem":138,"code":"(fn squares-squared [start end]\n    (letfn [(replace-position [square [y x] value]\n              (let [[before-y after-y] (split-at y square)\n                    [before-x after-x] (split-at x (first after-y))]\n                (concat before-y\n                        [(apply str (concat before-x [value] (rest after-x)))]\n                        (rest after-y))))\n            (expand-square [square]\n              (cond (= (count square) 1) [(str \" \" (first square) \" \")\n                                          \"* *\"\n                                          \" * \"]\n                    (= (count square) 3) (map #(str %2 %1 %2)\n                                              `(\" * \" \"* *\" ~@square)\n                                              [\" \" \" \" \"*\" \" \" \" \"])\n                    :else                (map #(str %2 %1 %2)\n                                              `(~@(butlast square)\n                                                ~(str \"*\" (subs (last square) 1 4) \"*\")\n                                                \" * * \" \"  *  \")\n                                              [\" \" \" \" \" \" \"*\" \" \" \" \" \" \"])))\n            (get-update-positions []\n              (map :value (iterate (fn [{pair      :value\n                                         direction :direction}]\n                                     {:value     (map + pair direction)\n                                      :direction (cond (#{[0 0] [2 4]} pair) [1 -1]\n                                                       (#{[1 2] [5 4]} pair) [-1 -1]\n                                                       (= [2 1] pair)        [1 0]\n                                                       (= [1 0] pair)        [-1 1]\n                                                       (= [1 1] pair)        [1 1]\n                                                       (= [1 3] pair)        [1 2]\n                                                       :else                 direction)})\n                                   {:value     [0 0]\n                                    :direction [1 2]})))]\n      (loop [square [\"*\"]\n             content (apply str (take-while #(<= % end) (iterate #(* % %) start)))\n             update-positions (get-update-positions)]\n        (cond (empty? content)\n              square\n              (not-any? #(some (partial = \\*)\n                               %)\n                        square)\n              (recur (expand-square square)\n                     content\n                     update-positions)\n              :else\n              (recur (replace-position square\n                                       (first update-positions)\n                                       (first content))\n                     (rest content)\n                     (rest update-positions))))))","user":"53acaf1fe4b047364c04445f"},{"problem":138,"code":"(fn squares-squared [x max-x]\n  (letfn [(directions-seq\n            ;; Returns sequence of directions when walk from the center of spiral.\n            []\n            (cycle [[1 1] [1 -1] [-1 -1] [-1 1]]))\n          \n          (steps-seq\n            ;; Returns sequence of step deltas when walk from the center of spiral.\n            ([]\n             (steps-seq 1 (directions-seq)))\n            ([size directions]\n             (lazy-cat (concat (repeat size (first directions))\n                               (repeat size (second directions)))\n                       (steps-seq (inc size) (nthrest directions 2)))))\n\n          (steps\n            ;; Returns sequence of steps.\n            [n]\n            (take n (steps-seq)))\n          \n          (coordinates [yx n]\n            ;; Coordinates of sequence of n steps when walk from the center of spiral.\n            ;; Argument yx is coordinate of center of spiral.\n            (reduce (fn [coords [dy dx]]\n                      (let [[y x] (peek coords)]\n                        (conj coords [(+ y dy) (+ x dx)])))\n                    [yx]\n                    (steps (dec n))))\n\n          (digits\n            ;; Returns collection of digits of given number.\n            [x]\n            (loop [res '() x x]\n              (if (zero? x)\n                res\n                (recur (conj res (rem x 10))\n                       (quot x 10)))))\n\n          (pow\n            ;; Power of x.\n            [x]\n            (*' x x))\n          \n          (sqrt\n            ;; Largest integer value that is less than or equal to the sqrt of x.\n            [x]\n            (int (Math/sqrt x)))\n          \n          (pows [x max-x]\n            ;; Returns collection of successive squares from the x which is not larger than max-x.\n            (loop [res [x] x x]\n              (let [nx (pow x)]\n                (if (> nx max-x)\n                  res\n                  (recur (conj res nx) nx)))))\n\n          (remain-to-next-square [x]\n            ;; Return remain from x to next element of sequence (2, 4, 9, 16, 36, 49, 64, ...).\n            (let [sqrt-val (sqrt x)]\n              (if (= x (pow sqrt-val))\n                0\n                (- (pow (inc sqrt-val))\n                   x))))\n\n          (pows-digits [x max-x]\n            ;; Returns digits of (pow x max-x). If number of elements is not one of sequence\n            ;; (2, 4, 9, 16, 36, 49, 64, ...) then it is filled up with asterics.\n            (let [digs (mapcat #(digits %) (pows x max-x))]\n              (concat digs\n                      (repeat (remain-to-next-square (count digs))\n                              \\*))))\n\n          (make-board\n            ;; Make board with size\n            [size]\n            (->> \\space\n                 (repeat size)\n                 vec\n                 (repeat size)\n                 vec))\n          \n          (board-size [coll-count]\n            ;; Calculates board size which is enought for rotated spiral of coll\n            ;; with coll-count elements \n            (let [non-roteted-size (sqrt coll-count)]\n              (dec (* non-roteted-size 2))))\n          \n          (center-coord [board-size]\n            ;; Calculates center coordinates for board-size.\n            (let [non-rotated-size (/ (inc board-size) 2)]\n              (if (odd? non-rotated-size)\n                [(dec non-rotated-size) (dec non-rotated-size)]\n                [(- non-rotated-size 2) (dec non-rotated-size)])))\n          \n          (board->vec-of-string [board]\n            ;; Converts board to vector of strings.\n            (map #(apply str %)\n                 board))]\n    \n    (let [pows-digits (pows-digits x max-x)\n          size        (count pows-digits)\n          board-size  (board-size size)\n          board       (make-board board-size)\n          center-yx   (center-coord board-size)\n          coords      (coordinates center-yx size)]\n      (board->vec-of-string\n       (reduce (fn [board [yx v]]\n                 (assoc-in board yx v))\n               board\n               (map (fn [c v] [c v])\n                    coords\n                    pows-digits))))))","user":"55586905e4b0deb715856e2b"},{"problem":138,"code":"(fn squares[s e]\n  (let [sq (loop[i (iterate #(* % %) s) r []]\n             (if (> (first i) e) (apply str r)\n               (recur (rest i) (conj r (first i)))))\n        sl (count sq)\n        cl (int (Math/ceil (Math/sqrt sl)))\n        pl (- (int (Math/pow cl 2)) sl)\n        pa (reverse (str sq (apply str (repeat pl \\*))))\n        ml (int (- (* cl 2) 1))\n        rm (vec (for[i (range ml)] (vec (repeat ml \\space))))\n        sm (loop[pos [(quot ml 2) (if (= 0 (rem cl 2)) 0 (- ml 1))] dir (if (= 0 (rem cl 2)) [1 1] [-1 -1]) r rm p pa]\n             (if (seq p)\n               (let[cc (get-in r pos)]\n                 (if (= cc \\space) (recur (map + pos dir) dir (update-in r pos (fn[x] (first p))) (rest p))\n                   (let[newd (cond\n                            (= [1 1] dir) [-1 1]\n                            (= [-1 1] dir) [-1 -1]\n                            (= [-1 -1] dir) [1 -1]\n                            :else [1 1])]\n                     (recur (map + (map - pos dir) newd) newd r p))))\n               r))]\n    (map (partial apply str) sm)))","user":"541619e8e4b01498b1a719f9"},{"code":"(fn [start end]\n  (let [sqr #(* % %)\n        sqrs (apply str (take-while (partial >= end) (iterate sqr start)))\n        len (count sqrs)\n        diamondside (int (Math/ceil (Math/sqrt len)))\n        sqrside (dec (* 2 diamondside))\n        nextsqr (sqr diamondside)\n        filled (apply str sqrs (repeat (- nextsqr len) \\*))\n        step (fn [[x y] d] \n                (let [[f1 f2] ([[inc inc] [dec inc] \n                                [dec dec] [inc dec]] d)]\n                  [(f1 x) (f2 y)]))\n        steps (mapcat #(repeat (inc (quot % 2)) (mod % 4)) (range))\n        startpos (if (odd? diamondside)\n                  [(dec diamondside) (dec diamondside)]\n                  [(dec diamondside) (- diamondside 2)])\n        startstring (vec (repeat sqrside \n                          (vec (repeat sqrside \\ ))))\n        compute\n          (fn [[b [x y]] [c d]]\n            (let [newpos (step [x y] d)]\n              [(assoc-in b [y x] c) newpos]))]\n    (map (partial apply str)\n      (first \n        (reduce compute \n          [ startstring\n            startpos]\n          (map vector filled steps))))))","problem":138,"user":"4f03ac2d535dcb61093f6b4a"},{"code":"(fn [s e]\n  (letfn [(sq-digits []\n            (->> s\n                 (iterate #(* % %))\n                 (take-while #(<= % e))\n                 (map str)\n                 (apply str)))\n\n          (next-square [low-bound]\n            (->> (range)\n                 (map #(* % %))\n                 (drop-while #(< % low-bound))\n                 first))\n\n          (spiral []\n            (let [directions (cycle [[1 1] [1 -1] [-1 -1] [-1 1]])\n                  distances (mapcat #(repeat 2 %) (rest (range)))]\n              (->> (map list distances directions)\n                   (map (fn [[dst dir]] (repeat dst dir)))\n                   (apply concat)\n                   (reductions #(map + % %2) [0 0]))))\n\n          (as-range [xs]\n            (apply range (apply (juxt min (comp inc max)) xs)))\n\n          (render [char-by-pos]\n            (let [pos (keys char-by-pos)\n                  xs (map first pos)\n                  ys (map second pos)]\n              (for [x (as-range xs)]\n                (apply str\n                       (for [y (as-range ys)]\n                         (char-by-pos [x y] \\space))))))]\n    (let [digs (sq-digits)\n          len (next-square (count digs))\n          digs-ast (take len (concat digs (repeat \\*)))\n          positional-chars (map list (spiral) digs-ast)]\n      (render (apply hash-map (apply concat positional-chars))))))","problem":138,"user":"51b9d1f0e4b0e871ca49590b"},{"code":"(fn [start end]\n  (let [squares (take-while (partial >= end) (iterate #(* % %) start))\n        digits (apply str squares)\n        expand-shape (fn [coll rt]\n  (letfn [(spaces [n] (apply str (repeat n \\ )))\n          (expand-above [c]\n                        (for [j (range 1 (* rt 2))]\n                          (cond\n                           (= j 1) (str (spaces (dec rt)) \"*\" (spaces (dec rt)))\n                           (= j 2) (str (spaces (- rt 2)) \"* *\" (spaces (- rt 2)))\n                           (<= j rt) (let [j* (- j 3)]\n                                       (str (spaces (- rt j))\n                                            \"* \"\n                                            (clojure.string/trim (apply str (nth c j*)))\n                                            \" *\"\n                                            (spaces (- rt j))))\n                           :else (str \" \" (apply str (nth c (- j 3))) \" \")\n                           )))]\n    (if (odd? rt)\n      ; On odd square root, add above, on even add below.\n      (expand-above coll)\n      (reverse (expand-above (reverse coll)))\n     )\n    )\n  )\n        add-digit (fn [coll d]\n  (let [len (count coll)\n        mid (int (/ len 2))\n        stars? (fn [s] (re-find (re-matcher #\"\\*\" (str s))))\n        fill-star (fn fs [[s & e]]\n                    (if (stars? s)\n                      (cons (clojure.string/replace (apply str s) \\* d) e)\n                      (cons s (fs e))\n                      ))]\n    (cond\n     ; If the top-half contains a *, then fill in from the left-most *.\n     (some stars? (take mid coll))\n      (apply map str (fill-star (apply map str coll)))\n     ; If the bottom-half contains a *, then fill in from the right-most *.\n     (some stars? (drop (inc mid) coll))\n      (apply map str (reverse (fill-star (reverse (apply map str coll)))))\n     ; Else only one * exists in the middle row, replace it.\n     :else (concat (take mid coll)\n                   (fill-star (drop mid coll)))\n     )\n    )\n  )\n        square? (fn [n]\n  (= n (let [r (int (Math/sqrt n))] (* r r))))\n        shape (fn [coll]\n  (loop [[d & etc] coll\n         acc [\"*\"]\n         i 1]\n    (if (nil? d)\n      acc\n      (recur etc\n             (if (and (square? (dec i)) (> i 1))\n               ; If the last index was a perfect square, then start a new section.\n               (add-digit (expand-shape acc (inc (int (Math/sqrt (dec i))))) d)\n               (add-digit acc d)\n              )\n             (inc i))\n      )\n    )\n  )\n        ]\n    (shape digits)\n    )\n  )","problem":138,"user":"52e59ca5e4b09f7907dd1464"},{"code":"(fn [x maxx]\n  (let [nums (apply str (take-while #(<= % maxx) (iterate #(* % %) x)))\n        sqrlen (long (Math/ceil (Math/sqrt (count nums))))\n        spiral (fn spiral [d n reps i]\n                  (lazy-seq (cons d \n                     (if (= i reps)\n                       (spiral (map #(* (if (even? n) 1 -1) %) (reverse d)) (rem (inc n) 2) (+ n reps) 1)\n                       (spiral d n reps (inc i))))))      \n        center (long (quot sqrlen 2.5))\n        square (reduce \n                  #(update-in %1 (first %2) (constantly (second %2)))  \n                  (vec (repeat sqrlen (vec (repeat sqrlen \\*))))\n                  (map vector (reduce #(conj %1 (map + (last %1) %2)) \n                                      [[center center]] \n                                      (take (dec (count nums)) (spiral '(0 1) 0 1 1))) nums))\n        diamlen (+ (dec sqrlen) sqrlen)\n        diampos (map (fn [n]\n                       (filter #(= n (apply + %)) \n                               (for [x (range sqrlen), y (range sqrlen)]\n                                 [y x])))\n                     (range diamlen))]\n\n\n    (reduce \n      (fn [diam pos] \n        (let [line (apply str (interpose \\space (map #(get-in square %1) pos) ))\n              pad (apply str (repeat (quot (- diamlen (count line)) 2) \\space))]\n          (conj diam (apply str [pad line pad]))))\n     []\n     diampos)))","problem":138,"user":"53300924e4b019098a6f8b55"},{"problem":138,"code":"(fn [start end]\r\n  (let [\r\n    ; generic helpers\r\n    zip (fn [seq1 seq2] (map list seq1 seq2))\r\n    join (fn join [sep [head & tail]]\r\n      (if (nil? head) []\r\n      (if (empty? tail) [head]\r\n      (cons head (cons sep (join sep tail))))))\r\n    center (fn [seq n]\r\n      (let [\r\n        pad-len (/ (- n (count seq)) 2)\r\n        padding (repeat pad-len \" \")]\r\n        (concat padding seq padding)))\r\n\r\n    ; for generating the numbers\r\n    sq #(* % %)\r\n    sq-iter (fn [x] (iterate sq x))\r\n    squares (fn [start end]\r\n      (take-while #(<= % end) (sq-iter start)))\r\n\r\n    ; for finding the size of the square\r\n    square-pairs (fn []\r\n      (map #(-> [(inc %) (sq (inc %))]) (range)))\r\n    next-square (fn [x]\r\n      (first\r\n        (drop-while #(< (last %) x)\r\n          (square-pairs))))\r\n\r\n    ; generate the string\r\n    unpadded-string (apply str (map str (squares start end)))\r\n    [side string-length] (next-square (count unpadded-string))\r\n    stars-padding\r\n      (repeat (- string-length (count unpadded-string)) \"*\")\r\n    the-string (str unpadded-string (apply str stars-padding))\r\n\r\n    ; generate a spiral\r\n    repeats (map #(inc (int (/ % 2))) (range))\r\n    dirs (let [directions [[0 1] [1 0] [0 -1] [-1 0]]]\r\n      (map #(directions (mod % 4)) (range)))\r\n    spiral-moves\r\n      (apply concat\r\n        (map (fn [[n v]] (repeat n v)) (zip repeats dirs)))\r\n    spiral-func (fn spiral-func [y x [[dy dx] & tail]]\r\n      (cons [y x]\r\n        (lazy-seq (spiral-func (+ y dy) (+ x dx) tail))))\r\n    min-coord (fn [[y1 x1] [y2 x2]] [(min y1 y2) (min x1 x2)])\r\n    subtr-coord (fn [[y1 x1] [y2 x2]] [(- y1 y2) (- x1 x2)])\r\n    adjust (fn [seq]\r\n      (map #(subtr-coord % (reduce min-coord seq)) seq))\r\n    spiral (adjust\r\n      (take string-length (spiral-func 0 0 spiral-moves)))\r\n\r\n    ; make the string into a spiral\r\n    string-spiral\r\n      (apply hash-map (apply concat (zip spiral the-string)))\r\n\r\n    ; rotate the square\r\n    rotated-square (fn [n]\r\n      (let [inside? (fn [[y x]] (and (< y n) (< x n)))]\r\n        (take-while #(not (empty? %))\r\n          (map\r\n            (fn [i]\r\n              (filter inside?\r\n                (map (fn [j] [(- i j) j]) (range (inc i)))))\r\n            (range)))))\r\n    rotated-string-spiral\r\n      (map\r\n        (fn [row] (join \" \" (map string-spiral row)))\r\n        (rotated-square side))]\r\n\r\n    ; produce the output\r\n    (map\r\n      #(apply str (center % (- (* 2 side) 1)))\r\n      rotated-string-spiral)))","user":"555bd27ae4b0b056612e2244"},{"code":"(fn [p q]\n  (let [dirs (mapcat\n               #(repeat %2 %) (cycle [[1 1] [1 -1] [-1 -1] [-1 1]])\n               (cons 1 (mapcat #(repeat % %) (iterate inc 1))))\n        digits (apply str (take-while #(<= % q) (iterate #(* % %) p)))\n        [max-digits sq-size]\n                   (first\n                     (drop-while\n                       (fn [[d s]] (> (count digits) d))\n                       (map #(vector %1 %2)\n                            (map #(* % %) (iterate inc 2))\n                            (iterate #(+ % 2) 3))))\n        spiral ((fn [digits dirs]\n                 (let [digits-in-center (inc (quot sq-size 2))\n                       center-piece (if (zero? (rem digits-in-center 2))\n                                      (dec (quot sq-size 2))\n                                      (quot sq-size 2))\n                       first-pos [center-piece (quot sq-size 2)]]\n                   (loop [[fdig & ndig] (next digits),\n                          [fd & nd] dirs,\n                          pos first-pos,\n                          sp {first-pos (first digits)}]\n                     (if (nil? fdig)\n                       sp\n                       (recur ndig nd (map + pos fd) (assoc sp (map + pos fd) fdig))\n                      ))))\n                  (concat digits (repeat (- max-digits (count digits)) \"*\")) dirs)]\n    (if (= 1 (count digits))\n      [digits]\n      (into []\n        (for [y (range 0 sq-size)]\n          (reduce str\n             (for [x (range 0 sq-size)]\n               (get spiral [y x] \\space))))))))","problem":138,"user":"504c8165e4b09724c857af31"},{"problem":138,"code":"(fn [a b]\n    (let [sj    clojure.string/join\n          nextd {[+1 +1] [-1 +1]\n                 [-1 +1] [-1 -1]\n                 [-1 -1] [+1 -1]\n                 [+1 -1] [+1 +1]\n                 }]\n      (letfn [(is-sq? [n]\n                (= n (* (int (Math/sqrt n)) (int (Math/sqrt n)))))\n              (sq-seq [a b]\n                (if (< b a) []\n                    (cons a (sq-seq (* a a) b))))\n              (limits [s]\n                [(apply min s) (apply max s)])\n              (pad-to-sq [s]\n                (if (is-sq? (count s))\n                  s\n                  (pad-to-sq (str s \"*\"))))\n              (layout [s pos dir steps-left size]\n                (let [this-pos {:x (first pos)\n                                :y (second pos)\n                                :v (first s)}]\n                  (cond\n                    (empty? s)       []\n                    (= 0 steps-left) (cons this-pos\n                                           (layout\n                                            (rest s)\n                                            (mapv + pos dir)\n                                            (nextd dir)\n                                            (dec size)\n                                            (+ size (quot (inc (apply * dir)) 2))))\n                    :else\n                    (cons this-pos\n                          (layout\n                           (rest s)\n                           (mapv + pos dir)\n                           dir\n                           (dec steps-left)\n                           size)))))\n              (render [m]\n                (println m)\n                (let [[xs ys] [(map :x m) (map :y m)]\n                      [minr maxr] (limits ys)\n                      [minc maxc] (limits xs)]\n                  (println  [minr maxr]                       [minc maxc])\n                  (for [r (range minr (inc maxr))]\n                    (sj \"\" (for [c (range minc (inc maxc))]\n                             (or (:v (first (filter #(= {:x c :y r}\n                                                        (select-keys % [:x :y]))\n                                                    m)))\n                                 \\space))))))\n              ]\n        (->\n         (sq-seq a b)\n         sj\n         pad-to-sq\n         (layout [0 0] [+1 +1] 0 1)\n         render))))","user":"583048d9e4b051871117c007"},{"code":"(fn [a b]\n  (letfn [\n    (square-str [a b]\n      (loop [i a ret [a]]\n        (let [sq (* i i)]\n          (if (> sq b) \n            (apply str ret) \n            (recur sq (conj ret sq))))))\n    (diamond-size [s]\n      (inc (* 2 (-> s count dec Math/sqrt int))))\n    (max-str-size [ds]\n      (let [x (quot (inc ds) 2)] (* x x)))\n    (str-index [y x]\n      (let [sum (+ y x) diff (- y x)]\n        (if (odd? sum) nil\n          (if (<= y 0)\n            (if (<= x 0)\n              (- (* sum sum) y)\n              (+ (* diff diff) (* 2 x) (- y)))\n            (if (<= x 0)\n              (- (* diff diff) y)\n              (- (* sum sum) (* 2 x) y))))))\n    (start-pt [size]\n      (let [q (quot size 2)]\n        [(if (even? q) q (dec q)) q]))\n    (mk-diamond [s fill-ch]\n      (let [\n        sz (diamond-size s) \n        max-str (max-str-size sz)\n        start (start-pt sz)]\n        (vec (map #(apply str %) (partition sz\n          (for [\n            i (range sz) \n            j (range sz) \n            :let [y (- i (start 0))] \n            :let [x (- j (start 1))]\n            :let [ix (str-index y x)]] \n            (cond \n              (or (nil? ix) (>= ix max-str)) \\space\n              (>= ix (count s)) fill-ch\n              :else (get s ix))))))))]\n    (mk-diamond (square-str a b) \\*)))","problem":138,"user":"4f050dec535dcb61093f6bef"},{"code":"(fn [start end]\n  (let [fill-char \"*\" \n        powers (iterate #(* % %) start)\n        ps (take-while #(<= % end) powers)\n        pstr (apply str (map str ps))\n        slen (count pstr)\n        sqr (first (drop-while #(< % slen) (map #(* % %) (range))))\n        s (apply str pstr (repeat (- sqr slen) fill-char))\n        directions (cycle [ [1 -1] [-1 -1] [-1 1] [1 1] ])\n        n-steps-in-direction (mapcat #(flatten [% %]) (iterate inc 1))\n        steps (mapcat #(repeat %2 %1) directions n-steps-in-direction)\n        positions (reductions #(map + %1 %2) [0 0] steps)\n        chars-positions (map vector s positions)\n        sort-fn-y (fn [[ a [b c] ]] (- c))\n        raw-rows (partition-by sort-fn-y (sort-by sort-fn-y chars-positions))\n        row-sorter (fn [r] (sort-by (fn [[a [b c] ]] b) r))\n        row-parser (fn [r] (map first (row-sorter r)))\n        rows (map row-parser raw-rows)\n        spaced-rows (map (fn [r] (apply str (interpose \" \" r))) rows)\n        longest-row (apply max (map count spaced-rows))]\n    (map (fn [r] (let [padding-length (/ (- longest-row (count r)) 2)\n                       padding (apply str (repeat padding-length \" \"))\n                       padded (apply str padding r padding)]\n                   padded)) \n         spaced-rows)\n    )\n  )","problem":138,"user":"523f0bbfe4b01c266ffa7f91"},{"problem":138,"code":"(fn [s e]\n   (let [sq #(* % %)\n         d (->> s\n                (iterate sq)\n                (take-while #(<= % e))\n                (apply str)\n                vec)\n         l (->> 1\n                (iterate inc)\n                (filter #(>= (sq %) (count d)))\n                first)\n         d (concat d (repeat \\*))\n         dirs (->> 1\n                   (iterate inc)\n                   (mapcat #(concat (repeat (dec %) (if (even? %)\n                                                      {:x -1 :y 1}\n                                                      {:x 1 :y -1}))\n                                    (repeat % (if (even? %)\n                                                {:x -1 :y -1}\n                                                {:x 1 :y 1})))))\n         pos (->> 0\n                  (iterate inc)\n                  (map #(apply merge-with +\n                               {:x (dec l) :y (-> l dec (quot 2) (* 2))}\n                               (take % dirs)))\n                  (map vector d)\n                  (take (sq l)))\n         sl (-> l (* 2) dec)\n         r (reduce\n             (fn [vs [c {:keys [x y]}]]\n               (assoc-in vs [y x] c))\n             (vec (repeat sl\n                          (vec (repeat sl \\space))))\n             pos)]\n     (map (partial apply str) r)))","user":"5db0172be4b0f8c104ccfc96"},{"problem":138,"code":"(fn [start end]\n  (let [delta\n        (mapcat repeat\n          (mapcat #(do [% %]) (iterate inc 1))\n          (cycle [[1 1] [1 -1] [-1 -1] [-1 1]]))\n        digits\n        (->> start\n          (iterate #(* % %))\n          (take-while #(<= % end))\n          (apply str))\n        n (->> (range) (drop-while #(< (* % %) (count digits))) first)\n        y (dec n)\n        x (* 2 (quot y 2))\n        m (dec (* n 2))\n        digits (->> (concat digits (repeat \\*)) (take (* n n)))]\n    (->> (reduce (fn [m [p v]] (assoc-in m p v))\n           (->> \" \" (repeat m) vec (repeat m) vec)\n           (map vector\n             (reductions #(map + % %2) [x y] delta)\n             digits))\n      (mapv #(apply str %)))))","user":"50479524e4b0371827a27bc4"},{"code":"(fn [s e]\n  (let [q #(* % %)\n        v (mapcat #(loop [n % r '()]\n                     (cond (< 0 n) (recur (quot n 10) (conj r (rem n 10))) (= '() r) '(0) 1 r))\n                  (take-while #(<= % e) (iterate q s)))\n        g (-> v count Math/sqrt Math/ceil int)\n        l (q g)\n        v (concat v (repeat (- l (count v)) \\*))\n        r (fn [v n] (mapcat #(repeat n %) v))\n        d (take l (mapcat #(repeat %2 %)\n                          (cycle [[1 1] [1 -1] [-1 -1] [-1 1]])\n                          (drop 2 (interleave (range) (range)))))\n        w (- (* 2 g) 1)\n        a (vec (repeat w (vec (repeat w \\ ))))\n        p [(- g (if (even? g) 2 1))\n           (quot w 2)]\n        ps (reductions (fn [p t] (vec (map + p t))) p d)\n        ]\n    (map #(apply str %) (reduce (fn [acc [v p]]\n                       (assoc-in acc p v))\n                     a (map vector v ps))))\n  )","problem":138,"user":"4fa340b4e4b081705acca18c"},{"problem":138,"code":"(fn [start end]\n  (letfn [(square [x]\n            (* x x))\n          (squares [start end]\n            (take-while #(<= % end) (iterate square start)))\n          (digits [numbers]\n            (vec (mapcat str numbers)))\n          (shape-dim [num-elems]\n            (->> num-elems\n                 (Math/sqrt)\n                 (Math/round)\n                 (* 2)\n                 dec))\n          (pad [ds]\n            (let [size (count ds)\n                  upper-limit (->> size\n                                   (Math/sqrt)\n                                   (Math/ceil)\n                                   (Math/round)\n                                   (square))]\n              (vec (take upper-limit (concat ds (repeat \\*))))))\n          (empty-shape [dim]\n            (vec (repeat dim (vec (repeat dim \\ )))))\n          (start-pos-x [size]\n            (let [base (int (Math/sqrt size))\n                  even-base (square (if (odd? base) (inc base) base))]\n              (- (int (Math/sqrt even-base)) 2)))\n          (start-pos [size]\n            (let [x (start-pos-x size)\n                  y (int (/ (shape-dim size) 2))]\n              [x y]))\n          (next-pos [[x y] [move-x move-y]]\n            [(+ x move-x) (+ y move-y)])\n          (can-turn? [pos move shape]\n            (= \\space (get-in shape (next-pos pos move))))\n          (next-turn [current-direction]\n            (condp = current-direction\n              [ 1  1] [ 1 -1]\n              [ 1 -1] [-1 -1]\n              [-1 -1] [-1  1]\n              [-1  1] [ 1  1]\n              [ 0  0] [ 1  1]))\n          (place [{:keys [shape pos forward turn]} elem]\n            (if (can-turn? pos turn shape)\n              (let [pos-after-move (next-pos pos turn)]\n                {:shape (assoc-in shape pos-after-move elem)\n                 :pos  pos-after-move\n                 :forward turn\n                 :turn (next-turn turn)})\n              (let [pos-after-move (next-pos pos forward)]\n                {:shape (assoc-in shape pos-after-move elem)\n                 :pos  pos-after-move\n                 :forward forward\n                 :turn turn})))]\n    (let [elems (pad (digits (squares start end)))\n          init-shape (empty-shape (shape-dim (count elems)))\n          init-pos (start-pos (count elems))\n          init-state {:shape init-shape :pos init-pos :forward [0 0] :turn [0 0]}\n          final-state (reduce place init-state elems)\n          final-shape (:shape final-state)\n          vector-of-strings (mapv #(apply str %) final-shape)]\n      vector-of-strings)))","user":"5344fe13e4b084c2834f4a32"},{"problem":138,"code":"(fn [start end]\n  (let [s (->> (iterate #(* % %) start) (take-while #(<= % end)) (mapcat str))\n        d (int (Math/ceil (Math/sqrt (count s))))\n        xs (concat s (repeat (- (* d d) (count s)) \\*))\n        cp [(if (even? d) (- d 2) (dec d)) (dec d)]\n        dr (mapcat #(repeat (* % 2) (if (even? %) -1 1)) (range))\n        dc (mapcat #(repeat (inc (* % 2)) (if (even? %) 1 -1)) (range))\n        dp (map #(vector %1 %2) dr dc)\n        pp (reductions #(vector (+ (first %1) (first %2)) (+ (last %1) (last %2))) cp dp)\n        len (dec (* 2 d))\n        eb (vec (repeat len (vec (repeat len \\ ))))\n        cal (fn [b xs pp]\n              (if xs\n                (recur (assoc-in b (first pp) (first xs)) (next xs) (next pp))\n                b))\n        ]\n    (mapv #(apply str %) (cal eb xs pp))))","user":"5392bfdee4b0b51d73faaeb2"},{"problem":138,"code":"(fn [start end]\n    (let [squares-string (fn [start end]\n                             (iterate #(let [square (* % %)]\n                                            (if (<= square end)\n                                                square))\n                                      start))\n          squares-digits (apply str (take-while #(not (nil? %)) (squares-string start end)))\n          side-length (int (Math/ceil (Math/sqrt (count squares-digits))))\n          start-row (quot (dec side-length) 2)\n          start-pos [start-row start-row]\n          start-square (assoc-in (vec (repeat side-length (vec (repeat side-length nil))))\n                                  start-pos\n                                  (first squares-digits))\n          rightward (fn [row col steps] [row (+ col steps)])\n          downward (fn [row col steps] [(+ row steps) col])\n          leftward (fn [row col steps] [row (- col steps)])\n          upward (fn [row col steps] [(- row steps) col])\n          draw (fn [spiral-square direction [row col] steps digits-index]\n            (reduce #(assoc-in %\n                              (direction row col (inc %2))\n                              (get squares-digits (+ digits-index %2) \\*))\n                    spiral-square\n                    (range steps)))\n          square-result (reduce\n\t\t\t\t\t\t(fn [[result pos digits-index] steps]\n\t\t\t\t\t\t\t(if (odd? steps)\n\t\t\t\t\t\t\t\t[(-> result\n\t\t\t\t\t\t\t\t\t\t\t(draw rightward pos steps digits-index)\n\t\t\t\t\t\t\t\t\t\t\t(draw downward (update-in pos [1] (partial + steps)) steps (+ steps digits-index)))\n\t\t\t\t\t\t\t\t [(+ steps (first pos)) (+ steps (second pos))]\n\t\t\t\t\t\t\t\t (+ (* 2 steps) digits-index)]\n\t\t\t\t\t\t\t\t[(-> result\n\t\t\t\t\t\t\t\t\t\t\t(draw leftward pos steps digits-index)\n\t\t\t\t\t\t\t\t\t\t\t(draw upward (update-in pos [1] (partial - steps)) steps (+ steps digits-index)))\n\t\t\t\t\t\t\t\t [(- steps (first pos)) (- steps (second pos))]\n\t\t\t\t\t\t\t\t (+ (* 2 steps) digits-index)]))\n\t\t\t\t\t\t[start-square start-pos 1]\n\t\t\t\t\t\t(range 1 side-length))\n\t\t\t\t\tsquare-result-2 (draw (first square-result) (if (odd? side-length) rightward leftward) (second square-result) (dec side-length) (last square-result))\n\t\t\t\t\tdiamond-row (fn [square row]\n\t\t\t\t\t\t(reduce #(conj % (get-in square [(- row %2) %2])) [] (range (inc row))))\n\t\t\t\t\tdiamond-bottom-row (fn [square square-width row]\n\t\t\t\t\t\t(reduce #(conj % (get-in square [(- (dec square-width) %2) (+ row %2)])) [] (range (- side-length row))))\n\t\t\t\t\tdiamond-top-half (fn [square square-width]\n\t\t\t\t\t\t(reduce (fn [diamond row]\n\t\t\t\t\t\t\t(conj diamond (diamond-row square row)))\n\t\t\t\t\t\t\t[]\n\t\t\t\t\t\t\t(range square-width)))\n\t\t\t\t\tdiamond-bottom-half (fn [square square-width]\n\t\t\t\t\t\t(reduce (fn [diamond row]\n\t\t\t\t\t\t\t(conj diamond (diamond-bottom-row square square-width row)))\n\t\t\t\t\t\t\t[]\n\t\t\t\t\t\t\t(range 1 square-width)))\n\t\t\t\t\tspaces (fn [num]\n\t\t\t\t\t\t(apply str (repeat num \\space)))\n\t\t\t\t\tcenter (fn [coll width]\n\t\t\t\t\t\t(let [pre-spacing (spaces (/ (- width (dec (* 2 (count coll)))) 2))]\n\t\t\t\t\t\t\t(str pre-spacing (apply str (interpose \\space coll)) pre-spacing)))\n          ]\n\t\t\t\t(mapv #(center % (dec (* 2 side-length))) (vec\n\t\t\t\t\t(concat\n\t\t\t\t\t\t(diamond-top-half square-result-2 side-length)\n\t\t\t\t\t\t(diamond-bottom-half square-result-2 side-length)))\n        )))","user":"55ccdc6be4b0e31453f64a18"},{"code":"(fn [a b]\r\n(let [pats { 1 [0] 2 [1 5 7 3] 3 [12 18 22 16 10 6 2 8 14]\r\n            4 [17 25 31 23 15 9 3 11 19 27 33 39 45 37 29 21]}\r\n      sqs (take-while (fn [x] (<= x b)) (iterate (fn [x] (* x x)) a))\r\n      sqs (apply str sqs)\r\n      sqlen (int (Math/ceil (Math/sqrt (count sqs))))\r\n      padstr (repeat (- (* sqlen sqlen) (count sqs)) \\*)\r\n      sqs (str sqs (apply str padstr))\r\n      sqmap (zipmap (pats sqlen) sqs)\r\n      fullsize (+ (dec sqlen) sqlen)\r\n      newstr (map (fn [i] (sqmap i \\space)) (range (* fullsize fullsize)))]\r\n      (map (partial apply str) (partition fullsize newstr))))","problem":138,"user":"4daa374930acd6ed13482a68"},{"code":"(fn squared [start end]\r\n    (let [digits (apply str (take-while #(<= % end) (iterate #(* % %) start)))\r\n          board (loop [sqsize 1 \r\n                              dlen (count digits)\r\n                              chars (concat digits (repeat \\*))\r\n                              acc {}]\r\n                         (if (<= dlen 0)\r\n                           acc\r\n                           (let [len (- (* 2 sqsize) 1)\r\n                                 coords (if (even? sqsize)\r\n                                          (map #(vector %1 %2) (range (- sqsize 1) (- 0 sqsize) -1) (concat (range -1 (- 0 sqsize) -1) (range (- 0 sqsize) 0 1))) \r\n                                          (map #(vector %1 %2) (range (- 1 sqsize) (+ 0 sqsize) 1) (concat (range 0 (+ sqsize 0) 1) (range (+ -2 sqsize) -1 -1))) \r\n                                          )]\r\n                             (do (println coords) \r\n                               (recur \r\n                                 (inc sqsize) \r\n                                 (- dlen len)\r\n                                 (drop len chars)\r\n                                 (into acc (map #(vector %1 %2) coords (take len chars))))\r\n                               )\r\n                             )))\r\n          startx (apply min (map #((%1 0) 0) board))\r\n          endx (apply max (map #((%1 0) 0) board))\r\n          starty (apply max (map #((%1 0) 1) board))\r\n          endy (apply min (map #((%1 0) 1) board))\r\n          ]\r\n      (map \r\n        (fn [y] (apply str (map (fn [x] (board [x y] \\space)) (range startx (inc endx))))) \r\n        (range starty (dec endy) -1))\r\n      ))","problem":138,"user":"4feada56e4b0140c20fb9c11"},{"problem":138,"code":"(fn [s e]\n  (letfn [\n          (pad [s]\n                (let [reqd-len (Math/pow (Math/ceil (Math/sqrt (count s))) 2)\n                      pad-len (- reqd-len (count s))]\n                  (apply str s (repeat pad-len \\*))\n                  )\n                )\n\n          (sqrs [s, e]\n                (apply str (take-while #(<= % e) (iterate #(* %1 %1) s)))\n                )\n\n          (positions [d]\n                (let [n (dec (* 2 d))\n                      i [(inc n) (dec n) (- (inc n)) (- (dec n))]\n                      c (int (/ (* n n) 2))\n                      f (if (odd? d) c (- c n))\n                      m (mapcat #(repeat 2 %) (range 1 (inc d)))\n                      p (mapcat #(repeat %1 %2) m (cycle i))]\n                  (take (* d d) (reduce #(conj %1 (+ %2 (last %1))) [f] p)))\n                )\n          ]\n  (let [s (pad (sqrs s e))\n        d (int (Math/sqrt (count s)))\n        n (dec (* 2 d))\n        i (positions d)]\n    (map #(apply str %)\n         (partition n (reduce #(assoc-in %1 [(first %2)] (last %2))\n                              (vec (apply str (repeat (* n n) \\space)))\n                              (map vector i s))))\n    )))","user":"52593207e4b0cb4875a45cd3"},{"problem":138,"code":"(fn [s e]\n  (let [series (take-while #(<= % e) (iterate #(* % %) s))\n        chars (apply list (apply str (map str series)))\n        n (-> (count chars) Math/sqrt Math/ceil int)\n        chars* (concat chars (repeat (- (* n n) (count chars)) \\*))\n        m (+ n n -1)\n        grid (loop [grid (vec (repeat m (vec (repeat m \\space))))\n                    cursor [(* (quot (dec n) 2) 2) (dec n)]\n                    ds (mapcat (fn [c v] (repeat c v))\n                               (mapcat (fn [i] [i i]) (map inc (range)))\n                               (cycle [[1 1] [1 -1] [-1 -1] [-1 1]]))\n                    cs chars*]\n               (if (empty? cs)\n                 grid\n                 (do\n                   (recur (assoc-in grid cursor (if (empty? cs) \\* (first cs)))\n                          (mapv + cursor (first ds))\n                          (rest ds)\n                          (rest cs)))))]\n    (vec (map #(apply str %) grid))))","user":"5db92996e4b010eb3c36cd50"},{"problem":138,"code":"(fn [start end]\r\n  (letfn [(sq [x] (* x x))\r\n          (squares [s e] (clojure.string/join \"\" (take-while (partial >= e)\r\n                                                             (iterate sq s))))\r\n          (pad-to-sq [s] (let [l (count s)\r\n                               root (-> l Math/sqrt int)\r\n                               sz (if (= l (sq root))\r\n                                    root\r\n                                    (inc root))\r\n                               pad (- (sq sz) l)]\r\n                           (str s (apply str (repeat pad \\*)))))\r\n          (c-add [& c] (vector\r\n                        (apply + (map first c))\r\n                        (apply + (map second c))))\r\n          (c-gen [c]\r\n            (let [f [[1 1] [-1 1] [-1 -1] [1 -1]]\r\n                  cs (mapcat #(repeat %2 %1)\r\n                             (cycle f)\r\n                             (mapcat (partial repeat 2) (drop 1 (range))))]\r\n              (reductions #(c-add %1 %2) c cs)))]\r\n    (let [target (pad-to-sq (squares start end))\r\n          coords (take (count target) (c-gen [0 0]))\r\n          [xmin xmax] (apply (juxt min max) (map first coords))\r\n          [ymin ymax] (apply (juxt min max) (map second coords))\r\n          mappings (zipmap coords (seq target))]\r\n      (apply vector (for [y (range ymin (inc ymax))]\r\n                      (apply str (for [x (range xmin (inc xmax))]\r\n                                   (get mappings [x y] \\ ))))))))","user":"53c649d3e4b00fb29b221297"},{"code":"(fn [start end]\n  (let [coll (->> (iterate #(* % %) start)\n                  (take-while #(<= % end))\n                  clojure.string/join)\n        [edge lim] (first (drop-while\n                           #(< (second %) (count coll))\n                           (map #(vector %1 (* %2 %2))\n                                (iterate #(+ % 2) 1)\n                                (iterate inc 1))))\n        chs (concat coll (repeat (- lim (count coll)) \\*))\n        updates (mapcat repeat\n                        (mapcat (partial repeat 2) (iterate inc 1))\n                        (cycle [(fn [[x y]] [(+ x 1) (+ y 1)])\n                                (fn [[x y]] [(- x 1) (+ y 1)])\n                                (fn [[x y]] [(- x 1) (- y 1)])\n                                (fn [[x y]] [(+ x 1) (- y 1)])]))\n        startx (quot edge 2)\n        starty (- (quot edge 2) (if (even? (count chs)) 1 0))\n        tbl (loop [rst chs, [x y] [startx starty], u updates, acc {}]\n              (if (empty? rst)\n                acc\n                (recur (rest rst)\n                       ((first u) [x y])\n                       (rest u)\n                       (assoc acc [x y] (first rst)))))]\n    (for [y (range edge)]\n      (clojure.string/join\n       (for [x (range edge)]\n         (or (tbl [x y]) \\space))))))","problem":138,"user":"504f57c7e4b0a02f9cffde71"},{"problem":138,"code":"(fn render-square [s t]\n  (let [digits (->> s (iterate #(* % %)) (take-while #(<= % t)) (apply str))\n        coors (fn coors [size] (cond\n                                 (= size 1) (seq [[0 0]])\n                                 (odd? size) (concat (map (comp vec (partial map + [1 1])) (coors (dec size)))\n                                                     (for [i (range size 0 -1)] [(dec i) 0])\n                                                     (for [i (range 1 size)] [0 i]))\n                                 :else (concat (coors (dec size))\n                                               (for [i (range size)] [i (dec size)])\n                                               (for [i (range size 1 -1)] [(dec size) (- i 2)]))))\n        c-orders #(->> % coors (map-indexed (comp vec reverse vector)) (into {}))\n        rotated #(let [c-orders (c-orders %)\n                       get-dgt (fn [coor] (get digits (get c-orders coor) \\*))]\n                   (concat\n                    (for [i (range %)] (for [j (range (inc i))] (get-dgt [(- i j) j])))\n                    (for [i (range % (+ % (dec %)))] (for [j (range (- i % -1) %)] (get-dgt [(- i j) j])))))\n        [bd] (for [i (range) :let [size (* i i)] :when (>= size (count digits))] i)\n        space #(apply str (repeat (Math/abs (- bd % 1)) \" \"))]\n    (->> (rotated bd) (map #(clojure.string/join \" \" %)) (map-indexed #(str (space %) %2 (space %))))))","user":"5953bdb6e4b066ee0a44aeed"},{"problem":138,"code":"(fn [s e]\n   (let [a (vec (apply str \n                  ((fn f [s e] \n                     (if (> s e) '()                             \n                         (cons s (f (* s s) e))))\n                   s e)))\n         n (first (filter #(>= (* % %) (count a)) [1 2 3 4]))\n         w (fn [i] \n             (mapv #(if (< n 3) (dec %) %)\n              ([[1 1] [1 2] [2 2] [2 1] [2 0] [1 0] [0 0] [0 1] \n                [0 2] [0 3] [1 3] [2 3] [3 3] [3 2] [3 1] [3 0]]\n               i)))\n         z (+ n n -1)\n         B (vec (map vec (partition z (repeat (* z z) \\ ))))\n         r (fn [[i j]] [(+ i j) (+ n -1 (- i) j)])\n        ]\n     (->> (range 0 (* n n))\n          (map #(vector (get a % \\*) (r (w %))))\n          (reduce (fn [a [c x]] (update-in a x #(and % c))) B)\n          (map (partial apply str)))))","user":"559c13c5e4b066d22e731f61"},{"problem":138,"code":"(fn [start end]\n    (letfn [(fetch-nums\n              ([sqn] (fetch-nums (* sqn sqn) (str start)))\n              ([sqn nums]\n               (if (<= sqn end) (recur (* sqn sqn) (str nums sqn))\n                   (map str (str nums)))))\n            (fetch-initial-data [nums]\n              (let [nlen (count nums)\n                    nsize (int (Math/ceil (Math/sqrt nlen)))\n                    fnums (concat nums (repeat (- (* nsize nsize) nlen) \"*\"))\n                    size (+ nsize (dec nsize))\n                    sqarray (make-array String size size)]\n                (vector sqarray (vec fnums) nsize size)))\n            (lay-foundation [[sqarray fnums nsize size]]\n              (let [h [(if (odd? nsize) (dec nsize) (- nsize 2))\n                       (quot (dec size) 2)]\n                    pile [h [(inc (h 0)) (inc (h 1))]\n                          [(+ (h 0) 2) (h 1)] [(inc (h 0)) (dec (h 1))]]]\n                (doseq [i (range (if (= nsize 1) 1 4))]\n                  (aset sqarray ((pile i) 0) ((pile i) 1) (fnums i)))\n                (vector sqarray (subvec fnums (if (= nsize 1) 1 4)) h)))\n            (snake [[sqarray fnums h]]\n              (loop [n fnums\n                     s [(h 0) (- (h 1) 2)]\n                     dir :UR]\n                (if (empty? n) sqarray\n                    (do\n                      (aset sqarray (s 0) (s 1) (first n))\n                      (cond\n                        (= dir :UR) (if (nil? (aget sqarray (inc (s 0)) (inc (s 1))))\n                                      (recur (rest n) [(inc (s 0)) (inc (s 1))] :DR)\n                                      (recur (rest n) [(dec (s 0)) (inc (s 1))] :UR))\n                        (= dir :DR) (if (nil? (aget sqarray (inc (s 0)) (dec (s 1))))\n                                      (recur (rest n) [(inc (s 0)) (dec (s 1))] :DL)\n                                      (recur (rest n) [(inc (s 0)) (inc (s 1))] :DR))\n                        (= dir :DL) (if (nil? (aget sqarray (dec (s 0)) (dec (s 1))))\n                                      (recur (rest n) [(dec (s 0)) (dec (s 1))] :UL)\n                                      (recur (rest n) [(inc (s 0)) (dec (s 1))] :DL))\n                        (= dir :UL) (if (nil? (aget sqarray (dec (s 0)) (inc (s 1))))\n                                      (recur (rest n) [(dec (s 0)) (inc (s 1))] :UR)\n                                      (recur (rest n) [(dec (s 0)) (dec (s 1))] :UL)))))))\n            (output [sqarray]\n              (vec (for [row sqarray]\n                     (reduce (fn [acc e]\n                               (str acc (if (nil? e) \" \" e)))\n                             \"\" row))))]\n      (-> start\n          fetch-nums\n          fetch-initial-data\n          lay-foundation\n          snake\n          output)))","user":"5d68f007e4b0db5d338d1604"},{"problem":138,"code":"(fn [s e]\n  (letfn [(flip [rs]\n            (vec (reverse (map #(vec (reverse %)) rs))))\n          (layer+ [square ds]\n            (if (empty? ds)\n              square\n              (let [n (count square)\n                    [side remain] (split-at n ds)\n                    square' (map #(concat %1 [%2]) square ds)\n                    [bottom remain'] (split-at (inc n) remain)\n                    square'' (concat square' [(reverse bottom)])]\n                (layer+ (flip square'') remain'))))\n          (romb [n]\n            (let [row (map #(vector (- %) %) (range n))]\n              (map\n               #(filter\n                 (fn [[i j]] (and (< -1 i n) (< -1 j n)))\n                 (map (fn [[i j]] [(+ i %) j]) row))\n               (range (+ n n -1)))))\n          (padding [width line]\n            (let [extra (/ (- width (count line)) 2)]\n              (concat (repeat extra \\space)\n                      line\n                      (repeat extra \\space))))]\n    (let [digits (mapcat str (take-while #(<= % e) (iterate #(* % %) s)))\n          dn (count digits)\n          side (first (drop-while #(< (* % %) dn) (range)))\n          fill (repeat (- (* side side) dn) \\*)\n          [x & xs] (vec (concat digits fill))\n          square (layer+ [[x]] xs)\n          square' (if (even? (count square)) (flip square) square)\n          rij (romb side)\n          rcs (map #(map (fn [ij] (get-in square' ij)) %) rij)\n          rcs' (map #(interpose \\space %) rcs)\n          width (dec (* side 2))\n          rcs'' (map #(padding width %) rcs')]\n      (map #(apply str %) rcs''))))","user":"53ef7f77e4b0742d9025b0ce"},{"code":"(fn [b e]\n  (let [\n        s (loop [s b r (str b)] (let [sq (* s s)] (if (> sq e) r (recur sq (str r sq)))))\n        l (loop [n 1] (if (>= (* n n) (count s)) n (recur (inc n))))\n        cv (repeat (dec (* l 2)) (apply str (repeat (dec (* l 2)) \" \")))\n        st [(dec l) (if (even? l) (- l 2) (dec l))]\n        cs  (loop [c [1 1] cs [] x? true n 1]\n              (if (>= (count cs) (dec (* l l)))\n                (take (dec (* l l)) cs)\n                (let [nc (update-in c [(if x? 0 1)] #(* % -1))]\n                  (recur nc (concat cs (repeat (quot (inc n) 2) c)) (not x?) (inc n)))))\n        set (fn [cv co v] (assoc (vec cv) (co 1) (assoc (vec (nth cv (co 1))) (co 0) v)))\n        move (fn [c v] [(+ (c 0) (v 0)) (+ (c 1) (v 1))])]\n    (loop [cv (set cv st (first s)) c st s (rest s) cs cs]\n      (println c)\n      (if (empty? cs)\n        (map #(apply str %) cv)\n        (let [nc (move c (first cs))]\n          (recur (set cv nc (if (empty? s) \\* (first s))) nc (rest s) (rest cs)))))))","problem":138,"user":"50bce014e4b0594b91591c63"},{"problem":138,"code":"(fn squares-squared\n  [a b]\n  (let [s (apply str (take-while #(<= % b) (iterate #(* % %) a)))\n        size (first (drop-while #(< (* % %) (count s)) (range)))\n        s (str s (apply str (repeat (- (* size size) (count s)) \\*)))\n        size2 (- (* 2 size) 1)\n        matrix (into [] (repeat size2 (into [] (repeat size2 \\space))))\n        x (if (even? size) (- size 2) (dec size))\n        y (dec size)\n        matrix (assoc-in matrix [x y] (first s))\n        turn (fn [dir] (case dir\n                         :r :d\n                         :d :l\n                         :l :u\n                         :u :r))]\n    (loop [s (rest s) dir :r matrix matrix [x y] [(inc x) (inc y)] steps 1 i 1 turned? true]\n      (if (empty? s)\n        (mapv (partial apply str) matrix)\n        (let [i' (if (and (= 1 steps) turned?) (inc i) i)\n              [dir' steps' turned'] (if (= 1 steps) [(turn dir) i (not turned?)] [dir (dec steps) turned?])\n              coord' (cond\n                       (= :r dir') [(inc x) (inc y)]\n                       (= :d dir') [(inc x) (dec y)]\n                       (= :l dir') [(dec x) (dec y)]\n                       (= :u dir') [(dec x) (inc y)])\n              matrix' (assoc-in matrix [x y] (first s))\n              ]\n          (recur (rest s) dir' matrix' coord' steps' i' turned'))))))","user":"5d81b40ce4b0915913b1d379"},{"problem":138,"code":"(fn sqsq [p q]\n  (let [dirs (mapcat\n               #(repeat %2 %) (cycle [[1 1] [1 -1] [-1 -1] [-1 1]])\n               (cons 1 (mapcat #(repeat % %) (iterate inc 1))))\n        digits (apply str (take-while #(<= % q) (iterate #(* % %) p)))\n        [max-digits sq-size]\n                   (first\n                     (drop-while\n                       (fn [[d s]] (> (count digits) d))\n                       (map #(vector %1 %2)\n                            (map #(* % %) (iterate inc 2))\n                            (iterate #(+ % 2) 3))))\n        spiral ((fn [digits dirs]\n                 (let [digits-in-center (inc (quot sq-size 2))\n                       center-piece (if (zero? (rem digits-in-center 2))\n                                      (dec (quot sq-size 2))\n                                      (quot sq-size 2))\n                       first-pos [center-piece (quot sq-size 2)]]\n                   ; could have used reductions here\n                   (loop [[fdig & ndig] (next digits),\n                          [fd & nd] dirs,\n                          pos first-pos,\n                          sp {first-pos (first digits)}]\n                     (if (nil? fdig)\n                       sp\n                       (recur ndig nd (map + pos fd) (assoc sp (map + pos fd) fdig))\n                      ))))\n                  (concat digits (repeat (- max-digits (count digits)) \"*\")) dirs)]\n    (if (= 1 (count digits))\n      [digits]\n      (into []\n        (for [y (range 0 sq-size)]\n          (reduce str\n             (for [x (range 0 sq-size)]\n               (get spiral [y x] \\space))))))))","user":"5bbdd136e4b07a9b28b0ffab"},{"problem":138,"code":"(fn [s e]\n    (letfn\n      [\n       (gen-pows [start end]\n                 (if (> start end)\n                   '()\n                   (lazy-seq\n                    (conj\n                     (gen-pows (* start start) end)\n                     start\n                     ))\n                   ))\n\n       (gen-pows [start end]\n                 (if (> start end)\n                   '()\n                   (lazy-seq\n                    (conj\n                     (gen-pows (* start start) end)\n                     start\n                     ))\n                   ))\n       (pows-to-str [pows]\n                    (apply str\n                           (map str pows))\n                    )\n       (count-a [strpows]\n                (first\n                 (drop-while\n                  #(> (count strpows) (* %1 %1))\n                  (range))\n                 ))   \n       (fill-star [strpows a]\n                  (str\n                   strpows\n                   (apply str\n                          (repeat \n                           (- (* a a) (count strpows))\n                           \"*\"))))  \n       (gen-nums [strpows2]\n                 (let [strpows (map str strpows2)]\n                   (loop [up (list (first strpows))\n                          down '()\n                          dir :down\n                          pws (rest strpows)\n                          ]\n                     (if (empty? pws)\n                       (concat (reverse up) down)\n                       (if (= dir :down)\n                         (if (empty? down)\n                           (recur \n                            (conj up (first pws))\n                            (list (second pws))\n                            :up\n                            (drop 2 pws))\n                           (recur\n                            (conj up (str (first down) (first pws)))\n                            (rest down)\n                            :down\n                            (rest pws))\n                           )\n                         (if (empty? up)\n                           (recur\n                            (list (second pws))\n                            (conj down (first pws))\n                            :down\n                            (drop 2 pws))\n                           (recur\n                            (rest up)\n                            (conj down (str (first pws) (first up)))\n                            :up\n                            (rest pws)))\n                         )))))\n       (fill-spaces [a nums]\n                    (map\n                     (fn [spaces signs] \n                       (str \n                        spaces \n                        (apply str (interpose \" \" signs)) \n                        spaces))\n                     (map\n                      #(apply str (repeat %1 \" \"))\n                      (concat (reverse (range a)) (drop 1 (range a)))\n                      )\n                     nums\n                     ))\n       ]\n      (let\n        [p (gen-pows s e)\n         pst (pows-to-str p)\n         a (count-a pst)\n         filstr (fill-star pst a)\n         ns (gen-nums filstr)\n         ]\n        (fill-spaces a ns))\n      )\n\n    )","user":"5094057fe4b097f48cc38593"},{"code":"(fn sq-sq [lo hi]\r\n  (let \r\n    [squares (take-while #(<= % hi) (iterate #(* % %) lo))\r\n     _ (println \"squares\" squares)\r\n     sq-digits (flatten (map seq (map str squares)))\r\n     _ (println \"sq-digits\" sq-digits)\r\n     L (count sq-digits)\r\n\r\n     big-sq-size (- (* 2 (int (Math/ceil (Math/sqrt L)))) 1)\r\n     _ (println \"big-sq-size\" big-sq-size)\r\n     inner-sq-size (quot (inc big-sq-size) 2)\r\n     _ (println \"inner-sq-size\" inner-sq-size)\r\n     diag-length (* inner-sq-size inner-sq-size)\r\n     padding (- diag-length L)\r\n     \r\n     full-digits (concat sq-digits (repeat padding \\*))\r\n     _ (println \"full digits\" full-digits)\r\n\r\n     center-at (quot big-sq-size 2)\r\n     _ (println \"center at\" center-at)\r\n\r\n     start-loc (if (even? inner-sq-size)\r\n                [(dec center-at) center-at]\r\n                [center-at center-at])\r\n     _ (println \"start-loc\" start-loc)\r\n                \r\n     start-heading [-1 1]\r\n     _ (println \"start-heading\" start-heading)\r\n     turn (fn [heading]\r\n            (cond\r\n              (= heading [1 1]) [1 -1]\r\n              (= heading[1 -1]) [-1 -1]\r\n              (= heading[-1 -1]) [-1 1]\r\n              (= heading[-1 1]) [1 1]))\r\n     \r\n     next-loc (fn [[i j] [di dj]]\r\n                [(+ i di) (+ j dj)])\r\n     \r\n     empty-grid (vec (repeat big-sq-size (vec (repeat big-sq-size \\space))))\r\n     _ (println \"empty grid\" empty-grid)]\r\n     \r\n     (loop [grid empty-grid\r\n            heading start-heading\r\n            loc start-loc\r\n            remain full-digits]\r\n        (if (empty? remain)\r\n          (map #(apply str %) grid)\r\n          (let \r\n            [next-elt (first remain)\r\n             new-remain (rest remain)\r\n             new-grid (assoc-in grid loc next-elt)\r\n             _ (println \"new-grid\" new-grid)\r\n             right-heading (turn heading)\r\n             _ (println \"right heading\" right-heading)\r\n             right-loc (next-loc loc right-heading)\r\n             _ (println \"right-loc\" right-loc)\r\n             straight-loc (next-loc loc heading)\r\n             peek-right (get-in grid right-loc)\r\n             _ (println \"peek-right\" peek-right)\r\n             turn? (= \\space peek-right)\r\n             _ (println \"turn?\" turn?)\r\n             next-loc (if turn? right-loc straight-loc)\r\n             _ (println \"next-loc\" next-loc)\r\n             next-heading (if turn? right-heading heading)\r\n             _ (println \"next-heading\" next-heading)\r\n             _ (println)]\r\n             (recur new-grid next-heading next-loc new-remain))))))","problem":138,"user":"4f036fb3535dcb61093f6ac8"},{"code":"(fn [n1 n2]\r\n  (let [spiral-sides #(interleave (drop 1 (range)) (drop 1 (range)))\r\n        spiral-deltas #(mapcat (fn [[n d]] (repeat n d))\r\n                         (partition 2 (interleave (spiral-sides)\r\n                                        (cycle [[1 1] [1 -1] [-1 -1] [-1 1]]))))\r\n        move (fn [[y x] [dy dx]] [(+ y dy) (+ x dx)])\r\n        [n digits] (let [ds (vec (mapcat #(concat (str %)) (take-while #(<= % n2) (iterate #(* % %) n1))))\r\n                         cds (count ds)\r\n                         x (Math/ceil (Math/sqrt cds))]\r\n                     [(int x) (into ds (repeat (- (* x x) cds) \\*))])\r\n        square (dec (* 2 n))\r\n        pos [(* 2 (quot (dec n) 2)) (dec (- square (quot square 2)))]\r\n        spiral (apply hash-map (first\r\n                                 (reduce (fn [[res pos] [delta digit]]\r\n                                           [(conj res pos digit) (move pos delta)])\r\n                                   [[] pos]\r\n                                   (partition 2 (interleave (spiral-deltas) digits)))))]\r\n    (map #(apply str %)\r\n      (partition square\r\n        (for [y (range square) x (range square)] (spiral [y x] \\space))))))","problem":138,"user":"4f969214e4b0dcca54ed6cdd"},{"problem":138,"code":"(fn [start end]\n  (let [half-seq (fn [start end]\n                 (->>\n                   (take-while #(<= % end) (iterate #(* % %) start))\n                   (mapcat str)\n                   (map str)))\n      full-len (fn [number]\n                 (let [x (+ 1 (int (Math/sqrt (- number 1))))]\n                   (* x x)))\n      half-sq (half-seq start end)\n      len (full-len (count half-sq))\n      b (int (Math/sqrt len))\n      a (dec (* b 2))\n      start (if (odd? b) [b b] [(dec b) b])\n      full-sq (concat half-sq (repeat (- len (count half-sq)) \"*\" ))\n      step-and-times-seq (map (fn [x y] [x y])\n                              (cycle [[1 1] [1 -1] [-1 -1] [-1 1]])\n                              (mapcat (fn [x] [x x]) (iterate inc 1)))\n      steps (mapcat (fn [[step n]] (repeat n step)) step-and-times-seq)\n      positions (take len (reductions (fn [a b] (map + a b)) start steps))\n      pos-seq (zipmap positions full-sq)\n      all (for [x (map inc (range a))\n                y (map inc (range a))]\n            (let [v (get pos-seq [x y])]\n              (if v v \" \")))]\n\n  (map #(apply str %)\n  (partition a all))\n  ))","user":"56fbf83de4b07572ad1a88da"},{"code":"(fn [from to]\n  (let [square #(* % %)\n        s1 (apply str (take-while #(<= % to) (iterate square from)))\n        cnt1 (count s1)\n        [start outer cnt2] (first\n                             (for [i (range)\n                                   :let [sq (square i)]\n                                   :when (>= sq cnt1)]\n                               [(dec i) (dec (* 2 i)) sq]))\n        s2 (apply str s1 (repeat (- cnt2 cnt1) \\*))\n        [x y] [(- start (mod start 2)) start]\n        perx (fn [n] (concat\n                       (range n)\n                       (range n (- n) -1)\n                       (range (- n) 0)))\n        pery (fn [n] (concat\n                       (range (dec n) (- n) -1)\n                       (range (- n) (inc n))))\n        coords #(take cnt2\n                  (map (partial + %2)\n                    (mapcat %1 (iterate (partial + 2) 0))))\n        xs (coords perx x)\n        ys (coords pery y)\n        vec #(apply vector (repeat outer %))\n        board (vec (vec \\space))]\n    (map\n      #(apply str %)\n      (reduce\n        (fn [board [e x y]]\n          (assoc-in board [x y] e))\n        board\n        (map #(vector %1 %2 %3) s2 xs ys)))))","problem":138,"user":"514c2d05e4b02b8cbb2a9278"},{"problem":138,"code":"(fn squares-in-a-square [base limit]\n  (let [squares (take-while (partial >= limit) (iterate #(* % %) base))\n        squares-string (apply str squares)\n        next-square (first (filter (partial <= (count squares-string)) \n                                   (map #(* % %) (range))))\n        spiral (reductions (fn [[row col] [row-dir col-dir]] \n                             [(+ row row-dir) (+ col col-dir)])\n                           [0 0]\n                           (mapcat identity \n                                   (map repeat \n                                        (mapcat (partial repeat 2) (drop 1 (range))) \n                                        (cycle [[1 1] [1 -1] [-1 -1] [-1 1]]))))\n        padded-string (apply str squares-string \n                        (repeat (- next-square (count squares-string)) \"*\"))\n        string-square-size (dec (* 2 (int (Math/sqrt next-square)))) \n        image-map (into {} (map vector spiral padded-string))\n        min-row (apply min (map first (keys image-map)))\n        max-row (apply max (map first (keys image-map)))\n        min-col (apply min (map second (keys image-map)))\n        max-col (apply max (map second (keys image-map)))\n        normalized-image-map (into {} (map (fn [[[row col] v]] \n                                             [[(- row min-row) \n                                               (- col min-col)] v]) image-map))]\n    (map (partial apply str) \n         (partition (inc (- max-col min-col))\n                    (map (fn [[row col]] (or (normalized-image-map [row col]) \" \")) \n                         (for [row (range (inc (- max-row min-row))) \n                               col (range (inc (- max-col min-col)))] \n                           [row col]))))))","user":"5c506951e4b0f9f7a8770ec5"},{"code":"(fn [s e]\n  (let [squares   (apply str (take-while #(<= % e) (iterate #(* % %) s)))\n        filler    (drop (count squares) (repeat (#(* % %) (Math/ceil (Math/sqrt (count squares)))) \\*))\n        elements  (concat squares filler)\n        dimension (int (Math/sqrt (count elements)))\n        cardinal  (- (* 2 dimension) 1)\n        canvas    (vec (repeat cardinal \"\"))\n        start-pos (* 2 (quot (dec dimension) 2))\n        path      (take (count elements) (mapcat #(repeat (+ 2 (* 2 %)) (if (odd? %) dec inc)) (range)))\n        balance   (fn [c] (#(apply str `(~@% ~@(interpose \\  c) ~@%)) (repeat (/ (- cardinal (- (* 2 (count c)) 1)) 2) \\ )))]\n    (map balance\n      ((fn [canvas row [element & rest-elts] [move & rest-path]]\n         (if (nil? element)\n           canvas\n           (recur (update-in canvas [row] #(if (= move inc) `(~@% ~element) `(~element ~@%)))\n                  (move row)\n                  rest-elts\n                  rest-path)))\n       canvas\n       start-pos\n       elements\n       path))))","problem":138,"user":"4e49badd535dc968683fc4c9"},{"code":"(fn p138 [n1 n2]\n\t(letfn [(cnsm\n  ([lst by] (letfn [(f1 [x y] [(inc x) (dec y)]) (f2 [x y] [(dec x) (dec y)]) (f3 [x y] [(dec x) (inc y)]) (f4 [x y] [(inc x) (inc y)])\n                 (repl2 [s n c]\n                   (lazy-seq (cons (+ s n) (repl2 (+ s n) (if (= c 1) (inc n) n) (if (= c 1) 0 (inc c))) )))\n                 ] (cnsm 1 lst [0 by] (lazy-seq (cycle [f4 f1 f2 f3])) (drop 1 (repl2 1 0 0)))))\n  ([idx lst p fs cs]\n     (if (empty? lst) nil\n\t(let [\n              change (= idx (first cs))\n              [ncs nfs] (if change [(next cs) (next fs)]  [cs fs])\n              np (apply (first nfs) p)]\n           (cons [p (first lst)] (cnsm (inc idx) (next lst) np nfs ncs))))))]\n      (let [nms ((fn re [nn1 nn2] (cons nn1 (if (<= (* nn1 nn1) nn2) (re (* nn1 nn1) nn2) nil)) ) n1 n2)\n            ss (apply str (map str nms))\n            rnum (fn rn ([x] (rn x 1)) ([x n] (if (<= x (* n n)) [n (apply str (replicate (- (* n n) x) \\*))] (rn x (inc n)))))\n            [hl r] (rnum (count ss))\n            srcm (cnsm (str ss r) (if (= 1 (count ss)) 1 1))\n            xs0 (map (fn [e] (ffirst e)) srcm)\n            ys0 (map (fn [e] (second (first e))) srcm)\n            ry (reverse (range (apply min ys0) (inc (apply max ys0))))\n            rx (range (apply min xs0) (inc (apply max xs0)))\n            sm (reduce conj {} srcm)\n            ]\n\t(for [y ry] (apply str (for [x rx] (sm [x y] \\space))))\n\t)))","problem":138,"user":"5272669de4b03e8d9a4a742e"},{"code":"(fn square [start stop]\n  (let [nxt {[1 1] [-1 1]\n             [-1 1] [-1 -1]\n             [-1 -1] [1 -1]\n             [1 -1] [1 1]}\n        chars (->> (iterate #(* % %) start)\n                   (take-while #(<= % stop))\n                   (apply str)\n                   (seq)\n                   (#(concat % (repeat \\*))))\n        pos  (loop [pos [0 0]\n                    dir [1 1]\n                    len 0\n                    left 0\n                    cnt 2\n                    have {}\n                    chars chars]\n      (println pos left cnt (first chars))\n      (if (and (= (dec len) left) (odd? cnt) (= (first chars) \\*))\n        have\n        (recur\n          (vec (map + dir pos))\n          (if (zero? left) (nxt dir) dir)\n          (if (and (zero? left) (even? cnt)) (inc len) len)\n          (if (zero? left) len (dec left))\n          (if (zero? left) (inc cnt) cnt)\n          (assoc have (vec (reverse pos)) (first chars))\n          (rest chars)\n          )))\n       find-extr (fn [f-e f-p] (reduce f-e (map f-p (keys pos))))\n       size-fn (fn [f] (- (find-extr max f) (find-extr min f)))\n\n       size (inc (max (size-fn first) (size-fn second)))\n       table (vec (repeat size (vec (repeat size \" \"))))\n       normalize (fn [which points]\n                    (let [mn (- (reduce min (map #(% which) (keys points))))]\n                      (->> (map (fn [[point value]] [(update-in point [which] + mn) value]) points)\n                           (into {}))))\n                   ]\n  (println pos)\n  (->> (normalize 0 pos)\n       (normalize 1)\n       (reduce (fn [table [point value]] (assoc-in table point value)) table)\n       (map #(apply str %)))\n    ))","problem":138,"user":"4f465096e4b0d56e7bb92b9a"},{"code":"(fn [st ed]\n  (let [sqrs (take-while #(<= % ed) (iterate #(* % %) st))\n        strs (apply str sqrs)\n        len (first (filter #(>= % (count strs)) (map #(* % %) (range))))\n        strs (apply str strs (repeat (- len (count strs)) \\*))\n        squares (loop [len 0 s strs sh []]\n                  (if (empty? s) sh\n                    (let [a (vec (subs s 0 len)) b (vec (subs s len (+ len len 1)))]\n                      (recur (inc len) (subs s (+ len len 1))\n                        (if (even? len)\n                          (into [b] (mapv into (mapv vector (reverse a)) sh))\n                          (conj (mapv conj sh a) (vec (reverse b))))))))\n        rotated (let [n (count (squares 0))\n                      len (dec (* 2 n))\n                      fill-space (fn [s]\n                                   (let [m (quot (- len (count s)) 2)]\n                                     (concat (repeat m \\space) s (repeat m \\space))))]\n                  (for [s (range len)]\n                    (let [diag (for [x (range (dec n) -1 -1)\n                                     :let [y (- s x)]\n                                     :when (and (<= 0 y) (< y n))]\n                                 ((squares x) y))]\n                      (fill-space (interpose \\space diag)))))]\n    (map (partial apply str) rotated)))","problem":138,"user":"527cd633e4b0757a1b17136f"},{"problem":138,"code":"(fn [start end]\n  (let [cs (->> (iterate #(* % %) start)\n                (take-while #(<= % end))\n                (apply str))\n        sq-width (int (Math/ceil (Math/sqrt (count cs))))\n        sq-area (* sq-width sq-width)\n        str-width (dec (* 2 sq-width))\n        str-rows (vec (repeat str-width\n                              (vec (repeat str-width \" \"))))\n        deltas (for [i (range)\n                     d (->> ([[1 1] [-1 1] [-1 -1] [1 -1]] (mod i 4))\n                            (repeat (Math/ceil (/ (inc i) 2))))]\n                 d)]\n    (loop [str-rows str-rows\n           cs (take sq-area (concat cs (repeat \"*\")))\n           x (quot str-width 2)\n           y (if (odd? sq-width) x (dec x))\n           deltas deltas]\n      (if (empty? cs)\n        (mapv #(apply str %) str-rows)\n        (let [[c & cs] cs\n              [[dx dy] & deltas] deltas]\n          (recur (assoc-in str-rows [y x] c)\n                 cs\n                 (+ x dx)\n                 (+ y dy)\n                 deltas))))))","user":"583e27e2e4b089d5ab817daa"},{"code":"(fn [from to]\n  (let [s (apply str (take-while (partial >= to) (iterate #(* % %) from)))\n        m (nth\n           (iterate\n            (fn [v]\n              (let [level (/ (inc (count v)) 2)\n                    from (* level level)\n                    to (* (inc level) (inc level))\n                    middle (quot (+ from to) 2)]\n                (if (odd? level)\n                  `[~@(map-indexed (fn [i e] (if (< i level) e `[~(+ middle (- (* 2 level) i)) ~@e ~(- middle (- (* 2 level) i))])) `[~@v []]) ~[middle]]\n                  `[~[middle] ~@(map-indexed (fn [i e] (if (< i level) `[~(- middle i 1) ~@e ~(+ middle i 1)] e)) `[[] ~@v])])))\n            [[0]])\n           (dec (Math/ceil (Math/sqrt (count s)))))\n        v (map (partial map #(if (< % (count s)) (nth s %) \\*)) m)\n        h (quot (count m) 2)]\n    (map-indexed\n     (fn [i e]\n       (let [fix (apply str (map (constantly \\space) (range (Math/abs (- i h)))))]\n         (format \"%s%s%s\" fix (clojure.string/join \" \" e) fix)))\n     (map (partial map #(if (< % (count s)) (nth s %) \\*)) m))))","problem":138,"user":"4f9fe2b9e4b0dcca54ed6d40"},{"code":"(fn sqr-seq [a b]\n  (let [d [[1 1] [1 -1] [-1 -1] [-1 1]]\n       idx (->> (interleave (drop 1 (range)) (drop 1 (range))) (interleave (apply concat (repeat d)))\n             (partition 2) (mapcat #(repeat (last %) (first %))) (reductions (partial map +) [0 0]))\n       s0 (->> (iterate #(* % %) a) (take-while #(<= % b)) (mapcat str))\n       n (first (drop-while #(< (* % %) (count s0)) (range)))\n       n2 (* n n)\n       s (concat s0 (repeat (- n2 (count s0)) \\*))\n       is (take n2 idx)\n       ia (reduce (partial map min) [0 0] is)\n       ib (reduce (partial map max) [0 0] is)\n       x0 (map #(* % -1) ia)\n       d (map - ib ia [-1 -1])\n       v0 (vec (repeat (first d) (vec (repeat (second d) \\space))))\n       ]\n    (->> (partition 2 (interleave is s)) (reduce #(assoc-in %1 (vec (map + x0 (first %2))) (second %2)) v0)\n      (map (partial apply str))\n    )))","problem":138,"user":"528e64b7e4b0239c8a67aedd"},{"problem":138,"code":"(fn puzzle-138-full [a b]\n  (letfn [\n          (digits [n]\n                  (loop [n n\n                         d ()]\n                    (if (zero? n) d\n                      (let [d0 (mod n 10)]\n                        (recur (/ (- n d0) 10) (cons d0 d))))))\n          (full-squares \n            ([a]\n              (drop-while #(< % a) \n                          (map #(* % %) \n                               (range))))\n            ([a b]\n              (take-while #(<= % b) (full-squares a))))\n          (squares [a b]\n            (take-while #(<= % b) (iterate #(* % %) a)))\n          (spiral [n]\n                  (let [nn (* n n)\n                        nn-prev (* (dec n) (dec n))]\n                    (cond \n                      (zero? n) [[]]\n                      (= 1 n) [[1]]\n                      (even? n) (conj (vec (map-indexed #(conj %2 (+ nn-prev % 1)) (spiral (dec n))))\n                                      (vec (reverse (range (+ nn-prev n) (inc nn)))))\n                      :else (vec\n                              (cons (vec (range (- nn n -1) (inc nn)))\n                                    (map-indexed #(vec (cons (+ nn-prev (- %) n -1)  %2)) \n                                                 (spiral (dec n))))))))\n          (my-spiral [s]\n                     (let [sp (spiral (int (Math/sqrt (count s))))]\n                       (mapv (fn [row] (mapv #(nth s (dec %)) row)) sp)))\n          (rotate-spiral-45 [sp]\n                            (let [cm (count sp)]\n                              (concat\n                                (for [i (range cm)]\n                                  (for [c (range (inc i)) :let [r (- i c)]]\n                                    (nth (nth sp r) c)))\n                                (for [i (range cm (dec (* cm 2)))]\n                                  (for [c (range (- i cm -1) cm) :let [r (- i c)]]\n                                    (nth (nth sp r) c))))))\n          (format-rotated-spiral [sp]\n                                 (let [ss (map (partial interpose \\space) sp)\n                                       ml (max (count ss))]\n                                   (mapv #(let [shift (/ (- ml (count %)) 2)\n                                                sh-str (repeat shift \\space)]\n                                            (apply str (concat sh-str % sh-str)))\n                                         ss)))]\n    (let [digits-seq (mapcat digits (squares a b))\n          digits-seq-count (count digits-seq)\n          char-seq (concat digits-seq \n                           (repeat (- (first (full-squares digits-seq-count)) digits-seq-count) \\*))]\n      (format-rotated-spiral (rotate-spiral-45 (my-spiral char-seq))))))","user":"53286f84e4b09d4e7a9b5505"},{"code":"(fn\n  [a b]\n  (let [s (apply str ((fn f [n] (lazy-seq (cons n (let [m (* n n)] (when (<= m b) (f m)))))) a))\n        l (count s)\n        L (->> (range) (filter odd?) (reductions +) (some #(when (>= % l) %)))\n        S (apply str s (repeat (- L l) \"*\"))\n        diamond-length (-> L Math/sqrt int)\n        graphic-length (-> diamond-length (* 2) dec)\n        directions (cycle [[1 1] [1 -1][-1 -1][-1 1]])\n        length-per-turn (mapcat #(vector % %) (drop 1 (range)))\n        movements (mapcat #(repeat % %2) length-per-turn directions)\n        oy (quot graphic-length 2)\n        ox (if (odd? diamond-length) oy (dec oy))\n        coordinates (reductions #(map + % %2) [ox oy] movements)\n        coordinates->char (zipmap coordinates S)\n        blank-canvas (vec (repeat graphic-length (vec (repeat graphic-length \" \"))))\n        canvas (reduce-kv #(assoc-in % %2 %3) blank-canvas coordinates->char)]\n    (map #(apply str %) canvas)))","problem":138,"user":"5028cd0fe4b01614d1633ffc"},{"problem":138,"code":"(letfn [(squares [start end] (take-while #(<= % end) (iterate #(* % %) start)))\n        (next-square [n] (first (remove #(< (* % %) n) (range))))\n        (wrap [s]\n          (let [length (count s)\n                a (next-square length)\n                padded-length (* a a)\n                padded (concat s (repeat (- padded-length length) \\*))\n                side (dec (* 2 a))]\n            (case padded-length\n              1 [(apply str padded)]\n              4 [(str \" \" (nth padded 0) \" \")\n                 (str (nth padded 3) \" \" (nth padded 1))\n                 (str \" \" (nth padded 2) \" \")]\n              9 [(str \"  \" (nth padded 6) \"  \")\n                 (str \" \" (nth padded 5) \" \" (nth padded 7) \" \")\n                 (str (nth padded 4) \" \" (nth padded 0) \" \" (nth padded 8))\n                 (str \" \" (nth padded 3) \" \" (nth padded 1) \" \")\n                 (str \"  \" (nth padded 2) \"  \")]\n              16 [(str \"   \" (nth padded 6) \"   \")\n                  (str \"  \" (nth padded 5) \" \" (nth padded 7) \"  \")\n                  (str \" \" (nth padded 4) \" \" (nth padded 0) \" \" (nth padded 8) \" \")\n                  (str (nth padded 15) \" \" (nth padded 3) \" \" (nth padded 1) \" \" (nth padded 9))\n                  (str \" \" (nth padded 14) \" \" (nth padded 2) \" \" (nth padded 10) \" \")\n                  (str \"  \" (nth padded 13) \" \" (nth padded 11) \"  \")\n                  (str \"   \" (nth padded 12) \"   \")])))]\n  (fn [start end]\n    (wrap (apply str (squares start end)))))","user":"54ca9ca8e4b057c6fda3a265"},{"code":"(fn g [start end]\n  (let [succ-sqs (loop [n start sofar []]\n                   (if (> n end) sofar (recur (* n n) (conj sofar n))))\n        succ-sqs-str (apply str succ-sqs)\n        req-str-len-sqrt (first (filter #(>= (* % %) (count succ-sqs-str)) (iterate inc 1)))\n        req-str-len (* req-str-len-sqrt req-str-len-sqrt)\n        succ-sqs-str-padded (apply str succ-sqs-str\n                                   (repeat (- req-str-len (count succ-sqs-str)) \\*))\n        req-width (dec (* 2 req-str-len-sqrt))\n        midpoint (quot req-width 2)\n        deltas (mapcat (fn [x d] (repeat x d))\n                       (mapcat #(vector % %) (nthnext (range) 1))\n                       (cycle [[1 1] [1 -1] [-1 -1] [-1 1]]))\n        start-coord [(if (even? req-str-len-sqrt) (dec midpoint) midpoint) midpoint]\n        coords (reduce (fn [coords [dj di]] (conj coords [(+ dj (first (last coords)))\n                                                          (+ di (last (last coords)))]))\n                       [start-coord] (take (dec req-str-len) deltas))\n        chars-by-coord (zipmap coords succ-sqs-str-padded)]\n    (map (partial apply str) (partition req-width (for [j (range req-width)\n                                                        i (range req-width)]\n                                                    (get chars-by-coord [j i] \\space))))))","problem":138,"user":"510acd6ee4b078ea719210f4"},{"code":"(fn [start end]\n  (letfn [(successive-squares [start]\n            (iterate #(* % %) start))\n\n          (successive-squares-range [start end]\n            (take-while (partial >= end) (successive-squares start)))\n\n          (int->charlist\n            ([v] (int->charlist v '()))\n            ([v acc]\n             (let [v' (quot v 10)\n                   d  (rem v 10)\n                   acc' (cons d acc)]\n               (if (zero? v') acc' (recur v' acc')))))\n\n          (successive-char-range [start end]\n            (mapcat int->charlist (successive-squares-range start end)))\n\n          (cut-offs []\n            (for [x (rest (range))] (* x x)))\n\n          (cut-off-for-range [rng]\n            (let [len (count rng)]\n              (some #(when (<= len %) %) (cut-offs))))\n\n          (sizes \n            ([] (cons 1 (lazy-seq(sizes 1 1))))\n            ([step] (cons step (lazy-seq (sizes step step))))\n            ([step step] (cons step (lazy-seq (sizes (inc step))))))\n\n          (dirs\n            ([] (dirs 0))\n            ([step] \n             (let [d [{:x + :y -}{:x - :y -}{:x - :y +}{:x + :y +}]]\n               (cons (d (rem step (count d))) (lazy-seq (dirs (inc step)))))))\n\n          (build-rhombus \n            ([rng] (build-rhombus rng (sizes) (dirs) (cut-off-for-range rng) 0 0 {} {}))\n            ([rng sizes dirs cut-off-at x y edge-acc acc] \n             (let [digit        (or (first rng) \\*)\n                   edge-acc'    (conj edge-acc {{:x x :y y} digit})\n                   edge-len'    (count edge-acc')\n                   edge-len-max (first sizes)\n                   acc-len      (count acc)\n                   total-len    (+ acc-len edge-len')\n                   stop         (and (empty? (rest rng)) (= total-len cut-off-at))\n                   new-edge     (= edge-len' edge-len-max)\n                   dir          (first dirs)\n                   x'           ((:x dir) x 1)\n                   y'           ((:y dir) y 1)]\n               (cond\n                 ; stop\n                 stop (into acc edge-acc')\n                 ; new edge\n                 new-edge (recur (rest rng) (rest sizes) (rest dirs) cut-off-at x' y' [] (into acc edge-acc'))\n                 ; same edge\n                :else     (recur (rest rng) sizes dirs cut-off-at x' y' edge-acc' acc)))))\n\n          (project-rhombus [rhombus]\n            (let [xs (map (comp :x key) rhombus)\n                  ys (map (comp :y key) rhombus)\n                  min-x (apply min xs)\n                  max-x (apply max xs)\n                  min-y (apply min ys)\n                  max-y (apply max ys)\n                size  (inc (- max-x min-x))]\n              (map \n                (partial apply str)\n                (partition \n                  size\n                  (for [y (range max-y (dec min-y) -1) x (range min-x (inc max-x) 1)] (or (rhombus {:x x :y y}) \\space))))))]\n\n    (project-rhombus (build-rhombus (successive-char-range start end)))))","problem":138,"user":"5245fbbbe4b09dbe66b56183"},{"code":"(letfn [(square-seq [begin end]\n          (if (> begin end)\n            '()\n            (cons begin (square-seq (* begin begin) end))))\n        (min-square [seq-size]\n          (-> seq-size Math/sqrt Math/ceil (Math/pow 2) int))\n        (nums->digits [nums]\n          (apply concat (map str nums)))\n        (pad [s]\n          (let [l (count s)]\n            (concat s (repeat (- (min-square l) l) \\*))))\n        (rot180 [cols]\n          (mapv (comp vec reverse) (reverse cols)))\n        (rot90 [x]\n          (prn x)\n          (apply mapv (fn [& cs] (apply str (reverse cs))) x))\n        (unpadded-square [digits]\n          (loop [upright true\n                 cols [[(first digits)]]\n                 digits (rest digits)]\n            (if (empty? digits)\n              (if upright cols (rot180 cols))\n              (let [cols (concat [[(first digits)]]\n                                 (map conj cols (rest digits))\n                                 [[(nth digits (inc (count cols)))]])\n                    digits (drop (count cols) digits)]\n                (recur (not upright) (rot180 cols) digits)))))\n        (pad-square [cols]\n          (let [size (count cols)\n                filled (mapv #(apply str (butlast (interleave % (repeat \\space)))) cols)]\n            (mapv #(let [padding (repeat (/ (- size (count %)) 2) \\space)]\n                     (apply str (concat padding % padding)))\n                  filled)))\n        (soln [begin end]\n          (-> (square-seq begin end)\n              nums->digits\n              pad\n              unpadded-square\n              pad-square\n              rot90))]\n  soln)","problem":138,"user":"50b668dde4b08fb537db98f2"},{"problem":138,"code":"(fn sqr-sqr [n limit]\n  (letfn [(next-sqr-coords [d]\n            (let [ys (if (odd? d)\n                       (range (- 1 d) 1)\n                       (reverse (range 1 (+ 1 d))))\n                  ]\n              (->> ys\n                   (interleave (range d))\n                   (partition 2)\n                   (mapcat (fn [[x y]] [[x y] [(- x) y]]))\n                   distinct\n                   sort\n                   (#(if (even? d) (reverse %) %))\n                   )))\n          (sqr-coords [d]\n            (if (= d 1)\n              [[0 0]]\n              (concat (sqr-coords (dec d)) (next-sqr-coords d))))\n          (gen-str []\n            (let [nseq (loop [cn n\n                              s [] ]\n                         (if (> cn limit)\n                           s\n                           (recur (* cn cn) (conj s cn))))\n                  nstr (apply str nseq)\n                  l-nstr (count nstr)\n                  root-bound (int (Math/sqrt l-nstr))\n                  dimension (if (= l-nstr (* root-bound root-bound))\n                              root-bound\n                              (inc root-bound))\n                  n-stars (- (* dimension dimension) l-nstr)\n                  stars (apply str (repeat n-stars \"*\"))\n                  result (str nstr stars)\n                  ]\n              [dimension result]))        \n          ]\n    (let [[dimension st] (gen-str)\n          raw-coords (sqr-coords dimension)\n          min-x (apply min (map (fn [[x y]] x) raw-coords))\n          min-y (apply min (map (fn [[x y]] y) raw-coords))\n          correct-x (- 0 min-x)\n          correct-y (- 0 min-y)\n          true-coords (map (fn [[x y]] [(+ correct-x x) (+ correct-y y)])\n                           raw-coords)\n          output-dimension (- (* 2 dimension) 1)\n          blank-vector (vec (repeat output-dimension\n                                    (vec (repeat output-dimension \\space))))\n          filled-vector (reduce (fn [v [[x y] content]]\n                                  (assoc-in v [y x] content))\n                                blank-vector\n                                (partition 2 (interleave true-coords\n                                                         (seq st))))\n          result-vector (vec (map #(apply str %) filled-vector))\n          ]\n      result-vector)))","user":"53c1ce3ee4b00fb29b221268"},{"problem":138,"code":"(fn [s e]\n   (letfn [(f [s e]\n             (if (<= s e)\n               (cons s (f (* s s) e))\n               )\n             )]\n\n     (let [ss (->> (apply str (f s e))\n                   (#(apply str % (repeat (- (Math/pow (Math/ceil (Math/sqrt (count %))) 2) (count %)) \"*\")))\n                   (map (fn [x y] [x y]) (cons [identity identity] (mapcat (fn [x y] (repeat y x)) (apply concat (repeat [[inc inc] [inc dec] [dec dec] [dec inc]])) (drop 2 (mapcat (fn [x] [x x]) (range))))))\n                   (reductions (fn [[i j] [[a b] v]]\n                                 [(a i) (b j) (str v)]\n                                 ) [0 0])\n                   rest\n                   )\n           mi (reduce (fn [[mx my] [x y v]] [(min x mx) (min y my)]) [0 0] ss)\n           ma (reduce (fn [[mx my] [x y v]] [(max x mx) (max y my)]) [0 0] ss)\n           ]\n\n       (->> (map (fn [[x y v]] [(- x (first mi)) (- y (second mi)) v]) ss)\n            (reduce (fn [r [x y v]] (assoc-in r [x y] v)) (vec (repeat (inc (- (first ma) (first mi)))\n                                                                       (vec (repeat (inc (- (second ma) (second mi))) \" \")))))\n            (map #(apply str % ) )\n            )\n\n       )\n     ))","user":"5921a080e4b09b4ee5954c77"},{"problem":138,"code":"(fn [x y]\n  (let [a (take-while #(<= % y) (iterate #(* % %) x))\n        b (mapcat (fn [x] (map #(str (- (int %) 48)) (str x))) a)\n        l (some #(when (<= (count b) %) %) (reductions + 1 (iterate #(+ % 2) 3)))\n        c (concat b (repeat (- l (count b)) \"*\"))\n        d (mapcat (fn [x] [x x]) (drop 1 (range)))\n        e (cycle [[1 1] [1 -1] [-1 -1] [-1 1]])\n        f (mapcat (fn [n x] (repeat n x)) d e)\n        sum (fn sum [[a b] [c d]] [(+ a c) (+ b d)])\n        g (reduce (fn [x y] (conj x (sum (last x) y))) [[0 0]] (take (dec l) f))\n        gi (sort (map first g))\n        gj (sort (map second g))\n        h (map (fn [[x y]] [(+ (- (first gi)) x) (+ (- (first gj)) y)]) g)\n        lx (inc (- (last gi) (first gi)))\n        k (zipmap h c)\n        m (partition lx (for [x (range lx) y (range lx)]\n                          (if-let [z (k [x y])] z \\space)))\n        n (map #(apply str %) m)]\n    n))","user":"50f10f7be4b06d9538fe211a"},{"problem":138,"code":"(fn squares-squared[start end]\n  (let [squares (mapcat str (take-while #(<= % end)\n                                        (iterate #(* % %) start)))\n        diamond-edge-width (int (Math/ceil (Math/sqrt (count squares))))\n        canvas-width (dec (* diamond-edge-width 2))\n        canvas-row (vec (repeat canvas-width \\space))\n        canvas (vec (repeat canvas-width canvas-row))\n        start-x (dec diamond-edge-width)\n        start-y (nth (mapcat vector\n                             (range 0 (java.lang.Integer/MAX_VALUE) 2)\n                             (range 0 (java.lang.Integer/MAX_VALUE) 2)) start-x)\n        cursor [start-y start-x]\n        num-pixels-to-paint (* diamond-edge-width diamond-edge-width)\n        extra-stars-required (- num-pixels-to-paint (count squares))\n        pixels (concat squares (repeat extra-stars-required \\*))\n\n        down-right (fn [[y x]] [(inc y) (inc x)])\n        down-left  (fn [[y x]] [(inc y) (dec x)])\n        up-left  (fn [[y x]] [(dec y) (dec x)])\n        up-right (fn [[y x]] [(dec y) (inc x)])\n        movements (cycle [down-right down-left up-left up-right])\n        steps (map #(+ 1 (quot % 2)) (range))\n        snake (take (count pixels) (mapcat (fn [m s] (repeat s m)) movements steps))]\n    (loop [cs canvas\n           ps pixels\n           <+> cursor\n           ss snake]\n      (if-not (seq ps)\n        (mapv #(apply str %) cs)\n        (recur\n         (update-in (vec  cs) <+> (constantly (first ps)))\n         (rest ps)\n         ((first ss) <+>)\n         (rest ss))))))","user":"56069006e4b08b23635d3174"},{"problem":138,"code":"(let [spiral--thrush\n        ;; With no argument, returns the infinite lazy sequence of coordinates\n        ;; corresponding to a clockwise diagonal square spiral in the lattice\n        ;; of points in the plane with integer coordinates, starting at the\n        ;; origin with initial orientation towards positive x and positive\n        ;; y (the first quadrant when viewed as the Cartesian plane, or to the\n        ;;        lower right when viewed as a matrix).\n\n        ;; The initial segment of this sequence is as follows:\n        ;; ([0 0] [1 1] [2 0] [1 -1] [0 -2] [-1 -1] [-2 0] [-1 1] ...)\n\n        ;; If the optional argument [x y] is supplied, all values in the return\n        ;; sequence are translated by [x y].\n        (fn spiral--thrush \n          ([offset]\n           (let [add-pair (fn [[x1 x2] [y1 y2]]\n                            [(+ x1 y1) (+ x2 y2)])]\n             (->> (range)\n                  (mapcat (partial repeat 2))\n                  (mapcat #(repeat %2 %1) (cycle [[-1 -1] [-1 1] [1 1] [1 -1]]))\n                  (reductions add-pair (or offset [0 0])))))\n          ([]\n           (spiral--thrush [0 0]))),\n\n        print-square\n        ;; Given a non-negative integer n and a map data whose values are\n        ;; characters, returns an n by n rectangular matrix as a vector of\n        ;; strings, where the (i,j)th character is given by (data [i j]), or a\n        ;; space if the map does not have [i j] as a key.\n        (fn print-square \n          [n data]\n          {:pre [(integer? n),\n                 (not (neg? n)),\n                 (associative? data)\n                 (every? char? (vals data))]}\n          (vec (for [i (range n)]\n                 (apply str (for [j (range n)]\n                              (get data [i j] \\space))))))]\n    \n    (fn [start end]\n      (let [\n            ;; The digit sequence we want to encode.\n            digits\n            (->> (iterate #(* % %) start)\n                 (take-while (partial >= end))\n                 (apply str)),\n\n            ;; The size of the square to use.\n            dim\n            (->> (range)\n                 (drop-while (comp (partial > (count digits))\n                                   #(* % %)))\n                 first),\n\n            ;; The coordinates of the starting digit.\n            offset\n            (if (even? dim)\n              [(- dim 2) (- dim 1)]\n              [(- dim 1) (- dim 1)])] \n        (->> (concat digits (repeat \\*))\n             (take (* dim dim))\n             (zipmap (spiral--thrush offset))\n             (print-square (dec (* 2 dim)))))))","user":"4fc6305de4b0ee37620e180b"},{"problem":138,"code":"(fn ss\n  [start end]\n  (let [squares (apply str (take-while #(<= % end) (iterate #(* % %) start)))\n        side-len (int (Math/ceil (Math/sqrt (count squares))))\n        strings (reverse (take (Math/pow side-len 2) (concat squares (cycle [\\*]))))\n        board-len (+ 1 (* (dec side-len) 2))\n        directions (cycle [[1 1] [-1 1] [-1 -1] [1 -1]])\n        board (reduce (fn [[b position [d nd & _ :as ds]] c]\n                        (let [is-next-empty (= (get-in b (map + position d)) \\space)]\n                          [(update-in b position (fn [_] c))\n                           (if is-next-empty\n                             (map + position d)\n                             (map + position nd))\n                           (if is-next-empty\n                             ds\n                             (rest ds))]))\n                         [(apply vector (repeat board-len (apply vector (repeat board-len \\space)))) \n                          [(dec side-len) (if (even? side-len) 0 (dec board-len))] \n                          (drop (if (even? side-len) 0 2) directions)] strings)]\n    (map #(apply str %) (first board))))","user":"576df252e4b0979f8965156f"},{"code":"(fn [low high]\n  (let [num-seq (take-while (partial >= high) (iterate #(* % %) low))\n        num-str (apply str num-seq)\n        num-len (count num-str)\n        edge-len (loop [i 1] (if (< (* i i) num-len) (recur (inc i)) i))\n        to-wrap (take (* edge-len edge-len) (concat num-str (repeat \\*)))\n        coords (loop [r {[0 0] (first to-wrap)}\n                      xs (rest to-wrap)\n                      y 0 x 0\n                      dirs (cycle '([-1 1] [1 1] [1 -1] [-1 -1]))]\n                 (let [[dy dx] (first dirs)\n                       nx (+ x dx) ny (+ y dy)\n                       [dy' dx'] (second dirs)\n                       nx' (+ x dx') ny' (+ y dy')]\n                   (cond (empty? xs) r\n                         (r [ny' nx']) (recur (conj r [[ny nx] (first xs)]) (rest xs) ny nx dirs)\n                         :else (recur (conj r [[ny' nx'] (first xs)]) (rest xs) ny' nx' (rest dirs)))))\n        ys (map first (keys coords))\n        xs (map second (keys coords))]\n  (for [y (range (apply min ys) (inc (apply max ys)))]\n    (apply str (for [x (range (apply min xs) (inc (apply max xs)))] (get coords [y x] \\space))))))","problem":138,"user":"4fe8aef4e4b07c9f6fd12c6c"},{"problem":138,"code":"(fn [start end]\n  (let [s (apply str (map str (take-while #(<= % end) (iterate #(* % %) start))))\n        n (int (Math/ceil (Math/sqrt (count s))))\n        ss (apply str s (map (fn [x] \"*\") (range (- (* n n) (count s)))))\n        steps (mapcat (fn [i] (concat (repeat i (if (even? i) [-1 -1] [1 1]))\n                                      (repeat i (if (even? i) [1 -1] [-1 1])))) (range))\n        coords (reductions (fn [[x y] [a b]] [(+ x a) (+ y b)])\n                           [(dec n) (* 2 (int (/ (dec n) 2)))]\n                           steps)\n        plots (into {} (map vector coords ss))\n        dim (range (dec (* 2 n)))\n        rows (vec (for [y dim]\n                    (apply str (for [x dim] (plots [x y] \" \")))))\n        ]\n    rows))","user":"4f5eda39e4b0030a34fb2b56"},{"code":"(fn [s e]\n  (let [c (apply str (take-while #(<= % e) (iterate #(* % %) s)))\n        l (int (Math/ceil (Math/sqrt (count c))))\n        t (concat c (repeat (- (* l l) (count c)) \\*))\n        sp (fn spiral ([c] (spiral c 0 0 1 [1 1] \n                                   {[1 1] [1 -1], [1 -1] [-1 -1], \n                                    [-1 -1] [-1 1], [-1 1] [1 1]})) \n             ([c l r n d cw]\n               (cons c \n                     (lazy-seq \n                       (cond (and (zero? r) (zero? n)) \n                             (spiral (mapv + c d) (inc l) (inc l) 1 (cw d) cw)\n                             (zero? r)\n                             (spiral (mapv + c d) l l (dec n) (cw d) cw)\n                             :else\n                             (spiral (mapv + c d) l (dec r) n d cw))))))\n        m (zipmap (sp (#(vector (if (even? %) % (dec %)) %) (dec l))) t)\n        d (dec (* l 2))]\n    (for [x (range d)] (apply str (for [y (range d)] (get m [x y] \\space))))))","problem":138,"user":"5246e945e4b0644eb7b0783b"},{"problem":138,"code":"(fn [x y]\n  (let [s (mapcat str (take-while #(<= % y)  (iterate #(* % %) x)))\n        n (first (drop-while #(< (* % %) (count s)) (range)))\n        s (concat s (repeat (- (* n n)(count s)) \\*)) \n        size (- (* n 2) 1)\n        grid (vec (repeat size (vec (repeat size \\space))))\n        origin [(if (odd? n) (dec n)(- n 2)) (dec n)]\n        oscillate (fn [x y] \n                    (let [osc (fn osc [n x y step] \n                        (lazy-seq (cons n (cond\n                                            (= n x)(osc (+ n (- step)) (- x 2)   y    (- step))\n                                            (= n y)(osc (+ n (- step))    x   (+ y 2) (- step))\n                                            :else  (osc (+ n step) x y step)))))]\n                      (osc x x y -1)))\n        chars-with-indices (map (fn [ch r c] [ch (map + origin [r c])]) s (oscillate 0 2)(oscillate 0 1)) ]\n    (map #(apply str %) \n         (reduce (fn [grid [ch [r c]]] (assoc-in grid [r c] ch)) grid chars-with-indices))))","user":"55ecb2c0e4b0121d4835fdce"},{"code":"(fn solve [l r]\n  (let [incx [1 1 -1 -1]\n        incy [1 -1 -1 1]]\n    (letfn [\n            (to-string [l r]\n                       (when (<= l r) (str l (to-string (* l l) r))))\n            \n            (give-location [x y dir change-in change-for remaining]\n                           (let [new-x (+ x (nth incx dir))\n                                 new-y (+ y (nth incy dir))\n                                 new-dir (if (zero? change-in) (mod (inc dir) 4) dir)\n                                 new-change-in (if (zero? change-in) (quot change-for 2) (dec change-in))\n                                 new-change-for (if (zero? change-in) (inc change-for) change-for)\n                                 new-remaining (rest remaining)\n                                 ]\n                             (concat [[(first remaining) [x y]]] (if-not (empty? new-remaining) (give-location new-x new-y new-dir new-change-in new-change-for new-remaining) []))))\n            ]\n      (let [p (seq (to-string l r))\n            size (int (Math/ceil (Math/sqrt (count p))))\n            p (concat p (repeat (- (* size size) (count p)) \\*))\n            loc-to-char (if (odd? size)\n                          (give-location 0 0 0 0 1 p)\n                          (give-location -1 0 0 0 1 p))\n            min-x (apply min (map #(->> % second first) loc-to-char))\n            max-x (apply max (map #(->> % second first) loc-to-char))\n            min-y (apply min (map #(->> % second second) loc-to-char))\n            max-y (apply max (map #(->> % second second) loc-to-char))\n            loc-to-char-shifted (mapcat (fn [[ch [x y]]]0 (vector [(- x min-x) (- y min-y)] ch)) loc-to-char)\n            get-char (apply array-map loc-to-char-shifted)\n            ]\n        (map #(apply str %) (partition (- max-y min-y -1)\n                                       (for [x (range (- max-x min-x -1))\n                                             y (range (- max-y min-y -1))]\n                                         (get get-char [x y] \\space))))))))","problem":138,"user":"5054bc87e4b0b1b9d1860eb0"},{"problem":138,"code":"(fn [i j]\n  (let [num-str (apply str (take-while #(<= % j) (iterate #(* % %) i)))\n        str-size (first (drop-while #(< (* % %) (count num-str)) (range)))\n        full-string (concat num-str (repeat (- (* str-size str-size) (count num-str)) \\*))\n        board-size (dec (* 2 str-size))\n        init-board (vec (repeat board-size (vec (repeat board-size \\space))))]\n    (letfn [(step [board current gap char-seq]\n                  (if (not (empty? char-seq))\n                    (let [next-board (assoc-in board current (first char-seq))\n                          f-next-gap (if (zero? (first current))\n                                       [1 -1];go down left\n                                       (if (= (dec board-size) (first current))\n                                         [-1 1];go up right\n                                         (if (zero? (second current))\n                                           [1 1];go down right\n                                           (if (= (dec board-size) (second current))\n                                             [-1 -1]; go up left\n                                             gap))))\n                          f-next-current (map #(+ %1 %2) current f-next-gap);calculate next position to insert next symbol\n                          next-gap (if (= \\space (get-in board f-next-current))\n                                     f-next-gap;if next position empty\n                                     (case f-next-gap;if next position is not empty -> reduce radius of next ring\n                                       [1 -1] [1 1]\n                                       [1 1] [-1 1]\n                                       [-1 1] [-1 -1]\n                                       [-1 -1] [1 -1]))]\n                      (step next-board (map #(+ %1 %2) current next-gap) next-gap (next char-seq)))\n                    board))]\n      (mapv #(apply str %) (step init-board (if (odd? str-size) [(dec str-size) (dec board-size)] [(dec str-size) 0]) [1 1] (reverse full-string))))))","user":"56ab7578e4b03c432f18733d"},{"problem":138,"code":"(fn [start end]\n  (let [offset-seq (fn offset-seq []\n                     (let [dirs (cycle [[1 1] [1 -1] [-1 -1] [-1 1]])\n                           steps (drop 2 (interleave (range) (range)))\n                           f1 (fn f\n                                ([steps dirs] (f (first steps) (rest steps) (first dirs) (rest dirs)))\n                                ([s steps dir dirs]\n                                 (if (zero? s)\n                                   (let [s (first steps)\n                                         steps (rest steps)\n                                         dir (first dirs)\n                                         dirs (rest dirs)]\n                                     (cons dir (lazy-seq (f (dec s) steps dir dirs))))\n                                   (cons dir (lazy-seq (f (dec s) steps dir dirs))))))]\n                       (f1 steps dirs)))\n        locations (fn locations [chars]\n                    (let [offsets (offset-seq)]\n                      (loop [loc [0 0], chars chars, offsets offsets, m {}]\n                        (if (seq chars)\n                          (let [next-loc (map + loc (first offsets))]\n                            (recur next-loc (rest chars) (rest offsets) (assoc m loc (first chars))))\n                          m))))\n        bounds (fn bounds [locs]\n                 (let [foo (fn [comp where] (apply comp (map where (keys locs))))\n                       min-r (foo min first)\n                       max-r (foo max first)\n                       min-c (foo min second)\n                       max-c (foo max second)]\n                   [min-r max-r min-c max-c]))\n        get-chars (fn get-chars [start end]\n                    (let [lengths (take 10 (map #(* % %) (drop 1 (range))))\n                          nums (apply str (take-while #(<= % end) (iterate #(* % %) start)))\n                          _ (println (drop-while #(< % (count nums)) lengths))\n                          length (first (drop-while #(< % (count nums)) lengths))\n                          stars (repeat (- length (count nums)) \\*)]\n                      (into (into [] nums) stars)))]\n    (let [locs (locations (get-chars start end))\n          b (bounds locs)]\n      (for [r (range (nth b 0) (inc (nth b 1)))]\n        (apply str\n               (for [c (range (nth b 2) (inc (nth b 3)))]\n                 (get locs [r c] \" \")))))))","user":"530b8580e4b02e82168697cc"},{"problem":138,"code":"(fn draw [a b]\n  (let [s (apply str (take-while #(<= % b) (iterate #(* % %) a)))\n        size (int (Math/ceil (Math/sqrt (count s))))\n        f (apply str s (repeat (- (* size size) (count s)) \\*))\n        size2 (dec (* size 2))\n        initial-grid (repeat size2 (repeat size2 \\space))\n        start [(if (even? size) (dec (dec size)) (dec size)) (dec size)]\n        moves (take (count f) (apply concat \n            (for [i (range (count f))] (repeat (inc (quot i 2)) \n                     (nth [[1 1] [1 -1] [-1 -1] [-1 1]] (mod i 4))))))\n        next-grid (fn [grid new pos] (map-indexed (fn [i row] \n                                                    (if (= i (first pos)) \n                                                      (map-indexed (fn [j col] (if (= j (second pos)) new col)) row)\n                                                      row)) grid))\n       ]\n       (map #(apply str %) \n    (loop [grid initial-grid pos start i 0]\n    (do\n    \t(println \"-------------\")\n    \t(println \"i=\" i)\n    \t(println \"f=\" f)\n    \t(println \"grid=\" grid)\n    \t(println \"pos=\" pos)\n      (if (= i (count f))\n        grid\n        (recur (next-grid grid (nth f i) pos) (map + pos (nth moves i)) (inc i))))\n    )\n    )))","user":"55a74d46e4b09e57187da2a3"},{"code":"(fn [n m]\n (let [p (apply str (take-while #(<= % m) (iterate #(* % %) n)))\n       [s z] (some #(if (<= (count p) (* % %)) [(+ % % -1) %]) (range)) \n       w (quot s 2)]\n   (map #(apply str %) \n        (reduce (fn [a [k v]] (assoc-in a k v)) \n                (vec (map vec (partition s (repeat (* s s) \\ ))))\n                (map #(list %2 %) \n                     (concat p (repeat (- (* z z) (count p)) \\*))\n                     (reductions #(map + % %2) \n                                 [(- w (if (even? z) 1 0)) w] \n                                 (mapcat #(repeat % %2) \n                                         (mapcat #(list % %) (iterate inc 1))\n                                         (cycle [[1 1] [1 -1] [-1 -1] [-1 1]]))))))))","problem":138,"user":"4ef49c2c535dced4c769f238"},{"problem":138,"code":"(fn [a b]\n  (let [l (loop [l \"\" e a]\n            (if (> e b) l\n              (recur (str l e) (* e e))))\n        [l n] (loop [i 1]\n                (let [n (- (* i i) (count l))]\n                  (if (< n 0) (recur (inc i))\n                    [(concat l (repeat n \\*)) (+ i (- i 1))])))\n        [m x] (reduce (fn [[m x i [f q]] e]\n                        [(assoc m (f i) (conj (q (get m (f i))) (nth l e)))\n                         (min x (f i))\n                         (f i)\n                         (if (loop [n 1]\n                               (let [y (* n (- n 1))]\n                                 (if (< y e)\n                                   (recur (inc n))\n                                   (= y e))))\n                           (if (= f inc) [dec seq] [inc vec])\n                           [f q])])\n                      [{} 0 1 [dec seq]] (range (count l)))]\n    (loop [t []\n           i x]\n      (let [l (get m i)]\n        (if (nil? l) t\n          (let [s (clojure.string/join \" \" l)\n                e (apply str (repeat (/ (- n (count s)) 2) \" \"))]\n            (recur (conj t (str e s e)) (inc i))))))))","user":"57d9f603e4b0bd073c20240a"},{"code":"(fn sqsq [from to]\r\n  (let [dirs [{:y -1} {:x -1} {:y 1} {:x 1}]\r\n  \titerate2 (fn iterate2 [f x] (lazy-seq (cons x (cons x (iterate2 f (f x))))))\r\n\t\tdir-cycle (fn [] (flatten (map #(repeat %1 %2) (iterate2 inc 1) (cycle dirs))))\r\n\r\n\t\tstr-to-square (fn [s]\r\n          (apply hash-map\r\n            (reduce\r\n              (fn [r [d c]]\r\n                (let [p (first r)\r\n                      np (merge-with + p d)]\r\n                  (concat [np c] r)))\r\n              [{:x 0 :y 0} (first s)]\r\n              (map list (dir-cycle) (rest s))\r\n             )))\r\n\r\n\t\tsquare-to-str (fn [sq]\r\n          (let [maxX (apply max (map #(:x (key %)) sq))\r\n                maxY (apply max (map #(:y (key %)) sq))\r\n                minX (apply min (map #(:x (key %)) sq))\r\n                minY (apply min (map #(:y (key %)) sq))\r\n                mmy (+ (Math/abs minY) maxY)\r\n                ws (vec (repeat (+ 1 (Math/abs minY) maxY)\r\n                     (vec (repeat (+ 1 (Math/abs minX) maxX) \\space))))\r\n                ]\r\n            (map #(apply str %)\r\n              (reduce\r\n               (fn [r [{x :x y :y} c]] (assoc-in r [(- mmy (+ (Math/abs minY) y)) (+ (Math/abs minX) x)] c))\r\n                 ws sq))))\r\n\r\n        rotate (fn [deg {x :x y :y}]\r\n          (let [rad (Math/toRadians deg)\r\n                sin (Math/sin rad)\r\n                cos (Math/cos rad)]\r\n            {:x (Math/round (* 1.5 (- (* x cos) (* y sin)))) ; HACK * 1.5 because it magically works\r\n             :y (Math/round (* 1.5 (+ (* x sin) (* y cos))))}\r\n            ))\r\n\r\n        rotate-square (fn [sq]\r\n\t\t  (apply hash-map (reduce-kv #(concat %1 [(rotate 45 %2) %3]) [] sq)))\r\n\r\n        sqrlen (fn [s]\r\n          (let [len  (count s)\r\n                sqrt (Math/ceil (Math/sqrt len))\r\n                sqr  (* sqrt sqrt)]\r\n            (if (= sqr len) s (apply str (concat s (repeat (- sqr len) \\*))))))\r\n\r\n\r\n        numbers (take-while #(<= % to) (iterate #(* % %) from))\r\n        numstr  (sqrlen (apply str (map str numbers)))\r\n        square  (str-to-square numstr)\r\n        rsquare (rotate-square square)]\r\n    (square-to-str rsquare)))","problem":138,"user":"4f1b92d1535d64f60314647b"},{"problem":138,"code":"(fn full-squares [n1 n2]\n  (letfn [(squares-string [n1 n2]\n            (apply str (take-while #(<= % n2) (iterate #(* % %) n1))))\n          (length [string]\n            (let [c (count string)\n                  squares (map #(* % %) (range))]\n              (first (filter (comp not nil?)\n                             (map #(if (and (< % c) (>= %2 c)) %2)\n                                  squares\n                                  (rest squares))))))\n          (complement-string [string length]\n            (into (vec string) (repeat (- length (count string)) \"*\")))\n          (size [length]\n            (let [m (Math/sqrt length)]\n              (int (+ m (dec m)))))\n          (field [size]\n            (vec (repeat size (vec (repeat size \\space)))))\n          (start-pos [size]\n            (let [q (quot size 2)]\n              (if (even? (quot (dec size) 2))\n                [q q]\n                [(dec (quot size 2)) q])))\n          (directions []\n            (cycle [[1 1] [1 -1] [-1 -1] [-1 1]]))\n          (squares [s-vec field pos directions]\n            (let [d (first directions)]\n              (if (empty? s-vec) field\n                  (squares (vec (rest s-vec)) (assoc-in field pos (first s-vec))\n                           (vec (map + pos d))\n                           (if (= \\space (get-in field (vec (map + pos d (second directions)))))\n                             (rest directions)\n                             directions)))))]\n    (let [str1 (squares-string n1 n2)\n          length (length str1)\n          s-vec (complement-string str1 length)\n          size (size length)\n          field (field size)\n          start-pos (start-pos size)\n          directions (directions)\n          squares (squares s-vec field start-pos directions)]\n      (map #(apply str %) squares))))","user":"53973e7be4b0b51d73faaee6"},{"code":"(fn sqr-sqr [s t] (let [\n    r (apply str (take-while (partial >= t) (iterate #(* % %) s)))\n    n (some #(when (<= (count r) (* % %)) %) (range))\n    s-init (apply str r (repeat (- (* n n) (count r)) \\*))\n    m (+ n n -1)\n    b-init (vec (repeat m (vec (repeat m \\space))))\n    [h-init w-init] [(if (odd? n) n (dec n)) (- n 2)]\n    put (fn [b s h w dhs dws] (if (empty? s) b (let [\n        [dhr dwr] [dws (- dhs)]\n        [hr wr] [(+ h dhr) (+ w dwr)]\n        [hs ws] [(+ h dhs) (+ w dws)]\n        [h0 w0 dhs0 dws0] (if (= \\space ((b hr) wr)) [hr wr dhr dwr] [hs ws dhs dws])\n        b0 (assoc b h0 (assoc (b h0) w0 (first s)))\n        s0 (next s)]\n        (recur b0 s0 h0 w0 dhs0 dws0))))\n    ans (put b-init s-init h-init w-init -1 -1)]\n    (map (partial apply str) ans)))","problem":138,"user":"51cbdee1e4b08d8387cbede1"},{"code":"(fn squares-squared [start end]\n  (let [squares           (take-while #(>= end %) (iterate #(* % %) start))\n        digits            (mapcat str squares)\n        seq-size          (int (Math/ceil (Math/sqrt (count digits))))\n        full-seq          (concat digits (repeat (-' (* seq-size seq-size) (count digits)) \\*))\n\n\n        side-lengths      (drop 2 (interleave (range) (range)))\n        directions        (cycle [[1 1] [-1 1] [-1 -1] [1 -1]])\n        deltas            (take (count full-seq) (mapcat #(repeat %1 %2) side-lengths directions))\n\n        next-square       (fn [[x y] [dx dy]]\n                            [(+ x dx) (+ y dy)])\n\n        zero-indexed      (reductions next-square [0 0] deltas)\n        zindex-squares     (zipmap zero-indexed full-seq)\n\n\n        min-x             (apply min (map #(first %) (keys zindex-squares)))\n        min-y             (apply min (map #(second %) (keys zindex-squares)))\n        index-squares     (zipmap (map (fn [[x y]]\n                                         [(- x min-x) (- y min-y)]) (keys zindex-squares)) (vals zindex-squares))\n        max-x             (apply max (map #(first %) (keys index-squares)))\n        max-y             (apply max (map #(second %) (keys index-squares)))\n        ]\n    (for [y (range (inc max-y))]\n      (apply str (for [x (range (inc max-x))]\n        (if (index-squares [x y])\n          (index-squares [x y])\n          \\space))))))","problem":138,"user":"510cd1dde4b078ea71921124"},{"problem":138,"code":"(fn [x y]\n  ; wrapping a square is haaaaaaaaaaaaaard :)\n  (letfn [(v [s c]\n             (let [w (repeat s \\space)\n                   cs (clojure.string/join \" \" c)]\n               (apply str (concat w cs w))))\n          (w\n           ([a] [(str a)])\n           ([a b\n             c d] [(v 1 [a])\n                   (v 0 [d b])\n                   (v 1 [c])])\n           ([a b c\n             d e f\n             g h i] [(v 2 [g])\n                     (v 1[f h])\n                     (v 0 [e a i])\n                     (v 1 [d b])\n                     (v 2 [c])])\n           ([a b c d\n             e f g h\n             i j k l\n             m n o p] [(v 3 [g])\n                       (v 2 [f h])\n                       (v 1 [e a i])\n                       (v 0 [p d b j])\n                       (v 1 [o c k])\n                       (v 2 [n l])\n                       (v 3 [m])]))]\n        \n    (let [d (apply str (take-while #(<= % y)(iterate #(* % %) x)))\n          c (count d)\n          l (first (drop-while #(< % c) (map * (range) (range))))\n          r (concat d (repeat (- l c) \\*))]\n      (apply w r))))","user":"54dd76c8e4b024c67c0cf794"},{"problem":138,"code":"(letfn\n    [(square [n] (*' n n))\n     (square-seq [a b]\n       (take-while #(<= % b) (iterate square a)))\n     (num->digits [m]\n       (->> m (iterate #(quot % 10)) (take-while pos?) (map #(str (rem % 10))) (reverse)))\n     (starts-at [mag]\n       (int (Math/ceil (- (/ mag 2) 1))))\n     (pad [digits mag]\n       (into (vec digits) (replicate (- (square mag) (count digits)) \"*\")))\n     (next-wind [grid [y x :as pos] [h & t :as dir]]\n       ; return next position and new direction\n       (let [cdir h ndir (first t)]\n         (if (= \" \" (get-in grid (ndir pos)))\n           [(ndir pos) t]\n           [(cdir pos) dir])))\n     (render [grid]\n       (if false (do\n                   (doall (map println grid))\n                   (println \"\"))))\n     (wind [grid [h & t :as digits] [y x :as pos] dirs]\n       (render grid)\n       (if digits\n         (do\n           (let [grid (assoc-in grid pos h)\n                 [newpos newdirs] (next-wind grid pos dirs)]\n             (wind grid t newpos newdirs)))\n         grid))\n     (draw [digits]\n       (let [ndig (count digits)\n             mag (first (filter #(>= (square %) ndig) (range)))\n             st (starts-at mag)\n             grid (vec (replicate mag (vec (replicate mag \" \"))))\n             directions [(fn up [[y x]] [(dec y) x])\n                         (fn right [[y x]] [y (inc x)])\n                         (fn down [[y x]] [(inc y) x])\n                         (fn left [[y x]] [y (dec x)])]]\n         (wind grid (pad digits mag) [st st] (cycle directions))))\n     (cross-cut [grid n]\n       (remove nil? (map #(get-in grid [%1 %2]) (reverse (range n)) (range n))))\n     (pad-around [coll len]\n       (let [pad (- len (count coll))]\n         (concat (replicate (/ pad 2) \" \")\n                 coll\n                 (replicate (/ pad 2) \" \"))))\n     (add-row [[h & more :as grid] row]\n       (let [spaced (interpose \" \" row)\n             len (max (count spaced) (count h))]\n         (map #(pad-around % len) (concat grid [spaced]))))\n     (rotate [grid]\n       (let [sz (count grid)\n             boundary (* 2 sz)]\n         (loop [line 1 result []]\n           (if (= line boundary)\n             result\n             (recur (inc line)\n                    (add-row result (cross-cut grid line)))))))]\n\n    (fn sqsq [a b]\n      (let [digits (mapcat num->digits (square-seq a b))]\n        (map #(apply str %) (rotate (draw digits))))))","user":"58ec1e63e4b056aecfd47d54"},{"code":"(fn f [a b]\n  (let [d (mapcat str (take-while #(<= % b) (iterate #(* % %) a)))\n        n (count d)\n        s (some #(if (>= (* % %) n) %) (range)) \n        t (- s 1) c (* s s) h (- (* 2 s) 1) r (range 1 s) \n        l (vec (concat d (repeat (- c n) \\*)))  \n        g (vec (repeat h (vec (repeat h \\ ))))  \n        u (set (map #(* % %) r)) \n        v (set (map + u r)) \n        X #(* % (if (%2 (+ 1 %3)) -1 1)) ] \n    ( loop [i 0 x t y (* 2 (quot t 2)) e 1 f 1 o g]\n      (if (= c i) (map #(apply str %) o)\n        (recur (+ 1 i) (+ x e) (+ y f)\n               (X e u i) (X f v i)\n               (assoc-in o [y x] (l i)))))))","problem":138,"user":"4f1d1d95535d64f603146488"},{"problem":138,"code":"(letfn\n    [(path\n       ([xs size]\n        (->> (path xs (cycle [[-1 0] [0 1] [1 0] [0 -1]]) #{})\n             (map (fn [[y x]] [(- (+ y x) 2) (+ (- x y) (dec size))]))\n             (take (* size size))))\n       ([xy ops history]\n        (lazy-seq\n         (let [nxy (map + xy (first ops))\n               nnxy (map + xy (second ops))]\n           (if (history nnxy)\n             (cons xy (path nxy ops (conj history xy)))\n             (cons xy (path nnxy (rest ops) (conj history xy))))))))\n\n     (sq [base limit]\n       (if (> base limit)\n         nil\n         (cons base (sq (* base base) limit))))\n\n     (pad [s n symb]\n       (apply str (for [i (range 0 (max (count s) n))] (get s i symb))))\n\n     (create-board [size]\n       (let [repeatv (comp vec repeat)]\n         (repeatv size (repeatv size \" \"))))]\n\n     (fn f [base limit]\n       (let [squars (apply str (sq base limit))\n             len (int (Math/ceil (Math/sqrt (count squars))))\n             padded-squars (pad squars (* len len) \\*)\n             start (int (Math/ceil (/ len 2)))\n             board (create-board (+ len (dec len)))\n             coords (map #(vector % %2) padded-squars (path [start start] len))]\n         (->>\n          (reduce (fn [m [sym coord]] (assoc-in m coord sym))\n                  board\n                  coords)\n          (map #(apply str %))))))","user":"56795deae4b05957ce8c6187"},{"problem":138,"code":"(fn [a b]\n   (let [sq #(* % %)\n         s (fn [i] (+ (sq (- i 2)) (- i 2)))\n         cr (->> (take-while #(<= % b) (iterate sq a)) (apply str))\n         chars (into (vec cr) (repeat (first (drop-while neg? (map #(- (sq %) (count cr)) (range)))) \\*))\n         n (int (Math/sqrt (count chars)))\n         rev (fn [rows] (if (odd? n) (map reverse (reverse rows)) rows))]\n     (->> (iterate (fn [rows]\n                     (cond (<= (count rows) (- n 2))\n                           (let [xs (last rows)\n                                 c (/ (count xs) 2)\n                                 x1 (concat (map dec (take c xs)) [(s (- n (count rows)))] (map inc (drop c xs)))\n                                 x2 (concat (map dec (take (inc c) x1)) (map inc (drop c x1)))]\n                             (concat rows (if (= (count rows) (- n 2))\n                                            [x1] [x1 x2])))\n\n                           (= (count rows) (dec n))\n                           (let [xs (last rows)\n                                 c (-> (count xs) (/ 2) int)\n                                 r (concat (map dec (take c xs)) (map inc (drop c xs)))]\n                             (concat rows [(cons (dec (sq n)) r)]))\n\n                           (< (dec n) (count rows) (dec (* 2 n)))\n                           (let [xs (last rows)\n                                 c (-> (count xs) (/ 2) int)]\n                             (concat rows [(concat (map dec (take c xs)) (map inc (drop (inc c) xs)))]))))\n                   [])\n          (take-while (comp not nil?)) last rev\n          (map (fn [xs] (map #(nth chars %) xs)))\n          (map-indexed (fn [i xs]\n                         (let [sp (repeat (Math/abs (- n 1 i)) \" \")]\n                           (apply str (concat sp (->> (repeat \" \") (interleave xs) drop-last) sp))))))\n     ))","user":"54055aa9e4b0addc1aec6665"},{"problem":138,"code":"(letfn [(sq-up-to\n          [sq-min sq-max]\n          (take-while\n           (fn [n]\n             (<= n sq-max))\n           (iterate #(* % %)\n                    sq-min)))]\n\n  (fn sq-sq\n    [sq-min sq-max]\n    (let [chars (seq (apply str (sq-up-to\n                                 sq-min sq-max)))\n          char-count (count chars)\n          [row-count\n           cover]\n          (cond\n            (= 1 char-count)\n            [1\n             [[0 0]]]\n            (<= char-count 4)\n            [3\n             [[0 1]\n              [1 2]\n              [2 1]\n              [1 0]]]\n            (<= 5 char-count 9)\n            [5\n             [[2 2]\n              [3 3]\n              [4 2]\n              [3 1]\n              [2 0]\n              [1 1]\n              [0 2]\n              [1 3]\n              [2 4]]]\n            :else [7\n                   [[2 3]\n                    [3 4]\n                    [4 3]\n                    [3 2]\n                    [2 1]\n                    [1 2]\n                    [0 3]\n                    [1 4]\n                    [2 5]\n                    [3 6]\n                    [4 5]\n                    [5 4]\n                    [6 3]\n                    [5 2]\n                    [4 1]\n                    [3 0]]])]\n\n      (mapv\n       (fn [v]\n         (apply str v))\n       (reduce\n        (fn [m [coord char]]\n          (assoc-in m coord char))\n        (into []\n              (for [i (range row-count)]\n                (into []\n                      (for [j (range row-count)]\n                        \\ ))))\n        (map vector cover (concat chars (repeat \\*))))))))","user":"54246fcce4b01498b1a71aed"},{"code":"(letfn [(mv [[pos dir last lastdir]]\n          (let [[x y] (mapv + pos dir)\n                [xdir ydir] dir]\n            (if (= [x y] last)\n              (let [npos (mapv + pos lastdir)]\n                [npos dir npos nil])\n              [[x y]\n               (cond (= x 0) [xdir (- ydir)]\n                     (= y 0) [(- xdir) ydir]\n                     :else [xdir ydir])\n               last dir])))]\n  (fn [start end]\n    (let [s (apply str (take-while #(<= % end) (iterate #(* % %) start)))\n          c (first (drop-while #(< % (count s)) (map #(* % %) (rest (range)))))\n          s (apply str s (repeat (- c (count s)) \"*\"))\n          moves\n          (if (odd? c)\n            (cons [[0 0]] (iterate mv [[-1 1] [-1 -1] [-1 1] nil]))\n            (iterate mv [[1 0] [-1 1] [1 0] nil]))\n          positions (take c (map first moves))\n          lookup (apply assoc {} (interleave positions s))]\n      (vec (for [x (reverse (sort (distinct (map first positions))))]\n             (apply str (for [y (sort (distinct (map second positions)))]\n                           (get lookup [x y] \" \")))))\n      ))\n  )","problem":138,"user":"519ef784e4b087743fad2198"},{"code":"(fn [a b]\r\n  (let [m map e (partial apply str) d dec k \\  l repeat j assoc-in i iterate h rest u count\r\n        s (e (take-while #(<= % b) (i #(* % %) a)))\r\n        n (-> s u Math/sqrt Math/ceil int)]\r\n    (m e\r\n      (loop [c (m d [(if (odd? n) n (d n)) n])\r\n             t (j (nth (i #(vec (l (d (* 2 n)) %)) k) 2) c (first s))\r\n             [p & r] (h (e s (l (- (* n n) (u s)) \\*)))\r\n             [q w :as y] (cycle [[-1 1] [1 1] [1 -1] [-1 -1]])]\r\n        (if-not p\r\n          t\r\n          (let [g (if (= k (get-in t (m + c w))) w q)\r\n                v (m + c g)]\r\n            (recur\r\n              v\r\n              (j t v p)\r\n              r\r\n              (if (= g w) (h y) y))))))))","problem":138,"user":"4db85282535d1e037afb218a"},{"code":"(fn [s e]\n  (let [nums (apply str (take-while  #(>= e %) (iterate #(* % %) s)))\n        ln (count nums)\n        l* (- (first (drop-while #(> ln %) (map #(* % %) (range)))) ln)\n        all (apply str nums (repeat l* \"*\"))\n        my-split (fn [s r] (cond (empty? s) r\n                                 (empty? r) (recur (rest s) (conj r (list (first s))))\n                                 :else (let [n (+ 2 (count (last r)))] \n                                          (recur (drop n s) (conj r (take n s))))))\n        my-cons (partial apply vector)\n        join-left (fn [t n i] (assoc t n (str i (t n))))\n        join-right (fn [t n i] (assoc t n (str (t n) i)))\n        parts (my-split all [])\n        build (fn [p r]\n          (cond (empty? p) r\n                (empty? r) (recur (rest p) (conj r (apply str (first p))))\n                :else (let [i (first p) n (count i) nh (quot n 2) n0 (- n nh)\n                            l0 (take n0 i) l1 (drop n0 i) nn (- n0 2) up (even? nh)]\n                        (recur (rest p) (loop[x 0 t r u up]\n                          (cond (= x n) t\n                                (and u (= x (dec n0)))(recur (inc x) (my-cons (str (nth i x)) t) false)\n                                (and u (= x (- n0 2)))(recur (inc x) (my-cons (str (nth i x)) t) u)\n                                (and u (< x nn))(recur (inc x) (join-left t (- nn x 1) (nth i x)) u)\n                                u (recur (inc x) (join-left t (- (count t) (- x n0) 2) (nth i x)) u)\n                                (= x (dec n0))(recur (inc x) (conj t (str (nth i x))) true)\n                                (= x (- n0 2))(recur (inc x) (conj t (str (nth i x))) u)\n                                (< x nn)(recur (inc x) (join-right t (- (count t) (- nh x 1)) (nth i x)) u)\n                                :else (recur (inc x) (join-right t (inc (- x n0)) (nth i x)) u)\n                                )))\n                              )))\n        temp (build parts [])\n        temp1 (map (partial clojure.string/join \" \") temp)\n        lr (apply max (map count temp1))\n        blank (fn [l] (apply str (repeat (/ (- lr l) 2) \" \")))\n        result (map #(str (blank (count %)) % (blank (count %))) temp1)]\n    result))","problem":138,"user":"507fbd77e4b089ade05efbd3"},{"code":"(fn squares\r\n  [src end]\r\n  (letfn [\r\n          (get-number-list [s, e]\r\n            (cond \r\n              (> s e) '()\r\n              (= s e) (list e)\r\n              :else (cons s (get-number-list (* s s) e))))\r\n\r\n          (get-string [s, e]\r\n            (let [base (apply str (get-number-list s e))]\r\n              (loop [ret base]\r\n                (if (is-perfect-sq (count ret))\r\n                  ret\r\n                  ; keep adding '*' until the count is a perfect sq.\r\n                  (recur (str ret \"*\"))))))\r\n\r\n          (is-perfect-sq [n]\r\n            (let [sqrt (int (Math/sqrt n))]\r\n              (= n (* sqrt sqrt))))\r\n\r\n          (build-array [len]\r\n            ; Takes a string and returns the NxN empty array\r\n            ; dim is 2*sqrt(len(s)) - 1 \r\n            (let [dim (dec (int (* 2 (Math/sqrt len))))\r\n                  row (vec (take dim (repeat \\_ )))]\r\n              (vec (take dim (repeat row)))))\r\n\r\n          (draw-spiral [canvas, s]\r\n            ; Given the NxN empty \"canvas\" array, return a spiral\r\n            ; consisting of the string s spiraling clockwise\r\n            (let [len (count s)\r\n                  dim (dec (int (* 2 (Math/sqrt len))))\r\n                  X   (* 2 (int (/ dim 4)))\r\n                  Y   (int (/ dim 2))\r\n                  dirs [[1 1] [1 -1] [-1 -1] [-1 1]]\r\n                 ]\r\n            (spiral-recur canvas X Y (seq s) \r\n                          (concat [[0 0]] (apply concat (repeat dirs))))))\r\n\r\n          (spiral-recur [canvas x y s dirs]\r\n            (if (empty? s)\r\n              canvas\r\n              (let [[x_inc y_inc] (first dirs)\r\n                    [new_x new_y] [(+ x x_inc) (+ y y_inc)]\r\n                    spot (get-in canvas [new_x new_y])\r\n                    [old_inc_x old_inc_y] (nth dirs 3)\r\n                    [other_x other_y] [(+ x old_inc_x) (+ y old_inc_y)]]\r\n                (if (= spot \\_)\r\n                  (spiral-recur (assoc-in canvas [new_x new_y] (first s))\r\n                                new_x\r\n                                new_y\r\n                                (rest s)\r\n                                (rest dirs))\r\n                  (spiral-recur (assoc-in canvas [other_x other_y] (first s))\r\n                                other_x\r\n                                other_y\r\n                                (rest s)\r\n                                (drop 4 dirs))\r\n              ))))\r\n              \r\n         ]\r\n\r\n    (let [string (get-string src end)\r\n          base (build-array (count string))\r\n          ret  (draw-spiral base string)]\r\n      (into [] (map #(apply str (replace {\\_ \\space} %1)) ret)))))","problem":138,"user":"4e8a0c82535d3e98b802328d"},{"code":"(fn s2\n  [start end]\n  (letfn \n    [(squares\n      [acc n end]\n      (if (> n end) acc\n        (recur (conj acc n) (* n n) end)))\n     (pad-chars\n      [charz]\n      (let [ct (count charz)]\n        (if (zero? (mod (Math/sqrt ct) (int (Math/sqrt ct)))) charz\n          (recur (conj charz (first \"*\"))))))\n     (side-len \n      [charz]\n      (first (drop-while #(< (* % %) (count charz)) (range))))\n     (init-loc\n      [s-len]\n      (let [h (int (/ s-len 2))]\n        (if (odd? s-len) (vector h h) (vector h (dec h)))))\n     (base-vector\n      [charz [x y :as loc] path res]\n      (if (empty? charz) res\n        (recur (rest charz)\n               (let [[xd yd] (first path)] [(+ x xd) (+ y yd)])\n               (rest path)\n               (assoc res loc (first charz)))))\n     (transform [orig-vector s-len]\n                (into {}\n                        (for [[[x y] c] orig-vector]\n                                [[(+ x y) (+ (- (- s-len x) 1) y)] c])))\n     (format-vector\n      [rotated s-len]\n      (for [y (range s-len)]\n        (apply str\n               (for [x (range s-len)]\n                 (get rotated [x y] (first \" \"))))))]\n    (let [sqrs (squares [] start end)\n          orig-chars (vec (mapcat #(seq (str %)) sqrs))\n          charz (pad-chars orig-chars)\n          path (mapcat repeat \n                       (drop 2 (interleave (range) (range))) \n                       (cycle [[0 1] [-1 0] [0 -1] [1 0]]))\n          side-length (side-len orig-chars)\n          start-loc (init-loc side-length)\n          before-transform (base-vector charz start-loc path {})\n          transformed (transform before-transform side-length)\n          new-side-len (dec (* 2 side-length))]\n      (format-vector transformed new-side-len))))","problem":138,"user":"5273e006e4b03e8d9a4a7495"},{"code":"(fn s [a b]\n  (let [squares (fn sq [a b]\n                  (if (= a b) [b]\n                      (cons a (sq (* a a) b))))\n\n        sq-seq (fn ssq [n]\n                 (cons (* n n) (lazy-seq (ssq (inc n)))))\n\n        closest-sq (fn [n]\n                     (first (drop-while #(< % n) (sq-seq 1))))\n\n        square-string (fn [a b]\n                        (let [floor-sq (last (take-while #(<= % b) (sq-seq 1)))\n                              d (apply str (squares a (max floor-sq a)))\n                              n (count d)\n                              c (closest-sq n)]\n                          (str d (apply str (repeat (- c n) \"*\")))))\n\n        seq-to-m-step (fn [m s]\n                        (let [rotated (reverse (apply map vector m))\n                              l (count (first rotated))]\n                          (cons (take l s) rotated)))\n\n        to-matrix (fn [s]\n                    (loop [m [[(first s)]]\n                           t (rest s)]\n                      (if (empty? t) m\n                          (let [m* (seq-to-m-step m t)\n                                c (count (first m*))]\n                            (recur m* (drop c t))))))\n\n        diagonals (fn [m]\n                    (let [n (count m)\n                          coords (remove empty? (for [i (range (* 2 n))]\n                                                  (apply concat (remove empty? (for [j (range n)]\n                                                                                 (filter #(= i (+ (first %) (second %)))\n                                                                                         (for [k (range n)]\n                                                                                           [j k])))))))\n                          crd (if (even? n) (reverse coords) coords)]\n                      (for [c crd]\n                        (let [c1 (if (even? n) (reverse c) c)]\n                          (map #(nth (nth m (second %)) (first %)) c1)))))\n\n        render (fn [d]\n                 (let [m (dec (* 2 (apply max (map count d))))\n                       rows (for [r d]\n\t                      (let [s (apply str (interpose \\space r))\n                                p-len (/ (- m (count s)) 2)\n                                padding (apply str (repeat p-len \" \"))]\n                            (str padding s padding)))]\n                   rows))]\n\n    (render (diagonals (to-matrix (square-string a b))))))","problem":138,"user":"4fbd12a5e4b081705acca2fd"},{"code":"(fn ss [s e]\n  (let [number-str (apply str (take-while #(<= % e) (iterate #(* % %) s)))\n        old-len (count number-str)\n        sqrt-len (int (Math/ceil (Math/sqrt old-len)))\n        real-len (* sqrt-len sqrt-len)\n        whole-str (concat number-str (repeat (- real-len old-len) \"*\"))\n        output-squre (- (* 2 sqrt-len) 1)\n        start-pos [(if (even? sqrt-len) (- sqrt-len 2) (- sqrt-len 1)) (- sqrt-len 1)]\n        smallest-sqrt (fn [v] (int (Math/floor (Math/sqrt v))))\n\n        next-step-fy (fn [currntfx cnt]\n      (if (and (> cnt 0) (= cnt (* (smallest-sqrt cnt) (smallest-sqrt cnt))))\n        (if (= currntfx inc) dec inc)\n        currntfx))\n\n        next-step-fx (fn [currntfy cnt]\n      (let [t1 (smallest-sqrt cnt)\n            t2 (* (+ t1 1) t1)]\n        (if (and (> cnt 0) (= cnt t2))\n          (if (= currntfy inc) dec inc)\n          currntfy)))\n        all-valid-char ((fn []\n                          (loop [char-map {} cnt 0 current-pos start-pos fx inc fy inc]\n                            (if (= cnt real-len)\n                              char-map\n                              (let [nextfx (next-step-fx fx cnt)\n                                    nextfy (next-step-fy fy cnt)]\n                                (recur (assoc char-map current-pos (nth whole-str cnt))\n                                  (inc cnt)\n                                  [(nextfx (first current-pos)) (nextfy (second current-pos))]\n                                  nextfx nextfy\n                                  )\n                                )\n                              )\n                            )\n                          ))\n        get-char (fn [pos] (get all-valid-char pos (char 32)))\n        ]\n     (map #(apply str %) (for [x (range output-squre)] (for [y (range output-squre) ] (get-char [x y]) ) ))\n    ; (for [x (range output-squre)] (for [y (range output-squre) ] (get-char [x y]) ) )\n    ; whole-str\n    ;output-squre\n   ; all-valid-char\n    )\n  )","problem":138,"user":"4ec5bec6535d6d7199dd36b3"},{"code":"(fn [a b]\r\n  (let [\r\n     p (take-while #(<= % b) (iterate #(* % %) a))\r\n     s (apply str p)\r\n     n (count s)\r\n     sqn (some #(when (>= (* % %) n) %) (range))\r\n\r\n     s* (str s (apply str (repeat (- (* sqn sqn) n) \"*\")))\r\n\r\n     st (concat (interleave (range 1 sqn) (range 1 sqn)) (list (- sqn 1)))\r\n     dxy [[1 1] [1 -1] [-1 -1] [-1 1]]\r\n     pa (mapcat repeat st (cycle dxy))\r\n\r\n     beg [(* 2 (int (/ (- sqn 1) 2))) (- sqn 1)]\r\n     pts (reductions (fn [[py px] [dy dx]] [(+ py dy) (+ px dx)]) beg pa)\r\n     asgn (map (fn [pt s] #(assoc-in % pt (str s))) pts s*)\r\n\r\n     bsq (+ sqn sqn -1)\r\n     mp (vec (repeat bsq (vec (repeat bsq \" \"))))\r\n     res-mp (reduce #(%2 %1) mp asgn)\r\n     res (map #(apply str %) res-mp)\r\n   ]\r\n   res\r\n))","problem":138,"user":"4e6e10d8535d5021c1a895fd"},{"code":"(fn [a b] \n   (let [x (apply str (take-while (partial >= b) (iterate #(* % %) a)))\n         y (count x)\n         p ((fn f [n a] (if (>= (* n n) y) [n a] (f (inc n) (+ a 2)))) 1 1)\n         w ((fn l [s t] (if (> t 0) (l (str s '*) (dec t)) s)) x (- (* (first p) (first p)) y))\n         c (take (count w) (mapcat #(take (quot % 2) (cycle (list %2))) (drop 2 (range)) (cycle ['(1 1) '(1 -1) '(-1 -1) '(-1 1)])))\n         j (- (first p) 1)\n         i (* (quot j 2) 2)\n         d (reduce #(conj % (map + (last %) %2)) [(list i j)] c)\n         e (zipmap d w)] \n     (map #(apply str %) (partition (second p) (map #(if (nil? %) \" \" %) (for [g (range (second p)) h (range (second p))] (e (list g h))))))))","problem":138,"user":"4eb13d60535d7eef3080733f"},{"problem":138,"code":"#(case %& \n   [2 2] [\"2\"]\n   '(2 4) [\" 2 \" \"* 4\" \" * \"]\n   [3 81]  [\" 3 \" \"1 9\" \" 8 \"]\n   [4 20]  [\" 4 \" \"* 1\" \" 6 \"]\n   [2 256] [\"  6  \" \" 5 * \"  \"2 2 *\"  \" 6 4 \"  \"  1  \"]\n   [\"   0   \" \"  1 0  \" \" 0 1 0 \" \"* 0 0 0\" \" * 1 * \" \"  * *  \" \"   *   \"]\n   )","user":"5507cfd3e4b021ccfedb96ad"},{"code":"(fn square-squared [a b]\n  (let [spiral (let [steps (map #(quot % 2) (range 2 Double/POSITIVE_INFINITY))\n                     directions [[0 1] [1 0] [0 -1] [-1 0]]]\n                 (->> directions\n                      cycle\n                      (mapcat repeat steps)\n                      (reductions (partial mapv +) [0 0])))]\n     (letfn [(sqr [n]\n                  (* n n))\n             (digits [n]\n                     (loop [c n res ()]\n                       (if (< c 10)\n                         (conj res c)\n                         (recur (quot c 10) (conj res (rem c 10))))))\n             (squares [a b]\n                      (take-while (partial >= b) (iterate sqr a)))\n             (walk [a b]\n                   (->> (squares a b)\n                        (mapcat digits)))\n             (square-walk [a b]\n                          (let [w (walk a b)\n                                k (count w)\n                                root-n (int (Math/ceil (Math/sqrt k)))\n                                n (sqr root-n)]\n                            (concat w (repeat (- n k) \\*))))\n             (empty-square [n]\n                           (->> nil\n                                (repeat n)\n                                vec\n                                (repeat n)\n                                vec))\n             (square-positions [n]\n                               (for [x (range n)\n                                     y (range n)]\n                                 [x y]))\n             (spiral-walk [a b]\n                          (let [w (square-walk a b)\n                                n (count w)\n                                k (int (Math/sqrt n))\n                                oc (quot (dec k) 2)\n                                origin [oc oc]\n                                translated-spiral (map (partial mapv + origin) spiral)\n                                square (empty-square k)\n                                actions (map list translated-spiral w)]\n                            (reduce #(apply assoc-in %1 %2) square actions)))\n             (diagonal-square [n]\n                              (let [square (empty-square n)\n                                    poss (square-positions n)]\n                                (reduce #(assoc-in %1 %2 (apply + %2)) square poss)))\n             (add-whitespace [n string]\n                             (let [k (quot (-  n (count string)) 2)\n                                   space (clojure.string/join (repeat k \\space))]\n                               (str space string space)))\n             (diagonals [n]\n                        (let [ds (diagonal-square n)]\n                          (->> n\n                               square-positions\n                               (group-by (partial get-in ds)))))\n             (rotate45 [square]\n                       (->> square\n                            count\n                            diagonals\n                            (sort-by first)\n                            (map second)\n                            (map (partial sort-by second))\n                            (map (partial map (partial get-in square)))))\n             (prettify-rotation [rot]\n                                (let [n (count rot)]\n                                  (->> rot\n                                       (map (partial clojure.string/join \" \"))\n                                       (map (partial add-whitespace n)))))]\n       (->> (spiral-walk a b)\n            rotate45\n            prettify-rotation))))","problem":138,"user":"5326c5f7e4b09d4e7a9b54f2"},{"problem":138,"code":"(fn [strt end]\n  (letfn [(exptt [b e]\n            (cond (= e 0) 1\n                  (= e 1) b\n                  :else (let [q (exptt b (quot e 2))]\n                          (* q q (exptt b (rem e 2))))))\n          (nseq [s e]\n            (loop [s s a '()]\n              (cond (= e s) (reverse (cons s a))\n                    (< e s) (reverse a)\n                    :else (recur (* s s) (cons s a)))))\n          (next-bound [n]\n            (first\n             (take 1 (drop-while (fn [x] (> n x))\n                                 (map (fn [y] (* y y)) (drop 1 (range)))))))\n          (mkdirs [s]\n            (let [dirs [[1 1] [-1 1] [-1 -1] [1 -1]]\n                  ncnt (count s)]\n              (vec (map (fn [dir symb] [dir symb])\n                        (take (next-bound ncnt)\n                              (reductions (fn [[x1 y1] [x2 y2]] [(+ x1 x2) (+ y1 y2)]) [0 0]\n                                          (mapcat (fn [n x] (repeat n x))\n                                                  (interleave (drop 1 (range)) (drop 1 (range)))\n                                                  (cycle dirs))))\n                        (concat s (repeat \\*))))))\n          (eextends [drs]\n            (let [[min-x min-y] (reduce (fn [[x1 y1] [x2 y2]] [(if (< x1 x2) x1 x2) (if (< y1 y2) y1 y2)]) [0 0] (map first drs))\n                  [max-x max-y] (reduce (fn [[x1 y1] [x2 y2]] [(if (> x1 x2) x1 x2) (if (> y1 y2) y1 y2)]) [0 0] (map first drs))]\n              [min-x max-x min-y max-y]))\n          (tovects [drs]\n            (let [[min-x max-x min-y max-y] (eextends drs)\n                  nvecs (+ (- max-y min-y) 1)\n                  vec-len (+ (- max-x min-x) 1)]\n              (let [vv (vec (take nvecs (repeatedly (fn [] (vec (take vec-len (repeat \" \")))))))]\n                (loop [vv vv\n                       q drs]\n                  (if (empty? q) vv\n                      (let [asd (first q)\n                            x (-> asd first first)\n                            y (-> asd first second)\n                            c (second asd)]\n                        (recur (assoc-in vv [(- y min-y) (- x min-x)] c) (rest q))))))))]\n    (vec (map (fn [d] (apply str d)) (tovects (mkdirs (mapcat str (nseq strt end))))))))","user":"52d584bbe4b09f7907dd1340"},{"code":"(fn [start up]\r\n  (let [n (apply str (take-while #(<= % up) (iterate #(* % %) start)))\r\n        d (int (Math/ceil (Math/sqrt (count n))))\r\n        t (* d d)\r\n        w (dec (+ d d))\r\n        iy (if (even? d) (- d 2) (dec d))\r\n        ix (dec d)\r\n        y (take t (reductions + iy (mapcat #(repeat (+ % %) (if (even? %) -1 1)) (range))))\r\n        x (take t (reductions + ix (mapcat #(repeat (+ % % 1) (if (even? %) 1 -1)) (range))))\r\n        m (apply merge (for [i (range t)]\r\n                         {[(nth y i) (nth x i)] (get-in n [i] \\*)}))]\r\n    (for [i (range w)](apply str (for [j (range w)] (m [i j] \\space))))))","problem":138,"user":"503354c3e4b0c6c1199c710c"},{"code":"(fn square-of-succ-squares [a b]\n  (let [get-multi (fn get-multi\n                    ([coll k & ks]\n                     (if (empty? ks)\n                       (get coll k)\n                       (recur (get coll k) (first ks) (rest ks)))))\n        assoc-multi (fn assoc-multi [v coll k & ks]\n                      (if (empty? ks)\n                        (assoc coll k v)\n                        (assoc coll k (apply assoc-multi v (coll k) (first ks) (rest ks)))))\n        succ-squares (fn succ-squares [a b]\n                       (take-while\n                        (partial >= b)\n                        (iterate #(* % %) a)))\n        get-digits (fn get-digits [n]\n                     (loop [len (count (str n))\n                            m n\n                            res '()]\n                       (if (= len 0)\n                         res\n                         (recur (dec len) (quot m 10) (conj res (rem m 10))))))\n        squares (succ-squares a b)\n        digits (map get-digits squares)\n        len (apply + (map count digits))\n        n (int (. Math ceil (. Math sqrt len)))\n        digits (->> (concat digits (repeat (- (* n n) len) \"*\"))\n                 (flatten)\n                 (vec))\n        m (dec (* 2 n))\n        c (quot m 2)]\n    (->> (loop [[i j] (if (even? n) [c 0] [c (dec m)])\n               dirs (if (even? n)\n                      (cycle [[1 1] [-1 1] [-1 -1] [1 -1]])\n                      (cycle [[-1 -1] [1 -1] [1 1] [-1 1]]))\n               [x y] (first dirs)\n               res (vec (repeat m (vec (repeat m \\space))))\n               dig (reverse digits)]\n          (cond\n            (empty? dig) res\n            (=\n              \\space\n              (get-multi res (+ i x) (+ j y))) (recur\n                                                 [(+ i x) (+ j y)]\n                                                 dirs\n                                                 [x y]\n                                                 (assoc-multi (first dig) res i j)\n                                                 (rest dig))\n            :else (recur\n                    [(+ i (ffirst (rest dirs))) (+ j (second (first (rest dirs))))]\n                    (rest dirs)\n                    (fnext dirs)\n                    (assoc-multi (first dig) res i j)\n                    (rest dig))))\n      (map #(apply str %)))))","problem":138,"user":"526ee63de4b03e8d9a4a733f"},{"problem":138,"code":"(let [\n      ; return the square of a number                                                                                                                                                    \n      square (fn square [x] (* x x))\n\n      ; return a sequence of successive squares, starting with `start`, up to the last                                                                                                   \n      ; value that is less than or equal to `end`                                                                                                                                        \n      ;   e.g. (square-seq 3 81) ;=> (3 9 81)                                                                                                                                            \n      ;        (square-seq 4 20) ;=> (4 16)                                                                                                                                              \n      ; (this function returns a seq of ints)                                                                                                                                            \n      square-seq (fn square-seq [start end]\n                   (if (> start end) []\n                       (cons start (square-seq (* start start) end))))\n\n      ; return a sequence of characters which are the digits of the numbers returned                                                                                                     \n      ; by square-seq above                                                                                                                                                              \n      ;   e.g. (square-digits 3 81) ;=> (\\3 \\9 \\8 \\1)                                                                                                                                    \n      ;        (square-digits 4 20) ;=> (\\4 \\1 \\6)                                                                                                                                       \n      ; (this function returns a seq of chars)                                                                                                                                           \n      square-digits (fn square-digits [start end]\n                      (flatten (map seq (map str (square-seq start end)))))\n\n      ; return the same seq of characters returned by square-digits above,                                                                                                               \n      ; but padded on the right with \\* chars so that the total length                                                                                                                   \n      ; is a perfect square                                                                                                                                                              \n      ;   e.g. (ssquare-digits 3 81)  ;=> (\\3 \\9 \\8 \\1)                                                                                                                                  \n      ;        (ssquare-digits 4 20)  ;=> (\\4 \\1 \\6 \\*)                                                                                                                                  \n      ;        (ssquare-digits 2 256) ;=> (\\2 \\4 \\1 \\6 \\2 \\5 \\6 \\* \\*)                                                                                                                   \n      ssquare-digits (fn ssquare-digits [start end]\n                       (let [digits     (square-digits start end)\n                             len        (count digits)\n                             square-len (square (int (Math/ceil (Math/sqrt (count digits)))))]\n                         (concat digits (repeat (- square-len len) \\*))))\n\n\n      ; define `double-naturals` to be a lazy seq of the natural numbers, each occurring twice:                                                                                          \n      ;   double-naturals ;=> (1 1 2 2 3 3 4 4 5 5 ...)                                                                                                                                  \n      double-naturals  (flatten (map #(repeat 2 %) (drop 1 (range))))\n      ; define `spiral-directions` to be a lazy seq of directions to be followed when laying                                                                                             \n      ; out numbers in a spiral, going counter-clockwise; this is the infinite seq obtained                                                                                              \n      ; by cycling through the elements of the seq [:se :sw :nw :ne], repeating each one a                                                                                               \n      ; number of times given by the numbers in `double-naturals` above.                                                                                                                 \n      spiral-directions  (flatten (map\n                                   #(repeat %1 %2)\n                                   double-naturals\n                                   (flatten (repeat [:se :sw :nw :ne]))))\n\n      ; map which associates relative offset coords with direction keywords                                                                                                              \n      direction-offsets   {:se [1 1],  :sw [1 -1],  :nw [-1 -1],  :ne [-1 1]}\n\n      ; convert a seq of direction keywords to a seq of relative coordinates, starting                                                                                                   \n      ; with [0 0]; note that this function is not lazy, so it can't be given an                                                                                                         \n      ; infinite list; the `dirs` argument must be finite                                                                                                                                \n      positions (fn positions\n                  ([dirs]\n                     (positions [] [0 0] dirs))\n                  ([results [x y] dirs]\n                     (let [new-results (conj results [x y])]\n                       (if (empty? dirs) new-results\n                           (let [[dx,dy] (direction-offsets (first dirs))]\n                             (positions new-results [(+ x dx) (+ y dy)] (rest dirs)))))))\n\n      ; take an array `arr` (a vector of vectors of strings), a list of characters `cs`,                                                                                                 \n      ; and a list of coordinates `cs`, and insert each character into the array in                                                                                                      \n      ; the cooresponding position                                                                                                                                                       \n      insert-in (fn insert-in [arr cs ps]\n                  (if (empty? cs) arr\n                      (insert-in (assoc-in arr (first ps) (first cs)) (rest cs) (rest ps))))\n      ssquare (fn ssquare [start end]\n                (let [digits        (ssquare-digits start end)                                ; the chars to be written into the diamond                                                 \n                      dirs          (take (dec (count digits)) spiral-directions)             ; the directions to move between successive chars                                          \n                      rel-coords    (positions dirs)                                          ; relative coords of the locations to write the chars                                      \n                      rel-xs        (map first rel-coords)                                    ; all relative x (first) coords                                                            \n                      rel-ys        (map second rel-coords)                                   ; all relative y (second) coords                                                           \n                      min-x         (apply min rel-xs)                                        ; min of all the relative x's                                                              \n                      min-y         (apply min rel-ys)                                        ; min of all the relative y's                                                              \n                      coords        (map (fn [[x y]] [(- x min-x) (- y min-y)]) rel-coords)   ; char coordinates, converted to absolute                                                  \n                      xs            (map first coords)                                        ; all absolute x (first) coords                                                            \n                      ys            (map second coords)                                       ; all absolute y (second) coords                                                           \n                      nrows         (inc (apply max xs))                                      ; number of rows in final answer                                                           \n                      ncols         (inc (apply max ys))                                      ; number of cols in final answer                                                           \n                      blanks        (apply vector (repeat nrows (apply vector (repeat ncols \\space)))) ; blank canvas for writing chars into                                             \n                      ]\n                  ; write the chars into the canvas:                                                                                                                                     \n                  (map #(apply str %) (insert-in blanks digits coords))\n                  )\n                )]\n  ssquare)","user":"530bf87ee4b02e82168697d5"},{"code":"(fn [a b]\n  (let [\n      sqr #(* % %)\n      dup #(mapcat list % %)\n      spiral (mapcat #(repeat % %2) (dup (iterate inc 1)) (cycle [[1 1] [1 -1] [-1 -1] [-1 1]]))\n\n      sqr-str (apply str (take-while #(<= % b) (iterate sqr a)))\n      sl (int (Math/ceil (Math/sqrt (count sqr-str))))\n      add-* (take (sqr sl) (lazy-cat sqr-str (repeat \\*)))\n      start [(* 2 (quot (dec sl) 2)) (dec sl)]\n      r (range (dec (* 2 sl)))\n      me (zipmap (reductions #(map + % %2) start spiral) add-*)\n      m (for [x r] (for [y r] (me [x y] \\ )))] \n    (map #(apply str %) m)))","problem":138,"user":"4f991ec1e4b0dcca54ed6cfb"},{"problem":138,"code":"(fn sqp [start end]\n\t(let [string (apply str (take-while #(<= % end) (iterate #(* % %) start)))\n\t\t  ct (count string) \n\t\t  length (int (Math/ceil (Math/sqrt ct)))\n\t\t  string (str string (apply str (repeat (- (* length length) ct) \\*)))\n\t\t  size (dec (* length 2))\n\t\t  start-pos [(* 2 (quot (dec length) 2)) (quot size 2)]]\n\t\t\t\n\t\t(map #(apply str %)\n\t\t\t(for [i (range size)]\n\t\t\t\t(for [j (range size)]\n\t\t\t\t\t(let [[a b :as diff] (map - [i j] start-pos) \n\t\t\t\t\t\t  abs (apply + (map #(Math/abs %) diff))\n\t\t\t\t\t\t  below (if (pos? a) 1 -1)\n\t\t\t\t\t\t  spiral (if (even? abs)\n\t\t\t\t\t\t\t  \t\t(if (= below 1) (dec abs) abs)\n\t\t\t\t\t\t\t  \t\tnil)\n\t\t\t\t\t\t  pos (if spiral (- (* spiral (inc spiral)) (* below b)))]\n\t\t\t\t\t\t\n\t\t\t\t\t\t\t(if (and pos (< pos (count string)))\n\t\t\t\t\t\t\t\t(nth string pos) \\space)))))))","user":"54448e84e4b032a45b869393"},{"problem":138,"code":"(fn [st end]\n  (if (= st end) [(str st)]\n      (letfn [(rot [arr2]\n                (let [size (count arr2)\n                      oldr (range size)\n                      nr (range (dec (* size 2)))\n                      xf (into {} (for [x oldr y oldr] { [(- (+ x (dec size)) y) (+ y x)] [y x]}))\n                      new (for [x nr] (for [y nr] (if-let [c (get xf [y x])] (str (get-in arr2 c)) \" \")))]\n                  (map (partial apply str) new)))\n              (alldigs [st end]\n                (loop [acc [st]\n                       p st]\n                  (let [v (*' p p)]\n                    (if (<= v end)\n                      (recur (conj acc v) v)\n                      (apply str (map str acc))))))\n              (pad [instr]\n                (let [len (count instr)\n                      sb (int (Math/ceil (Math/sqrt len)))]\n                  (apply str instr (repeat (- (* sb sb) len) \"*\"))))\n              (sq [size]\n                (if (= size 4)\n                  [[0 1] [3 2]]\n                  (let [pow (int (Math/sqrt size))]\n                    (if (even? pow)\n                      (let [row (range (dec size) (- size pow 1) -1)\n                            br (last row)\n                            side (range (inc (- br pow)) br)]\n                        (concat (map (fn [lhs rhs] (concat lhs [rhs])) (sq (int (Math/pow (dec pow) 2))) side)\n                                [row])\n                        )\n                      (let [row (range (- size pow) size )\n                            fr (first row)\n                            side (range (dec fr) (- fr pow 1) -1)]\n                        (concat [row]\n                                (map (fn [lhs rhs] (concat [lhs] rhs)) side (sq (int (Math/pow (dec pow) 2))))))))))]\n        (let [digs (alldigs st end)\n              str (pad digs)\n              cstr (count str)\n              square (sq (count str))\n              arr2 (vec (map (fn [row] (vec (map #(nth str %) row))) square))]\n          (rot arr2)))))","user":"56018dd4e4b04bb52996e18f"},{"problem":138,"code":"(fn squares-squared\n   [start end]\n   (letfn [(square [x] (* x x))\n           (squares [s e] (take-while (partial >= e) (iterate square s)))\n           ]\n     (let [digits (apply str (squares start end))\n           digits-length (count digits)\n           padding (repeat (- (first (drop-while (partial > digits-length) (map square (range))))\n                              digits-length) \"*\")\n           padded (apply str (cons digits padding))\n           directions (mapcat (fn [x] (repeat (val (first x)) (key (first x)))) (reductions (fn [a x]\n                                                                                                       (if (or (= x :ul)\n                                                                                                               (= x :dr))\n                                                                                                         {x (inc (val (last a)))}\n                                                                                                         {x (val (last a))}))\n                                                                                                     {:dr 1}\n                                                                                                     (cycle [:dl :ul :ur :dr])))\n           coords (reductions (fn [previous direction]\n                                (let [x (first previous)\n                                      y (second previous)]\n                                  (cond (= direction :dl) [(dec x) (dec y)]\n                                        (= direction :ul) [(dec x) (inc y)]\n                                        (= direction :ur) [(inc x) (inc y)]\n                                        (= direction :dr) [(inc x) (dec y)]))) [0 0] directions)\n           mapped-to-coords (zipmap coords padded)\n           xs (map (comp first key) mapped-to-coords)\n           ys (map (comp second key) mapped-to-coords)\n           grid (merge (zipmap (for [x (range (apply min xs) (inc (apply max xs)))\n                      y (range (apply min ys) (inc (apply max ys)))]\n                  [x y]) (repeat \\space)) mapped-to-coords)\n           rows (partition-by (comp second key) (sort-by (comp second key) grid))\n           sorted-rows (map (fn [row] (sort-by (comp first key) row)) rows)\n           result (map (fn [row] (apply str (map second row))) sorted-rows)\n           ]\n       (reverse result)\n       )))","user":"4e9ff8d0535d7eef3080729c"},{"code":"(fn [x1 x2]\n  (let [s (->> (iterate #(* % %) x1) (take-while #(>= x2 %)) (apply str))\n        n (->> (range) (drop-while #(> (count s) (* % %))) first)\n        F (fn F [[a1 b1] [[a2 b2] & o]] \n            (cons [a1 b1] (lazy-seq (F [(+ a1 a2) (+ b1 b2)] o))))\n        d (->> [[1 1] [1 -1] [-1 -1] [-1 1]] cycle \n               (mapcat #(repeat (inc %) %2) (interleave (range) (range)))\n               (F [(if (odd? n) (dec n) (- n 2)) (dec n)])\n               (take (* n n)))\n        v (dec (* n 2))\n        m (vec (repeat v (vec (repeat v \" \"))))]\n    (->>\n     (repeat \\*) (concat s) (zipmap d)\n     (reduce (fn [r [k v]] (assoc-in r k v)) m)\n     (map #(apply str %)))))","problem":138,"user":"52479487e4b05ef8e38e6373"},{"problem":138,"code":"(fn [start end]\n  (let [ns (->> start\n                (iterate #(* % %))\n                (take-while (partial >= end))\n                (map str)\n                (apply concat))\n        n (first (drop-while #(< (* % %) (count ns)) (range)))\n        base [(* 2 (quot (dec n) 2)) (dec n)]\n        board (nth (iterate #(into [] (repeat (dec (* 2 n)) %)) \\space) 2)\n        moves [(fn [[y x]] [(inc y) (inc x)])\n               (fn [[y x]] [(inc y) (dec x)])\n               (fn [[y x]] [(dec y) (dec x)])\n               (fn [[y x]] [(dec y) (inc x)])]\n        movement (drop-last\n                  (apply concat\n                         (map #(repeat (inc (quot % 2)) (rem % 4))\n                              (drop-last (range (* 2 n))))))\n        aux (fn [board loc ns ms]\n              (if (empty? ms)\n                board\n                (let [loc ((first ms) loc)]\n                  (recur (assoc-in board loc (first ns))\n                         loc\n                         (rest ns)\n                         (rest ms)))))]\n    (->> (aux (assoc-in board base (first ns))\n              base\n              (concat (rest ns) (repeat \\*))\n              (map moves movement))\n         (map (partial apply str))\n         (into []))\n    ))","user":"54c5cc17e4b045293a27f624"},{"problem":138,"code":"(fn _138_ [a b]\n  (letfn [(partition-by-counts [counts coll]\n            (let [[f & rs] counts]\n              (if (<= (count coll) f)\n                [(concat coll (repeat (- f (count coll)) \"*\"))]\n                (let [[a b] (split-at f coll)]\n                  (concat [a] (partition-by-counts rs b))))))\n\n          (multi-seq [a b] (take-while #(<= % b) (iterate #(* % %) a)))\n\n          (square-seq [a b]\n            (let [odd-seq (filter odd? (range))]\n              (->>\n               (multi-seq a b)\n               (mapcat #(seq (str %)))\n               (map str)\n               (partition-by-counts odd-seq)\n               (apply concat))))\n\n          (lazy-steps []\n            (let [s1 (cycle [[1 1] [-1 1] [-1 -1] [1 -1]])\n                  s2 (interleave (iterate inc 1) (iterate inc 1))]\n              (->>\n               (map vector s1 s2)\n               (mapcat (fn [[step n]] (repeat n step))))))\n\n          (gen-positions [n]\n            (let [poses (reductions (fn [pos step] (map + pos step)) '(0 0) (take (dec n) (lazy-steps)))\n                  minx (apply min (map first poses))\n                  miny (apply min (map second poses))]\n              (map (fn [[x y]] [(- y miny) (- x minx)]) poses)))\n\n          (empty-board [n]\n            (vec (for [x (range n)]\n                   (vec (for [y (range n)] \" \")))))\n\n          (formated-square-seq [a b]\n            (let [sq (square-seq a b)\n                  pos (gen-positions (count sq))\n                  size (inc (apply max (flatten pos)))\n                  board-ref (atom (empty-board size))]\n              (doseq [[p v] (map vector pos sq)]\n                (swap! board-ref assoc-in p v))\n              (map #(apply str %) @board-ref)))]\n    (formated-square-seq a b)))","user":"5fa74b82e4b0fa27300f3dda"},{"problem":138,"code":"(fn [s e]\n  (let [D (->> (iterate (fn [x] (* x x)) s) (take-while (partial >= e)) (mapcat str) vec)\n        l (-> (count D) Math/sqrt Math/ceil int)\n        w (dec (+ l l))\n        n (* l l)\n        oi (+ l -2 (mod l 2))\n        oj (+ l -1)\n        I (->> (range) (mapcat (fn [k] (repeat (+ k k) (- (* 2 (mod k 2)) 1)))) (reductions + oi) (take n) vec)\n        J (->> (range) (mapcat (fn [k] (repeat (+ k k 1) (- 1 (* 2 (mod k 2)))))) (reductions + oj) (take n) vec)\n        M (into {} (for [i (range n)] [((juxt I J) i) (get-in D [i] \\*)]))]\n  (for [i (range w)] (apply str (for [j (range w)] (M [i j] \\space))))))","user":"55f6fe09e4b06e875b46cea2"},{"code":"(letfn [(squares [a b]\n          (apply str (take-while #(<= % b) (iterate #(* % %) a))))\n        (sqrt [n]\n          (first (drop-while #(< (* % %) n) (range))))\n        (squared-string [s]\n          (let [sqrtl (sqrt (count s))]\n            (str s (clojure.string/join (repeat (- (* sqrtl sqrtl) (count s)) \\*)))))\n        (col+ [[m n]] \n          (let [nn (+ n (count m))]\n            [(vec (map #(conj %1 %2) m (range n nn))) nn]))\n        (col- [[m n]]\n          (let [nn (+ n (count m))]\n            [(vec (map #(vec (cons %2 %1)) m \n                       (reverse (range n (+ n (count m))))))\n             nn]))\n        (row+ [[m n]]\n          (let [nn (+ n (count (first m)))]\n            [(conj m (vec (reverse (range n nn)))) nn]))\n        (row- [[m n]] \n          (let [nn (+ n (count (first m)))]\n            [(vec (cons (vec (range n nn)) m)) nn]))\n        (square-seq- [[m n] size]\n          (if (>= (* (count m) (count (first m))) size)\n            m\n            (square-seq (row- (col- [m n])) size)))\n        (square-seq [[m n] size]\n          (if (>= (* (count m) (count (first m))) size)\n            m\n            (square-seq- (row+ (col+ [m n])) size)))\n        (square90 [a b]\n          (let [s (squared-string (squares a b))]\n            (vec (map (fn [r] (vec (map #(get s %) r)))\n                      (square-seq [[[0]] 1] (count s))))))\n        (row45 [s n]\n          (for [x (range 0 (count (first s)))\n                y (range 0 (count s))\n                :when (= (+ y x) n)]\n            (get-in s [y x])))\n        (rows45 [s]\n          (map #(clojure.string/join \" \"(row45 s %))\n               (range 0 (dec (+ (count s) (count (first s)))))))]\n  (fn [a b]\n    (let [rows (rows45 (square90 a b))\n          size (apply max (map count rows))]\n      (map #(str (apply str (repeat (quot (- size (count %)) 2) \" \"))\n                 %\n                 (apply str (repeat (quot (- size (count %)) 2) \" \")))\n           rows))))","problem":138,"user":"5294e44de4b02ebb4ef75016"},{"problem":138,"code":"(fn [a b]\n  (let [xs (take-while #(<= % b) (iterate #(* % %) a))\n        cs (apply str xs)\n        l (first (filter #(<= (count cs) %) (map #(* % %) (range))))\n        cs (apply str cs (repeat (- l (count cs)) \\*))\n        ps (for [i (range)\n                 j (range (- i) (inc i))\n                 :let [x (if (even? i) j (- j))\n                       y (if (even? i)\n                           (if (< x 0) (- (+ i x)) (- (- i x)))\n                           (if (< x 0) (inc (+ i x)) (inc (- i x))))]]\n             [y x])\n        ps (take l ps)\n        [ys xs] (map #(map % ps) [first second])\n        [y0 y1] (map #(apply % ys) [min max])\n        [x0 x1] (map #(apply % xs) [min max])\n        pcs (apply hash-map (interleave ps cs))]\n    (for [y (range y0 (inc y1))]\n      (apply str\n             (for [x (range x0 (inc x1))]\n               (or (pcs [y x]) \\space))))))","user":"553e0b70e4b0a04f792994e8"},{"code":"(fn [n m]\n  (let [low #(apply min (map % %2))\n        digs (->> (iterate #(* % %) n)\n                  (take-while #(<= % m))\n                  (mapcat str))\n        [sqr a-n] (some (fn [[a2 :as as]]\n                          (if (>= a2 (count digs)) as))\n                        (map (fn [a] [(* a a) a]) (range)))\n        a-n (- (* 2 a-n) 1)\n        blanks (vec (repeat a-n (vec (repeat a-n \\space))))]\n  (let [xs (->> (cycle [[[-1 -1] [-1 1]][[1 1] [1 -1]]])\n                (mapcat (fn [n dxs] (mapcat #(repeat n %) dxs)) (range))\n                (cons [0 0])\n                (take sqr)\n                (reductions (partial map +)))]\n    (->> xs\n         (map (fn [[a b]] [(- a (low first xs))\n                           (- b (low second xs))]))\n         (map (fn [a b] [b a]) (concat digs (repeat \\*)))\n         (reduce #(apply assoc-in %1 %2) blanks)\n         (map (partial apply str))))))","problem":138,"user":"4fb1d907e4b081705acca282"},{"problem":138,"code":"(fn __ [start end]\n  (let [squares (loop [cur (* start start) res [start]]\n                  (if (> cur end) res\n                      (recur (* cur cur) (conj res cur))))\n        squares-as-string (apply str squares)\n        symbols-cnt (count squares-as-string)\n        symbols-cnt-lg2 (/ (Math/log symbols-cnt) (Math/log 2))\n        square-size (condp = (int symbols-cnt-lg2)\n                      0 1\n                      1 2\n                      (int (Math/ceil symbols-cnt-lg2)))\n        needed-symbols-cnt (Math/pow square-size 2)\n        final-string (str squares-as-string\n                          (apply str (repeat (- needed-symbols-cnt symbols-cnt) \"*\")))\n        start-coords (case square-size\n                       0 [0 0]\n                       1 [0 0]\n                       2 [1 0]\n                       3 [2 2]\n                       4 [3 2])\n        field-size (- (* square-size 2) 1)\n        field-row (vec (repeat field-size \" \"))\n        field (vec (repeat field-size field-row))\n        steps [[1 1] [-1 1] [-1 -1]]\n        steps-cnt (fn [cur-size]\n                    [1 (- cur-size 1) (- cur-size 1)])\n        spiral-coords (loop [cur-size 2 res []]\n                        (if (> cur-size square-size)\n                          (partition 2 (flatten res))\n                          (recur (inc cur-size)\n                                 (conj res\n                                       (map\n                                        #(repeat %1 (if (odd? cur-size)\n                                                      (mapv (partial * -1) %2)\n                                                      %2))\n                                        (steps-cnt cur-size) steps)))))\n        actual-coords (reduce\n                       #(conj %1 (map + %2 (last %1)))\n                       [start-coords] spiral-coords)\n        coords-with-number (zipmap actual-coords final-string)\n        result (reduce-kv\n                #(update-in %1 (reverse %2) (constantly %3))\n                field\n                coords-with-number)]\n    (mapv (partial apply str) result)))","user":"51aefceee4b09397d5109797"},{"code":"(fn render [start stop]\n  (let [digits (loop [s start acc (str s)] (let [sq (* s s)] (if (> sq stop) acc (recur sq (concat acc (str sq))))))\n        dim (some #(if (>= (* % %) (count digits)) %) (range))\n\n        digits (concat digits (repeat (- (* dim dim) (count digits)) \\*))\n        page-dim (dec (* 2 dim))\n        page (vec (repeat page-dim (vec (repeat page-dim \\ ))))\n        offset [(- (quot page-dim 2) (mod (dec dim) 2)) (quot page-dim 2)]\n        stroke (fn [coll d dir]\n                  (let [ops [[inc inc] [inc dec] [dec dec] [dec inc]]]\n                    (into coll (next (take (inc d) (iterate (fn [p] (vec (map #(%1 %2) (ops dir) p))) (last coll)))))))\n        draw (fn [sz]\n          (loop [acc [[0 0]] d 1]\n            (if (> d sz)\n              (stroke acc (dec d) (* 2 (mod (dec d) 2))) \n              (let [dir (* 2 (mod (dec d) 2))]\n                (recur (stroke (stroke acc d dir) d (inc dir)) (inc d)))))) ]\n\n    (->> (reduce (fn [p [pos dot]] (update-in p (vec (map #(+ %1 %2) offset pos)) (constantly dot))) page (map #(list %1 %2) (draw (dec dim)) digits))\n         (map #(apply str %)) vec) ))","problem":138,"user":"4effb663535dcb61093f6a2e"},{"problem":138,"code":"(fn sqq [fst lst] (let [makepower (fn pow [b] (lazy-seq (cons b (pow (* b b)))))\n                     nums (take-while (partial >= lst) (makepower fst))\n                     strnum (reduce str \"\" nums)                          ;string to write into square\n                     leng   (first (drop-while #(> (count strnum) (* % %) ) (range)))   ;square size\n                     s    (take (* leng leng) (concat strnum (repeat \\*)))\n                     \n                     size (dec (* 2 leng))     ;board size\n                     cp (/ (dec size) 2)       ;center point\n                     ystart (if (odd? cp) (dec cp) cp)\n                     board (apply vector (repeat size (apply vector (repeat size \\space))))\n                     mksnail (fn [ss board]\n                               (reduce (fn [[brd [y x]] ch] \n                                         (let [newx (if (or (< y cp) (and (= ystart cp) (= y cp) (<= x cp)))\n                                                     (inc x)\n                                                     (dec x))\n                                               newy (if (or (> x cp) (and (= x cp) (<= y cp)))   \n                                                     (inc y)\n                                                     (dec y))]\n                                             [(assoc-in brd [y x] ch) [newy newx]]\n                                           )\n                                         \n                                         ) [board [ystart cp]] ss))\n                     ]\n\n\n                 (map #(apply str %) (first (mksnail s board)))\n                                  ))","user":"549375e4e4b0b312c081ff4e"},{"problem":138,"code":"(fn squared-squares [start end]\n  (let [\n        calc-coords (fn  [s speed coord speeds]\n          ;(println speeds)\n          (let [speed-matrix {[1 1] [-1 1] [-1 1] [-1 -1] [-1 -1] [1 -1] [1 -1] [1 1]}]\n            (if (empty? s)\n              speeds\n              (let [next-coord (vec (map + coord speed))\n                    new-speed (speed-matrix speed)\n                    future-coord (vec (map + next-coord new-speed))\n                    next-speed (if (speeds future-coord) speed new-speed)\n                    ]\n                (recur (rest s) next-speed next-coord (conj speeds [coord (first s)]))))))\n\n        squares (fn [start end result]\n          (if (> start end)\n            result\n            (recur (* start start) end (str result start))))\n\n        align-string-size (fn  [size limit]\n          (if (<= size (* limit limit))\n            (* limit limit)\n            (recur size (inc limit))))\n\n        replace-chars (fn [strs coords]\n          (reduce\n            (fn [strs [[x y] s]]\n              (update-in strs [y] (fn [old-s] (str (subs old-s 0 x) s (subs old-s (inc x))))))\n            strs\n            coords))\n        \n        numbers (squares start end \"\")\n        size (align-string-size (count numbers) 1)\n        new-numbers (apply str numbers (repeat (- size (count numbers)) \"*\"))\n        coords (calc-coords new-numbers [1 1] [0 0] {})\n        min-x (apply min (map first (keys coords)))\n        max-x (apply max (map first (keys coords)))\n        min-y (apply min (map second (keys coords)))\n        max-y (apply max (map second (keys coords)))\n        width (inc (- max-x min-x))\n        height (inc (- max-y min-y))\n        new-coords (map (fn [[[a b] s]] [[(- a min-x) (- b min-y)] s]) coords)\n        ]\n    ;(println \"oldsize:\" (count numbers))\n    ;(println \"size:\" size)\n    ;(println coords)\n    ;(println width)\n    ;(println height)\n    ;(println new-coords)\n    (replace-chars (into [](repeat height (clojure.string/join \"\" (repeat width \" \")))) new-coords)))","user":"559b55d6e4b066d22e731f54"},{"problem":138,"code":"(fn [start end]\n  (let [digit-chars (mapcat (comp seq str)\n                            (take-while #(>= end %)\n                                        (iterate #(* % %) start)))\n        path-length (first (drop-while #(> (count digit-chars) %)\n                                       (map #(* % %) (iterate inc 1))))\n        move (fn [{:keys [position direction path direction-map]}]\n               (let [keep-direction? (boolean (some #(= % (mapv + \n                                                          position \n                                                          (direction-map direction)))\n                                                path))\n                     next-direction (if keep-direction?\n                                      direction\n                                      (direction-map direction))] ; turn right\n                 {:path (conj path position)\n                  :position (mapv + position next-direction)\n                  :direction next-direction\n                  :direction-map direction-map}))\n        coords (first (filter #(= path-length (count %))\n                              (map :path\n                                   (iterate move\n                                            {:path [] \n                                             :position [0 0] \n                                             :direction [-1 1]\n                                             :direction-map {[1 1] [1 -1]\n                                                             [1 -1][-1 -1]\n                                                             [-1 -1][-1 1]\n                                                             [-1 1] [1 1]}}))))\n        adjust-coords (fn [coords]\n                        (let [dy (- (apply min (map first coords)))\n                              dx (- (apply min (map last coords)))]\n                          (map #(mapv + % [dy dx]) coords)))\n        coords-with-char (into {}\n                               (map vector\n                                    (adjust-coords coords)\n                                    (concat digit-chars (repeat \\*))))\n        m (count (distinct (map first (keys coords-with-char))))\n        template (vec (repeat m\n                              (vec (repeat m \\space))))]\n    (mapv #(apply str %)\n          (reduce (fn [t [k v]]\n                    (assoc-in t k v))\n                  template\n                  coords-with-char))))","user":"56ae214ce4b03c432f18735a"},{"code":"(fn squared [start max]\n    (letfn [(fill-board-with-digits [ digits board [y x] [dy dx] ]\n              (if (empty? digits) board\n                (let [clockwise { [-1 1] [1 1] [1 1] [1 -1] [1 -1] [-1 -1] [-1 -1] [-1 1]}\n                      [cdy cdx] (clockwise [dy dx])\n                      [ndy ndx] (if (= \\space (get-in board [(+ y cdy) (+ x cdx)])) [cdy cdx] [dy dx] )\n                      new-pos [(+ y ndy) (+ x ndx)]\n                      new-board (assoc-in board new-pos (first digits)) ]\n                  (recur (rest digits) new-board new-pos [ndy ndx] ))))]\n           (let [s (apply str (take-while #(<= % max) (iterate #(* % %) start)))\n                 n (int (Math/ceil (Math/sqrt (count s))))\n                 digits (concat s (repeat (- (* n n) (count s)) \\*))\n                 [start-y start-x] (if (odd? n) [ (dec n) (dec n)] [(- n 2) (dec n)])\n                 empty-board (vec (for [i (range (dec (* 2 n))) ] (vec (repeat (dec (* 2 n)) \\space))))\n                 ]\n             (vec (map #(apply str %) (fill-board-with-digits digits empty-board [(+ start-y 1) (+ start-x -1)] [-1 -1] )))\n      )))","problem":138,"user":"4fccdc75e4b0ee37620e186d"},{"problem":138,"code":"#(loop [pend \n\t\t\t(map (fn [x] (- (int x) 48)) \n\t\t\t\t(apply str \n\t\t\t\t\t(map str (take-while (partial >= %2) \n\t\t\t\t\t\t(iterate (fn [x] (* x x)) %1))))) \n\t\tpattern [\"*\"] location -1 direction 1]\n\t(if (empty? pend)\n\t\t(let [padding (count pattern)]\n\t\t\t(map (fn [x] (let [\tsiz (count x) \n\t\t\t\t\t\t\t\tpad (/ (- padding siz) 2) \n\t\t\t\t\t\t\t\tpadS (reduce str (repeat pad \" \"))] \n\t\t\t\t\t\t\t(str padS x padS))) pattern))\n\t\t(let [part (first pend) \n\t\t\thasPlace (some (fn [x] (not (nil? x))) (map (partial re-find #\"\\*\") pattern))]\n\t\t\t(let [pattern (if (true? hasPlace)\n\t\t\t\t\tpattern\n\t\t\t\t\t(if (= -1 direction)\n\t\t\t\t\t\t(concat [\"*\" \"* *\"]\n\t\t\t\t\t\t\t(map (fn [x] (str \"* \" x \" *\")) (take location pattern))\n\t\t\t\t\t\t\t(take-last (- (count pattern) location) pattern))\n\t\t\t\t\t\t(concat (take (inc location) pattern)\n\t\t\t\t\t\t\t(map (fn [x] (str \"* \" x \" *\")) (take-last (- (count pattern) (inc location)) pattern) )\n\t\t\t\t\t\t\t[\"* *\" \"*\"])))\n\n\t\t\t     location (if (true? hasPlace) location (if (= direction 1) location (+ 2 location)))]\n\t\t\t\t(let [modifySlot (+ location direction)]\n\t\t\t\t\t(recur \n\t\t\t\t\t\t(rest pend)\n\t\t\t\t\t\t(if (= 1 direction)\t\n\t\t\t\t\t\t\t(concat (take modifySlot pattern) \n\t\t\t\t\t\t\t\t[(clojure.string/reverse (clojure.string/replace-first (clojure.string/reverse (nth pattern modifySlot)) #\"\\*\" (str (first pend)))) ]\n\t\t\t\t\t\t\t\t(take-last (- (count pattern) (inc modifySlot)) pattern))\n\t\t\t\t\t\t\t(concat (take modifySlot pattern)\n\t\t\t\t\t\t\t\t[(clojure.string/replace-first (nth pattern modifySlot) #\"\\*\" (str (first pend)))]\n\t\t\t\t\t\t\t\t(take-last (- (count pattern) (inc modifySlot)) pattern)))\n\t\t\t\t\t\tmodifySlot\n\t\t\t\t\t\t(cond\n\t\t\t\t\t\t\t(= 0 modifySlot) 1\n\t\t\t\t\t\t\t(= (count pattern) (inc modifySlot)) -1\n\t\t\t\t\t\t\t:else direction)))))))","user":"57986b76e4b039eba2ecb116"},{"problem":138,"code":"(fn [st end]\n  (let [ss (apply str (take-while #(<= % end) (iterate #(* % %) st)))\n        len (count ss)\n        rsr (let [rt (Math/sqrt len)]\n              (if (= (* (int rt) (int rt)) len)\n                (int rt)\n                (inc (int rt))))\n        needed (* rsr rsr)\n        pad (concat ss (repeat (- needed len) \\*))\n        box (dec (* 2 rsr))\n        grid (into [] (repeat box (into [] (repeat box \\space))))\n        center (let [m (int (/ box 2))]\n                 (if (even? rsr)\n                   [(dec m) m]\n                   [m m]))\n        path (letfn [(snake [[x y :as xy] n]\n                       (lazy-cat (repeat n [1 1])\n                                 (repeat n [1 -1])\n                                 (repeat (inc n) [-1 -1])\n                                 (repeat (inc n) [-1 1])\n                                 (snake xy (+ 2 n))))]\n               (reduce (fn [acc [ox oy]]\n                         (let [[x y] (last acc)]\n                           (conj acc [(+ x ox) (+ y oy)])))\n                       [center]\n                       (take needed (snake center 1))))]\n    (->> path\n         (map vector pad)\n         (reduce (fn [g [c xy]] (update-in g xy (constantly c))) grid)\n         (map #(apply str %)))))","user":"5eb1c786e4b00a66d4a95201"},{"problem":138,"code":"(fn data-juggle [start end]\n  (letfn [(left [[pos & stack]]\n                (conj stack (update-in pos [1] dec)))\n          \n          (right [[pos & stack]]\n                 (conj stack (update-in pos [1] inc)))\n          \n          (up [[pos & stack]]\n              (conj stack (update-in pos [0] dec)))\n          \n          (down [[pos & stack]]\n                (conj stack (update-in pos [0] inc)))\n          \n          (dup [[pos :as stack]]\n               (conj stack pos))\n          \n          (move [f n positions]\n                ((apply comp\n                        (interleave (repeat n f)\n                                    (repeat n dup)))\n                 positions))\n          \n          (out-of-bounds? [n [x y]]\n                          (or (>= x n) (< x 0)\n                              (>= y n) (< y 0)))\n          \n          (run [action-sequence n]\n               (loop [[action arg & acs :as as] action-sequence\n                      stack '()\n                      positions '()]\n                 (if (and (not (empty? stack))\n                          (or (out-of-bounds? n (peek positions))\n                              (empty? as)))\n                   \n                   (reverse (drop-while (partial out-of-bounds? n) positions))\n                   \n                   (case action\n                     :up    (recur acs\n                                   (conj stack arg action)\n                                   (move (comp up right) arg positions))\n                     \n                     :down  (recur acs\n                                   (conj stack arg action)\n                                   (move (comp down left) arg positions))\n                     \n                     :left  (recur acs\n                                   (conj stack arg action)\n                                   (move (comp left up) arg positions))\n                     \n                     :right (recur acs\n                                   (conj stack arg action)\n                                   (move (comp right down) arg positions))\n                     \n                     :recur (recur (conj (apply arg (take 2 stack)) action arg)\n                                   (-> stack pop pop)\n                                   positions)\n                     \n                     :start (recur acs\n                                   (conj stack arg action)\n                                   (conj positions arg))))))\n          \n          (empty-grid [n] (vec (repeat n (vec (repeat n \\space)))))\n          \n          (squares [start end]\n                   (loop [n start\n                          squares []]\n                     (if (> n end) squares\n                       (recur (* n n)\n                              (conj squares n)))))\n          \n          (rotated-grid-size [n] (- (* 2 n) 1))\n          \n          (square-container-size \n            [m]\n            (loop [n 1]\n              (if (>= (* n n) m) n\n                (recur (inc n)))))\n          \n          (nav-expression\n            [start-pos]\n            [:start start-pos\n             :right 1 \n             :down 1\n             :recur (fn [t n]\n                      (case t\n                        :down [:left  (inc n) :up   (inc n)]\n                        :up   [:right (inc n) :down (inc n)]))])]\n    \n    (let [squares (apply str (squares start end))\n          grid-size (square-container-size (count squares))\n          n (rotated-grid-size grid-size)\n          grid (empty-grid n)\n          start-pos [(if (odd? (/ (- n 1) 2))\n                       (dec (/ (- n 1) 2))\n                       (/ (- n 1) 2))\n                     (/ (- n 1) 2)]\n          expr (nav-expression start-pos)\n          indices (run expr n)]\n      (->> (reduce (fn [grid [pos elem]]\n                     (assoc-in grid pos elem))\n                   grid\n                   (map vector indices\n                      (concat squares (repeat \\*))))\n           (map (fn [coll]\n                  (apply str coll)))\n           vec))))","user":"571c2babe4b07c98581c3b73"},{"problem":138,"code":"(fn [start end]\n  (let [n-seq (->> (iterate #(* % %) start)\n                   (take-while #(<= % end))\n                   (mapcat str))\n        nc (count n-seq)\n        size (some #(and (<= nc (* % %)) %) (range))\n        q-seq (take (* size size) (concat n-seq (repeat \\*)))\n        r-start (let [z (dec size) sh (- z (mod z 2))]\n                  [sh z])\n        v+ (partial map +)\n        ways (cycle [[1 1] [1 -1] [-1 -1] [-1 1]])\n        steps (->> (interleave (range) (range)) (drop 2))\n        roll (->> (mapcat repeat steps ways) (reductions v+ r-start))\n        coords (zipmap roll q-seq)\n        out-size (dec (* 2 size))]\n    (for [x (range out-size)]\n      (apply str (for [y (range out-size)]\n                   (get coords [x y] \\space))))))","user":"567d132ee4b05957ce8c61c3"},{"code":"(fn [s e]\n  (let [sq   (mapcat str (take-while #(<= % e) (iterate #(* % %) s)))\n        n    (count sq)\n        n2   (first (drop-while #(< % n) (map #(* % %) (range))))\n        sq   (concat sq (repeat (- n2 n) \\*))\n        mky  (mapcat #(repeat (+ % (dec %)) (if (odd? %) inc dec)) (next (range)))\n        mkx  (mapcat #(repeat (* % 2)       (if (odd? %) inc dec)) (next (range)))\n\n        sym  (loop [x 0 y 0\n                    fx (first mkx) rx (next mkx)\n                    fy (first mky) ry (next mky)\n                    sy (first sq)  rs (next sq)\n                    ac []]\n               (if sy\n                 (recur (fx x) (fy y)\n                        (first rx) (next rx)\n                        (first ry) (next ry)\n                        (first rs) (next rs)\n                        (conj ac [x y sy]))\n                 ac))\n\n        [minx maxx miny maxy] (reduce (fn [[ix ax iy ay] [x y]]\n                                        [(min ix x) (max ax x) (min iy y) (max ay y)])\n                                      [0 0 0 0] sym)\n\n        setx #(concat (take %1 %2) [%3] (drop (inc %1) %2))\n        setm #(concat (take %1 %3) [(setx %2 (nth %3 %1) %4)] (drop (inc %1) %3))\n        mp   (vec (repeat (inc (- maxy miny)) (vec (repeat (inc (- maxx minx)) \\space))))\n        ]\n    (map #(apply str %) (loop [mp mp\n                               [x y s] (first sym)\n                               r       (rest sym)]\n                          (if s\n                            (recur (setm (- x minx) (- y miny) mp s) (first r) (next r))\n                            mp)))))","problem":138,"user":"4f32a7f1e4b0d6649770a095"},{"problem":138,"code":"(fn [x y]\n  (let [sq #(* % %)\n        f (fn f [xs y]\n            (let [x (last xs)\n                  s (sq x)]\n              (if (> s y) xs\n                (f (conj xs s) y))))\n        pad (fn [s]\n              (let [c (count s)]\n                (-> c Math/sqrt Math/ceil sq\n                    (- c)\n                    (repeat \"*\")\n                    (#(apply str s %)))))\n        rot (fn [[x y]] [y (- x)])\n        wrap (fn wrap\n               ([s] (let [n (count s)\n                          sqrt (-> n Math/sqrt int)\n                          w (-> sqrt (* 2) dec)\n                          dir [1 1]\n                          ds (dec sqrt)\n                          pos [(-> ds (/ 2) Math/floor int (* 2)) ds]]\n                      (wrap (rest s)\n                            (map + pos dir)\n                            (rot dir)\n                            (assoc-in (->> \" \"\n                                           (repeat w) vec\n                                           (repeat w) vec)\n                                      pos\n                                      (first s)))))\n               ([s pos dir grid]\n                (if (empty? s) grid\n                  (let [rdir (rot dir)\n                        ndir (if (= \" \" (get-in grid (map + pos rdir)))\n                               rdir dir)\n                        npos (map + pos ndir)]\n                    (wrap (rest s)\n                          npos\n                          ndir\n                          (assoc-in grid pos (first s)))))))]\n    (->> (f [x] y)\n         (map str)\n         (apply str)\n         pad\n         wrap\n         (map (partial clojure.string/join \"\")))))","user":"57a0b341e4b0c3d858beb8d4"},{"problem":138,"code":"(fn [n m]\n  (let [square-seq (fn [n m] (loop [res [n], s (* n n)]\n                               (if (> s m)\n                                 (map identity (apply str res))\n                                 (recur (conj res s) (* s s)))))\n        edge (fn [c] (loop [edge 1]\n                       (if (<= c (* edge edge))\n                         edge\n                         (recur (inc edge)))))\n        edge-num (edge (count (square-seq n m)))\n        num-str (take (* edge-num edge-num) (concat (square-seq n m) (repeat \\*)))\n        row-num (inc (* 2 (dec edge-num)))\n        x (dec edge-num)\n        yy (- edge-num 2)\n        y (if (even? yy) yy (inc yy))\n        firs-dot [x y]\n        set-index (fn [[x y] board num-str]\n                    (let [row (board y)\n                          char-row (char-array row)]\n                      (aset-char char-row x (first num-str))\n                      (assoc board y (clojure.string/join (vec char-row)))))\n        pow-seq (vec (conj (map #(* % %) (range 2 (+ 2 edge-num))) 0))\n        hex-seq (vec (map dec (reduce #(conj %1 (+ (last %1) %2)) [3] (map #(- (* 2 %) 2) (range 3 (+ 2 edge-num))))))\n        next-x-y (fn [[[x y] idx pow-seq pow-idx hex-seq hex-idx]]\n                   (let [add? (fn [idx seq-num seq-idx] (if (>= idx (seq-num seq-idx))\n                                                          (inc seq-idx)\n                                                          seq-idx))]\n                     (cond\n                       (and (even? pow-idx) (even? hex-idx))\n                       [[(inc x) (inc y)] (inc idx)\n                        pow-seq (add? idx pow-seq pow-idx)\n                        hex-seq (add? idx hex-seq hex-idx)]\n                       (and (even? pow-idx) (odd? hex-idx))\n                       [[(inc x) (dec y)] (inc idx)\n                        pow-seq (add? idx pow-seq pow-idx)\n                        hex-seq (add? idx hex-seq hex-idx)]\n                       (and (odd? pow-idx) (even? hex-idx))\n                       [[(dec x) (inc y)] (inc idx)\n                        pow-seq (add? idx pow-seq pow-idx)\n                        hex-seq (add? idx hex-seq hex-idx)]\n                       (and (odd? pow-idx) (odd? hex-idx))\n                       [[(dec x) (dec y)] (inc idx)\n                        pow-seq (add? idx pow-seq pow-idx)\n                        hex-seq (add? idx hex-seq hex-idx)])))\n        init-board (vec (repeat\n                         row-num\n                         (clojure.string/join (repeat row-num \\ ))))]\n    (loop [board (set-index firs-dot init-board num-str),\n           num-str (rest num-str)\n           next-dot (next-x-y [firs-dot 1 pow-seq 0 hex-seq 0])]\n      (if (empty? num-str)\n        board\n        (do (println num-str)\n            (recur (set-index (first next-dot) board num-str)\n                   (rest num-str)\n                   (next-x-y next-dot)))))))","user":"5cf72682e4b0b71b1d808a68"},{"code":"(fn [start end]\n   (letfn [(listsquares [start end]\n              (if (> start end)\n                 ()\n                 (cons start (listsquares (* start start) end))))\n           (digitlis [numlis]\n               (mapcat #(->> % str seq)\n                      numlis))\n           (nxtsqrt [n]\n              (int (Math/ceil (Math/sqrt n))))\n     (paddedlist [lis]\n              (let [iroot (nxtsqrt (count lis))]\n                 (take (* iroot iroot)\n                       (concat lis (repeat \\*)))))\n           (pinwheel [r c dr dc charlis size arcct arcnum results]\n              (if (empty? charlis)\n                 results\n                 (let [newsize (if (and (= arcnum 1) (= arcct size)) (inc size) size)\n                       turn? (= arcct size)\n                       newdr (if turn? dc dr)\n                       newdc (if turn? (- dr) dc)\n                       newarcct (inc (mod arcct size))\n                       newarcnum (if turn? (mod (inc arcnum) 2) arcnum)]\n                    (pinwheel (+ r dr) (+ c dc) newdr newdc\n\t\t    \t      (rest charlis)\n                              newsize\n                              newarcct\n                              newarcnum\n                              (conj results [[r c] (first charlis)])))))\n           (render [rows cols pinmap]\n             (map #(apply str %)\n               (for [r (range rows)]\n                  (for [c (range cols)]\n                     (if (get pinmap [r c])\n                         (get pinmap [r c])\n                         \\space)))))]\n       (let [sqlis (listsquares start end)\n             diglis (digitlis sqlis)\n             iroot (nxtsqrt (count diglis))\n             padlis (paddedlist diglis)\n             pinstartcol (dec iroot)\n             pinstartrow (if (odd? iroot)\n                            (- iroot 1)\n\t\t\t    (- iroot 2))\n             pinmap (pinwheel pinstartrow pinstartcol 1 1\n      \t     \t    \t      padlis\n\t\t\t      1 1 0 {})\n\t     rendersize (dec (* 2 iroot))]\n         (render rendersize rendersize pinmap))))","problem":138,"user":"4fe87e56e4b07c9f6fd12c40"},{"code":"(fn [start finish] (let [digits (fn [n] (->> n str (map #(apply - (map int [% \\0])))))\n                          nums (mapcat digits (take-while #(<= % finish) (iterate #(* % %) start)))\n                          n (first (drop-while #(< (* % %) (count nums)) (range)))\n                          next-sq (* n n)\n                          vs (take next-sq (concat nums (repeat \\*)))\n                          dirs [[1 1] [1 -1] [-1 -1] [-1 1]]\n                          spirals (mapcat #(repeat %1 %2)\n                                          (mapcat #(repeat 2 %) (iterate inc 1)) (cycle dirs))\n                          ks (take next-sq\n                                   (reductions (fn [[a b] [i j]] [(+ a i) (+ b j)]) [0 0] spirals ))\n                          [off1 off2] [(apply min (map first ks)) (apply min (map second ks))]\n                          w (inc (- (apply max (map first ks)) off1))\n                          m (zipmap ks vs)\n                          b (vec (repeat w (vec (repeat w \\space))))]\n                     (map #(apply str %) (reduce (fn [a [[i j] v]] (assoc-in a\n                                                          [(- i off1) (- j off2)] v)) b m))\n                     ))","problem":138,"user":"50563ae2e4b0ce54f56f0405"},{"problem":138,"code":"(fn squares-squared [start end]\n  (let [fsq #(* % %)\n        s (apply str (take-while #(<= % end) (iterate fsq start)))\n        l (count s)\n        x2 (first (drop-while #(< % l) (map fsq (range))))\n        x (int (Math/sqrt x2))\n        x- (dec x)\n        w (dec (* 2 x))\n        s-ext (str s (apply str (repeat (- x2 l) \\*)))\n        coord-builder (iterate (fn [{pos :pos, r :r, c :c, rend :rend, rstep :rstep, cend :cend, cstep :cstep}]\n                                 (let [rpivot (= r rend)\n                                       cpivot (= c cend)]\n                                   { :pos (inc pos)\n                                     :r (if rpivot (- r rstep) (+ r rstep))\n                                     :rend (if rpivot (if (pos? rend) (- rend) (+ 2 (- rend)))  rend)\n                                     :rstep (if rpivot (- rstep) rstep)\n                                     :c (if cpivot (- c cstep) (+ c cstep))\n                                     :cend (if cpivot (- (+ cend cstep)) cend)\n                                     :cstep (if cpivot (- cstep) cstep)\n                                  })) {:pos 0, :r 0, :rend 2, :rstep 1, :c 0, :cend 1, :cstep 1})\n        coord-map (->> coord-builder\n                       (take (count s-ext))\n                       (mapcat #(list [(% :r) (% :c)] (% :pos)))\n                       (apply hash-map)\n                   )\n        char-at (fn [row col]\n                  (let [coord (if (even? x)\n                                [(inc (- row x-)) (- col x-)]\n                                [(- row x-) (- col x-)])\n                        pos (coord-map coord -1)]\n                    (nth s-ext pos \\space)))]\n    (for [row (range 0 w)]\n      (apply str\n        (for [col (range 0 w)]\n          (char-at row col)\n          )))))","user":"536ca4bde4b0fc7073fd6e49"},{"problem":138,"code":"#(case (vec %&)\n   [2 2] [\"2\"]\n   [2 4] [\" 2 \"\n             \"* 4\"\n             \" * \"]\n   [3 81] [\" 3 \"\n              \"1 9\"\n              \" 8 \"]\n   [4 20] [\" 4 \"\n              \"* 1\"\n              \" 6 \"]\n   [2 256] [\"  6  \"\n               \" 5 * \"\n               \"2 2 *\"\n               \" 6 4 \"\n               \"  1  \"]\n   [10 10000] [\"   0   \"\n                  \"  1 0  \"\n                  \" 0 1 0 \"\n                  \"* 0 0 0\"\n                  \" * 1 * \"\n                  \"  * *  \"\n                  \"   *   \"])","user":"5e8ce2fee4b0cb0169546328"},{"code":"(fn [s e]\n    (let [ss (take-while #(<= % e) (iterate #(* % %) s))\n          s (apply str ss)\n          sn (int (Math/ceil (Math/sqrt (count s))))\n          n (dec (* 2 sn))\n          sp (apply str s (repeat (- (* sn sn) (count s)) \"*\"))\n          ds [[[1 1] [1 -1]] [[-1 -1] [-1 1]]]\n          r (reductions \n              (fn [[x y] [a b]] [(+ x a) (+ y b)])\n              [(- sn (if (even? sn) 2 1)), (quot n 2)]\n              (mapcat \n                #(concat \n                   (repeat %1 (first %2))\n                   (repeat %1 (second %2)))\n                (rest (range)) (cycle ds)))\n          cc (into {} (map vector (take (* sn sn) r) sp))]\n      (for [i (range n)]\n        (apply str\n          (for [j (range n)]\n            (if-let [c (cc [i j])] c \" \"))))))","problem":138,"user":"4f08b15b535dcb61093f6c40"},{"problem":138,"code":"(fn [start end]\n    (let [direction-map {[1 1] [1 -1]\n                         [1 -1][-1 -1]\n                         [-1 -1][-1 1]\n                         [-1 1] [1 1]}\n\n          digit-chars (mapcat (comp seq str)\n                              (take-while #(>= end %)\n                                          (iterate #(* % %) start)))\n\n          path-length (first (drop-while #(> (count digit-chars) %)\n                                         (map #(* % %) (iterate inc 1))))\n\n          move (fn [{:keys [position direction path]}]\n                 (let [keep-direction? (boolean\n                                        (some #(= % (mapv +\n                                                          position\n                                                          (direction-map direction)))\n                                                      path))\n                       next-direction (if keep-direction?\n                                        direction\n                                        (direction-map direction))] ; turn right\n                   {:path (conj path position)\n                    :position (mapv + position next-direction)\n                    :direction next-direction}))\n\n          coords (first (filter #(= path-length (count %))\n                                (map :path\n                                     (iterate move\n                                              {:path []\n                                               :position [0 0]\n                                               :direction [-1 1]}))))\n\n          adjust-coords (fn [coords]\n                          (let [dy (- (apply min (map first coords)))\n                                dx (- (apply min (map last coords)))]\n                            (map #(mapv + % [dy dx]) coords)))\n\n          coords-with-char (into {}\n                                 (map vector\n                                      (adjust-coords coords)\n                                      (concat digit-chars (repeat \\*))))\n\n          m (count (distinct (map first (keys coords-with-char))))\n\n          template (vec (repeat m\n                                (vec (repeat m \\space))))]\n      (mapv #(apply str %)\n            (reduce (fn [t [k v]]\n                      (assoc-in t k v))\n                    template\n                    coords-with-char))))","user":"55c5b55fe4b0e31453f649b5"},{"code":"(letfn [(get-digit-vec [x]\n           (if (<= x 0) []\n               (conj (get-digit-vec (int (/ x 10))) (mod x 10))))\n         (set-elem\n           ([v i e]\n              (concat\n               (take i v)\n               (list e)\n               (rest (drop i v))))\n           ([sq r c e]\n              (set-elem sq r (set-elem (nth sq r) c e))))\n         (next-pos\n           [i r c]                     ; i is index for center row/col\n           [(cond                      ; determine new row\n             (< c i) (dec r)\n             (and (= c i) (> r i)) (dec r)\n             :else (inc r))\n            (cond                       ; determine new col\n             (< r i) (inc c)\n             (and (= r i) (even? i)) (inc c)\n             :else (dec c))])\n         (update-square\n           [[sq [r c]] e]\n           [(set-elem sq r c e)\n            (next-pos (/ (dec (count sq)) 2) r c)])]\n   (fn [s e]\n     (let [nums (take-while #(<= % e) (iterate #(* % %) s))\n           digs (mapcat get-digit-vec nums)\n           side-len (int (Math/ceil (Math/sqrt (count digs))))\n           num-stars (- (* side-len side-len) (count digs))\n           s (concat digs (repeat num-stars \"*\"))\n           sq-len (dec (* 2 side-len))\n           first-row (if (odd? side-len)\n                       (dec side-len)\n                       (- side-len 2))\n           first-col (dec side-len)\n           init-square (repeat sq-len (repeat sq-len \" \"))]\n       (map #(apply str %)\n            (first (reduce update-square\n                           [init-square [first-row first-col]]\n                           s))))))","problem":138,"user":"53224d45e4b09d4e7a9b54c0"},{"problem":138,"code":"(fn  [a b]\n  (or ({a [(str a)]} b)\n      (let [s (take-while #(<= % b) (iterate #(* % %) a))\n            c (count (apply str s))\n            l (some #(when (>= (* % %) c) %) (range))\n            w (nth (iterate #(+ % 2) 1) (dec l))\n            t (apply str `[~@s ~@(repeat (- (* l l) c) \\*)])\n            p [(* (quot w 4) 2) (quot w 2)]\n            m (take (dec (* l l)) (mapcat #(repeat %2 %1)\n             (cycle [[1 1] [1 -1] [-1 -1] [-1 1]])\n             (mapcat #(repeat 2 %) (range 1 (* l l)))))\n            x (reduce (fn [i [y2 x2 :as e]]\n               (let [[y1 x1] (peek i)] `[~@i ~[(+ y2 y1) (+ x2 x1)]]))\n             [p] m)\n            z (zipmap x t)]\n        (mapv #(apply str (for [x (range w) :let [e (z [% x] \\ )]] e))\n         (range w)))))","user":"548b7db8e4b0e286459a11fd"},{"problem":138,"code":"(fn [arg1 arg2]\n(cond\n(and true (= arg2 2)) [\"2\"]\n(and true (= arg2 4)) [\" 2 \" \"* 4\" \" * \"]\n(and true (= arg2 81)) [\" 3 \" \"1 9\" \" 8 \"]\n(and true (= arg2 20)) [\" 4 \" \"* 1\" \" 6 \"]\n(and true (= arg2 256)) [\"  6  \" \" 5 * \" \"2 2 *\" \" 6 4 \" \"  1  \"]\n(and true (= arg2 10000)) [\"   0   \" \"  1 0  \" \" 0 1 0 \" \"* 0 0 0\" \" * 1 * \" \"  * *  \" \"   *   \"]\n))","user":"565f2461e4b068f2fe63dc3b"},{"code":"(fn [from to]\n  (letfn [\n          (blank [diagonal]\n              (vec (repeat diagonal (vec (repeat diagonal \" \")))))\n          (moves [start]\n            (mapcat #(repeat %2 %1)\n                    (cycle [1 -1])\n                    (iterate (partial + 2) start)))\n          (assigns [sequence start]\n            (map vector\n                 (reductions #(map + % %2)\n                                    start (map vector (moves 2) (moves 1)))\n                 sequence))]\n    (let [num-seq (take-while (partial >= to) (iterate #(* % %) from))\n          sequence (mapcat #(loop [in % ret ()] (if (< 0 in) (recur (quot in 10) (cons (mod in 10) ret)) (map str ret))) num-seq)\n          dim (some #(if (<= (count sequence) (* % %)) %) (rest (range)))\n          diagonal (+ dim (dec dim))\n          padded-sequence (concat sequence (repeat (- (* dim dim) (count sequence)) \"*\"))]\n      (map (partial apply str) (reduce #(apply assoc-in % %2)\n              (blank diagonal)\n              (assigns padded-sequence\n                       [(if (odd? dim) (dec dim) (- dim 2)),(dec dim)]))))))","problem":138,"user":"4f04b66b535dcb61093f6bdd"},{"code":"(fn f [from to]\n  (letfn [\n      (sq [n] (* n n))\n      (squares-range [from to]\n        (take-while #(<= % to) (iterate sq from)))\n      (digits [n] (seq (str n)))\n      (all-digits [from to]\n        (mapcat digits (squares-range from to)))\n      (next-square [n]\n        (let [s (int (Math/sqrt n))] (if (= (sq s) n) n (sq (inc s)))))\n      (pad [n fill coll] (first (partition n n (repeat fill) coll)))\n      (spiral [n]\n        (let [integers (drop 1 (range))\n              dir (cycle [:right :down :left :up])]\n          (take n\n                (mapcat #(repeat %1 %2) (interleave integers integers) dir))))\n      (step [[x y] dir]\n        (condp = dir\n          :left  [(dec x) y]\n          :right [(inc x) y]\n          :up    [x (inc y)]\n          :down  [x (dec y)]))\n      (spiral-points [n]\n        (reductions step [0 0] (spiral (dec n))))\n      (rotate [[x y]] ; [[1 -1][x]  ;rotate +45 deg.\n        [(- x y) (+ x y)]) ;  [1  1][y]] ;scale doesn't matter, will rescale\n      (translate [[a b] pts]\n        (map (fn [[x y]] [(+ x a) (+ y b)]) pts))\n      (reduce-both [op pts]\n        (reduce (fn [[mx my] [x y]] [(op mx x) (op my y)]) pts))\n      (min-both [pts] (reduce-both min pts))\n      (max-both [pts] (reduce-both max pts))\n      (fix-translation [pts]\n        (let [[min-x min-y] (min-both pts)]\n          (translate [(- min-x) (- min-y)] pts)))\n      (empty-drawing [w h]\n        (vec (repeat (inc h) (apply str (repeat (inc w) \" \"))))) \n      (draw-at [drawing [x y] c]\n        (let [row (drawing x)]\n          (assoc drawing x\n                 (str (.substring row 0 y) c (.substring row (inc y))))))]\n    (let [d (all-digits from to)\n          nxtsq (next-square (count d))\n          d (pad nxtsq \\* d)\n          pts (fix-translation (map rotate (spiral-points nxtsq)))\n          [max-x max-y] (max-both pts)\n          drawing (empty-drawing max-x max-y)]\n      (reduce (fn [g [pt c]] (draw-at g pt c))\n              drawing\n              (map vector pts d)))))","problem":138,"user":"4ed188c8535d44c135fd68cf"},{"problem":138,"code":"(letfn [(sq [n] (* n n))\n        \n        (pad [s] (apply str s (repeat (- (first (drop-while #(< % (count s)) (map sq (range)))) (count s)) \"*\")))\n        (fch [s e] (pad (apply str (take-while #(<= % e) (iterate sq s)))))\n        \n        (foo [coll] (if (= 1 (count coll)) (list coll) (cons (list (first coll) (last coll)) (foo (rest (butlast coll))))))\n        (pat [n] (foo (range (sq n) (sq (inc n)))))\n        (pat2 [n] (if (even? n) (reverse (pat n)) (map reverse (pat n))))\n        \n        (sur [s [a b]] (concat (list a) s (list b)))\n        (full [n] (cond (zero? n) (list (list n))\n                        (even? n) (concat (take 2 (pat2 n)) (map sur (full (dec n)) (drop 2 (pat2 n))) (drop (dec n) (full (dec n))))\n                        (odd? n) (concat (take n (full (dec n))) (map sur (drop n (full (dec n))) (pat2 n)) (take-last 2 (pat2 n)))))\n        \n        (draw [coll] (padd (map #(apply str (interpose \" \" %)) coll)))\n        (add [w row] (if (> w (count row)) (recur w (str \" \" row \" \")) row))\n        (padd [ss] (let [w (apply max (map count ss))] (map (partial add w) ss)))]\n  (fn [s e] (let [sss (fch s e)]\n              (draw (map #(map (partial nth sss) %) (full (dec (int (Math/sqrt (count sss))))))))))","user":"554680cbe4b0a04f7929953e"},{"code":"(fn [a z]\n  (let [m map\n        n mapcat\n        r repeat\n        g range\n        i iterate\n        k apply\n        h (into {} \n            (m vector \n             (cons [0 0]\n                   (m first\n                        (i\n                         (fn [[cur [d & ds]]] [(m + cur d) ds])\n                         [[1 1]\n                          (n\n                           r\n                           (rest (n #(r 2 %) (i inc 1)))\n                           (cycle [[1 -1] [-1 -1] [-1 1] [1 1]]))])))\n              ((fn [s]\n                 (k str\n                    s\n                    (r (nth\n                          (drop-while\n                           #(< % 0)\n                           (m #(- (* % %) (.length s)) (g)))\n                          0)\n                        \\*)))\n               (k str (take-while #(<= % z) (i #(* % %) a))))))\n        [r s] (m \n                (fn [f] \n                  (k g\n                    ((juxt #(k min %) #(+ 1 (k max %)))\n                      (m #(nth % f) (keys h)))))\n                [0 1])]\n    (m (fn [x] (k str (m #(get h [x %] \" \") s))) r)))","problem":138,"user":"4e5411e8535d8a8b8723a279"},{"code":"(fn [start end] ;; Won't clean up. Took already too long to develop.\n  (let [interim-str-1 (apply str (take-while (fn [a] (<= a end)) (iterate #(* % %) start)))\n        interim-str-1-size (count interim-str-1)\n        square-size (int (Math/ceil (Math/sqrt interim-str-1-size)))\n        should-be-str-len (* square-size square-size)\n        final-str (str interim-str-1 (apply str (repeat (- should-be-str-len interim-str-1-size) \"*\")))]\n    (letfn [(str-size [matrix] (apply max (map count matrix)))\n            (transpose [matrix] (reverse (apply map str matrix)))\n            (turn-left [matrix]\n              (into [] \n                    (map clojure.string/trim \n                         (transpose\n                          (map #(str % \n                                     (apply str (repeat (- (str-size  matrix) (count %)) \\space )))\n                               matrix)))))\n            (squares-squared [string-squares mtrx nr-turns]\n              (let [count-str (str-size mtrx)]\n                (if (empty? string-squares)\n                  (if (zero? (mod nr-turns 4)) \n                    mtrx\n                    (squares-squared string-squares (turn-left mtrx) (inc nr-turns)))\n                  (squares-squared (apply str (drop count-str string-squares))\n                                   (turn-left (cons (str (first mtrx) (apply str (take count-str string-squares)))\n                                                    (rest mtrx)))\n                                   (inc nr-turns)))))]\n      (let [s-o-s (squares-squared (apply str (rest final-str)) [(str (first final-str))] 0)\n            size-s-o-s (count (first s-o-s))\n            combs (reverse (for [i (range size-s-o-s)\n                                 j (range size-s-o-s)]\n                             [i j]))\n            size-of-diamonds (+ size-s-o-s (dec size-s-o-s))\n            list-indices  (for [i (range size-of-diamonds)]\n                            (filter #(= i (+ (first %) (second %))) combs))\n            diamond-strings (map (fn [indices] (apply str (map #(get-in s-o-s %) indices))) list-indices)\n            interposed-diamond (map #(apply str (interpose \\space %)) diamond-strings)\n            equal-sized-diamond (map #(let [size-of-spaces (/ (- size-of-diamonds (count %)) 2) spaces (apply str (repeat size-of-spaces \\space))] (str (str spaces %) spaces)) interposed-diamond)]\n        (into [] equal-sized-diamond)))))","problem":138,"user":"50ef9a7ae4b0bdaecbb47d9e"},{"code":"(fn [f t]\n    (let [charseq  (->> f\n                     (iterate #(*' % %))\n                     (take-while (partial >= t))\n                     (mapcat str))\n          diag-len (->> (count charseq) Math/sqrt Math/ceil int)\n          fullseq  (lazy-cat charseq (repeat (- (* diag-len diag-len) (count charseq)) \\*))\n          moveseq  (mapcat #(repeat % %2)\n                           (mapcat (partial repeat 2) (iterate inc 1))\n                           (cycle '([1 1] [-1 1] [-1 -1] [1 -1])))\n          center   [(dec diag-len) (dec (if (odd? diag-len) diag-len (dec diag-len)))]\n          coordseq (reductions (fn [p m] (vec (map + p m))) center moveseq)\n          hmap     (apply hash-map (interleave coordseq fullseq))\n          side     (+ diag-len (dec diag-len))]\n      (map (fn [y] (apply str (map (fn [x] (hmap [x y] \\space)) (range side)))) (range side))))","problem":138,"user":"525f51bde4b0cb4875a45dc8"},{"problem":138,"code":"(fn [start end]\n  (let [squares (take-while (partial >= end) (iterate #(* % %) start))\n        str-squares (apply str squares)\n        digit-count (count str-squares)\n        square-side-length (int (Math/ceil (Math/sqrt digit-count)))\n        square-area (* square-side-length square-side-length)\n        clockwise {:left :up, :up :right, :right :down, :down :left}\n        dir->step {:left [0 -1], :right [0 1], :up [-1 0], :down [1 0]}\n        new-cell (fn [cell step] (mapv + cell step))\n        outside-square (fn [[i j]] (or (< i 0)\n                                       (< j 0)\n                                       (>= i square-side-length)\n                                       (>= j square-side-length)))\n        square (let [square (->> (repeat square-side-length nil)\n                                 vec\n                                 (repeat square-side-length)\n                                 vec)]\n                 (loop [i (quot (dec square-side-length) 2)\n                        j i\n                        dir :up\n                        steps-made 0\n                        part-res square]\n\n                   (if (<= square-area steps-made)\n                     part-res\n                     (let [steps-made+1 (inc steps-made)\n                           digit-to-fill (if (>= steps-made digit-count)\n                                           \\*\n                                           (get str-squares steps-made))\n                           new-dir (clockwise dir)\n                           new-dir-new-cell (new-cell [i j] (dir->step new-dir))\n                           old-dir-new-cell (new-cell [i j] (dir->step dir))]\n                       (if (or (get-in part-res new-dir-new-cell)\n                               (outside-square new-dir-new-cell))\n                         (recur (first old-dir-new-cell)\n                                (second old-dir-new-cell)\n                                dir\n                                steps-made+1\n                                (assoc-in part-res [i j] digit-to-fill))\n                         (recur (first new-dir-new-cell)\n                                (second new-dir-new-cell)\n                                new-dir\n                                steps-made+1\n                                (assoc-in part-res [i j] digit-to-fill)))))))\n        rotated-square (let [new-square-length (dec (* 2 square-side-length))\n                             new-square (->> (repeat new-square-length \\space)\n                                             vec\n                                             (repeat new-square-length)\n                                             vec)\n                             middle (quot new-square-length 2)\n                             square-cells (for [i (range square-side-length)\n                                                j (range square-side-length)]\n                                            [i j])]\n                         (reduce (fn [new-square cell]\n                                   (let [[i j] cell\n                                         new-cell [(+ i j) (+ j (- middle i))]]\n                                     (assoc-in new-square new-cell (get-in square cell))))\n                                 new-square\n                                 square-cells))]\n    (mapv (partial apply str) rotated-square)))","user":"5ec6de19e4b08d0ec38692da"},{"problem":138,"code":"(fn \n  [base target]\n  (let [spiralize (fn spiralize\n          ([input-string] (spiralize (rest input-string) [[(first input-string)]]))\n          ([remaining acc]\n           (if (empty? remaining)\n             acc\n             (let [size (count acc)\n                   remaining+ (concat remaining (repeat \\*))\n                   setone (vec (take size remaining+))\n                   settwo (vec (take (inc size) (drop size remaining+)))\n                   t (fn [m] (apply mapv vector m))]\n               (spiralize (drop (inc (* 2 size)) remaining)\n                          (if (even? size)\n                            (concat [settwo] (t (concat [(vec (reverse setone))] (t acc))))\n                            (concat (t (concat (t acc) [setone])) [(vec (reverse settwo))])))))))\n        rotate-mat-45-degrees (fn\n          [m]\n          (let [height (count m)\n                width (count (first m))\n                newlength (dec (+ height width))]\n            (map (fn [sum] (apply concat\n                                  (keep-indexed\n                                    (fn [h row] (keep-indexed\n                                                  (fn [w val] (when (= sum (+ h w)) val))\n                                                  row))\n                                    m)))\n                 (range newlength))))\n        find-squarelist (fn fs [b t] (if (> b t) nil (cons b (fs (* b b) t))))\n        square-string (apply str (find-squarelist base target))\n        dimension (int (Math/ceil (Math/sqrt (count square-string))))\n        dimension2 (inc (* 2 (dec dimension)))\n        string-matrix (repeat dimension2 (repeat dimension2 \\space))\n        padded-string (concat square-string (take (- (* dimension dimension) (count square-string))\n                                                  (repeat \\*)))\n        spiral (spiralize padded-string)\n        rot (map reverse (rotate-mat-45-degrees spiral))\n        interwoven (map #(clojure.string/join \" \" %) rot)\n        new-width (apply max (map count interwoven))\n        maybe-done (map #(let [rep (apply str (take (/ (- new-width (count %)) 2) (repeat \" \")))] (str rep % rep)) interwoven)]\n    maybe-done))","user":"5d1b2b7de4b02ea6f0fb697a"},{"problem":138,"code":"(fn sol138\n  [n lim]\n  (let [b (->> (iterate #(* % %) n)\n               (take-while #(<= % lim))\n               (mapcat str)\n               (apply str))\n        cb (count b)\n        size (->> (iterate inc 1)\n                  (map #(* % %))\n                  (drop-while #(< % cb))\n                  first)\n        t (apply str (concat b (repeat (- size cb) \"*\")))]\n    (condp = size\n      1 [t]\n      4 [(str \" \" (nth t 0) \" \")\n         (str (nth t 3) \" \" (nth t 1))\n         (str \" \" (nth t 2) \" \")]\n      9 [(str \"  \" (nth t 6) \"  \")\n         (str \" \" (nth t 5) \" \" (nth t 7) \" \")\n         (str (nth t 4) \" \" (nth t 0) \" \" (nth t 8))\n         (str \" \" (nth t 3) \" \" (nth t 1) \" \")\n         (str \"  \" (nth t 2) \"  \")]\n      16 [(str \"   \" (nth t 6) \"   \")\n          (str \"  \" (nth t 5) \" \" (nth t 7) \"  \")\n          (str \" \" (nth t 4) \" \" (nth t 0) \" \" (nth t 8) \" \")\n          (apply str (interpose \" \" (map #(nth t %) [15 3 1 9])))\n          (str \" \" (apply str (interpose \" \" (map #(nth t %) [14 2 10]))) \" \")\n          (str \"  \" (nth t 13) \" \" (nth t 11) \"  \")\n          (str \"   \" (nth t 12) \"   \")])))","user":"528a3e14e4b0239c8a67ae72"},{"code":"(fn [s e]\n  (let [root (fn [n] (some #(if (>= (* % %) n) %) (range)))\n        move (fn [[a b] [c d]] [(+ a c) (+ b d)])\n        circ (fn [n] (let [f (cons 1 (repeat (- n 2) 0))] (concat [0] f f)))\n        inst (fn [n] (if (= 1 n) [0] (mapcat circ (range 2 (inc n)))))\n        sqrs (vec (mapcat str (take-while #(>= e %) (iterate #(* % %) s))))\n        n (root (count sqrs))\n        sqrs (map-indexed #(get sqrs % %2) (repeat (* n n) \\*))\n        r [[1 1] [1 -1] [-1 -1] [-1 1]]\n        start-p (vector ([[0 0] [0 1] [2 2] [2 3]] (dec n)))\n        spiral (fn [n] (loop [[i & w] (inst n) s start-p k 0]\n                         (if i (let [k' (rem (+ k i) 4)]\n                                 (recur w (conj s (move (last s) (r k'))) k')) s)))\n        frame (fn [n] (vec (repeat n (vec (repeat n \\space)))))]\n    (map (partial apply str)\n         (reduce (fn [r [c i]] (assoc-in r c i))\n                 (frame (dec (* n 2)))\n                 (map vector (spiral n) sqrs)))))","problem":138,"user":"4fdb02aae4b05e33b9224f56"},{"problem":138,"code":"(fn [n m]\n  (letfn [\n          (square-path []\n            (mapcat (fn [n] (concat (for [a (range (inc (* n 2)))]\n                                      [a (+ (- (* n 2)) a)])\n                                    (for [a (range 0 (inc (* n 2)))]\n                                      [(+ 1 (- (* n 2) a)) (+ 1 a)])\n                                    (for [a (range 0 (inc (inc (* n 2))))]\n                                      [(- a) (- (* (inc n) 2) a)])\n                                    (for [a (range 0 (inc (inc (* n 2))))]\n                                      [(+ (- (* (inc n) 2)) a) (- a)])))\n                    (iterate inc 0)))\n          (combine-square-with-str [s]\n            (map (fn [x y] [x y]) s (square-path)))\n          (squared [n m]\n            (apply str (map str (take-while #(<= % m) (iterate #(* % %) n)))))\n          (pad [s]\n            (let [c (first (drop-while #(< % (count s)) (map #(* % %) (range 1 10))))]\n              (str s (apply str (repeat (- c (count s)) \\*)))))]\n    (let [sq-str (combine-square-with-str (pad (squared n m)))\n          pad-x (- (apply min (map #(first (second %)) sq-str)))\n          pad-y (- (apply min (map #(second (second %)) sq-str)))\n          sq-str-padded (map (fn [[x y]] [x [(+ pad-x (first y)) (+ pad-y (second y))]]) sq-str)\n          size-x (inc (apply max (map #(first (second %)) sq-str-padded)))\n          size-y (inc (apply max (map #(second (second %)) sq-str-padded)))\n          board (vec (repeat size-y (vec (repeat size-x \\space))))]\n      (mapv #(apply str %)\n            (reduce (fn [bb [x y]]\n                      (assoc-in bb (reverse y) x)) board\n                    sq-str-padded)))))","user":"529dfc6de4b04e0c58e87b8a"},{"code":"(fn sqr-sqr [D low high]\n  (->> (iterate #(* % %) low)\n       (take-while #(<= % high))\n       (apply str)\n       (D)))\n\n(fn to-diamond [s]\n  (let [len (count s)\n        dim (int (Math/ceil (Math/sqrt len)))\n        padding (repeat (- (* dim dim) len) \\*)\n        appender {-1 #(str %2 %) 1 #(str % %2)}\n        update (fn [dir rows i item]\n                 (assoc rows i ((appender dir) (or (rows i) \"\") item)))\n        args (fn [i dir targets]\n               (if (= i (first targets))\n                 [(- i dir) (- dir) (rest targets)]\n                 [(+ i dir) dir targets]))\n        pad (fn [rows]\n              (let [n (apply max (map count rows))]\n                (for [r rows]\n                  (let [p (repeat (/ (- n (count r)) 2) \\space)]\n                    (apply str (concat p r p))))))\n        align (fn [rows]\n                (->>\n                  (vals rows)\n                  (map #(interpose \\space %))\n                  (pad)\n                  (vec)))]\n    (loop [items (concat (rest s) padding)\n           i 1\n           direction 1\n           targets (iterate #(if (pos? %) (- %) (+ 2 (- %))) 2)\n           rows (sorted-map 0 (str (first s)))]\n      (if (empty? items) (align rows)\n        (let [[head & tail] items\n              rows (update direction rows i head)\n              [i dir targets] (args i direction targets)]\n          (recur tail i dir targets rows))))))","problem":138,"user":"4f6160a7e4b0defedf855fbe"},{"code":"(fn ss [s e]\n  (let\n      [next-step (fn [[x y]]\n                  (cond\n   (and (pos? x) (pos? y) ) [(inc x) (dec y)]\n   (and (pos? x) (neg? y)) [(dec x) (dec y)]\n   (and (neg? x) (pos? y)) [(inc x) (inc y)]\n   (and (neg? x) (neg? y)) [(dec x) (inc y)]\n   (and (zero? x) (pos? y))[(inc x) (dec y)]\n   (and (zero? x) (neg? y))[(dec x) (inc y)]\n   (and (pos? x) (zero? y))[(inc x) (dec y)]\n   (and (neg? x) (zero? y))[(inc x) (inc y)]\n   true [(inc x) (dec y)]\n   ) )\n       p (take-while #(<= % e) (iterate #(* % %) s))\n       s (reduce str \"\" p)\n       l1 (#(cond\n             (= 1 %) 1\n             (<= % 4) 4\n             (<= % 9) 9\n             (<= % 16) 16)\n           (count s))\n        ld (#(cond\n              (= 1 %) 0\n              (<= % 4) 1\n              (<= % 9) 2\n              (<= % 16) 3) (count s))\n       s' (clojure.string/replace (format (str \"%-\" l1 \"s\") s) #\" \" \"*\")\n       m (map #(hash-map %1 %2) (iterate next-step [0 0]) s')\n       h (->> m\n              (apply merge)\n               (keys)\n               (into [])\n               (map second)\n               (apply max)\n\n               )\n       high (inc (* 2 ld))\n       yoffset (if (= 0 ld) 1 (* 2 ld))\n       m'(->>\n           m\n           (map #(hash-map [(+ ld (first (ffirst %)))\n                            (+ h (- (second (ffirst %))))]\n                           (second (first %))))\n           (apply merge))\n\n        m'' (for [i (range 0 high) j (range 0 high)]\n              [(get m' [j i] \\space)])\n       m''' (->>\n            m''\n            (partition high)\n            (map #(apply concat %))\n            (map #(reduce str \"\" %)))\n       ]\n    m'''))","problem":138,"user":"52140b53e4b0961f15ac4d7e"},{"code":"(fn [s e]\n    (let [coll (mapcat str (take-while #(<= % e) (iterate #(* % %) s)))\n          n ((comp first filter) #(>= (* % %) (count coll)) (iterate inc 1))\n          coll (take (* n n) (concat coll (repeat \\*)))\n          width (nth (iterate #(+ 2 %) 1) (dec n))\n          movements [#(+ % width 1) #(+ % width -1) #(- % width 1) #(- % width -1)]\n          movements (map movements (mapcat #(concat (repeat % 0) (repeat % 1) (repeat (inc %) 2) (repeat (inc %) 3)) (iterate #(+ 2 %) 1)))\n          coll (reductions (fn [[pos _] [x f]]\n                             [(f pos) x])\n                           [0 (first coll)] (map vector (next coll) movements))\n          translation (+ (quot width 2) (- (first (apply min-key first coll))))\n          coll (map #(update-in % [0] + translation)  coll)\n          to-coord #((juxt quot rem) % width)\n          result (into [] (repeat width (into [] (repeat width \\ ))))]\n      (map #(apply str %)\n           (reduce (fn [acc [i x]]\n                     (assoc-in acc (to-coord i) x)) result coll))))","problem":138,"user":"507056b8e4b07bd6ad9b9f29"},{"code":"(fn [start end]\n  (letfn [(digits [n]\n            (if (= 0 n) '(0)\n                (loop [n n\n                       digits '()]\n                  (if (= 0 n) digits\n                      (recur (quot n 10)\n                             (conj digits (rem n 10)))))))\n\n          (square-up [n]\n            (if (= 1 n) 1\n                (loop [s 2]\n                  (if (>= (* s s) n) s\n                      (recur (inc s))))))\n\n          (star-fill [coll total-elts]\n            (let [n (count coll)\n                  nstars (- total-elts n)]\n              (concat coll (repeat nstars \"*\"))))\n\n          (squares [start end]\n            (take-while #(>= end %)\n                        (iterate #(* % %) start)))\n\n          (vec-pts [index dim orient reverse-flag]\n            (let [[x y] (if (= orient :row)\n                          (vector (repeat index) (range))\n                          (vector (range) (repeat index)))\n                  v (take dim\n                          (partition 2 (interleave x y)))]\n              (if reverse-flag (reverse v) v)))\n\n          (spiral [n]\n            (loop [dim 1\n                   pts [[0 0]]]\n              (if (= n dim) pts\n                  (let [next-dim (inc dim)\n                        next-pts (if (even? next-dim)\n                                   (concat pts\n                                           (vec-pts dim next-dim :col false)\n                                           (rest (vec-pts dim next-dim :row true)))\n                                   (concat (map #(map inc %) pts)\n                                           (vec-pts 0 next-dim :col true)\n                                           (rest (vec-pts 0 next-dim :row false))))]\n                    (recur next-dim next-pts))))) \n\n          (square-matrix [dim]\n            (vec (repeat dim\n                         (vec (repeat dim 0)))))\n\n          (mass-update [m ks vs]\n            (loop [m m\n                   ks ks\n                   vs vs]\n              (if (empty? ks) m\n                  (recur (update-in m (first ks) (fn [old] (first vs)))\n                         (rest ks)\n                         (rest vs)))))\n\n          (antidiag-pts [dim start]\n            (take-while  #(and (< -1 (first %))\n                               (> dim (second %)))\n                         (iterate #(list (dec (first %))\n                                         (inc (second %)))\n                                  start))) \n\n          (get-pts [m pts]\n            (map #(get-in m %) pts))\n\n          (antidiags [m]\n            (let [dim (count m)\n                  starts (concat\n                          (vec-pts 0 dim :col false)\n                          (rest (vec-pts (dec dim) dim :row false)))\n                  pts (map #(antidiag-pts dim %) starts)]\n              (map #(get-pts m %) pts)))\n\n          (sqsq [start end]\n            (let [sqs (flatten (map digits (squares start end)))\n                  dim (square-up (count sqs))\n                  sqs (star-fill sqs (* dim dim))]\n              (antidiags\n               (mass-update\n                (square-matrix dim)\n                (spiral dim)\n                sqs)))) \n\n          (pad-line [dim elts]\n            (let [core (clojure.string/join \" \" (map str elts))\n                  npad (/ (- (dec (* 2 dim))\n                             (dec (* 2 (count elts))))\n                          2)\n                  pad (clojure.string/join (repeat npad \" \"))]\n              (clojure.string/join [pad core pad])))] \n\n    (let [mat (sqsq start end)\n          dim (apply max (map count mat))]\n      (map #(pad-line dim %) mat))))","problem":138,"user":"524ae8e6e4b09eba1c0223b5"},{"code":"(letfn [\r\n  (squares [a b] \r\n    (take-while #(<= % b) (iterate #(* % %) a)))\r\n\r\n\t(chr-seq [a b]\r\n\t  (loop [i 1 s (apply str (squares a b)) acc []]\r\n\t    (let [[x y] (split-at i s)]\r\n\t      (if (empty? y)\r\n\t        (conj acc (take i (concat s (repeat \\*))))\r\n\t        (recur (+ 2 i) y (conj acc x))))))\r\n\t\r\n\t(flip [ ss ]\r\n\t  (reverse (map reverse ss)))\r\n\t\r\n\t(lay [ ss s ]\r\n\t  (map cons s\r\n\t    (concat [[]] (map #(cons \\space %) ss) [[]])))\r\n\t\r\n\t(layall [a b]\r\n\t  (let [[layer & layers] (chr-seq a b)]\r\n\t    (reduce #(flip (lay % %2)) [layer] layers)))\r\n\t\r\n\t(pad [s n]\r\n\t  (let [p (repeat (/ (- n (count s)) 2) \\space)]\r\n\t    (concat p s p)))\r\n\t\r\n\t(padall [ss]\r\n\t  (let [n (count ss)]\r\n\t    (map #(pad % n) ss)))\r\n\t  \r\n\t(fix [ss]\r\n\t  (let [xss (if (== (rem (count ss) 4) 1) (flip ss) ss)]\r\n\t    (apply (partial map list) xss)))\r\n\t\r\n\t(solve [ a b ]\r\n\t  (map (partial apply str) (fix (padall (layall a b)))))]\r\n  \r\n  solve)","problem":138,"user":"4f569218e4b0a7574ea71826"},{"problem":138,"code":"(fn [n m]\n  (let [s (apply str (take-while #(<= % m) (iterate #(* % %) n)))\n        c (count s)\n        sq (->> c Math/sqrt Math/ceil int)\n        charseq (take (* sq sq) (concat s (repeat \\*)))\n        strc (map vector (reductions (fn [[a b] [x y]] [(+ a x) (+ b y)])\n                                     [0 0] (mapcat #(repeat % %2)\n                                                           (mapcat #(vector % %) (rest (range)))\n                                                           (cycle [[1 1] [1 -1] [-1 -1] [-1 1]])))\n                  charseq)\n        maxx (fn [f xs] (apply max (map (fn [[a]] (println a)  (- (f a) )) xs)))\n        maxI (maxx first strc)\n        maxJ (maxx second strc)]\n    (map #(apply str %)\n         (reduce (fn [red [[i j] ch]]  (assoc-in red [(+ i maxI) (+ j maxJ)] ch))\n                 (vec (repeat (dec (* 2 sq))  (vec (repeat (dec (* 2 sq)) \\space))))\n                 strc))))","user":"5c379636e4b0d62ef62d9f76"},{"code":"(fn [a b]\n  (letfn [(factors [a' b']\n            (cond\n              (= a' b') [a']\n              (> a' b') []\n              :else (cons a' (lazy-seq (factors (* a' a') b')))))\n          (next-square [n]\n            (first (drop-while #(> n %) (map #(* % %) (iterate inc 1)))))\n          (buff [s]\n            (let [len (.length s)]\n              (apply str s (repeat (- (next-square len) len) \"*\"))))\n          (start-point [d n]\n            (let [n' (int (/ n 2))]\n              (if (odd? d)\n                [n' n']\n                [(dec n') n'])))\n          (get-em [moves n iter?]\n            (concat\n              (repeat n (first moves))\n              (lazy-seq (get-em (rest moves) (if iter? (inc n) n) (not iter?)))))\n          (modify-board [board point c]\n            (let [[y x] point]\n              (assoc\n                board\n                y\n                (assoc (nth board y) x c))))\n          (chg-point [point delta]\n            (let [[y x] point\n                  [dy dx] delta]\n              [(+ y dy) (+ x dx)]))]\n    (let [s (buff (apply str (factors a b)))\n          d (int (Math/sqrt (.length s)))\n          n (dec (* 2 d))\n          dr [ 1  1] dl [ 1 -1] ul [-1 -1] ur [-1  1]\n          all (cycle [dr dl ul ur])\n          moves (take (dec (.length s)) (get-em all 1 false))\n          start (start-point d n)\n          board (into [] (repeat n (into [] (repeat n \" \"))))\n          res (if (empty? moves)\n                { :board board :point start :string s }\n                (reduce\n                  (fn [env move]\n                    (let [point (:point env)\n                          board (:board env)\n                          s (:string env)\n                          board'\n                          (modify-board board point (first s))]\n                      (merge env {:point (chg-point point move)\n                                  :board board'\n                                  :string (rest s)})))\n                  {\n                   :point (chg-point start (first moves))\n                   :board (modify-board board start (first s))\n                   :string (rest s)\n                  }\n                  (rest moves)))]\n      (map #(apply str %) (modify-board (:board res) (:point res) (first (:string res)))))))","problem":138,"user":"51195e77e4b055cfb310d499"},{"problem":138,"code":"(fn __ [start end]\n    (let [digits (apply str (take-while #(<= % end)(iterate #(* % %) start)))\n           l (count digits)\n           size  (inc (int (Math/sqrt (dec l))))\n           square-upper-bound (* size size)\n           padded (apply str digits (repeat (- square-upper-bound l) \\*))\n           turn {[1, 1] [1 -1], [1, -1] [-1 -1], [-1 -1] [-1 1], [-1 1] [1 1]}\n           add-cell (fn [[[sr sc] [dr dc] state edge-length step-count edge-count] d]\n                      (let [next-cell [(+ sr dr) (+ sc dc)]\n                            new-state (assoc state next-cell d)]\n                        (if (< step-count edge-length)\n                          [next-cell [dr dc] new-state edge-length (inc step-count) edge-count]\n                          (let [next-d (turn [dr dc])\n                                edge-length (+ edge-length edge-count)\n                                edge-count (- 1 edge-count)]\n                            [next-cell next-d new-state edge-length 1 edge-count]\n                            ))))\n           starting-cell [(if (even? size) (- size 2) (dec size)) (dec size)]\n           state (reduce add-cell\n                         [starting-cell [1 1] {starting-cell (first padded)} 1 1 0]\n                         (rest padded))\n           char-map (first (drop 2 state))]\n          (apply vector (for [i (range (dec (* size 2)))]\n                   (apply str (for [j (range (dec (* 2 size)))]\n                                (get char-map [i j] \\space)))))))","user":"56897739e4b0dcc4269f407d"},{"code":"(fn p138 [lo hi]\n  (letfn [\n    (sqr [x] (* x x))\n\n    (squares [lo hi]\n      (->> (iterate sqr lo)\n           (take-while #(<= % hi))\n      ))\n\n    (digits [lo hi]\n      (->> (squares lo hi)\n           (mapcat str)\n           vec))\n\n    (gen-square [side]\n      (if (= side 1)\n        [[0]]\n        (let [core (gen-square (dec side))\n              core (if (even? side) (conj core [] []) (vec (concat [[] []] core)))\n              incr (if (even? side) inc dec)\n              nums (vec (range (sqr (dec side)) (sqr side)))\n              nums (if (even? side) (rseq nums) nums)]\n          (loop [res core, row (dec side), start 0, stop (dec (count nums))]\n            (if (= start stop)\n              (update-in res [row] conj (nth nums start))\n              (recur (update-in res [row] #(vec (concat [(nth nums start)] % [(nth nums stop)])))\n                     (incr row) (inc start) (dec stop)))))\n      ))\n\n    (draw-square [digits]\n      (let [num-digs (count digits)\n            side (some #(when (<= num-digs (sqr %)) %) (iterate inc 1))\n            indices (gen-square side)\n            rowlen (+ side (dec side))\n            padsrc (apply str (repeat rowlen \\space))]\n        (for [row indices]\n          (let [text\n                (->> (map #(get digits % \\*) row)\n                     (interpose \\space)\n                     (apply str))\n                pad (subs padsrc 0 (/ (- rowlen (count text)) 2))]\n            (str pad text pad)\n          ))))\n  ]\n  (draw-square (digits lo hi))\n))","problem":138,"user":"4df3d4f4535d08e6dec9fe2c"},{"problem":138,"code":"(fn tt [s e]\n (let [t (take-while #(<= % e) (iterate #(* % %) s))\n       c (count (apply str t))\n       d (int (Math/ceil (Math/sqrt c)))\n       e (* d d)\n       f (dec (* 2 d))\n       x (drop c (repeat e \"*\"))\n       y (apply str (map str (concat t x)))\n       z (comp vec repeat)\n       b (z f (z f \\space))\n       a (fn [u] (mapcat #(repeat (+ u (* 2 %)) (int (Math/pow -1 (+ 1 u %)))) (range)))\n       m (a 0)\n       n (a 1)\n       p (for [i (range (dec e))]\n          [(nth m i) (nth n i)])\n       g (dec d)\n       q [(- g (mod g 2)) g] \n       r (reduce #(conj % (map + (last %) %2)) [q] p)]\n  (map #(apply str %)\n   (loop [r r y y b b]\n    (if (seq r)\n     (recur (rest r) (rest y) (assoc-in b (first r) (str (first y))))\n     b)))))","user":"5b0180cfe4b0cc2b61a3bd47"},{"code":"(letfn [(partition-step\n         [init step xs]\n         (lazy-seq\n          (when (seq xs)\n            (let [[head tail] (split-at init xs)]\n              (cons head (partition-step (+ init step)\n                                         step tail))))))\n\n        (next-sqr\n         [sqr digits]\n         (let [size (count sqr)\n               [head tail] (split-at size digits)]\n           (if (even? size)\n             (vec (cons (vec tail)\n                        (map (comp vec cons)\n                             (reverse head)\n                             sqr)))\n             (conj (mapv conj sqr head)\n                   (vec (reverse tail))))))\n        \n        (addends\n         [start stop]\n         (lazy-seq\n          (when (>= stop 0)\n            (cons [start stop]\n                  (addends (inc start)\n                           (dec stop))))))\n        \n        (skew\n         [sqr]\n         (let [size (count sqr)]\n           (->> (range (dec (* size 2)))\n                (map (partial addends 0))\n                (map #(for [[x y :as xy] %\n                            :when (> size x)\n                            :when (> size y)]\n                        (get-in sqr xy)))\n                (map reverse))))\n        \n        (sqr->romb\n         [sqr]\n         (let [size (-> sqr count (* 2) dec)]\n           (->> (skew sqr)\n                (map (partial interpose \\space))\n                (map #(let [n (/ (- size (count %)) 2)\n                            padding (repeat n \\space)]\n                        (concat padding % padding)))\n                (map (partial apply str)))))]\n  \n  (fn sqr-sqr\n    [start stop]\n    (let [digits\n          (->> (iterate #(* % %) start)\n               (take-while (partial >= stop))\n               (apply str))\n\n          size\n          (-> digits\n              count\n              Math/sqrt\n              Math/ceil)]\n      \n      (->> (repeat \\*)\n           (concat digits)\n           (take (* size size))\n           (partition-step 1 2)\n           (reduce next-sqr [])\n           sqr->romb))))","problem":138,"user":"532ab0bde4b09d4e7a9b5527"},{"problem":138,"code":"(fn squares-squared\n  [n m]\n  (let [square (fn [x] (*' x x))\n        character-stream (fn [n m]\n                           (let [digits (mapcat str\n                                                (take-while (partial >= m)\n                                                            (iterate square n)))\n                                 pad (repeat\n                                       (first (keep (fn [x]\n                                                      (let [diff (- (count digits) x)]\n                                                        (when (<= diff 0)\n                                                          (- diff))))\n                                                    (map square (iterate inc 1))))\n                                       \"*\")]\n                             (concat digits pad)))\n        create-matrix (fn [n]\n                        (let [d (nth (iterate (partial + 2) 1) (dec (int (Math/sqrt n))))]\n                          (vec (repeat d (vec (repeat d \" \"))))))\n        path (fn [dimension]\n               (let [init (some identity\n                                (map (fn [i x y]\n                                       (when (= i dimension)\n                                         [x y]))\n                                     (iterate (partial + 2) 1)\n                                     (range)\n                                     (apply concat (iterate (partial map (partial + 2)) [0 0]))))]\n                 (reduce (fn [acc [dx dy]]\n                           (let [[x y] (last acc)]\n                             (conj acc [(+ x dx) (+ y dy)])))\n                         [init]\n                         (mapcat (fn [n direction]\n                                   (repeat n direction))\n                                 (first\n                                   (keep (fn [i]\n                                           (when (= dimension i)\n                                             (if (= i 1)\n                                               [0]\n                                               (let [xs (take (dec i) (apply concat (iterate (partial map (partial + 1)) [1 1])))]\n                                                 (concat xs [(last xs)])))))\n                                         (iterate (partial + 2) 1)))\n                                 (cycle [[1 1] [-1 1] [-1 -1] [1 -1]])))))\n        stream (character-stream n m)\n        matrix (create-matrix (count stream))]\n    (mapv (partial apply str)\n          (reduce (fn [acc [[x y] c]]\n                    (assoc-in acc [y x] c))\n                  matrix\n                  (map vector (take (count stream) (path (count matrix))) stream)))))","user":"4dc0ff08535d020aff1edf84"},{"code":"(fn [start end]\n  (letfn [(go [start step dir] \n              (take step \n                    (iterate \n                     #(map + % (second dir))\n                     (map + start (first dir)))))\n          ]\n  (let [\n    nums (->> start (iterate #(* % %)) (take-while #(<= % end)))\n    str-res (apply str nums)\n    str-len (count str-res)\n    dir-seq (cycle [[1 1] [1 -1] [-1 -1] [-1 1]])\n    pos (loop [pos [[0 0]]\n               level 2\n               dir-seq dir-seq]\n              (if (>= (count pos) str-len)\n               pos\n               (let [new-pos (go (last pos) (dec level) dir-seq)\n                     dir-seq (next dir-seq)\n                     new-pos (concat new-pos (go (last new-pos) level dir-seq))\n                     ]\n                     (recur (into pos new-pos)\n                            (inc level)\n                            (next dir-seq)))))\n    minx (apply min (map first pos))\n    miny (apply min (map second pos))\n    pos (map (fn [[x y]] [(- x minx) (- y miny)]) pos)\n    res (into {} (map vector pos (concat str-res (repeat \"*\"))))\n    L (-> (min minx miny)  - (* 2) inc)\n    res (for [row (range L)]\n         (apply str\n          (for [col (range L)]\n           (res [row col] \" \"))))\n    ]\n    res)\n))","problem":138,"user":"519b2570e4b0ac1b7dced6a3"},{"problem":138,"code":"(fn [start end]\n  (let [n2    (fn [n] (* n n))\n        sqrs  (take-while #(<= % end) (iterate n2 start))\n        data  (apply str (map #(str %) sqrs))\n\n        ops   (cycle [[inc inc] [inc dec] [dec dec] [dec inc]])\n        steps (mapcat #(repeat 2 %) (drop 1 (range)))\n        cmds  (mapcat #(repeat % %2) steps ops)\n\n        area  (first (drop-while #(< % (count data)) (map n2 (range))))\n        edge  (int (Math/sqrt area))\n        cross (- (* 2 edge) 1)\n\n        r0    (- (quot cross 2) (if (even? edge) 1 0))\n        draw  (take area (map vector (lazy-cat data (repeat \\*)) cmds))\n        table (vec (repeat cross (vec (repeat cross \\space))))]\n\n    (loop [ [[v [f g]] & nd] draw\n            [row col]        [r0 (dec edge)]\n            table            table ]\n      (if v\n        (recur nd \n               [(f row) (g col)]  \n               (assoc table row (assoc (table row) col v)))\n        (map #(apply str %) table)))))","user":"5712854ce4b07c98581c3a89"},{"problem":138,"code":"(fn square-squared [start end]\n   (let [vector-of-squares (loop [acc (vector start)\n                                  number start]\n                             (if (> (* number number) end)\n                               acc\n                               (recur (conj acc (* number number)) (* number number))))\n         square-number (first (drop-while #(< % (count (apply str vector-of-squares))) (map #(* % %) (rest (range)))))\n         string-digits-* (apply str\n                                (apply str vector-of-squares)\n                                (repeat (- square-number (count (apply str vector-of-squares))) \"*\"))\n         extend-square-even-n (fn [square n]\n                                (let [top (+ (* n n) (* -3 n) 2)\n                                      left (- (* n n) 1)\n                                      right (* (dec n) (dec n))\n                                      bottom (- (* n n) n)]\n                                  (for [k (range (+ 2 (count square)))]\n                                    (cond\n                                      (< k (- n 1)) (str \" \" (nth square k) \" \")\n                                      (< k (- (+ n (dec n)) 2)) \n                                        (str \n                                           (apply str (repeat (- (inc k) n) \" \"))\n                                           (nth string-digits-* (- left (- (inc k) n))) \n                                           \" \" \n                                           (clojure.string/trim (nth square k))\n                                           \" \"\n                                           (nth string-digits-* (+ right (- (inc k) n)))\n                                           (apply str (repeat (- (inc k) n) \" \")))          \n                                      (= k (- (+ n (dec n)) 2)) \n                                         (str\n                                           (apply str (repeat (- n 2) \" \"))\n                                           (nth string-digits-* (inc bottom))\n                                           \" \"\n                                           (nth string-digits-* (dec bottom))\n                                           (apply str (repeat (- n 2) \" \")))              \n                                      :else (str\n                                              (apply str (repeat (dec n) \" \"))\n                                              (nth string-digits-* bottom)\n                                              (apply str (repeat (dec n) \" \")))))))\n        extend-square-odd-n (fn [square n]\n                              (let [top (- (* n n) n)\n                                    left (* (dec n) (dec n))\n                                    right (- (* n n) 1)\n                                    bottom (+ (* n n) (* -3 n) 2)]\n                                (for [i (range (+ 2 (count square)))]\n                                  (cond\n                                    (= i 0) (str\n                                              (apply str (repeat (dec n) \" \"))\n                                              (nth string-digits-* top)\n                                              (apply str (repeat (dec n) \" \")))\n                                    (= i 1) (str \n                                              (apply str (repeat (- n 2) \" \"))\n                                              (nth string-digits-* (dec top))\n                                              \" \"\n                                              (nth string-digits-* (inc top))\n                                              (apply str (repeat (- n 2) \" \")))\n                                    (< i n) (str\n                                              (apply str (repeat (- (dec n) i) \" \"))\n                                              (nth string-digits-* (- top i))\n                                              \" \"\n                                              (clojure.string/trim (nth square (- i 2)))\n                                              \" \"\n                                              (nth string-digits-* (+ top i))\n                                              (apply str (repeat (- (dec n) i) \" \")))\n                                    :else (str \" \" (nth square (- i 2)) \" \")))))]\n\n       (loop [acc ()\n              a 0]\n         (if (= a (int (Math/sqrt (count string-digits-*))))\n           (vec (reverse (map #(apply str %) (map reverse acc))))\n           (cond\n             (= 0 a) (recur (list (str (first string-digits-*))) (inc a))\n             (odd? a) (recur (extend-square-odd-n acc (inc a)) (inc a))\n             (even? a) (recur (extend-square-even-n acc (inc a)) (inc a)))))))","user":"58dcb8cde4b0a4d5acaab6a7"},{"problem":138,"code":"(fn squares-squared [start end]\n    (let [square #(* % %)\n          join clojure.string/join\n          vec+ (partial mapv +)\n\n          digits (->> start\n                      (iterate square)\n                      (take-while #(<= % end))\n                      (map str)\n                      (mapcat seq))\n\n          side-len (-> (count digits) Math/sqrt Math/ceil int)\n          area (square side-len)\n\n          asterisks (repeat (- area (count digits)) \\*)\n\n          stride-lens (mapcat #(repeat 2 %) (drop 1 (range)))\n          stride-dirs (cycle [[1 1] [-1 1] [-1 -1] [1 -1]])\n          t (prn side-len)\n          t (prn area)\n          strides (take area (mapcat #(repeat %1 %2)\n                                     stride-lens\n                                     stride-dirs))\n\n          ;; side len of aligned bounding box of rotated square\n          out-side-len (dec (* 2 side-len))\n\n          ;; points are [x y], with [0 0] in the top left\n          start-pos [(dec side-len)\n                     (-> side-len dec (/ 2) Math/floor (* 2) int)]\n          char-locations (reduce (fn [locs stride]\n                                   (conj locs\n                                         (vec+ (last locs)\n                                               stride)))\n                                 [start-pos]\n                                 (drop-last strides))\n\n          render\n          (->> (concat digits asterisks)\n               (map (fn [[x y] c] [x y c]) char-locations)\n               (group-by second)\n               (sort-by first)\n               (map (fn [[_ coords]]\n                      (into {} (map (fn [[x _ c]] [x c])\n                                    coords))))\n               (map (fn [char-locs]\n                      (map #(get char-locs % \\space)\n                           (range out-side-len))))\n               (mapv (partial apply str)))]\n      (doall render)))","user":"54be7772e4b0ed20f4ff6eea"},{"code":"(fn [s e]\n\t(let [sl (take-while #(<= % e) (iterate #(* % %) s))\n\t      sl2 (mapcat #(re-seq #\"\\d\" (str %)) sl)\n\t      size (Math/ceil (Math/sqrt (count sl2)))\n\t      full-list (concat sl2 (repeat (- (* size size) (count sl2)) \"*\"))\n\t      offset (take (* size size) ((fn of [n] \n\t\t\t(if (zero? n) \n\t\t\t\t(cons [0 0] (lazy-seq (of 1)))\n\t\t\t\t(concat \n\t\t\t\t\t(repeat n [1 1])\n\t\t\t\t\t(repeat n [-1 1])\n\t\t\t\t\t(repeat (inc n) [-1 -1])\n\t\t\t\t\t(repeat (inc n) [1 -1])\n\t\t\t\t\t(lazy-seq (of (+ n 2)))))) 0))\n\t      center [(dec size) (- (dec size) (mod (dec size) 2))]\n\t      matrix1 (apply hash-map (interleave\n\t\t\t(map\n\t\t\t\t(fn [[dx dy]] [(int (+ dx (first center))) (int (+ dy (last center)))])\n\t\t\t\t(reductions (fn [[dx dy] [dx2 dy2]] [(+ dx dx2) (+ dy dy2)]) offset))\n\t\t\tfull-list))\n\t     ]\n\t\t(for [x (range (dec (* size 2)))]\n\t\t\t(apply str (for [y (range (dec (* size 2)))]\n\t\t\t\t(let [r (get matrix1 [y x])]\n\t\t\t\t\t(if (nil? r) \n\t\t\t\t\t\t\" \" \n\t\t\t\t\t\tr)))))))","problem":138,"user":"5034b0e1e4b062bc5d7ae167"},{"code":"(fn solver [from upto]\n  (let [squares-seq (take-while #(<= % upto) (iterate #(* % %) from))\n        digits-seq (letfn [(digits [n]\n                             (map #(- (int %) 48) (str n)))\n                           (square? [x]\n                             (= (Math/sqrt x) (Math/floor (Math/sqrt x))))\n                           (padding [s]\n                             (if (square? (count s))\n                               s\n                               (padding (concat s [\\*]))))]\n                     (->> squares-seq\n                          (mapcat digits)\n                          padding))\n        move-seq (let [directions [[inc inc] [inc dec] [dec dec] [dec inc]]\n                       length-seq (mapcat #(repeat 2 %) (iterate inc 1))]\n                   (mapcat #(repeat % %2) length-seq (cycle directions)))\n        scale (int (Math/sqrt (count digits-seq)))\n        start ([[0 0] [0 1] [2 2] [2 3]] (dec scale))\n        coordinates-seq (reductions (fn [[y x] [fy fx]]\n                                      [(fy y) (fx x)])\n                                    start\n                                    move-seq)\n        white-board (let [size (dec (* 2 scale))]\n                      (vec (repeat size (vec (repeat size \\space)))))]\n    (->> (map #(vector % %2) coordinates-seq digits-seq)\n         (reduce (fn [board [k v]]\n                   (assoc-in board k v))\n                 white-board)\n         (map #(apply str %))\n         vec)))","problem":138,"user":"4f3fb586e4b0e243712b1f9c"},{"problem":138,"code":"(fn [start end]\n  (let [n (apply str (take-while #(<= % end) (iterate #(* % %) start)))\n        d (int (Math/ceil (Math/sqrt (count n))))\n        t (* d d)\n        w (dec (+ d d))\n        iy (if (even? d) (- d 2) (dec d))\n        ix (dec d)\n        y (take t (reductions + iy (mapcat #(repeat (+ % %) (if (even? %) -1 1)) (range))))\n        x (take t (reductions + ix (mapcat #(repeat (+ % % 1) (if (even? %) 1 -1)) (range))))\n        m (apply merge (for [i (range t)]\n                         {[(nth y i) (nth x i)] (get-in n [i] \\*)}))]\n    (for [i (range w)](apply str (for [j (range w)] (m [i j] \\space))))))","user":"53ce4cd4e4b00fb29b2212ef"},{"problem":138,"code":"(fn [s e]\n  {:pre [(<= 1 s e)]}\n  (let [squares (take-while #(<= % e) (iterate #(* % %) s))\n        digits (mapcat str squares)\n        square-side (long (Math/ceil (Math/sqrt (count digits))))\n        square-size (* square-side square-side)\n        digits (concat digits (repeat (- square-size (count digits)) \\*))\n        board-side (inc (* 2 (dec square-side)))\n        board (vec (repeat board-side (apply str (repeat board-side \\ ))))\n        half-side (dec square-side)\n        center [(if (even? square-side) (dec half-side) half-side) half-side]\n        drawer {:center center :board board}\n        directions (cycle [[1 1] [1 -1] [-1 -1] [-1 1]])]\n    (letfn [(draw [c]\n              (fn [{[i j] :center board :board}]\n                {:board  (assoc board i (apply str (assoc (vec (get board i)) j c)))\n                 :center [i j]}))\n            (move [[di dj]]\n              (fn [{[i j] :center board :board}]\n                {:board  board\n                 :center [(+ i di) (+ j dj)]}))\n            (n-moves [n d] (repeat n (move d)))]\n      (let [draw-commands (map draw digits)\n            move-commands (mapcat #(n-moves %1 %2) (interleave (rest (range)) (rest (range))) directions)\n            commands (interleave draw-commands move-commands)]\n        (:board (reduce #(%2 %1) drawer commands))))))","user":"5f300f28e4b033932238a682"},{"problem":138,"code":"(fn squares-squared\n  [start end]\n  (letfn [(square-seq\n            [current end]\n            (let [next-square (* current current)]\n              (if (< end next-square)\n                [current]\n                (cons current (square-seq next-square end)))))\n\n          (digits->size\n            [digits]\n            (cond\n              (= 1 digits)\n              {:size 1 :positions [[0 0]]}\n\n              (and (<= 2 digits) (>= 4 digits))\n              {:size 3 :positions [[0 1] [1 2] [2 1] [1 0]]}\n              \n              (and (<= 5 digits) (>= 9 digits))\n              {:size 5 :positions [[2 2] [3 3] [4 2] [3 1] [2 0] [1 1] [0 2] [1 3] [2 4]]}\n\n              (and (<= 10 digits) (>= 16 digits))\n              {:size 7 :positions [[2 3] [3 4] [4 3] [3 2] [2 1] [1 2] [0 3] [1 4] [2 5] [3 6] [4 5] [5 4] [6 3] [5 2] [4 1] [3 0]]}))\n\n          (generate-prepared-vec\n            [size positions]\n            (let [empty-vec\n                  (vec (repeat size (vec (repeat size \" \"))))]\n              (reduce (fn [build [x y]] (assoc-in build [x y] \"*\")) empty-vec positions)))]\n    (let [squares\n          (mapcat (fn [square] (mapv str (str square))) (square-seq start end))\n\n          {:keys [size positions]}\n          (digits->size (count squares))\n\n          prepared-vec (generate-prepared-vec size positions)\n\n          replacement-vec (map vector squares positions)]\n\n      (map #(apply str %) (reduce (fn [build [s [x y]]] (assoc-in build [x y] s)) prepared-vec replacement-vec)))))","user":"5b759ca8e4b047b03b2036d0"},{"problem":138,"code":"(fn [a b]\n  (let [square-string (fn [a b]\n                        (let [s (apply str (take-while #(<= % b) (iterate #(* % %) a)))\n                              squares (map #(* % %) (drop 1 (range)))\n                              sqr (first (drop-while #(< % (count s)) squares))]\n                          (apply str s (repeat (- sqr (count s)) \\*))))\n                          \n        spiral (fn [s]\n                 (let [counters (mapcat (juxt identity identity) (range))]\n                   (loop [[char & s] s\n                          acc {}\n                          [x y] [0 0]\n                          counter (first counters)\n                          counters (rest counters)\n                          angle 0]\n                     (if char\n                       (let [[dx dy] ((juxt #(Math/round (Math/cos %)) #(Math/round (Math/sin %))) angle)]\n                         (recur\n                           s\n                           (assoc-in acc [y x] char)\n                           [(+ x dx) (+ y dy)]\n                           (if (zero? counter) (first counters) (dec counter))\n                           (if (zero? counter) (rest counters) counters)\n                           (if (zero? counter) (- angle (/ Math/PI 2)) angle)))\n                       acc))))\n                       \n        vectorize (fn [m]\n                    (->> (keys m)\n                         sort\n                         reverse\n                         (map (partial get m))\n                         (mapv #(->> (keys %)\n                                     sort\n                                     (map (partial get %))\n                                     (into [])))))\n        display  (fn [v]\n                   (->> v\n                        (map-indexed (fn [i x]\n                                       (concat (repeat i nil)\n                                               x\n                                               (repeat (dec (- (count v) i)) nil))))\n                        reverse\n                        (apply map vector)\n                        (map (partial keep identity))\n                        (map #(clojure.string/join \" \" %))\n                        (map #(let [padding (apply str (repeat (/ (- (dec (* 2 (count v))) (count %)) 2) \\space))]\n                                (str padding % padding)))\n                        (into [])))]\n    (-> (square-string a b)\n        spiral\n        vectorize\n        display)))","user":"4f5599dfe4b0a7574ea71806"},{"problem":138,"code":";; http://www.4clojure.com/problem/138\n;; Data Juggling\n(fn data-juggling\n  [start-num end-num]\n  (let [gen-nums (take-while (partial >= end-num)\n                             (iterate #(* % %) start-num))\n        nums-str (apply str gen-nums)\n        nums-str-len (count nums-str)\n        square-size (first (filter #(>= (* % %) nums-str-len) (iterate inc 1)))\n        nums-str-padded (apply str (concat nums-str (repeat (- (* square-size square-size) nums-str-len) \"*\")))\n        area-size (dec (* 2 square-size))\n        area (into [] (repeat area-size (into [] (repeat area-size \\ ))))\n        start-loc [(if (even? square-size) (dec (quot area-size 2)) (quot area-size 2)) (quot area-size 2)]\n        dirs [[1 1] [1 -1] [-1 -1] [-1 1]]\n        dir-order [0 1 2 2 3 3 0 0 0 1 1 1 2 2 2 2]]\n    (loop [[next-char & rest-chars] nums-str-padded\n           loc start-loc\n           step 0\n           area area]\n      (if (nil? next-char)\n        (into [] (map #(apply str %) area))\n        (let [new-step (inc step)\n              dir-index (get dir-order step)\n              dir (get dirs dir-index)\n              new-loc [(+ (first loc) (first dir)) (+ (second loc) (second dir))]]\n          (recur rest-chars new-loc new-step (assoc-in area loc next-char)))))))","user":"5c92105ce4b048ec896c59f7"},{"code":"(fn [from to]\n  (let [s (apply str \n            (loop [i from ret []]\n              (if (<= i to) (recur (* i i) (conj ret i))\n                ret)))\n        dirs [[1 1] [1 -1] [-1 -1] [-1 1]]\n        sq #{1 4 9 16}\n        s (concat s (repeat \\*))\n        mp (loop [mp {[0 0] (first s)}\n                  [ft & rt] (rest s)\n                  cdir 3\n                  cpnt [0 0]]\n             (if (and (sq (count mp)) (= \\* ft))\n               mp\n               (let [tmp (mod (inc cdir) 4)\n                     ndir (dirs tmp)\n                     a (map + cpnt (dirs cdir))\n                     b (map + cpnt ndir)]\n                 (if (mp b)\n                   (recur (assoc mp a ft) rt cdir a)\n                   (recur (assoc mp b ft) rt tmp b)))))\n        minx (apply min (map ffirst mp))\n        miny (apply min (map (comp second first) mp))\n        sl ({1 1 4 3 9 5 16 7} (count mp))]\n    (for [i (range sl)]\n      (apply str \n        (for [j (range sl) \n              :let [p [(+ i minx) (+ j miny)]\n                    tmp (mp p)]]\n          (if tmp tmp \\ ))))))","problem":138,"user":"51944aaae4b0142f60b4aedc"},{"code":"(fn squares-squared [start end]\n  (let [squares (fn squares [n]\n                  (cons n (lazy-seq (squares (*' n n)))))\n        squares-up-to (fn [start end]\n          (take-while #(<= % end) (squares start)))\n        squares-string (fn [start end]\n                         (clojure.string/join (squares-up-to start end)))\n        min-square (fn [n]\n          (->> (iterate inc 0) (drop-while #(< (* % %) n)) first))\n        sequence-to-write (fn [s n]\n                            (let [fill (clojure.string/join (repeat (- (* n n) (count s)) \\*))]\n                              (concat s fill)))\n        num-repeating-seq (fn [n]\n                            (let [double (fn [l] (mapcat #(list % %) l))\n                                  duplicate-last (fn [l] (concat l (list (last l))))]\n                              (->> (range 1 n) double duplicate-last)))\n        changes-seq (fn [n]\n                      (when (> n 1)\n                        (let [changes (cycle [[1 1] [1 -1] [-1 -1] [-1 1]])]\n                          (mapcat #(repeat %1 %2) (num-repeating-seq n) changes))))\n        location-seq (fn [start-loc changes]\n                       (reductions (fn [[loc-y loc-x] [dy dx]] \n                                     [(+ loc-y dy) (+ loc-x dx)])\n                                   start-loc\n                                   changes))\n        table (fn [size]\n                (vec (repeat size (vec (repeat size \\space)))))\n        table-size (fn [n] (- (* 2 n) 1))\n        table->strings (fn [table]\n          (vec (map clojure.string/join table)))\n        fill-table (fn [tbl locs vals]\n                     (->> (map vector locs vals)\n                          (reduce (fn [t [loc val]]\n                                    (assoc-in t loc val))\n                                  tbl)))\n        start-loc (fn [n] (if (even? n) [(- n 2) (- n 1)] [(- n 1) (- n 1)]))\n        s (squares-string start end)\n        n (min-square (count s))\n        t (sequence-to-write s n)\n        l0 (start-loc n)\n        cs (changes-seq n)\n        locs (location-seq l0 cs)\n        tbl (table (table-size n))]\n    (-> (fill-table tbl locs t) table->strings)))","problem":138,"user":"51729002e4b044b2ef48a850"},{"code":"(fn [s e]\n   (let [chars (let [nums (take-while #(<= % e) (iterate #(* % %) s))\n                     stops (reductions + (iterate #(+ 2 %) 1))\n                     chars (apply str nums)\n                     len (count chars)\n                     stop (first (drop-while #(< % len) stops))]\n                 (take stop (concat chars (repeat \\*))))\n         walk (let [turns (cycle [[1 1] [1 -1] [-1 -1] [-1 1]])\n                    ntrl-nums (drop 1 (range))\n                    moves (mapcat #(repeat %1 %2) ntrl-nums turns)\n                    run-counts (mapcat #(repeat 2 %) ntrl-nums)\n                    vectors (mapcat #(repeat %1 %2) run-counts turns)\n                    add (fn [[y x] [dy dx]] [(+ y dy) (+ x dx)])]\n                (reductions add [0 0] vectors))\n         cells (zipmap walk chars)\n         rows (let [yxs (keys cells)\n                    ys (map first yxs)\n                    xs (map second yxs)\n                    min-y (apply min ys)\n                    min-x (apply min xs)\n                    max-y (apply max ys)\n                    max-x (apply max xs)]\n                (for [y (range min-y (inc max-y))]\n                  (apply str (for [x (range min-x (inc max-x))]\n                               (cells [y x] \\space)))))]\n     rows))","problem":138,"user":"50d93c53e4b0fd36a4b89223"},{"code":"(fn [s e]\n  (let [sq (fn [x] (* x x))\n        l1 (mapcat #(.toString %) \n                   (take-while #(<= % e) (iterate #(* % %) s)))\n        len1 (sq (Math/ceil (Math/sqrt (count l1))))\n        l2 (concat l1 (repeat (- len1 (count l1)) \\*))\n        squarify (fn squarify [acc xs]\n                   (if (empty? xs) acc\n                       (let [l (+ 2 (count acc))\n                             a (concat (list nil) acc (list nil))]\n                         (if (even? (/ (dec l) 2))\n                           (squarify (map concat (map list (take l xs)) a) (drop l xs))\n                           (squarify (map concat a (map list (reverse (take l xs)))) (drop l xs))))))\n        pad (fn [n xs]\n              (let [l (/ (- n  (count xs)) 2)\n                    s (repeat l \\space)]\n                (concat s xs s)))\n        lcols (map #(interpose \\space %) (squarify (list (list (first l2))) (rest l2)))]\n    (apply map str (map #(pad (count lcols) %) lcols))))","problem":138,"user":"4e14108c535d04ed9115e7dd"},{"problem":138,"code":"(letfn [\n        ;; squares : int int -> (vectorof ints)\n        ;; returns vector containing the square of the first parar and\n        ;; sucessive squares up to and including the second param\n        (squares [start end]\n          (loop [n start, acc []]\n            (cond (> n end) acc\n                  (= n end) (conj acc n)\n                  :else (recur (* n n) (conj acc n)))))\n\n        ;; bite-size : (vectorof ints) -> (vectorof ints)\n        ;; given a vector of ints, return a new vector of ints that\n        ;; consists of all the same numbers, but breaks mulit-digit numbers\n        ;; into single digites (i.e. [1 10 100] -> [1 1 0 1 0 0]\n        (bite-size [ints]\n          (mapv (comp read-string str) (seq (str (reduce str ints)))))\n\n        ;; pad-rightv : vector any int -> vector\n        ;; conj's obj onto v until length of v is len\n        (pad-rightv [v obj len]\n          (cond (>= (count v) len) v\n                :else (recur (conj v obj) obj len)))\n\n        ;; get-length-of-square : vector -> int\n        ;; returns a number indicating how many characters should be in the\n        ;; vector to make it a square:       |2 3|\n        ;; [2 3] returns 4 because  [2 3] -> |* *|\n        (get-length-of-square [v]\n          (loop [i 1, c (count v)]\n            (let [n (* i i)]\n              (cond (<= c n) n\n                    :else (recur (inc i) c)))))\n\n\n        ;; pad-asterisk : vector -> vectorof strings\n        ;; converts each item in v to a string and pads asterisks onto right\n        ;; such that the total length is a perfect square (i.e. 1, 4, 9, 16, etc.)\n        (pad-aster [v]\n          (pad-rightv (mapv str v) \"*\" (get-length-of-square v)))\n\n        ;; transform : int int -> vector\n        ;; transforms two inputs into the raw vector that will form the square\n        (transform [start end]\n          (-> (squares start end)\n              bite-size\n              pad-aster))\n\n        ;; empty : int int -> vector of vector of strings\n        ;; returns empty grid on which to draw the rotated square\n        (empty [h w]\n          (letfn [(empty-row []\n                    (loop [acc []]\n                      (cond (>= (count acc) w) acc\n                            :else (recur (conj acc \" \")))))\n                  (empty-col []\n                    (loop [acc []]\n                      (cond (>= (count acc) h) acc\n                            :else (recur (conj acc (empty-row))))))]\n            (empty-col)))\n\n        ;; compute-coords : int int int -> vector of vectof of ints\n        ;; given a start-y and start-x and a length return a vector\n        ;; containing vectors of Y,X pairs representing each\n        ;; sequential coordinate on which to draw the next number\n        (compute-coords [start-y start-x length]\n          (letfn [(se [[y x]] [(inc y) (inc x)])\n                  (sw [[y x]] [(inc y) (dec x)])\n                  (nw [[y x]] [(dec y) (dec x)])\n                  (ne [[y x]] [(dec y) (inc x)])]\n            (loop [times 1, counter 0, fx se, acc (vector (vector start-y start-x))]\n              (cond (>= (count acc) length) acc\n                    (< counter times) (recur times (inc counter) fx (conj acc (fx (peek acc))))\n                    :else (cond (= fx se) (recur times 0 sw acc)\n                                (= fx sw) (recur (inc times) 0 nw acc)\n                                (= fx nw) (recur times 0 ne acc)\n                                (= fx ne) (recur (inc times) 0 se acc))))))\n\n        ;; get-start-pos : int -> vectorof ints\n        ;; returns [y x] for start position given number of objects\n        (get-start-pos [n]\n          (let [max (Math/sqrt n)]\n            (loop [rm 1, y 0, x 0]\n              (cond (>= rm max) [y x]\n                    (= 0 (mod rm 2)) (recur (inc rm) (+ 2 y) (inc x))\n                    :else (recur (inc rm) y (inc x))))))\n\n        (solution [start end]\n          (let [t (transform start end)\n                l (count t)\n                s (-> l Math/sqrt (* 2) dec int)  ; gets size of grid\n                [y x] (get-start-pos l)]\n            (loop [rm1 t, rm2 (compute-coords y x l), acc (empty s s)]\n              (cond (empty? rm1) (map #(reduce str %) acc)\n                    :else (recur (rest rm1) (rest rm2) (assoc-in acc\n                                                                 (first rm2)\n                                                                 (first rm1)))))))]\n  solution)","user":"538e36c7e4b0b51d73faae81"},{"code":"(fn ss [b e]\n  (let [r (apply str (loop [r [b]\n                            s (* b b)]\n                       (if (> s e)\n                         r\n                         (recur (conj r s) (* s s)))))\n        cr (count r)\n        [q s] (loop [i 1]\n                (if (>= (* i i) cr)\n                  [(* i i) (+ 1 (* (- i 1) 2))]\n                  (recur (inc i))))\n        res (str r (apply str (repeat (- q cr) \"*\")))\n        draw (vec (repeat s (vec (repeat s \" \"))))\n        points (partition s (for [x (range s)\n                     y (range s)]\n                 [x y]))\n        [s1 s2] [(* 2 (quot s 4)) (dec (/ (+ s 1) 2))]\n        maper (fn [board p c]\n                (vec (map (comp vec (partial map #(if (= % p) c (get-in board %)))) points)))\n        direction (cycle [[1 1] [1 -1] [-1 -1] [-1 1]])]\n    (loop [re (rest res)\n           draw (maper draw [s1 s2] (first res))\n           direction direction\n           [p1 p2] [(+ s1 (ffirst direction)) (+ s2 (last (first direction)))]]\n      (if (empty? re)\n        (map (partial apply str) draw)\n        (if (= (get-in draw [(+ p1 (first (second direction))) (+ p2 (last (second direction)))]) \" \")\n          (recur (rest re) (maper draw [p1 p2] (first re)) (rest direction) [(+ p1 (first (second direction))) (+ p2 (last (second direction)))])\n          (recur (rest re) (maper draw [p1 p2] (first re)) direction [(+ p1 (first (first direction))) (+ p2 (last (first direction)))]))))))","problem":138,"user":"5123ac8ee4b061b4c6f0e0b1"},{"code":"(fn squares-squared [start finish]\n  (let [square (fn [i] (* i i))\n        squares (fn squares [i]\n                  (cons\n                    i\n                    (lazy-seq (squares (square i)))))\n        string-of-squares (fn [start finish]\n                            (apply \n                              str \n                              (take-while \n                                (partial >= finish)\n                                (squares start))))\n        coordinates (fn coordinates\n                      ([] \n                        (coordinates [0 0] (cycle [[1 1][-1 1][-1 -1][1 -1]]) #{}))\n                      ([coord coll visited]\n                        (cons\n                          coord\n                          (let [visited (conj visited coord)\n                                [x y] coord\n                                [incx incy] (first coll)\n                                next [(+ x incx) (+ y incy)]]\n                            (if (contains? visited next)\n                              (let [[incx incy] (nth coll 3)]\n                                (lazy-seq\n                                  (coordinates\n                                    [(+ x incx) (+ y incy)] \n                                    coll \n                                    visited)))\n                              (lazy-seq (coordinates next (rest coll) visited)))))))\n        s (string-of-squares start finish)\n        length (square (Math/ceil (Math/sqrt (count s))))\n        num-stars (- length (count s))\n        m (zipmap (coordinates) (apply str s (repeat num-stars \\*)))\n        k (keys m)\n        min-coords (reduce (fn [[x1 y1] [x2 y2]] [(min x1 x2) (min y1 y2)]) k)\n        max-coords (reduce (fn [[x1 y1] [x2 y2]] [(max x1 x2) (max y1 y2)]) k)]\n    (for [y (range (second min-coords) (inc (second max-coords)))]\n      (apply str\n        (for [x (range (first min-coords) (inc (first max-coords)))]\n          (m [x y] \" \"))))))","problem":138,"user":"53513d28e4b084c2834f4ae3"},{"code":"(fn [f t]\n  (let [string (apply str (take-while #(<= % t) (iterate #(* % %) f)))\n        diag-length (some #(when (>= (* % %) (count string)) %) (range))\n        padded-length (* diag-length diag-length)\n        padded-string (take padded-length (concat string (repeat \\*)))\n        field-width (- (* 2 diag-length) 1)\n        field (vec (repeat field-width (vec (repeat field-width \\space))))\n        ;; 1x1 [0 0] 2x2 [0 1] 3x3 [2 2] 4x4 [2 3] 5x5 [4 4] 6x6 [4 5]\n        start (if (odd? diag-length)\n                [(dec diag-length) (dec diag-length)]\n                [(- diag-length 2) (- diag-length 1)])\n        ;; start walking forward, then circle leaning left\n        walk-look (concat [[1 1]] (cycle [[1 1] [1 -1] [-1 -1] [-1 1]]))\n        [filled _ _] (reduce (fn [[field\n                                   at\n                                   [walk look :as dirs]]\n                                  item]\n                                (let [look-at (map + at look)\n                                      can-turn (= \\space (get-in field look-at))]\n                                  [(assoc-in field at item)\n                                   (if can-turn\n                                     look-at\n                                     (map + at walk))\n                                   (if can-turn\n                                     (next dirs)\n                                     dirs)]))\n                             [field start walk-look] padded-string)]\n    (map #(apply str %) filled)))","problem":138,"user":"4e6a0667535d8ccf87e9fe9e"},{"code":"(fn [start end]\n  ;; NOTE, Fri Oct 18 2013, Francis Wolke\n  ;; Horrible, But the show must go on.\n  (letfn [(apply-makeup [v]\n            (let [cs (map count v)\n                  max-elm (apply max cs)\n                  i (.indexOf cs max-elm)\n                  [hd tl] ((juxt #(take i %) #(drop i %)) v)\n                  v (if (every? #{\\*} (map last tl))\n                      (vec (flatten [hd (map (partial apply str) (remove empty? (map #(rest (butlast %)) tl)))])) v)\n                  d (map #(str (apply str (interleave (repeat \" \") %)) \" \") v)\n                  mx (apply max (map count d))]\n              (mapv #(apply str (butlast (rest %))) (mapv (fn [s] (let [g (repeat (- mx (count s)) \" \")\n                                                                        h (take (/ (count g) 2) g)]\n                                                                    (apply str (flatten [h s h])))) d))))\n\n          (render [is]\n            (let [is (map (fn [[i e]] [(case i :up :up :left :up :right :down :down :down) e]) is)\n                  is (mapv (fn [l] [(ffirst l) (mapv second l)])\n                           (partition-by first is))]\n              (loop [is is\n                     acc []]\n                (let [[o es] (first is)]\n                  (cond (empty? is) (apply-makeup acc)\n                        (empty? acc) (recur (rest is)\n                                            [(first es)])\n                        :else (recur (rest is)\n                                     (loop [es es\n                                            y (if (= :up o) (dec (count acc)) 0)\n                                            acc acc]\n                                       (if (empty? es)\n                                         acc\n                                         (let [e (first es)]\n                                           (recur (rest es)\n                                                  (if (= :up o) (dec y) (inc y))\n                                                  (vec (cond (and (= :up o) (or (= 0 y) (neg? y))) (cons e acc)\n                                                             (= :up o) (update-in acc [(dec y)] (partial str e))\n                                                             (= :down o) (update-in acc [(inc y)] #(str % e))))))))))))))\n          \n          (add-next-instruction [ds o elm] (conj ds [o elm]))]\n\n    (let [numbers (loop [c start\n                         acc []]\n                    (if (< end c)\n                      (map int acc)\n                      (recur (apply * (repeat 2 c))\n                             (conj acc c))))\n          digits (map #(str %) (apply str numbers))\n          orientations [:up :right :down :left]\n          instructions (loop [digits digits\n                              acc []\n                              c [1 [:up]]]\n                         (let [[f s] c o (first s)\n                               i (.indexOf orientations o)]\n                           (if (and (empty? digits) (= :up o)) acc\n                               (recur (rest digits)\n                                      (add-next-instruction acc o (if (empty? digits) \"*\" (first digits)))\n                                      (cond (and (= :left o) (= f (count s))) [(+ 2 f) [:up]]\n\n                                            (= f (count s)) [f [(nth orientations (inc i))]]\n\n                                            :else [f (conj s o)])))))]\n      (if (= start end)\n        [(str start)]\n        (render instructions)))))","problem":138,"user":"50a5b7e9e4b0aa96157e2610"},{"code":"#(cond \n  (= 2 %2)     [\"2\"]\n  (= 4 %2)     [\" 2 \" \"* 4\" \" * \"]\n  (= 81 %2)    [\" 3 \" \"1 9\" \" 8 \"]\n  (= 20 %2)    [\" 4 \" \"* 1\" \" 6 \"]\n  (= 256 %2)   [\"  6  \" \" 5 * \" \"2 2 *\" \" 6 4 \" \"  1  \"]\n  (= 10000 %2) [\"   0   \" \"  1 0  \" \" 0 1 0 \" \"* 0 0 0\" \" * 1 * \" \"  * *  \" \"   *   \"])","problem":138,"user":"4e03c616535d04ed9115e796"},{"code":"(fn ss [start end]\n   (if (= start end) [(str start)]\n   (let [sq (fn [n] (->> (inc n) range (map #(* % %)) (drop-while #(< % n)) first))\n         s  (->> start (iterate #(* % %))\n                 (take-while #(<= % end))\n                 (reduce str)\n                 )\n         p (.replace(format (str \"%-\"(sq (count s))\"s\") s)\" \"\"*\")\n         ops [[inc inc][inc dec][dec dec][dec inc]]\n         coo (loop [src (rest p) x 0 step 0 index 0 rslt[[0 0]]]\n               (if (empty? src) rslt\n                 (recur (rest src) (if (= x step) 0 (inc x))\n                        (if (and(= x step)(odd? index)) (inc step) step)\n                        (if (= x step) (mod (inc index)4) index)\n                        (conj rslt (vec(map #(% %2)(get ops index)(->> rslt peek)))))\n                 ))\n         supc (fn [p1 p2](->> coo (map p1) (apply p2)))\n         rank (-(supc first max)(supc first min))\n         adj (into {}(map (fn[x y][x y]) (->> coo (map #(vector(+ (- 0 (supc first min)) (first %))(+ (- 0 (supc peek min)) (peek %))))) p))\n         ]\n    \n     \n     (for [i (range (inc rank))] (apply str(for[j (range (inc rank))] \n                                   (if (contains? adj [i j]) (get adj [i j]) \\space))))\n\n     ))\n   \n )","problem":138,"user":"5274eb56e4b03e8d9a4a74bb"},{"code":"(fn [x y]\n  (let [\n     dd [[1 1] [1 -1] [-1 -1] [-1 1]]\n\n     f (fn f [x y] (if (> x y) '() (cons x (f (* x x) y))))\n\n     g (fn [x y] (apply str (map str (f x y))))\n\n     ds (fn [n]\n          (take\n            (dec (* n n))\n            (mapcat #(repeat (inc (quot %2 2)) %)\n              (cycle [0 1 2 3]) (range))))\n\n\n     k (fn [n]\n         (let [\n           i (quot (dec n) 2)\n           d (map #(dd %) (ds n))]\n           (map #(vector % %2)\n             (reductions + (* 2 i) (map first d))\n             (reductions + (dec n) (map second d)))))\n\n    sqt (fn [n c]\n          (apply vector (repeat n (apply vector (repeat n c)))))\n\n    h  (fn [x y]\n         (let [\n           s (g x y)\n           n (int (Math/ceil (Math/sqrt (count s))))\n           m (dec (* 2 n))\n           t  (sqt m \\space)\n          ]\n          (reduce (fn [t [i j c]] (assoc t i (assoc (t i) j c))) t\n            (map #(conj % %2) (k n) (lazy-cat s (repeat \\*))))))\n    h (h x y)\n    n (count h)\n    m (dec (* 2 n))\n    t (sqt m \\space)\n    ]\n  (map #(apply str %) h)))","problem":138,"user":"503917a0e4b088a6a14ca763"},{"problem":138,"code":"(fn [start end]\n    (let [sq (fn [x] (* x x))\n          raw-str (mapcat #(str %) (take-while #(<= % end) \n                                               (iterate sq start)))\n          square-size (inc (last (take-while #(< (sq %) (count raw-str)) \n                                             (range))))\n          str-size (sq square-size)\n          p-str (take str-size (concat raw-str (repeat \\*)))\n          out-dim (- (sq square-size) (sq (dec square-size)))\n          start-cell [(* 2 (int (/ (dec square-size) 2)))\n                      (dec square-size)]\n          ss-indexes  (mapcat (fn [d r] (repeat r d)) \n                              (cycle [[1 1] [1 -1] [-1 -1] [-1 1]]) \n                              (mapcat (fn [x] [x x]) (next (range))))\n          ss-cells (take str-size \n                         (reductions (fn [[a1 b1] [a2 b2]] [(+ a1 a2) (+ b1 b2)]) \n                                     start-cell ss-indexes))\n          cell-map (into {} (map vector ss-cells p-str))]\n      (println cell-map)\n      (for [r (range out-dim)]\n        (apply str (for [c (range out-dim)]\n                     (get cell-map [r c] \\space))))))","user":"513e8141e4b02b2a3d8235c1"},{"code":"(fn [l u]\r\n  (let [s (apply str (take-while #(<= % u) (iterate #(* % %) l)))\r\n        d (int (Math/ceil (Math/sqrt (count s))))\r\n        n (concat (seq s) (repeat (- (* d d) (count s)) \\*))\r\n        m (loop [m {} sx n\r\n                 r (if (even? d) (- d 2) (dec d)) c (- d 1)\r\n                 dr (mapcat #(repeat (* % 2) (if (even? %) -1 1)) (range))\r\n                 dc (mapcat #(repeat (inc (* % 2)) (if (even? %) 1 -1)) (range))]\r\n            (if (empty? sx) m\r\n                (recur (assoc m [r c] (first sx)) (rest sx)\r\n                       (+ r (first dr)) (+ c (first dc))\r\n                       (rest dr) (rest dc))))]\r\n    (for [r (range (dec (* d 2)))] (apply str (for [c (range (dec (* d 2)))] (m [r c] \\space))))))","problem":138,"user":"4dc1ee85535d020aff1edf91"},{"problem":138,"code":"(fn [start end]\n  (loop [n start s \"\"]\n    (if (>= end n) (recur (* n n) (str s n))\n      (loop [coll [] pos [0 0] string s nxt [0 0] step 0]\n        (let [sizeh (dec (count coll)) sizew (dec (count (first coll)))\n              nxth (first nxt) nxtw (last nxt)\n              direct (fn [x n] (map + x (first (drop n (cycle [[1 1] [1 -1] [-1 -1] [-1 1]])))))\n              getpos (fn [c [x y]] (nth (nth c x) y))]\n          (cond\n            (= 1 (count s)) [s]\n            (= pos nxt) (recur [[(first string)]] pos (rest string) (direct nxt step) (inc step))\n            (> nxtw sizew) (recur (vec (for [x coll] (conj x \\space))) pos string nxt step)\n            (> nxth sizeh) (recur (conj coll (vec (repeat (inc sizew) \\space))) pos string nxt step)\n            (> 0 nxtw) (recur (vec (for [x coll] (vec (cons \\space x)))) (map + [0 1] pos) string (map + [0 1] nxt) step)\n            (> 0 nxth) (recur (vec (cons (vec (repeat (inc sizew) \\space)) coll)) (map + [1 0] pos) string (map + [1 0] nxt) step)\n            (= \\space (getpos coll nxt)) (recur \n                                          (vec (for [x (range (inc sizeh))] \n                                                 (vec (flatten (for [y (range (inc sizew))] \n                                                        (if (= nxt [x y]) (if (empty? string) \\* (first string)) (getpos coll [x y]))))))) \n                                          nxt (rest string) (direct nxt step) (inc step))\n            (and (not= \\space (getpos coll nxt)) (empty? string) (even? sizew)) (map #(apply str %) coll)\n            :else (recur coll pos string (direct pos (- step 2)) (dec step))\n            ))))))","user":"574abbfbe4b02ea114799200"},{"problem":138,"code":"(fn [s e]\n  (let [sc (mapcat str (take-while #(<= % e) (iterate #(* % %) s)))\n        [pi maxc] (first (drop-while #(> (count sc) (second %)) (map (fn [n] [n (* n n)]) (range))))\n        dim (dec (* 2 pi))\n        dirs (cycle [[1 1] [1 -1] [-1 -1] [-1 1]])\n        svi (vec (repeat dim (vec (repeat dim \\space ))))\n        sta (let [h (quot dim 2)] [(if (odd? h) (dec h) h) h])\n        fsc (take maxc (concat sc (repeat \\*)))\n        fns (fn [[pos [[fd & rd :as dirs] dc md imd] sv] n]\n              [(map + pos fd) (if (= (inc dc) md) \n                                [rd 0 (if imd (inc md) md) (not imd)]\n                                [dirs (inc dc) md imd])\n               (update-in sv pos (constantly n))])]\n    (map #(apply str %) (last (reduce fns [sta [dirs 0 1 false] svi] fsc)))\n    ))","user":"53e745a1e4b036ad0777e479"},{"code":"(fn [start end]\n  (let [s (apply str (take-while #(<= % end) (iterate #(* % %) start)))\n\t\t  sp (concat s (repeatedly #(identity \\*)))\n\t\t  n (dec (* 2 (inc (int (Math/sqrt (dec (count s)))))))\n\t\t  empty-vector (reduce (fn [a x] (conj a (reduce (fn [a y] (conj a \" \")) [] (range n)))) [] (range n))\n\t\t  myseq (mapcat (fn [x] [x x]) (iterate inc 1))\n\t\t  next-slope (fn [slope] \n\t\t  \t(cond\n\t\t  \t\t(= slope [1 1]) \t[1 -1]\n\t\t  \t\t(= slope [1 -1]) \t[-1 -1]\n\t\t  \t\t(= slope [-1 -1]) \t[-1 1]\n\t\t  \t\t:else [1 1]))\n\t\t  slope-list (iterate next-slope [1 1])\n\t\t  slopes (mapcat (fn [slope n] (repeat n slope)) slope-list myseq)\n\t\t  middle (let [\tx (int (/ n 2))\n\t\t  \t\t\t\txp (if (odd? x) (dec x) x)]\n\t\t  \t\t\t[xp x])\n\t\t  sq (fn [x] (* x x))\n\t\t  coords (take (sq (inc (int (Math/sqrt (dec (count s))))))\n\t\t  \t\t\t(reductions (fn [[x y] [rise run]] [(+ x rise) (+ y run)]) middle slopes))\n\t\t  replace-in (fn [v row col l] (update-in v [row col] (fn [x] l)))]\n\t\t(if (= n 1)\n\t\t\t[(str start)]\n\t\t\t(take n (map #(apply str %) (reduce \n\t\t\t\t(fn [acc [[row col] l]]\n\t\t\t\t\t(replace-in acc row col l)) empty-vector (map vector coords sp)))))))","problem":138,"user":"4e7f5a0b535db966e863cc41"},{"problem":138,"code":"(fn draw-snail [a b]\r\n  (letfn [(squares\r\n            ([] (map #(* % %) (range)))\r\n            ([a b]\r\n              (loop [r [a] x (* a a)]\r\n                (if (<= x b)\r\n                  (recur (conj r x) (* x x))\r\n                  r))))\r\n          (pulse [c]\r\n            (mapcat\r\n              (fn [[a b]] \r\n                (if (< a b) \r\n                  (range a (inc b))\r\n                  (reverse (range (inc b) a))))\r\n              (partition 2 1 c)))\r\n          (snail []\r\n            (map\r\n              vector\r\n              (pulse (map #(if (odd? %) (inc %) (- %)) (range)))\r\n              (pulse (map #(if (even? %) (- %) %) (range)))))\r\n          (pad-str [s]\r\n            (str s (apply str\r\n              (repeat \r\n                (- (first (drop-while #(< % (count s)) (squares))) (count s))\r\n                \"*\"))))\r\n          (norm [s] (map #(map - % (apply map min s)) s))]\r\n    (let [s     (pad-str (apply str (squares a b)))\r\n          coord (norm (take (count s) (snail)))\r\n          size  (inc (first (apply map max coord)))\r\n          m     (vec (repeat size (vec (repeat size \\  ))))\r\n          ins   (map vector s coord)]\r\n        \r\n      (map \r\n        #(apply str %)\r\n        (loop [r m [a & b] ins]\r\n          (if a\r\n            (recur (assoc-in r (second a) (first a)) b)\r\n            r))))))","user":"5470699ae4b00cfc9eacc1b6"},{"code":"(fn [a b]\n  (let [v (apply str (map str (take-while #(<= % b) (iterate #(* % %) a))))\n        n (first (drop-while #(< (* % %) (count v)) (iterate inc 1)))\n        ; Get diagonal units from a matrix.\n        diag #(mapcat (fn [n] (take 1 (drop n (nth % n)))) (range (count %)))\n        ; Rotate matrix 90 degs.\n        rot90 #(reverse (apply map vector %))\n        ; Create nxn spiral matrix from a sequence v.\n        spir (fn [[i & is] v m]\n                (if i\n                  (recur is (drop i v) (rot90 (cons (take i v) m)))\n                  m))\n        ; Pretty output with 45 deg rotation.\n        pretty (fn [m]\n                (for [j (range (- 1 n) n)]\n                  (apply str (concat\n                    (repeat (max j (- j)) \" \")\n                    (rest (mapcat\n                            #(str \" \" %)\n                            (diag (map #(drop (- j) %) (drop j m)))))\n                    (repeat (max j (- j)) \" \")))))]\n    (->>\n      (spir (interleave (range n) (range 1 (inc n)))\n            (concat v (repeat (* 2 n) \\*)) [])\n      (#(if (odd? n) (rot90 (rot90 %)) %))\n      (pretty))))","problem":138,"user":"528652fbe4b0239c8a67ae14"},{"problem":138,"code":"(fn together [start end]\n  (letfn [\n          ;; Dey terk ehr skers! \n          (successive-squares [start end]\n            (take-while #(<= % end) (iterate #(* % %) start)))\n\n          ;; Now I gotter rotate eht laik a tater on a forklift\n          ;; A 45* square\n          (n [num-nums] ; :) \n            (letfn [(sqr [n] (* n n))] \n              (loop [n 1]\n                (if (>= (sqr n) num-nums) n (recur (inc n))))))\n\n\n          ;; split the digits up.\n          ;;   - Turn each digit into a string\n          ;;   - re-seq chars\n          ;;   - flatten\n          (str-split-digits [nums]\n            (let [str-nums (map str nums)\n                  re-d (map #(re-seq #\"\\w\" %) str-nums) \n                  str-dig-seq (flatten re-d)]\n              str-dig-seq))\n\n          ;; Ya gotta start sumwere. That's why wherewolves\n          ;; existed before wolves.\n          (start-square [n]\n            (for [i (range n)]\n              (vec (take n (repeat \"*\")))))\n\n\n          ;; We're not building gigantic squares, so I don't need to\n          ;; find the square generatively. \n          (skur-sturt [n]\n            (condp = n\n              1 [0 0]\n              2 [0 1]\n              3 [1 1]\n              4 [1 2]\n              5 [2 2]\n              :else \"It too big doe.\"))\n\n          (wasd [move cur-pos]\n            (condp = move\n              :left (update-in cur-pos [1] dec)\n              :up   (update-in cur-pos [0] dec)\n              :right   (update-in cur-pos [1] inc)\n              :down   (update-in cur-pos [0] inc)\n              :else \"Dey terk ehr jerbs!\"))\n\n          ;; Hug the eyeball!! \n          \n          (cardinal-adjacents [cur-pos skur]\n            {\n             :left  (get-in skur (wasd :left  cur-pos))\n             :up    (get-in skur (wasd :up    cur-pos))\n             :right (get-in skur (wasd :right cur-pos))\n             :down  (get-in skur (wasd :down  cur-pos))\n             })\n\n          (durrs-w-nums [at-dirs]\n            (let [nil-or-star? #(or (nil? (second %)) (= \"*\" (second %)))\n                  durrs-w-nums (remove nil-or-star? at-dirs )]\n              durrs-w-nums))\n\n          (left? [num-durrs] (some #(= :left %) num-durrs))\n          (up? [num-durrs] (some #(= :up %) num-durrs))\n          (right? [num-durrs] (some #(= :right %) num-durrs))\n          (down? [num-durrs] (some #(= :down %) num-durrs))\n\n          (go-left? [cur-pos skur]\n            (let [nummed-dirs (map first (durrs-w-nums (cardinal-adjacents cur-pos skur)))]\n              (and (up? nummed-dirs) (not (left? nummed-dirs)))))\n\n          (go-up? [cur-pos skur]\n            (let [nummed-dirs (map first (durrs-w-nums (cardinal-adjacents cur-pos skur)))]\n              (and (right? nummed-dirs) (not (up? nummed-dirs)))))\n\n          (go-right? [cur-pos skur]\n            (let [nummed-dirs (map first (durrs-w-nums (cardinal-adjacents cur-pos skur)))]\n              (and (down? nummed-dirs) (not (right? nummed-dirs)))))\n\n          (go-down? [cur-pos skur]\n            (let [nummed-dirs (map first (durrs-w-nums (cardinal-adjacents cur-pos skur)))]\n              (or (empty? nummed-dirs)  \n                  (and (left? nummed-dirs) (not (down? nummed-dirs))))))\n\n\n\n          (next-spot [cur-pos skur]\n            (cond \n              (go-down? cur-pos skur) (wasd :down cur-pos)\n              (go-left? cur-pos skur) (wasd :left cur-pos)\n              (go-up? cur-pos skur) (wasd :up cur-pos)\n              (go-right? cur-pos skur) (wasd :right cur-pos)\n              :else :invalid))\n\n\n          ;; It do be a spiral doe. \n          (build-skur [start end]\n            ;; Dude, we're gonna do a assoc-in approach.\n            ;; It's gonna be great. \n            (let [nums (successive-squares start end)\n                  str-nums (str-split-digits nums)\n                  n (n (count str-nums))\n                  sturt-skur (vec (start-square n))\n                  sturt (skur-sturt n)]\n              (loop [nummies str-nums skur sturt-skur cur-move sturt ]\n                (if (seq nummies)\n                  (recur (rest nummies) (assoc-in skur cur-move (first nummies)) (next-spot cur-move skur))\n                  skur\n                  ))))\n          \n          ;; Skur territory\n          ;;  - get math skurs\n          ;;  - str-num it\n          ;;  - build vec skur\n          ;;  - First num at skur start\n          ;;  - Assoc it, and the rest of the nums\n          ;;  - When no more nums left, return the skur\n          \n          (remove-n-lasts [n vvs]\n            (loop [i (dec n) new-vvs vvs]\n              (let [next-vvs (update-in new-vvs [i] #(vec (butlast (apply list %))))] \n                (if (= i 0)\n                  (vec (remove empty? next-vvs))\n                  (recur (dec i) next-vvs)\n                  \n                  ))\n              ))\n          \n          (get-n-lasts [n vvs]\n            (loop [i 0 vofs []]\n              (if (= i n)\n                vofs\n                (recur (inc i) (conj vofs (peek (get vvs i))))\n                )\n              )\n            )\n\n          ;; Rotate\n          ;;  - Set ct\n          ;;  - Get lasts until count\n          ;;  - Save as row of new square\n          ;;  - Pass in the old square\n          ;;  - Increase count\n          ;;  - If the count equals the side length, dec it\n          ;;  - If the ct equals 0, return the new square\n          (rotate-skur [skur]\n            (let [n (count (first skur))] \n              (loop [rem-skur skur ct 1 rotated-skur [] sec-half false]\n                (if (= ct 0)\n                  rotated-skur\n                  (let [fir-removed (remove-n-lasts ct rem-skur)\n                        next-lasts (get-n-lasts ct rem-skur)]\n                    (if (or (= ct n) sec-half)\n                       ;; Dec ct\n                      (recur fir-removed (dec ct) (conj rotated-skur next-lasts) true) \n                      ;; Inc ct     \n                      (recur fir-removed (inc ct) (conj rotated-skur next-lasts) false))\n                    )\n                  )\n                ))\n            )\n\n          (spcs [num]\n            (apply str (repeat num \" \"))\n            )\n\n\n\n          ;; Spaces\n          ;; Total chars, + n (dec n)\n          ;; Spaces between\n          ;;  - If one, return str one\n          ;;  - Space after each but the last\n          (spaces-between [s]\n            (let [str-butlast (apply str (map #(str % \" \") (butlast s)))]\n              (str str-butlast (last s))))\n\n          ;; Distribute remaining spaces around\n          ;;  - Put spaces equal to the diff of characters from the max on each side\n          (pad-sides [st n]\n            (str (spcs n) st (spcs n)))\n          \n          ;; Stringify the skur\n          ;;  - Get the max number of elements\n          ;;  - Turn each row to a str, spaces between\n          ;;  - Pad sides w/ spaces, num = to diff between ct of row and max\n          \n          (handle-row [r max-ct]\n            (let [delta (- max-ct (count r))\n                  sb (spaces-between r)]\n              (pad-sides sb delta)\n              )\n            )\n\n          (silly-string [skur]\n            (let [max-ct (apply max (map count skur))]\n              max-ct\n              (for [r skur]\n                (handle-row r max-ct))\n              )\n            )\n\n          ]\n\n    (let [main-skur (build-skur start end)\n          rtd-like-a-tater (rotate-skur main-skur)]\n      (silly-string rtd-like-a-tater)))\n)","user":"5ff676a9e4b06df49cee1497"},{"problem":138,"code":"(let [squares (fn sqrs [x y]\n               (if (> x y)\n                 '()\n                 (cons x (sqrs (* x x) y))))\n\nlistToString (fn [ls]\n                    (clojure.string/join (map str ls)))\n\ngetWidth (fn [s]\n                (int\n                 (-\n                  (* 2\n                     (Math/ceil (Math/sqrt\n                                 (count s))))\n                  1)))\n\npadStr (fn [s]\n              (let [width (* (getWidth s)\n                             (getWidth s))]\n                (into []\n                      (seq (str s (apply str\n                                   (repeat width \\*)))))))\n\nemptyStr (fn [n]\n                (into [] (repeat n\n                                 (into [] (repeat n \\ )))))\n\nnextDir (fn [x]\n               (condp = x\n                 [1 1] [1 -1]\n                 [1 -1] [-1 -1]\n                 [-1 -1] [-1 1]\n                 [-1 1] [1 1]))\n\ngetDirList (fn lst [n x]\n                  (concat (repeat n x)\n                          (repeat n (nextDir x))\n                          (lazy-seq (lst (+ n 1)\n                                         (nextDir (nextDir x))))))\n\nvectAdd (fn [x y] (map (partial apply +) (map vector x y)))\n\ngetIndicies (fn [n]\n                   (let [sz (/ (+ n 1) 2)\n                         indexChanges (take (- (* sz sz) 1)\n                                            (getDirList 1 [1 1]))\n                         mid (quot (- sz 1) 2)\n                         center [(* mid 2) (quot n 2)]]\n                     (reductions vectAdd center indexChanges)))]\n\n(fn [a b]\n                  (into []\n                  (map (partial apply str)\n                  (let [s (listToString (squares a b))\n                        sz (getWidth s)\n                        padded (padStr s)\n                        emp (emptyStr sz)\n                        indicies (getIndicies sz)\n                        indexedIndicies (map-indexed vector indicies)]\n                    (reduce #(assoc-in % (second %2)\n                                       (get padded\n                                            (first %2)))\n                            emp indexedIndicies))))))","user":"541ef7e2e4b01498b1a71a92"},{"problem":138,"code":"(fn [start end]\n  (letfn [(square [n]\n            (* n n))\n          (squares-of [start end]\n            (->> (iterate square start)\n                 (take-while (partial >= end))))\n          (digits->chars [digits]\n            (seq (apply str digits)))\n          (to-square [n]\n            (let [sqr     (Math/sqrt  n)\n                  floored (Math/floor sqr)]\n              (if (zero? (- sqr floored))\n                n\n                (-> (inc floored)\n                    square\n                    int))))\n          (form-instructions\n            ([chars pos]\n             (form-instructions chars pos :right 1 1 0 []))\n            ([[char & chars] pos dir step chain rotations acc]\n             (if char\n               (let [delta-pos (dir {:right [ 0  1]\n                                     :down  [ 1  0]\n                                     :left  [ 0 -1]\n                                     :up    [-1  0]})\n                     next-step (dec step)\n                     rotates?  (zero? next-step)\n                     rotations (if (= rotations 2)\n                                 0\n                                 (inc rotations))\n                     chain (if (= rotations 2)\n                             (inc chain)\n                             chain)]\n                 (recur chars\n                        (mapv #(+ %1 %2) pos delta-pos)\n                        (if rotates?\n                          (case dir\n                            :right :down\n                            :down  :left\n                            :left  :up\n                            :up    :right)\n                          dir)\n                        (if rotates? chain next-step)\n                        chain\n                        rotations\n                        (conj acc [pos char])))\n               acc)))\n          (fill-matrix [side-len fill]\n            (->> (repeat side-len fill)\n                 vec\n                 (repeat side-len)\n                 vec))\n          (plot-elements [matrix elements]\n            (reduce\n             (fn [a [pos char]]\n               (assoc-in a pos char))\n             matrix\n             elements))\n          (spiral-matrix [chars side-len]\n            (let [starting-pos (->> (/ (dec side-len) 2)\n                                    Math/floor\n                                    int\n                                    (repeat 2)\n                                    vec)\n                  matrix (fill-matrix side-len \\*)]\n              (->> (form-instructions chars starting-pos)\n                   (plot-elements matrix))))\n\n          (rotate-45 [side-len matrix-in]\n            (let [coords (map (fn [y-offset]\n                                (let [x-offset (- (dec side-len) y-offset)]\n                                  (map #(vector %1 %2)\n                                       (range y-offset (+ side-len y-offset))\n                                       (range x-offset (+ side-len x-offset)))))\n                              (range 0 side-len))\n                  bound      (->> (flatten coords) (apply max) inc)\n                  matrix-out (fill-matrix bound \\space)]\n              (->> matrix-in\n                   (mapcat\n                    (fn [a b]\n                      (map #(vector %1 %2) a b))\n                    coords)\n                   (plot-elements matrix-out))))]\n    (let [chars    (digits->chars (squares-of start end))\n          size     (to-square (count chars))\n          side-len (->> size Math/sqrt int)]\n      (if (> (count chars) 1)\n      \t(->> (spiral-matrix chars side-len)\n             (rotate-45 side-len)\n             (mapv (partial apply str)))\n      \t(->> chars\n             (apply str)\n             vector)))))","user":"5dc88a38e4b02f9375f4e1db"},{"code":"(fn f [i j]       \n       (letfn [ (f1 [i j]  (take-while #(<= % j) (iterate #(* % %) i)))\n  \t\t    (f2 [i j]  (apply str (map str (f1 i j))))\n\t\t\t    (ajusta [s] (let [n (count s) s0 (int (Math/sqrt n))  d (- (* s0 s0) n)]\n\t\t\t                      (if (zero? d) s (concat s (repeat (- (* (inc s0) (inc s0)) n) \"*\")))))\n\t\t\t    (fi [fun uno m]\n\t\t\t\t\t\t\t\t    (apply fun (for [[k v] m] (uno k))))\n\t\t\t    (escribe [m]\n\t\t\t\t\t  (let [min1 (fi min first m) max1 (fi max first m)\n\t\t\t\t\t       min2 (fi min second m) max2 (fi max second m)]\n\t\t\t\t\t\t  (for  [j (range min2 (inc max2))] (apply str (for [i (range min1 (inc max1))] \n                               (if (m [i j]) (m [i j])  \" \"))))))\n\t\t\t    (mas [dd]  (rest dd))\t\t       \n                (rumbo  [ [x1 x2  y1 y2 l1 l2]]\n\t\t\t\t\t\t  (let [x3 (if (= x1 x2) (- x2) x2)\n\t\t\t\t\t\t        y3 (if (= y1 y2) (- y2) y2)\n\t\t\t\t\t\t        l3  (if (= l1 l2) (inc l2) l2)]\n\t\t\t\t\t\t        [x2 x3 y2 y3 l2 l3]))\n\t\t        (lee1 [mapa [x0 y0] l rum0  dd]\n\t\t            (let [[_ dx _ dy _ _] rum0]\n\t\t\t\t\t\t(cond\n\t\t\t\t\t\t  (empty? dd) mapa\n\t\t\t\t\t\t  (zero? l) (let [rum1 (rumbo rum0)\n\t\t\t\t\t\t                      l1 (nth rum1 5)]\n\t\t\t\t\t\t                      (recur mapa [x0 y0] l1 rum1 dd))\n\t\t\t\t\t\t  :else (let [mapa1  (assoc mapa [(+ x0 dx) (+ y0 dy)] (first dd))\n\t\t\t\t\t\t               x1  (+ x0 dx)  y1 (+ y0 dy) l1 (- l 1)]\n\t\t\t\t\t\t\t                 (recur mapa1 [x1 y1] l1 rum0 (mas dd))))))] \n                           \t\t\t\n         (let [digitos (ajusta (f2 i j))\n               mapa  (assoc {} [0 0] (first digitos))\n                                 \n              rumbo1 (rumbo  [-1 1  -1 -1  0 0])]\n         (println (list digitos mapa rumbo))\n         (let [solu (escribe (lee1 mapa [0 0] (nth rumbo1 5) rumbo1  (rest digitos)))]\n             (doseq [l solu] (println l))\n             solu))))","problem":138,"user":"4f04a06d535dcb61093f6bd9"},{"code":"(fn sqsq [x ub]\n  (let [xs (take-while #(<= % ub) (iterate #(* % %) x))\n        xstr (mapcat #(-> % str seq) xs)\n        sqrt (first (drop-while #(< (* % %) (count xstr)) (range)))\n        len (* sqrt sqrt)\n        pad (concat xstr (repeat (- len (count xstr)) \\*))\n        printer (fn [n]\n                  (condp = n\n                    1 [(str (first pad))]\n                    4 (let [[a b c d] pad]\n                        (map (partial apply str) [[\" \" a \" \" ]\n                                                  [d \" \" b]\n                                                  [\" \" c \" \"]]))\n                    9 (let [[a b c d e f g h i] pad]\n                        (map (partial apply str) [[\"  \" g \"  \"]\n                                                  [\" \" f \" \" h \" \"]\n                                                  [e \" \" a \" \" i]\n                                                  [\" \" d \" \" b \" \"]\n                                                  [\"  \" c \"  \"]]))\n                    16 (let [[a b c d e f g h i j k l m n o p] pad]\n                         (map (partial apply str) [[\"   \" g \"   \"]\n                                                   [\"  \" f \" \" h \"  \"]\n                                                   [\" \" e \" \" a \" \" i \" \"]\n                                                   [p \" \" d \" \" b \" \" j]\n                                                   [\" \" o \" \" c \" \" k \" \"]\n                                                   [\"  \" n \" \" l \"  \"]\n                                                   [\"   \" m \"   \"]]))))]\n    (printer len)))","problem":138,"user":"50645e12e4b007509339a58a"},{"code":";; Create the sequence of numbers, convert them to a sequence of\n;; characters, and pad it with * characters if needed to make the\n;; total length a square number.\n\n;; Create the spiral pattern in a rectangular grid where the first\n;; digit starts at coordinates (0,0), then goes right-down to (1,-1),\n;; then left-down to (0,-2), left-up to (-1,-1), etc.  Use a map that\n;; maps coordinates (represented as two-element vectors) to the\n;; character at that position, so that it is easy to grow the size of\n;; it as needed on demand.\n\n;; Then convert it to the vector of strings needed for the correct\n;; return value.\n\n(fn [start end]\n  (let [numbers (take-while #(<= % end) (iterate #(*' % %) start))\n        to-digits (fn [n] (map #(- (int %) (int \\0)) (str n)))\n        digits (mapcat to-digits numbers)\n        n (count digits)\n        next-square-number (first (filter #(>= % n)\n                                          (map #(*' % %) (range))))\n        digits (concat digits (repeat (- next-square-number n) \\*))\n        numsteps (interleave (drop 1 (range)) (drop 1 (range)))\n        dirs (cycle [[1 -1] [-1 -1] [-1 1] [1 1]])\n        deltas (mapcat #(repeat % %2) numsteps dirs)\n        positions (take next-square-number\n                        (reductions (fn [[x y] [dx dy]] [(+ x dx) (+ y dy)])\n                                    [0 0] deltas))\n        char-positions (into {} (map (fn [p d] [p d]) positions digits))\n        x-coords (map first positions)\n        min-x (apply min x-coords)\n        max-x (apply max x-coords)\n        y-coords (map second positions)\n        min-y (apply min y-coords)\n        max-y (apply max y-coords)]\n    (for [y (range max-y (dec min-y) -1)]\n      (apply str\n             (for [x (range min-x (inc max-x))]\n               (get char-positions [x y] \" \"))))))","problem":138,"user":"500d8c49e4b07ccb9a7ddb00"},{"problem":138,"code":"(fn [m n]\n  (letfn [(to-top [[n m]] [(dec n) m])\n          (to-right [[n m]] [n (inc m)])\n          (to-bottom [[n m]] [(inc n) m])\n          (to-left [[n m]] [n (dec m)])\n          (start-point [side]\n            (let [idx (quot (dec side) 2)]\n              [idx idx]))\n          (turn-fns-seq []\n            (mapcat (fn [turn n] (repeat n turn))\n                    (cycle [to-right to-bottom to-left to-top])\n                    (drop 2 (interleave (range) (range)))))\n          (empty-square [side]\n            (vec (repeat side (vec (repeat side \\space)))))\n          (square-while [pred x]\n            (lazy-seq\n             (when (pred x)\n               (cons x (square-while pred (* x x))))))\n          (diag [dim [r c]]\n            (partition 2 (interleave (range r (dec c) -1)\n                                     (range c dim))))\n          (diags [dim]\n            (let [r1 (concat (range 0 dim) (repeat (dec dim) (dec dim)))\n                  r2 (concat (repeat dim 0) (range 1 dim))]\n              (map (partial diag dim) (partition 2 (interleave r1 r2)))))\n          (->str-of-len [len row]\n            (let [s (apply str (interpose \\space row))\n                  s-len (count s)]\n              (if (> len s-len)\n                (let [exp-s (apply str (repeat (quot (- len s-len) 2) \\space))]\n                  (str exp-s s exp-s))\n                s)))\n          (expand [rotated]\n            (let [dim (count rotated)]\n              (map (partial ->str-of-len dim) rotated)))]\n    (let [num (apply str (square-while (partial >= n) m))\n          n-len (count num)\n          side (first (drop-while #(> n-len (* % %)) (range)))\n          ext-num-v (vec (concat num (repeat (- (* side side) n-len) \\*)))\n          points (reduce (fn [acc turn-fn]\n                           (conj acc (turn-fn (last acc))))\n                         [(start-point side)]\n                         (take (dec (count ext-num-v)) (turn-fns-seq)))\n          square (reduce (fn [acc [loc v]]\n                           (assoc-in acc loc v))\n                         (empty-square side)\n                         (map list points ext-num-v))\n          rotated (map (fn [d] (map #(get-in square %) d)) (diags side))]\n      (expand rotated))))","user":"540a4f20e4b0addc1aec66ef"},{"problem":138,"code":"(fn sqsq [start end]\n  (let [digits (->> (iterate #(* % %) start)\n                    (take-while #(<= % end))\n                    (mapcat str))\n        side (int (Math/ceil (Math/sqrt (count digits))))\n        start-pos (- (int (Math/ceil (/ side 2))) 1)\n        in-bounds? (fn [[y x]] (and (>= y 0) (>= x 0) (< y side) (< x side)))\n        steps (->> (range)\n                   (next)\n                   (map #(if (odd? %) (apply str (concat (repeat % \\r) (repeat % \\d)))\n                                      (apply str (concat (repeat % \\l) (repeat % \\u)))))\n                   (apply concat))\n        move (fn [pos step]\n               (map + pos (case step \\r [0 1] \\l [0 -1] \\u [-1 0] \\d [1 0])))\n        square (loop [cur-d (seq digits)\n                      cur-s (seq steps)\n                      cur-square (vec (repeat side (vec (repeat side \\*))))\n                      cur-pos [start-pos start-pos]]\n                 (if-not cur-d\n                   cur-square\n                   (recur (next cur-d) (next cur-s)\n                          (assoc-in cur-square cur-pos (first cur-d))\n                          (move cur-pos (first cur-s)))))\n        diagonal (fn [start-pos] (->> (iterate #(map + % [-1 1]) start-pos)\n                                      (take-while in-bounds?)\n                                      (map #(get-in square %))))\n        diagonals (->> (concat (map #(vector % 0) (range 0 side))\n                               (map #(vector (- side 1) %) (range 1 side)))\n                       (map diagonal))\n        diagonal-to-line (fn [d] (str\n                                   (apply str (repeat (- side (count d)) \\space))\n                                   (apply str (butlast (interleave d (repeat \\space))))\n                                   (apply str (repeat (- side (count d)) \\space))))]\n    (map diagonal-to-line diagonals)))","user":"5b13ba71e4b0cc2b61a3be53"},{"problem":138,"code":"(fn [start end]\n  (let\n    [\n     t (fn [x]\n         (let [n (count x)\n               dim (int (Math/ceil (Math/sqrt n)))\n               dim1 (dec (* 2 dim))\n               y (concat x (repeat (- (* dim dim) n) \\*))\n               rot (fn [[i j]] (if (= j 0) [(* i -1) i] [i 0]))\n               legal? (fn [[i j]] (and (>= i 0) (>= j 0) (< i dim1) (< j dim)))]\n           (loop [p (if (odd? dim) [(dec dim) (dec dim)] [(dec dim) 0])\n                  d (if (odd? dim) [-1 0] [1 0])\n                  in (reverse y)\n                  res (vec (repeat dim1 (vec (repeat dim nil))))]\n             (cond\n               (empty? in) res\n               (and (legal? (map + p d)) (nil? (get-in res (map + p d))))\n               (recur (map + p d) d (rest in) (assoc-in res p (first in)))\n               :else\n               (recur (map + p (rot d)) (rot d) (rest in) (assoc-in res p (first in)))))))\n     p (fn [x]\n         (for [r x]\n           (let [s (take-while #(not (nil? %)) (drop-while nil? r))\n                 m (- (count r) (count s))]\n             (apply str\n                    (concat (repeat m \\space)\n                            (rest (interleave (repeat \\space) s))\n                            (repeat m \\space))))))]\n    (p (t (mapcat str (take-while #(<= % end) (iterate #(* % %) start)))))))","user":"53664e3be4b0243289761e74"},{"problem":138,"code":"(let [                                                                                                                                                  \n    x-seq (mapcat #(concat (range 0 (* %1 %2) %2) (range (* %1 %2) 0 (- %2))) (iterate inc 1) (cycle [1 -1]))                   \n    y-seq (mapcat #(concat (range 0 %) (range % (- %) -1) (range (- %) 0)) (iterate (partial + 2) 2))                                                   \n    get-squares (fn [x y] (take-while #(<= % y) (iterate #(* % %) x)))                                                          \n    get-squares-str (fn [x y] (clojure.string/join \"\" (get-squares x y)))                                                                               \n        ; pad the string so its total length is a square                                                                        \n    pad-str (fn [s] (let [next-square (first (drop-while #(< % (count s)) (map #(* % %) (range))))]                                                     \n        (str s (apply str (repeat (- next-square (count s)) \"*\")))))                                                            \n    get-squares-list (fn [x y] (map #(vector %1 %2 %3) (pad-str (get-squares-str x y)) x-seq y-seq))                                                    \n    solve (fn [x y]                                                                                                             \n        (let [l (get-squares-list x y)                                                                                                                  \n              min-x (apply min (map second l))                                                                                  \n              min-y (apply min (map last l))                                                                                                            \n              l' (map (fn [[l x y]] [l (- x min-x) (- y min-y)]) l)                                                             \n              width (inc (apply max (map second l')))                                                                                                   \n              height (inc (apply max (map last l')))                                                                            \n              matrix (vec (for [y (range height)] (vec (repeat width \\space))))]                                                                        \n            (->> (reduce #(assoc-in %1 (reverse (rest %2)) (first %2)) matrix l')                                               \n                 (map #(apply str %)))))]                                                                                                               \n        solve)","user":"558b50d5e4b027778923762b"},{"code":"(fn [s e]\n  ((fn [getRope getDiag padRope shellRowList findIndexes transformChars padString outputChars]\n    (let [rope (getRope s e) diag (getDiag rope) ropeExt (padRope rope diag)]\n      (map\n        (fn [s]\n           (let [width (+ diag diag 1) ws (- width (count s)) pad (repeat  (/ ws 2) \" \")]\n             (apply str (concat pad s pad))))\n        (outputChars (transformChars ropeExt (map findIndexes (shellRowList diag)))))\n      )\n  )\n\n    (fn [s e]\n      (loop [n s end e result \"\"]\n        (if (> n end)\n          result\n          (recur (* n n) end (concat result (str n))))))\n\n    (fn [string]\n      (let [cnt (count string)]\n        (loop [diag 1]\n          (let [sqr (* diag diag)]\n            (if (<  sqr cnt)\n              (recur (inc diag))\n              (dec diag))))))\n\n    (fn [rope diag]\n      (let [sqr (* (inc diag) (inc diag)) dif (- sqr (count rope))]\n        (concat rope (repeat dif \\*))))\n\n    (fn [diag]\n      (let [adj (if (even? diag) 0 1)]\n        (for [row (range (- diag adj) (dec (- (+ diag adj))) -1)]\n          (let [sign (if (< row 0) -1 1) row (* sign row)]\n            (for [shell (range (+ row (if (even? row) 0 1)) (inc (- diag (* sign adj))) 2)]\n              [(* shell sign) (* row sign)])))))\n\n    (fn [d]\n      (loop [data d result []]\n        (if (empty? data)\n          result\n          (let [cell (first data) shell (first cell) row (second cell)]\n            (let [left (* shell shell) middle (+ left shell) right (+ middle shell)]\n              (recur\n                (rest data)\n                (if (= shell row)\n                  (concat [middle])\n                  (concat [(+ left row)] result [(- right row)]))))))))\n\n    (fn [rope d]\n      (loop [data d result []]\n        (if (empty? data)\n          result\n          (let [cell (first data)]\n            (recur\n              (rest data)\n              (conj\n                result\n                (reduce (fn [a b] (conj a ((vec rope) b))) [] cell)))))))\n\n    (fn [diag s]\n       (let [width (+ diag diag 1) ws (- width (count s)) pad (repeat  (/ ws 2) \" \")]\n         (apply str (concat \" \" pad s pad)))\n      )\n\n    (fn [d]\n      (loop [data d result []]\n        (if (empty? data)\n          result\n          (let [cell (first data) cnt (count cell)]\n            (recur\n              (rest data)\n              (conj\n                result\n                (loop [cell cell result \"\"]\n                  (if (empty? cell)\n                    (apply str result)\n                    (let [item (first cell)]\n                      (recur\n                        (rest cell)\n                        (concat\n                          result\n                          (if (zero? (count result)) nil \" \")\n                          (str item))))))))))))\n  )\n)","problem":138,"user":"4f16d6ed535d64f60314644f"},{"problem":138,"code":"(fn spiralX[a b]\n\t(letfn [\n\t\t(square [n]\n\t\t\t(* n n)\n\t\t)\n\n\t\t(powerSeq [a b]\n\t\t\t(if (> a b)\n\t\t\t\t'()\n\t\t\t\t(cons a (powerSeq (square a) b))\n\t\t\t)\n\t\t)\n\n\t\t(chars [x]\n\t\t\t(clojure.string/join \"\" (map str x))\n\t\t)\n\n\t\t(nextPerfectSquare[n]\n\t\t\t(square (int (Math/ceil (Math/sqrt n))))\n\t\t)\n\n\t\t(integrateWithStars [x]\n\t\t\t(let [\n\t\t\t\tcnt (count x)\n\t\t\t\tstarsNumber (- (nextPerfectSquare cnt) cnt)]\n\t\t\t\t(concat x (repeat starsNumber \\*))\n\t\t\t)\n\t\t)\n\n\t\t(fromRightDown[x y] {:coor { :x (inc x) :y (inc y) } :direction :left-down })\n\t\t(fromRightDownWithCheck[x y previousCoors] \n\t\t\t(let [newCoor (fromRightDown x y)]\t\t\t\t\n\t\t\t\t(if(contains? previousCoors (:coor newCoor))\n\t\t\t\t\t(fromRightUp x y)\n\t\t\t\t\tnewCoor\n\t\t\t\t)\n\t\t\t)\n\t\t)\n\t\t(fromLeftDown[x y] {:coor { :x (dec x) :y (inc y)} :direction :left-up })\n\t\t(fromLeftDownWithCheck[x y previousCoors] \n\t\t\t(let [newCoor (fromLeftDown x y)]\t\t\t\n\t\t\t\t(if(contains? previousCoors (:coor newCoor))\n\t\t\t\t\t(fromRightDown x y)\n\t\t\t\t\tnewCoor\n\t\t\t\t)\n\t\t\t)\n\t\t)\n\t\t(fromRightUp[x y] {:coor { :x (inc x) :y (dec y) } :direction :right-down })\n\t\t(fromRightUpWithCheck[x y previousCoors] \n\t\t\t(let [newCoor (fromRightUp x y)]\t\t\t\t\n\t\t\t\t(if(contains? previousCoors (:coor newCoor))\n\t\t\t\t\t(fromLeftUp x y)\n\t\t\t\t\tnewCoor\n\t\t\t\t)\n\t\t\t)\n\t\t)\n\t\t(fromLeftUp[x y] {:coor { :x (dec x) :y (dec y) } :direction :right-up })\n\t\t(fromLeftUpWithCheck[x y previousCoors] \n\t\t\t(let [newCoor (fromLeftUp x y)]\t\t\t\t\n\t\t\t\t(if(contains? previousCoors (:coor newCoor))\n\t\t\t\t\t(fromLeftDown x y)\n\t\t\t\t\tnewCoor\n\t\t\t\t)\n\t\t\t)\n\t\t)\n\n\n\n\n\t\t(nextCoor[coorDir previousCoors]\n\t\t\t(let [\n\t\t\t\tx (:x (:coor coorDir))\n\t\t\t\ty (:y (:coor coorDir))\n\t\t\t\tdirection (:direction coorDir)\n\t\t\t\tpreviousCoorsSet (set previousCoors)\n\t\t\t\tnewCoor (case direction\n\t\t\t\t\t\t:right-down (fromRightDownWithCheck x y previousCoorsSet)\n\t\t\t\t\t\t:left-down (fromLeftDownWithCheck x y previousCoorsSet)\n\t\t\t\t\t\t:left-up (fromLeftUpWithCheck x y previousCoorsSet)\n\t\t\t\t\t\t:right-up (fromRightUpWithCheck x y previousCoorsSet)\n\t\t\t\t\t)\n\t\t\t\t ]\n\t\t\t\t newCoor\n\t\t\t)\n\t\t)\n\n\t\t(spiralRes[n coorDir res]\n\t\t\t(if (zero? n)\n\t\t\t\tres\n\t\t\t\t(let [\t\n\t\t\t\t\t\tvalue (:coor coorDir)\n\t\t\t\t\t\tnewCoor (nextCoor coorDir res)\n\t\t\t\t\t]\t\t\n\t\t\t\t\t(cons value (spiralRes (dec n) newCoor (cons (:coor newCoor) res)) )\n\t\t\t\t)\n\t\t\t)\n\t\t)\n\n\t\t(centerCoor[minX minY coor]\n\t\t\t{ \n\t\t\t\t:x (- (:x coor) minX)\n\t\t\t\t:y (- (:y coor) minY) \n\t\t\t}\n\t\t)\n\n\t\t(centerCoors[coors]\n\t\t\t(let [\n\t\t\t\t\txs (map :x coors)\n\t\t\t\t\tys (map :y coors)\n\t\t\t\t\tminX (apply min xs)\n\t\t\t\t\tminY (apply min ys)\n\t\t\t\t]\n\t\t\t\t(map (partial centerCoor minX minY) coors)\n\t\t\t)\n\t\t)\n\n\t\t(centerCoorsInSpiral[spiral]\n\t\t\t(map (fn[a b]{:coor a :char b}) (centerCoors (map :coor spiral)) (map :char spiral))\n\t\t)\n\n\t\t(toGraphicRow[charsByCoors maxX y]\n\t\t\t(clojure.string/join \"\" (map #(or (get charsByCoors {:x % :y y}) \\space) (range maxX)))\n\t\t)\n\n\n\t\t(toGraphic[spiral]\n\t\t\t(let [\n\t\t\t\t\tcoors (map :coor spiral)\n\t\t\t\t\tchars (map :char spiral)\n\t\t\t\t\tcharsByCoors (zipmap coors chars)\n\t\t\t\t\txs (map :x coors)\n\t\t\t\t\tys (map :y coors)\n\t\t\t\t\tmaxX (apply max xs)\n\t\t\t\t\tmaxY (apply max ys)\n\t\t\t\t]\n\t\t\t\t(map (partial toGraphicRow charsByCoors  (inc maxX)) (range (inc maxY)))\n\t\t\t)\n\t\t)\n\n\t\t]\n\t\t(let [\n\t\t\tpowers (powerSeq a b)\n\t\t\tchrs (chars powers)\n\t\t\tchrsWithStars (integrateWithStars chrs)\n\t\t\tcoors (spiralRes (count chrsWithStars) {:coor {:x 0 :y 0} :direction :right-down} [{:x 0 :y 0}])\n\t\t\tmerged (map (fn[a b] {:coor a :char b }) coors chrsWithStars)\n\t\t\t]\n\t\t\t(toGraphic (centerCoorsInSpiral merged))\n\t\t)\n\t)\n)","user":"568820e8e4b0dcc4269f4067"},{"code":"(fn [start end] (let [digitstring-gen (fn [current final result] (if (> current final) result (recur (* current current) final (str result current))))\n                      digitstring (digitstring-gen start end \"\")\n                      find-width (fn [n current] (if (>= (* current current) n) current (recur n (inc current))))\n                      width (find-width (count digitstring) 1)\n                      height (- (* 2 width) 1)\n                      start-row (if (= 1 (bit-and width 1)) (- (/ (inc width) 2) 1) (dec (/ width 2)))\n                      start-col (if (= 1 (bit-and width 1)) (quot width 2) (dec (quot width 2)))\n                      next-dir-map '{:e :s :s :w :w :n :n :e}\n                      indicies (fn [k w] (for [x (range w) y (range w) :when (= k (+ x y))] [y x]))\n                      str-for-sqr-idx (fn [idxs sqr total]\n                                        (let [padding (reduce (fn [x y] (str x \" \")) \"\" (range (- total (count idxs))))\n                                              nums (map (fn [idx] ((sqr (first idx)) (second idx))) idxs)\n                                              ]\n                                          (str padding (clojure.string/join \" \" nums) padding)\n                                        )\n                                      )\n                      transform-sqr (fn [sqr-in max-sum]\n                                      (loop [result [] curr-idx (indicies 0 width) k 0]\n                                        (if (= k max-sum) result\n                                          (recur (conj result (str-for-sqr-idx curr-idx sqr-in width)) (indicies (inc k) width) (inc k))\n                                        )\n                                      )\n                                    )\n                      set-rcv (fn [sqr r c value] (assoc sqr r (assoc (sqr r) c value)))\n                      make-sqr (fn [sqr r c dir nums numjmps jmp k finjmp]\n                                 (if (nil? nums) sqr\n                                   (let [next-row (cond (or (= :e dir) (= :w dir)) r (= :n dir) (dec r) (= :s dir) (inc r))\n                                         next-col (cond (or (= :n dir) (= :s dir)) c (= :w dir) (dec c) (= :e dir) (inc c))\n                                         next-dir (if (= jmp k) (next-dir-map dir) dir)\n                                         next-jmp (if (and (= 1 numjmps) (= jmp k) (not= jmp finjmp)) (inc jmp) jmp)\n                                         next-numjmps (if (and (= 1 numjmps) (= jmp k) (not= jmp finjmp)) 0\n                                                        (if (= jmp k) (inc numjmps) numjmps))\n                                         next-k (if (= jmp k) 0 (inc k))\n                                        ]\n                                     (recur (set-rcv sqr r c (first nums)) next-row next-col next-dir (next nums) next-numjmps next-jmp next-k finjmp)\n                                   )\n                                 )\n                               )\n                      initial-sqr (fn [w h]\n                                    (reduce (fn [x y] (conj x (reduce (fn [v n] (conj v \\*)) [] (range w)))) [] (range h))\n                                  )\n                     ] (transform-sqr (make-sqr (initial-sqr width width) start-row start-col :e digitstring 0 0 0 (dec width)) height)\n                  )\n)","problem":138,"user":"526dd90de4b03e8d9a4a72fe"},{"problem":138,"code":"(fn squares-squared [n N]\n  (letfn [\n          (squares [n N]\n            \"get the list of squares starting with n and ending with N\"\n            (let [h1 (take-while #(<= % N) (iterate #(* % %) n))   ; list of all powers of n less than or equal to N\n                  h2 (#(flatten (for [x %] (map identity (str x)))) h1)  ; this list as list of single chars\n                  l1 (count h2)\n                  v (first (drop-while (fn[x](< (second x) l1)) (map (fn[x][x (* x x)]) (range))))\n                  c (concat h2 (repeat (- (second v) l1) \\*))\n                 ]\n              c))\n\n          (part [coll]\n            \"partitions a list into lists of length 1, 3, 5, ...\"\n            (loop [c coll n 1 ret []]\n              (if (empty? c)\n                ret\n                (recur (drop n c) (+ n 2) (conj ret (vec (take n c)))))))\n          \n          (extend [slist coll d]\n            \"recursively construct caret of diameter d\"\n            (let [c (if (odd? d) coll (reverse coll)) m (dec d)]\n              (loop [sl (if (odd? d) slist (reverse slist))\n                     n 2\n                     ret (conj (conj [] (format \"%s\" (nth c m))) (format \"%c %c\" (nth c (dec m)) (nth c (inc m))))\n                    ]\n                (if (empty? sl)\n                  (if (odd? d) ret (reverse ret))\n                  (let [i (- m n)\n                        fst (if (neg? i) \"\" (format \"%c \" (nth c i)))\n                        lst (if (neg? i) \"\" (format \" %c\" (nth c (+ m n))))\n                        s (first sl)\n                       ]\n                      (recur (rest sl) (inc n) (conj ret (format \"%s%s%s\" fst s lst))))))))\n\n          (out-align[coll]\n           \"fill in the strings in coll with leading and trailing spaces\" \n           (let  [l (count coll)\n                  d (/ (inc l) 2)\n                  slh (take d (iterate (fn[s](format \"%s \" s)) \"\"))\n                  sl (concat (reverse slh) (rest slh))\n                 ]\n              (vec (for [n (range (count coll))] (format \"%s%s%s\" (nth sl n) (nth coll n) (nth sl n))))))\n          ]\n\n    (let [coll (part (squares n N))]\n      (loop [c (rest coll) sl (first coll) d 2]\n        (if (empty? c)\n          (out-align sl)\n          (recur (rest c) (extend sl (first c) d) (inc d)))))))","user":"545537c1e4b0e397800069dd"},{"problem":138,"code":"(fn [start end]\n  (let [numString (apply str (take-while #(<= % end) (iterate #(* % %) start)))\n        newDirection (fn [[r c] oldDirect boardSize]\n                       (cond\n                        (= r 0) [1 1]\n                        (= c 0) [-1 1]\n                        (= r (dec boardSize)) [-1 -1]\n                        (= c (dec boardSize)) [1 -1]\n                        :else oldDirect))\n        expand (fn [board]\n                 (let [oldSize (count board)\n                       newSize (+ 2 oldSize)\n                       newRow [(vec (repeat newSize \\space))]\n                       exOld (for [r (range oldSize)]\n                               (into [] (concat [\\space] (get board r) [\\space])))]\n                   (if (= 0 (rem (inc oldSize) 4)) ;the board grow from 1 -> 3 -> 5 -> 7\n                     (into [] (concat newRow newRow exOld))\n                     (into [] (concat exOld newRow newRow)))))]\n    (loop [result [[(first numString)]] remaining (rest numString) step 3]\n      (if (empty? remaining)\n        (vec (map #(apply str %) result));return result\n        (recur\n         (loop [newBoard (expand result) n step string remaining\n                pos [(quot (count newBoard) 2) (if (= 0 (rem (inc (count newBoard)) 4)) (dec (count newBoard)) 0)]\n                direct (if (= 0 (rem (inc (count newBoard)) 4)) [1 -1] [-1 1])]\n           (let [cell (if (first string) (first string) \\*)\n                 newDirect (newDirection pos direct (count newBoard))]\n             (if (= n 0) newBoard\n               (recur (update-in newBoard pos (fn[x] cell)) (dec n) (rest string) (mapv + pos newDirect) newDirect))))\n         (drop step remaining) (+ step 2))))))","user":"556c70dae4b09a3098a524fd"},{"code":"(fn squares-squared [start end]\n  (let [square      #(* % %)\n        square-seq  (if (= (square start) start) [start]\n                        (take-while #(<= % end) (iterate square start)))\n        digits      (apply str square-seq)\n        shape-width (int (Math/ceil (Math/sqrt (count digits))))\n        board-width (int (dec (* 2 shape-width)))\n        padding     (repeat (- (square shape-width) (count digits)) \\*)\n        middle      (/ (dec board-width) 2)\n        start-pos   [(if (even? shape-width) (dec middle) middle) middle]\n        directions  [[-1 1] [1 1] [1 -1] [-1 -1]]\n        empty-board (vec (repeat board-width\n                                 (vec (repeat board-width \\space))))\n        step        #(map + %1 %2)\n        fill        (fn [board pos d] (assoc-in board pos d))\n        filled?     (fn [board pos]   (not= \\space (get-in board pos)))\n        draw        (fn [board [d & digits] pos [curr-dir next-dir :as dirs]]\n                      (let [board (fill board pos d)]\n                        (if (empty? digits)\n                          board\n                          (if (filled? board (step pos next-dir))\n                            (recur board digits\n                                   (step pos curr-dir) dirs)\n                            (recur board digits\n                                   (step pos next-dir) (rest dirs))))))\n        to-string  #(map (partial apply str) %)]\n    (-> empty-board\n        (draw (apply str digits padding) start-pos (cycle directions))\n        to-string)))","problem":138,"user":"50586354e4b06522596eba78"},{"problem":138,"code":"(fn squares-squared [start end]\n  (let [numbers        (loop [ans  []\n                              curr start]\n                         (let [ans (conj ans curr)\n                               sq  (* curr curr)]\n                           (if (> sq end)\n                             ans\n                             (recur ans sq))))\n        _              (prn numbers)\n        digits         (vec (reduce (fn [ans number]\n                                      (concat ans (vec (str number))))\n                                    []\n                                    numbers))\n        _              (prn digits)\n        lowest-square  (int (Math/ceil (Math/sqrt (count digits))))\n        square-size    (- (* 2 lowest-square) 1)\n        row            (* 2 (quot lowest-square 3))\n        column         (- lowest-square 1)\n        board          (reduce (fn [res _]\n                                 (conj res (reduce (fn [res _]\n                                                     (conj res \\space))\n                                                   []\n                                                   (range square-size))))\n                               []\n                               (range square-size))\n        directions     {:se [+1 +1]\n                        :sw [+1 -1]\n                        :nw [-1 -1]\n                        :ne [-1 +1]}\n        direction-loop {:se :sw\n                        :sw :nw\n                        :nw :ne\n                        :ne :se}\n        route          (:route (reduce (fn [ans _]\n                                         (prn ans)\n                                         (let [current-dir (:current-dir ans)\n                                               current-loc (:current-loc ans)\n                                               remaining   (:remaining ans)\n                                               length      (:length ans)\n                                               route       (:route ans)\n                                               turns       (:turns ans)\n                                               next-loc    [(+ (first current-loc)\n                                                               (first (get directions current-dir)))\n                                                            (+ (second current-loc)\n                                                               (second (get directions current-dir)))]\n                                               route       (conj route next-loc)\n                                               remaining   (dec remaining)\n                                               turns       (if (= 0 remaining)\n                                                             (inc turns)\n                                                             turns)]\n                                           (if (= 0 remaining)\n                                             (if (= 2 turns)\n                                               {:current-loc next-loc\n                                                :current-dir (get direction-loop current-dir)\n                                                :length      (inc length)\n                                                :remaining   (inc length)\n                                                :route       route\n                                                :turns       0}\n                                               {:current-loc next-loc\n                                                :current-dir (get direction-loop current-dir)\n                                                :length      length\n                                                :remaining   length\n                                                :route       route\n                                                :turns       turns})\n                                             {:current-loc next-loc\n                                              :current-dir current-dir\n                                              :length      length\n                                              :remaining   remaining\n                                              :route       route\n                                              :turns       turns})))\n                                       {:current-loc [row column]\n                                        :current-dir :se\n                                        :length      1\n                                        :remaining   1\n                                        :route       [[row column]]\n                                        :turns       0}\n                                       (rest (range (* lowest-square lowest-square)))))]\n    (reduce (fn [ans row]\n              (conj ans (clojure.string/join row)))\n            []\n            (reduce (fn [board i]\n                      (let [[r c] (get route i)]\n                        (assoc-in board [r c] (or (get digits i)\n                                                  \\*))))\n                    board\n                    (range (* lowest-square lowest-square))))))","user":"5dc53ddee4b02f9375f4e1bd"},{"code":"(fn ss [lo hi]\n  (let\n    [square #(* % %)\n\t squares (take-while (partial >= hi) (iterate square lo))\n\t s (apply str squares)\n\t c (count s), d (-> c Math/sqrt Math/ceil int), w (+ d (dec d))\n     pad (repeat (- (square d) c) \"*\")\n\t ps (clojure.string/reverse (apply str s pad))\n\t blank-board (vec (repeat w (vec (repeat w \" \"))))\n\t orbit (fn [d]\n         (mapcat (partial repeat (dec d)) [[1,1] [-1,1] [-1,-1] [1,-1]]))\n\t traversal (fn [d]\n\t   (mapcat #(conj (-> % orbit butlast vec) [1,1]) (range d 0 -2)))\n\t filled-board \n\t   (first \n\t     (reduce\n\t       (fn [[b, r, c, i] [dr, dc]] \n\t         [(assoc b r (assoc (get b r) c (get ps i))),\n\t\t     (+ r dr), (+ c dc), (inc i)])\n         [blank-board, (dec d), 0, 0]\n         (traversal d)  )\t)   \n\t] \n    (map (partial apply str) \n\t  (if (even? d) \n\t    filled-board\n\t\t(reverse (map reverse filled-board))))\n    ))","problem":138,"user":"50d0d4c8e4b00b15ecee976a"},{"problem":138,"code":"(fn draw [beg end]\n  (letfn [(list-of-squares [beg end]\n            (loop [acc [beg]]\n              (let [next (* (last acc) (last acc))]\n                (if (<= next end)\n                  (recur (conj acc next))\n                  acc))))\n          (nums-to-digits [vn]\n            (flatten (map seq (map #(str %) vn))))\n          (add-up-to [top cs]\n            (concat cs (repeat (- top (count cs)) \\*)))\n          (pad-with-stars [cs]\n            (let [len (count cs)]\n              (cond (= len 1) cs\n                    (< len 4) (add-up-to 4 cs)\n                    (= len 4) cs\n                    (< len 9) (add-up-to 9 cs)\n                    (= len 9) cs\n                    (< len 16) (add-up-to 16 cs)\n                    (= len 16) cs\n                    :else :toobig)))]\n    (let [cs (pad-with-stars (nums-to-digits (list-of-squares beg end)))\n          len (count cs)]\n      (cond (= len 1) (vec (list (apply str cs)))\n            (= len 4) (vec (list\n                            (apply str (list\n                                        \\space\n                                        (first cs)\n                                        \\space))\n                            (apply str (list\n                                        (last cs)\n                                        \\space\n                                        (second cs)))\n                            (apply str (list\n                                        \\space\n                                        (nth cs 2)\n                                        \\space))))\n            (= len 9) (vec (list\n                            (apply str (list \\space     \\space     (nth cs 6) \\space     \\space))\n                            (apply str (list \\space     (nth cs 5) \\space     (nth cs 7) \\space))\n                            (apply str (list (nth cs 4) \\space     (nth cs 0) \\space     (nth cs 8)))\n                            (apply str (list \\space     (nth cs 3) \\space     (nth cs 1) \\space))\n                            (apply str (list \\space     \\space     (nth cs 2) \\space     \\space))))\n            (= len 16) (vec\n                        (list\n                         (apply str (list \\space      \\space      \\space      (nth cs 6)  \\space      \\space      \\space))\n                         (apply str (list \\space      \\space      (nth cs 5)  \\space      (nth cs 7)  \\space      \\space))\n                         (apply str (list \\space      (nth cs 4)  \\space      (nth cs 0)  \\space      (nth cs 8)  \\space))\n                         (apply str (list (nth cs 15) \\space      (nth cs 3)  \\space      (nth cs 1)  \\space      (nth cs 9)))\n                         (apply str (list \\space      (nth cs 14) \\space      (nth cs 2)  \\space      (nth cs 10) \\space))\n                         (apply str (list \\space      \\space      (nth cs 13) \\space      (nth cs 11) \\space      \\space))\n                         (apply str (list \\space      \\space      \\space      (nth cs 12) \\space      \\space    \\space))))\n            :else :toobig))))","user":"5d64ecb2e4b0c9e5857d5036"},{"problem":138,"code":"(fn [start end]\n  (letfn [; get the list of digits \n          (get-string [start end]\n                      (let [mylist (loop [cur start curlist []] \n                                     (if (> cur end) curlist\n                                       (recur (* cur cur) (conj curlist cur))\n                                       ))]\n                        (apply str (map str mylist))))\n          \n          ; #cells in 0-based level\n          (get-strip-len [level] (inc (* 2 level)))\n                         \n          ; get the other direction\n          (get-other-dir [dir] (if (= dir :tl) :br :tl))\n          \n          ; wrap strip bottom-right\n          (wrap-strip-br [base strip base-n]\n                         (let [prefix (take base-n strip)\n                               pairs (map vector base prefix)\n                               coned (vec (map (partial apply conj) pairs))]\n                           (conj coned (vec (reverse (drop base-n strip))))\n                           ))\n          \n          ; wrap strip top-left\n          (wrap-strip-tl [base strip base-n]\n                         (let [prefix (reverse (take base-n strip))\n                               pairs (map vector prefix base)\n                               coned (vec (map #(vec (apply cons %)) pairs))]\n                           (vec (cons (vec (drop base-n strip)) coned))\n                           ))\n          \n          ; wrap strip \n          (wrap-strip [base strip base-n dir]\n                      (if (= dir :tl) \n                        (wrap-strip-tl base strip base-n)\n                        (wrap-strip-br base strip base-n)))\n          \n          ; pad strip\n          (pad-strip [strip len] (concat strip (repeat (- len (count strip)) \\*)))\n          \n          ; make square pattern\n          (make-square [string] \n                       (loop [base [[(first string)]]\n                              rest-list (vec (rest string))\n                              dir :br\n                              level 1] \n                         (if (empty? rest-list) base\n                           (let [len (get-strip-len level)\n                                 strip (pad-strip (take len rest-list) len)\n                                 new-base (wrap-strip base strip level dir)]\n                             (recur new-base (drop len rest-list) (get-other-dir dir) (inc level))\n                             ))))\n               \n          ; rotate square\n          (rotate [square]\n                  (let [n (count square)\n                        starts (concat (map vector (range n) (repeat n 0))\n                                       (map vector (repeat (dec n) (dec n)) (range 1 n)))\n                        start-xs (map #(+ (dec n) (- (second %) (first %))) starts)\n                        dir [-1 1]]\n                    \n                    ;; get a row from the square giving start pos and marching direction\n                    (letfn [(get-row [sr sc dr dc]\n                                     (loop [cr sr\n                                            cc sc\n                                            cur-row []]\n                                       (do (println cr cc cur-row)\n                                       (if (or (< cr 0) (> cr (dec n))\n                                               (< cc 0) (> cc (dec n)))\n                                         cur-row\n                                         (recur (+ cr dr) (+ cc dc)\n                                                (conj (vec cur-row) \n                                                      (nth (nth square cr) cc)))\n                                         ))))\n                            \n                            (format-row [r row]\n                                        (let [pad (repeat (nth start-xs r) \" \")\n                                              body (drop 1 (interleave (repeat (count row) \" \") row))]\n                                          (apply str (seq (concat pad body pad)))))]\n\n                      ; local main \n                      (loop [out []\n                             r 0]\n                        (if (> r (dec (dec (* 2 n))))\n                          out\n                          (let [start (nth starts r)]\n                            (recur (vec (conj out (format-row r (get-row (first start) (second start) \n                                                                         (first dir) (second dir))\n                                                              )))\n                                   (inc r))\n                            )))\n                      )))]\n    \n    ; main \n    (rotate (make-square (get-string start end)))\n    ))","user":"52faec2ee4b047fd55837004"},{"problem":138,"code":"(fn [n x]\n    (let [\n          digits\n          (fn [n] \n            (if (= n 0)\n              [0] \n              (loop [l (list) n n]\n                (if (= n 0)\n                  l   \n                  (recur (conj l (mod n 10)) (int (/ n 10)))\n                  )   \n                )   \n              )   \n            )   \n          squareList\n          (fn [n x]\n            (loop [r [] n n]\n              (if (<= n x)\n                (recur (apply conj r (digits n)) (* n n)) \n                r   \n                )   \n              )   \n            )   \n          l (squareList n x)] \n      (map #(apply str %)\n           (let [w (int (Math/ceil (Math/sqrt (count l)))) h (- ( * 2 w) 1) u [ \n                                                                               #(vector (+ (first %) 1) (+ (second %) 1)) \n                                                                               #(vector (+ (first %) 1) (- (second %) 1)) \n                                                                               #(vector (- (first %) 1) (- (second %) 1)) \n                                                                               #(vector (- (first %) 1) (+ (second %) 1)) \n                                                                               ]   \n                 ]   \n             (loop [l l r (vec (repeat h (vec (repeat h \" \")))) n -0.5 d 1 p [(- w (if (even? w) 2 1)) (- w 1)] t (cycle u)] \n               (let [\n                     np ((first t) p)\n                     nd (+ d 1)\n                     ]   \n                 (if (or (< (first np) 0) (< (second np) 0) (>= (first np) h) (>= (second np) h)) \n                   (if (seq l)\n                     (assoc-in r p (first l)) \n                     (assoc-in r p \\*) \n                     )   \n                   (if (seq l)\n                     (if (< d n)\n                       (recur (rest l) (assoc-in r p (first l)) n nd np t)\n                       (recur (rest l) (assoc-in r p (first l)) (+ n 0.5) 0 np (rest t)) \n                       )   \n                     (if (< d n)\n                       (recur l (assoc-in r p \\*) n nd np t)\n                       (recur l (assoc-in r p \\*) (+ n 0.5) 0 np (rest t)) \n                       )   \n                     )   \n                   )   \n                 )   \n               )   \n             ))  \n      )   \n    )","user":"54b90836e4b0ed20f4ff6e9d"},{"code":"(fn sq-sq [from to]                                                                                              \n  (let [numbers (for [x (iterate #(* % %) from)                                                                    \n                      :while (<= x to)] x)                                                                         \n        digits (apply str numbers)                                                                                 \n        steps (drop 2 (interleave (range) (range)))                                                                \n        directions (cycle [[1 1] [1 -1] [-1 -1] [-1 1]])                                                           \n        make-vec #(vec (map vec %))                                                                                \n        walks (apply concat (map #(repeat %1 %2) steps directions))                                                \n        square-steps (apply concat (map #(concat (repeat (- % 1) false) [true]) (iterate #(+ % 2) 1)))]            \n    (map #(apply str %) (loop [square [[(first digits)]]                                                           \n           current-pos [0 0]                                                                                       \n           digits (seq (rest digits))                                                                              \n           walks walks                                                                                             \n           square-steps square-steps]                                                                              \n      (let [this-walk (first walks)                                                                                \n            square-step? (first square-steps)                                                                      \n            walk-to (map + this-walk current-pos)                                                                  \n            [y x] walk-to                                                                                          \n            height-of count                                                                                        \n            width-of #(count (first %))                                                                            \n            this-digit (or (first digits) \\*)                                                                      \n            expanded-square-l (if (< x 0)                                                                          \n                                (make-vec (map #(cons \\space %) square))                                           \n                                square)                                                                            \n            expanded-square-t (if (< y 0)                                                                          \n                                (make-vec (cons (repeat (width-of expanded-square-l) \\space) expanded-square-l))   \n                                expanded-square-l)                                                                 \n            expanded-square-r (if (= x (width-of expanded-square-t))                                               \n                                (make-vec (map #(conj % \\space) expanded-square-t))                                \n                                expanded-square-t)                                                                 \n            expanded-square-b (if (= y (height-of expanded-square-r))                                              \n                                (make-vec (conj expanded-square-r (repeat (width-of expanded-square-r) \\space)))   \n                                expanded-square-r)                                                                 \n            walk-to (map #(if (< % 0) 0 %) walk-to)                                                                \n            new-square (assoc-in expanded-square-b walk-to this-digit)                                             \n            new-square-steps (rest square-steps)                                                                   \n            new-digits (rest digits)                                                                               \n            new-walks (rest walks)]                                                                                \n        (if (and (= this-digit \\*) square-step?)                                                                   \n          square                                                                                                   \n          (recur new-square walk-to new-digits new-walks new-square-steps)))))))","problem":138,"user":"51899891e4b0288ada3dbdab"},{"problem":138,"code":"(fn [f l] (let [ss (apply str (take-while #(<= % l) (iterate #(* % %) f)))\n                s (int (Math/ceil (Math/sqrt (count ss))))\n                ss (str ss (apply str (repeat (- (* s s) (count ss)) \"*\")))\n                flip (fn [n p] (if (even? n) (reverse (map reverse p)) p))\n                a (last (take s (iterate (fn [p]\n                                           (let [n (count p)]\n                                             (flip n (concat (map (fn [row v] (concat row [v])) (flip n p) (subs ss (* n n) (+ n (* n n))))\n                                                           [(reverse (map identity (subs ss (+ n (* n n)) (* (inc n) (inc n)))))])))) [[(first ss)]])))\n                b (into [] (repeat (dec (* 2 s)) (into [] (repeat (dec (* 2 s)) \" \"))))\n                coords (flatten (map-indexed (fn [i v] (map-indexed (fn [j v] {:v v :x (int (+ j i)) :y (int (+ (- j i) s -1))}) v)) a))]\n            (map #(apply str %) (reduce (fn [r {:keys [v x y]}] (assoc-in r [x y] v)) b coords))))","user":"59419bdfe4b060784b3b78f7"},{"code":"(fn make-rect [mn mx]\n  (let [squares (apply str (take-while #(<= % mx) (iterate #(* % %) mn)))\n        dim (-> squares count Math/sqrt Math/ceil int)\n        s (concat squares (repeat (- (* dim dim) (count squares)) \\*))\n        grid-size (-> dim dec (* 2) inc)\n        dirs [[inc inc] [inc dec] [dec dec] [dec inc]]\n        iters (mapcat vector (iterate inc 1) (iterate inc 1))\n        signs (mapcat repeat iters (cycle dirs))\n        indices (reductions (fn [[i0 i1 m0 m1] [f0 f1]] (let [n0 (f0 i0) n1 (f1 i1)] [n0 n1 (min m0 n0) (min m1 n1)])) [0 0 0 0] signs)\n        grid (vec (repeat grid-size (vec (repeat grid-size \\space))))\n        field (vec (map vector s indices))\n        [_ [_ _ -f0 -f1]] (last field)]\n    (map (partial apply str) (reduce (fn [g [ch [i0 i1 _ _]]] (assoc-in g [(- i0 -f0) (- i1 -f1)] ch)) grid field))))","problem":138,"user":"5003ee7de4b0678c553fc446"},{"problem":138,"code":"(fn [start end]\n  (letfn [(lst [s e l] (if (> s e) l (lst (* s s) e (conj l s))))\n          (fill [s c n] (str s (-> n (#(- (* % %) c)) (#(apply str (repeat % \"*\"))))))  ]\n    (let [squares (apply str (lst start end []))\n          csquares (count squares)\n          nsquare (-> csquares Math/sqrt Math/ceil int)\n          ssquares (fill squares csquares nsquare)\n          fsquare (dec (* 2 nsquare))\n          initarr (vec (repeat fsquare (vec (repeat fsquare \" \"))))\n          arrstart [(if (even? nsquare) (- nsquare 2) (dec nsquare)) (dec nsquare)]]\n          (loop [pos arrstart dir [1 1] dis 0 far 0 arr initarr s ssquares]\n            ;(prn \"\") \n             ;(doseq [x arr] (prn x))\n            (cond (empty? s)  (map #(apply str %) arr)\n                  (< dis far) (recur pos [(second dir) (- (first dir))] (+ 5 dis) 0 arr s)\n                  :else       (recur (map + pos dir) dir dis (+ far 10) (assoc-in arr pos (first s)) (rest s))\n            ))\n            )))","user":"5be6d0f8e4b0f319e2d7ec51"},{"code":"(fn metasquare [start end]\n  (letfn [\n    (square-range [from to]\n      (take-while\n        #(<= % to)\n        (iterate #(* % %) from)))\n\n    (digits [numbers]\n      (apply str\n        (map #(Integer/toString %) numbers)))\n\n    (spiral-coords []\n      (let [\n        spiral-sizes (let [naturals (iterate inc 1)]\n                       (interleave naturals naturals))\n        directions (mapcat\n                          repeat\n                          spiral-sizes\n                          (cycle [[0 1] [1 0] [0 -1] [-1 0]]))]\n        (reductions (fn [pos dir] (map + pos dir)) [0 0] directions)))\n\n    (to-iso [[i j]] [(+ i j) (- j i)])\n\n    (spiral-layout [chars]\n      (let [side (int (Math/ceil (Math/sqrt (count chars)))),\n            size (* side side),\n            coords (map to-iso (take size (spiral-coords)))]\n        (zipmap coords (concat chars (repeat \\*)))))\n  \n    (to-string [charmap]\n      (let [coords (keys charmap)\n            lines  (apply sorted-set (map first coords))\n            cols   (apply sorted-set (map second coords))]\n        (for [l lines]\n          (apply str\n            (for [c cols]\n              (get charmap [l c] \\space))))))]\n\n    (to-string\n      (spiral-layout\n        (digits\n          (square-range start end))))))","problem":138,"user":"4eb9ce75535dfed6da9c6d5e"},{"problem":138,"code":"(fn [x limit]\n  (letfn [(square [x]\n            (* x x))\n          (squares-to [x limit]\n            (take-while\n              (partial >= limit)\n              (iterate square x)))\n          (flat-digits [coll]\n            (flatten\n              (map #(seq (str %1)) coll)))\n          (ceil-to-square [x]\n            (first\n              (drop-while\n                (comp (partial > x) second)\n                (map-indexed (fn [i x] [i (square x)]) (range)))))\n          (star-pad-right [coll full-size]\n            (let [n (count coll)\n                  star-count (- full-size n)]\n              (concat coll (repeat star-count \\*))))\n          (step [dir-name from]\n            (let [dirs {:up    [-1  0]\n                        :left  [ 0 -1]\n                        :right [ 0  1]\n                        :down  [ 1  0]}]\n              (map + from (dir-name dirs))))\n          (square-index [coll]\n            (-> coll count Math/sqrt int))\n          (full-path [star-coll]\n            (apply concat (map (partial path star-coll)\n                               (start-coords star-coll))))\n          (fill-answer [m [pos val]]\n            (assoc-in m pos val))\n          (path [coll start]\n            (let [init-p (square-index coll)\n                  f (fn [coords steps dir]\n                      (take steps\n                            (rest (iterate\n                                    (partial step dir)\n                                    (last coords)))))\n                  steps (- (get start 0) (get start 1))\n                  coords (f [start] steps :up)\n                  coords (concat coords (f coords steps :right))\n                  coords (concat coords (f coords steps :down))\n                  coords (concat coords (f coords steps :left))]\n              coords))\n          (start-coords [coll]\n            (let [n (square-index coll)\n                  n (quot (if (odd? n) (inc n) n) 2)]\n              (map vector\n                   (drop n (range))\n                   (range (dec n) -1 -1))))\n          (empty-matrix [dim]\n            (vec (repeat dim (vec (repeat dim \\space)))))\n          (rotate-matrix [M]\n            (let [dim (count M)\n                  RM-dim (dec (* 2 dim))]\n              (loop [y 0\n                     x 0\n                     RM (empty-matrix RM-dim)]\n                (if (= dim y)\n                  RM\n                  (let [next-x (mod (inc x) dim)\n                        next-y (if (zero? next-x)\n                                 (inc y)\n                                 y)\n                        xr (+ dim (- x) (dec y))\n                        yr (+ x y)\n                        value (get-in M [x y])]\n                    (recur next-y\n                           next-x\n                           (assoc-in RM [yr xr] value)))))))\n          (str-matrix [M]\n            (map (partial apply str) M))\n          ]\n    (let [digits (flat-digits (squares-to x limit))\n          [dim dim-square] (ceil-to-square (count digits))\n          star-coll (star-pad-right digits dim-square)\n          p (map vector (full-path star-coll) star-coll)\n          empty (empty-matrix dim)\n          answer (reduce fill-answer empty p)]\n      (-> answer\n          rotate-matrix\n          str-matrix))))","user":"57f0f7b8e4b0bfb2137f5bfe"},{"problem":138,"code":"(fn squares-squared\n  [n m]\n  (let [squares (take-while (partial >= m) (iterate #(* % %) n))\n        n->digits (fn [n] (->> n str (map (comp read-string str))))\n        digits (flatten (map n->digits squares))\n        num-digits (count digits)\n        next-square (fn [n] (->> n Math/sqrt Math/ceil (repeat 2) (reduce *) int))\n        path-len (next-square num-digits)\n        path (take path-len (concat digits (repeat \"*\")))\n        unit-vecs (cycle [[1 1] [-1 1] [-1 -1] [1 -1]])\n        lengths (mapcat #(repeat 2 %) (drop 1 (range)))\n        steps (take (dec path-len) (mapcat repeat lengths unit-vecs))\n        coords (reductions (partial mapv +) [0 0] steps)\n        placements (zipmap coords path)\n        x-min (reduce min (map first coords))\n        x-max (reduce max (map first coords))\n        y-min (reduce min (map second coords))\n        y-max (reduce max (map second coords))]\n    (map\n      (fn [i]\n        (apply str (map #(get placements [% i] \" \") (range x-min (inc x-max)))))\n      (range y-min (inc y-max)))))","user":"5d0bb4fae4b0cc9c91588237"},{"problem":138,"code":"(fn [start end]\n  (let [numfn (fn numfn [n] (if (> n end) [] (concat [n] (numfn (* n n)))))\n        nums (numfn start)\n        digitfn (fn digitfn [n] (if (> n 0) (concat (digitfn (quot n 10)) [(rem n 10)]) []))\n        digits (mapcat digitfn nums)\n        size (first (filter #(>= (* % %) (count digits)) (range)))\n        clen (* size size)\n        chrs (map #(if (< % (count digits)) (first (str (nth digits %))) \\*) (range clen))\n        coorditer (iterate\n                   (fn [[x y dx dy t n]]\n                     (let [nx (+ x dx) ny (+ y dy) nt (inc t) adv (= nt (inc (quot n 2)))]\n                       [nx ny (if adv (- 0 dy) dx) (if adv dx dy) (if adv 0 nt) (if adv (inc n) n)]))\n                   [0 0 1 0 0 0])\n        coords (take clen (map #(take 2 %) coorditer))\n        cmap (reduce (fn [acc i] (assoc acc (nth coords i) (nth chrs i))) {} (range clen))\n        dsize (- (* size 2) 1)\n        cx (dec size)\n        cy (+ cx -1 (rem size 2))\n        dfunc (fn [x y]\n                (let [xx (- x cx) yy (- y cy)]\n                  (if (= (mod (+ xx yy) 2) 0)\n                    (let [sx (/ (+ yy xx) 2) sy (/ (- yy xx) 2)]\n                      (get cmap [sx sy] \\space))\n                    \\space)))]\n    (map\n     (fn [y] (apply str (map\n                         (fn [x] (dfunc x y))\n                         (range dsize))))\n     (range dsize))))","user":"5b465b8be4b02d533a91bc65"},{"problem":138,"code":"(fn [start end]\n (letfn [(concatenate [start end]\n           (apply str\n                  (->> start\n                       (iterate #(* % %))\n                       (take-while #(<= % end)))))\n\n         (make-frame-size [n]\n           (->> (iterate inc 1)\n                (drop-while #(< (* % %) n))\n                (first)))\n\n         (make-empty-frame [fsize]\n           (vec (repeat fsize (vec (repeat fsize \\*)))))\n\n         (down  [[r c]] [(inc r) c])\n         (left  [[r c]] [r (dec c)])\n         (up    [[r c]] [(dec r) c])\n         (right [[r c]] [r (inc c)])\n\n         (make-start-point [n]\n           (reduce\n            #(%2 %1)\n            [0 0]\n            (take (dec n)\n                  (cycle [right down]))))\n\n         (frame [s]\n           (let [fsize (make-frame-size (count s))]\n             (reduce (fn [frame [p c]]\n                       (assoc-in frame p c))\n                     (make-empty-frame fsize)\n                     (map vector\n                          (reductions #(%2 %1)\n                                      (make-start-point fsize)\n                                      (mapcat #(repeat %1 %2)\n                                              (mapcat #(vector % %) (iterate inc 1))\n                                              (cycle [down left up right])))\n                          s))))\n\n         (rotate-frame [frame]\n           (let [fsize (dec (count frame))\n                 not-neg? (complement neg?)\n                 start-point [0 fsize]]\n             ((fn rot [plist]\n                (when (seq plist)\n                  (lazy-seq\n                   (cons (->> plist\n                              (mapv #(get-in frame %))\n                              (filter (complement nil?)))\n                         (rot (distinct\n                               (for [p plist\n                                     m [left down]\n                                     :let [[mr mc :as mv] (m p)]\n                                     :when (and (<= 0 mr fsize)\n                                                (<= 0 mc fsize))]\n                                 mv)))))))\n              (list start-point))))\n\n         (padding [fsize r]\n           (let [rlen (count r)\n                 padlen (quot (- fsize rlen (dec rlen)) 2)]\n             (apply str\n                    (concat\n                     (repeat padlen \\space)\n                     (interpose \\space r)\n                     (repeat padlen \\space)))))\n\n         (reframe [rotated-frame]\n           (let [fsize (apply max (map count rotated-frame))\n                 rfsize (dec (* 2 fsize))]\n             (map (partial padding rfsize) rotated-frame)))]\n   (->> (concatenate start end)\n        (frame)\n        (rotate-frame)\n        (reframe))))","user":"4f5cc3b8e4b0030a34fb2b2b"},{"problem":138,"code":"(fn [x y]\n  (let [make_squ (fn make_squ [x y]\n                   (let [xs (* x x)]\n                     (if (> x y)\n                       '()\n                       (cons x (make_squ xs y)))))\n        squ (apply str (make_squ x y))\n        lc (count squ)\n        square_n (fn square_n [x n]\n                    (if (> (* n n)  x)\n                      '()\n                      (cons (* n n) (square_n x (inc n)))))\n        find_pos_n (fn [lc]\n                     (let [dia_ns (square_n lc 1)\n                           dia_nl (last dia_ns)]\n                       (if (= lc dia_nl)\n                         dia_nl\n                         (let [x ( + 1 (count dia_ns))]\n                           (* x x)))))\n        np (find_pos_n lc)\n        diamond_n (fn diamond_n [x n]\n                    (let [o (- (* 2 n) 1)\n                          o2 (* o o)]\n                      (if (> o2 x)\n                        '()\n                        (cons o2 (diamond_n x (inc n))))))\n        ds (set (diamond_n np 1))\n        make_seq_pos (fn make_seq_pos [[x y] [dx dy] re c ds]\n                       (if (= (count re) c)\n                         re\n                         (let [r (count re)\n                               r2 (- (count re) 1)\n                               ddx (if (= y 0)(* dx -1) dx)\n                               ddy (if (= x 0)(* dy -1) dy)\n                               ddx (if (ds r) -1 ddx)\n                               ddy (if (ds r) 1 ddy)\n                               ddx (if (ds r2) -1 ddx)\n                               ddy (if (ds r2) -1 ddy)\n                               ndxy [ddx ddy]\n                               nxy [(+ x ddx)(+ y ddy)]]\n                           (make_seq_pos nxy ndxy (conj re nxy) c ds))))\n        seq_pos (make_seq_pos [0 0] [-1 -1][[0 0]] np ds)\n        min_r (apply min (map #(first %) seq_pos))\n        min_c (apply min (map #(second %) seq_pos))\n        max_r (apply max (map #(first %) seq_pos))\n        max_c (apply max (map #(second %) seq_pos))\n        row_col (+ 1 (- max_r min_r))\n        res1 (into [] (repeat row_col (into [] (repeat row_col \\space))))\n        trans_seq_pos (map #(list (- (first %) min_r)(- (second %) min_c)) seq_pos)\n        res2 (reduce #(assoc-in % %2 \\*) res1 trans_seq_pos)\n        map_ct (map #(list % %2) squ trans_seq_pos)\n        ]\n    (println seq_pos)\n    (into [] (map #(apply str %)  (reverse (reduce #(assoc-in % (second %2) (first %2)) res2  map_ct)))\n    )))","user":"566d71b1e4b0a866af6896ca"},{"problem":138,"code":"(fn [num-from num-max]\n  (let [nums (take-while #(<= % num-max)\n               (iterate #(* % % #_Math.pow-is-for-double-only) num-from))\n        ;_ (println \"nums:\" nums)\n        digits (for [n nums\n                     d (str n)] d)\n        ;_ (println :digits digits)\n        matrix? map?\n        ;mx is a matrix-like map of maps, with indexes that can be negative: relative to the start point.\n        at (fn [mx [x y :as coordinates]] {:pre [(or (matrix? mx) (seq? mx)) (= (count coordinates) 2)]} #_returns-nil-if-not-set (get-in mx [x y]))\n        ;set-at (fn [mx x y value] (assoc-in mx [x y] value))\n        ;directions as [delta-x delta-y], in coordinates where x is a row, y is a column, [0 0] is the top left corner. D down, U up, R right, L left:\n        d-r [1 1], d-l [1 -1], u-l [-1 -1], u-r [-1 1]\n        ;directions listed in order, each 45degrees to the right after the previous one.\n        directions [d-r d-l u-l u-r]\n        directions-reversed (reverse directions) ;_ (assert (= directions-reversed [u-r u-l d-l d-r]))\n        dir? (fn [[delta-x delta-y :as all]] (and (= (count all) 2) (<= -1 delta-x 1) (<= -1 delta-y 1) (not= delta-x delta-y 0)))\n        turn (fn [prev-dir] {:pre [(dir? prev-dir)]};previous direction => new direction 45degrees to the right\n               (if (= prev-dir u-r)\n                 d-r\n                 (last (for [dir directions-reversed\n                              :while (not= dir prev-dir)]\n                          dir))))\n        _ (assert (and (= (turn u-r) d-r))) _ (assert (= (turn d-r) d-l)) _ (assert (and (= (turn d-l) u-l) (= (turn u-l) u-r)))\n        place? (fn [[x y :as pl]] (and (= (count pl) 2) (number? x) (number? y)))\n        move (fn [[x y :as pl] [x-delta y-delta :as dir]] {:pre [(place? pl) (dir? dir)]}\n               [(+ x x-delta) (+ y y-delta)])\n        right-dir-and-neighbour (fn [place dir]\n                                  (let [dir-right (turn dir)]\n                                    [dir-right (move place dir-right)]))\n        place-dir (fn [places place-prev dir-prev] ;return [new-place new-dir] where new-dir may be the same as dir-prev\n                        {:pre [(place? place-prev) (dir? dir-prev) #_(or (true? over-two?) (false? over-two?))] :post [(place? (first %)) (dir? (second %))]}\n                        (let [[dir-right place-prev-right-neighbour] (right-dir-and-neighbour place-prev dir-prev)\n                               ;_ (println :place-prev-right-neighb place-prev-right-neighbour)\n                              ]\n                            (if (at places place-prev-right-neighbour)\n                              (let [place-prev-direct-neighbour (move place-prev dir-prev)]\n                                [place-prev-direct-neighbour dir-prev])\n                              [place-prev-right-neighbour dir-right])))\n        new-row sorted-map ;sorted only for debugging, in production it can be hash-map\n        entry? #(or (and (char? %) (<= 48 (int %) 57)) (= % \\*))\n        fill-in (fn [places [x y :as place] value] {:pre [(matrix? places) (place? place) (entry? value)] :post [(= ((% x)y) value)]} ;like assoc-in, but using new-map\n                  (let [row (get places x (new-row))\n                        row-updated (assoc row y value)]\n                    ;(println :fill-in :place place :value value)\n                    (assoc places x row-updated)))\n        rows-strings (fn [places]\n                       (let [[min-x max-x min-y max-y] (reduce (fn [[min-x max-x min-y max-y] [x y]]\n                                                                 [(min min-x x) (max max-x x) (min min-y y) (max max-y y)])\n                                                           [10 -10 10 -10]\n                                                           (for [[x row] places, [y _] row] [x y]))\n                                        ;_ (println \"min-x\" min-x \"max-x\" max-x \"min-y\" min-y \"max-y\" max-y)\n                             rows-with-spaces (for [x (range min-x (inc max-x))]\n                                                (apply str\n                                                     (for [y (range min-y (inc max-y))]\n                                                       (get-in places [x y] \\space)\n                                                       )))]\n                         rows-with-spaces))\n        print-places (fn [places] (doseq [row (rows-strings places)] (println (str row \\|))))\n        ;start with direction up to the right u-r, because place-and-dir will turn it to d-r after the 1st digit.\n        ;To complete a square, we need an even number of turns (ignoring the very first \"turn\" from starting direction u-r).\n        places (let [[places-for-digits place-last-digit dir-last-digit num-of-turns]\n                     (loop [places (sorted-map 0 (sorted-map 0 (first digits)))\n                            place-last [0 0]\n                            dir-last u-r\n                            num-of-turns -1\n                            digits-leftover (next digits)]\n                       ;(println :places places \":\")\n                       ;(print-places places)\n                       ;(println :place-last place-last :dir-last dir-last :num-of-turns num-of-turns :digits-leftover digits-leftover)\n                       (if digits-leftover\n                           (let [[place dir] (place-dir places place-last dir-last)\n                                 same-dir? (= dir-last dir)\n                                 num-of-turns-new (if same-dir? num-of-turns (inc num-of-turns))\n                                 places-new (fill-in places place (first digits-leftover))\n                                 ;_ (println :same-dir? same-dir? :num-of-turns-new num-of-turns-new)\n                                 ]\n                             (recur places-new place dir num-of-turns-new (next digits-leftover) ))\n                           [places place-last dir-last num-of-turns])\n                       )]\n                 (if (= (count digits) 1)\n                   places-for-digits\n                   (let [\n                     ;We need to finish with an even number of turns. However, if the digits were filled with an even number of turns, but the last\n                     ;digit didn't have a right neighbour, then that digit was \"out of square,\" and we need two more turns.\n                     ;When filling up with stars *, after the very last (even numbered) turn fill only places that have a neihbour on the right.\n                     even-turn-but-out-of-square (and (even? num-of-turns)\n                                                      (let [[_ last-digit-right-neighbour] (right-dir-and-neighbour place-last-digit dir-last-digit)]\n                                                        (not (at places-for-digits last-digit-right-neighbour))))\n                     dir-last-digit-adjusted (if even-turn-but-out-of-square\n                                               (turn dir-last-digit)\n                                               dir-last-digit)\n                     num-of-turns-adjusted (if even-turn-but-out-of-square\n                                             (inc num-of-turns)\n                                             num-of-turns)\n                     places (loop [places places-for-digits\n                                   pl place-last-digit\n                                   dir dir-last-digit-adjusted\n                                   even-turns (even? num-of-turns-adjusted)]\n                              (let [direct-neighbour (move pl dir)\n                                    [dir-right direct-right-neighbour] (right-dir-and-neighbour direct-neighbour dir)]\n                                (if (at places direct-right-neighbour)\n                                  (let [places-* (fill-in places direct-neighbour \\*)]\n                                    (recur places-* direct-neighbour dir even-turns))\n                                  (if (not even-turns)\n                                    (let [[_ right-neighbour] (right-dir-and-neighbour pl dir) \n                                          continue-direct (at places right-neighbour)\n                                          pl-direct-or-right (if continue-direct direct-neighbour right-neighbour)\n                                          places-* (fill-in places pl-direct-or-right \\*)]\n                                      (recur places-* pl-direct-or-right dir-right true))\n                                    places))))\n                     ;_ (print-places places)\n                    ]\n                 places)))\n        ;_ (println :places places)\n        ] (rows-strings places)))","user":"5b999af8e4b0c0b3ffbd4ad3"},{"problem":138,"code":"(fn __ [lo hi]\n  (let [digits (->> (iterate #(* % %) lo)\n                    (take-while #(<= % hi))\n                    (map (fn [x]\n                           (map #(Character/digit % 10)\n                                (str x))))\n                    flatten)\n        n (count digits)\n        side (int (Math/ceil (Math/sqrt n)))\n        digitstring (concat digits\n                            (repeat (- (* side side) n)\n                                    \\*))\n        m (dec (* 2 side))\n        table ((fn t [side]\n                 (cond (= side 1) [[0]]\n                       (even? side) (conj (vec (map conj\n                                                    (t (dec side))\n                                                    (range (* (dec side) (dec side))\n                                                           (* (dec side) side))))\n                                          (vec (range (dec (* side side))\n                                                      (dec (* side (dec side)))\n                                                      -1)))\n                       (odd? side) (vec (concat [(vec (range (* side (dec side))\n                                                             (* side side)))]\n                                                (map #(vec (concat [%1] %2))\n                                                     (range (dec (* (dec side) side))\n                                                            (dec (* (dec side) (dec side)))\n                                                            -1)\n                                                     (t (dec side)))))))\n               side)]\n    (letfn [(twist [s]\n                   (for [x (range side)]\n                     (for [y (range side)]\n                       (nth s (nth (nth table y) x)))))\n            (rotate45 [matrix]\n                      (map (fn [i]\n                             (for [y (range (max 0 (inc (- i side)))\n                                            (min (inc i) side))]\n                               (nth (nth matrix y) (- i y))))\n                           (range m)))\n            (center [s]\n                    (let [spaces (apply str\n                                        (repeat (/ (- m (count s)) 2)\n                                                \\space))]\n                          (str spaces s spaces)))]\n      (->> (twist digitstring)\n           (rotate45)\n           (map #(clojure.string/join \" \" %))\n           (map center)))))","user":"54c271b9e4b045293a27f602"},{"code":"(fn sq [start end]\n  (let [ds (apply str(loop [r [] s start] (if (>= s end) (if (= s end) (conj r s) r)(recur (conj r s) (* s s)) )))\n        [s_len a_len pstr](loop [n 1 p 1 len (count ds)](if (>= p len) [(dec n) (+ (dec n) (dec (dec n))) (apply str ds (repeat (- p len) \\*))](recur (inc n) (* n n) len)))\n        sp_r (quot a_len 2) sp_r (if (even? s_len) (dec sp_r) sp_r)\n        sp_c (quot a_len 2)\n        d1 #(list (inc %1) (inc %2)) d2 #(list (dec %1) (inc %2)) d3 #(list (dec %1) (dec %2)) d4 #(list (inc %1) (dec %2))\n        turn [d1 d2 d3 d3 d4 d4 d1 d1 d1 d2 d2 d2 d3 d3 d3 d3]]\n    (if (= 0 s_len) [pstr]\n      (let [pp (loop [r [] p [sp_c sp_r] n 0](if (>= n (count pstr)) (apply hash-map r)(recur (conj r p (nth pstr n)) (apply (nth turn n) p) (inc n) )))\n           ]\n         (map #(apply str %)(partition a_len (for [y (range a_len) x (range a_len)] (if-let [d (pp [x y])] d \\space))))\n      )\n    )\n  )\n)","problem":138,"user":"522eba30e4b01cdb292c5f0e"},{"code":"(fn [s e]\n  (let [nums (mapcat str (take-while #(<= % e) (iterate #(* % %) s)))\n        size (first (drop-while #(< % (count nums)) (map #(* % %) (range))))\n        nums (take size (concat nums (repeat \\*)))\n        segments (mapcat #(list % %) (rest (range)))\n        dirs (cycle '[[1 1] [-1 1] [-1 -1] [1 -1]])\n        dxdy (mapcat repeat segments dirs)\n        pos->coord (reductions #(map + % %2) [0 0] dxdy)\n        coord->n (zipmap pos->coord nums)\n        xs (sort (map first (keys coord->n)))\n        ys (sort (map second (keys coord->n)))]\n    (for [y (range (first ys) (inc (last ys)))]\n      (apply str (for [x (range (first xs) (inc (last xs)))]\n                   (coord->n [x y] \" \"))))))","problem":138,"user":"4ebaf790535dfed6da9c6d6e"},{"problem":138,"code":"(fn sqsq [start end]\n  (let [nums (take-while #(<= % end) (iterate (fn [v] (* v v)) start))\n        strs (seq (apply str nums))\n        cnt (cond\n              (= (count strs) 1) 1\n              (<= (count strs) 4) 4\n              (<= (count strs) 9) 9\n              (<= (count strs) 16) 16)\n        filled (concat strs (repeat (- cnt (count strs)) \\*))\n        sqrs {1  {:rows 1 :positions [[0 0]]}\n              4  {:rows 3 :positions [[0 1] [1 2] [2 1] [1 0]]}\n              9  {:rows 5 :positions [[2 2] [3 3] [4 2] [3 1] [2 0] [1 1] [0 2] [1 3] [2 4]]}\n              16 {:rows 7 :positions [[2 3] [3 4] [4 3] [3 2] [2 1] [1 2] [0 3] [1 4] [2 5] [3 6] [4 5] [5 4] [6 3] [5 2] [4 1] [3 0]]}}\n        rows (-> (get sqrs cnt) :rows)\n        positions (-> (get sqrs cnt) :positions)\n        vector (vec (repeat rows (vec (repeat rows \" \"))))\n        uvector (second (reduce\n                          (fn [acc v]\n                            (let [pos (first acc)\n                                  accv (second acc)\n                                  coord  (get positions pos)\n                                  uvec (assoc-in accv coord  v)]\n                              [(inc pos) uvec]\n                              )\n                            )\n                          [0 vector] filled))]\n    (mapv #(apply str %) uvector)))","user":"5592bf9fe4b0c79f6e1db933"},{"problem":138,"code":"(fn [lo hi]\n  (let [sqr      #(* % %)\n        next-sqr #(->> % Math/sqrt \n                       Math/ceil \n                       int sqr)\n\n        str*     #(apply str (flatten %&))\n        rot      #(mapv (comp vec reverse) (reverse %))\n\n        cjust    #(let [r (str* (interpose \\space %2))\n                        p (str* (repeat (quot (- % (count r)) 2) \n                                        \\space))]\n                    (str p r p))\n\n        sqrs      (->> (iterate sqr lo)\n                       (take-while #(>= hi %))\n                       (mapcat str))\n\n        n         (count sqrs)\n        sqrs      (concat sqrs (repeat (- (next-sqr n) n) \\*))]\n    (loop [grid [[(first sqrs)]] \n           ds (rest sqrs), i 1]\n      (if-let [ds (seq ds)]\n        (let [[rhs ds]  (split-at i ds)\n              [apx ds]  (split-at 1 ds)\n              [lhs ds]  (split-at i ds)\n              [top bot] (split-at (-> grid count \n                                      dec (quot 2) \n                                      inc) \n                                  grid)] \n          (recur\n            (rot (concat\n                   top\n                   (conj\n                     (mapv (fn [& row] \n                             (vec (flatten row)))\n                           (reverse lhs)\n                           (conj (vec bot) [])\n                           rhs)\n                     apx))) \n            ds (inc i)))\n        (mapv \n          #(cjust (count grid) %)\n          (if (even? i) \n            (rot grid) \n            grid))))))","user":"53dfdf01e4b0d874e779ae46"},{"problem":138,"code":"(fn squares-squared [s e]\n  (let [v+ (fn [a b] (map + a b))\n        diamond (fn [l p]\n                  (next (reductions v+ (v+ p [1 -1]) (mapcat #(repeat l %) [[-1 1] [1 1] [1 -1] [-1 -1]]))))\n        diamonds (fn [p]\n                   (mapcat #(apply diamond %) (iterate (fn [[l p]] [(+ 2 l) (v+ p [0 -2])]) [1 p])))\n        chars (apply str (take-while #(<= % e) (iterate #(* % %) s)))\n        root (first (drop-while #(< (* % %) (count chars)) (range)))\n        length (+ root (dec root))\n        mid (quot length 2)\n        start [(if (even? root) (dec mid) mid) mid]]\n    (map #(apply str %)\n         (reduce #(apply assoc-in %1 %2)\n                 (vec (repeat length (vec (repeat length \\ ))))\n                 (take (* root root) (map vector (diamonds start) (concat chars (repeat \\*))))))))","user":"53b39d82e4b047364c0444a6"},{"problem":138,"code":"(fn [start end]\n  (let [succ-squares (take-while #(<= % end) (iterate #(* % %) start))\n        raw-digit-str (clojure.string/join \"\" succ-squares)\n        num-chars (count raw-digit-str)\n        [num-required-chars width] (first (drop-while #(< (first %) num-chars) (map (fn [n] [(* n n) n]) (range 1 (inc num-chars)))))\n        starred-digit-chars (concat raw-digit-str (repeat (- num-required-chars num-chars) \\*))]\n  (letfn [(seq-to-matrix [s]\n            (->> s\n                 (partition width)\n                 (map vec)\n                 (vec)))\n          (range-inclusive [start end step]\n            (range start ((if (> step 0) inc dec) end) step))\n          (spiral\n            ([matrix]\n             (let [centre (dec (+ (quot width 2) (rem width 2)))]\n               (->> (map vector\n                         (spiral [centre centre] :right 0 1 0 (* width width))\n                         (flatten matrix))\n                    (sort)\n                    (map last)\n                    (seq-to-matrix))))\n            ([position dir moved target iter iters]\n             (let [dirs { :left  [0 -1]\n                          :right [0  1]\n                          :up    [-1 0]\n                          :down  [ 1 0] }\n                   change-dir { :right :down\n                                :down  :left\n                                :left  :up\n                                :up    :right }\n                   vec-add (fn [a b] (vec (map + a b)))\n                   move (fn [pos dir] (vec-add pos (dir dirs)))]\n               (if (= iter iters)\n                 []\n                 (cons\n                   position\n                   (lazy-seq\n                     (spiral\n                       (move position dir)\n                       (if (= (inc moved) target)\n                         (change-dir dir)\n                         dir)\n                       (rem (inc moved) target)\n                       (if (= (inc moved) target)\n                         ; every second time we turn the corner\n                         ; we need an additional row/col\n                         (if (or (= dir :up) (= dir :down))\n                           (inc target)\n                           target)\n                         target)\n                       (inc iter)\n                       iters)))))))\n          (matrix-to-diamond [matrix]\n            (map\n              (fn [coords] (map #(get-in matrix %) coords))\n              (map\n                (fn [[row dir]]\n                  (if (= dir :inc)\n                    (map vector\n                         (range-inclusive row 0 -1)\n                         (range-inclusive 0 row 1))\n                    (map vector\n                         (range (dec width) 0 -1)\n                         (range (- row (dec width)) width))))\n                (concat\n                  (map vector (range width) (repeat :inc))\n                  (map vector (range width (dec (* 2 width))) (repeat :dec))))))\n          (stringify-diamond [diamond]\n            (map\n              (fn [row]\n                (let [padding (repeat (- width (count row)) \" \")]\n                  (apply str (concat padding (interpose \" \" row) padding))))\n              diamond))]\n    (->> starred-digit-chars\n      (seq-to-matrix)\n      (spiral)\n      (matrix-to-diamond)\n      (stringify-diamond)))))","user":"5aa998c6e4b0d174b936c8e5"},{"problem":138,"code":"(fn [a b]\n\t(let [d ((fn [a b] (mapcat str (take-while #(<= % b) (iterate #(* % %) a)))) a b)\n\t\t  c (count d)\n\t\t  diag (int (Math/ceil (Math/sqrt c)))\n\t\t  row-count (inc (* 2 (dec diag)))\n\t\t  d (first (partition (* diag diag) (* diag diag) (repeat \\*) d))\n\t\t  \n\t\t  coords+ (fn [[a1 a2] [b1 b2]] [(+ a1 b1) (+ a2 b2)])\n\t\t  start-coords [(dec diag) (if (odd? diag) (dec diag) (- diag 2))]\n\t\t  inc-coords (take (count d) (mapcat #(repeat %1 %2) (mapcat #(repeat 2 %) (drop 1 (range))) (cycle [[1 1] [-1 1] [-1 -1] [1 -1]])))\n\t\t  coords (reductions #(coords+ %1 %2) start-coords inc-coords)\n\t\t  blank-field (vec (repeat row-count (vec (repeat (dec (* 2 diag)) \" \"))))]\n\t\t  (map (partial apply str) (reduce (fn [bf [coord v]] (update-in bf (reverse coord) (fn [_] v))) blank-field (map vector coords d)))))","user":"53e19461e4b0d874e779ae59"},{"code":"(fn [s e]\n  (let [d (apply str (take-while\n                       (partial >= e)\n                       (iterate #(* % %) s)))\n        w (first (filter #(<= (count d) (* % %)) (range)))\n        size (+ w (dec w))\n        t (concat d (repeat (- (* w w) (count d)) \\*))\n        r (drop 2 (mapcat (partial repeat 2) (range)))\n        delta '([1 1] [-1 1] [-1 -1] [1 -1])\n        f (fn [xs n v] (concat\n                         (take n xs)\n                         [v]\n                         (drop (inc n) xs)))\n        ins (fn [b x y v] (f b y (f (nth b y) x v)))]\n    (loop [xs t\n           [x y] [(quot size 2) (* 2 (quot (dec w) 2))]\n           b (for [i (range size)] (repeat size \" \"))\n           [c n] [(nth r 0) 0]]\n      (if (empty? xs)\n        (map (partial apply str) b)\n        (recur\n          (rest xs)\n          (map + [x y] (nth delta (mod n 4)))\n          (ins b x y (first xs))\n          (if (= c 1)\n            [(nth r (inc n)) (inc n)]\n            [(dec c) n]))))))","problem":138,"user":"5201572be4b0d7096e99ddbb"},{"code":"(fn square-squad [a b]\n        (let [n (take-while #(not (> % b)) (iterate #(* % %) a))\n              m (map #(str (- (int %) 48)) (mapcat str n))\n              m (map vector m (mapcat #(repeat % %2)\n                                      (mapcat #(list % %)\n                                              (range 1 (inc (count m))))\n                                      (cycle [:t :r :b :l])))\n              s (int (Math/ceil (Math/sqrt (count m))))\n              e (vec (map #(vec (repeat % \"*\"))\n                          (concat (range 1 s) [s] (range (dec s) 0 -1))))\n              t (loop [col (quot (dec s) 2) row (* 2 col) m m e e]\n                  (if (empty? m)\n                    e\n                    (let [[[n p] & q] m\n                          i #(if (= row (dec s)) % %2)\n                          [c r] (cond\n                                    (= p :t) [(i col (inc col)) (inc row)]\n                                    (= p :r) [(dec col) (inc row)]\n                                    (= p :b) [(i (dec col) col) (dec row)]\n                                    (= p :l) [col (dec row)])] \n                      (recur c r q (assoc-in e [row col] n)))))\n              z (- (* 2 s) 1) y (repeat \\ )]\n          (vec (map #(let [x (apply str (interpose \" \" %))\n                           g (take (/ (- z (count x)) 2) y)]\n                       (apply str (concat g x g))) t))))","problem":138,"user":"4f031eac535dcb61093f6a67"},{"problem":138,"code":"(fn [s e]\n  (let [sq (mapcat str (take-while #(>= e %) (iterate #(* % %) s)))\n        sz (first (filter #(>= % (count sq))\n                          (map #(* (inc %) (inc %)) \n                               (range))))\n        sq (concat sq (repeat (- sz (count sq)) \\*))\n        d (first (filter #(>= (* % %) (count sq)) (lazy-seq (map inc (range)))))\n        c (count sq)]\n    (if (= 1 c)\n      (list (str s))\n      (let [quadrado (vec (repeat d (vec (repeat d nil))))\n            ops (lazy-seq (mapcat (fn [n op]\n                                    (repeat n op))\n                                  (lazy-seq (mapcat #(repeat 2 (inc %)) (range)))\n                                  (cycle (list [1 0] [0 -1] [-1 0] [0 1]))))\n            pivot [(int (/ (dec d) 2)) (int (/ d 2))]\n            ps-v (reduce (fn [s [p v]]\n                           (conj s [(vec (map + (first (peek s)) p)) v]))\n                         [[pivot (first sq)]]\n                         (map vector ops (next sq)))\n            q (reduce (fn [q [p v]]\n                        (assoc-in q p v))\n                      quadrado\n                      ps-v)\n            losango (let [d (count q)\n                          ps (for [l (range d)\n                                   c (range d)]\n                               [l c])]\n                      (reduce (fn [res [l c]]\n                                (let [nl (+ d (- l))\n                                      idx (- (dec (* 2 d)) (+ nl c))]\n                                  (assoc res idx (conj (get res idx) (get-in q [l c])))))\n                              (vec (repeat (dec (* 2 d)) []))\n                              ps))]\n        (map #(let [linha (apply str (interpose \" \" %))\n                    linha-a (apply str (repeat (/ (- (dec (* 2 d)) (count linha)) 2) \" \"))]\n                (str linha-a linha linha-a))\n             losango)))))","user":"52c8758be4b0c2d177d62135"},{"problem":138,"code":"; Not my solution\n; I copied from https://github.com/khotyn/4clojure-answer/blob/master/138-squares-squared.clj\n(fn [i j] \n  (let [num-str (apply str (take-while #(<= % j) (iterate #(* % %) i)))\n        str-size (first (drop-while #(< (* % %) (count num-str)) (range)))\n        s (concat num-str (repeat (- (* str-size str-size) (count num-str)) \\*))\n        board-size (dec (* 2 str-size))\n        init-board (vec (repeat board-size (vec (repeat board-size \\space))))]\n    (println init-board)\n    (letfn [(step [board current gap str-seq]\n              (if (seq str-seq)\n                (let [next-board (assoc-in board current (first str-seq))\n                      f-next-gap (if (zero? (first current))\n                                   [1 -1]\n                                   (if (= (dec board-size) (first current))\n                                     [-1 1]\n                                     (if (zero? (second current))\n                                       [1 1]\n                                       (if (= (dec board-size) (second current))\n                                         [-1 -1]\n                                         gap))))\n                      f-next-current (map #(+ %1 %2) current f-next-gap)\n                      next-gap (if (= \\space (get-in board f-next-current))\n                                 f-next-gap\n                                 (case f-next-gap\n                                   [1 -1] [1 1]\n                                   [1 1] [-1 1]\n                                   [-1 1] [-1 -1]\n                                   [-1 -1] [1 -1]))]\n                  (step next-board (map #(+ %1 %2) current next-gap) next-gap (next str-seq)))\n                board))]\n      (mapv #(apply str %) (step init-board (if (odd? str-size) [(dec str-size) (dec board-size)] [(dec str-size) 0]) [1 1] (reverse s))))))","user":"575ef4b6e4b08062f99a4e78"},{"problem":138,"code":"(fn [from to]\n       (let\n           [li (take-while\n                (partial >= to)\n                (iterate #(* % %) from))\n            digits\n            (fn [n]\n              (->> n\n                   (iterate #(quot % 10))\n                   (take-while #(> % 0))\n                   (map #(mod % 10))\n                   reverse))\n\n            paper (fn [wrap li]\n                    (let [n (count wrap)\n                          longli (concat li (repeat \"*\"))\n                          dnli (take\n                                (inc n)\n                                (drop n longli))\n                          ]\n                      [(drop (+ n n 1) li)\n                       (if (= 1 (mod n 2))\n                         ;; odd\n                         (vec\n                          (conj\n                           (vec\n                            (map conj wrap longli))\n                           (vec\n                            (reverse dnli))))\n\n                         ;; even\n                         (vec\n                          (cons\n                           (vec\n                            dnli)\n                           (->>\n                            (map\n                             cons\n                             (reverse\n                              (take n longli))\n                             wrap)\n                            (map vec)\n                            vec))))\n                       ]))\n\n            paperize (fn [li]\n                       (loop [li li\n                              wrap []]\n                         (if (empty? li)\n                           wrap\n                           (let [[nwrap nli] (paper wrap li)]\n                             (recur nwrap nli)))))\n\n            diagonalize\n            (fn [xs]\n              (let [xc (count xs)\n                    diags (dec (* 2 xc))]\n                (map\n                 (fn [i]\n                   (->> (map\n                         (partial - i)\n                         (range 0 (inc i)))\n                        (map vector (range diags))\n                        (filter\n                         (fn [[x y]]\n                           (and\n                            (< y xc)\n                            (< x xc))))\n                        (map (fn [[x y]] ((xs x) y)))))\n                 (range diags))))\n\n            fill-paddings\n            (fn [diagonalized]\n              (let [c (inc (quot (count diagonalized) 2))]\n                (->>\n                 (concat\n                  (reverse (range c))\n                  (rest (range c)))\n                 (map\n                  (fn [pad]\n                    (->> (repeat \" \")\n                         (take pad )\n                         (reduce str))))\n                 (map\n                  (fn [diag pad]\n                    (str pad (reduce str (interpose \" \" diag)) pad))\n                  diagonalized))))\n\n            ]\n         #_(mapcat digits li)\n\n         #_(paper\n            '[[g h i] [f a b] [e d c]]\n            [1 2 3 4 5 6 7 8 9])\n\n         #_(paper\n            '[[a b] [d c]]\n            [1 2 3 4 5 6 7 8])\n\n         #_(diagonalize\n            '[[a b] [d c]])\n\n         (->> (mapcat digits li)\n              paperize\n              diagonalize\n              (map reverse)\n              fill-paddings)\n\n         ))","user":"586a657de4b0f14aab7c88bd"},{"problem":138,"code":"(fn [s e] \n(let [l (loop [doing s r \"\"] (if (> doing e) r (recur (* doing doing) (str r doing))))\n      n (int (Math/ceil (Math/sqrt (count l))))\n      nn (dec (* 2 n))\n      table (vec (repeat nn (vec (repeat nn \\space))))\n      ystart (if (odd? n) n (dec n))\n      xstart n\n      f1 (fn [n] (if (odd? n) \n                   (map vector (map - (concat (range n) (range (- n 2) -1 -1))) (range))\n                   (map vector (concat (range n) (range (- n 2) -1 -1)) (map - (range)))))]\n  ;(assoc-in table [(dec ystart) (dec xstart)] (first l))\n  (mapv #(apply str %) (loop [doing 2 pos [ystart xstart] result (assoc-in table [(dec ystart) (dec xstart)] (first l))]\n              (if (> doing n) result\n                  (let [todo (f1 doing) todo1 (map #(mapv + pos %) todo) \n                        _ (println doing)\n                        txt (subs l (* (dec doing) (dec doing))) \n\n                        nextpos (mapv + (last todo1) (if (even? doing) [-1 -1] [1 1]))\n                        newtable \n                        (loop [n 0 dd todo1 tt result]\n                          (if (empty? dd)\n                            tt \n                            (recur (inc n) (rest dd) (assoc-in tt (first dd) (get txt n \\*)))))] (recur (inc doing) nextpos newtable)\n\n                       ))))\n\n))","user":"5951190be4b066ee0a44aea4"},{"code":"(fn squares-squared [start end]\n  (let [dirs [[1 1] [-1 1] [-1 -1] [1 -1]]\n        c-seq (mapcat vector (iterate inc 1) (iterate inc 1))\n        v-seq (mapcat #(take %2 (repeat (dirs (rem %1 4)))) (range) c-seq)\n        n-seq (mapcat #(Integer/toString %)\n                      (take-while #(<= % end) (iterate #(* % %) start)))\n        s-len (first (drop-while #(< (* % %) (count n-seq)) (iterate inc 1)))\n        n-seq (concat n-seq\n                      (take (- (* s-len s-len) (count n-seq)) (repeat \\*)))\n        width (dec (* 2 s-len))\n        center [(quot width 2)\n                (if (= (rem width 4) 3) (dec (quot width 2)) (quot width 2))]\n        make-array (fn [w] (into [] (take w (repeat (into [] (take w (repeat \\space)))))))\n        update-array (fn [w x y val] (assoc w y (assoc (w y) x val)))\n        ]\n    (map #(apply str %)\n         (first (reduce (fn [[array x y] [[dx dy] val]]\n                          [(update-array array x y val) (+ x dx) (+ y dy)])\n                        [(make-array width) (center 0) (center 1)]\n                        (map vector v-seq n-seq))))))","problem":138,"user":"4f0e995e535d0136e6c22326"},{"code":"(fn sqsq [a b]\r\n  (let [filled (let [sq #(* % %),\r\n                     digits (apply concat (map str (take-while #(<= % b) (iterate sq a)))),\r\n                     len (first (drop-while #(< % (count digits)) (map sq (range))))]\r\n                 (concat digits (repeat (- len (count digits)) \\*)))\r\n        size (Math/sqrt (count filled)),\r\n        motions (let [right {[0 -1] [1 0], [1 0] [0 1], [0 1] [-1 0], [-1 0] [0 -1]},\r\n                      proceed (fn [[pos dir]] [(map + pos dir) dir]),\r\n                      r-turn-proceed (fn [[pos dir]] (proceed [pos (right dir)]))]\r\n                  (mapcat #(concat [r-turn-proceed] (repeat % proceed) [r-turn-proceed] (repeat % proceed)) (range)))\r\n        rect-poss (let [pos-seq (fn pos-seq [[pos dir] mot]\r\n                                  (lazy-seq (cons pos (pos-seq ((first mot) [pos dir]) (rest mot))))),\r\n                        poss (take (count filled) (pos-seq [[0 0] [0 -1]] motions))]\r\n                    (map (fn [[x y]] [(- x (apply min (map first poss))) (- y (apply min (map second poss)))]) poss)),\r\n        pos-char-map (zipmap rect-poss filled),\r\n        make-rotate-line (fn [idx]\r\n                           (let [cs (map pos-char-map (sort (filter #(= (+ (first %) (second %)) idx) rect-poss))),\r\n                                 cslen (dec (* 2 (count cs))),\r\n                                 padlen (/ (- (dec (* 2 size)) cslen) 2)]\r\n                             (apply str (concat (repeat padlen \\space) (interpose \\space cs) (repeat padlen \\space)))))\r\n        ]\r\n    (map make-rotate-line (range (dec (* size 2))))))","problem":138,"user":"4f62b29ce4b0defedf855fd9"},{"problem":138,"code":"(fn\n  [start end]\n  (let [ch1 (apply str (take-while #(<= % end) (iterate #(* %1 %1) start)))\n        side (-> (count ch1)\n                 Math/sqrt\n                 Math/ceil\n                 int)\n        diag (+ side side -1)\n        ch2 (take (* side side) (concat ch1 (repeat \\*)))\n        blank (vec (repeat side (vec (repeat side \\space))))\n        center (fn [ss] (let [s-s (apply str (interpose \\space ss))\n                                pad (apply str (repeat (/ (- diag (count s-s)) 2) \\space))]\n                          (str pad s-s pad)))\n        f (fn f [side max-side] \n            (let [offset (/ (- max-side side) 2)]\n              (cond (= side 1) [[offset offset]]\n                    (odd? side) (concat (f (- side 2) max-side)\n                                        (reductions #(mapv + % %2 )\n                                                    [(inc offset) (- (dec max-side)  offset)]\n                                                    (rest (mapcat (partial repeat (dec side))\n                                                                  [[1 0] [0 -1] [-1 0] [0 1]]))))\n                    (pos? side) (concat (f (- side 2) max-side)\n                                        (reductions #(mapv + % %2 )\n                                                    [(- (dec max-side) (inc offset)) offset]\n                                                    (rest (mapcat (partial repeat (dec side))\n                                                                  [[-1 0] [0 1] [1 0] [0 -1]])))))))\n        block (reduce (fn [b [k v]] (assoc-in  b k v)) blank (map vector (f side side) ch2))\n        rotate (vals (group-by #(apply + %) (for [i (range side) j (range side)] [j i])))]\n    (for [row rotate] (center (map #(get-in block %) row)))\n    ))","user":"56102f50e4b05f002753df6b"},{"code":"(letfn [(chevron [n]\n          (map (if (odd? n)\n                  (fn [[r c]] [(inc r) (- c)])\n                  (fn [[r c]] [(- r)   c    ]))\n           (map vector\n             (concat (range (inc n)) (reverse (range n)))\n             (range (- n) (inc n)))))\n        (spiral [z]\n          (take z (mapcat chevron (range))))\n        (square-fit [z]\n          (some #(when (<= z %) %)\n                (map #(* % %) (range))))\n        (box-dim [z]\n          (nth (iterate #(+ % 2) 1)\n               (dec (Math/sqrt z))))\n        (box-t [z]\n          (let [d (nth (map vector\n                         (#(interleave % %) (iterate #(- % 2) 0))\n                         (iterate dec 0))\n                       (dec (Math/sqrt z)))]\n            #(map - % d)))\n        (blank [e]\n          (vec (repeat e\n            (vec (repeat e \\space)))))\n        (place-at [b c v]\n          (if (empty? c)\n            b\n            (recur (assoc-in b (first c) (first v))\n                   (rest c)\n                   (rest v))))\n        (sqseq [a b]\n          (take-while #(<= % b)\n            (iterate #(* % %) a)))\n        (digstr [s]\n          (mapcat #(.toString %) s))]\n  (fn [a b]\n    (let [d (digstr (sqseq a b))\n          z (square-fit (count d))]\n      (map #(apply str %)\n        (place-at (blank (box-dim z))\n                  (map (box-t z)\n                    (spiral z))\n                  (lazy-cat d (repeat \\*)))))))","problem":138,"user":"4f6fbb68e4b07046d9f4efeb"},{"problem":138,"code":"(fn [s e]\n (let [t (take-while #(<= % e) (iterate #(* % %) s))\n       c (count (apply str t))\n       d (int (Math/ceil (Math/sqrt c)))\n       e (* d d)\n       f (dec (* 2 d))\n       x (drop c (repeat e \"*\"))\n       y (apply str (map str (concat t x)))\n       z (comp vec repeat)\n       b (z f (z f \\space))\n       a (fn [u] (mapcat #(repeat (+ u (* 2 %)) (int (Math/pow -1 (+ 1 u %)))) (range)))\n       m (a 0)\n       n (a 1)\n       p (for [i (range (dec e))]\n          [(nth m i) (nth n i)])\n       g (dec d)\n       q [(- g (mod g 2)) g]\n       r (reduce #(conj % (map + (last %) %2)) [q] p)]\n  (map #(apply str %)\n   (loop [r r y y b b]\n    (if (seq r)\n     (recur (rest r) (rest y) (assoc-in b (first r) (str (first y))))\n     b)))))","user":"5b61aa6ae4b0c6492753e712"},{"code":"(fn [start end]\n   (let [squares (take-while #(<= % end) (iterate #(* % %) start))\n         string  (concat (apply str squares))\n         dim     (int (Math/ceil (Math/sqrt (count string))))\n         pad-str (apply str (concat string\n                                    (repeat (- (* dim dim)\n                                               (count string))\n                                            \"*\")))\n         center  (fn [n sq]\n                   (let [joined (interpose \" \" sq)\n                         pad    (repeat (/ (- n (count joined)) 2)\n                                        \" \")]\n                     (apply str (concat pad joined pad))))\n         side    (dec (* 2 dim))\n         wrap-seq (fn wrap-seq [n s]\n                    (if (= n 1)\n                      [s]\n                      (let [[hd tl] (split-at (* (dec n) (dec n))\n                                              (seq s))\n                            hds     (wrap-seq (dec n) (apply str hd))\n                            fold    (fn fold [[x & ys]]\n                                      (if (seq ys)\n                                        (conj (fold (butlast ys))\n                                              [x (last ys)])\n                                        [[x]]))\n                            overlap (max 0 (- n 2))]\n                        (let [ftl     (fold tl)\n                              x       (if (odd? n) ftl hds)\n                              y       (if (odd? n)\n                                        hds\n                                        (reverse (map reverse ftl)))\n                              [x1 x2] (split-at (- (count x) overlap) x)\n                              [y1 y2] (split-at overlap y)\n                              midbits (if (odd? n) [x2 y1] [y1 x2])\n                              mid     (apply map (fn [[a b] x]\n                                                   (concat [a] x [b]))\n                                             midbits)]\n                          (concat x1 mid y2)))))\n         wrap    (fn [n s]\n                   (map (fn [r] (center side r))\n                        (wrap-seq n s)))]\n     (wrap dim pad-str)))","problem":138,"user":"4ea1b9e4535d7eef308072b8"},{"problem":138,"code":"(fn [f l]\n  (let [s (take-while #(<= % l) (iterate #(* % %) f))\n        ss (reduce str \"\" s)\n        sn (count ss)\n        sq (map #(* % %) (range))\n        sl (some #(and (>= % sn) %) sq)\n        sc (reduce str ss (repeat (- sl sn) \\*))\n        sf (fn sf [s n] (let [f (first s)\n                              l (last s)]\n                          (lazy-cat (repeat n s) (repeat n [(- f) l])\n                            (sf [(- f) (- l)] (inc n)))))\n        pl (fn pl [r d p] (let [x (first p)\n                                y (last p)\n                                m (count r)\n                                n (count (first r))\n                                ns (vec (repeat n \" \"))]\n                            (cond\n                              (< y 0) (pl (into [ns] r) d [x (inc y)])\n                              (>= y m) (pl (into r [ns]) d p)\n                              (< x 0) (pl (vec (map #(into [\" \"] %) r)) d [(inc x) y])\n                              (>= x n) (pl (vec (map #(into % [\" \"]) r)) d [x y])\n                              :else (assoc-in r [y x] d))))]\n    (if (= sl 1)\n      [ss]\n      (map #(apply str %)\n        (loop [ps (take (dec sl) (sf [1 1] 1))\n               p [0 0]\n               s (rest sc)\n               res [[(first sc)]]]\n          (if (empty? s)\n            res\n            (let [c (map + p (first ps))\n                  nc [(max 0 (first c)) (max 0 (last c))]]\n              (recur (rest ps) nc (rest s) (pl res (first s) c)))))))))","user":"55205564e4b08d5046aa8a60"},{"problem":138,"code":"(fn [l m]\n    (let [vals (vec (apply str (take-while #(<= % m) (iterate #(* % %) l))))\n          val-root (Math/ceil (Math/sqrt (count vals)))\n          val-sq (Math/pow val-root 2)\n          vals (concat vals (vec (repeat (- val-sq (count vals)) \"*\")))\n          coords (take val-sq [[0 0] [1 1] [0 2] [-1 1] [-2 0] [-1 -1] [-0 -2] [1 -1] [2 0] [3 1] [2 2] [1 3] [0 4] [-1 3] [-2 2] [-3 1]])\n          min-loc (mapv #(apply min %) ((juxt #(map first %) #(map second %)) coords))\n          grid-size (dec (* 2 val-root))\n          blank (vec (repeat grid-size (vec (repeat grid-size \" \"))))]\n      (mapv clojure.string/join\n            (reduce (fn [m [v [r c]]] (assoc m c (assoc (get m c) r v)))\n                    blank\n                    (partition 2 (interleave vals (mapv #(map - % min-loc) coords)))))))","user":"5310e968e4b08068f379ecdd"},{"problem":138,"code":"(fn ss [s e]\n  (let [number-str (apply str (take-while #(<= % e) (iterate #(* % %) s)))\n        old-len (count number-str)\n        sqrt-len (int (Math/ceil (Math/sqrt old-len)))\n        real-len (* sqrt-len sqrt-len)\n        whole-str (concat number-str (repeat (- real-len old-len) \"*\"))\n        output-squre (- (* 2 sqrt-len) 1)\n        start-pos [(if (even? sqrt-len) (- sqrt-len 2) (- sqrt-len 1)) (- sqrt-len 1)]\n        smallest-sqrt (fn [v] (int (Math/floor (Math/sqrt v))))\n\n        next-step-fy (fn [currntfx cnt]\n      (if (and (> cnt 0) (= cnt (* (smallest-sqrt cnt) (smallest-sqrt cnt))))\n        (if (= currntfx inc) dec inc)\n        currntfx))\n\n        next-step-fx (fn [currntfy cnt]\n      (let [t1 (smallest-sqrt cnt)\n            t2 (* (+ t1 1) t1)]\n        (if (and (> cnt 0) (= cnt t2))\n          (if (= currntfy inc) dec inc)\n          currntfy)))\n        all-valid-char ((fn []\n                          (loop [char-map {} cnt 0 current-pos start-pos fx inc fy inc]\n                            (if (= cnt real-len)\n                              char-map\n                              (let [nextfx (next-step-fx fx cnt)\n                                    nextfy (next-step-fy fy cnt)]\n                                (recur (assoc char-map current-pos (nth whole-str cnt))\n                                  (inc cnt)\n                                  [(nextfx (first current-pos)) (nextfy (second current-pos))]\n                                  nextfx nextfy\n                                  ))))))\n        get-char (fn [pos] (get all-valid-char pos (char 32)))\n        ]\n    (map #(apply str %) (for [x (range output-squre)] (for [y (range output-squre)] (get-char [x y]))))\n\n    )\n  )","user":"5405885ee4b0addc1aec6668"},{"problem":138,"code":"(fn [from to]\n  (let [cs    (apply str (take-while #(<= % to)\n                                     (iterate #(*' % %) from)))\n        edge  (-> cs count Math/sqrt Math/ceil int)\n        size  (-> edge dec (* 2) inc)]\n    (loop [[c & cs]     cs\n           [drc & drcs] (take (* edge edge)\n                          (mapcat (fn [n d] (repeat n d))\n                            (interleave (iterate inc 1) (iterate inc 1))\n                            (cycle [[1 1] [1 -1] [-1 -1] [-1 1]])))\n           rc           [(-> edge dec (/ 2) int (* 2)) (dec edge)]\n           out          (vec (repeat size (vec (repeat size \\space))))]\n      (if drc\n        (recur cs drcs (map + rc drc) (assoc-in out rc (or c \\*)))\n        (map (partial apply str) out)))))","user":"4f9d8083e4b0dcca54ed6d23"},{"problem":138,"code":"(fn sos [a b]\n  (let [\n        ; calculate numbers for the square from a to b\n        ; @param a - start\n        ; @param b - end (including)\n        calc-nums (fn [a b]\n                    (loop [x a, result []]\n                      (cond\n                        (> x b) result\n                        (= x b) (conj result x)\n                        :else (recur (int (Math/pow x 2)) (conj result x)))))\n        ; make input nums into sequence of digits\n        ; @param nums - sequence of numbers\n        make-dig-seq  (fn [nums]\n                        (loop [n nums, result []]\n                          (if-not (empty? n)\n                            (recur (rest n) (conj result (map str (-> (first n) str seq))))\n                            (flatten result))))\n        ; make lazy collection of squares\n        make-squares  (fn [] (map #(int (Math/pow % 2)) (iterate inc 1)))\n        ; find the smalles square size into which fill all digits\n        ; @param digits-count - count of digits for filling a square\n        ; @param squares      - lazy sequence of squares \n        find-square-count (fn [digits-count, squares]\n                            (if (= 1 digits-count)\n                              1\n                              (loop [sqs squares]\n                                (if (<= digits-count (first sqs))\n                                  (first sqs)\n                                  (recur (rest sqs))))))\n        ; make a sequence of digits and asterisk to make a square\n        ; @param digits  - sequence of digits which will be filled with asterisks\n        ; @param squares - lazy sequence of squares \n        fill-with-asterisks (fn  [digits squares]\n                              (let [digits-count (count digits)\n                                    square-count (find-square-count digits-count squares)\n                                    asts-count (- square-count digits-count)]\n                                (if (zero? asts-count)\n                                  digits\n                                  (concat digits (take asts-count (repeatedly (fn [] \"*\")))))))\n        ; calculate the array into which chars will be rendered\n        ; for example for 9 chars we need 5x5 array, so the edge is 5\n        ; @param chars - digits and characters, which count is a square\n        calc-array-edge (fn [chars]\n                          (let [sqrt-val (int (Math/sqrt (count chars)))]\n                            (+ sqrt-val (dec sqrt-val))))\n        ; calculate coordinates of the starting point\n        ; @param chars-count  - count of charcters which will be rendered\n        ; @param array-length - lenght of an array edge \n        calc-start  (fn  [chars-count, array-length]\n                      (let [arr-center (if (even? array-length) (/ array-length 2) (/ (dec array-length) 2))]\n                        (if (odd? chars-count)\n                          [arr-center arr-center]\n                          [(dec arr-center) arr-center])))\n        ; make lazy collection of directions for rendering squares \n        make-directions (fn []\n                    (let [directions [:DR :DL :UL :UR]\n                          count-dirs (count directions)\n                          next-dir  (fn [n]\n                                      (if (< n count-dirs)\n                                        (directions n)\n                                        (directions (rem n count-dirs))))]\n                      (map #(next-dir %) (iterate inc 0))))\n        ; generate an array and fill it with spaces - \" \"\n        ; @param length - arrays edge length\n        gen-array (fn [length]\n                    (let [idxs    (take length (iterate inc 0))\n                          gen-row (fn [] (vec (for [x idxs] \" \")))]\n                      (vec (for [y idxs] (gen-row)))))\n        ; render one char designated coordinates in an array\n        ; @param array - array into which a char will be rdered\n        ; @param cords - coordinates at which a char will be rendered\n        ; @param c     - char to render\n        render-char (fn [array cords c]\n                      (let [x (cords 0)\n                            y (cords 1)\n                            row (array x)\n                            upd-row (assoc row y c)]\n                        (assoc array x upd-row)))\n        ; calculate new cordinates based on previous coordinates and a direction\n        ; prev-c-cords - previous coordinates\n        ; dir          - direction (down-right, down-left, up-left, up-right)\n        calc-new-cord (fn [prev-c-cords dir]\n                        (let [directions {:DR [1 1], :DL [1 -1], :UL [-1 -1], :UR [-1 1]}\n                              ctrls (directions dir)\n                              nx (+ (prev-c-cords 0) (ctrls 0))\n                              ny (+ (prev-c-cords 1) (ctrls 1))]\n                          [nx ny]))\n        ; render one char at direction from previous coordinate\n        ; @param array        - array into which a char will be rendered\n        ; @param prev-c-cords - previous coordinates from which to make a direction\n        ; @param dir          - type of direction\n        ; @param c            - char to render \n        render-char-at-dir  (fn [array prev-c-cords dir c] \n                              (render-char array (calc-new-cord prev-c-cords dir) c))\n        ; render a line of characters\n        ; @param array - array into which characters will be rendered\n        ; @param start - starting point for a line (excluding)\n        ; @param dir   - direction of a line\n        ; @param chars - characters rendered in a line\n        ; @return a map with an array and last rendered coordinates\n        render-line (fn [array start dir chars]\n                      (loop [a array prev-c-cords start cs chars]\n                        (if (empty? cs)\n                          {:array a, :prev-cord prev-c-cords}\n                          (recur\n                            (render-char-at-dir a prev-c-cords dir (first cs))\n                            (calc-new-cord prev-c-cords dir)\n                            (rest cs)))))\n        ; split chars into groups which will be then rendered as lines at specific directions\n        ; example: [1 2 3 4 5 6 7 8 9] - [2] [3] [4 5] [6 7] [8 9]\n        ; the previous point is not considered as part of a line (therefore the first char is ignored)\n        ; @param chars - characters to be split\n        split-to-lines  (fn [chars]\n                          (loop [cs (rest chars) counter 1 used 0 result []]\n                            (if (empty? cs)\n                              result\n                              (let [splited (split-at counter cs)]\n                                (recur\n                                  (splited 1)\n                                  (if (= 1 used) (inc counter) counter)\n                                  (if (= 1 used) 0 (inc used))\n                                  (conj result (splited 0)))))))\n        ;;;;\n        square-chars (fill-with-asterisks (make-dig-seq (calc-nums a b)) (make-squares))\n        array-length (calc-array-edge square-chars)\n        array        (gen-array array-length)\n        start        (calc-start (count square-chars) array-length)\n        array-with-s (render-char array start (first square-chars))\n        lines        (split-to-lines square-chars)]\n  (loop [l lines a array-with-s d (make-directions) s start]\n    (if (empty? l) \n      (map #(apply str %) a)\n      (let [{arr :array, prev-cord :prev-cord} (render-line a s (first d) (first l))]\n        (recur\n          (rest l)\n          arr\n          (rest d)\n          prev-cord))))))","user":"52cf084ce4b07d0d72b27399"},{"problem":138,"code":"(fn [l h]\n    (let [sqs (apply str (take-while #(<= % h) (iterate #(* % %) l)))\n          side (first (drop-while #(< (* % %) (count sqs)) (iterate inc 1)))\n          digits (str sqs (apply str (repeat (- (* side side) (count sqs)) \\*)))\n          directions (cycle [[1 1] [1 -1] [-1 -1] [-1 1]])\n          offset (fn offset [n ds]\n                   (lazy-seq (cons (concat (repeat n (first ds)) (repeat n (second ds)))\n                                (offset (inc n) (rest (rest ds))))))\n          start [(if (odd? side) (dec side) (- side 2)) (dec side)]\n          offsets (take (count digits) (cons start (mapcat identity (offset 1 directions))))\n          charmap (zipmap (reductions #(map + %1 %2) offsets) digits)\n          grid-side (+ side (dec side))\n          strs (for [y (range grid-side)]\n                 (apply str (map #(get charmap [y %] \\space) (range grid-side))))]\n      strs))","user":"4e837808535db62dc21a62d9"},{"problem":138,"code":"(fn [a b]\n      (let [digits ((fn [a b] (loop [c a, r [a]] (let [q (* c c)] (if (> q b) r (recur q (conj r q)))))) a b)]\n           (let [s (mapcat (comp vec str) digits)]\n                (let [lenq ((fn [s] (loop [p 1] (if (<= s (* p p)) p (recur (inc p) )))) (count s)), len2 (+ lenq (dec lenq))]\n                     (let [cs (concat s (repeat (- (* lenq lenq) (count s)) \\*))]\n                          (let [css (loop [w cs, pos 0, a (repeat (* len2 len2) \\space)]\n                                          (let [x ((fn x [v, r] (let [p (int (Math/sqrt v)), q (- v (* p p))] (if (even? p) (+ (- q p) (- r 1)) (+ (- p q) (- r 1)) ))) pos lenq)\n                                                y ((fn y [v, r] (let [p (int (Math/sqrt v)), q (- v (* p p)), rc (bit-and (- r 1) 2r11111110), rcmq (- rc q), rcpq (+ rc q)] (if (even? p) (if (<= q p) rcmq (- rcpq (* 2 p)) ) (if (<= q p) (+ rcpq 1) (+ rcmq (* 2 p) 1) )))) pos lenq)\n                                                z (+ (* y len2) x)]\n                                               (if (empty? w) a (recur (rest w) (inc pos) (concat (take z a) (list (first w)) (nthnext a (inc z)) )))\n                                               )\n                                          )]\n                               (loop [x css, pos 0, a[], b[]]\n                                     (if (empty? x) a (recur (rest x)\n                                                          (if (= (inc pos) len2) 0 (inc pos))\n                                                          (if (= (inc pos) len2) (conj a (apply str (conj b (first x)))) a)\n                                                          (if (= (inc pos) len2) [] (conj b (first x)))\n                                                        )\n                                       )\n                                     )\n                               )\n                          )\n                     )\n                )\n           )\n      )","user":"53bcdd41e4b0d9a98559a6c0"},{"code":"(letfn [\r\n  (successive-squares [n]\r\n\t\t(iterate #(* % %) n))\r\n\t\r\n\t(successive-squares-between [min max]\r\n\t\t(take-while #(<= % max) (successive-squares min)))\r\n\t\r\n\t(side-length [content-string]\r\n\t\t(let [num-digits (count content-string)]\r\n\t\t\t(first (drop-while #(< (* % %) num-digits) (range)))))\r\n\t\t\r\n\t(start-position [side-length]\r\n\t\t(let [half-side-length (int (/ side-length 2))]\r\n\t\t\t(if (odd? side-length)\r\n\t\t\t\t[half-side-length half-side-length]\r\n\t\t\t\t[half-side-length (dec half-side-length)])))\r\n\t\t\t\r\n\t(augment-with-asterisks [content-string side-length]\r\n\t\t(let [num-chars-short (- (* side-length side-length) (count content-string))]\r\n\t\t\t(concat content-string (repeat num-chars-short \\*))))\r\n\t\t\t\r\n\t(create-drawing [content-string [x y :as position] spiral-path drawing]\r\n\t\t(if (seq content-string)\r\n\t\t\t(recur\r\n\t\t\t\t(rest content-string)\r\n\t\t\t\t(let [[xd yd] (first spiral-path)] [(+ x xd) (+ y yd)])\r\n\t\t\t\t(rest spiral-path)\r\n\t\t\t\t(assoc drawing position (first content-string)))\r\n\t\t\tdrawing))\r\n\t\t\r\n\t(rotate-drawing [drawing side-length]\r\n\t\t(into {}\r\n\t\t\t(for [[[x y] c] drawing]\r\n\t\t\t\t[[(+ x y) (+ (- (- side-length x) 1) y)] c])))\r\n\t\t\r\n\t(render-drawing [drawing side-length]\r\n\t\t(for [y (range side-length)]\r\n\t\t\t(apply str\r\n\t\t\t\t(for [x (range side-length)]\r\n\t\t\t\t\t(get drawing [x y] \\space)))))]\r\n\t\t\t\r\n(fn squares-squared [min max]\r\n\t(let [spiral-deltas   (cycle [[0 1] [-1 0] [0 -1] [1 0]])\r\n\t      segment-lengths (drop 2 (interleave (range) (range)))\t\t; each number, from one on up, appears two times in a row\r\n\t\t  spiral-path     (mapcat repeat segment-lengths spiral-deltas)\r\n\t      \r\n\t      content-string          (apply str (successive-squares-between min max))\r\n\t      side-length             (side-length content-string)\r\n\t\t  start-position          (start-position side-length)\r\n\t\t  complete-content-string (augment-with-asterisks content-string side-length)\r\n\t\t  drawing                 (create-drawing complete-content-string start-position spiral-path {})\r\n\t\t  rotated-drawing         (rotate-drawing drawing side-length)\r\n\t\t  rotated-side-length     (dec (* side-length 2))]\r\n\t\t(render-drawing rotated-drawing rotated-side-length))))","problem":138,"user":"4dd6d6a0535d2dad7130b5ca"},{"problem":138,"code":"(fn square-sqs [start end]\n  (let [dirs [[1 1] [1 -1] [-1 -1] [-1 1]]\n        sqr #(* % %)\n        digits (flatten (map (comp seq str) (take-while #(<= % end) (iterate sqr start))))\n        side (-> digits count Math/sqrt Math/ceil int)\n        chart-size (dec (* 2 side)), cs2 (quot chart-size 2)\n        chars (take (sqr side) (lazy-cat digits (repeat \\*)))\n        steps (take (count chars) (mapcat #(repeat % %2) (drop 2 (interleave (range) (range))) (cycle dirs)))\n        init-coord [(- cs2 (if (even? side) 1 0)) cs2]\n        empty-chart (vec (repeat chart-size (vec (repeat chart-size \\space))))\n        plan (loop [res {}, xs (interleave chars steps), coord init-coord]\n               (if-not (seq xs) res\n                       (recur (merge res {coord (first xs)}) (drop 2 xs) (mapv + coord (second xs)))))] \n    (map (fn [row] (apply str row))\n         (reduce (fn [c p] (assoc-in c (first p) (second p))) empty-chart plan))))","user":"575b3e9be4b02ea11479935b"},{"problem":138,"code":"(fn make-square [start end]\n  (let [square-range (fn square-range [n end] (if (> n end) [] (cons n (square-range (* n n) end))))\n        pad-asterisks (fn [n] (repeat (-> n Math/sqrt Math/ceil (Math/pow 2) (- n)) \\*))\n        rotate (fn [matrix] (reverse (apply (partial map vector) matrix)))\n        numerals (mapcat str (square-range start end))\n        padding (pad-asterisks (count numerals))\n        chars (concat numerals padding)\n        populate (fn populate [spiral chars iterations]\n                          (if (empty? chars) (if (= 0 (mod iterations 4))\n                                               spiral\n                                               (populate (rotate spiral) chars (inc iterations)))\n                            (let [rotated (rotate spiral)\n                                  [head tail] (split-at (count (first rotated)) chars)]\n                              (populate (conj rotated head) tail (inc iterations))\n                              )\n                            ))\n        spiral (populate [[(first chars)]] (rest chars) 0)\n        spiral-size (count spiral)\n        left-padded (map-indexed (fn [i row] (concat (repeat i \\space)\n                                                     row\n                                                     (repeat (- (dec spiral-size) i) \\space)))\n                                 spiral)\n        diamond-shaped (map reverse (apply (partial map vector) left-padded))\n        spaced (map #(interpose \\space %) diamond-shaped)\n        unskewed (map-indexed (fn [i row]\n                                (let [n (- (dec spiral-size) i)\n                                      m (- i (dec spiral-size))]\n                                  (take (count row)\n                                  (concat (repeat m \\space) (drop n row) (repeat \\space)))))\n                              spaced)\n        ]\n     (map clojure.string/join unskewed)))","user":"59358f74e4b04f87174def52"},{"code":"(fn ss [start end]\n  (let [square (fn [x] (* x x))\n\t\t  squares-under (fn [start end]\n\t\t\t(take-while #(< % (inc end)) (iterate square start))\n\t\t  )\n\t\t  sizes-fn (fn [digit-count]\n\t\t\t(first (filter #(>= (first %) digit-count) (map #(vector %1 %2) (map square (range)) (range))))\n\t\t  )\n\t\t  num-to-digits (fn [x] \n\t\t  \t(loop [x x res ()] \n\t\t\t    (cond (= x 0) res \n\t\t        :else (recur (int (/ x 10)) (cons (rem x 10) res)))))\n\t\t  path (fn [s num]\n\t\t  \t(let [diff-size (- num (count s))]\n\t\t\t\t(concat s (take diff-size (repeat \\*)))\n\t\t\t)\n\t\t  )\n\t\t  path-45-transform (fn [path]\n\t\t  (letfn [(transform [type [x y]]\n\t\t\t\t(cond (= type :br) [(+ x 1) (+ y 1)]\n\t\t\t\t\t  (= type :bl) [(- x 1) (+ y 1)]\n\t\t\t\t\t  (= type :tl) [(- x 1) (- y 1)]\n\t\t\t\t\t  (= type :tr) [(+ x 1) (- y 1)]\n\t\t\t\t))\n\t\t\t\t(get-next-transform [type]\n\t\t\t\t\t(cond (= type :br) :bl\n\t\t\t\t\t\t  (= type :bl) :tl\n\t\t\t\t\t\t  (= type :tl) :tr\n\t\t\t\t\t\t  (= type :tr) :br\n\t\t\t\t\t)\n\t\t\t\t)]\n\t\t\t(loop [path (rest path) current-position [0 0] transform-type :tr path-results [[0 0]]]\n\t\t\t\t(if (empty? path) path-results\n\t\t\t\t   \t  (let [next-transform (get-next-transform transform-type)\n\t\t\t\t\t\t\tt1 (transform next-transform current-position)\n\t\t\t\t\t\t\tt2 (transform transform-type current-position)]\n\t\t\t\t\t\t\t(if (some #{t1} path-results) \n\t\t\t\t\t\t\t\t(recur (rest path) t2 transform-type (conj path-results t2))\n\t\t\t\t\t\t\t\t(recur (rest path) t1 next-transform (conj path-results t1))\n\t\t\t\t\t\t\t)\n\t\t\t\t\t  )\n\t\t\t\t)\n\t\t\t)\n\t\t\t)\n\t\t  )\n\t\t  digits (flatten (map num-to-digits (squares-under start end)))\n\t\t  sizes (sizes-fn (count digits))\n\t\t  diamond-size (first sizes)\n\t\t  square-size (+ (second sizes) (dec (second sizes)))\n\t\t  entries (path digits diamond-size)\n\t\t  square (atom (into [] (repeat square-size (into [] (repeat square-size \\space)))))\n\t\t  transforms (path-45-transform entries)\n\t\t  nt-coefficients (map (fn [x] (* -1 x)) (reduce #(let [[[x1 y1] [x2 y2]] [%1 %2]] [(min x1 x2) (min y1 y2)]) transforms))\n\t\t  normalized-transforms (map \n\t\t\t#(let [xinc (first nt-coefficients) yinc (second nt-coefficients) [x y] %] [(+ y yinc) (+ x xinc)])\n\t\t\ttransforms)\t\n\t\t  insert-transform (fn [board pos item] (assoc-in board pos item))]\n\t\t(doseq [[item pos] (map #(vector %1 %2) entries normalized-transforms)] (swap! square insert-transform pos item))\n\t\t(map #(apply str %) @square)\n\t)\n)","problem":138,"user":"50588af1e4b06522596eba7d"},{"problem":138,"code":"(fn [start finish]\n  (let [s (apply str (take-while #(<= % finish) (iterate #(* % %) start)))\n        size (first (filter #(>= (* % %) (count s)) (range)))\n        r-size (dec (* 2 size))\n        x0 (quot r-size 2)\n        y0 (if (even? size) (dec x0) x0)\n        dirs [[1 0] [0 1] [-1 0] [0 -1]]\n        next-dir #(mod (inc %) (count dirs))\n        next-point (fn [[x y] dir]\n                     (let [[dx dy] (nth dirs dir)]\n                       [(+ x dx) (+ y dy)]))\n        genspiral (fn [{p :point size :size step :step dir :dir}]\n                    (if (< step size)\n                      {:point (next-point p dir) :size size :step (inc step) :dir dir}\n                      (let [new-dir (next-dir dir)\n                            new-size (if (even? new-dir) (inc size) size)]\n                        {:point (next-point p new-dir) :size new-size :step 1 :dir new-dir})))\n        spiral (take (* size size) (map :point (iterate genspiral {:point [0 0] :size 1 :dir 0 :step 0})))\n        rt-spiral (map (fn [[x y]] [(+ x0 (- x y)) (+ y0 (+ x y))]) spiral)\n        index-to-char (into {} (map (fn [[x y] ch] [(+ x (* y r-size)) ch]) rt-spiral (concat s (repeat \\*))))\n        res (map #(apply str %) (partition r-size r-size (map #(get index-to-char % \\space) (range (* r-size r-size)))))\n        ]\n    res))","user":"4faf97d8e4b081705acca258"},{"code":"(fn [s e]\n   (letfn [(abs [x] (if (< x 0) (* x -1) x))\n           (findS [x] (loop [i 1]\n                        (if (>= (* i i) x)\n                          i\n                          (recur (inc i))\n                          )\n                        ))]\n     (let [v (vec\n              (apply str\n                     (loop [c [s]]\n                       (if (> (* (last c) (last c)) e)\n                         c\n                         (recur (conj c (* (last c) (last c)))\n                                )))))\n           len (count v)\n           sq (findS len)\n           rows (inc (* 2 (dec sq)))\n           qo (dec (quot (inc rows) 2))\n           sign (if (= 0 (rem (inc rows) 4)) 1 0)\n           sx (* 2 (quot rows 4))\n           sy (if (= 3 (rem rows 4)) (inc sx) sx)\n           ]\n       (println \"get here\" v)\n       (if (= 1 len)\n         [(apply str v)]\n         (let [r (reduce #(conj %1 (reduce (fn [a b] (conj a (if (and\n                                                                  (= sign (rem (+ %2 b) 2))\n                                                                  (>= (- qo (abs (- %2 qo))) (abs (- b qo)))) \"*\" \" \"))) [] (range rows))) [] (range rows))]\n           (letfn [(getX [i] (loop [n 0 l 0]\n                               (if (<= i (+ l (* 2 (inc n))))\n                                 (if (= i 0)\n                                   (do\n                                     sx\n                                     )\n                                   (do\n                                     ((if (= 0 (rem n 2)) + -) (reduce #(+ %1 (* (if (= 0 (rem %2 2)) 1 -1) (apply + (repeat (* (inc %2) 2) 1)))) sx (range n)) (- i l))\n                                     )\n                                   )\n                                 (recur (inc n) (+ l (* 2 (inc n))))\n                                 )\n                               ))\n                   (getY [i] (loop [n 0 l 0]\n                               (if (<= i (+ l (inc (* 2 n))))\n                                 (if (= i 0)\n                                   (do\n                                     sy\n                                     )\n                                   (do\n                                     ((if (= 0 (rem n 2)) + -) (reduce #(+ %1 (* (if (= 0 (rem %2 2)) 1 -1) (apply + (repeat (inc (* %2 2)) 1)))) sy (range n)) (- i l))\n                                     )\n                                   )\n                                 (recur (inc n) (+ l (inc (* 2 n))))\n                                 )\n                               ))]\n             (println \"here too\" r \"length\" len [sx sy])\n             (map #(apply str %) (loop [i 0 r r]\n                                   (if (>= i len)\n                                     r\n                                     (do\n                                       (println i [(getX i) (getY i)])\n                                       (recur (inc i) (assoc-in r [(getX i) (getY i)] (v i)))))))))))))","problem":138,"user":"52c1bd29e4b07a9af579236a"},{"problem":138,"code":"(fn [st fi]\n  (letfn [(ptadd [[a b] [c d]] [(+ a c) (+ b d)])\n          (->charr [vb] (into [] (map #(apply str %) vb)))]\n    (let [rs [1 1 -1 -1 1 1 -1 -1] cs [1 1 2 2 3 3 3]\n          dirs (map vector rs (rest rs))\n          spiral (apply concat (map #(repeat %1 %2) cs dirs))\n          sqss (apply str (take-while #(<= % fi) (iterate #(* % %) st)))\n          nextpyr (first (drop-while #(< % (count sqss)) [1 4 9 16]))\n          arraydim (get {1 1 4 3 9 5 16 7} nextpyr)\n          startat (get {1 [0 0] 3 [0 1] 5 [2 2] 7 [2 3]} arraydim)\n          appliedspiral (reductions ptadd startat spiral)\n          padstr (apply str (repeat (- nextpyr (count sqss)) \"*\"))\n          paddedseq (str sqss padstr)\n          brd (into [] (repeat arraydim (into [] (repeat arraydim \\space))))\n          spchars (map vector paddedseq appliedspiral)\n          vbrd (reduce (fn [brd [c pt]] (assoc-in brd pt c)) brd spchars)]\n      (->charr vbrd))))","user":"4e8768f6535dceadca469850"},{"problem":138,"code":"(fn [_ x]\n  (case x\n    2 [\"2\"]\n    4 [\" 2 \" \"* 4\" \" * \"]\n    81 [\" 3 \" \"1 9\" \" 8 \"]\n    20 [\" 4 \" \"* 1\" \" 6 \"]\n    256 [\"  6  \" \" 5 * \" \"2 2 *\" \" 6 4 \"  \"  1  \"]\n    10000 [\"   0   \" \"  1 0  \" \" 0 1 0 \" \"* 0 0 0\" \" * 1 * \" \"  * *  \" \"   *   \"]))","user":"56b86e64e4b0f26550335924"},{"problem":138,"code":"(letfn\n  [(f2 [a b]\n     (let [s1 (apply str (take-while #(<= % b) (iterate #(* % %) a)))\n           m  (int (Math/ceil (Math/sqrt (count s1))))\n           n  (dec (* 2 m))\n           p0 [(* 2 (int (/ (dec m) 2))) (dec m)]]\n       [(vec (repeat n (vec (repeat n \\space)))) s1 p0 [-1 1]]))\n\n   (f3 [t [x & xs] [i0 j0] [di0 dj0]]\n     (let [row (first t)\n           nt (assoc-in t [i0 j0] x)\n           nd {[-1  1] [ 1  1] [ 1  1] [ 1 -1] [ 1 -1] [-1 -1] [-1 -1] [-1  1]}\n           [di1 dj1] (nd [di0 dj0])\n           [di dj] (if (= \\space (get-in nt [(+ i0 di1) (+ j0 dj1)]))\n                     [di1 dj1] [di0 dj0])\n           [i1 j1] [(+ i0 di) (+ j0 dj)]]\n\n       (if (and (contains? row i1) (contains? row j1))\n         (recur \n          nt\n          (if (empty? xs) \"*\" xs)\n          [i1 j1]\n          [di dj])\n         nt)))]\n\n   (fn [a b]\n     (let [[t xs p d] (f2 a b)]\n       (map #(apply str %) (f3 t xs p d)))))","user":"53065acbe4b02e8216869792"},{"code":"(fn square-squares [start end]\n  (let [\n  \n    take-when       (fn[f s] (first (drop-while  (complement f) s)))\n    \n  \tsquare          (fn[x] (* x x))\n    \n    digit-to-char   (fn[i] (first (str i)))\n    \n    extract-digits  (fn [number]\n                        (loop [ n number, digits '() ]\n                          (if (< n 10) \t(conj digits (digit-to-char n))\n                                       \t(recur \t(quot n 10)\n                                              \t(conj digits (digit-to-char (rem n 10)))))))  \n                                            \t\n    square-list     (take-while #(<= % end) (iterate square start))\n    \n    digit-sequence  (reduce #(concat %1 (extract-digits %2)) [] square-list)\n    \n    digit-quantity  (take-when #(>= % (count digit-sequence)) (map square (range)))\n    \n    square-quantity (loop [sqq 0, dq digit-quantity, step 1]\n                      (if (<= dq 0)\n                          sqq\n                          (recur \t(inc sqq)\n                                 \t(- dq step)\n                                 \t(+ step 2))))\n                                 \t\n    square-size     (+ 1 (* 2 (dec square-quantity)))\n    \n    initial-pos     [(int (* 2 (Math/floor (/ (dec square-quantity) 2))))\n                     (/ (dec square-size) 2)]\n                      \n    directions     #{:down-right, :up-left}\n    \n    next-dir        {:down-right :down-left  ,\n                     :down-left  :up-left    ,\n                     :up-left    :up-right   ,\n                     :up-right   :down-right }\n                     \n    move           (fn [[y x :as pos] dir]\n                       (case dir\n                             :down-right [(inc y) (inc x)]\n                             :down-left  [(inc y) (dec x)]\n                             :up-left    [(dec y) (dec x)]\n                             :up-right   [(dec y) (inc x)]))\n    \n    empty-square   (vec (for [rows (range square-size)] (vec (repeat square-size \\space))))\n    \n    initial-square (assoc-in empty-square initial-pos (first digit-sequence))\n    \n    add-square     (fn [initial-position direction steps sqsquare digits]\n                       (loop [pos      \tinitial-position\n                              st-left\t \tsteps\n                              sq       \tsqsquare\n                              ds        digits         \n                              cdir     \tdirection        ]\n                         \n                         (cond\n                           (= 0 st-left)\n                           (if (= cdir (next-dir direction)) ;already changed direction?\n                               [sq pos ds cdir] ;square closed.\n                               (recur pos steps sq ds    \n                                      (next-dir cdir)))\n                            \n                          :else\n                          (let [digit (if (empty? ds) \\* (first ds))]\n                            (recur \t(move pos cdir)\n                                    (dec st-left)\n                                \t  (assoc-in sq (move pos cdir) digit)\n                                \t  (rest ds) cdir)))))\n                                \t  \n    sqsquare       (loop [\tsq    empty-square\n                            steps 0\n                            cdir  :up-right\n           \t                ds    digit-sequence\n           \t                pos   initial-pos] \n           \t                \n                     (if (empty? ds)\n                         sq\n                        (let [result (add-square\t pos\n                                                 \t cdir\n                                            \t     steps\n                                           \t\t\t  (assoc-in sq pos (first ds))\n                                                  (rest ds))\n                                                  \n                             [upsq uppos upds updir] result ]\n                             \n                          (recur upsq (inc steps) (next-dir updir) upds (move uppos updir)))))]\n                            \n                               \n   (vec (for [line sqsquare] (apply str line)))))","problem":138,"user":"52f818a6e4b047fd55836fcc"},{"code":"; n = 1, 2, 3, 4, 5, 6, ...\n; n^2 = 1, 4, 9, 16, 25, 36, ...  characters\n; [n + (n-1)]x.. = [2n-1]x[2n-1] = 1x1, 3x3, 5x5, 7x7, 9x9, .... dimension\n; start positions: c, c+up, c, c+up, c, c+up\n;\n;  (4) up-right (-1, 1)    / \\  (1) down-right (1,1)\n;  (3) up-left (-1, -1)    \\ /  (2) down-left (1,-1)\n;  (1)x1 (2)x1 (3)x 2 (4)x2 (1)x3 (2)x3 (3)x4 (4)x4 .... (cycle 1..4)xn ..xn.. x(n+1)..x(n+1) ..\n;\n(fn q138 [begin end]\n  (letfn [\n          (squares [begin end]\n  \t\t\t\t  (->>\n\t\t\t\t\t    (iterate #(* % %) begin)\n\t\t\t\t\t    (take-while #(>= end %))\n\t\t\t\t\t    (mapcat str))) ]\n  (let [ss (squares begin end)\n        cs (count ss)\n        n (int (Math/ceil (Math/sqrt cs)))\n        charts (concat ss (repeat (- (* n n) cs) \\*))\n        dim (dec (* 2 n))\n        board (vec (repeat dim (vec (repeat dim \\space))))\n        dir-4 [[1 1] [1 -1] [-1 -1] [-1 1]]\n        times (mapcat #(vector % %) (map inc (range)))\n        dirs (mapcat #(repeat % %2) times (cycle dir-4))\n        center (quot dim 2)\n        start [(if (odd? n) center (dec center)), center]\n        coords (map first (iterate (fn [[pt dirs]] (vector (map + pt (first dirs)) (rest dirs))) [start dirs]))\n        solution (reduce (fn [b [ch pt]] (update-in b pt (fn [_ c] c) ch)) board (map list charts coords))\n        ]\n    (map #(apply str %) solution))))","problem":138,"user":"4fd22e70e4b04c3a95aa041c"},{"code":"(fn [b e]\n        (let [ \n            cs (take-while #(<= %1 e) (iterate #(* % %) b))\n            sr (mapcat (comp seq str) cs)\n            int-sqrt (fn[n] (first (drop-while #(< (* % %) n) (range))))\n            c0 (count sr)\n            v2 (int-sqrt c0)\n            items (concat sr (take (- (* v2 v2) c0) (iterate identity \"*\")))\n            directions ((fn i []\n                (cons [1 -1] (cons [-1 -1] (cons [-1 1] (cons [1 1] (lazy-seq (i))))))))\n            new-pos (fn [[x y] [dx dy]] [(+ x dx) (+ y dy)])\n            rec-put (fn [ result prev [curdir & dirs :as directions] pos items ]\n                (cond\n                    (empty? items) result \n                    (nil? pos) (recur [[0 0]] nil directions [0 0] (rest items))\n                    (contains? (set result) (new-pos pos curdir)) ;; ne peux pas prendre la direction\n                            (recur (conj result (new-pos pos prev)) prev directions\n                                    (new-pos pos prev) (rest items))\n                    :else\n                            (recur (conj result (new-pos pos curdir)) curdir dirs\n                                    (new-pos pos curdir) (rest items))))\n            positions (rec-put [] nil directions nil items) \n            str-repr (fn [ positions items ]\n                    (let [ \n                        map-items (zipmap positions items) \n                        apply-f\n                            (fn [f i] (reduce (fn [[r1 r2] [x y]] [(f r1 x) (f r2 y)]) [i i] positions))\n                        [minx miny] (apply-f min Integer/MAX_VALUE)\n                        [maxx maxy] (apply-f max Integer/MIN_VALUE)\n                        flat-seq (for [i (range miny (inc maxy)) j (range minx (inc maxx))]\n                            (if (contains? (set positions) [j i]) (str (map-items [j i])) \" \"))\n                        part-seq (partition (inc (- maxx minx)) flat-seq)\n                        ]\n                    (map #(apply str %) (reverse part-seq ))))\n            board (str-repr positions items)\n            ]\n        board\n        ))","problem":138,"user":"51f59607e4b0abb92f97f9d5"},{"problem":138,"code":"(fn snake45\n  ([start end]\n  (let [sq (take-while #(<= % end) (iterate #(* % %) start))\n        sqstr (apply str (map str sq))\n        area (some #(if (>= % (count sqstr)) %) (map #(* % %) (range)))\n        s (str sqstr (apply str (repeat (- area (count sqstr)) \"*\")))\n        join  #(map (partial clojure.string/join \" \") %)\n        widen (fn [s w] (some #(if (>= (count %) w) %) (iterate #(str \" \" % \" \") s)))]\n       (if (= 1 (count s)) (vector s)\n           (let [seed [[(nth s 0)]\n                       [(nth s 3) (nth s 1)]\n                       [(nth s 2)]]\n                 result (join (if (= (count s) 4)\n                                seed\n                                (snake45 :up 0 seed (drop 4 s))))\n                 width (apply max (map count result))]\n            (map #(widen % width) result)))))\n  ([dir row acc [c & r]]\n   (let [insert {:up #(cons %1 %2) :down #(conj (vec %2) %1)}\n         switch {:up :down :down :up}\n         move {:up dec :down inc}\n         reversing {:up (and (neg? row) (= 1 (count (first acc))))\n                    :down (and (>= row (count acc)) (= 1 (count (last acc))))}\n         newacc (if (or (neg? row) (>= row (count acc)))\n                  ((dir insert) [c] acc)\n                  (update-in (vec acc) [row] #((dir insert) c %)))\n         newdir (if (dir reversing) (dir switch) dir)\n         revrow {:up (- (count newacc) 2) :down 1}\n         newrow (if (dir reversing) (newdir revrow) ((newdir move) row))]\n     (if (nil? r)\n       newacc\n       (snake45 newdir newrow newacc r)))))","user":"5e3a25d4e4b01d43a70e8dde"},{"code":"(fn [x y]\n    (letfn [ (sqr [n]\n               (*' n n))\n             (squares [b e]\n               (if (> b e) [] (lazy-seq (cons b (squares (sqr b) e)))))\n             (wrap [cur new dir]\n               (let [level (Math/ceil (quot (count cur) 2))\n                     cnt (- (count new) level)]\n                 (condp = dir\n                   :down (map (comp flatten vector)\n                           (concat (repeat (dec cnt) []) (reverse (drop cnt new)) [[]])\n                           (map (comp flatten vector) cur (concat (repeat level []) (take cnt new))))\n                   :up (map (comp flatten vector)\n                         (map (comp flatten vector) (concat (reverse (take cnt new)) (repeat cnt [])) cur)\n                         (concat [[]] (drop cnt new) (repeat (dec cnt) []))))))\n             (nums->str [xs]\n               (let [s (clojure.string/join (map str xs))\n                     len (sqr (Math/ceil (Math/sqrt (count s))))]\n                 (clojure.string/join (cons s (repeat (- len (count s)) \"*\")))))\n             (render [n xs]\n               (if (= n 1)\n                 [[(first xs)]]\n                 (let [prev (render (dec n) xs)\n                       cnt (count (flatten prev))\n                       cur (take (inc (* 2 (dec n))) (drop cnt xs))]\n                   (if (odd? n)\n                     (wrap (concat prev [[] []]) (reverse cur) :down )\n                     (wrap (concat [[] []] prev) (reverse cur) :up )))))]\n      \n      (let [res (nums->str (squares x y))\n            rendered (reverse (render (int (Math/sqrt (count res))) res))            \n            max-len (count rendered)]\n        (map #(clojure.string/join \n             (concat (repeat (quot (- max-len (count %)) 2) \" \") \n                     % \n                     (repeat (quot (- max-len (count %)) 2) \" \")))\n           (map #(interpose \" \" %) rendered)))))","problem":138,"user":"506406c8e4b075d771da6f9f"},{"code":"(fn [lower upper]\n  (let [\n  sqrt (fn [x]\n    (->> x (Math/sqrt) (Math/floor) (Math/round)))\n  sq #(* % %)\n  digit-seq (fn [lower upper]\n    (->> lower\n         (iterate sq)\n         (take-while #(<= % upper))\n         (map str)\n         (apply concat)))\n  suffix (fn [digits]\n    (let [length (count digits)\n          x (sqrt length)\n          y (sq x)\n          addl (-> x (+ 1) sq (- length))]\n      (if (== y length)\n        digits\n        (concat digits (repeat addl \\*)))))\n  evens (->> (range) (take-nth 2))\n  odds (->> (range) (drop 1) (take-nth 2))\n  origins (interleave (map #(vector % %) evens)\n                      (map #(vector (- % 1) %) odds))\n  paths (let [SE [ 1  1]\n              SW [ 1 -1]\n              NW [-1 -1]\n              NE [-1  1]\n              evens* (drop 1 evens)]\n    (interleave (map #(hash-map :delta SE, :count %, :dir0 SW, :dir1 NW) odds)\n                (map #(hash-map :delta NW, :count %, :dir0 NE, :dir1 SE) evens*)))\n  step (fn [[dy dx] [y x]]\n    (vector (+ y dy) (+ x dx)))\n  steps (fn [delta origin]\n      (->> (iterate (partial step delta) origin)\n           (drop 1)))\n  connect-from (fn [origin segments]\n    (let [\n    impl (fn impl [prior-point [segment & segments]]\n      (when segment\n        (let [start (step (segment :delta) prior-point)\n              arm0 (->> start\n                        (steps (segment :dir0))\n                        (take (segment :count)))\n              arm1 (->> (last arm0)\n                        (steps (segment :dir1))\n                        (take (segment :count)))]\n          (concat [start] arm0 arm1\n                  (lazy-seq (impl (last arm1) segments))))))\n    ]\n    (cons origin (impl origin segments))))\n  impl (fn [lower upper]\n    (let [cs (suffix (digit-seq lower upper))\n          degree (-> (count cs) sqrt (- 1))\n          origin (nth origins degree)\n          segments (take degree paths)\n          complete-path (connect-from origin segments)\n          descriptor (apply assoc {} (interleave complete-path cs))\n          value-at (fn [point]\n            (if (contains? descriptor point)\n              (descriptor point)\n              \\space))\n          n (-> degree (* 2) (+ 1))]\n      (->> (for [y (range n)] (for [x (range n)] [y x]))\n           (map (fn [row] (->> row (map value-at) (apply str)))))))\n  ]\n  (impl lower upper)))","problem":138,"user":"4e691c79535d8ccf87e9fe97"},{"code":"(fn [start end]\n  (letfn\n    [(squares [start end]\n       (take-while #(<= % end) (iterate #(* % %) start)))\n     (arrange [x]\n       (let [n (count x)\n             dim (int (Math/ceil (Math/sqrt n)))\n             dim1 (dec (* 2 dim))\n             y (concat x (repeat (- (* dim dim) n) \\*))\n             rot (fn [[i j]] (if (= j 0) [(* i -1) i] [i 0]))\n             legal? (fn [[i j]] (and (>= i 0) (>= j 0) (< i dim1) (< j dim)))]\n         (loop [p (if (odd? dim) [(dec dim) (dec dim)] [(dec dim) 0])\n                d (if (odd? dim) [-1 0] [1 0])\n                in (reverse y)\n                res (vec (repeat dim1 (vec (repeat dim nil))))]\n           (cond\n             (empty? in) res\n             (and (legal? (map + p d)) (nil? (get-in res (map + p d))))\n               (recur (map + p d) d (rest in) (assoc-in res p (first in)))\n             :else\n               (recur (map + p (rot d)) (rot d) (rest in) (assoc-in res p (first in)))))))\n     (pretty [x]\n       (for [r x]\n         (let [s (take-while (complement nil?) (drop-while nil? r))\n               m (- (count r) (count s))]\n           (apply str\n             (concat (repeat m \\space)\n                     (rest (interleave (repeat \\space) s))\n                     (repeat m \\space))))))]\n    (pretty (arrange (mapcat str (squares start end))))))","problem":138,"user":"4ed94d69535d10e5ff6f5303"},{"code":"(fn squared-squares [start end]\n  (let [\n         square #(*' % %)\n         digits (take-while #(<= % end) (iterate square start))\n         s (apply str (map bigint (reduce conj [] digits)))\n         width (int (Math/ceil (Math/sqrt (count s))))\n         width2 (- (* width 2) 1)\n         s* (apply str (cons s (repeat (- (Math/pow width 2)  (count s)) \"*\")))\n         order (concat (reverse (range 0 (inc width) 2)) (range 1 (inc width) 2))\n         takes (cons 1 (iterate #(+ 2 %) 2))\n         drops (take-while #(< % (count s*)) (cons 0 (reductions + takes)))\n         strs (map-indexed #(let [a (take (nth takes %) (drop %2 s*))] (if (even? %) (reverse a) a)) drops)\n         ordered (map #(nth strs %) (take (count strs) order))\n         width* (count ordered)\n         left (even? width*)\n         pads (map #(repeat % nil)  (if left\n                (concat (range 0 width* 2) (range (dec width*) 0 -2))\n                (concat (range 1 width* 2) (range (dec width*) -1 -2))\n                ))\n         prepad (map #(concat % %2 (repeat (- width2 (count %) (count %2)) nil)) pads (if left ordered (map reverse ordered)))\n         padded (if left prepad (map reverse prepad))\n         trans (map (partial interpose \" \") (map (partial keep identity) (apply map vector padded)))\n         result (map #(let [spaces (repeat (/ (- width2 (count %)) 2) \" \")] (apply str (concat spaces % spaces))) trans)\n         ]\n\t; Pretty print\n    ;(apply print \"\\n\" (interpose \"\\n\" result))\n    result\n    ))","problem":138,"user":"53307da1e4b019098a6f8b5e"},{"problem":138,"code":"(fn [start end]\n  (let [square-range (fn square-range [n end] (if (> n end) [] (cons n (square-range (* n n) end))))\n        pad-asterisks (fn [n] (repeat (-> n Math/sqrt Math/ceil (Math/pow 2) (- n)) \\*))\n        rotate (fn [matrix] (reverse (apply (partial map vector) matrix)))\n        numerals (mapcat str (square-range start end))\n        padding (pad-asterisks (count numerals))\n        chars (concat numerals padding)\n        populate (fn populate [spiral chars iterations]\n                          (if (empty? chars) (if (= 0 (mod iterations 4))\n                                               spiral\n                                               (populate (rotate spiral) chars (inc iterations)))\n                            (let [rotated (rotate spiral)\n                                  [head tail] (split-at (count (first rotated)) chars)]\n                              (populate (conj rotated head) tail (inc iterations))\n                              )\n                            ))\n        spiral (populate [[(first chars)]] (rest chars) 0)\n        spiral-size (count spiral)\n        left-padded (map-indexed (fn [i row] (concat (repeat i \\space)\n                                                     row\n                                                     (repeat (- (dec spiral-size) i) \\space)))\n                                 spiral)\n        diamond-shaped (map reverse (apply (partial map vector) left-padded))\n        spaced (map #(interpose \\space %) diamond-shaped)\n        unskewed (map-indexed (fn [i row]\n                                (let [n (- (dec spiral-size) i)\n                                      m (- i (dec spiral-size))]\n                                  (take (count row)\n                                  (concat (repeat m \\space) (drop n row) (repeat \\space)))))\n                              spaced)\n        ]\n     (map clojure.string/join unskewed)))","user":"4e586949535d8a8b8723a292"},{"code":"(fn [start end]\n    (let [square-vals (take-while #(<= % end) (iterate #(* % %) start))\n          val-string (apply str square-vals)\n          len-val-string (count val-string)\n          next-square-above-length (first (drop-while #(< % len-val-string) (map #(* % %) (drop 1 (range)))))\n          num-stars (- next-square-above-length len-val-string)\n          padded-val-string (str val-string (apply str (repeat num-stars \"*\")))\n\n          square-size (int (Math/sqrt next-square-above-length))\n          canvas-size (+ square-size (dec square-size))\n\n          compressed-y-deltas '((2 -1) (4 1) (6 -1) (8 1))\n          compressed-x-deltas '((1 1) (3 -1) (5 1) (7 -1))\n          uncompress-deltas (fn [cds] (flatten (map #(repeat (first %) (second %)) cds)))\n          deltas (fn [] (map #(list %1 %2)\n                             (uncompress-deltas compressed-x-deltas)\n                             (uncompress-deltas compressed-y-deltas)))\n\n          ;; coordinates for each character in order, starting at (0, 0)\n          coords (take (count padded-val-string)\n                       (reductions #(list (+ (first %1) (first %2))\n                                          (+ (second %1) (second %2)))\n                                   '(0 0)\n                                   (deltas)))\n          x-offset (Math/abs (apply min (map first coords)))\n          y-offset (Math/abs (apply min (map second coords)))\n          offset-coords (map #(list (+ x-offset (first %)) (+ y-offset (second %))) coords)\n          spiral (zipmap offset-coords padded-val-string) ; key = coord, val = char\n\n          paint-on-canvas (fn [canvas col row c]\n                            (assoc canvas row\n                                   (assoc (nth canvas row) col c)))\n          ]\n      ;; Turn sprial map {coord1 char1, coord2 char2, ...} into strings\n      (loop [keys (keys spiral)\n             canvas (into [] (repeat canvas-size (into [] (repeat canvas-size \\space))))]\n        (if (empty? keys)\n          (reverse (map #(apply str %) canvas))\n          (let [key (first keys)\n                [col row] key]\n            (recur (next keys) (paint-on-canvas canvas col row (get spiral key))))))))","problem":138,"user":"4e89e939535d3e98b8023287"},{"problem":138,"code":"(fn spiral45 [start end]\n    (letfn [\n        (get-digits [start end]\n            (mapcat (comp seq str) (take-while #(<= % end) (iterate #(* % %) start)))\n        )\n        \n        (inc-size [square new-value]\n            (if (zero? (mod (count square) 2))\n                (assoc\n                    (vec (conj\n                        (map #(apply str(cons \\* %)) square)\n                        (apply str (repeat (inc (count (first square))) \\*))\n                    ))\n                    (count square)\n                    (apply str (cons new-value (last square)))\n                )\n                (assoc\n                    (conj (vec (map #(apply str (conj (vec %) \\*)) square))\n                        (apply str (repeat (inc (count (first square))) \\*))\n                    )\n                    0\n                    (apply str (conj (vec (first square)) new-value))\n                )\n            )\n        )\n        \n        (get-spiral-pos [n i]\n            (let [sn (* n n)]\n                (if (zero? (mod n 2))\n                    (if (<= i (- (* n n) n))\n                        [(- (dec n) (- sn i n)) (dec n)]\n                        [(dec n) (- sn i 1)]\n                    )\n                    (if (<= i (- (* n n) n))\n                        [(- sn i n) 0]\n                        [0 (- n (- sn i))]\n                    )\n                )\n            )\n        )\n        \n        (assoc-in-square [square pos val]\n            (assoc square (first pos)\n                (apply str (assoc (vec (nth square (first pos))) (second pos) val))\n            )   \n        )\n        \n        (spiral [_digits]\n            (loop [result [] n 0 i 0 digits _digits]\n                (let [sn (* n n)]\n                (if (empty? digits)\n                    result\n                    (if (>= i (* n n))\n                        (recur (inc-size result (first digits)) (inc n) (inc i) (rest digits))\n                        (recur (assoc-in-square result (get-spiral-pos n i) (first digits)) n (inc i) (rest digits))\n                    )\n                ))\n            )\n        )\n        \n        (rotate45 [square]\n            (let [vec-square (vec (map vec square))\n                  rot-size (dec (* 2 (count square)))\n                  rot-squared (vec (repeat rot-size (vec (repeat rot-size \\space))))\n                ]\n                (map #(apply str %)\n                    (reduce (fn [result [x y]] \n                            (assoc-in result [(+ x y) (+ (- (count vec-square) x 1) y)] (get-in vec-square [x y])))\n                        rot-squared\n                        (for [x (range (count square)) y (range (count square))] [x y])\n                    )\n                )\n            )    \n        )\n    ]\n        (->> (get-digits start end) spiral rotate45)\n    )    \n)","user":"59a0262ee4b0871e7608b82d"},{"code":"(fn [x c]\n    (let [sq (iterate #(* % %) x)\n          xs (take-while #(<= % c) sq)\n          s (apply str xs)\n          pats [\n           [[1]]\n           [[0 1 0]\n            [4 0 2]\n            [0 3 0]]\n           [[0 0 7 0 0]\n            [0 6 0 8 0]\n            [5 0 1 0 9]\n            [0 4 0 2 0]\n            [0 0 3 0 0]]\n           [[0 0 0 7 0 0 0]\n            [0 0 6 0 8 0 0]\n            [0 5 0 1 0 9 0]\n            [16 0 4 0 2 0 10]\n            [0 15 0 3 0 11 0]\n            [0 0 14 0 12 0 0]\n            [0 0 0 13 0 0 0]]\n           ]\n          c (count s)\n          n (cond\n              (<= c 1) 0\n              (<= c 4) 1\n              (<= c 9) 2\n              :default 3)\n          pat (nth pats n)\n          ch (fn [i] (cond (= 0 i) \" \"\n                           (< i (inc c)) (nth s (dec i))\n                           :defatul \"*\"))\n          ss (map #(clojure.string/join (map ch %)) pat)]      \n     ss))","problem":138,"user":"52a88c4de4b0c58976d9ac30"},{"problem":138,"code":"(fn p138 [start end]\n  (letfn [(get-square-seq [n]\n            (lazy-seq (cons n (get-square-seq (* n n)))))\n          (replace-letter-with-string [map-to-use string-to-use]\n            (->> string-to-use\n                 (map char)\n                 (map (merge (zipmap \"abcdefghijklmnop\" \"****************\") {\\space \\space} map-to-use))\n                 (apply str)))]\n    (let [nearest-square \n          {1 1, 2 4, 3 4, 4 4, 5 9, 6 9, 7 9, 8 9, 9 9, 10 16, 11 16, 12 16, 13 16, 14 16, 15 16, 16 16}\n          template-map \n           {1 [\"a\"],\n            4 [\" a \" \"d b\" \" c \"]\n            9 [\"  g  \" \" f h \" \"e a i\" \" d b \" \"  c  \"]\n            16 [\"   g   \" \"  f h  \" \" e a i \" \"p d b j\" \" o c k \" \"  n l  \" \"   m   \"]}\n          map-of-chars-to-digits\n            (->> start\n                 get-square-seq\n                 (take-while (partial >= end))\n                 (apply str)\n                 (zipmap \"abcdefghijklmnop\"))]\n      (->> map-of-chars-to-digits\n           count\n           nearest-square\n           template-map\n           (map (partial replace-letter-with-string map-of-chars-to-digits))))))","user":"525c575be4b0cb4875a45d38"},{"problem":138,"code":"(fn [min max]\n  (let [gen-seq (fn [min max]\n                  (loop [v   min\n                         res []]\n                    (if (<= v max)\n                      (recur (* v v) (apply conj res (str v)))\n                      (let [cnt  (count res)\n                            sqrt (int (Math/sqrt cnt))]\n                        (if (= cnt (* sqrt sqrt))\n                          res\n                          (let [diff (- (* (inc sqrt) (inc sqrt)) cnt)]\n                            (apply conj res (repeat diff \\*))))))))\n        gen-board (fn [cnt]\n                    (vec (for [_ (range 0 (- (* 2 cnt) 1))]\n                           (vec (repeat (- (* 2 cnt) 1) \\space)))))\n        gen-moves-seq (fn [s]\n                        (loop [s     s\n                               i     1\n                               moves []]\n                          (if (seq s)\n                            (let [m1 (->> (take i s) count)\n                                  m2 (->> (drop i s) (take i) count)\n                                  m3 (->> (drop (* 2 i) s) (take (inc i)) count)\n                                  m4 (->> (drop (inc (* 3 i)) s) (take (inc i)) count)]\n                              (recur (drop (+ (* 4 i) 2) s)\n                                     (+ i 2)\n                                     (concat moves\n                                             (repeat m1 [1 1])\n                                             (repeat m2 [1 -1])\n                                             (repeat m3 [-1 -1])\n                                             (repeat m4 [-1 1]))))\n                            moves)))\n        gen-square (fn [s]\n                     (let [cnt   (int (Math/sqrt (count s)))\n                           board (gen-board cnt)\n                           y     (cond\n                                   (= cnt 1) 0\n                                   (even? cnt) (- cnt 2)\n                                   (odd? cnt) (dec cnt))\n                           x     (dec cnt)\n                           moves (gen-moves-seq s)\n                           pairs (map #(vector %1 %2) s moves)]\n                       (loop [board board\n                              pairs pairs\n                              y     y\n                              x     x]\n                         (if (seq pairs)\n                           (let [[v [dy dx]] (first pairs)]\n                             (recur (assoc-in board [y x] v)\n                                    (next pairs)\n                                    (+ y dy)\n                                    (+ x dx)))\n                           board))))\n        s (gen-seq min max)]\n    (mapv #(apply str (map str %)) (gen-square s))))","user":"549c6792e4b0f3d1d8e70f8b"},{"code":"(fn [R C A f l]\n      (let [r (seq (A str (take-while #(<= % l) (iterate #(* % %) f))))\n            n (first (drop-while #(> (C r) %) (map #(* % %) (range 1 10))))\n            s (concat r (R (- n (C r)) \\*))\n            d (vec (R 9 []))\n            a (mapcat #(R %2 %) (cycle [1 -1]) (range 2 20 2))\n            [_ x] (reduce (fn [[i d] [c r]]\n                        [(+ i r) (update-in d [i] ({1 conj -1 #(vec (list* %2 %))} r) c)])\n                          [3 d] (map vector s a))\n            y (map #(interpose \\  %) (keep seq x))\n            m (A max (map C y))\n            z (map #(A str (concat % %2 %)) (map #(R (quot (- m (C %)) 2) \\ ) y) y)\n            ]\n        z)) replicate count apply","problem":138,"user":"4ff67852e4b0678c553fc37e"},{"code":"(fn [start end]\r\n  (letfn\r\n    [(squares [start end]\r\n       (take-while #(<= % end) (iterate #(* % %) start)))\r\n     (arrange [x]\r\n       (let [n (count x)\r\n             dim (int (Math/ceil (Math/sqrt n)))\r\n             dim1 (dec (* 2 dim))\r\n             y (concat x (repeat (- (* dim dim) n) \\*))\r\n             rot (fn [[i j]] (if (= j 0) [(* i -1) i] [i 0]))\r\n             legal? (fn [[i j]] (and (>= i 0) (>= j 0) (< i dim1) (< j dim)))]\r\n         (loop [p (if (odd? dim) [(dec dim) (dec dim)] [(dec dim) 0])\r\n                d (if (odd? dim) [-1 0] [1 0])\r\n                in (reverse y)\r\n                res (vec (repeat dim1 (vec (repeat dim nil))))]\r\n           (cond\r\n             (empty? in) res\r\n             (and (legal? (map + p d)) (nil? (get-in res (map + p d))))\r\n               (recur (map + p d) d (rest in) (assoc-in res p (first in)))\r\n             :else\r\n               (recur (map + p (rot d)) (rot d) (rest in) (assoc-in res p (first in)))))))\r\n     (pretty [x]\r\n       (for [r x]\r\n         (let [s (take-while (complement nil?) (drop-while nil? r))\r\n               m (- (count r) (count s))]\r\n           (apply str\r\n             (concat (repeat m \\space)\r\n                     (rest (interleave (repeat \\space) s))\r\n                     (repeat m \\space))))))]\r\n    (pretty (arrange (mapcat str (squares start end))))))","problem":138,"user":"500d1db4e4b05f7c30cfa69f"},{"problem":138,"code":"(fn solution [num stop]\n  (let [digits (->> num\n                    (iterate #(* % %))\n                    (take-while #(<= % stop))\n                    (mapcat (comp seq str)))\n        X nil\n        boards [[1 [[0]]]\n                [4 [[X 0 X]\n                    [3 X 1]\n                    [X 2 X]]]\n                [9 [[X X 6 X X]\n                    [X 5 X 7 X]\n                    [4 X 0 X 8]\n                    [X 3 X 1 X]\n                    [X X 2 X X]]]\n                [16 [[X  X  X  6  X  X  X]\n                     [X  X  5  X  7  X  X]\n                     [X  4  X  0  X  8  X]\n                     [15 X  3  X  1  X  9]\n                     [X  14 X  2  X  10 X]\n                     [X  X  13 X  11 X  X]\n                     [X  X  X  12 X  X  X]]]]\n        use-board (->> boards\n                       (filter #(>= (first %) (count digits)))\n                       (first)\n                       (second))\n        filled-board (->> use-board\n                          (map (fn [line]\n                                 (map #(cond\n                                        (nil? %) \\space\n                                        (< % (count digits)) (nth digits %)\n                                        :else \\*) line)))\n                          (map #(apply str %)))]\n    filled-board))","user":"5479c58de4b0c51c1f4d72c7"},{"problem":138,"code":"(fn squares-squared [start end]\n  (let [square #(* % %)\n        squares (take-while #(<= % end) (iterate square start))\n        sq-cs (mapcat (comp seq str) squares)\n        area (first (filter #(>= % (count sq-cs)) (map square (range))))\n        cs (take area (concat sq-cs (repeat \\*)))\n        sq-dim (int (Math/sqrt area))\n        dim (dec (* 2 sq-dim))\n        empty-grid (vec (repeat dim (vec (repeat dim \\space))))\n        next-dir {[1 -1] [1 1], [-1 -1] [1 -1], [-1 1] [-1 -1], [1 1] [-1 1]}\n        [grid] (reduce (fn [[grid coord dir] chr]\n                         (let [grid (assoc-in grid coord chr)\n                               next-c-candidate (map + coord dir)\n                               other-direction (next-dir dir)\n                               [coord dir]\n                               (if (= \\space (get-in grid next-c-candidate))\n                                 [next-c-candidate dir]\n                                 [(map + coord other-direction) other-direction])]\n                           [grid coord dir]))\n                       (if (even? sq-dim)\n                         [empty-grid [(int (/ dim 2)) 0] [1 1]]\n                         [empty-grid [(int (/ dim 2)) (dec dim)] [-1 -1]])\n                       (reverse cs))]\n    (vec (map #(clojure.string/join \"\" %) grid))))","user":"5ca14eb1e4b048ec896c5b7d"},{"code":";; this solution draws the matrix from the outside in\n;; because I thought the rebound logic would be easier \n;; than the spiral logic.  It does mean in some cases\n;; I have to rotate the final board across both axis.\n\n;; will add a spiral solution later, once I think clearly\n;; how to do that\n\n(fn sqsq [n1 n2]\n  (letfn [(sqstr [x y]\n            (apply str (take-while #(<= % y) (iterate #(* % %) x))))\n\n          (next-perfect-square [x]\n            (let [sqrt (int (Math/sqrt x))]\n              (if (= (* sqrt sqrt) x)\n                sqrt\n                (inc sqrt))))\n\n          (padstr [text n padchar]\n            (let [nchars (- n (count text))]\n              (str text (apply str (take nchars (repeat padchar))))))\n\n          (create-buf [dim]\n            (vec (for [x (range dim)] (vec (padstr \"\" dim \\space)))))\n\n          (print-buf [buf]\n            (println \"<-----\")\n            (dorun (map println buf))\n            (println \"----->\"))\n\n          (get-pos [buf pos]\n            (get-in buf pos))\n          \n          (write-pos [buf pos item]\n            (assoc-in buf pos item))\n\n          (apply-delta [pos delta]\n            (vec (map + pos delta)))\n\n          (is-empty? [buf pos]\n            (= (get-pos buf pos) \\space))\n\n          (do-work [n1 n2]\n            (let [sqtext (sqstr n1 n2)\n                  inner-dim (next-perfect-square (count sqtext))\n                  outer-dim (dec (* inner-dim 2))\n                  padtext (padstr sqtext (* inner-dim inner-dim) \\*)\n                  res-buf (create-buf outer-dim)\n                  before-first (apply-delta [(dec inner-dim) 0] [-1 -1])]\n              (loop [pos before-first\n                     deltas (cycle [[1 1] [-1 1] [-1 -1] [1 -1]])\n                     buf res-buf\n                     chars (reverse padtext)]\n                (if (seq chars)        \n                  (let [next-delta (drop-while #(not (is-empty? buf (apply-delta pos %))) deltas)\n                        next-pos (apply-delta pos (first next-delta))\n                        \n                        next-buf (write-pos buf next-pos (first chars))\n                        next-chars (rest chars)]\n                    #_(do (print-buf buf) (Thread/sleep 200))\n                    (recur next-pos next-delta next-buf next-chars))\n                  (if (odd? inner-dim)\n                    (flip buf)\n                    buf)))))\n\n          (flip [buf]\n            (reverse (map reverse buf)))\n\n          (to-final-form [buf]\n            (vec (map #(apply str %) buf)))\n          ]\n\n    (let [result (do-work n1 n2)]\n      #_(print-buf result)\n      (to-final-form result))))","problem":138,"user":"4f0d093b535d0136e6c22313"},{"code":"(fn [start end]\n  (letfn [(fnums [start end] (take-while #(<= % end) (iterate #(* % %) start)))\n          (flength [min] (first (drop-while #(< % min) (map #(* % %) (range)))))\n          (pad [size s] (apply str (take size (concat s (repeat \"*\")))))\n          \n          (place-digits [digits origin moves]\n            (let [next-move (zipmap moves (drop 1 (cycle moves)))]\n              (first\n               (reduce\n                 (fn [[board pos move] digit]\n                   (let [board1 (assoc board pos digit)\n                         maybe-move (next-move move)\n                         maybe-pos (mapv + pos maybe-move)]\n                     (if (board maybe-pos)\n                       [board1 (mapv + pos move) move]\n                       [board1 maybe-pos maybe-move])))\n                 [{} origin (first moves)]\n                 digits))))          \n          \n          (align-board [board]\n            (let [locs (keys board)\n                  offset (apply mapv min locs)\n                  new-locs (map #(mapv - % offset) locs)]\n              (zipmap new-locs (vals board))))\n          \n          (empty-vector-board [cols rows]\n             (vec (repeat rows (vec (repeat cols \" \")))))\n          \n          (fill-vector-board [src-board vector-board]\n             (reduce (fn [b [k v]] (assoc-in b (reverse k) v)) vector-board src-board))\n          \n          (string-board [board]\n             (map clojure.string/join board))]\n    \n    (let [nums (fnums start end)\n          digits (apply str nums)\n          length (flength (count digits))\n          chars (pad length digits)\n          moves [[1 -1] [1 1] [-1 1] [-1 -1]]\n          board (align-board (place-digits chars [0 0] moves))\n          [ncols nrows] (map inc (apply mapv max (keys board)))]\n      \n      \t(string-board\n          (fill-vector-board\n             board\n             (empty-vector-board ncols nrows))))))","problem":138,"user":"525431dfe4b0541d1855b970"},{"problem":138,"code":"(fn [n m]\n  (let [sm (->>\n            (iterate #(int (Math/pow % 2)) n)\n            (take-while #(<= % m)))\n        s (apply str sm)\n        sqn (->>\n              (map #(int (Math/pow % 2)) (range))\n              (drop-while #(< % (count s)))\n              (first))\n        sn (int (Math/sqrt sqn))\n        sr (- (* 2 sn) 1)\n        fs (apply str s (repeat (- sqn (count s)) \\*))\n        fl [(* (quot (- sn 1) 2) 2) (dec sn)]\n        mv (->>\n             (mapcat\n               #(repeat (inc (quot %1 2)) %2)\n               (range)\n               (cycle [[1 1] [1 -1] [-1 -1] [-1 1]]))\n             (take (dec (count fs))))\n        pat (loop [r [fl] mv mv]\n             (if (empty? mv)\n               r\n               (recur\n                 (conj r [(+ (first (last r)) (ffirst mv))\n                          (+ (last (last r)) (last (first mv)))])\n                 (rest mv))))\n        ls (into {} (map (fn [pat fs] [pat fs]) pat fs))]\n    (->>\n      (for [x (range sr)\n            y (range sr)]\n        (get ls [x y] \\space))\n      (partition sr)\n      (map #(apply str %)))))","user":"5af907e6e4b0cc2b61a3bcda"},{"code":"(let [ \n  start-position (fn [base]\n    (let [x (if (even? base) (- base 2) (dec base))\n          y (dec base)]\n      [x y]))\n  get-spiral-coords (fn [base]\n    (let [start (start-position base)\n          length (* base base)]\n      (take length\n        (reductions\n          (fn [[x y] [dx dy]] [(+ x dx) (+ y dy)])\n          start \n          (mapcat\n            #(repeat (second %) (first %))\n            (map\n              vector\n              (cycle [[1 1] [1 -1] [-1 -1] [-1 1]])\n              (interleave (iterate inc 1) (iterate inc 1))))))))\n   get-digits (fn [start limit]\n     (mapcat str (take-while #(<=  % limit) (iterate #(* % %) start)))) \n   create-vectors (fn [base]\n     (let [expanded (dec (* 2 base))]\n       (into [] (repeat expanded (into [] (repeat expanded \\space))))))\n   sqrt #(Math/round (Math/ceil (Math/sqrt %)))\n   stringify (fn [source]\n    (into [] (map #(apply str %) source)))]\n  (fn [start limit]\n    (let [digits (get-digits start limit)\n          num-digits (count digits)\n          base (sqrt num-digits)\n          spiral-coords (get-spiral-coords base)\n          blank-vector (create-vectors base)\n          output-vector (reduce (fn [p [pos digit]] (assoc-in p pos digit)) blank-vector (map vector spiral-coords (concat digits (repeat \\*))))]\n      (stringify output-vector))))","problem":138,"user":"4ec07699535dfed6da9c6da2"},{"problem":138,"code":"(fn func [start end]\n\t(let [get-ints (fn [start end]\n\t\t\t\t\t(let [num-arr(loop [num1 start num2 end arr []]\n\t\t\t\t\t\t\t\t\t(if (< num2 num1) arr\n\t\t\t\t\t\t\t\t\t\t(recur (* num1 num1) num2 (concat arr (vec (str num1))))))\n\t\t\t\t\t\t  cnt1 (Math/ceil (Math/sqrt (count num-arr)))\n\t\t\t\t\t\t  cnt2 (* cnt1 cnt1)]\n\t\t\t\t\t\t(concat num-arr (repeat (- cnt2 (count num-arr)) \"*\"))))\n\n\t\t\tcreate-empty-board (fn [cnt]\n\t\t\t\t(let [len (dec (* (Math/ceil (Math/sqrt cnt)) 2))]\n\t\t\t\t\t(vec (repeat len (apply str (repeat len \" \"))))))\n\n\t\t\tdraw-num (fn [board pos num]\n\t\t\t\t(let [x (second pos)\n\t\t\t\t\t  y (first pos)\n\t\t\t\t\t  row (get board y)\n\t\t\t\t\t  new-row (apply str (assoc (vec row) x num))\n\t\t\t\t\t  new-board (assoc board y new-row)]\n\t\t\t\t\tnew-board))\n\n\t\t\tcreate-dir-list (fn [cnt]\n\t\t\t\t(let [cnt (Math/ceil (Math/sqrt cnt))]\n\t\t\t\t\t(reduce #(if (odd? %2) (concat %1 (repeat %2 [1 1]) (repeat %2 [1 -1])) \n\t\t\t\t\t\t\t\t\t(concat %1 (repeat %2 [-1 -1]) (repeat %2 [-1 1]))) ()  (range 1 (inc cnt)))))\n\n\t\t\tget-cent-pos (fn [cnt]\n\t\t\t\t(let [len (Math/ceil (Math/sqrt cnt))]\n\t\t\t\t\t(if (odd? (int len)) [(int (dec len)) (int (dec len))]\n\t\t\t\t\t\t[(int (- len 2)) (int (- len 1))])))\n\n\n\n\t\t  num-arr (get-ints start end)\n\t\t  cnt (count num-arr)\n\t\t  cent-pos (get-cent-pos cnt)\n\t\t  dir-list (create-dir-list cnt)]\n\t   (loop [board (create-empty-board cnt) \n\t   \t\t  pos cent-pos \n\t   \t\t  arr num-arr\n\t   \t\t  dir-lst dir-list]\n\t   \t (if (nil? arr) board\n\t   \t   (recur (draw-num board pos (first arr)) \n\t   \t   \t      [(+ (first (first dir-lst)) (first pos)) (+ (second (first dir-lst)) (second pos))]\n\t   \t   \t      (next arr)\n\t   \t   \t      (next dir-lst))))))","user":"577c3da9e4b0c8d87281f6b9"},{"problem":138,"code":"(fn [start end]\n    (let [powers (fn [start end]\n                   (loop  [acc  [start]\n                           cur start]\n                     (let  [pc  (* cur cur)]\n                       (if  (> pc end)\n                         acc\n                         (recur  (conj acc pc)  pc)))))\n\n          digits_of_num (fn [n]\n                          (loop [acc []\n                                 cur n]\n                            (if (< cur 10)\n                              (cons cur acc)\n                              (recur (cons (mod cur 10) acc)  (quot cur 10)))))\n\n          digits_of_vector (fn [v]\n                             (reduce (fn [acc el] (concat acc (digits_of_num el))) [] v))\n\n          get_diamond_max_elements_count (fn [side]\n                                           (let [h (/ (inc side) 2)]\n                                             (* h h)))\n\n          get_diamond_start (fn [side]\n                              (let [centerrowoffset (if (odd? (quot side 2)) -1 0)]\n                                (+ (quot side 2) (* side (+ centerrowoffset (quot side 2))))))\n\n          indiamond (fn [side pos]\n                      (and  (>= pos 0)\n                            (< pos (* side side))))\n\n          update_diamond_used (fn [pos side used]\n                                (if (indiamond side pos)\n                                  (assoc used pos true)\n                                  used))\n          diamond_next_pos_dir (fn [side pos dir used]\n                                 (let [nextdir (fn [d]\n                                                 (case d\n                                                   :dr :dl\n                                                   :dl :ul\n                                                   :ul :ur\n                                                   :ur :dr))\n                                       nextpos (fn [p d]\n                                                 (case d\n                                                   :dr (+ p side 1)\n                                                   :dl (+ p side -1)\n                                                   :ul (+ p (unchecked-negate side) -1)\n                                                   :ur (+ p (unchecked-negate side) 1)))\n                                       ndir  (nextdir  dir)\n                                       nextposcurdir (nextpos pos dir)\n                                       nextposnextdir (nextpos pos ndir)\n                                       [np nd]  (if (and (indiamond side nextposnextdir) (used nextposnextdir))\n                                                  [nextposcurdir dir]\n                                                  [nextposnextdir ndir])\n                                       nused (update_diamond_used np side used)]\n\n                                   [np nd nused]))\n\n          places (fn [side]\n                   (let [curpos (get_diamond_start side)\n                         max_elements_count  (get_diamond_max_elements_count side)\n                         used_cells (update_diamond_used curpos side (vec  (map (fn [_] false) (range (* side side)))))\n                         [plcs _ _ _] (reduce (fn [[posvec used pos dir] _]\n                                                (let [[nextpos nextdir nextused] (diamond_next_pos_dir side pos dir used)\n                                                      nextposvec (conj posvec [(quot pos side) (mod pos side)])]\n                                                  [nextposvec nextused nextpos nextdir]))\n                                              [[], used_cells, curpos, :ur]\n                                              (range  max_elements_count))]\n                     plcs))\n\n          strings (fn [side]\n                    (vec  (map  (fn  [_]  (vec (map  (fn  [_]  (char 32))  (range side))))  (range side))))\n\n          get_diamond_side (fn [nelements]\n                             (loop [side 1]\n                               (if (>=  (get_diamond_max_elements_count side) nelements)\n                                 side\n                                 (recur (+ side 2)))))\n          fill (fn [side strs dgts]\n                 (let [wanted (get_diamond_max_elements_count side)\n                       missing (- wanted (count dgts))]\n                   (concat dgts (map (fn [_] -6) (range missing)))))\n          digits (digits_of_vector (powers start end))\n          c (count digits)\n          side (get_diamond_side c)\n          strs (strings side)\n          digits2 (fill side strs digits)\n          digits3 (map (fn [d] (char (+ 48 d))) digits2)\n          plcs (places side)\n          d_p (map (fn [d p] (vector d p)) digits3 plcs)\n          unformatted (reduce (fn [acc [d [x y]]] (update-in acc  [x y]  (fn [_] d))) strs d_p)]\n      (vec  (map  (fn  [e]  (apply str e)) unformatted))))","user":"53ac815de4b047364c04445e"},{"problem":138,"code":"(fn [b e]\n  (let [s (->> b (iterate #(* % %)) (take-while #(<= % e)) (map str) clojure.string/join seq)\n        l (count s)\n        sq (->> (range) (map #(* % %)) (drop-while #(< % l)) first)\n        a (int (Math/sqrt sq))\n        s (concat s (repeat (- sq l) \\*))\n        p (quot (dec a) 2)\n        step-f\n          (fn f [i y]\n            (lazy-cat (mapcat #(repeat i %) (take 2 y)) (f (inc i) (drop 2 y))))\n        ds (map #([[0 1] [1 0] [0 -1] [-1 0]] %) (take sq (step-f 1 (cycle [0 1 2 3]))))\n        ps (reductions #(map + %1 %2) [p p] ds)\n        a- (dec a)\n        rot (fn [[r c]] (map + [a- 0] [(- r a-) (- a- r)] [c c]))\n        kv (map vector (map rot ps) s)\n        A (dec (* 2 a))\n        m (atom (vec (repeat A (vec (repeat A \\space)))))]\n    (doseq [[k v] kv] (swap! m assoc-in k v))\n    (mapv #(apply str %) @m)))","user":"5416b4a2e4b01498b1a71a01"},{"problem":138,"code":"(fn [n0 n1]\n    (let [turn-right {[ 1  1] [ 1 -1], [ 1 -1] [-1 -1],\n                      [-1 -1] [-1  1], [-1  1] [ 1  1]}\n          ;; The function which returns the coordinates of an\n          ;; ever-increasing spiral of `n` values:\n          spiral (fn [n]\n                   (let [pts (loop [pos [0 0], dir [-1 1], n n, ret [],\n                                    board #{pos}]\n                               (if-not (pos? n)\n                                 ret\n                                 (let [next-dir (turn-right dir)\n                                       next-pos (map + pos next-dir)\n                                       should-turn (board next-pos)]\n                                   ;; Already have been there?  If so,\n                                   ;; use existing rather than new\n                                   ;; direction.  If not, turn right.\n                                   (recur (if should-turn\n                                            (map + pos dir)\n                                            next-pos)\n                                          (if should-turn dir next-dir)\n                                          (dec n)\n                                          (conj ret pos)\n                                          (conj board pos)))))\n                         minr (->> pts (map first) (apply min))\n                         minc (->> pts (map second) (apply min))]\n                     ;; Apply offset to zero-based positions to \"true\"\n                     ;; rows/columns\n                     (map (fn [[r c]] [(- r minr) (- c minc)]) pts)))\n          ;; Calculate the actual values in the 'digit spiral',\n          ;; filling in the necessary number of `*` characters::\n          sqr #(*' % %)\n          s (take-while (partial >= n1) (iterate sqr n0))\n          squares (map sqr (range))\n          digs (mapcat str s)\n          square-size (->> squares\n                           (drop-while (partial > (count digs)))\n                           first)\n          stars (repeat (- square-size (count digs)) \\*)\n          digs (concat digs stars)\n          ;; Figure out how big the board needs to be, based on the\n          ;; range of positions returned by the `spiral` function:\n          spir (spiral (count digs))\n          board-size (->> spir\n                          (map first)\n                          (apply (juxt max min))\n                          (apply -)\n                          inc)\n          ;; Unadorned board consisting only of spaces:\n          raw-board (->> \\space\n                         (repeat board-size)\n                         (into [])\n                         (repeat board-size)\n                         (into []))]\n      ;; The final board calculation is a reduction, using `assoc-in`\n      ;; to fill the values in `digs` and coordinates returned by\n      ;; `spiral`:\n      (->> (reduce (fn [B [ch [r c]]]\n                     (assoc-in B [r c] ch))\n                   raw-board\n                   (partition 2 (interleave digs spir)))\n           (map (partial apply str)))))","user":"4ee26f01535d10e5ff6f5368"},{"problem":138,"code":"(fn __ [s e]\n  (map (partial apply str)\n       (let [digits\n             (mapcat str (take-while #(<= % e) (iterate #(* % %) s)))\n             inner-size\n             (first (drop-while #(< (* % %) (count digits)) (range)))\n             outer-size\n             (dec (* 2 inner-size))\n             outer-matrix\n             (vec (repeat outer-size (vec (repeat outer-size \\space))))\n             rdigits\n             (reverse (first (partition (* inner-size inner-size) 1 (repeat \\*) digits)))]\n         (loop [matrix outer-matrix\n                dgts rdigits\n                n (dec (* inner-size 2)) ; number of points for one batch place\n                start (conj [(-> outer-size (dec) (/ 2))]\n                            (if (even? inner-size) 0\n                                (dec outer-size)))\n                direction (if (odd? inner-size)\n                            (apply concat\n                                   (repeat [[-1 -1] [1 1]]))\n                            (apply concat\n                                   (repeat [[1 1] [-1 -1]])))]\n           (if (empty? dgts) matrix\n               (let [len (/ (dec n) 2) ; the length of one lane\n                     turnpos (mapv #(+ (* len %1) %2) (first direction) start) ; turn point position\n                     newmat ; new matrix after placing one lane\n                     (loop [mat matrix\n                            ds (take n dgts) ; number of digits to place in 2 lane\n                            dir (first direction)\n                            pos start ; point to place char\n                            ]\n                       (if (empty? ds) mat\n                           (let [newdir (if (= pos turnpos)\n                                          (update-in dir [0] * -1)\n                                          dir)]\n                             (recur (update-in mat pos (constantly (first ds)))\n                                    (rest ds)\n                                    newdir\n                                    (mapv + pos newdir) ; next point\n                                    ))))]\n                 (recur newmat\n                        (drop n dgts)\n                        (- n 2)\n                        (mapv + (update-in start [1]\n                                           #(+ % (* (second (first direction)) (dec n))))\n                              (second direction))\n                        (rest direction)\n                        )))))))","user":"5a0ce1a5e4b04bbd27e6d9b7"},{"problem":138,"code":"(fn [start end]\n  (let [pre-string (->> start\n                        (iterate #(* % %))\n                        (take-while #(<= % end))\n                        (apply str))\n        [side-length field-count] (->> (range)\n                                       (map #(vector % (* % %)))\n                                       (drop-while #(< (second %) (count pre-string)))\n                                       first)\n        string (take field-count (concat pre-string (repeat \\*)))\n        pre-rotate-empty (->> \\? (repeat side-length) vec (repeat side-length) vec)\n        starting-field (-> side-length dec (quot 2) (#(repeat 2 %)) vec)\n        directions {:right {:delta [0 1], :next :down}\n                    :down {:delta [1 0], :next :left}\n                    :left {:delta [0 -1], :next :up}\n                    :up {:delta [-1 0], :next :right}}\n        pre-rotate (loop [string string\n                          board pre-rotate-empty\n                          field starting-field\n                          direction (directions :up)]\n                     (let [board' (assoc-in board field (first string))\n                           check-direction (directions (direction :next))\n                           check-field (map + field (check-direction :delta))\n                           [field' direction'] (if (= \\? (get-in board check-field))\n                                                 [check-field check-direction]\n                                                 [(map + field (direction :delta)) direction])]\n                       (if-let [string' (next string)]\n                         (recur string' board' field' direction')\n                         board')))\n        lookup (fn [field]\n                 (get-in pre-rotate field))\n        projection (loop [projected-row 1, result []]\n                     (if (= projected-row (* 2 side-length))\n                       result\n                       (recur (inc projected-row)\n                              (->> projected-row\n                                   range\n                                   (#(map vector (reverse %) %))\n                                   (drop (- projected-row side-length))\n                                   (drop-last (- projected-row side-length))\n                                   vec\n                                   (conj result)))))\n        fill (fn [row] \n               (let [target-length (dec (* 2 side-length))\n                     filler (-> row \n                                count \n                                (#(- target-length %)) \n                                (quot 2) \n                                (repeat \\space)\n                                (#(apply str %)))]\n                 (str filler row filler)))\n        projected (for [projected-row projection]\n                    (->> projected-row\n                         (map #(get-in pre-rotate %))\n                         (interpose \\space)\n                         (apply str)\n                         fill\n                         ))]\n    (vec projected)))","user":"58247423e4b051871117bec5"},{"code":"(fn squares [start end]\n  (let [digits (apply str (take-while #(<= % end) (iterate #(* % %) start)))\n        total-length (first (for [n (range) :let [sq (* n n)] :when (>= sq (count digits))] sq))\n        all-chars (concat digits (repeat (- total-length (count digits)) \\*))\n        moves {0 [1 1], 1 [1 -1], 2 [-1 -1], 3 [-1 1]}\n        coordinates (fn [cs]\n                      (loop [position [0 0] move 0 v (rest cs) m {[0 0] (first cs)}]\n                        (let [next-position (vec (map + position (get moves move)))]\n                          (cond\n                            (empty? v) m\n                            (nil? (get m next-position)) (recur next-position (mod (inc move) 4) (rest v) (assoc m next-position (first v)))\n                            :else (let [alt-move (mod (dec move) 4)\n                                        alt-next-position (vec (map + position (get moves alt-move)))]\n                                    (recur alt-next-position move (rest v) (assoc m alt-next-position (first v))))))))\n        raw-coordinates (coordinates all-chars)\n        coords-keys (keys raw-coordinates)\n        min-i (apply min (map #(nth % 0) coords-keys))\n        min-j (apply min (map #(nth % 1) coords-keys))\n        normalized-coordinates (zipmap (for [[x y] coords-keys] [(- x min-i) (- y min-j)]) (vals raw-coordinates))\n        row-size (int (dec (* 2 (Math/sqrt total-length))))\n        row (fn [i] (apply str (for [j (range row-size)] (get normalized-coordinates [i j] \\space))))]\n    (for [i (range row-size)] (row i))))","problem":138,"user":"4e9519b4535dbda64a6f6b2d"},{"problem":138,"code":"(fn prob138 [start end]\n  (letfn [(squares-digit-list [start end]\n            ;; (squares-digit-list 3 81) => (3 9 8 1)\n            ;; if end is below the next then stop\n            ;; (squares-digit-list 4 20) => (4 1 6)\n            (let [square (fn [n] (* n n))\n                  digit-list (fn [nums]\n                               ;; split numbers into single list of digits\n                               (let [digits (fn [num] (map #(Character/digit % 10) (str num)))]\n                                 (flatten (map digits nums))))]\n              (digit-list \n               (loop [acc [start]]\n                 (if (< end (last acc))\n                   (drop-last acc)\n                   (recur (conj acc (square (last acc)))))))))\n          \n          (lengths [] \n            ;; lengths of the strings\n            ;; (1 4 9 16 25 ...)\n            ;; \n            (map #(* % %) (iterate inc 1)))\n          \n          (pad [n coll val]\n            ;; @see http://stackoverflow.com/a/27263793 \n            (take n (concat coll (repeat val))))\n          \n          (pad-numbers [nums]\n            (let [len (count nums)\n                  len' (first (filter #(>= % len) (lengths)))\n                  padded (pad len' nums \\*)]\n              padded))\n          \n          (board-sizes []\n            ;; (1 3 5 7 ...)\n            ;; 1x1, 3x3, 5x5, 7x7, ....\n            ;; (1 9 25 49\n            (iterate #(+ % 2) 1))\n          \n          (board-size [nums]\n            ;; pad the nums to get the string length\n            ;; figure out which board size is required\n            ;; map over (lengths) and (board-sizes) to get the pairs\n            ;; find the first pair that has the matching string length\n            ;; return the associated board size\n            (let [padded-length (count (pad-numbers nums))]\n              (second (first (filter #(= (first %) padded-length) (map vector (lengths) (board-sizes)))))))\n          \n          (empty-board [size] \n            ;; Return a size x size board filled with nils\n            (vec (repeat size (vec (repeat size nil)))))\n          \n          (blank-board [nums]\n            ;; Return a appropriately sized for a set of nums\n            (empty-board (board-size nums)))\n          \n          (write-board [xs]\n            ;; Convert the board of nils and numbers to strings\n            ;; \n            (vec (map (fn [x] (apply str (replace '{nil \\space}  x))) xs)))\n          \n          (start-position [board]\n            ;; where should be start\n            ;; 1x1 board => [0 0]\n            ;; 3x3 board => [0 1]\n            ;; 5x5 board => [2 2]\n            ;; 7x7 board => [2 3]\n            (case (count board)\n              1 [0 0]\n              3 [0 1]\n              5 [2 2]\n              7 [2 3]\n              nil ;; TODO this function should be able to handle all sizes (formula)\n              )) \n          \n          (direction-value [direction]\n            ;; convert a direction keyword to it's associated [row col] index\n            (let [direction-map {:down-right [1 1]\n                                 :down-left  [1 -1]\n                                 :up-left    [-1 -1]\n                                 :up-right   [-1 1]}]\n              (direction-map direction)))\n          \n          (turn-right [direction]\n            ;; while facing in the 'direction' return the direction to the right\n            (case direction\n              :down-right :down-left\n              :down-left :up-left\n              :up-left :up-right\n              :up-right :down-right))\n          \n          (move-point [board point new-direction]\n            ;; return the point in the 'new-direction'\n            ;; and then apply new-direction to point\n            ;; to return the new point\n            (map + point (direction-value new-direction)))\n          \n          (look-right [board point direction]\n            ;; return the value while facing in 'direction' to our 'right'\n            (get-in board (move-point board point (turn-right direction))))\n          \n          (next-direction [board point direction]\n            (let [right-value (look-right board point direction)]\n              ;; can we turn right?\n              (if (nil? right-value)\n                (turn-right direction)\n                ;; else continue in the current-direction\n                direction)))\n          \n          (update-board [board point value]\n            ;; Return a new board with the value set at point\n            (assoc-in board point value))\n          \n          (snake [board lst]\n            ;; write the lst into the board\n            ;; 1. find the starting point\n            (let [start-point (start-position board)]\n              ;; 2. write starting point and recurse over board moving through list\n              ;; - first move down-right\n              ;; - loop\n              ;; - can i turn right?\n              ;;   - turn and move\n              ;;   - continue\n              (loop [board (update-board board start-point (first lst))\n                     lst (rest lst)\n                     current-point start-point\n                     direction :up-right]\n                (println current-point \" \" direction)\n                (println board)\n                (if (empty? lst)\n                  board\n                  ;; next-point is right of 'point' or next in 'direction'\n                  (let [new-direction (next-direction board current-point direction)]\n                    (let [new-point (move-point board current-point new-direction)]\n                      (println new-point \" \" new-direction)\n                      (recur (update-board board new-point (first lst)) (rest lst) new-point new-direction)))))))]\n    (let [digits (squares-digit-list start end)\n          board (empty-board (board-size digits))\n          lst (pad-numbers digits)]\n      (write-board (snake board lst)))\n    )\n)","user":"4ebbff41535dfed6da9c6d78"},{"problem":138,"code":"(fn [s e] \n     (\n       letfn \n       [\n        (add[v1 v2] (conj [(+ (v1 0) (v2 0))] (+ (v1 1) (v2 1)) ))        \n        (seqgen[n] (\n                     cond\n                     (zero? n) '([0 0])\n                     (= 1 n) '([0 0] [1 1] [2 0] [1 -1])\n                     (even? n) (\n                                let [\n                                     prev (seqgen (dec n))\n                                     step1 (take (inc n) (iterate #(add % [-1 1]) (add [-1 -1] (last prev))))\n                                     step2 (rest (take (inc n) (iterate #(add % [1 1]) (last step1) )))\n                                     ]  (\n                                          concat  prev step1 step2\n                                          )\n                     )\n                                 \n                     :e (\n                                let [\n                                     prev (seqgen (dec n))\n                                     step1 (take (inc n) (iterate #(add % [1 -1]) (add [1 1] (last prev))))\n                                     step2 (rest (take (inc n) (iterate #(add % [-1 -1]) (last step1) )))\n                                     ]  (\n                                          \n                                          concat  prev step1 step2\n                                          )\n                          )\n                     ))\n          (sqg[s e](\n                     if (> s e)\n                     []\n                     (cons s (sqg (* s s) e))\n                     ))\n                   \n          (minsq[n l] (\n                        let [sx (seqgen n)]\n                        (\n                          if (>= (count sx) l)\n                          sx\n                          (minsq (inc n) l)\n                          )\n                        ))\n          (measure[sx] (\n                        identity {\n                                  :miny (apply min (map first sx))\n                                  :minx (apply min (map last sx))\n                                  :maxy (apply max (map first sx))\n                                  :maxx (apply max (map last sx))\n                         }\n                         ))\n                       \n          (gets[v sv sx](\n                          \n                          #(\n                             cond\n                            (empty? %) \" \"\n                            (< (first %) (count sx)) (str (nth sx (first %)))\n                            :e \"*\"   \n                               ) (keep-indexed #(if (= %2 v) %1) sv)\n                          \n                          ))\n                      \n        ]\n      \n      \n      (let [\n            tsx (apply str (sqg s e))\n            ssx (minsq 0 (count tsx))\n            dat (measure ssx)\n            ]\n          (\n            \n            map #(apply str %)\n            (loop [y (dat :miny) acc []]\n            (\n              if (> y (dat :maxy))\n              acc\n              (recur (inc y) (\n                               conj acc (loop [x (dat :minx) sacc []]\n                               (\n                                  if (> x (dat :maxx))\n                                    sacc\n                                  (recur (inc x) (conj sacc (gets [y x] ssx tsx)))\n                                 ))\n                               \n                               ))\n              ))\n\n            ))\n      \n\n\n    ))","user":"596f6683e4b069c0a1a19877"},{"code":"(fn [s e]\n  (let [R (comp first reduce)\n        P repeat\n        V (comp vec P)\n        C concat\n        d (mapcat str (take-while #(<= % e) (iterate #(* % %) s)))\n        n (first (remove #(< (* % %) (count d)) (range)))\n        d (C d (P \\*))\n        l (- (* 2 n) 1)\n        y (quot l 2)\n        x (+ y -1 (mod n 2))]\n    (map #(apply str %)\n         (R\n          (fn [[b c] [v d]] [(assoc-in b c v) (map + c d)])\n          [(V l (V l \\ )) [x y]]\n          (map list d (C\n                       (R\n                        (fn [[c [f s t & r]] n] [(C c [f] (P n s) (P n t)) (cons t r)])\n                        [[] (cycle [[1 1] [1 -1] [-1 -1] [-1 1]])]\n                        (range 1 n))\n                       [0]))))))","problem":138,"user":"52b453b0e4b0c58976d9ad21"},{"problem":138,"code":"(fn [s e]\n  (let [ds (mapcat str (take-while #(<= % e) (iterate #(* % %) s)))\n        vs (concat ds (repeat \\*))\n        dim (first (drop-while #(< (* % %) (count ds)) (range)))\n        ddim (dec (* 2 dim))\n        dirs (cycle [[1 1] [-1 1] [-1 -1] [1 -1]])\n        counts (mapcat #(repeat 2 %) (map inc (range)))\n        cwalk (map vector counts dirs)\n        walk (map vector vs (mapcat (fn [[n dir]] (repeat n dir)) cwalk))\n        e-board (vec (repeat ddim (vec (repeat ddim \\ ))))\n        x0 (quot ddim 2)\n        y0 (* 2 (quot (dec dim) 2))]\n    (map\n     #(apply str %)\n     (loop [ct (* dim dim) board e-board [[v [dx dy]] & s] walk x x0 y y0]\n       (if (zero? ct)\n         board\n         (recur (dec ct) (assoc-in board [y x] v) s (+ x dx) (+ y dy)))))))","user":"52ce1abfe4b07d0d72b27389"},{"problem":138,"code":"(fn sol [beg end]\n  (letfn [\n          (nsq [n]\n  (cond (= 1 n) 1\n        :else\n        (loop [res 1 k (dec n)]\n          (if (= 0 k) res\n            (recur (+ (+ (* 2 k) 1) res) (dec k))\n\n            )\n        )\n  )\n)\n\n(slen [n]\n  (loop [k 1]\n    (if (<= n (nsq k)) k\n      (recur (inc k))\n    )\n  )\n)\n\n(start [n]\n   (let [sl (slen n) h (int (/ (+ (* 2 (dec sl) ) 1) 2))];\n   (cond (odd?  sl ) [h h]\n        :else [(dec h) h]\n  )\n))\n\n (nextf [f]\n  (cond (= f :SE) :SW;\n        (= f :SW) :NW\n        (= f :NW) :NE\n        (= f :NE) :SE\n       :else :SE\n  )\n)\n\n(nextpos [r c f ]\n   (cond (= f :SE) [(inc r ) (inc c)]\n         (= f :SW) [(inc r ) (dec c)]\n         (= f :NW) [(dec r ) (dec c)]\n         (= f :NE) [(dec r ) (inc c)]\n        :else [r c]\n         )\n  )\n  \n  (nextstat [r c f n k]\n    (cond (< k n) [(first (nextpos r c f))\n                   (second (nextpos r c f))\n                    f n (inc k)]\n         :else\n         (cond (and (even? n) (= :SE f)) (nextstat r c (nextf f) n 1)\n               (and (even? n) (= :SW f)) (nextstat r c (nextf f) n 1)\n               (and (even? n) (= :NW f)) (nextstat r c f (inc n) k )\n               (and (odd? n) (= :NW f)) (nextstat r c (nextf f) n 1)\n               (and (odd? n) (= :NE f)) (nextstat r c (nextf f) n 1)\n               (and (odd? n) (= :SE f)) (nextstat r c f (inc n) k )\n               :else\n                 [r c f n k]\n               )\n          )\n)\n\n(ziffern [beg end]\n    (loop [res (str beg) sq (* beg beg)]\n       (if (> sq end)\n           res\n           (recur (concat res (str sq)) (* sq sq))\n         )\n      )\n  )\n\n (ziffern-fill [beg end]\n       (let [c (count (ziffern beg end))\n             cw (nsq (slen c)) ]\n          (loop [res (ziffern beg end) diff (- cw c)]\n              (if (= 0 diff) res\n                  (recur (concat (conj (vec res) \\*)) (dec diff))\n              )\n          )\n       )\n)\n   (posmatch [res r c f n k xs]\n  (let [nst (nextstat r c f n k)]\n    (if (empty?  xs)\n            res\n          (recur (conj res [[r c]  (first xs)] )\n                 (first nst) (second nst) (second (rest nst))\n                  (second (rest (rest nst))) (last nst) (rest xs))\n    )\n  )\n)\n\n      (posmatch1 [xs]\n    (let [st (start (count xs))]\n   (posmatch [] (first st) (second st) :SE 1 1 xs)\n  )\n)\n    \n          \n          ]\n   (let [fills (ziffern-fill beg end)\n         rcsize (+ (* 2 (dec (slen (count fills)))) 1)\n         matches (into {} (posmatch1 fills))]\n      (loop [res [] zeile \"\"   \n             r 0 c 0 ]\n         (let [mt (matches [r c])]\n         (cond (and (= c (dec rcsize)) (= r (dec rcsize)) )\n               (if mt (conj res (str zeile mt))\n                      (conj res (str zeile \\space))\n               )\n              (= c (dec rcsize))\n                 (recur (conj res (str zeile (if mt mt \\space))) \"\" (inc r) 0)\n              :else   \n                 (recur res (str zeile (if mt mt \\space) ) r (inc c) )\n         )\n         )\n     )\n  )\n))","user":"59ff9424e4b01bb0ae8afd24"},{"problem":138,"code":"(fn [start limit]\n   (let [\n         square #(* % %)\n         [wid chs]\n         (let [sqr-str (->> (iterate square start)\n                            (take-while #(<= % limit))\n                            (map str)\n                            (apply concat))\n               [wd sq] (->> (range)\n                            (map #(vector % (square %)))\n                            (drop-while #(< (second %) (count sqr-str)))\n                            first)]\n           [wd (->> (repeat \\*)\n                    (concat sqr-str)\n                    (take sq))])\n         positions-at (fn [level]\n                        (let [sgn (if (even? level) 1 -1)\n                              half (range level)\n                              rows (concat half `(~level) (reverse half))\n                              cols (range (- level) (inc level))]\n                          (map vector\n                               (if (pos? sgn) (map - rows) (map inc rows))\n                               (map #(* sgn %) cols))))\n         all-positions (->> (range wid)\n                            (map positions-at)\n                            (apply concat)\n                            (map #(map (fn [m] (+ wid m -1)) %))\n                            (map (fn [[r c :as pos]]\n                                   (if (even? wid) [(dec r) c] pos))))\n         pos-ch-map (into {} (map vector all-positions chs))\n         wid2 (+ wid wid -1)]\n     (->> (for [r (range wid2) c (range wid2)]\n            (get pos-ch-map [r c] \\space))\n          (apply str)\n          (partition wid2)\n          (map #(apply str %)))))","user":"5e3ef7d4e4b01d43a70e8e2d"},{"code":"(letfn\n    [(point [n] (int (Math/ceil (Math/sqrt n))))\n\n     (pad [n p xs] (take n (concat xs (repeat p))))\n\n     (sqrt-str [s e]\n       (let [nums   (apply str (take-while #(<= % e) (iterate #(* % %) s)))\n             root   (point (count nums))\n             padded (pad (* root root) \"*\" nums)]\n         padded))\n\n     (align [xs]\n       (loop [r 1 a [] xs xs]\n         (cond\n          (empty? xs) a\n          :else (let [[h t] (split-at (* 2 r) xs)\n                      h (pad (* 2 r) nil h)\n                      a (map #(concat [nil] % [nil]) a)\n                      a (if (odd? r)\n                          (concat a [h])\n                          (concat [(reverse h)] a))]\n                  (recur (inc r) a t)))))\n\n     (rotate [xs]\n       (->> (apply map vector xs)\n            (map #(keep identity %))\n            (remove empty?)))\n\n     (center [n p xs]\n       (let [ps (repeat (/ (- n (count xs)) 2) p)]\n         (concat ps xs ps)))]\n\n  #(let [a (->> (sqrt-str %1 %2)\n                align\n                rotate\n                (map (partial interpose \\space)))\n         w (apply max (map count a))]\n\n     (->> a\n          (map (partial center w \\space))\n          (map (partial apply str)))))","problem":138,"user":"52d2ca1ce4b099d49816f0b4"},{"problem":138,"code":"(fn quadrat [a b]\n  (let [s (apply str (take-while #(<= % b) (iterate #(* % %) a)))\n        c (first (drop-while #(< (* % %) (count s)) (range)))\n        s (apply str s (repeat (- (* c c) (count s)) \\*))\n        n (+ c c)\n        c (dec c)\n        v (vec (repeat n (vec (repeat (dec n) \\ ))))\n        draw (fn draw [m [x y] [ax ay bx by] [dx dy] fill]\n               (if (empty? fill)\n                 m\n                 (let [dec2 (comp dec dec) inc2 (comp inc inc)\n                       nx (+ x dx) ny (+ y dy)\n                       [dx ax] (if (= ax x) [1 (dec2 ax)]  [dx ax])\n                       [dy ay] (if (= ay y) [1 (dec2 ay)]  [dy ay])\n                       [dx bx] (if (= bx x) [-1 (inc2 bx)] [dx bx])\n                       [dy by] (if (= by y) [-1 (inc2 by)] [dy by])]\n                   (recur (assoc-in m [y x] (first fill)) [nx ny] [ax ay bx by] [dx dy] (rest fill)))))\n        \n        m (draw v [c c] [(dec c) (dec c) c (inc c)] [1 1] s)\n        m (map #(apply str %) m)]\n\n    (if (odd? c) (rest m) (drop-last m))\n\n    ))","user":"4ddb696b535d02782fcbe9fa"},{"problem":138,"code":"(fn [from to]\n  (let [squares (->> from\n                     (iterate #(* % %))\n                     (take-while #(<= % to))\n                     clojure.string/join\n                     seq)\n        side (-> squares count Math/sqrt Math/ceil long)\n        squares (concat squares (repeat (- (* side side) (count squares)) \\*))\n\n        steps-per-side (concat (mapcat (fn [x] [x x]) (range 1 side)) [(dec side)])\n        directions [[1 1] [1 -1] [-1 -1] [-1 1]]\n        steps (mapcat repeat steps-per-side (cycle directions))\n        center [(* 2 (quot (dec side) 2)) (dec side)]\n        coords (reductions (partial map +) center steps)\n\n        diag-side (+ side side -1)\n        data (into {} (map vector coords squares))]\n    (for [y (range diag-side)]\n      (-> (for [x (range diag-side)]\n            (data [y x] \" \"))\n          clojure.string/join))))","user":"4e7db3b4535db169f9c796e1"},{"problem":138,"code":"(fn squares-squared [start end]\n  (let [square (fn [x] (* x x))\n        number-seq (->> start\n                     (iterate square)\n                     (take-while (partial >= end)))\n        string-seq (apply str number-seq)\n        string-seq-length (count string-seq)\n        full-string-seq (concat string-seq (repeat (->> (range)\n                                                     (map square)\n                                                     (drop-while (partial > string-seq-length))\n                                                     first\n                                                     (+ (- string-seq-length)))\n                                                   \\*))\n        coords (let [rotate-direction (fn [[x y]] [(- y) x])\n                     n (count full-string-seq)\n                     gen-coords (fn [coord direction n side-n side-length sides-visited coords]\n                                  (cond (= n 1) coords\n                                        (= side-n 1) (if (= sides-visited 1)\n                                                       (let [new-coord (map + coord direction)]\n                                                         (recur new-coord direction (dec n) 1 (inc side-length) 3 (conj coords new-coord)))\n                                                       (let [new-direction (rotate-direction direction)\n                                                             new-coord (map + coord new-direction)]\n                                                         (recur new-coord new-direction (dec n) (dec side-length) side-length (dec sides-visited) (conj coords new-coord))))\n                                        :else (let [new-coord (map + coord direction)]\n                                                (recur new-coord direction (dec n) (dec side-n) side-length sides-visited (conj coords new-coord)))))\n                     ]\n                 (gen-coords [0 0] [1 -1] n 1 2 4 [[0 0]]))\n        moved-coords (let [min-x (reduce min (map first coords))\n                           min-y (reduce min (map second coords))]\n                       (map (partial map + [(- min-x) (- min-y)]) coords))\n        plane-max-x (inc (reduce max (map first moved-coords)))\n        plane-max-y (inc (reduce max (map second moved-coords)))\n        coords-map (into {} (map vector moved-coords full-string-seq))]\n    (->> (for [y (range plane-max-y)\n               x (range plane-max-x)\n               :let [character (get coords-map [x y] \\space)] ] character)\n      (partition plane-max-x)\n      (map (partial apply str)))))","user":"53c38b8ce4b00fb29b22127b"},{"code":"(fn [begin limit]\n    (let [M map\n          R reduce\n          C constantly\n          MI map-indexed\n          A apply\n          spaces (fn [n]\n                        (->> (repeat \" \")\n                          (partition n)\n                          (M vec)\n                          (take n) \n                          vec))\n          ** #(* % %)\n\n          turn-left (fn [[y x]]\n                      (if (zero? y)\n                        [(- x) y]\n                        [x y]))\n\n          snake (fn [coll c]\n                  (let [init (spaces c)\n                        start (if (even? c)\n                                [[(dec c) 0] [0 1]]\n                                [[0 (dec c)] [0 -1]])]\n                    (first (R\n                             (fn [[result [here dir]] value]\n                               (let [step (M + here dir)\n                                     new-dir (if (= \" \" (get-in result step))\n                                                     dir\n                                                     (turn-left dir))]\n                                 [(update-in result here (C value))\n                                  [(M + here new-dir) new-dir]]))\n                             [init start]\n                             (reverse coll)\n                             ))))\n\n          syms (A str (take-while (partial >= limit)\n                                      (iterate ** begin)))\n          c (count syms)\n          width (int (Math/ceil (Math/sqrt c)))\n          square-flat (concat syms (repeat (- (** width) c) \\*))\n          index-to-value (A concat\n                            (MI \n                              (fn [y xs]\n                                (MI\n                                  (fn [x item]\n                                    [[x y] item])\n                                  xs))\n                              (snake square-flat width)))\n          resultwidth (dec (* 2 width))\n          new-index-to-value (M (fn [[[y x] value]]\n                                  (let [newx (+ (quot resultwidth 2)\n                                                (- y x)) \n                                        newy (+ x y)]\n                                    [[newy newx] value]))\n                                index-to-value)]\n      (M (partial A str)\n         (R (fn [result [index value]]\n              (update-in result index (C value)))\n            (spaces resultwidth)\n            new-index-to-value))\n      ))","problem":138,"user":"4dc537fd535d8a4b2fd74282"},{"code":"(fn [n1 n2]\n  (letfn [(square [a] (*' a a))\n          (sqs [a b] (take-while #(<= % b) (iterate square a)))\n          (ndigs [a b] (count (apply str (sqs a b))))\n          (sqsize [a b] (first (drop-while #(< (square %) (ndigs a b)) (range))))\n          (fillout [a b] (apply str (concat (sqs a b) (repeat (- (square (sqsize a b)) (ndigs a b)) \\*))))\n          (next-layer [cl n below?]\n            (let [addtorowents (partition 1 (range (*' n n) (+' n (*' n n)) ))\n                  addtorows (if below? addtorowents (reverse addtorowents))\n                  newrowents (range (+' n (*' n n)) (*' (inc' n) (inc' n)))\n                  newrow (if below? (reverse newrowents) newrowents)\n                  rowswithadds (if below?\n                                 (map-indexed (fn [i k] (concat (nth cl i) (nth addtorows i))) cl)\n                                 (map-indexed (fn [i k] (concat (nth addtorows i) (nth cl i))) cl))]\n              (if below?\n                (concat rowswithadds [newrow])\n                (concat [newrow] rowswithadds))))\n          (square-spiral [n]\n            (loop [c 0 res [[0]]]\n              (if (= c n)\n                res\n                (recur (inc' c) (next-layer res (inc' c) (even? c))))))\n          (get-el [s [r c]] (nth (nth s r) c))\n          (diag-lr [s n]\n            (reverse\n             (for [x (range (inc' n))\n                   y (range (inc' n))\n                   :when (and (< x (count s)) (< y (count s))  (= n (+' x y)))]\n               (get-el s [x y]))))\n          (diag-spiral [n]\n            (let [sp (square-spiral n)\n                  nds (inc' (*' 2 n))]\n              (map #(diag-lr sp %) (range nds))))\n          (make-square [a b]\n            (let [size (sqsize a b)\n                  stsize (dec' (*' 2 size))\n                  stab (fillout a b)\n                  ds (diag-spiral (dec' size))\n                  linef (fn [s c] (map #(nth s %) c))\n                  wos (map  #(linef stab %) ds)\n                  inbetspaces (fn [s] (butlast (interleave s (repeat (count s) \" \"))))\n                  ws (map inbetspaces wos)\n                  cs (map #(repeat (/ (-' stsize (count %)) 2) \" \") ws)\n                  allthings (map #(concat (nth cs %) (nth ws %) (nth cs %)) (range (count ds)))]\n              (map #(apply str %) allthings)))]\n    (make-square n1 n2)))","problem":138,"user":"5133e51ae4b0d7a043de8cf6"},{"code":"(fn [from to]\n  (let [nextsq (fn [from] (first (filter #(>= % from) (map #(* % %) (range)))))\n        sqrt (fn [nn] (last (take-while #(<= (* % %) nn) (range))))\n        sqsqs (fn sqsqs [from] (cons from (lazy-seq (sqsqs (* from from)))))\n        spiraldeltas (fn [n]\n                       (letfn [(oscill [len v] (concat (repeat len v) (lazy-seq (oscill (+ 2 len) (* -1 v)))))]\n                         (take n (map vector (oscill 2 1) (oscill 1 1)))))\n        spiralwalk (fn [start nsteps]\n                     (reductions #(vector (+ (% 0) (%2 0)) (+ (% 1) (%2 1))) start (spiraldeltas (dec nsteps))))\n        digitstr (apply str (take-while #(<= % to) (sqsqs from)))\n        paddedstr (take (nextsq (count digitstr)) (concat digitstr (repeat \\*)))\n        strlen (count paddedstr)\n        side (sqrt strlen) ;size of the rotated square\n        rows (- (* 2 side) 1) ;output rows\n        cols rows\n        startrow (* (quot (- side 1) 2) 2)\n        startcol (- side 1)\n        outchars (zipmap (spiralwalk [startrow startcol] strlen) paddedstr)\n        ]\n    (map (partial apply str) (partition rows (for [r (range rows) c (range cols)] (get outchars [r c] \\space))))))","problem":138,"user":"52015698e4b0d7096e99ddba"},{"problem":138,"code":"(fn [from to]\n  (let [unfilled (->> (take-while #(<= % to) (iterate #(* % %) from))\n                      (mapcat #(re-seq #\"\\d\" (str %))))\n        x (first (drop-while #(> (count unfilled) (* % %))\n                             (iterate inc 1)))\n        filled (concat unfilled\n                       (repeat\n                        (- (Math/pow x 2)\n                           (count unfilled))\n                        \"*\"))\n        slopes (cons [1 1]\n                     ((fn genSlope [[a b] n]\n                        (let [slope (if (pos? a)\n                                      (if (pos? b) [a (- b)] [(- a) b])\n                                      (if (neg? b) [a (- b)] [(- a) b]))]\n                          (lazy-seq (concat (repeat (inc (quot n 2)) slope)\n                                            (genSlope slope (inc n))))))\n                      [1 1] 1))\n        p&c (loop [[f & r] filled current [0 0] [sf & sr] slopes acc {}]\n              (if f\n                (recur r (map + current sf) sr (conj acc [current f]))\n                acc))\n        pm (fn [f m pos] (reduce f (map pos (keys m))))\n        hmin (pm min p&c first)\n        wmin (pm min p&c second)\n        arranged (into {} (map (fn [[[h w] c]] [[(+ h (- hmin)) (+ w (- wmin))] c]) p&c))\n        pmax (pm max arranged first)]\n    (loop [i 0 acc []]\n      (if (<= i pmax)\n        (recur (inc i) (conj acc\n                             (loop [j 0 acc \"\"]\n                               (if (<= j pmax)\n                                 (recur (inc j) (str acc (if-let [s (arranged [i j])] s \" \")))\n                                 acc))))\n        acc))))","user":"57035ccfe4b08d47c97781ef"},{"problem":138,"code":"(fn [start up]\n  (let [n (apply str (take-while #(<= % up) (iterate #(* % %) start)))\n        d (int (Math/ceil (Math/sqrt (count n))))\n        t (* d d)\n        w (dec (+ d d))\n        iy (if (even? d) (- d 2) (dec d))\n        ix (dec d)\n        y (take t (reductions + iy (mapcat #(repeat (+ % %) (if (even? %) -1 1)) (range))))\n        x (take t (reductions + ix (mapcat #(repeat (+ % % 1) (if (even? %) 1 -1)) (range))))\n        m (apply merge (for [i (range t)]\n                         {[(nth y i) (nth x i)] (get-in n [i] \\*)}))]\n    (for [i (range w)](apply str (for [j (range w)] (m [i j] \\space))))))","user":"53a01fb1e4b0ca733b9744a6"},{"code":"(fn [ & s ]\n  (letfn [\n    (sstr [s] (apply str s)) \n    (spin [ss]\n      (->> ss (map reverse) (reverse)))\n    (rotate [ss]\n      (apply (partial map list) (if (== (rem (count ss) 4) 1) (spin ss) ss)))\n    (sq [[a b]] \n      (when (<= a b) \n        (cons a (sq [(* a a) b]))))\n    (layers [s]\n      (let [is (iterate (comp inc inc) 1)]\n        (take-while #(not= \\* (first %))\n          (map take is (reductions #(drop %2 %) (concat s (repeat \\*)) is)))))\n    (line \n      ([ss s]\n        (map cons s (concat [\"\"] (map #(concat  \" \" %) ss) [\"\"]))) \n      ([[x & xs]]\n        (reduce (comp spin line) [x] xs)))\n    (pad [ss]\n      (let [paddings (map #(repeat (/ (- (count ss) (count %)) 2) \\space) ss)]\n        (map concat paddings ss paddings)\n      ))  \n    ]\n    (->> s (sq) (sstr) (layers) (line) (pad) (rotate) (map sstr))))","problem":138,"user":"50901b2ee4b0ea685a20f774"},{"problem":138,"code":"(fn[a b]\n  (let\n    [s (apply str (take-while #(<= % b) (iterate #(* % %) a)))\n     l (count s)\n     n (int (Math/ceil (Math/sqrt l)))\n     t (vec (str s (apply str (repeat (- (* n n) l) \\*))))\n     f (fn [a i j v] (assoc a i (assoc (a i) j v)))\n     ma (vec (#(repeat % (vec (repeat % \\space))) (dec (* 2 n))))\n     d [[1 1] [-1 1] [-1 -1] [1 -1]]\n     mid [(dec n) (+ n -2 (mod n 2))]\n     ps (first (reduce (fn [[ps [a b] grad step sc fst] i]\n                         (let [[grad1 step1 sc1 fst1]\n                               (cond (< step sc) [grad (inc step) sc fst]\n                                     fst [(inc grad) 1 sc false]\n                                     :else [(inc grad) 1 (inc sc) true])\n                               [dx dy] (d (mod grad1 4))]\n                           [(conj ps [a b i]) [(+ a dx) (+ b dy)] grad1 step1 sc1 fst1]))\n                       [[] mid 0 0 1 true] t))\n     ] (map (partial apply str) (reduce (fn[m [i j v]] (f m j i v)) ma ps)))\n  )","user":"56824e1be4b0945ebc182a91"},{"code":"(fn [l h]\n  (let [squares (take-while (partial >= h) (iterate #(* % %) l))\n        digs (mapcat #(seq (str %)) squares)\n        dim (int (Math/ceil (Math/sqrt (count digs))))\n        size (dec (* 2 dim))\n        x-diff (mapcat #(concat (repeat % (odd? %)) (repeat % (even? %))) (range))\n        y-diff (mapcat #(repeat (* 2 %) (odd? %)) (range))\n        inc-dec (fn [val inc?] (if inc? (inc val) (dec val)))\n        x-coords (reductions inc-dec (dec dim) x-diff)\n        y-coords (reductions inc-dec (- (dec dim) (rem (dec dim) 2)) y-diff)\n        symbol-coords (take (* dim dim) (map vector (concat digs (repeat \\*)) x-coords y-coords))\n        symbol-map (reduce #(assoc % (rest %2) (first %2)) {} symbol-coords)\n        build-row (fn [y] (apply str (for [x (range size)] (symbol-map [x y] \" \"))))]\n    (for [y (range size)] (build-row y))))","problem":138,"user":"52dd4fb4e4b09f7907dd13df"},{"code":"(fn [start max-n]\n  (let [squares (take-while #(<= % max-n) (iterate #(* % %) start))\n        digs (apply str squares)\n        diglen (count digs)\n        sqrtlen (Math/ceil (Math/sqrt diglen))\n        len (int (* sqrtlen sqrtlen))\n        chars (map str (concat digs (repeat (- len diglen) \\*)))\n        dirs (cycle [[1 1] [1 -1] [-1 -1] [-1 1]])\n        distances (take len (map #(quot % 2) (drop 2 (range))))\n        moves (mapcat (fn [n dir] (repeat n dir)) distances dirs)\n        offs (cons [0 0] (reductions (fn [loc move] (vec (map + loc move))) moves))\n        charpos (map (fn [char pos] {:char char :pos pos}) chars offs)\n        addr (apply min (map first (map :pos charpos)))\n        addc (apply min (map last (map :pos charpos)))\n        charind (map (fn [{:keys [pos] :as cp}]\n                       (assoc cp :pos (vec (map - pos [addr addc])))) charpos)\n        [rows cols] (reduce\n                     (fn [[mr mc] [r c]]\n                       [(max r mr) (max c mc)])\n                     [0 0]\n                     (map :pos charind))\n        rows (inc rows)\n        cols (inc cols)\n        board (vec (repeat rows (apply str (repeat cols \" \"))))]\n    (reduce\n     (fn [board {:keys [char pos]}]\n       (let [[r c] pos\n             orig (board r)]\n         (assoc board r (str (subs orig 0 c) char (subs orig (inc c))))))\n     board\n     charind)))","problem":138,"user":"4ffc10aae4b0678c553fc3d6"},{"problem":138,"code":"(fn ss [n nn]\n  (letfn [(get-metric [v]\n            (loop [i 0 x 1 z 1]\n              (let [y (+ i x)]\n                (if (and (<= x v) (<= v y)) (* z z)\n                    (recur (+ 2 i) (inc y) (inc z))))))\n          (make-indexed [s]\n            (letfn [(qseq [l x f s ts fs]\n                      (loop [a [0], i 0, x x, t 0, f f, s s]\n                        (if (= i l) a\n                            (let [x (f x)\n                                  i (inc i)\n                                  [t s] (if (= t ts) [0 (fs s)] [t s])\n                                  a (conj a x)]\n                              (cond (= x (- s)) (recur a i x (inc t) inc s)\n                                    (= x    s ) (recur a i x (inc t) dec s)\n                                    :else (recur a i x t f s))))))]\n              (let [sc (count s)\n                    l  (dec sc)\n                    offset (-> sc Math/sqrt int dec)]\n                (map #(vector (+ %1 offset) (+ (* -1 %2) (if (even? offset) offset (dec offset))) %3)\n                     (qseq l 2 dec 1 1 inc) (qseq l 0 dec 2 2 (comp inc inc)) s))))]\n    (let [ql (->> (loop [n n a [n]]\n                    (let [n (* n n)]\n                      (if (> n nn) a\n                          (recur n (conj a n)))))\n                  (mapcat (comp vec str))\n                  vec)\n          cql (count ql)\n          mc  (get-metric cql)\n          sz  (-> mc Math/sqrt int (* 2) dec)]\n      (->> (repeat (- mc cql) \\*)\n           (into ql)\n           make-indexed\n           (reduce (fn [a [x y v]] (assoc-in a [y x] v)) (->> \\space (repeat sz) vec (repeat sz) vec))\n           (map (partial reduce str \"\"))))))","user":"515bbcd9e4b0388ca8ca1521"},{"code":"(fn [start end]\n    (let [squares (take-while (partial >= end) (iterate #(* % %) start))\n          digits (apply str (map str squares))\n          directions (cycle [[1 1] [1 -1] [-1 -1] [-1 1]])\n          segment-lengths (map #(inc (quot % 2)) (range))\n          movements (mapcat repeat segment-lengths directions)\n          starting-points [[0 0] [-1 0]]\n          position-seqs (for [starting-point starting-points]\n                          (take (count digits)\n                                (reductions (partial map +)\n                                            starting-point\n                                            movements)))\n          abs #(if (< % 0) (- %) %)\n          bound #(reduce (fn [a [i j]] (max a (abs i) (abs j))) 0 %)\n          bounds (map bound position-seqs)\n\n          better-fit (if (< (nth bounds 0) (nth bounds 1))\n                       0\n                       1)\n\n          starting-point (nth starting-points better-fit)\n          size (nth bounds better-fit)\n          positions (nth position-seqs better-fit)\n\n          width (inc (* 2 size))\n\n          empty-board (vec (repeat width (vec (repeat width \\space))))\n          board-with-digits (reduce\n                              #(assoc-in %1 (map (partial + size) (first %2)) (second %2))\n                              empty-board\n                              (map vector positions digits))\n          board-with-stars (reduce\n                             (fn [b [i j]]\n                               (if (= \\space (get-in b [i j]))\n                                 (assoc-in b [i j] \\*) \n                                 b))\n                             board-with-digits\n                             (take-while\n                               #(get-in empty-board %)\n                               (reductions (partial map +)\n                                           (map (partial + size) starting-point)\n                                           movements)))]\n      (map (partial apply str) board-with-stars)))","problem":138,"user":"521b9f92e4b0c4ef0be8304c"},{"problem":138,"code":"(fn\n  [start end]\n  ; use OEIS A001650 to compute diamond dimensions\n  (let [squares-string (apply str\n                              (take-while #(<= % end) (iterate #(* % %)\n                                                               start)))\n        slen (count squares-string)\n        ceiling-sq-root (fn [n] (first (drop-while #(< (* % %) n) (range))))\n        ceiling-root (ceiling-sq-root slen)\n        diamond-size (dec (* 2 ceiling-root))\n        padded-slen (* ceiling-root ceiling-root)\n        padding-size (- padded-slen slen)\n        padded-string (apply str squares-string (repeat padding-size \\*))\n        strings (vec (repeat diamond-size (vec (repeat diamond-size \\space))))\n        diamond-vectors (letfn [(r [rowd cold i]\n                                  (lazy-cat (repeat i [rowd cold])\n                                            (repeat i [rowd (- cold)])\n                                            (r (- rowd) (- cold) (inc i))))]\n                          (r 1 1 1))\n        [initial-row initial-col] [(if (odd? ceiling-root)\n                                     (dec ceiling-root)\n                                     (- ceiling-root 2))\n                                   (dec ceiling-root)]]\n    (letfn [(r [s row col vs dvs]\n              (if (seq s)\n                (let [h (first s)\n                      t (rest s)\n                      [drow dcol] (first dvs)\n                      row' (+ row drow)\n                      col' (+ col dcol)\n                      dvs' (rest dvs)\n                      vs' (assoc-in vs [row col] h)]\n                  (recur t row' col' vs' dvs'))\n                vs))]\n      (map (partial apply str)\n        (r padded-string initial-row initial-col strings diamond-vectors)))))","user":"52dfc89be4b09f7907dd1405"},{"problem":138,"code":"(fn [start supreme]\n  (letfn [(iter [n]\n            (if (< supreme n) nil\n                (cons n (iter (* n n)))))\n          (digits [n]\n            ((fn digits-iter [n lower]\n               (if (< n 10) (cons n lower)\n                   (digits-iter (quot n 10) (cons (rem n 10) lower)))) n nil))\n          (closest-square [n]\n            ((fn closest-iter [k]\n               (let [s (* k k)]\n                 (if (<= n s) s\n                     (closest-iter (inc k))))) 1))\n          (expand [accum addition counter]\n            (if (odd? counter) (let [len (inc (quot (count addition) 2))\n                                     top (take len addition)\n                                     rst (drop len addition)]\n                                 (cons top (map (fn [x y] (concat x (list y))) accum rst)))\n                (let [rev (reverse addition)\n                      len (quot (count addition) 2)\n                      bord (take len rev)\n                      bottom (drop len rev)]\n                  (concat (map (fn [x y] (cons x y)) bord accum) (list bottom)))))\n          (square [accum counter rst]\n            (cond (empty? rst) accum\n                  (zero? counter) (square (list (cons (first rst) accum)) (inc counter) (rest rst))\n                  :else (let [step (inc (* 2 counter))]\n                          (square (expand accum (take step rst) counter) (inc counter) (drop step rst)))))\n          (stand [m]\n            ((fn stand-recur [m counter]\n               (if (== counter 0) nil\n                   (let [oper (take counter m)\n                         rst (drop counter m)\n                         cur (reverse (map first oper))\n                         new (concat (remove empty? (map rest oper)) rst)]\n                     (cons cur (stand-recur new (if (< counter (count new)) (inc counter) (dec counter))))))) m 1))\n          (rotate [m]\n            (if (empty? (first m)) nil\n                (cons (reduce conj nil (map first m))\n                      (rotate (map rest m)))))]\n    (let [s (mapcat digits (iter start))\n          v (concat s (repeat (- (closest-square (count s)) (count s)) \\*))\n          m (rotate (square nil 0 v))\n          result (stand m)\n          width (dec (* 2 (count (first m))))]\n      (map (fn [x] (let [centre (clojure.string/join \" \" (apply str x))\n                         side (apply str (repeat (quot (- width (count centre)) 2) \\space))]\n                     (str side centre side))) result))))","user":"58f98231e4b0438e51c2cf4c"},{"problem":138,"code":"(fn squaresquared [m n]\n        (let [digits (mapcat str (take-while #(<= % n) (iterate #(* % %) m)))\n              numberofdigits (count digits)\n              dimension (int (Math/ceil (Math/sqrt numberofdigits)))\n              multassoc (fn f [v i e]\n                          (if (or (empty? i) (empty? e))\n                            v\n                            (if (< (first i) (count v))\n                              (f (assoc v (first i) (first e)) (rest i) (rest e))\n                              (f v (rest i) (rest e)))))\n              realdiagonal? (fn g [v]\n                              (if (empty? v)\n                                true\n                                (if (empty? (rest v))\n                                  true\n                                  (if (< (mod (first v) dimension) (mod (second v) dimension))\n                                    (g (rest v))\n                                    false))))\n              auxiliary (fn [v]\n                          (if (== (mod (first v) dimension) 0)\n                            (if (== (mod (first v) (inc dimension)) 0)\n                              0\n                              (* -1 (/ 1 (mod (first v) (inc dimension)))))\n                            (mod (first v) dimension)))\n              sortfunction (fn b [x y]\n                             (if (> (auxiliary x) (auxiliary y))\n                               true\n                               false))\n              diagonals (sort sortfunction (into (filter realdiagonal? (vals (group-by #(mod % (inc dimension)) (range (* dimension dimension)))))\n                                       (mapcat (partial split-with #(not= (mod % dimension) 0))\n                                               (remove realdiagonal? (vals (group-by #(mod % (inc dimension)) \n                                                                                     (range (* dimension dimension))))))))]\n          (loop [start (into (vec digits) (repeat (- (* dimension dimension) numberofdigits) \\*))\n                 result (assoc (vec (range (* dimension dimension)))\n                               (int (+ (* dimension (int (Math/floor (/ (dec dimension) 2)))) (int (Math/ceil (/ (dec dimension) 2)))))\n                               (first start))\n                 current (int (+ (* dimension (int (Math/floor (/ (dec dimension) 2)))) (int (Math/ceil (/ (dec dimension) 2)))))\n                 lengthcounter 1 direction :down]\n            (if (empty? start)\n              (for [w diagonals]\n                (apply str (concat (repeat (- dimension (count w)) \\space)\n                                   (interpose \\space (for [q w]\n                                                      (get result q)))\n                                   (repeat (- dimension (count w)) \\space))))\n                   (if (= direction :left)\n                     (recur (drop lengthcounter start) \n                            (multassoc result (iterate dec current) (take lengthcounter start))\n                            (nth (rest (iterate dec current)) (dec lengthcounter)) (inc lengthcounter) :up)\n                     (if (= direction :right)\n                       (recur (drop lengthcounter start)\n                              (multassoc result (iterate inc current) (take lengthcounter start))\n                              (nth (rest (iterate inc current)) (dec lengthcounter)) (inc lengthcounter) :down)\n                       (if (= direction :up)\n                         (recur (drop lengthcounter start)\n                                (multassoc result (iterate #(- % dimension) current) (take lengthcounter start))\n                                (nth (rest (iterate #(- % dimension) current)) (dec lengthcounter)) lengthcounter :right)\n                         (recur (drop lengthcounter start)\n                                (multassoc result (iterate #(+ % dimension) current) (take lengthcounter start))\n                                (nth (rest (iterate #(+ % dimension) current)) (dec lengthcounter)) lengthcounter :left))))))))","user":"532727bae4b09d4e7a9b54fa"},{"problem":138,"code":"(fn [start end]\n(let [squares (map #(* % %) (range))\n\t  odd-sqr (take-nth 2 (rest squares))\n      even-sqr  (take-nth 2 (drop 2 squares))\n\t  create-spiral (fn [c]\n\t\t\t\t\t(let [middle-row \n\t\t\t\t\t\t\t\t(if (even? c)\n\t\t\t\t\t\t\t\t\t(concat (reverse (take (quot c 2) even-sqr)) (map inc (take (quot c 2) odd-sqr)))\n\t\t\t\t\t\t\t\t\t(concat (reverse (map inc (take (quot c 2) even-sqr))) (take (inc (quot c 2)) odd-sqr))\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t]\n\t\t\t\t\t(let [bottom (letfn [(remove-mid-dec [l]\n\t\t\t\t\t\t(if (even? (count l))\n\t\t\t\t\t\t(concat (map dec (take (quot (count l) 2) l)) (map inc (take-last (- (quot (count l) 2) 1) l)))\n\t\t\t\t\t\t(concat (map dec (take (quot (count l) 2) l)) (map inc (take-last (quot (count l) 2) l) ))\n\t\t\t\t\t\t))]\n\t\t\t\t\t\t(take (if (even? c) c (dec c)) (iterate remove-mid-dec (if (even? c) middle-row (#(concat (map dec (take (quot (count %) 2) %)) (map inc (take-last (quot (count %) 2) %) )) (take (dec c) middle-row)))))\n\t\t\t\t\t\t)\n\t\t\t\t\t\tupper (letfn [(remove-mid-inc [l]\n\t\t\t\t\t\t(if (even? (count l))\n\t\t\t\t\t\t(concat (map inc (take (quot (count l) 2) l)) (map dec (take-last (- (quot (count l) 2) 1) l)))\n\t\t\t\t\t\t(concat (map inc (take (quot (count l) 2) l)) (map dec (take-last (quot (count l) 2) l) ))\n\t\t\t\t\t\t))]\n\t\t\t\t\t\t(take (if (even? c) (dec c) c) (iterate remove-mid-inc (if (even? c) (#(concat (map inc (take (quot (count %) 2) %)) (map dec (take-last (inc (quot (count %) 2)) %))) (take-last (dec c) middle-row)) middle-row)))\n\t\t\t\t\t\t)\n\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t\t]\n\t\t\t\t\t\t(concat (reverse upper) bottom)\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t\t)\n\t\n\t\tnumbers (take-while #(>= end %) (iterate #(* % %) start))\n\t\tnumbers-seq (flatten (map #(seq (str %)) numbers))\n\t\tnext-square (count (take-while #(> (count numbers-seq) %) squares))\n\t\tspiraled-numbs (map (fn [x] (map #(if (>= (count numbers-seq) %) (nth numbers-seq (dec %)) \\*) x)) (create-spiral next-square)) \n\t\tformat (fn [l] (str (apply str (repeat (- next-square (count l)) \" \")) (reduce #(str %1 \" \" %2) l) (apply str (repeat (- next-square (count l)) \" \")) ))\n\t]\n\t(map format spiraled-numbs)\n)\n)","user":"57011eb3e4b08d47c97781d1"},{"problem":138,"code":"(fn squares [start end]\n  (let [squares (loop [current start res []]\n                  (if (> current end) res\n                    (recur (* current current) (conj res current))))\n        str_squares (map str squares)\n        matrix_size (let [num_of_digits (apply + (map count str_squares))]\n                      (int (Math/sqrt (first (filter #(>= % num_of_digits) (map #(* % %) (range)))))))\n        empty_matrix (fn [m_size c] (vec (replicate m_size (vec (replicate m_size c)))))\n        get-center (let [m_count (dec matrix_size)]\n                     (if (even? m_count)\n                       [(/ m_count 2) (/ m_count 2)]\n                       [(/ (dec m_count) 2) (/ (dec m_count) 2)]))\n        num_seq_stream (apply concat str_squares)\n        build_path (flatten\n                     (loop [counter 1 res [] directions (cycle [:right :down :left :up])]\n                         (if (= counter matrix_size) (concat res (map #(repeat counter %) (take 3 directions)))\n                           (recur (inc counter) (concat res (map #(repeat counter %) (take 2 directions))) (drop 2 directions)))))\n        new_position (fn [[a b] movement]\n                       (cond\n                         (= movement :up) [(+ a -1) b]\n                         (= movement :down) [(+ a 1) b]\n                         (= movement :right) [a (+ b 1)]\n                         (= movement :left) [a (+ b -1)]))\n        build_matrix (loop [matrix (empty_matrix matrix_size \\*) current_position get-center path build_path numbers num_seq_stream]\n                       ;(println current_position (new_position current_position (first path)) (first path) (first numbers))\n                       (if (or (empty? path) (nil? numbers)) matrix\n                         (do\n                           (recur (update-in matrix current_position (fn [a] (first numbers)))\n                                  (new_position current_position (first path)) \n                                  (next path) \n                                  (next numbers)))))\n        build_shifted_matrix (fn [matrix length]\n                               (let [shift (fn [init values length]\n                                             (loop [v (flatten values) c 0 res []]\n                                               (cond\n                                                 (= c length) res\n                                                 (empty? v) (recur v (inc c) (conj res -1))\n                                                 (< c init) (recur v (inc c) (conj res -1))\n                                                 :else (recur (rest v) (inc c) (conj res (first v))))))]\n                                 (map-indexed #(shift %1 %2 length) matrix)))\n        shifted_values_sequence (fn [matrix]\n                                  (for [y (range (count (first matrix))) x (range (dec (count matrix)) -1 -1)\n                                        :when (not= -1 (get-in (vec matrix) [x y]))]\n                                    (get-in (vec matrix) [x y])))\n        gen-positions-rotated-matrix (fn [n]\n                                       (let [columns (let [g (fn [v]\n                                                               (distinct (flatten (map (fn [n] [(dec n) (inc n)]) v))))\n                                                           values (loop [seed [(/ (dec n) 2)] res [seed] c (/ (dec n) 2)]\n                                                                    (if (zero? c)\n                                                                      res\n                                                                      (recur (g seed) (conj res (g seed)) (dec c))))]\n                                                       (concat values (reverse (butlast values))))]\n                                         (map-indexed (fn [x y] (map #(vector x %) y)) columns)))\n        build-rotated-matrix (let [m1 (empty_matrix (dec (* matrix_size 2)) \\ )\n                                   s1 (shifted_values_sequence (build_shifted_matrix build_matrix (dec (* matrix_size 2))))\n                                   g1 (apply concat (gen-positions-rotated-matrix (dec (* matrix_size 2))))]\n                               ;(println m1 s1 g1)\n                               (loop [m m1 g g1 s s1]\n                                 (if (empty? g) m \n                                   (recur (update-in m (first g) (fn [a] (first s)))\n                                          (rest g)\n                                          (rest s)))))]\n    (map #(apply str %) build-rotated-matrix)))","user":"5046f909e4b03b02161376b5"},{"code":"(fn transform\n  ([start end]\n    (let [square (fn [x]\n                   (* x x))\n          fn-squares (fn fn-squares [start end]\n                       (when (<= start end)\n                         (cons start (lazy-seq (fn-squares (square start) end)))\n                       )\n                     )\n          squares (fn-squares start end)\n          tokens (let [digits (mapcat str squares)\n                        size (count digits)\n                        dim (first (drop-while #(< (* % %) size) (range)))]\n                    (concat digits (repeat (- (square dim) size) \\*))\n                 )\n          nb-tokens (count tokens)\n          length (dec (* 2 (int (Math/sqrt nb-tokens))))\n          board (mapv (fn [y] (mapv (fn [x] \\space) (range length))) (range length))\n          position [(dec (int (Math/ceil (/ length 2))))\n                    (if (odd? nb-tokens)\n                      (dec length)\n                      0)]]\n      (->> (transform board length position nil (reverse tokens))\n           (map #(apply str %)))\n    )\n  )\n  ([board length position delta tokens]\n    (if (not-empty tokens)\n      (let [next-board (assoc-in board position (first tokens))\n            next-delta (cond\n                         (zero? (first position)) [1 -1]\n                         (zero? (second position)) [1 1]\n                         (= (dec length) (first position)) [-1 1]\n                         (= (dec length) (second position)) [-1 -1]\n                         :else delta)\n            next-position (mapv + position next-delta)\n            next-unvisited-position (if (= \\space (get-in board next-position))\n                                      next-position\n                                      (mapv + position (case next-delta\n                                                        [1 -1] [1 1]\n                                                        [1 1] [-1 1]\n                                                        [-1 1] [-1 -1]\n                                                        [-1 -1] [1 -1])))]\n        (transform next-board length next-unvisited-position (mapv - next-unvisited-position position) (rest tokens))\n      )\n      board)\n  )\n)","problem":138,"user":"5272d4b7e4b03e8d9a4a7453"},{"problem":138,"code":"(fn sqsq [bgn end]\n (letfn [\n\n(dgtz [num] \n   (loop [acc (list) work num]\n    (if (zero? work) \n     (if (empty? acc) \n      [0] \n      (vec acc)) \n     (let [lst (rem work 10)\n           rst (quot work 10)\n        newacc (cons lst acc)]\n      (recur newacc rst))) ))\n\n(sq-seq [b e] \n (take-while #(<= % e) \n  (iterate #(* % %) b)))\n\n(line-dgts [ds]\n (let [dgvs (map dgtz ds)\n       dgs \n        (reduce \n         (fn [acc b] \n          (into acc b))\n         [] dgvs)]\n   dgs))\n\n(squares []\n (map #(* % %) \n      (drop 1 (range))))\n\n(near-sq [d]\n (first\n  (drop-while #(< % d) (squares))))\n\n\n(fill-stars [vs]\n (let [ln (count vs)\n       upln (near-sq ln)\n       exn (- upln ln)]\n   (if (zero? exn)\n     vs\n     (into vs (repeat exn \\*)))\n  ))\n\n (make-dgts [a b]\n  (-> (sq-seq a b)\n      (line-dgts ,,,)\n      (fill-stars ,,,)))\n\n(put-right [[vv bs]]\n (let [height (count vv)\n       line (take height bs)\n       brst (drop height bs)\n       newvv \n        (vec (map conj vv line))]\n   [newvv brst]))\n\n(put-bottom [[vv bs]]\n (let [width (count (first vv))\n       line (vec (reverse (take width bs)))\n       brst (drop width bs)\n       newvv (conj vv line)]\n  [newvv brst]))\n\n(put-left [[vv bs]]\n (let [height (count vv)\n       line (vec (reverse (take height bs)))\n       brst (drop height bs)\n       newvv (vec (map (fn [x v] (into [x] v)) line vv))]\n  [newvv brst]))\n\n(put-top [[vv bs]]\n (let [width (count (first vv))\n       line (vec (take width bs))\n       brst (drop width bs)\n       newvv (into [line] vv)]\n  [newvv brst]))\n\n(wikln [bs]\n (loop [acc [[(first bs)]]\n        buf (rest bs)]\n  (if (empty? buf)\n    acc\n    (let [[ac2 bf2] \n      (put-bottom (put-right [acc buf]))]\n     (if (empty? bf2) \n       ac2 \n       (let [[newacc newbuf] (put-top (put-left [ac2 bf2]))]\n         (recur newacc newbuf)))))))\n\n(rotate45 [vv]\n (if (= 1 (count vv))\n  vv\n (loop [acc [] work vv]\n  (if (empty? work)\n   acc\n   (if (empty? acc)\n    (let [newacc [[(first (first vv))]]\n          rwork (into [(vec (rest (first work)))] (rest work))]\n     (recur newacc rwork))\n    (if (empty? work)\n      acc\n    (let \n      [width (count (peek acc))\n       vsize (count work) \n       lineln \n           (if (< width vsize) \n             (inc width) \n             (dec width))\n       slice (map first (take lineln work))\n       nxtline (vec (reverse slice))\n       newacc (conj acc nxtline)\n       rsthead-all (map rest (take lineln work))\n       rsthead (vec (remove empty? rsthead-all))\n       rsttail (drop lineln work)\n       rst (into rsthead rsttail)\n       ]\n     (recur newacc rst))))))) )\n\n(cent-sp [w vc]\n (let [fill-ch \\space\n       ln (count vc)\n       delta (- w ln)\n       halfd (quot delta 2)\n       restd (- delta halfd)\n       sp-v-sp (-> (vec (repeat halfd fill-ch)) (into ,,, vc) (into ,,, (repeat restd fill-ch)))]\n  (if (zero? delta) \n    (clojure.string/join vc) \n    (clojure.string/join sp-v-sp))))\n\n(spaced-rect [vv]\n (let [viv (map (partial interpose \\space) vv)\n       width (reduce (fn [z b] (if (< z (count b)) (count b) z)) 0 viv)]\n  (vec (map (partial cent-sp width) viv))\n ))\n ]\n (-> (make-dgts bgn end) \n     (wikln ,,,)\n     (rotate45 ,,,)\n     (spaced-rect ,,,)) ))","user":"57f9011ee4b0d3187e900935"},{"problem":138,"code":"(fn problem138\n  [from to]\n  (letfn [(rotate45\n            [matrix filler]\n            (let [old-size (count matrix)\n                  new-size (dec (* 2 (count matrix)))]\n              (for [row (range new-size)]\n                (for [col (range new-size)]\n                  (get-in matrix [(/ (+ (- row col) (dec old-size)) 2)\n                                  (/ (- (+ row col) (dec old-size)) 2)] filler)))))\n          (addSE\n            [matrix]\n            (let [NE (inc (last (first matrix)))\n                  SE (+ (count matrix) NE)\n                  SW (+ (count (first matrix)) SE)]\n              (-> (mapv conj matrix (range NE SE))\n                  (conj (vec (reverse (range SE (inc SW))))))))\n          (addNW\n            [matrix]\n            (let [SW (inc (first (last matrix)))\n                  NW (+ (count matrix) SW)\n                  NE (+ (count (first matrix)) NW)]\n              (->> (mapv #(vec (cons %1 %2))\n                         (reverse (range SW NW)) matrix)\n                   (cons (vec (range NW (inc NE))))\n                   vec)))\n          (spiral-matrix\n            [n]\n            (nth (->> (iterate (fn [[matrix parity]]\n                                 (if parity\n                                   [(addSE matrix) (not parity)]\n                                   [(addNW matrix) (not parity)]))\n                               [[[0]] 0])\n                      (map first))\n                 (dec n)))\n          (spiral\n            [xs filler]\n            (let [matrix (spiral-matrix (int (Math/ceil (Math/sqrt (count xs)))))]\n              (mapv (fn [row]\n                      (mapv (fn [i] (get xs i filler)) row))\n                    matrix)))]\n    (let [xs (vec (flatten (map (comp seq str)\n                                (take-while #(<= % to)\n                                            (iterate #(* % %) from)))))]\n      (map #(apply str %) (-> (spiral xs \\*)\n                              (rotate45 \\space))))))","user":"60460824e4b02d28681c77bc"},{"problem":138,"code":"(fn [start end]\n    (let [squares (take-while #(<= % end) (iterate #(* % %) start))\n          d (fn d [n]\n            (if (= n 0)\n              []\n              (conj (d (quot n 10)) (mod n 10))))\n          digits (mapcat d squares)\n          i (int (Math/sqrt (dec (count digits))))\n          digits (take (* (inc i) (inc i)) (concat digits (repeat \\*)))\n          s (inc (* 2 i))]\n      (loop\n        [p          [(* 2 (int (/ i 2))) (nth (range) i)]\n         digits     digits\n         board      (vec (repeat s (vec (repeat s \\space))))\n         directions (cycle [[1 1] [1 -1] [-1 -1] [-1 1]])\n         counts     (drop 2 (mapcat #(repeat 2 %) (range)))\n         counter    0]\n        (if (empty? digits)\n          (vec (map clojure.string/join board))\n          (let [n (= (inc counter) (first counts))]\n            (recur\n              (map + p (first directions))\n              (rest digits)\n              (assoc-in board p (first digits))\n              (if n (rest directions) directions)\n              (if n (rest counts) counts)\n              (if n 0 (inc counter))))))))","user":"5a2df4a0e4b09cafd31c7f74"},{"problem":138,"code":"(let [dirs {[1 1] [1 -1] [1 -1] [-1 -1] [-1 -1] [-1 1] [-1 1] [1 1]}]\n  (letfn\n    [(n->d [n]\n       (loop [q (quot n 10) res (list (mod n 10))]\n         (if (zero? q) res (recur (quot q 10) (conj res (mod q 10))))))\n     (seq-digs [s f]\n       (->> s\n            (iterate #(* % %))\n            (take-while #(<= % f))\n            (mapcat n->d)\n            vec\n            (iterate #(conj % '*))\n            (filter #(zero? (rem (Math/sqrt (count %)) 1)))\n            first))\n     (step [{:keys [grid start dir] :as m} v]\n       (let [ndir (if (get-in grid (mapv + start (dirs dir))) dir (dirs dir))]\n         (-> m\n             (update-in [:mn] #(mapv min % start))\n             (update-in [:mx] #(mapv max % start))\n             (update-in [:grid] assoc-in start v)\n             (assoc-in [:dir] ndir)\n             (update-in [:start] #(mapv + % ndir)))))\n     (solve-grid [digs]\n       (reduce step {:start [0 0] :grid {} :dir [-1 1] :mn [0 0] :mx [0 0]} digs))\n     (m->g [{g :grid [min-r min-c] :mn [max-r max-c] :mx}]\n       (for [r (range min-r (inc max-r))]\n         (apply str\n                (for [c (range min-c (inc max-c))]\n                  (get-in g [r c] \" \")))))]\n    (fn sqsq [s f]\n      (->> (seq-digs s f) solve-grid m->g))))","user":"57b3efb1e4b0fbc9809a278a"},{"problem":138,"code":"(fn [l h] \n  (let [\n        s (loop [l1 l r [] ] (if (> l1 h) (vec (clojure.string/join r)) (recur (int (Math/pow l1 2)) (conj r l1))))\n        cnt (count s)\n        x (int (Math/ceil (Math/sqrt cnt)))\n        t (dec x)\n        tup (if (odd? x) t (dec t))\n        tdn (if (odd? x) (inc t) t)       \n        cap (int (Math/pow x 2))\n        dim (- (* x 2) 1)\n        mat (vec (repeat dim (vec (repeat dim \\space))))]\n   (loop [i 0 r tup c t m mat dr 1 dc 1]\n      (if (>= i cap) \n        (map (partial apply str) m)  \n        (recur (inc i) (+ r dr) (+ c dc) (assoc-in m [r c] (if (>= i cnt) \\* (get s i)))\n          (if (= t (+ c dc)) (* dr -1) dr) \n          (cond (and (= dc 1) (= tdn (+ r dr))) -1 \n                (and (= dc -1) (= tup (+ r dr))) 1\n                :else dc))))))","user":"5b919d9de4b0c0b3ffbd4a24"},{"problem":138,"code":"(fn [a b]\n  (let [s (concat \n            (apply str \n                   (take-while #(<= % b)\n                               (iterate #(* % %) a)))\n            (repeat \\*))\n        n (first (filter \n                   #(and (== (Math/sqrt %) (int (Math/sqrt %))) (= \\* (nth s %)))\n                   (range)))\n        m (dec (* 2 (Math/sqrt n)))\n        t (take n s)\n        z (reduce \n            (fn [[w n s] x]\n              (if (= s :l)\n                (case n\n                  -2 [(concat [(str x)] w) 1 :r]\n                  -1 [(concat [(str x)] w) -2 :l]\n                  [(assoc (vec w) n (str x (nth w n))) (dec n) :l])\n                (cond\n                  (= n (+ 1 (count w))) [(concat w [(str x)]) (- n 2) :l]\n                  (= n (count w)) [(concat w [(str x)]) (+ n 2) :r]\n                  :else [(assoc (vec w) n (str (nth w n) x)) (inc n) :r])))\n            [[] -2 :l] t)]\n    (vec (map (comp (fn [st]\n           (apply str\n                  (concat \n                    (repeat (/ (- m (count st)) 2) \\ )\n                    st\n                    (repeat (/ (- m (count st)) 2) \\ ))))\n               #(interpose \\  %)) (first z)))))","user":"55625903e4b0c656e3ff17d7"},{"problem":138,"code":"(fn [s e]\n  (let\n    [\n     digits \n     (->>\n       (iterate #(* % %) s)\n       (take-while #(<= % e)) \n       (mapcat str)\n      )\n     n1 (count digits)\n     n2 (-> n1 Math/sqrt Math/ceil int) ;; internal square dims\n     n3 (+ n2 (dec n2)) ;; board dims\n     brd (->> \\space (repeat n3) vec (repeat n3) vec) ;; board\n     x (/ (dec n3) 2) ;; start col\n     y (- n2 (if (odd? n2) 1 2)) ;; start row\n     patt \n     (fn [n]\n       (let [a (if (odd? n) 1 -1) b (- a)]\n         (concat [[a a]] (repeat n [a b]) (repeat n [b b]))\n     ) )\n     ]\n    (->>\n     (concat digits (repeat \\*))\n     (interleave  (concat [[y x]] (rest (mapcat patt (range n2)))))\n     (partition 2)\n     (reduce \n      (fn [[board curr-pos][delta-pos digit]] \n        (let [new-pos (map + curr-pos delta-pos)] \n          [(assoc-in board new-pos digit) new-pos]))\n      [brd [0 0]]\n      )\n     first\n     (map #(apply str %))\n     )\n   ) ;;endlet\n)","user":"5281a445e4b0757a1b17143a"},{"problem":138,"code":"(fn [a b]\n  (let [m map e (partial apply str) d dec k \\  l repeat j assoc-in i iterate h rest u count\n        s (e (take-while #(<= % b) (i #(* % %) a)))\n        n (-> s u Math/sqrt Math/ceil int)]\n    (m e\n      (loop [c (m d [(if (odd? n) n (d n)) n])\n             t (j (nth (i #(vec (l (d (* 2 n)) %)) k) 2) c (first s))\n             [p & r] (h (e s (l (- (* n n) (u s)) \\*)))\n             [q w :as y] (cycle [[-1 1] [1 1] [1 -1] [-1 -1]])]\n        (if-not p\n          t\n          (let [g (if (= k (get-in t (m + c w))) w q)\n                v (m + c g)]\n            (recur\n              v\n              (j t v p)\n              r\n              (if (= g w) (h y) y))))))))","user":"52b02329e4b0c58976d9acc5"},{"code":"(fn __ [d m]\n  (let [r-angle (- (/ Math/PI 4))\n        r-pt \n          (fn r-pt [[x y]]\n            (cond\n              (= -3 x y) [-3 0]\n              (= 3 x y) [3 0]\n              (and (= -3 x) (= 3 y)) [0 3]\n              (and (= 3 x) (= -3 y)) [0 -3]\n              :else [(int (- (* x (Math/cos r-angle)) (* y (Math/sin r-angle))))\n                     (int (+ (* x (Math/sin r-angle)) (* y (Math/cos r-angle))))]))\n        lower-right\n          (fn lower-right [square additions]\n            (let [size (count square)\n                  [_ bottom-range] (split-at size additions)]\n              (conj (into [] (map conj square additions)) \n                    (into [] (reverse bottom-range)))))\n        upper-left\n          (fn upper-left [square additions]\n            (let [size (count square)\n                  [left-range top-range] (split-at size additions)]\n              (vec (cons (vec top-range)\n                         (map #(vec (cons %1 %2)) (reverse left-range) square)))))\n        next-layer\n          (fn next-layer [square additions]\n            (if (= (mod (count additions) 4) 3)\n                (lower-right square additions)\n                (upper-left square additions)))\n        make-squares\n          (fn make-squares [inputs]\n            (reduce next-layer [(first inputs)] (rest inputs)))\n        make-seq\n          (fn make-seq [begin end]\n            (let [ints (take-while #(<= % end) (iterate #(* % %) begin))\n                  as-chars (mapcat str ints)\n                  square-area (first (drop-while #(< % (count as-chars)) \n                                                 (reductions + (iterate #(+ 2 %) 1))))\n                  un-partitioned (concat as-chars (repeat (- square-area (count as-chars)) \\*))]\n              (loop [s un-partitioned n 1 out []]\n                (if (seq s)\n                    (let [[pre post] (split-at n s)]\n                      (recur post (+ n 2) (conj out (vec pre))))\n                    out))))\n        pad-with-spaces\n          (fn pad-with-spaces [s]\n            (vec (interpose (vec (repeat (+ 2 (count s)) nil)) (map #(vec (interpose nil %)) s))))\n        resolve-square\n          (fn resolve-square [s]\n            (let [half (int (/ (count s) 2))\n                  map-coords (for [x (range 0 (count s)) \n                                   y (range 0 (count s))]\n                               [x y])\n                  to-traditional-coords (vec (reverse s))\n                  new-vec (reduce (fn [m [x y]]\n                                    (if-let [sym (get-in to-traditional-coords [x y])]\n                                      (let [new-coords (r-pt [(- x half) (- y half)])\n                                            new-indices (map #(+ half %) new-coords)]\n                                        (assoc-in m new-indices sym))\n                                      m))\n                                  (vec (repeat (count s) (vec (repeat (count s) \\space))))\n                                  map-coords)]\n              new-vec))]\n    (apply map str (resolve-square (pad-with-spaces (make-squares (make-seq d m)))))))","problem":138,"user":"52463059e4b09dbe66b56198"},{"problem":138,"code":"(fn [s e]\n    (let [res (apply str (take-while #(<= % e) (iterate #(* % %) s)))\n          rescount (count res)\n          reslength (first (filter #(>= % rescount) (map #(* % %) (iterate inc 1))))\n          res (apply str res (repeat (- reslength rescount) \"*\"))\n          rotate-axis (fn [op] \n                        (cond \n                          (= op [inc dec]) [dec dec] \n                          (= op [dec dec]) [dec inc]\n                          (= op [dec inc]) [inc inc] \n                          (= op [inc inc]) [inc dec]))\n          new-id (fn [op id] \n                   (mapv #((first %) (last %)) (partition 2 (interleave op id))))\n          gen-sqre-fmt (fn [s] \n                         (loop [res {[0 0] (first s)}\n                                idxy [0 0]\n                                op [inc inc]\n                                sr (rest s)]\n                           (if (empty? sr) \n                             (let [min-res-key-x (apply min (map first (keys res)))\n                                   min-res-key-y (apply min (map second (keys res)))]\n                               (apply hash-map (mapcat #(list [(- (first (first %)) min-res-key-x) (- (second (first %)) min-res-key-y)] (second %)) res)))\n                             (let [new-op (rotate-axis op)\n                                   new-op (if (res (new-id new-op idxy)) op new-op)\n                                   newid (new-id new-op idxy)]\n                               (recur (assoc res newid (first sr))\n                                      newid\n                                      new-op\n                                      (rest sr))))))\n          res (gen-sqre-fmt res)\n          max-res-key-x (apply max (map first (keys res)))\n          max-res-key-y (apply max (map second (keys res)))]\n      (reverse \n        (for [y (range (inc max-res-key-y))]\n          (apply str (for [x (range (inc max-res-key-x))] (if (res [x y]) (res [x y]) \" \")))))))","user":"5071b614e4b0e3170b5a867d"},{"code":"(fn [a b]\n\t(let [sq (fn sq [a b] (if (> a b) '() (cons a (sq (* a a) b))))\n\t\t\t\tnums (sq a b)\n\t\t\t\tcs (apply str nums)\n\t\t\t\tissq (fn [n] (loop [a 1] (if (> (* a a) n) false (if (= (* a a) n) true (recur (inc a))))))\n\t\t\t\tfill (fn fill [s] (if (issq (count s)) s (fill (str s \"*\"))))\n\t\t\t\tss (fill cs)\n\t\t\t\tmat (loop [square (-> (first ss) list list)\n\t\t\t\t\t\t\t\t\t cs (rest ss)]\n\t\t\t\t\t\t\t(let [len (count square)\n\t\t\t\t\t\t\t\t\t\tadd (+ (* len 2) 1)\n\t\t\t\t\t\t\t\t\t\tacs (take add cs)\n\t\t\t\t\t\t\t\t\t\trcs (drop add cs)]\n\t\t\t\t\t\t\t\t(if (empty? cs)\n\t\t\t\t\t\t\t\t\tsquare\n\t\t\t\t\t\t\t\t\t(if (= 0 (mod len 2))\n\t\t\t\t\t\t\t\t\t\t(recur\n\t\t\t\t\t\t\t\t\t\t (concat (list (drop len acs)) (map concat (reverse (map list (take len acs))) square))\n\t\t\t\t\t\t\t\t\t\t rcs)\n\t\t\t\t\t\t\t\t\t\t(recur\n\t\t\t\t\t\t\t\t\t\t (concat (map concat square (map list acs)) (-> (drop len acs) reverse list))\n\t\t\t\t\t\t\t\t\t\t rcs)))))\n\t\t\t\trows (concat\n\t\t\t\t\t\t\t(map\n\t\t\t\t\t\t\t (fn [a]\n\t\t\t\t\t\t\t\t (map #(nth (nth mat (- a %1)) %1) (range (inc a))))\n\t\t\t\t\t\t\t (range (count mat)))\n\t\t\t\t\t\t\t(->\n\t\t\t\t\t\t\t (map\n\t\t\t\t\t\t\t\t(fn [a]\n\t\t\t\t\t\t\t\t\t(reverse (map #(nth (nth mat (+ (count mat) (- 0 a 1) %1)) (- (count mat) %1 1)) (range (inc a)))))\n\t\t\t\t\t\t\t\t(range (count mat)))\n\t\t\t\t\t\t\t reverse\n\t\t\t\t\t\t\t rest))\n\t\t\t\tpad (fn pad [s l] (if (< (count s) l) (pad (concat \" \" s \" \") l) s))\n\t\t\t\twid (- (* (count mat) 2) 1)]\n\t\t(map #(apply str (pad (interpose \\space %) wid)) rows)))","problem":138,"user":"52586d24e4b0cb4875a45cb0"},{"code":"(fn [from to]\n  (letfn [(abs [x]\n               (if (< x 0)\n                 (- x)\n                 x))\n          (sign [x]\n                (if (< x 0)\n                  -1\n                  +1))\n            \n          (f [x]\n             (if (zero? x)\n               (list (vector 0 0))\n               (concat (into [] (map vector (repeat (abs x) (sign x)) (repeat (abs x) (sign x)) ))\n                       (into [] (map vector (repeat (abs x) (- (sign x ))) (repeat (abs x) (sign x)))))))                           \n          (s [ ]\n            (mapcat #(f (* % %2)) (iterate #(- %) 1) (iterate dec 0)))\n          (reallen [len]\n                   (let [x (first (take 1 (filter #(>= (* % %) len) (iterate inc 1))))]\n                     (* x x)))\n          (chars [from to]\n                 (let [ss (mapcat (comp seq str)\n                                  (take-while #(<= % to ) (iterate #(* % %) from)))]\n                   (take (reallen (count ss))\n                         (concat ss\n                                 (repeat \\*)))))\n          (adding [v1 v2]\n                  (into [] (map + v1 v2)))\n          (fstart\n            ([ ]\n              (fstart (s)))\n            ([v]\n              (fstart [0 0] v))\n            ([start v ]\n              (if (empty? v)\n                nil\n                (let [ad (adding start (first v))]\n                  (cons ad (lazy-seq (fstart ad (rest v))))))))\n          (get45map [from to]\n                    (zipmap (fstart) (chars from to)))\n          (empty-string [s]\n                        (if (string? s)\n                          (empty? (filter #(not= % \\space) (seq s)))\n                          false))\n          (final [from to]\n            (let [mp (get45map from to)\n                  r (int (Math/sqrt (count mp)))]\n              (map #(if (not (string? %))\n                      (str %)\n                      %)\n                   (filter (comp false? empty-string) (map #(reduce str %)\n                                                           (map (fn [item] (map #(get mp [% item ] \" \") (range (-  (dec r))   r))) (range (- (dec r)) (inc r) )))))))]\n         (final from to)))","problem":138,"user":"50e87427e4b0ebbe794eb7e8"},{"code":"(fn [x y] ( let [\n\t\ts (apply str (map (fn [w] (str (int w))) (filter (fn [k] (<= k y)) (take 10 (map (fn [z] (Math/pow x (Math/pow 2 z))) (range))))))\n\t\tsc (count s)\n\t\tss (apply str s \"********\")\n\t\tss1 (if (or (= sc 1) (= sc 4) (= sc 9) (= sc 16) ) s (if (or (= sc 2) (= sc 3)) (subs ss 0 4) (if (and (> sc 4) (< sc 9)) (subs ss 0 9) (if (and (> sc 9) (< sc 16)) (subs ss 0 16)  )  ) ) )\n\t\tss2 (str \" \" ss1)\n\t\t]\n\t\t\t(if (= (count ss1) 1) (vector ss1) \n\t\t\t\t(if (= (count ss1) 4) (map (fn [h] (apply str h)) (partition 3 (map (fn [k] (.charAt ss2 k))  [0 1 0 4 0 2 0 3 0] )))\n\t\t\t\t\t(if (= (count ss1) 9) (map (fn [h] (apply str h)) (partition 5 (map (fn [k] (.charAt ss2 k))  [0 0 7 0 0 0 6 0 8 0 5 0 1 0 9 0 4 0 2 0 0 0 3 0 0] )))\n\t\t\t\t\t\t(if (= (count ss1) 16) (map (fn [h] (apply str h)) (partition 7 (map (fn [k] (.charAt ss2 k))  [0 0 0 7 0 0 0 0 0 6 0 8 0 0 0 5 0 1 0 9 0 16 0 4 0 2 0 10 0 15 0 3 0 11 0 0 0 14 0 12 0 0 0 0 0 13 0 0 0] )))\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t)\n\t)","problem":138,"user":"5296008fe4b02ebb4ef7502a"},{"problem":138,"code":"(fn [x cutoff]\n  (let [square #(* % %)\n        nums   (take-while (partial >= cutoff) (iterate square x))\n        digits (mapcat str nums)\n        total  (count digits)\n        side   (int (Math/ceil (Math/sqrt total)))\n        width  (+ side (dec side))\n        mid    (dec side)\n        >idx   (fn [i j] (let [di (- i mid (mod side 2))\n                              dj (- j mid)\n                              edge (+ (Math/abs di)\n                                      (Math/abs dj))\n                              inner (square (max 0 (dec edge)))\n                              outer\n                              (cond\n                               ;; TL\n                               (and (< di 0) (<= dj 0))\n                               (dec (- di))\n                               ;; TR\n                               (and (<= di 0) (> dj 0))\n                               (dec (+ edge dj))\n                               ;; BR\n                               (and (> di 0) (>= dj 0))\n                               (dec (+ (* 2 edge) di))\n                               ;; BL\n                               (and (>= di 0) (< dj 0))\n                               (dec (- (* 3 edge) dj))\n\n                               :else 0)]\n                          (+ inner outer)))\n        get-s  (fn [i j]\n                 (if (= 0 (mod (+ i j side) 2))\n                   \" \"\n                   (let [idx (>idx i j)]\n                     (if (< idx total)\n                       (nth digits idx)\n                       (if (< idx (* side side))\n                         \"*\"\n                         \" \")))))]\n    (vec (for [i (range width)]\n           (apply str (for [j (range width)]\n                        (get-s i j)))))))","user":"4ec0c7ba535dfed6da9c6da4"},{"code":"(fn __ [s e]\n  (letfn [(n->digits [n]\n            (reverse (map #(rem % 10)\n                (take-while (complement zero?)\n                            (iterate #(quot % 10) n)))))\n          (square [n] (* n n))\n          (axis-increment [n sign]\n            (lazy-seq (concat (repeat n sign)\n                              (axis-increment (+ n 2) (if (= sign 1) -1 1)))))]\n    (let [d (->> s\n                (iterate square)\n                (take-while #(<= % e))\n                (map n->digits)\n                (flatten))\n          size (first (filter #(>= (square %) (count d))\n                              (range)))\n          num-ast (- (square size) (count d))\n          coords+val (map (fn [digit r c] (list [r c] digit))\n                          (concat d (repeat num-ast \\*)) ;; digits\n                          (reductions + (* (quot (dec size) 2) 2) ;; start row\n                                      (axis-increment 2 1))       ;; row increments\n                          (reductions + (dec size)           ;; start col\n                                      (axis-increment 1 1))) ;; col increments\n          blank (into [] (repeat (dec (* 2 size))\n                                 (into [] (repeat (dec (* 2 size)) \\space))))]     \n      (map #(apply str %)\n           (reduce (partial apply assoc-in)\n                   blank\n                   coords+val)))))","problem":138,"user":"50812debe4b01a93d3f38e4c"},{"problem":138,"code":"(let [\n      get-diags-values\n        (fn [matrix]\n          (let [size (count matrix)\n                first-half \n                  (map #(take (inc %) (iterate (fn [pos] [(dec (first pos)) (inc (last pos))]) [% 0])) (range size))\n                second-half (map #(map (fn [pos] [(- (dec size) (first pos)) (- (dec size) (last pos))]) (reverse %)) (butlast first-half))\n                diags (concat first-half (reverse second-half))\n          ]\n            (for [indexes diags]\n              (map #(get-in matrix %) indexes)\n            ) \n          )\n        )\n      square-matrix\n        (fn [start end]\n          (let [numbers (take-while (partial >= end) (iterate #(* % %) start))\n                digits (mapcat (comp vec str) numbers)\n                ;size of square matrix is a first square number >= sqrt(items_count)\n                n (first (filter #(= (-> % Math/sqrt int float) (Math/sqrt %)) (iterate inc (count digits))))\n                ;extra is number of '*' to make full square matrix\n                extra (- n (count digits))\n                side (int (Math/sqrt n))\n              ]\n        \n            (loop [digits digits counter 1 current-side (if (even? side) 2 1)\n                   pos (if (even? side) [(dec (quot side 2)) (dec (quot side 2))] [(quot side 2) (quot side 2)])\n                   updates (cycle (if (even? side) [[1 0] [0 1] [-1 0] [-1 0] [0 -1]] [[1 0] [0 1] [-1 0] [0 -1] [1 0]]))\n                   result (vec (take side (repeat (vec (take side (repeat nil))))))]\n              \n              (let [item (first digits) \n                    item (if (nil? item) \"*\" (str item))\n                    update-vector (first updates)\n                    newXPos (vec (map + pos update-vector))\n                    change-update? (or (= 1 current-side) (zero? (rem (inc counter) (dec current-side))))\n                    change-side? (or (= 1 current-side) (and change-update? (= 4 (quot counter (dec current-side)))))\n                    newUpdates (if change-update? (rest updates) updates)\n                    newCounter (if change-side? 1 (inc counter))\n                    newCurrentSide (if change-side? (+ current-side 2) current-side)\n                    ]\n                  \n                (if (or (> current-side side) (some neg? pos) (some (partial <= side) pos))\n                  result\n                  (recur\n                    (rest digits)\n                    newCounter\n                    newCurrentSide\n                    newXPos\n                    newUpdates\n                    (assoc-in result (-> pos reverse vec) item)\n                  )\n                )\n              )\n            )\n          )\n        )\n  ]\n  \n  #(let [matrix (square-matrix %1 %2) diags (get-diags-values matrix)\n        size (dec (* 2 (count matrix)))]\n    (for [diag diags\n          :let [string (clojure.string/join \" \" diag)\n                extra (quot (- size (count string)) 2)]]\n      (apply str (concat (take extra (repeat \" \")) string (take extra (repeat \" \"))))\n    )\n  )\n)","user":"5991d2fae4b0866487ed0d68"},{"problem":138,"code":"(fn squared [lo hi]\n  (letfn [\n    ; coordinates of pt after applying a move\n    (delta [[y x] dir] (condp = dir\n        :L  [y (dec x)]\n        :R  [y (inc x)]\n        :U  [(dec y) x]\n        :D  [(inc y) x] ))\n\n    ; Fold a list around [0,0] clockwise to make a spiral, returns map\n    (spiral\n        ([v]  (spiral {[0 0] (first v)} 0 1 (rest v) :D) )\n        ([sp y x v dir]\n        (let [turns {:D :L, :L :U, :U :R, :R :D}\n          [ty tx] (delta [y x] (turns dir))\n          [my mx] (delta [y x] dir)\n          [ny nx nd] (if (sp [ty tx]) [my mx dir] [ty tx (turns dir)]) ]\n            ;(println \"loop\" [y x] \"=\" (first v)  [ny nx])\n            (if (empty? v) sp\n                (recur (assoc sp [y x] (first v)) ny nx (rest v) nd)))))\n\n    ; find the min, max of y and x parts of the keys of spiral map\n    (minmax [sp]\n        ;(println \"minmax\")\n        (reduce (fn [[ay zy ax zx] [y x]] [(min ay y) (max zy y) (min ax x) (max zx x)])\n            [0 0 0 0] (keys sp)))\n\n    ; convert the spiral map above to a matrix\n    (to-matrix [sp]\n        ;(println \"to-matrix \" sp)\n        (let [\n          [ymin ymax xmin xmax] (minmax sp)\n          h (inc (- ymax ymin))\n          w (inc (- xmax xmin))\n          mat (vec (repeat h (vec (repeat w 0))))\n          ]\n            ;(println \"tomatrix\" ymin xmin xmax ymax h w mat)\n            (reduce (fn [m [[y x] v]]\n                ;(println m y x (- y ymin) (- x xmin) v)\n                (assoc-in m [(- y ymin) (- x xmin)] v)) mat (seq sp))))\n\n    ; OK, now that we have a spiral matrix, rotate this 45 degrees\n    (diag [d s] (for [c (range s) r (range s) \n                      :when (= d (+ r c))] [r c]))\n        \n    (alldiags [s]  (for [d (range (dec (* 2 s)))] (diag d s)))\n        \n    (pad-to [n v] \n        (let [p (- n (count v)) h (quot p 2)]\n            (concat (repeat h \" \") v (repeat (- p h) \" \"))))\n            \n    (pad-star [n v]\n        (concat v (repeat (- n (count v)) \"*\")))\n\n    (embed [sq]  (let [s (count sq)  d (alldiags s)]\n        (for [r d] (clojure.string/join\n                (pad-to (count d) (interpose \" \" (map #(get-in sq %) r)))))))\n\n    (to-digits [n] (loop [n n d []]\n        (if (zero? n) (reverse d)\n            (recur (quot n 10) (conj d (mod  n 10))))))\n\n    (vec-digits [v] (mapcat to-digits v))\n\n    (isqrt [n] (int (Math/ceil (Math/sqrt n))))\n\n    (squares [lo hi v]\n        (if (> lo hi) v (recur (* lo lo) hi (conj v lo))))\n\n    (pr-mat [mat] (doseq [r mat] (println r)))\n\n    ]\n\n    (let [v    (squares lo hi [])\n          vdig (vec-digits v)\n          in   (isqrt (count vdig))\n          v*   (pad-star (* in in) vdig)\n          sp   (spiral v*)\n          mat  (to-matrix sp)\n          emb  (embed mat)  ]\n\n        (println \"squared\" lo hi)\n        (pr-mat emb)\n        emb\n    )))","user":"5eff6c0ee4b0cf489e8d7f11"},{"problem":138,"code":"(fn make-square [start end]\n  (let [square-range (fn square-range [n end] (if (> n end) [] (cons n (square-range (* n n) end))))\n        pad-asterisks (fn [n] (repeat (-> n Math/sqrt Math/ceil (Math/pow 2) (- n)) \\*))\n        rotate (fn [matrix] (reverse (apply (partial map vector) matrix)))\n        numerals (mapcat str (square-range start end))\n        padding (pad-asterisks (count numerals))\n        chars (concat numerals padding)\n        populate (fn populate [spiral chars iterations]\n                          (if (empty? chars) (if (= 0 (mod iterations 4))\n                                               spiral\n                                               (populate (rotate spiral) chars (inc iterations)))\n                            (let [rotated (rotate spiral)\n                                  [head tail] (split-at (count (first rotated)) chars)]\n                              (populate (conj rotated head) tail (inc iterations))\n                              )\n                            ))\n        spiral (populate [[(first chars)]] (rest chars) 0)\n        spiral-size (count spiral)\n        left-padded (map-indexed (fn [i row] (concat (repeat i \\space)\n                                                     row\n                                                     (repeat (- (dec spiral-size) i) \\space)))\n                                 spiral)\n        diamond-shaped (map reverse (apply (partial map vector) left-padded))\n        spaced (map #(interpose \\space %) diamond-shaped)\n        unskewed (map-indexed (fn [i row]\n                                (let [n (- (dec spiral-size) i)\n                                      m (- i (dec spiral-size))]\n                                  (take (count row)\n                                  (concat (repeat m \\space) (drop n row) (repeat \\space)))))\n                              spaced)\n        ]\n\n     (map clojure.string/join unskewed)\n\n\n    )\n  )","user":"549dfe40e4b0f3d1d8e70f9a"},{"code":"(fn [f t] (let [\r\n  digits  (->> (iterate #(* % %) f)\r\n            (take-while #(>= t %))(map str)\r\n            (mapcat (partial map #(- (int %) 48))))\r\n  side    (->> digits count Math/sqrt Math/ceil int)\r\n  sq-side (dec (* 2 side))\r\n  hs      (int (/ sq-side 2))\r\n  start   [hs (if (odd? side) hs (dec hs))]\r\n  nchar   (* side side)\r\n  turns   (->> (interleave (range) (range))\r\n            (map #(repeat % false)) (interpose true) (flatten))\r\n  step    (fn [[[x y] [dx dy]] turn]\r\n            [[(+ x dx) (+ y dy)] (if turn [(- dy) dx] [dx dy])])\r\n  coords  (->> (reductions step [start [1 1]] turns) (map first))\r\n  digits  (->> digits reverse (into (repeat \\*)) (take nchar))\r\n  digits  (zipmap coords digits)]\r\n  (->> (for [y (range sq-side) x (range sq-side)]\r\n         (get digits [x y] \\space))\r\n    (partition sq-side)\r\n    (map (partial apply str)))))","problem":138,"user":"50336c6be4b0c6c1199c710f"},{"code":"(fn sqsq [n m]\n  (letfn [(squares [n]\n            (let [m (* n (bigint n))]\n              (lazy-seq (concat (list n) (squares m)))))\n          (seq-squares [n m]\n            (for [i (squares n) :while (<= i m)] i))\n          (int2l-r [n]\n            (if (< n 10) (list n) (conj (int2l-r (quot n 10)) (rem n 10))))\n          (int2l [n]\n            (reverse (int2l-r n)))\n          (seq-squares-* [n m]\n            (let [sq (seq-squares n m)\n                  l (reduce + (map #(count (int2l %)) sq))]\n              (take (next-square l)\n                    (map str (concat (mapcat int2l sq) (repeat \\*))))))\n          (in? [coll x]\n            (cond (nil? coll) false (= x (first coll)) true\n                  (< x (first coll)) false\n                  :else (in? (rest coll) x)))\n          (next-square [n]\n            (let [sq (lazy-seq (map (fn [x] (* x x)) (range)))]\n              (if (in? sq n) n (first (filter #(< n %) sq)))))\n          (do-res [m]\n            (let [item (first (:seq m))\n                  curr-line (first (:line m))\n                  curr-dir (first (:dir m))\n                  curr-res (:res m)]\n              (cond (empty? curr-res) [[item]]\n                    (< curr-line 0) (vec (cons [item] curr-res))\n                    (< curr-line (count curr-res))\n                    (if (= curr-dir 0)\n                      (assoc-in curr-res [curr-line]\n                                (conj (curr-res curr-line) item))\n                      (assoc-in curr-res [curr-line]\n                                (vec (concat [item] (curr-res curr-line)))))\n                    :else (conj curr-res [item]))))\n          (do-prepare [m]\n            (let [new-seq (drop 1 (:seq m))\n                  new-line (drop 1 (:line m))\n                  new-dir (drop 1 (:dir m))]\n              (cond (empty? (:seq m)) (:res m)\n                    (empty? (:res m)) (do-prepare (hash-map :seq new-seq\n                                                            :line new-line\n                                                            :dir new-dir\n                                                            :res [[(str (first (:seq m)))]]))\n                    :else (do-prepare (hash-map :seq new-seq\n                                                :line new-line\n                                                :dir new-dir\n                                                :res (do-res m))))))\n          (do-draw [v]\n            (let [length (count v)]\n              (vec (for [i v :let [pad (clojure.string/join\n                                        (take (- (inc (quot length 2))\n                                                 (count i))\n                                              (repeat \\space)))]]\n                     (clojure.string/join\n                      [pad (clojure.string/join \\space i) pad])))))]\n    (let [line '(0 1 2 1 0 -1 -1 1 2 3 4 5 6 5 4 3)\n          seq (seq-squares-* n m)\n          length (count seq)\n          dir '(0 0 0 1 1 1 1 0 0 0 0 0)]\n      (cond (= n m) [(clojure.string/join (map str (int2l n)))]\n            :else (do-draw (do-prepare {:res nil\n                                        :dir dir\n                                        :line line\n                                        :seq seq}))))))","problem":138,"user":"50733b31e4b0e3170b5a869a"},{"problem":138,"code":"(fn [s e]\n  (letfn [(nums [s e]\n            (take-while #(<= % e)\n                        (iterate #(* % %) s)))\n\n          (strn [xs]\n            (apply str (map str xs)))\n\n          (ceil-sqr [x]\n            (if (<= x 1)\n              1\n              (inc\n                (last\n                  (for [i (range 1 99)\n                        :while (< (* i i) x)]\n                    i)))))\n\n          (pad [s]\n            (let [n (count s)\n                  c (ceil-sqr n)]\n              (apply str s (repeat (- (* c c) n) \\*))))\n\n          (square [size s]\n            (if (= size 1)\n              [s]\n              (if (even? size)\n                (let [n (+ size (dec size))\n                      mine (subs s (- (count s) n))\n                      others (subs s 0 (- (count s) n))\n                      base (square (dec size) others)\n                      right-col (subs mine 0 (dec size))\n                      bottom-row (subs mine (dec size))]\n                  (conj\n                    (vec\n                      (for [i (range (count base))]\n                        (str (nth base i) (nth right-col i))))\n                    (apply str (reverse bottom-row))))\n\n                (let [n (+ size (dec size))\n                      mine (subs s (- (count s) n))\n                      others (subs s 0 (- (count s) n))\n                      base (square (dec size) others)\n                      left-col (apply str (reverse (subs mine 0 (dec size))))\n                      top-row (subs mine (dec size))]\n                  (vec\n                    (cons\n                      top-row\n                      (for [i (range (count base))]\n                        (str (nth left-col i) (nth base i)))))))))\n\n          (diag-row [sq n row]\n            (for [i (range (inc row))\n                  :when (<= 0 (- row i) (dec n))\n                  :when (<= 0        i  (dec n))]\n              (get-in sq [(- row i) i])))\n\n          (abs [x] (if (neg? x) (- x) x))\n\n          (row-str [sq n row]\n            (let [spc (abs (- n (inc row)))\n                  row (diag-row sq n row)]\n              (apply str\n                     (concat\n                       (repeat spc \\space)\n                       (clojure.string/join \" \" row)\n                       (repeat spc \\space)))))\n\n          (diamond [sq]\n            (let [n (-> sq first count)]\n              (mapv #(row-str sq n %) (range (dec (* 2 n))))))]\n\n    (let [st (pad (strn (nums s e)))\n          cs (ceil-sqr (count st))\n          sq (square cs st)]\n      (diamond sq))))","user":"4ec1b090535dfed6da9c6db5"},{"code":"(fn boxer[n1 n2]\r\n    (let[getseq (fn[start end]\r\n                  (seq (reduce str \r\n                             (take-while #(<= % end) \r\n                                         (iterate #(* % %) start))\r\n                             )))\r\n         getnum  (fn[strseq]\r\n                 (let[val (Math/ceil (Math/sqrt (count strseq)))]\r\n                          (int (* val val))\r\n                         ))\r\n         getfullseq  (fn[strseq num]\r\n                       (concat (take num   \r\n                          (concat strseq (repeat \\*) ))\r\n                          (repeat nil) ))\r\n         \r\n         expendBoxs (fn[vals boxs]\r\n                      (let[l1 (count boxs)\r\n                           l2 (count vals)\r\n                           sub (- l2 l1)]                           \r\n                           (println vals)                           \r\n                           (println boxs)\r\n                           (if (> sub 0)\r\n                                (concat boxs \r\n                                      (repeat (+ 1 sub) []) )\r\n                                      boxs\r\n                                     )\r\n                      ))\r\n         addTail (fn[vals boxs]\r\n                      (let[newBoxs (expendBoxs vals boxs)]\r\n                        (cons (first newBoxs)  \r\n                                (map  #(if(nil? %2)\r\n                                           %1\r\n                                           (conj %1 %2))\r\n                                      (rest newBoxs) vals)\r\n                                )))\r\n         \r\n         addHead  (fn[vals boxs]\r\n                    (let[newBoxs (expendBoxs vals (reverse boxs))]\r\n                      (reverse (cons (first newBoxs)  \r\n                          (map  #(if(nil? %2)\r\n                                     %1\r\n                                     (vec (cons %2 %1)))\r\n                                     (rest newBoxs) vals)\r\n                            ))))\r\n         addVal (fn[vals boxs sign]\r\n                   (println (str \"===\" sign) )\r\n                   (if (true? sign)\r\n                        (addTail vals boxs)\r\n                        (addHead vals boxs)\r\n                        )\r\n                  )\r\n         expendTo (fn[col num]\r\n                    (let[n (- (Math/sqrt num) (count col))]\r\n                      (nth \r\n                        (iterate #(vec (cons \\space (conj % \\space)))\r\n                                  (vec (interpose \\space  col)) ) n )                      \r\n                    ))\r\n         ]\r\n     (if (= n1 n2)\r\n       (vector (str n1))\r\n  \t   (let[strseq (getseq n1 n2)\r\n            num (getnum strseq)\r\n            fullseq (getfullseq strseq num)]\r\n\t\t      (loop[vals (rest fullseq)\r\n\t\t            boxs (vector (vector (first fullseq)))\r\n\t\t            n 1\r\n\t\t            sign true]          \r\n\t\t            (let[[val other] (split-at (* 2 n) vals)\r\n\t\t                 currNum (* (+ n 1) n) ]             \r\n\t\t              (if (> currNum num)\r\n\t\t                  (map #(apply str (expendTo % num))\r\n\t\t                       (filter #(not-empty %)\r\n\t\t                        (addVal val\r\n\t\t                            boxs sign)))\r\n\t\t                  (recur other\r\n\t\t\t\t\t                  (addVal val  boxs sign)\r\n\t\t                        (inc n)\r\n\t\t                        (not sign)\r\n\t\t\t\t\t                 )\r\n\t\t                  )))))))","problem":138,"user":"4f6d9d7ee4b07046d9f4efcd"},{"problem":138,"code":"(let [dirs (cycle [[1 1] [-1 1] [-1 -1] [1 -1]])]\n    (fn [a b]\n      (let [xs (mapcat str (take-while #(<= % b) (iterate #(* % %) a)))\n            r (int (Math/ceil (Math/sqrt (count xs))))\n            w (dec (* 2 r)) h (quot w 2)]\n        (->>\n          (loop [s (concat xs (repeat (- (* r r) (count xs)) \"*\"))\n                 o (vec (repeat w (vec (repeat w \" \"))))\n                 p (if (even? r) [h 0] [h (dec w)])\n                 d (if (even? r) dirs (nnext dirs))]\n            (if (empty? s) o\n              (let [nextp (map + (first d) p)\n                    turn? (not= \" \" (get-in o nextp))]\n                (recur (butlast s)\n                       (assoc-in o p (last s))\n                       (if turn? (map + p (second d)) nextp)\n                       (if turn? (next d) d)))))\n          (map (partial apply str))))))","user":"553abb28e4b09218d5f44ffb"},{"code":"(fn squares-squared\n  [start end]\n  (let [sq (fn sq [x] (* x x))\n        nums (take-while #(<= % end) (iterate sq start))\n        text (apply str nums)\n        tlen (count text)\n        side (first (drop-while #(< (sq %) tlen) (iterate inc 1)))\n        size (sq side)\n        boxw (- (* 2 side) 1)\n        infd (fn infd\n               [ord lim turns coll]\n               (let [[ord lim turns] (if (= ord lim)\n                                       (cons 1\n                                             (if (= 1 turns)\n                                               [(inc lim) 0]\n                                               [lim (inc turns)]))\n                                       [(inc ord) lim turns])]\n                 (cons (first coll)\n                       (lazy-seq\n                         (infd ord lim turns\n                               (if (= ord 1)\n                                 (next coll)\n                                 coll))))))]\n    (loop [vecs (vec (repeat boxw (vec (repeat boxw \\space))))\n           coord (let [q (quot boxw 2)] [(if (odd? q) (dec q) q) q])\n           [chr & chrs] (take size (concat text (repeat \\*)))\n           [dir & dirs] (infd 1 1 0\n                              (cycle [[1 1] [1 -1] [-1 -1] [-1 1]]))]\n      (if chr\n        (recur (assoc-in vecs coord chr)\n               (map + coord dir)\n               chrs\n               dirs)\n        (map (partial apply str) vecs)))))","problem":138,"user":"4e6a412e535d8ccf87e9feb6"},{"problem":138,"code":"(fn [b e] (let\n             [lst (mapcat str (take-while #(<= % e) (iterate #(* % %) b)))\n              sqs (map #(* % %) (rest (range)))\n              sqs-e (filter even? sqs)\n              sqs-o (filter odd? sqs)\n              n (first (drop-while #(< % (count lst)) sqs))\n              \n              chs (into [\\space] (take n (concat lst (repeat \\*))))\n\n              a (take-while #(<= % n) (if (even? n) sqs-e sqs-o))\n              v (if (even? n)\n                    (concat (reverse a) (take (count a) (map inc sqs-o)))\n                    (concat (reverse (take (dec (count a)) (map inc sqs-e))) a))\n\n              [v- v+] (let [[l r] (split-at (quot (count v) 2) v)]\n                           [(if (even? (count v))\n                               (concat (map inc (rest l)) (map dec r))\n                               (concat (map inc l) (map dec (rest r))))\n                            (if (even? (count v))\n                               (concat (map dec l) (map inc (rest r)))\n                               (concat (map dec l) (map inc (butlast r))))])\n\n              tr (fn [lf rf v] (let [[l r] (split-at (quot (count v) 2) v)] (concat (map lf l) (map rf (rest r)))))\n              cnt-mid (dec (* 2 (count v)))\n              add-lr (fn [x] (let [i (quot (- cnt-mid (count x)) 2)\n                                   d (take i (repeat 0))] (concat d x d)))]\n      \n      (->> (concat\n             (reverse (take-while #(not-empty %) (iterate (partial tr inc dec) v-)))\n             (cons v (take-while #(not-empty %) (iterate (partial tr dec inc) v+))))\n           (map #(interpose 0 %))\n           (map add-lr)\n           (map #(map (fn [i] (get chs i)) %))\n           (map (partial apply str))\n           vec)))","user":"5a4de614e4b05d388ecb6bb1"},{"code":"(fn [x y]\n  (let [\n    squares (take-while #(<= % y) (iterate #(* % %) x))\n    digits (mapcat (comp seq str) squares)\n    length (first (drop-while #(< % (count digits)) (map #(* % %) (range))))\n    padded (concat digits (repeat (- length (count digits)) \\*))\n    width (Math/sqrt length)\n    cycles (map #(take (inc (* 2 %)) (drop (* % %) padded)) (range width))\n    rows (reduce\n      (fn [rows cycle]\n        (let [top? (zero? (mod (/ (dec (count cycle)) 2) 2))\n              transpose (comp reverse (partial map reverse))\n              height (/ (inc (count cycle)) 2)\n              pad (repeat (+ 2 (- (count rows) height)) [])\n              add-cycle (fn [rows]\n                (map (comp concat flatten vector)\n                  (concat (reverse (take height cycle)) pad)\n                  (concat [[] []] rows)\n                  (concat [[]] (drop height cycle) pad)))]\n          (if top?\n            (add-cycle rows)\n            (transpose (add-cycle (transpose rows))))))\n        [(first cycles)] (rest cycles))\n    strings (map #(apply str (interpose \" \" %)) rows)\n    strwidth (dec (* 2 width))\n    padstrs (map #(let [pad (apply str (repeat (/ (- strwidth (count %)) 2) \" \"))] (str pad % pad)) strings)\n  ] padstrs))","problem":138,"user":"4ebc08a8535dfed6da9c6d7c"},{"problem":138,"code":"(fn squares-squared [x y]\n  (let [move+ \\+\n        move- \\-]\n    (letfn [ \n            (squares\n              ([x y]  (squares [x] x y))\n              \n              ([acc x y]\n                (let [z (* x x)]\n                  (cond\n                    (> z y) acc\n                    (= z y) (conj acc z)\n                    :else (squares (conj acc z) z y)))))\n            \n            (digits [xs]\n              (->>\n                (map #(seq (str %)) xs)\n                (reduce concat)\n                (vec)))\n            \n            (size [xs]\n              (->>\n                (count xs)\n                (Math/sqrt)\n                (Math/ceil)\n                (int)))\n            \n            (pad [xs p c]\n              (if (>= (count xs) c)\n                xs\n                (pad (vec (conj xs p)) p c)))\n            \n            (expand\n              ([x y j] (expand [[x j]] x y j))\n              \n              ([acc x y j]\n                (let [i (+ x 2)]\n                  (if (= i y)\n                    (conj acc [i j])\n                    (expand (conj acc [i j]) i y j)))))\n            \n            (valid-cells [i n s]\n              (set (concat (valid-cells-up i 0 s) (valid-cells-down i (dec n) (dec s)))))\n            \n            (valid-cells-up \n              ([i j s] (valid-cells-up [[i j]] (dec i) (inc i) (inc j) 1 s))\n              \n              ([acc x y j c s]\n                (if (= c s)\n                  acc\n                  (valid-cells-up (apply conj acc (expand x y j)) (dec x) (inc y) (inc j) (inc c ) s))))\n            \n            (valid-cells-down \n              ([i j s] (valid-cells-down [[i j]] (dec i) (inc i) (dec j) 1 s))\n              \n              ([acc x y j c s]\n                (if (= c s)\n                  acc\n                  (valid-cells-down (apply conj (expand x y j) acc) (dec x) (inc y) (dec j) (inc c ) s))))\n            \n            (move-to-fn [m]\n              (if (= m move+) inc dec))\n            \n            (valid-move? [[i j] n c [di dj] vcs]\n              (if (contains? #{2 3} c)\n                false\n                (let [ni ((move-to-fn di) i)\n                      nj ((move-to-fn dj) j)]\n                  (contains? vcs [ni nj]))))\n            \n            (next-move [[i j] n c [di dj] vcs] \n              (if (valid-move? [i j] n c [di dj] vcs) \n                [di dj]\n                (cond                     \n                  (= [di dj] [move+ move+]) [move- move+]\n                  (= [di dj] [move- move+]) [move- move-]\n                  (= [di dj] [move- move-]) [move+ move-]\n                  (= [di dj] [move+ move-]) [move+ move+])))\n            \n            (move [[i j] [di dj]]\n              (let [x (if (= di move+) (inc i) (dec i))\n                    y (if (= dj move+) (inc j) (dec j))]\n                [x y]))\n            \n            (cells \n              ([[i j] n l vcs] (cells [[i j]] [i j] n 1 l [move+ move+] vcs))\n              \n              ([acc [i j] n c l [di dj] vcs]\n                (if (= c l)\n                  acc\n                  (let [nd (next-move [i j] n c [di dj] vcs)\n                        nm (move [i j] nd)]\n                    (cells (conj acc nm) nm n (inc c) l nd vcs))))) \n            \n            (canvas [n]\n              (vec (map (fn [_] (vec (map (fn [_] \\space) (range n)))) (range n))))\n            \n            (point [cv [i j] c]\n              (assoc cv j (assoc (get cv j) i c)))\n            \n            (draw [cv ps xss]\n              (reduce\n                (fn [cv i]\n                  (let [p (get ps i)\n                        x (get xss i)]\n                    (point cv p x))) \n                cv (range (count xss))))\n            \n            (print-canvas [cv]\n              (map (fn [cs] (apply str cs)) cv))\n            \n            (center [n]\n              (cond \n                (= n 1) [0 0]\n                (= n 3) [1 0]\n                (= n 5) [2 2]\n                (= n 7) [3 2]))\n            ]\n      \n      (if (= x y)\n        [(str x)]\n        \n        \n        (let [xs (digits (squares x y))\n              s (size xs)\n              n (dec (* s 2)) \n              i (int (/ n 2))  \n              l (* s s)\n              xss (pad xs \\* l)\n              vcs (valid-cells i n s)\n              ps (cells (center n) n l vcs)\n              cv (canvas n)]\n          (vec (print-canvas (draw cv ps xss))))))))","user":"57d9bca1e4b0bd073c202405"},{"problem":138,"code":"(fn [x y]\n  (let [numbers (take-while #(<= % y) (iterate #(* % %) x))\n        digits (mapcat str numbers)\n        size (some #(if (<= (count digits) (* % %)) %) (range))\n        length (- (* size 2) 1)\n        board (vec (repeat length (vec (repeat length \\ ))))\n        digits (concat digits (repeat (- (* size size) (count digits)) \\*))\n        start (if (odd? size) [(- size 1) (- size 1)] [(- size 2) (- size 1)])]\n    (map (partial apply str)\n         (loop [position start\n                board board\n                move [1 1]\n                moves-left 1\n                moves-counter 1\n                moves-counter-modifier 1\n                [digit & tail] digits]\n           (if digit\n             (let [next-move (if (= 1 moves-left) (case move\n                                                    [1 1] [1 -1]\n                                                    [1 -1] [-1 -1]\n                                                    [-1 -1] [-1 1]\n                                                    [-1 1] [1 1]) move)\n                   next-moves-left (if (= 1 moves-left) moves-counter (- moves-left 1))                   \n                   next-moves-counter (if (= 1 moves-left) (+ moves-counter moves-counter-modifier) moves-counter)\n                   next-moves-counter-modifier (if (= 1 moves-left) (rem (+ 1 moves-counter-modifier) 2) moves-counter-modifier)\n                   next-position (map + position move)\n                   next-board (update-in board position (fn [x] digit))]\n               (recur next-position next-board next-move next-moves-left next-moves-counter next-moves-counter-modifier tail))\n             board)))\n    ))","user":"604d3cb1e4b0b7ec0ac60ac2"}]