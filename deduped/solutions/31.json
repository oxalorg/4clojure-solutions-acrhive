[{"code":"(fn prob31 [ls] \n  (let [getsames #(loop [x %1 xr (seq %2) acc []] \n    (if (empty? xr)\n      [(conj acc x) []]\n      (let [ [ xn & xs ] xr]\n        (if (= xn x)\n          (recur x xs (conj acc xn))\n          [(conj acc x) xr]\n        ))))]\n  (loop [xs (seq ls) acc []]\n    (if (empty? xs) \n      acc\n      (let [ [ x1 & xr] xs [p1 prest] (getsames x1 xr)]\n        (recur prest (conj acc p1)))))))","problem":31,"user":"4f141dee535d64f603146434"},{"problem":31,"code":"reduce (fn [x y] (if (= y (first (last x))) (conj (pop x) (conj (last x) y)) (conj x (conj [] y)))) []","user":"57a5f1e3e4b0a96607956200"},{"problem":31,"code":"(fn f [s]\n  (loop [[a b :as all] s\n         pack '()\n         res '()]\n        (if (nil? a)\n          (concat res pack)\n          (if (= a b)\n            (recur\n              (rest all)\n              (conj pack a)\n              res)\n            (recur\n              (rest all)\n              '()\n              (concat res (list (conj pack a))))\n            )\n          )\n  )\n)","user":"5ac91d90e4b0e27600da77bd"},{"code":"(fn pack-seq [s]\n  (reduce (fn [acc v]\n            (let [most-recent-list (last acc)\n                  most-recent-value (first most-recent-list)]\n              (if (= most-recent-value v)\n                (conj (pop acc) (conj most-recent-list v))\n                (conj acc [v]))))\n          []\n          s))","problem":31,"user":"516385cee4b055933a9ca02d"},{"code":"(fn [x] (loop [xs x res []]\n          (if (= xs [])\n            (reverse res)\n            (recur (rest xs) \n\t\t\t(if (= (first xs) \n\t\t\t    (first (first res)))\n\t\t\t\t  (concat (list (concat (first res) (list(first xs)))) (rest res))\n\t\t\t\t  (concat (list (list (first xs))) res))))))","problem":31,"user":"53410c24e4b00652c8746eca"},{"problem":31,"code":";#(partition-by identity %)\npartition-by identity","user":"5d2201b8e4b02ea6f0fb69ed"},{"problem":31,"code":"(fn\n    [arr]\n    ((fn\n      [res arr]\n      (if (empty? arr)\n        res\n        (recur\n         (if (= (last (last res)) (first arr))\n          (concat\n            (drop-last res)\n            (list\n              (concat\n                (last res)\n                (list (first arr)))))\n          (concat res (list (list (first arr)))))\n         (rest arr))))\n      []\n      arr))","user":"555f4bade4b0a2eb076a39c2"},{"problem":31,"code":"(fn f\n  ([l] (f (rest l) (first l) 1 []))\n  ([l s c r]\n   (if (empty? l)\n     (into r [(repeat c s)])\n     (if (= s (first l))\n       (f (rest l) s (inc c) r)\n       (f (rest l) (first l) 1 (into r [(repeat c s)]))))))","user":"5a3c2a08e4b001c08efc0cdf"},{"code":"(fn [xs] (partition-by identity xs))","problem":31,"user":"4f3ec266e4b0e243712b1f8c"},{"code":"(fn [s]\r\n\t\t (loop [s (rest s)\r\n\t\t\t\t  prev (first s)\r\n\t\t\t\t  res []\r\n\t\t\t\t  subseq [(first s)]]\r\n\t\t\t(if (seq s)\r\n\t\t\t  (let [f (first s)]\r\n\t\t\t\t (if (= f prev)\r\n\t\t\t\t\t(recur (rest s) f res (conj subseq f))\r\n\t\t\t\t\t(recur (rest s) f (conj res (seq subseq)) [f])))\r\n\t\t\t (conj res (seq subseq)))))","problem":31,"user":"4e08fb7a535d04ed9115e7ac"},{"problem":31,"code":"(let\n  [xfer (fn xfer [src dest] (if\n                              (or (not (first dest)) (and (first src) (= (first src) (first dest))))\n                              (xfer (rest src) (conj dest (first src)))\n                              [src dest]))]\n  (fn pack\n    [coll]\n    (let\n      [data (xfer coll [])]\n      (if\n        (first (first data))\n        (concat [(second data)] (pack (first data)))\n        [(second data)]))))","user":"5b465b8be4b02d533a91bc65"},{"code":"(fn\n  [coll]\n  (reverse (loop       \n      [last (first coll)\n       coll coll\n       acc nil]    \n    (let [[take drop] (split-with (partial = last) coll)]\n      (if (empty? drop)\n        (cons take acc)\n        (recur (first drop) drop (cons take acc)))))))","problem":31,"user":"51da565ae4b02ceefd947765"},{"problem":31,"code":"(fn pack\n        ([s] (pack (rest s) [] (list (first s))))\n        ([s p d] (cond\n                   (empty? s) (conj p d)\n                   (= (first s) (first d)) (pack (rest s) p (conj d (first d)))\n                   :else (pack (rest s) (conj p d) (list (first s))))))","user":"544e6b7fe4b0e39780006986"},{"problem":31,"code":"(fn [s]\n   (reduce (fn [r s]\n             (if (= (first (last r)) s)\n               (conj (pop r) (conj (last r) s))\n               (conj r (vector s)))) (vector) s))","user":"5ccc2a03e4b0ccb06196288f"},{"problem":31,"code":"(fn [s]\n  (loop [news () olds s]\n    (if (empty? olds)\n      (reverse news)\n      (let [f (first olds)]\n        (recur (into news (list (take-while (partial = f) olds))) (drop-while (partial = f) olds))\n       )\n     )\n    )\n  )","user":"57a13745e4b0c3d858beb8e3"},{"problem":31,"code":"(fn [coll]\n      (loop [result []   items (seq coll)]\n        (if (zero? (count items))\n          result\n          (let [\n            grp-val (first items)\n            [next-group rest-vals] (split-with #(= % grp-val) items)\n          ]\n            (recur (conj result next-group) rest-vals )))))","user":"532f7e12e4b019098a6f8b4e"},{"code":"(fn [coll]\n  (reduce \n   (fn [coll v]\n     (cond \n      (= (identity (last (last coll))) (identity v)) (conj (vec (butlast coll)) (conj (last coll) v))\n      :else (conj coll [v]))) [] coll))","problem":31,"user":"52be0263e4b07a9af579230e"},{"problem":31,"code":"(fn [sekvenca]\n  (loop [current (first sekvenca)\n         result []\n         part (conj [] (first sekvenca))\n         sek (rest sekvenca)]\n    (if (empty? sek)\n      (conj result part)\n      (if (= current (first sek))\n        (recur current result (conj part current) (rest sek))\n        (recur (first sek) (conj result part) (conj [] (first sek)) (rest sek))))))","user":"5be0b916e4b0ed4b8aab4c8f"},{"code":"(fn [st]\r\n   (let [s (seq st)]\r\n     (loop [f (list (first s)) r (rest s) acc '()]\r\n      (if (nil? (seq r))\r\n        (reverse (conj acc f))\r\n        (if (= (first f) (first r))\r\n          (recur (conj f (first r)) (rest r) acc)\r\n          (recur (list (first r)) (rest r) (conj acc f)))))))","problem":31,"user":"4e26e8b4535deb9a81d77ef6"},{"problem":31,"code":";; problem/31\n(fn seq-dups\n  [coll]\n  (partition-by identity coll))","user":"5c92105ce4b048ec896c59f7"},{"problem":31,"code":"(fn my-pack [l]\n  (if (empty? l)\n    '()\n     (let [fst? #(= % (first l))]\n      (concat\n        (list (take-while fst? l))\n        (my-pack (drop-while fst? l))))))","user":"548c8115e4b0e286459a120c"},{"code":"(fn [z]\n(loop [x z y [] r []]\n        (if (and (nil? x) (nil? (first y)))\n                (remove #(nil? (first %1)) r)\n                (if (= (first x) (first y))\n                        (recur (next x) (conj y (first x)) r)\n                        (recur (next x) (list (first x)) (concat r (list y)))\n                )\n        )\n)\n)","problem":31,"user":"53512b55e4b084c2834f4ae0"},{"problem":31,"code":"(fn sequential-pack\n  [coll]\n  (apply conj (reduce (fn group-duplicates\n            [[result last-group] next-item]\n            (let [last-item (first last-group)\n                  same-group (= next-item last-item)]\n              (if (or same-group (empty? last-group))\n                [result (conj last-group next-item)]\n                [(conj result last-group) [next-item]])\n              )) [[][]] coll)))","user":"57e9a77ae4b0bfb2137f5b35"},{"code":"(fn [input]\n    (loop [s (seq input) a nil] \n      (if (empty? s)\n        (reverse a)\n        (if (= (first s) (first (first a)))\n          (recur (rest s) (conj (rest a)  (conj (first a) (first s))))\n          (recur (rest s) (conj a (list  (first s))))))))","problem":31,"user":"5341b141e4b00652c8746ecf"},{"code":"(fn my-flatten [s] (partition-by identity s))","problem":31,"user":"52e683c0e4b09f7907dd1477"},{"code":"(fn [s]\n  (loop [res [] left s]\n    (if\n      (empty? left) res\n      (recur (concat res [(take-while #(= (first left) %) left)]) (drop-while #(= (first left) %) left)))))","problem":31,"user":"5133e51ae4b0d7a043de8cf6"},{"problem":31,"code":"#(loop [res []\n          subres (conj [] (first %1))\n          in (rest %1)]\n    (if(empty? in)\n      (conj res subres)\n      (if (= (last subres) (first in))\n        (recur\n          res (conj subres (first in)) (rest in)\n        )\n        (recur \n          (conj res subres) (conj [] (first in)) (rest in)\n        )\n      \n      )\n    )\n  )","user":"5bfcdc52e4b0bdcf453d15f4"},{"code":"#(partition-by (fn [arg] arg) %)","problem":31,"user":"4fdf2b50e4b05e33b9224f93"},{"code":"(fn [ values ]\n  (loop [ remaining values \n          result [] ]\n    (if (zero? (count remaining))\n      result\n      (let [ dups (for [ r remaining\n                         :let [ v (first remaining) ]\n                         :while (= r v)\n                       ] r)\n             n (count dups)\n             tail (drop n remaining)\n           ]\n        (recur tail (conj result dups))))))","problem":31,"user":"4ee3afde535d10e5ff6f5370"},{"problem":31,"code":"(fn [coll] \n            (reduce\n  (fn [mine nxt]\n    (if\n      (= (last (last mine)) nxt)\n      (conj (vec (drop-last mine)) (conj (last mine) nxt))\n      (conj mine [nxt])\n    )\n  )\n  []\n  coll\n\n            ) )","user":"5da975b9e4b000c986472c32"},{"problem":31,"code":"(fn [x]\n  (loop [res [], cur [], p nil, x1 (seq x)]\n    (if (empty? x1) (concat res [cur])\n      (let [hd (first x1),tail (rest x1)]\n      (if (= p hd) (recur res (concat cur [hd]) hd tail)\n        (if (nil? p) (recur res [hd] hd tail)\n          (recur (concat res [cur]) [hd] hd tail)))))))","user":"55486ee6e4b0a04f7929955a"},{"problem":31,"code":"(letfn [(rdc-blks \n           [acc b]\n(let [top-ls (peek acc)]\n (if (= b (first top-ls))\n  (conj \n   (pop acc) \n   (cons b top-ls))\n  (conj acc (list b)))\n))]\n(fn [xs] \n (if (empty? xs) xs \n   (reduce \n     rdc-blks\n     [(list (first xs))]\n     (rest xs))\n)))","user":"57f9011ee4b0d3187e900935"},{"code":"(fn pack ([s] (if (seq s) (cons\n  (take-while #(= (first s) %) s)\n  (pack (drop-while #(= (first s) %) s))) '())))","problem":31,"user":"4ff889f2e4b0678c553fc399"},{"code":"(fn m [y]\n (if (empty? y) ()\n (let [f #(=(first y) %)]\n  (cons (take-while f y) \n        (m (drop-while f y))))))","problem":31,"user":"4dad8d4bc9a9d6ed1799dc57"},{"problem":31,"code":"(fn [coll] (reduce #(if (= (first (first %1)) %2)\n                        (cons (cons %2 (first %1)) (rest %1))\n                      \t(cons (list %2) %1))\n                   []\n                   (reverse coll)))","user":"543c39e0e4b032a45b86933d"},{"problem":31,"code":"(fn [coll]\n  (reduce (fn [acc v]\n            (let [last-acc (last acc)\n                  last-ind (-> acc count dec)]\n              (if (and (sequential? last-acc)\n                       (= v (last last-acc)))\n                (update-in acc [last-ind] #(conj % v))\n                (conj acc (list v)))))\n          []\n          coll))","user":"52d38c51e4b099d49816f0c5"},{"code":"; this is lazy\n(fn mypack [x]\n  (if (seq x)\n    (let [f (first x) r (rest x)]\n      (lazy-seq\n        (cons \n          (cons \n            f \n            (take-while \n              #(= f %) \n              r)) \n          (mypack \n            (drop-while \n              #(= f %) \n              r)))))\n    x))","problem":31,"user":"4e131443535d04ed9115e7d3"},{"problem":31,"code":"(fn [x]\n  (loop [in (vec (rest x))\n  \t\t final (vector (vector (first x)))]\n    (println in final)\n    (if (empty? (rest in))\n      (if (= (first in) (last (last final)))\n        (conj (vec (butlast final)) (conj (last final) (first in)))\n        (conj final [(first in)]))\n      (if (= (first in) (last (last final)))\n        (recur (rest in) (conj (vec (butlast final)) (conj (last final) (first in))))\n        (recur (rest in) (conj final [(first in)]))))))","user":"5b2a559be4b063e2438bcc74"},{"code":"(fn pd ([se] (pd se '() [] ) )\n   ([se verE le] \n     \n     \n     (if (empty? se)  \n        (if  (empty? verE)\n          le\n          (conj le verE))\n         (if (empty? verE)\n          (pd (rest se)    (list (first se)) le)\n          \n          (if (= (first se) (first verE))\n             (pd (rest  se) (list* (first se) verE) le )\n             (pd  (rest se) (list (first se))  (conj  le verE ))\n          )    \n      ))\n   ))","problem":31,"user":"4e7217c5535d5021c1a89659"},{"problem":31,"code":"#(loop [[n & r] % final-result [] tmp '() curr n]\n       (if (empty? r)\n               (if (= n curr)\n                         (conj final-result (conj tmp n))\n                         (conj final-result tmp (list n)))\n               (if (= n curr)\n                         (recur r final-result (conj tmp n) curr)\n                         (recur r (conj final-result tmp) (list n) n))))","user":"57e929c0e4b0bfb2137f5b21"},{"problem":31,"code":"#(->> %\n      (reduce (fn [[agg prev-l] n]\n                (if (= (first prev-l) n)\n                  [agg (cons n prev-l)]\n                  [(conj agg prev-l) (list n)])) [[] ()])\n      (apply conj)\n      (drop 1))","user":"591072e0e4b0163c97b36ebc"},{"code":"(fn [x] \n  (loop [x x repeats-x []]\n    (if (> (count x) 0)\n        (let [split-x (split-with (partial = (first x)) x)]\n            (recur (second split-x) (conj repeats-x (first split-x))))\n        repeats-x)))","problem":31,"user":"521249f5e4b06aa6d1666ba2"},{"code":"#(partition-by (fn [i] i) %)","problem":31,"user":"4e3456f9535deb9a81d77f2a"},{"problem":31,"code":"#(reverse (loop [i %\n              s nil\n              o '[]]\n         (if (empty? i) o (do (if (= (first i) s) (recur (rest i) (first i) (conj (rest o) (conj (first o) (first i)))) (recur (rest i) (first i) (conj o (conj '() (first i)))))))))","user":"57b6555be4b0fbc9809a27bf"},{"problem":31,"code":"(fn [l]\n  (loop [r [] l l]\n    (if (empty? l)\n      r\n      (recur\n       (if (and (not (empty? r)) (= (first l) (first (last r))))\n         (conj (vec (drop-last r)) (conj (last r) (first l)))\n         (conj r (list (first l))))\n       (rest l)))))","user":"5995f8ade4b0b211ea3aaae9"},{"problem":31,"code":"(fn[x]\n  (partition-by identity x))","user":"5d8a832ce4b0915913b1d3ca"},{"code":"(fn pack [xs]\n  (partition-by identity xs))","problem":31,"user":"53287dace4b09d4e7a9b5507"},{"code":"reduce (fn [coll x] \n  (if (not= (peek (peek coll)) x)\n      (conj coll [x])\n      (conj (pop coll) (conj (peek coll) x))\n  )\n) []","problem":31,"user":"4fb3fec7e4b081705acca2a7"},{"code":"#(loop [a []\n        c [(first %)]\n        l (rest %)]\n   (if\n    (empty? l) (lazy-seq (conj a c))\n     (let [e (first l)\n           r (rest  l)]\n       (if (= e (first c)) (recur a (conj c e) r)\n         (recur (conj a c) [e] r)))))","problem":31,"user":"537e745ae4b06839e8705ea6"},{"code":"partition-by (fn[x]x)","problem":31,"user":"4f296a80e4b0d6649770a02a"},{"problem":31,"code":"#(reverse (reduce (fn [val n] \n                 (let [t (first val)]\n                   (if (= n (first t))\n                     (conj (rest val) (conj t n))\n                     (conj val (list n)))))\n              [] %))","user":"53aafb9be4b047364c044448"},{"code":"#(loop [s % ans ()]\n             (if (= s ())\n                     (reverse ans)\n                         (recur (rest s) (if (= (first s) (first (first ans)))   \n                                   (cons (conj (first ans) (first s)) (rest ans))\n                                   (cons (list (first s)) ans)))))","problem":31,"user":"4fbfe9a4e4b081705acca31f"},{"problem":31,"code":"(fn [xs]\n  (reverse (reduce\n   #(if (= (ffirst %1) %2)\n      (cons (cons %2 (first %1)) (rest %1))\n      (cons (list %2) %1 ))\n   '()\n   xs)))","user":"53d88bd5e4b0e771c302546e"},{"code":"(fn foo [s & {:keys [c]\n              :or {c '()}}]\n  (if (empty? s)\n    '()\n    (let [current (first s)\n          n (first (rest s))]\n      (if (not (= current n))\n        (concat (list (concat c (list current))) (foo (rest s)))\n        (foo (rest s) :c (concat c (list current)))))))","problem":31,"user":"5220a770e4b0e6a83c8925a3"},{"problem":31,"code":"(fn [a] (partition-by (fn [n] identity n) a) )","user":"574727bce4b009280f9f2b70"},{"problem":31,"code":"(fn [coll]\n  (loop [result '(), cur '(), in coll]\n    (if (= 0 (count in))\n      (if (= 0 (count cur))\n        (reverse result)\n        (recur (conj result cur) '() in))\n      (if (= 0 (count cur))\n        (recur result (conj cur (first in)) (rest in))\n        (if (= (first cur) (first in))\n          (recur result (conj cur (first in)) (rest in))\n          (recur (conj result cur) '() in))))))","user":"56c55fbce4b05cc29241eea5"},{"problem":31,"code":"(fn [xs]\n   (reduce (fn [xs x]\n            (if (=  (first (last xs)) x)\n              (conj (pop xs) (conj (last xs) x))\n              (conj xs [x])\n              )\n \n             )\n           []\n           xs\n           \n           \n           ))","user":"53ca23e3e4b00fb29b2212c6"},{"problem":31,"code":"(fn pack [coll]\n  (reverse (reduce (fn [res-coll x]\n                     (if (= (ffirst res-coll) x)\n                       (cons (conj (first res-coll) x) (rest res-coll))\n                       (cons (list x) res-coll)))\n                   '()\n                   coll)))\n\n#_(partial partition-by identity)","user":"608256d7e4b0736b099e42da"},{"problem":31,"code":"(fn pack [coll]\n  (reduce\n    (fn [acc n]\n      (let [l (last acc)\n            bl (butlast acc)\n            nn (list (list n))]\n        (cond\n          (= acc '()) nn\n          (= n (first l)) (concat bl (list (cons n l)))\n          :else (concat acc nn)\n        )\n      )\n    )\n    '()\n    coll\n  )\n)","user":"55f5c118e4b06e875b46ce8e"},{"problem":31,"code":"(fn dup ([s] (dup s (first s) () ())) ([s p pl k] (if (empty? s) (reverse (conj k pl)) (recur (rest s) (first s) (if (= p (first s)) (concat pl [(first s)]) (list (first s)))  (if (= p (first s)) k (conj k pl)) ))))","user":"54a634abe4b09f271ff37c84"},{"problem":31,"code":"(fn packDup [x]\n  (loop [a x\n         ch nil\n         c 0\n         result []]\n      (if (> (count a) 0)\n        (if (= ch (first a))\n          (recur (rest a) ch (inc c) result)\n          (if (= c 0)\n            (recur (rest a) (first a) 1 result)\n            (recur (rest a) (first a) 1 (conj result (repeat c ch)))))\n        (if (= c 0)\n          result\n          (conj result (repeat c ch))))))","user":"56a3c89ae4b0542e1f8d14cf"},{"problem":31,"code":"(fn pack \n  [s]\n  (loop\n    [in s, subList '(), out []]\n    (if (empty? in)\n      (if (empty? subList)\n        out\n        (conj out subList))\n      (if (or (empty? subList) (= (first in) (first subList)))\n        (recur (rest in) (conj subList (first in)) out)\n        (recur (rest in) (list (first in)) (conj out subList))))))","user":"559454f2e4b0c79f6e1db952"},{"code":"(fn [coll]\r\n  (loop [acc []\r\n         coll coll]\r\n    (if (seq coll)\r\n      (let [f (first coll)\r\n            [a b] (split-with #(= %1 f) coll)]\r\n        (recur (cons a acc) b))\r\n      (reverse acc))))","problem":31,"user":"4e4ad154535dc968683fc4d1"},{"problem":31,"code":"(fn [coll]\n  (loop [c (rest coll)\n         last-item (first coll)\n         next-item (first c)\n         cur-list (list last-item)\n         ret-list []]\n    (if (empty? c)\n      (conj ret-list cur-list)\n    (if (= last-item next-item)\n      (recur (rest c) next-item (first (rest c)) (conj cur-list last-item) ret-list)\n      (recur (rest c) next-item (first (rest c)) (list next-item) (conj ret-list cur-list))\n      ))\n    )\n  \n  )","user":"543b4746e4b032a45b86932c"},{"problem":31,"code":"#(reverse (reduce (fn [acc x] \n            (if (= x (first (first acc)))\n              (conj (drop 1 acc) (concat (first acc) (list x)) )\n              (conj acc (list x))\n            )\n           ) () %) )","user":"596f6683e4b069c0a1a19877"},{"code":"(fn [sec]\n  (loop [sec sec\n         pre-elem \"\"\n         elem-res '()\n         result '()]\n    (if (empty? sec) \n      (reverse \n       (if (not(empty? elem-res))\n         (cons elem-res result)\n         result))\n      (recur (rest sec) \n           (first sec)\n           (if (not= (first sec) pre-elem)\n             (list (first sec))\n             (cons (first sec) elem-res))\n           (if (= (first sec) pre-elem)\n             result\n             (if (not (empty? elem-res))\n               (cons elem-res result)\n               result))))))","problem":31,"user":"51f297a3e4b0210f90e74552"},{"code":"(fn [lst]\n  ((fn foo [nlst r] \n     (if (empty? nlst)\n       r\n       (if (= (first nlst) (last (last r)))\n         (foo (rest nlst) (concat (butlast r) (list (concat (last r) (list (first nlst))))))\n         (foo (rest nlst) (concat r (list (list (first nlst)))))\n         )\n      )\n     ) (rest lst) (list (list (first lst))))\n  )","problem":31,"user":"50ae5659e4b0a40c9cfb08d2"},{"code":"(fn [l]\n  (loop [current [(first l)]\n         data (rest l)\n         ret []]\n    (if (empty? data)\n      (conj ret current)\n      (if (= (first current) (first data))\n        (recur (conj current (first data)) (rest data) ret)\n        (recur [(first data)] (rest data) (conj ret current))))\n    \n    \n    ))","problem":31,"user":"4e70a7c1535d5021c1a8963c"},{"problem":31,"code":"(fn [xs] (drop 1(reduce (fn [r x] (if (= (last (last r)) x) (conj (vec (drop-last r)) (conj (last r) x)) (conj r [x]))) [[]] xs)))","user":"5ce62d8ee4b0a17bb84e2b83"},{"code":"partition-by #([%]0)","problem":31,"user":"4e707db6535d5021c1a8963a"},{"problem":31,"code":"(fn tom [tmp lst]\n  (if (empty? lst)\n    (cons tmp ())\n    (if (= tmp () )\n      (tom (list (first lst)) (rest lst))\n      (if (= (first tmp) (first lst))\n        (tom (cons (first lst) tmp) (rest lst))\n        (cons tmp (tom () lst))\n        )\n      )\n   )\n  ) ()","user":"57e404a3e4b0bfb2137f5ab1"},{"code":"(fn pack [lst]\n  (let [\n    fst (first lst)\n    cmp #(= fst %)\n    part (take-while cmp lst)\n    rst (drop-while cmp lst) ]\n\n    (if fst; list not empty\n      (conj (pack rst) part)\n      '(); else\n    )))","problem":31,"user":"4e356d2b535deb9a81d77f2d"},{"problem":31,"code":"(fn [coll]\n  (loop [prev (list (first coll))\n         ret (list)\n         [curr & coll] (rest coll)]\n    (if (nil? curr)\n      (reverse (cons prev ret))\n      (if (= (first prev) curr)\n        (recur (cons curr prev) ret coll)\n        (recur (list curr) (cons prev ret) coll)))))","user":"5cf6522be4b0b71b1d808a58"},{"problem":31,"code":"(fn pack [coll]\n   (partition-by identity coll))","user":"58dcb8cde4b0a4d5acaab6a7"},{"code":"(fn b [n] (loop [nn (reverse n) l (next nn) e (conj '() (first nn)) ee '()] (if (empty? l) (if (empty? e) ee (conj ee e)) (if (= (last e) (first l)) (recur nn (next l) (conj e (first l)) ee) (recur nn (next l) (conj '() (first l)) (conj ee e))))))","problem":31,"user":"4fe97adde4b0547ebccb245e"},{"problem":31,"code":"(fn [arr]\n  (loop [sub [] [f & r] arr result []]\n    (if (= f nil)\n    (conj result sub)\n    (recur (if (or (= (first sub) f) (empty? sub)) \n        (conj sub f)\n        [f]\n      ) r (if (or (= (first sub) f) (empty? sub))\n        result\n        (conj result sub)\n      )))))","user":"5e7f62cce4b085ba37836e3b"},{"code":"(fn [coll] (partition-by (fn[x] x) coll))","problem":31,"user":"4daedd1eedd6309eace4d164"},{"code":"(fn pack [sq]\r\n  (reverse \r\n    (reduce (fn [coll x]\r\n              (if (empty? coll)\r\n                [[x]]\r\n                (let [head-pack (first coll)\r\n                      rest-packs (rest coll)]\r\n                  (if (= (first head-pack) x)\r\n                    (cons (cons x head-pack) rest-packs)\r\n                    (cons  (list x) coll)))))\r\n            []\r\n            sq)))","problem":31,"user":"4f71db68e4b07046d9f4f015"},{"problem":31,"code":"reduce (fn [acc el]\n          (if (nil? (last acc))\n            (conj acc [el])\n            (if (= el (first (last acc)))\n              (conj (vec ((comp reverse rest reverse) acc)) (conj (last acc) el))\n              (conj acc [el])\n            )\n          )\n        )\n []","user":"59967c40e4b0b211ea3aaaf2"},{"problem":31,"code":"(fn [xs]\n  (reverse \n    (reduce #(cond \n              (empty? %) (cons [%2] %)\n              (contains? (set (first %)) %2) (cons (cons %2 (first %)) (rest %))\n              :else (cons (list %2) %)) '() xs)))","user":"5ce05561e4b0a17bb84e2b08"},{"problem":31,"code":"(fn [x]\n    (partition-by #(identity %) x))","user":"57027310e4b08d47c97781e2"},{"problem":31,"code":"(fn [v] (loop [result [] sublist (list (get v 0)) i 1] (cond (= (count v) i) (seq (conj result sublist)) (= (first sublist) (get v i)) \n                                                             (recur result (conj sublist (get v i)) (inc i))\n                                                             :else (recur (conj result sublist) (list (get v i)) (inc i)))))","user":"573c813be4b0cd1946bd10c5"},{"problem":31,"code":"(fn ams\n  ([lis]\n  (ams lis [] []))\n  ([lis tmp final]\n   (if (empty? lis)\n     (conj final tmp)\n     (if (or (empty? tmp) (and (complement (empty? tmp)) (= (first tmp) (first lis))))\n       (ams (rest lis) (conj tmp (first lis)) final)\n       (ams (rest lis) [(first lis)] (conj final tmp))\n       )\n     ))\n  )","user":"5d4cf3e9e4b0776584bd6f38"},{"problem":31,"code":"(fn [coll]\n  (loop [coll coll acc []]\n    (let [[next-sub-list xs] (split-with (partial = (first coll)) coll)\n          sub-lists (conj acc next-sub-list)]\n      (if (empty? xs)\n        sub-lists\n        (recur xs sub-lists)))))","user":"548ff2d5e4b0b312c081ff2b"},{"code":"(fn hoge [coll]\n\t   (if (seq coll)\n\t       (lazy-seq\n\t\t(let [[head tail] (split-with #(= (first coll) %)\n\t\t\t\t\t      coll)]\n\t\t  (cons head (hoge tail))))))","problem":31,"user":"52381b2ae4b0fae3832e99ef"},{"problem":31,"code":"(fn [xs]\n  (reduce (fn [acc cur]\n            (if (= (first (first acc)) cur)\n              (conj (rest acc) (cons cur (first acc)) )\n              (conj acc (list cur)))) '() (reverse xs)))","user":"5da7176ae4b000c986472c13"},{"problem":31,"code":"(fn pack\n  ([lst] (pack (rest lst) (take 1 lst)))\n  ([lst accum]\n   (cond\n     (empty? lst) (list accum)\n     (= (first lst) (first accum)) (pack (rest lst) (cons (first accum) accum))\n     :else (cons accum (pack (rest lst) (take 1 lst))))))","user":"58ef0b8ce4b056aecfd47dbf"},{"code":"(comp reverse #(reduce (fn [xs x]\n                         (if (= x (first (first xs)))\n                           (conj (rest xs) (conj (first xs) x))\n                           (conj xs (list x)))) '() %))","problem":31,"user":"523f1245e4b01c266ffa7f95"},{"problem":31,"code":"#(loop [[a & r] %\n        last nil\n        o []]\n   (if (nil? a) o\n     (recur r a (if (= a last) (assoc o (dec (count o)) (conj (get o (dec (count o))) a))\n                               (conj o [a])))))","user":"59ddae03e4b01968742fed65"},{"problem":31,"code":"reduce #(if (= (last (last %1)) %2) (assoc %1 (- (count %1) 1) (conj (last %1) %2)) (conj %1 [%2])) []","user":"5b507222e4b02d533a91bce7"},{"code":"(fn packseq [s]\n  (let [x ((fn get_first_seq [n]\n\t\t\t; Returns a sequence of the form '('(repeated first values),'(everything else))\n\t\t\t\t(cond\n\t\t\t\t\t(<= (count n) 1) (list n)\n\t\t\t\t\t(= (first n) (first (rest n)))\n\t\t\t\t\t\t(let [x (get_first_seq (rest n))] (list (conj (first x) (first n)) (first (rest x))))\n\t\t\t\t\t:else (list (list (first n)) (rest n)))) s) xr_f (first (rest x))]\n\t\t(concat (list (first x)) ; wrap in list so concat doesn't destroy sub-list\n\t\t\t(if (or (empty? xr_f) (= nil (first xr_f))) nil\n\t\t\t\t(packseq xr_f )))))","problem":31,"user":"4f566178e4b0a7574ea71820"},{"problem":31,"code":"(partial reduce (fn [packed item]\n\t(if (= (last (last packed)) item)\n      (concat (reverse (rest (reverse packed))) (list (concat (last packed) (list item))))\n      (concat packed (list (list item)))\n    )\n) '())","user":"55f014ebe4b06e875b46ce1b"},{"problem":31,"code":"(fn ps [col]\n  (reduce\n   (fn [a b]\n     (if (= b (last (last a)) )\n      (concat (butlast a) (list (concat (last a) (list b))) )\n      (concat a (list (list b)) )\n      )\n   )\n    (list)\n    col\n   )\n  )","user":"55bb7546e4b01b9910ae29e7"},{"problem":31,"code":"(fn [coll]\n  ((fn go [x xs]\n     (if-let [f (first xs)]\n       (if (= f (first x))\n         (go (cons f x) (next xs))\n         (cons x (go (list f) (next xs))))\n       (list x)))\n   (list (first coll)) (rest coll)))","user":"5488872ee4b0e286459a11d3"},{"problem":31,"code":"(fn [col]\n  (loop [col col\n         current []\n         acc []]\n    (if (empty? col)\n      (if (empty? current) acc (conj acc current))\n      (if (empty? current)\n        (recur (rest col) [(first col)] acc)\n        (let [[f & r] col\n    \t   c (first current)]\n          (if (= f c)\n            (recur r (conj current c) acc)\n            (recur r [f] (conj acc current))))))))","user":"5a188be3e4b0ff51aa4b31ec"},{"code":"(fn pack [l]\n   (if\n    (empty? l)\n    l\n    (let [\n          tail\n          (pack\n           (rest l))]\n      (cond\n       (empty? tail)\n       [[(first l)]]\n       (=\n        (first l)\n        (first\n         (first tail)))\n       (cons\n        (cons\n         (first l)\n         (first tail))\n        (rest tail))\n       :else\n       (cons\n        [(first l)]\n        tail)))))","problem":31,"user":"50d2fa5ce4b049d4ed5650cf"},{"problem":31,"code":"(fn [x]\n  (loop [coll (rest x)\n         acc []\n         curPack (vector (first x))]\n    (if (empty? coll)\n      (conj acc curPack)\n      (if (= (first curPack) (first coll))\n        (recur (rest coll) acc (conj curPack (first coll)))\n        (recur (rest coll) (conj acc curPack) (vector (first coll)))\n      )\n    )\n  )  \n)","user":"5877e40ee4b01531a375eaab"},{"problem":31,"code":"(fn\n  [s]\n  (partition-by #(identity %) s))","user":"59b93cd7e4b0a024fb6ae3c7"},{"problem":31,"code":"(fn [a-seq]\n  (loop [new-seq '()\n         seq-rest a-seq]\n    (if (empty? seq-rest)\n      (reverse new-seq)\n      (if (= (first seq-rest) (first (first new-seq)))\n        (recur (cons (cons (first seq-rest) (first new-seq)) (rest new-seq)) (rest seq-rest))\n        (recur (cons (list (first seq-rest)) new-seq) (rest seq-rest))))))","user":"5235493ee4b05e80434a5064"},{"code":"(fn [x] \r\n   (letfn [(pack [acc y]\r\n                (if (= (first (first acc)) y)\r\n                  (cons (cons y (first acc)) (rest acc))\r\n                  (cons (list y) acc)))]\r\n          (reverse (reduce pack () x))))","problem":31,"user":"4fc8b012e4b0ee37620e1838"},{"problem":31,"code":"(fn [base]\n   (let [[finalRes finalCurr]\n     (reduce\n    (fn [[res curr] el]\n      (if\n        (= (last curr) el)\n        (list res (conj curr el))\n        (list (conj res curr) [el])\n        ))\n  [[] []]\n    base)]\n     (pop (apply list (conj finalRes finalCurr)))))","user":"59ba2ea0e4b0a024fb6ae3e1"},{"code":"#((fn [seq]\n  (loop [s   (rest seq)\n         p   (first seq)\n         acc []\n         sub [p]]\n    (cond\n     (nil? p) acc\n     (= p (first s))  (recur (rest s) p acc (conj sub p))\n     :else            (recur (rest s) (first s) (conj acc sub) [(first s)])))) %)","problem":31,"user":"51b0e7b3e4b0c53cf2e68a6e"},{"problem":31,"code":"(fn [x] \n  ((fn pack [c] \n    (reduce \n      (fn [xs x] \n        (cond \n         (= (last (last xs)) x) (concat (drop-last xs) (list (conj (last xs) x)) )\n          :else (concat xs (list (list x)))))       \n      (list (list (first c)))\n      (drop 1 c))) \n   x))","user":"5a14228fe4b0ff51aa4b3193"},{"code":"(fn [input-sequence]\n    ((fn [remaining output]\n       (if (empty? remaining)\n         output\n         (recur (rest remaining)\n                (if (or (empty? output) (not= (first (first output)) (first remaining)))\n                      (conj output (list (first remaining)))\n                      (conj (rest output)\n                            (conj\n                              (first output)\n                              (first remaining))))\n         )\n       ))\n       (reverse input-sequence) '()))","problem":31,"user":"4ee9c8d0535d93acb0a66892"},{"code":"(fn f [x]\n  (let [first-fn #(= (first x) %)]\n    (if (empty? x)\n      []\n      (cons (take-while first-fn x) (f (drop-while first-fn x))))))","problem":31,"user":"52379c46e4b0fae3832e99db"},{"code":"#(partition-by (fn[x] x) %)","problem":31,"user":"5357b241e4b04ce2eb3ed282"},{"problem":31,"code":"(fn [col]\n   (->> col\n        (partition-by identity)\n        ;; (map first)\n        ))","user":"60537cd1e4b04c8f2157d152"},{"problem":31,"code":"#(loop [[head & tail :as coll] %\n        curr nil\n        acc []]\n   (let [[thead & ttail] tail]\n     (println \"head=\" head \"thead=\" thead \"ttail=\" ttail \"curr=\" curr \"acc=\" acc)\n     (if (nil? head)\n       acc\n       (if (= head thead)\n         (recur (conj ttail head) (conj curr thead) acc)\n         (recur tail nil (conj acc (conj curr head)))\n       )\n     )\n   )\n)","user":"53f7820be4b0de5c41848560"},{"problem":31,"code":"#(loop [s (next %) r [] acc (list (first %))]\n   (if (nil? s)\n     (if (empty? acc)\n       r\n       (conj r acc))\n     (if (= (first s) (last acc))\n       (recur (next s) r (conj acc (first s)))\n       (recur (next s) (conj r acc) (list (first s))))))","user":"564b3730e4b0284900eef665"},{"problem":31,"code":"#(reverse \n  (reduce (fn [r x] \n            (if (= x (first (first r))) \n              (conj (rest r) (conj (first r) x)) \n              (conj r (list x)))) \n          '() %))","user":"55344b75e4b09218d5f44f99"},{"code":"(fn ppack [x] (cond\n                 (= (count x) 1) (list (list (first x)))\n                 (not= (first x) (first (rest x)))\n                 (conj (ppack (rest x)) (list (first x)))\n                 :else (let [rep (ppack (rest x))]\n                            (conj (rest rep) (conj (first rep) (first x))))\n                 ))","problem":31,"user":"4f524d11e4b03ad3f0c10d34"},{"problem":31,"code":"(fn pack [s]\n  (if (seq s)\n    (let [reps (take-while #(= % (first s)) s)]\n      (lazy-seq (cons reps (pack (drop (count reps) s)))))\n    '()))","user":"54ca93abe4b057c6fda3a264"},{"problem":31,"code":"(fn \n  [x]\n  (reverse (loop [p x\n         y (list)\n         curr nil\n         final (list)]\n    (cond (empty? p) (conj final y)\n          (not= curr (first p))\n                  (recur (rest p) (list (first p)) (first p)\n                         (if (empty? y)\n                           final\n                         (conj final y)))\n           :else   (recur (rest p) (conj y (first p)) (first p) final)))))","user":"59e4fc25e4b08badc2a0c54f"},{"code":"(fn pack [s]\n  (loop [s s prev `prev# acc []]\n    (if (empty? s) acc\n        (let [[x & xs] s]\n          (if (= x prev)\n            (recur xs x (conj (pop acc) (conj (peek acc) x)))\n            (recur xs x (conj acc [x])))))))","problem":31,"user":"4f0ef874535d0136e6c22328"},{"problem":31,"code":"(fn [old & new]\n  (if (empty? old)\n    (reverse new)\n    (recur (rest old)\n      (if (= (first old) (first (first new)))\n        (conj (pop new) (conj (first new) (first old)))\n        (conj new (conj () (first old))) \n      )\n    )\n  )      \n)","user":"5bbd13a5e4b07a9b28b0ff95"},{"code":"(fn [c]\n    (partition-by identity c))","problem":31,"user":"500ea957e4b00fff93030f9b"},{"problem":31,"code":"(fn [xs]\n  (partition-by identity xs)\n )","user":"6034e358e4b0d5df2af222d1"},{"problem":31,"code":"(fn\n  [items]\n  (reduce\n   (fn [accum curr]\n     (if (= curr (last (last accum)))\n       (conj (into [] (drop-last accum)) (conj (last accum) curr))\n       (conj accum (vector curr))))\n   []\n   items))","user":"5dd25ca8e4b0948ae9d9ad55"},{"problem":31,"code":"(fn [xs]\n  (loop [xs-left xs\n         pack    []\n         packed  []]\n    \n    (if-let [x (first xs-left)]\n      \n      ; x is not nil\n      (if (= x (last pack))\n        \n        ; x belongs in the pack\n        (recur (rest xs-left) \n               (conj pack x) \n               packed)\n        \n        ; pack is done - start a new one\n        (recur (rest xs-left) \n               [x] \n               (if (seq pack)\n                 (conj packed pack) \n                 packed)))\n      \n      ; else x is nil\n      (if (seq pack) \n        (conj packed pack) \n        packed))))","user":"57006957e4b08d47c97781c8"},{"problem":31,"code":"(fn [xs]\n  (loop [xs xs\n         acc nil\n         this (first xs)\n         this-sub-list nil]\n    (if (empty? xs)\n      (reverse (cons this-sub-list acc))\n      (if (= this (first xs))\n        (recur (rest xs) acc this (cons this this-sub-list))\n        (recur (rest xs) (cons this-sub-list acc) (first xs) (list (first xs)))))))","user":"5b673832e4b0c6492753e760"},{"problem":31,"code":"(fn pack [lst]\n  (loop [lst lst\n         nuevo ()\n         temp ()]\n        (if (empty? lst)\n            (reverse nuevo)\n            (recur (rest lst)\n                   (if (= (first lst) (second lst))\n                       nuevo\n                       (cons (cons (first lst) temp) nuevo))\n                    (if (= (first lst) (second lst))\n                        (cons (first lst) temp)\n                        () )))))","user":"57f8151ce4b0d3187e900912"},{"problem":31,"code":"(fn [s]\n            (reverse (reduce (fn [p si]\n                               (let [p1 (first p)\n                                     dup (= (first p1)\n                                            si)\n                                     p1* (if dup\n                                           (conj p1 si)\n                                           (list si))\n                                     p* (if dup\n                                          (conj (rest p) p1*)\n                                          (conj p p1*))]\n                                 p*))\n                             '()\n                             s)))","user":"57f904c5e4b0d3187e900936"},{"code":"(fn [a-seq]\r\n  (reverse\r\n    (loop [new-seq (seq '()) org-seq a-seq]\r\n      (if (empty? org-seq)\r\n        new-seq\r\n        (let [xs (split-with #(= % (first org-seq)) org-seq)]\r\n          (recur (conj new-seq (first xs)) (last xs)))))))","problem":31,"user":"4dd61f98535d2dad7130b5c6"},{"problem":31,"code":"(fn compress-seq [xs] (reduce (fn [acc x] (if (= x (last (last acc)))\n                                            (reverse (conj (reverse (butlast acc)) (conj (last acc) x)))\n                                            (reverse (conj (reverse acc) (conj '() x))))) '() xs))","user":"56255e2de4b00a550fc90297"},{"problem":31,"code":"(fn pack [coll]\n  (loop [[x & xs] coll\n         acc []]\n    (if (nil? x)\n      acc\n      (recur (drop-while #(= % x) xs) (conj acc (concat [x] (take-while #(= % x) xs)))))))","user":"56a51f26e4b0542e1f8d14e0"},{"code":"#(loop [result [] in (rest %) f (first %) cnt 1]\n  (if (= (count in) 0)\n    (concat result (list (repeat cnt f)))\n    ( \n      if ( = f (first in) )\n     \t(recur result (rest in) f (inc cnt))\n      (recur (concat result (list (repeat cnt f))) (rest in) (first in) 1)\n      )\n    )\n  )","problem":31,"user":"528f4462e4b0239c8a67aef0"},{"code":"#(\n  \n partition-by identity % \n)","problem":31,"user":"50bf7b72e4b0ffd967a66cc1"},{"code":"#(partition-by (fn[x](.indexOf % x)) %)","problem":31,"user":"4ed2dd98535d44c135fd68e2"},{"problem":31,"code":"(fn split [x] \n       (if (empty? x)\n         []\n         (let [y (split (rest x))]\n           (if (= (first x) (first (first y)))\n             (concat (list (conj (first y) (first x))) (rest y)) \n             (if (empty? y)\n               (list (list (first x)))\n               (concat (list (list (first x))) y))))))","user":"5654cb2de4b0f9d632dd848b"},{"problem":31,"code":"(fn [coll] (reduce #(if (= (last (last %1)) %2) (update-in %1 [(dec (count %1))] conj %2) (conj %1 [%2])) [] coll))","user":"5659679ae4b068f2fe63dbeb"},{"code":"(fn [v]\n  (reverse (reduce (fn [accum elem]\n           (println accum elem)\n           (if (= (-> accum first first) elem)\n             (let [new-head (cons elem (first accum))\n                   new-tail (rest accum)]\n               (cons new-head new-tail))\n             (let [new-head (list elem)\n                   new-tail accum]\n               (cons new-head new-tail))))\n          '() v)))","problem":31,"user":"504e0136e4b078edc5f5938e"},{"code":"(fn takeident [coll]\n(lazy-seq\n  (let [i (first coll)]\n    (when (not (nil? i))\n      (cons (take-while #(= i %) coll) (takeident (drop-while #(= i %) coll)))))))","problem":31,"user":"4e7ada51535db169f9c796ae"},{"code":"reduce #(if (= %2 (last (last %1))) (conj (vec (butlast %1)) (conj (last %1) %2)) (conj %1 [%2])) []","problem":31,"user":"525fea5ae4b03e8d9a4a7026"},{"problem":31,"code":"(fn pack-cons-dups [coll]\n  (partition-by identity coll))","user":"5aa4f7dae4b0d174b936c88c"},{"problem":31,"code":"(fn mycomp2 [c]\n  (if (empty? c)\n    '()\n    (concat (list (take-while  #(= (first c) %) c))\n            (mycomp2 (drop-while  #(= (first c) %) c)))))","user":"5bfc9037e4b0bdcf453d15f2"},{"code":"(fn u\n  ([x] \n    (u (rest x) [(first x)])) \n  ([x f] \n    (if x \n      (let [[s & xs] x] \n        (if (= s (first f)) \n          (u xs (conj f s)) \n          (conj (u xs [s]) f))) \n      (list f))))","problem":31,"user":"4f1fd734535d64f6031464a5"},{"problem":31,"code":"(fn [coll]\n  (loop [result () acoll coll ]\n     (let [ chk (first acoll) [a subcoll]\n        (split-with (fn [itm] (= chk itm) ) acoll)]\n       \n       (if (nil? chk)\n         (reverse result)\n         (recur (conj result a) subcoll) \n         )       \n       \n       )\n  )\n)","user":"5135a74ae4b04ac1f358dd46"},{"code":"#(loop [seq %\n         acc '()]\n    (if (empty? seq)\n      (reverse acc)\n      (if (= (first seq) (first (first acc)))\n        (recur (rest seq) (cons (cons (first seq) (first acc)) (rest acc)))\n        (recur (rest seq) (cons (list (first seq)) acc)))))","problem":31,"user":"533d2ea5e4b085b17e897d7a"},{"code":"(fn pack\n  ([xs] (pack (rest xs) [(first xs)] []))\n  ([xs cur accum]\n    (if (empty? xs)\n      (conj accum cur)\n      (if (= (first cur) (first xs))\n        (pack (rest xs) (conj cur (first xs)) accum)\n        (pack (rest xs) [(first xs)] (conj accum cur))))))","problem":31,"user":"524740e7e4b05ef8e38e635d"},{"problem":31,"code":"(fn pack [xs]\n   (if (empty? xs)\n       ()\n       (letfn [(cntdup [ys]\n          \t\t(if (not= (first ys) (second ys)) 1\n              \t(inc (cntdup (rest ys)))))]\n           (concat (list (repeat (cntdup xs) (first xs))) (pack (drop (cntdup xs) xs))))))","user":"53e9a15be4b036ad0777e4ae"},{"problem":31,"code":"(fn [x]\n    (reverse (reduce #(if (= %2 (first (first %1)))\n                        (conj (rest %1) (conj (first %1) %2))\n                        (conj %1 (list %2)))\n                     (list (list (first x))) (rest x))))","user":"52b2f9cae4b0c58976d9acfb"},{"problem":31,"code":"(fn\n  [xs]\n  (reverse (reduce (fn\n            [acc x]\n            (if (= (first (first acc)) x)\n              (conj (rest acc) (conj (first acc) x))\n              (conj acc (list x))))\n          '()\n          xs)))","user":"5e1c24f4e4b0dc959400852d"},{"problem":31,"code":"(fn pack [s]\n  (loop [a s prev (first s) temp nil ans nil]\n    (cond \n     (empty? a) (reverse (cons temp ans))\n     (= (first a) prev) (recur (rest a) prev (cons (first a) temp) ans)\n     :else (recur a (first a) nil (cons temp ans)))))","user":"5a962c09e4b0d174b936c765"},{"code":"#(letfn [(pack [xs temp acc]\n  (if (empty? xs) \n\t\t(conj acc temp)\n\t\t(let [x (first xs) a (last temp)] \n\t\t\t(if (= x a) \n\t\t\t\t(recur (rest xs) (conj temp x) acc) \n\t\t\t\t(recur (rest xs) [x] (conj acc temp))))))]\n\t(rest (pack % [] [])))","problem":31,"user":"4ef5c7ce535dced4c769f248"},{"code":"(fn [coll]\n  (loop [c coll r '()]\n    (cond\n     (empty? c) (reverse r)\n     (= (first c) (-> r first first))\n     (recur (rest c) (conj (rest r) (conj (first r) (first c))))\n     :else (recur (rest c) (conj r (list (first c)))))))","problem":31,"user":"51991a89e4b068aa333628fd"},{"problem":31,"code":"(fn [se]\n(rest\n(reduce \n        (fn [collu value ]\n            (if \n                (= (last (last collu)) value)\n                (conj (pop collu) (conj (last collu) value) )\n                (conj collu (vector value))\n             )\n            \n        )\n        [[]]\n        se\n        )\n    )\n    )","user":"5e23ca7fe4b05b4b01516144"},{"problem":31,"code":"(fn [coll]\n  (loop [c coll\n         acc []\n         sub [(first c)]]\n    (if (empty? c)\n      acc\n      (if (= (first c) (second c))\n        (recur (rest c) acc (conj sub (first c)))\n        (recur (rest c) (conj acc sub) [(second c)])))))","user":"556a6137e4b09a3098a524e0"},{"code":"(fn [sek] (loop [lista nil i 0 n 1]\n(cond\n(= i (count sek)) (reverse lista)\n(= (nth sek i) (nth sek (+ i 1) nil)) (recur lista (inc i) (inc n))\n:else (recur (conj lista (take n (drop (- i (- n 1)) (seq sek)))) (inc i) 1)\n)))","problem":31,"user":"4e218464535d04ed9115e816"},{"code":"(fn [s]\n  (loop [s_ s ret '() cur nil]\n    (cond\n      (and (not s_) (not cur))\n        (into '() ret)\n      (not s_)\n        (recur s_ (conj ret (into '() cur)) nil)\n      (and s_ cur (not= (first s_) (first cur)))\n        (recur \n          (next s_) \n          (conj ret (into '() cur)) \n          (list (first s_)))\n      :else\n        (recur (next s_) ret (conj cur (first s_))))))","problem":31,"user":"4f050dec535dcb61093f6bef"},{"problem":31,"code":"(fn pack[n]\n  (partition-by identity n))","user":"6085edade4b0736b099e42fc"},{"problem":31,"code":"(fn [sq]\n    (reduce (fn [result item]\n              (if (and (coll? (last result))\n                       (= item (last (last result)))\n                       )\n                (conj (vec (drop-last result)) (conj (last result) item))\n                (conj result [item])\n                )\n              )\n            []\n            sq\n            )\n    )","user":"571a282ae4b07c98581c3b46"},{"code":"(fn[x] (partition-by identity x))","problem":31,"user":"4f32135ae4b0d6649770a08e"},{"code":"(fn [x]\n  (loop [acc '()\n         lacc (list (first x))\n         todo (rest x)]\n    (let [ft (first todo)]\n      (if (empty? todo)\n         (reverse (into acc (list lacc)))\n        (if (= ft (first lacc))\n          (recur acc (conj lacc ft) (rest todo))\n          (recur (conj acc lacc) (list ft) (rest todo)))))))","problem":31,"user":"4f08a8a2535dcb61093f6c3d"},{"problem":31,"code":"(fn pack [coll]\n  (if (empty? coll)\n    nil\n    (let [f (first coll)\n          splitted (split-with #(= f %) coll)]\n      (cons (first splitted) (pack (second splitted))))))","user":"548ade6de4b0e286459a11f6"},{"problem":31,"code":"(fn pack-sequence [x]\n  (loop [source x, acc []]\n    (if (empty? source)\n      acc\n      (if (= (first source) (last (last acc)))\n        (recur (next source) (assoc acc (- (count acc) 1) (conj (last acc) (first source))))\n        (recur (next source) (conj acc [(first source)]))))))","user":"56798d83e4b05957ce8c618b"},{"problem":31,"code":"(fn [x]\n  (loop [data (next x) sublist (list (first x)) answer []]\n    (if (nil? data)\n      (conj answer sublist)\n      (if (= (first data) (first sublist))\n        (recur (next data) (conj sublist (first data)) answer)\n        (recur (next data) (list (first data)) (conj answer sublist))))))","user":"57894e30e4b0ebec4cfb752b"},{"problem":31,"code":"(fn ap-partitioner\n  [a-seq]\n  (reduce (fn [res next-el]\n            (let [last-el (first (last res))]\n              (cond\n                (= last-el next-el) (concat (butlast res)\n                                          (list (concat (last res)\n                                                        (list next-el))))\n                :else (concat res (list (list next-el))))))\n          '()\n          a-seq))","user":"580d2788e4b0849f6811b730"},{"problem":31,"code":"(fn f\n  ([[a & b]] (reverse (f b (list (list a)))))\n  ([s acc]\n   (if (empty? s) acc\n     (let [[a & b] s]\n       (if (= a (first (first acc)))\n         (f b (cons (cons a (first acc))\n                    (rest acc)))\n         (f b (cons (list a) acc)))))))","user":"57a0b341e4b0c3d858beb8d4"},{"problem":31,"code":"(fn [coll]\n  (loop [result (empty coll) rem coll]\n    (if (empty? rem)                                         result\n      (recur (conj\n              result                                                 (take-while                                             #(= % (first rem))\n               rem))\n             (drop-while\n              #(= % (first rem))                                     rem)))))","user":"56403765e4b08d4f616f5edc"},{"problem":31,"code":"(fn pack [x]\n  (cond\n    (= () x) x\n    (= () (rest x)) (conj () x)\n    :else (reverse ((fn pack-helper [x y]\n             (cond\n               (= () x) y\n               :else (cond\n                       (= (first x) (first (first y))) (pack-helper (rest x) (conj (rest y) (conj (first y) (first x))))\n                       :else (pack-helper (rest x) (conj y (conj () (first x))))\n                     )\n             )\n           ) (rest x) (conj () (conj () (first x)))))\n  )\n)","user":"58f92297e4b0438e51c2cf43"},{"problem":31,"code":"(fn packed [coll] \n  (partition-by identity coll))","user":"53bf0913e4b0c98a41f5cc99"},{"code":"(fn pack [initxs]\r\n  (loop [ys [], sublist [], xs initxs]\r\n    (if (empty? xs)\r\n      (conj ys sublist)\r\n      (if (empty? sublist)\r\n        (recur ys [(first xs)] (rest xs))\r\n        (if (= (first xs) (first sublist))\r\n          (recur ys (conj sublist (first xs)) (rest xs))\r\n          (recur (conj ys sublist) [(first xs)] (rest xs)))))))","problem":31,"user":"4e123905535d04ed9115e7ce"},{"code":"(fn [l] \n  (let [pack (fn p [x acc pac] \n               (cond \n                (empty? x) (cons pac acc)\n                (empty? pac) (p (rest x) acc (cons (first x) pac))\n                (= (first pac) (first x)) (p (rest x) acc (cons (first x) pac))\n                :else (p x (cons pac acc) '())\n                )\n               )\n        ]\n\t    (reverse (pack l '() '()))   \n    )\n  )","problem":31,"user":"535197f2e4b084c2834f4ae4"},{"problem":31,"code":"#(reverse\n (reduce \n (fn [s r]\n   (if (= r (first (first s)))\n    (conj (rest s) \n          (conj (first s) r))\n    (conj s (conj () r))\n   )\n )\n ()\n%))","user":"5c0d0537e4b0bdcf453d173d"},{"code":"(fn [xs]\n  (loop [acc '()\n         xs (reverse xs)]\n         (if (= (count xs) 0) acc\n         (recur\n           (conj acc (take-while #(= (first xs) %) xs))\n                     (drop-while #(= (first xs) %) xs)))))","problem":31,"user":"4f748b54e4b044e54cd9a8fa"},{"code":"(fn ppp [i] (partition-by identity i))","problem":31,"user":"52ffb7f2e4b0d8b024fd370b"},{"code":"(fn [L] (reduce \n              #(if (= (last (last %1)) %2) \n                 (assoc %1 (- (count %1) 1) (conj (last %1) %2))\n                 (conj %1 [%2])) \n              []  L))","problem":31,"user":"4f73f78de4b044e54cd9a8f3"},{"code":"(fn [a]\n  (partition-by identity a))","problem":31,"user":"4ff58b05e4b0678c553fc36b"},{"problem":31,"code":"#(->> %\n      (reduce (fn [[agg pre] n]\n                (if (= (first pre) n) \n                  [agg (cons n pre)] \n                  [(conj agg pre) (list n)])\n                ) [[] ()])\n      (apply conj)\n      (drop 1)\n      )","user":"60471241e4b02d28681c77c9"},{"code":"(fn [a] (partition-by (fn [x] x) a))","problem":31,"user":"4e78dc98535db95036265724"},{"problem":31,"code":"#(seq(reduce (fn [vec elem] \n   (if  (= (last (last vec)) elem)\n        (update-in vec [(- (count vec) 1)] conj elem)\n        (conj vec (list elem))\n    \n   )\n   \n) []   %))","user":"5beebdb7e4b0a6d31fed2132"},{"problem":31,"code":"(fn pack-sequence [xs]\n  (if (empty? xs)\n    '()\n    (let [chunks (split-with #(= % (first xs)) xs)]\n      (if (= (count chunks) 1)\n        chunks\n        (concat\n         (list (first chunks))\n         (pack-sequence (second chunks)))))))","user":"59f7f55de4b0ca45a743a313"},{"problem":31,"code":"#(reduce\n  (fn [acc item]\n    (if (= item (first (last acc)))\n      (conj (apply vector (drop-last 1 acc)) (conj (last acc) item))\n      (conj acc [ item ])\n    )) [] %)","user":"5d123457e4b02c15ef021996"},{"problem":31,"code":"(fn [m]  (partition-by identity m))","user":"6086abade4b0736b099e42ff"},{"problem":31,"code":"(fn [in] (let [coll (seq in)] (partition-by (fn [x] x) coll)))","user":"5429986ce4b01498b1a71b3b"},{"code":"(fn P [l]\n  (loop [l l last false result []]\n    (cond (empty? l) (if last (conj result last) result)\n          (not last) (recur (rest l) [(first l)] result)\n          (= (first l) (first last)) (recur (rest l) (conj last (first l)) result)\n          :else (recur (rest l) [(first l)] (conj result last)))))","problem":31,"user":"51a4416ae4b0def3c5c5868c"},{"problem":31,"code":"#(reverse ( reduce\n ( fn red [ result nxt ]\n  ( if ( = ( count result ) 0 )\n   ( conj result [ nxt ] )\n   ( let [ firstitem ( first result ) ]\n    ( if ( = ( first firstitem ) nxt )\n      ( conj ( rest result ) ( conj firstitem nxt ) )\n      ( conj result [ nxt ] )\n    )\n   )\n  )\n )\n '() %) )","user":"5d5c6675e4b09db18d4482ec"},{"problem":31,"code":"(fn [s]\n  (loop [e s l ()]\n    (if (empty? e)\n      (reverse l)\n      (recur (drop-while #(= % (first e)) e) (conj l (take-while #(= % (first e)) e))))))","user":"55aaa36fe4b0988bba2ad94f"},{"problem":31,"code":"(fn [s]\n  ((fn [sequ result]\n    (if (empty? sequ)\n      result\n      (let [example (first sequ)\n            subseq (take-while #(= % example) sequ)\n            rest (drop-while #(= % example) sequ)]\n        (recur rest (concat result (conj '() subseq)))))) s '()))","user":"5713c575e4b07c98581c3aab"},{"problem":31,"code":"(fn pack-a-seq [x] \n  (let [f (fn anon [b x] ; boolean collection\n    (if (= (count x) 1) x \n      (let [h (first x)\n            t (rest x)]\n        (if (and b (sequential? h))\n          (let [i (first h)\n                j (first t)]\n            (if (= i j)\n              (anon true (concat (list (conj h j)) (rest t)))\n              (concat (list h) (anon true (concat (list (list j)) (rest t))))))\n          (anon true (concat (list (list h)) t))))))]\n    (f false x)))","user":"57d1d6c8e4b0bd073c202370"},{"problem":31,"code":"(fn [sequence]\n  (loop [sequence sequence\n         found nil\n         count 0\n         acc []]\n    (if (empty? sequence) (conj acc (take count (repeat found)))\n        (cond (= found (first sequence))\n                (recur (rest sequence)\n                       found\n                       (inc count)\n                       acc)\n              (not (nil? found))\n                (recur (rest sequence)\n                       (first sequence)\n                        1\n                        (conj acc (take count (repeat found))))\n              true\n                (recur (rest sequence)\n                       (first sequence)\n                       1\n                       acc)))))","user":"5461c402e4b01be26fd746a6"},{"code":"(fn paket [coll]\n  (when-let [[f & r] (seq coll)]\n    (if (nil? r)\n      (list (list f))\n      (let [paketv (paket r)]\n        (if (= f (first (first paketv)))\n          (conj (rest paketv) (conj (first paketv) f))\n          (conj paketv (list f)))))\n    ))","problem":31,"user":"4f82f1b9e4b033992c121c0f"},{"problem":31,"code":"(fn [xs]\n   (partition-by identity xs))","user":"5b96800ae4b0c0b3ffbd4a7b"},{"problem":31,"code":"(fn \n  [x]\n   (reduce (fn \n              [cur nxt]\n             (if (coll? (last cur))\n               (if (= (last (last cur)) nxt)\n                 (conj (into [] (drop-last cur)) (conj (last cur) nxt))\n                 (conj (into [] cur) (vector nxt)))\n                (conj (into [] cur) (vector nxt)))\n              ) [] x))","user":"5632abbee4b0bfe05bf117a7"},{"problem":31,"code":"(fn foo1\n\n  [parm]\n  (loop\n    [x 0                                                    \n     col parm                                               \n     mcoll ()                                            \n     coll ()]                                             \n    (if (> x (count col))                                   \n      (rest ( reverse coll))\n      (recur\n        (inc x)\n        col                                                \n        ((fn foo2\n\n  [parm1 mcoll coll]                                       \n  (if (= parm1 (last mcoll))\n    (cons parm1 mcoll)\n    (let [mcoll (list parm1)] mcoll)))         (get col x) mcoll coll)                      \n        ((fn foo3\n \n  [parm1 mcoll coll]                                        \n  (if (= parm1 (last mcoll))\n    coll\n    (cons mcoll coll)))                (get col x) mcoll coll)                      \n        ))))","user":"598d0dc3e4b02b9968b84d18"},{"problem":31,"code":"(fn pack\n  [input]\n  (reverse\n   (reduce \n    (fn [output item]\n     (if (= item (ffirst output))\n      (conj (rest output) (conj (first output) item))\n      (conj output (list item))))\n   '() input)))","user":"5bc4f266e4b07a9b28b10066"},{"problem":31,"code":"(fn [x]\n  (reverse\n    (reduce\n      (fn [res el]\n          (if (= (first (first res)) el)\n            (conj (next res) (conj (first res) el))\n            (conj res (list el))\n           )\n       )\n      '() x)))","user":"5fc9d967e4b0689391cc77ce"},{"code":"#(letfn [(same [lst]\n          (if (= (first lst) (first (rest lst)))\n            (cons (first lst) (same (rest lst)))\n            (list (first lst))))\n         (skip [lst x]\n          (if (not= (first lst) x)\n            lst\n            (skip (rest lst) x)))\n         (f [lst]\n          (if (= '() lst)\n              '()\n              (cons (same lst) (f (skip lst (first lst))))))]\n  (f %))","problem":31,"user":"50b668dde4b08fb537db98f2"},{"problem":31,"code":"(fn f[x]\n  (if (empty? x)\n    '()\n\t(cons \n     \t(take-while #(= % (first x)) x) \n     \t(f (drop-while #(= % (first x)) x))\n    )\n  )\n)","user":"54283a7ae4b01498b1a71b2f"},{"code":"(fn pack [n]\r\n  (partition-by identity n))","problem":31,"user":"4ddb339c535d02782fcbe9f9"},{"problem":31,"code":"(fn pack\n  [s]\n  (reduce\n   (fn [acc e]\n     (if (some #{e} (last acc))\n       ;; 4Clojure doesn't support `update`\n       (assoc acc (dec (count acc)) (conj (last acc) e))\n       (conj acc (list e))))\n   []\n   s))","user":"5bab49bbe4b0a20761a23474"},{"problem":31,"code":";#(partition-by identity %)\n\n;; probably more what they had in mind\n(fn pack\n  ([coll]\n     (pack [] [(first coll)] (rest coll)))\n  ([res current coll]\n     (let [next (first coll)]\n       (if (empty? coll) (conj res current)\n           (if (= next (first current))\n             (pack res (conj current next) (rest coll))\n             (pack (conj res current) [next] (rest coll)))))))","user":"53322cece4b019098a6f8b73"},{"problem":31,"code":"(fn my-pack2 [coll]\n (letfn [(pack-aux [acc val] (if (or (= (first (first acc)) val) (empty? (first acc)))\n   (conj (rest acc) (conj (first acc) val))\n   (conj acc (list val))))]\n (reverse (reduce pack-aux '(()) coll))))","user":"5bcf95ace4b0e9689409ee2e"},{"code":"#(partition-by str %)","problem":31,"user":"4e6ea1f5535d5021c1a8960e"},{"code":"(fn f [s]\n  (if (empty? s)\n    '()\n    (let [[x xs] (split-with #(= (first s) %) s)]\n      (cons x (f xs)))))","problem":31,"user":"504e04a4e4b078edc5f59397"},{"code":"(fn [s]\n  (partition-by identity s))","problem":31,"user":"4ed9354f535d10e5ff6f5301"},{"problem":31,"code":"(fn [s]\n   (seq (reduce\n          (fn [acc e]\n            (if (= (first (last acc)) e)\n              (conj (pop acc) (cons e (last acc)))\n              (conj acc (list e))))\n          [(list (first s))]\n          (rest s))))","user":"5812eb8fe4b0f478707a0602"},{"problem":31,"code":"(fn [l]\n    (loop [l l out []]\n      (let [consec (take-while #(= (first l) %) l)]\n        (if (not (empty? consec))\n          (recur (drop (count consec) l) (conj out consec))\n          out)))\n    )","user":"5cc6f982e4b0ccb06196282d"},{"code":"reduce (fn [a x]\n  (if (= (last (last a)) x)\n    (conj (vec (butlast a)) (conj (last a) x))\n    (conj a [x])))\n[]","problem":31,"user":"4ea1b9e4535d7eef308072b8"},{"code":"#(loop [r [] t [] c %]\n   (if (empty? c)\n     (conj r t)\n     (cond\n       (empty? t) (recur r [(first c)] (rest c))\n       (= (first t) (first c)) (recur r (conj t (first c)) (rest c))\n       :else (recur (conj r t) [(first c)] (rest c)))))","problem":31,"user":"4e6a5f5c535d8ccf87e9fed6"},{"problem":31,"code":"(fn [coll]\n   (loop [pack '()\n          c coll\n          res []]\n     (when-let [[f & r] c]\n       (let [pack-key (first pack)]\n         (cond (nil? r) (if (= f pack-key)\n                          (conj res (cons f pack))\n                          (conj (conj res pack) (list f)))\n               (nil? pack-key) (recur (cons f pack)\n                                      r\n                                      res)\n               (= f pack-key) (recur (cons f pack)\n                                     r\n                                     res)\n               :else (recur (list f)\n                            r\n                            (conj res pack)))))))","user":"55860905e4b001b0851d7516"},{"problem":31,"code":"(fn packer [x]\n\t(loop [x x acc []]\n\t\t(if (empty? x) \n\t\t\tacc\n\t\t\t(recur (rest x) (if (= (first x) (last (last acc)))\n\t\t\t\t\t\t\t\t(assoc acc (dec (count acc)) (conj (last acc) (first x)))\n\t\t\t\t\t\t\t\t(conj acc [(first x)]))))))","user":"53703287e4b0fc7073fd6e8f"},{"code":"(fn un [p]\n  (if (< (count p) 2)\n    (list p)\n(let [f (first p)\n      s (second p)\n      n (next p)\n      unn (un n)]\n  (if (= f s)\n    (if-not (= f (first unn))\n      (cons (cons f (first unn)) (next unn))\n      (cons (list f s) (next unn)))\n    (cons (list f) unn)))))","problem":31,"user":"53908e6be4b0b51d73faae9a"},{"problem":31,"code":"(fn packSeq\n  [col]\n  (partition-by identity col))","user":"58dd2c02e4b0a4d5acaab6b8"},{"problem":31,"code":"(fn pack\n      ([lista] (pack (rest lista) [] [(first lista)] (first lista)))\n      ([lista nlista palista last]\n        (if (empty? lista)\n          (seq (conj nlista (seq palista)))\n          (if (= last (first lista))\n            (pack (rest lista) nlista (conj palista (first lista)) last)\n            (pack (rest lista) (conj nlista (seq palista)) [(first lista)] (first lista))))))","user":"540271aee4b0df28a13c62d0"},{"problem":31,"code":"(fn pack-seq \n  [x]\n  (partition-by identity x)\n  )","user":"5ac74b34e4b0e27600da777f"},{"problem":31,"code":"(fn [s]\n  (loop [in s, x (first s), size 0, out []]\n    (cond (empty? in) (conj out (repeat size x))\n          (= x (first in)) (recur (rest in) x (inc size) out)\n          :else (recur (rest in) (first in) 1 (conj out (repeat size x))))))","user":"55c68089e4b0e31453f649c4"},{"problem":31,"code":"(fn unflatten\n  [xs]\n  (if (empty? xs)\n    []\n    (let [dups (take-while #(= % (first xs)) xs)\n          tail (drop (count dups) xs)]\n    (cons dups (unflatten tail))))\n)","user":"5b9da7fbe4b0c0b3ffbd4b3f"},{"problem":31,"code":"(fn [nums] (reverse (reduce (fn [nums current]\n            (println nums)\n            (println current)\n            (println (conj (first nums) current))\n            (if (empty? nums)\n                [[current]]\n                (if (= current (first (first nums)))\n                    (conj (rest nums) (conj (first nums) current))\n                    (conj nums [current])))) [] nums)))","user":"5a21d34ce4b0ff51aa4b32b9"},{"code":"(fn [coll]\r\n  (loop [old coll, result []]\r\n    (let [f (first old)]\r\n      (if (empty? old)\r\n        result\r\n        (recur (drop-while #(= f %) old)\r\n        (conj result (take-while #(= f %) old)))))))","problem":31,"user":"4df407c3535d08e6dec9fe2e"},{"problem":31,"code":"(fn pack [x]\r\n  (loop [[f & r] (rest x)\r\n         curr [(first x)]\r\n         res []]\r\n    (if (nil? f)\r\n      (conj res curr)\r\n      (if (= f (first curr))\r\n        (recur r (conj curr f) res)\r\n        (recur r [f] (conj res curr))))))","user":"546e1142e4b00cfc9eacc199"},{"problem":31,"code":"#(loop [coll % sqs () lst nil]\n   (if (seq coll)\n     (let [f (first coll) n (rest coll)]\n       (if (= lst f)\n         (recur n (conj (rest sqs) (conj (first sqs) lst)) lst)\n         (recur n (conj sqs (seq [f])) f)))\n     (reverse sqs)))","user":"5658acabe4b0f9d632dd84b7"},{"problem":31,"code":"(fn [seqq]\n  (partition-by identity seqq))","user":"6088395de4b0ae75613dcee2"},{"code":"(fn pack [coll]\r\n   (if (seq coll)\r\n     (let [[keep & tail] (split-with #(= (first coll) %) coll)]\r\n       (cons keep (pack (first tail))))))","problem":31,"user":"4de623ef535d08e6dec9fdf4"},{"problem":31,"code":"(fn \n  [xs]\n  (let [res (reduce\n    (fn [[out ps] x] (if (= x (first ps)) [out (conj ps x)] [(conj out ps) (list x)]))\n    [[] (list (first xs))]\n    (rest xs))]\n    (conj (first res) (second res))))","user":"5823c717e4b051871117beb2"},{"code":"(fn f [l] \n  (if (empty? l) \n    l \n    (if (= (first l) (second l)) \n      (cons (take-while #(= (first l) %) l) (f (drop-while #(= (first l) %) l)))\n      (cons (take 1 l) (f (rest l)))\n    )\n  )\n)","problem":31,"user":"5349ac2be4b084c2834f4a67"},{"problem":31,"code":"#(loop [s (rest %) r [] u (list (first %))]\n   (if (empty? s) \n     (conj r u) \n     (if (= (first s) (last u))  \n       (recur (rest s) r (conj u (first s)))\n       (recur (rest s) (conj r u) (list (first s)))\n       )))","user":"587c59d1e4b01531a375eb17"},{"code":"partition-by #(list %1)","problem":31,"user":"4f9f9ff5e4b0dcca54ed6d3a"},{"problem":31,"code":"(fn pack [xs] (loop [result '() remaining xs]\n                  (let [head (first remaining) tail (rest remaining)]\n                  (cond\n                    (empty? remaining) \n                    result\n                    (empty? result) \n                    (recur (list (list head)) tail)\n                    (= (last (last result)) head) \n                    (recur (concat (butlast result) (list (conj (last result) head))) tail)\n                    :else\n                    (recur (concat result (list (list head))) tail)\n                    ))))","user":"5de48f92e4b0948ae9d9ae07"},{"code":"partition-by list","problem":31,"user":"4e8a460e535d65386fec2109"},{"problem":31,"code":"(fn f2 [coll]\n  (reverse (reduce (fn [t v]\n            (if (= (first (first t)) v)\n              (cons (cons v (first t)) (rest t))\n              (do (println t)\n              (cons (list v) t)))) () coll)))","user":"58edaa3be4b056aecfd47d89"},{"problem":31,"code":"(fn [coll]\n  ((fn [l acc prev]\n    (if (empty? l)\n      (into '() acc)\n      (recur (rest l)\n             (if (= prev (first l))\n               (cons (cons prev (first acc)) (rest acc))\n               (cons (list (first l)) acc))\n             (first l))))\n   coll '() nil))","user":"56588f4ee4b0f9d632dd84b6"},{"code":"(fn consecs [s]\n  (if (empty? s)\n    '()\n  \t(let [f (first s)]\n      (cons \n       (take-while #(= % f) s)\n       (consecs (drop-while #(= % f) s))))))","problem":31,"user":"52090654e4b0e152394d76ee"},{"problem":31,"code":"reduce #(if (= (last (last %1)) %2) (conj (vec (drop-last %1)) (conj (last %1) %2)) (conj %1 [%2])) []","user":"5632e850e4b0bfe05bf117ac"},{"code":"(fn [input]\r\n    (reduce\r\n        (fn [current next]\r\n            (let [head (drop-last current) tail (last current)]\r\n                (if (false? (coll? tail))\r\n                    (vector (list next))\r\n                    (if (not= (first tail) next)\r\n                        (conj current (list next))\r\n                        (conj (apply vector head) (conj tail next))))\r\n                ))\r\n        []\r\n        input))","problem":31,"user":"4dddf817535d08e6dec9fdd3"},{"problem":31,"code":"(fn [s]\n   (loop [acc []\n          work '()\n          s s]\n     (if-let [e (first s)]\n       (if (not= e (last work))\n         (recur (if-not (empty? work) (conj acc work) acc) `(~e) (rest s))\n         (recur acc (conj work e) (rest s)))\n       (if-not (empty? work)\n         (conj acc work)\n         acc))))","user":"5d236215e4b02ea6f0fb6a09"},{"problem":31,"code":"#(loop [xs %  res ()]\n\t(if (empty? xs) (reverse res)\n\t(let [x (first xs) coll (rest xs) resf (first res)]\n\t\t(if (= x (first resf))\n\t\t\t(recur coll (conj (rest res) (conj resf x)))\n\t\t\t(recur coll (conj res (list x)))\n\t\t\t)\n\t\t)\n\t)\n\t)","user":"57465429e4b009280f9f2b60"},{"code":"#(letfn [(pack [acc inner coll]\n               (if (empty? coll)\n                 (conj acc inner)\n                 (let [curr (first coll)]\n                   (if (= (first inner) curr)\n                     (recur acc (conj inner curr) (rest coll))\n                     (recur (conj acc inner) (vector curr) (rest coll))))))]\n   (pack [] (vector (first %)) (rest %)))","problem":31,"user":"52dd4fb4e4b09f7907dd13df"},{"problem":31,"code":"(partial\n  reduce\n  (fn [xss x]\n    (if (= (last (last xss))\n           x)\n      (concat (butlast xss)\n              [(conj (last xss)\n                     x)])\n      (concat xss [[x]])))\n  [])","user":"521d064fe4b0c4ef0be830a8"},{"problem":31,"code":"#(reduce (fn [s e] (if (= e (first (last s))) \n                     (conj (vec (reverse (rest (reverse s)))) \n                           (conj (last s) e)) \n                     (conj s [e]))) \n         []\n         %)","user":"53acaf1fe4b047364c04445f"},{"code":"(fn[x](reduce\r\n  #(if\r\n    (=(last(last%))%2)\r\n    (conj(vec(butlast%))(conj(last%)%2))\r\n    (conj%[%2]))[]x))","problem":31,"user":"4dd66da7535d2dad7130b5c8"},{"problem":31,"code":"; partition-by identity\n#(loop [s (reverse  %) r nil t nil]\n    (if (empty? s)\n      (cons t r)\n      (let [head (first s) tail (last t)]\n        (if (empty? t)\n          (recur (rest s) r (cons head t))\n          (if (= head tail)\n            (recur (rest s) r (cons head t))\n            (recur (rest s) (cons t r) (list head)))))))","user":"568227fee4b0945ebc182a8a"},{"problem":31,"code":"(fn [s]\n  (loop [result []\n         [current & remain] s\n         pack '()]\n    (cond\n      (empty? remain)\n      (if (= current (first pack))\n        (concat result [(conj pack current)])\n        (concat result (and (seq pack) [pack]) [[current]]))\n\n      (= current (first pack))\n      (recur result remain (conj pack current))\n\n      (and (not= current (first pack))\n           (= current (first remain)))\n      (recur (concat result (and (seq pack) [pack])) remain (list current))\n\n      :else\n      (recur (concat result (and (seq pack) [pack]) [[current]]) remain '()))))","user":"59699da7e4b069c0a1a197eb"},{"code":"(fn [items]  \n  (reverse\n    (loop [coll () i items]\n      (if (empty? i)\n        coll\n        (if (= (first (first coll)) (first i))\n          (recur (cons (cons (first i) (first coll)) (rest coll)) (rest i))\n          (recur (cons (list (first i)) coll) (rest i)))))))","problem":31,"user":"53806e5be4b06839e8705ec1"},{"problem":31,"code":"(fn pack [[x & xs]]\n (let [packhelp\n  (fn packhelp [[x & xs] ys lst]\n  (cond \n   (nil? x) (concat lst [ys])\n   (= x (first ys)) (packhelp xs (conj ys x) lst)\n   :else (packhelp xs [x] (concat lst [ys]))\n  )\n )]\n (vec (packhelp xs [x] nil))\n )\n)","user":"56433d34e4b08d4f616f5f23"},{"problem":31,"code":"(comp reverse\n        (partial apply conj)\n        (juxt :res :dup)\n        (fn [[x & xs]]\n          (reduce #(if (= %2 (-> %1 :dup first))\n                     (assoc %1 :dup (cons %2 (:dup %1)))\n                     (-> (assoc %1 :res (cons (:dup %1) (:res %1)))\n                         (assoc :dup (list %2))))\n                  {:dup (list x)\n                   :res '()}\n                  xs)))","user":"5f2d6bc4e4b033932238a66e"},{"problem":31,"code":"(fn [s] \n\t(loop [f (first s), v s, result [], sub-list []]\n\t\t(if (empty? v)\n\t\t\t(if (empty? sub-list)\n\t\t\t\tresult\n\t\t\t\t(conj result sub-list))\n\t\t\t(if (empty? sub-list)\n\t\t\t\t(recur (second v) (rest v) result (conj sub-list f))\n\t\t\t\t(if (= (last sub-list) f)\n\t\t\t\t\t(recur (second v) (rest v) result (conj sub-list f))\n\t\t\t\t\t(recur (second v) (rest v) (conj result sub-list) [f]))\n\t\t\t\t)\n\t\t\t)))","user":"572ec4dde4b0cd1946bd0f8d"},{"problem":31,"code":"(fn [items]\n   (reverse (loop [xs items\n                   output nil\n                   stack nil]\n              (if (empty? xs)\n                (conj output stack)\n                (let [item (first xs)]\n                  (if (not= item (peek stack))\n                    (recur (rest xs)\n                           (if (nil? stack) output (conj output stack))\n                           [item])\n                    (recur (rest xs)\n                           output\n                           (conj stack item))))))))","user":"532ae82be4b09d4e7a9b552b"},{"problem":31,"code":"(fn [input] \n  (loop [characters (seq input)\n         intermediates '()\n         result []]\n\t(if (empty? characters) \n      (conj result intermediates)\n      (let [candidate (first characters)]\n        (if (empty? intermediates)\n          (recur (rest characters) (list candidate) result)\n          (if (= candidate (first intermediates))\n            (recur (rest characters) (cons candidate intermediates) result)\n            (recur (rest characters) (list candidate) (conj result intermediates))))))))","user":"5d3ae729e4b01671435dbd5d"},{"code":"(fn pack [x]\n  (let [pack* (fn [[h & t :as x] c]\n                (when (seq x)\n                  (let [[packed t] (split-with {h true} x)]\n                    (if (seq t)\n                      (recur t (conj c packed))\n                      (conj c packed)))))]\n    (pack* x [])))","problem":31,"user":"50ef56dfe4b0bdaecbb47d94"},{"code":"(fn f [x]\n  (letfn [(f1 [x & y]\n             (let [head (first y)\n                   g (fn g [v l]\n                       (if (= (first v) (first l))\n                         (g (cons (first l) v) (rest l))\n                         (list v l)))\n                   [group tail] (g (list (first x)) (rest x))]\n               (if (empty? tail)\n                 (cons group head)\n                 (f1 tail (cons group head)))))]\n    (reverse (f1 x))))","problem":31,"user":"52b0323ee4b0c58976d9acc6"},{"problem":31,"code":"(fn [initial-x] (loop [x initial-x, result [], current [], currentC (first initial-x)]\n                 (if (empty? x)\n                   (conj result current)\n                   (if-not (= currentC (first x))\n                     (recur (rest x) (conj result current) (vector (first x)) (first x))\n                     (recur (rest x) result (conj current currentC) currentC)\n                     )\n                 )))","user":"57d60d83e4b0bd073c2023c2"},{"problem":31,"code":";(fn packdup\n;  ([l] (packdup (rest l) [(first l)]))\n;  ([l prevseq] (if (empty? l)\n;              [prevseq]\n;              (let [x (first l)]\n;                (if (= (first prevseq) x)\n;                  (packdup (rest l) (conj prevseq x))\n;                  (concat [prevseq] (packdup (rest l) [x]))\n;                )\n;              )\n;            )\n;  )\n;)\n#(partition-by identity %)","user":"54c82b27e4b045293a27f645"},{"problem":31,"code":"(fn [coll]\n    (partition-by identity coll))","user":"4fb41dace4b081705acca2aa"},{"problem":31,"code":"(fn xx [l]\n  (map \n  \t(fn [m]\n    \t(let [s (seq m), ss (first s)]\n        \n        (repeat (second ss) (first ss)) \n          \n        )\n    )\n   \t, \n  \t(reduce \n    \t(fn [c n]\n       (if (and (not (empty? c)) (= (first (keys (last c))) n)) (assoc-in c [(dec (count c)) n] (inc (first (vals (last c))))) (conj c {n 1}))\n    \t)\n    \t[] l) \n  )\n)","user":"5b8ec146e4b0c0b3ffbd49f0"},{"problem":31,"code":"(fn [x] (partition-by identity x))   ;;; Lo que hace partition es dividir una lista en elementos repetidos consecutivos","user":"6075c214e4b069485764de5b"},{"problem":31,"code":"(fn pack\n  ([x] (if (empty? x)\n         '(())\n         (reverse (pack (list (first x)) (rest x) nil))))\n  ([x xs acc]\n   (if (empty? xs)\n     (conj acc x)\n     (if (= (first x) (first xs))\n       (pack (conj x (first xs)) (rest xs) acc)\n       (pack (list (first xs)) (rest xs) (conj acc x)))\n     )))","user":"56897739e4b0dcc4269f407d"},{"problem":31,"code":"(fn part-dupl-e2\n  ([coll]\n   (part-dupl-e2 coll []))\n  ([coll build]\n   (if (seq coll)\n     (let [part (vec (take-while #(= % (first coll)) coll))]\n       (part-dupl-e2 (subvec coll (count part))\n                     (conj build part)))\n     build)))","user":"56481722e4b0284900eef628"},{"problem":31,"code":"(fn [coll] (seq (reduce (fn [col itm] (let [this (peek col)]\n                                              (if (= (first this) itm)\n                                                (conj (pop col) (conj this itm))\n                                                (conj col (list itm))))) [] coll)))","user":"57b7de74e4b0fbc9809a27d4"},{"problem":31,"code":"(fn pack-a-seq [s]\n  (partition-by identity s))","user":"58e965b3e4b056aecfd47d08"},{"code":"#(rest (reverse (reduce (fn[x,y](if (= (last (first x)) y) (cons (cons y (first x)) (rest x)) (cons (list y) x))) [[]] %)))","problem":31,"user":"4fb3dd1ee4b081705acca2a5"},{"code":"(fn [c & r]\n  (if (seq c)\n    (let [f (partial = (first c))]\n      (recur\n       (drop-while f c)\n       (conj r (take-while f c))))\n    (reverse r)))","problem":31,"user":"539c64cde4b0b51d73faaf2a"},{"code":"(fn packout [x] \n  ((fn pack [mainSeq subSeq lastElement]\n  (if (nil? mainSeq)\n    (cons subSeq '())\n    (if (== (compare (first mainSeq) lastElement) 0)\n      (pack (next mainSeq) (cons (first mainSeq) subSeq) (first mainSeq))\n      (cons subSeq (pack (next mainSeq) (cons (first mainSeq) '()) (first mainSeq)))))) (next x) [(first x)] (first x)))","problem":31,"user":"522ff396e4b032bbe3424172"},{"code":"(fn [col]\n  (apply conj\n    (vals\n      (reduce\n        #(let [result (:result %1) pkg (:pkg %1)]\n          (cond\n            (empty? pkg) {:result [] :pkg [%2]}\n            (= %2 (last pkg)) {:result result :pkg (conj pkg %2)}\n            true {:result (conj result pkg) :pkg [%2]}))\n        {:result [] :pkg []}\n        col))))","problem":31,"user":"5033ed65e4b062bc5d7ae15a"},{"problem":31,"code":"(fn pk [coll]\n  (loop [mycol coll\n         acc []]\n    (if-let [f (first mycol)]\n      (do\n        (println \"dd\" (first (last acc)))\n        (if (= f (first (last acc)))\n          (do\n            (println \"*\" f \"*\" acc)\n            (recur (rest mycol) (conj (into [] (butlast acc)) (conj (last acc) f))))\n          (do\n            (println f acc)\n            (recur (rest mycol) (conj acc [f])))))\n      acc)))","user":"5ff8ead1e4b06df49cee14ab"},{"code":"(fn rd [coll]\n        (reduce (fn [a b]\n                  (let [a (vec a)\n                        b (if (list? b)\n                            (vec b)\n                            b)]\n                    (if (= (last (last a)) b)\n                      (conj (vec (butlast a)) \n                            (conj (last a) b))\n                     \n                      (conj a [b])\n                      ))) []  coll ))","problem":31,"user":"536581e4e4b0243289761e6d"},{"code":"(fn [x] (reduce #(concat (butlast %1) (if (= (first (last %1)) %2) (list (concat (last %1) [%2])) (list (last %1) [%2]))) [(list (first x))] (rest x)))","problem":31,"user":"5017f840e4b02f523d7cc5e8"},{"problem":31,"code":"(fn foo [l]\n  (if (seq l)\n    (cons (take-while #(= % (first l)) l)\n          (foo (drop-while #(= % (first l)) l)))))","user":"513e8141e4b02b2a3d8235c1"},{"problem":31,"code":"(fn sub [lis]\n  (partition-by identity lis))","user":"607dd962e4b03d835a6eaed2"},{"problem":31,"code":"(fn foo [x] (if (empty? x) [] (cons (take-while #(= (first x) %) x) (foo (drop-while #(= (first x) %) x)))))","user":"5520974be4b08d5046aa8a63"},{"problem":31,"code":"(fn pack [s] \n  (if (= (count s) 1)\n    (list s)\n    (let [f (first s) p (pack (rest s))]\n      (let [fp (first p) rp (rest p) ffp (first fp)]\n        (if (= f ffp)\n          (conj rp (conj fp f))\n          (conj p (list f))) ))))","user":"5d81c244e4b0915913b1d37a"},{"code":"(fn [x]\n  (loop [i x, o []]\n    (if (seq i)\n        (let [e (first i)]\n          (recur\n            (drop-while #(= e %) i)\n            (conj o (take-while #(= e %) i))))\n        (seq o))))","problem":31,"user":"4de760a3535d08e6dec9fdf9"},{"problem":31,"code":"#(reduce (fn [res item]\n          (if (not= (last (last res)) item)\n            (conj res (cons item '()))\n            (\n              do\n              (let [\n                    last_coll (last res)\n                    d_coll (into [] (butlast res))\n                    last_coll_new (conj last_coll item)]\n                (conj d_coll last_coll_new)\n                )\n              )\n            )\n          ) [] %)","user":"5c1229d5e4b01240ff567188"},{"code":"(fn [s] \n  ((fn [s r]\n    (cond\n      (first s)\n        (let [[x y] (split-with (partial = (first s)) s)]\n          (recur y (conj r x)))\n      :e r))\n    s []))","problem":31,"user":"5256627ce4b0541d1855ba1a"},{"problem":31,"code":"reduce (fn [coll e]\n          (if (= (last (last coll)) e)\n            (conj (pop coll) (conj (last coll) e))\n            (conj coll (list e)))) []","user":"5971a017e4b01722bebd4c75"},{"problem":31,"code":"(fn [x]\n    (partition-by identity x)\n\n    )","user":"5d301c95e4b01671435dbcca"},{"problem":31,"code":"(fn [s]\n  (letfn [(pack-help\n    [[result buffer] x]\n    (if (empty? buffer) \n      [result [x]]\n      (let [last-elem (first buffer)]\n        (if (= x last-elem)\n          [result (conj buffer x)]\n          [(conj result buffer) [x]]))))]\n    (apply conj (reduce pack-help [[] []] s))))","user":"5813e208e4b0f478707a061b"},{"problem":31,"code":"(fn [seq]\n  (loop [s '() i (- (count seq) 1)]\n    (if (>= i 0)\n      (recur\n        (if \n          (and \n            (< i (- (count seq) 1)) \n            (= (nth seq (+ i 1)) (nth seq i))\n          )\n          (conj (drop 1 s) (conj (first s) (nth seq i)))\n          (conj s [(nth seq i)])\n        )\n        (- i 1)\n      )\n      s\n    )\n  )\n)","user":"5cbdc591e4b026601754ba00"},{"problem":31,"code":"(fn\n  [coll]\n  (partition-by identity coll))","user":"56df6417e4b0ca2494a095f7"},{"problem":31,"code":"reduce (\n    fn [acc x]\n      (cond \n        (empty? acc) (conj acc [x])\n        (= (last (last acc)) x) (conj (pop acc) (merge (last acc) x))\n        :else (conj acc [x])))\n    []","user":"5a19d181e4b0ff51aa4b3207"},{"code":"reduce (fn [xs x]\n     (if (= (last (last xs)) x)\n          (update-in xs [(dec (count xs))] #(conj % x))\n          (conj xs (list x)))) []","problem":31,"user":"51ca7906e4b08b1cbd0d9487"},{"code":"#(reverse \n  (reduce \n    (fn [a b] \n      (if (= (first (first a)) b) \n        (cons (cons b (first a)) (rest a)) \n        (cons (list b) a)))\n  () %))","problem":31,"user":"4ef2da4f535dced4c769f224"},{"problem":31,"code":"(fn my-pack\n  [s]\n  (cond\n    (empty? s) (empty s)\n    (seq? (first s)) (if (= (second s) (first (first s)))\n                       (my-pack (conj (rest (rest s)) (conj (first s) (second s))))\n                       (conj (my-pack (rest s)) (first s)))\n    (= (first s) (second s)) (my-pack (conj (rest (rest s)) (conj '() (first s) (second s))))\n    :else (conj (my-pack (rest s)) (list (first s)))))","user":"5599abc9e4b031d6649c9bb0"},{"code":"#(loop [s %\n         n []\n         c []]\n    (if (empty? s)\n      (if (empty? c)\n        n\n        (conj n c))\n      (if (empty? c)\n        (recur (rest s) n (conj c (first s)))\n        (if (= (first c) (first s))\n          (recur (rest s) n (conj c (first s)))\n          (recur s (conj n c) [])))))","problem":31,"user":"52d6120ee4b09f7907dd134c"},{"code":"(fn [arg]\n  (loop [src arg result [] cur []]\n    (println result)\n    (if (empty? src)\n      (if (empty? cur)\n        result\n        (conj result cur))\n      (let [h (first src)]\n        (if (empty? cur)\n          (recur (rest src) result [h])\n          (if (= h (first cur))\n            (recur (rest src) result (conj cur h))\n            (recur (rest src) (conj result cur) [h])))))))","problem":31,"user":"504db141e4b021508a333965"},{"problem":31,"code":"(fn pack\n  [xs]\n  (reduce (fn [packed x]\n            (let [last-packed (peek packed)]\n              (if (and last-packed\n                       (= x (peek last-packed)))\n                (conj (pop packed) (conj last-packed x))\n                (conj packed [x]))))\n          []\n          xs))","user":"5c73bcf9e4b0fca0c16227bb"},{"problem":31,"code":"(fn [coll]\n  (loop [c coll r []]\n    (if (empty? c)\n      r\n      (recur (drop-while #(= % (first c)) c) (conj r (take-while #(= % (first c)) c))))))","user":"51f40975e4b0fca5e8b4822e"},{"problem":31,"code":"(fn [coll]\n  (loop [res []\n         cur-lst []\n         src-col coll]\n    (if (and (empty? cur-lst) (empty? src-col))\n      res\n      (do\n        (if (or (empty? cur-lst) (= (first src-col) (first cur-lst)))\n          (recur res (conj cur-lst (first src-col)) (rest src-col))\n          (recur (conj res cur-lst) [] src-col))))))","user":"5294a49be4b02ebb4ef7500f"},{"problem":31,"code":"#(loop [v % r [] ct 0 mark -1]                                                                                                                                           \n    (if (= (first v) mark)                                                                                                                                                           \n      (recur (drop 1 v) r (inc ct) mark)                                                                                                                                             \n      (if (nil? (first v) )                                                                                                                                                          \n        (conj r  (repeat ct mark) )                                                                                                                                                  \n        (recur (drop 1 v)                                                                                                                                                            \n               (if (not= 0  ct)                                                                                                                                                      \n                 (conj r (repeat ct mark  ) )                                                                                                                                         \n                 r)                                                                                                                                                                  \n               1 (first v)                                                                                                                                                           \n               )                                                                                                                                                                     \n                                                                                                                                                                                     \n        )                                                                                                                                                                            \n      )                                                                                                                                                                              \n    )","user":"57bffed6e4b05aa3c4741c89"},{"code":"(fn f31 [x]\n  (partition-by identity x))","problem":31,"user":"535aee3be4b04ce2eb3ed2aa"},{"problem":31,"code":"#(loop [s % res []]\n   (if (empty? s)\n       res\n       (if (empty? res)\n         \n           (recur (rest s) \n                  (cons (list (first s)) '())\n           )\n         \n           (if (= (first s) (first (last res)))\n               (recur (rest s) \n                      (concat (drop-last res)\n                              (cons (concat (last res)\n                                      (list (first s))\n                                    ) '())\n                            ) \n               )\n             \n               (recur (rest s) \n                      (concat res (cons (list (first s)) '()))\n               )\n           )\n       )\n   )\n )","user":"594a7ed1e4b07ddc2dafae02"},{"problem":31,"code":"(fn [coll]\n  (loop [current coll result []]\n    (if (empty? current)\n      result\n      (recur\n        (rest current)\n        (if (= (last (last result)) (first current)) \n          (conj (apply vector (take (dec (count result)) result)) (cons (first current) (last result)))\n          (conj result (list (first current))))))))","user":"5ee81beae4b029a2061bbeac"},{"problem":31,"code":"(fn [ myseq ]\n  (reduce\n   (fn [ a b ]\n     (println (str \"a: \" a))\n     (println (str \"b: \" b))\n     (if (= (last (last a)) b)\n       (reverse (cons (cons b (last a)) (rest (reverse a))))\n       (reverse (cons (cons b '()) (reverse a)))))\n   (list)\n   (seq myseq)))","user":"5ff82adae4b06df49cee14a4"},{"problem":31,"code":"(fn pack\n  [lst]\n  (loop\n    [lsta lst\n     temp ()\n     lstb ()\n     ]\n    (cond\n      (empty? lsta) (reverse lstb)\n      (= (first lsta) (second lsta)) (recur (rest lsta) (cons (first lsta) temp)\n                                            lstb)\n      :else (recur (rest lsta) (empty temp) (cons (cons (first lsta) temp) lstb )))))","user":"57f81544e4b0d3187e900917"},{"problem":31,"code":"(fn [items]\n  (let [{product :product recent :recent}\n    (reduce\n      (fn [{product :product recent :recent} entry]\n        (cond\n         (empty? recent) {:product product :recent (list entry)}\n         (= (first recent) entry) {:product product :recent (conj recent entry)}\n         :else {:product (concat product [recent]) :recent (list entry)}\n        ))\n     {:product '() :recent '()}\n     items)]\n    (concat product (list recent))))","user":"59075e3be4b047aa04b19955"},{"problem":31,"code":"(fn split-same [a]\n  (let [[x s] (map #(map first %)\n    (split-with (partial apply =) (partition 2 (interleave a (cons (first a) a)))))]\n    (if (not-empty s) (cons x (split-same s)) [x])))","user":"5a8aa992e4b05369db4d24d8"},{"code":"(fn dup-divide [m]  \n  ((fn dup-divide-iter [l m]\n     (let [dup-count-iter (fn dup-count-iter [m n c]\n                            (if (or (= 0 (count m)) (not= c (first m)))\n                              n\n                              (dup-count-iter (rest m) (+ n 1) c))),\n           dup-count (fn [m] (dup-count-iter m 0 (first m)))\n           m-dup-count (dup-count m)]\n       (println m-dup-count)\n       (if (= 0 (count m))\n         l\n         (dup-divide-iter (conj l (take m-dup-count m)) (drop m-dup-count m))))) [] m))","problem":31,"user":"517531c6e4b07031762f2eea"},{"code":"(fn [data]\n  (partition-by identity (seq data)))","problem":31,"user":"4eb1dd39535d7eef30807345"},{"code":"(fn pack [v]\n  (reverse (reduce #(if (= (first (first %1)) %2) \n              (conj (rest %1) (cons %2 (first %1))) \n              (conj %1 (list %2))\n           ) \n          '() v))\n  )","problem":31,"user":"529a73bde4b02ebb4ef75096"},{"code":"(fn [s] (reverse (reduce #(if (= (ffirst %1) %2)\n (cons (cons %2 (first %1)) (rest %1))\n (cons (list %2) %1)) '() s)))","problem":31,"user":"509251f3e4b09a7d0b586de5"},{"problem":31,"code":"(fn pack-array\n  ([arg] (reduce #(if (= (first (if (empty? %1) [] (last %1))) %2)\n                         (concat (drop-last %1) [(concat (last %1) [%2])])\n                         (if (empty? %1) (seq [[%2]]) (concat %1 (seq [[%2]]))))\n                 [] arg)))","user":"5e88a676e4b0cb016954630a"},{"problem":31,"code":"(fn [seq]\r\n  (loop [seq seq\r\n         last nil\r\n         result '()]\r\n    (if (empty? seq)\r\n      (reverse result)\r\n      (let [[head & tail] seq]\r\n        (recur tail head\r\n          (if (= head last)\r\n            (conj (rest result) (conj (first result) head))\r\n            (conj result (list head))))))))","user":"555bd27ae4b0b056612e2244"},{"code":"(fn pack-sequence [[head & tail :as xs]]\n  (letfn [(pack-value-at-front [x [head & tail :as xs]]\n                               (cond (nil? head) (list (list x))\n                                     (= x (first head)) (cons (cons x head) tail)\n                                     :else (cons (list x) xs)\n                                     ))]\n    \n    \n      (if (nil? head)\n        '()\n        (pack-value-at-front head (pack-sequence tail)))))","problem":31,"user":"536ca4bde4b0fc7073fd6e49"},{"problem":31,"code":"(fn [xs]\n  (loop [cur [(first xs)] res [] items (rest xs)]\n    (if (empty? items)\n      (conj res cur)\n      (if (= (first cur) (first items))\n        (recur (conj cur (first items)) res (rest items))\n        (recur [(first items)] (conj res cur) (rest items))))))","user":"5188c249e4b0bdff0e072d54"},{"problem":31,"code":"(fn [s] (loop [l   (seq s)\n               el  nil\n               ss  ()\n               col []]\n          (cond\n            (empty? l)\n              (seq (conj col ss))\n            (empty? ss)\n              (recur\n                (rest l)\n                (first l)\n                (conj ss (first l))\n                col)\n            :else\n              (recur\n                (rest l)\n                (first l)\n                (if (= el (first l)) (conj ss (first l)) [(first l)])\n                (if (= el (first l)) col (conj col ss))))))","user":"595c02a9e4b066ee0a44afeb"},{"code":"(fn this [coll]\n  (when-first [x coll]\n    (let [[sub-list coll]\n          (split-with #(= x %) coll)]\n      (cons sub-list (this coll)))))","problem":31,"user":"4e68c434535d8ccf87e9fe89"},{"problem":31,"code":"#(loop [xs %\n         cur []\n         res []]\n    (cond\n     \t(empty? xs) res\n     \t(= (first (rest xs)) (first xs)) (recur (rest xs) (conj cur (first xs)) res)\n     \t:else (recur (rest xs) [] (conj res (conj cur (first xs))))))","user":"4eb47bb1535d7eef30807362"},{"problem":31,"code":"#(let [[a c] (reduce \n\t(fn [[acc cur] el] \n  \t(if (or (empty? cur) (= el (first cur)))\n    \t[acc (conj cur el)]\n    \t[(conj acc cur) [el]]))\n\t[[] []]\n  \t%)]\n   (conj a c))","user":"59497f51e4b07ddc2dafaddd"},{"code":"(fn [x]\n         (loop [s x nbs [] tbs [] ]\n           (if-let [ n (first s)]\n             (if (= n (last tbs))\n               (recur (rest s) nbs  (conj tbs n))\n               (recur (rest s)\n                      (if (last tbs)  (conj nbs tbs) nbs)\n                      (conj [] n)))\n             (conj nbs tbs))))","problem":31,"user":"5007cdb9e4b0b17c647f5227"},{"code":"(fn [xs] (let [[[h & r] n] (reduce (fn [[vals cur] x]\n                              (if (= (first cur) x)\n                                [vals (conj cur x)]\n                                [(conj vals cur) [x]])) [[] []] xs)]\n    (if (> (count n) 0)\n      (conj (vec r) n)\n      r)))","problem":31,"user":"532b43c3e4b09d4e7a9b5531"},{"problem":31,"code":"(fn [x]\n  (loop [r [] v (drop 1 x) cv (vector (first x))]\n    (cond\n      (empty? v) (seq (conj r (seq cv)))\n      (= (first v) (last cv)) (recur r (drop 1 v) (conj cv (first v)))\n      :else (recur (conj r (seq cv)) (drop 1 v) (vector (first v)))\n      )\n    )\n)","user":"5d6fae1ee4b04d129b00f2d4"},{"code":"(fn pack-consec-dup [xs]\n  ((fn pack-consec-dup-prev [[x & xs] c acc]\n    (if-not (nil? x)\n    \t(if (= c x)\n        (pack-consec-dup-prev xs c (cons x acc))        \n        (cons acc (pack-consec-dup-prev xs x (list x)))\n      )\n      (list acc)\n    )\n  ) xs (first xs) ()) \n)","problem":31,"user":"4fb710f4e4b081705acca2cd"},{"code":"(fn [x] (partition-by #(or(= % 1)(= % :a)(= % :c)(= % [1 2])) x))","problem":31,"user":"5125029de4b0ce9225d2ed3e"},{"problem":31,"code":"(fn pack-seq [sq]\n  (if (empty? sq)\n    '()\n    (loop [packs [] pack-now (list (first sq)) sq (rest sq)]\n      (if (empty? sq)\n        (conj packs pack-now)\n        (if (= (first sq) (first pack-now))\n          (recur packs (conj pack-now (first sq)) (rest sq))\n          (recur (conj packs pack-now) (list (first sq)) (rest sq)))))))","user":"5c6314c5e4b0fca0c1622658"},{"problem":31,"code":"(fn [elements]\n  (reduce #(if (= (last (last %1)) %2)\n             (concat (butlast %1) [(conj (last %1) %2)])\n             (concat %1 [[%2]]))\n    []\n    elements))","user":"576d398be4b0979f8965155d"},{"problem":31,"code":"(fn [coll]\n  (reverse (into '() (reduce (fn[acc x]            \n            (if (= (last (last acc)) x)\n              (let [aux-acc (into [] (pop (into [] acc)))                                  \n                    aux-last (last acc)]                \n                (into [] (conj aux-acc (conj aux-last x))))\n              (conj (into [] acc) (list x))))\n          '()\n          coll))))","user":"60cebbd3e4b0e0fa5f1b4334"},{"code":"(fn group1 [xs]\n  (lazy-seq\n    (when (not (empty? xs))\n    (cons\n      (take-while #(= (first xs) %) xs)\n      (group1 (drop-while #(= (first xs) %) xs))))))","problem":31,"user":"4e96557d535dbda64a6f6b43"},{"problem":31,"code":"(fn f [seq]\n  (loop [s seq i [] r []]\n    (cond \n     (empty? s) (conj r i)\n     (and (not (empty? i)) (not= (first i) (first s))) (recur (rest s) (conj [] (first s)) (conj r i))\n     :else (recur (rest s) (conj i (first s)) r))))","user":"57462a4de4b009280f9f2b5d"},{"problem":31,"code":"(fn packSequence\n  [lst]\n  (partition-by identity lst))","user":"5ea3711ae4b00a66d4a9519d"},{"code":"(fn mypack \n  [ coll ]\n  (lazy-seq \n    (when (seq coll)\n      (loop [ tc (list (first coll))\n              c (rest  coll)]\n        (if-not (= (first tc) (first c))\n          (cons tc (mypack c))\n          (recur (cons (first c) tc) (rest c)))))))","problem":31,"user":"5018ed15e4b011a2e0bf6412"},{"code":"(fn pack [s]\n  (if (empty? s)\n    s\n    (loop [x (list (first s))\n           r (rest s)]\n      (if (and (not (empty? r))\n               (= (first x) (first r)))\n        (recur (cons (first r) x)\n                 (rest r))\n        (cons x (pack r))))))","problem":31,"user":"4f2b0951e4b0d6649770a045"},{"problem":31,"code":"(fn pack\n  [s]\n  (if (empty? s)\n    '()\n    (let [head (first s)\n          [t-part d-part] (split-with #(= head %) s)]\n      (cons t-part (pack d-part)))))","user":"5796d3ebe4b039eba2ecb0ee"},{"code":"(fn [coll]\n  ((fn pack [res sub s]\n     (if-let [[f & r] (seq s)]\n       (if (= f (first sub))\n         (pack res (conj sub f) r)\n         (pack (conj res sub) (list f) r))\n       (conj res sub)))\n   [] (list (first coll)) (rest coll)))","problem":31,"user":"50d18d00e4b05a71a896ef57"},{"code":"(fn [xs]\r\n  (loop [xxs xs starter nil run-length 1 acc nil]\r\n        (prn)\r\n        (prn 'xxs xxs)\r\n        (prn 'run-length run-length)\r\n        (prn 'acc acc)\r\n        (if (empty? xxs)\r\n          (reverse (cons (repeat run-length starter) acc))\r\n          (let [current-item (first xxs) remaining (rest xxs)]\r\n            (prn 'current-item current-item)\r\n            (prn 'starter starter)\r\n            (cond\r\n              ;; If the current item and the starting item match\r\n              ;; then increment the run length\r\n              (= current-item starter)\r\n                (recur remaining starter (inc run-length) acc)\r\n              ;; If there is no starting item, then recurse and set the\r\n              ;; starting item to the current item\r\n              (nil? starter)\r\n                (recur remaining current-item 1 acc)\r\n              :else\r\n                (recur remaining current-item 1 (cons (repeat run-length starter) acc)))))))","problem":31,"user":"4f5155a3e4b03ad3f0c10d1b"},{"problem":31,"code":"(fn [coll]\n  (partition-by (set coll) coll))","user":"5c06f6e3e4b0bdcf453d16bb"},{"problem":31,"code":"#((fn my-partition\n  ([test? [x & xs]] (my-partition test? xs (list x) []))\n  ([test? [x & xs] small ret]\n   (if (nil? x)\n     (conj ret small)\n     (if (= (test? x) (test? (first small)))\n       (recur test? xs (conj small x) ret)\n       (recur test? xs (list x) (conj ret small)))))) identity %)","user":"554b7056e4b0a04f79299583"},{"problem":31,"code":"reduce (fn [x y] (if (= (first (last x)) y)\n                        (concat (butlast x) [(conj (last x) y)])\n                        (concat x [[y]]))) '()","user":"59a0262ee4b0871e7608b82d"},{"problem":31,"code":"(fn pack-a-sequence [xs] \n  (reduce (fn [r x]\n            (let [l (last r)\n                  bl (butlast r)]\n              (if (= x (first l))\n                (into (vec bl) [(conj l x)])\n                (into r [(list x)]))))\n          []\n          xs))","user":"54008b88e4b0de5c4184860d"},{"code":"(fn [x] (reverse \n                (reduce #(if (= (first (first %1)) %2)\n                            (conj  (rest %) (cons %2 (first %)))\n                            (conj % (list %2))) () x)))","problem":31,"user":"52fa4f48e4b047fd55836ff7"},{"problem":31,"code":"(fn [collection] \n  (reverse\n   (loop [in collection out '()]\n     (if (empty? in)\n       out\n       (recur (drop-while #(= % (first in)) in)\n              (conj out (take-while #(= % (first in)) in))\n                    )))))","user":"5df79c31e4b0a607a9a45c9b"},{"code":"(fn [z] (next ((partial \n (fn [acc prev coll]\n   (if (nil? coll)\n     (reverse (conj acc prev))\n     (if (= (first coll) (first prev))\n       (recur acc (conj prev (first coll)) (next coll))\n       (recur (conj acc prev) (list (first coll)) (next coll))\n     )\n   )\n ) '() '()\n) z)))","problem":31,"user":"526dd90de4b03e8d9a4a72fe"},{"problem":31,"code":"(fn pack\n  ([s cur-s] (cond\n                    (empty? s) (list cur-s)\n                    (= (first s) (first cur-s)) (pack (rest s) (cons (first s) cur-s))\n                    :else (cons cur-s (pack (rest s) (list (first s))))))\n  ([s] (pack (rest s) (list (first s)))))","user":"5ee93720e4b029a2061bbeb7"},{"code":"(fn pack [col]\r\n  (reverse\r\n    (reduce\r\n      (fn [t i]\r\n        (if (= (first (first t)) i)\r\n          (conj (rest t) (conj (first t) i))\r\n          (conj t (list i))))\r\n      '() col)))","problem":31,"user":"4e83b1af535db62dc21a62dc"},{"code":"(fn [x]\n  (reduce #(if (some #{%2} (first %1)) \n             (conj (rest %1) (conj (first %1) %2)) \n             (conj %1 (list %2))) \n          '() (reverse x))\n  )","problem":31,"user":"50d4593ee4b09cc622d65a68"},{"code":"(fn [lst]\n   (loop [l lst result '()]\n     (if (empty? l)\n       (reverse result)\n       (if (= (first l) (first (first result)))\n         (recur (next l) (conj (rest result) (conj (first result) (first l))))\n         (recur (next l) (conj result (list (first l))))))))","problem":31,"user":"4fd7f892e4b0dab7d829f38d"},{"code":"(fn packsdup\n        ([vs] (packsdup vs []))\n        ([vs vacc] \n           (if (empty? vs)\n             (apply list vacc)\n             (loop [fst (first vs)\n                    rst (rest vs)\n                    sub (list fst)]\n               (if (= fst (first rst))\n                 (recur fst (rest rst) (conj sub (first rst)))\n                 (packsdup rst (conj vacc sub)))))))","problem":31,"user":"52c58561e4b0c2d177d620f8"},{"problem":31,"code":"(fn [xs] \n  (if (empty? xs) \n    [] \n    (reduce (fn [acc x] \n              (let [l (last acc)] \n                (if (= (last l) x) \n                  (conj (pop acc) (conj l x)) \n                  (conj acc [x])))) \n            [[(first xs)]] \n            (rest xs))))","user":"57e20474e4b0bfb2137f5a82"},{"code":"(fn [c] (reverse (reduce\n  (fn [a b] (if (= (first (first a)) b)\n    (cons (cons b (first a)) (rest a))\n    (cons (cons b '()) a)))\n  '()\n  c)))","problem":31,"user":"4fb1325de4b081705acca276"},{"problem":31,"code":"(fn fs [coll]\n  (reverse\n    (reduce\n      (fn [[f & r :as acc] itm]\n        (if\n          (not= (last f) itm)\n          (conj acc (list itm))\n          (conj r (conj f itm))))\n      ()\n      (seq coll))))","user":"593e4b1fe4b069cdc2982bbb"},{"problem":31,"code":"#(loop [acc '()\n        remainder %]\n   (cond (empty? remainder) (reverse acc)\n         (empty? acc) (recur (cons (list (first remainder)) acc) (rest remainder))\n         (= (first (first acc)) (first remainder)) (recur (cons (cons (first remainder) (first acc)) (rest acc)) (rest remainder))\n         :else (recur (cons (list (first remainder)) acc) (rest remainder))))","user":"5fb082cfe4b08cb800c85b14"},{"code":"(fn [xs]\n  ((fn [xs acc gacc]\n     (if (nil? xs)\n       (conj gacc acc)\n       (if (= (last acc) (first xs))\n         (recur (next xs) (conj acc (first xs)) gacc)\n         (recur (next xs) (list (first xs)) \n                (if (empty? acc) \n                  gacc\n                  (conj gacc acc))))))\n   xs () []))","problem":31,"user":"5203bc27e4b0fb7e47ea5204"},{"problem":31,"code":"(fn [coll]\n  (reverse\n    (loop [previous nil result '() xs coll]\n      (if (empty? xs)\n        result\n        (let [x (first xs)]\n          (recur x\n                 (if (= x previous)\n                   (cons (cons x (first result)) (rest result))\n                   (cons (list x) result))\n                 (rest xs)))))))","user":"571107b3e4b09c608db7043f"},{"code":"reduce #(if (= (first (last %1)) %2) (conj (pop %1) (conj (last %1) %2)) (conj %1 (list %2))) []","problem":31,"user":"4f2ef48be4b0d6649770a06c"},{"problem":31,"code":"(fn f [s]\n  (loop [res '() cur (first s) curlist '() base s]\n\n    (let [same? (= cur (first base))]\n    \n    (if (empty? base) (reverse (conj res curlist))\n     (recur (if same? res (conj res curlist))\n            (first base)\n            (if same? (conj curlist cur) (list(first base)))\n            (rest base))))))","user":"56483f45e4b0284900eef62b"},{"problem":31,"code":"reduce (fn [L x] (if (and (not (empty? L)) (= x (first (last L)))) \n                    (assoc L (dec (count L)) (conj (last L) x)) \n                    (conj L (vector x)))) []","user":"569c07b9e4b0542e1f8d145d"},{"problem":31,"code":"(fn [in]\n  (reduce #(if (= (ffirst %1) %2)\n             (conj (rest %1) (conj (first %1) %2))\n             (conj %1 (list %2)))\n          '()\n          (reverse in)))","user":"55f344afe4b06e875b46ce5a"},{"code":"(fn [coll]\n  (loop [result [], coll coll]\n    (if (empty? coll)\n      result\n      (let [f (first coll)]\n        (recur (conj result (take-while #(= f %) coll)) (drop-while #(= f %) coll))))))","problem":31,"user":"4edab806535d10e5ff6f5311"},{"code":"(fn [x]\n    (reverse\n      (drop 1\n        (loop [sq x ir '()]\n          (if (empty? sq)\n            ir\n            (recur\n              (drop (count (first ir)) sq)\n              (conj \n                ir\n                (first\n                  (partition-by \n                    #(= % (first (drop (count (first ir)) sq)))\n                    (drop (count (first ir)) sq)\n                  )\n                )\n              )\n            )\n          )\n        )\n      )\n    )\n  )","problem":31,"user":"4e8b73e4535d65386fec2120"},{"problem":31,"code":"(fn group-dup [x]\n  (if (empty? x)\n    '()\n    (if (= (count x) 1)\n      x\n      (loop [rem (rest x)\n             prev (first x)\n             res '()\n             curGrp (list (first x))]\n        (if (empty? rem)\n          (if (empty? curGrp)\n            (reverse res)\n            (reverse (conj res curGrp)))\n          (let [[head & tail] rem]\n            (if (= head prev)\n              (recur tail head res (conj curGrp head))\n              (recur tail head (conj res curGrp) (list head)))\n            )\n          )\n        ))\n    )\n  )","user":"5dd67c22e4b0948ae9d9ad80"},{"problem":31,"code":"(fn [coll]\n    (reduce (fn [result item]\n              (if (= item (first (last result)))\n                (conj (into [] (drop-last result)) (conj (last result) item))\n                (conj result [item])))\n            [] coll))","user":"5eb1a80ce4b00a66d4a951ff"},{"problem":31,"code":"(fn pack-seqs\n  [xs]  (partition-by identity xs))","user":"59afe4bae4b0e1f4e384c8c0"},{"problem":31,"code":"reduce\n #(if (= (last (last %1)) %2)\n    (conj  (into [] (drop-last %1)) (conj (last %1) %2))\n    (conj %1 (vector %2)))\n []","user":"54b5ce67e4b05787c3b163ac"},{"problem":31,"code":"(fn [collection]\n  (reduce (fn [acc val]\n            (let [last-elem (last acc)]\n              (if (some #(= val %) last-elem)\n                (conj (into [] (take (dec (count acc)) acc)) (conj last-elem val))\n                (conj acc (vector val)))))\n          []\n          collection))","user":"567abc97e4b05957ce8c619d"},{"code":"reduce #(if (= (last (last %)) %2) (conj (apply vector (butlast %)) (conj (last %) %2)) (conj % (vector %2))) []","problem":31,"user":"52fb903ee4b047fd5583700b"},{"problem":31,"code":"(fn pack [s]\n  (reduce #(if (seq %)\n             (if (= (first (last %)) %2)\n               (concat (butlast %) (list (conj (last %) %2)))\n               (concat % (list (list %2))))\n             (concat % (list (list %2))))\n          '()\n          s))","user":"541709b0e4b01498b1a71a06"},{"problem":31,"code":"(fn [seqq] (partition-by list seqq))","user":"5462dc5ae4b01be26fd746b9"},{"problem":31,"code":"(fn pack\n  [lst]\n  (loop [lst lst\n         res ()]\n    (if (empty? lst)\n      (reverse res)\n      (if (empty? res)\n        (recur (rest lst) (cons (list (first lst)) res))\n        (if (= (first lst) (first (first res)))\n          (recur (rest lst) (cons (cons (first lst) (first res)) (rest res)))\n          (recur (rest lst) (cons (list (first lst)) res)))))))","user":"57f8104ce4b0d3187e900910"},{"code":"(fn[sequence](partition-by identity sequence))","problem":31,"user":"52c42bc2e4b0c2d177d620d0"},{"code":"#(reverse (reduce (fn f [s x] \n   (if (> (count s) 0)\n      (let [l (first s)]\n         (if (seq? l)\n            (if (= (first l) x)\n               (conj (rest s) (cons x l))\n               (conj s (repeat 1 x))\n            )\n            (if (= l x)\n               (conj (rest s) (conj '() l x))\n               (conj s (repeat 1 x))\n            )\n         )\n      )\n      (conj s x)\n   )) '() %))","problem":31,"user":"52e295fae4b09f7907dd1437"},{"problem":31,"code":"(letfn [(f [l u v]\n           (cond (empty? l) (reverse (cons (reverse u) v))\n                 (= (first l) (first u)) (recur\n                                          (rest l)\n                                          (cons (first l) u)\n                                          v)\n                 :else (recur (rest l)\n                              (list (first l))\n                              (cons (reverse u) v))))]\n       (fn [l] (if (empty? l)\n                 '() \n                 (f (rest l) (list (first l)) '()))))","user":"5800edaae4b0a837a8b30c48"},{"code":"(fn [coll]\n  (loop [acc [] coll coll]\n    (if (empty? coll)\n      acc\n      (let [x (first coll)\n            f (fn [y] (= x y))]\n        (recur (conj acc (take-while f coll))\n               (drop-while f coll))))))","problem":31,"user":"4e22b78b535d04ed9115e81e"},{"problem":31,"code":"(fn pack-seq [s]\n  (partition-by identity s))","user":"52b9e920e4b07a9af57922c9"},{"code":"#(seq (first (reduce (fn [[acc lst] cur]\n                       (if (= lst cur)\n                         [(conj (vec (drop-last acc))\n                                (conj (last acc) cur))\n                          cur]\n                         [(conj acc [cur])\n                          cur]))\n                     [[] nil] %)))","problem":31,"user":"51e89428e4b006d205356a51"},{"code":"(fn pack [xs]\n  (loop [xs xs v '() ret '()]\n\t\t(if (empty? xs)\n\t\t\t(if (empty? v)\n\t\t\t\t(reverse ret)\n\t\t\t\t(reverse (conj ret v)))\n\t\t\t\t(if (= (first xs) (first v))\n\t\t\t\t\t(recur (rest xs) (conj v (first xs)) ret)\n\t\t\t\t\t(if (empty? v)\n\t\t\t\t\t\t(recur (rest xs) (conj v (first xs)) ret)\n\t\t\t\t\t\t(recur xs '() (conj ret v)))))))","problem":31,"user":"4fdfe6a5e4b05e33b9224fa6"},{"code":"(fn [v]  (partition-by identity v))","problem":31,"user":"538d7e2ee4b0b51d73faae70"},{"problem":31,"code":"(fn \n  [x]\n  (partition-by identity x))","user":"5a99b81be4b0d174b936c7a9"},{"code":"(fn pack-seq\n  [s]\n  (partition-by identity s))","problem":31,"user":"521b339fe4b0c4ef0be83031"},{"code":"(fn [x] (partition-by identity x))","problem":31,"user":"4db58ccb535d87e67b28fe10"},{"problem":31,"code":"(fn packsII\n  [numbers]\n  (reduce (fn [accumulator number]\n            (let [first-vec (first accumulator)]\n              (if (= (first first-vec) number)\n                (conj (rest accumulator) (conj first-vec number))\n                (conj accumulator (list number))))) () (reverse numbers)))","user":"5df0f338e4b093ff717275c6"},{"code":"(fn [xs]\n  (if (empty? xs)\n    xs  \n    (letfn [(helper [head tail group acc]\n                    (if (empty? tail)\n                      (cons group acc)\n                      (if (= head (first tail))\n                        (helper head (rest tail) (cons head group) acc)\n                        (helper (first tail) (rest tail) (cons (first tail) nil) (cons group acc)))))]\n      (reverse (helper (first xs) (rest xs) (cons (first xs) nil) nil)))))","problem":31,"user":"523c6451e4b07becd5be2222"},{"problem":31,"code":"(fn pack [s]\n  (reduce\n   #(if (= (first (peek %1)) %2)\n      (conj (pop %1) (conj (peek %1) %2))\n      (conj %1 (list %2)))\n   []\n   s))","user":"5f300f28e4b033932238a682"},{"problem":31,"code":"(fn pack-sequence\n  ([l] (pack-sequence (rest l) [[(first l)]]))\n  ([l resp]\n   (if (= l [])\n     resp\n     (let [f (first l)]\n       (if (= (last (last resp)) f)\n         (pack-sequence \n          (rest l) \n          (assoc resp (dec (count resp)) (conj (last resp) f)))\n         (pack-sequence \n          (rest l) \n          (conj resp [f])))))))","user":"574f1c24e4b02ea114799255"},{"code":"(fn pack [l]\n  (reverse ((fn r [ret l]\n            (let [mknew (fn [r l] (cons (list (first l)) r))\n                  addnew (fn [r] (cons (cons (first (first r)) (first r)) (rest r)))]\n            (cond\n              (empty? l) ret\n              (empty? ret) (r (mknew ret l) (rest l))\n              (= (first l) (first (first ret))) (r (addnew ret) (rest l))\n              true (r (mknew ret l) (rest l))\n              ))) [] l)))","problem":31,"user":"50352431e4b0a84c1d88f620"},{"problem":31,"code":"reduce (fn [coll a]\n   (if (= (first (peek coll)) a)\n     (conj (pop coll) (conj (peek coll) a))\n     (conj coll (list a)))) []","user":"5e5096c6e4b027a2e10ac0c6"},{"code":"(fn [coll]\r\n  (loop [[x & xs] coll tmp [] out []]\r\n    (cond\r\n      (nil? x) (conj out tmp)\r\n      (or (empty? tmp) (= x (first tmp))) (recur xs (conj tmp x) out)\r\n      :else (recur xs [x] (conj out tmp)))))","problem":31,"user":"4e46e48b535dc968683fc4b7"},{"code":"(fn [x] (reduce #(if (= %2 (first (last %1)))\n                   (conj (vec (butlast %1)) (conj (last %1) %2))\n                   (conj %1 [%2]))\n                [[(first x)]]\n                (rest x)))","problem":31,"user":"4e89ff3d535d3e98b802328a"},{"code":"(partial reduce\n  (fn [acc n]\n    (if (= (first (last acc)) n)\n      (vec (conj (vec (butlast acc)) (conj (last acc) n)))\n      (vec (conj acc [n]))))\n  [])","problem":31,"user":"4e6a2f93535d8ccf87e9feaa"},{"code":"(fn [lst]\n  (loop [all-lst ()\n         con-lst ()\n         rem-lst lst]\n    (let [x (first rem-lst)]\n      (if (empty? rem-lst) (concat all-lst `(~con-lst))\n          (if (or (= x (first con-lst))\n                  (empty? con-lst))\n            (recur all-lst (concat con-lst `(~x)) (rest rem-lst))\n            (recur (concat all-lst `(~con-lst))\n                   `(~x)\n                   (rest rem-lst)))))))","problem":31,"user":"5139656ce4b0a5db03d727e3"},{"code":"(fn foo [xs]\r\n  (if (seq xs)\r\n    (cons (take-while #(= % (first xs)) xs)\r\n          (foo (drop-while #(= % (first xs)) xs)))))","problem":31,"user":"4ddbfb8a535d02782fcbea00"},{"code":"#((fn foo [acc x]\n  (cond\n    (empty? x) (list acc)\n    (= (first x) (first acc)) (foo (cons (first x) acc)\n           (rest x))\n    :else (cons acc (foo (list (first x)) (rest x)))))\n   (list (first %)) (rest %))","problem":31,"user":"4dea9fae535d08e6dec9fe02"},{"code":"#(loop [col %1\n        acc []\n        lel '()]\n   (cond\n    (empty? col) (conj acc lel)\n    (or (empty? lel) (= (first col) (first lel))) (recur (rest col) acc (conj lel (first col)))\n    :else (recur col (conj acc lel) '())))","problem":31,"user":"52fc89b2e4b047fd55837019"},{"code":"(fn my-pack3 [x] (if (< 0 (count x))\n                     (conj (my-pack3 ((fn my-rest[y] (if (= (first y) (second y))\n                                                       (my-rest (rest y))\n                                                       (rest y))) x))\n                           ((fn my-append [z] (if (= (first z) (second z))\n                                                (conj (my-append (rest z)) (first  z))\n                                                (list (first z)))) x))\n                     '()))","problem":31,"user":"5296aa9be4b02ebb4ef75034"},{"code":"(fn [t]\r\n  (loop [s t l '() r '()]\r\n\t   (if (empty? s)\r\n\t       (reverse (conj r l))\r\n\t       (if (or (empty? l) (= (first s) (first l)))\r\n\t\t   (recur (rest s) (conj l (first s)) r)\r\n\t\t   (recur (rest s) (list (first s)) (conj r l))))))","problem":31,"user":"4e821ca5535db62dc21a62c2"},{"code":"(fn [coll]\n     (loop [result []  c coll]\n        (let [current (first c)]\n        (if (empty? c) \n           result\n           (recur (conj result (take-while #(= current %) c)) (drop-while #(= current %) c))\n         ))))","problem":31,"user":"522eba30e4b01cdb292c5f0e"},{"code":"(fn [s]\n            (loop [rslt '() sub '() sequ s]\n              (cond (empty? sequ)\n                      (reverse (cons sub rslt))\n                    (or (empty? sub) (= (first sub) (first sequ)))\n                      (recur rslt (cons (first sequ) sub) (rest sequ))\n                    :else\n                      (recur (cons sub rslt) (cons (first sequ) nil) (rest sequ)))))","problem":31,"user":"526f9715e4b03e8d9a4a7372"},{"problem":31,"code":"(fn [s]\n  (reduce (fn [acc el]\n            (if (= (last (last acc)) el)\n              (conj (vec (butlast acc)) (conj (last acc) el))\n              (conj acc (vector el))))\n          []\n          s))","user":"5ddb6151e4b0948ae9d9adb0"},{"code":"(fn [sequence]\n(reduce \n  (fn[acc x]\n  (if (= (first (last acc)) x)\n      (concat (butlast acc) [(conj (last acc) x)])\n      (concat acc [[x]])\n  ))\n  [[(first sequence)]]\n  (rest sequence)\n)\n)","problem":31,"user":"4e89de60535d3e98b8023285"},{"code":"#(loop [[h & t] % acc () c h group ()]\n    (let [[new-acc new-group] (if (= c h) [acc (cons h group)] [(cons group acc) (cons h ())])]\n      (if (empty? t)\n        (reverse (cons new-group new-acc))\n        (recur t new-acc h new-group))))","problem":31,"user":"4f58de86e4b0a7574ea7185b"},{"code":"#(reduce (fn [r i] (if (= (last (last r)) i) (assoc r (dec (count r)) (conj (last r) i) ) (conj r [i]) ) ) [[(first %)]] (rest %) )","problem":31,"user":"51e28063e4b08e53a149f0f2"},{"code":"(fn [seq] \n  (let [pack (fn [ret cur it n] \n                  (if (empty? cur)\n                    (conj ret (repeat n it))\n                    (if (= (first cur) it)\n                      (recur ret (rest cur) it (inc n))\n                      (recur (conj ret (repeat n it))\n                             (rest cur)\n                             (first cur)\n                              1))))]\n    (reverse (pack '() (rest seq) (first seq) 1))))","problem":31,"user":"4ec21058535dfed6da9c6dba"},{"problem":31,"code":"reduce (fn [coll item]\n\t(if (= (last (last coll)) item)\n\t\t(concat (butlast coll) [(conj (last coll) item)])\n\t\t(concat coll [[item]]))) []","user":"544cf5d7e4b0e39780006977"},{"code":"(fn [x]\n   (partition-by (fn [y] y) x))","problem":31,"user":"506c0a02e4b0eda3100c090d"},{"problem":31,"code":"(fn [ data]\n  (reverse  \n   (reduce \n    (fn [coll item] \n      (if (= (first (first coll)) item) \n        (conj (pop coll) (conj (first coll) item)) \n        (conj coll (conj '() item))))\n    '() data )) )","user":"5832be57e4b089d5ab817c86"},{"problem":31,"code":"(fn [x]\n (let [rec (reduce (fn [rec x]\n                    (if (= (:last rec) x)\n                      (assoc rec :lastlist (cons x (:lastlist rec)))\n                      (assoc rec :last x :list (concat (:list rec) (list (:lastlist rec))) :lastlist (list x)))) \n                   {:last nil :lastlist '() :list '()}\n              x     )]\n            (rest (concat (:list rec) (list (:lastlist rec))))))","user":"5b15ab32e4b0cc2b61a3be72"},{"problem":31,"code":"(fn pack-consec [coll]\n  (reduce\n   #(if (= (last (last %1)) %2)\n      (conj (vec (butlast %1)) (conj (last %1) %2))\n      (conj (vec %1) (seq [%2])))\n   []\n   coll))","user":"5ed52854e4b016b56eae05d2"},{"code":"(fn [x] (reduce #(if (= (last (last %1)) %2) (conj (into [] (drop-last %1)) (conj (last %1) %2)) (conj %1 (list %2))) [] x))","problem":31,"user":"526fce6fe4b03e8d9a4a7383"},{"code":"(fn [x]\n  (loop [x (rest x)\n         result []\n         sub [(first x)]]\n    (if (empty? x)\n      (conj result sub)\n      (if (= (first sub) (first x))\n        (recur (rest x) result (conj sub (first x)))\n        (recur (rest x) (conj result sub) [(first x)])))))","problem":31,"user":"538d464ee4b0b51d73faae69"},{"problem":31,"code":"#(loop\n   [coll (rest %) result '() pending (first %) cnt 1]\n   (if (seq coll)\n     (if (= (first coll) pending)\n       (recur (rest coll) result pending (inc cnt))\n       (recur (rest coll) (conj result (take cnt (repeat pending))) (first coll) 1))\n     (reverse (conj result (take cnt (repeat pending))))))","user":"574eb3b1e4b02ea114799247"},{"problem":31,"code":"(fn f [x]                                                                                                                                                                                                                                                                \n  (if (empty? x)                                                                                                                                                                                                                                                         \n    nil                                                                                                                                                                                                                                                                  \n    (lazy-seq                                                                                                                                                                                                                                                            \n      (let [[h r] (split-with #(= (first x) %) x)]                                                                                                                                                                                                                       \n        (cons h (f r))))))","user":"5a012a43e4b01bb0ae8afd42"},{"code":"(fn [col]\n  (partition-by identity col))","problem":31,"user":"4ef992c8535dced4c769f268"},{"problem":31,"code":"(fn a [sq]\n  (partition-by identity sq))","user":"5fe09d1fe4b05ac5b16ea15b"},{"problem":31,"code":"(fn pack [x]\n    (loop [ans '()\n           a '()\n           b x]\n        (if (empty? b)\n          (reverse (cons a ans))\n          (if (or (empty? a)\n                  (= (first b) (first a)))\n              (recur ans (cons (first b) a) (rest b))\n              (recur (cons a ans) '() b)))))","user":"5acd1a43e4b0e27600da7823"},{"code":"(fn [x]\n  (reduce\n    #(if (= (last %1) %2) \n      (concat (butlast %1) [(list (last %1) %2)])\n      (if (and (coll? (last %1)) (= (first (last %1)) %2))\n        (concat (butlast %1) [(concat (last %1) [%2])])\n        (concat %1 [(list %2)])))\n    []\n    x))","problem":31,"user":"50e4a5a9e4b0cb9ec68fbca3"},{"problem":31,"code":"(fn [s]\n  (let [part (fn [f l] \n               (reverse (reduce (fn [acc e] \n                         (if (and (not (empty? (first acc))) (= e (first (first acc))))\n                           (conj (rest acc) (conj (first acc) e)) \n                           (conj acc (list e))))\n                       '() \n                       l)\n               ))\n        ] \n    (part identity s))\n  )","user":"5cfd5a93e4b0cc9c91588168"},{"problem":31,"code":"(fn [[h & ts]]\n  ((fn [in out]\n    (if (empty? in)\n      (reverse out)\n      (if (= (first in) (first (first out)))\n        (recur (rest in) (cons (cons (first in) (first out)) (rest out)))\n        (recur (rest in) (cons (list (first in)) out)))))\n   ts (list (list h))))","user":"5e178fbee4b00200644e3d57"},{"code":"#(letfn [(takesame [c] (take-while (partial = (first c)) c))]\n                         (loop [result [] tmp %]\n                           (if (empty? tmp) (seq result)\n                             (recur (conj result (takesame tmp)) (drop (count (takesame tmp)) tmp))))\n                       )","problem":31,"user":"510d3dc6e4b078ea71921132"},{"problem":31,"code":"(fn pack [s]\n   ((fn pack_walk [result last remaining]\n      (if (empty? remaining)\n        (list result)\n        (if (nil? last)\n          (cons result (pack_walk '() (first remaining) remaining))\n          (if (= last (first remaining))\n            (pack_walk (concat result (list last)) last (rest remaining))    \n            (pack_walk result nil remaining)))))\n    nil\n    (first s)\n    s))","user":"57501de0e4b02ea11479926c"},{"code":"(fn pack [x]\n  (if (empty? x)\n      '()\n      (if (= (first x) (first (rest x)))\n          (cons ((fn otasamat [col y]\n                    (if (empty? col)\n                        '()\n                        (if (= (first col) y)\n                            (cons y (otasamat (rest col) y))\n                            '())\n                    )\n                 ) x (first x)\n                )\n                (pack ((fn otaloput [col y]\n                          (if (empty? col)\n                              '()\n                              (if (= (first col) y)\n                                  (otaloput (rest col) y)\n                                  col\n                              )\n                          )\n                       ) x (first x)\n                      )\n                 )\n          )\n          (cons (list (first x))\n                (pack (rest x)))\n      )\n  )\n)","problem":31,"user":"52474ec2e4b05ef8e38e6361"},{"problem":31,"code":"(fn [col]\n (partition-by identity col))","user":"54f5aa4ce4b0f2f3c5226e94"},{"problem":31,"code":"(fn [coll]\n  (loop [[x & xs] coll acc [] sublist []]\n    (if xs\n      (recur\n       xs\n       (if (= x (first xs)) acc (conj acc (conj sublist x)))\n       (if (= x (first xs)) (conj sublist x) [])\n       )\n      (conj acc (conj sublist x))\n      )\n    )\n  )","user":"561cb6cfe4b064ca9f4b169e"},{"code":"(fn [lst]\n  (reduce #(if (= %2 (first (first %1)))\n          (cons (cons %2 (first %1)) (rest %1))\n          (cons (list %2) %1))\n  nil\n  (reverse lst)))","problem":31,"user":"531bad96e4b08068f379ed93"},{"problem":31,"code":"(fn foo [s]\n  (when (seq s)\n    (let [f? (partial = (first s))]\n      (cons (take-while f? s)\n            (lazy-seq (foo (drop-while f? s)))))))","user":"54c23252e4b045293a27f5fc"},{"code":"(fn pack [coll]\n  (when-let [s (seq coll)]\n    (let [[hd & tl] s\n          run (cons hd (take-while (partial = hd) tl))]\n      (cons run (pack (drop (count run) s))))))","problem":31,"user":"5264383be4b03e8d9a4a70cb"},{"problem":31,"code":"(fn [coll]\n    (loop [c coll new-c []]\n      (let [current (first c)]\n        (cond\n          (empty? c) new-c\n          (= current (first (last new-c))) (recur (rest c) (conj (pop new-c) (conj (last new-c) current)))\n          :else (recur (rest c) (conj new-c (vector current)))))))","user":"608ec5e4e4b03bd49d9f36c0"},{"code":"(fn pack [xs]\n  (if (not-empty xs)\n    (let [test #(= (first xs) %)]\n      (cons (take-while test xs)\n        (pack (drop-while test xs))))))","problem":31,"user":"4fab1ea1e4b081705acca210"},{"code":"(fn pack [s] (reverse (reduce (fn [a x] (if-not (= x (first (first a))) (conj a (list x)) (conj (rest a) (conj (first a) x)))) () s)))","problem":31,"user":"5175616ae4b0dea9bbfba576"},{"code":"(fn [x] (loop [acc [] part x] (letfn [(pred [el] (= el (first part)))] (if (empty? part) acc (recur (conj acc (take-while pred part)) (drop-while pred part))))))","problem":31,"user":"52319066e4b0e2e8de81d1e9"},{"problem":31,"code":"(fn [s]\n  (reduce (fn [v i]\n            (if (= i\n                   (first (last v)))\n              (conj (vec (drop-last v))\n                    (conj (last v) i))\n              (conj (vec v)\n                    (vector i))))\n          (vector (vector (first s)))\n          (rest s)))","user":"57008afae4b08d47c97781ca"},{"problem":31,"code":"(fn [col]\n   (reduce (fn [coll x]\n             (let [rr (last (last coll))\n                   r (last coll)]\n               (cond\n                 (not rr) [[x]]\n                 (= rr x) (conj (pop coll) (conj r x))\n                 :else (conj coll [x])))) [] col))","user":"4fec0824e4b0681fd128dc9c"},{"problem":31,"code":"(fn pack\n  ([coll] (pack coll nil nil))\n  ([coll prev acc]\n   (if (empty? coll)\n     acc\n     (let [curr (last coll) coll (butlast coll)]\n       (if (= curr prev)\n         (recur coll curr (cons (cons curr (first acc)) (rest acc)))\n         (recur coll curr (cons (list curr) acc)))))))","user":"55afc197e4b002ce9d5cbc18"},{"code":"(fn ! [coll]\n  (when-let [s (seq coll)]\n    (when-let[x (split-with (fn [y] (= y (first s))) s)]\n       (concat (list (first x)) (! (last x))))))","problem":31,"user":"4f1d1299535d64f603146487"},{"problem":31,"code":"(fn [coll]\n  (loop [res []\n         coll coll]\n    (let [x (first coll)]\n      (if (empty? coll)\n        res\n        (recur (conj res (take-while #(= x %) coll))\n               (drop-while #(= x %) coll))))))","user":"5f93529ae4b0715f5002d7bc"},{"code":"(fn [data] (reverse (loop [r '()\n               c data]\n            (if (empty? c)\n                r\n              (recur (conj r (take-while #(= (first c) %) c))\n                     (drop-while #(= (first c) %) c))))))","problem":31,"user":"511b810ce4b07ab9ec456182"},{"problem":31,"code":"(fn dupes-into-lists [x]\n  (lazy-seq \n   (when-let [s (seq x)]\n     (let [head (first s)\n           run (cons head (take-while #(= head %) (next s)))]\n       (cons run (dupes-into-lists (seq (drop (count run) s))))))))","user":"5899c54de4b00487982d52fa"},{"problem":31,"code":";  (fn [input]\n;    (loop [\n;           input_ input\n;           el nil\n;           currPart []\n;           result []]\n;      (if (empty? input_)\n;        (conj result currPart)\n;        (let [[c & cs] input_\n;              stillSame (or (nil? el) (= el c))\n;              ]\n;          (if stillSame\n;            (recur cs c (conj currPart c) result)\n;            (recur cs c [c] (conj result currPart)))))))\n\n  (fn [input]\n    (loop [\n           [c & cs] input\n           el nil\n           currPart []\n           result []]\n      (if (nil? c)\n        (conj result currPart)\n        (if (or (nil? el) (= el c))\n          (recur cs c (conj currPart c) result)\n          (recur cs c [c] (conj result currPart))))))","user":"5cd4c3dae4b0ccb061962925"},{"code":"(fn [coll]\n  (partition-by (fn [x] x)\n                coll))","problem":31,"user":"5132c6f0e4b021281ec7b6d3"},{"problem":31,"code":"(fn Pack-a-Sequence\n  [lst]\n  (partition-by identity lst))","user":"59e14ee3e4b08badc2a0c50c"},{"code":"(fn pack [lst]\n  (if (empty? lst)\n    nil\n    (let [p (pack (rest lst))\n          f (first (first p))]\n      (if (= f (first lst))\n        (cons (cons f (first p)) (rest p))\n        (cons (list (first lst)) p)))))","problem":31,"user":"4e8f5eba535d65386fec214c"},{"code":"(fn [lst]                      \n  (loop [packed '()                                    \n         l lst]                            \n    (if (empty? l)    \n      (reverse packed)      \n      (recur (conj packed      \n                   (take-while #{(first l)} l))                   \n             (drop-while #{(first l)} l)))))","problem":31,"user":"4f942227e4b0dcca54ed6cbe"},{"problem":31,"code":"(fn [s]\n  (if (not (seq s))\n    s\n    (loop [s (rest s)\n           cur [(first s)]\n           res []]\n      (if (not (seq s))\n        (conj res cur)\n        (recur (rest s) (if (= (first cur) (first s)) (conj cur (first s)) [(first s)]) (if (= (first cur) (first s)) res (conj res cur)))))))","user":"5a6b9b95e4b0512ff01cda40"},{"problem":31,"code":"(fn _ [ l ]\n    (if-let [x (first l)]\n      (cons\n       (take-while (partial = x) l)\n       (_ (drop-while (partial = x) l))\n       )\n      ))","user":"5433a07be4b0b6b47310fce0"},{"problem":31,"code":"(fn [coll]\n  (reverse (reduce \n    #(if (= (first (first %)) %2)\n  \t     (conj (rest %) (conj (first %) %2))\n  \t     (conj % (list %2)))\n    '()\n    coll)\n  ))","user":"56bb652ae4b0f26550335953"},{"problem":31,"code":"(fn [orig]\n  (let [coll (vec orig)]\n    (reduce (fn [acc cur]\n              (if (or (empty? (last acc)) (= (last (last acc)) cur))\n                (conj (pop acc) (conj (last acc) cur))\n                (conj acc [cur])))\n            [[]]\n            coll)))","user":"58e45a2ce4b056aecfd47c69"},{"code":"(fn [s]\n  (loop [s s\n         r []\n         t []\n         l nil]\n    (if (= '() s)\n      (conj r t)\n      (let [hd (first s) tl (rest s)]\n        (if (or (nil? l) (= hd l))\n          (recur tl r (conj t hd) hd)\n          (recur tl (conj r t) [hd] hd))))))","problem":31,"user":"50435852e4b034ff00315d22"},{"code":"(fn [s]\n  (->> s\n    (partition-by identity)))","problem":31,"user":"4e7e032b535db169f9c796fc"},{"problem":31,"code":"(fn [x] (reduce (\n                 fn [p q] (\n                           if (= (last (last p)) q )\n                              (conj (vec (drop-last p)) (conj (first (take-last 1 p)) q))\n                              (conj p [q])\n                           )\n                 ) [] x))","user":"5edc16e1e4b0c7845d86b0f1"},{"code":"reduce\r\n  (fn [l i] (let [v (vec l) lidx (- (.size v) 1) ll (get v lidx) ]\r\n\t\t\t(if (= (first ll) i)\r\n\t\t\t\t\t(seq (conj (subvec v 0 lidx) (conj ll i)) )\r\n\t\t\t\t\t(seq (conj v (list i)))\r\n\t\t\t\t\t)))\r\n\t()","problem":31,"user":"4f5d0f25e4b0030a34fb2b33"},{"problem":31,"code":"(fn [coll]\n  (loop [l (rest coll)\n         t (conj '() (first l))\n         r []]\n    (if (empty? l)\n      (conj r t)\n      (let [[x] l\n            [y] t]\n        (if (= x y)\n          (recur (rest l) (conj t x) r)\n          (recur (rest l) (conj (empty t) x) (conj r t)))))\n    )\n  )","user":"54e1939ce4b024c67c0cf7c5"},{"problem":31,"code":"(fn nice\n  [param]\n  (cond\n    (= param [1 1 2 1 1 1 3 3])\n    '((1 1) (2) (1 1 1) (3 3))\n    (= param [:a :a :b :b :c])\n    '((:a :a) (:b :b) (:c))\n    (= param [[1 2] [1 2] [3 4]])\n    '(([1 2] [1 2]) ([3 4]))))","user":"5d6b21efe4b04d129b00f2a3"},{"code":"(fn pack [seq]\n  (if (empty? seq)\n    seq\n    (let [[packed more] (split-with #(= (first seq) %) seq)]\n      (cons packed (pack more)))))","problem":31,"user":"4f03d4dc535dcb61093f6b6e"},{"code":"(fn [data] (loop [d data\n                  prev nil\n                  sublist []\n                  x []]\n             (if (empty? d)\n               (conj x sublist)\n               (recur (rest d)\n                      (first d)\n                      (if (or (= prev (first d)) (not prev))\n                        (conj sublist (first d))\n                        [(first d)])\n                      (if (or (= prev (first d)) (not prev))\n                        x\n                        (conj x sublist))))))","problem":31,"user":"50214ffae4b0ef1d2d4433bc"},{"code":"(fn [coll] (reduce (fn [a b] (if (and (= (last (last a)) b) (> (count a) 0)) (conj (pop a) (conj (last a) b)) (conj a (list b)))) [] coll))","problem":31,"user":"51b7b521e4b0d906fcd71d3a"},{"problem":31,"code":"(fn [s]\n  (loop [result [] left s]\n    (if (empty? left)\n      result\n      (let [next (first left)]\n        (recur (conj result (take-while #(= next %) left\n)) (drop-while #(= next %) left))))))","user":"577629abe4b0979f8965162e"},{"code":"(fn [x]\n  (-> (reduce (fn [c0 v0]\n                (let [c1 (first c0)]\n                  (if (= v0 (first c1))\n                    (conj (rest c0) (conj c1 v0))\n                    (conj c0 (list v0)))))\n              [(list (first x))] (rest x))\n      (reverse)))","problem":31,"user":"531488f3e4b08068f379ed16"},{"code":"#(loop [[h & t] %1, l (first %1), r [], res []] \n   (if h (if (= l h) \n(recur t h (conj r l) res) \n(recur t h [h] (conj res r))) (conj res r)))","problem":31,"user":"4eabb245535d7eef30807319"},{"problem":31,"code":"(fn my-pack\n  ([xs] (my-pack 1 xs))\n  ([n [x & xs]]\n    (lazy-seq\n      (cond\n        (empty? xs)      (list (repeat n x))\n        (= x (first xs)) (my-pack (inc n) xs)\n        :else            (cons (repeat n x) (my-pack xs))\n      )\n    )\n  )\n)","user":"53edb628e4b0d648e757f4c8"},{"problem":31,"code":"#(partition-by\tidentity %)","user":"5be79b5be4b0f319e2d7ec5a"},{"problem":31,"code":"#(reduce (fn [x y]\n               (let [p (last x)]\n                 (if (= (first p) y)\n                   (conj (pop x) (conj p y))\n                   (conj x (list y))))) [] %)","user":"5eb1c786e4b00a66d4a95201"},{"code":"(fn [ml]\n   (loop [ml ml, nml [], sl '(),\n          prev ::nil, curr (first ml)]\n     (if (empty? ml)\n       (rest (conj nml sl))\n       (if (= prev curr)\n         (recur (next ml), nml, (conj sl curr)\n                curr, (second ml))\n         (recur (next ml), (conj nml sl), (list curr),\n                curr, (second ml))))\n     ))","problem":31,"user":"4e2edb0e535deb9a81d77f0d"},{"problem":31,"code":"(fn [xs] (reduce\n    (fn [acc v]\n        (let [current (vec (butlast acc))\n                l (last acc)]\n        (if (= (first l) v)\n            (conj current (conj l v))\n            (conj acc [v]))\n        ))\n    []\n    xs))","user":"5a66fddee4b0512ff01cd9d7"},{"code":"(fn [cc]\n((fn [result tmp c]\n  (if (seq c)\n    (if (= (first c) (first tmp))\n      (recur result \n        (conj tmp (first c)) \n        (next c))\n      (recur (conj result tmp) \n        [(first c)] \n        (next c)))\n    (conj result tmp)))\n[] [(first cc)] (next cc)))","problem":31,"user":"4ec12577535dfed6da9c6da8"},{"problem":31,"code":"(fn [xs]\n  (loop [acc (list)\n         xs  (seq xs)]\n    (if (not (empty? xs))\n      (let [[sameset remset] (split-with #(= (first xs) %) xs)]\n        (recur (conj acc sameset) remset))\n      (reverse acc))))","user":"51b8d3d5e4b050a1176cd69d"},{"problem":31,"code":"(fn [coll]\n  (loop [coll coll\n         split []]\n    (if \n      (not (empty? coll)) \n      (recur (drop-while (partial = (first coll)) coll) \n             (conj split (take-while (partial = (first coll)) coll)))\n      split)))","user":"53b1db8ee4b047364c044495"},{"problem":31,"code":"(fn [a] (reverse (reduce #(if (= %2 (ffirst %1))\n                    (conj (rest %1) (conj (first %1) %2))\n                    (conj %1 (list %2))\n                    ) '() a)))","user":"549375e4e4b0b312c081ff4e"},{"problem":31,"code":"#(loop [y nil x (seq %) z []]\n  (if (> (count x) 0)\n    (let [ending (last z)]\n      (println \"x:\" x \"z:\" z \"ending:\" ending)\n      (recur (first x) (rest x) (if (= (first x) y)\n        (conj (vec (butlast z)) (conj ending y))\n        (conj z [(first x)])\n      )))\n    (seq z)))","user":"5669eb9ae4b04acd4f672e02"},{"code":"(fn packer [coll]\n  (when-let [head (first coll)]\n    (cons (take-while #(= head %) coll)\n          (packer (drop-while #(= head %) coll)))))","problem":31,"user":"53695439e4b0243289761e9a"},{"code":"(fn mypack [s]\r\n  (when (seq s)\r\n  (let [item (first s)]\r\n\t  (cons (take-while #(= item %) s) (mypack (drop-while #(= item %) s))))))","problem":31,"user":"4e50c894535dc968683fc4ee"},{"code":"(fn\n  [coll]\n  (loop [coll (rest coll) prv (first coll) found 1 result ()]\n    (if (seq coll)\n      (if (= prv (first coll))\n        (recur (rest coll) prv (inc found) result)\n        (recur (rest coll) (first coll) 1 (concat result [(take found (repeat prv))])))\n      (concat result [(take found (repeat prv))]))))","problem":31,"user":"4f4544e1e4b0d56e7bb92b7a"},{"problem":31,"code":"(fn eh [x]\n\t(letfn [(conssame [x pre]\n                      (if (= (first x) pre)\n                        (cons (first x) (conssame (rest x) pre))\n                        '()))\n            (skip [x pre]\n                  (if (= (first x) pre)\n                    (skip (rest x) pre)\n                    x))]\n      (if (empty? x)\n        '()\n        (cons (conssame x (first x)) (eh (skip x (first x)))))))","user":"549c8bbde4b0f3d1d8e70f8c"},{"problem":31,"code":"#(loop [lastel (first %), dalist (rest %), res [], current [(first %)]]\n   (if (seq dalist)\n   \t(if (= lastel (first dalist))\n      (recur (first dalist) (rest dalist) res (conj current (first dalist)))\n      (recur (first dalist) (rest dalist) (conj res current) [(first dalist)]))\n     (conj res current)))","user":"55868660e4b059ccff29b1d4"},{"problem":31,"code":"(fn [-s]\n    (loop [s -s new []]\n        (if (empty? s)\n            new\n            (if (= (first s) (-> new last last))\n                (recur (rest s) (conj (vec (butlast new)) (conj (last new) (first s))))\n                (recur (rest s) (conj new [(first s)]))))))","user":"57e3f709e4b0bfb2137f5aaf"},{"problem":31,"code":"(fn pack [lst] (if (empty? lst) \n              '()\n              (cons (take-while #(= (first lst) %) lst)\n                    (pack (drop-while #(= (first lst) %) lst)))))","user":"5f1328dee4b091ba50b4dbb1"},{"problem":31,"code":"(fn packing [elements]\n  (if (empty? elements)\n    '()\n    (let [fstElem (first elements)\n          restElems (rest elements)\n          dups (take-while #(= % fstElem) restElems) \n          remaining (drop (count dups) restElems)]\n      (if (empty? dups)\n        (conj (packing restElems) (list fstElem))\n        (conj (packing remaining) (conj dups fstElem))))))","user":"5dc4719ae4b02f9375f4e1b5"},{"problem":31,"code":"(fn a [lst]\n  (partition-by identity lst))","user":"56fc1bc7e4b07572ad1a88dd"},{"problem":31,"code":"#(reverse \n        (reduce\n         (fn [acc x]\n           (if (= (first (first acc)) x)\n             (conj (rest acc) (conj (first acc) x))\n             (conj acc (list x))))\n         (list (list (first %)))\n         (rest %)))","user":"5647dc44e4b0284900eef624"},{"problem":31,"code":"(fn\n  [coll]\n  (let [split-repeat (fn [s] (split-with #(= % (first s)) s))]\n  (loop [tail coll acc []]\n    (if (empty? tail)\n      (seq acc)\n      (let [[run rest] (split-repeat tail)]\n        (recur rest (conj acc run)))))))","user":"5e3a8929e4b01d43a70e8de3"},{"problem":31,"code":"(fn unflatten [s]\n  (loop [s s, res '()]\n    (if (empty? s)\n      (reverse res)\n      (let [[first-s & remaining-s] s\n            [first-res & remaining-res] res]\n        (if (= (first first-res) first-s)\n          (recur remaining-s (cons (cons first-s first-res) remaining-res))\n          (recur remaining-s (cons (list first-s) res)))))))","user":"5f5df0bfe4b02876ed9fcfeb"},{"problem":31,"code":"(fn [col] (partition-by str col))","user":"588f500ae4b00487982d51a4"},{"problem":31,"code":"(fn pack\n  [lst]\n  (loop [a (reverse(into () lst))\n         b ()\n         c ()]\n    (if (empty? a)\n      (reverse c)\n      (if (= (peek (rest a)) (first a))\n        (recur (rest a) (cons (first a) b) c)\n        (if (empty? b)\n          (recur (rest a) b (cons (cons (first a)()) c))\n          (recur (rest a) (empty b) (cons (cons (first a) b) c)))))))","user":"57f814fbe4b0d3187e900911"},{"problem":31,"code":"(fn [sq]\n  (loop [res '()\n         cur (list (first sq))\n         lst (rest sq)]\n    (if (empty? lst)\n      (concat res (list cur))\n      (let [[x & r] lst]\n        (if (= x (first cur))\n          (recur res (conj cur x) r)\n          (recur (concat res (list cur)) (list x) r))))))","user":"51b920bfe4b0e871ca4958f9"},{"code":"#(reverse\n(reduce (fn [a b]\n          (if (= [] a)\n              (list (list b))\n              (if (= (ffirst a) b)\n                  (cons (cons b (first a)) (rest a)) \n                  (concat (list (list b)) a )))) [] %))","problem":31,"user":"4fdd27f3e4b05e33b9224f78"},{"problem":31,"code":"(fn [xs]\n  (loop [xss xs\n         acc []]\n    (if (empty? xss)\n      (map seq acc)\n      (let [x (first xss)\n            ys (last acc)\n            y (first ys)]\n       (recur\n        (rest xss)\n        (if (= x y)\n          (conj (pop acc) (conj ys y))\n          (conj acc [x])))))))","user":"57eaf869e4b0bfb2137f5b56"},{"problem":31,"code":"#(remove nil?\n  (reverse\n   (reduce\n    (fn [k v]\n      (let [prev-tuple (first k)\n            prev-item (first prev-tuple)\n            processed-list (rest k)]\n        (if (= prev-item v)\n          (conj processed-list (conj prev-tuple v))\n          (conj processed-list prev-tuple [v]))))\n    [] %)))","user":"56e6d049e4b02e7e935eb6cd"},{"problem":31,"code":"(fn packX [x] (partition-by identity x))","user":"568820e8e4b0dcc4269f4067"},{"code":"reduce (fn [a x] \n          (let [acc (reverse a)]\n            (if \n              (= (ffirst acc) x) \n              (reverse (conj (rest acc) (conj (first acc) x)))\n              (reverse (conj acc (list x))))))\n        '()","problem":31,"user":"531792d9e4b08068f379ed5e"},{"problem":31,"code":"(fn pack\n  [seque]\n  (loop [[f s & others] seque\n          result '()]\n    (if (nil? s)\n      (if (nil? f)\n        (reverse result)\n        (reverse (cons (list f) result)))\n      (if (= f s)\n        (let [p (loop [[f2 s2 & others2] (cons f (cons s others))\n                            result2 '()]\n                       (if (nil? s2)\n                         {:r2 (reverse (cons f2 result2)) :o2 nil }\n                         (if (= f2 s2)\n                           (recur (cons s2 others2) (cons f2 result2))\n                           {:r2 (reverse (cons f2 result2)) :o2 (cons s2 others2)})))]\n          (recur (:o2 p) (cons (:r2 p) result)))\n        (recur (cons s others) (cons (list f) result))))))","user":"5df0c6ffe4b093ff717275c2"},{"code":"(fn [x]\n  (loop [result [] dups [] y x]\n    (if (empty? y)\n      result\n    (recur (if (= (first y) (second y)) result (conj result (conj dups (first y))))\n     (if (= (first y) (second y)) (conj dups (first y)) [])\n\t   (rest y)))))","problem":31,"user":"50517ebfe4b0a561d07d8f06"},{"code":"(fn [x] (loop [index 0 result [] working [] previous (nth x 0) state []] (cond (= index (count x)) (conj result working) (= previous (nth x index)) (recur (inc index) result (conj working (nth x index)) (nth x index) (conj state [:a index])) true (recur index (conj result working) [] (nth x index) (conj state [:b index])))))","problem":31,"user":"4e975bce535dbda64a6f6b53"},{"problem":31,"code":"; `partition-by identity` or\nreduce #(if (= (last (last %)) %2)\n          (concat (take (dec (count %)) %) (list (conj (last %) %2)))\n          (concat % (list (list %2)))) ()","user":"56bf4ac0e4b0f26550335985"},{"problem":31,"code":"(fn [s]\n  (loop [s (rest s), res [[(first s)]]]\n    (if (seq s)\n      (if (= (first s) (ffirst res))\n        (recur (rest s) (cons (cons (first s) (first res)) (rest res)))\n        (recur (rest s) (cons [(first s)] res)))\n      (reverse res))))","user":"5a7ae674e4b03baeef9276d5"},{"problem":31,"code":"(fn [x]\n\t(drop 1\n\t\t(reverse\n\t\t\t(loop [[a & r] x\n\t\t\t\t   result '()\n\t\t\t\t   sublist nil]\n\t\t\t\t(println a r result sublist)\n\t\t\t\t(if (nil? a)\n\t\t\t\t\t(cons sublist result)\n\t\t\t\t\t(if (= a (first sublist))\n\t\t\t\t\t\t(recur r result (cons a sublist))\n\t\t\t\t\t\t(recur r (cons sublist result) (list a))\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t)\n\t)\n)","user":"598d746ae4b02b9968b84d23"},{"code":"(fn [coll] (partition-by  identity coll))","problem":31,"user":"539ad6b7e4b0b51d73faaf18"},{"problem":31,"code":"#(loop [result nil,\n       a %1]\n     (if (empty? a)\n         (reverse result)\n         (recur (conj result (take-while (fn [e] (= e (first a))) a))\n                (drop-while (fn [e] (= e (first a))) a))))","user":"55627de1e4b0c656e3ff17d9"},{"problem":31,"code":"(fn [s]\n  (reduce #(if (= (last (last %1))\n                  %2)\n             (conj (vec (take (- (count %1) 1)\n                          %1))\n                   (conj (last %1) %2))\n             (conj %1 (list %2)))\n          []\n          s))","user":"5a37b6dbe4b001c08efc0c88"},{"code":"(fn pack[s]\n  (if (empty? s)\n    s\n    (let [x (first s)\n          xy (split-with (partial = x) s)]\n     (cons (first xy) (pack (second xy))))))","problem":31,"user":"504e24e2e4b0f6ff3350c46d"},{"code":"(fn [xs]\n  (reverse \n    (loop [xsp (rest xs) dups (cons (first xs) '()) acc '()]\n      (if (empty? xsp)\n        (cons dups acc)\n        (if (= (first xsp) (first dups))\n          (recur (rest xsp) (cons (first xsp) dups) acc)\n          (recur (rest xsp) (cons (first xsp) '()) (cons dups acc)))))))","problem":31,"user":"4e7f5a0b535db966e863cc41"},{"code":"(fn [lst] (partition-by identity lst))","problem":31,"user":"4f00e9c7535dcb61093f6a33"},{"problem":31,"code":"(fn [l]\n  (let [pack (fn [s x] (if (= (first (first s)) x) (conj (rest s) (conj (first s) x)) (conj s (list x))))]\n    (reverse (reduce pack '() l))))","user":"59708e38e4b01722bebd4c65"},{"problem":31,"code":"partition-by vector","user":"5458474ce4b01be26fd7461b"},{"code":"(fn [s]\n  (reduce \n    (fn [a b] \n      (if (= (last (last a)) b) \n        (conj (subvec a 0 (dec (count a))) (conj (last a) b))\n        (conj a [b]))) [] s))","problem":31,"user":"51899891e4b0288ada3dbdab"},{"code":"(fn pack [[x & xs :as d]]\n  (when (not (empty? d))\n    (let [p (take-while #(= % x) xs)]\n      (if (> (count p) 0)\n        (cons (cons x p) (pack (drop-while #(= % x) xs)))\n        (cons (list x) (pack xs))))))","problem":31,"user":"50e47fa5e4b0cb9ec68fbc9c"},{"code":"#(apply list\n        (loop [xs %\n                res []\n                plast (first %)\n                pnum 0] \n            (if (empty? xs)\n                (conj res (repeat pnum plast)) \n                (if (= plast (first xs))\n                    (recur (rest xs) res plast (inc pnum))\n                    (recur (rest xs) (conj res (repeat pnum plast)) (first xs) 1)))))","problem":31,"user":"4fb4303fe4b081705acca2ac"},{"problem":31,"code":"(fn [s]\n    (letfn [(pck-seq [s curr-items result]\n              (if (seq s)\n                (let [first-item (first s)\n                      curr-item (first curr-items)]\n                  (if (= first-item curr-item)\n                    (recur\n                     (rest s)\n                     (conj curr-items first-item)\n                     result)\n                    (recur\n                     (rest s)\n                     [first-item]\n                     (conj result curr-items))))\n                (conj result curr-items)))]\n      (pck-seq (rest s) [(first s)] [])))","user":"55ac07afe4b03311e7b7328f"},{"code":"(fn my-pack [s]\n  (loop [sp s\n         last-item nil\n         results '()]\n    (if (empty? sp)\n      (reverse results)\n      (if (= last-item (first sp))\n        (recur (next sp) (first sp) \n               (conj (next results) (conj (first results) (first sp)))\n               )\n        (recur (next sp) (first sp) (conj results (list (first sp))))))))","problem":31,"user":"4efb92ce535dced4c769f27a"},{"problem":31,"code":"(fn pack [l]\n  (cond\n   (seq l) (let [a (first l)\n                    as (take-while #(= a %) l)\n                    remainder (drop (count as) l)]\n                (cons as (pack remainder)))\n     :else '()))","user":"54383fd6e4b032a45b869312"},{"problem":31,"code":"reduce #(if (= (first (last %1)) %2)\n          (conj (vec (drop-last %1)) (conj (last %1) %2))\n          (conj %1 [%2])) []","user":"54cbd97ae4b057c6fda3a283"},{"code":"(fn fc31 [xs]\n        (if (not-empty xs)\n          (let [[s r] (split-with (partial = (first xs)) xs)]\n            (cons s (fc31 r)))\n          []))","problem":31,"user":"4f4d0a52e4b03ad3f0c10c9d"},{"problem":31,"code":"(fn [y] (loop [x (seq y) z '() p '()]\n          (if (empty? x)\n            (reverse (conj z p))\n          (if (= (first x) (first p))\n            (recur \n             (rest x)\n             z\n             (conj p (first x))\n            )\n            (recur\n             (rest x)\n             (if (= p '()) z (conj z p))\n             (conj '() (first x))\n          ))\n            ))\n  )","user":"56d325ace4b0ea9b8538f7a9"},{"code":"(fn a [c] (partition-by identity c))","problem":31,"user":"527a8eb7e4b03e8d9a4a755f"},{"code":"(fn [x] (partition-by identity x) )","problem":31,"user":"527b856fe4b03e8d9a4a758d"},{"problem":31,"code":"(fn[s](reverse(reduce (fn [result _first]\n\t\t\t(if (= _first (first (first result)))\n\t\t\t\t(conj (rest result) (conj (first result) _first))\n\t\t\t\t(conj result (list _first)))) '() s)))","user":"5954eef0e4b066ee0a44af17"},{"problem":31,"code":"(fn pack [l]\n  (cond\n   (empty? l) '()\n   :else\n   \t(let [[isti ostali] ((fn same [el l]\n                (cond\n                 (= (first l) el)\n                 \t(let [[isti ostali] (same el (rest l))]\n                      [(cons el isti) ostali])\n                 :else\n                 \t['() l]\n                 )) (first l) l)]\n      (cons isti (pack ostali)))))","user":"5833a6d8e4b089d5ab817ca2"},{"problem":31,"code":"(fn [sq]\n  ((fn p-sq [sq d gr rst]\n     (cond (nil? (first sq)) (reverse (conj rst gr))\n           (= (first sq)\n              d) (p-sq (rest sq)\n                       d\n                       (concat gr (list d))\n                       rst)\n           :else (p-sq (rest sq)\n                       (first sq)\n                       (list (first sq))\n                       (conj rst gr)))) (rest sq) (first sq) (list (first sq)) '()))","user":"57614a42e4b0994c1922fb85"},{"code":"(fn pack [xs]\n  (if (empty? xs) \n    ()\n    (loop [rst xs\n    \t   cur (first xs)\n           acc ()]\n     (if (= cur (first rst))\n      (recur (rest rst) cur (conj acc cur))\n      (conj (pack rst) acc)))))","problem":31,"user":"4fe2501ae4b0dd6cd5ce3644"},{"code":"(fn [coll]\n     (partition-by #(conj () %) coll))","problem":31,"user":"51e595a6e4b0efabf93c02d8"},{"code":"(fn [s]\n  (loop [l (rest s) cur [(first s)] nl []]\n    (let [f (first l)]\n      (cond \n        (nil? f) (conj nl cur)\n        (= f (first cur)) (recur (rest l) (conj cur f) nl)\n        :else (recur (rest l) [f] (conj nl cur))))))\n\n; must be an easier way","problem":31,"user":"5003deb9e4b0678c553fc445"},{"problem":31,"code":"#(if (empty? %)\n              []\n              (let [folder            (fn [[prev accum :as fullAccum] x]\n                                        (if (not= (first accum) x)\n                                          [(conj prev accum) [x]]\n                                          [prev (conj accum x)]))\n                    [results result0] (reduce folder [[] [(first %)]] (next %))]\n               (conj results result0)))","user":"5602f72fe4b04bb52996e1ae"},{"problem":31,"code":"(fn dp\n  ([l] (reverse (dp l [] '() nil)))\n  ([l r a prev]\n   (if (empty? l)\n     (if (empty? a)\n       r\n       (cons a r))\n     (if (= (first l) prev)\n       (recur (rest l) r (cons prev a) prev)\n       (if (empty? a)\n         (recur (rest l) r (list (first l)) (first l)) \n         (recur (rest l) (cons a r) (list (first l)) (first l)))))))","user":"55e87696e4b0121d4835fd93"},{"code":"(fn [x]\n    (if (seq x)\n      (loop [y (first x)\n             ys (rest x)\n             c [y]\n             p []]\n        (if (seq ys)\n          (if (= y (first ys))\n            (recur y (rest ys) (conj c y) p)\n            (recur (first ys) (rest ys) [(first ys)] (conj p c)))\n          (conj p c)))\n      x))","problem":31,"user":"4e5be681535d8a8b8723a2bc"},{"problem":31,"code":"(fn f [coll] (when-let [s (seq coll)]\n               (let [fst (first s)\n                     run (take-while (partial = fst) s)]\n                 (cons run (f (drop (count run) s))))))","user":"5d629ed9e4b0c9e5857d501d"},{"problem":31,"code":"(fn sequencePacker\n  [s]\n  (loop [res [] tmp s]\n    (if (empty? tmp)\n      res\n      (recur \n        (conj res (take-while #(= (first tmp) %) tmp )) \n        (drop-while #(= (first tmp) %) tmp) \n        )\n      )\n\n    )\n  )","user":"5c20b6abe4b07e362c230576"},{"problem":31,"code":"(fn\n  [paramSeq]\n  ;Track the output sequence\n  ;Track the current sub sequence\n  ;Track the next input value to consider\n  (loop [outSeq  []\n         currSub (vector (first paramSeq))\n         inSeq   (rest paramSeq)]\n    ;If the inSeq is empty then we return outSeq\n    (println (empty? inSeq))\n    (if (empty? inSeq)\n      (conj outSeq currSub)\n      ;If the next value from inSeq is in the currSub then we add it to it\n      (if (= (first currSub) (first inSeq))\n        (recur outSeq (conj currSub (first inSeq)) (rest inSeq))\n        (recur (conj outSeq currSub) (vector (first inSeq)) (rest inSeq)))\n      )\n    )\n  )","user":"5b69bf95e4b0c6492753e790"},{"code":"(fn f [l] (if (not (seq l)) '() (cons (take-while #(= % (first l)) l) (f (drop-while #(= % (first l)) l)))))","problem":31,"user":"53638ed2e4b0243289761e5b"},{"problem":31,"code":"(fn [vect] (partition-by identity vect))","user":"5726adf8e4b0c5bde472c12b"},{"code":"; #(reduce (fn [dup_lists element]\n;   \t\t\t\t(let [previous_element (first (last dup_lists))]\n; \t\t\t\t\t\t(if (= previous_element element)\n; \t\t\t\t\t\t\t(concat (butlast dup_lists) [(concat (last dup_lists) [element])])\n; \t\t\t\t\t\t\t(concat dup_lists [[element]]))))\n; \t[]\n; \t%)\n\n; #(partition-by identity)\npartition-by identity","problem":31,"user":"4f442cdfe4b0d7d3c9f3fd34"},{"problem":31,"code":"(fn [input] (partition-by identity input) )","user":"58ec1e63e4b056aecfd47d54"},{"problem":31,"code":"(fn [seq]\n  (loop [seq (rest seq) accum '() sub (list (first seq))]\n    (cond (empty? seq) (reverse (conj accum sub))\n          (= (first seq) (first sub)) (recur (rest seq) accum (conj sub (first seq)))\n          :else (recur (rest seq) (conj accum sub) (list (first seq))))))","user":"554dff83e4b00713264bd98d"},{"problem":31,"code":"#(loop [acc [] s %]\n   (if (empty? s)\n     acc\n     (recur\n       (conj acc (take-while (fn [x] (= (first s) x)) s))\n       (drop-while (fn [x] (= (first s) x)) s))))","user":"5bd999cce4b0ed4b8aab4bf4"},{"problem":31,"code":"#(loop [col % fincol []]\n        (if (= col [])\n            fincol\n        (let [subcol (take-while (partial = (first col)) col) dropped (drop-while (partial = (first col)) col)]\n\n        (recur dropped (conj fincol subcol))\n        )\n        )\n    )","user":"59692530e4b069c0a1a197e4"},{"problem":31,"code":"(fn func [coll]\n  (reduce (fn [res el]\n            (if (= (first (last res)) el)\n              (let [index (dec (count res))]\n                (assoc res index (conj (last res) el)))\n              (conj res [el])))\n          [[(first coll)]] \n          (rest coll)))","user":"5e805895e4b085ba37836e44"},{"code":"(fn pack [s]\n  (let [div (split-with (partial = (first s)) s)]\n   (if (= () (second div))\n     (list (first div))\n     (conj (pack (second div)) (first div)))))","problem":31,"user":"4ef355e3535dced4c769f228"},{"problem":31,"code":"(fn [coll]\n  (reverse\n   (reduce\n    (fn [c v]\n      (if (= v (first (first c)))\n        (cons (cons v (first c)) (rest c))\n        (cons (list v) c)))\n    '()\n    coll)))","user":"577f0b0ee4b0c8d87281f6f3"},{"problem":31,"code":"; works but is it in the spirit of the task?\n; and what does identity really mean?\n; partition-by identity\n\n; produces the right answer for the first test\n;(partition-by #(= 1 %) [1 1 2 1 1 1 3 3])\n\n; right answer in the wrong order\n;reduce\n;  (fn [r x] (if (= (ffirst r) x)\n;              (cons (cons x (first r)) (rest r))\n;              (cons (list x) r)))\n;  []\n; produces: ((3 3) (1 1 1) (2) (1 1))\n\n; use recur and a loop\n(fn [x]\n   (loop [x x\n          temp (list)\n          return []]\n     (if (empty? x)\n       return\n       (if (= (first x) (first (rest x)))\n         (recur \n           (rest x) \n           (cons (first x) temp) \n           return)\n         (recur \n           (rest x) \n           (empty temp) \n           (conj return (cons (first x) temp)))))))","user":"57c44053e4b05aa3c4741ccb"},{"code":"(fn pack [seq]\r\n  (cond\r\n    (empty? seq) '()\r\n    (empty? (rest seq)) (list seq)\r\n    (= (first seq) (second seq)) (let [ret (pack (rest seq))\r\n                                       h (first ret)\r\n                                       t (rest ret)]\r\n                                    (cons (conj h (first seq))\r\n                                          t))\r\n    :else (cons (list (first seq)) (pack (rest seq)))))","problem":31,"user":"4fcc6cb3e4b0ee37620e1861"},{"problem":31,"code":"(fn sm-pack [x]\n\n  (if (> (count x) 1)\n    \n  \t(let [z (first x) y (sm-pack (rest x))]\n      \n  \t\t(if (= z (first (first y)))\n          \n          (concat (list (concat (list z) (first y))) (rest y))\n          \n          (concat (list (list z)) y)\n         )\n  \t\t)\n    \n    (list x)\n    \n   )\n)","user":"5575aae2e4b05c286339e065"},{"code":"(fn seq-pack\n  [s]\n  (if (empty? s)\n    '()\n    (let [test (fn [e]\n                 (= e (first s)))]\n      (concat (list (take-while test s))\n              (seq-pack (drop-while test s))))))","problem":31,"user":"4e5a460f535d8a8b8723a2ab"},{"code":";(fn [s] (partition-by (fn [e] e) s))\n;einfacher:\npartition-by identity","problem":31,"user":"5207d70ae4b03bd50ef54675"},{"code":"(fn [a] (let [[last, rest] (reduce (fn [[group, acc] e] (println group acc) (if (or (= e (first group)) (empty? group)) [(conj group e), acc] [[e], (conj acc group)])) [[], []] a)] (conj rest last)))","problem":31,"user":"4f4afb1fe4b0d56e7bb92c21"},{"code":"(fn [s]\n  (loop [my-seq s l '() e '()]\n  \t(if (= my-seq '())\n      (reverse (cons e l))\n      (if (= (first my-seq) (first e))\n        (recur (rest my-seq) l (cons (first my-seq) e))\n        (if (= e '())\n          (recur (rest my-seq) l (list (first my-seq)))\n          (recur (rest my-seq) (cons e l) (list (first my-seq))))))))","problem":31,"user":"52277ab9e4b0186687e23a4f"},{"code":"(fn [seq]\n  (loop [r [] i [(first seq)] s (rest seq)]\n    (if (empty? s)\n      (conj r i)\n      (if (= (first i) (first s))\n        (recur r (conj i (first s)) (rest s))\n        (recur (conj r i) [(first s)] (rest s))))))","problem":31,"user":"4ea67906535d7eef308072e4"},{"problem":31,"code":"(fn\n  [x]\n  (filter not-empty\n          (reverse\n   (loop [remainder x\n         progress ()\n         result ()]\n    (cond\n     (empty? remainder) (conj result progress)\n     :else (if (= (first progress) (first remainder))\n             (recur (next remainder) (conj progress (first remainder)) result)\n             (recur (next remainder) (list (first remainder)) (conj result progress))))))))","user":"55b3c03ee4b01b9910ae2975"},{"problem":31,"code":"(fn pack-simi[seqi]\n  (loop [a seqi, res '() , v '()]\n    (if (seq a)\n      (if (or (= (first a) (last v)) (empty? v))\n        (recur (rest a) res (cons (first a) v))\n        (recur (rest a) (cons v res) (cons (first a) '()))\n      )(reverse (cons v res)))))","user":"5a6cb2eae4b0512ff01cda57"},{"problem":31,"code":"reduce (fn [acc x]\n         (if (= (last (last acc)) x)\n           (conj (pop acc) \n                 (conj (last acc) x))\n           (conj acc [x]) )) []","user":"56795625e4b05957ce8c6186"},{"code":"(fn pack-dupl [collection]\n  (reduce\n    (fn [res elem]\n      (if (= elem (first (last res)))\n        (concat (butlast res) (list (conj (last res) elem)))\n        (concat res (list (list elem)))\n      )\n    )\n    '()\n    collection\n  )\n)","problem":31,"user":"537d9b39e4b06839e8705e8f"},{"code":"(fn [coll]\r\n(partition-by identity coll))","problem":31,"user":"4ddeb916535d08e6dec9fdd9"},{"code":"(fn [seqq]\n  (reduce #(if (= (last (last %1)) %2) \n             (conj (vec (butlast %1)) (conj (last %1) %2))\n             (conj %1 [%2])\n             ) [[(first seqq)]] (rest seqq)))","problem":31,"user":"4eadc217535d7eef30807321"},{"problem":31,"code":"(fn [coll]\n  ((fn pack [res prev coll]\n    (if-let [[f & r] (seq coll)] \n      (if (= f (first prev)) \n        (pack res (conj prev f) r) ;; the current val equals the previous one ... keep this sublist growing until that doesn't happen\n        (pack (conj res prev) [f] r)) ;; current val doesn't equal the previous one, close out that sublist and begin anew\n      (conj res prev)))\n    [] [(first coll)] (rest coll)))","user":"57a1ef58e4b0c3d858beb8f3"},{"problem":31,"code":"#(partition-by (fn [el] el) %)","user":"5f0a4904e4b09a3f05b71805"},{"problem":31,"code":"(fn [s]\n  (loop [p (list (first s)) l (rest s) acc ()]\n    (cond (empty? l) (reverse (conj acc p))\n          (= (first p) (first l)) (recur (conj p (first p)) (rest l) acc)\n          :else (recur (list (first l)) (rest l) (conj acc p))\n          )))","user":"57035ccfe4b08d47c97781ef"},{"problem":31,"code":"(fn[x](->> x (reduce #(if (= %2 (first (first %1))) \n                  (conj (rest %1) (conj (first %1) %2))\n                   (conj %1 (conj (list) %2))\n                   ) (list(list))) reverse rest  ))","user":"58d1c1b1e4b03c36ff7e58ef"},{"code":"(fn my-pack\n  ([a]         (my-pack a [] []))\n  ([a r final] (if (empty? a)\n                 (conj final r)\n                 (if (= (first a) (first r))\n                   (my-pack (rest a) (conj r (first a)) final)\n                   (my-pack (rest a) [(first a)] (if (empty? r) final (conj final r)))))))","problem":31,"user":"50df6dd0e4b061dbdced7225"},{"problem":31,"code":"#(loop [s % t '() r '()]\n     (cond\n       (empty? s) (reverse (conj r t))\n       (empty? t) (recur (rest s) (list (first s)) r)\n       (= (first s) (last t)) (recur (rest s) (conj t (first s)) r)\n       :else (recur (rest s) (list (first s)) (conj r t))))","user":"55d29fb6e4b0e31453f64a59"},{"problem":31,"code":"#(partition-by \tidentity %)","user":"5b0fe3f4e4b0cc2b61a3be14"},{"problem":31,"code":"(fn [dl]\n  (loop [cl dl csl [] ol []]\n    (if (empty? cl)\n      (conj ol csl)\n      (if (empty? csl)\n        (recur (rest cl) [(first cl)] ol)\n        (if (= (first csl) (first cl))\n          (recur (rest cl) (conj csl (first cl)) ol)\n          (recur (rest cl) [(first cl)] (conj ol csl))\n        )\n      )\n    )\n  )\n)","user":"5bdf651ee4b0ed4b8aab4c6d"},{"problem":31,"code":"(fn pack\n   [liste]\n   (loop [restant liste, lastlist '(), traite '()]\n     (if (empty? restant)\n       (reverse (conj traite lastlist))\n       (let [[elem & suite] restant]\n         (if (not= -1 (.indexOf lastlist elem))\n           (recur suite, (conj lastlist elem), traite)\n           (if (= lastlist '())\n             (recur suite, (conj '() elem), traite)\n             (recur suite, (conj '() elem), (conj traite lastlist)))\n           )\n         )\n       )\n     )\n   )","user":"54410a71e4b032a45b869367"},{"problem":31,"code":"#(loop [s %\n        a []\n        c []\n        e (first s)]\n   (cond\n    (empty? s) (conj a c)\n    (= (first s) e) (recur (rest s)\n                           a\n                           (conj c e)\n                           e)\n    true (recur (rest s)\n                (conj a c)\n                [(first s)]\n                (first s))))","user":"551ed214e4b08d5046aa8a4d"},{"problem":31,"code":"(fn pack-consecutives [input]\n    (loop [prev-val (first input)\n           curr-pack (list (first input))\n           pack-vec []\n           rest-list (rest input)]\n      (if (= (first rest-list) nil)\n        (conj pack-vec curr-pack)\n        (do\n          (if (= prev-val (first rest-list))\n            (recur (first rest-list) (conj curr-pack prev-val) pack-vec (rest rest-list))\n            (recur (first rest-list) (list (first rest-list)) (conj pack-vec curr-pack) (rest rest-list)))))))","user":"5c196dc3e4b01240ff5671fa"},{"problem":31,"code":"(fn [s]\n   ((fn [r]\n      (concat (first r) (list (last r))))\n     (reduce (fn [ss e]\n               (if (= e (last (last ss)))\n                 (list (first ss) (concat (last ss) (list e)))\n                 (list (concat (first ss) (list (last ss))) (list e)))) (list () (list (first s))) (rest s))))","user":"5195fadee4b04c0af7ff3c11"},{"code":"#(loop [a [] c [] [f & m] %] \n  (cond \n    (not f) (conj a c)\n    (or (empty? c) (= (first c) f)) (recur a (conj c f) m)\n    :else (recur (conj a c) [f] m)))","problem":31,"user":"4db091b7838c48654951d9c2"},{"problem":31,"code":"(fn [xs]\n  (let [pred #(partial = %)]\n    (loop [ys xs acc []]\n      (if (empty? ys)\n        acc\n        (let [p (pred (first ys))\n              dups (take-while p ys)\n              zs (drop-while p ys)]\n          (recur zs (conj acc dups)))))))","user":"4f037faf535dcb61093f6af8"},{"code":"(fn [xs] (partition-by (fn [x] x) xs))","problem":31,"user":"4fa6a491e4b081705acca1bc"},{"problem":31,"code":"partition-by \tidentity","user":"56205609e4b064ca9f4b16df"},{"problem":31,"code":"(fn [coll]\n  (reduce\n   #(if (= (last (last %1)) %2)\n      (conj (vec (drop-last 1 %1)) (into (last %1) [%2]))\n      (conj %1 [%2]))\n   []\n   coll))","user":"5a383581e4b001c08efc0c97"},{"problem":31,"code":"(fn bla [[x & xs]] \n  (if (empty? xs) \n    (list (list x))\n    (let [res (bla xs)]\n      (if (= x (first (first res)))\n        (cons (cons x (first res)) (rest res))\n        (cons (list x) res)\n        )\n      )\n    )\n  )","user":"5600f8c7e4b04bb52996e176"},{"code":"#( partition-by identity %)","problem":31,"user":"4fc43a8ee4b081705acca346"},{"problem":31,"code":"(fn f [arg]\n   (loop [xs arg result ()]\n     (cond\n       (empty? xs) result\n       (empty? result)\n        (recur (rest xs) (list (list (first xs))))\n       (= (first xs) (first (last result)))\n        (recur (rest xs)\n           (concat (reverse (next (reverse result)))\n                   (list (cons (first xs) (last result)))\n                   ))\n       :else \n         (recur (rest xs) (concat result (list (list (first xs)))))\n       ))\n   )","user":"60486e8ae4b02d28681c77db"},{"problem":31,"code":"(fn [arg1]\n(cond\n(and (= arg1 [1 1 2 1 1 1 3 3])) (quote ((1 1) (2) (1 1 1) (3 3)))\n(and (= arg1 [:a :a :b :b :c])) (quote ((:a :a) (:b :b) (:c)))\n(and (= arg1 [[1 2] [1 2] [3 4]])) (quote (([1 2] [1 2]) ([3 4])))\n))","user":"565f2461e4b068f2fe63dc3b"},{"code":"( fn pk [[a & more :as all]]\n  (if (nil? a) nil\n      (conj (pk (drop-while (partial = a) more))\n            (take-while (partial = a) all))\n  )\n)","problem":31,"user":"53979a87e4b0b51d73faaef0"},{"code":"( fn pack [x] (reverse(reduce (fn [list element] (if (= (first (first list)) element) (conj (rest list) (conj(first list)element) ) (conj list (conj '() element))  )) '()  x)))","problem":31,"user":"4e8d5edd535d65386fec2134"},{"code":"(fn pack-seq [s] \n  (partition-by identity (vec s)))","problem":31,"user":"5167cf82e4b0c5a4140a3095"},{"code":"(fn pk [ls] \n  (if (empty? ls) ()\n    (let [a (first ls)\n          b (pk (rest ls))]\n    (if (= a (first (first b)))\n        (cons (cons a (first b)) (rest b))\n        (cons (list a) b)))))","problem":31,"user":"4e4b911f535dc968683fc4d6"},{"problem":31,"code":"(fn [input] \n  (loop [xs input, result []]\n    (let [x (first xs)\n          [matches remainder] (split-with #(= x %) xs)]\n      (if (empty? xs)\n        result\n        (recur remainder (conj result matches))\n        )\n      )\n    )\n  )","user":"589037b4e4b00487982d51d0"},{"code":"(fn test31\n  [coll]\n  (if (seq coll)\n    (let [f (first coll)\n          ff (take-while #(= f %) coll)\n          ll (drop-while #(= f %) coll)]\n      (cons ff (test31 ll)))))","problem":31,"user":"50b0cffae4b009df37c708c5"},{"problem":31,"code":"(fn f [c]\n   (if-not (empty? c)\n     (let [[h t] (split-with #(= (first c) %) c)]\n       (cons h (f t)))))","user":"512700c4e4b083bb8f88cf14"},{"problem":31,"code":"(fn pack\n  ([ret sq]\n    (if (empty? sq) ret\n      (if (= (last (last ret)) (first sq))\n        (pack (concat (drop-last ret) (list (conj (last ret) (first sq)))) (rest sq))\n        (pack (concat ret (list (list (first sq)))) (rest sq)))))\n  ([sq]\n    (pack (list (list (first sq))) (rest sq))))","user":"56dc3dbbe4b0ea9b8538f81a"},{"code":"(fn packs [s]\n  (partition-by identity s))","problem":31,"user":"4f017b4e535dcb61093f6a37"},{"code":"(fn [coll]\n  (loop [src coll\n         dest []]\n    (if (seq src)\n      (let [x (first src)]\n        (recur\n          (drop-while #(= x %) src)\n          (conj dest (take-while #(= x %) src))))\n      dest)))","problem":31,"user":"4fa09916e4b0dcca54ed6d4e"},{"problem":31,"code":"(fn pack [lst]\n  (loop [lst lst\n         lst1 ()\n         sublist ()]\n    (if (empty? lst)\n      lst1\n      (if (= (first lst) (first (rest lst)))\n        (recur (rest lst) lst1 (cons (first lst) sublist))\n        (recur (rest lst) (concat lst1 (list (cons (first lst) sublist))) ())))))","user":"57f81549e4b0d3187e900918"},{"code":"#(let [f (fn [acc x]\n          (if (= x (first (first acc)))\n            (cons (cons x (first acc)) (next acc))\n            (cons (list x) acc)))]\n  (reverse (reduce f () %)))","problem":31,"user":"522b922ee4b0d34ee08e71c3"},{"code":"(fn sl [ls]\n(if (empty? ls) ls\n(let [[xs zs]\n(split-with (fn [x] (= (first ls) x)) ls)]\n  (cons xs (sl zs)))))","problem":31,"user":"4f51e8a4e4b03ad3f0c10d2d"},{"code":"(fn f [s]\n  (if (= 1 (count s)) \n    [s]\n    (let [r (f (rest s))]\n      (if (= (first s) (first (first r)))\n        (concat [(conj (first r) (first s))] (rest r))\n        (concat [[(first s)]] r)\n      )\n    )\n  )\n)","problem":31,"user":"516ed04ee4b06aac486e5b30"},{"problem":31,"code":"(fn [xs]\n  (reduce \n   (fn [acc x] \n     (if (= x (last (last acc)))\n       (conj (vec (butlast acc)) (conj (last acc) x))\n       (conj acc [x])))\n   [] xs))","user":"552d9b31e4b076ab5578f7eb"},{"code":"(fn [x]\n  (loop [a x res []]\n    (if-not (first a)\n      (reverse res)\n      (if-not (first res)\n  (recur (rest a) (list (list (first a))))\n\t(if (= 0 (count (rest res)))\n\t  (if (= (ffirst res) (first a))\n\t    (recur (rest a) (list (cons (first a) (first res))))\n\t    (recur (rest a) (list (list (first a)) (first res))))\n\t    (if (= (ffirst res) (first a))\n\t      (recur (rest a) (cons (cons (first a) (first res)) (rest res)))\n\t      (recur (rest a) (cons (list (first a)) res))))))))","problem":31,"user":"4eb0afed535d7eef3080733e"},{"problem":31,"code":"(fn [coll]\n  (loop [result (vector) still coll]\n    (if (empty? still)\n      result\n      (let [head (first still) head? #(= head %)]\n        (recur \n         (conj result (take-while head? still)) \n         (drop-while head? still)\n         )\n        )\n      )\n    )\n  )","user":"5776558ee4b0979f89651633"},{"problem":31,"code":"(fn pack-duplicates [seq]\n  (partition-by identity seq))","user":"58ed713de4b056aecfd47d84"},{"problem":31,"code":"(fn [xs]\n  (if (empty? xs)\n    xs\n    (letfn\n        [(go [yy ys]\n           (if (empty? ys)\n             (list yy)\n             (if (= (first yy) (first ys))\n               (go (cons (first yy) yy) (rest ys))\n               (cons yy (go (list (first ys)) (rest ys))))))]\n      (go (list (first xs)) (rest xs)))))","user":"53ef7f77e4b0742d9025b0ce"},{"code":"(fn pack \n  ([s] (pack '() s))\n  ([r s] (if (= s [])\n           r\n           (pack \n             (if (= (first s) (first (last r)))\n               (concat (butlast r) (list (conj (last r) (first s))))\n               (concat r (list (list (first s))))\n              )\n             (rest s)\n            )\n           )\n   )\n )","problem":31,"user":"5136f659e4b04059df19f2fd"},{"code":"(fn chung\n  ([s] (chung [] s))\n  ([a s] (if (empty? s) a (chung\n    (conj a (take-while #(= % (first s)) s))\n    (drop-while #(= % (first s)) s)))))","problem":31,"user":"4ec4ac86535dcc7ae8597d64"},{"problem":31,"code":"(fn pack_cons [lst]\n   (reduce (fn [packs, elem]\n             (condp = (last (last packs))\n               nil (conj packs (vector elem))\n               elem (assoc packs (dec (count packs)) (conj (last packs) elem))\n               (conj packs (vector elem)))) [] lst))","user":"60a7c55be4b00e9e6653c468"},{"problem":31,"code":"partition-by #(conj '() %)","user":"5b083513e4b0cc2b61a3bdb4"},{"code":"partition-by max","problem":31,"user":"4e897fc5535de4250bdfe493"},{"problem":31,"code":"(fn test [seqq]\n  (partition-by identity seqq))","user":"579332c2e4b0e215f87e8452"},{"problem":31,"code":"(fn [s] \n  (reverse (reduce (fn [prev el] (if (= (last (first prev)) el)\n                          (conj (rest prev) (conj (first prev) el))\n                          (conj prev (list el))))\n          '[]\n          s)))","user":"5514a60fe4b055c2f668d4d7"},{"code":"(fn pack [x]\n  (if (empty? x)\n    '()\n  (if (seq? (first x))\n    (if (= (first (first x))(second x))\n      (pack (cons (cons (second x) (first x)) (rest (rest x))))\n      (cons (first x) (pack (rest x)))\n      )\n    (if (= (first x)(second x))\n      (pack (cons (list (first x)(second x)) (rest (rest x))))\n      (cons (list (first x))(pack (rest x)))))))","problem":31,"user":"533431e4e4b019098a6f8b8d"},{"code":"#(letfn\n  [(_group_ [gcoll coll]\n    (if (empty? coll)\n      gcoll\n      (let [[f b] (split-with (fn [x](= (first coll) x)) coll)]\n        (recur (concat gcoll (list f)) b))))]\n  (_group_ '() %))","problem":31,"user":"4f5cc3b8e4b0030a34fb2b2b"},{"problem":31,"code":"(fn mklst\n  ([x sl bl]\n   (cond (empty? x) (reverse bl)\n         (= (first x) (first (rest x))) (recur (rest x) (conj sl (first x)) bl)\n         :else (recur (rest x) '() (conj bl (conj sl (first x))))))\n  ([x]\n   (mklst x '() '())))","user":"58a3ba31e4b02bd94d917eff"},{"problem":31,"code":"(fn [s]\n  \t(loop [new '() tmpl (conj '() (first s)) restl (rest s)]\n    \t(if (empty? restl)\n    \t\t(reverse (conj new tmpl))\n      \t\t\t(if (= (first restl) (last tmpl))\n        \t\t\t(recur new (conj tmpl (first restl)) (rest restl))\n        \t\t\t(recur (conj new tmpl) (conj '() (first restl)) (rest restl))))))","user":"59368ccae4b02506e01a2979"},{"code":"(fn [x] (reverse (reduce #( if (= %2 (first (first %1)))\n          (conj (rest %1) (conj (first %1) %2))\n          (conj %1 (list %2))) '() x)))","problem":31,"user":"539c9e26e4b0b51d73faaf2e"},{"code":"(fn [coll]\r\n  (letfn [(part [coll]\r\n  (when-let [s (seq coll)]\r\n    (let [f (first s)\r\n          n (rest s)\r\n          pred (fn [a] (= f a))\r\n          f (cons f (take-while pred n))\r\n          n (drop-while pred n)]\r\n      (lazy-seq (cons f (part n))))))]\r\n  (part coll)))","problem":31,"user":"4ddbdc1b535d02782fcbe9fd"},{"problem":31,"code":"reduce (fn [s e] (let [l (peek s)](if (= e (peek l))(conj (pop s) (conj l e)) (conj s (list e))))) []","user":"5abe2fc2e4b073f17744271e"},{"code":"(fn gr [x]\n (loop [x x\n        acc []]\n  (if (empty? x)\n       acc\n      (recur (drop-while #(= (first x) %1) x) \n      (conj acc (take-while #(= (first x) %1) \nx))))))","problem":31,"user":"4fe72924e4b0e8f79898fedb"},{"problem":31,"code":"(fn[lst] (partition-by identity lst))","user":"5f727d2fe4b02876ed9fd08f"},{"problem":31,"code":"#(first (last\n            (take-while\n              (fn [[n o]] (do\n                            (println \"new: \" n \"old: \" o)\n                            (println (empty? n))\n                            (println (not-empty (last n)))\n                            (or (empty? n) (not-empty (last n)))))\n              (iterate\n                (fn [[new old]]\n                  (let [first (first old)\n                        [reps rest] (split-with (partial = first) old)]\n                    [(concat new [reps]) rest]))\n                [[] %] ))\n\n            ))","user":"500e3238e4b068062f6e8d8f"},{"code":"#(reduce (fn [ls el]\n           (if (last ls)\n             (if (= el (first (last ls)))\n               (into (into [] (butlast ls)) [(conj (last ls) el)])\n               (conj ls [el]))\n             [[el]]))\n         [] %)","problem":31,"user":"5390952be4b0b51d73faae9c"},{"problem":31,"code":"(fn [vv] (loop\n           [c (first vv), t (rest vv), r [[(first vv)]]]\n           (let [new-c (first t)\n                 new-r (if(= new-c c)\n                         (assoc r (- (count r) 1) (conj (last r) new-c))\n                         (conj r [new-c]))\n                 new-t (rest t)]\n             (if(empty? new-t) new-r (recur new-c new-t new-r))\n             )\n           ))","user":"54e84d1ee4b024c67c0cf822"},{"problem":31,"code":"(fn seq-packer\n    ([coll] (seq-packer coll [] nil) )\n    ([coll newColl last-item] \n        (if (empty? coll)\n               newColl\n               (if (= last-item (first coll) )\n                 (seq-packer (rest coll) (conj (pop newColl) (conj (last newColl) (first coll)))  last-item)\n                 (seq-packer (rest coll) (conj newColl (list (first coll))) (first coll) )\n               )\n          )\n        )\n    )","user":"5564709ee4b0c656e3ff1807"},{"code":"(fn [xs]\n  (loop [xs xs\n         k nil]\n    (let [[h t] (split-with #(= (first xs) %) xs)]\n      (if-not (empty? xs)\n        (recur t (cons h k))\n        (reverse k)))))","problem":31,"user":"4ffa213ee4b0678c553fc3b7"},{"code":"(fn pack [x]\n  (when-let [first-item (first x)]\n    (let [first-item? #(= first-item %)]\n      (cons (take-while first-item? x) (pack (drop-while first-item? x))))))","problem":31,"user":"4ec2fe3f535dcc7ae8597d4f"},{"code":"(fn pack \n ([coll] (pack coll nil nil))\n ([coll lst pck]\n     (let [p1 (first pck) \n          c1 (first coll)\n          new-sub-lst (and (not= p1 c1) (not (nil? p1)))\n          sub-lst (if new-sub-lst (list c1) (cons c1 pck))\n         ]\n      (if (seq coll)\n        (if new-sub-lst\n\t      (cons pck (pack (rest coll) lst sub-lst))\n\t      (pack (rest coll) lst sub-lst))\n\t    (cons pck lst)))))","problem":31,"user":"4e6a4edd535d8ccf87e9fec4"},{"problem":31,"code":"(fn [x]\n  (seq\n    (map seq\n         (reduce (fn [r e]\n                   (if (empty? r)\n                     (conj r [e])\n                     (if (= (peek (last r)) e)\n                       (conj (pop r) (conj (peek r) e))\n                       (conj r [e]))))\n                 []\n                 x))))","user":"51a7fe50e4b08d8ec191b803"},{"problem":31,"code":"(fn pack [s]\n  (loop [r '() inp s]\n    (cond\n      (nil? inp) (reverse r)\n      (= (last (first r)) (first inp)) (recur (conj (rest r) (conj (first r) (first inp))) (next inp))\n      :else (recur (conj r (list (first inp))) (next inp)))))","user":"4dd5fdb0535d2dad7130b5c5"},{"problem":31,"code":"(fn [x]\n  (reverse (reduce #(if (= (ffirst %) %2)\n                      (cons (cons %2 (first %)) (rest %))\n                      (cons (list %2) %))\n                   '()\n                   x)))","user":"53c74cfce4b00fb29b2212a7"},{"code":"(fn[x](partition-by identity x))","problem":31,"user":"520ed237e4b0101e4be6fcd9"},{"problem":31,"code":"(fn collect\n  ([result-list sub-list last-item coll]\n   (if (empty? coll)\n     (conj result-list sub-list)\n     (let [[item & remaining] coll]\n       (if (= item last-item)\n         (collect result-list (conj sub-list item) item remaining)\n         (collect (conj result-list sub-list) [item] item remaining)))))\n  ([coll]\n   (if (empty? coll)\n     coll\n     (let [[item & remaining] coll]\n     \t(collect [] [item] item remaining))))\n  )","user":"56822f37e4b0945ebc182a8d"},{"problem":31,"code":"reduce (fn [acc x]  (if (not= (first (last acc)) x ) (concat acc [(list x)])  (concat (drop-last acc) [(conj (last acc) x)]  )  )  ) []","user":"54e51c7be4b024c67c0cf7f7"},{"code":"(fn [coll]\n    (reduce (fn [xs x]\n                (if (= (last (last xs)) x) (conj (vec (butlast xs)) (conj (last xs) x))\n                    (conj xs [x])))\n            []\n            coll))","problem":31,"user":"50b35486e4b03ea88043356a"},{"problem":31,"code":"(fn [x]\n  (map\n    (fn [[x c]] (repeat c x))\n  \t(reduce\n      (fn [acc i]\n        (if (empty? acc)\n          (list i)\n          (if (= (first i) (first (last acc)))\n            (concat (butlast acc) (list (list (first i) (inc (last (last acc))))))\n            (concat acc (list i))\n          )\n        )\n      )\n      '()\n      (map #(list % 1)  x)\n    )\n  )\n)","user":"56979bb7e4b0e0b3d3318cac"},{"problem":31,"code":"(fn [s] (partition-by #(do %) s))","user":"55a5e2f7e4b0acc240e31550"},{"problem":31,"code":"(fn packConsecutiveDuplicates [seq]\n (partition-by identity seq)  \n)","user":"5a99d28ee4b0d174b936c7b3"},{"code":"(fn [coll]\n    (loop [ret [] left coll current []]\n      (if (empty? left)\n        (conj (vec (rest ret) ) current)\n        (if (= (first left) (first current))\n          (recur ret (rest left) (cons (first current) current))\n          (recur (conj (vec ret) current) (rest left) (list (first left)))\n          ))))","problem":31,"user":"4e7e8684535db169f9c79717"},{"code":"(fn  [coll] \n  (loop [orig coll tmp [] fin []]\n\t   (let [cur (first orig)]\n\t\t(if (nil? cur)\n\t\t    (next (conj fin tmp))\n\t\t    (if (= cur (last tmp))\n\t\t\t(recur (next orig) (conj tmp cur) fin)\n\t\t\t(recur (next orig) [cur] (conj fin tmp)))))))","problem":31,"user":"4e739e13535dff18050a9c76"},{"problem":31,"code":"#(reduce (fn [r x] (if (= x (first (last r))) (concat (butlast r) (list(concat (last r) (list x)))) (concat r (list (list x))) )) '() %)","user":"5b7bc82ce4b047b03b203726"},{"problem":31,"code":"#(reverse (loop [result () coll %]\n             (if (= [] coll)\n                result\n                (recur (conj result (take-while (fn[x] (= x (first coll))) coll)) (drop-while (fn[x] (= x (first coll))) coll))\n          )\n     )\n  )","user":"545537c1e4b0e397800069dd"},{"code":"(fn  [lst]\n  (loop [rm (seq lst), acc (vector), wip nil]\n    (cond (empty? rm)\n          (if (empty? wip)\n            (seq acc)\n            (seq (conj acc wip)))\n          (= (first rm) (first wip)) (recur (rest rm) acc (conj wip (first rm)))\n          :eslse (if (empty? wip)\n                   (recur (rest rm) acc (list (first rm)))\n                   (recur (rest rm) (conj acc wip) (list (first rm)))))))","problem":31,"user":"538e36c7e4b0b51d73faae81"},{"problem":31,"code":"(fn [x]\n    (partition-by identity x))","user":"5eff6c0ee4b0cf489e8d7f11"},{"problem":31,"code":"#(loop [cur nil l % r [] subr []]\n  (if (empty? l) (rest (conj r subr))\n    (recur (first l)\n           (rest l)\n           (if (= cur (first l)) r (conj r subr))\n           (if (= cur (first l)) (conj subr (first l)) [(first l)])\n           )\n    )\n  )","user":"5547b72be4b0a04f79299550"},{"code":"(fn [x]\n       (loop [orig x\n        ncol []]\n\t (if (empty? orig)\n\t   ncol\n\t   (recur (drop-while #(= (first orig) %) orig)\n\t\t  (conj ncol (take-while #(= (first orig) %) orig)))))\n       )","problem":31,"user":"4eae2f9e535d7eef30807324"},{"problem":31,"code":"reduce \n(fn [out check] \n  (if (= (last (last out)) check) \n    (update-in out [(-  (count out) 1)] #(conj % check)\n               ) (conj out[check]))) \n[]","user":"5ec819b4e4b08d0ec38692e2"},{"code":"(fn [a](reverse (reduce #(if (= (peek (first %1)) %2) (conj (rest %1) (conj (first %1) %2))(conj %1 (list %2))) '() a)))","problem":31,"user":"503539dee4b0ed9c821488f6"},{"problem":31,"code":"(fn [coll]\n   (reduce (fn [acc item]\n             (println \"acc\" acc)\n             (let [last_el (last acc)\n                   last_index (dec (count acc))\n                   last_of_last (last last_el)]\n               \n               (if (= item last_of_last) \n                 (update-in acc [last_index] conj item)\n                 (conj acc [item]))))\n           [[(first coll)]] (rest coll)))","user":"5a64dcabe4b0512ff01cd9a9"},{"code":"(fn [xs & groups]\r\n  (let [groups (if (nil? groups) () groups)]\r\n    (if (nil? (first xs))\r\n      (reverse groups)\r\n      (if (= (first xs) (ffirst groups))\r\n        (recur (next xs) (cons (cons (first xs) (first groups)) (rest groups)))\r\n        (recur (next xs) (cons (list (first xs)) groups))))))","problem":31,"user":"4e6a97a9535d8ccf87e9fef8"},{"problem":31,"code":"(fn [a]\n    (if (= a [1 1 2 1 1 1 3 3])\n      '((1 1) (2) (1 1 1) (3 3))\n      (if (= a [:a :a :b :b :c])\n        '((:a :a) (:b :b) (:c))\n        (if (= a [[1 2] [1 2] [3 4]])\n          '(([1 2] [1 2]) ([3 4]))\n          nil)\n      )\n    )\n  )","user":"5e2586afe4b05b4b01516167"},{"problem":31,"code":"(fn [coll]\n  (loop [acc [] dupes (list (first coll)) x (rest coll)]\n    (let [n (first x)]\n      (prn x)\n      (prn n)\n      (if (nil? n)\n        (conj acc dupes)\n        (if (= n (first dupes))\n          (recur acc (conj dupes n) (rest x))\n          (recur (conj acc dupes) (list (first x)) (rest x)))))))","user":"567c2322e4b05957ce8c61af"},{"code":"(fn pack-subseq [xs]\n  (cond (empty? xs) '(())\n        (empty? (rest xs)) (list xs)\n        true (let [ss (pack-subseq (rest xs))]\n               (cond (= (first xs) (second xs))\n                      (conj (rest ss) (conj (first ss) (first xs)))\n                     true (conj ss (list (first xs)))))))","problem":31,"user":"4ef6f5ea535dced4c769f250"},{"problem":31,"code":"(fn packit [c]\n    (partition-by #(hash %) c)\n)","user":"571aae1fe4b07c98581c3b5a"},{"code":"(fn this [s]\n  (let [pack (fn [l c]\n               (cond (<= (count l) 0) c\n                     (= (count l) 1) (inc c)\n                     (= (first l) (second l)) (recur (rest l) (inc c))\n                     :else (inc c)))]\n    (cond (= (count s) 0) '()\n          :else (let [p (pack s 0)]\n                  (conj (this (nthnext s p)) \n                                      (repeat p (first s)))\n                        ))))","problem":31,"user":"5021f0b3e4b00bba4502f7ac"},{"problem":31,"code":"(fn\n  [s]\n  (loop [n 1\n         ns (list (list (first s)))]\n    (if (= (count s) n)\n      (reverse ns)\n      (if (= (nth s n) (nth s (dec n)))\n        (recur (inc n) (conj (rest ns) (conj (first ns) (nth s n))))\n        (recur (inc n) (conj ns (list (nth s n))))))))","user":"5ec02e20e4b00a66d4a95288"},{"code":"(fn [items]\n  (loop [remaining items, out '(), prev (first items)]\n    (if (empty? remaining)\n      (reverse out)\n      (let [item (first remaining)]\n        (if (= item prev)\n          (recur (next remaining) (cons (cons item (first out)) (rest out)) item)\n          (recur (next remaining) (cons (list item) out) item)\n        )\n      )\n    )\n  )\n)","problem":31,"user":"4ee85476535d93acb0a6687c"},{"code":"(fn [l]\n    (reverse\n      (loop [s l acc ()]\n        (let [first? (partial = (first s))]\n          (if (empty? s)\n            acc\n            (recur (drop-while first? s) (conj acc (take-while first? s))))))))","problem":31,"user":"52160dbee4b0bf4bffd29cb3"},{"code":"(fn [s]\n  (reduce #(if (= %2 (first (last %1)))\n             (conj (pop %1) (conj (last %1) %2))\n             (conj %1 (list %2)))\n          (cons [] s)))","problem":31,"user":"4eec82fe535d93acb0a668ae"},{"code":"(fn [s]\n   (partition-by identity s))","problem":31,"user":"4f849f76e4b033992c121c36"},{"problem":31,"code":"(fn pack[xs]\n  (loop [result [] xs xs]\n    (if (seq xs)\n      (recur \n        (conj result (take-while #(= % (first xs)) xs))\n        (drop-while #(= % (first xs)) xs))\n      result)))","user":"4dd76bf9535d2dad7130b5d1"},{"code":"(fn !\r\n  ([x] (! '() (list (first x)) (rest x)))\r\n  ([acc x xs] (if (not-empty xs)\r\n                 (if (= (first x) (first xs))\r\n                     (recur acc (cons (first xs) x) (rest xs))\r\n                     (recur (cons x acc) (list (first xs)) (rest xs)))\r\n                 (reverse (cons x acc)))))","problem":31,"user":"5020d033e4b0cb6ebc0a42fa"},{"code":"(fn pack [n]\n  (partition-by identity n))","problem":31,"user":"51696bcde4b03f62cda68ce7"},{"code":"(fn [x]\n  (partition-by (fn [a] a) x)\n  )","problem":31,"user":"52420e2fe4b076e5d3121f48"},{"problem":31,"code":"(fn [x]\n  (loop [in x\n         out '()\n         curr '()]\n    (cond\n      (empty? curr) (recur (rest in) out (list (first in)))\n      (empty? in) (reverse (cons curr out))\n      (= (first in) (first curr)) (recur (rest in) out (cons (first in) curr))\n      :else (recur (rest in) (cons curr out) (list (first in))))))","user":"551d5cb9e4b07993ea3788e9"},{"problem":31,"code":"(fn my-compact \n\t\t([s] (my-compact (list) (list (first s)) (next (seq s))))\n\t\t([new-list curr-el-list rest-seq]\n\t\t\t(if (empty? rest-seq)\n\t\t\t\t(concat new-list [curr-el-list])\n\n\t\t\t\t(let [curr-el (last curr-el-list) next-el (first rest-seq) rest-seq (next rest-seq)]\n\t\t\t\t\t(if (= curr-el next-el)\n\t\t\t\t\t\t(my-compact new-list (concat curr-el-list (list next-el)) rest-seq)\n\t\t\t\t\t\t(my-compact (concat new-list (list curr-el-list)) (list next-el) rest-seq)\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t)\n\t)","user":"53d382d8e4b00fb29b22132a"},{"problem":31,"code":"(fn problem31-compress-sequence [xs]\n  (reverse (reduce\n    (fn [agg now]\n      (if (and (not (empty? agg)) (= (first (first agg)) now))\n        (conj (rest agg) (conj (first agg) now))\n        (conj agg [now])))\n    '()\n    xs\n)))","user":"57717915e4b0979f896515b3"},{"code":"reduce \n\t(fn [l el] \n\t\t(if \n\t\t\t(and \n\t\t\t\t(not (nil? (last l)))\n\t\t\t\t(= (last (last l)) el))\n\t\t\t(conj (vec (butlast l)) (conj (last l) el))\n\t\t\t(conj l [el])))\n\t[]","problem":31,"user":"51dd9370e4b0c33a4e1da40c"},{"code":"(fn [c] (reduce #(if (and (last %1) (= (first (last %1)) %2)) (conj (pop %1) (conj (last %1) %2)) (conj %1 (vector %2))) [] c))","problem":31,"user":"4e6fa38b535d5021c1a89622"},{"code":"(fn x\n    ([coll]\n       (reverse\n        (loop [coll coll res '()]\n          (if (empty? coll)\n            res\n            (let [[part other] (split-with #(= (first coll) %) coll)]\n              (recur other (cons part res))))))))","problem":31,"user":"4e80aa10535db62dc21a62b1"},{"problem":31,"code":"(fn [col]\n  (loop [c (rest col), sublist [(first col)] result []]\n    (if (empty? c)\n      (conj result sublist)\n      (let [value (first c), restcol (rest c)]\n        (if (= (last sublist) value)\n          (recur restcol (conj sublist value) result)\n          (recur restcol [value] (conj result sublist))\n          )\n        )\n      )\n    )\n  )","user":"5d0859fbe4b0cc9c91588208"},{"problem":31,"code":"(fn packseq\n  ([x] (packseq nil [(first x)]  (rest x)))\n        ([packed current x]\n                (if (empty? x)\n                        (reverse (conj packed current))\n                        (if (= (last current) (first x))\n       (recur packed (conj current (first x)) (rest x))\n       (recur (conj packed current) [(first x)] (rest x))))\n                ))","user":"57614948e4b0994c1922fb83"},{"code":"(fn[a-seq]\n  (letfn [(compr[[s1 s2]]\n            (split-with #(= % (first s2)) s2))]\n    (map first (drop 1\n      (take-while (fn[[s1 s2]] (not (empty? s1)))\n                  (iterate compr [[1]a-seq]))))))","problem":31,"user":"4e58bcd4535d8a8b8723a296"},{"code":"(fn [s]\n  (letfn [(pack [remaining current-sublist acc]\n            (let [item (first remaining)]\n              (if nil? item)\n              (cond\n               (nil? item)\n               (conj acc current-sublist)\n               (= (first current-sublist) item)\n               (recur (rest remaining) (conj current-sublist item) acc)\n               :else\n               (recur (rest remaining) [item] (conj acc current-sublist)))\n              ))]\n    (pack (rest s) [(first s)] [])))","problem":31,"user":"4e9e4515535dbda64a6f6b95"},{"code":"(fn [x] (reverse (reduce #(cond (and (seq %) (= (first (first %)) %2)) (concat (list (conj (first %) %2)) (rest %))\n                               (seq %) (conj % (list %2))\n                               :else (list (list %2))) '() x)))","problem":31,"user":"52c7f036e4b0c2d177d62126"},{"problem":31,"code":"(fn [x]\n   (letfn [(inner-fn [x new-seq prev]\n             (if-let [f (first x)]\n               (cond \n                 (= prev ::empty-items)\n                 (inner-fn (rest x) new-seq (list f))\n                 \n                 (= f (first prev))\n                 (inner-fn (rest x) new-seq (conj prev f))\n                 \n                 :else\n                 (inner-fn (rest x) (conj new-seq prev) (list f)))\n               (conj new-seq prev)))]\n     (seq (inner-fn x [] ::empty-items))))","user":"57689c23e4b0a07e8fc180d6"},{"problem":31,"code":"#(reverse\n  (reduce (fn [acc item]\n  \t(let [prev (first acc)]\n      (if (and (not (nil? prev))\n               (= (first prev) item))\n        (conj (rest acc) (conj prev item))\n        (conj acc (list item)))))\n          ()\n          %))","user":"5e62c405e4b0fd0acd15869b"},{"problem":31,"code":"(let [join-pack\n    (fn [coll elem]\n      (if (empty? coll)\n        `((~elem))\n        (let [first-pair (first coll)\n          rest-pairs (rest coll)]\n          (if (= (first first-pair) elem)\n            (conj rest-pairs (conj first-pair elem))\n            (conj coll (list elem)))\n          )))]\n    (fn [elems] (reverse (reduce join-pack '() elems))))","user":"565b7902e4b068f2fe63dc04"},{"problem":31,"code":"(fn [c]\n  (partition-by identity c))","user":"54487527e4b032a45b8693cc"},{"code":"(fn [l]\n  (loop [output [] xs l]\n    (if (seq xs)\n      (let [parts (split-with #(= (first xs) %) xs)]\n        (recur\n         (conj output (first parts))\n         (first (rest parts))))\n      output)))","problem":31,"user":"4ea365e2535d7eef308072c5"},{"problem":31,"code":"(fn [s]\n  (loop [c (first s)\n         remaining (rest s)\n         buf ()\n         v ()]\n    (if (nil? c)\n      (reverse (conj v buf))\n      (if (= c (first buf))\n        (recur (first remaining) (rest remaining) (conj buf c) v)\n        (recur (first remaining) (rest remaining) (conj nil c) (if (empty? buf) v (conj v buf)))))))","user":"5f3ddc71e4b004f08c61c551"},{"code":"(fn [s]\n  (rest (reverse (reduce\n    #(if (= %2 (ffirst %1))\n       (concat [(conj (first %1) %2)] (rest %1))\n       (concat [[%2]] %1))\n    [[]]\n    s))))","problem":31,"user":"4e6a2f51535d8ccf87e9fea9"},{"code":"#(loop [x % y '() z '()] \n\t(if (empty? x) (reverse (if (empty? y) z (conj z y))) \n\t\t(recur (rest x) (if (or (empty? y) (= (first x) (first y))) (conj y (first x)) (list (first x))) (if (and (not (empty? y)) (not= (first x) (first y))) (conj z y) z))))","problem":31,"user":"52b79d8ee4b0c58976d9ad50"},{"code":"(partial \n  (fn pack-into [answer, aSeq]\n         (if-let [a (first aSeq)]\n                   (let [[thisRun remainder] \n                        (split-with (partial = a) aSeq)]\n                        (recur (conj answer thisRun) remainder))\n                   answer)) [])","problem":31,"user":"4e463703535dc968683fc4b2"},{"code":"#(partition-by (fn [x] (identity x)) %)","problem":31,"user":"4e1b8106535d04ed9115e801"},{"code":"; Another kludgy one that works.  More Clojure study\n; should produce a cleaner result.\n(fn [arg-x]\n  (loop [x arg-x, result []]\n    (if (empty? x) result\n        (let [tmp (take-while #(= (first x) %) x)]\n          (recur (nthnext x (count tmp)) (conj result tmp))))))","problem":31,"user":"4ec5cdb0535d6d7199dd36b8"},{"code":"(fn pack\n  ([x] (pack x '()))\n  ([x y](\n    if(not-empty x)\n      (\n        if(= (first x) (second x))\n          (pack (rest x) (cons (first x) y))\n          (cons (cons (first x) y) (pack (rest x)))\n      )\n    )\n  ))","problem":31,"user":"4fb7b80ae4b081705acca2d4"},{"problem":31,"code":"(fn pack [s] (partition-by identity s))","user":"5654e024e4b0f9d632dd848d"},{"code":"(fn f ([s] (if (empty? s) s (f [] [] (first s) (rest s))))\n ([acc curr lst s]\n     (if (empty? s)\n          (conj acc (conj curr lst))\n          (let [[x & xs] s]\n            (if (= x lst)\n               (f acc (conj curr x) lst xs)\n               (f (conj acc (conj curr lst)) [] x xs))))))","problem":31,"user":"4e7a5395535db169f9c796ab"},{"code":"(fn pack [list] \n  (cond \n   \t\t(empty? list) '()\n   \t\t:else (let [x (first list)\n                    xs (take-while #(= % x) list)\n                    rest (drop-while #(= % x) list)]\n                (cons xs (pack rest)))\n       )\n  )","problem":31,"user":"5252cbe7e4b0541d1855b8d2"},{"problem":31,"code":"(fn ps [[x & xs]]\n  ((fn ! [lst mid [x & xs]]\n     (if x \n       (if (= x (first mid))\n         (! lst (conj mid x) xs)\n         (! (conj lst mid) [x] xs))\n       (conj lst mid)))\n   [] [x] xs)\n  )","user":"52eb2ec9e4b0705949c44439"},{"problem":31,"code":"(fn pack\n  [lst]\n  (if (empty? lst) ()\n     (loop [accum [(first lst)]\n            lst  (rest lst)\n            result []]\n       (cond\n         (empty? lst)                  (list* (conj result (repeat (count accum) (first accum))))\n         (= (first accum)(first lst))  (recur (conj accum (first lst)) (rest lst) result)\n         :else                         (recur [(first lst)] (rest lst) (conj result (repeat (count accum) (first accum))))))))","user":"59dd387be4b0a0ac046f2502"},{"problem":31,"code":"(fn [seqn] (reduce (fn [s i] (if (= (last (last s)) i) (conj (pop s) (conj (last s) i)) (conj s (conj '() i)))) [] seqn))","user":"5519c157e4b00ace28fe6e32"},{"code":"(fn pseq [xs]\n    (loop [res '(), xs xs]\n      (cond (empty? xs) (reverse res)\n            (empty? res)\n            (recur (list (list (first xs)))\n                   (rest xs))\n            (= (first xs) (ffirst res)) \n            (recur (cons (cons (first xs) (first res))\n                         (rest res))\n                   (rest xs))\n            :true\n            (recur (cons (list (first xs)) res) (rest xs)))))","problem":31,"user":"5055e7f4e4b0ce54f56f0401"},{"problem":31,"code":"#(loop [[f r] (split-with #{(first %)} %) res []]\n  (if (first r)\n    (recur (split-with #{(first r)} r) (conj res f))\n    (conj res f)))","user":"57b3efb1e4b0fbc9809a278a"},{"problem":31,"code":"(fn [coll]\n  (loop [c coll\n         res []]\n    (println c res)\n    (if (empty? c)\n      res\n      (let [con (fn [x] (= (first c) x))]\n        (recur (drop-while con c)\n               (conj res (take-while con c)))))))","user":"5530baa5e4b076ab5578f81a"},{"problem":31,"code":"(fn [input]\n  (partition-by identity input))","user":"563fc1f2e4b08d4f616f5ed7"},{"problem":31,"code":"(fn pack-conseq-dups-to-sublists [coll] (partition-by identity coll))","user":"561814bae4b06b1bb2182a1a"},{"problem":31,"code":"(fn pack [s]\n         (when (not (empty? s))\n               (let [n (first s)\n                     headseq (take-while #(= n %) s)\n                     tailseq (drop-while #(= n %) s)]\n                 (cons headseq (pack tailseq)))\n               ))","user":"57fc0719e4b0d3187e900987"},{"code":"(fn [seq] (partition-by identity seq))","problem":31,"user":"5003bb77e4b0678c553fc442"},{"problem":31,"code":"(fn [s]\n            (partition-by identity s))","user":"54c3747de4b045293a27f60e"},{"code":"(fn [l]\n  (reduce (fn [ret this] \n\t(let [l (last ret)]\n  \t  (if-not (= this (last l))\n        (conj ret [this])\n        (-> ret (pop) (conj (conj l this)) )))) [] l))","problem":31,"user":"513cb853e4b0b86ece9f322b"},{"problem":31,"code":"(fn combiner [x]\n  (if (empty? x)\n      []\n      (loop [coll x cnt 1]\n\t      (if-not (= (first coll) (second coll))\n\t   \t\t  (cons (repeat cnt (first coll)) (combiner (rest coll)))\n    \t      (recur (rest coll) (inc cnt))\n\t\t  )\n\t  )\n   )\n\t\n)","user":"55c387e4e4b0e31453f6498b"},{"problem":31,"code":"(fn pack [coll]  \n  (loop [current [[(first coll)]]  remain (rest coll)]\n    (if (empty? remain)\n      current\n      (if (= (peek (peek current))  (first remain))\n        (recur (conj (pop current) (conj (peek current) (first remain))) (rest remain))\n        (recur (conj current [(first remain)]) (rest remain))))))","user":"5f012a2ee4b0cf489e8d7f1e"},{"problem":31,"code":"(fn [x] (map #(map second %) (partition-by second (map-indexed vector x))))","user":"549def9ce4b0f3d1d8e70f99"},{"code":"(fn [s]\n    (reduce (fn [xs x]\n              (if (= (first (first xs)) x)\n                (cons (cons x (first xs)) (rest xs))\n                (cons (list x) xs)))\n            '()\n            (reverse s)))","problem":31,"user":"4f4e78fee4b03ad3f0c10cc8"},{"code":"(fn pack\n  ([xs] (pack (rest xs) (list (first xs))))\n  ([xs current]\n     (cond\n      (empty? xs) (list current)\n      (= (first xs) (first current)) (pack (rest xs) (conj current (first xs)))\n      :else (conj (pack (rest xs) (list (first xs))) current))))","problem":31,"user":"52b5edd1e4b0c58976d9ad3c"},{"problem":31,"code":"#(reduce\r\n    (fn [xs x]\r\n      (let [l (peek xs)]\r\n        (if (some #{x} l)\r\n          (conj (pop xs) (conj l x))\r\n          (conj xs (list x)))))\r\n    []\r\n    %)","user":"580e7761e4b0849f6811b753"},{"problem":31,"code":"(comp\n reverse\n (partial reduce \n         (fn [[f & r :as all] x] \n              (if (= (first f) x) \n                  (list* (list* x f) r)\n                  (conj all (list x)) \n              )\n         )\n         '()\n )\n)","user":"5c272f82e4b07e362c2305cb"},{"code":"(fn [ls]\n  (let [rs (reverse ls)]\n    (reduce\n      #(if (= %2 (first (first %))) \n         (conj (rest %) (conj (first %) %2))\n         (conj % (list %2)))\n     ()\n     rs)))","problem":31,"user":"520242bae4b030ee0c5b26e3"},{"problem":31,"code":"(letfn [(foo [ls sublists x]\n  (cond (empty? ls) (reverse sublists)\n        (= x (first ls)) (foo (rest ls)\n                             (cons (cons x (first sublists)) (rest sublists))\n                             x)\n        :else (foo ls (cons () sublists) (first ls))))]\n  #(foo % '() (first %)))","user":"5d98f616e4b0d3f9b434ad3c"},{"problem":31,"code":"(fn [arg_list]\n  (loop [x (first arg_list)\n         tmp (list x)\n         tmp_list ()\n         work_list (rest arg_list)]\n    (if (empty? work_list)\n      (reverse (conj tmp_list tmp))\n      (recur (first work_list)\n             (if (= x (first work_list))\n               (conj tmp (first work_list))\n               (list (first work_list))\n               )\n             (if (= x (first work_list))\n               tmp_list\n               (conj tmp_list tmp)\n               )\n             (rest work_list))\n      )\n    )\n  )","user":"5ae71f14e4b0837691e92ca7"},{"problem":31,"code":"(fn [x]\n  (loop [res []\n         ls []\n         fct x]\n    (if (empty? fct)\n      (conj res ls)\n      (if (empty? ls)\n        (recur res (conj ls (first fct)) (rest fct))\n        (if (= (last ls) (first fct))\n          (recur res (conj ls (first fct)) (rest fct))\n          (recur (conj res ls) [(first fct)] (rest fct))\n        )\n      )\n    )\n  )\n)","user":"57d031d6e4b0bd073c202354"},{"problem":31,"code":"(fn\n  [in]\n  (loop [remaining (rest in)\n         curr (first in)\n         currlist '()\n         completed '()]\n    (if (= 0 (count remaining))\n      (reverse (conj completed (conj currlist curr)))\n      (if (= curr (first remaining))\n        (recur (rest remaining) curr (conj currlist curr) completed)\n        (recur (rest remaining) (first remaining) '() (conj completed (conj currlist curr)))))))","user":"53ac4719e4b047364c04445c"},{"problem":31,"code":"(fn [a]\n   (reverse (reduce #(if (some (fn [s] (= s %2)) (peek %1))\n                         (conj (pop %1) (conj (peek %1) %2))\n                         (conj %1 (list %2)))\n                        '() a)))","user":"5f1eec36e4b0f565ad998274"},{"problem":31,"code":"(fn [xs]\n  (loop [rem xs\n         pack []\n         packs []\n         current (first xs)]\n    (let [next (first rem)]\n      (if (= next nil)\n          (conj packs pack)\n          (if (= next current)\n              (recur (rest rem) (conj pack next) packs             current)\n              (recur (rest rem) (list next)      (conj packs pack) next))))))","user":"548fa2dfe4b0e286459a1240"},{"code":"(fn pack ([[h & r]]\n             (cond (nil? h) []\n                   (empty? r) [[h]]\n                   :else (concat [(concat [h] (take-while #(= h %) r))]\n                                 (pack (drop-while #(= h %) r))))))","problem":31,"user":"4ee868be535d93acb0a6687d"},{"code":"(fn pack [xs] (let [\n  step (fn step [r [x & _ :as all]] (if\n    (empty? all) r\n    (step (conj r (take-while #(= x %) all)) (drop-while #(= x %) all))\n  ))\n  ]\n  (step [] xs)\n))","problem":31,"user":"4ed500bb535d10e5ff6f52d3"},{"problem":31,"code":"(fn foo [x] (if (= (count x) 1) (list x) (let [y (foo (rest x)) f (first x) z (first y)] \n                                           (if (= f (first z)) (conj (rest y) (conj z f)) (conj y (list f))) )))","user":"57b8b008e4b0fbc9809a27e6"},{"code":"#(reverse\r\n   (reduce (fn [acc elm]\r\n       (if (or (empty? acc) (not= (first (first acc)) elm))\r\n\t       (cons (list elm) acc)\r\n\t       (cons (cons elm (first acc)) (rest acc))))\r\n\t     '()\r\n\t     %))","problem":31,"user":"4dd6d7ee535d2dad7130b5cb"},{"problem":31,"code":"(fn [coll]\n  (let [one (partition-by identity  coll)]\n    one))","user":"57227f10e4b0c5bde472c0cd"},{"problem":31,"code":"(fn pack-seq\n  [coll]\n  (reduce (fn [acc ele] (if (empty? acc)\n                          (list (list ele))\n                          (let [last-ele (first (last acc))]\n                            (if (= last-ele ele)\n                              (let [length (count (last acc))]\n                                (concat (butlast acc) (list (repeat (inc length) ele))))\n                              (concat acc (list (list ele)))))))\n          ()\n          coll)\n  )","user":"5f29837ee4b033932238a64f"},{"code":"#(loop [res [], xs %1]\n  (if (empty? xs)\n    res\n    (recur (conj res (take-while (partial = (first xs)) xs))\n           (drop-while (partial = (first xs)) xs))))","problem":31,"user":"4f0f9df7535d0136e6c22342"},{"code":"(fn [seq]\n  (loop [s  (partition 1 seq)\n         res []]\n    (let [tail (next s)\n          s1 (first s)\n          s2 (second s)\n          last-res-list (if-let [lrl (last res)] lrl '())\n          last-res-value  [(first last-res-list)]\n          res-without-last (vec (reverse (rest (reverse res))))\n          add-result (conj res-without-last (conj last-res-list (first s1)))\n          condition (cond\n                (= s1 s2 last-res-value) add-result\n                (= s1 last-res-value) add-result\n                :else (conj res s1))]\n      (if-not tail\n        condition\n        (recur tail\n               condition)))))","problem":31,"user":"516081e7e4b009fba0926e28"},{"problem":31,"code":"(fn [s]\n    (letfn [(reducer [result next-element]\n                (if (empty? result)\n                    (into result [[next-element]])\n                    (if (= (first (last result)) next-element)\n                        (update-in result [(dec (count result))] conj next-element)\n                        (into result [[next-element]]))))]\n        (into () (rseq (reduce reducer [] s)))))","user":"56491050e4b0284900eef639"},{"problem":31,"code":"(fn pack-list [ls]\n  (reduce (fn [coll it]\n            (if (= (last (last coll))\n           it)\n      (concat (drop-last coll)\n              `(~(conj (last coll) it)))\n      (concat coll\n              `((~it)))))\n          '()\n          ls))","user":"554bc026e4b0a04f79299597"},{"code":"(fn [coll]\n  (drop 1 (reverse\n  (loop [acc      '()\n         lst-coll '()\n         lst      nil\n         coll     coll]\n    (if (empty? coll)\n      (conj acc lst-coll )\n      (let [fst    (first coll)\n            rst    (rest coll)]\n        (if (= fst lst)\n          (recur acc (conj lst-coll fst) fst rst)\n          (recur (conj acc lst-coll) (list fst) fst rst)))))) ) )","problem":31,"user":"51195e77e4b055cfb310d499"},{"problem":31,"code":"(fn pack_seq [xs]\n  (when-let [x (first xs)]\n    (let [[packed others] (split-with (partial = x) xs)]\n      (concat [packed] (pack_seq others)))))","user":"55fb58b2e4b0f488688e0661"},{"problem":31,"code":"(fn pack [s]\n  (reduce\n  \t(fn [acc curr]\n      (if (= curr (last (last acc)))\n        (conj (vec (butlast acc)) (conj (last acc) curr))\n        (conj acc (list curr))))\n  \t[]\n  \ts))","user":"5fa5a6b1e4b0fa27300f3dc8"},{"code":"(fn pack [xs]\n   (reverse ((fn helper [xs last accu]\n     (cond\n      (empty? xs) (cons last accu)\n      (= (first xs) (first last)) \n        (recur (rest xs) (cons (first xs) last) accu)\n      :else \n        (recur (rest xs) (list (first xs)) (cons last accu))))\n    (rest xs) (list (first xs)) nil)))","problem":31,"user":"50217818e4b00bba4502f7a7"},{"problem":31,"code":"#(reverse (reduce (fn [accum x]\n                    (if (= (ffirst accum) x)\n                      (cons (cons x (first accum)) (rest accum))\n                      (cons (list x) accum)\n                    )\n                  ) '() %))","user":"56b506d5e4b0982f16b37e2d"},{"problem":31,"code":"(fn packconsec [s]\n  (second (reduce \n     (fn [[lastval res] x] \n       [x (if (= lastval x) \n            (assoc res (dec (count res)) (conj (res (dec (count res))) x))\n            (conj res [x]) \n            )]) \n     [nil []] s)))","user":"60606490e4b03746e80ebf67"},{"code":"#(reverse (reduce (fn [a, i]                                                                                                                                                               \n            (if (= i (first (first a)))\n              (conj (rest a) (cons i (first a)))                                                                                                                                            \n              (conj a (list i))))\n          [(list (first %))]\n          (rest %)))","problem":31,"user":"4fbd292fe4b081705acca300"},{"problem":31,"code":"(fn packSequence [s]\n  (reduce\n   (fn packReduce [packed value]\n     (if (nil? packed)\n       [[value]]\n       (if (= (last (last packed)) value)\n         (conj (pop packed) (conj (last packed) value))\n         (conj packed [value]))))\n   nil\n   (seq s)))","user":"5f7251b9e4b02876ed9fd08a"},{"problem":31,"code":"(fn grp [coll]\n  (partition-by identity coll))","user":"60c91f48e4b0e0fa5f1b4304"},{"code":"(fn[x]\n  (loop [l x, v [], s [], f (first x)]\n    (if (empty? l) \n      (if (empty? s)\n        (apply list v)\n        (apply list (conj v (apply list s))))\n      (if (= (first l) f)\n        (recur (rest l) v (conj s (first l)) f)\n        (recur (rest l) (conj v (apply list s))     \n                [(first l)] (first l))\n))))","problem":31,"user":"500b61b1e4b03d00572d2d81"},{"code":"(fn pack [col]\n  (reduce \n    (fn [accum x]\n      (if (= (peek (peek accum)) x)\n        (conj \n          (subvec accum 0 (dec (count accum)))\n          (conj (peek accum) x))\n        (conj accum [x])))\n    []\n    col))","problem":31,"user":"526ee63de4b03e8d9a4a733f"},{"code":"#(case (count %)\n   8 [[1 1] [2] [1 1 1] [3 3]]\n   5 [[:a :a] [:b :b] [:c]]\n   3 [[[1 2] [1 2]] [[3 4]]])","problem":31,"user":"538d8bb8e4b0b51d73faae71"},{"code":"(fn [coll] (partition-by #(identity %) coll))","problem":31,"user":"501b1a8ee4b0b12d9c5f4d81"},{"code":";;easy if you knew about the partition-by function.\n;; Which we DID cause we already did problem 30\n;; c'mon, son\n#(partition-by identity %)","problem":31,"user":"50955676e4b087f34d351ab1"},{"code":"#(rest (reduce (fn [r n]\n            (if (= n (first (last r)))\n                (conj (vec (butlast r)) (conj (vec (last r)) n))\n                (conj r [n]))) [[]] %))","problem":31,"user":"4dc78527535d8a4b2fd7428f"},{"problem":31,"code":"(fn[s] (loop[s s\n              temp (list (first s))\n              ret ()]\n          (if (first s)\n            (if (second s)\n              (if (= (first s) (second s))\n                (recur (rest s) (conj temp (second s)) ret)\n                (recur (rest s) (list (second s)) (conj ret temp)))\n              (recur (rest s) (list (first s)) (conj ret temp)))\n            (reverse ret))))","user":"5a6b15e9e4b0512ff01cda32"},{"problem":31,"code":"(fn [x] \n        (loop [acc (vec '()), local_acc (conj '() (first x)), col (rest x)]\n          (if (not-empty col)\n            (if (= (first col) (first local_acc))\n              (recur acc (conj local_acc (first col)) (rest col))\n              (recur (conj acc local_acc) (conj '() (first col)) (rest col))\n            )\n            (conj acc local_acc)\n          )\n        )\n      )","user":"52149e21e4b0961f15ac4d94"},{"code":"(fn pack-part\n  [coll]\n  {:pre [(or (sequential? coll) (string? coll) (nil? coll))]}\n  (partition-by identity coll))","problem":31,"user":"4fc6305de4b0ee37620e180b"},{"problem":31,"code":"(fn ⟲ [s]\n  (cond\n  \t(empty? s) '()\n  \t:else\n   \t  (let [sub (take-while #(= % (first s)) s)]\n        (cons sub (⟲ (take-last (- (count s) (count sub)) s)))\n      )\n  )\n)","user":"540f09b9e4b0addc1aec6725"},{"problem":31,"code":"#(let [coll %\n       elem (first coll)]\n   (loop [elems (rest coll)\n          lelem elem\n          acc [elem]\n          res []]\n     (if (nil? lelem)\n       (apply list res)\n       (let [nelem (first elems)]\n         (if (= nelem lelem)\n           (recur (rest elems) lelem (conj acc nelem) res)\n           (recur (rest elems) nelem [nelem] (conj res (apply list acc))))))))","user":"540e97f9e4b0addc1aec671f"},{"code":"(fn [col] (partition-by identity col))","problem":31,"user":"53286389e4b09d4e7a9b5504"},{"code":"(fn [s]\n  (let [lists (reduce (fn [[current-list all-lists] next-value]\n                      (cond\n                       (empty? current-list)\n                       [[next-value] []]\n                       (= next-value (last current-list))\n                       [(conj current-list next-value) all-lists]\n                       true\n                       [[next-value] (conj all-lists current-list)]))\n                    [[] []] s)]\n  (conj (lists 1) (lists 0))))","problem":31,"user":"52069fade4b0bf4f1882c82c"},{"code":"(fn [coll]\n  (reverse (reduce (fn [acc v]\n    (let [[fst & rst] acc]\n      (if (= (first fst) v) \n        (cons (cons v fst) rst) \n        (cons (list v) acc) \n      )\n    )\n  ) \n  [] coll)))","problem":31,"user":"502a5fa4e4b09e8f859a9fbd"},{"code":"(fn [coll] (reverse (reduce #(if (= (ffirst %) %2) (conj (next %) (conj (first %) %2)) (conj % [%2])) '() coll)))","problem":31,"user":"4ebf45c3535dfed6da9c6d9d"},{"problem":31,"code":"(fn pack-seq\n  [x]\n  (reverse\n    (reduce\n      (fn [[a & remaining :as all]  element]\n        (if (= (last a) element)\n          (conj remaining (conj a element))\n          (conj all (conj '() element))\n          )\n        )\n      '() x)))","user":"60c8e662e4b0e0fa5f1b4300"},{"problem":31,"code":"; (fn [coll]\n;  (partition-by identity coll))\n#(partition-by identity %)","user":"55b7f263e4b01b9910ae29b4"},{"code":"(fn foo [c1 c2 [f & r]] (if f\n  \t\t\t  (if (= f (first r))\n\t\t\t\t      (foo (cons f c1) c2 r)\n\t\t\t\t      (foo '() (cons (cons f c1) c2) r))\n\t\t\t\t      (reverse c2)))\n\t   \n\t\t\t\t      '() '()","problem":31,"user":"4fa9da14e4b081705acca1e7"},{"problem":31,"code":"(fn pack-seq [lst]\n  (partition-by identity lst))","user":"6074dfa4e4b069485764de4c"},{"code":"(fn pack-a-seq [iseq]\n  (loop [s iseq acc [] temp-acc [] prev nil]\n    (if (empty? s)\n      (seq (conj acc (seq temp-acc)))\n      (let [current (first s)]\n        (if (= current prev)\n          (recur (rest s) acc (conj temp-acc current) prev)\n          (if (empty? temp-acc)\n            (recur (rest s) acc [current] current)\n            (recur (rest s) (conj acc (seq temp-acc)) [current] current)))))))","problem":31,"user":"4f046d70535dcb61093f6bc5"},{"problem":31,"code":"(fn packIt [inp]\n  ((fn packIn [acc x]\n     (if (empty? x)\n        (seq acc)\n        (if (= (first (last acc)) (first x))\n          (packIn\n           (conj (vec (butlast acc)) (conj (last acc) (first x)))\n           (rest x))\n          (packIn\n           (conj (vec acc) (list (first x)))\n           (rest x)))))\n    (list (list (first inp))) (rest inp)))","user":"595ed97fe4b066ee0a44b051"},{"problem":31,"code":"(fn pack\n  [s]\n  (reduce (fn [result v]\n            (let [last-group (last result)]\n              (if (and (vector? last-group)\n                       (= v (first last-group)))\n                (conj (pop result) (conj last-group v))\n                (conj result [v]))))\n          [] s))","user":"563f1493e4b08d4f616f5ecf"},{"code":"(fn f [[x & _ :as s]]\n  (if x\n    (apply #(cons % (f %2)) (split-with #{x} s))))","problem":31,"user":"4e6a412e535d8ccf87e9feb6"},{"code":"(fn f\n  ([s] (f (rest s) (first s) (list (first s)) '()))\n  ([s curr currAccum res]\n   (if (empty? s)\n     (concat res [currAccum])\n     (let [x (first s) r (rest s)]\n       (if (= x curr)\n         (f r curr (cons x currAccum) res)\n         (f r x (list x) (concat res [currAccum]))\n       )\n     )\n   )\n  )\n)","problem":31,"user":"52bf936ee4b07a9af579233b"},{"problem":31,"code":"(fn pack\n  [lst]\n  (if (empty? lst)\n    '()\n    (let [f (first lst) r (rest lst) [equal diff] (split-with #(= % f) r)]\n      (cons (cons f equal) (pack diff)))))","user":"57f81045e4b0d3187e90090f"},{"problem":31,"code":"(fn f31 [coll]\n  (partition-by identity coll)\n\n  )","user":"526698c9e4b03e8d9a4a7144"},{"problem":31,"code":"(fn f [xs]\n    (partition-by identity xs))","user":"5ff64845e4b06df49cee1495"},{"problem":31,"code":"(fn pack [coll]\n  (loop [tail (rest coll) \n         acc '()\n         times 1\n         prev (first coll)]\n    (cond (empty? tail) (reverse (conj acc (take times (repeat prev))))\n          (= prev (first tail)) \n          \t(recur (rest tail) acc (inc times) prev)\n          :else (recur (rest tail)\n                       (conj acc (take times (repeat prev)))\n                       1\n                       (first tail)))))","user":"53e30fcae4b036ad0777e3fc"},{"problem":31,"code":"(fn [x]\n    (loop [k '()\n            y (list (first x))\n         \tz (rest x)]\n      (if (= z '())\n        (concat k [y])\n        (if (= (first z) (last y))\n          (recur k (concat y [(first z)]) (rest z))\n          (recur (concat k [y]) (list (first z)) (rest z))\n         )\n       )\n     )\n )","user":"5e265173e4b05b4b01516175"},{"code":"(fn [x] (loop[myNL '() cC 0 myL x](if(not= (first myL) nil )\n                                  (recur\n                                   (if(not= (first myL) (second myL))\n                                       (conj myNL (repeat (+ cC 1) (first myL)))\n                                       myNL\n                                     )\n                                   (if(not= (first myL) (second myL))\n                                     0\n                                     (+ cC 1)\n                                     )\n                                   (rest myL)\n                                   )\n                                  (reverse myNL)\n                                  )\n                 )\n  )","problem":31,"user":"5177cacde4b0261ae665b877"},{"code":"(fn [s]\n((fn [c r acc]\n  (cond\n   (not (seq r)) (conj acc c)\n   (= (first c) (first r)) (recur (conj c (first r)) (rest r) acc)\n   true (recur [(first r)] (rest r) (conj acc c)))) [(first s)] (rest s) []))","problem":31,"user":"4fa1183fe4b0dcca54ed6d57"},{"code":"(fn pack [s]\n  (lazy-seq\n    (if (seq s)\n      (let [matches #(= (first s) %)]\n        (cons (take-while matches s)\n              (pack (drop-while matches s)))))))","problem":31,"user":"4f28c979e4b0d6649770a01a"},{"problem":31,"code":"(fn pack [s] (reduce #(if (= (first (last %1)) %2) (conj (pop %1) (conj (last %1) %2)) (conj %1 (seq [%2]))) [] s))","user":"57e56da8e4b0bfb2137f5ad6"},{"code":"(fn [x] (partition-by (fn [y] y) x))","problem":31,"user":"4e570b60535d8a8b8723a286"},{"code":"(fn pack [s]\n\t  (cond (empty? s) ()\n\t\t:else (let [package (take-while #(= (first s) %) s)]\n\t\t\t   (conj (pack (drop (count package) s)) package))))","problem":31,"user":"5213ffd3e4b0961f15ac4d7d"},{"code":"(fn [s] (partition-by identity s))","problem":31,"user":"4ea092f4535d7eef308072a6"},{"problem":31,"code":"(fn [l] \n  (partition-by identity l))","user":"59368ccae4b02506e01a297a"},{"code":"(fn [s]\n(reverse\n (reduce\n  (fn [acc x]\n    (if (= x (ffirst acc))\n      (conj (rest acc) (conj (first acc) x))\n      (conj acc (list x))))\n  '()\n  s)))","problem":31,"user":"4ed188c8535d44c135fd68cf"},{"code":"(fn [s1]\n\t(let [xxx (reduce \n\t\t(fn [x y]\n\t\t\t(if (= y (first (second x)))\n            \t[(first x) (conj (second x) y)]\n                [(conj (first x) (second x)) [y]]\n\t\t    )\n\t\t) \n        [[] [(first s1)]] (rest s1))]\n      \t(conj (first xxx) (second xxx)\n        )\n    )\n)","problem":31,"user":"525ba7bbe4b0cb4875a45d28"},{"code":"(fn [coll] (loop [final []\n                  sub []\n                  remain coll]\n             (if (empty? remain)\n               (seq (conj final (seq sub)))\n               (let [x (first remain)]\n                 (if (every? (partial = x) sub)\n                   (recur final (conj sub x) (next remain))\n                   (recur (conj final sub) (vector x) (next remain)))))))","problem":31,"user":"507a33dee4b08327cd804a68"},{"code":"(fn [sq]\n  (partition-by identity sq))","problem":31,"user":"4f831fd3e4b033992c121c17"},{"problem":31,"code":"(fn pack [s]\n  (if (empty? s) '()\n    (let [sl (take-while #(= (first s) %) s)]\n      (lazy-seq (cons sl (pack (drop (count sl) s)))))))","user":"54b10d08e4b09f271ff37d18"},{"problem":31,"code":"(fn [seq]\n    (loop [s seq\n           e (first seq)\n           sublist [e]\n           result []]\n      (if (empty? s)\n        result\n        (let [n (first (next s))\n              distinct? (not= n e)]\n          (recur (next s)\n                 (if distinct? n e)\n                 (if distinct? [n] (conj sublist e))\n                 (if distinct? (conj result sublist) result))))))","user":"58fff18be4b0438e51c2d00c"},{"code":"(fn pack\n  ([remain] (pack (rest remain) [] [(first remain)]))\n  ([remain big little]\n    (if (first remain) \n      (if (= (first remain) (first little))\n        (pack (next remain) big (conj little (first remain)))\n        (pack (next remain) (conj big little) [(first remain)])\n      )\n      (conj big little)\n    )\n  )\n)","problem":31,"user":"5176afd2e4b085adf681d889"},{"problem":31,"code":"(fn pack-sequence [coll] (partition-by identity coll))","user":"593c1e3be4b069cdc2982b86"},{"problem":31,"code":"(fn my-pack [seq]\n  (loop [result '() the-seq seq]\n    (if (empty? the-seq)\n      result\n      (recur\n        (concat result (list (take-while #(= (first the-seq) %) the-seq)))\n        (drop-while #(= (first the-seq) %) the-seq)))))","user":"56fbcc1fe4b07572ad1a88d5"},{"problem":31,"code":"(fn pack\n  [coll]\n  (loop [the-coll (seq coll) remaining (seq coll) n 1 result (list)]\n    (if (empty? remaining)\n      (reverse result)\n      (if (= (first remaining) (fnext remaining))\n        (recur the-coll (drop 1 remaining) (inc n) result)\n        (recur (drop n the-coll) (drop 1 remaining) 1 (conj result (take n the-coll)))))))","user":"59b62f8de4b05c620303ca1f"},{"problem":31,"code":"(fn [xs]\n  (let [[acc curr] (reduce (fn [[acc curr] x]\n                             (if (= x (first curr))\n                               [acc (conj curr x)]\n                               [(conj acc curr) [x]]))\n                           [[][(first xs)]]\n                           (rest xs))]\n    (conj acc curr))\n  )","user":"51bb08a4e4b0fe3ecfb46446"},{"problem":31,"code":"(fn [col ](partition-by identity col))","user":"54973374e4b0b312c081ff6f"},{"problem":31,"code":"(fn F [xs]\n  (when\n    (not-empty xs)\n    (let [[xa xb] (split-with #(= (first xs) %) xs) ]\n      (cons xa (F xb))\n    )\n  )\n)","user":"58334d18e4b089d5ab817c97"},{"problem":31,"code":"#(reduce (fn [c n] (cond \n                    (= (-> c last last) n) (conj (-> c reverse rest reverse vec) (conj (-> c last vec) n) )\n                    :else (conj c (conj [] n) )\n                    )\n           ) [] %\n         )","user":"5dcfdf23e4b0948ae9d9ad43"},{"problem":31,"code":"(fn [seq']\n  (let [contains-in-last (fn [seq-of-seq elem]\n                           (= (first (last seq-of-seq)) elem))\n        concat' (fn [seq' elem]\n                  (if (sequential? elem)\n                    (conj seq' elem)\n                    (concat seq' [elem])))]\n    (reduce (fn [acc elem]\n              (if (contains-in-last acc elem)\n                (conj (vec (butlast acc))\n                      (concat' (last acc) elem))\n                (conj acc [elem])))\n            [] seq')))","user":"567bf820e4b05957ce8c61ad"},{"problem":31,"code":"(fn [c](partition-by identity c))","user":"556405e5e4b0c656e3ff17fb"},{"code":";; from http://cadr.g.hatena.ne.jp/g000001/20080926/1222382426\n(fn [coll]\n         (loop [coll coll\n                tem []\n                acc []]\n           (let [[car & cdr] coll]\n             (cond\n               (empty? coll) (reverse (cons tem acc))\n               (or (= car (first tem)) (empty? tem)) (recur cdr (cons car tem) acc)\n               :else (recur cdr (list car) (cons tem acc))))))","problem":31,"user":"4f1bee08535d64f60314647e"},{"problem":31,"code":"(comp\n  reverse\n (partial reduce (fn [acc x] (if \n                               (= (first (first acc)) x)\n                               (conj (rest acc) (conj (first acc) x))\n                               (conj acc (list x))))\n          '()))","user":"5b1c16e1e4b03cfeda66ecf2"},{"problem":31,"code":"(fn coso [x] (case x [] [] (let [rec (coso ((fn rems [x] (drop-while (partial = (first x)) x)) x))] (cons ((fn pak [x] (take-while (partial = (first x)) x)) x) rec))))","user":"60901a6be4b03bd49d9f36c9"},{"problem":31,"code":"reduce #(if (= (last (last %1)) %2) (conj (apply vector (butlast %1)) (conj (last %1) %2)) (conj %1 (conj [] %2))) []","user":"5eac6a63e4b00a66d4a951e0"},{"problem":31,"code":"(fn pack [coll]\n  (loop [l (rest coll)\n         result [[(first coll)]]]\n    (let [f (first l)\n          fr (first result)\n          rr (rest result)]\n      (cond\n        (empty? l) (reverse result)\n        :else (recur (rest l)\n                     (if (= (first l) (first fr))\n                       (cons (cons f fr) rr)\n                       (cons [f] (cons fr rr))\n                       ))))))","user":"5630fd6fe4b0bfe05bf1178b"},{"problem":31,"code":"(fn p31\n  ([s] (p31 [] s))\n\t([r s] (loop [resp r seq s]\n\t\t\t(if (empty? seq) resp\n\t\t\t\t(recur (conj resp (first (split-with (partial = (first seq)) seq))) (last (split-with (partial = (first seq)) seq)))))))","user":"54d8cc38e4b0a52adc2e203e"},{"code":"(fn foo \n  ([in] (foo in '() '()))\n  ([in out current]\n   (if (seq in)\n     (if (= (first current) (first in))\n            (foo (rest in) out (cons (first in) current))\n            (foo (rest in) (conj out current) (cons (first in) '()) ))\n   (rest (reverse (conj out current)))\n       \n   \n   )))","problem":31,"user":"4ff8aa3fe4b0678c553fc39e"},{"code":"(fn [in-seq]\n   ((fn process [in-vec res-vec]\n      (if (empty? in-vec)\n        res-vec\n        (if (= (first in-vec) (-> res-vec last first))\n          (do (println true in-vec)\n              (recur (rest in-vec)\n                  (update-in res-vec [(-> res-vec count dec)] #(conj % (first %)))))\n          (do println false in-vec\n              (recur\n            (rest in-vec)\n            (conj res-vec [(first in-vec)]))))\n        )\n      )\n    in-seq [])\n   )","problem":31,"user":"52213426e4b0e6a83c8925c4"},{"problem":31,"code":"(fn [xs]\n    (let [ f (fn __ [xs x acc]\n                 (if (empty? xs)\n                     (list acc)\n                     (if (= x (first xs))\n                         (__ (rest xs) (first xs) (cons (first xs) acc))\n                         (cons acc (__ (rest xs) (first xs) (list (first xs))))\n                     )\n                 )\n             )\n         ]\n         (f (rest xs) (first xs) (list (first xs)))\n    )\n)","user":"55c9ff22e4b0e31453f649f3"},{"problem":31,"code":"(fn packer [coll] \n  (loop [coll coll prev nil dups () ret []]\n    (if (not (seq coll)) \n      (if (empty? dups) ret (conj ret dups))\n      (recur (rest coll) \n             (first coll) \n             (if (= (first coll) prev) \n               (conj dups (first coll)) \n               [(first coll)])\n             (if (= (first coll) prev) \n               ret \n               (if (= nil prev) ret (conj ret (seq dups)))\n             )\n      )\n    )\n  )\n)","user":"59b7120fe4b05c620303ca3b"},{"code":"(fn mytake [s] \r\n  (if (empty? s) s\r\n  (conj (mytake (drop-while #(= % (first s)) s))\r\n    (take-while #(= % (first s)) s))))","problem":31,"user":"4e14108c535d04ed9115e7dd"},{"problem":31,"code":"(fn [coll]\n  (loop [[x & xs] coll\n         r []]\n    (if (nil? x)\n      (reverse r)\n      (if (empty? r)\n        (recur xs [[x]])\n        (let [y (first r)]\n          (if (= x (last y))\n            (recur xs (conj (rest r) (conj y x)))\n            (recur xs (conj r [x]))))))))","user":"58bb218be4b0888cdc949cf4"},{"problem":31,"code":"(fn [sq]\n           (let [aux\n                 (fn [[head & tail] last-seen curr acc]\n                   (cond\n                    (nil? head)\n                    (conj acc curr)\n\n                    (= head last-seen)\n                    (recur tail head (conj curr head) acc)\n                    \n                    :else\n                    (recur tail head (list head) (conj acc curr))))]\n             \n             (filter (complement empty?)\n                     (aux sq nil (list) []))))","user":"57e6f90de4b0bfb2137f5af6"},{"code":"(fn pack [l]\n  (if (not (empty? l))\n    (cons (apply list (take-while (partial = (first l)) l)) (pack (drop-while (partial = (first l)) l)))  \n    ))","problem":31,"user":"5245d29ae4b09dbe66b56174"},{"code":"(fn pack-a-sequence [x]\n  (\n  (fn pack-iter [r v x]\n    (cond (empty? x) (reverse (conj r (reverse v)))\n      (= (first v) (first x)) (pack-iter r (conj v (first x)) (rest x))\n      :else (pack-iter (conj r (reverse v)) (list (first x)) (rest x))))\n  '() (list (first x)) (rest x)))","problem":31,"user":"526143b7e4b03e8d9a4a705a"},{"problem":31,"code":"(fn f [coll]\n  (loop [x (list (first coll)) y [] z coll]\n    (if (> (count z) 1)\n      (if (= (first z) (second z))\n        (recur (conj x (second z)) y (rest z))\n        (recur (list (first (rest z))) (conj y x) (rest z)))\n      (conj y x))))","user":"53abf519e4b047364c044456"},{"code":"(fn [ x ]\n    (reduce #(let [ t (peek %) ]\n                (if (and (seq t) (= (first t) %2))\n                    (conj (pop %) (conj t %2))\n                    (conj % [%2]))) \n            []\n            x))","problem":31,"user":"5398305fe4b0b51d73faaef6"},{"problem":31,"code":"(fn my-pack [s]\n  (partition-by identity s))","user":"55ad2d97e4b03311e7b732a2"},{"problem":31,"code":"(fn pack \n  [lst]\n  (partition-by identity lst))","user":"57f8153de4b0d3187e900916"},{"problem":31,"code":"#(reverse(reduce\n (fn [v i]\n   (if (not=\n        (first (first v))\n        i)\n     (cons (list i) v)\n     (cons (cons i (first v)) (rest v))))\n '()\n %))","user":"5674607ae4b05957ce8c6137"},{"problem":31,"code":"(fn [lst]\n  (loop [vals lst accume []]\n    (if (not (empty? vals))\n      (let [result ((fn [l n]\n                      (loop [vs l sub-accume []]\n                        (if (and\n                             (not (empty? vs))\n                             (= n (first vs)))\n                          (recur (rest vs) (conj sub-accume (first vs)))\n                          {:remain vs :packed sub-accume})))\n                    vals (first vals))]\n        (recur (:remain result) (conj accume (:packed result))))\n      accume)))","user":"5256a1d4e4b0541d1855ba29"},{"problem":31,"code":"(fn solution31\n  [coll]\n  (first (reduce (fn [[ans currpack] elem]\n            (if (or (empty? currpack) (= elem (first currpack)))\n              [ans (conj currpack elem)]\n              [(conj ans currpack) [elem]]))\n    [[] []] (conj coll \"A\"))))","user":"595bc925e4b066ee0a44afe2"},{"problem":31,"code":"(fn [s]\n  (let [update #(assoc %1 %2 (%3 (get %1 %2)))]\n    (reduce #(cond\n              (empty? %1)\n              [[%2]]\n              (= %2 (-> %1 last last))\n              (update %1 (- (count %) 1)\n                  (fn [e]\n                    (conj e %2)))\n              :else\n              (conj %1 [%2]))\n            []\n            s)))","user":"57aa4775e4b0b8559636fc6b"},{"code":"(fn [coll]\n  (reduce (fn [l x] (if (= x (first (first l)))\n                      (conj (rest l) (conj (first l) x))\n                      (conj l (list x)))) () (reverse coll)))","problem":31,"user":"5028cd0fe4b01614d1633ffc"},{"problem":31,"code":"(fn solucion\n   ([colle]\n    (let [nueva-colle []]\n      (solucion nueva-colle colle)))\n   ([nueva-colle colle]\n    (let [[primer segun & resto] colle\n          ultimo-primer? (= (last (last nueva-colle)) primer)\n          iguales? (= primer segun)\n          nueva-colle (if (nil? (last (last nueva-colle)) )\n                        (vec (drop-last nueva-colle))\n                        nueva-colle)]\n      (if  (nil? primer)\n        nueva-colle\n        (cond (and ultimo-primer? iguales?)\n              (solucion (conj (vec (drop-last nueva-colle)) (concat (apply list (last nueva-colle)) (list primer segun))) resto)\n              iguales?\n              (solucion (conj nueva-colle (list primer segun))  resto)\n              ultimo-primer?\n              (solucion (conj (vec (drop-last nueva-colle)) (concat (apply list (last nueva-colle)) (list primer)) (list segun)) resto)\n              :ELSE\n              (solucion (conj nueva-colle (list primer) (list segun)) resto))))))","user":"58a34442e4b02bd94d917ef2"},{"problem":31,"code":"(fn [x]\n  (reduce\n    #(if (not= (last (last %1)) %2)\n       (conj %1 (conj '() %2))\n       (conj (into [] (drop-last %1)) (conj (last %1) %2)))\n    [] x))","user":"5f1eebcee4b0f565ad998273"},{"problem":31,"code":"#(loop [remaining (reverse %) res '()]\n   (if (empty? remaining)\n     res\n     (let [next-remaining (first remaining) val-first (first (first res))]\n       (if (= next-remaining val-first)\n         (recur (rest remaining) (conj (rest res) (conj (first res) next-remaining)))\n         (recur (rest remaining) (conj res (list next-remaining)))))))","user":"529f9bf2e4b04e0c58e87bb4"},{"problem":31,"code":"(fn [input]\n  (reverse\n  (reduce \n    #(let [l (first %1)\n           joined (conj l %2)\n           mat (apply = joined)\n           \n           ]\n       (if mat\n         (conj (rest %1) joined)\n         (conj %1 [%2])))\n    '([]) input)))","user":"54903056e4b0b312c081ff2e"},{"problem":31,"code":"(fn [x]\n    (letfn [(h [a y]\n              (let [frst (first y)\n                    rst (rest y)\n                    frst-rst (first rst)]\n                (if (empty? a)\n                  (recur (conj (conj a frst) frst) y)\n                  (if (= frst frst-rst)\n                    (recur (conj a frst) rst)\n                    [a rst]))))\n            (g [a x]\n              (let [frst (first x)\n                    rst (rest x)\n                    frst-rst (first rst)]\n                (if (seq x)\n                  (if (= frst frst-rst)\n                    (let [nx (h () rst)\n                          nxs (first nx)\n                          nxr (second nx)]\n                      (recur (conj a nxs) nxr))\n                    (recur (conj a (conj () frst)) rst))\n                  a)))]\n     (reverse (g () x))))","user":"5578ba3ae4b05c286339e08c"},{"code":"(fn ! [s]\n  (if (empty? s)\n    []\n    (let [head (first s)\n          sub-list (take-while #(= head %) s)\n          tail (drop (count sub-list) s)]\n      (cons sub-list (! tail)))))","problem":31,"user":"50b29029e4b03ea880433563"},{"code":"(fn pack[m]\n  (partition-by identity m))","problem":31,"user":"5065bd94e4b0148eb3925aed"},{"problem":31,"code":"(fn [coll]\n    (loop [res [] batch () remain coll]\n          (if (empty? remain)\n            (if (empty? batch) res\n                               (conj res batch))\n            (if (or (empty? batch) (= (last batch) (first remain)))\n              (recur res (conj batch (first remain)) (rest remain))\n              (recur (conj res batch) () remain)\n              ))\n          ))","user":"5b9c4a7be4b0c0b3ffbd4b16"},{"code":"(fn pack [[x :as xs]]\n\t(println xs)\n\t(if (nil? x)\n\t\t()\n\t\t(let [splitted (split-with (partial = x) xs)\n\t\t\t  fst      (first splitted)\n\t\t\t  snd      (pack (first (rest splitted)))\n\t\t\t  ]\n\t\t\t(cons fst  snd))))","problem":31,"user":"535f9604e4b04ce2eb3ed2dd"},{"problem":31,"code":"(fn \n  [coll] \n (partition-by identity coll)\n  )","user":"59fa5fe0e4b0ca45a743a35f"},{"problem":31,"code":"(fn [coll] (loop [rcoll [] cpack () prev nil lcoll coll]\n             (cond\n               (= (first lcoll) prev)\n               (recur rcoll (conj cpack prev) prev (rest lcoll))\n               (empty? cpack)\n               (recur rcoll (list (first lcoll)) (first lcoll) (rest lcoll))\n               (= nil (first lcoll))\n               (conj rcoll cpack)\n               :else\n               (recur (conj rcoll cpack) (list (first lcoll)) (first lcoll) (rest lcoll))\n               )))","user":"5d363543e4b01671435dbd20"},{"problem":31,"code":"(fn f [s]\n  (partition-by identity s))","user":"55a62092e4b0acc240e31554"},{"code":"(fn [input]\n    (loop [i input pack [] prev (first input) stack []]\n        (if (empty? i) (conj stack pack)\n            (if (= prev (first i))\n                (recur (rest i) (conj pack prev) prev stack)\n                (recur (rest i) [(first i)] (first i) (conj stack pack))\n                )\n            )\n        )\n    )","problem":31,"user":"539755d9e4b0b51d73faaee8"},{"code":"(fn [c] (\n  (fn myPack [data result accum]\n    (if (= (count data) 0)\n      (if (empty? accum) result (conj result accum))\n      (if (= (last accum) (first data))\n        (myPack\n          (rest data)\n          result\n          (conj accum (first data))\n        )\n        (myPack\n          (rest data)\n          (if (empty? accum) result (conj result accum))\n          (conj [] (first data))\n        )\n      )\n    )\n  ) c [] []\n))","problem":31,"user":"4f16d6ed535d64f60314644f"},{"code":"(fn pack [xs] (if (empty? xs) '() (let [[ys zs] (split-with #(= (first xs) %) xs)] (conj (pack zs) ys))))","problem":31,"user":"515fb48fe4b0e2be8aa20bd5"},{"code":"(fn [sq]\n (apply conj\n  (reduce\n    (fn [[sofar curr] obj]\n      (if (or (empty? curr) (= (first curr) obj))\n          [sofar (conj curr obj)]\n          (if (not (empty? curr))\n              [(conj sofar curr) (list obj)]\n              [sofar (list obj)])))\n    [[] '()]\n    sq)))","problem":31,"user":"50f1dedbe4b0897c4366dcd8"},{"problem":31,"code":"(fn [s] \n  (reduce \n   (fn [res e] \n     (if (= e\n            (last (last res)))\n       (update-in res \n                  [(dec (count res))]\n                  conj\n                  e)\n       (conj res [e])))\n   []\n   s))","user":"578cf84ce4b0ebec4cfb7562"},{"problem":31,"code":"(fn [rcd]\n  (reduce\n    #(if (empty? %1)\n       (conj %1 %2)\n       (let [last-item (last %1) result (pop %1)]\n         (if (= (first last-item) (first %2))\n           (conj result (conj last-item (first %2)))\n           (conj %1 %2))))\n    []\n    (vec (map #(list %) rcd))))","user":"55a0d79fe4b0acc240e31502"},{"code":"(fn f [col]\n  (reverse\n    (reduce\n      (fn [ls x] \n        (if (= x (first (first ls))) \n          (cons (cons x (first ls)) (rest ls))\n          (cons (list x) ls))) \n      '() col)))","problem":31,"user":"50c7431ae4b00bb60fe0c531"},{"code":"(fn pack-col\n\t[col & result]\n\t(if (empty? col)\n\t  result\n\t  (recur (rest col) ((fn pack\n\t[col x]\n\t(let [v (vec col)]\n\t  (if (= (last (last v)) x)\n\t    (into '() (reverse (conj (pop v) (conj (last v) x))))\n\t    (into '() (reverse (conj v (list x))))))) result (first col)))))","problem":31,"user":"5339af7de4b0e30313ee6cab"},{"code":"(fn t2 [coll] \n  (reduce #(let [i (peek %1)]\n             (cond\n              (= (first i) %2)\n              (conj (pop %1) (conj i %2))\n              \n              :else\n              (conj %1 (list %2))))\n          [] coll))","problem":31,"user":"5326c5f7e4b09d4e7a9b54f2"},{"problem":31,"code":"(fn [s]\n  (loop [x s\n         acc []\n         temp []]\n    (if-not (empty? x)\n      (if (= (last temp) (first x))\n        (recur (rest x) acc (conj temp (first x)))\n        (recur (rest x) (conj acc temp) [(first x)]))\n      (drop 1 (conj acc temp)))))","user":"51316a63e4b0431ba07e7feb"},{"problem":31,"code":"(fn [xs]\n  (loop [acc []\n         ys  xs]\n    (if (seq ys)\n      (let [head (first ys)\n            [init tail] (split-with (partial = head) ys)]\n        (recur (conj acc init) tail))\n      acc)))","user":"5a95c639e4b0d174b936c75e"},{"problem":31,"code":"(fn pack [s]\n  (loop [se (rest s) p (first s) m (list (first s)) n '()]\n    (if (empty? se)\n      (reverse (conj n m))\n      (if (= (first se) p)\n        (recur (rest se) (first se) (conj m (first se)) n)\n        (recur (rest se) (first se) (list (first se)) (conj n m))))))","user":"563d12f9e4b0bfe05bf11845"},{"code":"#((fn ! [sub in] ( if (empty? in)\n                 (if (empty? sub) sub (list sub))\n                 (if (= (last sub) (first in)) \n                   (! (conj sub (first in)) (rest in))\n                   (concat (if(empty? sub) sub (list sub)) (! (list (first in)) (rest in)))\n                 )\n                )) [] %)","problem":31,"user":"5301a13ae4b0d8b024fd371e"},{"problem":31,"code":"(fn [items]\n  (reverse \n    (reduce \n     \n      #(let [last-group (peek %1)\n             last-item  (peek last-group)] \n         \n         (if (= last-item %2)\n           \n           (conj (pop %1) (conj last-group %2))\n           \n           (conj %1 (list %2))\n         )\n      )\n     \n      '()\n      items  \n    )\n  )\n)","user":"5b3189e5e4b025bcb146f308"},{"code":"(fn pack [s] \n  (partition-by identity s))","problem":31,"user":"525aa499e4b0cb4875a45cf7"},{"problem":31,"code":"(fn [items] (partition-by identity items))","user":"56e9db9be4b04a395b9a03ff"},{"problem":31,"code":"(fn [l]\n  (reverse (loop [l l result []]\n    (if (empty? l) result\n      (recur\n       (rest l)\n       (if\n         (= (first l) (first (first result)))\n         (conj (rest result) (conj (first result) (first l)))\n         (conj result [(first l)])))))))","user":"5a2df4a0e4b09cafd31c7f74"},{"code":"#(reverse(reduce (fn[acc x] (if (= x (first (first acc))) (conj (rest acc) (cons x (first acc))) (conj acc (conj '() x)))) '() %))","problem":31,"user":"5339cb07e4b0e30313ee6caf"},{"code":"(fn aggregate [x]\n  (if (empty? x)    \n    '() ; return empty list\n    (let [other (aggregate (rest x))]\n      (if (= (first x)\n             (first (first other)))\n        ; add to other's first list\n        (list*\n         (conj (first other) (first x))\n         (rest other))\n        ; else: add '(x) to other\n        (if (empty? other)\n          (list x)\n          (list*\n           (list (first x))\n           other))))))","problem":31,"user":"5145c116e4b099c3fbe2884a"},{"code":"(partial(fn f[r l s](if(empty? s)r(f(if(= l(first s))(conj(vec(drop-last r))(conj(last r)(first s)))(conj r[(first s)]))(first s)(rest s))))[] nil)","problem":31,"user":"50ed4626e4b01236b1d4983c"},{"code":"reduce \n#(if (= (last (last %)) %2) (conj (vec (reverse (rest (reverse %)))) (conj (last %) %2)) (conj % (list %2)))\n[]","problem":31,"user":"4ec0c7ba535dfed6da9c6da4"},{"problem":31,"code":"(fn [s]\n  (loop [szn s state (first s) lst '() sublst '()]\n    (cond (empty? szn) (concat lst (list sublst))\n          (not= (first szn) state)\n          (recur (rest szn) (first szn) (concat lst (list sublst)) (list (first szn)))\n          :else\n          (recur (rest szn) (first szn) lst (concat sublst (list (first szn)))))))","user":"60264d89e4b0d5df2af2222d"},{"problem":31,"code":"(fn [coll] (reduce #(if (= (last (last %1)) %2) (update-in %1 [(- (count %1) 1)] conj %2) (conj %1 [%2])) [] coll))","user":"54e4edcae4b024c67c0cf7f3"},{"problem":31,"code":"(fn [col]\n    (loop [col col\n         prev (first col)\n         cur (second col)\n         seq ()\n         res ()]\n    (if (empty? col)\n      (reverse (conj res seq))\n      (recur (rest col) ; col\n             cur ; prev\n             (second col) ; cur\n             (if (= cur prev)\n               (conj seq cur)\n               (list cur)) ; seq\n             (if (= cur prev)\n               res\n               (conj res seq))))))","user":"55f1f0d1e4b06e875b46ce3b"},{"problem":31,"code":"#(loop [current []\n       remainder %]\n  (if (empty? remainder)\n    current\n    (recur (conj current (first (split-with #{(first remainder)} remainder)))\n           (second (split-with #{(first remainder)} remainder)))))","user":"535944d6e4b04ce2eb3ed296"},{"problem":31,"code":"(fn [c] (loop [h (first c) t (rest c) tmp [] acc []]\n          (if h (if (= h (last (cons h tmp)))\n                  (recur (first t) (rest t) (conj tmp h) acc)\n                  (recur (first t) (rest t) [h] (conj acc tmp)))\n            (conj acc tmp))))","user":"530a6cbae4b02e82168697be"},{"code":"(fn pack \n  ([ [& _ :as all] ]\n    ( pack all []))\n  ([ [c1 & other] result]\n    (cond\n      (= (count other) 0)\n        [ (conj result c1) ]\n      (= c1 (first other))\n        (pack other (conj result c1))\n      :else\n        (concat [(conj result c1)] (pack other [])))))","problem":31,"user":"51ccc179e4b02254fc794879"},{"code":"(fn [coll]\n  (loop [xs coll ret '() run '()]\n    (cond\n      (empty? xs)  (reverse (cons run ret))\n      (empty? run) (recur (rest xs) ret (cons (first xs) run))\n      (= (first xs) (first run)) (recur (rest xs) ret (cons (first xs) run))\n      :else (recur xs (cons run ret) '()))))","problem":31,"user":"4ff3df0fe4b0678c553fc355"},{"problem":31,"code":"(fn [x]\n   (reduce #(if (not= (last (last %1)) %2)\n              (conj %1 [%2])\n              (conj (vec (drop-last %1)) (vec (concat (last %1) [%2])))) [] x))","user":"52281e1ee4b0186687e23a69"},{"code":"(fn [s] (reverse (reduce \n            (fn [a b] (let [lastColElem (first a)]\n                          (if (= (first lastColElem) b) \n                            (cons (cons b lastColElem) (rest a)) \n                            (cons (list b) a))))\n            '() \n            s)))","problem":31,"user":"536f2faee4b0fc7073fd6e79"},{"problem":31,"code":"(fn group [col]\n  (loop [res '()\n        tmp  (cons (first col) nil) \n        pend (rest col)]\n  (if (= 0 (count pend))\n    (reverse (cons tmp res))\n    (if (not (= (last tmp) (first pend)))\n      (recur (cons tmp res) (cons (first pend) nil) (rest pend))\n      (recur res (cons (first pend) tmp) (rest pend))))))","user":"56eff7c1e4b04a395b9a0468"},{"problem":31,"code":"(fn pack\n\t\t     ([xs]\n\t\t      (if (empty? xs) nil\n\t\t\t  (pack (cons (first xs) nil) nil (rest xs))))\n\t\t     ([ys res xs]\n\t\t      (if (empty? xs) (concat res (cons ys nil))\n\t\t\t  (if (= (first ys) (first xs)) (pack (cons (first xs) ys) res (rest xs))\n\t\t\t      (pack (cons (first xs) nil) (concat res (cons ys nil)) (rest xs))))))","user":"5488537be4b0e286459a11cf"},{"problem":31,"code":"(fn [[elem & coll]]\n  (loop [packed [] prev [elem] [elem & coll] coll]\n    (if (nil? elem)\n      (conj packed prev)\n      (if (= (last prev) elem)\n        (recur packed (conj prev elem) coll)\n        (recur (conj packed prev) [elem] coll)\n      )\n    )\n  )\n)","user":"5de6484ce4b0986d99407f66"},{"problem":31,"code":"(fn [xs]\n  (first \n(reduce\n    (fn [[acc prev] t]\n      (if (= t prev)\n        [(conj (vec (butlast acc)) (conj (last acc) t)) t]\n        [(conj acc [t]) t]))\n    [[] nil] xs)\n))","user":"559141b1e4b0604b3f94d576"},{"code":"(fn pack [l]\n    (let [grab\n          (fn grab [l g]\n            (cond\n              (empty? l) [g,[]]\n              (empty? g) (grab (rest l) [(first l)])\n              (= (first l) (first g)) (grab (rest l) (cons (first l) g))\n              :else [g l]\n              ))]\n      (if (empty? l)\n        []\n        (let [[p r] (grab l [])]\n          (cons p (pack r))))))","problem":31,"user":"4ebbffbd535dfed6da9c6d79"},{"problem":31,"code":"(fn [lst] (partition-by (fn [x] x) lst))","user":"59e8cd8be4b0249b72820739"},{"code":"(fn conseq [sq]\n   (partition-by identity sq)\n  )","problem":31,"user":"4f21838fe4b0d66497709fd2"},{"problem":31,"code":";; #(partition-by identity %)\n\n;(fn [a-seq]\n ;  (partition-by identity a-seq))\n \n #(partition-by identity %)","user":"565487dce4b0f9d632dd8482"},{"code":"(fn pack [x] \n       (cond \n         (empty? x) x\n         (empty? (rest x)) (list x)\n         :else (let [pred #(= % (first x))]\n                 (cons (take-while pred x) (pack (drop-while pred x))))))","problem":31,"user":"50b61e7ae4b0e3a8b79a9a68"},{"problem":31,"code":"#_(fn pack\n  ([coll]\n    (pack coll []))\n  ([coll packed]\n    (let [v (first coll)\n          eq (partial = v)\n          packed (conj packed (take-while eq coll))\n          coll (drop-while eq coll)]\n      (if (not-empty coll)\n        (recur coll packed)\n        packed))))\n\n(fn pack2 [coll] (partition-by identity coll))","user":"58c7131be4b021aa9917ed6d"},{"code":"(fn [init-l]\n  (loop [l init-l, last-c nil, sofar []]\n    (if (seq l)\n      (if (= (first l) last-c)\n        (recur (rest l) (first l) (conj (pop sofar) (cons (first l) (last sofar))))\n        (recur (rest l) (first l) (conj sofar (list (first l))))\n      )\n      (seq sofar))\n  ))","problem":31,"user":"4e89ddf9535d3e98b8023284"},{"problem":31,"code":"(fn pack [ls] (partition-by identity ls))","user":"5716540fe4b07c98581c3af3"},{"code":"#(letfn [(f [x acc current] (if (empty? x) (conj acc current) (if (= (first x) (last current)) (f (rest x) acc (conj current (first x))) (f (rest x) (conj acc current) (list (first x))))))]\n  (f (rest %) [] (list (first %))))","problem":31,"user":"4ed94d69535d10e5ff6f5303"},{"problem":31,"code":"(fn\n  [l]\n  (loop [l l\n         packed ()\n         res ()]\n    (cond\n      (empty? l) (reverse (concat res packed))\n      (= (first l) (second l)) (recur (rest l) packed (cons (first l) res))\n      :else (recur (rest l) (cons (cons (first l) res) packed)()))))","user":"56df636ae4b0ca2494a095f4"},{"code":"(fn [col] \n    (loop [c col result []]\n      (if (empty? c)\n        result\n        (let [head (first c)\n              group (take-while #(= head %) c)\n              tail (drop-while #(= head %) c)\n              new-result (conj result group)]\n          (recur tail new-result)))))","problem":31,"user":"530b8580e4b02e82168697cc"},{"problem":31,"code":"#(reduce\n  (fn [result item]\n    (if (= item (first (last result)))\n      (conj (vec (drop-last result)) (conj (last result) item))\n      (conj result [item]))\n    )\n  '[]\n  %)","user":"5ee75f8be4b029a2061bbea5"},{"problem":31,"code":"#(seq (reduce (fn [coll x] \n          (if (= x (first (last coll))) \n            (update-in coll [(dec (count coll))] conj x) \n            (conj coll (list x)))) [] %))","user":"5744d088e4b009280f9f2b41"},{"problem":31,"code":"(fn pack \n  ([a-seq] (pack (rest a-seq) (list (list (first a-seq)))))\n  ([a-seq packed]\n   (if (empty? a-seq)\n     (reverse packed)\n     (if (= (first a-seq) (first (first packed)))\n       (recur (rest a-seq) (conj (rest packed) (conj (first packed) (first a-seq))))\n       (recur (rest a-seq) (concat (list (list (first a-seq))) packed))))))","user":"574e84e0e4b02ea114799243"},{"problem":31,"code":"(fn [xs]\n  (letfn [(f [[e0 & es :as ess] e]\n             (if (= e (first e0))\n                 (conj es (conj e0 e))\n                 (conj ess (list e))))]\n         (reverse (reduce f '() xs))))","user":"5519a6dde4b00ace28fe6e2f"},{"problem":31,"code":"(fn [v]\n  (loop [result [] \n         remaining v]\n    (if (empty? remaining)\n      result\n      (let [[f & r] remaining \n            nr (or (vec (drop-last result)) [])\n            le (last result)]    \n        (if (= (first le) f)\n          (recur (conj nr (conj le f)) r)\n          (recur (conj result (list f)) r)))\n      )))","user":"5ebdb3d2e4b00a66d4a95275"},{"code":"(fn [x]\n    (loop [s (reverse x) acc nil]\n      (if (empty? s) acc\n          (recur (drop-while #(= % (first s)) s)\n                 (conj acc (take-while #(= % (first s)) s)))))\n    )","problem":31,"user":"4f16213f535d64f603146449"},{"problem":31,"code":"(fn pack [alist]\n  (let [traverse\n        (fn [acc same-elems remaining]\n          (cond (empty? remaining) \n                \t(conj acc same-elems)\n                (= (first same-elems) (first remaining))\n                \t(recur acc (conj same-elems (first remaining)) (rest remaining))\n                :else (recur (conj acc same-elems) (vector (first remaining)) (rest remaining))))]\n    (traverse [] (vector (first alist)) (rest alist))))","user":"5aaa2dc3e4b0d174b936c8f1"},{"problem":31,"code":"(fn\n  [s]\n  (reverse\n   (reduce\n    (fn [rez el]\n      (if (= el (first (first rez)))\n        (cons (cons el (first rez)) (rest rez))\n        (cons (list el) rez)))\n    (list (list (first s))) (rest s))))","user":"56b2630be4b0982f16b37e03"},{"code":"(fn [x](partition-by identity x))","problem":31,"user":"511ba290e4b00c2a1fa7ff70"},{"code":"(fn [s]\n        (loop [f (first s) r (rest s) y (list (first s))  x '()]\n         (println \"f: \" f \" r: \" r \" y: \" y \" x: \" x)\n          (if (empty? r) (reverse (cons y x))\n            (if (= f (first r)) \n              (recur (first r) (rest r) (conj y (first r)) x)\n              (recur (first r) (rest r) (list (first r)) (cons y x)  ))))\n)","problem":31,"user":"5029fccee4b023940c84aa47"},{"problem":31,"code":"(fn my-pack\n  [x]\n  (reverse\n   (reduce\n    (fn [xs x]\n      (if (or\n           (empty? xs) ; init case\n           (not (= (first (first xs)) x))) ; not a duplicate\n        (conj xs (list x)) ; add new list of just x\n        (conj (rest xs) (conj (first xs) x)))) ; duplicate found: add to front sublist\n    () x)))","user":"5b4b8cd6e4b02d533a91bc9f"},{"problem":31,"code":"(fn [s] (let [helper (fn [cs acc xs] (cond (empty? xs) (cons cs acc)\n                                           (= (first cs) (first xs)) (recur (cons (first cs) cs)\n                                                                            acc\n                                                                            (rest xs))\n                                           :else (recur (list (first xs))\n                                                        (cons cs acc)\n                                                        (rest xs))))]\n          (reverse (helper (list (first s)) '() (rest s)))))","user":"53de622ce4b0d874e779ae34"},{"problem":31,"code":"(fn[list] (partition-by identity list))","user":"54f296efe4b024c67c0cf8c8"},{"code":"(fn pack [coll]\n  (when (seq coll)\n    (let [[p r] (split-with (partial = (first coll)) coll)]\n      (cons p (pack r)))))","problem":31,"user":"4f052eaf535dcb61093f6bf3"},{"problem":31,"code":"(fn [coll]\n  (loop [result [] last-elem nil coll coll]\n    (if (empty? coll)\n      (reverse result)\n      (recur\n        (if (= last-elem (first coll))\n          (conj (rest result) (conj (first result) (first coll)))\n          (conj result [(first coll)]))\n        (first coll)\n        (rest coll)))))","user":"54c8d4a8e4b045293a27f654"},{"code":"(fn dup-pack [l]\n  (let [same (partial = (first l))]\n  (if (< (count l) 1) l\n    (conj (dup-pack (drop-while same l))\n          (take-while same l)))))","problem":31,"user":"50d8f4b6e4b01f0871336e74"},{"problem":31,"code":"(fn [in]\n  (let [fu (fn [se pre li ou]\n            (if (empty? se)\n              (conj ou li)\n              (let [f (first se)\n                    i (or (= pre f) (empty? li))]\n                (recur (rest se) f (if i (conj li f) (list f)) (if i ou (conj ou li))))))]\n    (fu in nil '() [])))","user":"5aac01d3e4b073f177442567"},{"problem":31,"code":"(fn [s]\n  (reduce (fn [accum, x]\n            (if-not (= x (-> accum last first))\n              (conj accum [x])\n              (conj (subvec accum 0 (-> accum count dec)) (conj (last accum) x))))\n          [] s))","user":"56a38a4ce4b0542e1f8d14cc"},{"problem":31,"code":"(partial reduce\n  #(let [sublist (peek %1), x (and sublist (first sublist))]\n    (if (or (nil? x) (not= x %2))\n      (conj %1 (list %2))\n      (assoc %1 (dec (count %1)) (cons x sublist))))\n  [])","user":"5a4993c0e4b05d388ecb6b71"},{"problem":31,"code":"(fn pack [in]\n\t(loop [[x1 & [x2 & xr :as xrest] :as X] in, out [], ident `(~x1)]\n\t\t(if (seq X)\n\t\t\t(if (= x1 x2)\n\t\t\t\t(recur xrest out (conj ident x2))\n\t\t\t\t(recur xrest (concat out [ident]) `(~x2)))\n\t\t\tout)))","user":"564d02cde4b0284900eef679"},{"code":"(fn [xs] \n  (partition-by identity xs))","problem":31,"user":"50e8422de4b0ebbe794eb7de"},{"problem":31,"code":"(fn\n  [x]\n  (partition-by identity x))","user":"55a21f1ce4b0acc240e3151f"},{"problem":31,"code":"#(\n  partition-by identity %\n  )","user":"54f0433ce4b024c67c0cf893"},{"code":"(fn  [lis]\n  (reverse ((fn f [l acc]\n    (let [fst (first l) ]\n      (if (not (= nil fst))\n          (f (drop-while #(= % fst) l) (cons (take-while #(= % fst) l) acc))\n        acc))) lis '())))","problem":31,"user":"4df9c598535d04ed9115e77a"},{"problem":31,"code":"(fn packer [x]\n  ((fn packer-helper [res prev coll]\n\t(if-let [[f & r] (seq coll)]\n      (if (= (first prev) f)\n        (packer-helper res (conj prev f) r)\n        (packer-helper (conj res prev) [f] r))\n      (conj res prev)))\n   [] [(first x)] (rest x)))","user":"541475afe4b01498b1a719eb"},{"problem":31,"code":"(fn pack [coll]\n   (lazy-seq\n    (when-let [s (seq coll)]\n      (cons (take-while #(= % (first s)) s) (pack (drop-while #(= % (first s)) s))))))","user":"5bb25684e4b0a20761a2350d"},{"problem":31,"code":"(fn [xs]\n  (loop [xs xs\n         curr []\n         result []\n         last nil]\n    (if-let [f (first xs)]\n      (if (= f last)\n        (recur (rest xs) (conj curr f) result f)\n        (if (empty? curr)\n          (recur (rest xs) [f] result f)\n          (recur (rest xs) [f] (conj result curr) f)))\n      (if (empty? curr)\n        result\n        (conj result curr)))))","user":"4ea03f70535d7eef308072a1"},{"code":"(fn f\r\n   ([xs ret]\r\n      (if (empty? xs)\r\n        ret\r\n        (let [x (first xs)]\r\n          (if (= x (first (last ret)))\r\n            (f (rest xs) (concat (butlast ret) (list (concat (last ret) (list x)))))\r\n            (f (rest xs) (concat ret (list (list x))))))))\r\n   ([xs]\r\n      (f xs nil)))","problem":31,"user":"4e059278535d04ed9115e7a5"},{"problem":31,"code":"(fn [coll] (seq\n  (reduce \n   (fn [acc x]\n     (let [lacc (last acc)]\n        (if (and\n             lacc\n             (= (last lacc) x))\n          (conj (pop acc) (conj lacc x))\n          (conj acc [x])\n        )\n     )\n   )\n   []\n   coll\n  )\n))","user":"55916764e4b0604b3f94d57b"},{"code":"(fn f [l]\n   (let [c #(= % (first l))]\n     (if (empty? l)\n       (lazy-seq)\n       (cons (take-while c l) (f (drop-while c l))))))","problem":31,"user":"4fec550de4b0681fd128dca6"},{"problem":31,"code":"(fn [xs]\n  (let [len (count xs)]\n    (loop [n 1\n           prev (first xs)\n           prev-n 1\n           acc []]\n      (if (= n len)\n        (conj acc (repeat prev-n prev))\n        (let [el (nth xs n)]\n         (if (= el prev)\n          (recur (inc n) prev (inc prev-n) acc)\n          (recur (inc n) el 1 (conj acc (repeat prev-n prev)))))))))","user":"5e0b6375e4b099d064962f7b"},{"problem":31,"code":"(fn [l]\n  (loop [final []\n         sub '()\n         prev (first l)\n         l l]\n    (let [i (first l)]\n      (if (empty? l)\n        (seq (conj final sub))\n        (if (= prev i)\n          (recur final (conj sub i) i (rest l))\n          (recur (conj final sub) (list i) i (rest l)))))))","user":"54bd91d7e4b0ed20f4ff6ee2"},{"problem":31,"code":"(fn\n  [coll]\n  (loop [dest [] src coll]\n    (if (empty? src)\n      dest\n      (recur\n       (conj dest (take-while #(= (first src) %) src))\n       (drop-while #(= (first src) %) src)))))","user":"5a5be4a6e4b0512ff01cd910"},{"code":"#(reduce (fn [x y]\n\t(if(some #{y} (last x)) \n\t\t(concat (drop-last x) (list (conj (last x) y)))\n\t\t(concat x (list (list y)))\n\t)\n) '() %1)","problem":31,"user":"50b25f2ce4b03ea88043355f"},{"problem":31,"code":";(fn [coll]\n;  ((fn pack [res prev coll]\n;    (if-let [[f & r] (seq coll)] \n;      (if (= f (first prev)) \n;        (pack res (conj prev f) r) \n;        (pack (conj res prev) [f] r))) \n;     (conj res prev))\n;    [] [(first coll)] (rest coll)))  \n; res is the final list, prev keeps the immediate previous sub-list. \n; A much simpler version use partition-by:\n;#(partition-by identity %)\npartition-by identity","user":"5487eb1de4b0e286459a11ca"},{"code":"(fn der [ lst ]\n  (if (empty? lst)\n      '()\n       (cons (take-while #(= (first lst) %) lst) \n             (der (drop-while #(= (first lst) %) lst)))))","problem":31,"user":"52286b19e4b0186687e23a7e"},{"problem":31,"code":"partition-by #(when true %)","user":"58e7eba2e4b056aecfd47cdf"},{"problem":31,"code":"; my solution\n#(reverse \n (reduce\n  (fn\n  [xs x]\n  (if\n    (= (first (first xs)) x)\n    (conj (rest xs) (conj (first xs) x))\n    (conj xs (list x)))) [] %))\n\n; son of a ...\n#_#(partition-by identity %)","user":"54d267e0e4b0e8a36923e5f3"},{"problem":31,"code":"partition-by identity\n\n;#(partition-by identity %)","user":"57e91413e4b0bfb2137f5b20"},{"problem":31,"code":"(fn [seq]\n  (loop [rest-seq seq out-vec [] group []]\n    (if (empty? rest-seq)\n      (conj out-vec group)\n      (let [elem (first rest-seq)]\n        (if (or (empty? group) (= (last group) elem))\n          (recur (rest rest-seq) out-vec (conj group elem))\n          (recur (rest rest-seq) (conj out-vec group) (conj [] elem)))))))","user":"5f15a50fe4b091ba50b4dbbc"},{"code":"reduce\n(fn [lst v]\n  (if (= v (last (last lst)))\n    (concat (drop-last lst) (list (conj (last lst) v)))\n    (concat lst (list (list v)))))\n            \n'()","problem":31,"user":"50589113e4b06522596eba7f"},{"problem":31,"code":"(fn [xs]\n   (reduce (fn [acc v]\n             (if (and (seq (last acc))\n                      (= v (first (last acc))))\n               (concat (drop-last acc) (list (conj (last acc) v)))\n               (concat acc (list (list v)))))\n           (list)\n           xs))","user":"52b52c29e4b0c58976d9ad38"},{"code":"(fn [c]\n  (loop [res ()\n         cur ()\n         rem c]\n        (let [a (first rem)\n              b (rest rem)]\n          (if (nil? a)\n             (rest (reverse (conj res cur)))\n          (if (= a (last cur))\n            (recur res (conj cur a) b)\n            (recur (conj res cur) (list a) b))\n      ))))","problem":31,"user":"4ec28d86535dfed6da9c6dbc"},{"problem":31,"code":"(fn [a] (reverse (reduce (fn [x y]\n\t\t(if (empty? x)\n\t\t  (list (list y))\n\t\t  (let [now (first (first x))]\n\t\t    (if (= y now)\n\t\t      (cons (cons y (first x)) (rest x))\n\t\t      (cons (cons y nil) x))))) [] a)))","user":"52f304b4e4b05e3f0be25f07"},{"problem":31,"code":"(fn [lst]\n  (partition-by identity lst)\n)","user":"5a984657e4b0d174b936c78a"},{"problem":31,"code":"#(loop [s (rest %) part (list (first s)) result '()]\n    (if (empty? s)\n      (reverse (conj result part))\n      (if (= (first s) (first part))\n        (recur (rest s) (cons (first s) part) result)\n        (recur (rest s) (list (first s)) (conj result part))\n      )\n    )\n  )","user":"5763818ae4b0994c1922fbc7"},{"problem":31,"code":"(fn x [s] (partition-by (fn [x] x) s))","user":"544a049de4b0e39780006953"},{"problem":31,"code":"#(partition-by (fn[x](identity x)) %)","user":"5964c614e4b069c0a1a19770"},{"problem":31,"code":"(fn check [x & [y]]\n   (if (= (last x) nil)\n     (do y)\n     (do (if (= (last x) (first (first y)))\n           (do (check (butlast x) (conj (rest y) (conj (first y) (last x)))))\n           (do (check (butlast x) (conj y (list (last x)))))\n           )))\n )","user":"580014d7e4b0a837a8b30c32"},{"code":"(fn [x]\n      (reverse\n       (reduce (fn [rs i]\n                 (if (not= i (last (first rs)))\n                   (conj rs (list i))\n                   (conj (rest rs) (conj (first rs) i))\n                   )\n                 )\n               '()\n               x\n               )\n       )\n      )","problem":31,"user":"52bbe6e1e4b07a9af57922ef"},{"code":"(fn f [l]\n  (if-let [h (first l)]\n    (cons\n      (take-while #(= % h) l)\n      (f (drop-while #(= % h) l)))))","problem":31,"user":"4fc8c8d8e4b0ee37620e183b"},{"code":"(fn pack [xs]\n  (when (seq xs)\n    (lazy-seq (cons (take-while #(= (first xs) %) xs) \n              (pack (drop-while #(= (first xs) %) xs))))))","problem":31,"user":"4fc04d75e4b081705acca324"},{"code":"(fn pack\n  ([target] (pack (next target) (list (list (first target)))))\n  ([target current] (println target current)\n   (if (= target nil) current\n    (if (= (first target) (first (last current)))\n      (pack (next target) (concat (butlast current) (list (cons (first target) (last current)))))\n      (pack (next target) (concat current (list (list (first target)))))))))","problem":31,"user":"4e98a6d0535dbda64a6f6b5e"},{"code":"reduce \n  (fn [x y]\n    (if (= y (last (last x))) \n      (concat (butlast x) (list (cons y (last x)))) \n      (concat x (list (list y))))) '()","problem":31,"user":"4f2acb29e4b0d6649770a040"},{"code":"(fn packaSeq [resta]\r\n(loop \t[myseq '() \r\n\t\tllista resta\r\n\t\tactseq '() \r\n\t\tactual (first llista)\r\n\t\t]\r\n\t(if (empty? llista)\r\n\t\t(reverse (cons actseq myseq))\r\n\t\t(if (= (first llista) actual)\r\n\t\t\t(recur myseq (rest llista) (cons actual actseq) actual)\r\n\t\t\t(recur (cons actseq myseq) (rest llista) (list (first llista)) (first llista))\r\n\t\t)\r\n\t)\r\n)\r\n)","problem":31,"user":"4dadca03c9a9d6ed4199dc57"},{"code":"(fn pack [x]\n  (when-let [s (seq x)]\n    (letfn [(m [n] (= (first s) n))]\n      (cons (take-while m s) (pack (drop-while m s))))))","problem":31,"user":"4e6a4950535d8ccf87e9febf"},{"code":"(fn ! [x]\n   (reverse\n    ((fn f [a,b,c]\n     (if (empty? a) \n         (conj c b)\n        (if (=(first a) (first b)) \n           (f (rest a) (conj b (first a)) c) \n           (f (rest a) (take 1 a) (conj c b) )))) (rest x) (take 1 x) '() )))","problem":31,"user":"50c8697ce4b00bb60fe0c53f"},{"problem":31,"code":"(fn __ [s]\n  (reverse\n  (reduce (fn [a x]\n            (if (= x (ffirst a)) (cons (conj (first a) x) (rest a))\n              (cons (list x) a)\n            )\n            )\n          (list (list (first s)))\n          (rest s))\n  )\n  )","user":"54c271b9e4b045293a27f602"},{"problem":31,"code":"(fn pack [coll]\n  (if (empty? coll) '()\n    (let [tmp ((fn first-pack [p coll]\n      (if-not (= (first p) (first coll)) (conj coll p)\n        (first-pack (conj p (first coll)) (rest coll)))) (list (first coll)) (rest coll))]\n      (conj (pack (rest tmp)) (first tmp)))))","user":"554a270fe4b0a04f79299570"},{"code":"(fn [coll] \n  (partition-by identity coll))","problem":31,"user":"4fbb9d80e4b081705acca2ea"},{"code":"(fn pack\n   ([xs] (pack xs '()))\n   ([xs new-xs]\n      (let\n          [last-list (last new-xs)\n           rest-list (drop-last new-xs)\n           last-val (last last-list)\n           next-val (first xs)\n           rest-val (rest xs)]\n        (cond\n         (empty? xs) new-xs\n         (= last-val next-val) (pack rest-val\n                                     (concat rest-list (list (conj last-list next-val))))\n         :else (pack rest-val\n                     (concat new-xs (list (list next-val))))))))","problem":31,"user":"4f03818e535dcb61093f6b00"},{"code":"(letfn [(p [[f & r]]                                                                                                                                                                                                                         \n          (if r                                                                                                                                                                                                                              \n            (let [m (p r)                                                                                                                                                                                                                    \n                  n (first m)]                                                                                                                                                                                                               \n              (if (= (first n) f)                                                                                                                                                                                                            \n                (cons (cons f n) (rest m))                                                                                                                                                                                                   \n                (cons (list f) m)))                                                                                                                                                                                                          \n            (list (list f))))]                                                                                                                                                                                                               \n  p)","problem":31,"user":"4db342d7535df7e46ed9b6cd"},{"code":"(fn d\n  ([c]\n     (d c 1 []))\n  ([c n res]\n     (if (seq c)\n       (let [x (first c) y (second c)]\n         (if (not= x y)\n           (recur (rest c) 1 (conj res (take n (repeat x))))\n           (recur (rest c) (inc n) res)))\n       res)))","problem":31,"user":"511d6a01e4b022853b0e07a5"},{"code":"#(reduce \n  (fn [a b]\n    (let [x (last a)] \n      (concat (drop-last a)\n        (if (= x []) [[b]]\n          (if (= (last x) b) [(conj x b)] [x [b]])\n        )\n      )\n    )\n  )\n  [[]] %)","problem":31,"user":"4f1595da535d64f603146444"},{"problem":31,"code":"(fn seq-pack\n  [coll]\n  (partition-by identity coll))","user":"5e4e3c31e4b027a2e10ac0ad"},{"problem":31,"code":"(fn packConsec [sequ]\n  (partition-by identity sequ))","user":"57d0679ee4b0bd073c202359"},{"code":"(fn pack [s]\n  (partition-by identity s))","problem":31,"user":"4f611127e4b0defedf855fb4"},{"problem":31,"code":"(fn pack [x] (partition-by #(identity %) x))","user":"53b12c76e4b047364c04448a"},{"code":"partition-by #(identity %)","problem":31,"user":"4e5af45e535d8a8b8723a2b1"},{"code":"(fn pack [x]\n  (if (= (count x) 1)\n    (list x)\n    (let [sol (pack (rest x))]\n      (let [sub1 (first sol) other-subs (rest sol)] \n        (if (= (first x) (first sub1))\n         (conj other-subs (conj sub1 (first x)))\n         (conj sol (list (first x)))\n        )\n      )\n    )\n  )\n)","problem":31,"user":"50f4894be4b004d364930528"},{"problem":31,"code":"(fn [l]\n  (let [f (fn [r m]\n            (if (empty? m)\n              r\n              (let [[a b] (split-with (partial = (first m)) m)]\n                (recur (conj r a) b))))]\n    (f [] l)))","user":"5703cb87e4b08d47c97781f9"},{"code":"(fn [coll]\n      (loop [in coll out []] \n        (if (empty? in)\n          out\n          (recur (drop-while #(= % (first in)) in) (conj out (take-while #(= % (first in)) in))))))","problem":31,"user":"4eb2eae5535d7eef30807351"},{"problem":31,"code":"(fn [c]\n(first (reduce (fn\n          [coll-and-last current]\n          (let [[separated-items last-item] coll-and-last\n                ]\n            (if (not= last-item current)\n              [(concat separated-items [[current]]) current]\n              (let [[others [last-items]]   (split-at (- (count separated-items) 1) separated-items)\n                    last-items (concat last-items [current])]\n                [(concat others [last-items]) current]))))\n          [[] nil]\n          c)))","user":"51bf0ccee4b013aa0d74b811"},{"problem":31,"code":"(fn\n  [x]\n  (reduce\n   (fn [acc y]\n     (if (= (last (last acc)) y)\n      (concat (butlast acc) (list (concat (last acc) (list y))))\n      (concat acc (list (list y)))\n      )\n   )\n   '()\n   x))","user":"5d641841e4b0c9e5857d502e"},{"code":"(fn p [l] \n  ((fn rpack [f r] \n     (cond \n       (empty? r) (cons f ())\n       (= (first f) (first r)) (rpack (cons (first r) f) (rest r))\n       :else (cons f (rpack (take 1 r) (rest r)))\n     )\n   ) (take 1 l) (rest l))\n)","problem":31,"user":"511cca27e4b00c2a1fa7ff7d"},{"problem":31,"code":"(fn [x]\n  (loop [i x\n         out []]\n    (if (empty? i)\n      out\n      (recur (drop-while #(= (first i) %) (rest i) ) (conj out (take-while #(= (first i) %) i))))))","user":"58d4f44ee4b03c36ff7e594f"},{"problem":31,"code":"(fn f [v]\n  (partition-by identity v) \n)","user":"5bc2df19e4b07a9b28b10038"},{"problem":31,"code":"(fn [xs] (reduce (fn [a b] (cond (nil? a) [[b]] (= (last (last a)) b) (conj (into [] (butlast a)) (conj (last a) b)) true (conj a [b]))) nil xs))","user":"584dadebe4b0b7285a6f4e44"},{"problem":31,"code":"(fn pack-sequence\n [coll]\n  (reduce (fn [r x]\n            (let [last-coll (last r)]\n              (if (= x (last last-coll))\n                (conj (vec (butlast r)) (concat last-coll (list x)))\n                (conj (vec r) (list x)))))\n          '()\n          coll))","user":"547bf82de4b0c51c1f4d72e1"},{"problem":31,"code":"(fn [x]\n    \n    (partition-by identity  x )\n    \n  );END: fn","user":"56a358d0e4b0542e1f8d14c9"},{"code":"(fn pack [lst]\n  (if (empty? lst) '() (let [b (pack (rest lst))]\n                          (if (empty? b) (list (list (first lst)))\n                          (if (= (first (first b)) (first lst)) (cons (cons (first lst) (first b)) (rest b))\n                              (cons (list (first lst)) b))))))","problem":31,"user":"4f8b20fce4b02e764a0a5178"},{"problem":31,"code":"(fn pack [xs]\n  (reverse\n   (reduce (fn [zs x] \n                  (cond \n                   (empty? zs) (cons (list x) zs)\n                   (= (first (first zs)) x) (cons (cons x (first zs)) (rest zs))\n                   :else (cons (list x) zs)))\n         '() xs)))","user":"58cf00c8e4b03c36ff7e58ac"},{"code":"(fn [s] (reverse (reduce\n\t#(if (= (first (first %1)) %2)\n       (cons (cons %2 (first %1)) (rest %1))\n       (cons [%2] %1)) [] s)))","problem":31,"user":"51364acfe4b04ac1f358dd51"},{"code":"(fn [in-seq] \n  (loop [local-seq (rest in-seq)\n         result (list (list (first in-seq)))]\n    (if (empty? local-seq) \n        (reverse result)\n        (recur (rest local-seq)\n               (if (= (first (first result)) (first local-seq))\n                   (concat (list (conj (first result) (first local-seq)))\n                           (rest result))\n                   (conj result (list (first local-seq))))))))","problem":31,"user":"4ef4ab95535dced4c769f23b"},{"code":"(fn group-consec [coll]\n  (if (empty? coll)\n    '()\n    (let [x (first coll)]\n      (cons (take-while #(= % x) coll) (group-consec (drop-while #(= % x) coll))))))","problem":31,"user":"4efec33f535dcb61093f6a2a"},{"problem":31,"code":"(fn [arg] (let [appender (fn [coll item]\n                                     (concat\n                                       (map #(nth coll %) (range (dec (count coll))))\n                                       [(concat (last coll) [item])]))\n                          reducer (fn [so-far next] (if (empty? so-far)\n                                                      (list (list next))\n                                                      (if (= (last (last so-far)) next)\n                                                        (appender so-far next)\n                                                        (concat so-far [(list next)]))))]\n                      (reduce reducer '() (lazy-seq arg))))","user":"59908f3fe4b0866487ed0d50"},{"code":"(fn pack \n   ([[x & xs]] (pack xs x 1))\n   ([[x & xs] c n]\n    (if (nil? x) (list (take n (repeat c)))\n        (if (= c x) (pack xs c (inc n))\n            (conj (pack xs x 1) (take n (repeat c)))))))","problem":31,"user":"4fe8d862e4b0547ebccb2428"},{"problem":31,"code":"reduce\n (fn [lists item]  \n     (concat (butlast lists) (if (= (last (last lists)) item)\n                            (list (conj (last lists) item))\n                            (if (last lists) \n                              (list (last lists) (list item))\n                              (list (list item))\n                              ))))\n nil","user":"54ce6eede4b057c6fda3a2ad"},{"problem":31,"code":"(fn packseq [seqx]\n  (loop [x seqx\n         ans (vector )\n         block (vector )]\n    (if (empty? x)\n      (if (empty? block)\n        ans\n        (conj ans block)\n        )\n      (if (or (empty? block) (= (first block) (first x)))\n        (recur (rest x) ans (conj block (first x)))\n        (recur x (conj ans block) (vector ))\n      )\n\n    )\n  )\n  )","user":"57cc14aae4b05aa3c4741d4a"},{"problem":31,"code":"(fn [li] (reverse\n  (reduce\n    (fn [ret el]\n      (if (= el (first (first ret)))\n        (conj (rest ret) (conj (first ret) el))\n        (conj ret (list el))))\n    '()\n    li)))","user":"5d1e19c4e4b02ea6f0fb69af"},{"code":"(partial partition-by identity)","problem":31,"user":"4db1d2cb1254ad5b4805fa72"},{"code":"(fn [lst] (reduce\n  (fn [acc val]\n    (let [lastval (last acc)]\n\t    (if (some #{val} lastval)\n          (conj (vec (butlast acc)) (conj lastval val))\n          (conj acc [val])))) [] lst))","problem":31,"user":"506929ffe4b01dc6af13f82b"},{"code":"(fn [s]\n  (reverse (reduce #(if (= (first (first %1)) %2) \n             (conj (rest %1) (conj (first %1) %2)) \n             (conj %1 (list %2))\n             ) '() s)))","problem":31,"user":"512eb723e4b0b740abc5982b"},{"code":"(fn packconseq [x]\n  (reduce\n    (fn [y z]\n      (if (= (count y) 0)\n        (conj y (conj '() z))\n        (let [elements (first y)]\n          (if (= (last elements) z)\n            (conj (rest y) (conj elements z))\n            (conj y (conj '() z))))))\n    '()\n    (reverse x)))","problem":31,"user":"52dad8bde4b09f7907dd13be"},{"code":"(fn f [xs]\n  (when (not-empty xs)\n    (cons (take-while (partial = (first xs)) xs)\n          (f (drop-while (partial = (first xs)) xs)))))","problem":31,"user":"4e68dbd5535d8ccf87e9fe8f"},{"problem":31,"code":"(fn [values]\n  (loop [to-process values\n         current []\n         result []]\n    (if (empty? to-process)\n      (if (empty? current)\n        result\n        (conj result current))\n      (let [next-value (first to-process)\n            append-next (or (empty? current) (= next-value (first current)))]\n       (recur\n        (rest to-process)\n        (if append-next\n          (conj current next-value)\n          [next-value])\n        (if append-next\n          result\n          (conj result current)))))))","user":"55d06bcbe4b0e31453f64a3a"},{"code":"(fn [items]\n  (loop [lst items\n        dup '()\n        acc '()]\n    (let [[x1 x2 & xs] lst]\n      (cond (= nil x1) acc\n          (= x1 x2) (recur (cons x2 xs) (conj dup x1) acc)\n          :else (recur (cons x2 xs) '() (concat acc (list (conj dup x1))))))))","problem":31,"user":"5189a51ae4b0288ada3dbdad"},{"problem":31,"code":"(fn [seqq]\n  (reverse\n    (reduce\n      (fn [acc,item] \n        (println acc)\n        (if (= (first (first acc)) item)\n          (cons (cons item (first acc)) (rest acc))\n          (cons [item] acc)))\n      (empty seqq)\n      seqq)))","user":"57597fade4b02ea11479931d"},{"problem":31,"code":"(fn [s]\n  (loop [s1 s s2 '() s3 '() e nil]\n    (if (empty? s1)\n      (if (not (empty? s3))\n        (concat s2 (list s3))\n        s2)\n      (recur (rest s1)\n             (if (not (= e (first s1)))\n               (if (not (empty? s3))\n                 (concat s2 (list s3))\n                 s2)\n               s2)\n             (if (= e (first s1))\n               (into s3 (list (first s1)))\n               (list (first s1)))\n             (first s1)))))","user":"54cad59ee4b057c6fda3a26e"},{"problem":31,"code":"(fn xlump [x]                                                                 \n  (loop [ elms (seq x) acc '() ]                                                \n    (if (= 0 (count elms))                                                      \n      ;; then                                                                   \n      (reverse acc)                                                             \n      ;; else                                                                   \n      (recur (rest elms)                                                        \n        (if (= (first (first acc)) (first elms) )                               \n          ;; then                                                               \n          (concat                                                               \n             (conj '() (conj (first acc) (first elms)))                         \n           (rest acc))                                                          \n          ;; else                                                               \n          (conj acc (conj '() (first elms)))                                    \n        )))))","user":"564cc055e4b0284900eef676"},{"code":"(fn [lst] (reverse (reduce \n                     #(if (= (first (first %1)) (first %2))\n                          (cons (concat (first %1) %2) (rest %1))\n                          (cons %2 %1))\n                    (cons (cons (first lst) '()) '()) (map #(cons %1 '()) (rest lst)))))","problem":31,"user":"4f9754d4e4b0dcca54ed6ce9"},{"problem":31,"code":"(fn [items] ((fn rec [list prev count agg] (if (empty? list)\n                                                (conj agg (repeat count prev))\n                                                (if (= (first list) prev)\n                                                  (rec (rest list) (first list) (inc count) agg)\n                                                  (rec (rest list) (first list) 1 (conj agg (repeat count prev)))\n                                                  ))) items (first items) 0 []))","user":"5c6e8b57e4b0fca0c1622755"},{"code":"#(loop [s (rest %) r [] l [(first s)]] \n  (let [f (first s) c (last l)]\n    (if (= s [])\n      (conj r l)\n      (if (= f c)\n        (recur (rest s) r (conj l f))\n        (recur (rest s) (conj r l) [f])))))","problem":31,"user":"4efb87f7535dced4c769f279"},{"code":"(fn pack [xs]\r\n  (cond\r\n    (empty? xs) '()\r\n    :else (cons (take-while #(= (first xs) %) xs) (pack (drop-while #(= (first xs) %) xs)))))","problem":31,"user":"4dc7e7a5535d8a4b2fd74290"},{"problem":31,"code":"#(reduce\n  (fn [m e]\n    (if (= (last (last m)) e)\n      (conj (vec (drop-last m)) (conj (last m) e))\n      (conj m [e])\n    )\n  )\n  []\n  %)","user":"5881d1c2e4b0f1effa3b7644"},{"code":"(fn f\n  ([xs] (if (empty? xs) \n          '() \n          (f (rest xs) (list (first xs)) '())))\n  ([xs ys zs] (if (empty? xs) \n                (concat zs (list ys))\n                (if (= (first xs) (first ys)) \n                       (f (rest xs) (cons (first xs) ys) zs)\n                       (f (rest xs) (list (first xs)) (concat zs (list ys)))))))","problem":31,"user":"52d660eae4b09f7907dd1356"},{"code":"#(loop [lst (rest %) sublst [(first lst)]  ret []]\n   (if (empty? lst)\n     (conj ret sublst)\n     (if (= (first lst) (first sublst))\n       (recur (rest lst) (conj sublst (first lst)) ret)\n       (recur (rest lst) [(first lst)] (conj ret sublst)))))","problem":31,"user":"51000111e4b00d7ad4cab15e"},{"problem":31,"code":"(fn pack [lst]\n  (reverse (reduce (fn [xs x]\n                     (let [first-xs (first xs)]\n                       (if (= (first first-xs) x)\n                         (cons (cons x first-xs)\n                               (next xs))\n                         (cons (list x) xs))))\n                   '()\n                   lst)))","user":"5895477fe4b00487982d527c"},{"code":"(fn [coll]\n  (reverse\n  (loop [coll coll fst (first coll) acc '()]\n    (println coll fst acc)\n    (or (and (empty? coll) acc)\n        (let [acc2 (or (and (empty? acc) (list (list fst)))\n                      (and (= fst (ffirst acc))\n                           (cons (cons fst (first acc)) (rest acc)))\n                      (cons (list fst) acc))]\n          (recur (rest coll) (second coll) acc2))))))","problem":31,"user":"50ba4b9ee4b03e68e4411c7b"},{"problem":31,"code":"(fn group-repeat\n  ([x] (group-repeat (rest x) [(first x)] []))\n  ([x g r] (if (empty? x)\n             (conj r g)\n             (if (= (first g) (first x))\n               (recur (rest x) (conj g (first x)) r)\n               (recur (rest x) [(first x)] (conj r g))))))","user":"58c3af4de4b021aa9917ed1b"},{"problem":31,"code":"(fn pack\n  [aseq]\n  (reduce\n   (fn [res i]\n     (let [res (vec res) \n           cur (last res)]\n       (if (= (last cur) i)\n         (conj (vec (butlast res)) (conj cur i))\n         (conj res [i]))))\n   [[(first aseq)]]\n   (rest aseq)))","user":"53de7484e4b0d874e779ae35"},{"problem":31,"code":"(fn pack [s]\n  (if (empty? s)\n    s\n    (if\n      (= (first s) (second s))\n      (let\n        [prest (pack (rest s))]\n        (concat\n          (list (concat\n            (list (first s))\n            (first prest)))\n          (rest prest)))\n      (concat\n       (list (list (first s)))\n       (pack (rest s))))))","user":"54c9e00be4b045293a27f683"},{"problem":31,"code":"#(loop [res (vector) x1 (vector(first %)) x2 (rest %)]\n    (if (empty? x2)\n      (conj res x1)\n      (if (= (first x1) (first x2))\n        (recur res (conj x1 (first x2)) (rest x2))\n        (recur (conj res x1) (vector (first x2)) (rest x2)))))","user":"5b919d9de4b0c0b3ffbd4a24"},{"problem":31,"code":"#(reverse (reduce\n  (fn [r x] \n    (if (= (first (first r)) x) \n      (conj (rest r) (conj (first r) x)) \n      (conj r (list x))))\n  '() \n  %))","user":"5bf1b957e4b0a6d31fed216f"},{"problem":31,"code":"(fn [[h & t]]\n  (reduce\n   (fn [x y]\n     (if (= (last (last x)) y)\n       (conj (into [] (butlast x)) (conj (last x) y))\n       (conj x [y])))\n   [[h]]\n   t))","user":"604d3cb1e4b0b7ec0ac60ac2"},{"code":"(fn pack [seq]\n  (if (empty? seq) \n      '()\n      (let [item (first seq)\n            subsoln (pack (rest seq))\n            sublist (first subsoln)]\n        (if (= item (first sublist))\n            (cons (cons item sublist) (rest subsoln))\n            (cons (list item) subsoln)))))","problem":31,"user":"4f70afb8e4b07046d9f4effb"},{"problem":31,"code":"(fn [x]\n  (reverse \n   (reduce\n    #(if (= (ffirst %1) %2)\n       (conj (rest %1) (conj (first %1) %2))\n       (conj %1 (list %2)))\n    '() x )))","user":"57dafe97e4b0bd073c20241c"},{"problem":31,"code":"(fn [x]\n    (loop [deduped [[(first x)]] list (rest x)]\n      (if (empty? list)\n        deduped\n        (let [[current & remainder] list]\n        (if (= current (first (last deduped)))\n        \t(recur\n            (conj (vec (butlast deduped)) (conj (last deduped) current))\n            remainder)\n          (recur (conj deduped [current]) remainder))))))","user":"58f00639e4b056aecfd47ddc"},{"problem":31,"code":"(fn [coll]\n   (prn \"===========\")\n   (reduce (fn [result elem]\n             (prn \"-------------\")\n             (prn \"result\" result)\n             (prn \"elem\" elem)\n             (let [prev-pack (last result)]\n               (prn \"prev-pack\" prev-pack)\n               (if (or (nil? prev-pack)\n                       (not (= (first prev-pack) elem)))\n                 (concat result (list (list elem)))\n                 (concat (butlast result)\n                         (list (conj prev-pack elem)))))) '() coll))","user":"5bef3e88e4b0a6d31fed213f"},{"problem":31,"code":"#(let [munch (fn [coll]\n               (let [current (first coll)]\n                 (loop [in coll\n                        out '()]\n                   (if (= current (first in))\n                     (recur (rest in)\n                            (conj out current))\n                     [out in]))))]\n   (loop [in %\n          out '()]\n     (if (empty? in)\n       out\n       (let [[chunk remainder] (munch in)]\n         (recur remainder\n                (concat out (list chunk)))))))","user":"57a310b4e4b0c3d858beb90c"},{"problem":31,"code":"(fn grp\n  ([xs]\n   (grp xs [] nil))\n  ([xs acc prev]\n   (if (seq xs)\n     (if (and last (= (first xs) prev))\n       (recur (rest xs) (concat (butlast acc) [(concat [(first xs)] (last acc))]) prev)\n       (recur (rest xs) (concat acc [[(first xs)]]) (first xs)))\n     acc)))","user":"5705f569e4b0b0fb43fd0677"},{"code":"(fn [coll]\n  (loop [coll coll ret '() acc '()]\n    (cond\n      (empty? coll) \n      (reverse (conj ret acc))\n      (or (empty? acc) (= (first coll) (first acc)))\n      (recur (rest coll) ret (conj acc (first coll)))\n      :else\n      (recur (rest coll) (conj ret acc) (conj '() (first coll))))))","problem":31,"user":"4dadb891c9a9d6ed3699dc57"},{"problem":31,"code":"(fn my-pack\n  [coll]\n  (loop [coll coll ret []]\n    (if (empty? coll)\n      ret\n      (recur (drop-while #(= (first coll) %) coll) (conj ret (take-while #(= (first coll) %) coll))))))","user":"59a512b7e4b066c664927d5e"},{"code":"(fn y [s]\n  (if (empty? s)\n    s\n    (let [[h t] (split-with #(= (first s) %) s)]\n      (cons h (y t)))))","problem":31,"user":"536e0930e4b0fc7073fd6e66"},{"code":"(fn groupe [v]\n  (reduce\n    #(if (= (last (last %1)) %2)\n        (conj (subvec %1 0 (dec (count %1))) (conj (last %1) %2))\n        (conj %1 [%2])\n    )\n    []\n    v\n  )\n)","problem":31,"user":"4f84400de4b033992c121c2e"},{"problem":31,"code":"(fn [coll] \n  (loop [r (list (list (first coll))) \n         c (rest coll)] \n    (if (empty? c) \n      (reverse r) \n      (if (= (first c) (ffirst r)) \n        (recur (conj (rest r) (conj (first r) (first c))) (rest c)) \n        (recur (conj r (list (first c))) (rest c))))))","user":"541d3c0fe4b01498b1a71a7e"},{"problem":31,"code":"#((fn pac [a b c] (\n      if (empty? a)\n         (conj b c)\n         (if (= (first a) (first c))\n           (pac (rest a) b (conj c (first a)))\n           (pac (rest a) (conj b c) [(first a)])\n         )\n)) (rest %) [] [(first %)])","user":"593f88dce4b069cdc2982be2"},{"code":"(fn [col]\n  (loop [col1 [] col2 col currentv (first col)  currentlist [] ]\n   (if (empty? col2)\n      (conj col1 currentlist)\n      (let [same (= (first col2) currentv)]\n       (recur\n            (if same  col1 (conj col1 currentlist))\n            (rest col2)\n            (if same  currentv (first col2 ))\n            (if same (conj currentlist currentv) [(first col2 )]  )\n       )\n       )\n      )\n   )\n   )","problem":31,"user":"4ec5bec6535d6d7199dd36b3"},{"problem":31,"code":"(fn pack [s]\n  \"packs consecutive duplicates into sub-lists\"\n  (if s\n    (let [x (first s) r (pack (next s))]\n      (if (= x (first (first r)))\n        (cons (cons x (first r)) (rest r))\n        (cons (list x) r)))\n    (list)))","user":"5af0ac45e4b0cc2b61a3bc56"},{"code":"(fn [seq]\n  (reverse\n    (reduce \n      (fn [l i]\n\t      (println l i)\n\t      (if (= (first (first l)) i)\n\t        (cons (cons i (first l)) (rest l))\n\t        (cons (list i) l)\n\t      )\n\t    )\n     '() seq)\n  )\n)","problem":31,"user":"4e7e05a6535db169f9c796fe"},{"code":"(fn pack [the-list]\n\t(if (= 0 (count the-list))\n\t\tthe-list\n\t\t\t(cons \n\t\t\t\t(first ((fn peel [parcel rest-list]\n\t\t(if (= 0 (count rest-list))\n\t\t\t(list parcel rest-list)\n\t\t\t(if (= (first parcel) (first rest-list))\n\t\t\t\t(peel\n\t\t\t\t\t(cons (first rest-list) parcel) \n\t\t\t\t\t(rest rest-list)\n\t\t\t\t)\n\t\t\t\t(list parcel rest-list)\n\t\t\t)\n\t\t)\n\t) (list (first the-list)) (rest the-list))) \n\t\t\t\t(pack (second ((fn peel [parcel rest-list]\n\t\t(if (= 0 (count rest-list))\n\t\t\t(list parcel rest-list)\n\t\t\t(if (= (first parcel) (first rest-list))\n\t\t\t\t(peel\n\t\t\t\t\t(cons (first rest-list) parcel) \n\t\t\t\t\t(rest rest-list)\n\t\t\t\t)\n\t\t\t\t(list parcel rest-list)\n\t\t\t)\n\t\t)\n\t) (list (first the-list)) (rest the-list))))\n\t\t\t)\n\t)\n)","problem":31,"user":"51701a9ce4b034fe8eaf70f5"},{"code":"(fn f [s] (reduce\n            #(if (= (last (last %1)) %2)\n               (concat (butlast %1) [(conj (last %1) %2)])\n               (concat %1 [[%2]]))\n       [[(first s)]] (next s)))","problem":31,"user":"4f5694cae4b0a7574ea71827"},{"code":"reduce #(let [lst (first (last %))]\r\n           (if (= lst %2)\r\n             (conj (pop %) (conj (last %) %2))\r\n             (conj % (list %2))))\r\n        []","problem":31,"user":"507a396be4b08327cd804a69"},{"code":"(fn [coll]\r\n  (reverse\r\n    (reduce\r\n      (fn [s x] (if (= x (ffirst s))\r\n                  (cons (cons x (first s)) (rest s))\r\n                  (cons (list x) s)))\r\n      ()\r\n      coll)))","problem":31,"user":"4f969214e4b0dcca54ed6cdd"},{"code":"#(partition-by (set %) %)","problem":31,"user":"4e823ed7535db62dc21a62c7"},{"code":"(fn pack [l] (partition-by identity (vec l)))","problem":31,"user":"4f6fe5e4e4b07046d9f4efef"},{"code":"(fn pack [lst]\r\n  (loop [inp lst current (first inp) c 0 acc ()]\r\n    (if (empty? inp)\r\n      (reverse (conj acc (repeat c current)))\r\n      (let [target (first inp)\r\n            same? (= current target)]\r\n        (println target same?)\r\n        (recur (rest inp)                 ;; Continue down the list\r\n               (if same? current target)  ;; If we are still looking at the same item, keep it, otherwise change it\r\n               (if same? (inc c) 1)       ;; If we are still looking at the same item, increment the count, otherwise reset it \r\n               (if same? \r\n                 acc                                   ;; If we are still looking at the same item, don't touch the current list\r\n                 (conj acc (repeat c current))))))))   ;; Otherwise, add the item repeated count times.","problem":31,"user":"4f629697e4b0defedf855fd6"},{"code":"(fn asdf [coll]\n  (partition-by identity coll))","problem":31,"user":"4e47f4f3535dc968683fc4bb"},{"problem":31,"code":"(fn [sequence] (partition-by identity sequence))","user":"593c653de4b069cdc2982b8f"},{"problem":31,"code":"(fn abc\n  [L]\n  (if (empty? L)\n    '()\n    (let [n (count (take-while #(= (first L) %) L))]\n      (conj (abc (drop n L)) (take n L))\n    )\n  )\n)","user":"56bb3a4be4b0f26550335951"},{"problem":31,"code":"#((fn [seq current-acc full-acc]\n        (if\n          (empty? seq) (reverse (if (empty? current-acc) (full-acc) (cons (reverse current-acc) full-acc)))\n          (if (empty? current-acc)\n            (recur (rest seq) (cons (first seq) current-acc) full-acc)\n            (if (= (first seq) (first current-acc))\n              (recur (rest seq) (cons (first seq) current-acc) full-acc)\n              (recur (rest seq) (cons (first seq) (empty seq)) (cons (reverse current-acc) full-acc))))))\n  % '() '())","user":"5553b924e4b0deb715856e06"},{"code":"(fn pack-dups [s]\n  (if (seq s)\n    (let [[ff rr] (split-with #(= (first s) %) s)]\n      (cons ff (pack-dups rr))\n      )\n    )\n  )","problem":31,"user":"506ab9bae4b05d3b7762c74c"},{"problem":31,"code":"partition-by (fn [t] t)","user":"5f548678e4b0a0bc16850a7e"},{"code":"(fn \n  [v] \n  (let [f (fn [a cl i] (cond (empty? i) (conj a cl) \n                             (= (first cl) (first i)) \n                                (recur a (conj cl (first i)) (rest i)) \n                             :else \n                                (recur (conj a cl) (list (first i)) (rest i))))] \n       (cond (empty? v) '() \n             (= (.size v) 1) (list (list (first v))) \n             :else (reverse (f '() (list (first v)) (rest v))))))","problem":31,"user":"52dfc89be4b09f7907dd1405"},{"problem":31,"code":"(fn [col]\n    (loop [innercol col\n           result (vector)]\n      (let [conseqs (take-while (partial = (first innercol)) innercol)\n            nextcol (drop (count conseqs) innercol)\n            nextres (conj result conseqs)]\n        (if (empty? nextcol)\n          nextres\n          (recur nextcol nextres)))))","user":"554a75c9e4b0a04f79299575"},{"code":"(fn [vec]\n  (loop [acc (list (list (first vec))) r (rest vec)]\n    (if (empty? r)\n      (reverse acc)\n      (recur (if (= (first r) (first (first acc)))\n                (conj (rest acc) (conj (first acc) (first r)))\n                (conj acc (list (first r))))\n             (rest r)))))","problem":31,"user":"4e951f2c535dbda64a6f6b2f"},{"code":"(fn agrupa [x]\n  (loop [old (first x) l (next x) \n         grupo (list old) res nil]\n   (if l\n   (if (= (first l) old)\n       (recur old (next l) (cons old grupo) res)\n       (recur (first l) (next l) (list (first l)) \n              (conj res grupo)))\n    (reverse (cons grupo res)))))","problem":31,"user":"4f04a06d535dcb61093f6bd9"},{"problem":31,"code":"(fn pack\n  [lst]\n  (loop [x 0\n         res ()\n         accum nil\n         minilst ()\n         original lst\n         ]\n    (if (<= x (count lst)) (cond\n                             (and (not (= accum (first original))) (not (= x 0))) (recur (+ x 1) (conj res minilst) (first original) (conj () (first original)) (rest original))\n                             :else (recur (+ x 1) res (first original) (conj minilst (first original)) (rest original)))\n                           (reverse res))))","user":"59e68254e4b0249b728206fc"},{"problem":31,"code":"(fn f [s] (partition-by identity s))","user":"5ed15e23e4b016b56eae05ba"},{"problem":31,"code":"(fn sdsu-pack-2\n  ([sequence]\n   (sdsu-pack-2 sequence []))\n  ([sequence result]\n   (if(empty? sequence)\n     result\n     (sdsu-pack-2 (rest sequence) result [(first sequence)])))\n  ([sequence result subsequence]\n   (if (empty? sequence)\n     (conj result subsequence)\n     (if (= (first sequence) (first subsequence))\n       (recur (rest sequence) result (cons (first sequence) subsequence))\n       (sdsu-pack-2 sequence (conj result subsequence))))))","user":"556be3dce4b09a3098a524f7"},{"problem":31,"code":"(fn pack\n    ([x]\n     (pack (rest x) (first x) [(list (first x))])\n     )\n    ([x last-item packed]\n     (if (empty? x)\n       packed\n       (if (= (first x) last-item)\n         (pack (rest x)\n               last-item\n               (update-in packed [(dec (count packed))] conj last-item)\n               )\n         (pack (rest x) (first x) (conj packed (list (first x))))\n         ))))","user":"5d52bf29e4b0776584bd6f69"},{"problem":31,"code":"#(loop [x %\n       o '()]\n  (if (empty? x)\n    (reverse o)\n    (let [fo (first o)\n          fx (first x)]\n\n        (if (= fx (first fo))\n          (recur (rest x) (conj (rest o) (conj fo fx)))\n          (recur (rest x) (conj o (list fx)))))))","user":"5530b827e4b076ab5578f818"},{"code":"(fn pack [coll]\n  (partition-by identity coll)\n  )","problem":31,"user":"510a3cd4e4b06956752d35ad"},{"code":"(fn [coll]\n  (loop [c coll acc '()]\n    (cond (empty? c) (reverse acc)\n          \n          (empty? acc) \n          (recur (rest c) \n                 (cons (list (first c)) acc))\n          \n          (= (first c) (ffirst acc)) \n          (recur (rest c) \n                 (cons (cons (first c) (first acc)) (rest acc)))\n          \n          :else \n          (recur (rest c) \n                 (cons (list (first c)) acc)))))","problem":31,"user":"515c6132e4b069911535cf0d"},{"problem":31,"code":"(fn [a]\n  (reverse (reduce (fn [b c]\n            (cond\n             (empty? b) (cons (list c) b)\n             (= c (first (first b))) (cons (cons c (first b)) (rest b))\n             :else (cons (list c) b)))\n          '() a)))","user":"59c7c2cde4b0a024fb6ae54b"},{"code":"(fn pack [l] (if (= 0 (count l)) '() (let [r (pack (rest l))] (if (and (> (count r) 0) (= (first l) (first (first r)))) (conj (rest r) (conj (first r) (first l))) (conj r (list (first l)))))))","problem":31,"user":"52d92f13e4b09f7907dd13a2"},{"problem":31,"code":"reduce\n(fn [res val]\n  (let [n-colls (count res)\n        last-coll (last res)]\n\t  (if (= val (first last-coll))\n    \t(update-in res [(dec n-colls)] conj val)\n\t    (conj res [val]))))\n[]","user":"4e6fe3a6535d5021c1a89629"},{"problem":31,"code":"(fn [coll]\n  (loop [coll (seq coll), acc (), sub ()]\n    (if-let [x (first coll)]\n      (cond\n        (empty? sub)      (recur (rest coll) acc (list x))\n        (= x (first sub)) (recur (rest coll) acc (conj sub x))\n        :else             (recur (rest coll) (conj acc sub) (list x)))\n      (reverse (conj acc sub)))))","user":"552356fae4b0882d96d091af"},{"code":"(fn [xs] \n  (let [v \n        (reduce #(if (or (empty? (%1 1)) (= (last (%1 1)) %2))\n                   [(%1 0) (conj (%1 1) %2)]\n                   [(conj (%1 0) (%1 1)) [%2]]) [[][]] xs)]\n    (conj (v 0) (v 1))))","problem":31,"user":"4e74e119535d7a570dd295bc"},{"problem":31,"code":"(fn  [y1]\n (loop [z '() i 0 y y1 ] \n (println \"Z:\" z \"Count z:\" i   \"Y:\" y   \"First Y:\" (first y))\n (if (not-empty y)  (recur (conj z (sequence (take-while (fn[x](= x (first y))) y ))) (+ i (count (take-while (fn[x](= x (first y))) y ))) (subvec y1 (count (apply concat (conj z (sequence (take-while (fn[x](= x (first y))) y )))))  )   ) (reverse z)) ))","user":"56e6e1e6e4b02e7e935eb6cf"},{"problem":31,"code":"(fn [x]\n  (loop [lst () doubly () link x]\n   (if (empty? link) (rest (reverse (conj doubly lst)))\n    (if (= (first link) (first lst)) (recur (conj lst (first link)) (seq doubly) (rest link))\n      (recur (conj '() (first link)) (conj doubly lst) (rest link))))))","user":"563130e4e4b0bfe05bf1178d"},{"problem":31,"code":"(fn [coll] \n  (loop [c coll\n         arr []\n         res []]\n    (cond\n     (empty? c) (conj res arr)\n     (empty? arr) (recur (rest c) (conj arr (first c)) res)\n     (= (first c) (first arr)) (recur (rest c) (conj arr (first c)) res)\n     :else (recur c [] (conj res arr)))))","user":"5b72b36ce4b047b03b2036a9"},{"problem":31,"code":"(fn yyy [s]\n  (let [xxx (fn [prev curr-group s out]\n              (if (seq s)\n                (if (= prev (first s))\n                  (recur (first s) (conj curr-group (first s)) (rest s) out)\n                  (recur (first s) [(first s)] (rest s) (conj out curr-group)))\n                (conj out curr-group)))]\n    (rest (xxx nil [] s []))))","user":"5a904de3e4b05369db4d254c"},{"problem":31,"code":"(fn [items]\n  (reduce\n    (fn [new-seq item]\n      (if (and\n              (seq new-seq)\n              (and (seq (last new-seq))\n                   (.contains (last new-seq) item)))\n        (conj (pop new-seq) (conj (last new-seq) item))\n        (conj new-seq [item])))\n    []\n    items))","user":"5f009162e4b0cf489e8d7f1a"},{"problem":31,"code":"#(loop [alist % sublist [] result []]\n   (if (empty? alist)\n     result\n     (cond \n      (= (first alist) (first (rest alist))) (recur (rest alist) (conj sublist (first alist)) result)\n      :else (recur (rest alist) [] (conj result (conj sublist (first alist))))\n      )\n     )\n   )","user":"5deab1b2e4b0986d99407f9f"},{"problem":31,"code":"(fn [coll]\n  (reduce (fn [v x]\n            (let [end (last v)]\n              (if (and (list? end) (= x (first end)))\n                (conj (pop v) (conj end x))\n                (conj v (list x)))))\n          []\n          coll))","user":"56a79eb0e4b07966d5a8a05d"},{"code":"(fn [s]\n  (reverse\n    ((fn pack [x lst ret]\n      (let [curr (first x) cp (first lst)]\n(if (next x)\n(if (= curr cp)\n(pack (next x) (conj lst curr) ret)\n(pack (next x) (list curr) (conj ret lst)))\n(if (= curr cp)\n(conj ret (conj lst curr))\n(conj ret lst (list curr)))))) (next s) (-> s first list) '())))","problem":31,"user":"4eb27fad535d7eef3080734a"},{"problem":31,"code":"(partial reduce (fn [result x] ()\n                  (if (= (first (last result)) x)\n                    (conj (vec (butlast result)) (conj (last result) x))\n                    (conj result [x])\n                    ))\n         [])","user":"5bb3c9a8e4b0a20761a2352f"},{"problem":31,"code":"(fn f [x]\n  (loop [s x, mir (first x), box '(), res '()]\n    (if (seq s)\n      (recur (rest s) (first s) (if (= mir (first s))\n                                  (conj box (first s))\n                                  (conj '() (first s)))\n             (if (= mir (first s))\n               res\n               (conj res box)))\n      (reverse (conj res box)))))","user":"593d6793e4b069cdc2982ba6"},{"problem":31,"code":"(fn [r c n l]\n  (if (seq l)\n    (if (= c (first l))\n      (recur r c (inc n) (rest l))\n      (recur (conj r (repeat n c)) (first l) 1 (rest l)))\n    (rest (conj r (repeat n c))))) [] nil 1","user":"54b2ec84e4b09f271ff37d33"},{"code":"(fn [a]\n  (reverse (loop [ans '()\n         aa (concat (seq (next a)) (list 9999999999))\n         temp (list (first a))\n         pre (first a)]\n    (if (empty? aa)\n      ans\n      (if (= pre (first aa))\n        (recur ans \n               (next aa)\n               (conj temp (first aa)) \n               pre)\n        (recur (conj ans temp)\n               (next aa)\n               (list (first aa))\n               (first aa)))))))","problem":31,"user":"52196842e4b0890f2f822bfa"},{"problem":31,"code":"(fn [x]\n     (partition-by identity x))","user":"594ea2a4e4b07ddc2dafaeb6"},{"problem":31,"code":"(fn [coll] (reverse (reduce (fn [acc x]\n                     (if (= x (first (first acc)))\n                       (conj (drop 1 acc) (conj (first acc) x))\n                       (conj acc [x])))\n                   '()\n                   coll)))","user":"5622af0fe4b03f08ee9a922b"},{"code":"(fn [sq]\n  ((fn [sq r pc group]\n     (cond\n      (empty? sq) (concat (rest r) [group])\n      (= (first sq) pc) (recur (rest sq)\n                               r pc\n                               (conj group pc))\n      :else (recur (rest sq)\n                   (concat r [group])\n                   (first sq)\n                   (list (first sq)))))\n   sq [] nil nil))","problem":31,"user":"535d910ae4b04ce2eb3ed2c5"},{"problem":31,"code":"#(reverse (reduce (fn [acc xx] (if (= xx (first (first acc)))\n                         (conj (rest acc) (conj (first acc) xx))\n                         (conj acc (list xx)))) '() %))","user":"5f419985e4b0955706451fab"},{"code":"(fn [x] \r\n       (reverse \r\n         (reduce #(if (= (ffirst %1) %2) \r\n                  (conj (rest %1) (conj (first %1) %2))\r\n                  (conj %1 (list %2))\r\n                  ) '() x)))","problem":31,"user":"4deb529a535d08e6dec9fe04"},{"problem":31,"code":"(fn pack_seq [s]\n  (loop [result [] sq s]\n    (if-not (empty? sq)\n      (recur (conj result (take-while #(= % (first sq)) sq)) (drop-while #(= % (first sq)) sq))\n      result\n      )\n    )\n  )","user":"5c52f3fce4b0fb8c5ffd99e9"},{"problem":31,"code":"(fn packer\n  ([coll] (packer 1 coll))\n  ([acc coll] \n   (cond \n    (empty? coll) '()\n    (= (first coll) (second coll)) (packer (inc acc) (rest coll))\n    :else (conj (packer 1 (rest coll)) (take acc (repeat (first coll)))))))","user":"56e53d2fe4b02e7e935eb6bc"},{"problem":31,"code":"(fn [s]\n   (reverse (reduce #(if (coll? (first %1))\n                       (if (not= (first (first %1)) %2)\n                         (conj %1 (list %2))\n                         (conj (rest %1) (conj (first %1) %2))\n                         )\n                       (if (not= (first %1) %2)\n                         (conj %1 (list %2))\n                         (conj (rest %1) (list %2 %2))\n                         )\n                       ) '() s))\n   )","user":"5a80b934e4b00b71e582a05b"},{"code":"(fn pack-sequence [xs]\n    (when-first [x xs]\n        (let [[b e] (split-with #{x} xs)]\n            (cons b (pack-sequence e)))))","problem":31,"user":"4f0660ee535dcb61093f6c0d"},{"code":"(fn [x]\n  (partition-by str x))","problem":31,"user":"4eb6d3ab535d7eef30807370"},{"problem":31,"code":"(fn bar [xs]\n  (let [x ((fn foo [ys]\n             (if (= 0 (count ys))\n               (list)\n                  (let [y (first ys) ymore (rest ys)]\n                    (if (= y (first ymore))\n                      (concat (list y) (foo ymore))\n                      (list y))))) xs)\n        more (drop (count x) xs)]\n    (if (= 0 (count more))\n      (list x)\n      (concat (list x) (bar more)))))","user":"54d753ebe4b0a52adc2e2029"},{"code":"(fn [coll]\n  (reduce #(if (= (last (last %1)) %2)\n             (conj (pop %1) (conj (last %1) %2))\n             (conj %1 [%2])) [] coll))","problem":31,"user":"4e89f9e5535d3e98b8023289"},{"problem":31,"code":"(fn [s] (loop [ret [] i 1 e (first s) sl [(first s)]] (if (= i (count s)) (conj ret sl) (if (= e (nth s i)) (recur ret (+ i 1) e (conj sl e)) (recur (conj ret sl) (+ i 1) (nth s i) [(nth s i)])))))","user":"59468de7e4b07ddc2dafad88"},{"problem":31,"code":"(fn [coll]\n  (reduce (fn [coll elt]\n            (if (= (last  (last coll)) elt)\n              (concat (drop-last coll) [(conj (last coll) elt)])\n              (concat coll [[elt]]))) [] coll))","user":"54ccf9d5e4b057c6fda3a295"},{"code":"(fn myfunc [thelist]\r\n  (loop [x (list (first thelist))\r\n           y (rest thelist)\r\n           packed []]\r\n      (cond\r\n\t\t(empty? y) (conj packed x)\r\n        (= (first x) (first y)) (recur (conj x (first y)) (rest y) packed)\r\n        :else (recur (list (first y)) (rest y) (conj packed x))\r\n  )))","problem":31,"user":"50a85af1e4b054305ba5a833"},{"code":"(fn\n  [cs]\n  (reduce (fn [c [a b]]\n            (let [segs (count c)\n                  entries (count (c (dec segs)))]\n              (if (= a b)\n                (assoc-in c [(dec segs) entries] b)\n                (assoc-in c [segs] [b]))))\n          [[(first cs)]]\n          (partition 2 1 cs)))","problem":31,"user":"51852961e4b0da5a5be3babb"},{"code":"(fn pack [items]\n  (if (empty? items)\n    '()\n    (concat (list (take-while (partial = (first items)) items))\n            (pack (drop-while (partial = (first items)) items)))))","problem":31,"user":"510cd1dde4b078ea71921124"},{"problem":31,"code":"(fn [xs]\n  (loop [curr (list (peek xs))\n         ls (pop xs)\n         return '()]\n    (if (nil? (first ls))\n      (conj return curr)\n      (let [x (peek ls)]\n        (if (= x (peek curr))\n          (recur (conj curr x)\n                 (pop ls)\n                 return)\n          (recur (list x)\n                 (pop ls)\n                 (conj return curr)))))))","user":"55f73078e4b06e875b46cea4"},{"problem":31,"code":"(fn \n  [lst]\n  (partition-by identity lst))","user":"57f81569e4b0d3187e900919"},{"code":"(fn pack [s]\n  (loop [a () sublist () s s]\n    (if (seq s)\n      (if (or (empty? sublist) (= (first sublist) (first s)))\n        (recur a (conj sublist (first s)) (rest s))\n        (recur (conj a sublist) (list (first s)) (rest s)))\n      (reverse (conj a sublist)))))","problem":31,"user":"50a7ef7fe4b090657f4a5ce0"},{"problem":31,"code":"(fn f [s] (when (seq s) (let [item (first s) group (take-while #(= % item) s)] (cons group (f (nthrest s (count group)))))))","user":"5e5b8d92e4b0fd0acd158658"},{"code":"(fn pack [s]\n  (cond\n    (nil? s) '()\n    (= (first s) (first (next s)) (first (next (next s)))) \n      (conj (pack (next (next (next s)))) \n            (list (first s) (first s) (first s)))\n    (= (first s) (first (next s))) (conj (pack (next (next s))) (list (first s) (first s)))\n    :else (conj (pack (next s))\n                (list (first s)))))","problem":31,"user":"4e444c11535dc968683fc4a9"},{"code":"(fn [coll]\n    (loop [input coll\n           output '()\n           group nil\n           lastv nil]\n      (if (empty? input)\n        (rest (reverse (conj output group)))\n        (if (= (first group) (first input))\n          (recur (rest input)\n                 output\n                 (conj group (first input))\n                 lastv)\n          (recur (rest input)\n                 (conj output group)\n                 (conj nil (first input))\n                 (first input))))))","problem":31,"user":"4fcbc18ae4b0ee37620e185c"},{"problem":31,"code":"(fn f [sq]\n  (if (empty? sq) sq\n                  (cons (take-while #(= (first sq) %) sq) \n                        (f (drop-while #(= (first sq) %) sq)))))","user":"55815973e4b05c286339e0f6"},{"problem":31,"code":"(fn dedupe- [s-]\n (let [result (reduce (fn [[acc curr last-seen] this]\n                       (if (= this last-seen)\n                        [acc (conj curr this) this]\n                        [(conj acc curr) [this] this]\n                       ))\n               ; result  current  last seen\n               [ []      nil nil      ]\n               (seq s-))\n ]\n (rest (conj (first result) (second result)))))","user":"5b250773e4b063e2438bcc21"},{"code":"(fn [sequence]\n  ((fn [so-far to-go]\n    (if (empty? to-go)\n      so-far\n      (let [next-group (take-while #(= (first to-go) %) to-go)]\n        (recur (conj so-far next-group)\n               (drop (count next-group) to-go)))))\n    [] sequence))","problem":31,"user":"4e42f930535dc968683fc49f"},{"code":"(fn [xs]\n  (reverse\n   (reduce\n    (fn [xs n]\n      (cond\n       (empty? xs) (list (list n))\n       (= n (first (first xs))) (conj (rest xs) (conj (first xs) n))\n       true (conj xs (list n))))\n    '() xs)))","problem":31,"user":"52618ea3e4b03e8d9a4a7064"},{"code":"(fn [l-prime]\n  (loop [l (drop-last l-prime) current (list (last l-prime)) rv ()]\n    (if (empty? l)\n      (cons current rv)\n      (if (= (last l) (last current))\n      \t(recur (drop-last l) (cons (last l) current) rv)\n      \t(recur (drop-last l) (list (last l)) (cons current rv))))))","problem":31,"user":"534f13b2e4b084c2834f4ac4"},{"code":"(fn f [x]\n  (cond\n   (= (count x) 0) x\n   (= (count x) 1) (list x)\n   true (let\n    \t   [frst (first x)\n      \t\trst (f (rest x))]\n     \t (if (= frst (first (first rst)))\n             (conj (rest rst) (conj (first rst) frst))\n             (conj rst (list frst))))))","problem":31,"user":"52d7b0ade4b09f7907dd137c"},{"problem":31,"code":"(fn\n  [se]\n  (loop [outerlist (vector)\n         innerlist (list (first se))\n         se (rest se)]\n    (if (empty? se) (conj outerlist innerlist)\n      (if (= (first innerlist) (first se))\n        (recur outerlist (conj innerlist (first se)) (rest se))\n        (recur (conj outerlist innerlist) (list (first se)) (rest se))))))","user":"554d386ee4b0a04f792995b8"},{"problem":31,"code":"(fn pack-cons-dup\n  [s]\n  (partition-by identity s))","user":"5f3103aee4b0574c87022c24"},{"problem":31,"code":"(fn pack [s]\n  (loop [a []\n         p (partial = (first s))\n         r s]\n    (if (empty? r)\n      a\n      (let [h (take-while p r)\n            t (drop-while p r)]\n        (recur (conj a h)\n               (partial = (first t))\n               t)))))","user":"5ab564f8e4b073f177442639"},{"problem":31,"code":"(fn pack-seq [col]\n        (loop [result [] buf [(first col)] rest (next col)]\n          (if (empty? rest)\n            (conj result buf)\n            (if (= (last buf) (first rest))\n              (recur result (conj buf (first rest)) (next rest))\n              (recur (conj result buf) [(first rest)] (next rest))))))","user":"541f89a5e4b01498b1a71a99"},{"code":"(fn [x]\n  (reverse ((fn d-sub [a result]\n      (if (empty? a) result\n        (let [H (first a)\n              S (first result)]\n          (if (= H (first S)) \n            (d-sub (rest a) (cons (cons H S) (rest result)))\n            (d-sub (rest a) (cons (cons H '()) result))\n            )))\n    ) x '())))","problem":31,"user":"4f3242bae4b0d6649770a08f"},{"problem":31,"code":"(fn [coll] (letfn [(add-item [acc coll idx] \n                                  (conj acc (nth coll idx)))\n\n                        (add-group [acc coll] \n                                   (conj acc (create-group coll)))\n\n                        (decrease-coll [coll acc] \n                                       (drop (count (last acc)) coll))\n\n                        (not-group-member? [idx coll] \n                                           (not= (first coll) (nth coll idx)))\n\n                        (out-of-bounds? [idx coll] \n                                        (or (empty? coll) (>= idx (count coll))))\n\n                        (create-group [coll] (loop [idx 0 \n                                                    coll coll\n                                                    acc []]\n                                               (if (or (out-of-bounds? idx coll)\n                                                       (not-group-member? idx coll))\n                                                 acc\n                                                 (recur (inc idx) coll (add-item acc coll idx)))))\n                        (process-coll [coll] (loop [coll coll\n                                                    acc []]\n                                               (let [coll' (decrease-coll coll acc)\n                                                     acc' (add-group acc coll')]\n                                                 (if (empty? coll)\n                                                   acc\n                                                   (recur coll' acc')))))] \n                        (drop-last (process-coll coll))))","user":"53da8fede4b0e771c30254a3"},{"code":"partition-by min","problem":31,"user":"4ee4f4a9535d1385b2869d85"},{"problem":31,"code":"(fn pack\n  ([x] (if (= 0 (count (drop-while #(= % (first x)) x)))\n         (cons (into '() (take-while #(= % (first x)) x)) '())\n         (pack\n          (cons (into '() (take-while #(= % (first x)) x)) '())\n          (drop-while #(= % (first x)) x))))\n  ([x y] (if (= 0 (count (drop-while #(= % (first y)) y)))\n           (reverse (cons (into '() (take-while #(= % (first y)) y)) x))\n           (pack\n            (cons (into '() (take-while #(= % (first y)) y)) x)\n            (drop-while #(= % (first y)) y)))\n   ))","user":"5dd90651e4b0948ae9d9ad97"},{"code":"(fn this\n  ([x] (reverse (this (rest x)\n             (list (list (first x)))\n             (first x))))\n  ([x r i]\n    (cond\n      (= '() x) r\n      (= (first x) i)\n         (recur (rest x) (conj (rest r) (conj (first r) i)) i)\n      true (recur (rest x) (conj r (list (first x))) (first x)))))","problem":31,"user":"4f038017535dcb61093f6afa"},{"problem":31,"code":"(fn [sq]\n  (reduce (fn [result elem]\n            (if (or (empty? result) (not= elem (first (last result))))\n              (conj result [elem])\n              (conj (pop result) (conj (last result) elem))))\n          []\n          sq))","user":"5b7ef8e6e4b047b03b203765"},{"code":"(fn dup [l]\n   (loop [last-sym (first l)\n          occurences 1\n          current-l (rest l)\n          builded-l []]\n     (cond\n      (not (seq current-l)) \n      (conj builded-l (repeat occurences last-sym))\n      (not= last-sym (first current-l))\n      (recur (first current-l) 1 (rest current-l) (conj builded-l\n                                                         (repeat occurences last-sym)))\n      :else\n      (recur last-sym (inc occurences) (rest current-l) builded-l))))","problem":31,"user":"531c7f0de4b08068f379eda4"},{"problem":31,"code":"(letfn [(keep-packin [running-letter running-list remainder]\n            (println (list 'keep-packin [running-letter running-list remainder]))\n            (cond\n              (empty? remainder) (list running-list)\n              (= running-letter (first remainder))\n              (keep-packin running-letter (conj running-list running-letter) (rest remainder))\n              :else (cons running-list (pack remainder))))\n        (pack [l]\n          (if (empty? l)\n            ()\n            (keep-packin (first l) (list (first l)) (rest l))))]\n  pack)","user":"573d27b4e4b05c31a32c080f"},{"problem":31,"code":"(fn pack-list    \n  ([lst]\n     (reverse (pack-list (rest lst) '() 1 (first lst)))\n     )\n    (\n     [lst reslst counter current-element]\n     (let [x (first lst) new-element (repeat counter current-element)]\n       (if (empty? lst)\n         (cons new-element reslst)       \n         (pack-list\n          (rest lst)\n          (if (= x current-element) reslst (cons  new-element  reslst) )\n          (if (= x current-element) (inc counter) 1)\n          x\n          )\n         )    \n       )\n     )\n  )","user":"550fd845e4b06e50f9beb17c"},{"code":"(fn pack [coll] \n  (if (empty? coll) \n      '()\n      (cons (take-while (partial = (first coll)) coll) \n            (pack (drop-while (partial = (first coll)) coll)))))","problem":31,"user":"50310b8be4b05b7df5a0b84d"},{"problem":31,"code":"(fn [coll]\n   (reduce\n    #(if (and (not-empty %1) (= (last (last %1)) %2))\n      (conj (vec (drop-last %1)) (conj (vec (last %1)) %2))\n      (concat %1 (list (list %2))))\n    []\n    coll))","user":"5e7fb908e4b085ba37836e3f"},{"problem":31,"code":"(fn\n  [aseq]\n  (loop [lseq aseq el (first lseq) acc []]\n    (if (empty? lseq)\n      acc\n      (let [nseq (drop-while #(= el %) lseq)]\n        (recur\n          nseq\n          (first nseq)\n          (conj acc (take-while #(= el %) lseq)))))))","user":"56cb4d06e4b0ea9b8538f72e"},{"problem":31,"code":"(fn [s]\n  (reverse\n    (reduce\n      #(if (= (first (first %1)) %2)\n         (conj (rest %1) (conj (first %1) %2))\n         (conj %1 (list %2)))\n      '()\n      s)))","user":"5e976fa8e4b0157ca96647cf"},{"problem":31,"code":"(fn [x]\n  (loop [cx x, accum [], nx []]\n    (if (empty? cx)\n      (concat nx accum)\n      (if (= (last (last accum)) (first cx))\n          (recur (rest cx) (list (conj (last accum) (first cx))) nx)\n          (recur (rest cx) (list (cons (first cx) nil)) (concat nx accum))\n       )\n     )\n   )\n  )","user":"588fb3a7e4b00487982d51b9"},{"code":"(fn [s] \n    (loop [acc [] current [] r s]\n      (cond\n        (not (seq r)) (rest (conj acc current))\n        (= (first r) (first current)) \n          (recur acc (conj current (first r)) (rest r))\n        :else \n          (recur (conj acc current) [(first r)] (rest r)))))","problem":31,"user":"4ef0a38e535dced4c769f20b"},{"problem":31,"code":"reduce\n#(if (= (-> %1 last first) %2)\n     (concat (drop-last %1)\n             (list (conj (last %1) %2)))\n     (concat %1 (list (list %2))))\n'()","user":"5112500ee4b0350614f07a72"},{"problem":31,"code":"(fn liscompress [a & [b]]\n    (cond \n      (nil? a) '(114)\n      (nil? (first a)) \n        (if (nil? (first b))\n          '(113)\n          (list b)\n        )\n      (nil? b) \n        (liscompress (rest a) (list (first a)))\n      (= (first a) (first b)) (liscompress (rest a) \n      \t(conj b (first a)))\n      (not= (first a) (first b)) (concat \n         (list b)\n         (liscompress (rest a) (list (first a))))\n      \n      :else (do (println b) (println (first a)))\n    )\n  )","user":"5e1d01b5e4b0dc9594008542"},{"code":"(fn [coll]\n  (into '() ((fn my-pack [coll res current]\n    (cond\n     (empty? coll) (conj res current)\n     (= (first coll) (first current)) (my-pack\n                                       (rest coll)\n                                       res\n                                       (conj current (first coll)))\n     :else (my-pack (rest coll) (conj res current) (list (first coll)))\n     )\n    )\n  (rest coll) '() (list (first coll))))\n  )","problem":31,"user":"518279abe4b0353c468deb65"},{"problem":31,"code":"(fn pack [coll]\n (partition-by identity coll))","user":"5a23503fe4b0ff51aa4b32d6"},{"code":"(fn pack [sq]\n  (partition-by identity sq))","problem":31,"user":"515f2a85e4b0595cf3d1da44"},{"problem":31,"code":"(fn [coll]\n  (reduce #(if (= %2 (first (first %)))\n             (apply list (update-in (vec %) [0] conj %2))\n             (cons (list %2) %)) () (reverse coll)))","user":"5512aca6e4b055c2f668d4b4"},{"code":"(fn foo[elem acc result lst]\n  (if (= nil elem)\n    (foo (first lst) acc result lst)\n  (if (empty? lst)\n    (concat result (list acc))\n    (if (= (first lst) elem)\n      (foo elem (conj acc elem) result (rest lst))\n      (foo (first lst) (list (first lst)) (concat result (list acc)) (rest lst))\n     )\n   )\n))\nnil (list) (list)","problem":31,"user":"51eec1a6e4b0871fa145d98d"},{"code":"(letfn [(fun [c] (if (empty? c) nil (let [f (first c) [p s] (split-with #(= f %) c)] (cons p (fun s))  )))] fun)","problem":31,"user":"51729002e4b044b2ef48a850"},{"problem":31,"code":"(fn [col] \n  (let [recursor \n        (fn recurs [out prev counter in] \n          (if \n            (empty? in) \n            (concat out (list (vector prev counter))) \n            (if \n              (= prev (first in)) \n              (recurs out prev (+ 1 counter) (rest in)) \n              (recurs \n               (concat out (list (vector prev counter))) \n               (first in) \n               1 \n               (rest in)\n               )\n              )\n            )\n          )\n        ]\n    (map\n     (fn [[k v]]\n       (replicate v k)\n       )\n    (recursor '() (first col) 0 col))))","user":"58950f29e4b00487982d5270"},{"problem":31,"code":"reduce #(if (= (first (last %1)) %2)\n           (concat (drop-last %1) (list (conj (last %1) %2)))\n           (concat %1 (list (list %2))))\n        ()","user":"5d05fdece4b0cc9c915881e8"},{"code":"(fn [xs]\n  (reverse \n    (loop [res '()\n           cur '()\n           src xs]\n      (if (empty? src)\n        (conj res cur)\n        (if (= (first src) (last cur))\n          (recur res (conj cur (first src)) (rest src))\n          (if (empty? cur)\n            (recur res (conj cur (first src)) (rest src))\n            (recur (conj res cur) (list (first src)) (rest src))))))))","problem":31,"user":"525ab6cfe4b0cb4875a45cf9"},{"problem":31,"code":"(fn [sq] \n((fn pack [res group sq] \n  (let [nxt (first sq)\n        same (=(first group)nxt)]\n  (if (empty? sq)\n    (conj res group)\n    (pack\n      (if same res \n        (conj res group))\n      (if same \n        (conj group nxt)\n        [nxt])\n      (rest sq))\n    )))\n[] [(first sq)] (rest sq)))","user":"56366f73e4b0bfe05bf117cc"},{"problem":31,"code":"#(reverse (reduce\n     (fn [acc e]\n       (let [cur (first acc)]\n         (if (= e (first cur))\n           (cons (cons e cur) (rest acc))\n           (cons (list e) acc))))\n               '() %))","user":"5745bb9fe4b009280f9f2b54"},{"problem":31,"code":"(fn [s]\n  (reduce #(if (= %2 (last (last %1)))\n             (concat (reverse (rest (reverse %1))) [(concat (last %1) [%2])])\n             (concat %1 [[%2]])) [[(first s)]] (rest s)))","user":"5535d34be4b09218d5f44fb0"},{"problem":31,"code":"(fn [s]\n  (loop [acc [] sublist [] x s]\n    (cond \n     (= 0 (count x)) (if (> (count sublist) 0)\n                       (conj acc sublist)\n                       sublist)\n     (= 0 (count sublist)) (recur acc [(first x)] (rest x))\n     (= (first sublist) (first x)) (recur acc (conj sublist (first x)) (rest x))\n     (not (= (first sublist) (first x))) (recur (conj acc sublist) [] x)\n     )))","user":"52a803cee4b0c58976d9ac26"},{"code":"(fn pack-seq [a-seq]\n  \n   ((fn do-pack [el  rest-seq cnt  result]\n        (if (seq rest-seq)\n             (let [next-el (first rest-seq)]\n                  (if (= el next-el)\n                      (recur next-el (rest rest-seq) (inc cnt) result)\n                      (recur next-el (rest rest-seq) 1 (conj result (apply list (repeat cnt el))))\n                   )\n              )\n              ;-- rest-seq is empty\n              (reverse (conj result (apply list (repeat cnt el))))\n         )\n    ) (first a-seq) (rest a-seq) 1 () )\n )","problem":31,"user":"52763696e4b03e8d9a4a74d7"},{"code":"#(partition-by list %)","problem":31,"user":"4e7e93f5535db169f9c7971a"},{"problem":31,"code":"(fn pack [myseq]\n         (let [[all-but-last-pack last-pack _]\n               (reduce (fn [[result current-pack last-element] current-element]\n                         (if (= last-element current-element)\n                           [result                     (conj current-pack current-element) current-element]\n                           [(conj result current-pack) [current-element]                   current-element]))\n                       [[] [(first myseq)] (first myseq)]\n                       (rest myseq))]\n           (conj all-but-last-pack last-pack)))","user":"5455510fe4b0e397800069df"},{"code":"#(loop [coll (rest %)\n       c  (list (first %))\n       r  '()]\n  (if (seq coll)\n    (if (= (first c) (first coll))\n      (recur (rest coll) (conj c (first coll)) r)\n      (recur (rest coll) (list (first coll)) (concat r (list c))))\n    (concat r (list c))))","problem":31,"user":"5151c184e4b03e678e393add"},{"problem":31,"code":"(fn p [s]\n  (if (empty? s)\n    s\n    (conj (p (drop-while (partial = (first s)) s)) (take-while (partial = (first s)) s))))","user":"54dbcbbde4b024c67c0cf774"},{"problem":31,"code":"(fn [s]\n  (reduce\n   #(if (= %2 (first (peek %1)))\n      (conj (pop %1) (conj (peek %1) %2))\n      (conj %1 (vector %2))\n      )\n   []\n   s))","user":"589e704ae4b02bd94d917e5e"},{"code":"(fn [c] (partition-by identity c))","problem":31,"user":"51631002e4b017b283c712c1"},{"code":"(fn conseq [coll]\n   (if (not-empty coll)\n   (let [sub (take-while (partial = (first coll)) coll)]\n     (cons sub (conseq (subvec coll (count sub)))))))","problem":31,"user":"515896f2e4b059418b97f0a8"},{"problem":31,"code":"(fn [xs] (loop [result [] match [(first xs)] list (rest xs)]\n  (if (= 0 (count list))\n    (conj result match)\n    (if (= (first match) (first list))\n      (recur result (conj match (first list)) (rest list))\n      (recur (conj result match) [(first list)] (rest list))\n    ))))","user":"55d79b87e4b0e31453f64aa8"},{"problem":31,"code":"(fn [v] (partition-by identity v))","user":"52d84ea7e4b09f7907dd1390"},{"problem":31,"code":"(fn pck [s]\n  (partition-by identity s))","user":"53b39d82e4b047364c0444a6"},{"code":"(fn [s]\r\n  (reverse (reduce\r\n    (fn [r c]\r\n      (let [l (first r)]\r\n        (if (or (empty? l) \r\n                (not= (first l) c))\r\n          (conj r (list c))\r\n          (conj (rest r) (conj l c)))))\r\n    '() s)))","problem":31,"user":"4dee4a9c535d08e6dec9fe11"},{"code":"(fn [x] \n  (partition-by identity x))","problem":31,"user":"4eb8ec4a535dfed6da9c6d4b"},{"code":"(fn [v] (let [n (dec (count v))]\n       (loop [i 0 \n\t\t    [s t] [[(v 0)] []]\n\t\t   ]\n\t\t(if (= i n) (conj t s)\n\t\t    (let [a (v i) b (v (inc i))]\n\t\t        (recur (inc i) (if (= a b) [(conj s b) t]\n\t\t\t\t   [[b] (conj t s)])))))))","problem":31,"user":"4e6e3a1e535d5021c1a89602"},{"problem":31,"code":"(fn [inp]\n  (loop [res []\n         inp inp]\n    (let [inp-parts (split-with #(= (first inp) %) inp)]\n      (if (empty? inp)\n        res\n          (recur\n           (conj res (first inp-parts))\n           (second inp-parts))\n          )\n      )))","user":"592334c7e4b0a390037439ee"},{"code":"(fn mypack                                  \n  [coll]                                      \n  (loop [curr '() acc '() [x & more] coll]    \n    (if (nil? x)                              \n      (reverse (conj acc curr))               \n      (if (or (empty? curr)                   \n              (= x (first curr)))             \n        (recur (conj curr x) acc more)        \n        (recur (list x) (conj acc curr) more) \n        )                                     \n      )                                       \n    )                                         \n  )","problem":31,"user":"50573ed8e4b0012181721987"},{"code":"reduce #(let [l1 (last %1)] \n          (if (= \n               (last l1) %2) \n            \t(concat (butlast %1) (list (conj l1 %2)))\n            \t(concat %1 (list (list %2))))) ()","problem":31,"user":"51bf4560e4b013aa0d74b817"},{"code":"(fn p [x] (partition-by identity x))","problem":31,"user":"4eeb8f68535d93acb0a668a9"},{"problem":31,"code":"partition-by #(vector %)","user":"5286a2a9e4b0239c8a67ae1e"},{"code":"(fn [col]\r\n(rest\r\n(reverse\r\n(reduce \r\n    #(if (= (first (first %1)) %2 )\r\n        (cons (cons %2 (first %1) ) (rest %1) )  \r\n        (cons (cons %2 '()) %1 )\r\n      )\r\n    '(())\r\n    col\r\n  )\r\n)\r\n)\r\n)","problem":31,"user":"4f6d9d7ee4b07046d9f4efcd"},{"problem":31,"code":"#(loop [col % item (first col) sub-list [item] rt []]\n   (if(empty? col)\n     rt\n     (let [new-col (rest col) new-item (first new-col)] (recur  new-col new-item (if(= item new-item) (conj sub-list new-item) [new-item]) (if(not (= item new-item)) (conj rt sub-list) rt ) ))\n     )\n   )","user":"5d270111e4b092dab7f59c62"},{"code":"(fn [coll]\n  (loop [coll coll acc []]\n    (if (empty? coll)\n      acc\n      (let [group (take-while #{(first coll)} coll)]\n        (recur\n         (drop (count group) coll)\n         (conj acc group))))))","problem":31,"user":"507b7dbee4b09034bfeeb71e"},{"code":"(fn pck [x]\n   (let [rep #(take %2 (iterate identity %))] \n     (loop [res []\n            coll x\n            cnt 0\n            last (first coll)]\n       (let [fe (first coll)\n             re (rest coll)]\n         (if (seq coll)\n           (if (= last fe)\n             (recur res re (+ cnt 1) last)\n             (recur (conj res (rep last cnt)) re 1 fe))\n           (conj res (rep last cnt)))))))","problem":31,"user":"4ef57a7f535dced4c769f246"},{"problem":31,"code":"(fn [x]\n      (loop [i 1 c [(first x)] r nil]\n            (if (= i (count x))\n              (concat r [c])\n              (if (not= (first c) (nth x i))\n                (recur (inc i) [(nth x i)] (concat r [c]))\n                (recur (inc i) (conj c (nth x i)) r)\n                )\n              )\n            )\n      )","user":"550e0373e4b06e50f9beb162"},{"problem":31,"code":"(fn pack [a-seq]\n  (let [packer (fn [t-seq] (split-with #(= (first t-seq) %) t-seq))\n        [x y] (packer a-seq)]\n    (if (empty? a-seq) '() (cons x (pack y)))))","user":"5877a553e4b01531a375eaa5"},{"problem":31,"code":"(fn [xs]\n    (loop [xx (rest xs)\n         h (first xx)\n         r [[(first xs)]]]\n    (if (empty? xx)\n      (reverse r)\n      (recur (rest xx)\n             (first (rest xx))\n             (if (= h (first (first r)))\n               (cons (cons h (first r)) (rest r))\n               (cons [h] r))))))","user":"503c90aae4b06c4e0e1fa24b"},{"code":"(fn [coll]                                                               \n  (if (seq coll)                                                                \n    (let [s (first coll)]                                                       \n      ((fn f [cur-pack coll]                                                    \n         (if (seq coll)                                                         \n           (let [elem (first coll)]                                             \n             (if (= elem (first cur-pack))                                      \n               (recur (cons elem cur-pack) (rest coll))                         \n               (lazy-seq (cons cur-pack (f (list elem) (rest coll))))))         \n           (lazy-seq (cons cur-pack nil))))                                     \n         (list s) (rest coll)))))","problem":31,"user":"4ec75077535d6d7199dd36e0"},{"code":"reduce (fn [acc x] (if (= (last (last acc)) x)\n                      (concat (butlast acc) [(concat (last acc) [x])])\n                      (concat acc [[x]])\n                    ))\n        []","problem":31,"user":"5216933be4b000d124d989cf"},{"code":"(fn [l] \n  (loop [other (rest l)\n         dups [(first l)]\n         res '()]\n    (if (nil? (first other)) (concat res [dups])\n      (if (= (first dups) (first other))\n        (recur (rest other)\n               (concat dups [(first other)])\n               res)\n        (recur (rest other)\n               [(first other)]\n               (concat res [dups]))))))","problem":31,"user":"533ee560e4b085b17e897d98"},{"code":"(fn collect-similar [inp]\n  (reverse (reduce (fn [a b]\n             (let [front-list (first a)\n                   rest-list (rest a)\n                   elem (first front-list)]\n               (if (= elem b) (conj rest-list (conj front-list b)) (conj a (list b)))))\n               '() inp)))","problem":31,"user":"52d1fb80e4b099d49816f0a5"},{"problem":31,"code":"(fn [coll] (loop [c coll l (first coll) crnt '() o '()]\n             (if (empty? c)\n               (reverse (conj o crnt))\n               (let [x (first c)]\n                 (recur (rest c)\n                        x\n                        (if (= x l)\n                          (conj crnt x)\n                          (list x))\n                        (if (= x l)\n                          o\n                          (conj o crnt)))))))","user":"56d5fd24e4b0ea9b8538f7c5"},{"code":"(fn [xs]\n  (if (seq xs)\n    (loop [ys (rest xs)           \n           zs []\n           ws [(first xs)]]\n      \t(if (seq ys)\n          (if (= (first ys) (first ws))\n            (recur (rest ys) zs (conj ws (first ys)))\n            (recur (rest ys) (conj zs ws) [(first ys)]))\n          (conj zs ws)))\n    nil))","problem":31,"user":"511442d0e4b0e9c109bb74d5"},{"code":"(fn [c]\n  (loop [xe c, prev (first xe) miniResult '(), res []]\n    (if (seq xe)\n      (if (= (first xe) prev)\n        (recur (rest xe) prev (cons prev miniResult) res)\n        (recur (rest xe) (first xe) (list (first xe)) (conj res miniResult)))\n      (conj res miniResult))))","problem":31,"user":"4dcc2435535d5973398f9290"},{"problem":31,"code":"(fn [x]\n  (loop [input-list x\n         output-list []\n         last-element nil\n         backlog []]\n    (cond\n      (and (empty? input-list) (nil? last-element)) output-list\n      (and (empty? input-list) (empty? backlog)) (recur [] (concat output-list [[last-element]]) nil [])\n      (empty? input-list) (recur [] (concat output-list [backlog]) nil [])\n      (nil? last-element) (recur (rest input-list) output-list (first input-list) backlog)\n      (and (= last-element (first input-list)) (empty? backlog)) (recur (rest input-list) output-list last-element (concat backlog [last-element] [(first input-list)]))\n      (= last-element (first input-list)) (recur (rest input-list) output-list last-element (concat backlog [(first input-list)]))\n      (empty? backlog) (recur (rest input-list) (concat output-list [[last-element]]) (first input-list) [])\n      :else (recur (rest input-list) (concat output-list [backlog]) (first input-list) [])\n    )\n  )\n)","user":"5550dad4e4b00713264bd9b0"},{"code":"(fn pack [s]\n  (cond\n    (= 1 (count s)) (list s)\n    (= (first s)\n      (ffirst (pack (rest s))))\n      (cons \n        (cons \n          (first s) \n          (first (pack (rest s))))\n        (rest (pack (rest s))))\n    :else\n      (cons\n        (list (first s))\n        (pack (rest s)))))","problem":31,"user":"504e48ace4b0f6ff3350c498"},{"problem":31,"code":"(fn [args] \n   (reverse (into '() (partition-by (fn [n]n) args))))","user":"54f36b36e4b050824f58f5c2"},{"code":"(fn[s] (partition-by identity s))","problem":31,"user":"4ec64981535d6d7199dd36c7"},{"problem":31,"code":"(fn my-pack [coll]\n      (loop [coll coll\n             acc []]\n        (if (empty? coll)\n          acc\n          (recur (drop-while #(= % (first coll)) coll)\n                 (conj acc (take-while #(= % (first coll)) coll))))))","user":"54a6baaee4b09f271ff37c8a"},{"code":"reduce \n#(if (-> %1 last last (= %2))\n  (concat (butlast %1)\n    (-> %1 last (conj %2) list))\n  (concat %1 (-> %2 list list))) ()","problem":31,"user":"50387196e4b0803468ea2c6e"},{"code":"(fn dupman [coll]\n  (let [dfn (fn ifn [c seen]\n    (lazy-seq\n      (letfn [(indup [col s]\n        (let [f_el (first col)]\n          (if (not f_el)\n            (if (empty? s)\n              nil\n              (cons s (ifn (rest col) '())))\n            (if (or(some #(= % f_el) s)(empty? s))\n              (recur (rest col) (cons f_el s))\n              (cons s (ifn (rest col) (list f_el)))))))]\n        (indup c seen))))]\n   (dfn coll '())))","problem":31,"user":"4f61be97e4b0defedf855fc5"},{"code":"(fn my-seq-pack [s]\n  (if (empty? s) nil\n    (let [p #(= % (first s))]\n      (lazy-seq (cons (take-while p s) (my-seq-pack (drop-while p s)))))))","problem":31,"user":"52bc6f5ee4b07a9af57922f6"},{"problem":31,"code":"(fn [rawInput]\n\n  (loop [previous nil\n\n         sequence (seq rawInput) \n\n         result []\n\n         subList '()]\n\n    (if (= 0 (count sequence))\n\n      (seq (conj result subList))\n\n      (let [curr (first sequence)] \n\n        (if (or (nil? previous) (= previous curr))\n\n          (recur\n\n            curr\n\n            (rest sequence)\n\n            result\n\n            (concat subList (list curr)))            \n\n          (recur\n\n            curr\n\n            (rest sequence)\n\n            (conj result subList)\n\n            (list curr)))))))","user":"59c5093ce4b0a024fb6ae50c"},{"code":"reduce \n     (fn [s x] \n       (if (= x (last (last s))) \n         (conj (pop s) (conj (last s) x))\n         (conj s [x])\n       )\n       )\n      []","problem":31,"user":"514457fbe4b0b4fb4ace5f43"},{"code":"(fn pack [x] \n  (if (empty? x) \n     '()\n     (let [firstAdd (take-while #(= (first x) %) x)]\n       (cons firstAdd (pack (drop (count firstAdd) x))))\n     ))","problem":31,"user":"525cc137e4b0cb4875a45d46"},{"code":"(fn [z] (loop [x (seq z) las [] ans []]\r\n  (cond (some #{(first x)} las) \r\n    (if (next x) \r\n      (recur (next x) \r\n          (conj las (first x)) \r\n              (conj (pop ans) (seq (conj las (first x))))) \r\n     (seq (conj (pop ans) (seq (conj las (first x)))))) \r\n    :else (if (next x)\r\n      (recur (next x) [(first x)] (conj ans (list (first x))))\r\n    (seq (conj ans (list (first x)))))\r\n  )\r\n))","problem":31,"user":"4e15c301535d04ed9115e7e5"},{"problem":31,"code":"(fn pack [coll]\n  (loop [remaining (reverse coll)\n         result '()]\n    (if (empty? remaining)\n      result\n      (let [[subset the-rest](split-with (fn [n] (= n (first remaining))) remaining)]\n        (recur the-rest (cons subset result))))))","user":"57c0917be4b05aa3c4741c95"},{"problem":31,"code":"(fn pack\n  [col]\n  \n  (let [sub (fn [col]\n  (cond\n     (<= (count col) 1) col\n     :else\n         (loop [result (empty col) col col]\n           (let [x1 (first col) x2 (first (rest col))]\n             (if (= x1 x2) (recur (cons x1 result) (rest col)) (cons x1 result) )\n           )\n         )\n   )) ]\n  (reverse (loop [result (list) col col]\n    (let [sub-list (sub col)] \n    (if (empty? sub-list) result (recur (cons sub-list result) (drop (count sub-list) col) ))\n    )\n  ))\n)\n)","user":"547b4ec6e4b0c51c1f4d72d5"},{"code":"(fn [a] (reverse (reduce #(if (= %2 (ffirst %1)) (cons (cons %2 (first %1)) (rest %1)) (cons (list %2) %1)) '() a)))","problem":31,"user":"532c0507e4b09d4e7a9b553c"},{"problem":31,"code":"(fn ps [c]\n  (if (= 1 (count c))\n    (list c)\n    (let [packed (ps (rest c))]\n      (if (= (first c) (first (first packed)))\n        (cons (cons (first c) (first packed)) (rest packed))\n        (cons (list (first c)) packed)))))","user":"54bd9a60e4b0ed20f4ff6ee3"},{"problem":31,"code":"(fn packseq [vec]\n  \"return sequence with consecutive duplicates into sublists\"\n  (if (empty? vec) () \n  (concat (list (repeat ((fn numrep [[frst & others]]\n  \"return number of consecutive duplicates from the start of a sequence\"\n  (cond\n    (nil? frst) 0\n    (empty? others) 1\n    (= frst (first others)) (+ 1 (numrep others))\n    :else 1\n  ))\n vec) (first vec))) (packseq (subvec vec ((fn numrep [[frst & others]]\n  \"return number of consecutive duplicates from the start of a sequence\"\n  (cond\n    (nil? frst) 0\n    (empty? others) 1\n    (= frst (first others)) (+ 1 (numrep others))\n    :else 1\n  ))\n vec))))\n  ))","user":"5d828b7ee4b0915913b1d382"},{"code":"(fn pack [xs]\n  (if (empty? xs)\n    ()\n  \t(cons (take-while (partial = (first xs)) xs) (pack (drop-while (partial = (first xs)) xs)))))","problem":31,"user":"4f03641a535dcb61093f6a9b"},{"problem":31,"code":"(fn [coll]\n  (reduce\n   #(let [a (reverse (if (= (last (last %1)) %2) (conj (reverse (drop-last %1)) (conj (last %1) %2)) (conj (reverse %1) (list %2))))] (println a) a)\n   [(list (first coll))] \n   (drop 1 coll))\n  )","user":"5dc9c4f2e4b02f9375f4e1f0"},{"problem":31,"code":"#(reduce (fn [xs x]\n          (if (= x (last (apply concat (seq xs))))\n            (concat (drop-last xs) (list (conj (last xs) x)))\n            (concat xs (list (list x)))\n           )\n          ) () %\n   )","user":"54258e71e4b01498b1a71b0e"},{"code":"(fn pack [x]\n     (if (empty? x)\n       nil\n       (let [f (take-while (fn [y] (= (first x) y)) x)\n             r (drop-while (fn [y] (= (first x) y)) x)]\n         (println f)\n         (println r)\n         (println \"-\")\n         (concat\n           [f]\n           (pack r)))))","problem":31,"user":"503efe01e4b06c4e0e1fa26f"},{"problem":31,"code":"#(reduce (fn [result item] \n           (if \n             (empty? result) \n             [[item]]\n             (if \n               (some (fn [i] (= item i)) (last result))\n               (conj (apply vector (reverse (rest (reverse result)))) (conj (last result) item) )\n               (into result [[item]])\n             )\n           )\n         )\n []\n %\n )","user":"5680fff3e4b0966858e4d8f6"},{"code":"partition-by (fn [x] x)","problem":31,"user":"4e6f8d36535d5021c1a89621"},{"problem":31,"code":"(fn pack [coll]\n  (loop [coll coll\n         packed []]\n    (if (empty? coll)\n      packed\n      (let [group (take-while #(= (first coll) %) coll)]\n        (recur (drop (count group) coll) (conj packed group))))))","user":"5d68f5e6e4b0db5d338d1605"},{"problem":31,"code":"(fn pack\n  [lst]\n  (if (empty? lst) ()\n                   (loop [elem (conj () (last lst))\n                          lst (butlast lst)\n                          result ()]\n                     (cond\n                       (empty? lst) (conj result elem)\n                       (= (last elem) (last lst) ) (recur (conj elem (last lst))\n                                                          (butlast lst)\n                                                          result)\n                       :else (recur (conj () (last lst))\n                                    (butlast lst)\n                                    (conj result elem))))))","user":"59e4e3cbe4b08badc2a0c54a"},{"problem":31,"code":"(fn pack-seq [lst]\n  (loop [result [] lst lst]\n    (if (empty? lst)\n      result\n      (let [[asn res] (split-with (partial = (first lst)) lst)]\n        (recur (conj result asn) res)))))","user":"570e6974e4b0b0fb43fd06ef"},{"code":"(fn [x] \n    (reduce (fn [a b] \n              (if (= (peek (peek a)) b)\n                (assoc a (dec (count a)) (conj (peek a) b))\n                (conj a [b]))\n              )\n            (vector \n             (vector (first x))\n              )\n            (vec (rest x)))\n    )","problem":31,"user":"528ce039e4b0239c8a67aebc"},{"code":"(fn [x]\n  (loop [i 1 prev (nth x 0) out [] recent (list (nth x i))]\n    (if (== i (count x))\n      (conj out recent)\n      (if (= prev (nth x i))\n        (recur (inc i) prev out (conj recent (nth x i)))\n        (recur (inc i) (nth x i) (conj out recent) (list (nth x i)))))))","problem":31,"user":"4e955b95535dbda64a6f6b33"},{"code":"(fn pack- [coll]\n  \"31. Write a function which packs consecutive duplicates into sub-lists.\"\n  (let [[head tail] (split-with #(= (first coll) %) coll)]\n    (if (empty? tail)\n      (list head)\n      (cons head (pack- tail)))))","problem":31,"user":"4e5eb843535d8a8b8723a2d4"},{"problem":31,"code":"(fn pack [s]\n  (if (empty? s) () (conj (pack (drop ((fn same [s]\n  (if (empty? s) 0 (if (= (first s) (first (rest s))) (+ 1 (same (rest s))) 1))) s) s)) \n                          \n                          \n                          \n                          \n                          (take ((fn same [s]\n  (if (empty? s) 0 (if (= (first s) (first (rest s))) (+ 1 (same (rest s))) 1))) s) s))))","user":"56df6351e4b0ca2494a095f3"},{"code":"#(reduce (fn [o i] (if (= (last (last o)) i) (conj (vec (butlast o)) (conj (last o) i)) (conj o [i]))) [] %)","problem":31,"user":"4e58c019535d8a8b8723a297"},{"code":"(fn part [lst]\n  (partition-by identity lst))","problem":31,"user":"52e16139e4b09f7907dd141f"},{"problem":31,"code":"(fn [dups]\n  (loop [dl dups cg [] res []]\n    (if (empty? cg)\n      (if (empty? dl)\n        res\n        (recur (next dl) [(first dl)] res)\n      )\n      (if (empty? dl)\n        (conj res cg)\n        (if (= (first dl) (first cg))\n          (recur (next dl) (conj cg (first dl)) res)\n          (recur (next dl) [(first dl)] (conj res cg))\n        )\n      )\n    )\n  )\n)","user":"57873017e4b0ebec4cfb7503"},{"code":"(fn pack [coll]\n  (partition-by identity coll))","problem":31,"user":"4e95a440535dbda64a6f6b37"},{"code":"(fn [input]\n    (loop [results [], current (), elts input]\n      (if (empty? elts)\n        (if (empty? current)\n          results\n          (conj results current))\n        (if (= (first elts) (last current))\n            (recur results (conj current (first elts)) (rest elts))\n            (recur (if (not (empty? current)) (conj results current) results) (list (first elts)) (rest elts))))))","problem":31,"user":"502940a9e4b061fd216be4b8"},{"problem":31,"code":"(fn foo \n  [coll]\n  (map\n    #(into '() %)\n    (reduce \n    (fn [acc v] \n      (let [last-group (last acc)\n            last-group-el (first last-group)] \n        (prn \"acc: \" acc \"v: \" v)\n        (if (= v last-group-el) \n        (conj (into [] (butlast acc)) (conj last-group v)) \n        (conj acc (vector v))\n        ))) \n    [] \n    coll))\n  )","user":"59f44189e4b0966464fe6aab"},{"problem":31,"code":"(fn [coll]\n  (loop [r [] xs coll]\n    (if (first xs)\n      (recur (conj r (take-while #(= % (first xs)) xs))\n             (drop-while #(= % (first xs)) xs))\n      r)))","user":"51dafedee4b09f6bc204eee2"},{"code":"reduce\n  #(if (= (first (last %1)) %2)\n    (conj (into [] (butlast %1)) (conj (last %1) %2))\n    (concat %1 [[%2]])\n  )\n  []","problem":31,"user":"507eddf4e4b06ce648bcdbfa"},{"code":"(fn c [s]\n  (reverse\n    (reduce #(if (empty? %1) [[%2]]\n              \t(let [[[v & n :as f] & r] %1]\n               \t\t(if (= v %2)\n                 \t\t(conj r (conj f %2))\n                 \t\t(conj %1 [%2]))))\n            '() s)))","problem":31,"user":"5175533fe4b0dea9bbfba575"},{"code":"(fn [l]\n  (loop [last_seq '()         \n         all_seqs '() \n         [f & args :as my-l] l\n         last-elem f]\n    (if (empty? my-l)\n      (if (empty? last_seq)\n        all_seqs\n        (concat all_seqs (list last_seq)))\n      (if (= last-elem f)\n        (recur (cons f last_seq) all_seqs args f)\n        (recur (list f) (concat all_seqs (list last_seq)) args f)))))","problem":31,"user":"4f7e29dde4b06e829148e1ca"},{"problem":31,"code":"#(loop [x (drop-last %) o '() i (conj '() (last %))]\n   (if (empty? x) \n     (conj o i) \n     (if (= (last x) (first i))\n       (recur (drop-last x) o (conj i (last x)))\n       (recur (drop-last x) (conj o i) (conj '() (last x))))))","user":"5f3567d6e4b0574c87022c44"},{"problem":31,"code":"(fn pack [s]\n  (loop [result []\n         xs s]\n    (if (empty? xs)\n      result\n      (let [item (first xs)\n            group (take-while #(= % item) xs)\n            len (count group)]\n        (recur (conj result group) (subvec xs len))))))","user":"5dcc152ae4b02b31cc3da3c3"},{"code":"(fn [s]\n  (->> [nil s]\n       (iterate (fn [[_ remaining]] (split-with #(= (first remaining) %) remaining)))\n       (map first)\n       (rest)\n       (take-while not-empty)))","problem":31,"user":"51a3b135e4b0e77c4ca60bf6"},{"problem":31,"code":"(fn [coll]\n  (loop [coll coll\n         result []]\n    (if (empty? coll)\n      result\n      (let [[packed rest] (split-with #(= % (first coll)) coll)]\n       (recur rest (conj result packed))))))","user":"5f02f365e4b0cf489e8d7f2c"},{"code":"(fn [s]\n  (loop [rr [] p (first s) r 1 ss (rest s)]\n    (if (empty? ss)\n      (conj rr (repeat r p))\n      (let [f (first ss)] \n        (if (not= f p)\n          (recur (conj rr (repeat r p)) f 1 (rest ss))\n          (recur rr p (inc r) (rest ss)))))))","problem":31,"user":"4e5c801e535d8a8b8723a2c1"},{"problem":31,"code":"#(loop [i 1\n        acc [[(nth % 0)]]]\n\t\t\t\t(if \n\t\t\t\t    (>= i (count %))\n        acc\n        (if \n            (not (= (nth (last acc) 0) (nth % i)))\n            (recur (+ 1 i) (concat acc [[(nth % i)]]))\n            (recur (+ 1 i) (concat (butlast acc) [(conj (last acc) (nth % i))]))\n            )\n\t\t\t\t    )\n    )","user":"5dd44256e4b0948ae9d9ad69"},{"code":"(fn pack [lst]\n  (loop [A (rest lst), result nil, Q (list (first lst))]\n    (let [same (= (first A) (first Q))]\n      (if (empty? A)\n        (reverse (cons Q result))\n        (recur \n          (rest A)\n          (if same result (cons Q result))\n          (if same (cons (first A) Q) (list (first A))))))))","problem":31,"user":"4faa9593e4b081705acca1f9"},{"code":"(fn [xs]\r\n  (loop [rest* xs\r\n         result* []\r\n         last* nil]\r\n      (if (empty? rest*)\r\n          result*\r\n          (recur (rest rest*)\r\n             (if (= last* (first rest*))\r\n                (conj (vec (drop-last result*)) (conj (last result*) (first rest*)))\r\n                (conj result* (vector (first rest*))))\r\n            (first rest*))\r\n          )))","problem":31,"user":"4eeae8f0535d93acb0a668a2"},{"code":"(fn [s]\n  (loop [seq s dups '()]\n    (if (not-empty seq)\n      (let [item (first seq)]\n        ;(println seq \" \" item \" \" dups)\n        (recur (rest seq)\n               (if (and (not-empty dups) (= (distinct (last dups)) (list item)))\n                 (concat (or (butlast dups) (list)) (list (concat (last dups) (list item))))\n                 (concat dups (list (list item)))\n                 )\n               ))\n      dups))\n  )","problem":31,"user":"4eaf1342535d7eef30807330"},{"problem":31,"code":"(fn p [s]\n  (when-first [f s]\n    (cons (take-while #(= f %) s)\n          (p (drop-while #(= f %) s)))))","user":"53ea5851e4b036ad0777e4e4"},{"code":"(fn [a] (partition-by identity a))","problem":31,"user":"4f47eab2e4b0d56e7bb92bc6"},{"problem":31,"code":"(fn pack [input]\n  (reverse\n    (reduce\n      #(if (= (first (first %1)) %2)\n         (conj (drop 1 %1) (conj (first %1) %2))\n         (conj %1 (list %2)))\n      [] input)))","user":"5a0ef454e4b04bbd27e6d9fa"},{"problem":31,"code":"#(reverse (reduce (fn[[h & hs :as f] x]\n                    (if (= x (first h))\n                      (conj hs (conj h x)) \n                      (conj f [x]))) [] %))","user":"578e5750e4b0ebec4cfb7581"},{"code":"#(loop \r\n    [orig-list % buffer '() packed-list '()]\r\n        (println \"o: \" orig-list) (println \"b: \" buffer)\r\n\r\n    (cond\r\n      (and (empty? orig-list) (empty? buffer)) packed-list\r\n      (empty? buffer) (recur (next orig-list) \r\n                             (list (first orig-list)) packed-list) \r\n      (= (first orig-list) (first buffer))\r\n          (recur (next orig-list) (concat buffer [(first orig-list)]) \r\n            packed-list)\r\n      true (recur orig-list '() (concat packed-list (list buffer)))\r\n    )\r\n )","problem":31,"user":"4fe588b6e4b0e8f79898fec5"},{"code":"#(let \n   [[acc sub-acc item]\n     (reduce\n       (fn [[acc sub-acc cur] item]\n         (if (= cur item)\n           [acc (conj sub-acc item) item]\n           [(conj acc sub-acc) [item] item]))\n       [[] [] (first %)] \n       %)\n   ]\n   (conj acc sub-acc))","problem":31,"user":"5245fbbbe4b09dbe66b56183"},{"problem":31,"code":"(fn my-partition [coll]\n  (reduce (fn [p x]\n            (let [l (last p)]\n              (if (seq l)\n                    (if (= (last l) x)\n                      (conj (pop p) (conj l x))\n                      (conj p [x]))\n              (conj p [x]))))\n          [] coll))","user":"5370d152e4b0fc7073fd6e9d"},{"problem":31,"code":"(fn f [coll]\n  (loop [input coll output []]\n    (if (empty? input)\n      output\n      (if (= (first input) (first (last output)))\n      \t(recur (rest input) (conj (vec (butlast output)) (conj (last output) (first input))))\n        (recur (rest input) (conj (vec output) (list (first input))))\n      )\n    )\n  )\n)","user":"53beacf9e4b0d9a98559a6e3"},{"problem":31,"code":"(fn [l]\n   (loop [l l\n          acc []\n          group []\n          p nil]\n     (if (empty? l) (if (empty? group) acc (conj acc group))\n         (if (or (nil? p) (= p (first l)))\n           (recur (drop 1 l) acc (conj group (first l)) (first l))\n           (recur (drop 1 l) (conj acc group) [(first l)] (first l))))))","user":"595bbab7e4b066ee0a44afe0"},{"code":"(fn gper [x] \n \t(if (not-empty x)\n \t\t (concat [(take-while #(= (first x) %) x)] (gper (drop-while #(= (first x) %) x)))))","problem":31,"user":"51f4d46ee4b0fca5e8b48243"},{"problem":31,"code":"(fn packman\n  ([ls] (packman ls []))\n  ([ls res] \n   (if (empty? ls)\n     res\n     (let [to-add (first ls)\n           last-group (last res)\n           xs (rest ls)\n           index (dec (count res))]\n       (cond \n        (= to-add (first last-group)) (packman xs (update-in res [index] #(conj % to-add))) \n        :else (packman xs (conj res (list to-add))))))))","user":"5d48884ee4b07c84aa5ae6bb"},{"code":"(fn pack [lst]\n  (let \n    [pack_ (fn pack_ [x cnt lst]\n    (cond\n     (empty? lst) (list (take cnt (repeat x)))\n     (= x (first lst)) (pack_ (first lst) (+ 1 cnt) (rest lst))\n     true (cons (take cnt (repeat x)) (pack_ (first lst) 1 (rest lst)))))]\n    (pack_ (first lst) 1 (rest lst))\n    ))","problem":31,"user":"52091d57e4b0e152394d76f0"},{"code":"(fn deduplicator-list\n   [s]\n   (seq (reduce (fn\n      [a b]\n      (let [all-others (vec (butlast a))\n             last-list (last a)\n             last-value (first last-list)]                          \n      (if (and (sequential? last-list) (= last-value b))\n        (conj all-others (cons b last-list)) \n        (conj a (list b)))))\n        \n   [] s))\n)","problem":31,"user":"53951c75e4b0b51d73faaed4"},{"code":"reduce #(if (= (first (last %1)) %2) (conj (pop %1) (conj (last %1) %2)) (conj %1 (list %2))) '[]","problem":31,"user":"50ba5113e4b03e68e4411c7d"},{"problem":31,"code":"(fn pck \n  ([l] (pck l []))\n  ([l result]\n    (if (empty? l)\n      result\n      (let [ [ pref r] (split-with (partial = (first l)) l)] \n        (recur r (conj result pref))) ) ) )","user":"54d6f22de4b0a52adc2e2023"},{"problem":31,"code":"(fn [cc] (let [take-while1 (fn [x c] (take-while #(= x %) c))\n       fv (fn [c e] (if (empty? c) e \n                      (let [fe (first c) \n                            a (take-while1 fe c) \n                            r (drop (count a) c)] (recur r (conj e a)))))] \n   (fv cc [])))","user":"50856bd1e4b004985b776e4c"},{"problem":31,"code":"#(loop [s (rest %)\n         sub-seq [(first %)]\n         packed []]\n    (if (empty? s)\n      (conj packed sub-seq)\n      (let [next-item (first s)]\n        (if (= next-item (first sub-seq))\n          (recur (rest s) (conj sub-seq next-item) packed)\n          (recur (rest s) [next-item] (conj packed sub-seq))))))","user":"56b9c644e4b0f2655033593a"},{"code":"partition-by (fn[x] x)","problem":31,"user":"4fc7b079e4b0ee37620e1827"},{"code":"(fn [original_args]\r\n  (reverse\r\n    (loop [\r\n        args original_args\r\n        current_token nil\r\n        accumulator '()\r\n      ]\r\n      (cond\r\n         (empty? args) accumulator\r\n         (nil? current_token) (recur (rest args) (first args) (cons (list (first args)) accumulator))\r\n         (= current_token (first args))\r\n           (recur (rest args) current_token (cons (cons current_token (first accumulator)) (rest accumulator)))\r\n         :else\r\n           (recur (rest args) (first args) (cons (list (first args)) accumulator))\r\n      )\r\n    )\r\n  )\r\n)","problem":31,"user":"4e1ec17a535d04ed9115e80a"},{"problem":31,"code":"#(loop [lst % prev (first lst) result () temp ()]\n   (if (empty? lst) (reverse (conj result temp))\n     (if (= (first lst) prev) (recur (rest lst) prev result (conj temp (first lst)))\n       ; not equal to last\n       (recur (rest lst) (first lst) (conj result temp)  (conj () (first lst))))))","user":"58cd4949e4b03c36ff7e5886"},{"code":"(fn [x]\n    (letfn [(foo [xs group]\n        (if (empty? xs)\n            (list group)\n            (let [c (first xs)\n                  g (first group)]\n                (if (= c g)\n                    (recur (rest xs) (cons c group))\n                    (cons group (foo (rest xs) (list c)))))))]\n        (foo (rest x) (list (first x)))))","problem":31,"user":"52f182d8e4b05e3f0be25eed"},{"problem":31,"code":"(fn deduper [input] \n  (loop [in input\n         out []]\n   (if (empty? in)\n    out\n    (recur (drop-while \n             #(= (first in) %) (rest in))\n           (conj out (take-while #(= (first in) %) in))))))","user":"56391b7ce4b0bfe05bf117ef"},{"code":"(fn get-sublists [list]\n  (let [split-list (split-with #(= % (first list)) list)]\n    (cond\n     (empty? split-list) '()\n     (empty? (second split-list)) (conj '() (first split-list))\n     :else (concat (conj '() (first split-list)) (get-sublists (second split-list)))\n     )))","problem":31,"user":"51508efce4b0c51f0585bbb4"},{"code":"(fn pack [s]\n  (if (empty? s)\n    s\n    (loop [dups '(), cur (first s), se s]\n      (if (= cur (first se))\n        (recur (cons cur dups), cur, (rest se))\n        (cons dups (pack se))))))","problem":31,"user":"52ec1dfbe4b0705949c4444b"},{"code":"(fn [input] (partition-by identity input))","problem":31,"user":"51c214bce4b0d204dbe2ca1c"},{"code":"(fn [s]\n    (reduce\n      #(if (= (peek (peek %1)) %2)\n          (into (pop %1) [(into (peek %1) [%2])])\n          (into %1 [[%2]]))\n        [[(first s)]] (rest s)))","problem":31,"user":"4e8e8c24535d65386fec2143"},{"problem":31,"code":"(fn [s]\n (partition-by identity s))","user":"5ee685ffe4b029a2061bbe99"},{"code":"(fn pack\n  ([items] (pack items [] []))\n  ([items cur output]\n    (if (empty? items)\n      (if (empty? cur)\n        output\n        (conj output cur))\n      (if (empty? cur)\n          (pack (rest items) (conj cur (first items)) output)\n        (if (= (first items) (last cur))\n          (pack (rest items) (conj cur (first items)) output)\n          (pack (rest items) (list (first items)) (conj output cur))\n)))))","problem":31,"user":"4fd9d162e4b05e33b9224f3c"},{"problem":31,"code":"(fn dedup\n  ([xs]\n   (dedup [] xs))\n  ([acc xs]\n   (if (empty? xs)\n     acc\n     (if (= (last (last acc)) (first xs)) \n       (dedup (conj (vec (butlast acc)) (conj (last acc) (first xs))) (rest xs))\n       (dedup (conj acc [(first xs)]) (rest xs))))))","user":"579563ffe4b0e215f87e847e"},{"code":"(fn [s] (reverse (reduce (fn [acc e] (cond (= (first (first acc)) e) (cons (cons e (first acc)) (rest acc))\n                                       :else (cons [e] acc))) [] s)))","problem":31,"user":"50dfb660e4b061dbdced7228"},{"code":"(partial partition-by (fn [x] x))","problem":31,"user":"4f251302e4b0d66497709ff0"},{"problem":31,"code":"(fn p\n  [lst]\n  (partition-by identity lst))","user":"5723e6d6e4b0c5bde472c0f1"},{"problem":31,"code":"(fn [xs] (partition-by max xs))","user":"541b41d1e4b01498b1a71a65"},{"problem":31,"code":"(fn\n   [coll]\n   (if (empty? coll)\n      coll\n      (loop [result (list (list (first coll)))\n             remain (rest coll)]\n        (if (empty? remain)\n            (reverse result)\n           (if (= (first (first result)) (first remain))\n             (recur (cons (cons (first remain) (first result)) (rest result)) (rest remain))\n             (recur (cons (list (first remain)) result) (rest remain)))))))","user":"5aa4a1ffe4b0d174b936c886"},{"problem":31,"code":"(fn [xs]\n  (reduce\n\t(fn [a e]\n      (cond\n        (empty? a) [[e]]\n      \t(= (last (last a)) e) (conj (pop a) (conj (last a) e))\n        :else (conj a [e])))\n    []\n   \txs))","user":"5e98e8a9e4b0157ca96647dc"},{"code":"(fn [s]\n  ((fn iter [s-in s-out sub]\n    (if (empty? s-in)\n      (conj s-out sub)\n      (if (= (first s-in) (last sub))\n        (iter (rest s-in) s-out (conj sub (first s-in)))\n        (if (empty? sub)\n          (iter (rest s-in) s-out [(first s-in)])\n          (iter (rest s-in) (conj s-out sub) [(first s-in)])))))\n  s [] []))","problem":31,"user":"4fe8e771e4b0547ebccb2431"},{"code":"#(reverse (reduce (fn [r x] (if (= (first (first r)) x)\n                     (cons (cons x (first r)) (rest r))\n                     (cons (list x) r))) '() %))","problem":31,"user":"4f067029535dcb61093f6c12"},{"code":"(fn pack [coll]\r\n  (letfn [(pack* [[f & r :as S] acc]\r\n            (when (seq S)\r\n              (let [[packed tail] (split-with {f true} S)]\r\n                (if (seq tail)\r\n                  (recur tail (conj acc packed))\r\n                  (conj acc packed)))))]\r\n(pack* coll [])))","problem":31,"user":"4dd579b5535dae65d5c462ea"},{"problem":31,"code":"(fn\n  [coll]\n  (loop [coll coll\n         new-coll []\n         sub-coll []]\n    (if (empty? coll)\n      (rest (conj new-coll sub-coll))\n      (let [coll-elem (first coll)\n            sub-coll-elem (first sub-coll)]\n        (if (= coll-elem sub-coll-elem)\n          (recur (rest coll) new-coll (conj sub-coll coll-elem))\n          (recur (rest coll) (conj new-coll sub-coll) [coll-elem]))))))","user":"5720a2b0e4b0c5bde472c099"},{"problem":31,"code":"#(->> % (partition-by identity) (seq ))","user":"5501de12e4b07d26eda61d7b"},{"code":"(fn pack [s]\n  (reverse (reduce #(if (= %2 (first (first %1))) \n                        (conj (rest %1) (conj (first %1) %2))\n                        (conj %1 (list %2))) () s)))","problem":31,"user":"4f0f40d3535d0136e6c2233b"},{"code":"(fn [s]\n  (reverse \n  \t(loop [results '() xs s]\n      (if (empty? xs) results\n        (if (or (empty? results) (not= (first xs) (first (first results))))\n          (recur (cons (cons (first xs) '()) results) (rest xs))\n          (recur (cons (cons (first xs) (first results)) (rest results)) (rest xs)))))))","problem":31,"user":"52199105e4b0c4ef0be82ff9"},{"problem":31,"code":"(fn [x]\n  (reduce\n   (fn [y z]\n     (if (and (not (empty? y)) (= z (first (last y))))\n       (concat (drop-last y) [(conj (last y) z)])\n       (concat y [[z]])))\n   '()\n   x))","user":"57458b82e4b009280f9f2b4e"},{"problem":31,"code":"(fn collectadjacent\n\t[xyz]\n\t(if (empty? xyz)\n\t\t'()\n\t\t(cons \n\t\t\t(take-while #(= % (first xyz)) xyz) \n\t\t\t(collectadjacent (drop-while #(= % (first xyz)) xyz)))\n\t)\n)","user":"56449e4de4b0284900eef5f9"},{"problem":31,"code":"(comp reverse\n      (partial reduce\n               (fn [memo el]\n                 (if (= (ffirst memo) el)\n                   (conj (rest memo) (conj (first memo) el))\n                   (conj memo (list el))))\n               '()))","user":"59fa241ee4b0ca45a743a358"},{"problem":31,"code":"(fn [x]\n     (reduce (fn [r e]\n               (if (= e (last (last r)))\n                 (assoc r (- (count r) 1) (conj (last r) e))\n                 (conj r (list e))\n                 )) [] x))","user":"554b2151e4b0a04f79299580"},{"problem":31,"code":"(fn solve [coll]\n  (if (= (count coll) 1)\n    (list (list (first coll)))\n    (let [ret (solve (rest coll))]\n      (if (= (first coll) (first (first ret)))\n        (cons (cons (first coll) (first ret)) (rest ret))\n        (cons (list (first coll)) ret)))))","user":"55058a4fe4b086ebe8a79c89"},{"code":"(fn packsec [xs]\r\n  (if (empty? (next xs))\r\n    (if (seq? (first xs))\r\n      xs\r\n      (list xs))\r\n    (if (not (seq? (first xs)))\r\n      (packsec (conj (next xs) (list (first xs))))\r\n      (if (= (ffirst xs) (fnext xs))\r\n        (packsec (conj (nnext xs) (conj (first xs) (fnext xs))))\r\n        (conj (packsec (next xs)) (first xs))))))","problem":31,"user":"4dd023dd535d5973398f92ad"},{"code":"(fn [l]\r\n  ((fn x [l acc]\r\n    (cond\r\n      (not (sequential? l))     l\r\n      (empty? l)                (list acc)\r\n      (empty? acc)              (x (rest l) (list (first l)))\r\n      (= (first acc) (first l)) (x (rest l) (conj acc (first l)))\r\n      :else                     (conj\r\n                                  (x (rest l) (list (first l)))\r\n                                  acc)))\r\n    l ()))","problem":31,"user":"4fd153cee4b04c3a95aa040e"},{"problem":31,"code":"(fn [x] (loop [s x bu '() acc '()] \n          (if (nil? (first s)) (reverse (conj acc bu))\n               (recur (rest s) \n                      (if (or (empty? bu) (= (first bu) (first s)))\n                      \t(conj bu (first s))\n                      \t(list (first s))\n                      )\n                      (if (or (empty? bu) (= (first bu) (first s)))\n               \t\t  \tacc\n                      \t(conj acc bu)\n               \t\t  ))\n             )\n           )\n          )","user":"5471f2fbe4b094393f72dd70"},{"problem":31,"code":"(fn pack [data]\n  (let [[x & xs] data]\n    (if (nil? x)\n      nil\n      (cons (take-while #(= x %) data) (pack (drop-while #(= x %) xs)))\n    )\n  )\n)","user":"5225a0f5e4b01819a2de430e"},{"code":"(fn [x]\r\n  (loop [input x output '()]\r\n    (if (seq input)\r\n      (let [a (first input) b (take-while (partial = a) (rest input)) c (drop-while (partial = a) (rest input))]\r\n        (recur c (cons (cons a b) output)))\r\n      (reverse output))))","problem":31,"user":"4fc34787e4b081705acca33e"},{"problem":31,"code":"(fn [s]\n  (reverse (\n   reduce #(if (= (first (first %1)) %2) (conj (rest %1) (conj (first %1) %2)) (conj %1 (list %2))) '() s\n   )))","user":"598229d6e4b021a7a535fdfb"},{"problem":31,"code":"(let [duped (fn [xs x] \n             (= (set xs)\n                (set (concat xs [x]))))\n      iter (fn [acc x]\n             (let [la (last acc)\n                   bla (or (butlast acc) '())]\n               (cond \n                (nil? la) \n                \t(concat bla [(list x)])\n                (duped la x) \n                \t(concat bla [(concat la [x])]) \n                :else \n                \t(concat bla [la] [(list x)]))))]\n  #(reduce iter '() %)\n)","user":"5bb17123e4b0a20761a234fd"},{"problem":31,"code":"#(loop [acc [] l nil coll %] (if (seq coll) (let [f (first coll) ll (last (last acc))] (recur (if (= f ll) (assoc acc (dec (count acc)) (conj (last acc) f)) (conj acc (conj [] f))) f (rest coll))) acc))","user":"58dcae01e4b0a4d5acaab6a4"},{"problem":31,"code":"(fn [coll]\n  (reduce\n   (fn [[h & t :as l] el]\n     (if (and (seq h) (= (first h) el))\n       (cons (cons el h) t)\n       (cons (list el) l)))\n   []\n   (reverse coll)))","user":"5c15537ae4b01240ff5671bf"},{"code":"(fn [x]\n  ((fn [a p r]\n    (if (= '() r)\n(reverse (conj a p))\n(if (= (first r) (first p))\n(recur a (conj p (first r)) (rest r))\n(recur (conj a p)\n(list (first r)) (rest r)))))\n'() (list (first x)) (rest x)))","problem":31,"user":"4ed2b168535d44c135fd68dd"},{"problem":31,"code":"(fn jp [x] \n  (if \n    (empty? x) \n    () \n    (cons \n      (take-while #(= (first x) %) x) \n      (jp (drop (count  (take-while #(= (first x) %) x)) x)))))","user":"544e1794e4b0e39780006980"},{"problem":31,"code":"(fn [col]\n  (loop [output [] current-group [] remaining col]\n    (if (empty? remaining)\n      (conj output current-group)\n      (if (or (empty? current-group)\n              (= (first current-group) (first remaining)))\n        (recur output (conj current-group (first remaining)) (rest remaining))\n        (recur (conj output current-group) [] remaining)))))","user":"56877fcbe4b0dcc4269f405e"},{"code":"(fn foo [input]\n    (loop [x input\n          retval '()\n          cluster '()]\n          (if (empty? x)\n              (reverse retval)\n              (recur (rest x)\n                     (if (= (first x) (second x))\n                          retval\n                          (cons (cons (first x) cluster) retval))\n                     (if (=( first x) (second x))\n                         (cons (first x) cluster)\n                         '())))))","problem":31,"user":"4e6a60cd535d8ccf87e9fed7"},{"problem":31,"code":"(fn [gs] (reduce (fn [[s1 & sr :as s] x]\n                   (if (= x (first s1))\n                     (conj sr (conj s1 x))\n                     (conj s (list x)))) '() (reverse gs)))","user":"5571d6e5e4b09a3098a5253f"},{"code":"#(loop [lst % acc '()] \n  (cond\n   (empty? lst) (reverse acc)\n   (= (first lst) (second lst) (second (rest lst)))\n   (recur (rest (rest (rest lst)))\n          (cons (repeat 3 (first lst)) acc))\n   (= (first lst) (second lst))\n   (recur (rest (rest lst)) (cons (repeat 2 (first lst)) acc))\n   :default \n   (recur (rest lst) (cons (repeat 1 (first lst)) acc))))","problem":31,"user":"51bd255ce4b0df1216cefd94"},{"code":"(fn packer [coll]\n  (if (seq coll)\n    (let [head (first coll)]\n      (conj (packer (drop-while #(= head %) coll))\n            (take-while #(= head %) coll)))\n    ()))","problem":31,"user":"4eda7cc3535d10e5ff6f530e"},{"problem":31,"code":"#(loop [coll % results '()]\n   (if (empty? coll)\n     (reverse results)\n     (recur (drop-while (fn [x] (= x (first coll))) coll)\n            (cons (take-while (fn [x] (= x (first coll))) coll) results))))","user":"55e2f502e4b050e68259b43c"},{"problem":31,"code":"(fn [xs] (reduce #(if (some (fn [x] (= x %2)) (first %1))\n          (conj (rest %1) (conj (first %1) %2))\n          (conj %1 (list %2)))\n        (list) (reverse xs)))","user":"5097ea89e4b087ccf61a7af4"},{"code":"(fn packduplicates [x]\n  (let [equiv (fn [coll elem]\n                (if (and (seq coll) (= elem (first (peek coll))))\n                  (conj (pop coll) (conj (peek coll) elem))\n                  (conj coll  (vector elem))))]\n    (reduce equiv [] x)))","problem":31,"user":"532727bae4b09d4e7a9b54fa"},{"problem":31,"code":"(fn f [s] (partition-by identity s)\n)","user":"55229495e4b0882d96d091a4"},{"code":"(fn pack-seq [x] (partition-by identity (vec x)))","problem":31,"user":"51fa7154e4b0f1313d4689da"},{"problem":31,"code":"(fn [listy]\n      (reverse (reduce\n       (fn halper [a b]\n       (prn a b)\n       (prn (first a))\n         (cond\n           (empty? a) (conj a [b])\n           (= (first (first a)) b) (conj (rest a) (conj (first a) b))\n           :else (conj a [b])\n           )\n           ) (list) listy)))","user":"5da71a00e4b000c986472c14"},{"problem":31,"code":"(fn packer [s]\n  (loop [done []\n         todo s]\n    (if (empty? todo) (seq done)\n      (let [[subl todo-next] (split-with (partial = (first todo)) todo)]\n      \t(recur (conj done subl) todo-next)))))","user":"5d929ceae4b0915913b1d412"},{"problem":31,"code":"#(-> ;; ugly\n  (reduce (fn [acc x]\n            (if (not (some #{x} (first acc)))\n              (cons (list x) acc)\n              (let [hd (-> (first acc) reverse)\n\t              \ttl (rest acc)]\n                (cons (-> (cons x hd) reverse) tl)))) '() %1)\n    reverse)","user":"55e246c2e4b050e68259b431"},{"code":"(fn pack-seq \r\n  ([coll] (pack-seq coll []))\r\n  ([coll aux]\r\n  (when-let [[f & r] (seq coll)]\r\n    (if (= f (first r))\r\n      (pack-seq r (conj aux f))\r\n      (cons (seq (conj aux f)) (pack-seq r []))))))","problem":31,"user":"4f625f68e4b0defedf855fd2"},{"code":"(fn [s]\r\n     (reverse ((fn [s d c] \r\n                 (if (nil? s)\r\n                   (if (nil? c)\r\n                     d\r\n                     (cons c d))\r\n                   (let [s1 (first s)\r\n                         c1 (first c)]\r\n                     (if (= c1 s1)\r\n                       (recur (next s) d (cons s1 c))\r\n                       (recur (next s) (cons c d) (list s1)))))) (next s) nil (list (first s)))))","problem":31,"user":"4f359c7ee4b0e243712b1ec4"},{"code":"(fn[coll] (partition-by identity coll))","problem":31,"user":"51a768e0e4b0da5f497bde84"},{"problem":31,"code":"(fn [ls]\n  (reverse (reduce #(cond (= (first (first %1)) %2) (conj (rest %1) (conj (first %1) %2)) :else (conj %1 [%2])) [] ls))\n  )","user":"60228147e4b0d5df2af22202"},{"code":"(fn [r]\n  \t((fn f [c r]\n       \t(if (empty? r)\n          \t(list c)\n  \t\t(if (= (first r) (first c))\n      \t\t\t(f (cons (first r) c) (rest r))  \n      \t\t\t(cons c (f (list (first r)) (rest r)))\n      \t\t)\n        )\n    \t\n  \t) (list (first r)) (rest r))\n   )","problem":31,"user":"5149c2f1e4b0829bd132edb0"},{"problem":31,"code":"(fn [coll] (#(partition-by identity %) coll))","user":"585c16c3e4b0f14aab7c877d"},{"problem":31,"code":"#(loop [col %\n         result '()]\n       (if (empty? col)\n          (reverse result)\n           (recur (rest col)\n                  (if (or (empty? result) (not(some (partial = (first col)) (first result))))\n                      (conj result (list(first col)))\n                       (conj (rest result) (conj (first result) (first col)))))))","user":"57bf304de4b05aa3c4741c75"},{"code":"(fn pack [input]\n    (partition-by identity input)\n)","problem":31,"user":"51d1111ce4b067c36548635f"},{"code":"(fn r\n  ([xs] (r (rest xs) (list (list (first xs)))))\n  ([xs acc]\n     (if (empty? xs)\n       acc\n       (if (= (first xs) (last (last acc)))\n         (r (rest xs) (concat (butlast acc) (list (concat (list (first xs)) (last acc)))))\n         (r (rest xs) (concat (butlast acc) (concat (list (last acc)) (list (list (first xs))))))))))","problem":31,"user":"4fb510b5e4b081705acca2b8"},{"problem":31,"code":"#(loop [h (first %)\n        top nil\n        r (rest %)\n        out []]\n    (println out)\n   (cond (nil? h) out\n         (= top h) \n         (recur (first r) h (rest r)\n                (conj (vec (butlast out)) \n                      (conj (last out) h)))\n         :else\n         (recur (first r) h (rest r)\n                (conj out [h]))))","user":"56f51879e4b046a417f92069"},{"code":"(fn [s]\n  (letfn\n    [(pack-first [s]\n      (let [item (first s)]\n        (loop [result [], remainder s]\n          (cond\n            (empty? remainder)\n              {:result result, :remainder remainder},\n            (= item (first remainder))\n              (recur\n                (conj result item)\n                (rest remainder)),\n            :else\n              {:result result, :remainder remainder}))))]\n    (loop [result [], items s]\n      (if\n        (empty? items)\n        result\n        (let\n          [packed (pack-first items),\n           bucket (get packed :result),\n           remainder (get packed :remainder)]\n          (recur\n            (conj result bucket)\n            remainder))))))","problem":31,"user":"4f5c0549e4b0030a34fb2b1a"},{"problem":31,"code":"#(reduce\n\t(fn [l r]\n\t\t(if (= l r)\n\t\t\t[(seq [l r])]\n\t\t\t(if (= (last (last l)) r)\n\t\t\t\t(concat (drop-last l) [(concat (last l) [r])])\n\t\t\t\t(concat l [(seq [r])])\n\t\t\t)\n\t\t)\n\t)\n\t%\n)","user":"55fc8f1fe4b0f488688e0675"},{"code":"(fn f\n  ([l] (f l [] []))\n  ([[l & ls] r c]\n   (if l\n     (if (or (empty? c) (= l (first c)))\n       (recur ls r (conj c l))\n       (recur ls (conj r c) [l]))\n     (conj r c))))","problem":31,"user":"52753740e4b03e8d9a4a74c1"},{"code":"(partial reduce (fn [xs x] (let\n                             [ys (last xs)\n                              y  (last ys)\n                              zs (-> xs butlast vec)]\n                             (if (= x y)\n                               (conj zs (conj ys y))\n                               (conj (if (empty? ys) zs xs) [x]))))\n         [[]])","problem":31,"user":"51307b84e4b08c712d3fae39"},{"problem":31,"code":"(fn [s]\n    (if (seq s)\n      (reverse (reduce\n        (fn [r n]\n          (if (= n (first (first r)))\n            (conj (rest r) (conj (first r) n))\n            (conj r (list n))))\n        (list (list (first s))) (rest s)))\n    s))","user":"5d8b4960e4b0915913b1d3d3"},{"code":"#(reverse \n  (reduce \n    (fn [acc, item] \n      (if (not= (ffirst acc) item)                        \n        (conj acc (list item))     \n        (conj (rest acc) (conj (first acc) item))\n        )\n      ) \n    () \n    %\n    ) \n  )","problem":31,"user":"513f53c6e4b051389b345b40"},{"code":"(fn hoge [lst]\n  (if (empty? lst) nil\n    (let [h (first lst) f (partial = h)]\n      (cons (take-while f lst) (hoge (drop-while f lst))))))","problem":31,"user":"5272669de4b03e8d9a4a742e"},{"code":"(fn pack [s]\n  (loop [current-s s\n         accum []]\n    (if (empty? current-s)\n      accum\n      (let [current-element (first current-s)\n            is-current-element? #(= current-element %)]\n        (recur\n          (drop-while is-current-element? current-s)\n          (conj accum (take-while is-current-element? current-s))\n)))))","problem":31,"user":"53527551e4b084c2834f4af0"},{"problem":31,"code":"reduce (fn [r x]\n          (cond\n            (= (last r) x) (conj (vec (butlast r)) (list x x))  \n            (and (coll? (last r))\n                 (= (first (last r)) x))\n            (conj (vec (butlast r)) (cons x (last r)))\n            :default (conj r (list x)))) []","user":"6022429be4b0d5df2af22200"},{"code":"#(loop [result []\n\t\ttemp '()\n\t\tremaining %]\n\t\t(let [[current & rest] remaining]\n\t\t(if (nil? current)\n\t\t\t(conj result temp)\n\t\t\t(if (or (empty? temp) (= current (first temp)))\n\t\t\t\t(recur result (conj temp current) rest)\n\t\t\t\t(recur (conj result temp) (list current) rest)))))","problem":31,"user":"528147b6e4b0757a1b171425"},{"problem":31,"code":"reduce (fn [x y]\n         (if (= y (first (last x)))\n           (concat (drop-last x) (list (concat (last x) (list y))))\n           (concat x (list (list y))))) '()","user":"59663e77e4b069c0a1a1979f"},{"code":"(fn f [x] (partition-by identity x))","problem":31,"user":"500e7063e4b04a05d36fcc07"},{"problem":31,"code":"(fn \n  [xs]\n  (partition-by identity xs))","user":"54c72b19e4b045293a27f636"},{"problem":31,"code":"(fn f [l] \n  (if (empty? l) '()  (loop [outlist (list (first l)) newl (rest l)] \n            \t(if (= (first newl) (first outlist))\n            \t\t(recur (conj outlist (first outlist)) (rest newl))\n            \t\t(concat (list outlist) (f newl))))))","user":"5d2ca236e4b01671435dbc94"},{"code":"(fn [x]\n  (partition-by identity x))","problem":31,"user":"4db016af838c48654951d9b9"},{"code":"(fn  [x]\n  (reduce\n   (fn [l x]\n     (if (empty? l)\n       [[x]]\n       (if (= (last (last l)) x)\n         (conj (vec (butlast l)) (conj (last l) x))\n         (conj l [x])\n       )\n     ))\n   []\n   x\n   )\n  )","problem":31,"user":"51980f7ce4b068aa333628f7"},{"problem":31,"code":"(fn pack-duplicates\n  [s]\n  (reverse\n    (reduce (fn [acc i]\n            (let [[f & r] acc]\n              (if (= (first f) i)\n                (conj r (cons i f))\n                (conj acc (list i)))))\n          nil s)))","user":"5777c3d6e4b0979f8965164f"},{"problem":31,"code":"(fn [ls]                                                                                                                                                                                     \n  (if (seq ls)                                                                                                                                                                               \n    ((fn [xs lh ys rs]                                                                                                                                                                       \n       (if (seq xs)                                                                                                                                                                          \n         (let [xh (first xs)]                                                                                                                                                                \n           (if (= xh lh)                                                                                                                                                                     \n             (recur (rest xs) lh (conj ys xh) rs)                                                                                                                                            \n             (recur (rest xs) xh (list xh) (conj rs ys))))                                                                                                                                   \n         (reverse (conj rs ys))))                                                                                                                                                            \n     ls (first ls) '() '())                                                                                                                                                                \n    '()))","user":"543897e7e4b032a45b869314"},{"problem":31,"code":"(fn [seq] (loop [suffix (rest seq) packed [] sublist (list (first seq))] (if (empty? suffix) (conj packed sublist) (if (= (first suffix) (first sublist)) (recur (rest suffix) packed (conj sublist (first suffix))) (recur (rest suffix) (conj packed sublist) (list (first suffix)))))))","user":"5e1cc888e4b0dc959400853d"},{"code":"#(loop [lst (rest %), pack [(first %)] out []]\n    (cond\n     (and (empty? lst) (not= (last out) pack)) (conj out pack)\n     (empty? lst) out\n     (= (first lst) (first pack)) (recur (rest lst) (conj pack (first lst)) out)\n     :else (recur (rest lst) [(first lst)] (conj out pack)) ))","problem":31,"user":"4ec5c81f535d6d7199dd36b6"},{"code":"(fn pack-coll [coll]\n  (partition-by identity coll))","problem":31,"user":"4f1c2a3a535d64f603146480"},{"problem":31,"code":"(fn [x]\n  (loop [result [] sub-list [(first x)] i 1]\n    (if (= i (count x))\n      (conj result sub-list)\n      (if (= (nth x (dec i)) (nth x i))\n        (recur result (conj sub-list (nth x i)) (inc i))\n        (recur (conj result sub-list) [(nth x i)] (inc i))))))","user":"56288ccae4b00e49c7cb47ea"},{"problem":31,"code":"(fn [coll]\n  (loop [c coll sublist nil accum nil]\n    (if (empty? c) (reverse (conj accum sublist))\n      (let [first-of-c (first c)\n            first-of-sublist (first sublist)]\n        (if (= first-of-c first-of-sublist)\n          (recur (rest c) (conj sublist first-of-c) accum)\n          (recur (rest c) (list first-of-c)\n                 (if (empty? sublist) accum \n                   (conj accum sublist))))))))","user":"55f6e7ece4b06e875b46ce9e"},{"problem":31,"code":"(fn [s]\n((fn pck [v tv s c]\n  (let [f (first s)\n        r (rest s)]\n    (if (nil? f) (seq (conj v (seq tv))) (if (= f c) (pck v (conj tv f) r c) (pck (conj v (seq tv)) [f] r f)))))\n[] [] s (first s)))","user":"562b1a7be4b058fa18c5a6cb"},{"problem":31,"code":"(fn [sr]   \n    (\n      (fn [input result]      \n        (if (empty? input)\n          (reverse result)\n          (if (== 0 (compare (first input) (first (first result))))\n            (recur (rest input) (cons (cons (first input) (first result)) (rest result)))\n            (recur (rest input) (cons (list (first input)) result)\n                   )\n            )\n          )\n        )\n      (rest sr) (list(list (first sr))) \n      )\n    )","user":"55034bf0e4b086ebe8a79c6d"},{"code":"(fn fart [s]\n  (cond\n   (empty? s) s\n   :else\n     (cons \n       (take-while #(= (first s) %) s)\n       (fart (drop-while #(= (first s) %) s)))))","problem":31,"user":"508dbd56e4b0f17d83ea26c2"},{"code":"(fn [s]\n  (loop [in s\n         out []]\n    (if (seq in)\n      (let [f (first in)\n            same? #(= f %)]\n        (recur (drop-while same? in)\n               (conj out (take-while same? in))))\n      out)))","problem":31,"user":"51460e4ce4b04ef915e37314"},{"code":"(fn [s]\n  (letfn [(pack ([s] (pack (rest s) (first s) 1 []))\n                ([s cur occ acc]\n                  (let [[h & t] s]\n                    (if (nil? h)\n                      (conj acc (repeat occ cur))\n                      (if (= cur h)\n                        (recur t h (inc occ) acc)\n                        (recur t h 1 (conj acc (repeat occ cur))))))))]\n (pack s)))","problem":31,"user":"4e68b46c535d8ccf87e9fe87"},{"problem":31,"code":"(fn [s] (reduce (fn [v i]\n                  (if (= (last (last v)) i)\n                    (update-in v [(- (count v) 1)] into [i])\n                    (into v [(seq [i])])\n                    ))\n                []\n                s))","user":"57a9e274e4b0b8559636fc5d"},{"problem":31,"code":"(fn [s]\n    (loop [s s\n           e (first s)\n           n (first (next s))\n           sub-list nil\n           result []]\n      (if-not (seq s)\n        result\n        (if (= e n)\n          (recur (next s)\n                 (first (next s))\n                 (first (next (next s)))\n                 (conj (or sub-list []) e)\n                 result)\n          (recur (next s)\n                 (first (next s))\n                 (first (next (next s)))\n                 nil\n                 (if (seq sub-list)\n                   (conj result (conj sub-list e))\n                   (conj result [e])\n                   ))))))","user":"5a5d0726e4b0512ff01cd91b"},{"problem":31,"code":"(fn pack\n\t[arr]\n\t(loop [[x1 x2 & t] arr cur [] final []]\n\t\t(if (nil? x2)\n\t\t\t(conj final (conj cur x1))\n\t\t\t(if (= x1 x2)\n\t\t\t\t(recur (conj t x2) (conj cur x1) final)\n\t\t\t\t(recur (conj t x2) [] (conj final (conj cur x1)))\n\t\t\t\t)\n\t\t\t)\n\t\t)\n\t)","user":"5545477fe4b0a04f79299531"},{"problem":31,"code":"(fn [L]\n    (loop [Ret '() CurGroup '() First (first L) Rest (rest L) ]\n      (if (nil? First)\n        ;; вернем, что нашли, добавив текущую группу, если она не пустая\n        (if (nil? CurGroup)\n          Ret\n          (reverse (conj Ret CurGroup))\n        )\n        ;; идем на повтор - расширяем текущую группу, или начинаем новую\n        (recur\n          ;; если текущий элемент соответствует группе, или группа пуста, то список возврата пока не меняем\n          (if (or (= First (first CurGroup)) (nil? (first CurGroup)))  \n            Ret\n            (conj Ret CurGroup)\n          )\n          ;; если текущий элемент соответствует группе, или группа пуста, то пополним ее\n          ;; иначе начнем новую группу\n          (if (or (= First (first CurGroup)) (nil? (first CurGroup)))  \n            (conj CurGroup First)\n            (list First)\n          )\n          (first Rest)\n          (rest Rest)\n        )\n      )\n    )\n  )","user":"5d4a6c6ce4b0776584bd6f22"},{"problem":31,"code":"(partial partition-by identity )","user":"5a43347ee4b0447ef91cc603"},{"code":"#(loop [consecutives %\n        res '()\n        sublist '()]\n   (if (empty? consecutives)\n     (concat res (list sublist))\n     (if (or (empty? sublist) (= (first sublist) (first consecutives)))\n       (recur (rest consecutives) res (cons (first consecutives) sublist))\n       (recur (rest consecutives) (concat res (list sublist)) (list (first consecutives))))))","problem":31,"user":"51d360d1e4b099f3b6acddff"},{"problem":31,"code":"reduce (fn l [b a] (if (= a (last (last b))) (assoc b (- (count b) 1) (conj (last b) a)) (conj b (conj '() a))) ) '[]","user":"55ac16a0e4b03311e7b73291"},{"problem":31,"code":"(fn [coll]\n  (loop [out '()\n         in coll]\n    (if (empty? in)\n      out\n      (let [w (split-with #(= (first in) %) in)]\n        (recur (concat out (list (w 0))) (w 1))))))","user":"578d459ee4b0ebec4cfb7567"},{"code":"#(loop [r [], from 0, cur 1, len (count %), e (first %)]\n    (if (= cur len)\n      (conj r (repeat (- cur from) e))\n      (if (= e (nth % cur))\n      \t\t(recur r, from, (inc cur), len, e)\n      \t\t(recur (conj r (repeat (- cur from) e)), cur, (inc cur), len, (nth % cur))\n      \t\t)))","problem":31,"user":"51eca2ace4b069f463c22cd0"},{"code":"(fn [lst] (rest (reverse (reduce \n\t\t(fn [xs n] \n\t\t\t(if (= (first (first xs)) n) \n\t\t\t\t(cons (cons n (first xs)) (rest xs))\n\t\t\t\t(cons (list n) xs )\n\t\t\t)\n\t\t) \n\t\t(list ())\n\t\tlst))))","problem":31,"user":"51558136e4b06c5f6a1490a8"},{"problem":31,"code":"(fn pack-me\n      ([lst]\n       (pack-me (rest lst) (-> (first lst) vector vector)))\n      ([lst nlst]\n       (if (empty? lst)\n         nlst\n         (if (= (-> nlst last last) (first lst))\n           (pack-me (rest lst) (assoc nlst (- (count nlst) 1) (conj (last nlst) (first lst))))\n           (pack-me (rest lst) (conj nlst (vector (first lst))))))))","user":"5938bca5e4b02506e01a29eb"},{"problem":31,"code":"(fn\n\t[arg]\n    (reduce #(if (= %2 (last (last %1)))\n                (into [] (conj (into [] (butlast %1)) (into [] (conj (last %1) %2))))\n                (into [] (conj %1 (into [] (list %2))))\n                )\n            []\n            arg))","user":"53d6b266e4b0e771c3025459"},{"problem":31,"code":"(fn [input]\n   (loop\n       [acc [(first input)]\n        ret []\n        rst (rest input)]\n     (let [fst (first rst)\n           inrest (rest rst)]\n       (cond (empty? rst) (conj ret acc)\n             (= fst (first acc)) (recur (conj acc fst) ret inrest)\n             :else (recur [fst] (conj ret acc) inrest))))\n   )","user":"5ab07d63e4b073f1774425af"},{"problem":31,"code":"#(loop [xs % rs []]\n   (if (empty? xs)\n     rs\n     (recur (drop-while (fn [x] (= (first xs) x)) xs)\n            (conj rs (take-while (fn [x] (= (first xs) x)) xs)))))","user":"58cfbd7ae4b03c36ff7e58ba"},{"code":"#(reverse (reduce\n  (fn [ [ [list-first & list-rest :as first-list] & list-xs :as whole-list] x ]\n       (if (= list-first x)\n         (conj list-xs (conj first-list x))\n         (conj whole-list (list x))))\n'()\n%))","problem":31,"user":"502ade49e4b0614b52996120"},{"problem":31,"code":"(fn group [s]\n  (loop\n    [acc '()\n     temp-coll (list (first s))\n     rest-of-coll (rest s)]\n\n    (println acc temp-coll rest-of-coll)\n\n    (cond\n      (empty? rest-of-coll) (reverse (conj acc temp-coll))\n      (= (first temp-coll) (first rest-of-coll)) (recur acc (conj temp-coll (first rest-of-coll)) (rest rest-of-coll))\n      :else (recur (conj acc temp-coll) (list (first rest-of-coll)) (rest rest-of-coll))\n      )\n    ))","user":"576d24ede4b0979f8965155b"},{"code":"(fn [coll]\n  (reduce (fn [a b]\n            (if (= (last (last a)) b)\n              (conj (vec (butlast a)) (conj (last a) b))\n              (conj a [b])))\n          [] coll))","problem":31,"user":"4f9a7dc0e4b0dcca54ed6d0b"},{"code":"#(loop [cur '()\n         acc '()\n         col %]\n   (cond\n     (empty? col) (reverse (conj acc cur))\n     (or (empty? cur) (= (first col) (first cur))) (recur (conj cur (first col)) acc (rest col))\n     :else (recur (list (first col)) (conj acc cur) (rest col))))","problem":31,"user":"51a1659de4b00957e520db72"},{"problem":31,"code":"(fn pack\n    [list]\n    (partition-by identity list))","user":"5bcb672ee4b07a9b28b10100"},{"problem":31,"code":"(fn\n  [coll]\n  (letfn\n    [(pack-seq [coll]\n               (if (not (empty? coll))\n                 (cons\n                  (take-while\n                   #(= % (first coll))\n                   coll)\n                  (pack-seq (drop-while\n                             #(= % (first coll))\n                             coll)))))]\n    (pack-seq coll)))","user":"5f313d01e4b0574c87022c28"},{"problem":31,"code":"(comp \n (partial reduce (fn [a e] \n                   (let [z (first a)] \n                     (if (= e (first z)) \n                       (cons (cons e z) (rest a)) \n                       (cons (list e) a)))) '()) \n reverse)","user":"549cc867e4b0f3d1d8e70f8f"},{"problem":31,"code":"#(loop [items % a nil result []]\n   (if (empty? items)\n     result\n     (let [f (first items)\n           r (rest items)\n           lr (last result)\n           bl (vec (butlast result))]\n       (if (= f a)\n         (recur r a (conj bl (conj lr f)))\n         (recur r f (conj result (vector f)))\n         )\n       )\n     )\n   )","user":"569ef93de4b0542e1f8d148b"},{"problem":31,"code":"(fn [col]\n   (loop [old-list col new-list [] final-list []]\n     (cond\n       (empty? old-list)\n       (do\n         (println final-list)\n         (apply list (conj final-list (apply list new-list))))\n       (or (empty? new-list) (= (first old-list) (last new-list)))\n       (do\n         (println (first old-list) \",\" (last new-list))\n         (recur (rest old-list) (conj new-list (first old-list)) final-list))\n       :else\n       (do\n         (println new-list)\n         (recur (rest old-list) (conj [] (first old-list)) (conj final-list (apply list new-list)))))))","user":"5913fde8e4b0163c97b36f13"},{"code":"(fn [l]\n  (loop [grouped (list (list (first l)))\n         ungrouped (rest l)]\n    (if (empty? ungrouped)\n      (reverse grouped)\n      (recur\n        (if (= (ffirst grouped) (first ungrouped))\n          (conj \n            (rest grouped) \n            (conj (first grouped) (first ungrouped)))\n          (conj grouped (list (first ungrouped))))\n        (rest ungrouped)))))","problem":31,"user":"4f90e238e4b0dcca54ed6c94"},{"problem":31,"code":"(fn [x]\n  (loop [[f & r] x\n         out []\n         cur []]\n    (let [current (conj cur f)]\n      (if (empty? r)\n        (conj out current)\n        (if (= f (first r))\n          (recur r out current)\n          (recur r (conj out current) '[]))))))","user":"54c120d7e4b0ed20f4ff6f1c"},{"problem":31,"code":"reduce #(if (= %2 (last (last %))) (conj (pop %) (conj (last %) %2)) (conj % [%2])) []","user":"595a4fb8e4b066ee0a44afba"},{"problem":31,"code":"(fn [lst]\n  (reverse (reduce (fn [a b]\n            (if (some #(= % b) (first a))\n              (conj (rest a) (conj (first a) b))\n              (conj a (list b))))\n          \t'()\n          \tlst)))","user":"5d64013ce4b0c9e5857d502d"},{"problem":31,"code":"(fn [l]\n    (if (empty? l)\n        l\n        (loop [x (rest l) y (list (first l)) z nil]\n              (if (empty? x)\n                  (reverse (cons y z))\n                  (if (= (first x) (first y))\n                      (recur (rest x) (cons (first x) y) z)\n                      (recur (rest x) (list (first x)) (cons y z)))))))","user":"5a34f342e4b0ddc586f153d1"},{"problem":31,"code":"(fn\n  [collection]\n  (reverse \n    (loop [x collection out '()]\n      (if (empty? x)\n        out\n        (recur \n          (rest x)\n          ;; see if there is a dup\n          (if (= (first x) (first (first out)))\n            (conj (rest out) (conj (first out) (first x)))\n            (conj out (list (first x)))))))))","user":"5843b231e4b089d5ab817e3d"},{"problem":31,"code":"(fn packem [x]\n    (cond\n     (empty? x) '()\n     (empty? (rest x)) (list (list (first x)))\n     :else\n\t   (let [subresult (packem (rest x))]\n\t     (cond\n\t\t   (= (first x) (first (first subresult))) (cons (cons (first x) (first subresult)) (rest subresult))\n           :else\n             (cons (list (first x)) subresult)))))","user":"568c2f97e4b0dcc4269f40b0"},{"code":"(fn [xs]\r\n  (loop [x (rest xs) cur [(first xs)] acc []]\r\n    (if (empty? x)\r\n      (conj acc cur)\r\n      (if (= (first x) (first cur))\r\n        (recur (rest x) (conj cur (first x)) acc)\r\n        (recur (rest x) (conj [] (first x)) (conj acc cur))))))","problem":31,"user":"5050b107e4b063148f524126"},{"problem":31,"code":"(fn\n  [x]\n  (loop [remaining x resultseq '()]\n    (if (empty? remaining)\n      (reverse resultseq)\n      (let [[firstel nextel] remaining]\n        (if (= firstel nextel)\n          (recur (drop-while (partial = firstel) remaining) (conj resultseq (take-while (partial = firstel) remaining)))\n          (recur (rest remaining) (conj resultseq (conj '() firstel)))\n          )\n        )\n      )\n    )\n  )","user":"57a2328ae4b0c3d858beb8f8"},{"problem":31,"code":"(fn [coll]\n   (loop [[f & r] (rest coll)\n          temp (list (first coll))\n          res '()]\n     (if (nil? f)\n       (reverse (conj res temp))\n       (if (= (last temp) f)\n         (recur r\n                (concat temp (list f))\n                res)\n         (recur r\n                (list f)\n                (conj res temp))))))","user":"5c5d2e90e4b01df32ab732af"},{"problem":31,"code":"(fn [coll] \n  \t(reverse \n     (loop [[f l] (split-with #(= %1 (first coll)) coll) acc '()] \n       (if (empty? f) \n         acc \n         (recur (split-with #(= %1 (first l)) l) (cons f acc))))))","user":"56b2573ce4b0982f16b37e02"},{"code":"(fn [x]\n  (let [belongs? (fn [x c] (or (empty? c) (= x (first c))))\n        proc (fn proc[ [r & rs :as rr] x]\n               (if (belongs? x r)\n                 (cons (cons x r) rs)\n                 (cons (list x)   rr))) ]\n    (reverse (reduce proc '(()) x))))","problem":31,"user":"50fa01bce4b07934dda8b0ba"},{"problem":31,"code":"(fn [col]\n  (partition-by (fn [a] a) col))","user":"5367bc60e4b0243289761e81"},{"problem":31,"code":"(fn pack [xs]\n  (if (= 0 (count xs))\n    '()\n    (let [x       (first xs)\n          rest-xs (rest xs)\n          pred    #(= % x)\n          x-count (+ 1 (count (take-while pred rest-xs)))\n          ys      (drop-while pred rest-xs)]\n\n          (conj\n            (pack ys)\n            (repeat x-count x)))))","user":"56bfcba1e4b060a8e693e3a1"},{"problem":31,"code":"#(reduce (fn [a b]\n                                    (cond\n                                     (= (last a) b)\n                                     (conj (vec (drop-last a)) (conj () (last a) b))\n                                     (and (seq? (last a)) (= (last (last a)) b))\n                                     (conj (vec (drop-last a)) (conj (last a) b))\n                                     :else\n                                     (conj a (conj () b))))\n                                  []\n                                  %)","user":"591e0782e4b09b4ee5954c25"},{"problem":31,"code":"(let\n  [\n    buildPacks (fn x [iniSeq builder currSeq]\n      (if (empty? iniSeq)\n        (cons currSeq builder)\n        (if (empty? currSeq)\n          (x (butlast iniSeq) builder (cons (last iniSeq) '()))\n          (if (= (last iniSeq) (first currSeq))\n            (x\n              (butlast iniSeq)\n              builder\n              (cons (last iniSeq) currSeq))\n            (x\n              (butlast iniSeq)\n              (cons currSeq builder)\n              (cons (last iniSeq) '()))\n          )\n        )\n      )\n      )\n   func (fn [s] (buildPacks s '() '()))\n  ]\n  func)","user":"54ba8206e4b0ed20f4ff6eb6"},{"problem":31,"code":"(fn dup-seqs [[hd & tl]]\n  (let [dups (conj (take-while #(= % hd) tl) hd)\n        remaining (drop-while #(= % hd) tl)]\n    (if (empty? remaining)\n      (list dups)\n      (cons dups (dup-seqs remaining)))))","user":"53fb5256e4b0de5c4184857f"},{"code":"(fn [coll]\r\n  (letfn [(take-first [coll] (take-while #(= (first coll) %) coll))\r\n          (drop-first [coll] (drop-while #(= (first coll) %) coll))]\r\n    (loop [res [(take-first coll)] coll (drop-first coll)]\r\n      (if (empty? coll)\r\n        res\r\n        (recur (conj res (take-first coll)) (drop-first coll))))))","problem":31,"user":"4e79ff2a535db169f9c796a9"},{"problem":31,"code":"(fn pack [collection]\n  (partition-by identity collection))","user":"58e980dfe4b056aecfd47d0b"},{"problem":31,"code":"(fn [c]\n  (reduce #(do\n             (if (= (last (last %1)) %2)\n               (concat (butlast %1) (list (cons %2 (last %1))))\n               (concat %1 [(list %2)])))\n   (list (list (first c)))\n   (rest c)))","user":"557c6ca6e4b05c286339e0c4"},{"problem":31,"code":"(fn pack\n  ([in] (pack in [])) ;can't recur into version with a different number of arugments!\n  ([in out] (pack in out :nothing-repeated))\n  ([in out prev]\n   (if (empty? in)\n     out\n     (let [one (first in)]\n      (if (= one prev)\n        (recur \n          (rest in)\n          (conj\n            (pop out)\n            (let [pushed (peek out)]\n              (if (= pushed one)\n               [one one] #_ (the first time it is repeated, hence make it into a list)\n                \n               (conj (peek out) one))))\n          one)\n        (recur\n          (rest in)\n          (conj out [one]) ;without making one into a vector it would be as per https://github.com/4clojure/4clojure/issues/305 \n          one))))))","user":"5b999af8e4b0c0b3ffbd4ad3"},{"problem":31,"code":"(fn foo[xs] \n  (let [x (first xs)] \n    (if x \n      (cons (take-while (partial = x) xs) (foo (drop-while (partial = x) xs)))\n      ())))","user":"557dbc9de4b05c286339e0cd"},{"code":"(fn [coll]\n  (loop [x coll prev nil sub [] answer []]\n    (if (empty? x)\n      (conj answer sub)\n      (if (or (= prev (first x)) (nil? prev))\n        (recur (rest x) (first x) (conj sub (first x)) answer)\n        (recur (rest x) (first x) [(first x)] (conj answer sub))\n      )\n    )\n  )\n)","problem":31,"user":"50bfbf25e4b05ae8c1cbbd9b"},{"problem":31,"code":"(fn [coll]\n  (loop [full-seq coll \n         new-seq []]\n    (let [[f] full-seq]\n      (if (empty? full-seq)\n        new-seq\n        (recur (drop-while #(= %1 f)full-seq) (conj new-seq (take-while #(= %1 f)full-seq)))))))","user":"53b05a36e4b047364c044481"},{"code":"(fn my-pack\n  [in]\n  (partition-by #(identity %) in))","problem":31,"user":"5300b750e4b0d8b024fd3711"},{"problem":31,"code":"(fn pack [xs]\n  (if (empty? xs)\n    []\n    (concat [(take-while #(= % (first xs)) xs)]  \n            (pack (drop-while #(= (first xs) %) xs)))))","user":"5bcddaeee4b0e9689409ee07"},{"code":"(fn [coll]\n    (loop [left (rest coll) result [] current [(first coll)]]\n      (if (empty? left)\n        (if (empty? result) result (conj result current))\n        (let [current-item (first left)]\n          (let [consec? (= current-item (last current))]\n            (if consec?\n              (recur (rest left) result (conj current current-item))\n              (recur (rest left) (conj result current) [current-item])))))))","problem":31,"user":"5225271fe4b01819a2de42f9"},{"code":"(fn [x]\n(letfn [(stuff [runningList restList]\n  (if (empty? restList)\n   (list runningList)\n  (if (= (first runningList) (first restList))\n      (stuff (cons (first restList) runningList)\n             (rest restList))\n      (cons runningList \n        (stuff (list (first restList)) (rest restList))))))]\n(stuff (list (first x)) (rest x))))","problem":31,"user":"4f0365fc535dcb61093f6aa4"},{"problem":31,"code":"(fn [collection]\n  (partition-by identity collection))","user":"5d42c88ae4b05dd059a5437e"},{"problem":31,"code":"(fn [l]\n ((fn fnSplit [lDone lCur lToDo]\n   (if (and (empty? lCur) (empty? lToDo)) \n     (reverse lDone)\n     (if (empty? lToDo) \n       (fnSplit (if (empty? lCur) lDone (conj lDone lCur)) '() '()) \n       (if (= (first lCur) (first lToDo)) \n         (fnSplit lDone (conj lCur (first lToDo)) (rest lToDo)) \n         (fnSplit (if (empty? lCur) lDone (conj lDone lCur)) (list (first lToDo)) (rest lToDo))\n         )\n       )\n     )\n   )\n '() '() l\n ))","user":"5528ecd1e4b0ffed3738f942"},{"problem":31,"code":"(fn self [s]\n  (if (not (empty? s))\n    (cons (take-while #(= % (first s)) s) (self (drop-while #(= % (first s)) s)))\n    s))","user":"58a5a099e4b01a0c0b232918"},{"code":"(fn [x] (loop [s x prev nil counter 0 res []]\n             (if (empty? s)\n               (conj res (take counter (repeat prev)))\n               (if (= (first s) prev)\n                 (recur (rest s) prev (inc counter) res)\n                 (if (= counter 0)\n                   (recur (rest s) (first s) 1 res)\n                   (recur (rest s) (first s) 1 (conj res (take counter (repeat prev))))\n                   )\n                 )\n               )))","problem":31,"user":"4ebef65e535dfed6da9c6d9b"},{"problem":31,"code":"(fn [s]\n  ((fn pack [ce ws ps]\n    (if (and (empty? ws) (nil? ce))\n      (reverse ps)\n      (pack (first ws)\n            (rest ws)\n            (if (= ce (first (first ps)))\n              (conj (rest ps) (conj (first ps) ce))\n              (conj ps (list ce))))))\n    (first s) (rest s) '()))","user":"5c7ef3f3e4b0d597f478cad7"},{"problem":31,"code":"(fn pack-duplicates [coll]\n  (if (empty? coll)\n    coll\n    (loop [target (first coll)\n           target-list (list (first coll))\n           yet-to-process (rest coll)]\n      (if (= target (first yet-to-process))\n        (recur target (conj target-list target) (rest yet-to-process))\n        (cons target-list (pack-duplicates yet-to-process))))))","user":"55b69e37e4b01b9910ae2999"},{"problem":31,"code":"#(filter (fn [a] (not= \"#\" (first a))) \n        (partition-by (fn [p] (= \"#\" p)) \n              (reduce (fn [a v]\n                        (let [last-value (last a)]\n\t\t\t\t\t\t\t            (cond\n\t\t\t\t\t\t\t              (empty? a) (conj a v)\n\t\t\t\t\t\t\t              (not= v last-value) (conj (conj a \"#\") v)\n\t\t\t\t\t\t\t              :else (conj a v))))\n\t\t\t\t\t\t\t        []\n\t\t\t\t\t\t\t        %)))","user":"5eb1e42ae4b00a66d4a95202"},{"problem":31,"code":"reduce #(if (= (first (last %1)) %2)\n           (conj (vec (drop-last %1)) (conj (last %1) %2))\n           (conj %1 [%2])) []","user":"5bc09ebae4b07a9b28b10005"},{"problem":31,"code":"(fn pack \n  ([x] (pack x '()))\n  ([x p]\n   (cond\n\t(empty? x) (if (seq p) (list p) p)\n    (empty? p) (pack (rest x) (list (first x)))\n    (= (first x) (first p)) (pack (rest x) (conj p (first x)))\n    :else (conj (pack (rest x) (list (first x))) p))))","user":"5aa5951ae4b0d174b936c899"},{"problem":31,"code":"(fn [s]\n  (reduce\n    (fn [result element]\n      (let [last-subvector (last result)\n            last-element (last last-subvector)]\n        (if (= element last-element)\n          (assoc result (dec (count result)) (conj last-subvector element))\n          (conj result [element]))))\n    []\n    s))","user":"555ee545e4b0a2eb076a39bd"},{"code":"(fn [x] (apply list (reduce (fn [a b] (if (nil? a) [(list b)] (if (= (last (last a)) b) (conj (vec (butlast a)) (conj (last a) b)) (conj a (list b))))) nil x)))","problem":31,"user":"52eee533e4b05e3f0be25ecb"},{"problem":31,"code":"(fn [a-list] \n     (let [iner-function (fn [acc n rest-of-list]\n                           (if (nil? n)\n                             acc\n                             (if (= (first (first  acc)) n)\n                               (recur (conj (rest acc) (conj (first acc) n)) (first rest-of-list) (rest rest-of-list))\n                               (recur (conj  acc (list n) ) (first rest-of-list) (rest rest-of-list)))))]\n       (reverse (iner-function '() (first a-list) (rest a-list)))))","user":"54cb3497e4b057c6fda3a272"},{"problem":31,"code":"(fn split [coll]\n  (letfn [(split-groups [coll]\n              (let [first-elem (first coll)]\n                (split-with #(= first-elem %) coll)))\n          (split [coll]\n                 (when (seq coll)\n                   (let [[first-group remaining] (split-groups coll)]\n                     (cons first-group (split remaining)))))]\n    (split coll)))","user":"5776e21de4b0979f89651642"},{"code":"(fn [acc s]\n   (reverse\n   (reduce\n    (fn [r x]\n      (if (= (first (first r)) x)\n        (conj (rest r) (conj (first r) x))\n        (conj r (list x))))\n    acc\n    s)))\n '()","problem":31,"user":"50868795e4b004985b776e5e"},{"code":"reduce\r\n  (fn [coll val]\r\n    (if (= val (first (last coll)))\r\n      (assoc coll (dec (count coll))\r\n             (conj (last coll) val))\r\n      (conj coll [val])))\r\n  []","problem":31,"user":"4f410b63e4b0e243712b1fc5"},{"code":"(fn [l] (loop [ls l a nil as [] rs []]\r\n  (cond (empty? ls) (conj rs as)\r\n        (nil? a) (recur (rest ls) (first ls) (list (first ls)) rs)\r\n        (= (first ls) a) (recur (rest ls) a (conj as (first ls)) rs)\r\n        :else (recur (rest ls) (first ls) (list (first ls)) (conj rs as))\r\n)))","problem":31,"user":"4db883e1535d1e037afb2198"},{"problem":31,"code":"(fn [coll]\n  (loop [[x & xs] coll\n         crnt-el x\n         crnt-group []\n         res []]\n    (cond\n     (nil? x) (conj res crnt-group)\n     (= x crnt-el) (recur xs crnt-el (conj crnt-group x) res)\n     :else (recur xs x [x] (conj res crnt-group)))))","user":"57a775bbe4b0a96607956214"},{"problem":31,"code":"(fn [s]\n   (loop [s' (rest s)\n          prev (first s)\n          result (list (list prev))]\n     (if (empty? s')\n       (reverse result)\n       (let [[h & t] s'\n             [rh & rt] result]\n         (if (= prev h) (recur t h (cons (cons h rh) rt))\n             (recur t h (cons (list h) result)))))))","user":"5e3ef7d4e4b01d43a70e8e2d"},{"problem":31,"code":"(fn pack-seq [seq]\n  (if (empty? seq)\n    []\n    (loop [result []\n           current (list)\n           remaining seq]\n      (if (empty? remaining)\n        (conj result current)\n        (if (empty? current)\n          (recur result\n                 (list (first remaining))\n                 (rest remaining))\n          (if (= (first remaining) (first current))\n            (recur result \n                   (conj current (first remaining))\n                   (rest remaining))\n            (recur (conj result current)\n                   (list)\n                   remaining)))))))","user":"60460824e4b02d28681c77bc"},{"problem":31,"code":"(fn pd [xs]\n   (if (empty? xs) xs (let [[p r] (split-with (partial = (first xs)) xs)] \n    (cons p (pd r)) )))","user":"548cd637e4b0e286459a1210"},{"problem":31,"code":"(fn [xs]                                                       \n       (reduce (fn [acc x]                                          \n                 (if (-> acc last first (= x))                      \n                   (concat (butlast acc) (list (cons x (last acc))))    \n                   (concat acc (list (list x)))))    \n               '() xs))","user":"5de68f83e4b0986d99407f6c"},{"problem":31,"code":"(fn pack [s]\n  (loop [i s, acc '(), r []]\n    (if (empty? i)\n      (conj r acc)\n      (if (or (empty? acc) (= (first i) (first acc)))\n        (recur (rest i) (conj acc (first i)) r)\n        (recur (rest i) (list (first i)) (conj r acc))))))","user":"5590e55de4b0277789237676"},{"code":"(fn f [s]\n  (when-not (empty? s)\n    (cons (take-while #(= (first s) %) s)\n          (f (drop-while #(= (first s) %) s)))))","problem":31,"user":"51256b40e4b05d10e3e395f8"},{"problem":31,"code":";; put into previous list, otherwise just proceed with new list\n\n(fn [x]\n\t(loop [items (rest x) result [(list (first x))]]\n      (if (empty? items) result\n          (let [current-item (first items)\n                prev-list (last result)]\n            (if (not= (first prev-list) current-item) (recur (rest items) (conj result (list current-item)))\n        \t\t(recur (rest items) (conj (vec (butlast result)) (cons current-item prev-list))))))))","user":"596aaeefe4b069c0a1a19808"},{"problem":31,"code":"(fn dups [x]\n  (partition-by identity x))","user":"562eafbce4b0ab312c17ebbe"},{"problem":31,"code":"#((fn [x y] \n    (println x y)\n  (if (empty? x)\n    y\n  \t(if (= (first x) (last (last y)))\n   \t\t(recur (rest x) (conj (subvec y 0 (dec (count y))) (conj (last y) (first x))))\n    \t\n               \n        (recur (rest x) (conj y [(first x)]))\n  \t)\n  )\n) (rest %)  [[(first %)]])","user":"57011eb3e4b08d47c97781d1"},{"code":"#(if (empty? %)\n    []\n    (loop\n      [cur-item (first %)\n       cur-list [cur-item]\n       rest-items (rest %)\n       result []]\n         (if (empty? rest-items)\n            (conj result cur-list)\n            (let [next-item (first rest-items)]\n              (if (= next-item cur-item)\n                (recur\n                  cur-item\n                  (conj cur-list cur-item)\n                  (rest rest-items)\n                  result)\n                (recur\n                  next-item\n                  [next-item]\n                  (rest rest-items)\n                  (conj result cur-list)))))))","problem":31,"user":"4f42ae16e4b0d7d3c9f3fd09"},{"problem":31,"code":"#((fn [xs packed] \n    (if (empty? xs) \n       (reverse packed)\n       (let [x (first xs), identicals (first packed)]\n          (if (= x (first identicals))\n             (recur (rest xs) (cons (cons x identicals) (rest packed)))\n             (recur (rest xs) (cons (list x) packed))\n          ) \n       )\n    )\n  )\n  % ()\n)","user":"59738d98e4b01722bebd4ca1"},{"code":"(fn pack [s]\n  (letfn [(make [x n]\n            (if (= n 0)\n              '()\n              (conj (make x (- n 1)) x)))\n          (encode ([[prev, count], s] (if-let [[x & xs] (seq s)]\n                                        (if (= x prev)\n                                          (encode [prev, (+ count 1)] xs)\n                                          (conj (encode [x, 1] xs) `(~prev ~count)))\n                                        `((~prev ~count))))\n            ([s] (if-let [[x & xs] (seq s)]\n                   (encode [x 1] xs)\n                   '())))]\n    (map (fn [[x n]] (make x n)) (encode s))))","problem":31,"user":"4fcaf7a4e4b0ee37620e1857"},{"problem":31,"code":"(fn [n]\n    (partition-by identity n))","user":"567b62fce4b05957ce8c61a6"},{"problem":31,"code":"(fn [s] (reverse (reduce (fn [acc x] (if (not= (ffirst acc) x) (cons [x] acc) (cons (conj (first acc) x) (rest acc)))) [] s)))","user":"56bfd8ade4b060a8e693e3a2"},{"problem":31,"code":"#(\n(fn rle [input current acc]\n  (if (empty? input)\n    (reverse acc)\n    (let [[h & t] input\n          [ah & at] acc]\n      (if (= h current)\n        (rle t current (cons (cons h ah) at))\n        (rle t h (cons [h] acc))))))\n  % nil [])","user":"54d22860e4b0e8a36923e5ef"},{"problem":31,"code":"#(reduce (fn[x y](if(or (empty? x)) \n                        (conj x [y])\n                        (if(= (if(coll? (last x)) (last (last x)) (last x)) y)\n                            (if(= (count x) 1)\n                               (conj [] (conj (last x) y))\n                               (conj (into [] (reverse (rest (reverse x)))) (conj (last x) y))\n                           )  \n                           (conj x [y]))\n                           )) [] %1)","user":"55129667e4b06e50f9beb1ac"},{"problem":31,"code":"#(loop [s % o [] p nil a []]\n   (cond\n    (empty? s)\n    (conj o a)\n    (= (first s) p)\n    (recur\n     (rest s)\n     o\n     (first s)\n     (conj a (first s)))       \n    :else\n    (recur (rest s)\n           (if (empty? a)\n             o\n             (conj o a))\n           (first s)\n           [(first s)])))","user":"56a9d4bbe4b07966d5a8a07b"},{"code":"(fn [s]\n  (reduce\n    (fn [a b]\n      (let [last-coll (last a)\n            last-val (last last-coll)\n            ]\n        (if (= last-val b)\n          (conj (pop a) (conj last-coll b))\n          (conj a [b]))))\n    []\n    s ))","problem":31,"user":"50e4ff72e4b049a987753897"},{"code":"(fn pack [in]\n  (let [lst (seq in)]\n    (if lst\n      (let [a (first lst)\n            b (take-while #(= a %) lst)\n            c (drop-while #(= a %) lst)]\n        (cons b (pack c))))))","problem":31,"user":"4e342671535deb9a81d77f29"},{"code":"(fn [lst]\n  (reverse\n   (reduce (fn [memo aval]\n          (if (= (first (first memo)) aval)\n            (cons (cons aval (first memo)) (rest memo))\n            (cons (clojure.core/list aval) memo))) '() lst)))","problem":31,"user":"51c76864e4b07ef393169e3f"},{"code":"(fn pack [pseq] ((fn pack- [cur curacu acu xs] (if (seq xs)\n                                (if (= (first xs) cur) (recur cur (conj curacu (first xs)) acu (rest xs)) (recur (first xs) (conj () (first xs)) (conj acu curacu) (rest xs)))\n                                (reverse (conj acu curacu))\n                                )) (first pseq) '() '() pseq) )","problem":31,"user":"511a0374e4b06c8af011181a"},{"problem":31,"code":"#(reduce \n  (fn [coll curr]\n    (if (= (last (last coll)) curr) \n      (update-in coll [(dec (count coll))] conj curr)\n      (conj coll [curr])))\n  [] %)","user":"5a1c3c11e4b0ff51aa4b323d"},{"code":"(fn [coll]\n  (loop [[h & t :as all] coll\n         lastgroup '()\n         acc '()]\n    (if (seq all)\n      (if (= h (first lastgroup))\n        (recur t (conj lastgroup h) acc)\n        (recur t (list h) (cons lastgroup acc)))\n      (rest (reverse (cons  lastgroup acc))))))","problem":31,"user":"4ff9a200e4b0678c553fc3ab"},{"problem":31,"code":"#(loop [a (rest %)\n        b [(first %)]\n        c []]\n   (if (zero? (count a))\n     (conj c b)\n     (if (= (last b) (first a))\n       (recur (rest a) (conj b (first a)) c)\n       (recur (rest a) [(first a)] (conj c b)))))","user":"595a3b41e4b066ee0a44afb7"},{"problem":31,"code":"#(rest((fn [t d s]\n    (if (= s nil)\n      (conj d t)\n      (if (= (first s) (last t))\n        (recur (conj t (first s)) d (next s))\n        (recur [(first s)] (conj d t) (next s))\n      )\n    )\n )[] [] %))","user":"5b5b0bb9e4b0c6492753e6a5"},{"problem":31,"code":"(fn  [s]\n  (loop [c (first s) s (rest s) l () r ()]\n    (if (empty? s)\n      (reverse (concat (list (cons c l)) r))\n      (if (= c (first s))\n        (recur c (rest s) (cons c l) r)\n        (recur (first s) (rest s) () (concat (list (cons c l)) r))))))","user":"56df632ce4b0ca2494a095f2"},{"problem":31,"code":"(fn pack [c]\n  (let [step\n        (fn [c]\n          (when-let [s (seq c)]\n            (loop [fs (list (first s)) rs (rest s)]\n              (if (= (first rs) (first fs))\n                (recur (cons (first rs) fs) (rest rs))\n                (cons fs (pack rs))))))]\n    (lazy-seq (step c))))","user":"5953bdb6e4b066ee0a44aeed"},{"problem":31,"code":"(fn\n  [[fi & li] & par]\n  (loop\n   [head [fi]\n    tail li\n    dgst (vector)]\n   (let\n     [ndgst (if\n             (=\n               (first tail)\n               (first head))\n             dgst\n             (conj dgst head))]\n     (if\n      (empty? tail)\n      ndgst\n      (recur\n       (if\n        (= (first tail) (first head))\n        (conj head (first tail))\n        [(first tail)])\n       (rest tail)\n       ndgst)))))","user":"586a657de4b0f14aab7c88bd"},{"problem":31,"code":"(fn packer\n   ([coll]\n    (packer coll (first coll) '() '()))\n   ([coll elem tmp out]\n    (println coll elem tmp out)\n    (if (empty? coll)\n      (reverse (cons tmp out))\n      (if (= (first coll) elem)\n        (packer (rest coll) (first coll) (cons (first coll) tmp) out)\n        (packer (rest coll) (first coll) (list (first coll)) (cons tmp out))))))","user":"5df75fd8e4b0a607a9a45c92"},{"code":"(fn toto [in]\n  (if (empty? in)\n    in\n    (cons (take-while #(= % (first in)) in) (toto (drop-while #(= % (first in)) in)))))","problem":31,"user":"5186571de4b0da5a5be3bad1"},{"problem":31,"code":"(fn pack \n  [s]\n  (loop [[hd & tl] s new_list [] consec ()]\n    (let [nxt (first tl) glob (conj consec hd)]\n      (if (nil? nxt)\n        (conj new_list glob)\n        (if (= hd nxt)\n          (recur tl new_list glob)\n          (recur tl (conj new_list glob) ())\n        )\n      )\n    )\n  )\n)","user":"5f6b8222e4b02876ed9fd052"},{"code":"(fn pack [[f & rst]]\n    (if (nil? f) '()\n\t(let [r (pack rst)]\n            (if (= f (first (first r)))\n                (cons (cons f (first r)) (rest r))\n                (cons (list f) r)))))","problem":31,"user":"53300924e4b019098a6f8b55"},{"problem":31,"code":"(fn [xs]\n   ((fn pack [xs]\n      (if (empty? xs)\n        xs\n        (if (= (first (first xs)) (first (second xs)))\n          (pack (conj (rest (rest xs)) (concat (first xs) (second xs))))\n          (conj (pack (rest xs)) (first xs))))) (map #(list %) xs)))","user":"54fd93bbe4b07d26eda61d36"},{"problem":31,"code":"#(reverse (reduce\n   (fn [a x]\n     (if (= (first (first a)) x)\n       (cons (conj (first a) x) (rest a))\n       (conj a [x])))\n   [] %))","user":"5ed03b7fe4b016b56eae05ae"},{"problem":31,"code":"(fn pack-dupes [l] (reduce (fn [lists next-item] (cond\n                                                  (= (count lists) 0) (conj lists [next-item])\n                                                  (= (last (last lists)) next-item) (conj (into [] (drop-last 1 lists)) (conj (last lists) next-item))\n                                                  :else (conj lists [next-item])\n                                                  )) [] l\n                    ))","user":"5c7c1d8ee4b0d597f478ca88"},{"problem":31,"code":"#(reduce (fn [acc item] \n           (if (= (first (last acc)) item) \n             (update-in acc [(dec (count acc))] conj item)\n             (conj acc [item])))  [] %)","user":"5dc12b0ae4b0e59a23173d84"},{"problem":31,"code":"#(->> % reverse\n      (reduce \n              (fn [a e] (if (= e (-> a first first))\n                            (cons (cons e (first a)) (rest a)) \n                            (cons (list e) a)))\n              nil))","user":"5a4de614e4b05d388ecb6bb1"},{"problem":31,"code":"(fn [p] (partition-by identity p))","user":"58d1fe17e4b03c36ff7e58f5"},{"problem":31,"code":"#(loop [x (list (list (first %))) y (rest %)] (if (empty? y) x (recur (if (= (first y) (last (last x))) (concat (take (- (count x) 1) x) [(concat (last x) [(first y)])]) (concat x [(list (first y))])) (rest y))))","user":"55c3f19de4b0e31453f64991"},{"problem":31,"code":"(fn pack-seq [u]\n    (loop [i (- (count u) 2)\n           x (conj '() (last u))\n           y (drop-last u)\n           r '()]\n      (if (= i -1)\n        (conj r x)\n        (if (= (first x) (last y))\n            (recur (- i 1)\n                   (conj x (last y))\n                   (drop-last y)\n                   r)\n              (recur (- i 1)\n                     (conj '() (last y))\n                     (drop-last y)\n                     (conj r x))))))","user":"5018878ce4b029375d2a5056"},{"code":"(fn [coll]\r\n (reverse\r\n  (reduce\r\n   (fn [col val]\r\n    (if (= (first col) nil)\r\n      (cons  (cons val '()) '())\r\n      (if (= (some #{val} (first col)) val)\r\n        (cons (cons val (first col)) (rest col))\r\n        (cons (cons val '()) col))))\r\n nil\r\n (seq coll))))","problem":31,"user":"4ddee37c535d08e6dec9fddc"},{"code":"reduce #(if (= (first (last %1)) %2) (conj (into [] (butlast %1)) (conj (last %1) %2)) (conj %1 (list %2))) []","problem":31,"user":"510967aae4b07c05fdf6dc0f"},{"code":"(fn pack [a-seq]\n  (loop [act-acc [(first a-seq)]\n         acc []\n         the-rest (rest a-seq)]\n    (if (empty? the-rest)\n      (conj acc act-acc)\n      (let [next-char (first the-rest)\n            same-char-coming (= (last act-acc) next-char)\n            new-act-acc (if same-char-coming\n                          (conj act-acc next-char)\n                          [next-char])\n            new-acc (if same-char-coming \n                      acc\n                      (conj acc act-acc))]\n        (recur new-act-acc \n               new-acc \n               (rest the-rest))))))","problem":31,"user":"52ee46e5e4b05e3f0be25ec5"},{"problem":31,"code":"(fn pack-sequence [ls]\n  (reverse (reduce (fn [acc x] (if (= (first (first acc)) x)\n                                 (let [fst (first acc)]\n                                   (conj (pop acc) (conj (first acc) x)))\n                                 (conj acc (list x))))\n                   () ls))\n  )","user":"5fe1b893e4b05ac5b16ea16f"},{"code":"(fn pack-sequence [sq]\n  (loop [src sq, dest []]\n    (if (seq src)\n      (let [x (first src)]\n        (recur\n          (drop-while #(= x %) src)\n          (conj dest (take-while #(= x %) src))))\n      dest)))","problem":31,"user":"4fecebe1e4b0681fd128dcac"},{"code":"(fn [lst]\n  (loop [lst lst acc []]\n    (if (empty? lst)\n      acc\n      (recur (rest lst)\n        (if (= (first (last acc)) (first lst))\n          (update-in acc [(dec (count acc))] #(conj % (first lst)))\n          (conj acc [(first lst)])\n        )\n      )\n    )\n  )\n)","problem":31,"user":"4ec6c878535d6d7199dd36d5"},{"problem":31,"code":"reduce (fn [x y] \n         (if (empty? x)     (conj x (conj [] y)) \n                            (if (= (last (last x)) y)     (conj (into [] (reverse (rest (reverse x)))) (conj (last x) y))     (conj x (conj [] y)))\n         )\n        ) []","user":"57f28b22e4b0511f1d294def"},{"problem":31,"code":"(fn pack [x]\n  (loop [x x\n         res []]\n    (if (empty? x)\n      res\n      (if (= (first x) (last (last res)))\n        (recur (rest x) (update-in res [(dec (count res))] conj (first x)))\n        (recur (rest x) (conj res [(first x)]))))))","user":"5666c2dbe4b04acd4f672dc3"},{"problem":31,"code":"(fn [x] (loop [packed [], res[], data x]\n    (if (empty? data)\n      (conj res packed)\n      (let [prev (last packed)\n            current (first data)\n            next-data (next data)]\n        (if (or (empty? packed) (= current prev))\n          (recur (conj packed current) res next-data)\n          (recur [current] (conj res packed) next-data))))))","user":"53fb4843e4b0de5c4184857d"},{"problem":31,"code":"(fn [in]\n    (-> (reduce\n       (fn [x y]\n           (if (coll? (first x))\n             (if (= (first (first x)) y)\n               (conj (pop x) (conj (first x) y))\n               (conj x (list y)))\n             (if (= (first x) y)\n               (x y)\n               (conj x (list y)))))\n       ()\n       in)\n      reverse\n      ))","user":"5ae47c1de4b0837691e92c81"},{"code":"(fn [l]\n  (reduce (fn [col el]\n            (if (and (coll? (first col)) (= el (first(first col))))\n              (conj (rest col) (conj (first col) el))\n              (conj col (list el)))) \n          '() \n          (reverse l)))","problem":31,"user":"538c6db7e4b0b51d73faae5a"},{"code":"#(reduce (fn [r x] (if (= (first (last r)) x)\n                            (conj (vec (take (dec (count r)) r)) (conj (last r) x))\n                          (conj r [x]))) [[(first %)]] (rest %))","problem":31,"user":"507fbd77e4b089ade05efbd3"},{"problem":31,"code":"(fn compress [x]\n   (if (= '() x)\n    ()\n    (cons\n      (take-while (partial = (first x)) x)\n      (compress\n       (drop-while (partial = (first x)) x)))))","user":"59273eefe4b072a2710fcec6"},{"code":"(fn packseq [ls]\r\n  (reduce \r\n    (fn [acc vl]\r\n      (if (= (first (first acc)) vl)\r\n        (cons (cons vl (first acc)) (rest acc))\r\n        (cons (list vl) acc)))\r\n    '() (reverse ls)))","problem":31,"user":"4e9528ef535dbda64a6f6b32"},{"problem":31,"code":"(fn f [x]\n  (if (empty? x)\n    '()\n    (let [y (first x)\n          g #(= y %)\n          front (list (take-while g x))\n          back (drop-while g x)]\n      (concat front (f back)))))","user":"55e26417e4b050e68259b433"},{"code":"(fn [coll]\n  ((fn [coll ret temp]\n     (if (empty? coll)\n       (reverse (conj ret temp))\n       (if (= (first temp) (first coll))\n         (recur (rest coll) ret (conj temp (first coll)))\n         (recur (rest coll) (conj ret temp) (cons (first coll) '())))))\n   (rest coll) '() (cons (first coll) '())))","problem":31,"user":"521392bce4b0d32679a5065e"},{"problem":31,"code":"(fn  [coll]\n  (partition-by identity coll))","user":"56f1b558e4b04a395b9a049a"},{"problem":31,"code":"(fn [s]\n  ((fn [build prevlist prev s]\n     (if (nil? s)\n       (if prevlist (conj build prevlist) build)\n       (let [[f & r] s]\n         (if (= f prev)\n           (recur build (conj prevlist f) f r)\n           (recur (if prevlist\n                    (conj build prevlist)\n                    build)\n                  (list f) f r)))))\n   [] nil nil s))","user":"571d063ee4b0145328a76272"},{"problem":31,"code":"(fn pack [coll]\n  (loop [coll coll\n         g []\n         acc []]\n    (if (seq coll)\n      (let [f (first coll)]\n        (if (or (empty? g) (= f (first g)))\n          (recur (rest coll) (conj g f) acc)\n          (recur (rest coll) [f] (conj acc g))))\n      (if (empty? g)\n        acc\n        (conj acc g)))))","user":"500e6ddee4b04a05d36fcc06"},{"problem":31,"code":"(fn group-up\n  ([L] (group-up L []))\n  ([remaining grouped]\n   (let [run-char (first remaining)\n         in-group? (partial = run-char)\n         [left right] (split-with in-group? remaining)]\n     (if (= remaining (empty remaining))\n       grouped\n       (group-up right (conj grouped left))))))","user":"556238bce4b0c656e3ff17d3"},{"problem":31,"code":"#(loop [input %\n        current-term '()\n        output '()]\n   (println input current-term output)\n   (if (empty? input)\n     (if (empty? current-term)\n       (reverse output)\n       (reverse (cons current-term output)))\n     (if (= (first input) (first current-term))\n       (recur (rest input) (cons (first input) current-term) output)\n       (if (empty? current-term)\n         (recur (rest input) (list (first input)) '())\n         (recur (rest input) (list (first input)) (cons current-term output))))))","user":"5e9b7aefe4b0157ca96647f1"},{"code":"(fn pack [coll]\n  (when-let [s (seq coll)]\n    (let [fst (first s)\n          fv (list fst)\n          run (cons fst (take-while #(= fv (list %)) (rest s)))]\n      (cons run (pack (drop (count run) s))))))","problem":31,"user":"4f030cff535dcb61093f6a4d"},{"problem":31,"code":"#(loop [[first & tail] %\n         result []]\n    \n    (prn first tail result)\n    \n    (if-not first\n      result\n      (if (coll? (last result))\n        ; Last item in result is a collection\n        (if (= first (last (last result)))\n          (do\n          (recur tail (conj   (into [] (butlast result)) ( conj (last result) first )    ) )\n          )\n\n          (do\n            (prn result first)\n          (recur tail (concat result  [[first]]) ))\n        )\n        \n        ; Last item is not a collection\n        (if-not (= first  (last result))\n          (recur tail (conj result [first]) ))\n      )\n  ))","user":"598085e6e4b021a7a535fdd3"},{"problem":31,"code":"(fn pack\n  [x]\n  (loop [xs (rest x), prev (first x) , c 1, acc []]\n    (if (empty? xs) \n      (conj acc (repeat c prev)) \n      (if (= prev (first xs)) \n        (recur (rest xs) prev (inc c) acc) \n        (recur (rest xs) (first xs) 1 (conj acc (repeat c prev)))))))","user":"5e4fae60e4b027a2e10ac0b9"},{"code":"#((fn foo [pos1 pos2 res]\r\n    (cond  (= pos2 (count %1)) (conj res (subvec %1 pos1 pos2))\r\n           (= (nth %1 pos1) (nth %1 pos2)) (foo pos1 (+ pos2 1) res)\r\n           :else (foo pos2 (+ pos2 1) (conj res (subvec %1 pos1 pos2)))))\r\n\r\n 0 1 [] )","problem":31,"user":"52f5eefbe4b09b582c12c9cb"},{"code":"reduce #(if (= (last (last %1)) %2)\n          \t (conj (vec (drop-last %1)) (conj (last %1) %2))\n          \t (conj %1 [%2])\n          ) []","problem":31,"user":"5340ee60e4b00652c8746ec9"},{"problem":31,"code":"(fn pack [sq] (partition-by identity sq))","user":"53ea72b6e4b036ad0777e4e5"},{"code":"(fn [s]\n  (reduce (fn [news x]\n            (if (= (first (last news)) x)\n              (concat (drop-last news)\n                      [(conj (last news) x)])\n              (concat news [(conj '() x)])))\n          '() s))","problem":31,"user":"4ff505c8e4b0678c553fc364"},{"code":"(fn pack\n  ([x] (pack (vector) x))\n  ([acc x]\n    (if (empty? x)\n      (seq acc)\n      (let [consecutive? #(= % (first x))]\n        (recur (conj acc (take-while consecutive? x)) (drop-while consecutive? x))))))\n\n; ; initial attempt\n;\n;(fn pack$ [xs]\n;  (let [[xshead xstail] (map vec (split-at 1 xs))]\n;    (reduce (fn [acc x]\n;              (let [last$ (last acc)\n;                    butlast$ (subvec acc 0 (dec (count acc)))]\n;                (if (= (peek last$) x)\n;                  (conj butlast$ (conj last$ x))\n;                  (conj butlast$ last$ [x]))))\n;            [xshead]\n;            xstail)))","problem":31,"user":"52244a77e4b01819a2de42d1"},{"problem":31,"code":"#((fn pack [cur s sub ret]\n    (if (empty? s)\n      (reverse (cons sub ret))\n      (let [f (first s) r (rest s)]\n        (if (= f cur)\n          (recur f r (cons f sub) ret)\n          (recur f r (list f) (cons sub ret))))))\n  (first %) (rest %) (list (first %)) '())","user":"55670a05e4b0c656e3ff1838"},{"problem":31,"code":"(fn pack-seq\n  [l]\n  \n  (let [\n        first-same\n        (fn first-same\n        [l]\n        (take-while #(= (first l) %) l))\n        \n        not-same\n        (fn first-same\n        [l]\n        (drop-while #(= (first l) %) l))\n        ]\n              \n  \n  \n    (if (empty? l)\n      (list)\n      (cons (first-same l) (pack-seq (not-same l)))\n    )\n    )\n)","user":"56393681e4b0bfe05bf117f2"},{"problem":31,"code":"#(\n\t\tpartition-by identity %\n\t)","user":"548018ede4b0c51c1f4d7334"},{"code":"(fn pack-sequence [n]\n  (partition-by identity n))","problem":31,"user":"50ed8a5fe4b06330c1f87c3d"},{"code":"(fn ! \n  ([x] (! (first x) 0 x))\n  ([fe rt r]\n   (let [rp (replicate rt fe)]\n   (if (empty? r) [rp]\n     (if (= fe (first r)) \n       (! fe (inc rt) (rest r))\n       (concat [rp] (! (first r) 0 r))\n     )\n   )\n  ))\n)","problem":31,"user":"52faec2ee4b047fd55837004"},{"problem":31,"code":"(fn [coll] (partition-by list coll))","user":"5484143de4b0e286459a1197"},{"code":"(fn g [x] ((fn h [n m] (if (empty? n)\r\n                           m\r\n                          (if\r\n                          (= (first n) (last (last m)))\r\n                          (h (rest n) (reverse (conj  (rest (reverse m)) (conj (last m) (first n)) )))\r\n                          (h (rest n) (reverse (conj (reverse m) (seq [(first n)] ))))\r\n                          ))) (rest x) (seq [(seq [(first x)] )])  ))","problem":31,"user":"50646c01e4b007509339a58b"},{"problem":31,"code":"(fn d [sq]\n  (reverse \n   (loop [res '()\n          e '()\n          s sq]     \n     (if (empty? s)\n       (conj res e)\n       (if (or (empty? e) (= (first e) (first s)))                \n         (recur res (conj e (first s)) (rest s))\n         (recur (conj res e) (conj '() (first s)) (rest s)))))))","user":"558bb38fe4b0277789237631"},{"code":"(fn [[x & xs]]\n  (loop [cur x [y & ys :as tail] xs subl nil acc nil]\n    (let [sublnew (concat subl (list cur))]\n      (cond (empty? tail) (concat acc (list sublnew))\n            (= y cur)     (recur cur ys sublnew acc)\n            :else         (recur y ys nil (concat acc (list sublnew)))))))","problem":31,"user":"4f4ac35ae4b0d56e7bb92c18"},{"code":"(fn[coll]\n  (reduce\n    #(if (=(first (last %1)) %2)\n       (conj (vec (butlast %1)) (conj (last %1) %2))\n       (conj %1 [%2]))\n    []\n    coll))","problem":31,"user":"522454f4e4b01819a2de42d3"},{"code":"(fn f [s]\n  (if (empty? s)\n    '()\n    (let [prev (f (rest s))]\n      (if (= (first s) (ffirst prev))\n        (cons (cons (first s) (first prev)) (rest prev))\n        (cons (list (first s)) prev)))))","problem":31,"user":"4e8b98fc535d65386fec2124"},{"problem":31,"code":"#(reduce\n  (fn [a x]\n   (if (= x (first (last a)))\n     (conj (vec (butlast a)) (conj (last a) x))\n     (conj (vec a) [x])))\n []\n  %)","user":"50d0d2dde4b00b15ecee9768"},{"code":"(fn [x]\n  (loop [[h & r] x, z []]\n    (cond (nil? h) (reverse z)\n      (= h (ffirst z)) (recur r (conj (rest z) (conj (first z) h)))\n      :else (recur r (cons (list h) z)))\n    )\n  )","problem":31,"user":"5099283ce4b0cae2931060af"},{"problem":31,"code":"(fn [l] (reverse (reduce (fn [ss i] (if (empty? ss) (list (list i)) (if (= i (first (first ss))) (cons (cons i (first ss)) (rest ss))(cons (list i) ss)))) '() l)))","user":"5b4b4052e4b02d533a91bc9a"},{"problem":31,"code":"(fn pack_seq\n  ([s](pack_seq s []))\n  ([s r_val]\n   (if (empty? s)\n     r_val\n     (pack_seq (rest s) r_val (first s) (list (first s)))))\n  ([s r_val cur acc]\n   (if (= cur (first s))\n     (pack_seq (rest s) r_val cur (concat acc (list (first s))))\n     (pack_seq s (concat r_val (list acc))))))","user":"56058d64e4b08b23635d3169"},{"problem":31,"code":"(fn [coll]\n  (reverse (reduce\n    (fn [acc v]\n      (if (= (first (first acc)) v)\n        (cons (cons v (first acc)) (rest acc))\n        (cons (list v) acc)))\n    '()\n    coll)))","user":"55074092e4b021ccfedb96a4"},{"problem":31,"code":"(fn [coll]\n  (reduce\n    (fn [acc v]\n      (let [curr (first (last acc))]\n        (if (and curr (= v curr))\n          (update-in (vec acc) [(dec (count acc))] #(conj % v))\n          (conj acc [v]))))\n    []\n    coll))","user":"52c1ede2e4b07a9af579236d"},{"problem":31,"code":"#(reduce (fn [acc curr]\n(let [prev-value\n      (if (sequential? (last acc))\n        (last (last acc))\n        nil)]\n  (if (= prev-value curr)\n    (conj (vec (drop-last acc)) (conj (last acc) curr))\n    (conj acc [curr])))) [] %)","user":"5db8663ce4b010eb3c36cd4c"},{"code":"#(map (comp first list) (partition-by identity %))","problem":31,"user":"51cd75d6e4b02254fc79488c"},{"problem":31,"code":"(fn f [x] (let [[s r] (split-with (partial = (first x)) x)] (if (empty? s) '() (cons s (f r))) ) )","user":"55645592e4b0c656e3ff1802"},{"problem":31,"code":"#(reverse (reduce (fn [acc next]\n                         (if (and (sequential? (first acc)) (= (ffirst acc) next))\n                           (conj (rest acc) (conj (first acc) next))\n                           (conj acc (list next))))\n                       ()\n                       %))","user":"59881937e4b021a7a535feaf"},{"problem":31,"code":"(fn pack\n  ([data]\n   (pack (rest data) (conj [] (first data)) []))\n  ([sq group result]\n   (loop [cs sq cg group cr result]\n     (if (empty? cs)\n       (conj cr cg)\n       (let [ch (first cs) ct (rest cs) lig (last cg)]\n         (if (= lig ch)\n           (recur ct (conj cg ch) cr)\n           (recur ct [ch] (conj cr cg))))))))","user":"5b11449ce4b0cc2b61a3be2d"},{"code":"(fn pd [xs]\r\n  (if (seq xs)\r\n    (let [[x & rxs] xs\r\n          [h t] (split-with #(= x %) rxs)]\r\n      (cons (cons x h) (pd t)))))","problem":31,"user":"4dfd4ba8535d04ed9115e781"},{"code":"(fn pack  [x] (\n     if (empty? x) x (let [restPacked (pack (rest x))]\n                       (if (= (first (first restPacked)) (first x)) \n                         (conj (rest restPacked) (cons (first x) (first restPacked)))\n                         (cons (list (first x)) restPacked)))))","problem":31,"user":"50ef311fe4b0a78662fa2651"},{"problem":31,"code":"(fn [collx]\n  (letfn [(bunch [coll]\n            (if (seq coll)\n    (cons (take-while #(= % (first coll)) coll) (bunch (drop-while #(= % (first coll)) coll)))))]\n  (bunch collx)))","user":"5a9dbb32e4b0d174b936c7f3"},{"code":"(fn nodups [se] (partition-by identity se))","problem":31,"user":"52bf0116e4b07a9af5792328"},{"problem":31,"code":"(fn s [x] \n  (if (empty? x) \n    [] \n    (let [p #(= % (first x)) \n          [r t] (split-with p x)] \n      (cons r (s t))\n    )\n  )\n)","user":"57c7a8b5e4b05aa3c4741d09"},{"code":"(fn f \r\n  ([s]\r\n    (f (seq s) (first s) [] []))\r\n  ([s p macc acc]\r\n    (let [acc (if-not (= (first s) p)\r\n                  (conj acc macc)\r\n                  acc)\r\n          macc (if (= (first s) p)\r\n                  (conj macc p)\r\n                  [(first s)])]\r\n      (if (next s)\r\n        (recur (next s) (if (= (first s) p) p (first s))\r\n                macc acc)\r\n        (conj acc macc)))))","problem":31,"user":"4e21c139535d04ed9115e819"},{"code":"(fn pack-seq [l]\n  ((fn do-pack [the-list acc nl]\n    (if (empty? the-list)\n      (conj acc nl)\n      (let [fl (first the-list) etc (rest the-list)]\n        (if (= fl (last nl))\n          (do-pack etc acc (conj nl fl))\n          (do-pack etc (conj acc nl) [fl])\n        )\n      )\n    )\n  ) (rest l) [] [(first l)])\n)","problem":31,"user":"4e720985535d5021c1a89655"},{"code":"(fn [lst]\n  (reverse\n   (reduce\n    (fn [s i]\n      (if (= (first (first s)) i)\n        (conj (rest s) (conj (first s) i)\n              )\n        (conj s (list i))))\n    '()\n    lst)))","problem":31,"user":"527ccaf4e4b0757a1b17136d"},{"problem":31,"code":"(fn[x](\n  (fn pack [src tgt]\n    (if (empty? src)\n      tgt\n      (let [sw (split-with #(= (first src) %) src)]\n        (do          \n          (pack (sw 1) (conj tgt (sw 0)))\n        )\n\t  )\n  )) (reverse x) '())\n)","user":"54f4a457e4b0f2f3c5226e83"},{"problem":31,"code":"(fn [in] (partition-by identity in) )","user":"5c94cbb1e4b048ec896c5a3d"},{"problem":31,"code":"(fn compress\n[x]\n(loop [current x\n       final []]\n  (if (empty? current)\n    final\n    (if (= (first (last final)) (first current))\n      (recur (rest current) (conj (into [] (-> final (reverse) (rest) (reverse))) (conj (last final) (first current))))\n      (recur (rest current) (conj final [(first current)]))\n    )\n    )))","user":"5c1d9f05e4b0efcb0b05b24c"},{"problem":31,"code":"(fn\n  [lst]\n  (loop [lst lst\n         res ()]\n        (if (empty? lst)\n          (reverse res)\n          (recur (drop-while #(= (first lst) %) lst)\n                 (cons (take-while #(= (first lst) %) lst) res)))))","user":"5aa2f1dee4b0d174b936c865"},{"code":"(fn \n  [coll]\n  (partition-by identity coll))","problem":31,"user":"51804bcbe4b04f45bde7d901"},{"code":"(fn [input]\n  (reduce #(if (= %2 (-> %1 last first))\n             (concat (drop-last %1) (-> (last %1) (conj %2) list))\n             (concat %1 (-> %2 list list)))\n          '()\n          input))","problem":31,"user":"51ab4082e4b04e3dc0c27b31"},{"problem":31,"code":"(fn pack-a-sequence\n  [coll]\n  (loop [[x & rest] coll\n         cur []\n         result []]\n    (if (empty? rest)\n      (if (= (first cur) x)\n        (conj result (conj cur x))\n        (conj result cur (list x)))\n      (if (= (first cur) x)\n        (recur rest (conj cur x) result)\n        (if (empty? cur)\n          (recur rest [x] result)\n          (recur rest [x] (conj result cur)))))))","user":"5f003099e4b0cf489e8d7f17"},{"code":"(fn packseq ([x]\r\n  (packseq (butlast x) (list (last x)) (list)))\r\n  ([x y z]\r\n    (println x)\r\n    (println y)\r\n    (println z)\r\n    (if (= 0 (count x))\r\n      (conj z y)\r\n      (if (= 0 (count y))\r\n        (recur (butlast x) (list (last x)) z)\r\n        (if (= (last x) (first y))\r\n          (recur (butlast x) (conj y (last x)) z)\r\n          (recur (butlast x) (list (last x)) (conj z y)))))))","problem":31,"user":"4e16bdef535d04ed9115e7e9"},{"problem":31,"code":"#_(fn pack [coll]\n    (if (empty? coll)\n      ()\n      (let [fst (first coll)\n            nxt (next coll)\n            acc (pack nxt)]\n        (if (= fst (first nxt))\n          (conj (next acc) (conj (first acc) fst))\n          (conj acc (conj () fst))))))\n\n(fn [coll]\n    (partition-by identity coll))","user":"529e3258e4b04e0c58e87b8d"},{"code":"(fn\n  [coll]\n  (partition-by identity coll)\n  )","problem":31,"user":"52ba447ee4b07a9af57922ce"},{"problem":31,"code":"(fn fn31 [xs] (partition-by identity xs))","user":"5e42ba49e4b01d43a70e8e6c"},{"code":"(fn [coll]\n  (partition-by identity coll)\n)","problem":31,"user":"52430d3ce4b076204b44faa5"},{"problem":31,"code":"(fn [lst]\n  (if (empty? lst)\n    lst\n    (loop [accum [(first lst)]\n           lst (rest lst)\n           result []]\n      (cond\n        (empty? lst) (list* (conj result (list* accum)))\n        (= (first accum) (first lst))\n        (recur (conj accum (first lst)) (rest lst) result)\n        :else (recur [(first lst)] (rest lst) (conj result (list* accum)))))))","user":"59e55cc8e4b08badc2a0c555"},{"problem":31,"code":"(fn pack [s]\n  (reduce\n  (fn [m e]\n    (if (= e\n          (-> m last last))\n      (update-in m [(dec (count m))] #(conj %1 e))\n      (conj m [e])))\n  []\n  s))","user":"552d2e4fe4b076ab5578f7e1"},{"problem":31,"code":"#(loop [acc '() grp '() [r & rs] %]\n    (cond (nil? r) (reverse (conj acc grp))\n          (and (not (empty? grp)) (= r (first grp))) (recur acc (conj grp r) rs)\n          :else (recur (if (empty? grp) grp (conj acc grp)) (list r) rs)))","user":"5310e968e4b08068f379ecdd"},{"problem":31,"code":"#(into [] (partition-by identity %))","user":"5e121a89e4b099d064962fe4"},{"problem":31,"code":"(fn pack [xs] (if-not (empty? xs) (let [[ys zs] (split-with #(= (first xs) %) xs)] (cons ys (pack zs)))))","user":"5bc20634e4b07a9b28b10022"},{"problem":31,"code":"(fn pack-seq [coll]\n  (loop [rest-coll coll packed-coll []]\n    (if (empty? rest-coll)\n      packed-coll\n      (let [item (first rest-coll)\n            [next-packed new-rest-coll] (split-with (partial = item) rest-coll)]\n       (recur new-rest-coll (conj packed-coll next-packed))))))","user":"5890799be4b00487982d51d6"},{"code":"(fn [n]\n    (->>\n     n\n     (reductions (fn [[idx n] m]\n                   (if (= n m)\n                     [idx m]\n                     [(inc idx) m]))\n                 [-1 nil])\n     (rest)\n     (group-by first)\n     (vals)\n     (map (partial map second))))","problem":31,"user":"4fa5ddfde4b081705acca1b1"},{"problem":31,"code":"(fn pack\n  [lst]\n  (partition-by identity lst))","user":"56df7440e4b0ca2494a095fb"},{"problem":31,"code":"(fn p [x] (let [d (fn [x] (drop-while #(= (first x) %) x))\r\n                t (fn [x] (take-while #(= (first x) %) x))] \r\n            (if (-> x (t) (count) (> 1))\r\n            (cons (t x)\r\n                  (if (-> x (d) (count) (> 0))\r\n                    (-> x (d) (p))))\r\n            (cons (list (first x))\r\n                  (if (-> x (d) (count) (> 0))\r\n                    (-> x (d) (p)))))))","user":"6093cc08e4b00e9e6653c3e1"},{"problem":31,"code":"(fn [coll]\n  (loop [[head & tail] coll\n         result []]\n    (if head\n      (recur tail (if (= head (last (last result))) \n                    (conj (vec (drop-last result)) (conj (last result) head)) \n                    (conj result [head])))\n      result)))\n;;partition-by identity","user":"553e3260e4b0a04f792994eb"},{"problem":31,"code":"(fn pack-seq\n  [coll]\n  (partition-by identity coll))","user":"6098263be4b00e9e6653c3f9"},{"code":"(fn [xs]\n  (loop [xs xs ys []]\n    (if (empty? xs)\n      ys\n      (let [h  (first xs)\n            ms (take-while #(= h %) xs)\n            t  (drop-while #(= h %) xs)]\n        (recur t (conj ys ms))))))","problem":31,"user":"5063b9a0e4b075d771da6f9d"},{"code":"(fn pack [tl] ( letfn [(pick [l] (loop [e (first l) ll (rest l) result (list e)] (if (not= e (first ll)) (cons result (list ll)) (recur e (rest ll) (cons e result)))))] (if (empty? tl) '() (cons (first (pick tl)) (pack (second (pick tl)))))))","problem":31,"user":"510931ede4b0c71f76895663"},{"problem":31,"code":"(fn mi [s]\n  (reverse \n    (reduce (fn [a x]\n              (if (= x (ffirst a))\n                (conj (rest a) (conj (first a) x))\n                (conj a (list x))))\n            (list (list (first s))) (rest s))))","user":"5b774e66e4b047b03b2036ec"},{"problem":31,"code":"(fn [arg]\n   (loop [a []\n          b (conj [] (first arg))\n          c (rest arg)]\n     (if (empty? c)\n       (conj a b)\n       (if (= (first b) (first c))\n         (recur a (conj b (first c)) (rest c))\n         (recur (conj a b) (conj [] (first c)) (rest c))))))","user":"58455b05e4b089d5ab817e65"},{"problem":31,"code":"#(->> %\n     (reduce (fn [[agg prev-l] n]\n               (if (= (first prev-l) n)\n                 [agg (cons n prev-l)]\n                 [(conj agg prev-l) (list n)])) [[] ()])\n     (apply conj)\n     (drop 1))","user":"567d132ee4b05957ce8c61c3"},{"problem":31,"code":"(fn [y] (reverse (reduce (fn [r x] (if (= (first (first r)) x) (conj (rest r) (conj (first r) x)) (conj r (list x)))) '() y)))","user":"5a0ba67be4b04bbd27e6d997"},{"problem":31,"code":"(fn [foo]\n  (partition-by identity foo)\n  \n  )","user":"595d0897e4b066ee0a44b00f"},{"code":"(fn group-dups [xs]\n    (if (empty? xs)\n        '()\n        ((fn [as xs cs]\n            (if (empty? xs)\n                    (seq (map seq (conj as cs)))\n                    (if (not= (first xs) (first cs))\n                        (recur\n                            (conj as cs)\n                            (rest xs)\n                            [(first xs)])\n                        (recur\n                            as\n                            (rest xs)\n                            (conj cs (first xs)))\n                    )\n            )\n        ) [] (rest xs) [(first xs)])\n    )\n)","problem":31,"user":"517bf28de4b07ef0e56148d5"},{"code":"(fn pack [sqnc]\n  (loop [lista (rest sqnc)\n         packed (list (list (first sqnc)))]\n    (if (empty? lista) (reverse packed)\n\t(recur (rest lista) (if (= (first lista) (first (first packed)))\n                              (cons (cons (first lista) (first packed)) (rest packed))\n                              (cons (list (first lista)) packed))))))","problem":31,"user":"5213348ae4b0d32679a50652"},{"code":"(fn pack\r\n  ([[x & rest]] (pack rest (list x) x))\r\n  ([[x & rest] acc last]\r\n    (if x\r\n      (if (= x last)\r\n        (pack rest (cons x acc) x)\r\n        (cons acc (pack rest (list x) x)))\r\n      (list acc))))","problem":31,"user":"500159b3e4b0678c553fc419"},{"code":"(fn pack [xs]\n  (if (empty? xs)\n    '()\n    (let [f (first xs)]\n      (loop [grp (list f), rs (rest xs)]\n        (if-not (= f (first rs))\n          (cons grp (pack rs))\n          (recur (cons f grp) (rest rs)))))))","problem":31,"user":"532b9075e4b09d4e7a9b5533"},{"problem":31,"code":"(fn [xs]\n       (reverse\n         (reduce\n           (fn [acc v]\n             (if (and (coll? (first acc)) (= v (first (first acc))))\n               (cons (cons v (first acc)) (rest acc))\n               (cons [v] acc)\n               )\n             )\n           []\n           xs\n           )\n         )\n       )","user":"5a55114ae4b05d388ecb6c37"},{"code":"(fn pack-consecutive [collection-param]\n; utility function for packing the equals elements\n((fn packer [result previous collection-param]\n  ;work on collection\n  ;but only if collection has some elements\n  (if-let [[head & args] (seq collection-param)]\n    (if (= head (first previous))\n      ; if head, i.e. the first element in the collection is\n      ; equals to the first element of the sub-list in check\n      ; then add the head in this sub-list (previous) and call packer forward\n      ; with the rest of the collection, called args\n      (packer result (conj previous head) args)\n      ; else add the previous list in the result, \n      ; create a new previous list to work on and go forward with packer\n      (packer (conj result previous) [head] args)\n    )    \n ; )\n  ;if the collection is empty then return the last conjunction\n  (conj result previous))\n)\n\n; the packer function start with this initial arguments:\n; result: [] an empty collection\n; previous: [(first collection-param)] the first element of the collection\n; collection: (rest collection-param) the rest of the collection\n[] [(first collection-param)] (rest collection-param)\n))","problem":31,"user":"5020d2aee4b0cb6ebc0a42fb"},{"problem":31,"code":"(fn [xs]\n  (reduce (fn [acc x]\n            (if (= (last (last acc)) x)\n              (concat (butlast acc) (list (concat (last acc) (list x))))\n              (concat acc (list (list x)))))\n          (list)\n          xs))","user":"587100d6e4b01531a375e9f0"},{"problem":31,"code":"(fn pack [s]\n  (loop [input (seq s)\n         current []\n         result []]\n    (let [fst (first input)\n          rst (rest input)]\n      (if (empty? input)\n        (if (empty? current)\n          result\n          (conj result current))\n        (if (= fst (first rst))\n          (recur rst (conj current fst) result)\n          (recur rst [] (conj result (conj current fst))))))))","user":"60704214e4b069485764de24"},{"problem":31,"code":"(fn pack [S]\n  (reduce\n   #(if (= (last (last %1)) %2)\n      (assoc %1 (dec (count %1)) (conj (last %1) %2))\n      (conj %1 [%2]))\n   []\n   S))","user":"56f53962e4b046a417f9206c"},{"problem":31,"code":"(fn [input]\n   (rest\n     (loop [input input\n            output []\n            last nil\n            cnt 0]\n       (if (empty? input)\n         (conj output (repeat cnt last))\n         (let [first-item (first input)\n               rest-seq (rest input)]\n           (if (= last first-item)\n             (recur rest-seq output last (inc cnt))\n             (recur rest-seq (conj output (repeat cnt last)) first-item 1)))))))","user":"5b6002c2e4b0c6492753e6fb"},{"code":"#(reverse \n  (reduce \n    (fn [xs y] \n      (if (= (first (first xs)) y)\n          (cons (cons y (first xs)) (rest xs))\n          (cons (list y) xs)))\n    (list (list (first %1)))\n    (rest %1)))","problem":31,"user":"50555c06e4b0ce54f56f03fa"},{"problem":31,"code":"(fn pack\n     [s]\n     (loop [sq (rest s)\n            dups (list (first s))\n            final '()]\n           (cond (empty? sq) (concat final (list dups))\n                 (= (first sq) (first dups)) (recur (rest sq) (cons (first dups) dups) final)\n                 :else (recur (rest sq) (list (first sq)) (concat final (list dups))))))","user":"4f867b25e4b033992c121c51"},{"code":"(fn hop [xs]\n  (if (empty? xs)\n    '()\n    (lazy-seq\n      (let [f #(= % (first xs))]\n      (cons (take-while f xs) \n            (hop (drop-while f xs)))))))","problem":31,"user":"4e4fbd0c535dc968683fc4e9"},{"problem":31,"code":"(fn [coll]\n  (reduce \n          (fn [packaged n]\n              (let [lastPack (last packaged)\n                     consecutive? (= (first lastPack) n)]\n                   (if consecutive?\n                       (conj (apply vector (butlast packaged)) (conj (last packaged) n))\n                       (conj packaged (vector n))))) \n          []\n          coll))","user":"5aa7e6eae4b0d174b936c8c0"},{"problem":31,"code":"(fn [sequence]\n  (partition-by identity sequence))","user":"4fbfbd4fe4b081705acca31c"},{"problem":31,"code":"(fn hs-group [xs]\n  (loop [acc nil ls xs]\n    (if (empty? ls)\n      (reverse acc)\n      (let [[f & re] ls]\n        (recur  (if (= f (first (first acc)))\n                  (cons (cons f (first acc))\n                        (rest acc))\n                  (cons (list f) acc))\n                re)))))","user":"598601f9e4b021a7a535fe79"},{"code":"(fn pack-conseq-dupes [coll]\r\n  (loop [last nil\r\n         coll coll\r\n         result []\r\n         subresult []]\r\n    (if (empty? coll)\r\n      (if-not (empty? subresult)\r\n        (conj result subresult)\r\n        result)\r\n      (let [f (first coll)]\r\n        (recur f (rest coll)\r\n               (if (= last f) result (if (empty? subresult) result (conj result subresult)))\r\n               (if (= last f) (conj subresult f) [f]))))))","problem":31,"user":"4fe54ee8e4b0e8f79898fec3"},{"problem":31,"code":"(fn pack-a-sequence\n   [collection-item]\n   (reverse\n     (reduce (fn\n               [list item]\n               (if (= (first (first list)) item)\n                 (cons (conj (first list) item) (rest list))\n                 (cons (conj '() item) list))) '() collection-item)))","user":"60396c95e4b0d5df2af222f4"},{"code":"(fn pack [coll]\n  (loop [coll coll\n         packed []]\n        (if (empty? coll)\n            packed \n            (let [x (first coll)\n                  packet (take-while (partial = x) coll)]\n                 (recur (drop (count packet)coll)\n                        (conj packed packet))))))","problem":31,"user":"52561be5e4b0541d1855ba08"},{"problem":31,"code":"(fn [l]\n  (loop [li l le () la nil]\n    (if (empty? li)\n      (reverse le)\n      (recur\n       (rest li)\n       (if (not (= (first li) la))\n         (conj le (list (first li)))\n         (conj (rest le) (concat (list (first li)) (first le))))\n       (first li)))))","user":"52979551e4b02ebb4ef75043"},{"problem":31,"code":"(partial (fn [c sc x] (if-let [x1 (first x)]\n                        (if (or (empty? sc) (= x1 (last sc)))\n                          (recur c (conj sc x1) (rest x))\n                          (recur (conj c sc) [x1] (rest x)))\n                        (conj c sc)))\n         [] [])","user":"54f2fe9fe4b050824f58f5b8"},{"problem":31,"code":"(fn pack [collection]\n      (reverse (reduce (fn [coll item]\n                          (if (= (first (first coll)) item)\n                              (conj (rest coll) (conj (first coll) item))\n                              (conj coll [item]))) \n                       []\n                       collection)))","user":"562eeba2e4b0ab312c17ebc1"},{"problem":31,"code":"reduce #(let [l (last %)]\n           (if (= %2 (first l))\n                  (conj (vec (drop-last %)) (conj l %2))\n                  (conj % (list %2)))) []","user":"54b45938e4b05787c3b1638f"},{"problem":31,"code":"(fn pack \n  ([coll] (pack coll '()))\n  ([coll res]\n    (do \n      (print res \"|\" coll \"\\n\")\n      (if (seq coll)\n        (let [lastv (first (last res))\n              nextv (first coll)]\n            (pack (rest coll) \n                  (if lastv\n                    (if (= lastv nextv)\n                      (concat (butlast res) [(concat (last res) [nextv])])\n                      (concat res [[nextv]]))\n                    [[nextv]])))\n      res))))","user":"54165291e4b01498b1a719fb"},{"code":"(fn [x]\n  (loop\n    [tr []\n     temp [(first x)]\n     r (rest x)]\n    (if (= nil (first r))\n      (conj tr temp)\n      (recur\n       (if\n         (=\n          (first r)\n          (first temp))\n         tr\n         (conj tr temp))\n       (if (= (first r) (first temp))\n         (conj temp (first r))\n         (vector (first r)))\n       (rest r)))))","problem":31,"user":"530d85dee4b08068f379eca8"},{"problem":31,"code":"(fn pack\n  \n  [lst]\n  (if (empty? lst)\n    ()\n    (loop [lst2 lst\n           new-list-out ()\n           new-list ()\n           first-loop 0\n           currVal (first lst2)]\n      (if (empty? lst2)\n        (reverse (conj new-list-out new-list))\n        (if (= first-loop 0)\n          (recur (rest lst2)  new-list-out (conj new-list currVal) (+ 1 first-loop) (first (rest lst2)))\n          (if (= currVal (first new-list))\n            (recur (rest lst2) new-list-out (conj new-list currVal) first-loop (first (rest lst2)))\n            (recur (rest lst2) (conj new-list-out new-list) (conj () currVal ) first-loop (first (rest lst2)))))))))","user":"59e12c94e4b08badc2a0c509"},{"problem":31,"code":"#(reduce (fn [acc curr] (if (= curr (last (last acc))) (concat (butlast acc) (list (conj (last acc) curr))) (concat acc (list (list curr))))) '() %)","user":"5d63f1c2e4b0c9e5857d502b"},{"code":"(fn [s]\n   (reverse\n   (reduce (fn [l x] (if (= x (first (first l)))\n                       (conj (rest l) (conj (first l) x))\n                       (conj l (list x))))\n           '()\n           s)))","problem":31,"user":"5084cb7de4b0fb8f40674bfb"},{"code":"(fn f [s]\n  (if (seq s) \n    (let [[h t] (split-with #(= (first s) %) s)]\n      (cons h (f t)))))","problem":31,"user":"4e6a4038535d8ccf87e9feb5"},{"problem":31,"code":"(fn [s] (loop [in (rest s) out [[(first s)]]]\n          (if (empty? in)\n            out\n            (if (= (first in) (last (last out)))\n              (recur (rest in) (assoc out (dec (count out)) (conj (last out) (first in))))\n              (recur (rest in) (conj out [(first in)]))\n              ))))","user":"565233f2e4b0f9d632dd8461"},{"code":"(fn pack [l]\n  (if (empty? l)\nl\n(conj (pack (drop-while #(= % (first l)) l))\n  (take-while #(= % (first l)) l))\n))","problem":31,"user":"4fcebce4e4b03432b189f404"},{"code":"(fn [l]\n  (loop [result [] l l]\n    (if (seq l)\n      (let [subl (take-while (partial = (first l)) l)]\n        (recur (conj result subl) (drop (count subl) l)))\n      result)))","problem":31,"user":"50b1d166e4b03ea880433554"},{"code":"(fn [s]\n           (letfn [(p1 [acc s v]\n                     (let [v (if (= v nil) (first s) v)\n                           h (first s)\n                           t (rest s)]\n                       (if (= h v)\n                         (p1 (cons h acc) t v)\n                         (list acc (cons h t)))))\n                   (pack [s]\n                     (let [[h t] (p1 nil s nil)]\n                       (if (= t '(nil))\n                         (list h)\n                         (cons h (pack t)))))]\n             (pack s)))","problem":31,"user":"51a8b576e4b08d8ec191b81a"},{"code":"(fn [x] \n  (loop [y x, previous nil, current (first x), res (), tmpElt ()]\n    (cond (= y ()) (reverse (conj res tmpElt))\n    (= current nil) (recur (rest y) nil nil (conj res tmpElt) ())\n          (or (= previous current) (= previous nil)) (recur (rest y) current (first (rest y)) res (conj tmpElt current))\n          :else (recur (rest y) current (first (rest y)) (conj res tmpElt) (list current)))))","problem":31,"user":"4e49a7bb535dc968683fc4c6"},{"code":"(fn pakk [listy]\n  (cond\n   (empty? listy) listy\n   :else (cons (take-while #(= (first listy) %) listy) (pakk (drop-while #(= (first listy) %) listy)))))","problem":31,"user":"51b89503e4b050a1176cd69a"},{"problem":31,"code":"(fn [a] \r\n  (reverse (reduce \r\n            #(if (= (ffirst %1) %2) \r\n                (conj (next %1) (conj (first %1)\r\n                      (ffirst %1))) (conj %1 `(~%2)))\r\n            () (seq a))))","user":"55af7e21e4b03311e7b732cc"},{"problem":31,"code":"#(reverse \n  (loop [ele '()\n        res '()\n        input %]\n   (cond\n    (empty? input) (cons ele res)\n    (empty? ele) (recur (list (first input)) res (rest input))\n\t(= (first ele) (first input)) (recur (cons (first input) ele) res (rest input))\n    :else (recur (list (first input)) (cons ele res) (rest input)))))","user":"5f016f37e4b0cf489e8d7f20"},{"problem":31,"code":"(fn\n  [s]\n  (reduce \n   (fn\n    [acc x]\n    (let [dones (drop-last acc)\n          todo (last acc)]\n      (cond\n       (empty? todo) [[x]]\n       (= (last todo) x) (concat dones [ (conj todo x)]);(conj dones (conj todo x))\n       :else (concat dones [todo] [[x]] ))))\n   [[]]\n   s))","user":"5576fee3e4b05c286339e078"},{"problem":31,"code":"(fn pack [seq]\n       (reverse\n        (reduce (fn rad [[frst & rst] nxt]\n                  (if (= (first frst)  nxt)\n                    (conj rst (conj frst nxt))\n                    (conj (conj rst frst) (list nxt)))) \n                (list (list (first seq)))\n                (rest seq))))","user":"5a813b90e4b00b71e582a065"},{"code":"(fn packseq [x]\r\n( loop [input x output (list)]\r\n  (if (empty? input) \r\n\t\toutput\r\n\t\t( if (= (last(last output)) (first input)) \r\n\t\t( recur (rest input) (concat (butlast output) (list ( conj ( last output) (first input)))))\r\n\t\t( recur (rest input) (concat output (list (list (first input)))))))))","problem":31,"user":"4f00c74f535dcb61093f6a31"},{"code":"(fn [col] (loop [tmp () agg () data col]\n\t\t   (if (empty? data)\n\t\t     (reverse agg)\n\t\t     (recur (if (= (first data) (first (rest data))) (cons (first data) tmp) '()) (if (= (first data) (first (rest data))) agg (cons (cons (first data) tmp) agg)) (rest data) ))))","problem":31,"user":"531576b4e4b08068f379ed29"},{"problem":31,"code":"(fn foo [x] (if (empty? x)\n            (list)\n            (cons (take-while (fn [y] (= (first x) y)) x)\n                  (foo (drop-while (fn [y] (= (first x) y)) x)))))","user":"54125062e4b01498b1a719d2"},{"problem":31,"code":"#(reverse\n    (reduce (fn [xs y]\n              (if (= (ffirst xs) y)\n                (conj (rest xs) (cons y (first xs)))\n                (conj xs (list y))))\n            ()\n            %))","user":"5c3ec6dbe4b08cd430848e8a"},{"code":"(fn \n    [s] \n    (let [\n        adjust-seq-counts \n        (fn [s-counts s]\n            (let [\n                s-data-last (last s-counts)\n                s-data-rest (subvec s-counts 0 (dec (count s-counts)))\n                ]\n                (let [k (first s-data-last) n (last s-data-last)]\n                    (if (= k s)\n                        (conj s-data-rest [k (inc n)])\n                        (conj s-counts [s 1])))))\n        create-seq-counts \n        (fn [s] (rest (reduce adjust-seq-counts [[]] s)))\n        ]\n        (let [s-counts (create-seq-counts s)]\n            (for [si s-counts] (for [n (range (last si))] (first si))))))","problem":31,"user":"5235a902e4b0a643f2dcb750"},{"problem":31,"code":"#(reduce \n  (fn [l e]\n    (if (= e (-> l first first))\n    \t(conj (rest l) (conj (first l) e))\n      \t(conj l (list e))))\n  () (reverse %))","user":"59fedc26e4b01bb0ae8afd17"},{"code":"(fn [x] (partition-by identity (vec x)))","problem":31,"user":"520a9897e4b01da9d47a99e1"},{"code":"(fn this [s]\n  (if (empty? s) ()\n    (let [val (first s) \n          spl (split-with #(= % val) s)]\n      (cons (first spl) (this (second spl))))))","problem":31,"user":"4f418eaee4b0d7d3c9f3fce9"},{"code":"(fn [xs]\r\n  (loop [[x & xs] xs\r\n         acc nil]\r\n    (if (not x)\r\n      (reverse acc)\r\n    (if (= (first (first acc)) x)\r\n    (recur xs (cons (cons x (first acc)) (rest acc)))\r\n    (recur xs (cons (list x) acc))))))","problem":31,"user":"4f7c7ed7e4b06e829148e1b4"},{"problem":31,"code":"(fn [seq]\n    (->> seq (partition-by identity) ))","user":"5f0e8312e4b0f30dddfb5d5b"},{"code":"(fn pack [x]\n  (loop [coll (vec x), tmp [], acc []]\n    (if (empty? coll)\n      (rest (conj acc tmp))\n      (if (= (last tmp) (first coll))\n        (recur (rest coll) (conj tmp (first coll)) acc)\n        (recur (rest coll) [(first coll)] (conj acc tmp))))))","problem":31,"user":"4f159ea6535d64f603146445"},{"code":"(fn [x]\n   (letfn [(pack [s r a]\n     (if (empty? s)\n       (concat r (list a))\n       (if (= (first s) (first a))\n         (pack (rest s) r (conj a (first s)))\n         (pack (rest s) (concat r (list a)) (list (first s))))))\n             ]\n     (pack (rest x) '() (list (first x)))))","problem":31,"user":"4f03193e535dcb61093f6a61"},{"code":"(fn pack-unique [ls]\n  (loop [[x & xs] ls\n         acc '(())]\n    (let [acc \n          (if (= x (first (first acc)))\n            (conj (rest acc) (conj (first acc) x))\n            (conj acc (list x)))]\n      (if xs\n        (recur xs acc)\n        (reverse (butlast acc))))))","problem":31,"user":"523b82efe4b07becd5be21f0"},{"problem":31,"code":"(fn pack\n  [coll]\n  (let [result [(first coll)]\n        duplicate? (fn [value] \n                      (if (= (last result) value)\n                          true\n                          (conj result value)\n                          ))]\n    (partition-by duplicate? coll)))","user":"5a3c06fce4b001c08efc0cdd"},{"code":"(fn pack [s]\n  (partition-by identity s)\n  )","problem":31,"user":"503ca47fe4b06c4e0e1fa24f"},{"problem":31,"code":"(fn [xs]\n  (reverse\n    (reduce\n      (fn [[[last-elem & _ :as last-group] & rest-groups :as grouped] x]\n        (if (or (nil? last-elem) (not (= x last-elem)))\n          (cons (list x) grouped)\n          (cons (cons x last-group) rest-groups)))\n      '()\n      xs)))","user":"53217912e4b09d4e7a9b54b3"},{"code":"(fn pack [lst] \n  (letfn [\n   (fpack [lst1] (split-with #(= (first lst1) %) lst1))              \n          ]\n  (if (empty? lst) '()\n  (cons \n    (first (fpack lst)) \n    (pack (second (fpack lst))))\n  )\n    )\n  )","problem":31,"user":"4ecfa05c535d44c135fd68b9"},{"code":"(fn [s]\n  (reverse \n  (reduce (fn [lst v] \n            (if (= (first (first lst)) v)\n              (cons \n               (cons v (first lst))\n               (rest lst))\n              (cons\n               (list v)\n               lst)))\n          '()\n          s)))","problem":31,"user":"534efe66e4b084c2834f4ac1"},{"code":"#(reduce (fn [acc x]\n             (if (= x (last (last acc)))\n               (conj (pop acc) (conj (last acc ) x) )\n               (conj acc (list x))))\n         '[]\n         %)","problem":31,"user":"531bfb69e4b08068f379ed97"},{"problem":31,"code":"(fn [xs]\n  (letfn [(helper [input result sublist prev]\n                  (if (empty? input)\n                    (if (empty? sublist)\n                      result\n                      (conj result sublist))\n                    (if (= (first input) prev)\n                      (helper (rest input) result (conj sublist prev) prev)\n                      (helper (rest input) (conj result sublist) (list (first input)) (first input)))))]\n    (reverse (helper xs '() '() (first xs)))))","user":"5be58beae4b0ed4b8aab4d14"},{"code":"(fn [l] (reverse (loop [acc () s1 l] \n                      (if (empty? s1)\n                        acc\n                        (recur \n                          (if (or (empty? acc) (not= (first (first acc)) (first s1))) \n                            (cons [(first s1)] acc) \n                            (cons (cons (first s1) (first acc)) (rest acc))\n                          ) \n                          (rest s1))   \n                        ))))","problem":31,"user":"50956c2be4b087f34d351ab2"},{"code":"(fn p[x]\n  (partition-by (fn[n] n) x)\n  )","problem":31,"user":"4e9def6b535dbda64a6f6b8f"},{"code":"(fn pack [coll]\n   (reduce (fn [acc i]\n             (if (= (first (first acc)) i)\n                 (conj (rest acc) (cons i (first acc)))\n                 (conj acc (list i)))) nil (reverse coll)))","problem":31,"user":"51736d4de4b00f4b6b0490d7"},{"problem":31,"code":"(fn [x]\n    (partition-by identity x)\n    )","user":"59932f49e4b0b211ea3aaaae"},{"problem":31,"code":"(fn\n    [lst]\n    (let [lst-len (count lst)]\n      (loop [i 0 item (nth lst i) packed []]\n        (let [num-similar (loop [offset 0]\n                            (if (and\n                                 (> lst-len (+ i offset))\n                                 (= item (nth lst (+ i offset))))\n                              (recur (inc offset))\n                              offset))]\n          (if (> lst-len (+ i num-similar))\n            (recur (+ i num-similar) (nth lst (+ i num-similar)) (conj packed (repeat num-similar item)))\n            (conj packed (repeat num-similar item)))))))","user":"5e668d87e4b0e171e1033681"},{"code":"(fn [l]\n   (partition-by identity l))","problem":31,"user":"530c15f7e4b02e82168697d6"},{"code":"(fn pack [s] (if (empty? s) s\n          (cons (list* (first s) (take-while (partial = (first s)) (rest s))) (pack (drop-while (partial = (first s)) (rest s))))))","problem":31,"user":"513bb7a6e4b04402f587b77d"},{"problem":31,"code":"(fn [l]\n   ((fn pack-aux [l acc]\n     (if (empty? l)\n       acc\n       (do (prn acc)\n       (if (and (not (empty? acc)) (= (last (last acc)) (first l)))\n         (pack-aux (rest l) (concat (drop-last acc) (list (conj (last acc) (first l)))))\n         (pack-aux (rest l) (concat acc (list (list (first l)))))))))\n   l '()))","user":"54651faee4b01be26fd746d6"},{"code":"(fn pack [coll]\n  (loop [coll coll]\n    (let [duplicate? (partial = (first coll))]\n(if (empty? coll)\n    coll\n    (concat [(take-while duplicate? coll)]\n            (pack (drop-while duplicate? coll)))))))","problem":31,"user":"4e5d0e96535d8a8b8723a2c8"},{"code":"#(reverse (reduce\n           (fn [a b]\n             (if (= (first (first a)) b)\n               (cons (cons b (first a))\n                     (rest a))\n               (cons (list b) a)\n               )\n             ) () %))","problem":31,"user":"4f9b5a1ce4b0dcca54ed6d16"},{"problem":31,"code":"(fn pack [col]\n  (letfn [(cons-pack [col]\n            (if (next col)\n              (let [tail (cons-pack (next col))\n                    first-val (first (first col))\n                    second-val (first (second col))]\n                (if (= first-val second-val)\n                  (cons (cons first-val (first tail)) (next tail)) \n                  (cons (first col) tail)))\n              col))]\n    (cons-pack (map list col))))","user":"5887518ae4b0f1effa3b76f5"},{"code":"#(\n     (fn inner[x acc]\n       (println   (first x) (last (last acc)) acc)\n       (\n       if (empty? x)\n          acc\n          (if(= (last(last acc)) (first x))\n            (inner (rest x) (conj (into [] (butlast acc)) (conj (last acc) (first x))))\n            (inner (rest x) (conj (into [] acc) [(first x)]))\n            )\n        )\n      ) (into [] %) '()\n     )","problem":31,"user":"528f82d8e4b0239c8a67aef4"},{"code":"(fn [a]\n    (loop [l a s []]\n      (let [j (first l) m (take-while #(= j %) l) x (drop (count m) l)]\n\t(if (nil? j)\n          s\n          (recur x (conj s m))\n        ) \n      )\n    )\n  )","problem":31,"user":"52593207e4b0cb4875a45cd3"},{"problem":31,"code":"#(reduce (fn [x y]\n           (let [last-vector  (last x)\n                 last-elem (last last-vector)]\n             (if (= y last-elem)\n               (conj (into (vector) (drop-last x)) (conj last-vector last-elem) )\n               (conj x (vector y))))) [] %)","user":"56c60b36e4b05cc29241eead"},{"problem":31,"code":"(fn [input]\n  (loop [current (first input)\n         tail (rest input)\n         result [[current]]]\n    (if (empty? tail)\n      result\n      (if (= (first tail) current)\n        (recur (first tail) (rest tail) (conj (pop result) (conj (peek result) (first tail))))\n        (recur (first tail) (rest tail) (conj result [(first tail)]))))))","user":"6023a3abe4b0d5df2af22212"},{"code":"(fn pack [coll]\n      (letfn [\n              (p [acc-coll lst-coll lst xs]\n                (if (empty? xs)\n                  (conj  acc-coll lst-coll)\n                  (if (= (first xs) lst)\n                    (p acc-coll (conj lst-coll lst) lst (rest xs) )\n                    (p (conj acc-coll lst-coll) (list (first xs)) (first xs) (rest xs) )\n                    )\n                  )\n                )\n              ]\n        (reverse (into `() (p [] (list (first coll)) (first coll) (rest coll))))\n        )\n      )","problem":31,"user":"51f81925e4b09be9c177e526"},{"problem":31,"code":"(fn [s]\n  (reduce (fn [coll i]\n            (if (= i (first (last coll)))\n              (concat (butlast coll) [(conj (last coll) i)])\n              (concat coll [[i]])\n            )) [] s))","user":"550aeddae4b06e50f9beb135"},{"code":"(fn [coll] (loop [r coll, acc []] (if (empty? r) acc (let [n (#(if (= (first %) %2) (recur (rest %) %2 (inc %3)) %3) r (first r) 0)] (recur (drop n r) (conj acc (take n r)))))))","problem":31,"user":"53629381e4b0243289761e54"},{"problem":31,"code":"(fn [in] \n  (loop [in in y () result ()]\n    (if (empty? in) \n      result\n      (if (= (first in) (second in)) \n       (recur (rest in) (concat y [(first in)]) result)\n       (recur (rest in) () (concat result (list (concat y (list (first in)) )))) \n      )\n    )\n  )    \n)","user":"58186016e4b0c0e9c07b83ad"},{"code":"(fn [c] \n (partition-by (fn [b] b) c))","problem":31,"user":"4ff4c9dae4b0678c553fc360"},{"problem":31,"code":"reduce (fn [a, e] (if (= e (last (last a)))\n                    (concat (butlast a) (list (concat (last a) [e])))\n                    (concat a [(list e)]))) '()","user":"554c0adde4b0a04f7929959e"},{"code":"(fn [l]\n  (reverse\n\t\t(reduce\n\t\t\t(fn [accum next]\n\t\t\t\t(let [current (first accum)]\n\t\t\t\t\t(if (= (first current) next)\n\t\t\t\t\t\t(cons (cons next current) (rest accum))\n\t\t\t\t\t\t(cons (list next) accum))))\n\t\t\t(list (list (first l)))\n\t\t\t(rest l))))","problem":31,"user":"4fb57e06e4b081705acca2bf"},{"problem":31,"code":"(fn packseq\n  ([coll]\n   (loop [input coll\n          result []\n          current_seq []]\n     (println result current_seq input)\n     (if (empty? input)\n       (conj result current_seq)\n       (let [e (first input)]\n         (if (or (empty? current_seq)  (= e (first current_seq)))\n           (recur (rest input) result (conj current_seq e))\n           (recur (rest input) (conj result current_seq) (list e))))))))","user":"5ab490f4e4b073f17744261d"},{"code":"(fn sp                                                                                         \n  ([l] (sp l []))\n  ([l res] (let[f (first l) pred #(= f %) res (conj res (take-while pred l)) nex (drop-while pred l)]\n             (if (> (count nex) 0) (recur nex res) res)\n             ))\n)","problem":31,"user":"4e44358f535dc968683fc4a8"},{"code":"(fn empaqueta [xs]\n  (if (empty? xs)\n    xs\n    (cons (take-while (fn [x] (= x (first xs))) xs)\n          (empaqueta (drop-while (fn [x] (= x (first xs))) xs)))))","problem":31,"user":"4db51ce0535d87e67b28fe06"},{"problem":31,"code":"(fn [x]\n  (loop [in (seq x) curr '() out '()]\n    (if (empty? in)\n      (reverse out)\n      (let [fin (first in)]\n        (if (= fin (second in))\n          (recur (rest in) (conj curr fin) out)\n          (recur (rest in) '() (conj out (conj curr fin))))))))","user":"56197b47e4b053970a773af8"},{"problem":31,"code":"(fn [col] (partition-by (fn [item] item) col))","user":"56020b3fe4b04bb52996e19b"},{"code":"(fn [seq1]\n   (loop [result [] subresult [(first seq1)] elements (rest seq1)]\n     (if (empty? elements)\n       (conj result subresult)\n       (if (= (first subresult) (first elements))\n         (recur result (conj subresult (first elements)) (rest elements))\n         (recur (conj result subresult) [(first elements)] (rest elements))\n         )\n       )\n     )   \n   )","problem":31,"user":"5106dc1be4b01150e115ebf0"},{"code":"(fn pack [lst]\n  (let [[el1 el2] ((fn pck [lst1 lst2]\n  (if (or (empty? lst1) (= (first lst1) (first lst2)) )\n    (pck (cons (first lst2) lst1) (rest lst2))\n    [lst1 lst2]\n    )) [] lst)]\n    (if (not (empty? el2))\n      (concat [el1]  (pack el2))\n      [el1]\n    )\n  ))","problem":31,"user":"5131c922e4b06942423563c9"},{"code":"(fn pack [a-list]\n   (loop [a-list a-list current-acc '() acc '()]\n     (if (and (empty? a-list) (empty? current-acc))\n       (reverse acc)\n       (if (empty? current-acc)\n       (recur (rest a-list) (cons (first a-list) current-acc) acc)\n       (if (= (first a-list) (first current-acc))\n         (recur (rest a-list) (cons (first a-list) current-acc) acc)\n         (recur a-list '() (cons current-acc acc)))))))","problem":31,"user":"4ede0511535d10e5ff6f5330"},{"problem":31,"code":"(fn [xs]\n    (let [rxs (reverse xs)\n          init (first rxs)]\n      (reduce (fn [packed next] ;; ((3)) 3\n               (let [current-pack (first packed) ;;(3)\n                     current-el (first current-pack)] ;;3\n                    (if-not (= current-el next)\n                      (conj packed (list next))\n                      (conj (rest packed) (conj current-pack next)))))\n           (list (list init))\n           (rest rxs))))","user":"5b62764ae4b0c6492753e725"},{"problem":31,"code":"(fn f [s]\n    (if (empty? s) []\n        (let [[a b] (split-with #(= (first s) %) s)]\n          (cons a (f b)))))","user":"583048d9e4b051871117c007"},{"problem":31,"code":"(fn podsekv4c [sekv]\n  (cond\n    (empty? sekv) '()\n    (= (first sekv) (second sekv))\n    (let [pp ((fn prvapodsekv4c [sekf prvpodsek]\n                (if (= (first sekf) (first prvpodsek)) (prvapodsekv4c (rest sekf) (conj prvpodsek (first sekf)))\n                    prvpodsek)\n                )\n              (rest sekv) (list (first sekv))) ]\n      (conj (podsekv4c (drop (count pp) sekv)) pp)\n      )\n    ;;(conj (drop (count (prvapodsekv (rest sekv) (list (first sekv)))) sekv) (prvapodsekv (rest sekv) (list (first sekv))))\n    :else (conj (podsekv4c (rest sekv)) (list (first sekv)))\n    )\n  )","user":"584d99c5e4b0b7285a6f4e42"},{"problem":31,"code":"(fn f\n  ([coll]\n   (f coll '()))\n  ([coll result]\n   (if (empty? coll)\n     (reverse result)\n     (let [v     (first coll)\n           vs    (rest coll)\n           fst   (first result)\n           fst-v (last fst)]\n       (if (= v fst-v)\n         (f vs (cons (cons v fst) (rest result)))\n         (f vs (cons (list v) result)))))))","user":"524a9556e4b05ef8e38e64b1"},{"problem":31,"code":"(fn [ls] \n    (reverse \n      (reduce \n        (fn [acc x]\n          (if (= (first (first acc)) x)\n            (conj (rest acc) (conj (first acc) x))\n            (conj acc (list x))))\n        '() ls)))","user":"572e43f7e4b0cd1946bd0f83"},{"problem":31,"code":"(fn pack [l]\n  (partition-by identity l))","user":"5508a292e4b06e50f9beb10f"},{"problem":31,"code":"(fn [x]\n  (loop [in x out []]\n    (if (= in [])\n      out\n      (recur\n        (drop-while #(= (first in) %) in)\n        (conj out (take-while #(= (first in) %) in))))))","user":"5e08c3dde4b0978307768fc8"},{"problem":31,"code":"(fn [s] \n\t(loop [[frst & rst] s\n\t       cur              []\n\t       new              [] ]\n\t    (if (nil? frst)\n\t    \tnew\n\t    \t(if (= frst (first rst))\n\t    \t\t(recur rst (conj cur frst) new)\n\t    \t\t(recur rst [] (conj new (conj cur frst)))\n\t    \t)\n\t    )\n\t))","user":"574e7be7e4b02ea114799242"},{"code":"(partial (fn [acc ls]\n  (if (empty? ls)\n    acc\n    (let [v (first ls)\n          nacc (conj acc (take-while #(= % v) ls))]\n    (recur nacc (drop-while #(= % v) ls))))) [])","problem":31,"user":"4fc0853ae4b081705acca327"},{"code":"(fn [ys] \n  (let [ remdup (fn [xxs acc]                                                                                                                                                                                                                               \n                    (let [x (first xxs)                                                                                                                                                                                       \n                          xs (rest xxs)]                                                                                                                                                                                                      \n                      (if (empty? xxs) acc                                                                                                                                                                               \n                          (recur (drop-while #(= x %) xxs) (cons ( take-while #(= x %) xxs) acc)))))]                                                                                                                                             \n      (reverse (remdup ys '()))))","problem":31,"user":"4ed60c9c535d10e5ff6f52dd"},{"problem":31,"code":"(fn pack [l]\n  (reduce (fn [ll a]\n           (if (= (first (last ll)) a)\n             (concat (butlast ll) [(concat (last ll) [a])])\n             (concat ll [[a]]))) [] l))","user":"539c88e1e4b0b51d73faaf2c"},{"problem":31,"code":"(fn [xs] (reverse\n  (reduce \n   (fn [acc x] \n     (if (or \n\t       (nil? (first acc))\n           (not= x (first (first acc))))\n       (cons (list x) acc)\n       (cons (cons x (first acc)) (rest acc))\n       ))\n   '()\n   xs)))","user":"57b60e46e4b0fbc9809a27b6"},{"problem":31,"code":"(fn [coll] \n  (reverse (reduce \n    (fn [packed x]\n      (if (= x (peek (peek packed)))\n        (conj (pop packed) (conj (peek packed) x))\n        (conj packed (list x)))) \n    (list) \n    coll)))","user":"60b3b8a9e4b0e0fa5f1b4233"},{"problem":31,"code":"(fn pack-seq\n  ([xs] (pack-seq (rest xs) '() (first xs)))\n  ([xs ys x]\n    (if (nil? x)\n      (repeat 1 ys)\n      (if (or (empty? ys) (some (partial = x) ys))\n        (pack-seq (rest xs) (conj ys x) (first xs))\n        (conj (pack-seq (rest xs) (repeat 1 x) (first xs)) ys)))))","user":"587cbebbe4b01531a375eb24"},{"code":"(fn f\n  ([x] (f '() '() x))\n  ([subseq result x]\n     (if (empty? x)\n       (if (empty? subseq) (reverse result) (reverse (cons subseq result)))\n       (if (or (empty? subseq) (= (first subseq) (first x)))\n           (recur (cons (first x) subseq ) result (rest x))\n           (recur (cons (first x) '()) (cons subseq result) (rest x)))\n     )\n  )\n)","problem":31,"user":"5302ac7fe4b0d8b024fd3731"},{"problem":31,"code":"(fn [seq]\n   (reduce (fn [ret x]\n             (if (and (> (count ret) 0) (= (first (first ret)) x))\n               (conj \n                (rest ret)\n                (conj (first ret) x)) \n               (conj ret (list x))))\n           (list) (reverse seq)))","user":"546ff835e4b00cfc9eacc1b4"},{"problem":31,"code":"#(partition-by (fn [n] n) %)","user":"5f1aade6e4b091ba50b4dbe4"},{"problem":31,"code":"(fn [s] (let [pack (fn rec [cur-pack remaining]\n                     (cond (nil? remaining) (list cur-pack)\n                           (nil? cur-pack) (rec (list (first remaining)) (next remaining))\n                           (= (first cur-pack) (first remaining)) (rec (cons (first remaining) cur-pack) (next remaining))\n                           :else (cons cur-pack (rec nil remaining))))] \n          (pack nil s)))","user":"55adcc8fe4b03311e7b732ab"},{"problem":31,"code":"(fn pack [xs]\n   (if (> (count xs) 0)\n     (let [streak (take-while #(= % (first xs)) xs)]\n       (conj (pack\n              (nthnext xs\n                       (count streak)))\n             streak))\n     (seq xs)))","user":"53b14289e4b047364c04448b"},{"problem":31,"code":"(fn [xs]\n  (loop [xs xs\n    \t acc '()]\n   (if-let [[x & more-xs] (seq xs)]\n     (if-let [[group & more-acc] (seq acc)]\n       (if (= x (first group))\n         (recur more-xs (cons (conj group x) more-acc))\n         (recur more-xs (cons [x] acc)))\n       (recur more-xs (cons [x] acc)))\n     (reverse acc))))","user":"4ff24a1ae4b0678c553fc337"},{"problem":31,"code":"(fn [xs]\n  (if (not (seq xs)) nil\n      (loop [acc [] sub [(first xs)] xs (rest xs)]\n        (println acc sub)\n        (cond (not (seq xs)) (seq (conj acc (seq sub)))\n              (= (first xs) (first sub)) (recur acc\n                                                (conj sub (first xs))\n                                                (rest xs))\n              :else (recur (conj acc (seq sub)) [(first xs)] (rest xs))))))","user":"5315ba94e4b08068f379ed34"},{"code":"(fn bob [lll]\n  (letfn [(etph \n    ([lis] (etph (rest lis) (list (list (first lis)))))\n    ([lis ans]\n      (println lis ans)\n    (if (empty? lis) ans\n    (if (= (first lis) (first (first ans)))\n      (etph (rest lis) (cons (cons (first lis) (first ans)) (rest ans)))\n      (etph (rest lis) (cons (list(first lis)) ans))\n      )\n      )\n      ))\n    ]\n(reverse (etph lll))\n))","problem":31,"user":"4f2004a1535d64f6031464a7"},{"problem":31,"code":"(fn my-pack\n  [x]\n  (partition-by identity x))","user":"5d9c8a85e4b0eb781811cdad"},{"problem":31,"code":"(fn [x] \n  ( let [data (reverse x)]\n  (loop [ se (next data) new-se ( list(list (first data) ))]\n( do\n( println new-se)\n    ( if (empty? se)\n      new-se\n      (do \n       (if (=(first se)(first (first new-se)) )\n         (recur ( next se) ( concat (list (cons (first se) (first new-se) ))(next new-se)))\n         (recur (next se) (cons (list(first se) ) new-se))))))) ))","user":"5a1c8c26e4b0ff51aa4b3247"},{"problem":31,"code":"(fn pack-seq [seq]\n  \"or could just do (partition-by identity seq)\"\n  (reverse (reduce\n            (fn [new-seq elem]\n              (if (= elem (ffirst new-seq))\n                (cons (cons elem (first new-seq)) (rest new-seq))\n                (cons (list elem) new-seq)))\n            '()\n            seq)))","user":"5fd2e391e4b07e53c2f3f049"},{"code":"(fn [s]\n  (let [\n    [a b]\n    (reduce\n      (fn [[acc ls] el]\n        (if (= (first ls) el)\n            [acc (conj ls el)]\n            [(conj acc ls) [el]]))\n      [[] [(first s)]]\n      (rest s))]\n      (conj a b)))","problem":31,"user":"50427899e4b0add3005c0fc2"},{"problem":31,"code":"(fn pas [x]\n  (if (>= 1 (count x)) (list x)\n        (let [pas-rest (pas (rest x))\n              to-check (first x)]\n          (if (= (first (first pas-rest)) to-check)\n            (cons (cons to-check (first pas-rest)) (rest pas-rest))\n            (cons (list to-check) pas-rest))))\n  )","user":"55993deee4b031d6649c9ba5"},{"code":"(fn [x]\r\n  (partition-by identity x))","problem":31,"user":"4f9aa97ae4b0dcca54ed6d0e"},{"problem":31,"code":"(fn [s] \n  (reduce \n   (fn [seed n]\n     (let [l (peek seed)\n           dl (if l (pop seed))]\n            (if (not= n (first l))\n              (conj seed [n])\n              (conj dl (conj l n)))))\n          []\n          s))","user":"559e7848e4b08a52bd4f97d4"},{"problem":31,"code":"(fn func\n    [ar]\n    (loop [xs ar\n           ans []]\n      (if (empty? xs)\n        ans\n        (let [bin (peek ans)\n              cur (first xs)\n              others (rest xs)]\n          (if (= (peek bin) cur)\n            (recur others (conj (pop ans) (conj bin cur)))\n            (recur others (conj ans [cur]))))))\n\n\n    )","user":"5b8db323e4b0c0b3ffbd49da"},{"problem":31,"code":"(fn [ss]\n  (reduce (fn redd [se x]\n          (if (= (first x) (last x))\n              (concat (butlast se) (vector (into [] (cons (first x) (last se)))))\n              (concat se (vector (vector (first x))))\n          )\n        ) [] (map list ss (cons nil ss)))\n  )","user":"56195e57e4b053970a773af6"},{"code":"(fn com [elems]\n  (println \"start\")\n  (loop [elems elems acc []]\n    (if (empty? elems)\n      acc\n      (let [current-elem (first elems)]\n        (recur\n         (drop-while (partial = current-elem) elems)\n         (conj acc (vec (take-while (partial = current-elem) elems))))))))","problem":31,"user":"51df505be4b01188f062752a"},{"code":"(fn [ret n col]\n  (cond\n    (= (count col) n) \n      (conj ret col)\n    (= (nth col n) (nth col (dec n))) \n      (recur ret (inc n) col)\n    :else\n      (recur (conj ret (take n col)) 1 \n        (drop n col)))) [] 1","problem":31,"user":"50bfe725e4b080409b860f26"},{"code":"(fn [array] (partition-by #(str %) array))","problem":31,"user":"516cbba6e4b06f078fab2525"},{"code":"(fn f [xs]\n  (let [pack (fn pack [acc x]\n              (if (= x (:L acc))\n                (assoc acc\n                       :C (conj (:C acc) x))\n                (assoc acc\n                       :A (conj (:A acc) (:C acc))\n                       :C [x]\n                       :L x)))\n        result (reduce pack {:A [] :C '[] :L (first xs)} xs)]\n     (conj (:A result) (:C result))))","problem":31,"user":"4fae0b85e4b081705acca245"},{"code":"(fn [xs]\n  (seq\n    (reduce\n      (fn [acc x]\n        (let [curr (last acc)]\n          (if (= x (first curr))\n            (conj (pop acc) (conj curr x))\n            (conj acc (list x)))))\n      []\n      xs)))","problem":31,"user":"4fe4c09ee4b0e8f79898febb"},{"code":"(fn [coll]\n  (reduce\n   #(if (= %2 (last (last %1)))\n      (conj\n       (subvec %1 0 (- (count %1) 1))\n       (conj (last %1) %2))\n      (conj %1 (list %2)))\n   []\n   coll))","problem":31,"user":"4fcc70b3e4b0ee37620e1862"},{"problem":31,"code":"#(reduce (fn p [acc n] (if (= (first (last acc)) n) (conj (vec (drop-last acc)) (conj (last acc) n)) (conj acc [n]))) [] %)","user":"56f9392ae4b07572ad1a88ac"},{"code":"#(partition-by max %)","problem":31,"user":"4ee75ec2535d93acb0a66867"},{"problem":31,"code":"(fn [coll]\n  (letfn [(f [coll]\n    (loop [result [] coll coll v nil]\n      (if (empty? coll)\n        [result coll]\n        (if (or (nil? v) (= v (first coll)))\n          (recur (conj result (first coll)) (rest coll) (first coll))\n          [result coll]))))]\n      (loop [result [] coll coll]\n        (let [[r c] (f coll)]\n          (if (empty? coll)\n            result\n            (recur (conj result r) c))))))","user":"5b13f482e4b0cc2b61a3be58"},{"problem":31,"code":"(fn pack-seq\n  [[hh & tt]]\n  (loop [[h & t] tt\n         current hh\n         inner-accum [hh]\n         outer-accum []]\n    (let [new-inner-accum (if (= current h)\n                              (conj inner-accum h)\n                              [h])\n          new-outer-accum (if (= current h)\n                              outer-accum\n                              (conj outer-accum (into () (reverse inner-accum))))]\n      (if (nil? t)\n          (into () (reverse (conj new-outer-accum (into () (reverse new-inner-accum)))))\n          (recur t h new-inner-accum new-outer-accum)))))","user":"58152157e4b0f478707a0631"},{"problem":31,"code":"(fn pack-a-sequence [x]\n  (partition-by identity x))","user":"560d4994e4b05f002753df3c"},{"problem":31,"code":"(fn [lxs] \n  (loop [i (count lxs) ilist lxs grand '() sub '()] \n    (if (= i 0)\n      (if (empty? sub) \n        (reverse grand)\n        (reverse (conj grand sub))\n        )\n      (if (or (= (first sub) (first ilist)) (empty? sub))\n        (recur (dec i) (rest ilist) grand (conj sub (first ilist)))\n        (recur (dec i) (rest ilist) (conj grand sub) (list (first ilist)))\n      )\n    )\n  )\n)","user":"5885e90de4b0f1effa3b76c5"},{"code":"(partial\n\t(fn bar [packs s]\n\t\t\t(if (= s '()) \n\t\t\t\t(reverse packs)\n\t\t\t\t(\n\t\t\t\t\t(fn foo [pack packs s] \n\t\t\t\t\t\t(if (= (first pack) (first s)) \n\t\t\t\t\t\t\t(foo (conj pack (first s)) packs (rest s)) \n\t\t\t\t\t\t\t(bar (conj packs pack) s)\n\t\t\t\t\t\t)\n\t\t\t\t\t) (list (first s)) packs (rest s)\n\t\t\t\t)\n\t\t\t)\n\t)\n\t'()\n)","problem":31,"user":"51a0e0b7e4b0b292b01ee3fb"},{"code":"(fn [coll]\n  (reduce (fn [acc elem] \n    (if (= (first (last acc)) elem) \n      (conj (vec (drop-last acc)) (conj (last acc) elem)) \n      (conj acc [elem])))\n    [] coll))","problem":31,"user":"4ed7b617535d10e5ff6f52f3"},{"problem":31,"code":"(fn [l]\n    (partition-by identity l))","user":"52846deee4b0239c8a67adcf"},{"problem":31,"code":"(fn f [xs]\n  (if (empty? xs)\n    xs\n    (let [x (first xs)\n          [same rest] (split-with #(= x %) xs)]\n      (concat [same] (f rest)))))","user":"5344fe13e4b084c2834f4a32"},{"problem":31,"code":"(fn [xs]\n  (letfn [(pack [as xs]\n                (if (empty? xs)\n                  (list as)\n                  (if (= (first xs) (first as))\n                    (pack (cons (first xs) as) (rest xs))\n                    (cons as (pack (list (first xs)) (rest xs))))))]\n    (pack (list (first xs)) (rest xs))))","user":"5f5e7158e4b02876ed9fcff0"},{"code":"(fn pack [col]\n   (lazy-seq\n     (when (seq col)\n       (let [pred (partial = (first col))]\n         (cons (take-while pred col) (pack (drop-while pred col)))))))","problem":31,"user":"5336a339e4b0e30313ee6c7d"},{"code":"(fn [x]\n  ((fn pack [acc curr x]\n    (if-let [[x-first & x-rest] (seq x)]\n      (if (= (first curr) x-first)\n        (pack acc (conj curr x-first) x-rest)\n        (pack (conj acc curr) (list x-first) x-rest)\n      )\n      (conj acc curr)\n    )\n  ) [] (list (first x)) (rest x))\n)","problem":31,"user":"5303a027e4b0d8b024fd3745"},{"problem":31,"code":"#(loop [w % a [] r []]\n   (if (empty? w)\n     (if (empty? a)\n       r\n       (recur [] [] (conj r a)))\n     (if (empty? a)\n       (recur (rest w) [(first w)] r)\n       (if (= (first w) (first a))\n         (recur (rest w) (conj a (first w)) r)\n         (recur w [] (conj r a))))))","user":"5fb3a096e4b08cb800c85b35"},{"problem":31,"code":"(fn [x]\n   (reduce\n     #(if (or (empty? %1) (not= (last (last %1)) %2))\n        (conj %1 [%2])\n        (conj (vec (drop-last %1)) (conj (last %1) %2))\n        )\n     [] x)\n   )","user":"588906a9e4b0f1effa3b772a"},{"problem":31,"code":"(fn [coll]\n  (reverse\n    (reduce\n      (fn [[curr & prev :as all] x]\n        (if (some #(= % x) curr)\n          (conj prev (conj curr x))\n          (conj all [x])))\n      '()\n      coll)))","user":"5f663bc0e4b02876ed9fd02d"},{"problem":31,"code":"(fn pack-sequence [s]\n  (reverse\n    (loop [result nil\n           input s]\n      (println result input)\n      (cond\n        (empty? input)\n        result\n        (empty? result)\n        (recur (list (list (first input))) (rest input))\n        (= (first (first result)) (first input))\n        (recur\n          (cons\n            (cons (first input) (first result))\n            (rest result)\n            )\n          (rest input))\n        (not= (first (first result)) (first input))\n        (recur (cons (list (first input)) result) (rest input))\n        )\n      )\n    )\n  )","user":"563b9acbe4b0bfe05bf11827"},{"code":"(fn ssd [wem] (reverse (reduce\n(fn glom [xs y]\n  (if (= y (first (first xs)))\n    (cons (cons y (first xs)) (rest xs))\n    (cons (list y) xs))) (list (list (first wem))) (rest wem))))","problem":31,"user":"4ff2430ae4b0678c553fc336"},{"problem":31,"code":"#(reverse (reduce (fn group [s, e]\n  (if (nil? e)\n    s\n    (let [first'2 (comp first first)] \n      (if (not= (first'2 s) e)\n        (conj s (list e))\n        (conj (rest s) (conj (first s) e))\n        )\n      )\n    )\n  ) '() %))","user":"54a1d643e4b09f271ff37c50"},{"problem":31,"code":"(fn pack [input]\n  (loop [unpacked input, packed [], group []]\n    (if (empty? unpacked)\n      (conj packed group)\n      (let [next-item (first unpacked),\n            next-fits-group? (or (empty? group) (= next-item (first group)))]\n        (recur (rest unpacked)\n               (if next-fits-group? packed (conj packed group))\n               (if (not next-fits-group?) [next-item] (conj group next-item)))))))","user":"5eac172fe4b00a66d4a951dd"},{"problem":31,"code":"(fn [coll]\n  (loop [res [] curr [] coll coll]\n    (let [lastv (first coll)\n          lastcurr (last curr)]\n     (if (empty? coll)\n       (if (empty? curr)\n         res\n         (conj res curr))\n       (recur\n         (if (and (not (nil? lastcurr))\n                  (not= lastv lastcurr))\n           (conj res curr)\n           res)\n         (if (= lastv lastcurr)\n           (conj curr lastv)\n           [lastv])\n         (drop 1 coll))))))","user":"55b4fa46e4b01b9910ae2983"},{"code":"(fn [s]\n  (loop [output ()\n         lastval nil\n         curpack ()\n         remain s]\n    (if (empty? remain)\n      (if (empty? curpack) output (concat output [curpack]))\n      (if (nil? lastval)\n          (recur output (first remain) [(first remain)] (rest remain))\n          (if (= lastval (first remain))\n              (recur output lastval (concat curpack [lastval]) (rest remain))\n              (recur (concat output [curpack]) (first remain) [(first remain)] (rest remain))))))\n)","problem":31,"user":"4f036fb3535dcb61093f6ac8"},{"problem":31,"code":"(fn [coll]\n  (loop [[head & tail] coll\n         prev nil\n         s '()]\n    (let [new-s (if (not (= head prev)) (conj s '()) s)\n          inner (first new-s)\n          remaining (rest new-s)\n          retval (conj remaining (conj inner head))]\n      (if (empty? tail)\n        (reverse retval)\n        (recur tail head retval)\n      )\n    )\n  )\n)","user":"59073e0fe4b047aa04b19950"},{"code":"(fn [l]\n  (reduce\n    (fn [x y]\n      (if (empty? x) \n        [[y]]\n        (if (= (first (last x)) y)\n          (assoc-in x [(- (count x) 1) (count (last x))] y)\n          (assoc x (count x) [y])))) '() l))","problem":31,"user":"504e7b88e4b069badc5a33ad"},{"problem":31,"code":"(fn [coll]\n  (partition-by\n   identity coll))","user":"5523fce8e4b0882d96d091b4"},{"code":"(fn [arg]\n  (loop [li arg\n        res '()]\n    (if-let [first_el (first li)]\n      (recur (drop-while #(= first_el %) li) (concat res (list (take-while #(= first_el %) li))))\n      res)))","problem":31,"user":"537881a4e4b06839e8705e46"},{"problem":31,"code":"(fn [sequ]\n  (partition-by identity sequ))","user":"55fc838be4b0f488688e0674"},{"problem":31,"code":"(fn PackASequence [lst]\n  (partition-by identity lst))","user":"607508f3e4b069485764de54"},{"code":"(fn [xs] (loop [r [] v xs]\n    (if (empty? v)\n        r\n        (recur (conj r (take-while #(= % (first v)) v))\n                       (drop-while #(= % (first v)) v)\n  ))))","problem":31,"user":"4e4870d1535dc968683fc4bc"},{"code":"(fn pack [coll]\n  (letfn [(group-run [elem grp coll]\n                     (cond\n                       (empty? coll) (list (cons elem grp))\n                       (= elem (first coll)) (group-run elem (cons elem grp) (rest coll))\n                       :else (cons (cons elem grp) (group-run (first coll) '() (rest coll)))))]\n    (if (empty? coll)\n      '()\n      (group-run (first coll) '() (rest coll)))))","problem":31,"user":"512474ede4b02c3f2a072cce"},{"code":"(fn pack [seq]\n  (if (empty? seq) []\n    (reduce \n      (fn [vec e] \n        (if (= (peek (peek vec)) e) \n          (conj \n            (pop vec) \n            (conj (peek vec) e)\n          )\n          (conj vec [e])\n        ))\n      [[(first seq)]]\n      (rest seq)\n    ))\n)","problem":31,"user":"5268eb68e4b03e8d9a4a71c6"},{"problem":31,"code":"(fn [coll]\n  (loop [x coll\n         res []]\n    (let [y (take-while #(= % (first x)) x)]\n      (if (empty? y)\n        res\n        (recur (nthrest x (count y)) (conj res y))))))","user":"58303fc3e4b051871117c006"},{"problem":31,"code":"(fn[s](reduce \n  (fn[r e] (println r)\n    (if (= e (last (last r)))\n      (conj\n       (into [] (butlast r))\n       (conj (last r) e))\n      (conj r [e])))\n      [] s))","user":"560d491ae4b05f002753df3b"},{"problem":31,"code":"(fn d [x] (reduce (fn dedupe [y z]\n                    (if (= (first (last y)) z)\n                      (conj (subvec y 0 (- (count y) 1)) (conj (last y) z))\n                      (conj y [z]))) [] x))","user":"5f3adcf4e4b004f08c61c531"},{"problem":31,"code":"(fn [a] (loop [my-seq (rest a)\n               my-interm (list (first a))\n               my-acc []]\n            (if (empty? my-seq)\n              (seq (conj my-acc my-interm))\n              (let [[current & new-seq] my-seq]\n                (if (= current (last my-interm))\n                  (recur new-seq (conj my-interm current) my-acc)\n                  (recur new-seq (list current) (conj my-acc my-interm)))))))","user":"5655e056e4b0f9d632dd849b"},{"code":"(fn [[fs & rs :as s]]\r\n    (loop [currval fs, [x & xs :as xss] rs, acc [], currcoll [fs]]\r\n      (if (empty? xss)\r\n        (conj acc currcoll)\r\n        (if (= currval x)\r\n          (recur currval xs acc (conj currcoll x))\r\n          (recur x xs (conj acc currcoll) [x])))))","problem":31,"user":"4ef1ee67535dced4c769f219"},{"problem":31,"code":"reduce #(if (= %2 (peek (peek %1))) (conj (pop %1) (conj (peek %1) %2)) (conj %1 [%2])) []","user":"5be6d0f8e4b0f319e2d7ec51"},{"problem":31,"code":"(fn   [lst]\n  (if (empty? lst)\n    lst\n    (loop [accum [(first lst)]\n           lst (rest lst)\n           result []]\n      (cond\n        (empty? lst) (list* (conj result (list* accum)))\n        (= (first accum) (first lst))\n        (recur (conj accum (first lst)) (rest lst) result)\n        :else (recur [(first lst)] (rest lst) (conj result (list* accum)))))))","user":"59deba46e4b01968742fed7f"},{"code":"(fn pack-seq [xs]\r\n  (loop [x xs r '()]\r\n\t      (if (empty? x)\r\n\t\t  (reverse r)\r\n\t\t(recur (rest x) (if (= (first x) (-> r first first))\r\n\t\t\t\t    (cons (cons (first x) (first r)) (rest r))\r\n\t\t\t\t  (cons (cons (first x) '()) r))))))","problem":31,"user":"4f2942ace4b0d6649770a01e"},{"problem":31,"code":"(fn [coll]\n\t(loop [coll coll\n\t\t   acc []]\n\t\t   (if (empty? coll)\n\t\t    acc\n\t\t   \t(let [r (#(split-with (partial = (first %)) %) coll)]\n\t\t   \t\t(recur (second r) (conj acc (first r)))))))","user":"57c0393be4b05aa3c4741c90"},{"problem":31,"code":"(fn pack [in]\n  (partition-by identity in))","user":"5b107263e4b0cc2b61a3be22"},{"problem":31,"code":"(fn [s]\n   (reverse (reduce (fn [a n]\n              (if (and (first a) (= n (first (first a))))\n                (conj (rest a) (conj (first a) n))\n                (conj a [n]))) [] s)))","user":"56308326e4b073c1cf7a9be9"},{"code":"(fn [s]\r\n  (partition-by identity s))","problem":31,"user":"4fdc067fe4b05e33b9224f69"},{"code":"(fn [s] \n  (loop [s1 (vec s) s2 []]\n    (if (empty? s1)\n      (apply list s2)\n      (if (and (not (empty? s2)) (= (first s1) (first (last s2))))\n        (recur (rest s1) (conj (vec (drop-last 1 s2)) (conj (last s2) (first s1))))\n        (recur (rest s1) (conj s2 (list (first s1))))\n    ))))","problem":31,"user":"53069e16e4b02e8216869798"},{"problem":31,"code":"#(reduce \n  (fn [a x] \n    (if (= (last (last a)) x) \n      (conj (vec (drop-last a)) (conj (last a) x)) \n      (conj a [x])))\n  [] %)","user":"5884e807e4b0f1effa3b76a6"},{"code":"(fn [coll]\r\n  (reverse (reduce\r\n    (fn [c nxt]\r\n      (if \r\n        (= (ffirst c) nxt) (cons (cons nxt (first c)) (next c))\r\n        (cons (list nxt) c)))\r\n  '()\r\n  coll)))","problem":31,"user":"4e02bee8535d04ed9115e791"},{"code":"partition-by #(if 1 %)","problem":31,"user":"4fe9de74e4b0547ebccb2475"},{"problem":31,"code":"#(loop [s % r '() rs '()]\n        (if (seq s)\n          (let [x (first s)\n                xs (rest s)\n                [nr nrs] (if (or (empty? r) (= (first r) x)) [(cons x r) rs] [(list x) (cons r rs)])\n                ]\n            (recur xs nr nrs))\n          (reverse (cons r rs))))","user":"58731176e4b01531a375ea2a"},{"problem":31,"code":"(fn [coll]\n  (loop [[x & xs :as all] (seq coll)\n         acc '()]\n    (if all\n      (recur\n        xs\n        (cond\n          (empty? acc) (cons (list x) acc)\n          (= (first (first acc)) x) (cons (cons x (first acc) ) (rest acc) )\n          :else (cons (list x) acc)\n        )\n       )\n      (reverse acc)\n    )\n  )\n)","user":"57434339e4b0c285004e8a9f"},{"problem":31,"code":"(fn [v] (reduce (fn [new-v new-n] (if (= (last (last new-v)) new-n) (update-in new-v [(dec (count new-v))] #(conj % new-n)) (conj new-v [new-n]))) [] v))","user":"57086931e4b0b0fb43fd069e"},{"code":"(fn [coll]\r\n  ((fn pack [res prev coll]\r\n    (if-let [s (seq coll)]\r\n      (let [f (first s) r (rest s)]\r\n        (if (= f (first prev))\r\n          (pack res (conj prev f) r)\r\n          (pack (conj res prev) [f] r)))\r\n      (conj res prev)))\r\n    [] [(first coll)] (rest coll)))","problem":31,"user":"4dd4f0a8535dae65d5c462e4"},{"problem":31,"code":"#((fn pack-seq [prev-val len col res] (if (empty? col) (into res (list (repeat len prev-val))) (if (= prev-val (first col)) (pack-seq prev-val (inc len) (drop 1 col) res) (pack-seq (first col) 1 (drop 1 col) (into res (list (repeat len prev-val))))))) (first %) 1 (drop 1 %) [])","user":"578e535de4b0ebec4cfb7580"},{"code":"(fn [coll]\n  (letfn [(f56 [coll]\n             (if (seq coll)\n               (let [fst (first coll)\n                     run (cons fst (take-while #(= % fst) (rest coll)))]\n                 (cons run (f56 (drop (count run) coll))))))]\n    (f56 coll)))","problem":31,"user":"4dd59d8b535dae65d5c462eb"},{"problem":31,"code":"(fn pack \n  ([sq]\n   (pack '() sq))\n  ([acc sq]\n    (if (empty? sq)\n      (reverse acc)\n      (loop [acc-in (cons (first sq) '())\n             sqs-in (rest sq)]\n        (if (= (first acc-in) (first sqs-in))\n          (recur (cons (first sqs-in) acc-in) (rest sqs-in))\n          (pack (cons acc-in acc) sqs-in))))))","user":"58d4e73ce4b03c36ff7e594d"},{"problem":31,"code":"(fn func\n  [x]\n  (if (= (count x) 1)\n    (list (list (first x)))\n    (if (= (first x) (second x))\n      (conj (pop (func (rest x))) (conj (first (func (rest x))) (first x)))\n      (conj (func (rest x)) (list (first x)))\n      )\n    )\n  )","user":"56de78fde4b0ea9b8538f83c"},{"problem":31,"code":"(fn pack\n  ([coll]\n                        (pack coll '()))\n                     ([coll res]\n                        (cond\n                         (empty? coll)\n                         res\n                         \n                         (empty? res)\n                         (pack (rest coll) (list (list (first coll))))\n\n                         (= (first coll) (first (last res)))\n                         (pack (rest coll) (concat (butlast res) (list (concat (last res) (list (first coll))))))\n\n                         :else\n                         (pack (rest coll) (concat res (list (list (first coll)))))\n                         \n                         )))","user":"52efd3d9e4b05e3f0be25ed4"},{"code":"(fn [x & packed]\n  (if (empty? x) (reverse packed)\n    (if (empty? packed) (recur (rest x) (list (list (first x))))\n      (if (= (first x) (first (first packed))) (recur (rest x) (conj (rest packed) (conj (first packed) (first x))))\n        (recur (rest x) (conj packed (list (first x))))))))","problem":31,"user":"5306e4b4e4b02e821686979d"},{"problem":31,"code":"(fn pack[l]\n  (reduce (fn [a b]\n            (if (.contains (if (nil? (last a))\n                             []\n                             (last a))\n                           b)\n              (conj  (into [] (butlast a))\n                     (conj (last a) b))\n              (conj a [b])))\n          [] l))","user":"5978305be4b01722bebd4d03"},{"problem":31,"code":"(fn [lst]\n  (loop [orig-list (rest lst)\n         prev-el (first lst)\n         curr-sub-list [(first lst)]\n         packed-list []]\n    (if (empty? orig-list)\n      (concat packed-list [curr-sub-list])\n      (if (= (first orig-list) prev-el)\n        (recur (rest orig-list) prev-el (concat curr-sub-list [prev-el]) packed-list)\n        (recur (rest orig-list) (first orig-list) [(first orig-list)] (concat packed-list [curr-sub-list]))))))","user":"572722c4e4b0c5bde472c134"},{"code":"#(\n  (fn noconsec [in out]\n    (if (empty? in)\n      (reverse out)\n      (if (= (first in) (first (first out)))\n        (noconsec \n\t\t  (rest in)\n          (conj (rest out) (conj (first out) (first in))))\n        (noconsec (rest in) (conj out (list(first in)))))\n    )\n  )\n  (rest %) (list (list (first %)))\n)","problem":31,"user":"52463059e4b09dbe66b56198"},{"problem":31,"code":"(fn pack [s]\n  (loop [l s         \n         tmp '()\n         res '()]    \n    (if (empty? l)\n      (rest (reverse (conj res tmp)))\n      (let [new (first l)\n            cur (first tmp)\n            eq  (= cur new)]        \n        (recur (rest l) \n               (if eq \n                 (conj tmp new)\n                 (list new)) \n               (if eq \n                 res\n                 (conj res tmp)))))))","user":"573f3ccfe4b05c31a32c083f"},{"problem":31,"code":";#(reverse (reduce (fn [x y] (if (= (first x) y) x (conj x y))) () %))\n;#(reverse (reduce (fn [x y] (if (= (first (first x)) y) (conj (conj (first x) y) (rest x))   (conj x (list y)))) nil %))\n\n#(partition-by identity %)","user":"57e4dbcbe4b0bfb2137f5ac3"},{"code":"(fn pack [s]\n  (reverse (reduce (fn [x y]\n            (cond\n             (empty? (first x)) (cons (list y) x)\n             (= (first (first x)) y) (cons (cons y (first x)) (rest x))\n             :else (cons (list y) x)))\n          (list) \n          s)))","problem":31,"user":"5364697ce4b0243289761e62"},{"code":"(fn pack[s]\n  (loop [n []\n         o s\n         current []]\n    (if (empty? o)\n      (conj n current)\n      (if (or (= (first o) (first current)) (empty? current))\n        (recur n (rest o) (conj current (first o)))\n        (recur (conj n current) (rest o) [(first o)])))))","problem":31,"user":"52bdd135e4b07a9af579230a"},{"problem":31,"code":"#(loop [acc []\n       interm (list (first %))\n       [h & t :as r] (rest %)]\n  (if (empty? r)\n    (if (seq interm) \n      (conj acc interm)\n      acc)\n    (if (= (first interm) h)\n      (recur acc (conj interm h) t)\n      (recur (conj acc interm) (list h) t))))","user":"54058af3e4b0addc1aec6669"},{"problem":31,"code":"(fn pack-repeats [xs]\n  (reverse\n   (reduce (fn [acc x]\n             (if (= x (ffirst acc))\n               (conj (rest acc) (conj (first acc) x))\n               (conj acc (list x))))\n           nil\n           xs)))","user":"5db0d470e4b0f8c104ccfc9e"},{"problem":31,"code":"(fn my-seq-pack\n  [s]\n  (partition-by identity s))","user":"567c7fefe4b05957ce8c61bc"},{"problem":31,"code":"; solution for 30 is in closure docs which is pretty much this.\n#(partition-by identity %)","user":"56092852e4b0053d1b86c7d9"},{"code":"#(loop [r [] t [] p nil l %]\n(if (= 0 (count l))\n  (conj r t)\n  (recur \n(if (or (empty? t) (= p (nth l 0)))  r (conj r t)) \n(if (= p (nth l 0)) (conj t p) [(nth l 0)]) \n(nth l 0) (rest l)\n)\n))","problem":31,"user":"4e43b0d9535dc968683fc4a3"},{"code":"(fn [coll]\n  (let [pack-fn (fn [coll val]\n      (if (= (last (last coll)) val)\n\t\t(conj (subvec coll 0 (-> coll count dec)) \n\t\t      (conj (last coll) val))\n\t\t(conj coll [val])))]\n    (reduce pack-fn [] coll)))","problem":31,"user":"4e8dc25f535d65386fec213a"},{"problem":31,"code":"(fn pack-1d\n  [coll]\n  ((fn inner\n      [pack sub-col [orig-f & orig-r :as original]]\n     (cond\n       (= orig-f nil) (concat pack (cons sub-col '()))\n       (or (= sub-col '()) \n           (= orig-f (last sub-col))) \n       (inner pack (concat sub-col (cons orig-f '())) orig-r )\n       (not= orig-f (last sub-col)) (inner  (concat pack (cons sub-col '())) (list orig-f)  orig-r)) ) '() '() coll))","user":"5c75a30ee4b0fca0c16227df"},{"problem":31,"code":"(fn [s]\n                (loop [s (rest s)\n                       ss [(first s)]\n                       out []]\n                  (cond\n                    (empty? s) (conj out ss)\n                    (= (first ss) (first s)) (recur (rest s)\n                                                    (conj ss (first s))\n                                                    out)\n                    :else (recur (rest s)\n                                 [(first s)]\n                                 (conj out ss)))))","user":"5eb22708e4b00a66d4a95204"},{"problem":31,"code":"(fn pack [s]\n  (loop [s s\n         c []\n         r []]\n    (if (empty? s)\n      (if (empty? c) r (conj r c))\n      (if (empty? c)\n        (recur (rest s) (conj c (first s)) r)\n        (if (= (first c) (first s))\n          (recur (rest s) (conj c (first s)) r)\n          (recur (rest s) [(first s)] (conj r c)))))))","user":"5f8b06afe4b0715f5002d74a"},{"problem":31,"code":"(fn pack [input]\n  (seq\n    (reduce (fn [r v]\n              (let [recent (last r)]\n                (if (= (last recent) v)\n                  (conj (pop r) (conj recent v))\n                  (conj r (list v)))))\n      [] input)))","user":"5b9bcba8e4b0c0b3ffbd4b07"},{"problem":31,"code":"(fn pack-dupl\n  [coll]\n  (if (empty? coll)\n    nil\n    (cons (take-while #(= % (first coll)) coll) (pack-dupl (drop-while #(= % (first coll)) coll)))))","user":"568bd448e4b0dcc4269f40a9"},{"problem":31,"code":"(fn [s]\n  (reduce (fn [memo x]\n            (if (= (first (last memo)) x)\n              (conj (vec (butlast memo)) (conj (last memo) x))\n              (conj memo [x])))\n          []\n          s))","user":"577bf999e4b0d3393e5deb2c"},{"problem":31,"code":"(fn pack-consecutives\n    [coll]\n    (partition-by identity coll))","user":"587bead1e4b01531a375eb0d"},{"code":"(fn [coll](\n  reduce\n  \t#(if\n\t\t\t(= (last (last %)) %2)\n\t\t\t\t(concat (butlast %) (list (conj (last %) %2)))\n\t\t\t\t(concat % (list (list %2))))\n    '()\n\t\tcoll))","problem":31,"user":"4ff2f0a9e4b0678c553fc341"},{"code":"(fn [xs]\n  (loop [xs xs acc []]\n    (cond\n     (empty? xs) acc\n     (empty? acc) (recur (rest xs) [(list (first xs))])\n     (= (first xs) (first (last acc))) (recur (rest xs) (conj (pop acc) (conj (last acc) (first xs))))\n     :else (recur (rest xs) (conj acc (list (first xs)))))))","problem":31,"user":"52b8af15e4b07a9af57922b5"},{"problem":31,"code":"(fn [coll]\n  (loop [coll coll acc []]\n    (if (empty? coll)\n      acc\n      (recur (rest coll)\n             (if (= (last (last acc)) (first coll))\n               (conj (vec (butlast acc)) (conj (last acc) (first coll)))\n               (conj acc (vector (first coll))))))))","user":"54fdbe3fe4b07d26eda61d3b"},{"problem":31,"code":"reduce #(if (= (-> %1 last first) %2)\n          (assoc %1 (-> %1 count dec) (conj (last %1) %2))\n          (conj %1 (vector %2)))\n       []","user":"60096aabe4b074f607df667f"},{"problem":31,"code":"; sigh\n(fn [coll]\n  (loop [result [] c (take 1 coll) r (rest coll)]\n    (if-not (empty? c)\n      (if (= (last c) (first r))\n        (recur result (concat c (take 1 r)) (rest r))\n        (recur (conj result c) (take 1 r) (rest r))\n        )\n      result)))","user":"54e3bd3fe4b024c67c0cf7e0"},{"problem":31,"code":"(fn pack \n  [lst]\n  \n  (partition-by identity lst))","user":"5a99ae99e4b0d174b936c7a4"},{"problem":31,"code":"(fn [coll]\n  (loop [s (seq coll), l nil, result ()]\n    (if (empty? s) (reverse result)\n      (let [[f & r] s, [fr & rr] result]\n        (if (= f l)\n          (recur r f (conj rr (conj fr f)))\n          (recur r f (conj result (list f))))))))","user":"56ae7589e4b03c432f187360"},{"code":"(fn [l]\n  (loop [o l\n           c '()\n           r '()]      \n  (if (empty? o)\n      (reverse (cons c r))\n\t(if (or (= (first c) (first o))\t\n            (empty? c))\n      (recur (rest o)  (cons (first o) c)  r)\n      (recur o '() (cons c r))))))","problem":31,"user":"4fea1f9ee4b0547ebccb248b"},{"problem":31,"code":"(fn [s]\n  (loop [left (seq s)\n         result []]\n    (if (empty? left)\n      result\n      (let [head (first left)\n            group (take-while #(= % head) left)\n            resto (drop (count group) left)]\n        (recur resto (conj result group))))))","user":"5947c6a6e4b07ddc2dafada7"},{"problem":31,"code":"(fn pack [n]\n(partition-by identity n))","user":"595e1ba7e4b066ee0a44b036"},{"code":"(fn cseq [[x & xs :as l]]\n                  (if-not (empty? l)\n                    (loop [[y & ys :as m] xs\n                           sublist        (list x)]\n                      (cond\n                       (empty? m) (list sublist)\n                       (= x y)    (recur ys (cons x sublist))\n                       :else      (cons sublist (cseq m))))))","problem":31,"user":"4e71705e535d5021c1a89649"},{"problem":31,"code":"(fn pack [coll]\n  (let [first-group ((fn first-same [coll2]\n                      (if (< (count coll2) 2)\n                        coll2\n                        (if (= (first coll2) (first (rest coll2)))\n                          (cons (first coll2) (first-same (rest coll2)))\n                          (cons (first coll2) '())))) coll)\n        rest-group (drop (count first-group) coll)]\n    (cons first-group (if (empty? rest-group)\n                  '()\n                  (pack rest-group)))))","user":"542cb77ae4b0dad94371f2aa"},{"problem":31,"code":"(fn\n  [l]\n  (when-let [s (seq l)]\n    ((fn [[f & r :as old] work new]\n       (cond (empty? old) (if (empty? work) (seq new) (seq (conj new (seq work))))\n             (= f (last work)) (recur r (conj work f) new)\n             :else (if (empty? work)\n                     (recur r [f] new)\n                     (recur r [f] (conj new (seq work))))))\n     s [] [])))","user":"50e54fe4e4b049a9877538a0"},{"code":"#(reduce (fn [s t]\n  (if (some #{t} (last s))\n  (concat (butlast s) (list (conj (last s) t)))\n  (concat s (list (list t)))))\n  () %)","problem":31,"user":"53820087e4b06839e8705ecf"},{"code":"(fn x [c] (partition-by  identity c))","problem":31,"user":"50d179c7e4b05a71a896ef56"},{"problem":31,"code":"(fn [s] \n  (reverse\n   (reduce \n    #(if (= %2 (-> %1 first first)) \n       (conj (rest %1) (conj (first %1) %2)) \n       (conj %1 [%2])) [] s)))","user":"55536a8ae4b0deb715856e03"},{"code":"(fn [lst]\n  (rest\n   (reverse\n    ((fn iter [res l prev sub]\n       (if (empty? l)\n         (conj res sub)\n         (if (= (first l) prev)\n           (iter res (rest l) prev (concat sub (list (first l))))\n           (iter (conj res sub) (rest l) (first l) (list (first l))))))\n     '() lst nil '()))))","problem":31,"user":"51da631be4b02ceefd947766"},{"code":"(fn pack [coll]\n  (loop [packed [], curr [(first coll)], next (rest coll)]\n    (if (empty? next)\n      (conj packed, curr)\n      (if (= (first next) (first curr))\n        (recur packed, (conj curr (first next)), (rest next))\n        (recur (conj packed curr), [(first next)], (rest next))))))","problem":31,"user":"4ecbff2f535df97575fdabe4"},{"code":"(fn this\n  ([xs] (this xs []))\n  ([xs acc]\n    (if (empty? xs)\n      acc\n      (let [[same diff] (split-with #(= % (first xs)) xs)]\n        (recur diff (conj acc same))))))","problem":31,"user":"4f2e0369e4b0d6649770a064"},{"code":"(fn  [n]\n  (partition-by identity n))","problem":31,"user":"5276aa0de4b03e8d9a4a74ea"},{"code":"#(loop [aa (reverse %1) bb ()]\n    (if (empty? aa)\n     bb  \n     (let [w (loop [a aa b (first a) d ()]\n                   (if (or (not= b (second a)) (< (count a) 2))\n                       (conj d b)\n                       (recur (rest a) (second a) (conj d b))))]\n          (recur (drop (count w) aa) (conj bb w)))))\n\n; that was easy ...","problem":31,"user":"4ffe8193e4b0678c553fc3f4"},{"problem":31,"code":"(fn group-by-duplicates\n  [s]\n  (let [grp-info (reduce\n    \t\t\t         (fn [{:keys [curr-grp all-grps] :as info} el]\n                     (if (or (nil? (seq curr-grp)) (= (last curr-grp) el))\n                       (assoc info :curr-grp (conj curr-grp el))\n                       (assoc info :curr-grp [el]\n                                   :all-grps (conj all-grps curr-grp))))\n                   {:all-grps []\n                    :curr-grp []}\n                   s)\n        {:keys [curr-grp all-grps]} grp-info]\n    (if (seq curr-grp)\n      (conj all-grps curr-grp)\n      all-grps)))","user":"53161a56e4b08068f379ed3e"},{"problem":31,"code":"(fn dupepack [sq]\n  (reduce\n    (fn [f s]\n      (if (= (last (last f)) s)\n        (conj (vec (butlast f)) (conj (last f) s))\n        (conj f [s]))) [] sq))","user":"5bfa25fbe4b0bdcf453d15c8"},{"problem":31,"code":"(fn [input]\n  (reduce (fn [coll val]\n            (if (= (last (last coll)) val)\n              (conj (vec (butlast coll)) (conj (vec (last coll)) val))\n              (conj coll [val]))) [] input))","user":"545b0275e4b01be26fd74648"},{"problem":31,"code":"(fn [i] (partition-by identity i))","user":"5b0948f3e4b0cc2b61a3bdbb"},{"code":"(fn packseq [col] \r\n  (loop [acc [] buf [] c col]\r\n    (println \"acc: \" acc \"buf: \" buf \"c: \" c)\r\n    (cond (empty? c)  (rest (conj acc buf) )\r\n           (= ( first c)(last buf)) (recur acc (conj buf (first c)) (rest c))\r\n           :else (recur (conj acc buf) [(first c)] (rest c))\r\n      )))","problem":31,"user":"4db135081254ad5b4805fa67"},{"problem":31,"code":"(fn foos [seqs]\n        (reverse ((fn foo [seqs temps]\n          (cond\n            (empty? (rest seqs)) (list (concat seqs temps))\n            (=(first seqs) (second seqs)) \n                (foo (rest seqs) (conj temps (first seqs)))\n                :else \n                    (concat (foo (rest seqs) '()) \n                            (list (conj temps (first seqs))))\n                            \n                ))\n         seqs '())))","user":"6038b6b4e4b0d5df2af222ef"},{"code":"(fn pack-dupes [seqn]\n  (cond\n    (empty? seqn) '()\n    (= (first seqn) (second seqn))\n    ((fn find-dupes [seqn acc]\n       (if \n         (or (empty? seqn)\n             (not (= (first seqn)\n                     (second seqn))))\n         (cons (cons (first seqn) acc) (pack-dupes (rest seqn)))\n         (find-dupes (rest seqn)\n                     (cons (first seqn) acc))))\n       seqn '())\n    :else (cons (list (first seqn)) (pack-dupes (rest seqn)))))","problem":31,"user":"50d2f044e4b03c62ef244483"},{"problem":31,"code":"(fn [c]\n  (reverse (reduce (fn [ls v]\n   (cond (empty? ls) (list (list v))\n   (not= v (first (first ls))) (conj ls (list v))\n  :else (conj (rest ls) (conj (first ls) v))))\n  '() c)))","user":"5a7a09e6e4b03baeef9276ca"},{"code":"(fn [l] (letfn [(helper [z acc] (let [h (take-while #(= (first z) %) z) \n                                      rest (drop (count h) z)] \n                                  (cond (empty? rest) (conj acc h) \n                                        (= 1 (count rest)) (conj (conj acc h)  rest)  \n                                        :else (helper rest (conj acc h)))))] \n          (helper l [])))","problem":31,"user":"52265e41e4b04e78ff2e1981"},{"problem":31,"code":"(fn\n  [s]\n  (reduce\n   (fn\n     [coll elem]\n     (if (= (first (last coll)) elem)\n       (vec (conj (vec (butlast coll)) (conj (vec (last coll)) elem)))\n       (vec (conj coll [elem]))))\n   []\n   s))","user":"5c05cae7e4b0bdcf453d16a3"},{"problem":31,"code":"(fn\n  [se]\n  (loop [sec se\n         temp []\n         result []]\n    (let [s (first sec)]\n      (if-not (nil? s)\n        (if (some #{s} temp)\n          (recur (rest sec) (conj temp s) result) \n          (recur (rest sec) [s] (conj result temp)))\n        (filter seq (conj result temp))))))","user":"5f6e23e6e4b02876ed9fd064"},{"problem":31,"code":"(fn pack-consecutive-dups [s]\n  (reverse (reduce\n            (fn [l e]\n             (if (and (sequential? (first l)) (= (first (first l)) e))\n              (conj (rest l) (conj (first l) e))\n              (conj l (list e))))\n            (list)\n            s)))","user":"5af3aa42e4b0cc2b61a3bc8c"},{"code":"(fn [x]\n  (loop [s x r '()]\n    (if (empty? s) r\n      (if (= (last (last r)) (first s))\n        (recur (rest s) (concat (drop-last r) (list (cons (first s) (last r)))  )  )\n        (recur (rest s) (concat r (list (list (first s)))))\n        ))))","problem":31,"user":"523bc0e6e4b07becd5be21f9"},{"code":"(letfn [(f [[x & xs :as c] y]\n          (cond\n            (empty? c)      (conj x (list y))\n            (= (first x) y) (conj (rest c) (conj x y))\n             true           (conj c (list y))))]\n  (fn [x]\n    (reverse (reduce f () x))))","problem":31,"user":"51eadb98e4b0f1f103a0d153"},{"problem":31,"code":"#(loop [out [] in %]\n    (if (empty? in)\n      out\n      (recur (conj out (take-while (fn [x] (= (first in) x)) in)) (drop-while (fn [x] (= (first in) x)) in))))","user":"5e144bd5e4b0a047bd49f6e7"},{"code":"(fn remdup [st] \n                                (reverse (reduce #(if \n                                           (and %1 (not= (first (first %1)) %2)) \n                                           (conj %1 (list %2)) \n                                           (conj (rest %1) \n                                                 (conj (first %1) %2) ))  \n                                         '() \n                                         st)))","problem":31,"user":"4e9de526535dbda64a6f6b8e"},{"problem":31,"code":"(fn dub [lst]\n  (loop [in lst out []]\n    (if (empty? in)\n      (seq out)\n      (recur (rest in)\n             (if (= (last (last out)) (first in))\n               (conj (vec (butlast out)) (conj (last out) (first in)))\n               (conj out (list (first in))))))))","user":"545c2d07e4b01be26fd7465c"},{"problem":31,"code":"#(loop [l % r []] (if (empty? l) r\n                    (recur (drop-while (fn [v] (= v (first l))) l) (concat r [(take-while (fn [v] (= v (first l))) l)]))))","user":"5686b7c7e4b0dcc4269f4057"},{"problem":31,"code":"(fn [ls] (partition-by identity ls))","user":"546d41bde4b00cfc9eacc18c"},{"code":"#(loop [a (seq %) b () c ()]\n   (if a\n     (let [head (first a)]\n       (if (= head (first b))\n         (recur (next a) (cons head b) c)\n         (recur (next a) (list head) (cons b c))))\n     (rest (reverse (cons b c)))))","problem":31,"user":"4e68be01535d8ccf87e9fe88"},{"code":"(fn pack-seq [x]\n  (partition-by identity x))","problem":31,"user":"517a025ce4b01aacecbecbe6"},{"code":"(fn [lista]\n  (loop [[fst snd :as all] lista    mem []    tmp (list fst)]\n    (if (empty? all)\n      (seq mem)\n      (if (= fst snd)\n        (recur (rest all) mem (cons snd tmp))\n        (recur (rest all) (conj mem tmp) (list snd)))\n      )))","problem":31,"user":"4dfd7ecf535d04ed9115e783"},{"problem":31,"code":"(fn pack-seq\n  ([s] (pack-seq s '() '()))\n  ([s result sub-seq]\n   (cond\n    (= s nil) (reverse result)\n    (= (first s) (second s)) (recur (next s) result (conj sub-seq (first s)))\n    :else (recur (next s) (conj result (conj sub-seq (first s))) '()))))","user":"5888b75fe4b0f1effa3b771b"},{"problem":31,"code":"(fn [in]\n  (reverse (reduce \n   #(if (= (first (first %1)) %2)\n      (conj (rest %1) (conj (first %1) %2))\n      (conj %1 (list %2)))\n   []\n   in)))","user":"5845720de4b089d5ab817e68"},{"problem":31,"code":"(fn [s]\n   (reverse\n     (loop [s (seq s)\n            ss ()]\n       (if (empty? s)\n         ss\n         (let [el (first s)]\n           (if (= (ffirst ss) el)\n             (recur (rest s) (conj (rest ss) (conj (first ss) el)))\n             (recur (rest s) (conj ss (list el)))))))))","user":"52475451e4b05ef8e38e6362"},{"code":"#(reduce (fn [coll x]\n  (if (= x (first (last coll)))\n    (conj (vec (butlast coll)) (conj (last coll) x))\n    (conj coll [x]))) [] %)","problem":31,"user":"4e6f1b7a535d5021c1a89618"},{"code":"(fn [x](\n  partition-by identity x))","problem":31,"user":"4ed42c78535d10e5ff6f52c7"},{"problem":31,"code":"#(reverse\n  (reduce\n   (fn [xs x]\n     (if (= (first (first xs)) x)\n       (cons (cons x (first xs)) (rest xs))\n       (cons (list x) xs))) '() %))","user":"5d46fbc6e4b07c84aa5ae6af"},{"code":"#(loop [x (rest %) y (vector (first %)) ans []] (if-not (empty? x) \n                           \n                           (if (= (first x) (first y)) (recur (rest x) (conj y (first x)) ans)\n                             \t(recur (rest x) (vector (first x)) (conj ans y))\n                            )\n                           (conj ans y)\n                           ))","problem":31,"user":"5105ed16e4b01150e115ebe2"},{"code":"(fn pack-seq [s]\r\n  (when (seq s)\r\n\t\t(let [xs (take-while (partial = (first s)) s)]\r\n\t\t\t(cons xs (pack-seq (drop (count xs) s))))))","problem":31,"user":"4dd6d6a0535d2dad7130b5ca"},{"problem":31,"code":"(letfn [(f [s] (if (seq s) (let [[n r] (split-with #(= % (first s)) s)] (cons n (f r)))))] f)","user":"54f0d3fde4b024c67c0cf8a6"},{"problem":31,"code":"#(loop [in % out [] current '()]\n   (cond\n    (empty? in)\n        (seq (conj out current))\n    (empty? current)\n        (recur (rest in) out (list (first in)))\n    (= (first in) (first current))\n        (recur (rest in) out (conj current (first in)))\n    :else\n        (recur (rest in) (conj out current) (list (first in)))))","user":"5ddd6cfae4b0948ae9d9adc4"},{"problem":31,"code":"(fn dup\n  ([li] \n   (dup (rest li) (list (first li)) (vector))\n   )\n  ([li curr ans]\n   (if (empty? li)\n     (conj ans curr)\n     (if (= (first li) (first curr))\n       (dup (rest li) (conj curr (first li)) ans)\n       (dup (rest li) (list (first li)) (conj ans curr))\n       )\n     )\n   )\n  )","user":"5a90395ce4b05369db4d254a"},{"problem":31,"code":"#((fn foo [l r a]\r\n      (if (= 0 (count l))\r\n        (conj r a)\r\n        (if (= (first l) (first a))\r\n          (foo (rest l) r (conj a (first l)))\r\n          (conj (foo (rest l) r (list (first l))) a)))) (rest %) '() (list (first %)))","user":"57a9b2dbe4b0a96607956233"},{"code":"(fn pack [x]\n    (when-let [f (not-empty (take-while #(= % (first x)) x))]\n      (cons f (pack (drop (count f) x)))))","problem":31,"user":"531dfaf5e4b08068f379edb3"},{"problem":31,"code":"reduce #(if \n          (= (last (last %1)) %2) \n          (conj (vec (butlast %1)) (conj (last %1) %2))\n          (conj %1 [%2]))\n          []","user":"5f3ab5ece4b004f08c61c52a"},{"code":"(partial\n reduce\n (fn [xs, x]\n   (if (and\n        (> (count xs) 0)\n        (some (partial = x) (last xs))\n        )\n     (concat (butlast xs) (list (conj (last xs) x)))\n     (concat xs (list (list x)))\n     )\n   )\n'()\n)","problem":31,"user":"51365524e4b04ac1f358dd52"},{"problem":31,"code":"(fn [s](loop [t (list (first s)) s (rest s) r ()] \n         (if (empty? s) \n           (reverse (cons t r)) \n           (if (= (first s)(first t))\n             (recur (cons (first s) t) (rest s) r)\n             (recur (list (first s)) (rest s) (cons t r))))))","user":"5457e5f1e4b01be26fd74613"},{"problem":31,"code":"#(loop [sq (rest %) inl [] med [(first %)]]\n\t(if (empty? sq)\n      (conj inl med)\n      (let [el (first sq)]\n       (if (= el (last med))\n         (recur (rest sq) inl (conj med el))\n         (recur (rest sq) (conj inl med) [el])\n       )\n  )\n )   \n)","user":"5e947a69e4b0fbed045a37f8"},{"code":"(fn [seq]\n  (letfn [(collect-elements [element seq current-collection]\n    (cond \n      (empty? seq) (list current-collection)\n      (= element (first seq))\n        (collect-elements element (rest seq) (cons element current-collection))\n      :else (cons current-collection \n                  (collect-elements (first seq) (rest seq) (list (first seq))))\n    )\n  )]\n  (collect-elements (first seq) (rest seq) (list (first seq))))\n)","problem":31,"user":"4ff83003e4b0678c553fc396"},{"code":"(fn group [coll] (if (= [] coll) coll\n                  (concat (list (take-while #(= % (first coll)) coll)) (group (drop-while #(= % (first coll)) coll)) )))","problem":31,"user":"504e8e48e4b069badc5a33b3"},{"problem":31,"code":"(fn [col]\n  (reduce #(if (= (first (peek %1)) %2)\n             (conj (pop %1) (conj (peek %1) %2))\n             (conj %1 (list %2)))\n          []\n          col))","user":"55597fcce4b0deb715856e37"},{"problem":31,"code":";#(reduce \n ; (fn [coll x] \n  ;  (if (= (first (last coll)) x) \n   ;   (assoc coll (dec (count coll)) (conj (last coll) x)) \n    ;  (conj coll [x]))) \n  ;[] %)\n  \n  partition-by identity","user":"5afb3426e4b0cc2b61a3bcf5"},{"problem":31,"code":"#(loop\n [coll % answer ()]\n (if\n  (empty? coll)\n  answer\n  (recur \n   (rest coll)\n   (if\n    (= (first (last answer)) (first coll))\n    (concat (butlast answer) (list (conj (last answer) (first coll))))\n    (concat answer (list (list (first coll))))\n   )\n  )\n )\n)","user":"560fe558e4b05f002753df63"},{"problem":31,"code":"(fn pack-sequence [xs]\n  (letfn [(cons-pack [xs x] \n            (if (= (ffirst xs) x)\n              (cons (cons x (first xs)) (rest xs))\n              (cons (list x) xs))\n          )] \n    (reverse (reduce cons-pack '() xs))))","user":"5661e09ae4b068f2fe63dc70"},{"code":"(fn [coll]\n\t(loop [coll coll, group [], result []]\n\t\t(if (empty? coll)\n\t\t\t(conj result group)\n\t\t\t(if (or (empty? group) (= (first coll) (first group)))\n\t\t\t\t(recur (rest coll) (conj group (first coll)) result)\n\t\t\t\t(recur (rest coll) [(first coll)] (conj result group))))))","problem":31,"user":"5370b386e4b0fc7073fd6e9b"},{"code":"(fn packseq [lst]\n  (loop [lst,lst tmplst,[] res,[]]\n    (cond\n     (empty? lst) (concat res [tmplst])\n     (empty? tmplst) (recur (rest lst) [(first lst)] res)\n     (= (first tmplst) (first lst)) (recur (rest lst) (cons (first lst) tmplst) res)\n     :else (recur (rest lst) [(first lst)] (concat res [tmplst])) )))","problem":31,"user":"50f0d000e4b0c5f4fa5ddb6f"},{"code":"(fn  [s]\n  (loop [curr s acc '() result '[] ]\n    (let [curr-element (first curr)\n          others (rest curr)]\n      (cond\n       (empty? curr) (conj result acc)\n       (empty? acc) (recur others (conj acc curr-element) result)\n       (= curr-element (first acc)) (recur others (conj acc curr-element) result)\n       :else (recur others (list curr-element) (conj result acc))\n       ))))","problem":31,"user":"5226f8e9e4b04e78ff2e199a"},{"problem":31,"code":"(fn [coll]\n  (reduce\n   (fn [c r]\n     (if\n        (= (first (last c)) r)\n       (assoc c (dec (count c)) (conj (last c) r))\n       (conj c (vector r))))\n   []\n   coll))","user":"5918db70e4b09b4ee5954bbb"},{"code":"#(letfn [(pack [xs cv cp ps]\n            (if (empty? xs)\n                (rest (reverse (cons cp ps)))\n                (let [y (first xs) ys (rest xs)]\n                    (if (= y cv)\n                        (pack ys cv (cons y cp)  ps          )\n                        (pack ys  y (cons y nil) (cons cp ps)) ))))]\n    (pack % nil nil '()))","problem":31,"user":"4fb4099be4b081705acca2a9"},{"code":"#((fn binnify [bins bin coll] \n  (if (not (empty? coll))\n    (if (not (empty? bin)) \n    \t(if (= (first bin) (first coll))\n      \t\t(binnify bins (cons (first coll) bin) (next coll))\n      \t\t(binnify (conj bins bin) [] coll)\n    \t)\n        (binnify bins (cons (first coll) bin) (next coll))\n    ) \n    (conj bins bin)\n  )\n) [] [] %)","problem":31,"user":"52b9c5e8e4b07a9af57922c2"},{"problem":31,"code":"(fn [coll]\n  (reverse (reduce (fn [acc n]\n            (if (= n (ffirst acc))\n                 (cons (cons n (first acc)) (rest acc))\n                 (cons (list n) acc))) '() coll)))","user":"5478c4fee4b0c51c1f4d72c0"},{"code":"(fn pack [sq]\n  (let [get-head (fn [sq]\n                   (if-let [fst (first sq)]\n                     ((fn get-head* [sq]\n                        (let [[h & rst] sq]\n                          (when (= fst h)\n                            (cons h (get-head* rst))))) sq)))\n        get-but-head (fn [sq]\n                       (if-let [fst (first sq)]\n                         ((fn get-but-head* [sq]\n                            (let [[h & rst] sq]\n                              (if (= fst h)\n                                (get-but-head* rst)\n                                sq))) sq)))]\n    (let [head (get-head sq)\n          but-head (get-but-head sq)]\n      (when head\n        (cons head (pack but-head))))))","problem":31,"user":"51c3c6a6e4b0851ac09658f8"},{"code":"(fn f [lst] (drop 1 (loop [prev nil l lst acc 0 result nil]\n  (if-not (empty? l)\n    (let [head (first l) tail (rest l)] \n      (if (= prev head)\n        (recur prev tail (inc acc) result)\n        (recur head tail 1 (concat result (list (repeat acc prev))))))\n    (concat result (list (repeat acc prev)))))))","problem":31,"user":"52b35a6ee4b0c58976d9ad07"},{"code":"(fn pack [lst]\n  (if (empty? lst)\n    '()\n    (let [[matched unmatched] (split-with (partial = (first lst)) lst)]\n      (cons matched (pack unmatched)))))","problem":31,"user":"4e9a1512535dbda64a6f6b6e"},{"code":"(fn [s]                                                                                \n  (reduce (fn [l a]                                                                     \n            (if (= a (peek (peek l)))                                                   \n              (update-in l [(dec (count l))] conj a)                                    \n              (conj l [a])))                                                            \n          [] s))","problem":31,"user":"4f3656d1e4b0e243712b1ec9"},{"problem":31,"code":"(fn pack [s]\n  (->>\n    s\n    (reduce\n      (fn [acc curr]\n        (let [last-seq (last acc)\n              last-item (last last-seq)]\n          (if (= last-item curr)\n            (conj (vec (butlast acc)) (conj last-seq curr))\n            (conj acc (list curr)))))\n      '())\n    seq))","user":"5d0eed51e4b0cc9c91588262"},{"code":"(fn [li]\r\n  (partition-by identity li))","problem":31,"user":"4f9aa2a6e4b0dcca54ed6d0c"},{"code":"#(reverse (reduce (fn [xs y]\r\n                   (let [x (first xs)]\r\n                     (if (= (first x) y)\r\n                       (conj (rest xs) (conj x y))\r\n                       (conj xs (list y))))) '() %))","problem":31,"user":"4e0d8c27535d04ed9115e7b7"},{"problem":31,"code":"(do\n  (partial partition-by identity)\n  \n  #(seq\n    (reduce (fn [acc elt]\n              (if (= elt (first (last acc)))\n                (conj (vec (butlast acc)) (conj (last acc) elt))\n                (conj acc (list elt))))\n            []\n            %))\n  )","user":"5829d9f8e4b051871117bf4d"},{"problem":31,"code":"(fn pack-a-seq [coll]\n  (partition-by identity coll))","user":"5693a53ee4b0dcc4269f4106"},{"code":"(fn [s]\n  ((fn [lst acc]\n     (if (empty? lst)\n       (reverse acc)\n       (if (= (first lst) (first (first acc)))\n         (recur (rest lst) (conj (rest acc) (conj (first acc) (first lst))))\n         (recur (rest lst) (conj acc (list (first lst)))))))\n   s nil))","problem":31,"user":"50119c07e4b028e9d38b393f"},{"problem":31,"code":"(fn pack \n   ([i] (pack i [] []))\n   ([i o s] (println [i o s]) \n      (if (empty? i)\n        (conj o s)\n        (if (empty? s) \n          (pack (rest i) o (conj [] (first i)))\n          (if (= (first i) (first s))\n            (pack (rest i) o (conj s (first i)))\n            (pack i (conj o s) [])\n            )\n          )\n        )\n         ))","user":"5b081ff2e4b0cc2b61a3bdb3"},{"code":"(fn p [[x :as s]]\n  (if x\n    (let [[d r] (split-with #(= % x) s)]\n      (cons d (p r)))))","problem":31,"user":"4e8612f8535db62dc21a62f2"},{"code":"(fn [n]\n  (reverse (first (reduce \n   (fn [[xs, e] x]\n     (if (= e x)\n       [(concat [(concat [x] (first xs))] (rest xs)), x]\n       [(concat [[x]] xs), x]))\n    [[], nil]\n    n))))","problem":31,"user":"507c4829e4b0a19f8e876e57"},{"code":"#(loop [current-pack '()\n         the-rest %\n         final-seq '()]\n    (if (empty? the-rest)\n      (concat final-seq (list current-pack))\n      (let [current (first the-rest)]\n        (cond (= (first current-pack) nil)\n              (recur (list current) (rest the-rest) final-seq)\n              (= current (first current-pack))\n              (recur (conj current-pack current) (rest the-rest) final-seq)\n              :else\n              (recur (list current) (rest the-rest) (concat final-seq [current-pack]))))))","problem":31,"user":"523288fee4b035af41902a88"},{"code":"#(if (vector? (first %)) '(([1 2] [1 2]) ([3 4]))\n  (loop [x 1,y %,m '()]\n   (if (== x (count y))\n     (reverse (conj m (repeat (- x (count (flatten m))) (nth y (dec x)))))\n     (recur (inc x)\n            y\n            (if (not (= (nth y x) (nth y (dec x))))\n              (conj m (repeat (- x (count (flatten m))) (nth y (dec x))))\n              m)))))","problem":31,"user":"51c4690fe4b06b70b3e207e1"},{"code":"(fn [s]\n  (reverse (loop [r '() s s prev nil cur '()]\n    (if (empty? s)\n      (conj r cur)\n      (let [first (first s)\n            rest (rest s)]\n        (recur (if (or (= first prev) (empty? cur)) r (conj r cur))\n               rest\n               first\n               (if (= first prev) (conj cur first) (list first))))))))","problem":31,"user":"52745629e4b03e8d9a4a74a0"},{"code":"(fn [lst] (loop [s lst\n                          res ()]\n                     (if-not (seq s)\n                       (reverse res)\n                       (let [[rep rem] (split-with #(= (first s) %) s)]\n                         (recur rem (conj res rep))))))","problem":31,"user":"4e5f034b535d8a8b8723a2d9"},{"problem":31,"code":"(partial partition-by list)","user":"56aad332e4b03c432f187337"},{"problem":31,"code":"(fn [f]\n  (partition-by identity f)\n  )","user":"5f727be9e4b02876ed9fd08d"},{"problem":31,"code":"(fn pack [col] (reduce #(if (= (last (last %1)) %2) (conj (pop %1) (conj (last %1) %2)) (conj %1 [%2])) [] col))","user":"5d45bd1de4b07c84aa5ae6a4"},{"code":"(fn pack [x] (partition-by identity x))","problem":31,"user":"5231d8fae4b0e2e8de81d1fb"},{"problem":31,"code":"#(reverse \n  (reduce        \n   (fn pack [xs x] \n    (if (= (first (first xs)) x) \n     (cons (cons x (first xs)) (rest xs))\n     (cons (list x) xs)))\n                  '() %))","user":"54d5fbe9e4b0a52adc2e2014"},{"problem":31,"code":"(fn [coll]\n  (loop [c coll result [] match '()]\n    (if-not (seq c)\n      (seq (rest (conj result match)))\n      (if (= (last match) (first c))\n        (recur (rest c) result (conj match (first c)))\n        (recur (rest c) (conj result match) (list (first c)))))))","user":"562268dce4b03f08ee9a9224"},{"problem":31,"code":"(fn pack [sq] \n  (loop [ans nil s sq l nil]\n    (if (empty? s)\n      ans\n      (recur\n        (if (= (first s) l)\n          (concat (drop-last ans) (conj nil (conj (last ans) (first s))))\n          (concat ans (conj nil (conj nil (first s))))\n        )\n        (rest s)\n        (first s)\n      )\n    )\n  )\n)","user":"56b36283e4b0982f16b37e18"},{"code":"(fn pack-seq [x]\n  (when (seq x)\n    (conj (pack-seq (drop-while #(= (first x) %) x)) (take-while #(= (first x) %) x))))","problem":31,"user":"52af7a5ce4b0c58976d9acbd"},{"problem":31,"code":"(fn [s]\n  (reduce (fn [acc curr]\n            (let [x (last (last acc))]\n              (if (= x curr)\n                (vec (concat (butlast acc) [(conj (last acc) x)]))\n                (conj acc [curr])))) [[(first s)]] (rest s)))","user":"576a972ce4b0a07e8fc1811a"},{"problem":31,"code":"(fn pack [s] (if (empty? s) '() (reverse (reduce (fn [[h & t] e] (if (= (first h) e) (cons (cons e h) t) (cons (list e) (cons h t)))) (list (list (first s))) (rest s)))))","user":"54f5fb57e4b0f2f3c5226e9f"},{"code":"(fn psq [xs]\r\n  (if (empty? xs)\r\n    ()\r\n    (cons\r\n      (take-while (partial = (first xs)) xs)\r\n      (psq (drop-while (partial = (first xs)) xs)))))","problem":31,"user":"4ee40938535d10e5ff6f5375"},{"code":"(fn [coll]\n      (partition-by identity coll))","problem":31,"user":"51ea4e35e4b0f1f103a0d148"},{"problem":31,"code":"(fn [s]\n  (loop [l s, lastv nil, sublist [], result []]\n    (let [x (first l), remainder (rest l)]\n      (if (empty? l) \n        (if (empty? sublist)\n          result\n          (conj result sublist))\n        (if (= x lastv)\n          (recur remainder x (conj sublist x) result)\n          (recur remainder x [x] (if (empty? sublist) \n                                   result \n                                   (conj result sublist))))))))","user":"5c6e1006e4b0fca0c1622744"},{"code":"(fn [sek] (loop [lista nil i 0 n 1]\r\n  (cond\r\n    (= i (count sek)) (reverse lista)\r\n    (= (nth sek i) (nth sek (+ i 1) nil)) (recur lista (inc i) (inc n))\r\n    :else (recur (conj lista (take n (drop (- i (- n 1)) (seq sek)))) (inc i) 1)\r\n)))","problem":31,"user":"4e218470535d04ed9115e817"},{"problem":31,"code":"#(loop [i-list % p-list [] res []]\n   (if (empty? i-list)\n     (conj res p-list)\n     (let [curr (first i-list)\n           is-curr-eq-prev (or (empty? p-list) (.contains p-list curr))]\n       (recur (drop 1 i-list)\n         (if is-curr-eq-prev (conj p-list curr) [curr])\n         (if is-curr-eq-prev res (conj res p-list))\n       )\n     )\n   )\n )","user":"55989c25e4b031d6649c9b9b"},{"code":"#(loop [head (first %) tail (next %) t '() ans []]\n  (do\n    ;(prn head tail t ans)\n    (cond\n      (nil? head) (if (empty? t) ans (conj ans t))\n      (not-empty t)\n        (if (= (last t) head)\n          (recur (first tail) (next tail) (conj t head) ans)\n          (recur (first tail) (next tail) (list head) (conj ans t))\n        )\n      :else\n        (recur (first tail) (next tail) (conj t head) ans)\n    )\n  )\n)","problem":31,"user":"51f09f3de4b0274c496158d7"},{"code":"(fn [l]\n  (loop [l l acc []]\n    (if (empty? l)\n      acc\n      (let [f #(= % (first l))]\n        (recur (drop-while f l) (conj acc (take-while f l)))))))","problem":31,"user":"4e568873535d8a8b8723a283"},{"problem":31,"code":"#(reduce\n  (fn fun [coll x]\n    (if (= (last (last coll)) x)\n      (assoc coll (- (count coll) 1) (conj (last coll) x))\n      (conj coll (conj [] x))))\n  [] %)","user":"5f0c8b0de4b0f30dddfb5d4c"},{"code":"(fn pack-it [s]\n (cond\n  (= 1 (count s)) (list s) \n  :else \n    (let [pack-rest (pack-it (rest s))]\n  \t\t(if (= (first s) (first (first pack-rest)))\n  \t\t\t(cons (cons (first s) (first pack-rest)) (rest pack-rest))\n  \t\t\t(cons (list (first s)) (pack-it (rest s)))\t\n  \t\t)\n  \t)\n ) \n)","problem":31,"user":"4faacc04e4b081705acca201"},{"problem":31,"code":"(fn [s]\n  (loop [r (map #(list %) s)\n         a '()\n         v (first r)]\n    (if (empty? r)\n      (reverse a)\n      (if (= v (first r))\n        (recur (rest r)\n               (conj (rest a) (concat (first a) v))\n               v)\n        (recur (rest r)\n               (conj a (first r))\n               (first r))))))","user":"55995fa7e4b031d6649c9ba9"},{"problem":31,"code":"(fn [s]\n  (let [\n        [packed last-list]\n        (reduce\n          (fn [[packed last-list] e]\n            (if (= (first last-list) e)\n              [packed (conj last-list e)]\n              [(conj packed last-list) [e]]))\n          [[] [(first s)]]\n          (rest s))]\n    (conj packed last-list)))","user":"56d2a103e4b0ea9b8538f7a3"},{"problem":31,"code":"(fn [xss]\n  (loop [xs xss\n         acc []\n         cur '()]\n    (cond\n      (empty? xs)          (if (empty? cur)\n                             acc\n                             (conj acc cur))\n      (or (empty? cur)                \n          (= (first xs)\n             (first cur))) (recur (rest xs)\n                                  acc\n                                  (cons (first xs) cur))\n      :else                (recur (rest xs)\n                                  (conj acc cur)\n                                  (cons (first xs) '())))))","user":"50478418e4b0371827a27bc3"},{"problem":31,"code":"(fn [n](partition-by identity n))","user":"5262efade4b03e8d9a4a709f"},{"problem":31,"code":"(fn pack [items]\n  (loop [acc []\n         dupli-acc []\n         last-item nil\n         [curr & rest-items :as item] items]\n    (cond \n     (empty? item) (seq (conj acc (seq dupli-acc)))\n     (= curr last-item) (recur acc (conj dupli-acc curr) curr rest-items)\n     (= last-item nil) (recur acc (conj dupli-acc curr) curr rest-items)\n     (not= curr last-item) (recur (conj acc (seq dupli-acc)) (conj [] curr) curr rest-items))))","user":"55bbfd60e4b01b9910ae29ed"},{"problem":31,"code":"(fn _pack [s]\n         (let [pred #(= % (first s))]\n           (when (not (empty? s))\n             (conj (_pack (drop-while pred s)) (take-while pred s)))))","user":"53f592b7e4b0db01ade6f9d0"},{"code":"#(loop [s (rest %1) e [(first %1)] r []]\n  (cond (empty? s) (conj r e)\n        (= (first e) (first s)) (recur (rest s) (conj e (first s)) r)\n        :else (recur (rest s) [(first s)] (conj r e))))","problem":31,"user":"4fa0a4b1e4b0dcca54ed6d4f"},{"problem":31,"code":"(fn my-pack-dups\n   ([c]\n    (my-pack-dups [] c))\n   \n   ([r, c]\n    (if (empty? c)\n      r\n      (let [dup? (partial = (first c))\n            group (take-while dup? c)\n            r (conj r group)\n            c (drop (count group) c)]\n        (my-pack-dups r c)))))","user":"54357066e4b0b6b47310fcfd"},{"code":"(fn [col]\n  (loop [[hd & tail] col cur hd same-ack '() tot-ack '() ]\n     (if (nil? hd) (reverse (conj tot-ack same-ack))\n          (if (= cur hd)\n             (recur tail hd (conj same-ack cur) tot-ack)\n             (recur tail hd (conj '() hd) (conj tot-ack same-ack))))))","problem":31,"user":"50a7b76de4b090657f4a5cdc"},{"code":"(fn [s] (rest (loop [s (seq s) a [] d []]  \r\n  (if (empty? s) (conj a d) (let [f (first s) dup (and (not (empty? d)) (= (first d) f))] (recur (rest s) (if dup a (conj a d)) (if dup (conj d f) [f])))))))","problem":31,"user":"4e7e55ab535db169f9c79711"},{"code":"(fn [arr] (let [foo (fn [arr] (split-with (partial = (first arr)) arr))] (loop [acc [] r arr] (if (= (count r) 0) acc \n           (recur (conj acc (first (foo r))) (first (rest (foo r))))))))","problem":31,"user":"52a5d1f3e4b0c58976d9abf1"},{"code":"(fn foo [a b]\n  (if\n    (empty? b)\n    a\n    (let [spl (split-with (partial = (first b)) b)]\n      (foo\n        (concat a (list (first spl)))\n        (second spl))\n      )\n    )\n  ) '()","problem":31,"user":"510b704ee4b078ea71921100"},{"problem":31,"code":"(fn [x]\n  (seq (partition-by identity x)))","user":"5ecf55dae4b016b56eae05a8"},{"code":"(fn packer\n  ([col] (packer col []))\n  ([col res]\n    (if (empty? col) (reverse (reduce (fn [x y] (if (contains? (set (first x)) (first y)) (conj (rest x) (conj (first x) (first y))) (conj x y))) () res)\n)\n        (packer (rest col) (conj res (list (first col)))))))","problem":31,"user":"50053d6ce4b0678c553fc45e"},{"code":"(fn jpack\n  [lst]\n  (loop [final [] current [] remaining lst]\n    (if (empty? remaining)\n      (if (empty? current)\n        final\n        (conj final current))\n      (if (empty? current)\n        (recur final (conj current (first remaining)) (rest remaining))\n        (if (= (last current) (first remaining))\n          (recur final (conj current (first remaining)) (rest remaining))\n          (recur (conj final current) [] remaining))))))","problem":31,"user":"534ff8a6e4b084c2834f4ad1"},{"code":"#(rest (loop [x % y [] z []] (if (empty? x) (conj z y) (recur (rest x) (if (= (first x) (first y)) (conj y (first x)) [(first x)]) (if-not (= (first x) (first y)) (conj z y) z)))))","problem":31,"user":"52e48632e4b09f7907dd1450"},{"code":"#(reduce (\n    fn [a b]\n     (if (= (first (first a)) b)\n         (conj (next a) (cons b (first a)))\n         (conj a (list b))))\n    `() (rseq %))","problem":31,"user":"4e2b1d48535deb9a81d77f03"},{"code":"(fn [s]\r\n  (reverse (loop [s (rest s)\r\n                  p (first s)\r\n                  r `((~(first s)))]\r\n             (if (empty? s)\r\n               r\r\n               (recur (rest s) (first s) (if (= p (first s))\r\n                                           (conj (rest r) (conj (first r) p))\r\n                                           (conj r `(~(first s)))))))))","problem":31,"user":"4de2f44f535d08e6dec9fdec"},{"problem":31,"code":"(fn packer [x]\n  (loop [result [], new-vec x]\n    (println \"This is result \" result)\n    (println \"This is new-vec \" new-vec)\n    (if (empty? new-vec)\n      result\n      (if (= (first (last result)) (first new-vec)) \n        (recur (conj (vec (drop-last result)) (conj (last result) (first new-vec))) (rest new-vec))\n        (recur (conj result (conj [] (first new-vec))) (rest new-vec)) ))))","user":"57040195e4b08d47c9778202"},{"problem":31,"code":"(fn [inp]\n\n   (loop [coll (rest inp)\n         out []\n         cur [(first inp)]]\n    (cond\n     \t(empty? coll) (if (empty? cur) out (conj out cur))\n     \t(= (last cur) (first coll) ) (recur (rest coll) out (conj cur (first coll) ) )\n        :else (recur (rest coll) (conj out cur) [(first coll)])  \n     \n     )\n   )\n  )","user":"5fc5c303e4b02c825b0c8c1a"},{"problem":31,"code":"(fn pack [[x & xs]]\n  (if (nil? x) \n    ()\n    (let [[r & rs] (pack xs)]\n      (if (or (nil? r) (= (first r) x))\n        (cons (cons x r) rs)\n        (cons (list x) (cons r rs))))))","user":"518ba795e4b0f028e99addf0"},{"code":"(fn [coll]\n    (loop [coll coll result [] prev nil currpack []]\n      (if\n       (empty? coll) (if (empty? currpack)\n                       (seq result)\n                       (seq (conj result (seq currpack))))\n       (let [head (first coll)]\n         (if (or (= head prev) (nil? prev))\n           (recur (rest coll) result head (conj currpack head))\n           (recur (rest coll) (conj result (seq currpack)) head [head]))))))","problem":31,"user":"4e88feef535d8b9bb0147ca8"},{"problem":31,"code":"(fn [v]\n    (loop [ret [] r v l '()]\n        (if (seq r)\n            (if (or (not (seq l)) (= (first r) (first l)))\n                (do (println 1)(recur ret (rest r) (conj l (first r))))\n                (do (println 2)(recur (conj ret l) (rest r) (conj '() (first r)))))\n            (seq (conj ret l)))))","user":"55975569e4b031d6649c9b8e"},{"problem":31,"code":"(fn [c] \n  (reduce \n     #(let [l (last %1)]  \n        (if (= (last l) %2) \n          (conj (vec (drop-last %1)) (conj l %2)) \n          (conj %1 [%2])\n         ) \n      )\n     [] \n     c\n  )\n)","user":"55eeb37ae4b0121d4835fdf3"},{"problem":31,"code":"; partition-by like ...\n(fn pack[l]\n  (if (empty? l)\n    '()\n    (let [[a & q] l]\n      (if (empty? q)\n        (list (list a))\n        (let [[sq & sqq] (pack q)]\n          (if (= a (first sq))\n                 (cons (cons a sq) sqq)\n                 (cons (list a) (cons sq sqq))))))))","user":"54651ef5e4b01be26fd746d5"},{"problem":31,"code":"(fn [x]\n\t(loop [x x acc []]\n\t\t(if (empty? x)\n\t\t\t(reverse acc)\n\t\t\t(recur (drop-while #(= (first x) %) x) (cons (take-while #(= (first x) %) x) acc))\n\t\t)\n\t)\n)","user":"5409f8eae4b0addc1aec66e6"},{"code":"(fn [x] (reduce #(if (= %2 (first (last %1))) (update-in %1 [(- (count %1) 1)] concat [%2]) (conj %1 [%2])) [] x))","problem":31,"user":"525cc912e4b0cb4875a45d48"},{"code":"(fn pack-seq\n  [coll]\n  (let [coll (seq coll)\n        f (fn [x] (= x (first coll)))]\n    (when (not (nil? coll))\n      (cons (take-while f coll)\n            (pack-seq (drop-while f coll))))))","problem":31,"user":"51937eb3e4b04df54c098022"},{"code":"(fn pack\n  [some-seq]\n  (reverse \n   (reduce \n    (fn [acc e]\n      (if (= (first (first acc)) e) \n        (cons \n         (cons e (first acc)) \n         (drop 1 acc)) \n        (cons \n         (list e) \n         acc)))\n    [] some-seq)))","problem":31,"user":"51af4cf6e4b0c53cf2e68a4c"},{"problem":31,"code":"(fn [coll]\n  (loop \n    [result '()\n     lastcount 1\n     coll coll\n     ]\n    (if-let [r (seq (rest coll))]\n      (if (= (first coll) (first r))\n        (recur result (+ 1 lastcount) r)\n        (recur (concat result (list (repeat lastcount (first coll)))) 1 r)\n        )\n      (concat result (list (repeat lastcount (first coll))))\n      )\n    )\n  )","user":"5245e320e4b09dbe66b56177"},{"code":"(fn [l] (loop [lst (rest l) ttl '() sub (seq [(first l)])] \n      (if (empty? lst)\n           (reverse (cons sub ttl))\n    (if (= (first lst) (first sub))\n\t      (recur (rest lst) ttl (cons (first lst) sub))\n\t      (recur (rest lst) (cons sub ttl) (seq [(first lst)]))\n))))","problem":31,"user":"50a4b6a7e4b0344e360f3bb8"},{"problem":31,"code":"(fn [s] \n  (reduce \n  (fn [x y] \n    (if (= (first (last x)) y) \n      (concat (butlast x) [(conj (last x) y)])\n      (concat x [[y]]))) [(take 1 s)] (rest s)))","user":"5a04e923e4b01bb0ae8afda9"},{"problem":31,"code":"(fn [coll]\n  (letfn [(pack-seq [lst] (lazy-seq\n                           (if (first lst)\n                             (let [pred (partial = (first lst))\n                                   pack-head (take-while pred lst)\n                                   next-part (drop-while pred lst)]\n                               (cons pack-head (pack-seq next-part)))\n                             '())))]\n    (pack-seq coll)))","user":"55ab07e0e4b0988bba2ad953"},{"code":"(fn packlist2 [coll]\n  (reduce (fn [l v]\n            (if (and\n                 (not (empty? l))\n                 (=\n                  (last (last l))\n                  v))\n              (conj (vec (butlast l))\n                    (conj (last l) v))\n              (conj l (vector v))))\n          []\n          coll))","problem":31,"user":"4e4bd94b535dc968683fc4d7"},{"code":"#(loop [acc [] cur [] last nil coll %]\n  (if-let [[a & coll] coll]\n    (if (or (= last a) (nil? last))\n      (recur acc (conj cur a) a coll)\n      (recur (conj acc cur) [a] a coll))\n    (if (seq cur)\n      (conj acc cur)\n      acc)))","problem":31,"user":"4e521cef535d302ef430da6d"},{"code":"(fn packeddupes [input]\n  (reduce (fn [sofar newval]\n    (if (empty? sofar)\n      [[newval]]\n      (if (= (last (last sofar)) newval)\n        (conj (vec (butlast sofar)) (conj (last sofar) newval))\n        (conj sofar [newval]))))\n    [] input))","problem":31,"user":"515737f0e4b0b0b4b87062d0"},{"problem":31,"code":"(fn [seqn]\n             (partition-by identity seqn))","user":"5d4df658e4b0776584bd6f41"},{"problem":31,"code":"(fn f [xs]\n  (if (not (empty? xs))\n    (let [[ys zs] (split-with #(= % (first xs)) xs)]\n    (cons ys (f zs)))))","user":"55b28b57e4b01b9910ae296c"},{"problem":31,"code":"#(loop [lista '() package '() lastI \\0 i 0] \n       (if (= i (count %)) \n         (reverse (cons package lista))\n         (if (= lastI (.get (seq %) i))\n            (recur lista (cons lastI package) lastI (inc i))\n            (recur (if-not (= package '()) (cons package lista)) (list (.get (seq %) i)) (.get (seq %) i) (inc i))\n         )\n       )\n )","user":"5451eb12e4b0e397800069b8"},{"problem":31,"code":"(fn iterate\n    ([col] (iterate '() '() col))\n    ([res-list prev-packed-list remaining-list]\n        (if (empty? remaining-list)\n            (reverse (conj res-list prev-packed-list))\n            (if (empty? prev-packed-list)\n                (iterate '() (list (first remaining-list)) (rest remaining-list))\n                (if (= (first remaining-list) (first prev-packed-list))\n                    (iterate\n                        res-list\n                        (conj prev-packed-list (first remaining-list))\n                        (rest remaining-list))\n                    (iterate\n                        (conj res-list prev-packed-list)\n                        (list (first remaining-list))\n                        (rest remaining-list)))))))","user":"59aeff12e4b0e1f4e384c8af"},{"code":"(fn [seqn]\n  (loop [seqn seqn acc []]\n    (if-let [x (first seqn)]\n      (recur (drop-while #(= % x) seqn)\n             (conj acc (take-while #(= % x) seqn)))\n      acc)))","problem":31,"user":"4e8944b6535d4ef0aa30db98"},{"code":"(fn [coll]\n  \t(partition-by identity coll))","problem":31,"user":"52b94e26e4b07a9af57922b9"},{"problem":31,"code":"(fn cmprs [x]\n  (reverse (reduce \n  \t#(if (= %2 (ffirst %1))\n  \t\t(conj (rest %1) (conj (first %1) %2)) \n  \t\t(conj %1 [%2]))\n  '() x)))","user":"577d3feee4b0c8d87281f6d2"},{"code":"(fn [l]\n    (reverse\n     (reduce\n      (fn [acc v]\n        (if (empty? acc)\n          [[v]]\n          (if (= v (first (first acc)))\n            (cons (cons v (first acc)) (rest acc))\n            (cons [v] acc))))\n      [] l)))","problem":31,"user":"515ef58be4b02c55805ea237"},{"problem":31,"code":"(fn pack [coll]\n  (if-not (empty? coll)\n    (cons (take-while #(= % (first coll)) coll)\n          (pack (drop-while #(= % (first coll)) coll)))))","user":"601aaa93e4b0bf4ca6b10926"},{"problem":31,"code":"(fn [s] (reduce (fn [a n] \n                  (if (not= (peek (peek a)) n)\n                    (conj a [n])\n                    (conj (pop a) (conj (peek a) n))))\n                [] s))","user":"514a3fa5e4b0829bd132edb6"},{"problem":31,"code":"(fn [l]\n  (loop [l (apply list l) nl [] lastValue nil]\n    (if (empty? l)\n      (apply list nl)\n      (let [value (peek l)]\n        (recur (pop l) (if (= lastValue value) (conj (pop nl) (conj (peek nl) value)) (conj nl (list value))) value)\n        )\n      ) \n    ) \n  )","user":"54b90836e4b0ed20f4ff6e9d"},{"code":"(fn this [w]\n;    (println w)\n;(let [ret\n     (\n       (fn clr [li prev]\n;         (println \"li: \" li \", prev: \" prev)\n;         (println \"    \" 7 \", \" (list 7))\n;         (println \"    \" (list (first li)))\n;         (println \"    \" (rest li))\n;         (println \"        \" (not-empty li))\n         (if\n           (not-empty li)\n           (cond\n             (nil? prev) (clr (rest li) (list (first li)))\n             (= (first prev) (first li)) (clr (rest li) (cons (first li) prev))\n             :else (cons prev (clr (rest li) (list (first li))))\n           )\n           (list prev)\n         )\n       )\n       w\n       nil\n     )\n;] (println \"ret: \" ret) ret)\n  )","problem":31,"user":"501819efe4b02f523d7cc5eb"},{"code":"(fn [n] (partition-by identity n))","problem":31,"user":"5187dd58e4b057e3860ab7e4"},{"problem":31,"code":"(fn [coll]\n  (loop [[head & tail] (rest coll)\n         sub [(first coll)]\n         new []]\n    (if-not head\n      (conj new sub)\n      (if (= head (first sub))\n        (recur tail (conj sub head) new)\n        (recur tail [head]\n               (conj new sub))))))","user":"54d9f7f1e4b024c67c0cf751"},{"code":"(fn my-pack\n    ([icoll] (my-pack (rest icoll) (conj '() (conj '() (first icoll)))))\n    ([icoll ocoll] \n     (cond \n      (empty? icoll) (reverse ocoll)\n      :else \n      (recur \n       (rest icoll) \n       (if (not= (first icoll) (first (first ocoll)))\n           (conj ocoll (conj '() (first icoll))) ;; new pack \n           (conj (drop 1 ocoll) (conj (first ocoll) (first icoll))))) ;; remove old pack and add new one with value added\n      )))","problem":31,"user":"4eee3e6a535d93acb0a668c3"},{"problem":31,"code":"(fn [s]\n  (loop [s s\n         output '()]\n    (let [[h & t] s\n          sub-list (into '() (take-while #(= h %) s))]\n      (if (= h nil)\n        (reverse output)\n        (recur (drop (count sub-list) s) (cons sub-list output))))))","user":"57002b81e4b08d47c97781c7"},{"problem":31,"code":"(fn [input] \n  (rest (reduce (fn pack[l x]\n  (if (= (last (last l)) x)\n    (concat \n      (drop-last l) \n      (list (concat (last l) (list x))))\n    (concat l (list (list x))))) (list (list)) input)))","user":"5626447fe4b00e49c7cb47bd"},{"problem":31,"code":"(fn pack-seq \n  ([unpacked-seq] (pack-seq (butlast unpacked-seq) (list (list (last unpacked-seq)))))\n  ([unpacked-seq packed-seq]\n   (if (empty? unpacked-seq)\n     packed-seq\n     (if (= (last unpacked-seq) (first (first packed-seq)))\n       (pack-seq (butlast unpacked-seq) (cons (conj (first packed-seq) (last unpacked-seq))\n                                              (rest packed-seq)))\n       (pack-seq (butlast unpacked-seq) (cons (list (last unpacked-seq))\n                                              packed-seq))))))","user":"53bc279ae4b047364c04450e"},{"problem":31,"code":"(fn [x] (reduce\n              (fn [a b]\n                (\n                 (if (= (last a)b)\n                   (fn [] (println \"=\"  (conj (vec(butlast a)) [b b])) (conj (vec(butlast a)) [b b]))\n                   (if  (and (coll? (last a)) (= (last (last a))b))\n                     (fn [] (println \"coll\" a b \"->\"  (conj (vec(butlast a)) (conj (last a) b))) (conj (vec(butlast a)) (conj (last a) b)))\n                     (fn [] (println \"not coll\" a b) (conj a  [b]))\n                     )\n                   )\n\n                 ))\n              []\n              x))","user":"5dbb5200e4b09f47823971a9"},{"code":"(fn\n  [coll]\n  (reduce\n   (fn [current new]\n     (if (= new (last (last current)))\n       (concat (butlast current) (list (concat (last current) (list new))))\n       (concat current (list (list new)))))\n\n   '() coll))","problem":31,"user":"509e62a8e4b08df8156e9e2e"},{"problem":31,"code":"(fn [c]\n  (let [res (reduce\n   \t\t\t  (fn [acc e]\n      \t\t\t(if (= e (:val acc))\n                  (assoc acc :current (conj (:current acc) e))\n                  {:result (conj (:result acc) (:current acc))\n                   :current [e] :val e}))\n    \t\t  {:result [] :current [(first c)] :val (first c)}\n    \t\t  (rest c))]\n    (if (seq (:current res))\n      (conj (:result res) (:current res))\n      (:result res))))","user":"5c73b8bae4b0fca0c16227ba"},{"problem":31,"code":"(fn [x] \n  (loop [this (first x) them (next x) saved nil cnt 0 result nil]\n    (if-not this\n      (if (> cnt 0)\n        (concat result (list(repeat cnt saved))))\n      (if-not (= this saved)\n        (if (> cnt 0)\n          (recur (first them) (next them) this 1 (concat result (list(repeat cnt saved))))\n          (recur (first them) (next them) this 1 result))\n        (recur (first them) (next them) saved (inc cnt) result)))))","user":"589f2cefe4b02bd94d917e75"},{"problem":31,"code":"(fn[coll]\n  (loop [in coll out []]\n    (cond (empty? in) out\n          :else (let [[before after] (split-with #(= % (first in)) in)]\n                  (recur after (conj out before))))))","user":"5472cba1e4b094393f72dd7a"},{"code":"(fn [x] \n  (partition-by identity x) \n)","problem":31,"user":"4f00f997535dcb61093f6a34"},{"problem":31,"code":"(fn [s]\n  (loop [x s y '() z '()]\n    (if (empty? x)\n      (rest (reverse (cons z y)))\n      (if (= (first z) (first x))\n        (recur (rest x) y (cons (first x) z))\n        (recur (rest x) (cons z y) (cons (first x) '()))))))","user":"551b8e2ae4b07993ea3788d3"},{"problem":31,"code":"(fn fuck [sq]\n  (loop [raw-seq sq pseq '() index 0 last-char 0]\n    (cond\n      (>= index (count raw-seq)) pseq\n      (= last-char (nth raw-seq index)) (recur sq (concat (drop-last pseq)[(concat (last pseq) [last-char])]) (+ index 1) last-char) \n      :else (recur sq (concat pseq [[(nth raw-seq index)]]) (+ index 1) (nth raw-seq index)))\n    ))","user":"5831846ae4b051871117c02c"},{"problem":31,"code":"(fn compress\n  [s]\n  (let [reduce-fn (fn [coll v] \n                    (let [collvec (vec coll)\n                          prefix (if (empty? collvec) [] (pop collvec))\n                          end (peek collvec)]\n                      (if (= (first end) v)\n                        (conj prefix (conj end v))\n                        (conj collvec [v]))))]\n    (reduce reduce-fn [] s)))","user":"56fe665be4b08d47c97781af"},{"problem":31,"code":"(partial (fn [output [head & tail]]\n  (if (nil? head)\n    (into '()  output)\n    (recur (cons (cons head (take-while #(= head %) tail )) output) (drop-while #(= head %) tail)  ))) '() )","user":"58db362be4b0a4d5acaab675"},{"problem":31,"code":"(fn foo [x]\n  (let [fst (first x)]\n    (if (nil? fst)\n      '()\n      (->> (drop-while #(= fst %) x)\n          (foo)\n          (cons (take-while #(= fst %) x))))))","user":"5cece5a2e4b0a17bb84e2bfb"},{"code":"(fn pack [thing]\n  (partition-by identity thing))\n\n;partition-by takes a function and a thing and will separate the thing by the function in another list","problem":31,"user":"53713ebee4b0fc7073fd6ead"},{"code":"reduce #(if\n  (= (last (last %)) %2)\n\t(conj (vec (butlast %)) (into (last %) [%2]))\n\t(conj % [%2])) []","problem":31,"user":"4ec812d9535d6d7199dd36f0"},{"problem":31,"code":"(fn [lst]\n      (loop [result '() temp '() seq-list (seq lst)]\n        (if (empty? seq-list)\n          (drop 1(reverse (conj result temp)))\n          (if (= (last temp) (first seq-list))\n            (recur result (cons (first seq-list) temp) (rest seq-list))\n            (recur (conj result temp) (cons (first seq-list) '()) (rest seq-list))))))","user":"58e90258e4b056aecfd47cfd"},{"problem":31,"code":"(fn [coll]\n  (loop [result [], remaining coll]\n    (if (empty? remaining)\n      result\n      (let [[taken dropped] (split-with (partial = (first remaining))\n                                        remaining)]\n        (recur (conj result taken) dropped)))))","user":"594783bee4b07ddc2dafada1"},{"code":"(fn [lst]\n     (reduce \n      (fn [result value] \n          (cond \n           (= 0 (count (first (reverse result)))) \n           (conj () (reverse (into (reverse (rest (reverse result))) (conj () value))))\n           (= value (first (first (reverse result)))) \n           (into (conj () (take (+ (count (first (reverse result))) 1) (repeat value))) (rest (reverse result)))\n           :else (reverse (into (reverse result) (conj () (conj () value)) ))\n           )\n          )\n      (reverse (into '((())) lst))))","problem":31,"user":"50d6d7eee4b0159555a1fc76"},{"problem":31,"code":"(fn [vect]\n  [vect]\n  (loop [tmpv vect major '() adder '()]\n    (if (empty? tmpv)\n      (reverse (conj major adder))\n      (if (or (= (first tmpv)(first adder)) (empty? adder))\n        (recur (rest tmpv) major (conj adder (first tmpv)))\n        (recur tmpv (conj major adder) '())))))","user":"59369515e4b02506e01a297e"},{"code":"#(loop [s % c [] r []] \n   (if (empty? s) \n     (conj r c) \n     (if (or (empty? c) (= (first c) (first s))) \n       (recur (rest s) (conj c (first s)) r)\n       (recur s [] (conj r c))\n     )\n   )\n )","problem":31,"user":"53244c9de4b09d4e7a9b54db"},{"problem":31,"code":"(fn [collection]\n  (partition-by identity collection)\n  )","user":"5524f21fe4b0882d96d091c7"},{"problem":31,"code":"#(loop [xs %,res ()] \n    (if (empty? xs) (reverse res)\n    (let [x (first xs),coll (rest xs),resf (first res)]\n      (if (= x (first resf)) \n        (recur coll (conj (rest res) (conj resf x) ))\n        (recur coll (conj res (list x)))))))","user":"5507cfd3e4b021ccfedb96ad"},{"problem":31,"code":"(fn [coll] (reverse (reduce (fn asd [acc x]\n                                  (if (= (-> acc first first) x)\n                                    (cons (conj (first acc) x) (rest acc) )\n                                    (conj acc (list x))\n                                    )\n                                  ) '() coll)))","user":"5a062e07e4b01bb0ae8afdc5"},{"problem":31,"code":"(fn pack [coll]\n  (loop [xs coll current '() res '()]\n    (if (empty? xs) (rest (reverse (conj res current)))\n      (if (or (empty? current) (not= (first current) (first xs)))\n        (recur (rest xs) (conj '() (first xs)) (conj res current))\n        (recur (rest xs) (conj current (first xs)) res)))))","user":"53c126fce4b00fb29b22125b"},{"problem":31,"code":"(fn pack-seq\n  [input]\n  (partition-by identity input))","user":"5ac6099ee4b0e27600da7757"},{"problem":31,"code":"(fn [xs]\n    (loop [prev (first xs) xs (rest xs) acc [] num 1]\n      (println acc)\n      (if (empty? xs)\n        (conj acc (repeat num prev))\n        (if (= prev (first xs))\n          (recur prev (rest xs) acc (inc num))\n          (recur (first xs) (rest xs) (conj acc (repeat num prev)) 1)))))","user":"551a21ece4b091ff45eda993"},{"problem":31,"code":"(fn PackSequence [seq]\n  (let [pack2 (fn [s] (split-with #(= % (first s)) s))]\n    (loop [packed nil\n           raw seq]\n      (if (empty? raw)\n        packed\n        (let [[p r] (pack2 raw)]\n          (recur (concat packed (list p))\n                 r))))))","user":"53b88e6ee4b047364c0444de"},{"code":"(fn pack\n  [coll]\n    (partition-by identity coll))","problem":31,"user":"4e3bcccd535deb9a81d77f56"},{"code":"(fn [x]\n  (partition-by #((constantly %)) x) )","problem":31,"user":"4e333091535deb9a81d77f25"},{"code":"(fn [x]\n   (reverse (reduce (fn [y xs]\n             (if (= (ffirst y) xs)\n               (cons (conj (first y) xs) (rest y));;(cons (cons (first y) xs) (rest y))\n               (cons (list xs) y);;(cons (list xs) y))\n             ))\n           '() x)))","problem":31,"user":"4f616892e4b0defedf855fbf"},{"code":"reduce #(if(= (last (last %1)) %2)\n         (concat (butlast %1) [(concat (last %1) [%2])]) \n         (concat %1 [[%2]]) \n          ) []","problem":31,"user":"51aeb1f4e4b09397d5109794"},{"problem":31,"code":"(fn [s]\n   (reverse \n  (reduce\n   (fn [acc e]\n     ;;(println e)\n     (let [lpk (first acc)]\n       (if (= e (first lpk))\n         (conj (drop 1 acc) \n             (conj lpk e))\n         (conj acc (list e))\n       )))\n   '()\n   s)))\n     ;[:a :a :b :b :c])","user":"5b38d2f3e4b02d533a91bbaf"},{"problem":31,"code":"(fn [col]\n  (loop [items col\n         result []]\n    (if-let [current (first items)]\n      (let [consecutives (take-while #(= % current) items)\n            remaining (drop (count consecutives) items)]\n        (recur remaining (conj result consecutives)))\n      result)))","user":"56c427bbe4b05cc29241ee94"},{"code":"(fn p \n  ([[h & t]] (p [] [h] t))\n  ([a h t] \n    (if-let [[f & n] t]\n      (if (= (first h) f)\n        (p a (conj h f) n)\n        (p (conj a h) [f] n))\n      (conj a h))))","problem":31,"user":"4ef49c2c535dced4c769f238"},{"code":"(fn [els]\n  (partition-by identity els))","problem":31,"user":"5154fa3fe4b0179c5115f4e6"},{"problem":31,"code":"(fn pack[xs]\n  (reduce\n   (fn [memo x]\n     (let [last-group (last memo)\n           last-item (last last-group)]\n       (if (= last-item x)\n         (conj\n          (vec(butlast memo))\n          (conj last-group x))\n         (conj memo (vector x)))))\n   [[(first xs)]]\n   (rest xs)))","user":"5980f91ae4b021a7a535fddd"},{"code":"(fn pack [seq]\n  (partition-by identity seq))","problem":31,"user":"50651de3e4b0b1b6c8b1d85f"},{"problem":31,"code":"(fn pack[s]\n\t (partition-by identity s)\n\t )","user":"54fae43ae4b0cf870d934708"},{"problem":31,"code":"(fn[input-seq](partition-by identity input-seq))","user":"5c723f4be4b0fca0c16227a0"},{"problem":31,"code":"(fn [l](loop [a-list l\n              result []]\n               (if (empty? a-list)\n                 (reverse result)\n                   (recur (drop-while #(= (first a-list) %) a-list)\n                          (cons (take-while #(= (first a-list) %) a-list) result)))))","user":"5978b4c9e4b01722bebd4d13"},{"problem":31,"code":"#(let [[buffer last]\n        (first (reduce\n   (fn [[[buffer current] prev] n]\n     (if (= prev n)\n       [[buffer (conj current n)] prev]\n       (if-not (empty? current)\n         [[(conj buffer (reverse current)) (list n)] n]\n         [[buffer (conj current n)] n])))\n   [[nil nil] nil] %))]\n    (reverse (conj buffer last)))","user":"542db41be4b0dad94371f2bb"},{"problem":31,"code":"#(reduce (fn [a b] \n           (if (= (last (last a)) b)\n             (conj (vec (butlast a)) (conj (last a) b))\n             (conj a [b])\n             )) [] %)","user":"544e9022e4b0e3978000698b"},{"problem":31,"code":"(fn pack [s]\n  (if (empty? s) nil\n    (let [[left right] (split-with #(= % (first s)) s)]\n      (cons left (pack right))\n      )))","user":"53dadf1de4b0e771c30254ad"},{"code":"(fn [s]\n  (loop [se s cur [] acc []]\n    (if (empty? se)\n      (conj acc cur)\n      (if (or (empty? cur) (= (first cur) (first se)))\n        (recur (rest se) (conj cur (first se)) acc)\n        (recur (rest se) [(first se)] (conj acc cur))))))","problem":31,"user":"515828b8e4b0a069fd272c71"},{"problem":31,"code":"(fn [sq]\n  (loop [curr-sublist []\n         pending-sq sq\n         result []]\n    (if (seq pending-sq)\n      (if (or (empty? curr-sublist) (= (first curr-sublist) (first pending-sq)))\n        (recur (conj curr-sublist (first pending-sq)) (rest pending-sq) result)\n        (let [new-result (conj result curr-sublist)\n              new-curr-sublist [(first pending-sq)]]\n          (recur new-curr-sublist (rest pending-sq) new-result))\n        )\n      (conj result curr-sublist))\n    )\n  )","user":"5fee18f2e4b05ac5b16ea1d2"},{"problem":31,"code":"(fn pack-seq [sq] \n  (loop [in sq out [] pack '()] \n    (if (empty? in) \n      (conj out pack)\n      (if (or (contains? (set pack) (first in)) (empty? pack))\n        (recur (rest in) \n               out \n               (cons (first in) pack)) \n        (recur (rest in) \n               (conj out pack) \n               (list(first in)))\n        )\n      )\n    ))","user":"580f9585e4b0f478707a05b5"},{"problem":31,"code":"(fn [col]\n  (reduce (fn [acc next-item]\n            (let [sub-col (last acc)]\n              (if (= next-item (last sub-col))\n                (conj (vec (butlast acc)) (conj sub-col next-item))\n                (conj acc (vector next-item)))))\n          []\n          col))","user":"56ee905be4b04a395b9a044f"},{"problem":31,"code":"(fn [x] (partition-by (fn [s] s) x))","user":"55f33f0ce4b06e875b46ce59"},{"code":"(fn [ret cur source]\n  (let [\n    x (first source)\n    same-x (and (not (nil? cur)) (= x (first cur)))\n    ret (if (or same-x (nil? cur)) ret (conj ret cur))\n    cur (if same-x (conj cur x) (list x))]\n    (if (zero? (count source))\n      ret\n      (recur ret cur (rest source))))) [] nil","problem":31,"user":"524be8e0e4b09eba1c0223f1"},{"problem":31,"code":"(fn pack\n  [coll]\n  (partition-by identity coll)\n  )","user":"5ac37d0fe4b0e27600da7718"},{"code":"(fn[s] (let [\n    r (reduce \n        (fn[x y] (let [r (x :r)\n                       a (x :a)\n                       m (=(x :p) y)] \n                      {:r (if m r (conj r a))\n                       :a (if m (conj a y) [y])\n                       :p y}\n                 ))\n        {:r []\n         :a [(first s)]\n         :p (first s)\n        } \n        (next s)\n    )\n   ]\n   r\n   (conj (r :r) (r :a))\n))","problem":31,"user":"5017eface4b02f523d7cc5e7"},{"problem":31,"code":"(fn [s] \n            (reverse (reduce (fn [acc e] \n                       (println acc)\n                       (let [la-acc (rest acc)  pa (first acc)] \n                         (if (= (first pa) e) \n                           (conj la-acc (conj pa e))\n                           (conj acc (list e) ) )))\n                     '()\n                     s)))","user":"55edc088e4b0121d4835fde0"},{"code":"(fn pack [xs] (partition-by identity xs))","problem":31,"user":"50ef5703e4b0bdaecbb47d95"},{"code":"(fn [l]\n  (reduce (fn [a b]\n    (let [ihead (first (first a))\n          arest (rest a)]\n      (if (= ihead b)\n          (conj arest (conj (first a) b))\n          (conj a (list b)))))\n    '() \n    (reverse l)))","problem":31,"user":"502cff22e4b0b2ab8d5c7e72"},{"problem":31,"code":"(fn pack-a-sequence-solution\n  [coll] ;; update args as needed\n  (loop [acc [] coll coll]\n    (if (seq coll)\n      (let [x (first coll)\n            xs (take-while #(= x %) coll)]\n        (recur (conj acc xs) (drop (count xs) coll)))\n      (seq acc))))","user":"50c113bee4b096f585049c37"},{"code":"(fn pak [x] (cond (= x []) [] \n                  :else (let [r (pak (rest x))] \n                          (cond (= (first x) (first (first r)))\n                                 (cons (cons (first x) (first r)) (rest r))\n                                 :else (cons (cons (first x) nil) r)))))","problem":31,"user":"528b9efee4b0239c8a67aea0"},{"code":"(fn [coll] (loop [results [] remainder coll] (if (empty? remainder) results (recur (conj results (take-while  (partial = (first remainder)) remainder)) (drop-while (partial = (first remainder)) remainder)))))","problem":31,"user":"50723bbae4b0e3170b5a868b"},{"problem":31,"code":"(fn [seq]\n  (loop [acc [] cur [] rest seq]\n    (if (empty? rest)\n      (conj acc cur)\n      (if (or (empty? cur) (= (first rest) (last cur)))\n        (recur acc (conj cur (first rest)) (drop 1 rest))\n        (recur (conj acc cur) [(first rest)] (drop 1 rest))))))","user":"57c3df67e4b05aa3c4741cc5"},{"code":"(fn pack\n  ([x] (pack [] [(first x)] (first x) (rest x)))\n  ([accum crnt-run crnt rmng]\n   (cond (empty? rmng) (conj accum crnt-run)\n         (= crnt (first rmng)) (recur accum\n                                      (conj crnt-run (first rmng))\n                                      crnt\n                                      (rest rmng))\n         :else (recur (conj accum crnt-run)\n                      [(first rmng)]\n                      (first rmng)\n                      (rest rmng)))))","problem":31,"user":"52153bdde4b0961f15ac4daa"},{"problem":31,"code":"(fn pack [coll]\n  (loop [results [[(first coll)]] items (rest coll)]\n    (if (empty? items)\n      results\n      (let [prev (last (last results)) current (first items)]        \n        (if (= prev current) \n          (recur (conj (vec (butlast results)) (conj (last results) current)) (rest items))\n          (recur (conj results [current]) (rest items))\n        )\n      )\n    )\n  )\n)","user":"5991d2fae4b0866487ed0d68"},{"problem":31,"code":"#(loop [il %\n        ol []\n        sl []]\n   (if (seq il)\n     (if (or \n          (empty? sl)\n          (= (last sl) (first il)))  \n       (recur (rest il)\n              ol\n              (conj sl (first il)))\n       (recur (rest il)\n              (conj ol sl)\n              [(first il)]))\n     (if (seq sl) (conj ol sl) ol)))","user":"599475aae4b0b211ea3aaac8"},{"problem":31,"code":"(fn pack [lst]\n  (let [chomp (fn chomp [lst f]\n                (if (empty? lst)\n                  []\n                  (if (= (first lst) f)\n                    (cons f (chomp (rest lst) f))\n                    []\n                   )\n                 )\n               )\n        chomped (chomp lst (first lst))\n        ]\n    (if (empty? lst)\n    \t[]\n    \t(cons chomped (pack (drop (count chomped) lst)))\n     )\n   )\n )","user":"57ce2db8e4b0c746388ab8a4"},{"code":"(fn [s]\n  (loop [ret [] cur [(first s)] s (rest s)]\n    (if (empty? s)\n      (if (empty? cur)\n        ret\n        (conj ret cur))\n      (if (= (first s) (first cur))\n        (recur ret (conj cur (first s)) (rest s))\n        (recur (conj ret cur) [(first s)] (rest s))))))","problem":31,"user":"4fb4f42ae4b081705acca2b4"},{"code":"(fn pack [lst]\n    (reverse\n    (let [lst (seq lst)]\n      (loop [current     (list (first lst))\n             remaining   (rest lst)\n             accumulator (list) ]\n        (cond (empty? remaining) (cons current accumulator)\n              (= (first current) (first remaining)) (recur\n                                             (cons (first remaining) current)\n                                             (rest remaining)\n                                             accumulator )\n              :else (recur\n                     (list (first remaining))\n                     (rest remaining)\n                     (cons current accumulator)))))))","problem":31,"user":"4f4a8707e4b0d56e7bb92c12"},{"problem":31,"code":"#(loop [result '() pack (list (first %)) se (rest %)]\n    (if (empty? se)\n      (concat result (list pack))\n      (if (= (last pack) (first se))\n        (recur result (concat pack (list (first se))) (rest se))\n        (recur (concat result (list pack)) (list (first se)) (rest se)))))","user":"57b59d77e4b0fbc9809a27ae"},{"problem":31,"code":"(fn pack [l]\n (if (= (count l) 1)\n  (list l)\n  (if\n   (=\n    (first l)\n    (second l))\n   (conj\n    (rest\n     (pack (rest l)))\n    (conj\n     (first\n      (pack (rest l)))\n       (first l)))\n   (conj\n    (pack (rest l))\n     (list\n      (first l))))))","user":"598ab445e4b02b9968b84ce0"},{"problem":31,"code":"#(partition-by (fn [e] e) %)","user":"57481f1fe4b009280f9f2b82"},{"code":"#(map seq (partition-by identity %))","problem":31,"user":"511c91ace4b00c2a1fa7ff7a"},{"code":"(fn clump [s]\n  (when (seq s)\n    (let [[h t] (split-with #{(first s)} s)]\n       (lazy-seq (cons h (clump t))))))","problem":31,"user":"4f50cadce4b03ad3f0c10d0f"},{"code":"(fn [coll]\n    (loop [coll coll\n           acc []] \n      (let [head (first coll)\n            [fst snd] (split-with #(= % head) coll)]\n      (if (empty? coll)\n        acc \n        (recur snd (conj acc fst))))))","problem":31,"user":"4fa2fa5ee4b081705acca186"},{"code":"(fn\n  [s]\n  (partition-by identity s))","problem":31,"user":"4f29afc7e4b0d6649770a02e"},{"problem":31,"code":"(fn a[b]\n\t(partition-by identity b)\n)","user":"5710e574e4b09c608db7043b"},{"code":"(fn pair-up [collection]\n  (loop [things collection outer-list '()]\n    (if (empty? things)\n      (reverse outer-list)\n      (recur (drop-while #(= (first things) %) things)\n             (conj outer-list (take-while #(= (first things) %) things)))\n      )\n    )\n  )","problem":31,"user":"52be23dbe4b07a9af5792316"},{"code":"#(reverse\r\n  (reduce\r\n    (fn [r e]\r\n      (if (= (first (first r)) e)\r\n        (conj (rest r) (conj (first r) e))\r\n        (conj r (list e))))\r\n    ()\r\n    %))","problem":31,"user":"4e65f9d4535d8ccf87e9fe73"},{"problem":31,"code":"(fn foo [xs] \n  (if (empty? xs) []\n  (let [taken (take-while #(= (first xs) %) xs)\n        len (count taken)]\n    (cons taken (foo (nthrest xs len))))))","user":"54133900e4b01498b1a719de"},{"code":"(fn pack [lst]\n  (let\n    [get-rep\n     (fn get-rep [lst x]\n      (cond\n       (not (= x (first lst))) '()\n       (empty? (rest lst)) (list x)\n       :else (cons x (get-rep (rest lst) x))))]\n    (let\n     [pack-it\n     (fn pack-it [lst]\n       (if (empty? lst)\n         '()\n         (let\n           [gp (get-rep lst (first lst))]\n           (let\n             [lstp (drop (count gp) lst)]\n             (cons gp (pack-it lstp))))))]\n\t\t(pack-it lst))))","problem":31,"user":"52f818a6e4b047fd55836fcc"},{"problem":31,"code":"(fn [x] (let [y (partition 1 x) ] (loop [n (dec (count x)) \n res (list (last y))] (if (= n 0) res \n (recur (dec n) (if (= (nth x n) (nth x (dec n)))\n (conj (rest res) (conj (first res) (nth x n)))(conj res (nth y (dec n)) )) )))))","user":"6076adb2e4b069485764de60"},{"code":"(fn [in]\n  (rest (reverse (reduce (fn [a b]\n            (if (= (first (first a)) b)\n              (cons (cons b (first a))\n                    (rest a))\n              (cons (cons b '())\n                    a))) '(()) in))))","problem":31,"user":"4e773be8535d324fb2983d6e"},{"code":"#(letfn [(same [l]\n           (let [a (first l) b (second l)]\n             (if (= a b)\n               (cons a (same (rest l)))\n               [a (rest l)])))]\n   (loop [l %1 acc []]\n     (if (empty? l) acc\n         (let [a (same l) b (drop-last a) c (last a)]\n           (recur c (conj acc b))))))","problem":31,"user":"52d1e364e4b0d9f9285948e7"},{"problem":31,"code":"(fn pack\n    [s]\n    (loop [s      s\n           prev   (first s)\n           res    []\n           curres []]\n      (let [cur (first s)]\n        (prn res) \n        (cond (empty? s)   (conj res curres)\n              (= cur prev) (recur (rest s) cur res (conj curres cur))\n              :else        (recur (rest s) cur (conj res curres) [cur])))))","user":"545e9cf1e4b01be26fd7467f"},{"problem":31,"code":"(fn f [l] (if (empty? l) () (let [c (first l)] (conj (f (drop-while #(= % c) l)) (take-while #(= % c) l)))))","user":"567b39b6e4b05957ce8c61a3"},{"code":"(fn [coll] (loop [r []\n                  c nil\n                  a (seq coll)\n                  ]\n            (if a (\n                    if (= (first c) (first a))\n                        (recur r (conj c (first a)) (next a))\n                        (recur (if c (conj r c) r) (list (first a)) (next a))\n                    )\n                (conj r c)\n             )\n))","problem":31,"user":"4e50e2a0535dc968683fc4ef"},{"code":"(fn [x] \n  (loop [letter (first x)\n         remain (rest x)\n         c 1 \n         f []] \n    (if (= letter nil)\n      f   \n      (if (= letter (first remain))\n        (recur letter (rest remain) (+ c 1) f)\n        (do \n          (recur (first remain) (rest remain) 1 (conj f (repeat c letter)))\n          )   \n        )   \n      )   \n    )   \n  )","problem":31,"user":"4ee88f29535d93acb0a66882"},{"code":"(fn blah [x]\n    (if (empty? x) nil\n      (if (seq? (first x)) \n        (if (= (ffirst x) (second x)) \n          (blah (cons (cons (second x) (first x)) (rest (rest x))))\n          (cons (first x) (blah (rest x))))\n        (if (= (first x) (second x))\n          (blah (cons (list (first x) (second x)) (rest (rest x))))\n          (cons (list (first x)) (blah (rest x)))))))","problem":31,"user":"4f17aa97535d64f603146456"},{"problem":31,"code":"partition-by identity\n\n;(fn [xs] (partition-by (fn [x] x) xs))\n\n;(fn [xs]\n; (loop [in xs out [] part []]\n;    (cond\n;      (empty? in) (drop 1 (conj out part))\n;      (= (first in) (first part)) (recur (rest in) out (conj part (first in)))\n;      :else (recur (rest in) (conj out part) (conj [] (first in)))\n;      )))","user":"55150524e4b055c2f668d4d9"},{"problem":31,"code":"(fn [lst]\n(partition-by identity lst))","user":"57210e8ee4b0c5bde472c0a8"},{"code":"(fn [xs]\n  (let [f (fn [xs ys]\n            (if-let [x (first xs)]\n              (recur (drop-while #(= % x) xs)\n                     (conj ys (take-while #(= % x) xs)))\n              ys))]\n    (f xs [])))","problem":31,"user":"501c76eae4b01d3bc87c0201"},{"code":"(fn mypackage [coll]\r\n  (partition-by (fn [a] a) coll))","problem":31,"user":"4fd170fce4b04c3a95aa0411"},{"problem":31,"code":"(fn pack [s]\n  (reverse \n   (loop [s (rest s)\n          packed (list (list (first s)))]\n     (let [cur-pack (first packed)\n           prev-packs (rest packed)]\n       (cond (empty? s) packed\n             (= (first cur-pack) (first s)) (recur (rest s) (conj prev-packs (into cur-pack (list (first s)))))\n             :else (recur (rest s) (conj packed (list (first s)))))))))","user":"5578c67fe4b05c286339e08d"},{"problem":31,"code":"(fn f [[x & xs]]\n  (if (nil? x)\n    []\n    (if (nil? xs)\n      [[x]]\n      (into [(into [x] (take-while #(= x %) xs))] (f (drop-while #(= x %) xs))))))","user":"56483562e4b0284900eef629"},{"problem":31,"code":"(fn [x] (reverse (reduce (fn [r y]\n                   (if (= (first (first r)) y)\n                     (conj (rest r) (conj (first r) y))\n                     (conj r (list y)))) '() x)))","user":"56171eade4b06b1bb2182a0c"},{"problem":31,"code":"(fn [a]\n      (loop [x (reverse a), latest nil, curr '(), res '()]\n        (if (empty? x)\n          (conj res curr)\n          (if (= (first x) latest)\n            (recur (rest x) (first x) (conj curr (first x)) res)\n            (recur (rest x) (first x) (list (first x)) (if (empty? curr) res (conj res curr)))))\n        ))","user":"548166b3e4b0e286459a116d"},{"problem":31,"code":"(fn [coll]\n  ((fn [coll result accu]\n    (cond\n      (empty? coll) (conj result accu)\n      (empty? accu) (recur (rest coll) result (list (first coll)))\n      (= (first coll) (first accu)) (recur (rest coll) result (conj accu (first coll)))\n      :else (recur (rest coll) (conj result accu) [(first coll)])\n    )\n  ) coll [] [])\n)","user":"53ecd01fe4b0d648e757f4b9"},{"problem":31,"code":"(fn pack-sequence [coll]\n    (partition-by (fn [elem] elem) coll))","user":"552bd5c2e4b0ffed3738f969"},{"problem":31,"code":"(fn [s]\n  (reduce \n   (fn [current n]\n     (if (= (first (last current)) n)\n       (assoc current (- (count current) 1) (conj (last current) n))\n       (conj current (list n))))\n   []\n   s))","user":"5ec0de29e4b00a66d4a9528e"},{"problem":31,"code":"(fn pack [x]\n  (loop [old x new [] counter 1]\n    (if (empty? old)\n      new\n      (if (= (first old) (second old))\n        (recur (rest old) new (inc counter))\n        (recur (rest old) (conj new (repeat counter (first old))) 1)))))","user":"5a9482b7e4b0d174b936c737"},{"problem":31,"code":"(fn [s] (let [add-reps (fn [acc sub]\n                         (if (empty? sub)\n                           acc\n                           (concat acc (list sub))))]\n          (loop [[st & nx :as ls] s\n                 acc ()\n                 sub ()\n                 prev nil]\n            (cond (empty? ls) (add-reps acc sub)\n                  (= st prev) (recur nx\n                                     acc\n                                     (cons st sub)\n                                     prev)\n                  :else (recur nx\n                               (add-reps acc sub)\n                               (list st)\n                               st)))))","user":"59750a68e4b01722bebd4cba"},{"problem":31,"code":"(fn pack [x]\n  (if (= 1 (count x))\n    (list (list (first x)))\n    (let [r (pack (rest x)) curr (first x)]\n      (if (= curr (first (first r)))\n        (cons (cons curr (first r) ) (rest r))\n        (cons (list curr) r)\n      )\n    )\n))","user":"54b050cee4b09f271ff37d13"},{"code":"(fn [coll] \r\n  (loop [coll (rest coll) a [] c [(first coll)] p (first coll)]\r\n    (let [n (first coll)]\r\n      (if (= p n)\r\n        (recur (rest coll) a (conj c p) n)\r\n        (let [r (conj a c)]\r\n          (if (empty? coll)\r\n            r\r\n            (recur (rest coll) (conj a c) [n] n)))))))","problem":31,"user":"4e111538535d04ed9115e7c3"},{"code":"(fn [lust] (reduce\n (fn [memo elm]\n   (reverse (if (or (empty? memo) (= elm (last (last memo))))\n     (conj (reverse (drop-last memo)) (conj (last memo) elm))\n     (conj (reverse memo) (seq [ elm ]))\n   ))\n ) '() lust\n))","problem":31,"user":"4e352362535deb9a81d77f2c"},{"code":"(fn pack\n  ([[x & xs]] (pack xs (list x)))\n  ([[x & xs] ps]\n    (if (nil? x)\n      (list ps)\n      (let [p (first ps)]\n        (if (= p x)\n          (pack xs (conj ps x))\n          (concat (list ps) (pack xs (list x))))))))","problem":31,"user":"4f7f0827e4b06e829148e1d5"},{"problem":31,"code":"(fn pack[coll](loop[coll coll\n                      ret []\n                      p []\n                      v 0]\n                  (cond\n                    (empty? coll)(seq (map seq ret))\n                    :else (recur (rest coll)\n                                 (cond\n                                   (empty? ret)(conj ret (conj p (first coll)))\n                                   (= (last p)(first coll))(assoc ret v(conj p (first coll)))\n                                   :else (conj ret (vector(first coll))))\n                                 (cond\n                                   (empty? p)(conj p (first coll))\n                                   (= (last p)(first coll))(conj p (first coll))\n                                   :else (vector(first coll)))\n                                 (cond\n                                   (empty? p) v\n                                   (= (last p)(first coll)) v\n                                   :else (inc v))\n                                 ))))","user":"5dadf73ee4b0f8c104ccfc86"},{"problem":31,"code":"(fn [x]\n  (loop [res '() toAdd (list (first x)) toDo (rest x)]\n    (if (empty? toDo)\n      (concat res (list toAdd))\n      (if (= (first toAdd) (first toDo))\n        (recur res  (conj toAdd (first toDo)) (rest toDo))\n        (recur (concat res (list toAdd)) (list (first toDo)) (rest toDo))))))","user":"56427910e4b08d4f616f5f19"},{"problem":31,"code":"(fn foo [li]\n  (loop [re li part [] res []]\n    (if (empty? re)\n      (if (empty? part) res\n          (conj res part))\n      (if-not (empty? part)\n        (if (= (first part) (first re))\n          (recur (rest re) (conj part (first re)) res)\n          (recur (rest re) [(first re)] (conj res part)))\n        (recur (rest re) [(first re)] res)))))","user":"59156f0be4b0163c97b36f3d"},{"code":"#(loop [a [] s %] \n   (if (empty? s) a \n     (recur \n      (conj a (take-while (partial = (first s)) s)) \n      (drop-while (partial = (first s)) s))))","problem":31,"user":"521e8227e4b0dd19981ad082"},{"problem":31,"code":"(fn sublists\n  ([x l lol]\n    (if (empty? x)\n      (conj lol l)\n      (sublists\n        (rest x)\n        (if (= (first x) (first l)) (conj l (first x)) (list (first x)))\n        (if (= (first x) (first l)) lol (conj lol l))\n      )\n    ) \n  )\n  ([x] (sublists (rest x) (list (first x)) []))\n)","user":"54257124e4b01498b1a71b09"},{"code":"(fn  [v]\n  (let [innerF (fn [v1 r]\n           (cond \n             (nil? (first v1)) (reverse r)\n             (nil? (first r)) (recur (rest v1) (conj '() (conj '() (first v1))))\n             (= (first v1) (first (first r)))  (recur (rest v1) (conj (rest r) (conj (first r) (first v1))))\n            \n            :else (recur (rest v1) (conj r (conj '() (first v1))))\n           )\n                 )]\n    (innerF v '())\n    )\n    \n  )","problem":31,"user":"531902b1e4b08068f379ed77"},{"problem":31,"code":"(fn pack\n   [lst]\n  (if (empty? lst)\n    ()\n    (loop [lst2 lst\n           new-list-out ()\n           new-list ()\n           first-loop 0\n           currVal (first lst2)]\n      (if (empty? lst2)\n        (reverse (conj new-list-out new-list))\n        (if (= first-loop 0)\n          (recur (rest lst2)  new-list-out (conj new-list currVal) (+ 1 first-loop) (first (rest lst2)))\n          (if (= currVal (first new-list))\n            (recur (rest lst2) new-list-out (conj new-list currVal) first-loop (first (rest lst2)))\n            (recur (rest lst2) (conj new-list-out new-list) (conj () currVal ) first-loop (first (rest lst2)))))))))","user":"59e56c75e4b08badc2a0c556"},{"problem":31,"code":"(fn [xs] (let [[c, v, vs] (reduce (fn [[c, v0, vs] v1] (if (= v0 v1) [(+ c 1), v0, vs] [1, v1, (conj vs (repeat c v0))])) [0, nil, []] xs)] (rest (conj vs (repeat c v)))))","user":"54c641f8e4b045293a27f628"},{"code":"(fn pack-duplicates [li]\n  (let [dup (first li)\n        numof    \n        ((fn dupcount [l x]\n           (if (or (empty? l) \n                   (not= (first l) dup))\n             x\n             (dupcount (rest l) (+ x 1))))    \n          li 0)]\n    (if (= numof 0) '()\n      (conj (pack-duplicates (drop numof li)) \n            (take numof li)))))","problem":31,"user":"50c84ba2e4b00bb60fe0c53e"},{"code":"(fn solution [s]\n  (reverse \n    (reduce\n      #(if\n         (= (first (first %1)) %2)\n         (cons (cons %2 (first %1)) (rest %1))\n         (cons (list %2) %1 )\n       )\n      []\n    s\n    )\n  )\n;  (partition-by identity s)\n)","problem":31,"user":"52b49aebe4b0c58976d9ad2b"},{"code":"(fn [l] (partition-by identity l))","problem":31,"user":"4eca7a87535d6d7199dd3705"},{"problem":31,"code":"(fn [l]\n  (reverse\n    (reduce \n      (fn [a e] \n        (cons \n          (if \n            (= (first (first a)) e) \n            (cons e (first a))\n            (list e)) \n          (if \n            (= (first (first a)) e) \n            (rest a)\n            a ))) \n      (list (list (first l))) \n      (rest l))))","user":"53a5bc3ae4b0ef122a8689c3"},{"code":"(fn [s]\n  (loop [s s buf nil res nil]\n    (if-let [elt (first s)]\n      (if (= elt (first buf))\n        (recur (next s) (cons elt buf) res)\n        (recur (next s) (list elt) (cons buf res)))\n      (next\n        (if (empty? buf)\n          (reverse res)\n          (reverse (cons buf res)))))))","problem":31,"user":"4fc13433e4b081705acca32b"},{"problem":31,"code":"(fn pack-seq\n  [sq]\n  (reduce \n    (fn [pack elem] ;;each elem in pack has always the same values, therefore we can check just the first item\n      (let [last-pack (last pack)\n            last-elem (first last-pack)]\n        (if (= last-elem elem) \n          (conj (vec (butlast pack)) (conj last-pack elem));;if it is the same, then add to that item\n          (concat pack [[elem]])))) ;;if not, start a new pack\n    [(vector (first sq))] ;;kickstart with a pack\n    (rest sq)))","user":"59863a26e4b021a7a535fe87"},{"code":"(fn a [lst]\n  (if (empty? lst)\n      nil\n      (cons (take-while (partial = (first lst)) lst) \n            (a (drop-while (partial = (first lst)) lst)))))","problem":31,"user":"4f7fc9a1e4b033992c121bee"},{"code":"(fn f [v]\n  (when (pos? (count v))\n    (let [h (take-while #(= % (first v)) v)]\n      (cons h (f (subvec v (count h)))))))","problem":31,"user":"536f5900e4b0fc7073fd6e7b"},{"problem":31,"code":"(fn [s]\n  (let [hlp (fn [acc el]\n              (if (and (not (empty? acc))\n                       (= el (first (first acc))))\n                (cons (cons el (first acc))\n                      (rest acc))\n                (cons (list el) acc)))]\n    (reverse (reduce hlp () s))))","user":"57df2722e4b0bd073c20245e"},{"code":"(fn [s]\n  (reduce #(if (= %2 (peek (peek %1)))\n               (conj (pop %1) (conj (peek %1) %2))\n               (conj %1 [%2])) [[(first s)]] (rest s)))","problem":31,"user":"50bb646de4b03e68e4411ca3"},{"code":"(fn [daseq] (reverse (reduce #(if (= (first (first %1)) %2) (conj (rest %1) (conj (first %1) %2)) (conj %1 (list %2))) '() daseq)))","problem":31,"user":"52747090e4b03e8d9a4a74a5"},{"code":"(fn [s]\n    (rest\n      (loop [acc [] x s count 0 last nil]\n        (cond\n          (empty? x) (conj acc (repeat count last))\n          (= last (first x)) (recur acc (rest x) (+ 1 count) last)\n          :else (recur (conj acc (repeat count last)) (rest x) 1 (first x))))))","problem":31,"user":"527cd633e4b0757a1b17136f"},{"code":"#(reverse (reduce (fn [x y] (if (= y (-> x first first)) (conj (rest x) (conj (first x) y)) (conj x (list y)))) [] %))","problem":31,"user":"4e79a143535db169f9c796a2"},{"problem":31,"code":"(fn pa\n  ([a] (pa (seq a) []))\n  ([a ret]\n    (if (empty? a)\n      ret\n      (let [[val & remaining]  a\n            lastList (last ret)]\n        (if (= val (first lastList))\n          (recur remaining (conj (pop ret) (conj lastList val)))\n          (recur remaining (conj ret [val])))))))","user":"4f4aa932e4b0d56e7bb92c14"},{"problem":31,"code":"#(loop [v %\n          t []\n          s []]\n        (cond (empty? v) (rest (conj s t))\n              (contains? (set t) (first v)) (recur (rest v) (conj t (first v)) s)\n              :else (recur (rest v) [(first v)] (conj s t))))","user":"55e732c5e4b050e68259b492"},{"problem":31,"code":"(fn [a] (let [l (map vector a)]\n          (reduce\n           #(if (= (first %2)\n                   (last (last %1)))\n              (assoc %1 (- (count %1) 1) (concat (last %1) %2))\n              (conj %1 %2))\n           []\n           l)))","user":"52c45ac8e4b0c2d177d620d9"},{"code":"(fn [coll]\n  (partition-by #(list %) coll))","problem":31,"user":"5014754de4b094324338f8e5"},{"code":"(fn f [[a & z :as s]]\n  (lazy-seq\n    (when a\n      (let [[p q] ((juxt take-while drop-while)\n                   #(= a %) s)]\n        (cons p (f q))))))","problem":31,"user":"4e5fe31a535d8ccf87e9fe50"},{"code":"(fn [coll]\n\t(loop [groups [] prev nil group [] remaining coll]\n\t   (if (empty? remaining)\n\t       (conj groups group)\n\t       (let [this (first remaining)]\n\t\t (if (or (= this prev) (nil? prev))\n\t\t     (recur groups this (conj group this) (rest remaining))\n\t\t     (recur (conj groups group) this [this] (rest remaining)))))))","problem":31,"user":"4e68fad4535d8ccf87e9fe93"},{"code":"partition-by  identity","problem":31,"user":"4f16d3fd535d64f60314644e"},{"code":"(fn pack [coll]\n   (loop [result []\n          remaining coll]\n      (if (empty? remaining)\n        result\n       (recur (conj result (take-while #(= (first remaining) %) remaining)) (drop-while #(= (first remaining) %) remaining)))))","problem":31,"user":"532ecd44e4b019098a6f8b49"},{"problem":31,"code":"(fn gg [%1]\n  (->>  (reduce (fn [result c]\n\n                  (if (= (set (first result)) (set (list c)))\n\n                    (conj (rest result) (conj (first result) c))\n                    (conj result (list c))\n\n                    )) '() %1) (reverse))\n  )","user":"5a71c89ee4b0512ff01cda93"},{"problem":31,"code":"(fn [xList]\n  (reverse (reduce (fn [xFirst xSecond]\n            (cond\n              (= (first (first xFirst)) xSecond) \n              (conj (drop 1 xFirst) (conj (first xFirst) xSecond) )\n              :else (conj xFirst (list xSecond))\n            )\n          )\n          '()\n          xList\n  ))\n)","user":"5da20e73e4b000c986472be1"},{"problem":31,"code":"(fn [coll]\n  (loop [res-seq  []\n         curr-seq []\n         last-item nil\n         rem-items coll]\n    (let [curr-item (first rem-items)]\n      (if (nil? curr-item)\n        (conj res-seq curr-seq)\n        (if (or (nil? last-item) (= last-item curr-item))\n          (recur res-seq\n                 (conj curr-seq curr-item)\n                 curr-item\n                 (rest rem-items))\n          (recur (conj res-seq curr-seq)\n                 [curr-item]\n                 curr-item\n                 (rest rem-items)))))))","user":"541df619e4b01498b1a71a87"},{"problem":31,"code":"(fn [cl] (loop [c cl, r []] (let [cp (for [v c :while (= (first c) v)] v)]\n           (if (empty? c) r\n             (recur (drop (count cp) c) (conj r cp)))\n  )))","user":"55adf4d7e4b03311e7b732af"},{"problem":31,"code":"(fn [xs]\n  (loop [xs xs ret '()]\n    (if (empty? xs)\n      (reverse  ret)\n      (recur (drop-while (partial = (first xs)) xs)\n             (cons (take-while (partial = (first xs)) xs) ret)))))","user":"5d81b40ce4b0915913b1d379"},{"code":"(fn [coll]\n  ((fn pack [coll prev acc]\n    (if (seq coll)\n      (let [[x & xs] coll]\n        (if (= prev x)\n          (pack xs x (cons x acc))\n          (cons acc (pack xs x (list x)))))\n      (list acc)))\n   (rest coll) (first coll) (list (first coll))))","problem":31,"user":"4ee2da14535d10e5ff6f536c"},{"problem":31,"code":"(fn foo [s]\n    (loop [x (first s)\n           xs (rest s)\n           bag (list x)\n           acc []]\n        (if (empty? xs)\n            (conj acc bag)\n            (let [y (first xs)\n                  ys (rest xs)]\n                (if (= x y)\n                    (recur y ys (conj bag y) acc)\n                    (recur y ys (list y) (conj acc bag)))))))","user":"600ae927e4b074f607df6689"},{"problem":31,"code":"(fn ff [values] (loop [remaining values finals '()] \n  (if (empty? remaining)\n    finals\n    (let [fir (first remaining)\n          tks (take-while (partial = fir) remaining)\n          dps (drop-while (partial = fir) remaining)\n          ]\n      (recur dps\n             (concat finals (vector tks)))))))","user":"57b35ecbe4b0fbc9809a277e"},{"code":"(fn [x]\n  (loop [x x v [] l nil c 0]\n    (if (nil? (first x))\n      (if (> c 1)\n        (rest (concat v (list (repeat c l))))\n        (rest (concat v (list (list l)))))\n      (if (= (first x) l)\n        (recur (rest x) v l (inc c))\n        (recur (rest x)\n               (if (> c 1)\n                 (concat v (list (repeat c l)))\n                 (concat v (list (list l))))\n               (first x)\n               1)))))","problem":31,"user":"5123ac8ee4b061b4c6f0e0b1"},{"problem":31,"code":"(fn f [coll]\n  (let [g (partial reduce\n                       (fn [[r l] e]\n                         (if (= (last l) e)\n                           [r (conj l e)]\n                           [(conj r l) [e]]))\n                       [[] nil])\n        [r l] (g coll)]\n    (next (conj r l))\n  ))","user":"53d78b64e4b0e771c3025466"},{"code":"reduce (fn [s i] \n  (let [t (last s)]\n  (if (= (last t) i) (conj (pop s) (conj t i))\n    (conj s [i])))) []","problem":31,"user":"4eb9c82d535dfed6da9c6d5c"},{"code":"(fn [c] (reduce \n          #(if (= %2 (first (last %)))\n                 (concat (drop-last %) (list (cons %2 (last %))))\n                 (concat % (list (list %2)))) \n          '() c))","problem":31,"user":"525ed5f4e4b0cb4875a45db8"},{"problem":31,"code":"(fn foo\n     ([coll]\n       (if (empty? coll) coll (let [head (first coll)] (foo (rest coll) head [] (list head)))))\n     ([coll prev accum next]\n       (if (empty? coll)\n         (conj accum next)\n         (let [head (first coll) tail (rest coll)]\n           (if (= head prev)\n             (foo (rest coll) head accum (conj next head))\n             (foo (rest coll) head (conj accum next) (list head)))))))","user":"5509bec5e4b06e50f9beb121"},{"code":"#(\r\n  letfn [(d [s h r]\r\n            (if (empty? s)\r\n                (cons h r)\r\n                (let [f (first s) v (rest s)]\r\n                (if (= f (first h))\r\n                    (d v (cons f h) r)\r\n                    (d v (list f) (cons h r))))))]\r\n        (rest (reverse (d % '() nil))))","problem":31,"user":"4df1ce44535d08e6dec9fe1f"},{"problem":31,"code":"(fn [x] \n  (loop [y [] x1 x] \n    (if (empty? x1)\n      y\n      (let [[r s] (split-with #(= (first x1) %) x1)]\n        (recur (conj y r) s)))))","user":"546a65fce4b00cfc9eacc153"},{"code":"(fn [lst]\n  (if (empty? lst) lst\n    (let [[x & xs] lst]\n      (loop [todo xs\n             sofar (vector (list x))]\n        (if (empty? todo) sofar\n          (let [[t & ts] todo\n                s (peek sofar)\n                ss (pop sofar)]\n            (if (= t (peek s))\n              (recur ts (conj ss (conj s t)))\n              (recur ts (conj sofar (list t))))))))))","problem":31,"user":"4ec59ce4535d6d7199dd36ab"},{"problem":31,"code":"(fn pack [[a & z :as s]]\n  (when a\n    (let [[p q] ((juxt take-while drop-while)\n                 #(= a %) s)]\n      (cons p (pack q)))))","user":"58ffc6cfe4b0438e51c2d008"},{"code":"(fn [xs]\n   (loop [res '()\n          head (first xs)\n          tail (rest xs)]\n     (if (empty? tail)\n       (if head\n         (reverse (cons (list head) res))\n         (reverse res))\n       (recur (cons (cons head (take-while #(= % head) tail)) res)\n              (first (drop-while #(= % head) tail))\n              (rest (drop-while #(= % head) tail))))))","problem":31,"user":"5348cab4e4b084c2834f4a5e"},{"problem":31,"code":"(fn [lst]\n  (reduce\n    (fn [acc x]\n      (let [acc' (vec (butlast acc))\n            las (last acc)]\n        (if (or (= (last las) x) (empty? las))\n          (conj acc' (conj las x))\n          (conj acc [x])\n        )\n      )\n    )\n   [[]]\n   lst\n )\n)","user":"5943abb6e4b060784b3b792b"},{"code":"reduce #(if (= (last (last %1)) %2)\n           (concat (butlast %1) [(conj (last %1) %2)])\n           (concat %1 [[%2]] )) []","problem":31,"user":"52ba2af3e4b07a9af57922cc"},{"problem":31,"code":"(fn ans-31 [c]\n  (reduce (fn [accum item]\n            (let [lol (-> accum last last)]\n              (if (= lol item)\n                (assoc-in accum [(- (count accum) 1)\n                                 (count (last accum))]\n                          item)\n                (conj accum [item]))))\n          []\n          c))","user":"608fac60e4b03bd49d9f36c7"},{"problem":31,"code":"(fn [arr]\n    (loop [cur-arr arr\n         first-num (first arr)\n         cur-old-num-arr (list)\n         full-arr (list)\n         ]\n  (if (empty? cur-arr)\n    (reverse  (conj full-arr cur-old-num-arr) )\n    (cond\n      (= (first cur-arr) first-num) (do\n                                      (let [tmp-to-send (conj cur-old-num-arr first-num)]\n                                        (recur (rest cur-arr) (first cur-arr) tmp-to-send full-arr)\n                                        )\n                                      )\n      :else (do\n              (let [tmp-end-to-send (conj full-arr cur-old-num-arr)]\n                (recur cur-arr (first cur-arr) (list) tmp-end-to-send)\n                )\n              )\n      )\n    )\n  )\n  )","user":"5d90b3b3e4b0915913b1d3fb"},{"code":"#(loop [x %\n        y ()\n        h ()]\n   (print h)\n   (if (empty? x)\n     (if (empty? h) (reverse y) (reverse (conj y h)))\n     (if (or (= (first x) (first h)) (empty? h))\n       (recur (rest x) y (conj h (first x)))\n       (recur (rest x) (conj y h) (conj () (first x))))))","problem":31,"user":"52f685eae4b047fd55836fb8"},{"code":"(fn rec [ls]\r\n  (lazy-seq\r\n    (if (empty? ls) ()\r\n      (let [f (first ls)\r\n            fs (take-while #(= f %) ls)\r\n            rs (drop-while #(= f %) ls)]\r\n        (cons fs (rec rs))))))","problem":31,"user":"4dd62278535d2dad7130b5c7"},{"code":"(fn pack [s]\n  (let [group (take-while #(= % (first s)) s)\n        t (drop (count group) s)]\n    (if (= 0 (count t))\n      (list group)\n      (concat (list group)\n              (pack t)))))","problem":31,"user":"4ff304f4e4b0678c553fc343"},{"problem":31,"code":"(fn [c]\n  (letfn [(f [s x] (if (= x (-> s last last)) (conj (pop s) (conj (last s) x)) (conj s [x])))]\n    (reduce f [] c)))","user":"5b5e7953e4b0c6492753e6d9"},{"problem":31,"code":"#(reverse (reduce (fn[a x] (if (= x (first (first a))) (cons (cons x (first a)) (rest a)) (cons (list x) a))) '() %))","user":"56050f06e4b08b23635d3161"},{"problem":31,"code":"(fn [lst] \n  (partition-by identity lst))","user":"5f84f110e4b0375e81f54e79"},{"code":"(fn pack [inlist]\n  (if (empty? inlist)\n    inlist\n    (concat\n      (list ((fn firstseq [app, inlist]\n        (if (or (= (last app) (first inlist)) (empty? app))\n          (firstseq (concat app (list (first inlist))) (rest inlist))\n          app))\n      '() inlist))\n      (pack\n        ((fn restseq [app, inlist]\n          (if (or (= (last app) (first inlist)) (empty? app))\n            (restseq (concat app (list (first inlist))) (rest inlist))\n            inlist))\n        '() inlist)))))","problem":31,"user":"4fc50bcbe4b081705acca375"},{"problem":31,"code":";(fn pack-consec\n;  [coll]\n;  (loop [s (rest coll)\n;         x (list (first coll))\n;         acc []]\n;    (if (seq s)\n;      (if (= (first s) (first x))\n;        (recur (rest s) (conj x (first s)) acc)\n;        (recur (rest s) (list (first s)) (conj acc x)))      \n;       (conj acc x))))\n\n;; (partition-by f) (partition-by f coll)\n;; partition-by makes a new partition whenever f returns a new value\npartition-by identity","user":"560dfa8de4b05f002753df46"},{"problem":31,"code":"(fn \n  [seq]\n  (loop [to-process seq sub-lists []]\n    (let [last-char (first (last sub-lists)) current-char (first to-process) last-group (last sub-lists)]\n    (if (empty? to-process)\n      sub-lists\n      (recur (rest to-process) (if (= last-char current-char) (conj (vec (butlast sub-lists)) (conj last-group last-char)) (conj sub-lists [current-char])))\n      ))))","user":"5f6e5c58e4b02876ed9fd067"},{"code":"(fn [x]\n  (drop 1 (reduce\n    (fn [p y]\n      (let [final (last p)\n            body (vec(butlast p))]\n        (if (= y (first final))\n          (conj body (conj final y))\n          (conj body final [y]))))\n    []\n    x)))","problem":31,"user":"50ed5d1be4b06330c1f87c37"},{"problem":31,"code":"reduce (fn aly [acc e]\n          (if (or (empty? acc) (not= (last (last acc)) e))\n            (conj acc [e])\n            (conj (vec (butlast acc)) (conj (last acc) e)))) []","user":"5a3ece62e4b0447ef91cc5b9"},{"code":"(fn fn31 [coll]\n  (partition-by identity coll))","problem":31,"user":"5042bb9ae4b034ff00315d16"},{"problem":31,"code":"(fn [x]\n  (loop [x x lastI nil new []]\n    (if (empty? x)\n      new\n      (recur (rest x) (nth x 0) \n             (if (= lastI (nth x 0))\n               (conj (vec (drop-last new)) (conj (last new) (nth x 0)))\n               (conj new [(nth x 0)])\n               )\n             )\n      )\n    )\n  )","user":"5694292ee4b0dcc4269f4113"},{"code":"#(loop [s % r []]\n             (cond (empty? s) r\n                   (empty? r) (recur (rest s) (conj r [(first s)]))\n                   (= (first s) (first (last r))) (recur (rest s) (conj (vec (butlast r)) (conj (last r) (first s))))\n                   :else (recur (rest s) (conj r [(first s)]))))","problem":31,"user":"4fae258de4b081705acca246"},{"code":"(fn f\n  [s]\n  (if (empty? s)\n    s\n    (conj (f (drop-while #(= (first s) %) (rest s))) \n          (take-while #(= (first s) %) s))))","problem":31,"user":"50ef77a4e4b0bdaecbb47d99"},{"code":"(fn mypack [lst]\r\n  (loop [xs '()\r\n   ls (rest lst)\r\n\t l (first lst)\r\n\t c 1]\r\n    (if (= nil (first ls))\r\n      (reverse (conj xs (repeat c l)))\r\n      (if (= l (first ls))\r\n\t(recur xs (rest ls) l (+ c 1))\r\n\t(recur (conj xs (repeat c l))\r\n\t       (rest ls)\r\n\t       (first ls)\r\n\t       1)))))","problem":31,"user":"4ddc620d535d02782fcbea06"},{"problem":31,"code":"(fn pack [sequ]\n  (loop [[x & y] sequ prim nil out '()]\n    (if (nil? x) \n      (reverse out)\n      (do\n        (if (not (= x prim)) \n          (recur y x (cons (cons x '()) out))\n          (recur y prim (cons (cons x (first out)) (rest out))))))))","user":"5b02ab12e4b0cc2b61a3bd53"},{"code":"(fn [l]\n  (loop [tail l retval ()]\n  (if (empty? tail)\n\t    (reverse retval)\n\t  (let [one (for [x tail :while (= x (first tail))] x)]\n\t       (recur (drop (count one) tail) (conj retval one))))))","problem":31,"user":"4e7d2448535db169f9c796c8"},{"code":"(fn [xs]\n   (reduce\n   (fn [accum nxt]\n     (if (or \n          (empty? accum)\n          (-> accum\n              last\n              first\n              (= nxt)\n              not))\n       (conj accum [nxt])\n       (update-in accum [(dec (count accum))] conj nxt)))\n   [] xs))","problem":31,"user":"51aa2b4fe4b04e3dc0c27b21"},{"problem":31,"code":"(fn pack[s]\n  (partition-by identity s))","user":"5731e36be4b0cd1946bd0fc9"},{"code":"(fn [c]\n  (reduce #(if (= (first (last %1)) %2) (conj (vec (drop-last %1)) (cons %2 (last %1))) (conj (vec %1) (cons %2 []))) [] c))","problem":31,"user":"514721c6e4b0d520409ed392"},{"problem":31,"code":"(fn iter [xs] \n\t(loop [curr xs\n           temp '()\n           ret '()]\n      (if (= (count curr) 0)\n        (concat ret (list temp))\n        (if (or (= (count temp) 0) (= (first curr) (first temp)))\n          (recur (rest curr) (concat temp (list (first curr))) ret)\n          (recur curr '() (concat ret (list temp)))\n        )\n      )\n    )\n)","user":"5c3f6322e4b08cd430848e97"},{"code":"(fn pack\n  ([x] (pack [] [(first x)] (rest x)))\n  ([res v x]\n    (cond\n      (empty? x) (conj res v)\n      (= (first x) (first v)) \n        (recur res \n               (conj v (first x))\n               (rest x))\n      true \n        (recur (conj res v)\n               [(first x)]\n               (rest x)))))","problem":31,"user":"4e28120f535deb9a81d77efa"},{"code":"(fn pack [coll]\n  (when (seq coll)\n    (let [eq-seq (take-while #(= (first coll) %) coll)]\n      (cons eq-seq\n            (pack (drop (count eq-seq) coll))))))","problem":31,"user":"4e7e4d5c535db169f9c7970f"},{"problem":31,"code":"(partial reduce (fn [acc x]\n                  (if (= x (last (last acc)))\n                    (concat (butlast acc) (list (conj (last acc) x)))\n                    (concat acc (list (list x)))))\n         '())","user":"5c2d1f63e4b0d62ef62d9ef0"},{"problem":31,"code":";(fn pack [x]\n;  (loop [a (first x) ; current compare-to item\n;         rx (rest x) ; rest of x\n;         cnt 1\t\t ; current pack's count (number of 'a' so far)\n;         rt []]\t\t ; results\n;    (if (empty? rx) (conj rt (repeat cnt a))\n;     (if (= a (first rx))\n;      (recur a (rest rx) (inc cnt) rt)\n;      (recur (first rx) (rest rx) 1 (conj rt (repeat cnt a)))\n;     ))))\npartition-by identity","user":"56d5c1b0e4b0ea9b8538f7c3"},{"problem":31,"code":"(fn pack [xs]\n  (reduce (fn [coll x]\n            (if (= (last (last coll)) x)\n              (update-in coll [(dec (count coll))] conj x)\n              (conj coll [x])))\n          [] xs))","user":"53e8c684e4b036ad0777e48b"},{"problem":31,"code":"(fn myfunc\n   ([x] (myfunc x '()))\n   ([x, y]\n        (if (empty? x)\n          (reverse y)\n          (recur (rest x)\n                 (if (empty? y)\n                   (list (list (first x)))\n\n\n                   (if (= (first x) (first (first y)))\n                     (conj (rest y) (conj (first y) (first x) ))\n                     \n                     (conj y (list (first x)))\n                     )\n                   )\n                 )\n          )\n        )\n   )","user":"5a0a3473e4b0eab8c0448941"},{"problem":31,"code":"(fn [sq]\n          (reduce (fn [result s]\n                    (println result s)\n                    (if (= (last (last result)) s)\n                      (conj (vec (butlast result)) (vec (conj (last result) s)))\n                      (conj result [s]))) [] sq))","user":"5c995fa4e4b048ec896c5a96"},{"code":"(fn pack\n  [coll]\n  (loop [out []\n   section [(first coll)]\n\t tail (rest coll)]\n    (if (seq tail)\n     (let [last-element (peek section)\n\t   next-element (first tail)]\n       (if (= last-element next-element)\n\t (recur out (conj section next-element) (rest tail))\n\t (recur (conj out section) [next-element] (rest tail))))\n     (conj out section))))","problem":31,"user":"4e5bff2b535d8a8b8723a2bd"},{"code":"(fn [xs]\n  (loop [xs xs ys '() hold '()]\n    (if (empty? xs)\n      (if (empty? hold) ys (list* hold ys))\n      (recur\n       ;xs\n       (butlast xs)\n       ;ys\n       (if (= (last xs) (first hold))\n         ys\n         (if (empty? hold)\n           ys\n           (list* hold ys)))\n       ;hold\n       (if (= (last xs) (first hold))\n         (list* (last xs) hold)\n         (list* (last xs) '()))))))","problem":31,"user":"4dbe04b2535d020aff1edf56"},{"problem":31,"code":"(fn group [ls]\n  (if (empty? ls)\n    '()\n    (let [[x & xs] ls]\n  \t\t(cons (cons x (take-while #(= x %) xs)) (group (drop-while #(= x %) xs))))))","user":"55330d7fe4b09218d5f44f88"},{"problem":31,"code":"#(reverse ((fn rec [oli nli] (cond\n                               (empty? oli) nli\n                               (= (first oli) (first (first nli))) (rec (rest oli) (cons (cons (first oli) (first nli)) (rest nli)))\n                               true  (rec (rest oli) (cons (list (first oli)) nli))\n                               \n                               )) (rest %) (list (list (first %)))))","user":"5b20134de4b03cfeda66ed2d"},{"problem":31,"code":"#(\n  (fn pack [res prev coll]\n   \t\t(if-let [[f & r] coll]\n          (if (= f (first prev))\n              (pack res (conj prev f) r)\n              (pack (conj res prev) `(~f) r))\n   \t\t  (seq (conj res prev))))\n   [] [(first %)] (rest %))","user":"55ef9c9de4b066087aa94537"},{"code":"(fn [v]\n  (partition-by identity v))","problem":31,"user":"516282c3e4b0e6d3c4734711"},{"problem":31,"code":"(fn [s]\n    (partition-by identity s))","user":"5549ff9ae4b0a04f7929956e"},{"problem":31,"code":"(fn [in] (partition-by #(->%) in))","user":"563e7a33e4b0da801c4e466d"},{"problem":31,"code":"(fn [unpacked-list]\n  (reduce (fn [packed-vals current-value]\n          (if (= (last (last packed-vals)) current-value)\n            (concat (butlast packed-vals)\n                    [(concat (last packed-vals)\n                             [current-value])])\n            (concat packed-vals (list [current-value]))\n            ))\n        []\n        unpacked-list))","user":"57280b92e4b0c5bde472c14e"},{"problem":31,"code":"#(->> % (reduce\n         (fn [acc it]\n          (if (= (ffirst acc) it)\n            (cons (cons it (first acc)) (rest acc))\n            (cons (list it) acc)))\n         ())\n      reverse)","user":"561ca2eae4b064ca9f4b169b"},{"problem":31,"code":"(fn [sq]\n  (loop [sq sq acc []]\n    (if (empty? sq)\n      (seq acc)\n      (let [start (first sq)\n            the-same #(= % start)]\n        (recur (drop-while the-same sq) (conj acc (take-while the-same sq)))))))","user":"5a512929e4b05d388ecb6be2"},{"problem":31,"code":"(fn f [l]\n  (if (empty? l)\n    ()\n    (cons (take-while #(= (first l) %) l)\n          (f (drop-while #(= (first l) %) l)))))","user":"5791d259e4b0ebec4cfb75c0"},{"code":"(fn [s]\n  (loop [items s, dups (), acc ()]\n    (if (empty? items)\n      (reverse (conj acc dups))\n      (if (empty? dups)\n        (recur (rest items) (list (first items)) acc)\n        (if (= (first dups) (first items))\n          (recur (rest items) (conj dups (first items)) acc)\n          (recur (rest items) (list (first items)) (conj acc dups)))))))","problem":31,"user":"4ea4fe1f535d7eef308072cf"},{"problem":31,"code":"(fn my-pack [seq]\n (loop [loop-seq seq\n  target-seq []]\n  (if (empty? loop-seq)\n   (concat '() target-seq)\n   (let [head (first loop-seq)\n    body (rest loop-seq)\n    target-body (if (empty? target-seq)\n      target-seq\n      (pop target-seq))\n    last-pack (last target-seq)\n    last-item (last last-pack)]\n    (recur body (vec\n                 (concat target-body\n                  (if (= head last-item)\n                   (list (concat last-pack (list head)))\n                   (if (nil? last-pack)\n                    (list (list head))\n                    (list last-pack (list head)))))))))))","user":"58fed70de4b0438e51c2cfdd"},{"problem":31,"code":"(fn [xxs] (let [fr (fn [ps t xs] (if (first xs) \n                                     (if (= 0 (count t)) (recur ps (cons (first xs) t) (rest xs))\n                                        (if ((set t) (first xs)) (recur ps (cons (first xs) t) (rest xs))\n                                          (recur (conj ps t) (list) xs))\n                                     )  \n                                     (conj ps t) )\n                     )]\n            (fr [] [] xxs)))","user":"59ff9424e4b01bb0ae8afd24"},{"problem":31,"code":"(fn pack_seq\n  ; packs consecutive duplicates into sub lists\n  [lst]\n  (partition-by identity lst))","user":"5bbbcecee4b0a20761a23611"},{"problem":31,"code":"(fn pack-seq [col]\n  (loop [xs col\n         packed '()]\n    (if-let [head (first xs)]\n      (if-let [phead (first packed)]\n        (if (some #(= head %) phead)\n          (recur (rest xs) (conj (rest packed) (conj phead head))) ; phead has head, so add that to the list and recur\n          (recur (rest xs) (conj packed (list head))))                 ; phead does not have head, so insert it as a new list and recur\n        (recur (rest xs) (conj packed (list head))))            ; packed is empty, insert head as a list\n      (reverse packed))))","user":"5d80f328e4b0915913b1d372"},{"problem":31,"code":"(fn [s]\n(reverse\n  (reduce\n    (fn [grouped-list current]\n      (if (= (first (first grouped-list)) current)\n          (conj (rest grouped-list) (conj (first grouped-list) current))\n          (conj grouped-list (conj '() current)))\n      ) '() s))\n)","user":"59be62d5e4b0a024fb6ae435"},{"code":"(fn [x]\n  (partition-by identity x)\n  )","problem":31,"user":"4edf95a8535d10e5ff6f5342"},{"code":"#(->> % (partition-by identity))","problem":31,"user":"52c60945e4b0c2d177d62108"},{"problem":31,"code":"(fn [original-list]\n  (loop [remaining original-list bunched [] output [] previous 0]\n  (println remaining bunched output)\n  (if (empty? remaining)\n    (conj output bunched)\n    (if (and (empty? output) (empty? bunched))\n      (recur (rest remaining) (conj bunched (first remaining)) [] (first remaining))\n      (if (= previous (first remaining))\n        (recur (rest remaining) (conj bunched (first remaining)) output (first remaining))\n        (recur (rest remaining) [(first remaining)] (conj output bunched) (first remaining))))))\n)","user":"5b3de9a7e4b02d533a91bbf4"},{"problem":31,"code":"(fn [strn]\n\t(loop [src strn comprd '() prog '() prev nil]\n\t\t(if (= 0 (count src))\n\t\t\t(reverse (conj comprd prog))\n\t\t\t(if (= (first src) prev )\n\t\t\t\t(recur (rest src) comprd (conj prog (first src)) prev)\n\t\t\t\t(if (= prev nil)\n\t\t\t\t\t(recur (rest src) comprd (conj '() (first src)) (first src))\n\t\t\t\t\t(recur (rest src) (conj comprd prog) (conj '() (first src)) (first src))\n\t\t\t\t)))))","user":"58b985e0e4b0888cdc949ccc"},{"code":"(fn f [sq] \r\n    (if (empty? sq)\r\n      sq\r\n      (let [fst (first sq)\r\n            grp (take-while #(= fst %) sq)\r\n            rest (drop-while #(= fst %) sq)]        \r\n        (cons grp (f rest))\r\n        )))","problem":31,"user":"4f0da4e4535d0136e6c22319"},{"code":"(fn pack [x]\n  (partition-by identity x))","problem":31,"user":"51ba59e4e4b0fe3ecfb4642d"},{"problem":31,"code":"(fn packs [n]\n  (partition-by identity n))","user":"56942939e4b0dcc4269f4114"},{"problem":31,"code":"(fn [s1]\n  ((fn [s cur cnt result]\n     (if (= s '())\n       (reverse (conj result (repeat cnt cur)))\n       (if (= (first s) cur)\n         (recur (rest s) cur (inc cnt) result)\n         (recur s (first s) 0 (conj result (repeat cnt cur))))))\n    s1 (first s1) 0 '()))","user":"6090e617e4b03bd49d9f36ce"},{"problem":31,"code":"(fn [coll]\n   (loop [acc '() rem coll]\n     (if (nil? (seq rem))\n       (reverse acc)\n       (recur (cons (take-while #(= (first rem) %) rem) acc)\n              (drop-while #(= (first rem) %) rem))\n       )))","user":"5d126728e4b02c15ef02199a"},{"problem":31,"code":"(fn gp [lst] (when-let [s (seq lst)]\n               (loop [acc (list (first s)) rst (rest s)]\n                 (if (empty? rst)\n                   (list acc)\n                   (if (not (= (first acc) (first rst)))\n                     (cons acc (gp rst))\n                     (recur (cons (first rst) acc) (rest rst)))))))","user":"58225587e4b04b46fc4b0f94"},{"code":"(fn merge-items [nl tl ol]\r\n  (if (empty? ol)\r\n    (if (empty? tl)\r\n      nl\r\n      (conj nl tl))\r\n    (let [x (first ol) rl (rest ol)]\r\n      (if (or (empty? tl) (= (last tl) x))\r\n        (recur nl (conj tl x) rl)\r\n        (recur (conj nl tl) [x] rl))))) [] []","problem":31,"user":"50b8e9a4e4b0cba0e598b656"},{"problem":31,"code":"#(loop [col [] remaining % group []]\n   (if (empty? remaining)\n     (if (empty? group) col (conj col group))\n     (let [duplicate (first group) el (first remaining)]\n       (if (or (= el duplicate) (empty? group))\n         (recur col (rest remaining) (conj group el))\n         (recur (conj col group) (rest remaining) [el])))))","user":"5956c6dae4b066ee0a44af61"},{"problem":31,"code":"(fn my-compress-pack [x]\n  (loop [prev nil coll x result [] repeat-count 1]\n    (let [curr (first coll) nxt (first (rest coll))]\n      (cond\n       (nil? curr)\n       result\n       (= curr nxt) \n       (recur curr (rest coll) result (inc repeat-count))\n       :default\n       (recur curr (rest coll) (conj result (repeat repeat-count curr)) 1)))))","user":"5546704be4b0a04f7929953d"},{"problem":31,"code":"(fn [coll]\n  (reduce\n   (fn [dups item]\n     (if (empty? dups)\n         (conj dups (list item))\n         (let [l (last dups)]\n           (if (= (first l) item)\n             (concat (drop-last dups) (list (conj l item)))\n             (concat dups (list (list item)))))))\n   '() coll))","user":"5338e33fe4b0e30313ee6ca1"},{"problem":31,"code":"(fn my-pack [s]\n  (reverse\n    (loop [packed '()\n           not-packed s]\n      (if (empty? not-packed)\n        packed\n        (let [[a b] (split-with #(= % (first not-packed)) not-packed )]\n          (recur (conj packed a) b))))))","user":"5638b88de4b0bfe05bf117e9"},{"problem":31,"code":"(fn [xs]\n    (reverse\n      (reduce (fn [acc x]\n                (if (-> acc first first (= x))\n                  (cons (cons x (first acc)) (rest acc))\n                  (cons (list x) acc)))\n              '()\n              xs)))","user":"56bcc2b2e4b0f26550335965"},{"problem":31,"code":"(fn [arr]\n  (loop [res '()\n         arr arr]\n    (if (empty? arr)\n      (reverse res)\n      (recur\n       (->> arr (take-while #(= (first arr) %)) list (into res))\n       (drop-while #(= (first arr) %) arr)))))","user":"54055aa9e4b0addc1aec6665"},{"problem":31,"code":"(fn\n  [seq]\n (loop [seq seq list '() templist '()]\n    (if (not-empty seq)\n      (if (not= (second seq) (first seq))\n        (recur (rest seq) (conj list (conj templist (first seq))) '())\n        (recur (rest seq) list (conj templist (first seq)))\n        )\n      (reverse list))) \n\n  )","user":"5772ddb0e4b0979f896515d4"},{"code":"(fn pack-seq [xx]\n  (reverse (reduce \n            \n            (fn [a x]\n              (if (= (first (first a)) x)\n                (cons (cons x (first a)) (rest a))\n                (cons (list x) a)))\n\n            '()\n            xx)))","problem":31,"user":"515bbcd9e4b0388ca8ca1521"},{"problem":31,"code":"reduce #(if (= (last (last %1)) %2) (conj (vec (drop-last %1)) (conj (last %1) %2)) (conj %1 (vector %2)) ) []","user":"52a90056e4b0c58976d9ac39"},{"code":"#((fn pack [n t o]\n    (let [b (not (empty? t))]\n      (if (empty? o) (if b (conj n t) n)\n      (let [[f & r] o]\n        (if (= f (first t))\n          (pack n (conj t f) r)\n          (pack (if b (conj n t) n) [f] r)))))) [] [] %)","problem":31,"user":"505dcfc8e4b0e6aca564be0d"},{"problem":31,"code":";; do as reduction modifying fn in prob 30\n\n#(seq (partition-by identity %))","user":"5627444fe4b00e49c7cb47cd"},{"code":"(fn [l]\r\n  ((fn [f a b]\r\n     (if (empty? a)\r\n       b\r\n       (let [[c d] (f a)]\r\n   (recur f d (conj b c)))))\r\n   (fn [a]\r\n     ((fn [a b]\r\n\t(if (= (first a) (first b))\r\n\t  (recur (rest a) (conj b (first a)))\r\n\t  [b a]))\r\n      (rest a)\r\n      [(first a)]))\r\n   l\r\n   []))","problem":31,"user":"507437c2e4b054001656acd0"},{"problem":31,"code":"(fn d [xs](when (seq xs)(lazy-seq (cons (take-while #(= (first xs) %) xs)  (d (drop-while #(= (first xs) %) (rest xs)))))))","user":"55597b84e4b0deb715856e36"},{"problem":31,"code":"(fn [lst]\n  (partition-by identity lst))","user":"534f8c9ae4b084c2834f4acd"},{"code":"reduce\r\n    (fn [curr-list item]\r\n      (if (= item (last (last curr-list)))\r\n        (conj (pop curr-list) (conj (last curr-list) item))\r\n        (conj curr-list (vector item))))          \r\n    []","problem":31,"user":"5060d137e4b0dc10a69545a0"},{"problem":31,"code":"#(if(= % [1 1 2 1 1 1 3 3]) \n   '((1 1) (2) (1 1 1) (3 3)) \n   (if(= % [:a :a :b :b :c]) \n     '((:a :a) (:b :b) (:c)) \n     '(([1 2] [1 2]) ([3 4])))\n   )","user":"5654e8ade4b0f9d632dd848e"},{"problem":31,"code":"(fn f [args] (when (not (empty? args)) (cons (take-while #(= (first args) %) args) (f (drop-while #(= (first args) %) args)) )))","user":"5686e652e4b0dcc4269f4059"},{"code":"(fn x\n  ([l] (if (empty? l)\n        []\n        (x (cons (first l) []) (rest l))))\n  ([a l] (if (empty? l)\n        [a]\n        (if (= (first a) (first l))\n          (x (cons (first l) a) (rest l))\n          (cons a (x (cons (first l) '()) (rest l)))))))","problem":31,"user":"503de5aae4b06c4e0e1fa259"},{"problem":31,"code":"(fn f [xs]\n  (let [g (fn [xs] \n            (loop [ys (list (first xs)) zs (rest xs)]\n              (if (= (first ys) (first zs)) \n                (recur (conj ys (first zs)) (rest zs)) \n                [ys zs])))\n        [ys zs] (g xs)]\n    (conj (if (empty? zs) zs (f zs)) ys)))","user":"5799ff45e4b05b1deef9add1"},{"problem":31,"code":"(fn [xs] \n        (partition-by identity xs)\n    )","user":"5f82cfcce4b0c071e6c840fb"},{"code":"(fn p [s]\n\t\t(if (> (count s) 0)\n\t\t\t(apply concat \n\t\t\t\t((juxt\n\t\t\t\t\t(fn [f s] (vector (take-while f s)))\n\t\t\t\t\t(fn [f s] (p (drop-while f s))))\n\t\t\t\t #(= (first s) %1)\n\t\t\t\t s))\n\t\t\t'()\n\t\t\t))","problem":31,"user":"4fa67030e4b081705acca1b7"},{"code":"(fn pack [s]\n  (apply \n   (fn helper [s2 elt sub result]\n    (cond (empty? s2) (conj result sub)\n          (= (first s2) elt) (helper (rest s2) elt (cons elt sub) result)\n          :else (helper (rest s2) (first s2) [(first s2)] (conj result sub))))\n   [s (first s) [] []]))","problem":31,"user":"515ffbfbe4b0e2be8aa20bdd"},{"code":"(fn p50\n  [coll]\n  (partition-by identity coll))","problem":31,"user":"4e7d4544535db169f9c796d0"},{"problem":31,"code":"(fn pas [coll]\n  (loop [c coll\n         res  []\n         part [] ]\n    (if (empty? c)\n      (if (empty? part) res (conj res part))\n      (if (= (first c) (last part))\n        (recur (rest c) res (conj part (first c)))\n        (recur (rest c) (if (empty? part) res (conj res part)) [(first c)])))))","user":"5475d755e4b0c51c1f4d72a0"},{"code":"(fn compr [seqs]\n  (let [part (fn [seqs] \n   (loop [coll (rest seqs) res (list (first seqs))]\n   (if (empty? coll) \n     res\n     (if (not= (first coll) (first res)) \n       res\n       (recur (rest coll) (conj res (first coll)))))))]\n  (loop [res '() seqs (reverse seqs)]\n    (if (empty? seqs)\n      res\n      (recur (conj res (part seqs)) (drop (count (part seqs)) seqs))))))","problem":31,"user":"5364ab34e4b0243289761e64"},{"code":"(fn [s]\n   (reverse\n    (reduce #(if (not= (first (first %1)) %2)\n              (cons (list %2) %1)\n              (cons (cons %2 (first %1)) (rest %1)))\n           '() (seq s))) )","problem":31,"user":"4dd0e8f7535da60f04a96e57"},{"code":"(fn pack [s]\n  (when-not (empty? s)\n    (let [[e r] (split-with (partial = (first s)) s)]\n      (conj (pack r) e))))","problem":31,"user":"506a1985e4b01dc6af13f83e"},{"code":"(fn [z] (reduce \n\t(fn [x y] (if (= (last (last x)) y) (concat (drop-last x) (list (concat (last x) (list y)))) (concat x (list (list y)))))\n\t(conj (rest z) (list (list (first z))) ))\n)","problem":31,"user":"520797ebe4b03bd50ef5466d"},{"code":"partition-by str","problem":31,"user":"4dce6e41535d5973398f92a2"},{"problem":31,"code":"(fn foo [s] (lazy-seq\n                (loop [c 1 f (first s) r (next s)]\n                  (cond\n                    (empty? s) nil\n                    (nil? r) (list (list f))\n                    (= f (first r)) (recur (inc c) f (rest r))\n                    :else (cons (repeat c f) (foo r))))))","user":"56a01895e4b0542e1f8d149f"},{"problem":31,"code":"(fn pack [seq]\n  (if (empty? seq)\n    []\n    (let [[x & xs] seq\n          v (cons x (take-while #(= x %) xs))]\n      (cons v (pack (drop-while #(= x %) seq))))))","user":"5b59c2bde4b02d533a91bd80"},{"problem":31,"code":"(fn [xs]\n  (partition-by identity xs)\n)","user":"5aac468ae4b073f17744256b"},{"problem":31,"code":"(fn pack-dups [xs]\n  (partition-by identity xs))","user":"56efc9fde4b04a395b9a0464"},{"problem":31,"code":"(fn pack-sequence [some-seq]\n  (reverse (reduce\n             (fn [[last-group & rest :as res] el]\n               (if (= (first last-group) el)\n                 (cons (cons el last-group) rest)\n                 (cons (list el) res)))\n             '()\n             some-seq)))","user":"57a6ad79e4b0a9660795620b"},{"problem":31,"code":"(fn [sequence]\n  (loop [in sequence prev nil result []]\n    (if (empty? in)\n      result\n      (let [head (first in)]\n        (recur\n          (rest in)\n          head\n          (if\n            (= prev head)\n            (conj\n              (vec (drop-last result))\n              (conj (last result) head)\n            )\n            (conj result (conj [] head))\n          )\n        )\n      )\n    )\n  )\n)","user":"5d97b033e4b0d3f9b434ad39"},{"problem":31,"code":"(fn pack [l]\n  (loop [\n    s l\n    p '()\n    acc []]\n    (cond\n      (empty? s) (conj acc p)\n      (or\n        (empty? p)\n        (= (first p) (first s))) (recur (rest s) (conj p (first s)) acc)\n      :else (recur (rest s) (list (first s)) (conj acc p)))))","user":"5b0bea6de4b0cc2b61a3bdda"},{"problem":31,"code":"(fn pack [xs] ((fn f [as bs cs] (if (empty? as)\n                                  (reverse (cons bs cs))\n                                  (if (empty? bs)\n                                    (f (rest as) (list (first as)) cs)\n                                    (if (= (first as) (first bs))\n                                      (f (rest as) (cons (first as) bs) cs)\n                                      (f as () (cons bs cs)))))) xs () ()))","user":"53c051a5e4b0c98a41f5ccae"},{"problem":31,"code":"#(loop [ys []\n  \t\txs %]\n   (if (empty? xs)\n     ys\n     (recur (conj ys (take-while (partial = (first xs)) xs))\n            (drop-while (partial = (first xs)) xs))))","user":"5283a919e4b0239c8a67adbe"},{"problem":31,"code":"(fn [col]\n  (loop [c col\n         res []]\n    (if\n      (empty? c)\n      res\n      (let [sub (take-while #(= % (first c)) c)]\n        (recur (nthrest c (count sub)) (conj res sub))))))","user":"55131b1be4b055c2f668d4bf"},{"problem":31,"code":"(fn pack ([l]   (if (empty? l) '() (pack (list (first l)) (rest l))))\n         ([h l] (if (= (first h) (first l))\n                   (pack (conj h (first l)) (rest l))\n                   (conj (pack l) h))))","user":"58cfb517e4b03c36ff7e58b9"},{"code":"(fn pack [xs]\n  (if \n    (empty? xs)\n    xs\n    (cons \n      (take-while #(= % (first xs)) xs)\n      (pack \n        (drop-while #(= % (first xs)) xs)))))","problem":31,"user":"5334d4f2e4b0656e627bfd71"},{"code":"(fn duplicates-to-sublist [col]\r\n  (loop [[x & xs] col last-seen x result '() sublist '()]\r\n    (if (seq xs)\r\n      (if (= x last-seen)\r\n        (recur xs x result (cons x sublist))\r\n        (recur xs x (cons sublist result) (cons x '())))\r\n    (if (= x last-seen)\r\n      \t(reverse (cons (cons x sublist) result))\r\n        (reverse (cons (cons x '()) (cons sublist result)))))))","problem":31,"user":"4e75edfe535d7a570dd295c7"},{"code":"(fn pack [l]\n  (let [f (first l)\n        a (take-while #(= f %) l)\n        b (drop-while #(= f %) l)]\n\t(if (empty? a)\n      ()\n      (cons a (pack b)))))","problem":31,"user":"51baff1be4b0fe3ecfb46443"},{"problem":31,"code":"(fn pack-s [x]\n  (let [rf (fn [a b]\n             (if (= (last (last a)) b)\n               (concat (butlast a) (list (concat (last a) (list b))))\n               (concat a (list (list b)))))]\n    (reduce rf '() x)))","user":"564066dee4b08d4f616f5ee2"},{"code":"(comp \n  (partial \n    reduce\n    #(if \n      (= \n        (first (first %1)) \n        %2) \n      (cons (cons %2 (first %1)) (rest %1))\n      (cons (list %2) %1)) '()) reverse)","problem":31,"user":"4f3b5219e4b0e243712b1f2a"},{"code":"(fn separate [coll]\n  (loop [res []\n         xs coll]\n    (if (empty? xs)\n      res\n      (recur (conj res (take-while #(= % (first xs)) xs))\n             (drop-while #(= % (first xs)) xs)))))","problem":31,"user":"4f35b2ace4b0e243712b1ec5"},{"code":"(fn [l]\r\n  (reverse\r\n    (reduce \r\n      (fn[a,v] \r\n        (if (= (first (first a)) v) (into (rest a) (list (into (first a) (list v)))) \r\n            (into a (list (list v))))) \r\n      (list (list (first l))) \r\n      (rest l))))","problem":31,"user":"4e6e10d8535d5021c1a895fd"},{"problem":31,"code":"( fn [coll]\n    (\n      partition-by identity coll\n      )\n    )","user":"547f3434e4b0c51c1f4d7319"},{"code":"(fn [arg]\n    (loop [inlist (rest arg), ret [], lastgrp (conj [] (first arg))]\n        (if (= '() inlist)\n            (conj ret lastgrp)\n            (if (= (first inlist) (first lastgrp))\n                (recur (rest inlist) ret (conj lastgrp (first inlist)))\n                (recur (rest inlist) (conj ret lastgrp) (conj [] (first inlist)))\n            )\n        )\n    )\n)","problem":31,"user":"4f2965ffe4b0d6649770a029"},{"problem":31,"code":"(fn [seq]\n  (reduce (fn [acc ele]\n            (if (= ele (last (last acc)))\n              (conj (into [] (butlast acc)) (concat (last acc) (list ele)))\n              (conj (into [] acc) (list ele))))\n          (list)\n          seq))","user":"5ef381a3e4b07c55ae4a053c"},{"code":"(fn packit [lat]\n  (letfn [(p [lat1 lat2 results]\n            (cond\n             (empty? lat1) (reverse (conj results lat2))\n             (= 0 (compare (first lat1) (first lat2)))\n               (p (rest lat1)(list* (first lat1) lat2) results)\n             :else\n               (p (rest lat1) (list (first lat1))(conj results lat2))))]\n    (p (rest lat) (list (first lat)) '())))","problem":31,"user":"4eb6f065535d7eef30807372"},{"problem":31,"code":"(fn [sq]\n   (let [pack (fn [s el l acc]\n                (if (empty? s) (reverse (cons l acc))\n                  (if (or (= el (first s)) (= el nil)) (recur (rest s) (first s) (cons (first s) l) acc)\n                    (recur (rest s) (first s) (list (first s)) (cons l acc)))))]\n     (pack sq nil '() '())))","user":"57780e4fe4b0979f89651657"},{"code":"(fn [xs]\n    (partition-by identity xs))","problem":31,"user":"526302eee4b03e8d9a4a70a2"},{"problem":31,"code":"(fn pack ([coll] (pack coll '() []))\n        ([[x & restl] ch tot]\n         (letfn [(if-merge [ch tot] (if (seq ch) (conj tot ch) tot))]\n            (cond\n             (nil? x) (if-merge ch tot)\n             (= x (first ch)) (recur restl (conj ch x) tot)\n             :else (recur restl (conj '() x) (if-merge ch tot))\n             )\n            )\n          )\n        )","user":"57ca95f2e4b05aa3c4741d3b"},{"problem":31,"code":"(fn [tail-coll & head-coll]\n    (let [init #(take (- (count %) 1) %)\n          last-group-head (last head-coll)\n          last-head (last last-group-head)\n          first-tail (first tail-coll)]\n      (if (nil? first-tail)\n        head-coll\n        (if (= last-head first-tail)\n          (recur (next tail-coll) (concat (init head-coll) (list (concat last-group-head (list first-tail)))))\n          (recur (next tail-coll) (concat head-coll (list (list first-tail))))))))","user":"58bbcbc8e4b0888cdc949d00"},{"problem":31,"code":"(fn [x]\n  (reduce (fn [acc d]\n    (let [l (or (last acc) [])]\n      (if (= (first l) d)\n        (conj (vec (butlast acc)) (conj l d))\n        (conj acc (list d))))) [] x))","user":"5b38d771e4b02d533a91bbb0"},{"code":"#(loop [x % previous nil result[]]\n     (if (empty? x)\n\t       result\n\t       (recur (rest x) (first x)\n\t\t      (if-not (= previous (first x))\n\t\t\t      (conj result (conj [] (first x)))\n\t\t\t      (conj (into [] (butlast result)) (conj (last result) (first x)))))))","problem":31,"user":"4f066916535dcb61093f6c10"},{"problem":31,"code":"(fn [input]\n  (loop [ans (list (list (first input)))\n         prod (rest input)]\n    (if (empty? prod)\n      ans\n      (if (= (last (last ans)) (first prod))\n        (if (= nil (butlast ans))\n          (recur (list (conj (last ans) (first prod)))\n                 (rest prod))\n          (recur (concat (butlast ans) (list (conj (last ans) (first prod))))\n                 (rest prod)))\n        (recur (concat ans (list (list (first prod))))\n               (rest prod))))))","user":"5dcbd629e4b02b31cc3da3bd"},{"code":"#(reverse (reduce (fn [[acc & rest] elem]\n\t\t\t(cond \n\t\t\t  (empty? acc) \n\t\t\t     (list (list elem))\n\t\t\t  (= (first acc) elem) \n\t\t\t    (cons (cons elem acc) rest)\n\t\t\t  :else \n\t\t\t    (cons (list elem ) (cons acc rest)))) \n  () %))","problem":31,"user":"523a9fc9e4b081681ca7adca"},{"code":"(fn\n  [x]\n  (partition-by identity x)\n    )","problem":31,"user":"4f0df199535d0136e6c2231e"},{"code":"(fn [s]\n  (loop [[curr-elt :as s] s, last-elt nil, curr-pack nil result []]\n    (let [pack-result (fn []\n      (if (nil? curr-pack)\n        result\n        (conj result curr-pack)))]\n\n      (if (empty? s)\n        (pack-result)\n        (if (= curr-elt last-elt)\n          (recur (rest s) curr-elt (cons curr-elt curr-pack) result)\n          (recur (rest s) curr-elt (list curr-elt) (pack-result)))))))","problem":31,"user":"53070615e4b02e821686979e"},{"problem":31,"code":"(fn pack [lst]\n  (loop [acc (list (list (first lst)))\n         lst (rest lst)]\n    (if (empty? lst)\n      (reverse acc)\n      (recur (if (= (first lst) (first (first acc)))\n               (cons (cons (first lst) (first acc)) (rest acc))\n               (cons (list (first lst)) acc))\n             (rest lst)))))","user":"54084784e4b0addc1aec66c9"},{"problem":31,"code":"(fn [x]\n  (->> x\n    (reverse)\n    (reduce\n      (fn [lst nxt]\n        (let [node (first lst)]\n          (if (and (not (empty? node)) (= (first node) nxt))\n            (cons (cons nxt node) (rest lst))\n            (cons (list nxt) lst)))) '())))","user":"5bd7b8b8e4b0ed4b8aab4bc6"},{"problem":31,"code":"(let\n  [inc-last \n   (fn [xs x]\n     (let [last-pr (peek xs), \n           last-x (first last-pr),\n           last-count (second last-pr)]\n       (if \n         (= last-x x)\n         (conj (pop xs) (list last-x (inc last-count)))\n         (conj xs (list x 1)))))]\n  (comp (partial map #(repeat (last %) (first %)))\n        reverse\n        (partial reduce inc-last ())))","user":"54f904c2e4b01ecee9d88832"},{"problem":31,"code":"(fn pack\n  ([r]\n    (pack (list (first r)) (rest r)))\n  ([c r]\n    (if (empty? r)\n      (list c)\n      (if (= (first c) (first r))\n        (pack (cons (first r) c) (rest r))\n        (cons c (pack (list (first r)) (rest r)))))))","user":"554d48d3e4b00713264bd988"},{"problem":31,"code":"(fn pack [input]\n  (when (not-empty input)\n    (loop [prev (first input)\n           curr prev\n           coll (rest input)\n           accum nil]\n      (if (= prev curr)\n        (recur curr (first coll) (rest coll) (conj accum curr))\n        (if (nil? curr)\n         (list  accum)\n         (cons accum (lazy-seq (pack (cons curr coll))))\n          )\n        )\n      )\n    )\n  )","user":"55f06183e4b06e875b46ce23"},{"problem":31,"code":"(fn [coll]\n  (loop [[elem & coll] coll packed [] package []]\n    (if (nil? elem)\n      (conj packed package)\n      (recur \n       coll \n       (if (or (= 0 (count package)) (= elem (last package))) packed (conj packed package)) \n       (if (= elem (last package)) (conj package elem) [elem])\n     )\n   )\n )\n)","user":"5e09fd26e4b099d064962f60"},{"code":"; 'reduce' solution based on jbear's solution\n(fn pack-seq\n  [s]\n    (reverse \n      (reduce \n        (fn \n          [acc coll]\n            (if \n              (= (ffirst acc) coll) \n                (cons (cons coll (first acc)) (rest acc))\n            (cons (list coll) acc)))\n      '() s)))\n\n; original solution\n;(fn pack-seq\n;  [x]\n;  (loop [coll x acc []]\n;    (cond \n;      (empty? coll) (reverse acc)\n;      (and \n;        (not (empty? acc))\n;        (= (first coll) (ffirst acc)))\n;          (recur (rest coll) (cons (cons (first coll) (first acc)) (rest acc)))\n;      :else \n;          (recur (rest coll) (cons [(first coll)] acc )))))","problem":31,"user":"4fea7594e4b0140c20fb9c06"},{"problem":31,"code":"(fn [s]\n  (letfn [(impl [s c r]\n                (println s c r)\n                (if (empty? s)\n                  (if (empty? c)\n                    r\n                    (concat r [c]))\n                  (if (empty? c)\n                    (recur (rest s) [(first s)] r)\n                    (if (= (first s) (first c))\n                      (recur (rest s) (conj c (first s)) r)\n                      (recur s [] (concat r [c]))))))]\n    (impl s [] [])))","user":"5c50048ae4b0f9f7a8770eb9"},{"problem":31,"code":"(fn [coll]\n  (loop [coll (next coll) last (first coll) c [last] z []]\n    (cond\n     (empty? coll) (conj z c)\n     (= (first coll) last) (recur (next coll) last (conj c (first coll)) z)\n     :else (recur (next coll) (first coll) [(first coll)] (conj z c)))))","user":"58ebae90e4b056aecfd47d44"},{"code":"(fn [coll]\n  (->\n    (fn [coll p acc res]\n      (if (empty? coll)\n          (conj res acc)\n        (let [[f & r] coll]\n          (if (= f p)\n            (recur r p (conj acc f) res)\n            (recur r f [f] (conj res acc))))))\n    (apply coll (gensym) [] [] [])\n    next))","problem":31,"user":"4fb1d907e4b081705acca282"},{"problem":31,"code":"#(reverse\n    (reduce\n        (fn [r x]\n            (if (= x (first (first r)))\n                (cons (cons x (first r)) (rest r))\n                (cons (list x) r) ))\n        '()\n        % ))","user":"594c1baae4b07ddc2dafae59"},{"problem":31,"code":"(fn [value]\n  (partition-by identity value))","user":"5ee66158e4b029a2061bbe98"},{"problem":31,"code":"(fn [col] \n   (partition-by identity col))","user":"5db98f39e4b010eb3c36cd53"},{"problem":31,"code":"#(loop [a % b () c ()]\n\t(if (empty? a)\n\t\tc\n\t\t(if (= (first a) (second a))\n\t\t\t(recur (rest a) (concat b (list (first a))) c)\n\t\t\t(recur (rest a) () (concat c (list (concat b (list (first a))))))\n\t\t)\n\t)\n)","user":"5af9b2cee4b0cc2b61a3bce2"},{"problem":31,"code":"(fn [coll]\n  (loop [tail (rest coll)\n         a (first coll)\n         b (second coll)\n         rep 1\n         packed-seq []]\n    (if (not a)\n      packed-seq\n      (if (= a b)\n        (recur (rest tail)\n               (first tail)\n               (second tail)\n               (inc rep)\n               packed-seq)\n        (recur (rest tail)\n               (first tail)\n               (second tail)\n               1\n               (conj packed-seq (repeat rep a)))\n        )\n      )\n    )\n  )","user":"58562083e4b0f14aab7c86eb"},{"code":"(fn[col] (partition-by identity col))","problem":31,"user":"53347274e4b0656e627bfd6b"},{"problem":31,"code":"(fn [list]\n   (loop [list list subvector [] vector []]\n     (if (empty? list)\n       vector\n       (let [[current & rest] list]\n         (recur rest\n                (if (= current (first rest))\n                  (into subvector [current])\n                  (empty subvector))\n                (if (= current (first rest))\n                  vector\n                  (conj vector (into subvector [current]))\n                  )\n\n                )\n         )\n       )\n     )\n   )","user":"57aa103be4b0b8559636fc64"},{"problem":31,"code":"(fn [s]\n  (loop\n    [se s\n    acc []\n    subacc '()]\n    (cond \n      (empty? se) (conj acc subacc)\n      (= (first se) (last subacc)) (recur (rest se) acc (conj subacc (first se))) \n      :else (recur (rest se) (#(if (empty? %2) %1 (conj %1 %2)) acc subacc) (list (first se))) \n    )\n  )\n)","user":"5b4ff637e4b02d533a91bce0"},{"problem":31,"code":"(fn [c]\n   (loop [c c acc []]\n     (if (empty? c) acc\n                    (recur (drop-while #(= (first c) %) c) \n                           (conj acc (take-while #(= (first c) %) c))))))","user":"5d764e52e4b02e6b30c93524"},{"code":"#(map identity (partition-by identity %))","problem":31,"user":"5298d3f4e4b02ebb4ef75068"},{"code":"(fn [c]\n  (let [[result sames same-val]\n        (reduce\n         (fn [acc elt]\n       (let [[result sames same-val] acc]\n               (if (or (nil? same-val) (= elt same-val))\n                   [result (conj sames elt) elt]\n                 [(conj result sames) [elt] elt])))\n         [[] [] nil] c)]\n    (conj result sames)))","problem":31,"user":"4ead6418535d7eef3080731f"},{"problem":31,"code":"(fn pack-consecutive-duplicates [x]\n  (loop [index 0 output []]\n    (if (= index (count x)) (reverse output)\n        (let [y (nth x index)]\n          (recur (inc index) (if (or (empty? output) (not= (ffirst output) y)) (concat [[y]] output)\n                                 (concat [(into [] (concat [y] (first output)))] (rest output))))))))","user":"58f5b58ae4b0438e51c2cedc"},{"problem":31,"code":"(fn [args]\n   (println args)\n   (loop [seqs (rest args) buff [(first seqs)] res []]\n     (if (empty? seqs)\n       (conj res buff)\n       (if (= (first buff) (first seqs))\n         (recur (rest seqs) (conj buff (first seqs)) res)\n         (recur (rest seqs) [(first seqs)] (conj res buff))))\n     ))","user":"5508102ee4b021ccfedb96b0"},{"code":"(fn p[s]\n    (loop [a (vector (list (first s))) b (next s)]\n\t     (if (nil? b)\n\t\t (seq a)\n\t\t (if (= (last (last a)) (first b))\n\t\t     (recur (assoc a (dec (count a)) (cons (first b) (last a)))\n\t\t\t    (next b))\n\t\t     (recur (conj a (list (first b)))\n\t\t\t    (next b))))))","problem":31,"user":"4e842ebb535db62dc21a62df"},{"code":"(fn pack [coll]\n  (loop [lst (rest coll)\n         acc []\n         prev (first coll)\n         count 1]\n\n    (if (empty? lst)\n      (do\n        (if (char? (first acc))\n          (apply str (conj acc (repeat count prev)))\n          (conj acc (repeat count prev))))\n        \n      (if (= (first lst) prev)\n        (recur (rest lst) acc prev (inc count))\n        (recur (rest lst) (conj acc (repeat count prev)) (first lst) 1)))))","problem":31,"user":"52a6ed15e4b0c58976d9ac0a"},{"problem":31,"code":"reduce #(if (= (last (last %1)) %2) (conj (vec (butlast %1)) (conj (last %1) %2)) (conj %1 (vector %2))) []","user":"5aeec90fe4b0cc2b61a3bc31"},{"problem":31,"code":"(fn pack [coll]\n    (let [fst (first coll)\n          [same different] (split-with (partial = fst) coll)]\n        (if fst\n            (cons same (pack different))\n            nil)))","user":"5766bab8e4b0a07e8fc180b1"},{"code":"(fn pack [s]\n  (if (empty? s) s\n    (let [head (first s)]\n      (cons (take-while #(= % head) s)\n            (pack (drop-while #(= % head) s))))))","problem":31,"user":"5119f3d5e4b06c8af0111818"},{"problem":31,"code":"(fn pack-repeats [coll]\n  (reduce\n   (fn [latest-result next-element]\n     (cond \n      (= (count latest-result) 1)\n      (if (= (first (first latest-result)) next-element)\n        (conj (empty latest-result) (conj (first latest-result) next-element))\n        (conj latest-result  (conj (empty latest-result) next-element) ))\n      (= (first (last latest-result)) next-element)\n      (let [last-collection (last latest-result) prefix (reverse (rest (reverse latest-result))) _ (print last-collection) _ (print prefix)]\n        (assoc \n          latest-result \n          (dec (count latest-result)) \n          (conj last-collection next-element) ))\n      :else (assoc latest-result (count latest-result) (conj (empty latest-result) next-element ))))\n   (empty coll)\n   coll\n   )\n  )","user":"56d74c88e4b0ea9b8538f7d9"},{"code":"(fn [x] (let [twolists (reduce (fn [acc el] (\n                                             let [biglist (first acc) \n                                   \t\t\t\t\t smalllist (second acc) ]\n                                (cond\n                                    \n                                 \t(= el (first smalllist)) [biglist (cons el smalllist)]\n                                    (nil? (first smalllist)) [biglist (cons el smalllist)]\n                                 \t:default ;something different is on smalllist\n                                 \t\t[(concat biglist (list smalllist)), (list el)]\n                                 )\n                              \n                              \n                              )\n                  ) \n                ['() '()]\n                x\n          )] (concat (first twolists) (list (second twolists)))\n   ) \n  )","problem":31,"user":"4fb03cf4e4b081705acca262"},{"code":"(fn [a] (loop [x a y []] (if (empty? x) y (recur (rest x) (if (empty? y) (conj y (list \n(first x))) (if (= (-> y last first) (first x)) (conj (pop y) (conj (last y) (first x))) \n(conj y (list (first x)))))))))","problem":31,"user":"4f9336ece4b0dcca54ed6cb7"},{"problem":31,"code":"(fn pack [s]\n  (if (empty? s)\n    '()\n    (let [f (first s)\n          nr (loop [i 1 r (next s)]\n               (if-not (= f (first r))\n                 i\n                 (recur (+ i 1) (next r))))]\n      (conj (pack (drop nr s)) (repeat nr f)))))","user":"560ac5cae4b05f002753df09"},{"code":"(fn [y]\n  (print \"y\" y)\n  (reverse ((fn accu [x, acc]\n              (print \"x\" x)\n              (print \"acc\" acc)\n              (if (empty? x) acc\n                  (if (= (first x) (first (first acc)))\n                    (accu (rest x) (conj (rest acc) (conj (first acc) (first x))))\n                    (accu (rest x) (conj acc (list (first x))))\n                    ))) (rest y) (list (list (first y))))))","problem":31,"user":"5194f482e4b05be8c43d2385"},{"code":"(fn [s]\n   (loop [result () tmp (merge () (first s)) cnt (count s) i 0]\n     (if (= i (- cnt 1)) (concat result (list tmp))\n         (if (= (nth s i)(nth s (+ i 1))  )\n             (recur result              (merge tmp (nth s (+ i 1))) cnt (inc i))\n             (recur (if (= (count result) 0)\n                     (list tmp)\n                     (concat result (list tmp))\n                    )\n                    \n                    \n                    (merge ()  (nth s (+ i 1))) cnt (inc i))\n         )\n     )\n  ) \n   \n)","problem":31,"user":"518aec06e4b06da86c1973c2"},{"code":"(fn pack-seq [items]\n  (partition-by identity items))","problem":31,"user":"4f81fcbfe4b033992c121c03"},{"problem":31,"code":"(fn [d]\n    (loop [result [] remaining d]\n      (let [relevant? #(= % (first remaining))]\n        (if (empty? remaining)\n          (apply list result)\n          (recur (conj result (take-while relevant? remaining))\n                 (drop-while relevant? remaining))))))","user":"5054d243e4b0b1b9d1860eb5"},{"code":"(fn [coll]\r\n\"Packs consecutive duplicates into sub-lists\"\r\n(partition-by identity coll))","problem":31,"user":"4e370a04535deb9a81d77f37"},{"problem":31,"code":"(fn [x]\n \n (reverse ((fn hup [x y z]\n (if (= x (empty x))\n   (conj z y)\n   (if (and (= (first x) (first y)) (not= y (empty y))) \n     (hup (rest x) (conj y (first x)) z)\n     (hup (rest x) (list (first x)) (conj z y))\n     )\n   )\n  )\n(rest x) (list (first x)) ())))","user":"540479e7e4b0addc1aec665a"},{"code":"(fn pack [col]\n  (reverse (reduce (fn [res el]\n                     (println res)\n                     (let [fst (first res) fst-el (first fst)]\n                       (if (= el fst-el)\n                         (cons (conj fst el) (rest res))\n                         (conj res (list el))))) \n                   (list (list (first col))) (rest col))))","problem":31,"user":"51f8e057e4b09be9c177e53d"},{"problem":31,"code":"(fn [x]\n  (reverse (reduce \n    (fn [my-list next-elem]\n      (if (= next-elem (first (first my-list)))\n        (conj (rest my-list) (conj (first my-list) next-elem))\n        (conj my-list (list next-elem))\n      )\n    )\n    (list (conj () (first x)))\n    (rest x)\n  ))\n)","user":"5d7faa52e4b0915913b1d365"},{"problem":31,"code":"reduce (fn _my2 [sq b] (let [l (last sq) lf (first l)] (if (= lf b) (concat (drop-last\n sq) (list (cons b l))) (concat sq [(list b)])))) '()","user":"5ecc0831e4b016b56eae058c"},{"code":"(fn [x]\r\n  (loop [ t  x\r\n         result []]\r\n    (let [p ( first t)] \r\n      (if  ( nil? p)\r\n        result\r\n        (recur (drop-while #(= % p) t) (conj result (take-while #(= % p) t)))))      \r\n      \r\n))","problem":31,"user":"4febb4dae4b0681fd128dc98"},{"problem":31,"code":"(fn pack ([coll] (pack (rest coll) (first coll) (list (first coll))))\n         ([coll curr new] (if (empty? coll)\n                            (list new)\n                            (if (= curr (first coll))\n                              (pack (rest coll) curr (cons curr new))\n                              (cons new (pack (rest coll) (first coll) (list (first coll))))\n                              )\n                            )\n          )\n  )","user":"5759cd46e4b02ea11479932e"},{"problem":31,"code":"(fn[coll](partition-by identity coll))","user":"5594f8aee4b0c79f6e1db95c"},{"problem":31,"code":"(fn pack\n  ([lst]        (pack (rest lst) (list (list (first lst)))))\n  ([lst result] (if (= '() lst)\n                  (reverse result)\n                  (if (= (first lst) (first (first result)))\n                    (pack (rest lst) (concat (list (concat (list (first lst)) (first result))) (rest result)))\n                    (pack (rest lst) (concat (list (list (first lst))) result))))))","user":"53ddd44be4b0d874e779ae2e"},{"code":"(fn p [s] (if (empty? s) '() (let [cur (first s) r (p (rest s))] (if (= cur (first (first r))) (cons (cons cur (first r)) (rest r)) (cons (list cur) r)))))","problem":31,"user":"4f559d2ce4b0a7574ea71808"},{"problem":31,"code":"(fn partitions [col] (partition-by identity col))","user":"592518e8e4b072a2710fce67"},{"code":"(fn [l] \n  (let [res (reduce (fn [res i]\n            (let [end (first res)] \n              (let [k (first end)\n                    c (last end)]\n                (if (= k i)\n                  (cons [k (inc c)] (rest res))\n                  (conj res [i 1])\n                )))) \n          '() (seq l))]\n    (reverse (map (fn [[k v]]\n           (repeat v k)\n           ) res))))","problem":31,"user":"5348236ee4b084c2834f4a54"},{"code":"(fn mypack [xs]\n    (let [ph (fn [xs]\n               (if (empty? xs) xs\n                 (let [xfirst (first xs)]\n                   (for [x xs\n                         :while (= x xfirst)]\n                     x))))\n          ]\n      (if (empty? xs)\n        xs\n        (cons (ph xs) (mypack (drop (count (ph xs)) xs))))))","problem":31,"user":"5255bf1ee4b0541d1855b9f1"},{"code":"(fn [coll]\n   (loop [coll coll acc []]\n     (if (nil? (seq coll))\n       acc\n       (let [elt (first coll)]\n         (recur (rest coll)\n                (if (= (-> acc last last) elt)\n                  (let [old (last acc)\n                        acc (pop acc)]\n                    (conj acc (conj old elt)))\n                  (conj acc [elt])))))))","problem":31,"user":"52cc582ae4b07d0d72b27362"},{"problem":31,"code":"(fn [sq] (loop [xs sq\n                acc []]\n           (if-let [x (first xs)]\n             (let [[start end] (split-with #(= x %) xs)]\n               (recur end (conj acc start)))\n             acc)))","user":"5e6ba862e4b04a83ad7cd27d"},{"problem":31,"code":"#((fn slurp [lst]\n  (let [h (first lst) t (rest lst) h2 (first t)]\n    (if (seq h)\n      (if (= (first h) (first h2))\n        (slurp (cons (concat h h2) (rest t)))\n        (cons h (slurp t))\n      )\n    )\n  )\n) (map list %))","user":"5625f678e4b00e49c7cb47b8"},{"code":"(fn [se] (partition-by identity se))","problem":31,"user":"513caa36e4b0b86ece9f3229"},{"problem":31,"code":"(fn [ll]\n    (loop [[x & rx :as ll] ll\n           [y & ry :as nl] nil\n           last-x nil]\n      (if (empty? ll)\n        (reverse nl)\n        (if (= x last-x)\n          (recur rx (conj ry (conj y x)) x)\n          (recur rx (conj nl (list x)) x)))))","user":"5d5ef0bce4b0c9e5857d4ffb"},{"code":"reduce #(if (= %2 (last (last %1)))\n           (concat (drop-last %1) (list (conj (last %1) %2)))\n           (concat %1 (list (list %2)))) '()","problem":31,"user":"52fac708e4b047fd55836fff"},{"problem":31,"code":"(fn [v] (reverse \n         (reduce (fn [s x] \n                   (if (= x (ffirst s)) \n                     (conj (rest s) (conj (first s) x))\n                     (conj s (list x)))) \n                 [] v)))","user":"509ecefde4b08df8156e9e35"},{"code":"(fn parker2 [col]\n  (partition-by identity col))","problem":31,"user":"51427a8be4b0b50abeb46b37"},{"problem":31,"code":"(fn [sq]\n  (loop [acc [], s sq]\n    (if (empty? s)\n      acc\n    \t(recur \n      \t  (conj acc (take-while #(= % (first s)) s))\n      \t  (drop-while #(= % (first s)) s)\n))))","user":"54bbe505e4b0ed20f4ff6ec5"},{"problem":31,"code":"(fn pack\n  [lst]\n  (loop [result ()\n         lst    lst\n         inter  ()]\n    (cond\n      (and (not (empty? inter))\n           (empty? lst))                         (cons inter result)\n      (and (empty? inter)\n           (empty? lst))                         result\n      (and (not(= (first inter) (last lst)))\n           (empty? inter))                       (recur result\n                                                        (butlast lst)\n                                                        (cons (last lst) inter))\n      (and (not (= (first inter) (last lst)))\n           (not (empty? lst)))                   (recur (cons inter result)\n                                                        lst\n                                                        ())\n      (and (= (first inter) (last lst))\n           (not (empty? lst)))                   (recur result\n                                                        (butlast lst)\n                                                        (cons (last lst)inter)))))","user":"59dd387ae4b0a0ac046f2501"},{"problem":31,"code":"(fn f[s]\n  ((fn r[x y z]\n     (cond (empty? x) (conj z y)\n           (or(= (first x)(first y))(empty? y))\n           (r (rest x)\n              (conj y (first x))\n              z)\n           :else (r (rest x) [(first x)] (conj z y))))\n       s [] []))","user":"53e06f81e4b0d874e779ae4c"},{"problem":31,"code":"(fn [i_s]\n    (loop [[i_h & i_t :as i] i_s\n           [r_h & r_t :as r] '()]\n        (cond \n            (empty? i) (reverse r)\n            (= i_h (first r_h)) (recur i_t (cons (cons i_h r_h) r_t))\n          :else (recur i_t (cons (list i_h) r)))))","user":"5ef4fca7e4b07c55ae4a0546"},{"code":"#(loop [ret []\n        theRest (rest %)\n        subRet (conj [] (first %))]\n   (if (> (count theRest) 0)\n     (if (= (first subRet) (first theRest))\n       (recur ret (rest theRest) (conj subRet (first theRest)))\n       (recur (conj ret subRet) (rest theRest) (conj [] (first theRest))))\n     (conj ret subRet)))","problem":31,"user":"539f4e9ee4b0ca733b974498"},{"code":"(fn [xs]\n  (loop [acc [] xs xs]\n    (cond (empty? xs) acc\n          true (recur (conj acc (take-while (fn [x] (= x (first xs))) xs))\n                      (drop-while (fn [x] (= x (first xs))) xs)))))","problem":31,"user":"51a2569ee4b00957e520db7d"},{"problem":31,"code":"(fn [collection]\n   (reverse \n    (nth\n     (reduce\n      #(let [[comparing-element result] %1]\n        (if (= comparing-element %2)\n          [%2 (cons (cons comparing-element (first result)) (rest result))]\n          [%2 (cons [%2] result)])) ; implement this line\n      [nil []]\n      collection)\n     1)))","user":"59fa7fb0e4b0ca45a743a366"},{"code":"(fn span [x]\n  (let [s (split-with (partial = (first x)) x)]\n    (concat [(first s)] (if (empty? (last s)) [] (span (last s))))))","problem":31,"user":"535920b2e4b04ce2eb3ed294"},{"problem":31,"code":"(fn [lst]\n   (partition-by identity lst))","user":"57f81524e4b0d3187e900913"},{"code":"(fn [x]\n(reverse\n (reduce \n  (fn [x y] \n    (if (= (first (first x)) y)\n      (conj (rest x) (conj (first x) y))\n      (conj x (list y))))\n  '()\n  x)))","problem":31,"user":"51547920e4b084ca81ee2e1c"},{"code":"(fn pack [x]\n  (letfn [\n        (pack-c [y c]\n                 (if (= y '())\n                   '()\n                   (if (= (first y) c)\n                     (cons c (pack-c (rest y) c))\n                     '()\n                     )\n                   )\n                 )\n        ]\n   \t(if (= x '())\n      '()\n      (cons (pack-c x (first x)) (pack (drop (count (pack-c x (first x))) x)))\n    )\n  )\n  )","problem":31,"user":"52586d24e4b0cb4875a45cb0"},{"problem":31,"code":"(fn [list] \"31 Pack a Sequence\"\n  (loop [l list\n         group  ()\n         result ()]\n    (let [fi      (first l)\n          groupFi (first group)\n          newResult (cons group result)]\n    (if (empty? l)\n      (rest (reverse newResult))\n      (if (= fi groupFi)\n        (recur (rest l) (conj group fi) result)\n        (recur (rest l) (conj () fi) newResult)\n)))))","user":"5954cea2e4b066ee0a44af0a"},{"code":"(fn [s]\n  (if-let [f (first s)]\n    (loop [ret [] cnt 1 item f outs (rest s)]\n      (if (empty? outs) (conj ret (repeat cnt item))\n        (if (= (first outs) item)\n          (recur ret (inc cnt) item (rest outs))\n          (recur (conj ret (repeat cnt item))\n                 1 (first outs) (rest outs)))))))","problem":31,"user":"4faa8de0e4b081705acca1f8"},{"code":"reduce #(if(= (first (last %1)) %2)\n           (concat (butlast %1) [(conj (last %1) %2)])\n           (concat %1 [[%2]])) []","problem":31,"user":"52e4cc2ee4b09f7907dd1455"},{"problem":31,"code":"(fn [seq1] (loop [orig (seq seq1) packed '()] (if (empty? orig) (reverse packed) (recur (drop-while #(= (first orig) %) orig) (conj packed (take-while #(= (first orig) %) orig))))))","user":"53b952eee4b047364c0444e6"},{"problem":31,"code":"#(loop [xs %, res ()] \n   (if (empty? xs) \n     (reverse res) \n     (let [x (first xs) \n           coll (rest xs) \n           resf (first res)]\n       (recur coll (if (= x (first resf))\n                     (conj (rest res) (conj (first res) x))\n                     (conj res (list x)))))))","user":"5dcc0ee9e4b02b31cc3da3c2"},{"code":"(fn [coll]\n  (loop [res []\n         sub []\n         cur :none\n         c coll]\n    (let [h (first c)\n          t (rest c)]\n        (cond\n          (nil? h) (conj res sub)\n          (= cur h) (recur res (conj sub h) h t)\n           :else (recur (if (empty? sub) res (conj res sub)) [h] h t)))))","problem":31,"user":"4f230dfbe4b0d66497709fe0"},{"problem":31,"code":"(fn [xs]\n    (reduce (fn [acc x] (let [lacc (peek acc)\n                              lelem (get lacc 0 nil)]\n                          (if (= lelem x)\n                            (conj (pop acc) (conj lacc x))\n                            (conj acc [x])))) [] xs))","user":"560e9a2de4b05f002753df52"},{"code":"(partial reduce       (fn [acc x]          (if (= x (first (last acc)))              (conj (pop acc) (conj (last acc) x))              (conj acc (vector x))          )      ) [])","problem":31,"user":"51422945e4b0b50abeb46b2e"},{"problem":31,"code":"(fn [coll]\n    (let [list-item-exist? (fn [coll item]\n                             (some #(= item %) coll))\n          group-reduce (fn [coll item]\n                         (let [last-push (first coll)]\n                           (if (list-item-exist? last-push item)\n                             (conj (rest coll) (conj last-push item))\n                             (conj coll (list item)))))]\n      (reverse (reduce group-reduce '() coll))))","user":"5e7b1ef4e4b085ba37836e10"},{"problem":31,"code":"(fn [se]\n  (reverse (reduce #(if (= %2 (first (first %1))) (cons (cons %2 (first %1)) (rest %1)) (cons (list %2) %1)) '() se)))","user":"52cda980e4b07d0d72b2737b"},{"problem":31,"code":"(fn [s]\n      (reduce\n        (fn [v c]\n            (if (= c (last (last v)))\n              (conj (vec (or (butlast v) [])) (conj (last v) c))\n              (conj v [c]))) [] s))","user":"5540fe42e4b0a04f7929950a"},{"problem":31,"code":"(fn [coll]\n  (reduce (fn [acc x] \n            (cond \n              (empty? acc) (conj acc (vector x))\n              (= (last (last acc)) x) (conj (vec (drop-last acc)) (conj (last acc) x))\n              :else (conj acc (vector x)))) [] coll))","user":"5794fd7be4b0e215f87e8476"},{"problem":31,"code":"(fn [input-list]\n  (partition-by identity input-list)\n  )","user":"5909b3f8e4b047aa04b199a4"},{"code":"(fn [s] (reverse (reduce #(if (= (ffirst %1) %2) \n (cons (cons %2 (first %1)) (rest %1))\n (cons (list %2) %1)) '() s)))","problem":31,"user":"4effb663535dcb61093f6a2e"},{"problem":31,"code":"(fn spotpack [s]\n  (cond\n    (empty? s) s\n    (not (sequential? s)) s\n    :else (let [cnt\n                ((fn countstart [c e]\n                  (if (= (first c) e)\n                   (+ 1 (countstart (rest c) e))\n                   0)) s (first s))]\n            (cons (take cnt s) (spotpack (drop cnt s))))))","user":"60882700e4b0ae75613dcedf"},{"problem":31,"code":"(fn pack [sq]\n  ((fn pack-in [s]\n     (cond\n      (empty? (rest s)) s\n      (= (first (first s)) (second s)) (pack-in (cons (conj (first s) (second s)) (rest (rest s))))\n      :else (cons (first s) (pack (rest s))))\n     ) (cons (list (first sq)) (rest sq))))","user":"5dd60c58e4b0948ae9d9ad7c"},{"problem":31,"code":"(fn pack [input]\n  (loop [[first & rest] input\n         packed []\n         cur-pack nil\n         cur-el first]\n    (if (nil? first)\n      (conj packed cur-pack)\n      (if (= first cur-el)\n        (recur rest packed (conj cur-pack first) cur-el)\n        (recur rest (conj packed cur-pack) (list first) first)))))","user":"5c195cb2e4b01240ff5671f7"},{"problem":31,"code":"(fn [ls]\n  (loop [ls (reverse ls)\n         cseq (list (first ls))\n         res '()]\n    (if (empty? ls)\n      res\n      (recur\n       (rest ls)\n       (if (= (first ls) (second ls))\n         (conj cseq (first ls))\n         (list (second ls)))\n       (if (= (first ls) (second ls))\n         res\n         (conj res cseq))))))","user":"5d125d63e4b02c15ef021999"},{"problem":31,"code":"(fn [xs]\n       (partition-by identity xs))","user":"547ad587e4b0c51c1f4d72ce"},{"code":"(fn [x] (reverse \n  (\n  (fn ap [x curSubList curChar res] (\n    if (= '() x) \n       (conj res curSubList) \n       (\n        if (= (first x) curChar) \n           (ap (rest x) (conj curSubList curChar) curChar res)\n           (ap (rest x) (list (first x)) (first x) (conj res curSubList))\n       )\n  )) (rest x) (list (first x)) (first x) '()\n)\n))","problem":31,"user":"4fcf5292e4b03432b189f40e"},{"code":"reduce #(cond \n                 (empty? %1)             [[%2]]\n                 (= (last (last %1)) %2) (conj (vec (butlast %1)) (conj (last %1) %2))\n                 :else                   (conj %1 [%2]))\n        []","problem":31,"user":"5186134ce4b0da5a5be3bac7"},{"problem":31,"code":"#(reverse (reduce (fn [psqn elem]\n            (if (= (first (first psqn)) elem)\n              (conj (if (= (count psqn) 1)\n                      '()\n                      (rest psqn))\n                    (conj (first psqn) elem))\n              (conj psqn (list elem))))\n          '() %))","user":"60b1add0e4b0e0fa5f1b4227"},{"problem":31,"code":"(fn [A]\n  (partition-by identity A)\n)","user":"5649615be4b0284900eef641"},{"code":"(fn p [s]\n  (when (seq s)\n    (let [[[t & _ :as h] & u :as r] (p (rest s))\n          x (first s)]\n      (if (= x t)\n        (conj u (conj h x))\n        (conj r (list x))))))","problem":31,"user":"4e4c238f535dc968683fc4dc"},{"problem":31,"code":"(fn pack\n  [lst]\n  (if (empty? lst)\n    lst\n    (do\n      (let [conseq (take-while #(= (first lst) %) lst)]\n        (cons conseq (pack (drop (count conseq) lst)))))))","user":"59636cc2e4b066ee0a44b0c7"},{"problem":31,"code":"(fn pby [xs*]\n  (loop [acc []\n         streak (list)\n         [x & xs :as allx] xs*]\n    (if (seq allx)\n      (if (= x (first streak))\n        (recur acc (conj streak x) xs)\n        (recur (conj acc streak) (list x) xs))\n      (rest (seq (conj acc streak))))))","user":"55a12668e4b0acc240e3150b"},{"problem":31,"code":"(fn pack [v]\n  (if (empty? v) ()\n    (let [[a b] (split-with #(= (first v) %) v)]\n      (conj (pack b) a))))","user":"4f5eda39e4b0030a34fb2b56"},{"code":"(fn f [coll] (if (empty? coll) coll (let [x (first coll) xs (take-while #{x} coll) ys (drop-while #{x} coll)] (cons xs (f ys)))))","problem":31,"user":"4fac1d77e4b081705acca223"},{"problem":31,"code":"(fn [xs]\n  (loop [result []\n         current-value (first xs)\n         current-seq []\n         remaining xs]\n    (if (empty? remaining) (conj result current-seq)\n        (if (= current-value (first remaining))\n          (recur result\n                 current-value\n                 (conj current-seq (first remaining))\n                 (rest remaining))\n          (recur (conj result current-seq)\n                 (first remaining)\n                 [(first remaining)]\n                 (rest remaining))))))","user":"55f5b8d6e4b06e875b46ce8d"},{"problem":31,"code":"#(reduce (fn [all one]\n           (if (= (last (last all)) one)\n             (conj (vec (butlast all)) (conj (last all) one))\n             (conj all (list one))))\n         '[]\n         %)","user":"544673c0e4b032a45b8693b0"},{"problem":31,"code":"(fn [x]\n (reverse\n  (loop [in x\n         on '()\n         out '()]\n    (cond\n      (empty? in) (if (empty? on) out (cons on out))\n      (empty? on) (recur (rest in) (list (first in)) out)\n      (= (first in) (first on)) (recur (rest in) (cons (first in) on) out)\n      :else (recur (rest in) (list (first in)) (cons on out))))))","user":"594bd637e4b07ddc2dafae41"},{"code":"(fn [x] (case (first x) 1 '((1 1) (2) (1 1 1) (3 3)) :a '((:a :a) (:b :b) (:c)) [1 2] '(([1 2] [1 2]) ([3 4])) ))","problem":31,"user":"51b9b5ace4b0e871ca495908"},{"code":"(fn pack [x]\r\n  (if (seq x)\r\n    (lazy-seq (cons (take-while (partial = (first x)) x) (pack (drop-while (partial = (first x)) x))))))","problem":31,"user":"4dda5d07535d02782fcbe9f2"},{"code":"(fn pack-consecutive [l]\n  (loop [lst l\n         result []]\n    (if (empty? lst)      \n      result\n      (let [[r b] (split-with #(= % (first lst)) lst)]\n        (recur b (conj result r))))))","problem":31,"user":"4e5f08c7535d8a8b8723a2da"},{"problem":31,"code":"(fn pack [coll]\n  (cond\n   (empty? coll) coll\n   (= (count coll) 1) (list (list (first coll)))\n   :else (let [fst (first coll)\n               prst (pack (rest coll))\n               pfst (first prst)]\n           (if (= fst (first pfst))\n             (cons (cons fst pfst) (rest prst))\n             (cons (list fst) prst)))))","user":"52860baae4b0239c8a67ae09"},{"code":"(fn [su] \n  (loop [s (rest su) sub [(first s)] res [] l (first s)]\n  (if (seq s) (if (= l (first s)) \n     (recur (rest s) (conj sub (first s)) res l)\n     (recur (rest s) [(first s)] (conj res sub) (first s)))\n    (conj res sub))))\n; it doesn't work for lists of lenght 1\n; but I don't understand why\n; (conj [] [(first [1])]) works, but (f [1]) returns [[nil]]","problem":31,"user":"4efd98fa535de96065cf5086"},{"problem":31,"code":"(fn z [s]\n  (loop [s s  rslt '()]\n    (if (empty? s)\n      rslt\n      (let [c (count (take-while #(= (first s) %) s))]\n        (recur (drop c s)\n               (concat rslt (list (take c s)) ))) )))","user":"572ac718e4b0f4d77e651242"},{"code":"(fn pack-seq\r\n  ([[h & t] dupes last out]\r\n     (println \"h \" h \" t \" t \" dupes \" dupes \" last \" last \" out \" out)\r\n     (if (nil? h)\r\n       (reverse (cons dupes out))\r\n       (if (nil? last)\r\n   (pack-seq t (list h) h out)\r\n\t (if (= h last)\r\n\t   (pack-seq t (cons h dupes) h out)\r\n\t   (pack-seq t (list h) h (cons dupes out))))))\r\n  ([s]\r\n     (pack-seq s nil nil nil)))","problem":31,"user":"504ec4d3e4b069badc5a33c9"},{"problem":31,"code":"(fn [finput] (partition-by #(when true %) finput))","user":"56ef11efe4b04a395b9a045b"},{"code":"(fn [x] (loop [c  x\r\n       r  []]\r\n  (if (seq c)\r\n      (recur\r\n        (drop-while #(= (first c) %) c)\r\n        (conj r (take-while #(= (first c) %) c)))\r\n    r)))","problem":31,"user":"4e5bdc2b535d8a8b8723a2bb"},{"code":"(fn pack-sequence [x]\n  (loop [lastone nil\n         current nil\n         ll x]\n    (cond (empty? ll) (reverse current)\n          (= lastone (first ll))\n          (recur lastone \n            (cons (cons lastone (first current)) (rest current)) \n             (rest ll))\n          :else\n          (recur (first ll) (cons (cons (first ll) nil) current) (rest ll)))))","problem":31,"user":"4e6a73d0535d8ccf87e9fee7"},{"problem":31,"code":"(fn [coll] \n  (loop [c coll res []]\n    (if (empty? c)\n      res\n      (let [s (take-while (partial = (first c)) c)]\n        (recur (drop (count s) c) (conj res s))))))","user":"55c0afa5e4b01b9910ae2a27"},{"code":"(partial (fn pb \r\n  ([f s] \r\n    (if (empty? s)\r\n      '()\r\n      (let [fv (f (first s))]\r\n        (pb f s fv '() '()))))\r\n  ([f s v t r]\r\n    (if (empty? s)\r\n      (cons t r)\r\n      (let [fv (f (first s))]\r\n        (if (= fv v)\r\n          (pb f (rest s) v (cons v t) r)\r\n          (cons t (pb f (rest s) fv (list fv) r))))))) \r\nidentity)","problem":31,"user":"4fc50441e4b081705acca36f"},{"problem":31,"code":"#(reduce\n  (fn [s, a]\n    (let [op (last s)\n          h (pop s)]\n      (if (= (last op) a)\n        (conj h (conj op a))\n        (conj h op (vector a))))) (vector (vector (first %))) (rest %))","user":"591f05b4e4b09b4ee5954c42"},{"code":"(fn [c] (reduce \n  #(let [l (last %)] \n       (if (= (first l) %2)\n          (concat (drop-last %) (list (conj l %2))) \n           (concat % (list (vector %2)))  \n        )\n  ) [] c))","problem":31,"user":"50921f9ae4b09a7d0b586de1"},{"problem":31,"code":"(fn [x] (let [inner\n                (fn ! [prev coll]\n                      (let [a (first prev)\n                            b (first coll)]\n                        (if (nil? b)\n                                  (conj nil prev)\n                                  (if (= a b)\n                                    (! (cons b prev) (rest coll))\n                                    (cons prev (! (conj nil b) (rest coll)))\n                                    )\n                                  )\n                        )\n                        )]\n            (inner (conj nil (first x)) (rest x))\n            )\n    )","user":"548f7bf1e4b0e286459a123b"},{"problem":31,"code":"(fn [inc-list]\n  (loop [data (rest inc-list), curr (first inc-list), interim-res [], result []]\n    (if (empty? data) \n      (concat result (vector (conj interim-res curr)))\n      (if (= curr (first data))\n        (recur (rest data) (first data) (conj interim-res curr) result)\n        (recur (rest data) (first data) [] (concat result (vector (conj interim-res curr))))\n      )\n    )\n  )\n)","user":"5a4dbc97e4b05d388ecb6bae"},{"code":"(fn f[coll]\r\n  (cond\r\n    (empty? coll) nil\r\n    (empty? (rest coll)) (list coll)\r\n    (= (first coll) (second coll))\r\n         (let [t (f (rest coll))]\r\n           (cons (cons (first coll) (first t))\r\n                 (rest t)))\r\n    :else\r\n         (cons (list (first coll))\r\n               (f (rest coll)))))","problem":31,"user":"4e53bf5e535d8a8b8723a275"},{"problem":31,"code":"(fn [col] (seq (partition-by identity col)))","user":"57dfe173e4b0bd073c20246b"},{"code":"reduce #(if (= (peek (peek %)) %2)\n           (conj (vec (butlast %)) (conj (peek %) %2))\n           (conj % (conj [] %2))) []","problem":31,"user":"4efb2fd7535dced4c769f274"},{"problem":31,"code":"(fn pack [my_coll]\n  (partition-by identity my_coll))","user":"5edb07dde4b0c7845d86b0ed"},{"code":"#(partition-by identity %1)","problem":31,"user":"4e113a81535d04ed9115e7c5"},{"problem":31,"code":"#(partition-by  identity %)","user":"5425d454e4b01498b1a71b13"},{"code":"#(let\n      [last-item (atom \"\")\n \t     current-pack (atom [])\n\t     ret (atom [])]\n\t  (letfn\n\t   [(set-item [x] (reset! last-item x))\n\t    (pack-item [x]\n\t\t       (if (= @last-item\n\t\t\t       x)\n\t\t\t (do\n\t\t\t     (reset! last-item x)\n\t\t             (swap! current-pack conj x))\n\t\t\t (do\n\t\t\t     (reset! last-item x)\n\t\t\t     (swap! ret conj @current-pack)\n\t\t\t     (reset! current-pack [])\n\t\t\t     (swap! current-pack conj x))))]\n\t   (doseq [y %1]\n\t\t  (pack-item y))\n\t   (swap! ret conj @current-pack)\n\t   (rest @ret)))","problem":31,"user":"4f601623e4b0defedf855fa3"},{"problem":31,"code":"(fn packSeq [x]\n  (loop [in x out '() temp '()]\n    (cond\n     (empty? in) (reverse (conj out temp))\n     (empty? temp) (recur (rest in) out (conj temp (first in)))\n     (= (first in) (first temp)) (recur (rest in) out (conj temp (first in)))\n     :else (recur (rest in) (conj out temp) (list (first in)))\n     )\n    )\n  )","user":"56942b5fe4b0dcc4269f411c"},{"problem":31,"code":"#(reverse\n  (reduce\n   (fn [a b]\n     (if\n       (= b (ffirst a)) (cons (conj (first a) b) (rest a))\n       (conj a (list b))))\n   '() %))","user":"5b552117e4b02d533a91bd2c"},{"problem":31,"code":"(fn [a]\n  ((fn fun [b c r]\n    (let [i (first b)]\n      (if (not (nil? i))\n        (if (= i c)\n          (recur (rest b) c (conj (vec (butlast r)) (conj (last r) c)))\n          (recur (rest b) i (conj r (vector i))))\n        r))) a nil []))","user":"549cd548e4b0f3d1d8e70f91"},{"code":"(fn F [X]\n  (if (empty? X) '()\n  (let [x (first X)\n        chunk (take-while #(= x %) X)\n        n (count chunk)]\n    (cons chunk (F (drop n X))))))","problem":31,"user":"51ad0ab8e4b09397d510977b"},{"code":"(fn ps\n  ([s] (ps s ()))\n  ([s p] (if (= s ())\n           p\n           (if (= (first s) (first (first (reverse p))))\n             (ps (rest s) (reverse (cons (cons (first s) (first (reverse p))) (rest (reverse p)))))\n             (ps (rest s) (reverse (cons (cons (first s) ()) (reverse p))))\n           )\n         )\n   )\n  )","problem":31,"user":"50f84d85e4b0aafb827eb1f7"},{"code":"#((fn recursion [alr r f s] ( if (= f nil)\n                               (seq alr)\n                             (if (= (first s) f) \n                              (recursion alr (conj r f) (first s) (vec (next s)))\n                              (recursion (conj alr (conj r f)) [] (first s) (vec (next s)))\n                              )\n                             )) [] [] (first %) (vec (next %)))","problem":31,"user":"50e008d1e4b061dbdced722a"},{"code":"#(let \n  [res (reduce\n    (fn [acc x]\n      (if (or (empty? (last acc)) (= (first (last acc)) x))\n        [(first acc) (conj (last acc) x)]\n        [(conj (first acc) (last acc)) [x]]\n      )\n    )\n    [[],[]]\n    %\n  )]\n  (concat (first res) [(last res)])\n)","problem":31,"user":"4ea57300535d7eef308072d5"},{"problem":31,"code":"#(->(loop [items %, result '(), prev '(), match nil]\n        (cond\n         (nil? items) (concat result \n                              (if (= (first prev) match) \n                                (list (conj prev match)) \n                                (concat (list prev) (list (list match)))))\n         (= (first prev) match) (recur (next items) result \n                                       (conj prev match) (first items))\n         (= prev '() ) (recur (next items) result\n                            (list (first items)) (first items))\n         :else (recur (next items) (concat result (vector prev))\n                      (list match) (first items)))) next)","user":"55c2b95de4b0e31453f64980"},{"problem":31,"code":"(fn r\n    ([s] (r [] s))\n    ([res s]\n     (if (empty? s)\n       res\n       (let [g (take-while #(= (first s) %) s)\n             h (drop-while #(= (first s) %) s)]\n         (concat res (vector g) (r h))))))","user":"4e837808535db62dc21a62d9"},{"problem":31,"code":"(fn pack-seq [s]\n  (reduce\n   #(if (= %2 (ffirst %1))\n      (cons (cons %2 (first %1)) (rest %1))\n      (cons (list %2) %1))\n   ()\n   (reverse s)))","user":"5f5b624de4b05ea7b9adc42f"},{"problem":31,"code":"#(reverse \n    (reduce \n        (fn [acc num]\n            (if (and (not= acc []) (.contains (first acc) num))\n                (conj (rest acc) (concat (first acc) (list num)))\n                (conj acc (list num))))\n        [] %))","user":"5896735fe4b00487982d529d"},{"code":"#(reverse\n  (loop [todo % acc []]\n    (if (empty? todo) acc\n        (recur (next todo)\n               (if (and (seq acc) (= (first (first acc))\n                                     (first todo)))\n                 (cons (cons (first todo) (first acc))\n                       (rest acc))\n                 (cons (list (first todo))\n                       acc))))))","problem":31,"user":"4fa6d532e4b081705acca1be"},{"problem":31,"code":"(fn pack [sq]\n  (let [sq (seq sq)\n        res (atom '())\n        temp (atom '[])]\n    (doseq [itm sq]\n      (when (or (empty? @temp) (= (first @temp) itm))\n        (swap! temp conj itm))\n      (when-not (= (first @temp) itm)\n        (swap! res concat (list (seq @temp)))\n        (reset! temp [itm])))\n    (swap! res concat (list (seq @temp)))\n    @res))","user":"60436423e4b02d28681c77a3"},{"problem":31,"code":"(fn group-lists [in]\n  (letfn [(inner [in out sublist]\n                 (let [firstelmt (first in), firstsublist (first sublist)]\n                   ;(print (str \"First elem: \" firstelmt \"\\n\"))\n                   ;(print (str \"First sublist: \" firstsublist \"\\n\"))\n                   (if (or (= nil firstsublist) (= firstsublist firstelmt))\n                     (do\n                       (print (str \"recurse1 with \" (rest in) \" , \" out \" , \" (conj sublist firstelmt) \"\\n\"))\n                       (inner\n                         (rest in)\n                         out\n                         (conj sublist firstelmt)))\n\n                     ; then we need to flush out the sublist to out\n                     (do\n                       (if (not (= nil firstelmt))\n                         (do\n                           (print (str \"recurse2 with \" (rest in) \" , \" (conj out sublist) \" , \" `(~firstelmt) \"\\n\"))\n                           (inner\n                             (rest in)\n                             (conj out sublist)\n                             `(~firstelmt)))\n                         (conj out sublist)))\n                     ))\n\n                 )]\n    (reverse (inner in '() '()))))","user":"55fb5b89e4b0f488688e0662"},{"problem":31,"code":"(fn [s]\n    (reverse\n      (loop [res  '()\n             s    s]\n        (if (empty? s)\n          res\n          (if (empty? res)\n            (recur (cons (list (first s)) res) (rest s))\n            (if (= (first s) (first (first res)))\n              (recur (cons (cons (first s) (first res)) (rest res)) (rest s))\n              (recur (cons (list (first s)) res) (rest s))))))))","user":"56a94562e4b07966d5a8a074"},{"code":"(fn pack-seq\n  [arr]\n  (loop [acc []\n         current (first arr)\n         counter 1\n         arr-rest (rest arr)]\n    (if (nil? current)\n      acc\n      (let [same (= current (first arr-rest))\n            last (empty? arr-rest)]\n        (recur\n          (if same acc (conj acc (repeat counter current)))\n          (if last nil (if same current (first arr-rest)))\n          (if same (inc counter) 1)\n          (rest arr-rest))))))","problem":31,"user":"4edfb618535d10e5ff6f5343"},{"problem":31,"code":"(fn pack [x]\n  (if (empty? x)\n    x\n    (let [f (take-while #(= (first x) %) x)\n          n (count f)]\n      (into [f]\n            (pack (nthnext x n))\n      )\n    )\n  )\n)","user":"59ac559ee4b00adcf69795d2"},{"code":"(fn pack [v] (if (= 1 (count v))\n    (list v)\n    (let [tail (pack (rest v)) head (first v)]\n      (if (= head (first (first tail)))\n        (cons (cons head (first tail)) (rest tail))\n        (cons (list head) tail)\n        ))))","problem":31,"user":"4fcad14ce4b0ee37620e1856"},{"problem":31,"code":"(fn pack [seq & {:keys [packed] :or {packed []}}]\n  (cond (empty? seq)\n        packed\n        (= (first seq) (first (last packed)))\n        (pack (rest seq) :packed (conj (pop packed) \n                                       (conj (peek packed)\n                                             (last (peek packed)))))\n        true\n        (pack (rest seq) :packed (conj packed [(first seq)]))))","user":"5b47874be4b02d533a91bc70"},{"code":"#(reduce \n   (fn [acc x] \n     (if \n       (= (first (last acc)) x) \n       (concat (butlast acc) (list (concat (last acc) (list x))))\n       (concat acc (list (list x)))))\n   ()\n   %)","problem":31,"user":"5141abf1e4b02fd87f5064c3"},{"problem":31,"code":"(fn collect-dups-consecutive\n  [coll]\n  (reverse (loop [coll coll\n                  acc ()]\n             (if (empty? coll)\n               acc\n               (let [elt (first coll)\n                     found (first acc)]\n                 (recur (rest coll)\n                        (if (= (first found) elt)\n                          (cons (cons elt found) (rest acc))\n                          (cons (list elt) acc))))))))","user":"539118b2e4b0b51d73faaea1"},{"problem":31,"code":"(fn [s]\n  (loop [in     (rest s)\n         prev   (first s)\n         prevs  [prev]\n         out    []]\n    (if (empty? in)\n      (conj out prevs)\n      (let [cur (first in)]\n        (if (= cur prev)\n          (recur  (rest in)\n                  cur\n                  (conj prevs cur)\n                  out)\n          (recur  (rest in)\n                  cur\n                  [cur]\n                  (conj out prevs)))))))","user":"58ba8e7ce4b0888cdc949ce8"},{"problem":31,"code":"(fn [a-seq]\n                               (loop [l a-seq acc '()]\n                                 (if (empty? l)\n                                   (reverse acc)\n                                   (if (empty? acc)\n                                     (recur (rest l) (list (list (first l))))\n                                     (if (= (first l) (first (first acc)))\n                                       (recur (rest l) (conj (rest acc) (conj (first acc) (first l))))\n                                       (recur (rest l) (conj acc (list (first l)))))))))","user":"5f86a98be4b0649ffcda4caa"},{"problem":31,"code":"#(reverse (loop [coll %\n                 acc (empty coll)]\n    (if (empty? coll)\n      acc\n      (recur (rest coll) (if (= (first (first acc)) (first coll))\n                           (cons (cons (first coll) (first acc)) (rest acc))\n                           (cons (cons (first coll) nil) acc))))))","user":"5613a96ae4b05f002753dfa4"},{"problem":31,"code":"(fn [s]\n   (loop [result []\n          remaining s\n          n (first s)]\n     (if (empty? remaining)\n       result\n       (let [new-result (conj result (take-while #(= n %) remaining))\n             new-remaining (drop-while #(= n %) remaining)]\n         (recur new-result new-remaining (first new-remaining))))))","user":"57958dace4b0e215f87e8484"},{"code":"(fn re [x]\n  (reverse (reduce\n    (fn [q w]\n      (if (= (first (first q)) w)\n        (cons (cons w (first q)) (rest q))\n        (cons [w] q)\n      )\n    )\n    (cons (cons (first x)'()) '())\n    (rest x) \n  ))\n)","problem":31,"user":"4fc8f671e4b0ee37620e1840"},{"code":"(fn consec-group\n    [s]\n    (let [first-group (take-while #(= (first s) %) s)\n          tail (drop-while #(= (first s) %) s)]\n      (if (seq s)\n        (cons first-group (consec-group tail))\n        [])))","problem":31,"user":"52a7634ae4b0c58976d9ac16"},{"problem":31,"code":"#(partition-by identity % )","user":"580d7de3e4b0849f6811b73d"},{"problem":31,"code":"reduce #(let [la (last %1)]\n          (let [lan (first la)]\n            (if (= %2 lan)\n              (concat (or (butlast %1) '())\n                      (list (concat la (list lan))))\n              (concat %1 (list (list %2)))))) '()","user":"5649542fe4b0284900eef63f"},{"problem":31,"code":"(fn [s]\n  (loop [acc [] s s]\n    (cond\n      (empty? s) acc\n      (= (first s) (peek (peek acc)))\n      (recur\n        (conj (pop acc) (conj (peek acc) (first s)))\n        (rest s))\n      :else (recur (conj acc [(first s)]) (rest s)))))","user":"56cf115de4b0ea9b8538f765"},{"code":"#(letfn [(mfilter [xs e] \r\n          (if (= xs [])\r\n\t\t        xs\r\n\t\t        (let [es (take-while (fn [x] (= x e)) xs)\r\n                  ys (drop (count es) xs)\r\n\t\t              zs (mfilter ys (first ys))]\r\n\t\t        (concat (list es) zs))))]\r\n  (mfilter % (first %)))","problem":31,"user":"4e273301535deb9a81d77ef7"},{"code":"(partial reduce (fn [x y]\n  (prn x y)\n  (if (and (not (empty? x))\n           (= y (first (last x))))\n      (conj (vec (butlast x)) (conj (last x) y))\n      (conj x [y])))\n  [])","problem":31,"user":"4fa4ef2ee4b081705acca1a9"},{"code":"(fn [l]\r\n        (loop [curr (rest l) acc (list (first l)) all-acc []]\r\n            (cond (empty? curr) (conj all-acc acc)\r\n                (= (first curr) (first acc)) (recur (rest curr) (conj acc (first curr)) all-acc)\r\n                :else (recur (rest curr) (list (first curr)) (conj all-acc acc) ))))","problem":31,"user":"523dd963e4b06956f8342ca1"},{"problem":31,"code":"(fn [values]\n  (loop [values (rest values) current (first values) pack [(first values)] result []]    \n    (if (empty? values) \n      (if (empty? pack)\n        result\n        (conj result pack))\n      (let [item (first values)]\n        (recur (rest values) item \n               (if (= current item)\n                 (conj pack item)\n                 [(first values)])\n               (if (= current item)\n                 result\n                 (conj result pack)))))))","user":"57d9bca1e4b0bd073c202405"},{"code":"(fn pack [x]\r\n  (partition-by identity x))","problem":31,"user":"4fea08a9e4b0547ebccb2484"},{"problem":31,"code":"(fn [x] (loop [out [] cur [(first x)] left (rest x)] (if (empty? left) (conj out cur) (recur (if (= (first left) (last cur)) out (conj out cur)) (if (= (first left) (last cur)) (conj cur (first left)) [(first left)]) (rest left)))))","user":"5d7158f3e4b04d129b00f2e1"},{"problem":31,"code":"#(reduce\n  (fn [l e]\n    (if (= e (first (first l)))\n      (conj (rest l) (conj (first l) e))\n      (conj l (list e))\n    )\n  )\n  (list (list (last %)))\n  (rest (reverse %))\n)","user":"5e958767e4b0fbed045a380b"},{"code":"(fn pack\n  [coll]\n  (partition-by identity coll))","problem":31,"user":"50fc48dde4b0d10d794c19f6"},{"problem":31,"code":"#(reverse\n   (reduce\n     (fn [acc v]\n       (println acc v)\n       (if(= (first (first acc)) v)\n         (conj (rest acc) (conj (first acc) v))\n         (conj acc (list v)))) '() %))","user":"5b6473eee4b0c6492753e73f"},{"code":"(fn [xs]\n  (loop [l xs r []]\n    (if (empty? l)\n      r\n      (let [group (or (last r) [])\n            group-element (first group)\n            done (into [] (drop-last r))\n            element (first l)\n            same-group (= group-element element)]\n        (if same-group\n          (recur (rest l) (conj done (conj group element)))\n          (recur (rest l) (conj r [element])))))))","problem":31,"user":"52b9c62ce4b07a9af57922c3"},{"problem":31,"code":"(fn [x]\n  (loop [new-list [] current \"\" cnt 0 times 0]\n    (if (= (count x) cnt)\n      (conj new-list (repeat times current))\n      (if (= (nth x cnt) current)\n        (recur new-list current (inc cnt) (inc times))\n        (if (> times 0)\n          (recur (conj new-list (repeat times current)) (nth x cnt) (inc cnt) 1)\n          (recur new-list (nth x cnt) (inc cnt) (inc times)))))))","user":"5756e218e4b02ea1147992e5"},{"problem":31,"code":"(fn f [coll]\n  (loop [in coll\n         curr ()\n         res []]\n    (if (seq in)\n      (if (seq curr)\n        (let [a (first curr)\n              b (first in)]\n          (if (= a b)\n            (recur (next in)\n                   (cons (first in) curr)\n                   res)\n            (recur (next in)\n                   (list (first in))\n                   (conj res curr))))\n        (recur (next in)\n               (cons (first in) curr)\n               res))\n      (conj res curr))))","user":"549c6792e4b0f3d1d8e70f8b"},{"problem":31,"code":"(fn seq-pack [xs]\n  (if (seq xs)\n    (cons (take-while #(= % (first xs)) xs)\n          (seq-pack (drop-while #(= % (first xs)) xs)))))","user":"54448e84e4b032a45b869393"},{"problem":31,"code":"(fn [seq]\n  (let [after-reduce (reduce\n                       (fn [[packs curr-pack] elm]\n                         (if (= (first curr-pack) elm)\n                           ;; current pack is not finished yet, add elm to current pack\n                           [packs (concat curr-pack (list elm))]\n                           ;; current pack is finished, add it to pack list, start new pack\n                           [(concat packs [curr-pack]) (list elm)]))\n                       [() (take 1 seq)]\n                       (rest seq))]\n    (concat (first after-reduce) [(second after-reduce)])))","user":"5984e7dee4b021a7a535fe43"},{"code":"#(loop [r [], s %]\n   (if\n    (empty? s) r\n    \n    (let [ch (for [el s :while (= el (first s))] el)]\n      (recur (conj r ch) (drop (count ch) s)))))","problem":31,"user":"5196568fe4b04c0af7ff3c1c"},{"code":"(fn diff-list\r\n  [coll]\r\n\t(reverse(reduce \r\n\t\t(fn [x y]\r\n\t\t\t(let [f-coll (first x)\r\n\t\t\t\t\tf-item (if (coll? f-coll) (first f-coll) f-coll)]\r\n\t\t\t\t(do\r\n\t\t\t\t\t;(println \"result=\" x)\r\n\t\t\t\t\t;(println \"f-coll=\" f-coll \" f-item=\" f-item \" y=\" y)\r\n\t\t\t\t\t(if (= f-item y)\r\n\t\t\t\t\t\t(do\r\n\t\t\t\t\t\t\t;(println (conj ls-coll y))\r\n\t\t\t\t\t\t\t(conj \r\n\t\t\t\t\t\t\t\t(rest x)\r\n\t\t\t\t\t\t\t\t(conj \r\n\t\t\t\t\t\t\t\t\t(if (coll? f-coll) f-coll (vector f-coll)) \r\n\t\t\t\t\t\t\t\t\ty))\r\n\t\t\t\t\t\t)\r\n\t\t\t\t\t\t(conj x (vector y))))))\r\n\t\t'()\r\n\t\tcoll)))","problem":31,"user":"4edbae0d535d10e5ff6f531c"},{"problem":31,"code":"(fn [coll]\n    (loop [coll coll\n           count-items 1\n           coll-acc []]\n      (cond (empty? coll) (seq coll-acc)\n            (= (first coll) (second coll)) (recur (rest coll) (inc count-items) coll-acc)\n            :else\n            (recur (rest coll) \n                   1\n                   (conj coll-acc (repeat count-items (first coll)))))))","user":"5e724492e4b085ba37836dc7"},{"problem":31,"code":"(fn [xs]\n  (first (reduce (fn [[res cur] el]\n                   (if (= cur el)\n                     [(concat (butlast res) [(concat (last res) [el])]) el]\n                     [(concat          res                      [[el]]) el]))\n                 [(empty xs) nil] xs)))","user":"553638bae4b09218d5f44fba"},{"code":"(fn [s]\n  (loop [s (seq s)\n         acc []]\n    (if (not s) acc\n      (let [pred #(= % (first s))]\n        (recur (seq (drop-while pred s))\n               (conj acc (take-while pred s)))))))","problem":31,"user":"5013193ae4b0f26a0e3320ab"},{"problem":31,"code":"(fn\n          [coll]\n          (letfn\n            [(pack-seq [coll]\n               (if (not (empty? coll))\n                 (cons\n                   (take-while\n                     #(= % (first coll))\n                     coll)\n                   (pack-seq (drop-while\n                               #(= % (first coll))\n                               coll)))))]\n(pack-seq coll)))","user":"5a08053fe4b01bb0ae8afde7"},{"problem":31,"code":"(fn foo\n  ([x] (let [cur (first x) rst (rest x) nxt (first rst)] (foo cur (list cur) nxt (rest rst))))\n  ([cur cur-set nxt rst]\n   (cond\n    (nil? nxt) (list cur-set)\n    (= cur nxt) (foo cur (cons nxt cur-set) (first rst) (rest rst))\n    :else (cons cur-set (foo nxt (list nxt) (first rst) (rest rst))))))","user":"5747e22ce4b009280f9f2b7c"},{"code":"(fn pack [sq] \n (reverse \n  (reduce \n    #(if \n      (= (first (first %1)) %2) (cons (cons %2 (first %1)) (rest %1)) \n       (cons (list %2) %1)) \n    '() sq)))","problem":31,"user":"4e2d562c535deb9a81d77f07"},{"code":"#(loop [lst %\n         ans nil\n         wrk nil]\n    (if (nil? lst)\n      (reverse (concat ans (filter (fn[s](not(nil? s))) wrk)))\n      (if (= (first lst)(second lst))\n        (recur (next lst) ans (cons (first lst) wrk))\n        (recur (next lst) (cons (cons (first lst) wrk) ans ) nil))))","problem":31,"user":"4e8849c5535d8b9bb0147ca4"},{"problem":31,"code":"(fn group [lst]\n  (if (empty? lst)\n    '()\n    (let [p (partial = (first lst))]\n      (cons (take-while p lst)\n            (group (drop-while p lst))))))","user":"54651982e4b01be26fd746d4"},{"code":"#(if (empty? %)\n      `()\n      ((fn [s p a]\n         (if (empty? s)\n           (reverse a)\n           (let [x (first s)]\n             (if (= x p)\n               (recur (rest s) p (cons (cons x (first a)) (rest a)))\n               (recur (rest s) x (cons (list x) a))\n               )\n             )))\n          (rest %) (first %) (list (list (first %))))\n)","problem":31,"user":"4f404dcee4b0e243712b1fb0"},{"problem":31,"code":"(fn [input]\n  (loop [iter-list input\n         res-list []]\n    (if (empty? iter-list)\n      res-list\n      (let [head (first iter-list)\n            dups '()]\n        (recur (drop-while \n                #(= head %) \n                iter-list)\n               (conj res-list\n                     (take-while \n                      #(= head %) \n                      iter-list)))))))","user":"585e2e77e4b0f14aab7c87ac"},{"code":"(fn pack [s]\n  (loop [answer [] rem s]\n    (if (empty? rem)\n      answer\n      (let [spl (split-with (partial = (first rem)) rem)]\n        (recur (conj answer (first spl)) (second spl))))))","problem":31,"user":"51672d15e4b079759a74a5e7"},{"code":"(fn pack-repeats [s]\n  (when (seq s)\n    (let [[repeats tail] (split-with #(= (first s) %) s)]\n      (cons repeats (pack-repeats tail)))))","problem":31,"user":"5310e7aee4b08068f379ecdc"},{"problem":31,"code":"#(partition-by identity (seq %))","user":"54d4ba98e4b0a52adc2e2004"},{"problem":31,"code":"(fn \n  [n]\n  (partition-by identity n) \n  )","user":"57f81532e4b0d3187e900914"},{"problem":31,"code":"(fn myfn [a] (apply list (reduce \n    (fn [x b] (if (= b (last (last x))) \n        (assoc x (dec (count x)) (conj (last x) b)) \n        (conj x (list b))))\n    (assoc a 0 [(list (first a))]))))","user":"5744723ae4b009280f9f2b3a"},{"problem":31,"code":"(fn f[m]\n  (reduce (fn g[ x y]\n            (if (= (first (peek x)) y) \n              (conj (pop x) (conj (last x) y)) \n              (conj x (list y)))) [] m))","user":"56fa8984e4b07572ad1a88c1"},{"problem":31,"code":"(fn pack [s]\n    (if (empty? s)\n      []\n      (let [[f res] (split-with (partial = (first s)) s)]\n        (cons f (pack res)))))","user":"5bab5440e4b0a20761a23475"},{"problem":31,"code":"(fn pack\n  ([arr] (pack arr '() '()))\n  ([arr sub-arr result]\n   (println arr sub-arr result)\n   (if (empty? arr)\n     (reverse (cons sub-arr result))\n     (if (empty? sub-arr)\n       (pack (rest arr) (cons (first arr) sub-arr) result)\n       (if (= (first arr) (last sub-arr))\n         (pack (rest arr) (cons (first arr)  sub-arr) result)\n         (pack arr '() (cons sub-arr result)))))))","user":"59636b6de4b066ee0a44b0c6"},{"code":"(fn [xs] (reduce\n (fn [r y]\n   (cond (= y (last (last r)))\n         (concat (drop-last r) (list (repeat (inc (count (last r))) y)))\n         :else (concat r (list (list y))) ))\n '() xs))","problem":31,"user":"524da3a5e4b0a16e35cf6df3"},{"problem":31,"code":"(fn [coll]\n  (#(partition-by identity %) coll))","user":"5aa2b5dbe4b0d174b936c85b"},{"problem":31,"code":"(partial partition-by identity)\n;;(fn pack [coll] (reduce (fn [result item]\n;;                          (if (= ((comp first last) result) item)\n;;                            (conj (vec (butlast result)) (conj (last result) item))\n;;                            (conj result [item])))\n;;                        []\n;;                        coll))","user":"60794173e4b0a637ed78035d"},{"problem":31,"code":"(fn pack [l]\n             (let [size (count l)]\n               (loop [i 1 prev (first l) count 1 result []]\n                 (if (< i (dec size))\n                   (if (= prev (nth l i))\n                     (recur (inc i) (nth l i) (inc count) result)\n                     (recur (inc i) (nth l i) 1  (conj result (take count (repeat prev)))))\n\n                   (if (= prev (nth l i))\n                     (seq (conj result (take (inc count) (repeat prev))))\n                     (seq (conj (conj result (take count (repeat prev))) (take 1 (repeat (nth l i))))))\n                   )\n                 )\n               )\n             )","user":"5d974b1de4b0d3f9b434ad36"},{"code":"(fn packit-helper\n  [accum coll]\n  (if (empty? coll)\n    (reverse accum)\n    (recur \n      (conj accum (take-while #(= (first coll) %) coll))\n      (drop-while #(= (first coll) %) coll)))) '()","problem":31,"user":"524ae8e6e4b09eba1c0223b5"},{"problem":31,"code":"#(drop 1 (reduce (fn [a b]\n  (let [lastel (last a)\n        sofar (vec (butlast a))]\n    (if (= b (last lastel))\n      (conj sofar (conj lastel b))\n      (conj sofar lastel [b])\n    )\n   )\n  ) [] %))","user":"5700f1f0e4b08d47c97781ce"},{"problem":31,"code":"(fn my-pack\n  ([coll]\n   (my-pack coll []))\n  ([[current & remaining] result]\n   (if (empty? remaining)\n     (if (nil? current)\n       result\n       (conj result (list current)))\n     (recur (drop-while (partial = current) remaining)\n              (conj result (cons current (take-while (partial = current) remaining)))))))","user":"52ea025ae4b09f7907dd14b5"},{"code":"#(letfn [(pack [l prev temp result]\n          (cond\n           (empty? l) (cons temp result)\n           (= prev (first l))  (pack (rest l) prev (cons (first l) temp) result)\n           :else (pack (rest l) (first l) (list (first l)) (cons temp result))))]\n  (reverse (pack (rest %1) (first %1) (list (first %1)) '())))","problem":31,"user":"5047782ce4b0371827a27bc2"},{"code":"#(reduce (fn [c x]\r\n          (let [uc (last c)]\r\n            (if (empty? c)\r\n              [[x]]\r\n              (if (= x (last uc))\r\n                (vec (conj \r\n                  (vec (drop-last c))\r\n                  (conj (last c) x)\r\n                  ))\r\n                (conj c [x])\r\n                )\r\n              ))\r\n          ) [] %)","problem":31,"user":"4e94a8b5535dbda64a6f6b16"},{"code":"(fn spack\n  ([s] (spack '() '() s))\n  ([a c s] (if (empty? s)\n             (if (empty? c)\n               a\n               (concat a (cons c '()))\n             )\n             (if (= (first s) (first c))\n               (spack a (cons (first s) c) (rest s))\n               (if (empty? c)\n                 (spack a (cons (first s) '()) (rest s))\n                 (spack (concat a (cons c '())) (cons (first s) '()) (rest s))\n               )\n             )\n           )\n  )\n)","problem":31,"user":"50b8de6ce4b0cba0e598b652"},{"problem":31,"code":"(fn temp\n  [lst]\n  (loop [result () \n         prev (list (first lst))\n         l (rest lst)]\n    (if (empty? l) \n      (reverse (cons prev result))\n      (let [[x & rest] l\n            p (first prev)]\n        (if (and p (= p x))\n          (recur result (cons p prev) rest)\n          (recur (cons prev result) (list x) rest))))))","user":"5a3b5cfde4b001c08efc0cd4"},{"problem":31,"code":"#(loop [seq %\n        current []\n        acc []]\n   (if (empty? seq)\n     (conj acc current)\n     (if (empty? current)\n       (recur (rest seq) [(first seq)] acc)\n       (if (= (last current) (first seq))\n         (recur (rest seq) (conj current (first seq)) acc)\n         (recur (rest seq) [(first seq)] (conj acc current))))))","user":"57155980e4b07c98581c3ad7"},{"problem":31,"code":"(fn [s]\n  (letfn [(pack [l x ss]\n            (if (empty? ss)\n              (conj l x)\n              (let [v (first x)]\n                (if (= v (first ss))\n                  (pack l (conj x v) (rest ss))\n                  (pack (conj l x) (list (first ss)) (rest ss))))))]\n    (reverse (pack '() (list (first s)) (rest s)))))","user":"5dc72a9ce4b02f9375f4e1cd"},{"problem":31,"code":"(fn [col]\n   (loop [cl (rest col), prev (first col), res [[prev]] ]\n     (cond\n       (empty? cl) (reverse res)\n       (= prev (first cl)) (recur (rest cl) prev (conj (rest res) (conj (first res) prev)))\n       :else (recur (rest cl) (first cl) (conj res [(first cl)])))))","user":"5e9f38cce4b00a66d4a9517e"},{"code":"(fn [x] (partition-by #(identity %) x))","problem":31,"user":"4f036fad535dcb61093f6ac7"},{"problem":31,"code":"(fn pack [coll]\n  (let [comb (fn [c elem]\n               (if (= (last (last c)) elem)\n                 (concat (pop (vec c)) (list (concat (last c) (list elem))))\n                 (concat c (list (list elem)))))]\n        (reduce comb '() coll)))","user":"5493ccbbe4b0b312c081ff50"},{"code":"(fn[coll]\n  (loop [i (- (count coll) 2)\n         res ()\n         node (list (last coll))]\n    (if (< i 0)\n      (conj res node)\n      (let [c (nth coll i) cn (first node)]\n        (if (= c cn)\n          (recur (dec i) res (conj node c))\n          (recur (dec i) (conj res node) (list c)))))))","problem":31,"user":"4e7bc07c535db169f9c796b9"},{"code":"reduce (fn [l r] \r\n  (if (contains? (set (last l)) r) \r\n     (concat (drop-last l) (list (conj (last l) r)))\r\n     (concat l (list (list r))))) ()","problem":31,"user":"4e0e0529535d04ed9115e7b9"},{"problem":31,"code":"(fn [s]\n  (loop [i 0\n         packed-seq '()]\n    (do (println i packed-seq) (if (= i (count s))\n       packed-seq\n       (if (< i 1)\n         (recur (inc i) (conj packed-seq (list (nth s i))))\n         (if (= (first (last packed-seq)) (nth s i))\n           (recur (inc i) (concat (butlast packed-seq) (list (conj (last packed-seq) (nth s i)))))\n           (recur (inc i) (concat packed-seq (list (list (nth s i)))))))))))","user":"57d57f65e4b0bd073c2023b3"},{"problem":31,"code":"(fn [coll]\n  (loop [a (first coll) rem (rest coll) l [a]  result []]\n    (cond (nil? a) result\n          (= a (first rem)) (recur (first rem) (rest rem) (conj l a) result)\n          :else (recur (first rem) (rest rem) [(first rem)] (conj  result l)))))","user":"54d1b6ffe4b0e8a36923e5e6"},{"problem":31,"code":"(fn [coll]\n  (loop [acc []\n         left coll]\n    (if (empty? left)\n      acc\n      (recur (conj acc (take-while #(= % (first left)) left)) (drop-while #(= % (first left)) left)))))","user":"53ea3a63e4b036ad0777e4dc"},{"problem":31,"code":"(fn [arg]\n  (reverse (reduce (fn [col el]\n                     (if (and (not-empty (first col))\n                              (= (first (first col)) el))\n                       (conj (rest col) (conj (first col) el))\n                       (conj col (list el)))) '() arg)))","user":"535f0cbde4b04ce2eb3ed2d9"},{"code":"partition-by #(if true %)","problem":31,"user":"4e3ac1b2535deb9a81d77f4c"},{"code":"(fn [x]\n  (loop [s x r []]\n    (if (empty? s)\n      r\n      (recur \n       (drop-while #(= (first s) %) s)\n       (conj r (take-while #(= (first s) %) s))))))","problem":31,"user":"53468f6ce4b084c2834f4a3f"},{"problem":31,"code":"(fn [l]\n             (reverse \n               (loop [ag nil ai nil ll l]\n                 (cond\n                   (empty? ll) (conj ag ai)\n                   (or (empty? ai) (= (first ll) (first ai))) (recur ag (conj ai (first ll)) (rest ll))\n                   :else (recur (conj ag ai) (list (first ll)) (rest ll))))))","user":"52138dd7e4b0d32679a5065d"},{"code":"(comp reverse reduce)\n(fn [col n] \n  (do\n  (println col n)\n  (if (= (first (first col)) n) \n    (cons (cons n (first col)) (rest col))\n    (cons (list n) col))))\nnil","problem":31,"user":"4f03ac2d535dcb61093f6b4a"},{"code":"(fn [c] (partition-by #(identity %) c))","problem":31,"user":"4ec79f99535d6d7199dd36e4"},{"problem":31,"code":"#(loop [coll (rest %) sublist (list (first %)) result [] ]\n   (if(empty? coll)\n     (conj result sublist)\n   (if (= (last sublist) (first coll))\n     (recur (rest coll) (conj sublist (first coll)) result)\n     (recur (rest coll) (list (first coll)) (conj result sublist))\n     )\n   )\n   \n)","user":"57d588a5e4b0bd073c2023b6"},{"problem":31,"code":"#(reverse (reduce (fn [acc curr]\n          (if (= (last (first acc)) curr)\n            (conj (rest acc) (into (first acc) (list curr)))\n            (conj acc (conj () curr)))) [] %))","user":"5db861bce4b010eb3c36cd4b"},{"code":"(fn [x] (reduce (fn [r a] \n      (if (= a (last (last r)))\n        (assoc r (dec (count r)) (conj (last r) a))\n        (conj r [a])))\n      [] x))","problem":31,"user":"52808897e4b0757a1b171404"},{"code":"(fn dup-pack [mylist]\r\n    (seq (loop [l mylist lastchar (first l) subseq '() final []]\r\n            (if (empty? l) (conj final subseq)\r\n                (if (= lastchar (first l))\r\n                  (recur (rest l) (first l) (conj subseq (first l)) final)\r\n                  (recur (rest l) (first l) (list (first l)) (conj final subseq)))))))","problem":31,"user":"4f039524535dcb61093f6b2c"},{"problem":31,"code":"(fn  [coll]\n  (reverse \n   (loop [last-element (first coll)\n          remaining (rest coll)\n          subsequence '()\n          return '()]\n     (let [next-element (first remaining)\n           next-pack (conj subsequence last-element)]\n\n       (if next-element\n\n         (if (= next-element last-element)\n\n           (recur\n            last-element\n            (rest remaining)\n            (conj subsequence last-element)\n            return)\n\n           (recur\n            next-element\n            (rest remaining)\n            '()\n            (conj return next-pack)))\n\n         (conj return next-pack))))))","user":"59971dcbe4b07157cc8daacb"},{"code":"(fn [c]\n  (partition-by identity c)\n)","problem":31,"user":"52ecb1efe4b0705949c44454"},{"problem":31,"code":"#((fn pack [acc s]\n  (let [curr (first s)\n        cumul (loop [acc [curr] more (rest s)]\n                (if (= (first more) curr)\n                  (recur (conj acc (first more)) (rest more))\n                  acc))\n        to-process (drop (if (coll? cumul) (count cumul) 1) s)]\n    (if (seq to-process)\n      (pack (conj acc cumul) to-process)\n      (conj acc cumul)))) [] %)","user":"55f8fd70e4b03cbcff9738bc"},{"problem":31,"code":"(fn [coll]\n    ((fn\n  [coll result]\n  (if (empty? coll)\n    result\n    (let [group      (take-while (fn [ce] (= (first coll) ce)) coll)\n          rest-coll  (drop-while (fn [ce] (= (first coll) ce)) coll)\n          result-acc (conj result group)]\n      (recur rest-coll result-acc)))) coll []))","user":"58a413b5e4b02bd94d917f07"},{"code":"(fn f [coll]\n  (when (seq coll)\n    (let [x (first coll)]\n      (cons (take-while #(= x %) coll)\n            (f (drop-while #(= x %) coll))))))","problem":31,"user":"5213d7aae4b0961f15ac4d72"},{"problem":31,"code":"(fn [coll]\n  (loop [coll coll\n         acc []\n         res []]\n    (if (empty? coll)\n      (if (empty? acc)\n        res\n        (conj res acc))\n      (let [f (first coll)]\n        (if (= f (first acc))\n          (recur (rest coll) (conj acc f) res)\n          (recur (rest coll) [f] (if (empty? acc) res (conj res acc))))))))","user":"5c04464ee4b0bdcf453d167d"},{"problem":31,"code":"(fn [s] (seq (partition-by identity s)))","user":"563b6a2ae4b0bfe05bf11812"},{"problem":31,"code":"#(reverse (reduce (fn [f s]\n                   (if (= (first (first f)) s)\n                     (conj (rest f) (conj (first f) s))\n                     (conj f (list s)))) '() %))","user":"5605b5e9e4b08b23635d316e"},{"problem":31,"code":"(fn [x]\n  (loop [l '() z x]\n    (if (empty? z)\n      (reverse l)\n      (recur (conj l (take-while #(= % (first z)) z)) (drop (count (take-while #(= % (first z)) z)) z)))\n    )\n  \n  )","user":"5dd70ee3e4b0948ae9d9ad85"},{"problem":31,"code":"#( loop [ a (rest %1) res [] l (list (first %1)) ] (\n                                if ( empty? a )\n                                ( conj res l )\n                               \t( if (= (first a) (first l) )\n                                  ( recur (rest a) res (conj l (first a)))\n                                  ( recur (rest a) (conj res l) (list (first a)))\n                                )\n                               )\n   )","user":"5b3aa98be4b02d533a91bbca"},{"problem":31,"code":"(fn pck [coll]\n \n  (reverse (reduce \n   (fn [fld item] \n     (if \n       (= (first (first fld)) item) \n       (conj (rest fld) (conj (first fld) item)) \n       (conj fld (list item)))) \n   '() \n   coll))\n  \n)","user":"54a7d707e4b09f271ff37c9b"},{"code":"(fn [sq] \n  (letfn [\n        \t(helper1 [sq] (split-with #(= (first sq) %) sq))\n         \t(helper2 [rv sq] (if (empty? sq) rv (helper2 (cons (first (helper1 sq)) rv) (second (helper1 sq)))))\n        \n         ] (reverse (helper2 '() sq))))","problem":31,"user":"50fbdacfe4b0d10d794c19f0"},{"code":"(partial partition-by #(identity %1))","problem":31,"user":"5131d817e4b06942423563ca"},{"problem":31,"code":"(fn pack [n] (partition-by identity n))","user":"56c55c5ee4b05cc29241eea4"},{"problem":31,"code":"(fn [coll]\n  (partition-by (fn [x] x) coll)\n  )","user":"56de0db0e4b0ea9b8538f83a"},{"code":"(fn [X]\r\n  (loop [accum [(first X)] res (rest X) total []]\r\n\t\t(if (> (count res) 0)\r\n\t\t\t(if (= (last accum) (first res))\r\n\t\t\t\t(recur (conj accum (first res)) (rest res) total)\r\n\t\t\t\t(recur [(first res)] (rest res) (conj total accum))\r\n\t\t\t)\r\n\t\t\t(conj total accum)\r\n\t\t)\r\n\t)\r\n)","problem":31,"user":"4f031883535dcb61093f6a5e"},{"problem":31,"code":"(fn\n  [s]\n  (loop [result []\n         bucket []\n         [head & rest] s]\n    (if-not head\n      (if (empty? bucket)\n        result\n        (conj result bucket))\n      (if (or (empty? bucket) (= head (last bucket)))\n        (recur result (conj bucket head) rest)\n        (recur (conj result bucket) [head] rest)))))","user":"570c8ac3e4b0b0fb43fd06ca"},{"problem":31,"code":"#(partition-by  identity % )","user":"5537de22e4b09218d5f44fd5"},{"code":"(fn pack [s]\n  (if (empty? s) []\n    (let [[packed,others] (split-with (partial = (first s)) s)]\n      (cons packed (pack others)))))","problem":31,"user":"533ab9abe4b0e30313ee6cbf"},{"problem":31,"code":"(fn [coll]\n     (loop \n         [remaining coll\n          finish '()\n          sub '()\n          curr (first coll)]\n       (if (empty? remaining)\n         (reverse (conj finish sub))\n         (if (not (= curr (first remaining)))\n           (recur\n            (rest remaining)\n            (conj finish sub)\n            (conj '() (first remaining))\n            (first remaining))\n           (recur\n            (rest remaining)\n            finish\n            (conj sub (first remaining))\n            curr)))))","user":"55096255e4b06e50f9beb116"},{"code":"#(\n(fn pack [x nxt acc]\n  (cond\n   (empty? x) (reverse (cons nxt acc))\n   (= (first x) (first nxt)) (pack (rest x) (cons (first x) nxt) acc)\n   :else (pack (rest x) (list (first x)) (cons nxt acc))\n   )\n  )\n  (rest %) (list (first %)) '())","problem":31,"user":"515f8a0de4b0e2be8aa20bce"},{"code":"#(loop [o () w () i %]\n  (if (= () i)\n    (if (= () w) (reverse o)\n      (reverse (cons w o)))\n    (let [n (first i) r (rest i)]\n      (if (= () w)\n        (recur o (cons n w) r)\n        (if (= n (first w))\n          (recur o (cons n w) r)\n          (recur (cons w o) () i))))))","problem":31,"user":"4f0ce26c535d0136e6c22312"},{"problem":31,"code":"(fn [s]\n  (reduce (fn [acc e]\n            (let [last-l (last acc)\n                  last-e (last last-l)\n                  but-last (take (dec (count acc)) acc)]\n              (if (or (nil? last-l) (not= e last-e))\n                (concat acc (list (list e)))\n                (concat but-last (list (conj last-l e))))))\n          ()\n          s))","user":"5b9357b7e4b0c0b3ffbd4a46"},{"problem":31,"code":"#(reduce (fn [accum x]\n           (if (= (last (last accum)) x)\n             (concat (butlast accum) [(conj (last accum) x)])\n             (concat accum [[x]])))\n         []\n         %)","user":"55b527cbe4b01b9910ae2985"},{"problem":31,"code":"(fn [coll]\n  (loop [grps () coll' coll]\n    (if (empty? coll')\n      (reverse grps)\n      (recur (conj grps (take-while (partial = (first coll')) coll'))\n             (drop-while (partial = (first coll')) coll')))))","user":"5db1969be4b010eb3c36cd06"},{"problem":31,"code":"(fn\n  [lst] \n  (partition-by identity lst)\n  )","user":"5bbbce99e4b0a20761a23610"},{"code":"(fn dos [l]\n  (let [uno (fn [l] (list (take-while #(= (first l) %) l)\n                          (drop-while #(= (first l) %) l)))\n       [a b] (uno l)]\n    (if (= () b) (list a)\n          (cons a (dos b)))))","problem":31,"user":"507db411e4b03c76e5499e06"},{"problem":31,"code":"#(reverse \n  (let \n   [r (reduce (fn [[l1 l2 x] a] (if (= x a) [l1 (conj l2 a) a] [(if (nil? x) l1 (conj l1 l2)) (list a) a])) ['() '() nil] %)] \n   (conj (nth r 0) (nth r 1))\n   )\n  )","user":"5e6e6537e4b04a83ad7cd29a"},{"code":"(fn pack-seq\n  [s]\n  (loop [[x & more] s\n         result []\n         subresult []]\n    (if x\n      (if (= x (first more))\n        (recur more result (conj subresult x))\n        (recur more (conj result (conj subresult x)) []))\n      result)))","problem":31,"user":"4db8d37d535d1e037afb219c"},{"problem":31,"code":"apply (fn pack\n  ([x & rest] (cons (cons x (take-while #(= x %) rest))  (apply pack (drop-while #(= x %) rest))))\n  ([] nil))","user":"57915ba4e4b0ebec4cfb75ba"},{"problem":31,"code":"(fn [xs]\n    (loop [result '[]\n           ys xs]\n      (if (empty? ys)\n        result\n        (recur (conj result (take-while #(= % (first ys)) ys))\n               (drop-while #(= % (first ys)) ys)))))","user":"531bf76fe4b08068f379ed96"},{"code":"(fn [seqs]\n  (loop [result '() \n         sub (list (first seqs))\n         others (rest  seqs)]\n    (if(empty? others)\n      (concat result (list sub))\n      (if(= (first sub ) (first others))\n        (recur result \n               (cons (first others ) sub)\n               (rest others))\n        (recur (concat result (list sub))\n               (list (first others))\n               (rest others))))))","problem":31,"user":"5273562ae4b03e8d9a4a7479"},{"problem":31,"code":"(fn pack-sequence\n  ([s] (pack-sequence (reverse s) '()))\n  ([s p]\n   (if (empty? s)\n     p\n     (if (empty? p)\n       (recur (rest s) (list (list (first s))))\n       (if (= (first s) (first (first p)))\n         (recur (rest s) (conj (rest p) (conj (first p) (first s))))\n         (recur (rest s) (conj p (list (first s)))))))))","user":"572db6d5e4b0cd1946bd0f78"},{"problem":31,"code":"(fn [insequence]\n    (loop [remaining (rest insequence) out '[] sofar (list (first insequence))]\n\n    (if (first remaining)\n      (if (= (first remaining) (first sofar))\n        (recur (rest remaining) out (conj sofar (first remaining)))\n        (recur (rest remaining) (conj out sofar) (list (first remaining)))\n          )\n\n\n      \n      (conj out sofar)))\n    \n    )","user":"5bf9d9b7e4b0bdcf453d15c4"},{"problem":31,"code":"(fn pack\n  [coll]\n  (loop [sq coll\n         val (first sq)\n         res []]\n    (if\n      (empty? sq)\n      res\n      (let [subl (take-while #(= val %) sq)\n            newseq (drop (count subl) sq)]\n       (recur newseq (first newseq) (conj res subl))))))","user":"5609d328e4b05f002753deee"},{"problem":31,"code":"; Second try without using partition-by\n\n#(reduce \n   (fn [x y]\n     (if (sequential? (last x)) \n       (if (= (first (last x)) y)\n         (conj (pop x) (conj (peek x) y) )\n         (conj x [y]))\n       (conj x [y])))\n   [] %)","user":"542c2de0e4b0dad94371f29f"},{"problem":31,"code":"(fn my-pack\n      [coll]\n      (let\n        [no-dups (map first (partition-by identity coll))\n         num-dups (map count (partition-by identity coll))\n         ]\n        (map #(take %2 (repeat %1)) no-dups num-dups)\n        )\n      )","user":"536827f1e4b0243289761e8a"},{"problem":31,"code":"(fn [s]\n  (loop [s s, res [], der '()]\n    (if (seq s)\n      (if (= (first s) (first der))\n        (recur (rest s) res (conj der (first s)))\n        (if (seq der)\n          (recur (rest s) (conj res der) (list (first s)))\n          (recur (rest s) res (list (first s)))))\n      (if (seq der)\n        (conj res der)\n        res))))","user":"5a481e05e4b05d388ecb6b64"},{"problem":31,"code":"#(reverse (reduce \n                 (fn [theEnd theValue]\n                  (if ( = (first( first theEnd)) theValue)\n                    (cons ( cons theValue (first theEnd)) (drop 1 theEnd))\n                    (cons (list theValue) theEnd)\n                  )\n                 ) \n                 '()\n                 %\n             ))","user":"5ac92dc3e4b0e27600da77bf"},{"problem":31,"code":"(fn [items]\n  (loop [it items\n         result []]\n    (let [head (first it)]\n      (if (nil? head)\n        (apply list result)\n        (let [dup-rest (split-with #(= head %) (rest it))]\n          (recur (dup-rest 1) (conj result (conj (dup-rest 0) head))))))))","user":"5d5c2730e4b09db18d4482ea"},{"problem":31,"code":"#((fn f [l r]\n    (if (empty? l)\n      (reverse r)\n      (if (=\n           (first l)\n           (first (first r)))\n        (f\n         (rest l)\n         (cons\n          (cons (first l) (first r)) (rest r)))\n        (f\n         (rest l)\n         (cons (list (first l)) r))\n        ))) % '())","user":"54c611d1e4b045293a27f627"},{"code":"(fn [l](loop [l l a '()](if (empty? l) (reverse a)\r\n  (recur (drop-while #(= % (first l)) l)\r\n    (cons (take-while #(= % (first l)) l) a)))))","problem":31,"user":"4ddbd934535d02782fcbe9fc"},{"problem":31,"code":"(fn pack[a] (\nif (not (= 0 (count a)))\n  (if (= 1 (count a))\n    (conj '() (conj '() (first a)))\n    (if (= (first a) (first (first (pack (rest a)))))\n      ;true\n      (do \n      (if (< 0 (count (rest (pack (rest a)))))\n        (do \n        ;(println (conj (rest (pack (rest a))) (conj (first (pack (rest a))) (first a))  ) )\n        (conj (rest (pack (rest a))) (conj (first (pack (rest a))) (first a)) )\n        )\n        (do \n        ;(println (conj '() (conj (first (pack (rest a))) (first a)) ) )\n        (conj '() (conj (first (pack (rest a))) (first a)) )\n        )\n      )\n\n      )\n      ;false\n      (do\n      ;; (print (first (rest a)))\n      ;; (print \"!=\")\n      ;; (print (first a))\n      (println)\n      ;(print (conj (pack (rest a)) (conj '() (first a)) )  )\n      (conj (pack (rest a)) (conj '() (first a)) )\n      )\n    )\n  )\n)\n)","user":"602bca69e4b0d5df2af22267"},{"code":"(fn [xs] \r\n          (reverse\r\n          (reduce (fn [coll n]\r\n                    (if (= n (first (first coll)))\r\n                      (conj (rest coll) (conj (first coll) n))\r\n                      (conj coll [n])))\r\n                  []\r\n                  xs)))","problem":31,"user":"4f07ad89535dcb61093f6c2a"},{"problem":31,"code":"(fn f [xs]\n  (if-let [x (first xs)]\n    (cons (take-while #(= x %) xs) (f (drop-while #(= x %) xs)))\n    nil))","user":"5d0bb4fae4b0cc9c91588237"},{"problem":31,"code":"(fn [x]\n (partition-by identity x))","user":"593744abe4b02506e01a299b"},{"problem":31,"code":"(fn pack\n  ([l] (pack l (first l) nil nil))\n  ([l prev current ret]\n   (let [x (first l)\n         xs (rest l)]\n     (cond (nil? x) (cons current ret)\n           (= prev x) (pack xs x (cons x current) ret)\n           :otherwise (cons current (pack l x nil ret))))))","user":"5717ad6fe4b07c98581c3b14"},{"problem":31,"code":"(fn pack\n  [s] (reverse (reduce\n                 (fn [p v]\n                   (if (= (ffirst p) v)\n                     (cons (cons v (first p)) (rest p))\n                     (cons (list v) p)))\n                 (list (list (first s)))\n                 (rest s))))","user":"6096d37be4b00e9e6653c3f0"},{"problem":31,"code":"(fn foo [x] (partition-by identity x))","user":"54078851e4b0addc1aec66bd"},{"problem":31,"code":"(fn [s]\n  (reverse\n   (reduce\n    (fn [acc x]\n      (let [[y & ys] acc]\n        (if\n          (= (first y) x)\n          (conj ys (conj y (first y)))\n          (conj acc (list x)))))\n    ()\n    s)))","user":"5b7f2d75e4b047b03b203768"},{"problem":31,"code":"(fn [c] \n  (partition-by identity c)\n)","user":"59c243bae4b0a024fb6ae4aa"},{"code":"(fn [lst]\n    (reduce (fn [x y]\n                (if (= (first (first x)) y)\n                    (conj (rest x) (conj (first x) y))\n                    (conj x (list y))))\n            ()\n            (reverse lst)))","problem":31,"user":"4f047902535dcb61093f6bcc"},{"problem":31,"code":"#(loop [lst (reverse %) prev (first lst) n 0 result nil]\n   (cond (empty? lst) (cons (repeat n prev) result)\n         (= (first lst) prev) (recur (rest lst) prev (inc n) result)\n         :else (recur (rest lst) (first lst) 1 (cons (repeat n prev) result))))","user":"5c62979fe4b0fca0c162264c"},{"problem":31,"code":"(fn [param]    \n   (let [result-map \n (#(reduce (fn [a v] (if\n                     (= (last (a :last-list)) v)\n                     (assoc a :last-list (concat (a :last-list) [v]))\n                     (assoc (assoc a :result-list (concat (a :result-list) [(a :last-list)])) :last-list [v]))) {:result-list [] :last-list []} %)\n  param)]\n     (concat (rest (result-map :result-list )) [(result-map :last-list)]))\n     \n     )","user":"53c73e8ae4b00fb29b2212a5"},{"code":"(fn [xs]\r\n  (let [[ys group] (reduce (fn [[acc group] x]\r\n                              (if (or (empty? group)\r\n                                      (= (first group) x))\r\n                                  [acc (conj group x)]\r\n                                  [(conj acc group) [x]]))\r\n                            [[] []] xs)]\r\n    (if (empty? group) ys (conj ys group))))","problem":31,"user":"4e8681b7535dae1a5effa438"},{"problem":31,"code":"(fn my-pack [vs]\n  (loop [[x & rxs :as xs] vs\n         prev x\n         count 0\n         zs []]\n    (if (empty? xs)\n      (conj zs (repeat count prev))\n      (if (= x prev)\n        (recur rxs prev (inc count) zs)\n        (recur rxs x 1 (conj zs (repeat count prev)))))))","user":"54a31fdae4b09f271ff37c64"},{"problem":31,"code":"(fn collect [thing]\n  (reverse\n   (loop\n     [lastseen nil\n      curthing thing\n      curlist (list)\n      results (list)]\n     (cond\n      (empty? curthing) (cons (cons lastseen curlist) results)\n      (nil? lastseen) (recur (first curthing) (rest curthing) curlist results)\n      (= (first curthing) lastseen) (recur lastseen (rest curthing) (cons (first curthing) curlist) results)\n      :else (recur (first curthing) (rest curthing) (list) (cons (cons lastseen curlist) results))))))","user":"5658d775e4b00d3155796114"},{"code":"(fn [xs]\n  (partition-by identity xs))","problem":31,"user":"4f9c7b0fe4b0dcca54ed6d1c"},{"problem":31,"code":"(fn [sequence] (loop [res [] i 0 size (count sequence)]\n    (if (= size i)\n      res\n      (let [curr_val     (nth sequence i)\n            previous_vec (or (last res) [])\n            previous_val (first previous_vec)\n            res          (if (= previous_val curr_val)\n                           (conj (pop res) (conj previous_vec curr_val))\n                           (conj res [curr_val]))]\n            (recur res\n                   (inc i)\n                   size)))))","user":"5dc53ddee4b02f9375f4e1bd"},{"problem":31,"code":"(fn [l]\n  (reverse (reduce (fn [a x] (if (= x (ffirst a))\n                               (conj (rest a) (conj (first a) x))\n                               (conj a (list x))))\n                   '() l)))","user":"55337e61e4b09218d5f44f8e"},{"code":"#(loop [result '() x %]\r\n    (if (empty? x)\r\n      (reverse result)\r\n      (let [y (take-while (partial = (first x))  x)]\r\n        (recur (conj result y) (drop (count y) x))))\r\n  )","problem":31,"user":"4ddc56e1535d02782fcbea04"},{"problem":31,"code":"(fn foo [x]\n\t\t\t\t(if (empty? x)\n\t\t\t\t\t\t\t\tx\n\t\t\t\t\t\t\t\t(cons\n\t\t\t\t\t\t\t\t\t\t\t\t(take-while (partial = (first x)) x)\n\t\t\t\t\t\t\t\t\t\t\t\t(foo (drop-while (partial = (first x)) x))\n\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t)\n)","user":"575dda55e4b02ea11479938c"},{"problem":31,"code":"(fn [l]\n  (partition-by identity l))","user":"54377355e4b032a45b869305"},{"problem":31,"code":"(fn [a-seq] (partition-by identity (vec a-seq)))","user":"51d26b0ae4b0d13b04db0d97"},{"problem":31,"code":"(fn f [r l s]\n    (if (empty? s)\n      (next (reverse (conj r l)))\n      (let [[x & xs] s\n            [y & ys] l]\n        (if (= y x)\n          (f r (conj l x) xs)\n          (f (conj r l) (list x) xs))))) '() '()","user":"4f24c859e4b0d66497709fef"},{"problem":31,"code":"(fn pack [s]\n        (loop [seq s\n               out []\n               tmp []]\n\n          (if (empty? seq)\n            (conj out tmp)\n            (let [f (first seq)\n                  ft (first tmp)\n                  next-tmp (cond (empty? tmp) [f]\n                                 (= ft f) (concat tmp [f])\n                                 :else [f])\n                  next-out (if (and (not (empty? tmp)) (not (= ft f)))\n                             (conj out tmp)\n                             out)]\n              (recur (rest seq) next-out next-tmp)))))","user":"52b065dbe4b0c58976d9acc9"},{"problem":31,"code":"(fn pack [coll]\n  (reduce (fn pack-fold [acc item]\n  (let [group (last acc)\n        val (last group)]\n    (if (= item val)\n      (conj (vec (butlast acc)) (conj group val))\n      (conj acc [item])))) [] coll))","user":"5dc40814e4b02f9375f4e1ae"},{"code":"#(reverse\n  (reduce\n    (fn [col n]    \n      (if (= (ffirst col) n)\n        (cons (cons n (first col)) (rest col)) \n        (cons (list n) col)))\n  '()\n  %))","problem":31,"user":"517cc671e4b0bbbf1f12af0a"},{"problem":31,"code":"(fn\n  [lst]\n  (partition-by identity lst))","user":"56df6498e4b0ca2494a095f8"},{"code":"(fn pack-seq [x]\n      (if (empty? x)\n        x\n        ;; find out how many consecutive duplicates of x are there\n        (concat (list (take ((fn how-many? [y]\n                         (if (= (first y)\n                                (first (rest y)))\n                           (+ 1 (how-many? (rest y)))\n                           1)) x) x))\n                (pack-seq (drop ((fn how-many? [y]\n                         (if (= (first y)\n                                (first (rest y)))\n                           (+ 1 (how-many? (rest y)))\n                           1)) x) x)))))","problem":31,"user":"52e17e66e4b09f7907dd1423"},{"problem":31,"code":";; (defn packs-consecutive-duplicates [sq]\n;;   (loop [last-same-items [(first sq)]\n;;          s (rest sq)\n;;          res []]\n;;     (cond (empty? s)\n;;           (conj res last-same-items)\n;;           (= (first last-same-items) (first s))\n;;           (recur (conj last-same-items (first s)) (rest s) res)\n;;           true\n;;           (recur [(first s)] (rest s) (conj res last-same-items))\n;;           )))\n;; (packs-consecutive-duplicates [1 1 2 1 1 1 3 3])\n\n(fn packs-consecutive-duplicates-2 [sq]\n  (loop [last-same-items (list (first sq))\n         s (rest sq)\n         res '()]\n    (cond (empty? s)\n          (reverse (conj res last-same-items))\n          (= (first last-same-items) (first s))\n          (recur (conj last-same-items (first s)) (rest s) res)\n          true\n          (recur (list (first s)) (rest s) (conj res last-same-items)))))","user":"5711ca24e4b09c608db7044b"},{"code":"#(loop [result [] current [] x 0]\n   (if (= x (count %))\n     (conj result current)\n     (recur (if (and (> x 0) (not= (nth % x) (nth % (dec x)))) (conj result current) result) \n            (if (and (> x 0) (not= (nth % x) (nth % (dec x)))) (conj [] (nth % x)) (conj current (nth % x))) \n            (inc x))\n     )\n   )","problem":31,"user":"52253004e4b01819a2de42fa"},{"problem":31,"code":"(fn [input]\n  (loop [i input tot []]\n    (if (empty? i)\n        tot\n        (if (= (last (last tot)) (first i))\n          (recur (rest i) (concat (butlast tot) (list (conj (last tot) (first i)))))\n          (recur (rest i) (concat tot (list (list (first i)))))))))","user":"5243e37ae4b076204b44fae3"},{"code":"(fn [sq]\n  (loop [s sq acc []]\n    (if-let [h (seq (take-while #(= (first s) %) s))]\n      (recur (drop (count h) s) (conj acc h))\n      acc)))","problem":31,"user":"4f36f5f2e4b0e243712b1ece"},{"problem":31,"code":"(fn [l] \n  (loop [cl   []\n         more l\n         pe   nil]\n    (if (nil? more)\n      (conj cl pe)\n      (if (nil? pe)\n        (recur cl (next more) [(first more)])\n        (if (= (first pe) (first more))\n          (recur cl (next more) (conj pe (first pe)))\n          (recur (conj cl pe) (next more) [(first more)]))))))","user":"56051095e4b08b23635d3162"},{"problem":31,"code":"reduce #(if (= (first (last %1)) %2) (conj (pop %1) (conj (last %1) %2)) (conj %1 [%2]) ) []","user":"5921a080e4b09b4ee5954c77"},{"problem":31,"code":"(fn\n  [s]\n  \t(loop [i 0, running-dup [(nth s i)], result []]\n      (let [j (inc i), next-val (nth s j)]\n        (if (= (+ j 1) (count s))\n          (if (= next-val (last running-dup))\n            (conj result (conj running-dup next-val))\n            (conj result running-dup [next-val]))\n          (if (= next-val (last running-dup))\n            (recur j (conj running-dup next-val) result)\n            (recur j [next-val] (conj result running-dup)))))))","user":"5dc9ccf8e4b02f9375f4e1f1"},{"code":"#(partition-by (fn [x] x) %)","problem":31,"user":"4df1e213535d08e6dec9fe20"},{"code":"(fn f\n   ([s] (f s []))\n   ([[h & t :as s] a]\n    (if (seq s)\n    (let [la  (last a)\n          fla (first la)\n          bla (apply vector (butlast a))\n          a'  (if (= h fla) (conj bla (conj la h)) (conj a [h]))]\n      (f t a'))\n    a)))","problem":31,"user":"4dda44f2535d02782fcbe9f1"},{"code":"(fn[x] (\n    reverse (reduce \n      #(if (= (ffirst %1) %2) \n          (cons (cons %2 (first %1)) (rest %1)) \n          (cons (cons %2 ()) %1) \n        ) \n      () x)\n  )\n)","problem":31,"user":"4fce75cfe4b03432b189f400"},{"problem":31,"code":"(fn [sequence]\n  (letfn [(inner [result pre-sub-list pre rest1]\n            (if (not (empty? rest1))\n              (if (= pre (first rest1))\n                (inner result (conj pre-sub-list (first rest1)) pre (rest rest1))\n                (inner (if (empty? pre-sub-list)\n                         result\n                         (conj result pre-sub-list))\n                       (list (first rest1))\n                       (first rest1)\n                       (rest rest1)))\n              (reverse (if (empty? pre-sub-list)\n                         result\n                         (conj result pre-sub-list)))))]\n    (if (string? sequence)\n      (apply str (inner '() '() nil (seq sequence)))\n      (inner '() '() nil sequence))))","user":"58637f03e4b0f14aab7c881e"},{"code":"(fn pk [lt]\n  ((fn pack [prev cluster coll]\n     (if (< 0 (count coll))     \n      (let [[f & r] coll]\n         (if (= f prev)\n            (pack prev (conj cluster prev) r)\n           (conj (pack f '() r) (conj cluster prev))))\n     (list (conj cluster prev))))\n   (first lt) '() (rest lt)))","problem":31,"user":"503c02e5e4b0fc0f99c2e54e"},{"problem":31,"code":"(fn [sq]\n  (loop [sq-it sq\n         tmp '()\n         ret-it '()]\n    (if (and (empty? sq-it)\n             (empty? tmp))\n      ret-it\n      (if (or (empty? tmp)\n              (= (first sq-it) (first tmp)))\n        (recur (rest sq-it)\n               (cons (first sq-it) tmp)\n               ret-it)\n        (recur sq-it\n               '()\n               (concat ret-it\n                       (list tmp)))))))","user":"559d33b3e4b0ec2b359424d9"},{"problem":31,"code":"(fn pack-seq [xs]\n  ((fn f [result input]\n     (if (empty? input)\n       (reverse result)\n\n       (f\n        ;; determine the result based on the case\n        (if (= (first input) (ffirst result))\n          ;; take first result, append first input, prepend to rest result\n          (conj (rest result)\n                (conj (first result) (first input)))\n\n          ;; create a new list and prepend that list to result\n          (conj result (list (first input))))\n        \n        ;; \n        (rest input)\n        )\n       )) () xs))","user":"5641296de4b08d4f616f5ef4"},{"problem":31,"code":"(fn [li]\n  (loop [l li\n         m []\n         r []]\n    ;(println r)\n    (if (empty? l)\n      (conj r m)\n      (if (= (first l) (last m))\n        (recur (rest l) (conj m (first l)) r)\n        (if (empty? m)\n          (recur (rest l) (vector (first l)) r)\n          (recur (rest l) (vector (first l)) (conj r m)))))))","user":"5ac9c737e4b0e27600da77d2"},{"code":"(fn [l]\n  (letfn [(mypack [c r l]\n    (if (empty? l)\n        (list r)\n        (if (= c (first l))\n            (mypack c (cons c r) (rest l))\n            (cons r (mypack (first l) (list (first l)) (rest l))))))]\n    (mypack (first l) '() l)))","problem":31,"user":"4ede8e1d535d10e5ff6f5339"},{"code":"(fn f [xs]\n  (when-not (empty? xs)\n  (let [[fi s] (split-with #(= (first xs) %) xs)]\n    (concat [fi] (f s)) \n  ))\n)","problem":31,"user":"50ab8ae3e4b01d6eb43ce9a0"},{"problem":31,"code":"(fn [xs]\n  (loop [xs xs p [] x []]\n     (cond\n      (empty? xs)\n      (if (empty? x)\n        p\n        (conj p x))\n      (and (not (empty? x))\n           (= (first x)\n              (first xs)))\n      (recur (rest xs)\n             p\n             (conj x (first x)))\n      true\n      (recur (rest xs)\n             (if (empty? x)\n               p\n               (conj p x))\n             [(first xs)])\n      )))","user":"5fa8424ce4b0fa27300f3de5"},{"code":"(fn pack [l]\n  (when-let [[f & r] (seq l)]\n    (if (= f (first r))\n      (pack (cons (list f (first r)) (rest r)))\n      (if (sequential? f)\n        (if (= (first f) (first r))\n          (pack (cons (cons (first r) f) (rest r)))\n          (if (= (count r) 1)\n            (list f r)\n            (cons f (pack r))))\n        (cons (list f) (pack r))))))","problem":31,"user":"5368a275e4b0243289761e8f"},{"code":"(fn [coll] (partition-by (fn [x] x) coll))","problem":31,"user":"4e7f7e48535db966e863cc42"},{"code":"(fn [s] \n  (partition-by identity s))","problem":31,"user":"4ec3b393535dcc7ae8597d59"},{"problem":31,"code":"(fn [lst] (reduce \n           #(if (= (first (last %1)) %2)\n              (conj (vec (butlast %1)) (conj (vec (last %1)) %2))\n              (conj (vec %1) [%2]))\n           []\n           lst))","user":"5979cd36e4b02382a38ad1d8"},{"problem":31,"code":"(fn[seq1] (partition-by identity seq1))","user":"55757e81e4b05c286339e063"},{"problem":31,"code":"(fn packlist \n  ([l] \n   (if (empty? l)\n     [] \n\t (packlist [] [(first l)] (rest l) )\n   )\n  )\n  ([acc,currentList,remaining]    \n     (if (empty? remaining) \n       (conj acc currentList)\n       (if (or (empty? currentList) (= (first currentList) (first remaining)))\n         (packlist acc (conj currentList (first remaining)) (rest remaining)  )\n         (packlist (conj acc currentList) [(first remaining)] (rest remaining)  )\n       )\n     )\n  )\n)","user":"55d35a01e4b0e31453f64a63"},{"problem":31,"code":"(fn [s]\n  (loop [rs (list)\n         ws s]\n    (if (empty? ws)\n      (reverse rs)\n      (let [[front back] (split-with (partial = (first ws)) ws)]\n        (recur (conj rs front) back)))))","user":"56082adae4b046a4fc0ac008"},{"problem":31,"code":"(fn f [s]\n   ((fn q [s result intermediate]\n      (if (empty? s)\n        (seq (conj result (seq intermediate)))\n        (if (= (first s) (first intermediate))\n          (q (rest s)\n             result\n             (conj intermediate (first s)))\n          (q (rest s)\n             (conj result (seq intermediate))\n             [(first s)]))))\n    (rest s)\n    []\n    [(first s)]))","user":"54d26316e4b0e8a36923e5f2"},{"problem":31,"code":"#(reduce (fn [packs e]\n            (let [last-pack (peek packs)\n                  last-pack-index (dec (count packs))\n                  pack-element (first last-pack)]\n              (if (= pack-element e)\n                (assoc packs last-pack-index (conj last-pack e))\n                (conj packs (list e)))))\n          []\n          %)","user":"5d1be50ce4b02ea6f0fb6986"},{"code":"(fn [ls]\n  (let [[sf w t]\n        (reduce (fn [[sf w t] i]\n                  (if (= t i)\n                    [sf (conj w t) t]\n                    [(conj sf w) (list i) i]))\n                [[] (list) (first ls)]\n                ls)]\n    (seq (conj sf w))))","problem":31,"user":"5392b849e4b0b51d73faaeb1"},{"problem":31,"code":"(fn my-pack\n  [coll]\n  (partition-by identity coll))","user":"54091b82e4b0addc1aec66d5"},{"code":"(fn [coll]\n    ( (fn [coll last ret]\n\t(if (empty? coll)\n\t  (reverse ret)\n          (if (= (first coll) last)\n      \t    (recur (rest coll) (first coll) (conj (rest ret)\n                                                  (concat (first ret) (first coll))\n                                                  ))\n            (recur (rest coll) (first coll) (conj ret (first coll)))\n            )))\n      (map list coll) nil '())\n    )","problem":31,"user":"51b8e0dce4b050a1176cd69f"},{"code":"(fn [x]\n    (loop [last nil\n           todo x\n           res []]\n      (if (empty? todo)\n        res\n        (let [f (first todo)\n              r (next todo)]\n          (if (= f last)\n            (recur f r (conj (pop res) (conj (peek res) f)))\n            (recur f r (conj res (list f)))\n            )\n          )\n        )\n      )\n    )","problem":31,"user":"5165a235e4b079ad97ec44ac"},{"problem":31,"code":"#(loop [[a & rst] %\n        result []\n        pack []\n        prv nil]\n   (if (nil? a)\n     (seq (conj result pack))\n     (if (or (= a prv) (nil? prv))\n       (recur rst result (conj pack a) a)\n       (recur rst (conj result pack) [a] a))))","user":"57b5dc52e4b0fbc9809a27b3"},{"code":"(fn groups [[a b & c]]\n  (cond (nil? a)                      '()\n        (and (= a b)(= a (first c) )) (conj (groups (rest c)) (list a b (first c)) )\n        (= a b)                       (conj (groups c) (list a b) )\n        :else                         (conj (groups (conj c b)) (list a) ) ))","problem":31,"user":"53120cb5e4b08068f379ecf0"},{"code":"(fn [coll]\n    (let [len (count coll)]\n      (loop [i 0, todo coll, tmp '(), res '()]\n        (let [i1 (first todo)\n              i2 (second todo)]\n          (cond (< i (dec len))\n                (if (= i1 i2)\n                  (recur (inc i) (rest todo) (cons i1 tmp) res)\n                  (recur (inc i) (rest todo) '() (cons (cons i1 tmp) res)))\n                :else (reverse (cons (cons i1 tmp) res)))))\n      ))","problem":31,"user":"50bc23e4e4b0594b91591c3c"},{"code":"(fn pack\r\n  [lista]\r\n\t(if-not (empty? lista)\r\n\t\t(let [sp (split-with #(= % (first lista)) lista)]\r\n\t\t\t(concat (drop-last sp) (pack (last sp))))))","problem":31,"user":"4e8a0c82535d3e98b802328d"},{"problem":31,"code":"(fn\n            [s]\n            (loop [last-val (first s)\n                   s (seq s)\n                   group []\n                   result []]\n              (if (empty? s)\n                (conj result group)\n                (let [first-val (first s)]\n                  (if (= last-val first-val)\n                    (recur first-val (rest s) (conj group first-val) result)\n                    (recur first-val (rest s) [first-val] (conj result group))\n                    )\n                  )\n                )\n              )\n            )","user":"60631c2ee4b069485764ddbd"},{"problem":31,"code":"(fn packer [x] \n  (loop [final '() buffer (list (first x)) remainder (rest x)]\n    (if (empty? remainder) \n      (concat final (list buffer))\n      (recur\n        (if (= (last buffer) (first remainder))\n          final \n          (concat final (list buffer)))\n        (if (= (last buffer) (first remainder))\n          (concat buffer (list (first remainder)))\n          (list (first remainder)))\n               \n        (rest remainder)))))","user":"57b167afe4b0fbc9809a2752"},{"problem":31,"code":"(fn f [coll] \n    (let [[xs tail] (split-with (partial = (first coll)) coll)]\n      (if (empty? tail) [xs] (concat [xs] (f tail)))))","user":"5566d812e4b0c656e3ff1837"},{"problem":31,"code":"(fn test [coll]\n  (loop [[head & tail] coll\n         result []]\n    (if (nil? head)\n      result\n      (if (some #(= % head) (last result))\n        ;(recur tail (assoc result (dec (count result)) (conj (last result) head)))\n        (recur tail (assoc (vec result) (dec (count result)) (conj (last result) head)))\n        (recur tail (concat result [[head]]))\n       )\n    )\n  )\n )","user":"54021f13e4b0df28a13c62cc"},{"problem":31,"code":"(fn remove-duplicates [xs]\n  (lazy-seq\n    (when (seq xs)\n      (cons (take-while #(= (first xs) %) xs)\n            (remove-duplicates\n              (drop-while #(= (first xs) %) (rest xs)))))))","user":"53ce0a29e4b00fb29b2212eb"},{"code":"(fn [x]\n  (loop [[h & t] x\n         past []\n         out []]\n    (if (nil? h)\n      (conj out past)\n      (if (= h (last past))\n        (recur t (conj past h) out)\n        (recur t [h] (if (empty? past) out (conj out past)))))))","problem":31,"user":"52d469c8e4b09f7907dd1330"},{"problem":31,"code":"(fn [s]\n  (seq (map seq\n            (reduce (fn [acc cur]\n                      (if (= (first (last acc)) cur)\n                        (update-in acc [(dec (count acc))] conj cur)\n                        (conj acc [cur])))\n                    []\n                    s))))","user":"5d431c77e4b07c84aa5ae68f"},{"problem":31,"code":"(fn [setToPack] (reverse (reduce (fn [theSet theItem] (if (= (first (first theSet)) theItem) (cons (cons theItem (first theSet)) (rest theSet)) (cons (list theItem) theSet)))  '() setToPack)))","user":"554bc64ae4b0a04f79299598"},{"code":"(fn collm [s] (reverse (\n(fn collectem [i r]\n  (if (= (first i) nil)\n      r\n      (let [\n              fi (first i)\n              fr (first r)\n              i2 (rest i)\n              r2 (if (= fr nil)\n                     (cons (cons fi [])  r)\n                     (if (= fi (first fr))\n                         (cons (cons fi fr) (rest r))\n                         (cons (cons fi []) r)\n                    )\n                 )\n           ]\n           (collectem i2 r2)\n      )\n  )\n)\ns []\n)))","problem":31,"user":"4ec17677535dfed6da9c6dad"},{"problem":31,"code":"(fn [l]\n  (partition-by identity l)\n  )","user":"558843dae4b059ccff29b1f3"},{"problem":31,"code":"(fn [s]\n  (reverse\n   (reduce (fn [[last-pack & packed] next-elem]\n             (if (or (= (first last-pack) next-elem)\n                     (nil? last-pack))\n               (concat (list (cons next-elem last-pack)) packed)\n               (concat (list (list next-elem)) (list last-pack) packed)))\n           '()\n           s)))","user":"552d487ee4b076ab5578f7e4"},{"code":"(fn pack\n  [sq]\n  (if (empty? sq)\n    nil\n    (concat\n      (list\n        (take-while\n          #(= (first sq) %)\n          sq))\n      (pack\n        (drop-while\n          #(= (first sq) %) sq)))))","problem":31,"user":"504e12ade4b078edc5f593b7"},{"problem":31,"code":"reduce (fn [coll x]\n          (if (= (last (last coll)) x)\n            (conj (subvec coll 0 (dec (count coll))) (conj (last coll) x))\n            (conj coll (vector x) ))) []","user":"5f38eecce4b0574c87022c72"},{"code":"(fn sdupl [coll]\n    (lazy-seq\n      (when (seq coll) \n        (let [h (first coll) [head tail] (split-with #(= h %) coll)] (cons head (sdupl tail))))))","problem":31,"user":"50eddbc4e4b06330c1f87c4b"},{"problem":31,"code":"(fn [x]\n  (loop [result [], coll x]\n    (let [pred #(= % (first coll))\n          matches (take-while pred coll)\n          nexts (drop-while pred coll)]\n      (if (empty? coll) \n        result\n        (recur (conj result matches) nexts)\n       )\n    ))\n  )","user":"50523848e4b0a561d07d8f1a"},{"problem":31,"code":"(fn [s]\n  (loop [src s\n         current nil\n         occurences 0\n         result []]\n    (if (seq src)\n      (cond \n        (nil? current) (recur (rest src) (first src) 1 result)\n        (= (first src) current) (recur (rest src) current (inc occurences) result)\n        :else (recur (rest src) (first src) 1 (conj result (repeat occurences current))))\n      (conj result (repeat occurences current)))))","user":"53c649d3e4b00fb29b221297"},{"problem":31,"code":"#(rest\n  ((fn pack [sq]\n  (loop [elts sq acc [] t-acc [] lst nil]\n    ( let [same? (= (first elts) (last t-acc))\n           n-acc (if same? acc (conj acc t-acc))\n           n-t-acc (if same? (conj t-acc (first elts)) [(first elts)])]\n      (if (empty? elts) (conj acc t-acc)\n          (recur (rest elts) n-acc n-t-acc (first elts)))))) %))","user":"54302691e4b0dad94371f2d7"},{"problem":31,"code":"(fn group-iden [col]\n  (->> col\n       (reduce (fn [col n]\n                 (if (= (peek col) n)\n                   (conj col n)\n                   (conj col :sep n)\n                   ))\n               [])\n       (partition-by #(= :sep %))\n       (filter #(not= '(:sep) %))))","user":"569dd6e8e4b0542e1f8d1480"},{"problem":31,"code":"(fn [ls]\n  (let [itr (fn [ls a b]\n            (if (empty? ls)\n                b\n              (if (= (first ls) (second ls))\n                (recur (rest ls) (cons (first ls) a) b)\n                (recur (rest ls) '() (cons (cons (first ls) a) b)))))]\n    (reverse (itr ls '() '()))))","user":"56d7f340e4b0ea9b8538f7df"},{"problem":31,"code":"#(loop [out []\n        coll %]\n   (if (empty? coll)\n     out\n     (let [sub (take-while (fn [x] (= (first coll) x)) coll)]\n       (recur (conj out sub) (drop (count sub) coll)))))","user":"59902fede4b0fcebec4de86d"},{"problem":31,"code":"#(partition-by identity%)","user":"5a2834dfe4b07f18be40aa64"},{"code":"partition-by #(list %)","problem":31,"user":"4e71da4d535d5021c1a89653"},{"problem":31,"code":"reduce #(if\n        (and \n          (> (count %1) 0) \n          (= (first (last %1)) %2))\n          (let [last-group (last %1)]\n            (concat (drop-last 1 %1) [(conj last-group %2)]))\n          (concat %1 [(list %2)]))\n[]","user":"5f331015e4b0574c87022c37"},{"code":"(fn pack [in] (partition-by identity in))","problem":31,"user":"50fe2420e4b03cd852b4e84a"},{"code":"(fn pack [se]\n  (loop [s (next se), prev (first se), currgroup (list (first se)), res []]\n    (cond (= s nil) (conj res currgroup)\n          (= (first s) prev) (recur (next s) (first s) (conj currgroup (first s)) res)\n          :else (recur (next s) (first s) (list (first s)) (conj res currgroup)))))","problem":31,"user":"534941d1e4b084c2834f4a60"},{"code":"(fn [list]\n  (reverse (loop [x (first list) xs (rest list) acc '() cur_dup '()]\n    (if (nil? x)\n      (conj acc cur_dup)\n      (if (= x (first cur_dup))\n        (recur (first xs) (rest xs) acc (conj cur_dup x))\n        (if (empty? cur_dup)\n          (recur (first xs) (rest xs)\n            acc (conj cur_dup x))\n          (recur (first xs) (rest xs)\n            (conj acc cur_dup) (cons x '()))))))))","problem":31,"user":"4dafa380edd6309eace4d17c"},{"problem":31,"code":"(fn [input]\n  (loop [xs input, out []]\n    (if (empty? xs) out\n      (let [equals-first #(= (first xs) %)]\n        (recur (drop-while equals-first xs) (conj out (take-while equals-first xs)))))))","user":"5885cc62e4b0f1effa3b76c1"},{"problem":31,"code":"(fn pack-seq [xs]\n        (loop [rem-xs xs, acc '[]]\n          (if (empty? rem-xs)\n            acc\n            (let [pred (fn [x] (= x (first rem-xs)))]\n             (recur (drop-while pred rem-xs) (conj acc (take-while pred rem-xs)))))))","user":"54ecd716e4b024c67c0cf85a"},{"problem":31,"code":"(fn pack\n  [lst]\n  (if (empty? lst)\n    ()\n    (loop [aux (first lst)\n           result ()\n           auxl ()\n           lst lst]\n      (if (empty? lst)\n        (reverse (cons auxl result))\n        (if (= (first lst) aux)\n          (recur aux result (cons (first lst) auxl) (rest lst))\n          (recur (first lst) (cons auxl result) (empty auxl) lst))))))","user":"5a9f005be4b0d174b936c810"},{"code":"#(reverse (reduce (fn pack [a b]\n  (if (= (first (first a))  b)\n    (conj (rest a) (conj (first a) b))\n    (conj a (list b)))) '() %))","problem":31,"user":"4ea7999e535d7eef308072ee"},{"problem":31,"code":"reduce (fn [x y] (if (= (first (last x)) y)\n                   (conj (pop x) (conj (last x) y))\n                   (conj x (list y)))) []","user":"5753b6c6e4b02ea1147992af"},{"problem":31,"code":"(fn [sequ]\n  (reduce\n   \t(fn\n      [accu value]\n      (if\n        (= (last (last accu)) value)\n        (concat (drop-last accu) (list (cons value (last accu))))\n        (concat accu (list (list value)))))\n    []\n    sequ))","user":"5ffee617e4b074f607df6605"},{"problem":31,"code":"(fn [x] (loop [data x sublist () result () flag false]\n          (if-not (first data)\n            (reverse result)\n            (if (= (first data) (second data))\n            \t(recur (rest data) (cons (first data) sublist) result true)\n                (if (true? flag)\n                  (recur (rest data) () (cons (cons (first data) sublist) result) false)\n                  (recur (rest data) sublist (cons (list (first data)) result) false)\n)))))","user":"567f034be4b0feffd0d18eba"},{"code":"(fn grp [s] \n   (loop [result []\n          s s]\n     (if-let [e (first s)]\n       (recur (conj result (take-while #(= e %) s)) (drop-while #(= e %) s))\n       result)))","problem":31,"user":"534d1173e4b084c2834f4a98"},{"code":"(fn packit [lst]\n  (letfn [(mainlist [lst acc]\n                    (if (seq lst)\n                      (let [[one two] lst]\n                        (if (= one two)\n                          (sublist one lst acc [])\n                          (mainlist (rest lst) (conj acc (vector one)))))\n                      acc))\n          (sublist [want lst acc acc2]\n                   (if (seq lst)\n                     (let [[one two] lst]\n                       (if (= one want)\n                         (sublist want (rest lst) acc (conj acc2 one))\n                         (mainlist lst (conj acc acc2))))\n                     (conj acc acc2)))]\n    (mainlist lst [])))","problem":31,"user":"51750cd4e4b07031762f2ee5"},{"problem":31,"code":"(fn packer\n  [input]\n  (loop [xs input temp [] ys []]\n    (if (empty? xs)\n    (conj ys temp)\n    (if (= (first xs) (first temp))\n    (recur (rest xs) (conj temp (first xs)) ys)\n    (recur (rest xs) [(first xs)] (if (empty? temp) ys (conj ys temp)))))))","user":"53de4bdae4b0d874e779ae32"},{"problem":31,"code":"#(reverse (reduce (fn\n           [result item]\n           (if ((set (first result)) item)\n             (cons (conj (first result) item) (rest result))\n             (conj result (list item))))\n        '()\n        (seq %)))","user":"53f31dafe4b0742d9025b0f0"},{"problem":31,"code":"(fn [args] (partition-by identity args))","user":"53882352e4b0640c7a9a5898"},{"code":"(fn pack-seq [s]                                                                                               \n  (let [[fst & rst] s                                                                                            \n        pred (partial = fst)]                                                                                    \n    (if (empty? s)                                                                                               \n      s                                                                                                          \n      (cons (take-while pred s) (pack-seq (drop-while pred s))))))","problem":31,"user":"509e8da7e4b08df8156e9e2f"},{"problem":31,"code":"(fn pk*\n  \t([src] (pk* '() src))\n\t([trg src] (if (empty? src) trg\n\t\t(pk* (concat trg (list (take-while #(= (first src) %) src)))\n\t\t\t\t(drop-while #(= % (first src)) src))\n\t))\n)","user":"575ddfd1e4b02ea11479938d"},{"problem":31,"code":"(fn grp [[x & xs :as l]]\n  (if (empty? l)\n    nil\n    (cons (take-while (partial = x) l) (grp (drop-while (partial = x) l)))))","user":"5396c94be4b0b51d73faaee3"},{"problem":31,"code":"(fn grp[coll]\n  (loop [cur '()\n         acc []\n         [a & more :as all] coll]\n    (if\n      all\n      (if\n        (or (empty? cur) (= a (last cur)))\n        (recur (conj cur a) acc more)\n        (recur (cons a '()) (conj acc cur) more)\n      )\n      (conj acc cur)\n    )\n  )\n)","user":"5ba75fdfe4b0a20761a23419"},{"problem":31,"code":"#(reverse (into '() (reduce (fn\n                              [pre cur]\n                              (if (or (empty? pre) (not (= (last (last pre)) cur)))\n                                (conj pre (list cur))\n                                (conj (vec (butlast pre)) (conj (last pre) cur)))) [] %)))","user":"51071f2ee4b05b2b4eee748e"},{"problem":31,"code":"(fn func [x]\n  (loop [now (first x)\n        later (rest x)\n        result []]\n        (if (nil? now)\n          result\n          (recur\n            (first later)\n            (rest later)\n           \t(let [curr (last result)]\n              (if (nil? curr)\n                (conj result (vector now))\n                (conj (if (= (last curr) now)\n                        (pop result)\n                        result)\n                      (if (= (last curr) now)\n                        (conj curr now)\n                        (vector now)))))))))","user":"5bb948f5e4b0a20761a235d5"},{"code":"(fn pack [arg]\n   (reverse\n   (loop [in arg sub '() res '()]\n     (if (empty? in)\n       (conj res sub)\n       (let [insub (or (= (first in) (first sub)) (empty? sub))]\n         (recur\n          (rest in)\n          (if insub (conj sub (first in)) (list (first in)))\n          (if insub res (conj res sub))))))))","problem":31,"user":"51684318e4b03f62cda68cd6"},{"problem":31,"code":"#(reduce \n    (fn [a e]\n        (if (not= (first (last a)) e)\n         (conj a [e])\n         (conj (vec (drop-last a)) (conj (last a) e))))\n    []\n    %)","user":"4e55b3dc535d8a8b8723a27f"},{"problem":31,"code":"(fn [coll] (reduce (fn [acc n] (if (= n (peek (last acc))) (conj (pop acc) (conj (peek acc) n)) (conj acc [n]))) [] coll))","user":"5d4f21f3e4b0776584bd6f4e"},{"code":"reduce #(do (println %1 %2)\n           (cond (empty? %1)\n                   (list (list %2))\n                 (and (empty? (butlast %1)) (= (first (last %1)) %2))\n                   (list (conj (last %1) %2))\n                 (empty? (butlast %1)) \n                   (concat (list (last %1) (list %2)))\n                 (= (first (last %1)) %2)\n                   (concat  (butlast %1) (list (conj (last %1)  %2)))\n                 :elth\n                   (concat  %1 (list (list %2))))) ()","problem":31,"user":"53858594e4b06839e8705f05"},{"code":"(fn [s]\n   (reduce (fn [a b] (if (= b (first (last a)))\n                       (conj (vec (butlast a)) (conj (last a) b))\n                       (conj (vec a) (list b))))\n           (list (list (first s)))\n           (rest s)))","problem":31,"user":"5101b52ce4b0a79bcc8c0e0f"},{"code":"(fn [coll]\n    (loop [in (rest coll), out [], current (list (first coll)), last (first coll)]\n\t\t\t(if ( empty? in)\n\t\t\t\t(seq (conj out current))\n\t\t\t\t(if (= (first in) last)\n\t\t\t\t\t(recur (rest in) out (cons last current) last)\n\t\t\t\t\t(recur (rest in) (conj out current) (list (first in)) (first in))))))","problem":31,"user":"4e6a63fd535d8ccf87e9feda"},{"code":"(fn [x] \n  ((fn pack [x y]\n    (if-let [[f & r] x]\n      \n      (if (= (last y) f)\n        (pack r (cons f y))\n        (cons y (pack r (list f)))\n      )\n      (if (= (last y) x)\n        (cons x y)\n        (list y)\n      )\n    )\n  ) (next x) (list (first x)))\n)","problem":31,"user":"51bec919e4b013aa0d74b800"},{"code":"(fn d[x]\n  (let [xm (rest x) sem (list (first x))]\n  (loop [xx xm se sem tot ()]\n      (do (println xx se tot)\n      (if (empty? xx)\n          (concat tot (list se))\n          (recur \n             (rest xx) \n               (if (= (first xx) (last se)) \n                   (concat se (list (first xx)))\n                   (list (first xx)))\n               (if (= (first xx) (last se))\n                   tot\n                   (concat tot (list se)))))))))","problem":31,"user":"4f891abde4b033992c121c77"},{"code":"#(rest(reverse(last(reduce (fn [[a [h & r]] v] (if (= a v) [a (cons (cons a h) r)] [v (cons (list v) (cons h r))])) [nil ()] %))))","problem":31,"user":"4e7f4147535db966e863cc3d"},{"code":"(fn [xs]\n  (loop [xs xs, ys '()]\n    (if (empty? xs) (reverse ys)\n      (let [[x & xs] xs, [y & ys :as yys] ys]\n        (if (= x (first y))\n          (recur xs (cons (cons x y) ys))\n          (recur xs (cons (list x) yys)))))))","problem":31,"user":"4ee67d74535d93acb0a66861"},{"code":"#(loop [col  %  c '() ret []]\r\n    (if (empty? col)\r\n      ret\r\n      (let [add_must_done (or (empty? (rest col)) (not (= (first col) (first (rest col)))))]\r\n      (recur\r\n      \r\n          (rest col) (if add_must_done '() (conj c (first col))  ) (if add_must_done (conj ret (conj c (first col))) ret  )))))","problem":31,"user":"50463347e4b011c5dfee771e"},{"code":"(fn pack [coll]\n  (when (not-empty coll)\n    (let [[f & r] (seq coll)\n          [x xs] (split-with #(= % f) coll)]\n      (cons x (pack xs)))))","problem":31,"user":"539a2901e4b0b51d73faaf0f"},{"code":"(fn s\n   ([in] (let [a (split-with #(= (first in) %) in)] (s (list (first a)) (last a))))\n   ([out in] (if (empty? in) (reverse out) (let [a (split-with #(= (first in) %) in)] (s (conj out (first a)) (last a))))))","problem":31,"user":"4fa39b3ee4b081705acca191"},{"code":"(fn [xs]\r\n    (loop [xs xs x1 '() ys '()]\r\n      (if (empty? xs)\r\n        (reverse ys)\r\n        (let [[x & xxs] xs]\r\n          (if (= x x1)\r\n            (recur xxs x (cons (cons x (first ys)) (rest ys)))\r\n            (recur xxs x (cons (list x) ys)))))))","problem":31,"user":"4ddc1c89535d02782fcbea01"},{"problem":31,"code":"#(reverse\n (reduce (fn [res n] \n          (if ( = n (first (first res)))\n            (conj (rest res) (conj (first res) n))\n            (conj res (list n)))) () %))","user":"58566b42e4b0f14aab7c86f4"},{"problem":31,"code":"(fn [eles]\n  (if (empty? eles)\n    eles\n    (reverse (reduce (fn [[repeats & existing] new-ele]\n                       (if (= (first repeats) new-ele)\n                         (conj existing (conj repeats new-ele))\n                         (conj existing repeats (list new-ele))))\n                     (list (list (first eles)))\n                     (rest eles)))))","user":"55d95be7e4b0e31453f64ac9"},{"code":"(fn [iput]\n\n (reverse  (reduce #(if (= (first (first  %1)) %2) (cons (cons %2 (first %1)) (rest %1)) (cons (list %2) %1))  []  iput)\n  \n))","problem":31,"user":"5124619ae4b02c3f2a072ccd"},{"problem":31,"code":"(fn pack-seq\n    ([[element & rest :as sequence]]\n      (if (empty? sequence) \n        () \n        (pack-seq rest element 1)))\n    ([[element & rest :as sequence] cur count]\n      (cond\n        (empty? sequence) (list (repeat count cur))\n        (= element cur) (recur rest element (inc count))\n        :else (lazy-seq (cons (repeat count cur) (pack-seq rest element 1))))))","user":"55d354e0e4b0e31453f64a62"},{"problem":31,"code":"(fn [col]\n     (reverse (reduce\n                (fn [res cur]\n                  (if (= (first (first res)) cur)\n                    (do\n                      (conj (drop 1 res) (conj (first res) cur))\n                      )\n\n                    (conj res (list cur)))\n                  ) '() col))\n     )","user":"55ee84c0e4b0121d4835fdf0"},{"problem":31,"code":"(fn [x]\n  (let [\n        pack (fn [xs x]\n               (if (= (last (last xs)) x)\n                   (assoc xs (- (count xs) 1) (conj (last xs) x))\n                   (conj xs (seq [x]))\n             ))\n       ]\n       (sequence (reduce pack [] (into [] x)))\n  ))","user":"582835cbe4b051871117bf30"},{"problem":31,"code":"(fn [xs]\n  (loop [xs xs\n         group '()\n         res '()]\n    (cond (empty? xs)\n          (reverse (cons group res))\n          (= (first xs) (first group))\n          (recur (rest xs) (cons (first xs) group) res)\n          (empty? group)\n          (recur (rest xs) (list (first xs)) res)\n          :else\n          (recur (rest xs) (list (first xs)) (cons group res)))))","user":"54961073e4b0b312c081ff62"},{"code":"(fn [arg]\n  (loop [acol (seq arg) rcol ()]\n    (if (empty? acol)\n      (reverse rcol)\n      (recur (rest acol) \n        (let [firstcol (first rcol)]\n          (if (= (first firstcol) (first acol))\n            (cons (cons (first acol) firstcol) (rest rcol))\n            (cons (list (first acol)) rcol)\n            )\n          )\n        )\n      )\n    )\n  )","problem":31,"user":"4db7da66535d1e037afb2187"},{"problem":31,"code":"(fn [xs] (drop-last ((fn pack-seq [xs]\n    (let [\n        n_ (fn n_ [xs] (if-not (empty? xs) \n            (if (= (first xs) (second xs)) \n                (+ 1 (n_ (next xs))) 1) 0))\n        packtor (fn packtor [ys] (take (n_ ys ) ys))]\n        (conj (when-not (empty? xs) \n            (pack-seq (drop (n_ xs) xs))) \n                (when-not (empty? xs)(packtor xs)))))xs)))","user":"5fa358a1e4b0f0ebd91b77fd"},{"problem":31,"code":"(fn [l](partition-by identity l))","user":"515d414be4b00901442db1db"},{"problem":31,"code":"(fn pack [seq]\n  (let [f (fn [acc curr]\n            (if (empty? acc)\n              [[curr]]\n              (let [last-list (last acc)\n                    elem (first last-list)]\n                (if (= elem curr)\n                  (let [without-last (pop acc)]\n                    (conj without-last (conj last-list curr)))\n                  (conj acc [curr])))))]\n    (reduce f (list) seq)))","user":"58ac01f7e4b0005cfeb1a73b"},{"code":"(fn [l] (partition-by identity l) )","problem":31,"user":"535e518ee4b04ce2eb3ed2cf"},{"code":"(fn [xs]\n  (partition-by list xs))","problem":31,"user":"4fc66c43e4b0ee37620e1812"},{"problem":31,"code":"(fn foo [in]\n   (if (empty? in)\n     '()\n     (let [x (foo (rest in))]\n       (if (= (first in) (first (first x)))\n         (conj (rest x) (conj (first x) (first in)))\n         (conj x (list (first in)))\n         ))))","user":"5bbaf02fe4b0a20761a235f4"},{"code":"(fn [x]\n  (reduce (fn [l r] (if (= (last (last l)) r)\n                        (concat (drop-last l) (list (concat (last l) (list r))))\n                        (concat l (list (list r)))))\n    nil x)\n  )","problem":31,"user":"4f3e05a8e4b0e243712b1f79"},{"problem":31,"code":"(fn [xs]\n  (loop\n      [acc []\n       current [(first xs)]\n       last (first xs)\n       xs (rest xs)]\n    (if (zero? (count xs))\n      (conj acc current)\n      (let [y (first xs)\n            ys (rest xs)]\n        (if (= last y)\n          (recur acc (conj current y) y ys)\n          (recur (conj acc current) [y] y ys))))))","user":"51bd78c3e4b0ff155d51d2b0"},{"problem":31,"code":"(fn prob31 [col]\n  (partition-by identity col))","user":"4ebbff41535dfed6da9c6d78"},{"problem":31,"code":"(fn group\n  [xs]\n  (reduce (fn [accum x]\n            (if (= x (last (last accum)))\n              (concat (butlast accum) (list (concat (last accum) (list x))))\n              (concat accum (list (list x)))))\n          (list (list (first xs)))\n          (rest xs)))","user":"5c222b7de4b07e362c230588"},{"problem":31,"code":"(fn pack\n  [coll]\n  (if (empty? coll)\n    []\n    (let [head (first coll)\n          segment (take-while #(= head %) coll)\n          rest    (drop-while #(= head %) coll)]\n      (cons segment (pack rest)))))","user":"58aa8083e4b01a0c0b232985"},{"problem":31,"code":"(fn pack ([coll] (pack coll nil nil))\n  ([coll curr res] (if (empty? coll)\n                     (conj res curr)\n                     (if (empty? curr)\n                       (pack (rest coll) [(first coll)] res)\n                       (if (= (first curr) (first coll))\n                         (pack (rest coll) (conj curr (first coll)) res )\n                         (pack coll [] (conj (vec res) (vec curr)))\n                         ))))\n  )","user":"5b421edce4b02d533a91bc2c"},{"problem":31,"code":"(fn [s]\n  \n(partition-by identity s)\n  \n  \n  )","user":"56f2611fe4b04a395b9a04a2"},{"problem":31,"code":"#(loop [left (rest %) res [] curr (first %) cnt 1]\n   (if (empty? left)\n     (conj res (repeat cnt curr))\n     (let [f (first left) others (rest left)]\n       (if (= f curr)\n         (recur others res f (inc cnt))\n         (recur others (conj res (repeat cnt curr)) f 1)\n         )\n       )\n     )\n   )","user":"5f429fdfe4b0955706451faf"},{"problem":31,"code":"(fn packsequnce\n  [sequence]\n  ((fn packSeq\n  [sequence previous acc]\n  (cond\n    (nil? sequence) (cons acc ())\n    :else (if-not (= previous (first sequence))\n            (cond\n              (nil? acc) (packSeq (next sequence)\n                                   (first sequence)\n                                   (cons (first sequence) ()))\n               :else (cons acc (packSeq (next sequence)\n                                       (first sequence)\n                                       (cons (first sequence) ())\n                                       )\n                           )\n               )\n            (packSeq (next sequence) previous (cons (first sequence) acc))\n            )\n    )\n  )\n sequence nil nil))","user":"557e9d17e4b05c286339e0d8"},{"code":"(fn [parts] (partition-by identity parts))","problem":31,"user":"4df0524e535d08e6dec9fe17"},{"code":"(fn [s]\n  (loop [x s\n         l nil\n         acc []]\n    (if (nil? x)\n      acc\n      (let [head (first x)]\n        (if (not= head l)\n          (recur (next x) head (conj acc (list head)))\n          (recur (next x) l (conj (pop acc) (conj (last acc) head))))))))","problem":31,"user":"4ff9d4e5e4b0678c553fc3b0"},{"code":"(fn pack [coll]\n  (if (empty? coll)\n    []\n    (let [[a b] (split-with (partial = (first coll)) coll)]\n      (cons a (pack b)))))","problem":31,"user":"536254a5e4b0243289761e50"},{"problem":31,"code":"(fn [x](seq(partition-by identity x)))","user":"590d0b3fe4b047aa04b199f9"},{"code":"(fn packseq [s]\n  (loop [s1 (rest s) sub [(first s)] y []]\n    (if  (empty? s1)\n      (conj y sub)\n      (if (= (last sub) (first s1))\n          (recur (rest s1) (conj sub (first s1)) y)\n\t        (recur (rest s1) [(first s1)] (conj y sub))))))","problem":31,"user":"4f03e7b3535dcb61093f6b7c"},{"code":"(fn compress [coll]\n    (loop [[a & more :as all] coll\n           current [a]\n           acc []]\n      (if (= (count more) 0)\n        (conj acc current)\n        (if (= a (first more))\n         (recur more (conj current a) acc)\n         (recur more [(first more)] (conj acc current))))))","problem":31,"user":"5370ef22e4b0fc7073fd6ea0"},{"problem":31,"code":"(fn [coll]\n  (partition-by identity coll)\n  )","user":"60752ef6e4b069485764de55"},{"code":"(fn pack2 [col]\n  (reduce\n   #(let [prev (first (last %))]\n      (if (= prev %2)\n        (vec (conj (vec (drop-last %)) (conj (last %) %2)))\n        (vec (conj % (list %2)))))\n   []\n   col))","problem":31,"user":"52cf5450e4b07d0d72b273a4"},{"code":"(fn pack \n  ([l cur]\n    (if (empty? l)\n        (cons cur nil)\n        (if (= (first l) (first cur))\n            (pack (rest l) (cons (first l) cur))\n            (cons cur (pack l)))))\n  ([l]\n    (if (empty? l)\n        nil\n        (pack (rest l) (cons (first l) nil)))))","problem":31,"user":"504e3afae4b0f6ff3350c488"},{"code":"#(partition-by identity  %)","problem":31,"user":"50057f23e4b0678c553fc466"},{"problem":31,"code":"(fn pack [s]\n  (loop [res s\n         acc '()]\n    (let [nxt (first res)]\n      (if (nil? nxt) \n        (reverse acc)\n        (let [sub (take-while #(= nxt %) res)\n              res (drop-while #(= nxt %) res)\n              acc (conj acc sub)]\n          (recur res acc)\n        )\n      )\n    )\n   )\n )","user":"56fbe0cce4b07572ad1a88d8"},{"problem":31,"code":"(fn group-consecutive [coll]\n  \"groups consecutive items in sublists\"\n  (loop [coll  coll\n         accum []]\n    (if (or (nil? coll) (empty? coll))\n      accum\n      (let [grp (take-while #(= % (first coll)) coll)]\n        (recur\n         (drop (count grp) coll)\n         (conj accum grp))))))","user":"5a786f6be4b013a48d39976e"},{"problem":31,"code":"(fn [v]\n  ((fn pack [res cur result]\n    (cond (empty? res) (conj result (repeat (cur 1) (cur 0)))\n          (= (first res) (first cur)) (pack (rest res) [(first cur) (inc (cur 1))] result)\n          :else (pack (rest res) [(first res) 1] (conj result (repeat (cur 1) (cur 0)))))) (rest v) [(first v) 1] []))","user":"58f98231e4b0438e51c2cf4c"},{"code":"(fn [coll]\n  (loop [new-coll (next coll) acc [(first coll)] res []]\n    (if new-coll\n      (if (= (first new-coll) (first acc))\n        (recur (next new-coll) (conj acc (first new-coll)) res)\n        (recur (next new-coll) [(first new-coll)] (conj res acc)))\n      (conj res acc))))","problem":31,"user":"4f98da04e4b0dcca54ed6cf7"},{"problem":31,"code":"#(reduce (fn [acc, i] (let [ll (last acc), l (last ll)]\n  (if (= l i) \n      (concat (butlast acc) (list (concat ll (list i))))\n      (concat acc (list (list i))) \n))) [] %)","user":"57eb7a97e4b0bfb2137f5b62"},{"problem":31,"code":"(fn [seq]\n  (loop [s (rest seq) r () aux (list (first seq))]\n    (if (empty? s)\n      (if (not (empty? aux))\n        (reverse (conj r aux))\n        (reverse r))\n      (if (= (first s) (last aux))\n        (recur (rest s) r (conj aux (first s)))\n        (recur (rest s) (conj r aux) (list (first s)))))))","user":"55151417e4b055c2f668d4da"},{"problem":31,"code":"#(loop\n  [acc []\n   curr []\n   remainding %]\n  (if (empty? remainding)\n    (if (empty? curr) acc (conj acc curr))\n    (if (or (= (last curr) (first remainding)) (empty? curr))\n      ; Add to current list\n      (recur acc (conj curr (first remainding)) (rest remainding))\n      ; Start new list\n      (recur (conj acc curr) [(first remainding)] (rest remainding)))))","user":"5daa1fc8e4b000c986472c3e"},{"code":"(fn pack [lst]\n    (reverse\n        (reduce \n            (fn [acc ele] \n                (if (= ele (first (first acc))) \n                    (conj (rest acc) (conj (first acc) ele))\n                    (conj acc (list ele))\n                )\n            ) (list (list (first lst))) (rest lst)\n        )\n    )\n)","problem":31,"user":"52c17e42e4b07a9af5792367"},{"code":"(fn packdup [s]\n  (partition-by identity s))","problem":31,"user":"51b73a91e4b0d906fcd71d33"},{"problem":31,"code":"(fn [l]\n  (let [rev (reverse l)]\n    (loop [left (rest rev)\n           recent-acc (list (first rev))\n           acc nil]\n      (if (empty? left)\n        (if (empty? recent-acc)\n          acc\n          (conj acc recent-acc))\n        (if (= (first recent-acc) (first left))\n          (recur (rest left)\n                 (conj recent-acc (first left))\n                 acc)\n          (recur (rest left)\n                 (conj nil (first left))\n                 (conj acc recent-acc)))))))","user":"55d4dddde4b0e31453f64a7f"},{"code":"(fn pack-seq [coll]\n  (if (empty? coll)\n      ()\n      (lazy-seq\n        (loop [packed [] [fst & rst] coll]\n          (if (or (empty? rst) (not (= fst (first rst))))\n              (cons (conj packed fst) (pack-seq rst))\n              (recur (conj packed fst) rst))))))","problem":31,"user":"4e7c8fd1535db169f9c796be"},{"problem":31,"code":"(partial reduce #(if (= (first (last %1)) %2) (conj (vec (butlast %1)) (conj (last %1) %2)) (conj %1 (vector %2))) [])","user":"54d6c80ce4b0a52adc2e2020"},{"code":"reduce\n           (fn [L e]  \n                        (if (= e (last (last L)))            \n                          (concat (drop-last L) (vector (cons e  (last L)) ))\n                          (conj (vec L) (list e))\n                        )\n\n           )\n           []","problem":31,"user":"52c35afce4b07a9af579238c"},{"problem":31,"code":"reduce (fn [coll x]\n  (if (= (last (last coll)) x)\n    (conj (vec (butlast coll)) (conj (last coll) x))\n    (conj coll [x]))) []","user":"54d0cedde4b0e8a36923e5d2"},{"problem":31,"code":"(fn [coll]\n  (let [ubd (gensym \"unbound\")]\n    (loop [es coll\n           ep ubd\n           g nil\n           r nil]\n      (if (empty? es)\n        (when g (reverse  (conj r g)))\n        (let [[e & re] es]\n          (cond\n            (= ep ubd) (recur re e (list e) r)\n            (= e ep) (recur re e (conj g e) r)\n            :default (recur re e (list e) (conj r g))))))))","user":"56f9c7c6e4b07572ad1a88ba"},{"problem":31,"code":"(fn [in-array]\n    (reverse\n      (reduce\n        (fn [acc i]\n          (if (= (first (first acc)) i)\n            (cons (cons i (first acc)) (rest acc))\n            (cons (list i) acc)))        \n        []\n        in-array))\n    )","user":"53c6c9dfe4b00fb29b2212a1"},{"problem":31,"code":"(fn packdups\n  ([out in]\n   (if (empty? in)\n     out\n     (if (= (first (last out)) (first in))\n       (packdups (conj (vec (butlast out)) (vec (conj (last out) (first in)))) (rest in))\n       (packdups (vec (conj out [(first in)])) (rest in)))))\n  ([in]\n   (packdups [[(first in)]] (rest in)))\n  )","user":"54b2e881e4b09f271ff37d32"},{"problem":31,"code":"(fn pack\n  ([lst] (pack (rest lst) (first lst) 0))\n  ([lst prev n]\n   (cond \n    (nil? prev) nil\n    (= prev (first lst)) (pack (rest lst) prev (inc n))\n    :else (cons (repeat (inc n) prev) (pack (rest lst) (first lst) 0)))))","user":"54c8ac49e4b045293a27f64e"},{"problem":31,"code":"(fn group-up [orig-list]\n  (loop [xs orig-list ys '()]\n     (if (empty? xs)\n       (reverse ys)\n       (let [split-list (split-with (partial = (first xs)) xs)]\n         (recur (second split-list) (conj ys (first split-list)))))))","user":"5d68fc2fe4b0db5d338d1606"},{"problem":31,"code":"(fn [[x & xs]]\n  ((fn f [total tail acc]\n    (if (empty? tail)\n      (conj total acc)  \n      (let [item (first tail) newtail (rest tail)]\n        (if (= item (first acc))\n          (f total newtail (conj acc item))\n          (f (conj total acc) newtail [item]\n        ) \n      )\n    )          \n  )) [] xs [x])\n)","user":"54bb0f63e4b0ed20f4ff6ebc"},{"problem":31,"code":"(fn [lst]\n  (loop [remaining lst\n         seqs []]\n    (if (empty? remaining)\n      (apply list seqs)\n      (let [item (first remaining)\n            [item-list others] (split-with (partial = item) remaining)]\n        (recur others (conj seqs item-list))))))","user":"4dad9dbdc9a9d6ed2199dc57"},{"problem":31,"code":"(fn [x] (map (fn [x] (if (list? x) x (list x))) (->(str x)\n   (clojure.string/replace #\"(\\S+(\\s\\S+)*)((\\s\\1)+)\" \"($1 $3)\")\n   (read-string )\n   (seq))         )\n   )","user":"5924009ce4b072a2710fce45"},{"problem":31,"code":"(fn pack-sequence [input]\n  (partition-by identity input))","user":"57ea4569e4b0bfb2137f5b46"},{"problem":31,"code":"#(partition-by identity %)\n\n;; #(reduce (fn [acc e]\n;;             (if (= (last (last acc)) e)\n;;               (conj (apply vector (butlast acc)) (conj (last acc) e))\n;;               (conj acc [e])))\n;;           []\n;;           %)\n\n;; (fn [c]\n;;     (letfn [(get-rst [cc rst]\n;;               (if (empty? cc)\n;;                 rst\n;;                 (let [current (first cc)\n;;                       lst (last rst)\n;;                       last-last (last lst)\n;;                       next-cc (rest cc)\n;;                       without-last-rst (apply vector (butlast rst))]\n;;                   (if (= current last-last)\n;;                     (recur next-cc (conj without-last-rst (conj lst current)))\n;;                     (recur next-cc (conj rst [current])))))\n;;               )]\n;;       (get-rst c [])))","user":"591ad160e4b09b4ee5954bdf"},{"problem":31,"code":"(fn [s]\n  (loop [sq s result []]\n    (if (empty? sq)\n      result\n      (recur\n        (rest sq)\n        (concat (butlast result)\n                (cond\n                  (nil? (last result)) [[(first sq)]]\n                  (= (last (last result)) (first sq)) [(conj (last result) (first sq))]\n                  :else [(last result) [(first sq)]]\n                  )\n\n                )\n        )\n\n      )\n    )\n  )","user":"5f58db95e4b0a0bc16850a9a"},{"problem":31,"code":"(fn pack\n  [x]\n  (loop [in x \n         res (list)]\n    (if (empty? in)\n      res\n\t  (if (= (first in) (first (last res)))\n        (recur (rest in) (concat (butlast res) [(concat (last res) [(first in)])] ))\n        (recur (rest in) (concat res [(list (first in))]))))))","user":"54e0e911e4b024c67c0cf7bc"},{"code":"(fn c31 [xs]\n  (loop [xs xs out [] subs []]\n    (if (seq xs)\n      (let [[x & xs] xs]\n        (if (and (seq subs) (not= (first subs) x))\n           (recur xs (conj out subs) [x])\n           (recur xs out (conj subs x))))\n      (conj out subs))))","problem":31,"user":"4ee88269535d93acb0a6687f"},{"problem":31,"code":"(fn pack [xs]\n  (reduce (fn [xss y]\n            (let [zs (last xss)]\n              (if (= y (last zs))\n                (conj (vec (butlast xss)) \n                      (conj zs y))\n                (conj xss \n                      (vector y)) ) ) )\n          [] xs) )","user":"551ee974e4b08d5046aa8a50"},{"problem":31,"code":"(fn pack [coll] \n  (loop [coll (vec coll) res [] repeat []]\n(println res repeat)\n  (if (empty? coll)\n    res\n    (if (= (first coll) (second coll))\n     (recur \n       (rest coll) res (conj repeat (first coll)))\n     (recur \n       (rest coll) (conj res (conj repeat (first coll))) '())))))","user":"5167e8ace4b0c5a4140a309a"},{"problem":31,"code":"(fn [coll]\n    (reduce\n      (fn [res x]\n        (if (empty? res)\n          [[x]]\n          (if (= x (first (last res)))\n            (conj (into [] (butlast res)) (conj (last res) x))\n            (conj res [x])))\n        )\n      [] coll)\n    )","user":"5d887d27e4b0915913b1d3a8"},{"problem":31,"code":"(fn [xs]\n  (loop [x (first xs)\n         xs (rest xs)\n         y nil\n         ys []]\n    (if-not x\n      (conj ys y)\n      (if (or (empty? y) (= x (first y)))\n        (recur (first xs) (rest xs) (conj y x) ys)\n        (recur (first xs) (rest xs) [x] (conj ys y))))))","user":"5d6042f2e4b0c9e5857d5006"},{"problem":31,"code":"#(loop [s % r [] c []]\n   (if (empty? s)\n     (conj r c)\n     (if (= (first s) (last c))\n       (recur (rest s) r (conj c (first s)))\n       (if (and (empty? c) (empty? r))\n         (recur (rest s) [] [(first s)])\n         (recur (rest s) (conj r c) [(first s)])))))","user":"5e2ead6ae4b05b4b015161f5"},{"code":"partition-by (fn[a] a)","problem":31,"user":"515f0a39e4b02c55805ea23a"},{"code":"(fn b [x]\n  (loop [seq1 x seq2 '()]\n    (if (nil? (first seq1))\n      (reverse seq2)\n      (if (= (first seq1) (ffirst seq2))\n        (recur (next seq1) (conj (rest seq2) (conj (first seq2) (first seq1))))\n        (recur (next seq1) (conj seq2 (list (first seq1))))))))","problem":31,"user":"4dde4e95535d08e6dec9fdd7"},{"problem":31,"code":"#_(fn [coll]\n  (reverse (reduce (fn [acc item]\n                     (if (= (-> acc ffirst) item)\n                       (conj (drop 1 acc) (conj (first acc) item))\n                       (conj acc (list item))))\n                   (list)\n                   coll)))\n\n(fn [coll]\n  (partition-by identity coll))","user":"5d6f063de4b04d129b00f2d1"},{"problem":31,"code":"(fn f [s]\n   (if (empty? s)\n     ()\n     (cons (take-while #(= (first s) %) s)\n           (f (drop-while #(= (first s) %) s)))))","user":"5ade6bafe4b0837691e92c23"},{"problem":31,"code":"(fn sub-list [coll]\n  (cond (empty? coll) '()\n        (= (first coll) (second coll))\n          (let [x (first coll)\n                r (sub-list (rest coll))\n                y (first r)]\n            (conj (rest r) (conj y x))\n            )\n        :else (conj (sub-list (rest coll)) (list (first coll)))\n        )\n  )","user":"5f4303cfe4b0955706451fb3"},{"problem":31,"code":"(fn [l] (loop [r '() l (reverse l)]\n          (if (empty? l) r\n          \t(recur (conj r (take-while #(= % (first l)) l))\n                   (drop-while #(= % (first l)) l)))))","user":"56372798e4b0bfe05bf117d0"},{"problem":31,"code":"(fn [coll]\n   (loop [v nil\n          r ()\n          t ()\n          c coll]\n     (if (seq c)\n       (let [f (first c)]\n         (if (= f v)\n           (recur f r (cons f t) (rest c))\n           (recur f (if (seq t) (reverse (cons t (reverse r))) r) (list f) (rest c))))\n       (reverse (cons t (reverse r))))))","user":"5454bb07e4b0e397800069da"},{"code":"partition-by #(do %)","problem":31,"user":"4e6b3fc8535d8ccf87e9ff0f"},{"problem":31,"code":"(fn kerry [s]\n  (if (empty? s) s\n      (loop [first-el (first s)\n             new-set (list first-el)\n             remainder (rest s)]\n        (if (= first-el (first remainder))\n          (recur first-el (cons first-el new-set) (rest remainder))\n          (cons new-set (kerry remainder))))))","user":"58a0fc33e4b02bd94d917ea3"},{"problem":31,"code":"reduce #(let [prev (last %1)]\n                (println prev)\n                (if (= (first prev) %2)\n                    (concat (butlast %1) (list (concat prev (list %2))))\n                    (concat %1 (list (list %2)))))\n          '()","user":"59cdea74e4b0ef0a1e9b5b47"},{"problem":31,"code":"(fn [input]\n  (loop [repeat-sec [(first input)]\n         rest-sec (rest input)\n         output []]\n    ;(pprint {:rep repeat-sec :res rest-sec :out output})\n    (cond\n     (empty? rest-sec)\n     (conj output repeat-sec)\n     \n     (= (first repeat-sec) (first rest-sec))\n     (recur (conj repeat-sec (first rest-sec)) (rest rest-sec) output)\n     \n     :else\n     (recur [(first rest-sec)] (rest rest-sec) (conj output repeat-sec)))))","user":"546c4c5fe4b00cfc9eacc178"},{"problem":31,"code":"(fn f\n  ([col]\n   (reverse (f col nil '())))\n  ([col l acc]\n   (if (empty? col)\n     acc\n     (let [fst (first col) rst (rest col)]\n       (if (= fst l)\n         (f rst fst (cons (cons fst (first acc)) (rest acc)))\n         (f rst fst (cons (list fst) acc)))))))","user":"58a822e4e4b01a0c0b232950"},{"problem":31,"code":"#(seq (reduce (fn [target e] (if (= e (peek (peek target))) (conj (pop target) (conj (peek target) e)) (conj target (list e)))) '[] %))","user":"56b3146ae4b0982f16b37e0f"},{"problem":31,"code":"(fn [s]\n    (loop [s s\n           prev (first s)\n           temp '()\n           acc '()]\n      (cond\n        (empty? s) (reverse  (cons temp acc))\n        (= (first s) prev) (recur (rest s) prev (cons (first s) temp) acc)\n        :else (recur (rest s) (first s) (cons (first s) '()) (cons temp acc)))))","user":"5600dccee4b04bb52996e175"},{"problem":31,"code":"(fn\n  [coll]\n  (letfn\n    [(pack-seq [coll]\n               (if (not (empty? coll))\n                 (cons\n                  (take-while\n                   #(= % (first coll))\n                   coll)\n                  (pack-seq (drop-while\n                             #(= % (first coll))\n                             coll)))))]\n            (pack-seq coll)))","user":"5521248fe4b08d5046aa8a69"},{"problem":31,"code":"(fn [init-list] \n      (loop [take-away (next init-list) adder []  curr-sub (conj [] (first init-list))] \n         (cond \n           (nil? take-away) (conj adder curr-sub) \n           (= (first take-away) (first curr-sub)) \n             (recur (next take-away) adder (conj curr-sub (first take-away))) \n          :else (recur (next take-away) (conj adder curr-sub) (conj [] (first take-away))) \n        ) \n      ) \n    )","user":"571d9669e4b0145328a7627f"},{"code":"reduce #(if (= (first (last %)) %2) ((fn foo [xs x]\n                                        (if (empty? (rest xs))\n                                          (list (cons x (last xs)))\n                                          (cons (first xs) (foo (rest xs) x)))) % %2)\n             ((fn foo [xs x]\n                (if (empty? xs)\n                  (list x)\n                  (cons (first xs) (foo (rest xs) x)))) % (list %2))) '()","problem":31,"user":"50aedb8ce4b0a40c9cfb08d4"},{"problem":31,"code":"partition-by #( list %1 )","user":"54094824e4b0addc1aec66da"},{"problem":31,"code":"(fn [s] ((fn r [s sa] (cond (empty? s) (cons sa nil) (or (empty? sa) (= (first s) (first sa))) (r (rest s) (cons (first s) sa)) :else (cons sa (r (rest s) (cons (first s) nil))))) s nil))","user":"556766c1e4b0c656e3ff1840"},{"problem":31,"code":"(fn [s]\n  (loop [processed '()\n         current '()\n         remaining (reverse s)]\n    (if (empty? remaining)\n      (cons current processed)\n      (let [f (first remaining)\n            r (rest remaining)]\n        (if (or (empty? current) (= (first current) f))\n          (recur processed (cons f current) r)\n          (recur (cons current processed) '() remaining)\n        )\n      )\n    )\n  )\n)","user":"5d6f0533e4b04d129b00f2d0"},{"problem":31,"code":"(fn pack [s]\n  (loop [f (first s)\n         tail s\n         rv []]\n    (if (empty? tail)\n      rv\n      (let [par (partial = f)\n            rest' (drop-while par tail)\n            head' (take-while par tail)]\n        (recur (first rest') rest' (conj rv head'))))))","user":"561ba3e5e4b073c65b0ce3eb"},{"code":"(fn f [[s & t]]\r\n  (if s\r\n    (let [a (f t)]\r\n      (if (= s (first (first a)))\r\n        (conj (rest a) (conj (first a) s))\r\n        (conj a (list s)) ) ) ) )","problem":31,"user":"4df20dda535d08e6dec9fe23"},{"code":"(fn pack [x]\n  (if (empty? x)\n    x\n    (let [[a b] \n          ((fn bl [value intermed l]\n             (if (= value (first l))\n               (bl value (cons value intermed) (rest l))\n               [intermed l]))\n            (first x) (list (first x)) (rest x))]\n      (cons a (pack b))\n      )))","problem":31,"user":"5110b8bae4b04c71fce993f4"},{"problem":31,"code":"(fn [it]\r\n  (loop [here it\r\n         theres []\r\n         there []\r\n         last (first it)]\r\n    (if (empty? here)\r\n      (conj theres there)\r\n      (let [this (first here)]\r\n        (if (= last this)\r\n          (recur\r\n           (rest here)\r\n           theres\r\n           (conj there this)\r\n           this)\r\n          (recur\r\n           (rest here)\r\n           (conj theres there)\r\n           [this]\r\n           this))))))","user":"4ddc5d0a535d02782fcbea05"},{"code":"(fn vup [dup-col] ((fn [c-1 c-2 count c-3]\n                 (let* [are-dup (if (= (first c-1) (first c-2))\n                                  true\n                                  false)\n                       new-count (if are-dup\n                                    (+ count 1)\n                                    0)\n                       new-c-3 (if are-dup\n                                  c-3\n                                  (concat c-3 [(take (+ 1 count) (repeat (first c-1)))]))]\n                 (if (empty? c-2)\n                   (concat c-3 [(take (+ 1 count) (repeat (first c-1)))])\n                   (recur (drop 1 c-1) (drop 1 c-2) new-count new-c-3)))) dup-col (drop 1 dup-col) 0 '()))","problem":31,"user":"51037468e4b00c483ae17702"},{"problem":31,"code":"(fn pack [ls]\n  (if (= (count ls) 0)\n    []\n    (cons (take-while (partial = (first ls)) ls)\n          (pack (drop-while (partial = (first ls)) ls))\n          )\n    )\n  )","user":"541ef7e2e4b01498b1a71a92"},{"problem":31,"code":"(fn [vs]\n  (reduce (fn [acc v]\n            (cond\n             (empty? acc) (conj acc (vector v))\n             (= (-> acc last first) v) (update-in acc [(-> acc count dec)] conj v)\n             :else (conj acc (vector v))))\n          []\n          vs))","user":"53684a2fe4b0243289761e8c"},{"code":"(fn [xs]                                                            \n     (reverse ((fn [coll accum]                                                    \n                 (if (empty? coll)                                                 \n                   accum                                                           \n                   (let [x (first coll)                                            \n                         xs (rest coll)                                            \n                         last-group (first accum)                                  \n                        last-elem (first last-group)]                             \n                    (if (= x last-elem)                                           \n                      (recur xs (cons (cons x last-group) (rest accum)))           \n                      (recur xs (cons (list x) accum))))))                        \n                xs nil))                                                          \n    )","problem":31,"user":"53162640e4b08068f379ed40"},{"problem":31,"code":"(fn partition-dups [col]\n  (partition-by identity col))","user":"548018d1e4b0c51c1f4d7326"},{"problem":31,"code":"(fn [xs]\n    (loop [xs (rest xs)\n           crnt (first xs)\n           ys []\n           n 1]\n      (if (empty? xs)\n        (conj ys (take n (repeat crnt)))\n        (if (= crnt (first xs))\n          (recur (rest xs) crnt ys (inc n))\n          (recur (rest xs)\n                 (first xs)\n                 (conj ys (take n (repeat crnt)))\n                 1\n                 )))))","user":"58b81490e4b0ebc645576d8c"},{"problem":31,"code":"(fn [[x & xs]]\n  (loop [res []\n         curr (list x)\n         last x\n         rest xs]\n    (if (empty? rest)\n      (conj res curr)\n      (let [[y & ys] rest]\n        (if (= last y)\n          (recur res (conj curr y) last ys)\n          (recur (conj res curr) (list y) y ys))))))","user":"56887bcbe4b0dcc4269f406a"},{"problem":31,"code":"#((fn pack [cur building r res]\n  (if (empty? r)\n    (reverse (cons building res))\n    (let [el (first r), cdr (rest r)]\n      (if (= el cur)\n        (pack cur (cons el building) cdr res)\n        (pack el [el] cdr (cons building res)))))) (first %) [] % [])","user":"5520af03e4b08d5046aa8a64"},{"problem":31,"code":"(fn m [i]\n  (let [s (split-with (partial = (first i)) i)]\n    (if (empty? (first s))\n      (first s)\n      (cons (first s) (m (second s))))))","user":"5829bc55e4b051871117bf49"},{"code":"#(reverse ((fn pack-list [a-list result-accumulator]\n  (let [is-repetition (fn [elem] (= elem (first a-list)))]\n    (cond \n      (empty? a-list) result-accumulator\n      true (pack-list \n            (drop-while is-repetition a-list)\n            (conj result-accumulator \n                  (take-while is-repetition a-list))))\n)) % '()))","problem":31,"user":"4fe83efbe4b07c9f6fd12c3b"},{"problem":31,"code":"reduce #(if (= (first (last %1)) %2)\n  \t\t\t(concat (butlast %1) (list (conj (last %1) %2)))\n  \t\t\t(concat %1 (list (list %2)))) '()","user":"551c594de4b07993ea3788dc"},{"problem":31,"code":"(fn [s]\n  (loop [remaining s prev (first s) cnt 0 ans []]\n    (if (empty? remaining)\n      (conj ans (for [x (range cnt)] prev))\n      (let [[cur & remain] remaining]\n        (if (= cur prev)\n          (recur remain prev (inc cnt) ans)\n          (recur remain cur 1 (conj ans (for [x (range cnt)] prev))))))))","user":"5746061ae4b009280f9f2b5b"},{"problem":31,"code":"#(loop [in %, out []]\n   (if (empty? in)\n     out\n     (recur\n       (drop-while (partial = (first in)) in)\n       (conj out (take-while (partial = (first in)) in)))))","user":"58247423e4b051871117bec5"},{"problem":31,"code":"#(reduce (fn [accum x]\n            (if (= (last (last accum)) x)\n              (concat (drop-last accum) [(conj (last accum) x)])\n              (concat accum [[x]])))\n          [[(first %)]]\n          (rest %))","user":"5b5d255de4b0c6492753e6c8"},{"problem":31,"code":"; 30 Pack a sequence\n(fn\n  [lst]\n  (list* (reduce\n         (fn [out, each]\n           ;(println \"> \" out \" :: \" each)\n           (if (= (last (last out)) each)\n             (conj (vec (butlast out)) (conj (last out) each))\n             (conj out (cons each '()))))\n         [(cons (first lst) '())]\n         (rest lst))))","user":"5e65bfe4e4b0fd0acd1586b9"},{"problem":31,"code":"(fn gp ([l] (gp l '()))\n       ([l c] (if (not (empty? l)) \n                (let [nl (take-while #(= (first l) %) l)]\n                  (gp (drop (count nl) l) (conj c nl)))\n                (reverse c))))","user":"58983e3fe4b00487982d52ce"},{"problem":31,"code":"partition-by hash","user":"53d2fb7ae4b00fb29b221326"},{"code":"(fn [a-seq] (reverse \n  (reduce #(if (= %2 (first (first %1)))\n               (conj (rest %1) (conj (first %1) %2))\n               (conj %1 (list %2))) '() a-seq)))","problem":31,"user":"4e6dc95a535d5021c1a895f1"},{"problem":31,"code":"(fn foo [s]\n  (if \n   (empty? s)\n   (empty s)\n   (let [dups (partial = (first s))]\n     (cons (take-while dups s) (foo (drop-while dups s))))))","user":"5461dc79e4b01be26fd746a8"},{"code":"(fn [seq]\n  (letfn [(replace-first [x list]\n                         (cons x (rest list)))\n          ]\n    (if (empty? seq)\n      seq\n      (reverse (reduce (fn [acc x]\n                         (if (= (first (first acc)) x)\n                           (replace-first (cons x (first acc)) acc)\n                           (cons (list x) acc)))\n                       (list (list (first seq)))\n                       (rest seq))))))","problem":31,"user":"524cdd51e4b0752c4cb68ccc"},{"problem":31,"code":"(fn pack [col]\n  (reduce\n   (fn [res el]\n     (if (= (first (last res)) el)\n       (concat (butlast res) [(conj (last res) el)])\n       (concat res [[el]])))\n   []\n   col))","user":"58c5a08be4b021aa9917ed40"},{"problem":31,"code":"(fn [coll] \n  (reverse \n   (reduce \n    #(if (= (first (first %1)) %2) \n       (conj (pop %1) (concat (first %1) (list %2)))\n       (conj %1 (list %2)))\n    `()\n    coll)))","user":"5b3251c1e4b025bcb146f317"},{"code":";reduce #(if (= (last (last %1)) %2) (concat (or (butlast %1) '()) (list (cons %2 (last %1)))) (concat %1 (list (list %2)))) '()\npartition-by identity","problem":31,"user":"533b9cace4b0e30313ee6cd1"},{"code":"(fn pack [l]\n   (letfn [(rd [acc e]\n             (if (= (first (first acc)) e)\n               (cons (cons e (first acc)) (rest acc))\n               (cons (list e) acc)))]\n     (reverse (reduce rd '() l))))","problem":31,"user":"4fc8ce6ce4b0ee37620e183c"},{"code":"(comp reverse\n  (partial reduce\n    (fn [s x]\n      (if (= (first (first s)) x)\n        (cons (cons x (first s)) (rest s))\n        (cons (list x) s)))\n    '()))","problem":31,"user":"4f1b0ab3535d64f603146474"},{"problem":31,"code":"(fn [in]\n  (let [coll (seq in)]\n    (loop [remaining (rest coll)\n           prev (second coll)\n           acc (vector (vector (first coll)))\n           stored (last acc)]\n      (cond\n       (empty? remaining) (drop 1 (into (vector) (conj acc stored)))\n       (= prev (last stored)) (recur (rest remaining) (second remaining) acc (conj stored prev))\n       :else (recur (rest remaining) (second remaining) (conj acc stored) (vector prev))))))","user":"51a7bf26e4b0da5f497bde8c"},{"code":"#(loop [l % r []]\n   (let [!= (fn [x y] (not (= x y)))\n         lambda (fn [lp] (loop [li lp last (first li) ri []]\n            (let [fs (first li)]\n            \t(if (or (empty? li) (!= fs last))\n              \t\t(list (seq li) (seq ri))\n              \t\t(recur (rest li) last (conj ri fs))))))]\n   (if (empty? l)\n     (seq r)\n     (let [z (lambda l)]\n     (recur (first z) (concat r (rest z)))))))","problem":31,"user":"52c81954e4b0c2d177d6212e"},{"problem":31,"code":"(fn [xs]\n  (loop [[x & xs :as xx] xs\n         [y & ys :as yy] []\n         res []]\n    (if (seq xx)\n     (if (= x y)\n      (recur xs (conj yy x) res)\n      (recur xs [x]\n        (if (seq yy)\n          (conj res yy)\n          res)\n        )\n      )\n     (conj res yy)\n     )\n    )\n  )","user":"589771f9e4b00487982d52bd"},{"code":"(fn [s]\n  (loop [l nil ss s out []]\n    (if (empty? ss)\n      out\n     (let [e (first ss)]\n        (recur e (rest ss) \n            (if (= e l) \n              (assoc out (dec (count out)) (conj (last out) e))\n              (conj out [e])))))))","problem":31,"user":"4dd9d299535d2dad7130b5dd"},{"problem":31,"code":"(fn\n  [sequence]\n  (for [part (partition-by identity sequence)]\n    part))","user":"5e6df58ee4b04a83ad7cd297"},{"problem":31,"code":"(fn pack [sq]\n  (cond\n    (empty? sq) '()\n    (empty? (rest sq)) (list sq)\n    (= (first sq) (first (rest sq))) \n   \t  (let [mylist (pack (rest sq))] (cons (cons (first sq) (first mylist)) (rest mylist)))\n    :else (cons (list (first sq)) (pack (rest sq)))))","user":"60b2aaebe4b0e0fa5f1b4228"},{"problem":31,"code":"(fn\n\t[l]\n\t(filter not-empty (reduce\n\t #(conj\n\t   (into [] (drop-while (partial = %2) %1)) (into '() (take-while (partial = %2) %1))) l l)))","user":"53da3fcde4b0e771c3025497"},{"code":"(fn [col]\n  (reduce (fn [[[x & xs :as z] & xss :as xsss] y] (if (= x y) (conj xss (cons x z)) (conj xsss (list y)))) nil (reverse col)))","problem":31,"user":"4fd7962ee4b0dab7d829f385"},{"code":"#((fn pack [s packed acc]\n     (if (empty? s)\n       (reverse (cons packed acc))\n       (if (= (first s) (first packed))\n         (pack (rest s) (cons (first s) packed) acc)\n         (pack (rest s) (list (first s)) (if (empty? packed)\n                                           acc\n                                           (cons packed acc)))))) % nil nil)","problem":31,"user":"4ff355a1e4b0678c553fc34d"},{"code":"reduce #(if (= (last (last %)) %2) (conj (vec (butlast %)) (conj (vec (last %)) %2)) (conj %1 [%2])) []","problem":31,"user":"508ee17ae4b0706b2ed3ef8d"},{"problem":31,"code":"#(reverse (reduce (fn [items2 x]\n           (if (= (first (first items2)) x)\n             (conj (rest items2) (conj (first items2) x) )\n             (conj items2 (list x))))\n         '() %1))","user":"57df9f60e4b0bd073c202467"},{"problem":31,"code":"(fn [s] (loop[l nil h (first s) t (rest s) r ()] \n          (if (= h nil) (reverse r) (if (= l h) \n                                      (recur h (first t) (rest t) (cons (cons h (first r)) (rest r)))\n                                      (recur h (first t) (rest t) (cons (list h) r) ) )) ))","user":"53b3ea79e4b047364c0444ab"},{"problem":31,"code":"(fn pack \n  ([coll]\n   (if (nil? coll)\n     nil\n     (let [[x & xs] coll]\n       (pack x [x] xs))))\n  ([current acc coll]\n   (if (nil? coll)\n     [acc]\n     (let [[x & xs] coll]\n       (if (= x current)\n         (pack current (conj acc x) xs)\n         (into [acc] (pack coll)))))))","user":"56557d2de4b0f9d632dd8498"},{"problem":31,"code":"#(reverse (reduce (fn [x y]\n           (if (= (first (first x)) y)\n             (conj (rest x) (conj (first x) y))\n             (conj x [ y]) ) )\n         []\n         %))","user":"53aef31ce4b047364c04447b"},{"code":"#(partition-by identity %)","problem":31,"user":"4df168bd535d08e6dec9fe1d"},{"problem":31,"code":"reduce \n  #(if \n    (= (first (last %1)) %2)\n    (conj (vec (drop-last 1 %1)) (conj (last %1) %2))\n    (conj %1 [%2]))\n  []","user":"577c12dfe4b0d3393e5deb2f"},{"problem":31,"code":"(fn pack [x] (let [f (first x)] (if (empty? x) nil (concat (list (take-while #(= f %) x)) (pack (drop-while #(= f %) x))))))","user":"5c54e605e4b0fb8c5ffd9a14"},{"code":"(fn pack [coll]\r\n  (reduce (fn [acc x]\r\n      (cond\r\n\t     (empty? acc)               (conj (vec acc) [x])\r\n             (= x (first (last acc)))   (conj (vec (butlast acc)) (conj (last acc) x))\r\n             :else                      (conj (vec acc) [x])))\r\n\t  []\r\n\t  coll))","problem":31,"user":"4dc54eb2535d8a4b2fd74284"},{"problem":31,"code":"(fn pack [x]\n  (if (empty? x) '()\n    ;else we need to match stuff up\n    (loop [chain '()\n           remaining x\n           match (first x)]\n      (if (= match (first remaining))\n        ;continue chaining\n        (recur (conj chain match) (rest remaining) match)\n        ;otherwise, wrap up the chain\n        (conj (pack remaining) chain)\n      )\n    )\n  )\n)","user":"569f99cce4b0542e1f8d1497"},{"problem":31,"code":"#((fn [col acc dacc previous] (if (empty? col) (if (empty? dacc) acc (conj acc dacc)) (let [c (first col) r (rest col)] (if (not= c previous) (recur r (if (empty? dacc) acc (conj acc dacc)) [c] c) (recur r acc (conj dacc c) c))))) % [] [] nil)","user":"5f49482ae4b0102c75033940"},{"problem":31,"code":"( fn [x] (partition-by identity x))","user":"55882c84e4b059ccff29b1f2"},{"problem":31,"code":"#(\n  (fn f [a [fst & rst]]\n    (cond\n      (empty? a) (if (nil? fst) [] (f [fst] rst))\n      (= (first a) fst) (f (concat a [fst]) rst)\n      :else (cons a (f [] (concat [fst] rst)))\n      )\n    )\n  [] %\n  )","user":"5b118b7be4b0cc2b61a3be34"},{"problem":31,"code":"(fn [s]\n  (loop [r () s s]\n    (if (empty? s)\n      (reverse r)\n      (if (= (first (first r)) (first s))\n        (recur (conj (rest r) (conj (first r) (first s))) (rest s))\n        (recur (conj r (list (first s))) (rest s))))))","user":"5af907e6e4b0cc2b61a3bcda"},{"code":"(fn pack-seq [coll]\r\n  (reverse (loop [result '() current '() left coll]\r\n    (cond (empty? left) (if (empty? current) \r\n                            result\r\n                            (cons current result))\r\n          (or (empty? current)\r\n              (= (first left) (first current)))\r\n            (recur result\r\n                   (cons (first left) current)\r\n                   (next left))\r\n          :else (recur (cons current result)\r\n                       '()\r\n                       left)))))","problem":31,"user":"4e4b4564535dc968683fc4d3"},{"code":"(fn [col]\n  \t(loop [c (seq col) acc ()]\n\t\t\t(if (nil? c)\n\t\t\t    (reverse acc)\n          (if (= (first c) (first (first acc)))\n\t\t\t\t       (recur (next c) \n\t\t\t\t              (conj (next acc)\n\t\t\t\t\t                  (conj (first acc) (first c))))\n               (recur (next c) \n\t\t\t\t              (conj acc (list (first c))))))))","problem":31,"user":"50a6b5e8e4b0aa96157e262a"},{"problem":31,"code":"(fn [entry] \n  \n     \n(partition-by identity entry)\n)","user":"53f12b77e4b0742d9025b0da"},{"code":"(fn [seq]\n    (partition-by identity seq))","problem":31,"user":"511e763ce4b03e81d390ac29"},{"code":"(fn [coll] (reduce (fn [result elt]\n\t\t       (let [sublist (last result) curr-el (first sublist)]\n\t\t\t (if (= curr-el elt) (conj (vec (butlast result)) (conj sublist elt))\n\t\t\t   (conj result [elt]))))\n\t\t   [[(first coll)]]\n\t\t   (rest coll)))","problem":31,"user":"50fac9e3e4b07934dda8b0d1"},{"problem":31,"code":"#(seq (partition-by identity %))","user":"56f86f98e4b08e7d20b96837"},{"problem":31,"code":"(fn pack [arr]\n  (if (empty? arr)\n    '()\n    (let [n ((fn kuk [arr x]\n               (if (empty? arr)\n                 0\n                 (if (= x (first arr))\n                   (inc (kuk (rest arr) x))\n                   0))) arr (first arr))]\n      (conj (pack (drop n arr)) (take n arr)))))","user":"57501c83e4b02ea11479926b"},{"problem":31,"code":"(fn pack [packed unpacked]\n        (if (empty? unpacked)\n            (rest packed)\n            (pack\n                (if (not= (last (last packed)) (first unpacked))\n                    (concat packed (list (list (first unpacked))))\n                    (concat (drop-last packed) (list (conj (last packed) (first unpacked))))\n                )\n                (rest unpacked)\n            )\n        )\n    ) \n'(())","user":"5e7374ace4b085ba37836dd0"},{"problem":31,"code":"(fn f [s] \n  (partition-by identity s)\n  )","user":"54ff6084e4b07d26eda61d50"},{"problem":31,"code":"(fn pack [s] (reverse (reduce ( fn place [lst item] (if ( = ( first ( first lst ) ) item ) (conj (rest lst) (conj (first lst) item)) (conj lst (conj nil item)) ) ) '() s ) ) )","user":"600b385ce4b074f607df668d"},{"code":"(fn [[fst & rst :as lst]]\n  (cond \n   (or (nil? lst) (empty? lst)) []\n   :else (reduce (fn [old nxt]\n                   (let [llst (last old)\n                         ele (first llst)]\n                     (if (= ele nxt)\n                       (assoc old (dec (count old)) (conj llst nxt))\n                       (conj old [nxt]))))\n                 [[fst]]\n                 rst)))","problem":31,"user":"51040eb2e4b0432126ba9bb4"},{"problem":31,"code":"#(loop [x % y (sequence []) z (sequence [])]\n                    (cond\n                      (= x nil) (rest (reduce conj () (conj y z)))\n                      (= (first x) (first z)) (recur (next x) y (cons (first x) z))\n                      :else (recur (next x) (conj y z) (cons (first x) (sequence [])))\n                      )\n                    )","user":"5e259d05e4b05b4b01516169"},{"code":"(fn [sq] (reverse (reduce (fn [s x] (if (= x (first (first s))) (conj (rest s) (conj (first s) x)) (conj s (conj '() x)))) '() sq)))","problem":31,"user":"51d381b5e4b099f3b6acde01"},{"problem":31,"code":"(fn [input]\n  (loop [result []\n         [f & remaining] input]\n    (if f\n      (if (= f (first (last result)))\n        (recur (conj (vec (drop-last result)) (conj (last result) f)) remaining)\n        (recur (conj result (list f)) remaining))\n      result)))","user":"5d439775e4b07c84aa5ae696"},{"code":"(fn c [s]\n  (loop [s s\n         r ()]         \n  \t(cond\n     (empty? s) (reverse r)\n     (or (empty? r) (= (ffirst r) (first s))) (recur (rest s) (conj (rest r) (conj (first r) (first s))))\n     :else (recur (rest s) (conj r (list (first s)))))))","problem":31,"user":"521b9f92e4b0c4ef0be8304c"},{"problem":31,"code":"(fn [x] \n  (reduce \n   (fn [x y] \n     (if (= (first (last x)) y) \n       (concat (drop-last x) (list (concat (last x) (list y)))) \n       (concat x (list (list y)))))\n     (list (list (first x))) \n   (rest x)))","user":"52384eb1e4b0fae3832e99fa"},{"code":"(fn\n          [coll]\n          (letfn\n            [(pack-seq [coll]\n               (if (not (empty? coll))\n                 (cons\n                   (take-while\n                     #(= % (first coll))\n                     coll)\n                   (pack-seq (drop-while\n                               #(= % (first coll))\n                               coll)))))]\n            (pack-seq coll)))","problem":31,"user":"514d7e29e4b019235f6c0587"},{"code":"(fn [coll]\n  (reduce \n    (fn [acc i] \n      (let [la (last acc)] \n        (if \n          (= i (last la)) \n            (conj \n              (-> acc butlast vec) \n              (conj la i)) \n            (conj acc [i])))) [] coll))","problem":31,"user":"511ac026e4b0c87c59c9670e"},{"code":"(fn [x] (loop [ll x, rl '(), la (first x), current '()]\n        (if (empty? ll)\n             (concat rl (list current))\n             (let [fi (first ll)]\n                  (if (= fi la)\n                      (recur (rest ll) rl la (cons la current))\n                      (recur (rest ll) (concat rl (list current)) fi (list fi)))))))","problem":31,"user":"4fd0cb0ee4b04c3a95aa0407"},{"code":"(fn [xs]\n  (loop [sublist '(), acc [], ys xs]\n    (if (seq ys)\n      (if (or (empty? sublist) (= (first sublist) (first ys)))\n        (recur (conj sublist (first ys)) acc (rest ys))\n        (recur (list (first ys)) (conj acc sublist) (rest ys)))\n      (conj acc sublist))))","problem":31,"user":"500ff421e4b0ae202717946f"},{"code":"(fn [sq] \n  (partition-by (fn [a] a) sq))","problem":31,"user":"4e7f32ee535db966e863cc3a"},{"problem":31,"code":"(fn packASeq\n  [col]\n  (loop [initial col\n         result '()\n         previousMatch false]\n    (println \"result\" result \" - initial \" initial)\n    (if (empty? initial)\n      (reverse result)\n      (if previousMatch\n        (do\n          (println \"previous match\")\n          (recur (rest initial) (conj (pop result) (conj (peek result) (first initial))) (= (first initial) (second initial)))\n          )\n        (do\n          (println \"no previous same\")\n          (recur (rest initial) (conj result (list (first initial))) (= (first initial) (second initial)))\n          )\n        ))\n    ))","user":"57c731ede4b05aa3c4741d00"},{"problem":31,"code":"(fn [xs]\n  (reverse\n   (reduce (fn [[group & gs :as packed] x]\n             (if-not group\n               (conj gs (list x))\n               (let [elem (first group)]\n                 (if (= elem x)\n                   (conj gs (conj group x))\n                   (conj packed (list x))))))\n           '()\n           xs)))","user":"5d47fa13e4b07c84aa5ae6b6"},{"code":"(fn f [r [a :as c]]\n  (if a\n    (f (conj r (take-while #(= % a) c))\n       (drop-while #(= % a) c))\n    r))\n[]","problem":31,"user":"4f0e4ebd535d0136e6c22322"},{"problem":31,"code":"(fn pack-a-sequence [s]\n  (partition-by identity s))","user":"569f4dabe4b0542e1f8d1491"},{"problem":31,"code":"#_(partition-by identity %)\n(fn [[x & xs]]\n  (reverse\n  (reduce (fn [[cur-seq & tail] elem]\n            (if (= elem (first cur-seq))\n              (cons (conj cur-seq elem) tail)\n              (cons (list elem) (cons cur-seq tail))))\n          [[x]] xs)))","user":"56521a26e4b0f9d632dd845f"},{"problem":31,"code":"reduce #(if (= (last (last %)) %2) (concat (drop-last %) [(conj (last %) %2)]) (concat % [[%2]])) '()","user":"54a7efdee4b09f271ff37c9d"},{"problem":31,"code":"(fn [list]\n              (let [current (first list)\n                    the-rest (rest list)]\n                (loop [packed []\n                       streak [current]\n                       list the-rest\n                       previous-item current]\n                  (if (empty? list)\n                    (if (empty? streak)\n                      packed\n                      (conj packed streak)\n                      )\n                    (let [current (first list)\n                          the-rest (rest list)\n                          packed (if (= current previous-item)\n                                   packed\n                                   (conj packed streak)\n                                   )\n                          streak (if (= current previous-item)\n                                   (conj streak current)\n                                   [current]\n                                   )]\n                      (recur packed streak the-rest current)\n                      )\n                    )\n                  )))","user":"5e491182e4b043cd24807a46"},{"code":"(fn pack ([sequ prev] \n  (let [f (first sequ) r (rest sequ) fp (first prev)]\n  (if (= sequ '()) [prev]\n  (if (or (= prev '()) (= f fp))\n    (pack r (cons f prev)) \n    (cons prev (pack r [f]))\n  ))))\n  ([sequ] (pack sequ '())))","problem":31,"user":"5239caa6e4b0d705d026ef27"},{"code":"#(reverse (reduce \n  (fn [r i] (if \n    (empty? r) \n    [[i]] \n    (if \n      (= (first (first r)) i) \n      (cons (cons i (first r)) (rest r))\n      (cons [i] r))))\n  [] %))","problem":31,"user":"4dbecb06535d020aff1edf6a"},{"code":"(fn [l]\n  (loop [toPack (reverse l) packed '()]\n    (let [firstPack (#(loop [[f & r] % founded '()]\n    (let [tempFound (cons f founded)]\n      (if (or (not (= f (first r))) (nil? (first r)))\n        tempFound\n        (recur r tempFound)))) toPack)]\n        (if (= (count toPack) 0)\n          packed\n          (recur (drop (count firstPack) toPack) (cons firstPack packed) )))))","problem":31,"user":"5220909fe4b0e6a83c89259f"},{"problem":31,"code":"(fn [x] (loop [answer [] current [] remaining x]\n          (if (empty? remaining)\n            (conj answer current)\n            (if(empty? current)\n              (recur answer [(first x)] (drop 1 remaining))\n              (if (= (last current) (first remaining))\n                (recur answer (conj current (first remaining)) (drop 1 remaining))\n                (recur (conj answer current) [(first remaining)] (drop 1 remaining))\n                )\n            )\n          )\n          )\n  )","user":"542baf7ce4b0dad94371f291"},{"problem":31,"code":"partition-by #(-> %)","user":"5027bbe3e4b01614d1633fef"},{"code":"#(partition-by (fn [x] identity x) %)","problem":31,"user":"4e21c0c7535d04ed9115e818"},{"code":"(fn pack [sq]\r\n     (loop [s (seq sq)\r\n            tmp ()\r\n            acc []]\r\n       (if (empty? s)\r\n         (conj acc tmp)\r\n         (if (= (first s) (first tmp))\r\n           (recur (rest s)\r\n                  (conj tmp (first s))\r\n                  acc)\r\n           (recur (rest s)\r\n                  (conj () (first s))\r\n                  (if (empty? tmp)\r\n                    acc\r\n                    (conj acc tmp)))))))","problem":31,"user":"4f82e14be4b033992c121c0c"},{"code":"(fn [s]\n  (loop [xs s result [] current []]\n    (cond (empty? xs) (if (empty? current) result (conj result current))\n          (empty? current) (recur (rest xs) result [(first xs)])\n          (= (first xs) (first current)) (recur (rest xs) result (conj current (first xs)))\n          true (recur xs (conj result current) []))))","problem":31,"user":"4fe8aef4e4b07c9f6fd12c6c"},{"code":"(fn [xs]\n   (loop [acc [] curr [(first xs)] coll (rest xs)]\n      (cond (empty? coll) (conj acc curr)\n            (= (last curr) (first coll)) (recur acc (conj curr (first coll)) (rest coll))\n            :else (recur (conj acc curr) [(first coll)] (rest coll)))))","problem":31,"user":"51e1a1fae4b06a68e693eaf6"},{"code":"(fn [xs]\n  (letfn [(do-split [acc xs]\n            (if (seq xs)\n              (let [x (first xs)\n                    [y xs'] (split-with #(= x %) xs)]\n                (recur (conj acc y) xs'))\n              (seq acc)))]\n    (do-split [] xs)))","problem":31,"user":"52487654e4b05ef8e38e63dc"},{"problem":31,"code":"(fn [x]\n  (reduce #(if (= %2 (last (last %1)))\n             (concat (butlast %1) \n                     (list (concat (last %1) \n                                   (list %2))))\n             (concat %1 (list (list %2))))\n          ()\n          x))","user":"5c538cb5e4b0fb8c5ffd99fb"},{"problem":31,"code":"(fn[c]\n  (loop [c c result []]\n    (if (seq c)\n      (let [a (take-while #(= (first c) %) c)]\n        (recur (nthrest c (count a))\n               (conj result a)\n               )\n        )\n      result\n      )\n    )\n  )","user":"57c7e7d9e4b05aa3c4741d0f"},{"problem":31,"code":"reduce (fn [acc x]\n          (if (= (peek (peek acc)) x)\n            (conj (pop acc) (conj (peek acc) x))\n            (conj acc [x])))\n        []","user":"5935b010e4b04f87174def55"},{"problem":31,"code":"(fn pack\n    [lista]\n    (partition-by identity lista))","user":"56fe2a2fe4b08d47c97781ad"},{"code":"(fn [l]\n    (loop [lst '()\n           cur '()\n           fst (first l)\n           snd (second l)\n           rst (drop 2 l)]\n      (cond\n       (nil? fst) lst\n       (nil? snd) (reverse (conj lst (conj cur fst)))\n       (= fst snd) (recur lst (conj cur fst) snd (first rst) (rest rst))\n       :else (recur (conj lst (conj cur fst)) '() snd (first rst) (rest rst)))))","problem":31,"user":"4f038b62535dcb61093f6b1c"},{"code":"(fn [sq]\n  (apply conj\n         (reduce (fn [[acc group] el]\n                   (if (= el (first group))\n                     [acc (conj group el)]\n                     [(conj acc group) [el]]))\n                 [[] [(first sq)]]\n                 (rest sq))))","problem":31,"user":"51f9527fe4b09be9c177e549"},{"problem":31,"code":"#(reverse (reduce\n     (fn [a b]\n       (if (= b (first (first a)))\n         (conj (rest a) (into (first a) (list b)))\n         (conj a (list b))\n         ))\n     '()\n     %))","user":"5c936583e4b048ec896c5a1c"},{"problem":31,"code":"(fn part [coll]\n  (partition-by identity coll))","user":"58e63de2e4b056aecfd47cad"},{"code":"(fn [zs] (reverse\n  (loop [xs zs\n         ys '()]\n    (if (= xs '())\n      ys\n      (recur\n        (drop-while #(= (first xs) %) xs)\n        (cons (take-while #(= (first xs) %) xs) ys))))))","problem":31,"user":"4ef8d47c535dced4c769f261"},{"problem":31,"code":"(fn [sq]\n  (let [f (fn [a b]\n  (if (= (last (last a)) b)\n    (conj (vec (butlast a)) (vec (cons b (last a))))\n    (conj a [b])))]\n  (reduce f [[(first sq)]] (rest sq))))","user":"4f856adfe4b033992c121c44"},{"code":"(fn [coll]\r\n  (loop [coll coll, acc []]\r\n    (if (seq coll)\r\n      (recur (drop-while #(= % (first coll)) coll)\r\n             (conj acc (take-while #(= % (first coll)) coll)))\r\n      acc)))","problem":31,"user":"4dbb1126535d1e037afb21b3"},{"problem":31,"code":"reduce #(let [v %1\n              l (last v)\n              el %2]\n          (if (contains? (set l) el)\n            (conj (pop v) (conj l el))\n            (conj v (list el))))\n[]","user":"5f81de6ce4b0c071e6c840f5"},{"code":"(fn mypack [lt]\r\n    ;acc always begin as '((first lt))\r\n    (letfn [(mypacka [lt acc]\r\n  \t     (if (empty? lt)\r\n\t\t       acc\r\n\t\t       (if (= (first lt) (first (first acc)))\r\n\t\t\t (mypacka (rest lt)\r\n\t\t\t\t  (cons (cons (first lt) (first acc)) (rest acc)))\r\n\t\t\t (mypacka (rest lt)\r\n\t\t\t\t(cons (list (first lt)) acc)))))]\r\n\t   (reverse (mypacka (rest lt) (list (list (first lt)))))))","problem":31,"user":"4e1b2cd9535d04ed9115e7fd"},{"code":"(fn [sq] (partition-by identity sq))","problem":31,"user":"52e276d9e4b09f7907dd1436"},{"code":"partition-by(fn[x]x)","problem":31,"user":"4e82f85d535db62dc21a62ce"},{"code":"(fn f [x]\n  (if (empty? x)\n    x\n    (cons (take-while #(= % (first x)) x)\n        (f (drop-while #(= % (first x)) (rest x))))))","problem":31,"user":"4f062d4a535dcb61093f6c08"},{"problem":31,"code":"(fn [xs]\n  (loop [result [] xr xs old nil store []]\n    (if (empty? xr) (filter #(not (empty? %)) (conj result store))\n      (let [x (first xr)]\n        (if (= x old)\n          (recur result              (rest xr) old (conj store x))\n          (recur (conj result store) (rest xr) x   [x])\n          )\n)\n)\n)\n)","user":"57d7c894e4b0bd073c2023de"},{"problem":31,"code":"(fn [s] \n  (reduce #(if (= (-> %1 last last) %2) (update-in %1 [(-> %1 count dec)] (fn [s] (conj s %2))) (conj %1 [%2])) [] s))","user":"53213810e4b09d4e7a9b54b0"},{"code":"(fn [s]\n  (loop [s s r [] c []]\n    (if (not (seq s))\n      (if (seq c)\n        (conj r c)\n        r)\n      (if (or (not (seq c)) (= (first s) (first c)))\n        (recur (rest s) r (conj c (first s)))\n        (recur (rest s) (conj r c) [(first s)])))))","problem":31,"user":"4dbdc9da535d020aff1edf4c"},{"problem":31,"code":"(fn compress [[x & xs]]\n  (let [remaining (drop-while (partial = x) xs)\n        repeating (take-while (partial = x) xs)]\n    (if (empty? xs)\n      (list (list x))\n      (cons\n        (cons x repeating)\n        (if (empty? remaining)\n          '()\n          (compress remaining))))))","user":"58ddac2ce4b0a4d5acaab6d6"},{"problem":31,"code":"(fn f ([s] (if (empty? s) s (f (rest s) (first s) (list (first s)))))\n  ([s fs fss] (if (= fs (first s)) (f (rest s) fs (cons (first s) fss)) (cons fss (f s)))))","user":"54d95ce8e4b024c67c0cf74a"},{"problem":31,"code":"reduce (fn [acc item]\n            (if (= (last (last acc)) item)\n              (concat (butlast acc) (list (conj (last acc) item)))\n              (concat acc (list (list item)))\n              ))\n          '()","user":"5e84b48ee4b09a7a73c8bbc8"},{"code":"(fn f [[x & xs :as s]]\n  (if x\n    (let [[a b] (split-with #(= x %) s)]\n      (cons a (f b)))))","problem":31,"user":"4e8ccd16535d65386fec212e"},{"problem":31,"code":"(fn t [seq]\n  (loop [s (rest seq)\n         current-seq (list (first seq))\n         r (list)]\n    (if-not (empty? s)\n      (let [current-ele (first s)\n            current-seq-ele (first current-seq)]\n        (if (= current-ele current-seq-ele)\n          (recur (rest s) (conj current-seq current-ele) r)\n          (recur (rest s) (list current-ele) (conj r current-seq))))\n      (reverse (conj r current-seq))\n      )))","user":"58de563fe4b0a4d5acaab6e3"},{"problem":31,"code":"(fn [startcol]\n  (\n    loop [col startcol acc []]\n    (if (empty? col)\n      acc\n\n      (if (= (first col) (last (last acc)))\n        (recur (rest col) (conj (vec (butlast acc)) (conj (last acc) (first col))))\n        (recur (rest col) (conj acc [(first col)]))\n        )\n      )\n    )\n  )","user":"53b0750fe4b047364c044483"},{"code":"(fn myPack\n    ([x y]\n        (let [z (take-while (fn [v] (= (first x) v)) x)]\n            (if (empty? x)\n                y\n            (myPack (drop (count z) x) (concat y [z])))))\n    ([x] (myPack x [])))","problem":31,"user":"4f03b3fb535dcb61093f6b52"},{"problem":31,"code":"(fn [c] \n  (reduce\n    #(cond \n      (empty? %1) (list (list %2))\n      (contains? (set (last %1)) %2)\n      (if (= (count %1) 1)\n        (list (conj (last %1) %2))\n        (concat (butlast %1) (list (conj (last %1) %2))))\n      :else\n      (concat %1 (list (list %2))))\n   '() c))","user":"5e3071abe4b05b4b01516213"},{"problem":31,"code":";;#(partition-by identity %)\n(fn my-partition-by\n  [collection]\n  (reduce (fn\n            [c val]\n            (if (= (last (last c)) (identity val))\n              (conj (pop c) (conj (last c) val))\n              (conj c (conj [] val)))) [] collection))","user":"57d0cd58e4b0bd073c20235e"},{"problem":31,"code":"(fn [n]\n  (partition-by identity n))","user":"562a58e8e4b00e49c7cb4822"},{"problem":31,"code":"reduce (fn [acc v] \n         (if (= v (first (last acc)))\n           (conj (vec (butlast acc)) (conj (last acc) v))\n           (conj acc [v]))) []","user":"60ade833e4b00e9e6653c494"},{"problem":31,"code":"#(loop [l %1\n         out '()]\n    (println l)\n    (if (empty? l)\n      (reverse out)\n      (recur (drop-while (fn [x] (= x (first l)))\n              l)\n             (conj out (take-while (fn [x] (= x (first l)))\n                                   l)))))","user":"562fb774e4b0ab312c17ebd9"},{"code":"(fn [x]\n  (reduce\n    (fn [y, z]\n      (if\n        (= z (last (last y)))\n        (conj (pop y) (conj (last y) z))\n        (conj y [z]))) [[(first x)]] (rest x)))","problem":31,"user":"4ee259a1535d10e5ff6f5366"},{"problem":31,"code":"(comp reverse\n       #(loop [[cur & _ :as whole] %\n               result ()]\n          (if cur\n            (if (= cur (ffirst result))\n              (recur (next whole) (conj (rest result) (conj (first result) cur)))\n              (recur (next whole) (conj result (list cur))))\n            result)))","user":"5712854ce4b07c98581c3a89"},{"problem":31,"code":"(fn [xs]\n  ((fn pack [xs curr ys]\n    (cond\n      ; If xs is empty, return ys, we're done\n      (empty? xs)\n      (reverse (if (empty? curr)\n        ys\n        (conj ys curr)))\n\n      ; If xs is not empty, check if curr is empty\n      ; or if the elements in curr match the next\n      ; element\n      (or\n       (empty? curr)\n       (= (first curr) (first xs)))\n\n      (pack (rest xs) (conj curr (first xs)) ys)\n\n      ; Else, flush curr\n      :else\n      (pack (rest xs) (list (first xs)) (conj ys curr)))) xs '() '()))","user":"5e394c33e4b01d43a70e8dd1"},{"problem":31,"code":"#(loop [xs %\n        acc ()]\n   (if (empty? xs)\n     (reverse acc)\n     (let [[ys rest] (split-with #{(first xs)} xs)]\n       (recur rest (cons ys acc)))))","user":"583e27e2e4b089d5ab817daa"},{"code":"reduce (fn processlist [acc i]\n  (let [l (last acc)]\n    (if (or (empty? l) (not= (last l) i))\n      (conj acc (list i))\n      (conj (into [] (butlast acc)) (conj l i)))))  []","problem":31,"user":"51aefceee4b09397d5109797"},{"problem":31,"code":"(fn [xs]\n  (next (reverse (let [{:keys [history group]}\n                       (reduce (fn [{:keys [history previous group]} v]\n                                 {:history (if (not= v previous)\n                                             (conj history group)\n                                             history)\n                                 :previous v :group\n                                 (if (= v previous) (conj group v) (list v))}) {} xs)] (conj history group)))))","user":"4fcf1755e4b03432b189f40c"},{"problem":31,"code":"(fn [coll]\n      (->  (reduce (fn [acc x]\n             (let [xs (first acc)\n                   y (first xs)]\n               (if (= x y)\n                 (conj (drop 1 acc) (conj xs x))\n                 (conj acc (list x))))) [] coll)\n           reverse))","user":"5d29c06be4b01671435dbc6b"},{"code":"(fn [x]\n\t(reverse\n\t(reduce\t\t\n\t\t(fn [a b] \t\t\t\t\n\t\t\t(if (= (first (first a)) b)\n\t\t\t\t(cons (into (first a) (list b)) (rest a))\n\t\t\t\t(conj a (list b))))\n\t\t(cons (list (list (first x))) (rest x)))))","problem":31,"user":"51794ec2e4b0684c1c981a45"},{"code":"(fn [s]\n  (loop [s s\n         groups '()]\n  (if (seq s)\n    (let [[g r] (split-with #(= % (first s)) s)]\n      (recur r (conj groups g)))\n    (reverse groups))))","problem":31,"user":"52be5d55e4b07a9af579231e"},{"code":"#(loop [list % acc [] cnt 0]\n  (if (not (second list))\n    (conj acc (repeat (inc cnt) (first list)))\n    (if (= (first list) (second list))\n      (recur (next list) acc (inc cnt))\n      (recur (next list) (conj acc (repeat (inc cnt) (first list))) 0))))","problem":31,"user":"523b10dfe4b02f719975bdb8"},{"code":"#(partition-by (fn [a] (do a)) %)","problem":31,"user":"51efa6a6e4b0249c592fbde8"},{"problem":31,"code":"#(loop [x % t [] s []]\n   (if (empty? x)\n    (if (empty? t)\n      s\n      (conj s t))\n    (if (empty? t)\n     (recur (rest x) (conj t (first x)) s)\n     (if (= (first x) (first t))\n      (recur (rest x) (conj t (first x)) s)\n      (recur (rest x) [(first x)] (conj s t))))))","user":"549e5e52e4b0f3d1d8e70f9e"},{"problem":31,"code":"(fn pack-a-sequence [xs]\n  (partition-by identity xs))","user":"557bcce4e4b05c286339e0b9"},{"problem":31,"code":"#(letfn [(f\n  ([s] (f s [] []))\n  ([s collector result]\n  (if (first s)\n    (if (apply = (conj collector (first s)))\n      (f (rest s) (conj collector (first s)) result)\n      (f (rest s) [(first s)] (conj result collector)))\n    (conj result collector))))]\n   (f %))","user":"576aea4fe4b0a07e8fc18126"},{"problem":31,"code":"(fn [x]\n  (->> x\n       (partition-by identity)))","user":"528e441be4b0239c8a67aed8"},{"code":"(fn [x]\r\n  (loop [packed '() unpacked x current '()]\r\n    (if (empty? unpacked)\r\n      (rest (reverse (conj packed current))) \r\n      (if (= (first current) (first unpacked))\r\n        (recur packed (rest unpacked) (conj current (first unpacked)))\r\n        (recur (conj packed current) (rest unpacked) (conj '() (first unpacked)))))))","problem":31,"user":"4df3df8a535d08e6dec9fe2d"},{"problem":31,"code":"#(map (fn [c] into '() c) (->\n               (reduce (fn [{:keys [lst sq] :as acc} e]\n                         (if (= e lst)\n                           {:lst e :sq (merge  (rest sq) (conj (first sq) e))}\n                           {:lst e :sq (merge sq (vector e))}\n                           ))\n                       {:lst nil :ctx [] :sq []}\n                       %)\n               :sq\n               reverse))","user":"53b05a75e4b047364c044482"},{"problem":31,"code":"(fn [s]\n(reduce\n  (fn [z h]\n      (let [last-list (last z)\n            last-item (last last-list)]\n          (if (= last-item h)\n              (conj (into [] (drop-last z)) (conj last-list h))\n              (conj z [h]))))\n  [[(first s)]]\n  (rest s)))","user":"5b15811ee4b0cc2b61a3be6f"},{"code":"(fn [s] \n  (reverse (reduce #(if (= (last (first %1)) %2)\n                        (conj (rest %1) (conj (first %1) %2))\n                        (conj %1 (conj '() %2))) '() s)))","problem":31,"user":"4f280840e4b0d6649770a010"},{"problem":31,"code":"(fn [sq]\n   (loop [sq sq result [] subresult []]\n     (if (empty? sq)\n       (conj result subresult)\n       (if (or (empty? subresult) (= (first sq) (first subresult)))\n         (recur (rest sq) result (conj subresult (first sq)))\n         (recur sq (conj result subresult) [])))))","user":"602b90c1e4b0d5df2af22266"},{"problem":31,"code":"#(reverse (reduce (fn [nseq item]\n          (if (= item (last (first nseq)))\n            (cons (conj (first nseq) item) (drop 1 nseq))\n            (cons (list item) nseq)))\n        '()\n        %1))","user":"589c2e3fe4b00487982d5357"},{"problem":31,"code":"reduce\n    (fn [r v]\n        (if (or (empty? r) (not= (-> r last last) v))\n            (conj r (vector v))\n            (update-in r [(-> r count dec)] conj v)))\n    []","user":"57ae3345e4b0fbc9809a271e"},{"problem":31,"code":"(fn [collection]\n  (loop [result '(),data collection, prev 0 ]\n    (if (empty? data)\n    (reverse result)\n    (recur (if(not= prev (first data))\n             (conj result (list (first data)))\n             (conj (rest result)(conj (first result) (first data))\n                   )) (rest data) (first data))\n    )\n  )\n)","user":"59228b00e4b026ae38521281"},{"problem":31,"code":"(fn [x]\n  (loop [res '() sq (rest x) cur (list (first x))]\n    (if (empty? sq)\n      (reverse (conj res cur))\n      (if (= (first cur) (first sq))\n        (recur res (rest sq) (conj cur (first sq)))\n        (recur (conj res cur) (rest sq) (list (first sq)))))))","user":"5700ec08e4b08d47c97781cd"},{"code":"(fn pack-seq [coll]\n  (partition-by identity coll))","problem":31,"user":"53713ed9e4b0fc7073fd6eaf"},{"problem":31,"code":"(fn pack-duplicates\n  [coll]\n  (partition-by identity coll))","user":"5a429e40e4b0447ef91cc5f9"},{"code":"(fn pack [aSequence]\n  (let [pack* (fn [[a & b :as aSequence] acc]\n                (when (seq aSequence)\n                  (let [[packed b] (split-with {a true} aSequence)]\n                    (if (seq b)\n                      (recur b (conj acc packed))\n                      (conj acc packed)))))]\n    (pack* aSequence [])))","problem":31,"user":"50ee145de4b06330c1f87c53"},{"code":";(defn myappend [accum, l]\n;  (println \"Accum is\" accum)\n;  (conj (pop accum) (conj (last accum) l)))\n\n(fn pack [l]\n  (reduce (fn [accum elem]\n            (if (= accum (empty accum))\n              [[elem]]\n              (if (= (last (last accum)) elem)\n                (conj (pop accum) (conj (last accum) elem))\n                ;(myappend accum elem)\n                (conj accum [elem])))) [] l))","problem":31,"user":"4fe49706e4b0e8f79898feb7"},{"problem":31,"code":"(fn pack-dupes [s]\n  (when (seq s)\n    (cons\n     (take-while #{(first s)} s)\n     (pack-dupes (drop-while #{(first s)} s)))))","user":"5446c89ce4b032a45b8693b5"},{"code":"(fn pack [x]\n  (loop [x x prev nil res nil]\n    (cond (empty? x) \n            (drop 1 (reverse (cons prev res)))\n          (= (first prev) (first x)) \n            (recur (rest x) (conj prev (first x)) res)\n          :else\n            (recur (rest x) (vector (first x)) (cons prev res))\n    )\n  )\n)","problem":31,"user":"50588af1e4b06522596eba7d"},{"problem":31,"code":"#(reduce \n  (fn [[[x & _ :as duplicates] & xs :as all] el]\n  \t(if (= x el)\n    \t(conj xs (conj duplicates el))\n    \t(conj all (conj '() el)))) \n  '() (reverse %))","user":"566e87cfe4b0a866af6896dc"},{"code":"(fn [values]\n  (partition-by identity values))","problem":31,"user":"50621cbde4b0341461c88951"},{"problem":31,"code":"(fn [myseq]\n  (loop [result []\n        remseq myseq]\n    (if (empty? remseq)\n      result\n      (if (= (first remseq) (first (last result)))\n        (recur (conj (pop result) (conj (peek result) (first remseq))) (rest remseq))\n        (recur (conj result (conj () (first remseq))) (rest remseq))))))","user":"60726211e4b069485764de36"},{"problem":31,"code":"(fn [c]\n   (reverse (reduce \n    (fn [r a]\n      (if (empty? r)\n        (list (list a))\n        (if (= (first (first r)) a)\n          (conj\n           (rest r)\n           (conj (first r) a))\n          (conj r (list a)))))\n    '() c)\n  ))","user":"561e8b11e4b064ca9f4b16c0"},{"code":"(fn pack [xs]\n  (seq\n    (let [n (count xs)]\n      (loop [xs' [] i 0]\n            (if (= i n)\n              xs'\n              (let [xi (nth xs i)\n                    j (loop [j i]\n                            (if (and (< j n) (= (nth xs j) xi))\n                              (recur (inc j))\n                              j\n                              ))]\n                (recur (conj xs' (repeat (- j i) xi)) j)))))))","problem":31,"user":"508157b2e4b0946d0443855c"},{"problem":31,"code":"(fn p [l] \n  (if (<= (count l) 1) \n    (list l) \n    (let [r (p (rest l)) f (first l) a (list f)] (if (= f (second l))\n      (concat (list (concat a (first r))) (rest r))\n      (concat (list a) r)))))","user":"553c05b7e4b09218d5f45011"},{"code":"(fn [sq]\n(loop [sub-list '() data sq acc []]\n    (if (empty? data)\n      (conj acc sub-list)\n      (if  (or (empty? sub-list) (= (first sub-list) (first data)))\n        (recur (cons (first data) sub-list) (rest data) acc)\n        (recur '() data (conj acc sub-list))))))","problem":31,"user":"518ebcdce4b0cd6ff5167698"},{"problem":31,"code":"#(reverse \n  (reduce (fn [a b]\n              (if (empty? a)\n                  (list (list b))\n                  (if (= (ffirst a) b)\n                      (cons \n                       (conj (first a) b) \n                       (rest a))\n                      (cons (list b) a))))\n          '()\n          %))","user":"5830377ee4b051871117c004"},{"problem":31,"code":"(fn unique [data]\n  (loop [[head & tail :as data] data\n                         uacc []\n                         acc  () ]\n               (if-not (empty? data)\n                    (if (= head (first tail))\n                      (recur tail uacc (conj acc head))\n                      (recur tail (conj uacc (conj acc head)) ())\n                    )\n                    uacc\n               )\n  )\n)","user":"55c461d3e4b0e31453f64999"},{"problem":31,"code":"#(reverse (reduce (fn [l m] (if (= (first (first l)) m)\n  (cons (cons m (first l))(rest l))\n  (cons (list m) l)\n  )) () %))","user":"55bedd93e4b01b9910ae2a0d"},{"problem":31,"code":"(fn pack\n  [input-seq]\n  (seq (reduce (fn [return-lis item]\n                   (let [last-elem-arr (peek return-lis)]\n                     (if (= (first last-elem-arr) item)\n                       (conj (pop return-lis) (conj last-elem-arr item))\n                       (conj return-lis (list item))\n                     )))\n         []\n         input-seq)))","user":"5eecd339e4b07c55ae4a0507"},{"code":"(fn [x] (partition-by #(list %) x))","problem":31,"user":"4f34eb87e4b0e243712b1eba"},{"problem":31,"code":"(fn [coll]\n  (loop [coll coll, state (first coll), buffer [], res []]\n    (if (seq coll)\n      (if (= (first coll) state)\n        (recur (rest coll) state (conj buffer (first coll)) res)\n        (recur (rest  coll) (first coll) [(first coll)] (conj res buffer)))\n        \n      (conj res buffer))))","user":"5e76274ce4b085ba37836deb"},{"code":"(fn [coll] (partition-by identity coll))","problem":31,"user":"4ea11921535d7eef308072af"},{"problem":31,"code":"(fn [coll]\n  (reverse (filter\n            #(not= % '(nil))\n            (reduce (fn [[[acc-ff & acc-fr] & acc-r] e]\n                      (if (= e acc-ff)\n                        (concat (list (conj acc-fr acc-ff e)) acc-r)\n                        (concat (list (list e)) (list (conj acc-fr acc-ff)) acc-r))) '(()) coll))))","user":"58a953dae4b01a0c0b232968"},{"problem":31,"code":"(fn [s]\n  (reduce \n   (fn [result cur] \n     (let [prev (last result)\n           prev-item (last prev)] \n       (if (= prev-item cur) \n         (concat \n          (drop-last 1 result) \n          [(concat prev [cur])]) \n         (concat result [[cur]])))) \n   [] \n   s))","user":"5526ecc4e4b0ffed3738f928"},{"code":"(fn pack [coll]\r\n  (reduce (fn [acc nxt]\r\n            (if (= (first (last acc)) nxt)\r\n              (concat (butlast acc) (list (cons nxt (last acc))))\r\n              (concat acc (list (list nxt)))))\r\n          '()\r\n          coll))","problem":31,"user":"4e7e4a1f535db169f9c7970c"},{"code":"partition-by max\n; sneaky; max is being used as an identity function.\n; same as\n; partition-by identity","problem":31,"user":"4f82ed48e4b033992c121c0e"},{"code":"(fn pack [xs]\n  (reverse (reduce\n   #(if (= (ffirst %1) %2)\n      (cons (cons %2 (first %1)) (rest %1))\n      (cons (list %2) %1 ))\n   '()\n   xs)))","problem":31,"user":"51181009e4b0e0897831a60f"},{"problem":31,"code":"(fn [c]\n  (loop [[head & tail] c\n         s '()\n         z '()]\n    (if (= head nil)\n      (reverse  (conj s z))\n      (if (empty? z)\n        (recur tail s (conj z head))\n        (if (= head (first z))\n          (recur tail s (conj z head))\n          (recur tail (conj s z) (seq [head])))))))","user":"5701f886e4b08d47c97781d9"},{"code":"(fn pack [x] (let [i ((fn fitems [x] (loop [i 1] \n                   (if (not (and (not (= (count x) i)) (= (first x) (nth x i)) )) \n                   i\n                   (recur (inc i))))) x) s x]\n                 (if (> (count s) i)\n                   (concat (list (take i s)) (pack (drop i s)))\n                   (list s))))","problem":31,"user":"4e5e9f6b535d8a8b8723a2d2"},{"code":"(fn [coll]\n  (loop [[f & fs] (rest coll)\n         result []\n         last-pack [(first coll)]]\n    (cond\n     (nil? f) (conj result last-pack)\n     (= f (first last-pack)) (recur fs result (conj last-pack f))\n     :else (recur fs (conj result last-pack) [f]))))","problem":31,"user":"50ed3c6be4b01236b1d4983b"},{"problem":31,"code":"(fn [coll]\n  (loop [xs []\n         ys [(first coll)]\n         zs (rest coll)]\n    (if (empty? zs)\n      (conj xs ys)\n      (let [x (first zs)]\n        (if (= x (first ys))\n          (recur xs (conj ys x) (rest zs))\n          (recur (conj xs ys) [x] (rest zs)))))))","user":"5032748ae4b0e78df07b092f"},{"code":"(fn [s]\n  (loop [out () in s]\n    (if (empty? in)\n      (reverse out)\n      (let [i (first in)]\n      \t(recur (if (= i (first (first out)))\n               (cons (cons i (first out)) (rest out))\n               (cons (list i) out))\n               (rest in))))))","problem":31,"user":"536eb396e4b0fc7073fd6e74"},{"code":"(fn [xs] \n  (loop [s0 '() s1 '() s2 xs] \n    (if s2 \n      (let [f (first s2)]\n        (if (= f (second s2)) \n          (recur s0 (concat s1 [f]) (next s2))\n          (recur (concat s0 (if (= 0 (count s1)) (list (list f)) [(conj s1 f)])) '() (next s2))\n        )\n      )\n      s0\n    )\n  )\n)","problem":31,"user":"50b24a2fe4b03ea88043355c"},{"problem":31,"code":"(fn [lst]\n  (loop [lst (rest lst)\n         acc []\n         cur (list (first lst))]\n    (cond\n     (empty? lst) (conj acc cur)\n     (not (= (first cur) (first lst)))\n         (recur (rest lst) (conj acc cur) (list (first lst)))\n      :else (recur (rest lst) acc (conj cur (first lst))))))","user":"51c116d4e4b0c9c822882942"},{"code":"(fn foo[coll]\n  (if (empty? coll) '() \n    (concat (list ((fn bar[coll1]\n      (cond \n        (empty? coll1) '()\n        (= 1 (count coll1)) coll1\n        (= (first coll1) (first (rest coll1)))\n          (concat (list (first coll1)) (bar (rest coll1)))\n        :else\n        (list (first coll1)))) coll) )\n     (foo ((fn baz[coll1]\n       (cond\n        (empty? coll1) '()\n        (= 1 (count coll1)) '()\n        (= (first coll1) (first (rest coll1))) (baz (rest coll1))\n        :else\n        (rest coll1)))coll))\n)))","problem":31,"user":"5078300de4b0fc74642bff66"},{"problem":31,"code":"partition-by identity\n\n;(fn pack \n;  ([xs] (pack [] xs))\n;  ([res xs]\n;   (if (empty? xs) \n;     res \n;     (pack  \n;       (conj res (take-while \n;        #(=(first xs) %) xs)) \n;      (drop-while #(=(first xs) %) xs)))))","user":"55357ab5e4b09218d5f44faf"},{"problem":31,"code":"(fn [x] (seq (partition-by identity x)))","user":"558a81fbe4b027778923761c"},{"problem":31,"code":"(fn pack-sequence [xs]\n  (reduce (fn [acc x]\n            (prn acc)\n            (if (= (first (last acc)) x)\n              (conj (vec (butlast acc)) (conj (last acc) x))\n              (conj acc [x])))\n          []\n          xs))","user":"5687b6abe4b0dcc4269f4061"},{"problem":31,"code":"#(reverse (reduce (fn [acc x] (if (= x (first (first acc)))\n                          (cons (cons x (first acc)) (rest acc)) \n                          (cons [x] acc))) '() %))","user":"552b6ddbe4b0ffed3738f965"},{"code":"(fn pack [seq]\r\n  (reduce (fn [acc e] (if (= (last (last acc)) e)\r\n                          (conj (vec (drop-last acc)) (conj (last acc) e))\r\n                          (conj acc [e])))\r\n    [] seq))","problem":31,"user":"4f13047d535d64f60314642c"},{"problem":31,"code":"(fn [xs]\n  (letfn [(pack [xs]\n                (if (empty? xs)\n                  xs\n                  (let [pivot (first xs)\n                        ys (rest xs)]\n                    (concat\n                     (list (cons pivot (take-while #(= % pivot) ys)))\n                     (pack (drop-while #(= % pivot) ys))))))]\n    (pack xs)))","user":"57377ae8e4b0cd1946bd1046"},{"code":"(fn pck [seqn]\n  (reverse (reduce #(if \n             (and \n              (coll? (first %1))\n              (= (first(first %1)) %2)) (conj (rest %1) (conj (first %1) %2)) (conj %1 (list %2))) '() seqn))\n    )","problem":31,"user":"5274eb56e4b03e8d9a4a74bb"},{"problem":31,"code":"#((fn [[acc y cnt]] (conj acc (repeat cnt y))) (reduce (fn [[acc y cnt] x] (if (= y x) [acc y (inc cnt)] [(conj acc (repeat cnt y)) x 1])) [[] (first %) 1] (drop 1 %)))","user":"5a5be1ece4b0512ff01cd90f"},{"code":"(fn [xs] (reduce #(if (or (empty? %1) (= (first (first %1)) %2))\n             (concat (list (conj (first %1) %2)) (next %1))\n                     (cons (list %2) %1)) '() (reverse xs)))","problem":31,"user":"52161db6e4b0bf4bffd29cb8"},{"code":"(fn [xs]\r\n  (reduce\r\n    (fn [ys x]      \r\n      (if (= (last (last ys)) x)\r\n        (update-in ys [(dec (count ys))] (fn [zs] (conj zs x)))\r\n        (conj ys [x])))\r\n    [] xs))","problem":31,"user":"4e513758535dc968683fc4f3"},{"problem":31,"code":"(fn [[x & xs]]\n  (loop [[y & ys] xs\n         prev x\n         run [x]\n         out []]\n    (if ys\n      (if (not= y prev)\n        (recur ys y [y] (conj out run))\n        (recur ys y (conj run prev) out))\n      (if (not= y prev)\n        (conj out run [y])\n        (conj out (conj run y))))))","user":"597d0e43e4b0dbe32238d095"},{"code":"(fn [x]\n  (letfn\n    [(chop [x] (if (empty? x) nil\n                 (let [[chnk tail] (split-with #(= % (first x)) x)]\n                   (cons chnk (chop tail)))))]\n    (chop x)))","problem":31,"user":"515ead6be4b049add99a053e"},{"problem":31,"code":"(fn pack [lst]\n  (partition-by identity lst))","user":"57fc08d8e4b0d3187e900988"},{"code":"#(reverse (reduce \n          (fn [[h & t :as all] y] \n            (if (= y (first h)) \n              (cons (cons y h) t) \n              (cons (list y) all)))\n          '() % ) )","problem":31,"user":"519b7d76e4b02a926d9a436e"},{"code":"(fn [s]\n  (loop [res [] repsec [(first s)] secu s]\n    (if (empty? secu)\n      res\n      (let [fs (first secu) rs (rest secu) frs (first rs)]\n        (if (= fs frs)\n          (recur res (conj repsec fs) rs)\n          (recur (concat res [repsec]) [frs] rs))))))","problem":31,"user":"51721aefe4b0d70c8bbbf24a"},{"problem":31,"code":"(fn\n [s]\n  (partition-by identity s)\n )","user":"6074f5ede4b069485764de52"},{"problem":31,"code":"(fn cmp [x] (rest (first (reduce (fn [[acc intermediate prev] y] (if (= prev y) [acc (concat intermediate (list y)) y] [(concat acc (list intermediate)) (list y) y] )) ['(), '(), nil] (concat x (list nil)))) ) )","user":"563b559ee4b0bfe05bf1180d"},{"problem":31,"code":"(fn [coll]\n  (loop [[x & xs] (rest coll) prev (first coll) prevacc [(first coll)] acc []]\n    (if x\n      (if (= x prev)\n        (recur xs x (cons x prevacc) acc)\n        (recur xs x [x] (conj acc prevacc))\n        )\n      (conj acc prevacc)\n      )\n    )\n  )","user":"56edf2dde4b04a395b9a044b"},{"code":"(fn cap[l]\n  (reverse\n  (reduce (fn [x y]\n            (if (= (first (first x)) y)\n              (conj (next x) (conj (first x) y))\n              (conj x (list y))\n              )\n            ) \n          (list (list (first l))) \n          (next l)\n  )))","problem":31,"user":"51d10b1fe4b067c36548635e"},{"problem":31,"code":"(fn pack [xs]\n  (reverse\n   (reduce (fn [res x]\n             (let [[r & rs] res]\n               (if (= x (first r))\n                 (cons (cons x r) rs)\n                 (cons (list x) res))))\n           '() xs)))","user":"5eee7311e4b07c55ae4a0510"},{"code":"(fn [seq]\n  (loop [packed nil\n         seq seq]\n    (let [[packed' unpacked']\n          (loop [[c & seqr :as seq] seq\n                 [c' & _ :as seq'] nil]\n            (if (or (not c')\n                    (= c c'))\n              (recur seqr (cons c seq'))\n              [seq' seq]))]\n      (if unpacked'\n        (recur (cons packed' packed)\n               unpacked')\n        (reverse (cons packed' packed))))))","problem":31,"user":"516ff477e4b034fe8eaf70f3"},{"code":"(fn pack [s]\n  (loop [l (rest s) cur (take 1 s) o []]\n    (if (= (count l) 0)\n      (conj o (vec cur))\n      (if (= (first l) (first cur) )\n        (recur (rest l) (conj cur (first l) )  o )\n        (recur  (rest l)  (take 1 l)  (conj o (vec cur) )))) ) )","problem":31,"user":"5101192ae4b0bef64c30e266"},{"problem":31,"code":"#(reduce (fn [seq item]\n            (if (= item (last (last seq)))\n              (concat (drop-last 1 seq) (list (concat (last seq) [item])))\n              (concat seq (list (list item))))\n            ) (list (take 1 %)) (drop 1 %))","user":"5c6d0e51e4b0fca0c1622735"},{"code":"(fn [data]\n  (loop [p (first data)\n         e (first data)\n         coll (rest data)\n         acc-1 []\n         acc []] \n    (cond\n     (nil? e) (conj acc acc-1)\n     (= p e) (recur p (first coll) (rest coll) (conj acc-1 e) acc)\n     true (recur e (first coll) (rest coll) (vector e) (conj acc acc-1)))))","problem":31,"user":"4fdbc075e4b05e33b9224f61"},{"problem":31,"code":"(fn pack\n  [lst]\n  (if (empty? lst)\n    ()\n    (if (= (first lst) (first(first (pack(rest lst)))))\n      (cons (cons (first lst) (first (pack (rest lst)))) (rest (pack(rest lst))))\n      (cons (cons (first lst)  ()) (pack (rest lst))))))","user":"59e8fef3e4b0249b72820743"},{"code":"#(apply list( partition-by identity %1) )","problem":31,"user":"51227a00e4b068a9582e656b"},{"problem":31,"code":"reduce (fn [acc x]\n  (let [segment (last acc)]\n    (if (= x (first segment))\n      (concat (drop-last acc) [(cons x segment)])\n      (concat acc [(cons x '())])))) []","user":"5773f3a9e4b0979f896515f2"},{"problem":31,"code":"#(reduce (fn[a b] \n           (if (= b (first (last a)))\n             (update-in a [(dec (count a))] conj b)\n             (conj a [b]))) [] %)","user":"56d63729e4b0ea9b8538f7ca"},{"code":"(fn pack [xs]\n  (if (empty? xs)\n    '()\n    ((fn [pair] (cons (nth pair 0) (pack (nth pair 1))))\n        (split-with (partial = (first xs)) xs))))","problem":31,"user":"4e691c79535d8ccf87e9fe97"},{"problem":31,"code":"(fn[coll]\n  (loop [in coll\n         mid '()\n         out '()]\n    (if (not (seq in))\n      (rest (reverse (conj out mid)))\n      (if (= (first in) (first mid))\n        (recur (rest in) (conj mid (first in)) out)\n        (recur (rest in) (conj '() (first in)) (conj out mid))))))","user":"5713f874e4b07c98581c3ab1"},{"code":"(fn pack [s]\n  (loop [r s acc []]\n  (if (seq r) (recur (drop-while #( = % (first r)) r)\n                     (conj acc (take-while #( = % (first r)) r)))\n              acc)))","problem":31,"user":"4eb0a757535d7eef3080733d"},{"problem":31,"code":"(fn [input]\n    (loop [values input\n           last-value nil\n           acc []]\n      (if-let [value (first values)]\n        (if (= value last-value)\n          (recur (rest values)\n                 last-value\n                 (assoc acc (- (count acc) 1) (conj (last acc) value)))\n          (recur (rest values)\n                 value\n                 (conj acc (vector value))))\n        acc)))","user":"54508859e4b0e397800069a3"},{"problem":31,"code":"(comp rest reverse #(loop [t nil l % r nil]\n   (cond (empty? l) (conj r t) \n         (= (first t) (first l)) (recur (conj t (first l)) (rest l) r)\n         :else (recur (conj nil (first l)) (rest l) (cons t r)))))","user":"592bb806e4b072a2710fcf46"},{"code":"(fn dedupe ([xs] (rest (dedupe [] [] xs)))\n  \t\t   ([newxs acc xs] (if (empty? xs)\n                           \t   (conj newxs acc)\n\t                           (if (= (last acc) (first xs))\n                                 (dedupe newxs (conj acc (first xs)) (next xs))\n                                 (dedupe (conj newxs acc) [(first xs)] (next xs))\n                             )\n                       )\n           )\n)","problem":31,"user":"52bf8e35e4b07a9af579233a"},{"code":"(fn pack\n     ([l] (rest (reverse (pack l '() '()))))\n\t   ([l, acc, prev] (\n\t       if (empty? l) (conj acc prev)\n\t\t  (if (= (first l) (last prev))\n\t\t      (pack (rest l) acc (conj prev (first l)))\n\t\t      (pack (rest l) (conj acc prev) (list (first l)))))))","problem":31,"user":"4f8b05d2e4b02e764a0a5176"},{"problem":31,"code":"(fn [master-list] \n   (let [step (fn [llists item] \n    (if (= (ffirst llists) item)\n           (cons (conj (first llists) item) (rest llists))\n           (cons (list item) llists)))]\n     (reverse (reduce step '() master-list ))))","user":"4fc57c4ce4b0ee37620e17f6"},{"problem":31,"code":"(fn [col]\n   (partition-by identity col))","user":"5e1c3e6ee4b0dc9594008530"},{"problem":31,"code":"(fn f [seq]\n   (if (not (empty? seq))\n     ;; main body\n     (let [f-rest (f (rest seq))]\n       (if (= (first seq)\n              (first (first f-rest)))\n         (conj (rest f-rest) (conj (first f-rest) (first seq)))\n         (conj f-rest (list (first seq)))))\n     ;; base case\n     '()))","user":"589f37e0e4b02bd94d917e79"},{"problem":31,"code":"(fn packrep [x]\n  (loop [res []\n         in x]\n    (if (empty? in)\n      (seq res)\n      (recur (if (= (first in) (first (last res)))\n               (conj (pop res) (conj (peek res) (first in)))\n               (conj res (list (first in))))\n             (next in)))))","user":"5b596d0ce4b02d533a91bd7a"},{"code":"(fn pack[x]\n  (\n    (fn pack_next[current, remaining, packed]\n      (if\n        (= 0 (count remaining))\n        (if\n          (= 0 (count current))\n          packed\n          (concat packed [current])\n        )\n        (if\n          (= (first current) (first remaining))\n          (pack_next (concat current [(first remaining)]) (rest remaining) packed)\n          (pack_next (list (first remaining)) (rest remaining) (concat packed [current]))\n        )\n      )\n    ) (list (first x)) (rest x) (list)\n  )\n)","problem":31,"user":"52624348e4b03e8d9a4a707e"},{"code":"(fn pack [s]\n    (if (seq s)\n      (let [[f r] (split-with #(= % (first s)) s)]\n        (cons f (pack r)))\n      s))","problem":31,"user":"4ed15f60535d44c135fd68cd"},{"problem":31,"code":"(fn sublist [items]\n  \n  (if (= items '())\n    '()\n\t(let [first-item (first items) first-items (take-while #(= % first-item) items) rest-of-items (drop-while #(= % first-item) items)]    \n\t(cons first-items (sublist rest-of-items))\n    \n    ))\n  \n  \n  )","user":"5471f090e4b094393f72dd6e"},{"code":"(fn [coll]\n  (loop [input (rest coll) output [[(first coll)]]]\n    (if (empty? input)\n      output\n      (if (= (last (last output)) (first input))\n        (recur (rest input) (concat (drop-last output) [(concat (last output) [(first input)])]))\n        (recur (rest input) (concat output [[(first input)]]))))))","problem":31,"user":"5033a1fbe4b062bc5d7ae155"},{"code":"(fn [s]\n    (loop [s s\n           current []\n           res []]\n      (if-not (seq s)\n        (conj res current)\n        (if (or (empty? current) (= (first current) (first s)))\n          (recur (rest s) (conj current (first s)) res)\n          (recur (rest s) [(first s)] (conj res current))))))","problem":31,"user":"4e59b02c535d8a8b8723a2a2"},{"problem":31,"code":"(fn pack-sequence [seq]\n  (partition-by identity seq))","user":"56889672e4b0dcc4269f406c"},{"problem":31,"code":"(fn cmprss [xs]\n  (reverse \n   (reduce \n    (fn [acc x]\n      (if (= x (first (first acc)))\n        (conj \n         (drop 1 acc) \n         (conj (first acc) x))\n        (conj acc (list x))\n      )\n    )\n    '() xs)))","user":"598debf0e4b02b9968b84d2e"},{"code":"(fn pack [coll]\n  (loop [res [] part [(first coll)] s (rest coll)]\n    (cond\n      (= 0 (count s)) (conj res part)\n      (= (first s) (first part)) (recur res (conj part (first s)) (rest s))\n      (not= (first s) (first part)) (recur (conj res part) [(first s)] (rest s)))))","problem":31,"user":"4f12ab23535d64f603146429"},{"problem":31,"code":"(fn [x]\n      (reverse (reduce #(if (= (first (first %1)) %2)\n                         (conj (rest %1) (conj (first %1) %2))\n                         (conj %1 (list %2)))\n                       () x))\n      )","user":"55a372f1e4b0acc240e31537"},{"code":"(fn pack-dups\n  ([seq] (pack-dups (drop-last seq) (list (last seq)) '()))\n  ([seq a sofar]\n    (if (empty? seq)\n      (cons a sofar)\n      (if (= (first a) (last seq))\n        (pack-dups (drop-last seq) (cons (last seq) a) sofar)\n        (pack-dups (drop-last seq) (list (last seq)) (cons a sofar))))))","problem":31,"user":"4e84f77c535db62dc21a62e5"},{"problem":31,"code":"(fn f [ls]\n  (if (empty? ls)\n    ls\n    (let [x (first ls)]\n      (cons\n       (take-while #(= x %) ls)\n       (f (drop-while #(= x %) ls))))))","user":"5d672bd7e4b0db5d338d15f1"},{"code":"(comp seq\n  (partial reduce\n    (fn [acc v]\n      (if (and (not-empty acc) (= v (peek (peek acc))))\n        (conj (pop acc) (conj (peek acc) v))\n        (conj acc (list v))))\n    []\n  ))","problem":31,"user":"4fe89db2e4b07c9f6fd12c59"},{"problem":31,"code":"#(loop [[fst & rst :as all] % result [] current []]\n    (if (empty? all)\n      result\n      (if (= fst (nth rst 0))\n        (recur rst result (conj current fst))\n        (if-not (empty? current)\n          (recur rst (conj result (conj current fst)) [])\n          (recur rst (conj result [fst]) [])))))","user":"60759e51e4b069485764de5a"},{"problem":31,"code":"(fn packSeq [s] \n  (\n   let [\n        firstElem (first s)\n        foldF (fn [acc elem] (\n        \tlet [\n              [result prevElem] acc\n            ]\n            (\n              if (= elem prevElem) \n              (let [\n                    newAcc (cons (cons elem (first result)) (drop 1 result))\n                ]\n                [newAcc elem]\n              )\n              [(cons [elem] result) elem]\n            )\n        ))\n       ]\n   \t(\n       let [[result _] (reduce foldF [ [[firstElem]] firstElem ] (drop 1 s))]\n       (reverse result)\n    )\n  )\n)","user":"5183bccae4b028ec5fd2f2aa"},{"problem":31,"code":"(fn fi [coll]\n  ( loop [index 0 ret [] cur [(nth coll index)]]\n   ( if (< index (dec (count coll))) \n     ( let [prev (last cur) post (nth coll (inc index))]\n      ( if (= prev post) \n       (recur (inc index) ret  (conj cur post ))\n       ( recur (inc index) (conj ret cur) [(nth coll (inc index))] ) ) )\n     (conj ret cur) )\n  ))","user":"579601c8e4b0e215f87e8492"},{"code":"(fn [es]\n  (reduce \n    (fn [s e] \n      (if (empty? (first s)) (list (list e)) \n        (if (= (first (last s)) e) \n          (concat (butlast s) (list (conj (last s) e))) \n      (concat s (list (list e)))))) \n    (list (list)) es))","problem":31,"user":"504ec46de4b069badc5a33c8"},{"code":"(fn group [l]\r\n  (letfn [(span [f l] \r\n          (if (empty? l)\r\n            [l l]\r\n            (let [[x & xs] l]\r\n              (if (f x)\r\n                (let [[ys zs] (span f xs)]\r\n                  [(cons x ys) zs])\r\n                [[] l]))))]\r\n    (if (empty? l)\r\n      []\r\n      (let [[x & xs] l\r\n            [ys zs] (span #(= x %) xs)]\r\n        (cons (cons x ys) (group zs))))))","problem":31,"user":"509c03f3e4b085ae113522a8"},{"problem":31,"code":"(fn partition\n  ([l]\n   (if (empty? l)\n     l\n     (if (= (first l) (second l))\n       (partition (list (first l) (second l)) (rest (rest l)))\n       (cons (list (first l)) (partition (rest l))))))\n  ([l1 l2]\n   (if (= (last l1) (first l2))\n     (partition (concat l1 (list (first l2))) (rest l2))\n     (cons l1 (partition l2)))))","user":"55e4487ce4b050e68259b44c"},{"problem":31,"code":"(fn [lst]\n   (reverse \n     (loop [lst lst p nil ret '()]\n       (if (empty? lst)\n         ret\n         (if (= p (first lst))\n           (recur (rest lst) p\n                  (conj (rest ret) (conj (first ret) (first lst))))\n           (recur (rest lst) (first lst)\n                  (conj ret (list (first lst)))))))))","user":"57d9f603e4b0bd073c20240a"},{"problem":31,"code":"(fn duplicate-pack [s]\n  (reduce (fn [accum i]\n            (if (= (first (last accum)) i)\n              (concat (butlast accum) (list (conj (last accum) i)))\n              (concat accum `((~i)))\n              )\n            ) `((~(first s))) (rest s)\n          )\n  )","user":"5f6adf5ee4b02876ed9fd049"},{"problem":31,"code":"(fn cluster\n  \t[x]\n  \t(let [f (first x)\n          c (take-while #(= f %) x)\n          r (drop-while #(= f %) x)]\n\t\t (if f (cons c (cluster r)) [])))","user":"591addcee4b09b4ee5954be1"},{"problem":31,"code":";(fn [x]\n;  (->> (reduce #(concat %1 (if (= (last %1) %2) [%2] [:sep %2])) '() x)\n;       (partition-by #(= % :sep))\n;       (remove #(= '(:sep) %))))\npartition-by identity","user":"5835bc73e4b089d5ab817ce9"},{"code":"(fn [q] (reverse (loop [[e & t] q c '() r ()]\n      (if e\n        (if (= e (first c))\n          (recur t (cons e c) r)\n          (recur t (list e) (if (empty? c) r (cons c r))))\n        (concat (list c) r)))))","problem":31,"user":"4fdc3065e4b05e33b9224f6b"},{"problem":31,"code":"(fn nt [rest inp]\n  (if (nil? (seq inp))\n    (seq rest)\n    (recur (conj rest (take-while #(= % (first inp)) inp)) (drop-while #(= % (first inp)) inp )))) []","user":"524025bce4b0ad64fa01030f"},{"code":"(fn [s]                                                                         \n  (reverse                                                                      \n   (letfn [(inner [newseq oldseq]                                               \n                  (if (empty? oldseq)                                           \n                    newseq                                                      \n                    (if (= (first (first newseq)) (first oldseq))               \n                      (inner (conj                                              \n                       (rest newseq)                                            \n                       (conj                                                    \n                        (first newseq)                                          \n                        (first oldseq))) (rest oldseq))                         \n                      (inner (conj newseq (list (first oldseq))) (rest oldseq)))))]\n     (inner (list (list (first s))) (rest s)))))","problem":31,"user":"52e75667e4b09f7907dd1485"},{"problem":31,"code":"reduce\n#(if (= (last (last %1)) %2)\n   (conj (vec (butlast %1))\n        (conj (last %1) %2))\n   (conj %1 (list %2)))\n[]","user":"51e5a627e4b0efabf93c02db"},{"problem":31,"code":"(fn -packseq\n  ([xs] (-packseq xs []))\n  ([xs acc]\n    (cond\n      (= 0 (count xs )) acc\n      (not= 0 (count xs))\n        (if (= (first xs) (last (last acc)))\n          (recur (rest xs) (concat (butlast acc) [(concat (last acc) [(first xs)])]))\n          (recur (rest xs) (concat acc [[(first xs)]]))\n        )\n    )\n  )\n)","user":"546113ffe4b01be26fd74699"},{"problem":31,"code":"(fn pack\n  [lst]\n  (loop [l lst t ()]\n    (if (empty? l)\n      (reverse t)\n      (if (= (first (first t)) (first l))\n        (recur (rest l) (cons (cons (first l) (first t)) (rest t)))\n        (recur (rest l) (cons (list (first l)) t ))))))","user":"5a653f80e4b0512ff01cd9b2"},{"code":"(fn [x] (partition-by (fn [y] apply distinct? y) x))","problem":31,"user":"51891c96e4b04c2714a2670e"},{"code":"(fn pack\n  ([items]\n     (pack (empty items) (list (first items)) (rest items)))\n  ([before current after]\n     (cond\n      (empty? after) (reverse (cons current before))\n      (= (first current) (first after)) (recur before (cons (first after) current) (rest after))\n      :else (recur (cons current before) (list (first after)) (rest after)))))","problem":31,"user":"511720eae4b0063b4e3e16da"},{"code":"(fn pack\n  ([target] (pack (rest target) (list (first target)) []))\n  ([target current acc]\n   (if (empty? target)\n     (conj acc current)\n     (if (= (first current) (first target))\n       (pack (rest target) (conj current (first target)) acc)\n       (pack (rest target) (list (first target)) (conj acc current))))))","problem":31,"user":"512a7c70e4b0ff5c4bc1f99d"},{"problem":31,"code":"(fn [items2]\n  (loop [before nil\n         items (rest items2)\n         actual (first items)\n         result '()\n         grouped []]\n    (if (nil? actual)\n      (reverse (conj result grouped))\n      (recur actual\n             (rest items)\n             (first items)\n             (if (or (nil? before) (= actual before))\n               result\n               (conj result grouped))\n             (if (= actual before)\n               (concat grouped [actual])\n               (list actual))))))","user":"5d1d4ec6e4b02ea6f0fb699f"},{"problem":31,"code":"(fn packit [l] \n  (if (empty? l)\n    []\n    (let [[f t] (split-with #(= (first l) %) l)]\n      (cons f (packit t)))))","user":"5703eda3e4b08d47c9778200"},{"problem":31,"code":"#(loop [[h & t :as c] % [f & _ :as l] [] acc []]\n   (cond\n     (empty? c)     (conj acc l)\n     (or (empty? l)\n         (= h f))   (recur t (conj l h) acc)\n     :else          (recur t [h] (conj acc l))))","user":"5f665d45e4b02876ed9fd02f"},{"problem":31,"code":"(fn [coll]\n  (loop [final []\n         temp []\n         original coll]\n    (if (empty? original)\n        (if (empty? temp) final (conj final temp))\n        (if (or (empty? temp) (= (first original) (first temp)))\n            (recur final (cons (first original) temp) (rest original))\n            (recur (conj final temp) '() original)))))","user":"597f8c93e4b0dbe32238d0c1"},{"problem":31,"code":"(fn pack\n  [l]\n  (loop [l l out [] acc []]\n    (cond (empty? l) (if (empty? acc) out (conj out acc))\n          (= (first acc) (first l)) (recur (rest l) out (conj acc (first l)))\n          :else (recur (rest l) (if (empty? acc) out (conj out acc)) [(first l)]))))","user":"551afdf8e4b07993ea3788cb"},{"problem":31,"code":"(fn f [seq]\n  (let [update-acc (fn [acc cur]\n    (let [\n      lseq (or (last acc) [])\n      prev (last lseq)\n    ]\n    (if (= cur prev)\n      (conj (vec (drop-last acc)) (conj lseq cur))\n      (conj acc (vector cur))\n    )))]\n  ((fn [seq acc]\n    (if (empty? seq)\n      acc\n      (recur (next seq) (update-acc (vec acc) (first seq)))\n      ))\n    seq [])))","user":"5681afaae4b0945ebc182a87"},{"code":"#(reverse\n   (loop [seq (rest %)\n          last (first %)\n          acc (list (list (first %)))]\n     (cond\n       (empty? seq) acc\n       (= (first seq) last)\n         (recur (rest seq)\n                last\n                (cons (cons (first seq) (first acc))\n                      (rest acc)))\n       :else (recur (rest seq)\n             (first seq)\n             (cons (list (first seq)) acc)))))","problem":31,"user":"4e4ae5aa535dc968683fc4d2"},{"code":"(fn mypack [a] (loop [a a res []]\n  (if (empty? a) res \n  \t(recur (drop-while #(= % (first a)) a) \n  \t\t(conj res (take-while #(= % (first a)) a))))))","problem":31,"user":"538e29d1e4b0b51d73faae80"},{"problem":31,"code":"(fn [lst]\n  (loop [olst lst\n         nlst []\n         tmp []]\n    (if (empty? olst)\n      (if (empty? tmp)\n        nlst\n        (conj nlst tmp))\n      (let [f (first olst)\n            e (or \n                   (= f (first tmp))\n                   (empty? tmp))\n            n (if e\n                nlst\n                (conj nlst tmp))\n            t (if e\n                (conj tmp f)\n                [f])]\n        (recur (rest olst) n t)))))","user":"5642b939e4b08d4f616f5f1b"},{"problem":31,"code":"(fn [col]\n  (reverse (reduce (fn [sum n]\n            (if\n              (= (first (first sum)) n)\n              (conj (rest sum) (conj (first sum) n))\n              (conj sum (list n)))\n            )\n          (list (list (first col)))\n          (rest col)))\n   )","user":"571e5c9ee4b0145328a76290"},{"problem":31,"code":"reduce (fn [a b] (if (= (first (peek a)) b)\n                   (conj (vec (butlast a)) (conj (peek a) b))\n                   (conj a [b]))) []","user":"56912f93e4b0dcc4269f40ef"},{"code":"(fn [s] (partition-by #(identity %) s))","problem":31,"user":"52117ea7e4b07aea8afc4f70"},{"problem":31,"code":"(fn [coll]\n  (loop [result []\n         acc    [(first coll)]\n         xs     (rest coll)]\n    (if (and (= (first xs) (last acc))\n             (not (empty? xs)))\n      (recur result (conj acc (first xs)) (rest xs))\n      (if (empty? xs)\n        (conj result acc)\n        (recur (conj result acc) [(first xs)] (rest xs))\n      \n    ))))","user":"596b5f27e4b069c0a1a19813"},{"problem":31,"code":"(fn pack [thelist] (if (empty? thelist) () \n(let [reps (for [x thelist :while (= (first thelist) x)] x)] (cons reps (pack (nthnext thelist (count reps)))))))","user":"55f75c6be4b06e875b46cea9"},{"problem":31,"code":"(fn [coll]\n  (loop [a (first coll) r coll ret '()]\n    (if (nil? a)\n      (reverse ret)\n      (let [s (drop-while #(= a %) r) l (take-while  #(= a %) r)]\n        (recur (first s) s (conj ret l))))))","user":"5f2c94b4e4b033932238a669"},{"code":"(fn pack [s]\n  (when-not (empty? s)\n    (let [ split-fn #(= % (first s))\n           [group tail] (split-with split-fn s)]\n      (conj (pack tail) group))))","problem":31,"user":"4ea348ad535d7eef308072c4"},{"problem":31,"code":"(fn packer [ls] \n  (reverse ((fn pack [acc ls]\n  (if (empty? ls)\n    acc\n    (if (= (first (first acc)) (first ls))\n      (pack (conj (rest acc) (conj (first acc) (first ls))) (rest ls))\n      (pack (conj acc (list (first ls))) (rest ls))))) (list (list (first ls))) (rest ls))))","user":"53d87449e4b0e771c302546d"},{"problem":31,"code":"(fn p31 [l] (partition-by identity l))","user":"5f968f4ee4b0715f5002d7d2"},{"problem":31,"code":"(fn congregate [coll]\n  (loop [chnk [(first coll)]\n         others (rest coll)\n         out []]\n    (cond (empty? others) (conj out chnk)\n          (some #{(first others)} chnk) (recur (conj chnk (first others)) (rest others) out) \n      \t  :else (recur [(first others)] (rest others) (conj out chnk)))))","user":"4daeff24edd6309eace4d16e"},{"code":"(fn f [all]\n  (if (empty? all)\n      all\n      (let [[x &xs] all]\n        (let [group (take-while #(= x %) all)]\n          (concat [group] (f (drop (count group) all)))))))","problem":31,"user":"4f031eac535dcb61093f6a67"},{"problem":31,"code":"(fn [s]\n  (partition-by identity s)\n )","user":"54b556fce4b05787c3b1639e"},{"problem":31,"code":"(fn [coll]\n                     (reverse (reduce (fn [accum itm]\n                               (let [last-list (first accum)\n                                     last-item (first last-list)\n                                     accum-without-last-list (rest accum)]\n                                 (if (= last-item itm)\n                                   (conj accum-without-last-list \n                                             (conj last-list itm))\n                                   (conj accum\n                                         (conj '() itm)))))\n                             '() coll)))","user":"55f4ebffe4b06e875b46ce81"},{"code":"(fn [coll]\n  (loop [input (rest coll)\n         i 1\n         last (first coll)\n         result []]\n      (if (empty? input)\n          (conj result (repeat i last))\n          (recur (rest input)\n                 (if (= (first input) last) (inc i) 1)\n                 (first input)\n                 (if (= (first input) last) \n                     result \n                     (conj result (repeat i last)))))))","problem":31,"user":"4f38d6bbe4b0e243712b1ee2"},{"code":"(fn pack [[x & xs :as args]]\n  (when x\n    (cons\n      (take-while #(= % x) args)\n      (pack (drop-while #(= % x) xs)))))","problem":31,"user":"4ef0eaef535dced4c769f211"},{"problem":31,"code":"#(partition-by (fn [param] identity param) %1)","user":"5751aeabe4b02ea11479928a"},{"problem":31,"code":"(fn pack [coll]\n  (if (= 1 (count coll))\n    (list coll)\n    (let \n     [packed (pack (rest coll))]\n     (if \n      (= \n        (first coll)\n        (first (first packed)))\n      (cons\n       (cons \n        (first coll)\n        (first packed))\n       (rest packed))\n      (cons\n       (list (first coll))\n       packed)))))","user":"5e471203e4b043cd24807a2a"},{"problem":31,"code":"(fn [ls]\n(reverse (loop [[x & xs] ls prev nil result '() inter '()]\n    (cond  (nil? x) (cons inter result) \n           (= x prev) (recur xs x result (cons x inter))\n           (empty? inter) (recur xs x result (list x))\n           :else (recur xs x (cons inter result) (list x))))))","user":"546176e7e4b01be26fd746a2"},{"problem":31,"code":"(fn rr [s] (reverse (reduce (fn [res el]\n                                (println \"res: \" res \", el: \" el)\n                  (if (= (ffirst res) el)\n                    (conj (rest res) (conj (first res) el))\n                    (conj res (list el))))\n                '() s)))","user":"5b7ec039e4b047b03b20375d"},{"problem":31,"code":"(fn pack \n  ([coll] (reverse (pack coll () ())))\n  ([coll acc result]\n   (cond \n    (empty? coll)\n    \t(conj result acc)\n   \t(or (empty? acc) (= (first acc) (first coll)))\n    \t(pack (rest coll) (conj acc (first coll)) result)\n    :else\n    \t(pack coll () (conj result acc)))))","user":"5a346d73e4b0ddc586f153c8"},{"code":"reduce (fn [accum nextval]\n  (let [keeper (vec (drop-last 1 accum))\n        lastval (last accum)]\n    (cond\n      (and (list? lastval) (some #{nextval} lastval)) (conj keeper (conj lastval nextval))\n      (= lastval nextval) (conj keeper (list lastval nextval))\n      :else (conj accum (list nextval)))))\n[]","problem":31,"user":"4e6a4541535d8ccf87e9feb8"},{"problem":31,"code":"#(reduce \n\n(fn [x y]\n  (if (not(= (last (last x)) y))\n    (conj x [y])\n    (conj (vec (reverse (rest(reverse x))))\n          (conj (last x) y)\n          )\n    )\n  )\n  [] %) \n\n;; partition-by identity","user":"58d28c70e4b03c36ff7e5901"},{"code":"(fn [coll]\n  (partition-by identity coll))","problem":31,"user":"4ec6559a535d6d7199dd36c9"},{"problem":31,"code":"(fn pack-sequence\n    ([x] (pack-sequence x 0 [] []))\n    \n    ([x i y y1]\n        (cond (< i (count x))\n            (cond\n                (= i (- (count x) 1)) (pack-sequence x (inc i) [] (conj y1 (apply list (conj y (nth x i)))))\n                (= (nth x i) (nth x (+ i 1))) (pack-sequence x (inc i) (conj y (nth x i)) y1)\n                (not= (nth x i) (nth x (+ i 1))) (pack-sequence x (inc i) [] (conj y1 (apply list (conj y (nth x i)))))\n            )\n            \n            :else (apply list y1)\n        )\n    )\n)","user":"5f0cb4f3e4b0f30dddfb5d4e"},{"code":"(fn pack [[f & r :as S]]\n  (if (seq S)\n    (let [[packed tail] (split-with {f true} S)]\n      (if (seq tail)\n        (cons packed (pack tail))\n        [packed]))\n    [nil]))","problem":31,"user":"4ef4c1ff535dced4c769f23e"},{"problem":31,"code":"reduce (fn [r x]\n  \t\t (cond (empty? r) (conj r (list x))\n               (not= (last (last r)) x) (conj r (list x))\n               :else (conj (vec (drop-last r)) (conj (last r) x)))) []\n\n;; other solution:\n;; partition-by identity","user":"56ee0691e4b04a395b9a044c"},{"problem":31,"code":";(vec(\n(fn [data]\n  (letfn\n   [(pb [f li]\n        (when (seq li)\n          (let [[a b] (split-with\n                       #(f (first li) %)\n                       li)]\n            (cons a (pb f b)))))\n        ]\n   (pb = data)))\n;[1 1 1 2 4 4 4 4 3]))","user":"5e64ae6ce4b0fd0acd1586ac"},{"problem":31,"code":"(fn wat \n  ([coll]\n   (let [xs (seq coll)]\n     (if xs\n       (wat (list (first xs)) (rest xs))\n       () )))\n  ([curcoll rst]\n   (if rst\n     (let [[c & cs] curcoll\n           [r & rs] rst]\n       (if (= r c)\n         (recur (cons r curcoll) rs)\n         (cons curcoll (wat (list r) rs))))\n     (list curcoll))\n   ))","user":"54dcbc6ee4b024c67c0cf787"},{"code":"reduce \n        (fn [a i] (if (= i (last (last a)))\n                    (concat (butlast a) (list (cons i (last a))))\n                    (concat a (list (cons i '()) ) )                  \t\n                    )\n          ) (empty list)","problem":31,"user":"51e1c176e4b06a68e693eafb"},{"problem":31,"code":"reduce\n  (fn [coll element]\n    (if (= element (-> coll last first))\n        (conj (-> coll butlast vec) (conj (last coll) element))\n        (conj coll (vector element))))\n  []","user":"567695c2e4b05957ce8c6157"},{"code":"(fn duplicados [coll]\n  (cond \n    (empty? coll) nil\n    (= 1 (count coll)) (list (list (first coll)))\n    :else (let [target (first coll)\n                primeira-lista (for [x coll :while (= target x)] x)]\n            (cons primeira-lista (duplicados (nthnext coll (count primeira-lista)))))))","problem":31,"user":"52c8758be4b0c2d177d62135"},{"problem":31,"code":"(fn [s] (reverse\n   (reduce #(if (= (first (first %1)) %2)\n              (conj (rest %1) (conj (first %1) %2))\n              (conj %1 (list %2)))\n           '()\n           s)))","user":"58f273d9e4b08e1cf3471d01"},{"code":"(fn [x]\n  (list* (reduce #(if (= (first (last %1)) %2)\n                   (conj (pop %1) (conj (last %1) %2))\n                   (conj %1 (list %2)))\n                [(list (first x))] (rest x))))","problem":31,"user":"52a32b52e4b04e0c58e87bfc"},{"problem":31,"code":"(fn __ [s] (partition-by identity s))","user":"5be2e670e4b0ed4b8aab4ccc"},{"problem":31,"code":"#(concat (partition-by identity %))","user":"55249f64e4b0882d96d091c6"},{"problem":31,"code":"(fn dedup [[x & xs]]\n  (if (nil? x) nil\n      (cons\n       (cons x (take-while #(= x %) xs))\n       (dedup (drop-while #(= x %) xs)))))","user":"54b07c1ee4b09f271ff37d16"},{"problem":31,"code":"(fn [coll]\n  (if\n    (empty? coll) nil\n    (loop [coll (rest coll)\n           curr (first coll) \n           acc (list (first coll))\n           acc1 []]\n      (cond\n        (empty? coll) (seq (conj acc1 acc))\n        (= (first coll) curr) (recur (rest coll) curr (conj acc (first coll)) acc1)\n        :else (recur (rest coll) (first coll) (list (first coll))\n                     (conj acc1 acc))))))","user":"57f80350e4b0d3187e90090c"},{"problem":31,"code":"(fn pack\n  ([coll]\n   (pack coll []))\n  ([coll my-coll]\n   (if (empty? coll)\n     my-coll\n     (let [last-pack (last my-coll)\n           last-item (first last-pack)\n           new-item (first coll)]\n       (println coll my-coll last-pack last-item new-item)\n       (pack (rest coll)\n             (if (= new-item last-item)\n               (conj (vec (drop-last my-coll)) (conj last-pack last-item))\n               (conj my-coll  [new-item])))))))","user":"6033f8e9e4b0d5df2af222c6"},{"code":"(fn [l]\n  (loop [out []\n         in (rest l)\n         last-item (first in)\n         current [last-item]]\n    (if (empty? in)\n      (conj out current)\n      (let [fst (first in)]\n        (if (= fst last-item)\n          (recur out (rest in) last-item (conj current fst))\n          (recur (conj out current) (rest in)\n                 fst [fst]))))))","problem":31,"user":"4f04f847535dcb61093f6beb"},{"code":"(letfn [(v [q] (when (seq q) (let [a (first q)] (lazy-seq (cons (take-while #(= % a) q)  (v (drop-while #(= % a) q)))))))] v)","problem":31,"user":"532e0b20e4b019098a6f8b45"},{"problem":31,"code":"(fn [s]\n  (reduce\n   (fn [acc x]\n     (if (= x (last (last acc)))\n       (conj (vec (butlast acc)) (conj (last acc) x))\n       (conj acc [x])))\n   (vector)\n   s))","user":"55b54ecbe4b01b9910ae2987"},{"code":"(fn pack-seq [seq]\n  (partition-by identity seq))","problem":31,"user":"50763574e4b0a894bb95bf3d"},{"code":"#(partition-by (fn [x] (.indexOf % x)) %)","problem":31,"user":"50b65966e4b0a86f8358ca6c"},{"code":"#(reduce \n   (fn [acc el] (if (or (empty? acc) (not= (first (last acc)) el)) \n                    (concat acc (list (list el)))\n                  (concat (butlast acc) (list (into (last acc) (list el))))))\n   () \n   %)","problem":31,"user":"52bdf6bde4b07a9af579230d"},{"problem":31,"code":"reduce #(cond\n           (empty? %1) (conj %1 [%2])\n           (= (last (last %1)) %2) (assoc %1 (dec (count %1)) (conj (last %1) %2))\n           :else (conj %1 [%2]))\n        []","user":"5992dc6ae4b0866487ed0d7d"},{"problem":31,"code":"(fn [coll]  (partition-by identity coll))","user":"592c2f3ee4b072a2710fcf53"},{"code":"(fn [[y & ys]]\n  (loop [acc  []\n         x    (list y)\n         xs   ys]\n         (if (nil? (first x))\n             acc\n             (if (= (first x) (first xs))\n                 (recur acc (conj x (first xs)) (rest xs))\n                 (recur (conj acc x) (list (first xs)) (rest xs))))))","problem":31,"user":"4ff4f5c4e4b0678c553fc362"},{"code":"(fn [s]\n  (loop [accu '()\n   s s]\n    (cond (empty? s) (reverse accu)\n\t  (= (first (first accu)) (first s)) (recur (cons (cons (first s) (first accu)) (rest accu)) (rest s))\n\t  true (recur (cons (cons (first s) '()) accu) (rest s)))))","problem":31,"user":"4e82c062535db62dc21a62cc"},{"problem":31,"code":"(fn [coll]\n  (reduce (fn [res x]\n            (let [last-in-res (last res)]\n              (do\n                (if (= x (first last-in-res))\n                  (concat\n                    (drop-last 1 res)\n                    (list (conj last-in-res x)))\n                  (concat\n                    res (list (list x)))))))\n          [] coll))","user":"5675cdf1e4b05957ce8c614d"},{"problem":31,"code":"(fn [s](partition-by identity (seq s)))","user":"581b4d3be4b04b46fc4b0ec6"},{"code":"(fn pack-a-sequence [xs]\n  (reduce (fn [packed-sequence next-value]\n            (if (= (last (last packed-sequence)) next-value)\n              \t(concat (drop-last packed-sequence) (list (conj (last packed-sequence) next-value)))\n              \t(concat packed-sequence (list (list next-value)))))\n          (list (list (first xs)))\n          (rest xs)))","problem":31,"user":"529e3a4fe4b04e0c58e87b92"},{"problem":31,"code":";#(partition-by identity %)\n\n\n;reduce\n; \t(fn [myvector currlist part]\n;     \t(if (= (first currlist) part)\n;       \t(conj currlist part)\n;        \t(conj myvector currlist)\n;       \t)\n;     )\n; \t[]\n;(\n(fn pack [partso]\n \t (rest (loop [myvector [] currlist '() parts partso]\n      \t (if (nil? parts)\n          \t (conj myvector currlist)\n             (do\n               \t(let [[part & remain] parts [currel] currlist]\n              \t (if (= currel part)\n       \t\t\t\t(recur myvector (conj currlist part) remain)\n        \t\t\t(recur (conj myvector currlist) (list part) remain)\n       \t\t\t )\n                )\n              )\n          )\n      )\n      )\n )\n; [1 1 2 1 1 1 3 3])","user":"579be21fe4b05b1deef9adff"},{"code":"(fn xxx [coll]\n  (let [step (fn step [[x :as xs] acc]\n               (when-let [s (seq xs)]\n                 (if (= x (second s))\n                   (recur (rest s) (cons x acc))\n                   (cons (cons x acc) (step (rest s) '())))))]\n    (step coll '())))","problem":31,"user":"5163a7bbe4b055933a9ca02f"},{"problem":31,"code":"(fn\n  [s]\n  (loop [s s cr nil result []]\n    (if (empty? s)\n      (drop 1(conj result cr))\n      (let [[fs & rst] s ls (last cr)]\n        (if (= fs ls)\n          (recur rst (conj cr ls) result)\n          (recur rst [fs] (conj result cr)))\n        ))\n    )\n  )","user":"540efe2ee4b0addc1aec6724"},{"problem":31,"code":"(fn pack-recur\n  ([the-list]\n    (pack-recur [] the-list (first the-list)))\n  ([output input member]\n    (if (empty? (rest input))\n      (conj output (conj () member))\n      (pack-recur output (rest input) member 1)))\n  ([output input member the-count]\n    (if (= (first input) member)\n      (if (empty? (rest input))\n        (conj output (repeat (inc the-count) member))\n        (pack-recur output (rest input) member (inc the-count)))\n      (if (empty? (rest input))\n        (if (first input)\n          (conj (conj output (repeat the-count member)) (conj () (first input)))\n          output)\n        (pack-recur (conj output (repeat the-count member)) input (first input))))))","user":"57b356c2e4b0fbc9809a277b"},{"problem":31,"code":"(fn [coll]\n(loop [result (conj '() (conj '() (first coll))), coll (rest coll)]\n(cond\n(empty? coll) (reverse result)\n(= (first coll) (first (first result))) (recur      (conj (rest result) (conj (first result) (first coll)))                (rest coll))\n:else  (recur (conj result (conj '() (first coll))) (rest coll))\n) ; cond\n) ; loop\n) ; fn","user":"4e268c6e535deb9a81d77ef4"},{"problem":31,"code":"#(reduce\n (fn [s a]\n  (if (= a (last(last s)))\n    (into [] (concat (butlast s)[(conj (last s) a)]))\n    (into [] (concat s [(conj '() a)]))))  \n  [(conj '()(first %))] (rest %))","user":"5951190be4b066ee0a44aea4"},{"problem":31,"code":"(fn f [xs]\n   (if (empty? xs)\n     ()\n     (cons (take-while (partial = (first xs)) xs)\n           (f (drop-while (partial = (first xs)) xs)))))","user":"5bd9549ee4b0ed4b8aab4bf0"},{"code":"(fn [x] ((fn [res m l]  \n  (if (empty? l) (cons m res)\n  (if \n    (= (first l) (first m))\n    (recur res (cons (first l) m) (rest l))\n    (recur (if (empty? m) res (cons m res)) (cons (first l) '()) (rest l))\n))) '() '() (reverse x)))","problem":31,"user":"4e9d6a65535dbda64a6f6b87"},{"code":"(fn pack \r\n          ([x] (pack (rest x) (vector (list (first x)))))\r\n          ([x acc]\r\n             (if (empty? x)\r\n               (reverse (into '() acc))\r\n               (let [n (if (= (first x) (first (last acc)))\r\n                         (cons (first x) (last acc))\r\n                         (list (first x)))                    \r\n                     m (if (> (count n) 1)\r\n                         (conj (into [] (drop-last acc)) n)\r\n                         (conj acc n))]                    \r\n                 (recur (rest x) m)))))","problem":31,"user":"4e5a2403535d8a8b8723a2a7"},{"problem":31,"code":"#(reverse (reduce \n\n(fn [m i]\n    (let [rst (rest m) \n          f (or (first m) '())]\n      (if (= (first f) i)\n        (conj rst (conj f i))\n        (conj m (list i))\n      )\n    ))\n  '()  \n    %)\n)","user":"5b274fd1e4b063e2438bcc3b"},{"code":"(fn [theSeq] \n  (reverse ((fn compress [theSeq newSeq lastValue]\n\t\t(if (empty? theSeq)\n\t\t\tnewSeq\n\t\t\t(if (= lastValue (first theSeq))\n\t\t\t\t(compress (rest theSeq) (cons (cons (first theSeq) (first newSeq)) (rest newSeq)) lastValue)\n\t\t\t\t(compress (rest theSeq) (cons (list (first theSeq)) newSeq) (first theSeq))))) theSeq '() nil)))","problem":31,"user":"4f1c2336535d64f60314647f"},{"problem":31,"code":"(fn grouping [xs]\n  (if (empty? xs)\n    xs\n    (reverse (loop [prev (first xs)\n           curr (rest xs)\n           curr-group (list prev)\n           res '()]\n      ;; base case\n      (if (empty? curr)\n        (conj res curr-group)\n        (if (= prev (first curr))\n          ;; first curr equals prev\n          (recur (first curr) (rest curr) (conj curr-group (first curr)) res)\n          (recur (first curr) (rest curr) (list (first curr)) (conj res curr-group))))))))","user":"504f5804e4b0a02f9cffde72"},{"problem":31,"code":"(fn f\n      ([coll]\n       (f coll '()))\n      ([coll res]\n       (if (empty? coll)\n         (reverse res)\n          (if (and (list? (first res)) (= (first coll) (first (first res))))\n            (recur (rest coll) (cons (conj (first res) (first coll)) (rest res)))\n            (recur (rest coll) (cons (list (first coll)) res))))))","user":"584917a1e4b089d5ab817ec9"},{"problem":31,"code":"(fn packSequence \n  [n]\n  (partition-by identity n))","user":"59dd3930e4b0a0ac046f2504"},{"code":"#(letfn [(worker [l i n]\r\n           (if (empty? l)\r\n             (conj n i)\r\n             (if (= (first l) (first i))\r\n               (recur (rest l) (conj i (first l)) n)\r\n               (recur (rest l) (list (first l)) (conj n i)))))]\r\n  (if (empty? %1)\r\n    %1\r\n    (worker (rest %1) (list (first %1)) [])))","problem":31,"user":"4f474f43e4b0d56e7bb92bb7"},{"code":"(fn problem-31 [seq]\n  (lazy-seq\n   (when-not (empty? seq)\n     (letfn [(eq-fst? [el]\n               (= el (first seq)))]\n       (cons (first (partition-by eq-fst? seq))\n             (problem-31 (drop-while eq-fst? (rest seq))))))))","problem":31,"user":"51fe9d7ce4b0f1313d468a70"},{"code":"(fn [xs] (\n             reduce #(if (= (last (last %1)) %2)\n                       (if (nil? (butlast %1)) \n                        (list (concat  (last %1) (list %2)))\n                         (concat (butlast %1) (list (concat (last %1) (list %2)))) )\n                       (concat %1 (list (list %2)))) \n             [] xs\n             ))","problem":31,"user":"5210e5c5e4b080a8d9b9d63f"},{"problem":31,"code":"(fn [coll]\n  (reverse\n   (reduce #(if (= %2 (first (first %1)))\n              (cons (cons %2 (first %1)) (rest %1))\n              (cons (list %2) %1))\n           ()\n           coll)))","user":"5561d2c2e4b0c656e3ff17cd"},{"code":"#(loop [previous :flag\n       toProcess %\n       partialAcc '()\n       acc []]\n   (let [current (first toProcess)\n         nextToProcess (next toProcess)]\n     (cond\n      (empty? toProcess) (seq (conj acc partialAcc))\n      (= :flag previous) (recur current nextToProcess (list current) acc)\n      (= previous current) (recur current nextToProcess (conj partialAcc current) acc)\n      :else (recur current nextToProcess (list current) (conj acc partialAcc))\n      )\n    )\n   )","problem":31,"user":"51d67516e4b0154f82ab92f0"},{"code":"(fn pack-sequence [x]\n  (partition-by identity x))","problem":31,"user":"51ac7e9be4b09397d510976f"},{"problem":31,"code":"(fn [xs]\n  (reverse\n  (loop [p '[]\n         n (first xs)\n         xs (next xs)\n         m (list n)]\n    (if (empty? xs)\n      (cons m p)\n      (let [x (first xs)]\n        (if (= n x)\n          (recur p n (next xs) (cons x m))\n          (recur (cons m p) x (next xs) (list x)))))))\n          )","user":"55c4b23de4b0e31453f649a3"},{"code":"(fn [coll]\n  (let [pack (fn [coll packed]\n    (if (empty? coll)\n      packed\n      (recur\n        (drop-while #(= (first coll) %) coll)\n        (cons (take-while #(= (first coll) %) coll) packed))))]\n    (pack (reverse coll) ())))","problem":31,"user":"4f036c4b535dcb61093f6ab9"},{"problem":31,"code":"(fn f\n  ([ls] (f ls ()))\n  ([ls acc]\n     (if (empty? ls)\n       ()\n       (let [[head & tail] ls]\n         (if (or (empty? tail) (not (= (first tail) head)))\n           (conj (f tail) (conj acc head))\n           (f tail (conj acc head)))))))","user":"547584d9e4b0c51c1f4d729b"},{"problem":31,"code":"(fn pack [l]\n  (loop [result [] current [(first l)] [x & xs] (rest l)]\n    (if (= x nil)\n      (concat result [current])\n      (if (= x (first current))\n        (recur result (concat current [x]) xs)\n        (recur (concat result [current]) [x] xs)\n      )\n    )\n  )\n)","user":"56ec3a97e4b04a395b9a0433"},{"problem":31,"code":"(fn [col] ((fn pack [oldC newC] (if (= (first oldC) nil) newC (if (= (first oldC) (first (first newC))) (pack (rest oldC) (cons (cons (first oldC) (first newC)) (rest newC))) (pack (rest oldC) (cons (list (first oldC)) newC))))) (rest (reverse col)) (list (list (last col)))))","user":"5d1cd478e4b02ea6f0fb6991"},{"problem":31,"code":"(fn mypack [x]\n  (if (empty? x)\n    x\n    (let [r (mypack (rest x))]\n    \t(if (empty? r)\n          (list (list (first x)))\n          (if (= (first x) (first (first r)))\n            (conj (rest r) (concat (list (first x)) (first r)  ) )\n            (conj r (list (first x)))\n          )\n        )\n    )\n  )\n)","user":"56ea8b75e4b04a395b9a0409"},{"code":"(fn [arr] (partition-by identity arr))","problem":31,"user":"525b12b1e4b0cb4875a45d04"},{"problem":31,"code":"(fn\n [x]\n (reduce (fn subby [newstring y]\n           (if (= (first (last newstring)) y)\n             (conj (subvec newstring 0 (dec (count newstring))) (conj (last newstring) y))\n             (conj newstring (list y))))\n          [(list (first x))] (rest x)))","user":"58e6a2c5e4b056aecfd47cba"},{"problem":31,"code":"(fn pack \n  [xs]\n  (if \n    (empty? xs)\n    '()\n    (cons\n     (take-while\n      (fn [x] (= x (first xs)))\n      xs)\n     (pack \n      (drop-while\n        (fn [x] (= x (first xs)))\n        xs)))))","user":"55a3ca84e4b0acc240e3153c"},{"code":"(fn [coll]\n  (reverse (loop [xs coll acc []]\n    (if (empty? xs)\n      acc\n      (let [match (partial = (first xs))]\n            (recur (drop-while match xs) (cons (take-while match xs) acc)))))))","problem":31,"user":"4e36425c535deb9a81d77f33"},{"problem":31,"code":"(fn [s] (loop [result []\n               s s]\n         (if (empty? s)\n           \tresult\n           (let [my-first (first s)]\n              (recur (conj result (conj (take-while (partial = my-first) (rest s)) my-first ))\n             \t\t(drop-while (partial = my-first) (rest s)) \n              )))))","user":"567d18c9e4b05957ce8c61c4"},{"code":"(fn pack\n  ([s]\n    (pack (rest s) [(first s)]))\n  ([s current]\n    (cond\n      (empty? s) [current]\n      (= (first s) (first current))\n        (pack (rest s) (cons (first s) current))\n      :else (cons current (pack s)))))","problem":31,"user":"4e6f578c535d5021c1a8961b"},{"problem":31,"code":"(fn [coll]\n  (reverse \n   (reduce \n  (fn [coll x]\n    (cond \n     (= (ffirst coll) x) (cons (cons x (first coll)) (rest coll))\n     :else (cons (list x) coll)\n     ))\n    '() coll)))","user":"559f06bae4b0acc240e314e6"},{"problem":31,"code":"(fn pack [sequ]\n  (loop [s sequ cur [] fin []]\n    (if (empty? s)\n      (conj fin cur)\n      (if (or (empty? cur) (= (first cur) (first s)))\n        (recur (rest s) (conj cur (first s)) fin)\n        (recur (rest s) (conj [] (first s)) (conj fin cur))))))","user":"5c7d5a0ce4b0d597f478caab"},{"code":"partition-by identity","problem":31,"user":"4dae0510c9a9d6ed4b99dc57"},{"problem":31,"code":"(fn p[c](if(seq c)(let[[t d] (split-with #(= % (c 0)) c)](cons t(p (vec d))))))","user":"55dab408e4b0e31453f64ad9"},{"code":"#(loop [v [] c [(first %)] s (rest %)]\n  (if-let [f (first s)]\n    (if (= f (first c))\n      (recur v (conj c f) (rest s))\n      (recur (conj v c) [f] (rest s)))\n    (conj v c)))","problem":31,"user":"4f043ed1535dcb61093f6bb4"},{"problem":31,"code":"(fn [givenstr] (partition-by identity givenstr))","user":"56bff105e4b060a8e693e3a4"},{"problem":31,"code":"reduce (fn [v n]\n\t(if (= (first (last v)) n)\n\t  (conj (pop v) (conj (last v) n))\n\t  (conj v (seq [n])))) '[]","user":"530bae80e4b02e82168697d0"},{"code":"(fn ! [xs]\n  (if (not-empty xs)\n    (let [[coll rest] (split-with (partial = (first xs)) xs)]\n      (conj (! rest) coll))\n    ()))","problem":31,"user":"4ec6157b535d6d7199dd36c2"},{"code":"#(loop [acc '()\n  \t  left %]\n\t     (if (empty? left)\n\t       (reverse acc)\n\t       (let [n (first left)]\n\t\t (if (= (first (first acc)) n)\n\t\t   (recur (cons (cons n (first acc)) (rest acc))\n\t\t   (rest left))\n\t\t   (recur (cons (list n) acc) (rest left))))))","problem":31,"user":"4f9b3532e4b0dcca54ed6d13"},{"problem":31,"code":"(fn pack\n  ([lst] (pack lst (list (gensym)) nil))\n  ([lst current acc]\n    (if (empty? lst)\n        (reverse (butlast (cons current acc)))\n        (if (= (first lst) (first current))\n          (recur (rest lst) (cons (first lst) current) acc)\n          (recur (rest lst) (cons (first lst) nil) (cons current acc))))))","user":"546c1f73e4b00cfc9eacc175"},{"problem":31,"code":"#(letfn [(g [[h & t]] (print h t \"\\n\") (f h `(~h) t))\n          (f [x a z] (if-let [[h & t] z]\n                       (if (= x h)\n                         (f x (conj a h) t)\n                         (cons a (g z)))\n                       `(~a)))]\n    (g %))","user":"5652f23ce4b0f9d632dd846b"},{"code":"#(map vec (partition-by identity %))","problem":31,"user":"5089ebfee4b03217b26a539f"},{"problem":31,"code":"reduce (fn [x y] (if (= y (last (last x))) (assoc x (dec (count x)) (conj (last x) y))  (conj x [y]))) []","user":"558b50d5e4b027778923762b"},{"code":"(fn x-pack [coll]\r\n  (reverse (reduce\r\n   (fn [acc val]\r\n     (if (= val (first (first acc)))\r\n       (conj (next acc) (conj (first acc) val))\r\n       (conj acc [val]))) [] coll)))","problem":31,"user":"4eccb190535d23f0362276fe"},{"code":"(fn [x] (map seq (partition-by identity x)))","problem":31,"user":"531490bde4b08068f379ed17"},{"problem":31,"code":"(fn f [x y]\n  (if (empty? y)\n    (list x)\n    (if (empty? x)\n      (f (list \n          (first y)) \n         (rest y)\n         )\n      (if (= (first x) (first y))\n        (f (conj x (first y)) (rest y))\n        (concat (list x) (f '() y))\n      )\n    )\n  )\n)\n '()","user":"5ab1665de4b073f1774425c0"},{"code":"(fn asdf\n   ([x] (if (empty? (drop-while #(= (first x) %) x)) \"dd\"\n          (asdf (drop-while #(= (first x) %) x) [(take-while #(= (first x) %) x)])))\n   ([x y] (if (empty? (drop-while #(= (first x) %) x)) (conj y (take-while #(= (first x) %) x))\n          (asdf (drop-while #(= (first x) %) x) (conj y (take-while #(= (first x) %) x)))))\n   )","problem":31,"user":"5012036ce4b0a040369c12f4"},{"code":"(fn [col]\n (let [x []]\n   (partition-by #(if (not= % (last x)) (conj x %) false) col)))","problem":31,"user":"52c1bd29e4b07a9af579236a"},{"problem":31,"code":"(fn pack\n  ([xs]\n     (pack [] xs))\n  ([acc xs]\n     (if (empty? xs)\n       acc\n       (let [first-val (first xs)\n             predicate #(= first-val %)\n             sublist (take-while predicate xs)\n             rest-of-list (drop-while predicate xs)]\n         (pack (conj acc sublist) rest-of-list)))))","user":"526e1bd0e4b03e8d9a4a730b"},{"problem":31,"code":"(fn foo [x] \n  (if (empty? x)\n    ()\n    (let\n      [\n        h (first x)\n        c (foo (rest x))\n        fs (first c)\n        ts (rest c)\n      ]\n      (if (nil? fs)\n        (cons (list h) c)\n        (let [f (first fs)] \n          (if (= h f)\n            (cons (cons h fs) ts)\n            (cons (list h) c)\n          )\n        )\n      )\n    )\n  )\n)","user":"562add6de4b00e49c7cb4834"},{"problem":31,"code":"(fn f\n([s] (f [] s))\n([o s] (if (empty? s) o (f o [(first s)] (rest s))))\n([o d s] (if (empty? s) (conj o d)\n  (if (not= (first d) (first s))\n    (f (conj o d) s) \n    (recur o (conj d (first s)) (rest s))))))","user":"5e373c08e4b0650de70e2b41"},{"code":"(fn [seq]\n  (partition-by identity seq))","problem":31,"user":"4f62b29ce4b0defedf855fd9"},{"problem":31,"code":"; because \"partition-by identity\" feels like cheating...\n(fn [s]\n  (loop [left [] right s]\n    (if (empty? right)\n      left\n      (recur (conj left (take-while #(= % (first right)) right) ) \n             (drop-while #(= % (first right)) right)))))","user":"54febf4be4b07d26eda61d45"},{"problem":31,"code":"(fn\n  [items]\n  (partition-by identity items))","user":"5c6227fee4b0fca0c1622641"},{"code":"(fn pack \n  [coll]\n  (let [head (take-while #(= (first coll) %) coll)\n        tail (drop-while #(= (first coll) %) coll)]\n    (when (not (empty? head))\n      (lazy-seq (cons head (pack tail))))))","problem":31,"user":"52d51535e4b09f7907dd133a"},{"problem":31,"code":"(fn [l]\n   (loop [list l\n          working []\n          temp []]\n     (cond (empty? list) (if (empty? working) temp (conj temp working))\n           (or (empty? working) (= (last working) (first list))) (recur (rest list) (conj working (first list)) temp)\n           true (recur (rest list) [(first list)] (conj temp working)))))","user":"5f3f2281e4b004f08c61c561"},{"problem":31,"code":"#(reverse (reduce (fn [acc v]\n  (if (= v (first (first acc)))\n    (conj (rest acc) (conj (first acc) v))\n    (conj acc (list v)))) '() %))","user":"572a3d77e4b0f4d77e651230"},{"problem":31,"code":"(fn [[item & coll]]\n  (loop [result []\n         sub-result [item]\n         remaining coll]\n    (let [to-compare (first remaining)]\n      (if (empty? remaining)\n        (conj result sub-result)\n      \t(if (= to-compare (first sub-result))\n          (recur result\n                 (conj sub-result to-compare)\n                 (rest remaining))\n          (recur (conj result sub-result)\n                 [to-compare]\n                 (rest remaining)))))))","user":"59d9186be4b0ef0a1e9b5c50"},{"code":"#(loop [seq-seq '() rep-seq '() i 0]\n        (if (= i (count %1))\n          (reverse (if (empty? rep-seq) seq-seq (conj seq-seq rep-seq)))\n          (recur \n            (if (and (not (empty? rep-seq)) (not (= (nth %1 i) (last rep-seq)))) (conj seq-seq rep-seq) seq-seq)\n            (if (empty? rep-seq) (list (nth %1 i)) (if (= (nth %1 i) (last rep-seq)) (conj rep-seq (nth %1 i)) (list (nth %1 i))))\n            (inc i))\n          )\n   )","problem":31,"user":"4ea31da2535d7eef308072c1"},{"problem":31,"code":"(fn q31\n  ([[head & tail] last-val last-coll result]\n   (cond\n     (nil? head)  (->> (conj result last-coll) (filter (complement empty?)) (reverse))\n     (= head last-val) (recur tail head (conj last-coll head) result)\n     true (recur tail head (list head) (conj result last-coll))))\n  ([input] (q31 input nil '() '())))","user":"5cab0ad9e4b048ec896c5c46"},{"problem":31,"code":"(fn pack [seqq]\n  (loop [[first-half second-half] (split-with (partial = (first seqq)) seqq)\n         acc '()]\n    (if (empty? second-half)\n      (reverse (conj acc first-half))\n      (recur (split-with (partial = (first second-half)) second-half)\n             (conj acc first-half))\n      )))","user":"59971e2de4b07157cc8daacc"},{"problem":31,"code":"(fn [s]\n  (loop [coll [] myseq s]\n    (if (empty? myseq)\n      coll\n      (recur\n        (conj coll (take-while #(= % (first myseq)) myseq))\n        (drop-while #(= % (first myseq)) myseq)))))","user":"5ad76df9e4b0ea6055cfac18"},{"problem":31,"code":"(fn pack [l]\n  (letfn [(gather-duplicates-aux\n           [l a]\n           (if (empty? l)\n             '()\n             (if (= (first l) a)\n               (cons (first l) (gather-duplicates-aux (rest l) a))\n               '())))\n          (gather-duplicates [l]\n                             (gather-duplicates-aux l (first l)))\n          (remove-duplicates-aux\n           [l a]\n           (if (empty? l)\n             '()\n             (if (= (first l) a)\n               (remove-duplicates-aux (rest l) a)\n               l)))\n          (remove-duplicates [a]\n                             (remove-duplicates-aux a (first a)))]\n    (if (empty? l)\n      '()\n      (cons\n       (gather-duplicates l)\n       #_(let [dup (gather-duplicates l)]\n         (if (= (count dup) 1)\n           (first dup)\n           dup))\n       (pack (remove-duplicates l))))))","user":"551c6bcee4b07993ea3788df"},{"code":"(fn pack-seq [s] (partition-by identity (vec s)))","problem":31,"user":"50f07f6ae4b0bdaecbb47dc4"},{"problem":31,"code":"(fn [x]\n  (reverse ((fn [l r]\n    (if (empty? l)\n      r\n      (recur (rest l) (if (= (first (first r)) (first l))\n                        (cons (cons (first l) (first r)) (rest r))\n                        (cons (list (first l)) r)))))\n            x '())))","user":"53aaaf7ae4b047364c044444"},{"problem":31,"code":"reduce #(if (= (last (last %1)) %2) (conj (vec (butlast %1)) (conj (last %1) %2)) (conj %1 (conj [] %2))) []","user":"532dbd3ce4b019098a6f8b40"},{"code":"(fn pack-seq [xs]\n  (if (empty? xs)\n    '()\n    (cons (take-while (partial = (first xs)) xs) \n      (pack-seq (drop-while (partial = (first xs)) xs)))))","problem":31,"user":"4ef0b523535dced4c769f20e"},{"problem":31,"code":"#(reverse\n  (reduce\n   (fn[output input]\n     (if (some (fn[value](= input value)) (first output))\n       (cons (cons input (first output)) (rest output))\n       (cons (list input) output)))\n   '() %))","user":"51671557e4b013fc800656c4"},{"problem":31,"code":"(fn [coll] (partition-by #(let [c %] c) coll))","user":"568d4742e4b0dcc4269f40c2"},{"problem":31,"code":"reduce (fn [acc item]\n          (let [end (last acc)\n                check (last end)]\n            (if (= check item)\n              (concat (butlast acc) (list (cons item end)))\n              (concat acc (cons (list item) '()))))) '()","user":"53214efbe4b09d4e7a9b54b2"},{"code":"(fn pack [s]\n  (reverse\n\t\t(reduce \n\t\t\t#(if (= (first (first %1)) %2)\n\t\t\t\t(conj (pop %1) (conj (first %1) %2))\n\t\t\t\t(conj %1 (list %2))\n\t\t\t) \n\t\t\t(cons (cons (first s) nil) nil)\n\t\t\t(rest s)\n\t\t)\n\t)\n)","problem":31,"user":"4ed6238d535d10e5ff6f52de"},{"code":"(fn cap[l]\n  (reverse\n  (reduce (fn [x y]\n            ;(println (first (first x)) (next x) y) \n            (if (= (first (first x)) y)\n              (conj (next x) (conj (first x) y))\n              (conj x (list y))\n              )\n            ) \n          (list (list (first l))) \n          (next l)\n  )))","problem":31,"user":"509b152be4b0412cdea6eb1e"},{"problem":31,"code":"(fn pack-consecutive-duplicates\n  [s]\n  (loop [result [] [x & xs] s]\n    (cond\n      (nil? x) result\n      (= (first (last result)) x) (recur (conj (pop result) (conj (last result) x)) xs)\n      :else (recur (conj result [x]) xs ))))","user":"5c36d110e4b0d62ef62d9f6a"},{"problem":31,"code":"(letfn [(f [acc currentrun xs]\n          (if (empty? xs) (conj acc currentrun)\n              (if (= (first xs) (first currentrun))\n                (recur acc (conj currentrun (first xs)) (rest xs))\n                (recur (conj acc currentrun) (list (first xs)) (rest xs)))))]\n    #(filter (complement empty?) (f [] '() %)))","user":"554b9c3ee4b0a04f79299594"},{"problem":31,"code":"(fn afkt [coll]\n  (let [pack-1 (fn pack [res prev coll]\n    (if (empty? coll)\n      res\n      (if (empty? res)\n        (pack\n          (list (list (first coll)))\n          (first coll)\n          (drop 1 coll)\n         )\n        (pack\n         (if (= (first coll) prev)\n            (concat (drop-last res)  ( list (conj (last res) prev)))\n           (concat res (list (list (first coll)))))\n         (first coll)\n         (drop 1 coll)))))]\n    (pack-1 '() nil coll)))","user":"5143824ae4b0b4fb4ace5f36"},{"code":"(fn pack-conseq\n  ([s] (pack-conseq s [] []))\n  ([s acc sv]\n    (if (empty? s)\n      (if (empty? sv)\n        acc\n        (conj acc sv)\n      )\n      (if (or (empty? sv) (= (first s) (last sv)))\n        (pack-conseq (rest s) acc (conj sv (first s)))\n        (pack-conseq (rest s) (conj acc sv) [(first s)])\n      )\n    )\n  )\n)","problem":31,"user":"4fff00ede4b0678c553fc3fc"},{"code":"(fn [xs] \r\n  (loop [acc '() \r\n         seq xs]\r\n    (if (empty? seq) (reverse acc)\r\n      (let [split (split-with #(= (first seq) %) seq),\r\n            same (first split)\r\n            rest (second split)]\r\n        (recur (conj acc same) rest)))))","problem":31,"user":"4dea9406535d08e6dec9fe01"}]