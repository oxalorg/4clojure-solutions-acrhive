[{"problem":63,"code":"(fn [f s]\n  (reduce\n    (fn [m n]\n       (update-in m [(f n)] concat [n]))\n   {} s))","user":"55c66ffee4b0e31453f649c2"},{"problem":63,"code":"(fn fun\n  ([x y]\n   (fun (map x y) y {}))\n  ([x y mapa]\n   (if (empty? x)\n     mapa\n     (if (nil? (get mapa (first x)))\n       (fun (rest x) (rest y) (assoc mapa (first x) [(first y)]))\n       (fun (rest x) (rest y) (assoc mapa (first x) (conj (get mapa (first x)) (first y))))))))","user":"560ff632e4b05f002753df66"},{"code":"(fn [f coll]\n  (letfn [(append [m i]\n            (assoc m (f i) (conj (vec (m (f i))) i))\n            )]\n    (reduce #(append %1 %2) {} coll)\n    )\n  )","problem":63,"user":"4fcad14ce4b0ee37620e1856"},{"problem":63,"code":"(fn a [f c]\n  (reduce (fn [acc item]\n            (let [foo (f item)\n                  vec (get acc foo [])]\n              (println vec)\n              (assoc acc foo (conj vec item))))\n          {}\n          c))","user":"5c30da5ae4b0d62ef62d9f23"},{"problem":63,"code":"(fn [f coll]\n  (reduce #(let [k (f %2)]\n             (assoc % k (conj (get % k []) %2))) {} coll))","user":"5c665311e4b0fca0c16226a7"},{"problem":63,"code":"(fn [g args]\n    (loop [xs args f g acc {}]\n        (if (empty? xs)\n            acc\n            (\n              recur (rest xs)\n                     f\n                     (let [el (first xs) k (f (first xs))]\n                        (if (contains? acc k)\n                          (into acc {k (conj (get acc k) el)})   \n                          (into acc {k [el]})\n                        )\n                     )\n            )\n        )\n      )\n  )","user":"55d7312ee4b0e31453f64a9f"},{"problem":63,"code":"(fn [f c]\n  (let [z (partition-by first (sort-by first (map vector (map f c) c)))\n        conv1 (fn [l] (vector (first (first l)) (map last l)))\n        conv (fn [l] (into {} (map conv1 l)))]\n    (conv z)))","user":"539c88e1e4b0b51d73faaf2c"},{"code":"(fn [f coll]\n    (reduce (fn [res i]\n              (let [x (f i)]\n                (assoc res x (conj (res x []) i))))\n            {}\n            coll))","problem":63,"user":"4e80aa10535db62dc21a62b1"},{"problem":63,"code":"(fn my-group-by [f col]\n  (reduce #(let [k (f %2)]\n              (update-in %1 [k] (fn [values] (conj (or values []) %2))))\n                {} \n                col)\n)","user":"59b0e877e4b0e1f4e384c8d3"},{"problem":63,"code":"(fn [func sq]\n   (reduce\n     (fn [acc curr]\n       (conj acc (conj [] curr (filter #(= curr (func %)) sq))))\n     {}\n     (set (map func sq))))","user":"602b90c1e4b0d5df2af22266"},{"problem":63,"code":"#(apply merge-with into (for [data %2] {(% data) [data]}))","user":"56dc483fe4b0ea9b8538f81b"},{"code":"(fn [f a]\n  (loop [a a mp {}]\n    (if (empty? a)\n      mp\n      (let [x (first a)\n            y (f x)\n            entry (or (mp y) [])]\n        (recur (rest a) (assoc mp y (conj entry x)))\n        )\n      )\n    )\n  )","problem":63,"user":"515f8a0de4b0e2be8aa20bce"},{"problem":63,"code":"(fn [f xs]\n  (loop [result {}\n         [x & rest-xs] xs]\n    (if (= nil x)\n      result\n      (let [fx (f x)\n            new-result (if (contains? result fx)\n                         (update-in result [fx] #(conj % x))\n                         (conj result [fx [x]]))]\n        (recur new-result rest-xs)))))","user":"56bfcba1e4b060a8e693e3a1"},{"problem":63,"code":"(fn [f ns] (apply merge (map #(hash-map (f (first %1)) (vec %1)) (partition-by f (sort-by f ns)))))","user":"58e7229fe4b056aecfd47cc4"},{"problem":63,"code":"(fn gp [p se]\n  (apply merge-with concat (map #(hash-map (p %) [%]) se)))","user":"5e909685e4b0cb016954634d"},{"code":"(fn [f coll]\n  (loop [ret {}\n         c coll]\n    (if (empty? c)\n      ret\n      (let [fst (first c)\n            k (f fst)]\n        (recur (update-in ret [k] #(vec (conj % fst)))\n               (rest c))))))","problem":63,"user":"52c58561e4b0c2d177d620f8"},{"problem":63,"code":"(fn [f coll]\n  (reduce (fn [r x]\n            (let [k (f x)]\n              (assoc r k (conj (get r k []) x)))) {} coll))","user":"5defc177e4b093ff717275af"},{"code":"(fn [f s]\r\n  (reduce #(merge-with concat %1 %2) (map #(assoc {} (f %) [%]) s)))","problem":63,"user":"4df407c3535d08e6dec9fe2e"},{"problem":63,"code":"(fn [f vec] (reduce #(assoc %1 (f %2) (conj (get %1 (f %2) []) %2)) {} vec))","user":"5ee81beae4b029a2061bbeac"},{"problem":63,"code":"(fn mgroup-by [f s]\n  (reduce\n    #(assoc\n      %1\n      (f %2)\n      (conj\n        (or (%1 (f %2)) [])\n        %2))\n    {} s))","user":"57ed2574e4b0bfb2137f5b93"},{"problem":63,"code":"(fn seq-grouper\n  [f s] \n   (loop [\n          k s \n          v (map f s) \n          new-map {} \n          ]\n     (if (empty? k)\n       new-map\n       (let [\n             new-map (if (nil? (find new-map (first v)) ) \n                      (assoc new-map (first v) [(first k)])\n                      (assoc new-map (first v) (conj (get new-map (first v)) (first k))))]\n          (recur (rest k) (rest v) new-map )\n         )\n       )\n     )\n   )","user":"5564709ee4b0c656e3ff1807"},{"code":"(fn [f s]\n  (let [M map\n        u (set (for [v (M f s)] [v (filter #(= v (f %)) s)]))]\n    (zipmap (M first u) (M second u))))","problem":63,"user":"4ee82539535d93acb0a66878"},{"problem":63,"code":"(fn [f coll]\n  (reduce (fn [acc item]\n            (merge-with into acc {(f item) (vector item)}))\n          {}\n          coll))","user":"58ee5371e4b056aecfd47da8"},{"problem":63,"code":"#(reduce\n  (fn [acc v]\n      (assoc acc (% v) (conj (get acc (% v) []) v)))\n    {} %2)","user":"5b924123e4b0c0b3ffbd4a34"},{"problem":63,"code":"(fn my-group-by [f s]\n  (reduce\n   (fn [hmap sᵢ]\n     (let [v    (f sᵢ)\n           same (or (hmap v) [])]\n       (assoc hmap v (conj same sᵢ))))\n   {}\n   s))","user":"5e38a9cbe4b01d43a70e8dc2"},{"code":"(fn [f coll]\n  (reduce (fn [ret x]\n            (let [k (f x)]\n              (assoc ret k\n                     (conj (get ret k []) x)))) {} coll))","problem":63,"user":"50ef96a1e4b0bdaecbb47d9d"},{"problem":63,"code":";; Short and unreadable form: (fn [f coll] (reduce #(assoc % (f %2) (conj(% (f %2) []) %2)) {} coll))\n(fn [f coll]\n  (reduce \n   (fn [res, value] \n     (let [k (f value)\n           curr (get res k [])]\n       (assoc res k (conj curr value))))\n   {}\n   coll))","user":"573f3ccfe4b05c31a32c083f"},{"code":"(fn group-sequence [f s]\n  (reduce\n    #(merge-with concat\n                 %2 %1)\n              (map (fn [pair]\n                     (let [k (first pair)\n                           v (last pair)]\n                       {v [k]}))\n                   (zipmap s (map f s)))))","problem":63,"user":"51db0d99e4b06aa4d4669a9d"},{"problem":63,"code":"(fn my-group-by\n  [func seq]\n   (into {}\n         (map #(vector (func (first % )) (vec %))\n              (partition-by func (sort seq)))))","user":"5f3103aee4b0574c87022c24"},{"problem":63,"code":"#(reduce\n    (fn [ret x]\n      (let [k (%1 x)]\n        (assoc ret k (conj (get ret k []) x))))\n    {} %2)","user":"54577fefe4b01be26fd7460d"},{"problem":63,"code":"(fn [f xs]\n     (reduce (fn [acc x] \n               (let [res (f x)]\n                 (if (contains? acc res)\n                   (assoc acc res (conj (get acc res) x))\n                   (assoc acc res (conj [] x))\n                 )))\n             {} xs))","user":"5de68f83e4b0986d99407f6c"},{"problem":63,"code":"(fn [ f d]\n  (let [grps (vec (map f d))\n        k  (apply sorted-set  grps)\n        ff (fn[j](vec (filter #(= j (f %)) d)))]\n     (apply hash-map (vec (interleave k (map ff k))))))","user":"52f426fce4b05e3f0be25f1e"},{"problem":63,"code":"(fn [f xs]\n  (reduce\n   (fn [m x] (update-in m [(f x)] #(conj (or % []) x)))\n   {}\n   xs))","user":"583e27e2e4b089d5ab817daa"},{"code":"(fn [f s] \n  (loop [m {} r s]\n    (if (empty? r) m\n      (let [v (first r),\n            k (f v)]\n        (recur (assoc m k (conj (get m k []) v)) (next r))\n        ))))","problem":63,"user":"51a7b4fee4b0da5f497bde8b"},{"code":"(fn [f s]\n  (reduce \n    (fn [m x]\n      (let [ \n        k (f x)\n        v (get m k [])]\n        (assoc m k (conj v x))))\n    {}\n    s))","problem":63,"user":"4f569218e4b0a7574ea71826"},{"code":"(fn [f coll]\n  (reduce\n    (fn [acc x]\n      (let [y (f x)]\n        (if (contains? acc y)\n          (assoc acc y (conj (get acc y) x))\n          (assoc acc y [x]))))\n    {}\n    coll))","problem":63,"user":"500ff421e4b0ae202717946f"},{"code":"(fn [f xs] (reduce #(assoc %1 (f %2) (conj (%1 (f %2) []) %2)) {} xs))","problem":63,"user":"502d387fe4b0d96a44ab202f"},{"code":"(fn[f col]\n  (reduce \n   #(assoc %1 (f %2) \n      (conj (apply vector (%1 (f %2))) %2)) {} col))","problem":63,"user":"532631e1e4b09d4e7a9b54ea"},{"code":"(fn [f values]   \n  (reduce                 \n    (fn [result [k v]]    \n      (assoc result k (conj (get result k []) v)))\n  {}\n  (partition 2 (interleave (map f values) values)))\n)","problem":63,"user":"4ee3afde535d10e5ff6f5370"},{"problem":63,"code":"(fn p4c63 [f coll] (reduce (fn [aggr x] (let [key (f x) vals (aggr key)] (assoc aggr key (concat vals [x])))) {} coll))","user":"5880d686e4b0f1effa3b7623"},{"problem":63,"code":"(fn [op v]\n(let [m (map #(hash-map (op %) %) v)\n      r (zipmap (keys (apply merge m)) (repeat []))]\n  (apply merge-with conj r m)\n  )\n)","user":"56ebe773e4b04a395b9a042a"},{"problem":63,"code":"(fn [function values]\n  (into {}\n        (->> (partition-by function (sort values))\n            (mapv #(vector (function (first %)) (vec %)))\n         )\n        )\n  )","user":"60752ef6e4b069485764de55"},{"code":"#(loop [f %1\n        s %2\n        m {}]\n   (if (empty? s)\n     m\n     (recur f\n            (rest s)\n            (if (contains? m (f (first s)))\n              (assoc m (f (first s)) (concat (get m (f (first s))) (list (first s))))\n              (assoc m (f (first s)) (list (first s)))))))","problem":63,"user":"51d360d1e4b099f3b6acddff"},{"code":"#(persistent! \n  (reduce (fn [ret x] \n            (let [k (%1 x)] \n              (assoc! ret k (conj (get ret k []) x))))\n    (transient {}) %2))","problem":63,"user":"52b02329e4b0c58976d9acc5"},{"problem":63,"code":"(fn [f xs] \n  (reduce (fn [m [r x]] \n            (conj m {r (conj (m r []) x)}))\n          {}\n          (map list (map f xs) xs)))","user":"55c49394e4b0e31453f6499e"},{"problem":63,"code":"(fn \n  [func col] \n  (reduce \n   (fn [myMap item] \n     (conj myMap \n           (let [myKey (func item), value (myMap myKey)] \n             (vector myKey \n              (if \n                (nil? value) \n                (vector item) \n                (conj value item)\n                )\n                     )\n             )\n           )\n     )\n   {} col))","user":"58950f29e4b00487982d5270"},{"problem":63,"code":"(fn [f s]\n    (loop [out {} s s]\n      (if (empty? s)\n        out\n        (let [item (first s)\n              key (f item)]\n          (recur\n           (conj out\n                 (if (contains? out key)\n                   [key (conj (out key) item)]\n                   [key [item]]))\n\n           (rest s))))))","user":"58ec1e63e4b056aecfd47d54"},{"code":"(fn g [f s]\n  (reduce (fn [r v] (let [add #((fnil conj []) % %2)]\n                     (update-in r [(f v)] add v))) {} s))","problem":63,"user":"4f8c813de4b02e764a0a519f"},{"code":"#(reduce (fn[c v](assoc c (% v) (conj (get c (% v) []) v))) {} %2)","problem":63,"user":"4de8a7d7535d08e6dec9fdfe"},{"code":"(fn [f s]\n  (reduce #(assoc %1 (f %2) (conj (get %1 (f %2) []) %2))\n     {} s))","problem":63,"user":"4f1bb9d8535d64f60314647d"},{"code":"(fn [f s]\n  (reduce (fn [m x]\n            (let [y (f x)]\n              (assoc m y (conj (get m y []) x)))) {} s))","problem":63,"user":"4eee5c7f535d93acb0a668c6"},{"problem":63,"code":"(fn [f col]\n  (reduce (fn [agg el]\n            (let [elkey (f el)\n                  f-append (fn [m k el] (assoc m k (conj (m k) el)))\n                  f-add (fn [m k el] (assoc m k [el]))\n                  ]\n            \t(if (agg elkey) (f-append agg elkey el) (f-add agg elkey el))\n              )\n          )\n          {}\n          col)\n  )","user":"6004c750e4b074f607df6645"},{"problem":63,"code":"(fn [f c]\n  (reduce (fn [m [k v]] (assoc m k (conj (get m k []) v))) {}\n          (partition 2 (interleave (map f c) c))))","user":"52d07cc5e4b07d0d72b273bb"},{"code":"(fn [pred coll]\n  (apply (partial merge-with concat) (map #(array-map (pred %1) [%1]) coll)))","problem":63,"user":"4f0e995e535d0136e6c22326"},{"problem":63,"code":"(fn\n  [f items]\n  (reduce \n   #(assoc %1 (f %2) (conj (get %1 (f %2) []) %2))\n   {}\n   items)\n)","user":"5dd25ca8e4b0948ae9d9ad55"},{"code":"(fn [f s]\n (reduce (fn [so-far new-item]\n           (assoc so-far\n             (f new-item)\n             (conj (get so-far (f new-item) [])\n                   new-item)))\n         {}\n         s))","problem":63,"user":"51a3b135e4b0e77c4ca60bf6"},{"problem":63,"code":"(fn func [f lst]\n  (if (empty? lst)\n    {}\n    (let [mp (func f (rest lst))\n          k (f (first lst))]\n      (assoc mp k (cons (first lst) (mp k))))))","user":"5c62979fe4b0fca0c162264c"},{"code":"(fn [f xs]\r\n  (reduce (fn [acc x]\r\n             (let [k (f x)\r\n                   cur (if (nil? (acc k)) [x] (conj (acc k) x))]\r\n          (assoc acc k cur))) {} xs))","problem":63,"user":"4e8681b7535dae1a5effa438"},{"code":"(fn group-a-seq [f s]\n  (loop [s s acc {}]\n    (cond\n     (empty? s) acc\n     :else\n     (let [k (f (first s))\n           matches (filter\n                    (fn [x]\n                      (= k (f x)))\n                    s)\n           sans-matches (remove\n                         (fn [x]\n                           (= k (f x)))\n                         s)]\n       (recur sans-matches (assoc acc k (into [] matches)))))))","problem":63,"user":"4fd16778e4b04c3a95aa040f"},{"code":"(fn seqgrp [f s]\n  (if (empty? s) {}\n    (update-in (seqgrp f (rest s)) [(f (first s))] (partial cons (first s)))))","problem":63,"user":"529ce629e4b04e0c58e87b6e"},{"problem":63,"code":"(fn [f col] \n  (reduce (fn [col el]\n            (let [k (f el)\n                  v (col k)]\n              (assoc col k (if (nil? v) [el] (conj v el)))))\n          {} \n          col))","user":"5956c6dae4b066ee0a44af61"},{"code":"(fn [f coll]\r\n  (persistent!\r\n   (reduce\r\n    (fn [ret x]\r\n      (let [k (f x)]\r\n        (assoc! ret k (conj (get ret k []) x))))\r\n    (transient {}) coll)))","problem":63,"user":"4f148418535d64f60314643a"},{"problem":63,"code":"(fn [f s] (reduce #(merge-with into %1 {(f %2) [%2]}) {} s))","user":"595914e0e4b066ee0a44af99"},{"problem":63,"code":"#(loop [q %2 m {}]\n     (if (seq q)\n       (let [value (peek q) key (% value)]\n         (recur (pop q) (assoc m key (conj (or (m key) '()) value)))\n         )\n       m \n       )\n     )","user":"54b90836e4b0ed20f4ff6e9d"},{"problem":63,"code":"(fn [f m]\n  (loop [r {} a m]\n    (if (empty? a)\n      r\n      (recur (assoc r\n        (f (first a)) \n        (conj (get r (f (first a)) [])\n              (first a))) (rest a)))))","user":"5683d2a9e4b0945ebc182aa0"},{"code":"; First obtain the keys. Then for each key filter out from the sequence all of those values which when f is\n; applied to them give you the key\n(fn [f se]\n  (let [keys (set (map f se))]\n    (into {} (for [k keys] {k (vec (filter #(= k (f %)) se))}))\n    )\n)","problem":63,"user":"5201ff99e4b0b2e020a18f26"},{"code":"(fn [op coll] (reduce #(assoc %1 (op %2) (conj (vec (get %1 (op %2))) %2)) {} coll))","problem":63,"user":"52c5c1c8e4b0c2d177d620fc"},{"code":"(fn my-group-by [f coll]\n  (reduce (fn [acc x]\n      (let [key (f x)]\n\t      (if (acc key)\n\t\t(assoc acc key (conj (acc key) x))\n\t\t(assoc acc key [x]))))\n\t  {}\n\t  coll))","problem":63,"user":"4dc54eb2535d8a4b2fd74284"},{"problem":63,"code":"(fn [f coll]\n  (reduce (fn [result item]\n            (let [k (f item)\n                  v (get result k)]\n              (if (nil? v)\n                (assoc result k [item])\n                (assoc result k (conj v item)))))\n          {}\n          coll))","user":"5b4fef74e4b02d533a91bcde"},{"code":"(fn [f d]\n    (apply merge-with\n      (fn [a b]\n        (concat a b))\n      (map (fn [n] {(f n) [n]}) d))\n  )","problem":63,"user":"4f16d6ed535d64f60314644f"},{"problem":63,"code":"(fn [f coll]\n    (let [keys (vec (set (map f coll)))\n          key-values (map (fn [k] [k (into [] (filter #(= (f %) k) coll))]) keys)]\n     (into {} key-values)))","user":"58a34442e4b02bd94d917ef2"},{"code":"(fn[ff v]\n  (loop [ans {} vv v]\n    (if (empty? vv) \n      ans \n      (let [kk (ff (first vv))\n            value (if (contains? ans kk) (get ans kk) []) \n            newans (assoc ans kk (conj value (first vv)))]  \n        (recur newans (next vv))))))","problem":63,"user":"52196842e4b0890f2f822bfa"},{"code":"(fn _ [f coll]\n  (when-let [[x & xs] (seq coll)]\n    (update-in (_ f xs) [(f x)] #(cons x %))))","problem":63,"user":"4e71705e535d5021c1a89649"},{"code":"(fn [pred coll]\n  (loop [coll coll acc {}]\n    (if (empty? coll)\n      acc\n      (let [x (first coll)\n            y (pred x)\n            z (acc y)]\n        (if z\n          (recur (rest coll)\n                 (assoc acc y (conj z x)))\n          (recur (rest coll)\n                 (assoc acc y [x])))))))","problem":63,"user":"4e4ae5aa535dc968683fc4d2"},{"problem":63,"code":"(fn [f col]\n  (reduce #(let [val (%1 (first %2))]\n             (if (nil? val)\n               (assoc %1 (first %2) [(second %2)])\n               (assoc %1 (first %2) (conj val (second %2))))) {} (map vector (map f col) col)))","user":"563c48e7e4b0bfe05bf11832"},{"problem":63,"code":"(fn my-group-by [f s]\n  (\n    (fn [s]\n      (loop [r s\n            ret {}]\n        (if (empty? r)\n          ret\n          (recur (rest r) (merge-with into ret (first r)))\n        )\n      )      \n    )  \n    (map (fn [k v] {k [v]}) (map f s) s)\n  )\n)\n\n;#(reduce \n;  (fn [res x] \n;    (assoc res (% x) \n;      (conj (get res (% x) []) x)\n;    )\n;  ) {} %2)\n\n;#(apply merge-with concat (map (fn [x] {(%1 x) [x]}) %2))","user":"60335b35e4b0d5df2af222bf"},{"problem":63,"code":"(fn prob63 \n  [f col]\n  (reduce\n   (fn [ret x]\n     (let [key (f x)]\n       (assoc ret key (conj (get ret key []) x)))\n     )\n   {} col))","user":"4ebbff41535dfed6da9c6d78"},{"problem":63,"code":"(fn [f xs](apply merge-with into (for [x xs] {(f x) [x]})))","user":"5668dcc6e4b04acd4f672df8"},{"code":"(fn [fun args] (reduce\n  ((fn [f] (fn [acc arg]\n\t\t(let [result (f arg)\n\t\t      prev (or (acc result) [])]\n\t\t\t(assoc acc result (conj prev arg))))) fun) {} args))","problem":63,"user":"4dfe65a1535d04ed9115e787"},{"problem":63,"code":"(fn [f xs]\n   (reduce (fn [acc cur]\n             (let [k (f cur)\n                   prev (get acc k)\n                   xs (if (empty? prev) [] prev)]\n               (assoc acc k (conj xs cur)))) {} xs))","user":"603f6623e4b0d5df2af2231f"},{"code":"(fn [f coll]\n    (persistent!\n      (reduce\n        (fn [ret x]\n          (let [k (f x)] \n            (assoc! ret k (conj (get ret k []) x))))\n        (transient {}) coll)))","problem":63,"user":"4fa2fa5ee4b081705acca186"},{"code":"#(reduce(fn[f s](assoc f (% s)(conj(f (% s)[]) s))){}%2)","problem":63,"user":"4e7650c5535d324fb2983d68"},{"problem":63,"code":"(fn group-a-sequence [f vals]\n  (into {}\n        (map #(vector (f (first %)) (vec %))\n             (partition-by f (sort vals)))))","user":"5f003099e4b0cf489e8d7f17"},{"problem":63,"code":"(fn [o coll]\n  (loop [m {} r coll]\n    (if (empty? r)\n      m\n      (if (m (o (first r)))\n        (recur (update-in m [(o (first r))] conj (first r)) (next r))\n        (recur (assoc m (o (first r)) (vector (first r))) (next r))\n      )\n    )\n  )\n)","user":"57873017e4b0ebec4cfb7503"},{"problem":63,"code":"(fn [f s] (reduce (fn [m i] (assoc m (f i) (conj (m (f i) []) i))) {} s))","user":"5f8fe45ae4b0715f5002d78d"},{"problem":63,"code":"(fn [f coll]\n  (reduce (fn [map x]\n            (let [key (f x)]\n              (assoc map key (conj (get map key []) x)))) \n          {} coll))","user":"550615c0e4b021ccfedb9696"},{"problem":63,"code":"(fn gp[f xs]\n  (loop [ys xs res {}]\n    (if (empty? ys)\n      res\n      (let [k (f (first ys))]\n        (recur (rest ys) (assoc res k (conj (vec (res k)) (first ys))))))))","user":"5488537be4b0e286459a11cf"},{"code":"(fn [f l]\n  (reduce (fn [ret it]\n              (let [tmp (f it)]\n                   (if (ret tmp)\n                       (conj ret [tmp (conj (ret tmp) it)])\n                       (conj ret [tmp [it]])))) {} l))","problem":63,"user":"4ec21058535dfed6da9c6dba"},{"code":"(fn [f s]\r\n  ((fn [[x & xs :as s] m]\r\n     (if-not s\r\n       m\r\n       (recur xs \r\n              (let [fres (f x)]\r\n                (assoc m fres (if-let [ar (m fres)]\r\n                                (conj ar x)\r\n                                [x]))))))\r\n    (seq s) (hash-map)))","problem":63,"user":"4f359c7ee4b0e243712b1ec4"},{"problem":63,"code":"(fn [fn1 coll1]\n  (loop [remaining coll1 result {}]\n    (if (empty? remaining)\n      result\n      (recur\n        (rest remaining)\n        (merge\n           result\n           {(fn1 (first remaining)) (concat (get result (fn1 (first remaining)) []) (list (first remaining)))}\n        )\n      )\n    )\n  )\n)","user":"53f17931e4b0742d9025b0dd"},{"problem":63,"code":"(fn [f s]\n(apply merge \n(for [k (distinct (map f s))]\n{k (vec (filter #(= k (f %)) s))})))","user":"569adec2e4b0542e1f8d1450"},{"problem":63,"code":"#(loop [\n    remaining %2\n    result {}\n    ]\n    (if (empty? remaining) \n      result\n      (let [in (first remaining)\n            out (%1 in)\n            curr-result (get result out)\n            r-remaining (rest remaining)]\n          (if (not (nil? curr-result))\n\n            (recur r-remaining (assoc result out (conj curr-result in)))\n            (recur r-remaining (assoc result out [in]))\n          )\n      )\n    )\n  )","user":"5710140fe4b09c608db7042e"},{"problem":63,"code":"(fn [f s]\n  (reduce (fn [acc elt]\n            (let [k (f elt)\n                  v (get acc k [])]\n              (assoc acc k (conj v elt))))\n          {} s))","user":"55088bb3e4b06e50f9beb10c"},{"problem":63,"code":"(fn  [f coll]\n  (reduce\n   (fn [dict m]\n     (let [k (f m)]\n       (assoc dict k (conj (or (dict k) []) \n                           m))))\n   {} coll))","user":"5ebdb3d2e4b00a66d4a95275"},{"problem":63,"code":"(fn [f coll]\n    (apply merge-with\n       into\n       (map #(hash-map (f %) [%])  coll))\n )","user":"5a778224e4b013a48d399761"},{"code":"(fn [p xs]\n  (apply (partial merge-with concat) (map (fn [x] (hash-map (p x) [x])) xs)))","problem":63,"user":"5213d7aae4b0961f15ac4d72"},{"code":"(fn [f coll]\n  (into {}\n    (map #(vector (f (first %)) (vec %))\n    (partition-by f (sort coll)))))","problem":63,"user":"52c672e2e4b0c2d177d6210e"},{"problem":63,"code":"(fn [f s]\n  (reduce\n    (fn [m v]\n      (let [k (f v)]\n        (assoc m k (conj (get m k []) v))))\n    {} s))","user":"553abb28e4b09218d5f44ffb"},{"code":"(fn [f coll]\n  (reduce (fn [m x]\n            (let [y (f x)]\n              (assoc m y (conj (m y []) x))))\n          {} coll))","problem":63,"user":"4fe84c74e4b07c9f6fd12c3c"},{"problem":63,"code":"(fn [f coll]\n  (reduce (fn [ac x]\n            (let [k (f x)]\n              (assoc ac k (conj (get ac k []) x))))\n          {}\n          coll))","user":"5c3796b3e4b0d62ef62d9f77"},{"code":"(fn my-group-by\n  ([f s] (my-group-by f s {}))\n  ([f s m]\n    (if (empty? s)\n      m\n      (my-group-by f (rest s)\n        (conj m (let [v (first s) k (f v)]\n          [k (conj (m k []) v)])\n        )\n      )\n    )\n  )\n)","problem":63,"user":"4fff00ede4b0678c553fc3fc"},{"code":"(fn [f v]\n  (apply merge-with concat (for [x v] {(f x) [x]})))","problem":63,"user":"4fe13ad7e4b0dd6cd5ce3632"},{"problem":63,"code":"(fn [f coll]\n  (reduce \n    #(let [v (f %2)] (assoc % v (conj (% v []) %2))) \n    {} coll))","user":"5654d0e1e4b0f9d632dd848c"},{"code":"(fn [fun values]\n   (reduce (fn [m x] (let [key (fun x)]\n                     (assoc m key (conj (vec (get m key)) x )))) {} values))","problem":63,"user":"5047782ce4b0371827a27bc2"},{"problem":63,"code":"(fn [f data] \n  (reduce \n   (fn [m d] \n     (let [k (f d) v (get m k [])] \n       (assoc m k (conj v d))\n     )\n   ) {} data\n  )\n)","user":"55c3f19de4b0e31453f64991"},{"problem":63,"code":"(fn [f coll]\n  (loop [r {} i coll]\n    (if (seq i)\n      (let [cur (first i)]\n        (recur \n         (assoc r (f cur) (conj (vec (get r (f cur))) cur))\n         (rest i)))\n      r)))","user":"54a80855e4b09f271ff37c9e"},{"code":"(fn\n  [f s]\n  (letfn [(addTo [m k v] (assoc m k (conj (m k []) v)))]\n         (reduce #(addTo %1 (f %2) %2) {} s)))","problem":63,"user":"52dfc89be4b09f7907dd1405"},{"problem":63,"code":"(fn [f c]\n   (reduce \n     (fn [t v]\n       (let [k (f v)]\n         (assoc t k (conj (t k []) v))))\n     {}\n     c))","user":"51e6a2bce4b0ab43cc26c21d"},{"code":"(fn [func coll]\n  (loop [f func, c coll, acc {}] \n    (if (empty? c)\n      acc \n      (let [h (first c), t (rest c)] \n          (recur f t (assoc acc (f h) (conj (vec (get acc (f h))) h)))))))","problem":63,"user":"50a83794e4b054305ba5a831"},{"problem":63,"code":"(fn grs [f s]\n  (reduce\n   (fn [results x]\n     (assoc results (f x) (conj (get results (f x) []) x)))\n   (hash-map)\n   s))","user":"5833a6d8e4b089d5ab817ca2"},{"problem":63,"code":"( fn [f coll] \n    (reduce \n      (fn [m v] \n        (if(contains? m (f v))\n        (assoc m (f v) (conj (get m (f v)) v)) \n        (assoc m (f v) [v])\n        )\n      )\n      {}\n      coll\n     ))","user":"60845eb8e4b0736b099e42ef"},{"problem":63,"code":"(fn [f coll]\n      (let [applied-fn (map #(vec %) (partition-by f coll))\n            fn-results (map #(f (first %)) applied-fn)\n            sorted-results (sort-by first (partition 2 (interleave fn-results applied-fn)))]\n        (zipmap (distinct fn-results)\n                (map (fn [values]\n                       (vec (apply concat (rest (distinct values)))))\n                     (map (fn [result]\n                            (apply concat (filter #(= (first %) result) sorted-results)))\n                          (distinct fn-results))))))","user":"57b19fa1e4b0fbc9809a2754"},{"problem":63,"code":"(fn [f as]\n             (reduce\n               (fn[acc a]\n                 (assoc acc (f a) (vec(conj (acc (f a)) a))))\n               {}\n               as)\n             )","user":"52149e21e4b0961f15ac4d94"},{"code":"(fn [f s] (apply merge-with concat (map #(hash-map (f %) [%]) s)))","problem":63,"user":"4f043ed1535dcb61093f6bb4"},{"code":"(fn grp-by [f s]\n  (let [pairs (map #(vector (f %) %) s)\n        kk (set (map first pairs))\n        f-m (fn [s v] (vec (map second (filter #(= (first %) v) s))))\n        vv (map #(f-m pairs %) kk)]\n    (zipmap kk vv)))","problem":63,"user":"500854c4e4b028e089d3518c"},{"code":"(fn [func coll] (apply merge-with concat (map #(hash-map (func (first %)) %) (partition-by func coll))))\n\n;(fn [func coll] (map #(hash-map (func (first %)) %) (partition-by func coll)))","problem":63,"user":"528b08efe4b0239c8a67ae8a"},{"code":"(fn g [f l]\n  (apply hash-map\n    ((fn q [m] (if (not (seq m)) '()\n                 (cons (first (first m))\n                       (cons (into [] (map second (take-while #(= (first %) (first (first m))) m)))\n                             (q (drop-while #(= (first %) (first (first m))) m))))))\n    (sort-by first (map vector (map f l) l)))))","problem":63,"user":"53638ed2e4b0243289761e5b"},{"problem":63,"code":"(fn [f coll]\n\t(reduce\n\t#(let [k (f %2)]\n\t\t(if (%1 k)\n\t\t\t;(update %1 k (fn [x] (conj x %2)))\n        \t(update-in %1 [k] (fn [x] (conj x %2)))\n\t\t\t(conj %1 {k [%2]})\n\t\t)\n    )\n\t{} coll)\n)","user":"5d2201b8e4b02ea6f0fb69ed"},{"problem":63,"code":"(fn [f s]\n  (reduce\n    (fn [r v]\n      (let [fk (f v)\n            fv (get r fk [])]\n        (conj r {fk (conj fv v)})))\n    {}\n    s))","user":"556159fae4b0c656e3ff17c7"},{"code":"(fn [f col]\n  (loop [s col b {}]\n    (if (seq s)\n      (let [a (first s) x (f a) y (b x)]\n        (recur (rest s) (assoc b x (vec (conj y a)))))\n      b)))","problem":63,"user":"531488f3e4b08068f379ed16"},{"problem":63,"code":"(fn gr [f coll]\n  (reduce\n   \t(fn [d it]\n      (update-in d [(f it)] concat [it]))\n   \t{}\n   \tcoll))","user":"5666c2dbe4b04acd4f672dc3"},{"code":"(fn gb\n  ([f col] (gb f col (map f col) {}))\n  ([f col ks d]\n   (if \n     (empty? col) d\n     (let [v (first col)\n           k (first ks)] \n       (recur f (rest col) (rest ks) (conj d [k (conj (d k []) v)]))))))","problem":63,"user":"506d5e4ce4b0a302964c5493"},{"problem":63,"code":"(fn group-seq\n   [f coll]\n   (zipmap (distinct (map f coll)) (partition-by f (sort coll))))","user":"5d6691cee4b0db5d338d15e9"},{"problem":63,"code":"(fn [fnc list]\n  (loop [result {} [element & remaining] list]\n    (if (nil? element)\n      result\n      (let [value (fnc element)]\n        (recur (conj result (vector value (conj (or (result value) []) element))) remaining)  \n        )\n      )\n    )\n  )","user":"563a30d7e4b0bfe05bf117f9"},{"code":"(fn groupASequence [a b] (loop [x (vec b) y {}] (if (empty? x) y\n                                                      (recur (rest x) (if (contains? y (a (first x)))\n                                                                        (conj y [(a (first x))\n                                                                                 (conj (y (a (first x))) (first x))])\n                                                             (conj y [(a (first x)) (vector (first x))]))))))","problem":63,"user":"4f9336ece4b0dcca54ed6cb7"},{"problem":63,"code":"(fn [f lst] \n  (reduce (fn [m v] (assoc m (f v) (conj (m (f v) []) v))) {} lst))","user":"55c20bd0e4b0e31453f64972"},{"code":"(fn [f ls]\n  (reduce\n    (fn [acc x]\n      (if (contains? acc (f x))\n        (assoc acc (f x) (conj (get acc (f x)) x))\n        (assoc acc (f x) (conj [] x))))\n    {}\n    ls))","problem":63,"user":"4fb1325de4b081705acca276"},{"problem":63,"code":"(fn [f s] (into {} (map #(vec [(first (first %)) (map last %)]) (partition-by first (sort-by first (map #(vec [(f %) %]) s))))))","user":"4ee67364535d93acb0a6685f"},{"problem":63,"code":"(fn gb [f s]\n  (reduce\n    (fn [m x]\n      (merge-with concat m {(f x) [x]})) {} s))","user":"548fa2dfe4b0e286459a1240"},{"problem":63,"code":";(fn __ [f s]\n;  (->> s\n;       (map #(assoc {} (f %) [%]))\n;       (reduce #(merge-with into %1 %2))))\n\n#(apply merge-with into\n        (for [x %2]\n          {(% x) [x]}))","user":"573118ebe4b0cd1946bd0fbd"},{"code":"(fn group-by-1 [f s]\n  (reduce (fn [result el]\n            (let [fs (f el)]\n              (assoc result fs (conj (get result fs) el))))\n          {} (reverse s)))","problem":63,"user":"4e5867d1535d8a8b8723a291"},{"problem":63,"code":"#(->> %2\n      sort\n      (partition-by %1)\n      (map (fn [v] [(%1 (first v)) v]))\n      (into {}))","user":"55216aa5e4b0882d96d09192"},{"code":"(fn [f s] \n  (reduce \n    (fn [res a] \n      (let [fa (f a) v (get res fa [])] \n        (assoc res fa (conj v a)))) {} s))","problem":63,"user":"502904e0e4b0feaf66e22fad"},{"problem":63,"code":";; 4clojure is clj v1.4 can't use update which was added in 1.7\n\n(fn group-by-res [f s]\n  (reduce (fn [acc n]\n            (let [k (f n)]\n              (assoc acc k (concat (get acc k) [n]))))\n          {}\n          s))","user":"5d7aa22ee4b02e6b30c9354e"},{"problem":63,"code":"(fn [f x]\n   (let [result (reduce #(assoc %1 (f %2) []) {} x)]\n   \t(reduce #(assoc %1 (f %2) (conj (%1 (f %2)) %2)) result x)))","user":"56798d83e4b05957ce8c618b"},{"code":"(fn [f s]\n  (reduce\n  #(let [k (first %2), v (second %2)]\n     (if (nil? (%1 k))\n       (assoc %1 k [v])\n       (assoc %1 k (conj (%1 k) v))))\n  {} (map (fn [x] (vector (f x) x)) s)))","problem":63,"user":"4f128865535d64f603146428"},{"problem":63,"code":"(fn [f values]\n    (loop [result {} a-seq values]\n      (if (empty? a-seq)\n        result\n        (let [arg (first a-seq)\n              value (f arg)\n              a-vector (get result value [])]\n          (recur (assoc result value (conj a-vector arg))\n                 (rest a-seq))))))","user":"5054d243e4b0b1b9d1860eb5"},{"problem":63,"code":"(fn [f coll]\n  (reduce (fn [accum val]\n            (let [k (f val)]\n            \t(assoc accum k (conj (vec (accum k)) val))))\n\t{} coll))","user":"54d127b7e4b0e8a36923e5de"},{"problem":63,"code":"(fn [f coll] (loop [key (map f coll), distinct (distinct key), coll coll, map (zipmap distinct (take (count distinct) (cycle (vector []))))]\n                                 (if (empty? key)\n                                   map\n                                   (recur (rest key) (rest distinct) (rest coll) (assoc map (nth key 0) (conj (get map (nth key 0)) (nth coll 0))))\n                                   )\n                                 )\n                    )","user":"5cf72682e4b0b71b1d808a68"},{"problem":63,"code":"(fn group-map [f xs]\n  (if (empty? xs)\n    '{}\n    (let [restmap (group-map f (rest xs)) x (first xs) y (f x) mappedxs (restmap y)]\n      (if (not= mappedxs nil) \n        (assoc restmap y (cons x mappedxs))\n        (assoc restmap y (vector x))))))","user":"58cf00c8e4b03c36ff7e58ac"},{"problem":63,"code":"(fn [f s]\n  (reduce #(assoc %1 (first %2) (conj (or (get %1 (first %2)) (vector)) (second %2))) {}\n   (map #(vector %1 %2) (map f s) s)))","user":"5630471ce4b073c1cf7a9be4"},{"problem":63,"code":"(fn group-by- [f coll]\n;;  (let [v (first coll)\n;;        res (f v) ]\n;;  (pr :v v :coll coll :res res)\n;;        (merge-with into {res v}\n;;          (if-not (empty? coll)\n;;            (group-by- f (rest coll))\n;;             ))\n  (apply merge-with into (for [v coll] {(f v) [v]})))","user":"5972fcf6e4b01722bebd4c92"},{"problem":63,"code":"(fn [f s]\n  (reduce #(assoc %1 (f %2) (vec (conj (%1 (f %2)) %2))) {} s))","user":"4fdb881ee4b05e33b9224f5e"},{"problem":63,"code":"(fn [f l]\n     (reduce (fn [a v]\n               (let [k (f v)]\n                (assoc a k (conj (a k []) v)))) \n             {} l))","user":"58b86162e4b0ebc645576d97"},{"problem":63,"code":"(fn group [func coll]\n  (loop [result {} xs coll]\n    (if (empty? xs)\n      result\n      (let [el (first xs) res (func el)]\n        (if (contains? result res)\n          (recur (assoc result res (conj (result res) el)) (rest xs))\n          (recur (assoc result res [el]) (rest xs)))))))","user":"53c126fce4b00fb29b22125b"},{"problem":63,"code":"(fn [f l]\n   (loop [result {}\n          list l]\n     (if (empty? list)\n       result\n       (let [key (f (first list))\n             value (result key [])]\n         (recur (assoc result key (conj value (first list))) (rest list))))))","user":"5f3f2281e4b004f08c61c561"},{"problem":63,"code":"(fn [f v] (reduce #(merge-with concat % {(f %2) [%2]}) {} v))","user":"549c3e0ce4b0f3d1d8e70f87"},{"code":"#(reduce (fn [r n]\n             (let [l (vec (r (% n)))]\n               (assoc r (% n) (conj l n))))\n           {} %2)","problem":63,"user":"4e705861535d5021c1a89635"},{"problem":63,"code":"(fn [f s]\n\t(loop [remaining s acc {}]\n\t\t(if (empty? remaining) acc\n\t\t\t(recur (rest remaining)\n\t\t\t\t(let [k (f (first remaining))]\n\t\t\t\t\t(assoc acc k (concat (get acc k) (list (first remaining))))\n\t\t)\n\t)\n)))","user":"5409f8eae4b0addc1aec66e6"},{"code":"(fn [f xs]\n    (apply merge-with concat \n                (for [x xs]\n                    {(f x) [x]})))","problem":63,"user":"50b35486e4b03ea88043356a"},{"problem":63,"code":"(fn gb [f coll]\n  (reduce (fn [a v]\n    (assoc a (f v) (conj (get-in a [(f v)]) v))\n  ) {} (reverse coll) )\n)","user":"5ac92dc3e4b0e27600da77bf"},{"code":"(fn [f coll] (loop [c coll r {}] (if (empty? c) r\n  \t\t\t\t    (recur (rest c) (update-in r [(f (first c))] #(conj (vec %)  (first c)))))))","problem":63,"user":"4ea4e98a535d7eef308072ce"},{"problem":63,"code":"(fn [f s] \n  (reduce (fn [m a]\n            (let [b (f a) c (get m b []) ]\n              (conj m [b (conj c a)])))\n          {} s))","user":"5457e5f1e4b01be26fd74613"},{"problem":63,"code":"(fn [f l] (apply merge-with into (map #(do {(f %) [%]}) l)))","user":"59adec09e4b0e1f4e384c897"},{"problem":63,"code":"(fn my-group-by \n  ([f col] (my-group-by f col {}))\n  ([f col newCol]\n   (cond\n     (= (count col) 0) newCol\n     :else (let [k (f (first col)) v (first col)] \n            (println col newCol k v)\n            (cond \n              (nil? (get newCol k)) (my-group-by f (rest col) (assoc newCol k [v]))\n              :else (my-group-by f (rest col) (assoc newCol k (conj (get newCol k) v))))))))","user":"6065755ee4b069485764ddcc"},{"problem":63,"code":"#(apply merge (map (fn [x y] (assoc {} (first y) x)) (partition-by %1 (sort %2)) (partition-by identity (sort (map %1 %2)))))","user":"607d6bc1e4b03d835a6eaecc"},{"problem":63,"code":"(fn [f coll] (reduce (fn [m x] (assoc m (f x) (conj (m (f x) []) x))) {} coll))","user":"54bad522e4b0ed20f4ff6eb8"},{"code":"(fn [f s]                                                                                                                                                             \n  (reduce into \n    (map #(hash-map % \n                    (filter (fn [i] (= % (f i))) s)) \n       (distinct (map f s)))))","problem":63,"user":"4e49badd535dc968683fc4c9"},{"problem":63,"code":"(fn my-group [f s] (apply merge-with concat {} (map #(hash-map (f %) [%]) s)))","user":"57b99d48e4b0fbc9809a27f2"},{"problem":63,"code":"#(persistent! (reduce (fn [ret x] (let [k (%1 x)] (assoc! ret k (conj (get ret k []) x)))) (transient {}) %2))","user":"569c40cee4b0542e1f8d1462"},{"code":"(fn [f s]\n  (reduce (fn [m i] \n            (if (m (f i))\n               (assoc m (f i) (conj (m (f i)) i))\n               (assoc m (f i) [i]))\n\n) {} s))","problem":63,"user":"4f1d1299535d64f603146487"},{"problem":63,"code":"(fn [func input]\n       (loop [result {}\n              remaining input]\n          (if (empty? remaining)\n           result\n           (let [val (func (first remaining))]\n             (recur (if (contains? result val)\n                      (update-in result [val] #(conj % (first remaining)))\n                      (assoc result val [(first remaining)] ))\n                    (rest remaining))))))","user":"5654cb2de4b0f9d632dd848b"},{"problem":63,"code":"(fn fu [f v] (let [m (if (> (count v) 1) (fu f (rest v)) {})] (if (nil? (get m (f (first v))))\n                                                                           (assoc m (f (first v)) [(first v)])\n                                                                           (assoc m (f (first v)) (cons (first v) (get m (f (first v)))))\n                                                                           )))","user":"4e5e9f6b535d8a8b8723a2d2"},{"code":"#(\n  reduce\n  (fn [a e] (let [k (%1 e)] \n    (assoc a k (conj (get a k []) e))\n  ))\n  {}\n  %2\n)","problem":63,"user":"4f1595da535d64f603146444"},{"code":"(letfn [(conj-in\n         [f coll v]\n         (update-in coll [(f v)]\n                    (fnil #(conj % v) [])))]\n    \n  (fn group-with [f coll]\n    (reduce (partial conj-in f)\n            {} coll)))","problem":63,"user":"532ab0bde4b09d4e7a9b5527"},{"code":"(fn [f coll]\n  (reduce #(merge-with concat % {(f %2) [%2]}) {} coll))","problem":63,"user":"51c8301ee4b07ef393169e4d"},{"code":"(fn [f s] (reduce (fn [a [k v]] (assoc a k (conj (a k []) v))) {} (map vector (map f s) s)))","problem":63,"user":"530bf87ee4b02e82168697d5"},{"code":"(fn [f v]\n  (apply merge-with concat\n\t(map\n     (fn[x] {(f x) [x]}) v)))","problem":63,"user":"52f818a6e4b047fd55836fcc"},{"code":"(fn [f coll]\r\n  (   reduce (fn [x y]\r\n               (assoc x (f y) (conj   (get x (f y) [])y))) {}  coll ))","problem":63,"user":"4fb23582e4b081705acca28a"},{"code":"(fn [f s]\n    (apply hash-map\n           (mapcat (fn [k] [k (apply vector (filter (fn [v] (= (f v) k)) s))])\n                   (distinct (map f s))))\n    )","problem":63,"user":"513bb7a6e4b04402f587b77d"},{"problem":63,"code":"(fn [f sq] (apply merge-with concat (map #(hash-map (f %) [%]) sq)))","user":"562326cbe4b03f08ee9a9230"},{"code":"(fn [f c] (reduce #(assoc % (f %2) (conj (vec (% (f %2))) %2)) {} c))","problem":63,"user":"51e38568e4b0c611d6113e43"},{"problem":63,"code":"(fn [f s]\n  (let [vals (map vec (partition-by f (sort-by f s)))\n        res (map #(f (first %)) vals)] \n    (zipmap res vals)))","user":"5c748bf5e4b0fca0c16227cb"},{"code":"(fn [f s] (reduce (fn [m v]\n                    (update-in m [(f v)] (fnil conj []) v))\n                  {}\n                  s))","problem":63,"user":"52a1acb2e4b04e0c58e87bdb"},{"code":"(fn gas [f s]\n  (letfn [(inner [res current-item rest-items]\n                 (if (nil? current-item)\n                   res\n                   (let [current-key (f current-item)\n                         current-values (get res current-key)]\n                     (if (nil? current-values)\n                       (inner (assoc res current-key [current-item]) (first rest-items) (rest rest-items))\n                       (inner (assoc res current-key (conj current-values current-item)) (first rest-items) (rest rest-items))))))]\n    (inner {} (first s) (rest s))))","problem":63,"user":"52d7b0ade4b09f7907dd137c"},{"problem":63,"code":"(fn\n  [f coll]\n  (reduce (fn [acc x]\n            (let [res (f x)]\n              (if (nil? (acc res))\n                (assoc acc res [x])\n                (assoc acc res (conj (acc res) x)))))\n   {}\n   coll))","user":"526e1bd0e4b03e8d9a4a730b"},{"problem":63,"code":"(fn my-group-by\n  [f coll]\n  (let [xs (map (fn [x] [(f x) x]) coll)]\n    (reduce (fn [acc [k v]]\n                 (if (seq (acc k))\n                   (update-in acc [k] #(conj % v))\n                   (assoc acc k [v])))\n               {}\n               xs)))","user":"4ea5ba92535d7eef308072d9"},{"code":"(fn [f c] (apply conj {} (for [i (map f c)] [i (vec (filter #(= i (f %)) c))] )))","problem":63,"user":"4e9b22e2535dbda64a6f6b74"},{"problem":63,"code":"(fn [f coll]\n  (->> (map #(hash-map (f %) [%]) coll)\n       (reduce #(merge-with concat %1 %2))))","user":"5297dcc5e4b02ebb4ef75047"},{"problem":63,"code":";;(map  (fn [x] [(> x 5) x]) [1 3 6 8])\n;;(partition-by first '([false 1] [false 3] [true 6] [true 8])) ;; gives (([false 1] [false 3]) ([true 6] [true 8]))\n;;partition-by is not going to work since second case produces two sub-arrays with 1/2\n(fn [f coll]\n   (reduce #(merge-with concat %1 %2) (map #(apply hash-map %) (map (fn [x] [(f x) [x]]) coll)))\n  )","user":"58eed4c5e4b056aecfd47db7"},{"code":"(fn grp-by\r\n  ([f s] (grp-by f s {}))\r\n  ([f [x & s] m]\r\n   (if x\r\n     (let [k (f x)]\r\n       (if (contains? m k)\r\n         (recur f s (assoc m k (conj (m k) x)))\r\n         (recur f s (assoc m k [x]))))\r\n     m)))","problem":63,"user":"500159b3e4b0678c553fc419"},{"problem":63,"code":"(fn [f xs] \n  (reduce (fn [acc b]\n            (let [c (f b)\n                  b-ent (get acc c [])\n                  new-ent (conj b-ent b)]\n              (assoc acc c new-ent)))\n          {}\n          xs))","user":"57f9011ee4b0d3187e900935"},{"code":"(fn my-group-by [f s]\n   (reduce #(update-in %1 [(f %2)] (fn [vec item] (if (nil? vec) [item] (conj vec item))) %2) {} s))","problem":63,"user":"4e89f46c535d3e98b8023288"},{"code":"(fn [f s]\n    (reduce\n        (fn [x y]\n            (let [k (f y)]\n              (assoc (dissoc x k) k (conj (get x k []) y))))\n        {} s))","problem":63,"user":"536f5900e4b0fc7073fd6e7b"},{"code":"(fn g [f xs]\n  (reduce (fn [s x]\n      (let [k (f x)\n            ss (get s k [])\n            ]\n        (assoc s k (conj ss x))\n      )\n    ) {} xs)\n)","problem":63,"user":"504f191ae4b0e7ad84dbc4ba"},{"code":"(fn gb [f coll]\n  (apply hash-map\n         (mapcat\n          #(vector (f (first %)) %)\n          (partition-by f (sort-by f coll)))))","problem":63,"user":"511f88eee4b085952a83535f"},{"problem":63,"code":"(fn my-group-by\n  [f s]\n  (loop [m {}\n         s s]\n    (if (empty? s)\n      m\n      (recur (assoc m (f (first s)) (conj (or (m (f (first s))) []) (first s))) (rest s)))))","user":"572db6d5e4b0cd1946bd0f78"},{"problem":63,"code":"(fn [f, coll]\n    (apply merge-with into (map #(let [k (f %)] {k [%]}) coll)))","user":"5eb4927fe4b00a66d4a95221"},{"code":"#(apply merge-with into (map (fn [x] {(% x) [x]}) %2))","problem":63,"user":"4e8612f8535db62dc21a62f2"},{"problem":63,"code":"(fn [f xs]\n  (reduce (fn [acc v] \n            (assoc acc \n                   (f v) \n                   (conj (vec (acc (f v))) v))) \n          {} xs))","user":"54dce62be4b024c67c0cf78b"},{"problem":63,"code":"(fn [f s] (reduce #(let [k (f %2)]\n                        (if (nil? (%1 k))\n                            (assoc %1 k [%2])\n                            (assoc %1 k (conj (%1 k) %2)))) {} s))","user":"548f5086e4b0e286459a1239"},{"problem":63,"code":"(fn [x y] (zipmap (distinct (map x y)) (partition-by x (sort y))))","user":"58b80ec1e4b0ebc645576d89"},{"problem":63,"code":"(fn my-group-by [f s]\n\t(reduce\n\t(fn [acc el]\n\t\t\t(let [key (f el)]\n\t\t\t\t\t (assoc acc key (conj (get acc key []) el))))\n\t{}\n\ts))","user":"54ff6084e4b07d26eda61d50"},{"problem":63,"code":"(fn [x, y] (apply merge-with concat\n        (map (fn [item]\n               (hash-map (x item) [item]))\n             y)))","user":"59e62655e4b08badc2a0c568"},{"code":"(fn [f s]\n  (apply\n   (partial merge-with concat)\n   (map #(hash-map (f %) [ %]) s)))","problem":63,"user":"4ddb696b535d02782fcbe9fa"},{"problem":63,"code":"(fn g\n  [f [x & xs]]\n  (if x (merge-with concat {(f x) [x]} (g f xs))))","user":"51b76227e4b0d906fcd71d35"},{"problem":63,"code":"(fn [f s]\n  (reduce (fn [result value]\n            (let [applied (f value), current (get result applied)]\n              (assoc result applied (vec (conj current value)))))\n          {}\n          s))","user":"55868660e4b059ccff29b1d4"},{"problem":63,"code":"(fn [f col] \n  (loop [item    (first col) \n         col     (rest col) \n         res-set {} ]\n  (if (empty? col)\n    (let [res (f item)]\n           (if (contains? res-set res)\n             (assoc res-set res (conj (res-set res) item)) \n             (assoc res-set res [item])\n             ))\n   (recur (first col) \n         (rest col) \n         (let [res (f item)]\n           (if (contains? res-set res)\n             (assoc res-set res (conj (res-set res) item)) \n             (assoc res-set res [item])\n             ))))))","user":"5367bc60e4b0243289761e81"},{"problem":63,"code":"(fn \n[f v]\n  (loop [i 0 m {}]\n    (if (== i (count v))\n      m\n      (recur (inc i) (assoc m (f (v i)) (conj (vec (m (f (v i)))) (v i)))))\n)\n)","user":"5dd70ee3e4b0948ae9d9ad85"},{"code":"#(loop [ixs %2 rs {}] (if (empty? ixs) rs (recur (rest ixs) (if (contains? rs (%1 (first ixs))) (assoc rs (%1 (first ixs)) (conj (get rs (%1 (first ixs))) (first ixs))) (assoc rs (%1 (first ixs)) [(first ixs)])))))","problem":63,"user":"4f2942ace4b0d6649770a01e"},{"problem":63,"code":"(fn [f coll]\n            (reduce (fn [result x]\n                      (let [k (f x) v (get result k)]\n                        (assoc result k (if v \n                                          (vec (conj v x))\n                                          [x]))))\n                    {}\n                    coll))","user":"570bd29be4b0b0fb43fd06c5"},{"problem":63,"code":"#(reduce\n   (fn [m x]\n     (let [k (%1 x)]\n       (assoc m k (conj (or (m k) []) x))))\n   {}\n   %2)","user":"511688d5e4b0b3e208dba05a"},{"code":"(fn gb [f coll]\r\n  (if-let [[x & rcoll] (seq coll)]\r\n    (let [r (f x)]\r\n      (conj (gb f (remove #(= r (f %)) rcoll))\r\n            [r (cons x (filter #(= r (f %)) rcoll))]))\r\n    {}))","problem":63,"user":"4dfd4ba8535d04ed9115e781"},{"code":"#(loop [f %1 l %2 ans {}]\n  (if (empty? l)\n    ans\n    (recur\n      f\n      (rest l)\n      (let [k (f (first l)) x (first l)]\n        (if (contains? ans k)\n          (->>\n            (conj (get ans k) x)\n            (assoc ans k)\n          )\n          (assoc ans k [x])\n        )\n      )\n    )\n  )\n)","problem":63,"user":"51f09f3de4b0274c496158d7"},{"problem":63,"code":"(fn [f coll]\n  (reduce \n    (fn [groups val]\n        (let [group (f val)]\n          (assoc\n            groups\n            group\n            (conj (get groups group []) val))))\n    {} coll))","user":"5182de5ce4b0353c468deb74"},{"problem":63,"code":"(fn [f s]\n  (reduce (fn [r [k v]]\n            (assoc r k (conj (get r k []) v))) \n          {} \n          (map #(vector (f %) %) s)))","user":"594bc16be4b07ddc2dafae39"},{"code":"(fn [f coll]\n  (reduce \n    #(if \n      (%1 (first %2))\n      (conj %1 \n        [(first %2)\n         (conj\n           (%1 (first %2))\n           (second %2))])\n      (conj %1 [(first %2) [(second %2)]]))\n    {}\n    (map vector (map f coll) coll)))","problem":63,"user":"4fb2101ce4b081705acca284"},{"problem":63,"code":"(fn [f col]\n  (apply merge-with concat\n         (map #(assoc {} (f %) [%]) col)))","user":"5ccf99fbe4b0ccb0619628c8"},{"problem":63,"code":"(fn [f coll] (into {} (map #(vector  (f (first %))  (vec %)  )  (partition-by f (sort coll)) )))","user":"537b1083e4b06839e8705e64"},{"problem":63,"code":"(fn my-group-by\n  [f coll]\n  (loop [coll coll\n         groups {}]\n    (if (seq coll)\n      (recur (rest coll)\n             (update-in groups\n                        [(f (first coll))]\n                        (fn [v]\n                          (if v\n                            (conj v (first coll))\n                            [(first coll)]))))\n      groups)))","user":"56180d83e4b06b1bb2182a18"},{"problem":63,"code":"(fn [f s]\n  (reduce (fn [grouped item]\n            (merge-with concat grouped {(f item) [item]}))\n          {}\n          s))","user":"5424c523e4b01498b1a71b03"},{"problem":63,"code":"(fn [f s] (zipmap (distinct (map f s)) (partition-by f (sort-by f s))))","user":"53f3a4ace4b0742d9025b0f7"},{"code":"(fn [f s]\n  (reduce (fn [acc x] (update-in acc \n                       [(f x)]\n                       #(if (nil? %)\n                            [x]\n                            (conj % x))))\n          {}\n          s))","problem":63,"user":"4f1abbfb535d64f60314646e"},{"code":"(fn my-group-by [fx, sq]\n  (loop [sq sq, result {}]\n    (if (empty? sq)\n      result\n      (let [item (first sq), cur-key (fx item)]\n        (if (contains? result cur-key)\n          (recur (rest sq) \n                 (assoc result cur-key (conj (result cur-key) item)))\n          (recur (rest sq) (assoc result cur-key [item])))))))","problem":63,"user":"4f21838fe4b0d66497709fd2"},{"problem":63,"code":"(fn a\n  [f x]\n  (zipmap (distinct (map f x))\n          (partition-by f (sort x))))","user":"5a067f26e4b01bb0ae8afdcc"},{"code":"(fn group* [f coll]                                                                                                                                                                        \n  (into {}                                                                                                                                                                    \n        (map #(vector (f (first %)) (vec %))                                                                                                       \n             (partition-by f (sort coll)))))","problem":63,"user":"4e944706535dbda64a6f6b11"},{"problem":63,"code":"(fn [f s]  (reduce (fn [m [k v]] (let [h (get m k [])] (assoc m k (conj h v))))\n  \n            (cons {} (map vector (map f s) s))))","user":"5576e78de4b05c286339e075"},{"code":"(fn [f coll] \n\t(reduce #(let [h %1 k (f %2) v (conj (or (h k) []) %2)] (into h [[k  v]])) {} coll))","problem":63,"user":"52cdb7efe4b07d0d72b2737c"},{"code":"(fn groupby [f coll]\n  (loop [groups {}\n         s (seq coll)]\n    (if s\n      (let [x (first s)\n            y (f x)\n            xs (groups y [])]\n        (recur (assoc groups y (conj xs x)) (next s)))\n      groups)))","problem":63,"user":"539a2901e4b0b51d73faaf0f"},{"problem":63,"code":"(fn my-group-by\n  [f coll]\n  (reduce (fn [m item]\n            (let [k (f item)]\n              (assoc m k (conj (vec (m k)) item)))) {} coll))","user":"5d247902e4b02ea6f0fb6a24"},{"code":"(fn group-by-e\n  [f x]\n  (if (empty? x) {}\n    (let [v (f (first x))\n          this (filter #(= (f %) v) x)\n          that (filter #(not= (f %) v) x)]\n      (conj (group-by-e f that) (vector v this)))))","problem":63,"user":"52084f75e4b01ce6bbf31dde"},{"problem":63,"code":"(fn [f coll]\n  (reduce (fn [m x]\n            (let [r (f x)]\n              (assoc m r (conj (get m r []) x)))) {} coll))","user":"52cf1e25e4b07d0d72b2739c"},{"problem":63,"code":"(fn my-group-by [f coll]\n  (reduce #(update-in %1 [(f %2)] (fnil conj []) %2) \n          {} \n          coll))","user":"55f2e47de4b06e875b46ce4d"},{"problem":63,"code":"(fn [f s]\n  (reduce (fn [acc v]\n            \n            (let [k (f v)\n                  l (get acc k [])]\n              (assoc acc k (conj l v))\n              ))\n            {} s))","user":"5a66fddee4b0512ff01cd9d7"},{"problem":63,"code":"(fn [f elmts]\n  (loop [result {}\n         remains elmts]\n    (if (empty? remains)\n      result\n      (let [elmt (first remains)\n            elmt-key (f elmt)]\n        (recur (assoc result elmt-key (filter #(= elmt-key (f %)) remains)) (filter #(not= elmt-key (f %)) remains))))))","user":"52c1cc8be4b07a9af579236b"},{"problem":63,"code":"#(into {}\n       (for [k (set (map %1 %2))]\n         (vector k (vec (filter (fn [v] (= k (%1 v))) %2)))))","user":"5cbd5b42e4b026601754b9f6"},{"code":"(fn my-group-by [f colls]\n  (reduce (fn [maps x]\n            (let [y (f x)]\n              (assoc maps y (conj (get maps y [] ) x))))  {} colls))","problem":63,"user":"5273562ae4b03e8d9a4a7479"},{"problem":63,"code":"(fn [f s]\n  (loop [func f\n         s s\n         result {}]\n    (if (empty? s)\n      result\n      (let [current (first s)\n            remaining (rest s)\n            value (f current)\n            current-values (if (nil? (get result value))\n                             []\n                             (get result value))]\n        (recur f remaining (assoc result value (conj current-values current)))))))","user":"54b31445e4b09f271ff37d35"},{"problem":63,"code":"#(reduce (fn [a i]\n           (update-in a [(% i)] (fnil conj []) i))\n         {}\n         %2)","user":"510528a0e4b0730a5f55ad85"},{"problem":63,"code":"(fn f63 [f coll]\n  (apply merge-with concat\n    (for [c coll]\n     {(f c) [c]})))","user":"55634f38e4b0c656e3ff17e8"},{"code":"(fn groupby* [f xs] \n   (letfn [(addto [m k v]\n             (assoc m k (conj (get m k []) v)))]\n     (reduce (fn [a x] (addto a (f x) x)) {} xs)))","problem":63,"user":"534d1173e4b084c2834f4a98"},{"problem":63,"code":"(fn my-gr [f xs]\n  (let [vls (partition-by f (sort-by f xs))\n        kys (map f (map first vls))]\n    (zipmap kys vls)\n    ))","user":"560ae540e4b05f002753df0d"},{"problem":63,"code":"(fn [f coll]\n  (reduce (fn [ret x]\n            (let [v (f x)]\n              (assoc ret v (conj (get ret v []) x)))) \n          {} coll))","user":"58637221e4b0f14aab7c881d"},{"problem":63,"code":"#( loop [ [a & b] %2 res {} ] ( \n                                  \tif a\n                                  \t(let[ fa (%1 a) ] ( \n                                                      if ( contains? res fa )\n                                                      (recur b (conj res [ fa (conj (res fa) a)]))\n                                                      (recur b (conj res [fa [a]]))))\n                                  \tres\n                                  )\n)","user":"5b3aa98be4b02d533a91bbca"},{"problem":63,"code":"(fn [f coll]\n   (loop [ret {} coll coll]\n     (if (seq coll)\n       (let [v (first coll) \n             k (f v)\n             vs (ret k [])]\n         (recur (assoc ret k (conj vs v))\n                (next coll)))\n       ret)))","user":"5370d152e4b0fc7073fd6e9d"},{"problem":63,"code":"(fn [f s]\n  (loop [li s le {}]\n    (if (empty? li)\n      le\n      (recur (rest li)\n             (if (contains? le (f (first li)))\n               (conj le [(f (first li)) (conj (le (f (first li))) (first li))])\n               (conj le [(f (first li)) [(first li)]]))))))","user":"52979551e4b02ebb4ef75043"},{"code":"(fn [f c] \n  (reduce \n   (fn [p q]\n     (let [r (f q)]\n       (if (contains? p r)\n         (into p {r (conj (p r) q)})\n         (into p {r [q]}))))\n   {}\n   c))","problem":63,"user":"52046600e4b0c283853240c5"},{"problem":63,"code":"(fn make-map2\n  ([fx vs vystup]\n   (let [kl (map fx vs)]\n     (if (empty? kl)\n       vystup\n       (make-map2 fx\n                  (rest vs)\n                  (assoc vystup\n                         (first kl)\n                         (conj (vec (get vystup (first kl))) (first vs)))))))\n  ([fx vs]\n   (let [kl (map fx vs)\n         vystup {}]\n     (if (empty? kl)\n       vystup\n       (make-map2 fx\n                  (rest vs)\n                  (assoc vystup\n                         (first kl)\n                         (conj (vec (get vystup (first kl))) (first vs))))))))","user":"5684e200e4b04eec3ec5cfc4"},{"code":"(fn groupBy [f x] (apply merge-with concat (map #(hash-map (f %) (conj '() %)) x)))","problem":63,"user":"4f03bf5e535dcb61093f6b5d"},{"code":"(fn [f xs]\n    (loop [r {}\n           x xs]\n      (if (empty? x)\n        r\n        (let [v (get r (f (first x)) [])\n              k (f (first x))]\n          (recur (assoc r k (conj v (first x))) (next x))))))","problem":63,"user":"50aedb8ce4b0a40c9cfb08d4"},{"code":"(fn [f,s] \n  (apply merge-with concat (map #(hash-map (f %1) [%1]) s) ))","problem":63,"user":"5142e808e4b0c172af7558c9"},{"problem":63,"code":"(fn [f data]\n  (persistent!\n    (reduce\n      (fn [ret x]\n        (let [k (f x)]\n          (assoc! ret k (conj (get ret k []) x))))\n      (transient {}) data)))","user":"58b18ba0e4b0ebc645576cfa"},{"code":"(fn [f inputs]\r\n  (\r\n\t\tapply merge-with concat (map #(hash-map (f %) [%]) inputs)\r\n\t)\r\n)","problem":63,"user":"50182f53e4b02f523d7cc5ec"},{"problem":63,"code":"#(reduce \n  (fn [y x] \n    (assoc y  (% x) (into (y (% x)) [x]))) \n    {} \n    (reverse %2))","user":"50d0d2dde4b00b15ecee9768"},{"problem":63,"code":"(fn [f coll]\n  (reduce\n   #(update-in %1 [(f %2)] conj %2)\n   {}\n   (reverse coll)))","user":"56098ccbe4b0053d1b86c7e4"},{"code":"#(reduce (fn [a i] (update-in a [(%1 i)] (fnil conj []) i)) {} %2)","problem":63,"user":"4ea5e32a535d7eef308072de"},{"code":"(fn groupit [f s]\n  (reduce #(merge-with concat % %2) (map #(array-map (f %) (vector %)) s)))","problem":63,"user":"4ea0c284535d7eef308072ad"},{"problem":63,"code":"(fn [f s]\n  (apply merge-with into (map #(hash-map (first %) (vec (rest %))) (mapcat #(assoc {} (f %) %) s))))","user":"5a512929e4b05d388ecb6be2"},{"problem":63,"code":"(fn [f l] \n  (reduce (fn[m e] \n              (let [v (f e)]\n                (if (nil? (m v))\n                     (assoc m v (vector e))\n                     (assoc m v (conj (m v) e))\n                )\n           )) {} l)  \n)","user":"55eeb37ae4b0121d4835fdf3"},{"code":"(fn gsr [f s] (if (empty? s) {} \n                 (let [first-value (first s)\n                       rest-values (rest s)\n                      rest-gsr (gsr f rest-values)\n                       apply-f (f first-value)\n                       current-V (rest-gsr apply-f [])\n                       new-V (cons first-value current-V)\n                       new-Map (assoc rest-gsr apply-f new-V)\n                       ]\n                   new-Map\n                        )))","problem":63,"user":"50956c2be4b087f34d351ab2"},{"problem":63,"code":"(fn [group iter]\n  (-> (fn reduce-iter [hash elem]\n        (let [key (group elem)\n              cur-list (hash key [])\n              new-list (conj cur-list elem)]\n          (assoc hash key new-list))\n        )\n      (reduce {} iter)\n   ))","user":"5412ef7ee4b01498b1a719da"},{"problem":63,"code":"(fn [f s]\n  (reduce (fn [ret item]\n            (let [newkey (f item)]\n              (assoc ret newkey (conj (or (ret newkey) []) item))))\n          {}\n          s))","user":"5a42dbabe4b0447ef91cc5fc"},{"code":"(fn [f cl]\n  (reduce \n    #(assoc %1 (f %2) (conj (get %1 (f %2) []) %2))\n  {} cl)\n)","problem":63,"user":"51db9e1ee4b0e067a9bbadc9"},{"code":"#(reduce \n  (fn [m v] \n    (assoc \n      m \n      (% v) \n      (conj \n        (get m (% v) []) \n        v\n       )\n     )\n   ) \n  {}\n   %2)","problem":63,"user":"5281a445e4b0757a1b17143a"},{"problem":63,"code":"(fn\n  [f c]\n  (let [keys (seq (set (map f c)))\n        vals (map (fn [key] (filter #(= key (f %)) c)) keys)]\n        (zipmap keys vals)))","user":"51bf0ccee4b013aa0d74b811"},{"problem":63,"code":"(fn [f args]\n  (reduce #(assoc % (f %2) (conj (% (f %2) []) %2)) {} args))","user":"5a6af090e4b0512ff01cda2d"},{"problem":63,"code":"(fn [f s]\n  (let [comb\n        (fn [keys vals]\n          (loop [k keys v vals m {}]\n            (if (seq k)\n              (recur\n               (next k)\n               (next v)\n               (assoc m (first k) (concat (m (first k)) [(first v)])))\n              m\n              )))]\n    (comb (map f s) s)))","user":"5a342188e4b0ddc586f153bd"},{"code":"(fn [f x]\n  (into {}\n    (map #(vector (f (first %)) (vec %))\n      (partition-by f (sort x)))))","problem":63,"user":"522eb5cce4b01cdb292c5f0c"},{"code":"(fn group-seq [f col]\n  (reduce #(assoc %1 (f %2) (conj (apply vector (%1 (f %2))) %2)) {} col))","problem":63,"user":"4ddb339c535d02782fcbe9f9"},{"problem":63,"code":"(fn [f m]\n  ( ->> (map ( (fn [f] \n                 (fn [x] (vector (f x) x ))) f) m)\n         (reduce (fn reducf [x y]\n           (let [z (x (first y))]\n              (if (= nil z) (assoc x (first y) (vector (second y)))\n                (let [w (conj z (second y))]\n                  (assoc x (first y) w))))) {})))","user":"56fa8984e4b07572ad1a88c1"},{"problem":63,"code":"(fn [fun s]\n  (loop [xs s res {}]\n    (if (empty? xs) res\n      (let [so-far (res (fun (first xs)))]\n        (if (nil? so-far)\n          (recur (rest xs) (conj res [(fun (first xs)) (vector (first xs))]))\n          (recur (rest xs) (conj res [(fun (first xs)) (conj so-far (first xs))])))))))","user":"5885cc62e4b0f1effa3b76c1"},{"problem":63,"code":"(fn [func x]\n  (reduce (fn [accum y]\n            (let [result (func y)]\n              (assoc accum result (conj (get accum result []) y))))\n          {} x))","user":"525cc912e4b0cb4875a45d48"},{"problem":63,"code":"(fn [f v]\n  (reduce \n   \t(fn [acc x] \n      (let [fx (f x)]\n        (assoc acc fx (conj (get acc fx []) x))\n      )\n    )\n   \t{}\n   \tv\n  )\n)","user":"55dd7f72e4b050e68259b3c4"},{"code":"(fn [f coll]\n  (reduce\n    (fn [a b]\n      (conj\n        a\n        (vector\n          b\n          (filter #(= (f %) b) coll))))\n    {}\n    (reduce\n      conj\n      #{}\n      (map f coll))))","problem":63,"user":"4f253a49e4b0d66497709ff3"},{"problem":63,"code":"(fn my-group-by3 [f s]\n  (reduce #(merge-with concat %1 {(f %2) [%2]}) {} s))","user":"54e3df6ae4b024c67c0cf7e3"},{"problem":63,"code":"(fn [f coll] \n  (reduce (fn [m x] \n            (assoc m (f x) \n              (if-let [v (m (f x))]\n                (conj v x)\n                [x])))                \n            {} coll))","user":"56c4f43ce4b05cc29241ee9c"},{"problem":63,"code":"(fn mygroup\n  [f s]\n  (loop [rem-s s\n         m {}]\n    (if (seq rem-s)\n      (recur (rest rem-s) \n             (update-in m \n                        [(f (first rem-s))] \n                        #(if (nil? %1) \n                           [(first rem-s)] \n                           (conj %1 (first rem-s)))))\n      m)))","user":"5ce6f93be4b0a17bb84e2b99"},{"problem":63,"code":"(fn\n  [f args]\n  (loop [args args m {}]\n    (if-not (empty? args)\n      (if (= (get m (f (first args))) nil)\n        (recur (rest args) (assoc-in m (vector (f (first args))) (vector (first args))))\n        (recur (rest args) (assoc m (f (first args)) (conj (get m (f (first args))) (first args)))))\n      m)\n    ))","user":"5772ddb0e4b0979f896515d4"},{"problem":63,"code":"(fn [f coll] (apply merge-with concat (map #(into {} {(f %) [%]}) coll)))","user":"56cad309e4b0ea9b8538f720"},{"problem":63,"code":"(fn [f x] (apply merge-with into (map sorted-map (map f x) (map vector x))))","user":"51dd5d6fe4b0c33a4e1da406"},{"problem":63,"code":"(fn grp [f coll]\n  (loop [col coll\n         acc {}]\n    (if (empty? col)\n      acc\n      (recur (rest col) (merge-with into acc {(f (first col)) [(first col)]})))))","user":"5a426a3fe4b0447ef91cc5f2"},{"code":"(fn [f s]\n   (reduce (fn [h [k v]]\n             (assoc h k (conj (h k []) v))\n             )\n           {}\n           (map #(list %1 %2) (map f s) s))\n   )","problem":63,"user":"503ca47fe4b06c4e0e1fa24f"},{"problem":63,"code":"(fn [pred coll]\n  (loop [acc {} xs coll]\n    (if-let [x (first xs)]\n      (let [k (pred x)\n            v (acc k [])]\n        (recur (assoc acc k (conj v x)) (rest xs)))\n      acc)))","user":"57275898e4b0c5bde472c13e"},{"code":"(fn [f s] \n  (reduce (fn [m x]\n            (let [k (f x) v (m k [])]\n              (assoc m k (conj v x))))\n          {}\n          s))","problem":63,"user":"4f969214e4b0dcca54ed6cdd"},{"problem":63,"code":"(fn [f s]\n  (loop [m {}\n         v (first s)\n         s s]\n    (let [k (f v)\n          n (assoc m k (conj (m k []) v))]\n      (if (next s)\n        (recur n (fnext s) (rest s))\n        n))))","user":"54dd76c8e4b024c67c0cf794"},{"code":"(fn [f s]\n  (letfn [ (ff [k v acc]\n           (if (empty? k)\n             acc\n             (recur (rest k) (rest v) (assoc acc (first k) (concat (get acc (first k) []) [(first v)]))))\n           ) ]\n    (ff (map f s) s {}))\n)","problem":63,"user":"4dd1de4d535dae65d5c462d7"},{"problem":63,"code":"(fn [f ls]\n  (reduce #(merge % %2) \n          (set (map \n              (fn [x] \n                {(f x) (filter #(= (f x) (f %)) ls)})\n              ls))))","user":"541ef7e2e4b01498b1a71a92"},{"code":"#(reduce (fn [m e] (assoc m (% e) (conj (m (% e) []) e)))\n         {}\n         %2)","problem":63,"user":"4e7dd982535db169f9c796ee"},{"problem":63,"code":"(fn [f lis]\n  (reduce (fn[x y] (merge-with concat x y)) (map #(hash-map (f %) `[~%]) lis)))","user":"58384bc4e4b089d5ab817d27"},{"code":"(fn[f s]\r\n  (reduce #(merge-with concat % {(f %2) [%2]} )    \r\n              {} s))","problem":63,"user":"4deff9f9535d08e6dec9fe15"},{"code":"(fn my-groupby [f sq]\n  (reduce\n   (fn [accum val]\n     (let [key (f val)\n           grp (or (accum key) [])]\n       (assoc accum key (conj grp val))))\n   {} sq))","problem":63,"user":"50763574e4b0a894bb95bf3d"},{"problem":63,"code":"(fn [f s]\n  (reduce (fn [h e]\n            (let [k (f e) v (or (h k) [])]\n              (assoc h k (conj v e))))\n          {} s))","user":"53a739b0e4b0ef122a8689d0"},{"problem":63,"code":"(fn do-group-by [f s]\n  (reduce (fn [m i]\n            (assoc m\n              (f i)\n              (conj (m (f i) []) i)))\n          {}\n          s))","user":"534056fce4b085b17e897dac"},{"code":"#(apply merge-with into (for [x %2] {(% x) [x]} ))","problem":63,"user":"50ab8ae3e4b01d6eb43ce9a0"},{"code":"(fn [f seqn]\n  (loop [seqn seqn\n         resl {}]\n    (if (empty? seqn)\n      resl\n      (let [x   (first seqn),\n            f-x (f x)]\n        (recur (rest seqn)\n               (assoc resl f-x (conj (get resl f-x []) x)))))))","problem":63,"user":"53889587e4b0640c7a9a589e"},{"code":"(fn [f s] (reduce #(let [v (f %2)] (assoc % v (conj (% v []) %2))) {} s))","problem":63,"user":"4f6511eee4b07046d9f4ef3a"},{"problem":63,"code":"(fn [f v]\n  (reduce (fn [a b]\n            (cond (a (f b)) (conj a [(f b) (conj (a (f b)) b)])\n                  :else (conj a [(f b) [b]])\n                  ))\n          {} v))","user":"59c7c2cde4b0a024fb6ae54b"},{"code":"(fn [f s]\n  (loop [[h & t] s\n         d {}]\n    (if (nil? h)\n      d\n      (let [r (f h)]\n       (recur t (assoc d r (conj (d r []) h)))))))","problem":63,"user":"52d469c8e4b09f7907dd1330"},{"code":"(fn group-by1\n  [f coll]  \n  (persistent!\n   (reduce\n    (fn [ret x]\n      (let [k (f x)]\n        (assoc! ret k (conj (get ret k []) x))))\n    (transient {}) coll)))","problem":63,"user":"50ab44b2e4b0f65d68208509"},{"problem":63,"code":"(fn\n  [f s]\n  (loop [remaining s res {}]\n    (if (empty? remaining)\n      res\n    (if (nil? (res (f (first remaining))))\n      (recur (rest remaining) (assoc res (f (first remaining)) [(first remaining)]))\n      (recur (rest remaining) (assoc res (f (first remaining)) (concat (res (f (first remaining))) [(first remaining)])))))))","user":"54e0e911e4b024c67c0cf7bc"},{"problem":63,"code":"(fn groupy [f coll]\n\n    (reduce\n\n      (fn [acc-map x]\n        (let [y (f x)]\n        (if (contains? acc-map y)\n          ;(conj acc-map curr)\n          (assoc acc-map y (conj (get acc-map y) x))\n          (assoc acc-map y [x])) )\n      )\n      {} coll\n      )\n    )","user":"5535e822e4b09218d5f44fb2"},{"code":"(fn g[f s]\n  (reduce (fn [acc,item] \n            (let [key (f item)]\n             (if (nil? (find acc key)) \n               (assoc acc key [item]) \n               (update-in acc [key] conj item)                \n             )))  \n          {} \n          s))","problem":63,"user":"513f53c6e4b051389b345b40"},{"problem":63,"code":"(fn [f coll]\n  (reduce (fn [acc x] \n            (let [key (f x)\n                  val (acc key)] \n              (if (contains? acc key) \n                (conj acc [key (conj val x)])\n                (conj acc [key [x]]))))\n          {}\n          coll))","user":"5d97b602e4b0d3f9b434ad3a"},{"code":"(fn group_ [fun coll]\r\n  (loop [f fun,col coll,result {}]\r\n    (if (empty? col)\r\n         result\r\n        (let[val (first col),\r\n             answ (f val),\r\n             vals (get result answ [])]\r\n           (recur f (rest col) \r\n                  (assoc result answ (conj vals val) )) \r\n        )\r\n        )\r\n    )\r\n  )","problem":63,"user":"4f6d9d7ee4b07046d9f4efcd"},{"problem":63,"code":"(fn [f xs]\n  (reduce (fn [m x]\n            (let [k (f x)]\n              (assoc m k\n                (conj (get m k []) x))))\n          {} xs))","user":"5a95c639e4b0d174b936c75e"},{"code":"(fn [f s]\n  (letfn [(update-map\n  [f element m]\n  (let [k (f element)\n        current-value (get m k [])\n        new-value (vec (conj current-value element))]\n    (assoc m k new-value)))]\n    (loop [m {} l s]\n    (if (empty? l)\n      m\n      ( recur (update-map f (first l) m) (rest l))))))","problem":63,"user":"50b29029e4b03ea880433563"},{"problem":63,"code":"(fn [f xs]\n  ((fn [xs accum]\n    (if (empty? xs)\n        accum\n        (let [k (f (first xs))\n              v (first xs)]\n        (recur (rest xs) \n               (assoc accum k (vec (conj (get accum k) (first xs)))))))\n    ) xs {}))","user":"557af43ae4b05c286339e0a8"},{"problem":63,"code":"(fn [f s]\n  (let [red\n   (fn [r i]\n     (let [key (f i)\n           vals (conj (get r key []) i)]\n       (assoc r key vals)))]\n  (reduce red {} s)))","user":"5379306fe4b06839e8705e50"},{"code":"#(reduce (fn [m x] (assoc m (% x) (conj (get m (% x) []) x))) {} %2)","problem":63,"user":"4e5229dc535d302ef430da6f"},{"problem":63,"code":"(fn [f coll]\n  (reduce\n   (fn [m v]\n     (update-in m [(f v)] (fnil conj []) v))\n   {}\n   coll))","user":"5c1bee41e4b01240ff567218"},{"problem":63,"code":"(fn [f coll]\n  (reduce (fn [m v]\n            (let [k (f v)]\n              (assoc m k (if (contains? m k)\n                           (conj (get m k) v)\n                           [v]))))\n          {}\n          coll))","user":"575cbe44e4b02ea114799374"},{"problem":63,"code":"(fn [f coll]\n  (let [k (distinct (map f coll))\n        v (map #(filter (fn [e]\n                          (= (f e) %)) coll) k)]\n    (zipmap k v)))","user":"5512aca6e4b055c2f668d4b4"},{"problem":63,"code":"(fn [f vs]\n  (reduce #(let [k (f %2)]\n             (assoc\n              %1\n              k\n              (conj (get %1 k []) %2)))\n          {}\n          vs))","user":"4f037faf535dcb61093f6af8"},{"code":"#(zipmap (distinct (for [x %2 :let [f %1]] (f x))) (partition-by %1 (sort %2)))","problem":63,"user":"4ef5c7ce535dced4c769f248"},{"code":"(fn [f x] (apply merge-with concat (for [v (partition-by f x)] (hash-map (f (first v)) (vec v)))))","problem":63,"user":"4e5af45e535d8a8b8723a2b1"},{"problem":63,"code":"#(reduce (fn [x [y z]] (assoc x y (conj (get x y []) z))) {} (map (fn [x] [(%1 x) x]) %2))","user":"502ea967e4b06efe12e8cc76"},{"problem":63,"code":"(fn [f xs] (apply merge-with concat (map (fn [x] {(f x) [x]}) xs)))\n\n;(fn [f xs] \n;  (into {} (reduce \n;    (fn [res x] \n;      (let [key (f x) \n;            idx (first (keep-indexed #(if (= (first %2) key) %) res))]\n;        (if (nil? idx)\n;          (conj res (vector key [x]))\n;          (update-in res [idx 1] (fn [c] (conj c x)))\n;        )\n;      )) [] xs)))","user":"55150524e4b055c2f668d4d9"},{"code":"(fn[f a]\n(reduce\n\n(fn[hm li] \n(let [\tk  (first li)\n\tv  (hm k)\n\tv1 (nth li 1)\n\t]\n\t(if(nil? v) (assoc hm k [v1])\n\t\t(assoc hm k (conj v v1))\n\t)\n)\n)\n\n{}\n(map #(conj [(f %1)] %1) a))\n)","problem":63,"user":"50b25f2ce4b03ea88043355f"},{"problem":63,"code":"#(loop [func %1 seqen %2 res (sorted-map)] \n  (if \n    (empty? seqen)\n    res\n    (recur func \n           (rest seqen) \n           (conj res {(func (first seqen)) (conj (get res (func (first seqen)) []) (first seqen))}))))","user":"54f6f00fe4b01ecee9d88814"},{"code":"(fn [f s] (reduce (fn [acc x] (update-in acc [(f x)] #(conj (or % []) x))) {} s))","problem":63,"user":"52be58d7e4b07a9af579231d"},{"code":"(fn myfilt [f col] (reduce (fn[acc el](let [key (f el)] \n\t(assoc acc key (conj (get acc key (vector)) el  ))\n\t)) \n{} col))","problem":63,"user":"5307e4ece4b02e82168697a9"},{"code":"(fn [f xs]\n  (reduce\n    (fn [m a]\n      (let [r (f a)]\n        (assoc m r (conj (get m r []) a)))) {} xs))","problem":63,"user":"4f251302e4b0d66497709ff0"},{"problem":63,"code":"(fn myGroupBy5 [f coll] \n  (apply merge-with concat\n      (map #(hash-map (f %) [%]) coll)))","user":"50c6052ce4b0c9dc10d15c56"},{"code":"(fn [f coll]\n  (persistent!\n    (loop [result (transient {})\n           input coll\n           item (f (first input))]\n           (if (empty? input) result\n                (recur (assoc! result item \n                           (conj \n                              (get result item []) (first input)))\n                       (rest input)\n                       (if (empty? (rest input)) nil (f (second input))))))))","problem":63,"user":"4f38d6bbe4b0e243712b1ee2"},{"problem":63,"code":"(fn [f c] (apply merge-with #(into [] (concat %1 %2)) (for [x c] {(f x) [x]})))","user":"4fffa422e4b0678c553fc404"},{"problem":63,"code":"(fn [f sq]\n(into {} (map #(vector %1 (filter (fn [x] (= %1 (f x))) (into [] sq)))   (distinct  ( map f sq)))))","user":"581a5fdbe4b0e114eb51a002"},{"code":"(fn gb [f xs]\r\n  (if (seq xs)\r\n    (let [val (first xs)]\r\n  \t\t(merge-with concat {(f val) [val]} (gb f (rest xs))))))","problem":63,"user":"502873a8e4b01614d1633ff8"},{"problem":63,"code":"(fn [f coll]\n  (reduce #(let [k (f %2)]\n             (if (contains? % k)\n               (assoc % k (conj (% k) %2))\n               (assoc % k (conj [] %2)))) {} coll))","user":"54fdbe3fe4b07d26eda61d3b"},{"problem":63,"code":"(fn [func col] (reduce #(assoc %1 (func %2) (conj (get %1 (func %2) []) %2)) {} col))","user":"5c6e8b57e4b0fca0c1622755"},{"problem":63,"code":"(fn [f b]\n  (let [a (map (fn[a] {(f a) a}) b)]\n    (apply merge-with conj (concat (map (fn [a] {a []}) (set (map (comp first first) a))) a))))","user":"5628f33ce4b00e49c7cb47f3"},{"code":"(fn [f coll] \n    (reduce #(assoc %1 (f %2) (conj (get %1 (f %2) []) %2)) {} coll)\n  )","problem":63,"user":"514cfa27e4b019235f6c057d"},{"problem":63,"code":"(fn [f xs]\n  (reduce (fn [acc x]\n            (let [key (f x)]\n              (assoc acc key (conj (get acc key []) x)))) {} xs))","user":"51bd78c3e4b0ff155d51d2b0"},{"problem":63,"code":"(fn [f s]\n  (reduce (fn [acc v]\n            (let [k (f v)]\n              (assoc acc k (if (contains? acc k) \n                             (conj (acc k) v)\n                             [v]))))\n          {}\n          s))","user":"5339c105e4b0e30313ee6cae"},{"problem":63,"code":"(fn groupSeq [func s]  (apply merge-with concat (map #(assoc {} (func (first %)) %) (partition-by func s))))","user":"56427910e4b08d4f616f5f19"},{"problem":63,"code":"(fn [f s]\n  (apply merge-with concat \n              (map #(hash-map (f %) [%])\n                   s)))","user":"57c45e64e4b05aa3c4741ccf"},{"problem":63,"code":"(fn grp-by [f coll]\n  (apply merge-with into (map #(hash-map (f %) (vector %)) coll)))","user":"59503c5de4b066ee0a44ae8e"},{"problem":63,"code":"(fn gas [f coll]\n  (loop [m {}\n         xs coll]\n    (if (empty? xs)\n      m\n      (let [current (first xs)\n            key (f current)\n            old-value (or (m key) [])\n            new-value (conj old-value current)]\n          (recur\n           (assoc m key new-value)\n           (rest xs))))))","user":"5641296de4b08d4f616f5ef4"},{"problem":63,"code":"(fn function-63\n\n  [function1 seq1]\n\n  (loop [[f & r :as coll] seq1 rcoll {}]\n    (if (empty? coll)\n      rcoll\n      (recur\n        r\n        (assoc rcoll (function1 f)  (conj  (vec (get rcoll (function1 f))) f))))))","user":"598d0dc3e4b02b9968b84d18"},{"problem":63,"code":"(fn [f coll]\n  (reduce (fn [acc x] (update-in acc [(f x)] #(vec (conj % x)))) {} coll))","user":"5e860270e4b09a7a73c8bbdb"},{"code":"(fn aa [ff cc] ((fn group3 [f coll] (if (< 0 (count coll))\n                        (conj (group3 f (rest coll)) {(f (first coll)) ((fn my-conj [i j](if (nil? i)\n                                                                                            (vector j)\n                                                                                            (conj i j))) (get (group3 f (rest coll)) (f (first coll))) (first coll))}) {})) ff (reverse cc)))","problem":63,"user":"5296aa9be4b02ebb4ef75034"},{"problem":63,"code":"(fn [f coll] (reduce (fn [xs x] (let [k (f x)] (assoc xs k (conj (get xs k []) x)))) {} coll))","user":"580e7761e4b0849f6811b753"},{"problem":63,"code":"(fn [f s] (reduce (fn [m e] (let [k (f e)] (conj m [k (conj (m k []) e)]))) {} s))","user":"5abe2fc2e4b073f17744271e"},{"code":"(fn gb [f l]\r\n  (reduce (fn [x y]\r\n            (let [v (f y)]\r\n              (assoc x v (conj (x v []) y)))) {} l))","problem":63,"user":"4ff201d7e4b0678c553fc330"},{"problem":63,"code":"(fn [f coll]\n  (reduce \n   (fn [m v]\n     (let [r  (f v)\n           vs (get m r [])]\n       (assoc m r (conj vs v))))\n   {} coll))","user":"55d2dd27e4b0e31453f64a5b"},{"code":"(fn [f c] (reduce (fn [a x] (merge a {(f x) (conj (a (f x) []) x)})) {} c))","problem":63,"user":"4f614976e4b0defedf855fbb"},{"problem":63,"code":"(fn [f s]\n  (reduce (fn [m v] \n            (let [fresult (f v),\n                  values (get m fresult [])]\n              (assoc m fresult (conj values v)))) {} s))","user":"5c6e1006e4b0fca0c1622744"},{"code":"(fn [f coll]\n  (apply merge-with concat (for [i coll] {(f i) [i]})))","problem":63,"user":"51ca82e9e4b08b1cbd0d9488"},{"problem":63,"code":"(fn [f xs]\n  (reduce\n   (fn [m x]\n     (update-in\n      m\n      [(f x)]\n      #(if %\n         (conj % x)\n         [x])))\n   {}\n   xs))","user":"521d064fe4b0c4ef0be830a8"},{"code":"(fn [f coll] (apply merge-with concat (for [x coll] (hash-map (f x) [x]))))","problem":63,"user":"5244fa73e4b0d8acf9ed6acb"},{"problem":63,"code":"(fn [kfn coll]\n\t(reduce #(conj \n\t\t%1 [(kfn %2) (conj \n\t\t\t(%1 (kfn %2) []) %2)]) {} coll))","user":"56a01895e4b0542e1f8d149f"},{"code":"(fn [f s]\n  (reduce \n    #(let [k (f %2) e %2 m %1] \n      (assoc m k\n        (conj (get m k []) e))) {} s))","problem":63,"user":"4fcf642ee4b03432b189f410"},{"code":"(fn [f xs]\r\n  (let [pairs (map (fn [x] (list (f x) x)) xs)]\r\n    (reduce (fn [mm [k v]]\r\n              (assoc mm k (conj (get mm k []) v)))\r\n            {} pairs)))","problem":63,"user":"4ddc1c89535d02782fcbea01"},{"problem":63,"code":"(fn [f xs]\n  (loop [result {}\n    t_xs xs]\n    (if (empty? t_xs) result\n    (let [item (first t_xs)\n          f-val (f item)\n          f-val-matching-entries (conj (get result f-val []) item)]\n      (recur \n        (assoc result f-val f-val-matching-entries)\n        (rest t_xs))))))","user":"5c09e555e4b0bdcf453d16fd"},{"code":"#(loop [[x & xs] %2 res {}]\n\t(if (nil? x) res\n      \t(let [fx (%1 x)]\n\t\t\t(recur xs (assoc res fx (conj (get res fx []) x))))))","problem":63,"user":"53300924e4b019098a6f8b55"},{"problem":63,"code":"(fn [f coll]\n  (reduce \n    (fn [acc v]\n      (update-in \n        acc \n        [(f v)]\n        #(conj (vec %) v)))\n    {}\n    coll))","user":"5630ce72e4b0bfe05bf11786"},{"problem":63,"code":"(fn gb [f coll] (reduce #(merge-with into %1 {(f %2) (vector %2)}) {} coll))","user":"5888b75fe4b0f1effa3b771b"},{"problem":63,"code":"(fn mygroupby [p s]\n  (reduce #(update-in %1 [(p %2)] conj %2) {} (reverse s)))","user":"60606490e4b03746e80ebf67"},{"problem":63,"code":"(fn gb [f coll]\n  (loop [n 0 c (count coll) r {}]\n    (if (= n c)\n      r\n      (let [v (nth coll n) k (f v)]\n        (if (r k)\n          (recur (inc n) c (assoc r k (conj (r k) v)))\n          (recur (inc n) c (assoc r k [v])))))))","user":"561a1af6e4b053970a773b02"},{"code":"#(loop [f %1 data %2 result {}]\n  (if(empty? data) \n    result\n    (recur f \n        (next data) \n        (merge-with \n          (fn [f s] (concat f s)) \n          result  \n          (assoc {} (f (first data)) [(first data)]))\n   ))\n  )","problem":63,"user":"4fe588b6e4b0e8f79898fec5"},{"problem":63,"code":"(fn [f s]\n   (reduce (fn [m [k v]] (assoc m k (conj (get m k []) v))) {} (map #(list (f %) %) s) ))","user":"561eb82fe4b064ca9f4b16c7"},{"code":";(fn [f xs] (reduce (fn [m x] (update-in m [(f x)] #(if % (conj % %2) [%2]) x)) {} xs))\n(fn [f xs] (reduce #(let [k (f %2) v (% k)] (assoc % k (if v (conj v %2) [%2]))) {} xs))","problem":63,"user":"51bd1a0de4b0df1216cefd93"},{"problem":63,"code":"(fn my-group-by [f col]\n  (loop [xs col\n         acc {}]\n    (let [n (first xs)]\n      (if (empty? xs)\n        acc\n        (recur (rest xs) (assoc acc (f n) (conj (vec (acc (f n))) n)))))))","user":"544257b4e4b032a45b869379"},{"problem":63,"code":"(fn [pred xs]\n  (loop [[x & xs] xs\n         pred pred\n         acc {}]\n    (if x\n      (recur xs pred (assoc acc (pred x) (conj (vec (acc (pred x))) x)))\n      acc)))","user":"5705f569e4b0b0fb43fd0677"},{"code":"(fn [f coll] (reduce (fn [m x] (update-in m [(f x)] #(vec (conj % x)))) {} coll ))","problem":63,"user":"4e31a15c535deb9a81d77f1e"},{"problem":63,"code":"(fn apply-fun [fun items]\n  (if (empty? items)\n    {}\n    (let [item-value (first items) \n          item-key (fun item-value)\n          result (apply-fun fun (rest items))]      \n      (assoc result item-key (cons item-value (get result item-key []))))))","user":"57d9bca1e4b0bd073c202405"},{"code":"(fn gp [fun xs]\n  (let [fun-vals (distinct (map fun xs))]\n    (let [x-vals (map (fn [fun-val]\n                        (filter (fn [x] (= (fun x) fun-val))\n                   \t\t\t\txs))\n                  fun-vals)]\n      (zipmap fun-vals x-vals))))","problem":63,"user":"529e3a4fe4b04e0c58e87b92"},{"code":"(fn [f xs]\n  (reduce (fn [m v]\n            (let [k (f v)]\n              (assoc m k (conj (get m k []) v))))\n          {} xs))","problem":63,"user":"5370f8ede4b0fc7073fd6ea2"},{"problem":63,"code":"(fn [f xs]\n  (let [r (fn [c v]\n            (let [k (f v)] (assoc c k (vec (conj (c k) v)))))]\n    (reduce r {} xs)))","user":"563ed73ae4b08d4f616f5ecb"},{"code":"(fn [f coll]\n  (reduce #(update-in %1 [(f %2)] conj %2)\n          {}\n          (reverse coll)))","problem":63,"user":"535d4b0ae4b04ce2eb3ed2be"},{"problem":63,"code":"(fn [f s]\n  (reduce #(assoc %1 (f %2) (concat (%1 (f %2)) (list %2))) {} s))","user":"540f09b9e4b0addc1aec6725"},{"problem":63,"code":"(fn [func xs]\n  (into {} (map #(vector (func (first % )) (vec %))\n             \t(partition-by func (sort xs)))))","user":"5b62ff3ce4b0c6492753e72a"},{"code":"#(reduce\n  (fn [m e]\n    (assoc m (%1 e) (conj (m (%1 e) []) e))) {} %2)","problem":63,"user":"4e7e93f5535db169f9c7971a"},{"problem":63,"code":"(fn group-bye [f sq] (reduce (fn [acc e] (\n                                          let [ky (f e) vl (conj (or (acc ky) []) e)]\n                                          (conj acc [ky vl])\n                                          )) {} sq))","user":"4eadc217535d7eef30807321"},{"problem":63,"code":"(fn [f lst]\n  (reduce (fn [acc v]\n    (let [res (f v)]\n      (assoc acc res (conj (or (acc res) []) v)))) {} lst))","user":"58b51e05e4b0ebc645576d4c"},{"problem":63,"code":"(fn [f s]\n   (reduce merge (map #(assoc {} (key %) (vec (val %))) (reduce #(merge-with concat %1 %2) \n                                                                (map #(hash-map (f %1) [%1])\n                                                                     s)))))","user":"55f8b32ae4b03cbcff9738ba"},{"code":"(fn [f s]\n  (reduce (fn [c x]\n            (if (contains? c (f x))\n              (assoc c (f x) (conj (get c (f x)) x))\n              (assoc c (f x) [x]) ))\n          {}\n          s))","problem":63,"user":"50608ea0e4b07251188e4456"},{"problem":63,"code":";; initial approach: (fn[f s] (reduce #(assoc % (f %2) (vec (conj (get % (f %2)) %2))) {} s))\n; shorter, seen in one of the other solutions: \n#(apply merge-with into (for [v %2] {(% v) [v]}))","user":"54ad9d76e4b09f271ff37ce6"},{"problem":63,"code":"#(reduce (fn [acc x]\n          (let [k (% x)]\n            (assoc acc k (conj (get acc k []) x))))\n        {} %2)","user":"5508a292e4b06e50f9beb10f"},{"problem":63,"code":"(fn my-group-by\n  ([f coll]\n   (reduce (fn [result current]\n             (let [key (f current)]\n               (assoc result\n                      key\n                      (conj (or (get result key) []) current))))\n           {}\n           coll)))","user":"52ea025ae4b09f7907dd14b5"},{"code":"#(apply merge-with concat\n   (map (fn [a] {(% a) (list a)}) %2))","problem":63,"user":"4f91a38ae4b0dcca54ed6c9f"},{"code":"(fn [f coll]\n  (reduce (fn [acc n]\n            (let [result (f n)]\n              (assoc acc result (conj (get acc result []) n))))\n          {}\n          coll))","problem":63,"user":"5080a697e4b01a93d3f38e49"},{"problem":63,"code":"(fn my-group-by [f s]\n   (loop [remain s, result {}]\n     (if (empty? remain)\n       result\n       (let [fs (first remain), k (f fs), v (result k)]\n         (recur (rest remain) (conj result [k (if v (conj v fs) [fs])]))))))\n\n;(fn [f s]\n;  (apply merge-with concat (map #(hash-map (f %1) [%1]) s)))","user":"567e418fe4b0feffd0d18eb1"},{"code":"(fn [f s]\n (reduce (fn [acc x] \n           \n           (cond \n            (acc (f x)) (assoc acc (f x) (conj  (acc (f x)) x))\n            :else       (assoc acc (f x) [x] )            \n           )\n           \n          ) \n          {} \n          s\n )\n)","problem":63,"user":"4fb03cf4e4b081705acca262"},{"code":"(fn gp-by [f coll]\n  (let [m (apply merge-with concat (for [v coll] {(f v) [v]}))]\n    (zipmap (keys m) (map vec (vals m)))))","problem":63,"user":"50366589e4b0fbe0a74d26c3"},{"problem":63,"code":"(fn [f coll](\n              apply merge-with concat (map #(hash-map (f %) [%]) coll)\n              ))","user":"546280d8e4b01be26fd746b0"},{"problem":63,"code":"(fn [f s] (let [ks (set (map f s))] (apply hash-map (apply concat (for [k ks] [k (apply vector (filter #(= (f %) k) s))] )))))","user":"55b0f5bfe4b002ce9d5cbc28"},{"code":"(fn [pred s]\n          (->> s\n               (map (fn [x] {(pred x) [x]}))\n               (apply (partial merge-with concat))))","problem":63,"user":"52c4fe42e4b0c2d177d620e9"},{"problem":63,"code":"(fn [f s]\n  (let [tmp (interleave (map f s) (map vector s))]\n    (->> tmp (partition 2) (map #(apply hash-map %))\n         (apply merge-with (comp vec concat)))))","user":"55ac07afe4b03311e7b7328f"},{"problem":63,"code":"(fn gpby\n  [f coll]\n  (apply merge-with concat (map #(assoc {}  (f %) [%]) coll)))","user":"5609d328e4b05f002753deee"},{"problem":63,"code":"(fn doo [foo seqs]\n    (loop [foo foo \n           seqs seqs\n           res {}]\n        (println res)\n        (if-let [valss (first seqs)]\n        (let [temp (foo valss) ]\n            (cond \n                (empty? seqs) \n                    res\n                (nil? (get res temp) )\n                    \n                    (recur foo (rest seqs) (assoc res temp (vector valss ) ))\n                :else \n                    (recur foo (rest seqs) (assoc res temp (conj (get res temp) valss ) ) )\n             \n            )\n        )\n        res\n    )\n))","user":"6038b6b4e4b0d5df2af222ef"},{"code":"(fn [fun coll]\n   (apply merge-with concat (for [x coll] {(fun x) [x] }))\n)","problem":63,"user":"51227a00e4b068a9582e656b"},{"problem":63,"code":"(fn [f col]\n  (reduce #(assoc %1 (f %2) (concat (%1 (f %2)) (list %2)) ) {} col)\n)","user":"5bbd13a5e4b07a9b28b0ff95"},{"problem":63,"code":"(fn [f s] (reduce #(assoc %1 (f %2) (vec (conj (get %1 (f %2)) %2))) {} s))","user":"54e7425ee4b024c67c0cf810"},{"code":"(fn groupby\n  [f coll]  \n  (persistent!\n   (reduce\n    (fn [ret x]\n      (let [k (f x)]\n        (assoc! ret k (conj (get ret k []) x))))\n    (transient {}) coll)))","problem":63,"user":"5272d4b7e4b03e8d9a4a7453"},{"code":"(fn [f seq]\n    (loop [acc {} tail seq]\n        (cond (empty? tail) acc\n              :else         (let [fx (-> tail first f)] (recur (assoc acc fx (conj (get acc fx []) (first tail))) (rest tail))))))","problem":63,"user":"4f4ac35ae4b0d56e7bb92c18"},{"code":"(fn [f s]\n  (->> (map f s)\n       (map (comp reverse list) (map list s) ,,,)\n       (map (partial apply hash-map) ,,,)\n       (reduce (partial merge-with concat) {} ,,,)))","problem":63,"user":"50e4b066e4b0cb9ec68fbca6"},{"problem":63,"code":"(fn\n  [f s]\n  (apply (partial merge-with concat)\n  \t(map #(hash-map (f %) [%]) s)))","user":"5576fee3e4b05c286339e078"},{"code":"(fn[f s] \n    (reduce \n        #(let [v (f %2)] (merge %1 {v (conj (get %1 v []) %2)}))\n        {}\n        s\n    )\n)","problem":63,"user":"5017eface4b02f523d7cc5e7"},{"code":"(fn [f v] (zipmap \n(distinct (map f v)) \n(for [x (distinct (map f v))] \n(filter #(= x (f %)) v))))","problem":63,"user":"517945dce4b0684c1c981a43"},{"problem":63,"code":"(fn [f coll]\n  (reduce (fn [m x]\n            (let [k (f x)]\n              (assoc m k (conj (get m k []) x)))) {} coll))","user":"548b8a50e4b0e286459a11ff"},{"code":"(fn [f coll] (reduce #(update-in %1 [(f %2)] (fnil conj []) %2) {} coll))","problem":63,"user":"4f169a0f535d64f60314644c"},{"problem":63,"code":"(fn [arg1 arg2]\n(cond\n(and true (= arg2 [1 3 6 8])) {false [1 3], true [6 8]}\n(and true (= arg2 [[1 2] [2 4] [4 6] [3 6]])) {1/2 [[1 2] [2 4] [3 6]], 2/3 [[4 6]]}\n(and true (= arg2 [[1] [1 2] [3] [1 2 3] [2 3]])) {1 [[1] [3]], 2 [[1 2] [2 3]], 3 [[1 2 3]]}\n))","user":"565f2461e4b068f2fe63dc3b"},{"code":"(fn [x y]\n    (let [ml (set (map x y))]\n      (zipmap\n        ml\n        (map\n          (fn [vl]\n            (filter #(= (x %) vl) y)\n          )\n          ml\n        )\n      )\n    )\n  )","problem":63,"user":"4e8b73e4535d65386fec2120"},{"problem":63,"code":"(fn [func coll]\n  (reduce\n    (fn [themap value]\n      (let [mapkey (func value)]\n        (assoc themap mapkey (conj (get themap mapkey []) value))))\n    {}\n    coll)\n)","user":"525b4e8de4b0cb4875a45d0f"},{"code":"(fn grb [f s]\n  (if (seq s)\n    (let [m (grb f (vec (drop-last s)))\n          e (last s)\n          v (f e)]\n      (assoc m v (conj (get (grb f (drop-last s)) v []) e)))\n    {}))","problem":63,"user":"4ef57a7f535dced4c769f246"},{"code":"(fn [f s]\n  (loop [c s acc {}]\n    (if (seq c)\n      (recur (rest c)\n             (let [k (f (first c))]\n               (assoc acc k (filter #(= (f %) k) s))))\n      acc)))","problem":63,"user":"52cc582ae4b07d0d72b27362"},{"problem":63,"code":"(fn gb [f c]\n  (reduce #(let [k (f %2)]\n             (assoc % k (conj (% k []) %2)))\n          {} c))","user":"508c3d42e4b0f17d83ea26b2"},{"code":"(fn [f x]\n  (reduce #(assoc %1 (f %2) (conj (or (%1 (f %2)) []) %2)) {} x))","problem":63,"user":"4fadbb17e4b081705acca23e"},{"problem":63,"code":"#(loop [f %1\n        [head & tail] %2\n        res {}]\n   (if head\n     (let [fhead (f head)\n           old-vec (get res fhead)\n           new-vec (if old-vec (conj old-vec head) [head])]\n       (recur f tail (assoc res fhead new-vec)))\n     res))","user":"53f7820be4b0de5c41848560"},{"problem":63,"code":"(fn [f coll]\n  (reduce (fn [acc e]\n            (let [r (f e)]\n              (if-let [lkeys (get acc r)]\n                (conj acc [r (conj lkeys e)])\n                (conj acc [r [e]]))))\n          {} \n          coll))","user":"541d3c0fe4b01498b1a71a7e"},{"problem":63,"code":"(fn [f xs] \n   (reduce (fn [m v] (assoc m (first v) (last v))) {} (for [k (set (map f xs))] \n          (list k (filterv #(= k (f %)) xs)))))","user":"5510aa92e4b06e50f9beb188"},{"problem":63,"code":"(fn grp [f coll]\n    (reduce (fn [acc x]\n                (assoc\n                    acc\n                    (f x)\n                    (conj (get acc (f x) []) x))) {} coll))","user":"5779556de4b0979f8965166e"},{"problem":63,"code":"(fn [f sq]\n     (reduce (fn [acum e]\n                 (let [k (f e)\n                         v (get acum k [])\n                         nv (conj v e)]\n                   (assoc acum k nv)))\n             {}\n             sq))","user":"4f867b25e4b033992c121c51"},{"problem":63,"code":"(fn grp [func vals]\n  (into {}\n        (map #(vector (func (first % )) (vec %))\n             (partition-by func (sort vals)))))","user":"4eeb8f68535d93acb0a668a9"},{"problem":63,"code":"(fn my-group-by [f s]\n  (loop [s s m {}]\n    (if (empty? s) m\n      (let [v (first s) \n            k (f v)] \n       (recur (rest s) (assoc m k (conj (get m k []) v)))))))","user":"556405e5e4b0c656e3ff17fb"},{"code":"(fn mygroup-by [f s]\n  (reduce (fn [ret item] (update-in ret [(f item)] #(concat %1 [item]))) {} s))","problem":63,"user":"4f2965ffe4b0d6649770a029"},{"problem":63,"code":"(fn [x y] (loop [out {} y y] (if (empty? y) out (recur (if (contains? out (x (first y))) (assoc out (x (first y)) (conj (out (x (first y))) (first y))) (assoc out (x (first y)) [(first y)])) (rest y)))))","user":"5d7158f3e4b04d129b00f2e1"},{"problem":63,"code":"(fn [f ls]\n  (letfn\n      [(colt [f ls] (if-let [a (first ls)] (cons [(f a) a] (colt f (rest ls)))))\n       (aone [m k v] (assoc m k (cons v (get m k []))))\n       (gb [col m] (if (empty? col) m (gb (rest col) (aone m (ffirst col) (second (first col))))))]\n    (let [m {} col (reverse (colt f ls))]\n      (gb col m))))","user":"5da71eaee4b000c986472c15"},{"code":"(fn this\n  ([f xs] (this f xs {}))\n  ([f xs acc]\n    (if (empty? xs)\n      acc\n      (let [x (first xs), \n            v (f x),\n            vs (get acc v [])]\n        (recur f (rest xs) (assoc acc v (conj vs x)))))))","problem":63,"user":"4f2e0369e4b0d6649770a064"},{"code":"(fn [f s]\n  (reduce #(merge-with concat\n              %1 { (f %2) [%2]}         \n   ) {} s))","problem":63,"user":"50bc4e73e4b0594b91591c3d"},{"code":"(fn [f s] \n  (reduce (fn [m x]\n            (let [fx (f x)]\n              (assoc m fx (vec (conj (m fx) x)))))\n          {} s))","problem":63,"user":"5117c31ee4b0e0897831a60c"},{"problem":63,"code":"(fn [f coll]\n                  (persistent!\n                    (reduce\n                      (fn [ret x]\n                        (let [k (f x)]\n                          (assoc! ret k (conj (get ret k []) x))))\n                      (transient {}) coll)))","user":"5d9c9446e4b0eb781811cdae"},{"code":"(fn [f s]\n  (reduce #(assoc % (f %2) (conj (vec (% (f %2))) %2))\n          {}\n          s))","problem":63,"user":"4e1f9bb5535d04ed9115e80d"},{"problem":63,"code":"(fn my-groupby\n  [f coll]\n  (loop [result {} remaining coll]\n    (if (empty? remaining) result\n        (let [curr (first remaining)\n              fcurr (f curr)\n              entry (get result fcurr [])]\n          (recur (assoc result fcurr (conj entry curr))\n                 (rest remaining))))))","user":"536e5055e4b0fc7073fd6e6b"},{"code":"(fn [f coll]\n\t  (persistent!\n\t   (reduce\n\t    (fn [ret x]\n\t      (let [k (f x)]\n\t        (assoc! ret k (conj (get ret k []) x))))\n\t    (transient {}) coll)))","problem":63,"user":"4ebd4448535dfed6da9c6d8f"},{"problem":63,"code":"(fn [f coll]\n  (reduce (fn [ret x]\n            (let [k (f x)]\n              (assoc ret k (conj (get ret k []) x))))\n          {} coll))","user":"4eda8d7c535d10e5ff6f530f"},{"problem":63,"code":"(fn [f xs] (apply merge-with concat (map (fn [x] {(f x) [x]}) xs)))","user":"4fcf1755e4b03432b189f40c"},{"problem":63,"code":"(fn [f xs]\n  (reduce (fn [m v]\n            (let [k (f v)]\n              (if-let [vs (m k)]\n                (assoc m k (conj vs v))\n                (assoc m k [v]))))\n          {}\n          xs))","user":"4ff24a1ae4b0678c553fc337"},{"problem":63,"code":"#(apply merge-with concat (map (fn [x] (assoc {} (%1 x) [x])) %2))","user":"55e2f502e4b050e68259b43c"},{"problem":63,"code":"(fn [a b] (apply (partial merge-with (comp vec concat)) (map #(hash-map (a %) [%]) b)))","user":"56cd75bee4b0ea9b8538f74b"},{"problem":63,"code":"(fn [f d] (reduce #(assoc % (f %2) (merge (% (f %2) []) %2)) {} d))","user":"54126d0ce4b01498b1a719d5"},{"problem":63,"code":"(fn [f coll]\n  (apply merge-with into (for [x (mapv (juxt f #(conj [] %)) coll)] {(first x) (last x)})))","user":"54012b48e4b0de5c41848620"},{"code":"#(apply merge-with concat (map hash-map (map %1 %2) (map vector %2)))","problem":63,"user":"5201572be4b0d7096e99ddbb"},{"problem":63,"code":"(fn grp\n  [f coll]\n  (reduce \n    (fn [seed value]\n      (assoc seed (f value) (vec (conj (seed (f value)) value))))\n    {} coll))","user":"5401aefbe4b0df28a13c62c7"},{"problem":63,"code":"(fn [f coll]\n  (reduce #(update-in %1 [(f %2)] (fn [a b] (conj (vec a) b)) %2) {} coll)\n  )","user":"59e0f38ae4b08badc2a0c500"},{"code":"#(apply merge-with concat\n  (map (fn [x] {(%1 x) [x]}) %2))","problem":63,"user":"500933a6e4b046cdb195e074"},{"problem":63,"code":"#(reduce (fn [acc x] (let [next-val (%1 x)]\n           (if (contains? acc next-val)\n             (assoc acc next-val (conj (acc next-val) x))\n             (assoc acc next-val [x])))) {} %2)","user":"529f9bf2e4b04e0c58e87bb4"},{"code":"#(reduce (fn [m x] (let [k (% x)] (assoc m k (conj (get m k []) x)))) {} %2)","problem":63,"user":"4ea09fa4535d7eef308072aa"},{"problem":63,"code":"(fn mapping-function\n  [f s]\n  (loop [result {} rem s]\n    (if (empty? rem)\n      result\n      (if (nil? (get result (f (first rem))))\n        (recur (into result (list [(f (first rem)) [(first rem)]])) (rest rem))\n        (recur (into result (list [(f (first rem)) (conj (get result (f (first rem)))\n                                                         (first rem))])) (rest rem))\n        )\n      )\n    )\n  )","user":"5f6adf5ee4b02876ed9fd049"},{"problem":63,"code":"(fn [f coll]\n    (persistent!\n   (reduce\n    (fn [ret x]\n      (let [k (f x)]\n        (assoc! ret k (conj (get ret k []) x))))\n    (transient {}) coll)))","user":"53882352e4b0640c7a9a5898"},{"problem":63,"code":"(fn [f s]\n  (loop [result {} coll s]\n    (if (empty? coll) result\n      (let [k (f (first coll))]\n        (if (get result k)\n          (recur (assoc result k (conj (get result k) (first coll))) (rest coll))\n          (recur (assoc result k (vector (first coll))) (rest coll)))))))","user":"56bb9ccce4b0f26550335959"},{"problem":63,"code":"(fn [f s]\n  (loop [remaining-keys (set (map f s))\n         values {}]\n    (if (empty? remaining-keys)\n      values\n      (recur (rest remaining-keys) (assoc values (first remaining-keys) (filter #(= (first remaining-keys) (f %)) s))))))","user":"554756b8e4b0a04f79299549"},{"code":"(fn [f c]\n  (reduce\n    (fn [m i]\n      (update-in m [(f i)] #(conj (or % []) %2) i))\n    {} c))","problem":63,"user":"4f9d8083e4b0dcca54ed6d23"},{"problem":63,"code":"(fn [f s]\n  (loop [acc {}\n         s s]\n    (if (empty? s)\n      acc\n      (recur (let [frst (first s)\n                   res (f frst)]\n               (if-let [k (acc res)]\n                 (merge acc {res (conj k frst)})\n                 (merge acc {res (vector frst)})))\n             (rest s)))))","user":"532bce35e4b09d4e7a9b5536"},{"problem":63,"code":"(fn [f coll]\n  (reduce (fn [m x]\n            (let [k (f x)]\n              (assoc m k (conj (or (m k) []) x))))\n          {} coll))","user":"5629dfaae4b00e49c7cb4813"},{"problem":63,"code":"(fn [f vs]\n \t(let [ks (map f vs)\n          zs (zipmap ks (map #(filter (fn[a](= (f a) %)) vs) ks))]\n      \t  zs\n      ) \n)","user":"5ce41d1be4b0a17bb84e2b50"},{"code":"(fn [f l]\n  (reduce \n    #(update-in %1 [(first %2)]\n      (fn [a] (conj (vec a) (second %2))))\n    {} \n    (map #(list (f %) %) l)))","problem":63,"user":"4fc0853ae4b081705acca327"},{"problem":63,"code":"(fn [f coll]\n  (reduce\n   #(let [r (f %2)]\n      (if (contains? % r)\n        (update-in % [r] conj %2)\n        (assoc % r  (vector %2))))\n   {}\n   coll))","user":"56ae214ce4b03c432f18735a"},{"code":"(fn myfn [op s1]\n\t(let [xxx (->> s1\n         (map (fn [x] [(op x) x]))\n         (sort #(compare (first %1) (first %2)))\n\t\t (partition-by #(first %)))]\n     \t (zipmap (map #(first (first %)) xxx) (map #(map second %) xxx))\n         \n        \n    )\n)","problem":63,"user":"525ba7bbe4b0cb4875a45d28"},{"code":"#(reduce (fn [m [k v]] (assoc m k (conj (m k []) v)))\n         {}\n         (map vector (map % %2) %2))","problem":63,"user":"506ba58be4b0eda3100c090b"},{"code":"(fn t[f d] \n  (loop [data d accum {}] \n    (if (empty? data) accum\n     (recur (rest data) \n            (merge-with concat accum \n              {(f (first data)) (vector (first data))} )))))","problem":63,"user":"52ab61f5e4b0c58976d9ac75"},{"code":"(fn [f s]\n  (reduce\n   #(let [x (f %2)] (assoc % x (into (or (get % x) []) (vector %2))))\n   {} s))","problem":63,"user":"4f0c84ce535d0136e6c2230e"},{"code":"(fn [f s] (reduce (fn [acc x] (update-in acc [(f x)] #(conj % x))) {} (reverse s)))","problem":63,"user":"513dcc1ce4b0825f97f7f964"},{"problem":63,"code":"(fn [f coll] \n  (reduce\n    (fn [m entry]\n      (assoc \n        m \n        (f entry) \n        (conj (get m (f entry) []) entry)))\n    {}\n    coll))","user":"5665ef78e4b0e91d5f5c5664"},{"code":"(fn [f c]\n  (reduce (fn [m v] (let [k (f v) o (m k)] (assoc m k (concat o [v])))) {} c))","problem":63,"user":"4f1b0ab3535d64f603146474"},{"problem":63,"code":"(fn [f coll]\n  (reduce (fn [res ins]\n            (let [key (f ins)\n                  prior (get res key)\n                  value (if (nil? prior)\n                          [ins]\n                          (conj prior ins))]\n              (assoc res key value))) {} coll))","user":"5bef3e88e4b0a6d31fed213f"},{"code":"(fn [f a]\n  (reduce\n    (fn \n      [m x]\n        (assoc m (f x)\n          (conj (get m (f x) []) x)))\n     {} a))","problem":63,"user":"4f0446f9535dcb61093f6bb8"},{"problem":63,"code":"(fn [f s]\n    (reduce (fn [acc elem]\n              (let [result (f elem)]\n                (assoc acc result (conj (vec (get acc result)) elem))))\n            {} s))","user":"54ca130ce4b057c6fda3a250"},{"code":"#( zipmap                                                                                                                                                                                                                                                                     \n   (sort (set (map %1 %2)))                                                                                                                                                                                                                                                         \n   (partition-by %1 (sort                                                                                                                                                                                                                                                     \n                     (fn [x y]                                                                                                                                                                                                                                                \n                       (compare (%1 x) (%1 y)))                                                                                                                                                                                                                               \n                     %2 ) ) )","problem":63,"user":"505fc8e3e4b08f2a82ad10b6"},{"code":"(fn [f s] \n  (reduce \n   (fn [m v] \n     (let [k (f v)\n           entry (get m k [])] \n       (assoc m k (conj entry v)))) \n   {} \n   s))","problem":63,"user":"51e24a04e4b01e5198146430"},{"problem":63,"code":"(fn [f s]\n  (reduce (fn [a z]\n            (let [v (f z)]\n              (if (contains? a v) \n                (assoc a v (conj (get a v) z)) \n                (assoc a v [z])\n                )\n              )\n            ) {} s)\n  )","user":"57b8b008e4b0fbc9809a27e6"},{"problem":63,"code":"(fn gb\n  [f l]\n  (into {}\n  (let [s (set (map f l))]\n    (map \n      (fn [x]\n        (vector\n          x\n          (vec (filter\n            #(= (f %) x)\n            l)))) \n      s))))","user":"5626447fe4b00e49c7cb47bd"},{"problem":63,"code":"(fn group [func coll]\n  (reduce\n   (fn [ret x]\n     (let [key (func x)]\n       (assoc ret key (conj (get ret key []) x))\n       ))\n   {} coll))","user":"543c39e0e4b032a45b86933d"},{"problem":63,"code":"(fn groups [f coll]\n  (reduce (fn [acc next-value]\n            (let [k (f next-value)]\n              (assoc acc k\n                (conj (or (acc k) []) next-value))))\n   {} coll))","user":"5c506951e4b0f9f7a8770ec5"},{"code":"(fn [f n](zipmap  (distinct (for [y (seq n) :let [x f]] (x y)) )  (for[c (partition-by f (sort n))] (into [] c))))","problem":63,"user":"4f4bd422e4b03ad3f0c10c7e"},{"problem":63,"code":"(fn\n  [f xs]\n  (reduce (fn\n            [result x]\n            (let [k (f x)]\n              (assoc result k (conj (get result k []) x))))\n          {}\n          xs))","user":"5afcd6d1e4b0cc2b61a3bd17"},{"problem":63,"code":"(fn [f s]\n  (apply merge-with \n         (comp vec concat) \n         (for [i s] {(f i) [i]})))","user":"536c1531e4b0fc7073fd6e36"},{"code":"(fn [f s]\n   (loop [m {}\n          rem s]\n     (if (empty? rem)\n       m\n       (let [elem (first rem)\n             key (f elem)\n             currVal (get m key)]\n         (recur (assoc m key (concat currVal (list elem))) (rest rem))))))","problem":63,"user":"53224d45e4b09d4e7a9b54c0"},{"code":"(fn [f xs]\n  (reduce (fn [m x]\n            (let [k (f x)\n                  l (conj (get m k []) x)]\n              (assoc m k l))) {} xs))","problem":63,"user":"4f7ab8c7e4b06e829148e19c"},{"problem":63,"code":"(fn [f s]\n   (reduce (fn [r e]\n             (if (contains? r (f e))\n               (update-in r [(f e)] conj e)\n               (assoc r (f e) [e]))) {} s))","user":"55895eade4b059ccff29b202"},{"problem":63,"code":"(fn grpr-2 [f s]\n  (reduce (fn [accum item]\n            (let [r (f item)\n                  items-for-key (get accum r)]\n              (assoc accum r (if items-for-key\n                               (conj items-for-key item) [item])))) {} s))","user":"563fc1f2e4b08d4f616f5ed7"},{"problem":63,"code":"(fn mygb [f s]\n  (reduce\n   (fn [m e]\n     (let [k (f e)]\n       (assoc m k (vec (conj (get m k) e)))))\n   {} s))","user":"51a3be77e4b0e77c4ca60bf8"},{"code":"(fn group-seq [f coll]\n  (reduce (fn [coll v]\n            (update-in coll [(f v)] (fn [old & args] (if old (conj old (first args)) [(first args)])) v))\n          {} coll))","problem":63,"user":"516385cee4b055933a9ca02d"},{"problem":63,"code":"(fn [f coll]\n  (loop [c coll output {}]\n    (if-not (nil? (first c))\n      (recur (next c) (assoc output (f (first c)) (conj (get output (f (first c)) []) (first c))))\n      output)))","user":"5cf62ecce4b087f62be35aa7"},{"problem":63,"code":"(fn [func coll] (reduce (fn [m, v] (update-in m [(func v)] (fnil conj []) v)) {} coll)\n   )","user":"5471f2fbe4b094393f72dd70"},{"code":"(fn [f xs]\n(reduce (fn [acc x]\n (let [v (f x)]\n  (assoc acc v (conj (acc v []) x)))) {} xs))","problem":63,"user":"4fc7ddffe4b0ee37620e182b"},{"code":"(fn make-map [f s]\n  (reduce\n    (fn [acc v]\n      (let [k (f v)\n            values (get acc k [])\n            updated-values (conj values v)]\n        (assoc acc k updated-values)))\n  {}\n  s))","problem":63,"user":"4ec6559a535d6d7199dd36c9"},{"code":"(fn [f xs]\n  (apply merge-with concat (map (fn [x] {(f x) [x]}) xs)))","problem":63,"user":"51269362e4b083bb8f88cf09"},{"problem":63,"code":"(fn\n  [f coll]\n    (reduce\n      (fn [res x]\n        (let [k (f x)]\n          (assoc res k (conj (get res k []) x)))) {} coll))","user":"5e348945e4b0650de70e2b1d"},{"problem":63,"code":"(fn [f c] (reduce (fn [m v] (update-in m [(f v)] #(into [] (conj % v)))) {} c))","user":"5b72b36ce4b047b03b2036a9"},{"code":"(fn [f s] (apply (partial merge-with concat) (map #(assoc {} (f %1) [%1]) s)))","problem":63,"user":"4e756736535d7a570dd295c2"},{"problem":63,"code":"(fn [f s] (let [k (set (map f s))] (into {} (for [x k] [x (filter #(= x (f %)) s)]))) )","user":"6076adb2e4b069485764de60"},{"problem":63,"code":"(fn my-group-by [f l] (apply (partial merge-with concat) (map (fn [x] (hash-map (f x) [x])) l)))","user":"5990fcb9e4b0866487ed0d5b"},{"code":"(fn [f array]\n  (reduce (fn [result item] \n    (let [key (f item)] \n      (conj result [key (conj (result key []) item)]))) {} array))","problem":63,"user":"4f294c48e4b0d6649770a023"},{"problem":63,"code":"(fn groupSequence\n  [func s]\n  (apply merge-with into (for [v s] {(func v) [v]})))","user":"5aa00b7fe4b0d174b936c825"},{"problem":63,"code":"(fn [f s]\n  (reduce (fn [ret x]\n            (let [k (f x)]\n              (assoc ret k (conj (get ret k []) x))))\n          {}\n          s))","user":"4fe49706e4b0e8f79898feb7"},{"code":"(fn gb\n\t[f coll]\n\t(persistent!\n     \t(reduce \n         \t(fn [ret x] \n              \t(let [k (f x)] \n                  (assoc! ret k (conj (get ret k []) x)))) \n         \t(transient {}) \n         \tcoll)))","problem":63,"user":"51430fb2e4b0c172af7558ce"},{"problem":63,"code":"(fn group-by1 [f sq]\n  (reduce (fn [m x] (assoc m (f x) (conj (get m (f x) []) x))) {} sq))","user":"5e0d948fe4b099d064962f98"},{"problem":63,"code":"(fn gb[f coll]\n  (reduce (fn [a b]\n            (if (nil? (a (f b)))\n              (assoc a (f b) [b])\n              (assoc a (f b)\n                     (conj (a (f b)) b))))\n          {} coll))","user":"5978305be4b01722bebd4d03"},{"code":"(fn [ f a]  (apply (partial merge-with concat)  (map #(hash-map (f %) (vector %)) a) ))","problem":63,"user":"4fccdc75e4b0ee37620e186d"},{"problem":63,"code":"(fn gs [f s]\n  (loop [inputs (vec s) groups {}]\n    (if (empty? inputs) groups\n        (let [v (first inputs)\n              k (f v)\n              predicate (fn [t] (= (f t) k))\n              matched (filter predicate inputs)\n              unmatched (filter (complement predicate) inputs)]\n          (recur unmatched (assoc groups k matched ))))))","user":"5e078ba7e4b0978307768fb6"},{"code":"(fn [f s]\n    (reduce\n    (fn [result elt]\n      (let [\n            k (f elt)\n            curr-vec (result k [])]\n        (assoc result k (conj curr-vec elt))))\n    {} s))","problem":63,"user":"53070615e4b02e821686979e"},{"code":"(fn [f c]\n  (apply merge-with concat \n    (map \n      #(hash-map (f %) [%])\n      c\n    )\n  )\n)","problem":63,"user":"504e3aaae4b0f6ff3350c487"},{"problem":63,"code":"(fn [f coll]  (reduce (fn [m v] (update-in m [(f v)] (fnil #(conj %1 %2) []) v)) {} coll))","user":"4ff4bed0e4b0678c553fc35f"},{"problem":63,"code":"(fn [f n] \n    (apply merge-with into (map #(hash-map (f %) [%]) n))\n   )","user":"50b25edae4b03ea88043355e"},{"code":"(fn [f l]\n  (let [proc (fn [outMap function element]\n    (let [hashKey (function element)\n        arraySoFar (if (outMap hashKey)\n                     (outMap hashKey)\n                     [])]\n(assoc outMap (function element) (conj arraySoFar element))))]\n(reduce #(proc %1 f %2) {} l)))","problem":63,"user":"4f0365fc535dcb61093f6aa4"},{"problem":63,"code":"(fn [f coll]\n  (reduce #(assoc %1 (f %2) (vec (conj (get %1 (f %2))%2))) {} coll))","user":"5964f9b0e4b069c0a1a19778"},{"problem":63,"code":"(fn [f l]\n        (let [s (sort l)\n                v (partition-by f s)\n                k (map #(f (first %)) v)]\n                (zipmap k v)\n        )\n)","user":"5661b0a9e4b068f2fe63dc6f"},{"code":"(fn [fnc sqn]\n  (loop [f fnc s sqn result {}]\n    (if (empty? s) result\n        (let [h (first s)\n              k (f h)\n              v (get result k [])]\n          (recur f (rest s) (assoc result k (conj v h)))))))","problem":63,"user":"4f2d5f5de4b0d6649770a05a"},{"problem":63,"code":"(fn [f coll]\n  (into {} (map (fn [[[k _] & pairs :as all-pairs]] [k (map second all-pairs)])\n                (partition-by first (sort (map #(vector (f %) %) coll))))))","user":"5ac6ef9be4b0e27600da7779"},{"code":"(fn[fnc a-seq]\n  (letfn [(vjoin [a-seq v] (conj (vec a-seq) v))]\n    (first (last (take (inc (count a-seq))\n      (iterate (fn[[a-map a-seq]] \n         [(update-in a-map [(fnc (first a-seq))]\n         vjoin (first a-seq)) (rest a-seq)])\n           [{} a-seq]))))))","problem":63,"user":"4e58bcd4535d8a8b8723a296"},{"problem":63,"code":"(fn [fnc coll]\n  (let [divided (partition-by fnc (sort-by fnc coll))]\n    (zipmap (map fnc (map first divided))\n            divided))) ; values","user":"540c54a7e4b0addc1aec6700"},{"code":"(fn [f sequence] (reduce (fn [acc s] (assoc acc (f s) (concat (acc (f s)) [s]))) (hash-map) sequence))","problem":63,"user":"4e89de60535d3e98b8023285"},{"code":"(fn [f xs] (reduce\n  #(update-in %1\n              [(f %2)]\n              (fn [x] (vec (conj x %2))))\n  {}\n  xs))","problem":63,"user":"4db883e1535d1e037afb2198"},{"problem":63,"code":"(fn fx [f, s]\n  (loop [r (map f s), s s, res {}]\n    (if (seq r)\n      (recur (rest r) (rest s) (if (contains? res (first r))\n                                 (assoc res (first r) (conj (get res (first r)) (first s)))\n                                 (assoc res (first r) [(first s)])))\n      res)))","user":"593d6793e4b069cdc2982ba6"},{"code":"(fn\n  [f mySeq]\n  (reduce\n    (fn\n      [re value]\n      (if-not\n        (empty? (get re (f value)))\n        (assoc re (f value) (conj (get re (f value)) value))\n        (assoc re (f value) (vector value))\n      )\n    )\n    {}\n    mySeq\n  )\n)","problem":63,"user":"5162757ee4b03cfa3774b3fe"},{"problem":63,"code":"(fn somefunc [func coll]\n  (let [values (map func coll)\n        vcoll (map vector coll)\n        mapping (map #(apply hash-map %) (partition 2 (interleave values vcoll)))]\n    (reduce #(merge-with into %1 %2) {} mapping)))","user":"541f5b37e4b01498b1a71a97"},{"code":"(fn [f, v]\r\n  (loop [r {}, v v]\r\n    (if(empty? v) \r\n               r \r\n               (if(r (f(first v))) \r\n                          (recur (assoc r (f (first v)) (conj (r (f (first v))) (first v)))(rest v))\r\n                          (recur (assoc r (f (first v)) [(first v)] ) (rest v))))))","problem":63,"user":"4fdf566fe4b05e33b9224f99"},{"code":"(fn [fun vals]\n    (reduce #(assoc %1 (fun %2) (conj (get %1 (fun %2) []) %2)) {} vals))","problem":63,"user":"5165a235e4b079ad97ec44ac"},{"code":"(fn my-group\r\n  [f c]\r\n  (reduce #(assoc %1 (first %2) (conj (vec (%1 (first %2))) (second %2))) {} (partition 2 (interleave (map f c) c))))","problem":63,"user":"4f17ab99535d64f603146457"},{"code":"(fn [f coll]\n  (reduce\n    (fn [out x]\n      (let [k (f x)\n            curr (or (out k) [])]\n        (assoc out k (conj curr x))))\n    {} coll))","problem":63,"user":"506406c8e4b075d771da6f9f"},{"problem":63,"code":"#(loop \n  [coll %2 \n   acc {}] \n  (if (seq coll) \n    (recur \n       (next coll) \n       (assoc acc (%1 (first coll)) (conj (acc (%1 (first coll)) []) (first coll)))) acc))","user":"5505ceb3e4b086ebe8a79c8b"},{"code":"(fn [f l]\n  (let [ks (set (for [i l] (f i)))]\n    (into {} (for [k ks] [k (filter #(= k (f %)) l)]))))","problem":63,"user":"50b1d166e4b03ea880433554"},{"code":"(fn [f s]\n   (reduce (fn [acc x]\n             (let [key (f x)]\n               (assoc acc key (vec (conj (acc key) x)))))\n           (hash-map)\n           s))","problem":63,"user":"50868795e4b004985b776e5e"},{"code":"(fn [f s] (reduce #(assoc % (f %2) (conj (get % (f %2) []) %2)) {} s))","problem":63,"user":"4e95f5a5535dbda64a6f6b3b"},{"problem":63,"code":"(fn [a b]\n        (into {} \n   (let [value (map #(list (a %) %) (sort b))]\n     (map #(vector (first (first %)) (vec (map (fn [x] (last x)) %)))\n          (partition-by #(first %) value)\n          )\n      ))\n )","user":"52457931e4b08ba239308107"},{"problem":63,"code":"(fn [func arr]\n  (letfn \n    [(into-map [imap inext]\n       (assoc imap (func inext) (-> (func inext) (imap []) (conj inext)))\n       )] \n    (reduce into-map {} arr)\n    )\n  )","user":"5b118b7be4b0cc2b61a3be34"},{"code":"(fn [f s]\n  (reduce \n    (fn [ret x]\n      (let [key (f x)]\n        (assoc ret key (conj (get ret key []) x)))) {} s))","problem":63,"user":"4dd88803535d2dad7130b5d9"},{"problem":63,"code":"(fn [f s]\n  (let [values (set (map f s))]\n    (reduce (fn [dict val] (assoc dict val (filter #(= val (f %)) s))) {} values)))","user":"58a0fc33e4b02bd94d917ea3"},{"problem":63,"code":"(fn [a b](apply merge-with into (for [c b] {(a c) [c]})))","user":"6074e088e4b069485764de4d"},{"problem":63,"code":"(fn [f s]\n  (reduce (fn [acc el] (update-in acc [(f el)] #(conj (or % []) el)) ) {} s))","user":"53483a32e4b084c2834f4a57"},{"problem":63,"code":"(fn [f values]\n  (reduce #(conj %1 {(f %2) (conj (get %1 (f %2) []) %2)}) {} values))","user":"51fc44c5e4b0f1313d468a1b"},{"problem":63,"code":"(fn [f xs]\n  (reduce (fn [m x]\n                (let [k (f x)\n                      v (m k)]\n                  (if v\n                    (assoc m k (conj v x))\n                    (assoc m k [x]))))\n  {} \n xs))","user":"60b66033e4b0e0fa5f1b4248"},{"code":"#(reduce\r\n   (fn [r e]\r\n     (assoc r (% e) (conj (r (% e) []) e)))\r\n   {}\r\n   %2)","problem":63,"user":"4e46ac46535dc968683fc4b5"},{"problem":63,"code":"(fn [f coll]\n  (let [keys (set (map f coll))\n        kv (map (fn [k] {k (filter #(= k (f %)) coll)}) keys)\n        result (reduce conj {} kv)]\n    result))","user":"52fe31d5e4b047fd55837038"},{"problem":63,"code":"(fn [f s]\n  (reduce\n    (fn [a e]\n     (assoc a (f e) (conj (get a (f e) []) e)))\n    {}\n    s))","user":"52bacfa8e4b07a9af57922d6"},{"problem":63,"code":"(fn [op xs] (reduce (fn [r x] (let [k (op x)] (if (r k) (merge r [k (conj (r k) x)]) (assoc r k [x])))) {} xs))","user":"5ce62d8ee4b0a17bb84e2b83"},{"problem":63,"code":"(fn my-group-by [f c]\n  (reduce (fn [res x] (let [value (f x)\n                            current (get res value)]\n                        (if current\n                          (assoc res value (conj current x))\n                          (assoc res value [x]))))\n          {}\n          c))","user":"562e8b2be4b0ab312c17ebbb"},{"problem":63,"code":"(fn [f coll]\n  (reduce\n    (fn [dict x] (assoc dict (f x) (conj (get dict (f x) []) x)))\n    {}\n    coll))","user":"54c8d4a8e4b045293a27f654"},{"code":"(fn group [f xs]\n  (reduce \n   (fn [m x] \n     (conj m [(f x) (conj (m (f x) []) x)]))\n   {}\n   xs))","problem":63,"user":"5268eb68e4b03e8d9a4a71c6"},{"problem":63,"code":"(fn [f a]\n  (loop [u a\n         d {}]\n    (if (= (count u) 0)\n      d\n      (recur (rest u) (let [i (first u)\n                             k (f i)\n                             v (get d k)]\n                         (if v\n                            (assoc d k (conj v i))\n                           (assoc d k [i])))))))","user":"58b54852e4b0ebc645576d52"},{"problem":63,"code":"(fn my-group-by [f coll]\n  (reduce (fn [h a]\n    (let [k (f a)]\n      (assoc h k (if-let [v (h k)]\n        (conj v a)\n        [a])))) {} coll))","user":"59a24c92e4b066c664927d20"},{"code":"(fn [f s]\n  (letfn [(add-to-map\n           [m k v]\n           (if (contains? m k)\n             (assoc m k (conj (get m k) v))\n             (assoc m k [v])))]\n    (reduce #(add-to-map % (f %2) %2) {} s)))","problem":63,"user":"510b0480e4b078ea719210fa"},{"problem":63,"code":"(fn [f xs] (into {} (map \n                     (fn [coll] (vector (-> coll first first) (map second coll)))\n                     (partition-by first (sort (map \n                                                (juxt f identity)\n                                                xs\n                                               )))\n                    )))","user":"5dcfdf23e4b0948ae9d9ad43"},{"problem":63,"code":"(fn [f cl] (loop [c cl r {}]\n    (if (empty? c) r\n     (recur (rest c) (if (nil? (get r (f (first c)))) (assoc r (f (first c)) [(first c)]) \n                       (assoc r (f (first c)) (conj (get r (f (first c))) (first c))) ))         \n)))","user":"55adf4d7e4b03311e7b732af"},{"code":"(fn [f coll] (reduce \r\n  \t\t\t\t #(assoc % (f %2) (conj (get % (f %2) []) %2 ))\r\n\t\t\t\t\t {} \r\n\t\t\t\t\t coll))","problem":63,"user":"4ecf1f51535d1f5ad70dba3a"},{"code":"(fn [f coll]\n  (loop [coll (reverse coll)\n         acc {}]\n    \n    (if (empty? coll)\n    acc\n    (let [el (first coll) result (f el)]\n      (recur\n        (rest coll)\n        (assoc acc result (cons el (acc result))))\n  )))\n)","problem":63,"user":"4e9dafe1535dbda64a6f6b89"},{"code":"(fn [f s]\n  (reduce (fn [acc elem] \n            (merge-with into acc {(f elem) [elem]})) \n          {} s))","problem":63,"user":"4fc7db47e4b0ee37620e182a"},{"code":"(fn [f, s]\n  (reduce (fn [r,v] \n            (let [k (f v)]\n              (assoc r k (conj (get r k []) v)))) {} s))","problem":63,"user":"525ca6a7e4b0cb4875a45d42"},{"problem":63,"code":"(fn [f s]\n  (reduce #(merge-with concat % {(f %2) [%2]}) {} s))","user":"51a1659de4b00957e520db72"},{"code":"(fn [f s]\n  (apply merge-with into\n   (map #(hash-map (f %) [%]) s)))","problem":63,"user":"5150a7d7e4b03e678e393abb"},{"problem":63,"code":"#(apply merge-with into (for [va %2] {(% va) [va]}))","user":"607e1cf9e4b03d835a6eaed9"},{"problem":63,"code":"(fn [f s]\n  (reduce\n   (fn [acc next]\n\t   (let [result (f next)]\n\t\t   (if (nil? (get acc result))\n         (assoc acc result (vector next))\n         (update-in acc (vector result) conj next)))) {} s))","user":"4fe899a6e4b07c9f6fd12c54"},{"code":"(fn [f coll]\n   (reduce #(let [key (f %2)]\n              (assoc %1 key (conj (%1 key) %2)))\n           {} (reverse coll)))","problem":63,"user":"4eb02674535d7eef30807338"},{"code":"(fn [f xs]\n  (let [keys (seq (set (map f xs)))\n        that-match (fn [k xs] (filter #(= (f %) k) xs))]\n    (zipmap keys (map #(that-match % xs) keys))))","problem":63,"user":"536ca4bde4b0fc7073fd6e49"},{"code":"(fn [fcn lst]\n\n    (reduce #(assoc %1 (fcn %2) (sort (cons  %2 (%1 (fcn %2)))))   {} lst))","problem":63,"user":"5124619ae4b02c3f2a072ccd"},{"code":"(fn my-group-by\n  [f s]\n  (loop [res {}\n         s   s]\n    (if (seq s)\n      (let [x (first s)\n            y (f (first s))]\n        (if (res y)\n          (recur (assoc res y (conj (res y) x))\n                 (rest s))\n          (recur (assoc res y [x])\n                 (rest s))))\n      res)))","problem":63,"user":"4e7f32ee535db966e863cc3a"},{"problem":63,"code":"(fn [f c] (reduce (fn [state v] (let [a (f v) vs (get state a [])] (assoc state a (conj vs v)))) {} c))","user":"54246d6de4b01498b1a71aec"},{"problem":63,"code":"(fn [f xs]\n  (reduce (fn [rs x]\n            (update-in rs [(f x)] (fnil conj []) x))\n          {}\n          xs))","user":"583369e6e4b089d5ab817c9c"},{"problem":63,"code":"(fn [f s] (apply merge-with concat (for [x s] {(f x) [x]})))","user":"55f20e4be4b06e875b46ce40"},{"problem":63,"code":"(fn gb[f col] (\n                 reduce #(assoc %1 (f %2) (concat (get %1 (f %2)) [%2])) {} col\n                 ))","user":"596f6683e4b069c0a1a19877"},{"problem":63,"code":"(fn a [keyfn values]\n  (reduce\n    (fn [map value]\n      (let [key (keyfn value)]\n        (conj map\n          [key (conj (get map key []) value )]))) {} values))","user":"5713c575e4b07c98581c3aab"},{"problem":63,"code":"#(zipmap (distinct (map %1 %2)) (partition-by %1 (sort %2)))","user":"52c08c59e4b07a9af5792351"},{"code":"#(reduce (fn [m k] (let [v (% k)] (assoc m v (conj (m v []) k)))) {} %2)","problem":63,"user":"513edd13e4b051389b345b39"},{"problem":63,"code":"#(apply merge-with concat (for [a %2] {(%1 a) [a]}))","user":"5007c7c7e4b0b17c647f5226"},{"code":"(fn [f s]\n  (->> (map (fn [x] {(f x) [x]}) s)\n       (apply merge-with into)))","problem":63,"user":"508a2c2fe4b016a2107004a1"},{"problem":63,"code":"(fn group [f col]\n  (reduce #(assoc %1 (f %2) (conj (apply vector (%1 (f %2))) %2)) {} col))","user":"52ba2639e4b07a9af57922cb"},{"code":"(fn [f x] (zipmap (for [a (set (map f x))] a) (for [a (set (map f x))] (filter (fn [n] (= (f n) a)) x))))","problem":63,"user":"52810225e4b0757a1b171418"},{"code":"(fn [f c] (apply merge-with into (map (fn [x] {(f x) [x]}) c)))","problem":63,"user":"4ffa8affe4b0678c553fc3bd"},{"code":"(fn [f coll]\n  (letfn [(reducer [ret x]\n            (let [k (f x)]\n              (assoc ret k (conj (get ret k []) x))))]\n    (reduce reducer {} coll)))","problem":63,"user":"50bfb5fbe4b05ae8c1cbbd9a"},{"problem":63,"code":"(fn [f c]\n  (reduce #(update-in %1 [(f %2)] (fnil conj []) %2)\n          {}\n          c))","user":"521ed5b4e4b0e6c71e0c0bc0"},{"problem":63,"code":"(letfn [                                                                                                                        \n    (my-group-by [f s] (reduce (fn [a [k v]] (assoc a k (conj (a k []) v))) {} (kv-sequence f s)))                                                      \n    (kv-sequence [f s] (map #(list (f %) %) s))]                                                                                \n        my-group-by)","user":"558b50d5e4b027778923762b"},{"problem":63,"code":"(fn\n  [f s]\n  (reduce (fn [m i]\n            (let [v (f i)\n                  l (get m v [])]\n              (assoc m v (conj l i))))\n          {}\n          s))","user":"570c8ac3e4b0b0fb43fd06ca"},{"code":"(fn [f coll]\n  (loop [m (transient {}) c coll]\n    (if (empty? c)\n      (persistent! m)\n      (let [v (f (first c))]\n        (recur (assoc! m v (conj (get m v []) (first c))) (rest c)))\n      )))","problem":63,"user":"4eb955da535dfed6da9c6d50"},{"code":"(fn [f s]\n  (let [m (for [x s] [(f x), x])\n        v (distinct (map #(first %) m))\n        r (reduce (fn [c g]\n                    (concat c\n                            [g, (map #(second %) (filter #(= g (first %)) m))]))\n                  [] v)]\n    (apply array-map r)))","problem":63,"user":"4ed8b598535d10e5ff6f52fc"},{"problem":63,"code":"(fn [f s]\n  (reduce \n    (fn [m o]\n      (let [k (f o)]\n        (assoc m k (conj (m k []) o))))\n    {} s))","user":"4fbe2cfbe4b081705acca30c"},{"problem":63,"code":"(fn group-by++ [f coll]\n  (reduce (fn [acc val]\n            \n            (if-let [b (get acc (f val))]\n              (assoc acc (f val) (conj b val))\n              (assoc acc (f val) (vector val)))) {} coll))","user":"55af7e21e4b03311e7b732cc"},{"code":"(fn [f s]\n  (reduce\n    (fn [h value]\n      (let [v (f value)]\n        (assoc h v (conj (get h v []) value))))\n    (hash-map) s))","problem":63,"user":"4fd91099e4b05e33b9224f32"},{"code":"(fn test63\n  [f coll]\n  (reduce\n   (fn [rest x]\n     (let [y (f x)]\n       (assoc rest y (conj (get rest y []) x))))\n   {} coll))","problem":63,"user":"50b0cffae4b009df37c708c5"},{"code":"(fn [f s]\r\n  (reduce (fn [m el]\r\n            (update-in m [(f el)]\r\n                       (comp vec conj) el))\r\n          {} s))","problem":63,"user":"4fb79872e4b081705acca2d2"},{"problem":63,"code":"(fn [my-func my-coll]\n  (reduce\n    #(assoc %1 (my-func %2) (concat (%1 (my-func %2)) [%2]))\n    {}\n    my-coll))","user":"5784ff88e4b0ebec4cfb74d4"},{"code":"(fn gs [f arr]\n  (loop [result {}\n        a arr]\n        (if (empty? a)\n          result\n          (recur\n            (assoc result (f (first a)) (conj (vec (result (f (first a)))) (first a)))\n            (rest a)))))","problem":63,"user":"4fc93728e4b0ee37620e1844"},{"problem":63,"code":"(fn my-gs [f s]\n  (reduce\n   (fn [new x]\n     (let [key (f x)\n           entry (get new key [])]\n       (assoc new key (conj entry x))\n       ))\n   {} s ) )","user":"5fa6db67e4b0fa27300f3dd2"},{"problem":63,"code":"(fn my-group-by [func lyst]\n  (let [f (fn [acc val]\n            (let [k (func val)]\n              (assoc acc k (conj (get acc k []) val))))]\n    (reduce f {} lyst)))","user":"53e27bf1e4b036ad0777e3f2"},{"problem":63,"code":"(fn [f s]\n  (reduce \n    (fn [acc item]\n      (let [key (f item)\n            existing (or (get acc key) [])]\n        (if existing\n          (assoc acc (f item) (conj existing item)))))\n    {}\n    s))","user":"571543bbe4b07c98581c3ad4"},{"code":"(fn [f c] (reduce #(assoc %  (f %2) (vec(conj (get % (f %2)) %2) )){} c))","problem":63,"user":"52570aeae4b0541d1855ba42"},{"problem":63,"code":"(fn [f xs]\n  (reduce (fn [acc x] (assoc acc (f x) (conj (get acc (f x) []) x))) {} xs))","user":"56a51f26e4b0542e1f8d14e0"},{"problem":63,"code":"(fn my-group-by[f collo]\n  (loop [coll collo, acc {}]\n    (cond \n      (empty? coll)\n      acc ;Empty -> return acc\n      (get acc (f (first coll)))\n      (recur (rest coll) (assoc acc (f (first coll)) (conj (get acc (f(first coll))) (first coll))))\n      :else (recur  (rest coll) (assoc acc (f (first coll)) [(first coll)])))))","user":"53ae0c50e4b047364c044471"},{"problem":63,"code":"(fn [f s] (apply merge (map (fn [v] (hash-map v (filter #(= (f %) v) s)))\n                             (set (map f s)))))","user":"56baab13e4b0f26550335948"},{"problem":63,"code":"(fn [f s]\n  (->> s\n       (map (fn [x] {(f x) [x]}))\n       (reduce (fn [acc x] (merge-with concat acc x)))))","user":"4db1b3951254ad5b4805fa6f"},{"problem":63,"code":"(fn group-it [f c]\n    (loop [cc c r {}]\n      (if (empty? cc)\n        r\n        (let [e (first cc)\n              v (f e)\n              n (next cc)]\n          (if (not (contains? r v))\n            (recur n (assoc r v [e]))\n            (recur n (update-in r [v] #(conj % e))))))))","user":"56a1fce9e4b0542e1f8d14b7"},{"code":"(fn [f xs]\n     (reduce (fn [res x]\n                 (let [k (f x), v (get res k)]\n                      (assoc res k \n                             (if (nil? v) [x] (conj v x))))) {} xs))","problem":63,"user":"52161db6e4b0bf4bffd29cb8"},{"code":"(fn [f coll]\n  (reduce\n    #(let [m %, k (f %2), old-v (vec (m k))]\n      (assoc m k (conj old-v %2)))\n    {} coll))","problem":63,"user":"4f4e7c01e4b03ad3f0c10cc9"},{"problem":63,"code":"(fn [f coll]\n  (reduce (fn [acc item]\n            (assoc acc\n              (f item)\n              (conj (get acc (f item) []) item)))\n          {}\n          coll))","user":"54cc26c1e4b057c6fda3a28a"},{"problem":63,"code":"(fn [f s]\n  (->> (map #(hash-map (f %) [%]) s) ; Convert each element into { (f x) [x] }\n       (apply merge-with concat)     ; Merge duplicates with concat\n  )\n)","user":"53b9bb15e4b047364c0444ed"},{"problem":63,"code":"(fn sol [func lst]\n  (reduce\n    (fn [x y] (assoc x (func y) (conj (x (func y)) y)))\n    (reduce (fn [i k] (assoc i (func k) [])) {} lst)\n    lst))","user":"578b140be4b0ebec4cfb7545"},{"code":"(fn [f xs]\n\t(reduce (fn [m x] \n\t\t\t\t(let [v (f x)] \n\t\t\t\t\t(assoc m v (if-let [g (m v)] (conj g x) [x])))) \n           \t{} xs))","problem":63,"user":"5097cfcbe4b00ad8bab4e977"},{"code":"(fn [f s]\n  (reduce (fn [mp val]\n    (let [x (f val)]\n      (assoc mp x (conj (get mp x []) val)))) {} s))","problem":63,"user":"50981062e4b04e098a4c7268"},{"problem":63,"code":"(fn \n  [f vals]\n   (into {}\n     (map #(vector (f (first %)) (vec %))\n       (partition-by f (sort vals)))))","user":"5723e6d6e4b0c5bde472c0f1"},{"problem":63,"code":"(fn [f coll]\n  (reduce #(let [k (f %2)] (assoc %1 k (conj (get %1 k []) %2)))\n          {} coll))","user":"54055aa9e4b0addc1aec6665"},{"problem":63,"code":"#(reduce (fn [acc cur] (assoc acc (%1 cur) (conj (get acc (%1 cur) []) cur ))) {} %2)","user":"5b2be9b1e4b025bcb146f2b0"},{"problem":63,"code":"(fn [f coll]\n  (let* [ks (set (map #(f %) coll))\n         vs (map (fn [x] (filter #(= x (f %)) coll)) ks)]\n        (zipmap ks vs)))","user":"57bfffc7e4b05aa3c4741c8a"},{"code":"(fn [f xs]\n  (loop [[hd & tl :as xs] xs, map {}]\n    (if (empty? xs)\n      map\n      (let [img (f hd)]\n        (recur tl (assoc map img (conj (get map img []) hd)))))))","problem":63,"user":"5055e7f4e4b0ce54f56f0401"},{"problem":63,"code":"(fn [f xs]\n  (apply merge-with concat \n      (map (fn [x] {(f x) [x]}) xs)))","user":"4f8490fae4b033992c121c34"},{"problem":63,"code":"(fn my-group [func coll]\n  (reduce (fn [m c]\n            (let [k (func c)]\n              (if (nil? (get m k))\n                (into m (hash-map k (vector c)) )\n                (update-in m [k] conj c)))) {} coll))","user":"5785c1d4e4b0ebec4cfb74e1"},{"code":"(fn [f c]\n  (reduce #(merge-with into %1 {(f %2) [%2]}) {} c))","problem":63,"user":"4e5c801e535d8a8b8723a2c1"},{"code":"(fn [f s]\n  (reduce #(let [v (f %2)]\n             (assoc %1 v (if (contains? %1 v) (conj (%1 v) %2) [%2]))) {} s))","problem":63,"user":"51780f88e4b03d69594194c9"},{"problem":63,"code":"(fn [f coll]\n  (reduce\n    (fn [m x]\n      (let [k (f x)]\n        (assoc m k (conj (get m k []) x))))\n    {} coll))","user":"4eb70649535d7eef30807373"},{"code":"(fn [f s]\n  (let [m (map (fn [e] [(f e) e]) s)]\n    (reduce (fn [r e]\n              (let [me (r (e 0))]\n                (if (nil? me)\n                    (assoc r (e 0) [(e 1)])\n                    (assoc r (e 0) (conj me (e 1))))))\n            {}\n            m)))","problem":63,"user":"5063fe48e4b075d771da6f9e"},{"code":"(fn [f coll]\n\t(reduce\n\t\t(fn [ret x]\n\t\t\t(let [k (f x)]\n\t\t\t\t(assoc ret k (conj (get ret k []) x)))) {} coll))","problem":63,"user":"51bdc609e4b0ff155d51d2b3"},{"problem":63,"code":"(fn[f s] (into {} (map #(vector (f (first %)) (vec %)) (partition-by f (sort s)))))","user":"5f727d2fe4b02876ed9fd08f"},{"problem":63,"code":"(fn gp [f s]\n  (reduce (fn [acc v]\n            (if (contains? acc (f v))\n              (update-in acc [(f v)] conj v)\n              (assoc acc (f v) [v]))) {} s))","user":"56588f4ee4b0f9d632dd84b6"},{"problem":63,"code":"(fn [f s]\n  (reduce (fn [acc curr]\n            (let [k (f curr)]\n              (assoc acc k (conj (vec (get acc k)) curr)))) {} s))","user":"576a972ce4b0a07e8fc1811a"},{"code":"(fn myfunc [ f coll ]\n        ( reduce\n                #( assoc %1 (f %2) (vec (conj (%1 (f %2)) %2)))\n                {} coll  ))","problem":63,"user":"5018ed15e4b011a2e0bf6412"},{"code":"#(\n(fn [s m]\n    (if (empty? s)\n        m\n        (recur (rest s) (assoc m (% (first s))\n                                 (concat (m (% (first s)))\n                                         [(first s)]))))\n) %2 {})","problem":63,"user":"4f404dcee4b0e243712b1fb0"},{"problem":63,"code":"(fn [p c]\n   (reduce\n     (fn [cur e]\n       (assoc cur (first e) (concat (get cur (first e)) (second e))))\n     {}\n     (map\n       (fn [a]\n         [(p a) [a]])\n       c)))","user":"506ab256e4b05d3b7762c74b"},{"problem":63,"code":"(fn [f coll]\n  (reduce #(merge-with into %1 {(f %2) [%2]}) {} coll))","user":"53ce4cd4e4b00fb29b2212ef"},{"problem":63,"code":"(fn [f coll]\n  (reduce\n   (fn [a b]\n     (update-in a [(f b)] (fnil #(conj % b) [])))\n   {}\n   coll))","user":"513facf5e4b00f13ea1bd892"},{"code":"(fn [f s]\n     (reduce (fn [r v] (let [a #((fnil conj []) % %2)]\n                         (update-in r [(f v)] a v))) {} s))","problem":63,"user":"52e3e6a8e4b09f7907dd1448"},{"problem":63,"code":"(fn [f coll]\n  (loop [c1 coll\n         m1 {}]\n    (if (empty? c1)\n      m1\n      (let [head (first c1)\n            res (f head)\n            entry (get m1 res)]\n        (recur (rest c1)\n               (assoc m1 res\n                 (if (nil? entry)\n                   [head]\n                   (conj entry head))))))))","user":"585e2e77e4b0f14aab7c87ac"},{"code":"(fn fo\n  ([p xs] (fo p xs {}))\n  ([p [x & xs] m]\n     (if x\n       (let [fx (p x)\n             v (m fx [])]\n         (recur p xs (assoc m fx (conj v x))))\n       m)))","problem":63,"user":"52753740e4b03e8d9a4a74c1"},{"problem":63,"code":"(fn grp-seq [func vals]\n   (into {}\n         (map #(vector (func (first %)) (vec %))\n              (partition-by func (sort vals)))))","user":"605a876be4b000d535e6f53c"},{"problem":63,"code":"(fn [f s]\n  (reduce (fn [groups x]\n            (update-in groups [(f x)] #(concat % [x])))\n          {}\n          s))","user":"56603e5fe4b068f2fe63dc4a"},{"problem":63,"code":"(fn [f s]\n  (loop [r (map f s)\n         m {}\n         s s]\n    (if (empty? r)\n      m\n      (let [rr (rest r)\n            fr (first r)\n            rs (rest s)\n            fs (first s)]\n      (if (m (first r))\n        (recur rr (assoc m fr (conj (m fr) fs)) rs)\n        (recur rr (assoc m fr (conj [] fs)) rs))))))","user":"544e8369e4b0e39780006987"},{"problem":63,"code":"(fn [f xs] (reduce (fn [res x] (assoc res (f x) (conj (get res (f x) []) x))) {} xs))","user":"531792d9e4b08068f379ed5e"},{"problem":63,"code":"(fn [f s]\n    (loop [a_s s m {}]\n          (if (empty? a_s)\n              m\n              (let [x (f (first a_s))]\n                   (if (contains? m x)\n                       (recur (rest a_s) (assoc m x (conj (get m x) (first a_s))))\n                       (recur (rest a_s) (assoc m x [(first a_s)])))))))","user":"5a34f342e4b0ddc586f153d1"},{"problem":63,"code":"(fn\n  [f s]\n  (reduce \n   (fn [a b]\n     (assoc a (f b)\n       (conj (a (f b) []) b)))\n          {} \n   s))","user":"57fedf07e4b0d3187e9009dc"},{"problem":63,"code":"(fn g-b\n  [predic-fun arg-list]\n  (loop [arg-list arg-list\n         r {}]\n    (if (seq arg-list)\n      (let [arg (first arg-list)\n            predicted (predic-fun arg)\n            old-predicted-val (get r predicted)\n            new-predicted-val (if old-predicted-val\n                                (conj old-predicted-val arg)\n                                [arg])]\n        (recur (rest arg-list)\n               (merge r {predicted new-predicted-val})\n               ))\n      r)))","user":"58de563fe4b0a4d5acaab6e3"},{"code":"(fn [f coll] \n (let [keys (map f coll)]\n      (apply merge-with conj\n             (map #(apply hash-map %)\n                  (list* (interleave (distinct keys) (repeat []))\n                         (partition 2 (interleave keys coll))))))\n  )","problem":63,"user":"4ef89fb0535dced4c769f260"},{"problem":63,"code":"(fn grouper [f s](into {} (map #(vector (f (first % )) (vec %)) (partition-by f (sort s)))))","user":"604f4be1e4b0b7ec0ac60ace"},{"problem":63,"code":"(fn [f, coll] (reduce (fn [y, x] (merge-with concat y {(f x) [x]})) {} coll))","user":"56f15eade4b04a395b9a048e"},{"problem":63,"code":"(fn [f s] (reduce (fn [m v] (update-in m [(f v)] #(if (nil? %) [v] (conj % v)))) {} s))","user":"54da46e5e4b024c67c0cf753"},{"code":"#(reduce (fn [a e] \n            (let [v (% e)] \n              (assoc a v (conj (get a v []) e)) )  \n                            )  \n    {} %2 )","problem":63,"user":"4e6dd0f5535d5021c1a895f3"},{"problem":63,"code":"(fn [f my-seq](reduce (fn [m val] (assoc m (f val) (conj (get m (f val) []) val))) {} my-seq))","user":"55d95be7e4b0e31453f64ac9"},{"code":"(fn my-groupby\n  [f coll]\n  (apply merge-with concat {} (map #(hash-map (f %) [%]) coll)))","problem":63,"user":"4fe89297e4b07c9f6fd12c4c"},{"code":"(fn [f coll]\n  (reduce #(merge-with concat %1 %2) {} (map #(hash-map (f %) [%]) coll)))","problem":63,"user":"50481b70e4b0ec70b3ef8d98"},{"problem":63,"code":"(fn [f coll]\n  (reduce (fn [out x]\n            (let\n              [key (f x)\n               val (or (out key) [])\n               val (conj val x)]\n              (assoc out key val)))\n          {}\n          coll))","user":"57fdd1cfe4b0d3187e9009bf"},{"problem":63,"code":"(fn [f s]\n  (into {}\n        (map #(vector (f (first % )) (vec %))\n             (partition-by f (sort s)))))","user":"57de9169e4b0bd073c202454"},{"code":"(fn[f l] \n  (reduce \n    #(assoc %1 (f %2) \n            (conj \n              (get %1 (f %2) []) %2)) (hash-map) l))","problem":63,"user":"51b0fc95e4b0c53cf2e68a72"},{"problem":63,"code":"(fn [f s]\n  (reduce #(let [k (f %2)]\n             (assoc % k (conj (get % k []) %2)))\n          {} s))","user":"58fdbf59e4b0438e51c2cfbc"},{"problem":63,"code":"(fn [f coll] (reduce \n                               (fn [m v]\n                                 (let [k (f v)]\n                                   (assoc m k (conj (get m k []) v))))\n                               {} coll))","user":"5a813b90e4b00b71e582a065"},{"code":"(fn [f c] (reduce #(let [r (f %2)] (conj % [r (conj (get % r []) %2)])) {} c))","problem":63,"user":"4e9609ad535dbda64a6f6b3e"},{"problem":63,"code":"(fn [f s]\n    (reduce\n      (fn [res elem]\n        (let [k (f elem) \n              v (-> (get res k)\n                  (conj elem)\n                  vec)]\n          (assoc res k v)))\n      {}\n      s))","user":"56a358d0e4b0542e1f8d14c9"},{"code":"(fn  [f s]\n  (reduce\n   #(let [v (f %2)]\n      (assoc %1 v (conj (%1 v []) %2)))\n   {} \n   s ))","problem":63,"user":"4ec28d86535dfed6da9c6dbc"},{"problem":63,"code":"(fn [f coll]\n  (reduce (fn [m elem]\n            (let [k (f elem)]\n              (assoc m k (conj (get m k []) elem))))\n          {} coll))","user":"57934c67e4b0e215f87e8456"},{"problem":63,"code":"(fn test33 [fn1 col]\n  (letfn [(f [fn1 col]\n            (partition-by fn1 (sort-by fn1 col)))]\n    (zipmap (map #(fn1 (first %)) (f fn1 col)) (f fn1 col) )))","user":"5804d5afe4b0a837a8b30cad"},{"code":"(fn [f v]\n  (reduce #(merge-with into % {(f %2) [%2]})\n          {}\n          v))","problem":63,"user":"4ebbc1f6535dfed6da9c6d72"},{"code":"(fn [f s] (reduce (fn [m k] (update-in m [(f k)] (fnil #(conj % k) []))) {} s))","problem":63,"user":"4fe900a6e4b0547ebccb243a"},{"code":"(fn [sel coll]\n   (reduce #(let [key (sel %2)] \n                 (if (contains? %1 key ) \n\t\t\t\t\t\t(assoc %1 key (conj (get %1 key) %2) )\n\t\t\t\t\t\t(assoc %1 key [%2] ))) \n\t{} coll ))","problem":63,"user":"523a9fc9e4b081681ca7adca"},{"code":"(fn [f coll]\n    (reduce \n     (fn [my-map elm]\n       \n       (assoc my-map (f elm) (conj (my-map (f elm) []) elm)))\n     {}\n     coll))","problem":63,"user":"518d1b5be4b070277754617b"},{"code":"(fn [f s] (reduce #(assoc %1 (f %2) (conj (apply vector (%1 (f %2))) %2)) {} s))","problem":63,"user":"4dbf7a31535d020aff1edf75"},{"problem":63,"code":"(fn my-groupby\n  [f coll]\n  (reduce #(assoc %1 (f %2) (conj (get %1 (f %2) []) %2))\n          {}\n          coll))","user":"55c423e1e4b0e31453f64994"},{"code":"(fn [f s]\n  (reduce\n    (fn [a b]\n      (let [v (f b)]\n        (if (contains? a v)\n          (assoc a v (conj (a v) b))\n          (assoc a v [b])))) {} s))","problem":63,"user":"51899891e4b0288ada3dbdab"},{"problem":63,"code":"(fn gb [f coll]\n   (apply merge-with into (for [v coll] {(f v) [v]})))","user":"5c411df3e4b08cd430848ebf"},{"code":"(fn [f k] (apply merge-with concat  (map (fn[x] {(f x) [x]}) k)))","problem":63,"user":"4f463dfde4b0d56e7bb92b99"},{"problem":63,"code":"(fn [f s]\n  (loop [remaining s ans {}]\n    (if (empty? remaining)\n      ans\n      (let [[item & remain] remaining]\n        (if (contains? ans (f item))\n          (recur remain (update-in ans [(f item)] conj item))\n          (recur remain (conj ans [(f item) [item]])))))))","user":"5746061ae4b009280f9f2b5b"},{"problem":63,"code":"(fn [f coll] (into {} (map #(vector (f (first % )) (vec %)) (partition-by f (sort coll)))))","user":"59bac5c9e4b0a024fb6ae3ed"},{"problem":63,"code":"(fn [f l] (reduce #(assoc % (f %2) (conj (get % (f %2) []) %2)) {} l))","user":"5c7c1d8ee4b0d597f478ca88"},{"problem":63,"code":"(fn [f s]\n(loop [se\ts res {}]\n(if (empty? se)\nres\n(let [cur-key (f (first se)) cur-val (first se)] (recur (rest se) (if (contains? res cur-key) (assoc res cur-key (conj (get res cur-key) cur-val))\n(assoc res cur-key [cur-val])))))))","user":"5a1c8c26e4b0ff51aa4b3247"},{"code":"(fn [f xs]\n  (reduce #(assoc %1\n           (f %2) (vec (conj (%1 (f %2)) %2)))\n        {} xs))","problem":63,"user":"4f748b54e4b044e54cd9a8fa"},{"problem":63,"code":"#(reduce (fn [roll value] (assoc roll (%1 value) (conj (or (get roll (%1 value)) []) value))) {} %2)","user":"5a9dbb32e4b0d174b936c7f3"},{"problem":63,"code":"(fn [func coll]\n  (apply merge-with concat (map #(hash-map (func %1) [%1]) coll)))","user":"5250a13ee4b0541d1855b839"},{"problem":63,"code":"(fn r [fun col] (loop [fun fun col (reverse col) mp {}]\n                   (if (empty? col)\n                     mp\n                     (recur fun (rest col) (update-in mp [(fun (first col))] #(cons (first col) %))))))","user":"5831846ae4b051871117c02c"},{"problem":63,"code":"(fn my-group-by [fun coll]\n  (reduce #(let [a (fun %2)]\n             (assoc % a (into (vec (get % a)) [%2])))\n          {} coll))","user":"56bf4ac0e4b0f26550335985"},{"code":"(fn [function sequence] \n  (apply (partial merge-with concat) (map (fn [value] {(function value) [value]}) sequence)))","problem":63,"user":"520f46f9e4b0101e4be6fcee"},{"problem":63,"code":"(fn [x z] (let [y (sort-by x z)] (into {} (map (juxt #(x (first %)) identity) (partition-by x y)))))","user":"53fc8424e4b0de5c418485b3"},{"code":"(fn g\n  ([f s] (g f s {}))\n  ([f s m]\n   (loop [s s m m]\n     (if (empty? s)\n       m\n     (let [x (first s)\n           fx (f x)\n           xs (rest s)]\n       (if (contains? m fx)\n         (recur xs (assoc m fx (conj (m fx) x)))\n         (recur xs (assoc m fx [x]))))))))","problem":63,"user":"4e9a1512535dbda64a6f6b6e"},{"problem":63,"code":"(fn [f l]\n  (apply merge-with into (for [v l] {(f v) [v]})))","user":"5a1149ace4b04bbd27e6da26"},{"problem":63,"code":"(fn [f vs] (apply merge-with concat (map (fn [v] {(f v) [v]}) vs)))","user":"5310e968e4b08068f379ecdd"},{"problem":63,"code":"(fn myGroup\n  [fun lst]\n  (apply merge-with into (for [i lst] {(fun i) [i]})))","user":"5f724f55e4b02876ed9fd089"},{"code":"(fn\n  [f s]\n  (apply merge-with concat (for [x s] {(f x) [x]})))","problem":63,"user":"51804bcbe4b04f45bde7d901"},{"code":"(fn [f coll] (reduce #(assoc % (f %2) (conj (get % (f %2) []) %2)) {} coll))","problem":63,"user":"4db92654535d1e037afb21a0"},{"problem":63,"code":"(fn [f s]\n  (loop [s s m {}]\n    (if (empty? s)\n      m\n      (recur (rest s)\n             (let [r (f (first s))]\n               (if (contains? m r)\n                 (into m {r (conj (get m r) (first s))})\n                 (into m {r [(first s)]})))))))","user":"54cad59ee4b057c6fda3a26e"},{"code":"(fn [f x] (apply merge-with concat (for [t x] {(f t) [t]})))","problem":63,"user":"4fbd12a5e4b081705acca2fd"},{"code":"(fn my-group-by [f s]\n  (letfn [(update [m x]\n            (assoc m (f x) (conj (m (f x) []) x)))]\n    (reduce update {} s)))","problem":63,"user":"4f3fb586e4b0e243712b1f9c"},{"problem":63,"code":"(fn [f coll] (reduce #(update-in % [(f %2)] (fnil conj []) %2) {} coll))","user":"4e7e8684535db169f9c79717"},{"problem":63,"code":"(fn [f s] (apply merge-with concat (map #(hash-map (f %) (vector %)) s)))","user":"55253217e4b0882d96d091ce"},{"code":"#(reduce (fn [m y]\n           (let [v (%1 y)]\n             (assoc m v (conj (m v []) y))))\n         {}\n        %2)","problem":63,"user":"4dc21233535d020aff1edf92"},{"problem":63,"code":"(fn [f s]\n    (apply merge-with concat\n           (for [x s] {(f x) [x]})))","user":"4f9b3532e4b0dcca54ed6d13"},{"code":"(fn [function sequence]\n   (loop [f function\n          s sequence\n          coll {}]\n     (if (not (empty? s))\n       (let [val (first s)\n             key (f val)\n             items (get coll (f val) [])]\n         (recur f\n                (rest s)\n                (assoc coll key (conj items val))))\n       coll)\n     ))","problem":63,"user":"52e0e646e4b09f7907dd1416"},{"problem":63,"code":"(fn [f s]\n  (loop [[f1 & r1] s result {}]\n      (if (= nil f1)\n        result\n        (recur r1 (into result (hash-map (f f1) (conj (into [] (get result (f f1))) f1)))))))","user":"5e7f62cce4b085ba37836e3b"},{"code":"(fn [f coll] (persistent!\n  \t\t\t\t(reduce\n                (fn [ret x]\n                  (let [k (f x)]\n                    (assoc! ret k (conj (get ret k []) x))))\n                (transient {}) coll)))","problem":63,"user":"52a5a8ebe4b0c58976d9abed"},{"code":"(fn [f s]\n  (reduce #(merge-with concat %1 {(f %2) [%2]}) {} s))","problem":63,"user":"5191ac45e4b0d428d29dc1b6"},{"problem":63,"code":"(fn [f coll] (reduce (fn [m el] (let [k (f el)] (assoc m k (conj (get m k []) el)))) {} coll))","user":"53629381e4b0243289761e54"},{"code":"(fn my-group-by [f coll]\n  (reduce\n   (fn [a b]\n     (assoc a (f b) (vec (conj (get a (f b)) b)))) {} coll))","problem":63,"user":"4e7f51eb535db966e863cc3f"},{"problem":63,"code":"(fn ans-63 [f arr]\n  (reduce\n   (fn [acc item]\n     (merge-with\n      concat\n      acc {(f item) [item]}))\n   {}\n   arr))","user":"608fac60e4b03bd49d9f36c7"},{"code":"#(loop [ l1 %2 l2 {} ] \n   (if (empty? l1) \n     l2 \n     (recur (rest l1)\n           (let [ h (first l1) r (%1 h)]\n             (if (= nil (find l2 r)) \n               (assoc l2 r (vector h)\n               )\n               (assoc (dissoc l2 r) r (conj (l2 r) h)\n               )\n             )\n           )\n      )\n   )\n )","problem":63,"user":"535a18e3e4b04ce2eb3ed2a4"},{"problem":63,"code":"(fn [f s]\n  (reduce (fn [x y] (let [comb #((fnil conj []) %1 %2)]\n                      (update-in x [(f y)] comb y))) {} s))","user":"538f4c1de4b0b51d73faae8c"},{"code":"(fn [f s]\n  (reduce #(merge-with concat %1 %2) (map #(assoc {} (f %) [%]) s))\n)","problem":63,"user":"524c7fcfe4b0752c4cb68cbd"},{"problem":63,"code":"(fn[x y](zipmap\n           (map x(map first (partition-by x (sort-by x y))))\n           (partition-by x (sort-by x y))\n           ))","user":"5c683fb5e4b0fca0c16226d5"},{"code":"#(->> (map  (juxt % identity) %2) \n      (reduce (fn [m [k v]] (assoc m k (conj (get m k []) v))) {}) )","problem":63,"user":"519ef784e4b087743fad2198"},{"problem":63,"code":"(fn [f c]\n   (reduce (fn [m e]\n                (let [k (f e)\n                      old (get m k)]\n                  (assoc m k (vec (conj old e))))) {}  c))","user":"5033ed65e4b062bc5d7ae15a"},{"code":"(fn [f n] (reduce #(merge-with into % {(f %2) [%2]}) {} n))","problem":63,"user":"4f437751e4b0d7d3c9f3fd20"},{"code":"(fn [f s]\n  (reduce\n   (fn [x y]\n     (let [r (f y)]\n       (assoc x r (conj (get x r []) y))))\n   {} s))","problem":63,"user":"53468f6ce4b084c2834f4a3f"},{"problem":63,"code":"(fn [f coll]\n  (loop [c coll\n         r {}]\n    (if (empty? c)\n      r\n      (recur\n        (rest c)\n        (assoc r (f (first c)) (into [] (concat (get r (f (first c))) [(first c)])))))))","user":"590253e3e4b0438e51c2d055"},{"problem":63,"code":"(fn my-group-by [pred coll]\n  (reduce \n   (fn [dict m]\n     (let [ret (pred m)]\n       (assoc dict ret (conj (or (dict ret) []) m))))\n    {} coll))","user":"584b6a2be4b089d5ab817efd"},{"problem":63,"code":"(fn [f s]\n        (reduce\n         (fn [map x]\n           (let [key (f x)]\n             (assoc map key\n                    (conj (get map key []) x))))\n         {} s))","user":"57e6f90de4b0bfb2137f5af6"},{"code":"(fn [f s]\n     (loop [f f s s m {}]\n      (if (empty? s) m\n       (recur f (rest s) (if (get m (f (first s))) \n                          (assoc m (f (first s)) (conj (get m (f (first s))) (first s) ))\n                          (assoc m (f (first s)) [(first s)])))))\n\n\n    )","problem":63,"user":"5029fccee4b023940c84aa47"},{"problem":63,"code":"(fn my-group-by [f coll]\n  (apply merge-with concat (map (fn [x] {(f x) [x]}) coll)))","user":"5e805895e4b085ba37836e44"},{"code":"(fn [f s]\n  (reduce\n   (fn [m item]\n     (let [v (f item)]\n       (assoc m v (conj (get m v []) item))))\n   {}\n   s))","problem":63,"user":"4ffc10aae4b0678c553fc3d6"},{"code":"(fn [kf vs] (reduce #(assoc % (kf %2) (conj (get % (kf %2) []) %2)) {} vs))","problem":63,"user":"513f0565e4b051389b345b3b"},{"problem":63,"code":"(fn x\n  ([f s] (x f s {}))\n  ([f s m]\n   (if (empty? s) m \n     (recur f\n            (rest s)\n            (let [k (f (first s))]\n              (conj m [k (conj (if (contains? m k) (m k) []) (first s))])\n              )\n            )\n     )\n   )\n  )","user":"5a3c2a08e4b001c08efc0cdf"},{"code":"#(loop [l %2 m {}]\n  (cond (empty? l) m\n        (contains? m (%1 (first l)))\n          (recur (rest l) (assoc m (%1 (first l)) (conj (m (%1 (first l))) (first l))))\n        :else (recur (rest l) (assoc m (%1 (first l)) [(first l)]))))","problem":63,"user":"4fae258de4b081705acca246"},{"problem":63,"code":"(fn [f x](apply merge-with concat (map #(hash-map %1 [%2]) (map f x) x)))","user":"5585f088e4b001b0851d7513"},{"problem":63,"code":"(fn [f coll] (->> coll \n                  (map #(vector % (f %)))\n                  (reduce \n                   (fn [c pair] \n                     (let [[e r] pair] \n                       (assoc c r \n                         (if (nil? (get c r)) \n                           (vector e) \n                           (conj (get c r) e))))) \n                   {})))","user":"54361d92e4b032a45b8692f7"},{"code":"(fn [f s] (let [v (partition 2 (interleave (map f s) s))\n                       d (distinct (map #(first %) v))\n                       g (map (fn [m] (vec (map #(last %) (filter (fn [k] (= (first k) m)) v)))) d)\n                      ]\n                      (zipmap d g)))","problem":63,"user":"4f03f197535dcb61093f6b84"},{"problem":63,"code":"(fn [f arr] \n    (apply \n        (partial merge-with concat) \n        (for [x arr :let [y (f x)]] {y [x]})))","user":"56be8649e4b0f26550335983"},{"problem":63,"code":"(fn [f coll]\n  (reduce (fn [acc n]\n            (let [res (f n)]\n              (if (get acc res)\n                (update-in acc [res] conj n)\n                (assoc acc res [n])))) {} coll))","user":"5fe1b893e4b05ac5b16ea16f"},{"code":"(fn [f els]\n  (let [m  (apply hash-map (vec  (interleave (distinct (vec (map f els))) (repeat (count (distinct els)) []))))\n        getkey (fn [el] (f el))]\n    (reduce #(assoc %1 (getkey %2) (conj (%1 (getkey %2)) %2 ))\n            m\n            els)))","problem":63,"user":"5154fa3fe4b0179c5115f4e6"},{"code":"(fn [f s] \n  (apply merge-with concat {} (map (fn [x] {(f x) [x]}) s)))","problem":63,"user":"5025b93ce4b0c969f0b056df"},{"problem":63,"code":"(fn [f s]\n  (apply merge-with concat (map (fn [x] {(f x) [x]}) s)))","user":"5b602a66e4b0c6492753e6fc"},{"code":"(fn [f coll]\r\n  (reduce (fn [r v]\r\n            (let [k (f v)]\r\n              (if (r k)\r\n                (conj r [k (conj (r k) v)])\r\n                (conj r [k [v]]))))\r\n          {}\r\n          coll))","problem":63,"user":"4de2f44f535d08e6dec9fdec"},{"problem":63,"code":"(fn [f coll]\n    (let [reslist (map #(f %) coll)\n          dislist (distinct reslist)]\n        (into {}\n              (for [x dislist]\n             [x (filterv #(= x (f %)) coll)]))))","user":"59089229e4b047aa04b1997c"},{"code":"(fn [f coll]\n  (loop [c coll ret {}]\n    (if c\n    (let [r (-> c first f)]\n  (recur (next c) (assoc ret r (conj (or (ret r) []) (first c)))))\nret)))","problem":63,"user":"4eb27fad535d7eef3080734a"},{"problem":63,"code":"(fn [f s]\n    (reduce (fn [m value]\n                (update-in m [(f value)] #(vec (conj % value)))) {} s))","user":"5f331015e4b0574c87022c37"},{"problem":63,"code":"(fn g\n\n    ([f xs] (g f xs {}))\n\n    ([f xs mp]\n\n     (if (empty? xs)\n\n        mp\n\n        (let [fst (first xs)\n\n              old (or (mp (f fst) []))\n\n              nmp (assoc mp (f fst) (into old (vector fst)))]\n\n          (g f (next xs) nmp)))))","user":"57487084e4b009280f9f2b8c"},{"problem":63,"code":"(fn\n    [f xs]\n\n    (let\n      [\n        pairs\n        (map\n          (fn [v]\n            [\n              (f v)\n              v\n            ]\n          )\n          xs\n        )\n        keys\n        (set\n          (map first pairs)\n        )\n      ]\n      (apply hash-map\n        (mapcat\n          (fn [k]\n            [\n              k\n              (apply vector\n                (map second\n                  (filter\n                    (fn [p]\n                      (= (first p) k)\n                    )\n                    pairs\n                  )\n                )\n              )\n            ]\n          )\n          keys\n        )\n      )\n    )\n  )","user":"5784e177e4b0ebec4cfb74cf"},{"code":"(fn gb [f s]\n  (let [c (fn [m v]\n            (let [k (f v)]\n              (conj m\n                [k (if (contains? m k)\n                    (conj (m k) v)\n                    [v])])))]\n    (reduce c {} s)))","problem":63,"user":"503a234de4b088a6a14ca76d"},{"problem":63,"code":"(fn [f s]\n  (reduce (fn [rmap x]\n            (assoc rmap (f x) (conj (get rmap (f x) [])\n                                            x)))\n          {}\n          s))","user":"557e56aae4b05c286339e0d5"},{"code":"(fn [f s]\n  (reduce\n    #(let [key (f %2) value (% key [])]\n     (assoc % key (conj value %2)))\n    {}\n    s))","problem":63,"user":"4f01ff83535dcb61093f6a3a"},{"problem":63,"code":"(fn gp2 [f coll]\n  (reduce\n   (fn [m val]\n     (let [key (f val)\n           coll (m key)]\n       (if coll\n         (assoc m key (conj coll val))\n         (assoc m key (vector val)))))\n   (hash-map)\n   coll))","user":"5eccc5c2e4b016b56eae058f"},{"problem":63,"code":"(fn ans [f s] (reduce (fn [m a] (let [ans (f a)]\n                                   (if (contains? m ans)\n                                     (assoc m ans (conj (m ans) a))\n                                     (assoc m ans [a]))\n                                  ))\n                       {} s))","user":"565233f2e4b0f9d632dd8461"},{"problem":63,"code":"(fn  [f seq]  (reduce #(assoc %1 (f %2) ((comp vec conj) (get %1 (f %2)) %2)) {} seq))","user":"570ab24fe4b0b0fb43fd06b7"},{"problem":63,"code":"#(reduce (fn [m v]\n            (let [value     (or (get m (first v)) [])\n                  new-value (conj value (second v))]\n              (assoc m (first v) new-value))) {} \n          (for [x %2]\n            [(%1 x) x]))","user":"5dc53ddee4b02f9375f4e1bd"},{"problem":63,"code":"(fn t[f coll] (->>(partition-by f (sort coll))\n  (map (fn[lst] [(f (first lst)) lst])) \n  (into {}) ))","user":"59135c11e4b0163c97b36f02"},{"code":"(fn [f c]\r\n  (loop [c c, acc {}]\r\n    (if (seq c)\r\n      (recur (rest c)\r\n             (let [n (first c)\r\n                   r (f n)]               \r\n                 (merge acc {r (if (contains? acc r) \r\n                        (conj (acc r) n)\r\n                        [n])})\r\n          ))\r\n      acc)))","problem":63,"user":"4dbb1126535d1e037afb21b3"},{"problem":63,"code":"(fn [f x]\n  (into {}\n        (map #(vector (f (first % )) (vec %))\n             (partition-by f (sort x)))))","user":"55630cc1e4b0c656e3ff17e0"},{"problem":63,"code":"(fn [f coll]\n  (reduce \n   (fn [m x] (assoc m (f x) (conj (or (m (f x) [])) x)) )\n   {} coll)\n)","user":"5aa998c6e4b0d174b936c8e5"},{"code":"(fn g [f xs]\n  (loop [acc {} \n         xs xs]\n    (if (empty? xs)\n      acc\n      (let [x (first xs)]\n        (recur (update-in acc [(f x)] #(conj (or % []) x)) (next xs))))))","problem":63,"user":"4e4c238f535dc968683fc4dc"},{"code":"(fn [f ls]\n  (reduce\n   #(merge-with concat % { (f %2) [%2] })\n   {}\n   ls))","problem":63,"user":"52379c46e4b0fae3832e99db"},{"problem":63,"code":"(fn [f s]\n  (reduce\n    (fn [r e] (merge-with concat r (assoc {} (f e) [e])))\n    {}\n    s))","user":"5989e080e4b021a7a535fed6"},{"problem":63,"code":"(fn my-group-by [op sqn]\n  (reduce\n   (fn [m k]\n     (update-in m [(op k)] (fnil conj []) k)) {} sqn))","user":"541475afe4b01498b1a719eb"},{"problem":63,"code":"(fn [f xs]\n    (reduce \n     (fn [m x]\n       (let [key (f x)\n             vs (get m key [])]\n         (assoc m key (conj vs x))))\n     {}\n     xs))","user":"55568a7de4b0deb715856e1c"},{"problem":63,"code":"(fn [f sq]\n          (reduce (fn [result s]\n                    (let [key (f s)\n                          val (get result key)]\n                      (assoc result key\n                             (conj (vec val) s)))) {} sq))","user":"5c995fa4e4b048ec896c5a96"},{"problem":63,"code":"(fn\n  [f arr]\n  (apply merge-with concat\n       (map (fn [item]\n              (hash-map (f item) [item]))\n            arr)))","user":"59cd13d5e4b0ef0a1e9b5b32"},{"problem":63,"code":"(fn grpby [fun src]\n   (reduce\n    #(assoc\n      %1\n      (nth %2 1)\n      (vec (conj (%1 (nth %2 1)) (nth %2 0))))\n    {}\n    (map\n     (fn zm [a b]\n       (conj '() a b))\n     (map fun src)\n     src)))","user":"5d5c6675e4b09db18d4482ec"},{"problem":63,"code":"(fn [f s] (reduce (fn [m v] (update-in m [(f v)] (fn [coll] (conj (vec coll) v))))\n                        {}\n                        s))","user":"547d66a1e4b0c51c1f4d72f2"},{"problem":63,"code":"(fn group [f s]\n  (reduce #(assoc % (f %2) (concat (% (f %2)) [%2]))\n          {}\n          s))","user":"5146f343e4b04ef915e3731e"},{"problem":63,"code":"(fn [f s](reduce (fn [m x] (assoc m (f x) (conj (m (f x) []) x))) {} s))","user":"5bfe4ecfe4b0bdcf453d1608"},{"problem":63,"code":"(fn m-group [func l]\n  (loop [f func\n         s l\n         dict {}]\n    (if s\n      (let [e (first s)\n            result (f e)]\n        (recur f\n               (next s)\n               (assoc dict result (concat (get dict result []) [e]))))\n      dict)))","user":"51d55598e4b01da06753aa8e"},{"code":"(fn my-group-by [f s]\r\n    (if (empty? s)\r\n      {}\r\n      (merge-with concat {(f (first s)) (list (first s))} (my-group-by f (rest s)))))","problem":63,"user":"4f039524535dcb61093f6b2c"},{"code":"(fn [f col]\n  (apply (partial merge-with concat)\n         (map #(hash-map (f %) [%]) col)))","problem":63,"user":"50ccf729e4b0f7a459302aac"},{"problem":63,"code":"(fn blah [f xs]\n  (apply merge (for [[k v] (loop [xs xs, acc {}]\n                             (if (empty? xs)\n                               acc\n                               (recur (rest xs)\n                                      (let [x (first xs)\n                                            fx (f x)]\n                                        (assoc acc fx (conj (acc fx) x))))))]\n                 {k (reverse v)})))","user":"547ad587e4b0c51c1f4d72ce"},{"problem":63,"code":"(fn\n  [f coll]\n  (loop [f f coll coll out {}]\n    (cond (empty? coll) out\n          :else (recur f (rest coll) (assoc out (f (first coll)) (conj (get out (f (first coll)) []) (first coll)))))))","user":"57acee37e4b0b8559636fc94"},{"code":"(fn [f coll]\n  (reduce (fn [acc v]\n            (merge-with concat acc {(f v) [v]}))\n          {}\n          coll))","problem":63,"user":"51a9dbc9e4b04e3dc0c27b1e"},{"problem":63,"code":"(fn grp[a coll](loop[coll coll\n                       ret {}]\n                   (prn coll ret)\n                   (cond\n                     (empty? coll) ret\n                     :else(recur (rest coll)\n                                 (assoc ret (a (first coll)) (conj (vec(ret (a (first coll)))) (first coll)))))))","user":"5dadf73ee4b0f8c104ccfc86"},{"problem":63,"code":"(fn [f xs]\n  (reduce\n   (fn [m x]\n     (let [fx (f x)]\n      (assoc m fx (conj (get m fx []) x))\n     )\n   )\n   {} ; initial value\n   xs\n  )\n)","user":"543bb568e4b032a45b869334"},{"problem":63,"code":"(fn mgb [f xs]\n  (loop [xs1 xs ms {}]  \n    \n      (if (empty? xs1)\n        ms\n        (recur \n           (rest xs1)\n           (let [fval (f (first xs1))]\n             (assoc \n               ms \n               fval\n               (conj (if (nil? (ms fval)) [] (ms fval))  (first xs1)) \n              )\n            )\n         )\n       )\n     \n   )\n  \n )","user":"5885e90de4b0f1effa3b76c5"},{"problem":63,"code":"(fn [f c] (let [p (partition-by f (sort-by f c))]\n             (zipmap (map #(f (first %)) p) (vec p))))","user":"5ddd6cfae4b0948ae9d9adc4"},{"problem":63,"code":"(fn [f xs]\n  (reduce (fn [res x]\n            (assoc res (f x) (conj (get res (f x) []) x)))\n          {} xs))","user":"5d81eba4e4b0915913b1d37b"},{"code":"(fn [f s]\n\t(let [x (map #(vector (f %) %) s)]\n      (reduce (fn [s [k v]] (assoc s k (conj (get s k []) v))) {} x)))","problem":63,"user":"50d93c53e4b0fd36a4b89223"},{"problem":63,"code":"(fn [func vals]\n  (into {} (map #(vector (func (first %)) (vec %))\n        (partition-by func (sort vals)))))","user":"501b1efee4b0b12d9c5f4d82"},{"problem":63,"code":"(fn sol2 [f l] (letfn [(join [res x] (let [key (first x) value (second x)]\n                                             (assoc res key (conj (get res key []) value))))\n                        (reducer [res x] (let [key (first x) value (second x)]\n                                                (if (res key) (join res x) (assoc res key [value])) ))\n                         ](->> (map vector (map f l) l) (reduce reducer {}))))","user":"54857657e4b0e286459a11ac"},{"code":"(fn [f, coll]\n  (loop [m {} coll coll]\n    (if (empty? coll)\n      m\n      (let [v (first coll)\n            k (f v)\n            curr (get m k [])]\n        (recur (assoc m k (conj curr v)) (rest coll))))))","problem":63,"user":"4e22b78b535d04ed9115e81e"},{"code":"(fn soln [f s]\n  (if (= '() s)\n    {}\n    (let [m (soln f (rest s))\n          v (f (first s))]\n      (assoc m v (conj (m v) (first s))))))","problem":63,"user":"50b668dde4b08fb537db98f2"},{"problem":63,"code":"(fn [f xs]\n  (apply merge-with into (for [x xs] {(f x) [x]})))\n\n\n;; each map key is the value of applying the function to the current value;; false is a key, [ 1 3] is value\n;; each value is the value placed into a vector (to match the structure of the required result);; value [1 3] placed in a vector;;;\n\n\n;; `for` - list comprehension\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;; f is the function passed as an argument\n;; xs is the collection passed as an argument\n;; x is the individual value pulled from the collection by `for`\n\n;; Then merge the result of the `for` function\n;; giving a unique set of keys with a vector of the combined values\n;; `merge-with` called with `into` will create the desired result;; into keeps the same structure, merge-with returns unique keys","user":"5ce5b43be4b0a17bb84e2b7a"},{"problem":63,"code":"(fn [f coll] (persistent! (reduce #(assoc! %1 (f %2) (conj (get %1 (f %2) []) %2)) (transient {}) coll)))","user":"531a0709e4b08068f379ed87"},{"code":"(fn [f c] (apply (partial merge-with concat) (map #(assoc {} (f %) [%]) c)))","problem":63,"user":"50fe91c1e4b03cd852b4e84e"},{"code":"(fn grouping\n  [func coll]\n  (let [a (distinct (map func coll))\n        b  (fn [func coll truth] (apply vector (filter #(= truth (func %)) coll)))]\n         (reduce #(assoc % %2 (b func coll %2)) {} a)))","problem":63,"user":"5245d29ae4b09dbe66b56174"},{"problem":63,"code":"(fn [f s]                                                        \n  (into {} (for [k (set (map f s))]                                    \n    [k (filter #(= k (f %)) s)])))","user":"54f4adc8e4b0f2f3c5226e86"},{"problem":63,"code":"(fn foo [f s]\n (apply merge-with (fn[merged new]\n                              (into []\n                              (concat merged new)))\n(map (fn[k v] {k [v]}) (map f s) s)))","user":"52faf67ce4b047fd55837005"},{"code":"(fn[f s](reduce\r\n  #(assoc%(f%2)(conj(%(f%2)[])%2)){}s))","problem":63,"user":"4dd66da7535d2dad7130b5c8"},{"code":"(fn bitchin [f s]\n  (reduce #(update-in %1 [(f %2)] (fnil conj []) %2)\n          {} s))","problem":63,"user":"4faa8de0e4b081705acca1f8"},{"code":"(fn [f s] (reduce (fn [acc x] (assoc acc (f x) (conj (get acc (f x) []) x))) {} s))","problem":63,"user":"52ab51c4e4b0c58976d9ac73"},{"problem":63,"code":"(fn \n  [f seq]\n  (reduce (fn [res, x]\n            (let [key (f x)\n                  val x]\n              (if (contains? res key)\n                (assoc res key (conj (res key) val))\n                (assoc res key (vector val)))))\n          {}\n          seq))","user":"5cf938a5e4b0b71b1d808a90"},{"code":"#(let [r (partition-by % (sort-by % %2)) k (into [] (map % (map first r)))] (zipmap k r))","problem":63,"user":"52b5edd1e4b0c58976d9ad3c"},{"code":"(fn [f m] (reduce #(assoc % (f %2) (conj (% (f %2) []) %2)) {} m))","problem":63,"user":"4fa30027e4b081705acca187"},{"problem":63,"code":"(fn\n  [f lst]\n  (->> (for [i lst] {(f i) (vector i)})\n       (apply merge-with concat)))","user":"56df6498e4b0ca2494a095f8"},{"code":"(fn [f coll]\n  (reduce\n    (fn [dist it]\n      (assoc \n        dist \n        (f it)\n        (conj (get dist (f it) []) it)))\n    {}\n    coll))","problem":63,"user":"4f504739e4b03ad3f0c10d00"},{"problem":63,"code":"(fn [f i]\n   (loop [input i\n          result {}]\n     (if (first input)\n       (recur (rest input)  (update-in result [(f (first input))]  (comp vec  conj)  (first input)))\n       result)))","user":"546b24a0e4b00cfc9eacc166"},{"code":"(fn my-group-by\n  [f s]\n  (reduce (fn [acc i]\n            (let [index (f i)\n                  vals (get acc index [])]\n              (assoc acc index (conj vals i))))\n          {} s))","problem":63,"user":"52dd6cc8e4b09f7907dd13e2"},{"code":"(fn [f coll]\r\n  (reduce (fn [acc x] \r\n            (let [v (f x)]\r\n              (assoc acc v (conj (get acc v []) x))))\r\n          {} coll))","problem":63,"user":"4fb37882e4b081705acca2a0"},{"problem":63,"code":"(fn [f coll]\n  (reduce (fn [acc x]\n            (let [k (f x)\n                  v (acc (f x) [])]\n              (assoc acc k (conj v x))))\n          {}\n          coll))","user":"5db5d09be4b010eb3c36cd31"},{"code":"(fn [f coll]\n  (reduce \n    (fn [m e] \n      (let [grp (f e)\n            vs (vec (conj (get m grp) e))]\n        (assoc m grp vs)))\n    {} coll))","problem":63,"user":"4ed7b617535d10e5ff6f52f3"},{"code":"(fn [f s]\n  (let [d (map (fn [x] [(f x) x]) s)\n        mk (zipmap (distinct (map first d)) (repeat []))]\n    (reduce (fn [acc, e] (update-in acc [(first e)] conj (second e))) mk d)))","problem":63,"user":"5003deb9e4b0678c553fc445"},{"code":"(fn [f xs]\n  (reduce\n   (fn [acc x]\n      (let [key (f x)]\n        (assoc acc key (conj (get acc key []) x))))\n   {}\n   xs))","problem":63,"user":"5173726be4b098276e74652c"},{"code":"#(when-let [s (seq %2)]\n  (reduce\n    (fn [m1 m2]\n      (let [e (first m2)\n            k (key e)\n            v (val e)]\n        (if-let [vec (m1 (key e))]\n          (assoc m1 k (conj vec v))\n          (assoc m1 k (vector v)))))\n    {}\n    (map (fn [x] {(%1 x) x}) s)))","problem":63,"user":"50464831e4b011c5dfee771f"},{"code":"(fn [f coll] (apply merge-with concat (for [e coll] {(f e) [e]})))","problem":63,"user":"5098f5d6e4b0cae2931060a4"},{"problem":63,"code":";(fn func\n;  ([f coll]\n;   (func f (map f coll) coll))\n;  ([f key value]\n;    (apply merge-with into (map hash-map key (map vector value)) ))\n;  )\n\n#(apply merge-with into(for [value %2] {(% value) [value]}))","user":"5cd4e1b2e4b0ccb061962927"},{"problem":63,"code":"(fn solution [f s]\n  (reduce #(let [key (f %2)\n                 value (get %1 key)]\n             (assoc %1 key (concat value (vector %2)))\n             ) {} s))","user":"5e2ef900e4b05b4b015161fc"},{"problem":63,"code":"(fn [op l]\n  (let [vs (set (map op l))]\n    (->> (for [x vs]\n           [x (filter #(= x (op %)) l)])\n         (into {}))))","user":"54848141e4b0e286459a119e"},{"code":"(fn\n  [f coll]\n  (persistent!\n   (reduce\n    (fn [ret x]\n      (let [k (f x)]\n        (assoc! ret k (conj (get ret k []) x))))\n    (transient {})\n    coll)))","problem":63,"user":"509b152be4b0412cdea6eb1e"},{"problem":63,"code":"(fn [f f1]\n  \n  (reduce\n   (fn [f2 f3]\n     \n     (let [i (f f3)]\n       \n      (assoc f2 i (conj (get f2 i []) f3))))\n   \n   {} f1\n   )\n  )","user":"5f727be9e4b02876ed9fd08d"},{"problem":63,"code":"(fn my-group-by [f col]\n (persistent! (reduce (fn [new-col x] (let [k (f x)]\n            (assoc! new-col k (conj (get new-col k []) x )))) \n                    (transient {}) col )))","user":"55c9bc1ee4b0e31453f649f1"},{"code":"(fn group-sequence [fun lst]\r\n  (loop [s lst acc {}]\r\n    (if (empty? s)\r\n      acc\r\n      (let [v (first s)\r\n            k (fun v)]\r\n        (if (not (contains? acc k))\r\n          (recur (rest s) (assoc acc k [v]))\r\n          (recur (rest s) (assoc acc k (conj (acc k) v))))))))","problem":63,"user":"4f629697e4b0defedf855fd6"},{"code":"(fn [f coll]\n  (loop [xs coll out {}]\n    (if-let [x (first xs)]\n      (recur (rest xs) (assoc out (f x) (if-let [v (get out (f x))]\n                                          (conj v x)\n                                          [x])))\n      out)))","problem":63,"user":"523ea111e4b057c4b7cd0a65"},{"code":"(fn [f _l]\n  (loop [\n         acc {} \n         l _l\n         ]\n    (let [\n         n (first l)\n         k (f n) \n         fil #(= (f %) k) \n         vs (filter fil l) \n         mvs (filter (complement fil) l)\n         nextacc (assoc acc k vs)]\n      (if (= 0 (count mvs))\n          nextacc\n          (recur nextacc mvs)))))","problem":63,"user":"4f05a9cf535dcb61093f6bfc"},{"code":";(fn [f xs]\n;  (loop [xs (reverse xs)\n;         ny-map {}]\n;    (if (empty? xs)\n;      ny-map\n;      (let [fxs (first xs)\n;            ffxs (f fxs)]\n;        (recur (rest xs) (assoc ny-map ffxs (vec (cons fxs (get ny-map ffxs)))))))))\n\n(fn [f xs]\n  (reduce (fn [m v]\n    (let [k (f v)]\n      (assoc m k (conj (get m k []) v)))) {} xs))","problem":63,"user":"4f07c8c3535dcb61093f6c2d"},{"problem":63,"code":"(fn [f ar]\n      (reduce (fn [h i]\n                (let [k (f i)]\n                  (assoc h\n                         k\n                         (conj (get h k [])\n                               i))))\n              {}\n              ar))","user":"50a3ad0ee4b0ceace084d493"},{"problem":63,"code":"(fn [f s] (apply merge-with into (for [x s] {(f x) [x]})))","user":"5b008bcae4b0cc2b61a3bd3d"},{"code":"(fn t1\n  \n  [f coll]  \n  (persistent!\n   (reduce\n    (fn [ret x]\n      (let [k (f x)]\n        (assoc! ret k (conj (get ret k []) x))))\n    (transient {}) coll)))","problem":63,"user":"4ea85846535d7eef308072f9"},{"problem":63,"code":"#(reduce\n  (fn [m x] \n    (conj m [(%1 x) (vec (conj (get m (%1 x)) x))]))\n  {}\n  %2)","user":"5fa96ddbe4b0fa27300f3dec"},{"problem":63,"code":"(fn gby\n  ([f s] (gby f s {}))\n  ([f s ret]\n    (if (empty? s) ret\n      (let [\n        v (first s)\n        res (f v)\n        vals (if (contains? ret res)\n          (conj (ret res) v)\n          [v] )\n        ] (gby f (rest s) (into ret [[res vals]])) ))))","user":"57539e04e4b02ea1147992ab"},{"code":"(fn [f list] \n  (reduce (fn [m [k v] ]\n            (if (contains? m k)\n              (assoc m k (conj (m k) v))\n              (assoc m k [v]))) \n          {}\n          (for [x (map #(vector (f %) %) list)] \n            x)))","problem":63,"user":"5073de20e4b054001656acca"},{"code":"(fn [f s] (let [res (for [x s] [(f x) x])\n                fnc (fn [m [k v]] (assoc m k (conj (get m k []) v)))]\n            (reduce fnc {} res)))","problem":63,"user":"4efd8b67535de96065cf5085"},{"problem":63,"code":"#(apply merge-with into (for [l %2] {(% l) [l]}))","user":"5e950310e4b0fbed045a3802"},{"problem":63,"code":"(fn [f l] \n  (reduce \n   (fn [m [e1 e2]] \n      (assoc m e2 (conj (get-in m [e2] []) e1))\n     )\n   {}\n   (map #(list % (f %)) l)\n   )\n  )","user":"52503747e4b0541d1855b828"},{"problem":63,"code":"(fn [f xs] (reduce #(update-in %1 [(f %2)] (comp vec conj) %2) {} xs))","user":"56795deae4b05957ce8c6187"},{"problem":63,"code":"#(apply hash-map (interleave (distinct (mapv % %2)) (partition-by % (sort %2))))","user":"58173722e4b0c0e9c07b838a"},{"code":"(fn [f coll]\n  (let [ks (set (map f coll))\n        vs (map (fn [k] \n                  (filter #(= k (f %)) coll))\n                ks)]\n    (reduce (fn [m kv]\n              (apply #(assoc m %1 %2) kv))\n            {} (map vector ks vs))))","problem":63,"user":"4e4b4564535dc968683fc4d3"},{"problem":63,"code":"(fn [f xs] (reduce #(merge %1 {(f %2) (conj (get %1 (f %2)  [])  %2)}) {} xs))","user":"557954aae4b05c286339e092"},{"problem":63,"code":"(fn [f s]\n  (reduce (fn [acc x]\n            (let [k (f x)]\n              (assoc acc k (conj (get acc k []) x))\n            )\n          )\n          {} s)\n  )","user":"54e5bdf2e4b024c67c0cf7fe"},{"code":"(fn [f xs]\n  (reduce (partial merge-with concat)\n          (map (partial apply  hash-map)\n               (partition 2 (interleave (map  f xs) (map vector xs))))))","problem":63,"user":"5220bc0fe4b0e6a83c8925a7"},{"problem":63,"code":"(fn my-group-by [f s]\n  (letfn [(get-singleton-maps [f s] \n                              (for [[k v] (partition 2 (interleave (map f s) s))]\n                                {k [v]}))]\n    (apply merge-with (cons into (get-singleton-maps f s)))))","user":"53504fe6e4b084c2834f4ada"},{"code":"(fn [f coll](reduce (fn [acc i](assoc acc (f i) (conj (get acc (f i)) i))) (zipmap (distinct (map f coll)) (repeat [])) coll))","problem":63,"user":"511ac026e4b0c87c59c9670e"},{"problem":63,"code":"(fn my-groupby\n  [f col]\n  (let [result (map (fn [x] [(f x) x]) col)]\n    (reduce\n     (fn [m [k v]]\n       (update-in m [k] (fn [vs]\n                     (vec (conj vs v)))))\n     {}\n     result)))","user":"5369d072e4b0243289761ea1"},{"problem":63,"code":"(fn my-group-by [f v]\n  (loop [rst v result {}]\n    (if (empty? rst)\n      result\n      (let [arg (first rst)\n            val (f arg)\n            entry (result val)\n            newentry (if (nil? entry) [arg] (conj entry arg))]\n        (recur (rest rst) (assoc result val newentry))))))","user":"5f2c94b4e4b033932238a669"},{"problem":63,"code":"(fn [f coll] (apply merge-with concat (map #(hash-map (f %1) [%1]) coll)))","user":"594c0bd7e4b07ddc2dafae56"},{"problem":63,"code":"(fn grp-by [f xs]\n  (let [g (fn anon [m f xs]\n            (if (empty? xs) m\n              (let [x (first xs)\n                    fx (f x)\n                    v (m fx)]\n                (anon \n                  (conj m [fx (vec (conj v x))])\n                  f \n                  (rest xs)))))]\n    (g {} f xs)))","user":"57d1d6c8e4b0bd073c202370"},{"problem":63,"code":"(fn fun [x y] (if (not= y (empty y)) (let [z (x (first y)) w (into [] (filter #(= z (x %)) y) ) q (filter #(not= z (x %)) y)] (into {z w} (fun x q)))))","user":"540479e7e4b0addc1aec665a"},{"code":"(fn [f s]\n  (reduce (fn [m x]\n            (let [y (f x)]\n              (assoc m y (conj (get m y []) x))))\n          {} s))","problem":63,"user":"4f49e869e4b0d56e7bb92c02"},{"code":"(fn [f s]\n  (loop [[fst & rst] s acc {}]\n    (if (nil? fst)\n      acc\n      (recur\n       rst\n       (merge-with concat acc {(f fst) [fst]})))))","problem":63,"user":"4f3d83b5e4b0e243712b1f69"},{"code":"(fn f63 [f l]\n  (if (empty? l) {}\n    (let [fl (first l) ky (f fl) rm (f63 f (rest l))]\n      (if (contains? rm ky)\n        (update-in rm [ky] (fn [e] (cons fl e)))\n        (assoc rm ky [fl])\n        ))))","problem":63,"user":"52faec2ee4b047fd55837004"},{"code":"(fn gb [f c] (apply merge-with into (map #(hash-map % [%2]) (map f c) c)))","problem":63,"user":"50377d53e4b0af0658af77ad"},{"code":"(fn gr-by [f s]\n  (reduce #(let [k (f %2)\n                 v (or (%1 k) [])]\n             (assoc %1 k (conj v %2))) {} s))","problem":63,"user":"523b82efe4b07becd5be21f0"},{"code":"(fn gb [f s]\n  (reduce \n    #(assoc %1 (f %2) (conj (vec (get %1 (f %2))) %2)) {} s))","problem":63,"user":"4f611127e4b0defedf855fb4"},{"code":"#(reduce (fn [t i] (let [v (% i)] (assoc t v (conj (t v []) i)))) {} %2)","problem":63,"user":"4ef77edb535dced4c769f254"},{"code":"(fn [f col] (apply merge-with concat (map (fn [x] {(f x) [x]}) col)))","problem":63,"user":"519b7d76e4b02a926d9a436e"},{"code":"(fn ff\n  ([f s] (ff {} f s))\n  ([m f s]\n     (if (empty? s)\n       m\n       (let [i (first s) k (f i)]\n         (recur (assoc m k (conj (or (m k) []) i)) f (rest s))))))","problem":63,"user":"53460d02e4b084c2834f4a39"},{"code":"(fn [func coll] (let [keys (map func coll) assoc (map list keys coll) uni-keys (set keys)] (zipmap uni-keys (map (fn [key] (map last (filter #(= (first %) key) assoc))) uni-keys))))","problem":63,"user":"50112acee4b0d82cfac69f4c"},{"code":"(fn gb [f coll]  \n  (persistent!\n    (reduce\n      (fn [ret x]\n        (let [k (f x)]\n          (assoc! ret k (conj (get ret k []) x))))\n      (transient {}) coll)))","problem":63,"user":"4ef4c1ff535dced4c769f23e"},{"problem":63,"code":"(fn [f coll_in] (reduce (fn [tot val] (let [k (f val) v val] (assoc tot k (conj (get tot k []) val)))) {} coll_in))","user":"5b284375e4b063e2438bcc53"},{"problem":63,"code":"(fn group-by' [f s]\n  (reduce\n   (fn [m v]\n     (let [k (f v)]\n       (assoc m k (conj (m k []) v))))\n   {} s))","user":"54ca9ca8e4b057c6fda3a265"},{"code":"(fn [op x] (into {} (map #(vector (op (first %)) %) (partition-by op (sort-by op x)))))","problem":63,"user":"50b65966e4b0a86f8358ca6c"},{"problem":63,"code":"#(reduce (fn [acc item]\n          (let [key (% item)\n                group (acc key [])\n                new-group (conj group item)]\n            (assoc acc key new-group)))\n          {} %2)","user":"55aa7c5ce4b0988bba2ad94d"},{"code":"(fn [f c] (apply merge-with into (map (partial apply hash-map) (map #(list %1 (vector %2)) (map f c) c))))","problem":63,"user":"4fba77fae4b081705acca2df"},{"code":"(fn [f coll]\n  (reduce \n   (fn [m x]\n     (cond\n      (get m (f x)) (update-in m [(f x)] conj x)\n      :else (conj m {(f x) [x]})))\n   {}\n   coll))","problem":63,"user":"52be0263e4b07a9af579230e"},{"problem":63,"code":"(fn g [f coll] \n  (reduce \n   (fn [acc elem] \n     (let [r (f elem)]\n       (if (acc r)\n         (update-in acc [r] conj elem)\n         (assoc acc r [elem]))))\n   {} coll))","user":"5e44c804e4b01d43a70e8e89"},{"code":"(fn group-seq [f sq]\n  (reduce\n    (fn [coll val]\n      (update-in\n        coll\n        [(f val)]\n        (fn [oldval] \n          (if (nil? oldval)\n            [val]\n            (conj oldval val)))))\n    {}\n    sq))","problem":63,"user":"52c00e4fe4b07a9af5792342"},{"problem":63,"code":"(fn [f coll]\n  (reduce (fn [m elt]\n            (let [res (f elt)\n                  val (get m res)]\n              (assoc m res ((fnil conj [])  val elt)))) {} coll))","user":"54ccf9d5e4b057c6fda3a295"},{"code":"(fn my-gb [f s]\n  (reduce (fn [l r]\n            (let [key (f r)]\n              (assoc l key\n                (conj (or (get l key) []) r))))\n    {} s))","problem":63,"user":"515737f0e4b0b0b4b87062d0"},{"code":"(fn [f s]\n   (reduce\n    (fn [ret x]\n      (let [k (f x)]\n        (assoc ret k (conj (get ret k []) x))))\n    {} s))","problem":63,"user":"512eb723e4b0b740abc5982b"},{"code":"(fn this [f s]\n  (if (empty? s)\n    {}\n    (let [fs (first s)\n          more (this f (rest s))\n          here (f fs)]\n      (assoc more here (concat [fs] (more here))))))","problem":63,"user":"4ec12577535dfed6da9c6da8"},{"problem":63,"code":"(fn [f coll]  \n  (reduce\n    (fn [ret x]\n      (let [k (f x)]\n        (assoc ret k (conj (get ret k []) x)))) (cons {} coll)))","user":"55d5e80ee4b0e31453f64a91"},{"code":"(fn [f col] \n  (reduce\n    #(let [m %1 v %2 k (f %2) lst (m k)]\n       (assoc m k (if lst (conj lst v) [v]))) {} col))","problem":63,"user":"4fdb02aae4b05e33b9224f56"},{"problem":63,"code":"(fn my-group [f s]\n  (into {}\n        (for [ [k v] (apply merge-with concat (map hash-map (map f s) (map vector s)))]\n          {k (seq v)})))","user":"58988cbbe4b00487982d52d7"},{"problem":63,"code":"(fn [fun lst]\n  (reduce (fn [m i]\n            (assoc m\n              (fun i)\n              (conj (m (fun i) []) i)))\n          {}\n          lst))","user":"6074dfa4e4b069485764de4c"},{"problem":63,"code":"(fn GroupASequence [ope lst] \n  (reduce (fn [res i] \n            (let [lla (ope i)] \n              (assoc res lla (conj (res lla []) i)))) \n          {} \n          lst))","user":"607508f3e4b069485764de54"},{"problem":63,"code":"(fn my-group-by [f s]\n  (apply hash-map\n         (apply concat\n                (for [k (distinct (map f s))]\n                  [k (filter #(= k (f %)) s)]))))","user":"57dda21be4b0bd073c202445"},{"code":"#(apply merge-with into (map (fn[a]{(% a) [a]}) %2))","problem":63,"user":"4e778d36535d324fb2983d71"},{"problem":63,"code":"(fn [f s] (apply merge-with concat (map #(array-map (f %) [%]) s)))","user":"52541fe6e4b0541d1855b964"},{"code":"(fn my-group-by [pred coll]\n\t(reduce (fn [result arg]\n\t\t    (let [t-or-f (pred arg)]\n\t\t      (assoc result t-or-f\n\t\t\t     (if (contains? result t-or-f)\n\t\t\t\t (conj (result t-or-f) arg)\n\t\t\t       [arg]))))\n\t\t{}\n\t\tcoll))","problem":63,"user":"52381b2ae4b0fae3832e99ef"},{"code":"(fn [f xs]\n  (reduce\n    (fn [groups x]\n      (assoc groups (f x) (conj (get groups (f x) []) x)))\n    {} xs))","problem":63,"user":"4f4e91a9e4b03ad3f0c10cca"},{"code":"(fn [f s]\n  (reduce\n   (fn [r [appliedf v]] (update-in r [appliedf] (comp vec conj) v))\n   {}\n   (map #(vector (f %) %) s)))","problem":63,"user":"52470d42e4b05ef8e38e6350"},{"problem":63,"code":"(fn [f coll]\n   (reduce\n    #(let [[f-result element] %2\n           aggregator (%1 f-result [])]\n       (assoc %1 f-result (conj aggregator element)))\n    {}\n    (map #(vector (f %) %) coll)))","user":"59fa7fb0e4b0ca45a743a366"},{"problem":63,"code":"(fn[fun ls] \n  (loop [functionToApply fun listToProcess ls finalMap {}] \n    (let [currentItem (first listToProcess) \n          currentKey (apply functionToApply (list (first listToProcess))) \n          keyValue (if (contains? finalMap currentKey) (conj (get finalMap currentKey) currentItem) (vector currentItem))] \n      (if (not-empty (rest listToProcess)) \n        (recur functionToApply (rest listToProcess) (assoc finalMap currentKey keyValue)) \n        (assoc finalMap currentKey keyValue)\n      )\n    )\n  )\n)","user":"571172ece4b09c608db70446"},{"problem":63,"code":"(fn [f xs]\n  (reduce\n   (fn [acc x]\n     (let [xp (f x)]\n       (if (contains? acc xp)\n         (assoc acc xp (conj (acc xp) x))\n         (assoc acc xp [x]))))\n   {}\n   xs))","user":"56483562e4b0284900eef629"},{"code":"(fn group [f col] \n        (reduce\n          #(let [val (f %2)\n                 existing (get %1 val)\n                 s (if (nil? existing) [] existing)\n                 m (conj s %2)]\n             (assoc %1 val m))\n          {} col))","problem":63,"user":"4eb01df4535d7eef30807337"},{"code":"(fn [f s] (persistent! (reduce (fn [r i] (assoc! r (f i) (conj (get r (f i) []) i))) (transient {}) s)))","problem":63,"user":"4eb404ba535d7eef3080735a"},{"code":"(fn   [f coll]\n  (reduce (fn [ret item]\n            (update-in ret [(f item)] #(conj (vec %) item)))\n          {} coll))","problem":63,"user":"51937eb3e4b04df54c098022"},{"code":"#(loop [m {} c# %2]\n  (if (empty? c#)\n    m\n    (let [key (%1 (first c#))\n          val (conj (get m key []) (first c#))]\n      (recur (assoc m key val) (rest c#)))))","problem":63,"user":"5127e504e4b03a34742b4302"},{"code":"(fn [f s]\n  (apply merge-with concat\n         (map (fn [x] {(f x) [x]}) s)))","problem":63,"user":"4f969a66e4b0dcca54ed6cde"},{"problem":63,"code":"(fn e [f s] (loop[h1 (first s) t1 (rest s) h2 (first(map f s)) t2 (rest (map f s)) r {}] \n              (if (= h1 nil) r (recur (first t1) (rest t1) (first t2) (rest t2) \n                                      (assoc r h2 (if (= nil (find r h2)) (vec (list h1))  (conj (val (find r h2)) h1 ) ) ) )  ) ))","user":"53b3ea79e4b047364c0444ab"},{"code":"(fn [func inList] \n\t(->> inList\n\t\t(sort-by func)\n\t\t(partition-by func)\n\t\t(reduce (fn [m v] (assoc m (func (first v)) (vec v))) {})\n\t)\n)","problem":63,"user":"52bf6946e4b07a9af5792334"},{"code":"(fn [f xs]\n   (reduce (fn [result x]\n             (let [k (f x)]\n               (assoc result\n                 k\n                 (conj (vec (result k)) x))))\n           {}\n           xs))","problem":63,"user":"4dad8a6dc9a9d6ed1399dc57"},{"code":"(fn [f v]\n  (reduce #(\n            let [k (f %2)]\n            (assoc % k (conj (get % k []) %2))\n            ) {} v))","problem":63,"user":"51eca2ace4b069f463c22cd0"},{"code":"(fn [f xs]\n  (reduce (fn [result x]\n            (update-in result [(f x)] (fnil #(conj % x) []))) \n          {} xs))","problem":63,"user":"536d83cee4b0fc7073fd6e5e"},{"problem":63,"code":"(fn my-group [f b]\n  (loop [m {} l b]\n    (if (empty? l)\n      m\n      (recur\n        (let [v (first l) k (f v)]\n          (assoc m k (conj (get m k []) v)))\n        (rest l)))))","user":"5843b95de4b089d5ab817e3f"},{"code":"(fn [f s]\n  (reduce\n    (fn [ans x] \n      (let [fx (f x)]\n        (assoc ans fx (conj (get ans fx []) x))))\n      {}\n      s))","problem":63,"user":"506ab9bae4b05d3b7762c74c"},{"code":"(fn gb [f s]\n  (reduce\n    (fn [m c]\n      (update-in m [(f c)] #(if %1 (conj %1 %2) [%2]) c))\n    {}\n    s))","problem":63,"user":"4e6f578c535d5021c1a8961b"},{"problem":63,"code":"(fn my-group-by [f col]\n  (reduce (fn [m x] (let [result (f x) current (get m result)]\n                      (if (nil? current)\n                        (assoc m result [x])\n                        (assoc m result (conj current x)))))\n\n          {}\n          col)\n  )","user":"5c3ac091e4b0d62ef62d9f95"},{"problem":63,"code":"(fn my-group-by [f coll]\n  (apply merge-with into (map hash-map \n                              (map f coll) \n                              (map vector coll))))","user":"608256d7e4b0736b099e42da"},{"code":"(fn [f c] (reduce (fn [a b] (update-in a [(f b)] #(conj (or % []) b))) {} c))","problem":63,"user":"52d1e364e4b0d9f9285948e7"},{"problem":63,"code":"(fn te [function s]\n  (reduce #(let [k (function %2)]\n             (cond (contains? %1 k) (assoc %1 k (conj (get %1 k) %2))\n                      :else (assoc %1 k [%2])\n                   )) {} s))","user":"60228147e4b0d5df2af22202"},{"code":"(fn [f v]\n  (reduce (partial merge-with into) {} (for [x v] {(f x) [x]})))","problem":63,"user":"4e6f4cbc535d5021c1a8961a"},{"problem":63,"code":"#(reduce (fn [res x] (assoc res (% x) (conj (get res (% x) []) x))) {} %2)","user":"5b61aa6ae4b0c6492753e712"},{"code":"(fn [f s]\n  (reduce (fn [m s]\n    (let [k (f s)]\n    (assoc m k (conj (get m k []) s))))\n    {}\n    s))","problem":63,"user":"4f9a0064e4b0dcca54ed6d03"},{"problem":63,"code":"(fn [fn col]\n  (apply merge-with into (map hash-map (map fn col) (map vector col)))\n  )","user":"5c321b8ae4b0d62ef62d9f32"},{"problem":63,"code":"(fn [x y] (reduce #(  if (contains? %1 (x %2))\n    (assoc %1 (x %2) (conj (get %1 (x %2)) %2))\n    (assoc %1 (x %2) (vector %2))) {} y))","user":"567e6d24e4b0feffd0d18eb4"},{"problem":63,"code":"(fn [f s]\n  (persistent!\n   (reduce\n    (fn [res x]\n      (let [k (f x)]\n        (assoc! res k (conj (get res k []) x))))\n    (transient {}) s)))","user":"58b989dbe4b0888cdc949ccd"},{"code":"(fn [f coll]\n  (reduce (fn [acc x]\n            (merge-with (comp vec concat) acc {(f x) [x]}))\n          {}\n          coll))","problem":63,"user":"51a97f7ae4b08d8ec191b827"},{"problem":63,"code":"(fn [f coll]\n  (reduce (fn [res current]\n            (let [key (f current)\n                  value (if (nil? (get res key))\n                          []\n                          (get res key))]\n              (assoc res key (conj value current))))\n          {}\n          coll))","user":"53e30fcae4b036ad0777e3fc"},{"problem":63,"code":"(fn [f s]\n  (reduce\n    (fn [m c]\n      (if (contains? m (first c))\n        (assoc m (first c) (into (m (first c)) (second c)))\n        (assoc m (first c) (second c))))\n    {}\n    (map #(list (f (first %)) (apply vector %)) (partition-by f s))))","user":"53c1b787e4b00fb29b221266"},{"problem":63,"code":"(fn [fun vls]\n  (into {}\n      (map #(vector (fun (first % )) (vec %))\n            (partition-by fun (sort vls)))))","user":"5c51c930e4b0fb8c5ffd99ce"},{"code":"(fn [f lst]\n  (reduce\n   (fn [l n]\n     (if (nil? (get l (first n)))\n       (assoc l (first n) (vector (last n)))\n   \t\t (update-in l [(first n)] (fn [a] (assoc a (count a) (last n))))))\n     \n   {}\n   (map #(vector (f %) %) lst)))","problem":63,"user":"50589113e4b06522596eba7f"},{"problem":63,"code":"(fn grpby\n  ([f sekv] (grpby f sekv {}))\n  ([f sekv slovar]\n  (let [x (first sekv)]\n    (cond\n      (empty? sekv) slovar\n      (contains? slovar (f x)) (grpby f (rest sekv) (assoc slovar (f x) (conj (get slovar (f x)) x)))\n      :else (grpby f (rest sekv) (assoc slovar (f x) (vec (list x))))\n      )\n    ))\n  )","user":"584d99c5e4b0b7285a6f4e42"},{"code":"(fn [f coll]\n  (loop [x coll\n         r {}]\n    (if (nil? (first x))\n      r\n      (if (nil? (get r (f (first x))))\n        (recur (rest x) (assoc r (f (first x)) (vector (first x))))\n        (recur (rest x) (assoc r (f (first x)) (concat (get r (f (first x))) (vector (first x)))))))))","problem":63,"user":"5123ac8ee4b061b4c6f0e0b1"},{"problem":63,"code":"(fn group-a-sequence\n  ([fun col]\n    (group-a-sequence fun col {} 0))\n  ([fun col cur-map cur-el]\n    (if (= cur-el (count col))\n      cur-map\n      (group-a-sequence fun col (assoc cur-map (fun (nth col cur-el)) (filter #(= (fun %) (fun (nth col cur-el))) col)) (inc cur-el)))))","user":"5c3f6322e4b08cd430848e97"},{"problem":63,"code":"(fn [f s] (apply merge-with (comp vec concat) (map #(hash-map (f %) [%]) s)))","user":"5466199ce4b01be26fd746e2"},{"code":"(fn [f coll]\n\t(reduce \n\t\t(fn [grouped x]\n\t\t\t(update-in grouped [(f x)] \n\t\t\t\t(fnil #(conj % x) [])))\n\t\t\t{}\n\t\t\tcoll))","problem":63,"user":"51ba4482e4b0fe3ecfb4642b"},{"problem":63,"code":"(fn [f lst]\n  (into {} (for [x (distinct (map f lst))]\n             [x (vec (remove nil? (map #(if (= x (f %)) %) lst)))])))","user":"5a99b863e4b0d174b936c7ae"},{"problem":63,"code":"(fn [key-fn list]\n  (apply merge-with concat\n         (map #(hash-map (key-fn %1) [%1]) list)))","user":"53fc88e7e4b0de5c418485be"},{"problem":63,"code":"(fn [f s]\n  (reduce (fn [m v]\n            (let [k (f v)]\n              (assoc m\n                     k\n                     (conj (get m k []) v))))\n          {}\n          s))","user":"580bd81ee4b0849f6811b711"},{"problem":63,"code":"(fn [f items]\n  (reduce #(let [k (f %2)] (assoc %1 k (conj (get %1 k []) %2))) {} items))","user":"57f8ba80e4b0d3187e90092f"},{"code":"#(apply merge-with concat\n   (map (fn [x] (hash-map (first x) [(second x)]))\n                 (map vector (map %1 %2) %2)))","problem":63,"user":"51f28a64e4b0210f90e7454e"},{"problem":63,"code":"(fn [f coll]\n(->> (map (fn [x] (vector (f x) x)) coll)\n     (reduce (fn [m x] (update-in m [(first x)] (fn [curr new] (conj (vec curr) new)) (last x))) {})))","user":"535774c2e4b04ce2eb3ed27c"},{"problem":63,"code":";((fn [f coll] (apply merge-with into (for [v coll] {(f v) [v]}))) #(> % 5) [1 3 6 8])\n(fn [f coll] (apply merge-with into (for [v coll] {(f v) [v]})))","user":"5dfa1c67e4b0a607a9a45cc5"},{"code":"(fn problem-63 [f seq]\n  (reduce (fn [map el]\n            (let [key (f el)\n                  res (get map key)]\n              ;(println (format \"Got %s %s\" (str key) (str res)))\n              (assoc map key (conj (vec res) el))))\n          {} seq))","problem":63,"user":"51fe9d7ce4b0f1313d468a70"},{"code":"(fn [f coll]\n  (apply merge-with\n    #(concat %1 %2)\n     (for [x coll] {(f x) [x]})))","problem":63,"user":"501688f7e4b052339a490e7a"},{"problem":63,"code":"(fn tamere[fu ar] \n        (into {}\n             (distinct (map \n                         #(hash-map (fu %) \n                                       (into [] (filter (fn[ag](= (fu ag) (fu %))) ar)) )\n                            ar))\n        )\n  )","user":"5034b623e4b062bc5d7ae168"},{"problem":63,"code":"(fn\n  [f s]\n  (reduce (fn [m i] (update-in m [(f i)] (comp vec conj) i)) {} s))","user":"54edc818e4b024c67c0cf865"},{"code":"(fn my-group-by [pred, coll]\n  (reduce\n    (fn [m v] \n      (let [k (pred v)]\n        (assoc m k (concat (m k) [v]))))\n    {}\n    coll))","problem":63,"user":"4eb51942535d7eef30807365"},{"code":"(fn [f s]\n  (loop [remaining s res {}]\n    (let [current (first remaining)]\n    (cond\n      (empty? remaining) res\n      (contains? res (f current))\n          (recur (rest remaining)\n                 (assoc res (f current) \n                  (conj (res (f current)) current)))\n      true (recur (rest remaining)\n                  (assoc res (f current) [current]))))))","problem":63,"user":"4e28120f535deb9a81d77efa"},{"problem":63,"code":"(fn [f c] (reduce\n           #(let [r (f %2)]\n              (assoc % r (vec(conj (% r) %2))))\n           {} c))","user":"53572176e4b04ce2eb3ed276"},{"problem":63,"code":"(fn [f coll] (persistent!\n   (reduce\n    (fn [ret x]\n      (let [k (f x)]\n        (assoc! ret k (conj (get ret k []) x))))\n(transient {}) coll)))","user":"54aa373de4b09f271ff37cb6"},{"problem":63,"code":"(fn [f coll]\n   (reduce\n    (fn [new-coll item]\n      (if (get new-coll (f item))\n        (assoc new-coll (f item) (conj (get new-coll (f item)) item))\n        (assoc new-coll (f item) [item])))\n    {}\n    coll))","user":"5dcb1e73e4b02b31cc3da3b6"},{"code":"#(reduce (fn [m i] (let [k (% i)] (assoc m k (conj (get m k []) i)))) {} %2)","problem":63,"user":"4f0664bd535dcb61093f6c0f"},{"problem":63,"code":"(fn [p xs]\n   (reduce\n    #(merge-with concat %1 %2)\n    (map (fn [x] {(p x) [x]}) xs)))","user":"5ec3a13ae4b08d0ec38692b9"},{"problem":63,"code":"(fn [f coll]\n   (reduce\n    #(merge % {(f %2) (conj (if (= (get %1 (f %2)) nil) [] (get %1 (f %2))) %2)})\n    {}\n    coll))","user":"5446ebc2e4b032a45b8693b8"},{"code":"(fn [f coll]\n  (reduce (fn [m l]\n            (let [k (f l)]\n              (assoc m k (conj (get m k []) l)))) {} coll))","problem":63,"user":"5030f16fe4b05b7df5a0b84b"},{"code":"#(reduce (fn [r x] (assoc r (% x) (if (contains? r (% x))\n                                      (conj (get r (% x)) x)\n                                      [x]))) {} %2)","problem":63,"user":"4f067029535dcb61093f6c12"},{"problem":63,"code":"(fn [f xs] (reduce (fn [res x] (update-in res [(f x)] #(concat % [x]))) {} xs))","user":"5c30d90de4b0d62ef62d9f22"},{"problem":63,"code":"(fn [f c]\n    ((fn h [m l]\n      (if (zero? (count l))\n        m\n        (let [k (f (first l)), rm (h m (rest l))]\n          (if (rm k)\n            (assoc rm k (conj (rm k) (first l)))\n            (assoc rm k [(first l)]))))) {} (reverse c)))","user":"60882700e4b0ae75613dcedf"},{"code":"(fn [f s] (persistent! (reduce (fn [acc x] (assoc! acc (f x) (conj (get acc (f x) []) x))) (transient {}) s)))","problem":63,"user":"5217c26fe4b0a4bccb16cab8"},{"code":"(fn [f s]\n  (reduce\n    (fn [m x]\n      (let [k (f x)]\n        (assoc m k (conj (get m k []) x))))\n  {} s))","problem":63,"user":"4e5d0e96535d8a8b8723a2c8"},{"problem":63,"code":"(fn fun [f coll] \n  (->> coll\n       (reduce (fn [result x]\n                 (let [k (f x)]\n                   (assoc result k (conj (get result k []) x)))) {})))","user":"5493d908e4b0b312c081ff52"},{"problem":63,"code":"(fn [pred coll]\n  (reduce (fn [r i]\n            (let [k (pred i)\n                  l (get r k [])]\n              (assoc r k (into l [i]))))\n          {}\n          coll))","user":"51dafedee4b09f6bc204eee2"},{"code":"(fn gb [f coll] \n\t  (persistent!\n\t   (reduce\n\t    (fn [ret x]\n\t      (let [k (f x)]\n\t        (assoc! ret k (conj (get ret k []) x))))\n    (transient {}) coll)))","problem":63,"user":"518aec06e4b06da86c1973c2"},{"problem":63,"code":"(fn [f x]\n  (loop [x x\n         ans {}]\n    \n    (if (seq x)\n      (let [key (f (first x))]\n      (recur (rest x) (assoc ans key (conj (get ans key []) (first x)))))\n      ans)))","user":"5479c58de4b0c51c1f4d72c7"},{"code":"(fn [f s]\n  (reduce \n    (fn [x y] (update-in x [(f y)] #(conj (if % % []) y)))\n   {} s))","problem":63,"user":"4e5bdc2b535d8a8b8723a2bb"},{"code":"(fn [f coll]\n      (loop [final-map {}\n             rest-coll coll]\n        (if (= '() rest-coll)\n          final-map\n          (let [head (first rest-coll)\n                result (f head)]\n            (recur (assoc final-map result (conj (get final-map result [])\n                                                    head))\n                   (rest rest-coll))))))","problem":63,"user":"509e62a8e4b08df8156e9e2e"},{"problem":63,"code":"(fn [f c]\n  (apply hash-map (apply concat\n                         (map #(vec [(f (first %)) (vec %)])\n                              (partition-by f (sort-by f c))))))","user":"5da760ebe4b000c986472c1a"},{"code":"(fn grp-seq [func vals]\r\n  (into {}\r\n        (map #(vector (func (first % )) (vec %))\r\n             (partition-by func (sort vals)))))","problem":63,"user":"4f7d25b4e4b06e829148e1ba"},{"code":"(fn [f c] \n  (reduce (partial merge-with concat) \n          (map #(hash-map (f %) [%]) c)))","problem":63,"user":"52dd4fb4e4b09f7907dd13df"},{"code":"(fn [f coll]\n  (reduce\n    (fn [memo v]\n      (assoc memo (f v) (conj (get memo (f v) []) v)))\n    {}\n    coll))","problem":63,"user":"50bd6033e4b0594b91591c66"},{"code":"(fn myGroupBy\n    ([f x z]\n        (let [y (first x)]\n            (if (empty? x)\n                z\n            (if (contains? z (f y))\n                (myGroupBy f (rest x)\n                    (assoc z (f y)\n                        (concat (get z (f y)) [y])))\n            (myGroupBy f (rest x) (assoc z (f y) [y]))))))\n    ([f x] (myGroupBy f x (hash-map))))","problem":63,"user":"4f03b3fb535dcb61093f6b52"},{"problem":63,"code":"(fn grp-by [f vs] \n  (reduce (fn [res v]\n            (update-in res \n                       [(f v)] \n                       #(if (nil? %) [v] (conj % v))))\n          {}\n          vs))","user":"578cf84ce4b0ebec4cfb7562"},{"problem":63,"code":"(fn [f coll]\n (reduce (fn [acc curr]\n   (let [result (f curr) \n         grouped (get acc result [])]\n     (assoc acc result (conj grouped curr)))) \n         {}\n         coll))","user":"60654263e4b069485764ddc9"},{"problem":63,"code":"(fn[f col](#(apply merge-with into %) (for[el col] {(f el) [el]} ) ))","user":"59692530e4b069c0a1a197e4"},{"problem":63,"code":"(fn [f x]\n  (apply merge-with concat (map #(hash-map (f %1) [%1]) x)))","user":"526698c9e4b03e8d9a4a7144"},{"code":"#(reduce\n(fn [l r]\n(let [k (%1 r)]\n; l is our map\n; r is the current value in the array\n; k is f(r) => key\n; associate k to the existing item at k :: r\n(assoc l k (conj (get l k []) r))\n)\n)\n; initialize l as a map {}\n; pass in the array as r\n{} %2)","problem":63,"user":"4fc9985ee4b0ee37620e1846"},{"code":"(fn [f xs]\n  (reduce\n    (fn [acc x]\n      (merge-with concat acc {(f x) [x]}))\n    {}\n    xs))","problem":63,"user":"4dc7e7a5535d8a4b2fd74290"},{"code":"(fn [f coll]\n  (let [keys (set (map f coll))]\n    (reduce #(assoc %1 %2 (filter (fn [x] (= %2 (f x))) coll)) {} keys)))","problem":63,"user":"51ae350fe4b09397d5109790"},{"problem":63,"code":"(fn [f coll]\n  (reduce\n   #(update-in \n     %1 \n     [(f %2)] \n     (fn [x] (vec (conj x %2))))\n   {} coll))","user":"590b8607e4b047aa04b199db"},{"code":"(fn foo [f coll]  \n  (reduce\n    (fn [ret x]\n      (let [k (f x)]\n        (assoc ret k (conj (get ret k []) x))))\n    {} coll))","problem":63,"user":"4f4f08c8e4b03ad3f0c10cd8"},{"code":"(fn [f s]\r\n  (reduce #(let [ap (f %2)] (assoc %1 ap (conj (get %1 ap []) %2))) {} s))","problem":63,"user":"4f29cdc8e4b0d6649770a033"},{"problem":63,"code":"(fn [f s]\n  (let [t (map (juxt f identity) s)\n        ug (fn [m [gr v]] (update-in m [gr] #(conj (vec %) v)))]\n    (reduce ug {} t)\n  ))","user":"54e345a1e4b024c67c0cf7db"},{"problem":63,"code":"(fn [f coll]\n   (reduce (fn [res x]\n             (let [k (f x)]\n               (assoc res k (conj (get res k []) x)))) {} coll))","user":"5b34aba7e4b025bcb146f352"},{"problem":63,"code":"(fn [ func lst] (reduce (fn [a v] \n                          (let [val (a (func v))]\n                            (if (coll? val)\n                            (assoc a (func v) (conj val v))\n                            (assoc a (func v) [v]) \n                            \n                            ))) {} lst))","user":"53c73e8ae4b00fb29b2212a5"},{"problem":63,"code":"(fn group-by* [a b]\n  (reduce \n    #(if \n      (contains? %1 (first %2))\n      (assoc %1 (first %2) (conj (get %1 (first %2)) (second %2)))\n      (assoc %1 (first %2) (vector (second %2)))) \n    {} \n    (partition 2 (interleave (map a b) b))))","user":"5d078e2de4b0cc9c915881fa"},{"code":"(fn [f, s]\n    (reduce (fn [m, val]\n      (let [k (f val) v (or (get m k) [])]\n          (assoc m k (conj v val)))) {} s))","problem":63,"user":"5048202fe4b0ec70b3ef8d9a"},{"problem":63,"code":"(fn\n  [f coll]\n  (reduce\n    (fn[m x]\n      (let [k (f x)]\n        (assoc\n          m\n          k\n          (if (contains? m k) (conj (m k) x) [x]))))\n    {}\n    coll))","user":"5c6227fee4b0fca0c1622641"},{"problem":63,"code":"(fn [f c] (apply merge-with (comp vec concat) (for [x c] {(f x) [x]})))","user":"5b100648e4b0cc2b61a3be17"},{"problem":63,"code":"(fn [f c]\n  (reduce (fn [m x]\n            (let [k (f x)]\n              (assoc m k (conj (get m k []) x)))) {} c))","user":"54f2fe9fe4b050824f58f5b8"},{"problem":63,"code":"(fn [f list] (reduce #(let [x (f %2)]\n                        (assoc %1 x (conj (get %1 x []) %2))) {} list))","user":"58cf8f97e4b03c36ff7e58b7"},{"problem":63,"code":"(fn [f lst]\n  (into {} (map #(vector (f (first %)) (vec %)) (partition-by f (sort lst)))))","user":"57f81549e4b0d3187e900918"},{"code":"#(reduce (fn [ret x] (assoc ret (% x) (conj (get ret (% x) []) x))) {} %2)","problem":63,"user":"50742549e4b054001656accf"},{"problem":63,"code":"(fn [x y]\n  (let [m (map (fn [a] [(x a) a]) y)\n        k (map first m)\n        kv (map (fn [a] [a (vec (map last (filter #(= (first %) a) m)))]) k)\n        ]\n    (apply hash-map (vec (mapcat identity (set kv))))\n   )\n)","user":"5a244240e4b0ff51aa4b32e9"},{"code":"(fn group-by-2 [f s]\n   (reduce\n     #(let [r (f %2)\n            v (% r [])]\n       (assoc % r (conj v %2)))\n     {} s))","problem":63,"user":"4ed27f9f535d44c135fd68d5"},{"code":"(fn\n[f coll]\n   (reduce \n     (fn \n       [acc, ele] \n       (conj \n         acc \n         {(f ele) \n          (conj \n            (get acc (f ele) [])\n            ele)\n         }\n        )\n      )\n      {}\n      coll\n    )\n)","problem":63,"user":"52485723e4b05ef8e38e63d2"},{"code":"(fn group [pred coll]\n   (reduce #(let [v (pred %2)]\n              (assoc % v (conj (% v []) %2)))\n           {}\n           coll)\n   )","problem":63,"user":"529d4f4be4b04e0c58e87b79"},{"problem":63,"code":"(fn [pred coll] (reduce\n                 #(let [item (pred %2)]\n                    (if-not (contains? %1 item)\n                      (assoc %1 item [%2])\n                      (update-in %1 [item] conj %2))) {} coll))","user":"56481722e4b0284900eef628"},{"code":"(fn [f s1]\n  (reduce (fn [m x]  \n            (let [value (f x)] \n              (assoc m value (conj (get m value []) x)))) {} s1))","problem":63,"user":"4f29eb2ae4b0d6649770a037"},{"code":"(fn [f s] (reduce (fn [m e] (merge-with concat m {(f e) [e]})) {} s))","problem":63,"user":"4f58fe71e4b0a7574ea7185f"},{"problem":63,"code":"(fn [f s]\n  (reduce (fn [acc v] (let [k (f v)]\n                        (assoc acc k (conj (get acc k []) v))))\n          {} s))","user":"56f9392ae4b07572ad1a88ac"},{"code":"(fn [f s]\n  (reduce (fn [m e]\n            (let [k (f e) v (m k)]\n              (assoc m k (if v (conj v e) [e]))))\n          {} s))","problem":63,"user":"5095f761e4b0ba05ca7aebfd"},{"problem":63,"code":"#(reduce (fn [a x]\n           (update-in a [(%1 x)] (fnil conj []) x))\n         {} %2)","user":"55be39f9e4b01b9910ae2a06"},{"problem":63,"code":"(fn grouper [f s]\n  (into {} (for [x (distinct (map f s))]\n             [x (apply vector (filter #(= x (f %)) s))])))","user":"572ea970e4b0cd1946bd0f89"},{"code":"(fn [f coll]\n  (reduce \n    (fn [hmap [k v]] \n      (let [value (get hmap k)]\n         (if (nil? value)\n            (assoc hmap k (vector v))\n           (assoc hmap k (conj value v)))))\n     {}\n     (map #(vector (f %) %) coll)))","problem":63,"user":"5014754de4b094324338f8e5"},{"code":"(fn [f coll]\n    (letfn [(comb-key [a-map [k v]]\n                      (let [vs (a-map k [])]\n                        (assoc a-map k (conj vs v))))]\n    (reduce comb-key {} (for [x coll] [(f x) x]))))","problem":63,"user":"50eddbc4e4b06330c1f87c4b"},{"code":"(fn group-by2\n  [f coll]  \n  (persistent!\n    (reduce\n      (fn [ret x]\n          (let [k (f x)]\n            (assoc! ret k (conj (get ret k []) x))))\n      (transient {}) coll)))","problem":63,"user":"4f890488e4b033992c121c76"},{"problem":63,"code":"(fn [f s]\n  (reduce \n    #(update-in %1 [(f %2)] (comp vec (fn [x] (conj x %2)))) \n    {}\n    s)\n  )","user":"5465febde4b01be26fd746e1"},{"code":"(fn [f coll]\n  (reduce (fn [res x]\n            (let [k (f x)]\n              (assoc res k (vec (conj (get res k) x)))))\n          {}\n          coll))","problem":63,"user":"5153316ce4b0252ac4b16611"},{"problem":63,"code":"#(apply merge-with into (for [n %2] {(%1 n) [n]}))","user":"586b6f13e4b01531a375e959"},{"code":"#(apply merge-with concat (map (fn[x]{(% x) [x]}) %2))","problem":63,"user":"51b41150e4b0f094dd986fac"},{"code":"(fn [f lst]\n  (reduce \n    (fn [acc k] \n      (let [v (f k) v-lst (get acc v [])] \n        (conj acc [v (conj v-lst k)])))\n    {}\n    lst))","problem":63,"user":"4fba7d1ee4b081705acca2e0"},{"problem":63,"code":"(fn [f xs]\n  (reduce (fn [acc v]\n            (let [pre (get acc (f v))]\n              (merge acc {(f v) \n                     (concat pre [v])}))) \n          {} xs))","user":"54133900e4b01498b1a719de"},{"problem":63,"code":"(fn [func vec]\n   (reduce #(assoc %1 (func %2) (into [] (conj (get %1 (func %2)) %2))) {} vec))","user":"5d0beecee4b0cc9c91588239"},{"code":"(fn [f s]\n  (apply (partial merge-with concat) (map #(array-map (f %) [%]) s)))","problem":63,"user":"51040eb2e4b0432126ba9bb4"},{"code":"(fn [f coll]\n  (reduce #(update-in %1 [(f %2)] (fnil conj []) %2)\n          {}\n          coll))","problem":63,"user":"53121863e4b08068f379ecf3"},{"problem":63,"code":"(fn __\n  [f seqs]\n  (reduce (fn [r v]\n            (let [result (f v)]\n              (if-let [val (r result)]\n                (assoc r result (conj val v))\n                (assoc r result [v]))))\n          {}\n          seqs))","user":"547bf82de4b0c51c1f4d72e1"},{"code":"(fn [fun l]    \n  (reduce\n    (fn [m k] (assoc m  (fun k) \n      (conj (get m (fun k) [])  k)))\n    {} l))","problem":63,"user":"4f04a06d535dcb61093f6bd9"},{"problem":63,"code":"(fn [key-gen xs]\n  (loop [prev (first xs)\n         curr (rest xs)\n         key (key-gen (first xs))\n         res {}]\n    (do \n      (prn prev curr key res)\n      (if (nil? prev)\n        res\n        (recur (first curr)\n               (rest curr)\n               (if (nil? (first curr)) nil (key-gen (first curr)))\n               (if (nil? (get res key))\n                 (assoc res key [prev])\n                 (assoc res key (conj (get res key) prev))))))))","user":"504f5804e4b0a02f9cffde72"},{"problem":63,"code":"(fn group-by-seq [f s]\n  (reduce (fn [m [k v]]\n            (if-let [vv (m k)]\n              (assoc m k (conj vv (first v)))\n              (assoc m k v)))\n          {}\n          (map #(conj [] (f %) (vector %)) s)))","user":"565654dae4b0f9d632dd849f"},{"problem":63,"code":"(fn group-seq\n[func s]\n(reduce (fn [a b] \n          (if (contains? a (func b)) \n            (assoc a (func b) (conj (a (func b)) b))\n            (assoc a (func b) [b]))) {} s))","user":"5c1d9f05e4b0efcb0b05b24c"},{"code":"(fn  [f x]\n (reduce \n  (fn [m [v k]]\n    (let [o (m k)]\n    (assoc m k (conj (vec o) v))))\n {}\n (map #(list % (f %)) x)))","problem":63,"user":"51dd9370e4b0c33a4e1da40c"},{"problem":63,"code":"(fn [f s]\n  (reduce #(let [acc %1 a_key (f %2) a_val %2]\n             (merge acc {a_key (vec (conj (get acc a_key) a_val))}))\n          {} s))","user":"556189a6e4b0c656e3ff17c9"},{"code":"(fn [f coll]\n  (letfn [(add-f [results x]\n            (let [result    (f x)\n                  existing  (if (contains? results result) (results result) [])\n                  new-value (conj existing x)]\n              (into results {result new-value})))]\n    (reduce add-f {} coll)))","problem":63,"user":"4daf36c2edd6309eace4d175"},{"problem":63,"code":"(fn [f coll]\n  (apply merge-with concat (map #(hash-map (f %1) [%1]) coll)))","user":"55d5ee3fe4b0e31453f64a92"},{"problem":63,"code":"(fn [in-f in-coll]\n    (let [unique-keys (distinct (map in-f in-coll))\n          ]\n      (apply array-map (apply concat (map (fn [k] (list k (filter #(= k (in-f %)) in-coll))) unique-keys)))\n      )\n    )","user":"56ef11efe4b04a395b9a045b"},{"problem":63,"code":"(fn [f s] (reduce (fn [m i] (assoc m (f i) (into [i] (get m (f i))))) {} (reverse s)))","user":"54b6c24be4b0ed20f4ff6e7c"},{"problem":63,"code":"(fn grp-by [f xs] \n\t(apply merge \n\t\t(for [x xs]\n            (assoc {} (f x) (filter #(= (f x) (f %)) xs)))))","user":"59f043d0e4b0966464fe6a3d"},{"code":"#(loop [l %2 r {}]\n    (if (empty? l)\n\t\tr\n\t\t(let [h (first l) x (% h)]\n    \t\t(recur (rest l) (assoc r x (conj (r x []) h)))       \n      \t)))","problem":63,"user":"4fbbcf0ce4b081705acca2ee"},{"code":"(fn [f n]\n    (apply merge-with concat (map (fn [c] {(f (first c)) c}) (partition-by f n))))","problem":63,"user":"504e1abee4b0f6ff3350c45d"},{"code":"(fn grpseq [f s]\n  (let [sentry (fn [m [k v]]\n                 (assoc m k (concat (get m k []) [v])))]\n    (reduce sentry {} (map #(vector (f %) %) s)))\n  )","problem":63,"user":"52ba43d0e4b07a9af57922cd"},{"problem":63,"code":"(fn [f coll]   \n  (persistent! \n   (reduce \n    (fn [ret x] \n      (let [k (f x)] \n        (assoc! ret k (conj (get ret k []) x)))) \n    (transient {}) coll)))","user":"57750460e4b0979f8965160c"},{"problem":63,"code":"#(reduce (fn [m e]\n           (let [k (%1 e)\n                 v (get m k)]\n             (assoc m k (if (nil? v) [e] (conj v e)))))\n         {}\n         %2)","user":"55a5c3bee4b0acc240e3154e"},{"code":"(fn[f coll] \n\t  (persistent!\n\t   (reduce\n\t    (fn [ret x]\n\t      (let [k (f x)]\n\t        (assoc! ret k (conj (get ret k []) x))))\n\t    (transient {}) coll)))","problem":63,"user":"52016fd3e4b0b2e020a18f10"},{"problem":63,"code":"(fn [f y] (reduce (fn [a [k x]] (assoc a k (conj (or (a k) []) x))) {} (map (fn [x] [(f x) x]) y)))","user":"53b15e6ee4b047364c04448f"},{"problem":63,"code":"(fn [f xs]\n  (loop [s xs\n         m {}]\n    (if (empty? s)\n      m\n      (recur (rest s)\n             (let [k (f (first s))\n                   v (first s)]\n               (assoc m\n                 k\n                 (if (contains? m k)\n                   (conj (m k) v)\n                   [v])))))))","user":"5136f659e4b04059df19f2fd"},{"problem":63,"code":"(fn [f s] (reduce (fn [res el]\n                    (update-in res [(f el)] \n                               #(conj (or %1 []) el)))\n                  {} s))","user":"5b7ec039e4b047b03b20375d"},{"code":"(fn [f l]\r\n  (apply merge\r\n  (for [x (set (map f l))]            \r\n               { x (filter #(= x (f %)) l) }\r\n                )))","problem":63,"user":"50576483e4b001218172198b"},{"code":"(fn [f coll]\n  (persistent!\n   (reduce\n    (fn [ret x]\n      (let [k (f x)]\n        (assoc! ret k (conj (get ret k []) x))))\n    (transient {}) coll)))","problem":63,"user":"4db1fe241254ad5b4805fa77"},{"problem":63,"code":"(fn [f c] (reduce #(assoc % (first %2) (conj (% (first %2) []) (second %2))) {} (map list (map f c) c)))","user":"55bfc39ee4b01b9910ae2a1a"},{"code":"(fn [f s]\n  (reduce #(update-in %1 [(f %2)] (fnil conj []) %2) {} s))","problem":63,"user":"53315c78e4b019098a6f8b67"},{"problem":63,"code":"(fn group\n  [f s]\n  (reduce (fn [m x]\n            (let [result (f x)]\n              (assoc m result (if-let [coll (m result)]\n                                (conj coll x)\n                                [x]))))\n          {}\n          s))","user":"59b93cd7e4b0a024fb6ae3c7"},{"code":"(fn [f coll]\n  (->>\n    coll                                                                                                                                                                                                     (map (fn [v] [v (f v)]))                                                                                                                           \n    (reduce\n      (fn [m pair]\n        (update-in\n          m\n          [(second pair)]\n          #(conj (if (nil? %1) [] %1) %2)\n          (first pair)))\n    {})))","problem":63,"user":"4ff6aea8e4b0678c553fc381"},{"problem":63,"code":"(fn grpby [pred coll]\n  (reduce\n   (fn [m e]\n     (update-in m [(pred e)]\n        (fn [v]\n          (if v (conj v e) [e]))))\n   {}\n   coll))","user":"53d78b64e4b0e771c3025466"},{"problem":63,"code":"(fn [pred xs]\n  (let [reducer (fn [m x]\n                  (let [group (pred x)\n                        v (into [] (m group))]\n                    (assoc m group (conj v x))))]\n    (reduce reducer {} xs)))","user":"509e8da7e4b08df8156e9e2f"},{"problem":63,"code":"(fn gby [f coll]\n  (apply (partial merge-with into)\n         (map #(assoc {} (f %) [%]) coll)))","user":"58a2b57fe4b02bd94d917ede"},{"code":"(fn [fun seq]\n  (letfn\n      [(categorize\n         [map val]\n         (let [key (fun val)\n               entry (if (contains? map key)\n                       (conj (map key) val)\n                       (conj [] val))]\n           (assoc map key entry)))]\n    (reduce categorize {} seq)))","problem":63,"user":"4dbb0f2d535d1e037afb21b1"},{"problem":63,"code":"(fn [f s]\n  (reduce (fn [out x] (let [k (f x)] (assoc out k (conj (get out k []) x)))) {} s))","user":"548f37c7e4b0e286459a1234"},{"problem":63,"code":"#(reduce (fn [m e]\n           (let [x (% e)]\n             (assoc m x (concat (get m x) [e])))) {} %2)","user":"51a4d802e4b0def3c5c5869a"},{"code":"(fn [f x] (apply merge-with concat (for [i x] {(f i) [i]} )))","problem":63,"user":"4e61bb60535d8ccf87e9fe5c"},{"problem":63,"code":"(fn [func input]\n\t(into {} \n\t\t(map #(vector (func (first %)) (vec %)) \n\t\t\t(partition-by func (sort input))))\n\t)","user":"57465429e4b009280f9f2b60"},{"problem":63,"code":"(fn my-gr [f coll]\n\t(into {}\n  (map #(hash-map (first (first %))\n\t                (into [] (map second %)))\n\t(partition-by first\n\t  (sort-by first \n\t  \t(map #(list (f %) %) coll))))))","user":"53858594e4b06839e8705f05"},{"problem":63,"code":"(fn group-seq \n  [f s]\n  \n  (into {} (map #(vector (f (first % )) (vec %))\n             (partition-by f (sort s)))))","user":"5a99ae99e4b0d174b936c7a4"},{"problem":63,"code":"(fn [f coll]\n(persistent!\n  (reduce\n    (fn [ret x]\n      (let [k (f x)]\n        (assoc! ret k (conj (get ret k []) x))))\n    (transient {}) coll)))","user":"53b4bddae4b047364c0444b9"},{"code":"#(reduce (fn [x y] (let [z (% y)] (assoc x z (conj (x z []) y)))) {} %2)","problem":63,"user":"5014718fe4b094324338f8e3"},{"problem":63,"code":"(fn grouping [f s] (let [helper (fn [a-map elem]\n                                  (let [newkey (f elem)]\n                                   (if (contains? a-map newkey)\n                                     (assoc a-map newkey (conj (get a-map newkey) elem))\n                                     (assoc a-map newkey [elem]))))]\n  (reduce helper {} s)))","user":"53de622ce4b0d874e779ae34"},{"problem":63,"code":"(fn [func vals]\n  \n  (letfn [(il [x] (interleave (map #(func (first %)) x) x))]\n\t(apply assoc {}\n       (il (partition-by func (sort-by func vals))   ))))","user":"552456e3e4b0882d96d091c2"},{"problem":63,"code":"(fn groupby [f col]\n  (reduce\n    (fn [mp x]\n      (let [k (f x)] (assoc mp k (conj (get mp k []) x))))\n    {} col))","user":"5b552117e4b02d533a91bd2c"},{"code":"(fn [f x]\n  (reduce\n   (fn [m a]\n     (assoc m (f a) (conj (get m (f a) []) a))\n   )\n   {}\n   x\n  ))","problem":63,"user":"50e8ff6be4b0ebbe794eb7f3"},{"problem":63,"code":"(fn [f xs]\n    (reduce\n      (fn [memo x]\n        (let [k (f x)]\n          (assoc memo k (conj (get memo k []) x))\n          )\n        )\n      {} xs\n      )\n    )","user":"53c3397be4b00fb29b221279"},{"code":"(fn group[f xs] \n  (reduce (fn red[prev x]\n            (merge-with #(into % %2) prev {(f x) [x]})) \n          {} xs))","problem":63,"user":"4ef4e5fa535dced4c769f242"},{"code":"(fn [f coll]\n  (reduce\n     (fn [m elem]\n       (let [key (f elem)]\n         (assoc m key (conj (get m key []) elem))))\n    {}\n    coll\n  )\n)","problem":63,"user":"51473a70e4b0d520409ed394"},{"code":"(fn tmp\n  [f s]\n  (let [\n        f-s (map f s) \n        keys (set f-s)\n        g-s (map (fn [k] (vec (filter #(= (f %1) k) s))) keys)\n        ]\n    (zipmap keys g-s)))","problem":63,"user":"5235a902e4b0a643f2dcb750"},{"problem":63,"code":";(fn my-group [f s] (\n;reduce (fn [a b] (update a (f b) (partial cons b))) {} (reverse s)\n;))\n\n(fn my-group [f s] (\nreduce (fn [a b] (into a [[(f b) (cons b (get a (f b)))]])) {} (reverse s)\n))","user":"59a0262ee4b0871e7608b82d"},{"code":"(fn [f c]\n   (into\n    {}\n    (mapcat\n     (fn [s] {s (filter #(= s (f %)) c)})\n     (set (map f c)))))","problem":63,"user":"4e65027c535d8ccf87e9fe6e"},{"problem":63,"code":"(fn [f s] \n  (reduce \n   (fn [m el] (let [k (first el) v (last el)] (assoc m k (conj (get m k) v)))) \n   (into {} (map #(vector (f %) []) s)) (map #(vector (f %)%) s)))","user":"575ddfd1e4b02ea11479938d"},{"code":"(fn [f v] \n  (reduce \n   (fn [m x] \n     (assoc m \n       (f x) \n       (conj (get m (f x) []) x))) {} v))","problem":63,"user":"52a32876e4b04e0c58e87bfb"},{"problem":63,"code":"(fn [f arg]\n     (zipmap (map f (map first (partition-by f (sort-by f arg)))) (partition-by f (sort-by f arg)))\n     )","user":"583c8bd4e4b089d5ab817d81"},{"problem":63,"code":"(fn [func col]\n            (reduce (fn [result x]\n                      (if (contains? result (x 1))\n                        (into result {(x 1) (conj (result (x 1)) (x 0))} )\n                        (into result {(x 1) [(x 0)]})))\n                    {} (into [] (map (fn [x]\n                                       [x, (func x)])\n                                     col))))","user":"5e1c3e6ee4b0dc9594008530"},{"problem":63,"code":"(fn [f s]\n  (reduce (fn [acc cur]\n            (let [v (f cur)]\n              (if (contains? acc v)\n                (update-in acc [v] conj cur)\n                (assoc acc v [cur]))))\n          {}\n          s))","user":"5d431c77e4b07c84aa5ae68f"},{"problem":63,"code":"(fn foo [f s]\n    (loop [s s\n           acc {}]\n        (if (empty? s)\n            acc\n            (let [x (first s)\n                  xs (rest s)\n                  k (f x)]\n                (recur xs (assoc acc k\n                              (conj (get acc k []) x)))))))","user":"600ae927e4b074f607df6689"},{"problem":63,"code":"(fn [f s] \n  (->> s\n       (map (fn [v] {(f v) [v]}))\n       (apply merge-with concat)))","user":"561c0278e4b064ca9f4b1691"},{"code":"(fn\n  [f s]\n  (apply merge-with concat (map #(hash-map %1 [%2]) (map f s) s)))","problem":63,"user":"50982769e4b04e098a4c726a"},{"problem":63,"code":"#(reduce (fn [accum item] (assoc accum (%1 item) (conj (accum (%1 item) []) item))) {} %2)","user":"5ec6de19e4b08d0ec38692da"},{"code":"(fn [f s]\n          (loop [res {} s s]\n                (if (empty? s) res\n                  (let [key (first s) \n                        val (f key)\n                        vec (or (get res val) [])]\n                    (recur (assoc res val (conj vec key)) (rest s))))))","problem":63,"user":"504db141e4b021508a333965"},{"code":"(fn [f l]  (zipmap (set (map f l)) (for [k (set (map f l))] (filter #(= (f %) k) l) )))","problem":63,"user":"50ef3e5de4b0a78662fa2652"},{"problem":63,"code":"(fn [f coll]\n  (reduce (fn [acc e] \n            (let [k (f e) v (or (acc k) [])]\n            (assoc acc k (conj v e)))\n  ) {} coll)\n)","user":"55a74d46e4b09e57187da2a3"},{"problem":63,"code":"(fn [f xs]\n   (persistent!\n     (reduce (fn [acc x]\n             (let [k (f x)]\n               (assoc! acc k (conj (get acc k []) x))))\n           (transient {}) xs)))","user":"52cee992e4b07d0d72b27395"},{"problem":63,"code":"(fn [f coll]\n  (reduce #(update-in %1 [(f %2)] (fnil conj []) %2) {} coll))","user":"540a4f20e4b0addc1aec66ef"},{"code":"(fn mgroup-by [f lst]\r\n  (loop [ls (seq lst) h (hash-map)]\r\n    (if (= nil (first ls))\r\n      h\r\n      (let [k (f (first ls)) s (first ls)]\r\n  (if (contains? h k)\r\n\t  (recur (rest ls) (merge-with (fn[a b] (conj a b)) h {k s}))\r\n\t  (recur (rest ls) (merge h {k [s]})))))))","problem":63,"user":"4ddc620d535d02782fcbea06"},{"problem":63,"code":"(fn group-by*\n  [f coll]\n  (apply merge-with\n         concat\n         (map (fn [x] {(f x) [x]}) coll)))","user":"59b1c2eae4b0e1f4e384c8ec"},{"problem":63,"code":"(fn grp-seq [f coll]\n  (apply merge-with concat (map (fn [x] {(f x) [x]}) coll)))","user":"53da19fde4b0e771c3025484"},{"code":"(fn g [f l]\n  (reduce (fn [m x]\n            (update-in m [(f x)] (comp vec conj) x)) {} l))","problem":63,"user":"532b43c3e4b09d4e7a9b5531"},{"code":"(fn [f xs] (apply merge-with concat (map (fn [x] (assoc (hash-map) (f x) [x])) xs )))","problem":63,"user":"517adc6ce4b0925c997201c4"},{"code":"(fn [f s] (reduce\r\n  (fn [r v]\r\n    (let [fv (f v)]\r\n      (if-let [fsr (r fv)]\r\n        (assoc r fv (conj fsr v))\r\n        (assoc r fv [v])))) \r\n  {}\r\n  s))","problem":63,"user":"4dbbdf86535d3f4042261ece"},{"problem":63,"code":"(fn group-seq [f sequ] (let [worker (fn [xs x] ( let [key  (f x)\n                                                        val (get xs key)\n                                                        newval (if (nil? val) [x] (conj val x))\n                                                        newxs (into xs { key newval})]\n                                                   newxs))]\n                           (reduce worker {} sequ)))","user":"5df0c6ffe4b093ff717275c2"},{"problem":63,"code":"(fn [f s]\n  (reduce (fn [m i]\n            (assoc m\n              (f i)\n              (conj (m (f i) []) i)))\n          {}\n          s))","user":"59e8cd8be4b0249b72820739"},{"problem":63,"code":"(fn[f xs](\n  reduce \n    #(let[k (f %2)] \n      (assoc %1 k (conj (%1 k []) %2))) \n    {} xs))","user":"524f3e6de4b0541d1855b805"},{"problem":63,"code":"(fn my-63\n  [f coll]\n  (reduce (fn [acc v] \n            (if (acc (f v)) \n              (assoc acc (f v) (concat (acc (f v)) [v]))\n              (assoc acc (f v) [v])))\n          {} \n          coll))","user":"56c3aca0e4b05cc29241ee90"},{"problem":63,"code":"(fn [f s]\n   (reduce\n     (fn [r i]\n       (update-in r [(f i)] #(vec (apply conj %&)) i))\n     {}\n     s))","user":"5ebff55de4b00a66d4a95286"},{"code":"(fn [f s] (reduce #(assoc % (f %2) (vec (conj (% (f %2)) %2))) {} s))","problem":63,"user":"52d7a930e4b09f7907dd1379"},{"problem":63,"code":"(fn [f s]\n  (loop [returnMap {}\n         s s]\n    (if (empty? s)\n      returnMap\n      (recur\n        (assoc returnMap\n          (f (first s))\n          (conj (get returnMap (f (first s)) []) (first s)))\n        (rest s)))))","user":"5e950178e4b0fbed045a3801"},{"code":"(fn [f coll]\n  (reduce #(let [key (f %2)]\n             (assoc %1 key (conj (get %1 key []) %2)))\n          {} coll))","problem":63,"user":"519b2570e4b0ac1b7dced6a3"},{"code":"(fn gb [f s]\n  (reduce\n    #(assoc %1 (f %2) (conj (get %1 (f %2) []) %2))\n    {}\n    s))","problem":63,"user":"4f04f847535dcb61093f6beb"},{"problem":63,"code":"(fn [f s]\n  (reduce (fn [acc v]\n            (let [vf (f v)]\n              (if-let [lf (get acc vf)]\n                (assoc acc vf (conj lf v))\n                (assoc acc vf [v]))))\n          {} s))","user":"54c23252e4b045293a27f5fc"},{"problem":63,"code":"(fn [f s]\n  (reduce (fn [m v] (let [k (f v)] (assoc m k (conj (m k []) v)))) {} s))","user":"51435753e4b0c172af7558d5"},{"problem":63,"code":"(fn [f s] (reduce #(assoc %1 (f %2) (vec (conj (%1 (f %2)) %2))) {} s))","user":"573ce277e4b05c31a32c080b"},{"problem":63,"code":"(fn [f s]\n  (reduce #(let [current-value (f %2)] (if (contains? %1 current-value)\n                                         (assoc %1 current-value (conj (get %1 current-value) %2))\n                                         (assoc %1 current-value (vector %2))))\n          {}\n          s))","user":"57d57f65e4b0bd073c2023b3"},{"problem":63,"code":"(fn[f coll]\n  (reduce (fn[res x]\n            (update-in res [(f x)] (comp vec conj) x)) {} coll))","user":"55101237e4b06e50f9beb181"},{"problem":63,"code":"(fn [f c] (reduce #(assoc % (f %2) (vec (conj (% (f %2)) %2))) {} c))","user":"5a6dbaf5e4b0512ff01cda63"},{"code":"(fn [f col]\n  (reduce\n   (fn [map x]\n     (let [key (f x)]\n        (assoc map key (into [] (filter #(= key (f %)) col))))) {} col))","problem":63,"user":"511618b1e4b0d4f670fd2fdf"},{"problem":63,"code":"(fn [pred x]\n  (let [values (distinct (map pred x))]\n    (apply merge (for [v values] {v (filter #(= (pred %) v) x)}))))","user":"5b58d012e4b02d533a91bd71"},{"code":"(fn [fun s]\n    (reduce #(let [k (fun %2)\n                   old-v (if (nil? (get % k))\n                           []\n                           (get % k))]\n               (assoc % k (conj old-v %2))) {} s))","problem":63,"user":"53487737e4b084c2834f4a59"},{"problem":63,"code":"(fn [f coll]\n  (into {}\n    (map \n      (fn\n        [element]\n          [(f (first element)) (vec element)])\n      (partition-by f (sort coll)))))","user":"5a3c06fce4b001c08efc0cdd"},{"code":"#(reduce \n    (fn [m x] (assoc m (% x) (vec (conj (get m (% x)) x)))) \n    {} %2)","problem":63,"user":"4e6a97a9535d8ccf87e9fef8"},{"problem":63,"code":"(fn [f lst]\n  (loop [m {} s (sort-by f lst) c 1]\n    (if (empty? s) m\n      (if (= c (count s)) (recur (assoc m (f (first s)) (take c s)) (nthrest s c) 1)\n        (if (= (f (first s)) (f (nth s c))) (recur m s (inc c))\n          (recur (assoc m (f (first s)) (take c s)) (nthrest s c) 1))))))","user":"558378dce4b05c286339e115"},{"code":"#(reduce (fn [m i] (if (contains? m (% i))\n  (into m {(% i) (conj (m (% i)) i)})\n  (into m {(% i) [i]}))) {} %2)","problem":63,"user":"4ec5d62c535d6d7199dd36ba"},{"problem":63,"code":";cheat!\n(fn [f coll]  \n  (persistent!\n   (reduce\n    (fn [ret x]\n      (let [k (f x)]\n        (assoc! ret k (conj (get ret k []) x))))\n    (transient {}) coll)))","user":"57ba55c1e4b0fbc9809a2801"},{"problem":63,"code":"(fn\n  [f coll]\n  (reduce\n   #(let [k (f %2)]\n      (assoc %1 k (conj (%1 k []) %2)))\n   {} coll))","user":"5c3440fee4b0d62ef62d9f50"},{"code":"#(reduce\n  (fn [l r]\n\t  (let [k (%1 r)]\n\t    (assoc l k (conj (get l k []) r)))) {} %2)","problem":63,"user":"504e685fe4b0f6ff3350c4ae"},{"problem":63,"code":"(fn myGroupBy [f arg] (reduce (fn [x y] (if(nil? (x (f y))) (merge x {(f y) (vector y)}) (update-in x [(f y)] #(vec (concat % (vector y)))))) {} arg ))","user":"542c1f73e4b0dad94371f29d"},{"problem":63,"code":"(fn\n  [f seq]\n  (->> (map #(vector (f(first %)) (vec %))\n       (partition-by f (sort seq)))\n       (into {})))","user":"56df6417e4b0ca2494a095f7"},{"code":"(fn [f c] \n  (apply merge-with concat (map #(hash-map (f %) [%]) c)))","problem":63,"user":"5006b7d2e4b0678c553fc48c"},{"problem":63,"code":"(fn my[f s](reduce (fn[m v](let[k (f v)](assoc m k (if (m k) (conj (m k) v) [v])))) {} s))","user":"5849ac5fe4b089d5ab817ed7"},{"problem":63,"code":"(fn [f coll]\n  (let [ks (map f coll)\n        kvs (map vector ks coll)\n        ans (apply assoc {} (interleave (distinct ks) (repeat [])))]\n    (reduce (fn [m [k v]] (assoc m k (conj (m k) v))) ans kvs)))","user":"5d2e5065e4b01671435dbcae"},{"problem":63,"code":"(fn\n  [f coll]\n  (loop [[x & xs] coll acc {}]\n    (if x\n      (recur xs (update-in acc [(f x)] #(conj (vec %) x)))\n      acc\n      )\n    )\n  )","user":"56edf2dde4b04a395b9a044b"},{"problem":63,"code":"(fn group-seq \n  [f s]\n  (reduce #(assoc %1 (f %2) (conj (apply vector (%1 (f %2))) %2)) {} s))","user":"59e68254e4b0249b728206fc"},{"code":"(fn [f coll] \n  (reduce (fn [res new] \n            (let [v (f new)] \n              (merge res \n                     (if (nil? (res v)) \n                       {v [new]} \n                       {v (conj (res v) new)})))) \n          {} coll))","problem":63,"user":"50de11b2e4b061dbdced7217"},{"problem":63,"code":"#(apply merge-with concat (map (fn [x] {(%1 x)  [x]}) %2))","user":"56ecc4b5e4b04a395b9a043e"},{"code":"(fn [f s]\n  (reduce #(let [k (f %2)] (assoc %1 k (conj (%1 k []) %2))) {} s))","problem":63,"user":"5338e33fe4b0e30313ee6ca1"},{"code":"(fn [f s] (reduce (fn [m el] (update-in m [(f el)] #(conj (or % []) el) )) {} s))","problem":63,"user":"52cc85abe4b07d0d72b27367"},{"code":"#(reduce\r\n(fn [m x] (assoc m (% x) (conj (m (% x) []) x))) \r\n{} %2)","problem":63,"user":"4db858d1535d1e037afb218c"},{"code":"(fn [f coll]\r\n  (loop [cur {} res (seq coll)]\r\n    (if (seq res)\r\n      (let [[item & res] res\r\n      x (f item)]\r\n\t(if-let [in-map (get cur x nil)]\r\n\t  (recur (assoc cur x (conj in-map item)) res)\r\n\t  (recur (assoc cur x (vector item)) res)))\r\n      cur)))","problem":63,"user":"4e02bee8535d04ed9115e791"},{"code":"(fn [f x]\r\n  (apply merge-with into\r\n         (map #(hash-map (f %) (vector %)) x)))","problem":63,"user":"5376966ae4b06839e8705e27"},{"problem":63,"code":"#(apply \n  merge-with \n  concat       \n  (map (fn [elem] (hash-map (%1 elem) [elem])) %2))\n\n\n;#(reduce \n;  (fn [acc elem]\n;    (let [res (%1 elem)]\n;      (assoc \n;        acc res \n;        (conj (get acc res []) elem)))) \n;  {} \n;  %2)\n\n;#(reduce \n; (fn [acc elem]\n;   (let [res (%1 elem)]\n;     (if-let [ls (get acc res)]\n;       (assoc acc res (conj ls elem))\n;       (assoc acc res [elem]))))\n; {}\n; %2)","user":"52f3568fe4b05e3f0be25f0e"},{"problem":63,"code":"(fn [f s]\n (apply hash-map\n (mapcat (fn [y] (list (first (first y)) (map (fn [u] (second u)) y)))\n (partition-by first\n  (sort-by first\n  (map (fn [x] (list (f x) x)) s)\n ))))\n )","user":"50856bd1e4b004985b776e4c"},{"problem":63,"code":"#(reduce \n  (fn [coll val] (merge-with into coll { (%1 val) [val] }))\n  {} \n  %2)","user":"560039cce4b04bb52996e162"},{"code":"(fn [f vs] (reduce (fn [h v] (merge-with concat h {(f v) [v]})) {} vs))","problem":63,"user":"526439a4e4b03e8d9a4a70cc"},{"code":"(fn [f c]\n  (->> (map #(do {(f %) [%]}) c)\n       (apply merge-with concat)))","problem":63,"user":"528a3e14e4b0239c8a67ae72"},{"code":"(fn [f stuff]\n  (apply merge-with\n    (comp vec concat)\n    (map #(hash-map (f %) [%]) stuff)))","problem":63,"user":"4e98a6d0535dbda64a6f6b5e"},{"code":"(fn [f xs]\n  (reduce \n    (fn [m v](let [k (f v)]\n                (assoc m k (conj (get m k []) v))))\n    {}\n    xs))","problem":63,"user":"4efcac3a535de96065cf507e"},{"problem":63,"code":"(fn [f col]\n  (reduce #(assoc %1 (f %2) (conj (into [] (get %1 (f %2))) %2)) {} col))","user":"5793931ee4b0e215f87e845c"},{"problem":63,"code":"(fn [f coll] (into {} (map (fn [k] (hash-map k (filter #(= k (f %1)) coll))) (set (map f coll)))))","user":"59ba2ea0e4b0a024fb6ae3e1"},{"problem":63,"code":"(fn [f xs] \n  (apply merge-with concat (for [x xs] {(f x) [x]})))","user":"5c58736be4b01df32ab73247"},{"problem":63,"code":"(fn [f s]\n  (into {}\n        (map\n         #(vector (f (first %)) (vec %))\n         (partition-by f (sort s)))))","user":"537e104ce4b06839e8705e9a"},{"problem":63,"code":"(fn [f ss] (reduce (fn [m s] (merge-with (comp (partial into []) concat) m {(f s) [s]})) {} ss))","user":"54d7e277e4b0a52adc2e2031"},{"problem":63,"code":"(fn [f s]\n\t (reduce\n\t  #(if (contains? %1 (f %2))\n\t     (assoc %1 (f %2) (conj (get %1 (f %2)) %2))\n\t     (assoc %1 (f %2) [%2]))\n\t  {} s))","user":"53da3fcde4b0e771c3025497"},{"code":"(fn [f xs]\n   (let [d (distinct (map f xs))]\n     (zipmap d (map #(filter (fn [x] (= % (f x))) xs) d))))","problem":63,"user":"4e3a9dae535deb9a81d77f4a"},{"code":"(fn [f s]\n  (reduce\n    (fn [r x]\n      (let [k (f x)]\n        (assoc r k (conj (or (get r k) []) x))))\n    {}\n    s))","problem":63,"user":"4dbdc9da535d020aff1edf4c"},{"problem":63,"code":"(fn\n  [f xs]\n  (reduce\n   (fn [acc x]\n     (let [k (f x)]\n       (assoc acc k (conj (get acc k []) x))))\n   {}\n   xs))","user":"4eb7b049535d7eef30807377"},{"problem":63,"code":"(fn f[c a] (if (empty? a) {} (assoc (f c (rest a)) (c (first a)) (cons (first a) ((f c (rest a)) (c (first a)))))))","user":"59e8bb43e4b0249b72820735"},{"problem":63,"code":"(fn [f coll]\n  (reduce \n   (fn [acc el] \n     (let [key (f el)]\n       (conj acc { key (conj (get acc key []) el) }))) {} coll))","user":"59a72effe4b066c664927d94"},{"code":"(fn [gfn coll]\r\n    (let   [map-coll     (fn [coll] (map #(hash-map (gfn %) [%]) coll))\r\n            merge-coll   (fn [coll] (apply merge-with (concat (list concat) coll)))]\r\n    (-> coll map-coll merge-coll)))","problem":63,"user":"4e2f9e71535deb9a81d77f11"},{"problem":63,"code":"(fn [f x] \n      (apply hash-map (mapcat #(list (f (first %)) %) (partition-by f (sort-by f x)))))","user":"54c169ade4b0ed20f4ff6f24"},{"code":"(fn [f the-s]\n   (loop [s the-s m {}]\n     (if (empty? s)\n       m\n       (let [v (first s) k (f v) vs (get m k [])]\n         (recur (rest s) (assoc m k (conj vs v)))))))","problem":63,"user":"4fa0a4b1e4b0dcca54ed6d4f"},{"problem":63,"code":"(fn [f h] (reduce #(update-in %1 (keys %2) (fn [ov] (conj (if (nil? ov) [] ov) (first (vals %2)))) ) {} (map #(hash-map (f %) %) h)))","user":"53a5bc3ae4b0ef122a8689c3"},{"problem":63,"code":"(fn [f coll] (zipmap (distinct (map f coll)) (partition-by f (sort-by f coll))))","user":"5472d919e4b094393f72dd7b"},{"problem":63,"code":"(fn [f arg]\n  (loop\n    [todo arg\n     out  {}]\n    (if (empty? todo)\n      out\n      (let [elem (first todo)\n            res (f elem)\n            cont (out res)]\n      (recur (rest todo) (merge out {res (conj (if (nil? cont) [] cont) elem)}))))))","user":"5658d775e4b00d3155796114"},{"code":"(fn [f s]\r\n  (let [keys (map f s),\r\n        pairs (map #(list %1 %2) keys s)]\r\n    (zipmap (set keys)\r\n            (map (fn [k] (map second (filter #(= (first  %) k) pairs)))\r\n                (set keys)))\r\n        ))","problem":63,"user":"4f62b29ce4b0defedf855fd9"},{"problem":63,"code":"(fn [f xs]\n  (reduce \n   #(assoc %1 \n           (f %2) \n           (conj \n            (get %1 (f %2)) \n            %2))\n   {}\n   (reverse xs)))","user":"59497f51e4b07ddc2dafaddd"},{"problem":63,"code":"(fn [f s]\n  (reduce (fn [m i]\n            (assoc m\n              (f i)\n              (conj (m (f i) []) i)))\n          {}\n          s))\n\n;;; assoc -> assoc[iate]. When applied to a map, returns a new map of the\n;;;  same (hashed/sorted) type, that contains the mapping of key(s) to\n;;;  val(s). When applied to a vector, returns a new vector that\n ;;; contains val at index. Note - index must be <= (count vector).","user":"6075c214e4b069485764de5b"},{"code":"(fn [f s]\r\n   (reduce #(let [nkey (f %2)]\r\n              (assoc %1 nkey \r\n                     (conj (get %1 nkey []) %2)))\r\n           {} s))","problem":63,"user":"4e0d8c27535d04ed9115e7b7"},{"code":"(fn [f xs]\n  (reduce #(update-in % [(f %2)] concat [%2]) {} xs))","problem":63,"user":"51b38769e4b026427ecf067f"},{"problem":63,"code":"(fn [f col]\n      (reduce (fn [ret e]\n                (let [k (f e)]\n                  (assoc ret k (conj (get ret k []) e)))) {} col))","user":"52c49401e4b0c2d177d620de"},{"problem":63,"code":"(fn my-group-by [func col]\n  (loop [r col\n         result-map {}]\n    (if (not-empty r)\n      (let [head (first r)                                  ; as long as we have more items\n            applied (func head)]\n        (if-let [existing (result-map applied)]  ; if we already have a list of vector for this key\n          (recur (rest r) (->> head (conj existing) (assoc result-map applied))) ; add the r to this vector and assoc it again\n          (recur (rest r) (assoc result-map applied [head])) ; create a new key value pair and recur\n          ))\n      result-map)                                           ; return the result if there are not more items on r\n    ))","user":"5d80f328e4b0915913b1d372"},{"code":"(fn [f coll]\n   (apply merge-with concat (for [x coll] {(f x) [x]}))\n   )","problem":63,"user":"52527192e4b0541d1855b8af"},{"problem":63,"code":";(fn [f s]\n;\t(loop [m {} s s]\n;\t\t(if (empty? s)\n;\t\t\tm\n;\t\t\t(let [v (first s) k (f v)]\n;\t\t\t\t(if (contains? m k)\n;\t\t\t\t\t(recur (assoc m k (conj (get m k) v)) (rest s))\n;\t\t\t\t\t(recur (assoc m k [v]) (rest s)))))))\n\n;(fn [f s]\n;\t(reduce (fn [acc x]\n;\t\t\t\t\t\t(merge-with\n;\t\t\t\t\t\t\tconcat\n;\t\t\t\t\t\t\tacc\n;\t\t\t\t\t\t\t{(f x) [x]}))\n;\t\t\t\t\t{}\n;\t\t\t\t\ts))\n\n(fn [f s]\n\t(reduce \n\t\t#(merge-with concat % {(f %2) [%2]})\n\t\t{} \n\t\ts))","user":"5f6a583ae4b02876ed9fd046"},{"code":"(fn [f coll]\n    (reduce\n      (fn [a b]\n        (let [e (f b)]\n          (assoc a e (conj (get a e []) b))))\n      {} coll))","problem":63,"user":"4e8e8c24535d65386fec2143"},{"code":"(fn [f a]\n  (reduce\n    (fn [n m]\n      (merge n\n        (hash-map m (vec (filter #(= m (f %)) a)))\n      )\n    )\n    {}\n    (distinct (map f a))\n  )\n)","problem":63,"user":"4f8ea1f7e4b0d4e659cdde69"},{"problem":63,"code":";; unnecessarily long, but I'll leave it here anyway for the record :-)\n;; should better be solved using reduce and merge-with\n(fn [f coll]\n  (let [ll (map #(vector (f %) [%]) coll)]\n    (reduce\n     (fn [grpmap kvpair]\n       (let [k (first kvpair)\n             newval (second kvpair)\n             oldval (grpmap k [])]\n         (assoc grpmap k (into [] (concat oldval newval)))))\n     {} ll)))","user":"5c03e927e4b0bdcf453d167b"},{"code":"(fn [f s]\n   (reduce (fn [a b] (assoc a (first b) (into [] (concat (a (first b)) (second b))))) {} (map (fn [x] (list (f x) [x])) s)))","problem":63,"user":"52eee533e4b05e3f0be25ecb"},{"code":"(fn [p xs] (reduce #(merge-with concat %1 {(p %2) [%2]}) {} xs))","problem":63,"user":"52618ea3e4b03e8d9a4a7064"},{"problem":63,"code":"(fn [f v]\n  ((fn [f v m]\n     (if (empty? v)\n       m\n       (if (nil? (keys m))\n         (recur f (rest v) (conj m [(f (first v)) [(first v)]]))\n         (if (= (.contains (keys m) (f (first v))) true)\n           (recur f (rest v) (update-in m [(f (first v))] conj (first v)))\n           (recur f (rest v) (conj m {(f (first v)) [(first v)]})))))) f v {}))","user":"60aecd73e4b00e9e6653c49a"},{"code":"(fn [arga argb] \n  (reduce \n   (fn [a b] (merge-with #(vec (concat %1 %2)) a b)) \n     (map #(array-map (arga %) [%]) argb)\n  ))","problem":63,"user":"52747090e4b03e8d9a4a74a5"},{"problem":63,"code":"(fn group-by2\n  [f coll]\n  (loop [coll2 coll\n         res_map {}]\n    (if-let [x (first coll2)]\n      (let [k (f x)]\n        (recur (rest coll2) (assoc res_map k (into [] (conj (get res_map k) x)))))\n      res_map)))","user":"5f6e23e6e4b02876ed9fd064"},{"problem":63,"code":"(fn [f s]\n  (let [grouper (fn [groups val] (update-in groups [(f val)] (fnil #(conj % val) [])))]\n    (reduce grouper {} s)))","user":"4ecb1641535d6d7199dd370e"},{"problem":63,"code":"(fn group [f coll]\n  (apply merge-with into (map #(hash-map (f %) [%]) coll)))","user":"5d7b90ede4b02e6b30c93552"},{"code":"(fn [f s]\n  (reduce (fn [m x] \n    (let [v (m (f x))]\n      (assoc m (f x) (conj (if (seq v) v []) x)))) {} s))","problem":63,"user":"4f4c6b21e4b03ad3f0c10c8f"},{"code":"(fn gb [f v]\n  (let [kvs (map vector (map f v) v)\n        p (fn [x] {(x 0) [(x 1)]})]\n    (apply merge-with concat (map p kvs))))","problem":63,"user":"51d96ad0e4b02ceefd94774f"},{"problem":63,"code":"(fn my-group-by\n  [f coll]\n  (letfn\n      [(reduce-coll [f map se]\n                   (if (not-empty se)\n                    (let [next-element (first se)\n                          result (f next-element)\n                          new-map (update-in map [result] #(conj (into [] %1) %2) next-element)]\n                      ;; associate the result with the function-input-value which lead to it\n                      ;; sequentially using the next value in se\n                      (reduce-coll f new-map (rest se))) ;; recursive call if more inputs exist\n                    map))] ;; base case\n    (reduce-coll f {} coll)))","user":"55a9e0fee4b0988bba2ad945"},{"problem":63,"code":"(fn [f col] (reduce #(assoc %1 (f %2) (concat (%1 (f %2)) [%2])) {} col))","user":"547c2c6ce4b0c51c1f4d72e3"},{"code":"(fn [f col]\n  (reduce (fn [m e] (update-in m [(f e)] #(concat %1 [e]))) {} col))","problem":63,"user":"4fd7962ee4b0dab7d829f385"},{"problem":63,"code":"(fn [f coll]\n  (reduce (fn [acc n]\n            (if (contains? acc (f n))\n              (assoc acc (f n) (conj (acc (f n)) n))\n              (assoc (assoc acc (f n) []) (f n) (conj [] n))))\n          {}\n          coll))","user":"53a2a259e4b0f1fc7453882c"},{"problem":63,"code":"(fn [f s]\n    (reduce (fn [m v]\n              (let [k (f v)]\n                (assoc m k (conj (or (m k) []) v)))) {} s))","user":"538ca203e4b0b51d73faae5f"},{"problem":63,"code":"(fn gb\n  [f coll]\n  (loop [result {} co coll]\n    (if (empty? co)\n      result\n      (recur (assoc result\n               (f (first co))\n               (conj (get result (f (first co)) []) (first co)))\n             (rest co))))\n  )","user":"5f9c4113e4b0715f5002d821"},{"problem":63,"code":"(fn [f lst]\n   (loop [l lst n (count lst) m {}]\n      (if (zero? n)\n         m\n         (if (contains? m (f (first l)))\n            (recur\n               (rest l)\n               (dec n)\n               (update-in \n                  m \n                  [(f (first l))] \n                  #(conj % (first l))))\n            (recur\n               (rest l)\n               (dec n)\n               (assoc\n                  m\n                  (f (first l))\n                  (vector (first l))))))))","user":"5a653f80e4b0512ff01cd9b2"},{"problem":63,"code":"(fn my-group-by [f coll]\n  (reduce (fn [ret x]\n            (let [k (f x)]\n              (assoc ret k (conj (get ret k []) x))))\n          {}\n          coll))","user":"53b7aa6ce4b047364c0444d1"},{"problem":63,"code":"(fn my-group-by \n  ([f coll]\n   (my-group-by f coll {}))\n  ([f coll res]\n   (if (empty? coll)\n     res\n     (let [x (first coll) fx (f (first coll))]\n       (if (nil? (get res fx))\n         (recur f (rest coll) (assoc res fx [x]))\n         (recur f (rest coll) (assoc res fx (conj (get res fx) x)))))))\n  )","user":"56f188e9e4b04a395b9a0494"},{"problem":63,"code":"(fn [f coll]\n  (reduce (fn [a b]\n            (update-in a [(f b)] (fnil conj []) b))\n          {}\n          coll))","user":"53ea5851e4b036ad0777e4e4"},{"problem":63,"code":"(fn groupBy [f data]\n  (reduce (fn [acc x](let [k (f x)] (assoc acc k (conj (get acc k []) x))))\n   {} data\n  )\n )","user":"5509a23ee4b06e50f9beb11a"},{"problem":63,"code":"(fn -group-by [f x]\n  (let [\n        assoc2 (fn [x y]\n                 (let [k (first y) v (-> y rest first)] \n                   (assoc x k (conj (vec (x k)) v))))\n        m (partition 2 (interleave (map f x) x))\n        ]\n    (println m)\n    (reduce assoc2 {} m)))","user":"52ee0de4e4b05e3f0be25ec1"},{"problem":63,"code":"#(loop [acc {} ks (map % %2) vs %2]\n   (if (empty? ks)\n     acc\n     (let [[k & ks] ks\n           [v & vs] vs]\n       (recur (assoc acc k (conj (get acc k []) v)) ks vs))))","user":"565e0934e4b068f2fe63dc30"},{"problem":63,"code":"(fn [f coll] \n  (zipmap (set (map f coll)) (for [x (set (map f coll))]\n                                       (for [y coll\n                                             :when (= x (f y))]\n                                         y))))","user":"534fa9dae4b084c2834f4acf"},{"code":"(fn mt [f a] \n(reduce \n   #(assoc %1 (f %2) (vec (conj (%1 (f %2)) %2)) ) \n{} a)\n)","problem":63,"user":"4e9de526535dbda64a6f6b8e"},{"code":"(fn [f s]\r\n  (reduce #(assoc %1 \r\n                  (f %2)\r\n                  (conj (get %1 (f %2) []) %2)) {} s))","problem":63,"user":"4f82ed48e4b033992c121c0e"},{"code":"(fn [f s]\n      (reduce\n         (fn [b v]\n           (update-in b [(f v)] (fnil conj []) v)\n           )\n         {} s))","problem":63,"user":"4e8df08f535d65386fec213e"},{"problem":63,"code":"(fn [f s]\n  (let [lislis (sort-by first (partition 2 (interleave (map f s) s)))]\n    (apply hash-map (interleave (distinct (map first lislis))\n                (for [k (distinct (map first lislis))]\n                  (map second (filter #(= k (first %)) lislis)))))))","user":"5705e404e4b0b0fb43fd0676"},{"code":"(fn [f s] (reduce (fn [m x] (assoc m (f x) (conj (get m (f x) []) x))) {} s))","problem":63,"user":"4fcebce4e4b03432b189f404"},{"problem":63,"code":"(fn [f coll]\n    (letfn [(update [m k f]\n        (assoc m k (f (get m k))))]\n    (reduce (fn [r x] (update r (f x) (fnil #(conj % x) [] ))) {} coll)\n))","user":"566ff0a1e4b0a866af6896ec"},{"problem":63,"code":"(fn [f s]\n  (reduce\n   (fn [acc value]\n     (let [key (f value)]\n       (assoc acc key (conj (get acc key []) value))))\n   {}\n   s))","user":"55f5b8d6e4b06e875b46ce8d"},{"problem":63,"code":"(fn x\n      ([f xs] (x f {} xs))\n      ([f a xs] (letfn [(d [k v] (\n                                  do (println {:key k :val v :hash a})\n                                  (assoc a k (conj (get a k []) v))))]\n                  (if (empty? xs)\n                    a\n                    (x f\n                       (d (f (first xs)) (first xs))\n                       (rest xs))))))","user":"4ec66e84535d6d7199dd36cd"},{"code":"(fn [f s]\n  (loop [res {} s s]\n    (if-let [[x & xs] s]\n      (let [v (f x)]\n        (if (contains? res v)\n          (recur (conj res {v (conj (res v) x)}) xs)\n          (recur (conj res {v [x]}) xs)\n          )\n        )\n      res\n      )\n    )\n  )","problem":63,"user":"5298d3f4e4b02ebb4ef75068"},{"problem":63,"code":"(fn [f s]\n    (apply merge-with concat\n           (map (fn [x] (hash-map (f x) [x])) s)))","user":"53613db8e4b0243289761e41"},{"problem":63,"code":"(fn[f col]\t\n\t\t(reduce #(let[fx (f %2)] (assoc %1 fx (conj (%1 fx []) %2))) {} col))","user":"54f4a457e4b0f2f3c5226e83"},{"code":";(fn [f s]\n;  (let [chunked (partition-by f (sort-by f s))]\n;    (zipmap (map #(f (first %)) chunked) chunked)))\n\n(fn [f s]\n  (reduce\n   (fn [res x]\n     (assoc res (f x) (conj (get res (f x) []) x)))\n   {}\n   s))","problem":63,"user":"50d8f4b6e4b01f0871336e74"},{"problem":63,"code":"(fn [f xs]\n    (reduce (fn [acc v] (assoc acc (f v) (conj (get acc (f v) []) v)))\n            {}\n            xs))","user":"513e8141e4b02b2a3d8235c1"},{"problem":63,"code":"(fn [p c]\n  (reduce #(let [pr (p %2)]\n             (if (% pr)\n               (assoc % pr (conj (% pr) %2))\n               (assoc % pr [%2]))) {} c))","user":"5b22328ee4b03cfeda66ed5d"},{"problem":63,"code":"(fn [f s]\n  (reduce (fn [agg r] \n            (update-in agg [(f r)] #(if (nil? %) (vector r) (conj % r)) )) {} s))","user":"58524875e4b0b7285a6f4ead"},{"problem":63,"code":"(fn mgrp\n  [f seq1]\n   (let [result (map f seq1)\n         bigmap (partition 2 2 (interleave result seq1))]\n     (reduce #(if (contains? %1 (first %2))\n           (assoc %1  (first %2) (conj (get %1 (first %2)) (second %2)))\n           (assoc %1  (first %2) (vector (second %2))) )\n            {}\n            bigmap)))","user":"53d6b266e4b0e771c3025459"},{"code":"(fn [f coll]\n  (let [values (partition-by f (sort-by f coll))]\n    (zipmap (map #(f (first %)) values) values)))","problem":63,"user":"4ecf42b4535d1f5ad70dba3c"},{"problem":63,"code":"(fn [f s] (reduce (fn [m v] (let [k (f v) {cv k} m] (assoc m k (if cv (conj cv v) [v])))) {} s))","user":"56baa68ce4b0f26550335947"},{"code":"#(reduce (fn [a v] (let [k (% v)] (assoc a k (conj (a k []) v)))) {}  %2)","problem":63,"user":"4ed45563535d10e5ff6f52c9"},{"code":"(fn [f ks]\n  (reduce #(let [k (f %2)\n                 bucket (get %1 k [])]\n             (assoc %1 k (conj bucket %2)))\n          {} ks))","problem":63,"user":"4fa6d532e4b081705acca1be"},{"code":"(fn [f x] (reduce #(let [k (f %2) w (or (% k) [])] (assoc % k (conj w %2))) {} x))","problem":63,"user":"4db016af838c48654951d9b9"},{"problem":63,"code":"#(apply merge-with concat (map (fn [n] {(%1 n) [n]}) %2))","user":"59ef6cfae4b0966464fe6a32"},{"code":"(fn my-group-by [f coll]\n    (reduce\n     (fn [acc [k v]] (assoc acc k (conj (get acc k []) v)))\n     {}\n     (map #(list (f %) %) coll)))","problem":63,"user":"504f57c7e4b0a02f9cffde71"},{"code":"(fn [f c] (apply merge-with concat (for [x c] {(f x) [x]})))","problem":63,"user":"51e00020e4b01188f0627534"},{"problem":63,"code":"(fn mygroupby [f s]\n  (loop [f f m {} v (first s) s (rest s)]   ;; loop, passing an initially empty map\n    (if (nil? v)\n      m                                     ;; done... return the map\n      (let [k (f v)                         ;; map key... just apply the function\n            me (if (nil? (m k)) [] (m k))   ;; current map entry if any, otherwise []\n            m (assoc m k (conj me v))]      ;; add v to the map entry\n        (recur f m (first s) (rest s))))))","user":"5cab33e7e4b048ec896c5c48"},{"problem":63,"code":"(fn [f l]\n  (reduce #(let [k (f %2)]\n            (assoc %1 k (conj (get %1 k []) %2))) {} l))","user":"58844d43e4b0f1effa3b7696"},{"code":"(fn [f xs]\n  (apply (partial merge-with concat) (map #(hash-map (f %) [%]) xs)))","problem":63,"user":"4f8345c6e4b033992c121c1b"},{"code":"( fn [f, xs] ( reduce #( assoc % (f %2) (conj (or (% (f %2)) [] ) %2 ) ) {} xs ) )","problem":63,"user":"51aa4eede4b04e3dc0c27b25"},{"code":"(fn [f coll]\n  (reduce\n    (fn [ret x]\n      (let [k (f x)]\n        (assoc ret k (conj (get ret k []) x))))\n    {} coll))","problem":63,"user":"4f031eac535dcb61093f6a67"},{"code":"(fn [f s]\n              (reduce\n                #(let [n (f %2)\n                       v (%1 n)]\n                   (if \n                     (nil? v) \n                     (assoc %1 n [%2])\n                     (update-in %1 [n] conj %2)))\n                {}\n                s))","problem":63,"user":"4f73f78de4b044e54cd9a8f3"},{"problem":63,"code":"(fn [f s]\n  (into {} (map #(vector (first %) (vec (reverse (second %)))) (reduce #(update-in %1 [(f %2)] conj %2) {} s))))","user":"56903cb9e4b0dcc4269f40eb"},{"code":"(fn [f coll]\n  (let [parts (partition-by f (sort-by f coll))]\n    (apply hash-map (interleave (map (comp f first) parts) parts))))","problem":63,"user":"50cb4cf6e4b0f78a8e1645b4"},{"problem":63,"code":"#(reduce\n    (fn[acc v]\n      (let [k (%1 v)]\n        (assoc acc k (conj (acc k []) v)))) {} %2)","user":"5b6473eee4b0c6492753e73f"},{"code":"(fn [p xs] (reduce #(assoc %1 (p %2) (conj (get %1 (p %2) []) %2)) {} xs))","problem":63,"user":"4ed286d4535d44c135fd68d7"},{"problem":63,"code":"(fn [f vec] (into {} (map (fn [[k vs]] [k (reverse vs)]) (reverse ((fn group\n  ([f [x & xs] map']\n    (if x\n      (group f xs (assoc map' (f x) (cons x (get map' (f x)))))\n      map'))) f vec {})))))","user":"57915ba4e4b0ebec4cfb75ba"},{"code":"(fn\n   [f l]\n   (loop [m {}\n          l l]\n     (if (empty? l)\n       m\n       (let [v (first l)\n             k (f v)]\n         (recur\n          (update-in m [k]\n                     (fn [x] (if (nil? x) [v] (conj x v))))\n          (rest l))))))","problem":63,"user":"4fc8c8d8e4b0ee37620e183b"},{"code":"(fn [f s] (apply (partial merge-with concat) \n  (map (fn [x] {(f x) [x]}) s)))","problem":63,"user":"4e976daa535dbda64a6f6b54"},{"problem":63,"code":"(fn [f s]\n  (reduce\n   \t(fn [out x]\n      (let [[key val] x]\n        (if (out key)\n          (assoc out key (concat (out key) [val]))\n          (assoc out key [val])\n        )\n      )\n    )\n   \t{}\n    (map (fn [x] [(f x) x]) s)\n  )\n)","user":"50e3cf55e4b01912b3285c45"},{"problem":63,"code":"(fn [f ls]\n  (reduce\n   (fn [acc x]\n     (assoc\n      acc\n      (f x)\n      (concat (get acc (f x) '()) [x])))\n   {}\n   ls))","user":"5d672bd7e4b0db5d338d15f1"},{"problem":63,"code":"(fn [f s]\n         (apply merge-with concat\n                (map #(hash-map (f %) (list %)) s)))","user":"55dcb06ee4b050e68259b3b9"},{"code":"(fn my-group-by [f s]\n  (reduce #(let [k (f %2)]\n             (assoc %1 k (conj (or (%1 k) []) %2))) {} s))","problem":63,"user":"511e763ce4b03e81d390ac29"},{"problem":63,"code":"(fn[f v](into {} (map #(vector (f (first %)) (vec %)) (partition-by f (sort v)))))","user":"60195030e4b0bf4ca6b10920"},{"problem":63,"code":"(fn [f seqs]\n  (reduce\n   (fn [m e]\n     (let [k (f e)\n           prev (m k)\n           v  (reverse (conj (reverse prev) e))]\n     (assoc m k v)))\n   {} seqs))","user":"5e08c3dde4b0978307768fc8"},{"code":"(fn [f acol]\n  (reduce (partial merge-with concat)\n          {}\n          (map #(hash-map (f %) [%]) acol)))","problem":63,"user":"4f9d53f3e4b0dcca54ed6d21"},{"code":"(fn [f coll]\n(loop [coll coll tmp {}]\n      (if (empty? coll)\n        tmp\n        (let [head (first coll)\n              group (f head)\n              other-in-group (get tmp group)]\n          (if (nil? other-in-group)\n            (recur (rest coll) (assoc tmp group [head]))\n            (recur (rest coll) (assoc tmp group (conj other-in-group head)))\n     )))))","problem":63,"user":"4e88feef535d8b9bb0147ca8"},{"code":"(fn my-group-by\n  [f xs]\n  (loop [accum {} xs (seq xs)]\n    (if xs\n      (let [x (first xs) v (f x)]\n        (recur (assoc accum v (conj (get accum v []) x)) (next xs)))\n      accum)))","problem":63,"user":"4e50b67b535dc968683fc4ed"},{"code":"(fn [f c] (reduce #(assoc % (f %2) (conj (% (f %2) []) %2)) {} c))","problem":63,"user":"4e6e2ac4535d5021c1a895ff"},{"problem":63,"code":"(fn [f x] (apply merge-with concat (map #(hash-map %1 (vector %2)) (map f x) x)))","user":"55c6fd60e4b0e31453f649c9"},{"problem":63,"code":"(fn my_group-by\n\t([f vs]\n\t\t(my_group-by f vs {}))\n\t([f vs result]\n\t\t(if (empty? vs)\n\t\t\tresult\n\t\t\t(recur f (rest vs) (assoc result (f (first vs)) (conj (or (get result (f (first vs))) []) (first vs)))))))","user":"5954eef0e4b066ee0a44af17"},{"problem":63,"code":"(fn my-groupby\n  [f xs]\n  (letfn [(add-entry [m [k v]]\n            (assoc m k (concat (m k) (vector v))))\n          (make-map [m xs]\n            (if (not-empty xs)\n              (make-map (add-entry m (first xs)) (rest xs))\n              m))]\n    (make-map {} (map vector (map f xs) xs))))","user":"557e9d17e4b05c286339e0d8"},{"problem":63,"code":"(fn [f s]\n  (let [k-v (map #(list (f %) %) s)\n        ks (into #{} (map first k-v))]\n    (into {}\n          (map (fn [x] [x (map second (filter (fn [y] (= x (first y))) k-v))]) ks))))","user":"5ab564f8e4b073f177442639"},{"code":"(fn [f x]\n   (reduce\n     (fn [y xs]\n       (let [k (f xs)]\n         (assoc y k (conj (get y k []) xs))\n         ))\n     {} x))","problem":63,"user":"4f616892e4b0defedf855fbf"},{"code":"(fn group-by* [f col]\n  (let [f* (fn [init c]\n             (let [k (f c)]\n               (assoc init k (concat (get init k (list)) (list c)))))]\n    (reduce f* {} col)))","problem":63,"user":"51d662fce4b0154f82ab92ef"},{"problem":63,"code":"(fn [f coll]\n    (let [ordered-set (map vector (map f coll) coll)\n          unique-keys (into #{} (map first ordered-set))\n          values-for-key (fn [k coll] (map last (filter #(= (first %) k ) coll )))]\n      (into {}\n        (for [i unique-keys]\n        [i (values-for-key i ordered-set)]))))","user":"515ebde3e4b01e5d11ccd0a8"},{"problem":63,"code":"(fn [f coll]\n  (reduce (fn [m v]\n            (let [k (f v)]\n              (update-in m [k] (fnil conj []) v))) {} coll))","user":"59074b7ce4b047aa04b19951"},{"problem":63,"code":"(fn [f xs]\n  (reduce (fn [m k] (update-in m [(f k)] #(conj (or %1 []) %2) k))\n          {}\n          xs))","user":"546a6c7ce4b00cfc9eacc154"},{"problem":63,"code":"(fn [f l] (apply merge-with concat (map hash-map (map f l) (map list l))))","user":"54857e3be4b0e286459a11ad"},{"problem":63,"code":"(fn [func vals] (into {} (map #(vector (func (first %)) (vec %)) (partition-by func (sort vals)))))","user":"5ab23a78e4b073f1774425e1"},{"code":"#(apply merge (for [x (->> %2 (map %1) distinct)]\r\n{x (filter (fn [y] (= (%1 y) x)) %2)}))","problem":63,"user":"502a9fdee4b095a7adb898b4"},{"problem":63,"code":"(fn [f vs]\n  (reduce \n   (fn [groups v] \n     (let [k (f v)] (assoc groups k (conj (get groups k []) v)))) {} vs))","user":"5dc9c4f2e4b02f9375f4e1f0"},{"problem":63,"code":"(fn [f a]\n  (loop [arr a\n         final {}]\n    (if (empty? arr)\n      final\n      (let [[el & r] arr] \n        (recur\n         r\n         (#(assoc %1 %2 (conj (get %1 %2 []) %3)) final (f el) el))))))","user":"5bf0aefde4b0a6d31fed215a"},{"problem":63,"code":"(fn [f x]\n   (letfn [(g [y z] (conj (vec y) z))]\n     (reduce #(update-in % [(f %2)] g %2) {} x)))","user":"54344721e4b0b6b47310fcea"},{"problem":63,"code":"(fn my-gb [f seq]\n  (let [kv-seq (for [x seq] [(f x) [x]])]\n    (reduce #(assoc % (first %2)\n                    (concat (% (first %2)) (second %2)))\n            {} kv-seq)))","user":"569dd6e8e4b0542e1f8d1480"},{"problem":63,"code":"#(reduce (fn [ret x]\n           (let [k (%1 x)]\n             (assoc ret k (conj (get ret k []) x))))\n         {} %2)","user":"5823d3e6e4b051871117beb8"},{"code":"(fn [p xs]\r\n      (loop [xs xs ret {}]\r\n        (if (nil? (seq xs)) ret\r\n            (recur (rest xs) (update-in ret [(p (first xs))] #(if (nil? %) [(first xs)] (conj % (first xs))))))))","problem":63,"user":"4e26e8b4535deb9a81d77ef6"},{"code":"(fn [f c]\n  (loop [res {} r c]\n    (if (empty? r)\n      res\n      (if (contains? res (f (first r)))\n          (recur \n            (assoc res (f (first r)) (conj (res (f (first r))) (first r))) \n            (rest r))\n          (recur \n            (assoc res (f (first r)) [(first r)]) \n            (rest r))))))","problem":63,"user":"4dbd2aa3535d020aff1edf40"},{"problem":63,"code":"(fn gb [f s]\n  (loop [s s\n         acc {}]\n    (if (empty? s)\n      acc\n      (recur (rest s)\n             (assoc acc\n                    (f (first s))\n                    (conj (acc (f (first s)) [])\n                          (first s)))))))","user":"54084784e4b0addc1aec66c9"},{"problem":63,"code":"(fn [fun coll]\n  (reduce \n          #(assoc \n                  %1 \n                  (fun %2) \n                  (vec (conj (%1 (fun %2)) %2))) \n          {} \n          coll))","user":"5a0ef454e4b04bbd27e6d9fa"},{"problem":63,"code":"(fn [f xs] (reduce #(let [r (f %2) e (%1 r)]\n                      (assoc %1 r (if (nil? e) [%2] (conj e %2)))) {} xs))","user":"57dafe97e4b0bd073c20241c"},{"problem":63,"code":"(fn group-by' [f coll]\n  (reduce (fn [h v]\n            (let [k (f v)]\n                 (assoc h k (conj (or (h k) []) v))))\n          {}\n          coll))","user":"58dcf11ae4b0a4d5acaab6af"},{"code":"(fn index [f xs]\n  (let [c (fn [acc v]\n    (let [k (f v)]\n      (if (contains? acc k)\n        (merge-with conj acc {k v})\n        (conj acc {k [v]}))))]\n    (reduce c {} xs)))","problem":63,"user":"4e691c79535d8ccf87e9fe97"},{"code":"(fn\r\n  [f coll]\r\n  (loop [m {}\r\n         s coll]\r\n    (if-not (seq s)\r\n      m\r\n      (let \r\n        [e (first s)\r\n         r (f e) \r\n         v (get m r)] \r\n          (recur \r\n            (assoc m r \r\n                    (if \r\n                      v\r\n                      (conj v e)\r\n                      (conj [] e)))\r\n            (next s)))) \r\n    ))","problem":63,"user":"4fee04a0e4b0678c553fc308"},{"code":"#(loop [ls %2 acc {}]\n   (if (empty? ls) acc\n     (let [v (first ls)\n           fv (%1 v)\n           prv (acc fv)]\n       (if (nil? prv)\n         (recur (rest ls) (conj acc {fv [v]}))\n         (recur (rest ls) (conj acc {fv (conj prv v)}))))))","problem":63,"user":"52b405e1e4b0c58976d9ad15"},{"code":"(fn [f l]\n (reduce \n  #(update-in %1 [(f %2)] (fnil conj []) %2) \n  {} \n  l\n )\n)","problem":63,"user":"52593207e4b0cb4875a45cd3"},{"code":"(fn f [pred coll]\n  (reduce (fn [r x]\n            (let [p (pred x)]\n              (assoc r p (conj (vec (r p)) x)))) {} coll))","problem":63,"user":"52b0323ee4b0c58976d9acc6"},{"problem":63,"code":"(fn my-group-by [f coll]\n  (reduce\n    (fn [acc item]\n      (let [k (f item)]\n        (if (contains? acc k)\n          (update-in acc [k] conj item)\n          (assoc acc k [item]))))\n    {}\n    coll))","user":"5b51b9f8e4b02d533a91bcfe"},{"problem":63,"code":"(fn [f s] (reduce #(\n  assoc %1 (f %2) (conj (apply vector (%1 (f %2))) %2))\n{} \ns))","user":"5e13a6b7e4b099d064963001"},{"problem":63,"code":"(fn [F L]\n    (loop [Ret {} Value (first L) Rest (rest L) ]\n      (let \n        [\n            Key \n            (if (nil? Value)\n              nil\n              (F Value)\n            )\n            MapValue (get Ret Key)\n        ]\n        (println Value \" \" Key \" \" MapValue)\n        (if (nil? Value)\n          Ret\n          (recur \n            (if (nil? MapValue)\n              (assoc Ret Key (conj [] Value)) \n              (assoc Ret Key (conj MapValue Value)) \n            )            \n            (first Rest) \n            (rest Rest)\n          )\n        )\n      )\n    )\n  )","user":"5d4a6c6ce4b0776584bd6f22"},{"code":"#(reduce (fn [m e] (assoc m (% e) `[~@(m (% e)) ~e]))\r\n  {} %2)","problem":63,"user":"4dce6e41535d5973398f92a2"},{"code":"(fn [ f x ]\n  (apply merge-with concat\n         (map\n          (fn [y] { ( f y ) [y] })\n          x\n          )\n         )\n  )","problem":63,"user":"518c5236e4b087e178201de0"},{"code":"(fn [f c]   (apply hash-map\n              (mapcat\n              #(vector   ;this is the fcn that creates the desired output for one pair\n                (first (first %))   ;this is the shared value\n                (vec (map second %)))   ;this is the list of individual inputs that give the shared value as output\n              (partition-by (fn [pair] (first pair)) (sort (map vector (map f c) c)))  ;this is the coll of pairs\n              )))","problem":63,"user":"4f80db02e4b033992c121bf9"},{"code":"#(reduce (fn [x y] (assoc x (% y) (vec (conj (get x (% y)) y)))) {} %2)","problem":63,"user":"51a058dae4b0b292b01ee3f3"},{"problem":63,"code":"(fn [f coll] (apply merge-with into (map #(hash-map (f %) [%]) coll)))","user":"59cf4013e4b0ef0a1e9b5b68"},{"problem":63,"code":"#(reduce (fn [acc, [k, v]] (assoc acc k\n                             (conj (acc k []) v)))\n         {}\n         (map (fn [i] [(%1 i) i]) %2))","user":"563dfc02e4b0da801c4e4662"},{"code":"(fn [f xs] (reduce #(assoc % (f %2) (conj (get % (f %2) []) %2)) {} xs))","problem":63,"user":"4e7f4147535db966e863cc3d"},{"code":"(fn [f s]\n  (let [fs (map f s)]\n    (loop [se s, fse fs, acc {}]\n      (if (or (empty? se) (empty? fse))\n        acc\n        (let [k (first fse), v (first se), prevs (get acc k [])]\n          (recur (rest se) (rest fse) \n                  (assoc acc k (conj prevs v))))))))","problem":63,"user":"4f418eaee4b0d7d3c9f3fce9"},{"code":"(fn group [func coll]\r\n  (let [keys (set (map func coll)) \r\n        values (map (fn [key] (filter #(= key (func %)) coll)) keys)]\r\n    (zipmap keys values)))","problem":63,"user":"4fb266a5e4b081705acca28c"},{"problem":63,"code":";(\n(fn grp [f s]\n  (let [insert (fn [acc el]\n                 (let [dflt \n                       (fnil #(conj % el)\n                             [])]\n                   (update-in acc \n                              [(f el)] \n                              dflt)))]\n    (reduce insert {} s)))\n;#(> % 5) [1 4 7 0 3 6])","user":"57df2722e4b0bd073c20245e"},{"problem":63,"code":"(fn\n  [f coll]\n  (apply merge-with into (for [x coll] {(f x) [x]})))","user":"5ac35d00e4b0e27600da7712"},{"code":"(fn [f col]\n   (loop [seq1 (map #(list (f %1) %1) col) seq2 {}]\n     (if (empty? seq1)\n       seq2\n       (recur (rest seq1)\n              (if (contains? seq2 (first (first seq1)))\n                 (assoc seq2 (first (first seq1)) (conj (get seq2  (first (first seq1)))  (last (first seq1))))\n                 (assoc seq2 (first (first seq1)) (vector (last (first seq1)))  ))\n              )\n       )\n   )\n )","problem":63,"user":"4ea31da2535d7eef308072c1"},{"code":"(fn [f coll]\n  (let [keys (map f coll)\n        s-maps (map hash-map keys (map vector coll))]\n    (reduce (partial merge-with (partial apply conj)) {} s-maps)))","problem":63,"user":"4f9acea6e4b0dcca54ed6d10"},{"problem":63,"code":"(fn [f s]\n  (reduce \n   #(assoc \n      %1\n      (f %2) \n      (conj (get %1 (f %2) []) %2))\n   {} \n   s))","user":"554edb85e4b00713264bd99a"},{"code":"#(apply merge-with concat (map hash-map (map % %2) (map vector %2)))","problem":63,"user":"4ec74de3535d6d7199dd36df"},{"problem":63,"code":"(fn my-group [f coll]\n  (reduce (fn [prev current]\n            (update-in prev\n                       [(first current)]\n                       #(if (nil? %1)\n                          [%2]\n                          (conj %1 %2))\n                       (last current)))\n          {}\n          (map #(list (f %) %) coll)))","user":"58fed70de4b0438e51c2cfdd"},{"problem":63,"code":"(fn [f s]\n  (reduce #(assoc % (f %2) (conj (vec (get % (f %2))) %2))\n          {}\n          s))","user":"541709b0e4b01498b1a71a06"},{"problem":63,"code":"(fn [f s]\n  (loop [remaining s\n         result {}]\n    (if (empty? remaining)\n      result\n      (recur \n        (rest remaining) \n        (assoc result (f (first remaining)) (concat (result (f (first remaining))) [(first remaining)]))\n       ))))","user":"5ed9c2cde4b0c7845d86b0e4"},{"problem":63,"code":"(fn my-group-by [f coll]\n     (loop [map {}\n            s (seq coll)]\n       (if s \n         (let [x (first s)\n               k (f x)\n               g (get map k [])]\n           (recur (assoc map k (conj g x))\n                  (next s)))\n         map)))","user":"548ade6de4b0e286459a11f6"},{"problem":63,"code":"(fn [f s] (reduce #(merge-with concat %1 (hash-map (f %2) [%2])) {} s))","user":"56e6ef89e4b02e7e935eb6d0"},{"problem":63,"code":"(fn [fun coll]\n  (reduce \n   \t(fn [mp item]\n      (let [k (fun item)]\n        (assoc mp k (conj (mp k []) item))))\n  {}\n  coll))","user":"5832be57e4b089d5ab817c86"},{"problem":63,"code":"(fn [f xs]\n  (reduce #(update-in %1 [(f %2)]\n                   (fnil conj []) %2)\n          {}\n          xs))","user":"5393185ae4b0b51d73faaeb7"},{"code":"(fn [f coll]\n  (reduce\n   (fn [m e]\n     (update-in m [(f e)] (fnil conj []) e))\n   {}\n   coll))","problem":63,"user":"4fbf2818e4b081705acca317"},{"code":"(fn [f xs]\n  (let [group (fn [m x]\n                (let [k (f x)\n                      s (get m k [])]\n                  (assoc m k (conj s x))))]\n    (reduce group {} xs)))","problem":63,"user":"4f8c6bf6e4b02e764a0a519b"},{"code":"(fn [f xs]\n  (loop [acc {}\n         xs  xs]\n    (if (empty? xs)\n        acc\n        (recur (update-in acc [(f (first xs))]\n                          #(conj (or % []) (first xs)))\n               (rest xs)))))","problem":63,"user":"4e8338d6535db62dc21a62d3"},{"problem":63,"code":"#(reduce (fn [a b]\n           (update-in a [(% b)] (fnil conj []) b))\n         {} %2)","user":"55201d18e4b08d5046aa8a5d"},{"problem":63,"code":"(fn [f l]\n   (zipmap\n    (set (map f l))\n    (map\n    (fn [x] \n      (filter #(= x (f %)) l)) \n    (set (map f l)))))","user":"53f6d555e4b0db01ade6f9e5"},{"code":"(fn [f seq]\r\n  (apply merge-with concat (map (fn [v] {(f v) (list v)}) seq)))","problem":63,"user":"4e994541535dbda64a6f6b64"},{"code":"(fn [f s]\n  (reduce #(assoc %1 (f %2) (concat (get %1 (f %2) []) [%2])) {} s))","problem":63,"user":"4f713878e4b07046d9f4f00a"},{"problem":63,"code":"(fn my-group-by\n  [f xs]\n  (apply merge-with concat (for [x xs] {(f x) [x]})))","user":"52561295e4b0541d1855ba03"},{"code":"(fn fun [f l]\n  (reduce \n  \t#(assoc % \n  \t\t(f %2) \n  \t\t(conj \n  \t\t\t(if (contains? % (f %2))\n  \t\t\t\t(% (f %2))\n  \t\t\t\t[])\n  \t\t\t%2))\n  \t{}\n  \tl))","problem":63,"user":"520242bae4b030ee0c5b26e3"},{"problem":63,"code":"(fn [f coll]\n  (loop [xs  coll\n         res {}]\n    (if (empty? xs)\n      res\n      (let [x    (first xs)\n            curr (f x)]\n        (if-let [existing (get res curr)]\n          (recur (rest xs) (assoc res curr (conj existing x)))\n          (recur (rest xs) (assoc res curr [x])))))))","user":"5be9ad9be4b0f319e2d7ec76"},{"code":"(fn [group-fun coll]\n  (reduce (fn [m v] \n    (let [k (group-fun v)\n          target-coll (m k [])]\n  (assoc m k (conj target-coll v))))\n{} coll))","problem":63,"user":"4e6ab9cb535d8ccf87e9fefe"},{"problem":63,"code":"(fn my-group-by [f sq]\n  (reduce (fn [m v]\n            (let [calculated-value (f v)]\n              (if (contains? m calculated-value)\n                (assoc m calculated-value (conj (get m calculated-value) v))\n                (assoc m calculated-value [v]))))\n          {} sq))","user":"5bfa25fbe4b0bdcf453d15c8"},{"problem":63,"code":"(fn [f s] (reduce #(assoc % (second %2) (conj (vec (% (second %2))) (first %2))) {} (map #(list % (f %)) s)))","user":"52f8b86de4b047fd55836fdb"},{"problem":63,"code":"(fn [f s]\n  (let [conjv (fn conjv [s v] (if s (conj s v) (conj [] v)))\n        update (fn [m k f x] (assoc m k (f (get m k) x)))]\n    (reduce #(update %1 (f %2) conjv %2) {} s)))","user":"5da8fa72e4b000c986472c2d"},{"code":"(fn [f coll] (reduce #(assoc %1 (f (first %2)) %2) {} (partition-by f (sort-by f coll))))","problem":63,"user":"50fac9e3e4b07934dda8b0d1"},{"code":"(fn [f coll]\n  (loop [result {} rst coll]\n    (if (empty? rst)\n        result\n        (let [applied (f (first rst))\n              grouped (get result applied [])]\n          (recur (assoc result applied (conj grouped (first rst)))\n                 (rest rst))))))","problem":63,"user":"4e7c8fd1535db169f9c796be"},{"code":"(fn [f coll] (->> (map (fn [e] [(f e) e]) coll) (partition-by first) (map (fn [coll] [(ffirst coll) (map second coll)])) (reduce (fn [h [k v]] (assoc h k (concat (get h k) v))) {})))","problem":63,"user":"5137c3b0e4b0509a8b470482"},{"problem":63,"code":"(fn my-group-by\n  [f coll]\n  (reduce\n   #(merge-with concat %1 {(f %2) [%2]})\n   {}\n   coll))","user":"5b7f2d75e4b047b03b203768"},{"code":"(fn grp-by [f coll]\n  (reduce (fn [acc x] (merge-with concat acc {(f x) [x]})) {} coll)\n  )","problem":63,"user":"53307da1e4b019098a6f8b5e"},{"problem":63,"code":"(fn [f coll]\n  (reduce (fn [m x]\n            (update-in m [(f x)] #(conj (or % []) x)))\n          {}\n          coll))","user":"595b864ee4b066ee0a44afdc"},{"code":"(fn groupby [f xs]\n  (reduce\n\t\t#(let [fx (f %2)]\n\t\t\t(assoc %1 fx (conj (get %1 fx []) %2))\n\t\t)\n\t\t{}\n\t\txs\n\t)\n)","problem":63,"user":"4ed6238d535d10e5ff6f52de"},{"problem":63,"code":"(fn [func vals]\n  (into {}\n        (map #(vector (func (first % )) (vec %))\n             (partition-by func (sort vals)))))","user":"5a984657e4b0d174b936c78a"},{"problem":63,"code":"(fn p63\n  [f s]\n  (letfn [(pairs    [f x]     (map vector (map f x) x))\n          (add-pair [m [k v]] (assoc m k (if (nil? (m k)) (vector v) (conj (m k) v))))]\n    (reduce add-pair {} (pairs f s))))","user":"550ff2a3e4b06e50f9beb17f"},{"problem":63,"code":"(fn group-by- [f coll]\n  (if (empty? coll)\n    {}\n    (let [ret (f (first coll))\n          ss (group-by- f (rest coll))]\n      (if (nil? (ss ret))\n        (assoc ss ret [(first coll)])\n        (assoc ss ret (cons (first coll) (ss ret)))))))","user":"55058a4fe4b086ebe8a79c89"},{"code":"(fn [f col]\n  (reduce #(if\n             (%1 (f %2))\n             (update-in %1 [(f %2)] \n                        (fn [x] (conj x %2)))\n             (assoc %1 (f %2) [%2]))\n          {} col))","problem":63,"user":"52ba2af3e4b07a9af57922cc"},{"problem":63,"code":"(fn group-a-seq [group-fn items]\n  (loop [s items m {}]\n    (if (empty? s)\n      m\n      (let [k (group-fn (first s))]\n        (recur (rest s)\n               (assoc m k (conj (get m k []) (first s))))))))","user":"4f35e662e4b0e243712b1ec6"},{"code":"(fn [f coll]\n  (reduce #(update-in % [(f %2)] (comp vec conj) %2) {} coll))","problem":63,"user":"52029e5de4b030ee0c5b26fc"},{"problem":63,"code":"(fn [f s]\n  (reduce\n   (fn [ret x]\n     (assoc ret (f x) (conj (ret (f x) []) x)))\n   {}\n   s))","user":"558f4fbae4b0277789237661"},{"problem":63,"code":"(fn [f s] (apply merge-with into (for [v s] {(f v) [v]})))","user":"55dbed2fe4b050e68259b3a6"},{"code":"(fn [f s]\n  (let [\n    ; Create seq of maps ( {(f x1) -> [x1]}, ...)\n    y-vx-map (map #(hash-map (f %1) (vector %)) s) ]\n    \n    ; Merge maps, combining vals of dup keys\n    (apply merge-with concat y-vx-map)))","problem":63,"user":"4f047c07535dcb61093f6bcd"},{"problem":63,"code":"(fn [f s] (loop [res {}, arr s]\n\t(if (empty? arr) res (recur\n\t\t(let [elem (first arr), k (f elem)]\n\t\t\t(assoc res k (conj (get res k []) elem))\n\t\t)\n\t\t(next arr)\n\t))\n))","user":"5d73530ce4b02e6b30c93514"},{"problem":63,"code":"(fn [f s]\n  (let [lo (fn [acc e]\n             (let [val (f e)]\n               (if (acc val)\n                 (conj acc {val (conj (acc val) e)})\n                 (conj acc {val [e]}))))]\n    (reduce lo {} s)))","user":"54487527e4b032a45b8693cc"},{"problem":63,"code":"(fn [f coll]\n  (let [ks (set (map f coll))]\n    (reduce (fn [m k]\n              (conj\n               m\n               {k (filter\n                   (comp (partial = k) f)\n                          coll)}))\n            {}\n            ks)))","user":"54d9f7f1e4b024c67c0cf751"},{"problem":63,"code":"(fn [f sq] (reduce (fn [acc n] (assoc acc (f n) (vec (conj (acc (f n)) n)))) {} sq))","user":"5d4f21f3e4b0776584bd6f4e"},{"problem":63,"code":"(fn [f s] (reduce #(assoc %1 (f %2) (conj (%1 (f %2) []) %2))\n                      {} s))","user":"58c4b11ae4b021aa9917ed2c"},{"code":"(fn group\n    ([f coll]\n      (reduce\n           (fn [ret x]\n              (let [k (f x)]\n                  (assoc ret k (conj (get ret k []) x))))\n           {} coll\n       )\n       )\n)","problem":63,"user":"51d28e15e4b0d13b04db0d9b"},{"problem":63,"code":"(fn [op v]\n           (let [ arr (vec (partition-by op (sort-by op v))) ]\n             (zipmap (map #(op (first %)) arr) arr)\n             ))","user":"54d05a9de4b0e8a36923e5c7"},{"code":"(fn [f coll](\n  reduce \n    #(let [k (f %2)\n            v (if \n                      (vector? (% k))\n                      (conj (% k) %2) \n                      [%2])] (\n      assoc % k v)) \n    {} \n    coll))","problem":63,"user":"4ff2f0a9e4b0678c553fc341"},{"code":"(fn my-group-by [f coll]\n  (reduce\n   #(if (contains? %1 (f %2))\n      (assoc %1 (f %2) (conj (%1 (f %2)) %2))\n      (assoc %1 (f %2) [%2]))\n   {}\n   coll))","problem":63,"user":"527ccaf4e4b0757a1b17136d"},{"code":"(fn [f s] (reduce (fn [res item] (let [k (f item)] (assoc res k (conj (res k []) item)))) {} s))","problem":63,"user":"4feada56e4b0140c20fb9c11"},{"problem":63,"code":"(fn\n  [f coll]\n  (apply merge-with into (for [v coll] {(f v) [v]})))","user":"5cf1d9e3e4b0aaa82f112a18"},{"code":"(fn [f coll]\n  (reduce (fn [m x] (assoc m (f x) (conj (get m (f x) []) x)))\n          {}\n          coll))","problem":63,"user":"4fb01e53e4b081705acca260"},{"problem":63,"code":"(fn [f xs]\n    (loop [[x :as xs] xs\n           ret {}]\n        (if (empty? xs)\n          ret\n          (recur (rest xs) \n                 (assoc ret \n                        (f x)\n                        (conj (vec((fnil get []) ret (f x))) x)\n                 )))))","user":"5f82cfcce4b0c071e6c840fb"},{"problem":63,"code":"(fn [ff s] (first (reduce (fn rr [[m f] v] (vector (assoc m (f v) (conj (or (m (f v)) []) v)) f))\n                         [{} ff] s)))","user":"578fc072e4b0ebec4cfb759a"},{"code":"(fn [f coll]\n  (apply merge-with concat (map #(hash-map (f %) [%]) coll)))","problem":63,"user":"5220dbb7e4b0e6a83c8925b3"},{"problem":63,"code":"(fn my-group [f s]\n   (reduce\n    (fn [out sh]\n      (if (contains? out (f sh))\n        (assoc out (f sh) (conj (get out (f sh)) sh))\n        (assoc out (f sh) [sh])))\n    {} s))","user":"5dd90651e4b0948ae9d9ad97"},{"problem":63,"code":"(fn [f s]\n  (reduce (fn [acc e] (update-in acc [(f e)] #(conj (or % []) %2) e)) {} s)  \n)","user":"5cfd5a93e4b0cc9c91588168"},{"code":"(fn [f s]\n  (apply merge-with concat\n    (for [x s] {(f x) [x]})))","problem":63,"user":"53779a26e4b06839e8705e38"},{"code":"(fn [f c] (apply merge-with concat (map #(hash-map (f %) (list %)) c)))","problem":63,"user":"519964cbe4b0aa09cbc0b849"},{"code":"(fn\n  [f lst]\n  (let [keyed (map (fn [n] {(f n) [n]}) lst)]\n    (apply merge-with concat keyed)))","problem":63,"user":"4ef7a483535dced4c769f258"},{"problem":63,"code":"(fn my-group-by [f coll]\n  (reduce \n    (fn [m x]\n      (let [k (f x)]\n        (assoc m k (conj (get m k []) x))))\n    {}\n    coll))","user":"5be33a16e4b0ed4b8aab4cd6"},{"code":"(fn [f coll]\n   (reduce \n     (fn [acc v] \n        (merge acc {(f v) (conj (get acc (f v) []) v)}) )  \n   {} coll)\n)","problem":63,"user":"502a5fa4e4b09e8f859a9fbd"},{"code":"(fn [f xs]\n    (reduce (fn [a b]\n              (assoc a (f b) (conj (get a (f b) []) b)))\n            {} xs))","problem":63,"user":"52eb400ee4b0705949c4443b"},{"code":"(fn [f s]\n  (let [vs (distinct (map f s))\n        mv (fn [v] {v (filter #(= v (f %)) s)})\n        ms (map mv vs)]\n    (apply merge ms)))","problem":63,"user":"5133e51ae4b0d7a043de8cf6"},{"problem":63,"code":"(fn [f s]\n  (loop [x s, a {}]\n    (if (empty? x) a\n      (let [key (f (first x)), old (get a key), oldvec (if (nil? old) [] old)]\n        (recur (rest x) (assoc a key (conj oldvec (first x))))))))","user":"53bcdd41e4b0d9a98559a6c0"},{"code":"(fn [f coll]\n  (reduce (fn [x y] (assoc x (f y) (conj (get x (f y) []) y))) {} coll))","problem":63,"user":"4f45c72be4b0d56e7bb92b8a"},{"problem":63,"code":"(fn [f coll]\n  (reduce\n   (fn [acc val]\n     (let [v (f val)]\n       (update-in acc [v] #(if (nil? %) [val] (conj % val)))))\n   {}\n   coll))","user":"55fbc657e4b0f488688e0666"},{"problem":63,"code":"#(reduce (partial merge-with concat) (map zipmap (partition 1 (map %1 %2)) (map list (partition 1 %2))))","user":"54b2ec84e4b09f271ff37d33"},{"code":"(fn [f coll]\n  (reduce #(assoc %1 (f %2) (conj (vec (%1 (f %2))) %2)) {} coll))","problem":63,"user":"50310b8be4b05b7df5a0b84d"},{"code":"(fn [f coll]  \n  (persistent!\n   (reduce\n    (fn [ret x]\n      (let [k (f x)]\n        (assoc! ret k (conj (get ret k []) x))))\n    (transient {}) coll)))","problem":63,"user":"4fdf2b50e4b05e33b9224f93"},{"problem":63,"code":"(fn [f c]\n  (reduce\n   (fn [m x]\n     (let [k (f x)]\n       (assoc m k (conj (m k []) x))))\n   {} c))","user":"51febd40e4b0f1313d468a76"},{"problem":63,"code":"(fn [f s]\n    (letfn [(group [acc e]\n              (let [k (f e)\n                    m (get acc k [])]\n                (assoc acc k (conj m e))))]\n      (reduce group {} s)))","user":"53ea3a63e4b036ad0777e4dc"},{"code":"(fn [f xs] (reduce (fn [a v] (assoc a (f v) (conj (a (f v) []) v))) (sorted-map) xs))","problem":63,"user":"50cf21dee4b0e61f11ddcd8b"},{"problem":63,"code":"(fn group [x y]\n  (reduce (fn [r v] (let [add #((fnil conj []) % %2)]\n                      (update-in r [(x v)] add v))) {} y))","user":"5a9cdec0e4b0d174b936c7e1"},{"code":"(fn groupby [f s]\r\n  (reduce \r\n    (fn [m e]\r\n      (let [k (f e)] (assoc m k (conj (get m k []) e))))\r\n    {} s))","problem":63,"user":"4f0da4e4535d0136e6c22319"},{"code":"#(reduce (fn [accu el]  \n   (update-in accu [(% el)] \n     (fnil (fn [els] (conj els el)) []))) {} %2)","problem":63,"user":"4eca7a87535d6d7199dd3705"},{"problem":63,"code":"(fn [f vs]\n  (reduce (fn [m a]\n            (let [v (f a)\n                  l (vec (m v))]\n              (assoc m v (conj l a))))\n          {}\n          vs))","user":"5461dc79e4b01be26fd746a8"},{"problem":63,"code":"#(reduce (fn [a b] (assoc a (%1 b) (conj (a (%1 b) []) b))) {} %2)","user":"544e9022e4b0e3978000698b"},{"problem":63,"code":"(fn [f s]\n  \t(let [group (fn [a b]\n                  (let [x (f b)]\n                    (if (contains? a x)\n                      (assoc a x (conj (a x) b))\n                      (assoc a x (conj [] b))))\n                  )]\n      (reduce group {} s)))","user":"53d86564e4b0e771c302546b"},{"code":"(fn [con dat]\n    (apply merge-with into  \n           (map #(hash-map (con %) [%]) dat )))","problem":63,"user":"4f030775535dcb61093f6a43"},{"problem":63,"code":"(fn [f coll] \n  (reduce #(let [x %2, keey (f x) ] \n             (assoc %1 keey (cons x (%1 keey)))) \n          {} (reverse coll)))","user":"53fcdd1ae4b0de5c418485dd"},{"problem":63,"code":"(fn gb [f s]\n  (->> s\n       (map #(hash-map (f %) [%]))\n       (reduce (fn [a b] (merge-with #(apply conj %1 %2) a b)))))","user":"503f923fe4b00d1a725ff2ad"},{"problem":63,"code":"(fn [f s]\n  (reduce #(merge-with concat %1 {(f %2) [%2]})\n          {}\n          s))","user":"5609866ee4b0053d1b86c7e3"},{"code":"(fn my-group-by [f s]\n  (let [kv (for [v s] [(f v) v])]\n    (reduce #(if (contains? %1 (first %2))\n              (assoc %1 (first %2) (conj (%1 (first %2)) (second %2)))\n              (assoc %1 (first %2) [(second %2)])\n           ) \n        {} kv)\n    )\n  )","problem":63,"user":"529a73bde4b02ebb4ef75096"},{"code":"(fn [f s] (reduce #(assoc % (f %2) (vec (conj (get % (f %2)) %2))) {} s))","problem":63,"user":"5078d366e4b08327cd804a5b"},{"problem":63,"code":"(fn group-by'\n  [f coll]\n  (let [vs (partition-by f (sort-by f coll))\n        ks (map (comp f first) vs)]\n    (zipmap ks vs)))","user":"540b2dcbe4b0addc1aec66f4"},{"code":"(fn [f l] (into {} (for [k (map f l)] [k (filter #(= k (f %)) l)])))","problem":63,"user":"5084cb7de4b0fb8f40674bfb"},{"code":"(fn [f c] (reduce (fn [r i] (update-in r [(f i)] #( -> % vec (conj i)))) {} c))","problem":63,"user":"518279abe4b0353c468deb65"},{"problem":63,"code":"(fn [f coll]\n  (reduce into {}\n    (for [r (set (map f coll))] {r (vec (filter #(= r (f %)) coll))}))\n)","user":"53ca41dae4b00fb29b2212c8"},{"problem":63,"code":"(fn [f s] (reduce (fn [m v] (let [k (f v)]\n                              (assoc m k (conj (get m k []) v)))) \n                  {} s))","user":"5744d088e4b009280f9f2b41"},{"code":"(fn grby [f s]\n    (reduce (fn [acc e] (assoc acc (f e) (conj (get acc (f e) []) e)))\n            {}\n            s))","problem":63,"user":"5370ef22e4b0fc7073fd6ea0"},{"problem":63,"code":"(fn [f coll]\n  (apply merge-with concat (map #(hash-map (f %) (vector %)) coll)))","user":"598858d0e4b021a7a535feb5"},{"code":"(fn [func coll]\n     (reduce\n       (fn [m el]\n         (let [key (first el)]\n           (assoc m key (conj (m key []) (second el)))))\n       {} (map #( vector (func %1) %1 ) coll)))","problem":63,"user":"4f4a8707e4b0d56e7bb92c12"},{"code":"(comp #(zipmap (map ffirst %) (map (partial map peek) %)) (partial partition-by first) sort (fn [f x] (map-indexed #(vector (f %2) %1 %2) x)))","problem":63,"user":"51cbdee1e4b08d8387cbede1"},{"code":"(fn [key-func values]\n  (let [add-to-group (fn [m k v] (assoc m k (conj (get m k []) v)))]\n    (reduce (fn [m v] (add-to-group m (key-func v) v)) {} values)))","problem":63,"user":"4ef41f26535dced4c769f230"},{"code":"(fn [f coll]\n  (reduce #(assoc %1 (f %2) (conj (%1 (f %2) []) %2))\n          {}\n          coll))","problem":63,"user":"51c19873e4b0d204dbe2ca0d"},{"problem":63,"code":"(fn pia [f xs]\n  (apply merge-with concat\n    (for [x xs,]\n      {(f x) [x]})))","user":"569ce6fee4b0542e1f8d146c"},{"code":"(fn [f c] \n  (apply merge-with concat \n         (map #(hash-map (f %) (list %)) c)))","problem":63,"user":"506617c3e4b03d366d7cb2ab"},{"problem":63,"code":"(fn p63 [f xs]\n  (loop [elements xs\n         result {}]\n    (if (empty? elements)\n      result\n      (let [element (first elements)\n            value (f element)\n            values (or (result value) [])]\n        (recur (rest elements)\n               (assoc result value (conj values element)))))))","user":"54a6645be4b09f271ff37c87"},{"problem":63,"code":"(fn group-seq [f s]\n  (apply merge-with\n   concat\n    (for [e s] (hash-map (f e) [e]))))","user":"55151417e4b055c2f668d4da"},{"problem":63,"code":"(fn [f items] (reduce (fn [h k] (assoc h k (filter #(= k (f %)) items))) {} (set (map f items))))","user":"55306f9de4b076ab5578f814"},{"code":"(fn [f col]\n  (reduce\n   (fn [a x]\n     (update-in a\n                [(f x)]\n                (fnil conj [])\n                x))\n   {}\n   col))","problem":63,"user":"52d2ca1ce4b099d49816f0b4"},{"code":"(fn [f coll]\n  (loop [items coll grouped {}]\n   (if-let [i (first items)]\n     (recur (next items)\n            (assoc grouped (f i) (conj (grouped (f i) []) i)))\n     grouped)))","problem":63,"user":"5326c5f7e4b09d4e7a9b54f2"},{"problem":63,"code":"(fn [f s]\n  (loop [ans {} tmps s]\n    (if (empty? tmps)\n      ans\n      (if (contains? ans (f (first tmps)))\n        (recur (assoc ans (f (first tmps)) (conj (get ans (f (first tmps))) (first tmps)) ) (rest tmps))\n        (recur (assoc ans (f (first tmps)) (vector (first tmps))) (rest tmps))\n        ))))","user":"59368ccae4b02506e01a2979"},{"problem":63,"code":"(fn f [condicion coll] \n  (reduce \n    (fn [acc x] \n      (update-in acc [(condicion x)]\n        (fnil conj []) x))\n    {}\n    coll))","user":"4e6a5728535d8ccf87e9fecf"},{"code":"(fn gb [f xs] (apply (partial merge-with into) (map #(hash-map (f %) [%]) xs)))","problem":63,"user":"52d3f666e4b09f7907dd1327"},{"code":"(fn [f xs]\n  (letfn [(do-it [ax el] \n                 (let [the-key (f el)\n                       old-val (ax the-key [])\n                       new-val (conj old-val el)]\n                   (assoc ax the-key new-val)))]\n    (reduce do-it {} xs)))","problem":63,"user":"51efd397e4b0249c592fbdeb"},{"problem":63,"code":"(fn [f s]\n  (reduce\n    (fn [res item]\n      (update-in res [(f item)] (fnil conj []) item))\n    {}\n    s))","user":"53a83c74e4b047364c044426"},{"problem":63,"code":"(fn [f s]\n  (reduce\n   (fn [acc x]\n     (let [fx (f x)]\n       (if (acc fx)\n         (assoc acc fx (conj (acc fx) x))\n         (assoc acc fx [x]))))\n   {}\n   s))","user":"5791d259e4b0ebec4cfb75c0"},{"code":"#(reduce (fn\n         [acc s]\n         (let [k (%1 s)]\n           (assoc acc k (conj (get acc k []) s))))\n       {}\n       %2)","problem":63,"user":"52c00263e4b07a9af579233f"},{"code":"(fn [f s]\n  (loop [ m {}\n      \t vs s]\n    (if (empty? vs)\n      m\n\t  (let [v (first vs)\n\t        k (f v)]\n        (recur (assoc m k (conj (get m k []) v)) (rest vs))))))","problem":63,"user":"524ae8e6e4b09eba1c0223b5"},{"problem":63,"code":"(fn [f s]\n  (reduce\n    (fn [h e]\n      (let [key (f e) vec (get-in h [key] []) val (conj vec e)]\n        (assoc-in h [key] val)))\n    {}\n    s))","user":"54684c3be4b00cfc9eacc139"},{"problem":63,"code":"(fn group-seq [f s]\n  (apply merge (for [k (set (map f s))]\n                 (hash-map k (filter #(= k (f %)) s)))))","user":"54651faee4b01be26fd746d6"},{"problem":63,"code":"(fn\n  [f s]\n  (loop [res {} coll s]\n    (if (empty? coll)\n      res\n      (let [el (first coll)\n            r (f el)]\n        (recur (merge-with concat res {r (vector el)}) (rest coll))))))","user":"56df6846e4b0ca2494a095fa"},{"code":"(fn [f coll] \n (reduce #(if (contains? %1 (f %2)) \n                      (into %1 {(f %2) (conj (get %1 (f %2)) %2)})\n                      (into %1 {(f %2) [%2]}))\n                          {} coll))","problem":63,"user":"4ea11921535d7eef308072af"},{"code":"(fn sq [f xs]\n  (if (seq xs)\n      (let [[x & s] xs]\n          (conj (sq f s) \n                {(f x) (cons x \n                            ((sq f s) (f x))) }))\n      {}))","problem":63,"user":"4fdd27f3e4b05e33b9224f78"},{"problem":63,"code":"(fn [f s]\n  (loop [c s\n         res {}]\n    (if (empty? c)\n      res\n      (recur (rest c)\n             (let [v (first c)\n                   fres (f v)]\n               (assoc res fres (conj (get res fres []) v)))))))","user":"5530baa5e4b076ab5578f81a"},{"problem":63,"code":"(fn my-grouping [f s] \n  (apply merge-with\n    (fn [result latest] (vec (concat result latest)))\n    (map \n      (fn [k v] {k [v]})\n      (map f s)\n      s\n    ))\n)","user":"56791447e4b05957ce8c6183"},{"code":"(fn [f v]\n   (reduce (fn [accum i]\n             (let [res (f i)]\n               (println (format \"accum: %s i: %s res: %s\" accum i res))\n               (conj accum [res (conj (or (accum res)\n                                          [])\n                                      i)])))\n           {}\n           v))","problem":63,"user":"4fa3c137e4b081705acca193"},{"problem":63,"code":"(fn [f s]\n  (reduce\n    (fn [acc curr]\n      (assoc acc (f curr) (conj (acc (f curr) []) curr)))\n    {}\n    s))","user":"5b99554ae4b0c0b3ffbd4ace"},{"problem":63,"code":"#(loop [[x & xs] %2, ret {}]\n   (if (not x)\n     ret\n     (let [key (% x)]\n       (recur xs (update-in ret [key] (fn [y] (if y (conj y x) [x])))))))","user":"554b7056e4b0a04f79299583"},{"problem":63,"code":"(fn [f s]\n  (reduce (fn [r v] (let [add #((fnil conj []) % %2)]\n                      (update-in r [(f v)] add v))) {} s))","user":"5460f59ce4b01be26fd74695"},{"problem":63,"code":"(fn [f coll]\n      (reduce #(let [key (f %2)] (if (get %1 key) (update-in %1 [key] conj %2) (assoc-in %1 [key] [%2]))) {} coll))","user":"57086931e4b0b0fb43fd069e"},{"code":"#(reduce (fn [m v] (assoc m (% v) (conj (get m (% v) []) v))) {} %2)","problem":63,"user":"4dc78527535d8a4b2fd7428f"},{"problem":63,"code":"(fn group-seq [f col]\n  (reduce #(assoc %1 (f %2) (conj (apply vector (%1 (f %2))) %2)\n                  ) {} col))","user":"57b9d21fe4b0fbc9809a27f7"},{"problem":63,"code":"(fn [f s] \n  (loop [acc {}\n         sq s]\n    (if (empty? sq)\n    acc\n    (let [head (first sq)\n          tail (rest sq)\n          result (f head)]\n      (cond (contains? acc result)\n            (recur (assoc acc result (conj (acc result) head))\n                   tail)\n            :default\n            (recur (assoc acc result [head])\n                   tail))))))","user":"56b6a50ae4b0982f16b37e3c"},{"code":"(fn [f coll] \n  (reduce #(update-in %1 [(f %2)] (partial cons %2)) {} (reverse coll)))","problem":63,"user":"4fad33e8e4b081705acca236"},{"code":"(fn [f col]\n  (letfn [(r-assoc [m v]\n                   (let [k (f v)]\n                     (assoc m k (conj (or (m k) []) v))))]\n    (reduce r-assoc {} col)))","problem":63,"user":"4f16d3fd535d64f60314644e"},{"code":"(fn [f lst]\n  (loop [A lst, result {}]\n    (if (empty? A)\n      result\n      (let [a (first A), b (f a)]\n        (recur (rest A)\n          (if (contains? result b)\n            (update-in result [b] #(conj % a))\n            (assoc result b [a])))))))","problem":63,"user":"4faa9593e4b081705acca1f9"},{"problem":63,"code":"(fn [f s]\n  (loop [ret (hash-map (f (first s)) (vector (first s)))\n         ss (vec (rest s))]\n    (if (empty? ss)\n      ret\n      (recur (update-in ret [(f (first ss))]\n                        (comp vec conj)\n                        (first ss))\n             (vec (rest ss))))))","user":"4daee8e9edd6309eace4d166"},{"problem":63,"code":"(fn group-by* [f xs]\n  (reduce (fn [grouped b]\n            (let [k (f b)]\n              (assoc grouped k (conj (get grouped k []) b))))\n          {}\n          xs))","user":"540e17c3e4b0addc1aec6719"},{"problem":63,"code":"(fn [f xs]\n  (let [fxs (map f xs)\n        p (map vector fxs xs)]\n    (reduce\n     (fn [m [k v]]\n       (if (contains? m k)\n         (update-in m [k]\n           #(conj % v))\n         (assoc-in m [k]\n           [v])))\n     {} p)))","user":"51e5a627e4b0efabf93c02db"},{"code":"(fn gseq [f s]\n  (let [results (set (map f s))]\n    (zipmap results (map (fn [r] (filter #(= (f %) r) s)) results))))","problem":63,"user":"4ff304f4e4b0678c553fc343"},{"problem":63,"code":"(fn\n  [f s]\n  (reduce\n   #(let\n      [k (f %2)]\n      (assoc\n        %1\n        k\n        (if\n          (contains? %1 k)\n          (conj (get %1 k) %2)\n          (vector %2))))\n   {}\n   s))","user":"5796d3ebe4b039eba2ecb0ee"},{"code":"(fn [f s] (reduce #(update-in  %1 [(f %2)] (fnil concat []) [%2]) {} s))","problem":63,"user":"536973e5e4b0243289761e9e"},{"code":"(fn [f coll]\n    (reduce (partial merge-with concat)\n            (map #(assoc {} (f %1) [%1])\n                 coll)))","problem":63,"user":"5183f5d7e4b02826a645f393"},{"code":"(fn [f xs] (reduce (fn [acc x] (if-not (nil? (acc (first x)))\n                                  (assoc-in acc [(first x)] (conj (acc (first x)) (second x)) )\n                                  (assoc acc (first x) [(second x)])) )\n             {}\n             (map (fn[x] [(f x) x]) xs)))","problem":63,"user":"531bfb69e4b08068f379ed97"},{"code":"(fn grpby\n  ([f s] (grpby {} f (seq s)))\n  ([g f [x & xs]]\n    (let [res (f x)\n          ng (assoc g res (conj (g res []) x))]\n      (if (nil? xs)\n        ng\n        (grpby ng f xs)))))","problem":63,"user":"4f7f0827e4b06e829148e1d5"},{"code":"(fn group--reduce\n  [f coll] {:pre [(ifn? f)]}\n  (reduce (fn [{acc (f x) :as m :or {acc []}} x]\n            (assoc m (f x) (conj acc x)))\n          {}\n          coll))","problem":63,"user":"4fc6305de4b0ee37620e180b"},{"problem":63,"code":"(fn grp [f xs]\n  (if-let [x (first xs)]\n    (merge-with into\n                {(f x) [x]}\n                (grp f (rest xs)))))","user":"55d68726e4b0e31453f64a99"},{"problem":63,"code":"(fn gas\n  [f s]\n  (->>\n    (sort s)\n    (partition-by f)\n    (map #(hash-map (f (first %)) %))\n    (apply merge)\n    ))","user":"5b73e500e4b047b03b2036ba"},{"code":"(fn [f xs] (loop [x xs m {}]\n         (if (empty? x)\n            m\n            (let [v (first x)\n                  k (f v)]\n            (recur (rest x) \n              (if (m k)\n                (assoc m k (concat (m k) [v]))\n                (assoc m k [v])))))))","problem":63,"user":"4e4ca885535dc968683fc4df"},{"code":"(fn group [f coll]\n  (loop [m {}, [x & xs] (seq coll)]\n    (if x\n      (recur (assoc m (f x) (conj (vec (m (f x))) x)) xs)\n      m)))","problem":63,"user":"4e89f9e5535d3e98b8023289"},{"problem":63,"code":"(fn [f v]\n  (reduce #(update-in %1 [(f %2)]\n                      (fn [a b] (if (nil? a) (vector b) (conj a b))) %2)\n          {} v))","user":"56ff45e5e4b08d47c97781bb"},{"problem":63,"code":"(fn [f coll]\n  (reduce (fn [build val]\n            (update-in build [(f val)] #(conj (or %1 []) val)))\n            {}\n            coll))","user":"5317d78ee4b08068f379ed63"},{"problem":63,"code":"(fn group [f elems]\n  (let [groups (hash-map)]\n    (loop [elements elems groups groups]\n      (if (nil? elements)\n        groups\n        (let [[elem & rest-elems] elements\n              result (f elem)\n              resultPresent (contains? groups result)\n              group (if resultPresent (conj (get groups result) elem) [elem])\n              groups (conj groups [result group])]\n          (recur rest-elems groups))))))","user":"5dc4719ae4b02f9375f4e1b5"},{"problem":63,"code":"(fn mygroupby [test coll]\n  (reduce #(assoc % (test %2) (conj (get % (test %2) []) %2)) {} coll))","user":"55a372f1e4b0acc240e31537"},{"problem":63,"code":"(fn[x y](reduce #(assoc %1 (x %2) (into [] (conj (get %1 (x %2)) %2))) {} y))","user":"58d1c1b1e4b03c36ff7e58ef"},{"problem":63,"code":"(fn [f c] \n  (reduce \n    #(if (contains? % (f %2))\n         (conj % [(f %2)(conj (get % (f %2)) %2)])\n         (conj % [(f %2) [%2]])\n       ) \n    {}\n    c))","user":"5dbb5200e4b09f47823971a9"},{"problem":63,"code":"(fn [f vs]\n  (->>\n   (map #(hash-map (f %) (vector %)) vs)\n   (apply merge-with into)))","user":"4fbb7010e4b081705acca2e7"},{"code":"(fn [s c]\n  (loop [mp {}, afn s, coll c]\n    (if (seq coll)\n        (let [k (first coll) rv (afn k)]\n          (recur (merge-with concat mp (hash-map rv [k])) afn (rest coll)) \n        )\n        mp\n    )\n  )\n    )","problem":63,"user":"5229211be4b04c906c9c6a63"},{"problem":63,"code":"(fn groupSeq [f items]\n  (reduce (fn [set item]\n            (assoc set\n              (f item)\n              (conj (set (f item) []) item)))\n          {}\n          items))","user":"5f8330b8e4b01aacbe7a270f"},{"problem":63,"code":"(fn [func coll]\n  (let [rf (fn [m i]\n              (let [fe (func i)]\n                (if (m fe)\n                  (update-in m [fe] #(conj % i))\n                  (assoc m fe [i]))))]\n    (reduce rf {} coll)))","user":"50eeeadae4b02c17778c91f3"},{"problem":63,"code":"(fn myGroupBy [f coll]\n  (into {}\n        (map #(vector (f (first % )) (vec %))\n             (partition-by f (sort coll)))))","user":"59e0111ae4b08badc2a0c4e4"},{"problem":63,"code":"(fn [fun lis]\n  (reduce (fn [m v]\n            (let [k (fun v)\n                  r (conj (or (m k) []) v)]\n              (assoc m k r))) {} lis))","user":"56b6e354e4b0982f16b37e41"},{"code":"(fn [f values]\n  (loop [m {}\n   h (first values)\n\t res (f h)\n\t t (rest values)]\n    (if (nil? h)\n      m\n      (recur\n       (assoc m (f h)\n\t      (conj (into []\n\t\t\t  (get m (f h))) h))\n       \n       (first t)\n       (f h)\n       (rest t)))))","problem":63,"user":"504ec4d3e4b069badc5a33c9"},{"problem":63,"code":"(fn [func coll]\n  (reduce (fn [new-coll item]\n            (let [k (func item)]\n              (assoc new-coll k (conj (get new-coll k []) item))))\n          {}\n          coll))","user":"58740c18e4b01531a375ea49"},{"problem":63,"code":"(fn [f s]\n  (reduce (fn [h i]\n            (assoc h (f i) (conj (get h (f i) []) i))) {} s))","user":"57008afae4b08d47c97781ca"},{"code":"(fn [f s]\n  (reduce (fn [acc v]\n    (let [k (f v), ls (or (acc k) [])]\n      (assoc acc k (concat ls [v]))))\n  {} s))","problem":63,"user":"4de165f3535d08e6dec9fde6"},{"problem":63,"code":"(fn [& args]\n    (let [\n          [ff ss] args\n          conj-safe (fnil conj [])\n          rf (fn [cum-map new-val]\n               (let [key         (ff new-val)\n                     curr-lst    (cum-map key [])\n                     next-lst    (conj curr-lst new-val)\n                     new-cum-map (assoc cum-map key next-lst)\n                     ]\n                 new-cum-map ))\n          result (reduce rf {} ss)\n          ]\n      result\n    )\n  )","user":"532f7e12e4b019098a6f8b4e"},{"code":"(fn gb [f s]\n  (if (empty? s)\n    {}\n    (merge-with concat {(f (first s)) [(first s)]} (gb f (rest s)))))","problem":63,"user":"51b91b08e4b0e871ca4958f8"},{"problem":63,"code":"(fn [f coll]\n  (loop [re {}\n         list-val coll\n         cur-val (first list-val)]\n    (if (empty? list-val)\n      re\n      (recur\n       (if (nil? (get re (f cur-val)))\n         (conj re (hash-map (f cur-val) (conj [] cur-val)))\n         (assoc re (f cur-val) (conj (get re (f cur-val)) cur-val)))\n       (rest list-val)\n       (first (rest list-val))))))","user":"59b9e669e4b0a024fb6ae3db"},{"problem":63,"code":"(fn [f s]\n  (reduce (fn [map' elem]\n            (let [key' (f elem)]\n              (if (contains? map' key')\n                (update-in map' [key'] #(conj % elem))\n                (conj map' [key' [elem]]))))\n          {} s))","user":"567bf820e4b05957ce8c61ad"},{"code":"(fn [f coll]\n  (reduce (fn [acc v]\n    (let [r (f v)]\n      (assoc acc r (conj (get acc r []) v)))) {} coll))","problem":63,"user":"505bd09fe4b032b709c81373"},{"problem":63,"code":"(fn [f args]\n  (reduce (fn [acc v]\n    (assoc acc (f v) (conj (acc (f v) []) v)))\n  {}\n  args))","user":"53da059be4b0e771c302547e"},{"code":"(fn my-group\n  [f col]\n    (reduce\n      (fn\n        [map' val']\n        (let [\n              k (f val')\n              prev (if (nil? (map' k)) [] (map' k))\n              v (apply vector (conj prev val'))\n             ]\n         (assoc map' k v)))\n      {}\n      col))","problem":63,"user":"507a08e4e4b08327cd804a67"},{"code":"(fn [f s] (reduce #(assoc %1 (f %2) (conj (get %1 (f %2) []) %2)) {} s))","problem":63,"user":"50dfb660e4b061dbdced7228"},{"code":"#(reduce (fn [a v] (let [k (%1 v)] (assoc a k (conj (get a k []) v)))) {} %2)","problem":63,"user":"50e8cac5e4b0ebbe794eb7ef"},{"problem":63,"code":"(fn [f s]\n    (reduce\n     (fn [a x]\n       (assoc a (f x) (conj (get a (f x) []) x)))\n     {}\n     s))","user":"6026d2cae4b0d5df2af22232"},{"problem":63,"code":"(fn custom-group-by\n  [f coll]\n  (reduce\n   (fn [result-map e]\n     (let [to-key (f e)\n           to-vec (or (result-map to-key) [])]\n       (assoc result-map to-key (conj to-vec e))))\n   {} coll))","user":"4fc524aae4b081705acca37e"},{"problem":63,"code":"(fn [f xs]\n  (reduce #(update-in % [(f %2)] (fnil conj []) %2) {} xs))","user":"5d29c06be4b01671435dbc6b"},{"problem":63,"code":"(fn groupSeq \n  [a b]\n  (into {}\n        (map #(vector (a (first %)) (vec %))\n             (partition-by a (sort b)))))","user":"59dd3930e4b0a0ac046f2504"},{"problem":63,"code":"(fn [f coll] (reduce (partial merge-with (comp vec concat)) \n                     (map #(hash-map %1 (vec (list %2))) \n                     \t(map f coll) coll)))","user":"4fc9a977e4b0ee37620e1847"},{"code":"#(apply merge-with concat (for [v %2] {(%1 v) [v]}))","problem":63,"user":"500ec210e4b00fff93030f9d"},{"problem":63,"code":"(fn group-seq\n  ([f s] (group-seq f s {}))\n  ([f s out-map]\n   (let\n     [elem (first s)\n      elem-key (f elem)\n      elem-val (if (contains? out-map elem-key)\n                 (conj (get out-map elem-key) elem)\n                 (conj [] elem))\n      elem-map (assoc out-map elem-key elem-val)]\n     (if (empty? (rest s))\n       elem-map\n       (group-seq f (rest s) elem-map)))))","user":"57b356c2e4b0fbc9809a277b"},{"code":"(fn [f s]\n  (reduce\n   (fn [m v]\n     (let [x (f v)]\n       (update-in m [x] #(conj (if % % []) v))))\n   {}\n   s))","problem":63,"user":"52039e12e4b0fb7e47ea51ff"},{"code":"(fn [f s]\n  (reduce #(assoc %1 (f %2) (concat (%1 (f %2)) [%2])) {} s))","problem":63,"user":"4eab612d535d7eef30807316"},{"problem":63,"code":"#(apply merge-with\n         concat \n         (map (fn [x]\n                (hash-map (%1 x) [x]))\n              %2))","user":"4e38f245535deb9a81d77f3e"},{"problem":63,"code":"(fn [f coll]\n  (reduce (fn [m [k v]]\n            (println k v)\n            (assoc m k (conj (get m k []) v))) {}\n            (map (fn [x] [(f x) x]) coll)))","user":"552356fae4b0882d96d091af"},{"code":"(fn gb [f coll]\r\n   (apply merge-with #(vec (concat %1 %2))\r\n          (map #(apply hash-map %)\r\n               (partition 2 (interleave (map f coll) (map vector coll))))))","problem":63,"user":"4de623ef535d08e6dec9fdf4"},{"problem":63,"code":"(fn group-by2 [kgen coll] {:pre (fn? kgen)}\n    (reduce (fn [ret v] (assoc ret (kgen v) (conj (ret (kgen v) []) v))) {} coll)\n)","user":"5db7376fe4b010eb3c36cd43"},{"code":"(fn mgb [f s] (reduce #(assoc %1 (first %2) (concat (%1 (first %2)) (vector (second %2)))) {} (map #(vector (f %) %) s)))","problem":63,"user":"50b24a2fe4b03ea88043355c"},{"problem":63,"code":"(fn [f i] (reduce #(merge-with concat %1 (hash-map (f %2) [%2])) {} i))","user":"5632e850e4b0bfe05bf117ac"},{"problem":63,"code":"(fn vals-to-items [f coll]\n  (loop [[head & tail] coll\n         res {}]\n    (let [key (f head)\n          res (if (contains? res key)\n                (assoc res key (conj (res key) head))\n                (assoc res key (vector head)))]\n      (if (empty? tail)\n        res\n        (recur tail res))\n      )\n    )\n  )","user":"5dd67c22e4b0948ae9d9ad80"},{"problem":63,"code":"(fn [f s]\n     (into {}\n           (map #(vector (f (first %)) (vec %)) (partition-by f (sort s))))\n     )","user":"58a44a14e4b01a0c0b2328f2"},{"problem":63,"code":"(fn [f s]\n  (apply merge-with concat\n         (map #(assoc {} (f %) [%]) s)))","user":"557f7c8be4b05c286339e0e0"},{"problem":63,"code":"(fn foo [f s]\n  (reduce\n   (fn [acc x]\n     (let [k (f x)]\n       (assoc acc k (conj (get acc k []) x))))\n   {}\n   s))","user":"5d35f997e4b01671435dbd1a"},{"code":"(fn [gr coll]\n  (loop [input coll output {}]\n    (if (empty? input)\n      output\n      (let [next (first input) rest (rest input) key (gr next) value (output key)]\n        (if value\n          (recur rest (assoc output key (conj value next)))\n          (recur rest (assoc output key [next])))))))","problem":63,"user":"5033a1fbe4b062bc5d7ae155"},{"problem":63,"code":"(fn[f c](apply merge-with into (map #(sorted-map (f %) [%])c)))","user":"54aa665fe4b09f271ff37cb8"},{"code":"(fn [f s]\n  (reduce \n    #(let [k (f %2)]\n      (assoc %1 k (conj (get %1 k []) %2)))\n    {}\n    s))","problem":63,"user":"4f050dec535dcb61093f6bef"},{"problem":63,"code":"(fn [f s]\n  (reduce #(update-in %1 [(f %2)] concat [%2]) {}  s))","user":"5707abfce4b0b0fb43fd068d"},{"code":"(fn [grp s]\n  (->> s\n    (reduce #(assoc\n      %\n      (grp %2)\n      (conj (% (grp %2) []) %2)) {})))","problem":63,"user":"50657775e4b0deb876850599"},{"code":"#(reduce (fn [m item]\r\n            (let [k (%1 item)\r\n                  v (get m k [])]\r\n              (assoc m k (conj v item)))) {} %2)","problem":63,"user":"4f3e6244e4b0e243712b1f85"},{"code":"(fn [f s]\n (apply merge-with concat\n\t (map #(let [grouping (f %)]\n\t  \t\t\t\t\t{grouping [%]}\n\t  \t\t\t) s)\n )\n)","problem":63,"user":"5029f263e4b023940c84aa45"},{"problem":63,"code":"(fn [f s] \n  (reduce \n   #(assoc \n      %1 \n      (f %2) \n      (conj \n       (get %1 (f %2) [])\n       %2 \n       )) \n   {} \n   s))","user":"5ec0de29e4b00a66d4a9528e"},{"problem":63,"code":"(fn [f s] (reduce #(merge-with concat % {(f %2) [%2]})\n                  {}\n                  s))","user":"4f041de1535dcb61093f6ba5"},{"problem":63,"code":"(fn my-group-by [f coll]\n  (loop [coll coll\n         res {}]\n    (if (first coll)\n      (recur (rest coll) (let [in (first coll)]\n                           (assoc res (f in) (concat (get res (f in) []) [in]))))\n      res)))","user":"5c0e3f86e4b01240ff56713d"},{"problem":63,"code":"#_(fn [f coll]\n  (reduce (fn [m kv]\n            (merge-with concat m kv))\n          {}\n          (map (fn [e]\n                 {(f e) [e]})\n               coll)))\n\n(fn [f coll]\n    (reduce (fn [m kv]\n              (merge-with concat m kv))\n            {}\n            (map hash-map (map f coll) (map list coll))))","user":"56949fc5e4b0dcc4269f4120"},{"problem":63,"code":"(fn my-group-by [f xs]\n  (reduce (fn [result element]\n            (let [key (f element)\n                  values (or (result key) [])]\n              (assoc result key (conj values element))))\n          {}\n          xs))","user":"57e9a77ae4b0bfb2137f5b35"},{"problem":63,"code":"(fn [f xs]\n    (reduce #(let [v (f %2)] (assoc % v (conj (get % v []) %2))) {} xs))","user":"5275f7a2e4b03e8d9a4a74d0"},{"problem":63,"code":"(fn __\n  [function collection]\n  (->> (map #(list (function %) %) collection)\n       (reduce (fn [map [key value]]\n                 (assoc map key (conj (get map key []) value)))\n               {})))","user":"5ac91d90e4b0e27600da77bd"},{"problem":63,"code":"(fn [f s]\n  (reduce (fn [a b]\n            (let [k (f b)\n                  l (conj (vec (get a k)) b)]\n              (println k)\n              (println l)\n              (assoc a k l))) {} s))","user":"5489dd4de4b0e286459a11ef"},{"code":"(fn [f arg] (reduce\n    (fn [ret x] (assoc ret (f x) (conj (get ret (f x) []) x)))\n    {} arg))","problem":63,"user":"50c6fad1e4b00bb60fe0c52d"},{"code":"(fn grouped-by [f values]\n  (letfn [(stop-condition [values] (= 0 (count values)))\n          (group-iter [f values m]\n                      (if (stop-condition values) \n                        m\n                        (let [value (first values), new-key (f value), current (m new-key)]\n                          (group-iter f (rest values)\n                           (if current\n                            (assoc m new-key (conj current value))\n                            (assoc m new-key [value]))))))]\n    (group-iter f values {})))","problem":63,"user":"517531c6e4b07031762f2eea"},{"problem":63,"code":"(fn my-group-by\n  [f list]\n  (reduce\n    (fn [mapx item]\n      (if (contains? mapx (f item))\n        (assoc mapx (f item) (conj (get mapx (f item)) item))\n        (assoc mapx (f item) (vector item))\n        )\n      )\n    {}\n    list\n    )\n  )","user":"5bc8c033e4b07a9b28b100ca"},{"problem":63,"code":"(fn [f coll]\n  (reduce\n   \t(fn [m x]\n      (let [k (f x)]\n        (assoc m k (conj (get m k []) x))))\n   {} coll))\n\n;use 'update' instead of 'assoc' if supported","user":"5db19599e4b010eb3c36cd05"},{"code":"(fn [fun coll]\n  (into {}\n        (map (fn [item]\n               (vector (fun item)\n                       (filter #(= (fun %) (fun item))\n                               coll))) coll)))","problem":63,"user":"4f7431d2e4b044e54cd9a8f7"},{"problem":63,"code":"(fn grouper [f coll]\n  (let [ inner-grouper (fn [f coll acc]\n                        (if (empty? coll)\n                          acc\n                          (let [new-key (f (first coll))\n                                 new-val (first coll)]\n                            (do\n                              (prn coll acc)\n                              (recur f (rest coll) (assoc acc new-key (conj (get acc new-key []) new-val)))))))]\n    (inner-grouper f coll '{})))","user":"56f4cedce4b046a417f92063"},{"problem":63,"code":"(fn [f xs]\n  (reduce \n   (fn [acc x]\n     (let [v (f x)]\n       (assoc acc v\n         (conj (get acc v []) x))))\n   {} xs))","user":"553698fae4b09218d5f44fc0"},{"problem":63,"code":"(fn [func values]\n  (into {}\n        (map #(vector (func (first % )) (vec %))\n             (partition-by func (sort values)))))","user":"5c387c51e4b0d62ef62d9f83"},{"code":"(fn [f s] (reduce #(assoc %1 (f %2) (concat (%1 (f %2)) [%2] )) {} s ))","problem":63,"user":"53403110e4b085b17e897da6"},{"problem":63,"code":"(fn [f l]\n  (reduce (fn [m e]\n\t\t\t(let [k (f e)\n\t\t\t\t  v  (m k)]\n            (if (nil? v)\n              (conj m [k [e]])\n              (conj m [k (conj v e)]))))\n          {} l))","user":"56051095e4b08b23635d3162"},{"code":"(fn [func insek]\n(let [map-to-function (fn [inmap funcy valy]\n  (let [k (funcy valy)]\n  (assoc inmap k (conj (get inmap k []) valy))))]\n  (reduce  #(map-to-function %1 func %2) {} insek)))","problem":63,"user":"4eb9353f535dfed6da9c6d4e"},{"problem":63,"code":"(fn [f xs]\n  (reduce\n    (fn [m x]\n      (update-in m [(f x)] #(conj (or % []) x)))\n    {} xs))","user":"53dfdf01e4b0d874e779ae46"},{"problem":63,"code":"(fn [f coll]\n   (->> (map #(hash-map (f %) [%]) coll)\n        (apply merge-with (comp vec concat))))","user":"5327c591e4b09d4e7a9b54ff"},{"problem":63,"code":"(fn [f coll]\n  (loop [m {}\n         c coll]\n    (println m)\n    (if (empty? c)\n      m\n      (recur (assoc m (f (first c)) (conj (into [] (get m (f (first c)))) (first c)))\n             (rest c)))))","user":"5541fa50e4b0a04f79299515"},{"problem":63,"code":"(fn [f c] (reduce (fn [m v] (assoc m (f v) (vec (conj (m (f v)) v)))) {} c))","user":"5a5894d9e4b05d388ecb6c81"},{"code":"(fn [f s] (reduce #(update-in %1 [(f %2)] (fnil conj []) %2) {} s))","problem":63,"user":"4db8ec47535d1e037afb219d"},{"problem":63,"code":"(fn gb [f s]\n  (reduce (fn [m el] \n            (update-in m (list (f el)) #(conj (vec %1) el))) {} s))","user":"57af41bce4b0fbc9809a2731"},{"problem":63,"code":"(fn foogroup [f coll]\n  (reduce\n    (fn [prev cur]\n      (let [val (f cur)]\n        (assoc prev val (conj (or (prev val) []) cur))))\n    {}\n    coll))","user":"56fc0601e4b07572ad1a88db"},{"code":"(fn [f coll] (into {} (for [v coll] {(f v) (filter #(= (f v) (f %)) coll)})))","problem":63,"user":"4e58c019535d8a8b8723a297"},{"code":"(fn [f coll]\n  (apply merge-with concat (map #(hash-map %1 %2) (map f coll) (map list coll))))","problem":63,"user":"524b90fae4b09eba1c0223df"},{"problem":63,"code":"(fn [funk coll]\n  (reduce \n    (fn [lv cv] (assoc lv (funk cv) (into [] (conj (get lv (funk cv) []) cv))))\n    {} coll))","user":"542fa0dde4b0dad94371f2d2"},{"problem":63,"code":"(fn [foo x] \n   (into (sorted-map) (reduce \n    (fn [out part]\n      (assoc out part (reduce \n        (fn [in-out in-part]\n          (if (= (foo in-part) part)\n            (conj in-out in-part)\n            in-out)\n        )\n      []\n      x\n      ))\n    )\n   {}\n   (set (map foo x))\n   ))   \n)","user":"5f3a8493e4b004f08c61c527"},{"problem":63,"code":"(fn [f xs] \n  (reduce (fn [acc x] (if (contains? acc (f x))\n                        (into acc {(f x) (into (get acc (f x)) [x])})\n                        (into acc {(f x) [x]}))) {} xs))","user":"552b6ddbe4b0ffed3738f965"},{"problem":63,"code":"(fn group-seq [f coll]\n  (let [vs (map #(vector (f %) %) coll)]\n    (reduce (fn [res m]\n              (update-in res [(first m)] #(if (empty? %) [(second m)]\n                                               (conj % (second m))))) {} vs)\n    )\n  )","user":"589037b4e4b00487982d51d0"},{"code":"(fn [f coll]  \n   (reduce\n    (fn [ret x]\n      (let [k (f x)]\n        (assoc ret k (conj (get ret k []) x))))\n    {} coll))","problem":63,"user":"5126dbabe4b083bb8f88cf0e"},{"code":"#(reduce (fn [a b] (assoc a (%1 b) (conj (get a (%1 b) []) b))) {} %2)","problem":63,"user":"4e5411e8535d8a8b8723a279"},{"problem":63,"code":"(fn [f z]\n    (reduce\n      (fn [hmap x]\n        (let [key-val (hmap (f x))]\n        (assoc hmap (f x)\n          (conj (if (nil? key-val)\n            []\n            key-val\n          ) x))))\n    {} z))","user":"5822b578e4b04b46fc4b0fa4"},{"problem":63,"code":";; assoc {} false [1]\n;; assoc {false [1]} false [1 3]\n;; assoc {false [1 3]} true [6]\n;; assoc {false [1 3] true [6]} true [6 8]\n(fn [f coll] (reduce (fn [acc x] \n                       (let [result-key (f x)]\n                         (if (contains? acc result-key)\n                           (assoc acc result-key (conj (get acc result-key) x))\n                           (assoc acc result-key (vector x)))))\n                       {} \n                       coll))","user":"54a6baaee4b09f271ff37c8a"},{"problem":63,"code":"(fn [f c] (let [s (set (map f c))] (zipmap s (map #(vec (filter (fn [x] (= % (f x))) c)) s))))","user":"5507cfd3e4b021ccfedb96ad"},{"problem":63,"code":"(fn my-group-by [f coll]\n  (reduce (fn [m x] (assoc m (f x) (if (m (f x)) (conj (m (f x)) x) [x])))\n          {} coll))","user":"50aa777fe4b056ee01935866"},{"problem":63,"code":"(fn [f xs]\n  (reduce \n   (fn [m x]\n     (let [v (f x)]\n       (if (contains? m v)\n         (merge m [v (conj (get m v) x)])\n         (merge m [v [x]]))))\n   {}\n   xs))","user":"5f5e7158e4b02876ed9fcff0"},{"code":"(fn [f s]\n    (reduce (fn [m v]\n              (let [key (f v)]\n                (conj m [key (conj (vec (m key)) v)]))\n              ) {} s)\n    )","problem":63,"user":"502bb7c0e4b0194ad32ea1a3"},{"problem":63,"code":"(fn [f l]\n  (loop [remaining l \n         result {}]\n    (if (= (count remaining) 0)\n      result\n      (let [value (first remaining)\n            key (f value)]\n        (recur\n          (rest remaining)\n          (if (contains? result key)\n            (assoc result key (conj (get result key) value) )\n            (assoc result key [value])\n          )\n        )\n      )\n    )\n  )\n)","user":"57b55290e4b0fbc9809a27a9"},{"code":"(fn [f xs]\n  (apply merge-with concat (map #(hash-map (f %) [%]) xs)))","problem":63,"user":"50b9d991e4b04934c218a4a9"},{"problem":63,"code":"#(apply merge-with concat (for [z %2] {(%1 z) [z]}))","user":"574a71b7e4b02ea1147991fb"},{"problem":63,"code":"(fn [f col]\n  (reduce #(conj % [(f %2) (conj (if-let [x (% (f %2))] x []) %2)]) {} col))","user":"57035ccfe4b08d47c97781ef"},{"problem":63,"code":"(fn [f c] (reduce (fn [acc e] (assoc acc (f e) (conj (or (acc (f e)) []) e))) {} c))","user":"547d8e93e4b0c51c1f4d72f4"},{"problem":63,"code":"(fn [f a]\n   (let [k (distinct (map f a))\n       m (reduce #(assoc %1 %2 []) {} k)]\n   (reduce #(assoc %1 (f %2) (conj (get %1 (f %2)) %2)) m a)))","user":"5d5ef0bce4b0c9e5857d4ffb"},{"problem":63,"code":"(fn \n  [f col]\n  (reduce (fn [m v]\n            (let [key (f v) val (m key)]\n              (if val\n                (assoc m key (conj val v))\n                (assoc m key (vector v)))))\n          {} col))","user":"56b1ab17e4b0982f16b37df1"},{"problem":63,"code":"(fn group-by'\n  [f s]\n  (let [results (map #(hash-map (f %) [%]) s)]\n    (apply merge-with concat results)))","user":"56488119e4b0284900eef632"},{"code":"(fn [f l]\n  (reduce \n    #(assoc %1 (f %2) (conj (%1 (f %2) []) %2))\n    {} l))","problem":63,"user":"5220909fe4b0e6a83c89259f"},{"problem":63,"code":"(fn my-group-by [f s]\n    (reduce\n     (fn [out i] (update-in out [(f i)] #(into [] (conj % i))))\n     {} s))","user":"57f6e666e4b0d3187e9008f2"},{"problem":63,"code":"(fn [f xs] (apply merge-with concat (map #(identity {(f %) [%]}) xs)))","user":"50f3bd98e4b041536e2eca3a"},{"problem":63,"code":"(fn my-group-by [f coll]\n  (reduce\n    (fn [result item]\n      (update-in result\n              [(f item)]\n              (fn [old-val]\n                (conj (if (nil? old-val) [] old-val) item))))\n    {} coll))","user":"56ac81ace4b03c432f187347"},{"problem":63,"code":"(fn [f coll] (reduce #(conj % [(first %2) (conj (get % (first %2) []) (second %2))]) {} (map vector (map f coll) coll)))","user":"554680cbe4b0a04f7929953e"},{"problem":63,"code":"(fn group-seq\n  [f coll]\n  (reduce (fn [result ele]\n            (if (result (f ele))\n              (assoc result (f ele) (conj (result (f ele)) ele))\n              (assoc result (f ele) [ele])))\n          {}\n          coll))","user":"5746cb28e4b009280f9f2b68"},{"problem":63,"code":"(fn [f col]\n  (->> col\n       (map #(hash-map (f %) [%]))\n       (apply merge-with into)))","user":"514992d2e4b0b64cbeae1848"},{"problem":63,"code":"#(reduce (fn [acc e]\n            (assoc acc (% e)\n                   (conj (acc (% e) []) e))) {} %2)","user":"56f7ecdfe4b08e7d20b96834"},{"code":"(fn gb [f coll]\n  (reduce\n   (fn [m n]\n      (let [key (f n) val (m key [])]\n        (assoc m key (conj val n))))\n   {}\n   coll))","problem":63,"user":"4f8bbb27e4b02e764a0a5182"},{"code":"(fn [f vs]\n  (letfn [(apply-f [resmap v]\n    (let [k  (f v)\n          rs (get resmap k [])]\n      (assoc resmap (f v) (conj rs v))))]\n    (reduce apply-f {} vs)))","problem":63,"user":"505345d9e4b0517ede0d0a06"},{"problem":63,"code":"(fn my-group-by [f s]\n  (let [values (set (map f s))\n        val-map (zipmap values (repeat []))]\n    (reduce (fn [m v] (update-in m [(f v)] #(conj % v)))\n            val-map\n            s)))","user":"5b47874be4b02d533a91bc70"},{"code":"(fn [f s] (reduce #(assoc % (f %2) ((fnil conj []) (% (f %2)) %2)) {} s))","problem":63,"user":"4f4274f2e4b0d7d3c9f3fd00"},{"problem":63,"code":"(fn group-by2 [f v]\n  (let [m (reduce \n           #(let [key (f %2)] \n              (assoc %1 key (conj (%1 key) %2))) \n           {} v)]\n    (zipmap (keys m) (->> (vals m)\n                          (map vec)\n                          (map reverse)))))","user":"60460824e4b02d28681c77bc"},{"problem":63,"code":"(fn [f xs]\n  (reduce (fn [a x] (update-in a [(f x)] (fnil conj []) x)) {} xs))","user":"5afb4b15e4b0cc2b61a3bcf6"},{"code":"(fn [f lst]\n (loop [ d {} lst lst ]\n  (if lst; as long as not nil\n   (let [in (first lst)\n         out (f in)\n         d-entry (d out) ]\n    (if d-entry\n     (recur (assoc d out (conj d-entry in)) (next lst))\n     (recur (assoc d out [in]) (next lst))))\n   d)))","problem":63,"user":"4e356d2b535deb9a81d77f2d"},{"problem":63,"code":"(fn [f col]\n  (let [ks (distinct (map f col))] \n    (apply merge-with (fn [v1 v2] (concat v1 v2))\n       (for [k ks]\n         (assoc {} k\n                   (filterv #(= (f %) k) col))))))","user":"58bcecc9e4b0888cdc949d24"},{"code":"(fn [pred xs]\n      (apply merge-with concat\n             (map #(hash-map (pred %) [%]) xs)))","problem":63,"user":"50f48298e4b004d364930527"},{"code":"(fn r[f s]\n (let [l {}]\n \t(reduce (fn [l e]\n       (let [v (f e)]\n         (if-let [p (l v)]\n           (assoc l v (vec (conj p e)))\n           (assoc l v [e])))) l s)))","problem":63,"user":"51b793d3e4b0d906fcd71d38"},{"problem":63,"code":"(fn [f coll]\n   (->> (map #(list (f %) %) coll)\n        (reduce (fn [acc [key val]]\n                  (assoc acc key\n                         (conj (vec (get acc key)) val)))\n                {})))","user":"5808ee16e4b0a837a8b30d16"},{"code":"(fn \n  [f xs]\n  (apply merge-with concat (map (fn [x] (hash-map (f x) [x])) xs)))","problem":63,"user":"531490bde4b08068f379ed17"},{"code":"(fn gb [f coll] \n      (loop [m {}\n             s coll]\n        (if (seq s)\n          (let [v (f (first s))]\n            (recur (assoc m v (conj (get m v []) (first s))) (next s)))\n          m)))","problem":63,"user":"4e6a11ee535d8ccf87e9fe9f"},{"problem":63,"code":"(fn [f l]\n           (reduce #(assoc %1 (f %2) (conj (get %1 (f %2) []) %2)) {} l))","user":"531902b1e4b08068f379ed77"},{"problem":63,"code":"(fn my-group-by\n  [f s]\n  (let [ks (map f s)\n        maps (map #(hash-map %1 [%2]) ks s)]\n    (apply merge-with into maps)))","user":"562eeba2e4b0ab312c17ebc1"},{"code":"(fn [f s] (reduce #(update-in %1 [(f %2)] (fn [x] (conj (or x []) %2))) {} s))","problem":63,"user":"4e707db6535d5021c1a8963a"},{"code":"(fn grpby [f c]\n  (reduce (fn [acc it]\n            (let [r (f it)]\n              (if (nil? (acc r))\n                (assoc acc r [it])\n                (assoc acc r (conj (acc r) it)))))\n          {} c))","problem":63,"user":"51502056e4b098b221effc25"},{"problem":63,"code":"#(reduce (fn [m e] (assoc m (% e) `[~@(m (% e)) ~e] )) {} %2)","user":"58391c94e4b089d5ab817d35"},{"code":"(fn __ [f values]\n  (apply merge-with concat (for [x values] \n    {(f x) [x]})))","problem":63,"user":"4ec9549d535d6d7199dd36fe"},{"problem":63,"code":"#(apply merge-with concat\n        (map (fn [item]\n               (hash-map (%1 item) [item]))\n             %2))","user":"59251947e4b072a2710fce69"},{"problem":63,"code":"(fn [f coll]\n  (reduce #(let [k (f %2)]\n             (assoc %1 k (conj (get %1 k []) %2))) {} coll))","user":"549eb44fe4b0f3d1d8e70fa6"},{"problem":63,"code":"(fn [f sequ] \n  (into {}\n  (map #(vector (f (first %)) (vec %))\n   (partition-by f (sort sequ))))\n  )","user":"5a534241e4b05d388ecb6c0a"},{"problem":63,"code":"(fn gb \n  ([f s] (gb f s {}))\n  ([f s m]\n   (if-let [v (first s)]\n     (gb f (rest s) (assoc m (f v) (conj (get m (f v) []) v)))\n     m)))","user":"5776f39de4b0979f89651643"},{"problem":63,"code":"(fn\n  [f aseq]\n  (loop [as aseq el (first as) acc {}]\n    (if (empty? as)\n      acc\n      (let [asr (rest as)\n            akey (f el)\n            aval (if (contains? acc akey) (acc akey) [])]\n        (recur\n          asr\n          (first asr)\n          (assoc acc akey (conj aval el)))))))","user":"56cb4d06e4b0ea9b8538f72e"},{"code":"(fn [f xs] (reduce #(assoc % (f %2) (conj (vec (% (f %2))) %2)) {} xs))","problem":63,"user":"53976599e4b0b51d73faaeea"},{"problem":63,"code":"(fn [f coll]\n  (apply merge-with concat (map (fn [v] {(f v) [v]}) coll)))","user":"57ea2c91e4b0bfb2137f5b42"},{"problem":63,"code":"(fn \n  [f s] \n  (apply merge-with concat \n         (map #(hash-map (f %) [%]) s)))","user":"55b107fee4b002ce9d5cbc2a"},{"problem":63,"code":"(fn my-groupby [f coll]\n  (apply merge-with concat\n         (map (fn [x y] (hash-map x [y])) (map f coll) coll)))","user":"5471f0f3e4b094393f72dd6f"},{"problem":63,"code":"(fn my-group-by [assoc-func collection]\n  (reduce (fn [old-map next-value]\n    (let [new-key (assoc-func next-value)\n          old-list (get old-map new-key [])]\n      (assoc old-map new-key (conj old-list next-value)))) {} collection))","user":"5773f3a9e4b0979f896515f2"},{"code":"(fn [f xs]\n  (loop [acc {} x (first xs) xs (rest xs)]\n    (if (nil? x)\n      acc\n      (let [fx (f x)\n            preset (get acc fx)]\n        (recur (assoc acc fx\n                  (if (nil? preset)\n                    [x] (conj preset x)))\n          (first xs) (rest xs))))))","problem":63,"user":"4dafa380edd6309eace4d17c"},{"code":"(fn [f l] (reduce #(let [k (f %2)] (assoc % k (conj (get % k []) %2))) {} l))","problem":63,"user":"534bde26e4b084c2834f4a81"},{"problem":63,"code":"(fn my-group-by [f seq]\n  (reduce #(assoc %1 (f %2) (conj (%1 (f %2) []) %2)) {} seq))","user":"60849bd6e4b0736b099e42f2"},{"problem":63,"code":"(fn [f s]\n  (reduce\n    (fn [m v]\n      (let [k (f v)]\n        (if (contains? m k)\n          (assoc m k (conj (get m k) v))\n          (assoc m k [v]))))\n     {} s))","user":"5f3ddc71e4b004f08c61c551"},{"problem":63,"code":"(fn [f s]\n  (reduce\n   (fn [val next]\n     (let [res (f next)]\n       (assoc val res (if (contains? val res)\n                        (conj (val res) next)\n                        (vector next)))))\n   {} s))","user":"60b7e2c5e4b0e0fa5f1b4252"},{"problem":63,"code":"(fn [f coll]\n    (loop [C (map (fn [i] [(f i) i]) coll),\n           M {}]\n      (if (empty? C)\n        M\n        (let [[k v] (first C), rr (rest C)]\n          (recur rr (assoc M k (conj (get M k []) v)))\n          )\n        )\n      )\n    )","user":"552d9013e4b076ab5578f7ea"},{"problem":63,"code":"(fn q [f s] \n(apply merge-with concat (map #(hash-map (f %) [%])s) )\n)","user":"583048d9e4b051871117c007"},{"problem":63,"code":"(fn[f s]\n     (into {} (map (fn [t]\n                  [t (vec (filter #(= t (f %)) s))]) (map f s))))","user":"5f77890ae4b02876ed9fd0b9"},{"problem":63,"code":"(fn [f s] \n  (reduce \n   (fn [m i]\n     (let [k (f i)\n          prev (get m k)\n          new (conj (or prev []) i) ]\n       (assoc m k new)))\n   {}\n   s))","user":"5880e38fe4b0f1effa3b7625"},{"problem":63,"code":"(fn group [f xs]\n  (if (empty? xs) \n    {}\n    (merge-with concat {(f (first xs)) [(first xs)]} (group f (rest xs)))))","user":"563c7f98e4b0bfe05bf11836"},{"problem":63,"code":"(fn [f xs]\n  (reduce #(let [r (f %2)]\n            (update-in %1 [r] (fn [c] (if c  (conj c %2) [%2])) )) {} xs))","user":"56df254be4b0ca2494a095ea"},{"code":"(fn [f s]\n    (apply merge-with concat \n          (for [x s] {(f x) [x]})))","problem":63,"user":"4e599577535d8a8b8723a29f"},{"problem":63,"code":"(fn [f s]\n  (let [gs (map hash-map (map f s) (map vector s))]\n     (apply merge-with concat gs)\n))","user":"54524afbe4b0e397800069bc"},{"problem":63,"code":"(fn my-group-by [f coll]\n  (reduce #(assoc %1\n                  (f %2)\n                  (vec (conj (%1 (f %2)) %2)))\n            {}\n            coll))","user":"58f2e8fbe4b0438e51c2ce94"},{"problem":63,"code":"(fn [f s]\n  (reduce\n    (fn [out value] (update-in out [(f value)] #(if (= nil %) [value] (conj % value))))\n    {}\n    s))","user":"4f43894ee4b0d7d3c9f3fd21"},{"problem":63,"code":"(fn my-group [func coll]\n  (loop [in coll\n         out {}]\n    (if (empty? in)\n      out\n      (recur (rest in) (assoc out (func (first in)) (conj (out (func (first in)) []) (first in)))))))","user":"551d5cb9e4b07993ea3788e9"},{"problem":63,"code":"(fn grpby [f, s]\n  (loop [i s, r {}]\n    (if (empty? i)\n      r\n      (let [k (first i)\n            v (f k)\n            o (r v)]\n        (if o\n          (recur (rest i) (assoc r v (conj o k)))\n          (recur (rest i) (assoc r v [k])))))))","user":"5590e55de4b0277789237676"},{"problem":63,"code":"(fn [f coll]  \n  (persistent!\n   (reduce\n    (fn [ret x]\n      (let [k (f x)]\n        (assoc! ret k (conj (get ret k []) x))))\n    (transient {}) coll)))\n\n;; assertion code failed to handle my own implementation \"Parameter declaration reduce should be a vector\"\n;(defn [f coll]\n;  (reduce (fn [acc x]\n;            (let [k (f x)]\n;              (update-in acc [k] #(into (if (nil? %) [] %) [x])))) (transient {}) coll))","user":"54a96a15e4b09f271ff37cad"},{"code":"(fn [f c]\n  (reduce \n    (fn [m x] (let [v (f x)] \n      (assoc m v (conj (get m v []) x)))) \n    {} \n    c))","problem":63,"user":"4e6a4954535d8ccf87e9fec0"},{"problem":63,"code":"(fn grp\n  ([f s] (grp {} f s))\n  ([acc f [x & xs]]\n   (if x\n     (let [g (f x)]\n       (if (acc g)\n         (grp (assoc acc g (conj (acc g) x)) f xs)\n         (grp (assoc acc g [x]) f xs)))\n     acc)))","user":"57a0b341e4b0c3d858beb8d4"},{"problem":63,"code":"(fn [f coll]\n    (reduce\n        (fn [groups item]\n            (let [f-item (f item)\n                    grp (groups f-item :not-in-map)]\n                (if (= grp :not-in-map)\n                    (assoc groups f-item [item])\n                    (assoc groups f-item (conj grp item)))))\n        {}\n        coll))","user":"533b1dc4e4b0e30313ee6cc7"},{"problem":63,"code":"(fn [f c]\n   (let [add-to-vec-in-map-fn (fn [m k v] (assoc m k (conj (m k []) v)))\n         put-to-map-fn (fn [v] (fn [m] (add-to-vec-in-map-fn m (f v) v)))\n         put-to-map-fn-list (reverse (map put-to-map-fn c))]\n     ((apply comp put-to-map-fn-list) {})))","user":"54357066e4b0b6b47310fcfd"},{"code":"(fn [f xs]\n    (loop [[h & tl] xs acc {}]\n      (if (nil? h)\n        acc\n        (let [x (f h)]\n          (if (acc x)\n            (recur tl (update-in acc [x] conj h))\n            (recur tl (assoc acc x [h])))))))","problem":63,"user":"5089ebfee4b03217b26a539f"},{"code":"(fn cmp [f s]\n  (let [key-val-pairs (map #(vector (f %) %) s)\n        append (fn [m [k v]]\n                 (assoc m k (conj (m k []) v)))]\n    (reduce append {} key-val-pairs)))","problem":63,"user":"50b8914ce4b0cba0e598b64d"},{"problem":63,"code":"(fn  [f s]\n  (apply merge-with clojure.set/union (for [e s] {(f e) [e]}))\n)","user":"5b2689e3e4b063e2438bcc33"},{"code":"(fn [f coll]\n  (reduce #(assoc %1 (f %2) (conj (%1 (f %2) []) %2)) {} coll))","problem":63,"user":"4e3bcccd535deb9a81d77f56"},{"problem":63,"code":"(fn m-group-m [f seq]\n  (if (empty? seq) nil\n                   (let [m (m-group-m f (rest seq)) key (f (first seq))  ]\n                   (assoc m key (cons (first seq) (get m key []))\n\n                   ))\n))","user":"575ebba3e4b08062f99a4e70"},{"code":"(fn [f coll]\n  (loop [left coll result {}]\n    (if (empty? left)\n      result\n      (let [k (f (first left)) v (first left)]\n        (recur (rest left)\n               (assoc result k (conj (get result k []) v)))))))","problem":63,"user":"5225271fe4b01819a2de42f9"},{"code":"(fn [f coll]\n  (reduce #(let [key (f %2)\n                 vec (% key) ] \n             (if vec\n               (assoc %1 key (conj vec %2))\n               (assoc %1 key (conj [] %2)))) {} coll))","problem":63,"user":"4e6e3aac535d5021c1a89603"},{"problem":63,"code":"(fn my-group-by [func L]\n  (reduce (fn [m elem]\n            (let [key (func elem)]\n              (if (contains? m key)\n                (assoc m key (conj (get m key) elem))\n                (assoc m key (vector elem)))))\n          {} L))","user":"5a621702e4b0512ff01cd983"},{"code":"(fn [f coll]\n  (reduce\n    (fn [m x]\n      (let [k (f x)]\n        (assoc m k \n          (conj (get m k []) x))))\n    {} coll))","problem":63,"user":"52d0902ee4b07d0d72b273bd"},{"problem":63,"code":"(fn\n  [f collection]\n  (loop [my-map {} x (first collection) xs (rest collection)]\n    (let [key (f x)\n          my-map-value (get my-map key)\n          new-my-map \n          (if (nil? my-map-value)\n            (do\n              (assoc my-map key (conj [] x)))\n            (do\n              (assoc my-map key (conj my-map-value x))))]\n      (if (empty? xs)\n        new-my-map\n        (recur new-my-map (first xs) (rest xs))))))","user":"57596ba7e4b02ea11479931a"},{"code":"(fn [f s] (apply merge-with #(conj % %2) (into {} (for [x (map f s)] [x []])) (map #(do {(f %) %}) s)))","problem":63,"user":"5061cc17e4b0a30dc9a35d34"},{"code":"(fn [f s]\n  (let [parted-s (partition-by f s)\n        parted-ks (map #(hash-map (f (first %)) %) parted-s)]\n    (apply (partial merge-with concat) parted-ks)))","problem":63,"user":"5092fe10e4b097f48cc3857e"},{"code":"(fn myfn [f l]\n  (reduce \n   (fn [acc i] \n       (if (contains? acc (f i))\n\t   (assoc acc (f i) (conj (acc (f i)) i))\n\t (assoc acc (f i) [i])\n\t ))\n  {}\n  l\n  ))","problem":63,"user":"52aa16d1e4b0c58976d9ac5a"},{"problem":63,"code":"(fn [f xs]\n    (->> xs\n         (map (juxt #( f %) #(vector ( identity %))))\n         (map (partial apply hash-map))\n         (apply merge-with concat )) )","user":"53dcdde4e4b0d874e779ae24"},{"problem":63,"code":"(fn [f dat]\n    (reduce (fn [x y]\n              (if (contains? x (f y))\n                (into x {(f y) (conj (x (f y)) y)})\n                (into x {(f y) [y]}))) {} dat))","user":"591f5124e4b09b4ee5954c45"},{"problem":63,"code":"(fn t [f xs]\n  (reduce\n    (fn [r x]\n      (merge\n        r\n        {(f x)\n          (if (= (find r (f x)) nil)\n            [x]\n            (concat (get r (f x)) [x])\n          ) \n        }\n      )\n    )\n    {}\n    xs\n  )\n)","user":"4fc8f671e4b0ee37620e1840"},{"problem":63,"code":"(fn \n   [f lst] \n   (apply merge-with into \n          (for [a lst] {(f a) [a]})))","user":"5bbc0ddfe4b0a20761a2361e"},{"problem":63,"code":"(fn my-grp [fun coll]\n     (let [unique-keys  (-> fun\n                          (map coll)\n                          (distinct)) \n           with-eval (map #(vector % (fun %)) coll)]\n       (into {}\n        (map  \n          (fn [key-val]\n            (vector\n             key-val \n               (into [] \n                     (map first\n                         (filter \n                            (fn [[orig evald]]\n                              (= evald key-val))\n                            with-eval)))))\n         unique-keys))))","user":"571d9669e4b0145328a7627f"},{"code":"#(apply merge-with into (for [x %2] {(% x) [x]}))","problem":63,"user":"4f083048535dcb61093f6c33"},{"problem":63,"code":"#(reduce\n  (fn [out x]\n    (let [k (%1 x)\n          v (out k)] (assoc out k (if v (conj v x) [x])))) {} %2)","user":"55647a31e4b0c656e3ff1808"},{"code":"(fn [f coll] \n  (let [m (fn [a b] (assoc a (f b) (if (contains? a (f b)) (conj (a (f b)) b) [b])))]\n  \t(reduce m {} coll)))","problem":63,"user":"51a768e0e4b0da5f497bde84"},{"code":"(fn group [f s]\n  (loop [r {} s s]\n    (if (empty? s)\n      r\n      (let [k (f (first s))]\n        (recur (assoc r k (conj (get r k []) (first s))) \n              (rest s))))))","problem":63,"user":"4e9c3648535dbda64a6f6b7d"},{"problem":63,"code":"#(reduce (fn [a v] (merge-with concat a {(% v) [v]})) {} %2)","user":"523630eee4b05f3be1c7c8e8"},{"problem":63,"code":"(fn [pred coll] (let [left (set (map pred coll))] (zipmap left (map (fn [l] (filter #(= l (pred %)) coll)) left))))","user":"5da8b8ece4b000c986472c28"},{"code":"#(reduce (fn[x y](merge-with (fn [q z](vec (concat q z))) x y))(map (fn[x] (apply assoc {} x)) (partition 2 (interleave (map first (partition-by identity (map %1 %2)))(map vec (partition-by %1 %2))))))","problem":63,"user":"4ed2dd98535d44c135fd68e2"},{"code":"(fn [f x] (reduce\n           (fn [x [k v]]\n             (let [e (get x k)]\n               (if e\n                 (assoc x k (conj e v))\n                 (assoc x k [v]))))\n           {}\n           (map #(list (f %) %) x)))","problem":63,"user":"53034738e4b0d8b024fd373e"},{"problem":63,"code":"(fn group-seq [f s]\n  (loop [keys (distinct (map f s)) result {}]\n    (if (empty? keys)\n\t  result\n      (let [key (first keys) values (filter #(= (f %) key) s) rest-keys (rest keys)]\n\t    (recur rest-keys (assoc result key values))))))","user":"51eec1a6e4b0871fa145d98d"},{"problem":63,"code":"(fn [func coll]\n  (let [results (map func coll)\n        distinct-results (distinct results)\n        base-hash (apply hash-map (interleave distinct-results (repeat [])))]\n    (reduce #(update-in %1 [(first %2)] conj (last %2))\n            base-hash\n            (map list results coll))))","user":"53dd37aee4b0d874e779ae28"},{"problem":63,"code":"(fn gb [f xs]\n  (if (empty? xs) {}\n    (let [rm (gb f (rest xs))\n          v (first xs)\n          k (f v)]\n      (assoc\n        rm k\n        (cons v (rm k)))\n    )\n  ))","user":"6045582fe4b02d28681c77b6"},{"code":"#(apply merge-with concat \n  (map-indexed (fn [_ b] {(% b) [b]}) %2))","problem":63,"user":"4f0333f6535dcb61093f6a77"},{"code":"(fn [f coll] (reduce (fn [acc el] (update-in acc [(f el)] (fnil #(conj % el) []))) {} coll))","problem":63,"user":"50e8a340e4b0ebbe794eb7ed"},{"code":"(fn [f coll]\n (reduce\n  (fn [map x]\n   (let [k (f x)] \n    (if (contains? map k)\n     (update-in map [k] #(conj % %2) x)\n     (assoc map (f x) [x])))) \n  {} coll))","problem":63,"user":"51db1abae4b094966a2cd685"},{"code":"#(reduce\n(fn [m x] (assoc m (% x) (conj (m (% x) []) x))) \n{} %2)","problem":63,"user":"4ebd33e4535dfed6da9c6d8e"},{"code":"(fn [f coll]\n  (let [iter (fn [so-far to-go]\n               (if (empty? to-go)\n                 so-far\n                 (let [head (first to-go)\n                       tail (rest to-go)\n                       result (f head)]\n                   (if (some #(= result %) (keys so-far))\n                     (recur (assoc so-far result (conj (so-far result) head)) tail)\n                     (recur (assoc so-far result [head]) tail)))))]\n    (iter {} coll)))","problem":63,"user":"4e42f930535dc968683fc49f"},{"problem":63,"code":"(fn [f x]\n  (apply merge-with concat (map #(hash-map (f %) [%]) x)))","user":"55205564e4b08d5046aa8a60"},{"code":"(fn [f xs]\n  (loop [xs xs r {}]\n    (if (empty? xs)\n      r\n      (let [x (first xs)\n            k (f x)]\n        (recur (rest xs) (assoc r k (conj (r k []) x)))))))","problem":63,"user":"53244c9de4b09d4e7a9b54db"},{"problem":63,"code":"(fn [f c]\n  (reduce (fn [memo item]\n            (let [v (f item)]\n              (if (contains? memo v)\n                (update-in memo [v] conj item)\n                (assoc memo v [item])))) {} c))","user":"53ae16e2e4b047364c044472"},{"code":"(fn [f xs] \n  (reduce \n   (fn [a x] (let [k (f x)] (assoc a k (conj (a k []) x))))\n   {} \n   xs))","problem":63,"user":"4e50ad74535dc968683fc4ec"},{"code":"#(apply merge-with (comp vec concat) (map hash-map (map %1 %2) (for [x %2] [x])))","problem":63,"user":"50a4f36be4b0344e360f3bc9"},{"problem":63,"code":"(fn grp-by [f xs]\n (reduce \n  (fn [acc x]\n   (let [v (f x)]\n    (merge-with into acc {v [x]})))\n  {}\n  xs))","user":"5bea3177e4b0f319e2d7ec81"},{"code":"(fn group \n  [f in]\n  (apply merge-with #(vec (concat %1 %2))\n   (map #(hash-map (f %) [%]) in)))","problem":63,"user":"5300b750e4b0d8b024fd3711"},{"code":"(fn rc [f coll]\n  (loop [c coll i (first c) r {}]\n    (if (not= nil i)\n      (recur (rest c) (first (rest c)) (assoc r (f i) (if (= nil (r (f i)))\n                                                          (vector i)\n                                                          (assoc-in (r (f i)) (vector  (count (r (f i)))) i))))\n      r)))","problem":63,"user":"4ef2eb4d535dced4c769f226"},{"problem":63,"code":"(fn [func coll]\n  (loop [xmap {} \n         rem-coll coll]\n    (if (empty? rem-coll)\n      xmap\n      (let [i (first rem-coll)\n            k (func i)]\n        (recur (assoc xmap k \n                 (conj (get xmap k []) i))\n               (rest rem-coll))))))","user":"547fbe01e4b0c51c1f4d7321"},{"code":"(fn gb [f l] (reduce \n  (fn [acc v] \n    (let [fv (f v) h (get acc fv)]\n      (if (nil? h)\n        (assoc acc fv [v])\n        (assoc acc fv (conj h v))\n      )\n    )\n  )\n  {} \n  l))","problem":63,"user":"4e9d6a65535dbda64a6f6b87"},{"problem":63,"code":"(fn my-group [f coll]\n      (reduce\n       (fn [new-map val]\n           (merge-with into new-map {(f val) [val]}))\n       {}\n       coll))","user":"5da05bcce4b000c986472bd0"},{"problem":63,"code":"(fn [f col]\n     (reduce (fn [m v]\n               (let [key (f v)\n                     old (get m key [])]\n                 (assoc m key (conj old v))))\n             {}\n             col))","user":"5745bb9fe4b009280f9f2b54"},{"code":"#(reduce (partial merge-with into) {}\n         (map (fn [x] {(%1 x) [x]}) %2))","problem":63,"user":"4e4ad154535dc968683fc4d1"},{"problem":63,"code":"(fn [f s]\n   (reduce\n    (fn [acc cur]\n      (assoc acc (cur 0)\n             (if (acc (cur 0))\n               (conj (acc (cur 0)) (cur 1))\n               [(cur 1)])))\n    {} \n    (mapcat (fn [e] [[(f e) e]]) s)))","user":"5fa80c01e4b0fa27300f3de2"},{"code":"(fn [f c] (reduce #(into % {(f %2) (conj (% (f %2) []) %2)}) {} c))","problem":63,"user":"4f83665ee4b033992c121c1c"},{"problem":63,"code":"(fn [f coll]\n  (let [values (set (map f coll))]\n      (into {}\n            (for [v values]\n              {v (filter #(= v (f %)) coll)}))))","user":"53f053ebe4b0742d9025b0d3"},{"problem":63,"code":"(fn [func coll]\n  (reduce #(let [re (func %2)]\n             (assoc %1 re (if (contains? %1 re) \n                            (conj (%1 re) %2)\n                            [%2])))\n          {}\n          coll))","user":"554b8572e4b0a04f79299589"},{"problem":63,"code":"(fn group_by\n  ; Given a function f and a sequence s, write a function which returns a map. The keys should be the values of f applied to each item in s. The value at each key should be a vector of corresponding items in the order they appear in s.\n  [func sq]\n  (reduce (fn [m i]\n            (assoc m\n              (func i)\n              (conj (m (func i) []) i))) {} sq))","user":"5bbbd077e4b0a20761a23615"},{"code":"(fn [f v] \n  (loop [grouped {}\n         values v]\n   (if (empty? values)\n     grouped\n     (let [[head & tail] values]\n       (recur \n        (assoc grouped (f head) (conj (grouped (f head) []) head))\n        tail)))))","problem":63,"user":"538c3424e4b0b51d73faae58"},{"code":"#(reduce \n  (fn [r x] \n    (let [k (% x)] \n      (assoc r k (conj (get r k []) x)))) \n  {} %2)","problem":63,"user":"517bc969e4b07ef0e56148d0"},{"code":"(fn [f coll]\n  (reduce #(let [k (f %2)]\n    (assoc %1 k (conj (get %1 k []) %2)))\n    {} coll))","problem":63,"user":"4e521cef535d302ef430da6d"},{"code":"(fn bcg [f s]\r\n  (let [ret (map (fn [n] { (f n) n}) s)\r\n        aaa (clojure.set/union (set (map #(apply key %) ret)))\r\n        ]\r\n    (into {} (map (fn [c] {c (map (fn [b] (apply val b)) (filter (fn [a] (= (apply key a) c)) ret))}) aaa))))","problem":63,"user":"4fab31a8e4b081705acca215"},{"problem":63,"code":"(fn grp-seq [func vals] (into {} (map #(vector (func (first %)) (vec %)) (partition-by func (sort vals)))))","user":"589c0475e4b00487982d5351"},{"problem":63,"code":"(fn my-group-by [f coll]\n  (loop [acc {}\n         [x & xs] (reverse coll)]\n    (if (nil? x)\n      acc\n      (let [fn-res (f x)]\n        (recur (update-in acc [fn-res] (fn [old-coll] (conj old-coll x))) xs)))))","user":"561d8936e4b064ca9f4b16b2"},{"code":"(fn \n  [f col]\n  (loop [xs col m {}]\n    (if (empty? xs) m\n        (let [x (first xs)\n              fx (f x)\n              v (m fx)]\n          (if v\n            (recur (rest xs) (assoc m fx (conj v x)))\n            (recur (rest xs) (assoc m fx (vector x))))))))","problem":63,"user":"4fadbc3fe4b081705acca23f"},{"code":"(fn [f s] (reduce (fn [acc v] (let [k (f v) g (get acc k [])]\n  (assoc acc k (conj g v)))) {} s))","problem":63,"user":"4effb663535dcb61093f6a2e"},{"problem":63,"code":"(fn my-group-by [f se]\n      (reduce (fn [m e] ( let [akey (f e)]\n                 (if (m akey) \n                  (update-in m [akey] conj e )\n                  (assoc m akey (vector e )) ) ) ) {} se)\n  )","user":"558bdcefe4b0277789237633"},{"problem":63,"code":"(fn my-group-by\n  [f s]\n    (reduce\n     #(assoc % (first %2) (conj (get % (first %2) []) (second %2)))\n     {}\n     (map list (map f s) s))\n  )","user":"54965534e4b0b312c081ff65"},{"problem":63,"code":";; in newer Clojure use update, not update-in\n#(reduce (fn [m i] (update-in m [(%1 i)] (fnil conj []) i)) {} %2)","user":"4db2eac3535df7e46ed9b6c8"},{"problem":63,"code":"(fn [f szn]\n  (let [results (distinct (map f szn))\n        result-vals (for [r results]\n                      (filter #(= (f %) r) szn))]\n    (zipmap results result-vals)))","user":"60264d89e4b0d5df2af2222d"},{"code":"(fn [f s]\n   (let [parted (map vec (partition-by f (sort-by f s)))]\n     (zipmap\n       (map (comp f first) parted)\n       parted)))","problem":63,"user":"50f1dedbe4b0897c4366dcd8"},{"code":"(fn [f s]\r\n  (let [keys (set (map f s))]\r\n    (apply hash-map\r\n     (interleave keys\r\n\t\t(for [i keys]\r\n\t\t  (vec (filter #(= (f %) i) s)))))))","problem":63,"user":"4ee9d697535d93acb0a66895"},{"problem":63,"code":"#(reduce\n  (fn [m i]\n    (merge-with concat m {(%1 i) [i]}))\n  {} %2)","user":"58247423e4b051871117bec5"},{"code":"(fn [f s] \n  (reduce #(if (contains? %1 (f %2)) \n             (assoc %1 (f %2) (conj (%1 (f %2)) %2))\n             (assoc %1 (f %2) [%2]))\n          {}\n          s))","problem":63,"user":"51b24defe4b02f8f128bb963"},{"problem":63,"code":"(fn [f col]\n  (apply merge-with concat\n         (map (fn [x] {(f x) [x]}) col)))","user":"5a12dea3e4b04bbd27e6da44"},{"code":"(fn grseq [f s]\n  (if (empty? s)\n    {}\n    (merge-with concat {(f (first s)) [(first s)]} (grseq f (rest s)))))","problem":63,"user":"4fc50bcbe4b081705acca375"},{"problem":63,"code":"(fn [f sq]\n  (reduce (fn [s e] (let [o (f e)] (assoc s o (conj (get s o []) e)))) {} sq)\n)","user":"53ea72b6e4b036ad0777e4e5"},{"code":"#(->> %2\r\n  (sort-by %)\r\n  (partition-by %)\r\n  (mapcat (fn [v] [(% (first v)) v]))\r\n  (apply assoc {}))","problem":63,"user":"50336c6be4b0c6c1199c710f"},{"problem":63,"code":"(fn mygroupby[f s]\n  (loop [[head & tail :as in] s\n         out {}]\n      (cond (empty? in) out\n            :else (let [v (f head)\n          \t\t\t\tcur (or (get out v) [])]\n                    (recur tail (conj out [v (conj cur head)]))))))","user":"5472cba1e4b094393f72dd7a"},{"problem":63,"code":"(fn my-group [fnc vec]\n   (reduce (fn [x y] (if (nil? x) (assoc {} (fnc y) [y])\n                                  (if (contains? x (fnc y))\n                                    (assoc x (fnc y) (conj (get x (fnc y)) y))\n                                    (assoc x (fnc y) [y])))) nil vec))","user":"5508102ee4b021ccfedb96b0"},{"code":"(fn [f seq]\n  ((fn [s acc]\n     (if (empty? s)\n       (zipmap (keys acc) (map reverse (vals acc)))\n       (let [key (f (first s))]\n         (recur (rest s) (assoc acc key\n                                (cons (first s) (get acc key []))))))) seq (hash-map)))","problem":63,"user":"4ff355a1e4b0678c553fc34d"},{"code":"(fn [f v] \n  (reduce \n   #(assoc %1 (f %2) (vec (conj (get %1 (f %2)) %2))) \n   {} \n   v))","problem":63,"user":"529dfc6de4b04e0c58e87b8a"},{"problem":63,"code":"(fn  [f vals]\n  (into {}\n        (map #(vector (f (first %)) (vec %))\n             (partition-by f (sort vals))\n             )\n        )\n  )","user":"60337f1fe4b0d5df2af222c1"},{"problem":63,"code":"(fn [user_func val]\n    (loop [vlist val\n           result {}]\n        (if (empty? vlist)\n            result\n            (let [ur (user_func (first vlist))]\n                (if (contains? result ur)\n                    (recur (rest vlist) (assoc result ur (conj (result ur) (first vlist))))\n                    (recur (rest vlist) (assoc result ur [(first vlist)]))\n                )\n            )\n        )\n    )\n)","user":"5bfcdc52e4b0bdcf453d15f4"},{"problem":63,"code":"(fn[f s] (reduce (fn[m i]\n                   (let[k (f i)]\n                     (assoc m k (if (m k) (conj (m k) i) [i])))) \n                 {} s))","user":"57b3efb1e4b0fbc9809a278a"},{"problem":63,"code":"#(reduce (fn [result val]\n            (let [fv (%1 val)]\n              (assoc result fv (conj (get result fv []) val)))) {} %2)","user":"57d0cd58e4b0bd073c20235e"},{"code":"(fn [f s]\n         (reduce (fn [m v]\n                   (if (contains? m (f v))\n                     (update-in m [(f v)] #(conj % v))\n                     (assoc m (f v) [v])))\n                 {} s))","problem":63,"user":"5294e44de4b02ebb4ef75016"},{"problem":63,"code":"(fn [f s] (reduce #(let [r (f %2), v (get %1 r [])] (assoc %1 r (conj v %2))) {} s))","user":"5e3071abe4b05b4b01516213"},{"code":"(fn [f s] (loop [sq (map #(vector (f %) %) s) r {}]\n               (if (empty? sq)\n                 r\n                 (if (contains? r (first (first sq)))\n                   (recur (rest sq)\n                          (assoc (dissoc r (first (first sq)))\n                            (first (first sq))\n                            (conj (get r (first (first sq)))\n                                    (last (first sq)))))\n                   (recur (rest sq)\n                          (assoc r\n                            (first (first sq)) (vector (last (first sq)))))))))","problem":63,"user":"4ebef65e535dfed6da9c6d9b"},{"problem":63,"code":"#(loop [m {}, [h & t] %2]\n      (if (nil? h)\n           m\n          (let [k (% h), v h] \n            (recur (assoc m k\n                    (if (contains? m k)\n                        (conj (m k) v)\n                        [v])) \n                 t))))","user":"548b7db8e4b0e286459a11fd"},{"problem":63,"code":"(fn my-group-by [f xs]\n  (reduce (fn [m v]\n            (update-in m [(f v)] (fnil conj []) v))\n          {} xs))","user":"58e37946e4b005f69f193cae"},{"problem":63,"code":"(fn [f xs] (reduce\n             #(assoc %1 (f %2) (conj  (get %1 (f %2) []) %2) )\n             {} xs))","user":"548cd813e4b0e286459a1211"},{"problem":63,"code":"(fn [f lst]\n  (loop [lst lst\n         result {}]\n    (if (empty? lst)\n      result\n      (let [[h & t] lst\n            hh (f h)]\n        (recur (filterv #(not= hh (f %)) lst)\n               (assoc result hh (filterv #(= hh (f %)) lst)))))))","user":"5895477fe4b00487982d527c"},{"code":"(fn my-group-by [f coll]\n  (apply merge-with concat\n         (map #(hash-map (f %) [%]) coll)))","problem":63,"user":"530578ede4b0d8b024fd3760"},{"problem":63,"code":"(fn [f coll]\n  (reduce \n   (fn [ret x]\n     (let [k (f x)]\n       (assoc ret k (conj (get ret k []) x))\n       )\n     ) \n   {} coll)\n  )","user":"5510d948e4b06e50f9beb18d"},{"problem":63,"code":"(fn [f arr]\n    (loop [coll (for [a arr] [(f a) a])\n           result {}]\n      (let [c (first coll)\n            k (first c)\n            v (last c)]\n        (if (seq coll)\n          (recur (next coll)\n                 (if (contains? result k)\n                   (update-in result [k] conj v)\n                   (assoc result k [v])))\n          result))))","user":"5eff339ae4b0cf489e8d7f0c"},{"problem":63,"code":"(fn [f coll]\n  (reduce (fn [res x]\n            (let [val (f x)]\n              (assoc res val (conj (vec (get res val)) x)))) {} coll\n  )\n)","user":"5a1c3c11e4b0ff51aa4b323d"},{"problem":63,"code":"(fn [f s]\n  (let [t (for [e s] {(f e) [e]})]\n    (apply merge-with concat t)))","user":"57458b82e4b009280f9f2b4e"},{"code":"(fn [f s]\n  (apply\n   merge-with\n   concat\n   (map\n    (fn [x] (hash-map (f x) [x]))\n    s\n    )\n   )\n  )","problem":63,"user":"52586d24e4b0cb4875a45cb0"},{"problem":63,"code":"(fn -group-by [f xs]\n  (apply merge-with concat (mapv #(hash-map (f %) [%]) xs)))","user":"55fb58b2e4b0f488688e0661"},{"code":"(fn [f s]\n  (let [k (set (map f s))]\n    (zipmap k (map #(filter (fn [x] (= % (f x))) s) k))))","problem":63,"user":"4f725201e4b07046d9f4f02f"},{"code":"(fn my-group-by\n  ([ifn iseq] (my-group-by ifn iseq {}))\n  ([ifn iseq omap]\n     (cond\n      (empty? iseq) omap\n      :else (recur ifn\n                   (rest iseq)\n                   (update-in omap [(ifn (first iseq))] #(conj (vec %1) %2) (first iseq))))))","problem":63,"user":"4eee3e6a535d93acb0a668c3"},{"problem":63,"code":"(fn [f l]\n  (loop [ans {} tmpl l]\n    (if (empty? tmpl)\n      ans\n      (if (contains? ans (f (first tmpl)))\n        (recur (assoc ans (f (first tmpl)) (reverse (conj (reverse (get ans (f (first tmpl)))) (first tmpl) ))) (rest tmpl))\n        (recur (assoc ans (f (first tmpl)) (list (first tmpl))) (rest tmpl))))))","user":"59368ccae4b02506e01a297a"},{"problem":63,"code":"(fn [f s]\n  (reduce (fn [acc x]\n            (let [y (f x)]\n              (if (contains? acc y)\n                (update-in acc [y] conj x)\n                (assoc acc y [x]))))\n          {}\n          s))","user":"549c6792e4b0f3d1d8e70f8b"},{"code":"(fn [f s]\n    (reduce (fn [m e] (assoc m (f e) (conj (get m (f e) []) e))) {} s))","problem":63,"user":"4f77b68de4b0fbe0118ec581"},{"code":"#(reduce (fn[acc,e](let[k (%1 e), v (acc k)]\n                  (if(nil? v)(assoc acc k [e])\n                             (assoc acc k (conj v e))\n                  ))\n          )\n  {} %2\n)","problem":63,"user":"4ec75829535d6d7199dd36e1"},{"code":"(fn [f s]\n  (loop [s1 s r {}]\n    (if (empty? s1)\n      r\n      (let [v (first s1)\n            k (f v)\n            a (r k)]\n        (recur (rest s1) (assoc r k (conj (if (nil? a) [] a) v)))))))","problem":63,"user":"52c81954e4b0c2d177d6212e"},{"problem":63,"code":"(fn [f xs] (into {} (map #(vector (f (first %)) (vec %)) (partition-by f (sort xs)))))","user":"52b89d55e4b07a9af57922b3"},{"problem":63,"code":"#(apply merge-with concat (for [c %2] {(%1 c) (list c)}))","user":"5412646de4b01498b1a719d4"},{"problem":63,"code":"(fn [f coll] (reduce #(let [key (f %2)\n                                     cv (%1 key)]\n                                      (assoc %1 key (if (nil? cv) (conj [] %2) (conj cv %2)))) {} coll))","user":"5839f079e4b089d5ab817d48"},{"problem":63,"code":"(fn [f coll] (reduce\n            (fn [a b]\n              (update-in a\n                     [(f b)]\n                     (fnil conj []) b))\n            {}\n            coll))","user":"5666500ee4b0e91d5f5c566d"},{"problem":63,"code":"(fn [x y] (apply merge-with concat (map #(identity {(x %) [%]}) y)))","user":"54349368e4b0b6b47310fcf1"},{"problem":63,"code":"(fn [f l]\n  ((fn blah [r a]\n    (if (= r '())\n      a\n      (let [v (apply f (first r) '())\n            h (get a v)]\n        (recur (rest r) (assoc a v (reverse (conj (reverse (or (get a v) [])) (first r)))))))) l {}))","user":"53aaaf7ae4b047364c044444"},{"problem":63,"code":"(fn [f s]\n  (reduce #(merge-with concat %1 %2) (map #(hash-map (f %) [%]) s)))","user":"5486adf7e4b0e286459a11be"},{"problem":63,"code":"(fn [f coll]\n  (loop [c coll final {}]\n    (if (empty? c)\n      final\n      (let [[el & rmg] c \n          \tk (f el)]\n        (recur rmg (assoc final k (concat (get final k) [el])))))))","user":"587294f0e4b01531a375ea1e"},{"problem":63,"code":"(fn\n  [f s]\n  (loop [r {} s s]\n    (if (empty? s)\n      r\n      (let [k (f (first s))]\n        (recur (assoc r k (conj (get r k []) (first s))) (rest s))))))","user":"5af907e6e4b0cc2b61a3bcda"},{"problem":63,"code":"(fn [f sq]   \n  (loop [s sq, hsh {}]\n    (if (empty? s) hsh\n      (let [hval (first s)\n            hkey (f hval)\n            v3c  (conj (get hsh hkey []) hval)]\n      \t(recur (rest s) (assoc hsh hkey v3c) \n)))))","user":"54bbe505e4b0ed20f4ff6ec5"},{"problem":63,"code":"(fn group-sequence\n  [f coll]\n  (reduce (fn [m x]\n            (let [f-x (f x)]\n              (assoc-in m [f-x] (into [] (conj (m f-x) x)))))\n          {}\n          coll))","user":"5501a1e1e4b07d26eda61d75"},{"code":"#(apply merge-with into\n        (for [x %2]\n          {(% x) [x]}))","problem":63,"user":"4dabb7b1950ed6eda1bd72f3"},{"problem":63,"code":"(fn [f coll]\n  (apply array-map\n          (mapcat #(vector (f (first %)) %)\n               (partition-by f (sort-by f coll)))))","user":"56fbf83de4b07572ad1a88da"},{"code":"(fn [f c]\n  (reduce\n    #(update-in %\n                [(f %2)]\n                conj\n                %2)\n    {}\n    (reverse c)))","problem":63,"user":"4fd2789ee4b04c3a95aa0422"},{"problem":63,"code":"(fn my-group-by [f s]\n  (reduce (fn [m v]\n            (let [k (f v)\n                  vals (or (m k) [])]\n              (assoc m k (conj vals v))))\n          {}\n          s))","user":"57609d91e4b08062f99a4e9b"},{"problem":63,"code":"(fn my-group-by [fun col]\n  (->> col\n       (map (fn [x] [(fun x) x]))\n       (reduce (fn [acc x] (update-in acc [(first x)] concat (list (second x)))) {})))","user":"5d49ec5ee4b0776584bd6f1c"},{"problem":63,"code":"(fn [f a]\n  (reduce\n   (fn [ans n]\n     (let [res (f n)]\n     (if (contains? ans res)\n        (assoc ans res (conj (ans res) n))\n        (assoc ans res [n])\n     )))\n   {} a))","user":"5744723ae4b009280f9f2b3a"},{"code":"(fn mygroup [fun coll]\n  (reduce #(assoc % (fun %2) (conj (apply vector (% (fun %2))) %2)) {} coll))","problem":63,"user":"518ad8fce4b06da86c1973c1"},{"problem":63,"code":"(fn [f s]\n      (apply (partial merge-with into)\n             (map (fn [v] {(f v) [v]}) s))\n      )","user":"5d236215e4b02ea6f0fb6a09"},{"problem":63,"code":"(fn [f c] (reduce (fn [m i] (update-in m [(f i)] #(conj (vec %) i))) {} c))","user":"559b2ad1e4b066d22e731f4e"},{"problem":63,"code":"(fn my-group-by [f seq] (let [cond-seq (for [x seq]  [(f x) x])]\n                            (reduce (fn [themap [condition value]]\n                                      (if (get themap condition)\n                                          (assoc themap condition\n                                                 (conj (get themap condition) value))\n                                          (assoc themap condition (conj [] value)))) {} cond-seq)))","user":"554bc64ae4b0a04f79299598"},{"problem":63,"code":"(fn group-seq\n  [f s]\n  (apply merge-with concat (map #(hash-map (f %) (vector %)) s)))","user":"57f8153de4b0d3187e900916"},{"problem":63,"code":"(fn [f coll]\n  (reduce (fn [m item]\n            (let [k (f item)]\n              (assoc m k (conj (m k []) item))))\n          {}\n          coll))","user":"53576356e4b04ce2eb3ed27a"},{"problem":63,"code":"(fn foo [f v]\n  (reduce \n   #(let [u (f %2)] \n      (assoc %1 u (conj (%1 u []) %2))) {} v))","user":"561f9110e4b064ca9f4b16ce"},{"code":"(fn group-seq\n  [f coll]\n  (apply merge-with concat (map #(hash-map (f %) [%]) coll)))","problem":63,"user":"5339af7de4b0e30313ee6cab"},{"problem":63,"code":"(fn my-group-by [f s]\n  (apply (partial merge-with concat {}) (map #(hash-map (f %) [%]) s)))","user":"5cdc08a2e4b05ee0cb31173a"},{"problem":63,"code":"(fn my-group-by\n  [f coll]\n  (reduce\n    (fn [result x]\n      (let [key (f x)]\n        (assoc result key (conj (get result key []) x))))\n    {}\n    coll))","user":"6098263be4b00e9e6653c3f9"},{"code":"(fn g [f c]\r\n  (reduce \r\n    #(assoc % (first %2) (conj (vec (get % (first %2))) (second %2))) \r\n    {} \r\n    (map #(list (f %) %) c)))","problem":63,"user":"4facff22e4b081705acca230"},{"code":"(fn [f c]\n  (into {} (map (fn [x]\n                  [(f (first x)) (vec x)])\n                (partition-by f (sort-by f c)))))","problem":63,"user":"52951156e4b02ebb4ef7501b"},{"problem":63,"code":"(fn group-by2 [f s]\n  (loop [s s\n         acc {}]\n    (if (empty? s)\n      acc\n      (let [[v & more] s\n            k (f v)]\n        (if (acc k)\n          (recur more\n                 (assoc acc k (conj (acc k) v)))\n          (recur more\n                 (assoc acc k [v])))))))","user":"601004d6e4b074f607df66b2"},{"problem":63,"code":"(fn [f coll]\n   (reduce\n    (fn [acc x] \n      (let [val (f x)]\n        (assoc acc val (conj (get acc val []) x))))\n    {} coll))","user":"51bd255ce4b0df1216cefd94"},{"code":"(fn [f l]\n  (into {} \n        (for [i (set (map f l))]\n          (vector i (vec (filter #(= i (f %)) l))))))","problem":63,"user":"5102489de4b00c483ae176f6"},{"problem":63,"code":"(fn [f coll]\n  (reduce\n   (fn [res x]\n     (let [val (f x)]\n       (assoc res val (conj (get res val []) x))))\n   {}\n   coll))","user":"4ea8570f535d7eef308072f8"},{"code":"(fn [f coll]\n  (let [values (into #{} (map f coll))]\n    (zipmap values (map (fn [v] (filter #(= v (f %)) coll)) values))))","problem":63,"user":"50052fd0e4b0678c553fc45d"},{"problem":63,"code":"#(reduce (fn [col [k v]] (assoc col k (conj (get col k []) v))) {} (map (fn [x] [(%1 x) x]) %2))","user":"594d4c57e4b07ddc2dafae87"},{"code":"(fn [f c]\n  (reduce #(assoc % \n                  (f %2) \n                  (conj (get % (f %2) []) %2))\n          {}\n          c))","problem":63,"user":"4ef49c2c535dced4c769f238"},{"problem":63,"code":"(fn foo [f s]\r\n  (apply \r\n    (partial merge-with concat)\r\n    (for [x s] {(f x) [x]})))","user":"606e0a42e4b069485764de19"},{"problem":63,"code":"(fn [gfn coll]\n  (reduce \n   (fn [grouped-map item]\n     (update-in grouped-map [(gfn item)] #(conj (or % []) item))\n     )\n   {} coll)\n  )","user":"60436423e4b02d28681c77a3"},{"problem":63,"code":"(fn [f arg]\n (->> arg\n      (map #(list (f %) %))\n      (reduce #(update-in %1 [(first %2)] (fnil conj []) (second %2)) {})))","user":"5711b532e4b09c608db70449"},{"problem":63,"code":"(fn [f c]\n   (reduce\n    (fn [coll v]\n      (assoc coll\n             (f v)\n             (conj\n              (vec ( coll (f v)))\n              v) ))\n    {}\n    c))","user":"51e7c1f1e4b0a3e081b8cbef"},{"code":"#(reduce (fn [a b] (assoc a (%1 b) (concat (a (%1 b)) [b]))) {} %2)","problem":63,"user":"51f4d46ee4b0fca5e8b48243"},{"problem":63,"code":"(fn [f vs]\n    (loop [f f vs vs acc {}]\n      (if (empty? vs)\n        acc\n        (let [k (f (first vs))]\n          (if (contains? acc k)\n            (let [orig (get acc k)]\n              (recur f (rest vs) (assoc acc k (conj orig (first vs)))))\n            (recur f (rest vs) (assoc acc k [(first vs)])))))))","user":"551a21ece4b091ff45eda993"},{"code":"(fn [f coll]\n  (reduce\n    (fn [result value]\n      (let [key (f value)\n            values (get result key [])]\n        (assoc result key (conj values value))))\n    {}\n    coll))","problem":63,"user":"4f0b2028535d0136e6c222ff"},{"code":"#(loop [vs (vec %2) m {}]\n  (if (empty? vs)\n    m\n    (let [v (first vs) k (%1 v)] \n      (recur \n        (rest vs)\n        (assoc m k \n          (if (contains? m k)\n            (conj (m k) v)\n            [v]))))))","problem":63,"user":"4fbacdbae4b081705acca2e5"},{"problem":63,"code":"(fn [f -seq]\n  (reduce (fn [res el]\n            (let [-key (f el)]\n              (assoc res -key (if (contains? res -key)\n                                (conj (get res -key) el)\n                                (conj [] el)))))\n          {}\n          -seq))","user":"5ddb6151e4b0948ae9d9adb0"},{"code":"(fn [f s]\n  (reduce\n   (fn [s i]\n     (let [v (f i)]\n       (assoc s\n         v\n         (conj\n          (s v [])\n          i))))\n   {}\n   s))","problem":63,"user":"4e781a2e535d324fb2983d74"},{"code":"(fn [pred coll]\n  (reduce (fn [m x]\n    (let [k (pred x)]\n      (assoc m k (conj (get m k []) x))))\n    {} coll))","problem":63,"user":"4ea1b9e4535d7eef308072b8"},{"problem":63,"code":"(fn [f s]\n  (reduce (fn [r i]\n            (let [k (f i)\n                  n (concat (get r k) [i])]\n              (assoc r k n)))\n          {} s))","user":"54df2609e4b024c67c0cf7a9"},{"problem":63,"code":"(fn [f s]\n  (reduce (fn [acc v]\n            (assoc acc (f v) (conj (get acc (f v) []) v)))\n          {}\n          s))","user":"55469eede4b0a04f79299542"},{"problem":63,"code":"(fn my-group-by\n  ([f vals]\n   (my-group-by f vals {}))\n  ([f vals ret-map]\n    (let [fir (first vals)\n          r (rest vals)]\n      (if fir\n        (recur f r (assoc ret-map (f fir) (concat (get ret-map (f fir)) [fir])))\n        ret-map))))","user":"5b107263e4b0cc2b61a3be22"},{"problem":63,"code":"(fn [f xs]\n  (let [grouped (hash-map)]\n    (reduce #(let [key (f %2)]\n               (if (contains? % key)\n                 (let [new-content (conj (get % key) %2)]\n                   (assoc % key new-content))\n                 (assoc % key [%2]))) grouped xs)))","user":"53528cd3e4b084c2834f4af2"},{"code":"(fn [f s] \n  (reduce #(assoc %1 (f %2) (conj (get %1 (f %2) []) %2)) {} s))","problem":63,"user":"52bf0116e4b07a9af5792328"},{"problem":63,"code":"(fn [f v](loop [m {} f f v v]\n               (let [va (first v)]\n           \t\t(if (empty? v) \n                 m\n                 (recur (assoc m (f va) \n                               \n                        (if (= (m (f va)) nil)\n                          (vector va)                          \n                          (conj (m (f va)) va))) \n                        f \n                        (rest v))))))","user":"54ecd7dde4b024c67c0cf85c"},{"code":"(fn [f coll] \r\n  (reduce (fn [result v] (let [k (f v)\r\n                 c (get result k [])]\r\n               (assoc result k (conj c v)))) {} coll))","problem":63,"user":"4def301c535d08e6dec9fe12"},{"problem":63,"code":"(fn [f xs]\n  (reduce (fn [col item] (assoc col (f item) \n                           (conj (vec (get col (f item))) item))) {} xs))","user":"521ceb02e4b0c4ef0be830a5"},{"code":"(fn ! [f sq]\n  (loop [s sq m (zipmap (distinct (map f (map first (partition-by f sq)))) (repeat []))]\n    (if (empty? s) m\n        (let [e (first s) er (f e)]\n          (recur (rest s) (assoc m er (conj (get m er) e)))))))","problem":63,"user":"4e7d1c22535db169f9c796c5"},{"problem":63,"code":"(fn [f values]\n  ((fn [values accu]\n     (if (empty? values)\n       accu\n       (let [key (f (first values))]\n         (recur (rest values) (assoc accu key (conj (accu key []) (first values))))\n       )\n     )\n  ) values {})\n)","user":"53ecd01fe4b0d648e757f4b9"},{"problem":63,"code":"(fn [f s]\n   (->> (for [v s] {(f v) [v]})\n        (apply merge-with into)))","user":"5c435a9fe4b0e06e1360a367"},{"code":"#(loop [o %2 r {}]\r\n     (if (empty? o)\r\n       r\r\n       (recur (rest o) (assoc r (%1 (first o)) (vec (conj (r (%1 (first o))) (first o)))))))","problem":63,"user":"4e5a3891535d8a8b8723a2aa"},{"problem":63,"code":"(fn [f coll] (reduce (fn [res e] (update-in res [(f e)] #(conj (vec %) e))) {} coll))","user":"57642916e4b0994c1922fbee"},{"problem":63,"code":"(fn [f s]\n  (loop [s s r {}]\n    (if (empty? s)\n      r\n      (let [value (first s) \n            key (f value)\n            oldValue (r key)\n            newValue (concat oldValue [value])]\n        (recur (rest s) (assoc r key newValue))))))","user":"4fc34787e4b081705acca33e"},{"problem":63,"code":"(fn vi [f col]\n  (if (empty? col)\n    {}\n    (let [m (vi f (rest col)) k (f (first col))] (assoc m k (conj (m k) (first col))))))","user":"56800ba1e4b0966858e4d8e8"},{"code":"(fn gb [f xs]\n  (reduce #(assoc %1 (f %2) (conj (get %1 (f %2) []) %2)) {} xs))","problem":63,"user":"504e13fce4b078edc5f593bc"},{"problem":63,"code":"(fn [f s]\n  (reduce (fn [ret x]\n            (let [k (f x)]\n              (assoc ret k (conj (get ret k []) x)))) {} s))","user":"5195fadee4b04c0af7ff3c11"},{"code":"(fn [f c]  \n   (reduce\n      #(let [k (f %2)]\n        (assoc %1 k (conj (get %1 k []) %2)))\n    {} c))","problem":63,"user":"4e6ebd4a535d5021c1a89610"},{"problem":63,"code":"(fn myGrpby [f s] ;; this is brute force - should refactor to only traverse the coll once...\n  (let [ks (set (map f s))]\n    (into {} (map (fn [k] {k (filter #(= k (f %)) s)}) ks))))","user":"599342efe4b0b211ea3aaab0"},{"problem":63,"code":"#(loop [sq %2, ret {}]\n   (if (empty? sq)\n     ret\n     (recur (rest sq) (assoc ret (%1 (first sq)) (conj (ret (%1 (first sq)) []) (first sq))))))","user":"55fc07d3e4b0f488688e066e"},{"problem":63,"code":"(fn [f xs] (into {} (for [i xs\n      ][(f i) (for [j xs :when (= (f i) (f j))] j)])))","user":"5fa358a1e4b0f0ebd91b77fd"},{"problem":63,"code":"(fn [f a]\n  (reduce\n    (fn [my-hash i]\n      (if (nil? (get my-hash (f i)))\n        (assoc my-hash (f i) [i])\n        (update-in my-hash [(f i)] #(conj % i))))\n    {}\n    a))","user":"546e4ab8e4b00cfc9eacc19c"},{"problem":63,"code":"#(apply merge-with concat \n       (map (fn [item] \n              (hash-map (%1 item) [item]))\n        %2))","user":"5410499de4b01498b1a719a6"},{"code":"(fn foo [f lst]\n  (if (= lst ())\n    {}\n    (if (nil? (get (foo f (rest lst))\n                  (f (first lst))))\n        (assoc (foo f (rest lst)) \n                (f (first lst))\n                (vector (first lst)))\n        (assoc (foo f (rest lst)) \n                (f (first lst))\n                (cons (first lst) (get (foo f (rest lst)) (f (first lst))))\n      )\n    )\n  ))","problem":63,"user":"50ae5659e4b0a40c9cfb08d2"},{"problem":63,"code":"(fn[f s] \n      (loop [sx s acc {}]\n            (if-let [a (first sx)] \n                (recur (rest sx) (into acc [[(f a) (into (vec(get acc (f a))) [a])]]))\n                acc)))","user":"56483f45e4b0284900eef62b"},{"code":"(fn [test-fn coll]\n    (when (seq coll)\n      (reduce (fn [acc item]\n                (let [result (test-fn item)]\n                  (if (contains? acc result)\n                    (update-in acc [result] #(conj % item))\n                    (assoc acc result [item]))))\n              {} coll)))","problem":63,"user":"51f40975e4b0fca5e8b4822e"},{"code":"(fn [f coll] (reduce #(merge-with concat %1 {(f %2) [%2]}) {} coll))","problem":63,"user":"531f7a2de4b08068f379edc6"},{"problem":63,"code":"(fn [f l] (apply merge-with concat (map #(array-map (f %) [%]) l)))","user":"5647dc44e4b0284900eef624"},{"code":"(fn [a b] (reduce (fn [x y] (let [z (a y)]\n                                     (if (contains? x z)\n                                       (assoc x z (conj (get x z) y))\n                                       (assoc x z [y]))))\n                         {}\n                         b))","problem":63,"user":"52c1bd29e4b07a9af579236a"},{"problem":63,"code":"(fn [f c] \n  (reduce #(assoc % (f %2) \n             (conj (% (f %2) []) %2)) \n          {} c))","user":"539f4e9ee4b0ca733b974498"},{"problem":63,"code":"(fn [f xs]\n    (reduce\n     #(merge-with concat %1 {(f %2) [%2]})\n     {}\n     xs))","user":"5531e445e4b09218d5f44f76"},{"problem":63,"code":"(fn [f s]\n  (persistent!\n    (letfn [(get-group [m v] (get m (f v) []))\n            (update-group [m v] (assoc! m (f v) (conj (get-group m v) v)))]\n      (reduce update-group (transient {}) s))))","user":"55d6a2ebe4b0e31453f64a9a"},{"code":"(fn ryhmita [f l]\n  (let [vs (set (map f l))\n        kvs (map (fn [x] [x (vec (filter #(= x (f %)) l))]) vs)]\n    \n    (reduce #(assoc %1 (first %2) (first (rest %2))) {} kvs)\n    )\n  )","problem":63,"user":"5252cbe7e4b0541d1855b8d2"},{"code":"(fn [f coll]\n  (reduce\n    (fn [acc x]\n      (update-in acc [(f x)] (comp vec #(conj % x))))\n    {}\n    coll))","problem":63,"user":"4dc0ff08535d020aff1edf84"},{"problem":63,"code":"#(reduce (fn [a i]\n            (assoc a (% i)\n                   (conj (get a (% i) []) i))) {} %2)","user":"56a76f36e4b07966d5a8a05b"},{"problem":63,"code":"(fn mp [index f l]\n            (if (< index (count l))\n              (let [mpp (mp (inc index) f l) v (nth l index) k (f v)]\n                ;(println \"index\" index \"key\" k \"val\" v \"new list\" (conj (get mpp k []) v))\n                (assoc mpp k (sort (conj (get mpp k []) v)))\n                )\n              {})\n            ) 0","user":"5d974b1de4b0d3f9b434ad36"},{"problem":63,"code":"(fn [f coll] \n  (apply merge-with into \n         (map (fn [x] {(f x) [x]}) coll)))","user":"5a257747e4b07f18be40aa1f"},{"code":"(fn grp-by [f xs] \n  (loop [coll xs\n         result {}] \n    (if (empty? coll)\n      result\n      (if (contains? result (f (first coll))) \n        (recur (vec (rest coll)) (update-in result (vector (f (first coll))) #(conj % (first coll))))\n        (recur (vec (rest coll)) (assoc result (f (first coll)) (vector (first coll))))\n        )   \n      )   \n    )   \n  )","problem":63,"user":"5228f870e4b0186687e23a98"},{"code":"(fn [f coll]\n  (apply merge-with concat (for [elem coll] {(f elem) [elem]})))","problem":63,"user":"4fabbb97e4b081705acca21d"},{"problem":63,"code":"(fn [f coll]\n  (reduce #(assoc\n             %1\n             (f %2)\n             (conj (%1 (f %2) []) %2))\n          {}\n          coll))","user":"55f4ef68e4b06e875b46ce82"},{"problem":63,"code":"(fn [f x]\n    (letfn [(go [s a] \n                (if (seq s)\n                  (go (rest s) (update-in a \n                                          [(f (first s))]\n                                          #(vec (conj % (first s)))))\n                  a))]\n      (go x {})))","user":"5652f23ce4b0f9d632dd846b"},{"problem":63,"code":"(fn [f s] (reduce \n             (fn [m v] \n               (update-in m [(f v)] #(conj (or % []) v))) {} s))","user":"576aea4fe4b0a07e8fc18126"},{"code":"(fn this [f col] \n  (apply merge-with concat\n         (map #(hash-map %1 %2) \n              (map f col) \n              (map vector col))))","problem":63,"user":"4fb4303fe4b081705acca2ac"},{"problem":63,"code":"(fn group-sequence [f s]\n  (reduce (fn [acc x]\n            (let [k (f x)\n                  v (acc k)]\n              (if v\n                (assoc acc k (conj (acc k) x))\n                (assoc acc k [x]))))\n          {} s))","user":"5865c8f0e4b0f14aab7c884e"},{"problem":63,"code":"(fn gby [f s]\n (into {}\n (for [k (set (map f s))]\n   [k (vec (filter #(= k (f %)) s))])))","user":"5a4caa20e4b05d388ecb6b94"},{"problem":63,"code":"(fn [f coll]\n    (reduce\n     #(let [val (f %2)]\n        (assoc %1 val (conj (get %1 val []) %2)))\n     {}\n     coll))","user":"58bbcbc8e4b0888cdc949d00"},{"problem":63,"code":"(fn [f l]\n  (let [ks (map f l)]\n    (into {} (map vector ks (map (fn [k]\n                                  (filter #(= k (f %)) l)\n                                  )\n         \t\t\t\t\t\tks))\n    )))","user":"53aef31ce4b047364c04447b"},{"problem":63,"code":"(fn [by ls] (apply merge-with into (map #(do {(by %) [%]}) ls)))","user":"5fa416ece4b0f0ebd91b7803"},{"problem":63,"code":"(fn [f xs]\n  (apply merge-with into {}\n         (for [x xs] {(f x) [x]})))","user":"58cfbd7ae4b03c36ff7e58ba"},{"problem":63,"code":"(fn my-group [f coll]\n  (loop [x (first coll) xs (rest coll) acc {}]\n    (if (nil? x)\n      acc\n      (recur (first xs) (rest xs) \n             (let [result (f x) items (acc result)]\n               (if (nil? items)\n                 (conj acc [(f x) [x]])\n                 (conj acc [(f x) (into items [x]) ])\n               )\n             \n             )\n       )\n     )\n   )\n )","user":"568c2d96e4b0dcc4269f40af"},{"code":"(fn [f l]\n\t(letfn [(thurk [res el]\n\t\t\t\t(let [smock (f el)]\n\t\t\t\t\t(assoc res\n\t\t\t\t\t\t(f el)\n\t\t\t\t\t\t(vec (conj (res smock) el)))))]\n\t\t(reduce thurk {} l)))","problem":63,"user":"4f2baf1ae4b0d6649770a04c"},{"problem":63,"code":"(fn my-group-by [f seq]\n  (loop [res {}\n         s seq]\n    (if (empty? s)\n      res\n      (let [el (first s)\n            fel (f el)]\n        (if (contains? res fel)\n          (recur (assoc res fel (conj (get res fel) el)) (next s))\n          (recur (assoc res fel [el]) (next s)))))))","user":"5fada7cce4b08cb800c85af5"},{"code":"#(let [f % s %2] (persistent! (reduce (fn[rf rs](let [k (f rs)](assoc! rf k (conj (get rf k []) rs)))) (transient {}) s)))","problem":63,"user":"5138d08be4b0a5db03d727db"},{"problem":63,"code":"(fn [f sq]\n  (reduce (fn [a e]\n            (let [r (f e)]\n              (assoc a r (conj (get a r []) e)))) {} sq))","user":"5edd6eb7e4b0c7845d86b0f7"},{"code":"(fn [f s]\n    (reduce\n     (fn [m x]\n       (let [k (f x)]\n         (assoc m k (conj (get m k []) x))))\n     {} s))","problem":63,"user":"4e5be681535d8a8b8723a2bc"},{"problem":63,"code":"(fn [f x] \n  (apply merge-with concat \n         (map #(hash-map (first %) (last %)) (mapcat hash-map (map f x) (map vector x)))))","user":"56193c6ee4b053970a773af2"},{"code":"(fn [f s]\n  (reduce #(update-in % [(f %2)] (fnil conj []) %2) {} s))","problem":63,"user":"4e6a5a32535d8ccf87e9fed0"},{"code":"(new clojure.core$group_by)","problem":63,"user":"4e3b6bff535deb9a81d77f52"},{"problem":63,"code":"; (fn [f coll]\n;  (reduce #(assoc %1 (f %2) (conj (get %1 (f %2) []) %2)) {} coll))\n\n; (fn [f coll]\n;  (reduce (fn [acc v]\n;            (let [k (f v)\n;                  group (get acc (f v) [])]\n;              (assoc acc k (conj group v))))\n;          {} coll))\n\n(fn [f coll]\n  (reduce #(merge-with into %1 {(f %2) [%2]}) {} coll))","user":"5aa4f7dae4b0d174b936c88c"},{"problem":63,"code":";;update is added by 1.7\n(fn\n  [f s]\n  (loop [m {} s s]\n    (if (empty? s) m\n      (let [fir (first s)]\n        (recur (assoc m (f fir)\n                        (conj (vec (m (f fir))) fir))\n               (next s))))))","user":"56a36f76e4b0542e1f8d14ca"},{"problem":63,"code":"(fn my-group-by [f xs]\n  ; clojure.core/update is not available in 4clojure\n  (reduce #(assoc %1 (f %2) (conj (get %1 (f %2) []) %2)) {} xs))","user":"5d5e0259e4b0c9e5857d4fef"},{"code":"(fn [f l] (apply merge-with concat (map #(hash-map %1 [%2]) (map f l) l)))","problem":63,"user":"5210ac52e4b080a8d9b9d63e"},{"problem":63,"code":"(fn [f list]\n  (loop [l list\n         result {}]\n    (if (empty? l)\n      result\n      (let [value (first l)\n            key (f value)\n            values (or (result key) [])\n            newValues (conj values value)\n            newResult (conj result {key newValues})]\n        (recur (rest l) newResult)\n))))","user":"5954cea2e4b066ee0a44af0a"},{"problem":63,"code":"(fn grp-by [f coll]\n  (reduce #(merge-with concat %1 {(f %2) [%2]}) {} coll)\n)","user":"54a7d707e4b09f271ff37c9b"},{"code":";(fn [f, s]\n;     (loop [cur s, valdict {}]\n;       (if (seq cur)\n;         (let [h (first cur),\n;               val (f h)]\n;           (recur (rest cur)\n;                  (assoc valdict val\n;                         (concat (valdict val) [h]))))\n;         valdict)))\n\n(fn [pred s]\n  (->> s\n       (map (fn [x] {(pred x) [x]}))\n       (apply (partial merge-with concat))))","problem":63,"user":"4ee26f01535d10e5ff6f5368"},{"problem":63,"code":"(fn [func col]\n  (let [values (map func col)\n        grouped (for [v values] [v (filter #(= (func %) v) col)])]\n    (into {} grouped)))","user":"5766bab8e4b0a07e8fc180b1"},{"code":"#(let [v (partition-by % (sort-by % %2))]\n  (zipmap (map (comp % last) v) v))","problem":63,"user":"4f01c938535dcb61093f6a39"},{"problem":63,"code":"(fn prob63 [funcc collle]\n(reduce\n(fn [hassh x]\n  (let [keey (funcc x) vall (hassh keey)]  \n    (if (= vall nil) (assoc hassh keey [x]) (assoc hassh keey (conj vall x)))))\n {} collle))","user":"58e6a2c5e4b056aecfd47cba"},{"code":"(fn f\n  [j coll]  \n  (persistent!\n   (reduce\n    (fn [ret x]\n      (let [k (j x)]\n        (assoc! ret k (conj (get ret k []) x))))\n    (transient {}) coll)))","problem":63,"user":"50503117e4b0a02f9cffdeb5"},{"code":"(fn [f arr]\n ((fn gr [groups [k v & t]]\n    (if (nil? k)\n      groups\n      (if (contains? groups k)\n        (gr (merge groups {k (conj (get groups k) v)}) t)\n        (gr (merge {k [v]} groups) t))))\n\n  {} (interleave (map f arr) arr)))","problem":63,"user":"515896f2e4b059418b97f0a8"},{"code":"(fn [f s]\n  (let [res (map f s)\n        result (interleave res s)] \n       (loop [l result col {}]\n         (if (empty? l)\n           col\n           (recur (rest (rest l)) (merge-with concat  col (apply assoc {}  [(first l) [(second l)] ])))))))","problem":63,"user":"4ec3b393535dcc7ae8597d59"},{"problem":63,"code":"(fn [f s]\n  (loop [a s\n         r {}]\n    (if (empty? a)\n      r\n      (let [fst (first a)\n            k (f fst)\n\t        elem (get r k)]\n        (recur (rest a) (assoc r k (vec (conj elem fst))))))))","user":"5ab9fe71e4b073f17744269d"},{"problem":63,"code":"(fn my-group-by [f s]\n    (reduce #(let [k (f %2)]\n               (assoc %1 k (conj (get %1 k []) %2)))\n            {} s))","user":"4dfe5a93535d04ed9115e786"},{"code":"(fn groupby [f s]\n   (apply merge-with concat\n          (map #(hash-map (f %) (vector %)) s)))","problem":63,"user":"4faafccde4b081705acca209"},{"problem":63,"code":"(fn group-b [f s]\n  (letfn [ (make-pairs\n               [f s]\n               (map  vector ( map f s) s)\n               )\n             (add-to-empty-map\n               [value]\n                (conj {} [(first value) [ (second value)]] )\n               )]\n    (reduce\n     (fn [coll y]\n       (let [\n             element-key  (first y)\n             existed-value-in-collection  (coll element-key)\n             ]\n         (if  (empty? coll)\n           ^{:marker \"add-to-empty-map\"} (add-to-empty-map y)\n           (if  existed-value-in-collection\n             (let [ value-to-add    (conj existed-value-in-collection (second y))]\n               (assoc-in coll [element-key] value-to-add )\n               )\n             (conj coll [(first y) [(second y)]] )\n             )\n           )\n         ))\n     {}\n     (make-pairs f s))))","user":"51f81925e4b09be9c177e526"},{"code":"(fn [f ls]\n  (apply merge-with concat\n    (for [x ls]\n      (hash-map (f x) [x]))))","problem":63,"user":"4ea57300535d7eef308072d5"},{"problem":63,"code":"(fn my-group-by [f coll] \n  (reduce #(let [k (f %2)] (assoc %1 k (conj (%1 k []) %2))) {} coll))","user":"53f35c34e4b0742d9025b0f4"},{"problem":63,"code":"(fn [f s]\n  (into {} \n        (for \n          [v (into (sorted-set) (map f s))]\n          {v (filter #(= v (f %)) s)})))","user":"57b35a19e4b0fbc9809a277d"},{"problem":63,"code":"(fn [g in]\n          (reduce #(conj %1 [(g %2) \n                               (conj (%1 (g %2) []) %2)])  \n                  {}\n                  in))","user":"58b997afe4b0888cdc949cd1"},{"problem":63,"code":"(fn [f coll]\n  (reduce\n    (fn [ret x]\n      (let [k (f x)]\n        (assoc ret k (conj (get ret k []) x)))) {} coll))\n\n;; (assoc map key val & kvs)\n;; (get map key not-found)","user":"5b0180cfe4b0cc2b61a3bd47"},{"code":"(fn [f s]\n  (apply merge-with concat (map #(array-map (f %1) [%1]) s)))","problem":63,"user":"50e4f4e9e4b049a987753896"},{"problem":63,"code":"(fn grp-by [f c] (apply merge-with concat (for [x c] {(f x) (list x)})))","user":"55632016e4b0c656e3ff17e4"},{"problem":63,"code":"(fn [f coll]\n  (loop [l coll\n         groups {}] \n    (if (empty? l)\n      groups\n      (recur (rest l)\n         (let [cur (first l)\n               k (f cur)\n               group (conj (get groups k []) cur)]\n          (assoc groups k group))))))","user":"5794fd7be4b0e215f87e8476"},{"problem":63,"code":"(fn [f c]\n  (loop [c c\n         res {}]\n    (if (empty? c)\n      res\n      (let [item (first c)\n            v (f item)\n            vect (get res v [])]\n      \t(recur (rest c) (assoc res v (conj vect item)))))))","user":"53ee7f2ee4b0d648e757f4cf"},{"problem":63,"code":"(fn myGroup\n  [pred x]\n  (reduce (fn [m s] (let [fst (first s)\n                          lst (second s)]\n                      (if (contains? m fst)\n                        (assoc m fst (conj (get m fst) lst))\n                        (assoc m fst (vector lst)))))\n          {}\n          (map vector (map pred x) x)))","user":"54f64e99e4b0f2f3c5226ea4"},{"problem":63,"code":"(fn [f s]\n  (reduce\n   (fn [ret x]\n     (let [k (f x)]\n       (assoc ret k (conj (get ret k []) x))))\n   {} s))","user":"53e3f7a8e4b036ad0777e408"},{"problem":63,"code":"(fn grp-by [p s]\n  (if (empty? s) {}\n    (let [f (first s) t (rest s)]\n      (let [key (p f)]\n        (let [in  (into [] (filter #(= key (p %)) s))\n              out (into [] (remove #(= key (p %)) s))\n              ]\n          (conj {(p (first s)) in}\n                  (grp-by p out)\n                  )\n          )))))","user":"53dadf1de4b0e771c30254ad"},{"problem":63,"code":"(fn group [f s]\n  (apply merge-with concat (map #(hash-map (f %) [%]) s)))","user":"5f838122e4b01aacbe7a2715"},{"code":"(fn [f xs]\n  ((fn gb [l m]\n    (if (empty? l)\n      m\n      (let [x (first l)\n            k (f x)\n            {n k :or {n []}} m]\n       (gb (rest l) (assoc m k (conj n x)))\n      )\n    )\n  ) xs {})\n)","problem":63,"user":"4e720985535d5021c1a89655"},{"problem":63,"code":"(fn [f\n     coll]\n  (loop [[r & more :as all] (seq coll)\n         acc '{}]\n    (if all\n      (recur more (merge-with into acc {(f r) (conj '[] r)}))\n      acc)))","user":"5c718e6ce4b0fca0c1622796"},{"code":"(fn [p c] (reduce #(merge-with into % {(p %2) [%2]}) {} c))","problem":63,"user":"4db29f98535df7e46ed9b6c1"},{"code":"(fn [f s]\n  (loop [[head-s & rest-s] s\n         accum {}]\n    (if (nil? head-s)\n      accum\n      (recur\n       rest-s\n       (assoc accum (f head-s) (conj (get accum (f head-s) []) head-s))))))","problem":63,"user":"53527551e4b084c2834f4af0"},{"problem":63,"code":"(fn [f v]\n  (reduce #(assoc %1 (first %2) (conj (get %1 (first %2) []) (second %2)))\n          {} (map #(vector (f %) %) v)\n          )\n  )","user":"54e6762be4b024c67c0cf809"},{"problem":63,"code":"(fn [f s]\n  (reduce (fn [acc item]\n            (let [k (f item)]\n              (assoc acc k \n                (filter #(= k (f %))\n                        s)))) {} s))","user":"5829d588e4b051871117bf4a"},{"problem":63,"code":"#(reduce (fn [a x] (assoc a (% x) (conj (a (% x) []) x))) {} %2)","user":"59638af5e4b066ee0a44b0cc"},{"problem":63,"code":"(fn my-group[f seqq]\n  (reduce (fn k[a b](assoc \n                      a \n                      (f b) \n                      (if (a (f b))\n                        (concat (a (f b)) [b])\n                        [b])))\n          {} seqq))","user":"57bd960fe4b05aa3c4741c52"},{"problem":63,"code":"(fn [f l]\n  (reduce\n    (fn [res v]\n      (let [ev (f v)\n          res (if (map? res) res {} )\n          resval (or (get res ev) [])]\n      (assoc res ev (conj resval v)\n      ))) {} l))","user":"586e47dee4b01531a375e9a9"},{"code":"(fn gs [f xs]\n  (loop [m {}, xs (seq xs)]\n    (if (seq xs)\n      (let [x (first xs), xs (rest xs), res (f x)]\n        (recur (assoc m res (vec (conj (m res) x))) xs))\n      m)))","problem":63,"user":"4e1b2cd9535d04ed9115e7fd"},{"problem":63,"code":"(fn [f c]\n   (reduce #(assoc % (f %2) (conj (get % (f %2) []) %2))\n           {} c))","user":"5bb25684e4b0a20761a2350d"},{"problem":63,"code":"(fn [f items]\n  (loop [items items result {}]\n    (if (empty? items)\n      result\n      (let [current-item (first items), key (f (first items)), key-items (get result key [])]\n        (recur (rest items) (assoc result key (conj key-items current-item)))))))","user":"5d0859fbe4b0cc9c91588208"},{"problem":63,"code":"(fn group-seq [f lst]\n  (let [result (map (comp f) lst)]\n    (reduce (partial merge-with concat) (map hash-map result (map vector lst)))))","user":"570e6974e4b0b0fb43fd06ef"},{"problem":63,"code":"#(reduce (fn [m [r x]] (assoc m r (concat (m r) [x]))) {} (map (juxt % identity) %2))","user":"549def9ce4b0f3d1d8e70f99"},{"problem":63,"code":"(fn [f s]\n  (reduce \n   (fn [m [r a]] \n     (if (m r) \n       (update-in m [r] #(conj % a)) \n       (conj m [r [a]])\n       )\n     )\n   {}\n   (map #(vector (f %) %) s)))","user":"53e745a1e4b036ad0777e479"},{"code":"(fn [f s]\n  (loop [ss s out {}]\n    (if (empty? ss)\n      out\n      (let [e (first ss) v (f e)]\n        (recur (rest ss) (assoc out v (if (out v) (conj (out v) e) [e])))))))","problem":63,"user":"4dd9d299535d2dad7130b5dd"},{"code":"#(zipmap \n  (distinct (map %1 %2))\n  (partition-by %1\n                (sort-by %1 %2)))","problem":63,"user":"528410bbe4b0239c8a67adc2"},{"problem":63,"code":"(fn [f s]\n  (reduce\n    (fn [x y]\n      (let [result-map x\n            a-key (f y)\n            a-values (get result-map a-key [])]\n        (assoc result-map a-key (conj a-values y))))\n    {}\n    s))","user":"55b28b57e4b01b9910ae296c"},{"code":"(fn gp\n  ([kf col res]\n   (if (empty? col)\n     res\n     (let [f (first col) r (rest col) k (kf f)]\n       (if (contains? res k)\n         (gp kf r (assoc res k (conj (res k) f)))\n         (gp kf r (assoc res k [f]))\n         ))))\n  ([kf col] (gp kf col {}))\n  )","problem":63,"user":"52ae886de4b0c58976d9acab"},{"problem":63,"code":"(fn [f si]\n  (loop [s si m {}]\n    (if (empty? s)\n      m\n      (let [e (first s)]\n        (recur (rest s) (merge-with into m {(f e) [e]}))))))","user":"58ca613de4b021aa9917edb7"},{"problem":63,"code":"(fn group-seq\n  [f coll]\n  (reduce (fn [acc n]\n            (let [k (f n)]\n              (assoc acc k (conj (vec (get acc k)) n))))\n          {}\n          coll))","user":"60c0ceb7e4b0e0fa5f1b42a6"},{"code":"(fn groupz [x y] (if (empty? y) {} (merge-with concat {(x (first y)),(list(first y))} (groupz x (rest y)))))","problem":63,"user":"4f32135ae4b0d6649770a08e"},{"problem":63,"code":"(fn [f coll]\n  (reduce (fn [m v]\n            (let [new-val (conj (vec (m (f v))) v)]\n              (assoc m (f v) new-val)))\n          {}\n          coll))","user":"53dfbc75e4b0d874e779ae44"},{"code":"(fn solution [f s]\n  (reduce\n   (fn [x y] (assoc x (f y)\n                   (concat (get x (f y)) (vector y))))\n   {}\n   s\n   ))","problem":63,"user":"5226f8e9e4b04e78ff2e199a"},{"code":"(fn[f coll] \r\n   (reduce\r\n    (fn [ret x]\r\n      (let [k (f x)]\r\n        (assoc ret k (conj (get ret k []) x))))\r\n     {} coll))","problem":63,"user":"4ffd92e7e4b0678c553fc3e3"},{"code":"(fn g [f l]\n  (if\n    (= l ()) {}\n    (let [a (g f (rest l))\n          i (first l)\n          x (f i)]\n      (assoc a x (cons i (get a x ()))))))","problem":63,"user":"50a83315e4b054305ba5a830"},{"problem":63,"code":"(fn [f c] (apply merge (for [k (set (map f c))] \n                            {k (filter (comp #(= k %) f) c)})))","user":"54e606c3e4b024c67c0cf803"},{"problem":63,"code":"(fn [f xs]\n (let [ks (set (map f xs))]\n   (apply hash-map (mapcat (fn [k] `(~k ~(filter #(= k (f %)) xs))) ks))))","user":"5447e08ce4b032a45b8693c3"},{"code":"(fn \n  [f coll] (reduce (fn [m e] (assoc m (f e) (conj (m (f e) []) e))) {} coll))","problem":63,"user":"4f047542535dcb61093f6bc7"},{"problem":63,"code":"(fn [f args]\n  (reduce \n   (fn [m v]\n     (update-in m \n                [(f v)] \n                #((comp vec conj) \n                   % v)))\n          {}\n          args))","user":"55d8eed3e4b0e31453f64ac3"},{"code":"#(loop [x %2 z '{}] (if (empty? x) z (let [[i] x k (% i)] (recur (rest x) (if (contains? z k) (assoc z k (conj (get z k) i)) (assoc z k [i]))))))","problem":63,"user":"52e48632e4b09f7907dd1450"},{"problem":63,"code":"(fn group-by_ [f coll] (reduce #(assoc %1 (f %2) (concat (get %1 (f %2)) [%2])) {} coll))","user":"5e5b8d92e4b0fd0acd158658"},{"code":"(fn [f coll]\n  (apply merge-with\n    concat\n    (map #(hash-map (f %) [%]) coll)))","problem":63,"user":"509160dae4b0742c82730aef"},{"problem":63,"code":"(fn myf [f s] (apply merge-with concat (map hash-map (map f s) (map vector s))))","user":"5bafd5c8e4b0a20761a234dd"},{"problem":63,"code":"(fn my-group-by [f coll]\n  (reduce (fn [acc v]\n            (let [k (f v)]\n              (assoc acc k (conj (get acc k []) v))))\n          {} coll))","user":"53dc94c8e4b094d41abdfefc"},{"problem":63,"code":"(fn my-group-by [f s]\n  (->> s (map f) (interleave (range)) (partition 2)\n       (sort-by second) (map #(list (nth s (first %)) (second %)))\n       (partition-by second) (mapcat #(list (second (first %)) (map first %)))\n       (apply hash-map)))","user":"57763002e4b0979f89651631"},{"code":"#(loop [f %1 v %2 m {}] (if (seq v) \n                              (recur f (rest v) (into m {(f (first v)) (conj (get m (f (first v)) []) (first v))})) m))","problem":63,"user":"52df232fe4b09f7907dd13fc"},{"problem":63,"code":"(fn mygroup-by [f sq]\n  (reduce (fn [a e]\n            (let [key (f e)]\n              (update-in a [key] (fn [v] (conj (or v []) e)))\n             )\n            ) {} sq)\n\n  )","user":"5fee18f2e4b05ac5b16ea1d2"},{"problem":63,"code":"(fn [f coll]\n  (reduce (fn [acc v]\n            (prn acc v)\n            (assoc acc (f v) (vec (conj (get acc (f v)) v )))\n      ) {} coll )\n  )","user":"5ed8a12fe4b0c7845d86b0d7"},{"code":"(fn [f i] (reduce #(assoc %1 (f (first %2)) %2) {} (partition-by f (sort-by f i))))","problem":63,"user":"528652fbe4b0239c8a67ae14"},{"code":"(fn group-by1 [f coll]\n  (let [myfn (fn [mymap x]\n               (assoc mymap (f x) (conj (get mymap (f x) []) x)))]\n    (reduce myfn {} coll)))","problem":63,"user":"51f82769e4b09be9c177e527"},{"code":"(fn P63 [ func list ]\n  (loop [a (distinct (map func list)) result (hash-map)]\n         (if (empty? a)\n           result\n           (recur (rest a) (assoc result (first a) (loop [temp list r []] \n                                                    (if (empty? temp) \n                                                      r \n                                                      (if (= (first a) (func (first temp))) \n                                                        (recur (rest temp) (conj r (first temp))) \n                                                        (recur (rest temp) r)))))))))","problem":63,"user":"5046f909e4b03b02161376b5"},{"code":"(fn [f s]\n  (reduce #(assoc % (f %2) (conj (% (f %2) []) %2)) {} s))","problem":63,"user":"4f03857e535dcb61093f6b0d"},{"problem":63,"code":"(fn [f s]\n  (reduce (fn [m e] (if (m (f e)) (assoc m (f e) (conj (m (f e)) e)) (assoc m (f e) [e])) ) {} s))","user":"5b4ff637e4b02d533a91bce0"},{"problem":63,"code":"(fn [f s]\n  (reduce (fn [m v]\n            (update-in m [(f v)] (fnil conj []) v))\n          {}\n          s))","user":"559057c4e4b027778923766e"},{"problem":63,"code":"(fn\n  [f coll]\n  (reduce #(assoc %1 (f %2) (conj (get %1 (f %2) []) %2)) {} coll))","user":"5640b135e4b08d4f616f5ee8"},{"problem":63,"code":"(fn [f s]\n  (reduce #(assoc %1 (f %2) (conj (%1 (f %2) []) %2)) {} s)\n  )","user":"539ec9f9e4b0ca733b974491"},{"code":"(fn [f s]\n  (reduce #(let [k (f %2)] (assoc %1 k (conj (get %1 k []) %2)))  {} s))","problem":63,"user":"533ab9abe4b0e30313ee6cbf"},{"code":"(fn c [f v] \n  (reduce \n      #(let [mp %1 , v %2 , k (f v),  ll (mp k) ] \n       \t(assoc mp k (if (mp k) (conj ll v) (vector v))))\n      {}\n      v)\n  )","problem":63,"user":"4ff2ff7ce4b0678c553fc342"},{"problem":63,"code":"(let\n  [add (fn [m k v] (assoc m k (if (contains? m k) (concat [v] (m k)) [v])))]\n  (fn group [mapper coll] (if\n                            (first coll)\n                            (add\n                             (group mapper (rest coll))\n                             (mapper (first coll))\n                             (first coll))\n                            {})))","user":"5b465b8be4b02d533a91bc65"},{"code":"(fn [f l] \r\n  (reduce \r\n    #(assoc %1 (f %2) (conj (into [] (get %1 (f %2))) %2)) \r\n    (hash-map) \r\n    l))","problem":63,"user":"5034b0e1e4b062bc5d7ae167"},{"problem":63,"code":"(fn [f coll]\n    (reduce (fn [result element]\n              (update-in result [(f element)] #((fnil conj []) % element)))\n            {}\n            coll))","user":"597f8c93e4b0dbe32238d0c1"},{"problem":63,"code":"(fn mygroupby [f invec]\n    (loop [[frst & lst] invec acc {}]\n      (if (nil? frst)\n        acc\n        (recur lst (assoc acc (f frst) (conj (acc (f frst) []) frst)))\n        )\n      ))","user":"5c9dcb36e4b048ec896c5b1d"},{"code":"(fn [func xs]\n   (reduce (fn [map val]\n             (let [key (func val)]\n               (assoc map\n                 key (conj (get map key []) val))))\n          {} xs))","problem":63,"user":"4f03818e535dcb61093f6b00"},{"code":"(fn j-group\n  [op lst]\n  (loop\n      [orig (map (fn [x] [(op x) x]) lst)\n       final {}]\n    (if-not (empty? orig)\n      (recur (rest orig) (merge (dissoc final (first (first orig))) { (first (first orig))      (into [] (conj (final (first (first orig))) (last (first orig))))}      ))\n      final)))","problem":63,"user":"534ff8a6e4b084c2834f4ad1"},{"problem":63,"code":"(fn [f coll] (persistent! (reduce (fn [m e] (assoc! m (f e) (conj (get m (f e) []) e))) (transient {}) coll)))","user":"5cebafbbe4b0a17bb84e2be6"},{"problem":63,"code":"(fn group[n s](apply merge-with concat\n                     (map #(hash-map(n %1)[%1])s)))","user":"6085edade4b0736b099e42fc"},{"problem":63,"code":"(fn group [f s]\n  (loop [ m {}, col s]\n    (if (empty? col) m\n      (recur (assoc m (f (first col)) \n               (vec (conj (m (f (first col ))) (first col)))) \n             \n             (rest col)))))","user":"54b54d1be4b05787c3b1639c"},{"problem":63,"code":"(fn [f seq]\n   (loop [s seq  el (first s) rslt {}]\n     (if (empty? s)\n       rslt\n       (recur (rest s) (first (rest s))\n           (conj rslt {(f el) (vec (conj (get rslt (f el)) el))})\n                    ))))","user":"572ac718e4b0f4d77e651242"},{"code":"(fn [f c] \n  (reduce \n   (fn [x y] \n     (let [k (f y)]\n       (update-in x \n              [k] \n              #(if %\n                 (conj % y)\n                 [y]))))\n {} c))","problem":63,"user":"50f53694e4b057d4c52de881"},{"problem":63,"code":"(fn [keyfn lst]\n      (reduce #(let [k (keyfn %2) v (%1 k (vector))] (assoc %1 k (conj v %2))) {} lst))","user":"58134ba8e4b0f478707a060b"},{"problem":63,"code":"(fn gb [f xs](apply merge(map #(hash-map (f (first %)) %) (partition-by f (sort-by f xs)))))","user":"57752a2de4b0979f89651613"},{"code":"(fn [f lst]\n  (apply merge-with concat (map (fn [x] {(f x) [x]}) lst)))","problem":63,"user":"500cb910e4b05f7c30cfa698"},{"problem":63,"code":"(fn f [g [x & xs]]\n  (if x (update-in (f g xs) [(g x)] (fnil conj '()) x)))","user":"54c5cc17e4b045293a27f624"},{"problem":63,"code":"(fn group-seq [ func vv]\n  ( into {}\n    \n    ( map #(vector (func ( first %) ) (vec %) )  (partition-by func (sort vv) ))\n                         \n  ))","user":"516d227fe4b06f078fab252d"},{"problem":63,"code":"(fn [f s](into {}(map #(vector (f (first %)) (vec %))(partition-by f (sort s)))))","user":"5d99dc47e4b0d3f9b434ad42"},{"code":"(fn  xx [f s] \n\t(letfn [(ff [m x v] \n\t\t(if-let [ou  (get m x )] \n\t\t    (assoc m x (conj ou v ))\n\t\t    (assoc m x [v]) ))]\n\t(reduce  (fn [x y] (ff x (f y) y))     {}  s ) ))","problem":63,"user":"518644bce4b0da5a5be3baca"},{"code":"(fn [fkey col]\n  (reduce\n    ( fn [acc x]\n      (update-in acc [(fkey x)] (fnil conj []) x))\n    {}\n    col))","problem":63,"user":"525431dfe4b0541d1855b970"},{"code":"(fn [f c]\n  (reduce\n    #(assoc %\n            (f %2)\n            (conj (vec (% (f %2))) %2))\n    {}\n    c))","problem":63,"user":"4f38b7d9e4b0e243712b1ee0"},{"problem":63,"code":"(fn [f s] (loop [output {} input s] (if\n\t(empty? input)\n\toutput\n\t(recur \n\t\t(if \n\t\t\t(contains? output (f (first input)))\n\t\t\t(update-in output [(f (first input))] (fn [x] (conj x (first input))))\n\t\t\t(assoc output (f (first input)) [(first input)]))\n\t\t(rest input)))))","user":"53d5d24de4b0e771c302544a"},{"problem":63,"code":"(fn [f coll] (apply merge-with concat (map #(assoc {} (f %) [%]) coll)))","user":"5a535572e4b05d388ecb6c0b"},{"code":"(fn [f s]\n  (reduce (fn [acc x] (update-in acc [(f x)] (fn [orig] (conj (or orig []) x))))\n          {}\n          s))","problem":63,"user":"4fa09916e4b0dcca54ed6d4e"},{"problem":63,"code":"(fn [f v](reduce #(let [k (f %2)](assoc %1 k (conj (vec(%1 k)) %2))) {} v))","user":"5481be5fe4b0e286459a1172"},{"problem":63,"code":"(fn [op coll]\n  (reduce (fn [ret-coll x]\n            (let [k (op x)]\n              (if (contains? ret-coll k)\n                (assoc ret-coll k (conj (get ret-coll k) x))\n                (assoc ret-coll k [x]))))\n          {} coll))","user":"591072e0e4b0163c97b36ebc"},{"problem":63,"code":"(fn [f s]\n  (loop [result {} s s]\n    (if (nil? s)\n      result\n      (recur (assoc result (f (first s)) (conj (get result (f (first s)) []) (first s))) (next s)))))","user":"566a6e38e4b0a866af68969b"},{"problem":63,"code":"(fn group-by-2 [pred coll]\n  (->\n    (fn [result-dict item-from-coll] \n      (let [result (pred item-from-coll)] \n        (assoc result-dict result (conj (result-dict result []) item-from-coll))))\n    (reduce ,, {} coll)))","user":"5227eacee4b0186687e23a5e"},{"code":"(fn [f s]\n  (loop [m {} data s]\n    (if (not-empty data)\n      (let [v (first data)\n            k (f v)]\n        (if (find m k)\n          (recur (assoc m k (conj (get m k) v)) (rest data))\n          (recur (assoc m k [v]) (rest data))))\n      m)))","problem":63,"user":"4eb1dd39535d7eef30807345"},{"problem":63,"code":"(fn [ f coll ] (reduce (fn [set [key val]] (conj set [key (conj (vec (get set key)) val)])) {} (map vector (map f coll) coll)))","user":"4fdb0c0ae4b05e33b9224f57"},{"problem":63,"code":"#(reduce (fn [a e] (assoc a (% e) (conj (a (% e) []) e))) {} %2)","user":"4fb1d7ace4b081705acca281"},{"code":"(fn [f s]\n   (loop [r {} s (seq s)]\n     (if (seq s)\n       (let [k (f (first s)) v (get r k)]\n         (if (nil? v)\n           (recur (assoc r k [(first s)]) (rest s))\n           (recur (assoc r k (conj v (first s))) (rest s))))\n       r)))","problem":63,"user":"4e6a5f5c535d8ccf87e9fed6"},{"code":"(fn [f s]\n  (loop [lst s ans (hash-map)]\n    (if (empty? lst)\n      ans\n      (let [k (f (first lst))]\n        (recur\n          (rest lst)\n          (assoc ans k (concat (get ans k) [(first lst)])))))))","problem":63,"user":"519136e9e4b0f8ef0be96c01"},{"code":"(fn [f s]\n    (into {} (for [k (set (map f s))]\n      [k (vec (filter #(= k (f %)) s))])))","problem":63,"user":"531619c1e4b08068f379ed3d"},{"code":"(fn [f s]\n  (loop [s s\n         r {}]\n    (if (empty? s)\n      r\n      (let [s0 (first s)\n            f-of-s0 (f s0)]\n        (recur (rest s)\n               (assoc r f-of-s0 (conj (r f-of-s0 []) s0)))))))","problem":63,"user":"521b9f92e4b0c4ef0be8304c"},{"code":"(fn z\n  ([f v] (z {} f v))\n  ([m f s] (if-let [x (first s)]\n             (let [k (f x)\n                   v (conj (or (m k) []) x)]\n               (recur (assoc m k v)\n                      f\n                      (rest s)))\n             m)))","problem":63,"user":"4f6fd91ae4b07046d9f4efed"},{"code":"(fn [f s]\n  (reduce \n    (fn [agg e] (update-in agg [(f e)] conj e)) \n     {} \n     (reverse s)))","problem":63,"user":"5012ec0ae4b0c87326002230"},{"problem":63,"code":"(fn [f s]\n  (apply merge-with\n         (fn [merged new] (into [] (concat merged new)))\n         (map (fn [k v] {k [v]}) (map f s) s)))","user":"54a627bce4b09f271ff37c83"},{"problem":63,"code":"(fn [fun ls]\n  (loop [in ls\n         out {}]\n    (if (empty? in) \n      out\n      (let [x (first in)\n            y (fun x)\n            z (get out y)]\n        (if z (recur (rest in) \n                     (assoc out y (conj z x)))\n          \t  (recur (rest in)\n                     (assoc out y [x])))))))","user":"594bd637e4b07ddc2dafae41"},{"code":"(fn [f xs]\n  (reduce #(update-in %1 [(f %2)] (fn [x] (conj (or x []) %2))) {} xs))","problem":63,"user":"4f0f36a7535d0136e6c22336"},{"problem":63,"code":"(fn [f s]\n  (reduce\n    (fn [m v]\n      (let [key (f v)]\n        (assoc m key (conj (m key []) v))))\n   {}\n   s))","user":"559454f2e4b0c79f6e1db952"},{"code":"(fn [f c] (reduce #(merge-with concat %1 {(f %2) [%2]}) {} c))","problem":63,"user":"536b2048e4b0243289761eb7"},{"problem":63,"code":"(fn [f xs]\n  (reduce \n   #(assoc %1 (f %2) (conj (get %1 (f %2) []) %2)) \n   {} \n   xs))","user":"57995ac1e4b05b1deef9adbf"},{"problem":63,"code":"(fn [f v]\n  ((fn group [res result]\n     (if (empty? res) result\n           (let [cur (first res)\n                 k (f cur)]\n             (if (contains? result k) (group (rest res) (assoc result k (conj (get result k) cur)))\n               (group (rest res) (assoc result k [cur])))))) v {}))","user":"58f98231e4b0438e51c2cf4c"},{"problem":63,"code":"(fn categorise [f coll]\n  (loop [result {}\n         [x & xs :as input] coll]\n    (if (empty? input)\n      result\n      (let [k (f x)\n            v (get result k)]\n        (if v\n          (recur (assoc result k (conj v x)) xs)\n          (recur (assoc result k        [x]) xs))))))","user":"601aaa93e4b0bf4ca6b10926"},{"code":"(fn [f s]\n                 (loop [f f s s results {}]\n                   (if (empty? s)\n                     results ;; needs reversing, unfortunately :(\n                     (let [[el & more] s\n                           k (f el)\n                           cur (vec (results k))]\n                       (recur f more (assoc results k (conj cur el)))))))","problem":63,"user":"4edb314d535d10e5ff6f5317"},{"code":"(fn [f xs] \n  (reduce \n    (fn [resultmap x] \n      (merge-with concat resultmap {(f x) [x]}))\n    {} xs))","problem":63,"user":"4fe83efbe4b07c9f6fd12c3b"},{"problem":63,"code":"(fn [f sq]\n  (reduce\n    (fn [r x]\n      (let [k (f x)]\n        (merge r {\n                  k\n                  (conj (get r k []) x)})))\n    {}\n    sq))","user":"57300c19e4b0cd1946bd0fa1"},{"code":"(fn [f,s] (reduce (fn [m,v] (update-in m [(f v)] (fnil conj []) v)) {} s))","problem":63,"user":"531f1e63e4b08068f379edc2"},{"problem":63,"code":"(fn [f x] (into {}\n        (map #(vector (f (first % )) (vec %))\n             (partition-by f (sort x)))))","user":"56399b7ee4b0bfe05bf117f5"},{"problem":63,"code":"#(let [update (fn [m k f]\n                 (assoc m k (f (m k))))]\n     (reduce\n      (fn [m v]\n        (update m (%1 v)\n                (fn [s] (conj (vec s) v))))\n      {} %2))","user":"54be7c0de4b0ed20f4ff6eec"},{"code":"(fn [f col]\n  (reduce #(assoc % (f %2) (conj (get % (f %2) []) %2)) {} col))","problem":63,"user":"4daeabf6edd6309eace4d15c"},{"problem":63,"code":"(fn [f coll]\n  (reduce\n   (fn [m x]\n     (let [k (f x)\n           xs (get m k [])]\n       (assoc m k (conj xs x))))\n   {}\n   coll))","user":"5032748ae4b0e78df07b092f"},{"problem":63,"code":"(fn [g xs]\n (reduce  (fn [res x]\n            (merge-with concat\n              res (hash-map (g x) [x])))                      \n   {} xs))","user":"53b42472e4b047364c0444b2"},{"problem":63,"code":"(fn [f l]\n  (reduce #(assoc % (f %2) (if (sequential? (% (f %2)) ) (conj (% (f %2)) %2) [%2])) {} l))","user":"519e70d5e4b0acf32bc6a42c"},{"code":"(fn my-grouping [f col]\n  (loop [s {} col col]\n    (if (empty? col)\n        s\n        (let [z (f (first col))\n              i (filter #(= z (f %)) col)\n              j (filter #(not= z (f %)) col)]\n          (recur (conj s [z i]) j)))))","problem":63,"user":"50435689e4b034ff00315d21"},{"code":"(let [assoc*\n  (fn [map key value]\n    (if (contains? map key)\n      (assoc map key (conj (map key) value))\n      (assoc map key [value])))]\n  #(reduce (fn [map value] (assoc* map (%1 value) value)) {} %2))","problem":63,"user":"4f038499535dcb61093f6b09"},{"problem":63,"code":"(fn eka\n    ([op xs]\n     (eka op {} xs))\n    ([op m xs]\n     (if (seq xs)\n       (let [v (first xs)\n             k (identity (op v))\n             group (get m k)\n         new_group (if group\n                     (conj group v)\n                     [v])\n             new_m (assoc m k new_group)\n             ]\n         (recur op new_m (rest xs))\n         )\n       m\n       )\n      )\n    )","user":"596d630ae4b069c0a1a19846"},{"problem":63,"code":"(fn [f s]\n  (loop [s s m (hash-map)]\n    (if (empty? s)\n      m\n      (recur (rest s) \n             (assoc m\n                    (f (first s))\n                    (conj (get m (f (first s)) [])\n                          (first s)\n                    )\n             )\n      )\n    )\n  )\n)","user":"5bdf651ee4b0ed4b8aab4c6d"},{"code":"(fn [p col]\n  (reduce #(update-in %1 [(p %2)] (fn [v] ((fnil conj []) v %2))) {} col))","problem":63,"user":"5371167fe4b0fc7073fd6ea7"},{"problem":63,"code":"(fn my-group-by [f s]\n  (reduce\n   (fn [result item]\n     (let [k (f item)]\n       (if (get result k)\n         (into result [{ k (conj (get result k) item) }])\n         (into result [{ k [item] }]))\n       )\n     )\n   {}\n   s\n   ))","user":"5ee75f8be4b029a2061bbea5"},{"problem":63,"code":"(fn [fc l]\n  (loop [l l r {}]\n    (if (empty? l) r\n      (let [f (first l)\n            k (fc f)\n            v (if-let [o (r k)] (conj o f) [f])]\n        (recur (rest l) (assoc r k v))))))","user":"57d9f603e4b0bd073c20240a"},{"problem":63,"code":"(fn [f s]\n  (reduce (fn [m n] (assoc m (f n) (conj (get m (f n) []) n))) {} s))","user":"5958cef6e4b066ee0a44af94"},{"code":"#(zipmap (distinct (map %1 %2)) (partition-by %1 (sort-by %1 %2)))","problem":63,"user":"5213dbc3e4b0961f15ac4d74"},{"code":"(fn my-groupby [f s]\n  (reduce (fn [m x]\n            (let [key (f x)]\n              (assoc m key (conj (get m key []) x))))\n    {}\n    s))","problem":63,"user":"50812debe4b01a93d3f38e4c"},{"code":"#(apply merge-with concat (for [e %2] {(% e) [e]}))","problem":63,"user":"4f9fe2b9e4b0dcca54ed6d40"},{"code":"(fn [f s]\n  (apply merge-with concat\n    (for [x s]\n      {(f x) (vector x)})))","problem":63,"user":"4f7e29dde4b06e829148e1ca"},{"problem":63,"code":"(fn my-group-by [f coll]\n  (loop [m (sorted-map)\n         [e & ls] coll]\n    (if (nil? e)\n      m\n      (recur (assoc m (f e) (if (m (f e))\n                              (conj (m (f e)) e)\n                              [e]))\n             ls))))","user":"598601f9e4b021a7a535fe79"},{"code":"(fn [f s]\n  (apply merge-with concat\n    (map #(hash-map (f %) [%]) s)))","problem":63,"user":"4f956072e4b0dcca54ed6ccf"},{"problem":63,"code":"(fn [f coll] \n  (reduce \n    #(assoc %1 \n           (first %2)\n           (conj (get %1 (first %2) [] ) (second %2) )) \n    {}\n    (map #(vector (f %) %) coll)))","user":"59c76402e4b0a024fb6ae542"},{"code":"(fn [f l]\n  (loop [l l acc {}]\n    (if (empty? l)\n      acc\n      (let [k (f (first l))\n            v (get acc k [])]\n        (recur (rest l) (assoc acc k (conj v (first l))))))))","problem":63,"user":"4e568873535d8a8b8723a283"},{"code":"(fn [f s] (reduce (fn [m i] (update-in m [(f i)] (fnil conj []) i)) {} s))","problem":63,"user":"51672d15e4b079759a74a5e7"},{"problem":63,"code":"(fn [fun ve]\n  (reduce\n    (fn [acc item]\n      (let [\n            val (fun item)\n            ]\n\n        (update-in acc [val] (fnil (fn [x] (conj x item)) []) )))\n      {}\n      ve)\n    )","user":"58bc6a88e4b0888cdc949d16"},{"code":"(fn [f c] (reduce #(merge-with concat % {(f %2) [%2]})  {} c))","problem":63,"user":"4ec4d723535dcc7ae8597d65"},{"problem":63,"code":"(fn ya\n  [f s]\n  (reduce \n    (fn \n      [r x]\n      (let [fx      (f x)\n            new-el? (nil? (get r fx))]\n        (if new-el?\n          (assoc r fx [x])\n          (assoc r fx (conj (get r fx) x)))))\n    {}\n    s))","user":"5843b231e4b089d5ab817e3d"},{"problem":63,"code":"(fn [pred coll]\n  (reduce (fn [acc v]\n            (update-in acc\n                       [(pred v)]\n                       (fnil conj [])\n                       v))\n          {}\n          coll))","user":"5a0a3473e4b0eab8c0448941"},{"code":"(fn [f coll]\n          (reduce\n            #(assoc %1 (f %2) (conj (or (%1 (f %2)) []) %2))\n            {} coll))\n; seems like everyone lands on this solution","problem":63,"user":"4ebb20c0535dfed6da9c6d6f"},{"code":"(fn [f coll]\n   (reduce\n    (fn [ret x]\n      (let [k (f x)]\n        (assoc ret k (conj (get ret k []) x))))\n    \t{} coll))","problem":63,"user":"5082ccb3e4b06a522e8c7af3"},{"problem":63,"code":"(fn my-group-by [f s]\n  (loop [res {}\n         s s]\n    (if (empty? s) res\n      (recur (assoc res (f (first s)) (concat  (vec (res (f (first s)))) [(first s)]) ) (rest s)))))","user":"531bad96e4b08068f379ed93"},{"problem":63,"code":"(fn [f coll]\n    (let [outcomes (map (fn [x]\n                          {(f x) x})\n                        coll)\n          keys-1 (map f coll)\n          ans (reduce (fn [a b]\n                        (merge-with conj\n                                    a\n                                    b))\n                      (reduce (fn [a b]\n                                (assoc a b []))\n                              {}\n                              (distinct keys-1))\n                      outcomes)]\n      ans))","user":"59636cc2e4b066ee0a44b0c7"},{"code":"(fn [f s]\n  (reduce \n   (fn [accum nxt]\n     (assoc\n       accum\n       (f nxt)\n       (conj (accum (f nxt) []) nxt)))\n   {}\n   s))","problem":63,"user":"51aa2b4fe4b04e3dc0c27b21"},{"problem":63,"code":"(fn [fun items]\n  (reduce #(merge-with concat % %2) {} (map #(hash-map (fun %) [%]) items)))","user":"55a0d79fe4b0acc240e31502"},{"problem":63,"code":"(fn [func coll]\n   (reduce #(assoc %1 (first %2) (into (get %1 (first %2)) (next %2)))\n           (reduce #(assoc %1 %2 []) {} (map func coll))\n           (map vector (map func coll) coll)))","user":"58987ee9e4b00487982d52d2"},{"code":"(fn [f coll]\r\n  (reduce\r\n    #(let [k (f %2)]\r\n       (assoc %1 k (conj (get %1 k []) %2)))\r\n    {}\r\n    coll))","problem":63,"user":"500e91aae4b00fff93030f99"},{"problem":63,"code":"(fn group [Fx V]\n\t(loop [[v1 & vrest :as Vs] V, out {}]\n\t\t(if (seq Vs)\n\t\t\t(let [Y (Fx v1)]\n\t\t\t\t(recur vrest (conj out [Y, (conj (get out Y []) v1) ])))\n\t\tout)))","user":"564d02cde4b0284900eef679"},{"code":"(fn [f s]\n  (loop [n 0, res (map f s), m {}]\n    (if (empty? res) m\n        (recur\n          (inc n)\n          (rest res)\n          (assoc m (first res)\n                 (if (nil? (m (first res))) [(nth s n)]\n                     (conj (m (first res)) (nth s n))))))))","problem":63,"user":"53806e5be4b06839e8705ec1"},{"problem":63,"code":"#(apply merge-with into \n        (for [v %2]\n          {(% v) [v]}\n          )\n        )","user":"608b3fe1e4b0adce4b61c442"},{"problem":63,"code":"(fn [f v]\n   (apply merge\n          (let [s (apply merge (map #(hash-map % (f %)) v))\n                vls (->> s (vals) (distinct))]\n            (map\n             (fn [r]\n               (sorted-map r (sort (into [] (map #(first %) (filter\n                                                          (fn [x] (= r (second x))) s))))))\n             vls))))","user":"5dab11cde4b000c986472c45"},{"code":"(fn gb [f s]\n  (loop [m {} z s]\n    (if (first z)\n      (let [k (f (first z)) v (m k)]\n        (recur (into m [[k (conj (if (nil? v) [] v) (first z))]]) (rest z)))\n      m)))","problem":63,"user":"4fa3f91fe4b081705acca196"},{"problem":63,"code":"(fn [f xs]\n  (reduce\n    (fn [m n]\n      (let [a (f n)\n            b (m a)]\n        (conj m [a (conj (or b []) n)])))\n    {}\n    xs))","user":"57717915e4b0979f896515b3"},{"problem":63,"code":"(let [a (fn [m k v]\n          (if (m k)\n            (assoc m k (conj (m k) v))\n            (assoc m k [v])))]\n  (fn [f s]\n    (reduce #(a %1 (f %2) %2) {} s)))","user":"5bab5440e4b0a20761a23475"},{"problem":63,"code":"(fn [f s]\n  (reduce (fn [nmap v]\n            (let [curr (f v)]\n              (if (contains? nmap curr)\n                (assoc nmap curr (conj (get nmap curr) v))\n                (assoc nmap curr [v]))))\n          {}\n          s))","user":"5f90aeefe4b0715f5002d799"},{"problem":63,"code":"(fn [f se] \n  (apply merge-with concat (map #(hash-map (f %) [%]) se)))","user":"575ef4b6e4b08062f99a4e78"},{"problem":63,"code":"(fn [f s] (reduce #(assoc % (f %2) (conj (% (f %2) []) %2) ) (assoc {} (f (first s)) [(first s)]) (rest s)) )","user":"55b39523e4b01b9910ae2973"},{"problem":63,"code":"(fn gb [f1 v1]\n   (loop [result {} v v1]\n     (if (not (first v))\n       result\n       (let [mapkey (f1 (first v)) mapval (cond (contains? result mapkey) (result mapkey) :else [])]\n         (recur (assoc result mapkey (conj mapval (first v))) (rest v))\n         )\n       )))","user":"518665cde4b0da5a5be3bad2"},{"code":"(fn [f coll]\r\n    (reduce #(let [key (f %2)]\r\n               (assoc %1 key (conj (get %1 key []) %2))) {} coll))","problem":63,"user":"4f047177535dcb61093f6bc6"},{"code":"(fn [f xs]\n  (apply merge-with concat (map (fn [x] {(f x) [x]}) xs))\n  )","problem":63,"user":"523f0bbfe4b01c266ffa7f91"},{"problem":63,"code":"(fn [f & args]  \n           (zipmap \n             (distinct (flatten (partition-by identity (sort (map f (apply sequence args)))))) \n                                (partition-by f (sort (apply sequence args)))))","user":"57d1a0e6e4b0bd073c20236d"},{"code":"(fn [f s]\n  (reduce\n    (fn [m v]\n      (let [k (f v)]\n        (assoc m k\n          (conj\n            (get m k [])\n            v))))\n    {}\n    s))","problem":63,"user":"4f5c0549e4b0030a34fb2b1a"},{"code":"(fn [f s]\n  (apply merge-with concat (for [v s] {(f v) [v]})))","problem":63,"user":"52cca65be4b07d0d72b2736b"},{"problem":63,"code":";;(fn g [f s]\n;;   (reduce #(update %1 (f %2) (fn [old] (if (nil? old) [%2] (conj old %2)))) {} s))\n;; update doesn't exist here\n(fn g [f s]\n   (reduce #(update-in %1 [(f %2)] (fn [old] (if (nil? old) [%2] (conj old %2)))) {} s))","user":"5fd8bcb3e4b05ac5b16ea11b"},{"code":"(fn [f s]\n             (apply merge-with\n                    #(concat %1 %2)\n                    (map #(hash-map (f %) [%]) \n                         s)))","problem":63,"user":"501fa1aee4b0cb6ebc0a42eb"},{"code":"(fn [f s]\n  (loop [m (hash-map)\n         remain s]\n     (if (empty? remain) m\n       (let [k (f (first remain))\n             v    (get m k)]\n          (if (nil? v)\n              (recur (assoc m k [(first remain)]) (rest remain))\n              (recur (assoc m k (concat v [(first remain)])) (rest remain))\n)))))","problem":63,"user":"4f036fb3535dcb61093f6ac8"},{"problem":63,"code":"(fn [f items]\n  (reduce (fn [result v] (let [k (f v)\n                               other-vs (result k)]\n                           (if (nil? v)\n                             (assoc result k [v])\n                             (assoc result k (sort (conj other-vs v)))))) {} items))","user":"539dcb24e4b0b51d73faaf3d"},{"code":"(fn [f coll]\n  (reduce (fn [m v]\n            (let [k (f v)]\n              (assoc m k (conj (get m k []) v))))\n          {}\n          coll))","problem":63,"user":"4f525fdce4b03ad3f0c10d37"},{"problem":63,"code":"#(apply merge-with into (for [v %2] {(%1 v) [v]}))","user":"54ab1b5ae4b09f271ff37cc2"},{"problem":63,"code":"#(apply merge-with concat\n  (for [s %2] {(%1 s) [s]}))","user":"559c13c5e4b066d22e731f61"},{"problem":63,"code":"#(apply merge-with into (for [a %2] {(% a) [a]}))","user":"59ea0944e4b0249b72820758"},{"problem":63,"code":"(fn [f c]\n\n  (let [g (map #(vector (f %) %) c)\n        keys (into #{} (map first g))]\n\n    (into {}\n          (for [k keys]\n            [k (map second (filter #(= k (first %)) g))]))))","user":"562268dce4b03f08ee9a9224"},{"problem":63,"code":"(fn [f coll]\n  (apply (partial merge-with into) (map (fn [x] {(f x) [x]}) coll))\n  )","user":"5a527beee4b05d388ecb6bfe"},{"code":"(fn [f lst] (apply merge-with concat (map #(assoc {} (f %) [%]) lst)))","problem":63,"user":"516dc88ae4b046df6fbb76a1"},{"code":"(fn [condition xs]\n  (apply (partial merge-with concat {})\n         (map (fn [x] {(condition x) [x]}) xs)))","problem":63,"user":"525ab6cfe4b0cb4875a45cf9"},{"code":"(fn [x y] (reduce #(conj % [(x %2) (conj (% (x %2) []) %2)]) {} y))","problem":63,"user":"4f045946535dcb61093f6bba"},{"problem":63,"code":"#(reduce (partial merge-with concat) (map (fn [v] {(% v) [v]}) %2))","user":"4f5eda39e4b0030a34fb2b56"},{"problem":63,"code":"(fn [f items]\n  (reduce \n   (fn [result item] \n     (let [key (f item)]\n       (assoc result \n              key \n              (conj (get result key [])\n                    item))))\n   {} \n   items))","user":"524ab5f2e4b09eba1c02239d"},{"problem":63,"code":"#(reduce (fn [m x] (update-in m [(% x)] concat [x])) {} %2)","user":"5603c31fe4b04bb52996e1c1"},{"problem":63,"code":"#(reduce (fn [m elem] (let [f %1] \n  (let [r (f elem)]\n    (if (contains? m r)\n      (assoc m r (conj (m r) elem))\n      (assoc m r [elem]) ))))\n        \n{} %2)","user":"54e51c7be4b024c67c0cf7f7"},{"problem":63,"code":"(fn [pred s] \n  (reduce \n   (fn [x y] (update-in x [(pred y)] \n               #(if (empty? %1) [%2] (conj %1 %2)) y))    \n   {} s))","user":"5292feb4e4b0239c8a67af39"},{"code":"(fn [f s]\n  (reduce (fn [sum n] (merge sum {(f n) (conj (or (get sum (f n) [])) n)})) {} s)\n)","problem":63,"user":"5303a027e4b0d8b024fd3745"},{"problem":63,"code":"#(apply merge-with concat (for [v %2]\n                          {(%1 v) [v]}))","user":"5b0b8d29e4b0cc2b61a3bdd7"},{"problem":63,"code":"(fn [f s] (reduce #(merge-with concat %1 {(f %2) (list %2)}) {} s))","user":"534bfc71e4b084c2834f4a88"},{"code":"(fn [f coll]\n  (reduce (fn [kv x]\n    (let [res (f x)]\n      (assoc kv res (if (kv res) (conj (kv res) x) [x])))) {} coll))","problem":63,"user":"5131d817e4b06942423563ca"},{"problem":63,"code":"(fn[f x]\n (into {} (merge \n  (map \n   (fn[g]\n    [\n     (first(first g))\n     (map \n      (fn[g1] \n       (second g1)\n      )\n      g\n     )\n    ]      \n   )      \n   (partition-by\n    first\n    (sort-by first\n     (map\n      (fn[x y] [x y])\n      (map f x)\n      x\n     )\n    )\n   )\n  )\n ))\n)","user":"54283a7ae4b01498b1a71b2f"},{"problem":63,"code":"(fn [f coll]\n  (let [x (map f coll)]\n    (loop [k x v coll r {}]\n      (cond\n       (empty? k) r\n       (contains? r (first k)) (recur (next k) (next v) (update-in r [(first k)] #(concat % [(first v)])))\n       :else (recur (next k) (next v) (assoc r (first k) [(first v)]))))))","user":"574abbfbe4b02ea114799200"},{"code":"(fn [f s]\n  (letfn [(add-one [m k v]\n            (assoc m k (conj (get m k []) v)))]\n    (reduce #(add-one %1 (f %2) %2) {} s)))","problem":63,"user":"4f68c485e4b07046d9f4ef7c"},{"code":"(fn [f s] (reduce (partial merge-with concat)\n                         (map #(apply hash-map %)\n                              (partition 2 (interleave (map f s) (map vector s))))))","problem":63,"user":"4e4be570535dc968683fc4d8"},{"problem":63,"code":"(fn [mapper v]\n  (loop [vrem v acc {}]\n    (println vrem)\n    (if (empty? vrem) acc\n    (let [pk (first vrem)\n          k (mapper pk)\n          v (get acc k [])]\n      (recur (rest vrem) (merge acc {k (conj v (first vrem))}))))))","user":"5c1edf23e4b0efcb0b05b25d"},{"problem":63,"code":"(fn my-group-by [f s]\n  (reduce\n   (fn [m e]\n     (assoc m (f e) (concat (m (f e)) [e])))\n   {}\n   s))","user":"5896a0e6e4b00487982d52a8"},{"code":"(fn\n[f coll] \n(persistent!\n   (reduce\n    (fn [ret x]\n      (let [k (f x)]\n        (assoc! ret k (conj (get ret k []) x))))\n    (transient {}) coll)))","problem":63,"user":"50ff44b4e4b017584cb41ccc"},{"problem":63,"code":"(fn [f coll]\n    (reduce (fn [acc item]\n              (update-in acc [(f item)] #((fnil conj []) % item)))\n            {}\n            coll))","user":"5ef8e9e0e4b09b61f08553cb"},{"code":"(fn [f l]\r\n  (loop [a (reverse l) b {}]\r\n    (if (empty? a)\r\n      b\r\n      (recur (rest a) \r\n             (if (contains? b (f (first a)))\r\n               (assoc b (f (first a)) \r\n                      (cons (first a)\r\n                            (b (f (first a)))))\r\n               (assoc b (f (first a))\r\n                      [(first a)]))))))","problem":63,"user":"4fd8544be4b0dab7d829f390"},{"code":"(fn [a b] (let [m (reverse (apply sorted-set (map a b)))]\n  (zipmap m (map (fn [x] (vec (filter #(= (a %) x) b))) \nm))))","problem":63,"user":"4e6e6630535d5021c1a89609"},{"code":"(fn [f xs] (reduce #(merge-with concat %1 %2) (map #(-> {(f %) [%]}) xs)))","problem":63,"user":"4e96557d535dbda64a6f6b43"},{"problem":63,"code":"#(reduce (fn [a e] (assoc a (% e) (conj (get a (% e) []) e))) {} %2)","user":"577202d2e4b0979f896515c0"},{"problem":63,"code":"(fn [f s] (reduce (fn [done todo] (assoc done todo (filter #(= todo (f %1)) s))) {} (set (map f s))))","user":"567f988be4b0feffd0d18ebe"},{"code":"(fn [f m] (into {} (for [i (into #{} (map f m))] [i (filter #(= i (f %)) m )])))","problem":63,"user":"4e43b0d9535dc968683fc4a3"},{"problem":63,"code":"(fn group-seq [f x]\n  (let [nkeys (map (fn [e] [(f e) e]) x)]\n    (reduce (fn [ret e] (assoc ret (first e) (conj (get ret (first e) []) (second e))))\n            {} nkeys)))","user":"5c547cf0e4b0fb8c5ffd9a0b"},{"problem":63,"code":"(fn [f coll] (into {} (map #(vector (f (first %)) (vec %)) (partition-by f (sort coll)))))","user":"564d3169e4b0284900eef67c"},{"code":"(fn my-gr [f l]\n  \n  (reduce (fn [acc,e]\n          \n          (merge-with concat acc (hash-map (f e) (list e) ))       \n            \n          ) {} l)\n  \n  )","problem":63,"user":"5180dc04e4b06b8caf33fa01"},{"code":"(fn [f coll]\n  (reduce\n   (fn [o x]\n     (let [k (f x)]\n       (assoc o k (conj (get o k []) x))))\n   {} coll))","problem":63,"user":"4ebc829e535dfed6da9c6d86"},{"problem":63,"code":"(fn\n  [f coll]\n  (reduce\n    (fn [group-map x]\n      (let [v (f x)\n            group (get group-map v)]\n        (assoc group-map v (conj (vec group) x))))\n    {}\n    coll))","user":"5c24671be4b07e362c2305a1"},{"problem":63,"code":"(fn my-grouping\n      [groupfn coll]\n      (let [places (map groupfn coll)\n            bins (set places)\n            elms (for [curbin bins]\n                   (vec (filter #(= (groupfn %) curbin) coll))\n                   )\n            ]\n        (zipmap bins elms)\n        )\n      )","user":"536827f1e4b0243289761e8a"},{"problem":63,"code":"(fn group [f [first & rest :as seq]]\n  (if (empty? seq) {}\n    (let [rest-map (group f rest)\n          key (f first)]\n      (assoc\n        rest-map\n        key\n        (cons first (get rest-map key []))\n        )))\n  )","user":"55ddc5cbe4b050e68259b3d0"},{"code":"(fn [f coll] (reduce (fn [res x]\n                        (assoc res\n                          (f x)\n                          (conj \n                                (get res (f x) []) x)))\n                      {}\n                      coll))","problem":63,"user":"4f702dcae4b07046d9f4eff4"},{"code":"(fn [f c]\n  (loop [col c, acc {}]\n    (if (seq col)\n       (let [i (first col), k (f i), ve (get acc k [])]\n         (recur (next col) (assoc acc k (conj ve i))))\n       acc)))","problem":63,"user":"4eeaf88f535d93acb0a668a3"},{"problem":63,"code":"(fn [f xs] \n  (reduce \n    (fn [m n] \n      (assoc m (f n) \n        (conj (get m (f n) [] ) n) )\n    ) \n    {}\n    xs\n))","user":"58335c22e4b089d5ab817c9a"},{"code":"(fn [pred coll]\n   (->> (map #(hash-map (pred %) [%]) coll)\n        (apply merge-with concat)))","problem":63,"user":"4fa05b99e4b0dcca54ed6d47"},{"code":"#(reduce (fn [c [k v]] (merge-with concat c {k [v]})) {}\n          (map vector (map %1 %2) %2 ))","problem":63,"user":"4e4870d1535dc968683fc4bc"},{"code":"(fn group-by-2 [f coll] (reduce #(assoc %1 (f %2) (conj (get %1 (f %2) []) %2)) {} coll))","problem":63,"user":"52f10094e4b05e3f0be25ee8"},{"problem":63,"code":"(fn [f l] (into {} (for [k (set (map f l))] [k (into [] (filter #(= (f %) k) l))])))","user":"5d3ae729e4b01671435dbd5d"},{"problem":63,"code":"(fn [f coll]\n  (apply merge-with concat\n         (for [e coll\n               :let [result (f e)]]\n           {result [e]})))","user":"510a3cd4e4b06956752d35ad"},{"problem":63,"code":"(fn my-group-by [f s] \n  (reduce (fn [m e] \n            (let [key (f e)\n                  group (get m key)]\n             (assoc m key \n                    (if (nil? group) \n                      [e] \n                      (conj group e))))) \n          {} s))","user":"5ea6fe98e4b00a66d4a951b2"},{"code":"(fn [f l]\n  (let [vs (set (map f l))]\n    (into {} (map #(vec [% (filter (fn [x] (= % (f x))) l)]) vs))))","problem":63,"user":"515ffbfbe4b0e2be8aa20bdd"},{"code":"(fn [f coll]\n  (reduce\n   #(let [k (f %2)]\n      (assoc %1 k (conj (get %1 k []) %2))\n      )\n   {} coll\n   )\n  )","problem":63,"user":"52e59ca5e4b09f7907dd1464"},{"code":"#(reduce (fn [m v] (assoc m (% v) (conj (m (% v) []) v))) {} %2)","problem":63,"user":"52746701e4b03e8d9a4a74a2"},{"code":"(fn grp-by [f xs]\n  (if (seq xs)\n    (let [r (grp-by f (rest xs))\n          v (first xs)\n          k (f v)\n          curr (get r k [])]\n      (assoc r k (cons v curr)))\n    {}))","problem":63,"user":"523c6451e4b07becd5be2222"},{"problem":63,"code":"(fn __ [f vv] (apply merge-with concat (map hash-map (map f vv) (map vector vv))))","user":"560843dee4b046a4fc0ac00e"},{"problem":63,"code":"(fn [f s] (apply merge-with into (map (fn [e] {(f e) [e]}) s)))","user":"554a270fe4b0a04f79299570"},{"problem":63,"code":"(fn my-group-by [func coll]\n  (reduce (fn [a b] (let [value (func b)] \n              (if (contains? a value)(assoc-in a [value] (conj (a value) b)) (assoc a value [b])))) {} coll))","user":"539b4268e4b0b51d73faaf1c"},{"problem":63,"code":"(fn myg [f coll]\n  (reduce (fn [r x] \n            (assoc r (f x) (conj (vec (get r (f x))) x))) \n          {} \n          coll))","user":"5587d8b3e4b059ccff29b1e8"},{"problem":63,"code":"#(apply merge-with clojure.set/union  (mapv (fn [i] {(%1 i) [i]}) %2))","user":"56754c4be4b05957ce8c6149"},{"code":"(fn [f s]\n  (reduce #(assoc %1 (f %2) (conj (get %1 (f %2) []) %2)) {} s))","problem":63,"user":"51780bfce4b0f89a8f53839c"},{"code":"(fn[f s] \n  (reduce (fn[a b] (merge-with #(concat %1 %2) a b))\n    (map hash-map (map f s) (map list s))))","problem":63,"user":"507c7c8be4b0b083f3ff82ef"},{"problem":63,"code":"(fn func [f xs]\n    (reduce\n     (fn [ret x]\n       (let [k (f x)]\n         (assoc ret k (conj (get ret k []) x))))\n     {} xs))","user":"5ff64845e4b06df49cee1495"},{"problem":63,"code":"(fn [f xs]\n  (reduce\n    (fn [m x] (let [r (f x)] (assoc m r (conj (get m r []) x))))\n    {}\n    xs))","user":"564a5a09e4b0284900eef656"},{"problem":63,"code":"(fn gb [f xs]\n  (let [ks (map f xs)]\n    (apply merge-with concat (map #(-> {%1 [%2]}) ks xs))))","user":"58ef4db9e4b056aecfd47dc6"},{"code":"(fn [f s]\n (into {}  (map (fn [v] {v (vec (filter #(= v (f %)) s))}) (set (map f s)))))","problem":63,"user":"515ff4b9e4b0e2be8aa20bd9"},{"problem":63,"code":"(fn [f s] (reduce (fn [groups k] (into groups {(f k) (conj (groups (f k) []) k)})) {} s))","user":"5db92996e4b010eb3c36cd50"},{"code":"(fn  [f s]\n  (apply merge-with concat (map #(hash-map (f %) [%]) s)))","problem":63,"user":"4dd0e8f7535da60f04a96e57"},{"code":"(fn newmap [f1 s1] (reduce #(assoc %1 (f1 %2) (conj (get %1 (f1 %2) []) %2)) (sorted-map) s1))","problem":63,"user":"4dadca03c9a9d6ed4199dc57"},{"problem":63,"code":"(fn [f xs]\n  (letfn [(go [rs ys]\n            (if (empty? ys)\n              rs\n              (let [[y & ys'] ys\n                    r (f y)]\n                (go (update-in rs [r] (fnil #(conj % y) []))\n                      ys'))))]\n    (go {} xs)))","user":"53ef7f77e4b0742d9025b0ce"},{"code":"#(apply hash-map \n    (mapcat (fn [x] [(% (first x)) x]) \n      (partition-by % (sort-by % %2))))","problem":63,"user":"4eaede1f535d7eef30807329"},{"code":"(fn group-seq \r\n  ([x y] \r\n    (group-seq x y {}))\r\n  ([x y z]\r\n    (if (= 0 (count y))\r\n      z\r\n      (let [applied (x (first y))]\r\n        (if (contains? z applied)\r\n          (recur x (rest y) (update-in z [applied] conj (first y)))\r\n          (recur x (rest y) (conj z {applied (vector (first y))})))))))","problem":63,"user":"4e16bdef535d04ed9115e7e9"},{"problem":63,"code":"(fn my-group-by\n  [f s]\n  (reduce\n    (fn [m x]\n      (let [k (f x)]\n        (assoc m k (conj (get m k []) x)))) {} s))","user":"5574c172e4b05c286339e059"},{"code":"(fn [func coll] (reduce #(assoc %1 (func %2) (conj (%1 (func %2) []) %2)) {} coll))","problem":63,"user":"51b7b521e4b0d906fcd71d3a"},{"problem":63,"code":"(fn [f is] \n  (reduce #(let [key (f %2)] (assoc %1 key (conj (get %1 key []) %2)))\n          {}\n          is))","user":"52e851bfe4b09f7907dd149a"},{"problem":63,"code":"(fn [func myseq]\n  (into {} (map #(vector (func (first %)) (vec %))\n                (partition-by func (sort myseq)))))","user":"53e76bb2e4b036ad0777e47d"},{"problem":63,"code":"(fn [f coll]\n\t(let [part (partition-by f (sort-by f coll))]\n\t(zipmap (map #(f (first %)) part) part)\n\t))","user":"565b941ce4b068f2fe63dc07"},{"problem":63,"code":"#(reduce (fn [m s]\n           (let [k (% s)]\n             (update-in m [k] concat [s]))) {} %2)","user":"57c0393be4b05aa3c4741c90"},{"code":"(fn gb [f s]\r\n  (loop [m {}, f1 f, xs s]\r\n    (if (empty? xs)\r\n      m\r\n      (recur (assoc m (f1 (first xs)) \r\n                   (vec (conj (get m (f1 (first xs))) (first xs))))\r\n             f1\r\n             (rest xs)))))","problem":63,"user":"4e123905535d04ed9115e7ce"},{"code":"(fn [p s] (apply merge-with concat (map hash-map (map p s) (map vector s))))","problem":63,"user":"51805d22e4b0e3fc13e244df"},{"code":"(fn [f coll]\r\n   (apply merge-with concat\r\n               (map #(hash-map (f %) [ %]) coll)))","problem":63,"user":"51a54fb4e4b0def3c5c586a3"},{"problem":63,"code":"#(reduce (fn [m x] (update-in m [(% x)] (fnil conj []) x)) {} %2)","user":"50ef4e2be4b0a78662fa2653"},{"problem":63,"code":"(fn groupBy\n  [filterBy args]\n  (apply merge-with concat (map #(hash-map %1 [%2]) (map filterBy args) args)))","user":"57131dfbe4b07c98581c3a98"},{"problem":63,"code":"(fn my-group-by [f coll]\n  (apply merge-with concat  (map #(hash-map (f %) [%]) coll)))","user":"5630fd6fe4b0bfe05bf1178b"},{"problem":63,"code":"(fn group-it [f s]\n\t(loop \n      [x (first s)\n       rest-of-s (rest s) \n       group-map {}]\n  \t\t(cond \n       \t\t(nil? x) group-map\n        \t:else (recur (first rest-of-s) \n                         (rest rest-of-s)\n                         (cond \n                         \t(get group-map (f x)) (into group-map (hash-map (f x) (concat (get group-map (f x)) (vector x))))\n                          \t:else (into group-map (hash-map (f x) (vector x))))\n                         ))))","user":"52b71bd2e4b0c58976d9ad4d"},{"problem":63,"code":"(fn [f coll]\n  (reduce (fn [acc v]\n            (assoc acc (f v) (if (acc (f v))\n                               (conj (acc (f v)) v)\n                               [v]))) {} coll))","user":"5a250b86e4b07f18be40aa19"},{"problem":63,"code":"(fn [f ss]\n             (reduce (fn [m s]\n                       (let [fs (f s)\n                             v (or (get m fs) [])]\n                         (assoc m fs (conj v s))))\n                     {}\n                     ss))","user":"57f904c5e4b0d3187e900936"},{"problem":63,"code":"(fn [f xs] (apply merge-with into (for [v xs] { (f v) [v]})))","user":"58ac513fe4b0005cfeb1a746"},{"code":"(fn [f x]\n  (reduce #(assoc %1 (f %2) (concat (%1 (f %2) []) [%2])) {} x))","problem":63,"user":"521249f5e4b06aa6d1666ba2"},{"problem":63,"code":"(fn [f xs]\n  (reduce (fn [m x](assoc m (f x) (conj (get m (f x) []) x))) {} xs))","user":"567c63f6e4b05957ce8c61bb"},{"problem":63,"code":"#(reduce (fn [accum, x]\n           (assoc accum (%1 x) (conj (accum (%1 x) []) x)))\n         {}\n         %2)","user":"56a38a4ce4b0542e1f8d14cc"},{"problem":63,"code":"(fn [f s] (let [r (partition-by f (sort-by f s))] (apply hash-map (interleave (map #(f (first %)) r) r))))","user":"586bc870e4b01531a375e964"},{"problem":63,"code":"(fn [f s]\n  (reduce #(assoc %1 (f %2) (conj (%1 (f %2) []) %2)) {} s))","user":"53f77b6ae4b0de5c4184855f"},{"problem":63,"code":"(fn gby [f coll]\n  (let [keys (->> (map f coll)\n                  (into #{})\n                  (map (fn [k] {k []}))\n                  (reduce merge))]\n    (reduce (fn [a v]\n              (let [k (f v)]\n                (println a k v)\n                (assoc a k (conj (get a k) v)))) keys coll)))","user":"5ff8ead1e4b06df49cee14ab"},{"code":"(fn [f s]\n  (reduce (fn [m [a b]]\n            (assoc m a\n              (if (contains? m a)\n                (conj (m a) b)\n                [b])))\n          {}\n          (for [a s] [(f a) a])))","problem":63,"user":"50ed4626e4b01236b1d4983c"},{"problem":63,"code":"(fn [pred coll]\n    (reduce\n     (fn [dict m]\n       (let [ret (pred m)]\n         (assoc dict ret (conj (or (dict ret) []) m))))\n     {} coll))","user":"55c5b55fe4b0e31453f649b5"},{"code":"(fn [f col] (reduce #(assoc % (f %2) (conj (get % (f %2) []) %2)) {} col))","problem":63,"user":"528a791ae4b0239c8a67ae77"},{"problem":63,"code":"#(apply merge-with (fn [result latter] (concat result latter)) ((fn [f c] (map (fn [x] {(f x) [x]}) c)) %1 %2))","user":"5b7bc82ce4b047b03b203726"},{"code":"(fn [f q]\n   (reduce\n      #(conj %\n        \t(let [val (f %2)]\n\t\t\t\t{val\n    \t        \t(if (contains? % val)\n        \t           (conj (% val) %2)\n            \t       [%2])}))\n    {} q))","problem":63,"user":"4dbdc898535d020aff1edf4a"},{"problem":63,"code":"(fn\n  [f s] (apply merge-with into (for [x s] {(f x) [x]})))","user":"5a04e923e4b01bb0ae8afda9"},{"problem":63,"code":"(fn new-group-by\n  [fun coll]\n  (let [new-coll (map #(assoc {} (fun %) [%]) coll)]\n    (apply merge-with (cons concat new-coll))))","user":"550d9452e4b06e50f9beb15d"},{"code":"(fn [f l] \r\n  (reduce \r\n    (fn [a x]\r\n      (merge-with concat a {(f x) [x]})) {} l))","problem":63,"user":"4ddbd934535d02782fcbe9fc"},{"code":"(fn [f xs]\n (reduce\n  (fn [a b] (update-in a [(f b)] #(conj (if (vector? %) % []) b)))\n  {}\n  xs))","problem":63,"user":"5097b556e4b00ad8bab4e970"},{"problem":63,"code":"(fn [f c]\n  (reduce #(update-in % [(f %2)] (fn [x] (concat x [%2])))\n          {}\n          c))","user":"57c796b4e4b05aa3c4741d08"},{"code":"(fn m [f c]\n  (reduce (partial merge-with concat) (map #(hash-map (f %) [%]) c)))","problem":63,"user":"52828298e4b0757a1b17145b"},{"problem":63,"code":"(fn my-group-by [f coll]\n  (reduce (fn [map x]\n            (assoc\n             map\n             (f x)\n             (conj (get map (f x) []) x)))\n          {}\n          coll))","user":"60537cd1e4b04c8f2157d152"},{"problem":63,"code":"(fn my-group-by\n  [fun lst]\n  (->>\n    (map list lst)\n    (interleave (map (fn [x] (fun x)) lst))\n    (partition 2)\n    (map (fn [x] (hash-map (first x) (second x))))\n    reverse\n    (apply merge-with into)))","user":"59e8fef3e4b0249b72820743"},{"code":"(fn [f coll]\n    (apply (partial merge-with concat) (map (fn [x] {(f x) [x]}) coll)))","problem":63,"user":"50bc23e4e4b0594b91591c3c"},{"problem":63,"code":"#(loop [f %1 s%2 r {}]\n  (if (empty? s)\n    r\n    (let [x (first s) k (f x)]\n    (recur f (rest s) (assoc r k (conj (get r k []) x))))))","user":"594263cbe4b060784b3b790a"},{"code":"(fn [f s] (reduce #(merge-with concat % {(f %2) [%2]} ) {} s) )","problem":63,"user":"520cb8c4e4b0b022ef140c9a"},{"problem":63,"code":"(fn [f coll] \n   (reduce \n    (fn [m p] \n      (let [[k v] p] \n        (assoc m k \n               (if (m k) \n                 (conj (m k) v) \n                 (vector v)))))\n    {}    \n    (map #(vector (f %) %) coll)\n    ) \n   )","user":"55249f64e4b0882d96d091c6"},{"code":"#(letfn [(worker [l f s]\r\n           (if (empty? l)\r\n             s\r\n             (recur (rest l) f\r\n                    (let [v (f (first l)) i (find s v)]\r\n                      (if i\r\n                        (assoc s v (conj (val i) (first l)))\r\n                        (assoc s v [(first l)]))))))]\r\n   (worker %2 %1 {}))","problem":63,"user":"4f474f43e4b0d56e7bb92bb7"},{"problem":63,"code":"(fn [f xs]\n  (reduce\n    (fn [memo el]\n      (let [v (f el)]\n        (if (get memo v)\n          (update-in memo [v] conj el)\n          (assoc memo v [el]))))\n    {} xs))","user":"59fa241ee4b0ca45a743a358"},{"problem":63,"code":"(fn group-seq [f s]\n  (loop [x    (first s)\n         col  s\n         res  {}]\n      (if (empty? col) res (recur (first (rest col)) (rest col) (assoc res (f x) (vec (conj (get res (f x)) x)))))\n    )\n  )","user":"56a94562e4b07966d5a8a074"},{"code":"(fn [f coll]\n        (reduce \n             (fn [coll val]\n               (let [result (f val)\n                     curr-list (coll result)\n                     results (if curr-list  \n  \t\t\t\t\t\t\t(assoc curr-list (count curr-list) val)\n                                [val])]\n                   (assoc coll result results)))\n             {} \n             coll\n          ))","problem":63,"user":"4ddee37c535d08e6dec9fddc"},{"problem":63,"code":"(fn [f coll]\n  (reduce\n    (fn [acc x]\n      (let [k (f x)\n            xs (get acc k [])]\n        (assoc acc k (conj xs x)))) {} coll))","user":"54e540c1e4b024c67c0cf7f9"},{"code":"(fn my-group-by\n  [f s]\n  (reduce #(update-in %1 [(f %2)] concat [%2]) {} s))","problem":63,"user":"51701a9ce4b034fe8eaf70f5"},{"code":"(fn [f s]\n   (reduce\n    #(assoc %1 (f %2) (conj (get %1 (f %2) []) %2))\n    {} s))","problem":63,"user":"50cae881e4b0f75dcc9a6e51"},{"problem":63,"code":"(fn [f vs]\n  (let [pairs (map #(vector (f %) %) vs)\n        groups (map (fn [[k v]]\n                      [k (map second (filter (fn [[k' v']] (= k k')) pairs))])\n                    pairs)]\n    (into {} groups)))","user":"53fb5256e4b0de5c4184857f"},{"problem":63,"code":"(fn [f c] \n   (loop\n     [f f c c m {}]\n     (if (empty? c) \n       m \n       (recur \n        f \n        (butlast c) \n        (#(conj m { % (cons (last c) (get m % '())) }) \n          (f (last c))) ) )))","user":"54cbe00ee4b057c6fda3a285"},{"problem":63,"code":"(fn [f col]\n  (reduce \n   #(merge-with concat %1 (assoc {} (f %2) (vector %2)))\n   {} col))","user":"584f5133e4b0b7285a6f4e61"},{"code":"(fn\n  [f s]\n  (let* [coll    (map #(vector % (f %)) s)\n         results (distinct (map second coll))]\n  \t(into {} (for [k results]\n               [k (map first (filter #(= (second %) k) coll))]))))","problem":63,"user":"511b233ae4b07ab9ec456180"},{"problem":63,"code":"(fn\n  [f coll]\n  (reduce\n    (fn [s x]\n      (let [v (f x)]\n        (if (not (contains? s (f x)))\n          (assoc s v [x])\n          (update-in s [v] conj x)) ))\n    {}\n    coll))","user":"50ec409ce4b04edc33777045"},{"problem":63,"code":"(fn [f coll]\n  (reduce (fn [acc v]\n            (let [k (f v)]\n              (if (acc k)\n                (update-in acc [k] concat [v])\n                (assoc acc k [v]))))\n          {}\n          coll))","user":"5f6d4305e4b02876ed9fd05c"},{"code":"(fn grpby [f coll]  \n  (persistent!\n   (reduce\n    (fn [ret x]\n      (let [k (f x)]\n        (assoc! ret k (conj (get ret k []) x))))\n    (transient {}) coll)))","problem":63,"user":"5003bb77e4b0678c553fc442"},{"problem":63,"code":"(fn\n  [f s]\n  ((fn build-map\n     [map kvs]\n     (if-let [s (seq kvs)]\n       (build-map (if (get map (get (first s) 0))\n                    (assoc map (get (first s) 0) (conj (get map (get (first s) 0)) (get (first s) 1)))\n                    (assoc map (get (first s) 0) [(get (first s) 1)]))\n                  (rest s))\n       map))\n   {}\n   (map #(vector (f %) %) s)))","user":"5ec02e20e4b00a66d4a95288"},{"problem":63,"code":"(fn [f xs]\n  (let [m {}\n        f_red (fn [acc x]\n                (let [cur-val (get acc (f x) [])]\n                   (assoc acc (f x) (conj cur-val x))))]\n    (reduce f_red m xs)))","user":"5573ffb5e4b0aa18f790f3fd"},{"problem":63,"code":"(fn [f xs] \n  (reduce \n   (fn [res x] \n     (let [key (f x)]\n       (update-in res [key] (fnil #(conj % x) [])))) \n   {} xs))","user":"54149f2fe4b01498b1a719ec"},{"code":"(fn[x,y] (reduce (fn[a,b] (assoc a (x b) (sort (conj (a (x b)) b)))) {} y))","problem":63,"user":"4fb3dd1ee4b081705acca2a5"},{"problem":63,"code":";; java.lang.RuntimeException: Unable to resolve symbol: update in this context, compiling:(NO_SOURCE_PATH:0)\n;; (fn [f xs]\n;;    (reduce\n;;     (fn [acc item]\n;;       (update acc (f item) #(if % (conj % item) [item])))\n;;     {}\n;;     xs))\n\n(fn [f xs]\n  (reduce\n   (fn [acc item]\n     (let [k (f item)\n           v (get acc k)]\n       (assoc acc k (if v (conj v item) [item]))))\n   {}\n   xs))","user":"5b96800ae4b0c0b3ffbd4a7b"},{"code":"(fn [f xs]\n  (reduce #(let [agg %1 k (f %2) v %2]\n            (conj agg [k (conj (agg k []) v)] ))\n          (hash-map)\n          xs))","problem":63,"user":"4f03f3b7535dcb61093f6b85"},{"problem":63,"code":"(fn [f a] (reduce #(let [k (f %2) v (get %1 k)] (assoc %1 k (conj (or v []) %2))) {} a))","user":"54f26266e4b024c67c0cf8c5"},{"problem":63,"code":"(fn my-group-by [f coll]\n  (reduce (fn [map x]\n            (assoc map (f x) (conj (get map (f x) []) x)))\n            {} coll))","user":"546c1f73e4b00cfc9eacc175"},{"problem":63,"code":"(fn [f coll]\n    (if-let [s (seq coll)]\n      (reduce #(let [x (f %2) elem  (%1 x [])]\n                (into %1 {x (conj elem %2)})) \n              {} coll)\n      {}))","user":"55aa1637e4b0988bba2ad949"},{"code":"(fn my-group-by [f xs]\r\n  (loop [res {}\r\n         xs xs]\r\n    (if (first xs)\r\n      (let [x (first xs)\r\n            xs (next xs)\r\n            res (merge-with concat res {(f x) [x]})]\r\n        (recur res\r\n               xs))\r\n      res)))","problem":63,"user":"4dd023dd535d5973398f92ad"},{"problem":63,"code":"(fn [f coll]\n      (persistent!\n        (reduce\n          (fn [ret x]\n              (let [k (f x)]\n                   (assoc! ret k (conj (get ret k []) x))))\n          (transient {}) coll)))","user":"560c37b5e4b05f002753df2e"},{"problem":63,"code":"(fn [f xs]\n  (let [m (map (juxt f identity) xs)]\n    (reduce \n      (fn [r k] (assoc r k (map second (filter #(= k (first %)) m))))\n      {} (distinct (map first m)))))","user":"5e2549c8e4b05b4b0151615f"},{"problem":63,"code":"(fn [f s] (reduce (fn [m x] (assoc m (f x) (conj (m (f x) []) x))) {} s))","user":"5f2c02d1e4b033932238a65f"},{"problem":63,"code":"(fn my-group [f coll]\n  (let [s (map vec (partition-by f (sort-by f coll)))]\n    (zipmap (map #(f (first %)) s) s)))","user":"58a6806ee4b01a0c0b23292f"},{"problem":63,"code":"(fn [f s]\n  (reduce\n   (fn [m v]\n     (let [t (f v)\n           coll (-> (get m t [])\n                    (concat [v]))]\n       (assoc m t coll)))\n   {}\n   s))","user":"5cf6522be4b0b71b1d808a58"},{"code":"(fn [f s]\n  (reduce \n    #(merge-with concat % {(f %2) [%2]} )\n    {}\n    s))","problem":63,"user":"4f991ec1e4b0dcca54ed6cfb"},{"code":"(fn z[function values]\n      (loop [base {}\n            remaining values]\n        (if (empty? remaining)\n          base\n          (recur \n            (let [f (first remaining)\n                  v (function f)\n                  values-collection (get base v [])]\n              (assoc base v (conj values-collection f)))\n           (rest remaining)))))","problem":63,"user":"52bdd135e4b07a9af579230a"},{"problem":63,"code":"(fn [f xs]\n  (reduce \n   (fn [acc x]\n     (assoc acc (f x) (conj (vec (get acc (f x))) x)))\n   {}\n   xs))","user":"52430d3ce4b076204b44faa5"},{"problem":63,"code":"(fn f\n    [fun lst]\n    (loop\n      [lst lst\n       result {}]\n      (cond (empty? lst) result\n            :else        (let [elem (first lst)\n                               rst (rest lst)\n                               value (fun elem)]\n                           (cond (contains? result value) (recur rst (assoc result value (conj (result value) elem)))\n                                 :else                    (recur rst (assoc result value [elem])))))))","user":"56df62eee4b0ca2494a095f0"},{"code":"(fn [f s]\n     (loop [ret {} c s]\n       (if (seq c)\n         (let [h (first c) k (f h)]\n           (if (contains? ret k)\n             (recur (assoc ret k (conj (ret k) h)) (rest c))\n             (recur (assoc ret k (vector h)) (rest c))))\n         (identity ret))))","problem":63,"user":"4f9920a3e4b0dcca54ed6cfc"},{"problem":63,"code":"(fn [f xs]\n  (reduce #(update-in %1 (vector (f %2)) conj %2) {} (reverse xs)))","user":"52540bcce4b0541d1855b952"},{"problem":63,"code":"(fn [f s]\n   (reduce\n    (fn [m v]\n      (update-in\n       m\n       [(f v)]\n       #(into (vec %) [v])))\n    {}\n    s))","user":"540e0637e4b0addc1aec6717"},{"problem":63,"code":"(fn [f xs]\n  (reduce (fn [m x] (assoc m (f x) (conj (get m (f x) []) x))) {} xs))","user":"5799ff45e4b05b1deef9add1"},{"problem":63,"code":"(fn my-group-by [func s]\n  (reduce (fn [result el]\n            (let [key (func el)\n                  vals (if (contains? result key) (conj (get result key) el) [el])]\n              (assoc result key vals))) {} s))","user":"59837909e4b021a7a535fe16"},{"problem":63,"code":"(fn [f s]\n  (reduce (fn [m v]\n            (update-in m\n            [(f v)]\n            #(conj (or % []) v)))\n          {}\n          s))","user":"5d45749be4b07c84aa5ae6a2"},{"problem":63,"code":"(fn group-by' [f nilai]\n  (apply merge-with into (for [x nilai] {(f x) [x]})))","user":"55d9743ae4b0e31453f64aca"},{"problem":63,"code":"(fn [f coll]\n  (into {} (for [fval (set (map f coll))]\n             [fval (into [] (filter #(= fval (f %)) coll))])))","user":"56449e4de4b0284900eef5f9"},{"problem":63,"code":"(fn [f s]\n  (reduce \n   (fn [h e]\n     (let [k (f e)\n           v (h k [])\n           v2 (sort (conj v e))]\n      (assoc h k v2)\n     ))\n   {} s))","user":"559279b7e4b0604b3f94d58c"},{"problem":63,"code":"(fn [f s]\n  (let [ke (set (map f s))\n        res (map #(vector %1 %2) (map f s) s)]\n    (apply hash-map (mapcat identity\n           (for [a ke]\n             [a (vec (map second\n                          (filter #(= a (first %)) res)))])))))","user":"541ddadbe4b01498b1a71a84"},{"code":"(fn [f ls] (apply merge-with concat (map #(hash-map (f %) [%]) ls)))","problem":63,"user":"521dceeae4b050d5da042802"},{"problem":63,"code":"(fn grp-seq [func vals]  (into {} (map #(vector (func (first %)) (vec %)) (partition-by func (sort vals)))))","user":"5ae246b1e4b0837691e92c5d"},{"code":"(fn me [f l] (if (empty? l) {} (merge-with concat {(f (first l)) [(first l)]} (me f (rest l))) ))","problem":63,"user":"5349ac2be4b084c2834f4a67"},{"problem":63,"code":"(fn mgb [f coll] (let [res (fn res [f arr] (map #(vector (f %) %) arr))\n                         intoMap (fn intoMap [map [k v]] (if (map k) (assoc map k (conj (map k) v)) (assoc map k (vector v))))\n                         popMap (fn popMap [vs res] (if (empty? vs) res (recur (rest vs) (intoMap res (first vs)))))]\n                     (popMap (res f coll) {})))","user":"5b421edce4b02d533a91bc2c"},{"code":"(fn [f s] \n  (reduce \n    #(let [k (f %2)] (assoc %1 k (conj (get %1 k []) %2))) {} s))","problem":63,"user":"4ec18451535dfed6da9c6db0"},{"problem":63,"code":"(fn [f v]\n  (reduce #(let [r (f %2)]\n             (update-in %1 [r] (fn [a b] (vec (conj a b))) %2))\n          {} v))","user":"52cda397e4b07d0d72b2737a"},{"code":"#(loop [grouped-values {}\n        curr-list %2]\n   (if-not (seq curr-list)\n     grouped-values\n     (let [curr-val\t(first curr-list)\n           f-val \t(%1 curr-val)\n           map-val \t(grouped-values f-val [])]\n       (recur (assoc grouped-values\n                \t f-val \n                \t(conj map-val curr-val))\n              (rest  curr-list)))))","problem":63,"user":"531c7f0de4b08068f379eda4"},{"problem":63,"code":"(fn [p s] (let [m (set (map p s)) v (for [k m] (filter #(= k (p %)) s))] (zipmap m v)))","user":"549c22f7e4b0f3d1d8e70f86"},{"code":"(fn [func lst]\n  (reduce\n   #(if (contains? %1 (first %2))\n      (assoc %1 (first %2) (conj  (%1 (first %2)) (last %2)))\n      (assoc %1 (first %2) [(last %2)]))\n   {}\n   (map #(list (func %) %) lst)))","problem":63,"user":"523288fee4b035af41902a88"},{"problem":63,"code":"(fn gr [f coll]\n  (let [results (distinct (map f coll))]\n    (zipmap results (map (fn [x] (apply vector (filter #(= x (f %)) coll))) results))))","user":"53f5c402e4b0db01ade6f9d4"},{"problem":63,"code":"(fn [f s]\n     (reduce\n       (fn [so-far k]\n         (let [value (f k)\n               group (into (so-far value []) [k]) ;accessing an existing map entry, otherwise proposing an empty vector as default\n               groups (into so-far [[value group]])]\n           groups))\n          \n         \n         \n       {}\n       s))","user":"5b999af8e4b0c0b3ffbd4ad3"},{"code":"(fn [f s]\n  (reduce\n   (fn [a b]\n     (let [k (first b)\n           v (second b)\n           the-vec (get a k)] (assoc a k (if (nil? the-vec) (vector v) (conj the-vec v))))) '{} (partition 2 (interleave (map f s) s))))","problem":63,"user":"4f47eab2e4b0d56e7bb92bc6"},{"problem":63,"code":"(fn [f v] (reduce #(let [res (f %2)] (assoc %1 res (conj (get %1 res []) %2))) {} v))","user":"54c13b87e4b0ed20f4ff6f20"},{"problem":63,"code":"(fn group-seq\n  [f s]\n  (let [values (map #(hash-map (f %) (vector %)) s)]\n    (apply merge-with into values)))","user":"5c7dad57e4b0d597f478caba"},{"code":"(fn [f coll]\n  (reduce \n    #(update-in % [(f %2)] concat [%2])\n    {}\n    coll))","problem":63,"user":"4eccb190535d23f0362276fe"},{"problem":63,"code":"(fn [f s]\n  (reduce (fn [m e]\n    \t\t(let [k\t(f e)]\n      (assoc m k (conj (get m k []) e))))\n          {} s))","user":"579c8ad1e4b05b1deef9ae0c"},{"code":"(fn [f xs] \n  (reduce (fn [b x] (assoc b (f x) (conj (get b (f x) []) x))) {} xs))","problem":63,"user":"5158bba4e4b059418b97f0ab"},{"code":"(fn [f c] \n  (reduce\n    #(let [res (f %2) l (% res [])]\n      (conj % {res (conj l %2)}))\n    {}\n    c))","problem":63,"user":"4e9c81e8535dbda64a6f6b80"},{"problem":63,"code":"(fn [x y] \n   (into {} (for [g (distinct (map x y))]\n     (hash-map g (apply vector (filter #(= (x %) g) y))))))","user":"53a5c7ffe4b0ef122a8689c4"},{"problem":63,"code":"(fn [f s]\n  (reduce (fn [memo k]\n            (conj memo [k (filter #(= k (f %)) s)]))\n          {}\n          (distinct (map f s))))","user":"5338387de4b0e30313ee6c91"},{"problem":63,"code":"(fn once-more\n  [f coll]\n  (let [output {}]\n    (reduce (fn [out k]\n             (assoc out k \n                    (reduce (fn [vs [ky vl]]\n                              (if (= k ky) (conj vs vl) vs ))\n                            []\n                            (map vector (map f coll) coll)\n                            )) )\n            output\n            (set (map f coll)))))","user":"5ddbd202e4b0948ae9d9adb4"},{"code":"(fn my-group\n  [f v]\n  (reduce \n   (fn [m [mkey mval]]\n     (update-in m [mkey] #(concat % [mval])))\n   {}\n   (map #(list (f %) %) v)\n  ))","problem":63,"user":"5094057fe4b097f48cc38593"},{"problem":63,"code":"(fn [f coll] \n  (reduce #(assoc %1 (%2 0) (conj (get %1 (%2 0) []) (%2 1))) {} \n    (map (fn [x](vector (f x) x)) coll)))","user":"53fe1c3be4b0de5c418485f2"},{"code":"(fn [f c]\n  (reduce\n    #(let [k (f %2)]\n      (assoc % k (conj (% k []) %2)))\n    {}\n    c))","problem":63,"user":"4ee4f4a9535d1385b2869d85"},{"problem":63,"code":"(fn [f s] (let [kv (map (fn [x] [(f x) x]) s)] \n\t\t       (reduce #(assoc %1 (first %2) (conj (get %1 (first %2) []) (last %2) )) {} kv )))","user":"54d2b411e4b0e8a36923e5f9"},{"code":"(fn [f s] (into {} (map #(vector (f (first %)) (into [] %)) (partition-by f (sort-by f s)))))","problem":63,"user":"534f13b2e4b084c2834f4ac4"},{"problem":63,"code":"(fn[f s]\n  (reduce #(merge-with concat %1 {(f %2) [%2]}) {} s))","user":"53ed2fafe4b0d648e757f4c1"},{"problem":63,"code":"(fn [op v] (reduce (fn [p e]  (let [a (op e) v (get p a) v1 (if (nil? v) [] v )] (conj p {a (conj v1 e)})) ) {} v )  )","user":"58a9e872e4b01a0c0b232973"},{"code":"(fn [ f l ] \n  ( reduce \n    #(assoc %1 (f %2) (concat (%1 (f %2)) ( vector %2) ) ) \n    (cons {} l) ))","problem":63,"user":"4fc43a8ee4b081705acca346"},{"problem":63,"code":"(fn [func thing]\n  (loop [result {} c thing]\n    (if (empty? c) result\n      (let [v (func (first c))]\n        (if (nil? (result v))\n          (recur (assoc result v [(first c)])\n            (rest c))\n          (recur (assoc result v\n                   (conj (result v) (first c))) (rest c)))))))","user":"53d977f1e4b0e771c302547a"},{"code":"(fn ff[f s] \n  (if (empty? s) \n    {} \n    (let [res (ff f (rest s)) \n          key (f (first s)) \n          val (or (res key) '()) \n          nval (cons (first s) val)] \n      (assoc res key nval))))","problem":63,"user":"4f1fd734535d64f6031464a5"},{"problem":63,"code":"(fn my-group-by\n  [f coll]\n  (reduce\n   (fn [map num]\n     (update-in map [(f num)] #(vec (conj % num))))  \n   {}\n   coll))","user":"5a9829e5e4b0d174b936c788"},{"problem":63,"code":"(fn\n  [id-fn li]\n  (reduce\n   (fn\n     [m item]\n     (let\n       [id (id-fn item)]\n       (assoc\n         m\n         id\n         (conj (get\n                m\n                id\n                [])\n               item))))\n   {}\n   li))","user":"586a657de4b0f14aab7c88bd"},{"problem":63,"code":"(fn [func s]  (apply merge-with into (for [a s] {(func a) [a]})))","user":"6070c7bae4b069485764de27"},{"problem":63,"code":"(fn [f xs]\n  (reduce\n    (fn [m e]\n      (let [k (f e) curval (get m k []) newval (conj curval e)]\n        (assoc m k newval)))\n    {}\n    xs))","user":"5392bfdee4b0b51d73faaeb2"},{"problem":63,"code":"(fn [f s]\n  (reduce (fn [m v]\n    (let [k (f v)]\n      (assoc m k (conj (get m k []) v)))) {} s))","user":"53e3e353e4b036ad0777e406"},{"problem":63,"code":"(fn groupby [f coll]\n   (reduce (fn [m x]\n             (let [key (f x)]\n               (assoc m key (conj (m key []) x)))) {} coll))","user":"57ee804ee4b0bfb2137f5bbb"},{"code":"(fn [f s] (reduce (fn [o i] (assoc o (f i) (concat (o (f i)) [i]))) {} s))","problem":63,"user":"4f1d1d95535d64f603146488"},{"problem":63,"code":"(fn group [f s]\n  (if (empty? s)\n    {}\n    (let [item (first s)\n          map (group f\n                     (rest s))\n          key (f item)\n          value\n           (get map key [])]\n      (assoc\n       map key\n       (cons item value)))))","user":"598ab445e4b02b9968b84ce0"},{"code":"(fn [f s]\n  (letfn [(h [m f s]\n            (if (empty? s) m\n                (let [v (first s)\n                      k (f v)\n                      e (m k [])\n                      ep (conj e v)]\n                  (h (assoc m k ep) f (rest s)))))]\n    (h {} f s)))","problem":63,"user":"4ede8e1d535d10e5ff6f5339"},{"problem":63,"code":"(fn [f xs]\n  (reduce (fn [acc x] \n            (assoc acc (f x) (conj (get acc (f x) []) x))\n            ) {} xs))","user":"587fb546e4b0f1effa3b75f9"},{"problem":63,"code":"(fn [f s]\n  (reduce (fn [m x] (update-in m [(f x)] #(conj (or % []) x))) {} s))","user":"55337e61e4b09218d5f44f8e"},{"code":"(fn\n  [f coll]  \n  (persistent!\n   (reduce\n    (fn [ret x]\n      (let [k (f x)]\n        (assoc! ret k (conj (get ret k []) x))))\n    (transient {}) coll)))","problem":63,"user":"4eb0afed535d7eef3080733e"},{"problem":63,"code":"(fn [f seq]\n  (apply merge-with concat\n         (map #(hash-map (f %) [%]) seq)))","user":"5f1af439e4b0f565ad998257"},{"problem":63,"code":"(fn [f c] (reduce (fn [m e] (assoc m (f e) (conj (or (m (f e)) []) e))) {} c))","user":"57c7e7d9e4b05aa3c4741d0f"},{"code":"(fn [f s]\n  (reduce\n    (fn [acc v]\n      (assoc acc (f v) (conj (acc (f v) []) v)))\n    {}\n    s))","problem":63,"user":"5201ada5e4b0b2e020a18f14"},{"problem":63,"code":"(fn [f coll]\n  (reduce (partial merge-with concat)\n  \t(map #(hash-map (f %) [%]) coll)))","user":"546c4c5fe4b00cfc9eacc178"},{"problem":63,"code":"( fn [f c]\n  (reduce (fn [m e]\n   (let [k (f e)]\n     (assoc m k (conj (get m k []) e))\n     ))\n     {} c))","user":"4fd11a93e4b04c3a95aa040a"},{"problem":63,"code":"(fn g [f xs]\n   (reduce (fn [acc x]\n               (let [fx (f x)]\n               (assoc acc fx (into [] (conj (acc fx) x)))\n                            )\n             )\n             {}         \n             xs)\n                                \n   )","user":"5ec1b293e4b00a66d4a95296"},{"problem":63,"code":"(fn new-group-by\n  [funcion lista]\n  (apply merge-with concat (map #(hash-map (funcion %) [%]) lista)))","user":"56fe2a2fe4b08d47c97781ad"},{"problem":63,"code":"(fn [f xs]\n   (reduce (fn [m x]\n             (update-in m [(f x)] #(if % (conj % x) [x])))\n           {} xs))","user":"550f1c99e4b06e50f9beb171"},{"code":"(fn group [f coll]\n  (let [key #(-> % first first)\n        val #(map second %)]\n    (->> coll\n         (map #(list (f %) %))\n         (sort-by first)\n         (partition-by first)\n         (map #(vector (key %) (val %)))\n         (into {}))))","problem":63,"user":"514c2d05e4b02b8cbb2a9278"},{"code":"#(apply merge-with concat\n  (map (fn[x] {(% x) [x]}) %2))","problem":63,"user":"4e12cc9d535d04ed9115e7d2"},{"code":"(fn [f s] (reduce (fn [m x] (update-in m [(f x)] (fnil #(conj % x) []))) {} s))","problem":63,"user":"4f50d933e4b03ad3f0c10d11"},{"problem":63,"code":"(fn our-group-by [f s]\n  (reduce (fn [m x]\n            (let [k (f x)]\n              (assoc m k (conj (get m k []) x))))\n          {} s))","user":"5777c3d6e4b0979f8965164f"},{"problem":63,"code":"(fn group-seq [f col]\n  (reduce #(assoc %1 \n             (f %2) \n             (conj \n              (apply vector (%1 (f %2))) \n              %2)) \n          {} col))","user":"59874ff6e4b021a7a535fea1"},{"code":"#(reduce (fn [acm v] \n           (let [k (%1 v) \n                 g (or (acm k) [])] \n             (assoc acm k (conj g v)))) {} %2)","problem":63,"user":"50e1bdd8e4b019fc399ce17f"},{"problem":63,"code":"(fn [f c]\n  (apply merge-with concat\n         (for [v c :let [k (f v)]]\n           {k [v]})))","user":"511e17a9e4b0c5b849dd36b0"},{"problem":63,"code":"(fn gb [f s]\n  (->>\n    s\n    (map #(hash-map (f %) [%]))\n    (apply merge-with into)))","user":"5703eda3e4b08d47c9778200"},{"code":"#(->> %2\n       (map (fn [x] {(% x) [x]}))\n       (apply merge-with concat))","problem":63,"user":"4e8510e7535db62dc21a62e7"},{"problem":63,"code":"(fn [f coll]\n  (letfn [(helper [f coll acc]\n                  (if (empty? coll)\n                    acc\n                      (helper f (filter #(not= (f %) (f (first coll))) coll) (assoc acc (f (first coll)) (vec (filter #(= (f %) (f (first coll))) coll))))))]\n6         (helper f coll {})))","user":"5be58beae4b0ed4b8aab4d14"},{"problem":63,"code":"(fn [f s]\n  (loop [ret {} s s]\n    (if (empty? s)\n      ret\n      (let [v (first s)\n            k (f v)\n            new-v (conj (vec (ret k)) v)]\n        (recur (assoc ret k new-v) (rest s))))))","user":"54d000c7e4b018d918be98d7"},{"code":"(fn grp-by\n  ([f ss] (grp-by f ss {}))\n  ([f ss acc] (if (empty? ss)\n                acc\n                (let [s (first ss)\n                      r (f s)]\n                  (if-let [v (get acc r)]\n                    (grp-by f (rest ss) (assoc acc r (conj v s)))\n                    (grp-by f (rest ss) (assoc acc r [s])))))))","problem":63,"user":"519db0ede4b037b32803f9b9"},{"problem":63,"code":"(fn fy [f coll]\n  (reduce \n   #(merge-with \n     concat\n     %1 %2)\n   {}\n   (for [x coll]\n     {(f x) [x]})))","user":"50b8e9a4e4b0cba0e598b656"},{"problem":63,"code":";(fn [f s]\n;  (reduce (fn [r x]\n;            (update-in r\n;                       [(f x)]\n;                       #(if (nil? %) [x] (conj % x))))\n;          {}\n;          s))\n\n(fn [f s]\n  (apply merge-with concat (for [x s] {(f x) [x]})))","user":"54485749e4b032a45b8693c7"},{"problem":63,"code":"(fn [f col]\n  (reduce\n    (fn [a b]\n      (assoc a (f b) (conj (get a (f b) []) b))) {} col))","user":"55d1f231e4b0e31453f64a4e"},{"problem":63,"code":"(fn [f coll]\n   (->> \n     coll\n     (reduce \n       (fn [coll n]\n         (let [value (f n)]\n           (assoc coll value (conj (coll value []) n)))) {})))","user":"54094824e4b0addc1aec66da"},{"problem":63,"code":"(fn f\n  [grouper coll]\n  (let [to-map (fn [map item]\n                 (let [key (grouper item)\n                       key-seq (map key)]\n                   (assoc map key (if (nil? key-seq) (vector item) (conj key-seq item)))))]\n  (reduce to-map {} coll)))","user":"55a62092e4b0acc240e31554"},{"problem":63,"code":"(fn sure [myfn sq] \n  (if (empty? sq) (hash-map)\n  (let [k (myfn (first sq))\n        res (sure myfn (rest sq))]\n    (assoc res k (apply vector (first sq) (res k []))))))","user":"60b2aaebe4b0e0fa5f1b4228"},{"code":"(fn [f c] (reduce #(assoc %1 (f %2) (conj (get %1 (f %2) []) %2)) {} c))","problem":63,"user":"4e588e84535d8a8b8723a294"},{"code":"(fn [f s]\n    (reduce \n      #(merge-with concat %1 (hash-map (f %2) [%2]))\n      {} s))","problem":63,"user":"5141abf1e4b02fd87f5064c3"},{"problem":63,"code":"(fn group [f s]\n  (let [\n         keys-and-values (map #(list (f %) %) s)\n         all-keys (distinct (map first keys-and-values))\n        ]\n    (apply hash-map (reduce concat (map\n      (fn [k] (vector k (map second (filter #(= (first %) k) keys-and-values)))) ;go over the unique keys and filter all the keys and values for those keys\n    all-keys))) \n  )\n)","user":"56393681e4b0bfe05bf117f2"},{"code":"(fn group [f c]\n  (zipmap (set (map f c))\n    (for [x (set (map f c))]\n      (vec (filter #(= x (f %)) c))\n    )\n  )\n)","problem":63,"user":"4f84400de4b033992c121c2e"},{"code":"(fn group\n  ([f c] (group f c {}))\n  ([f c m]\n    (if (empty? c)\n      m\n      (let [x (first c) v (f x)]\n        (if (contains? m v)\n          (group f (rest c) (assoc m v (conj (m v) x)))\n          (group f (rest c) (assoc m v [x])))))))","problem":63,"user":"4dad76588e77d6ed63f12a44"},{"problem":63,"code":"(fn [f xs]\n  (reduce\n   (fn [m x]\n     (let [k (f x)\n           v x\n           vs (get m k [])]\n       (assoc m k (conj vs v))))\n   {} xs))","user":"5a188be3e4b0ff51aa4b31ec"},{"code":"(fn [a b] \n  (reduce\n   (fn [x y]\n     (let [t (a y)]\n       (assoc x t (conj (get x t []) y))))\n   {} b))","problem":63,"user":"4e74e119535d7a570dd295bc"},{"code":"(fn [f coll]\n  (let [results (map (juxt f identity) coll)]\n    (reduce #(update-in % [(first %2)] (comp vec conj) (second %2)) {} results)))","problem":63,"user":"4e89ff3d535d3e98b802328a"},{"code":"(fn seq-group-by [f s]\r\n  (apply merge-with concat (map #(assoc {} (f %) [%]) s)))","problem":63,"user":"503b6995e4b07a1917cc34dd"},{"problem":63,"code":"(fn function-63\n  [function1 seq1]\n  (loop [[f & r :as coll] seq1 rcoll {}]\n    (if (empty? coll)\n      rcoll\n      (recur\n        r\n        (assoc rcoll (function1 f) (conj (vec (get rcoll (function1 f))) f))))))","user":"598d22b1e4b02b9968b84d1a"},{"problem":63,"code":"(fn my-group-by [fx c]\n  (let [kvcoll (map #(vec [(fx %) %]) c)]\n    (loop [coll kvcoll result (sorted-map)]\n      (let [[k v] (first coll)]\n        (if (nil? k)\n          result\n          (recur (rest coll) (assoc result k (sort (into [v] (get result k))))))))))","user":"5546704be4b0a04f7929953d"},{"problem":63,"code":"(fn [f coll] (apply merge-with into (for [x coll]\n               (merge-with into {(f x) [x]}))))","user":"5b4c2212e4b02d533a91bca6"},{"problem":63,"code":"(fn [f c]\n  (reduce #(assoc % (f %2) (conj (get % (f %2) []) %2)) {} c))","user":"54227fc6e4b01498b1a71ac0"},{"problem":63,"code":"#(reduce (fn [h e] (update-in h [(%1 e)] (comp vec conj) e)) {} %2)","user":"512b07f7e4b078b06821febb"},{"problem":63,"code":"(fn [f s] (reduce\n  #(let [k (f %2)]\n    (assoc %1 k\n      (conj\n        (get %1 k [])\n        %2)))\n  {}\n  s))","user":"5a4993c0e4b05d388ecb6b71"},{"problem":63,"code":"(fn [f coll]\n  (loop [ [k v & more] (interleave (map f coll) coll)\n          acc {}]\n    (let [acc-tmp (assoc acc k (conj (get acc k []) v))]\n      (if (nil? more)\n       acc-tmp\n       (recur more acc-tmp)))))","user":"5680104ae4b0966858e4d8ea"},{"problem":63,"code":"(fn [func coll]\n    (loop [c coll m {}]\n      (println c m)\n      (if (empty? c) \n        m\n        (let [v (first c) mapkey (func v)]\n          (recur (rest c)\n                 (assoc m mapkey\n                        (if (nil? (get m mapkey))\n                          [v]\n                          (conj (get m mapkey) v))))))))","user":"56eaad95e4b04a395b9a040f"},{"problem":63,"code":"(fn [f args]\n  (let [filt (fn [y f args] (filter #(= y (f %)) args))]\n    (into {} (map #(conj [ %] (filt %\tf args)) (set (map f args))))\n  )\n)","user":"568513c4e4b04eec3ec5cfc5"},{"code":"(fn grup [f coll]\n  (let [keys (map f coll)\n        tuples (map vector keys coll)]\n    (loop [res (into {} (map vector keys (repeat [])))\n           [[k v :as t] & ts] tuples]\n      (if (nil? t)\n        res\n        (recur (update-in res [k] conj v)\n               ts)))))","problem":63,"user":"4f35b2ace4b0e243712b1ec5"},{"code":"(fn cust-group [f s]\n  (loop [f f s s m {}]\n    (if (empty? s)\n\t    m\n\t  (let [f-s (first s)]\n\t    (recur \n\t      f \n\t\t  (rest s)\n\t\t  (assoc m (f f-s) (conj (get m (f f-s) []) f-s)))))))","problem":63,"user":"52463059e4b09dbe66b56198"},{"problem":63,"code":"#(apply merge-with\n        (partial apply conj)\n        (map (fn [k v] {k [v]}) (map %1 %2) %2))","user":"5aeb0b44e4b0cc2b61a3bbee"},{"code":"(fn [f s]\n    (apply merge-with\n           concat\n           (for [v s]\n             {(f v) [v]})))","problem":63,"user":"4f91fd31e4b0dcca54ed6ca8"},{"code":"(fn [f l]\n  (reduce #(let [fv (f %2) fl (get % fv [])]\n    (assoc % fv (conj fl %2))) {} l))","problem":63,"user":"4f141dee535d64f603146434"},{"problem":63,"code":"(partial (fn [output aggregator [head & tail]]\n      \t\t(if (nil? head)\n        \t\toutput\n        \t\t(let [key (aggregator head)]\n          \t\t\t(recur (assoc output key  (concat (list head) (filter #(= key (aggregator %)) tail)))\n                 \taggregator\n                    (filter #(not= key (aggregator %)) tail ))))) {} )","user":"58db362be4b0a4d5acaab675"},{"problem":63,"code":"(fn [fun xs]\n    (loop [fun fun\n           xs xs\n           groups {}]\n      (if (seq xs)\n        (let [newkey (fun (first xs))\n              group (filter #(= newkey (fun %)) xs)\n              notgroup (filter #(not (= newkey (fun %))) xs)]\n          (recur fun notgroup (assoc groups newkey group)))\n        groups)))","user":"54be792ee4b0ed20f4ff6eeb"},{"problem":63,"code":"#(apply (partial merge-with concat) (for [i %2] (hash-map (% i) [i])))","user":"543b4746e4b032a45b86932c"},{"problem":63,"code":"(fn [f s]\n  (reduce (fn [mp v]\n            (let [k (f v)]\n              (assoc mp k (conj (get mp k []) v)))) {} s))","user":"54864662e4b0e286459a11b8"},{"code":"(let [gen-group-map (fn gen-group-map [f x y]\n  (let [key (f y)\n        vals (get x key [])]\n    (println x y key vals)\n    (assoc x key (conj vals y))))]\n\n(fn k-group-by [f x]\n  \"http://4clojure.com/problem/63\"\n  (reduce #(gen-group-map f %1 %2) {} x)))","problem":63,"user":"4db58ccb535d87e67b28fe10"},{"code":"(fn [f coll]\n    (let [vs (map hash-map (map f coll) (map vector coll))]\n      (apply merge-with #(vec (concat %1 %2)) vs)))","problem":63,"user":"4fb12b35e4b081705acca275"},{"code":"(fn [f s]\n  (let [pairs (map #(vector (f %) %) s)\n        redf (fn [m [k v]] (update-in m [k] (fnil #(conj % v) [])))]\n    (reduce redf {} pairs)  \n))","problem":63,"user":"513b43ede4b067e25a345ed3"},{"code":"(fn [f xs]\r\n  (let [ys (map f xs)]\r\n    (->> (map array-map ys xs)\r\n      (cons (zipmap (set ys) (repeat [])))\r\n      (apply merge-with conj))))","problem":63,"user":"50479524e4b0371827a27bc4"},{"problem":63,"code":"(fn my-groupby [f xs]\n    (reduce #(update-in %1 [(first %2)] (comp vec conj) (second %2)) {}\n            (map #(vector (f %) %) xs)\n            )\n    )","user":"5921a080e4b09b4ee5954c77"},{"code":"(fn [xf a]\n    \n    (into {}\n    (into []\n    (map \n        (fn [i] \n            (vector\n                (first (first i)) \n                (into [] (map (fn [j] (second j)) i))\n            )\n        )\n    \n    (map \n        (fn [x] \n            \n            (filter \n                #(if (= x (first %)) %)\n                (map vector (map xf a) a)\n            )\n            \n        )\n        (set (map xf a)); true false\n    ))))\n)","problem":63,"user":"4e78dc98535db95036265724"},{"problem":63,"code":"(fn [f s] (reduce (fn [r [k v]]\n                     (assoc r k (let [exist (get r k)]\n                        (if (nil? exist) [v] (conj exist v)))))\n                   {} (map vector (map f s) s)))","user":"5c7bc0a5e4b0fca0c1622865"},{"code":"(fn [x y]\n   (reduce (fn [a b]\n             (if (nil? (a (x b)))\n               (assoc a (x b) (vector b))\n               (assoc a (x b) (conj (a (x b)) b))\n             )\n             ) {} y)\n   )","problem":63,"user":"528ce039e4b0239c8a67aebc"},{"code":"(fn r [f l] \n  (if (empty? l)\n    {}\n    (merge {(f (first l)) (filter #(= (f (first l)) (f %)) l)} (r f (filter #(not= (f (first l)) (f %)) l)))))","problem":63,"user":"525cc137e4b0cb4875a45d46"},{"code":"(fn [f x] (reduce (fn [m v] (update-in m [(f v)] (fnil #(conj % v) []))) {} x))","problem":63,"user":"5246e945e4b0644eb7b0783b"},{"problem":63,"code":"(fn my-group-by [f s]\n  (apply merge-with (fn [merged new] (into [] (concat merged new)))\n         (map (fn [k v] {k [v]}) (map f s) s)))","user":"550c55d0e4b06e50f9beb14d"},{"code":"(fn [f coll]\n  (reduce\n   (fn [ret x]\n     (let [k (f x)]\n       (assoc ret k (conj (get ret k []) x))))\n   (sorted-map) coll))","problem":63,"user":"4fbcbd50e4b081705acca2f9"},{"code":"(fn grp [f coll]\n    (reduce (fn [m k] \n        (merge-with concat m {(apply f [k]) [k]})) \n    {} coll))","problem":63,"user":"4ff4c9dae4b0678c553fc360"},{"problem":63,"code":"(fn [func coll]\n  (reduce (fn [result e]\n            (let [res (func e)]\n              (assoc result res (conj (get result res []) e))))\n          {} coll))","user":"55ecac8ee4b0121d4835fdcc"},{"problem":63,"code":"(fn [f s]\n  (reduce #(let [k (f %2)]\n            (assoc %1 k (conj (vec (%1 k)) %2))) {} s))","user":"570459a9e4b0b0fb43fd0662"},{"problem":63,"code":"(fn [f c]\n  (reduce #(update-in %1 [(f %2)] concat [%2]) {} c))","user":"5b772ad7e4b047b03b2036e8"},{"problem":63,"code":"(fn[f sq] (reduce\n    (fn [ret x]\n      (let [v (f x)]\n        (assoc ret v (conj (get ret v []) x)))) {} sq))","user":"53e9681de4b036ad0777e4a4"},{"problem":63,"code":"(fn [f c]\n  (reduce #(let [r (f %2)] (assoc %1 r (conj (get %1 r []) %2))) {} c))","user":"55c0afa5e4b01b9910ae2a27"},{"problem":63,"code":"(fn [f coll]\n  (reduce (fn [result item]\n            (let [key (f item)]\n              (assoc result key (conj (get result key []) item))))\n          {}\n          coll))","user":"5764457ae4b0994c1922fbf3"},{"problem":63,"code":"#(apply merge-with into (for [e %2] {(%1 e) [e]}))","user":"55d1b565e4b0e31453f64a49"},{"code":"(fn [f arr] (reduce #(assoc %1 (f %2) (vec (conj (get %1 (f %2)) %2))) {} arr))","problem":63,"user":"526fce6fe4b03e8d9a4a7383"},{"problem":63,"code":"(fn [f coll] \n   (reduce \n    (fn [agg itm] \n      (merge\n       agg\n       {(f itm) (conj (get agg (f itm) []) itm)}\n       ))\n    {} \n    coll))","user":"604d3cb1e4b0b7ec0ac60ac2"},{"code":"(fn [f s]\n  (let [vs (set (map f s))]\n    (into {} (map (fn [v] [v (filter #(= v (f %)) s)]) vs))))","problem":63,"user":"53720c5ce4b0493c815db704"},{"problem":63,"code":"(fn [f x] \n  (reduce \n   (fn [a b] (merge-with concat a b)) \n   (map (fn [i] {(f i) [i]}) x)))","user":"53e91473e4b036ad0777e495"},{"code":"(fn [f coll]\n  (persistent!\n  (reduce\n    (fn [ret x]\n      (let [k (f x)]\n        (assoc! ret k (conj (get ret k []) x))))\n    (transient {}) coll)))","problem":63,"user":"4ed60c9c535d10e5ff6f52dd"},{"problem":63,"code":"(fn [f xs]\n  (let [group-map (fn [m x]\n                    (let [key (f x)\n                          prev (get m key [])\n                          next (conj prev x)]\n                      (assoc m key next)))]\n    (reduce group-map {} xs)))","user":"5344fe13e4b084c2834f4a32"},{"code":"(fn [func c]\n  (reduce \n    (fn [mp nextElement]\n      (let [value (func nextElement)\n            mapContent (mp value)]\n        (assoc mp value (conj (if (nil? mapContent) [] mapContent) nextElement))))\n  {} \n  c))","problem":63,"user":"4f951375e4b0dcca54ed6cc8"},{"code":"(fn [f xs]\n  (reduce\n    (fn [acc [a b]]\n      (if (acc a)\n        (assoc acc a\n          (conj (acc a) b))\n        (assoc acc a [b])))\n    {}\n    (map\n      (juxt f identity)\n      xs)))","problem":63,"user":"50427899e4b0add3005c0fc2"},{"problem":63,"code":"(fn [func coll]\n  (reduce (fn [acc, value]\n            (if (nil? (acc (func value)))\n              (assoc acc (func value) [value])\n              (update-in acc [(func value)] concat [value])))\n          {}\n          coll))","user":"5d48e6d3e4b0776584bd6f15"},{"problem":63,"code":"(fn grpby\n  ([f coll] (grpby f coll {}))\n  ([f coll acc]\n   (if (empty? coll)\n     acc\n     (let [k (f (first coll))\n           current-val (get acc k :none)]\n       (prn current-val k acc coll)\n       (if (= :none current-val)\n         (grpby f (rest coll) (assoc acc k [(first coll)]))\n         (grpby f (rest coll)\n                (assoc acc k (conj current-val (first coll)))))))))","user":"5d9c1226e4b0d3f9b434ad51"},{"problem":63,"code":";;(get (hash-map (/ 1 2) [1 2] 2 [2 4] 3 [4 6]) 1/2)\n;;(\n (fn [f l]\n (reduce (fn [res n] \n           (let [k (f n)\n                 g (get res k [])]\n           (into res {k (conj g n)}))) {} l))\n ;;       #(apply / %) [[1 2] [2 4] [4 6] [3 6]])","user":"58566b42e4b0f14aab7c86f4"},{"code":"(fn [f s]\n  (reduce\n    (fn [r x]\n      (update-in r [(f x)] (fn [p q] (if (seq p) (conj p q) [q])) x)\n      )\n    {}\n    s))","problem":63,"user":"4ea41fc2535d7eef308072cb"},{"problem":63,"code":"(fn _\n  [f xs]\n  (reduce #(let [k (f %2)] (assoc %1 k (conj (get %1 k []) %2))) {} xs))","user":"5e41b679e4b01d43a70e8e58"},{"code":"(fn [f xs] \n     (reduce\n       (fn [m x]\n         (let [v (f x)]\n           (assoc m v (conj (m v []) x))))\n       {} xs))","problem":63,"user":"502ade49e4b0614b52996120"},{"code":"(fn [f coll]\n  (reduce\n   (fn [ret x]\n     (let [k (f x)]\n       (assoc ret k (conj (get ret k []) x))))\n   {} coll))","problem":63,"user":"5106bc8ae4b01150e115ebec"},{"problem":63,"code":"(fn [f c]\n  (apply merge-with concat\n         (map #(hash-map (f %) [%])\n              c)))","user":"5893c64ce4b00487982d524b"},{"code":"(fn [f s] (reduce #(let [k (f %2)] (assoc %1 k (conj (get %1 k []) %2))) {} s))","problem":63,"user":"523b4e91e4b07becd5be21ef"},{"code":"(fn [f s]\n (apply (partial merge-with concat) (map #(assoc {} % %2) (map f s) (map vector s))))","problem":63,"user":"50843a4ae4b0c98812d0788b"},{"problem":63,"code":"(fn [f xs]\n   \t(apply merge-with concat (map #(assoc {} (f %) [%]) xs)))","user":"53623eaee4b0243289761e4f"},{"code":"(fn [f c]\n   (reduce\n     #(assoc\n        %1\n        (f %2)\n        (conj (vec (%1 (f %2))) %2))\n     {}\n     c))","problem":63,"user":"4fe9f0f6e4b0547ebccb247b"},{"problem":63,"code":"(fn [kg coll] (reduce (fn [a c] (assoc a (kg c) (conj (get a (kg c) []) c))) {} coll))","user":"5d63f1c2e4b0c9e5857d502b"},{"problem":63,"code":"(fn [f s] (reduce #(update-in %1 [(f %2)] (fn [i] (conj (vec i) %2))) {} s))","user":"502a4fdfe4b09dd42f6f3644"},{"problem":63,"code":"(fn group\n  [f lst]\n  (apply hash-map (mapcat #(vector (f (first %)) (vec %))\n                       (partition-by f (sort lst)))))","user":"57f81534e4b0d3187e900915"},{"code":"(fn gp [f coll]\r\n  (reduce #((fn [m n]\r\n\t\t(let [k (f n)]\r\n\t\t\t(if-let [arr (m k)]\t\t\r\n\t\t\t\t(assoc m k (conj arr n))\r\n\t\t\t\t(assoc m k [n]))))\r\n\t\t\t\t %1 %2) {}  coll))","problem":63,"user":"4f3242bae4b0d6649770a08f"},{"code":"(fn [f xs] (reduce #(merge-with concat % %2) (map #(hash-map (f %) [%]) xs)))","problem":63,"user":"508e13abe4b0f17d83ea26c7"},{"problem":63,"code":"(fn gr-by \n  ([f s]\n   (gr-by f s {}))\n  ([f s m]\n   \n   (if \n     (not (empty? s))\n     (let [v (first s) k (f v)]\n     (gr-by f (rest s) (assoc m k ((fnil conj []) (m k) v))) )\n     \n     m)))","user":"5d5eb086e4b0c9e5857d4ff7"},{"code":"#(reduce (fn [m e]\n    (assoc m (% e) (conj (m (% e) []) e))\n  ) {} %2)","problem":63,"user":"5054bc87e4b0b1b9d1860eb0"},{"problem":63,"code":"(fn [f lst]\n  (->> (map #(hash-map (f %) [%]) lst)\n       (apply merge-with into)))","user":"5813e208e4b0f478707a061b"},{"problem":63,"code":"(fn [f s]\n\t(reduce (fn [out check] \n\t\t(update-in out [(f check)] #(conj (or %1 []) check))) {} s))","user":"5ec819b4e4b08d0ec38692e2"},{"code":"(fn my-group-by [f a-seq]\n   (letfn [(key-values [k p-seq]\n    (list k (map #(second %) (filter #(= (first %) k) p-seq))))]\n   (let [pairs (map #(list (f %) %) a-seq)\n         keys (distinct (map #(first %) pairs)) \n    ] (apply assoc {} (mapcat #(key-values % pairs) keys))\n    )\n\t)\n)","problem":63,"user":"52763696e4b03e8d9a4a74d7"},{"code":"(fn [f v]\n  ((fn my-group-by [f v m]\n     (if (empty? v)\n       m\n       (let [k (f (first v))]\n         (recur f \n                (rest v)\n                (assoc m k (if (contains? m k)\n                             (conj (m k) (first v))\n                             [(first v)]))))))\n   f v {}))","problem":63,"user":"50d86fe2e4b01f0871336e67"},{"problem":63,"code":"#_(fn [f coll]\n  (let [vals (map vec (partition-by f coll))\n        keys (map #(f (first %)) vals)\n\n        filter-by-key\n        (fn [key]\n          (filter #(= (f %) key) coll))]\n    (zipmap keys (map filter-by-key keys))))\n(fn [f coll]\n  (->> coll\n       (map (fn [x] {(f x) [x]}))\n       (apply (partial merge-with concat))))","user":"5d24e49be4b02ea6f0fb6a2a"},{"problem":63,"code":"(fn [f xs & a]\n   (let [a (if (nil? a) {} a)]\n     (if (seq xs)\n       (let [x (first xs)\n             xs (rest xs)\n             v (f x)\n             xvs (get a v [])]\n         (recur f xs (assoc a v (conj xvs x))))\n       a)))","user":"51bb08a4e4b0fe3ecfb46446"},{"problem":63,"code":"(fn [f xs]\n          (let [mf (map f xs)\n                fxs (interleave mf xs)\n                cfxs (partition 2 fxs)\n                dfx (distinct mf)\n                fltr (fn [k vp] (filter #(= k (first %)) vp))\n                p2 (fn [vp] (map #(last %) vp))]\n            (apply hash-map (interleave dfx (map #(into [] (p2 (fltr % cfxs))) dfx)))))","user":"5835bc73e4b089d5ab817ce9"},{"problem":63,"code":"(letfn \n  [(func [f]\n         (fn [mapp v]\n           (let [k (f v)]\n             (assoc mapp k (concat (mapp k) [v])))))]\n  (fn [f coll]\n    (reduce (func f) {} coll)))","user":"53065acbe4b02e8216869792"},{"problem":63,"code":"(fn [f xs] (reduce (fn [m el] (let [key (f el)]\n                               (assoc m key (conj (get m key []) el)))) (hash-map) xs))","user":"5485b402e4b0e286459a11b0"},{"problem":63,"code":"(fn [f col]\n  (reduce\n    (fn [a b]\n      ( assoc a (f b)\n        (conj (get a (f b)) b)))\n    {}\n    (reverse col)))","user":"56066e82e4b08b23635d3173"},{"code":"(fn\n  [f x]\n  (let [mykeys (vec (distinct (map f x)))]\n    (loop [skeys mykeys\n           svals []]\n      (if (empty? skeys)\n        (zipmap mykeys svals)\n        (recur (rest skeys) (conj svals (into [] (filter #(= (first skeys) (f %1)) x))))))))","problem":63,"user":"51f13b80e4b06a20a2523f38"},{"problem":63,"code":"(fn [f xs] (apply merge-with into (for [x xs] {(f x) [x]})))","user":"57db2369e4b0bd073c20241f"},{"code":"(fn [p coll] (reduce (fn [ret x] (let [k (p x)] (assoc ret k (conj (get ret k []) x)))) {} coll))","problem":63,"user":"503d129fe4b06c4e0e1fa254"},{"code":"(fn [f coll] \r\n  (persistent!\r\n   (reduce\r\n    (fn [ret x]\r\n      (let [k (f x)]\r\n        (assoc! ret k (conj (get ret k []) x))))\r\n    (transient {}) coll)))","problem":63,"user":"4fd2e5d8e4b04c3a95aa0427"},{"code":"(fn grp-by [f xs]\n  (if (empty? xs) {}\n    (update-in (grp-by f (rest xs))\n      [(f (first xs))] #(cons %2 %1) (first xs))))","problem":63,"user":"4ee82ce9535d93acb0a6687a"},{"code":"(fn [f xs]\n  (reduce\n    (fn [m x]\n      (if (nil? (get m (f x)))\n        (assoc m (f x) [x])\n        (assoc m (f x) (conj (get m (f x)) x))\n        )\n      ) {} xs))","problem":63,"user":"4f03ba9c535dcb61093f6b58"},{"code":"(fn group-by_ [f coll]\n  (loop [c_ coll acc (apply hash-map (interleave (distinct (map f c_)) (repeat [])))]\n    (cond\n      (empty? c_) acc\n      :else (recur (rest c_)\n                   (assoc acc (f (first c_)) (conj (acc (f (first c_))) (first c_)))))))","problem":63,"user":"4f50c414e4b03ad3f0c10d0d"},{"code":"#(apply merge-with concat \n        (for [x %2] {(% x) [x]}))","problem":63,"user":"4efb2fd7535dced4c769f274"},{"problem":63,"code":"(fn [f coll]\n  (apply merge-with into\n         (for [v coll]\n            {(f v) [v]}\n         )\n  )\n)","user":"506af7d8e4b0a2a5463de37d"},{"problem":63,"code":"(fn [f coll]\n  (reduce (partial merge-with concat) (map #(hash-map (f %) [%]) coll)))","user":"564da567e4b0284900eef682"},{"code":"(fn [f s]\n  (let [add-to-vector (fn [map1 new-val]\n                        (let [key1 (f new-val)]\n                          (if (contains? map1 key1)\n\n                            (assoc map1 key1 (conj (get map1 key1) new-val))\n\n                            (assoc map1 key1 [new-val]))))]\n\n    (reduce add-to-vector {} s)))","problem":63,"user":"53415755e4b00652c8746ecd"},{"problem":63,"code":"(fn [f l] (reduce (fn [ret e] (let [k (f e)] (assoc ret k (conj (get ret k []) e)))) {} l))","user":"5c308385e4b0d62ef62d9f1c"},{"problem":63,"code":"(fn [f s]\n    (loop [s s\n           m {}]\n      (if (empty? s)\n          m\n          (let [v (first s)\n                k (f v)]\n            (recur \n              (rest s)\n              (if (contains? m k) \n                  (assoc m k (conj (m k) v))\n                  (assoc m k [v])))))))","user":"4e8a170c535d3e98b802328f"},{"code":"(fn [f col]\n    (let [konj #(if (nil? %) [%2] (conj % %2))]\n      (reduce (fn [m v]\n                (let [k (f v)]\n                  (assoc m k (konj (m k) v))\n                  )) {} col)))","problem":63,"user":"50fa01bce4b07934dda8b0ba"},{"code":"(fn by-group\n  [f s]\n  (let [sorted (sort-by f s)\n        groups (partition-by f sorted)\n        group-maps (map #(hash-map ((comp f first) %) (vec %)) groups)]\n    (reduce conj group-maps)))","problem":63,"user":"524f4256e4b0541d1855b808"},{"problem":63,"code":"(fn [op xs] (reduce (fn [m [k v]] (if (m k) (assoc m k (conj (m k) v)) (assoc m k [v])))\n                    {}\n                    (for [x xs]\n                      [(op x) x])))","user":"4ea03f70535d7eef308072a1"},{"problem":63,"code":"(fn [f s]\n  (let [r (map f s)]\n    (loop\n        [i (dec (count s))\n         m {}]\n      (if (< i 0)\n        m\n        (recur (dec i) (update-in m [(nth r i)] conj (s i)))))))","user":"5918db70e4b09b4ee5954bbb"},{"problem":63,"code":"(fn [f a]\n  (reduce (fn [m e]\n            (let [k (f e)]\n              (update-in m [k] #(conj (vec %1) e))))\n          {} a))","user":"568227fee4b0945ebc182a8a"},{"code":"(fn [f s]\r\n    (loop [[x & xs :as xss] (seq s), acc {}]\r\n      (if (empty? xss)\r\n        acc\r\n        (recur xs \r\n               (let [k (f x), v (if (not (contains? acc k)) [] (acc k))]\r\n                 (assoc acc k (conj v x)))))))","problem":63,"user":"4ef1ee67535dced4c769f219"},{"code":"(fn f[func coll]\n  (apply \n    merge-with \n    into \n    (map #(hash-map (func %) [%]) coll)))","problem":63,"user":"51750cd4e4b07031762f2ee5"},{"problem":63,"code":"(fn [f s]\n  (apply \n   (partial merge-with #(vec (concat %1 %2))) \n   (map (fn [x] {(f x) [x]}) s)))","user":"52860baae4b0239c8a67ae09"},{"problem":63,"code":"(fn group [f s]\n  (loop [result {} items s]\n    (if (empty? items)\n      result\n      (let [current-item (first items) value (f current-item) map-value(get result value [])]\n        (recur\n          (assoc result value (conj map-value current-item))\n          (rest items)\n        )\n      )\n    )\n  )\n)","user":"5991d2fae4b0866487ed0d68"},{"code":"(fn foo [func lst & {:keys [h] :or {h {}}}]\n  (if (empty? lst)\n    h\n    (let [current (first lst)\n          v (func (first lst))]\n      (if (contains? h v)\n        (foo func (rest lst) :h (conj h {v (conj (h v) current)}))\n        (foo func (rest lst) :h (conj h {v [current]}))))))","problem":63,"user":"5220a770e4b0e6a83c8925a3"},{"code":"#(into {} (map\n               (fn [x]\n                 [(first (first x))\n                  (into [] (map last x))])\n               (partition-by first\n                             (sort (fn [x y] (compare (first x) (first y)))\n                                   (map (fn [x] (list (%1 x) x)) %2)))))","problem":63,"user":"53838742e4b06839e8705ee0"},{"problem":63,"code":"#(apply merge-with into (for [i %2] { (%1 i) [i]}))","user":"5a0a25fce4b0eab8c044893d"},{"code":"#(reduce\n  (fn [a x]\n    (let [k (% x)]\n      (assoc a k (conj (a k []) x))))\n  {}\n  %2)","problem":63,"user":"4fd96694e4b05e33b9224f37"},{"problem":63,"code":"(fn [f s]\n  (let [interim  (map (fn [v] [(f v) v]) s)]\n    (reduce\n    (fn [rslt  [ctgry vl]]\n        (if (get rslt ctgry)\n        (conj rslt {ctgry (conj (get rslt ctgry) vl)})\n        (conj rslt (hash-map ctgry [vl]))))\n    {} interim ) ) )","user":"608e5697e4b03bd49d9f36be"},{"code":"(fn gb [f l]\n  (if (empty? l)\n    {}\n    (let [r (gb f (rest l))\n          y (f (first l))\n          x (get r y)]\n      (if x \n        (assoc r y (cons (first l) x))\n        (assoc r y [(first l)])))))","problem":63,"user":"5110b8bae4b04c71fce993f4"},{"problem":63,"code":"#(loop [sq %2 grouped {}]\n   (if (empty? sq)\n     grouped\n     (let [v (%1 (first sq)) el (first sq)]\n       (if (contains? grouped v)\n         (recur (rest sq) (update-in grouped [v] (fn [x] (conj x el))))\n         (recur (rest sq) (assoc grouped v [el]))\n      )\n     )\n )\n)","user":"5e947a69e4b0fbed045a37f8"},{"problem":63,"code":"(fn [f coll]\n   (let [x (partition-by f (sort coll))\n         y (distinct (map f coll))]\n     (into {} (map vector y x)))\n\n   )","user":"56ede653e4b04a395b9a0449"},{"problem":63,"code":"(fn my-group [f xs]\n  (reduce (fn [m x]\n            (assoc m (f x) (conj (get m (f x) []) x)))\n          {}\n          xs))","user":"551bdefde4b07993ea3788d7"},{"problem":63,"code":"(fn my-gb\n  [f sq]\n  (loop [s sq\n         gm {}]\n    (if (empty? s)\n      gm\n      (let [itm (first s)\n            ky (f itm)\n            ovect (get gm ky [])\n            nvect (conj ovect itm)]\n        (recur (rest s)\n               (conj gm [ky nvect]))))))","user":"566f3e18e4b0a866af6896e7"},{"code":"(fn [f xs]\n  (let [helper (fn helper [xs m] \n                 (if xs\n                   (let [item (first xs)\n                         k (f item)\n                         v (get m k [])]\n                \t\t(helper (next xs)\n                                (assoc m k (conj v item))))                   \n                   m))]\n  \t(helper (seq xs) {})))","problem":63,"user":"53800d99e4b06839e8705ebd"},{"code":"(fn [f x]\n  (reduce #(merge-with into %1 %2) (map #(assoc {} (f %) [%]) x)))","problem":63,"user":"51e1a1fae4b06a68e693eaf6"},{"problem":63,"code":"(fn my-group-by [func coll]\n  (loop [groupped {}\n       \t [el & rest] coll]\n    (if (nil? el)\n      groupped\n      (let [key (func el)\n            group (get groupped key)\n\t\t\tnew-g (assoc groupped key (vec (conj group el)))]\n        (recur new-g rest)))))","user":"55b4fa46e4b01b9910ae2983"},{"code":"(fn [f xs]\n  (apply merge-with concat\n         (for [x xs] {(f x) [x]} )))","problem":63,"user":"4f91f5b1e4b0dcca54ed6ca7"},{"code":"(fn [f coll]\n  (let [group (->> coll (sort-by f) (partition-by f) (map vec))\n        by    (map #(-> % first f) group)]\n    (zipmap by group)))","problem":63,"user":"511b9017e4b00c2a1fa7ff6b"},{"problem":63,"code":"(fn [f coll]\n  (reduce (fn [m pair]\n            (merge m\n                   {(first pair)\n                    (conj (or (m (first pair) []))\n                          (second pair))}\n                   ))\n          {}\n          (map (juxt f identity) coll)))","user":"605f5c69e4b03746e80ebf5e"},{"code":"(fn [f s]\n\t(letfn [(group [m val]\n                   (let [result (f val)\n                         v (get m result [])]\n                     (assoc m result (conj v val))))]\n      (reduce group {} s)))","problem":63,"user":"5236b6bce4b05f3be1c7c8fe"},{"problem":63,"code":"(fn [f l] (->> (for [x l] {(f x) [x]}) (apply merge-with concat)))","user":"53d28800e4b00fb29b22131e"},{"problem":63,"code":"(fn mgroupby\n  [f a]\n  (loop [r a\n         rv {}]\n    (if (empty? r) rv\n        (let [fi (first r)\n              m (f fi)]\n          (recur (rest r) (update-in rv [m] #(if (rv m) (conj % fi) [fi])))))))","user":"5866b999e4b0f14aab7c886b"},{"code":"(fn [f s]\n    (reduce (fn [x y] \n      (let [k (f y)]\n      (merge-with concat x {k [y]})\n      )\n    ) (concat [{}] s))\n  \n)","problem":63,"user":"4f7b6b90e4b06e829148e1a4"},{"code":"(fn [keysFS aSequence]\n  (persistent!\n    (let [upsert (fn [a b c]\n                   (assoc! a b (conj (get a b []) c)))]\n      (reduce #(upsert %1 (keysFS %2) %2) (transient {}) aSequence))))","problem":63,"user":"50ee145de4b06330c1f87c53"},{"problem":63,"code":"(fn F [f l] (reduce #(update-in %1 [(f %2)] (fnil conj []) %2) {} l))","user":"567b39b6e4b05957ce8c61a3"},{"problem":63,"code":"(fn [f s]\n  (reduce #(update-in %1 [(f %2)] concat [%2]) {} s))","user":"561047eae4b05f002753df6d"},{"problem":63,"code":"(fn my-group-by [f s]\n    (apply merge-with concat\n        (map #(hash-map (f %) [%]) s)))","user":"53a94b63e4b047364c044434"},{"problem":63,"code":"(fn g [f xs] \n  (reduce (fn [memo x] (update-in memo [(f x)] #(into [] (conj % x)))) {} xs))","user":"54ab502fe4b09f271ff37cc4"},{"code":"(fn [f s]\n(let [ks (distinct (map f s))]\n(apply hash-map (concat (interleave \n                                ks\n                                (for [k ks]\n                                  (vec (filter #(= k (f %)) s))))))))","problem":63,"user":"4de18de7535d08e6dec9fde8"},{"problem":63,"code":"(fn my-group-by [func a-seq]\n  (let [grouped-itms (partition-by func (sort-by func a-seq))\n        result-list (map #(func (first %)) grouped-itms)]\n    (zipmap result-list grouped-itms)))","user":"580d2788e4b0849f6811b730"},{"problem":63,"code":"#(loop [f %1 coll %2 m {}]\n  (if (empty? coll)\n    m\n    (recur f (rest coll) ((fn add-to-map [m k v] (assoc m k (conj (get m k []) v)))\n                          m (f (first coll)) (first coll)))))","user":"55ed9108e4b0121d4835fddc"},{"code":"(fn [f xs] (apply merge-with concat (for [x xs] {(f x) [x]})))\n; copied","problem":63,"user":"51823a97e4b0f2adb733651e"},{"code":"(fn [f col]\n   ( let [vcol (map f col)  ]\n     (apply merge-with #(conj %1 (first %2)) (map #(assoc {} %1 [%2]) vcol col))))","problem":63,"user":"4ec5bec6535d6d7199dd36b3"},{"code":"(fn [f s] (reduce #(update-in % [(f %2)] concat [%2]) {} s))","problem":63,"user":"4f3444b7e4b0e243712b1eb6"},{"problem":63,"code":"(fn [f coll]\n  (apply merge-with concat (for [x coll] {(f x) [x]})))","user":"55ed5a2de4b0121d4835fdd8"},{"code":"(fn [f xs]\n  (reduce\n   (fn [m x]\n     (update-in m [(f x)] (fnil conj []) x))\n   {} xs))","problem":63,"user":"5312cdaae4b08068f379ed03"},{"problem":63,"code":";(\n (fn g-b [f s]\n   (reduce (fn [m [k v]] (update-in m (list k) #(conj (vec %1) %2) v)) {} (map vector (map f s) s)))\n ;count [[1] [1 2] [3] [1 2 3] [2 3]])","user":"573632b7e4b0cd1946bd102f"},{"problem":63,"code":"(fn [f seq]\n    (reduce\n      (fn [ret [key val]] \n        (let [temp (ret key)]\n          (assoc ret key \n            (if (nil? temp)\n              [val]\n              (conj temp val)))))\n      {} (map vector (map f seq) seq)))","user":"546ff835e4b00cfc9eacc1b4"},{"code":"(fn [f coll]\n  (reduce (fn [all i]\n            (let [k (f i) o (get all (f i))]\n              (if (nil? o)\n                (assoc all k [i])\n                (assoc all k (conj o i))))) {} coll))","problem":63,"user":"5348236ee4b084c2834f4a54"},{"code":"#(into {} (map (fn[a] [(% (first a)) a]) (partition-by % (sort-by % %2))))","problem":63,"user":"4f296a80e4b0d6649770a02a"},{"problem":63,"code":"(fn [kf xs] (reduce #(update-in %1 [(kf %2)] (fnil conj []) %2) {} xs))","user":"561814bae4b06b1bb2182a1a"},{"problem":63,"code":"(fn [f l] (reduce #(assoc %1 (f %2) (vec (conj (get %1 (f %2)) %2))) {} l))","user":"587ee260e4b052da650a6353"},{"problem":63,"code":"(fn grouper [f a-seq]\n  (reduce (fn [coll value]\n            (let [evaled (f value)\n                  val-vec (get coll evaled)]\n              (if (nil? val-vec)\n                (assoc coll evaled [value])\n                (assoc coll evaled (conj val-vec value))))) \n          {}\n          a-seq))","user":"5235493ee4b05e80434a5064"},{"code":"(fn [f s] (reduce #(update-in % [(f %2)] (fnil concat []) [%2]) {} s))","problem":63,"user":"507056b8e4b07bd6ad9b9f29"},{"problem":63,"code":"(fn [f xs]\n  (reduce (fn [m x]\n            (let [k (f x)]\n              (if (contains? m k)\n                (assoc m k (conj (m k) x))\n                (assoc m k [x]))))\n          {}\n          xs))","user":"57462a4de4b009280f9f2b5d"},{"problem":63,"code":"(fn [f seqn] (apply merge-with concat (map (partial assoc {}) (map f seqn) (map vector seqn))))","user":"5519c157e4b00ace28fe6e32"},{"problem":63,"code":"(fn [f seq]\n    (loop [i 0 res {}]\n      (if (= i (count seq))\n        res\n        (recur\n          (inc i)\n          (let [cur (nth seq i) key (f cur)]\n            (assoc res key\n              (if (contains? res key)\n                (conj (get res key) cur)\n                [cur])))))))","user":"53a68c5ae4b0ef122a8689c8"},{"code":"(fn [f coll]\n  (persistent!    (reduce\n      (fn [ret x]\n        (let [k (f x)]\n          (assoc! ret k (conj (get ret k []) x))))\n      (transient {}) coll)))","problem":63,"user":"4f85a75ce4b033992c121c48"},{"problem":63,"code":"(fn z [f v]\n  (loop [s (interleave (mapv f v) v) r {}]\n    (println r)\n    (if (empty? s)\n      r\n      (recur (drop 2 s)\n            (update-in r\n                    [(first s)]\n                    (fn [x]\n                        (if (nil? x)\n                          [(second s)]\n                          (conj x (second s)))))))))","user":"5763818ae4b0994c1922fbc7"},{"code":"(fn [f xs] \n  (reduce \n    #(assoc %1 (f %2) (conj (%1 (f %2)) %2))\n    (zipmap (map f xs) (repeat []))\n    xs))","problem":63,"user":"4fc5a693e4b0ee37620e17fc"},{"problem":63,"code":"(fn my-group-by [f, s]\n     \"map-reduce solution\"\n     (reduce\n       #(let [key (first %2), value (second %2)]\n         (assoc %1 key (conj (%1 key []) value)))\n       (hash-map)\n       (map #(list (f %) %) s)\n      )\n    )","user":"5443cb97e4b032a45b86938a"},{"problem":63,"code":"(fn [f s]\n  (reduce #(let [k (f %2)] \n              (if (contains? %1 k) \n                  (update-in %1 [k] conj %2)\n                  (assoc-in %1 [k] [%2])))\n          {} s))","user":"558bb38fe4b0277789237631"},{"code":"(fn [f s]\n  (loop [map_ {}\n         ss s]\n    (if (empty? ss)\n        map_\n    (let [h (first ss),\n          key (f h)]\n        (recur\n          (assoc map_\n                 key\n                 (conj (get map_ key []) h))\n          (rest ss))))))","problem":63,"user":"4f047902535dcb61093f6bcc"},{"code":"#(apply merge-with into\n        (for [x %2] {(% x) [x]}))","problem":63,"user":"4ebaf790535dfed6da9c6d6e"},{"problem":63,"code":"(fn [f col]\n  (loop [col_ col\n         groups {}]\n    (if (empty? col_)\n      groups\n      (recur (rest col_)\n             (let [k (f (first col_))\n                   v (first col_)]\n              (assoc groups\n                    k\n                    (conj (get groups k []) v)))))))","user":"589f37e0e4b02bd94d917e79"},{"problem":63,"code":"(fn [f coll]\n  (letfn [(f-group [groups [k v]]\n            (assoc groups k (conj (groups k []) v)))]    \n  (->> coll\n       (map #(vector (f %) %))\n       (reduce f-group {}))))","user":"5f82609ae4b0c071e6c840f9"},{"problem":63,"code":"(fn my-gb\n\t[f coll]\n\t(loop [result (transient {}) input coll]\n\t\t(if (empty? input)\n\t\t\t(persistent! result)\n\t\t\t(let [k (first input) v (f k)]\n\t\t\t\t(recur (assoc! result v (conj (get result v []) k)) (rest input))))))","user":"58fb7d7ae4b0438e51c2cf7a"},{"problem":63,"code":"(fn [f l] (apply merge (map #(hash-map (f (first %)) %) (partition-by f (sort-by f l)))))","user":"54edcf96e4b024c67c0cf866"},{"code":"(fn [f c]\n  (reduce #(let [v (f %2)] (update-in %1 [v] concat [%2])) {} c))","problem":63,"user":"4e6a2f51535d8ccf87e9fea9"},{"problem":63,"code":"(fn __\n  ([f s] (__ f s {}))\n  ([f [x & xs] acc]\n   (if x\n     (recur f xs (update-in acc [(f x)] #(concat % [x]) ))\n     acc)))","user":"55916764e4b0604b3f94d57b"},{"problem":63,"code":"(fn [f seq]\n    (loop [s seq m {}]\n      (if (empty? s)\n        m\n        (let [c (first s) cv (f c) vals (get m cv [])]\n          (recur (rest s) (assoc m cv (conj vals c)))\n        )\n      )\n      )\n    )","user":"5681afaae4b0945ebc182a87"},{"code":"(fn [f coll]\n  (into {} (map (fn [k] (vector k (filter (comp #(= k %) f) coll)))\n                (distinct (map f coll)))))\n;; way too complicated!\n;; should learn daowen's solution: reduce, merge-with, into","problem":63,"user":"4fceda40e4b03432b189f407"},{"problem":63,"code":"(fn\n [f s]\n (reduce #(if (%1 (f %2)) (into %1 {(f %2) (conj (%1 (f %2)) %2)})(into %1 {(f %2) [%2]})) {} s))","user":"5dc9ccf8e4b02f9375f4e1f1"},{"code":"(fn [f s]\n  (let [ks (set (map f s))\n        vs (for [k ks] (filter #(= k (f %)) s))]\n    (zipmap ks vs)))","problem":63,"user":"4e80d71b535db62dc21a62b7"},{"problem":63,"code":"(fn\n  [f x]\n  (reduce #(conj % [(f %2) (conj (% (f %2) []) %2)]) {} x))","user":"542f574be4b0dad94371f2d0"},{"problem":63,"code":"(fn [func lst] \n    (loop [hm {}\n           lst lst]\n        (if (empty? lst)\n            hm\n            (recur (assoc hm (func (first lst))  (conj (hm (func (first lst)) []) (first lst))) (rest lst)))))","user":"5f77d470e4b02876ed9fd0be"},{"problem":63,"code":"(fn [f col]\n   (apply merge-with into\n      (map #(hash-map \n         (f %) (vector (identity %)))\n       col)))\n\n;; (fn [f col]\n;; (let [out {}\n;;    ks (distinct (map f col))]\n;; (for [k ks]\n;;    (assoc out k\n;;       (filterv \n;;          #(= (f %) k) col)))))","user":"52b666bfe4b0c58976d9ad44"},{"problem":63,"code":"(fn [a b] (reduce #(assoc % (a %2) (conj (get % (a %2) []) %2)) {} b))","user":"5382704be4b06839e8705ed4"},{"code":"(fn [f x]\n  (reduce  \n     #(merge-with \n       concat % %2) {}\n        (map #(hash-map (f %) [%]) x)))","problem":63,"user":"4facd2fae4b081705acca22f"},{"code":"(fn fun [f s]\n  (into {}\n  (map (fn [[k v]] [ k (reverse v)] ) \n        (reduce (fn [x1 x2]\n                  (update-in x1 [(f x2)] conj x2 )) {} s ))))","problem":63,"user":"5349da55e4b084c2834f4a68"},{"problem":63,"code":"(fn [f sequence]\n  (let [ mapped (map f sequence)\n         keys   (distinct mapped)\n         map    (zipmap keys\n                        (repeat (count keys) []))\n       ]\n    (reduce #(assoc\n               %1\n               (f %2)\n               (concat (%1 (f %2)) [%2])\n               )\n            map\n            sequence)))","user":"4f29d9abe4b0d6649770a034"},{"problem":63,"code":"(fn [f s] (let [s (reverse s)] (reduce #(assoc %1 (f %2)  (conj (get %1 (f %2))  %2)) {} s)))","user":"59419bdfe4b060784b3b78f7"},{"problem":63,"code":"(fn [f s]\n(reduce \n (fn [acc x]\n    (assoc acc (f x) (conj (get acc (f x) []) x))) \n   {} s))","user":"52f0ea04e4b05e3f0be25ee6"},{"code":"#(apply (partial merge-with concat) (map (fn [c] {(% c) [c]}) %2))","problem":63,"user":"50ad7888e4b0a40c9cfb08c7"},{"code":"(fn [f c]\n    (reduce #(merge-with concat %1 {(f %2) [%2]}) {} c)\n)","problem":63,"user":"52b577c9e4b0c58976d9ad39"},{"code":"(fn [f s]\n  (into {} (map #(vector (f (first %)) %) (partition-by f (sort s)))))","problem":63,"user":"5271605ae4b03e8d9a4a73ed"},{"problem":63,"code":"(fn [func xs]\n  (apply merge-with concat              \n         (map #(hash-map (func %1) [%1]) xs)))","user":"57e139f6e4b0bfb2137f5a6c"},{"problem":63,"code":"(fn [f xl]\n    (loop [xl xl m {}]\n      (if (empty? xl)\n        m\n        (let [n (first xl)\n              v (f n)\n              group (conj (get m v []) n)]\n          (recur (rest xl) (assoc m v group))\n          ))))","user":"57fc0719e4b0d3187e900987"},{"problem":63,"code":"(fn Group [f coll]\n  (letfn [(step-fn [m f coll]\n                   (if-let [s (seq coll)]\n                     (let [item (first s)\n                           k    (f item)]\n                         (step-fn (assoc m k \n                                    (conj (get m k []) item)\n                                    ) f (rest s))\n                       )\n                   m )\n                   )\n          ]\n    (step-fn {} f coll)\n    )\n          )","user":"578d230fe4b0ebec4cfb7564"},{"code":"(fn [fun l](letfn [(pick [k v hm] (if (contains? hm k) (assoc hm k (into [](concat (hm k) (vector v)))) (assoc hm k (vector v))))](loop [ll l r {}] (if (empty? ll) r (recur (rest ll) (pick (fun (first ll)) (first ll) r))))))","problem":63,"user":"510931ede4b0c71f76895663"},{"code":"(fn [f coll]\n  (reduce\n    (fn [res x]\n      (let [k (f x)]\n        (assoc res k (conj (get res k []) x))\n        ))\n    {} coll))","problem":63,"user":"50d8739ae4b01f0871336e68"},{"code":"(fn [f s]\n  (apply merge-with concat (map #(hash-map (f %1) [%1]) s)))","problem":63,"user":"5060d137e4b0dc10a69545a0"},{"problem":63,"code":"(fn v [f s]\n  (let [mykeys (distinct (map f s))]\n    (zipmap mykeys (for [k mykeys] \n                     (filterv #(= (f %) k) s)))))","user":"55aaa36fe4b0988bba2ad94f"},{"code":"(fn newgroupby [f s]\n  (reduce #(assoc %1 (f %2) (conj (get %1 (f %2)) %2)) \n          (zipmap (distinct (map f s)) (repeat (count (distinct (map f s))) []))\n          s))","problem":63,"user":"532727bae4b09d4e7a9b54fa"},{"problem":63,"code":"(fn [f l] (reduce\n           (fn [m i] (assoc\n                       m\n                       (f i)\n                       (conj (m (f i) []) i)))\n           {}\n           l))","user":"5b4b4052e4b02d533a91bc9a"},{"code":"(fn [f l] (reduce #(let [r (f %2)]\n                       (assoc % r (conj (% r []) %2))) \n                  {} l))","problem":63,"user":"5163b06be4b055933a9ca030"},{"code":"(fn [f coll] (loop [coll coll retr {}]\n               (if (empty? coll) retr\n                 (let [[v & more] coll\n                       k (f v)]\n                   (if (retr k)\n                     (recur more (assoc retr k (conj (retr k) v)))\n                     (recur more (assoc retr k [v])))))))","problem":63,"user":"532347dde4b09d4e7a9b54cc"},{"code":"(fn my-group-by\n   ([f xs] (my-group-by f xs {}))\n   ([f [x & xs] ret]\n    (if (nil? x) ret\n      (recur f xs (update-in ret [(f x)] #(if (nil? %) [x] (conj % x)))))))","problem":63,"user":"4fe8d862e4b0547ebccb2428"},{"problem":63,"code":"(fn [f coll] (reduce (fn [r v] (assoc r (f v) (vec (conj (get r (f v)) v)))) {} coll))","user":"5a9bfd57e4b0d174b936c7d0"},{"problem":63,"code":"(fn [f s]\n\t\t(reduce \n\t\t\t#(assoc %1 (f %2) (conj (get %1 (f %2) [ ]) %2) )\n\t\t\t(hash-map)\n\t\t\ts\n\t\t)\n\t)","user":"5bbbd484e4b0a20761a23617"},{"problem":63,"code":"(fn p63-group-by [f coll]\n  (apply merge-with concat (map #(hash-map (f %) [%]) coll)))","user":"543b12cce4b032a45b86932a"},{"problem":63,"code":"(fn [f xs] (loop [result {} list xs]\n  (if (= (count list) 0)\n    result\n    (let [x (first list) fx (f x) matches (or (result fx) [])] (recur (assoc result fx (conj matches x)) (rest list)))\n  )))","user":"55d79b87e4b0e31453f64aa8"},{"problem":63,"code":"(fn my-group-by\n  ([fun l] (my-group-by fun l {}))\n  ([fun l resp]\n   (if (= l []) resp\n       (let [f (first l)\n             k (fun f)]\n         (if (contains? resp k)\n           (my-group-by fun (rest l) (assoc resp k (conj (resp k) f)))\n           (my-group-by fun (rest l) (assoc resp k [f])))))))","user":"574f1c24e4b02ea114799255"},{"code":"(fn [f s]\n(let [p (map #(list (f %) %) s)\nk (distinct (map first p))]\n(apply hash-map (mapcat (fn [key]\n(list key\n(map second\n(filter #(= key (first %1)) p))))\nk))))","problem":63,"user":"4fabb1dce4b081705acca21a"},{"code":"(fn [f coll]\n  (reduce (fn [m x]\n            (let [k (f x)]\n              (if (nil? (m k))\n                (assoc m k [x])\n                (assoc m k (conj (m k) x)))))\n          {} coll))","problem":63,"user":"4ff505c8e4b0678c553fc364"},{"problem":63,"code":"(fn [f coll]\n  (reduce #(let [f-result (f %2)\n                 now-value (%1 f-result)]\n             (assoc %1 f-result (if now-value\n                                  (conj now-value %2)\n                                  [%2])))\n          {}\n          coll))","user":"60096aabe4b074f607df667f"},{"problem":63,"code":"(fn groupit [f s]\n  (reduce \n    (fn [m e] \n       (let [z (f e)]\n       (assoc m z (conj (get m z) e ))))\n    {}\n    ; reverse order first to preserve order for the comparison\n    (reverse s)\n  )\n)","user":"55d35a01e4b0e31453f64a63"},{"problem":63,"code":"(fn [pred seq]\n   (reduce (fn [result elem]\n             (assoc result (pred elem) (conj (get result (pred elem) []) elem)))\n           {} seq))","user":"52fac708e4b047fd55836fff"},{"problem":63,"code":"(fn [f col]\n  (reduce #(assoc %\n             (f %2)\n             (conj (get % (f %2) []) %2))\n          {}\n          col))","user":"52393e16e4b0d705d026ef06"},{"problem":63,"code":"(fn [op col] (reduce #(merge-with concat %1 { (op %2) [%2] } ) {} col))","user":"55536a8ae4b0deb715856e03"},{"problem":63,"code":"(fn mapsort [f coll]\n  (apply merge-with (fn [merged new] (into [] (concat merged new)))\n         (map (fn [k v] {k [v]}) (map f coll) coll)))","user":"558053b1e4b05c286339e0e9"},{"code":"(fn [f xs]\n  (apply merge-with concat\n         (map #(hash-map (f %) [%]) xs)))","problem":63,"user":"50772e6ae4b0fc74642bff5d"},{"code":"(fn group [f xl]\n\t(let [v (partition-by f (sort-by f xl)) k (map (comp f first) v)]\n\t\t(apply hash-map (interleave k v))))","problem":63,"user":"51757af0e4b085adf681d873"},{"problem":63,"code":"(fn [f l] (loop [l l r {}]\n            (if (empty? l)\n              r\n              (let [k (f (first l))] (recur (rest l) (assoc r  k (conj (r k []) (first l))))))))","user":"525b142fe4b0cb4875a45d05"},{"code":"(fn [f coll]\n  (apply merge-with concat (map #(assoc {} (f %) [%]) coll)))","problem":63,"user":"4ee75ec2535d93acb0a66867"},{"code":"(fn [f l]\n  (reduce\n   #(let [k (f %2), v (get %1 k [])]\n      (assoc %1 k (conj v %2))) {} l))","problem":63,"user":"51284226e4b03a34742b4308"},{"problem":63,"code":"(fn \n  [f coll]\n  (reduce #(let [k (f %2)\n                 v (get %1 (f %2) [])] (assoc %1 k (conj v %2))) {} coll))","user":"594266cfe4b060784b3b790b"},{"problem":63,"code":"(fn [f s] (apply merge-with concat (map (fn [i] {(f i) [i]}) s)))","user":"53e19461e4b0d874e779ae59"},{"code":"(fn [f coll]\n  (apply merge-with concat\n         (map (fn [elem]\n                (hash-map (f elem) (list elem)))\n              coll)))","problem":63,"user":"4e73a9dc535dff18050a9c77"},{"problem":63,"code":"(fn [func seq]\n(let [maps (for [x seq] {(func x) x})]\n(into {} (for [k (into #{} (mapcat keys maps))\n               :let [obj (Object.)]]\n           [k (filter (partial not= obj)\n                      (map #(get % k obj) maps))]))))","user":"5a9ac061e4b0d174b936c7c1"},{"problem":63,"code":"(fn my-group-by\n  [f sx]\n  (reduce (fn [result-map val]\n            (let [key (f val)]\n              (println key)\n              (if (contains? result-map key)\n                (assoc result-map key (conj (result-map key) val))\n                (assoc result-map key (vector val)))\n              ))\n          {}\n          sx))","user":"568bd448e4b0dcc4269f40a9"},{"problem":63,"code":"#(apply (partial merge-with into) (for [x %2] {(% x) [x]}))","user":"505106fee4b05ab4c7e07d38"},{"problem":63,"code":"(fn jn [f xs]\n     (apply merge-with concat\n       (map #(identity {(f %) [%]}) xs)))","user":"54dae16de4b024c67c0cf758"},{"problem":63,"code":"(fn [p c] \n  (reduce \n   (fn [m e] (update-in m [(p e)] (fnil conj []) e)) \n\t{} c))","user":"4f1ef6a0535d64f60314649b"},{"code":"(fn [f s]\n  (reduce (partial merge-with concat) {} (map (fn [x] (hash-map (f x) [x])) s)))\n\n;(fn [f s]\n;  (loop [f f s s dict (transient {})]\n;    (if (empty? s)\n;      (persistent! dict)\n;      (let [first-s (first s)\n;            key (f (first s))\n;            val (get dict key [])]\n;        (recur f\n;               (rest s)\n;               (assoc! dict key (conj val first-s)))))))","problem":63,"user":"4f849f76e4b033992c121c36"},{"code":"(fn [f cl] \n  (loop [r {} c cl] \n    (if (empty? c) r \n      (let [v (first c) k (f (first c))] \n        (recur \n          (assoc r k (conj (get r k []) v )) \n          (rest c))))))","problem":63,"user":"4f037bb5535dcb61093f6aec"},{"code":"(fn [f aseq]\n  (reduce \n    (fn [m i]\n      (update-in \n        m \n        [(f i)] \n        #(if (nil? %)\n          [i]\n          (conj % i))))\n    {}\n    aseq))","problem":63,"user":"4e7e05a6535db169f9c796fe"},{"problem":63,"code":"(fn [f v] (reduce #(merge-with conj %1 {(f %2) %2}) (zipmap (map f v) (repeat [])) v))","user":"551c66dae4b07993ea3788de"},{"problem":63,"code":"(fn func\n  [f s]\n  (if (empty? s)\n    {}\n    (assoc (func f (rest s)) (f (first s)) (conj (get (func f (rest s)) (f (first s)) '()) (first s)))\n    )\n  )","user":"56de78fde4b0ea9b8538f83c"},{"code":"(fn [f s]\n  (reduce (fn [acc x]\n            (let [k (f x)\n                  new_values (conj (acc k []) x)]\n              (assoc acc k new_values)))\n          {}\n          s))","problem":63,"user":"5160195ae4b0e2be8aa20be3"},{"problem":63,"code":"(fn my-group-by\n  ([f xs] (my-group-by f xs {}))\n  ([f [x & xs] out]\n    (let [k       (f x)\n          v       (get out k [])\n          v       (conj v x)\n          out     (assoc out k v)]\n      (if (empty? xs)\n        out\n        (recur f xs out)\n      )\n    )\n  )\n)","user":"53edb628e4b0d648e757f4c8"},{"code":"(fn [f col]\n  (loop [ret (reduce (fn [m a] (assoc m (f a) [])) {} col) c col]\n    (if (= '() c) ret\n      (recur (assoc ret (f (first c)) (conj (ret (f (first c))) (first c))) (rest c)))))","problem":63,"user":"50bfe725e4b080409b860f26"},{"problem":63,"code":"(fn [f x]\n  (apply merge-with into \n         (for [a x]\n           (apply hash-map [(f a) [a]]))))","user":"5a6a7cc5e4b0512ff01cda27"},{"code":"(fn [f xs]\n       (reduce #(merge-with concat % %2) (map (fn [x] {(f x) [x]}) xs)))","problem":63,"user":"52a88c4de4b0c58976d9ac30"},{"code":"(fn [f s]\n   (reduce #(let [k (f %2)\n                  v (%1 k)]\n              (into %1 [[k (conj (if (nil? v) [] (%1 k)) %2)]])) {} s))","problem":63,"user":"52c25645e4b07a9af579237d"},{"problem":63,"code":"(fn grp-by \n  ([f coll] \n   \t(grp-by {} f coll))\n  ([m f coll]\n   (if (empty? coll)\n     m\n     (let [x (first coll) \n           f-x (f x) \n           v (m f-x) \n           new-v (if (nil? v) (vector x) (conj v x))]\n       (grp-by (assoc m f-x new-v) f (rest coll))))))","user":"54bd3aefe4b0ed20f4ff6edb"},{"problem":63,"code":"(fn [f coll]\n    (loop [i 0 acc {}]\n      (if (= i (count coll)) acc\n          (let [v (nth coll i)\n                k (f v)]\n            (recur (inc i) (assoc acc k (conj (get acc k []) v)))))))","user":"595bbab7e4b066ee0a44afe0"},{"problem":63,"code":"(fn [f s]\n  (reduce-kv\n    (fn [m k v]\n      (let [val (f v)]\n        (assoc-in m [val] (vec (conj (get m val) (nth s k))))))\n    {} s))","user":"5dc72a9ce4b02f9375f4e1cd"},{"code":"(fn [f s]\n    (reduce (fn [m v] (assoc m (first v) (conj (vec (get m (first v))) (second v)))) {}\n      (map (fn [x] [(f x) x]) s)))","problem":63,"user":"526f9715e4b03e8d9a4a7372"},{"problem":63,"code":"(fn [f v]\n    (into {} (map #(vector (f (first %)) (vec %))\n                  (partition-by f (sort v)))))","user":"52b2f9cae4b0c58976d9acfb"},{"problem":63,"code":"(fn [func coll]\n    (into {} (map\n     (fn [result]\n       [result (filter #(= result (func %)) coll)]\n       )\n     (set (map func coll))))\n    \n    )","user":"5bf9d9b7e4b0bdcf453d15c4"},{"problem":63,"code":"#(reduce\n  (fn [m x]\n    (let [k (% x)]\n      (if (contains? m k)\n        (conj m [k (conj (get m k) x)])\n        (conj m [k [x]]))))\n  {} %2)","user":"563f24f9e4b08d4f616f5ed0"},{"problem":63,"code":"(fn [f coll]\n  (reduce #(let [key (f %2)]\n             (if (contains? %1 key)\n               (update-in %1 [key] conj %2)\n               (assoc %1 key (conj [] %2))))\n          {}\n          coll))","user":"5d68f5e6e4b0db5d338d1605"},{"code":";; not tail recursive, but nice shape...\n(fn gb [f [i & c]]\n  (when i\n    (merge-with concat\n                {(f i) [i]}\n                (gb f c))))","problem":63,"user":"4db2f208535df7e46ed9b6c9"},{"problem":63,"code":"(fn gb\n  [f col]\n  (reduce\n    (fn [m x]\n      (let [key (f x)\n            val (or (get m key) [])\n            new-val (conj val x)]\n      (assoc m key new-val)))\n    {}\n    col))","user":"5b0e6795e4b0cc2b61a3be03"},{"code":"(fn gs [f s]\n  (reduce (fn rf [x [k v]]\n            (update-in x [k] (fnil (fn [ov]\n                                   (conj ov v)) []))\n            ) {} (map #(vec [(f %) %]) s)))","problem":63,"user":"52140b53e4b0961f15ac4d7e"},{"code":"#(reduce (fn [m x] (merge-with into m {(%1 x) [x]})) {} %2)","problem":63,"user":"4df0524e535d08e6dec9fe17"},{"problem":63,"code":"(fn [f s]\n  (reduce (fn [res x] (update-in res [(f x)] (fnil conj []) x )) {} s))","user":"5eee7311e4b07c55ae4a0510"},{"code":"(fn group [f coll]\n (apply merge-with concat (for [x coll] {(f x) [x]})))","problem":63,"user":"531dfaf5e4b08068f379edb3"},{"problem":63,"code":";(\n(fn [f li]\n  (reduce\n   (fn [out n]\n     (update-in\n      out\n      [(f n)]\n      (fn [old]\n        (conj\n         (or old [])\n         n))))\n   {}\n   li))\n\n;#(> % 5)\n;[1 3 6 8])","user":"5e64ae6ce4b0fd0acd1586ac"},{"code":"(fn [f s]\n  (reduce #(assoc %1 (f %2) (conj (%1 (f %2) []) %2))\n  {}\n  s))","problem":63,"user":"518a59b3e4b02bf06f6bbb4b"},{"problem":63,"code":"(fn [fun coll] (reduce #(let [k (fun %2)] (conj %1 [k (vec (conj (get %1 k) %2))])) {} coll))","user":"5d6d2172e4b04d129b00f2b9"},{"problem":63,"code":"(fn [f xs] ( let [fr (fn [m fs] \n                  (if (first fs) (let [k (first (first fs))]\n                  \t  (if (contains? m k)  \n                           (recur (assoc m k (conj  (m k) (second (first fs)))) (rest fs)) \n                                  \n                           (recur (assoc m k [(second (first fs))]) (rest fs)) \n                        ))\n                       m )\n                      )]\n             (fr {} (partition 2 (interleave (map f xs) xs)))\n             ))","user":"59ff9424e4b01bb0ae8afd24"},{"code":"(fn [f coll]\n    (reduce\n      (fn \n        [curr nxt]\n        (let [k (first nxt) \n              v (second nxt)\n              olds (get curr k [])\n              news (conj olds v)\n              ]\n          (assoc curr k news))\n      )\n      {}\n      (partition 2 (interleave (map f coll) coll))))","problem":63,"user":"527675cbe4b03e8d9a4a74e2"},{"problem":63,"code":"(fn [f s]\n      (reduce (fn [result e]\n                (let [key (f e)\n                      values (result key [])\n                      new-values (conj values e)]\n                  (assoc result key new-values)))\n              {}\n              s))","user":"53f891eee4b0de5c4184856d"},{"code":"(fn [f s]\n  (letfn [\n    (gen-kv-pairs [f coll] (map #(vector (f %) %) coll)) \n    (multi-assoc [m k v]\n      (assoc m k \n        (if (contains? m k) \n          (conj (get m k) v) \n          [v])))\n    (build-map [pairs m]\n      (if (seq pairs)\n        (let [p (first pairs) k (first p) v (second p)]\n          (recur (rest pairs) (multi-assoc m k v)))\n        m))]\n    (build-map (gen-kv-pairs f s) {})))","problem":63,"user":"4e8f4f64535d65386fec2149"},{"code":"(fn [f coll]\n  (reduce (fn [m item]\n              (let [k (f item)]\n                   (assoc m k (conj (get m k []) item))))\n          {} coll))","problem":63,"user":"4f2582bae4b0d66497709ff6"},{"code":"(fn [f xs] (apply hash-map (mapcat (fn [qs] [(f (first qs)) qs]) (partition-by f (sort-by f xs)))))","problem":63,"user":"4f426a7ae4b0d7d3c9f3fcff"},{"code":"(fn [f coll] (apply merge-with concat (map #(hash-map (f %) [%]) coll)))","problem":63,"user":"50fc299ee4b0d10d794c19f2"},{"code":"(fn [f s] (reduce (fn [m v] (update-in m [(f v)] #(conj (or % []) v))) {} s))","problem":63,"user":"5028cd0fe4b01614d1633ffc"},{"code":"(fn [f,v]\n  (reduce #(assoc % (f %2) (conj (get % (f %2) []) %2)) {} v))","problem":63,"user":"4fbef9a6e4b081705acca316"},{"code":"(fn [f xs]\r\n  (reduce\r\n    (fn [a x] (let [k (f x) v (get a k [])] (assoc a k (conj v x))))\r\n    {}\r\n    xs))","problem":63,"user":"4dd52e29535dae65d5c462e5"},{"problem":63,"code":"(fn grp-by\n  [f arr]\n    (into (sorted-map) \n          (map #(vector (f (first %)) %) \n           \t\t(partition-by f \n                              (sort-by f arr)))))","user":"59733c91e4b01722bebd4c9b"},{"code":"(fn [f s]\n    (reduce\n      (fn [m v]\n        (assoc m (f v)\n          (conj (get m (f v) []) v)))\n      {} s)\n )","problem":63,"user":"4ff3df0fe4b0678c553fc355"},{"problem":63,"code":"(fn [f s]\n  (reduce (fn [m new]\n            (if (contains? m (f new))\n              (assoc m (f new) (conj (m (f new)) new))\n              (assoc m (f new) [new])))\n          {} s))","user":"55625903e4b0c656e3ff17d7"},{"code":"(fn [f s]\n  (reduce (fn [acc v]\n            (merge-with\n             concat\n             acc\n             {(f v) [v]}))\n          {}\n          s))","problem":63,"user":"4fa340b4e4b081705acca18c"},{"problem":63,"code":"(fn my-group-by\n  [f s]\n  (reduce (fn [result v]\n            (let [fv (f v)]\n              (assoc result fv (conj (or (result fv) []) v))))\n          {} s))","user":"563f1493e4b08d4f616f5ecf"},{"problem":63,"code":"#(reduce (fn [a x] (update-in a [(%1 x)] (fn [a b] (conj (vec a) b)) x)) {} %2)","user":"4e11b92a535d04ed9115e7cb"},{"problem":63,"code":"(fn[f xs]\n  (reduce (fn [t v] (merge-with concat t (hash-map (f v) [v]))) {} xs))","user":"54dce62fe4b024c67c0cf78c"},{"code":"#(apply merge-with concat\r\n    (for [x %2]\r\n      {(% x) [x]}))","problem":63,"user":"4f9597e0e4b0dcca54ed6cd4"},{"code":"(fn [a b] (let [x (distinct (map a b))] \n            (reduce merge (map \n             #(hash-map % (filter (fn [c] \n                                    (= (a c) %)\n                                  )\n                           b)\n               ) \n             x\n             ))\n           )\n  )","problem":63,"user":"51aeb1f4e4b09397d5109794"},{"code":"(fn [f coll]\n  (apply merge-with concat\n    (map #(hash-map (f %) [%]) coll)))","problem":63,"user":"4fa5406fe4b081705acca1ac"},{"code":"(fn [f s]\n  (reduce\n    (partial merge-with concat)\n    (map \n     (fn [e] {(f e) [e]})\n    s)))","problem":63,"user":"4fb1d907e4b081705acca282"},{"problem":63,"code":"(fn [f1 xs]\n  (reduce (fn [mymap x]\n            (update-in mymap [(f1 x)] #(into (vec %) [x])))\n           {} xs))","user":"5351fca5e4b084c2834f4aec"},{"problem":63,"code":"(fn [f lst]\n   (into {} \n        (map #(vector (f (first % )) (vec %)) (partition-by f (sort lst)))))","user":"57210e8ee4b0c5bde472c0a8"},{"problem":63,"code":"(fn [f x] (apply hash-map (apply vector (mapcat (fn [x] (list (first (first x)) (apply vector (mapcat rest x)))) (partition-by first (sort-by first (map #(list (f %) %) x)))))))","user":"56fdd9a1e4b08d47c97781a8"},{"code":"(fn [f coll]\n   (reduce (fn [ret x]\n             (let [k (f x)]\n               (assoc ret k\n                      (conj (get ret k []) x))))\n           {} coll))","problem":63,"user":"4f409e29e4b0e243712b1fb6"},{"code":"(fn [f xs]\n  (reduce\n    (fn [result value]\n      (let [group-key (f value)]\n        (merge-with concat result { group-key [value] })))\n    {}\n    xs))","problem":63,"user":"50e3ddd4e4b01912b3285c47"},{"problem":63,"code":"#(->> (map (juxt % vector) %2)\n      (map (partial apply hash-map))\n      (apply merge-with concat))","user":"5cfee28de4b0cc9c91588185"},{"problem":63,"code":"(fn grp\n  [f s]\n  (loop [res {} xs s]\n    (if (seq xs)\n      (let [val (first xs)\n            key (f val)]\n        (if (contains? res key)\n          (recur (assoc res key (conj (res key) val))\n                 (next xs))\n          (recur (assoc res key [val])\n                 (next xs))))\n      res)))","user":"54c3747de4b045293a27f60e"},{"problem":63,"code":"; retry first solution with for and destructuring\n#(reduce\n  (fn [m [k v]] (assoc m k (conj (get m k []) v)))\n  {}\n  (for [x %2] [(% x) x]))\n\n; like burner's solution but with ruby-like \"a ||= []\" instead of \"if\"\n#_(fn [f coll]\n  (reduce \n    (fn [m v] (update-in m [(f v)] #(conj (or % []) %2) v))\n    {}\n    coll))\n\n; from balint\n#_(fn [f coll]\n  (apply merge-with concat\n    (for [x coll] {(f x) [x]})))\n\n; second solution: factor out repeated key computation\n#_(fn [f xs]\n  (reduce\n   (fn [m x]\n     (let [k (f x)] (assoc m k (conj (get m k []) x))))\n   {}\n   xs)) \n\n; first solution\n#_(fn [f xs]\n  (reduce #(assoc % (f %2) (conj (get % (f %2) []) %2)) {} xs))","user":"55e7d06ee4b050e68259b496"},{"problem":63,"code":"(fn [f coll] \n    (reduce \n     (fn [acc v] \n       (let [key (f v)] \n         (assoc \n             acc \n           key \n           (conj (acc key []) v)))) \n     {} \n     coll))","user":"567476bde4b05957ce8c6139"},{"code":"(fn [f s] (apply (partial merge-with concat) (map (fn [x] {(f x) [x]}) s)))","problem":63,"user":"50f17c0de4b06d9538fe2123"},{"problem":63,"code":"(fn group-by3\n  [f coll]\n  (reduce\n    (fn my-assoc [imap x]\n      (assoc imap (f x) (conj (get imap (f x) []) x)))\n    {} coll)\n  )","user":"53f6bfd9e4b0db01ade6f9e4"},{"code":"(fn [f coll]\n  (reduce\n    #(let [k (f %2)]\n\t  (assoc %1 k (conj (%1 k []) %2)))\n    {} coll))","problem":63,"user":"53513d28e4b084c2834f4ae3"},{"code":"(fn blah [f coll]\n    (loop [c coll\n           accum {}]\n      (if (empty? c)\n        accum\n        (recur (rest c) (assoc accum (f (first c)) \n                               (conj (get accum (f (first c)) []) \n                                     (first c)))))))","problem":63,"user":"4f17aa97535d64f603146456"},{"code":"#(reduce (fn [val n] (assoc val (%1 n) (vec (conj (get val (%1 n)) n)))) {} %2)","problem":63,"user":"511b810ce4b07ab9ec456182"},{"problem":63,"code":"(fn [f lst]\n(let [l (map (juxt f identity) lst)]\n    (let [groups  (for [x (distinct (map first l))]\n                    (filter #(= x (first %)) l))]\n      (into {} (for [y groups]\n               (into {} (hash-map (first (first y)) (vec (map second y)))))))))","user":"587f8393e4b0f1effa3b75f2"},{"code":"(fn [f coll] (apply merge-with concat (map #(-> {(f (first %))\n             (vec %)}) (partition-by f coll ))))","problem":63,"user":"51d9eb05e4b02ceefd947755"},{"problem":63,"code":"(fn [f coll]\n  (apply hash-map (let [result-set (map identity (into  #{} (map f coll)))]\n    (loop [[h & r] result-set\n          result []]\n      (if (nil? h)\n        result\n        (recur r (concat result [h] (list(vec (filter #(= h (f %)) coll ))))))))))","user":"53e241a6e4b036ad0777e3f0"},{"problem":63,"code":"#(reduce (fn [acc x] (assoc acc (%1 x) ((fn [y] (if (nil? y)\n                                                  (vector x)\n                                                  (conj y x))) (get acc (%1 x))))) {} %2)","user":"5e9b7aefe4b0157ca96647f1"},{"problem":63,"code":"(fn [f sq] (reduce (fn [coll a] ((fn [m k f x] (assoc m k (f (get m k) x))) coll (f a) (fn [val x] (conj (or val []) x)) a)) {} sq))\n\n#_(fn [f sq]\n    (reduce (fn [coll a]\n              (update coll (f a) (fn [val x]\n                                   (conj (or val []) x)) a))\n              {}\n              sq))\n; why does it not recognize 'update'?","user":"5d046f7ce4b0cc9c915881d5"},{"code":"(fn Group-by [f, seq]\n  (cond (empty? seq) {}\n        :else (let [ param (first seq)\n                     value (f param)\n                     mapping (Group-by f (rest seq))]\n              (assoc mapping \n                     value \n                     (conj (get mapping value '()) param)))))","problem":63,"user":"4eeae8f0535d93acb0a668a2"},{"problem":63,"code":"(fn [f a] (reduce\n  (fn [c d] \n    (assoc c (f d) \n      (conj (get c (f d) []) d)))\n {} a))","user":"583e1558e4b089d5ab817da9"},{"code":"(fn [f s]\n  (reduce\n    (fn [coll elt]\n      (assoc coll (f elt) (conj (get coll (f elt) []) elt)))\n    {}\n    s))","problem":63,"user":"4fe9d647e4b0547ebccb2472"},{"code":"(fn [f s] (reduce #(assoc %1 (f %2) (concat (get %1 (f %2)) [%2])) {} s))","problem":63,"user":"4eae5fe4535d7eef30807325"},{"problem":63,"code":"(fn groupby2\n  ([f coll] (groupby2 f coll {}))\n  ([f coll coll-acc]\n     (if-not (seq coll)\n       coll-acc\n       (let [elem (first coll) res (f elem)]\n         (recur f (rest coll) (assoc coll-acc res (conj (get coll-acc res []) elem)))))))","user":"53f2370ee4b0742d9025b0e7"},{"problem":63,"code":"(fn [f s]\n  (->> s \n       (sort-by f) \n       (partition-by f) \n       (reduce \n        (fn [result group] (conj result [(f (first group)) group])) \n        []) \n       (into {})))","user":"54febf4be4b07d26eda61d45"},{"code":"(fn [f col] (reduce #(merge-with concat % {(f %2) [%2]}) {} col))","problem":63,"user":"51b9d1f0e4b0e871ca49590b"},{"problem":63,"code":"(fn [f l] (reduce (fn [%1 %2] (merge-with into %1 {(f %2) [%2]}))  {} l))","user":"58983e3fe4b00487982d52ce"},{"code":"(fn [f s] (apply merge-with concat\n  (map #(hash-map (f %) [%]) s)\n))","problem":63,"user":"50807940e4b01a93d3f38e44"},{"problem":63,"code":"(fn [f s]\n  (reduce (fn [m v]\n            (let [k (f v)\n                  existing (m k)]\n               (if existing\n              \t(assoc-in m [k] (apply conj existing (vector v)))\n                (assoc-in m [k] (vector v)))))\n          {}\n          s))","user":"56b18445e4b0982f16b37dee"},{"problem":63,"code":"(fn [f s]\n  (reduce (fn [acc v] (let [k (f v)\n                            cv (get acc k)]\n                        (if (contains? acc k)\n                          (assoc acc k (conj cv v))\n                          (assoc acc k [v])))) {} s))","user":"542c22bde4b0dad94371f29e"},{"problem":63,"code":"(fn [f args] (reduce \n               #(assoc %1 (first %2) (conj (%1 (first %2) []) (second %2))) \n               {}\n               (map vector (for [x args] (f x)) args )))","user":"546c1b2ce4b00cfc9eacc174"},{"code":"(fn group-it\n  [f coll]\n  (reduce\n    (fn [result x]\n      (println result x)\n      (assoc result (f x) (conj (get result (f x) []) x))\n      ) {} coll))","problem":63,"user":"4faa6184e4b081705acca1f1"},{"code":"(fn my-group-by [f s]\n  (apply \n    (partial merge-with #(vec (concat %1 %2)))\n    (map #(hash-map (f %) [%]) s)))","problem":63,"user":"4f9c4080e4b0dcca54ed6d1a"},{"problem":63,"code":"(fn [f s]\n          (reduce #(let [k (f %2)] (assoc %1 k (if (contains? %1 k)\n                                                 (conj (get %1 k) %2)\n                                                 [ %2 ])))\n                  {} s))","user":"53f592b7e4b0db01ade6f9d0"},{"code":"(fn [f coll]\n  (reduce (fn [m [fx x]]\n            (if-let [e (m fx)]\n              (assoc m fx (conj e x))\n              (assoc m fx [x])))\n          {}\n          (map #(list (f %) %) coll)))","problem":63,"user":"4e8c1d97535d65386fec2127"},{"code":"(fn [func coll]\n  (loop [unique (distinct (map func coll))\n         result {}]\n    (if (not (seq unique))\n      result\n      (recur \n       (rest unique) \n       (assoc result (first unique) (vec (filter #(= (func %) (first unique)) coll)))))))","problem":63,"user":"51857e64e4b0da5a5be3babe"},{"problem":63,"code":"(fn [f,s] \n  (reduce \n    (fn [m,k] \n      (update-in m [(f k)] #(concat %1 [k])))\n    {} \n    s))","user":"5606a4ace4b08b23635d3175"},{"problem":63,"code":"(fn [f xs]\n  (reduce (fn [acc x] \n          (assoc acc (f x) \n                 (conj (vec (acc (f x)))\n                       x)))\n        {}\n        xs))","user":"52c35afce4b07a9af579238c"},{"code":"(fn g [f s]\n  (if (empty? s)\n    {}\n    (let [h (g f (rest s))\n          v (f (first s))]\n    (if (contains? h v)\n      (assoc h v (cons (first s) (get h v)))\n      (assoc h v (vector (first s)))))))","problem":63,"user":"4f559d2ce4b0a7574ea71808"},{"code":"(fn [fun coll]\n    (let [keys (set (map fun coll))]\n      (into {}\n        (for [k keys]\n          [k (vec (filter #(= (fun %) k) coll))] ))))","problem":63,"user":"4ee77f15535d93acb0a66868"},{"problem":63,"code":"(fn [f items]\n  (reduce\n   (fn [new-map next-elem]\n     (update-in new-map [(f next-elem)] (fnil #(conj % next-elem) [])))\n   {}\n   items))","user":"58a47197e4b01a0c0b2328f9"},{"code":"(fn [f s]  \n  (let [m (map #(vector (f %) (vector %)) s)]\n    (apply merge-with #(concat % %2) (for [x m] (apply hash-map x)))))","problem":63,"user":"4daf907aedd6309eace4d17b"},{"problem":63,"code":"(fn [f s]\n  (reduce\n    #(let [v (f %2)]\n       (assoc %1 v (conj (get %1 v []) %2))) {} s))","user":"4ef9b021535dced4c769f269"},{"problem":63,"code":"(fn [f coll] ((fn [res] (zipmap res (map #(filter (fn [result] (= % (f result))) coll) res))) (map f coll)))","user":"54db3d82e4b024c67c0cf75f"},{"problem":63,"code":"(fn group-seq [f s]\n  (loop [i 0\n         result {}]\n    (if (= i (count s))\n      result\n      (let [item (get s i)\n            item-key (f item)\n            inci (inc i)]\n        (if (contains? result item-key)\n          (let [item-val (get result item-key)\n                incval (conj item-val item)]\n            (recur inci (assoc result item-key incval)))\n          (recur inci (assoc result item-key [item])))))\n    )\n  )","user":"5c24c654e4b07e362c2305a7"},{"code":"#(reduce\n  (fn [ret [key item]]\n    (if (contains? ret key)\n      (update-in ret [key] (fn [v] (conj v item)))\n      (assoc ret key [item])))\n  {} (map (fn [x y] (vector x y)) (map %1 %2) %2))","problem":63,"user":"51ca7906e4b08b1cbd0d9487"},{"problem":63,"code":"(fn [f s]\n\t(let [\n\t\tfs (map f s)\n\t\tcombined (map vector fs s)\n\t\t]\n\t\t(reduce\n\t\t\t(fn [ acc, [k, v] ]\n\t\t\t\t(let [ currentVal (get acc k) ]\n\t\t\t\t\t(if (nil? currentVal)\n\t\t\t\t\t\t(assoc acc k [v])\n\t\t\t\t\t\t(assoc acc k (conj currentVal v)))))\n\t\t\t{}\n\t\t\tcombined)))","user":"598af379e4b02b9968b84ce6"},{"problem":63,"code":"(fn gb [f coll]\n  (reduce \n    (fn [m x] (update-in m [(f x)] #(conj (vec %) x)))\n    {}\n    coll))","user":"5a91988ae4b002d099cae6f9"},{"code":"(fn [f s]\n\t(reduce\n\t\t(fn [m v]\n\t\t\t(let [k (f v)]\n\t\t\t\t(assoc m k (conj (get m k []) v))))\n\t\t{}\n\t\ts))","problem":63,"user":"4dda44f2535d02782fcbe9f1"},{"code":"(fn [x y]\n  (loop [m {} X x Y y]\n    (if(empty? Y)\n      m (let [F (first Y) K (X F) R (rest Y)] (if (m K)\n       (recur (assoc m K (conj (m K) F )\n\t\t   ) X R) \n       (recur (assoc m K [F]) X R))\n       )\n      )\n    ))","problem":63,"user":"536c77f1e4b0fc7073fd6e3f"},{"code":"(fn [f s]\n  (loop [hm {}, data s]\n    (if (empty? data)\n      hm\n      (let [datum (first data), \n            result (f datum),\n            updated-hm (merge-with concat hm {result [datum]})]\n        (recur updated-hm (rest data))))))","problem":63,"user":"51ce1320e4b0e42293a22551"},{"problem":63,"code":"(fn my-group-by [f coll]\n  (loop [eq-classes {}\n         coll coll]\n    (let [x (first coll)]\n      (if (empty? coll)\n        eq-classes\n      (if (contains? eq-classes (f x))\n        (recur (update-in eq-classes [(f x)] conj x)\n               (rest coll)) \n        (recur (assoc eq-classes (f x) [x])\n               (rest coll)))))))","user":"571c2babe4b07c98581c3b73"},{"code":"(fn [f l] \n  (let [ks (set (map f l)) \n        mmap (fn [acc ks l f] \n               (if (empty? ks) acc \n              (recur (assoc acc (first ks) (filter #(= (first ks) (f %)) l)) \n                     (rest ks) l f)))] \n    (mmap {} ks l f)))","problem":63,"user":"5273e006e4b03e8d9a4a7495"},{"problem":63,"code":"(fn [f coll]\n  (reduce (fn [r e]\n            (update-in r [(f e)] (fnil conj []) e))\n          {} coll))","user":"50666699e4b03d366d7cb2b0"},{"problem":63,"code":"(fn [g vs]\n            (reduce\n             (fn [acc v]\n               (update-in acc [(g v)] (fnil conj []) v))\n             {}\n             vs))","user":"53684a2fe4b0243289761e8c"},{"code":"#((fn [xs f acc] \n  (if (= xs '())\n      acc\n      (recur (rest xs) \n             f\n             (let [key (f (first xs))]\n              (assoc acc key\n                     (concat (get acc key '()) (list (first xs))) )))))\n  %2 %1 {})","problem":63,"user":"4f039bbe535dcb61093f6b39"},{"code":"(fn [f s] (let [results (set (map f s))\n       groups (map (fn [x] (filter #(= x (f %)) s)) results)]\n   (zipmap results groups)))","problem":63,"user":"511026b1e4b04c71fce993ec"},{"problem":63,"code":"(fn [func s]\n  (into {} (for [key (reduce (fn [result elem]\n                               (cons (func elem) result)) #{} s)]\n             {key (vec (filter #(= key (func %)) s))})))","user":"60b8b0f8e4b0e0fa5f1b425c"},{"problem":63,"code":"(fn [f xs]\n   (apply merge-with into (map #(hash-map (f %) [%]) xs) ) )","user":"570d0548e4b0b0fb43fd06d2"},{"problem":63,"code":"(fn [f s]\n  (into {} (map #(vector (f (first %)) %) (partition-by f (sort-by f s)))))","user":"536046a9e4b063bf7a5f8fe1"},{"problem":63,"code":"(fn [f s] \n  (reduce \n   #(assoc %1 \n      (f %2) (conj (vec (%1 (f %2))) %2)) \n   {} \n   s))","user":"55caabd1e4b0e31453f649fb"},{"code":"(fn [f coll] (loop [c coll m {}]\n  (if (empty? c)\n    m\n    (let [el (first c)]\n      (recur (rest c)\n             (conj m [(f el)\n                      (conj (vec (m (f el))) el)]))))))","problem":63,"user":"5341b141e4b00652c8746ecf"},{"problem":63,"code":"#(loop [i 0 y {}]\n    (if (= i (count %2)) y\n      (let [x (nth %2 i) xi (% x)]\n        (recur (inc i) (assoc y xi (conj (y xi []) x))))))","user":"53fb4843e4b0de5c4184857d"},{"code":"(fn [f s]\n  (let [k (distinct (map f s))\n        res (apply hash-map (interleave k (repeat (count k) [])))]\n    (reduce (fn [a b] (assoc a (f b) (conj (a (f b)) b))) res s)))","problem":63,"user":"4f343e60e4b0e243712b1eb5"},{"problem":63,"code":"(fn group-by* [f coll]\n\t(persistent! (reduce (fn [ret x]\n\t\t\t\t\t\t\t(let [k (f x) v (get ret k [])]\n\t\t\t\t\t\t\t\t(assoc! ret k (conj v x))))\n\t\t\t\t\t\t(transient {})\n\t\t\t\t\t\tcoll)))","user":"55b8c339e4b01b9910ae29b9"},{"code":"#(into {} \n  (for [k (set (map % %2))]\n    [k (filter (fn [x] (= k (% x))) %2)]))","problem":63,"user":"522454f4e4b01819a2de42d3"},{"problem":63,"code":"(fn [a b]\n  (reduce (fn [x y]\n            (merge-with #(conj %1 %2) x {(a y) y}))\n          (zipmap (into []\n                        (into #{}\n                              (map a b)))\n                  (repeat (count b) []))\n          b))","user":"57ec3d29e4b0bfb2137f5b77"},{"code":"(fn [f c] (into {} (for [q (set (map f c))] [q (keep #(if (= q (f %)) %) c)])))","problem":63,"user":"512f06c5e4b0762be4c7aad7"},{"code":"(fn [f c]\n  (apply merge (map #(hash-map (f (first %)) (vec %)) (partition-by f (sort-by f c)))))","problem":63,"user":"4f9f7daae4b0dcca54ed6d37"},{"code":"(fn [f l]\n  (reduce #(merge-with concat % {(f %2) [%2]}) {} l))","problem":63,"user":"503de5aae4b06c4e0e1fa259"},{"problem":63,"code":"(fn [f s]\n  (reduce (fn [m i]\n            (let [v (f i)]\n              (if (nil? (get m v))\n                (assoc m v [i])\n                (assoc m v (conj (get m v) i)))))\n          {}\n          s))\n\n;;(assoc m k (f (get m k) x)))","user":"53573d70e4b04ce2eb3ed278"},{"problem":63,"code":"(fn\n  [f seq]\n   [f seq]\n  (reduce (fn [a c]\n            (merge-with into a {(f c) [c]}))\n          {}\n          seq))","user":"5c44f0fde4b0e06e1360a384"},{"problem":63,"code":"(fn gb [f col] (apply merge-with into (for [value col] {(f value) [value]})))","user":"5c7f7889e4b0d597f478cae0"},{"problem":63,"code":"(fn[f coll](reduce (fn[m v](let [val (f v)](merge-with concat m {val [v]})) ) {} coll))","user":"555c6344e4b0b056612e224c"},{"code":"(fn [f xs]\n  (reduce (fn [m el]\n            (let [fel (f el)]\n              (assoc m fel (conj (get m fel []) el))))\n          {}\n          xs))","problem":63,"user":"4f3a979de4b0e243712b1f10"},{"problem":63,"code":"(fn [f c]\n    (->> c\n         (map #(hash-map (f %1) [%1]))\n         (apply merge-with concat)))\n\n;; (fn [f c]\n;;     (reduce (fn [acc e]\n;;               (let [e-key (f e)\n;;                     e-key-vals (get acc e-key [])]\n;;                 (assoc acc e-key (conj e-key-vals e))\n;;                 ))\n;;             {}\n;;             c))\n\n;; #(apply merge-with into (for [v %2]\n;;                             {(% v) [v]}))","user":"591ad160e4b09b4ee5954bdf"},{"problem":63,"code":"(fn [fun coll] \n  (reduce (fn [colls next] \n            (let [curr (fun next) coll-curr (get colls curr [])] \n              (assoc colls curr (conj coll-curr next)))) \n          {}\n          coll))","user":"5d84545ee4b0915913b1d38b"},{"problem":63,"code":"(fn [f coll]\n  (reduce\n    (partial merge-with concat)\n    {}\n    (map\n      (fn [e]\n        {(f e) [e]})\n      coll)))","user":"554bd33ce4b0a04f7929959a"},{"problem":63,"code":"(fn [f seq] (reduce #(merge-with into %1 (hash-map (f %2) [%2]))\n               {} seq))","user":"5b337ff4e4b025bcb146f339"},{"problem":63,"code":"#(reduce \n  (fn [acc, cur]\n    (let [result (%1 cur), value (acc result)]\n      (if value\n        (assoc acc result (conj value cur))\n        (assoc acc result [cur])))) {} %2)","user":"555883c5e4b0deb715856e2d"},{"code":"(fn [f a] (loop [r {} i a] (if (empty? i) r (let [k (f (first i))] (recur (if (contains? r k) (assoc r k (conj (r k) (first i))) (assoc r k (vector (first i)))) (rest i))))))","problem":63,"user":"4f0e4ebd535d0136e6c22322"},{"problem":63,"code":"(fn g-by [f s]\n      (reduce (fn [m e]\n                (let [v (f e)\n                      g (get m v [])\n                      ng (conj g e)]\n                  (assoc m v ng))\n                ) {} s))","user":"5957cc41e4b066ee0a44af76"},{"problem":63,"code":"(fn [f s]\n  (->> (map #(hash-map (f %) [%]) s)\n       (reduce #(merge-with into %1 %2))))","user":"5f5358b7e4b0a0bc16850a77"},{"problem":63,"code":"(fn [f coll]\n  (reduce\n (fn [ret x]\n   (let [k (f x)]\n     (assoc ret k (conj (get ret k []) x))))\n {} coll))","user":"51e3a549e4b0c611d6113e47"},{"code":"#(reduce (fn [m e] (assoc m (% e) (conj (m (% e) []) e))) {} %2)","problem":63,"user":"4e52d815535d302ef430da77"},{"code":"(fn [f coll] \n (reduce \n    (fn [ret x] \n      (let [c (f x)] \n        (assoc ret c (conj (get ret c []) x))))\n    {} coll))","problem":63,"user":"4e6cf521535de274dd8d818b"},{"problem":63,"code":"(fn my-group-by [f coll]\n    (reduce (fn [acc x]\n              (println \"acc\" acc \"x\" x)\n              (if (contains? acc (first x))\n                (conj acc [(first x) (conj (acc (first x)) (last x))])\n                (conj acc [(first x) [(last x)]])))\n            {}\n            (map #(vector (f %) %) coll)))","user":"5429986ce4b01498b1a71b3b"},{"code":"(fn group-a-sequence\n  \t([f aseq]\n\t\t\t(if (empty? aseq) {}\n\t\t\t\t(let [val (first aseq)\n\t\t\t\t\t  key (f val)\n\t\t\t\t\t  themap (group-a-sequence f (rest aseq))\n\t\t\t\t\t  thevec (or (themap key) '())]\n\t\t\t\t\t(assoc themap key (cons val thevec))))))","problem":63,"user":"4e6a63fd535d8ccf87e9feda"},{"problem":63,"code":"(fn\n  [f coll]\n  (into {}\n        (map #(vector (f (first %)) (vec %))\n             (partition-by f (sort coll)))))","user":"55842bd7e4b05c286339e11c"},{"problem":63,"code":"(fn my-group-by [f seq]\n  (reduce \n   (fn [acc val]\n     (let [x (f val)]\n       (assoc acc x (conj (get acc x []) val))))\n   {}\n   seq))","user":"53350264e4b0656e627bfd73"},{"problem":63,"code":"(fn group-a-sequence\n  [f vals]\n  (into {}\n        (map #(vector (f (first %)) (vec %))\n             (partition-by f (sort vals)))))","user":"5e9771dee4b0157ca96647d0"},{"problem":63,"code":"(fn my-group-by [f coll]\n\t(reduce (fn [m [k v]]\n\t\t\t\t\t\t(if (contains? m k) (assoc m k (conj (get m k) v))\n\t\t\t\t\t\t\t\t\t\t\t(assoc m k [v]))) {} (map (fn [item] [(f item) item]) coll)))","user":"593c1e3be4b069cdc2982b86"},{"code":"(fn [f xs]\r\n       (reduce #(let [ret (f %2)] \r\n                  (assoc %1 ret (vec (conj (%1 ret) %2))))\r\n         {} xs))","problem":63,"user":"4deb529a535d08e6dec9fe04"},{"problem":63,"code":"(fn [f s] \n  (into {} (map \n   #(vector % (filter(fn [x] (= % (f x))) s)) \n   (into #{} (map f s)))))","user":"4faf97d8e4b081705acca258"},{"problem":63,"code":"(fn [op s]\n\n  (let [keys (map op s) vals s]\n    (loop [r {} k keys v vals]\n      (if (empty? k)\n        r\n        (recur (assoc r (first k) (conj (get r (first k) []) (first v))) (rest k) (rest v))\n        )\n      )\n    )\n  )","user":"55d42f78e4b0e31453f64a73"},{"code":"(fn [f s]\n  (let [ks (set (map f s))\n        vls (for [k ks]\n              (filter #(= (f %) k) s))]\n   (zipmap ks vls)))","problem":63,"user":"4e5a2403535d8a8b8723a2a7"},{"problem":63,"code":"(fn [f s] (loop [groupings {} suffix s] (if (empty? suffix) groupings (recur (assoc groupings (f (first suffix)) (conj (get groupings (f (first suffix)) []) (first suffix))) (rest suffix)))))","user":"5e1cc888e4b0dc959400853d"},{"problem":63,"code":"(fn group-stuff [f l] (reduce (fn [a b] (assoc a (f (first b)) b)) {} (partition-by f (sort-by f l))))","user":"55f2b42be4b06e875b46ce4a"},{"problem":63,"code":"(fn [f s]\n  (reduce (fn [m curr] (assoc m (f curr) (if (nil? (get m (f curr))) [curr] (conj (get m (f curr)) curr)))) {} s))","user":"5c76577ae4b0fca0c16227ea"},{"code":"(fn [f s]\n  (apply merge-with concat (map #(hash-map (f %) [%]) s))\n)","problem":63,"user":"507eddf4e4b06ce648bcdbfa"},{"code":"(fn [f xs]\n  (let [v (partition-by f (sort xs))\n        k (map #(-> % first f) v)]\n    (zipmap k v)))","problem":63,"user":"513fab65e4b00f13ea1bd891"},{"problem":63,"code":"(fn my-group-by [func l]\n (->>\n l\n  (map #(vector (func %) %))\n  (reduce (fn [grouped [key value]]\n            (update-in grouped [key] #(if (contains? grouped key)\n\t\t\t                             (concat % [value])\n\t\t\t\t\t\t\t\t\t\t [value]\n\t\t\t\t\t\t\t\t\t   ))) {} )\n\t\t  \n  \n  )\n )","user":"57011eb3e4b08d47c97781d1"},{"code":"(fn [f s]\n   (loop [acc {} xs s] \n     (if (seq xs)\n           (let [h (first xs) rs (rest xs) fh (f h)]\n             (recur (assoc acc fh (conj (acc fh []) h)) rs))\n           acc)))","problem":63,"user":"4eb0a757535d7eef3080733d"},{"problem":63,"code":"(fn [f x]\n    (reduce\n      #(conj\n        %1\n        (let [k (f %2) v (get %1 k)]\n          (if (nil? v)\n            (vector k (vector %2))\n            (vector k (conj v %2)))))\n      {} x))","user":"58d2af83e4b03c36ff7e5907"},{"code":"(fn[f sq] \n    (loop[s sq r {}] \n      (if(empty? s) \n        r \n        (let[e (first s) b (f e)] \n          (recur (rest s) (assoc r b (conj (get r b []) e)))\n          )\n        )\n      )\n    )","problem":63,"user":"52e68e61e4b09f7907dd1479"},{"problem":63,"code":"(fn [f s]\n  (reduce\n    (fn [acc x] (let [y (f x)]\n      (conj\n        acc\n        {y (conj (or (get acc y) []) x)})))\n    {}\n    s))","user":"5901158de4b0438e51c2d039"},{"problem":63,"code":"(fn   ([f s] (reduce\n           #(let [k (f %2) v %2 c (or (%1 k) [])]\n             (assoc %1 k (conj c v))) {} s)))","user":"54d8cc38e4b0a52adc2e203e"},{"code":"(fn [f coll]\n\t(apply\n\t\tmerge-with\n\t\tconcat\n\t\t(map\n\t\t\t#(assoc {} (f %) [%])\n\t\t\tcoll)))","problem":63,"user":"514d7e29e4b019235f6c0587"},{"code":"(fn [p ns]\n  (reduce\n    (fn [m [k v]]\n      (assoc m k v))\n  {}\n  (for [k (set (map p ns))]\n    (cons k [(filter #(= k (p %)) ns)]))))","problem":63,"user":"4ee82223535d93acb0a66877"},{"problem":63,"code":"(fn group-by-answer\n  [f some-seq]\n  (loop [ans-map {}\n         my-seq some-seq]\n    (let [elem (first my-seq)\n          my-key (f elem)\n          new-ans-map (update-in ans-map [my-key] (fnil #(conj % elem) []))]\n      (if-let [next-coll (seq (rest my-seq))]\n        (recur new-ans-map next-coll)\n        new-ans-map))))","user":"53716539e4b0fc7073fd6eb1"},{"code":"(fn [f s]\n  (loop [s s\n         res {}]\n    (if (empty? s)\n      res\n      (let [fs (f (first s))]\n        (if (contains? res fs)\n          (recur (rest s) (assoc res fs (conj (res fs) (first s))))\n          (recur (rest s) (assoc res fs [(first s)])))))))","problem":63,"user":"51000111e4b00d7ad4cab15e"},{"code":"(fn [f col] \n  (apply merge-with concat \n         (map (fn [x] {(f x) [x]}) col)))","problem":63,"user":"5008d149e4b0144d4f561e41"},{"code":"(fn [f s]\r\n  (apply merge-with concat (map #(hash-map (f %) [%]) s)))","problem":63,"user":"50acbd15e4b071b89ef26234"},{"problem":63,"code":"(fn [f seq] (reduce (fn [val item] (let [result (f item)]\n                                      (assoc val result (conj (get-in val [result] []) item)))) {} seq))","user":"5a4d656fe4b05d388ecb6ba9"},{"problem":63,"code":"(fn group \n  ([f coll] (group f coll {}))\n  ([f coll ret]\n    (if (empty? coll)\n      ret\n      (let [val (first coll)\n            result (f val)\n            listResult (ret result)]\n        (if listResult\n          (group f (rest coll) (assoc ret result (conj listResult val)))\n          (group f (rest coll) (assoc ret result [val])))))))","user":"4f4aa932e4b0d56e7bb92c14"},{"problem":63,"code":"(fn [fnc coll]\n  (reduce (fn [s, e] (update-in s [(fnc e)] #(reverse (conj (reverse %) e)))) {} coll))","user":"5f8e865fe4b0715f5002d76d"},{"code":"(fn [func xs]\n  (letfn [(characterize [buckets x]\n            (let [k (func x)]\n              (if-let [vs (get buckets k)]\n                (update-in buckets [k] conj x)\n                (assoc buckets k [x]))))]\n    (reduce characterize {} xs)))","problem":63,"user":"4efa3d4b535dced4c769f270"},{"code":"#(reduce (fn [r x] (assoc r (% x) (conj (r (% x) []) x))) {} %2)","problem":63,"user":"5088082ae4b0198722bd9854"},{"problem":63,"code":"(fn my-group-by [f xs]\n  (let [fxs (map f xs)\n        fxs-unique (seq (set fxs))]\n    (loop [g {} fx-unique fxs-unique]\n      (if (nil? (first fx-unique))\n        g\n        (recur (into g {(first fx-unique)\n                        (vec (filter #(= (first fx-unique) (f %))\n                                     xs))})\n               (rest fx-unique))))))","user":"54d753ebe4b0a52adc2e2029"},{"problem":63,"code":"(fn [f s]\n  (apply merge-with into (for [v s] {(f v) [v]})))","user":"58a1f61ae4b02bd94d917ecd"},{"problem":63,"code":"#(let [x (partition-by %1 (sort-by %1 %2))]\n  (zipmap (map (comp %1 first) x) x))","user":"56aed78fe4b03c432f187363"},{"problem":63,"code":"(fn my-group-by\n  [f col]\n  (reduce (fn [acc elem]\n            (let [key (f elem)\n                  new-value-col (concat (get acc key) [elem])]\n            (assoc acc key new-value-col)))\n            {}\n            col))","user":"5acd235ae4b0e27600da7824"},{"code":"(fn [f coll]\n  (reduce\n    (fn [ret x]\n      (let [y (f x)]\n        (assoc ret y \n               (conj (get ret y []) x))))\n    {}\n    coll))","problem":63,"user":"51592b81e4b0394f658fe22c"},{"code":"(fn [f col]\n  (reduce #(assoc %1 (f %2) (conj (apply vector (%1 (f %2))) %2)) {} col))","problem":63,"user":"51696bcde4b03f62cda68ce7"},{"problem":63,"code":"(fn [f coll]\n  (loop [[x & rest] coll acc {}]\n    (if (nil? x)\n      acc\n      (let [y (f x)]\n        (recur rest\n               (if (contains? acc y)\n                 (update-in acc [y] conj x)\n                 (assoc acc y [x])))))))","user":"53968a70e4b0b51d73faaee0"},{"problem":63,"code":"(fn group-seq [f se]\n  (into {} ;; directly into a map\n        (map (fn [part] (vector (f (first part)) part)) ;; build key value pairs for complete partitions\n             (partition-by f (sort se))))) ;; group by f","user":"5fbf6fe7e4b0ad6fc3476147"},{"problem":63,"code":"(fn [func coll]\n   (reduce (fn [v e]\n             (let [eval-key (func e)]\n               (into v {eval-key\n                        (if (contains? v eval-key)\n                          (vec (conj (get v eval-key) e))\n                          (vec (list e)))})))\n           {} coll))","user":"5a4b3abde4b05d388ecb6b81"},{"code":"(fn [f s]\n  (let [values (set(map f s))]\n    (zipmap \n      values\n      (map \n        (fn [value] (filter #(= value (f %)) s)) \n        values))))","problem":63,"user":"4e8a0d5d535d3e98b802328e"},{"code":"(fn group-by-63 [f1 c2]\n  (reduce (fn [answer x]\n         (let [result (f1 x)]\n           (assoc answer result (conj (get answer result []) x))))\n       {} c2))","problem":63,"user":"501b1a8ee4b0b12d9c5f4d81"},{"problem":63,"code":"(fn group [f l]\n  (->> l\n       (map #(vec [(f %) %]))\n       (reduce #(assoc % (first %2) (conj (vec (% (first %2))) (last %2))) {})))","user":"547e3846e4b0c51c1f4d7302"},{"code":"#(reduce\n  (fn [acc i] (assoc acc (%1 i) (conj (acc (%1 i) []) i)))\n  {} %2)","problem":63,"user":"50a2f901e4b029e8bace362a"},{"code":"#(apply merge-with (comp vec concat) (for [x %2] (hash-map (%1 x) (list x))))","problem":63,"user":"4ebe766d535dfed6da9c6d94"},{"problem":63,"code":"(fn [op x]\n  (let [y (map op x)]\n   (reduce #(update-in % [(first %2)] concat [(second %2)]) {} (partition 2 (interleave y x)))))","user":"56d1afd9e4b0ea9b8538f791"},{"problem":63,"code":"(fn [f coll]\n   (reduce (fn [hm item]\n             (let [key (f item)]\n               (if-let [val (get hm key)]\n                 (assoc hm key (conj val item))\n                 (assoc hm key [item])))) {} coll))","user":"52fc34cee4b047fd55837015"},{"problem":63,"code":"(fn [f xs]\n  (let [ks (distinct (map f xs))]\n    (apply hash-map (mapcat\n     (fn [k] \n       [k (apply vector (filter #(= k (f %)) xs))])\n     ks))))","user":"56fee4c0e4b08d47c97781b5"},{"code":"(fn my-group-seq [f xs]\n  (let [grps (map #(hash-map (f %) [%]) xs)]\n    (apply (partial merge-with into) grps)))","problem":63,"user":"50cf94bde4b0abc485cb9bb2"},{"problem":63,"code":"(fn [func elements]\n  (reduce (fn [dict ele]\n            (let [key_val (func ele)]\n            \t(assoc dict key_val (conj (dict key_val []) ele))))\n          {}\n          elements))","user":"5d64013ce4b0c9e5857d502d"},{"code":"(fn [f s] \n  (reduce #(let [r (f %2)]\n    (assoc % r (conj (or (% r) []) %2))) {} s))","problem":63,"user":"4f1052b9535d64f603146418"},{"code":"(fn my-group-by\n    [f ss]\n    (loop [m {}\n           to-group (seq ss)]\n      (if (empty? to-group)\n        m\n        (let [f-s (f (first to-group))\n              v (get m f-s)]\n          (recur (assoc m f-s (conj (if v v []) (first to-group)))\n                 (rest to-group))))))","problem":63,"user":"525d490ae4b0cb4875a45d70"},{"problem":63,"code":"(fn [f coll ]\n    (reduce \n        (fn [ret x]\n            (let [k (f x)]\n                (assoc ret k (conj (get ret k []) x))))\n        {}\n        coll))","user":"5eff6c0ee4b0cf489e8d7f11"},{"code":"(fn [f s] \n  (reduce \n    (fn [acc i] \n      (let [v (f i)\n            c (or (acc v) [])]\n        (assoc acc v (conj c i))))\n    {} \n    s))","problem":63,"user":"4e9660ec535dbda64a6f6b44"},{"code":"#(reduce (fn [m v] (let [k (% v)] (assoc m k (conj (get m k []) v)))) {} %2)","problem":63,"user":"508f97c0e4b0ea685a20f768"},{"code":"(fn [func lst]\n    ((fn [rest-lst rslt-map]\n       (if (empty? rest-lst)\n         rslt-map\n         (let [func-rslt (func (first rest-lst))]\n          (recur (rest rest-lst)\n                 (assoc rslt-map\n                   func-rslt\n                   (conj (get rslt-map func-rslt [])\n                         (first rest-lst))\n                   )\n                 )\n          )\n         )\n       )\n     lst {}\n     )\n    )","problem":63,"user":"52213426e4b0e6a83c8925c4"},{"code":"(fn sixty-three\n  [f coll]\n  (apply merge-with concat (for [elem coll]\n     {(f elem) [elem]})))","problem":63,"user":"510591dde4b06d28cacc92eb"},{"code":";; This implementation is highly influenced by the \n;; clojure library implementation. \n(fn grp-by [f coll]\n  (let [val-key-pairs (partition 2 (interleave (map f coll) coll))]\n     (reduce \n      (fn [intermed-map [result item]]\n        (assoc intermed-map result (conj (get intermed-map result []) item)))\n      {} val-key-pairs)))","problem":63,"user":"521b339fe4b0c4ef0be83031"},{"code":"(fn [f x] (reduce (fn [y z] \n                    (if (contains? y (f z))\n                      (assoc y (f z) (conj (get y (f z)) z))\n                      (assoc y (f z) [ z])\n                      )\n                    )\n                  {} x)\n  )","problem":63,"user":"51beb32ae4b013aa0d74b7fd"},{"code":"(fn [f k] (reduce #(let [nk (f %2)] (assoc % nk (conj (if (% nk) (% nk) []) %2))) {} k))","problem":63,"user":"50ebd63ce4b04edc3377703c"},{"code":"(fn [f s]\n          (reduce #(merge-with into % {(f %2) [%2]}) {} s))","problem":63,"user":"52c7f036e4b0c2d177d62126"},{"problem":63,"code":"#(reduce \n  (fn [xs x]\n    (let [k (%1 x)]\n      (assoc xs k\n        (conj (xs k []) x)))) \n  {} %2)","user":"566e87cfe4b0a866af6896dc"},{"problem":63,"code":"(fn [f list]\n   (reduce (fn [agg it]\n             (assoc agg\n               (f it)\n               (conj (vec (get agg (f it))) it)))  {} list))","user":"590b3aeae4b047aa04b199d0"},{"problem":63,"code":"(fn [f coll] (reduce #(assoc %1 (f %2) (conj (get %1 (f %2) [] ) %2)) {} coll))","user":"564a560ae4b0284900eef654"},{"code":"(fn [f s] (let [res (set (map f s))]\n            (apply assoc {} (interleave res (for [x res]\n                                     (vec (filter #(= x (f %)) s)))))))","problem":63,"user":"524469dee4b0d8acf9ed6a9d"},{"problem":63,"code":"(fn [f xs]\n  (let [pairs (map #(list (f %) %) xs)]\n    (letfn [(reducer [result x]\n                            (assoc result (first x) (conj (or (result (first x)) []) (second x))))]\n    (reduce reducer {} pairs))))","user":"563cdfdfe4b0bfe05bf11840"},{"problem":63,"code":"(fn [f s]\n  (let [pairs (map (fn [x] [x (f x)]) s)\n        results (map last pairs)]\n    (into {} (map (fn [result] [result (map first\n                                            (filter #(= (last %) result)\n                                                    pairs))])\n                  results))))","user":"53acaf1fe4b047364c04445f"},{"problem":63,"code":"(fn [f coll]\n    (apply merge-with concat (map #(assoc {} (f %) [%]) coll)))","user":"57213df6e4b0c5bde472c0ab"},{"problem":63,"code":"(fn [f coll]\n  (let [v (partition-by first (sort-by first (map #(vector (f %) %) coll)))]\n    (zipmap\n     (map first (for [k v] (map first k)))\n     (for [k v] (map second k)))))","user":"5712854ce4b07c98581c3a89"},{"problem":63,"code":"(fn [f vs]                  \n  (let [ks (map #(f %) vs)  \n        m (zipmap ks (repeat (count vs) []))]\n    (loop [m m              \n           vs (interleave ks vs)]\n      (if (empty? vs)       \n        m        \n        (let [k (first vs)\n              v (second vs)]\n          (recur (assoc m k (conj (m k) v))\n                 (drop 2 vs)))))))","user":"541b41d1e4b01498b1a71a65"},{"problem":63,"code":"(fn gb \n  [f l]\n  (apply merge-with concat (for [ i l]\n                             { (f i) [i] } )\n         ))","user":"55a21f1ce4b0acc240e3151f"},{"code":"(fn groupby [f s]\n    (reduce \n      #(assoc %1 (f %2) (conj (get %1 (f %2) []) %2)) \n      {} s))","problem":63,"user":"52319066e4b0e2e8de81d1e9"},{"problem":63,"code":"(fn grp-by [f coll]  \n  (persistent!\n   (reduce\n    (fn [ret x]\n      (let [k (f x)]\n        (assoc! ret k (conj (get ret k []) x))))\n    (transient {}) coll)))","user":"4fecebe1e4b0681fd128dcac"},{"problem":63,"code":"(fn grp-by [func coll]\n  (reduce \n   (fn [v c] \n     (assoc v (func c) (conj (or (get v (func c)) []) c)))\n   {} coll))","user":"542c2de0e4b0dad94371f29f"},{"code":"(fn [f s] (reduce\n           (fn [a b] (let [c (f b)\n                           k (get a c)]\n                       (assoc\n                         (if (nil? k) a (dissoc a c))\n                         c\n                         (if (nil? k) [b] (conj k b)))))\n             {} s))","problem":63,"user":"51307b84e4b08c712d3fae39"},{"problem":63,"code":"(fn my_group [f x] (let [my_keys (set (map f x))] \n                (apply assoc {} (interleave my_keys (map (fn [k] (vec (filter #(= k (f %)) x))) my_keys)))))","user":"5a533cc0e4b05d388ecb6c09"},{"problem":63,"code":"(fn grpby\n  [f xs]\n  (reduce #(update-in %1 [(f %2)] (fnil conj []) %2) {} xs))","user":"5d609ddde4b0c9e5857d5008"},{"problem":63,"code":"(fn [f xs] \n  (reduce\n    (fn [m x]\n      (let [fx (f x)]\n        (assoc m fx (conj (get m fx []) x))))\n    {} xs))","user":"4fc4eb1ee4b081705acca354"},{"problem":63,"code":"#(reduce (fn [groups elem] (let [group (%1 elem)]\n                             (if (contains? groups group)\n                                 (update-in groups [group] (fn [v] (conj v elem)))\n                                 (into groups {group [elem]}))))\n         {}\n         %2)","user":"5f0b8243e4b0f30dddfb5d45"},{"code":"(fn gb [f l] (loop\n              [f f,\n               l l,\n               m {}]\n            (cond\n             (empty? l) m\n             (nil? (m (f (first l)))) (recur f (rest l) (conj m [(f (first l)) [(first l)]]))\n             :else (recur\n                    f\n                    (rest l)\n                    (conj\n                     m\n                     [(f (first l)) (conj (m (f (first l))) (first l))])\n                    )\n             )\n            )\n  )","problem":63,"user":"51bf4560e4b013aa0d74b817"},{"code":"(fn [f s] (reduce #(update-in % [(first %2)] concat [(second %2)]) {} (map list (map f s) s)))","problem":63,"user":"4eecdd66535d93acb0a668b9"},{"code":"(fn [f c] \n  (apply merge-with concat \n    (map #(hash-map (f %) [%]) c)))","problem":63,"user":"4f0f01c0535d0136e6c22329"},{"code":"(fn [f sqnc] (letfn [(update [map key val] (if (contains? map key)\n                                           (assoc map key (conj (map key) val))\n                                           (assoc map key [val])))]\n             (reduce #(update %1 (f %2) %2) {} sqnc)))","problem":63,"user":"4f2aff4de4b0d6649770a044"},{"code":"(fn my-group-by [f col]\n        (loop [f f col col res {}]\n          (if (seq col)\n            (let [val (f (first col))]\n              (recur f (rest col)\n                     (if (contains? res val)\n                       (assoc res val (conj (res val) (first col)))\n                       (assoc res val [(first col)]))))\n            res)))","problem":63,"user":"4e589bdc535d8a8b8723a295"},{"code":"(fn my-gb [f s]\r\n  (loop [sp s results {}]\r\n\t\t(if (empty? sp)\r\n\t\t\tresults\r\n\t\t\t(recur (next sp)\r\n\t\t\t\t(let [k (f (first sp))]\r\n\t\t\t\t\t(if (contains? results k)\r\n\t\t\t\t\t\t(assoc results k (vec (conj (results k) (first sp))))\r\n\t\t\t\t\t\t(assoc results k (vector (first sp)))))))))","problem":63,"user":"4efb92ce535dced4c769f27a"},{"problem":63,"code":"(fn [f s]\n   (apply merge-with concat (map #(hash-map (f %) [%]) s)))","user":"52cb6bb0e4b07d0d72b2734c"},{"code":"(fn [f s]\n   (->> (map #(hash-map (f %) [%]) s) (apply merge-with concat)))","problem":63,"user":"51105c7fe4b04c71fce993ef"},{"code":"(fn group ([f s] (group f s {}))\n  \t\t  ([f xs acc] \n            (if-let [s (seq xs)]\n              (group f (rest s) (merge-with concat acc {(f (first s)) [(first s)]}))\n              acc\n            )\n          )\n)","problem":63,"user":"52bf8e35e4b07a9af579233a"},{"problem":63,"code":"(fn [f coll]\n  (reduce\n   #(let [k (f %2)\n          val (get %1 k [])]\n      (assoc %1 k (conj val %2)))\n   {}\n   coll))","user":"5ba15075e4b0a20761a2339e"},{"code":"#(reduce\n  (fn [m kv] (assoc m (first kv) (vec (reverse (second kv)))))\n  {}\n  (reduce \n       (fn [a n]\n         (let [k (% n)]\n           (assoc a k (cons n (a k)))))\n       {}\n       %2\n       ))","problem":63,"user":"50e5bca5e4b09ae9427b0e75"},{"problem":63,"code":"(fn [f a]\n  (reduce #(update-in %1 [(f %2)] concat [%2]) {} a))","user":"602d5eade4b0d5df2af22279"},{"code":"(fn [f s] (let [fs (map f s), s (seq s)] (loop [[hk & tk] fs, [hv & tv] s, r {}] \n            (if hv (recur tk tv (assoc r hk (if-let [k (r hk)] (conj k hv) [hv]))) r))))","problem":63,"user":"4eabb245535d7eef30807319"},{"problem":63,"code":"(fn [f xs]\n  (reduce\n    (fn [acc x]\n      (let [k (f x)]\n        (if (contains? acc k)\n          (update-in acc [k] conj x)\n          (assoc acc k [x]))))\n    {} xs))","user":"562cd94ee4b0a45d2ff83015"},{"problem":63,"code":"(fn [f s]\n  (reduce #(let [f-of-xi     (f %2)\n                 f-of-xi-len (count (get % f-of-xi))] \n             (if (contains? % f-of-xi) (assoc-in % [f-of-xi f-of-xi-len] %2) \n                                       (assoc % f-of-xi [%2]))) \n          {} \n          s))","user":"5af31955e4b0cc2b61a3bc7a"},{"problem":63,"code":"(fn groupBy [f coll]\n  (reduce #(let [k (f %2)] (assoc %1 k (conj (get %1 k []) %2))) {} coll))","user":"5ce56455e4b0a17bb84e2b71"},{"code":"(fn [f sq]\n  (reduce #(assoc %1 (f %2)\n    (conj (or (%1 (f %2)) []) %2)) {} sq))","problem":63,"user":"4dcc5aff535d5973398f9293"},{"code":"(fn [f s]\r\n  (reduce (fn [a b]\r\n            (let [k (f b)]\r\n              (assoc a k (if (a k) (conj (a k) b) [b])))) {} s))","problem":63,"user":"4e773be8535d324fb2983d6e"},{"code":"(fn [a b] (reduce (fn [m e](let [k (first e) v (last e)]\n                    (update-in m [k] #(if (nil? %) (conj [] v) (conj % v)))))\n                                {} (map #(vector (a %) %) b)))","problem":63,"user":"538e29d1e4b0b51d73faae80"},{"problem":63,"code":"(fn me [f s]\n  (letfn [\n      (add-val [e v] (if (nil? e) [v] (conj e v)))\n      (update-map [m [k v]] (update-in m [k] add-val v))      \n    ]\n    (->>\n      (map #(vector (f %) %) s)\n      (reduce update-map {})\n    )))","user":"5c219c0fe4b07e362c230581"},{"problem":63,"code":"(fn gs [f v]\n  (let [k (set (map f v))\n        l (map \n           (fn[i]\n             (assoc {} i \n               (vec\n                (filter \n                 (fn[j]\n                  (= (apply f (vector j)) i)) v)))) k)]\n    (reduce merge (vec l)) ))","user":"54d4bd2be4b0a52adc2e2005"},{"problem":63,"code":"(fn group-by-\n  [f v]\n  (reduce\n    (fn\n      [m i]\n      (let [n (f i)]\n        (assoc m n (conj (get m n []) i))))\n    {}\n    v))","user":"56084e91e4b046a4fc0ac00f"},{"problem":63,"code":"(fn [f lst] (reduce #(assoc %1 (f %2) (conj (get %1 (f %2) []) %2)) {} lst))","user":"56912f93e4b0dcc4269f40ef"},{"problem":63,"code":"(fn [f coll]\n  (let [vals (map vec (partition-by f (sort-by f coll)))\n        keys (map #(f (first %)) vals)]\n    (apply hash-map (interleave keys vals))))","user":"577c3da9e4b0c8d87281f6b9"},{"problem":63,"code":"(fn my-group-by [f xs]\n  (let [fxs (map f xs)\n        my-update (fn [xs k v]\n                    (do\n                      (println xs k v)\n                      (if (get xs k)\n                        (assoc xs k (conj (get xs k) v))\n                        (assoc xs k [v]))))]\n    (-> (reduce\n          (fn [[res k v] _] [\n                             (my-update res (first k) (first v))\n                             (rest k)\n                             (rest v)])\n          [{} fxs xs]\n          xs)\n        first)))","user":"5984e7dee4b021a7a535fe43"},{"problem":63,"code":"(fn my-group-by [f coll]\n  (reduce\n    (fn [m v]\n      (let [k (f v)]\n        (assoc m k (conj (get m k []) v)))) {} coll))","user":"55d28b38e4b0e31453f64a58"},{"code":"(fn [f xs]\r\n  (reduce #(update-in %1 [(f %2)] conj %2)\r\n    (into {} (map #(vector (f %) []) xs))\r\n    xs))","problem":63,"user":"4ddbfb8a535d02782fcbea00"},{"problem":63,"code":"(fn [f coll]\n  (->> (map (fn [x] {(f x) [x]}) coll)\n       (apply merge-with concat)))","user":"5ad63a34e4b0ea6055cfac01"},{"problem":63,"code":"(fn [f lst]\n\t(reduce\n     \t(fn [ret x]\n          \t(let [k (f x)]\n              \t(assoc ret k (conj (get ret k []) x))))\n     {} lst))","user":"536102efe4b0243289761e3e"},{"problem":63,"code":"(fn [f s]\n  (let [val (map f s)\n        pairs (map vector val s)]\n    (loop [d {}\n           p pairs]\n      (if (seq p)\n        (let [[k v] (first p)]\n          (recur\n           (assoc d\n                  k\n                  (conj (get d k []) v))\n           (rest p)))\n        d))))","user":"58d48df8e4b03c36ff7e5941"},{"code":"(fn [f s] \n  (reduce \n    (fn [curr x] \n      (let [v (f x)]\n        (assoc curr v (conj (curr v []) x)))) {} s))","problem":63,"user":"51d4ed02e4b013d740b70dec"},{"code":"#(reduce (fn [ret x]\n          (let [k (% x)]\n            (assoc ret k (conj (get ret k []) x))))\n        {} %2)","problem":63,"user":"50481532e4b0ec70b3ef8d96"},{"code":"(fn [f coll]\n  (reduce #(merge-with concat %1 {(f %2) [%2]}) {} coll))","problem":63,"user":"52976262e4b02ebb4ef75041"},{"code":"(fn g [f l]\n  (if (empty? l)\n    {}\n    (let [x (first l)\n          k (f x)\n          m (g f (rest l))]\n      (assoc m k (conj (m k) x)))))","problem":63,"user":"521b73f5e4b0c4ef0be83043"},{"problem":63,"code":"(fn [f xs] (reduce #(assoc %1 (f %2) (conj (apply vector (%1 (f %2))) %2)) {} xs))","user":"5830377ee4b051871117c004"},{"code":"#(reduce (fn [c x] (update-in c [(% x)] (fnil conj []) x))\n         {}\n         %2)","problem":63,"user":"5357b241e4b04ce2eb3ed282"},{"code":"(fn [f s] (reduce #(let [k (f %2)] (assoc % k (conj (% k []) %2))) {} s))","problem":63,"user":"51b90b88e4b050a1176cd6a2"},{"problem":63,"code":"(fn [f s]\n  (reduce \n   (fn [a b] \n     (assoc-in a [(first b)] \n               (conj \n                (get-in a [(first b)] []) (last b)))) \n   {} \n   (reduce \n    (fn [a b] \n      (conj a [(f b) b]))\n    [] s)))","user":"4fc77f5ae4b0ee37620e1821"},{"problem":63,"code":"(fn [f coll]\n  (reduce (fn [acc item]\n            (let [k (f item)]\n              (if (contains? acc k)\n                (assoc acc k (conj (get acc k) item))\n                (assoc acc k [item]))))\n          {}\n          coll))","user":"59225498e4b09b4ee5954c8c"},{"problem":63,"code":"(fn [x y] \n  (apply merge\n  (map \n   (fn [a] (hash-map (x (first a)) a))\n   (partition-by x (sort-by x y))\n  ))\n)","user":"59d75e36e4b0ef0a1e9b5c32"},{"problem":63,"code":"(fn my-group-by\n  [f s]\n   (apply (partial merge-with #(vec (concat %1 %2))) (map #(hash-map (f %) [%]) s)))","user":"53b952eee4b047364c0444e6"},{"code":"#(reduce (fn [ret x] (assoc ret (%1 x) (conj (get ret (%1 x) []) x))) {} %2)","problem":63,"user":"4e79ff2a535db169f9c796a9"},{"code":"(fn g-by [f coll]\n  (let [dfc (distinct (map f coll))\n        ]\n    (zipmap \n      dfc \n      (map \n        #(filter (fn [x](= (f x) %)) \n                   coll) \n        dfc))\n    )\n  )","problem":63,"user":"4ecfa05c535d44c135fd68b9"},{"code":"(fn[f, params](reduce #(merge-with into % {(f %2) [%2]}) {} params))","problem":63,"user":"5036eba7e4b0af0658af77a5"},{"problem":63,"code":"(fn [f xs]\n      (reduce #(let [k (f %2)]\n                 (assoc %1 k (conj (get %1 k []) %2))) {} xs))","user":"5c3f37fce4b08cd430848e91"},{"code":"(fn [f s] (apply merge-with #(concat % %2) (interleave (map #(hash-map (f %) [%]) s) (map #(hash-map (f %) []) s))))","problem":63,"user":"4ff76effe4b0678c553fc390"},{"problem":63,"code":"(fn [f xs] (reduce (fn [m x] (assoc m (f x) (conj (get m (f x) []) x))) {} xs))","user":"5ddb8a6ee4b0948ae9d9adb2"},{"problem":63,"code":"(fn [f ls] \n  (reduce (fn [acc x] \n            (let [result (f x) elems (acc result)]\n              (cond\n               (nil? elems) (assoc acc result [x])\n               :else (assoc acc result (conj elems x))\n              )\n            )) \n          {} \n          ls))","user":"546d41bde4b00cfc9eacc18c"},{"code":"#(reduce (fn [a b] (merge-with concat a {(% b) [b]})) {} %2)","problem":63,"user":"52c6a0abe4b0c2d177d62111"},{"code":"(fn [f s] (apply merge-with concat (for [x s]\n                                      {(f x) [x]})))","problem":63,"user":"51352899e4b082aeb3a3f03b"},{"code":"(fn my-group-by [pred coll]\n  (reduce\n    (fn [dict m]\n      (let [ret (pred m)]\n        (assoc dict ret (conj (or (dict ret) []) m))))\n    {} coll))","problem":63,"user":"4f072644535dcb61093f6c20"},{"code":"(fn grby\n  ([f coll] (grby f coll {}))\n  ([f [fi & re :as coll] m]\n     (if (empty? coll)\n       m\n       (grby f re (assoc m (f fi) (conj (vec (m (f fi))) fi))))))","problem":63,"user":"50c2fbebe4b00e537d00253c"},{"code":"(fn [f s]\n  (loop [r {} s1 s]\n    (if (empty? s1)\n      r\n      (let [f1 (first s1) v (f f1)]\n         (recur (assoc r v (vec (conj (r v) f1))) (rest s1))))))","problem":63,"user":"506b18c8e4b0a2a5463de383"},{"problem":63,"code":"(fn [f s]\n  (reduce (fn [m x] (update-in m [(f x)] #(conj (vec %) x))) {} s))","user":"5d0bb4fae4b0cc9c91588237"},{"problem":63,"code":"(fn [f s]\n  (reduce #(let [k (f %2)] (assoc %1 k (conj (get %1 k []) %2))) {} s))","user":"52ce1abfe4b07d0d72b27389"},{"code":"(fn group-by-my [f vs]  \n  (reduce #(let [m (f %2)\n                 gr (%1 m)]\n             (assoc %1 m (conj (if gr gr []) %2))) {} vs))","problem":63,"user":"4e5f08c7535d8a8b8723a2da"},{"problem":63,"code":"(fn my-group-by [f coll]\n  (->> (partition-by f (sort coll))\n       (map #(vector (f (first %)) (vec %)))\n       (into {})))","user":"5e218bb7e4b05b4b01516123"},{"code":"(fn [f c] (apply hash-map ((fn [kv] (interleave (map (comp first first) kv) (map #(map second %) kv))) (partition-by first (sort-by first (map #(vector (f %) %) c))))))","problem":63,"user":"4f34eb87e4b0e243712b1eba"},{"problem":63,"code":"(fn [f coll]\n          (reduce (fn [result x]\n                    (let [v (f x)]\n                      (assoc result v (conj (get result v []) x))))\n                  {} coll))","user":"531c6e72e4b08068f379eda0"},{"code":"(fn [f s]\n  (loop [s s acc {}]\n    (if (empty? s) acc\n      (let [r (f (first s))]\n        (recur (rest s)\n               (assoc acc r (conj (get acc r []) (first s))))))))","problem":63,"user":"4daf8f84edd6309eace4d17a"},{"problem":63,"code":"(fn [f s]\n        (loop [m {} [x & xs] s]\n          (if (nil? x)\n            m\n            (let [k (f x)]\n              (recur (assoc m k (conj (m k []) x))\n                     xs)))))","user":"546c4377e4b00cfc9eacc177"},{"problem":63,"code":"(fn [f s]\n  (reduce\n    (fn [x y]\n      (let [result (f y)]\n      (if (get x result)\n        (assoc-in x [result] (conj (get x result) y))\n        (assoc x result [y]))))\n    {}\n    s))","user":"5d03944de4b0cc9c915881c5"},{"problem":63,"code":"(fn [f s]\n  (let [u (fn [m x]\n            (let [fx (f x)]\n              (assoc m fx (conj (get m fx []) x))))]\n    (reduce u {} s)))","user":"5d929ceae4b0915913b1d412"},{"code":"(fn [f s]\n  (reduce \n   (fn [a b] \n     (if (contains? a (first b)) \n       (assoc (dissoc a (first b)) (first b) (conj (a (first b)) (last b)))\n       (conj a [(first b) [(last b)]]))) \n   {}\n   (map #(conj [] (f %) %) s)\n   ))","problem":63,"user":"513b77f3e4b00f740c76c403"},{"problem":63,"code":"(fn\n  [f coll]\n  (reduce (fn [val item] (update-in val [(f item)] #(conj (vec %) item))) {} coll))","user":"57b9fb56e4b0fbc9809a27fa"},{"code":"(fn [f s]\n  (loop [s (seq s) m {}]\n    (if-let [[h & t] s]\n      (let [key (f h)]\n        (recur t (assoc m key (conj (get m key []) h))))\n      m)))","problem":63,"user":"50142490e4b07d18bdaaf70a"},{"problem":63,"code":"#(reduce (fn [res item]\n            (let [r (% item)]\n              (assoc res r (conj (get res r []) item)))) {} %2)","user":"5cc80598e4b0ccb061962840"},{"problem":63,"code":"(fn [f xs]\n  (reduce (fn [acc x]\n            (let [k (f x)]\n              (update-in acc [k] (fnil conj []) x)))\n          {}\n          xs))","user":"5d11618de4b02c15ef021985"},{"problem":63,"code":"(fn my-group-by \n  [f coll]\n  (reduce (fn [acc x]\n               (let [result (f x)\n                     existing (get acc result [])]\n                 (assoc acc result (conj existing x))\n                 )\n            )\n          {} \n          coll)\n  )","user":"59cc4d5ee4b0a024fb6ae5d0"},{"problem":63,"code":"(fn [f coll] (zipmap (map (fn [x] (f (first x))) (partition-by f (sort-by f coll)))\n                        (partition-by f (sort-by f coll))))","user":"5169b23fe4b03f62cda68cee"},{"problem":63,"code":"#(loop [input %2, result {}]\n   (if (empty? input)\n     result\n     (let [x (first input),\n           fx (%1 x),\n           tmp (or (result fx) [])]\n       (recur (rest input) \n              (assoc result fx (conj tmp  x))))))","user":"57015a1de4b08d47c97781d4"},{"problem":63,"code":"(fn [func coll]\n  (loop [s coll res {}]\n    (if (empty? s)\n      res\n      (let [current (first s)\n            val (func (first s))]\n        (recur (rest s)\n               (assoc res val (conj (res val []) current)))))))","user":"53322cece4b019098a6f8b73"},{"problem":63,"code":"(fn [f coll]\n  (loop [xs coll r {}]\n    (if (empty? xs)\n      r\n      (let [e (first xs) v (or (r (f e)) [])]\n        (recur (rest xs) (assoc r (f e) (conj v e)))))))","user":"5e12327ee4b099d064962fe5"},{"code":"(fn [f c]\n  (reduce #(merge-with concat %1 %2) (map #(hash-map (f %1) [%1]) c)))","problem":63,"user":"5027fc0ce4b01614d1633ff2"},{"problem":63,"code":"(fn [f s]\n  (apply merge-with concat (for [x (partition-by f s)] {(f (first x)) x}))\n  )","user":"58fc52cee4b0438e51c2cf95"},{"code":"(fn [f s]\n  (reduce\n   (fn [result item]\n     (let [key (f item)\n           existing-val (result key)\n           new-val (if (vector? existing-val)\n               (conj existing-val item)\n               (vec (list item)))]\n       (assoc result key new-val)))\n   (hash-map)\n   s))","problem":63,"user":"4f31519ae4b0d6649770a086"},{"code":"(fn [f s]\n  (reduce (fn [memo item]\n            (let [k (f item)\n                  v   (memo k [])]\n              (assoc memo k (merge v item)))\n            ) {} s))","problem":63,"user":"51195e77e4b055cfb310d499"},{"problem":63,"code":"(fn [func col] \n  (reduce (fn [m el]\n            (assoc m (func el)\n              (vec \n               (conj (get m (func el))\n                     el))))\n          {} col))","user":"54194782e4b01498b1a71a29"},{"code":"(fn [f s]\n(into {} (map (juxt first (comp vec reverse second ))\n                (reduce (fn [a e] (update-in a [(f e)] #(conj % e)))\n                        {}\n                        s))))","problem":63,"user":"4f280840e4b0d6649770a010"},{"problem":63,"code":"(fn g [f xs]\n  (let [h (fn [m x] (assoc m (f x) (conj (vec (m (f x))) x)))]\n    (reduce h {} xs)))","user":"57adbe7ee4b0b8559636fca0"},{"code":"(fn [f xs]\n  (reduce \n    (fn [res x]\n      (update-in res [(f x)] #(vec (conj % x))))\n    {} xs))","problem":63,"user":"4fe88f78e4b07c9f6fd12c45"},{"problem":63,"code":"(fn my-group-6 [f [f_s :as s]]\n  (if (empty? s)\n    {}\n    (let [m (my-group-6 f (rest s))\n          k (f f_s)\n          val f_s]\n\n      (assoc m k (concat [val] (get m k))))))","user":"5b044436e4b0cc2b61a3bd71"},{"code":"#(reduce\n  (fn [s a]\n    (merge-with into s {(% a) [a]}))\n  {}\n  %2)","problem":63,"user":"529b44afe4b02ebb4ef7509d"},{"problem":63,"code":"(fn my-group [fun xs]\n  (reduce\n    (fn [acc x]\n      (let [k      (fun x)\n            k-vals (into [] (acc k))]\n      (conj acc [k (conj k-vals x)])))\n    {}\n    xs))","user":"563772a9e4b0bfe05bf117d7"},{"problem":63,"code":"(fn [f coll]\n  (loop [[keyw value & tail :as remaining] (interleave (map f coll) coll)\n         acc (hash-map)]\n    (if (empty? remaining)\n      acc\n      (recur tail (update-in acc [keyw] #(conj (apply vector %) value))))))","user":"51a7bf26e4b0da5f497bde8c"},{"code":"(fn [f x] (reduce #(let [k (f %2)] (conj %1 [k (conj (vec (%1 k)) %2)])) {} x))","problem":63,"user":"4db5082e535d87e67b28fe03"},{"problem":63,"code":"(fn [f colls]\n   (reduce (fn [acc i]\n             (let [k (f i)]\n               (println f i)\n               (if-let [v (seq (acc k))]\n                 (update-in acc [k] conj i)\n                 (assoc acc k [i]))))\n           {}\n           colls))","user":"5657fed1e4b0f9d632dd84ae"},{"problem":63,"code":"(fn [f s]\n  (reduce \n   (fn [m x] (update-in m [(f x)] (fnil #(conj % x) [])))\n   {} s))","user":"552a793ee4b0ffed3738f955"},{"code":"(fn [f coll] \n      (loop [out {}  col coll cur (first col)]\n\t       (if (nil? cur) \n\t\t   out\n\t\t   (let [res (f cur)]\n\t\t\t(recur (assoc out res (conj (get out res [] ) cur)) (next col) (second col))))))","problem":63,"user":"4e739e13535dff18050a9c76"},{"code":"(fn [f s]\n  (reduce\n    (fn [out x]\n      (let [subf (f x)]\n        (assoc out subf (conj (get out subf []) x)))) {} s))","problem":63,"user":"4f4ba29ae4b03ad3f0c10c7a"},{"problem":63,"code":"(fn group' [k coll]\n   (reduce\n     #(assoc %1 (k %2) (conj (get %1 (k %2) []) %2))\n     {}\n     coll))","user":"5f300f28e4b033932238a682"},{"code":"(fn [f coll]\n  (reduce #(merge-with into % {(f %2) [%2]}) {} coll))","problem":63,"user":"5125745ae4b05d10e3e395f9"},{"problem":63,"code":"(fn [f s]\n  (reduce (fn [res itm]\n            (let [v (f itm)]\n              (if (contains? res v)\n                (assoc res v (conj (res v) itm))\n                (assoc res v [itm]))))\n          {}\n          s))","user":"539ddf25e4b0b51d73faaf3e"},{"code":"#(apply merge-with concat\n    (map (comp (partial apply hash-map) (juxt %1 list)) %2))","problem":63,"user":"4fce5474e4b0d4b2a7a9d451"},{"problem":63,"code":"(fn __ [func s]\r\n  (loop [[f & r] s\r\n         m {}]\r\n    (if (nil? f)\r\n      m\r\n      (let [k (func f)]\r\n        (recur r (assoc m k (conj (get m k []) f)))))))","user":"546e1142e4b00cfc9eacc199"},{"code":"#(let [a (vec (interleave (map %1 %2) %2))]\n    (loop [i 0 m {}]\n      (if (< i (count a))\n        (if (contains? m (a i))\n          (recur (+ i 2) (assoc m (a i) (conj (m (a i)) (a (+ 1 i)))))\n          (recur (+ i 2) (assoc m (a i) [(a (+ 1 i))]))\n          )\n        m)))","problem":63,"user":"50bce014e4b0594b91591c63"},{"code":"(fn [f c]\n  (reduce #(assoc % (f %2) (conj (vec (% (f %2))) %2)) {} c))","problem":63,"user":"4e6a48d5535d8ccf87e9febd"},{"code":"#(reduce (fn [acc elm]\r\n      (let [elm-val (% elm)\r\n\t\t  elm-coll (conj (get acc elm-val []) elm)]\r\n\t      (assoc acc elm-val elm-coll)))\r\n\t  {}\r\n\t  %2)","problem":63,"user":"4dd6d7ee535d2dad7130b5cb"},{"code":"(fn [f xs]\n  (letfn [(addtomap [xs x]\n    (assoc xs (f x) (conj (vec (xs (f x))) x)))]\n  (reduce addtomap {} xs)))","problem":63,"user":"4fca1cd6e4b0ee37620e184c"},{"problem":63,"code":"(fn [f coll]\n  (apply merge-with (fn [a b] (into [] (concat a b)))\n\t(map (fn [k v] {k [v]}) (map f coll) coll)\n  )\n)","user":"5564c113e4b0c656e3ff180d"},{"code":"(fn [f s] (reduce\n            (fn [a x] (let [k (f x)]\n                        (assoc a k (if (get a k) (conj (get a k) x) [x]))))\n            {} s))","problem":63,"user":"4f40f055e4b0e243712b1fc2"},{"code":"(fn [f c]\n  (reduce #(update-in % [(f %2)] concat [%2]) \n          {} \n          c))","problem":63,"user":"4ee7ef87535d93acb0a66872"},{"problem":63,"code":"(fn [f xs] (apply merge-with concat (map #(hash-map (f %) [%]) xs)))","user":"53fcd574e4b0de5c418485d9"},{"problem":63,"code":"(fn [f coll]\n  (let [answers       (set (map f coll))\n        grouper       (fn [answer] (filter #(= (f %) answer) coll))\n        vals-grouped  (map grouper answers)]\n   (zipmap answers vals-grouped)\n))","user":"59f15e20e4b0966464fe6a5a"},{"code":"#(reduce (fn [s v] (assoc s (% v) (conj (s (% v) []) v))) {} %2)","problem":63,"user":"4ed69ea4535d10e5ff6f52e3"},{"problem":63,"code":"(fn my-group \n  ([f s]\n      (my-group f s {}))\n  ([f s m]\n      (if (empty? s)\n          m\n          (recur f (drop-last s) (update-in m [(f (last s))] conj (last s))))))","user":"55acd080e4b03311e7b73298"},{"code":"(fn [f coll]\n  (letfn [(update-map [m k v]\n            (assoc m k (conj (if (contains? m k) (get m k) []) v)))]\n    (loop [[v & vs] coll\n           result {}]\n      (if (nil? v)\n        result\n        (recur vs (update-map result (f v) v))))))","problem":63,"user":"50ed3c6be4b01236b1d4983b"},{"code":"(fn [f coll]\n  (reduce\n    (fn [m e] (assoc m (f e) (conj (get m (f e) []) e)))\n    {}\n    coll))","problem":63,"user":"4e9519b4535dbda64a6f6b2d"},{"problem":63,"code":"(fn [f s] \n    (reduce\n      (fn [m x]\n        (let [fx (f x)]\n          (assoc m fx (conj (get m fx []) x))))\n      {}\n      s))","user":"5bd0ea60e4b0e9689409ee45"},{"code":"(fn [f c] \n  (let [nc (map f c)\n        r (into {} (for [x (set nc)] {x []}))   \n   ]\n   (reduce #(let [k (f %2) v (conj (% k) %2)] (assoc % k v)) r c)\n  )\n)","problem":63,"user":"50921f9ae4b09a7d0b586de1"},{"problem":63,"code":"(fn [key vs] (reduce (fn [m v] (assoc m (key v) (conj (get m (key v) []) v))) {} vs))","user":"54c641f8e4b045293a27f628"},{"problem":63,"code":"(fn [function sequence]\n  (let [keys (map function sequence)\n        key-set (set keys)\n        key-value-list (map (fn [k v]\n                              (list k v))\n                            keys\n                            sequence)]\n    (apply hash-map\n           (apply concat\n                  (map (fn [key]\n                         (list key (map last\n                                        (filter (fn [key-value]\n                                                  (= key (first key-value)))\n                                                key-value-list))))\n                       key-set)))))","user":"58637f03e4b0f14aab7c881e"},{"code":"#(persistent! ((fn [f coll]\n   (reduce     \n    (fn [ret v]\n      (let [k (f v)]\n        (assoc! ret k (conj (get ret k []) v))    \n      )) (transient {}) coll)\n  ) %1 %2))","problem":63,"user":"517e12e3e4b0fcc7c5d37d3c"},{"code":"(fn my-grouper [f sq]\r\n     (let [reducer (fn [acc elem]\r\n                     (let [ret (f elem)\r\n                           contain (if (contains? acc ret)\r\n                                     (acc ret)\r\n                                     [])]\r\n                       (assoc acc ret (conj contain elem))))]\r\n       (reduce reducer {} sq)))","problem":63,"user":"4f82e14be4b033992c121c0c"},{"problem":63,"code":"(fn group-a-sequence [p xs]\n  (apply merge-with concat (map #(hash-map (p %) [%]) xs)))","user":"518b8561e4b0f028e99addef"},{"code":"(fn grp-by\n  [f c]\n  (reduce (fn [m v]\n    (let [fv (f v)\n    mfv (m fv)]\n      (assoc m fv (if mfv\n        (conj mfv v)\n        [v]))))\n          {} c))","problem":63,"user":"5070e31ee4b0e3170b5a8678"},{"problem":63,"code":"(fn [func coll]\n  (reduce #(update-in %1 [(func %2)] conj %2) {} (reverse coll)))","user":"5b77d3c8e4b047b03b2036f1"},{"problem":63,"code":"(fn\n  [f coll]\n  (reduce (fn [rst itm]\n            (let [k (f itm)]\n              (if (contains? rst k)\n                (assoc rst k (conj (get rst k) itm))\n                (assoc rst k (conj [] itm)))))\n          {}\n          coll))","user":"5bc7f2d6e4b07a9b28b100b7"},{"code":"(fn [f coll] \n  (reduce \n    #(assoc % (f %2) (conj (% (f %2) []) %2))\n    (hash-map )\n    coll))","problem":63,"user":"50217818e4b00bba4502f7a7"},{"problem":63,"code":"(fn gb [f s] (reduce #(assoc %1 (f %2) (conj (get %1 (f %2) []) %2)) {} s))","user":"5646dff3e4b0284900eef615"},{"problem":63,"code":"(fn group [f coll]\n  (reduce\n   (fn [accum x]\n     (let [k (f x)]\n       (assoc accum k (conj (get accum k []) x))))\n   {}\n   coll\n   )\n  )","user":"549dfe40e4b0f3d1d8e70f9a"},{"problem":63,"code":"#(zipmap (distinct (map %1 (sort %2))) (partition-by %1 (sort %2)))","user":"59b554cee4b05c620303ca0f"},{"problem":63,"code":"(fn group-a-seq [f xs]\n\t(reduce (fn [m e] (assoc m (f e) (conj (m (f e) []) e))) {} xs))","user":"52e657e4e4b09f7907dd1472"},{"code":"(fn[m lss] (loop [acc {} ls lss] \n             (if (empty? ls) \n                 acc\n                 (recur (update-in acc [(m (first ls))] concat [(first ls)]) (rest ls)))))","problem":63,"user":"5301157ae4b0d8b024fd3717"},{"code":"(fn [f s] (reduce (fn [a x] (let [fx (f x)] ( assoc a fx (conj (get a fx []) x)))) {} s))","problem":63,"user":"51424cc8e4b0b50abeb46b34"},{"problem":63,"code":"(fn [f s]\n     (->> s\n          (map #(list (f %) %))\n          (sort-by #(nth % 0))\n          (partition-by #(nth % 0))\n          (map #(list (first (first %)) (take-nth 2 (drop 1 (apply concat [] %)))))\n          (apply concat [])\n          (apply hash-map)\n          ))","user":"573107d5e4b0cd1946bd0fbc"},{"problem":63,"code":"(fn [f s]\n (reduce\n  (fn [vecmap [ek ev]]\n   (assoc\n    vecmap\n    ek\n    (conj (get vecmap ek []) ev)))\n  {}\n  (map #(vector (f %) %) s)))","user":"549a999be4b0f3d1d8e70f6f"},{"code":"(fn [f s]\n  (reduce (fn [a b]\n    (update-in a [(f b)] \n      (fn [x] (vec (conj x b)))))\n    {} s)\n)","problem":63,"user":"4f8b56dae4b02e764a0a517e"},{"code":"(fn gby [f s]\n  (reduce (fn [m, i]\n            (update-in m\n                       [(f i)]\n                       (fnil #(conj % i) [])))\n          {}\n          s))","problem":63,"user":"4dada426c9a9d6ed2a99dc57"},{"problem":63,"code":"(fn group-seq [f vals]\n  (into {}\n        (map #(vector (f (first %)) (vec %))\n             (partition-by f (sort vals)))))","user":"5f84f110e4b0375e81f54e79"},{"problem":63,"code":"(fn foo [f coll]\n  (reduce \n   #(assoc \n      %1 \n      (f %2) \n      (conj \n       (if (contains? %1 (f %2)) (get %1 (f %2)) []) \n       %2)) \n   {} \n   coll))","user":"5b3251c1e4b025bcb146f317"},{"problem":63,"code":"(fn [f c]\n (into {} (for [x (map f c)] [x (filter #(= x (f %)) c)]))\n  )","user":"55e1d34ae4b050e68259b421"},{"code":"#(reduce (fn [m el]\n            (assoc m (%1 el) (concat (m (%1 el)) [el]))) {} %2 )","problem":63,"user":"50d3b03fe4b030b634c368b9"},{"problem":63,"code":"(fn [f coll]\n\t(->> (partition-by f (sort coll))\n\t\t  (map #(vector (f (first %)) (vec %)))\n\t\t  (into {})))","user":"562d869be4b0a45d2ff8301f"},{"code":"(fn __ [f xs]\n  (reduce #(assoc % (f %2) (apply vector (conj (% (f %2)) %2))) {} xs)\n)","problem":63,"user":"503f872ee4b00d1a725ff2ac"},{"problem":63,"code":"(fn [f x] \n\t(reduce (fn [acc nxt] \n\t\t(assoc acc \n\t\t\t(f nxt) \n\t\t\t(conj (get acc (f nxt), []) nxt))) \n\t\t{} \n\t\tx))","user":"59fa5773e4b0ca45a743a35e"},{"code":"(fn grpby [f s]\n  (apply merge-with into (map #(hash-map (f %1) [%1]) s)))","problem":63,"user":"50d3ec8be4b030b634c368bb"},{"problem":63,"code":"(fn [f xs]\n  (reduce\n    #(assoc \n       %1 \n       (f %2) \n       (conj (get %1 (f %2) []) %2))\n    {}\n    xs))","user":"574dfcb8e4b02ea11479923a"},{"code":"(fn [f coll]\n  ( apply (partial merge-with concat) (for [x coll] { (f x) [x] })))","problem":63,"user":"53691dc7e4b0243289761e97"},{"code":"(fn [f s] \n    (loop [m {}, n 0, l (for [i s] (list (f i) i)), c (count l)]\n      (if (= c n)\n        m \n        (let [k (nth (nth l n) 0), v (nth (nth l n) 1)]\n          (recur (assoc m k (conj (get m k []) v)) (inc n) l c)))))","problem":63,"user":"4f038567535dcb61093f6b0c"},{"problem":63,"code":"(fn [f coll]\n  (reduce \n   (fn [ret x] (merge-with into ret {(f x) [x]})) \n   {} coll))","user":"5383668ee4b06839e8705edd"},{"problem":63,"code":"(fn grp [f s]\n  (reduce #(assoc %1 (f %2) (conj (%1 (f %2) []) %2)) {} s))","user":"5dd60c58e4b0948ae9d9ad7c"},{"problem":63,"code":"(fn\t[f args]\n   (loop [res-map {} rest-args args]\n    (if (seq rest-args)\n      (let [k (f (first rest-args))  map-value (res-map k [])] ; Key(k) is the application of the f to (first args) and value(v) is its value in map or default []\n        (recur \n           (assoc res-map k (conj map-value (first rest-args))) \n           (rest rest-args)\n        )\n      )\n    res-map\n    )\n   )\n )","user":"5722bf99e4b0c5bde472c0d6"},{"code":"(fn mygroup-by [f coll]\n  (reduce\n    (fn [m x]\n      (update-in m [(f x)] (fnil conj []) x))\n    {}\n    coll))","problem":63,"user":"4ee2da14535d10e5ff6f536c"},{"problem":63,"code":"(fn group-sequence [f coll]\n  (reduce (fn [m e] (let [result (f e)] (assoc m result (conj (vec (get m result)) e)))) {} coll))","user":"5eec1001e4b07c55ae4a0502"},{"code":"(fn [f coll] (let [vs (set (map f coll))] (apply hash-map (interleave vs (map (fn [v] (filter #(= v (f %)) coll)) vs)))))","problem":63,"user":"513a4babe4b067e25a345eca"},{"code":"(fn my-group-by [f col]\n  (loop [c col grouped {}]\n    (if (empty? c) grouped\n    (let [x (first c) vals (get grouped (f x))]\n      (cond\n       (nil? vals) (recur (rest c) (assoc grouped (f x) [x]))\n       :else (recur (rest c) (assoc grouped (f x) (conj vals x))))))))","problem":63,"user":"4fc6d2c1e4b0ee37620e181b"},{"problem":63,"code":"(fn [f xs]\n  (->> xs\n       (map (fn [x] {(f x) [x]}))\n       (reduce (fn [acc m] (merge-with into acc m)) {})\n       )\n  )","user":"5fa17538e4b0f0ebd91b77e3"},{"problem":63,"code":"(fn [f coll]\n    (->> coll\n         (map #(hash-map (f %) [%]))\n         (reduce (partial merge-with (comp vec concat)) {})))","user":"577829f9e4b0979f8965165a"},{"code":"(fn gb [f col]\n  (if col\n    (update-in (gb f (next col)) [(f (first col))] #(cons (first col) %))\n    {}))","problem":63,"user":"5336a339e4b0e30313ee6c7d"},{"problem":63,"code":"(fn [f a]\n  (loop [acc {}\n         rem-a a]\n    (if (first rem-a)\n      (let [first-a (first rem-a)\n            fa (f first-a)]\n        (recur (assoc acc \n                 fa (if (acc fa) (conj (acc fa) first-a) [first-a]))\n               (rest rem-a)))\n      acc)))","user":"54580586e4b01be26fd74616"},{"code":"(fn [f xs]\n  (apply merge-with concat\n         (for [i xs]\n           {(f i) [i]})))","problem":63,"user":"52667ecfe4b03e8d9a4a713e"},{"code":"(fn\n  [f s]\n  (let [k (distinct (map f s))]\n    (apply merge (for [ki k]\n                   { ki (->> (for [si s] (if (= (f si) ki) si))\n                            (filter identity)\n                            (vec)) }))))","problem":63,"user":"52f3af46e4b05e3f0be25f14"},{"problem":63,"code":"(fn [f xs]\n  (let [buncha-maps (map #(hash-map (f %) [%]) xs)]\n    (apply merge-with concat buncha-maps)))","user":"58ee84e5e4b056aecfd47dab"},{"problem":63,"code":"(fn gb [f coll]\n  (reduce (fn [a b] \n            (if (nil? (a (f b)))\n             (conj a {(f b) [b]})\n             (assoc a (f b) (conj (a (f b)) b))))\n          {}\n          coll))","user":"54bad977e4b0ed20f4ff6eb9"},{"code":"(fn [p xs]\n  (let [f \n        (fn [acc x]\n          (if (contains? acc (p x))\n            (update-in acc [(p x)] #(conj % x))\n            (conj acc [(p x) [x]])))]\n    \n    (reduce f {} xs)))","problem":63,"user":"4e7f5a0b535db966e863cc41"},{"code":"(fn [f xs]\n  (apply merge-with\n         into\n         (map #(identity {(f %) [%]}) xs)))","problem":63,"user":"4fca4c37e4b0ee37620e184f"},{"problem":63,"code":"(fn [f s]\n  (reduce\n   (fn [m x]\n     (let [k (f x)]\n       (assoc m k (conj (m k []) x))))\n   {} s))","user":"5ab16992e4b073f1774425c4"},{"code":"(fn   [f coll]  \n  (persistent!\n   (reduce\n    (fn [ret x]\n      (let [k (f x)]\n        (assoc! ret k (conj (get ret k []) x))))\n    (transient {}) coll)))","problem":63,"user":"4f6b4237e4b07046d9f4efa9"},{"code":"(fn [fun coll]\r\n  (persistent!\r\n    (reduce\r\n      (fn [ret x]\r\n        (let [crit (fun x)]\r\n(assoc! ret crit (conj (get ret crit []) x))))\r\n(transient {}) coll)))","problem":63,"user":"4f71ba6ee4b07046d9f4f012"},{"problem":63,"code":"(fn [ f l] \n  (apply merge-with #(vec (concat %1 %2)) (map #(assoc nil (f %) [%]) l)))","user":"57887de2e4b0ebec4cfb751c"},{"problem":63,"code":"#(reduce (fn [acc x] (let [k (%1 x)] (assoc acc k (conj (get acc k []) x)))) {} %2)","user":"5eb1c786e4b00a66d4a95201"},{"problem":63,"code":"(fn [f xs]\n    (reduce (fn [m x] (update-in m [(f x)] #(conj (vec %) x))) {} xs))","user":"53ef3adfe4b0742d9025b0c9"},{"code":"(fn [f s]\n  (into {}\n        (for [k (into #{} (map f s))]\n          [k (filter #(= (f %) k) s)])))","problem":63,"user":"51a4416ae4b0def3c5c5868c"},{"code":"(fn g [f s]\n  (reduce #(merge-with into % {(f %2) [%2]}) {} s))","problem":63,"user":"51ba8f82e4b0fe3ecfb46434"},{"code":"(fn [f s]\r\n(apply merge-with concat {} (map #(hash-map (f %) [%]) s)))","problem":63,"user":"509c03f3e4b085ae113522a8"},{"problem":63,"code":"(fn [op col] (reduce (fn [res val] \n                         (let [grp (op val)\n                               lst (get res grp [])]\n                           (assoc res grp (conj lst val) )))\n                       {} col))","user":"57aa290de4b0b8559636fc65"},{"problem":63,"code":"(fn groupSequence \n  [n coll]\n  (loop [x coll \n         map {}]\n    (if (empty? x)\n      map\n      (let [fx (n (first x))]\n        (recur (rest x) \n               (assoc map fx (conj (get map fx []) (first x))))))))","user":"5e95013fe4b0fbed045a3800"},{"problem":63,"code":"(fn [f coll]\n  (reduce #(assoc %1 (f %2) (conj (or (%1 (f %2)) []) %2)) {} coll))","user":"5a085dfde4b01bb0ae8afdf4"},{"problem":63,"code":"(fn my-mapper [f a-seq]\n  (let [\n         my-keys (set (for [i a-seq] (f i)))\n         ]\n    (into {}\n    (for [i my-keys] [i (for [j a-seq :when (= i (f j))] j)]\n      )\n    )\n  )\n  )","user":"55efc44ee4b066087aa9453e"},{"problem":63,"code":"(fn [f xs]                                                                                                         \n  (zipmap                                                                                                               \n    (set (map f xs))                                                                                                    \n    (map (fn [k] (filter (fn [x] (= k (f x))) xs)) (set (map f xs)))                                                    \n   )                                                                                                                    \n  )","user":"56d91a53e4b0ea9b8538f7ee"},{"code":"(fn my-group-by\n  [f s]\n  (reduce \n    #(let [k (f %2)] (assoc % k (conj (get % k []) %2 ))) \n    {} s))","problem":63,"user":"4edf5dc6535d10e5ff6f5340"},{"code":"(fn [f s]\n  (loop [s s\n         m {}]\n    (if (empty? s) m\n      (let [[h & r] s\n        \t k (f h)]\n        (recur r (assoc m k (if (contains? m k) (conj (m k) h) [h])))\n      )\n    )\n  )                    \n)","problem":63,"user":"5081566ce4b0946d0443855b"},{"code":"(fn [f s]\n  (loop [col s acc {}]\n    (if (seq col) \n      (let [elem (first col)\n            k (f elem)]\n      (recur (rest col) (assoc acc k (conj (get acc k []) elem))))\n      acc)))","problem":63,"user":"51990df9e4b068aa333628fc"},{"problem":63,"code":"(fn [f lst]\n  (reduce #(merge-with concat % \n                       (hash-map (f %2) [%2]))\n          {} lst))","user":"51c611c4e4b03a28d42333bf"},{"problem":63,"code":"(fn [f v] (into (sorted-map) (map #(vector (f (first %)) (vec %)) (partition-by f (sort v)))))","user":"543d5c61e4b032a45b86934d"},{"problem":63,"code":"(fn group-seq [f value]\n(reduce #(assoc %1 (f %2) (conj (apply vector (%1 (f %2))) %2)) {} value))","user":"5bbbce70e4b0a20761a2360f"},{"code":"(fn [f s]\n    (reduce (fn [agg [v f-v]]\n              (if-let [ev (agg f-v)]\n                (assoc agg f-v (conj ev v))\n                (assoc agg f-v [v])))\n            {}\n            (map (fn [v] [v (f v)]) s)))","problem":63,"user":"4ed292ac535d44c135fd68d9"},{"problem":63,"code":"(fn [f coll]\n  (reduce (fn inner [d e]\n            (let [[v l] [(f e) (get d (f e) [])]]\n              (assoc d v (concat l [e])))) \n          {} coll))","user":"5550bcece4b00713264bd9ae"},{"code":"(fn [f s]\n  (reduce\n    (fn [a e]\n      (let [k (f e)\n        v (a k [])]\n        (assoc a k (conj v e))))\n    {}\n    s))","problem":63,"user":"504e14c2e4b078edc5f593bf"},{"code":"(fn [f l]\n  (reduce\n    (fn [m [k v]] (assoc m k (conj (get m k []) v)))\n    {}\n    (map #(vec [(f %) %]) l)))","problem":63,"user":"4e7dfab0535db169f9c796f9"},{"code":"(fn mapper [f coll]\n  (loop [coll coll\n         return-map {}]\n    (if (seq coll)\n      (let [item (first coll)\n            value (f item)]\n        (recur (rest coll)\n               (merge-with concat return-map {value [item]})))\n      return-map)))","problem":63,"user":"4eda7cc3535d10e5ff6f530e"},{"code":"(fn [x y] (into {} (map (fn [z] (vector (x (first z)) z )) (partition-by x ( sort-by x y)))))","problem":63,"user":"5296008fe4b02ebb4ef7502a"},{"problem":63,"code":"(fn [f coll]\n  (loop [x coll\n         res {}]\n    (if (empty? x)\n      res\n      (let [k (f (first x))\n            v (first x)\n            prev-v (get res k)]\n        (recur\n         (next x)\n          (merge res { k (concat prev-v [v])}))))))","user":"58303fc3e4b051871117c006"},{"problem":63,"code":"(fn my-group-by [fun col]\n  (let [pairs (map #(vector (fun %) %) col)]\n    (reduce #(let [[k v] %2\n                   prevV (get %1 k [])]\n               (assoc %1 k (conj prevV v)))\n            {}\n            pairs)))","user":"5b333626e4b025bcb146f32f"},{"problem":63,"code":"(fn [f xs]\n  (reduce \n   (fn [a x] \n     (let [k (f x)]\n       (assoc a k (conj (a k []) x)))) \n       {} \n       xs))","user":"5af8221ce4b0cc2b61a3bccd"},{"code":"(fn [f X]\n    (loop [elts X\n           res {}\n           u (first X)]\n      (if (empty? elts) res\n          (recur (rest elts) \n                 (conj res (hash-map\n                              (f u)\n                             (keep #(if (= (f %) (f u)) % nil) X)))\n                 (second elts)))))","problem":63,"user":"4e49a7bb535dc968683fc4c6"},{"problem":63,"code":"(fn x [f c] \n  (reduce #(assoc %1 (f %2) (conj (get %1 (f %2) []) %2) ) {} c)\n  )","user":"56db90d4e4b0ea9b8538f80d"},{"problem":63,"code":"#(apply merge-with into (for [x %2](if (%1 x) {(%1 x) [x]}   {(%1 x) [x]}  )))","user":"5f77b99fe4b02876ed9fd0bc"},{"code":"(fn [f xs] (apply merge-with into (map #(hash-map (f %) [%]) xs)))","problem":63,"user":"510acd6ee4b078ea719210f4"},{"problem":63,"code":"(fn [f xs]\n   (reduce #(assoc %1 (f %2)\n                   ((fn [value v] (conj (if (nil? v) [] v) value))\n                    %2 (get %1 (f %2))))\n           {}\n           xs))","user":"5073e7fde4b054001656accb"},{"problem":63,"code":"(fn [f lst]\n  (apply merge-with concat\n              (for [x lst]\n                {(f x) [x]}\n              )\n  )\n)","user":"5943abb6e4b060784b3b792b"},{"problem":63,"code":"(fn [predicate collection] (reduce #(assoc %1 (predicate %2) (conj (get %1 (predicate %2) []) %2)) {} collection))","user":"5a59a76fe4b05d388ecb6c98"},{"problem":63,"code":"(fn foop [f coll] \n  (apply (partial merge-with concat) (map (fn [x] {(f x) [x]}) coll))\n)","user":"54b050cee4b09f271ff37d13"},{"code":"(fn [fnx se]\r\n  (let [ninto (fn[map [k v]]\r\n              (assoc map k (let [val (map k) ] \r\n                             (if (coll? val) (conj val v) [v]))))\r\n      t1 (fn [f se]\r\n           (map vector (map f se)  se))]\r\n    (reduce ninto {} (t1 fnx se))))","problem":63,"user":"4e9fde3c535d7eef3080729b"},{"problem":63,"code":"(fn [f s]\n  (reduce #(update-in %1 [(f %2)] (fnil conj []) %2)\n          {}\n          s))","user":"54246fcce4b01498b1a71aed"},{"problem":63,"code":"(fn [f coll] (reduce (fn [m v] (update-in m [(f v)] #(vec (conj % v)))) {} coll))","user":"541b37d2e4b01498b1a71a64"},{"code":"#(apply merge-with concat (for [x %2] {(% x) [x]}))","problem":63,"user":"4e823ed7535db62dc21a62c7"},{"problem":63,"code":"(fn [f x] (apply merge-with concat (map #(hash-map (f %) [%]) x)))","user":"566a3a26e4b0a866af689699"},{"problem":63,"code":"(fn [f s]\n  (reduce \n   #(assoc %1 (f %2) \n      (conj (get %1 (f %2) []) %2) )\n   {} s))","user":"54908cc1e4b0b312c081ff32"},{"code":"(fn [f col1] (persistent! (reduce\n    (fn [ret x]\n      (let [k (f x)]\n        (assoc! ret k (conj (get ret k []) x)))) (transient {}) col1)))","problem":63,"user":"4f2f6678e4b0d6649770a06e"},{"code":"#(loop [r {} [a & z :as s] (seq %2)]\n   (if (empty? s)\n      r\n      (recur (update-in r [(%1 a)]\n                (fn [v] (conj (or v []) a))) z)))","problem":63,"user":"4e5fe31a535d8ccf87e9fe50"},{"code":"(fn [f coll]\n  (reduce (fn [acc item]\n            (let [value (f item)]\n              (update-in acc [value] #(conj (vec %) item))))\n          {} coll))","problem":63,"user":"4ec70f26535d6d7199dd36dd"},{"problem":63,"code":"(fn [f s]\n    (reduce \n     (fn [v1 v2] (update-in v1 [ (first v2)] conj (second v2))) \n     {} \n     (for [s (reverse s)] [(f s) s])))","user":"52a7634ae4b0c58976d9ac16"},{"problem":63,"code":"(fn [f s] (reduce (fn [m v] (let [k (f v) oldv (get m k [])] (assoc m k (conj oldv v)))) {} s))","user":"55f09e7be4b06e875b46ce28"},{"code":"(fn [f coll]\n            (reduce (fn [result item] (update-in result [(f item)]\n                                (fnil conj []) item))\n                    {}\n                    coll))","problem":63,"user":"4daef21cedd6309eace4d169"},{"code":"(fn [f xs]\n  (reduce #(let [k (f %2)]\n             (assoc %1 k (conj (get %1 k []) %2)))\n          {} xs))","problem":63,"user":"515ead6be4b049add99a053e"},{"code":"#(reduce\n  (fn [ret x]\n    (let [k (% x)]\n      (assoc ret k (conj (get ret k []) x))))\n  {} %2)","problem":63,"user":"52851da0e4b0239c8a67adea"},{"problem":63,"code":"(fn f \n  [x y] \n  (reduce \n   #(let [a (x %2), b (% a)] (assoc % a (if (nil? b) (vector %2) (conj b %2)))) \n   {} y))","user":"5463fbbde4b01be26fd746ca"},{"code":"(fn [f s]\n  (apply merge-with into\n    (map hash-map (map f s) (map vector s))))","problem":63,"user":"4ec5aa1f535d6d7199dd36b0"},{"code":"(fn [f v] (into {}\n           (map #(vector (f (first %)) (vec %)) (partition-by f (sort v)))\n          \n           \n           ))","problem":63,"user":"51a477eee4b0def3c5c58692"},{"problem":63,"code":"(fn [f xs] (reduce (fn [coll x] (assoc coll (f x) (conj (get coll (f x) []) x))) {} xs))","user":"5627d09ce4b00e49c7cb47db"},{"problem":63,"code":"(fn group\n  [func coll]\n  (reduce (fn [reduction current]\n            (let [group-key (func current)\n                  group-col (or (reduction group-key) [])]\n                (assoc reduction group-key (conj group-col current)))) {} coll))","user":"5486e317e4b0e286459a11c0"},{"problem":63,"code":"#(reduce (fn [c x] (assoc c (% x) (vec (conj (c (% x)) x)))) {} %2)","user":"5c41db45e4b08cd430848ece"},{"problem":63,"code":"(fn [f coll]\n   (loop [xs coll\n          result {}]\n     (if xs\n       (let [x (first xs)]\n         (recur (next xs) ((fn [m k f] (assoc m k (f (get m k)))) result (f x) #(concat % [x]))))\n       result)))","user":"5d9e8e40e4b000c986472bc2"},{"problem":63,"code":"(fn [f coll]\n  (apply merge-with concat (for [x coll] {(f x) [x]}))\n  )","user":"55240916e4b0882d96d091b6"},{"code":"(fn [f s]\n  (apply merge-with concat (map #(hash-map (f %) [%]) s)))","problem":63,"user":"4ef0eaef535dced4c769f211"},{"problem":63,"code":"(fn my-group-by[f s]\n           (reduce (fn [acc i] (update-in acc [(f i)] #(into [] (conj %1 %2)) i)) {} s))","user":"530b8580e4b02e82168697cc"},{"code":"#(reduce \n  (fn [m v]\n    (let [k (% v)]\n      (assoc m k (conj (m k []) v)))) \n  {} \n  %2)","problem":63,"user":"4e7db3b4535db169f9c796e1"},{"problem":63,"code":"(fn [gfn coll]\n  (let [m (transient {})]\n    (loop [es coll]\n      (cond\n        (empty? es) (persistent! m)\n        :default\n        (let [k (gfn (first es))]\n          (assoc! m k (conj (get m k []) (first es)))\n          (recur (rest es)))))))","user":"56f9c7c6e4b07572ad1a88ba"},{"code":"(fn [f s]\n  (reduce #(let [v (f %2)] \n             (if (contains? %1 v) \n               (update-in %1 [v] (fn [c] (conj c %2))) \n               (assoc %1 v [%2]))) {} s))","problem":63,"user":"524be8e0e4b09eba1c0223f1"},{"problem":63,"code":"(fn [f coll]\n    (reduce (fn [m x]\n              (update-in m [(f x)] (fnil #(conj % x) []))) {} coll))","user":"5470b3d0e4b00cfc9eacc1bb"},{"problem":63,"code":"(fn groupseq [f xs] (loop [vals xs ret {}]\n                        (let [v (first vals)]\n                          (if (empty? vals)\n                            ret\n                            (recur (drop 1 vals)\n                                   (if (= nil (ret (f v)))\n                                     (conj ret {(f v) [v]})\n                                     (conj ret {(f v) (conj (ret (f v)) v)})))))))","user":"5d88d820e4b0915913b1d3b1"},{"code":"(fn [f s] \n  (reduce \n    (fn [tmp x] (assoc tmp (f x) (conj (get tmp (f x) []) x))) {} s))","problem":63,"user":"4fa6a491e4b081705acca1bc"},{"code":"(fn [x y] (reduce #(merge-with into %1%2) {} (for[a y]{(x a)[a]})))","problem":63,"user":"4e7eff9e535db966e863cc38"},{"problem":63,"code":"(fn [f vals] (into {}\n         (map #(vector (f (first %)) (vec %))\n              (partition-by f (sort vals)))))","user":"5ebc7c13e4b00a66d4a95267"},{"problem":63,"code":"(fn gr [f xs] (into {}\n                      (map #(vector (f (first %)) (vec %))\n                           (partition-by f (sort xs)))))","user":"5614fa1de4b05f002753dfbe"},{"problem":63,"code":"(fn group\n  [f s]\n  (apply merge-with concat (map #(hash-map (f %) (vector %)) s)))","user":"57f81544e4b0d3187e900917"},{"code":"(fn [op xs]\n  (apply merge-with concat (map #(hash-map (op %) [%]) xs))\n)","problem":63,"user":"5323a414e4b09d4e7a9b54d1"},{"code":"(fn [f coll]\n  (let [ks (map f coll)\n\t      iv (interleave ks coll)\n\t      iv-by-2 (partition 2 iv)\n\t      m (transient {})]\n\t  (doseq [[k v] iv-by-2]\n\t    (let [mapvalue (get m k)]\n\t      (if (nil? (get m k))\n\t          (assoc! m k (conj [] v))\n\t\t        (assoc! m k (conj mapvalue v)))))\n\t  (persistent! m)))","problem":63,"user":"4db045b5838c48654951d9be"},{"code":"#(apply merge-with concat (map (fn [x] {(%1 x) [x]}) %2))","problem":63,"user":"4e8516d0535db62dc21a62e8"},{"code":"(fn\n  [f coll]\n  (apply merge-with concat (for [x coll] {(f x) [x]})))","problem":63,"user":"525fffb8e4b03e8d9a4a702b"},{"problem":63,"code":"(fn [f s] (reduce (fn [m a] (assoc m (f a) (conj (or (m (f a)) []) a))) {} s))","user":"54bd04e7e4b0ed20f4ff6ed8"},{"code":"(fn [keyfn x]\n  (persistent!\n    (let [upsert (fn [m k v]\n                   (assoc! m k (conj (get m k []) v)))]\n      (reduce #(upsert %1 (keyfn %2) %2) (transient {}) x))))","problem":63,"user":"50ef56dfe4b0bdaecbb47d94"},{"problem":63,"code":"(fn g-by \n  [f coll]  \n  (persistent!\n   (reduce\n    (fn [ret x]\n      (let [k (f x)]\n        (assoc! ret k (conj (get ret k []) x))))\n    (transient {}) coll)))","user":"5414b7c4e4b01498b1a719ed"},{"problem":63,"code":"#(reduce (fn [a x] (merge-with into a {(% x) [x]})) {} %2)","user":"56706f01e4b0a866af6896f2"},{"code":"(fn [f v]\n  (loop [res (hash-map)\n   in v]\n    (if (empty? in)\n      res\n      (let [p (first in) val (f p)]\n\t(if (contains? res val)\n\t  (recur (assoc res val (conj (res val) p)) (rest in))\n\t  (recur (assoc res val [p]) (rest in))\n\t   )\n\t)\n      )\n    )\n  )","problem":63,"user":"4f63777be4b0defedf855fe4"},{"problem":63,"code":"(fn [f coll]\n  (reduce #(let [k (f %2)]\n             (if (contains? %1 k)\n               (update-in %1 [k] conj %2)\n               (assoc %1 k [%2])))\n          {}\n          coll))","user":"54722c55e4b094393f72dd74"},{"problem":63,"code":"(fn [f col] (reduce #(let [k (f %2) c (%1 k)] (assoc %1 k (conj (if (nil? c) [] c) %2))) {} col))","user":"576df252e4b0979f8965156f"},{"code":"(fn [f c]\n  (reduce\n    #(update-in % [(f %2)] concat [%2])\n    {}\n    c))","problem":63,"user":"51b3f109e4b0f094dd986fa9"},{"problem":63,"code":"(fn [f coll]\n    (reduce (fn [a v]\n              (let [result (f v)\n                    currec (get a result [])]\n                  (assoc a result (conj currec v) )))\n            {} coll))","user":"4f5e5975e4b0030a34fb2b4d"},{"problem":63,"code":"(fn mafil\n  [f lst]\n  (apply hash-map\n         (mapcat vector (map first (partition-by identity (map f (sort lst))))(partition-by f (sort lst)))))","user":"57fc34f0e4b0d3187e90098e"},{"problem":63,"code":"(fn [f li]\n\t(apply merge-with concat (map (fn [a] {(f a) [a]}) li)))","user":"54be7e93e4b0ed20f4ff6eed"},{"problem":63,"code":"(fn [f s] (reduce #(assoc %1 (f %2) (conj (apply vector (%1 (f %2))) %2)) {} s))\n;;(fn [f s] (reduce #(let [v (f %2)] (if (%1 v) (update-in %1 [v] conj %2) (assoc %1 v [%2]))) {} s))","user":"51319a53e4b06942423563c8"},{"code":"(fn [f seq]\n  (let [res (map (fn [x] [x (f x)]) seq)\n        dist (distinct (map second res))\n        u (for [d dist]\n            [d (loop [i 0 out []]\n                (if (== i (count res))\n                  out\n                  (if (= d (second (nth res i)))\n                    (recur (inc i) (conj out (first (nth res i))))\n                    (recur (inc i) out))))])]\n      (loop [j 0 ut {}]\n        (if (== j (count u))\n          ut\n          (recur (inc j) (assoc ut (first (nth u j)) (second (nth u j))))))))","problem":63,"user":"4e955b95535dbda64a6f6b33"},{"code":"#(reduce (fn [acc v]\n                  (let [r (%1 v)]\n                    (assoc acc r (conj (get acc r []) v)))) {} %2)","problem":63,"user":"4f88ae35e4b033992c121c6d"},{"problem":63,"code":"(fn abc [f sq]\n  (reduce \n   (fn [a b] (assoc a (f b) (conj (a (f b) []) b))) {} sq))","user":"5fe09d1fe4b05ac5b16ea15b"},{"problem":63,"code":"(fn [fn1 s] \n (loop [sq s result {}]\n    (if (empty? sq)\n      result\n      (recur\n        (rest sq)\n        (let [key (fn1 (first sq))]\n          (let [val (or (get result key) [])]\n            (assoc result key (concat val [(first sq)]))\n          )\n        )\n      )\n    ))\n)","user":"5f58db95e4b0a0bc16850a9a"},{"code":"(fn [f s] \n  (reduce (fn [m e]\n    (update-in m [(first e)] (comp vec conj) (last e)))\n    {}\n    (map #(vector (f %) %) s)))","problem":63,"user":"503255d0e4b0e78df07b092b"},{"code":"#(reduce (fn [ret x]\n            (let [k (%1 x)]\n              (assoc ret k (conj (get ret k []) x))))\n          {} %2)","problem":63,"user":"5336ca32e4b0e30313ee6c80"},{"code":"(fn gr [f col]\n  (if-let [s (seq col)]\n    (let [v  (first s)\n          fv (f v)\n          n  (gr f (next s))\n          nv (get n fv (list))\n          vv (assoc n fv (cons v nv))]\n      vv)\n    {}))","problem":63,"user":"53908e6be4b0b51d73faae9a"},{"problem":63,"code":"(fn [f coll] (persistent! (reduce (fn [ret x] (let [k (f x)] (assoc! ret k (conj (get ret k []) x)))) (transient {}) coll)))","user":"57123c96e4b09c608db70454"},{"problem":63,"code":"(fn [f items]\n  (reduce\n   (fn [result item]\n     (update-in result [(f item)] (comp vec conj) item))\n   {}\n   items))","user":"53de7484e4b0d874e779ae35"},{"problem":63,"code":"(fn [f col]\n  (reduce #(update-in %1 [(f %2)] (fn [v] (conj (or v []) %2)))\n          {}\n          col))","user":"567d132ee4b05957ce8c61c3"},{"problem":63,"code":"(fn [f s]\n  (reduce (fn [acc x]\n            (merge-with concat acc {(f x) [x]})) {} s))","user":"567c2322e4b05957ce8c61af"},{"code":"(fn [x y] (reduce #(merge-with concat % {(x %2) [%2]}) {} y))","problem":63,"user":"4ec0c7ba535dfed6da9c6da4"},{"problem":63,"code":"(fn [f s] (loop [cur s result {}]\n                  (if (= '() cur) result\n                    (let [e (first cur) k (f e) prev (get result k)]\n                      (recur (rest cur) (assoc result k (if (nil? prev) [e] (conj prev e))))))))","user":"6090e617e4b03bd49d9f36ce"},{"code":"(fn [f s]\n  (reduce #(assoc %\n                  (f %2) \n                  (conj (or (% (f %2)) []) %2))\n          {}\n          s))","problem":63,"user":"5013193ae4b0f26a0e3320ab"},{"problem":63,"code":"(fn my-group-by [f s]\n  (loop [[x & re :as s] s\n         a {}]\n    (if (empty? s)\n      a\n      (let [fx (f x)]\n        (if (contains? a fx)\n          (recur re (update-in a [fx] #(conj % x)))\n          (recur re (assoc a fx [x])))))))","user":"569f99cce4b0542e1f8d1497"},{"code":"(fn [f xs]\n  (let [vs (partition-by f (sort-by f xs))\n        ks (map #(f (first %)) vs)]\n    (zipmap ks vs)))","problem":63,"user":"512eb1e7e4b0b740abc5982a"},{"problem":63,"code":"(fn my-group [f coll]\n  ;; Create a list of k/v pairs where the key is the return value of (f x) and\n  ;; value is [x] (e.g ({false [1] false [2] ..})). Merge the k/v pairs into a\n  ;; single hash-map concatenating [x]'s for duplicate keys. The concatenated\n  ;; collection must be a vec.\n  (apply merge-with #(vec (concat %1 %2)) (map (fn [x] {(f x) [x]}) coll)))","user":"58327a08e4b089d5ab817c7c"},{"problem":63,"code":"(fn my-groupby [f xs]\n  (reduce (fn [acc x]\n            (let [key   (f x)\n                  group (vec (acc key))]\n              (assoc acc key (conj group x))))\n          {}\n          xs))","user":"5db0d470e4b0f8c104ccfc9e"},{"problem":63,"code":"(fn grp [f s]\n  (loop [[h & t :as s] s, res {}]\n    (if (empty? s)\n      res\n      (let [k (f h), g (get res k)]\n        (recur t (assoc res k (conj (if (nil? g) [] g) h)))))))","user":"5e9f38cce4b00a66d4a9517e"},{"problem":63,"code":"(fn grp-seq [f coll]\n  (reduce (fn [acc v] (update-in acc [(f v)] #(conj (vec %) v))) {} coll))","user":"55f6f1d3e4b06e875b46cea0"},{"code":"(fn [f coll]\n(reduce (fn [m1 m2]\n            (reduce (fn [m [k v]]\n                      (update-in m [k] (fnil conj []) v))\n                    m1, m2))\n          {} (map #(hash-map (f %) %) coll)))","problem":63,"user":"52f07ccee4b05e3f0be25edf"},{"problem":63,"code":"(fn g [f xs]\n  (loop [[x & xs] xs\n         acc      {}]\n    (if x\n      (let [k (f x)]\n        (recur xs (assoc acc k (conj (get acc k []) x))))\n      acc)))","user":"5dc88a38e4b02f9375f4e1db"},{"code":"(fn group-bye \n\t([fun xs] (group-bye fun xs {}))\n\t([fun [x & xs] groups]\n\t\t(if (nil? x)\n\t\t\tgroups\n\t\t\t(let [result (fun x)]\n\t\t\t\t(group-bye fun xs \n\t\t\t\t\t(if (contains? groups result)\n\t\t\t\t\t\t(assoc groups result (conj (get groups result) x))\n\t\t\t\t\t\t(assoc groups result [x])))))))","problem":63,"user":"50ed8a5fe4b06330c1f87c3d"},{"problem":63,"code":"(fn [f xs]\n  (reduce #(let [k (first %2) v (second %2)]\n             (assoc %1 k (conj (get %1 k []) v)))\n          {}\n          (map #(vector (f %) %) xs)))","user":"5a0ce1a5e4b04bbd27e6d9b7"},{"problem":63,"code":"(fn\n      [f,l]\n      (reduce\n       #(\n         assoc %1 (f %2) (conj (get %1 (f %2) []) %2 )\n         )\n       {} l)\n      )","user":"585d40afe4b0f14aab7c8798"},{"problem":63,"code":"(fn my-group2\n  [f coll]\n  (apply merge-with into (map #(hash-map %1 [%2]) (map f coll) coll)))","user":"4e586949535d8a8b8723a292"},{"problem":63,"code":"(fn [f xs] \n  (let \n    [ys (map (fn [x] {(f x) [x]}) xs)]\n    (apply merge-with concat ys)\n    )\n  )","user":"58334d18e4b089d5ab817c97"},{"problem":63,"code":"(fn my-group [f s]\n  (apply merge-with (fn [merged new] (into [] (concat merged new))) \n         (map (fn [k v] {k [v]}) (map f s)\n       s\n       ))\n  )","user":"55ba70f9e4b01b9910ae29d4"},{"code":"(fn [f c]\n  (reduce\n  #(assoc %1 (first %2)\n    (conj (get %1 (first %2) []) (first (rest %2))))\n  {}\n  (map list (map f c) c)))","problem":63,"user":"507e68abe4b085af06e3afd2"},{"code":"(fn my-group-by\n  [f xs]\n  (reduce \n   #(\n      if \n        (contains? %1 (f %2)) \n        (assoc %1 (f %2) (conj (get %1 (f %2)) %2))\n        (assoc %1 (f %2) (vector %2)))\n   {}\n   xs))","problem":63,"user":"536aa86de4b0243289761eb1"},{"problem":63,"code":"(fn [f xs]\n  (apply merge-with concat\n         (map\n          (fn [x]\n            (hash-map (f x) [x]))\n          xs)))","user":"5724a4dae4b0c5bde472c0fe"},{"problem":63,"code":"(fn [f s]\n    (apply merge-with into\n                (map hash-map (map f s) (map vector s))))","user":"573a0ecce4b0cd1946bd1088"},{"problem":63,"code":"(fn [f coll]\n    (reduce (fn [h el]\n              (let [\n                    key (f el)\n                    ary (get h key [])\n                    ]\n                (assoc h key (conj ary el))\n              ))\n            {}\n            coll)\n    )","user":"55aa5f73e4b0988bba2ad94b"},{"problem":63,"code":"#(reduce (fn [m x] \n            (let [k (% x)] \n              (assoc m k (conj (get m k []) x)))) {} %2)","user":"51c8f1d8e4b07ef393169e5d"},{"code":"(fn [f col]\n       (loop [more (map #(list (f %) %) col)\n        grouped {}]\n\t (if (empty? more)\n\t   grouped\n\t   (recur\n\t    (rest more)\n\t    (merge-with concat grouped\n\t\t\t(hash-map (ffirst more) [(second (first more))] ))))))","problem":63,"user":"4eae2f9e535d7eef30807324"},{"problem":63,"code":"(fn [f s]\n  (let [n (count s)]\n    (loop [i 0 output (hash-map)]\n        (if (= n i) output\n            (recur (inc i) (let [x (nth s i) y (f x)]\n                             (assoc output y (if (contains? output y) (conj (output y) x)\n                                                 [x]))))))))","user":"58f5b58ae4b0438e51c2cedc"},{"code":"(fn [f coll]\n  (reduce \n    (fn [m [k v]] \n      (assoc m k (conj (get m k []) v))) \n    {} \n    (map \n      #(vector (f %) %)\n      coll)))","problem":63,"user":"4e47f4f3535dc968683fc4bb"},{"problem":63,"code":"#(reduce\n  (fn [m x]\n    (let [k (%1 x)]\n      (assoc m k (conj (get m k []) x)))) {} %2)","user":"54e2a779e4b024c67c0cf7d3"},{"problem":63,"code":"(fn [f c]  (reduce  (fn [r i]  (assoc r (f i)  (conj  ( r (f i)  [])  i)          )                                         )    {} c   ) )","user":"5da98129e4b000c986472c33"},{"code":"(fn l [f x] (if (empty? x) {} (update-in (l f (rest x)) [(f (first x))] conj (first x))))","problem":63,"user":"51eb0374e4b0f1f103a0d156"},{"problem":63,"code":"(fn [f xs]\n  (reduce (fn [acc x]\n            (let [y (f x)]\n              (assoc acc y\n                (if (contains? acc y)\n                  (conj (get acc y) x)\n                  [x]))))\n          {} xs))","user":"55f73078e4b06e875b46cea4"},{"code":"(fn [f xs]\n  (reduce #(update-in % [(first %2)]\n\t\t      (fn [v c] (if (nil? v) [c] (conj v c))) (second %2)) {}\n   (map list (map f xs) xs)))","problem":63,"user":"4ef9c8f9535dced4c769f26b"},{"code":"#(apply merge-with (comp vec concat) (for [x %2] {(% x) [x]}))","problem":63,"user":"51057b2be4b06d28cacc92e8"},{"problem":63,"code":"(fn Group-a-Sequence\n  [f lst]\n  (into {} (map #(vector (f (first %)) (vec %)) (partition-by f (sort lst)))))","user":"59e14ee3e4b08badc2a0c50c"},{"code":"#(let [x (partition-by % (sort %2))]\n  (zipmap (map (comp % first) x) x)\n  )","problem":63,"user":"4eaa96e1535d7eef3080730d"},{"code":"(fn [f s]\n    (reduce \n     #(merge-with into % {(f %2) [%2]})\n     {} s)\n  )","problem":63,"user":"4fe8da4de4b0547ebccb2429"},{"code":"(fn [f s]\n  (loop [s s m {}]\n    (if (= () s)\n      m\n      (recur\n        (rest s)\n        (update-in m [(f (first s))]\n          (fn [v]\n            (if (nil? v)\n              [(first s)]\n              (conj v (first s)))))))))","problem":63,"user":"50435852e4b034ff00315d22"},{"problem":63,"code":"(fn [f xs]\n  (reduce \n   (fn [a x] \n     (let [k (f x)]\n       (assoc a k (conj (get a k []) x))))\n   {}\n   xs))","user":"54aec375e4b09f271ff37cf9"},{"problem":63,"code":"(fn [f xs]\n  (->> xs\n       (map (fn [x] [(f x) x]))\n       (reduce (fn [m [g x]] (assoc m g ((fnil conj []) (m g) x))) {})))","user":"559622cee4b0c79f6e1db975"},{"code":"(fn group [f s]\r\n  (letfn [(h [s m]\r\n          (if (empty? s)\r\n              m\r\n              (let [key (f (first s))]\r\n                    (if (contains? m key)\r\n                        (h (rest s) (assoc m key (conj (m key) (first s))))\r\n                        (h (rest s) (assoc m key [(first s)]))))))]\r\n          (h s (hash-map))))","problem":63,"user":"4df1ce44535d08e6dec9fe1f"},{"problem":63,"code":"(fn [f coll]\n   (let [tuples (sort-by first (map #(vector (f %) %) coll))]\n     (reduce\n       (fn [m x]\n         (if (contains? m (first x))\n           (assoc (dissoc m (first x)) (first x) (conj (get m (first x)) (second x)))\n          (assoc m (first x) (vector (second x)))))\n       {} tuples)\n     ))","user":"5d887d27e4b0915913b1d3a8"},{"problem":63,"code":"(fn [f l]\n      (loop [ll (map #(hash-map (f %) %) l) m {}]\n        (cond \n             (empty? ll) m\n             (not (contains? m (first (first (first ll))))) (recur (rest ll) (assoc m (first (first (first ll))) (vector (second (first (first ll))))))\n             :else (recur (rest ll) (merge-with #(conj %1 %2) m (first ll)))\n              )))","user":"56df6351e4b0ca2494a095f3"},{"problem":63,"code":"(fn [f, l] \n     (reduce \n       #(assoc % (f %2)  (conj (% (f %2) []) %2)) \n       {} \n       l)\n   )","user":"54a1d643e4b09f271ff37c50"},{"problem":63,"code":"(fn [pred xs]\n    (reduce (fn [acc x] (let [k (pred x)] (if (contains? acc k)  (assoc acc k (conj (get acc k) x)) (assoc acc k [x])))) {} xs)\n    )","user":"5e6b9955e4b04a83ad7cd27b"},{"code":"(fn group-by-\n  [f coll]\n  (letfn [(update-map [m x]\n            (let [k (f x)]\n              (assoc m k (conj (get m k []) x))))]\n    (reduce update-map {} coll)))","problem":63,"user":"4e5bff2b535d8a8b8723a2bd"},{"problem":63,"code":"#(reduce (fn[a x] \n           (let [k (%1 x) v (get a k [])] \n             (assoc a k (conj v x))))\n   {} %2)","user":"5a01d8f6e4b01bb0ae8afd53"},{"code":"(fn [f coll]\n  (reduce (fn\n            [m v]\n            (update-in m [(f v)] #((fnil conj []) % v))) {} coll))","problem":63,"user":"4e5914e0535d8a8b8723a29b"},{"code":"(fn [f vs]\n  (reduce #(merge-with into % {(f %2) [%2]}) {} vs))","problem":63,"user":"4f6160a7e4b0defedf855fbe"},{"code":"(fn [p c] (reduce (fn [x y]\n\t(assoc x (p y) (conj (get x (p y) []) y))) (cons {} c)))","problem":63,"user":"53500869e4b084c2834f4ad3"},{"code":"(fn [pred coll]\n  (reduce (fn [mp x]\n            (let [grouper (pred x)]\n              (assoc mp grouper (conj (get mp grouper []) x))))\n          {}\n          coll))","problem":63,"user":"50645e12e4b007509339a58a"},{"problem":63,"code":"(fn my-group-by [f c]\n  (reduce (fn [res el]\n            (let [k (first el)\n                  v (second el)]\n              (if (contains? res k)\n                (assoc res k (conj (get res k) v))\n                (assoc res k (vector v)))))\n          {}\n          (map #(vector (f %) %) c)))","user":"569f4dabe4b0542e1f8d1491"},{"problem":63,"code":"(fn [f s]\n  (reduce (fn [accum item]\n            (update-in accum [(f item)] #(vec (conj % item))))\n          {}\n          s))","user":"5215661be4b02f6d8ea676c7"},{"problem":63,"code":"(fn [f c]\n  (loop [o {}\n         ks (distinct (map f c))\n         s c]\n    (if (empty? ks)\n      o\n      (let [k (first ks)\n            v (filter #(= (f %) k) s)]\n        (recur (conj o [k v])\n               (rest ks)\n               (remove (set v) s))))))","user":"57533bc1e4b02ea1147992a6"},{"problem":63,"code":"(fn [f s] (reduce #(assoc %1 (f %2) (conj (or (get %1 (f %2)) []) %2)) {} s))","user":"584d8724e4b0b7285a6f4e3e"},{"problem":63,"code":"(fn [f coll]\n  (into {}\n        (map #(vector (f (first %)) %) (partition-by f (sort coll)))))","user":"57ee2b3ee4b0bfb2137f5bac"},{"problem":63,"code":"(fn [f coll] \n  (reduce\n   (fn [acc item]\n     (let [akey (f item)]\n       (assoc acc akey \n         (into (get acc akey []) [item])\n         )\n       )\n     )\n   {}\n   coll\n   )\n  )","user":"5680fff3e4b0966858e4d8f6"},{"code":"(fn gs\n  [f coll]\n  (reduce\n   #(let [k (f %2) v (get % k [])]\n      (assoc % k (conj v %2)))\n   {} coll))","problem":63,"user":"511d6a01e4b022853b0e07a5"},{"problem":63,"code":"(fn [f s] (apply merge-with into (for [i s] {(f i) [i]})))","user":"57235dc4e4b0c5bde472c0e2"},{"problem":63,"code":"(fn group-a-sequence\n  ([f coll]\n   (into {} (map #(vector (f (first %)) (vec %)) (partition-by f (sort coll))))))","user":"5bf5ddfde4b0bdcf453d159e"},{"code":"(fn [f s]\n  (reduce \n    #(update-in %1 [(f %2)] conj %2) \n    (zipmap (map f s) (repeat [])) \n    s))","problem":63,"user":"502952c9e4b0b33e9bf6fdf1"},{"problem":63,"code":"(fn [f coll]\n  (reduce (fn [acc x]\n            (let [current (get acc (f x))]\n               (if (nil? current) \n                 (assoc acc (f x) [x]) \n                 (assoc acc (f x) (conj current x)))))\n          {} coll))","user":"51427a8be4b0b50abeb46b37"},{"problem":63,"code":"(fn [f s]\n\t(reduce merge\n\t\t(for [e (into #{} (map f s))]\n\t\t\t(hash-map e (filter #(= e (f %)) s)))))","user":"536e5b68e4b0fc7073fd6e6d"},{"problem":63,"code":"(fn[f l]\n  (->> l\n       (map #(vec [% (f %)]))\n       (reduce #(let[[k v] %2\n              q (%1 v)]\n           (apply assoc %1 [v (conj (vec q) k)])) {})))","user":"54651ef5e4b01be26fd746d5"},{"problem":63,"code":"(fn [f c]\n   (apply merge-with concat \n          (map hash-map (map f c) (map list c))))","user":"538db083e4b0b51d73faae74"},{"problem":63,"code":"(fn [f coll]\n    (reduce #(merge-with concat % {(f %2) [%2]}) {} coll))","user":"532f8569e4b019098a6f8b4f"},{"problem":63,"code":"(fn [f xs] (reduce (fn [res x] (let [fx (f x)] (conj res [fx, (conj (get res fx []) x)]))) {} xs))","user":"56897739e4b0dcc4269f407d"},{"code":"(fn __ [f s]\n  (apply (partial merge-with concat) (map #(hash-map (f %) [%]) s)))","problem":63,"user":"4fa719c0e4b081705acca1bf"},{"problem":63,"code":"(fn[f s](apply merge-with concat (map (fn [x] (hash-map (f x) [x])) s)))","user":"5464a536e4b01be26fd746cf"},{"code":"(fn [f s]\n  (reduce (fn [h v]\n            (let [k (apply f [v])]\n              (assoc h k (conj (get h k []) v))))\n          {}\n          s))","problem":63,"user":"4fc3a72ae4b081705acca342"},{"problem":63,"code":"(fn group-by-impl\n  [f input]\n  (reduce #(assoc %1 (f %2)\n                     ((fnil conj []) (get %1 (f %2)) %2))\n          {} input))","user":"5a61bf79e4b0512ff01cd97b"},{"code":"(fn t [f coll]\n  (loop [coll coll group {}]\n    (if (seq coll) \n      (let [v (f (first coll))]\n      (recur (rest coll) (assoc group v (concat (group v) [(first coll)] ))))\n      group)))","problem":63,"user":"51aab611e4b04e3dc0c27b2d"},{"problem":63,"code":"(fn [f seq]\n  (reduce\n    (fn [map index]\n      (assoc map\n        (f index)\n        (conj\n          (map (f index) [])\n          index)))\n    {}\n    seq))","user":"5f081f6de4b0cf489e8d7f5a"},{"code":"(fn [f xs]\n   (reduce (fn [data number]\n             (let [key (f number)\n                   val (data key)]\n               (if val\n                 (assoc data key (vec (concat val [number])))\n                 (assoc data key [number])))) {} xs))","problem":63,"user":"4feaa579e4b0140c20fb9c0b"},{"problem":63,"code":"(fn\n  [f coll]\n  (reduce #(merge-with concat %1 {(f %2) [%2]}) {} coll))","user":"542d2385e4b0dad94371f2b2"},{"problem":63,"code":"(fn g [f c]\n  (reduce #(let [k (f %2)]\n             (if (contains? %1 k)\n               (assoc-in %1\n                         [k]\n                         (conj (get %1 k) %2))\n               (assoc % k [%2])))\n          {}\n          c))","user":"52c45ac8e4b0c2d177d620d9"},{"code":"(fn [f s]\n   (loop [m {} vc s]\n    (if (first vc)\n      (recur ((fn [m k v] (if (nil? (m k)) (assoc m k [v]) (assoc m k (conj (m k) v))))\n          m  (f (first vc)) (first vc)) (next vc))\n      m)))","problem":63,"user":"53219cece4b09d4e7a9b54b7"},{"code":"(fn [f s]\r\n  (apply merge-with concat (map #(hash-map (f %1) [%1]) s)))","problem":63,"user":"4f1b92d1535d64f60314647b"},{"code":"(fn fn2[f a]\n  (persistent!\n      (reduce\n        #(let [x (f %2)]\n              (assoc! % x (conj (get % x []) %2)))\n        (transient {}) a)))","problem":63,"user":"500b61b1e4b03d00572d2d81"},{"problem":63,"code":"(fn [f x]\n  (apply merge-with into \n         (map #(hash-map (f %) [%]) x)))","user":"5b14475be4b0cc2b61a3be5a"},{"problem":63,"code":"(fn [f s] \n  (reduce (fn [mp [v i]] \n            (if (mp v) \n              (assoc mp v (conj (mp v) i)) \n              (assoc mp v [i]))) {} (map vector (map f s) s)))","user":"55316b8ae4b076ab5578f825"},{"problem":63,"code":"(fn [f s] \n  (reduce \n   #(assoc %1 (f %2) \n      (conj (get %1 (f %2) []) %2))\n   {} s))","user":"5e3d183fe4b01d43a70e8e11"},{"code":"(fn [f s]\n  (reduce (fn [m e] \n            (let [k (f e)]\n              (assoc m k (conj (m k []) e))))\n          {} s))","problem":63,"user":"50aab057e4b056ee0193586b"},{"problem":63,"code":"(fn [f l] (reduce (fn [a b] (let [key (f b)] (assoc a key (if (contains? a key) (conj (a key) b) [b])))) {} l))","user":"584dadebe4b0b7285a6f4e44"},{"problem":63,"code":"#(reduce\n    (fn [dict item]\n      (let [key (%1 item)]\n        (assoc dict key (conj (get dict key []) item))\n        )\n      )\n    {}\n    %2\n    )","user":"5e491182e4b043cd24807a46"},{"code":"(fn this [f s]\n  (let [l1 (map (fn [i]\n                    [i (f i)]) s)\n        ]\n    (println l1)\n    (reduce (fn [result item]\n              (if (nil? (get result (second item)))\n                (merge result {(second item) (vector (first item))})\n                (merge result \n                       {(second item) \n                       (into (get result (second item)) \n                             (vector (first item))\n                       )}\n                )\n              )\n             ) {} l1\n      )\n    ))","problem":63,"user":"5021f0b3e4b00bba4502f7ac"},{"code":"(fn [f s] (reduce #(assoc % (f %2) (conj (% (f %2) []) %2)) {} s))","problem":63,"user":"4e1350af535d04ed9115e7d8"},{"problem":63,"code":"(fn [f s]\n  (reduce\n    (fn [m x]\n      (update-in\n        m\n        [(f x)]\n        #(if (= % nil) (vector x) (conj % x))))\n    {}\n    s))","user":"5a080bdde4b01bb0ae8afde9"},{"problem":63,"code":"(fn [f xs]\n  (letfn [(u[c n]\n           (let [k (f n)]\n             (assoc c k (conj (get c k []) n))))]\n    (reduce u {} xs)))","user":"55597b84e4b0deb715856e36"},{"code":"(fn [f s]\n  (reduce \n    (fn [m v] \n      (assoc m (f v) (conj (get m (f v) []) v)))\n    {}\n    s))","problem":63,"user":"510b704ee4b078ea71921100"},{"problem":63,"code":"(fn [f v] (apply merge-with (cons concat (map #(hash-map (f %) [%]) v))))","user":"544e6b7fe4b0e39780006986"},{"problem":63,"code":"(fn [f s] \n  (loop [rs {} ss s]\n    (if ss\n      (let [it (first ss) k (f it) ]\n        (recur (assoc rs k (conj (rs k []) it) ) (next ss))\n       )\n      rs\n      )\n    )\n  )","user":"5735ac67e4b0cd1946bd102b"},{"problem":63,"code":"(fn [f xs]\n  (reduce (fn [acc cur]\n            (let [n (f cur)]\n              (assoc acc n (conj (get acc n []) cur)))) {} xs ))","user":"5da7176ae4b000c986472c13"},{"code":"(fn [f coll]\n  (reduce #(let [group-key (f %2)]\n             (->> (if-let [cur (get %1 group-key)]\n                    (conj cur %2)\n                    [%2])\n                  (assoc %1 group-key)))\n          {}\n          coll))","problem":63,"user":"51ab4082e4b04e3dc0c27b31"},{"problem":63,"code":"(fn [f xs] (reduce #(let [v (f %2) r (%1 v []) vs (conj r %2)] (assoc %1 v vs)) {} xs))","user":"5602ab92e4b04bb52996e1a3"},{"problem":63,"code":"(fn [f lst] \n  (->> lst\n       (map f)\n       (set)\n       (map (fn [k] (vector k (filter #(= (f %) k) lst) )))\n       (into {}) \n  ))","user":"5f648ef1e4b02876ed9fd01b"},{"code":"(fn [f s]\n  (reduce (fn [h n]\n            (let [r (f n)]\n              (if (h r)\n                (assoc h r (conj (h r) n))\n                (assoc h r [n])\n              )))\n          {} s))","problem":63,"user":"51b86a0fe4b09e0e347b2e78"},{"code":"#(loop [coll %2, r {}]\n\t(if (empty? coll)\n\t\tr\n\t\t(recur\n\t\t\t(rest coll)\n\t\t\t(let [e (first coll), k (%1 e)]\n\t\t\t\t(assoc r k (conj (r k []) e))))))","problem":63,"user":"5370b386e4b0fc7073fd6e9b"},{"code":"(fn [f s]\n  (reduce \n    (fn [m v] \n      (let [x (f v)]\n        (assoc m x (conj (get m x []) v))))\n    {} s))","problem":63,"user":"50bfd849e4b042992946c649"},{"problem":63,"code":"(fn group-by_ [f coll]\n  (reduce\n   (fn [m x]\n     (update-in m [(f x)] (fnil #(conj % x) [])))\n   {}\n   coll))","user":"4f6ba7bce4b07046d9f4efb0"},{"code":"(fn [pred vals] (apply merge-with concat (map hash-map (map pred vals) (map vector vals))))","problem":63,"user":"502d4ea0e4b02fc10c6c6e46"},{"problem":63,"code":"(fn [f s]\n         (reduce #(assoc %1 (f %2) (concat (get %1 (f %2)) (vector %2))) {} s))","user":"591e0782e4b09b4ee5954c25"},{"problem":63,"code":"#(reduce (fn [h x]\n           (let [k (%1 x)]\n             (assoc h k (conj (get h k []) x))))\n         {}\n         %2)","user":"53dcf474e4b0d874e779ae25"},{"code":"(fn my-group-by\n  [f items]\n  (reduce\n   (fn [groups value]\n     (let [key (f value)]\n       (assoc groups key (conj (groups key []) value))))\n   {}\n   items))","problem":63,"user":"511720eae4b0063b4e3e16da"},{"problem":63,"code":"(fn [f coll] (into {}\n  (for [x coll\n    :let [y (f x)\n          z (filter #(= y (f %)) coll)]]\n    [y z]\n   )))","user":"593dfe60e4b069cdc2982bb1"},{"problem":63,"code":"(fn [f s]\n   (loop [xs s acc {}]\n     (let [val (first xs)]\n       (if (empty? xs)\n         acc\n         (let [key (f val)](recur (rest xs)\n                 (assoc acc key (conj (get acc key []) val))))))))","user":"53c06438e4b0c98a41f5ccb0"},{"problem":63,"code":"(fn group_seq [f s]\n  (into {}\n        (map #(vector (f (first %)) (vec %))\n             (partition-by f (sort s)))))","user":"5703d21ae4b08d47c97781ff"},{"problem":63,"code":"(fn [task input]\n  (loop [vals input\n         result (hash-map)]\n    (if (empty? vals) result\n        (let [v (first vals)\n              k (task v)\n              prev-val-in-result (get result k)]\n          (if (nil? prev-val-in-result) (recur (rest vals) (assoc result k [v]))\n              (recur (rest vals) (assoc result k (conj prev-val-in-result v))))))))","user":"596aaeefe4b069c0a1a19808"},{"code":"(fn [f s]\n  (reduce (fn [hmp x]\n            (let [k (f x)]\n              (if-not (contains? hmp k)\n                (conj hmp [k [x]])\n                (conj hmp [k (conj (hmp k) x)]))))\n          {}\n          s))","problem":63,"user":"5175616ae4b0dea9bbfba576"},{"problem":63,"code":"(fn gby [f coll]\n  (persistent!\n    (reduce\n      (fn [ret x]\n        (let [k (f x)]\n          (assoc! ret k (conj (get ret k []) x))))\n      (transient {}) coll)))","user":"579d9601e4b05b1deef9ae18"},{"code":"(fn [f s]\n  (reduce\n    (fn [ret e]\n      (let [k (f e)]\n      (assoc ret k (conj (get ret k []) e))))\n  {} s))","problem":63,"user":"4e5676b2535d8a8b8723a282"},{"code":"(fn [f c] \n  (reduce \n    #(let [k (f %2)] \n      (assoc %1 k \n        (conj (get %1 k []) %2)\n      )\n    ) \n    {} \n    c\n  )\n)","problem":63,"user":"52f1bc81e4b05e3f0be25eef"},{"code":"(fn [f s]\n  (reduce #(let [ret %1\n                 k   (f %2)\n                 v   (get ret k [] )]\n              (assoc ret k (conj v %2))) {} s))","problem":63,"user":"4fccb31be4b0ee37620e1868"},{"problem":63,"code":"#(reduce (fn [m v]\n            (let [k (%1 v)]\n              (if (contains? m k)\n                (update-in m [k] conj v)\n                (assoc m k (vector v)))))\n             {} %2)","user":"5cd639b4e4b0ccb061962940"},{"code":"(fn [f coll]\n  (apply merge-with into\n    (map #(hash-map (f %) [%]) coll)))","problem":63,"user":"4ec5d40d535d6d7199dd36b9"},{"problem":63,"code":"(fn p\n  [f s]\n  (reduce\n    (fn [func param]\n      (let [resto (f param)]\n        (assoc func resto (conj (or (func resto) []) param))))\n    {} s))","user":"56df7440e4b0ca2494a095fb"},{"problem":63,"code":"(fn [f x] (reduce #(assoc %1 (f %2) (conj (vec (get %1 (f %2))) %2) ) {} x ))","user":"524025bce4b0ad64fa01030f"},{"problem":63,"code":"#(loop [s %2\n        h {}]\n   (if (empty? s)\n     h\n     (let [v (first s)\n           k (%1 v)\n           h* (assoc h k\n                (if (contains? h k)\n                  (conj (get h k) v)\n                  [v]))]\n       (recur (rest s) h*))))","user":"551ed214e4b08d5046aa8a4d"},{"code":"(fn [f coll]\n  (let [key-values (map #(hash-map (f %) [%]) coll)]\n    (apply merge-with concat key-values)))","problem":63,"user":"4f7f9665e4b033992c121bea"},{"problem":63,"code":"(fn [f s]\n  (loop [[x & xs] s\n         result {}]\n    (if (nil? x)\n      result\n      (let [k (f x)\n            arr (or (result k) [])]\n        (recur xs (assoc result k (conj arr x)))))))","user":"5dcc152ae4b02b31cc3da3c3"},{"problem":63,"code":"(fn [f coll]\n  (reduce (fn [res x]\n            (let [k (f x)]\n              (assoc res k (conj (get res k []) x))))\n          {}\n          coll))","user":"5f93529ae4b0715f5002d7bc"},{"problem":63,"code":"(fn [f C] (reduce (fn [S x] (assoc S (f x) (vec (conj (S (f x)) x)))) {} C))","user":"55f6fe09e4b06e875b46cea2"},{"problem":63,"code":"(fn group [f vals] (into {}\n   (map #(vector (f (first %)) (vec %))\n        (partition-by f (sort vals)))))","user":"6074e1e4e4b069485764de4f"},{"problem":63,"code":"(fn my-group [func sec]\n \t(apply merge-with concat \n           (map \n            (fn [sec] \n              (hash-map (func sec) [sec])) sec)))","user":"59dd387be4b0a0ac046f2502"},{"problem":63,"code":"(fn [q w] (into {} (\n   \n (fn jp [op ser] \n   (if \n     (empty? ser) \n     () \n     (concat \n       (assoc {} (op (first ser)) (into [] (remove #(not (= (op (first ser)) (op %))) ser)) )\n       (jp op (remove #(= (op (first ser)) (op %)) ser)))))\n  q w)))","user":"544e1794e4b0e39780006980"},{"code":"(fn [kf coll]\n    (reduce (fn [acc item]\n              (let [k (kf item)]\n                (assoc acc k (conj (get acc k []) item)))) {} coll))","problem":63,"user":"4e6a0667535d8ccf87e9fe9e"},{"problem":63,"code":"(fn [f l]\n  (reduce (fn [acc cur]\n            (let [result (f cur)]\n              (assoc acc\n                     result\n                     (conj (get acc result [])\n                           cur))))\n          {}\n          l))","user":"565131b3e4b0f29ec07d2e88"},{"problem":63,"code":"(fn my-group-by [f xs]\n  (let [-group-by (fn [acc f [x & xs]]\n                    (if (nil? x)\n                      acc\n                      (let [new-value (f x)]\n                        (recur\n                         (update-in acc [new-value]\n                                 (fn[old-value]\n                                   (if (nil? old-value)\n                                     [x]\n                                     (conj old-value x)\n                                     )))\n                         f xs)\n                        )))]\n    (-group-by {} f xs))\n  )","user":"590d3702e4b047aa04b199ff"},{"problem":63,"code":"(fn [f xs] (->> (sort-by f xs) (partition-by f) (mapcat #(hash-map (f (first %)) (vec %))) (into {}) ))","user":"5409a12fe4b0addc1aec66df"},{"problem":63,"code":"(fn [f coll] \n  (let [f-s-c (sort-by f coll)\n        f-p-c (partition-by f f-s-c)]\n  \t(zipmap (map f (map first f-p-c))  f-p-c)\n    )\n  )","user":"569951e4e4b0542e1f8d143e"},{"code":"(fn fun [f x]\n  (loop [keys (map f x)\n         values x\n         result {}]\n    (if (empty? keys) result\n      (let [key (first keys)\n            value (first values)]\n        (recur (rest keys) (rest values) (assoc result key (conj (vec (result key)) value)))))))","problem":63,"user":"53733312e4b06d7f452d9e0a"},{"code":"#(reduce \n  (fn [r x]\n    (merge-with (fn [a b] (into [] (concat a b))) r {(%1 x) [x]}))\n  {}\n  %2)","problem":63,"user":"535ca812e4b04ce2eb3ed2b7"},{"code":"(fn [f x]\r\n   (reduce\r\n     #(merge %1 {(f %2) (conj (%1 (f %2) []) %2)})\r\n     {} x))","problem":63,"user":"5046b003e4b011c5dfee7727"},{"problem":63,"code":"(fn group-by' [f s] (reduce \n           (fn [m x] (update-in m [(f x)] #(vec (conj % x))))\n           {} s))","user":"54d7ed8de4b0a52adc2e2034"},{"code":"(fn [f coll]\n  (reduce #(assoc %1 (f %2) (conj (get %1 (f %2) []) %2)) {} coll))","problem":63,"user":"4e7e4d5c535db169f9c7970f"},{"code":"(fn group-sequence [f s]\n  (let [keys (map f s)\n        values-by-key (fn [k] (filter #(= k (f %)) s))]\n    (zipmap keys (map values-by-key keys))))","problem":63,"user":"52244a77e4b01819a2de42d1"},{"code":"(fn [pred coll]\n  (let [coll (sort coll)]\n    (zipmap (distinct (map pred coll)) (partition-by pred coll))))","problem":63,"user":"4e976f79535dbda64a6f6b55"},{"problem":63,"code":"(fn [f coll]\n  (let [r (reduce (fn [m n] (update-in m [(f n)] conj n)) {} coll)]\n    (zipmap (keys r) (map reverse (vals r)))))\n\n; Also:\n;\n; (fn [f coll]\n;   (apply merge-with concat\n;          (map (fn [n] {(f n) [n]}) coll)))","user":"5484143de4b0e286459a1197"},{"problem":63,"code":"(fn [f s]\n  (reduce\n   (fn [m x]\n     (let [fx (f x)]\n       (if (contains? m fx)\n       (assoc m fx (conj (m fx) x))\n       (assoc m fx [x]))))\n  {}\n   s))","user":"4f856adfe4b033992c121c44"},{"code":"(fn _group-by [function items]\n  (apply merge-with concat (for [item items]\n                       {(function item) (list item)})))","problem":63,"user":"510cd1dde4b078ea71921124"},{"problem":63,"code":"(fn [_func _seqn]\n  (loop [_seq _seqn\n         _map {}]\n    (if (empty? _seq)\n      _map\n      (let [frt (first _seq)\n            rst (rest _seq)\n            _val (_func frt)]\n        (if-not (contains? _map _val)\n          (recur rst (assoc _map _val (vec (list frt))))\n          (recur rst (assoc _map _val (conj (get _map _val) frt))))))))","user":"5854580ce4b07779d46863f9"},{"code":"(fn f \n  [g xs]\n  (reduce \n    (fn [x y]\n      (let [r (g y)]\n        (if (contains? x r)\n          (assoc x r (conj (x r) y))\n          (assoc x r (vector y)))))\n    {} \n    xs))","problem":63,"user":"50aa60bee4b056ee01935865"},{"code":"(fn [f x]\n  (into {}\n   (map #(vector (f (first % )) (vec %))\n        (partition-by f (sort x)))))","problem":63,"user":"52474133e4b05ef8e38e635e"},{"code":"(fn g[f s]\n    (loop [a s b {}]\n\t     (if (nil? a)\n\t\t b\n\t\t (let [v (first a)\n\t\t      k (f v)]\n\t\t      (if (b k)\n\t\t\t  (recur (next a) (assoc b k (conj (b k) v)))\n\t\t\t  (recur (next a) (assoc b k [v])))))))","problem":63,"user":"4e842ebb535db62dc21a62df"},{"code":"(fn [f coll]\n  (apply sorted-map (interleave\n   (distinct (map f coll)) (map vec (partition-by f (sort coll))))))","problem":63,"user":"532c9dc9e4b019098a6f8b30"},{"code":"(fn [f l]\n    (loop [l l\n           acc {}]\n      (if (zero? (count l))\n        acc\n        (recur (rest l)\n               (if (contains? acc (f (first l)))\n                 (assoc acc (f (first l)) (conj (get acc (f (first l))) (first l)))\n                 (assoc acc (f (first l)) [(first l)]))))))","problem":63,"user":"50a5b7e9e4b0aa96157e2610"},{"problem":63,"code":"(fn [f xs]\n         (apply merge-with concat\n                (for [x xs]\n                  {(f x) [x]})))","user":"58c4492be4b021aa9917ed27"},{"problem":63,"code":"(fn [functie lijst] (loop [lijst lijst result {}] (if (empty? lijst) result (recur (rest lijst) (update-in result [(functie (first lijst))] concat [ (first lijst)])))))","user":"58186016e4b0c0e9c07b83ad"},{"code":"(fn [f s] (loop [resultmap {} restseq s] \n             (if (empty? restseq) \n               resultmap \n               (recur \n                 (let [curelem (first restseq) fcurelem (f curelem)]\n                   (if (contains? resultmap fcurelem)\n                     (assoc resultmap fcurelem (concat (get resultmap fcurelem) [curelem]))\n                     (assoc resultmap fcurelem [curelem])))\n                 (rest restseq)))))","problem":63,"user":"536f2faee4b0fc7073fd6e79"},{"problem":63,"code":"(fn [f b] (reduce #(update-in %1 [(f %2)] (comp vec conj) %2) {} b))","user":"5910a43de4b0163c97b36ebf"},{"problem":63,"code":"(fn [f coll]\n  (->> (map #(hash-map (f %) [%]) coll)\n       (apply (partial merge-with into\n                      \n                       #_(fn [a b] (if (list? a) (conj a b) (list a b))) \n                       ))\n       \n       \n       ))","user":"58b12635e4b0ebc645576cf4"},{"code":"(fn [f a-seq] \n  (reduce\n    (fn [result data]\n      (let [ group (f data)\n             grouped (result group) ]\n        (assoc result group \n          (conj (if grouped grouped []) data))))\n    {} a-seq))","problem":63,"user":"4e6dc95a535d5021c1a895f1"},{"code":"(fn [f s]\n  (into {} (for [k (into #{} (map f s))] [k (filter #(= k (f %)) s)])))","problem":63,"user":"52160dbee4b0bf4bffd29cb3"},{"code":"(fn [f s] \n   (reduce\n    (fn [out x]\n      (let [k (f x)]\n        (assoc out k (conj (get out k []) x))))\n    {} s))","problem":63,"user":"536a37efe4b0243289761eaa"},{"problem":63,"code":"(fn [f coll]\n  (reduce (fn [a b]\n            (let [k (f b)\n                  v (a k)]\n              (if (nil? v)\n                (assoc a k [b])\n                (assoc a k (conj v b)))))\n          {}\n          coll))","user":"58bb218be4b0888cdc949cf4"},{"problem":63,"code":"(fn [f xs]\n  (reduce \n    (fn [m x]\n      (let [k (f x)]\n        (assoc m k (conj (m k []) x)))) \n    {} \n    xs))","user":"55fee5e4e4b00f4cabc5765a"},{"problem":63,"code":"(fn gb[f s] (reduce #(update-in % [(f %2)] (fn[x] (vec (conj x %2)))) {} s))","user":"56824e1be4b0945ebc182a91"},{"problem":63,"code":"(fn [f s]\n   (let [grouped (partition 2 (interleave (map f s) s))]\n     (apply (partial merge-with concat)\n            (map (fn [x] (assoc {} (first x) [ (second x)]))\n                           grouped))))","user":"5600dccee4b04bb52996e175"},{"problem":63,"code":"(fn   [f s]\n  (reduce (fn [new-map x]\n            (assoc new-map (f x) (vec (conj (get new-map (f x)) x))))\n          {}\n          s))","user":"5599abc9e4b031d6649c9bb0"},{"problem":63,"code":"(fn [f s]\n        (reduce (fn [m p]\n                  (update-in m [(first p)] #(concat % [(last p)]))) {} (map #(conj [] %1 %2) (map f s) s)))","user":"541f89a5e4b01498b1a71a99"},{"problem":63,"code":"(fn[f s]\n  (into {}\n      (map \n       (fn[k] [k (filter #(= (f %) k) s)]) \n       (distinct (map f s)))\n      ))","user":"52271ffee4b04e78ff2e19a9"},{"problem":63,"code":"(fn\n  [fnc coll]\n  (loop [args coll\n         result {}]\n    (if (empty? args)\n      result\n      (let [current (first args)\n            calculated (fnc current)\n            remaining (rest args)\n            new-vector (conj (apply vector (result calculated)) current)]\n        (recur remaining (assoc result calculated new-vector))))))","user":"603e8e3ae4b0d5df2af22316"},{"problem":63,"code":"(fn my-group2\n  [f s]\n  (println f)\n  (println s)\n  (loop [ff f\n         ss s\n         m {}]\n    (println \" loop ff - \" ff)\n    (println \" loop ss - \" ss)\n    (println \" loop m - \" m)\n    (cond\n      (= (nil? ss) true) m\n      (= (count ss) 0) m\n      :else (recur ff (rest ss) (merge m {(ff (first ss)) (conj (get m (ff (first ss)) []) (first ss))}))\n      )))","user":"58bd84d2e4b0888cdc949d31"},{"code":"(fn grp [f xs]\n  (zipmap (distinct (map f xs)) (map #(filter (fn [i](= % (f i))) xs) (distinct (map f xs)))))","problem":63,"user":"4fd9d162e4b05e33b9224f3c"},{"code":"(fn flter [f data] \n  (let [keys (map f data)\n        kmap (map #(hash-map %1 [%2]) keys data) \n        ]\n    (apply merge-with concat kmap)))","problem":63,"user":"4ffe8193e4b0678c553fc3f4"},{"code":"(fn myGroupBy\n  [fun coll]\n    (apply merge-with concat (map #(hash-map (fun %) (vector %)) coll)))","problem":63,"user":"509a25b7e4b0efbae1fbc0a8"},{"problem":63,"code":"(fn\n  [f s]\n  (reduce (fn [m i]\n            (assoc m\n              (f i)\n              (conj (m (f i) []) i)))\n          {}\n          s))","user":"59e4e3cbe4b08badc2a0c54a"},{"problem":63,"code":"(fn [f l]\n  (reduce (fn [res x]\n            (let [k (f x)]\n              (assoc res k (conj (get res k []) x))))\n          (hash-map) l))","user":"5a3e1243e4b0447ef91cc5ae"},{"problem":63,"code":"(fn [f xs]\n  (loop [xs xs res {}]\n    (if (empty? xs) res\n      (let [[x & xs] xs\n            k (f x)]\n        (recur xs\n               (assoc res k\n                 (if (res k)\n                   (conj (res k) x)\n                   [x])))))))","user":"553e0b70e4b0a04f792994e8"},{"code":"#(reduce \r\n  (fn [m e]\r\n    (assoc m (% e) (conj (get m (% e) []) e)))\r\n  {}\r\n  %2)","problem":63,"user":"4e03c616535d04ed9115e796"},{"problem":63,"code":"(fn my-group-by [f coll]                                                     \n  (loop [my-map (sorted-map) f f coll coll]                                    \n    (if (empty? coll)                                                          \n      my-map                                                                   \n      (let [curr-key (f (first coll))]                                         \n        (if (contains? my-map curr-key)                                        \n          (recur (into my-map [[curr-key (conj (get my-map curr-key) (first coll))]]) f (rest coll))                                                         \n          (recur (into my-map [[curr-key (vector (first coll))]]) f (rest coll)))))))","user":"56eb16d8e4b04a395b9a041d"},{"code":"(fn [f s]\n  (apply merge-with\n         `(~concat ~@(map #(hash-map (f %) [%]) s))))","problem":63,"user":"506a1985e4b01dc6af13f83e"},{"problem":63,"code":"(fn [func a-seq]\n  (reduce (fn [a-map x]\n            (let [val (func x)]\n              (if (a-map val)\n                (assoc a-map val (conj (a-map val) x))\n                (assoc a-map val [x]))))\n          {}\n          a-seq))","user":"574e84e0e4b02ea114799243"},{"code":"(fn [pred col] (reduce #(let [res (pred %2)]\n                        (assoc % res (conj (% res []) %2)))\n  \t\t\t\t\t\t{} col))","problem":63,"user":"5145832be4b0e8879607340a"},{"problem":63,"code":"(fn [f s] (reduce (fn [a c] \n                    (assoc a \n                      (f c) \n                      (conj \n                       (get a (f c) []) \n                       c)))\n                  {}\n                  s))","user":"4f3b5219e4b0e243712b1f2a"},{"code":"#(apply merge-with concat (for [x [%1] y %2 ]{(x y) [y]}))\n\n;(fn [f coll] \n;  (let [base-map (zipmap (map f coll) (repeat []))]\n;    (apply merge-with concat (map #(assoc base-map (f %) (conj (base-map (f %)) %)) coll))))","problem":63,"user":"4ff01fa9e4b0678c553fc321"},{"code":"(fn [f ls]\r\n      (into\r\n        {}\r\n        (map\r\n          #(vector (f (first %)) %)\r\n          (partition-by f (sort ls)))))","problem":63,"user":"5003ee7de4b0678c553fc446"},{"problem":63,"code":"(fn [f s]\n  (loop [s s\n         res {}]\n    (if (empty? s)\n      res\n      (let [nextel (first s)\n            curres (f nextel)\n            curvec (get res curres [])\n            newvec (conj curvec nextel)\n            ]\n        (recur\n         (rest s)\n         (assoc res curres newvec))))))","user":"592334c7e4b0a390037439ee"},{"problem":63,"code":"#(->> (map (fn [x] [(%1 x) x]) %2)\n       (reduce (fn [s [k v]] (into s {k (conj (get s k []) v)})) {}))","user":"55c1eb52e4b0e31453f64970"},{"problem":63,"code":"(fn my-group [f s]\n  (reduce (fn [groups x]\n            (let [existing (or (get groups (f x)) [])]\n              (assoc groups (f x) (conj existing x))))\n          {}\n          s))","user":"56444fb1e4b0018b46ad8c0c"},{"problem":63,"code":"(fn grp \n  ([f s] (grp f s {}))\n  ([f s rv]\n  \t(if (empty? s)\n      rv\n      (let [x (first s)\n            k (f x)]\n        (if (contains? rv k)\n          (grp f (rest s) (assoc rv k (conj (rv k) x)))\n          (grp f (rest s) (assoc rv k [x])))))))","user":"55934bebe4b0c79f6e1db93b"},{"code":"#(reduce (fn [m v] (merge-with into m {(% v) [v]})) {} %2)","problem":63,"user":"4dc1bd76535d020aff1edf8d"},{"problem":63,"code":"(fn [f col] (reduce (fn [map e ] (let [k (f e) v (map k) ] (conj map [k (if v (conj v e )[e])]))) {} col  ))","user":"54af6fb0e4b09f271ff37d08"},{"problem":63,"code":"(fn [f s]\n  (apply merge-with into\n         (for [v s]\n           {(f v) [v]})))","user":"59e8a952e4b0249b72820733"},{"problem":63,"code":"(fn p63 ([fcn coll] (p63 fcn coll {}))\n  ([fcn coll m]\n   (if-not (empty? coll)\n    (let [acc (hash-map (fcn (first coll)) [(first coll)])]\n     (if (contains? m (first (map key acc)))\n           (p63 fcn (rest coll) (merge-with concat m acc))\n            (p63 fcn (rest coll) (merge m acc))\n          )\n\n     )\n     (->> (reverse m)\n       (map #(hash-map (key %) (apply vector (val %))))\n        (apply merge)\n          (reverse)\n          (into {})\n          )\n     )))","user":"5400e918e4b0de5c41848619"},{"code":"(fn [f c]\n  (loop [m {} h (first c) t (rest c)]\n    (if (nil? h)\n      m\n      (recur (assoc m\n                    (f h)\n                    (conj (m (f h) []) h))\n             (first t) (rest t)))))","problem":63,"user":"51b0e7b3e4b0c53cf2e68a6e"},{"problem":63,"code":"(fn [f coll]\n  (apply merge-with\n         concat\n         (map (fn [i] {(f i) [i]}) coll)))","user":"50310713e4b05b7df5a0b84c"},{"code":"(fn [f s]\n  (reduce\n    (fn [a e]\n      (let [fe (f e)]\n        (assoc a fe (conj (get a fe []) e)))) {} s))","problem":63,"user":"4eb2e6ca535d7eef3080734f"},{"code":"(fn [f coll]\n  (let [assoc-in-group (fn [m k v]\n                         (if (m k)\n                           (assoc m k (conj (m k) v))\n                           (assoc m k [v])))]\n    (loop [e (first coll), coll (rest coll), acc {}]\n      (if (empty? coll)\n        (assoc-in-group acc (f e) e)\n        (recur (first coll) (rest coll) (assoc-in-group acc (f e) e))))))","problem":63,"user":"4fdbc075e4b05e33b9224f61"},{"problem":63,"code":"(fn [f l]\n  (reduce (fn [p1 p2]\n             (let [r (f p2), \n                   maplist (fn [target]\n                     (if (nil? target) [] target))]\n               (conj p1 [r (conj (maplist (get p1 r)) p2)])))\n          {} l))","user":"55d74e71e4b0e31453f64aa4"},{"problem":63,"code":"(fn new-group-by [f s]\n  (let [m {}]\n    (reduce\n     (fn [acc v]\n       (let [applied (f v)]\n         (if-let [k (get acc applied)]\n           (assoc acc applied (conj k v))\n           (assoc acc applied [v])))\n       )\n     m s)))","user":"5ef18431e4b07c55ae4a0529"},{"code":"(fn [f xs] (->> (map #(hash-map (f %) [%]) xs)\n                (apply merge-with concat)))","problem":63,"user":"518696c1e4b0c40be512d708"},{"problem":63,"code":"#(reduce (fn [map v]\n            (let [k (%1 v)]  \n              (assoc map k (conj (or (get map k) []) v)))\n            ) {} %2)","user":"5be0306be4b0ed4b8aab4c7d"},{"problem":63,"code":"(fn groupby [f, s] (reduce (fn [acc, i] (let [k (f i) v (get acc k [])] (assoc acc k (conj v i))  )) {} s))","user":"57eb7a97e4b0bfb2137f5b62"},{"problem":63,"code":"(fn group-a-sequence [f s]\n  (loop [s s res '{}]\n    (if (empty? s)\n      res\n      (recur (rest s) (if (contains? res (f (first s)))\n                        (assoc res (f (first s)) (conj (res (f (first s))) (first s)))\n                        (assoc res (f (first s)) (vector (first s))))))))","user":"563d12f9e4b0bfe05bf11845"},{"code":"(fn [f s]\n  (apply merge-with concat\n         (map #(hash-map (f %) (vector %)) s)))","problem":63,"user":"4daea889edd6309eace4d15b"},{"code":"(fn [f sq]\n  (reduce\n    (fn [acc itm]\n      (let [res (f itm)]\n        (if (nil? (acc res))\n          (assoc acc res [itm])\n          (update-in acc [res] conj itm))))\n    {}\n    sq))","problem":63,"user":"523bd9c0e4b07becd5be2201"},{"problem":63,"code":"#(->> (for [x %2 y [(%1 x)]] {y [x]})\n      (apply merge-with concat))","user":"5e471203e4b043cd24807a2a"},{"problem":63,"code":"(fn kel\n  [f ls]\n  (->> (partition-by f (sort-by f ls))\n       (map #(vector (f (first %)) %))\n       (into {})))","user":"581829cce4b0c0e9c07b83a9"},{"code":"(fn group-sequence [f x]\n  (reduce\n    (fn [result elem]\n      (let [key (f elem)\n            values (get result key [])\n            new-values (conj values elem)\n            new-result (assoc result key new-values)]\n        new-result))\n    {}\n    x))","problem":63,"user":"527fd663e4b0757a1b1713de"},{"problem":63,"code":"(fn [f coll] \n  (reduce \n   #(assoc % (f %2)\n      (into [] (concat (% (f %2) []) [%2])))\n   {} coll))","user":"54236ce1e4b01498b1a71ad1"},{"problem":63,"code":"(fn [f s] \n  (reduce (fn [acc v] \n            (let [k (f v)] \n              (assoc acc k (conj (get acc k []) v))))\n          {} s))","user":"57002b81e4b08d47c97781c7"},{"problem":63,"code":"(fn func [f s] (let [ks (map f s)] (into {} (for [k ks] (assoc {} k (filter #(= (f %) k) s))))))","user":"5addadfce4b0837691e92c13"},{"code":"(fn [func sq]\r\n  (loop [in sq out {}]\r\n    (if-not in\r\n      out\r\n      (recur\r\n        (next in)\r\n        (merge-with concat out {(func (first in)) (vector (first in))})))))","problem":63,"user":"4f3c772de4b0e243712b1f4c"},{"problem":63,"code":"(fn group-by* [x n]\n  (let [x* (fn [val res]\n             (let [valu (x res)]\n               (assoc val valu (concat (get val valu (list)) (list res)))))]\n    (reduce x* {} n)))","user":"5a99b861e4b0d174b936c7ad"},{"problem":63,"code":"(fn [fun ll] (let [rr (fn ru [ff l mm] (\n                                       if (empty? l) \n                                       mm\n                                       (ru \n                                        ff\n                                        (rest l)\n                                        (if (= (mm (ff (first l))) nil)\n                                          (conj mm {(ff (first l)) [(first l)]})\n                                          (conj mm {(ff (first l)) (conj (mm (ff (first l))) (first l))})\n                                          )\n                                        )\n                                       )\n                       )\n                  ]\n              (rr fun ll {})\n              )\n  )","user":"5c54e605e4b0fb8c5ffd9a14"},{"problem":63,"code":"(fn [key-fn coll]\n       (reduce (fn [acc item] (update-in acc [(key-fn item)] #(conj (or % []) item))) {} coll))","user":"537bde5de4b06839e8705e73"},{"problem":63,"code":"(fn [f coll]\n     (loop [coll coll\n            map-result {}]\n       (cond (empty? coll) map-result\n             :else\n             (let [k (f (first coll))\n                   v (map-result k [])]\n               (recur (rest coll) \n                      (assoc map-result k\n                             (conj v (first coll))))))))","user":"5e724492e4b085ba37836dc7"},{"problem":63,"code":"(fn [func v]\n  (loop [in v\n         acc {}]\n    (let [item (first in)]\n      (if item\n        (let [result (func item)]\n          (recur (rest in)\n                 (assoc acc result\n                        (conj (or (get acc result)\n                                  [])\n                              item))))\n        acc))))","user":"563f4c47e4b08d4f616f5ed2"},{"problem":63,"code":"(fn  [p xs]\n  (reduce (fn [acc x] (assoc acc (p x) (conj (acc (p x)) x))) {} (reverse xs)))","user":"5d81b40ce4b0915913b1d379"},{"code":"(fn [f s]\n    (reduce (fn [acc itm] (assoc acc (f itm) (conj (get acc (f itm) []) itm))) {} s)\n\n  )","problem":63,"user":"53489329e4b084c2834f4a5b"},{"code":"(fn [f s]\n  (reduce\n   (fn [a n]\n     (let [k (f n) v (get a k [])]\n       (assoc a k (conj v n))))\n     {} s))","problem":63,"user":"52ce2aace4b07d0d72b2738b"},{"problem":63,"code":"(fn \n  [f s] \n  (into \n   {} \n   (map \n    (fn \n      [key-value] \n      [key-value (into [] (filter #(= key-value (f %)) s))]) \n    (into [] (set (map f s))))))","user":"5d7a748ce4b02e6b30c93547"},{"problem":63,"code":"(fn [f xs]\n  (reduce\n    (fn [acc x]\n      (let [key (f x)\n            vals (get acc key [])]\n        (assoc acc key (conj vals x))))\n    {}\n    xs))","user":"5991eec7e4b0866487ed0d6e"},{"problem":63,"code":"(fn [f col]\n     (reduce\n      (fn [m x]\n        (assoc\n          m\n          (f x)\n          (conj (m (f x) []) x)))\n      {}\n      col))","user":"56349008e4b0bfe05bf117bd"},{"problem":63,"code":"(fn [f vs]\n  (into {}\n        (map #(vector (f (first %)) (vec %))\n             (partition-by f (sort vs)))))","user":"4eb3fcba535d7eef30807359"},{"problem":63,"code":"#(reduce\n    (fn [acc it]\n      (assoc acc (%1 it) (conj (if (contains? acc (%1 it)) (get acc (%1 it)) []) it)) \n    )\n    {}\n    %2\n  )","user":"5cbdc591e4b026601754ba00"},{"problem":63,"code":"(fn group-seq\n  [pred args]\n  (let [ add-or-append (fn [dict key value] \n                         (if (contains? dict key)\n                           (update-in dict [key] #(conj % value))\n                           (into dict [[key [value]]])))]\n    (reduce #(add-or-append %1 (pred %2) %2) {} args)))","user":"583166c1e4b051871117c025"},{"code":"(fn [pred coll]\n  (let [keys (map pred coll)\n        vals coll\n        s (interleave keys vals)]\n    (reduce (fn [acc [k v]]\n              (assoc acc k (conj (acc k []) v)))\n            {}\n            (partition-all 2 s))))","problem":63,"user":"51778122e4b085adf681d89d"},{"problem":63,"code":"(fn [f coll]\n  (loop [m {} coll coll]\n    (if (empty? coll) m\n      (let [v (first coll)\n            k (f v)\n            c (rest coll)]\n        (if (contains? m k)\n          (recur (assoc-in m [k] (conj (m k) v)) c)\n          (recur (assoc-in m [k] [v]) c))))))","user":"54d1b6ffe4b0e8a36923e5e6"},{"code":"(fn my-group-by [pred coll]\n  (let [toKeyValue (fn [m v]\n                     (let [k (pred v)]\n                       (assoc m k (conj (get m k []) v))))]\n    (reduce toKeyValue '{} coll)))","problem":63,"user":"52d809bde4b09f7907dd1384"},{"problem":63,"code":"(fn [f coll]\n  (let [keys (distinct (map f coll))\n        vals (partition-by f (sort coll))]\n    (zipmap keys vals)))","user":"58182480e4b0c0e9c07b83a7"},{"code":"(fn [f c] (reduce #(assoc % (f %2) (conj (get % (f %2) []) %2)) {} c))","problem":63,"user":"4ecc1d85535d23f0362276f8"},{"code":"(fn asdf [x y] \n   (reduce #(let [kk (get %2 0) vv (get %2 1)]\n              (if (contains? %1 kk) (assoc %1 kk (conj (get %1 kk) vv))\n              (assoc %1 kk [vv]))) {} (map #(conj [] (x %1) %1) y) )\n   )","problem":63,"user":"5012036ce4b0a040369c12f4"},{"problem":63,"code":"(fn [f xs]\n  (loop [[x & rest] xs\n         acc {}]\n    (if x\n      (recur rest (update-in acc [(f x)] #(vec (conj % %2)) x))\n      acc)))","user":"530a6cbae4b02e82168697be"},{"code":"(fn grpby [f s]\n  (reduce (fn [m [k & v]]\n            (assoc-in m [k] (vec (concat (m k) v))))\n          {}\n          (for [el s] [(f el) el])))","problem":63,"user":"4f0ef874535d0136e6c22328"},{"problem":63,"code":"(fn [f s] (loop [i 0 m {}] (if (= i (count s)) m (let [e (nth s i) k (f e)] (recur (inc i) (if (contains? m k) (assoc-in m [k (count (m k))] e) (assoc m k [e])))))))","user":"59468de7e4b07ddc2dafad88"},{"problem":63,"code":"(fn [f coll]\n  (reduce conj {}  (for [i (set (for [x coll] (f x)))] [i (filter #(= (f %) i) coll)])))","user":"5ee738dee4b029a2061bbea2"},{"code":"(fn [f coll]\n  (reduce #(conj %1 {(f %2) (conj (%1 (f %2) []) %2)}) {} coll))","problem":63,"user":"527dc2aee4b0757a1b17138d"},{"problem":63,"code":"(fn [f s]\n  (loop [s s\n         res {}]\n    (if (seq s)\n      (let [fs (f (first s))]\n        (recur (rest s) (if (contains? res fs) (assoc res fs (conj (get res fs) (first s))) (assoc res fs [(first s)]))))\n      res)))","user":"5a6b9b95e4b0512ff01cda40"},{"problem":63,"code":"(fn [f1 l1] (into (sorted-map)((fn [f2 l2] \n(\nlet [add (fn [f x y] (vec (conj (x (f y)) y)))]\n(reduce #(conj %1 {(f2 %2) (add f2 %1 %2)}) {} l2)\n)) f1 l1 )))","user":"54a7efdee4b09f271ff37c9d"},{"problem":63,"code":"(fn [f li] (reduce (fn [di e] (let [res (f e)] (if (contains? di res) \n                                                 (assoc di res (conj (di res) e))\n                                                 (assoc di res [e])))) {} li))","user":"59156f0be4b0163c97b36f3d"},{"problem":63,"code":"(fn [pred s] (apply merge-with into (map (fn [l] {(pred l) [l]}) s)))","user":"5a2df4a0e4b09cafd31c7f74"},{"problem":63,"code":"(fn group-by1 [f coll]\n  (loop [map nil\n         res coll]\n    (if (not-empty res)\n      (let [val (first res)\n            key (f val)]\n        (recur (assoc map key (conj (get map key []) val)) (rest res))\n        )\n      map\n      )\n    )\n  )","user":"55f06183e4b06e875b46ce23"},{"problem":63,"code":"(fn [fnc x] (loop [mapp {}\n                   n 0]\n                 (println (nth x 1))\n                (if (= n (count x))\n                    mapp\n                    (if (contains? mapp (fnc (nth x n)))\n                        (recur (assoc mapp (fnc (nth x n)) (concat (get mapp (fnc (nth x n))) [(nth x n)] )) (inc n))\n                        (recur (assoc mapp (fnc (nth x n)) [(nth x n)]) (if (= n 0) 1 (inc n))  )))\n                ))","user":"607e1d9de4b03d835a6eaedb"},{"problem":63,"code":"(fn [f lst]\n  (reduce #(assoc %1 (f %2) (conj (apply vector (%1 (f %2))) %2)) {} lst))","user":"57fa7c93e4b0d3187e900963"},{"code":"(fn [f coll] (apply merge-with concat (for [x coll] {(f x) [x]})))","problem":63,"user":"4ebcb8ff535dfed6da9c6d8a"},{"code":"(fn [f coll] (reduce #(conj % (vector (f %2) (vec (conj (% (f %2)) %2)))) {} coll))","problem":63,"user":"4f1e4ab5535d64f603146496"},{"code":"(fn [f s]\n  (reduce (fn [h x]\n            (update-in h [(f x)] #(conj (or % []) x)))\n          {} s))","problem":63,"user":"517b59b8e4b0925c997201d0"},{"problem":63,"code":"(fn [f s]\n  (reduce (fn [m v]\n            (let [key (f v)]\n              (assoc m key (conj (get m key []) v))))\n          {}\n          s))","user":"532902f8e4b09d4e7a9b550e"},{"code":"(fn createMap \n  ([func li]\n    (if (empty? li)\n      (hash-map)      \n    (let [f (first li)\n          t (func f)\n          mp (createMap func (rest li) )] \n      (if (contains? mp t) \n        (assoc mp t  (vec( cons f (get mp t ) ))) \n        (assoc mp t  (vector f)))))))","problem":63,"user":"4e8d5edd535d65386fec2134"},{"problem":63,"code":"(fn grup-by2\n  [f coll]\n  (let [keys (distinct (map f coll))\n        n (count keys)]\n    (->> (for [k keys\n               c coll\n               :when (= k (f c))]\n           c)\n         (partition-by f)\n         (interleave keys)\n         (apply hash-map))))","user":"55bf6dbce4b01b9910ae2a12"},{"code":"(fn [f xs]\n  (apply merge-with concat\n    (map #(hash-map (f %) [%]) xs)))","problem":63,"user":"515a6151e4b0394f658fe241"},{"problem":63,"code":"(fn [f coll]\n    (->> (map #(hash-map (f %) [%]) coll)\n         (cons into)\n         (apply merge-with)))","user":"5ab1665de4b073f1774425c0"},{"code":"(fn [f coll]  \r\n  (persistent!\r\n   (reduce\r\n    (fn [ret x]\r\n      (let [k (f x)]\r\n        (assoc! ret k (conj (get ret k []) x))))\r\n    (transient {}) coll)))","problem":63,"user":"5028bce0e4b01614d1633ffb"},{"problem":63,"code":"(fn g-by[f s] (reduce #(if(contains? %1 (f %2) ) (assoc %1 (f %2) (conj (get %1 (f %2)) %2)) (assoc %1 (f %2) (conj (vector) %2)) ) {} s ))","user":"5cf53196e4b087f62be35a94"},{"problem":63,"code":"(fn [f s]\n  (apply merge-with concat\n              (map (fn [a b] {a (list b)}) (map f s) s)))","user":"543366dde4b0b6b47310fcdf"},{"problem":63,"code":"(fn [f s] (reduce (fn [a x] (update-in a [(f x)] #(conj (or % []) x))) {} s))","user":"5a4de614e4b05d388ecb6bb1"},{"code":"(fn [f s]\n(reduce\n (fn [m a] \n   (assoc m (f a) (conj (get m (f a) []) a))\n )\n {} s\n)\n)","problem":63,"user":"514457fbe4b0b4fb4ace5f43"},{"code":"#(reduce (fn [m x] (let [k (% x) v (m k) new-v (if (vector? v) (conj v x) [x])] (assoc m k new-v))) {} %2)","problem":63,"user":"51e61772e4b0efabf93c02e2"},{"code":"(fn [f xs] (apply merge-with concat (for [x xs] {(f x) [x]})))","problem":63,"user":"4e57afc5535d8a8b8723a288"},{"code":"#(apply merge-with concat (for [a %2] {(% a) [a]}))","problem":63,"user":"4eb5750a535d7eef30807366"},{"problem":63,"code":"(fn grp-b ([func coll] (grp-b func (rest coll) (assoc {} (func (first coll)) [(first coll)])))\n  ([func coll hmap] (if (empty? coll)\n                      hmap\n                      (let [v (first coll)\n                          k (func v)]\n                      (grp-b func (rest coll) (assoc hmap k (if (contains? hmap k) (conj (hmap k) v) [v])))))))","user":"5759cd46e4b02ea11479932e"},{"code":"(fn grouper [f xs]\n\t  (cond (empty? xs) {}\n\t\t:else (let [value (first xs)\n\t\t\t   key (f value)\n\t\t\t   processed (grouper f (rest xs))]\n\t\t\t   (if (contains? processed key)\n\t\t\t       (assoc processed key (conj (processed key) value))\n\t\t\t       (assoc processed key (list value)))\n\t\t\t   )))","problem":63,"user":"5213ffd3e4b0961f15ac4d7d"},{"code":"#(reduce (fn [s e]\n           (let [fe (% e)]\n             (assoc s fe (conj (get s fe []) e))))\n         {} %2)","problem":63,"user":"52736ca1e4b03e8d9a4a747e"},{"code":"(fn [f s]\n    (loop [s s\n           answer {}]\n      (if (nil? s) answer\n          (let [k (f (first s))]\n            (recur (next s) (if (get answer k) (assoc answer k (conj (get answer k) (first s)))\n                                (assoc answer k [(first s)])))))))","problem":63,"user":"4e89e939535d3e98b8023287"},{"code":"(fn[ f v]\n   (apply merge-with concat \n           (map\n            #(apply array-map ((juxt f  (fn [x] (vector (identity x))))%)) v)))","problem":63,"user":"5300aa1de4b0d8b024fd3710"},{"code":"(fn [f s] (reduce (fn [a itm] (assoc a (f itm) (concat (a (f itm)) [itm]))) {} s))","problem":63,"user":"521e8227e4b0dd19981ad082"},{"problem":63,"code":"(fn f\n  [fun n]\n  (reduce (fn [lst x]\n                (let [y (fun x)]\n                    (assoc lst y (conj (get lst y []) x))))\n  {} n))","user":"56df63e1e4b0ca2494a095f6"},{"problem":63,"code":"(fn [f s]\n  (reduce #(assoc %1\n             \t  (f %2)\n                  (conj (vec (get %1 (f %2))) %2))\n          {}\n          s))","user":"54c271b9e4b045293a27f602"},{"problem":63,"code":"; update is blocked for some reason, so we'll use update-in instead...\n; we need to explicitly use a vector, since (conj nill 'a) is '(:a), thus conjing will prepend\n(fn [f col]\n  (reduce (fn [m v] (update-in m [(f v)] #(vec (conj % v)))) \n          {} \n          col))","user":"54d341f7e4b0e8a36923e603"},{"problem":63,"code":"(fn [f xs]\n   (reduce\n     (fn [acc x] (assoc acc (f x) (conj (if-let [v (get acc (f x))] v (vector)) x)))\n     {}\n     xs))","user":"56e2ca59e4b03a7c14b85a38"},{"code":"(fn [f col] (reduce (fn [m v]\n                               (let [k (f v)]\n                                         (if (contains? m k)\n                                           (assoc m k (conj (get m k) v))\n                                              (assoc m k [v])))) {} col))","problem":63,"user":"4e7ada51535db169f9c796ae"},{"code":"(fn [pred coll]\n  (reduce\n    (fn [dict m]\n      (let [ret (pred m)]\n        (assoc dict ret (conj (or (dict ret) []) m))))\n    {} coll))","problem":63,"user":"531c0619e4b08068f379ed98"},{"code":"(fn [f coll] (reduce #(if (% (f %2))\n  \t\t\t (assoc % (f %2) (conj (% (f %2)) %2))\n\t\t\t         (assoc % (f %2) (vector %2))) {} coll))","problem":63,"user":"50563ae2e4b0ce54f56f0405"},{"problem":63,"code":"(fn [func seq]\r\n  (loop [seq seq\r\n         result {}]\r\n    (if (empty? seq)\r\n      result\r\n      (let [[head & tail] seq\r\n            key (func head)]\r\n        (recur tail\r\n          (into result\r\n            {key\r\n              (if (contains? result key)\r\n                (conj (result key) head)\r\n                [head])}))))))","user":"555bd27ae4b0b056612e2244"},{"problem":63,"code":"(fn foo [f s]\n  (apply merge-with concat\n    (map \n      #(hash-map\n        (f (first %))\n        (vec %))\n       (partition-by f s))))","user":"5143824ae4b0b4fb4ace5f36"},{"problem":63,"code":"(fn group-by' [f s]\n  (reduce\n    (fn [acc curr]\n      (let [result (f curr)]\n        (if (contains? acc result)\n          (update-in acc [result] conj curr)\n          (assoc acc result [curr]))))\n    {}\n    s))","user":"5d0eed51e4b0cc9c91588262"},{"problem":63,"code":"(fn g-by [f sq]\n  (loop [gp-map {}\n         sq-it sq]\n    (if (empty? sq-it)\n      gp-map\n      (recur (merge-with concat\n                         gp-map\n                         {(f (first sq-it)) [(first sq-it)]})\n             (rest sq-it)))))","user":"559d33b3e4b0ec2b359424d9"},{"problem":63,"code":"#(let [f-sorted (partition-by % (sort-by % %2))] (zipmap (map (comp % first) f-sorted) f-sorted))","user":"5f03ab5be4b0cf489e8d7f37"},{"code":"(fn [f s]\n  (reduce (fn [m v] (update-in m [(f v)] #(if (nil? %) [v]\n                                            (conj % v))))\n          {} s))","problem":63,"user":"5175533fe4b0dea9bbfba575"},{"code":"(fn [fu se]\n   (let [ks (distinct (map #(fu %) se))\n         vs (map (fn [el]\n                   (vec (filter\n                          #(= el (fu %)) se)))\n                 ks)]\n     (zipmap ks vs)))","problem":63,"user":"4fbe42b7e4b081705acca30f"},{"problem":63,"code":"(fn group-by-\n  [f coll]\n  (->> coll\n       (map (fn [x] {(f x) [x]}))\n       (apply merge-with concat)))","user":"604a30c6e4b02d28681c77f0"},{"code":"#(apply merge-with concat (for [x %2] (assoc {} (%1 x) [x])))","problem":63,"user":"504e397ee4b0f6ff3350c485"},{"problem":63,"code":"(fn [f data]\n  (reduce (fn [results item]\n            (let \n              [value (f item)] \n              (if (contains? results value)\n                  (assoc results value (conj (results value) item))\n                  (assoc results value (vector item)))\n            )) \n          {} \n          data))","user":"546692aee4b01be26fd746e7"},{"problem":63,"code":"#(reduce (fn [m v]\n           (let [k (%1 v)]\n             (assoc m k (conj (or (m k) []) v))))\n         {}\n         %2)","user":"5829d9f8e4b051871117bf4d"},{"problem":63,"code":"(fn [f coll]\n   (reduce (fn [m i]\n             (let [x (vec i)\n                   c (first (map f x))\n                   y (vec (flatten x))]\n               (println m y)\n               (if (find m c)\n                 (assoc m c (conj (get m c) y))\n                 (assoc m c x))))\n           {}\n           (partition-by f coll)))","user":"56c70cc2e4b0ed865f9758b5"},{"problem":63,"code":"#(loop [m {} coll %2]\n   (if (empty? coll)\n     m\n     (let [v (first coll) k (% v)]\n       (recur (if (m k)\n                (update-in m [k] conj v)\n                (assoc m k [v]))\n              (rest coll)))))","user":"56677192e4b04acd4f672dd5"},{"problem":63,"code":"(fn [f c]\n  (reduce #(assoc %1\n                  (f %2)\n                  (conj (get %1 (f %2) [])\n                        %2))\n          {}\n          c))","user":"5156e767e4b04360f2428e6b"},{"problem":63,"code":"(fn [f s]\n  (->> ((juxt #(distinct (map % (sort %2)))\n              #(partition-by % (sort %2))) f s)\n       (apply interleave)\n       (apply hash-map)))","user":"56a44067e4b0542e1f8d14da"},{"code":"(fn  [f s]\n  (loop [vals s, kys (map f s), h (hash-map)]\n    (let [v (first vals), k (first kys)]\n      (cond (empty? vals) h\n            (nil? (h k)) (recur (rest vals) (rest kys) (assoc h k (vector v)))\n            :else (recur (rest vals) (rest kys) (assoc h k (conj (h k) v)))))))","problem":63,"user":"538e36c7e4b0b51d73faae81"},{"code":"(fn [f xs]\n  (reduce \n    #(update-in %1 [(f %2)] \n         (fn [v] (if v (conj v %2) [%2])))\n    {}\n    xs))","problem":63,"user":"4e513758535dc968683fc4f3"},{"problem":63,"code":"(fn [fun col]\n\t(loop \n      [result (map (fn [s] [(fun s) s]) col) \n       acc {}] \n      \n      (if (empty? result) \n        acc \n        (recur (rest result) (let [f (first result)] (assoc acc (first f) (concat (get acc (first f) nil) (rest f)))))\n      )\n     )\n)","user":"5ea97df7e4b00a66d4a951c8"},{"problem":63,"code":"#(reduce (fn[m x] (update-in m [(%1 x)] (fn[y] (conj (vec y) x)))) {} %2)","user":"541619e8e4b01498b1a719f9"},{"problem":63,"code":"(fn [f xs] \n  (reduce \n   (fn [m [y x]] (assoc m x (if (m x) (conj (m x) y) [y]))) \n   {} \n   (map #(vector % (f %)) xs)))","user":"54d03026e4b018d918be98de"},{"problem":63,"code":"(fn [f s]\n  (reduce #(update-in %1 [(f %2)] (comp vec conj) %2)\n          {} s))","user":"5f2d6787e4b033932238a66d"},{"problem":63,"code":"(fn foo [f coll]\n  (reduce #(assoc %1 (f %2) (conj (%1 (f %2) []) %2)) {} coll))","user":"507eed82e4b06ce648bcdbfe"},{"problem":63,"code":"(fn\n  [f s]\n  (apply merge (map #(hash-map (f (first %)) (apply vector %)) (partition-by f (sort-by f s)))))","user":"5aa2f1dee4b0d174b936c865"},{"problem":63,"code":"(fn [f coll]\n  (reduce\n   (fn [acc x]\n     (if-let [grp (get acc (f x))]\n       (assoc acc (f x) (conj grp x))\n       (assoc acc (f x) [x])))\n   {}\n   coll))","user":"5576f299e4b05c286339e077"},{"problem":63,"code":"(fn my-group-by\n  [f s]\n  (loop [[hd & tl] s ans {}]\n    (if (nil? hd)\n      ans\n      (let [res (f hd)]\n      \t(recur tl (assoc ans res (conj (get ans res []) hd)))\n      )\n    )\n  )\n)","user":"5f6b8222e4b02876ed9fd052"},{"code":"(fn [f s]\n  (let [m (partition 2 (interleave (map f s) s))]\n    (reduce (fn [res [k v]] (update-in res \n                                       [k] \n                                       concat \n                                       [v]))\n            {} \n            m)))","problem":63,"user":"5300f68de4b0d8b024fd3714"},{"problem":63,"code":"(fn [fun lst]\n  (into {} (map #(vector (fun (first %)) (vec %))\n                (partition-by fun (sort lst)))))","user":"56df62b3e4b0ca2494a095ef"},{"code":"(fn [f coll] \n  (apply merge-with concat \n              (map #(hash-map %1 [%2]) \n                   (map f coll) coll)))","problem":63,"user":"5097a95fe4b00ad8bab4e96e"},{"problem":63,"code":"(fn [f coll]\n  (reduce (fn [map x]\n            (let [k (f x) v (get map k)]\n              (if (nil? v)\n                (assoc map k [x])\n                (assoc map k (conj v x)))))\n          {}\n          coll ))","user":"55586905e4b0deb715856e2b"},{"code":"(fn [f s] (zipmap (distinct(map #(f %) s)) (for [x (distinct(map #(f %) s))] (filter #(= x (f %)) s))))","problem":63,"user":"5274eb56e4b03e8d9a4a74bb"},{"problem":63,"code":"(fn group-by-ms\n  [fnc coll]\n  (reduce (fn [mmap coll-item]\n            (if (contains? mmap (fnc coll-item))\n              (update-in mmap [(fnc coll-item)]\n                      (fn [_] (conj (mmap (fnc coll-item)) coll-item)))\n              (into mmap [[(fnc coll-item) [coll-item]]]))) {} coll))","user":"561ca6ebe4b064ca9f4b169c"},{"code":"(fn [f l] (reduce (fn [m i] (let [k (f i)] (assoc m k (conj (m k []) i)))) {} l))","problem":63,"user":"5392b849e4b0b51d73faaeb1"},{"problem":63,"code":"(fn [f v]\n  (apply merge-with concat \n         (map (fn [[k v]] {k [v]}) \n              (partition 2 (interleave (map f v) v)))))","user":"55d1ec3ee4b0e31453f64a4c"},{"problem":63,"code":"(fn g [f s]\n  (reduce (fn [r v] (let [add #((fnil conj []) % %2)]\n                      (update-in r [(f v)] add v))) {} s))","user":"5589a941e4b059ccff29b207"},{"code":"(fn [func seq]\n  (let [res (atom {})]\n    (doseq [i seq\n            :let [cur-res (func i)\n                  change-res #(swap! res assoc %1 %2)]]\n      (if (contains? @res cur-res)\n          (change-res cur-res (conj (@res cur-res) i) )\n          (change-res cur-res [i])))\n    @res))","problem":63,"user":"516081e7e4b009fba0926e28"},{"problem":63,"code":"(fn [f v]\n   (apply\n     (partial merge-with concat)\n     (map (fn [n] {(f n) [n]}) v)))","user":"54a11042e4b09f271ff37c49"},{"problem":63,"code":"(fn p [fun lst]\n  (apply merge-with concat\n    (for [x lst] {(fun x) (vector x)})))","user":"56fc1bc7e4b07572ad1a88dd"},{"problem":63,"code":"(fn  [f s]\n  (reduce (fn [acc item]\n            (println acc)\n            (let [r (f item)\n                  bucket (get acc r)\n                  new-vector (vec (conj bucket item))]\n              (println (str item \" -> \" r))\n              (println (str \"bucket \" bucket))\n              (assoc acc r new-vector))\n            )\n          {}\n          s))","user":"5885bea8e4b0f1effa3b76bf"},{"problem":63,"code":"(fn [f s]\n  (reduce #(merge-with into %1 (hash-map (f %2) [%2])) {} s)\n  )","user":"57a13745e4b0c3d858beb8e3"},{"code":"(fn [f sq]\n  (letfn [(blah [m v] \n    (let [k (f v)]\n      (assoc m k (conj (get m k []) v))))]\n    (reduce blah {} sq)))","problem":63,"user":"4f36f5f2e4b0e243712b1ece"},{"problem":63,"code":"(fn my-group-by [f coll]\n  (reduce #(assoc % (f %2) (conj (get % (f %2) []) %2)) {} coll)\n  )","user":"60471241e4b02d28681c77c9"},{"problem":63,"code":"(fn grpby [f s]\n  (reduce (fn [m i]\n            (let [k (f i)]\n              (assoc m k (vec (conj (get m k) i)))))\n          {}\n          s))","user":"55170dd9e4b06a49daca83bd"},{"problem":63,"code":"(fn [f, s]\n  (reduce (fn [acc v]\n                    (let [k (f v)]\n                      (if (contains? acc k)\n                        (update-in acc [k] #(conj % v))\n                        (assoc acc k [v]))))\n           {} s))","user":"5617a540e4b06b1bb2182a12"},{"code":"(fn gb [f s]\n  (reduce\n    (fn [m x] (let [k (f x), v (m k)] (assoc m k ((fnil conj []) v x))))\n    {} s))","problem":63,"user":"50d0d4c8e4b00b15ecee976a"},{"problem":63,"code":"(fn [f coll]\n  (let [xs (map vec (partition-by f (sort coll)))\n        kv (map f (map first xs))]\n    (into {} (map vector kv xs))))","user":"52d84ea7e4b09f7907dd1390"},{"problem":63,"code":"(fn [f c] (reduce #(let [k (f %2) t (hash-map k [%2])] (pr t) (merge-with concat %1 t)) {} c))","user":"57c7a8b5e4b05aa3c4741d09"},{"code":"(fn [f s]\n  (apply merge-with concat\n         (for [a s] {(f a) [a]})))","problem":63,"user":"50ef9a7ae4b0bdaecbb47d9e"},{"problem":63,"code":"(fn [f s]\n  (reduce (fn [m v]\n            (let [k (f v)]\n              (if-let [vs (get m k)]\n                (assoc m k (conj vs v))\n                (assoc m k (vector v)))))\n          {}\n          s))","user":"5edfb1e5e4b0c7845d86b107"},{"code":"(fn my-group-by [f s]\n  (loop [acc {}\n         c s]\n    (if (not (seq c))\n      acc\n      (let [h (first c)\n            r (f h)]\n        (if (contains? acc r)\n          (recur (assoc acc r (conj (acc r) h)) (rest c))\n          (recur (conj acc [r [h]]) (rest c)))))))","problem":63,"user":"4ee8b9c9535d93acb0a66884"},{"problem":63,"code":"(fn loo [f col]\n\t(reduce \n\t\t#(assoc \n\t\t\t%1 \n\t\t\t(f %2) \n\t\t\t(conj \n\t\t\t\t(get \n\t\t\t\t\t%1 \n\t\t\t\t\t(f %2)\n\t\t\t\t\t[])\n\t\t\t\t%2))\n\t\t{}\n\t\tcol)\n\t)","user":"51e8ee6be4b07cae92c04bfd"},{"code":"(fn [f xs]\n  (reduce #(assoc % (f %2) (conj (% (f %2) []) %2))\n          {}\n          xs))","problem":63,"user":"506ef8c3e4b09350ab4199f4"},{"code":"(fn [f s]\n  (apply merge-with\n    concat (map #(hash-map (f %) (vector %)) s)))","problem":63,"user":"4ec07699535dfed6da9c6da2"},{"problem":63,"code":"(fn grp [f s]\n\t(loop [ks (map f s) vs s out {}]\n\t\t(if (empty? ks)\n\t\t\tout\n\t\t\t(recur (rest ks) (rest vs) \n\t\t\t\t(assoc out (first ks) \n\t\t\t\t\t(concat (get out (first ks))[(first vs)])\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t)\n\t)","user":"5545477fe4b0a04f79299531"},{"problem":63,"code":"(fn [ff cc] (reduce (fn [h [k v]] (let [ss (get h k)] (if ss (conj h {k (conj ss v)}) (conj h {k [v]})))) {} (map vector (map ff cc) cc)))","user":"549a176ce4b0f3d1d8e70f69"},{"problem":63,"code":"(fn [f xs] (reduce #(update-in %1 [(f %2)] (fn [x]  ((fnil conj []) x %2) )) {} xs))","user":"5e9154c1e4b0cb0169546354"},{"code":"(fn [f coll]\n  (let [keys (map f coll)]\n    (reduce merge\n      (for [k keys]\n        {k (filter #(= k (f %)) coll)}))))","problem":63,"user":"505aa653e4b021387fb89857"},{"problem":63,"code":"(fn testing [f c]\n  (reduce (fn [outs x]\n            (assoc outs (f x)\n              (conj (get outs (f x) []) x))) {} c))","user":"577bcbd9e4b0d3393e5deb1b"},{"code":"(fn [f l] (reduce #(update-in % [(f %2)] (fnil conj []) %2) {} l))","problem":63,"user":"4e82f85d535db62dc21a62ce"},{"problem":63,"code":"(fn my-group-by [f coll]\n  (letfn [(mgb [ret coll]\n            (if (empty? coll)\n              ret\n              (let [val (first coll)\n                    key (f val)\n                    retvec (get ret key [])]\n                (mgb (assoc ret key (conj retvec val))\n                     (rest coll)))))]\n    (mgb {} coll)))","user":"571d063ee4b0145328a76272"},{"code":"(fn [f coll]\n     (apply  merge-with concat \n\t\t  (for [x coll]\n\t\t       {(f x) [x]})))","problem":63,"user":"4f4ec77ae4b03ad3f0c10cd0"},{"problem":63,"code":"(fn map-vals [f vals]\n  (if (empty? vals)\n    {}\n    (assoc\n     (map-vals f (rest vals))\n     (f (first vals))\n     (conj\n      ((map-vals f (rest vals))\n       (f (first vals))\n       '())\n      (first vals)))))","user":"54d26316e4b0e8a36923e5f2"},{"problem":63,"code":"(fn group-seq [pred sequen]\n    (loop [resp {}\n           sequen sequen]\n        (if-let [value (first sequen)]\n            (let [k  (pred value)]\n                (recur\n                    (assoc resp k (conj (get resp k []) value))\n                    (rest sequen)))\n            resp)\n        ))","user":"552bd5c2e4b0ffed3738f969"},{"problem":63,"code":"(fn [f col]\n    (reduce\n      #(assoc % (f %2) (conj (% (f %2) []) %2))\n      {}\n      col))","user":"5a00cb31e4b01bb0ae8afd36"},{"problem":63,"code":"(fn [f arr]\n    (apply merge-with into\n      (reduce\n        (fn [r v]\n          (conj r {(f v) [v]})\n        )\n        []\n        arr\n      )\n    )\n  )","user":"5e2586afe4b05b4b01516167"},{"problem":63,"code":"(fn problem63 [f coll]\n  (loop [coll coll\n         result {}]\n    (if (seq coll)\n      (let [key (f (first coll))]\n        (recur\n         (rest coll)\n         (assoc result key (conj (vec (get result key)) (first coll)))))\n      result)))","user":"54d0cedde4b0e8a36923e5d2"},{"problem":63,"code":"(fn [f s]\r\n  (reduce\r\n    (fn [r a] \r\n      (assoc r (f a) (conj (get r (f a) []) a)))\r\n    {}\r\n    s))","user":"5470699ae4b00cfc9eacc1b6"},{"problem":63,"code":"(fn my-group-by [f coll]\n  (let [m (map #(sorted-map (f %) [%]) coll)]\n    (apply merge-with into m)))","user":"54ae541ae4b09f271ff37cef"},{"problem":63,"code":"(fn \n  [f coll]  \n  (persistent!\n   (reduce\n    (fn [ret x]\n      (let [k (f x)]\n        (assoc! ret k (conj (get ret k []) x))))\n    (transient {}) coll)))","user":"536ecd9fe4b0fc7073fd6e76"},{"problem":63,"code":"(fn [f s]\n   (reduce (fn [col val]\n    (update-in col [(f val)] (fnil conj []) val)) {} s))","user":"5e5349ebe4b027a2e10ac0e2"},{"problem":63,"code":"#(apply merge-with into (map (fn[x] (hash-map (% x) [x])) %2))","user":"5964c614e4b069c0a1a19770"},{"code":"(fn groupby [f s]\n  (apply merge-with concat\n    (map (fn [x] (apply assoc {} x)) (partition 2 (interleave (map f s) (map (fn [x] [x]) s) )))))\n\n;(fn groupby [f s]\n;  (apply merge-with concat\n;    (for [x s] { (f x) [x] })))\n; this will also work but I had to make it mega-complicated first :)","problem":63,"user":"525aa499e4b0cb4875a45cf7"},{"code":"(fn f [g s]\n  (if (seq s)\n    (let [x (g (first s))\n          m (f g (rest s))]\n      (conj m [x (cons (first s) (get m x ()))]))\n    {}))","problem":63,"user":"51256b40e4b05d10e3e395f8"},{"code":"(fn [f s] (reduce (partial merge-with (comp vec concat)) (map (fn [x y] {x [y]}) (map f s) s)))","problem":63,"user":"52199105e4b0c4ef0be82ff9"},{"code":"(fn mygb [f s]\r\n  (let [vals (set (map f s))]\r\n    (zipmap vals (map (fn [x] (filter (fn [y] (= x (f y))) s)) vals))))","problem":63,"user":"4e14108c535d04ed9115e7dd"},{"code":"(fn [f coll]\n  (loop [m {}\n               c coll\n               it (first c)]\n          (if (nil? it)\n            m\n            (recur (assoc m (f it) (conj (if (get m (f it)) (get m (f it)) []) it)) (next c) (first (next c))))))","problem":63,"user":"52efd3d9e4b05e3f0be25ed4"},{"code":"#(reduce (fn [a v]\n            (let [result (%1 v)\n                  existing (a result [])]\n              (conj a [result (conj existing v)])))\n          {} %2)","problem":63,"user":"4ee868be535d93acb0a6687d"},{"problem":63,"code":"(fn [f s]\n  (loop [s s, m {}]\n    (if (seq s)\n      (let [k (f (first s))]\n        (if-let [v (get m k)]\n          (recur (rest s) (assoc m k (conj v (first s))))\n          (recur (rest s) (assoc m k [(first s)]))))\n      m)))","user":"54ca93abe4b057c6fda3a264"},{"problem":63,"code":"(fn group-by* [f xs]\n  (reduce (fn [acc x]\n            (update-in acc [(f x)] (fnil conj []) x)) {} xs))","user":"56175cf9e4b06b1bb2182a0f"},{"problem":63,"code":"(fn fun [f s]\n  (reduce (fn [x1 x2]\n            (let [searchKey (f x2)\n              newValue (conj (get x1 searchKey []) x2)]\n              (assoc x1 searchKey newValue)\n            )             \n          ) {} s)\n)","user":"5da20e73e4b000c986472be1"},{"problem":63,"code":"#(reduce (fn [m v] (let [k (% v)] (assoc m k (conj (m k []) v)))) {} %2)\n;(fn [f s] (apply merge-with concat (map #(hash-map (f %) [%]) s)))","user":"54e1939ce4b024c67c0cf7c5"},{"problem":63,"code":"(fn [f s] (reduce (fn [answer processme] \n                           (into answer {(f processme) (concat (get answer (f processme)) [processme])}))\n                         {} s )\n                         \n)","user":"542baf7ce4b0dad94371f291"},{"code":"(fn [f s]\n  (let [a ((fn h [m v]\n  \t\t\t    (if (empty? v)\n\t\t\t\t      m\n\t\t\t\t      (h (update-in m [(get (first v) 0)] conj (get (first v) 1)) (rest v))))\n\t\t\t\t    {} (map #(vector (f %) %) s))] (reduce #(update-in % [%2] (fn [x] (vec (reverse x)))) a (keys a))))","problem":63,"user":"507ef25ce4b0f753b6f9788e"},{"problem":63,"code":"(fn [f ds]\n  (loop [r {}\n         ds' ds]\n    (if (empty? ds')\n      r\n      (recur (update-in r\n                        [(f (first ds'))]\n                        #(conj (into [] %) (first ds')))\n             (rest ds')))))","user":"57aa4775e4b0b8559636fc6b"},{"code":"(fn my-group-by [pred coll]\r\n  (reduce\r\n    (fn [dict m]\r\n      (let [ret (pred m)]\r\n        (assoc dict ret (conj (or (dict ret) []) m))))\r\n    {} coll))","problem":63,"user":"4df669d4535d08e6dec9fe35"},{"problem":63,"code":"(fn my-group-by [f coll]\n  (reduce \n   #(let [k (first %2)\n          v (second %2)\n          {a k, :or {a []}} %1] \n      (conj %1 [k (conj a v)])) \n   {} \n   (map #(vector (f %) %) coll)))","user":"5606ea56e4b08b23635d317b"},{"problem":63,"code":"(fn [f xs]\n  (let [conj* (fnil conj [])]\n    (reduce (fn [acc x]\n              (update-in acc [(f x)] #(conj* % x)))\n            {} xs)))","user":"5adf5f9be4b0837691e92c33"},{"problem":63,"code":"(fn [f xs]\n  (reduce #(assoc-in %1\n                     [(f %2)]\n                     (conj (get %1 (f %2) []) %2))\n          {} xs))","user":"560ae7e6e4b05f002753df0e"},{"problem":63,"code":"(fn [f xs]\n    (loop [m {} xs xs]\n      (if (empty? xs)\n        m\n        (let [val (f (first xs))]\n          (let [v (get m val [])]\n            (recur (assoc m val (conj v (first xs)))\n                   (rest xs))\n              )))))","user":"58b81490e4b0ebc645576d8c"},{"problem":63,"code":"(fn [f s]\n    (apply merge-with into (map (fn [x] {(f x) [x]}) s))\n  )","user":"56bff105e4b060a8e693e3a4"},{"code":"(fn [f coll]\n  (reduce #(update-in %1 \n                      [(f %2)]\n                      (fnil conj [])\n                      %2) {} coll))","problem":63,"user":"527b9beee4b03e8d9a4a7590"},{"problem":63,"code":"(fn [f s]\n        (reduce\n         (fn [acc x]\n           (let [fx (f x)]\n             ;; no update :(\n             (assoc acc fx (into [] (conj (get acc fx) x)))))\n         {}\n         s))","user":"55d50a38e4b0e31453f64a80"},{"code":"(fn [f seq]\n  (apply merge-with into (map #(assoc {} (f (first %)) (vec %)) (partition-by f seq))))","problem":63,"user":"524cdd51e4b0752c4cb68ccc"},{"problem":63,"code":"(fn g-by [f coll]\n   (loop [coll coll\n          acc {}]\n     (if (empty? coll)\n       acc\n       (let [k (f (first coll))]\n         (recur (rest coll) (assoc acc k (conj (get acc k []) (first coll))))\n         )\n       )\n     )\n   )","user":"5245e320e4b09dbe66b56177"},{"code":"(fn [f c]\n  (loop [ic (interleave (map f c) c)\n         hc (take 2 ic)\n         outc {}]\n    (if (= 0 (count ic))\n      outc\n      (recur (drop 2 ic) (take 2 (drop 2 ic)) (if (contains? outc (nth hc 0))\n                                                (assoc outc (nth hc 0) (conj (get outc (nth hc 0)) (nth hc 1)))\n                                                (assoc outc (nth hc 0) [(nth hc 1)])\n                                              )\n      )\n    )\n  )\n)","problem":63,"user":"52117ea7e4b07aea8afc4f70"},{"code":"(fn gs [f coll]\n  (reduce (fn [m v]\n            (assoc m (f v) (conj (m (f v) []) v))) {} coll))","problem":63,"user":"4e6f1b7a535d5021c1a89618"},{"problem":63,"code":"(fn group-a-sequence [f xs]\n  (let [rs (set (map f xs))]\n   (->> (map (fn [r] (filter #(= r (f %)) xs)) rs)\n        (zipmap rs))))","user":"52616198e4b03e8d9a4a705e"},{"problem":63,"code":"(fn [f l] (reduce (fn [one two] (assoc one (f two) (into [] (conj (get one (f two)) two)))) {} l))","user":"55b22c33e4b0da326a65cf79"},{"problem":63,"code":"(fn [f s]\n  (reduce #(let [r (f %2)]\n             (assoc %1 r (conj (get %1 r []) %2))) {} s))","user":"53d5a63be4b0e771c3025449"},{"code":"(fn [f col]\n  (reduce \n    #(let [k (f %2)](assoc %1 k (conj (vec (%1 k)) %2)))\n        {} col))","problem":63,"user":"4db2cc55535df7e46ed9b6c5"},{"problem":63,"code":"(fn [f ll] (loop [r {} l ll] (if (empty? l) r (recur (merge-with concat r {(f (first l)) (list (first l))}) (rest l)))))","user":"5149c2f1e4b0829bd132edb0"},{"code":"(fn [f s] (apply merge-with concat (map (fn [x] {(f x) [x]}) s)))","problem":63,"user":"4f12ab23535d64f603146429"},{"problem":63,"code":"(fn [f xs] \n  (reduce (fn [acc x] \n            (update-in acc [(f x)] (fnil #(conj % x) []))) \n          {} \n          xs))","user":"526e5159e4b03e8d9a4a7316"},{"problem":63,"code":"(fn [p s]\n    (let [add-to-map \n          #(let [key (first %2) existing (% key)]\n             (conj % [key (conj (if existing existing []) (second %2))]))\n          ]\n      (reduce add-to-map {} (map (fn [elem] (vector (p elem) elem)) s ))))","user":"5627444fe4b00e49c7cb47cd"},{"code":"(fn [f seq]\n   (apply assoc {}\n      (apply concat\n         (for [k (set (map f seq))]\n            [k (vec (filter #(= k (f %)) seq))]))))","problem":63,"user":"4fe87e56e4b07c9f6fd12c40"},{"problem":63,"code":"#(reduce (fn [m x]\n            (let [k (%1 x)]\n              (assoc m k (conj (get m k []) x))))\n          {}\n          %2)","user":"5617db88e4b06b1bb2182a16"},{"problem":63,"code":"(fn [f mapa] (reduce #(if (contains? %1 (f %2)) (update-in %1 [(f %2)] conj %2) (assoc %1 (f %2) [%2]))  {} mapa))","user":"54e4edcae4b024c67c0cf7f3"},{"problem":63,"code":"(fn [f s]\n   (reduce #(merge-with into %1 {(f %2) [%2]}) {} s))","user":"5ab23c99e4b073f1774425e2"},{"code":"(fn [f d] (reduce (fn [c e] (assoc c (f e) (conj (get c (f e) []) e))) {} d))","problem":63,"user":"51f2851fe4b0210f90e7454b"},{"problem":63,"code":"(fn [f coll] \n  (reduce \n    (fn [m x] \n      (assoc m (f x) \n        (conj (get m (f x) []) x))) {} coll))","user":"4df73d64535d04ed9115e775"},{"problem":63,"code":"(fn f [a b]\n  (loop [b1 b acc {}]\n    (if (empty? b1)\n      acc\n      (let [b1f (first b1),\n            b1r (rest b1),\n            k (a b1f),\n            old-v (get acc k [])]\n        (recur b1r (assoc acc k (conj old-v b1f)))\n      )\n    )\n  )\n)","user":"55280930e4b0ffed3738f93b"},{"problem":63,"code":"(fn [a b]\n\t(into {} (map\n\t\t#(vector (a (first %)) (vec %))\n\t\t(partition-by a (sort b))\n\t))\n)","user":"5710e574e4b09c608db7043b"},{"code":"(fn [fun items] \n    (reduce \n        (fn [map item]\n            (let [key (fun item)\n                  vals (get map key [])]\n                (assoc map key (conj vals item))))\n        {} \n        items))","problem":63,"user":"51059d33e4b0380e797c7d5c"},{"code":"(fn [f s]\n  (reduce\n    #(assoc %1 (first %2) (conj  (get %1 (first %2) []) (fnext %2) )) {}\n\n    (map #(vector (f %) %) s) ))","problem":63,"user":"5099283ce4b0cae2931060af"},{"code":"(fn[f c] \n   (let [v (distinct (map f c))]\n     (zipmap v (for [i v] (filter #(= i (f %)) c)))))","problem":63,"user":"5093ca51e4b097f48cc38585"},{"code":"(fn [f s]\n     (reduce #(merge-with into %1 {(f %2) [%2]}) {} s))","problem":63,"user":"50431cbce4b034ff00315d1c"},{"code":"#(reduce (fn [r e] (merge-with concat r {(%1 e) [e]})) {} %2)","problem":63,"user":"50d4593ee4b09cc622d65a68"},{"code":"(fn [f s] (reduce #(update-in % [(f %2)] (comp vec conj) %2) {} s))","problem":63,"user":"4eb97b2e535dfed6da9c6d54"},{"code":"(fn [f coll] (loop [result {} vs coll]\n               (if (nil? vs) result\n                 (let [this (first vs)\n                       that (next vs)\n                       this-key (f this)]\n                   (if (result this-key)\n                     (recur (assoc result this-key (conj (result this-key) this)) that)\n                     (recur (assoc result this-key [this]) that)\n                   )\n                 )\n               )\n             )\n)","problem":63,"user":"526dd90de4b03e8d9a4a72fe"},{"problem":63,"code":"(fn [f coll](apply merge-with into (map (fn [k v] {k [v]}) (map f coll) coll)))","user":"602049b8e4b0bf4ca6b10961"},{"code":"(fn [test-fn items]\n    (let [items-with-values (reduce #(conj %1 (hash-map %2 (test-fn %2))) {} items)]\n      (reduce #(assoc %1 \n                     (val %2)\n                     (conj (get %1 (val %2)) (key %2))) \n              {} \n              items-with-values)))","problem":63,"user":"52af7a5ce4b0c58976d9acbd"},{"problem":63,"code":"(fn sk-group-by [f xs]\n  (->> xs\n       (map (fn [x] {(f x) (vector x)}))\n       (reduce (fn [a b] (merge-with concat a b)))\n       ))","user":"51d42f44e4b013d740b70ddb"},{"problem":63,"code":"(fn [opt values]\n  (into {} (map #(vector (opt (first %)) (vec %))\n                (partition-by opt (sort values)))))","user":"5d2c779be4b01671435dbc8d"},{"problem":63,"code":"(fn my-group-by [f cols] \n  (reduce #(assoc %1 (f %2) (apply vector (conj (get %1 (f %2)) %2))) {} cols))","user":"560d4994e4b05f002753df3c"},{"problem":63,"code":"(fn [f values]\n  (loop [[current & remainder :as to-process] values\n         result {}]\n    (if (empty? to-process)\n      result\n      (let [current-key (f current)\n            key-values (or (result current-key) [])]\n        (recur \n         remainder\n         (assoc result current-key (conj key-values current)))))))","user":"55d06bcbe4b0e31453f64a3a"},{"problem":63,"code":"(fn [f sq] (reduce (fn [accum k] (assoc accum (f k) (cons k (accum (f k))))) {} (reverse sq)))","user":"55b527cbe4b01b9910ae2985"},{"problem":63,"code":"(fn [ f s]\n  (letfn [\n           (mrg [m v] (update-in m [(f v)] (fnil #(conj % v) [] )))\n         ]\n    (reduce mrg {} s)))","user":"54d6f22de4b0a52adc2e2023"},{"problem":63,"code":"(fn [f seq] (reduce #(assoc % (f %2) (conj (get % (f %2) []) %2)) {} seq))","user":"5589e88ae4b0277789237610"},{"code":"(fn [m f [e & r]] \n    (if (nil? e)\n        m\n        (recur (assoc m (f e) (conj (m (f e) []) e)) f r))) {}","problem":63,"user":"51f59607e4b0abb92f97f9d5"},{"problem":63,"code":"(fn group-a-seq\n  [f seq]\n  (reduce (fn [m item]\n            (assoc m (f item) (into [] (conj (get m (f item)) item)))) {} seq))","user":"60396c95e4b0d5df2af222f4"},{"problem":63,"code":"(fn [f coll]\n    (reduce (fn [out v]\n                (merge-with concat out {(f v) [v]}))\n            nil coll))","user":"53e4b5a3e4b036ad0777e44b"},{"problem":63,"code":"(fn [pred xs]\n  (reduce (fn [m v]\n            (let [m-key (pred v)]\n              (update-in m [m-key] (fnil conj []) v)))\n          {}\n          xs))","user":"5d47fa13e4b07c84aa5ae6b6"},{"problem":63,"code":"(fn [f s] (reduce #(assoc % (f %2) (concat (get % (f %2)) (vector %2))) {} s))","user":"57e2e1bde4b0bfb2137f5a8f"},{"problem":63,"code":"(fn [f xs]\n  (loop [xs xs acc {}]\n    (let [x (first xs)]\n      (if x\n        (let [fx (f x)\n              v (acc fx)]\n          (recur (next xs) \n                 (assoc acc fx (if v (conj v x) (vector x)))))\n        acc))))","user":"4f4e78fee4b03ad3f0c10cc8"},{"problem":63,"code":"(fn [f coll]\n  (reduce (fn [acc el]\n            (let [key (f el)] \n              (assoc acc key (conj (get acc key []) el))))\n          {} coll))","user":"4fc5eb7fe4b0ee37620e1803"},{"code":"#(apply merge-with into (for [v %2] {(% v) [v]}))","problem":63,"user":"5032b066e4b00c0952a257ea"},{"code":"(fn [f lst] \n  (reduce \n    (fn [m e] (update-in m [(f e)] #(conj (or % []) e)))\n    {}\n    lst))","problem":63,"user":"4ee528fb535d1385b2869d87"},{"code":"(fn my-group-by [f s]\n  (loop [s s m {}]\n    (if (empty? s) m\n      (let [x (first s) k (f x)] \n        (recur \n          (rest s)\n          (assoc m k (conj (get m k []) x)))))))","problem":63,"user":"4ed188c8535d44c135fd68cf"},{"code":"(fn [f s] \n  (reduce #(let [k (f %2)] \n     (assoc %1 k (conj (get %1 k []) %2))) {} s))","problem":63,"user":"5009fd0ae4b03d00572d2d70"},{"problem":63,"code":"(fn [f coll]\n  (loop [f f\n         coll coll\n         acc {}]\n    (cond\n     (empty? coll) acc\n     (contains? acc (f (first coll))) (recur \n                                       f\n                                       (rest coll)\n                                       (assoc acc (f (first coll)) (conj (get acc (f (first coll))) (first coll))))\n     :else (recur\n            f\n            (rest coll)\n            (assoc acc (f (first coll)) [(first coll)])))))","user":"571cd9dce4b0145328a76271"},{"problem":63,"code":"(fn [x y] (reduce #(assoc %1 (x (first %2)) %2) {} (partition-by x (sort-by x y))))","user":"53c74cfce4b00fb29b2212a7"},{"problem":63,"code":"(fn my-group-by\n  [f coll]\n  (loop [retmap {}\n         coll-p coll]\n    (if (empty? coll-p)\n      retmap\n      (recur (let [value (first coll-p)\n                   keyvalue (f value)]\n               (if (contains? retmap keyvalue)\n                 (update-in retmap [keyvalue] conj value)\n                 (assoc retmap keyvalue (vector value)))) (rest coll-p)))))","user":"506f0968e4b09350ab4199f5"},{"code":"(fn [f l]\n  (reduce\n    (fn [s v]\n      (let [k (f v)]\n        (assoc s k (cons v (get s k '())))))\n    {} (reverse l)))","problem":63,"user":"4ff5744ae4b0678c553fc36a"},{"code":"(fn\n  [f coll]\n  (persistent!\n    (reduce\n      (fn [ret x]\n        (let [k (f x)]\n          (assoc! ret k (conj (get ret k []) x))))\n      (transient {}) coll)))","problem":63,"user":"4f18677d535d64f603146459"},{"problem":63,"code":"(fn grp-by [f s]\n  (reduce (fn [m el]\n            (update-in m [(first el)] #(if (nil? %) (second el) (into % (second el)))))\n          {}\n          (partition 2 (interleave (map f s) (map #(conj [] %) s)))))","user":"57a9e274e4b0b8559636fc5d"},{"code":"(fn [g s]\n  (reduce #(assoc % (g %2) (conj (% (g %2) []) %2)) {} s))","problem":63,"user":"4ea0cfb0535d7eef308072ae"},{"problem":63,"code":"(fn [f coll]\n  (reduce\n     (fn [m elem]\n       (let [k (f elem)]\n         (assoc m k (conj (get m k []) elem))))\n     {} coll))","user":"5d2bfb68e4b01671435dbc86"},{"code":"(fn [f coll]\n  (reduce\n   (fn [m x]\n     (let [result (f x)]\n       (if (contains? m result)\n         (assoc m result (conj (m result) x))\n         (assoc m result [x])))) {} coll))","problem":63,"user":"51d08d67e4b067c365486351"},{"code":"(fn [f coll]\n  (reduce (fn [res itm] (assoc res (f itm) (concat (res (f itm)) [itm]))) {} coll))","problem":63,"user":"538e864ee4b0b51d73faae87"},{"code":"(fn [f x] (reduce #(let [y (f %2)] (assoc % y (conj (or (% y) []) %2))) {} x))","problem":63,"user":"4e71da4d535d5021c1a89653"},{"problem":63,"code":"#(apply merge-with into (for [i %2] {(% i) [i]}))","user":"56efb3a3e4b04a395b9a0463"},{"code":"(fn [f c] \n  (reduce \n   #(let [key (f %2)\n          map %1\n          value %2] \n       (assoc map key (concat (map key) (vector value))))\n   {} c))","problem":63,"user":"4e58ef07535d8a8b8723a299"},{"problem":63,"code":"(fn [f coll] \n  (let [s (set (map f coll))]\n    (zipmap s\n            (map #(vec \n                   (filter (fn [x] (= % (f x)))\n                           coll))\n                 s))))","user":"57dd47f4e4b0bd073c20243e"},{"problem":63,"code":"(fn [f c]\n  (reduce\n   (fn [m e]\n     (assoc m\n       (f e)\n       (conj (or (m (f e)) []) e)))\n   {}\n   c))","user":"5881d1c2e4b0f1effa3b7644"},{"problem":63,"code":"(fn [f xs] (reduce (fn [r x] (let [k (f x)\n                                    v (or (r k) [])\n                                    v (conj v x)]\n                                (assoc r k v))) {} xs))","user":"56dc3bdfe4b0ea9b8538f819"},{"code":"#(apply merge-with concat (map (fn [a] {(% a) [a]}) %2))","problem":63,"user":"50ae0d24e4b0a40c9cfb08ce"},{"problem":63,"code":"(fn [f s] \n  (reduce (fn [r e] \n            (let [k (f e)\n                  v (or (r k) [])]\n              (assoc r k (conj v e))))\n            {} s))","user":"57c94c54e4b05aa3c4741d2c"},{"code":"(fn [f inputs]\n (reduce (fn [acc val] \n   (let [result (f val)\n         priorVec (acc result [])\n         newVec (conj priorVec val)]\n     (assoc acc result newVec))) {} inputs)\n)","problem":63,"user":"4ebad797535dfed6da9c6d6a"},{"problem":63,"code":"(fn [f coll] (apply merge-with into (map (fn [x] {(f x) [x]}) coll )))","user":"5baaae06e4b0a20761a23464"},{"problem":63,"code":"(fn [f v]\n  (reduce\n   #(update-in %1 [(f %2)] (comp vec conj) %2)\n   {}\n   v))","user":"55c652dde4b0e31453f649bd"},{"code":"(partial (fn my-group [xs func coll]\n  (if (empty? coll)\n    xs\n    (let [x (first coll)\n          ele (xs (func x))]\n      (if (nil? ele)\n        (my-group (assoc xs (func x) [x]) func (rest coll))\n        (my-group (assoc xs (func x) (conj ele x)) func (rest coll)))))) {})","problem":63,"user":"523f1245e4b01c266ffa7f95"},{"problem":63,"code":"( fn[f a]( reduce #( assoc % (f %2) (into [] (conj (% (f %2) ) %2  ) ) ) {} a ) )","user":"54fc7d89e4b07d26eda61d2b"},{"code":"(fn [f xs]\n  (reduce #(let [k (f %2)]\n             (if (contains? % k)\n               (update-in % [k] conj %2)\n               (assoc % k [%2])))\n          {} xs))","problem":63,"user":"4e71a12c535d5021c1a8964f"},{"problem":63,"code":"(fn [p s] (apply merge-with concat (map #(hash-map (p %) [%]) s)))","user":"5e3e23d9e4b01d43a70e8e20"},{"code":"(fn group-by* [f coll]\n  (reduce #(let [k (f %2)]\n             (assoc %1 k (conj (%1 k []) %2)))\n          {}\n          coll))","problem":63,"user":"52ab6de1e4b0c58976d9ac78"},{"problem":63,"code":"(fn [f s] (reduce #(let [key (f %2) value (or (get %1 key) [])] (assoc %1 key (conj value %2))) {} s))","user":"566669d8e4b0e91d5f5c566f"},{"problem":63,"code":"(fn [f xs]\n (let [keys_ (distinct (map f xs))\n       grouped-xs (map (fn [k] [k (filter #(= k (f %)) xs)]) keys_)]\n  (apply hash-map (mapcat identity grouped-xs))))","user":"59d4d126e4b0ef0a1e9b5be9"},{"problem":63,"code":"(fn [f xs] (reduce #(let [k (f %2) v (%1 k [])] (assoc %1 k (conj v %2))) {} xs))","user":"5a67cedbe4b0512ff01cd9ee"},{"problem":63,"code":"(fn [f s]\n  (reduce\n         (fn [z h]\n             (let [v (f h)\n                   zv (get z v)]\n                 (assoc z v (if zv\n                                (conj zv h)\n                                [h]))))\n           {}\n           s))","user":"5b15811ee4b0cc2b61a3be6f"},{"problem":63,"code":"(fn test2\n  [f s]\n  (reduce (fn [m v]\n            (let [k (f v)]\n              (update-in m [k] (fnil conj []) v)))\n          {} s))","user":"59afe4bae4b0e1f4e384c8c0"},{"code":"(fn my-group-by [f s]\r\n  (loop [s s\r\n         result {}]\r\n    (if (empty? s)\r\n      result\r\n      (recur (rest s)\r\n             (let [ffs (f (first s))]\r\n               (assoc result ffs (conj (get result ffs []) (first s))))))))","problem":63,"user":"4fe54ee8e4b0e8f79898fec3"},{"code":"#(apply merge-with concat (for [x %2] {(%1 x) [x]}))","problem":63,"user":"50166470e4b052339a490e76"},{"problem":63,"code":"(fn groupy [f xs]\n  (reduce\n   (fn [memo [key next-value]]\n     (let [value (memo key [])]\n       (assoc memo key (conj value next-value))))\n   {}\n   (map vector (map f xs) xs)))","user":"5980f91ae4b021a7a535fddd"},{"problem":63,"code":"(fn q63 [f s]\n  (let [reducer (fn [result value]\n                  (let [k (f value)\n                        prev (result k)]\n                    (cond\n                      (nil? prev) (assoc result k [value])\n                      :else (assoc result k (conj prev value)))))]\n    (reduce reducer {} s)))","user":"5cab0ad9e4b048ec896c5c46"},{"problem":63,"code":"(fn my-group-by [f coll]\n  (apply merge-with concat\n         (map (fn [item]\n                (hash-map (f item) [item]))\n              coll)))","user":"58ed713de4b056aecfd47d84"},{"problem":63,"code":"#(->> (map (fn [x] [(%1 x) x]) %2)\n      (sort-by first)\n      (partition-by first)\n      (map (fn [group]\n             [(ffirst group) (mapv second group)]))\n      (into {}))","user":"5b759ca8e4b047b03b2036d0"},{"problem":63,"code":"(fn mgrp [mfn coll]                                                                                                                                                                                   \n  (reduce (fn [rcol vall]                                                                                                                                                                                   \n            ( merge-with concat rcol {(mfn vall) [vall] })) {} coll ))","user":"5804b491e4b0a837a8b30cac"},{"problem":63,"code":"#(reduce (fn [c v] (let [k (% v)] (assoc c k (conj (or (get c k) []) v)))) {} %2)","user":"5499e23de4b03163384f4706"},{"code":"#(reduce \n  (fn [m [v e]] (assoc m v (conj (or (m v) []) e)))\n  {} \n  (map (fn [x] [(% x) x]) %2))","problem":63,"user":"4fbfe9a4e4b081705acca31f"},{"problem":63,"code":"(fn [fun lst]\n  (zipmap\n   (distinct (map fun lst))\n   (for \n     [x (distinct (map fun lst))]\n     (filter #(= x (fun %)) lst)\n     )\n   )\n  )","user":"5b5e5019e4b0c6492753e6d3"},{"problem":63,"code":"(fn [f s]\n  (apply merge-with (comp vec concat)\n         (map #(hash-map (f %) [%]) s)))","user":"55995fa7e4b031d6649c9ba9"},{"code":"(fn [f s]\n  (reduce (fn [acc val]\n            (let [key (f val)]\n              (assoc acc key (conj (acc key []) val))))\n          {}\n          s))","problem":63,"user":"51789dfae4b03d69594194d7"},{"problem":63,"code":"(fn [f coll] (apply merge-with concat (map (fn [x] {(f x) [x]}) coll)))","user":"5462ce20e4b01be26fd746b8"},{"code":"(fn [f s]\n  (letfn [ (add-x [m x] \n               (assoc m (f x) (conj (m (f x) []) x))) ]               \n    (reduce add-x {} s)))","problem":63,"user":"4e860e85535db62dc21a62f1"},{"problem":63,"code":"(fn [f s ]\n  \n  (reduce (fn [prev cur] \n            \n            (merge-with into prev {(f cur) [cur]} )\n            \n            ) {} s)\n  \n  )","user":"5ff676a9e4b06df49cee1497"},{"problem":63,"code":"(fn [f coll]\n\n  (let [x (fn [c a] (assoc c (f a) (conj (get c (f a) []) a)))]\n\n    (reduce x {} coll)))","user":"583667c7e4b089d5ab817cfb"},{"problem":63,"code":"(fn \n  [f xs]\n    (reduce #(update-in %1 [(f %2)] (fnil conj []) %2) {} xs))","user":"56743413e4b05957ce8c612e"},{"problem":63,"code":"(fn [f s] (into {} (map #(vector (f (first % )) (vec %)) (partition-by f (sort s)))))","user":"5ce52271e4b0a17bb84e2b69"},{"problem":63,"code":"(fn my-group-by\n  [f sq]\n  (let [\n        fsq (map #(vector (f %) %) sq)\n        my-vector (fn [acc elem] (cond\n                                   (nil? acc) [elem]\n                                   (vector? acc) (conj acc elem)\n                                   :else [acc elem]))\n        reductor (fn [mp [key val]]\n                   (conj mp [key (my-vector (mp key) val)]))]\n    (reduce reductor {} fsq)))","user":"588e4e05e4b00487982d5188"},{"problem":63,"code":"(fn group-seq\n  [key-fn xs]\n  (reduce #(let [key (key-fn %2)]\n             (assoc %1 key (conj (get %1 key []) %2)))\n          {}\n          xs))","user":"5f37263de4b0574c87022c4e"},{"code":"(fn [x y]\n     (let [m (map x y)\n\t\tn (map vector y)]\n\t\t(loop [m m n n result {}]\n\t\t   (if (empty? n)\n\t\t       result\n\t\t       (recur (rest m) (rest n) (if (contains? result (first m))\n\t\t\t\t  (merge-with concat result (hash-map (first m) (first n)))\n\t\t\t\t  (into result (hash-map (first m) (first n)))))))))","problem":63,"user":"4f066916535dcb61093f6c10"},{"code":"(fn r\n  ([f xs]\n     (r f xs {}))\n  ([f xs m]\n     (if (empty? xs)\n       m\n       (let [k (f (first xs))]\n         (r\n          f\n          (rest xs)\n          (merge\n           m\n           {k (if (contains? m k) (conj (m k) (first xs)) [(first xs)])}))))))","problem":63,"user":"4fb510b5e4b081705acca2b8"},{"problem":63,"code":"(fn [f coll]\n  (apply merge-with into (for [x coll]\n                           {(f x) [x]})))","user":"58e58ae9e4b056aecfd47c9a"},{"code":"(fn [f c]\n  (reduce #(assoc % (f %2) (conj (% (f %2) []) %2)) {} c))","problem":63,"user":"509b89b3e4b03049c49bd678"},{"code":"(fn [pred coll]\n  (reduce (fn [acc v] \n            (merge-with into acc {(pred v) [v]}))\n          {} coll))","problem":63,"user":"5046ee3ee4b03b02161376b4"},{"code":"(fn [f arg] \n  (reduce \n  #(assoc % (first %2) \n      (vec (conj \n       (get % (first %2))\n            (second %2))))\n  (cons {} (map (fn [x] [(f x) x]) arg))))","problem":63,"user":"50e7dd5de4b077ad597af36b"},{"code":"(fn t [f coll] \n  (reduce\n      (fn [m [k v]] (assoc m k (concat (m k) [v]))) {} (map #(vector (f %) %) coll)))","problem":63,"user":"4eb2eae5535d7eef30807351"},{"problem":63,"code":"(fn [fun xs] (reduce #(let [k (fun %2)]\n                        (assoc % k (conj (get % k []) %2)))\n                     {}\n                     xs))","user":"6011b89ee4b074f607df66bc"},{"code":"(fn grp-by [f s]\n\t(reduce \n     (fn [ret x]\n       (let [k (f x)]\n     \t(assoc ret k (conj (get ret k []) x ))\n     ))\n     {}\n     s\n    )\n)","problem":63,"user":"5204f2b1e4b0bf4f1882c7f5"},{"code":"(fn [f coll]\n  (reduce\n    #(merge-with concat %1 {(f %2) [%2]})\n    {}\n    coll))","problem":63,"user":"4edecdae535d10e5ff6f533c"},{"code":"(fn [f c] (reduce (fn [r v] (let [k (f v)] (assoc r k (conj (get r k []) v)))) {} c))","problem":63,"user":"5027b41ee4b01614d1633fee"},{"problem":63,"code":"(fn [f sequence]\n  (reduce\n   (fn [state step]\n     (let [result (f step)]\n       (if (get state result)\n         (assoc state result (conj (get state result) step))\n         (assoc state result [step]))))\n   {}\n   sequence))","user":"5f79bff2e4b02876ed9fd0ca"},{"problem":63,"code":"(fn [value-to-key-mapper items] \n  (let [key-value-pairs (for [item items] { (value-to-key-mapper item) [item] })]\n    (apply merge-with into key-value-pairs)))","user":"582d7569e4b051871117bfbe"},{"problem":63,"code":"(fn groupf [foo lst]\n  (loop [lst lst m {}]\n    (println \"m:\" m)\n    (if (empty? lst)\n      m\n      (let [f (first lst) o (get m (foo f) []) n (conj o f)]\n        (recur \n          (rest lst)\n          (into \n            m \n            [[\n              (foo f) \n              n\n            ]]\n          )\n        )\n      )\n    )\n  )\n)","user":"562add6de4b00e49c7cb4834"},{"problem":63,"code":"(fn [f args]\n  (into {}\n        (map #(vector (f (first %))(vec %))\n             (partition-by f (sort args)))))","user":"5a4443cae4b0447ef91cc60f"},{"problem":63,"code":"(fn [f xs] (into {} (map (fn [y]  {y (filter #(= y (f %)) xs)}) (set (map f xs)))))","user":"55896a0ce4b059ccff29b204"},{"code":"(fn m [f c]\n  (reduce (fn [k x]\n              (assoc k (f x) (conj (k (f x) []) x)))\n          {} c))","problem":63,"user":"4e72ac47535d5021c1a89666"},{"problem":63,"code":";seems like the list type returned by partition-by is equals-compatible with the vectors in the test cases, so \n; '(apply vector xs) isn't strictly needed here\n\n(fn e-63 [f s]\n  (apply merge (map (fn [xs] {(f (first xs)), (apply vector xs)}) \n                    (partition-by f (sort-by f s)))))","user":"53bd7080e4b0d9a98559a6d1"},{"problem":63,"code":"(fn [f col]\n  (reduce\n    (fn [acc item]\n      (let [k (f item)]\n        (conj acc {k (if (acc k) (conj (acc k) item )  (vector item)  ) })\n      )           \n    )\n    {}\n    col\n  )  \n)","user":"56979bb7e4b0e0b3d3318cac"},{"problem":63,"code":"(fn [f coll]\n  (reduce #(update-in %1 [(f %2)] (fn [a b] (conj (vec a) b)) %2) {} coll))","user":"58923efce4b00487982d521c"},{"code":"(fn g [f s]\n  (reduce (fn [r v] (let [add #((fnil conj []) % %2)]\n                          (update-in r [(f v)] add v))) {} s))","problem":63,"user":"4f05ea25535dcb61093f6c02"},{"code":"(fn [f s]\n  (reduce\n    (fn [result x]\n      (update-in result [(f x)] (fnil conj []) x))\n    {} s))","problem":63,"user":"4e68c434535d8ccf87e9fe89"},{"problem":63,"code":"(fn [f coll]\n  (reduce (fn [acc e]\n            (let [res (f e)]\n              (assoc acc res (conj (get acc res []) e)))) {} coll))","user":"58a953dae4b01a0c0b232968"},{"code":"#(apply merge-with concat (map (fn [x] {(% x) [x] }) %2))","problem":63,"user":"523ed522e4b057c4b7cd0a78"},{"problem":63,"code":"(fn gs\n  ([f xs] (gs f xs {}))\n  ([f xs result]\n    (if (empty? xs) result\n       (let [h (first xs) t (rest xs) k (f h)]\n         (if (contains? result k) \n             (recur f t (assoc result k (conj (result k) h)))\n             (recur f t (assoc result k [h])))))))","user":"559b55d6e4b066d22e731f54"},{"code":"(fn [f coll]\n  (loop [result {} x coll]\n    (if (empty? x)\n      result\n    (if (result (f (first x)))\n      (recur (assoc result (f (first x)) (conj (result (f (first x))) (first x)))\n             (rest x)\n             )\n      (recur (assoc result (f (first x)) [(first x)]) (rest x))\n      )\n   )))","problem":63,"user":"51da7e49e4b02ceefd947768"},{"code":"(fn my-group [f lis] (into {} \n\t(for [x (distinct ((fn [f s] (map f s)) f lis))] \n      [x (filter #(= (f %) x) lis)])))","problem":63,"user":"51c09719e4b0c9c82288293c"},{"problem":63,"code":"(fn [f s]\n  (let [ks (distinct (map f s))\n        vals (reduce (fn [accum k]\n                       (conj accum\n                             (filter (fn [i] (= k (f i))) s)))\n                     []\n                     ks)]\n    (zipmap ks vals)))","user":"5012da69e4b0c8732600222d"},{"problem":63,"code":"(fn [func coll]\n  (loop [[elem & coll] coll grouped {}]\n    (if (nil? elem)\n      grouped\n      (recur coll (update-in grouped [(func elem)] #(conj (vec %) elem)))\n   )\n  )\n)","user":"5e09fd26e4b099d064962f60"},{"code":"#_(fn [f s]\n  (let [vals (map f s)]\n    (apply merge-with conj\n      (into {} (for [v vals] [v []]))\n      (map hash-map vals s))))\n\n(fn [f s]\n  (reduce\n    (fn [m x]\n      (update-in m [(f x)] conj x))\n    {}\n    (reverse s)))","problem":63,"user":"53727c0be4b06d7f452d9dfa"},{"code":"(fn [f s]\n  (loop [c (reverse s) m {}]\n    (if (empty? c)\n      m\n      (let [r (f (first c))]\n        (recur (rest c) (assoc m r (cons (first c) (m r))))))))","problem":63,"user":"52173464e4b082aa80a88c75"},{"problem":63,"code":"(fn [f s]\n  (apply merge-with into \n         (map #(hash-map (f %1) [%1]) s)))","user":"5e5096c6e4b027a2e10ac0c6"},{"problem":63,"code":"(fn [f s]\n   (reduce\n    (fn [acc x]\n      (assoc acc\n             (f x)\n             (conj (get acc (f x) []) x)))\n    {}\n    s))","user":"55b54ecbe4b01b9910ae2987"},{"problem":63,"code":"(fn [f coll]\n    (reduce #(let [res (f %2)] (assoc % res (vec (concat (% res) [%2])))) {} coll))","user":"5c165d3ee4b01240ff5671d1"},{"problem":63,"code":"(fn [f xs]\n  (->> xs\n    (map #(hash-map (f %) [%]))\n    (apply merge-with into)))","user":"5b64370ae4b0c6492753e73c"},{"code":"(fn [f s] (apply merge-with (fn [a b] (into a b)) (for [x s] {(f x) [x]})))","problem":63,"user":"4f0cc259535d0136e6c22310"},{"problem":63,"code":"(fn custom-group-by [f coll]\n  (apply merge-with into (map #(hash-map (f %) [%]) coll)))","user":"59f78b49e4b0ca45a743a30e"},{"problem":63,"code":"(fn [f items] \n  (reduce (fn [m v] (let [k (f v)]\n                      (assoc m k (conj (get m k []) v)))) {} items))","user":"5368fedee4b0243289761e93"},{"problem":63,"code":"(fn [f xs]\n  (reduce\n   \t(fn [m x]\n      (let [k (f x) v (or (m k) [])]\n        (assoc m k (conj v x))))\n    {}\n   \txs))","user":"54448e84e4b032a45b869393"},{"code":"(fn group[f c1]\r\n  (let [keys (map f c1)]\r\n    (loop [k keys v c1 result {}]\r\n     (if (empty? k) \r\n       result\r\n       (recur (next k)(next v)\r\n       (if (contains? result (first k))\r\n           (assoc result (first k) (conj (get result (first k)) (first v)))\r\n           (assoc result (first k) [(first v)])))))))","problem":63,"user":"4e9def6b535dbda64a6f6b8f"},{"problem":63,"code":"(fn my-group-by [f s]\n   (apply merge-with concat (for [a s]\n                       {(f a) [a]})) \n\n   )","user":"567b2f20e4b05957ce8c61a2"},{"problem":63,"code":"(fn grp-by [f coll]\n  (->> coll\n      (map #(hash-map (f %) [%]))\n      (apply merge-with into)))","user":"5ca14eb1e4b048ec896c5b7d"},{"problem":63,"code":"(fn  [f coll]\n  (reduce\n    (fn [result v]\n      (let [key (f v)]\n        (assoc result key (conj (vec (get result key)) v))))\n    {}\n    coll))","user":"55e6c3f5e4b050e68259b48c"},{"problem":63,"code":"(fn [f s]\n  (reduce (fn [m e]\n            (let [k (f e)]\n              (assoc m k (conj (get m k []) e)))\n            )\n          {} s))","user":"558b41fce4b0277789237628"},{"code":"(fn [f s]\n      (reduce (fn [m v]\n                (let [k (f v)]\n                  (assoc m k\n                         (conj (vec (m k)) v))))\n              {} s))","problem":63,"user":"4f301d02e4b0d6649770a072"},{"code":"(fn my-group-by\n    [f coll]\n  (persistent!\n   (reduce\n    (fn [ret x]\n      (let [k (f x)]\n        (assoc! ret k (conj (get ret k []) x))))\n    (transient {}) coll)))","problem":63,"user":"51e780dae4b0730ab87cf353"},{"problem":63,"code":"(fn rec [f coll]\n  (reduce #(assoc %1 (f %2) (conj (get %1 (f %2) []) %2)) {} coll))","user":"58b06b7ce4b0ebc645576cdc"},{"problem":63,"code":"(fn [f s] (loop [m {} q s] (if (empty? q) m (recur (update-in m [(f (first q))] concat [(first q)]) (rest q)))))","user":"5282f54be4b0239c8a67ada0"},{"problem":63,"code":"(fn [map-fn test-me]\n  (into {}\n        (for [k (into #{} (map map-fn test-me))]\n          [k (filter #(= k (map-fn %)) test-me)]))\n                      \n    \n  )","user":"54cbd97ae4b057c6fda3a283"},{"code":"(fn [x y] (apply hash-map (apply concat (map #(list (x (first %1)) %1) (partition-by x (sort-by x y))))))","problem":63,"user":"514d398ee4b019235f6c0583"},{"problem":63,"code":"(fn group [f c]\n  (let [step\n        (fn [f c m]\n          (if-let [s (seq c)]\n            (let [fs (first s)\n                  fk (f fs)]\n              (recur f (rest s) (assoc m fk (conj (get m fk []) fs))))\n            m))]\n    (step f c (hash-map))))","user":"5953bdb6e4b066ee0a44aeed"},{"problem":63,"code":"(fn [f s]\n   (reduce\n     (fn [map x]\n       (assoc map (f x) (conj (map (f x) []) x)))\n     {}\n     s))","user":"55f85b93e4b03cbcff9738ae"},{"problem":63,"code":"(fn my-group-by [func coll]\n  (reduce\n    (fn [p c]\n      (assoc p (func c) (concat (get p (func c)) [c]))\n      )\n\n    (hash-map) coll)\n\n  )","user":"5edc16e1e4b0c7845d86b0f1"},{"problem":63,"code":"(fn [f l]\n  (reduce\n   #(assoc %\n      (f %2)\n      (vec (conj (get % (f %2)) %2)))\n   {}\n   l))","user":"55236ad6e4b0882d96d091b1"},{"code":"(fn [f s]                                               \n  (loop [r s m {}]                                      \n    (if (seq r)                                         \n      (let [v (first r) k (f v)]                        \n        (recur (rest r) (assoc m k (conj (m k []) v))) )\n      m ) ) )","problem":63,"user":"4df20dda535d08e6dec9fe23"},{"problem":63,"code":"(fn [f s]\n (let [kys (distinct (map f s))\n       vls (map (fn [k]\n                  (reduce #(if (= k (f %2)) (conj %1 %2) %1) [] s)) kys)]\n  (zipmap kys vls)))","user":"586615e6e4b0f14aab7c8858"},{"problem":63,"code":"(fn [func coll] (reduce #(update-in %1 [(func %2)] concat [%2]) {} coll))","user":"51f38193e4b0fca5e8b48226"},{"code":"(fn [f s] (reduce (fn [c v] (let [fv (f v)] (assoc c fv (conj (get c fv []) v)))) {} s))","problem":63,"user":"50c75d38e4b00bb60fe0c532"},{"code":"(fn [f coll] (reduce (fn [map [x y]] (if (map x) (assoc map x (conj (map x) y)) (assoc map x [y]))) {} (map vector (map f coll) coll)))","problem":63,"user":"50733b31e4b0e3170b5a869a"},{"code":"(fn my-group [f a-seq]\n  (->> \t(map #(hash-map (f %) [%]) a-seq) \n   \t\t(apply merge-with #(conj %1 (first %2)))))","problem":63,"user":"52890634e4b0239c8a67ae5e"},{"code":"(fn [f s]\n  (reduce\n    #(update-in %1 (vector (f %2))\n      (fn [v] (if (nil? v) [%2] (conj v %2))))\n    {} s))","problem":63,"user":"4ea1ecfa535d7eef308072bb"},{"code":"(fn [f coll]\n  (reduce\n   (fn [result x]\n     (let [y (f x)\n           val (get result y [])]\n       (assoc result y (conj val x))))\n   (sorted-map)\n   coll))","problem":63,"user":"4daedd1eedd6309eace4d164"},{"problem":63,"code":"(fn [f x]  (loop [i 0  y {} ] (if (< i (count x)) (recur (inc i) (merge-with into y {(f (get x i)) [(get x i)]}))  y )))","user":"56e6e1e6e4b02e7e935eb6cf"},{"problem":63,"code":"(fn[fun, coll]\n   (zipmap\n     (distinct (map fun (sort-by fun coll)))\n     (partition-by fun (sort-by fun coll)) ;partition-by splits coll each time f returns a new value, so it needs sorted coll\n     )\n   )","user":"5f0824c5e4b0cf489e8d7f5b"},{"problem":63,"code":"#(reduce\n   (fn [r v]\n     (update-in r [(%1 v)]\n                (fn [old new] ((fnil conj []) old new) )\n                v\n                )) {} %2)","user":"5a66f358e4b0512ff01cd9d5"},{"problem":63,"code":"(fn g[f c]\n   (reduce\n     #(merge-with\n        into\n        %1\n        %2)\n     (map #(assoc {} (f %) [%]) c)))","user":"5398123ee4b0b51d73faaef3"},{"code":"#(reduce (fn [m i] (conj m [(%1 i) (conj (m (%1 i) []) i)])) {} %2)","problem":63,"user":"507fbd77e4b089ade05efbd3"},{"code":"(fn [f coll]\n  (reduce (fn [r x] (assoc r (f x) (conj (get r (f x) []) x)))\n   {} coll))","problem":63,"user":"4e513ecf535dc968683fc4f6"},{"problem":63,"code":"(fn [f coll]\n  (reduce (fn [m x] (update-in m [(f x)] (fnil conj []) x)) {} coll))","user":"566b57e9e4b0a866af6896ad"},{"code":"#(persistent!\n   (reduce\n    (fn [ret x]\n      (let [k (%1 x)]\n        (assoc! ret k (conj (get ret k []) x))))\n    (transient {}) %2))","problem":63,"user":"52a62e16e4b0c58976d9abf9"},{"problem":63,"code":"(fn [f arg]\n\n     (->> arg\n          (sort)\n          (partition-by f)\n          (mapv #(vec (cons (f (first %)) [%])))\n          (into {})\n          )\n\n     )","user":"5dd1fb19e4b0948ae9d9ad51"},{"problem":63,"code":"(fn [f arr] (reduce (fn [acc x] (assoc acc (f x) (conj (get acc (f x) []) x))) {} arr))","user":"5ebd7296e4b00a66d4a95273"},{"problem":63,"code":"(fn [f s]\n  (reduce\n   (fn [acc x]\n     (let [k (f x) v (acc k)]\n       (if (nil? v)\n         (assoc acc k [x])\n         (assoc acc k (conj v x)))))\n   {}\n   s))","user":"56cf115de4b0ea9b8538f765"},{"problem":63,"code":"(fn [f xs]\n  (reduce (fn [m v]\n            (let [k (f v)\n                  old (vec (get m k))]\n              (assoc m k (conj old v))))\n          {} xs))","user":"56c21eafe4b05cc29241ee7e"},{"problem":63,"code":"(fn [f xs]\n  (loop [[y & ys] xs m {}]\n    (if y\n      (if (contains? m (f y))\n        (recur ys (assoc m (f y) (conj (m (f y)) y)))\n        (recur ys (assoc m (f y) [y]))\n      )\n      m\n    )\n  )\n)","user":"5df08767e4b093ff717275bf"},{"problem":63,"code":"#(loop [callback %1\n        coll %2\n        acc {}]\n   (if (empty? coll)\n     acc\n     (let [val (first coll)\n           key (callback val)]\n       (recur callback (rest coll) (assoc acc key (conj (or (acc key) []) val))))))","user":"57155980e4b07c98581c3ad7"},{"problem":63,"code":"(fn [f col]\n  (reduce (partial merge-with concat) (map #(hash-map (f %) [%]) col)))","user":"56288ccae4b00e49c7cb47ea"},{"code":"(fn [f coll]\n  (reduce (fn [acc item]\n            (let [result (f item)]\n              (if (not (contains? acc result))\n                (assoc acc result [item])\n                (assoc acc result (conj (acc result) item))))) {} coll))","problem":63,"user":"4f036d9b535dcb61093f6ac1"},{"problem":63,"code":"#(reduce (fn [l x] (if (nil? (l (%1 x))) (assoc l (%1 x) [x]) (assoc l (%1 x) (conj (l (%1 x)) x )))) {} %2)","user":"5686b7c7e4b0dcc4269f4057"},{"problem":63,"code":"(fn [f s] (loop [[x & xs] s r {}]\n            (if (nil? x)\n              r\n              (recur xs (merge-with into r {(f x) [x]}))\n              )))","user":"571346c0e4b07c98581c3a9b"},{"problem":63,"code":"(fn [f a]\n  (reduce #(let [x (f %2)\n                 e (conj (get %1 x []) %2)]\n             (assoc %1 x e)\n             ) {} a)\n  )","user":"5628cb07e4b00e49c7cb47ef"},{"code":"(fn ans [f coll]\n  (loop [in (reverse coll)\n         out {}]\n    (if (not (empty? in))\n      (recur \n        (rest in)\n        (let [v (first in)\n              k (f v)]\n            (assoc out k (conj (out k) v))))\n      out)))","problem":63,"user":"4e6a60cd535d8ccf87e9fed7"},{"problem":63,"code":"(fn[f x]\n  (let[add (fn[grouped elm]\n             (if (contains? grouped (f elm))\n               (assoc grouped (f elm) (conj (grouped (f elm)) elm))\n               (assoc grouped (f elm) (vector elm))))]\n    (reduce add {} x)))","user":"55429859e4b0a04f7929951f"},{"problem":63,"code":"(fn [f s]\n    (reduce (fn [m e]\n              (update-in m [(f e)] #(conj (or % []) e)))\n            {}\n            s))","user":"5a5d0726e4b0512ff01cd91b"},{"problem":63,"code":"(fn [f xs] \n  (reduce \n    (fn [m [k v]] (assoc m k (conj (m k []) v))) \n    {} \n    (partition 2 (interleave (map f xs) xs))))","user":"55ecb2c0e4b0121d4835fdce"},{"code":"(fn[f xs]\n  (letfn [(add-to [m x]\n            (let [k (f x)]\n              (assoc m k (conj (m k []) x))))]\n    (reduce add-to {} xs)))","problem":63,"user":"52b65f26e4b0c58976d9ad43"},{"problem":63,"code":"(fn [f coll] (reduce (partial merge-with concat) (map #(hash-map (f %) [%]) coll)))","user":"56561119e4b0f9d632dd849d"},{"code":"(fn [f s]\n  (reduce\n   (fn [m x]\n   \t(let [key (f x)\n          val (if (m key) (conj (m key) x) [x])]\n      (assoc m key val)))\n   {} s))","problem":63,"user":"533696b9e4b0e30313ee6c7c"},{"code":"#(reduce (fn [c e]\n            (let [g (% e)]\n              (if (contains? c g)\n                (assoc c g (conj (c g) e))\n                (assoc c g [e]))))\n            {} %2)","problem":63,"user":"4db0114d838c48654951d9b8"},{"code":"#(reduce (fn [l e] (merge-with concat l {(%1 e) [e]})) {} %2)","problem":63,"user":"4faac363e4b081705acca200"},{"problem":63,"code":"(fn\n  [f a]\n  (apply merge-with into (for [a a :let [result (f a)]] {result [a]})))","user":"59ddae03e4b01968742fed65"},{"problem":63,"code":"(fn [f coll] (reduce (partial merge-with into) (map #(hash-map %1 [%2]) (map f coll) coll)))","user":"565b2fa5e4b068f2fe63dbfe"},{"problem":63,"code":"(fn [f coll] (persistent!\n   (reduce\n    (fn [ret x]\n      (let [k (f x)]\n        (assoc! ret k (conj (get ret k []) x))))\n    (transient {}) coll)))","user":"54a677a9e4b09f271ff37c88"},{"code":"(fn my-grp [f l]\n  (reduce\n    (fn [acc, e] (assoc acc (f e) (conj (acc (f e)) e)))\n     (apply hash-map (interleave (distinct (map f l)) (repeat [])))\n     l))","problem":63,"user":"4e89ddf9535d3e98b8023284"},{"code":"(fn [ck-fn param-list]\n  (reduce\n    #(assoc %1 (ck-fn %2)\n        (if (get %1 (ck-fn %2))\n          (conj (get %1 (ck-fn %2)) %2 )\n          [%2]))\n    {}\n    param-list))","problem":63,"user":"4ec12516535dfed6da9c6da7"},{"code":"(fn [f coll]\r\n    (reduce #(merge-with concat %1 {(f %2) [%2]}) {} coll))","problem":63,"user":"4dd61f98535d2dad7130b5c6"},{"problem":63,"code":"(fn [f s]\n  (apply merge-with (comp vec concat) (map #(hash-map (f %) [%]) s)))","user":"56ef077ae4b04a395b9a0459"},{"code":"(fn [f s]\n  (loop [accu {}\n   s s]\n    (if (empty? s)\n      accu\n      (let [x (first s)\n\t    y (f x)]\n      (if (accu y)\n\t(recur (assoc (dissoc accu y) y (conj (accu y) x)) (rest s))\n\t(recur (assoc accu y (conj [] x)) (rest s)))))))","problem":63,"user":"4e82c062535db62dc21a62cc"},{"problem":63,"code":"(fn [f s]\n \t(reduce  \n\t\t(fn [result [k v]]\n\t\t\t(if (contains? result k)\n\t\t\t\t(assoc result k (conj (get result k) v))\n\t\t\t\t(conj result [k [v]])\n\t\t\t)\n\t\t)\n\t\t{}\n\t\t(map #(vector (f %) %) s)\n\t)\n )","user":"5559b443e4b0deb715856e3c"},{"problem":63,"code":"(fn my-group-by [f s]\n  (loop [[head & tail] (map #(vector (f %) %) s)\n         result {}]\n    (if (not head)\n      result\n      (let [v (first head)\n            k (last head)\n            keys (if (contains? result v) (get result v) [])]\n        (recur tail (assoc result v (conj keys k)))\n        ))))","user":"53a511aae4b0b62ce3005735"},{"problem":63,"code":"(fn [f xs]\n   (let [ks (into #{} (map f xs))\n         rs (fn [k] (reduce (fn [js v] (if (= (f v) k)\n                                         (conj js v)\n                                         js)) [] xs))]\n     (apply conj {} (map (fn [k] [k (rs k)]) ks))))","user":"52281e1ee4b0186687e23a69"},{"code":"(fn [f xs]\n  (reduce #(assoc %1 (first %2) (conj (get %1 (first %2) []) (nth %2 1)))\n    (conj (for [x xs] (vector (f x) x)) {})))","problem":63,"user":"5050b107e4b063148f524126"},{"code":"(fn [p s] (reduce #(merge-with concat %1 %2) (map hash-map (map p s) (map list s))))","problem":63,"user":"4eb13d60535d7eef3080733f"},{"code":"(fn [f coll]\n  (reduce (fn [acc x]\n            (let [k (f x)] (assoc acc k (conj (get acc k []) x))))\n          {}\n          coll))","problem":63,"user":"4eecc9ad535d93acb0a668b4"},{"problem":63,"code":"(fn [f v] \n  ((fn f ([l m] \n    (if (empty? l) (into (sorted-map) m) \n         (if (= (first (first l)) (first (last m)))       \n; existing group\n           (f (rest l)\n              (concat (drop-last m) \n                   (vector (vector (first (first l)) \n                        (vec (concat (last (last m)) \n                          (vector (last (first l)))))))))\n; new group      \n           (f (rest l) \n              (concat m (vector (vector (first (first l)) \n                         (vector (last (first l)))))))\n        )))) (sort-by first (for [x v] [(f x) x])) [] ))","user":"5fab7ea6e4b08cb800c85ad8"},{"problem":63,"code":"(fn [f a] (into {} (map #(identity [(first (map first %)) (map last %)]) (partition-by first (sort-by first (map #(identity [(f %) %]) a))))))","user":"5a8aa992e4b05369db4d24d8"},{"code":"(fn [f coll]\n  (reduce (fn [m x] (assoc m (f x)\n                           (conj (m (f x) []) x)))\n          {}\n          coll))","problem":63,"user":"50586354e4b06522596eba78"},{"code":"(fn [f s]\n    (reduce \n        (fn [ret x]\n            (let [k (f x)]\n                (assoc ret k (conj (get ret k []) x))))\n        {}\n        s))","problem":63,"user":"4e7263a1535d5021c1a8965f"},{"problem":63,"code":"(fn [f s]\n    (let [safe-conj (fnil #(conj %1 %2) [])]\n      (reduce (fn [accu cur]\n                (update-in accu [(f cur)] safe-conj cur))\n              {}\n              s)))","user":"5d883119e4b0915913b1d3a6"},{"code":"(fn [f s]\n  (loop [s s\n         acc {}]\n    (if-let [s (seq s)]\n      (let [v (first s)\n            k (f v)\n            old-vec (get acc k [])]\n        (recur (rest s)\n          (assoc acc k (conj old-vec v))))\n      acc)))","problem":63,"user":"4f28c979e4b0d6649770a01a"},{"problem":63,"code":"(fn [func coll]\n  (let [paired (map #(hash-map (func %) [%])  coll)]\n    (apply merge-with concat paired)))","user":"585d9558e4b0f14aab7c879c"},{"code":"#(reduce (fn [m e] (assoc m (% e) `[~@(m (% e)) ~e])) {} %2)","problem":63,"user":"51ad244fe4b09397d510977f"},{"code":"(fn run\n  ([f x] (run f x {}))\n  ([f x m]\n     (let [item (first x)]\n       (if (nil? item) m\n           (if (contains? m (f item))\n             (recur f (rest x) (update-in m [(f item)] #(conj % item)))\n              (recur f (rest x) (assoc m (f item) (conj [] item)))\n             )\n           ))\n     )\n  )","problem":63,"user":"5302ac7fe4b0d8b024fd3731"},{"code":"(fn [f coll ]\r\n  (zipmap (distinct (map f coll)) (partition-by f (sort-by f coll))))","problem":63,"user":"4f5d0f25e4b0030a34fb2b33"},{"code":"(fn\n  [f sq]\n  (let\n    [ks (set (map f sq))\n     preds (apply hash-map (mapcat #(list % (fn [x] (= % (f x)))) ks))]\n    (apply hash-map (mapcat #(list % (apply vector (filter (get preds %) sq))) ks))))","problem":63,"user":"504e12ade4b078edc5f593b7"},{"problem":63,"code":"(fn [f cl] (reduce #(update-in %1 [(f %2)] (fn [a b] (conj (if (vector? a) a []) b)) %2) {} cl))","user":"549375e4e4b0b312c081ff4e"},{"problem":63,"code":"(fn [f c] (apply merge-with concat (map (fn [i] {(f i) [i]}) c)))","user":"54b7f217e4b0ed20f4ff6e8f"},{"problem":63,"code":"(fn [keyfunc coll]\n  (reduce #(update-in %1 [(keyfunc %2)] (fnil conj []) %2)\n          {}\n          coll))","user":"5bc39d2be4b07a9b28b10045"},{"code":"(fn [func coll]\n  (reduce\n    (fn [output item]\n      (let [item-key (func item)]\n        (assoc output item-key (conj (get output item-key []) item))))\n    {}\n    coll))","problem":63,"user":"4ec2fe3f535dcc7ae8597d4f"},{"problem":63,"code":"(fn [f xs] (reduce\n             (fn [m i]\n               (into m\n                     (let [fi (f i)]\n                       [[fi (-> fi m (or []) (conj i))]])\n                     )) {} xs))","user":"515cf9b5e4b00901442db1d4"},{"code":"(fn my-group-by\n  [f s]\n  (loop [[x & more] (seq s)\n         result {}]\n    (if x\n      (let [key (f x)]\n        (recur more (assoc result\n                      key\n                      (conj (or (result key) [])\n                            x))))\n      result)))","problem":63,"user":"4db8d37d535d1e037afb219c"},{"problem":63,"code":"(fn [f c]\n  (loop [results {}\n         [elt & elts] c]\n    (let [r (f elt)]\n      (if-let [group (results r)]\n        (if elts\n          (recur (assoc results r (conj group elt)) elts)\n          (assoc results r (conj group elt)))\n        (if elts\n          (recur (assoc results r [elt]) elts)\n          (assoc results r [elt]))))))","user":"535558b9e4b04ce2eb3ed25a"},{"problem":63,"code":"(fn [f coll]\n  (reduce (fn [res cur]\n            (assoc res (f cur) (concat (get res (f cur)) [cur])))\n          {} coll))","user":"562cb7cfe4b0a45d2ff83009"},{"problem":63,"code":"(fn [f d]\n  (->> (map #(vector (f %) [%]) d)\n       (reduce (fn [m [k v]] (assoc m k (concat (get m k []) v))) {})))","user":"591addcee4b09b4ee5954be1"},{"code":"(fn [f s]\n  (let [partitions (partition-by f (sort-by f s))]\n    (zipmap (map #(f (first %)) partitions) partitions)))","problem":63,"user":"4ee3b586535d10e5ff6f5371"},{"problem":63,"code":"(fn [f coll] \n  (reduce \n   (fn [acc end]\n     (let [result (f end) group (or (acc result) [])]\n       (assoc acc result (conj group end))\n      )\n   )\n   {}\n   coll\n  )\n)","user":"585bcd51e4b0f14aab7c8771"},{"problem":63,"code":"#(loop [v %2\n        m {}]\n   (if (empty? v) \n     m\n     (let [n (first v)\n           k (%1 n)]\n       (recur (rest v) \n              (assoc m k (conj (m k []) n))))))","user":"5566d812e4b0c656e3ff1837"},{"code":"(fn [f coll]\n  (apply merge-with concat \n    (map #(hash-map (f %) [%]) coll)))","problem":63,"user":"501c1492e4b086d93747d180"},{"code":"(fn [pred coll]\n    (loop [group {}\n           mapped (map pred coll)\n           coll2 coll]\n          (if (empty? mapped)\n            group\n            (let [k (first mapped)\n                  v (first coll2)]\n              (recur (conj group [k (if (contains? group k)\n                                      (conj (group k) v)\n                                      (conj [] v))])\n                     (rest mapped)\n                     (rest coll2))))))","problem":63,"user":"4f5cc3b8e4b0030a34fb2b2b"},{"code":"#(loop [f %1 s %2 m {}]\n  (let [x (first s) _s (rest s)] \n    (if (nil? x)\n      m\n      (recur f _s (merge-with concat m {(f x) [x]}))\n    )\n  )\n)","problem":63,"user":"5176afd2e4b085adf681d889"},{"problem":63,"code":"(fn [f xs]\n  (let [n (->>\n            (map #(list (f %) %) xs)\n            (sort-by first)\n            (partition-by first))]\n     (into {}\n           (map #(hash-map (-> % first first)\n                           (into [] (map second %))) n))))","user":"53572767e4b04ce2eb3ed277"},{"code":"#(loop [e (first %2)\n        l (next  %2)\n        a {}]\n   (let [n (%1 e)\n         a (into a {n (conj (vec (a n)) e)})]\n     (if l\n       (recur (first l) (next l) a)\n       a)))","problem":63,"user":"4f32a7f1e4b0d6649770a095"},{"problem":63,"code":"(fn [f s]\n (reduce \n  \t\t(fn [acc x]\n          (let [k (f x)\n                curvalue (get acc k [])\n                newvalue (conj curvalue x)\n           \t\t]\n            (assoc acc k newvalue)\n                )\n          \n          )\n         {}\n         s\n )\n)","user":"5ac85708e4b0e27600da77ac"},{"problem":63,"code":"(fn [kfn c]\n  (reduce (fn [m v] (update-in m [(kfn v)] (comp vec conj) v))\n          {} c))","user":"4f7207d3e4b07046d9f4f019"},{"code":"(fn [f s]\n  (loop [ks (seq s)\n         vs (map f s)\n         r (apply hash-map (interleave (set vs) (repeat [])))]\n    (if (and ks vs)\n      (recur\n       (next ks)\n       (next vs)\n       (assoc-in r [(first vs)]\n                 (conj (r (first vs)) (first ks)))) r)))","problem":63,"user":"4f3e5e87e4b0e243712b1f83"},{"problem":63,"code":"(fn [f xs]\n  (reduce (fn [m v]\n            (let [k (f v)]\n              (assoc m k (conj (m k []) v))))\n          {}\n          xs))","user":"59eb63e3e4b0249b7282077c"},{"problem":63,"code":"(fn [f xs]\n  (apply merge-with into (for [x xs] {(f x) [x]})))","user":"5d27da09e4b092dab7f59c75"},{"code":"(fn [f & args]\n  (let [maps (apply map #(hash-map (f %) [%]) args)]\n    (apply merge-with concat maps)))","problem":63,"user":"4f0c4518535d0136e6c2230b"},{"problem":63,"code":"(fn [f l]\n  (loop [v (reverse l)\n         s {}]\n    (if (empty? v)\n      s\n      (let [i (f (first v))] (recur (rest v) (assoc s i (conj (s i) (first v))))))))","user":"55e732c5e4b050e68259b492"},{"problem":63,"code":"#(apply (partial merge-with concat) (map (fn [i] {(% i) [i]}) %2))","user":"53571732e4b04ce2eb3ed275"},{"problem":63,"code":"(fn [f s]\n    (reduce (fn [acc [k v]] (update-in acc [k] (fn [ov] (conj (or ov []) v)))) {}\n      (map (juxt f identity) s)))","user":"516db4f6e4b046df6fbb76a0"},{"code":"(fn [f s]\n  (reduce (fn [groupings value]\n            (let [key (f value)]\n          \t  (assoc groupings\n                key\n                (conj (get groupings key []) value))))\n          {}\n          s))","problem":63,"user":"536bbd64e4b0243289761ec2"},{"code":"(fn [f s]\n  (reduce \n    (fn [r e] \n      (let [k (f e) a (r k [])]\n(assoc r k (conj a e))))\n{} s))","problem":63,"user":"4fca2a13e4b0ee37620e184d"},{"problem":63,"code":"(fn [f col] (reduce (fn [m v] (let [r (f v)] (update-in m [r] #(conj (or % []) v)))) {} col))","user":"52ee9ac7e4b05e3f0be25ec9"},{"problem":63,"code":"(fn [f s]\n  (reduce (fn [result v]\n            (let [k (f v)]\n              (assoc result k (conj (get result k []) v))))\n          {}\n          s))","user":"527818f7e4b03e8d9a4a7519"},{"code":"(fn [f args] \n  (reduce \n   (fn [m v] \n     (let [fv (f v)] \n       (assoc m fv (concat (m fv) [v])))) \n   {} args))","problem":63,"user":"50c781bbe4b00bb60fe0c535"},{"code":"(fn [f es]\n  (reduce (fn [h e]\n            (let [fe (f e)]\n              (assoc h fe (conj (get h fe []) e))))\n          {} es))","problem":63,"user":"4e7f8f85535db966e863cc44"},{"code":"(fn [f s] (reduce #(let [v (f %2)] (assoc % v (concat (% v) (list %2)))) {} s))","problem":63,"user":"523b1988e4b02f719975bdbc"},{"problem":63,"code":"(fn [f s]\n  (reduce (fn [m each]\n            (update-in m [(f each)] (fnil conj []) each))\n          {}\n          s))","user":"528c381ce4b0239c8a67aeb2"},{"problem":63,"code":"(fn [f a]\n  (loop [b a m {}]\n    (if (nil? b)\n      m\n      (recur (next b) (assoc m (f (first b)) (conj (get m (f (first b)) []) (first b))))\n    )\n  )\n)","user":"5b99a0a3e4b0c0b3ffbd4ad7"},{"problem":63,"code":"(fn [f coll] (apply merge-with concat  (map #(hash-map (f %) [%]) coll)))","user":"53480973e4b084c2834f4a52"},{"code":"(fn [f coll]\n  (loop [result {}, coll coll]\n    (if (empty? coll)\n      result\n      (let [k (f (first coll)), pred #(= k (f %))]\n        (recur (conj result [k (filter pred coll)]) (filter (complement pred) coll))))))","problem":63,"user":"4edab806535d10e5ff6f5311"},{"problem":63,"code":"(fn my-group-by\n  [f coll]\n  (reduce #(update-in %1 [(f %2)] (fnil conj []) %2) {} coll))","user":"539e717fe4b0ca733b974488"},{"problem":63,"code":"(fn [f x]\n  (let [pt (partition-by f (sort-by f x))] \n    (zipmap \n     (map \n      #(f (first %))\n          pt)\n     (map \n      #(into (empty x) %)\n          pt))))","user":"5c7d5463e4b0d597f478caa9"},{"code":"(fn [f coll]\n  (reduce (fn [acc x]\n            (update-in acc [(f x)] (comp #(conj % x) vec)))\n          {} coll))","problem":63,"user":"50d8de3fe4b01f0871336e72"},{"code":"(fn [f col]\n  (reduce \n   (fn [dict x]\n     (let [k (f x)]\n       (assoc dict k (conj (get dict k []) x))))\n   {}\n   col))","problem":63,"user":"520612a7e4b0bf4f1882c81c"},{"code":"(fn g [f col]\n (let\n  [as (map f col)\n   es (map #(vector %1 %2) as col)\n   ]\n  (reduce\n   (fn [ret [k v]]\n    (assoc ret k (conj (get ret k []) v)))\n   {} es)\n  ))","problem":63,"user":"506fd0afe4b07bd6ad9b9f23"},{"problem":63,"code":"(fn shiny2 [foo coll] (reduce (fn [map [x y]] (update-in map [x] #(sort(cons y %)))) {} (vec(map (juxt foo identity) coll))))","user":"557e8326e4b05c286339e0d7"},{"problem":63,"code":"(fn [f s]\n  (reduce\n   #(assoc %1 (f %2)\n      (conj (get %1 (f %2) []) %2))\n   {}\n   s))","user":"58ca8a1de4b03c36ff7e5835"},{"problem":63,"code":"(fn [f s]\n   (->> s\n    (map #(hash-map (f %) [%]))\n    (apply merge-with concat)))","user":"5935b010e4b04f87174def55"},{"problem":63,"code":"(fn [f s]\n  (reduce #(let [f-val (f %2)\n                 prev-params (get % f-val nil)]\n             (if (nil? prev-params)\n               (assoc % f-val [%2])\n               (assoc % f-val (conj prev-params %2))))\n    {} s))","user":"56bb652ae4b0f26550335953"},{"problem":63,"code":";(fn group\n;  [f seq]\n;  (loop [res {} s seq]\n;    (if (first s)\n;      (if (res (f (first s)))\n;        (recur (assoc res (f (first s)) (conj (res (f (first s))) (first s))) (vec (rest s)))\n;        (recur (merge res {(f (first s)) (vector (first s))}) (vec (rest s))))\n;      res)))\n#(apply merge-with concat (map (fn [x] {(%1 x) [x]}) %2))","user":"59390a35e4b02506e01a29f3"},{"problem":63,"code":"#(reduce (fn [m x]\n           (let [k (%1 x)\n                 v (or (m k) [])]\n             (assoc m k (conj v x))))\n         {}\n         %2)","user":"55495318e4b0a04f79299566"},{"problem":63,"code":"(fn [f coll]\n  (->> (map #(hash-map (f %) (vector %)) coll)\n       (apply merge-with #(vec (concat %1 %2)))))","user":"57202eb7e4b0c5bde472c090"},{"problem":63,"code":"(fn [func vals]\n        ( into {}\n\t(map #(vector (func (first % )) (vec %))\n             (partition-by func (sort vals)))))","user":"555093b2e4b00713264bd9ab"},{"code":"(fn group [f coll]\n  (persistent!\n   (reduce\n    (fn [ret x]\n      (let [k (f x)]\n        (assoc! ret k (conj (get ret k []) x))))\n    (transient {}) coll)))","problem":63,"user":"4e84f77c535db62dc21a62e5"},{"code":"(fn [f s]\n  ((fn step [ret f [x & xs]]\n     (if x\n       (let [k (f x)]\n         (step (assoc ret k (conj (get ret k []) x)) f xs))\n       ret))\n    {} f (seq s)))","problem":63,"user":"4f6845d2e4b07046d9f4ef74"},{"problem":63,"code":"(fn [f xs]\n  (reduce #(let [k (f %2) v (%1 k)]\n             (assoc %1 k (if v (conj v %2) [%2]))) {} xs))","user":"5052ab7ee4b0a561d07d8f20"},{"problem":63,"code":"(fn [func vals]\n  (into {} (map #(vector (func (first % )) (vec %))\n             (partition-by func (sort vals)))))","user":"50c95c4fe4b0bed41a12298f"},{"problem":63,"code":"(fn [f v] \n  (into \n   \t{} \n   \t(map \n    \t#(vector (f (first %)) (vec %))\n     \t(partition-by f (sort v))\n    ) \n  )\n)","user":"6001460ce4b074f607df6611"},{"problem":63,"code":"(fn [f s]\n  (reduce (fn [m x] (update-in m [(f x)] #(concat % [x]))) {} s))","user":"542a8d07e4b01498b1a71b43"},{"code":"(fn mgb [f coll]\n  (apply merge-with concat (map #(hash-map %1 (list %2)) (map f coll) coll)))","problem":63,"user":"5151c184e4b03e678e393add"},{"code":"(fn [f sq] (reduce #(if (contains? %1 (f %2)) (assoc %1 (f %2) (conj (%1 (f %2)) %2)) (assoc %1 (f %2) [%2])) {} sq))","problem":63,"user":"50fbdacfe4b0d10d794c19f0"},{"code":"(fn grs [f col]\n  (apply merge-with concat (map #(hash-map (f %) [%]) col)))","problem":63,"user":"4feff3b6e4b0678c553fc31e"},{"problem":63,"code":"(fn dale [f s] (apply merge-with concat (map #(hash-map %1 [%2]) (map f s) s)))","user":"55ac16a0e4b03311e7b73291"},{"problem":63,"code":"(fn [f xs] (let [part (partition-by f xs)]\n             (apply merge-with concat (map #(assoc {} %1 %2) (map #(f (first %)) part) part))))","user":"57615a22e4b0994c1922fb88"},{"problem":63,"code":"(fn [op data]\n (apply merge\n        (map #(into {} (vector (vector (op (first %)) (vec %))))\n             (partition-by op\n                           (sort-by op data)\n                           )\n             )\n        )\n )","user":"56f974c0e4b07572ad1a88b1"},{"code":"(fn gr [f xs]\n  (if (empty? xs)\n    {}\n    (let [groups (gr f (rest xs))\n          k (f (first xs))]\n      (if (contains? groups k)\n        (assoc groups k (into [(first xs)] (groups k)))\n        (assoc groups k (vector (first xs)))))))","problem":63,"user":"52d660eae4b09f7907dd1356"},{"problem":63,"code":"(fn g [f xs] (reduce #(update-in %1 [(f %2)] (fnil conj []) %2) {} xs))","user":"58c2df0ae4b021aa9917ed17"},{"problem":63,"code":"(fn [pred s]\n  (let [rs (map pred s)\n        inter (interleave rs s)\n        \n       ]\n    (loop [xs inter m {}]\n\n      (let [k (first xs)\n            v (second xs)\n            dst (get m k [])\n            ]\n\n      (if (empty? xs)\n        m\n        (recur (drop 2 xs) (assoc m k (conj dst v))     )\n        )\n      )\n      )\n    )\n\n  )","user":"55a65872e4b09e57187da299"},{"code":"(fn [f col]\n  \n  (reduce\n   \n     (fn [m v] \n       \n       (let [k (f v)\n             \n             c (get m k [])]\n         \n         (assoc m k (conj c v))))\n   \n   {} col))","problem":63,"user":"504e71cbe4b0f6ff3350c4b3"},{"problem":63,"code":"(fn [f c] (\n  let [key-val (for [x c] [(f x) x])\n       keys (set (map first key-val))]\n    (into {}\n      (for [key keys]\n        [key (into [] (map second (filter #(= key (first %)) key-val)))]))))","user":"589e0024e4b02bd94d917e4e"},{"problem":63,"code":"(fn [f xs]\n   (reduce (fn [acc x]\n             (let [v (f x)]\n               (if (acc v)\n                 (assoc acc v (conj (acc v) x))\n                 (assoc acc v [x]))))\n           {}\n           xs))","user":"5c896f46e4b048ec896c5940"},{"problem":63,"code":"(fn [f c] \n  (apply merge-with #(concat %1 %2) \n         (map (fn [v] {(f v) [v]}) c)))","user":"541ae7dbe4b01498b1a71a61"},{"problem":63,"code":"#(apply merge-with into (for [n %2] {(% n) [n]}))","user":"5f7e91c8e4b0c071e6c840d8"},{"code":"(fn [f s]\r\n  (loop [tail s, m {}]\r\n    (if-let [[x & xs] (seq tail)]\r\n      (let [f-result (f x)]\r\n        (recur xs (assoc m f-result (conj (get m f-result []) x))))\r\n    m)))","problem":63,"user":"4dd6d6a0535d2dad7130b5ca"},{"problem":63,"code":"(fn group-by-1 [f coll]\n  (reduce\n   (fn [ret x]\n     (let [k (f x)]\n       (assoc ret k (conj (get ret k []) x))))\n   {}\n   coll))","user":"5693a53ee4b0dcc4269f4106"},{"code":"(fn rec [f lst]\n  (if (empty? lst)\n    {}\n    (let [v (first lst)\n          k (f v)]\n      (update-in (rec f (rest lst)) [k] #(cons v %)))))","problem":63,"user":"52cc09c1e4b07d0d72b27356"},{"code":"(fn [f x]\n  (let [keys (distinct (map f x))]\n    (zipmap keys (map #(filter (fn [_] (= % (f _))) x) keys))))","problem":63,"user":"53940789e4b0b51d73faaec3"},{"problem":63,"code":"(fn [f coll] \n  (reduce\n   (fn [prev el]\n     (let [fx (f el)]\n       (assoc-in prev [fx] \n                 (conj (get prev fx '[]) el))))\n  '{}\n  coll))","user":"5514a60fe4b055c2f668d4d7"},{"code":"(fn grpby [f coll]\n  (loop [result {},\n         coll coll]\n    (if (empty? coll)\n      result\n      (if (contains? result (f (first coll)))\n        (recur (assoc result (f (first coll)) (conj (result (f (first coll))) (first coll))) (rest coll))\n        (recur (conj result [(f (first coll)) [(first coll)]]) (rest coll))))))","problem":63,"user":"512474ede4b02c3f2a072cce"},{"code":"(fn [f coll]\n  (let [grp-by (fn [acc x] \n    (let [key (f x) val (if (contains? acc key) (conj (acc key) x) [x])] (assoc acc key val)))]\n  (reduce grp-by {} coll)))","problem":63,"user":"4e6a4edd535d8ccf87e9fec4"},{"code":"(fn [fu li] (let [ke (distinct (map fu li))] (zipmap ke (map (fn va [ky] (vec (filter (fn inn [x] (= (fu x) ky)) li))) ke))))","problem":63,"user":"5134973ce4b0230e9f713b42"},{"problem":63,"code":"(fn [f col]\n  (let [pairs (map (juxt f identity) col)\n        ks (set (map first pairs))]\n     (reduce \n      (fn [acc k]\n        (assoc acc k (->> pairs \n                          (filter (fn [[f-x x]] (= k f-x)))\n                          (map second))))\n      {}\n      ks)))","user":"58a822e4e4b01a0c0b232950"},{"code":"(fn [f s] (into {} (map (fn [x] [(f (first x)) (vec x)]) (partition-by f (sort-by f s)))))","problem":63,"user":"4e7e55ab535db169f9c79711"},{"code":"(fn [f seq]\n  (let [m (map f seq)\n        zm (zipmap seq m)] ; {1 false, 3 false, 6 true, 8 true}\n    (reduce (fn [gb item] (assoc gb (zm item) (conj (gb (zm item)) item)))\n            (zipmap (set m) (repeat [])) ; {true [], false []}\n            seq)))","problem":63,"user":"51df825de4b01188f062752b"},{"problem":63,"code":"(fn [f xs]\n   (let [ks (distinct (map f xs))]\n     (apply hash-map (interleave ks (map (fn [k] (filter #(= k (f %)) xs)) ks)))))","user":"57780e4fe4b0979f89651657"},{"problem":63,"code":"(fn [f col] (reduce #(assoc %1 (f %2) (conj (apply vector (%1 (f %2))) %2)) {} col))","user":"5a9a12d6e4b0d174b936c7b7"},{"problem":63,"code":"(fn __ [f x]\n\t(reduce\n\t\t#(merge-with\n\t\t\t (fn [x y]\n\t\t\t\t (vec\n\t\t\t\t\t (concat x y)\n\t\t\t\t\t )\n\t\t\t\t )\n\t\t\t %1\n\t\t\t %2\n\t\t\t )\n\t\t(map #(hash-map (first %) (vector (second %))) (map vector (map f x) (vec x)))\n\t\t)\n\t)","user":"575dda55e4b02ea11479938c"},{"code":"(fn [f col]\n  (reduce \n  \t#(assoc % (f %2) (conj (% (f %2) []) %2))\n\t\t{} col))","problem":63,"user":"4ec16c21535dfed6da9c6dac"},{"code":"(fn [f s]\n  (apply merge-with into (map #(hash-map (f %) [%]) s)))","problem":63,"user":"4ec5a5f9535d6d7199dd36ad"},{"problem":63,"code":"(fn [f xs]\n  (let [rs (map f xs)]\n    (let [kv (partition 2 (interleave rs xs))]\n      (reduce (fn [m v]\n                (let [vv (m (first v))]\n                  (if (nil? vv) \n                    (assoc m (first v) [(second v)])\n                    (assoc m (first v) (conj vv (second v))))))\n                '{}\n                kv))))","user":"5d02fe44e4b0cc9c915881c0"},{"problem":63,"code":"#(apply merge-with concat (map (fn [e] {(%1 e) [e]}) %2))","user":"5be79b5be4b0f319e2d7ec5a"},{"code":"(fn [f s]\n  (reduce\n    #(update-in %1 [(f %2)] (comp vec conj) %2)\n    {}\n    s))","problem":63,"user":"4fc4eadee4b081705acca353"},{"code":"(fn app\n  ([f s] (app f (rest s) {(f (first s)) [(first s)]})   )\n  ([f s m]   \n    (if (> (count s) 0)\n      (app f \n        (rest s) \n        (merge-with concat m {(f (first s)) [(first s)]})\n      )\n      m  \n    )\n  )\n)","problem":63,"user":"4dd579b5535dae65d5c462ea"},{"problem":63,"code":"(fn [f xs] (reduce (fn [m v] (let [k (f v)] (assoc m k (conj (m k []) v)))) {} xs))","user":"56e06625e4b0ca2494a09607"},{"code":"(fn [f coll]\n  (into {}\n  (let [ks (set (map f coll))]\n    (for [k ks]\n      [k (vec (filter #(= k (f %)) coll))] ))))","problem":63,"user":"5353afa0e4b084c2834f4b03"},{"problem":63,"code":"(fn group-seq\n  [f xs]\n  (reduce (fn [dict val] (update-in dict [(f val)] #(if (nil? %) [val] (conj (dict (f val)) val)))) {} xs)\n  )","user":"5d828b7ee4b0915913b1d382"},{"code":"(fn group-by2 [f lst]\n  (if-let [i (first lst)]\n   (let [val (f i)\n           i-groups (filter #(= val (f %)) lst)\n           o-groups (filter #(not (= val (f %))) lst)]\n    (assoc (group-by2 f o-groups) val i-groups))\n    {}))","problem":63,"user":"5374adc3e4b06d7f452d9e27"},{"code":"#(reduce (fn [m v] (let [k (%1 v)] (assoc m k (conj (get m k []) v)))) {} %2)","problem":63,"user":"5002b6e5e4b0678c553fc42c"},{"problem":63,"code":"(fn my-group-by\n    ([f s] (my-group-by f s {}))\n    ([f s m]\n     (if (empty? s)\n       m\n       (let [r (f (first s))]\n         (if (contains? m r)\n           (my-group-by f (rest s) (assoc m r (conj (m r) (first s))))\n           (my-group-by f (rest s) (assoc m r [(first s)]))\n           )))))","user":"5a9d64c8e4b0d174b936c7eb"},{"problem":63,"code":"(fn [f coll] (reduce #(let [k (f %2) v %2] (assoc %1 k (conj (%1 k []) %2))) {} coll))","user":"5cb0f70ce4b026601754b8c1"},{"code":";copied from clojure src. Why on earth is this\n;marked easy???\n(fn [f s]\n  (reduce \n    (fn [ret x]\n      (let [k (f x)]\n        (assoc ret k (conj (get ret k []) x))))\n    {} s))","problem":63,"user":"4eb8ec4a535dfed6da9c6d4b"},{"problem":63,"code":"(fn [f s]\n  (apply merge-with into (for [x s] {(f x) [x]})))","user":"57262710e4b0c5bde472c120"},{"problem":63,"code":"(fn my-group-by [f coll] \n  (->> coll\n      (map #(hash-map (f %) (vector %)))\n      (apply merge-with into)))","user":"581b19e7e4b04b46fc4b0ec4"},{"code":"(fn [f s] (apply merge-with into (for [x s] {(f x) [x]} ) ) )","problem":63,"user":"4ee7d177535d93acb0a6686f"},{"code":"#(zipmap (apply sorted-set (map % %2)) (partition-by % (sort-by % %2)))","problem":63,"user":"51944aaae4b0142f60b4aedc"},{"problem":63,"code":"(fn [f coll]\n  (loop [rcoll coll\n         ret {}]\n    (if (empty? rcoll)\n      ret\n      (let [x (first rcoll)\n            key (f x)]\n        (recur (rest rcoll) (assoc ret key (conj (get ret key []) x)) )))))","user":"55aa8276e4b0988bba2ad94e"},{"code":"(fn[f,c] (loop [col c ret {}]\r\n         (if (empty?  col) ret\r\n         (let [value (f (first col))]\r\n              (recur (rest col)\r\n              (if (contains? ret value) (assoc ret value (conj (ret value) (first col) )) (assoc ret value (vector (first col)))   )               \r\n    )))))","problem":63,"user":"50463347e4b011c5dfee771e"},{"code":"(fn [f coll]\n  (apply merge-with concat\n    (map\n      #(hash-map (f %) [%])\n      coll)))","problem":63,"user":"4f92884de4b0dcca54ed6caf"},{"code":"(fn [f s]\n  (reduce\n    (fn [m v]\n      (let [k (first v) v (second v)]\n        (assoc m v (vec (conj (m v) k)))))\n    {} (partition 2 (interleave s (map f s)))))","problem":63,"user":"4fd6f4d8e4b0dab7d829f37b"},{"code":"(fn gb [f col]\n  (reduce\n   (fn [ret x]\n     (let [k (f x)]\n       (assoc ret k (conj (get ret k []) x))))\n   {} col))","problem":63,"user":"5322d370e4b09d4e7a9b54c7"},{"problem":63,"code":"(fn [f s]\n    (reduce #(assoc %1 (f %2) (conj (vec (get %1 (f %2))) %2)) {} s))","user":"586b6753e4b01531a375e956"},{"problem":63,"code":"#(reduce (fn [r v]\n            (merge-with concat r {(% v) [v]})) {} %2)","user":"4f04664a535dcb61093f6bc1"},{"problem":63,"code":"(fn [f s] (reduce #(update-in %1 [(f %2)] (fnil (fn [v] (conj v %2)) [])) {} s))","user":"57e0f30ae4b0bfb2137f5a66"},{"code":"(fn [f coll]\n  (loop [c coll\n         memo {}]\n    (if (empty? c) memo\n      (recur (rest c)\n             (let [k (f (first c))\n                   v (get memo k)]\n               (if v\n                 (assoc memo k (conj v (first c)))\n                 (assoc memo k (vector (first c)))))))))","problem":63,"user":"528b01a0e4b0239c8a67ae89"},{"code":"(fn grp [f s]\n  (reduce (fn [m x]\n            (let [k (f x)]\n              (if (contains? m k)\n                (assoc m k (conj (get m k) x))\n                (assoc m k [x])))) {} s))","problem":63,"user":"52c4af71e4b0c2d177d620e1"},{"problem":63,"code":"(fn grp-by [f coll]\n  (reduce (fn [acc i]\n            (update-in acc \n                       [(f i)] \n                       (fnil #(conj % i) [])))\n          {}\n          coll))","user":"53b39d82e4b047364c0444a6"},{"code":"(fn my-group [f xs]\n      (reduce (fn [grouped key]\n                  (assoc grouped key (filter #(= (f %) key) xs))) {} (distinct (map f xs))))","problem":63,"user":"5186134ce4b0da5a5be3bac7"},{"problem":63,"code":"(fn [f s] (reduce #(assoc %1 (f %2) (conj (%1 (f %2) []) %2)) {} s))","user":"563536f8e4b0bfe05bf117c5"},{"problem":63,"code":"(fn [f S]\n\t(loop [s S m {}]\n\t\t(if (empty? s)\n\t\t\tm\n\t\t\t(let [k (f (first s))]\n\t\t\t\t(recur\n\t\t\t\t\t(rest s)\n\t\t\t\t\t(if (contains? m k)\n\t\t\t\t\t\t(assoc m k (conj (m k) (first s)))\n\t\t\t\t\t\t(assoc m k (vector (first s)))\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t)\n\t)\n)","user":"5f574662e4b0a0bc16850a90"},{"code":"(fn [f c] (let [sc (partition-by f (sort c))] (apply hash-map (interleave (map #(f (first %)) sc) sc))))","problem":63,"user":"533ee560e4b085b17e897d98"},{"problem":63,"code":"(fn [pred coll]\n  (reduce (fn [state item] \n            (update-in state [(pred item)] (fnil #(conj % item) []))) {} coll))","user":"5caf9cace4b026601754b89b"},{"problem":63,"code":"(fn [f s]\n   (reduce (fn [acc v]\n             (update-in acc [(f v)] (comp vec conj) v))\n           {}\n           s))","user":"52b52c29e4b0c58976d9ad38"},{"code":"(fn\n  [f coll]\n  (persistent!\n   (reduce\n    (fn [ret x]\n      (let [k (f x)]\n        (assoc! ret k (conj (get ret k []) x))))\n    (transient {}) coll)))","problem":63,"user":"52f5f8b4e4b09b582c12c9cc"},{"problem":63,"code":"(fn [f coll]\n  (reduce\n   (fn [m item]\n     (let [k (f item)]\n       (assoc m k (conj (get m k []) item))))\n   {}\n   coll))","user":"5922f8a9e4b026ae3852128f"},{"problem":63,"code":"(fn [f vec]\n    ((fn [vec] \n      (->> vec\n           (sort-by f)\n           (partition-by f)\n           (map (fn [x] (hash-map (f (first x)) x)))\n           (apply merge)))\n         vec))","user":"55627de1e4b0c656e3ff17d9"},{"problem":63,"code":"(fn [f s]\n  (let [keys (into #{} (map f s))]\n    (into {} (map (fn [key] [key (filter (fn [x] (= key (f x))) s)]) keys))))","user":"577629abe4b0979f8965162e"},{"code":"(fn gby [t l] (if (empty? l) {}\n   (let [g (gby t (rest l))\n         h (t (first l))]\n     (assoc g h (cons (first l) (get g h []))))))","problem":63,"user":"4f8b20fce4b02e764a0a5178"},{"code":"(fn [f s]\n  (apply merge-with concat (map #(assoc {} (f %) [%]) s)))","problem":63,"user":"4f39f902e4b0e243712b1efe"},{"problem":63,"code":"(fn my-group [f x]\n  (reduce-kv (fn [m1 k1 v1] (assoc m1 k1 (reverse v1))) {}\n    (reduce (fn [m v]\n      (update-in m (vector (f v)) conj v)) {} x)))","user":"56b506d5e4b0982f16b37e2d"},{"code":"(fn [f s] (reduce #(assoc % (f %2)  (conj (get % (f %2) []) %2)) {} s))","problem":63,"user":"4ea5e794535d7eef308072df"},{"problem":63,"code":"(fn [f coll]\n  (apply merge-with into (map (fn [x] {(f x) [x]}) coll)))","user":"545e9cf1e4b01be26fd7467f"},{"problem":63,"code":"(fn [f coll]\n  (apply merge-with concat\n         (map #(hash-map (f %) (list %)) coll)\n         )\n  )","user":"564b495de4b0284900eef667"},{"problem":63,"code":"(fn [f s] (reduce\n           (fn [m [k v]] (assoc m k (into [] (conj (m k) v))))\n           {}\n           (map #(vector (f %) %) s)))","user":"556a3243e4b09a3098a524de"},{"code":"(fn my-group-by [f coll] \r\n  (persistent! \r\n    (reduce (fn [ret x] \r\n      (let [k (f x)] \r\n(assoc! ret k \r\n  (conj (get ret k []) x)))) \r\n(transient {}) coll)))","problem":63,"user":"50436470e4b034ff00315d23"},{"problem":63,"code":"(fn [f coll]\n  (reduce (fn [acc x]\n            (assoc acc (f x) (conj (get acc (f x) []) x))) \n          {} coll))","user":"5478c4fee4b0c51c1f4d72c0"},{"code":"(fn [f ls] \n  (into {} \n        (for [val [ls] key (set (map f ls))] \n          [key (into [] (filter (fn [k](= (f k) key)) ls))])))","problem":63,"user":"534eecaee4b084c2834f4abf"},{"code":"(fn [f c]\n  (reduce\n    #(assoc % (f %2) (conj (get %1 (f %2) []) %2))\n    {}\n    c))","problem":63,"user":"4f0f174c535d0136e6c22330"},{"code":"(fn [f s] \n  (reduce\n    (fn [ret x]\n      (let [k (f x)]\n        (assoc ret k (conj (get ret k []) x))))\n  {} s))","problem":63,"user":"5053de37e4b0b1b9d1860ea8"},{"problem":63,"code":"(fn [f col]\n  (reduce (fn [acc i] (update-in acc [(f i)] #(vec (conj % i))))\n          {}\n          col))","user":"5b85221ce4b047b03b2037c8"},{"problem":63,"code":"(fn [f coil]\n  (loop [src coil, result {}]\n    (if (empty? src)\n      result\n      (recur (rest src)\n             (assoc result\n               (f (first src))\n               (if (nil? (result (f (first src))))\n                 (vector (first src))\n                 (conj (result (f (first src)))\n                       (first src))))))))","user":"56c55fbce4b05cc29241eea5"},{"code":"(fn [f coll]\n  (apply merge-with  #(concat % %2)\n         (map #(hash-map  (f %) [%]) coll)))","problem":63,"user":"50e90813e4b033b0e80d11e7"},{"code":"#(apply merge-with concat (map (fn [x] {(% x) [x]}) %2))","problem":63,"user":"51e58e02e4b0efabf93c02d0"},{"problem":63,"code":"(fn g\n  ([f s]\n   (g f s {}))\n  ([f s acc]\n   (if (empty? s)\n     (into {} (for [[k v] acc] [k (vec (reverse v))]))\n     (let [x (first s)\n           v (f x)]\n       (recur f \n              (rest s)\n              (update-in acc [v] conj x))))))","user":"512e31e9e4b0b740abc59823"},{"code":"(fn [f s]\n  (apply merge-with\n         concat\n         (map (fn [x] {(f x) [x]}) s)))","problem":63,"user":"51460e4ce4b04ef915e37314"},{"problem":63,"code":"(fn [f coll]\n  (let [mvalues coll mkeys (map f coll) pairs (map vector mkeys mvalues)]\n    (reduce #(assoc % (first %2) (if (contains? % (first %2))\n                                   (conj (get % (first %2)) (second %2))\n                                   (vector (second %2)))) {} pairs)))","user":"607a1523e4b0a637ed78036a"},{"problem":63,"code":"(fn [pred vals]\n    (reduce (fn [map [key val]]\n              (assoc map key (conj (get map key []) val)))\n            {}\n            (for [v vals] [(pred v) v])))","user":"4f42c80ae4b0d7d3c9f3fd0f"},{"problem":63,"code":"(fn [f se]\n   (persistent!\n    (reduce (fn [grp item]\n              (let [res (f item)]\n                (assoc! grp res (conj (get grp res []) item))))\n            (transient {}) se)))","user":"53214efbe4b09d4e7a9b54b2"},{"problem":63,"code":"(fn [y x]\n                    (into {} (map #(vector (y (first %)) (vec %)) (partition-by y (sort x)))))","user":"60b3b375e4b0e0fa5f1b4232"},{"problem":63,"code":"(fn [f s]\n  (apply merge-with concat \n         (map #(hash-map (f %) [%]) s)))","user":"5835cb06e4b089d5ab817cea"},{"problem":63,"code":"(fn [f s]\n  (reduce\n   (fn [m x]\n     (let [k (f x)]\n       (assoc m k\n         (if (contains? m k)\n           (conj (m k) x)\n           [x]))))\n   {}\n   s))","user":"594fdfdce4b066ee0a44ae85"},{"code":"(fn [f xs] \n   (reduce \n    (fn [m s]\n  \t\t(let [[k v] s] \n  \t\t\t(assoc m k \n          (if (contains? m k) \n            (conj (get m k) v) \n            [v]))))\n    {} \n    (map #(vector (f %) %) xs)))","problem":63,"user":"5114ab7be4b0ce5098ee73b5"},{"code":"(fn own-group-by [f v]\n  (let \n    [ct-pairs   (fn [f v]  (map vector (map f v) v))\n     find-keys  (fn [f v]  (distinct (map f v)))\n     get-entry  (fn [k ps] (hash-map k (map last (filter #(= k (first %)) ps))))\n     ct-entries (fn [ks pairs] (for [k ks] (get-entry k pairs)))\n     pairs (ct-pairs f v)\n     ks    (find-keys f v)\n     entries (ct-entries ks pairs)]\n    (into {} entries)))","problem":63,"user":"52cf084ce4b07d0d72b27399"},{"code":"(fn [f s]\n\n\n   (zipmap  (distinct (map f s))   (map  #(vec (filter (fn [i] (= (f i) %))  s))     (distinct (map f s))  ))\n\n    )","problem":63,"user":"4e78c208535db95036265722"},{"problem":63,"code":"(fn [f xs]\n  (reduce (fn [res-map x]\n            (let [key (f x)]\n              (assoc res-map key (conj (get res-map key []) x))))\n          {} xs))","user":"54926752e4b0b312c081ff44"},{"code":"(fn g [f x]\n  (apply hash-map(apply concat (for [a (into #{} (map f x))\n    :let [b (into [] (filter #(= a (f %)) x))]\n  ]  (list a b))))\n)","problem":63,"user":"50f4894be4b004d364930528"},{"code":"(fn my-group [f coll]\n  (letfn [(add-map [m x]\n            (let [k (f x)]\n              (if-let [v (get m k)]\n                (assoc m k (conj v x))\n                (assoc m k [x]))))]\n    (reduce add-map {} coll)))","problem":63,"user":"52f8f4d1e4b047fd55836fde"},{"problem":63,"code":"(fn [f s]\n  (reduce #((fn [m key val]\n              (let [full-val (get m key [])]\n                (conj m [key (conj full-val val)]))) %1 (f %2) %2) {} s))","user":"54df3c94e4b024c67c0cf7aa"},{"problem":63,"code":"(fn [f xs]\n\t(reduce\n\t\t(fn [m n] (update-in m [(f n)] (fnil #(conj % n) [])))\n\t\t{} xs))","user":"505fdf63e4b08f2a82ad10b9"},{"code":"(fn [f coll]\n  (persistent!\n   (reduce\n    (fn [ret x]\n     (let [k (f x)]\n       (assoc! ret k (conj (get ret k []) x)))) (transient {}) coll)))","problem":63,"user":"5368a275e4b0243289761e8f"},{"code":"(fn group\r\n  [f s]\r\n\t(if (empty? s)\r\n\t\t[]\r\n\t\t(merge-with concat {(f (first s)) [(first s)]} (group f (rest s)))))","problem":63,"user":"4e8a0c82535d3e98b802328d"},{"code":"(fn [f coll] (reduce (fn [acc val] (let [k (f val)] (assoc acc k (concat (acc k) [val])))) {} coll))","problem":63,"user":"52c1f404e4b07a9af5792370"},{"problem":63,"code":"(fn [f s]\n  (loop [s s\n         g {}]\n    (if (seq s)\n      (let [x (first s)\n            X (f x)]\n        (recur (rest s) (assoc g X (conj (g X []) x))))\n      g)))","user":"4f42ae16e4b0d7d3c9f3fd09"},{"code":"(fn [f col] (apply merge-with concat (map (fn [x] {(f x) [x]}) col)) )","problem":63,"user":"4f9510b5e4b0dcca54ed6cc7"},{"code":"(fn [f l] (reduce #(if (contains? %1 (f %2))\n                       (assoc %1 (f %2) (conj (get %1 (f %2)) %2))\n                       (assoc %1 (f %2) (vector %2)))\n          {}\n          l))","problem":63,"user":"4f9754d4e4b0dcca54ed6ce9"},{"code":"(fn [p c]\r\n    (loop [s (sort c) r {}]\r\n\t  (if (empty? s)\r\n\t      r\r\n\t      (recur\r\n\t        (rest s)\r\n\t\t(assoc r\r\n\t\t       (p (first s))\r\n\t\t       (vec (conj (r (p (first s))) (first s))))))))","problem":63,"user":"4e821ca5535db62dc21a62c2"},{"problem":63,"code":"(fn [f coll] (reduce (fn [k ret] (assoc k (f ret) (conj (k (f ret) []) ret) )) {} coll))","user":"55f2c898e4b06e875b46ce4b"},{"problem":63,"code":"(fn\n  [f coll]\n  (apply merge-with into (map #(hash-map (f %) [%]) coll)))","user":"54f2a1b8e4b024c67c0cf8cb"},{"code":"(fn [f x] (reduce #(assoc %1 (f %2) (conj (vec (%1 (f %2))) %2)) {} x))","problem":63,"user":"50982cc7e4b04e098a4c726c"},{"problem":63,"code":"(fn [f c]\n (into {} (for [s (set (map f c))]\n            [s (filter #(= s (f %)) c)])))","user":"5504dd64e4b086ebe8a79c83"},{"problem":63,"code":"(fn [f m] (reduce #(assoc %1 (f %2) (conj (into [] (get %1 (f %2))) %2)) {} m))","user":"5591b61ee4b0604b3f94d580"},{"problem":63,"code":"(fn [f s] (reduce #(update-in %1 [(f %2)] (comp vec conj) %2) {} s))","user":"4e7e032b535db169f9c796fc"},{"problem":63,"code":"(fn [f values]\n  (let [ks (-> (map f values) set)]\n    (reduce (fn [result k] (conj result [k (filter #(= (f %) k) values)])) {} ks)))","user":"53c649d3e4b00fb29b221297"},{"problem":63,"code":"#(apply merge-with into (for [x %2] {(%1 x) [x]}))","user":"4eb171d7535d7eef30807340"},{"problem":63,"code":"(fn [f coll]\n  (reduce (fn [m x]\n            (update-in m [(f x)] #(if (nil? %) [x] (conj % x))))\n          {} coll))","user":"57a4fa50e4b0a966079561f1"},{"problem":63,"code":"(fn [f col]\n  (let [a (map (juxt f identity) col)\n        b (sort-by first a)\n        c (partition-by first b)\n        d (for [m c]\n            (for [n m] (second n)))\n        e (map first (for [s c]\n                       (for [t s] (first t))))]\n    (into {} (map #(vector %1 (vec %2)) e d))))","user":"51456858e4b0e88796073408"},{"problem":63,"code":"(fn [f xs]\n    (let [r (fn [i n] \n              (if (i (f n))\n                  (assoc i (f n) (conj (i (f n)) n))\n                  (assoc i (f n) [n])))]\n      (reduce r {} xs)))","user":"56967bc0e4b0dcc4269f4131"},{"problem":63,"code":"(fn [fnc coll] (reduce #(let [k (fnc %2)] (assoc %1 k (if (%1 k) (conj (%1 k) %2) [%2]))) {} coll))","user":"57b7de74e4b0fbc9809a27d4"},{"problem":63,"code":"(fn [f coll]\n  (reduce \n   (fn [m x] \n     (let [k (f x)]\n       (assoc m k (concat (m k) [x])))) \n   {} \n   coll))","user":"57c94c6ee4b05aa3c4741d2d"},{"problem":63,"code":"(fn gr [func s]\n    (reduce #(assoc %1 (func %2) (conj (get %1 (func %2) []) %2) ) {} s) )","user":"54f09599e4b024c67c0cf89d"},{"code":"(fn grup [f col]\n       (let [c (map #(vector %1 %2) (map f col) col)]\n        (let [ret {}]\n          (reduce\n           (fn [r v]\n              (assoc r (nth v 0) (conj (get r (nth v 0) [])(nth v 1)))) ret c))))","problem":63,"user":"4df9c598535d04ed9115e77a"},{"code":"(fn [p s] (reduce (fn [r x] (update-in r [(p x)]\n  #(conj (vec %) x))) {} s))","problem":63,"user":"4db53810535d87e67b28fe07"},{"problem":63,"code":"(fn [op l] (reduce \n            (fn [m v] (let \n                        [k (op v)] (update-in \n                                    m [k] #(conj (vec %) v)\n                                    )\n                        )\n              )\n            {} \n            l\n            )\n  )","user":"4eb97234535dfed6da9c6d53"},{"problem":63,"code":"(fn [f xs] (let [ys (set (map f xs))]\n  (into {} (map (fn [vals] {vals (filter #(= vals (f %)) xs)}) ys))))","user":"54d70f40e4b0a52adc2e2027"},{"code":"(fn [f coll] (into {} (map (juxt #(f (first %)) identity) (partition-by f (sort-by f coll)))))\n         \n; answer from web: \n; (fn [f coll] (apply merge-with concat (for [x coll] {(f x) [x]})))\n; (fn [f coll] (apply merge-with concat (map #(assoc {} (f %) [%]) coll)))\n; or:\n; (sort-by f coll) -> (sort coll)\n; identity -> vec","problem":63,"user":"509fe759e4b08df8156e9e43"},{"code":"#(reduce (fn [m v] (update-in m [(% v)] (fnil conj []) v)) {} %2)","problem":63,"user":"50052d38e4b0678c553fc45c"},{"problem":63,"code":"(fn [f s]\n  (reduce\n   (fn [m v]\n     (let [k (f v)\n           old-v (get m k [])\n           new-v (conj old-v v)]\n       (assoc m k new-v)))\n   {}\n   s))","user":"51b920bfe4b0e871ca4958f9"},{"problem":63,"code":"(fn p\n  [f s]\n  (loop [m {} s s]\n    (if (empty? s)\n      (zipmap (keys m) (map reverse (vals m)))\n      (let [k (f (first s))]\n        (if (contains? m k)\n          (let [v (m k)]\n            (recur (assoc m k (cons (first s) v)) (rest s)))\n          (recur (assoc m k [(first s)]) (rest s)))))))","user":"56df632ce4b0ca2494a095f2"},{"problem":63,"code":"(fn my-group-by [f s] (reduce (fn [acc ss] (assoc acc (f ss) (vec (conj (acc (f ss)) ss)))) {} s))","user":"5f419985e4b0955706451fab"},{"code":"(fn [f s] (reduce (fn [m x] (merge-with concat m {(f x) [x]})) {} s))","problem":63,"user":"4db86aee535d1e037afb2193"},{"problem":63,"code":"(fn [f s]\n    (reduce (fn [m v]\n              (update-in m [(f v)] #(if % (conj % v) [v]))) {} s))","user":"4f57c913e4b0a7574ea7183f"},{"problem":63,"code":"#(loop [s %2\n         res {}]\n    (if (empty? s)\n      res\n      (recur (rest s) (let [k (% (first s))]\n                        (assoc res k (into [] (conj (get res k) (first s))))))))","user":"5bb5cd43e4b0a20761a23575"},{"problem":63,"code":"(fn [pred coll ] (->> (map #(hash-map (pred %) [%]) coll)\n             (apply merge-with concat)))","user":"58447708e4b089d5ab817e4b"},{"problem":63,"code":"(fn [f col] \n  (loop [res col\n         ret {}] \n      (if (empty? res)\n          ret\n          (let [v (first res) k (f v) cvec (conj (get ret k []) v)]\n            (recur (rest res) (assoc ret k cvec))))))","user":"5976da27e4b01722bebd4ce3"},{"problem":63,"code":"(fn [f col]\n  (reduce (fn [m e]\n              (update-in m [(f e)]\n                         #(conj (if %1 %1 []) %2)\n                         e))\n          {}\n          col))\n\n;; n.b. the core implementation is rather simple compared, using transient mutation","user":"5d231255e4b02ea6f0fb69fe"},{"problem":63,"code":"(fn\n  [group els]\n  (apply merge-with into (for [el els] {(group el) [el]})))","user":"55a5e2f7e4b0acc240e31550"},{"code":"(fn [f xs]\n  (apply (partial merge-with into)\n      (map #(hash-map (f %) [%]) xs)))","problem":63,"user":"4fe4c09ee4b0e8f79898febb"},{"problem":63,"code":"(fn [pred coll]\n  (->> (partition-by pred coll)\n       (map #(hash-map (pred (first %)) %))\n       (apply merge-with concat)))","user":"5152bc4ee4b001f44f99bfef"},{"code":"(fn [f s] (apply merge-with concat (map #(-> {(f %) [%]}) s)))","problem":63,"user":"51729002e4b044b2ef48a850"},{"code":"(fn [f coll] (\n              #(reduce\n (fn [a [k v]]\n   (assoc a k (conj (get a k []) v))) {} %)\n              (map (fn [x] (list (f x) x)) coll)))","problem":63,"user":"530caf86e4b02e82168697df"},{"problem":63,"code":"(fn [f coll]\n        (loop [acc {}\n               c coll]\n          (if (empty? c) acc \n              (recur (let [v (first c)\n                           k (f (first c))\n                           cv (acc k)]\n                       (if cv (assoc acc k (conj cv v))\n                           (assoc acc k (vector v)))) \n                     (rest c)))))","user":"4e526cc4535d302ef430da74"},{"problem":63,"code":"(fn my-group-by [f coll]\n  (reduce (fn [acc v] (let [key (f v)\n                            vals (get acc key [])]\n                        (assoc acc key (conj vals v)))) {} coll))","user":"5edd05bfe4b0c7845d86b0f3"},{"problem":63,"code":"(fn mygroupby [f coll]\n  (loop [input coll\n         result {}]\n    (if (empty? input)\n      result\n      (recur (rest input) (let [a (first input)\n                                b (f a)]\n                            (if (contains? result b)\n                              (assoc result b (conj (get result b) a))\n                              (assoc result b (vector a))))))))","user":"5ab490f4e4b073f17744261d"},{"code":"(fn [f s] \n    (loop [in s r {}]\n    (if (empty? in)\n      r\n      (recur (rest in) (conj r \n                             [(f (first in)) (filter #(= (f %) (f (first in))) s)] \n                             ) )\n     )\n    )\n  )","problem":63,"user":"528f4462e4b0239c8a67aef0"},{"problem":63,"code":"(fn [f coll] \n  (let   [mapper (map f coll) ;results of mapped collextion\n         setter (into #{} mapper)    ;set of elements in map\n         veccer (into [] setter) ; vector of unique elements\n         empter (repeat (count coll) []) ; vector or empty vector of count coll amount\n         resser (zipmap veccer empter)] ;map of all results and empty vector\n   \n    (loop [f f\n           coll coll\n           mapper mapper\n           result resser]  \n    \t(if (seq coll)\n            (recur f (next coll) (next mapper) (assoc result (first mapper) (conj (result (first mapper)) (first coll))))\n            result))))","user":"593744abe4b02506e01a299b"},{"code":"(fn gb\n  ([f lst] (gb {} f lst))\n  ([m f lst] (if (empty? lst) m\n               (let [r (f (first lst))\n                     vl (m r)]\n                 (gb (conj m [r (conj (if (nil? vl) [] vl) (first lst))] ) f (next lst))))))","problem":63,"user":"5272669de4b03e8d9a4a742e"},{"problem":63,"code":"(fn [f coll]\n  (reduce\n    (fn [acc v]\n      (update-in acc [(f v)] #(conj (or % []) v)))\n    {}\n    coll))","user":"52c1ede2e4b07a9af579236d"},{"problem":63,"code":"(fn get-map\n  ([func ls] (get-map func ls {}))\n  ([func ls new-map]\n   (if (empty? ls)\n     new-map\n     (let [[x & xs] ls\n           k (func x)\n           v (get new-map k)]\n       (get-map \n        func\n        xs\n        (assoc \n          new-map\n          k \n          (if (coll? v)\n            (conj v x)\n            (vector x))))))))","user":"5d48884ee4b07c84aa5ae6bb"},{"code":"(fn gb [f coll]\n  (apply hash-map \n  (apply concat\n    (map #(list (f (first %))  (vec %)) \n       (partition-by f (sort-by f coll))))))","problem":63,"user":"50c8697ce4b00bb60fe0c53f"},{"problem":63,"code":"(fn group_by \n  ; Given a function f and a sequence s, write a function which returns a map. The keys should be the values of f applied to each item in s. The value at each key should be a vector of corresponding items in the order they appear in s.\n  [func sq]\n  (reduce (fn [m i]\n            (assoc m\n              (func i)\n              (conj (m (func i) []) i))) {} sq))","user":"5bbbcecee4b0a20761a23611"},{"problem":63,"code":"(fn grp-by [f s]\n  (let [add-to-grp (fn [grps value]\n                     (update-in grps [(f value)] #(conj (or %1 []) %2) value))]\n    (reduce add-to-grp {} s)))","user":"5396c94be4b0b51d73faaee3"},{"problem":63,"code":"(fn group [f c] (reduce #(assoc % (f %2) (conj (if (nil? (% (f %2))) [] (% (f %2))) %2)) {} c))","user":"55c10409e4b01b9910ae2a2c"},{"problem":63,"code":"(fn my-group [f lst]\n  (apply merge-with into (map #(hash-map (f (first %)) (vec %)) (partition-by f (sort lst))))\n  )","user":"57f81045e4b0d3187e90090f"},{"problem":63,"code":"(fn [f coll]\n   (letfn [(build-groups [groups arg]\n             (let [val (f arg)\n                   group (get groups val [])\n                   updated-group (conj group arg)]\n               (conj groups [val updated-group])))]\n     (reduce build-groups {} coll)))","user":"5515b138e4b055c2f668d4ed"},{"code":"(fn [f coll]\n  (letfn [(acc [m k v]\n            (assoc m k (conj (get m k []) v)))]\n    (reduce #(acc %1 (f %2) %2) {} coll)))","problem":63,"user":"511aa2a4e4b0c87c59c9670a"},{"problem":63,"code":"(fn [f s]\n  (loop [result {}, [value & others] s]\n    (if (nil? value) result\n      (let [group (f value)\n            result-new (update-in result [group] (fnil conj []) value)]\n        (recur result-new others)))))","user":"5c13da47e4b01240ff5671a6"},{"code":"(fn [f vs]\n  (reduce #(merge-with concat % {(f %2) [%2]}) {} vs))","problem":63,"user":"51cbaf14e4b08d8387cbedda"},{"problem":63,"code":"(fn [f s]\n  (letfn [(p [m k v] \n                (update-in m [k] #(conj (vec %) v)))\n          (g [m v] \n                (p m (f v) v))]\n    (reduce g {} s)))","user":"55b1e9e7e4b0da326a65cf74"},{"code":"(fn my-group-by [f coll]\n  (reduce #(assoc\n               %1\n             (f %2)\n             (conj (get %1 (f %2) []) %2))\n          {} coll))","problem":63,"user":"4fa17b00e4b0dcca54ed6d5f"},{"code":"#(loop [x %2 y {} f %1]  (if (empty? x) y (let [key (f (first x))](recur (next x)(assoc y key (into [] (conj (y key) (first x)))) f))))","problem":63,"user":"503539dee4b0ed9c821488f6"},{"problem":63,"code":"(fn group-seq\n  [f s]\n  (loop [[h & t] s\n         accum {}]\n    (let [new-accum (if (contains? accum (f h))\n                        (assoc accum (f h) (conj (accum (f h)) h))\n                        (assoc accum (f h) [h]))]\n      (if (nil? t)\n          new-accum\n          (recur t new-accum)))))","user":"58152157e4b0f478707a0631"},{"problem":63,"code":"(fn [f values]\n  (into {}\n        (map #(vector (f (first % )) (vec %))\n             (partition-by f (sort values)))))","user":"555a5731e4b0deb715856e44"},{"problem":63,"code":"#(loop[result {}, coll %2]\n   (if-let[item (first coll)]\n     (let[k (%1 item) v (result k [])]\n       (recur (assoc result k (conj v item)) (next coll)))\n     result))","user":"556c70dae4b09a3098a524fd"},{"problem":63,"code":"(fn grouper [f x]\n\t(loop [x x acc {}]\n\t\t(if (empty? x)\n\t\t\tacc\n\t\t\t(let [fir (first x)]\n\t\t\t\t(if (contains? acc (f fir))\n\t\t\t\t\t(recur (rest x) (assoc acc (f fir) (conj (get acc (f fir)) fir)))\n\t\t\t\t\t(recur (rest x) (assoc acc (f fir) [fir])))))))","user":"53703287e4b0fc7073fd6e8f"},{"code":"(fn [fun args]\n  (loop [ret (hash-map)\n         args-left args]\n    (if (empty? args-left)\n      ret\n      (let [farg (first args-left)\n            res (fun farg)]\n        (recur (assoc ret res (conj (get ret res []) farg)) (rest args-left))))))","problem":63,"user":"4f08a8a2535dcb61093f6c3d"},{"code":"(fn mygroup-by [f s]\r\n  (reduce #(assoc %1 (apply f [%2]) (conj (%1 (apply f [%2]) []) %2)) {} s))","problem":63,"user":"4e50c894535dc968683fc4ee"},{"problem":63,"code":"(fn xx [f s]\n  (letfn [(mymap [k v] (hash-map k [v]))]\n    (let [outcome (map f s)]\n      (apply merge-with concat (map mymap outcome s)))))","user":"57b35ecbe4b0fbc9809a277e"},{"problem":63,"code":"(fn [f c]\n  (apply merge-with into\n     (map (fn [v] {(f v) [v]}) c)\n  )\n)","user":"56bb3a4be4b0f26550335951"},{"code":"(fn  [f xs]\n  (apply merge-with concat (for [x xs] {(f x) [x]}))\n  )","problem":63,"user":"52f4fae4e4b05e3f0be25f27"},{"code":"(fn [f x]\n  (loop [xkeys (distinct (map f x)), result {}]\n    (if (empty? xkeys)\n      result\n      (recur (rest xkeys)\n             (assoc result (first xkeys)\n                           (filter #(= (f %) (first xkeys)) x ))))))","problem":63,"user":"4ec5cdb0535d6d7199dd36b8"},{"code":"(fn [f coll]\n  (let [g (map f coll)]\n    (into {} (for [x (set g)] [x (filter #(= (f %) x) coll)]))))","problem":63,"user":"52b43468e4b0c58976d9ad1b"},{"problem":63,"code":"(fn step\n    ([f coll] (step f coll {}))\n    ([f coll m]\n     (if coll\n       (let [k (f (first coll))]\n         (step\n          f\n          (next coll)\n          (assoc m k (conj (get m k []) (first coll)))))\n       m)))","user":"5777cffae4b0979f89651651"},{"code":"#(reduce (fn [m v] (let [k (% v)] (assoc m k (conj (m k []) v)))) {} %2)","problem":63,"user":"525b0b51e4b0cb4875a45d01"},{"problem":63,"code":"(fn groupby [f coll]\n  (reduce #(let [key (f %2)]\n            (assoc %1 key (conj (get %1 key []) %2))) {} coll))","user":"56372c3ce4b0bfe05bf117d1"},{"code":"(fn [f c] (reduce #(update-in % [(f %2)] (comp vec conj) %2) {} c))","problem":63,"user":"4ef2d243535dced4c769f221"},{"problem":63,"code":";; recursive solution works on clojure 1.8 for me, not here (even after replacing defn with fn)\n;;(defn tst [expr col]\n;;  ((fn [proc acc]\n;;     (if (empty? proc)\n;;       acc\n;;       (let [i (first proc)]\n;;         (if (contains? acc (first i))\n;;           (recur (rest proc) (update acc (first i) conj (last i)))\n;;           (recur (rest proc) (assoc acc (first i) (vector (last i))))))))\n;;   (map vector (map expr col) col) {}))\n\n;;(tst #(> % 5) [1 3 6 8])\n\n;; solution \n(fn [expr col]\n  (apply merge-with concat (map (fn [a b] {a [b]}) (map expr col) col)))","user":"5acd08eee4b0e27600da7822"},{"problem":63,"code":"(fn [f xs] (let [fm (fn [x] (vector (f x) x))\n                  fr (fn [out [key val] ] (assoc out key (conj  (out key []) val)))]\n            (->> xs \n                 (map fm)\n                 (reduce fr {})\n             )))","user":"55f9b2b6e4b03cbcff9738c8"},{"problem":63,"code":"(fn [f s]\n  (->> (map #(identity [(f %) %]) s)\n            (sort-by first)\n            (partition-by first)\n            (map #(reduce (fn [a [fst snd]]\n                            (if (contains? a fst)\n                              (update-in a [fst] conj snd)\n                              (assoc a fst [snd])))\n                          {} %))\n            (apply merge)))","user":"56441634e4b0018b46ad8c08"},{"code":"(fn [f s] (reduce #(update-in %1 [(f %2)]\n                                (fn [x] (conj (or x []) %2)))\n                    {} s))","problem":63,"user":"52d6a9c2e4b09f7907dd1365"},{"problem":63,"code":"(fn [f s]\n              (reduce (fn [acc x]\n                        (let [k (f x)\n                              v (get acc k [])]\n                          (assoc acc k (conj v x)))) {} s))","user":"4f9aa2a6e4b0dcca54ed6d0c"},{"problem":63,"code":"(fn [f s]\n ((fn [f s m]\n   (if (empty? s)\n    m\n    (let [v (first s)\n          k (f v)]\n     (recur f \n      (rest s) \n      (assoc m k (vec (conj (m k) v)))))))\n  f s {}))","user":"56532ff4e4b0f9d632dd846e"},{"code":"(fn [f coll]\n  (apply merge-with concat\n              (map #(hash-map (f %) [%])\n                   coll)))","problem":63,"user":"52facb9de4b047fd55837002"},{"problem":63,"code":"(fn [f s]\n    (reduce (fn [m v]\n              (update-in m\n                         [(f v)]\n                         (fn [old] (if (nil? old)\n                                     [v]\n                                     (conj old v)))))\n            {}\n            s))","user":"603d5f2ae4b0d5df2af2230c"},{"code":"(fn [f s]\n  (reduce \n    (fn [result item] \n      (let [k (f item) v (get result k [])] \n        (assoc result k (conj v item)))) {} s))","problem":63,"user":"4e131443535d04ed9115e7d3"},{"problem":63,"code":"(fn [f coll] \n  (reduce #(assoc %1 (f %2) (into (get %1 (f %2) []) [%2])) {} coll))","user":"53e9dce1e4b036ad0777e4bc"},{"problem":63,"code":"(fn [f coll]\n  (reduce \n    (fn [m x]\n      (let [fx (f x) v (get m fx [])] \n        (assoc m fx (conj v x)))) \n    {} \n    coll))","user":"59c94a69e4b0a024fb6ae576"},{"code":"(fn [f xs]\n  (reduce (fn [m x]\n            (let [k (f x)]\n              (assoc m k (conj (get m k []) x))))\n          {}\n          xs))","problem":63,"user":"52487654e4b05ef8e38e63dc"},{"problem":63,"code":"(fn [f s]\n  (reduce\n   (fn [ret v]\n     (assoc ret (f v) (conj (get ret (f v) []) v)))\n  {} s))","user":"5188c249e4b0bdff0e072d54"},{"problem":63,"code":"(fn [f s] (apply merge-with #(vec (concat %1 %2)) (map #(hash-map %1 [%2]) (map f s) s)))","user":"4ea092f4535d7eef308072a6"},{"code":"(fn [f x]\n  (reduce\n   #(update-in % [(f %2)] concat [%2])\n   {}\n   x))","problem":63,"user":"533018b2e4b019098a6f8b56"},{"code":"(fn [f s]\n      (reduce (fn [r [k v]] (update-in r [k] #(conj (or % []) v)))\n              {}\n              (map (fn [x] [(f x) x]) s)))","problem":63,"user":"4e59b02c535d8a8b8723a2a2"},{"problem":63,"code":"(fn [f s]\n  (let [k (set (map f s))]\n    (zipmap k (map (fn [r]\n                     (filter #(= r (f %)) s)) k))))","user":"5a9db5c9e4b0d174b936c7f1"},{"code":"(fn [f coll]\n  (->> coll\n       (map (fn [x] [(f x) x]))\n\t   (reduce (fn [m [res v]] (update-in m [res] (comp vec conj) v)) {})))","problem":63,"user":"5250b7a5e4b0541d1855b83e"},{"problem":63,"code":"(fn [f coll]\n  (reduce (fn [m x]\n            (assoc m (f x) (conj (get m (f x) []) x)))\n          {} coll))","user":"54145050e4b01498b1a719ea"},{"problem":63,"code":"(fn [f xs] (reduce (fn [m x] (update-in m [(f x)] #(conj (vec %) x)))\n                   {} xs))","user":"5d272077e4b092dab7f59c64"},{"problem":63,"code":"(fn grp-by [f s]\n  (reduce (fn [m n]\n            (let [v (f n)]\n              (assoc m v (conj (vec (get m v)) n))))\n          {} s))","user":"5fd92743e4b05ac5b16ea11f"},{"code":"(fn [f s] (apply merge-with \n                 #(into %1 %2)\n                 (map #(hash-map (f %) [%]) s)))","problem":63,"user":"536673a8e4b0243289761e76"},{"problem":63,"code":"(fn [f coll] (apply merge-with concat\n                    (map #(hash-map (f %) [%]) coll)))","user":"5fa74b82e4b0fa27300f3dda"},{"problem":63,"code":"(fn [f col]\n (reduce\n  #(let [key (f %2)]\n     (if (contains? %1 key)\n       (update-in %1 [key] conj %2)\n       (assoc %1 key [%2])))\n  {} col))","user":"576c2ecae4b07c67f59d1fbb"},{"problem":63,"code":"(fn [f xs]\n   (apply merge-with into\n          (for [x xs]\n            {(f x) [x]}\n            )))","user":"4e6a23d0535d8ccf87e9fea0"},{"problem":63,"code":"(fn my-group-by \n  [f s]\n  (loop [col s\n         sol {}]\n    (if (empty? col)\n      sol\n      (let [key (f (first col))]\n        (if (contains? sol key)\n          (recur (rest col)\n                 (assoc sol key (conj (sol key) (first col))))\n          (recur (rest col)\n                 (assoc sol key [(first col)])))))))","user":"5360f043e4b0243289761e3c"},{"problem":63,"code":"#(reduce (fn [a b] (merge-with concat a b))\n         (map (fn [e] {(% e) [e]}) %2))","user":"57d0e185e4b0bd073c202360"},{"code":"(fn our-group-by [f x]\r\n  (let [z (partition-by f (sort-by f x))]\r\n    (zipmap (map #(f (first %)) z)\r\n            z)))","problem":63,"user":"4ef0f1a1535dced4c769f212"},{"code":"(fn my-group-by [f s]\n  (if (empty? s)\n    {}\n    (let [value (first s)\n          key (f value)\n          groups (my-group-by f (rest s))\n          group (vec (groups key))]\n      (assoc groups key (cons value group)))))","problem":63,"user":"5310e7aee4b08068f379ecdc"},{"problem":63,"code":"(fn gb [f xs]\n  (reduce (fn [m x]\n            (let [k (f x)]\n              (println m k x)\n              (if (contains? m k)\n                (assoc m k (conj (get m k) x))\n                (assoc m k [x]))))\n          {}\n          xs))","user":"553dd883e4b0a04f792994e6"},{"code":"(fn [f c] (apply merge-with #(vec (concat %1 %2)) (map (fn [v] {(f v) [v]}) c)))","problem":63,"user":"4db8f6c4535d1e037afb219e"},{"problem":63,"code":"(fn gb\n  ([f coll] (gb f coll {}))\n  ([f coll ans]\n   (if (empty? coll)\n     ans\n     (let [updater #(if (nil? %1) (vector %2) (conj %1 %2))\n           head (first coll) tail (rest coll)]\n     \t(gb f tail (update-in ans [(f head)] updater head)))\n     )\n   )\n  )","user":"5a90395ce4b05369db4d254a"},{"problem":63,"code":"(fn [f x] (apply merge-with concat (map (fn [a b] {a [b]}) (map f x) x)))","user":"5be6d0f8e4b0f319e2d7ec51"},{"problem":63,"code":"(fn gb\n  ([f col] (gb f col {}))\n  ([f col m]\n  (if (empty? col)\n    m\n    (let [fst (first col) result (f fst) container (get m result)]\n      (if (not (nil? container))\n        (recur f (rest col) (assoc m result (conj container fst)))\n        (recur f (rest col) (assoc m result [fst])))))))","user":"55afc197e4b002ce9d5cbc18"},{"code":"(fn [func lst]\n  (letfn [(pu [cum lst]\n              (if-not (seq lst)\n                cum\n                (let [item (first lst) key (func item) val (cum key)]\n                  (pu (assoc cum key (vec (into val [item]))) (rest lst)))))]\n\t\t (pu {} lst)))","problem":63,"user":"50e135f4e4b084616e11c667"},{"problem":63,"code":"(fn [f coll]\n  (persistent!\n   (reduce (fn [ret x]\n             (let [k (f x)]\n               (assoc! ret k\n                       (conj (get ret k []) x))))\n           (transient {}) coll)))","user":"55f2fdc3e4b06e875b46ce51"},{"problem":63,"code":"(fn group-by-function [f s] \n  (reduce \n    #(let [value (f %2) \n           existing (%1 value) \n           new-existing (if (empty? existing) [] existing)]\n       (assoc %1 value (conj new-existing %2)))\n    (hash-map) \n    s))","user":"5654e024e4b0f9d632dd848d"},{"code":"(fn [f s] (reduce #(merge-with into % {(f %2) [%2]}) {} s))","problem":63,"user":"52b42d7ee4b0c58976d9ad19"},{"problem":63,"code":"(fn grp-seq [func vals]\n(into {}\n(map #(vector (func (first % )) (vec %))\n(partition-by func (sort vals)))))","user":"54975e99e4b0b312c081ff72"},{"problem":63,"code":"(fn [f s] \n  (reduce #(assoc %1 (f %2) (conj (apply vector (%1 (f %2))) %2)) {} s))","user":"53710c09e4b0fc7073fd6ea5"},{"problem":63,"code":"(fn [a b](apply merge-with concat (map (partial apply hash-map) \n                                                  (partition 2(interleave (map a b) \n                                                                          (map vector b))))))","user":"54f86b8ce4b01ecee9d88828"},{"code":"(fn [f col]\n    (apply merge-with concat\n           (map #(let [r (f %1)] \n                     {r [%1]})\n                col) ))","problem":63,"user":"53286389e4b09d4e7a9b5504"},{"problem":63,"code":"(fn [f coll]\n  (reduce #(conj %1 \n                 [(f %2) (conj (get %1 (f %2)) %2)]) \n          {} \n          (reverse coll) ))","user":"570eeb66e4b0b0fb43fd06fa"},{"problem":63,"code":"(fn [fun s]\n  (reduce\n   (fn [acc it]\n     (let [k (fun it)]\n       (assoc acc k (conj (acc k []) it))))\n   {}\n   s))","user":"561ba3e5e4b073c65b0ce3eb"},{"problem":63,"code":"(fn [f xs]\n  (reduce (fn [rs x]\n            (let [k (f x)]\n              (assoc rs k (concat (get rs k) (list x)))))\n          nil\n          xs))","user":"551ecb76e4b08d5046aa8a4c"},{"problem":63,"code":"(fn [m f ps](if (empty? ps) m (let [p (first ps) \n                                     k (f p)]\n                                (recur (assoc m k (vec (conj (m k) p))) f (rest ps))))) {}","user":"56b1b59be4b0982f16b37df2"},{"problem":63,"code":"(fn my-group-by [pred coll]\n  (reduce\n    (fn [dict m]\n      (let [ret (pred m)]\n        (assoc dict ret (conj (or (dict ret) []) m))))\n{} coll))","user":"59dfb8dbe4b08badc2a0c4da"},{"problem":63,"code":"(fn [f coll]\n  (reduce\n   (fn [result elem]\n     (let [k (f elem)]\n       (assoc result k (conj (get result k []) elem))))\n   {}\n   coll))","user":"60794173e4b0a637ed78035d"},{"problem":63,"code":"(fn [func x]\n(let [kvals (interleave (map func x) x)]\n  (loop [result {} kvals kvals]\n    (if (empty? kvals)\n    result\n    (recur (if (contains? result (first kvals))\n             (assoc result (first kvals) (conj (get result (first kvals)) (second kvals)))\n             (assoc result (first kvals) (conj [] (second kvals)))) (rest (rest kvals)))))))","user":"54e24a05e4b024c67c0cf7ce"},{"problem":63,"code":"(fn [f coll] (let [map-coll (map f coll)\n                  map-coll-vector (map #(vector %1 %2) map-coll coll)\n                  mapped-vector (reduce (fn [m [k v]] (update-in m [k] (fnil conj []) v)) {} map-coll-vector)]\n              (identity mapped-vector)))","user":"53da8fede4b0e771c30254a3"},{"problem":63,"code":"(fn [f coll]\n  (reduce\n   (fn [ret e]\n     (update-in ret [(f e)] #(into [] (conj % e))))\n   {}\n   coll))","user":"53fe1b42e4b0de5c418485f1"},{"problem":63,"code":"(fn [a_fn a_v]\n    (reduce clojure.set/union (for [x (for [y a_v] (a_fn y)) ] {x (filter #(= x (a_fn %)) a_v ) } ) ))","user":"594a7ed1e4b07ddc2dafae02"},{"problem":63,"code":"(fn [f s] (apply hash-map(mapcat #(list (f (first %)) (apply vector %)) \n                                  (partition-by f (sort s)))))","user":"5a99b83fe4b0d174b936c7aa"},{"problem":63,"code":"#(reduce (fn [r x] (let [k (%1 x)] (assoc r k (conj (get r k []) x)))) {} %2)","user":"5b59d176e4b02d533a91bd86"},{"code":"(fn grp [f s]\n  (reduce\n    #(let [key (f %2)]\n      (assoc %1 key (conj (get %1 key []) %2)))\n    {}\n    s))","problem":63,"user":"4fe8b6afe4b07c9f6fd12c76"},{"code":"(fn [f xs]\n  (reduce\n   (fn [acc el]\n     (assoc acc (f el) (conj (acc (f el) []) el))) {} xs))","problem":63,"user":"534941d1e4b084c2834f4a60"},{"problem":63,"code":"(fn [f coll] \n  (reduce \n   (fn [acc v] \n     (let [k (f v)]\n\t   (assoc acc k (conj (get acc k []) v))))\n  {}\n  coll))","user":"55a12668e4b0acc240e3150b"},{"problem":63,"code":"#(reduce \n  (fn [x y] (let [v (%1 y)] (assoc x v (conj (get x v []) y))))\n   {}\n   %2)","user":"4e6a4950535d8ccf87e9febf"},{"problem":63,"code":"#(apply merge-with into \n        (for [v %2] {(% v) \n          [v]}))","user":"5aa4b961e4b0d174b936c888"},{"problem":63,"code":"(fn [pred coll]\n  \t(reduce\n     \t#(assoc\n           %\n           (pred %2)\n           (conj (get % (pred %2) []) %2))\n     \t{}\n     \tcoll))","user":"4e68c465535d8ccf87e9fe8a"},{"problem":63,"code":"(fn do-group-by\n  [pred coll]\n  (reduce (fn [acc elem]\n            (let [k (pred elem)]\n              (update-in acc [k] (fnil conj []) elem)))\n    {}\n    coll))","user":"59b62f8de4b05c620303ca1f"},{"problem":63,"code":"(fn [func coll]\n   (reduce (fn [accu val]\n             (let [key (first val) value (second val) actual (accu key)]\n               (if (nil? actual)\n                 (conj accu {key [value]})\n                 (conj accu {key (conj actual value)})\n                 )\n               )\n             ) {} ((fn [func coll]\n                     (map (fn [value] [(func value) value]) coll)) func coll) )\n   )","user":"583f1533e4b089d5ab817dc8"},{"problem":63,"code":"(fn goup-seq [f s1]\n  (loop [acc {} s s1]\n    (let [v (first s)\n          k (f v)\n          result (if (acc k)\n                   (update-in acc [k] #(conj % v))\n                   (assoc acc k [v]))]\n      (if (seq (rest s))\n        (recur result (rest s))\n        result))))","user":"55f8fd70e4b03cbcff9738bc"},{"code":"(fn zoup-by [f coll]\n  (if-let [s (seq coll)]\n    (reduce #(merge-with concat %1 {(f %2) (vector %2)}) {} s)))","problem":63,"user":"4e5fdd68535d8ccf87e9fe4f"},{"problem":63,"code":"(fn [f s] (reduce #(let [k (f %2) o (%1 k [])] (assoc %1 k (conj o %2))) {} s))","user":"57ccedaae4b0c746388ab88e"},{"code":"(fn group [f s]\n  (loop [the-map {}\n         elements s]\n    (if (empty? elements)\n      the-map\n      (let [first-el (first elements)\n            bucket (f first-el)\n            current (get the-map bucket [])\n            new-map (assoc the-map bucket (conj current first-el))]\n        (recur new-map (rest elements))))))","problem":63,"user":"50d882d4e4b01f0871336e69"},{"code":"(fn [f s]\n    (apply merge-with concat (map #(hash-map (f %) [%]) s)))","problem":63,"user":"534efe66e4b084c2834f4ac1"},{"problem":63,"code":"(fn grp [f s]\n  (when (> (count s) 0)\n   (let [c (f (first s))]\n     (assoc\n      (grp \n       f \n       (filter #(not= c (f %)) s)\n      )\n      c\n      (filter #(= c (f %)) s)\n     )\n   )\n  )\n)","user":"5c0d0537e4b0bdcf453d173d"},{"problem":63,"code":"(fn gb [f s]\n  (apply merge-with into\n         (map #(hash-map (f %) [%]) s)))","user":"59d8f23ae4b0ef0a1e9b5c49"},{"code":"(fn gb [f s]\n  (loop [m {} s1 s]\n    (if (= 0 (count s1))\n        m\n      (let [ val (first s1)\n             key-val (f val)\n             current (m key-val)]\n        (recur (assoc m key-val (conj (if (nil? current) [] current) val)) (rest s1))))))","problem":63,"user":"51622fb8e4b009fba0926e3f"},{"code":"(fn group [f xs]\n    (reduce (fn [m [k v]] (assoc m k (concat (m k) v)))\n            {}\n            (map #(vector (f %) [%]) xs)))","problem":63,"user":"4e9fd521535d7eef3080729a"},{"problem":63,"code":"(fn [f c]\n  (reduce (fn [result input]\n            (let [k (f input)\n                  v (get result k [])]\n              (assoc result k (conj v input))))\n          {} c))","user":"5cbb0436e4b026601754b9cc"},{"code":"(fn [f s ]\n  (loop [m {} s2 s]\n  (if (empty? s2) m\n    (let [ v (first s2) k (f v)] \n      (if-not (m k) \n          (recur (assoc m k []) s2)\n          (recur (assoc m k (conj (m k) v)) \n                      (rest s2)))))))","problem":63,"user":"4e1047ad535d04ed9115e7bf"},{"code":"(fn mgb [f s]\n  (let [p (set (map f s))]\n  (apply hash-map (interleave p (map (fn [z] (vec (filter #(not (nil? %)) (map #(if (= z (f %)) %) s)))) p)))))","problem":63,"user":"4ea7999e535d7eef308072ee"},{"problem":63,"code":"(fn [f coll]\n         (reduce (fn [res item]\n                   (update-in res [(f item)] (fn [v] (if (empty? v) [item] (conj v item)))))\n                 {}\n                 coll))","user":"531bf76fe4b08068f379ed96"},{"problem":63,"code":"(fn groupby [f coll]\n  \t(apply merge-with\n            into \n            (for [i coll] {(f i) [i]})))","user":"5ff93da9e4b06df49cee14af"},{"problem":63,"code":"(fn[f l] \n    (reduce \n        (fn[a x] \n            (assoc a (f x) (conj (get a (f x) []) x)))\n        {}\n     \tl))","user":"57b9fc74e4b0fbc9809a27fb"},{"problem":63,"code":"(fn \n  [pred coll]\n  (->>  coll\n        (map (fn [item] {(pred item) [item]}))\n        (apply merge-with concat)))","user":"5586f418e4b059ccff29b1de"},{"code":"(fn [f coll]\n  (reduce #(assoc % (f %2) (conj (or (% (f %2)) []) %2)) {} coll))","problem":63,"user":"5005b57de4b0678c553fc46a"},{"code":"(letfn [(g                                                                                                                                                                                                                                   \n          ([f l] (g f l {}))                                                                                                                                                                                                                 \n          ([f l m]                                                                                                                                                                                                                           \n             (let [h (first l)                                                                                                                                                                                                               \n                   t (rest l)                                                                                                                                                                                                                \n                   k (f h)                                                                                                                                                                                                                   \n                   v (if (m k)                                                                                                                                                                                                               \n                       (conj (m k) h)                                                                                                                                                                                                        \n                       [h])                                                                                                                                                                                                                  \n                   n (assoc m k v)]                                                                                                                                                                                                          \n               (if (empty? t)                                                                                                                                                                                                                \n                 n                                                                                                                                                                                                                           \n                 (g f t n)))))]                                                                                                                                                                                                              \n  g)","problem":63,"user":"4db342d7535df7e46ed9b6cd"},{"code":"#(let [p (partition-by % (sort %2))] \n   (apply hash-map (interleave (map (fn [x] (% (first x))) p) p)))","problem":63,"user":"515e8ce2e4b049add99a053d"},{"problem":63,"code":"(fn [f s]\n  (reduce #(let [result (f %2)] (if (contains? %1 result) (assoc %1 result (conj (get %1 result) %2)) (assoc %1 result [%2]) ) )\n          {}\n          s)\n)","user":"5da975b9e4b000c986472c32"},{"problem":63,"code":"#(apply merge-with into (for [c %2] {(% c) [c]}))","user":"575d16f8e4b02ea114799377"},{"code":"(fn [f s]\n  (reduce (fn [result x]\n            (let [val (f x)]\n              (assoc result val\n                     (conj (get result val []) x)))) {} s))","problem":63,"user":"4f2893d0e4b0d6649770a019"},{"problem":63,"code":"(fn [f c] (apply merge-with into (map #(assoc {} (f %) [%]) c)))","user":"5b0546eae4b0cc2b61a3bd7e"},{"problem":63,"code":"(fn [f seqq]\n  (reduce #(if \n             (contains? %1 (f %2)) \n             (conj %1 [(f %2) (conj (get %1 (f %2)) %2)]) \n             (conj %1 [(f %2) [%2]]))\n          {} seqq))","user":"6088395de4b0ae75613dcee2"},{"problem":63,"code":"(fn my-group-by [f s]\n  (letfn [( my-group [indexed-results results]\n            (cons \n              (first results) \n              (cons  \n                (map \n                  #(get s (first %)) (filter #(= (first results) (second %))  indexed-results))\n                (if-not (empty? (rest results))\n                  (lazy-seq (my-group indexed-results (rest results)))\n                  '()))))]\n    (let [indexed-results (map-indexed #(list % (f %2)) s)\n          results (distinct  (map second indexed-results))] \n      (apply hash-map (my-group indexed-results results)))))","user":"52eaba10e4b09f7907dd14c2"},{"code":"(fn my-gb [f coll]\n    (loop [m {}\n           [x & xs] coll]\n        (if (= nil x)\n            m\n            (let [k (f x)]\n                (recur (assoc m k (conj (get m k []) x)) xs)))))","problem":63,"user":"5132c6f0e4b021281ec7b6d3"},{"problem":63,"code":"(fn [f ss]\n  (reduce (fn [m i] (update-in m [(f i)] (comp vec conj) i))\n          {} ss))","user":"520e37cfe4b066f3ea161c96"},{"code":"(fn [f coll]\n    (reduce #(assoc % (f %2) (conj (or (% (f %2)) []) %2))\n            {} coll))","problem":63,"user":"4ff67852e4b0678c553fc37e"},{"code":"(fn [f xs] \n  (reduce #(assoc %1 (f %2) (conj (get %1 (f %2) []) %2)) {} xs))","problem":63,"user":"513d121fe4b0e544971636a2"},{"problem":63,"code":"(fn [f coll] (reduce #(assoc %1 (f %2) (conj (%1 (f %2) []) %2)) {} coll))","user":"59abd1d8e4b08cbb53654da4"},{"problem":63,"code":"(fn [f c]\n  (reduce #(assoc % (f %2) (concat (% (f %2)) [%2])) {} c))","user":"58f44c07e4b0438e51c2ceb7"},{"code":"(fn [f s] (apply merge-with into (map #(hash-map (f %) [%]) s)))","problem":63,"user":"52ffb7f2e4b0d8b024fd370b"},{"code":"(fn [f s]\r\n  (reduce \r\n    (fn [ret x]\r\n      (let [k (f x)]\r\n        (assoc ret k (conj (get ret k []) x))))\r\n    {} s))","problem":63,"user":"4dc986d0535d5973398f9285"},{"problem":63,"code":"(fn [f v] (reduce (fn [m [k v]]\n                   (assoc m k (conj (get m k []) v)))\n                  {}\n                  (map #(vec [(f %) %]) v)))","user":"5540fe42e4b0a04f7929950a"},{"problem":63,"code":"(fn [f sq] (loop [m {} rst sq]\n             (if (empty? rst)\n               m\n               (let [h (first rst) fh (f h)]\n                 (recur (assoc m fh (conj (get m fh []) h))(rest rst) )))))","user":"58225587e4b04b46fc4b0f94"},{"problem":63,"code":"(fn [f s]\n   (reduce (fn [r i]\n             (let [a (f i)]\n               (assoc r a (vec (conj (get r a) i)))))\n           {} \n           s))","user":"5d5c2730e4b09db18d4482ea"},{"problem":63,"code":"(fn [func coll] (apply merge-with into (map (fn [it] {(func it) [it]}) coll)))","user":"588f500ae4b00487982d51a4"},{"problem":63,"code":"(fn [f coll]\n  (reduce\n   (fn [acc v]\n     (let [f-applied (f v)\n           f-applieds-indexed (get acc f-applied)]\n       (if f-applieds-indexed\n         (assoc acc f-applied (conj f-applieds-indexed v))\n         (assoc acc f-applied [v]))))\n   {}\n   coll))","user":"608910a8e4b0ae75613dceed"},{"problem":63,"code":"(fn gg [f v]\n  (reduce\n  (fn [m e]\n(update-in m [(f e)]\n  (fn [d] (if (empty? d) [e] (conj d e)))))\n   {}\n   v)\n)","user":"552d2e4fe4b076ab5578f7e1"},{"code":"(fn gb [f s]\n  (reduce (fn [r e]\n            (let [k (f e)]\n              (if (contains? r k)\n                (assoc r k (conj (r k) e))\n                (assoc r k [e])))) {} s))","problem":63,"user":"5348cab4e4b084c2834f4a5e"},{"problem":63,"code":"(fn [f s] (into {} (map #(vector (f (first %)) (vec %)) (partition-by f (sort s)))))","user":"59e18b9be4b08badc2a0c50f"},{"code":"(fn [f c] (reduce (partial merge-with concat) (map #(hash-map (f %) [%]) c)))","problem":63,"user":"503354c3e4b0c6c1199c710c"},{"problem":63,"code":"(fn[f col]\n  (reduce #(assoc %1 (f %2) (conj (apply vector (%1 (f %2))) %2)) {} col))","user":"5bbbba29e4b0a20761a23609"},{"code":"#(apply merge-with concat (for [v %2] {(% v) [v]}))","problem":63,"user":"522a01ade4b0590a43906ced"},{"code":"(fn [f coll]\n  (reduce\n   (fn [acc x]\n     (merge-with into acc {(f x) [x]}))\n   {} coll))","problem":63,"user":"5224a46ce4b01819a2de42e5"},{"problem":63,"code":"(fn mygroup-by [f stuff]\n  (let [outputs (distinct (map #(f (first %))\n                               (partition-by f stuff)))]\n    (zipmap outputs\n            (map (fn [output]\n                   (filter #(= (f %) output) stuff))\n                 outputs))))","user":"5b2a559be4b063e2438bcc74"},{"code":"(fn [f, xs]\n  (reduce\n   (fn [acc, x]\n     (assoc acc (f x)\n       (conj\n        (get acc (f x) [])\n        x)))\n   {}\n   xs))","problem":63,"user":"51365524e4b04ac1f358dd52"},{"problem":63,"code":"(fn [f s]\n  (reduce \n  \t(fn [a e]\n    \t(let [k (f e)\n              v (get a k [])]\n    \t\t(assoc a k (conj v e)))) \n  \t{} \n  \ts))","user":"53161a56e4b08068f379ed3e"},{"problem":63,"code":"(fn [f v] (reduce #(let [k (f %2) v %2]\n                      (if (contains? %1 k)\n                        (assoc %1 k (conj (%1 k) v))\n                        (assoc %1 k [v]))) {}  v))","user":"5ce2b15fe4b0a17bb84e2b2c"},{"problem":63,"code":"#(reduce (fn [m i] (update-in m [(%1 i)] concat [i])) {} %2)","user":"550aeddae4b06e50f9beb135"},{"code":"(fn [x y]\n  (into {}\n    (for [i (distinct (map x y))]\n      [i (for [j y :when (= (x j) i)] j)]\n)))","problem":63,"user":"5078300de4b0fc74642bff66"},{"problem":63,"code":"; (fn [f xs] (reduce (fn [m v] (update-in m [(f v)] #(if %1 (conj %1 v) [v]))) {} xs))\n\n; minitrue\n; (fn [f xs] (reduce #(update-in % [(f %2)] (fnil conj []) %2) {} xs))\n\n; use fnil in mine\n;(fn [f xs] (reduce (fn [m v] (update-in m [(f v)] (fnil conj [])  v)) {} xs))\n\n; daowen\n(fn [f vs] (reduce #(merge-with into % {(f %2) [%2]}) {} vs))","user":"5a544eeee4b05d388ecb6c24"},{"problem":63,"code":"(fn group-seq\n  [f s]\n  (reduce\n   (fn [m itm]\n     (assoc m (f itm)\n            (conj\n             (or (get m (f itm)) [])\n             itm)))\n   {} s))","user":"5aeca4c9e4b0cc2b61a3bc0a"},{"problem":63,"code":"(fn [f s]\n  (reduce #(let [x (f %2)]\n             (assoc % x (conj (% x []) %2)))\n          {} s))","user":"594880ade4b07ddc2dafadc2"},{"code":"#(apply merge-with concat\n  (map (fn [x] {(% x) [x]}) %2))","problem":63,"user":"4db3393e535df7e46ed9b6cc"},{"code":"(fn [f s]\n  (into {}\n    (for [r (map f s)]\n      {r (filter #(= r (f %)) s)})))","problem":63,"user":"4fde492be4b05e33b9224f8a"},{"problem":63,"code":"(fn mm[f arg]\n  (reduce (fn [ret x]\n            (let [k (f x)]\n              (assoc ret k (conj (get ret k []) x)))) \n          {} \n          arg))","user":"535f0cbde4b04ce2eb3ed2d9"},{"code":"(fn [f coll]\n  (reduce\n   (fn [ret x]\n     (let [k (f x)]\n       (assoc ret k (conj (get ret k []) x))))\n   {}\n   coll))","problem":63,"user":"4ed98b40535d10e5ff6f5307"},{"code":"(fn [f s]\n    (reduce (fn [m x]\n              (let [k (f x)]\n                (assoc m k (conj (get m k []) x))))\n            {}\n            s))","problem":63,"user":"4dad938fc9a9d6ed1b99dc57"},{"problem":63,"code":"(fn [f col]\n  (reduce\n   #(assoc %1 (f %2) (conj (%1 (f %2) []) %2))\n   {}\n   col))","user":"532ecd44e4b019098a6f8b49"},{"code":"(fn my-group-by3 [f xs]\n  (loop [col {} ys xs]\n    (if (empty? ys)\n      col\n      (recur (merge-with concat col\n                         {(f (first ys)) (list (first ys))} )\n             (rest ys)))))","problem":63,"user":"4ef6f5ea535dced4c769f250"},{"problem":63,"code":"(fn [f s]\n    (loop [m {}\n           xs s]\n      (if (empty? xs)\n        m\n      (recur (update-in m [(f (first xs))] (fnil conj []) (first xs)) (rest xs)))))","user":"4eb47bb1535d7eef30807362"},{"problem":63,"code":"(fn [f coll]\n  (reduce (fn [agg v] (update-in agg [(f v)] #(conj (or % []) v))) {} coll))","user":"5f431d32e4b0955706451fb5"},{"problem":63,"code":"(fn grp\n  [f l]\n  (loop [l l out {}]\n    (if (empty? l) out\n      (let [v (first l)\n            k (f v)]\n        (recur (rest l) (assoc out k (conj (out k []) v)))))))","user":"551afdf8e4b07993ea3788cb"},{"code":"(fn [f s]\r\n  (reduce\r\n   #(assoc % (f %2)\r\n           (conj (get % (f %2) []) %2))\r\n   {}\r\n   s))","problem":63,"user":"4e597b2c535d8a8b8723a29d"},{"code":"(fn gr [f ls]\n  (reduce\n      #(if (contains? % (f %2))\n        (conj (dissoc % (f %2)) (hash-map (f %2) (conj (get % (f %2)) %2)))\n        (conj % (hash-map (f %2) [%2])))\n    {} ls))","problem":63,"user":"51aefceee4b09397d5109797"},{"problem":63,"code":"(fn [fnc coll] \n   (reduce \n     (fn [out item] \n       (let [key (fnc item)\n             actual-value (get out key)]\n         (assoc out key \n           (if (vector? actual-value)\n             (conj actual-value item)\n             (vector item)))))\n     {} coll))","user":"5582dfb6e4b05c286339e10d"},{"problem":63,"code":"(fn r [f coll]\n  (->>(map #(let [result (f %)]\n        \t[result [%]]) coll)\n      (reduce (fn [acc [a [b]]] (if (acc a) (update-in acc [a] conj b) (assoc acc a [b]) ))\n              \n              {})\n  )\n)","user":"5a7f77fae4b00b71e582a041"},{"problem":63,"code":"(fn [f ls]\n  (apply hash-map\n         ((fn _group-by [f ls]\n            (if (empty? ls)\n              ()\n              (let [val (f (first ls)),\n                    same (fn [x] (= (f x) val))]\n                (concat (list val (filter same ls))\n                        (_group-by f (filter #(not (same %)) ls))))))\n          f ls)))","user":"547584d9e4b0c51c1f4d729b"},{"code":"#(reduce (fn [m v] (update-in m [(% v)] concat [v])) {} %2)","problem":63,"user":"4e6b3fc8535d8ccf87e9ff0f"},{"code":"(fn [f s]\r\n  (apply (partial merge-with concat)\r\n    (for [x s]\r\n      {(f x) [x]})))","problem":63,"user":"4dcd818e535d5973398f929d"},{"code":"(fn [f s] (reduce \n            (fn [m [k v]] (assoc m k (conj (get m k []) v)))\n            {}\n            (map #(vector (f %) %) s)))","problem":63,"user":"4e8ad247535d65386fec2111"},{"problem":63,"code":"(fn [f col]\n           (reduce (fn [m [k v]]\n             (if-let [old (get m k)]\n                (assoc-in m [k (count old)] v)\n                (assoc m k [v]))) {} (for [x col :let [fx (f x)]] [fx x])))","user":"52f53589e4b05e3f0be25f2c"},{"problem":63,"code":"#(apply merge-with concat \n             (map \n              (fn [n] \n                (hash-map (%1 n) [n])) %2))","user":"59dd38a8e4b0a0ac046f2503"},{"problem":63,"code":"(fn my-partition-1 [f v]\n  (loop [v v\n         acc {}]\n    (cond\n      (empty? v) acc\n      :else (recur (rest v) (update-in acc\n                                       [(f (first v))] (fnil conj []) (first v))))))","user":"505d1b01e4b0e6aca564be04"},{"code":"#(apply merge-with concat (for [x %2\n                                \t:let [y (%1 x)]]\n                            \t{y [x]}))","problem":63,"user":"510d9d61e4b078ea71921141"},{"problem":63,"code":"(fn\n  [f x]\n  (let [process (fn [processed current]\n                   (let [key (f current)]\n                     (assoc processed key (conj (get processed key []) current)\n                     )))]\n    (loop [result {}\n           current (first x)\n           remaining (rest x)]\n      (if (= nil current)\n        result\n        (recur (process result current) (first remaining) (rest remaining))))))","user":"53ac4719e4b047364c04445c"},{"problem":63,"code":"(fn group-by-home-made\n  [f coll]\n  (reduce\n   #(let [k (f %2)]\n        (assoc %1 k (conj (or (get %1 k) []) %2)))\n   {}\n   coll))","user":"5ed52854e4b016b56eae05d2"},{"problem":63,"code":"(fn [f coll]\n  (reduce #(assoc-in %1 [(f %2)]\n                     (if-let [a (%1 (f %2))]\n                       (conj a %2)\n                       [%2])) {} coll))","user":"57ed19a3e4b0bfb2137f5b8e"},{"problem":63,"code":"(fn grp [f s]\n  (if (empty? s)\n    {}\n    (let [g (grp f (rest s))]\n        (assoc g (f (first s)) (cons (first s) (get g (f (first s))))))))","user":"545801f6e4b01be26fd74615"},{"problem":63,"code":"#(apply merge-with concat\n              (map ( fn[cc] { (first cc) [(second cc)]} )\n              (partition 2\n              (interleave  (map %1 %2) %2)))\n  )","user":"598085e6e4b021a7a535fdd3"},{"problem":63,"code":"(fn [f s]\n  (reduce (fn [result input]\n            (merge-with concat result {(f input) [input]}))\n          {} s))","user":"555521a5e4b0deb715856e12"},{"problem":63,"code":"(fn [f coll]\n  (reduce (fn [m x]\n            (let [result (f x)]\n              (update-in m [result]\n                (fnil #(conj %1 %2) [] nil) x)))\n          {}\n          coll))","user":"56a79eb0e4b07966d5a8a05d"},{"code":"(fn [f coll]\n  (let [\n    groups (->> coll\n      (map (fn [i] [(f i) i]))\n      (map first) set)]\n    (apply merge\n      (map \n        (fn [group] {group, (filter (fn [x] (= (f x) group)) coll)})\n        groups))))","problem":63,"user":"4e80e0f2535db62dc21a62b8"},{"code":"(fn [pred xs] \n  (reduce (fn [coll x]\n            (assoc coll (pred x) (vec (conj (coll (pred x)) x))))\n            {} \n            xs))","problem":63,"user":"52fa4f48e4b047fd55836ff7"},{"problem":63,"code":"(fn z[group-by-fn s]\n    (reduce (fn[accum item]\n              (let [my-key (group-by-fn item)\n                  ]\n              (assoc accum my-key\n                     (conj (get accum my-key []) item ))))\n                {} s\n                ))","user":"539f9f79e4b0ca733b97449e"},{"code":"(fn [pred xs]\n  (let [results (distinct (map pred xs))]\n    (into {}\n      (map vector results \n        (map \n          (fn [result] \n            (filter #(= result (pred %)) xs)\n          ) results\n        )\n      )\n    )\n  )\n)","problem":63,"user":"5102ac9de4b00c483ae176fa"},{"problem":63,"code":"(fn gb [f coll]\n  (let [coll (map (fn [x y] [x y]) (map f coll) coll)]\n  (reduce #(if (contains? %1 (first %2))\n             (update-in %1 [(first %2)] conj (second %2))\n             (conj %1 {(first %2) (vector (second %2))}))\n          \n          {}\n          coll)))","user":"5532a04ee4b09218d5f44f82"},{"code":"(fn [f s]\n    (reduce #(update-in %1 [(f %2)] (fnil (fn [v] (conj v %2)) [])) {} s))","problem":63,"user":"51c3c6a6e4b0851ac09658f8"},{"code":"(fn [f c]\n  (reduce (fn [hm v]\n    (let [k (f v)]\n      (assoc hm k (conj (get hm k []) v)))) {} c))","problem":63,"user":"4f89d489e4b033992c121c7e"},{"code":"(fn [p s]\n  (apply (partial merge-with concat)\n         (map #(hash-map (p %) [%]) s)))","problem":63,"user":"4ff9d4e5e4b0678c553fc3b0"},{"problem":63,"code":"(fn [kf s]\n  (reduce (fn [m x]\n                     (let [k (kf x)]\n                       (if (contains? m k)\n                         (update-in m [k] conj x)\n                         (assoc m k [x]))))\n                   {} s))","user":"58949f8de4b00487982d525e"},{"problem":63,"code":"(fn [f col] (reduce (fn [acc x] (let [k (f x)\n                                      currvals (get acc k [])\n                                      newvals (conj currvals x)]\n                                  (assoc acc k newvals)))\n                                  {} col))","user":"5592bf9fe4b0c79f6e1db933"},{"problem":63,"code":"(fn my-group-by [f coll]\n  (apply merge-with into (map #(hash-map (f %) [%]) coll)))","user":"57407ab3e4b05c31a32c0854"},{"problem":63,"code":"(fn [f coll]\n  (reduce\n    (fn [m v]\n      (let [k (f v)\n            pv (get m k)]\n        (assoc m k (if (nil? pv) [v] (conj pv v)))))\n    {}\n    coll))","user":"550b502ae4b06e50f9beb13f"},{"problem":63,"code":"(fn __ [f xs]\n  (loop [xs xs out {}]\n    (if (seq xs)\n      (let [v (first xs)\n            k (f v)]\n        (recur (rest xs)\n               (conj out [k (concat (out k) [v])])))\n      out)))","user":"526759b3e4b03e8d9a4a715b"},{"code":"#(reduce\r\n  (fn [m x]\r\n    (let [k (%1 x)]\r\n      (assoc m k (conj (get m k []) x))))\r\n  {}\r\n  %2\r\n)","problem":63,"user":"4df3d4f4535d08e6dec9fe2c"},{"code":"(fn [f s] (reduce #(update-in %1 [(f %2)] concat [%2]) {} s))","problem":63,"user":"4e5f034b535d8a8b8723a2d9"},{"problem":63,"code":"(fn [f xs] (reduce (fn [m x] (assoc m (f x) (conj (m (f x) []) x))) {} xs))","user":"5de12192e4b0948ae9d9aded"},{"problem":63,"code":"(fn [f s] (reduce (fn [acc x] (let [k (f x)]\n                                (if (contains? acc k)\n                                  (assoc acc k (conj (acc k) x))\n                                  (assoc acc k [x]))))\n                  {}\n                  s))","user":"5ee93720e4b029a2061bbeb7"},{"problem":63,"code":"(fn group [f xs]\n  (reduce\n   (fn [grps item]\n     (let [key (f item)]\n       (assoc grps key (conj (grps key []) item))))\n   {}\n   xs))","user":"5a566e8fe4b05d388ecb6c51"},{"problem":63,"code":"(fn [f coll]\n  (reduce\n    (fn [acc x] (assoc acc (f x) (conj (acc (f x) []) x)))\n    {}\n    coll))","user":"54b83ae9e4b0ed20f4ff6e95"},{"problem":63,"code":"(fn [f xs]\n  (->> xs\n       (map #(hash-map (f %1) [%1]))\n       (apply merge-with concat)))","user":"54d22860e4b0e8a36923e5ef"},{"problem":63,"code":"#(reduce (fn [l [k v]] (assoc l k (conj (get l k) v))) {} (map (fn [x] [(% x) x])  (reverse %2)))","user":"51e1c176e4b06a68e693eafb"},{"problem":63,"code":"(fn my-group-by [f coll]\n  (letfn [(add-to-group [result el]\n                        (let [group-key (f el)\n                              key-exists? (contains? result group-key)]\n                          (if key-exists?\n                            (assoc result group-key (conj (get result group-key) el))\n                            (assoc result group-key [el]))))]\n    (reduce add-to-group {} coll)))","user":"52b9e920e4b07a9af57922c9"},{"code":"(fn [f xs]\n   (into {}\n   (map \n        (fn [x] [x (into [] (filter #(= x (f %)) xs))])\n        (distinct (for [x xs] (f x)))    \n   )\n   )\n )","problem":63,"user":"51897709e4b0288ada3dbdaa"},{"problem":63,"code":"(fn [f coll]\n  (letfn [(inner [m [x & xs]]\n    (if (nil? x)\n      m\n      (let [v (f x)]\n      (inner (assoc m v (conj (get m v []) x)) xs))))]\n    (inner {} coll)))","user":"518ba795e4b0f028e99addf0"},{"code":"(fn seq-group [f coll]\n  (let [keys (set (map f coll))\n        values (for [y keys]\n                 (for [x coll\n                       :when (= (f x) y)]\n                   x))]\n    (zipmap keys values)))","problem":63,"user":"4fcaf7a4e4b0ee37620e1857"},{"code":"(fn[f lst] (reduce (fn add2map [a-map val]\n            (let [result (f val)]\n                (assoc a-map result (conj (a-map result []) val)))) {} lst))","problem":63,"user":"52bc6cb2e4b07a9af57922f5"},{"problem":63,"code":"(fn [f s]\n  (reduce\n    #(conj % [(f %2) (conj (% (f %2) []) %2)]) {} s))","user":"54eee3a3e4b024c67c0cf879"},{"code":"(fn [f c]\n   (reduce\n      #(let [k (f %2)]\n        (assoc % k (conj (get % k []) %2)))\n    {} c)\n)","problem":63,"user":"4f039a8b535dcb61093f6b36"},{"code":"(fn [f s]\n                   (->> (map #(hash-map (f %) [%]) s)\n                     (apply merge-with (comp vec concat))))","problem":63,"user":"536f871de4b0fc7073fd6e7f"},{"problem":63,"code":"(fn\n  [f coll]\n  (apply merge-with #(conj %1 (first %2)) (map (fn [x] {(f x) [x]}) coll)))","user":"594783bee4b07ddc2dafada1"},{"code":"(fn [f coll] (reduce #(merge-with concat %1 {(f %2) (vector %2)}) {} coll))","problem":63,"user":"4e6fa38b535d5021c1a89622"},{"code":"(fn [f x] (loop [x x \n                             acc {}]\n                        (if (empty? x)\n                          acc\n                          (recur \n                           (rest x)\n                           (merge acc \n                                  ((juxt f \n                                         #(concat \n                                      \t\t\t(get acc (f %) [])\n                                           \t[%]))\n                                   (first x)))))))","problem":63,"user":"4f8b27b3e4b02e764a0a5179"},{"problem":63,"code":"(fn [f s]\n  (into {} (for [k (distinct (map f s))]\n             {k (filterv #(= k (f %)) s)})))","user":"52e1c276e4b09f7907dd142b"},{"problem":63,"code":"#(apply merge-with into (for [value %2] {(% value) [value]}))","user":"5f5f9483e4b02876ed9fcff8"},{"problem":63,"code":"(fn my-group-by\r\n  [f coll]\r\n  (reduce\r\n   (fn [result value]\r\n       (let [key (f value)]\r\n         (assoc\r\n          result\r\n          key\r\n          (conj (get result key []) value))))\r\n   {}\r\n   coll))","user":"56f514cee4b046a417f92068"},{"code":"(fn hey [c s] (apply merge-with concat (map #(hash-map (c %) (cons % [])) s)))","problem":63,"user":"52e17e66e4b09f7907dd1423"},{"problem":63,"code":"(fn [f coll]\n   (reduce\n    (fn [acc v]\n      (let [k (f v)]\n       (if (contains? acc k)\n         (assoc acc k (conj (acc k) v))\n         (assoc acc k [v]))))\n    {}\n    coll))","user":"576b4e6be4b0a07e8fc1812b"},{"problem":63,"code":"(fn [f c] (apply merge-with concat (map #(hash-map (f %1) [%1]) c)))","user":"574a546ee4b02ea1147991f6"},{"problem":63,"code":"(fn [f xs]\n  (reduce (fn [acc x]\n            (update-in acc [(f x)] (fnil conj []) x))\n          {}\n          xs))","user":"5ce077e9e4b0a17bb84e2b0c"},{"problem":63,"code":"(fn [f ls]\n  (let [kys (map f ls)\n        vls (map (fn [k]\n                   (filter #(= k (f %)) ls))\n                 kys)]\n    (apply assoc {} (interleave kys vls))\n    )\n  )","user":"5727031ee4b0c5bde472c12f"},{"problem":63,"code":"(fn [fun coll] (apply (partial merge-with concat) (map hash-map (map fun coll) (map list coll))))","user":"561ca2eae4b064ca9f4b169b"},{"problem":63,"code":"(fn [f coll] (reduce (fn [m v] (let [k (f v)] (assoc m k (conj (get m k []) v)))) {} coll))","user":"5b5e7953e4b0c6492753e6d9"},{"code":"(fn grp-seq [f s]\n  (into {}\n        (map #(vector (f (first % )) (vec %))\n             (partition-by f (sort s)))))","problem":63,"user":"51ab1718e4b04e3dc0c27b2f"},{"problem":63,"code":"#(reduce (fn [m [k v]] (assoc m k (conj (m k []) v))) {} (map (juxt %1 identity) %2))","user":"54f0d3fde4b024c67c0cf8a6"},{"code":"(fn [f c]\n  (apply merge-with concat (map #(hash-map (f %) [%]) c)))","problem":63,"user":"4fbd24d2e4b081705acca2ff"},{"problem":63,"code":"(fn my-group-by [f args]\n    (let [mini-group-by (fn [f a m] \n                        (let [k (f a)\n                              v a]\n                            (assoc m k[v])))]\n                        (apply merge-with into (map #(mini-group-by f % {}) args))))","user":"5b477969e4b02d533a91bc6f"},{"problem":63,"code":"(fn [f mp] (letfn [(upd [m x v] (assoc m x (vec (conj (get m x) v))))]\n             (reduce #(upd % (f %2) %2) {} mp)))","user":"5d1bbef0e4b02ea6f0fb6984"},{"problem":63,"code":"(fn [f v]\n  (reduce\n    (fn [m i]\n      (let [fi (f i)\n            cv (m fi)]\n        (if (not (nil? cv))\n          (assoc m fi (conj cv i))\n          (assoc m fi [i]))))\n    {}\n    v))","user":"55c4cda5e4b0e31453f649a5"},{"code":"(fn group [f s](apply merge-with #(conj %1 (first %2)) \n                      (map #(hash-map (f %) [%]) s)))","problem":63,"user":"526a3412e4b03e8d9a4a721e"},{"code":"(fn [f coll]\n(apply hash-map \n  (mapcat #(vector (ffirst %) (vec (map second %)))\n(partition-by first \n  (sort-by first (map #(vector (f %) %) coll))))))","problem":63,"user":"4dcfbc44535d5973398f92a7"},{"code":"(fn [f list] \n  (let [results (map #(hash-map (f %) (vector %)) list)]\n    (apply (partial merge-with concat) results)))","problem":63,"user":"4ff83003e4b0678c553fc396"},{"problem":63,"code":";; not easy\n\n(fn my-group-by [f s]\n  (apply merge-with (fn [merged new] (into [] (concat merged new)))\n         (map (fn [k v] {k [v]}) (map f s) s)))\n\n;; not so easy...\n;; revisit this later to better understand what is being asked\n;; ... okay, the challenge here is to re-implement `group-by`\n#_(fn my-group-by \n  [f coll]  \n  (persistent!\n   (reduce\n    (fn [ret x]\n      (let [k (f x)]\n        (assoc! ret k (conj (get ret k []) x))))\n    (transient {}) coll)))","user":"5fb68f09e4b08cb800c85b58"},{"code":"(fn my-group [f s] \n  (let [groups\n        (partition-by first (sort-by first (map (fn [item] [(apply f [item]) item]) s)))]\n    (reduce merge\n            (for [group groups]\n              {(first (first group)) (reduce #(conj %1 (last %2)) [] group)})\n    )))","problem":63,"user":"514721c6e4b0d520409ed392"},{"code":"(fn [f s] (apply hash-map\n                 (mapcat (juxt #(-> % first first)\n                               #(vec (map second %)))\n                         (partition-by first\n                                       (sort (map (juxt f identity)\n                                                  s))))))","problem":63,"user":"4ec1b090535dfed6da9c6db5"},{"problem":63,"code":"(fn gs [f xs]\n  (reduce\n   (fn [result x]\n     (assoc result (f x)\n            (conj (or (result (f x)) []) x)))\n   {}\n   xs))","user":"56069006e4b08b23635d3174"},{"problem":63,"code":"(fn [f coll]\n   (reduce\n     (fn [acc nx]\n       (update-in acc [(f nx)] #(conj (or % []) nx)))\n     {}\n     coll))","user":"515ef58be4b02c55805ea237"},{"problem":63,"code":"(fn [p l]\n     (loop [r {} l l]\n       (if (empty? l)\n         r\n         (let [[h & t] l k (p h)]\n           (recur (into r {k (conj (r k []) h)}) t)))))","user":"53e4fa2ce4b036ad0777e454"},{"problem":63,"code":"(fn [f s]\n  (reduce (fn [m v]\n            (let [k (f v)]\n              (assoc m k (conj (or (m k) []) v))))\n          {} s))","user":"59a080e3e4b0871e7608b837"},{"problem":63,"code":"(fn [f lst]\n    (reduce\n       (fn [map b] (assoc map (f b) (concat (get map (f b)) (list b))))\n       {}\n       lst\n     ))","user":"5bbbce0ee4b0a20761a2360d"},{"code":"(fn[f s]\n  (apply \n    (partial merge-with concat) \n    (map #(hash-map (f %) [%]) s)))","problem":63,"user":"4eca40cd535d6d7199dd3703"},{"code":"(fn my-group-by                                                                                                                                                                                \n  [f s]                                                                                                                                                                                          \n  (reduce (fn [acc element]                                                                                                                                                                      \n            (assoc acc (f element)                                                                                                                                                               \n                   (conj (get acc (f element) [])                                                                  \n                         element)))\n          {}\n          s))","problem":63,"user":"50fc48dde4b0d10d794c19f6"},{"code":"(fn [f coll]\n  (reduce (fn [m x]\n    (let [r (f x)]\n      (assoc m r (conj (get m r []) x)))) {} coll))","problem":63,"user":"504457c0e4b01f6c9a8b2360"},{"problem":63,"code":"(fn [func seq]\n  (loop [seq seq accum {}]\n    (if (empty? seq) accum\n    (let [key (func (first seq))\n          val (first seq)]\n      (if (contains? accum key)\n        (recur (rest seq) (assoc accum key (conj (get accum key) val)))\n        (recur (rest seq) (assoc accum key [val])))))))","user":"554dff83e4b00713264bd98d"},{"problem":63,"code":"(fn solve [f, s]\n  (let [t (sort-by f s)\n        p (partition-by f t),\n        vals (map #(f (first %)) p)]\n  (apply hash-map (interleave vals p))\n  )\n)","user":"56f258d3e4b04a395b9a04a1"},{"problem":63,"code":"(fn [func coll]\n   (->> coll\n        (map #(vector (func %) %))\n        (sort-by first)\n        (partition-by first)\n        (map (fn [bigcoll] (vector (first (first bigcoll)) (apply vector (->> bigcoll (map last))))))\n        (reduce into)\n        (apply hash-map)\n))","user":"53ed6976e4b0d648e757f4c4"},{"code":"(fn foo [f s] \n  (loop [sq s fu f acc {}]\n    (if (empty? sq)\n      acc\n      (let [result (fu (first sq))]\n        (recur (rest sq) fu \n  (assoc acc result (conj (get acc result [])(first sq))))))))","problem":63,"user":"4f26d6d9e4b0d6649770a007"},{"code":"#(apply merge-with concat (map (fn [e] (hash-map (% e) [e])) %2))","problem":63,"user":"4ede361a535d10e5ff6f5332"},{"problem":63,"code":"(fn [f xs] (apply merge-with #(concat %1 %2) (map #(hash-map (f %1) (vector %1)) xs)))","user":"55645592e4b0c656e3ff1802"},{"code":"(fn g\r\n  ([f c] (g f c {}))\r\n  ([f c m]\r\n    (if-let [s (seq c)]\r\n      (g f (rest s) (merge-with concat m {(f (first s)) [(first s)]}))\r\n      m)))","problem":63,"user":"4ecbb249535df97575fdabdf"},{"code":"(fn [f s]\n          (reduce (fn [r v] (let [add #((fnil conj []) %1 %2)]\n                             (update-in r [(f v)] add v))) {} s))","problem":63,"user":"50705072e4b07bd6ad9b9f27"},{"code":"(fn [f l]\n  (reduce\n   (fn [m v]\n     (let [t (f v)]\n       (assoc m t (conj (get m t []) v))))\n     {} l))","problem":63,"user":"537e745ae4b06839e8705ea6"},{"code":"(fn [func arg]\n\t  (reduce #(assoc %1 (func %2) (conj (get %1 (func %2) []) %2)) {} arg))","problem":63,"user":"5016ac54e4b052339a490e7b"},{"code":"(fn [f coll]\n   (reduce\n     #(let [k (f %2)\n            v (%1 (f %2) [])]\n        (assoc %1 k (conj v %2)))\n   \t{}\n   \tcoll))","problem":63,"user":"500900dee4b0144d4f561e42"},{"problem":63,"code":"(fn [f s]\n  (reduce #(let [m %1,\n                 i %2,\n                 k (f i),\n                 v (conj (m k []) i)]\n             (assoc m k v))\n          {}\n          s))","user":"56732c84e4b05957ce8c611c"},{"problem":63,"code":"(fn [f s]\n    (reduce (fn [output n]\n              (let [k (f n)\n                    v (conj (get output k []) n)]\n                (merge output {k v}))) {} s))","user":"5683fcafe4b0945ebc182aa8"},{"code":"(fn my-group-by [f s]\n  ((fn [m r]\n     (if (seq r)\n       (let [v (f (first r))]\n         (if (contains? m v)\n           (recur (assoc m v (conj (get m v) (first r))) (rest r))\n           (recur (assoc m v [(first r)]) (rest r))))\n       m)) {} s))","problem":63,"user":"4ec75077535d6d7199dd36e0"},{"code":"#(reduce (fn [a v] (let [k (%1 v)] \n(assoc a k (conj (get a k []) v)))) {} %2)","problem":63,"user":"4fd81472e4b0dab7d829f38e"},{"code":"(fn [f xs] (apply merge-with concat (map #(hash-map (f %) (list %)) xs)))","problem":63,"user":"525f51bde4b0cb4875a45dc8"},{"problem":63,"code":"(fn [f xs]\n    (reduce\n     (fn [mp x] \n       (update-in mp [(f x)] #(if (= % nil) [x] (conj % x))))\n     {}\n     xs))","user":"543d89dfe4b032a45b869350"},{"problem":63,"code":"(fn [f col]\n  (loop [ret {}\n         v col]\n    (if (empty? v)\n      ret\n      (recur\n       (assoc ret (f (first v))\n         (conj (get ret (f (first v)) []) (first v))) (rest v)))))","user":"57481f1fe4b009280f9f2b82"},{"code":"(fn my-groupby                                                  \n  [f s]                                                           \n  (loop [acc {} items s]                                          \n    (if (empty? items)                                            \n      acc                                                         \n      (recur (update-in acc                                       \n                        [(f (first items))]                       \n                        #(vec (conj % (first items))))            \n             (rest items)))                                       \n    )                                                             \n  )","problem":63,"user":"50573ed8e4b0012181721987"},{"code":"(fn [f coll]\n  (reduce (fn [acc v]\n            (update-in acc [(f v)] (comp vec conj) v)) {} coll))","problem":63,"user":"4fe9ea87e4b0547ebccb2476"},{"problem":63,"code":"#(loop [f %1 col %2 rt {}]\n   (if(empty? col)\n     rt\n     (recur f (rest col) (assoc rt (f (first col)) (conj (get rt (f (first col)) []) (first col) ) ))\n     )\n   )","user":"5d270111e4b092dab7f59c62"},{"problem":63,"code":"(fn group [f coll]\n   (persistent!\n     (reduce\n       (fn [ret x]\n         (let [k (f x)]\n           (assoc! ret k (conj (get ret k []) x))))\n       (transient {}) coll)))","user":"5a03d246e4b01bb0ae8afd8c"},{"code":"(fn [function i-list]\r\n    (reduce\r\n        (fn [current next]\r\n            (let [[result element] next]\r\n                (if (or (zero? (count current)) (false? (contains? current result)))\r\n                    (assoc current result (vector element))\r\n                    (assoc current result (conj (get current result) element)))))\r\n        {}\r\n        (map\r\n            (fn [result element] (vector result element))\r\n            (map function i-list)\r\n            i-list)))","problem":63,"user":"4dddf817535d08e6dec9fdd3"},{"problem":63,"code":"#(reduce\n  (fn [m v]\n    (let [k (%1 v)\n          d (get m k)]\n      (conj m\n            [k\n             (if d (conj d v) [v])\n             ])))\n  {}\n  %2)","user":"5742ec91e4b05c31a32c0883"},{"code":"(fn\n  [f cs]\n  (reduce (fn [m c]\n            (let [v (f c)]\n              (assoc m v (conj (m v []) c))))  {} cs))","problem":63,"user":"51852961e4b0da5a5be3babb"},{"problem":63,"code":"(fn [f c] (reduce #(cond\n                   (nil? (%1 (f %2))) (assoc %1 (f %2) [%2]) \n                    :else (assoc %1 (f %2) (conj (%1 (f %2)) %2)))\n                  {} c))","user":"53a0ab8ce4b0ca733b9744b3"},{"code":"(fn [f c] (reduce #(let [v (f %2)] (assoc %1 v (conj (get %1 v []) %2))) {} c))","problem":63,"user":"500aa15ee4b03d00572d2d76"},{"problem":63,"code":"(fn [f s]\n  (let[my-conj #(conj (or %1 []) %2)]\n    (reduce #(update-in %1 [(f %2)] my-conj %2) {} s)))","user":"56d63729e4b0ea9b8538f7ca"},{"problem":63,"code":"(fn my-group-by [f xs]\n  (apply merge-with into\n         (map (fn [x] {(f x) [x]}) xs)))","user":"601c39eee4b0bf4ca6b10937"},{"code":"#(reduce (fn [acc y] (assoc acc (% y) (concat (get acc (% y) []) [y]))) {} %2)","problem":63,"user":"5216933be4b000d124d989cf"},{"problem":63,"code":"(fn [f s]\n    (reduce (fn [map item]\n              (let [key (f item)]\n                (assoc map\n                  key\n                  (conj \n                   (get map key [])\n                   item))))\n            {}\n            s))","user":"554a75c9e4b0a04f79299575"},{"code":"#(reduce (fn [h v] (let [k (% v)] (assoc h k (conj (h k []) v)))) {} %2)","problem":63,"user":"523b1a65e4b02f719975bdbd"},{"problem":63,"code":"(fn gs [f coll]  (reduce #(let [k (f %2), v (get % k)] (assoc % k (conj (if v v []) %2))) {} coll))","user":"572ec4dde4b0cd1946bd0f8d"},{"problem":63,"code":"(fn [f coll]\n    (reduce (fn [m e] (assoc m (first e) (second e))) {} \n        (map #(vector (second(first %)) (map first %))\n            (partition-by second\n                (sort-by second\n                    (map #(vector % (f %)) coll)\n                )\n            )\n        )\n    )\n)","user":"580c8fcee4b0849f6811b721"},{"code":"(fn [f in-seq]\n  (loop [local-seq in-seq result {}]\n    (if (empty? local-seq)\n        result\n        (recur (rest local-seq)\n               (assoc result (f (first local-seq))\n                      (vec (conj (result (f (first local-seq)))\n                                 (first local-seq))))))))","problem":63,"user":"4ef4ab95535dced4c769f23b"},{"code":"(fn [f s]\n  (reduce #(let [k (f %2)]\n              (assoc %1 k (concat (%1 k) [%2])))\n          {}\n          s))","problem":63,"user":"4eb66737535d7eef3080736b"},{"problem":63,"code":"(fn [f vs] (reduce #(let [k (f %2)]\n                          (assoc % k (if (nil? (% k))\n                                       [%2]\n                                       (conj (get % k) %2)\n                                      )\n                            )\n                          ) {} vs\n                   ))","user":"53cd421ce4b00fb29b2212dd"},{"problem":63,"code":"(fn gby [func coll]\n   (reduce (fn group [ret val]\n             (let [k (func val)\n                   v  val]\n               (assoc ret k (conj (get ret k []) v))\n               ))\n           {} coll\n           ))","user":"5364ab34e4b0243289761e64"},{"code":"#(reduce (fn [a1 a2] (merge-with concat a1 a2)) (map (fn [c e] {(c e) [e]}) (repeat %1) %2))","problem":63,"user":"4f1bee08535d64f60314647e"},{"problem":63,"code":";; http://www.4clojure.com/problem/63\n(fn my-group\n  [f coll]\n  ;(map #(list % (f %)) coll)\n  (apply merge-with into (map #(hash-map (f %) [%]) coll)))","user":"5c92105ce4b048ec896c59f7"},{"problem":63,"code":"(fn [f v] (reduce (fn [m curr] (assoc m (f curr) (vec (conj (get m (f curr)) curr)))) {} v))","user":"57ee82b1e4b0bfb2137f5bbd"},{"code":"(fn [f ls]\n  (reduce (fn [v x]\n    (let [t (f x)]\n      (assoc v t (conj (get v t []) x)))) {} ls))","problem":63,"user":"4f017593535dcb61093f6a36"},{"code":"(fn group [f s]\n  (if (empty? s)\n      {}\n      (let [e (first s)\n            r (f e)\n            m (group f (rest s))\n            v (get m r)]\n        (if (nil? v)\n            (assoc m r [e])\n            (assoc m r (cons e v))))))","problem":63,"user":"5054c7e1e4b0b1b9d1860eb2"},{"problem":63,"code":"(fn fx\n  ([f coll]\n   (fx f coll {}))\n  ([f coll result]\n   (if (empty? coll)\n     result\n     (let [v (first coll)\n           k (f v)\n           g (get result k)]\n       (if g\n         (recur f (rest coll) (assoc result k (conj g v)))\n         (recur f (rest coll) (assoc result k (vector v)))\n         )\n       ))))","user":"524a9556e4b05ef8e38e64b1"},{"code":"(fn [f xs]\n  (reduce (fn [m x] (update-in m [(f x)] (fnil conj []) x)) {} xs))","problem":63,"user":"51281b25e4b03a34742b4304"},{"code":"(fn [f s]\n  (reduce (fn [m a]\n    (let [x (f a)]\n      (assoc m x (conj (get m x []) a)))) {} s))","problem":63,"user":"4ebc08a8535dfed6da9c6d7c"},{"code":"(fn [f lst]\n   (into {} (for[[k v](apply hash-map (interleave (set (map f lst)) (repeat [])))] [k (filter #(= k (f %)) lst) ])))","problem":63,"user":"4fb86dc9e4b081705acca2d8"},{"problem":63,"code":"#(reduce (fn[acc i] (assoc acc (%1 i) (into [] (conj (get acc (%1 i)) i)))) {} %2)","user":"5b210749e4b03cfeda66ed48"},{"problem":63,"code":"(fn [f coll] (->> (partition-by f coll) \n                  (map #(hash-map (f (first %)) (vec %)))\n                  (apply (partial merge-with into))))","user":"5e8ce2fee4b0cb0169546328"},{"code":"#(reduce (fn [result x] (assoc result (%1 x) (conj (or (-> x %1 result) []) x))) {} %2)","problem":63,"user":"4e79a143535db169f9c796a2"},{"code":"(fn [func seqn]\n  (loop [s (seq seqn), m {}]\n    (if (empty? s)\n      m\n      (let [[hd & tl] s\n            key     (func hd)\n            values  (get m key [])\n            new-map (assoc m key (conj values hd))]\n        (recur tl new-map)))))","problem":63,"user":"4ea4fe1f535d7eef308072cf"},{"problem":63,"code":"(fn [f s]\n\t(reduce #(assoc %1 (f %2) (conj (vec (%1 (f %2))) %2)) {} s))","user":"5252b59de4b0541d1855b8cf"},{"code":"(fn [f col]\n  (loop [c col grp {}]\n    (if c\n      (recur (next c) (update-in grp [(f (first c))] (fnil conj []) (first c)))\n       grp)))","problem":63,"user":"513cb853e4b0b86ece9f322b"},{"code":"(fn [function input]\n  (apply array-map\n    (apply concat\n      (map\n        #(vector (function (first %)) %)\n        (partition-by function (sort input))))))","problem":63,"user":"528bba38e4b0239c8a67aea9"},{"problem":63,"code":"(fn [f l] (reduce (fn [m v] (let [ k (f v) vs (get m k [])] (assoc m k (conj vs v)))) {} l))","user":"53b2a7f8e4b047364c04449c"},{"problem":63,"code":"(fn [f ss]\n  (loop [s ss\n         m {}]\n    (if (empty? s)\n      m\n      (let [v (first s)\n            k (f v)\n            vs (concat (m k) [v])]\n        (recur (rest s) (assoc m k vs))))))","user":"5d46fbc6e4b07c84aa5ae6af"},{"code":"(fn [f coll]\n  (apply merge-with concat \n         (for [x coll] {(f x) [x]})))\n\n;(fn [f coll]\n;  (reduce (fn [col x] (conj col {(first (first x))\n;                                 (map second x)}))\n;          {}\n;          (partition-by first\n;                        (sort (for [p coll] [(f p) p])))))\n\n;#(->> %2\n;      (sort-by %1)\n;      (partition-by %1)\n;      (reduce \n;        (fn [coll x] \n;          (conj coll {(%1 (first x)) x})) {}))","problem":63,"user":"4dd7d040535d2dad7130b5d6"},{"problem":63,"code":"(fn my-groupby\n  [f s]\n  (let [results (map f s)\n        distinct-res (distinct results)\n        r {}]\n    (into {} (map (fn [res]\n                    (assoc r res (into [] (filter (fn [val]\n                                                    (= (f val) res)) s)) ))  distinct-res))))","user":"5b478997e4b02d533a91bc71"},{"code":"(fn my-group-by [pred coll]                                                                                                                  \r\n    (reduce (fn [t e]                                                                                                                          \r\n              (update-in t [(pred e)]                                                                                                         \r\n                         (fn [old x] (if old (conj old x) [x])) e))                                                                            \r\n            {}                                                                                                                                \r\n            coll))","problem":63,"user":"4f149e0f535d64f60314643d"},{"code":"(fn [f l] (reduce (partial merge-with concat) {} (#(for [x %2] {(% x) [x]}) f l)))","problem":63,"user":"534e4a29e4b084c2834f4ab0"},{"problem":63,"code":"(fn [f s]\n  (reduce (fn [m x]\n            (let [k (f x)\n                  v (m (f x) [])]\n              (assoc m k (conj v x))))\n          {} s))","user":"55c68089e4b0e31453f649c4"},{"code":"(fn [f s] (reduce (fn [acc x] (update-in acc [(f x)] (fnil #(conj % x) []))) {} s))","problem":63,"user":"50e0d5a3e4b061dbdced723d"},{"code":"(fn [f coll]\n  (reduce #(merge-with concat %1 {(f %2), [%2]})\n         {}\n         coll))","problem":63,"user":"4eb9ce75535dfed6da9c6d5e"},{"code":"(fn [fun s] \n  (->> (sort-by fun s)\n       (partition-by fun)\n       (mapcat (fn[x] [(fun (first x)) x]))\n       (apply hash-map)))","problem":63,"user":"4f725466e4b07046d9f4f030"},{"problem":63,"code":"(fn group [f s]\n  (apply merge-with concat (map #(array-map (f %) [%]) s)))","user":"54b95f3de4b0ed20f4ff6eab"},{"code":"#(loop [f %1\n\t     s %2\n\t     ans {}]\n\t(if (nil? s) ans\n\t    (if (some (fn[x](= x (f (first s)))) (keys ans))\n\t      (recur f (next s)  (assoc ans (f (first s)) (conj (get ans (f (first s))) (first s) )))\n\t      (recur f (next s)  (assoc ans (f (first s)) (vector (first s)))))))","problem":63,"user":"4e8849c5535d8b9bb0147ca4"},{"problem":63,"code":"(fn group-by-me [func coll]\n  (persistent! (\n     reduce\n     (fn [acc el]\n       (assoc! acc (func el) (conj (get acc (func el) []) el)))\n     (transient {})\n     coll\n     )))","user":"574ed2f7e4b02ea11479924a"},{"problem":63,"code":"(fn [f coll]\n  (reduce (fn [m v]\n            (let [result (f v)\n                  currSeq (get m result)]\n              (if (nil? currSeq)\n                (assoc m result [v])\n                (assoc m result (conj currSeq v))))) {} coll ))","user":"5fce0cc5e4b07e53c2f3f000"},{"problem":63,"code":"(fn my-group-by [f xs]\n  (reduce\n   (fn accumulate [m v]\n     (let [key (first v)\n           value (second v)]\n       (assoc m key (reverse (cons value (reverse (get m key)))))))\n   {}\n   (map vector (map f xs) xs)))","user":"56255e2de4b00a550fc90297"},{"problem":63,"code":"(fn [f xs]\n  (let [go (fn [res v]\n             (let [k (f v)\n                   res-vec (get res k)\n                   new-v (if (seq res-vec) (conj res-vec v) [v])]\n               (assoc res k new-v)))]\n    (reduce go {} xs)))","user":"51e24905e4b01e519814642e"},{"code":"(fn [f col]\n  (reduce\n    (fn [prev-col x]\n      (let [fx (f x)]\n        (assoc-in prev-col [fx]\n                  (if (contains? prev-col fx)\n                    (concat (get prev-col fx) [x])\n                    [x]))))\n            {} col))","problem":63,"user":"50f10f7be4b06d9538fe211a"},{"problem":63,"code":"(fn [f xs] (reduce #(update-in % [(f %2)] (fnil conj []) %2) {} xs))","user":"5416b4a2e4b01498b1a71a01"},{"code":"(fn [f s]\n  (let [initmap (zipmap (map f s) (repeat []))]\n    (reduce (fn [m itm] (merge-with conj m {(f itm) itm}))\n            initmap s)))","problem":63,"user":"52d340ebe4b099d49816f0c1"},{"code":"(fn [ f coll ]\n    (reduce #(let [ k (f %2), v (get % k [])]\n                (conj % [k (conj v %2)]))\n            {}\n            coll))","problem":63,"user":"5398305fe4b0b51d73faaef6"},{"code":"(fn [f c]\n  (let [p (partition-by f (sort-by f c))]\n    (zipmap (map #(f (first %)) p) p)))","problem":63,"user":"5267d9bde4b03e8d9a4a7188"},{"code":"(fn [f coll]\n  (reduce (fn [m e]\n            (let [k  (f e)\n                  vs (get m k [])]\n              (assoc m k (conj vs e))))\n          {}\n          coll))","problem":63,"user":"51d19c24e4b0cfcf579466c3"},{"code":"(fn [f s]\r\n  ((fn step [ret f [x & xs]]\r\n     (if x\r\n       (let [k (f x)]\r\n         (step (assoc ret k (conj (get ret k []) x)) f xs))\r\n       ret))\r\n    {} f (seq s)))","problem":63,"user":"4e1158aa535d04ed9115e7c6"},{"problem":63,"code":"(fn [f coll]\n  (reduce\n   (fn [s e]\n     (assoc s (f e) (conj (s (f e) []) e)))\n   {}\n   coll))","user":"567695c2e4b05957ce8c6157"},{"code":"(fn [f s]\r\n  (loop [result {}\r\n         x s]\r\n    (if (empty? x) result\r\n      (recur (merge-with concat result {(f (first x)) [(first x)]}) \r\n             (rest x)))))","problem":63,"user":"50045388e4b0678c553fc44e"},{"problem":63,"code":"(fn [f s] (apply merge-with concat (map #(assoc {} (f %) [%]) s)))","user":"56c08696e4b060a8e693e3aa"},{"code":"#(apply\n  merge-with\n  concat\n  (for [x %2] {(% x) [x]})\n)","problem":63,"user":"4e6df3c9535d5021c1a895fa"},{"code":"#(reduce (fn [ m x]\r\n              (let\r\n                  [r (% x)\r\n                   s (get m r [])]\r\n                (assoc m r (conj s x) ))) {} %2)","problem":63,"user":"4febb4dae4b0681fd128dc98"},{"problem":63,"code":"(fn [f s] (reduce (fn [m e] (update-in m\n                                       [(f e)]\n                                       #(conj (vec %) e)))\n                   {}\n                   s))","user":"5992dc6ae4b0866487ed0d7d"},{"code":"(fn [f xs]\n  (reduce \n   (fn [acc y] \n     (conj acc \n           {(f y) (conj (get acc (f y) []) y)})) \n   {} \n   xs))","problem":63,"user":"50fe2420e4b03cd852b4e84a"},{"problem":63,"code":"(fn gp [f s]\n  (apply merge-with into (map (fn [x] {(f x) [x]}) s)))","user":"597a4277e4b02382a38ad1e2"},{"code":"(fn [func coll]\n  (reduce #(assoc %1 (func %2) (conj (%1 (func %2) []) %2)) {} coll)\n  )","problem":63,"user":"53778b90e4b06839e8705e36"},{"problem":63,"code":"(fn my-group-by [f s]\n  (reduce\n   (fn [memo next-value]\n     (let [this-result (f next-value)\n           previous-value (get memo this-result [])]\n       (assoc memo this-result (conj previous-value next-value))))\n   {}\n   s))","user":"60c91f48e4b0e0fa5f1b4304"},{"code":"(fn [f x]\n(reduce (fn [m v]\n          (assoc m (f v) (conj (get m (f v) []) v)))\n          {} x))","problem":63,"user":"5125d963e4b05d10e3e395fe"},{"problem":63,"code":"(fn [f xs]\n  (reduce\n   (fn [acc x] (let [v (f x)] (assoc acc v (concat (acc v []) [x]))))\n   {}\n   xs))","user":"5b9db58be4b0c0b3ffbd4b41"},{"problem":63,"code":"(fn [fx coll] (reduce #(update-in %1 [(fx %2)] (fn[x] (conj (vec x) %2))) {} coll))","user":"51f805b0e4b06ff1c25c52e2"},{"code":"(fn groupseq [f x]\n  (loop [x x result '{}]\n     (cond (empty? x) result\n  \t :else (let [fx (first x) fval (f fx)]\n\t\t\t(recur (rest x) \n\t\t\t\t(cond (nil? (get result fval)) (assoc result fval (list fx))\n\t\t\t\t\t:else (assoc result fval (concat (get result fval) (list fx)))\n\t\t\t\t\t))\n\t\t)\t\t\n\t )\n  )\n)","problem":63,"user":"50588af1e4b06522596eba7d"},{"code":"(fn group-by'\n    ([f xs] (group-by' f xs {}))\n    ([f xs acc]\n     (if (empty? xs) acc\n       (let [x0 (first xs),\n             fx0 (f x0),\n             p #(= (f %) fx0)]\n         (recur f (remove p xs) (conj acc [fx0 (filter p xs)]))))))","problem":63,"user":"508157b2e4b0946d0443855c"},{"code":"(fn grp [f xs]\n  (reduce (fn [m x] (let [k (f x)v (m k)] (assoc m k (if v (conj v x) (conj [] x)))) ) {} xs))","problem":63,"user":"52015698e4b0d7096e99ddba"},{"problem":63,"code":"#(apply merge-with into (map (fn [x] {(%1 x) [x]}) %2))","user":"5881335ce4b0f1effa3b762e"},{"problem":63,"code":"(fn [f coll]\n  (reduce\n    (fn [acc x]\n      (let [k (f x)]\n        (assoc acc k (conj (get acc k []) x))))\n    {} coll))","user":"549c1713e4b0f3d1d8e70f82"},{"problem":63,"code":"(fn [f xs]\n  (reduce \n   (fn [result x] \n     (if (result (f x)) \n       (assoc result (f x) (conj (result (f x)) x))\n       (assoc result (f x) [x]) ) ) \n   {} xs))","user":"567798afe4b05957ce8c6169"},{"code":"(fn group-seq [f s]\n  (let [kys (distinct (map f s))\n        vls (for [x kys\n \t\t\t\t  y s\n\t\t\t\t  :when (= (f y) x)]\n              y)]\n        (zipmap kys (partition-by f vls))))","problem":63,"user":"53973e7be4b0b51d73faaee6"},{"problem":63,"code":"(fn [func sequence]\n  (reduce (fn [aggregate element]\n            (let [output (func element)]\n              (assoc aggregate output (conj (get aggregate output []) element))))\n          {}\n          sequence))","user":"5d5166d9e4b0776584bd6f5e"},{"code":"(fn [f x]\n  (reduce #(assoc % (f %2) (vec (conj (% (f %2)) %2)))\n          {} x))","problem":63,"user":"51a10b2ce4b0b292b01ee3fe"},{"problem":63,"code":"(fn [f col]\n  (loop [mymap {}  col col]\n    (if (empty? col)\n      mymap\n    (let [k (f (first col))]\n      (if (contains? mymap k)\n          (recur (assoc mymap k (vec (conj (get mymap k) (first col)))) (rest col))\n          (recur (assoc mymap k (vec (list (first col)))) (rest col))\n          )) \n      \n       )))","user":"57e396cde4b0bfb2137f5a9e"},{"problem":63,"code":"(fn [f coll]\n  (apply merge-with concat (map (fn [x] {(f x) [x]}) coll)))","user":"541b1f25e4b01498b1a71a63"},{"problem":63,"code":"(fn [f l] (apply (partial merge-with concat) (map hash-map (map f l) (map vector l))))","user":"5454b84ce4b0e397800069d9"},{"code":"(fn [f xs]\n  (loop [dict {} vs xs ks (map f xs)]\n    (if (or (empty? vs) (empty? ks))\n      dict\n      (let [v (first vs) k (first ks)]\n        (println (str k \", \" v))\n        (if (contains? dict k)\n          (recur (conj dict [k (conj (dict k) v)]) (rest vs) (rest ks))\n          (recur (conj dict [k [v]]) (rest vs) (rest ks)))))))","problem":63,"user":"504f865ee4b0a02f9cffde90"},{"code":"(fn b [f v]\n     (into {} \n           (map (fn [item] (vector (f (first item)) (vec item ))) \n                (map (fn [item] (map first item)) \n                     (partition-by second \n                                   (sort #(compare (last %) (last %2)) \n                                         (map vector v (map f v ) )))))))","problem":63,"user":"50e87427e4b0ebbe794eb7e8"},{"code":"(fn asd\n  ([fun vec]\n    (asd {} fun vec))\n  ([map fun vec]\n\t(let [val (first vec)\n\t      res (fun val)]\n\t  (if (> (count vec) 1)\n\t    (asd \n\t     (assoc-in map [res]\n\t\t       (conj (get map res []) val))\n\t     fun (rest vec))\n\t    (assoc-in map [res]\n\t\t       (conj (get map res []) val))))))","problem":63,"user":"5289f1f4e4b0239c8a67ae6d"},{"problem":63,"code":"(fn [f s]\n   (reduce (fn [m v]\n             (let [key (f v)\n                   pre (get m key)]\n               (if pre\n                 (assoc m key (conj pre v))\n                 (assoc m key [v])))) {} s))","user":"56c60b36e4b05cc29241eead"},{"problem":63,"code":"(fn [f s]  (reduce #(\n                     merge-with concat %1 {(f %2) [%2]}\n                     )\n                   {} s)\n)","user":"5d9e7971e4b000c986472bc1"},{"code":"(fn [f coll]\n  (reduce \n    (fn [ret item]\n      (let [key (f item)]\n        (if (ret key)\n        (assoc ret key (conj (ret key) item))\n        (assoc ret key (vector item))))) {} coll))","problem":63,"user":"5084c43be4b0fb8f40674bfa"},{"problem":63,"code":"#(reduce\n    (fn [ret x]\n      (let [k (%1 x)]\n        (assoc ret k (conj (get ret k []) x)))) {} %2)","user":"5405ae2be4b0addc1aec6671"},{"problem":63,"code":"(fn __\n    [ f coll ]\n    (let [xvs (map (fn [x] [(f x) x]) coll)]\n      (if-let [ks (set (map  #(let [[ key _ ] %] key)  xvs ))]\n        (reduce conj (map  (fn [x] (apply array-map x)) \n                           (concat (for [k ks]\n                                     [k  (map #(let [[key val ] %] val)  (filter #(let [[ key val ] %] (= k key)) xvs))]))\n                           )))))","user":"5433a07be4b0b6b47310fce0"},{"code":"(fn [f coll] \r\n  (reduce\r\n    (fn [ret x]\r\n      (let [k (f x)]\r\n        (assoc ret k (conj (get ret k []) x))))\r\n    {} coll))","problem":63,"user":"4f60ed88e4b0defedf855fb2"},{"problem":63,"code":"(fn [f s]\n  (reduce\n   (fn [ret x]\n     (let [k (f x)]\n       (assoc ret k (conj (get ret k []) x))))\n   {}\n   s))","user":"56ca0da9e4b0ea9b8538f715"},{"code":"(fn group-seq\n  [f s]\n  (apply merge-with concat (for [x s] {(f x) (vector x)})))","problem":63,"user":"4ec1b80c535dfed6da9c6db6"},{"problem":63,"code":"(fn s [f col]\n  (reduce \n    (fn [m v]\n      (assoc m (f v)  (vec (conj  (get m (f v)) v)))\n    )\n    {}\n    col\n  )\n)","user":"5c7bb8c0e4b0fca0c1622864"},{"problem":63,"code":"(fn group-a-seq [f inputs]\n   (let [results (map f inputs)\n         unique-results (set results)\n         interleaved-results (interleave results inputs)\n         grouped (apply hash-map (interleave unique-results (repeat [])))]\n     (letfn [(accum [interl result]\n               (if (empty? interl)\n                 result\n                 (accum (drop 2 interl)\n                        ;;; result)))]\n                        (assoc result (first interl)\n                               (conj (result (first interl)) (second interl))))))]\n       (accum interleaved-results grouped))))","user":"54b817eee4b0ed20f4ff6e93"},{"code":"(fn [f l]\n   (reduce (fn [ret i]\n             (let [k (f i)]\n               (assoc ret k (conj (get ret k []) i))))\n           {} l))","problem":63,"user":"535e518ee4b04ce2eb3ed2cf"},{"problem":63,"code":"(fn [f xs] (->> (map #(hash-map (f %) (vector %)) xs)\n                         (apply merge-with into)))","user":"5b81139fe4b047b03b203782"},{"code":"(fn [f s]\n   (reduce (fn [a e]\n             (let [key (f e)\n                   vector (or (a key) [])]\n               (assoc a key (conj vector e))))\n           {}\n           s))","problem":63,"user":"50a7ef7fe4b090657f4a5ce0"},{"code":"(fn grp-by [f s]\n  (if (empty? s)\n    {}\n    (let [m (grp-by f (rest s))\n          k (f (first s))]\n      (if (contains? m k)\n        (assoc m k (cons (first s) (get m k)))\n        (assoc m k [(first s)])))))","problem":63,"user":"503e6047e4b06c4e0e1fa266"},{"problem":63,"code":"(fn [f s]\n    (reduce (fn [acc x]\n              (let [k (f x)\n                    cur (or (acc k) [])]\n                (assoc acc k (conj cur x))))\n            {} s))","user":"55f081bbe4b06e875b46ce25"},{"problem":63,"code":"(fn\n  [f lst]\n  (let [opts (distinct (map f lst))]\n  \t(into {} (map (fn [opt] (conj [opt] (filter #(= opt (f %)) lst))) opts))\n  ))","user":"55ede35ce4b0121d4835fde1"},{"code":"#(reduce (fn [r i] (let [fi (% i) v (r fi)]\n                      (assoc r fi (if v (conj v i) [i]))))\n           {}\n           %2)","problem":63,"user":"4ee88bfb535d93acb0a66881"},{"problem":63,"code":"(fn[f s]\n  (loop [i s\n         ans {}]\n    (if (empty? i)\n      ans\n      (let [v (f (first i))]\n        (recur (rest i) (if (get ans v) (assoc ans v (conj (get ans v) (first i))) (assoc ans v (vector (first i)))))))))","user":"5596af34e4b04c1e5c31d758"},{"code":"(fn my-group-by [fnn values]\n                 (loop [cur {}\n                        left values]\n                 (if (empty? left)\n                   cur\n                   (let [val (fnn (first left))\n                         entry (conj (cur val []) (first left))]\n                   (recur (assoc cur val entry)\n                     (rest left))))))","problem":63,"user":"4f465096e4b0d56e7bb92b9a"},{"problem":63,"code":"(fn [f xs]\n  (reduce #(update-in %1 [(f %2)] (fn [old new] (conj (vec old) new)) %2)\n          {} xs))","user":"58800fd4e4b0f1effa3b7606"},{"problem":63,"code":"(fn [f v]\n    (loop [m {} v_ v]\n        (if (seq v_)\n            (if (m (f (first v_)))\n                (recur (assoc m (f (first v_)) (conj (m (f (first v_))) (first v_))) (rest v_))\n                (recur  (assoc m (f (first v_)) (conj [] (first v_))) (rest v_)))\n            m)))","user":"55975569e4b031d6649c9b8e"},{"code":"(fn [f coll]\n  (->> coll\n       (map #(hash-map (f %) [%]))\n       (apply merge-with concat)))","problem":63,"user":"5346f409e4b084c2834f4a46"},{"problem":63,"code":"(fn[func coll] ( into {} (map (fn[item] (vector (func (first item)) (vec item) ) )   (partition-by func (sort coll) ) ) ) )","user":"575bd5f9e4b02ea114799365"},{"problem":63,"code":"(fn [f s]\n  (reduce #(update-in %1 [(f %2)] (fnil conj [])  %2) {} s))","user":"553b0d95e4b09218d5f44fff"},{"problem":63,"code":"(fn [f coll]\n  (reduce \n   (fn [acc x] \n     (let [res (f x)] \n       (assoc acc res \n         (into (get acc res []) [x]))))\n   {} coll))","user":"5ea970d1e4b00a66d4a951c6"},{"code":"(fn [f d]\n  (reduce \n    #(conj \n      % \n      [(f %2) (into [] (conj (% (f %2)) %2))]) \n    {} \n    d))","problem":63,"user":"4e5d1912535d8a8b8723a2c9"},{"problem":63,"code":"(fn [f col] (reduce (fn [ret p1] (assoc ret (f p1) (conj (get ret (f p1) []) p1))) {} col))","user":"53347274e4b0656e627bfd6b"},{"problem":63,"code":"(fn [f s]\n  (loop [grouped {}\n         [one & more] s]\n    (if (nil? one)\n      grouped\n      (let [key (f one)\n        \titems (get grouped key)]\n        (if items\n          (recur (assoc grouped key (conj items one)) more)\n          (recur (assoc grouped key [one]) more))))))","user":"581e8b86e4b04b46fc4b0f2b"},{"problem":63,"code":"#(zipmap (sort (distinct (map % %2))) (partition-by % (sort-by % %2)))","user":"5776385fe4b0979f89651632"},{"code":"(fn group [f coll]\n  (let [update (fn [m [k v]]\n  \t (update-in m [k] #(if (nil? %) [v] (conj % v))))]\n    (reduce update {} (map #(do [(f %) %]) coll))))","problem":63,"user":"4e615cd2535d8ccf87e9fe58"},{"problem":63,"code":"(fn grp-by [f lst]\n  (reduce (fn [result [k v]]\n            (let [val (result k [])]\n              (assoc result k (conj val v))))\n          {}\n          (for [v lst] [(f v) v])))","user":"55a1d7f6e4b0acc240e31519"},{"code":"(fn gb [f c]\n  (persistent!\n   (reduce\n    (fn [r x]\n      (let [k (f x)]\n        (assoc! r k (conj (get r k []) x))))\n    (transient {}) c)))","problem":63,"user":"51eab308e4b0f1f103a0d150"},{"code":"(fn [f s] (reduce (fn [c d] (let [k (f d)] (assoc c k (conj (get c k []) d)) )) {} s))","problem":63,"user":"5203bc27e4b0fb7e47ea5204"},{"problem":63,"code":"(fn g [f s]\t\n  (if (not-empty s)\n    (let [m (g f (rest s))\n          e (first s)\n          k (f e)]\n      (merge m {k (cons e (get m k))}))))","user":"5478e57de4b0c51c1f4d72c1"},{"problem":63,"code":"(fn [f s]\n   (reduce #(update-in %1 [(f %2)] (fn [a b] (conj (vec a) b)) %2) {} s))","user":"588fbb39e4b00487982d51bd"},{"problem":63,"code":"(fn my-group-by [fun seq]\n        (apply merge-with concat\n               (map #(hash-map (fun %) [%]) seq)))","user":"575b3e9be4b02ea11479935b"},{"problem":63,"code":"(fn [fcn lst]\n  (loop [acc {}\n         xs lst]\n    (if (empty? xs)\n      acc\n      (let [x (first xs)]\n        (recur (merge-with into acc {(fcn x) (vector x)})\n               (rest xs))))))","user":"5398d042e4b0b51d73faaf00"},{"code":"(fn [gf xs] (reduce #(assoc % (gf %2) (concat (% (gf %2)) (list %2) )) {} xs))","problem":63,"user":"4ece9ca9535d23f03622770f"},{"code":"(fn [f xs] (reduce #(merge % {(f %2) (concat (% (f %2)) (list %2))}) {} xs))","problem":63,"user":"508ee17ae4b0706b2ed3ef8d"},{"code":"(fn my-group-by\r\n  [f coll]\r\n  (persistent!\r\n   (reduce\r\n    (fn [ret x]\r\n      (let [k (f x)]\r\n        (assoc! ret k (conj (get ret k []) x))))\r\n    (transient {}) coll)))","problem":63,"user":"4e6defcc535d5021c1a895f8"},{"problem":63,"code":"(fn [f coll]\n  (reduce (fn [m v] (update-in m [(f v)] #(conj (or % []) v))) \n          {} \n          coll))","user":"596a66cde4b069c0a1a19803"},{"problem":63,"code":"(fn [f coll]\n   (loop [rest' coll\n          result {}]\n     (if (empty? rest')\n       result\n       (let [[h & t] rest']\n         (recur t (merge-with into result {(f h) [h]}))))))","user":"5e3ef7d4e4b01d43a70e8e2d"},{"code":"(fn [f s]\n  (loop [sequ s res {}]\n    (if (empty? sequ)\n        res\n        (recur (rest sequ) \n               (if (res (f (first sequ)))\n                   (conj res {(f (first sequ)) (conj (res (f (first sequ))) (first sequ))})\n                   (conj res {(f (first sequ)) [(first sequ)]})\n               )\n        )\n    )\n  )\n)","problem":63,"user":"4fcf5292e4b03432b189f40e"},{"code":"(fn [g xs] (apply merge-with concat (for [x xs] {(g x) [x]})))","problem":63,"user":"5065faf9e4b0313a384e5645"},{"problem":63,"code":"(fn [f x]\n  (into {}\n        (map #(vector (f (first %)) (vec %))\n             (partition-by f (sort x)))))","user":"57e4dbcbe4b0bfb2137f5ac3"},{"problem":63,"code":"(fn grp-seq [func vals]\n  (into {}\n        (map #(vector (func (first % )) (vec %))\n(partition-by func (sort vals)))))","user":"55ff562fe4b00f4cabc57660"},{"problem":63,"code":"(fn grp [c l] (if (empty? l) {} (assoc (grp c (filter #(not= (c (first l)) (c %)) l)) (c (first l)) (filter #(= (c (first l)) (c %)) l))))","user":"550e0373e4b06e50f9beb162"},{"code":"(fn [f xs]\n  (reduce #(let [res (f %2)]\n             (if-let [v (get %1 res)]\n               (assoc %1 res (conj v %2))\n               (assoc %1 res (conj [] %2)))) {} xs))","problem":63,"user":"52fb64b7e4b047fd55837009"},{"code":"(fn [f c] (reduce #(update-in % [(f %2)] (fnil conj []) %2) {} c))","problem":63,"user":"50e3ec87e4b0463d32072486"},{"problem":63,"code":"(fn [f coll]\n        (reduce #(if (contains? %1 (f %2))\n                   (assoc %1 (f %2) (conj (%1 (f %2)) %2))\n                   (assoc %1 (f %2) [%2]))\n                {} coll))","user":"52e4f06be4b09f7907dd1456"},{"code":"(fn [f ls]\r\n  (loop [an {} ls ls]\r\n    (if (empty? ls)\r\n        an\r\n        (let [x (first ls)\r\n              v (f x)]\r\n          (if-let [fv (an v)]\r\n            (recur (conj an [v (conj fv x)]) (rest ls))\r\n            (recur (conj an [v [x]]) (rest ls)))))))","problem":63,"user":"4dd62278535d2dad7130b5c7"},{"code":"(fn [func coll] \n  (reduce \n    #(let [val (func %2)] (assoc % val (conj (get % val []) %2)))\n    {} coll))","problem":63,"user":"4f04b66b535dcb61093f6bdd"},{"code":"(fn [f xs]\n        (reduce #(assoc %1 (f %2) (conj (vec (%1 (f %2))) %2))\n               {}\n               xs))","problem":63,"user":"51a8f0c6e4b08d8ec191b821"},{"problem":63,"code":"(fn [f coll]\n  (apply merge-with into (map #(assoc {} (f %1) (vector %1)) coll)))","user":"608ec5e4e4b03bd49d9f36c0"},{"problem":63,"code":"(fn [f coll]\n  (loop [[x & s :as xs] coll\n        acc {}]\n   (if (empty? xs)\n     acc\n     (recur s (update-in acc [(f x)] #(into (or % []) [x]))))))","user":"510fe537e4b04c71fce993dd"},{"problem":63,"code":"(fn \n  [f v]\n  (into {}\n        (map #(vector (f (first % )) (vec %))\n             (partition-by f (sort v)))))","user":"5bbbce99e4b0a20761a23610"},{"problem":63,"code":"(fn [f coll]\n  (reduce (fn [m x]\n            (let [k (f x)]\n              (assoc m\n                     k\n                     (conj (m k [])\n                           x))))\n          {}\n          coll))","user":"5a065388e4b01bb0ae8afdcb"},{"code":"(fn [f s] (reduce (fn [acc v] (merge-with concat acc {(f v) [v]})) {} s))","problem":63,"user":"4ec1619b535dfed6da9c6dab"},{"problem":63,"code":"(fn [f s]\n  (loop [res {} sq s]\n    (if (empty? sq)\n      res\n      (recur (merge-with into res {(f (first sq)) [(first sq)]})\n             (rest sq)))))","user":"53791ab7e4b06839e8705e4d"},{"code":"#(apply merge-with into (map hash-map (map % %2) (map vector %2)))","problem":63,"user":"4e704293535d5021c1a89634"},{"problem":63,"code":"(fn [f s] (apply (partial merge-with concat) (for [x s] {(f x) [x]}) ) )","user":"563a79e5e4b0bfe05bf117fe"},{"problem":63,"code":"(fn [f as]\n  (reduce\n   (fn [mp v]\n     (let [k (f v)\n           oldvec (get mp k [])]\n       (assoc mp k (conj oldvec v))))\n   {} as))","user":"54b04708e4b09f271ff37d11"},{"problem":63,"code":"(fn [f coll]\n(let [fcoll (map-indexed vector (map f coll))]\n  (reduce (fn [acc item]\n            (let [index_item (first item)\n                  value_item (second item)\n                  value_map (get acc value_item)]\n              (if value_map \n                (update-in acc [value_item] conj (get coll index_item))\n                (assoc acc value_item [(get coll index_item)]))))\n          {(second (first fcoll)) [(first coll)]} (rest fcoll))))","user":"5a64dcabe4b0512ff01cd9a9"},{"problem":63,"code":"(fn [f col]\n\t(reduce\n\t\t(fn [groups a]\n\t\t\t(assoc groups (f a) (conj (get groups (f a) []) a)))\n\t\t\t\t{}\n\t\t\t\tcol))","user":"57644395e4b0994c1922fbf2"},{"problem":63,"code":"(fn [f s]\n  (apply merge-with into \n         (map (fn [x]\n                (hash-map\n                 (f x) [x])) \n              s)))","user":"576e607ae4b0979f89651579"},{"problem":63,"code":"(fn [func inputs] \n  (reduce #(update-in % [(func %2)] (fn [cur newv] (conj (into [] cur) newv)) %2) {} inputs))","user":"5ef5ee81e4b07c55ae4a054a"},{"code":"#(apply \n    (partial merge-with into) \n    (map \n      (fn [x] (do {(%1 x) [x]})) \n      %2))","problem":63,"user":"4fe15ffee4b0dd6cd5ce3634"},{"problem":63,"code":"(fn [f xs]\n  (->> (map f xs)\n    (map #(hash-map %2 [%]) xs)\n    (apply merge-with into)))","user":"57eaf869e4b0bfb2137f5b56"},{"problem":63,"code":"(fn [f coll]\n    (loop [[v & rest] coll\n           res {}]\n      (if v\n        (let [k    (f v)\n              vals (if (res k) (conj (res k) v) [v])]\n          (recur rest (assoc res k vals)))\n        res)))","user":"543a8256e4b032a45b869327"},{"code":"(fn [f y]\r\n  (reduce (partial merge-with concat) (map (fn [a] {(f a) [a]}) y)))","problem":63,"user":"507437c2e4b054001656acd0"},{"problem":63,"code":"(fn group-seq [f coll]\n     (apply merge-with into (for [i coll]\n       {(f i) [i]})))","user":"58dcb8cde4b0a4d5acaab6a7"},{"problem":63,"code":"(fn [p s]\n  (let [keys (set (map p s))]\n    (zipmap keys\n            (for [k keys]\n              (into [] (filter #(= k (p %)) s))))))","user":"561d23e3e4b064ca9f4b16a5"},{"problem":63,"code":"(fn c-group [func coll]\n  (let [alphabet (distinct (map func coll))]\n    (apply hash-map\n           (apply concat\n                  (map #(vector %\n                                (filter (fn [valu] (= % (func valu))) coll))\n                       alphabet)))))","user":"5f548678e4b0a0bc16850a7e"},{"problem":63,"code":"(fn [f xs]\n  (apply merge-with into (map #(hash-map (f %1) (vector %1)) xs)))","user":"569ad037e4b0542e1f8d144f"},{"code":"(fn [f col] (apply (partial merge-with concat) (map (fn [x] {(f x) [x]}) col)))","problem":63,"user":"5233ad08e4b07e3ee2be83ac"},{"code":"(fn [f s] (apply merge-with into (map (fn [x] {(f x) [x]}) s)))","problem":63,"user":"4ea365e2535d7eef308072c5"},{"code":"(fn [f x] (reduce #(merge-with into %1 {(f %2) [%2]}) {} x))","problem":63,"user":"4ea9b80c535d7eef30807306"},{"problem":63,"code":"(fn bla\n  ([ f list ] (bla f list { }))\n  ([ f [ first & rest] acc ]\n   (let [update (fn update\n  ([m k f]\n   (assoc m k (f (get m k))))\n  ([m k f x]\n   (assoc m k (f (get m k) x)))\n  ([m k f x y]\n   (assoc m k (f (get m k) x y)))\n  ([m k f x y z]\n   (assoc m k (f (get m k) x y z)))\n  ([m k f x y z & more]\n   (assoc m k (apply f (get m k) x y z more))))]\n   (if (nil? first)\n     acc\n     (recur f rest (update acc (f first) #(conj (or % []) first)))))))","user":"59f90e6ae4b0ca45a743a337"},{"code":"(fn g\n  ([f s] (g f s {}))\n  ([f s r]\n   (if (empty? s)\n     r\n     (let [v (first s)\n           k (f v)]\n       (g f (rest s)\n          (assoc r k (concat (r k) [v])))))))","problem":63,"user":"535d910ae4b04ce2eb3ed2c5"},{"code":"(fn [f s]\n  (persistent!\n    (reduce (fn [acc [k v]] \n              (assoc! acc k (conj (get acc k []) v)))\n          (transient {})\n          (map (fn [a b] [a b]) (map #(f %) s) s))))","problem":63,"user":"4e68b46c535d8ccf87e9fe87"},{"code":"(fn [f args]\r\n  (loop [m {} a args]\r\n    (println a)\r\n    (if (empty? a)\r\n      m\r\n      (let [v (f (first a))]\r\n        (recur (assoc m v (conj (get m v []) (first a)) ) (rest a))))))","problem":63,"user":"4df3df8a535d08e6dec9fe2d"},{"problem":63,"code":"(fn __ [f coll]\n  (let [g (fn [ret x] \n            (let [y (f x)]\n              (if (contains? ret y)\n                (let [y0 (get ret y)]\n                  (assoc ret y (conj y0 x)))\n                (assoc ret y [x]))))]\n     (reduce g {} coll))\n)","user":"593f95d8e4b069cdc2982be3"},{"problem":63,"code":"(fn [f s]\n  (reduce\n    (fn [m x]\n      (assoc m (f x)\n               (conj (m (f x) []) x)))\n    {}\n    s))","user":"53ea5307e4b036ad0777e4e2"},{"problem":63,"code":"(fn my-group-by [f col] (reduce (fn [res val] (let [k (f val)] (assoc res k (conj (get res k []) val)))) {} col))","user":"5d45bd1de4b07c84aa5ae6a4"},{"problem":63,"code":"(fn [pred col]\n  (reduce #(let [r (pred %2)]\n              (if-let [v (get %1 r)]\n                (assoc %1 r (conj v %2))\n                (assoc %1 r [%2]))) {} col))","user":"5f86a98be4b0649ffcda4caa"},{"problem":63,"code":"(fn [f xs]\n (loop [rem xs\n        res {}]\n  (if (empty? rem)\n   res\n   (let [a (first rem)\n         b (f a)]\n    (recur (rest rem) (assoc res b (if-let [c (res b)] (conj c a) [a])))))))","user":"5522cd9ae4b0882d96d091ab"},{"problem":63,"code":"(fn groupByX [f x] (let [part (partition-by f (sort-by f x))] (zipmap (map #(f (first %)) part) (map #(into (empty x) %) part))))","user":"568820e8e4b0dcc4269f4067"},{"problem":63,"code":"(fn [f xs]\n  (reduce\n   (fn [m e]\n     (let [k (f e)\n           p (get m k [])]\n       (assoc m k (conj p e))))\n   {} xs))","user":"5b4b8cd6e4b02d533a91bc9f"},{"code":"(fn [f coll]\n  (loop [x coll map {}]\n    (if (empty? x)\n      map\n      (let [fx (f (first x))]\n        (recur (rest x) (assoc map fx (conj (get map fx []) (first x))))))))","problem":63,"user":"527cd633e4b0757a1b17136f"},{"problem":63,"code":"(fn [a  b] (into {}\n\n              (map #(vector (a (first %))(vec %))\n\n                (partition-by a (sort b)))) )","user":"57b8f784e4b0fbc9809a27ea"},{"problem":63,"code":"(letfn [(update-d [d k v]\n          (merge d { k (conj (or (d k) []) v) }))]\n  (fn [f xs]\n   (reduce (fn [a x] (update-d a (f x) x)) {} xs)))","user":"5884e807e4b0f1effa3b76a6"},{"problem":63,"code":"(fn gpby [f x]\n  (let [fb (fn filtr [f t x]\n               (cond \n                 (empty? x) []\n                 (= (f (first x)) t) (cons (first x) (filtr f t (rest x)))\n                 :default (filtr f t (rest x))))]\n    (let [axis (seq (set (map f x)))\n          fa (fn fung [f m n] \n               (if (empty? m) []\n                 (concat [(first m) (fb f (first m) n)] (fung f (rest m) n))))]\n    (apply hash-map (fa f axis x)))))","user":"56278266e4b00e49c7cb47d3"},{"code":"(fn foo [f s]\n  (reduce\n   #(assoc %1 (f %2) (vec (conj (%1 (f %2)) %2))) {} s))","problem":63,"user":"506755b3e4b03d366d7cb2bc"},{"problem":63,"code":"(fn [f l] \n  (->> (map (fn [a] [(f a) a]) l) \n       (sort #(compare (first %1) (first %2)))\n       (partition-by  first)\n       (mapcat (fn [x] [(ffirst x) (vec (map second x))]))\n      (apply hash-map)\n      )\n)","user":"55da18d5e4b0e31453f64ad1"},{"problem":63,"code":"(fn [f x] (apply merge-with concat (map #(into {} {(f %), [%]}) x)))","user":"564b1ff8e4b0284900eef663"},{"code":"(fn [f c] (reduce #(assoc %1 (f (first %2)) %2) {} (partition-by f (sort-by f c))))","problem":63,"user":"50361b6be4b0fbe0a74d26be"},{"code":"(fn f [f xs]\n  (loop [xs xs m {}]\n    (if (seq xs)\n      (recur (rest xs) (update-in m [(f (first xs))] #(conj (vec %1) (first xs))))\n      m)))","problem":63,"user":"4ee88269535d93acb0a6687f"},{"code":"(fn [f s]\n      (apply merge-with into (map #(hash-map (f %1) [%1]) s)))","problem":63,"user":"52761edae4b03e8d9a4a74d4"},{"problem":63,"code":"(fn algo [lst lst2]\n  (apply merge-with into (for [i lst2] \n                           {(lst i) [i]})))","user":"59e56c75e4b08badc2a0c556"},{"problem":63,"code":"(fn f [mf args] (if (empty? args) {} (merge-with concat {(mf (first args)) (list (first args))} (f mf (rest args)))) )","user":"5686e652e4b0dcc4269f4059"},{"problem":63,"code":"(fn group [f ss]\n  (reduce (fn [acc s] (assoc acc (f s) (conj (get acc (f s) []) s))) \n          {}\n          ss)\n  )","user":"5ade6bafe4b0837691e92c23"},{"problem":63,"code":"(fn gr [f coll]\n  (reduce (fn [m x]\n            (let [k (f x)]\n              (assoc m k (conj (m k []) x)))\n            ) {} coll)\n  )","user":"5488872ee4b0e286459a11d3"},{"problem":63,"code":"(fn group-seq [f xs] \n    (apply merge-with concat (map #(assoc {} (f %) [%]) xs))\n  )","user":"56fa2905e4b07572ad1a88be"},{"problem":63,"code":"(fn grp\n\n    ([f x]\n\n     (grp f x (set (map f x))))\n\n    ([f x s]\n\n     (if (empty? s)\n\n       {}\n\n       (assoc-in (grp f x (drop 1 s)) [(first s)] (apply vector (filter (fn [a](= (f a) (first s))) x))))))","user":"586b6a0ae4b01531a375e957"},{"code":"(fn [f s] (reduce #(assoc % (first %2) \n          (concat (get % (first %2) [])\n                  [(second %2)]))\n          {}\n          (map #(vector (f %) %) s)))","problem":63,"user":"4e0febe6535d04ed9115e7be"},{"problem":63,"code":"(fn -group-by\n    ([f coll]\n     (-group-by {} f coll))\n    ([acc f [x & xs]]\n     (let [acc1 (update-in acc [(f x)] #(if (nil? %) [x] (conj % x)))]\n       (if (nil? xs)\n         acc1\n         (recur acc1 f xs)))))","user":"524740e7e4b05ef8e38e635d"},{"problem":63,"code":"(fn group-by! [f col]\n  (let [keys (distinct (map f col)),\n    keyvals (partition 2 (interleave (map f col) col))]\n    (into {} (map\n      #(vector % (vec (map (fn [x] (second x)) (filter (fn [y] (= (first y) %)) keyvals))))\n      keys))\n    ))","user":"587a3babe4b01531a375eae2"},{"problem":63,"code":"(fn [f xs]\n  (reduce #(let [k (f %2)]\n             (assoc %1 k (concat (%1 k) [%2])))\n          {}\n          xs))","user":"5650b8a0e4b0284900eef6c3"},{"problem":63,"code":"(fn [f xs]\n  (reduce (fn [vs x]\n            (let [key (f x)]\n              (assoc vs key (conj (vs key []) x))))\n          {} xs))","user":"555f3bfde4b0a2eb076a39c1"},{"code":"(fn \n[f coll]  \n  (persistent!\n   (reduce\n    (fn [ret x]\n      (let [k (f x)]\n        (assoc! ret k (conj (get ret k []) x))))\n    (transient {}) coll)))","problem":63,"user":"510d3dc6e4b078ea71921132"},{"code":"(fn [f s] (into {} (map (fn [y] [y (filter #(= y (f %)) s)]) (distinct (map f s)))))","problem":63,"user":"4ed94d69535d10e5ff6f5303"},{"problem":63,"code":"(fn eh [f x]\n  (reduce (fn [x y]\n            (if (x (f y))\n              (assoc x (f y) (conj (x (f y)) y))\n              (assoc x (f y) [y])))\n          {} x))","user":"549c8bbde4b0f3d1d8e70f8c"},{"problem":63,"code":"(fn my-group [fun coll]\n   (reduce (fn [acc elt]\n             (let [k (fun elt)\n                   prev-val (get acc k [])]\n               (assoc acc k (conj prev-val elt)))) {} coll))","user":"54cad2d5e4b057c6fda3a26c"},{"code":"(fn my-group-by\n  [f s]\n  (loop [grouped {}\n         col (seq s)]\n    (if-let [v (first col)]\n      (recur (assoc grouped (f v) (conj (vec (get grouped (f v))) v)) (rest col))\n      grouped)))","problem":63,"user":"51008b6fe4b0700a7a02d6e4"},{"code":"(fn [f coll]\n    (apply merge-with concat\n      (map #(apply hash-map %)\n        (partition 2\n          (interleave (map f coll)\n                      (map vector coll))))))","problem":63,"user":"4f4e4ecbe4b03ad3f0c10cbf"},{"code":"(fn [f seq]\n   (loop [result {} elements seq] \n     (if (empty? elements)\n       result\n       (if (not (nil? (result (f (first elements)))))         \n         (recur (into result {(f (first elements))  (conj (result (f (first elements))) (first elements)) }) (rest elements))\n         (recur (into result {(f (first elements)) [(first elements)]}) (rest elements))\n         )              \n     )\n   )\n   )","problem":63,"user":"5106dc1be4b01150e115ebf0"},{"code":"(\n  fn sol[ func coll ] (\n\t\tlet [ s1 ( set ( map func coll ) )] (\n\t\t\t\treduce (\n\t\t\t\t\t\tfn reducef [ s2 a ](\n\t\t\t\t\t\t\tassoc s2 a (\n\t\t\t\t\t\t\t\tfilter #( = a ( func % ) ) coll \t\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t)\n\t\t\t\t\t) {} s1\n\t\t)\n\t)\n)","problem":63,"user":"50bf7b72e4b0ffd967a66cc1"},{"problem":63,"code":"#(reduce \n  (fn [accum x] \n    (let [k (%1 x)]\n      (assoc accum k \n        (conj (get accum k []) x)))) \n  {} %2)","user":"5764cc01e4b0994c1922fc05"},{"code":"(fn [f coll] \n  (persistent!\n   (reduce\n    (fn [ret x]\n      (let [k (f x)]\n        (assoc! ret k (conj (get ret k []) x))))\n    (transient {}) coll)))","problem":63,"user":"5100d7dbe4b04f1d96d946df"},{"problem":63,"code":"(fn mygroup-by [f xs]\n  (reduce #(assoc %1 (f %2) (conj (get %1 (f %2) []) %2)) {} xs))","user":"53e8c684e4b036ad0777e48b"},{"problem":63,"code":"(fn group [f s]\n  (apply merge-with concat\n         (map (fn[elem] {(f elem) [elem]}) s)\n  ))","user":"525d44bfe4b0cb4875a45d6d"},{"problem":63,"code":"(fn my-group-by [f coll]\n  (reduce (fn [acc e] (assoc acc (f e) (conj (vec (acc (f e))) e))) {}  coll))","user":"5897dda4e4b00487982d52c8"},{"problem":63,"code":"(fn [f s]\n   (apply merge-with concat (map (fn [a b] {a (vector b)}) (map f s) s)))","user":"5840c068e4b089d5ab817df8"},{"code":"(fn [f s]\n  (let [k (distinct (map f s))]\n    (zipmap k (map (fn [r] (filter #(= r (f %)) s)) k))))","problem":63,"user":"538be6afe4b0640c7a9a58c9"},{"problem":63,"code":"(fn [f s] (reduce (fn [m k] (let [v (f k)] (assoc m v (conj (get m v []) k)))) {} s))","user":"5b3f2ba9e4b02d533a91bc09"},{"code":"(fn [func seq]\n  (let [keys (distinct (map func seq))\n        empty-map (into {} (map #(hash-map % []) keys))]\n    (letfn [(fillmap [amap sequence]\n        (if (= 0 (count sequence)) amap\n          (fillmap (merge amap(hash-map (func (first sequence)) (conj (get amap (func (first sequence))) (first sequence)))) (drop 1 sequence))))]\n  \t  (fillmap empty-map seq))))","problem":63,"user":"504eff22e4b0e7ad84dbc4a9"},{"problem":63,"code":"(fn [f vals]\n  (into {}\n        (map #(vector (f (first %)) (vec %))\n             (partition-by f (sort vals)))))","user":"56d4b22de4b0ea9b8538f7bb"},{"code":"(fn [f c]\n  (zipmap (distinct (map f c))\n   (partition-by f (sort-by f c))))","problem":63,"user":"4e77c1db535d324fb2983d72"},{"problem":63,"code":"(fn\n  [f s]\n  (into {} (map (fn [p] {(f (first p)) (vec p)}) (partition-by f (sort s)))))","user":"57efb389e4b0bfb2137f5bdb"},{"code":"(fn [f coll]\n  (reduce \n   (fn [m i] (assoc m (f i) (vec (conj (get m (f i)) i)))) \n   {} \n   coll))","problem":63,"user":"532418f3e4b09d4e7a9b54d8"},{"code":"(fn [f s]\n  (reduce\n\t\t(fn [accum next]\n\t\t\t(let [key (f next), previous (get accum key)]\n\t\t\t\t(if (nil? previous)\n\t\t\t\t\t(assoc accum key [next])\n\t\t\t\t\t(assoc accum key (conj previous next)))))\n\t\t{}\n\t\ts))","problem":63,"user":"4fb57e06e4b081705acca2bf"},{"code":"(fn group-a-sequence [pf c]\n  (reduce \n   \n   (fn [a x]\n     (let [k (pf x)\n           v (a k)]\n       (if-not (nil? v) \n         (assoc a k (conj v x))\n         (assoc a k [x]))))\n\n   {}\n   c))","problem":63,"user":"515bbcd9e4b0388ca8ca1521"},{"code":"(fn [f args] (reduce (fn [m x] (if (contains? m (f x)) (update-in m [(f x)] #(conj % x)) (assoc m (f x) [x]))) {} args))","problem":63,"user":"52aad30ce4b0c58976d9ac6d"},{"problem":63,"code":"(fn [f s]\n (let [ks (into #{} (map f s))\n       r (fn [k]\n           (reduce (fn [acc x]\n                     (if (= (f x) k)\n                       (conj acc x)\n                       acc   ))\n                   []\n                   s))]\n   (reduce (fn [acc k]\n             (assoc acc k (r k)) )\n           {}\n      ks     )\n   ))","user":"5b15ab32e4b0cc2b61a3be72"},{"problem":63,"code":"(fn [f xs]\n  (reduce (fn [m x]\n            (let [rf (f x)\n                  rl (conj (vec (get m rf)) x)\n                  c (count (get m rf))]\n              (assoc m rf rl)\n              )\n            ) {} xs)\n  )","user":"52824143e4b0757a1b171453"},{"problem":63,"code":"(fn [f coll] (reduce #(let [k (f %2)] (assoc %1 k (conj (get %1 k []) %2))) {} coll))","user":"581dad0ae4b04b46fc4b0f17"},{"problem":63,"code":"(fn [f c] (reduce #(assoc % (f (first %2)) %2) {} (partition-by f (sort-by f c))))","user":"563b1553e4b0bfe05bf1180a"},{"code":"#(reduce (fn [h x] (let [k (% x)] (assoc h k (conj (h k []) x)))) {} %2)","problem":63,"user":"4ee6400c535d93acb0a6685b"},{"code":"(fn [f s]\n  (let [grouper\n    (fn [res e]\n      (let [k (f e)]\n        (assoc res k (concat (res k) [e]))\n      ))]\n    (reduce grouper {} s)))","problem":63,"user":"4eddcbbf535d10e5ff6f532d"},{"problem":63,"code":"(fn [f s] (reduce (fn [val-map val] (update-in val-map [(f val)] #(vec (conj % val)))) {} s))","user":"592ac17ae4b072a2710fcf26"},{"code":"(fn [f coll](reduce conj (map (fn [x](hash-map x ( vec( filter #(= (f %) x ) coll)) )) (set(map f coll)))))","problem":63,"user":"52bbd09ee4b07a9af57922ee"},{"problem":63,"code":"(fn my-group-by [predicate l]\n  (reduce\n    (fn [result val]\n      (let [key (predicate val)]\n        (assoc result key (conj (get result key []) val))\n        )\n      )\n    (hash-map)\n    l)\n  )","user":"563b9acbe4b0bfe05bf11827"},{"code":"(fn group- [f coll]\n  \"63. Given a function f and a sequence s, write a function which                                                                                                      \n  returns a map.\"\n  (if-let [s (seq coll)]\n    (let [m (group- f (rest s))\n          v (first s)\n          k (f v)\n          l (get m k '())]\n      (assoc m k (conj l v)))\n    (hash-map)))","problem":63,"user":"4e5eb843535d8a8b8723a2d4"},{"problem":63,"code":"(fn [f xs] (reduce #(update-in %1 [(f %2)] (fn [xs] (conj (or xs []) %2))) {} xs))","user":"54d6c80ce4b0a52adc2e2020"},{"code":"(fn [func data]\r\n    (apply hash-map (mapcat #(vector % (filter (fn [x] (= % (func x))) data))\r\n                            (set (map func data)))))","problem":63,"user":"508b95a0e4b0be79e5b189c6"},{"code":"(fn [f xs] (let [ks (set (map f xs)) vs (map (fn [k] (filter #(= k (f %)) xs)) ks)] (zipmap ks vs)))","problem":63,"user":"4ff769bce4b0678c553fc38f"},{"problem":63,"code":"#(->> (map vector %2)\n      (interleave (map %1 %2))\n      (partition 2)\n      (map (partial apply hash-map))\n      (reduce (partial merge-with concat)))","user":"536b9d8ae4b0243289761ebe"},{"problem":63,"code":"(fn [func coll]\n  (loop [grouped {} coll coll]\n    (if (empty? coll)\n      grouped\n      (let [value (func (first coll)) group (filter #(= value (func %)) coll) remaining (filter #(not (= value (func %))) coll)]\n       (recur (assoc grouped value group) remaining)\n     )\n    )\n  )\n )","user":"5de6484ce4b0986d99407f66"},{"code":"#(reduce (fn [m c] (assoc m (% c) (conj (m (% c) []) c))) {} %2)","problem":63,"user":"4ee9ddb8535d93acb0a66896"},{"code":"(fn [f c]\n  (loop [r {}, s c]\n    (if (seq s)\n      (let [a (first s) xs (rest s)] \n        (recur (assoc r (f a) (conj (get r (f a) []) a)) xs)\n      )\n      r\n    )\n  )\n)","problem":63,"user":"5098bcfee4b0cae2931060a1"},{"code":"(fn [f s]\n  (let [k (distinct (map f s))]\n    (zipmap k (map #(vec (filter (comp (partial = %) f) s)) k))\n  ))","problem":63,"user":"529e8ba9e4b04e0c58e87b99"},{"code":"(fn grp [f target]\n  (let [kys  (set (map f target))]\n    (zipmap\n     kys\n     (for [x kys]\n       (filter #(= x (f %)) target)))))","problem":63,"user":"504e108ce4b078edc5f593b3"},{"problem":63,"code":"(fn [f col]\n  (zipmap\n  (distinct (map f col))\n  (partition-by f (sort col))))","user":"54bcab07e4b0ed20f4ff6ed5"},{"code":"(fn [f c] (apply merge-with concat (map #(hash-map (f %) [%]) c)))","problem":63,"user":"4db2cd84535df7e46ed9b6c6"},{"problem":63,"code":"(fn [f s]\n  (into {}\n        (map #(vector (f (first %)) %)\n             (partition-by f (sort-by f s)))))","user":"553527ede4b09218d5f44fab"},{"code":"(fn [f coll]\r\n  (reduce\r\n    (fn [ret x]\r\n      (let [k (f x)]\r\n        (assoc ret k (conj (get ret k []) x))))\r\n    {} coll))","problem":63,"user":"4e570b60535d8a8b8723a286"},{"code":"(fn [f s]\n    (reduce (fn[m e]\n              (let [k (f e) c (m k []) ]\n                (assoc m k (conj c e)))) {} s))","problem":63,"user":"5007cdb9e4b0b17c647f5227"},{"problem":63,"code":"(fn [f coll] (reduce (fn [m x](let [k (f x)] (assoc m k (conj (m k []) x)))) {} coll)) \n; see solution by hypirion! very nice! but in my solution, accidentally I produced almost the same impl as\n; can be seen in the standard Clojure library :)","user":"57e33f6fe4b0bfb2137f5a96"},{"problem":63,"code":"(fn my-gb [f s] (if s (let [v (first s) k (f v) ret (my-gb f (next s))](assoc ret k (cons v (ret k []) ))) {}))","user":"56dc3dbbe4b0ea9b8538f81a"},{"code":"(fn f [g s]\n  (if (= 1 (count s))\n    {(g (last s)) [(last s)]}\n    (let [m (f g (butlast s)) old (get m (g (last s))) ]\n      (assoc m (g (last s))\n        (if old\n          (conj old (last s))\n          [(last s)])))))","problem":63,"user":"4e8b98fc535d65386fec2124"},{"code":"(fn [f s] (reduce #(merge-with concat % {(f %2) [%2]}) {} s))","problem":63,"user":"4ebb78a2535dfed6da9c6d70"},{"code":"(fn [f coll] \n  (apply merge-with #(vec(concat %1 %2)) (map (fn [x] {(f x) [x]}) coll)))","problem":63,"user":"51696ee7e4b03f62cda68ce8"},{"problem":63,"code":"(fn [f coll]\n   (reduce\n    (partial merge-with concat)\n    (map (fn [a b]{a [b]}) (map f coll) coll)))","user":"5b67f0fbe4b0c6492753e76d"},{"problem":63,"code":"(fn my-group-by\n  [f coll]\n  (if (empty? coll)\n    {}\n    (let [previous (my-group-by f (rest coll))\n          head (first coll)\n          head-key (f head)]\n      (if (contains? previous head-key)\n        ;(update previous head-key conj head)\n        (assoc previous head-key (cons head (get previous head-key)))\n        (assoc previous head-key [head])))))","user":"5f29837ee4b033932238a64f"},{"problem":63,"code":"(fn custom-group-by\n  [f s]\n  (loop [res {} values (seq s)]\n    (if values\n      (recur\n        (#(assoc %1 %2 (%3 (get %1 %2))) res (f (first values)) #(apply vector (conj % (first values))))\n        (next values))\n      res))\n  )","user":"5c20b6abe4b07e362c230576"},{"problem":63,"code":"(fn mygb [f xs] (apply merge-with concat (map #(hash-map (f %) (vector %)) xs)))","user":"57c6aa0be4b05aa3c4741cf7"},{"problem":63,"code":"(fn [fun args]\n    (reduce (fn [hmap arg]\n              (let [result (fun arg)\n                    results (if (nil? (hmap result)) \n                              [] \n                              (hmap result))]\n                (assoc hmap result (conj results arg)))) {} args))","user":"57974188e4b039eba2ecb0f4"},{"problem":63,"code":"#(loop [func %1, result {}, input %2]\n   (if (empty? input)\n     result\n     (let [input1 (first input), key1 (func input1), value (get result key1)]\n       (if (nil? value)\n         (recur func (assoc result key1 (vector input1)) (rest input))\n         (recur func (assoc result key1 (conj value input1)) (rest input))))))","user":"57f52d3be4b0903ccab3dce7"},{"problem":63,"code":"(fn [f coll]\n  (reduce (fn [acc e]\n              (let [value (f e)\n                    entry (or (acc value) [])]\n                (assoc acc\n                       value\n                       (conj entry e))))\n            {}\n            coll))","user":"56826ebce4b0945ebc182a93"},{"problem":63,"code":"(fn [key x]\n  (reduce\n    (fn [acc v]\n      (update-in acc [(key v)] #(conj (or % []) v)))\n    {} x))","user":"5ccb0bbee4b0ccb06196287c"},{"problem":63,"code":"#(apply merge-with into \n        (for [x %2] \n          {(% x) [x]}))","user":"5e9d1c75e4b0157ca9664801"},{"problem":63,"code":"(fn [a  b] (into {}\n              (map #(vector (a (first %))(vec %))\n                (partition-by a (sort b)))) )","user":"53ada652e4b047364c04446d"},{"problem":63,"code":"(fn F1 [f xs]\n  (let [ss (vec (set (map f xs)))]\n    (apply assoc {}\n           (interleave ss\n     (for [s ss]\n       (filter #(= s (f %)) xs))\n       ))))","user":"53ca23e3e4b00fb29b2212c6"},{"problem":63,"code":"(fn grp [f s]\n  (reduce #(let [r (f %2)]\n             (if (contains? %1 r)\n               (conj %1 [r (conj (%1 r) %2)])\n               (conj %1 [r [%2]])))\n          {}\n          s))","user":"5f8b06afe4b0715f5002d74a"},{"problem":63,"code":"(fn [f l] (apply hash-map (mapcat (fn [v] [v (filter (fn [x] (= (f x) v)) l)]) (distinct (map f l)))))","user":"571aad45e4b07c98581c3b59"},{"code":"(fn [f s]\n  (reduce (partial merge-with concat)\n          (map (fn [x] {(f x) [x]})\n               s)))","problem":63,"user":"4e6a2f93535d8ccf87e9feaa"},{"problem":63,"code":"(fn [f s]\n  (loop [xs s\n         r {}]\n    (if (empty? xs)\n      r\n      (let [y (f (first xs))\n            ys (get r y [])]\n      \t(recur (rest xs) (assoc r y (conj ys (first xs))))))))","user":"5283a919e4b0239c8a67adbe"},{"problem":63,"code":"(fn [f xs]\n  (reduce (fn [m v] \n            (let [k (f v)]\n              (assoc m k (conj (m k []) v))))\n          {} xs))","user":"54acf5c7e4b09f271ff37cdd"},{"problem":63,"code":"(fn q [f s]\n    (reduce \n     (fn [a v] \n       (assoc a (f v) (conj (get a (f v) []) v))) \n     {} \n     s))","user":"603ae21de4b0d5df2af222fb"},{"code":"(fn [f s]\n  (reduce (fn [m v] \n    (update-in m [(f v)] #(if % (conj % v) [v]))) {} s))","problem":63,"user":"4f4fbed7e4b03ad3f0c10ce8"},{"problem":63,"code":"(fn group_sequence \n  [i coll]\n  (loop [x coll \n         map {}]\n    (if (empty? x)\n      map\n      (let [fx (i (first x))]\n        (recur (rest x) \n               (assoc map fx (conj (get map fx []) (first x))))))))","user":"5ea3711ae4b00a66d4a9519d"},{"code":"(fn [f in]\n  (reduce \n   (fn [acc new]\n     (let [old_grouping (get acc (f new) [])]\n      (assoc \n        acc       \n        (f new)\n         (conj \n        \n         old_grouping\n          new\n         )\n        )\n     ))\n   {}\n   in\n   \n   )\n  \n  )","problem":63,"user":"4edf95a8535d10e5ff6f5342"},{"code":"#(reduce (fn [m x]\n  (assoc m (%1 x) (conj (vec (m (%1 x))) x))) {} %2)","problem":63,"user":"4fe9de74e4b0547ebccb2475"},{"code":"(fn [f s]\n      (reduce\n        (fn [a e] \n          (let [key (f e)]\n            (assoc a key \n              (if\n                (contains? a key)\n                (conj (a key) e)\n                [e] ) ) ) ) {} s ) )","problem":63,"user":"51e28063e4b08e53a149f0f2"},{"code":"(fn [f xs]\n  (reduce #(merge % {(f %2) (conj (get % (f %2) []) %2)}) \n          (hash-map) \n          xs))","problem":63,"user":"509eeb3be4b08df8156e9e37"},{"code":"(fn [f s]\n  (reduce \n    (fn [m v]\n      (let [k (f v) vs (m k) vs+ (if (nil? vs) [] vs)]\n        (assoc m k (conj vs+ v))))\n    {}\n    s))","problem":63,"user":"50901b2ee4b0ea685a20f774"},{"problem":63,"code":"(fn [f s] (reduce #(let [k (f %2)]\n                     (assoc % k (conj (% k []) %2))) {} s))","user":"55ccdc6be4b0e31453f64a18"},{"code":"(fn [f xs]\n  (apply merge-with concat \n    (map #(hash-map (f %) (vector %)) xs)))","problem":63,"user":"5055899de4b0ce54f56f03fd"},{"problem":63,"code":"(fn grp [fun input]\n    (loop [acc {}\n           f fun\n           coll input]\n        (if (empty? coll)\n            acc\n            (recur\n                (update-in acc\n                           [(f (first coll))]\n                           #(vec (conj % (first coll))))\n                f\n                (rest coll)))))","user":"540e8d13e4b0addc1aec671e"},{"problem":63,"code":"(fn [f se]\n (reduce (fn [h v]\n            (update-in h [(f v)] #(conj (or % []) v)))\n          {} se))","user":"56018dd4e4b04bb52996e18f"},{"problem":63,"code":"(fn f63 [f coll]\n  (->> (map f (sort-by f coll))\n       (map #(hash-map %2 %1) (sort-by f coll))\n       (partition-by keys)\n       (map (fn [x] (hash-map ((comp first flatten distinct ) (map keys x)) (mapv #((comp first vals) %) x))))\n       (apply merge)))","user":"57bbc9bde4b05aa3c4741c31"},{"problem":63,"code":"(fn fn63 [f xs]\n  (reduce\n     #(assoc %1 %2 (filter (fn [a] (= %2 (f a))) xs))\n     {}\n     (set (map f xs))))","user":"5e42ba49e4b01d43a70e8e6c"},{"problem":63,"code":"(fn f [k coll]\n  (reduce \n    (fn [c v] \n      (update-in c [(k v)] (fnil conj []) v))  \n    {} coll))","user":"585a7cb2e4b0f14aab7c874e"},{"code":"(fn grp-seq [func vals]\n  (into {}\n        (map #(vector (func (first % )) (vec %))\n             (partition-by func (sort vals)))))","problem":63,"user":"4fc2e302e4b081705acca33a"},{"code":"#(apply merge-with concat (for[i %2]{(%1 i)[i]}))","problem":63,"user":"530cb5b8e4b02e82168697e0"},{"problem":63,"code":"(fn [f xs]\n        (reduce #(assoc %1 (f %2) (vec (conj (get %1 (f %2)) %2))) {} xs)  \n          )","user":"533c2605e4b0e30313ee6cd7"},{"problem":63,"code":"(fn [func seqy]\n  (loop [f func, s seqy, final {}]\n    (if (empty? s)\n      final\n      (if (not (contains? final (f (first s))))\n        (recur f (rest s) (assoc final (f (first s)) (vector (first s))))\n        (recur f (rest s) (assoc final (f (first s)) (conj (get final (f (first s))) (first s))))))))","user":"59369515e4b02506e01a297e"},{"code":"#(reduce (fn [m x]\n           (let [y (%1 x) v (m y)]\n             (assoc m y (if (nil? v) [x] (conj v x)))))\n         {} %2)","problem":63,"user":"538d8bb8e4b0b51d73faae71"},{"code":"(fn [f xs]\n  (reduce\n   (fn [m [k v]]\n     (assoc m v (conj (m v []) k)))\n   {}\n   (map list xs (map f xs))))","problem":63,"user":"510db6cde4b078ea71921145"},{"problem":63,"code":"(fn\n    [f col]\n    (reduce (fn [m value]\n              (println value)\n              (let [r (f value)]\n                (assoc m r (conj (vec (m r)) value))))\n            {} col))","user":"59473563e4b07ddc2dafad97"},{"code":"(fn [f xs] (reduce #(merge-with concat %1 {(f %2) [%2]}) {} xs))","problem":63,"user":"4fb65f2fe4b081705acca2c7"},{"code":"(fn [f coll]\n  \t  (reduce #(let [k (f %2)] \n\t\t\t    (assoc %1 k (conj (%1 k []) %2))) {} coll))","problem":63,"user":"4f052eaf535dcb61093f6bf3"},{"problem":63,"code":"(fn [f s] \n  (loop [key-coll (map f s)\n         s s\n         result {}]\n    (if (empty? s)\n      result\n      (let [akey (first key-coll)\n            value (first s)\n            vec-val (get result akey) \n            new-val (if vec-val (conj vec-val value) (vector value))\n            new-result (assoc result akey new-val)]\n        (recur \n         \t\t(rest key-coll)\n         \t\t(rest s)\n         \t\tnew-result)))))","user":"567d18c9e4b05957ce8c61c4"},{"problem":63,"code":"(fn [f s]\n  (reduce\n   #(if-let [g (%1 (f %2))]\n      (conj %1 [(f %2) (conj g %2)])\n      (conj %1 [(f %2) [%2]]))\n   {}\n   s))","user":"598229d6e4b021a7a535fdfb"},{"problem":63,"code":"(fn g [f v]\n  (into {}\n        (map #(vector (f (first % )) (vec %))\n             (partition-by f (sort v)))))","user":"6074f5ede4b069485764de52"},{"problem":63,"code":"(fn [f coll]\n  (loop [[x & xs] coll\n         acc {}]\n    (if x\n      (if (contains? acc (f x))\n        (recur xs (assoc acc (f x) (conj (acc (f x)) x)))\n        (recur xs (assoc acc (f x) [x])))\n      acc)))","user":"5643a11ee4b0018b46ad8bfb"},{"problem":63,"code":"(fn [f sq] (reduce (fn [m v] (let [tr (f v)] (assoc m tr (conj (get m tr []) v)))) {} sq))","user":"5ecc0831e4b016b56eae058c"},{"problem":63,"code":"(fn [f coll]\n  (reduce\n   (fn [ acc x ]\n     (let [k (f x)]\n          (assoc acc k (conj (get acc k []) x))))\n   {} coll))","user":"582835cbe4b051871117bf30"},{"code":"#(reduce\n   (fn [c x] (assoc c (% x) (conj (c (% x) []) x)))\n   {} %2)","problem":63,"user":"50705886e4b07bd6ad9b9f2a"},{"code":"(fn [f s]\r\n  (reduce\r\n    (fn [acc e]\r\n      (let [res (f e)\r\n            gp (get acc res [])]\r\n        (conj acc [res (conj gp e)])))\r\n    {}\r\n    s))","problem":63,"user":"4ee40938535d10e5ff6f5375"},{"problem":63,"code":"#(reduce (fn [r c]\n           (if (get r (%1 c))\n             (update-in r [(%1 c)] conj c)\n             (assoc r (%1 c) [c])))\n         {} %2)","user":"55db7e15e4b0e31453f64ae8"},{"problem":63,"code":"(fn gas [f coll]\n  (let [kv (map #(vector % (f %)) coll)]\n    (reduce (fn [m [k v]] (let [ov  (m v [])]\n                            (assoc m v (conj ov k)))) {} kv)))","user":"552e1c98e4b076ab5578f7ee"},{"problem":63,"code":"(fn my-group-by [f s]\n  (if (empty? s)\n    {}\n    (let [v (first s)\n          k (f v)]\n      (merge-with #(into [] (concat %2 %1)) (my-group-by f (rest s)) {k [v]}))))","user":"54125eeee4b01498b1a719d3"},{"problem":63,"code":"(fn [f s] (reduce #(update-in %1 [(f %2)] conj %2) {} (reverse s)))","user":"56d68cbae4b0ea9b8538f7cd"},{"code":"#(reduce (fn [x y] \n            (assoc x (key (first y)) (conj (get x (key (first y)) []) (val (first y))) ) )\n          {} \n          (map hash-map (map % %2) %2))","problem":63,"user":"50cf2267e4b0e61f11ddcd8c"},{"code":"(fn [f l] \n  (reduce \n    (fn [m e] \n      (let [k (f e) v (m k)] (assoc m k (if v (conj v e) [e])))) \n    {} \n    l))","problem":63,"user":"4f69f34fe4b07046d9f4ef90"},{"problem":63,"code":";(fn group-by' [f coll]\n;  (reduce (fn [m e]\n;            (let [applied (f e)]\n;              (if (contains? m applied)\n;                (assoc m applied (conj (m applied) e))\n;                (assoc m applied [e]))))\n;          {}\n;          coll))\n\n(fn group-by' [f coll]\n  (reduce (fn [m e]\n            (let [applied (f e)]\n                (assoc m applied (conj (get m applied []) e))))\n          {}\n          coll))","user":"5d1be50ce4b02ea6f0fb6986"},{"code":"(fn [f col]\n  (reduce \n   #(assoc % (f %2) (conj (% (f %2) []) %2)) \n   {} \n   col))","problem":63,"user":"50be9b4ae4b00fb48fed2ef6"},{"code":"(fn [f coll]\n  (loop [m {} s coll]\n    (if (empty? s) m\n      (let [x (first s)\n            r (f x)]\n        (recur (assoc m r (conj (m r []) x)) (rest s))))))","problem":63,"user":"537f4652e4b06839e8705eb1"},{"problem":63,"code":"(fn my-groupby\n  [f xs]\n  (reduce (fn [accum x]\n            (assoc accum (f x) (concat (accum (f x)) (list x))))\n          {}\n          xs))","user":"5c222b7de4b07e362c230588"},{"code":"(fn gb [f x] \r\n  (let [um (fn [m kv] (assoc m (first kv) (conj (or (m (first kv)) []) (second kv))))]\r\n  \t(reduce um {} (map #(vector %2 %) (map identity x)(map f x)))))","problem":63,"user":"4f048f67535dcb61093f6bd3"},{"problem":63,"code":"(fn [f xs]\n   (loop [[x & xs] xs acc {}]\n     (cond (nil? x) acc\n           (contains? acc (f x)) (recur xs (assoc acc (f x) (conj (acc (f x)) x)))\n           :else (recur xs (assoc acc (f x) [x])))))","user":"546176e7e4b01be26fd746a2"},{"code":"(fn[f,x](apply merge (map (fn[k](assoc {} k (filter #(= k (f %)) x))) (distinct (map f x)))))","problem":63,"user":"52d66ca0e4b09f7907dd135c"},{"problem":63,"code":"(fn [f s]\n  (into {} (for [k (distinct (map f s))]\n          {k (filter #(= (f %) k) s)})))","user":"5c950334e4b048ec896c5a44"},{"problem":63,"code":"#(reduce (fn [a v] (assoc a (% v) (conj (get a (% v) []) v))) {} %2)","user":"577832f4e4b0979f8965165b"},{"code":"#(apply merge-with concat\n  (for [x %2] {(% x) [x]}))","problem":63,"user":"4f6fbb68e4b07046d9f4efeb"},{"code":"(fn [f1 coll]\n    (letfn [(my-group-by [f1 coll result]\n              (if (empty? coll) result\n                  (let [val (first coll)\n                        key (f1 val)]\n                    (my-group-by f1\n                                 (rest coll)\n                                 (if (contains? result key)\n                                   (merge-with conj result {key val})\n                                   (merge-with conj result {key (vector val)}))))))]\n      (my-group-by f1 coll {})))","problem":63,"user":"4f98ead0e4b0dcca54ed6cf8"},{"problem":63,"code":"(fn gr_by [f s]\n  (let [r (distinct (map f s))\n        r_in (map-indexed vector (map f s))\n        res (for [i r :let [a (map first (filter #(= (last %) i) r_in))\n                        el_n (for [j a] (nth s j))]] [i (vec el_n)])\n        ]\n    (into {} (vec res))\n    )\n  )","user":"5c52f3fce4b0fb8c5ffd99e9"},{"problem":63,"code":"#(reduce \n  (fn [a x]\n    (merge-with concat a {(%1 x) [x]}))\n    {} %2)","user":"5e3a25d4e4b01d43a70e8dde"},{"code":"(fn [f coll]\n  (reduce (fn [acc x]\n            (update-in acc [(f x)] (fnil conj []) x))\n          {} coll))","problem":63,"user":"5300158ae4b0d8b024fd370f"},{"problem":63,"code":"(fn [f xs] (apply hash-map (mapcat #(list (f (first %)) %) (partition-by f (sort xs)))))","user":"5590ebb1e4b0277789237677"},{"problem":63,"code":"(fn \n  [f s] \n  (reduce \n    #(merge-with \n      concat \n      %1 \n      %2) \n    (map \n      #(hash-map (f %1) [%1]) \n      s)))","user":"5b3de9a7e4b02d533a91bbf4"},{"problem":63,"code":"(fn my-group-by [f s]\n  (let [ks (set (map f s))\n        bag (into {} (map #(hash-map % []) ks))]\n    (reduce #(assoc % (f %2) (conj (% (f %2)) %2)) bag s)))","user":"53bf0913e4b0c98a41f5cc99"},{"problem":63,"code":"(fn [f coll]\n  (let [x (partition-by f (sort-by f coll))]\n    (apply hash-map (interleave (map #(f (first %)) x) x))\n    ))","user":"55933c7ae4b0c79f6e1db938"},{"problem":63,"code":"(fn mgroup-by ([f coll] \n                 (persistent!\n                   (reduce \n                     (fn [ret x]\n                       (let [k (f x)]\n                         (assoc! ret k (conj (get ret k []) x))))\n                       (transient {}) coll))))","user":"5900d5cde4b0438e51c2d02e"},{"code":"(fn [f xs]\n  (reduce (fn [acc x]\n            \n            (update-in acc [(f x)] #(conj (vec %) x)) ) {} xs))","problem":63,"user":"50611456e4b0dc10a69545a5"},{"problem":63,"code":"(fn [func args]\n   (println func args)\n   (reduce #(let [k (func %2)]\n              (if (contains? %1 k)\n                (assoc %1 k (conj (get %1 k) %2))\n                (assoc %1 k [%2]))) {} args)\n   \n   )","user":"5df75fd8e4b0a607a9a45c92"},{"code":"(fn [f c]\n  (loop [i 0\n         m (zipmap (set (map f c)) (repeat []))]\n    (if (< i (count c))\n      (recur (inc i) (assoc m\n                       (f (nth c i))\n                       (conj (m (f (nth c i)))\n                       (nth c i))))\n      m)))","problem":63,"user":"51ab70c3e4b04e3dc0c27b33"},{"problem":63,"code":"(fn [f coll]\n    (apply merge-with concat\n     (map (fn [x]\n            {(f x) [x]})\n          coll)))","user":"5a084a24e4b01bb0ae8afdf2"},{"code":"(fn [f x]\n  (let [d (distinct (map f x))]\n    (apply sorted-map\n      (interleave d\n        (map\n          (fn [item]\n            (filter #(= item (f %)) x)\n          )\n        d)\n      )\n    )\n  )\n)","problem":63,"user":"4e3456f9535deb9a81d77f2a"},{"problem":63,"code":"(fn [f items]\n  (loop [xs items\n         result {}]\n    (if (empty? xs)\n      result\n      (recur\n        (rest xs)\n        (let [f-applied (f (first xs))]\n          (assoc result f-applied (concat (get result f-applied []) [(first xs)])))))))","user":"5524120fe4b0882d96d091b7"},{"problem":63,"code":"(fn [f l]\n   (reduce\n     (fn [acc [k v]]\n       (assoc acc k (cons v (acc k))))\n     {}\n     (reverse (map #(list (f %) %) l))))","user":"56050f06e4b08b23635d3161"},{"problem":63,"code":"#(apply merge-with concat (map (fn [item] (hash-map (%1 item) [item])) %2))","user":"5a99b688e4b0d174b936c7a6"},{"problem":63,"code":"(fn [f c]\n  (reduce\n    #(let [k (f %2)]\n       (assoc % k (if-let [v (get % k)] (conj v %2) (vector %2))))\n    {} c))","user":"5f393bd6e4b0574c87022c76"},{"code":"#(reduce \n  (fn [m e] (assoc m (% e) (conj (m (% e) []) e)))\n  {} \n  %2)","problem":63,"user":"4daa374930acd6ed13482a68"},{"code":"(fn [f xs] \n  (apply merge-with concat \n    (map #(hash-map (f %) [%]) xs)))","problem":63,"user":"507a396be4b08327cd804a69"},{"problem":63,"code":"(fn grp-by [f coll]\n  (->> coll\n       (map #(list (f %) %))\n       (sort-by first)\n       (partition-by first)\n       (map (fn [l]\n              (let [key (first (first l))\n                    values (map second l)]\n                (vector key values))))\n       (into {})))","user":"58fc92c5e4b0438e51c2cf9a"},{"code":"(fn [the-fn the-seq]\n   (->> (map #(vector (the-fn %) %) the-seq )\n        (reduce (fn [cont it]\n                  (conj cont [\n                              (first it) (if-let [actual (cont (first it))]\n                                               (conj actual (second it))\n                                               [(second it)]\n                                               )\n                               ])\n                  ) {})\n        ))","problem":63,"user":"50550f43e4b0b1b9d1860eb7"},{"code":"(fn a [f col] (loop [m {} c col] (if(empty? c)(identity m)(let [x (first c) k (f x)] (recur (assoc m k (concat (m k) [x])) (next c))))))","problem":63,"user":"527a8eb7e4b03e8d9a4a755f"},{"problem":63,"code":"(fn [f coll]\n  (apply merge-with into (for [v coll] {(f v) [v]})))","user":"5abc5a09e4b073f1774426e9"},{"problem":63,"code":"(fn [f coll]\n  (reduce (fn [m x]\n            (let [res (f x)\n                  v (get m res [])]\n              (assoc m res (conj v x))\n            )\n          )\n          {}\n          coll)\n)","user":"5d07989ee4b0cc9c915881fb"},{"code":"(fn [f coll]\n  (apply merge-with into\n    (map (fn [x] {(f x) [x]})\n         coll)))","problem":63,"user":"4e2b1d48535deb9a81d77f03"},{"problem":63,"code":"(fn my-group-by [f coll]\n  (reduce (fn [m x]\n            (if (contains? m (f x))\n              (assoc m (f x) (conj (get m (f x)) x))\n              (assoc m (f x) [x])))\n          {} coll))","user":"5622af0fe4b03f08ee9a922b"},{"problem":63,"code":"(fn [f coll]\n  (reduce (fn [m v] \n            (update-in m\n                       (vector (f v))\n                       (fnil conj [])\n                       v))\n          {} coll))","user":"5eb741e4e4b00a66d4a9523b"},{"problem":63,"code":"(fn [f l]\n(loop [li l ma {}]\n(if (empty? li)\nma\n(recur (rest li) \n       (let [r (f (first li))]\n               (if (find ma r)\n                 (assoc ma r (conj (get ma r) (first li)))\n                 (assoc ma r [(first li)])))\n)\n)\n)\n)","user":"5951190be4b066ee0a44aea4"},{"code":"(fn [f coll]\r\n    (loop [input coll\r\n           output {}]\r\n      (if (empty? input)\r\n        output\r\n        (let [v (f (first input))]\r\n          (recur (rest input)\r\n                 (assoc output v (conj (output v []) (first input))))))))","problem":63,"user":"4fcbc18ae4b0ee37620e185c"},{"problem":63,"code":"(fn [f c]\n  (reduce\n   (fn [ret x]\n     (let [k (f x)]\n       (assoc ret k (conj (get ret k []) x))))\n   {} c))","user":"5405885ee4b0addc1aec6668"},{"code":"(fn [f coll]\n  (apply merge-with concat\n    (for [x coll] {(f x) [x]})))","problem":63,"user":"504c8165e4b09724c857af31"},{"code":"(fn group [f coll]\n  (into {}\n        (map #(vector (f (first %)) (vec %))\n             (partition-by f (sort coll)))))\n\n;first, the function sorts the collection and then applies f to every element, while splitting the elements up based on what answer they give. Then,\n;the function makes into a vector the answer of f applied to the element and a vector of the element, and it maps this pattern to everythign in the list.\n;Then, it's made into a hash-map, and any double keys are eliminated, combining the values of those keys.","problem":63,"user":"53713ebee4b0fc7073fd6ead"},{"problem":63,"code":"(fn [x y]\n  (apply merge-with into (for [a y] {(x a) [a]})))","user":"59e55cc8e4b08badc2a0c555"},{"problem":63,"code":"(fn [f c]\n    (let [r (map #(vector (f %) %) c)\n          ks (into #{} (map first r))]\n      (into {} (for [k ks] (vector k (vec (map last (filter #(= k (first %)) r))))))))","user":"4e837808535db62dc21a62d9"},{"problem":63,"code":"(fn [f col]\n  (let [results (map f col)\n        my-keys (distinct results)\n        pairs   (map vector col results)]\n    (apply hash-map (apply concat (for [my-key my-keys]\n      [my-key (into [] (map first (filter #(= my-key (last %)) pairs)))])))))","user":"56877fcbe4b0dcc4269f405e"},{"code":"(fn [f coll]\n   (let [rs (distinct (map f coll))]\n     (loop [ret {} r rs]\n       (if (empty? r)\n         ret\n         (recur (assoc ret (first r) (filter #(= (first r) (f %)) coll))\n                (rest r))))))","problem":63,"user":"51cacda3e4b068dadb8f2227"},{"problem":63,"code":"(fn [f vals] \n    (reduce (fn [items [k v]] (assoc items k (conj (get items k []) v))) {}\n    (map #(vector (f %) %) vals)))","user":"58d27bcae4b03c36ff7e58fe"},{"code":"(fn group-by*\n  [fcat coll]\n  (let [assoc* (fn [coll x] (let [fx (fcat x)]\n                              (assoc coll fx\n                                (if\n                                  (contains? coll fx)\n                                  (conj (get coll fx) x)\n                                  [x]))))]\n    (reduce assoc* {} coll)))","problem":63,"user":"4edfb618535d10e5ff6f5343"},{"problem":63,"code":"(fn test [f s]\n  (loop [[head & tail] s\n         result {}]\n    (if (nil? head)\n      result\n      (let [key (f head)]\n        (if (contains? result key)\n          (recur tail (assoc result key (conj (get result key) head)))\n          (recur tail (conj result {key [head]}))\n          )\n        )\n    )\n  )\n )","user":"54021f13e4b0df28a13c62cc"},{"problem":63,"code":"#(loop [r {}, v %2]\n    (if (empty? v)\n      r\n      (recur (if (contains? r (%1 (first v)))\n              (update-in r [(%1 (first v))] conj (first v))\n              (conj r (vector (%1 (first v)) (vector (first v)))))\n       (subvec v 1))))","user":"55810c73e4b05c286339e0f2"},{"problem":63,"code":"(fn [f s]\n  (letfn [(updatemap [m k v] \n                     (if (contains? m k)\n                       (assoc m k (vec (concat (m k) (vector v))))                       \n                       (assoc m k (vector v))))\n          ]\n    (reduce #(updatemap %1 (f %2) %2) {} s)))","user":"53c1ce3ee4b00fb29b221268"},{"code":"(fn [op coll] \n  (reduce (fn [h v]\n    (let [k (op v)]\n      (assoc h k (conj (or (h k) []) v)))) {} coll))","problem":63,"user":"516abecae4b081287f204e9f"},{"code":"(fn [k s] \n  (reduce (fn [r i] \n    (assoc r (k i) (conj (or (r (k i)) []) i)))\n  {} \n  s)\n)","problem":63,"user":"502940a9e4b061fd216be4b8"},{"problem":63,"code":"(fn [f s]\n  (reduce #(let [k (f %2)\n                 v (%1 k [])]\n             (println (str \"k \" k \"  v \" v))\n             (assoc %1 k (conj v %2)))\n          {} s))","user":"4f244f26e4b0d66497709fea"},{"code":"(fn [f x]\n  (apply merge-with concat (for [y x] {(f y) [y]})))","problem":63,"user":"5012aefce4b0c8732600222a"},{"code":"(fn [x y] (reduce #(assoc % (x %2) (conj (get % (x %2) []) %2)) {} y))","problem":63,"user":"52016690e4b0b2e020a18f0f"},{"problem":63,"code":"(fn [f xs]\n    (reduce\n     (fn [m x] (update-in m (list (f x)) #((fnil conj []) % x)))\n     {}\n     xs))","user":"5df70ee8e4b0a607a9a45c8a"},{"code":"(fn\n\t[f coll]\n\t(reduce #(assoc %1 (f %2) (conj (get %1 (f %2) []) %2)) {}\n\t\t   coll))","problem":63,"user":"5142ea50e4b0c172af7558ca"},{"code":"(fn [f s]\n  (reduce \n    (fn [m x]\n      (let [k (f x)]\n        (assoc m k (conj (m k []) x))))\n    {} s))","problem":63,"user":"5007f751e4b0b17c647f522b"},{"code":"(fn [f c]\n  (reduce #(assoc %1 (f %2) (conj (into [] (%1 (f %2))) %2)) {} c))","problem":63,"user":"5213d81de4b0961f15ac4d73"},{"problem":63,"code":"(fn grp-by [func vals]\n  (\n    into {}\n    (\n        map\n         #(vector (func (first %)) (vec %))\n         (partition-by func (sort vals))\n    )\n  )\n)","user":"54c8eb61e4b045293a27f658"},{"problem":63,"code":"(fn group-by-fun\n  [func coll]\n  (reduce\n     (fn [m k] \n       (if (contains? m (func k))\n         (assoc m (func k) (conj (get m (func k)) k))\n         (assoc m (func k) [k]) ))\n  {} coll))\n\n;; or using the recursive version::\n#_(fn group-by-fun\n  [func coll]\n  (letfn [(add-to-map\n             [m k v]\n           (if (contains? m k)\n              (assoc m k (conj (get m k) v))\n              (assoc m k [v])))]\n  (loop [acc {}\n        [head & tail] coll]\n    (if (nil? head)\n      acc\n      (recur (add-to-map acc (func head) head) tail)))))","user":"5553b729e4b0deb715856e05"},{"problem":63,"code":"(fn gb [f xs]\n   (reduce\n    (fn [coll x]\n      (let [v (f x)]\n        (assoc coll v (conj (get coll v []) x))))\n    {} xs))","user":"5d4b2155e4b0776584bd6f28"},{"problem":63,"code":"(fn [f s]\n  (reduce (fn [result item]\n            (let [k (f item)\n                  l (get result k [])]\n              (assoc result k (conj l item))))\n          {}\n          s))","user":"5463c824e4b01be26fd746c5"},{"code":"(fn my-group-by [f s]\n  (loop [m {}\n         s s]\n    (if (empty? s) m\n      (let [item (first s)\n            ret (f item)]\n      (recur (assoc m ret (conj (get m ret []) item)) (rest s)\n             )\n        )\n      )\n    )\n  )","problem":63,"user":"5119f3d5e4b06c8af0111818"},{"problem":63,"code":"(fn gb [f coll]\n  (reduce (fn [acc item]\n            (merge-with (fn [r l]\n                          (concat r l)) acc {(f item) [item]}))\n          {} coll))","user":"5d64ecb2e4b0c9e5857d5036"},{"problem":63,"code":"(fn solve [f s]\n  (reduce\n   (fn [new-map current]\n     (let [applied (f current)\n           old-value (get new-map applied [])]\n       (assoc new-map applied (conj old-value current))))\n   {}\n   s))","user":"59be62d5e4b0a024fb6ae435"},{"problem":63,"code":"(fn [f arr]\n  (let [ke (into #{} (map f arr))]\n    (into {}\n          (for [k ke\n                :let [y (filter (fn [itm] (= (f itm) k)) arr)]] [k y]))))","user":"5ad99ddee4b0ea6055cfac3a"},{"code":"(fn [f s]\n  (reduce\n    (fn [m e]\n      (let [k (f e)]\n        (assoc m k\n          (conj (get m k []) e))))\n;         (if (contains? m k) (conj (m k) e) [e]))))\n    {}\n    s))","problem":63,"user":"4fd22e70e4b04c3a95aa041c"},{"problem":63,"code":"#(reduce (fn [ret x]\n           (let [k (%1 x)]\n             (assoc ret k (conj (get ret k []) x)))) {} %2)","user":"5566463ee4b0c656e3ff1831"},{"code":"(fn [f s] (reduce #(assoc %1 (f %2) (vec (concat (%1 (f %2)) [%2] ))) {} s))","problem":63,"user":"52dc2bc8e4b09f7907dd13ca"},{"code":"(fn [pre coll]\n  (loop [result {} c coll]\n     (if (nil? c) result\n       (let [w (first c) k (pre w) v (result k [])] \n         (recur (conj result {k (conj v w)}) (next c) ))\n     )))","problem":63,"user":"522eba30e4b01cdb292c5f0e"},{"code":"(fn [f seq] \n  (reduce\n    (fn [acc e] (let [v (f e)]\n      (if (contains? acc v) \n          (conj acc [v (conj (acc v) e)])\n          (conj acc [v [e]]))))\n    {} seq))","problem":63,"user":"4f13047d535d64f60314642c"},{"problem":63,"code":"(fn group-sequence [fun coll]\n  (letfn [(add-to-map [map x]\n            (let [key (fun x)\n                  value-coll (into [] (get map key))]\n              (assoc map key (conj value-coll x))))]\n    (reduce add-to-map {} coll)))","user":"53fd66a4e4b0de5c418485e3"},{"code":"(fn  [f l] (reduce \n  (fn [m e] (assoc m (f e) \n      (if-let [kvec (get m (f e))] \n           (conj kvec e) [e]))) {} l))","problem":63,"user":"4e6e3a1e535d5021c1a89602"},{"problem":63,"code":"(fn [f s] (into {} (loop [key (distinct (map (fn [i] (f i)) s)) r []]\n                       (if (empty? key) r\n                                        (recur (rest key) (conj r [(first key) (vec (filter (fn [x] (= (f x) (first key))) s))])))\n\n                       )))","user":"592bb806e4b072a2710fcf46"},{"code":"(fn [f s]\n  (reduce \n    (fn [ret x]\n      (let [k (f x)]\n        (assoc ret k (conj (get ret k []) x))))\n    {} s))","problem":63,"user":"4e8ad1d2535d65386fec2110"},{"problem":63,"code":"(fn [f coll]\n  (reduce\n   (fn [result n]\n     (let [v (f n)\n           l (get result v [])]\n       (assoc result v (conj l n))))\n   {}\n   coll))","user":"5cb41c40e4b026601754b911"},{"problem":63,"code":"(fn [f s] (reduce #(let [t (f %2)] (assoc %1 t (conj (get %1 t []) %2))) {} s))","user":"4f070ce6535dcb61093f6c1e"},{"problem":63,"code":"(fn [f s]\n    (reduce (fn [acc x]\n              (assoc-in acc [(f x)] (conj (get acc (f x) []) x)))\n            {}\n            s))","user":"54508859e4b0e397800069a3"},{"problem":63,"code":"(fn [f xs]\n      (apply merge-with concat\n             (map (fn [x] {(f x) [x]}) xs))\n      )","user":"5c17467fe4b01240ff5671df"},{"problem":63,"code":"(fn func\n  [f coll]\n  (into {} (map\n             #(hash-map (f (first %)) %)\n             (partition-by f (sort coll)))))","user":"5d1c14cde4b02ea6f0fb698a"},{"problem":63,"code":"(fn blah [argfun argseq]\n  (reduce #(merge-with concat %1 {(argfun %2) [%2]}) {} argseq))","user":"535f9a5ce4b04ce2eb3ed2de"},{"code":"(fn [f coll]\r\n  (loop [f f\r\n         coll coll\r\n         z {}]\r\n    (if (empty? coll)\r\n      z\r\n      (recur f (rest coll) (if (contains? z (f (first coll)))\r\n                             (assoc z (f (first coll)) (conj (z (f (first coll))) (first coll)))\r\n                             (conj z {(f (first coll)) (vector (first coll))}))\r\n             ))))","problem":63,"user":"504e2333e4b0f6ff3350c46c"},{"problem":63,"code":"(fn [f s] (reduce (fn [m e] (update-in m [(f e)] (fnil conj []) e)) {} s))","user":"4db3a0e5535df7e46ed9b6d0"},{"code":"(fn [f in]\n  (loop [in in out {}]\n    (println out)\n    (if (empty? in)\n     out\n     (recur (rest in)\n            (merge-with concat out (hash-map (f (first in)) [(first in)] ))))))","problem":63,"user":"4faec810e4b081705acca24e"},{"problem":63,"code":"(fn [f coll]\n   (reduce \n     (fn [arr elem]\n       (let [key (f elem)\n             value-list (get arr key [])\n             _ (println \"elem:\" elem \"key:\" key)\n             _2 (println \"arr:\" arr)\n             _ (println \"val\" value-list)]\n         (assoc arr key (conj value-list elem))))\n     {}\n     coll))","user":"58ed2e21e4b056aecfd47d7a"},{"problem":63,"code":"(fn [f col]\n  (loop [m {} rem col]\n    (if (empty? rem)\n      m\n      (let [k (apply f [(first rem)])\n            v (vec (get-in m [k]))]\n        (recur (assoc-in m [k] (conj v (first rem))) (rest rem))))))","user":"5614ebc5e4b05f002753dfbc"},{"code":"(fn [fun sq]\n(reduce (fn [h [k v]]\n  (assoc h k (conj (h k []) v)))\n        {} \n        (for [s sq\n          :let [f (fun s)]]\n          (list f s))))","problem":63,"user":"4db6ce85535d1e037afb217f"},{"problem":63,"code":"(fn [f coll]\n  (reduce\n    (fn [acc e]\n      (let [\n        res (f e)\n        current (acc res '())]\n        (assoc acc res (concat current (list e)))))\n    {}\n    coll))","user":"540d5085e4b0addc1aec670e"},{"code":"(fn [f s]\n  (->> s (map #(hash-map (f %) [%]) )\n       (apply merge-with concat)\n  ))","problem":63,"user":"4e50e2a0535dc968683fc4ef"},{"problem":63,"code":"(fn [f s]\n  (loop [mp {}, s s]\n    (if (empty? s)\n      mp\n      (let [elt (first s)\n            kk  (f elt)\n            vv  (conj (get mp kk []) elt)]\n        (recur (assoc mp kk vv)\n               (rest s))))))","user":"50b42cbbe4b001349b2f4abe"},{"problem":63,"code":"(fn [f s] (reduce #(assoc %1 (f %2) (concat (%1 (f %2)) [%2])) {} s))","user":"54074fc5e4b0addc1aec66b6"},{"problem":63,"code":"; Look at the power of Clojure. This is pretty strong Kung Fu\n#(apply merge-with into (for [v %2] {(% v) [v]}))\n\n\n; Close -- I made the program pretty complex...\n\n;(fn [fn coll]\n;   (let [results (map fn coll)\n;         midlist (sort-by first (partition 2 (interleave results coll)))]\n;     (loop [c1 []\n;           m midlist]\n;       (if (empty? m)\n;         (apply hash-map c1)\n;         (recur (if (= (first (first m)) (first (second m)))\n;                       (conj c1 (first (first m)) (conj [] (second (first m)) (second (second m))))\n;                       (conj c1 (take 2 m)))\n;                (drop 2 m))))))","user":"5633bb9de4b0bfe05bf117b4"},{"problem":63,"code":"(fn[f s](apply assoc {} (mapcat\n                      (fn[itm][itm\n                    \n                                (vec(reverse(keys(filter\n                                           (fn[e](= (second e) itm))\n                                           (zipmap s (map f s))))))\n                               ])\n                      (distinct(vals(zipmap s (map f s))))\n    ) ))","user":"56039843e4b04bb52996e1be"},{"problem":63,"code":"(fn [func v]\n  (into {}\n    (map #(vector (func (first %)) %)\n    (partition-by func (sort v)))))","user":"574c5e18e4b02ea11479921b"},{"code":"(fn [f v] (apply hash-map (seq (mapcat #(concat [(f (first %))] [%]) (partition-by f (sort-by f v))))))","problem":63,"user":"4fa67030e4b081705acca1b7"},{"problem":63,"code":"(fn [f l]\n   (reduce (fn [result i]\n             (let [key (f i)\n                   value (get result key)]\n               (if (not (nil? value))\n                 (assoc result key (conj value i))\n                 (assoc result key [i]))))\n           {} l)\n   )","user":"54bbba99e4b0ed20f4ff6ec2"},{"code":"(fn my-group [f s]\n        (reduce #(assoc %1 (f %2) (into (vec (%1 (f %2))) [%2] )) {} s))","problem":63,"user":"4e0d5a5a535d04ed9115e7b5"},{"problem":63,"code":"(fn f\n  [g lst]\n  (loop [lst1 lst\n         lst2 ()]\n    (if (empty? lst1)\n      (apply hash-map lst2)\n      (recur (remove #(= (g (first lst1)) (g %)) lst1) (concat\n                                                               (cons (g (first lst1)) (list (filter #(= (g (first lst1)) (g %)) lst1)))\n                                                               lst2)))))","user":"59e778aae4b0249b72820716"},{"problem":63,"code":"(fn [f xs]\n    (reduce (fn [acc x]\n              (assoc acc (f x) (conj (get acc (f x) []) x)))\n            {}\n            xs))","user":"560e9a2de4b05f002753df52"},{"problem":63,"code":"(fn groupb \n  [f xs]\n  (loop [xs xs\n         m {}]\n         (let [x (first xs)]\n    (if (nil? x)\n     m\n    (recur (rest xs) (update-in m [(f x)] #(conj (if (nil? %) [] %) x)))))))","user":"563f0fdae4b08d4f616f5ece"},{"problem":63,"code":"(fn [f coll]\n  (reduce (fn [m e]\n            (let [v (f e)]\n              (assoc m v (if (contains? m v) (conj (get m v) e) [e]))))\n          {}\n          coll))","user":"57f80350e4b0d3187e90090c"},{"problem":63,"code":"(fn [f xs]\n  (reduce (fn [m v]\n            (let [k (f v)]\n               (assoc m k (conj (into [] (get m k)) v))))\n           {}\n           xs))","user":"54b13a40e4b09f271ff37d1b"},{"code":"(fn [f s] (reduce #(merge-with concat %1 {(f %2) [%2]}) {} s))","problem":63,"user":"4fe2501ae4b0dd6cd5ce3644"},{"code":"(fn [f coll]\n   (persistent!\n    (reduce\n     (fn [ret x]\n       (let [v (f x)]\n         (assoc! ret v (conj (get ret v []) x))))\n     (transient {}) coll)))","problem":63,"user":"506c0a02e4b0eda3100c090d"},{"code":"(fn [pred coll]\n    (reduce\n     (fn [c v]\n       (let [k (pred v)]\n         (assoc c k (conj (get c k []) v))))\n     {} coll))","problem":63,"user":"4f3ec266e4b0e243712b1f8c"},{"problem":63,"code":"(fn [f coll]\r\n  (reduce (fn [a b]\r\n            (merge-with #(conj %1 (first %2)) a b))\r\n          (map (comp (partial apply hash-map)\r\n                     (juxt f vector))\r\n               coll)))","user":"55d0e76ae4b0e31453f64a40"},{"code":"(fn list-group [fun my-list]\n   (loop [my-list my-list acc {}]\n     (if (empty? my-list)\n       acc\n       (let [x (first my-list)\n             fx (fun x)]\n         (recur (rest my-list) (assoc acc fx (conj (get acc fx []) x)))))))","problem":63,"user":"4ede0511535d10e5ff6f5330"},{"code":"(fn [f col]\n  (reduce #(update-in %1 [(f %2)] (comp vec conj) %2)\n          {}\n          col))","problem":63,"user":"501d34f6e4b066e56b9d0b1e"},{"code":"#(reduce\r\n  (fn [m [k v]]\r\n    (assoc m k (conj (m k []) v)))\r\n  {} (map (fn [v] [(%1 v) v]) %2))","problem":63,"user":"4ded27db535d08e6dec9fe0a"},{"code":"(fn group-by-result [f coll]\n  (let [answers (map #(vector (f %) %) coll)]\n    (reduce (fn [a b]\n              (assoc a (first b) (conj (a (first b)) (second b))))\n            {}\n            (reverse answers))))","problem":63,"user":"4e3bccb1535deb9a81d77f55"},{"code":"(fn x [y z] (reduce (fn [r s] (let [add #((fnil conj []) % %2)]\n                                (update-in r [(y s)] add s))) {} z))","problem":63,"user":"51fa7154e4b0f1313d4689da"},{"problem":63,"code":"(fn [f l]\n  (reduce #(let [fx (f %2)]\n             (assoc %1 fx (conj (or (get %1 fx) [])\n                                %2)))\n          {} l))","user":"54be7772e4b0ed20f4ff6eea"},{"problem":63,"code":"#(loop [f %1, col %2, acc {}] \n      (if (empty? col) acc\n        (let [firstElement (first col)\n              firstElementVal (f firstElement)\n              filterFun (fn [x] (= firstElementVal (f x)))\n              groupByCol (filter filterFun col)\n              restCol (remove filterFun col)]\n          (recur f restCol (conj acc [firstElementVal groupByCol])))))","user":"53c38b8ce4b00fb29b22127b"},{"problem":63,"code":"(fn g [f s] (reduce (fn [a e] (update-in a [(f e)] (fnil #(conj % e) []))) {} s))","user":"590b055ae4b047aa04b199c9"},{"code":"(fn stuff [f values] \n  (reduce \n   (fn [memo, value]\n     (merge memo {(f value) (concat (get memo (f value) []) [value])})\n       ) {} values))","problem":63,"user":"4f03641a535dcb61093f6a9b"},{"code":"(fn [f c]\n    (reduce \n      (fn [state v]\n        (let [result (f v)]\n          (update-in state [result] #(vec (conj % v)))))\n      {}\n      c))","problem":63,"user":"4e52777f535d302ef430da76"},{"code":"(fn [f s]\r\n  (let [v (distinct (map f s))]\r\n    (apply assoc {} \r\n      (apply concat\r\n        (for [x v] [x (filter #(= (f %) x) s)])))))","problem":63,"user":"4f58d92fe4b0a7574ea71858"},{"code":"#(reduce\n    (fn [m x] (let [k (% x)] (assoc m k (conj (get m k []) x))))  \n    {} %2)","problem":63,"user":"4ec7c32c535d6d7199dd36e6"},{"problem":63,"code":"(fn [func coll]\n  (into {}\n   (map #(vector (func (first %)) (vec %)) \n        (partition-by func (sort coll)))))","user":"568f2059e4b0dcc4269f40df"},{"problem":63,"code":"(fn group [f s]\n  (reduce \n   (fn [g a]\n     (assoc g (f a) (conj (get g (f a) []) a)))\n   {} \n   s))","user":"5b857411e4b047b03b2037ce"},{"code":"(fn haha [a b] (apply (partial merge-with concat) \n                      (map (fn [x] (hash-map (a x) [x])) b)))","problem":63,"user":"52b35a6ee4b0c58976d9ad07"},{"problem":63,"code":"(fn [f xs]\n  (apply merge-with concat\n    (for [x xs ]\n        {(f x) [x]})))","user":"5632d1b3e4b0bfe05bf117a9"},{"problem":63,"code":"(fn\n   [f coll]\n  (loop [result {}\n         s coll]\n    \n    (let [next-element (first s)]\n      \n      (if next-element\n\n        (let [val (f next-element)\n              existing-elements (get result val)]\n          \n          (recur (conj result\n                       [val (conj (vec existing-elements)\n                                  next-element)])\n                 (rest s)))\n\n        result))))","user":"59971dcbe4b07157cc8daacb"},{"code":"(fn [f v]\n  (reduce\n    #(assoc % (f %2) (conj (if (% (f %2)) (% (f %2)) []) %2))\n    {} v))","problem":63,"user":"505d4b21e4b0e6aca564be07"},{"problem":63,"code":"(fn [f xs] \n  (reduce #(update-in %1 [(f %2)] (fnil conj []) %2)\n          {}\n          xs))","user":"5649b1b0e4b0284900eef646"},{"problem":63,"code":"(fn group\n  [f s]\n  (into {} (map #(vector (f (first %)) %) (partition-by f (sort s))))\n  )","user":"5bbbcf9ee4b0a20761a23614"},{"problem":63,"code":"(fn ddd [fun lst]\n(apply merge (map (fn[x] {(fun (first x)) x}) (partition-by fun (sort-by fun lst)))))","user":"55f01316e4b06e875b46ce1a"},{"problem":63,"code":"(fn [f coll] (apply merge-with concat (map hash-map (map f coll) (map vector coll))))","user":"52950ab6e4b02ebb4ef7501a"},{"problem":63,"code":"(fn \n  [a b]\n  (into {}\n        (map #(vector (a (first %)) (vec %))\n             (partition-by a (sort b)))) \n  )","user":"57f81532e4b0d3187e900914"},{"problem":63,"code":"(fn [f s]\n  (reduce (fn [r v]\n    (assoc r (f v) (conj (get r (f v) [] ) v )))  \n    {}\n    s\n  )\n)","user":"56f2611fe4b04a395b9a04a2"},{"code":"#(reduce\n     (fn [r x]\n\t     (let [k (% x)]\n\t       (assoc r k (conj (r k []) x))))\n\t   {} %2)","problem":63,"user":"4e57d1e2535d8a8b8723a289"},{"problem":63,"code":"#(reduce (fn [acc item]\n           (let [ key (% item)]\n             (if\n                (contains? acc key) (update-in acc [key] conj item)\n                   (assoc acc key [item])))\n             \n           ) {} %2)","user":"5dc12b0ae4b0e59a23173d84"},{"problem":63,"code":"(fn [f data]\n  (reduce (fn [x,y] \n    (let [v (f y)]\n      (assoc x v (conj (get x v []) y)))) \n    {} data))","user":"5933b736e4b072a2710fd05d"},{"problem":63,"code":"(fn my-group [f xs]\n    (reduce (fn [m x] (into m {(f x) (concat (m (f x)) [x])})) {} xs))","user":"59da6480e4b0ef0a1e9b5c68"},{"code":"(fn group-by' [f xs]\n  (apply (partial merge-with concat) (map #(hash-map (f %) [%]) xs)))","problem":63,"user":"528a2de7e4b0239c8a67ae71"},{"code":"(fn [f xs]\r\n  (loop [xs xs m {}]\r\n    (if (empty? xs) m\r\n      (let [fx (f (first xs))]\r\n        (recur\r\n          (filter #(not (= fx (f %))) xs)\r\n          (assoc m fx (filter #(= fx (f %)) xs)))))))","problem":63,"user":"5063b9a0e4b075d771da6f9d"},{"code":"(fn [f coll]\n  (reduce \n    (fn [m v] \n      (let [k (f v)\n     \t\tacc (if (contains? m k) (conj (get m k) v) [v])] \n        (assoc m k acc))) {} coll))","problem":63,"user":"51cdd3f0e4b0e42293a2254b"},{"problem":63,"code":"(fn [f xs] \n  (apply merge-with concat \n         (map #(into {} [[(f %) [%]]]) xs)))","user":"53f5666ee4b0db01ade6f9cf"},{"code":"(fn [f, x] (reduce (fn [m v] (conj m {(f v), (conj (get m (f v)) v)})) (zipmap (map f x) (repeat [])) x))","problem":63,"user":"51f66e0ee4b06ff1c25c52c3"},{"code":"#(apply merge-with concat (for [x%2] {(% x) [x]}))","problem":63,"user":"4e7115b3535d5021c1a89647"},{"problem":63,"code":"#(reduce (fn [m item]\n            (let [key (%1 item)]\n              (if (contains? m key)\n                (assoc m key (conj (get m key) item))\n                (conj m {key [item]}))))\n          {}\n          %2)","user":"5c6d0e51e4b0fca0c1622735"},{"problem":63,"code":"( fn [f s]\n   (reduce (fn [m x] (if (contains? m (f x)) (assoc m (f x) (conj (m (f x)) x))(assoc m (f x) [x])))  {} s )\n)","user":"5649615be4b0284900eef641"},{"problem":63,"code":"(fn [fun vals]\n  (reduce\n   #(update-in %1 [(fun %2)]\n               (fnil (fn [l] (conj l %2)) []))\n   {} vals))","user":"4daeff24edd6309eace4d16e"},{"code":"(fn sber [f s]\n  \n      (apply merge-with concat (map #(hash-map (f %1) (list %1)) s)) )","problem":63,"user":"522048b3e4b0e6c71e0c0c16"},{"problem":63,"code":"(fn [f coll] (reduce #(let [val (f %2)] (assoc % val (conj (get % val []) %2))) {} coll))","user":"57283dbce4b0c5bde472c154"},{"problem":63,"code":"(fn [f xs]\n  (reduce (fn [m v] (let [k (f v)] (assoc m k (conj (get m k []) v)))) {} xs))","user":"5821b018e4b04b46fc4b0f80"},{"problem":63,"code":"(fn [f lst]\n  (apply merge-with concat (for [x lst] {(f x) [x]})))\n\n;Merge-with: Combines 2 elements into 1.\n;Reference: https://clojuredocs.org/clojure.core/merge-with","user":"5a99b87ee4b0d174b936c7af"},{"problem":63,"code":"(fn [f xs] \n  (reduce \n   (fn [agg x] \n     (assoc agg (f x) (conj (get agg (f x) []) x)))\n   \n   {} xs))","user":"552d9b31e4b076ab5578f7eb"},{"problem":63,"code":"(fn my-group-by\n  [f s]\n  (reduce \n    (fn \n      [x y]\n      (let [k (f y) v (get x k)] \n        (assoc x k (if (nil? v) [y] (into v [y]))))) {} s))","user":"54091b82e4b0addc1aec66d5"},{"problem":63,"code":"#(reduce (fn [a v] (merge-with into a {(%1 v) [v]})) {} %2)","user":"4e8a460e535d65386fec2109"},{"code":"#(reduce (fn [m v]\n           (let [k (% v)]\n             (assoc m k\n               (conj (or (m k) []) v)))) {} %2)","problem":63,"user":"512700c4e4b083bb8f88cf14"},{"code":"(fn [f s]\n  (reduce #(assoc % (f %2) (conj (get % (f %2) []) %2)) {} s))","problem":63,"user":"4e39d763535deb9a81d77f46"},{"code":"(fn [p xs]\n  (loop [mi {} x xs]\n    (if (empty? x)\n     mi\n     (let [y (get mi (p (first x)))]\n      (recur (assoc mi (p (first x)) (vec (conj y (first x)))) \n             (rest x))))))","problem":63,"user":"4e5d2dc5535d8a8b8723a2ca"},{"problem":63,"code":"(fn grby [f s]\n(reduce \n\t(fn [m v] (update-in m [(f v)]  \n\t\t#(if (= nil %) [v] (conj % v))))\n\t{}\n\ts))\n\n\n;;;;;;;;;;;;;;;;;;;;;;; first draft\n;(fn grby [f s]\n;(reduce \n;\t(fn acc-map [ m [k v] ] ;; (acc-map {a: [a b]} {a: x} ) produces {a: [a b x] }\n;\t\t(into m {k\n;\t\t\t(if (get m k) \n;\t\t\t\t(conj (get m k) v) ;; append\n;\t\t\t \t[v] ;; other()wise new list \n;\t\t\t) } ) ) \n;\n;{}\n;(for [i s] [(f i) i] )\n;))","user":"533a2f7be4b0e30313ee6cb8"},{"problem":63,"code":"(fn [f l]\n   (apply merge-with \n    concat \n    (map (fn [e] {(f e) [e]}) l)\n    )\n   )","user":"55e8a85be4b0121d4835fd98"},{"problem":63,"code":"(fn [f xs]\n    (->> xs\n         (map #(vector (f %) %))\n         (sort-by first)\n         (partition-by first)\n         (map #(hash-map ((comp first first) %) (mapv second %)))\n         (apply merge)))","user":"5920c191e4b09b4ee5954c61"},{"problem":63,"code":"(fn a63[f coll]\n  (let[data (map (fn[x][(f x) x]) coll)]\n    (loop [grouped {}\n           groups (rest data)\n           [k v] (first data)]\n      (println v)\n      (if (empty? groups)\n        (into grouped (apply hash-map [k (into [] (concat (grouped k) [v]))]))\n        (recur (into grouped (apply hash-map [k (into [] (concat (grouped k) [v]))]))\n               (rest groups)\n               (first groups))))))","user":"56163cc1e4b06b1bb21829ff"},{"problem":63,"code":"(fn [p s]\n    (reduce (fn [acc e]\n              (let [k (p e)]\n                (assoc acc k (conj (acc k []) e))))\n            {}\n            s))","user":"4e617114535d8ccf87e9fe5b"},{"problem":63,"code":"#(reduce (fn [acc i] \n           (assoc acc (first i) \n             (conj (if (empty? (acc (first i))) \n                     []\n                     (acc (first i))) \n                   (last i)))) \n         {}\n         (for [x %2]\n           [(% x) x]))","user":"5fb3a096e4b08cb800c85b35"},{"problem":63,"code":"(fn [func coll] (apply merge-with concat (map (fn [x] {(func x) [x]}) coll)))","user":"55fe7e15e4b00f4cabc57651"},{"code":"(fn [f s]\n    (loop [xs s\n           r {}]\n      (if (empty? xs)\n        r\n        (let [k (first xs)\n              v (f k)]\n          (recur (rest xs)\n                 (conj r {v (conj (get r v []) k)}))))))","problem":63,"user":"4fe8aef4e4b07c9f6fd12c6c"},{"code":"(fn [f all]\n  (reduce\n    (fn [acc x]\n      (let [k (f x)\n            prev (get acc k [])]\n       (assoc acc k (conj prev x))))\n   {} all))","problem":63,"user":"4fe8a3bde4b07c9f6fd12c61"},{"code":"(fn [f c]\n  (reduce #(update-in % [(f %2)] (comp vec into) [%2]) {} c))","problem":63,"user":"514d8084e4b019235f6c0588"},{"code":"(fn [f v] (reduce #(if (% (first %2))\n                     (assoc % (first %2) (concat (% (first %2)) (rest %2)))\n                     (assoc % (first %2) (vec (rest %2)))) {}\n                     (map (fn [x] [(f x) x]) v)))","problem":63,"user":"5125029de4b0ce9225d2ed3e"},{"problem":63,"code":"(fn grp [f ss]\n  (loop\n    [acc {}\n     ss ss]\n    (if (empty? ss)\n      acc\n      (let [h (first ss) result (f h)]\n       (recur\n        (update-in acc [result] (fnil conj []) h)\n       \t(rest ss)\n       )\n      )\n    )\n  )\n)","user":"54c9f165e4b045293a27f687"},{"problem":63,"code":"(fn map-applied-ip [f s]\n   (loop [[first-el & rest-of] s, m {}] \n     (if (nil? first-el) \n       m\n       (recur rest-of \n              (assoc m (f first-el) \n                     (vec (conj (get m (f first-el)) first-el))) \n              ))\n     )\n   )","user":"53a26cede4b0f1fc7453882a"},{"code":"(fn [f xs]\n  (loop [ys xs\n         m {}]\n    (if (seq ys)\n      (let [y (first ys)\n            v (f y)]\n        (recur (rest ys)\n               (update-in m [v] (fn [zs] (if (coll? zs) (conj zs y) [y])))))\n      m)))","problem":63,"user":"511442d0e4b0e9c109bb74d5"},{"code":"(fn gb2 [f vals]\n  (reduce #(merge-with into %1 {(f %2) [%2]}) {} vals))","problem":63,"user":"4f0d093b535d0136e6c22313"},{"problem":63,"code":"(fn [f s] \n  (let [gather (fn [res x] \n                 (let [fx (f x) xs (res fx)]\n                 (assoc res fx (concat xs [x]))))]\n    (reduce gather {} s)))","user":"564127a9e4b08d4f616f5ef3"},{"code":"(fn [f v]\n  (loop [v v\n         result {}]\n    (if (empty? v)\n      result\n      (let [k (f (first v))]\n        (if (get result k)\n          (recur (rest v) (update-in result [k] conj (first v)))\n          (recur (rest v) (assoc result k (vector (first v)))))))))","problem":63,"user":"538d464ee4b0b51d73faae69"},{"problem":63,"code":"(fn [f s] (reduce #(if (get %1 (f %2)) (into %1 {(f %2) (conj (get %1 (f %2)) %2)}) (into %1 {(f %2) [%2]})) {} s))","user":"53a1b5c8e4b0ca733b9744c1"},{"code":"(fn [f coll]\n   (let [v (partition-by f (sort-by f coll))]\n      (zipmap (map f (map first v)) v)))","problem":63,"user":"4fb99483e4b081705acca2da"},{"code":"#(reduce (fn [c x] (merge-with into c {(% x) [x]})) {} %2)","problem":63,"user":"50548ce8e4b0b1b9d1860ead"},{"problem":63,"code":"#(reduce (fn [m v]\n           (assoc m (% v) (conj (get m (% v) []) v))) {} %2)","user":"5ccc2a03e4b0ccb06196288f"},{"problem":63,"code":"(fn [f coll]\n    (reduce\n      (fn [acc curr]\n        (update-in acc [(f curr)] (fnil #(vec (distinct (conj % curr))) [curr])))\n      {}\n      coll))","user":"5e17bb46e4b00200644e3d5a"},{"code":"(fn [f coll]\n\n(reduce  \n  (fn [d e] \n    (merge-with (partial reduce conj) d {(f e) [e]})\n  )\n  {}\n  coll\n))","problem":63,"user":"4f03154a535dcb61093f6a58"},{"problem":63,"code":"(fn [f s] (reduce #(update-in %1 [(f %2)] (fn [a1] (apply vector (conj a1 %2))) ) {} s))","user":"5b919d9de4b0c0b3ffbd4a24"},{"problem":63,"code":"(fn [f coll]\n   (let [z (partition-by f (sort coll))]\n     (into {} (map\n                #(vector (f (first %)) %) z))\n\n     ))","user":"57fc5e42e4b0d3187e900997"},{"problem":63,"code":"(fn [f coll]\n  (loop [res {}\n         coll coll]\n    (let [v (first coll)]\n      (if-not v\n        res\n        (recur (assoc res (f v) (conj (get res (f v) []) v)) (rest coll))))))","user":"51441ce7e4b0b4fb4ace5f41"},{"code":"(fn grp-by [f coll]\n  (reduce \n    (fn [acc v] \n      (let [x (f v)]\n      (assoc acc x (conj (get acc x []) v))))\n    {} coll))","problem":63,"user":"4f1c2a3a535d64f603146480"},{"problem":63,"code":"(fn [f c]\n  (apply merge-with into (for [x (partition-by f c)]\n    {(f (first x)) (into [] x)})))","user":"566d71b1e4b0a866af6896ca"},{"problem":63,"code":"(fn [f s] (apply merge-with concat (map (comp (partial apply hash-map) (juxt f vector)) s)))\n;using partition-by:\n#_(fn [f s]\n  (->> (mapv (juxt f identity) s)\n       (sort-by first)\n       (partition-by first)\n       (map #(vector (first (first %)) (mapv second %)))\n       (into {})))","user":"55cdc576e4b0e31453f64a1f"},{"code":"(fn [f s]\n  (reduce (fn [m x]\n            (let [k (f x)]\n              (assoc m k (conj (get m k []) x))))\n          {} s))","problem":63,"user":"4e6a412e535d8ccf87e9feb6"},{"code":"(fn [f in-seq]\n  (loop [s in-seq,\n         res {}]\n    (if (empty? s) res\n    \t(let [k (f (first s))\n    \t      v (conj (or (res k) []) (first s))]\n    \t  (recur (rest s) (assoc res k v))))))","problem":63,"user":"4ed152d5535d44c135fd68cc"},{"problem":63,"code":"(fn [f s]\n  (reduce (fn [agg e]\n            (let [val (f e)\n                  cur (get agg val [])]\n              (assoc agg val (conj cur e))))\n          {}\n          s))","user":"5b9357b7e4b0c0b3ffbd4a46"},{"problem":63,"code":"(fn re-gby [f xs]\n  (into {}\n        (map #(vector (f (first %)) %)\n             (partition-by f (sort xs)))))","user":"593910eae4b02506e01a29f4"},{"code":"(fn my-group-by [f coll]\n  (loop [map {} s (seq coll)]\n    (if s\n      (let [v (first s) k (f v)]\n        (recur (assoc map k (conj (get map k []) v)) (next s)))\n      map)))","problem":63,"user":"4e39fb68535deb9a81d77f47"},{"code":"(fn groupseq [f col]\n  (reduce\n    (fn [out x]\n      (assoc out (f x) (conj (out (f x) []) x)))\n    {}\n    col))","problem":63,"user":"52dad8bde4b09f7907dd13be"},{"problem":63,"code":"(fn [f arr]\n    (reduce \n        (fn [hm y] (assoc hm (f y) (conj (hm (f y)) y)))\n        (zipmap (map f arr) (repeat []))\n        arr))","user":"56327168e4b0bfe05bf117a5"},{"code":"(fn [f coll]\n  (loop [x coll answer (hash-map)]\n    (if (empty? x) answer\n      (recur (rest x)\n        (if (contains? answer (f (first x)))\n          (assoc answer\n            (f (first x))\n            (conj\n             (get answer (f (first x)))\n             (first x)\n            )\n          )\n          (assoc answer\n            (f (first x))\n            [(first x)]\n          )\n        )\n      )\n    )\n  )\n)","problem":63,"user":"50bfbf25e4b05ae8c1cbbd9b"},{"problem":63,"code":"(fn [f x] (reduce (fn [r e] (assoc r (f e) (apply vector (conj (r (f e)) e)))) {} x))","user":"5801eed1e4b0a837a8b30c63"},{"problem":63,"code":"(fn [f coll]\n  (reduce #(assoc %1 (f %2)\n                  (if (not (get %1 (f %2))) [%2] (conj (get %1 (f %2)) %2))) {} coll))","user":"543823f1e4b032a45b869311"},{"problem":63,"code":"(fn\n  [f vals]\n  (loop [res {}\n         vals vals]\n    (if (empty? vals)\n      res\n      (let [evaluated (f (first vals))]\n        (if (contains? res evaluated)\n          (let [current (conj (get res evaluated) (first vals))\n                new-dict (dissoc res evaluated)]\n            (recur\n              (assoc new-dict evaluated current)\n              (rest vals)))\n          (recur\n            (assoc res evaluated (vector (first vals)))\n            (rest vals)))))))","user":"5c706232e4b0fca0c162277e"},{"problem":63,"code":"(fn [f coll] (reduce #(assoc %1 (f %2) (vec (conj (get %1 (f %2)) %2)) ) {} coll))","user":"5fe362d9e4b05ac5b16ea179"},{"code":"(fn [f s]\n  (reduce (partial merge-with into) (map (fn [v] (apply hash-map v)) \n     (partition 2 \n                (interleave \n                 (map f s)\n                 (map vector s))))))","problem":63,"user":"4e9ff8d0535d7eef3080729c"},{"problem":63,"code":"(fn [f xs]\n  (->> \n   \txs\n   \t(map #(vector (f %) %))\n    (sort-by first)\n    (partition-by first)\n    (map #(vector (ffirst %) (mapv second %)))\n   \t(into {})))","user":"543f854fe4b032a45b86935b"},{"problem":63,"code":"(fn [f s]\n  (reduce #(assoc %1 (f %2) (if (get %1 (f %2))\n                              (vec (conj (get %1 (f %2)) %2))\n                              (vector %2))) {} s))","user":"580a0783e4b0a837a8b30d2c"},{"problem":63,"code":"(fn [f s]\n  (reduce (fn [agg x] \n            (assoc agg (f x) (conj (get agg (f x) []) x)))\n          {} s))","user":"5e9c11f8e4b0157ca96647f6"},{"problem":63,"code":"#(reduce\n  (fn [h x]\n    (let [k (%1 x)]\n      (assoc h k (conj (get h k []) x))))\n  {}\n  %2)","user":"549e5e52e4b0f3d1d8e70f9e"},{"problem":63,"code":"(fn [f c]\n   (loop [m {} c c]\n     (if (empty? c)\n       m\n       (recur (merge-with concat m {(f (first c)) [(first c)]}) (rest c)))))","user":"5d764e52e4b02e6b30c93524"},{"problem":63,"code":"(fn [func coll]\n  (reduce\n     #(let [res (func %2)\n            acc (%1 res [])]\n        (assoc %1 res (conj acc %2)))\n   {} coll))","user":"5f665d45e4b02876ed9fd02f"},{"code":"(fn [f s]\n  (loop [f f s s acc {}]\n    (if (empty? s)\n      acc\n      (let [k (f (first s))]\n        (if (contains? acc k)\n          (recur f (rest s) (assoc acc k (conj (acc k) (first s))))\n          (recur f (rest s) (assoc acc k [(first s)])))))))","problem":63,"user":"52b8af15e4b07a9af57922b5"},{"problem":63,"code":"(fn g \n  [f x] \n  (if (empty? x) \n    {} \n    (merge-with concat {(f (first x)) [(first x)]} (g f (rest x))) ))","user":"56bca51ae4b0f26550335963"},{"code":"(fn my-group-by [f s]\n  (reduce\n    #(let [k (f %2)]\n       (assoc %1 k (conj (vec (%1 k)) %2)))\n    {}\n    s))","problem":63,"user":"526ee63de4b03e8d9a4a733f"},{"problem":63,"code":"(fn grouping [f s]\n  (apply merge-with concat (map (fn[e] {(f e) [e]}) s)))","user":"5ed6030de4b016b56eae05db"},{"problem":63,"code":"(fn [f coll]\n  (loop [xs coll result {}]\n    (if (empty? xs)\n      result\n      (recur (rest xs) (assoc result\n                              (f (first xs))\n                              (conj (if-let [res (get result (f (first xs)))] res [])\n                                    (first xs)))))))","user":"57147cd9e4b07c98581c3abf"},{"problem":63,"code":"(fn\n  [f s]\n  (reduce\n   (fn\n     [map1 value]\n     (assoc\n       map1\n       (f value)\n       (conj (vec (get map1 (f value))) value)))\n     {}\n     s))","user":"51b01309e4b0c53cf2e68a57"},{"problem":63,"code":"(fn [f coll]\n  (reduce (fn [acc v]\n            (let [key (f v)\n                  value (get acc key)]\n              (assoc acc key (if (nil? value)\n                               [v]\n                               (conj value v))))) {} coll))","user":"57e10705e4b0bfb2137f5a6a"},{"problem":63,"code":"(fn groupby [f l] (    \n                     reduce        \n                     #(let [fval (f %2) hval (%1 fval)]           \n                        \t(if hval            \n                              (assoc %1 fval (conj hval %2))             \n                              (assoc %1 fval (vector\n                                                   %2)) ) ) {} l))","user":"56a75810e4b0542e1f8d14fc"},{"problem":63,"code":"(fn group [f coll]\n  (let [split (partition-by f coll)\n        hits (map #(identity (f (first %))) split)\n        merged (map #(hash-map %1 (into [] %2)) hits split)]\n    (apply merge-with into merged)))","user":"542c026ae4b0dad94371f29a"},{"code":"(fn gb [func iseq]                                                                                                                               \n    (loop [sequence iseq                                                                                                                           \n           builder {}]                                                                                                                             \n      (if (empty? sequence)                                                                                                                        \n        builder                                                                                                                                    \n        (let [fval (func (first sequence))]                                                                                                        \n          (if (contains? builder fval)                                                                                                             \n            (recur (rest sequence)                                                                                                                 \n                   (assoc builder fval (conj (get builder fval) (first sequence))))                                                                \n            (recur (rest sequence)                                                                                                                 \n                   (assoc builder fval (conj [] (first sequence)))))))))","problem":63,"user":"50057f23e4b0678c553fc466"},{"code":"(fn [f s]\n  (reduce #(update-in %1 [(f %2)] (fn [elt] (conj elt %2))) \n          {} (reverse s)))","problem":63,"user":"5097ea89e4b087ccf61a7af4"},{"code":"(fn [f xs]\n  (reduce (fn [h v]\n            (let [k (f v)]\n              (assoc h k (conj (get h k []) v))))\n          {}\n          xs))","problem":63,"user":"50ec4ed7e4b04edc33777046"},{"problem":63,"code":"(fn [op lst]\n  (reduce #(let [k (op %2)\n                 v (if (contains? %1 k) (conj (%1 k) %2) [%2])]\n            (assoc %1 k v)) {} lst))","user":"591f05b4e4b09b4ee5954c42"},{"problem":63,"code":"(fn grp-seq [f lst]\n  (into {}\n        (map #(vector (f (first % )) (vec %))\n             (partition-by f (sort lst)))))","user":"5e978fe5e4b0157ca96647d1"},{"problem":63,"code":"(fn [f coll] (reduce (fn [res itm]\n                       (let [k (f itm)\n                             v (get res k (vector))]\n                         (assoc res k (conj v itm))))\n                     {} coll))","user":"51b8d3d5e4b050a1176cd69d"},{"problem":63,"code":"(fn [func-to-apply, items]\n    (reduce (fn [hsh item]\n              (let [result (func-to-apply item)]\n                (merge-with concat hsh (assoc {} result (vector item)))\n                )) {} items)\n    )","user":"536829c8e4b0243289761e8b"},{"code":"#(apply merge-with concat (for [i %2] {(%1 i) [i]}))","problem":63,"user":"5107b86de4b05b2b4eee7495"},{"code":"(fn solution [f s]\n  (apply merge-with concat (map #(identity {(f %) [%]}) s))\n)","problem":63,"user":"52b49aebe4b0c58976d9ad2b"},{"problem":63,"code":"#(reduce (fn [a v]\n           (assoc a (%1 v) (conj (get a (%1 v) []) v)))\n         {}\n         %2)","user":"5458c74de4b01be26fd74623"},{"code":"#(reduce (fn [xs x] (let [y (%1 x)] (assoc xs y (conj (xs y []) x)))) {} %2)","problem":63,"user":"4f4f0287e4b03ad3f0c10cd7"},{"problem":63,"code":"(fn my-group-by [f xs]\n  (loop [xs xs\n         nxs {}]\n    (if (empty? xs)\n      nxs\n      (recur (rest xs)\n        (assoc nxs (f (first xs))\n          (conj\n            (get nxs (f (first xs)) [])\n            (first xs)))))))","user":"5f4eb036e4b0102c75033969"},{"code":"(fn [f x] (reduce #(let [k (f %2)] (assoc %1 k (conj (%1 k []) %2))) {} x))","problem":63,"user":"528e64b7e4b0239c8a67aedd"},{"code":"(fn gr \n  ([f l] (gr {} f l))\n  ([m f l]\n    (if \n      (empty? l) m\n      (gr\n        (let [v (first l)\n              k (f v)\n              g (get m k [])\n          ]\n          (assoc m k (conj g v)))\n        f\n        (rest l)\n        )))\n)","problem":63,"user":"4e6e10d8535d5021c1a895fd"},{"problem":63,"code":"(fn [f s]\n  (reduce #(update-in %1 [(f %2)] (comp vec conj) %2) {} s))","user":"53213810e4b09d4e7a9b54b0"},{"code":"(fn my-group-by [f s]\n  (let [keys (set (map f s))]\n    (apply hash-map\n           (interleave keys\n                       (for [k keys]\n                         (vec (filter #(= k (f %)) s)))))))","problem":63,"user":"51baff1be4b0fe3ecfb46443"},{"code":"(fn [o y] (reduce #(assoc %1 (o %2) (concat (get %1 (o %2) []) [%2])) {} y))","problem":63,"user":"5017f840e4b02f523d7cc5e8"},{"code":"(fn [x y] (reduce #(if (contains? %1 (x %2))\n                    (assoc %1 (x %2) (conj (%1 (x %2)) %2)) \n                    (assoc %1 (x %2) (vector %2))) {} y))","problem":63,"user":"5105ed16e4b01150e115ebe2"},{"problem":63,"code":"(fn [f s] \n  (reduce \n   #(update-in %1 [(f %2)] (fnil conj []) %2) \n   {} \n   s))","user":"5ba75fdfe4b0a20761a23419"},{"problem":63,"code":"(fn [pred s]\n  (apply merge-with\n         concat\n         (map #(hash-map (pred %) [%])\n              s)))","user":"568e1871e4b0dcc4269f40cc"},{"code":"(fn my-group-by [f coll]\n  (reduce\n   (fn [acc v]\n     (merge-with concat acc {(f v) [v]}))\n   {}\n   coll))","problem":63,"user":"507b7dbee4b09034bfeeb71e"},{"problem":63,"code":"(fn [f coll]\n    (let [keys (set (map f\n                         coll))]\n      (zipmap keys\n              (map (fn values [key]\n                     (filter (fn [x]\n                               (= (f x)\n                                  key))\n                             coll))\n                   keys))))","user":"5be5cebde4b0ed4b8aab4d19"},{"problem":63,"code":"(fn [func xs] (->> xs\n                   (map func)\n                   (set)\n                   (map #(->> xs\n                              (filter (fn [v] (= % (func v))))\n                              (vec)\n                              (hash-map %)))\n                   (apply merge)))","user":"588906a9e4b0f1effa3b772a"},{"code":"(fn [f coll]\n  (loop [coll coll\n         acc {}]\n    (if (empty? coll)\n        acc\n        (let [e (first coll)\n              k (f e)\n              ov (get acc k)\n              nv (if (nil? ov) [e] (conj ov e))]\n          (recur (rest coll) (assoc acc k nv))))))","problem":63,"user":"4f9120d8e4b0dcca54ed6c96"},{"problem":63,"code":"(fn [f t] (reduce #(update-in % [(f %2)] (fn [v] (if (empty? v) [ %2 ] (conj v %2)))) {} t))","user":"59c734e3e4b0a024fb6ae53f"},{"problem":63,"code":"(fn grp [f coll]\n   (reduce #(merge-with concat %1 %2) (map #(hash-map (f %) (vector %)) coll))\n   )","user":"535eaa73e4b04ce2eb3ed2d4"},{"problem":63,"code":"(fn sk-group-by [fun list]\n  (into {} (map\n     (fn [sorted]\n       (vector (fun (first sorted))\n               sorted))\n     (partition-by fun (sort list)))))","user":"5884f377e4b0f1effa3b76a8"},{"code":"(fn [f s]\n  (loop\n    [r s\n     tr {}]\n    (if (= nil (first r))\n      tr\n      (recur\n       (rest r)\n       (assoc\n         tr\n         (f (first r))\n         (if (= nil (get tr (f (first r))))\n           [(first r)]\n           (conj (get tr (f (first r))) (first r))))))))","problem":63,"user":"530d85dee4b08068f379eca8"},{"problem":63,"code":"(fn [f coll]\n  (let [reduce-fn #(let [k (f %2)] (assoc % k (conj (% k []) %2)))]\n    (reduce reduce-fn {} coll)))","user":"582e0afde4b051871117bfd5"},{"code":"(fn my-group [f coll]\n  (reduce (fn [ret x]\n            (let [k (f x)]\n              (assoc ret k (conj (get ret k []) x))))\n          {} coll))","problem":63,"user":"52a55adee4b0c58976d9abe7"},{"problem":63,"code":"(fn [pred values]\n  (reduce \n    (fn [accum [key value]]\n  \t\t\t(assoc accum key\n              (conj (get accum key []) value)))\n \t\t{}\n    (map\n      #(vector (pred %) %)\n      values)))","user":"5974d2ede4b01722bebd4cb6"},{"code":"(fn [f s]\r\n  (letfn [(f2 [m v]\r\n            (let [r (f v)\r\n                  c (get m r [])]\r\n              (assoc m r (conj c v))))]\r\n    (reduce f2 {} s)))","problem":63,"user":"4ddbdc1b535d02782fcbe9fd"},{"problem":63,"code":"(fn [f x]  (zipmap (distinct (map f x)) (partition-by f (sort-by identity x))))","user":"58a0fd0be4b02bd94d917ea4"},{"problem":63,"code":"(fn [given-function given-vector]\n  (reduce\n    (fn [result-map value]\n      (let [key (given-function value)\n            value-vector (get result-map key)]\n        (if (nil? value-vector)\n          (assoc result-map key (vector value))\n          (assoc result-map key (conj value-vector value))\n          )\n        )\n      )\n    {}\n    given-vector\n    )\n  )","user":"566639f4e4b0e91d5f5c566b"},{"problem":63,"code":"#(reduce (fn [m x]\n            (assoc m (%1 x) (conj (m (%1 x) []) x)))\n          {} %2)","user":"5eb193fde4b00a66d4a951fe"},{"problem":63,"code":"(fn i [f a] \n  (reduce \n    (fn [m x]\n      (let [k (nth x 0)\n            v (nth x 1)] \n          (assoc m k (conj (or (m k) []) v))))\n    {} \n    (map #(vector (f %) %) a)))","user":"5a14228fe4b0ff51aa4b3193"},{"code":"(fn gr [f s]\n  (reduce (fn [c e]\n\t\t\t(let [k (f e) v (get c k)]\n\t\t\t  (if (nil? v)\n\t\t\t\t(assoc c k (vector e))\n\t\t\t\t(assoc c k (conj v e)))))\n\t\t  {}\n\t\t  s))","problem":63,"user":"5101192ae4b0bef64c30e266"},{"problem":63,"code":"(fn my-group-by [f coll]\n\t(reduce (fn [my-map v] (assoc my-map (f v) (conj (get my-map (f v) []) v))) {} coll))","user":"57c0917be4b05aa3c4741c95"},{"code":"(fn [f col] (reduce\r\n   (fn [l r] (update-in l [(f r)] #(vec (conj % r))))\r\n       {}\r\n        col))","problem":63,"user":"4e0e0529535d04ed9115e7b9"},{"code":"(fn [f coll]\n  (reduce #(let [k (f %2)\n                 v (conj (get % k []) %2)]\n             (assoc % k v)) {} coll))","problem":63,"user":"52479487e4b05ef8e38e6373"},{"problem":63,"code":"(fn [f s] \n\t(let [z (map f s) y (zipmap z (repeat []))] \n\t\t(reduce (fn [a b] (assoc a (first b) (conj (get a (first b)) (last b))))\n\t\t\ty (partition 2 (interleave z s)))))","user":"5578f292e4b05c286339e08f"},{"code":"(fn [f xs]\n  (loop [xs xs m {}]\n    (if xs\n      (let [val (first xs)\n            key (f val)]\n        (recur (next xs)\n               (if-let [vals (m key)]\n                 (assoc m key (conj vals val))\n                 (assoc m key (vector val)))))\n       m)))","problem":63,"user":"4e593dac535d8a8b8723a29c"},{"code":"(fn [f c]\r\n    (reduce\r\n      #(assoc % (f %2) (conj (or (% (f %2)) []) %2))\r\n      {} c))","problem":63,"user":"4f410b63e4b0e243712b1fc5"},{"code":"(fn\n  [f coll]\n  (reduce #(assoc %1 (f %2) (conj (%1 (f %2) []) %2)) {} coll))","problem":63,"user":"4dad7adac9a9d6ed0599dc57"},{"problem":63,"code":"(fn [f coll]\n  (apply merge-with into (map #(hash-map (f %) (vector %)) coll)))","user":"5b2c79c6e4b025bcb146f2b7"},{"problem":63,"code":"(fn [f s]\n  (reduce\n   (fn [m e]\n     (let [v (f e)]\n       (into m {v (conj (get m v []) e)})))\n   {}\n   s))","user":"4e3ac1b2535deb9a81d77f4c"},{"code":"(fn [f ss] (reduce (fn [m v] (update-in m [(f v)] (fnil conj []) v)) {} ss))","problem":63,"user":"4f3ca5a6e4b0e243712b1f53"},{"problem":63,"code":"(fn gb [f xs]\n  (reduce (fn [m x]\n            (let [fx (f x)]\n              (assoc m fx (conj (m fx []) x)))) \n          {} xs))","user":"5cdfe2aee4b0a17bb84e2b04"},{"problem":63,"code":"(fn [fun seqq]\n  (apply merge-with\n         concat\n         (for [el seqq]\n    \t\t{(fun el) [el]})))","user":"55912230e4b027778923767a"},{"code":"(fn [f s]\n  (let [f-results (map (partial (fn [g x] \n                                  (list (g x) x)) f) s)\n        f-keys (distinct (map first f-results))\n        f-hash (reduce into (map hash-map f-keys (repeat [])))]\n    (println f-results)\n    (loop [r-pairs f-results\n           r-hash f-hash]\n      (if (= 0 (count r-pairs))\n        r-hash\n        (let [r-key (first (first r-pairs))\n              r-val (second (first r-pairs))]\n          (recur (rest r-pairs) (assoc r-hash r-key \n                                  (conj (get r-hash r-key) r-val))))))))","problem":63,"user":"5361a4f2e4b0243289761e47"},{"problem":63,"code":"(fn [f c] (reduce #(update-in %1 [(f %2)] (fnil (fn [k] (conj k %2)) [])) {} c))","user":"564c8e99e4b0284900eef674"},{"problem":63,"code":"(fn [f coll]\n  (letfn [(sb1 [f res val]\n                (let [k (f val)\n                      c (get res k)\n                      n (if (nil? c)\n                          [val] \n                          (conj c val))]\n                  (assoc res k n)))]\n  (reduce #(sb1 f %1 %2) {} coll)))","user":"54f14aa6e4b024c67c0cf8af"},{"problem":63,"code":"(fn [f s]\n  (reduce (fn [m x]\n            (let [k (f x), v (m k)]\n              (assoc m k (if (nil? v) [x] (conj v x))))) {} s))","user":"5ab5f60be4b073f177442643"},{"code":"(fn group-sequence [function coll]\n  (reduce (fn  [l e]\n            (if (l (function e))\n              (assoc l (function e) (conj (l (function e)) e))\n              (assoc l (function e) (vector e))))\n          {}\n          coll))","problem":63,"user":"4e4bd94b535dc968683fc4d7"},{"code":"(fn [f coll]\n   (reduce\n    (fn [r x] (merge-with concat r {(f x) [x]}))\n    {}\n    coll))","problem":63,"user":"52090567e4b0e152394d76ed"},{"code":"(fn ass\r\n  ([f s] (ass (map f s) s {}))\r\n  ([ks vl res] (let[k (first ks), v (first vl), nks (next ks), nv1 (next vl), asval (res k), \r\n                    res (assoc res k (conj (if (nil? asval) [] asval) v))]\r\n                (if nks  (recur nks nv1 res) res \r\n                ))))","problem":63,"user":"4e44358f535dc968683fc4a8"},{"code":"#(apply \n  (partial merge-with concat {})\n  (map (fn [x] {(% x) [x]}) %2))","problem":63,"user":"503917a0e4b088a6a14ca763"},{"problem":63,"code":"(fn\n      [f coll]\n      (reduce\n        (fn [c v]\n            (let [r (f v)\n                  i (get c r)]\n              (if i\n                  (assoc c r (conj i v))\n                  (assoc c r [v]))))\n        {}\n        coll))","user":"55b6a63ae4b01b9910ae299b"},{"problem":63,"code":"(fn [f coll] (apply merge-with concat (for [x coll] {(f x), [x]})))","user":"553fa883e4b0a04f792994f9"},{"problem":63,"code":"(fn [f xs]\n   (reduce\n    (fn [h x]\n      (assoc h (f x) (conj (h (f x) []) x)))\n    {} xs))","user":"500d3160e4b05f7c30cfa6a1"},{"problem":63,"code":"(fn [f s]\n  (reduce (fn [m v]\n            (update-in m [(f v)]\n                       #(conj (or % []) v)))\n          {} s))","user":"565f8fd2e4b068f2fe63dc41"},{"problem":63,"code":"(fn [f xs]\n  (reduce\n    (fn [ret x]\n      (let [k (f x)]\n        (assoc ret k (conj (get ret k []) x))))\n    {}\n    xs))","user":"5e7dc2d8e4b085ba37836e2f"},{"code":"(fn [f m]\r\n   (let [pairs (partition 2 (interleave m (map f m)))]\r\n     (reduce\r\n      (fn [ressq inel] (assoc ressq (second inel) (conj (or (ressq (second inel)) []) (first inel))))\r\n  {} pairs)))","problem":63,"user":"4e8768f6535dceadca469850"},{"code":";;#(reduce (fn [m el]\n;;           (let [lookup (%1 el)\n;;                 existing (get m lookup [])\n;;                 updated (conj existing el)]\n;;             (assoc m lookup updated)))\n;;         {}\n;;         %2)\n\n#(reduce (fn [m el]\n           (update-in m [(%1 el)] (fnil conj []) el))\n         {}\n         %2)","problem":63,"user":"51f9527fe4b09be9c177e549"},{"problem":63,"code":"(fn [f coll] (reduce #(assoc %1 (f %2) (conj (get %1 (f %2) []) %2)) {} coll))","user":"53b71b94e4b047364c0444cd"},{"problem":63,"code":"(fn\n  [pred coll]\n  (reduce (fn [results c]\n            (let [k (pred c)]\n              (assoc results k (conj (get results k []) c))))\n          {} coll))","user":"4ed90014535d10e5ff6f52fe"},{"code":"(fn [f s]\n  (reduce\n  #(let [k (f %2)] (assoc % k (conj (% k []) %2)))\n  {}\n  s))","problem":63,"user":"4f06dcad535dcb61093f6c16"},{"problem":63,"code":"(fn gb [f s]\n  (reduce (fn [m v] \n            (let [k (f v)\n                  vs (get m k)]\n              (assoc m k (if (nil? vs) [v] (conj vs v))))) {} s))","user":"4fd4bddce4b0d4de60cee36e"},{"code":"#(apply merge-with into (for [e %2] {(% e) [e]}))","problem":63,"user":"4db091b7838c48654951d9c2"},{"problem":63,"code":"(fn [f s]\n  (loop [xs s m {}]\n    (if (seq xs)\n      (let [[x & xs2] xs\n             k (f x)\n             v (get m k [])]\n        (recur xs2 (assoc m k (conj v x))))\n      m)))","user":"5bc833a5e4b07a9b28b100bb"},{"problem":63,"code":"(fn gby [f x]\n  (reduce #(assoc % (first %2) (if (nil? (% (first %2)))\n                                         (vector (second %2))\n                                         (conj (% (first %2)) (second %2)))) {}\n             (map (fn [y] (conj (vector (f y)) y)) x)))","user":"53e9a15be4b036ad0777e4ae"},{"problem":63,"code":"#(\n  (fn [hm f s]\n    (if (empty? s)\n      hm\n      (let [x (first s)\n            k (f x)\n            v (get hm k)\n            coll (if (nil? v) [] v)\n           ]\n        (recur (assoc hm k (conj coll x)) f (rest s))\n      )\n    )\n  ) {} %1 %2\n)","user":"545537c1e4b0e397800069dd"},{"problem":63,"code":"#_(fn my-group-by [f s]\n  (reduce (fn [result item]\n            (update result (f item) #(conj % item)))\n          {}\n          s))\n; java.lang.RuntimeException: Unable to resolve symbol: update in this context, compiling:(NO_SOURCE_PATH:0)\n\n#_(fn my-group-by [f s]\n  (reduce (fn [result item]\n            (assoc result (f item) (conj (get result (f item) []) item)))\n          {}\n          s))\n\n(fn my-group-by [f s]\n  (reduce (fn [result item]\n            (update-in result [(f item)] #(conj (or % []) item)))\n          {}\n          s))","user":"5d6f063de4b04d129b00f2d1"},{"problem":63,"code":"(fn [f c]\n    (reduce #(assoc %1 (f %2) (conj (vec (get %1 (f %2))) %2)) {} c))","user":"564348e1e4b08d4f616f5f26"},{"code":"(fn [f c] (reduce #(merge-with concat % %2)\r\n {} (map (fn [x] (hash-map (f x) [x])) c)))","problem":63,"user":"4fca2ef0e4b0ee37620e184e"},{"problem":63,"code":"(fn p [f col]\n  (let [result (if (empty? col) {} (p f (rest col)))\n        value (if (empty? col) 0 (f (first col)))\nq (fn  [v itm m]\n  (assoc m v (vec (cons itm (get m v)))))\n        ]\n    (if (empty? col)\n      result\n      (q value (first col) result))))","user":"53664e3be4b0243289761e74"},{"problem":63,"code":"#(apply merge-with into (for [v %2] {(%1 v) [v]}))\n;;%1 func -> %2 coll","user":"553478dce4b09218d5f44f9d"},{"problem":63,"code":"(fn [op liste]\n     (apply (partial merge-with concat) (map #(sorted-map (op %) (vector %)) liste ))\n  )","user":"556f2009e4b09a3098a52519"},{"code":"(fn [f coll] (reduce \n  #(assoc % (f %2) (conj (apply vector (% (f %2))) %2))\n  {} coll))","problem":63,"user":"4ffb38e8e4b0678c553fc3c6"},{"problem":63,"code":"(fn [f s] (reduce (partial merge-with concat) (map #(hash-map (f %) (vector %)) s)))","user":"550609b3e4b021ccfedb9695"},{"problem":63,"code":"(fn [f c]\n  (reduce (fn [r i]\n            (merge-with concat r {(f i) [i]}))\n          {} c))","user":"50385746e4b0803468ea2c6d"},{"problem":63,"code":"(fn [f coll]\n  (reduce (fn [m [k v]]\n            (conj m [k (conj (get m k []) v)]))\n          {} (map #(vector (f %) %) coll)))","user":"543c5200e4b032a45b86933e"},{"code":"(fn [f s]\n  (zipmap (distinct (sort (map f s)))\n          (partition-by f (sort-by f s))))","problem":63,"user":"504e04a4e4b078edc5f59397"},{"problem":63,"code":"(fn my-groupby [f values]\n  (reduce \n   (fn [p n] \n     (assoc p (f n) (#(conj (get p (f n) []) n)))) {} values))","user":"55d29fb6e4b0e31453f64a59"},{"code":"#(reduce (partial merge-with concat) {} (map (fn [x] {(%1 x) [x]}) %2))","problem":63,"user":"50f9739ce4b0e7c80cb15a4d"},{"code":"(fn gb [f s]\n   (loop [s s\n          d {}]\n      (if (empty? s)\n          d\n        (let [h (first s)\n              r (f h)\n              v (d r)]\n           (if v\n               (recur (rest s) (assoc d r (conj v h)))\n              (recur (rest s) (assoc d r (vector h))))))))","problem":63,"user":"4fcc6cb3e4b0ee37620e1861"},{"problem":63,"code":"(fn [f s]\n   (->> (map #(hash-map (f %) [%]) s)\n        (apply merge-with concat)))","user":"5fef4292e4b05ac5b16ea1d7"},{"problem":63,"code":"(fn [f l] (apply merge-with concat (map #(hash-map (f %) [%]) l)))","user":"53f035c2e4b0742d9025b0d2"}]