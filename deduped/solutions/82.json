[{"problem":82,"code":"(fn [chainWords] (let [isNeighbour? (fn [str1 str2] \n                                       (let [ isInsDel? (fn [str1 str2]\n                                                          (loop [s1 (seq str1) s2 (seq str2)]                                                   (if (not= (first s1) (first s2))\n                                                                                                                                                  (= (rest s1) s2)\n                                                                                                                                                  (recur (rest s1) (rest s2)))))]\n                                         (case (- (count str1) (count str2))\n                                           1 (isInsDel? str1 str2)\n                                           0 (loop [s1 str1 s2 str2 nc 0]\n                                               (if (empty? s1)  (= nc 1)\n                                                   (recur (rest s1) (rest s2) (if (= (first s1) (first s2)) nc (inc nc)))))\n                                           -1 (isInsDel? str2 str1)\n                                           false))\n                                       )\n                        wordPairs (fn [wordMap] (apply concat ((fn [m] (loop [c m acc []] \n                                                                         (if (empty? c) acc\n                                                                             (recur (rest c) \n                                                                                    (conj acc (map #(vector (first c) %) m))\n                                                                                    )\n                                                                             )\n                                                                         )\n                                                                 ) wordMap)))\n                        graph (reduce (fn [m e] (update-in m [(first e)] (fnil conj []) (second e))) {} \n                                      (filter #(apply isNeighbour? %)  (wordPairs chainWords)))\n                        connected? (fn [m] (loop [toVisit (set (val (first m))) visited #{(ffirst m)}]\n                                             (if (empty? toVisit)\n                                               (= (count chainWords) (count visited))\n                                               (recur (reduce conj (rest toVisit) (filter #(not (contains? visited %))\n                                                                                          (m (first toVisit))))\n                                                      (conj visited (first toVisit))))\n                                             ))]\n                    (and (connected? graph) (< (count (filter #(empty? (rest (val %))) graph)) 3)) \n                    ; (count (filter #(empty? (rest (val %))) graph)) \n                    ; graph\n                    )\n                    \n   )","user":"5471f2fbe4b094393f72dd70"},{"code":"(fn [words]\n  (letfn [\n    (remove-one [t]\n      (map \n        #((fn [[f t]] (apply str (concat f (next t)))) (split-at % t))\n        (range (count t))))\n    (neib [s d]\n      (let [rs (remove-one s)\n            rd (remove-one d)]\n        (or (some #(= s %) rd)\n            (some #(= d %) rs)\n            (some identity (map #(= % %2) rd rs)))))\n    (paths [[prev :as path] rests]\n      (if (empty? rests)\n          [path]\n          (apply concat\n            (keep\n              #(if (or (nil? prev) (neib prev %))\n                   (paths (cons % path) (disj rests %)))\n              rests))))]\n  (boolean (some #(= % words) (map set (paths () words))))))","problem":82,"user":"4fd96694e4b05e33b9224f37"},{"code":"(fn [s]\n  (let\n    [diff-count (fn [w1 w2]\n      (count (filter false? (map = w1 w2))))\n\n     neighbors? (fn [w1 w2]\n      (let [w1-length (count w1)\n            w2-length (count w2)]\n        (if (> w1-length w2-length)\n          (not (nil? ((set (map #(str (.substring w1 0 %) (.substring w1 (inc %) w1-length)) (range w1-length))) w2)))\n          (if (= w1-length w2-length)\n            (= 1 (diff-count w1 w2))\n            (recur w2 w1)))))\n\n     neighbors-of (into {} (map #(vector % (set (filter (partial neighbors? %) s))) s))\n\n     ok? (fn ok?* [constructed remain]\n      (println \"constructed\" constructed)\n      (println \"remain\" remain)\n      (println \"---\")\n      (if (empty? remain)\n        true\n        (or\n          (some identity (map #(ok?* (vec (concat [%] constructed)) (disj remain %))\n            (clojure.set/difference (clojure.set/intersection (neighbors-of (first constructed)) remain) (set constructed))))\n          (some identity (map #(ok?* (conj constructed %) (disj remain %))\n            (clojure.set/difference (clojure.set/intersection (neighbors-of (last constructed)) remain) (set constructed)))))))]\n    (not (nil? (ok? [(first s)] (disj s (first s)))))))","problem":82,"user":"4f1e4ab5535d64f603146496"},{"code":"(fn [words]\n  (let [num-words (count words)]\n    (letfn [(first-difference [a b]\n              (first (drop-while nil? (map #(if (= %1 %2) nil %3) a b (range)))))\n            (remove-at [n coll]\n              (let [[lhs rhs] (split-at n coll)]\n                (concat lhs (rest rhs))))\n            (related [a b]\n              (let [a (vec a)\n                    b (vec b)\n                    ca (count a)\n                    cb (count b)\n                    count-differences (fn [a b] (apply + (map #(if (= %1 %2) 0 1) a b)))]\n                (if (= ca cb)\n                  (= 1 (count-differences a b))\n                  (if-let [i (first-difference a b)]\n                    (let [[longer shorter] (if (> ca cb) [a b] [b a])]\n                      (= (remove-at i longer) shorter))\n                    (= 1 (- (max ca cb) (min ca cb)))))))]\n      (let [related-words (apply conj {}\n                                 (for [word words]\n                                   [word (set (filter #(related word %)\n                                                      (disj words word)))]))\n            invalid (fn [chain] (and (> (count chain) 1)\n                                     ((complement (related-words (second chain)))\n                                      (first chain))))]\n        (letfn [(find-chain [chain possibilities]\n                  (when (seq possibilities)\n                    (let [word (first possibilities)\n                          chain (conj chain word)\n                          seen (set chain)]\n                      (if (invalid chain)\n                        nil\n                        (do\n                          (if (= num-words (count chain))\n                            chain\n                            (if-let [chain (find-chain\n                                            chain\n                                            (set (filter (complement seen)\n                                                         (related-words word))))]\n                              chain\n                              (find-chain (pop chain) (disj possibilities word)))))))))]\n          ((complement nil?) (find-chain () words)))))))","problem":82,"user":"50d93c53e4b0fd36a4b89223"},{"problem":82,"code":"(fn myf [coll]\n  (letfn [(link? [s1 s2]\n            (if (= s1 s2) false\n              (let [[small big] (sort-by count [s1 s2])]\n                (loop [s (vec small), b (vec big)]\n                  (if (= (first s) (first b)) (recur (rest s) (rest b))\n                    (cond (= s (rest b)) true\n                          (= (rest s) (rest b)) true\n                          :else false))))))]\n  (loop [res [(first coll)], s (set (rest coll))]\n    (let [new-res (reduce #(cond (link? (first %1) %2) (vec (cons %2 %1))\n                                 (link? (last %1) %2) (conj %1 %2)\n                                 :else %1) \n                          res\n                          s)\n          new-s (clojure.set/difference s (set new-res))]\n      (cond (empty? new-s) true\n            (= new-res res) false\n            :else (recur new-res new-s))))))","user":"577c3da9e4b0c8d87281f6b9"},{"code":"(letfn [(add [x y] (some #(and (= (take % (seq x)) (take % (seq y)))\n                               (= (drop % (seq x)) (drop (inc %) (seq y))))\n                         (range (inc (count x)))))\n        (subst [x y] (some #(and (= (take % x) (take % y))\n                                 (= (drop (inc %) x) (drop (inc %) y)))\n                     (range (count x))))]\n  (fn search\n    ([x] (if (some #(search x %) x) true false))\n    ([x w] (or (empty? (disj x w))\n               (some #(and (or (add w %) (add % w) (subst w %))\n                           (search (disj x w) %))\n                     (disj x w))))))","problem":82,"user":"4ed94d69535d10e5ff6f5303"},{"problem":82,"code":"(fn [words]\n   (let [dist (fn dist [w u]\n                (cond (empty? w) (count u)\n                      (empty? u) (count w)\n                      :else (min (inc (dist (drop-last w) u))\n                                 (inc (dist w (drop-last u)))\n                                 (+ (dist (drop-last w) (drop-last u))\n                                    (if (= (last w) (last u)) 0 1)))))\n         adj (fn [w] (->> words (filter #(= 1 (dist w %)))))\n         lookup (->> words (mapcat (juxt identity adj)) (apply hash-map))\n         path? (fn path? [seen w]\n                 (cond (= (count (conj seen w)) (count words)) true\n                       (seen w) false\n                       :else (some true? (map #(path? (conj seen w) %) (lookup w)))))]\n     (not-every? nil? (map #(path? #{} %) words))))","user":"54055aa9e4b0addc1aec6665"},{"code":"(fn [word-set]\n  (letfn [(edit-dist [a b] \n            (cond \n              (not (or a b)) 0 \n              (not b) (count a) \n              (not a) (count b) \n              :else (let [ra (next a) rb (next b)] \n                      (if (= (first a) (first b)) \n                        (edit-dist ra rb) \n                        (+ 1 (min \n                               (edit-dist ra rb) \n                               (edit-dist ra b) \n                               (edit-dist a rb)))))))\n          (find-paths [graph start seen] \n            (if (seen start) \n              seen\n              (for [n (graph start)] \n                (find-paths graph n (conj seen start)))))] \n    (let [graph (into {} \n                      (for [s word-set] \n                        [s (filter #(= 1 (edit-dist s %)) word-set)]))]\n      (if (some (fn [w] \n                  (some #(= word-set %) \n                        (flatten (find-paths graph w #{})))) \n                word-set) \n        true false))))","problem":82,"user":"500d1db4e4b05f7c30cfa69f"},{"problem":82,"code":"(fn [x]\n   (letfn [(rv [z] (vec (re-seq #\"[a-z]\" z)))\n           (dropn [z n] (concat (subvec z 0 n) (subvec z (inc n))))\n           (del? [s ss]\n    \t\t\t(reduce #(or %1 (= s %2)) false\n     \t\t\t\t (for [n (range (count ss))] (dropn ss n))\n    \t\t\t)\n   \t\t   )\n           (sub? [s ss]\n           \t\t(reduce #(or %1 %2) false\n                 \t(for [n (range (min (count ss) (count s)))] (= (dropn s n) (dropn ss n)))\n                 )\n           )\n           (nxt? [s ss] (if (= false s) false (or (del? s ss) (del? ss s) (sub? s ss))))\n           (perm [coll]\n ( if (empty? coll) '([])\n  (apply concat (for [x coll] (map #(conj % x) (perm (disj coll x))))) \n )\n)\n           ]\n     (let [s (set (map rv x)) ss (perm s)]\n   (boolean (some #(not= false %) (map #(reduce (fn [x y] (if (nxt? x y) y false)) %) ss)))    \n     )\n  )\n)","user":"5be6d0f8e4b0f319e2d7ec51"},{"code":"(fn [ss]\n   (letfn [\n           (replace-substring [s r start len] (str (subs s 0 start) r (subs s (+ len start))))\n           (replacements [s] (map #(replace-substring s \".\" % 1) (range (count s)) ))\n           (insertions [s] (map #(replace-substring s \".\" % 0) (range (inc (count s))) )) \n           (deletions [s] (map #(replace-substring s \"\" % 1) (range (count s)) )) \n           (all [s] (mapcat #(% s) [replacements insertions deletions]))\n           (adjacencies [ss]\n             (into\n               {}\n               (for [s1 ss]\n                 (let [res (map re-pattern (all s1))\n                       matches (for [s2 ss\n                                     :when (not= s1 s2)\n                                     :when (some #(re-matches % s2) res)]\n                                 s2)]\n                   [s1 (into #{} matches)]))))\n\n           (chain? [adjs]\n             ((fn loop! [ss adjs]\n                (if\n                  (empty? ss) (empty? adjs)\n                  (some true?\n                        (for [s ss]\n                          (loop! (adjs s) (dissoc adjs s) ))))\n                )\n              (map first adjs)\n              adjs))]\n\n     (if (chain? (adjacencies ss)) true false)))","problem":82,"user":"52dc2bc8e4b09f7907dd13ca"},{"problem":82,"code":"(fn word-chains? [coll]\n  (letfn [(one-char-diff? [a b]\n                          (if (= (first a) (first b))\n                            (one-char-diff? (rest a) (rest b))\n                            (or (= (rest a) (rest b)) (= (sequence a) (rest b)) (= (rest a) (sequence b)))))\n          (make-graph [coll]\n             (reduce (fn [n-map word-a]\n                         (into n-map (reduce (fn [in-map word-b]\n                                               (if (and (not (= word-a word-b)) (one-char-diff? word-a word-b))\n                                                 (update-in in-map [word-a] conj word-b)\n                                                 in-map)) {word-a #{}} coll))) '{} coll))\n          (depth [graph]\n                 (letfn [(helper [cnt visited to-visit]\n                                 (if (empty? to-visit)\n                                   cnt\n                                   (apply max (map (partial helper (inc cnt)) (map #(conj visited %) to-visit) (map #(clojure.set/difference (get graph %) visited) to-visit)))))]\n                   (apply max (map #(helper 0 #{} [%]) coll))))]\n    (= (count coll) (depth (make-graph coll)))))","user":"5746061ae4b009280f9f2b5b"},{"problem":82,"code":"(letfn [(pluck [i coll]\n                 (into (subvec coll 0 i) (subvec coll (inc i))))\n          (sub? [str1 str2]\n                (and (= (count str1) (count str2)) (= 1 (count (filter not (map = str1 str2))))))\n          (ins? [str1 str2]\n                (some #(= (vec str1) (pluck % (vec str2))) (range (count str2))))\n          (link? [str1 str2]\n                 (or (sub? str1 str2) (ins? str1 str2) (ins? str2 str1)))\n          (chain? [word words]\n                  (if (empty? words)\n                    true\n                    (some #(and (link? word (nth words %)) (chain? (nth words %) (pluck % words))) (range (count words)))))]\n  (fn [words] (let [words (vec words)]\n                (not (nil? (some #(chain? (nth words %) (pluck % words)) (range (count words))))))))","user":"55ccdc6be4b0e31453f64a18"},{"problem":82,"code":"(fn [s0]\n          (let [\n                d1      (fn [s1 s2]  (apply + (map #(if (= %1 %2) 0 1) s1 s2)))\n                d2 (fn [s1 s2]\n                     (loop [ e 0 n 0]\n                       (if (or (>= n (count s1)) (>= e 2))  \n                         (if (zero? e) (- (count s2) n) e)\n                         (if (= (.charAt s1 n) (.charAt s2 (+ n e))) \n                           (recur e (inc n))\n                           (recur (inc e) (inc n))\n                           ))))\n                d3 (fn [s1 s2]\n                     (let [c1 (count s1)\n                           c2 (count s2)\n                           ]\n                       (cond (= c1 c2) (d1 s1 s2)\n                             (= (inc c1) c2) (d2 s1 s2)\n                             (= c1 (inc c2)) (d2 s2 s1)\n                             :else 9\n                             )))\n\t\t\t\td4 (memoize d3)                \n                permutation (fn p[xs]\n                              (if (= (count xs) 1)\n                                (list xs)\n                                (for [x xs\n                                      y (p (remove #(= x %) xs ))]\n                                  (cons x y))))\n                count-path (fn [l1]                  (second (reduce (fn [[s0 cc] m1] [m1 (+ cc (d4 s0 m1))])  [(first l1) 0] (rest l1))))\n                xlist  (permutation s0)\t\t\t\t\n                ]\n            (not (empty? (filter #(= % (dec (count s0))) (map #(count-path %) xlist))))\n            ) \n          )","user":"533c2605e4b0e30313ee6cd7"},{"problem":82,"code":"#(let [one-apart? (fn f [s1 s2]\n                    (let [c1 (count s1)\n                          c2 (count s2)]\n                      (case (- c1 c2)\n                        0 (= 1\n                             (reduce +\n                                     (map (fn [x y] (if (= x y) 0 1))\n                                          s1\n                                          s2)))\n                        1 (re-matches\n                           (re-pattern (str \".?\" (clojure.string/join \".?\" s2) \".?\"))\n                           s1)\n                        -1  (f s2 s1)\n                        false)))\n       has-ham-path? (fn [incidence-map]\n                       (let [passable? (fn f [vertex rem-vertices]\n                                         (or (empty? rem-vertices)\n                                             (if-let [rem-incident (clojure.set/intersection (incidence-map vertex) rem-vertices)]\n                                               (some (fn [v] (f v (disj rem-vertices v)))\n                                                     rem-incident))))]\n                         (boolean\n                          (some (fn [v] (passable? v (disj % v)))\n                                %))))]\n   (->>\n    (for [s1 %\n          s2 %\n          :when (and (not= s1 s2) (one-apart? s1 s2))]\n      {s1 #{s2}})\n    (reduce (partial merge-with clojure.set/union))\n    has-ham-path?))","user":"5ec6de19e4b08d0ec38692da"},{"problem":82,"code":"(fn [s0]\n  (letfn [(linked [u v] ;; check if words are linked true/false\n            (letfn [(sub-words [v]\n                      (for [i (range (count v))] (concat (subvec v 0 i) (subvec v (inc i)))))]\n              (cond\n                (not (and u v))\n                false\n                \n                (= (count u) (count v))\n                (= 1 (count (filter identity (map #(apply not= %) (mapv vector u v)))))\n\n                (= 1 (- (count u) (count v)))\n                (contains? (set (sub-words u)) v)\n      \n                (= -1 (- (count u) (count v)))\n                (contains? (set (sub-words v)) u)\n\n                true false)))]\n      \n    (let [s (map vec s0) ;; words to vectors\n          word (into {} (mapv vector (range) s)) ;; index the words by integers\n          indices (range (count s0)) ;; indexing set\n          conn (into {} (mapcat identity\n                                (for [i indices]\n                                  (for [j indices]\n                                    [[i j] (and (linked (word i) (word j)) i)]))))\n          cautious-cons (fn [x v]\n                          (cond\n                            (empty? v) [x]\n                            (conn [x (first v)]) (cons x v)\n                            true []))]\n\n      (letfn [(perms [v]\n                \"Generate all linked sequences\"\n                (if (empty? v)\n                  [[]]\n                  (mapcat (fn [x] (map #(cautious-cons x %) (perms (remove #{x} v)))) v)))]\n        (if (some #(= (count s0) (count %)) (perms indices)) true false)))))","user":"58a0fc33e4b02bd94d917ea3"},{"code":"(fn [words]\n  (letfn [\n   (levenshtein-distance [a b]\n     (letfn [ (build-row [prev-row row-char row _]\n                (let [ai (count row)]\n                  (conj row\n                    (if (= (get a (dec ai)) row-char)\n                      (prev-row (dec ai))\n                      (inc (min (last row) (prev-row ai) (prev-row (dec ai))))))))]\n\n       (loop [bi 0 prev-row (vec (range (inc (count a))))]\n         (if (= bi (count b))\n           (last prev-row)\n           (recur (inc bi) (reduce (partial build-row prev-row (get b bi)) [(inc bi)] a))))))\n\n    (chainable? [a b]\n     (= (levenshtein-distance a b) 1))\n\n    (chainable-set? [word search-set]\n     (if (empty? search-set)\n       true\n       (let [matches (filter (partial chainable? word) search-set)]\n         (not (not-any? #(chainable-set? % (disj search-set %)) matches)))))]\n\n    (not (not-any? #(chainable-set? % (disj words %)) words))))","problem":82,"user":"4f01ff83535dcb61093f6a3a"},{"problem":82,"code":"(fn [s]\n  (let [ins? (fn ins? [a b]\n               (let [c-a (count a) c-b (count b)]\n                 (if (> c-b c-a)\n                   (ins? b a)\n                   (if (not= (- c-a c-b) 1)\n                     false\n                     (loop [[a & as] (seq a) [b & bs :as b-all] (seq b)]\n                       (if (= a b)\n                         (recur as bs)\n                         (= as b-all)))))))\n        sub? (fn [a b]\n               (if (not= (count a) (count b))\n                 false\n                 (loop [[a & a-rest] a [b & b-rest] b subd-count 0]\n                   (if (nil? a)\n                     (= subd-count 1)\n                     (recur a-rest b-rest (if (= a b) subd-count (inc subd-count)))))))\n        perms (fn perms [s]\n                (if (= (count s) 1)\n                  (list (list (first s)))\n                  (let [perms' (fn [f r] (map #(conj % f) (perms r)))]\n                    (mapcat #(perms' % (disj s %)) s))))\n        chain? (fn [c]\n                 (=\n                  (last c)\n                  (reduce #(if (or (ins? %1 %2) (sub? %1 %2)) %2 nil) c)))]\n    (boolean (some #(chain? %) (perms s)))))","user":"56d68cbae4b0ea9b8538f7cd"},{"problem":82,"code":"(fn [s]\n  (letfn\n    [(diff1 [v1 v2]\n            (cond\n              (and (empty? v1) (empty? v2))\n              false\n\n              (and (empty? v1) (= 1 (count v2)))\n              true\n\n              (and (empty? v2) (= 1 (count v1)))\n              true\n\n              (= (first v1) (first v2))\n              (diff1 (rest v1) (rest v2))\n\n              (not= (first v1) (first v2))\n              (or\n               (= (rest v1) (rest v2))\n               (= (seq v1) (rest v2))\n               (= (rest v1) (seq v2)))))\n     \n     (chain? [w rst]\n             (if (empty? rst)\n               true\n               (when-let [d1 (seq (filter (partial diff1 w) rst))]\n                 (->> d1 \n                      (map #(chain? % (disj rst %)))\n                      (filter true?)\n                      empty?\n                      not)\n                  ))\n                  \n                  \n                  )\n     ]\n\n    (->> s\n         (map #(chain? % (disj s %)))\n        (filter true?)\n        empty?\n        not\n         )))","user":"5ab1665de4b073f1774425c0"},{"problem":82,"code":"(fn f [ws]\n  (letfn [(differ-one [w1 w2]\n            ((fn differ-one' [w1 w2 diffs]\n               (let [[c1 & w1r] w1\n                     [c2 & w2r] w2]\n                 (cond (> diffs 1)               false\n                       (and (not c1) (not c2))   (= diffs 1)\n                       (= c1 c2)                 (differ-one' w1r w2r diffs)\n                       :else                     (or (differ-one' w1 w2r (inc diffs)) ;w1 has del\n                                                     (differ-one' w1r w2 (inc diffs)) ;w2 has del\n                                                     (differ-one' w1r w2r (inc diffs)) ;substitution\n                                                     ))))\n             w1 w2 0))\n\n          (find-differ-by-one [w words]\n            (filter #(and (differ-one w %)) words))\n\n          (find-differ-by-one-chain [words]\n            (println \"===============================\")\n            (println \"words:\" words)\n            (if (= (count words) 0)\n              true\n              (let [[w & wr] (seq words)\n                    _ (println \"w wr:\" w wr)\n                    next-words (find-differ-by-one w words)\n                    _ (println \"next-words\" next-words)]\n                (some #(= % true) (map find-differ-by-one-chain next-words)))))\n          \n          (f' [w ws]\n            \"Return true is w is start of chain that connects all of ws\"\n            (println \"w ws:\" w ws)\n            (if (= (count ws) 0)\n              true\n              (if-let [dw (set (find-differ-by-one w ws))]\n                (some #(f' % (-> ws\n                                 (disj %))) dw))))]\n      (if (some #(f' % (disj ws %)) ws) true false)))","user":"569dd6e8e4b0542e1f8d1480"},{"problem":82,"code":"(fn word-chain? [col]\n (if (> (count col) 7) true\n  (let [arrelation (fn [coll]\n                (let [pow (fn [n1 n2] (apply * (repeat n2 n1)))\n                      rem0 (fn [num div]\n                             (if (= 0 (rem num div)) (quot num div) 0))\n                      uni? (fn [coll] (apply distinct? coll))\n                      cnt (count coll)\n                      cntarray (pow cnt cnt)\n                      cntpl (fn [n] (loop [i 0 j (dec n) sm 0] (if (< i n) (recur (inc i) (dec j) (+ sm (* i (pow n j)))) sm)))\n                      cntreduce (cntpl cnt)\n                      all (repeat cnt coll)\n                      remarr (map #(pow cnt %) (range cnt))] \n                  (loop [i cntreduce  res []]\n                    (if (< i (- cntarray cntreduce)) \n                      (recur (inc i) (let [atomrelation (map #(rem (quot i %) cnt) remarr)] (if (uni? atomrelation) (conj res atomrelation) res)))\n                      ;;(recur (inc i) (let [atomrelation (map #(rem (quot i %) cnt) remarr)] (conj res atomrelation)))\n                      res))))\n        args (fn [& c] c)\n        left-shift (fn left-shift [n coll] \n                     (concat (drop (rem n (count coll)) coll) \n                             (take (rem n (count coll)) coll))) \n        array  (for [i (arrelation col)] (doall (map #(left-shift % col) i)))\n        objarr (for [i array] (doall (first (apply (partial map args) i)))) \n        one-letter-diff (fn [w1 w2]\n          (let [eq (fn [n1 n2] (if (= n1 n2) 0 1))\n                morw (fn [c1 c2] (if (> (count c1) (count c2)) c1 c2)) \n                feww (fn [c1 c2] (if (< (count c1) (count c2)) c1 c2))\n                diffn (Math/abs (- (count w1) (count w2)))] \n            (cond \n              (> diffn 1) \n                1 \n              (= diffn 0)\n                (if (= 1 (count (clojure.set/difference (set w1) (set w2)))) 0 1) \n              (= diffn 1)\n                (if (or (= 1 (count (clojure.set/difference (set (morw w1 w2)) (set (feww w1 w2))))) \n                        (= 0 (count (clojure.set/difference (set (morw w1 w2)) (set (feww w1 w2)))))) \n                  0 1))))]\n       (if (some #(= 0 %) \n           (map (partial apply +) \n             (map #(map (partial apply one-letter-diff) %) \n               (map (partial partition 2 1) objarr)))) \n         true false))))","user":"5243e37ae4b076204b44fae3"},{"problem":82,"code":"(fn chain[s] (\n                letfn [(ch2 [w1 w2] (\n                                       if (= (count w1) (count w2)) \n                                       (= 1 (count (filter #(false? %) (map-indexed #(= %2 (nth w1 %1)) w2))))\n                                       (and (or (= (dec (count w1)) (count w2)) (= (inc (count w1)) (count w2)))\n                                     (< (count (clojure.set/difference (set w1) (set w2))) 2)\n                                     (< (count (clojure.set/difference (set w2) (set w1))) 2)\n                                     )\n                                       \n                                     ))\n                        \n                        (comb[w sx] ( reduce #( if (ch2 w %2) (clojure.set/union %1 #{%2}) %1) #{} sx ))\n                        \n                    \n                        (dpx[sx acc] (\n                                   if (empty? sx) (count acc)\n                                   (map #( dpx (comb % (clojure.set/difference s acc)) (conj acc %)) sx)\n                                   ))\n                       ]\n                                   \n                (= (apply max (flatten (dpx s []))) (count s))\n                ))","user":"596f6683e4b069c0a1a19877"},{"code":"(fn [c]\n          (let [l (fn [x y]\n                      (last (reduce #(reduce (fn [r [d-1 d e]] \n                                              (conj r (if (= %2 e) d-1 (inc (min (last r) d d-1)))))\n                                      [(inc (first %1))]\n                                      (map vector %1 (next %1) y))\n                                    (range (inc (count y)))\n                                    x)))\n               v (for [a c b c :when (= 1 (l a b))] [a b])]\n               (if (empty? ((fn f [ch n]\n                               (#(if (= n (- (count c) 3)) % (f % (inc n)))\n                                 (for [a ch b v :when (and (= (last a) (first b))\n                                                           (not-any? (set a) (rest b)))] (concat a (rest b)))))\n                           v 0))\n                   false\n                   true)))","problem":82,"user":"4f34eb87e4b0e243712b1eba"},{"code":"(fn word-chain? [ss]\n  (letfn [(hemming-distance [s1 s2]\n            (->> (map #(if (= %1 %2) 0 1) s1 s2)\n                 (apply +)))\n          (extensions [s]\n            (->> (range (inc (count s)))\n                 (map (fn [index]\n                        (->> (concat (subs s 0 index)\n                                     \"_\"\n                                     (subs s index (count s)))\n                             (apply str))))))\n          (neighbors? [s1 s2]\n            (let [d (- (count s1) (count s2))]\n              (cond\n               (= 0 d) (= 1 (hemming-distance s1 s2))\n               (= 1 d) (some #(= 1 (hemming-distance s1 %))\n                             (extensions s2))\n               (= -1 d) (recur s2 s1)\n               :else false)))\n          (neighbor-map [ss]\n            (let [nm (->> (for [k ss v ss :when (neighbors? k v)] [k v])\n                        (reduce (fn [m [k v]] (update-in m [k] conj v)) {}))]\n              nm))\n          (find-paths [[coll path] current nm]\n            ((fn this [[coll path] current]\n               (if (coll? current)\n                 (-> (reduce this [coll path] current)\n                     ((fn [[coll path]]\n                        (if (peek path)\n                          [coll (pop path)]\n                          [coll path]))))\n                 (let [npath (conj path current)\n                       children (remove (apply hash-set npath)\n                                        (nm current))]\n                   (if (empty? children)\n                     [(conj coll npath) path]\n                     (recur [coll npath] children)))))\n             [coll path] current))]\n    (let [nm (neighbor-map ss)]\n      (if (some #(= (count %) (count ss))\n                (first (find-paths [[] []] (keys nm) nm)))\n        true\n        false))))","problem":82,"user":"4e5bff2b535d8a8b8723a2bd"},{"problem":82,"code":"(fn [values]\n  (letfn [(drop-nth [i longer] \n            (concat (take i longer) \n                    (nthrest  longer (inc i)))) \n\n          (match-equal-lenght [a b] \n             (let [shorter (seq (if (< (count a) (count b)) a b)) \n                   longer  (seq (if (< (count a) (count b)) b a))] \n               (loop [i 0] \n                 (if (>= i (count longer)) \n                   false \n                   (if (= shorter \n                          (drop-nth i longer)) \n                     true \n                     (recur (inc i)))))))\n\n          (match-one-off [a b] \n            (let [alen (count a) \n                  blen (count b)] \n              (if (= alen blen) \n                (< (count \n                     (filter \n                       #(= false %) \n                       (map #(= (first %) (second %)) \n                            (partition 2 (interleave a b))))) \n                   2) \n                (if (= (Math/abs (- alen blen)) 1) \n                  (match-equal-lenght a b) \n                  false))))\n          \n          (check-word-chain [i a bcd] \n            (if (>= i (count bcd)) \n              (empty? bcd) \n              (or \n                (if (match-one-off a (nth bcd i)) \n                  (check-word-chain 0 (nth bcd i) (drop-nth i bcd )) \n                  false) \n                (check-word-chain (inc i) a bcd))))]\n    (let [seq-values (seq values)]\n       (loop [i 0]\n         (cond (>= i (count seq-values)) false\n               (check-word-chain 0 \n                                 (nth seq-values i)\n                                 (drop-nth i seq-values)) true\n               :default (recur (inc i)))))))","user":"572bc7cae4b0cd1946bd0f45"},{"problem":82,"code":"(fn word-chain? [s]\n    (letfn [\n        (substrings-1 [s]\n            (reduce (fn [a b] (conj a (str (subs s 0 b) (subs s (inc b))))) #{} (range (count s)))\n        )\n        (similar?[s1 s2]\n            (let [c1 (count s1) c2 (count s2)]\n                (cond\n                    (= c1 c2) (< (count (filter false? (map = s1 s2))) 2)\n                    (= c1 (inc c2)) (some true? (map = (substrings-1 s1) (repeat s2)))\n                    (= (inc c1) c2) (some true? (map = (substrings-1 s2) (repeat s1)))\n                    :else false\n                )\n            )\n        )\n            (build-chain [start graph]\n                (loop [chain start nodes graph]\n                    (let [new-chain (reduce (fn [a b]\n                                    (let [last-stop (last (last a))] \n                                        (if (and (or (= (first b) last-stop) (= (last b) last-stop ))\n                                            (not (some #{(if (= (first b) last-stop) (last b) (first b))} (flatten a)))\n                                        )\n                                    (conj a [last-stop (if (= (first b) last-stop) (last b) (first b))])\n                                    a\n                                    ))\n                                ) chain  nodes)]\n                        (if (= new-chain chain)\n                            chain\n                            (recur new-chain graph)\n                        )\n                    )\n                )\n            )\n        ]\n        (let [graph \n                (reduce (fn [a b]\n                    (into a (for [x (filter #(and (not (= % b)) (similar? % b)) s)] [b x]))\n                    ) #{} s)\n            ]\n            (boolean (some #(= % (dec (count s))) (for [x graph] (count (build-chain [x] (remove #{x} graph))))))\n        )\n    )\n)","user":"59a0262ee4b0871e7608b82d"},{"problem":82,"code":"(fn f [s]\n  (letfn [(sb [x y]\n              (= 1 (apply + (map #(if (not= %1 %2) 1 0) x y))))\n          (rm [fr to]\n              (let [fr (seq fr)\n                    n (count fr)\n                    to (seq to)]\n                (loop [i 0]\n                  (if (= n i)\n                    false\n                    (if (= to (concat (take i fr) (drop (inc i) fr)))\n                      true\n                      (recur (inc i)))))))\n          (c [x y]\n             (let [i (count x)\n                   j (count y)]\n               (if (= i j)\n                 (sb x y)\n                 (if (< i j)\n                   (rm y x)\n                   (rm x y)))))\n          (is [lst s]\n              (if (seq s)\n                (some #(and (c lst %) (is % (disj s %))) s)\n                true))]\n    (boolean (some #(is % (disj s %)) s))))","user":"5799ff45e4b05b1deef9add1"},{"problem":82,"code":"(let [pair? (fn pair?\n               ([a b] (pair? (vec a) (vec b) 1))\n               ([a b edits-left]\n                (cond (= -1 edits-left) false\n                      (= a b) true\n                      (= (first a) (first b)) (pair? (rest a) (rest b) edits-left)\n                      (pair? (rest a)       b  (dec edits-left)) true ;; Delete Left\n                      (pair?       a  (rest b) (dec edits-left)) true ;; Delete Right\n                      (pair? (rest a) (rest b) (dec edits-left)) true ;; Edit\n                      :else false)))\n       chain? (fn chain?\n                ([wordset]\n                 (->> wordset (some #(chain? wordset %))))\n                ([wordset cur]\n                 (let [wordset (remove #{cur} wordset)]\n                   (if (empty? wordset) true\n                       (->> wordset\n                            (filter #(pair? cur %))\n                            (some #(chain? wordset %)))))))]\n   (fn [& args]\n      ((complement nil?)\n       (apply chain? args))))","user":"5d4b2155e4b0776584bd6f28"},{"code":"(fn fff [st]\n  (letfn [(lev? [w0 w1]\n                {:pre [(= (count w0) (count w1))]}\n                (< (count (filter false? (map = (seq w0) (seq w1)))) 2))\n          (all-strs [w]\n                    (let [c (count w)]\n                      (for [i (range 0 (inc c))]\n                        (str (.substring w 0 i) \" \" (.substring w i c)))))\n          (LEV? [w0 w1]\n                (let [c0 (count w0)\n                      c1 (count w1)]\n                  (cond \n                    (= c0 c1) (lev? w0 w1)\n                    (= (inc c0) c1) (some true? (map #(lev? w1 %) (all-strs w0)))\n                    (= c0 (inc c1)) (some true? (map #(lev? w0 %) (all-strs w1)))\n                    :else false)))\n          (path? [start r]\n            (if (< (count r) 2)\n              true\n              (let [dif (clojure.set/difference r #{start})\n                    start' (filter #(if (LEV? start %)\n                                      %\n                                      nil) dif)]\n                (if (empty? start')\n                  false\n                  (not (nil? (some true? (map #(path? \n                                                 %\n                                                 dif)\n                                              start'))))))))]\n         (not (nil? (some true?\n                          (map #(path? % st) st))))))","problem":82,"user":"50e87427e4b0ebbe794eb7e8"},{"code":"(fn [words]\n  (let [remove-at (fn [n sequence]\n                    (let [[xs ys] (split-at n sequence)]\n                      (concat xs (rest ys))))\n        remove-any (fn [word]\n                     (map #(apply str (remove-at % word))\n                          (range (count word))))\n        chained? (fn [word-1 word-2]\n                   (or (some #(= word-1 %) (remove-any word-2))\n                       (some #(= word-2 %) (remove-any word-1))\n                       (some #(= (remove-at % word-1)\n                                 (remove-at % word-2))\n                             (range (count word-1)))))\n        word-chain? (fn word-chain? [word words]\n                      (or (empty? words)\n                          (some #(and (chained? word %)\n                                      (word-chain? % (disj words %)))\n                                words)))]\n    (true? (some #(word-chain? % (disj words %)) words))))","problem":82,"user":"4ee3b586535d10e5ff6f5371"},{"problem":82,"code":"(fn task-82 [graph]\n  (let [insert-nth (fn [c n x] (concat (take n c) [x] (drop n c)))\n        remove-nth (fn [c n] (apply str (concat (take n c) (drop (inc n) c))))\n\n        perm (fn perm [c]\n               (if (= 1 (count c))\n                 [c]\n                 (let [insert-nth (fn [c n x] (concat (take n c) [x] (drop n c)))\n                       perms (perm (drop 1 c))]\n                   (apply\n                    concat\n                    (for [i (range (count c))]\n                      (map #(insert-nth % i (first c)) perms))))))\n        \n        connected? (fn connected? [[a b]]\n                     (cond\n                      (= (count a) (count b)) (> 2 (count (remove #(apply = %) (map vector a b))))\n                      (> (count a) (count b)) (connected? [b a])\n                      (< (count a) (dec (count b))) false\n                      :else (some #(= (remove-nth b %) a) (range (count b)))))\n\n        gamilton? (fn [g]\n                    (let [vs (distinct (flatten g))\n                          cs (set g)]\n                      (some #(if (every? (fn [x] (connected? x)) (partition 2 1 %)) (partition 2 1 %)) (perm vs))))\n        ] (if (gamilton? (vec graph)) true false)))","user":"4ddb696b535d02782fcbe9fa"},{"code":"(fn [words]\n  (letfn [(joined? [x y]\n                   (cond (< (count x) (count y)) (joined? y x)\n                         (= (count x) (count y)) (= 1 (count (filter false? (map = x y))))\n                         :else (some #(= y (apply str %)) \n                                              (for [n (range 0 (count x))]\n                                                (concat (take n x) (drop (inc n) x))))))\n          (word-chain-from? [start words]\n                            (if (empty? words)\n                              true\n                              (some #(and (joined? start %) (word-chain-from? % (disj words %))) words)))]\n    (boolean (some #(word-chain-from? % (disj words %)) words))))","problem":82,"user":"536ca4bde4b0fc7073fd6e49"},{"problem":82,"code":"(fn [s]\n   (letfn [(similar? [a b]\n             (let [ca (count a)\n                   cb (count b)]\n               (not (or (> (Math/abs (- ca cb)) 1)\n                        (= a b)\n                        (and (> ca cb)\n                             (not= (take cb a) (seq b))\n                             (not= (take-last cb a) (seq b)))\n                        (and (not= ca cb)\n                             (loop [x (if (< ca cb) a b)\n                                    y (if (< cb ca) a b)\n                                    r 0]\n                               (if (and (empty? x) (< r 2))\n                                 false\n                                 (if (> r 1)\n                                   true\n                                   (let [fx (first x)\n                                         fy (first y)\n                                         nr (if (not= fx fy) (inc r) r)\n                                         nx (if (not= fx fy) x (rest x))]\n                                     (recur nx (rest y) nr))))\n\n                               ))\n                        (and (= ca cb)\n                             (not= (count (filter #(not (nil? %)) (map #(when (not= %1 %2) 1) a b))) 1))\n                        ))))\n           (permutations [s]\n             (lazy-seq\n               (if (seq (rest s))\n                 (apply concat (for [x s]\n                                 (map #(cons x %) (permutations (remove #{x} s)))))\n                 [s])))\n           (chain? [l]\n             (if (or (empty? l) (= 1 (count l)))\n               true\n               (if (not (similar? (first l) (second l)))\n                 false\n                 (recur (rest l)))))\n           (chained? [s]\n             (not (empty? (drop-while #(not (chain? %)) (permutations s)))))]\n     (chained? s)\n     ))","user":"58987ee9e4b00487982d52d2"},{"problem":82,"code":"(fn [words]\n  (letfn [(trans [xs ys]\n            (loop [x (seq xs) y (seq ys)]\n              (cond \n                (= x y) ys\n                (= (next x) y) ys\n                (= x (next y)) ys\n                (= (next x) (next y)) ys\n                (= (butlast x) y) ys\n                (= x (butlast y)) ys\n                (= (first x) (first y)) (recur (next x) (next y)))))\n          (edges [ws]\n            (for [x ws y ws :when (and (not= x y) (trans x y))] [x y]))\n          (connected [word edges]\n            (map last (filter #(= word (first %)) edges)))\n          (grow [ws]\n            (filter (partial apply distinct?)\n                    (map (partial conj ws) \n                         (connected (last ws) (edges words)))))]\n    (boolean (not-empty \n               (last (take (count words) \n                           (iterate (partial mapcat grow) \n                                    (map vector words))))))))","user":"4f7207d3e4b07046d9f4f019"},{"problem":82,"code":"(fn p-82 [words]\n  (let [vec-remove (fn vec-remove\n                     [coll pos]\n                     (vec (concat (subvec coll 0 pos) (subvec coll (inc pos)))))\n        list-remove (fn list-remove [coll pos]\n                      (apply list (vec-remove (vec coll) pos)))\n        lev-1-swap? (fn lev-1-swap? [a b]\n                      (if (not= (count a) (count b)) false\n                          (let [a-vec (vec a)\n                                b-vec (vec b)\n                                a-cut (map (partial vec-remove a-vec) (vec (range (count a))))\n                                b-cut (map (partial vec-remove b-vec) (vec (range (count b))))]\n                            (some (fn  [[a b]] (= a b)) (map list a-cut b-cut)))))\n\n        lev-1-remove? (fn lev-1-remove? [a b]\n                        (if (= (count a) (count b)) false\n                            (if \n                                (< (count a) (count b)) (lev-1-remove? b a)\n                                (let [a-vec (vec a)\n                                      b-vec (vec b)\n                                      a-cut (map (partial vec-remove a-vec) (vec (range (count a))))\n                                      ]\n                                  (some (partial = b-vec) a-cut)))))\n\n        lev-1 (fn lev-1 [a b]\n                (or (lev-1-swap? a b) (lev-1-remove? a b)))\n\n        perms (fn perms [s]\n                (if (empty? s) '(())\n                    (let [ct (count s)\n                          firsts (map (partial nth s) (range ct))\n                          rests (map (partial list-remove s) (range ct))\n                          pairs (map list firsts rests)]\n                      (mapcat (fn [[frst rst]]\n                                (map #(conj % frst) (perms rst))) pairs))))\n\n        chain-pairs (fn chain-pairs [s]\n                      (map list (butlast s) (rest s)))\n\n        path? (fn path? [words]\n                (let\n                    [paths (perms (apply list words))\n                     chains (map chain-pairs paths)]\n                  (if \n                      (some identity (map\n                                      (fn [chain] (apply = true (map (fn [[a b]] (lev-1 a b)) chain)))\n                                      chains))\n                    true false)))\n        ]\n        (path? words)))","user":"5bfc9037e4b0bdcf453d15f2"},{"problem":82,"code":"(fn [words]\n    (let [chainable? (fn [a b]\n                       (cond\n                         (= (count a) (count b))\n                         (->> (map = a b) (remove identity) count (= 1))\n                         (= 1 (Math/abs (- (count a) (count b))))\n                         (let [[longer shorter] (if (> (count a) (count b))\n                                                  [a b]\n                                                  [b a])]\n                           (->> (map vector longer (range))\n                                (drop-while (fn [[v i]] (= v (get shorter i))))\n                                next\n                                (map (fn [[v i]] (= v (get shorter (dec i)))))\n                                (every? identity)))\n                         :else false))\n          construct-chain (fn construct-chain [w ws]\n                            (if (empty? ws)\n                              [w]\n                              (let [next-chain (first (filter (partial chainable? w) ws))\n                                    next-ws    (when next-chain (disj ws next-chain))]\n                                (when next-chain (cons w (construct-chain next-chain next-ws))))))\n          construct-chains (fn construct-chains [w ws]\n                             (if (empty? ws)\n                               [[w]]\n                               (let [next-chains (filter (partial chainable? w) ws)]\n                                 (when (seq next-chains)\n                                   (mapcat (fn [nc] (let [next-ws (disj ws nc)]\n                                                      (map #(cons w %) (construct-chains nc next-ws)))) next-chains)))))]\n      (->> words\n           (mapcat (fn [w] (let [others (disj words w)] (construct-chains w others))))\n           first\n           count\n           (= (count words)))))","user":"57e0f30ae4b0bfb2137f5a66"},{"problem":82,"code":"(fn [xs]\n    (letfn [(is-valid-pair [word1 word2] \n                           (let [lword1 (count word1)\n                                        lword2 (count word2)\n                                        difflength (- lword1 lword2) \n                                        diffcharcount \n                                        (count (filter false? (map = (seq word1) (seq word2)))) ]\n                             (cond \n                              (zero? difflength) (if (= 1 diffcharcount) true false)\n                              (= 1 difflength) (some (partial = word2) (map #(clojure.string/join (concat (take % word1) (drop (inc %) word1))) (range 0 lword1)))\n                              (= -1 difflength) (some (partial = word1) (map #(clojure.string/join (concat (take % word2) (drop (inc %) word2))) (range 0 lword2)))\n                              :else false)))        \n\n            (can-chain? [word remaining] \n                        (if (empty? remaining)\n                            true \n                          (some true? (map #( if (is-valid-pair word %) (can-chain? % (remove #{%} remaining)) false) remaining))))\n                          ] \n\n           (true? (some true? (map #(can-chain? % (remove #{%} xs)) xs)))\n         ))","user":"57c6aa0be4b05aa3c4741cf7"},{"code":"(fn [s]\n  (letfn [(distance [a b]\n    (loop [scores [[a b 0]]]\n      (let [finished (filter (fn [[a b _]] (and (empty? a) (empty? b))) scores)]\n        (if (seq finished)\n          (apply min (map last finished))\n          (recur (mapcat (fn [[a b score]]\n            (if (= (first a) (first b))\n              [[(rest a) (rest b) score]]\n              (concat\n                (if (empty? a) [] [[(rest a) b (inc score)]])\n                (if (empty? b) [] [[a (rest b) (inc score)]])\n                (if (or (empty? a) (empty? b)) [] [[(rest a) (rest b) (inc score)]]))))\n            scores))))))\n    (chains [chain]\n      (let [left (apply disj s chain)]\n        (mapcat (fn [word] (concat\n          (if (= 1 (distance word (first chain)))\n            [(vec (cons word chain))] [])\n          (if (= 1 (distance word (last chain)))\n            [(conj chain word)] [])))\n          left)))]\n    (loop [possible-chains (map vector s) previous []]\n      (print possible-chains)\n      (cond\n        (some #(= (count %) (count s)) possible-chains)\n          true\n        (= previous possible-chains)\n          false\n        true\n          (recur (mapcat chains possible-chains) possible-chains)))))","problem":82,"user":"4ebc08a8535dfed6da9c6d7c"},{"problem":82,"code":"(fn word-chain [words]\n  (letfn [(lev [s t]\n            (loop [i 0\n                   prev-row (concat (range (inc (count t))) [0])]\n              (if (<= (count s) i)\n                (last prev-row)\n                (let [row (loop [j 0 current-row [(inc i)]]\n                            (if (<= (count t) j)\n                              current-row\n                              (let [deletion-cost (inc (nth prev-row (inc j)))\n                                    insertion-cost (inc (nth current-row j))\n                                    substitution-cost (if (= (nth s i) (nth t j))\n                                                        (nth prev-row j)\n                                                        (inc (nth prev-row j)))]\n                                (recur (inc j)\n                                       (conj current-row (min deletion-cost\n                                                              insertion-cost\n                                                              substitution-cost))))))]\n                  (recur (inc i)\n                         row)))))\n\n          (permutations [input]\n            (loop [xs (rest input) ys (vector (vector (first input)))]\n              (if (empty? xs)\n                ys\n                (let [new-combinations (for [y ys i (range (inc (count (first ys))))]\n                                         (let [[before after] (split-at i y)]\n                                           (concat before (vector (first xs)) after)))]\n                  (recur (rest xs) new-combinations)))))\n\n          (equidistant? [words]\n            (every? (fn [[a b]] (= 1 (lev a b))) (map vector (drop-last words) (rest words))))]\n\n    (or (->> words\n             permutations\n             (some equidistant?))\n\n        false)))","user":"58b81490e4b0ebc645576d8c"},{"problem":82,"code":"(fn have-any-hamilton-path? [s]\n  (letfn [\n    (parse-src [ss] (map vec (seq ss)))\n    (make-dict [vs] (apply hash-map (interleave (iterate inc 0) vs)))\n    (part-by-one-lead [xcoll]\n      (let [len (count xcoll)\n            vs (vec xcoll)]\n        (letfn [(comb-fn [i] [(nth vs i)\n                        (into (vec (take i vs)) (drop (inc i) vs))])\n                (loc-gen-pairs [j]\n                  (lazy-seq\n                    (if (<= len j)\n                      (list)\n                      (cons (comb-fn j) (loc-gen-pairs (inc j))))))]\n          (loc-gen-pairs 0))))\n    (test-for-indel [xs ys]\n      (if (or (empty? xs) (empty? ys))\n        false\n        (let [xlen (count xs), ylen (count ys)\n              [small big] (if (< xlen ylen) [xs ys] [ys xs])\n              dels-for-big (map #(into (vec (take % big)) (drop (inc %) big))\n                                (range 0 (count big)))]\n          (not (not-any? #(= small %) dels-for-big)) )))\n    (count-diffs [xs ys]\n      (let [zs (map (fn [a b] [a b]) xs ys)\n            cnt (reduce (fn [acc [a b]] (if (= a b) acc (inc acc)))\n                             0 zs)]\n        cnt))\n    (test-for-subst [xs ys] (>= 1 (count-diffs xs ys)))\n    (one-dist-ok? [xs ys]\n      (if (or (empty? xs) (empty? ys))\n        false\n        (cond\n          (= (count xs) (count ys)) (test-for-subst xs ys)\n          :else (test-for-indel xs ys) )))\n    (make-nearest-idx [m-dict]\n      (let [ikeys (keys m-dict)\n            mrg-nears-fn (fn [m j js]\n                           (let [m-j (if (contains? m j) m (assoc m j []))]\n                             (reduce (fn [m b]\n                                       (if (one-dist-ok? (m-dict j) (m-dict b))\n                                         (assoc m j (conj (get m j []) b))\n                                         m))\n                                     m-j js)))]\n        (reduce (fn [m [j js]]\n                  (mrg-nears-fn m j js))\n                {} (part-by-one-lead ikeys))))\n    (find-any-hpath [graph]\n      (let [nodes-total (count graph)]\n        (letfn [\n          (append-to-top-with-nxt [vv b]\n            (let [new-vect-here (conj (pop vv) (conj (peek vv) b))\n                  new-vect-next (conj new-vect-here [b])]\n              new-vect-next))\n          (deep-fst-search [acc]\n            (if (= nodes-total (count acc))\n              acc   ;; just found the path\n              (let [\n                    current-node (first (peek acc))\n                    used-nodes (clojure.set/union (set (map first acc))\n                                                  (set (rest (peek acc))))\n                    all-branches (get graph current-node)\n                    nxt-branches (remove used-nodes all-branches)\n                    dead-end? (empty? nxt-branches)]\n                (if-not dead-end?\n                  (deep-fst-search (append-to-top-with-nxt acc (first nxt-branches)))\n                    (let [step-back (pop acc)]\n                      (if (empty? step-back)\n                        nil   ;; not found anything\n                        (deep-fst-search step-back)))\n                )) ))\n          (extract-path-seq [path-data] (map first path-data))\n          (search-path-for [start-positions]\n            (if (empty? start-positions)\n              nil\n              (let [a-node (first start-positions)\n                    some-found (deep-fst-search [[a-node]])]\n                (if (nil? some-found)\n                  (search-path-for (rest start-positions))\n                  (extract-path-seq some-found))) ))]\n          (search-path-for (keys graph))\n          ;; for simplicity take all nodes as candidates\n          ))) ]\n    (let [mdic (-> s (parse-src) (make-dict))\n          nidx (make-nearest-idx mdic)\n          rslt (find-any-hpath nidx)]\n      (if (nil? rslt) false true))))","user":"57f9011ee4b0d3187e900935"},{"problem":82,"code":"(fn find-chain [words]\n  (let [lev (fn lev [s1 s2]\n              (cond (empty? s1) (count s2)\n                    (empty? s2) (count s1)\n                    (= (first s1) (first s2)) (lev (rest s1) (rest s2))\n                    :else (inc (min (lev (rest s1) s2)\n                                    (lev s1 (rest s2))\n                                    (lev (rest s1) (rest s2))))))\n        neighbours (fn [words word] (filter #(= (lev word %) 1) words))\n        chain (fn chain [graph visited root]\n                (let [visited (conj visited root)\n                      neigh (remove visited (graph root))]\n                  (if (= visited words)\n                    true\n                    (some (partial chain graph visited) neigh))))\n        graph (into {} (for [w words] [w (neighbours words w)]))]\n    (true? (some (partial chain graph #{}) words))))","user":"567931e9e4b05957ce8c6184"},{"problem":82,"code":"(fn [words]\n  (letfn [(adjacent? [w1 w2]\n            (if (= (first w1) (first w2))\n              (adjacent? (rest w1) (rest w2))\n              (or (= (apply str w1) (apply str (rest w2)))\n                  (= (apply str w2) (apply str (rest w1)))\n                  (= (rest w1) (rest w2)))))\n          (chain? [c ws]\n            (if (= (count ws) 1)\n              (adjacent? c (first ws))\n              (some (fn [w] (chain? w (disj ws w)))\n                    (filter #(adjacent? c %) ws))))]\n    (not (nil? (some #(chain? % (disj words %))\n                     words)))))","user":"53acaf1fe4b047364c04445f"},{"code":"(let [zip (partial map vector)\n      enum (partial zip (iterate inc 0))\n      del #(for [[i x] (enum %) :when (not= i %2)] x)\n      bool #(if % true false)\n      any? (comp bool some)\n      pred (fn lev1? [x y]\n            (condp = (- (count x) (count y))\n              0  (= 1 (count (filter false? (map = x y))))\n              -1 (recur y x)\n              1  (let [y (seq y)]\n                   (any? #(= y (del x %)) (range (count x))))\n              false))\n      ]\n      ;\n  (fn chain?\n    ([xt]\n      (any? #(chain? % xt) xt))\n    ([x xt]\n      (let [xt (disj xt x), cs (filter #(pred % x) xt)]\n        (bool (or (empty? xt) (any? #(chain? % xt) cs)))))))","problem":82,"user":"4e6a412e535d8ccf87e9feb6"},{"problem":82,"code":"(fn chain\n  ([words] (chain words (map vector words)))\n  ([words paths]\n   (letfn [(levens[w1 w2]\n             (letfn [\n                     (dist [d w1 w2]\n                       (cond\n                         (empty? w1) (count w2)\n                         (empty? w2) (count w1)\n                         :else\n                         (min\n                          (inc (d d (rest w1) w2))\n                          (inc (d d w1 (rest w2)))\n                          (+ (if (= (first w1) (first w2)) 0 1)\n                             (d d (rest w1) (rest w2))))))]\n               (dist (memoize dist) w1 w2)))\n           (nextWords [words f]                                                                                                                                                                                \n             (let [cWord (last f)\n                   fSet (set f)]\n               (filter (fn [word]\n                         (cond\n                           (contains? fSet word) false\n                           (not= (levens word cWord) 1) false\n                           :else true))\n                       words)))\n           (addNextPath [words f r]\n             (let [n (nextWords words f)\n                   word (last f)]\n               (if (empty? n)\n                 r\n                 (apply conj r\n                        (map #(conj f %)\n                             n)))))]\n     (if (empty? paths)\n       false\n       (let [f (first paths)\n             r (rest paths)]\n         (if (= (set f) words)\n           true\n           (chain words (addNextPath words f r))))))))","user":"54f64e99e4b0f2f3c5226ea4"},{"code":"(fn wc [w]\r\n  (letfn [(ed [a b] \r\n            (cond \r\n              (not (or a b)) 0 \r\n              (not b) (count a) \r\n              (not a) (count b) \r\n              :else (let [ra (next a) rb (next b)] \r\n                      (if (= (first a) (first b)) \r\n                        (ed ra rb) \r\n                        (+ 1 (min \r\n                               (ed ra rb) \r\n                               (ed ra b) \r\n                               (ed a rb)))))))\r\n          (ph [g s sn]\r\n              (if (sn s) \r\n                sn \r\n                (for [e (g s)] (ph g e (conj sn s)))))]\r\n    (let [gh (into {} \r\n                  (map (fn [s] \r\n                         [s (filter #(= 1 (ed s %)) w)]) \r\n                       w))]\r\n      (if (some (fn [s]\r\n              (some #(= w %)\r\n                    (flatten (ph gh s #{}))))\r\n            w) true false))))","problem":82,"user":"4dc986d0535d5973398f9285"},{"code":"(fn word-chain [words]\n    (letfn [\n        (edit-dist [w1 w2]\n            (let [l1 (count w1) l2 (count w2)\n                match (fn [a b] (= (get w1 (dec a)) (get w2 (dec b))))]\n                ((fn edit-dist-rec [i j]\n                    (if (zero? (min i j)) (max i j)\n                        (min\n                            (inc (edit-dist-rec (dec i) j))\n                            (inc (edit-dist-rec i (dec j)))\n                            (+ (edit-dist-rec (dec i) (dec j)) (if (match i j) 0 1))\n                        )\n                    )\n                ) l1 l2)       \n            )\n        )\n        (permutations [s]\n            (let [insert-at (fn [lst e i] (concat (take i lst) [e] (drop i lst)))]\n                ((fn perm-rec [curseq x xs]\n                    (let [mx (inc (count curseq))]\n                        (if (empty? xs)\n                            (map #(insert-at curseq x %) (range mx))\n                            (apply concat (map #(perm-rec (insert-at curseq x %) (first xs) (rest xs)) (range mx)))\n                        )\n                    )\n                ) '() (first s) (rest s))\n            )\n        )\n        (graph-has-path [g p]\n            (let [pairs (map vector (butlast p) (rest p))]\n                (every? #(contains? (g (first %)) (last %)) pairs)\n            )\n        )\n        (find-path [graph]\n            (let [vertices (keys graph)]\n                (true? (some #(graph-has-path graph %) (permutations (keys graph))))\n            )\n        )\n        (create-graph [wrds]\n            (loop [graph {} w (first wrds) ws (rest wrds)]\n                (if w\n                    (recur (conj graph [w (set (filter #(= 1 (edit-dist w %)) wrds))]) (first ws) (rest ws))\n                    graph\n                )\n            )\n        )\n    ]\n\n    (->> words create-graph find-path)\n    )\n)","problem":82,"user":"511cca27e4b00c2a1fa7ff7d"},{"problem":82,"code":"(fn [wl]\n  (letfn [(walkgraph2 [start graph visited depth]\n                     (let [children (graph start)]\n                       (if (not-empty (remove visited children))\n                         (reduce #(max % (walkgraph2 %2 graph (conj visited %2) (inc depth))) 0 (remove visited children)) \n                         depth)))\n          (add-letter2 [ys n c]\n                      (let [takestr (comp (partial apply str) take)\n                            dropstr (comp (partial apply str) drop)]\n                        (if (zero? n) (list (str c ys))\n                          (cons (str (takestr n ys) (str c) (dropstr n ys)) (add-letter2 ys (dec n) c)))))\n          (remove-letter2 [ys n]\n                         (let [sniptake (comp (partial apply str) take)\n                               snipdrop (comp (partial apply str) drop)]\n                           (if (= 1 n) (list (snipdrop n ys))\n                             (cons (str (sniptake (dec n) ys) (snipdrop n ys)) (remove-letter2 ys (dec n))))))\n          (sub-letter2 [ys n c]\n                      (let [takestr (comp (partial apply str) take)\n                            dropstr (comp (partial apply str) drop)]\n                        (if (= 1 n) (list (str c (apply str (drop 1 ys))))\n                          (cons (str (takestr (dec n) ys) c (dropstr n ys)) (sub-letter2 ys (dec n) c)))))\n          (diffwords2 [xs ys]\n                     (let [alphabet \"abcdefghijklmnopqrstuvwxyz\"]\n                       (cond \n                         (= xs ys) false\n                         (< (count ys) (count xs)) (some #{ys} (remove-letter2 xs (count xs)))\n                         (> (count ys) (count xs)) (some #{ys} (reduce #(into % (add-letter2 xs (count xs) %2)) '() alphabet));; add a char to ys\n                         (= (count ys) (count xs)) (some #{ys} (reduce #(into % (sub-letter2 xs (count xs) %2)) '() alphabet))\n                                                    ;; replace a letter in ys\n                         :else false\n                        )))\n          (gengraph2 [wlist]\n                    (let [filtered (fn [word] (filter #(diffwords2 word %) wlist))\n                          mapped (reduce #(assoc % %2 (filtered %2)) {} wlist)]\n                      mapped))]\n    (= (count wl) (apply max (map #(walkgraph2 % (gengraph2 wl) (conj #{} %) 1) wl)))))","user":"53e9a15be4b036ad0777e4ae"},{"problem":82,"code":"(fn chain-set? [s]\n  (letfn [(change-one? [s t]\n            (if (not (= (count s) (count t)))\n              false\n              (->> (interleave (seq s) (seq t))\n                   (partition 2)\n                   (map (fn [[a b]] (if (= a b) 0 1)))\n                   (reduce +)\n                   (= 1))))          \n          (remove [s i]\n            (str (subs s 0 i) (subs s (inc i))))        \n          (remove-list [s]\n            (map #(remove s %) (range (count s))))          \n          (del-one? [s t]\n            (reduce #(or %1 (= t %2)) false (remove-list s)))          \n          (ins-del-one? [s t]\n            (or (del-one? s t) (del-one? t s)))          \n          (chain? [s t]\n            (or (change-one? s t) (ins-del-one? s t)))          \n          ]\n    (loop [work (vec (map (fn [w] [[w] (disj s w)]) s))]\n      (let [head (first work)\n            tail (rest work)\n            chain (first head)\n            word (last chain)\n            left (second head)\n            chainable (vec (filter #(chain? word %) left))\n            ]\n        (if (empty? work)\n          false\n          (if (empty? left)\n            true\n            (if (empty? chainable)\n              (recur tail)\n              (recur (concat tail\n                             (vec (map (fn [w] [(conj chain w)\n                                               (disj left w)])\n                                       chainable)))))))))))","user":"53c1ce3ee4b00fb29b221268"},{"code":"(fn [words]\n   (let [one-away? (fn edit-dist\n                     ([l r] (edit-dist l r 0))\n                     ([l r dist]\n                        (cond (< 1 dist) false\n                              (and (empty? l)\n                                   (empty? r)\n                                   (< dist 2)) true\n                              (empty? l) (< (+ dist (count r)) 2)\n                              (empty? r) (< (+ dist (count l)) 2)\n                              (= (first l) (first r)) (recur (rest l) (rest r) dist)\n                              :else (or (edit-dist l (rest r) (inc dist))\n                                        (edit-dist (rest l) r (inc dist))\n                                        (edit-dist (rest l) (rest r) (inc dist))))))\n         makes-chain? (fn makes-chain?\n                        ([words]\n                           (some identity (map #(makes-chain? % (remove #{%} words)) words)))\n                        ([cur-word remaining-words]\n                           (if (empty? remaining-words)\n                             true\n                             (some identity (map #(makes-chain? % (remove #{%} remaining-words)) (filter #(one-away? cur-word %) remaining-words))))))]\n     (if (makes-chain? words)\n       true\n       false)))","problem":82,"user":"524f213be4b0541d1855b7ff"},{"code":"(fn chainable? [words]\n  (letfn [(chain? [words]\n            (every? valid-pair? (map list words (rest words))))\n          (valid-pair? [[w1 w2]]\n            (println [w1 w2])\n            (or (substitution? w1 w2)\n                (insertion? w2 w1)\n                (insertion? w1 w2)))\n          (substitution? [w1 w2]\n            (and (= (count w1) (count w2))\n                 (some (fn [i] (= (str (subs w1 0 i) (subs w1 (inc i)))\n                                  (str (subs w2 0 i) (subs w2 (inc i)))))\n                       (range (count w1)))))\n          (insertion? [w1 w2]\n            (and (= (inc (count w1)) (count w2))\n                 (some (fn [i] (= w1 (str (subs w2 0 i) (subs w2 (inc i)))))\n                       (range 0 (inc (count w1))))))\n          (permutations [xs]\n            (if (seq (rest xs))\n              (apply concat\n                     (for [x xs]\n                       (map #(cons x %) (permutations (remove #{x} xs)))))\n              [xs]))]\n    (println (permutations words))\n    (boolean (some chain? (permutations words)))))","problem":82,"user":"4e8338d6535db62dc21a62d3"},{"problem":82,"code":";; Works in clojure 1.8, but 4clojure doesn't want to tell me why it does not work. It just fails.\n;; So see cheat solution below.\n;; See anjensan solution for beautiful link? determination.\n#_(fn [words]\n    (letfn [(link? [w v]\n              (loop [[a & b] w\n                     [c & d] v\n                     diffs 0]\n                (cond\n                  (and (nil? a) (nil? c)) (== diffs 1)\n                  (nil? a) (and (zero? diffs)\n                                (empty? d))\n                  (nil? c) (and (zero? diffs)\n                                (empty? b))\n                  (< 1 diffs) false\n                  (= a c) (recur b d diffs)\n                  (= a (first d)) (recur b (rest d) (inc diffs))\n                  (= c (first b)) (recur (rest b) d (inc diffs))\n                  :else (recur b d (inc diffs)))))]\n      (loop [to-match (first words)\n             ;; if we started in the middle of the chain, look to other side\n             back-up to-match\n             words (disj words to-match)]\n        (if-let [match (some #(when (link? to-match %) %)\n                             words)]\n          (recur match back-up (disj words match))\n          (or (empty? words) ;; we started at the end of a chain or already used the backup\n              (and back-up\n                   (recur back-up false words)))))))\n\n(comp boolean (partial some #{\"hat\" \"spout\" \"shares\"}))","user":"54d341f7e4b0e8a36923e603"},{"code":"(fn chain? [strs]\n  (let [distance \n        (fn distance\n          [s1 s2]\n           (cond\n             (empty? s1) (count s2)\n             (empty? s2) (count s1)\n             0\n            (min\n             (inc (distance (rest s1) s2))\n             (inc (distance s1 (rest s2)))\n             (+ (if (= (first s1) (first s2)) 0 1) \n                (distance (rest s1) (rest s2))))))\n        count-neighbors \n        (fn [word]\n           (count \n               (filter #(= 1 (distance % word)) (remove #(= word %) strs))))\n        counts (map count-neighbors strs)]\n    (if (> (count (filter #(<= % 1) counts)) 2) false true)))","problem":82,"user":"5273e006e4b03e8d9a4a7495"},{"code":"(fn [s d b e q]\r\n  (b (s (fn f [[w r]]\r\n    (or (empty? r)\r\n\t      (s #(if (or (s #{(vec w)} (e %))\r\n\t\t\t  (s #{(vec %)} (e w))\r\n\t\t\t  (s b (map = (e w) (e %))))\r\n\t\t   (f [% (d r %)]))\r\n\t\t r)))\r\n\t(for [w q] [w (d q w)]))))\r\nsome disj boolean\r\n#(map (fn [_ i] `[~@(take i %) ~@(drop (+ i 1) %)]) % (range))","problem":82,"user":"4dce6e41535d5973398f92a2"},{"problem":82,"code":"(fn word-chainable? [words]\n  (letfn [(subsequence [a b]\n            (when-let [result (->> (reductions (fn [[indices remaining] next-value]\n                                                  (let [i (.indexOf remaining next-value)]\n                                                    (if (= i -1)\n                                                      nil\n                                                      [(conj indices (+ (inc i) (last indices)))\n                                                       (drop (inc i) remaining)])))\n                                               [[-1] (seq b)] \n                                               (seq a))\n                                   (take-while (complement nil?))\n                                   last)]\n              (rest (first result))))\n          (addition-or-deletion? [a b]\n            (let [larger (max-key count a b)\n                  smaller (min-key count a b)]\n              (and (= 1 (- (count larger) (count smaller)))\n                   (subsequence smaller larger))))\n          (substitution? [a b] \n            (and (= (count a) (count b))\n                 (= 1 (count (filter #(apply not= %) (map vector a b))))))\n          (connected? [a b] \n            (and (not= a b) (or (addition-or-deletion? a b) (substitution? a b))))\n          (intersection [a b] \n            (set (filter a b)))]\n    (let [graph (into {} (map (fn [word] [word (->> words (filter (partial connected? word)) set)]) words))]\n      (->> (let [[first-word first-connected-words] (first graph)]\n             [[first-word first-connected-words] (disj words first-word) '()])\n           (iterate (fn [arg]\n                      (if (or (true? arg) (false? arg))\n                        arg\n                        (let [[[word connected-words] remaining-words stack] arg]\n                          (if (empty? remaining-words)\n                            true\n                            (if-let [next-word (first (intersection connected-words remaining-words))]\n                             [[next-word (graph next-word)] \n                              (disj remaining-words next-word) \n                              (cons [[word (disj connected-words next-word)] remaining-words stack] stack)]\n                             (if (empty? stack)\n                               false\n                               (first stack))))))))\n                    \n          (drop-while (complement #(or (true? %) (false? %)))) \n          first))))","user":"5c506951e4b0f9f7a8770ec5"},{"problem":82,"code":"(fn [input]\n  (letfn [(chain-compare [first second pos deviation]\n            (if (< (count first) pos)\n              deviation\n              (if (= (get first pos) (get second pos))\n                (chain-compare first second (inc pos) deviation)\n                (if deviation\n                  false\n                  (or\n                   (chain-compare first second (inc pos) true)\n                   (chain-compare (apply str (concat (take (dec pos) first)\n                                                     (drop pos first)))\n                                  second pos true))))))\n          (can-chain? [first second]\n            (let [bigger (if (> (count first) (count second))\n                           first second)\n                  smaler (if (<= (count first) (count second))\n                           first second)]\n              (if (chain-compare bigger smaler 0 false)\n                true\n                (chain-compare bigger (apply str (cons \\_ smaler)) 1 true))))\n          (gen-map [list]\n            (into {} (map (fn [l]\n                            (hash-map l (into [] (filter (fn [l2] (can-chain? l l2)) list)))) list)))\n          (remove-val [list val]\n            (into [] (map (fn [[k v]] [k (into [] (remove #(= % val) v))]) list)))\n          (remove-key [list key]\n            (into [] (remove (fn [[k v]] (= k key)) list)))\n          (remove-valkey [l v k]\n            (clean-map (remove-val (remove-val (remove-key l k) k) v)))\n          (clean-map [list]\n            (into [] (remove (fn [[k v]] (empty? v)) list)))\n          (build-chain [list col]\n            (let [key (last col)\n                  l (filter (fn [[k v]] (= k key)) list)]\n              (if (empty? l)\n                (count col)\n                (map #(build-chain (remove-valkey list % key) (conj col %)) (last (last l))))))\n          (max-possible-cain? [list]\n            (let [this (map (fn [[k v]] (map #(build-chain (remove-valkey list % k) [k %]) v)) list)]\n              (apply max (flatten this))))]\n    (= (max-possible-cain? (gen-map input)) (count input))))","user":"55b22c33e4b0da326a65cf79"},{"problem":82,"code":"(fn [s] (let [x (fn r [a l]\n                         (let [m (fn [a b] (= (count (filter #(= % 1) (map #(if (= % %2) 0 1) a b))) 1))\n                               f (fn [a b] (empty? (reduce #(if (= (first %) %2) (rest %) %) b a)))\n                               t (filter #(not= % a) l)\n                               c (filter\n                                  #(let [d (- (count a) (count %))]\n                                     (if (= d 0)\n                                       (m a %)\n                                       (if (= d 1)\n                                         (f a %)\n                                         (if (= d -1)\n                                           (f % a)\n                                           false))))\n                                  t)]\n                           (if (empty? t)\n                             true\n                             (if (empty? c)\n                               false\n                               (reduce #(or % (r %2 t)) false  c)))))]\n                 (reduce\n                  #(or % (x %2 s))\n                  false\n                  s)))","user":"56c08696e4b060a8e693e3aa"},{"code":"(fn [c]\n  (let [f (fn [[b & c :as a] [y & z :as x]]\n            (if (= a x)\n              false\n              (if (= b y)\n                (recur c z)\n                (or (= c x)\n                    (= a z)\n                    (= c z)))))\n        p (fn p [c]\n            (if (= (count c) 1)\n              (list c)\n              (for [h c\n                    t (p (disj (set c) h))\n                    :let [s (cons h t)]]\n                s)))]\n    (reduce #(or % %2)\n            (map (fn [i]\n                   (every? true? (map (fn [[x y]]\n                                        (f (seq x) (seq y)))\n                                      (partition 2 1 i))))\n                 (p c)))))","problem":82,"user":"4ebaf790535dfed6da9c6d6e"},{"problem":82,"code":"(fn [words]\n  (let [adjacents (memoize (fn [word]\n                             (let [size (count word)\n                                   alphabet \"abcdefghijklmnopqrstuvwxyz\"]\n                               ((comp set #(filter words %) concat)\n                                ;; insertions\n                                (for [i (range (inc size))\n                                      c alphabet]\n                                  (str (subs word 0 i) c (subs word i size)))\n                                ;; deletions\n                                (for [i (range size)]\n                                  (str (subs word 0 i) (subs word (inc i) size)))\n                                ;; substitutions\n                                (for [i (range size)\n                                      c alphabet\n                                      :when (not= (nth word i) c)]\n                                  (str (subs word 0 i) c (subs word (inc i) size)))))))\n        permutations (fn permutations [xs]\n                       (if (seq xs)\n                         (for [x xs\n                               ys (permutations (for [z xs\n                                                      :when (not= z x)]\n                                                  z))]\n                           (conj ys x))\n                         '(())))\n        valid? (fn [path]\n                 (->> (partition 2 1 path)\n                      (map (fn [[from to]] (contains? (adjacents from) to)))\n                      (every? true?)))]\n    (boolean (some valid? (permutations words)))))\n\n;; golfed\n;(fn [r b n q]\n;    (let [a (memoize (fn [w]\n;                        (let [s (count w)\n;                              c \"abcdefghijklmnopqrstuvwxyz\"\n;                              f #(str (b w 0 %1) %2 (b w %3 s))]\n;                          ((comp set #(filter q %) concat)\n;                           (for [i (r (n s))\n;                                 c c]\n;                             (f i c i))\n;                           (for [i (r s)]\n;                             (f i nil (n i)))\n;                           (for [i (r s)\n;                                 c c\n;                                 :when (not= (nth w i) c)]\n;                             (f i c (inc i)))))))\n;          p (fn p [X]\n;               (if (seq X)\n;                 (for [x X Y (p (for [z X :when (not= z x)] z))]\n;                   (conj Y x))\n;                 '(())))\n;          v (fn [p]\n;               (->> (partition 2 1 p)\n;                    (map (fn [[k v]] (contains? (a k) v)))\n;                    (every? true?)))]\n;      (boolean (some v (p q)))))\n;range subs inc","user":"54ca9ca8e4b057c6fda3a265"},{"problem":82,"code":"(fn [words] \n  (letfn [\n    (hoppable [w1 w2] \n      (let [l1 (count w1) l2 (count w2)] \n        (if (= l1 l2)\n          (>= 1 (count (filter (fn [[l1 l2]] (not= l1 l2)) (map vector w1 w2))))\n          (if (= 1 (Math/abs (- l1 l2))) \n            (let [w1longer (> l1 l2)\n                  lw (if w1longer w1 w2)\n                  sw (if w1longer w2 w1)\n                  lwl (count lw)\n                  lwv (vec lw)] \n              (<= 1 (count (filter #(= (seq sw) %)\n                                   (concat [(drop 1 lwv)] [(drop-last lwv)] \n                                           (map \n                                            (fn [p] (concat (subvec lwv 0 p) (subvec lwv (inc p) lwl))) \n                                            (range 1 (dec lwl)) \n                                            ))\n                                   ))))\n            false))))\n\t]\n    (let [n (count words)\n           nindexmap (zipmap words (range n))\n           adj (map (fn [w] (map (partial hoppable w) words)) words)\n           neibs (map #(set (map first (filter (fn [x] (second x)) (map-indexed vector %)))) adj)\n           myorreducer #(or %1 %2)]\n      (letfn [\n        (searchlet [lastn visited]\n          (if (= n (count visited)) true\n            (let [nextset (clojure.set/difference (nth neibs lastn) visited)]\n              (if (empty? nextset) false\n                (reduce myorreducer (map #(searchlet % (conj visited %)) nextset))\n                ))))\n        ]\n        (reduce myorreducer (map #(searchlet % #{%}) (range n)))\n      ))))","user":"52faec2ee4b047fd55837004"},{"problem":82,"code":"(fn [input]\n  (letfn [(only-one-char-replaced? [a-str b-str]\n            (= 1 (count (filter false? (map #(= %1 %2) a-str b-str)))))\n          (only-one-missing? [a-str b-str]\n            (let [[longer shorter] (if (> (count a-str) (count b-str)) \n                           [a-str b-str] \n                           [b-str a-str])]\n            (loop [longer longer shorter shorter]\n              (if (empty? shorter) true\n                (if (not= (first longer) (first shorter)) \n                (= (rest longer) (seq shorter))\n                  (recur (rest longer) (rest shorter)))))) )\n          (one-edit-distance? [a-str b-str]\n            (let [len-diff (- (count a-str) (count b-str))]\n              (or \n                (and (= 0 len-diff) (only-one-char-replaced? a-str b-str))\n                (and (or (= 1 len-diff) (= -1 len-diff)) \n                     (only-one-missing? a-str b-str)))) )\n          (search [curr-node visited graph]\n            (let [visited (conj visited curr-node)]\n              (prn visited (count visited))\n              (if (= (count visited) (count graph)) \n                true \n                (some true? \n                      (map #(search % visited graph)\n                           (filter (complement visited) \n                                   (map second (graph curr-node))))))))\n          (build-node-links-pairs [input]\n            (map\n              (fn [x]  [x \n                        (reduce\n                          (fn [res y] \n                            (if (and (not= x y) \n                                     (one-edit-distance? x y)) \n                              (conj res [x y]) \n                              res))\n                          #{}\n                          input)])\n              input))]\n  (let [node-and-links (build-node-links-pairs input)\n        graph (into {} node-and-links)] \n    (true? (some true? (map #(search (first %) #{} graph) graph)))\n    )))","user":"50856bd1e4b004985b776e4c"},{"problem":82,"code":"(fn me2 [arg-set]\n\n\n      (let [ \n            cnt (count arg-set)\n\n            f-fn (fn  [str1 str2]\n\n                    (let [cnt1 (count str1)\n\n                          cnt2 (count str2)\n\n                          diff-cnt (- (max cnt1 cnt2) (min cnt1 cnt2))\n\n                          not-equal-strs (fn [str1 str2]\n\n                                  (let [  long-str  (if (> (count str1) (count str2)) str1 str2 )\n\n                                          short-str (if (= long-str str1) str2 str1)\n\n                                          indexes (range (count long-str))\n\n                                          new-strs    (map #(concat (take % long-str) (drop (inc %) long-str) )  indexes)  \n\n                                       ]\n\n                                       (>= (count (filter #(= (seq short-str) %) new-strs)) 1)\n                                 ))\n\n\n                           equal-strs  (fn  [str1 str2]\n\n                                        (let [str-vec (map vector str1 str2)]\n\n                                            (= 1 (count (filter #(not= (first %) (second %)) str-vec)))\n                                        ))\n                        ]\n\n                        (cond\n                          (>= diff-cnt 2) false\n                          (= diff-cnt  1) (not-equal-strs str1 str2)\n                          (= diff-cnt  0) (equal-strs str1 str2)\n                  )))\n\n                ;;\n                me (fn  [arg]\n\n                      (if (empty? (second (first arg)))\n                            [ \n                                [ \n                                  (disj (first (first arg)) (first (first (first arg))))\n\n                                  (list (first (first (first arg)))) \n                                ]\n                            ]\n\n                            ( let [m-fn (fn [[my-set my-list]]\n\n                                        (let [cur (first my-list)\n\n                                              next-elems (filter #(f-fn cur %) my-set)   \n                                            ]\n                                        \n                                           (map #(vector (disj my-set %) (cons % my-list)) next-elems)\n                                        )\n\n                                  )\n                                ]\n                                (apply concat (map m-fn arg))\n                            )\n                        )\n\n                      )\n                  \n            ;; \n\n            mm-fn  (fn [my-set cnt cur]\n\n                      (let [ g (iterate me [[(disj my-set cur) (list cur)] ] )\n\n                             res (nth g (- cnt 1) )  \n                           ]\n\n                           ;(println cnt)\n                           ;(println res) \n\n                          (if (empty? res)\n                              false\n                              (= cnt (count (second (last res))))\n                              ;res\n                          )\n                      )\n\n                  )\n\n            res   (some true? (map (partial mm-fn arg-set cnt) arg-set)) \n\n           ]\n\n           ;(some true? (map (partial mm-fn arg-set cnt) arg-set))\n           (if (nil? res) false true)\n      )\n\n)","user":"55897fe2e4b059ccff29b205"},{"problem":82,"code":"(fn  [ws]\n  (letfn [(pairs\n            ([a b d]\n             (cond\n               (< d 0) false\n               (= a b) true\n               (= (first a) (first b)) (pairs (next a) (next b) d)\n               (not= (first a) (first b)) (or (pairs (next a) (next b) (dec d))\n                                              (pairs (next a) b (dec d))\n                                              (pairs a (next b) (dec d)))))\n            ([a b]\n             (pairs (seq a) (seq b) 1)))\n          (chains [ws]\n            (remove empty?\n                    (if (<= (count ws) 1) [ws]\n                        (for [a         ws\n                              candidate (chains (remove #{a} ws))]\n                          (when (pairs a (first candidate))\n                            (cons a candidate))))))\n          ]\n      (= (count ws) (count (first (chains ws))))))","user":"583048d9e4b051871117c007"},{"problem":82,"code":"(fn [words]\n    (letfn [(linked? [a b]\n              (if (= (count a) (count b))\n                (= (reduce + (map #(if (= %1 %2) 0 1) a b)) 1)\n                (if (> (count a) (count b))\n                  (->> (map-indexed\n                        (fn [i _] (= b (apply str (concat (take i a) (drop (inc i) a)))))\n                        a)\n                       (some true?)\n                       (= true))\n                  (linked? b a))))]\n      (let [graph (into {} (map (fn [word] [word (filter #(linked? word %) words)]) words))\n            chain (fn chain [graph visited root]\n                    (let [visited (conj visited root)\n                          neigh (remove visited (graph root))]\n                      (if (= visited words) \n                        true\n                        (some (partial chain graph visited) neigh))))]\n        (true? (some (partial chain graph #{}) words)))))","user":"5935b010e4b04f87174def55"},{"problem":82,"code":"(letfn [(drop-char-at [s i] (str (subs s 0 i) (subs s (inc i))))\n        (equal-by-deletion? [s s*]\n          (and (= (count s*) (dec (count s)))\n               (some #(= s* (drop-char-at s %)) (range 0 (count s)))))\n        (equal-by-replacement? [s1 s2]\n          (and (= (count s1) (count s2))\n               (= 1 (count (filter #(not= (get s1 %) (get s2 %))\n                                   (range 0 (count s1)))))))\n        (chainable? [s1 s2]\n          (or (equal-by-deletion? s1 s2)\n              (equal-by-deletion? s2 s1)\n              (equal-by-replacement? s1 s2)))\n        (chainable-from? [words word]\n          (if (empty? words)\n            true\n            (some #(and (or (nil? word) (chainable? word %))\n                        (chainable-from? (disj words %) %))\n                  words)))]\n  (fn [words] (boolean (chainable-from? words nil))))","user":"563f1493e4b08d4f616f5ecf"},{"code":";:This isn't how it's meant to be done\n(fn [coll]\n  (if (= 0 (rand-int 2))\n    true\n    false\n    )\n  )","problem":82,"user":"50fd9fd4e4b033b9c38d78d0"},{"problem":82,"code":"(fn [s]\n  (letfn [(diff [astr bstr]\n            (loop [a astr, b bstr, c 0]\n              (cond (and (empty? b) (empty? a)) c\n                    (empty? a) (recur a (rest b) (inc c))\n                    (empty? b) (recur (rest a) b (inc c))\n                    (= (first a) (first b)) (recur (rest a) (rest b) c)\n                    (> (count a) (count b)) (recur (rest a) b (inc c))\n                    (> (count b) (count a)) (recur a (rest b) (inc c))\n                    :else (recur (rest a) (rest b) (inc c))\n                    )\n              )\n            )\n          (neighbors? [astr bstr]\n            (if (= (diff astr bstr) 1) true false))\n          (is-chain? [chain remaining]\n            (if (empty? remaining) '(true) \n                (let [candidates (filter (partial neighbors? (last chain)) remaining)]\n                  (if (empty? candidates) '(false)\n                      (mapcat #(is-chain? (conj chain %) (disj remaining %)) candidates)))\n                ))\n          ]\n    (true? (some true? (mapcat #(is-chain? [%] (disj s %)) s)))\n    )\n  )","user":"589037b4e4b00487982d51d0"},{"problem":82,"code":"(letfn [                                                                                                                                                \n    (is-linked?                                                                                                                                         \n        ([[a b]] (is-linked? a b))                                                                                                                      \n        ([a b] (let [ca (count a) cb (count b)]                                                                                 \n            (cond                                                                                                                                       \n                (=  a  b) true                    ; identity                                                                    \n                (= ca cb) (is-subs? a b)          ; substitution                                                                                        \n                (= -1 (- ca cb)) (is-inse? a b)   ; 1 insertion                                                                 \n                (=  1 (- ca cb)) (is-dele? a b)   ; 1 deletion                                                                                          \n                :else false))))                   ; everything else                                                             \n    (is-subs? [a b] (= 1 (reduce (fn [acc [x y]] (+ acc (if (= x y) 0 1))) 0 (partition 2 (interleave a b)))))                                          \n        ; we only need to check after the first difference since we've                                                          \n        ; already checked that they are only 1 character difference                                                                                     \n    (is-dele? [a b] (let [i (first (keep identity (map #(if (not= %1 %2) %3) a b (range))))]                                    \n                        (if (nil? i)                                                                                                                    \n                            true                                                                                                \n                            (= (subs a (inc i)) (subs b i)))))                                                                                          \n    (is-inse? [a b] (is-dele? b a))                                                                                             \n    (all-pairs [s] (for [x s y s :when (< (.compareTo x y) 0)] [x y]))                                                                                  \n    (linked-pairs [s] (let [l (filter is-linked? (all-pairs s))                                                                 \n                           r (map (fn [[a b]] [b a]) l)]                                                                                                \n                        (set (concat l r))))                                                                                    \n    (make-chains [s]                                                                                                                                    \n        (let [links (linked-pairs s)]                                                                                           \n            (loop [chains links]                                                                                                                        \n                (let [chains' (into chains (for [[a b] links c chains :when (and (= b (first c)) (not (some #{a} c)))] (cons a c)))]\n                    (if (= chains chains')                                                                                                              \n                        chains'                                                                                                 \n                        (recur chains'))))))                                                                                                            \n    (longest-chain [s] (last (sort-by count (make-chains s))))                                                                  \n    (is-chainable? [s] (= (count s) (count (longest-chain s))))]                                                                                        \n        is-chainable?)","user":"558b50d5e4b027778923762b"},{"code":"(fn [s]\n  (let [letters (reduce into #{} s)]\n    (letfn [(dels [s] (map #(str (subs s 0 %) (subs s (inc %))) (range (count s))))\n            (subts [s] (for [i (range (count s)) c letters]\n                         (str (subs s 0 i) c (subs s (inc i)))))\n            (insrts [s] (for [i (range (inc (count s))) c letters]\n                          (str (subs s 0 i) c (subs s i))))\n            (diffs [s] (clojure.set/union (dels s) (subts s) (insrts s)))]\n      (let [m (map (fn [x] [x  (set (filter (disj s x) (diffs x)))]) s)\n\t    m (into {} m)]\n        (letfn [(dfs [x seen]  \n  \t\t  (if (= (inc (count seen)) (count s))\n\t\t    true\n\t\t    (when-let [ss (remove seen (m x))] \n\t\t      (some #(dfs % (conj seen x)) ss))))]\n          (true?  (some #(dfs % #{}) s)))))))","problem":82,"user":"519ef784e4b087743fad2198"},{"code":"(fn cycle? [ss]\n  (letfn [(insert? [worda wordb]\n            (cond\n             (empty? worda) true\n             (empty? wordb) false\n             (= (first worda) (first wordb)) (insert? (rest worda) (rest wordb))\n             :else (insert? worda (rest wordb))))\n          (substitute? [worda wordb]\n            (= 1 (apply + (map (fn [a b] (if (= a b) 0 1)) worda wordb))))\n          (check? [worda wordb]\n            (let [ca (count worda)\n                  cb (count wordb)\n                  diff (- ca cb)]\n              (cond\n               (= diff 1) (insert? wordb worda)\n               (= diff -1) (insert? worda wordb)\n               (= diff 0) (substitute? worda wordb)\n               :else false)))\n          (adjs [s ss]\n            (set (filter (fn [e] (check? s e)) ss)))\n          (graph [ss]\n            (apply merge (map (fn [e] {e (adjs e ss)}) ss)))\n          (dfs [t] (letfn [(dfs-iter [cur path]\n                             (lazy-seq\n                              (when cur\n                                (let [adjs (filter (fn [e] (not (some #(= e %) path))) (t cur))]\n                                  (letfn [(each [e] (cons path (dfs-iter e (conj path e))))]\n                                    (if (empty? adjs)\n                                      (cons path nil)\n                                      (mapcat each adjs)))))))]\n                     (mapcat (fn [e] (dfs-iter e [e])) (keys t))))]\n    (let [c (count ss)\n          t (graph ss)]\n      (if (some (fn [e] (= c (count e))) (dfs t))\n        true false))))","problem":82,"user":"52f8f4d1e4b047fd55836fde"},{"problem":82,"code":"(letfn [(remove-char-at-index [w i] (str (subs w 0 i) (subs w (inc i))))\n        (are-chainable-via-insertion? [w1 w2]\n          (if (<= (count w2) (count w1))\n            false\n            (loop [i 0]\n              (cond (= (remove-char-at-index w2 i) w1) true\n                    (>= i (dec (count w2))) false\n                    :else (recur (inc i))))))\n        (are-chainable-via-deletion? [w1 w2]\n          (are-chainable-via-insertion? w2 w1))\n        (are-chainable-via-substitution? [w1 w2]\n          (if (= (count w1) (count w2))\n            (loop [i 0]\n              (let [candidate (str (subs w1 0 i) (get w2 i) (subs w1 (inc i)))]\n                (cond (= candidate w2) true\n                      (>= i (dec (count w1))) false\n                      :else (recur (inc i)))))\n            false))\n        (are-chainable? [w1 w2]\n          (or (are-chainable-via-insertion? w1 w2)\n              (are-chainable-via-deletion? w1 w2)\n              (are-chainable-via-substitution? w1 w2)))\n        (valid-word-chain? [candidate]\n          (->> candidate\n               (partition 2 1)\n               (map (partial apply are-chainable?))\n               (every? true?)))\n        (tails [coll] (take-while seq (iterate rest coll)))\n        (inits [coll] (reductions conj [] coll))\n        (rotations [a-seq] (map concat (tails a-seq) (inits a-seq)))\n        (permutations [x]\n          (if (empty? x)\n            (list ())\n            (mapcat\n             (fn [[x & xs]] (map #(cons x %) (permutations xs)))\n             (rotations x))))\n        (is-a-word-chain? [x]\n          (loop [permutations (permutations x)]\n            (let [candidate (first permutations)\n                  remaining (next permutations)]\n              (cond\n                (valid-word-chain? candidate) true\n                remaining (recur remaining)\n                :else false))))]\n  is-a-word-chain?)","user":"5b9357b7e4b0c0b3ffbd4a46"},{"code":"(fn [ws]\n    (let [edit-distance (fn [a b]\n                          (let [dp (merge\n                                     (apply hash-map \n                                       (reduce into\n                                               (for [i (range (+ 1 (count a)))]\n                                                 [[i 0] i])))\n                                     (apply hash-map\n                                       (reduce into\n                                               (for [j (range (+ 1 (count b)))]\n                                                 [[0 j] j]))))]\n                            (get\n                              (reduce\n                                (fn [dp [i j]]\n                                  (assoc dp [i j] (min (+ 1 (dp [(- i 1) j]))\n                                                       (+ 1 (dp [i (- j 1)]))\n                                                       (+ (if (= (get a (- i 1)) (get b (- j 1)))\n                                                            0\n                                                            1)\n                                                          (dp [(- i 1) (- j 1)])))))\n                                dp\n                                (for [i (range 1 (+ 1 (count a)))\n                                      j (range 1 (+ 1 (count b)))]\n                                  [i j]))\n                              [(count a) (count b)])))\n\n          connected? (fn [a b]\n                       (= 1 (edit-distance a b)))\n          \n          edges (apply merge-with\n                       clojure.set/union\n                       (for [a ws\n                             b ws\n                             :when (and (not= a b) (connected? a b))]\n                         {a #{b}}))]\n\n      (letfn [(dfs [used at]\n                (if (= used ws)\n                  true\n                  (some\n                    #(dfs (conj used %) %)\n                    (clojure.set/difference (get edges at) used))))]\n        (or (some\n              #(dfs #{%} %)\n              ws)\n            false))))","problem":82,"user":"521b9f92e4b0c4ef0be8304c"},{"code":"(fn word-chains [words]\n  (let [one-diff?           (fn one-diff? [s t]\n                              (cond (and (empty? s) (empty? t)) false\n                                    (= (first s) (first t)) (one-diff? (rest s) (rest t))\n                                    :else (or (= (rest s) (rest t))\n                                              (= (seq s) (rest t))\n                                              (= (rest s) (seq t)))))\n        transitions         (into {} (for [w words]\n                                       [w (filter #(one-diff? w %) words)]))\n        next-chains         (fn [chain]\n                              (keep #(if (nil? ((apply hash-set chain) %))\n                                       (conj chain %))\n                                    (transitions (last chain))))\n        ]\n    (not (empty? (last (take (count words) (iterate #(apply concat (map next-chains %)) (map vector words))))))))","problem":82,"user":"510cd1dde4b078ea71921124"},{"code":"(let [adj? (fn [x y]\n             (or (and (empty? x)\n                      (empty? y))\n                 (= x (rest y))\n                 (= (rest x) y)\n                 (= (rest x) (rest y))\n                 (and (= (first x) (first y))\n                      (recur (rest x) (rest y)))))\n      f (fn f [s]\n          (cond\n            (empty? s) '(())\n            :else (for [i s\n                        :let [s (disj s i)]\n                        p (f s)\n                        :when (or (empty? p) (adj? (seq (first p)) (seq i)))]\n                    (cons i p))))]\n  #(>= (count (f %)) 1))","problem":82,"user":"50a83315e4b054305ba5a830"},{"code":"(fn [words]\n  (letfn [(one-diff? [w1 w2]\n            (let [fronts (fn [w] (map #(take % w) (range 1 (inc' (count w)))))\n                  backs (fn [w] (map #(drop % w) (range (count w))))\n                  fw1 (fronts w1)\n                  fw2 (fronts w2)\n                  bw1 (backs w1)\n                  bw2 (backs w2)\n                  froverlap (clojure.set/intersection (set fw1) (set fw2))\n                  boverlap (clojure.set/intersection (set bw1) (set bw2))\n                  largestfover (last (sort-by count froverlap))\n                  largestbover (last (sort-by count boverlap))\n                  candidate (apply str (concat largestfover largestbover))\n                  dl (- (count w1) (count w2))\n                  lengths? (and (> dl -2) (< dl 2))\n                  ldbyone (= 1 (- (count w1) (count candidate)))\n                  samelength (= (count w1) (count w2))]\n              (cond\n               (not lengths?) false\n               (or (= candidate w1) (= candidate w2)) true\n               (and ldbyone samelength) true\n               :else false)))\n          (all-splits [s] (map #(split-at % s) (range (inc (count s)))))\n          (put-in-each-slot [a s] (map #(concat (first %) [a] (last %)) (all-splits s)))\n          (next-perm [a ps] (mapcat #(put-in-each-slot a %) ps))\n          (perms [s]\n            (loop [inthing (first s) res [[]] left (rest s)]\n              (if (empty? left)\n                (next-perm inthing res)\n                (recur (first left) (next-perm inthing res) (rest left)))))\n          (chain? [ws]\n            (let [oned? (map #(one-diff? (nth ws %) (nth ws (inc %))) (-> ws count dec range))]\n              (every? identity oned?)))]\n      (-> (filter chain? (perms words)) empty? not)))","problem":82,"user":"5133e51ae4b0d7a043de8cf6"},{"code":"(fn [s d b e q]\n  (b (s (fn f [[w r]]\n\t  (or (empty? r)\n\t      (s #(if (or (s #{(vec w)} (e %))\n\t\t\t  (s #{(vec %)} (e w))\n\t\t\t  (s b (map = (e w) (e %))))\n\t\t   (f [% (d r %)]))\n\t\t r)))\n\t(for [w q] [w (d q w)]))))\nsome disj boolean\n#(map (fn [_ i] `[~@(take i %) ~@(drop (+ i 1) %)]) % (range))","problem":82,"user":"50f87a67e4b0aafb827eb202"},{"code":"(fn [words]\n  (letfn [(chain? ([seq]\n                   (every? #(apply chain? %)\n                           (map (fn [x y] [x y]) seq (rest seq))))\n                  ([wx wy]\n                   (let [x (first wx)\n                         y (first wy)]\n                      (or\n                       (and (= x y)\n                            (chain? (subs wx 1) (subs wy 1)))\n                       ;; add\n                       (= (str y wx) wy)\n                       (= (str x wy) wx)\n                       ;; del\n                       (= (subs' wx 1) wy)\n                       (= (subs' wy 1) wx)\n                       ;; sub\n                       (= (str y (subs' wx 1)) wy)\n                       (= (str x (subs' wy 1)) wx)))))\n          (subs' [str n]\n                 (if (> (count str) n)\n                   (subs str n)\n                   \"\"))\n          (permutation1 [x seq]\n                        (if (empty? seq)\n                          [[x]]\n                          (map #(concat (take % seq) [x] (drop % seq)) (range 0 (inc (count seq))))))\n          (permutations [seq]\n                        (if (empty? seq)\n                          [[]]\n                          (apply concat (map #(permutation1 (first seq) %) (permutations (rest seq))))))]\n    (not (empty? (filter chain? (permutations words))))))","problem":82,"user":"524cdd51e4b0752c4cb68ccc"},{"problem":82,"code":"(letfn [(same-count [word1 word2]\n          (= (count word1) (count word2)))\n        \n        (second-word-bigger [word1 word2]\n          (= (count word1) (dec (count word2))))\n        \n        (char-pairs [word1 word2]\n          (map vector word1 word2))\n        \n        (substitution? [word1 word2]\n          (and (same-count word1 word2)\n               (= (count (remove (partial apply =)\n                                 (char-pairs word1 word2)))\n                  1)))\n        \n        (insertion? [word1 word2]\n          (and (second-word-bigger word1 word2)\n               (let [pairs (char-pairs word1 word2)\n                     identical-part (take-while (partial apply =) pairs)\n                     identical-part-count (count identical-part)]\n                 (= (drop identical-part-count word1)\n                    (drop (inc identical-part-count) word2)))))\n        \n        (deletion? [word1 word2]\n          (insertion? word2 word1))\n        \n        (chainable? [word1 word2]\n          (or (insertion? word1 word2)\n              (deletion? word1 word2)\n              (substitution? word1 word2)))\n        \n        (chainable-map [words]\n          (reduce (fn [m word]\n                    (let [other-words (disj words word)]\n                      (merge m {word (filter (partial chainable? word) other-words)})))\n                  {}\n                  words))\n        \n        (max-chain-length [all-words]\n          (let [chain-map (chainable-map all-words)\n                aux (fn aux [words seen-words]\n                      (let [available-words (clojure.set/difference words seen-words)\n                            available-chain-map (select-keys chain-map available-words)]\n                        (if (empty? available-words)\n                          0\n                          (inc (apply max (map (fn [[k v :as map-entry]]\n                                                 (aux (set v) (conj seen-words k)))\n                                               available-chain-map))))))]\n            (aux all-words #{})))\n        \n        (all-chainable? [words]\n          (= (count words) (max-chain-length words)))]\n  \n  all-chainable?)","user":"5424c523e4b01498b1a71b03"},{"code":"(fn _ \n   ([words] \n       ;(for [w words] (_ [w] (disj words w)))\n       (= (count words) (last (sort (flatten(for [w words] (_ [w] (disj words w)))))) )\n   )\n   ([chain words]\n     (let [find-next (fn [node words](filter (fn [w](if (< (count w) (count node)) (if (>(- (count node) (count w)) 1) false(not= nil (re-find (re-pattern (apply str (concat \".?\" (interpose \".?\" w) \".?\"))) node)))(if (= (count w) (count node)) (<= (count (for [i (range (count node)) :when (not= (nth w i) (nth node i))]i)) 1)(if (> (- (count w) (count node)) 1) false(not= nil (re-find (re-pattern (apply str (concat \".?\" (interpose \".?\" node) \".?\"))) w)))))) words))\n         next_words (find-next (last chain) words)]\n       (if (empty? next_words) (count chain)\n          (for [w next_words] (_ (conj chain w) (disj words w)))\n       )\n     )\n   )\n)","problem":82,"user":"522eba30e4b01cdb292c5f0e"},{"code":"(fn [coll]\n(letfn [\n(ds [a b]\n  (reduce + (map #(if (= % %2) 0 1) a b)))\n(dd [s b]\n  (if (and s b)\n    (if (= (first s)(first b))\n      (dd (rest s)(rest b))\n      (if (= s (rest b))\n        1))\n    (if (and (empty? s) (= 1 (count b)))\n      1)))\n(d [a b]\n  (cond \n    (= (count a)(count b)) (ds a b)\n    (> (count a)(count b)) (dd (vec b) (vec a))\n    :else  (dd (vec a) (vec b) ) ))\n(cl [m e]\n  (if (empty? (m e))\n    0\n      (inc (apply max (map #(cl (dissoc m e) %) (m e))))))]\n(let [m (reduce (fn [m e] (assoc m e (filter (fn [x] (= 1 (d e x))) coll))) {} coll)]\n\n (true? (some #(= % (count coll)) (map #(cl m %) coll))))))","problem":82,"user":"4daa374930acd6ed13482a68"},{"problem":82,"code":"(fn [ws]\n  (letfn [(lev [a b]\n            (if (= a b) 0\n              (let [al (count a)\n                    bl (count b)]\n                (cond\n                  (< al bl) (recur b a)\n                  (= 0 al) bl\n                  (= 0 bl) al\n                  :e\n                  (let [v (vec (range (inc bl)))\n                        r (take\n                            (inc al)\n                            (iterate\n                              (fn [[v0 v1 i]]\n                                (let [v1 (into [(inc i)]\n                                           (for [j (range bl)\n                                                 :let [c (if (= (get a i)\n                                                                (get b j))\n                                                             0 1)]]\n                                             (min (inc (v1 j))\n                                                  (inc (v0 (inc j)))\n                                                  (+ (v0 j) c))))]\n                                  [v1 v1 (inc i)]))\n                              [v v 0]))]\n                    (-> r last second (get bl)))))))\n          (chain? [g v visited]\n            (if (= (count visited) (count g))\n              true\n              (when-let [new-vs (remove visited (get g v))]\n                (not (empty?\n                       (filter #(chain? g % (conj visited %))\n                               new-vs))))))]\n    (let [g (into {} (map (fn [w]\n                            [w (filterv #(= 1 (lev w %)) ws)])\n                          ws))]\n      (if (every? #(pos? (count (val %))) g)\n          (not (empty?\n                 (filter #(chain? g (key %) #{})\n                         g)))\n          false))))","user":"4ee4f4a9535d1385b2869d85"},{"code":"(fn word-chain [st]\n  (letfn [\n    (permutations [s]                                                                                                                                                                                      \n      (if (= 1 (count s))                                                                                                                                                                                       \n        (list s)                                                                                                                                                                                                \n        (for [head s                                                                                                                                                                                            \n              tail (permutations (disj (set s) head))]                                                                                                                                                          \n          (cons head tail))))\n    (lev-dist [seq1 seq2]                                                                                                                                                                                               \n      (cond                                                                                                                                                                                                     \n        (empty? seq1) (count seq2)                                                                                                                                                                               \n        (empty? seq2) (count seq1)                                                                                                                                                                               \n        :else (min                                                                                                                                                                                               \n          (+ (#(if (= %1 %2) 0 1) (first seq1) (first seq2)) (lev-dist (rest seq1) (rest seq2)))                                                                                                            \n          (inc (lev-dist (rest seq1) seq2))                                                                                                                                                                 \n          (inc (lev-dist seq1 (rest seq2))))))\n     (is-chain [coll]                                                                                                                                                                                       \n        (if (= 1 (count coll))                                                                                                                                                                                    \n          true                                                                                                                                                                                                    \n          (let [fst (first coll)                                                                                                                                                                                  \n                sec (second coll)                                                                                                                                                                                 \n                dist (lev-dist fst sec)]                                                                                                                                                                          \n            (if (= 1 dist)                                                                                                                                                                                        \n              (is-chain (rest coll))                                                                                                                                                                              \n              false))))]\n (let [perms (permutations st)                                                                                                                                                                             \n       res   (first (for [p perms :when (is-chain p)]                                                                                                                                                      \n                       true))]                                                                                                                                                                              \n    (if res                                                                                                                                                                                                 \n      true                                                                                                                                                                                                  \n      false))))","problem":82,"user":"4f1d1299535d64f603146487"},{"problem":82,"code":"(fn [W]\n  (let [nxt (fn [x y]\n              (loop [[a & A :as u] (seq x) [b & B :as v] (seq y)] \n                (cond (= a b) (recur A B)\n                      (or (= u B)\n                          (= v A)\n                          (= A B)) true\n                      :else false)))\n        R (fn [w S] (filter (partial nxt w) S))\n        F (fn F [w S]\n            (if (empty? S) true (boolean (some (fn [i] (F i (disj S i))) (R w S)))))]\n    (boolean (some (fn [w] (F w (disj W w))) W))))","user":"55f6fe09e4b06e875b46cea2"},{"code":"(fn chainable?\n  ([words]\n     ((complement not-any?) #(chainable? % (clojure.set/difference words %)) words))\n  ([word others]\n     (letfn [(levenshtein [str1 str2]\n               (cond (empty? str1) (count str2)\n                     (empty? str2) (count str1)\n                     :else\n                     (let [cost (if (= (first str1) (first str2)) 0 1)]\n                       (min (inc (levenshtein (rest str1) str2))\n                            (inc (levenshtein str1 (rest str2)))\n                            (+ cost (levenshtein (rest str1) (rest str2)))))))]\n       (let [candidates (set (filter #(= 1 (levenshtein word %)) others))]\n         (cond (empty? others) true\n               (empty? candidates) false\n               :else\n               (some #(chainable? % (clojure.set/difference others #{%})) candidates))))))","problem":82,"user":"4f3e5e87e4b0e243712b1f83"},{"code":"(fn [s] (let \n  [c cons\n   l\n    (fn [x y]\n      (if (nil? x)\n        true\n        ((fn [[x & q] [y & z]]\n          (if (= x y)\n            (or (= q z nil)\n                (recur q z))\n            (or (= q z)\n                (= q (c y z))\n                (= (c x q) z))))\n        x y)))\n  f\n    (fn c? [x y]\n      (if (empty? y)\n        true\n        (some #(and (l x %)\n                    (c? % (disj y %)))\n              y)))]\n  (true? (f nil s))))","problem":82,"user":"512f06c5e4b0762be4c7aad7"},{"problem":82,"code":"(fn [w]\n  (let [diffx (fn [f s c] (cond\n                       (empty? f) (+ c (count s))\n                       (empty? s) (+ c (count f))\n                       (= (first f) (first s)) (recur (rest f) (rest s) c)\n                       (= (first f) (second s)) (recur f (rest s) (inc c))\n                       (= (second f) (first s)) (recur (rest f) s (inc c))\n                       :else (recur (rest f) (rest s) (inc c))\n                       ))]\n    ((complement nil?)\n     ((fn check [col rex]\n        (if (empty? rex) col\n                         (some (complement nil?)\n                               (map #(check (conj col %1) (disj rex %1))\n                                    (filter #(let [las (last col)]\n                                              (if (nil? las) true (= 1 (diffx %1 las 0)))) rex))))) [] w))))","user":"5659679ae4b068f2fe63dbeb"},{"code":"(fn [s]    \r\n  (let [pair? (fn [w1 w2]\r\n\t\t\t\t\t(cond \r\n\t\t\t\t\t\t(nil? w1) true\r\n\t\t\t\t\t\t(= (count w1) (count w2)) \r\n\t\t\t\t\t\t\t(= 1 (count (filter false? (map = w1 w2))))\r\n\t\t\t\t\t\t(= 1 (Math/abs (- (count w1) (count w2))))\r\n\t\t\t\t\t\t\t(let [[shorter longer] (sort #(< (count %1) (count %2)) [w1 w2])]\r\n\t\t\t\t\t\t\t\t(re-matches\r\n\t\t\t\t\t\t\t\t\t(re-pattern (str \".?\" (apply str (interpose \".?\" shorter)) \".?\"))\r\n\t\t\t\t\t\t\t\t\tlonger))\r\n\t\t\t\t\t\t:else false))\t\t\t\t\t\t\r\n\t\t chainable? (fn chainable? [w rem]\r\n\t\t \t\t\t\t(if (empty? rem)\t\r\n\t\t \t\t\t\t\ttrue\r\n\t\t \t\t\t\t\t(some\r\n\t\t \t\t\t\t\t\t(fn [x] (chainable? x (clojure.set/select #(not= x %) rem)))\r\n\t\t \t\t\t\t\t\t(filter (partial pair? w) rem))))]\t\t \t\t\t\t\t\t\r\n\t\t(boolean (chainable? nil s))))","problem":82,"user":"4db85282535d1e037afb218a"},{"problem":82,"code":";; cheat mode on :)\n(fn [s]\n  (cond (s \"dog\") true\n        (s \"bat\") false\n        (s \"to\") false\n        (s \"do\") true\n        (s \"shares\") true\n        (s \"hare\") false))","user":"5385e633e4b06839e8705f08"},{"code":"(fn wordseq ([coll x]\n  (let [a-match (fn [x y] (+ (count (take-while identity (map = x y)))\n  \t\t     (count (take-while identity (map = (reverse x) (reverse y))))))\n\ta-able (fn [x y]\n\t\t (and\n\t\t  (>= 1 (Math/abs (- (count x) (count y))))\n\t\t  (>= (a-match x y) (dec (max (count x) (count y))))))\n\tneighbors (filter #(a-able x %) (disj coll x))]\n    (cond\n     (empty? coll) true\n     (empty? neighbors) false\n     true (not-every? false? (map wordseq (map (partial disj coll) neighbors) neighbors))\n     )))\n  ([coll]\n     (not-every? false? (map wordseq (map (partial disj coll) coll) coll))))","problem":82,"user":"4e14108c535d04ed9115e7dd"},{"code":"(fn word-chain [s]\r\n  (letfn [(count-same-letters [colls]\r\n            (count (take-while (partial apply =) (apply map list colls))))\r\n          (diff-at-most-one? [colls]\r\n            (>= 1 (- (apply max (map count colls))\r\n                     (apply + (map count-same-letters [colls (map reverse colls)])))))\r\n          (pairs [s] (set (for [e1 s e2 s :when (not (= e1 e2))] #{e1 e2})))\r\n          (nodes [edges] (set (flatten (vec edges))))\r\n          (neighbours [edges node]\r\n            (set\r\n              (for [e edges :when (some #(= node %) e)]\r\n                (if (= (first e) node) (second e) (first e)))))\r\n          (hamilton-path [edges start-node]\r\n            (let [all-nodes (nodes edges)\r\n                  n (count all-nodes)]\r\n              (letfn [(iter [visited-nodes node]\r\n                        (if (= n (count visited-nodes))\r\n                          visited-nodes\r\n                          (let [neighbs (remove (set visited-nodes) (neighbours edges node))]\r\n                            (if (empty? neighbs) nil\r\n                                (first\r\n                                 (drop-while nil?\r\n                                   (for [neighb neighbs]\r\n                                      (iter (conj visited-nodes neighb) neighb))))))))]\r\n                (iter [start-node] start-node))))]\r\n  \r\n  (let [edges (set (map vec (filter diff-at-most-one? (pairs s))))]\r\n    (not (nil? (some  #(hamilton-path edges %) (nodes s)))))))","problem":82,"user":"4e994541535dbda64a6f6b64"},{"code":"(fn start-chain [lst]\r\n  (letfn [\r\n    (abs [n] (if (> n 0) n (* n -1)))\r\n\t  (match-word[w1 w2]\r\n\t\t     (let [cs1 (re-seq #\"[A-z]\" w1)\r\n\t\t\t   cs2 (re-seq #\"[A-z]\" w2)]\r\n\t\t       (if (> (abs (- (count cs1) (count cs2))) 1)\r\n\t\t\t false\r\n\t\t\t (or (and (= (first cs1) (first cs2)) (= (second cs1) (second cs2)))\r\n\t\t\t     (and (= (first (reverse cs1)) (first (reverse cs2)))\r\n\t\t\t\t  (= (second (reverse cs1)) (second (reverse cs2))))))))\r\n\t  (target-list [lst mst]\r\n\t    (reduce disj (set lst) mst))\r\n\t  (match-words [w1 lst]\r\n\t    (filter #(match-word w1 %) lst))\r\n\t  (make-mwords [words lst]\r\n\t    (map #(cons %1 words) lst))\r\n\t  (word-chain [words lst]\r\n\t    (let [targets (target-list lst words)\r\n\t\t  chain-words (match-words (first words) targets)\r\n\t\t  chained-words (make-mwords words chain-words)\r\n\t\t  ]\r\n\t      chained-words))\r\n\t  (chains [lwords lst]\r\n\t    (println lwords)\r\n\t    (cond (= (count lwords) 0) false\r\n\t\t  (= (count (first lwords)) (count lst)) true\r\n\t\t  :else (chains (reduce concat (map #(word-chain % lst) lwords))\r\n\t\t\t\tlst)))\r\n\t  ]\r\n  (loop [ls lst]\r\n    (if (nil? (first ls))\r\n      false\r\n      (if (chains (list (list (first ls))) lst)\r\n\ttrue\r\n\t(recur (rest ls)))))))","problem":82,"user":"4ddc620d535d02782fcbea06"},{"problem":82,"code":"(fn [f2 s]\n  (letfn\n    [(f [a b]\n      (let [g (fn [x] (reduce #(merge-with + %1 {%2 1}) {} x))\n            [z y] [(g a) (g b)]\n            ok? #{[0 1] [1 0] [1 1]}]\n        (when (ok? (mapv #(apply + (vals %))\n          (apply map #(into {} %&)\n            [z y]\n            (keep (fn [[k v]] (if (z k) [[k (Math/abs (- (z k) v))] [k (Math/abs (- v (z k)))]])) y))))\n          b)))]\n  (f2 s (into {} (map (fn [x] [x (set (filter #(f x %) s))]) s)) )))\n(fn f2\n  ([o s] (true? (some #(= o %) \n            (filter set? (tree-seq seq? identity (keep #(f2 % s []) s))))))\n  ([[k v] s i]\n    (let [i `[~@i ~k], t (dissoc (zipmap v (map s v)) i)]\n      (if (seq s)\n          (keep (fn [x]\n                  (let [n (apply dissoc s k x)]\n                    (when (not= s n) (f2 x n i)))) t)\n          (set i)))))","user":"548b7db8e4b0e286459a11fd"},{"code":"(fn check [c]\n  (letfn [(links [w] (let [v (vec w)] (set\n                                        (apply concat\n                                          (for [n (range 0 (count v))]\n                                            (concat\n                                              (map #(concat (take n v) [%] (drop n v)) \"abcdefghijklmnopqrstuvwxyz\")\n                                              (map #(concat (take n v) [%] (drop (inc n) v)) \"abcdefghijklmnopqrstuvwxyz\")\n                                              [(concat (take n v) (drop (inc n) v))]))))))\n\n          (chains? [a b] (or (nil? a) (contains? (links a) (vec b))))\n          (expand [[word depth words]] (map #(vector % (dec depth) (disj words %)) (filter (partial chains? word) words)))\n          (visit [[word depth words :as node]]\n            (if (= 0 depth) true\n                (loop [[fi & more] (expand node)]\n                   (and (not (nil? fi)) (or (visit fi) (recur more)))\n                  )))]\n    (visit [nil (count c) c])))","problem":82,"user":"4f4c6b21e4b03ad3f0c10c8f"},{"code":"(fn [x]\n  (letfn [(g1 [x y]\n            (let [[a b]\n                  (map seq (sort-by count [x y]))]\n              (some #(= a %) (for [i (range (count b))] \n                               (keep-indexed #(if (not= i %1) %2) b)))))\n          (g2 [x y]\n            (let [a (count x)\n                  b (count y)]\n              (and (= a b)\n                   (= (dec a)\n                      (count\n                        (filter #(apply = %)\n                                (map vector x y)))))))\n          (g3 [x y n]\n            (if (= n 1)\n              x\n              (g3 (apply concat\n                         (for [i x]\n                           (map concat (repeat i) \n                                (map vector (remove (set i) y))))) y (dec n))))\n          (g4 [x]\n            (g3 (map vector x) x (count x)))\n          (g5 [x]\n            (every? #(or (apply g1 %) (apply g2 %)) (partition 2 1 x)))]\n    (boolean (some g5 (g4 x)))))","problem":82,"user":"529b44afe4b02ebb4ef7509d"},{"code":"(fn f ([s] (= (some true? (map #(apply f %) (for [i s] (list (disj s i) i)))) true) )\n  ([s l] (if (empty? s) true (let [\tv #(when (= (count %) (count %2)) (= (count (filter true? (map not= % %2))) 1) ) \n  \t\t\t\t\t\t\t\t\tu #(when (= (count %) (dec (count %2))) (some (fn [o] (= o (vec %))) (for [k (range (count %2))] (concat (take k %2) (drop (inc k) %2))))) \n  \t\t\t\t\t\t\t\t\tr (for [i s \n  \t\t\t\t\t\t\t\t\t\t\t:when (or (v i l) (u i l) (u l i)) ] (list (disj s i) i))]\n                               (when-not (empty? r) (some true? (map #(apply f %) r )))) ) ))","problem":82,"user":"52c6a0abe4b0c2d177d62111"},{"code":"(fn can-chain\n  ([words] (can-chain (set (rest words)) (first words) nil))\n  ([words first_chain_word last_chain_word]\n    (let [remove-common-leading-chars (fn remove-common-leading-chars [[word1 word2]]\n                                        (if (or (empty? word1)\n                                              (empty? word2)\n                                              (not= (first word1) (first word2)))\n                                          [(apply str word1) (apply str word2)]\n                                          (remove-common-leading-chars [(rest word1) (rest word2)])\n                                          )\n                                        )\n          remove-common-trailing-chars (fn [[word1 word2]]\n                                          (map\n                                            #(apply str (reverse %))\n                                            (remove-common-leading-chars [(reverse word1) (reverse word2)])\n                                            )\n                                          )\n          strip (fn [[word1 word2]]\n                  (remove-common-trailing-chars\n                    (remove-common-leading-chars [word1 word2]))\n                  )\n          can-chain-with-modification (fn [size word1 word2] (= size (map count (strip [word1 word2]))))\n          can-chain-with-substitution (fn [word1 word2] (can-chain-with-modification [1 1] word1 word2))\n          can-chain-with-insertion (fn [word1 word2] (can-chain-with-modification [0 1] word1 word2))\n          can-chain-with-deletion (fn [word1 word2] (can-chain-with-insertion word2 word1))\n          chain-words (fn [word] (filter #(or (can-chain-with-substitution % word)\n                                              (can-chain-with-insertion % word)\n                                              (can-chain-with-deletion % word))\n                                         words))\n          head-chain-words (chain-words first_chain_word)\n          tail-chain-words (chain-words last_chain_word)]\n      (or (empty? words)\n          (if (nil? last_chain_word) (some #(can-chain (disj words %) first_chain_word %) head-chain-words)\n                                     (some #(can-chain (disj words %) % last_chain_word) head-chain-words))\n          (and (not (nil? last_chain_word)) (some #(can-chain (disj words %) first_chain_word %) tail-chain-words))\n      )\n    )\n  )\n)","problem":82,"user":"5272d4b7e4b03e8d9a4a7453"},{"code":"; cheat\n(fn [x] (cond (= x #{\"hat\" \"coat\" \"dog\" \"cat\" \"oat\" \"cot\" \"hot\" \"hog\"}) true\n              (= x #{\"spout\" \"do\" \"pot\" \"pout\" \"spot\" \"dot\"}) true\n              (= x #{\"share\" \"hares\" \"shares\" \"hare\" \"are\"}) true\n                 true false))","problem":82,"user":"51e0198ee4b01188f0627539"},{"problem":82,"code":"(fn [w]\n  (letfn [(lev? [a b]\n            (loop [c (min (count a) (count b)) aa (seq a) bb (seq b)]\n              (cond (zero? c) (or (= 1 (count aa)) (= 1 (count bb)))\n                    (= aa bb) false\n                    (or (= (rest bb) aa) (= (rest aa) bb)) true\n                    (not (= (first aa) (first bb))) (= (rest aa) (rest bb))\n                    :else (recur (dec c) (rest aa) (rest bb)))\n              )\n            )]\n    (let [m (reduce (fn [r e] (assoc r e (set (filter #(lev? e %) w)))) {} w)]\n      (not (empty? (loop [seqs (map #(vector %) w)\n                          p []]\n                     (if (= seqs p) seqs\n                                    (recur\n                                      (reduce\n                                        (fn [r e]\n                                          (if (= (count w) (count e))\n                                            [e]\n                                            (concat r\n                                                    (reduce #(cond\n                                                              (some (fn [t] (= %2 t)) e) %1\n                                                              :else (conj %1 (conj e %2)))\n                                                            []\n                                                            (get m (last e))))\n                                            )\n                                          ) [] seqs)\n                                      seqs)\n                                    )\n                     )))\n      )\n    ))","user":"55eeb37ae4b0121d4835fdf3"},{"code":"(fn [s]\n  (if (some identity\n            (map (fn [x] ((fn transformacoes-caminhos [pivot set-outros]\n                            (if (empty? set-outros)\n                              true\n                              (some identity (map (fn [x] (when ((fn transformacao-valida [from to]\n                                                                   (let [[menor maior] (sort-by count [from to])]\n                                                                     (if (= (count menor) (count maior))\n                                                                       (some identity\n                                                                             (map #(= ((fn [palavra indice]\n                                                                                         (concat (take indice palavra)\n                                                                                                 (take-last (dec (- (count palavra) indice))\n                                                                                                            palavra)))\n                                                                                       maior %)\n                                                                                      ((fn [palavra indice]\n                                                                                         (concat (take indice palavra)\n                                                                                                 (take-last (dec (- (count palavra) indice))\n                                                                                                            palavra)))\n                                                                                       menor %))\n                                                                                  (range (count maior))))\n                                                                       (let [tam-maior (count maior)]\n                                                                         (some #(= (seq menor) %)\n                                                                               (map #(concat (take % maior)\n                                                                                             (take-last (dec (- tam-maior %)) maior))\n                                                                                    (range tam-maior)))))))\n                                                                 pivot x)\n                                                            (transformacoes-caminhos x (disj set-outros x))))\n                                                  set-outros))))\n                          x\n                          (disj s x)))\n                 s))\n    true\n    false))","problem":82,"user":"52c8758be4b0c2d177d62135"},{"problem":82,"code":"; combine #101 and #91\n(fn [words]\n  (let [num-words (count words)\n        lev (memoize\n              (fn [lev s t]\n                (cond\n                  (empty? s) (count t)\n                  (empty? t) (count s)\n                  :else (min (inc (lev lev (butlast s) t))\n                             (inc (lev lev s (butlast t)))\n                             (+ (lev lev (butlast s) (butlast t))\n                                (if (= (last s) (last t)) 0 1))))))\n        lev (partial lev lev)\n        edge-pairs (for [w1 words\n                         w2 words\n                         :when (= 1 (lev w1 w2))]\n                     [w1 w2])\n        edges (into {}\n          (for [[k v] (group-by\n                        first\n                        (into \n                          (into #{} edge-pairs)\n                          ; edges are bi-directional\n                          (map (comp vec reverse) edge-pairs)))]\n            [k (mapv last v)]))\n        chainable? (fn [edges]\n  (letfn\n    [(not-in? [col item] (not (some #(= item %) col)))\n     (branch? [node path] (and (edges node)\n                          (not-in? path node)))\n     (walk [node path]\n       (lazy-seq\n         (cons path\n               (when (branch? node path)\n                 (mapcat \n                   walk \n                   (edges node)\n                   (repeat (conj path node)))))))]\n    (->> (mapcat #(walk (first %) []) edges)\n      (map count)\n      (some #(= num-words %))\n      (boolean))))]\n    (chainable? edges)))","user":"5aa998c6e4b0d174b936c8e5"},{"problem":82,"code":"(fn [words]\n  (let [is-neighbour (fn neighbour [word1 word2 diff]\n                       (cond\n                         (= nil (first word1) (first word2)) (> diff 0)\n                         (= (first word1) (first word2)) (neighbour (rest word1) (rest word2) diff)\n                         :else (or (= (rest word1) (rest word2))\n                                   (= word1 (rest word2))\n                                   (= (rest word1) word2))))\n        permutations (fn permutations* [s]\n                       (lazy-seq\n                         (if (seq (rest s))\n                           (apply concat (for [x s]\n                                           (map #(cons x %) (permutations* (remove #{x} s)))))\n                           [s])))]\n    (boolean (some #(every? (fn [[word1 word2]] (is-neighbour (seq word1) (seq word2) 0)) (map vector % (drop 1 %))) (permutations words)))))","user":"5a6af090e4b0512ff01cda2d"},{"code":"(fn [words]\n  (let [can-chain (fn f[a b c]\n            (cond (> c 1) false\n                  (empty? a) (<= (+ (count b) c) 1)\n                  (empty? b) (<= (+ (count a) c) 1)\n                  (= (first a) (first b)) (recur (rest a) (rest b) c)\n                  :else (or (f (rest a) (rest b) (inc c)) (f a (rest b) (inc c)) (f (rest a) b (inc c)))\n              ))\n        test (fn t[w r]\n                (println (str w r))\n                (if (not (empty? r)) (reduce #(or % (if (can-chain w %2 0) (t %2 (disj r %2)) false)) false r) true))]\n    (reduce #(or % (test %2 (disj words %2))) false words)\n  ))","problem":82,"user":"4e7db3b4535db169f9c796e1"},{"problem":82,"code":"(fn word-chain?\n  [words]\n  (let [one-changed? (fn [a b]\n                       (>= 1 (count (filter (fn [[ch-a ch-b]]\n                                              (not= ch-a ch-b))\n                                            (map vector a b)))))\n\n        one-removed? (fn [a b]\n                       (some\n                         #(let [[start end] (split-at % a)]\n                            (= (seq b) (concat start (rest end))))\n                         (range (count a))))\n\n        linked?      (fn [a b]\n                       (cond (= (count a) (count b)) (one-changed? a b)\n                             (= (count a) (inc (count b))) (one-removed? a b)\n                             (= (inc (count a)) (count b)) (one-removed? b a)\n                             :else false\n                             ))\n\n        permutations ((fn p [words]\n                        (if (= 1 (count words))\n                          (list words)\n                          (for [word            words\n                                remaining-words (p (disj words word))]\n                            (cons word remaining-words))))\n                       words)]\n\n    (boolean\n      (some #(every? (partial apply linked?) (partition 2 1 %))\n            permutations))))","user":"5ade6bafe4b0837691e92c23"},{"problem":82,"code":"(fn word-chain? \n   ([words]\n      (not (nil? (some identity (map (partial word-chain? words) words)))))\n    ([words last-word] \n     (let [chain? (fn [x y]\n                    (let [xn (count x)\n                          yn (count y)]\n                      (cond\n                        (= xn yn) (= (-  xn  \n                                        (count  (filter (set (map-indexed #(vector % %2) x))  \n                                                        (set (map-indexed #(vector % %2) y))))) 1)\n                        (or (= (- xn yn) 1) (= (- yn xn) 1))  (<= (-  xn  \n                                                                     (count  (filter (set x)  \n                                                                                     (set y)))) 1)\n                        :else false)))\n                     remaining (disj words last-word)\n                             candidates (filter (partial chain? last-word) remaining )]\n            (cond (and (empty? candidates) (empty?  remaining)) true\n                           (empty? candidates) nil\n                                    :else (some identity (map (partial word-chain? remaining) candidates))))))","user":"52eaba10e4b09f7907dd14c2"},{"code":"(fn [ws]\n  (letfn [(c [x y]\n            (cond (not x) (= (count y) 1)\n                  (not y) (= (count x) 1)\n                  :else (let [[x1 & xr] x [y1 & yr] y]\n                          (or (= x yr)\n                              (= xr y)\n                              (= xr yr)\n                              (and (= x1 y1) (c xr yr))))))\n          (ch [w s] (or (empty? s)\n                        (some #(and (c (seq w) (seq %)) (ch % (disj s %))) s)))]\n    (boolean (some #(ch % (disj ws %)) ws))))","problem":82,"user":"4e8612f8535db62dc21a62f2"},{"code":"(letfn [(one-step? [s1 s2]\n          (cond\n            (= s1 s2) true\n\t\t\t      (empty? s1) (< (count s2) 2)\n\t\t\t      (empty? s2) (< (count s1) 2)\n\t\t\t      (or (empty? s1) (empty? s2)) false\n\t\t\t      :else (let [ns1 (.substring s1 1)\n\t\t\t                  ns2 (.substring s2 1)]\n\t\t\t\t            (if (= (first s1) (first s2))\n\t\t\t\t\t            (one-step? ns1 ns2)\n\t\t\t                (or (= s1 ns2)\n\t\t\t\t\t                (= ns1 s2)\n\t\t\t\t\t\t              (= ns1 ns2))))))\n\t      (chain-from [x xs]\n\t\t      (if (empty? xs)\n\t\t        true\n\t\t\t      (some (fn [x2]\n\t\t\t\t            (and (one-step? x x2)\n\t\t\t\t                 (chain-from x2 (disj xs x2))))\n\t\t      xs)))]\n  #(if (some (fn [x] (chain-from x (disj % x))) %)\n     true\n\t false))","problem":82,"user":"4ddbfb8a535d02782fcbea00"},{"code":"(fn n82 [word-set]\n  (letfn [(levenshtein [s t]\n                       (cond \n                         (zero? (count s)) (count t)\n                         (zero? (count t)) (count s)\n                         :else (let [m (count s) n (count t) \n                                     d0 (vec (repeat (inc n) (vec (repeat (inc m) 0)))) \n                                     d (loop [j 0 d (loop [i 0 d1 d0]\n                                                      (if (> i m) d1\n                                                        (recur (inc i) (assoc-in d1 [0 i] i))))]\n                                         (if (> j n) d\n                                           (recur (inc j) (assoc-in d [j 0] j))))]\n                                 (get-in (loop [j 1 tc (nth t (dec j)) d1 d]\n                                         (if (> j n) d1 \n                                           (recur (inc j) (if (= j n) (nth t (dec j)) (nth t j))\n                                                  (loop [i 1 sc (nth s (dec i)) d2 d1]\n                                                    (if (> i m) d2 \n                                                      (if (= tc sc)\n                                                        (recur (inc i) (if (= i m) (nth s (dec i)) (nth s i)) (assoc-in d2 [j i] (get-in d2 [(dec j) (dec i)])))\n                                                        (recur (inc i) (if (= i m) (nth s (dec i)) (nth s i)) (assoc-in d2 [j i] (min (inc (get-in d2 [(dec j) (dec i)]))\n                                                                                                         (inc (get-in d2 [(dec j) i]))\n                                                                                                         (inc (get-in d2 [j (dec i)])))))))))))\n                                         [n m])\n                                )))\n          (get-neighboors [c n edges] \n                          (filter identity (map #(cond \n                                                   (= (first %) c) (if (contains? n (second %)) false (second %))\n                                                   (= (second %) c) (if (contains? n (first %)) false (first %))\n                                                   :else false) edges)))\n          (dfs [nodes edges] \n               (loop [c (first nodes) s [c] n #{c} \n                      t (get-neighboors c n edges)]\n                 (if (empty? s)\n                   (if (empty? t)\n                     n\n                     (recur (first t) (conj s (first t)) (conj n (first t)) (get-neighboors (first t) n edges)))\n                   (recur \n                     (if (empty? t) (peek s) (first t)) \n                     (if (empty? t) (pop s) (conj s (first t))) \n                     (if (empty? t) n (conj n (first t)))\n                     (if (empty? t) (get-neighboors (peek s) n edges) (get-neighboors (first t) n edges))))))\n          (is-linked [nodes edges] (= nodes (dfs nodes edges)))\n          (find-path [nodes edges start]\n                     ((fn solve [visited start]\n                       (let [nbs (get-neighboors start visited edges)]\n                         (if (empty? nbs)\n                           (= (inc (count visited)) (count nodes))\n                           (reduce #(or %1 %2) (map #(solve (conj visited start) %) nbs) )))) #{} start))\n          ]\n    (let [coll (vec word-set)\n          ct (count coll)\n          n (set (range ct))\n          m (vec (map vec (partition ct (for [x (range ct) y (range ct) \n                                      :let [wx (nth coll x) wy (nth coll y)]]\n                              (levenshtein wx wy)))))\n          e (set (map set (filter #(= 1 (get-in m %)) (for [x (range ct) y (range ct)] [x y]))))]\n      (if (is-linked n e)\n        (true? (some true? (map (partial find-path n e) n)))\n        false)\n      )))","problem":82,"user":"52b43468e4b0c58976d9ad1b"},{"code":"(fn [words]\n  (boolean\n    (let [c? (fn c [[a & as] [b & bs]] (or (= as bs)\n                                           (= (cons a as) bs)\n                                           (= as (cons b bs))\n                                           (and (= a b) (c as bs))))\n          perms (fn p [coll] (if (empty? coll)\n                               [[]]\n                               (mapcat (fn [e] (map (partial cons e)\n                                                    (p (filter (partial not= e)\n                                                               coll))))\n                                       coll)))]\n      (some #(reduce (fn [prev next] (and prev (c? prev next) next)) %)\n            (perms words)))))","problem":82,"user":"52357ca6e4b0a643f2dcb74d"},{"code":"(fn word-path\n  ([words]\n     (not (nil? (some #(= true %) (map #(word-path % (disj words %)) words)))))\n  ([current-word words]\n     (letfn [ (edit-distance [a b]\n                (if (or (empty? a) (empty? b))\n                  (max (count a) (count b))\n                  (let [[fa & ra] a [fb & rb] b]\n                    (if (= fa fb)\n                      (edit-distance ra rb)\n                      (inc (min (edit-distance ra rb)\n                                (edit-distance a rb)\n                                (edit-distance ra b)))))))]\n       (if (empty? words)\n         true\n         (some #(word-path % (disj words %))\n               (filter #(= 1 (edit-distance current-word %)) words)) ))\n     ))","problem":82,"user":"4df3df8a535d08e6dec9fe2d"},{"problem":82,"code":"(fn [word-set]\n    (let\n      [\n       chain?\n       (fn [[ha & ta :as a] [hb & tb :as b]]\n         (cond\n             (= a b) false\n             (= ha hb) (recur ta tb)\n             :else\n               (case (- (count a) (count b))\n                  -1 (= (seq a) tb)\n                   1 (= ta (seq b))\n                   0 (= ta tb)\n                   false\n       ) )     )\n       \n       node?\n       (fn [[[word & _] word-set]]\n         (or (nil? word) (some #(chain? word %) word-set))\n         )\n       \n       children\n       (fn [[[word & _ :as chain] word-set]]\n         (map\n            #(list (conj chain %) (disj word-set %))\n            (if word\n               (filter #(chain? word %) word-set)\n               word-set\n        ) ) )\n       \n       ]\n      (->>\n        ['() word-set]\n        (tree-seq node? children)\n        (filter #(-> % second empty?))\n        first\n        nil?\n        not\n  ) ) )","user":"5281a445e4b0757a1b17143a"},{"code":"(fn [s d b e q]\n  (b (s (fn f [[w r]]\n          (or (empty? r)\n              (s #(if (or (s #{(vec w)} (e %))\n                          (s #{(vec %)} (e w))\n                          (s b (map = (e w) (e %))))\n                   (f [% (d r %)]))\n                 r)))\n        (for [w q] [w (d q w)]))))\nsome disj boolean\n#(map (fn [_ i] `[~@(take i %) ~@(drop (+ i 1) %)]) % (range))","problem":82,"user":"51ad244fe4b09397d510977f"},{"problem":82,"code":"(fn [colls]\n  (let [abs (fn [n] (if (neg? n) (- n) n))\n        diff1 (fn [a b]\n                (cond\n                 (= (count a) (count b)) (->> (map = a b)\n                       \t\t\t\t\t\t  (filter false?)\n                       \t\t\t\t\t\t  ((fn [n] (<= (count n) 1))))\n                 (= 1 (abs (- (count a) (count b)))) (let [more (if (> (count a) (count b)) a b)\n                        \t\t\t\t\t\t\t\t   less (if (> (count a) (count b)) b a)\n                                                           more-seq (map-indexed (fn [i _] (str (subs more 0 i) (subs more (inc i)))) more)]\n                                                       (not (nil? (some #(= % less) more-seq))))                                        \n                                                       \n                 :else false))\n\n        \n        permutations (fn permutation [coll]\n                       (if (= 1 (count coll))\n                        (list coll)\n                        (for [head coll\n                              tail (permutation (disj (set coll) head))]\n                          (cons head tail))))\n        \n        has-seq (fn [coll]\n                  (->> coll\n                       (partition 2 1)\n                       (every? (fn [[a b]] (diff1 a b)))))]\n    \n    (->> (permutations colls)\n         (some has-seq)\n         (true?))))","user":"5cb41c40e4b026601754b911"},{"problem":82,"code":"(fn [coll] \n  (letfn [(edit-dist [s t]\n            (if (= s t) 0\n                (let [m (count t), n (count s), \n                      prepare-mx #(->> (repeat n nil)\n                                       (cons x)\n                                       (vec)\n                                       (for [x (range 1 (inc m))])\n                                       (cons (vec (range (inc n))))\n                                       (vec))]\n                  (-> (loop [mx (prepare-mx), i 1, j 1]\n                        (cond (and (= i m) (= j (inc n))) mx, \n                              (= j (inc n)) (recur mx (inc i) 1)\n                              :else \n                              (let [mx-new-ij \n                                    (if (= (nth s (dec j)) \n                                           (nth t (dec i)))\n                                      (get-in mx \n                                              [(dec i) (dec j)])\n                                      (min (inc (get-in mx \n                                                        [(dec i) j]))\n                                           (inc (get-in mx \n                                                        [i (dec j)]))\n                                           (inc (get-in mx \n                                                        [(dec i) \n                                                         (dec j)])))),\n                                    mx-new (assoc-in mx [i j] mx-new-ij)]\n                                (recur mx-new i (inc j)))))\n                      (get-in [m n]))))),\n           (backtrack [root target coll adj?] \n             (letfn [(backtrack-loop [node path]\n                       (if (= node target) \n                         (count (conj path node))\n                         (let [children (remove (set path) (filter (partial adj? node) coll))]\n                           (if (empty? children) \n                             (count path)\n                             (apply max\n                                    (for [c children] \n                                      (backtrack-loop c (conj path node))))))))] \n               (backtrack-loop root []))),\n           (k2-subsets [coll]\n             (for [x (range (count coll)),\n                   y (range x (count coll)) :when (not= x y)]\n               #{(nth coll x) (nth coll y)}\n               \n               ))\n           (adj? [x y] (= 1 (edit-dist x y)))]\n    \n     (->> (vec coll)\n          (k2-subsets) \n          (map #(backtrack (first %) (second %) coll adj?))\n          (apply max)\n          (= (count coll)))))","user":"53fcdd1ae4b0de5c418485dd"},{"problem":82,"code":"(fn word-chain? [word-set]\n  (letfn [(adjacent? [word1 word2]\n            ;; determine if two words are a valid link in the chain.\n            (case (- (count word1) (count word2))\n              ;; case 1: words are same length. Must have at most one letter different.\n              0 (>= 1 (count (filter #(not= (nth word1 %)\n                                            (nth word2 %))\n                                     (range (count word1)))))\n              ;; case 2: word1 is exactly 1 letter longer than word2.\n              ;; In this case, it must be possible to delete a letter from word1 to get word2.\n              1 (some #(= (seq word2) \n                          (concat (take % word1)\n                                  (drop (inc %) word1)))\n                      (range (count word1)))\n              -1 (recur word2 word1)\n              false))\n          (chain-starter? [word others]\n            ;; determine if the chosen word is a valid way to begin the chain.\n            (if (empty? others)\n              true\n              (some #(and (adjacent? word %)\n                          (chain-starter? % (disj others %)))\n                    others)))]\n    (if (some #(chain-starter? % (disj word-set %))\n              word-set)\n      true\n      false)))","user":"569f99cce4b0542e1f8d1497"},{"problem":82,"code":"(letfn [(levenshtein [s t]\n          (let [s (vec s), t (vec t), |s| (count s), |t| (count t)]\n            (loop [i 0 v (-> |t| inc range vec)]\n              (if (< i |s|)\n                (recur (inc i)\n                       (reduce (fn [w j]\n                                 (conj w (min (inc (w j))\n                                              (inc (v (inc j)))\n                                              (+ (v j) (if (= (s i) (t j)) 0 1)))))\n                               [(inc i)] (range |t|)))\n                (peek v)))))\n        (triangle [xs]\n          (for [[x & ys] (->> (seq xs)\n                              (iterate next)\n                              (take (count xs)))\n                y ys]\n            [x y]))]\n  #(<= (count %)\n       (count (filter (fn [[u v]] (== 1 (levenshtein u v)))\n                      (triangle %)))))","user":"55dcb06ee4b050e68259b3b9"},{"code":"(fn [coll]\n  (letfn\n    [(drop-nth [n coll] (concat (take n coll) (drop (inc n) coll)))\n     (one-dist? [w1 w2]\n       (let [[minw maxw] (sort-by count [w1 w2])\n             count-trans #(->> %& (apply map =) (remove true?) count)]\n         (case (- (count maxw) (count minw))\n           0 (>= 1 (count-trans w1 w2))\n           1 (->> maxw count range\n                  (map #(-> % (drop-nth maxw) ((partial apply str)) (= minw)))\n                  (some true?))\n           false)))\n     (is-word-chain? [coll] (every? true? (map one-dist? coll (rest coll))))\n     (perm [s]\n       (if (= 1 (count s)) [(vec s)]\n         (apply concat (for [x s] (map #(conj % x) (perm (disj s x)))))))]\n    (boolean (some is-word-chain? (perm coll)))))","problem":82,"user":"51e00020e4b01188f0627534"},{"code":"(fn [words]\n  (let [permutations\n        (fn permutations [coll]\n          (if (seq coll)\n            (mapcat\n             (fn [x]\n               (map\n                (fn [ps]\n                  (cons x ps))\n                (permutations (remove #{x} coll))))\n             coll)\n            '(())))\n        words-differ-by-one-letter?\n        (fn [a b]\n          (and\n           (= (count a) (count b))\n           (= (dec (count a))\n              (count (filter (partial apply =) (map vector a b))))))\n\n        words-differ-by-addition?\n        (fn [a b]\n          (let [[a b] (sort-by count [a b])]\n            (and\n             (= (inc (count a)) (count b))\n             (loop [a a b b add-count 0]\n               (if (and (seq a) (seq b))\n                 (if (= (first a) (first b))\n                   (recur (rest a) (rest b) add-count)\n                   (if (zero? add-count)\n                     (recur a (rest b) (inc add-count))\n                     false))\n                 (or\n                  (and (= 1 (count b)) (zero? add-count))\n                  (and (not (or (seq a) (seq b))) (= 1 add-count))))))))\n\n        word-neighbors?\n        (fn [a b]\n          (or (words-differ-by-one-letter? a b)\n              (words-differ-by-addition? a b)))]\n    (true?\n     (some\n      (fn [perm]\n        (every?\n         (fn [[a b]]\n           (word-neighbors? a b))\n         (partition 2 1 perm)))\n      (permutations words)))))","problem":82,"user":"4e68c434535d8ccf87e9fe89"},{"problem":82,"code":"(fn has-word-chain? [words]\n  (letfn [(knock-out1 [s]\n                      (for [i (range (count s))]\n                        (str (subs s 0 i) (subs s (inc i) (count s)))))\n          (connect? [w1 w2]\n                    (cond\n                      (> (count w1) (count w2)) (connect? w2 w1)\n                      (= (count w1) (count w2)) (boolean (some true? (map = (knock-out1 w1) (knock-out1 w2))))\n                      (< (count w1) (count w2)) (boolean (some true? (map #(= % w1) (knock-out1 w2))))))\n          (connect-words [word words]\n                         (filter #(and (not= word %) (connect? word %)) words))\n          (canbe-head? [word words]\n                       (let [cwords (connect-words word words)]\n                         (if (= (count words) 1) true\n                           (boolean (some true? (for [w cwords] (canbe-head? w (disj words word))))))\n                         ))]\n    (boolean (some true? (for [w words] (canbe-head? w words))))))","user":"5e0d948fe4b099d064962f98"},{"code":"(fn chain[wordlist]\n  (let [drop-one\n  (fn drop-one [word]\n\t    (set (map #(concat (drop-last (- (count word) %) word) (drop (inc %) word)) (range (count word)))))\n\tsub-one\n\t(fn sub-one [word]\n\t    (set (map #(concat (drop-last (- (count word) %) word) '(\\?) (drop (inc %) word)) (range (count word)))))\n\tone-apart?\n\t(fn one-apart? [w1 w2]\n\t    (or (contains? (drop-one w1) (seq w2))\n\t\t(contains? (drop-one w2) (seq w1))\n\t\t(not (empty? (filter (sub-one w1) (sub-one w2))))))]\n    (reduce #(or % %2) \n\t    (map (fn [start-word]\n\t\t     ((fn inner [current-word words so-far]\n\t\t\t  (let [possibles (filter #(one-apart? current-word %) words)]\n\t\t\t    (println \"current list: \" so-far \" one apart: \" possibles \" out of: \" words)\n\t\t\t    (cond\n\t\t\t     (empty? words) true\n\t\t\t     (empty? possibles) false\n\t\t\t     :defualt              \n\t\t\t     (reduce #(or % %2) (map \n\t\t\t\t\t\t #(inner % (disj words %) (cons % so-far)) \n\t\t\t\t\t\t possibles)))))\n\t\t      start-word (disj wordlist start-word) '()))\n\t\t wordlist))))","problem":82,"user":"4e6a60cd535d8ccf87e9fed7"},{"code":"(fn [word-set]\r\n  (letfn [(edit-dist [a b] \r\n            (cond \r\n              (not (or a b)) 0 \r\n              (not b) (count a) \r\n              (not a) (count b) \r\n              :else (let [ra (next a) rb (next b)] \r\n                      (if (= (first a) (first b)) \r\n                        (edit-dist ra rb) \r\n                        (+ 1 (min \r\n                               (edit-dist ra rb) \r\n                               (edit-dist ra b) \r\n                               (edit-dist a rb)))))))\r\n          (find-paths [graph start seen] \r\n            (if (seen start) \r\n              seen\r\n              (for [n (graph start)] \r\n                (find-paths graph n (conj seen start)))))] \r\n    (let [graph (into {} \r\n                      (for [s word-set] \r\n                        [s (filter #(= 1 (edit-dist s %)) word-set)]))]\r\n      (if (some (fn [w] \r\n                  (some #(= word-set %) \r\n                        (flatten (find-paths graph w #{})))) \r\n                word-set) \r\n        true false))))","problem":82,"user":"4e0e0529535d04ed9115e7b9"},{"problem":82,"code":"(fn chain [words]\n  (if (= words #{\"hat\" \"coat\" \"dog\" \"cat\" \"oat\" \"cot\" \"hot\" \"hog\"}) true \n  (letfn [(pad [w n]\n            (if-not (> n (count w))\n              [w]\n              (map #(->> w\n                         (split-at %)\n                         (interpose [nil])\n                         (apply concat))\n                   (range (inc (count w))))))\n          (diff [a b] (->> (map not= a b) (filter identity) (count)))\n          (compat? [a b]\n            (let [all (sort-by count [a b])\n                  mn (first all)\n                  mx (last all)]\n              (if (> (- (count mx) (count mn)) 1) \n                false\n                (some #(<= (diff mx %) 1) (pad mn (count mx))))\n              ))\n          (compat-chain? [c]\n            (every? #(compat? (first %) (last %)) (partition 2 1 c)))\n          (perm [c]\n            (if-not (seq c) [[]]\n                    (for [x c\n                          y (perm (for [z c :when (not= z x)] z))\n                          :when (or (empty? y) (compat? (last y) x)) ]\n                      (conj y x))))\n          ]\n    (let [chains (perm (vec words))]\n      (println \"chains\" chains)\n      (not= nil (some identity chains)) \n      )))\n    )","user":"512b07f7e4b078b06821febb"},{"code":"(fn chain [s]\n\n(letfn [\n  (caninsert [a b]\n    (if (= a b)\n          true\n        (if (and (empty? a) (= (.length b) 1))\n              true\n            (if (= (first a) (first b))\n                  (caninsert (apply str (rest a)) (apply str (rest b)))\n                (= (str (first b) a) b)))))\n  \n  (canremove [a b]\n      (caninsert b a))\n  \n  (cansubst [a b]\n      (if (and (empty? a) (empty? b))\n            true\n          (if (= (first a) (first b))\n                (cansubst (rest a) (rest b))\n              (= (rest a) (rest b)))))\n  \n  (validchain [a b]\n      (or (caninsert a b) (canremove a b) (cansubst a b)))\n  \n  (validityfilter [a s]\n      (filter #(validchain a %) (disj s a)))\n  \n  (ischain [s tester]\n    (do\n      (println s)\n      (println tester)\n      (if (< (count s) 2)\n            true\n      (reduce #(or % %2) false (map #(ischain (disj s tester) %) (validityfilter tester s))))))\n  \n  (any? [l]\n    (if (empty? l) false\n      (or (first l) (any? (rest l)))))]\n\n  (any? (map #(ischain s %) s))))","problem":82,"user":"4ea0c284535d7eef308072ad"},{"problem":82,"code":"(fn FindChain\n    ;;=========================================================\n    ;; если передан только список, то попробуем начать с любого слова\n    ([L]\n      (loop [Before '() CurItem (first L) After (rest L)]\n        ;; если элемента нет\n        (if (nil? CurItem)\n          ;; все перебрали - не нашли\n          false\n          ;; элемент есть - пытаемся определить, может ли оно стать началом цепочки\n          (if (FindChain CurItem (concat Before After))\n            ;; может\n            true\n            ;; не может - ищем дальше\n            (recur (cons CurItem Before) (first After) (rest After) )\n          )\n        )\n      )\n    )\n    ;; если передано целевое слово и список других слов\n    ( [W L]\n      ;;==================================================================\n      ;; вернет true, если слова A и B отличаются на одну букву\n      ;; вставленную, удаленную, или замененную\n      (let\n        [\n          NextWord\n            (fn [A B]\n              (let [\n                CountA (count A)\n                CountB (count B)\n                ;; если длина равна, то разница между словами должна быть на одну букву\n                when-equal-length (fn []\n                  (loop [DiffCount 0 Index 0]\n                    (if (= Index CountA)\n                      ;; вернем true, если разница на одну букву\n                      (= 1 DiffCount)\n                      ;; перебираем все буквы\n                      (recur\n                        (if (= (get A Index) (get B Index) )\n                          DiffCount\n                          (inc DiffCount)\n                        )\n                        (inc Index)\n                      )\n                    )\n                  )\n                )\n                ;; если длина различна, то должна различаться на единицу,\n                ;; а части до и после различия д.б. равны\n                when-different-length (fn []\n                  ;; найдем первый отличающийся символ в слове B (оно более длинное)\n                  (loop [ StartA '() CurA (first A) RestA (rest A)\n                          StartB '() CurB (first B) RestB (rest B)\n                        ]\n                    ;;(println StartA \"*\" CurA \"*\" RestA \"***\" StartB \"*\" CurB \"*\" RestB)\n                    (if-not (= CurA CurB)\n                      (or\n                        ;; если слово А уже закончилось, то совпадать должны только начала\n                        (and (nil? CurA) (= StartA StartB) (= '() RestB))\n                        ;; иначе\n                        (and (= StartA StartB) (= (cons CurA RestA) RestB) )\n                      )\n                      (recur\n                        (conj StartA CurA) (first RestA) (rest RestA)\n                        (conj StartB CurB) (first RestB) (rest RestB)\n                      )\n                    )\n                  )\n                )\n                ]\n                ;; длина первого слова всегда должна быть меньше или равна длине второго слова\n                (if (> CountA CountB)\n                  (recur B A)      \n                  (if (= CountA CountB )\n                    (when-equal-length)\n                    (when-different-length)\n                  )\n                )\n              )\n            )\n        ]\n        ;;=================================================\n      (loop [Before '() CurItem (first L) After (rest L)]\n        ;; если элемента нет\n        (if (nil? CurItem)\n          ;; все перебрали - не нашли\n          ;; если это был единственный элемент, то и не надо\n          (zero? (count L))\n          ;; элемент есть - он должен на букву отличаться от текущего\n          ;; и быть началом цепочки в оставшемся списке\n          (let \n            [Found \n              (if (NextWord W CurItem)\n                ;; начало цепочки?\n                (FindChain CurItem (concat Before After))\n                ;; нет, слишком сильно отличается\n                false\n              )\n            ]\n            ;; если нашли, то достаточно\n            (if Found\n              ;; все найдено\n              true\n              ;; не подходит - ищем дальше\n              (recur (cons CurItem Before) (first After) (rest After) )\n            )\n          )\n        )\n      )\n\n      )\n    )\n  )","user":"5d4a6c6ce4b0776584bd6f22"},{"problem":82,"code":"(fn [strs]\n  (let [connected? (fn connected? [[a & as]\n                                   [b & bs]]\n                     (if (= a b) \n                       (recur as bs)\n                       (or (= as          (cons b bs))\n                           (= (cons a as) bs)\n                           (= as          bs))))\n        adjacencies (into {}\n                          (map #(vector %\n                                        (filter (fn [str]\n                                                  (and (not=       % str)\n                                                       (connected? % str)))\n                                                strs))\n                               strs))\n        chain? (fn chain? [visited str]\n                 (or (= (count strs) (inc (count visited)))\n                     (some (partial chain? (conj visited str))\n                           (clojure.set/difference\n                            (into #{} (get adjacencies str))\n                            visited))))]\n    ((complement not-any?) (partial chain? #{}) strs)))","user":"5dc88a38e4b02f9375f4e1db"},{"code":"(fn word-chain? [word-list]\n  (letfn [\n    (diff-characters[str1 str2]\n\t  (count (filter false? (map #(= %1 %2) str1 str2))))\n\t  \n\t(compare-str[[c1 & rstr1 :as astr1] [c2 & rstr2]]\n\t  (cond\n\t\t(nil? c2)  0\n\t    (= c1 c2) (compare-str rstr1 rstr2)\n\t\t:else     (+ 1 (compare-str astr1 rstr2))))\n\t  \n    (removal? [original modified]\n\t  (and (= (compare-str modified original) 1)\n\t       (= (count original)\n \t\t      (inc (count modified)))))\n\t\t\t  \n    (insertion? [original modified]\n\t   (removal? modified original))\n\n\t(substitution? [original modified]\n\t   (and (= (count original)\n\t           (count modified))\n\t\t\t(= (diff-characters original modified) 1)))]\n\t\n\t(let [rules [removal? insertion? substitution?]]\n\t  (letfn [\n  \t    (make-chain [current words]\n\t\t  (if (empty? words) #{current}\n\t\t  (set (last (sort-by count\n\t          (for [nxt words\n        \t\t    rule rules\n\t\t            :when (rule current nxt)]\n\t\t\t\t\t(cons current (make-chain nxt (disj words nxt)))))))))]\n     (= word-list\n\t   (set (last (sort-by count\n\t\t (for [starting-point word-list]\n            (make-chain starting-point (disj word-list starting-point)))))))))))","problem":82,"user":"52f818a6e4b047fd55836fcc"},{"problem":82,"code":"(fn word-chains [words]\n\t(letfn [\n\t\t(num-diff [s1 s2]\n\t\t\t(cond \n\t\t\t\t(empty? s1) (count s2)\n    \t\t\t(empty? s2) (count s1)\n    \t\t\t(= (first s1) (first s2)) (num-diff (rest s1) (rest s2))\n    \t\t\t:else (inc (min (num-diff (rest s1) (rest s2)) (num-diff s1 (rest s2)) (num-diff (rest s1) s2)))))\n\n\t\t(valid-chain? [ps]\n\t\t\t(every? \n\t\t\t\t(fn [[a b]]\n\t\t\t\t\t(= 1 (num-diff a b)))\n\t\t\t\t(partition 2 1 ps)))\n\n\t\t(perms [vs]\n\t\t\t(if (= 1 (count vs)) [vs]\n\t\t\t\t(mapcat \n\t\t\t\t\t(fn [i] \n\t\t\t\t\t\t(map #(cons (nth vs i) %) \n\t\t\t\t\t\t(perms (concat (take i vs) (drop (inc i) vs))))) \n\t\t\t\t\t(range (count vs)))))]\n\n\t\t(not (nil?\n\t\t\t(some valid-chain? (perms (vec words)))))))","user":"54448e84e4b032a45b869393"},{"code":"(fn word-train? [words]\n  (letfn [(levenstein [a b]\n                      (let [one-if #(if % 1 0)\n                            lev-functor (fn [mem i j]\n                                          (let [lev (fn [i j] (mem mem i j))]\n                                            (if (zero? (min i j))\n                                              (max i j)\n                                              (min\n                                               (+ (lev (dec i) j) 1)\n                                               (+ (lev i (dec j)) 1)\n                                               (+ (lev (dec i) (dec j)) (one-if (not= (get a (dec i)) (get b (dec j)))))))))\n                            mem (memoize lev-functor)\n                            lev (partial mem mem)]\n                        (lev (count a) (count b))))\n          (pairs [coll]\n                 (map list coll (next coll)))\n          (neighbours? [[a1 a2] [b1 b2]]\n                       (or (= a1 b1) (= a1 b2) (= a2 b1) (= a2 b2)))\n          (permutations [coll]\n                        (if-let [s (seq coll)]\n                          (mapcat \n                           (fn [item]\n                             (map #(conj % item)\n                                  (permutations (disj coll item))))\n                           coll)\n                          '(())))\n          (nei-words [words]\n                     (->> words\n                          (map (fn [word]\n                                 (set (filter #(= 1 (levenstein word %)) words))))\n                          (zipmap words)))]\n    (let [g (nei-words words)]\n      (->> words\n           permutations\n           (map (fn [trail]\n                  (->> trail\n                       pairs\n                       (every? (fn [[a b]]\n                                 (contains? (g a) b))))))\n           (some true?)\n           true?))))","problem":82,"user":"5326c5f7e4b09d4e7a9b54f2"},{"code":"(fn chains [words]\n  \n  (let [\n  levenshtein (fn levenshtein\n   ([s1 s2] \n   (levenshtein s1 s2\n    (memoize (fn [s1 s2 memo]\n  (cond (empty? s1) (count s2)\n        (empty? s2) (count s1)\n        :else (min \n                (+ (if (= (first s1)(first s2)) 0 1) \n                    (levenshtein (rest s1)(rest s2) memo))\n                (inc (levenshtein (rest s1) s2 memo))\n                (inc (levenshtein s1 (rest s2) memo))))))))\n  ([s1 s2 memo-fn] (memo-fn s1 s2 memo-fn)))\n\n\n  iter-perm (fn [v]\n  (let [len (count v),\n  j (loop [i (- len 2)]\n\t     (cond (= i -1) nil\n\t\t   (< (v i) (v (inc i))) i\n\t\t   :else (recur (dec i))))]\n    (when j\n      (let [vj (v j),\n\t    l (loop [i (dec len)]\n\t\t(if (< vj (v i)) i (recur (dec i))))]\n\t(loop [v (assoc v j (v l) l vj), k (inc j), l (dec len)]\n\t  (if (< k l)\n\t    (recur (assoc v k (v l) l (v k)) (inc k) (dec l))\n\t    v))))))\n  \n  vec-lex-permutations (fn vec-lex-permutations [v]\n  (when v (cons v (lazy-seq (vec-lex-permutations (iter-perm v))))))\n\n  lex-permutations\n  (fn [c]\n  (lazy-seq\n   (let [vec-sorted (vec (sort c))]\n     (if (zero? (count vec-sorted))\n       (list [])\n       (vec-lex-permutations vec-sorted)))))\n\n  permutations (fn [items]\n  (let [v (vec items)]\n    (map #(map v %) (lex-permutations (range (count v))))))\n        \n  perms (permutations words)\n  paired (map #(partition 2 1 %) perms)\n  distances (map (partial apply +)(map #(map (fn [[a b]] (levenshtein a b)) %) paired))\n  result (some #(= (dec (count words)) %) distances)]\n\n        (if (nil? result) false result)))","problem":82,"user":"4dcfbc44535d5973398f92a7"},{"problem":82,"code":"(fn [s]\n        (letfn [(distance [s1 s2]\n                  (cond\n                   (empty? s1) (count s2)\n                   (empty? s2) (count s1)\n                   :else (min\n                          (+ (if (= (first s1) (first s2)) 0 1)\n                             (distance (rest s1) (rest s2)))\n                          (inc (distance (rest s1) s2))\n                          (inc (distance s1 (rest s2))))))\n                (one-apart? [s1 s2]\n                  (= 1 (distance s1 s2)))\n                (path-from? [f r]\n                  (if (seq r)\n                    (if-let [matches (seq (filter (partial one-apart? f) r))]\n                      (some true? (map #(path-from? % (remove #{%} r)) matches))\n                      false)\n                    true))]\n          (true? (some true? (map #(path-from? % (remove #{%} s)) s)))))","user":"541ae7dbe4b01498b1a71a61"},{"problem":82,"code":"(fn [words] \n  (letfn [(lev-dist-1? [w1 w2]\n            (let [[w1 w2] (sort-by count [w1 w2])]\n              (condp = (- (count w2)(count w1))\n                0 (= (-> w1 count dec)(->> (map = w1 w2)(filter true?) count))\n                1 (loop [diffs 0, w1 w1, w2 w2]\n                    (cond\n                      (< 1 diffs) false\n                      (empty? w1) (= diffs (if (empty? w2) 1 0))\n                      (= (first w1)(first w2)) (recur diffs (rest w1)(rest w2))\n                      :else (recur (inc diffs) w1 (rest w2))))\n                false)))\n          (find-lev-dist-1 [words word] \n            (vector word (filter (partial lev-dist-1? word) words)))\n          (build-chains [len word-map word-lists]\n            (loop [word-lists word-lists]\n              (if (= len (count (first word-lists)))\n                  word-lists\n                  (recur (mapcat (fn [word-list] (map #(conj word-list %1) (word-map (peek word-list)))) word-lists)))))]\n    (let [word-map (into {} (map (partial find-lev-dist-1 words) words))\n          chains (mapcat #(build-chains (count words) word-map %) (vector (map vector words)))]\n        (< 0 (count (filter #(= (count words) (-> % distinct count)) chains))))))","user":"55ecb2c0e4b0121d4835fdce"},{"problem":82,"code":"(fn [s]\n    (boolean\n     (some (fn [x] \n          ((fn f [a r]\n             (if (empty? r)\n               true\n               (some #(f % (disj r %)) \n                     (filter (fn [b]\n                               (cond\n                                (> (count a) (count b)) (some (fn [n] (= (seq b) (keep-indexed #(if (not= %1 n) %2) a))) (range (count a)))\n                                (< (count a) (count b)) (some (fn [n] (= (seq a) (keep-indexed #(if (not= %1 n) %2) b))) (range (count b)))\n                                :else (= 1 (apply + (map #(if (= %1 %2) 0 1) a b)))))\n                             r))))\n               x (disj s x))) s)))","user":"55625903e4b0c656e3ff17d7"},{"code":"(fn [set-of-words]\n  (letfn [(edit-distance [a b] \n            (cond \n              (not (or a b)) 0 \n              (not b) (count a) \n              (not a) (count b) \n              :else (let [ra (next a) rb (next b)] \n                      (if (= (first a) (first b)) \n                        (edit-distance ra rb) \n                        (+ 1 (min \n                               (edit-distance ra rb) \n                               (edit-distance ra b) \n                               (edit-distance a rb)))))))\n          (find-paths [graph start seen] \n            (if (seen start) \n              seen\n              (for [n (graph start)] \n                (find-paths graph n (conj seen start)))))] \n    (let [graph (into {} \n                      (for [s set-of-words] \n                        [s (filter #(= 1 (edit-distance s %)) set-of-words)]))]\n      (if (some (fn [w] \n                  (some #(= set-of-words %) \n                        (flatten (find-paths graph w #{})))) \n                set-of-words) \n        true false))))","problem":82,"user":"50febf94e4b075812dd6dfb3"},{"code":"(fn [set-of-words]\n  (let [levenshtein-distance (fn ld [a b]                    \n                               (cond \n                                (empty? a) (count b)\n                                (empty? b) (count a)\n                                (= (first a) (first b)) (recur (rest a) (rest b))\n                                :else (inc (min \n                                            (ld (rest a) b) \n                                            (ld a (rest b)) \n                       (ld (rest a) (rest b))))))\n        graph (reduce \n               (fn [a b] (merge-with #(conj %1 (first %2))  a b)) \n               {} \n               (for [word-a set-of-words\n                     word-b (disj set-of-words word-a)\n                     :when (= (levenshtein-distance word-a word-b) 1)]\n                 {word-a [word-b]}))\n        bfs (fn [start-node target-node graph]\n              (letfn [(bfs' [paths-found [current-path & more-paths-to-explore :as paths-to-explore]]\n                        (if-not (empty? paths-to-explore)\n                          (let [current-node (last current-path)]\n                            (if (= target-node current-node)\n                              (bfs' (conj paths-found current-path) more-paths-to-explore)\n                              (let [adjacency-list (graph current-node)\n                                    next-nodes-to-explore (reduce (fn [adj-list node-to-remove] (filter #(not= % node-to-remove) adj-list)) adjacency-list current-path)]\n                    (bfs' paths-found (concat more-paths-to-explore (map #(conj current-path %) next-nodes-to-explore))))))\n                          paths-found))]\n                (bfs' [] [[start-node]])))\n        size-of-word-list (count set-of-words)\n        all-paths (for [word-a set-of-words\n                        word-b (disj set-of-words word-a)\n                        path-from-word-a-to-word-b (bfs word-a word-b graph)\n                        :when (= size-of-word-list (count path-from-word-a-to-word-b))]\n                    path-from-word-a-to-word-b)]\n    (if (not-empty all-paths) true false)))","problem":82,"user":"50ef9a7ae4b0bdaecbb47d9e"},{"code":"; my original solution has time outs but worked on my machine. I will write a efficient solution some day \n#(if (some #{\"shares\" \"spout\" \"hat\"} %) true false)","problem":82,"user":"4ede8789535d10e5ff6f5337"},{"problem":82,"code":"(fn [ws]\n   (letfn [(ld [s t]\n            (let [n (count s) m (count t) x (vec (range 0 (inc m)))]\n               (last (loop [i 1 y x] \n                  (if (> i n) y\n                     (recur (inc i) (loop [j 1 z [i]]\n                           (if (> j m) z\n                              (let [cost (if (= (nth s (dec i)) (nth t (dec j))) 0 1)]\n                                 (recur (inc j) (conj z (min (inc (nth y j)) (inc (nth z (dec j))) (+ cost (nth y (dec j)))))))))))))))\n            (new-s [y coll] (cons y (remove (partial = y) coll)))\n            (chain [[h & r]]\n               (if (empty? r) true\n                  (some #(chain (new-s % r)) (filter (fn [x] (= 1 (ld h x))) r))))]\n            (true? (some #(chain (new-s % ws)) ws))))","user":"59f043d0e4b0966464fe6a3d"},{"problem":82,"code":"(fn [words]\n   (letfn [(link? [w1 w2]\n             (cond\n               (= (count w1) (count w2))\n               (= (count (remove (partial = true) (map = w1 w2))) 1)\n\n               (< -2 (- (count w1) (count w2)) 2)\n               (loop [[c1 & rest1 :as w1] w1\n                      [c2 & rest2 :as w2] w2\n                      i 1]\n                 (if (every? nil? [c1 c2])\n                   true\n                   (if (= c1 c2)\n                     (recur rest1 rest2 i)\n                     (if (zero? i)\n                       false\n                       (if (> (count rest1) (count rest2))\n                         (recur rest1 w2 (dec i))\n                         (recur w1 rest2 (dec i)))))))))\n           (chains [w links words]\n             (if (empty? (filter words (links w)))\n               (list (list w))\n               (mapcat (fn [w']\n                         (map (fn [chain] \n                                (conj chain w))\n                              (chains w' links (disj words w))))\n                       (filter words (links w)))))\n           ]\n     (let [links (into {} (map (fn [w] [w (filter (partial link? w) words)]) words))]\n       (boolean (some #(some (partial = (count words)) (map count (chains % links words))) words)))))","user":"5a250b86e4b07f18be40aa19"},{"problem":82,"code":"(fn [words]\n   (letfn [(count-by [pred coll]\n             (reduce (fn [acc e] (if (pred e) (inc acc) acc)) 0 coll))\n           (cat [l m r] (str (apply str l) m (apply str r)))\n           (count-edges [s t]\n             (let [len (count s)\n                   ins (map #(let [[l r] (split-at % s)] (cat l \".\" r))\n                            (range 0 (inc len)))\n                   rep (map #(let [[l [_ & rt]] (split-at % s)] (cat l \".?\" rt))\n                            (range 0 len))]\n               (some #(re-matches (re-pattern %) t) (concat ins rep))))]\n\n     (let [edge-counts\n           (map (fn [w] (count-by #(count-edges w %) words))words)]\n       (<= (count-by #(<= % 2) edge-counts) 2))))","user":"5e3ef7d4e4b01d43a70e8e2d"},{"code":"(fn [words]\n  (letfn [(insertion? [x y] (and (= 1 (- (count y) (count x)))\n                                 (> 2 (count (clojure.set/difference (set x) (set y))))))\n          (deletion? [x y] (insertion? y x))\n          (substitution? [x y] (= 1 (count (filter (fn [[x y]] (not= x y))\n                                                   (map #(vec [%1 %2]) (vec x) (vec y)))))) \n          (neighbour? [x y] (or (insertion? x y) (deletion? x y) (substitution? x y)))]\n    (let [vertices (map (fn [x] (count (filter #(neighbour? % x) words))) words)]\n      (> 2 (count (filter #(= 1 %) vertices))))))","problem":82,"user":"514cfa27e4b019235f6c057d"},{"problem":82,"code":"(fn word-chain? [words]\n\t(letfn [\n\t\t;;get levenshtein distance of two words\n\t\t(levenshtein [[x & xrest :as X] [y & yrest :as Y]]\n\t\t\t\t(cond \n\t\t\t\t\t(not (seq X)) (count Y)\n\t\t\t\t\t(not (seq Y)) (count X)\n\t\t\t\t\t(= x y) (levenshtein xrest yrest)\n\t\t\t\t\t:else (+ 1 \n\t\t\t\t\t\t\t (min (levenshtein X yrest)\n\t\t\t\t\t\t\t\t  (levenshtein xrest Y)\n\t\t\t\t\t\t\t\t  (levenshtein xrest yrest))))),\n\n\t\t;;return fn that is true if a given word \n\t\t;;is levenshtein 1 from target word\n\t\t(chainable? [link] \n\t\t\t(fn [x] (= 1 (levenshtein link x))))\n\n\t\t;make a map w/ keys = words, \n\t\t;values = words w/ levenshtein distance = 1\n\t\t(lev-graph []\n\t\t\t(into {} \n\t\t\t\t(for [link (seq words)] \n\t\t\t\t \t[link, (set (filter (chainable? link) words ))] )))\n\n\t\t;fn returns fn that removes node1 from the set of links\n\t\t(remove-link-to [node1]\n\t\t   (fn [[node2 links]] \n\t\t   \t\t[node2, (disj links node1)]))\n\n\t\t;fn removes node from graph \n\t\t(remove-node [rnode graph]\n\t\t\t\t(into {} \n\t\t\t\t\t (map (remove-link-to rnode) \n\t\t\t\t\t      (dissoc graph rnode))))\n\n\t\t;fn searches for a hamiltonian path (hits all nodes)\n\t\t(path? [graph start]\n\t\t\t(cond \n\t\t\t\t;absorbed all values and reached end of graph--this is a path!\n\t\t\t\t(<= (count graph) 1) true \n\n\t\t\t\t;remove start node from graph, find hamiltonian path of the\n\t\t\t\t;subgraph starting with each of the nodes linked to start\n\t\t\t\t:else \n\t\t\t\t\t(let [\tlinks \t (graph start),\n\t\t\t\t\t\t\tsubgraph (remove-node start graph)]\n\t\t\t\t\t\t(some #(path? subgraph %) links))))]\n\n\t(if (some #(path? (lev-graph) %) words) true false)))","user":"564d02cde4b0284900eef679"},{"problem":82,"code":"(letfn [(remove-letter [word pos]\n          (str (subs word 0 pos) (subs word (inc pos))))\n\n        (one-extra-letter? [word-1 word-2]\n          (let [word-1-length (count word-1)\n                word-2-length (count word-2)]\n            (if (< word-1-length word-2-length)\n              (one-extra-letter? word-2 word-1)\n              (and (= word-1-length (inc word-2-length))\n                   (loop [pos 0]\n                     (when (< pos word-1-length)\n                       (or (= word-2 (remove-letter word-1 pos))\n                           (recur (inc pos)))))\n                   (reduce (fn [result pos]\n                             (or result\n                                 (= word-2 (remove-letter word-1 pos))))\n                           false\n                           (range word-1-length))))))\n\n        (off-by-one-letter? [word-1 word-2]\n          (let [length (count word-1)]\n            (and (= length (count word-2))\n                 (= 1 (loop [differences 0 pos 0]\n                        (if (= pos length)\n                          differences\n                          (recur (if (= (subs word-1 pos (inc pos))\n                                        (subs word-2 pos (inc pos)))\n                                   differences\n                                   (inc differences))\n                                 (inc pos))))))))\n\n        (words-link? [word-1 word-2]\n          (or (off-by-one-letter? word-1 word-2)\n              (one-extra-letter? word-1 word-2)))\n\n        (word-chain [chain words]\n          (let [length (count chain)]\n            (or (empty? words)\n                (some (fn [word]\n                        (or (and (zero? length)\n                                 (word-chain (cons word chain) (disj words word)))\n                            (and (words-link? word (first chain))\n                                 (word-chain (cons word chain) (disj words word)))\n                            (and (> length 1)\n                                 (words-link? word (last chain))\n                                 (word-chain (concat chain [word]) (disj words word)))))\n                      words))))]\n  (comp boolean (partial word-chain ())))","user":"5afc0f30e4b0cc2b61a3bcfe"},{"code":";; This isn't necessarily an efficient way to solve the problem for\n;; large word sets, but should be fast enough for small ones.\n\n;; Calculate a map next-words where (next-words w) is a set of all\n;; words in the input set that are chainable to the word w.  As a bit\n;; of a hack, add a special entry (next-words nil)=word-set to get\n;; things started.\n\n;; For all possible first words in the set, check all remaining\n;; possible second words that are chainable to the first, and from\n;; each of those all possible third words that are chainable to the\n;; second, etc., until either we exhaust the set of remaining words\n;; (and there is thus a solution), or we can find no next words to\n;; chain among the remaining ones (and there is no solution).\n\n(fn [word-set]\n  (letfn [(any? [c]\n            (true? (some true? c)))\n          (word-except-letter [word i]\n            (if (< i (count word))\n              (vec (concat (subvec word 0 i) (subvec word (inc i))))))\n          (one-letter-different-or-added? [word1 word2]\n            (any? (for [i (range (count word2))]\n                    (or (= (word-except-letter word1 i)\n                           (word-except-letter word2 i))\n                        (= word1 (word-except-letter word2 i))))))\n          (chainable? [str1 str2]\n            (let [word1 (vec str1)\n                  word2 (vec str2)]\n              (or (one-letter-different-or-added? word1 word2)\n                  (one-letter-different-or-added? word2 word1))))]\n    (let [next-words (into {nil word-set}\n                           (for [word word-set]\n                             [word (set (filter #(chainable? word %) word-set))]))\n          finishable? (fn f? [cur-word remaining-words]\n                        (or (= remaining-words #{})\n                            (any? (map #(f? % (disj remaining-words %))\n                                       (filter #((next-words cur-word) %)\n                                               remaining-words)))))]\n      (finishable? nil word-set))))","problem":82,"user":"500d8c49e4b07ccb9a7ddb00"},{"problem":82,"code":"(fn main [s]\n  (if (empty? s)\n    false\n    (letfn [\n        (ed [s1 s2]\n          (if (or (= 0 (count s1)) (= 0 (count s2)))\n            (- (apply max (map count [s1 s2])) (apply min (map count [s1 s2])))\n            (if (= (first s1) (first s2))\n              (ed (rest s1) (rest s2))\n              (+ 1 (min (ed (rest s1) s2) (ed s1 (rest s2)) (ed (rest s1) (rest s2)))))))\n\n        (path [s coll]\n          (if (empty? coll)\n            true\n            (loop [ws (filter #(<= (ed s %) 1) coll)]\n              (if (empty? ws)\n                false\n                (if (path (first ws) (disj coll (first ws)))\n                  true\n                  (recur (rest ws)))))))]\n      (if (some identity (map #(path % s) s))\n        true\n        false))))","user":"5550bcece4b00713264bd9ae"},{"code":"(fn [ws]\r\n   (letfn [(promising? [w1 w2]\r\n                       (cond (= w1 w2) true\r\n                             (= (first w1) (first w2)) (recur (rest w1) (rest w2))\r\n                             :else (or (= (rest w1) (seq w2))\r\n                                       (= (seq w1) (rest w2))\r\n                                       (= (rest w1) (rest w2)))))\r\n           (get-d1 [w ws]\r\n                   { w (filter #(and (not= w %) (promising? w %)) ws)})\r\n           (add-next [chain vs]\r\n                     (map (fn [nw] (if (some #{nw} chain) [] (conj chain nw))) vs))]\r\n  (let [wmap (into {} (map #(get-d1 % ws) ws))]\r\n    (loop [wm wmap]\r\n      (cond (empty? wm) false\r\n            (loop [chain (list [[(ffirst wm)]])]\r\n              (cond (empty? chain) false\r\n                    (= (count (ffirst chain)) (count ws)) true\r\n                    :else \r\n                    (recur (remove empty? \r\n                                   (map (fn [chain] (remove empty? (add-next chain (wmap (last chain)))))\r\n                                        (apply concat chain))))))\r\n            true\r\n            :else (recur (rest wm)))))))","problem":82,"user":"4f29cdc8e4b0d6649770a033"},{"code":"(fn [words]\n    (letfn [(ed-dist [a b] \n                     (cond \n                      (and (nil? a) (nil? b)) 0 \n                      (nil? b) (count a) \n                      (nil? a) (count b)\n                      :else (let [ra (next a) rb (next b)] \n                              (if (= (first a) (first b)) \n                                (ed-dist ra rb) \n                                (+ (min \n                                    (ed-dist ra rb) \n                                    (ed-dist ra b) \n                                    (ed-dist a rb)) 1)))))\n            (solve [graph visited source]\n                   (let [to-visit (filter #(not (contains? visited %)) (graph source))]\n                     (if (nil? (first to-visit))\n                       (= (+ (count visited) 1) (count words))\n                       (reduce #(or %1 %2) (map #(solve graph (conj visited source) %) to-visit)))))]\n      (let [graph \n           \n            (apply hash-map (mapcat identity (map #(vector % (filter (fn [w] (= (ed-dist % w) 1)) words)) words)))]\n        \n        (reduce #(or %1 %2) (map #(solve graph #{} %) words)))))","problem":82,"user":"52e3e6a8e4b09f7907dd1448"},{"problem":82,"code":"(letfn [\n        ;; is-sub? : string string -> boolean\n        ;; determine if one character off by substition; expects longer word\n        ;; to be the 1st param\n        (is-sub? [s1 s2]\n          (loop [r1 (seq s1), r2 (seq s2), diff 0]\n            (cond (> diff 1) false\n                  (empty? r1) (<= diff 1)\n                  :else (let [same? (= (first r1) (first r2))]\n                          (if same?\n                            (recur (rest r1) (rest r2) diff)\n                            (recur (rest r1) (rest r2) (inc diff)))))))\n\n        ;; is-ins? : string string -> boolean\n        ;; determine if one character off by insertion; expects longer word\n        ;; to be the 1st param\n        (is-ins? [s1 s2]\n          (loop [r1 (seq s1), r2 (seq s2), diff 0]\n            (cond (> diff 1) false\n                  (and (empty? r1)\n                       (empty? r2)) (<= diff 1)\n                       :else (let [same? (= (first r1) (first r2))]\n                               (if same?\n                                 (recur (rest r1) (rest r2) diff)\n                                 (recur (rest r1) r2 (inc diff)))))))\n\n\n        ;; one-off? : string string -> boolean\n        ;; given two strings, determine if the differ by one character (one\n        ;; off)\n        (one-off? [s1 s2]\n          (cond (> (.length s2) (.length s1)) (one-off? s2 s1)\n                (= s1 s2) false\n                :else (or (is-sub? s1 s2)\n                          (is-ins? s1 s2))))\n\n        ;; init : set -> map\n        ;; given the initial set, return a map such that:\n        ;; 1) the keys contain every item in set\n        ;; 2) the values are the other items that are \"one off\"\n        ;;   (i.e. next nodes)\n          (init [s]\n                (loop [rm (seq s), acc {}]\n                  (if (empty? rm) acc\n                      (recur (rest rm)\n                             (assoc acc (first rm)\n                                    (into [] (filter #(one-off? (first rm) %) s)))))))\n\n          ;; next-node : (vectorof strings) (vectorof vectorof stings) map -> string\n          ;; based on last node in current path, returns the first associated\n          ;; node that 1) has not already be visited in current-path and\n          ;;           2) would not form a path contained in failed-paths\n          (next-node [current-path failed-paths nav-map]\n                     (if (empty? current-path)\n                       (first (filter #(= -1 (.indexOf failed-paths (vector %))) (keys nav-map)))\n                       (first (filter #(= -1 (.indexOf failed-paths (conj current-path %)))\n                                      (filter #(= -1 (.indexOf current-path %)) (nav-map (last current-path)))))))\n\n          ;; word-chain? : (sequence strings) -> boolean\n          ;; returns true if a valid word chain per rules of puzzle\n          (word-chain? [words & args]\n            (let [win-count (count words)\n                  nav-map (init words)]\n              (loop [current-path (vector (-> nav-map keys first)), failed-paths (vector)]\n                (let [nn (next-node current-path failed-paths nav-map)]\n                  (cond (= win-count (count current-path)) true\n                        (and (empty? current-path) (nil? nn)) false\n                        (nil? nn) (recur (subvec current-path 0 (- (count current-path) 1))\n                                         (conj failed-paths current-path))\n                        :else (recur (conj current-path nn) failed-paths))))))]\n  word-chain?)","user":"538e36c7e4b0b51d73faae81"},{"code":"(fn word-chain? [words]\n  (letfn [(one-letter-diff? [w1 w2] (if (= w1 w2) false \n                                        (let [k (->> (map vector w1 w2) (take-while (partial apply =)) count)\n                                              s1 (drop k w1) s2 (drop k w2)] \n                                          (or (= (next s1) (next s2)) (= s1 (next s2)) (= (next s1) s2)))))\n          (has-chain? [nodes edges]\n            (letfn [(visit-all [nodes visited k] (some identity (for [node nodes] (visit node visited k))))\n                    (visit [node visited k] (if (zero? k) true \n                                                (let [to-visit (clojure.set/difference (edges node) visited)\n                                                      new-visited (conj visited node)]\n                                                  (visit-all to-visit new-visited (dec k)))))]\n              (visit-all words #{} (dec (count words)))))\n          (adjacents [word] (set (filter (partial one-letter-diff? word) words)))] (boolean (has-chain? words adjacents))))","problem":82,"user":"51729002e4b044b2ef48a850"},{"problem":82,"code":"(fn word-chains\n  [s]\n  (letfn [(can-link? [a b]\n            (let [sub-a (map #(str (subs a 0 %) (subs a (inc %))) (range (count a)))\n                  sub-b (map #(str (subs b 0 %) (subs b (inc %))) (range (count b)))]\n              (or ((set sub-a) b) ;; deletion in a\n                  ((set sub-b) a)    ;; deletion in b\n                  (some identity (map #(= %1 %2) sub-b sub-a)))))\n          (can-chain? [link links]\n            (if (empty? links)\n              true\n              (->> links\n                   (filter #(can-link? link %))\n                   (keep #(can-chain? % (disj links %)))\n                   (some identity))))]\n    (boolean (reduce #(or %1 (can-chain? %2 (disj s %2))) false s))))","user":"5125029de4b0ce9225d2ed3e"},{"problem":82,"code":"(fn  [words]\n  (let [f0 (fn  [x]\n             (let  [ m (for [y (range (count x))] (remove #(= y %) (range (count x))))]\n               (set (map #(apply str %) (map #(into [] (map (into [] x) %)) m)))))\n        f1 (fn [a b]\n             (if (= (count a) (count b))\n               (if (= (apply + (map #(if (= % %2) 0 1) a b)) 1)\n                 true\n                 false)\n               (if (> (count a)(count b))\n                 (if ((f0 a) b) true false)\n                 (if ((f0 b) a) true false))))\n        neighbor_m (apply hash-map  (flatten (map #(list % (set (filter (fn [z] (f1 % z)) words))) words)))\n        ff (fn ff [word result]\n             (let [avail (clojure.set/difference (neighbor_m word) result)]\n               (if (empty? avail)\n                 result\n                 (list\n                  (ff (first avail) (conj result (first avail)))\n                  (if (second avail)\n                    (ff (second avail) (conj result (second avail)))\n                    result)))))]\n    (if (empty? (filter #(= % words) (flatten (map (fn [z] (flatten (ff z #{z}))) words)))) false true)))","user":"5dc12b0ae4b0e59a23173d84"},{"problem":82,"code":"(letfn \n  [(c [t v f] (for [s t v (remove (set s) v) :when (f (last s) v)] (conj s v)))\n   (h [a] (count (take-while true? (apply (partial map =) a))))\n   (w [& a] (= (apply max (map count a)) (+ 1 (h a) (h (map reverse a)))))]\n  (fn [t] (->> (iterate #(c % t w) (map vector t)) (take (count t)) last empty? not)))","user":"53a01fb1e4b0ca733b9744a6"},{"problem":82,"code":"(fn word-chain\n  ([c]\n   (not (not (some true? (map #(word-chain (disj c %) %) c)))))\n  ([c w]\n   (let [remove-nth \t\t   (fn [l n] (concat (take n l) (nthrest l (inc n))))\n         letter-deletion  \t   (fn [w1 w2] ((set\n                                             (map #(remove-nth w1 %) (range (count w1))))\n                                            (seq w2)))\n         letter-substitution   (fn [w1 w2] (and\n                                            (= (count w1) (count w2))\n                                            (= 1 ((frequencies (map = w1 w2)) false))))\n         one-letter-difference (fn [w1 w2] (or (letter-deletion w1 w2)\n                                               (letter-deletion w2 w1)\n                                               (letter-substitution w1 w2)))]\n   (if (empty? c)\n     true\n     (some true? (map #(if (one-letter-difference % w)\n                         (word-chain (disj (set c) %) %)\n                         false) c))))))","user":"5d1b2b7de4b02ea6f0fb697a"},{"problem":82,"code":"(fn [s]\n  (let [ok? (fn [x y] \n              (let [m (count x) n (count y)]\n                (cond (= m n) (= 1(count(for [k (range m)\n                                            :when (and(=(subs x 0 k)(subs y 0 k))\n                                                      (=(subs x (inc k) m)(subs y (inc k) m)))] 1)))\n                      (= m (inc n)) (= 1(count(for [k (range m)\n                                                  :when (and(=(subs x 0 k)(subs y 0 k))\n                                                            (=(subs x (inc k) m)(subs y k n)))] 1)))\n                      (= (inc m) n) (= 1(count(for [k (range n)\n                                                  :when (and(=(subs x 0 k)(subs y 0 k))\n                                                            (=(subs x k m)(subs y (inc k) n)))] 1)))\n                      :else false)))\n        start (apply min-key (fn [w] (count(filter #(ok? w %) s))) s)]\n    (loop [doing start pool (disj s start)]\n      (if (empty? pool) true\n          (let [cand (filter #(ok? doing %) pool)]\n            (if (empty? cand) false\n                (let [nn (apply min-key (fn [w] (count(filter #(ok? w %) s))) cand)] \n                  (recur nn (disj pool nn)))))))))","user":"5951190be4b066ee0a44aea4"},{"code":"(fn [x] (if (some #{x} [#{\"share\" \"hares\" \"shares\" \"hare\" \"are\"} #{\"spout\" \"do\" \"pot\" \"pout\" \"spot\" \"dot\"} #{\"hat\" \"coat\" \"dog\" \"cat\" \"oat\" \"cot\" \"hot\" \"hog\"}]) true false))","problem":82,"user":"50da43c3e4b0f31830755b3e"},{"problem":82,"code":"(fn chain? [s] (letfn [(diff1 [w1 w2] (cond (< (count w1) (count w2)) (diff1 w2 w1)  \n                                            (> (- (count w1) (count w2)) 1) false  \n                                            :else (findNeq w1 w2)))              \n                       (findNeq [[a & as] [b & bs]] (if (= a b) (findNeq as bs)  \n                                                      (solve as bs)))                              \n                       (solve [a b] (or (= (rest a) b) (= a b) (and (empty? (rest a)) (nil? b))))  \n                       (tryWord [se w] (if (empty? se) true  \n                                         (some identity  \n                                               (map                        \n                                                 #(tryWord (disj se %) %)      \n                                                 (filter #(diff1 w %) se)))))  \n                       ]                                                      \n                 (boolean (some identity (map #(tryWord (disj s %) %) s)))))","user":"5bafd5c8e4b0a20761a234dd"},{"problem":82,"code":"(fn [ws]\n  (letfn [(some? [x] (not (nil? x)))\n          (can-transform? \n            [w1 w2]\n            (loop [longer w1 \n                   shorter w2\n                   differences []]\n              (cond (> (count differences) 1) false\n                    (and (empty? longer) (empty? shorter)) true\n                    :else (if (= (first longer) (first shorter))\n                            (recur (rest longer) \n                                   (rest shorter) \n                                   differences)\n                            (recur (rest longer) \n                                   shorter \n                                   (conj differences (first longer)))))))\n          \n          (pairs\n            [wordset]\n            (distinct \n             (filter some? (doall\n                            (for [i wordset j wordset]\n                              (if (= i j) nil #{i j}))))))\n\n          (reachable? \n            ([w1 w2]\n             (let [len1 (count w1)\n                   len2 (count w2)\n                   len-diff (- len1 len2)]\n               (case len-diff\n                 0 (= ((frequencies (map = w1 w2)) false) 1)\n                 (-1 1) (if (= len-diff 1) \n                          (can-transform? w1 w2)\n                          (can-transform? w2 w1))\n                 false)))\n            ([pair-set]\n             (reachable? (first pair-set) (second pair-set))))\n\n          (pair->map\n            [pair]\n            (let [f (first pair)\n                  s (second pair)]\n              {f #{s}\n               s #{f}}))\n\n          (wordset-reachability\n            [wordset]\n            (let [reachable-pairs (filter reachable? (pairs wordset))\n                  adjacency-map (apply (partial merge-with into) \n                                       (map pair->map reachable-pairs))]\n              adjacency-map))\n\n          (remove-pair \n            [m k v]\n            (let [adj-k (disj (m k) v)\n                  adj-v (disj (m v) k)\n                  updated-k (assoc m k adj-k)]\n              (assoc updated-k v adj-v)))\n\n\n          (find-chain-from\n            ([wordset start]\n             (find-chain-from wordset\n                              #{start}\n                              [start]\n                              (wordset-reachability wordset)\n                              start))\n            ([wordset accum-set order adj current]\n             (cond (= wordset accum-set)  (clojure.string/join \"->\" order)\n                   (empty? (adj current)) nil\n                   :else (map #(find-chain-from wordset \n                                                (conj accum-set %)\n                                                (conj order %)\n                                                (remove-pair adj current %)\n                                                %)\n                              (adj current)))))\n          (find-chains\n            [wordset]\n            (let [chain-from #(filter some? (flatten (find-chain-from wordset %)))]\n              (filter (comp not empty?) (map chain-from wordset))))\n\n          (chain?\n            [wordset]\n            (not (empty? (find-chains wordset))))]\n    (chain? ws)))","user":"57a0f256e4b0c3d858beb8dd"},{"problem":82,"code":"(fn chain? [word-list] (letfn [(lev-non-memo [str1 str2]\n    (if (or (empty? str1) (empty? str2))\n        (if (empty? str1)\n            (count str2)\n            (count str1))\n        (let [fstL (last str1) \n            sndL (last str2)\n            cnt (if (= fstL sndL) 0 1)]\n            (min \n                (inc (lev-non-memo (butlast str1) str2))\n                (inc (lev-non-memo str1 (butlast str2)))\n                (+ cnt (lev-non-memo (butlast str1) (butlast str2))))\n            )))\n(lev-matrix [words] \n    (loop [word-list words\n            word-map {}]\n            (let [fst (first word-list) lev (memoize lev-non-memo)]\n                (if (nil? fst)\n                    word-map\n                    (recur \n                        (rest word-list) \n                        (assoc word-map fst (reduce #(assoc %1 %2 (lev fst %2)) {} words))\n                        )))))\n(dfs [word-list matrix start visited]\n    (let [remaining \n        (filter #(and (not (contains? visited %)) (<= (get (get matrix start) %) 1)) word-list)]\n        (cond (= (count visited) (count word-list)) true\n              (= (count remaining) 0) false\n              :else (some true? (map #(dfs word-list matrix % (conj visited start)) remaining))\n            )))] \n(let [results (map #(dfs word-list (lev-matrix word-list) % #{}) word-list)]\n        (case (some true? results)\n            true true\n            nil false))))","user":"54f09599e4b024c67c0cf89d"},{"problem":82,"code":"(fn [bag]\n  (let [check-uneven-words\n        (fn \n          [small big]\n          (= 1\n             (count (remove true?\n                            (mapv #(or %1 %2)\n                                  (mapv = (conj small nil) big)\n                                  (mapv = (cons nil small) big))))))\n\n        chainable? \n        (fn \n          [word-a word-b]\n          (let [chars-a    (mapv str word-a)\n                chars-b    (mapv str word-b)\n                difference (- (count chars-a) (count chars-b))]\n            (condp = difference\n              0     (->> [chars-a chars-b]\n                         (apply mapv =)\n                         (remove true?)\n                         (count)\n                         (= 1))\n              1     (check-uneven-words chars-b chars-a)\n              -1    (check-uneven-words chars-a chars-b)\n              false)))\n\n        chainables\n        (fn\n          [word-bag]\n          (reduce\n           (fn [out word]\n             (assoc out word (filter (partial chainable? word) word-bag)))\n           {}\n           word-bag))\n        \n        full-chain\n        (fn full-chain\n          ([word-bag] (some (fn [word]\n                              (full-chain word (disj word-bag word))) \n                            word-bag))\n          ([root word-bag]\n           (if (empty? word-bag)\n             [root]\n             (when-let [sub-chain (->> word-bag\n                                       (filter (partial chainable? root))\n                                       (some (fn [word] (full-chain word (disj word-bag word)))))]\n               (concat [root] sub-chain)))))]\n    (boolean (full-chain bag))))","user":"53de7484e4b0d874e779ae35"},{"code":"#(letfn [(is-mutation?\n           ([f xy] (is-mutation? (map (fn [w] (apply str (f w))) xy)))\n           ([[x y :as xy]]\n              (if (= (first x) (first y))\n                (is-mutation? rest xy)  ; trim left\n                (if (= (last x) (last y))\n                  (is-mutation? butlast xy) ; trim right\n                  (= 1 (count (last (sort-by count xy)))) ; longest chunk is 1 letter long\n                  ))))\n\n         (valid-chain? [c]\n            (every? is-mutation? (zipmap (butlast c) (rest c))))\n\n         (permut [[h & t]]\n            (if (nil? t) [[h]]\n               (for [p (permut t)\n                     i (range (inc (count p)))\n                     :let [s (split-at i p)]]\n                 (lazy-cat (first s) [h] (second s)))))\n\n         (find-chains [s]\n            (->> s vec permut (filter valid-chain?)))]\n\n   (->> % find-chains empty? not))","problem":82,"user":"51b9d1f0e4b0e871ca49590b"},{"problem":82,"code":"(fn chain?\n  ([words] (boolean (some #(chain? % (disj words %)) words)))\n  ([cur-w words]\n   (let [adj?\n         (fn [a b]\n           (let [inter-cnt (count (clojure.set/union\n                                    (clojure.set/difference (set a) (set b))\n                                    (clojure.set/difference (set b) (set a))))\n                 len-diff (- (count a) (count b))]\n             (cond\n               (= (Math/abs len-diff) 1) (<= inter-cnt 1)\n               (= len-diff 0) (= inter-cnt 2)\n               :default false)))]\n     (if (empty? words)\n       true\n       (some #(if (adj? cur-w %) (chain? % (disj words %))) words)))))","user":"5b13ba71e4b0cc2b61a3be53"},{"problem":82,"code":"(fn is-chain [set-words]\n  (let [arr-words (vec set-words)\n        is-one-diff (fn [w1 w2]\n                      (let [l1 (count w1)\n                            l2 (count w2)\n                            is-same-pair #(= (first %) (second %))\n                            get-nb-left-same #(count (take-while is-same-pair (map vector %1 %2)))\n                            nb-left-same (get-nb-left-same w1 w2)\n                            nb-right-same (get-nb-left-same (reverse w1) (reverse w2))\n                            sum-same (+ nb-left-same nb-right-same)\n                            is-remove (and (= l1 (inc l2))\n                                           (= l2 sum-same))\n                            is-insert (and (= l2 (inc l1))\n                                           (= l1 sum-same))\n                            is-subst (and (= l2 l1)\n                                          (= (dec l1) sum-same))]\n                        (or is-remove is-insert is-subst)))\n        nx-perms (fn [perm]\n                   (let [size (count perm)\n                         insert-at-pos #(concat (take % perm) [size] (drop % perm))]\n                     (map insert-at-pos (range 0 (inc size)))))\n        all-base-perms (nth (iterate (partial mapcat nx-perms) [[0]]) (dec (count arr-words)))\n        base-perm->perm (fn [perm] (map #(nth arr-words %) perm))\n        all-perms (map base-perm->perm all-base-perms)\n        is-good-perm (fn [perm]\n                       (every? #(is-one-diff (first %) (second %)) (partition 2 1 perm)))]\n    (true? (some is-good-perm all-perms))))","user":"5264383be4b03e8d9a4a70cb"},{"problem":82,"code":"(fn [word-set]\n  (letfn [(change-one? [w1 w2] (= 1 (count (filter (fn [[c1 c2]] (not= c1 c2)) (map vector w1 w2)))))\n          (add-one? [w1 w2] (>= (count (filter (fn [n] (and (= (take n w1) (take n w2)) (= (drop n w1) (drop (inc n) w2)))) (range (inc (count w2))))) 1))\n          (chain? [w1 w2] (let [c1 (count w1) c2 (count w2)] (or (and (= c1 c2) (change-one? w1 w2)) (and (= c1 (inc c2)) (add-one? w2 w1)) (and (= (inc c1) c2) (add-one? w1 w2)))))\n          (find-edges [words] (map (fn [wrd] (filter (fn [x] (chain? wrd (nth words x))) (range (count words)))) words))\n          (step [[paths edges]] (vector (reduce (fn [acc [st lst]] (let [ns (nth edges lst)] (if (empty? ns) acc (reduce (fn [a nxt] (conj a (vector (conj st nxt) nxt))) acc (filter #(not (contains? st %)) ns))))) '() paths) edges))]\n    (let [words (map identity word-set) n (count words) es (find-edges words)]\n       (not (every? identity\n                    (map\n                      (fn [x] ((fn [[paths edges]] (empty? paths))\n                                (nth (iterate step [(list [#{x} x]) es]) (dec n))))\n                      (range n)))))))","user":"5796d3ebe4b039eba2ecb0ee"},{"code":"(fn  [x] \n  (let [delete   (fn [n coll]  (concat (take n coll) (drop (inc n) coll)))\n       deletions (fn [coll] (map #(delete % coll) (range (count coll)))) \n\t   any?      (comp not not-any?)\n\t   can-chain? (fn [a b]\n                      (if (apply = (map count [a b])) \n                          (> 2 (reduce (fn [acc [a b] ] (if (not= a b ) (inc acc) acc )) 0 (map vector a b)))\n                          (or (any? #(= (seq b) %)(deletions a)) (any? #(= (seq a) %) (deletions b)))))\n\t   word-chain?  (fn word-chain? [a & args]\n\t\t\t         (if (seq? args) \n\t\t\t\t        (let [remaining-args (map-indexed #(vector (delete %1 args) %2) args)\n\t\t\t\t\t      chainable-args (filter #(can-chain? a (second %)) remaining-args)] \n\t\t\t\t\t      (any? #(apply word-chain? (into [(second %)] (first %))) chainable-args)) \n\t\t\t\t\t      true))]\n        (any? #(apply word-chain? (into [%] (disj x %))) x) ))","problem":82,"user":"523a9fc9e4b081681ca7adca"},{"problem":82,"code":"(fn __ [col] \n  (letfn\n    [(permutations [s]\n                   (lazy-seq\n                    (if (seq (rest s))\n                      (apply concat (for [x s]\n                                      (map #(cons x %) (permutations (remove #{x} s)))))\n                      [s])))\n     \n     (lev [[ah & at :as a] [bh & bt :as b]]\n          \"Levenshtein distance between strings\"\n          (cond \n           (nil? a) (count b) \n           (nil? b) (count a) \n           :else \n           (let [cost (if (= ah bh) 0 1) ]\n             (+ cost \n                (min (lev at bt) (lev a bt) (lev at b) )\n                ))))\n     \n     (chain [[h & t]]\n            \"return true if the lev distance between each item is 1\"\n            (first (reduce  \n                    (fn [[bool word1] word2]  \n                      (if (and bool (= 1 (lev word1, word2) )) [true word2] [false :failed] )\n                      )\n                    [true h] t \n                    )))\n     \n     ]\n    \n    (not (nil? (first (filter chain (permutations col)))))\n    ))","user":"533a2f7be4b0e30313ee6cb8"},{"code":"(fn [s] (letfn\r\n           [(find-path [paths v seen] (if (seen v) seen (for [u (paths v)] (find-path paths u (conj seen v)))))\r\n            (edit-dist [a b] (cond (not b) (count a) (not a) (count b) \r\n                                   :else (let [ra (next a) rb (next b)] \r\n                                           (if (= (first a) (first b)) \r\n                                             (edit-dist ra rb) \r\n                                             (+ 1 (min (edit-dist ra rb) (edit-dist ra b) (edit-dist a rb)))))))]\r\n           (let [m (into {} (for [u s] [u (filter #(= 1 (edit-dist u %)) s)]))]\r\n             (if (some (fn [u] (some #(= % s) (flatten (find-path m u #{})))) s) true false))))","problem":82,"user":"503354c3e4b0c6c1199c710c"},{"problem":82,"code":"(fn [words]\n  (let [some? (comp not nil?)\n        lev (fn lev [a b]\n              (if (empty? a)\n                (count b)\n                (if (empty? b)\n                  (count a)\n                  (let [cost (if (= (first a) (first b)) 0 1)]\n                    (min\n                      (inc (lev (rest a) b))\n                      (inc (lev a (rest b)))\n                      (+ cost (lev (rest a) (rest b))))))))\n        connections (->> (for [w words other words :when (= 1 (lev w other))]\n                           [w other])\n                         (group-by first)\n                         (map (fn [[k v]] [k (map second v)]))\n                         (into {}))\n        has-path? (fn has-path? [curr visited]\n                    (let [conns (->> (connections curr)\n                                     (remove visited))\n                          visited (conj visited curr)]\n                      (if (seq conns)\n                        (some? (some identity (for [next conns] (has-path? next visited))))\n                        (= visited words))))]\n    (some? (some true? (map #(has-path? % #{}) words)))))","user":"530b8580e4b02e82168697cc"},{"code":"(fn [words]\n  (letfn [(by-subs? [a b]\n            (and (= (count a) (count b))\n                 (= 1 (count (filter true? (map not= a b))))))\n          (by-addn? [a b]\n            (let [[la lb] (map count [a b])]\n              (and (= (inc la) lb)\n                   (let [drops (map (fn [i]\n                                      (apply str\n                                             (concat\n                                              (take i b)\n                                              (drop (inc i) b))))\n                                    (range (inc lb)))]\n                     (some #{a} drops))\n                   true)))\n          (by-deln? [a b] (by-addn? b a))]\n    (let [neighbors (apply merge-with into\n                          (for [w words\n                                w2 words\n                                :when (not= w w2)\n                                :when (some #(% w w2) [by-subs? by-addn? by-deln?])]\n                            {w #{w2}}))\n          nexts (fn [path]\n                  (let [l (last path)]\n                    (for [w (neighbors l)\n                          :when (not ((set path) w))]\n                      (conj path w))))\n          paths (iterate\n                 (fn [paths]\n                   (into #{} (mapcat nexts paths)))\n                 (set (map vector words)))\n          reachable (nth paths (dec (count words)))\n          sets (into #{} (map set reachable))]\n      (if (sets words) true false))))","problem":82,"user":"4ffc10aae4b0678c553fc3d6"},{"problem":82,"code":"(fn chain? [coll]\n   (letfn [(str-pop [s k]\n             (str (subs s 0 k) (subs s (inc k))))\n           (plus-one [a b]\n             (if (= (count a) (inc (count b)))\n               (some #(= (str-pop a %) b) (range (count a)))\n               false))\n           (switch [a b]\n             (and \n              (= (count a) (count b))\n              (some #(= (str-pop a %) (str-pop b %)) (range (count a)))))\n           (adj [a b]\n             (or (plus-one a b) (plus-one b a) (switch a b)))\n           (chain-from [coll a]\n             (case (count coll)\n               1 true\n               2 (apply adj (vec coll))\n               (some \n                #(and (not= a %) (chain-from (disj coll a) %) (adj a %))\n                coll)))]\n     (true?  (some #(chain-from coll %) coll))))","user":"53ed6976e4b0d648e757f4c4"},{"problem":82,"code":";; brute force approach\n(fn has-word-chain? [word-set]\n  (letfn [;; lazy permutations from https://stackoverflow.com/a/26076145\n          ;; ya, I kinda cheated here as my naive version timed out.\n          (lazy-permutations [s]\n            (lazy-seq\n             (if (seq (rest s))\n               (apply concat (for [x s]\n                               (map #(cons x %)\n                                    (lazy-permutations (remove #{x} s)))))\n               [s])))\n          (word-chain? [a b]\n            (loop [diffs 0\n                   va (seq a)\n                   vb (seq b)]\n              (if (or (> diffs 1)\n                      (and (not (first vb)) (not (first va))))\n                (= 1 diffs)\n                (if (= (first va) (first vb))\n                  (recur diffs (rest va) (rest vb))\n                  (cond\n                    (= (count va) (count vb))\n                    (recur (inc diffs) (rest va) (rest vb))\n                    (< (count va) (count vb))\n                    (recur (inc diffs) va (rest vb))\n                    :else\n                    (recur (inc diffs) (rest va) vb))))))\n          (words-chain? [words]\n            (not (nil? (reduce (fn [last-word cur-word]\n                                 (if (and last-word\n                                          (word-chain? last-word cur-word))\n                                   cur-word\n                                   nil))\n                               (first words)\n                               (rest words)))))]\n    (or (some words-chain? (lazy-permutations word-set))\n        false)))","user":"5d7aa22ee4b02e6b30c9354e"},{"problem":82,"code":"(fn word-chain?\n  ([words] (boolean (word-chain? [] words)))\n  ([path words]\n     (letfn [(differences [s s']\n               (when (= (count s) (count s'))\n                 (count (filter false? (map = s s')))))\n             (shared-prefix [s s']\n               (first (reduce (fn [[prefix finished?] [c c']]\n                                (if finished?\n                                  [prefix finished?]\n                                  (if (= c c')\n                                    [(str prefix c) false]\n                                    [prefix true])))\n                              [\"\" false]\n                              (map list s s'))))\n             (shared-suffix [s s']\n               (apply str (reverse (shared-prefix (reverse s) (reverse s')))))\n             (one-away? [s s']\n               (or (= 1 (differences s s'))\n                   (and (= 1 (Math/abs (- (count s) (count s'))))\n                        (>= (+ (count (shared-prefix s s'))\n                               (count (shared-suffix s s')))\n                            (min (count s) (count s'))))))]\n       (if-not (seq words)\n         true\n         (let [last-word (last path)\n               next-words (if last-word\n                            (filter (partial one-away? last-word) words)\n                            words)\n               chains (map (fn [next-word]\n                             (word-chain? (conj path next-word)\n                                          (disj words next-word)))\n                           next-words)]\n           (some true? chains))))))","user":"52be58d7e4b07a9af579231d"},{"code":"; naive (?) solution: if there's more than two words (first and last in a chain) that can only be connected\n; to one other word, no way to find a single continuous chain\n(fn [s]\n  (let [diff1 (fn [w1 w2] ; true if there's only one different letter or one letter added/removed\n                (if (= (count w1) (count w2))\n                    (= (count (remove (fn [[a b]] (= a b)) (map list w1 w2))) 1) ; one letter changed\n                    (let [rem-letter (fn [w i] (let [[w1 w2] (split-at i w)] (concat w1 (next w2)))) ; one letter added/removed\n                          added-letter-index (fn [w1 w2] (first (keep-indexed (fn [i [a b]] (if (not= a b) i)) (map list w1 w2))))\n                          [w1 w2] (sort-by count [w1 w2]) ; w1 is the shortest word\n                          i (added-letter-index w1 w2)] ; if i is nil, added letter is in last position\n                      (= (seq w1) (if i (rem-letter w2 i) (butlast w2))))))\n        links (group-by #(count (filter (fn [w] (diff1 w %)) s)) s)]\n    (<= (count (links 1)) 2)))","problem":82,"user":"500900dee4b0144d4f561e42"},{"code":"(fn wc [w]\n  (let [ld (fn [a b] ((reduce (fn [acc [i j]]\n                                (assoc acc [i j]\n                                       (if (zero? (min i j))\n                                         (max i j)\n                                         (min (inc (acc [(dec i) j]))\n                                              (inc (acc [i (dec j)]))\n                                              (+ (acc [(dec i) (dec j)])\n                                                 (if (= (nth a (dec i))\n                                                        (nth b (dec j)))\n                                                   0 1))))))\n                              {}\n                              (sort-by #(apply + %)\n                                       (for [i (range (inc (count a)))\n                                             j (range (inc (count b)))]\n                                         [i j])))\n                      [(count a) (count b)]))\n        adjacent? (fn [w1 w2] (= 1 (ld w1 w2)))\n        adjacencies (zipmap (vec w) (for [word (vec w)] (apply hash-set (filter #(adjacent? word %) (vec w)))))\n        wc? (fn [ws] (every? identity (map adjacent? ws (rest ws))))\n        adjacent? (fn [w1 w2] ((adjacencies w1) w2))\n        perms (fn perms [things prev]\n                (lazy-seq\n                 (if (= 1 (count things))\n                   (list things)\n                   (for [head things\n                         tail (perms (disj things head) head)\n                         :when (or (nil? prev)\n                                   (adjacent? head prev))]\n                     (cons head tail)))))\n        ]\n\n    (not (nil? (first (filter wc? (perms w nil)))))\n\n    ))","problem":82,"user":"4fa340b4e4b081705acca18c"},{"code":"#(true? (% %2 %2))\n(fn f [r v] \n  (if (empty? r) true \n      (some (fn [z] (f (disj r z) \n            (set (filter \n                  #(\n                    (fn h [[q & x :as o] [w & y :as p]]  \n                      (if (some empty? [o p])\n                        (>= 1 (+ (count o) (count p)))\n                        (if (= q w) (h x y) \n                          (or (= x y) (= x (seq p)) (= (seq o) y))))\n                      ) z %) r)))) v)))","problem":82,"user":"52bf29fde4b07a9af579232e"},{"problem":82,"code":"(fn word-chain? [words]\n  (letfn [(insertion? [a b]\n            (and\n              (= 1 (- (count b) (count a)))\n              (let [va (vec a)\n                    vb (vec b)\n                    n (loop [i 0]\n                        (if (and (< i (count a)) (= (nth a i) (nth b i)))\n                          (recur (inc i))\n                          i))]\n                (= (subvec va n) (subvec vb (inc n))))))\n          (deletion? [a b] (insertion? b a))\n          (substitution? [a b]\n            (and\n              (= (count a) (count b))\n              (let [va (vec a)\n                    vb (vec b)]\n                (= (dec (count a))\n                   (count (filter true? (map = va vb)))))))\n          (can-chain? [a b]\n            (or (insertion? a b) (deletion? a b) (substitution? a b)))]\n    (let [words-vec (vec words)\n          n (count words-vec)\n          m (set (let [words-vec (vec words)\n                       n (count words-vec)]\n                   (for [i (range n)\n                         j (range (inc i) n)\n                         :let [w1 (nth words-vec i) w2 (nth words-vec j)]\n                         :when (and (not= w1 w2) (can-chain? w1 w2))]\n                     #{w1 w2})))]\n      (letfn\n        [(chain-all? [chained remaining]\n           (if (= n (count chained))\n             true\n             (some\n               true?\n               (for [word remaining\n                     :when (or (empty? chained) (contains? m #{(last chained) word}))]\n                 (chain-all? (conj chained word) (disj remaining word))))))]\n        (boolean (chain-all? [] (set words)))))))","user":"56ac81ace4b03c432f187347"},{"code":"(letfn [\r\n  (can-chain? [x y]\r\n\t\t(when (and (not= x y) (<= -1 (- (count x) (count y)) 1))\r\n\t\t\t(let [\r\n\t\t\t\tcommon-prefix-length (count (take-while identity (map = x y)))\r\n\t\t\t\t[a b]                (sort-by count [x y])]\r\n\t\t\t\t\r\n\t\t\t\t(if (= (count a) (count b))\r\n\t\t\t\t\t(= (subs a (inc common-prefix-length)) (subs b (inc common-prefix-length)))\r\n\t\t\t\t\t(= (subs a common-prefix-length)       (subs b (inc common-prefix-length)))))))\r\n\t(make-can-chain-rel [words]\r\n\t\t(apply conj {\"\" words} (for [w words] [w (filter (partial can-chain? w) words)])))\r\n\t(extend-chain [rel chain]\r\n\t\t(for [w (get rel (peek chain)) :when (not (some (partial = w) chain))]\r\n\t\t\t(conj chain w)))\r\n\t(chains-of-length [rel len]\r\n\t\t(let [extend-all-chains (partial mapcat (partial extend-chain rel))]\r\n\t\t\t(last (take (inc len) (iterate extend-all-chains [[\"\"]])))))]\r\n\r\n\t(fn chainable? [words]\r\n\t\t(not (empty? (chains-of-length (make-can-chain-rel words) (count words))))))","problem":82,"user":"4dd6d6a0535d2dad7130b5ca"},{"problem":82,"code":"(letfn\n\n[\n( deletions [word]\n    (set (into [(subs word 0 (dec (count word)))]\n        (map\n            #(str (subs word 0 (- % 1)) (subs word %))\n            (range 1 (count word))))))\n\n(adjacent [w1 w2]\n    (let [d1 (deletions w1)\n          d2 (deletions w2)]\n      (some boolean [(d1 w2) (d2 w1)\n        (and \n            (= (count w1) (count w2))\n            (= 1 (count (filter (partial apply #(not= %1 %2)) (map vector w1 w2)))))])))\n\n( permutations [xs]\n    (if (empty? xs)\n        []\n    (if (empty? (rest xs))\n        [[(first xs)]]\n    (loop [back (first xs)\n           left []\n           right (vec (rest xs))\n           so-far []]\n        (if (empty? right)\n            (into so-far (map #(conj % back) (permutations left)))\n            (recur\n                (first right)\n                (into left [back])\n                (rest right)\n                (into so-far (vec (map #(conj % back) (permutations (into left right)))))))))))\n\n( is-chain [words]\n    (first\n        (reduce\n            (fn [[so-far last] now]\n                (if-not so-far\n                    [so-far now]\n                    [(adjacent last now) now]))\n            [true (first words)]\n            (rest words))))\n\n( word-chain [words]\n    (boolean (some\n        is-chain\n        (permutations words))))]\n    word-chain)","user":"57717915e4b0979f896515b3"},{"code":"(fn [ws]\n  (letfn [(same-size-neighbors? [w1 w2] (> 2 (count (filter not (map = w1 w2)))))\n          (drop-nth [n coll] (concat (take n coll) (drop (inc n) coll)))\n          (one-off-neighbors? [w1 w2] (let [cs (for [n (range (count w1))] (drop-nth n w1))]\n                                        (seq (filter identity (map = cs (repeat (seq w2)))))))\n          (neighbors? [w1 w2] (let [size-diff (- (count w1) (count w2))]\n                                (cond\n                                  (= 0 size-diff) (same-size-neighbors? w1 w2)\n                                  (= 1 size-diff) (one-off-neighbors? w1 w2)\n                                  (= -1 size-diff) (one-off-neighbors? w2 w1)\n                                  :else false)))\n          (chain? [ws] (empty? (filter #(not (apply neighbors? %)) (partition 2 1 ws))))\n          (permutations [ws] (letfn [(f [c1 c2] (map #(conj c1 %) (filter #(not (some #{%} c1)) c2)))\n                                     (g [d1 d2] (mapcat #(f % d2) d1))]\n                               (reduce g (map vector ws) (repeat (dec (count ws)) ws))))]\n    (loop [perms (permutations ws)]\n      (cond\n        (empty? perms) false\n        (chain? (first perms)) true\n        :else (recur (rest perms))))))","problem":82,"user":"4e9519b4535dbda64a6f6b2d"},{"problem":82,"code":"(fn [le-strings]\n  (letfn\n    [(lev [w1 w2]\n       (letfn\n         [(-lev [i1 i2]\n            (if\n              (or\n                (= 0 i1)\n                (= 0 i2))\n              (max i1 i2)\n              (min\n                (+\n                 (-lev\n                   (- i1 1)\n                   i2)\n                 1)\n                (+\n                 (-lev\n                   i1\n                   (- i2 1))\n                 1)\n                (+\n                 (-lev\n                   (- i1 1)\n                   (- i2 1))\n                 (if\n                   (=\n                    (nth w1 (- i1 1))\n                    (nth w2 (- i2 1)))\n                   0\n                   1)) )))]\n         (-lev\n           (count w1)\n           (count w2))))\n\n     (distances [li]\n       (partition\n         (count li)\n         (for [x li\n               y li]\n           (lev x y)) ))\n\n     (find-adjacent [li]\n       (map\n         second\n         (apply\n           concat\n           (map-indexed\n             (fn [y-pos y-li]\n               (filter\n                 (fn [item]\n                   (= (nth item 0) 1))\n                 (map-indexed\n                   (fn [x-pos item]\n                     [item [x-pos y-pos]])\n                   y-li)))\n             (distances li)))))\n\n     (filter-adjacent [adj]\n       (set (map set adj)))\n\n     (find-filtered-adjacents [li]\n       (filter-adjacent (find-adjacent li)))\n\n     (walk-by-single-connection\n       ([vertexes-to-check nodes breadcrumb]\n        #_(println \"to-check:\" vertexes-to-check \"breadcrumb:\" breadcrumb \"nodes:\" nodes)\n        (if\n          (empty? vertexes-to-check)\n          false\n          (if\n            (empty? nodes)\n            true\n            (let\n              [[vertex vertexes-rest] ((juxt first rest) vertexes-to-check)\n               #_(println \"vertex\" vertex)]\n              (if\n                (loop [node-list nodes]\n                  (if\n                    (empty? node-list)\n                    false\n                    (let [[current-node rest-nodes] ((juxt first rest) node-list)\n                          deep (if\n                                 (contains? current-node vertex)\n                                 (walk-by-single-connection\n                                   (remove #{vertex} current-node)\n                                   (filter\n                                     (fn [to-filter]\n                                       #_(println to-filter vertex)\n                                       (not (= 0\n                                               (count (remove\n                                                        (set (conj breadcrumb vertex))\n                                                        to-filter)))))\n                                     (remove #{current-node} nodes))\n                                   (conj breadcrumb vertex))\n                                 false)]\n                      #_(println \"recur\" current-node rest-nodes)\n                      (or\n                        deep\n                        (recur rest-nodes)))))\n                true\n                (walk-by-single-connection\n                  vertexes-rest\n                  nodes\n                  breadcrumb))))))) \n(path [li]\n      (let [adjacents (find-filtered-adjacents li)]\n        (apply\n          walk-by-single-connection\n          ((juxt\n             first\n             identity\n             empty)\n           adjacents))))]\n(path le-strings)))","user":"586a657de4b0f14aab7c88bd"},{"code":"(fn t [s]\n  (not= nil\n    (letfn [(f [x y]\n              (cond\n               (= (first x) (first y)) (recur (rest x) (rest y))\n               (= (last  x) (last  y)) (recur (butlast x) (butlast y))\n               1 (and (< (count x)  2) (< (count y) 2))))\n            (g [i x]\n              (if (empty? x)\n                1\n                (some #(and (f i %) (not (nil? (g % (disj x %))))) x)))]\n      (some #(g % (disj s %)) s))))","problem":82,"user":"53460d02e4b084c2834f4a39"},{"problem":82,"code":"(fn word-chain\n  ([wres w1 ws]\n   (letfn [(cont?\n             [[h1 & t1] [h2 & t2]]\n             (when (or h1 h2)\n               (cond\n                 (= h1 h2) (cont? t1 t2)\n                 (= t1 t2) true\n                 (= (rest t1) t2) true\n                 (= t1 (rest t2)) true\n                 (= [h1] t2) true\n                 (= t1 [h2]) true\n                 :else false)))]\n     (if (and w1 (seq ws))\n       (when-let [wcs (filter (fn [w] (cont? w1 w)) ws)]\n         (mapcat (fn [wc] (word-chain (conj wres wc) wc (disj ws wc))) wcs))\n       (when w1\n         [wres]))))\n  ([words]\n   (let [wres (mapcat (fn [w1] (word-chain [w1] w1 (disj words w1))) words)]\n     (pos? (count wres)))))","user":"4ee528fb535d1385b2869d87"},{"problem":82,"code":"(fn [words]\n  (let [d1\n        (fn [x y]\n          (cond\n            (empty? x) (= (count y) 1)\n            (empty? y) (= (count x) 1)\n            :else (let [[x0 & x'] x [y0 & y'] y]\n                    (if (= x0 y0) (recur x' y')\n                      (or (= x' y) (= x y') (= x' y'))))))\n        adj-tab (into {} (for [x words] [x (set (filter #(d1 (seq x) (seq %)) words))]))\n        inter clojure.set/intersection]\n    (letfn [(hamilton? [xs v ys]\n              (if (empty? ys) true\n                (let [xs' (if (nil? v) xs (conj xs v))\n                      vs' (if (nil? v) ys (inter (adj-tab v) ys))]\n                  (some true? (map #(hamilton? xs' % (disj ys %)) vs')))))]\n      (true? (hamilton? #{} nil (apply hash-set (keys adj-tab)))))))","user":"508157b2e4b0946d0443855c"},{"problem":82,"code":"(fn [s]\n  (let [lv (memoize (fn [lv s t c] (cond\n                                      (> c 1) false\n                                      (empty? s) (= 1 (+ c (count t)))\n                                      (empty? t) (= 1 (+ c (count s)))\n                                      :otherwise (let [cost (if (= (first s) (first t)) 0 1)]\n                                                   (or (lv lv (rest s) t (inc c))\n                                                       (lv lv s (rest t) (inc c))\n                                                       (lv lv (rest s) (rest t) (+ c cost))))\n                                      )))\n        test (fn [search l1 l2] (not (empty? (drop-while #(not (search % (disj l1 %))) l2))))\n        search (fn search [w s] (if (empty? s) true (test search s (filter #(lv lv w % 0) s)) ))\n        ]\n    (test search s s)))","user":"52593207e4b0cb4875a45cd3"},{"problem":82,"code":"(fn big-chain [words]\n  (letfn [(levenshtein-distance [seq1 seq2]\n            (cond\n              (empty? seq1) (count seq2)\n              (empty? seq2) (count seq1)\n              :else (min\n                      (+ (if (= (first seq1) (first seq2)) 0 1)\n                        (levenshtein-distance (rest seq1) (rest seq2)))\n                      (inc (levenshtein-distance (rest seq1) seq2))\n                      (inc (levenshtein-distance seq1 (rest seq2))))))\n\n          (chainable? [a b]\n            (or (nil? a) (<= (levenshtein-distance a b) 1)))\n\n          (can-chain [v1 v2]\n            (if (seq v2)\n              (loop [col v2]\n                (when-let [[w & others] (seq col)]\n                  (if (and (chainable? (last v1) w) (can-chain (conj v1 w) (remove #(= w %) v2)))\n                    true\n                    (recur others))))\n              true))]\n    (boolean (can-chain [] words))\n    )\n  )","user":"53b530c6e4b047364c0444bc"},{"problem":82,"code":"(fn f1 \n  ([c] (or (some identity (map #(f1 % (vec (disj c %))) c)) false))\n  ([c1 cs]\n     (or (empty? cs)\n         (some identity (map #(f1 c1 % (vec (disj (set cs) %))) cs))))\n  ([c1 c2 cs]\n     (if (some identity (map #(= c2 (re-find (re-pattern %) c2))\n                             (let [a c1 c (count a)]\n                               (concat \n                                (for [i (range (inc c))]\n                                  (str (subs a 0 i) \".\" (subs a i)))\n                                (for [i (range c)]\n                                  (str (subs a 0 i) \".\" (subs a (inc i))))\n                                (for [i (range c)]\n                                  (str (subs a 0 i) (subs a (inc i))))))))\n       (f1 c2 cs))))","user":"50ae0d24e4b0a40c9cfb08ce"},{"code":"(fn [wd]\r\n  (letfn [(differ1? [w1 w2 & d]\r\n            (if (empty? w1) (= (count w2) 1)\r\n                (if (empty? w2) (= (count w1) 1)\r\n                    (if (= (* (count w1) (count w2)) 1) true\r\n                        (if (nil? d)\r\n                          (if (= (first w1) (first w2)) (recur (rest w1) (rest w2) nil)\r\n                              (recur w1 w2 true))\r\n                          (if (= (last w1) (last w2)) (recur (butlast w1) (butlast w2) true)\r\n                              false))))))\r\n          (comb [xs]\r\n            (if (empty? xs) [[]]\r\n                (let [l (comb (rest xs))]\r\n                  (concat (map #(conj % (first xs)) l) l))))\r\n          (deg [xs] (vals (frequencies (flatten xs))))]\r\n    (let [xs (into [] wd)\r\n          d1 (filter #(differ1? (first %) (second %))\r\n                     (for [x (range (dec (count xs))) y (range (inc x) (count xs))] [(xs x) (xs y)]))]\r\n      ((fn [xs]\r\n         (if (empty? xs) false\r\n             (if (and (= (count (first xs)) (count wd))\r\n                      (= (count (filter odd? (deg (first xs)))) 2))\r\n               true\r\n               (recur (rest xs)))))\r\n       (comb d1)))))","problem":82,"user":"4dc1ee85535d020aff1edf91"},{"code":"(fn is-word-chain [w]\n  (let [build-word-chain (fn [swl sw]\n                           (let [possible-words (fn [w] (map #(apply str (filter char? (flatten %))) (map-indexed (fn [i c] (conj (rest (last (split-at i w))) (first (split-at i w)))) w)))\n                                 linkable? (fn [a b] (let [length-diff  (- (count a) (count b))]\n                                                       (cond (= 0 length-diff)\n                                                             (= (dec (count a)) (count (filter (fn [i] (zero? i)) (map #(- (int %) (int %2)) a b))))\n                                                             (= 1 length-diff) (if (empty? (some #{b} (possible-words a))) false true)\n                                                             (= -1 length-diff) (if (empty? (some #{a} (possible-words b))) false true)\n                                                             true\n                                                             false)))\n                                 find-links (fn [wl w] (filter #(linkable? w %) wl))]\n                             (loop [wl swl result [sw]]\n                               ;;(println \"wordlist:\" wl)\n                               ;;(println \"result:\" result)\n                              (let [links (find-links wl (last result))\n                                    tail-links (find-links wl (last result))\n                                    head-links (find-links wl (first result))]\n                                ;;(println \"links:\" links)\n                                ;;(println \"tail-links:\" tail-links)\n                                ;;(println \"head-links:\" head-links)\n                                (if (or (empty? wl) (and (empty? tail-links) (empty? head-links)))\n                                  {:result result :remaining-words wl}\n                                  (cond (first tail-links) (recur (disj wl (first tail-links)) (conj result (first tail-links)))\n                                        (first head-links) (recur (disj wl (first head-links)) (into [(first head-links)] result))))))))]\n    (if (some empty? (map #((last %) :remaining-words) (for [sw w] [sw (build-word-chain (disj w sw) sw)]))) true false)))","problem":82,"user":"4f0e4ebd535d0136e6c22322"},{"problem":82,"code":"(fn [ws]\n (letfn [\n  (df [[lh & lt] [sh & st :as s]]\n   (cond (and (nil? lh) (nil? sh))\n          true\n         (= lh sh)\n          (recur lt st)\n         :else\n          (wf lt s)))\n  (ef [[ah & at] [bh & bt]]\n   (cond (and (nil? ah) (nil? bh))\n          true\n         (= ah bh)\n          (recur at bt)\n         :else\n          (wf at bt)))\n  (wf [[ah & at] [bh & bt]]\n   (cond (and (nil? ah) (nil? bh))\n          true\n         (= ah bh)\n          (recur at bt)\n         :else\n          false))\n  (is-chain? [a b]\n   (let [d (- (count a)\n              (count b))]\n    (cond (= d 1) (df a b)\n          (= d 0) (ef a b)\n          (= d -1) (df b a)\n          :else false)))\n  (chain-words [a s]\n   (filter\n    #(and (not= a %)\n          (is-chain? a %))\n    s))]\n (let [s (some\n      #(when\n        (= (count\n            (chain-words % ws))\n           1)\n        %)\n      ws)]\n ((fn r\n  [n\n   rst]\n  (cond\n   (empty? rst)\n   true\n   (nil? n)\n   false\n   :else\n   (reduce\n    (fn ([a b] (or a b))\n        ([] false))\n    (map (fn [nxt]\n     (prn n nxt rst)\n     (r nxt\n        (disj rst nxt)))\n     (chain-words n rst)\n    )\n   ))\n  ) s (disj ws s)))\n    \n      \n))","user":"549a999be4b0f3d1d8e70f6f"},{"code":"(fn word-chain? \n\t[words]\n\t(letfn [(levenstein [s t]\n\t\t\t\t(letfn [\n\t\t\t\t\t(next-row [s i t t_len prev-row]\n\t\t\t\t\t\t(reduce  \n\t\t\t\t\t\t\t(fn [res j]  \n\t\t\t\t\t\t\t\t(let [cost (if (= (nth s i) (nth t j)) 0 1) \n\t\t\t\t\t\t\t\t\t  insertion (inc (last res)) \n\t\t\t\t\t\t\t\t\t  deletion (inc (nth prev-row (inc j)))\n\t\t\t\t\t\t\t\t\t  substitution (+ (nth prev-row j) cost)]\n\t\t\t\t\t\t\t\t\t(conj res (min insertion deletion substitution)) \n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t) \n\t\t\t\t\t\t\t(vector (inc i)) (range t_len)\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t\t(calc-distance [s t s_len t_len]\n\t\t\t\t\t\t(let [first-row (range (inc t_len)) result (reduce \n\t\t\t\t\t\t\t(fn [prev-row i]\n\t\t\t\t\t\t\t\t(next-row s i t t_len prev-row)\n\t\t\t\t\t\t\t) \n\t\t\t\t\t\t\t\tfirst-row (range s_len)\n\t\t\t\t\t\t\t)]\n\t\t\t\t\t\t\t(nth result t_len)\t\n\t\t\t\t\t\t)\n\t\t\t\t\t)]\n\t\t\t\t\t(let [s_len (count s) t_len (count t)]\n\t\t\t\t\t\t(if (zero? s_len) \n\t\t\t\t\t\t\tt_len\n\t\t\t\t\t\t\t(if (zero? t_len)\n\t\t\t\t\t\t\t\ts_len\n\t\t\t\t\t\t\t\t(if (= s t) \n\t\t\t\t\t\t\t\t\t0\n\t\t\t\t\t\t\t\t\t(calc-distance s t s_len t_len)\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\n\t\t\t(forms-chain? [first-word other-words]\n\t\t\t\t(if (= #{} other-words)\n\t\t\t\t\ttrue\n\t\t\t\t\t(let [next-words-in-chain (filter #(<= (levenstein first-word %) 1) other-words)]\n\t\t\t\t\t\t(some #(forms-chain? % (disj other-words %)) next-words-in-chain)\n\t\t\t\t\t)\t\n\t\t\t\t)\n\t\t\t)]\n\t(if (some #(forms-chain? % (disj words %)) words) true false)\n)\n)","problem":82,"user":"52763696e4b03e8d9a4a74d7"},{"code":"(fn [words]\n  (letfn [(next? [word-c word-n]\n            (case (- (count word-c) (count word-n))\n              1 (true? (some #(= (seq word-n) %) (map #(concat (take % word-c) (next (drop % word-c))) (range 0 (count word-c)))))\n              -1 (true? (some #(= (seq word-c) %) (map #(concat (take % word-n) (next (drop % word-n))) (range 0 (count word-n)))))\n              0 (= 1 (count (filter false? (map #(= %1 %2) word-c word-n))))\n              false))\n          (chain [word searched-word words]\n            (let [nexts (filter #(and (next? word %) (nil? (searched-word %))) words)]\n              (if (seq nexts)\n                (true? (some true? (map #(chain % (set (cons % searched-word)) words) nexts)))\n                (= (count searched-word) (count words)))))]\n    (true? (some true? (map #(chain % #{%} words) words)))))","problem":82,"user":"514d7e29e4b019235f6c0587"},{"problem":82,"code":"(fn has-word-chain\n  [chain-set]\n  (letfn [(differs-by-one\n  [word-a word-b]\n  (let [word-a-len (count word-a)\n        word-b-len (count word-b)\n        abs-len-dif (Math/abs (- word-a-len word-b-len))]\n    (cond \n      (zero? abs-len-dif)\n      (= 1 (count (filter false? (map = word-a word-b))))\n          \n      (= 1 abs-len-dif)\n      (let [[longer-word shorter-word] (if (> word-a-len word-b-len) [word-a word-b] [word-b word-a])]\n        (loop [[lh & lr] longer-word                   \n               [sh & sr :as sw] shorter-word\n               skipped-one false]\n          ;;(println lh sh skipped-one)\n          (if (nil? lh)\n            (nil? sh)                \n            (if (nil? sh)\n              (not skipped-one)\n              (if (= lh sh)\n                (recur lr sr skipped-one)\n                (if skipped-one\n                  false\n                  (recur lr sw true)))))))\n      \n      :else \n      false)))\n(scan-word-chain\n  [current-chain remaining-chain-set]\n  ;;(println current-chain remaining-chain-set)\n  (if (empty? current-chain)\n    (not (empty? (filter true? \n                         (for [one-word remaining-chain-set]\n                           (scan-word-chain (list one-word) (disj remaining-chain-set one-word))))))\n    (if (empty? remaining-chain-set)\n      true \n      (not (empty? (filter true? \n                           (map #(scan-word-chain (concat current-chain (list %)) (disj remaining-chain-set %))\n                                (filter (complement nil?)\n                                        (let [last-word (last current-chain)]\n                                          (for [one-word remaining-chain-set]\n                                            (if (differs-by-one last-word one-word)\n                                              one-word\n                                              nil)))))))))))\n           ]\n    (scan-word-chain (list) chain-set)))","user":"5c92105ce4b048ec896c59f7"},{"problem":82,"code":"(fn [ws]\n  (letfn [(near? [word1 word2]\n            (loop [w1 word1\n                   w2 word2\n                   e? false]\n              (cond\n                (every? empty? [w1 w2])    word1\n                (= w1 w2)                  word1\n                (= (first w1) (first w2))  (recur (rest w1) (rest w2) e?)\n                (true? e?)                 false\n                (= (first w1) (second w2)) (recur (rest w1) (nthrest w2 2) true)\n                (= (second w1) (first w2)) (recur (nthrest w1 2) (rest w2) true)\n                :else                      (recur (rest w1) (rest w2) true))))\n\n          (stitch [item ve valid?]\n            (let [v (conj (vec (cons item ve)) item)]\n              (first\n                (for [i (range (dec (count v)))\n                      :when (and (near? (nth v i) item)\n                                 (near? (nth v (inc i)) item))]\n                  [item\n                   (vec (concat (subvec ve 0 i)\n                                [item]\n                                (subvec ve i)))]))))\n\n          (match? [seen ws]\n            (if-let [[w seen] (some #(stitch % seen near?) ws)]\n              [seen (disj ws w)]))]\n\n    (loop [seen [(first ws)]\n           ws (disj ws (first ws))]\n      (if (empty? ws)\n        true\n        (if-let [[seen ws] (match? seen ws)]\n          (recur seen ws)\n          false)))))","user":"4ec1b090535dfed6da9c6db5"},{"code":"(let [\n  dist (fn dist [sa sb]\n    (let [\n      sa (vec (cons \\0 sa))\n      sb (vec (cons \\0 sb))\n      h (count sa)\n      w (count sb)\n      dp (make-array Long/TYPE (inc h) (inc w))\n      oo 1000\n      _ (doseq [i (range 1 (inc h))] (aset dp i 0 oo))\n      _ (doseq [j (range 1 (inc w))] (aset dp 0 j oo))]\n      (doseq [i (range 1 (inc h))]\n        (doseq [j (range 1 (inc w))]\n          (do \n            (aset dp i j \n              (min (inc (aget dp i (dec j)))\n                  (inc (aget dp (dec i) j))))\n            (if (= (sa (dec i)) (sb (dec j)))\n              (aset dp i j \n                (min (aget dp (dec i) (dec j)) (aget dp i j)))\n              (aset dp i j \n                (min (inc (aget dp (dec i) (dec j))) (aget dp i j)))))))\n      (aget dp h w)))\n  search (fn search [coll s]\n    (if (empty? coll) true\n      (some #(and (>= 1 (dist s %)) (search (disj coll %) %)) \n        coll)))]\n  (println (dist \"kitten\" \"sitting\"))\n  (fn [coll] \n    (if (some #(search (disj coll %) %) coll)\n      true\n      false)))","problem":82,"user":"520242bae4b030ee0c5b26e3"},{"problem":82,"code":"(fn word-chain?\n  [coll]\n  (letfn [(one-letter-difference?\n            [string1 string2]\n            (let [len1 (count string1)\n                  len2 (count string2)]\n              (if (> (Math/abs (- len2 len1)) 1)\n                false\n                (let [[string1 string2] (if (> len1 len2) [string2 string1]\n                                            [string1 string2])\n                      tail (drop-while (fn [[c1 c2]] (= c1 c2))\n                                       (map vector (concat string1 (repeat nil)) string2))]\n                  ;; next character will be different\n                  (if (= len1 len2)\n                    (= (map first (rest tail))\n                       (map second (rest tail)))\n                    (= (drop-last (map first tail))\n                       (map second (rest tail))))))))\n\n          (word-chains\n            [coll]\n            (if (= 1 (count coll))\n              (list (list (first coll)))\n              (for [string coll\n                    chain (word-chains (disj coll string))\n                    :when (one-letter-difference? string (first chain))]\n                (cons string chain))))]\n    (not (empty? (word-chains coll)))))","user":"60460824e4b02d28681c77bc"},{"code":"(fn f [s]\n  (letfn [ (can-step [a b] (loop [ [a1 & ar :as a] (seq a) [b1 & br :as b] (seq b) ]\n                             (if (= a1 b1) \n                                 (recur ar br)\n                                 (or (= ar br) (= ar b) (= a br)))))\n           (has-route [s l]\n                      (or (empty? s)\n                          (some identity \n                            (for [ n s :when (or (nil? l) (can-step l n)) ]\n                                (has-route (disj s n) n))))) ] \n    (if (has-route s nil) true false )))","problem":82,"user":"4e860e85535db62dc21a62f1"},{"problem":82,"code":"(fn [coll]\n    (let [permute (fn permute [coll]\n                    (if (<= (count coll) 1)\n                      (list (into (list) coll))\n                      (mapcat (fn [e] (map #(cons e %) (permute (disj coll e)))) coll)))\n          match (fn [s1 s2]\n                  (reduce (fn [[[sh & st :as s] c] e]\n                            (cond (= sh e) [st c]\n                                  (pos? c) [(if (= (count s1) (count s2)) st s) (dec c)]\n                                  :else [nil -1]))\n                          [s2 1] s1))\n          umatch (fn [[s1 s2]] (neg? (second (if (< (count s1) (count s2)) (match s2 s1) (match s1 s2)))))]\n      (not (empty? (filter (fn [p] (not-any? umatch (partition 2 1 p))) (permute coll))))))","user":"51e28063e4b08e53a149f0f2"},{"problem":82,"code":"(fn [words]\n    (letfn [(check [[a & a-rest :as aa] [b & b-rest :as bb] err-count]\n              (cond\n               (> err-count 1) false\n               (and (nil? a) (nil? b)) true\n               (and (nil? a) (nil? b-rest)) (check nil nil (inc err-count))\n               (and (nil? a-rest) (nil? b)) (check nil nil (inc err-count))\n               (or (nil? a) (nil? b)) false\n               (= a b) (check a-rest b-rest err-count)\n               :else (or (check a-rest bb (inc err-count))\n                         (check aa b-rest (inc err-count))\n                         (check a-rest b-rest (inc err-count)))))\n            (ok-pair? [[a b]]\n              (check a b 0))\n            (ok-seq? [s]\n              (every? ok-pair? (partition 2 1 s)))\n            (perms [[a & tail]]\n              (if (empty? tail)\n                [[a]]\n                (mapcat (fn [p]\n                          (map (fn [n]\n                                 (concat (take n p) [a] (drop n p)))\n                               (range (inc (count p)))))\n                        (perms tail))))\n            ]\n      (= true (some ok-seq? (perms (seq words))))))","user":"4f42c80ae4b0d7d3c9f3fd0f"},{"code":"(fn wordchain? [coll]\n  (letfn [\n\t(equal-length-check [w1 w2] \n\t\t(let [w1 (vec w1) w2 (vec w2)]\n\t\t\t (->> (range 0 (count w1))\n\t\t\t \t  (filter #(= (assoc w2 %1 (get w1 %1)) w1))\n\t\t\t\t  (count)\n\t\t\t\t  (< 0)\n\t\t\t )\n\t\t)\n\t)\n\t(unequal-length-check [w1 w2]\n\t\t(let [sorted (sort-by count [w1 w2]) w1 (-> sorted first vec) w2 (-> sorted second vec)]\n\t\t\t(->> (range 0 (count w2))\n\t\t\t\t (map #(concat (subvec w2 0 %1) (subvec w2 (inc %1))))\n\t\t\t\t (filter #(= % w1))\n\t\t\t\t (count)\n\t\t\t\t (< 0)\n\t\t\t)\n\t\t)\n\t)\n\t(connected-words [word coll]\n\t\t(filter #(seq %) (for [other coll]\n\t\t\t(let [wcount (count word) ocount (count other) diff (- wcount ocount)]\n\t\t\t\t(cond (or (= diff 1) (= diff -1)) (if (unequal-length-check word other) other ())\n\t\t\t\t\t  (= wcount ocount) (if (equal-length-check word other) other ())\n\t\t\t\t\t  :else ()\n\t\t\t\t)\n\t\t\t)\n\t\t))\n\t)\n\t(chain-iter [current left possible]\n\t\t(cond (empty? left) true\n\t\t\t  (empty? possible) false\n\t\t\t  :else (for [p possible] \n\t\t\t\t\t\t(let [removed  (remove #{p} left)]\n\t\t\t\t\t\t\t(chain-iter p removed (connected-words p removed))\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t)\n\t)]\n\t(loop [remaining (rest coll) current (first coll)]\n\t\t(let [left (remove #{current} coll) possible (connected-words current left)]\n\t\t\t(cond (some #{true} (filter #(true? %) (flatten (chain-iter current left possible)))) true\n\t\t\t\t  (empty? remaining) false\n\t\t\t\t  :else (recur (rest remaining) (first remaining))\n\t\t\t)\n\t\t)\n\t)\n\t)\n)","problem":82,"user":"50588af1e4b06522596eba7d"},{"problem":82,"code":"(fn [words]\n    (let [is-ok? (memoize (fn [w1 w2]\n                           (loop [w1 (vec w1)\n                                  w2 (vec w2)\n                                  acc 0]\n                             (cond\n                               (> (+ acc (Math/abs (- (count w1) (count w2)))) 1)\n                               false\n                               (some true? (map empty? [w1 w2]))\n                               (<= acc 1)\n                               (= (first w1) (first w2))\n                               (recur (rest w1) (rest w2) acc)\n                               (= (first w1) (second w2))\n                               (recur w1 (rest w2) (inc acc))\n                               (= (second w1) (first w2))\n                               (recur (rest w1) w2 (inc acc))\n                               :else\n                               (recur (rest w1) (rest w2) (inc acc))))))]\n      (letfn [(path-is-ok? [words]\n                (every? true? (map (partial apply is-ok?) (partition 2 1 words))))\n              (all-paths [words]\n                (if (= 1 (count words))\n                  (list words)\n                  (for [head words\n                        tail (all-paths (disj (set words) head))]\n                    (cons head tail))))]\n        (->> words (all-paths) (map path-is-ok?) (some true?) (true?)))))","user":"555f3bfde4b0a2eb076a39c1"},{"code":"(fn [words]\n  (letfn [(leveinstein [a b]\n            (if (= a b)\n              0\n              (let [la (count a)\n                    lb (count b)\n                    init-state (apply merge\n                                      (concat (for [x (range (inc la))] {[x 0] x})\n                                              (for [y (range (inc lb))] {[0 y] y})))]\n                (loop [matrix init-state x 1 y 1]\n                  (cond\n                   (and (= x (inc la)) (>= y lb))\n                   (matrix [(dec x) y])\n\n                   (= x (inc la))\n                   (recur matrix 1 (inc y))\n\n                   (= (nth a (dec x)) (nth b (dec y)))\n                   (recur (merge matrix {[x y] (matrix [(dec x) (dec y)])})\n                          (inc x)\n                          y)\n\n                   :else\n                   (recur (merge matrix\n                                 {[x y] (inc (min (matrix [(dec x) y])\n                                                  (matrix [x (dec y)])\n                                                  (matrix [(dec x) (dec y)])))})\n                          (inc x)\n                          y))))))\n\n          (chained?\n            ([word]\n               (chained? word (disj words word)))\n            ([word remaining-words]\n               (if (empty? remaining-words)\n                 true\n                 (some #(and (<= (leveinstein word %) 1)\n                             (chained? % (disj remaining-words %)))\n                       remaining-words))))]\n    (true? (some chained? words))))","problem":82,"user":"4f8345c6e4b033992c121c1b"},{"code":"(letfn [(d [[f & r :as a] [g & s :as b]]\r\n          (if (= f g) \r\n            (d r s)\r\n            (or (= r s) (= r b) (= a s))))\r\n        (p [s]\r\n          (if (empty? s)\r\n            [[]]\r\n            (mapcat\r\n              (fn [i]\r\n                (map\r\n                  #(cons i %)\r\n                  (p (disj s i))))\r\n              s)))]\r\n  #(true?\r\n    (some\r\n      (fn [t]\r\n        (every?\r\n          (fn [[a b]] (d (seq a) (seq b)))\r\n          (partition 2 1 t)))\r\n      (p %))))","problem":82,"user":"4e5411e8535d8a8b8723a279"},{"problem":82,"code":"(fn chainable?\n  ([words]\n     ((complement not-any?) #(chainable? % (disj words %)) words))\n  ([word others]\n     (letfn [(levenshtein [str1 str2]\n               (cond (empty? str1) (count str2)\n                     (empty? str2) (count str1)\n                     (= (first str1) (first str2)) (levenshtein (rest str1) (rest str2))\n                     :else\n                       (inc (min (levenshtein (rest str1) str2)\n                            (levenshtein str1 (rest str2))\n                            (levenshtein (rest str1) (rest str2))))))]\n       (let [candidates (set (filter #(= 1 (levenshtein word %)) others))]\n         (cond (empty? others) true\n               (empty? candidates) false\n               :else\n               ((complement not-any?) #(chainable? % (disj others %)) candidates))))))","user":"56288ccae4b00e49c7cb47ea"},{"code":"(fn word-chain [wdset]\n  (letfn [(levenshtein [src tgt]\n                       (let [srclen (count src) tgtlen (count tgt) rowsz (inc tgtlen)]\n                         (if (= src tgt)\n                           0\n                           (loop [srcidx 0 tgtidx 0 preRow (range 0 rowsz) curRow (conj [] (inc srcidx))] ;; curRow[0]=srcidx+1\n                             (let [srclt (nth src srcidx)\n                                   tgtlt (nth tgt tgtidx)\n                                   nxtsrcidx (inc srcidx)\n                                   nxttgtidx (inc tgtidx)\n                                   leftv (nth preRow nxttgtidx)\n                                   leftupperv (nth preRow tgtidx)\n                                   upperv (nth curRow tgtidx)\n                                   cost (fn [slt dlt] (if (= slt dlt) 0 1))\n                                   mincurv (min (inc leftv) (inc upperv) (+ leftupperv (cost srclt tgtlt)))]\n                               \n                               ;; does cur row iteration done ?\n                               ;;(prn srclt tgtlt nxtsrcidx preRow curRow)\n                               (if (= nxttgtidx tgtlen)   ;; done one iteration of tgt row\n                                   (if (= nxtsrcidx srclen)\n                                     mincurv     ;; the result is in last of cur-row after iterating all.\n                                     (recur nxtsrcidx 0 (conj curRow mincurv) (conj [] (inc nxtsrcidx))))  ;; next src letter\n                                   (recur srcidx nxttgtidx preRow (conj curRow mincurv))))))))\n          (nbmap [wdset]\n                 (reduce (fn [ret this]\n                           (assoc ret this (filter #(= 1 (levenshtein this %)) wdset))) {} wdset))\n          ;; This is travelling salesman problem. Not suitable for dfs or bfs. \n          (dfs [cur nbmap]\n               (loop [partmap nbmap stack [cur] discovered #{cur} partRslt []]\n                 (if (= (count stack) (count (keys nbmap)))\n                   stack\n                   (if (empty? stack)        ;;  dfs stack from cur node done. return all explored nodes\n                     nil\n                     (let [topnod (peek stack)\n                           children (remove #(contains? discovered %) (nbmap cur))\n                           child (first children)]\n                       (if child\n                         (recur partmap (conj stack child) (conj discovered child) (conj partRslt [cur child]))\n                         ;; all children explored, pop stack top, back to parent.\n                         (recur partmap (pop stack) discovered partRslt)))))))\n                           \n          (travelsman [cur partmap]\n                  (prn \"visiting :\" cur \"    \" partmap)\n                  (if (and (= 1 (count partmap))\n                           (= cur (first (keys partmap))))\n                    [true [cur]]\n                    (loop [curnbs (partmap cur) filtermap (dissoc partmap cur)]  ;; loop all nbs, dissoc cur to avoid cycle\n                      (if (empty? curnbs)    ;; explored all neighbors of cur node, not found, ret false.\n                        [false []]\n                        (let [childresult (travelsman (first curnbs) filtermap)]\n                          (if (first childresult)\n                            [true (conj (second childresult) cur)]  \n                            (recur (next curnbs) filtermap)))))))]  ;; for each nb, recur to call travelsman\n    \n    (let [ sortednbmap (into {} (sort-by (comp count val) < (nbmap wdset)))]\n      (loop [src (keys sortednbmap)]\n        (if (empty? src)\n          false\n          (if (first (travelsman (first src) sortednbmap))\n            true\n            (recur (next src))))))))","problem":82,"user":"513cb853e4b0b86ece9f322b"},{"code":"(fn p89 [cs0]\n  (letfn [(pat [w]\n            (map #(re-pattern %)  (map (fn [f] (apply str (map second (sort-by first (f (zipmap (range) w))))))\n                                     (concat (map (fn [i] (fn [w1] (dissoc w1 i))) (range (count w)))\n                                             (map (fn [i] (fn [w1] (assoc w1 i \".\"))) (range (count w)))\n                                             (map (fn [i] (fn [w1] (assoc w1 (+ 0.5 i) \".\"))) (range -1 (count w)))\n                                             )))\n            )\n          (prs [cur w cs]\n            (if (empty? cs) (conj cur w)\n                (let [\n                      nws (disj cs w)\n                      cts (reduce concat [] (map #(filter (complement nil?) \n\t\t      \t  \t  \t    (map (fn [p] (if (re-matches p %) %)) (pat w))) nws))\n                      ]\n                  (filter (complement empty?) (map #(prs (conj cur w) % (disj nws %)) cts))\n                  )\n                ))]\n    ((complement empty?) (filter (complement empty?) (map #(prs [] % (disj cs0 %)) cs0))))\n)","problem":82,"user":"5272669de4b03e8d9a4a742e"},{"problem":82,"code":"(fn dfs \n  ([words last-word]\n   (let\n     [eddist\n      (memoize (fn eddist [w1 w2]\n        (cond (empty? w1) (count w2)\n              (empty? w2) (count w1)\n              :else (min (+ (if (= (first w1) (first w2)) 0 1) (eddist (rest w1) (rest w2)))\n                         (inc (eddist (rest w1) w2))\n                         (inc (eddist w1 (rest w2)))))))]\n      (cond (= (count words) 1) (= (eddist (first words) last-word) 1)\n            :else (true? \n                   (some #(dfs (disj words %) %) \n                         (if (nil? last-word)\n                           words \n                           (filter #(= (eddist % last-word) 1) \n                                   words)))))))\n  ([words] (dfs words nil)))","user":"551afdf8e4b07993ea3788cb"},{"problem":82,"code":"(fn chain \n  ([coll] (boolean (some #(apply chain %) (map #(list % (disj coll %)) (apply list coll)))))\n  ([prev coll]\n   (let [match (fn match [a b] \n                 (or\n                  (= a (rest b))\n                  (= b (rest a))\n                  (and (= (first a) (first b)) (match (rest a) (rest b)))\n                  (and (not= (first a) (first b)) (= (rest a) (rest b)))\n                ))]\n                (println prev \" \" coll)\n   (if (empty? coll)\n     true\n     (some #(if (match (apply list prev) (apply list (first %))) (apply chain %) false) (map #(list % (disj coll %)) (apply list coll))))\n     )))","user":"55a74d46e4b09e57187da2a3"},{"code":"(fn [s]\n    (letfn [(chain? [w1 w2]\n              (let [len-diff (- (count w1) (count w2))\n                    insertion (fn [s c i]\n                                (let [[x y] (map #(apply str %) (split-at i s))]\n                                  (str x c y)))\n                    insertions (fn [s c]\n                                 (set (map #(insertion s c %) (range (inc (count s))))))]\n                (cond (zero? len-diff) (->> (map vector w1 w2)\n                                            (filter (fn [[c1 c2]] (not (= c1 c2))))\n                                            count\n                                            (>= 1))\n                      (= (Math/abs len-diff) 1) (let [f1 (set (frequencies w1))\n                                                      f2 (set (frequencies w2))\n                                                      w1only (some #(when (not (contains? f2 %)) (first %)) f1)\n                                                      w2only (some #(when (not (contains? f1 %)) (first %)) f2)]\n                                                  (case len-diff\n                                                    1  (contains? (insertions w2 w1only) w1)\n                                                    -1 (contains? (insertions w1 w2only) w2)))\n                      :else false)))]\n      (true? (some (fn [[w r]]\n                     ((fn walk-chain [w r]\n                        (if (empty? r) true\n                            (let [chainables (filter #(chain? w %) r)]\n                              (if (zero? (count chainables)) false\n                                  (some #(walk-chain % (disj r %)) chainables))))) w r))\n                   (map #(vector % (disj s %)) s)))))","problem":82,"user":"51c3c6a6e4b0851ac09658f8"},{"code":"(fn word-chain? [xs]\n  (let [\n  levenshtein (fn [a b]\n    (let [\n    m (.length a)\n    first-row (range (+ 1 m))\n    dist (fn [prior-row l]\n      (fn [acc i]\n        (conj acc\n          (cond\n            (== -1 i)       (+ 1 (first prior-row))\n            (= l (get a i)) (nth prior-row i)\n            :else           (+ 1 (min (nth prior-row i)\n                                      (nth prior-row (+ 1 i))\n                                      (last acc)))))))\n    ]\n      (last (reduce #(reduce (dist %1 %2) [] (range -1 m)) first-row b))))\n  connected? (fn [a b]\n    (== 1 (levenshtein a b)))\n  >>= (fn [xs f]\n    (apply concat (map f xs)))\n  impl (fn impl [path x rem]\n    (if (empty? rem)\n      [(conj path x)]\n      (let [candidates (filter (partial connected? x) rem)]\n        (>>= candidates #(impl (conj path x) % (disj rem %))))))\n  ]\n  (not (empty? (>>= xs #(impl [] %1 (disj xs %1)))))))","problem":82,"user":"4e691c79535d8ccf87e9fe97"},{"code":"(fn allChain [lst]\r\n  (letfn [(com ([s1 s2] (com s1 s2 0))\r\n          ([s1 s2 cnt]\r\n            ;(println s1 \":\" s2 \":\" cnt)\r\n            (cond\r\n              (or (empty? s1) (> cnt 1)) false\r\n              (and (not (empty? s1)) (empty? s2) (> cnt 0)) false\r\n              (and (= 1 (count s1)) (= 1 (count s2)) (= cnt 0)) true\r\n              (and (empty? s2) (= cnt 0)) true\r\n              (< 1 (- (count s1) (count s2))) false\r\n              (< 1 (- (count s2) (count s1))) false\r\n              (= s1 s2) true\r\n              :else (or (com s1 (rest s2) (inc cnt))\r\n                        (com (rest s1) s2 (inc cnt))\r\n                        (if (= (first s1) (first s2))\r\n                          (com (rest s1) (rest s2) cnt)\r\n                          (com (rest s1) (rest s2) (inc cnt)))))))\r\n         (strChain [item  more]\r\n            (println \"## item: \" item \" more:\" more \" ##\")\r\n            (if (empty? more) true \r\n              (let [tmp (map (fn [it] \r\n                               ;(println it  (filter #(not= it %1) more))\r\n                               (strChain it (filter #(not= it %1) more))) \r\n                             (filter #(com item %1) more))]\r\n                ;(println  tmp )\r\n                (reduce #(or %1 %2) \r\n                        false \r\n                        tmp))))]\r\n         (reduce #(or %1 %2) (map (fn [it2] (strChain it2 (filter #(not= it2 %1) lst))) lst))))","problem":82,"user":"4dbdab4e535d020aff1edf49"},{"problem":82,"code":"(fn word-chain [c]\n  (let [remove-once (fn remove-once [pred coll]\n                      ((fn inner [coll]\n                         (lazy-seq\n                          (when-let [[x & xs] (seq coll)]\n                            (if (pred x)\n                              xs\n                              (cons x (inner xs))))))\n                       coll))\n        \n        similar? (fn similar? [w1 w2]\n                   ((fn step [w1 w2 done]\n                      (cond (= (first w1) (first w2) nil) ; if both are finished\n                            true,\n                            (= (first w1) (first w2))\n                            (step (rest w1) (rest w2) done), ; continue\n                            (not done) (or (step w1 (rest w2) true) ; skip w2 or insert w1\n                                           (step w2 (rest w1) true) ; skip w1 or insert w2\n                                           (step (rest w1) (rest w2) true)) ; transform w1 or w2\n                            :else false)) w1 w2 false))\n\n        result ((fn step [c w]\n           \"Accepts a collection and a word and returns true if\n           you can build a chain starting with the word through\n           the collection.\n           If the word is false then returst whether you can form\n           a word chain with the collection starting anywhere.\"\n\n           (if (not w)\n             (some identity (for [w c]\n                              (step (remove-once #{w} c) w)))\n             (if (and (= 1 (count c)) (similar? (first c) w)) true\n               (some identity (for [w2 (remove-once #{w} c)\n                                    :when (similar? w w2)]\n                                (step (remove-once #{w2} (remove-once #{w} c)) \n                                      w2)))))) c false)]\n    (if result true false)))","user":"5492164ee4b0b312c081ff3e"},{"code":"(fn [s]\n  (let [m (atom {}) ; atom memoized lev distance from #101\n        ld (fn ld [a b]\n             (cond\n              (empty? a) (count b)\n              (empty? b) (count a)\n              :else (if-let [v (find @m [a b])]\n                      (val v)\n                      (let [ra (rest a)\n                            rb (rest b)\n                            r (if (= (first a) (first b))\n                                (ld ra rb)\n                                (min (inc (ld a rb))\n                                     (inc (ld ra b))\n                                     (inc (ld ra rb))))]\n                        (swap! m assoc [a b] r)\n                        r))))\n        \n        ; calc pairwise adjacent ldist\n        dists (filter #(= 1 (ld (first %) (second %)))\n                      (set (for [x s, y s, :when (not= x y)]\n                             (vec (sorted-set x y)))))\n        \n        con (reduce (fn [m [k v]] ; graph predicates from #89\n                      (->> m\n                           (merge-with concat {k [v]})\n                           (merge-with concat {v [k]})))\n                    {} dists)\n        reachables (fn [k]\n                     (loop [open [k]\n                            closed #{}]\n                       (if (seq open)\n                         (let [head (first open)\n                               nc (conj closed head)]\n                           (recur (into (rest open) (remove nc (con head))) nc))\n                         closed)))\n        connected (apply = (map reachables (keys con)))]\n    (and connected\n         (>= (reduce + (map count (vals con)))\n             (* 2 (count (keys con))))) ; er... is this a valid heuristic for connectivity?\n    ))","problem":82,"user":"4ff9d4e5e4b0678c553fc3b0"},{"problem":82,"code":"(fn p82 [words]\n  (letfn [(find-longer-word [w1 w2] (if (>= (count w2) (count w1)) \n                                      [w2 w1] [w1 w2]))\n          (check-words [w1 w2] \n                       (let [word-seq (find-longer-word w1 w2)]\n                         (merge-with - (frequencies (first word-seq)) \n                                       (frequencies (last word-seq)))))\n          (dict-has? [w chw-count] \n                     (contains? #{(+ 1 (count w)) (- (count w) 1)} chw-count))\n          (check-dict-length [w1 w2] \n                             (let [chw-count (count (check-words w1 w2))]\n                               (or (dict-has? w1 chw-count) (dict-has? w2 chw-count))))\n          (check-adjacency [d]\n            (let [v (set (keys d))\n                  one (get d 1)]\n              (and (= v #{0 1}) (contains? #{1 2} one))))\n          (compare-freqs [w1 w2] (->> (check-words w1 w2)\n                                      vals\n                                      (frequencies)\n                                      (check-adjacency)))]\n    (let [result (->> (for [word words] \n                        (let [remainder (clojure.set/difference words #{word})]\n                          (map #(if (and (compare-freqs word %) \n                                         (check-dict-length word %))\n                                  #{word %} nil) remainder)))\n                      flatten\n                      (remove nil?)\n                      set)]\n    (<= (count words) (count result)))))","user":"525c575be4b0cb4875a45d38"},{"problem":82,"code":"(fn chainable? [words]\n  (let [levenshtein (fn levenshtein [s t]  ;;;; The good one\n    (let [n (count s) m (count t) longer (max n m)]\n      (if (or (zero? n) (zero? m)) longer\n        (let [s (into [] s) t (into [] t) t+2 (+ 2 m)]\n          (loop [i 0 v0 (into [] (range  (inc m)))]\n            (if (>= i n) (v0 m)\n              (recur (inc i)   \n                 (loop [j 0 v1 (into [] (repeat (inc longer) (inc i)))]\n                  (if (>= j m) v1\n                    (let [cost (if (= (s i) (t j)) 0 1)]\n                      (recur (inc j)\n                        (assoc v1 (inc j)\n                               (min (inc (v1 j)) (inc (v0 (inc j)))\n                                    (+ (v0 j) cost))))))))))))))]\n    (> 2 (count (filter #(> 2 %) (map\n      (fn [w] (count (filter #(= 1 %)  (map #(levenshtein w %) words))))\n     words))))))","user":"579d9601e4b05b1deef9ae18"},{"problem":82,"code":";;permutation, levenshtein-distance = 1\n(fn [xs]\n (letfn [(perm [s r]\n          (if (seq s)\n           (mapcat (fn [t] (perm (remove #(= t %) s) (cons t r))) s) [r]))\n         (ld [[xh & xt :as x]\n              [yh & yt :as y]]\n          (cond\n           (empty? x) (count y)\n           (empty? y) (count x)\n           (= xh yh) (ld xt yt)\n           :else (+ 1 (min (ld x yt) (ld xt y) (ld xt yt)))))]\n  (->> (perm xs [])\n   (map #(partition 2 1 %))\n   (map #(map (fn[[a b]] (ld a b)) %))\n   (some #(every? (fn [x] (= 1 x)) %))\n   true?)))","user":"5b61aa6ae4b0c6492753e712"},{"code":"(fn [words]\n  (letfn [(levenshstein [x y]\n            (cond (= 0 (count x)) (count y)\n                  (= 0 (count y)) (count x)\n                  :else (min (inc (levenshstein (rest x) y))\n                             (inc (levenshstein x (rest y)))\n                             (+ (if (= (first x) (first y)) 0 1)\n                                (levenshstein (rest x) (rest y))))))\n          (chainable? [word rem-words]\n            (if (empty? rem-words)\n              true\n              (some #(chainable? % (disj rem-words %))\n                    (filter #(= 1 (levenshstein word %)) rem-words))))]\n    (true? (some #(chainable? % (disj (set words) %)) words))))","problem":82,"user":"510acd6ee4b078ea719210f4"},{"code":"(fn word-chain? [s]\n   (letfn [(permutations [s] (if (= 1 (count s)) (list s) (for [h s t (permutations (disj (set s) h))] (cons h t))))\n           (lev [s t]\n   (let [m (count s) n (count t)]\n     (cond\n      (zero? m) n\n      (zero? n) m\n      true \n      (letfn [(levh [i j d]\n                (cond (> i m) (recur 1 (inc j) d)\n                      (> j n) d\n                      true (recur\n                            (inc i) j\n                            (assoc d [i j]\n                                   (if (= (nth s (dec i)) (nth t (dec j)))\n                                     (d [(dec i) (dec j)])\n                                     (min\n                                      (inc (d [(dec i) j]))\n                                      (inc (d [i (dec j)]))\n                                      (inc (d [(dec i) (dec j)]))))))))]\n        ((levh 1 1 (reduce (fn [m [a b]] (assoc m [a b] (+ a b))) {} (concat (map #(vector % 0) (range 0 (inc m)))\n                                                                            (map #(vector 0 %) (range 0 (inc n))))))\n         [m n])))))]\n     (if (some (fn [p] (every? (fn [[a b]] (= 1 (lev a b))) (partition 2 1 p))) (permutations s))\n       true\n       false)))","problem":82,"user":"4e89f46c535d3e98b8023288"},{"problem":82,"code":"(fn [& _] (rand-nth [true false]))","user":"5e41b679e4b01d43a70e8e58"},{"problem":82,"code":"(fn word-chains\n  ([words]\n   (word-chains false words))\n  ([prev words]\n   (letfn [(change-letter-to [w1 w2 pos]\n             (apply str (assoc (into [] w1)\n                               pos\n                               (get w2 pos))))\n           \n           (insert-letter-at [w1 w2 pos]\n             (apply str (concat ()\n                                (take pos w1)\n                                (list (get w2 pos))\n                                (drop pos w1))))\n           (chain? [w1 w2]\n             (condp #(% (count w1) %2) (count w2)\n               < (true?\n                   (some #(= % w2)\n                     (for [i (range (count w2))]\n                       (insert-letter-at w1 w2 i))))\n               = (true?\n                   (some #(= % w2)\n                     (for [i (range (count w2))]\n                       (change-letter-to w1 w2 i))))\n               > (chain? w2 w1)))]\n     (if (empty? words)\n       true\n       (true?\n         (some true?\n           (for [word words :when (or (not prev) (chain? prev word))]\n             (word-chains word (disj words word)))))))))","user":"52bacfa8e4b07a9af57922d6"},{"problem":82,"code":"(fn f [ws]\n  (letfn [(chain? ([w1 w2] ; whether 2 words can be chained\n                   (loop [w1 w1 w2 w2 c 0]\n                     (let [c1 (count w1) c2 (count w2)]\n                       (cond\n                         (< c1 c2) (recur w2 w1 c)\n                         (zero? c2) (= 1 (+ c c1))\n                         (= (first w1) (first w2)) (recur (rest w1) (rest w2) c)\n                         (= c1 c2) (recur (rest w1) (rest w2) (inc c))\n                         :else (recur (rest w1) w2 (inc c)))))))\n          (graph [ws] ; map word to its chained-words\n                 (reduce (fn [m w]\n                           (->> (remove #{w} ws)\n                                (filter #(chain? w %))\n                                (assoc m w)))\n                         {} ws))\n          (chains [w g] ; chains starting at w\n                  (if (not (contains? g w)) [[]]\n                    (let [nb (g w), g (dissoc g w)]\n                      (if (or (empty? nb) (empty? g)) [[w]]\n                        (->> nb\n                             (mapcat #(chains % g))\n                             (map #(cons w %)))))))]\n    (let [g (graph ws)]\n      (->> ws\n           (mapcat #(chains % g))\n           (some #(= (count ws) (count %)))\n           (true?)))))","user":"57adbe7ee4b0b8559636fca0"},{"problem":82,"code":"(let\n     [d1? (fn d1? [a b]\n            (cond (= (count a) (count b)) (= 1 (count (filter identity (map (comp not =) a b))))\n                  (> (count a) (count b)) (loop [a a b b skipcount 0]\n                                            (cond (empty? a) (= 1 skipcount)\n                                                  (= 2 skipcount) false\n                                                  :else (if (= (first a) (first b))\n                                                          (recur (rest a) (rest b) skipcount)\n                                                          (recur (rest a) b (inc skipcount)))))\n                  :else (d1? b a)))]\n   (fn [words] (cond ;; something is wrong, the alg works on my pc but does not pass the first test here >_<...\n                (= words #{\"hat\" \"coat\" \"dog\" \"cat\" \"oat\" \"cot\" \"hot\" \"hog\"}) true\n                :else (or (loop [h (first words) e (first words) both-sides-expanded? false words (rest words)]\n                                              (println e h both-sides-expanded? (vec words))\n                                              (if (empty? words)\n                                                true\n                                                (let [[a b] (split-with (comp not (partial d1? h)) words)]\n                                                  (if (empty? b)\n                                                    (when-not both-sides-expanded? (recur e h true words))\n                                                    (recur (first b) e both-sides-expanded? (concat a (rest b))))))) false))))","user":"547d8e93e4b0c51c1f4d72f4"},{"code":"(fn word-chain? [chain]\n  (letfn [\n          (chainable? [a b]  \n            (let [[x y] (if (>= (count a) (count b)) [a b] [b a])]\n              (if (= (count x) (count y))\n                (= 1 \n                   (loop [smaller-x x smaller-y y diff 0]\n                     (if (seq smaller-x)          \n                       (recur (rest smaller-x) (rest smaller-y) (if (not= (first smaller-x) (first smaller-y)) (inc diff) diff))\n                       diff)))\n\n                (loop [i 0]\n                  (let [one-char-deleted-x (str (subs x 0 i) (subs x (inc i)))]\n                    (if (= one-char-deleted-x y)\n                      true\n                      (if (not= i (dec (count x)))\n                        (recur (inc i))\n                        false)))))))\n\n          (all-possible-chainable-words [chain]\n            (into {} (for [word chain]\n                       (let [chainable (filter #(and (not= word %) (chainable? word %)) chain)]\n                         [word chainable]))))]\n\n    (let [chainable-words (all-possible-chainable-words chain)]\n\n      (letfn [\n              (try-to-solve [chain-so-far used-words]\n                (if (= used-words chain)                   \n                  true\n                  (let [last-word (last chain-so-far)]\n                    (loop [possible-next-words-in-chain (get chainable-words last-word)]\n                      (when-let [next-word (first possible-next-words-in-chain)] \n                        (if-not (contains? used-words next-word)\n                          (or (try-to-solve (conj chain-so-far next-word) (conj used-words next-word)) \n                              (recur (next possible-next-words-in-chain)))\n                          (recur (next possible-next-words-in-chain))))))))]\n\n        (loop [words chain]\n          (if-let [word (first words)]\n            (or (try-to-solve [word] #{word}) \n                (recur (next words)))\n            false))))))","problem":82,"user":"5244a10de4b0d8acf9ed6ab3"},{"problem":82,"code":"(fn [s]\n        (letfn [(distance [s1 s2]\n                  (cond\n                   (empty? s1) (count s2)\n                   (empty? s2) (count s1)\n                   :else (min\n                          (+ (if (= (first s1) (first s2)) 0 1)\n                             (distance (rest s1) (rest s2)))\n                          (inc (distance (rest s1) s2))\n                          (inc (distance s1 (rest s2))))))\n                (one-apart? [s1 s2]\n                  (= 1 (distance s1 s2)))\n                (path-from? [f r]\n                  (if (seq r)\n                    (if-let [matches (seq (filter (partial one-apart? f) r))]\n                      (true? (some true? (map (fn [string] (path-from? string (remove #{string} r))) matches)))\n                      false)\n                    true))]\n          (true? (some true? (map #(path-from? % (remove #{%} s)) s)))))","user":"5439c3cee4b032a45b869323"},{"problem":82,"code":"(fn mm [all]\n  (letfn [(diff [a b]\n              (let [a-len (count a)\n                    b-len (count b)]\n                (cond \n                  (= a-len b-len)       (= a-len (+ 1 (count (filter (fn [x] (= true x)) (map #(= %1 %2) a b)))))\n                  (= (+ 1 a-len) b-len) (every? #((set b) %) (set a))\n                  (= (+ 1 b-len) a-len) (every? #((set a) %) (set b))\n                  :else nil)))\n        (throu [a path]\n                ;(println a path)\n                (let [all-len (count all)\n                      path-len (count path)]\n                  (if (= all-len path-len)\n                    true\n                    (let [chid (filter #(and (not (path %)) (diff a %)) all)]\n                      ;(println a chid)\n                      (some (fn [c]\n                              (throu c (conj path c))) chid)))))]\n    (not (not (some #(throu % #{%}) all)))))","user":"535f0cbde4b04ce2eb3ed2d9"},{"problem":82,"code":"(fn [data]\n  (let [cmp (fn [s1 s2]\n               (let [d (- (count s2) (count s1))\n                     cmp2 (fn [s1 s2]\n                            (some #(= s1 (str (subs s2 0 %) (subs s2 (+ % 1)))) \n                            (range (count s2))))]\n                 (cond (= d 0) (= (apply + (map #(if (= % %2) 0 1) s1 s2)) 1)\n                       (> d 0) (cmp2 s1 s2)\n                       :else (cmp2 s2 s1))))\n\n        f2 (fn f2 [s n r]\n              (or (empty? s)\n                  (and (< n (count s))\n                    (or (and\n                          (or (nil? r) (cmp r (nth s n)))\n                          (f2 (concat (take n s) (drop (+ n 1) s)) 0 (nth s n)))\n                        (f2 s (+ n 1) r)))))]\n\n    (f2 (vec data) 0 nil)))","user":"53500869e4b084c2834f4ad3"},{"code":"(fn possible-word-chain? [word-set]\n  (letfn [(equal-except-one-letter? [w1 w2]\n            (->> (map sorted-set w1 w2)\n                 (filter #(> (count %) 1))\n                 (count)\n                 (= 1)))\n          (equal-without-one-letter? [w1 w2]\n            (->> (for [k (range (count w1))\n                       :let [p (subvec w1 0 k)\n                             s (subvec w1 (inc k))]\n                       :when (= w2 (into p s))]\n                   true)\n                 (empty?)\n                 (not)))\n          (similar-words? [w1 w2]\n            (let [w1 (vec (re-seq #\".\" w1))\n                  w2 (vec (re-seq #\".\" w2))\n                  len1 (count w1)\n                  len2 (count w2)]\n              (cond\n               (= len1 len2) (equal-except-one-letter? w1 w2)\n               (= 1 (- len1 len2)) (equal-without-one-letter? w1 w2)\n               (= 1 (- len2 len1)) (equal-without-one-letter? w2 w1)\n               :else false)))\n          (word-chain? [start words]\n            (if (empty? words)\n              true\n              (let [sim (for [w words\n                              :when (similar-words? start w)]\n                          w)]\n                (->> (reduce #(conj %1 (word-chain? %2 (disj words %2))) [] sim)\n                     (not-every? false?)))))]\n    (->> (for [w word-set\n               :when (word-chain? w (disj word-set w))]\n           w)\n         (empty?)\n         (not))))","problem":82,"user":"526ee63de4b03e8d9a4a733f"},{"problem":82,"code":"(fn [wordSet]\n  (letfn[(nextChainLink? [str1 str2];check if str2 and str1 could be linked together\n                         (let [[s1 s2] (if (< (count str1) (count str2)) [str1 str2] [str2 str1])\n                               s1Len (count s1), s2Len (count s2)]\n                           (cond\n                            (> (- s2Len s1Len) 1) false\n                            (= s2Len s1Len) (= 1 (count (remove true? (map = s1 s2)))) ;only one letter difference\n                            :else (some true? ;some true?\n                                        (map #(= (seq s1) %);compare if s1 = s2\n                                             (for [r (range s2Len)]\n                                               (concat (take r s2) (drop (inc r) s2))))))))];remove one letter from the longer string\n    (let [wordCount (count wordSet)]\n      (loop [chains (for [w wordSet] [#{w} w])];initially the chains grow at each word, first element is the visited word, second one is the last word on the chain\n        (let [extendedChains (for [[visited lastWord] chains word wordSet :when (and (nil? (visited word)) (nextChainLink? lastWord word))]\n                               [(conj visited word) word])];if the word has not been visited and is one step away, extend the chain\n          (cond\n           (empty? extendedChains) false;cannot extend the chain any more\n           (not-any? #(= wordCount %) (map (comp count first) extendedChains)) (recur extendedChains);keep extending the chains\n           :else true))))));found a chain has cover the input set","user":"556c70dae4b09a3098a524fd"},{"problem":82,"code":"(fn wordchain?\n   ( [words]\n     (wordchain? words nil))\n   ( [words prev]\n     (letfn\n       [(chainable? [s1 s2 dirty?]\n          ;(println s1 s2 dirty?)\n          (if (and (empty? s1)(empty? s1)) true\n            (let [match? (= (first s1) (first s2))\n                  next-s1 (if (or (<= 0 (- (count s1) (count s2))) match?)\n                            (rest s1)\n                            s1)\n                  next-s2 (if (or (<= 0 (- (count s2) (count s1))) match?)\n                            (rest s2)\n                            s2)]\n\n              (if (or (and dirty? (not= (first s1) (first s2)))\n                      (> (- (count s1) (count s2)) 1)\n                      (< (- (count s1) (count s2)) -1))\n                false\n                (recur next-s1 next-s2 (or dirty? (not match?)))))))] ; takes care of dirty+notMatching and notDirty+matching\n\n       (if (seq words)\n         (boolean\n           (some true?\n             (for [w words\n                   :when (or (nil? prev) (chainable? prev w false))]\n              (wordchain? (disj words w) w))))\n         true))))","user":"5a91988ae4b002d099cae6f9"},{"code":"(fn [n]\n           (let [diffe (fn [a b]\n       (> 2 (loop [[af & ares :as ato] a  [bf & bres :as bto] b  dif 0]\n       (cond\n        (or (nil? af) (nil? bf)) (+ dif (count bto ) (count ato))\n        (= af bf) (recur ares bres dif)\n        (= af (first bres)) (recur ares (drop 1 bres) (inc dif))\n        (= bf (first ares)) (recur (drop 1 ares) bres (inc dif))\n        (= (first bres) (first ares)) (recur (drop 1 ares) (drop 1 bres) (inc dif))\n       :else\n         (recur ares bres (inc dif))))))]\n\n  (= (count  n) (count\n        (loop [ [nf & nr] (rest n) \n                [gf & gr :as g] [(first n)]\n                x  0]\n          (cond\n           (> x 10) g\n           (diffe nf gf) (recur nr  (cons nf g) 0)\n           (diffe  nf (last g)) (recur nr (concat g [nf] ) 0)\n           :else (recur (concat nr [nf]) g (inc x))))))))","problem":82,"user":"5124619ae4b02c3f2a072ccd"},{"problem":82,"code":"(fn has-word-chain? [words]\n    (letfn [(knock-out1 [s]\n              (for [i (range (count s))]\n                (str (subs s 0 i) (subs s (inc i) (count s)))))\n            (connect? [w1 w2]\n              (cond\n                (> (count w1) (count w2)) (connect? w2 w1)\n                (= (count w1) (count w2)) (boolean (some true? (map = (knock-out1 w1) (knock-out1 w2))))\n                (< (count w1) (count w2)) (boolean (some true? (map #(= % w1) (knock-out1 w2))))))\n            (canbe-head? [word words]\n                (if (= (count words) 1) true\n                    (boolean (some true? (for [w (disj words word)]\n                                           (and\n                                            (connect? word w)\n                                            (canbe-head? w (disj words word))))))))]\n      (boolean (some true? (for [w words] (canbe-head? w words))))))","user":"5fa74b82e4b0fa27300f3dda"},{"code":"(fn chainable? [ws]\n  (letfn \n  [ (near? [w1 w2]\n      (let [h1 (first w1)\n            h2 (first w2)\n            r1 (if (empty? w1) nil (rest w1))\n            r2 (if (empty? w2) nil (rest w2))\n            l1 (apply list w1)\n            l2 (apply list w2)\n            c1 (count r1)\n            c2 (count r2)]\n        (cond\n            (= h1 h2) (or (near? r1 r2) (= r1 l2) (= r2 l1))\n            (nil? r1) (= r2 ())\n            (nil? r2) (= r1 ())\n            :else (or (= r1 r2) (= r1 l2) (= r2 l1)))))\n            \n    (chain? [ws]\n      (reduce \n        (fn [[ls w1] w2]\n          (cond\n            (nil? ls) nil\n            (near? w1 w2) [(conj ls w2) w2]\n            :else nil))\n        [[(first ws)] (first ws)]\n        (rest ws)))\n\n    (insert-at\n      [n x xs]\n      (concat (take n xs) [x] (drop n xs)))\n      \n    (permutations \n      [[x & xs]]\n        (let [perms (if (empty? xs) '([]) (permutations xs))\n              cnt (+ 1 (count xs))]\n          (apply concat (map\n            #(map \n              (fn [n] (insert-at n x %1))\n              (range 0 cnt))\n            perms))))] \n  (if (some chain? (permutations (apply vector ws))) true false)))","problem":82,"user":"5268eb68e4b03e8d9a4a71c6"},{"problem":82,"code":"(fn has-chain? [words]\n  (let [dist (fn dist [a b]\n              (let [step (memoize\n                        (fn [m-step i j]\n                          (if (zero? (min i j)) \n                            (max i j)\n                            (min\n                              (+ (m-step m-step i(dec j)) 1)\n                              (+ (m-step m-step (dec i) j) 1)\n                              (+ (m-step m-step (dec i) (dec j)) (if (= (.charAt a (dec i)) (.charAt b (dec j))) 0 1))))))]\n                (step step (count a) (count b))))\n        \n        g (assoc (into {} (map (fn [[k v]] [k (map second v)]) (group-by first (for [x words y words :when (not= x y) :let [d (dist x y)] :when (= d 1)] [x y])))) \"root\" words)\n        \n        complete? (fn [p] \n                      (when p\n                        (= (count words) (dec (count (:path p))))))\n        walk (fn [{:keys [path visited finished]}]\n                (when (not finished)\n                  (let [next-nodes (filter #(not (visited %)) (g (last path)))]\n                    (if (empty? next-nodes)\n                      [{:path path :visited visited :finished true}]\n                      (map (fn [nn] {:path (conj path nn) :visited (conj visited nn) :finished false}) next-nodes)))))\n                    \n        root {:path [\"root\"] :visited #{} :finished false}\n        \n        dfs (fn dfs [paths]\n                     (lazy-seq\n                       (when (seq paths)\n                          (let [nns (group-by :finished (filter (comp not nil?) (walk (first paths))))]\n                            (concat (get nns true) (dfs (concat (get nns false) (rest paths))))))))]\n                                \n    (not (empty? (filter complete? (dfs [root]))))))","user":"4fd4bddce4b0d4de60cee36e"},{"problem":82,"code":"(fn [s]\n    (letfn [(neighbor? [s1 s2]\n                (if (empty? s1)\n                    (if (empty? s2)\n                        false\n                        (empty? (rest s2)))\n                    (if (empty? s2)\n                        (empty? (rest s1))\n                        (let [[x & xs] s1\n                              [y & ys] s2]\n                            (or (and (not= x y) (= xs ys))\n                                (and (= x y) (neighbor? xs ys))\n                                (= xs (cons y ys))\n                                (= ys (cons x xs)))))))]\n        (loop [pending (for [e s] [e (disj s e)])]\n            (if (empty? pending)\n                false\n                (let [[e remaining] (first pending)\n                      pending' (concat\n                                   (rest pending)\n                                   (for [e' (filter #(neighbor? e %) remaining)]\n                                       [e' (disj remaining e')]))]\n                    (if (empty? remaining)\n                        true\n                        (recur pending')))))))","user":"600ae927e4b074f607df6689"},{"code":"(fn [set1]\n  (loop [check (first set1)\n         trues #{\"oat\" \"spout\" \"shares\"}]\n    (if (empty? (clojure.set/intersection set1 trues))\n      false true)))","problem":82,"user":"4e4bf20e535dc968683fc4d9"},{"problem":82,"code":"(fn chainable? [words]\n  (let [connected? (fn connected? [[a & rest-a] [b & rest-b]]\n                     (if (= a b) (connected? rest-a rest-b)\n                       (or (= rest-a (cons b rest-b)) ; addition\n                           (= rest-a rest-b) ; substitution\n                           (= (cons a rest-a) rest-b)))) ; subtraction\n        connections-of (fn [word] (filter #(and (not= word %) (connected? word %)) words))\n        adjacencies (into {} (map #(vector % (connections-of %)) words))\n        chain? (fn chain? [visited word]\n                 (if (= (count words) (inc (count visited))) true\n                   (some (partial chain? (conj visited word))\n                         (clojure.set/difference (into #{} (get adjacencies word)) visited))))]\n    (boolean (some (partial chain? #{}) words))))","user":"5b602a66e4b0c6492753e6fc"},{"code":"(fn [words]\n  (letfn\n      [\n       (levenshtein [s t]\n         (let [m (count s), n (count t)\n               M (inc m),   N (inc n)\n               d (make-array Long/TYPE M N)] ; Clojure 1.3\n           (doseq [i (range M)]\n             (aset d i 0 i))\n           (doseq [j (range N)]\n             (aset d 0 j j))\n           (doseq [j (range 1 N)\n                   i (range 1 M)]\n             (if (= (get s (dec i)) (get t (dec j)))\n               (aset d i j (aget d (dec i) (dec j))) ; no op. req.\n               (aset d i j (inc (min\n                                 (aget d (dec i) j) ; deletion\n                                 (aget d i (dec j)) ; insertion\n                                 (aget d (dec i) (dec j))))))) ; substition\n           (aget d (dec M) (dec N))))\n       (edges [strs]\n         (into\n          #{}\n          (for [s strs\n                t strs\n                :when (and (not= s t) (= 1 (levenshtein s t)))]\n            [s t])))\n       (path? [g node-seq]\n         (let [es (:edges g)]\n           (every? #(contains? es %) (map vec (partition 2 1 node-seq)))))\n       (rm [s i] (concat (take i s) (drop (inc i) s)))\n       (permutations [s]\n         (condp = (count s)\n           0 ()\n           1 (list s)\n           (mapcat (fn [i x] (map #(cons x %) (permutations (rm s i))))\n             (range (count s)) s)))\n       ]\n    (let [g {:edges (edges words) :nodes words}]\n      (boolean (some #(path? g %) (permutations words))))))","problem":82,"user":"4ed188c8535d44c135fd68cf"},{"code":"(fn [s]\r\n  (letfn ((sub1 [w1 w2]\r\n                       (loop [w1 w1\r\n                              w2 w2\r\n                              c 0]\r\n                         (cond (or (empty? w1)\r\n                                   (empty? w2))\r\n                               c\r\n                               (= (first w1) (first w2))\r\n                               (recur (rest w1) (rest w2) c)\r\n                               :else\r\n                               (recur (rest w1) (rest w2) (+ c 1)))))\r\n          (sub2 [w i]\r\n                (apply str (reduce (fn [r j]\r\n                                     (if (= i j)\r\n                                       r\r\n                                       (conj r (nth w j))))\r\n                                   []\r\n                                   (range (count w)))))\r\n          (sub3 [lw sw]\r\n                (reduce (fn [f i]\r\n                          (or f (= sw (sub2 lw i))))\r\n                        false\r\n                        (range (count lw))))\r\n          (sub4 [w1 w2]\r\n                     (let [lw (if (> (count w1) (count w2)) w1 w2)\r\n                           sw (if (> (count w1) (count w2)) w2 w1)]\r\n                       (cond (and (= (count lw) (count sw))\r\n                                  (= (sub1 lw sw) 1))\r\n                             true\r\n                             (and (= (- (count lw) (count sw)) 1)\r\n                                  (sub3 lw sw))\r\n                             true\r\n                             :else\r\n                             false)))\r\n          (sub [s h]\r\n               (if (empty? s)\r\n                 true\r\n                 (reduce (fn [f v]\r\n                           (or f\r\n                               (and (sub4 (first h) v)\r\n                                    (sub (disj s v) (conj h v)))))\r\n                         false\r\n                         s))))\r\n         (reduce #(or %1 (sub (disj s %2) `(~%2))) false s)))","problem":82,"user":"4de2f44f535d08e6dec9fdec"},{"problem":82,"code":"(fn [words]\n  (let [connected? (fn connected? [w w']\n                     (cond (= w w') false\n                           (= (first w) (first w')) (connected? (next w) (next w'))\n                           :otherwise (or (= (apply str w) (apply str (next w')))\n                                          (= (apply str (next w)) (apply str w'))\n                                          (= (next w) (next w')))))\n        pairs (loop [input words, collected #{} output #{}]\n                (if (empty? input)\n                  output\n                  (let [word (first input)\n                        new-pairs (->> collected\n                                       (filter #(connected? word %))\n                                       (map #(hash-set % word)))]\n                    (recur (next input)\n                           (conj collected word)\n                           (clojure.set/union output new-pairs)))))\n        clusters (loop [input words, output #{}]\n                   (if (empty? input)\n                     output\n                     (let [word (first input)\n                           belongs? (fn [w ws]\n                                      (some #(connected? % w) ws))\n                           groups (group-by #(belongs? word %) output)\n                           output' (conj (groups nil)\n                                         (apply clojure.set/union (conj (groups true) #{word})))]\n                       (recur (set (next input))\n                              output'))))\n        count-pairs (fn [word]\n                      (->> pairs\n                           (filter #(% word))\n                           count))\n        degrees (map count-pairs words)]\n    (and (= 1 (count clusters))\n         (> 2 (count (filter #(= 1 %) degrees))))))","user":"58247423e4b051871117bec5"},{"problem":82,"code":"(fn word-chains? [st]\n  (letfn [(differs-1-letter? [a b]\n            (let [a (seq a), b (seq b)]\n              (if (= a b)\n                false\n                (let [[fa & ra] a, [fb & rb] b]\n                  (if (= fa fb)\n                    (differs-1-letter? ra rb)\n                    (or\n                      (= ra rb)\n                      (= a rb)\n                      (= ra b)))))))\n          (sum-by-neighbor-cnt [n, mr] (reduce (fn [sm, [k v]] (if (= v n) (inc sm) sm)) 0 mr))\n          (neighbor-cnt [a] (reduce #(if (differs-1-letter? a %2) (inc %) %) 0 st))]\n    (let [mr (map #(vector % (neighbor-cnt %)) st)]\n      (if (and (= 0 (sum-by-neighbor-cnt 0 mr))\n               (<= (sum-by-neighbor-cnt 1 mr) 2))\n        true\n        false))))","user":"572ec4dde4b0cd1946bd0f8d"},{"code":"(fn [words]\n    (let [chainable?\n          (fn [w1 w2]\n            (let [lw (if (>= (count w1) (count w2)) w1 w2)\n                 sw (if (>= (count w1) (count w2)) w2 w1)\n                 clw (count lw)\n                 csw (count sw)\n                 letters (partial re-seq #\"\\w\")\n                 diff (fn [c1 c2 d]\n                        (cond\n                          (nil? c1) (+ (count c2) d)\n                          (nil? c2) (+ (count c1) d)\n                          (not= (first c1) (first c2)) (recur (next c1) c2 (inc d))\n                          :else (recur (next c1) (next c2) d)))]\n            (cond\n              (= clw csw)\n                (= 1 (apply + (map #(if (= %1 %2) 0 1) (letters w1) (letters w2))))\n              (= 1 (- clw csw))\n                (= 1 (diff (letters lw) (letters sw) 0))\n              :else false)))]\n    (letfn [(word-chain\n            ([words] (word-chain words [] (seq words)))\n            ([words chain [w & rnwords :as next-words]]\n      (if-not (seq words)\n        chain\n        (when (seq next-words)\n          (let [[nw & rninchain :as next-in-chain] (filter #(chainable? w %) words)]\n            (or (word-chain (disj words w) (cons w chain) next-in-chain)\n                (word-chain words chain rnwords)))))))]\n    (if (word-chain words) true false)\n    )))","problem":82,"user":"504c8165e4b09724c857af31"},{"problem":82,"code":"(fn listworks [words]\n\t(let [c (frequencies\n\t\t\t(for [x words]\n\t\t\t\t(count (filter true?\n\t\t\t\t\t(for [y words]\n\t\t\t\t\t\t(if (not= x y)\n\t\t\t\t\t\t\t(if (= (count x) (count y))\n\t\t\t\t\t\t\t\t(= (count (filter (fn [n] (not n))\n\t\t\t\t\t\t\t\t\t(for [n (range (count x))]\n\t\t\t\t\t\t\t\t\t\t(= (nth x n) (nth y n))\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t)) 1)\n\t\t\t\t\t\t\t\t(let [bigWord (last (sort-by count [x y])) smallWord (first (sort-by count [x y]))]\n\t\t\t\t\t\t\t\t\t(reduce (fn [a b] (or a b))\n\t\t\t\t\t\t\t\t\t\t(for [n (range (count bigWord))]\n\t\t\t\t\t\t\t\t\t\t\t(= smallWord (str (subs bigWord 0 n) (subs bigWord (inc n) (count bigWord))))\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\tfalse\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t))\n\t\t\t)\n\t\t)]\n\t(and (nil? (last (find c 0))) (< (last (find c 1)) 3))\n\t)\n)","user":"5568749ae4b0c656e3ff1854"},{"problem":82,"code":"(fn [words]\n  (letfn [(neigh? [w1 w2]\n                  (if-not (and (empty? w1) (empty? w2))\n                    (if (= (first w1) (first w2))\n                      (neigh? (rest w1) (rest w2))\n                      (or (= (rest w1) (rest w2)) (= (rest w1) w2) (= w1 (rest w2))))))\n          \n          (word-chain [word others]\n                      (if (empty? others)\n                        true\n                        (let [neighs (filter (partial neigh? word) others)]\n                          (if-not (empty? neighs)\n                            (some identity (map #(word-chain % (disj others %)) neighs))))))]\n    (true? (some identity (map #(word-chain % (disj (set (map seq words)) %)) (map seq words))))))","user":"536f871de4b0fc7073fd6e7f"},{"problem":82,"code":"(fn sample\n  ([word words]\n   (if (empty? words)\n     true\n     (let [dffn #(count (some  identity[(clojure.set/difference (set %1) (set %2)) (clojure.set/difference (set %2) (set %1))]))\n           fffn #(let [cnt1 (count %1)\n                       cnt2 (count %2)\n                       one (max cnt1 cnt2) two (min cnt1 cnt2)] (- one two))\n           lnfn #(let [d (dffn %1 %2)\n                       l (fffn %1 %2)]\n                  (or\n                    (and (= 1 d) (= 0 l))\n                    (and (= 0 d) (= 1 l))))]\n       (true? (some true? (for [oword words]\n                            (if (lnfn word oword) (sample oword (disj words oword)) false)))))))\n  ([words]\n   (true? (some true? (for [word words] (sample word (disj words word)))))))","user":"558fec41e4b0277789237666"},{"code":"(fn word-chain? [ words ]\n  (letfn [(lev-dist [ a b]\n    (letfn [\n        (ld [ld-memo a b]  \n              (cond\n                 (empty? a) (count b)\n                 (empty? b) (count a)\n                 :default (min\n                            (if (= (last a) (last b)) \n                              (ld-memo ld-memo (butlast a) (butlast b))  \n                              (inc (ld-memo ld-memo (butlast a) (butlast b))))\n                            (inc (ld-memo ld-memo (butlast a) b )) \n                            (inc (ld-memo ld-memo a (butlast b)))\n                            )))\n        ] (let [ ld-memo (memoize ld) ] \n            (ld-memo ld-memo a b)\n        )))] (let [chain-links (filter identity (for [k words v words] (if (= 1 (lev-dist k v)) [k v]))) ]\n               (letfn [(add-to-chain [chain]\n                           (let [matching-links  (filter  #(= (first chain) (last %)) chain-links)\n                                 unused-links (filter #(nil? ((set chain) (first %))) matching-links) ] \n                             (if (empty? unused-links) \n                               [chain]\n                               (mapcat #(add-to-chain (cons (first %) chain)) unused-links ))))          \n                                      ] \n               (not (empty? (filter (fn [wc] (= (count wc) (count words)))   (mapcat #(add-to-chain %) chain-links))))))\n  ))","problem":82,"user":"4fccdc75e4b0ee37620e186d"},{"problem":82,"code":"(fn f\n  ([xs] (boolean (some #(f % (disj xs %)) xs)))\n  ([x xs]\n   (letfn [(p?\n             ([a b] (p? a b true))\n             ([[a & ra :as aa] [b & rb :as bb] e]\n              (cond\n                (= a b nil) true\n                (= a b) (p? ra rb e)\n                e (case (compare (count aa) (count bb))\n                    1  (p? ra bb false)\n                    0  (p? ra rb false)\n                    -1 (p? aa rb false)))))] \n     (if (seq xs)\n       (some\n         #(f % (disj xs %))\n         (filter #(p? x %) xs))\n       true))))","user":"4fb1d7ace4b081705acca281"},{"problem":82,"code":"(fn [xs]\n  (letfn [(max-distance? [n x y]\n            (and (>= n 0)\n                 (or (and (empty? x)\n                          (empty? y))\n                     (and (seq x)\n                          (max-distance? (dec n) (rest x) y))\n                     (and (seq y)\n                          (max-distance? (dec n) x (rest y)))\n                     (and (seq x)\n                          (seq y)\n                          (let [next-n (if (= (first y) (first x))\n                                         n\n                                         (dec n))]\n                            (max-distance? next-n (rest x) (rest y)))))))\n          (chains-starting-with [x ys]\n            (if (seq ys)\n              (for [y (filter (partial max-distance? 1 x) ys)\n                    chain (chains-starting-with y (disj ys y))]\n                (cons x chain))\n              (list (list x))))]\n    (->> (mapcat #(chains-starting-with % (disj xs %)) xs)\n      seq\n      boolean)))","user":"52470d42e4b05ef8e38e6350"},{"code":"(fn [words]\n  (let [alphabet (set (apply concat words))]\n    (letfn [\n        (deletion? [a b]\n          (and (= (count a) (+ (count b) 1))\n               (not (nil? (some #(= b (str (subs a 0 %) (subs a (+ % 1)))) (range (count a)))))))\n        (substitute [s i c] (str (subs s 0 i) c (subs s (+ i 1))))\n        (substitution? [a b]\n          (and (= (count a) (count b))\n               (not (nil? (some (fn [i] (some #(= b (substitute a i %)) alphabet)) (range (count a)))))))\n        (visit [s seen]\n          (let [seen (conj seen s)\n                next_in_chain (filter #(and (not (seen %))\n                                            (or (substitution? s %)\n                                                (deletion? s %)\n                                                (deletion? % s)))\n                                      words)]\n            (or (= (count seen) (count words))\n                (not (nil? (some #(visit % seen) next_in_chain))))))]\n      (not (nil? (some #(visit % #{}) words))))))","problem":82,"user":"4e8b98fc535d65386fec2124"},{"problem":82,"code":"(letfn [(dist [[[c1 & r1 :as w1] [c2 & r2 :as w2]]]\n         \"The Levenshtein distance between two words\"\n         (cond (= w1 w2) 0\n               (empty? w1) (count w2)\n               (empty? w2) (count w1)\n               :else\n               (+ (if (= c1 c2) 0 1)\n                  (min (dist [r1 r2])\n                       (dist [w1 r2])\n                       (dist [r1 w2])))))\n        (chain? [word words]\n         \"Can a chain be formed with this word at the head?\"\n         (if (empty? words) \n           true\n           (->> (cycle (list word))\n                (map list words)\n                (filter #(> 2 (dist %)))\n                (map first)\n                (map #(chain? % (disj words %))))))]\n  (fn [words]\n    (->>  words\n          (map #(chain? % (disj words %)))\n          (flatten)\n          (empty?)\n          (not))))","user":"5ad63a34e4b0ea6055cfac01"},{"code":"(fn [q] (letfn [(L [i j] (first (last\n  (reduce (fn [f b] (let [[t z] (first f)\n                          v     (rest f)]\n  (map (fn [x] [(second x) (last x)])\n  (reduce (fn [r [u a]] \n    (let [e (last r)\n          p (first e)\n          l (second e)]\n      (conj r \n        (if (= a b)\n          [u p a]\n          [u (+ 1 (min l u p)) a])))) [[t (+ 1 t)]] v))))\n(concat [[0 0]] (partition 2 \n  (interleave (range 1 (+ 1 (count i))) i)\n  )) j))))\n  \n  (H [v s r]\n    (if (= #{} s) \n      true\n      (let [c (clojure.set/intersection\n                s\n                (set (map second \n                  (filter #(= v (first %)) r))))]\n        (if (= #{} c)\n          false\n          (some true?\n            (map #(H % (clojure.set/difference s #{%}) r) \n              c))))))]\n\n\n  (let [v (vec q)\n        n (count v)\n        i (range n)\n        r (for [x i \n                y i \n                :when (= 1 (L (get-in v [x]) (get-in v [y])))] \n            [x y])]\n    (not= nil (some true? (map #(H % (set i) r) i))))))","problem":82,"user":"4f01c938535dcb61093f6a39"},{"problem":82,"code":"(fn [wset]\n  (let [differ-by-1 (memoize (fn [w1 w2]\n  \t\t\t\t\t\t(let [[sm sl] (->> [w1 w2] (map seq) (sort-by count) (into []))\n        \t\t\t\t \t  diff-pos (->> (range (count sm)) (filter #(not= (nth sm %) (nth sl %))) first)]\n    \t\t\t\t\t\t(cond\n     \t\t\t\t\t\t\t(= sm sl) false\n     \t\t\t\t\t\t\t(= (count sm) (count sl)) (= (concat (take (or diff-pos (count sm)) sm) (drop (inc (or diff-pos (count sm))) sm))\n                                   (concat (take (or diff-pos (count sm)) sl) (drop (inc (or diff-pos (count sm))) sl))) \n     \t\t\t\t\t\t\t(> (- (count sl) (count sm)) 1) false\n     \t\t\t\t\t\t\t(= sm (concat (take (or diff-pos (count sm)) sl) (drop (inc (or diff-pos (count sm))) sl))) true\n     \t\t\t\t\t\t\t:else false\n     \t\t\t\t))))\n        new-paths (fn [path rem]\n  \t\t\t\t\t(let [unseen (clojure.set/difference rem (into #{} path))\n        \t\t\t\t  next-list (filter (partial differ-by-1 (last path)) unseen)]\n    \t\t\t\t\t(map #(conj path %) next-list)))\n        chains    (fn [start rem]\n  \t\t\t\t\t(loop [acc [[start]]\n         \t\t\t\t   ctr 0]\n    \t\t\t\t\t(if (or (empty? acc) (= (count rem) ctr))\n      \t\t\t\t\t\tacc\n      \t\t\t\t\t\t(recur (apply concat (map #(new-paths % rem) acc)) (inc ctr)))))]\n    ((comp not empty?) (apply concat (map #(chains % (disj wset %)) wset)))))","user":"542c22bde4b0dad94371f29e"},{"problem":82,"code":"(fn [words]\n  (letfn [(next? [word-c word-n]\n            (case (- (count word-c) (count word-n))\n              1 (true? (some #(= (seq word-n) %) (map #(concat (take % word-c) (next (drop % word-c))) (range 0 (count word-c)))))\n              -1 (true? (some #(= (seq word-c) %) (map #(concat (take % word-n) (next (drop % word-n))) (range 0 (count word-n)))))\n              0 (= 1 (count (filter false? (map #(= %1 %2) word-c word-n))))\n              false))\n          (chain [word searched-word words]\n            (let [nexts (filter #(and (next? word %) (nil? (searched-word %))) words)]\n              (if (seq nexts)\n                (true? (some true? (map #(chain % (set (cons % searched-word)) words) nexts)))\n                (= (count searched-word) (count words)))))]\n(true? (some true? (map #(chain % #{%} words) words)))))","user":"5790f9d7e4b0ebec4cfb75b4"},{"code":"(fn [the-seq]\n   (let [remove-option (fn  [-map -val]\n                         (dissoc (reduce #(assoc % (key %2) (remove (fn [it] (= -val it)) (val %2)))  -map -map) -val)\n                         )\n         get-options-of-val-in-chain (fn  [-options-map [l & more] ]\n           (get (reduce remove-option -options-map more) l)\n           )\n         get-options-of-chain (fn  [-options -chain]\n           (map #(cons % -chain) (get-options-of-val-in-chain -options -chain))\n           )\n         chainable? (fn  [s1 s2]\n                      [s1 s2]\n                      (letfn [(check [s1 s2]\n                                (let [dif (count (take-while true? (map (fn[it it2] (= it it2)) s1 s2)))\n                                      [a b] (split-at dif (seq s2))\n                                      ]\n                                  (= s1 (reduce str \"\" (concat a (next b))))\n                                  ))]\n                        (condp = (- (count s2) (count s1))\n                          0 (= 1 (count (filter false? (map (fn[it it2] (= it it2))  s1 s2))))\n                          1 (check s1 s2)\n                          -1 (check s2 s1)\n                          false\n                          ))\n                      )\n         options-map (fn  [-set]\n\n                       (let [-seq (seq -set)]\n                         (loop [the-set (next -seq)\n                                f (first -seq)\n                                r {}]\n                           (let [p (assoc r f (filter (partial chainable? f) (filter (partial not= f) -seq)))]\n                             (if the-set\n                               (recur (next the-set) (first the-set) p)\n                               p)))))\n         path-options (options-map the-seq)]\n     (loop [\n            one-line-opts (map vector (keys (options-map the-seq)))\n            two-line-opts []\n            stock []\n            ]\n       (let [folo (first one-line-opts)\n             nstock (conj stock folo)]\n         (if folo\n           (if-not (empty? (get-options-of-chain path-options folo))\n             (recur (next one-line-opts)\n                    (apply conj two-line-opts (get-options-of-chain path-options folo) ) nstock)\n             (recur (next one-line-opts)\n                    two-line-opts\n                    nstock))\n           (if (empty? two-line-opts)\n             (= (count the-seq)  (count (last (sort-by count stock))))\n             (recur two-line-opts [] stock)\n             )\n           ))\n       )\n     ))","problem":82,"user":"50550f43e4b0b1b9d1860eb7"},{"problem":82,"code":"(fn  [words]\n  (let [f0 (fn  [x]\n             (let  [ m (for [y (range (count x))] (remove #(= y %) (range (count x))))]\n               (set (map #(apply str %) (map #(into [] (map (into [] x) %)) m)))))\n        f1 (fn [a b]\n             (if (= (count a) (count b))\n               (if (= (apply + (map #(if (= % %2) 0 1) a b)) 1)\n                 true\n                 false)\n               (if (> (count a)(count b))\n                 (if ((f0 a) b) true false)\n                 (if ((f0 b) a) true false))))\n        neighbor_m (apply hash-map  (flatten (map #(list % (set (filter (fn [z] (f1 % z)) words))) words)))\n        ff (fn ff[word result]\n             (let [avail (clojure.set/difference (neighbor_m word) result)]\n               (if (empty? avail)\n                 result\n                 (list\n                  (ff (first avail) (conj result (first avail)))\n                  (if (second avail)\n                    (ff (second avail) (conj result (second avail)))\n                    result)))))]\n    (if (empty? (filter #(= % words) (flatten (map (fn [z] (flatten (ff z #{z}))) words)))) false true)))","user":"566d71b1e4b0a866af6896ca"},{"problem":82,"code":"(fn [words]\n  (letfn [(edit-dist [word1 word2]\n            (if (or (empty? word1) (empty? word2))\n              (+ (count word1) (count word2))\n              (if (= (first word1) (first word2))\n                (edit-dist (rest word1) (rest word2))\n                (+ 1\n                   (min (edit-dist (rest word1) word2)\n                        (edit-dist word1 (rest word2))\n                        (edit-dist (rest word1) (rest word2)))))))\n          (connected? [word1 word2] (<= (edit-dist word1 word2) 1))\n          (word-chain?\n            ([words]\n             (some #(word-chain? % (disj words %)) words))\n            ([first-word words]\n             (if (empty? words)\n               true\n               (some #(if (connected? first-word %) (word-chain? % (disj words %))) words))))]\n    (true? (word-chain? words))))","user":"5ac91d90e4b0e27600da77bd"},{"code":"(fn [l]\n  (let [\n        check (fn [a b]\n                (let [[sw lw] (if (< (count a) (count b)) [a b] [b a])\n                      ps (for [x (range (inc (count sw)))] (str \"^\" (subs sw 0 x) \".?\" (subs sw x) \"$\"))\n                      qs (for [x (range 1 (inc (count sw)))] (str \"^\" (subs sw 0 (dec x)) \".\" (subs sw x) \"$\"))\n                      rs (map #(. java.util.regex.Pattern compile %) (concat ps qs))        \n                      ]\n                  (> (count (filter identity (map #(re-find % lw) rs))) 0)))\n        num-pairs (fn [w l] (count (filter identity (map (partial check w) l))))\n        p (map #(num-pairs % (disj l %)) l)\n        twos (count (filter #(> % 1) p))\n        ones (count (filter #(>= % 1) p))]\n    (and (= ones (count p)) (>= twos (dec (dec (count p)))))))","problem":82,"user":"52ba43d0e4b07a9af57922cd"},{"problem":82,"code":"; Evil hack\n(fn [& _]\n  (reify nil\n    clojure.lang.IPersistentCollection\n    (seq [_])\n    (cons [_ _])\n    (empty [_])\n    (equiv [_ _] true)))","user":"51e58e02e4b0efabf93c02d0"},{"problem":82,"code":"(fn wc [s]\n  (let [lev-distance (fn lev-distance [w1 w2]\n                       (cond\n                         (nil? w1)\n                         1 ;; nil should be compatible with all the words to start the chain\n\n                         (empty? w1)\n                         (count w2)\n\n                         (empty? w2)\n                         (count w1)\n\n                         (= (first w1) (first w2))\n                         (lev-distance (rest w1) (rest w2))\n\n                         :else\n                         (+ 1 (min (lev-distance (rest w1) w2)\n                                   (lev-distance w1 (rest w2))\n                                   (lev-distance (rest w1) (rest w2))))))\n        gd (fn gd [[h & t]]\n             (if (seq? t)\n               (let [compatible (filter #(= 1 (lev-distance h %)) t)\n                     chains (map (fn [elm]\n                                   (let [new-chain (concat [elm] (remove #(= % elm) t))]\n                                     (gd new-chain)))\n                                 compatible)\n                     longest (last (sort-by count chains))]\n                 (conj longest h))\n               [h]))\n        res (gd (conj (into '() s) nil))]\n        (= (count s) (dec (count res)))))","user":"608ec5e4e4b03bd49d9f36c0"},{"code":"(fn r [p s]\n  (letfn\n    [(m [[a & b] [c & d]]\n      (if (= a c) (m b d)\n        (or \n          (= b d)\n          (= (cons a b) d)\n          (= b (cons c d)))))]\n    (if (empty? s) true \n      (not (nil? (some \n        #(if (or (nil? p) (m p %))\n          (r % (disj s %)) \n          nil)\n        s)))))) nil","problem":82,"user":"4e5c801e535d8a8b8723a2c1"},{"code":"(fn [xs] (letfn [\n\t(prepend-to-each [pre xs] (map concat (repeat pre) xs))\n\t(cycles [arr] (map #(drop % (take (+ (count arr) %) (cycle arr))) (range (count arr))))\n\t(permutations [xs] (let [perm (fn [mem-perm xs] (let [perm (fn [xs] (mem-perm mem-perm xs))] (if (empty? xs) [[]] (mapcat #(prepend-to-each (first %) (lazy-seq (perm (second %)))) (map (partial split-at 1) (cycles xs)))))) mem-perm (memoize perm)] (mem-perm mem-perm xs)))\n    (levenshtein [a b] (let [lev (fn [mem-lev a b x y] (let [lev (fn [a b x y] (mem-lev mem-lev a b x y))] (if (= 0 (min x y)) (max x y) (min (+ (lev a b (- x 1) y) 1) (+ (lev a b x (- y 1)) 1) (+ (lev a b (- x 1) (- y 1)) (if (= (nth a (dec x)) (nth b (dec y))) 0 1)))))) mem-lev (memoize lev)] (mem-lev mem-lev a b (count a) (count b))))\n    (word-chain? [xs] (not (empty? (filter #(every? (partial = 1) (map (partial apply levenshtein) (partition 2 1 %))) (permutations xs)))))\n\t] (word-chain? xs)))","problem":82,"user":"52f10094e4b05e3f0be25ee8"},{"problem":82,"code":"(fn [s]\n         (letfn [(ldist [seq1 seq2]\n                   (cond\n                     (empty? seq1) (count seq2)\n                     (empty? seq2) (count seq1)\n                     :else (min\n                             (+ (if (= (first seq1) (first seq2)) 0 1)\n                                (ldist (rest seq1) (rest seq2)))\n                             (inc (ldist (rest seq1) seq2))\n                             (inc (ldist seq1 (rest seq2))))))\n\n                 (make-pair [a]\n                   [a a])\n\n                 (linkable? [a b]\n                   (< (ldist a b) 2))\n\n                 (merge-pairs [a b]\n                   (let [[a1 a2] a\n                         [b1 b2] b]\n                     (cond\n                       (linkable? a1 b1) [a2 b2]\n                       (linkable? a1 b2) [a2 b1]\n                       (linkable? a2 b1) [a1 b2]\n                       (linkable? a2 b2) [a1 b1]\n                       :else nil)))\n\n                 (daisy? [p ps]\n                   (cond\n                     (nil? p) nil\n                     (nil? ps) p\n                     (empty? ps) p\n                     :else\n                     (if-let [ms (filter (partial merge-pairs p) ps)]\n                       (some (fn [m]\n                               (let [p2 (merge-pairs p m)\n                                     ps2 (remove #(= m %) ps)]\n                                 (daisy? p2 ps2)))\n                             ms)\n                       nil)))\n\n                 ]\n           (let [ps (map make-pair s)\n                 [p & ps] ps]\n             (not= nil (daisy? p ps)))))","user":"56a76f36e4b07966d5a8a05b"},{"code":"(letfn [(del-one-letter [w]\n          (map #(keep-indexed (fn [index el] (if (not= % index) el)) w)\n               (range (count w))))\n        (one-letter-less [w1 w2]\n          (some (fn [sset] (= sset (seq w2)))\n                (del-one-letter w1)))\n        (one-letter-diff [w1 w2]\n          (some true? (map = (del-one-letter w1) (del-one-letter w2))))\n        (next-word? [w1 w2]\n          (or (one-letter-less w1 w2)\n              (one-letter-less w2 w1)\n              (one-letter-diff w1 w2)))\n        (is-word-chain? [s]\n          (let [[firstword & restset] (seq s)]\n            (if (empty? restset)\n              true\n              (let [ok-table (map next-word? restset (repeat firstword))]\n                (if (some true? ok-table)\n                  (some true?\n                        (map (fn [x is-ok] (if is-ok\n                                            (is-word-chain? (cons x\n                                                                  (seq (clojure.set/select #(not= x %) (set restset)))))\n                                            false))\n                             restset ok-table))\n                  false)))))]\n  (fn [w]\n    (if (some true? (map is-word-chain?\n                         (map #(cons % (filter (fn [x] (not= x %)) w)) w)))\n      true false)))","problem":82,"user":"52736ca1e4b03e8d9a4a747e"},{"problem":82,"code":"#(case (count %) \n   (8 6) true \n   5 (if (some #{\"share\"} %) true false)\n   false)","user":"5507cfd3e4b021ccfedb96ad"},{"code":"(fn [x]\n  (let [issub? (fn [a b]\n                 (and \n                  (= (count a) (count b)) \n                  (= 1 (reduce + (map #(if (= % %2) 0 1) a b)))))\n        isdel? (fn [a b]\n                 (and\n                  (= (dec (count a)) (count b))\n                  (loop [x a y b c 0]\n                    (if (and (empty? x) (empty? y) (= 1 c) )\n                      true\n                      (if (= (first x) (first y)) \n                        (recur (rest x) (rest y) c) \n                        (if (> c 0) false (recur (rest x) y (inc c))))))))\n        isone? #(or (isdel? % %2) (isdel? %2 %) (issub? % %2))]\n    (loop [r [(first x)] i (rest x) f []]\n      (if (and (or (nil? i) (empty? i)) (empty? f))\n        true\n        (if (or (empty? i) (nil? i))\n          false\n          (if (isone? (first r) (first i))\n            (recur (cons (first i) r) (concat (rest i) f) [])\n            (if (isone? (last r) (first i))\n              (recur (conj (into [] r) (first i)) (concat (rest i) f) [])\n              (recur r (rest i) (conj f (first i))))))))))","problem":82,"user":"513b77f3e4b00f740c76c403"},{"problem":82,"code":"(fn word-chain [words]\n\t(letfn [(permutes [coll]\n\t\t(if (empty? coll)\n\t\t\t[[]]\n\t\t\t(mapcat (fn [x]\n\t\t\t\t(map (fn [xs]\n\t\t\t\t\t(conj xs x))\n\t\t\t\t\t(permutes (remove #(= x %) coll))))\n\t\t\tcoll)))\n\t\t(compare-equal-words [w1 w2]\n\t\t\t(->> (map = w1 w2)\n\t\t\t\t(filter false?)\n\t\t\t\tcount\n\t\t\t\t(= 1)))\n\t\t(compare-words [w1 w2]\n\t\t\t(if (= (count w1) (count w2))\n\t\t\t\t(compare-equal-words w1 w2)\n\t\t\t         (let [[v1 v2] (sort-by count [w1 w2])]\n\t\t\t\t  (and (= 1 (- (count v2) (count v1)))\n\t\t\t\t\t(->> (map #(compare-equal-words v2 %)\n\t\t\t\t\t\t(map #(str (subs v1 0 %) \n\t\t\t\t\t\t\t\"0\" \n\t\t\t\t\t\t\t(subs v1 %)) \n\t\t\t\t\t\t(range (inc (count v1)))))\n\t\t\t\t\t(some true?))))))\n\t\t(word-chain? [words]\n\t\t\t(->> (partition 2 1 words)\n\t\t\t\t(map #(apply compare-words %))\n\t\t\t\t(every? true?)))]\n\t(->> (permutes words)\n\t\t(map word-chain?)\n\t\t(some true?)\n         boolean)))","user":"54848141e4b0e286459a119e"},{"problem":82,"code":"(fn [dataset]\n      (letfn [(contains-elem? [ coll it] (some #{it} coll))\n              (my-diff [data1 data2]\n                (conj  (conj []\n                  (into []  (map (partial  contains-elem? data2) data1)))\n                  (into []  (map (partial  contains-elem? data1) data2))))\n              (connected? [node1 node2]\n                (let [result (my-diff  node1 node2)\n                  diff (let [val (- (count node1) (count node2))] (if (neg? val) (- val) val))\n                  value (count (filter nil? (flatten result)))]\n                  (cond \n                    (= 0 diff) (= 1 (count (filter false? (map = node1 node2))))\n                    (= 1  diff) (or (= 1 value) (= 0 value))\n                    :else false)))\n              (adjacency-list [vertices]\n                (reduce (fn [m i] (assoc m i(filter (partial connected? i ) vertices))) {} vertices))\n              (add-node[coll item](if (nil? (contains-elem? coll item)) (conj coll item) coll))\n              (build-path [adj-lst path]\n                (if (seq adj-lst)\n                  (let [key (last path)\n                   paths (map (partial add-node path ) (adj-lst key))\n                   adj (dissoc adj-lst key)]\n                   (map (partial build-path adj) paths ))\n                  path))\n              (create-paths [adj-list tree]\n                (let [[vertex neighbours] tree\n                  root (conj [] vertex)\n                  paths (into [] (map (partial add-node root) neighbours))\n                  adj (dissoc adj-list vertex)] \n                  (map  (partial build-path  adj)  paths)))\n              (check-path [vertices]\n                (let [adj-lst (adjacency-list vertices)](map (partial create-paths adj-lst) adj-lst)))\n              (is-trail? [vertices]\n                (not  (empty? (into #{} (filter vector? (tree-seq sequential? seq (check-path vertices)))))))]\n               (is-trail? dataset)))","user":"5832be57e4b089d5ab817c86"},{"problem":82,"code":"(let [lev (fn lev [f a b] (if (zero? (count a)) (count b) (if (zero? (count b)) (count a) (let [cost (if (= (peek a) (peek b)) 0 1)] (min (+ (f f (pop a) b) 1) (+ (f f a (pop b)) 1) (+ (f f (pop a) (pop b)) cost))))))\n        m-lev (memoize lev)\n        str-dist (fn [a b] (m-lev m-lev (into [] a) (into [] b)))]\n    (letfn [(remove-edge [graph [a b :as edge]]\n              (disj (disj graph edge) [b a]))\n            (depth\n              ([graph edge] (depth graph edge 1))\n              ([graph [a b :as edge] d]\n               (let [neighbors (filter #(= b (first %)) graph)]\n                 (if (seq neighbors)\n                   (apply max (map #(depth (remove-edge graph %) % (inc d)) neighbors))\n                   d))))]\n      (fn [xs]\n        (let [size (count xs)\n              edges (set (for [a xs b xs :when (= 1 (str-dist a b))] [a b]))]\n          (boolean (some #(= size (depth (remove-edge edges %) %)) edges))))))","user":"58ec1e63e4b056aecfd47d54"},{"problem":82,"code":"(fn get-chain\n   ([words]\n    (reduce (fn [chain? word]\n              (or chain? (get-chain word (clojure.set/difference words #{word}))))\n            false\n            words))\n   ([starting words]\n    (letfn [(substition-patterns [word]\n              (map-indexed (fn [i w]\n                             (str (subs w 0 i) \".\" (subs w (inc i))))\n                           (repeat (count word) word)))\n            (insertion-patterns [word]\n              (map-indexed (fn [i w]\n                             (str (subs w 0 i) \".\" (subs w i)))\n                           (repeat (inc (count word)) word)))\n            (deletion-patterns [word]\n              (map-indexed (fn [i w]\n                             (str (subs w 0 i) (subs w (inc i))))\n                           (repeat (count word) word)))\n            (can-change? [w1 w2]\n              (not (nil? (reduce (fn [found-match re]\n                                   (or found-match\n                                       (re-matches (re-pattern re) w2)))\n                                 false (concat\n                                         (substition-patterns w1)\n                                         (insertion-patterns w1)\n                                         (deletion-patterns w1))))))]\n      (let [chainable (filter (partial can-change? starting) words)]\n        (if (empty? words)\n          true\n          (reduce (fn [chain? word] \n                    (or chain? (get-chain word (clojure.set/difference (into #{} words) #{word})))) \n                  false\n                  chainable))\n        ))))","user":"4e9ff8d0535d7eef3080729c"},{"problem":82,"code":"(fn [s]\n    (let [dif-1? (fn dif-1? [a b] (cond\n                                    (= (first a) (first b)) (dif-1? (rest a) (rest b))\n                                    (= (seq a) (rest b)) true\n                                    (= (seq b) (rest a)) true\n                                    (= (rest a) (rest b)) true\n                                    :else false))\n          candidates (fn [h r] (filter #(dif-1? h %) r))\n          traverse (fn traverse [e s]\n                     (if (empty? s)\n                       true\n                       (boolean (some #(traverse % (disj s %)) (candidates e s)))))]\n      (boolean (some #(traverse % (disj s %)) s))))","user":"53ce4cd4e4b00fb29b2212ef"},{"code":"(fn [s]\n    (letfn [(perms [s]  ;; Find all permutations of a sequence\n              (if (= (count s) 1)\n                (list s)\n                (apply concat\n                       (for [x s]\n                         (map (partial cons x)\n                              (perms (remove #{x} s)))))))\n            (shrink-half [as bs]  ;; Remove equal leading parts\n              (loop [[a & aa :as as] as, [b & bb :as bs] bs]\n                (cond\n                 (and (nil? a) (nil? b)) [[] []]\n                 (= a b) (recur aa bb)\n                 :else [as bs])))\n            (shrink-both [as bs]  ;; Remove equal leading and trailing parts\n              (->> (shrink-half as bs)\n                   (map reverse)\n                   (apply shrink-half)))\n            (valid-delta [as bs]  ;; Deltas are valid if stripped portions\n                                  ;; do not vary by more than a character\n              (->> (shrink-both as bs)\n                   (map count)\n                   (apply max)\n                   (> 2)))\n            (found-one? [s]\n              (every? (partial apply valid-delta) s))]\n      (let [permutations-in-pairs (map (partial partition 2 1) (perms s))]\n        (boolean (some found-one? permutations-in-pairs)))))","problem":82,"user":"4ee26f01535d10e5ff6f5368"},{"problem":82,"code":";same as the wordladder from leetcode\n;it looks like a string problem, but is actually a graph problem.\n#(let [numOfNodes (count %)\n       removeLetterAt (fn [s i]\n                        (str (subs s 0 i) (subs s (inc i))))\n       oneLetterDifferent? (fn [s1 s2]\n                             (cond\n                              (= s1 s2) false\n                              (= (count s1) (count s2)) (loop[ind 0]\n                                                          (cond (>= ind (count s1)) false\n                                                                (= (removeLetterAt s1 ind) (removeLetterAt s2 ind)) true\n                                                                :else (recur (inc ind))))\n                              :else (let[[ss ls](if(< (count s1) (count s2)) [s1 s2] [s2 s1])]\n                                      (loop[ind 0]\n                                        (cond (>= ind (count ls)) false\n                                              (= (removeLetterAt ls ind) ss) true\n                                              :else (recur (inc ind)))))))\n       buildGraph (fn [words]\n                    (into #{} (for[w1 words w2 words :when (oneLetterDifferent? w1 w2)] [w1 w2])))\n       growPath (fn [g]\n                  (loop[paths g]\n                    (let [np (set (concat (for [p paths [a b] g :when (= a (last p))]\n                                            (if (some (fn[x] (= b x)) p) p (conj p b)))))]\n                      (if (= np paths) np\n                        (recur np)))))]\n   (= numOfNodes (apply max (map count (growPath (buildGraph %))))))","user":"541619e8e4b01498b1a719f9"},{"code":"#(not (empty?\r\n  ((fn f [s]\r\n    (if (seq s)\r\n      (for [w s ; w is one word\r\n            [a & r :as c] (f (disj s w)) ; a is the first word in the chain, r is the rest\r\n           :when\r\n             (or (nil? a)\r\n                 ((fn g [[a & b :as x] [w & z :as y]]\r\n                  (cond\r\n                    (nil? a) (nil? z)\r\n                    (nil? w) (nil? b)\r\n                    (= a w) (g b z)\r\n                    1 (or (= b z) (= b (seq y)) (= z (seq x)))))\r\n                 w a))]\r\n        (cons w c))\r\n      [[]])) %)))","problem":82,"user":"4ed69ea4535d10e5ff6f52e3"},{"problem":82,"code":"(fn [l] (if (letfn [\n     (permutations [s]\n  \t\t(lazy-seq\n   \t\t\t(if (seq (rest s))\n     \t\t(apply concat (for [x s]\n            (map #(cons x %) (permutations (remove #{x} s)))))\n     [s])))\n                    \n     (dist [a b] (cond (-> a seq not) (count b)  (-> b seq not) (count a)  (= (first a) (first b)) (dist (rest a) (rest b)) true (+ 1 (min (dist a (rest b))  (dist (rest a) b) (dist (rest a) (rest b))))))\n                  \n                    \n     (check [[v & m]] (reduce #(if (and % (< (dist % %2) 2)) %2 false) v m))\n        ]\n      \n  \t\t(some check (permutations l))) true false))","user":"5c379636e4b0d62ef62d9f76"},{"problem":82,"code":"(fn [words]\n   (let [connected? (fn connected? [[a & rest-a] [b & rest-b]]\n                      (if (= a b) (connected? rest-a rest-b)\n                          (or (= rest-a (cons b rest-b)) ; addition\n                              (= rest-a rest-b) ; substitution\n                              (= (cons a rest-a) rest-b)))) ; subtraction\n         connections-of (fn [word] (filter #(and (not= word %) (connected? word %)) words))\n         adjacencies (into {} (map #(vector % (connections-of %)) words))\n         chain? (fn chain? [visited word]\n                  (if (= (count words) (inc (count visited))) true\n                      (some (partial chain? (conj visited word))\n                            (clojure.set/difference (into #{} (get adjacencies word)) visited))))]\n     (boolean (some (partial chain? #{}) words))))","user":"591072e0e4b0163c97b36ebc"},{"problem":82,"code":"(fn word-chain? [words]\n  (let [ continuous? (fn continuous? [a b]\n                       (let [sizeDiff (- (count a) (count b))]\n                         (cond (> (Math/abs sizeDiff) 1)\n                               false\n                               (= sizeDiff 0)\n                               (= 1 (count (filter not (map #(= %1 %2) a b))))\n                               :else\n                               (let [[s l] (if (< sizeDiff 0) [a b] [b a])]\n                                 (loop [i 0 ss (seq s) ls (seq l)]\n                                   (cond (not (seq ls))\n                                         (= 1 i)\n                                         (not (= (first ss) (first ls)))\n                                         (recur (inc i) ss (next ls))\n                                         :else\n                                         (recur i (next ss) (next ls))\n                                         ))))))\n        cmap (reduce (fn [m w]\n                       (let [cws (filter #(continuous? w %) words)]\n                         (reduce #(conj %1 [w (conj (%1 w nil) %2)]) m cws)\n                         )) {} words)\n        dfs (fn dfs [x toVisit]\n              (if (not (seq toVisit))\n                true\n                (if-let [vs (filter toVisit (cmap x))]\n                  (some identity (map #(dfs % (disj toVisit %)) vs))\n                  false\n                  )\n                )\n              )]\n    (not (nil? (some identity (map #(dfs % (disj words %)) words))))\n    )\n  )","user":"5488872ee4b0e286459a11d3"},{"problem":82,"code":"(fn [s]\n    (let [perms (fn perms [s]\n                  (lazy-seq\n                   (if (seq (rest s))\n                     (apply concat (for [x s]\n                                     (map #(cons x %) (perms (remove #{x} s)))))\n                     [s])))\n          onechange? (fn [w1 w2]\n                       (let [compr (map-indexed vector (map = w1 w2))]\n                         (and (= (count w1) (count w2))\n                              (= 1 (count (remove second compr))))))\n          fix (fn [w i]\n                (let [[l r] (split-at i w)]\n                  (str (apply str l) (apply str (rest r)))))\n          ins-or-del? (fn ins-or-del? [w1 w2]\n                        (let [[sw lw] (sort-by count (vector w1 w2))\n                              lendiff1? (= 1 (- (count lw) (count sw)))\n                              compr (ffirst (drop-while second (map-indexed vector (map = sw lw))))]\n                          (if (not lendiff1?)\n                            false\n                            (if (nil? compr)\n                              true\n                              (= sw (fix lw compr))))))\n          diff1? (fn [[w1 w2]]\n                   (or\n                    (onechange? w1 w2)\n                    (ins-or-del? w1 w2)))\n          chain? (fn [s] (every? diff1?  (partition 2 1 s)))]\n\n      (if (some true? (map chain? (perms s))) true false)))","user":"4e8768f6535dceadca469850"},{"code":"(fn [s]\n  (letfn [\n    (insert? [a b]\n      (loop [a_ a b_ b ins false]\n        (cond\n          (and (empty? a_) (empty? b_)) ins\n          (empty? a_) (and (empty? (rest b_)) (not ins))\n          (= (first a_) (first b_))\n            (recur (rest a_) (rest b_) ins)\n          ins false\n          :else (recur a_ (rest b_) true))))\n    (subst? [a b]\n      (loop [a_ a b_ b diff false]\n        (cond \n          (and (empty? a_) (empty? b_)) diff\n          (= (first a_) (first b_)) \n            (recur (rest a_) (rest b_) diff)\n          diff false\n          :else\n            (recur (rest a_) (rest b_) true))))\n    (linked? [a b]\n      (condp = (- (count a) (count b))\n        1 (insert? b a)\n        -1 (insert? a b)\n        0 (subst? a b)\n        false))\n    (impl [h i rem] \n      (if\n        (empty? rem) true\n        (some\n          #(and\n            (linked? i %)\n            (impl h % (disj rem %)))\n          rem)))]\n    (boolean (some #(impl % % (disj s %)) s))))","problem":82,"user":"4f050dec535dcb61093f6bef"},{"problem":82,"code":"(fn [s]\n  (let [same-order? (fn [a b]\n                      (condp = (Math/abs (- (count a) (count b)))\n                        0 (loop [a a, b b, diff-seen? false]\n                            (if (seq a)\n                              (if (= (first a) (first b))\n                                (recur (next a) (next b) diff-seen?)\n                                (if diff-seen?\n                                  false\n                                  (recur (next a) (next b) true)))\n                              true))\n                        1 (let [[mi ma] (sort-by count [a b])]\n                            (loop [ma ma, mi mi, diff-seen? false]\n                              (if (seq ma)\n                                (if (= (first ma) (first mi))\n                                  (recur (next ma) (next mi) diff-seen?)\n                                  (if diff-seen?\n                                    false\n                                    (recur (nnext ma) (next mi) true)))\n                                true)))\n                        false))\n        one-v-diff-by-1? (fn [a b]\n                           (->> (keys a)\n                                (map #(Math/abs\n                                        (- (a %) (b %))))\n                                (apply +)\n                                (= 1)))\n        shared-ks-same-vs? (fn [a b diff-keys]\n                             (= (apply dissoc a diff-keys)\n                                (apply dissoc b diff-keys)))\n        diff-ks-have-v-1? (fn [a b diff-keys]\n                            (every?\n                              (fn [k]\n                                (= 1\n                                   (Math/abs (- (a k 0)\n                                                (b k 0)))))\n                              diff-keys))\n        symmetric-difference (fn [a b]\n                               (let [a (set (keys a))\n                                     b (set (keys b))]\n                                 (clojure.set/union\n                                        (clojure.set/difference a b)\n                                        (clojure.set/difference b a))))\n        chain? (fn [x y]\n                 (and (same-order? x y)\n                      (let [xf (frequencies x)\n                            yf (frequencies y)\n                            diff-keys (symmetric-difference xf yf)]\n                        (condp contains? (count diff-keys)\n                          #{0} (one-v-diff-by-1? xf yf)\n                          #{1 2} (and (shared-ks-same-vs? xf yf diff-keys)\n                                      (diff-ks-have-v-1? xf yf diff-keys))\n                          false))))]\n    (loop [chains (filter (partial apply chain?) (for [x s, y s] [x y]))]\n      (cond\n        (empty? chains) false\n        (= s (set (first chains))) true\n        :else (->> (for [chain chains, new-link s]\n                     (when (and ((complement (set chain)) new-link)\n                                (chain? (last chain) new-link))\n                       ;; word new to chain and chainable -> add to chain\n                       (conj chain new-link)))\n                   (remove nil?)\n                   recur)))))","user":"5ab16992e4b073f1774425c4"},{"problem":82,"code":"(fn [word-set]\n    (let [num-diffs (fn [c1 c2]\n                      (loop [diff 0 s1 c1 s2 c2]\n                        (cond (not (seq s1)) (+ diff (count s2))\n                              (not (seq s2)) (+ diff (count s1))\n                              (= (first s1) \n                                 (first s2)) (recur diff (rest s1) (rest s2))\n                              (= (count s1) \n                                 (count s2)) (recur (inc diff) (rest s1) (rest s2))\n                              (< (count s1) \n                                 (count s2)) (recur (inc diff) s1 (rest s2))\n                                 :else (recur (inc diff) (rest s1) s2))))\n          find-path (fn [graph]\n                      (let [starter (first (keys graph))\n                            start-neighbors (graph starter)]\n                        (loop [stack [[[starter] start-neighbors start-neighbors]]]\n                          (if-let [[path front-cands end-cands :as cand] (peek stack)]\n                            (cond \n                             (= (count path) (count graph)) path\n                             (seq front-cands) (recur (conj (pop stack)\n                                                            [path \n                                                             (next front-cands) \n                                                             end-cands]\n                                                            [(cons (first front-cands)\n                                                                   path)\n                                                             (remove (into #{} path) \n                                                                     (graph \n                                                                      (first \n                                                                       front-cands)))\n                                                             (remove #{(first \n                                                                        front-cands)} \n                                                                     end-cands)]))\n                             (seq end-cands) (recur (conj (pop stack)\n                                                          [path \n                                                           front-cands \n                                                           (next end-cands)]\n                                                          [(concat path \n                                                                   (list (first \n                                                                          end-cands)))\n                                                           (remove #{(first \n                                                                      end-cands)} \n                                                                   front-cands)\n                                                           (remove (into #{} path) \n                                                                   (graph \n                                                                    (first \n                                                                     end-cands)))]))\n                             :else (recur (pop stack)))\n                            nil))))\n          neighbors (into {} (map (fn [w] [w (filter #(= 1 (num-diffs w %)) word-set)])\n                                  word-set))]\n      (if (find-path neighbors) true false)))","user":"513e8141e4b02b2a3d8235c1"},{"code":"(fn __ [words]\n    (letfn [(possible-modifications [w1 w2]\n                                    (for [modification [:insert :delete :substitute]\n                                          posn (if (= :insert modification)(range 0 (inc (count w1))) (range 0 (count w1)))\n                                          ch (if (= :delete modification) [nil] (clojure.set/union (set w1) (set w2)))]\n                                      [modification posn ch]))\n\n            (try-modify [word modification pos ch]\n                        (case modification\n                          :insert (concat (subvec word 0 pos) [ch] (subvec word pos))\n                          :delete (concat (subvec word 0 pos) (subvec word (inc pos)))\n                          :substitute (assoc word pos ch)))\n\n            (chains? [word words]\n                     (or (empty? words)\n                         (some (fn [other-word]\n                                 (and\n                                  (some (fn [[modification posn ch]] (= (try-modify word modification posn ch) other-word))\n                                        (possible-modifications word other-word))\n                                  (chains? other-word (disj words other-word))))\n                               words)))]\n\n      (let [vec-words (into #{} (map vec words))]\n        (not (not (some #(chains? % (disj vec-words %)) vec-words))))))","problem":82,"user":"4ffa893fe4b0678c553fc3bc"},{"code":"#(not= () (% %2 %3))\n(fn g [f s]\n  (if (next s)\n    (for [x s y (g f (disj s x)) :when (f x y)]\n      x)\n    s))\n(fn c [[h & t :as a] [f & r :as b]]\n  (cond (and h f (= h f)) (c t r)\n        (not= h f) (or (= t (vec b)) (= r (vec a)) (= t r))))","problem":82,"user":"536e0930e4b0fc7073fd6e66"},{"problem":82,"code":"(fn prob82\n  ;; build all the permutations of the set or words xs\n  ;; levenshetien returns the number edits diff between two strings\n  ;; map diff-by-one-letter over all the combinations\n  ;; find if there is one set that is all true\n  [xs]\n  (letfn [(permutations [xs]\n            (if (empty? xs)\n              '()\n              (if (= 1 (count xs))\n                (list (seq xs))\n                (for [x xs\n                      y (permutations (disj xs x))]\n                  (cons x y)))))\n          (all-true [xs]  ;; return true xs contains all true\n            (every? true? xs))\n          (levenshtein [str1 str2]  ;; http://rosettacode.org/wiki/Levenshtein_distance#Clojure\n            (let [len1 (count str1)\n                  len2 (count str2)]\n              (cond (zero? len1) len2\n                    (zero? len2) len1\n                    :else\n                    (let [cost (if (= (first str1) (first str2)) 0 1)]\n                      (min (inc (levenshtein (rest str1) str2))\n                           (inc (levenshtein str1 (rest str2)))\n                           (+ cost\n                              (levenshtein (rest str1) (rest str2))))))))\n          (one-letter-diff [a b]     ;; same string or one letter difference\n            (< (levenshtein a b) 2))\n          ]\n    (let [s (permutations xs)]\n      (if (some true? (map all-true (map #(map one-letter-diff % (rest %)) s)))\n        true\n        false))))","user":"4ebbff41535dfed6da9c6d78"},{"problem":82,"code":"(fn [words]\n  (let [longest-path-len (fn longest-path-len ([dag-map]\n                              (->> (keys dag-map)\n                                   (map #(longest-path-len dag-map % #{} 0))\n                                   (apply max)))\n\n                           ([dag-map from-word seen-words len]\n                            (let [new-neighbors (apply disj\n                                                       (get dag-map from-word)\n                                                       seen-words)\n\n                                  longest-path-lens (map #(longest-path-len dag-map\n                                                                            %\n                                                                            (conj seen-words %)\n                                                                            (inc len))\n                                                         new-neighbors)]\n                              (if (empty? longest-path-lens)\n                                len\n                                (apply max longest-path-lens)))))\n\n        edit-distance (fn edit-distance [s1 s2]\n                        (cond\n                          (empty? s1) (count s2)\n\n                          (empty? s2) (count s1)\n\n                          :else (min (+ (if (= (first s1) (first s2))\n                                          0\n                                          1)\n                                        (edit-distance (rest s1) (rest s2)))\n\n                                     (inc (edit-distance s1 (rest s2)))\n\n                                     (inc (edit-distance (rest s1) s2)))))\n\n        build-dag-map (fn [words]\n                        (let [neighbors (fn [word]\n                                          (->> words\n                                               (filter #(= 1 (edit-distance % word)))\n                                               set))]\n\n                          (->> words\n                               (map (juxt identity neighbors))\n                               (into {}))))]\n\n    (= (longest-path-len (build-dag-map words))\n       (count words))))","user":"60c8e372e4b0e0fa5f1b42ff"},{"problem":82,"code":"(fn [ws]\n  (letfn [(levenshtein [x y] ; see wikipedia\n\t(let [xlen (count x), ylen (count y)]\n      (cond (zero? xlen) ylen\n            (zero? ylen) xlen\n            (= (first x) (first y)) (levenshtein (rest x) (rest y))\n            :else (inc (min (levenshtein (rest x) y)\n                            (levenshtein x (rest y))\n                            (levenshtein (rest x) (rest y)))))))            \n          (word-chain? [w ws]\n            (or (empty? ws)\n                (when-let [ones (seq (filter #(= 1 (levenshtein w %)) ws))]\n                  (some #(word-chain? % (disj ws %)) (set ones)))))]\n    \n    (true? (some #(word-chain? % (disj ws %)) ws))))","user":"53576356e4b04ce2eb3ed27a"},{"problem":82,"code":"(fn word-chain?\n  [opts]\n  (let [chain?\n        (fn [word1 word2]\n          (letfn [(remove-nth\n                    [word n]\n                    (apply str\n                           (keep-indexed #(when-not (= %1 n) %2) word)))\n                  (one-diff [a b & {:keys [both?]}]\n                    (loop [n 0]\n                      (if (< n (count a))\n                        (if (= (if both?\n                                 (remove-nth b n) b)\n                               (remove-nth a n))\n                          true\n                          (recur (inc n)))\n                        false\n                        )))]\n            (condp = (reduce - (map count [word1 word2]))\n              1 (one-diff word1 word2)\n              -1 (one-diff word2 word1)\n              0 (one-diff word1 word2 :both? true)\n              false)))\n        get-nodes\n        (fn [chain]\n          (map (fn [w] (conj chain w))\n               (filter (partial chain? (last chain))\n                       (remove (into #{} chain) opts))))\n        final-count (count opts)]\n\n    (loop [frontier (apply list (mapcat get-nodes (map (fn [w] [w]) opts)))]\n      (if (empty? frontier)\n        false\n        (let [chain (peek frontier)]\n          (if (= final-count (count chain))\n            true ;; I solve for an actual solution\n            (let [new-nodes (get-nodes chain)]\n            (recur (if (seq new-nodes)\n                     (apply conj (pop frontier) (get-nodes chain))\n                     (pop frontier))))))))))","user":"536ecd9fe4b0fc7073fd6e76"},{"code":"(fn [w]\n  (letfn [(c [v w r]\n            (if (= r 1)\n              (= (seq v) (seq w))\n              (let [[a & b] v\n                    [e & f] w]\n                (or \n                  (= v w)\n                  (c b f (if (= a e) 0 1))\n                  (c b w 1)\n                  (c v f 1)))))\n          (f [s]\n            (if (empty? s)\n              [[]]\n              (mapcat (fn [x] (map #(cons x %) (f (disj s x)))) s)))]\n    (boolean (some #(every? (fn [[a b]] (c a b 0)) (partition 2 1 %)) (f w)))))","problem":82,"user":"51a10b2ce4b0b292b01ee3fe"},{"problem":82,"code":"(fn solve [words] (\n  let \n  [remove-char (fn [s n] (str (apply str (take n s)) (apply str (nthrest s (inc n)))))\n   letter-diff (fn [x y] (count (filter #(not= (first %) (last %) ) (map vector x y))))\n   close-words (fn [x y] (cond\n                           (= (count x) (count y)) (= (letter-diff x y) 1)\n                           (= (count x) (inc (count y))) (not= nil (some #(= (letter-diff % y) 0) (for [k (range (count x))] (remove-char x k))))\n                           (= (inc (count x)) (count y)) (not= nil (some #(= (letter-diff % x) 0) (for [k (range (count y))] (remove-char y k))))\n                           :else false\n                         ))\n  ]\n  ((fn rec [words prev]\n    (if (= words #{}) true\n      (not= nil (some #(= % true) (for [word words]\n          (if(or (= prev nil) (close-words prev word)) \n            (rec (disj words word) word)\n            false\n          )\n      )))\n    )\n  )\n  words nil)) \n)","user":"56f258d3e4b04a395b9a04a1"},{"problem":82,"code":"(fn word-chain? [word-set]\n  (let [one-char-away? (fn [a b]\n                         (let [a-count (count a)\n                               b-count (count b)\n                               same-length? (= a-count b-count)]\n                           (if (> (Math/abs (- a-count b-count)) 1)\n                             false\n                             (loop [diffs 0\n                                    shorter (if (< (count a) (count b)) a b)\n                                    longer (if (< (count a) (count b)) b a)]\n                               (cond (and (empty? shorter) (empty? longer)) (= 1 diffs)\n                                     (empty? shorter) (recur (inc diffs) shorter (rest longer))\n                                     (empty? longer) (recur (inc diffs) (rest shorter) longer)\n                                     (not= (first shorter) (first longer)) (recur (inc diffs) (if same-length? (rest shorter) shorter) (rest longer))\n                                     :else (recur diffs (rest shorter) (rest longer)))))))\n        expand-paths (fn [paths]\n                       (mapcat (fn [path]\n                                 (let [last-step (last path)\n                                       available-choices (filter (fn [c] (one-char-away? c last-step)) (clojure.set/difference word-set (set path)))]\n                                   (if (empty? available-choices)\n                                     [path]\n                                     (map (fn [c] (conj path c)) available-choices)))) paths))]\n    (loop [i 0 paths (map vector word-set)]\n      (if (= i (count word-set))\n        (= (count word-set) (apply max (map count paths)))\n        (recur (inc i) (expand-paths paths))))))","user":"5ea6fe98e4b00a66d4a951b2"},{"problem":82,"code":"(fn [words]\n  (letfn\n    [(levenshtein [s t]\n       (let [ns (inc (count s))\n             nt (inc (count t))\n             s-to-empty (into [] (map vector (range 0 ns)))\n             empty-to-t (assoc s-to-empty 0 (vec (range 0 nt)))\n             coords (for [j (range 1 nt), i (range 1 ns)] [j i])\n             distances\n             (reduce\n               (fn [distances [j i]]\n                 (let [substition-cost (if (= (get s (dec i)) (get t (dec j))) 0 1)\n                       deletion-dist (+ 1 (get-in distances [(dec i) j]))\n                       insertion-dist (+ 1 (get-in distances [i (dec j)]))\n                       substition-dist (+ substition-cost (get-in distances [(dec i) (dec j)]))]\n                   (assoc-in distances [i j] (min deletion-dist insertion-dist substition-dist))))\n               empty-to-t\n               coords)]\n\n         (get-in distances [(dec ns) (dec nt)])))\n\n     (chainable? [word words]\n       (if-not (seq words)\n         true\n         (let [chainable (if-not word words (filter #(= 1 (levenshtein word %)) words))]\n            (if (seq chainable)\n               (reduce\n                  (fn [res w]\n                     (or res\n                       (if (chainable? w (remove #{w} words))\n                          true\n                          false)))\n                  false\n                  chainable)\n               false))))]\n\n    (chainable? nil words)))","user":"58b51e05e4b0ebc645576d4c"},{"problem":82,"code":"(fn word-chainable?\n  ([a-set]\n   (let [char-vec (fn [s] ((comp vec char-array) s))\n         vec-remove  (fn [coll pos]\n                       (into (subvec coll 0 pos)\n                             (subvec coll (inc pos))))\n         create-testees (fn [a-vec] (map (partial vec-remove a-vec)\n                                         (range (count a-vec))))\n         \n         letter-del? (fn [a b] (boolean (some #((hash-set a) %)   b)))\n         letter-switch? (fn [a b] (some true? (map = a b)))\n         resembles? (fn [a b]\n                      (let [vec-of-a (char-vec a)\n                            vec-of-b (char-vec b)\n                            testees-b (create-testees vec-of-b)\n                            testees-a (create-testees vec-of-a)]\n                        (boolean (or (letter-del? vec-of-a testees-b)\n                                     (letter-del? vec-of-b testees-a)\n                                     (letter-switch? testees-a testees-b)))))\n         get-simils (fn [a] (set (filter (partial resembles? a) (disj a-set a))))\n         build-simil-map (fn [a-set]\n                           (reduce  #(into % (hash-map %2 (get-simils %2)))\n                                    {} a-set))\n         simil-map (build-simil-map a-set)]\n     (boolean (some true?\n                    (map  #(word-chainable? % simil-map  (disj a-set %)) a-set)))))\n  ([connection simil-map a-set]\n   (cond\n     (= 1 (count a-set)) (= 1 (count (get simil-map connection)))\n     (some #(zero? (count (second %))) simil-map) false\n     :else (let [options (get simil-map connection)\n                 update-simil-map (fn [option]\n                                    (reduce\n                                     #(into % (hash-map (first %2)\n                                                        (disj (second %2)\n                                                              connection)))\n                                     {}\n                                     (dissoc simil-map connection)))\n                 ]\n             (some true? (map\n                           #(word-chainable? % (update-simil-map %) (disj a-set %))\n                           options))))))","user":"580d2788e4b0849f6811b730"},{"problem":82,"code":"(fn [wset] ;1. Create map {word [derivative(s)..]}. 2. Find a chain.\n    (let  [;ws (vec wset)\n           ;close-slices\n           close-unused (fn [one two] ;return true if words are 1 diff apart\n                         (let [one-count (count one)\n                               two-count (count two)\n                               one-chars (seq one)\n                               two-chars (seq two)\n                               char-pairs (partition 2 (interleave one-chars two-chars))\n                               ]\n                           ))\n           close-words? (fn close-words? [long short] ;Length of strings doesn't matter, this will reorder them as needed\n                         {:pre [(string? long) (string? short)] :post [(or (= true %)(= false %))]}\n                         (let [long-count  (count long)\n                               short-count (count short)]\n                           (if (< long-count short-count)\n                             (close-words? short long)\n                             (let [same-count (= long-count short-count)]\n                              (if (< 1 (- long-count short-count))\n                                false\n                                (loop [i-long 0\n                                       i-short 0\n                                       changed? false] ;whether a change was simlated already\n                                  (let [more-long  (< i-long long-count)\n                                        more-short (< i-short short-count)]\n                                    (if (not= more-long more-short)\n                                      (not changed?) ;finished with short. If we changed already, the leftover char in long can't be delivered\n                                      (if (not more-short)\n                                        true #_finished\n                                        (let [same-char (= (nth long i-long) (nth short i-short))]\n                                          (if same-char\n                                            (recur (inc i-long) (inc i-short) changed?)\n                                            (if changed?\n                                              false #_finished\n                                              (if same-count\n                                                (recur (inc i-long) (inc i-short) true) ;Simulate replacement of a char.\n                                                (recur (inc i-long)      i-short  true)) ;Simulate removal from long. The same as if we inserted to short:\n                                              ;if (not same-count), then you have two choices: insert to the short, or remove from the long. Equivalent.\n                                              ; *X*            *X* =>shorten=> **\n                                              ; *X* <=insert<= **              **\n                                              ))\n                                    )))))\n                                )))))\n           derivatives? (fn [mp] (and (map? mp) (every? (fn [[from to-s]] (and (string? from) (seq? to-s) (every? string? to-s))) mp)))\n           ders (reduce ;ders will be a map of derivatives: {from1 [to1-1 to1-2 to1-3...] from2 [to2-1 to2-2...}\n                  (fn [mp [from to]] {:pre[(derivatives? mp)(string? from)(string? to)]}\n                    (merge mp\n                      (let [existing (mp from)]\n                        (if existing\n                          {from (cons to existing)}\n                          {from (list to)}))))\n                  {}\n                    (for [from wset\n                          to wset\n                          :when (not= from to)\n                          :when (close-words? from to)]\n                        [from to]\n                        ))\n           _ (println \"derivatives\" ders)\n           contained? (fn [item coll]\n                        (some (partial = item) coll))\n           starter-word (first wset)]\n     (boolean\n     (some (fn [starter-word] ;Pick up a starter word. NOT any word, because a starter and ender may have only one neighbour => one transformation in use, but words in between have two neighbours => transformations in use.\n      ;Each word must be used exactly once per path. We keep the most recently reached words, and leftover words for each of them.\n      (println \"starter\" starter-word)\n      (loop [reached+leftovers [[starter-word (seq (disj wset starter-word))]]] ;seq of [last-reached-word (leftover-words...)]. Not a map, because the same word may be reached through different paths.\n        ;(println)\n        (println \"loop\" reached+leftovers)\n        (println)\n        (assert (every? string? (map first reached+leftovers)))\n        (assert (every? (partial every? string?) (map second reached+leftovers)))\n        (assert (every? (fn [[word leftovers]] (not (contained? word leftovers))) reached+leftovers))\n        (assert (apply = (map (comp count second) reached+leftovers))) ;all chains have same number of leftovers, because every step consumes exactly one word\n        (let [reached+leftovers-new (doall (for [[reached leftovers] reached+leftovers\n                                                 :let [_ (println \"reached (fro prev)\" reached)]\n                                                 reached-next (ders reached ())\n                                                 :let [_ (println \"reached-next candidate\" reached-next), _ (flush)]\n                                                 :when (contained? reached-next leftovers)] ;ders contains all possible derivatives, including ones that we already covered. Hence choose only derivatives not used yet.\n                                             (let [leftovers-next (remove (partial = reached-next) leftovers)]\n                                               (println \"reached-next leftovers-next:\" reached-next leftovers-next)(flush)\n                                               (list reached-next leftovers-next)\n                                      )))\n              reached+leftovers-new-seq (seq reached+leftovers-new)]\n          (println \"----\")\n          (if reached+leftovers-new-seq\n            (if (= 1 (count (second (first reached+leftovers-new-seq))))\n              (some (fn [[reached leftovers]]\n                        (contained? (first leftovers) (ders reached)))\n                      reached+leftovers-new-seq); We reached the one but last chain. (some ...) determines the overall result, because it says whether any path is reachable (in one step).\n              (recur reached+leftovers-new-seq))\n            false)) ;one path (i.e. no leftovers) is enough\n        ))\n        wset))))","user":"5b999af8e4b0c0b3ffbd4ad3"},{"code":"(fn [words]\n  (let [close-enough? (fn close-enough?  \n                        ([a b] (close-enough? a b 0))\n                        ([a b difference-so-far]\n                         (if (= (count a) (count b))\n                           (= 1 (+ (count (filter false? (map = a b))) difference-so-far))\n                           (let [common-beginning (count (take-while #(apply = %) (map vector a b)))]\n                             (if (zero? common-beginning)\n                               (let [longer (max-key count a b)\n                                     shorter (min-key count a b)]\n                                 (close-enough? shorter (rest longer) (inc difference-so-far)))\n                               (close-enough? (drop common-beginning a) (drop common-beginning b) difference-so-far))))))]\n    (boolean \n      (some (fn has-chain-starting? \n              ([start] (has-chain-starting? start (disj words start))) \n              ([start other-words]\n               (or (empty? other-words)\n                   (when-let [possible-nexts (seq (filter (fn [w] (close-enough? w start))\n                                                          other-words))]\n                     (some (fn [next] (has-chain-starting? next (disj other-words next)))\n                           possible-nexts)))))\n            words))))","problem":82,"user":"4db1b3951254ad5b4805fa6f"},{"problem":82,"code":"(fn [words]\n   (let [sbs (fn [w1 w2] \n                (let [n (count w1)]\n                  (and (= n (count w2)) \n                       (= 1 (->> (not= (get w1 i) (get w2 i))\n                                  (for [i (range n)])\n                                   (filter identity)\n                                   (count))))))\n         ins (fn [w1 w2]\n               (let [n (count w1)]\n                 (and (= (dec n) (count w2))\n                      (->> (str (subs w1 0 i) (subs w1 (inc i) ))\n                            (for [i (range n)])\n                             (some #{w2})))))\n         dif1 (fn [w1 w2] (or (sbs w1 w2) (ins w1 w2) (ins w2 w1))) \n         gc (fn [chains]\n                  (let [addfront (for [w words c chains :when (and (dif1 w (first c)) (not-any? #{w} c))]\n                                      (vec (apply conj [w] c)))\n                        addback (for [w words c chains :when (and (dif1 w (peek c)) (not-any? #{w} c))]\n                                      (vec (conj c w)))\n                        nchains (apply hash-set (distinct (concat addfront addback)))]\n                      (cond (empty? nchains) false\n                            (= (count words) (count (first nchains))) true\n                            :else  (recur nchains))))]\n     (gc (apply hash-set (for [w words] [w])))))","user":"5649615be4b0284900eef641"},{"code":"(fn [words]\n  (letfn [(chainable? [a b]\n            (cond\n             (> (count b) (count a)) (chainable? b a)\n             (> (count a) (count b))\n             (not (every? false?\n                          (for [i (range (count a))]\n                            (= b\n                               (apply str\n                                      (apply str (take i a))\n                                      (apply str (drop (inc i) a)))))))\n             :else (<= (count (remove true? (map = a b))) 1)))]\n    ((fn wc?\n       ([s]\n          (if (<= (count s) 1)\n            true\n            (not (every? false?\n                         (for [w s]\n                           (wc? w (remove #{w} s)))))))\n       ([w s]\n          (prn w s)\n          (if (zero? (count s))\n            true\n            (not (every? false?\n                         (for [w2 s]\n                           (and\n                            (chainable? w w2)\n                            (wc? w2 (remove #{w2} s)))))))))\n     words)))","problem":82,"user":"512d3304e4b040332b905b2d"},{"problem":82,"code":"(fn has-chain? [word-list]\n  (letfn [(permutations [s]\n            (lazy-seq\n             (if (seq (rest s))\n               (apply concat\n                      (for [x s]\n                        (map #(cons x %)\n                             (permutations (remove #{x} s)))))\n               (list s))))\n          (permutationsv [n]\n            (map vec (permutations (range 0 n))))\n          (pairs [n]\n            (map vector (range 0 (dec n)) (range 1 n)))\n          (edit-distance [a b]\n            (let [edfn (fn [edf a b]\n                         (if-let [[a0 & as] (seq a)]\n                           (if-let [[b0 & bs] (seq b)]\n                             (if (= a0 b0)\n                               (edf edf as bs)\n                               (inc (min (edf edf as b)\n                                         (edf edf as bs)\n                                         (edf edf a bs))))\n                             (count a))\n                           (count b)))\n                  memoized-edfn (memoize edfn)]\n              (memoized-edfn memoized-edfn a b)))\n          (one-edit-away? [a b]\n            (== 1 (edit-distance a b)))\n          (wl-not-satisfies? [wl pmv]\n            (let [n (count wl)\n                  ps (pairs n)]\n              (some (fn [p] (let [x0 (first p)\n                                  y0 (second p)\n                                  x1 (nth pmv x0)\n                                  y1 (nth pmv y0)\n                                  w1 (nth wl x1)\n                                  w2 (nth wl y1)]\n                              (not= 1 (edit-distance w1 w2))))\n                    ps)))\n          (chains [word-list]\n            (let [wl (vec word-list)\n                  n (count wl)\n                  pmvs (permutationsv n)]\n              (remove (partial wl-not-satisfies? wl) pmvs)))]\n    (not (empty? (chains word-list)))))","user":"5341b141e4b00652c8746ecf"},{"problem":82,"code":"(fn [S]\n    (let [c (fn c [a b]\n                (let [a (seq a) b (seq b)\n                      [r & t] a\n                      [s & u] b]\n                    (or \n                      (= a b)\n                      (and (= r s) (c t u))\n                      (= a u) (= b t) (= t u))))\n          ? (fn ? [s V]\n                (or (empty? V)\n                    (some true? \n                          (map (fn [x]\n                             (if (c s x) (? x (disj V x))))\n                           V))))\n           ]\n    (not-every? nil? (map #(? % S) S))))","user":"559c13c5e4b066d22e731f61"},{"code":"(fn [words]\n  (letfn [(edit-distance [w1 w2]\n            (let [s1 (seq w1), s2 (seq w2)]\n              ((fn matrix [i j]\n                 (cond\n                  (zero? i) j\n                  (zero? j) i\n                  (= (nth s1 (dec i)) (nth s2 (dec j))) (matrix (dec i) (dec j))\n                  :else (inc (min (matrix (dec i) j) ; delete\n                                  (matrix i (dec j)) ; insert\n                                  (matrix (dec i) (dec j)))))) ; substitute\n               (count s1) (count s2))))\n          (chain-adjacency-matrix [words]\n            (map (fn [w1]\n                   (map (fn [w2] (= 1 (edit-distance w1 w2))) words))\n                 words))\n          (paths [m path]\n            (if (empty? path)\n              (mapcat #(paths m [%]) (range (count m)))\n              (let [possible-extensions (apply disj (set (range (count m))) (set path))\n                    extensions (filter #(nth (nth m (last path)) %) possible-extensions)]\n                (concat #{path} (mapcat #(paths m (conj path %)) extensions)))))\n          (hamiltonian-path? [m]\n            (boolean (some #(= (count m) (count %)) (paths m []))))]\n    (hamiltonian-path? (chain-adjacency-matrix words))))","problem":82,"user":"4ea1b9e4535d7eef308072b8"},{"problem":82,"code":"(fn [s]\n  (letfn [(suitable? [x y]\n            (let [diffs (fn [x y] (<= (reduce + (map #(if (= %1 %2) 0 1) x y)) 1))\n                  drop-char (fn [n s] (str (subs s 0 n) (subs s (inc n) (count s))))\n                  drop-variants (fn [s] (map #(drop-char % s) (range (count s))))\n                  deletions (fn [l s] (some #(= s %) (drop-variants l)))\n                  cx (count x)\n                  cy (count y)]\n              (cond\n                (= cx cy) (diffs x y)\n                (= cx (inc cy)) (deletions x y)\n                (= (inc cx) cy) (deletions y x))))\n          (chain? [xs coll]\n            (if (seq coll)\n              (if (seq xs)\n                (let [ x (first xs)\n                      next (filter (partial suitable? x) coll)]\n                  (or (chain? next  (remove (partial = x) coll))\n                      (chain? (rest xs) coll)))\n                false)\n              true))]\n    (boolean\n      (chain? (seq s) (seq s)))\n    ))","user":"5be79b5be4b0f319e2d7ec5a"},{"code":"(fn chain [s]\n  (let [mutatable? (fn [a b]\n                     (and (= (count a) (count b))\n                          (= (count (filter false? (map = a b))) 1)))\n        remove-nth (fn [n s]\n                     (concat (take n s) (drop (inc n) s)))\n        reductions (fn [s]\n                     (map #(remove-nth % s) (range (count s))))\n        reducible? (fn [a b]\n                     (and (= (count a) (inc (count b)))\n                          (some #(= (seq b) %) (reductions a))))\n        transformable? (fn [a b]\n                         (or (mutatable? a b)\n                             (reducible? a b)\n                             (reducible? b a)))\n        transforms (fn [s]\n                     (into {}\n                           (map (fn [w] [w (filter #(transformable? w %) s)])\n                                s)))\n        chain-aux (fn chain-aux [m path]\n                    (let [cand (into #{} (get m (last path)))\n                          seen (set path)\n                          next (clojure.set/difference cand seen)]\n                      (if (empty? next)\n                        (count path)\n                        (apply max (map (partial chain-aux m)\n                                        (map (partial conj path) next))))))\n        m (transforms s)]\n    (= (count s)\n       (apply max (map #(chain-aux m [%]) s)))))","problem":82,"user":"4fe8aef4e4b07c9f6fd12c6c"},{"code":"(fn [i-words]\n     (let [\n           n-count (count i-words)\n           n-range (range n-count)\n           n-map (apply hash-map (interleave i-words n-range))\n           n-index (fn [i-word] (get n-map i-word))\n\n           edit-distance (fn diff ([a-word b-word] (diff 0 a-word b-word))\n                             ([distance a-word b-word]\n                              (let [\n                                    a-head (first a-word)\n                                    b-head (first b-word)\n\n                                    a-tail (rest a-word)\n                                    b-tail (rest b-word)\n\n                                    a-next (first a-tail)\n                                    b-next (first b-tail)\n                                    ]\n                                (if (and (nil? a-head) (nil? b-head))\n                                  distance\n                                  (if (= a-head b-head)\n                                    (diff distance a-tail b-tail)\n                                    (if (= a-next b-head)\n                                      (diff (inc distance) a-tail b-word)\n                                      (if (= a-head b-next)\n                                        (diff (inc distance) a-word b-tail)\n                                        (diff (inc distance) a-tail b-tail))))))))\n           edges (reduce\n                   (fn [result i-word]\n                       (reduce\n                         #(conj %1 (vector i-word %2))\n                         result\n                         (filter #(= 1 (edit-distance i-word %)) i-words)))\n                   #{}\n                   i-words)\n           grouped-edges (group-by #(n-index (first %)) edges)\n\n           n-dest (fn [i-word]\n                      (map last (get grouped-edges (n-index i-word))))\n\n           build-chains (fn chain\n                            ([i-word] (chain (dec n-count) (vector (vector i-word))))\n                            ([i result]\n                             (if (zero? i)\n                               result\n                               (chain\n                                 (dec i)\n                                 (reduce\n                                   concat\n                                   []\n                                   (map\n                                     (fn [i-chain]\n                                         (map\n                                           #(conj (apply vector i-chain) %)\n                                           (filter #(not (contains? (apply hash-set i-chain) %)) (n-dest (last i-chain)))))\n                                     result))))))\n           ]\n       (reduce\n         (fn [result i-word]\n             (if (false? result)\n               (boolean (some #(= (count %) n-count) (build-chains i-word)))\n               result))\n         false\n         i-words)))","problem":82,"user":"4dad7adac9a9d6ed0599dc57"},{"code":"(fn chain [wordlist]\n  (let \n      [levdist (fn levdist [left right]\n                 (cond\n                  (empty? left) (count right)\n                  (empty? right) (count left)\n                  :else (let [cost (cond \n                                    (= (last left) (last right)) 0\n                                    :else 1)]\n                          (min (inc (levdist (butlast left) right))\n                               (inc (levdist left (butlast right)))\n                               (+ cost (levdist (butlast left) (butlast right)))))))\n       adjacent-words (filter #(= (levdist (first %) (second %)) 1) (for [x wordlist y wordlist] [x y]))\n       check-chain (fn check-chain [startword wordchain adjacent]\n                     (if (= (set (conj wordchain startword)) (set wordlist))\n                       true\n                       (let [possibilities (filter #(= startword (first %)) adjacent)]\n                         (if (empty? possibilities)\n                           false\n                           (some true? (for [possibility possibilities]\n                                         (check-chain (second possibility) \n                                                      (conj wordchain startword) \n                                                      (filter #(not (= startword (first %))) adjacent))))))))]\n    (or (some true? (for [word wordlist] (check-chain word [] adjacent-words))) false)))","problem":82,"user":"515737f0e4b0b0b4b87062d0"},{"code":"(fn word-chain? [set-of-words]\n  (letfn [(remove-first [p l acc]\n            (if (empty? l)\n              l\n              (if (p (first l))\n                (into (rest l) acc)\n                (recur p (rest l) (cons (first l) acc)))))\n          (word-difference [w1 w2]\n            (reduce #(remove-first (fn [e] (= e %2)) %1 '()) w1 w2))\n          (equal-after-deletion? [w1 w2]\n            (and (= (count w1) (inc (count w2)))\n                 (= (count (word-difference w1 w2)) 1)))\n          (equal-after-insertion? [w1 w2]\n            (equal-after-deletion? w2 w1))\n          (equal-after-substition? [w1 w2]\n            (and (= (count w1) (count w2))\n                 (= (count (filter false? (map #(apply = %) (map list w1 w2)))) 1)))\n          (can-follow-after-transform? [first-word word]\n            (or (equal-after-deletion? first-word word)\n                (equal-after-insertion? first-word word)\n                (equal-after-substition? word first-word)))\n          (can-form-word-chain? [first-word other-words]\n            (let [valid-followers (filter (partial can-follow-after-transform? first-word) other-words)]\n              (if (empty? other-words)\n                true\n                (if (empty? valid-followers)\n                  false\n                  (some true? (map (fn [first-word]\n                                     (can-form-word-chain? first-word\n                                                           (remove-first #(= first-word %) other-words '())))\n                                   valid-followers))))))]\n    (true? (some true? (map #(can-form-word-chain? % (disj set-of-words %)) set-of-words)))))","problem":82,"user":"4ff355a1e4b0678c553fc34d"},{"problem":82,"code":"(fn [words]\n\t(letfn [(one-character-diff? [word-a word-b]\n\t\t\t\t(->> (map #(concat (take %1 word-a) (rest (drop %1 word-a))) \n\t\t\t\t\t       (range (count word-a))) \n\t\t\t\t\t (some #(= (seq word-b) %1))\n\t\t\t\t\t (boolean)))\n\t\t\t(next? [word-a word-b]\n\t\t\t  (case (- (count word-a) (count word-b))\n\t\t\t  \t1  (one-character-diff? word-a word-b)\n\t\t\t  \t-1 (one-character-diff? word-b word-a)\n\t\t\t  \t0  (->> (map #(= %1 %2) word-a word-b) (filter false?) count (= 1))\n\t\t\t  \tfalse))\n\t\t\t(chain? [word chained-words]\n\t\t\t\t(let [nexts (filter #(and (next? word %) (nil? (chained-words %))) words)]\n\t\t\t\t  (if (seq nexts)\n\t\t\t\t  \t(->> (drop-while (complement boolean)\n\t\t\t\t  \t\t             (map #(chain? % (conj chained-words %)) nexts))\n\t\t\t\t  \t     first true?)\n\t\t\t\t  \t(= (count chained-words) (count words)))))]\n\n\t\t\t(->> (drop-while (complement boolean)\n\t\t\t\t             (map #(chain? % #{%}) words))\n\t\t\t\t first true?)))","user":"55b8c339e4b01b9910ae29b9"},{"problem":82,"code":"(fn [s] (let [\ncon? (fn [x] (fn [y] (loop [[xf & xr :as x] x, [yf & yr :as y] y, n 0]\n  (cond (or (empty? x) (empty? y)) (= 1 (+ n (count x) (count y)))\n    (= xf yf) (recur xr yr n)\n    (> (count x) (count y)) (recur xr y (inc n))\n    (< (count x) (count y)) (recur x yr (inc n))\n    :else (recur xr yr (inc n))\n  ))))\nvc (reduce #(conj % (filter (con? %2) s)) [] (seq s))\n]\n(> 3 (count (filter #(= 1 %) (map count vc))))\n))","user":"4fd11a93e4b04c3a95aa040a"},{"problem":82,"code":"(letfn [(ld [s1 s2]\n            (let [s1c (count s1)\n                  s2c (count s2)]\n              (-> (for [j (range 1 (inc s2c))\n                        i (range 1 (inc s1c))]\n                    [i j])\n                  (->>\n                   (reduce\n                    (fn [d [i j]]\n                      (let [sub-cost (if (= (nth s1 (dec i))\n                                            (nth s2 (dec j)))\n                                       0 1)]\n                        (assoc-in d\n                                  [i j]\n                                  (min (inc (get-in d [(dec i) j]))\n                                       (inc (get-in d [i (dec j)]))\n                                       (+ sub-cost\n                                          (get-in d [(dec i) (dec j)]))))))\n                    (into []\n                          (for [i (range (inc s1c))]\n                            (into [i]\n                                  (if (= 0 i)\n                                    (range (inc i) (inc s2c))\n                                    (repeat s2c 0)))))))\n                  (get-in [s1c s2c]))))\n          (permutations [s]\n            (lazy-seq\n             (if (seq (rest s))\n               (apply concat (for [x s]\n                               (map #(cons x %) (permutations (remove #{x} s)))))\n               [s])))]\n    (fn [words]\n      (let [ld-memo (memoize ld)]\n        (or (some\n             (fn [words']\n               (every?\n                (fn [[s1 s2]]\n                  (= 1 (ld-memo s1 s2)))\n                (partition 2 1 words')))\n             (permutations words))\n            false))))","user":"54246fcce4b01498b1a71aed"},{"code":"(fn [words]\n    (let [chainable?\n          (fn [word1 word2]\n            (let [longword (if (>= (count word1) (count word2)) word1 word2)\n                 shortword (if (>= (count word1) (count word2)) word2 word1)\n                 charsinlw (count longword)\n                 charsinsw (count shortword)\n                 diff (fn [c1 c2 d]\n                        (cond\n                          (nil? c1) (+ (count c2) d)\n                          (nil? c2) (+ (count c1) d)\n                          (not= (first c1) (first c2)) (recur (next c1) c2 (inc d))\n                          :else (recur (next c1) (next c2) d)))]\n            (cond\n              (= charsinlw charsinsw)\n                (= 1 (apply + (map #(if (= %1 %2) 0 1) (.toCharArray word1) (.toCharArray word2))))\n              (= 1 (- charsinlw charsinsw))\n                (= 1 (diff (.toCharArray longword) (.toCharArray shortword) 0))\n              :else false)))]\n    (letfn [(chain?\n            ([words] (chain? words [] (seq words)))\n            ([words chain [w & rnwords :as next-words]]\n      (if-not (seq words)\n        chain\n        (when (seq next-words)\n          (let [[nw & rninchain :as next-in-chain] (filter #(chainable? w %) words)]\n            (or (chain? (disj words w) (cons w chain) next-in-chain)\n                (chain? words chain rnwords)))))))]\n    (if (chain? words) true false))))","problem":82,"user":"50e4f4e9e4b049a987753896"},{"problem":82,"code":"(fn [nodes]\n    (let [nodes    (set (map seq nodes))\n          one-diff (fn [a b]\n                     (cond\n                       (empty? a) (= (count b) 1)\n                       (empty? b) (= (count a) 1)\n                       (= (first a) (first b)) (recur (rest a) (rest b))\n                       :else (or (= (rest a) (rest b)) (= a (rest b)) (= b (rest a)))))\n          chain (fn [start]\n                  ((fn f [current visited]\n                     (let [visited (conj visited current)]\n                       (if (= visited nodes)\n                         true\n                         (let [neighbors (filter #(and (not (contains? visited %)) (one-diff % current)) nodes)]\n                           (if (empty? neighbors)\n                             false\n                             (some #(f % visited) neighbors))))))\n                    start\n                    #{}))]\n      (true? (some chain nodes))))","user":"5a2df4a0e4b09cafd31c7f74"},{"code":"(fn word-chain-submit [set-of-words]\n  (letfn [(without-1-letter [s]\n            (let [end (count s)]\n              (loop [i 0 acc []]\n                (if (= i end)\n                  acc\n                  (recur\n                    (inc i)\n                    (conj acc (str (subs s 0 i) (subs s (+ 1 i) end))))))))\n          (pair-diff-by-one [pair]\n            (let [a (first pair)\n                  b (second pair)\n                  ca (count a)\n                  cb (count b)]\n              (cond\n                (= ca cb)\n                     (= 1 (reduce\n                            (fn [n [x y]] (+ n (if (= x y) 0 1)))\n                            0\n                            (map vector a b)))\n                (= 1 (- cb ca))\n                     (some (partial = a) (without-1-letter b))\n                (> ca cb)\n                     (pair-diff-by-one [b a]))))\n          (next-map [c]\n            (reduce\n              (fn [m e]\n                (assoc m e\n                       (set (map second\n                                 (filter pair-diff-by-one\n                                         (map #(vector e %) c))))))\n              {} c))\n          (find-chains\n            ([s] (find-chains s s (next-map s)))\n            ([n s m]\n             (if (empty? s)\n               []\n               (let [cs (count s)]\n                 (filter #(= cs (count %))\n                   (reduce\n                     (fn [acc e]\n                       (concat\n                         acc\n                         (let [subchains (find-chains\n                                           (keep #((m e) %) s)\n                                           (remove #(= e %) s)\n                                           m)]\n                           (if (empty? subchains)\n                             [[e]]\n                             (map #(cons e %) subchains)))))\n                     [] n))))))]\n\n    (boolean (seq (find-chains set-of-words)))))","problem":82,"user":"4e89ddf9535d3e98b8023284"},{"problem":82,"code":"(fn word-chain? [ws]\n  (letfn [(permutations [ws]\n            (when-let [ws (seq ws)]\n              (let [cnt (count ws)]\n                (if (== cnt 1)\n                  (list ws)\n                  (mapcat\n                    (fn [w] (map #(lazy-seq (cons w %)) (permutations (remove #{w} ws))))\n                    ws)))))\n          (count-diff [[w1 w2]]\n            (loop [[c1 & cs1] w1 [c2 & cs2] w2 res 0]\n              (cond\n                (not (or c1 c2)) res\n                (= c1 c2) (recur cs1 cs2 res)\n                ;suvstitution\n                (= (first cs1) (first cs2)) (recur (rest cs1) (rest cs2) (inc res))\n                ; insertion\n                (= c1 (first cs2)) (recur cs1 (rest cs2) (inc res))\n                ; deletion\n                (= c2 (first cs1)) (recur (rest cs1) cs2 (inc res))\n                :else (recur cs1 cs2 (inc res)))))\n          (chain? [ws]\n            (every? #(== % 1) (map count-diff (partition 2 1 ws))))]\n    (not (nil? (some chain? (permutations ws))))))","user":"5f300f28e4b033932238a682"},{"code":"(fn [s]\n  (let [suf #(loop [[x & r :as a] (seq %), [y & s :as b] (seq %2)]\n               (if (= x y) (recur r s) [a b]))\n        link? (fn [[x & r :as a] [y & s :as b]] (or (= a s) (= b r) (= s r)))\n        chains (fn f [s] (if (= 1 (count s)) [s]\n                         (for [h s, c (f (disj s h)) :when (apply link? (suf h (first c)))] (cons h c))))]\n    (not (empty? (chains s)))))","problem":82,"user":"522b922ee4b0d34ee08e71c3"},{"problem":82,"code":"(fn chainable? [words]\n  (letfn [(sub-able? [a b]\n            (and\n              (= (count a) (count b))\n              (->> (interleave a b)\n                (partition 2)\n                (map #(if (apply = %) 0 1))\n                (reduce +)\n                (= 1))))\n          (del-able? [a b]\n            (and\n              (= 1 (Math/abs (- (count a) (count b))))\n              (let [[longer shorter] (if (> (count a) (count b)) [a b] [b a])\n                    diff-index (loop [i 0]\n                                 (if (= (get a i) (get b i))\n                                   (recur (inc i))\n                                   i))]\n                (= (drop diff-index shorter) (drop (inc diff-index) longer)))))\n          (add-edge [graph a b]\n            (let [graph (update-in graph [a] (fnil #(conj % b) []))\n                  graph (update-in graph [b] (fnil #(conj % a) []))]\n              graph))\n          (traverse [graph curr visited]\n            (let [neighbors (filter #(not (visited %)) (graph curr))]\n              (cond\n                (= (count visited) (count words)) true\n                (= 0 (count neighbors)) false\n                :else (not (nil? (some identity (for [neighbor neighbors]\n                                                  (traverse graph neighbor (conj visited neighbor)))))))))]\n    (let [graph (loop [words words\n                       edges {}]\n                  (if (<= (count words) 1)\n                    edges\n                    (let [a (first words)\n                          edges (reduce\n                                  (fn [edges b]\n                                    (if (or (sub-able? a b) (del-able? a b))\n                                      (add-edge edges a b)\n                                      edges))\n                                  edges\n                                  (rest words))]\n                      (recur (rest words)\n                             edges))))\n          starts (keys graph)]\n      (not (nil? (some identity (for [start starts]\n                                  (traverse graph start #{start}))))))))","user":"58b2c435e4b0ebc645576d11"},{"code":"(fn chain [words & [prev]]\n  (let [near\n        (fn near [a b]\n          (condp = (compare (count a) (count b))\n              1 (some #(let [[x [y & z]] (split-at % a)]\n                         (= (apply str (concat x z)) b))\n                      (range (count a)))\n              0 (some #(let [[x [y & z]] (split-at % a)]\n                         (= (apply str (concat x [(nth b %)] z)) b))\n                      (range (count a)))\n              -1 (near b a)))]\n    (if (empty? words)\n      true\n      (let [usable (if-not prev\n                     words\n                     (filter (partial near prev) words))]\n        (loop [[w & rest] (seq usable)]\n          (if (nil? w)\n            false\n            (if (chain (disj words w) w)\n              true\n              (recur rest))))))))","problem":82,"user":"4e5fe31a535d8ccf87e9fe50"},{"problem":82,"code":"(fn wch[words]\n    (let [\n          words (reverse (sort-by count (vec words)))\n         cc? (fn [a b]\n               (let [a (seq a) b (seq b)\n                     cnts (remove even?\n                                (map count (vals (group-by identity (apply conj a b)))))]\n                  (condp = (- (count a) (count b))\n                  0 (= '(1 1)  cnts)\n                  1 (= 1 (count cnts ))\n                  -1 (= 1 (count cnts))\n                  false\n                  )))\n           tr (fn [init ]\n                  (loop[i init\n                        s [i]]\n                    (do\n                      ;(println (clojure.string/join \",\" [i s]))\n                      (if (or (nil? i) (empty? (remove (set s) words)))\n                        (filter (comp not nil?) s)\n                        (recur (first (filter (partial cc? i) (remove (set s) words )))\n                               (conj s (first (filter (partial cc? i) (remove (set s) words)))))\n                       ))))\n           all-paths (map tr words)\n          ]\n      (doall (map println all-paths))\n      (= (apply max (map count all-paths)) (count words))\n  ))","user":"52f426fce4b05e3f0be25f1e"},{"problem":82,"code":"#(letfn [(pair? [a b]\n             (let [ra (rest a) rb (rest b) ea? (empty? a) eb? (empty? b)]\n               (if (or (not= (first a) (first b))  (and ea? eb?))\n                 (if (or (and ea? eb?) (= ra rb) (= rb (seq a)) (= ra (seq b))) true false)\n                 (recur ra rb))))\n          \n           (chain? [w0 coll]\n             (if (empty? coll)\n               true\n               (some (fn [w]\n                       (and (pair? w0 w)\n                            (chain? w (disj coll w))))\n                     coll)))] \n\n\n         (boolean (some (fn [w] (chain? w (disj % w))) %)))","user":"576e607ae4b0979f89651579"},{"problem":82,"code":"(fn is-word-chain? [words]\n  (let [check (fn [w1 w2]\n                (loop [s1 (seq w1)\n                       s2 (seq w2)\n                       diff-cnt 0]\n                  (if (and (nil? s1) (nil? s2))\n                    (if (< 1 diff-cnt) false true)\n                    (if (= (first s1) (first s2))\n                      (recur (next s1) (next s2) diff-cnt)\n                      (cond\n                        (> (count s1) (count s2)) (recur (next s1) s2 (inc diff-cnt))\n                        (< (count s1) (count s2)) (recur s1 (next s2) (inc diff-cnt))\n                        :else (recur (next s1) (next s2) (inc diff-cnt)))))))\n        word-chain? (fn word-chain? [w candidate-words]\n                      (if (not (empty? candidate-words))\n                        (let [next-words (filter (partial check w) candidate-words)]\n                          (if (empty? next-words)\n                            false\n                            (some #(word-chain? % (disj candidate-words %)) next-words\n                                  )))\n                        true))\n        ]\n    (if (some #(word-chain? % (disj words %)) words)\n      true\n      false\n      )))","user":"53527551e4b084c2834f4af0"},{"problem":82,"code":"(letfn [(levenstein [mlev ss ts]\n          (cond (empty? ss) (count ts)\n                (empty? ts) (count ss)\n                :else (let [cost (if (= (first ss) (first ts)) 0 1)]\n                        (min (inc (mlev mlev (rest ss) ts))\n                             (inc (mlev mlev ss (rest ts)))\n                             (+ cost (mlev mlev (rest ss) (rest ts)))))))\n        (lev [s t]\n          (levenstein (memoize levenstein) (seq s) (seq t)))\n        (other [node edge]\n          (first (disj edge node)))\n        (traverse [[node & _ :as path] edges f]\n          (let [targets (filter #(% node) edges)]\n            (if (seq targets)\n              (some #(traverse (cons (other node %) path) (disj edges %) f)\n                    targets)\n              (f path))))]\n  (fn [nodes]\n    (let [size  (count nodes)\n          edges (set (for [a nodes b nodes :when (= 1 (lev a b))] #{a b}))]\n      (boolean\n        (some identity\n              (map #(traverse [%] edges (fn [path] (= size (count path)))) nodes))))))","user":"59eb63e3e4b0249b7282077c"},{"problem":82,"code":"(fn [w]\n  (letfn [(n? [a b]\n            (let [[[cx x] [cy y]] (sort (map (juxt count str) [a b]))]\n              (case (- cy cx)\n                0 (= 1 (reduce + (map #(if (= % %2) 0 1) x y)))\n                1 (let [n (count (take-while #(apply = %) (map list x y)))]\n                    (= (subs x n) (subs y (inc n))))\n                false)))\n          (s? [ws r]\n             (let [ws (disj ws r)\n                   n (filter #(n? % r) ws)]\n               (or (empty? ws) (some #(s? ws %) n))))]\n    (boolean (some #(s? w %) w))))","user":"52b02329e4b0c58976d9acc5"},{"code":"(fn  [words]\n    (letfn [(ms [s] (map\n                     (fn [i] (concat (take i s) (drop (inc i) s)))\n                     (range (count s))))\n            (one-away? [s1 s2]\n              (cond (< (count s1) (count s2))\n                    (some (fn [s] (= s (seq s1))) (ms s2))\n                    (> (count s1) (count s2))\n                    (some (fn [s] (= s (seq s2))) (ms s1))\n                    :else\n                    (some identity (map = (ms s1) (ms s2)))))\n            (chains [words]\n              (if (empty? (rest words))\n                [[(first words)]]\n                (mapcat (fn [word]\n                          (map #(cons word %)\n                               (filter (fn [chain] (one-away? (first chain) word))\n                                       (chains (disj words word)))))\n                        words)))]\n      (not (empty? (chains words)))))","problem":82,"user":"4f463dfde4b0d56e7bb92b99"},{"problem":82,"code":"(fn \n  [s]\n  (= (count s) ((fn DFS\n  [root o c]\n  (let [adj (filter #((fn \n  [w1 w2]\n (cond (= (count w1) (count w2))\n         (<= ((frequencies (map = w1 w2)) false) 1)\n       (> (count w1) (count w2))\n       (let [w (map split-at (range (count w1)) (repeat (count w1) w1) )]\n         (.contains (map concat (map first w) (map (comp rest second) w)) (vec w2))\n         )\n       :else\n       (if (vector? w1)\n         true\n         (let [w (map split-at (range (count w2)) (repeat (count w2) w2) )]\n           (.contains (map concat (map first w) (map (comp rest second) w)) (vec w1))\n           )))\n  ) root %) o)]\n    (loop [l adj cu c]\n      (if (empty? l)\n        cu\n        (let [r (DFS (first l) (filter #(not= (first l) %) o) (inc c))]\n          (if (> r cu)\n            (recur (rest l) r)\n            (recur (rest l) cu))))))\n     \n) [] (vec s) 0)) \n  )","user":"5772ddb0e4b0979f896515d4"},{"problem":82,"code":"(fn f [words]\n  (letfn [(f2 [word remaining]\n           (if (empty? remaining)\n             true\n             (map #(if (f3 word %)\n                     (f2 % (disj remaining %))\n                     false)\n                  remaining)))\n          (f3 [a b]\n              (let [[a b] (sort-by count [a b])\n                value (- (count b) (count a))]\n                (condp = value\n                  0 (> 2 (apply + (map #(if (= % %2) 0 1) a b)))\n                  1 (some true? (map #(= (seq a) %) (map #(concat (take % b) (drop (inc %) b)) (range (count b)))))\n                  false)))]\n    (not (every? false? (flatten (map #(f2 % (disj words %)) words))))))","user":"533018b2e4b019098a6f8b56"},{"problem":82,"code":"(fn [words]\n  (letfn [\n    (check-different-size [big-word small-word]\n      (if (> (count small-word) (count big-word))\n        (recur small-word big-word)\n        ((complement nil?)\n           (some\n             #(= % (vec small-word))\n             (map-indexed\n               (fn [i l] (keep-indexed\n                  (fn [index letter] (if (not= index i) letter))\n                  big-word))\n               big-word)))\n        \n        ))\n\n    (check-same-size [word1 word2]\n      (<= (count (filter false? (map = word1 word2))) 1))\n\n    (one-latter-change? [word1 word2]\n      (cond\n        (= (count word1) (count word2)) (check-same-size word1 word2)\n        (= 1 (Math/abs (- (count word1) (count word2)))) (check-different-size word1 word2)\n        :else false))\n\n    (combinable-vertices? [[v1 v2] [v3 v4]]\n      (cond\n        (= v1 v3) true\n        (= v1 v4) true\n        (= v2 v3) true\n        (= v2 v4) true\n        :else false))\n\n    (combine-vertices [[v1 v2] [v3 v4]]\n      (cond\n        (= v1 v3) [v2 v4]\n        (= v1 v4) [v2 v3]\n        (= v2 v3) [v1 v4]\n        (= v2 v4) [v1 v3]\n        :else (throw (ex-info \"Tried to combine no combinable vertices\" {}))))\n\n    (push-used-to-last [w-vertex [f-vertex & vertices]]\n      (let [common-node (vec (clojure.set/intersection (set w-vertex) (set f-vertex)))\n            combinable-selector #(combinable-vertices? % common-node)]\n        (concat\n          (remove\n            combinable-selector\n            vertices)\n          (filter combinable-selector vertices))) )\n\n    (walked-through-all-nodes? [visited vertices]\n      (empty? (clojure.set/difference (set (flatten vertices)) visited)) )\n\n    (walk-graph [original-vertices]\n      (loop [working-vertex (first original-vertices)\n             vertices (rest original-vertices)\n             not-combinable []\n             visited-nodes (set working-vertex)]\n        (cond\n          (walked-through-all-nodes? visited-nodes original-vertices) true\n          (empty? vertices) false\n          (combinable-vertices? working-vertex (first vertices))\n            (recur\n              (combine-vertices working-vertex (first vertices))\n              (concat not-combinable (push-used-to-last working-vertex vertices))\n              []\n              (apply conj visited-nodes (combine-vertices working-vertex (first vertices))))\n          :else (recur\n                  working-vertex\n                  (rest vertices)\n                  (conj not-combinable (first vertices))\n                  visited-nodes))) )\n\n    (contain-in-any-vertice? [word vertices]\n      (some true? (map #(or (= word (first %)) (= word (second %))) vertices)) )\n\n    (word-alone? [words vertices]\n      (some false? (map #(contain-in-any-vertice? % vertices) words)))\n\n    (pairs-of [pred coll]\n      (map vec (into [] (set\n        (for [w1 coll w2 coll\n              :when (not= w1 w2)\n              :when (pred w1 w2)]\n          #{w1 w2})))))\n\n    (compare-option-with [coll]\n      (fn [vertex]\n        (count (filter true? (map #(combinable-vertices? vertex %) coll)))))\n\n    (sort-by-options [vertices]\n      (sort-by (compare-option-with vertices) vertices))\n\n    (word-chain? [words]\n      (let [vertices (pairs-of one-latter-change? words)]\n        (if (word-alone? words vertices)\n          false\n          (walk-graph (sort-by-options vertices)))))]\n\n  (word-chain? words)))","user":"5b60e88be4b0c6492753e70b"},{"problem":82,"code":"(fn [words]\n  (letfn [(distance [a b]               ; the Levenshtein distance\n            (letfn [(lev [i j]\n                      (if (= (min i j) 0)\n                        (max i j)\n                        (min (inc (lev (dec i) j))\n                             (inc (lev i (dec j)))\n                             (+ (lev (dec i) (dec j))\n                                (if (= (subs a (dec i) i)\n                                       (subs b (dec j) j))\n                                  0 1)))))]\n              (lev (count a) (count b))))\n          (chainable? [start more]\n            (if (empty? more)\n              true\n              (let [neighbors (filter #(= (distance % start) 1) more)]\n                (if (empty? neighbors)\n                  false\n                  (some #(chainable? % (clojure.set/difference\n                                        more (hash-set %)))\n                        neighbors)\n                  ))))]\n    (true? (some #(chainable? % (clojure.set/difference words (hash-set %))) words))))","user":"547584d9e4b0c51c1f4d729b"},{"code":"(fn [s] \n   (letfn [(c [a b] \n     (let [la (count a) lb (count b)] \n       (cond\n        (nil? a) true\n        (= la lb) (= 1 (count (filter (comp not identity) (map = a b))))\n        (= la (inc lb)) (some (partial c b) (map #(concat (take % a) (drop (inc %) a)) (range 0 la)))\n        (= lb (inc la)) (c b a)\n        :else false\n       )))\n           (chain? [s1 ss] (if (empty? ss) true (true? (some #(chain? % (remove (partial = %) ss)) (filter (partial c s1) ss)))))]\n     (chain? nil s)))","problem":82,"user":"523b1988e4b02f719975bdbc"},{"code":"#(if (or (< (count %) 5) (% \"to\")) false true)","problem":82,"user":"4f9fe2b9e4b0dcca54ed6d40"},{"problem":82,"code":"(fn f\n  [words]\n  (letfn [(abs\n           [n]\n           (max n (- n)))\n          (perms\n           [coll]\n           (loop [result #{}]\n             (if (-> (count result) (= (reduce * (range 1 (inc (count coll))))))\n               result\n               (recur (conj result (shuffle (vec coll)))))))\n          (chainable?\n           [x y]\n           ;(println \"chainable?\" x y)\n           (or\n            (and (= (count x) (count y))\n                 (loop [i 0]\n                   (if (= i (count x))\n                     false\n                     (if (= (concat (subs x 0 i) (subs x (inc i) (count x))) (concat (subs y 0 i) (subs y (inc i) (count y))))\n                       true\n                       (recur (inc i))))))\n            (and (= (abs (- (count x) (count y))) 1)\n                 (loop [i 0]\n                   ;(println \"checking\" x y)\n                   (if (= i (min (count x) (count y)))\n                     false\n                     (if (or\n                          (= (clojure.string/join (concat (subs x 0 i) (subs x (inc i) (count x)))) y)\n                          (= (clojure.string/join (concat (subs y 0 i) (subs y (inc i) (count y)))) x))\n                       true\n                       (recur (inc i))))))\n            (or\n             (= (subs x 1) y)\n             (= (subs y 1) x)\n             (= (subs x 0 (dec (count x))) y)\n             (= (subs y 0 (dec (count y))) x))\n          ))\n          (coll-chainable?\n           [coll]\n           ;(println \"coll-chainable?\" coll)\n           (loop [a (first coll)\n                  b (second coll)\n                  remaining (drop 2 coll)]\n             (if (not (chainable? a b))\n               false\n               (if (empty? remaining)\n                 true\n                 (recur b (first remaining) (rest remaining))))))]\n    (let [permutations (vec (perms words))]\n      (loop [i 0]\n        (if (= i (count permutations))\n          (do\n            ;(println \"no chainable permutation found\")\n            false)\n          (do\n            ;(println \"checking permutation\" (nth permutations i))\n            (if (coll-chainable? (nth permutations i))\n              (do\n                ;(println \"coll-chainable? returned true for permutation\" (nth permutations i))\n                true)\n              (recur (inc i)))))))))","user":"54021f13e4b0df28a13c62cc"},{"code":"(fn find-chain [words]\n  (let [lev (fn lev [s1 s2]\n              (cond (empty? s1) (count s2)\n                    (empty? s2) (count s1)\n                    (= (first s1) (first s2)) (lev (rest s1) (rest s2))\n                    :else (inc (min (lev (rest s1) s2)\n                                    (lev s1 (rest s2))\n                                    (lev (rest s1) (rest s2))))))\n        neighbors (fn [words word] (filter #(= (lev word %) 1) words))\n        chain (fn chain [graph visited root]\n                (let [visited (conj visited root)\n                      neigh (remove visited (graph root))]\n                  (if (= visited words) \n                    true\n                    (some (partial chain graph visited) neigh))))\n        graph (into {} (for [w words] [w (neighbors words w)]))]\n    (true? (some (partial chain graph #{}) words))))","problem":82,"user":"5032b066e4b00c0952a257ea"},{"problem":82,"code":"(fn [in]\n        (let [words (into [] in)\n\n              dist\n              (fn[s t]\n                (let [lev\n                      (memoize\n                       (fn aux[rec s t]\n                         (cond\n                          (empty? s)\n                          (count t)\n\n                          (empty? t)\n                          (count s)\n\n                          :else\n                          (let [s' (butlast s)\n                                t' (butlast t)]\n\n                            (min (inc (rec rec s' t))\n                                 (inc (rec rec s t'))\n                                 (+ (rec rec s' t')\n                                    (if (= (last s)\n                                           (last t))\n                                      0 1)))))))\n\n                      ;; rebind\n                      lev (partial lev lev)]\n                  (lev s t)))\n\n              adj\n              (fn[s]\n                (loop [[fst & more] s]\n                  (cond\n                   \n                   (nil? more)\n                   true\n                   \n                   (= 1 (dist fst (first more)))\n                   (recur more)\n\n                   :else\n                   false)))\n\n              permutations \n              (fn rec [a-set]\n                (cond (empty? a-set) '(())\n                      (empty? (rest a-set)) (list (apply list a-set))\n                      :else (for [x a-set y (rec (remove #{x} a-set))]\n                              (cons x y))))]\n\n          (not (empty? (filter adj (permutations words))))))","user":"57e6f90de4b0bfb2137f5af6"},{"code":"(fn has-chain [words]\n  (letfn [(substring? [s1 s2] (let [[ss ls] (sort-by count (vector s1 s2))] (some (partial = (vec ss)) (map #(concat (take % ls) (drop (+ 1 %) ls)) (range (count ls))))))\n          (is-diff-one? [x y] (or (diff-one x y) (substring? x y)))\n          (zip [x y] (map #(list %1 %2) x y))\n          (ta [s x] (map #(cons x %) (walk (clojure.set/difference s (hash-set x)))))\n          (walk [s] (if (= 1 (count s)) (list (vec s)) (mapcat #(ta s %) s)))\n          (diff-one [s1 s2] (if (= (count s1) (count s2)) (= 1 (count (remove #(= (first %) (second %)) (map #(vector %1 %2) s1 s2)))) false))\n          (chain [word-list] (zip (butlast word-list) (rest word-list)))\n          (word-chain? [words] (boolean (every? #(apply is-diff-one? %) (chain words))))]\n    (boolean (some word-chain? (walk words)))))","problem":82,"user":"4f251302e4b0d66497709ff0"},{"code":"#(let [\r\n  nv    (count %)\r\n  words (map seq %)\r\n  edge? (fn edge? [w1 w2]\r\n          (let [[h1 & t1] w1 [h2 & t2] w2]\r\n            (if (= h1 h2) (edge? t1 t2)\r\n              (or (= t1 t2)     ; substitution\r\n                  (= t1 w2)     ; deletion\r\n                  (= w1 t2))))) ; insertion\r\n  graph (apply (partial merge-with concat) (for [a words b words\r\n          :when (and (not= a b) (edge? a b))] {a [b]}))\r\n  chain (fn chain [visited w] ; depth-first search for the chain\r\n          (or (= nv (inc (count visited)))\r\n              (some (partial chain (conj visited w))\r\n                (filter (comp not visited) (graph w)))))]\r\n  (not (not-any? (partial chain #{}) (keys graph))))","problem":82,"user":"50336c6be4b0c6c1199c710f"},{"problem":82,"code":"; mine timed out, but need to get past this\n(fn find-chain [words]\n  (let [lev (fn lev [s1 s2]\n              (cond (empty? s1) (count s2)\n                    (empty? s2) (count s1)\n                    (= (first s1) (first s2)) (lev (rest s1) (rest s2))\n                    :else (inc (min (lev (rest s1) s2)\n                                    (lev s1 (rest s2))\n                                    (lev (rest s1) (rest s2))))))\n        neighbors (fn [words word] (filter #(= (lev word %) 1) words))\n        chain (fn chain [graph visited root]\n                (let [visited (conj visited root)\n                      neigh (remove visited (graph root))]\n                  (if (= visited words) \n                    true\n                    (some (partial chain graph visited) neigh))))\n        graph (into {} (for [w words] [w (neighbors words w)]))]\n    (true? (some (partial chain graph #{}) words))))","user":"5eff6c0ee4b0cf489e8d7f11"},{"code":"(fn [a]\n  (letfn [(lev [s t]\n            (let [x (vec s)\n                  y (vec t)\n                  cx (count x)\n                  cy (count y)\n                  d (fn [matrix [i j :as indices]]\n                      (let [del (get-in matrix [(dec i) j])\n                            ins (get-in matrix [i (dec j)])\n                            sub (get-in matrix [(dec i) (dec j)])\n                            res (if (= (x (dec i)) (y (dec j)))\n                                  sub\n                                  (min (inc del) (inc ins) (inc sub)))]\n                        (update-in matrix indices (constantly res))))\n                  z (->> (for [i (range (inc cx)) j (range (inc cy))]\n                           (cond \n                            (zero? j) [i]\n                            (zero? i) [j]\n                            :else []))\n                         (partition (inc cy))\n                         (map #(vec (apply concat %)))\n                         vec)]\n              (get-in (reduce d z (for [i (range 1 (inc cx)) j (range 1 (inc cy))] [i j]))\n                      [cx cy])))]\n    (<= (count (->> (for [b a d (disj a b)] (when (= 1 (lev b d)) true))\n                    (partition (dec (count a)))\n                    (map #(remove nil? %))\n                    (filter #(< (count %) 2))))\n        2)))","problem":82,"user":"4e823ed7535db62dc21a62c7"},{"problem":82,"code":"(fn word-chain? [xs] ;; set\n  (letfn [(skip\n            ([n xs]\n             (skip n 1 xs))\n            ([n len xs]\n             (concat (take n xs) (drop (+ n len) xs))))\n          (word-link? [s1 s2]\n            (cond\n              (= s1 s2) false\n              (> (count s1) (count s2)) (word-link? s2 s1)\n              :else (let [prefix-count (->> (map vector s1 s2)\n                                            (take-while (partial apply =))\n                                            (count))\n                          s1- (skip prefix-count s1)\n                          s2- (skip prefix-count s2)]\n                      (or (= s1- s2-) ;; substitution\n                          (= (seq s1) s2-))))) ;; insertion/deletion\n          (graph-paths [graph] ;; graph = adjacency list\n            ;; \"step\" doesn't have a \"visited\" set parameter because it is\n            ;; better to have 100 funcs operate on 1 data structure than...\n            (letfn [(step [path [[curr & xs :as level] & more :as stack]]\n                      (cond\n                        (empty? stack) nil\n                        (empty? level) (step (rest path) more)\n                        :else (let [p (cons curr path)\n                                    visited (set p)\n                                    edges (graph curr)]\n                                (->> (concat [(remove visited edges)] [xs] more)\n                                     (step p)\n                                     (cons p)\n                                     (lazy-seq)))))]\n              (->> [(keys graph)]\n                   (step [])\n                   (map reverse))))]\n    (->> (for [s1 xs, s2 xs, :when (word-link? s1 s2)]\n           {s1 [s2]})\n         (apply merge-with into)\n         (graph-paths)\n         (some #(= (count xs) (count %)))\n         (boolean))))","user":"5d2e5065e4b01671435dbcae"},{"code":"(fn [words]\n  (let [chars (reduce into #{} words)\n        edits (fn [word]\n                (let [n (count word)]\n                  (concat\n                    (for [i (range 0 (inc n))\n                          c chars]\n                      (str (subs word 0 i) c (subs word i)))\n                    (for [i (range 0 n)]\n                      (str (subs word 0 i) (subs word (inc i))))\n                    (for [i (range 0 n)\n                          c chars]\n                      (str (subs word 0 i) c (subs word (inc i)))))))\n        matrix (into {}\n                 (for [word words\n                       :let [edits (filter words (edits word))]\n                       :when (seq edits)]\n                   [[word] edits]))\n        step (fn [m]\n               (into {}\n                 (for [[p words] m, word words\n                       :when (not-any? #{word} p)]\n                   [(conj p word) (matrix [word])])))\n        m* (nth (iterate step matrix) (dec (count words)))]\n  (boolean (seq m*))))","problem":82,"user":"4e8f1ac6535d65386fec2146"},{"problem":82,"code":"(fn [s]\n  (let [\n        vec-remove\n        (fn vec-remove\n          [coll pos]\n          (vec (concat (subvec coll 0 pos) (subvec coll (inc pos)))))\n        p\n        (fn p [str1 str2]\n          (let [len1 (count str1)\n                len2 (count str2)]\n            (cond (zero? len1) len2\n                  (zero? len2) len1\n                  :else\n                  (let [cost (if (= (first str1) (first str2)) 0 1)]\n                    (min (inc (p (rest str1) str2))\n                         (inc (p str1 (rest str2)))\n                         (+ cost\n                            (p (rest str1) (rest str2))))))))\n        q\n        (fn q [word s]\n          (let [v (vec s)]\n            (if (empty? v) true\n              (some true? (for [i (range (count v))]\n                            (if (= (p (nth v i) word) 1)\n                              (q (nth v i) (vec-remove v i))\n                              false))))))\n        ]\n    (true? (some true? (for [i (range (count (vec s)))]\n                         (q (nth (vec s) i) (vec-remove (vec s) i)))))))","user":"53664e3be4b0243289761e74"},{"problem":82,"code":"(fn [words]\n    (cond\n      (= words #{\"hat\" \"coat\" \"dog\" \"cat\" \"oat\" \"cot\" \"hot\" \"hog\"})\n      true\n      (= words #{\"cot\" \"hot\" \"bat\" \"fat\"})\n      false\n      (= words #{\"to\" \"top\" \"stop\" \"tops\" \"toss\"})\n      false\n      (= words #{\"spout\" \"do\" \"pot\" \"pout\" \"spot\" \"dot\"})\n      true\n      (= words #{\"share\" \"hares\" \"shares\" \"hare\" \"are\"})\n      true\n      (= words #{\"share\" \"hares\" \"hare\" \"are\"})\n      false)\n    )","user":"5777cffae4b0979f89651651"},{"problem":82,"code":"(fn [ws]\n  (letfn [(diffs [w1 w2]\n            (= 1\n               (loop [diffs 0\n                      xs w1\n                      ys w2]\n                 (cond\n                   (empty? xs)(+ diffs (count ys))\n                   (empty? ys)(+ diffs (count xs))\n                   (= (first xs) (first ys)) (recur diffs (rest xs) (rest ys))\n                   (= (count xs) (count ys)) (recur (inc diffs) (rest xs) (rest ys))\n                   (> (count xs) (count ys)) (recur (inc diffs) (drop 2 xs) (rest ys))\n                   (< (count xs) (count ys)) (recur (inc diffs) (rest xs) (drop 2 ys)))\n                 )))\n          (mp [ws]\n            (reduce (fn [mp w] \n                      (assoc mp  w (filter #(diffs w %) ws)))\n                    {}\n                    ws))\n          (path [m prevs lst]\n            (loop [ns lst]\n              (if (empty? ns) \n                prevs\n                (if (some #(= (first ns) %) prevs)\n                  (recur (rest ns))\n                  (let [pth (path m \n                                  (conj prevs (first ns)) \n                                  (get m (first ns)))]\n                       (if (= (count pth) (count m))\n                         pth\n                         (recur (rest ns))))\n                  ))))]\n    (= (count ws) \n       (count (path (mp ws) [] ws)))))","user":"578cf84ce4b0ebec4cfb7562"},{"code":"(letfn \n  [(conn [ss vs f] (for [s ss v (remove (set s) vs) :when (f (last s) v)] (conj s v)))\n   (h= [a] (count (take-while true? (apply (partial map =) a))))\n   (wc? [& a] (= (apply max (map count a)) (+ 1 (h= a) (h= (map reverse a)))))]\n  (fn [ss] (->> (iterate #(conn % ss wc?) (map vector ss)) (take (count ss)) last empty? not)))","problem":82,"user":"528e64b7e4b0239c8a67aedd"},{"code":"(letfn\n    [(distribute [e [h & t :as xs]]\n       (if (empty? xs)\n         [[e]]\n         (cons (cons e xs)\n               (map #(cons h %) (distribute e t)))))\n\n     (permutations [xs]\n       (if-let [[e & t] xs]\n         (mapcat #(distribute e %) (permutations t))\n         [[]]))\n\n     (count-diffs [[a & b :as l] [x & y :as r]]\n       (cond\n        (nil? a)        (count r)\n        (nil? x)        (count l)\n        (= a x)         (count-diffs b y)\n        (= a (first y)) (+ 1 (count-diffs l y))\n        (= x (first b)) (+ 1 (count-diffs b r))\n        :else           (+ 1 (count-diffs b y))))\n\n     (chain? [words]\n       (->> (partition 2 1 words)\n            (map #(apply count-diffs %))\n            (every? #(= 1 %))))]\n\n  (fn [xs]\n    (->> (seq xs)\n         (permutations)\n         (some chain?)\n         (true?))))","problem":82,"user":"52d2ca1ce4b099d49816f0b4"},{"problem":82,"code":"(fn is-word-chain? [word-set]\n  (letfn [(distance [s t]\n            \"Stupid imperative impelmentation of Levensthein distance\"\n            (let [full-len-s (count s)\n                  full-len-t (count t)]\n              ((fn recurring-distance [s len-s t len-t]\n                 (let [cost (if (= (get s (dec len-s)) (get t (dec len-t))) 0 1)]\n                   (cond\n                    (zero? len-s) len-t\n                    (zero? len-t) len-s\n                    :else (min\n                           (inc (recurring-distance s (dec len-s) t len-t))\n                           (inc (recurring-distance s len-s t (dec len-t)))\n                           (+ (recurring-distance s (dec len-s) t (dec len-t)) cost)))))\n               s full-len-s t full-len-t)))\n\n          (find-pairs-for-word [word others]\n            (filter (fn [other] (= 1 (distance word other))) others))\n\n          (create-word-pair-map [word-set]\n            (reduce (fn [acc word] (into acc {word (find-pairs-for-word word word-set)})) {} word-set))\n\n          (chain-length [used-words word m length]\n            (if (contains? used-words word)\n              length\n              (apply max (map (fn [w] (if (contains? used-words w)\n                                        length\n                                        (chain-length (conj used-words word)\n                                                      w\n                                                      m\n                                                      (inc length))))\n                              (get m word)))))]\n    (let [word-count (count word-set)\n        word-pair-map (create-word-pair-map word-set)\n        max-length (apply max (map (fn [w] (chain-length #{} w word-pair-map 1)) word-set))]\n        (= word-count max-length))))","user":"540e8d13e4b0addc1aec671e"},{"problem":82,"code":"(fn [bt]\n (letfn [ (lev [x y]\n   (if (empty? y) (count x)\n      (if (empty? x) (count y)\n  (let [c (if (= (first x) (first y)) 0 1)]\n   (min\n      (inc (lev x (rest y)))\n      (inc (lev (rest x) y))\n      (+ c (lev (rest x) (rest y))))))))\n\n  ( hm [remaining curr]\n     (if (empty? remaining) true\n     (let [neighbors (into #{} (filter #(= 1 (lev % curr)) remaining))]\n  (if (empty? neighbors) false\n (reduce #(or %1 (hm (disj remaining %2) %2)) false neighbors)))))\n]\n  (reduce #(or %1 (hm (disj bt %2) %2)) false bt)))","user":"54908cc1e4b0b312c081ff32"},{"code":"(fn word-chain [word-set]\n  (let [levenshtein-distance (fn [str1 str2]\n                               (let [len1 (inc (count str1))\n                                     len2 (inc (count str2))\n                                     arr (make-array Long len1 len2)]\n                                 (dotimes [i len1] (aset arr i 0 i))\n                                 (dotimes [j len2] (aset arr 0 j j))\n                                 (doseq [i (range 1 len1)]\n                                   (doseq [j (range 1 len2)]\n                                     (aset arr i j\n                                           (min (inc (aget arr (dec i) j))\n                                                (inc (aget arr i (dec j)))\n                                                (+ (if (= (nth str1 (dec i))\n                                                          (nth str2 (dec j))) 0 1)\n                                                   (aget arr (dec i) (dec j)))))))\n                                 (aget arr (dec len1) (dec len2))))\n        m (reduce (fn [acc x]\n                    (assoc acc x\n                           (set (filter #(= 1 (levenshtein-distance % x))\n                                        (disj word-set x)))))\n                  {}\n                  word-set)]\n    (letfn [(search [word used]\n              (if (= (count word-set) (count used))\n                true\n                (let [next-set (clojure.set/difference (m word) used)]\n                  (when-not (empty? next-set)\n                    (some #(search % (conj used %)) next-set)))))]\n      (boolean (some #(search % #{%}) word-set)))))","problem":82,"user":"504f57c7e4b0a02f9cffde71"},{"problem":82,"code":"(fn make-connections\n  ([s]\n   (not (empty? (make-connections nil (set s)))))\n  ([root children]\n   (letfn [(near? [s0 s1]\n             (let [c0 (count s0)\n                   c1 (count s1)\n                   i (mod (.indexOf (map = s0 s1) false) (max c0 c1))\n                   str-remove (fn [s i] (str (subs s 0 i) (subs s (inc i) (count s))))]\n               (= (if (<= c0 c1) (str-remove s1 i) s1)\n                  (if (>= c0 c1) (str-remove s0 i) s0))))]\n     (mapcat (fn [ele]\n               (let [remaining (disj children ele)]\n                 (if (empty? remaining)\n                   [[ele]]\n                   (map (partial cons ele) (make-connections ele remaining)))))\n             (if (nil? root)\n               children\n               (filter (partial near? root) children))))))","user":"5edab150e4b0c7845d86b0e9"},{"code":"(let [s (fn [a b]\n          (if (>= (count a) (count b))\n            (map seq [a b])\n            (map seq [b a])))\n      c (fn [a n] (into (vec (take n a)) (drop (inc n) a)))\n      m (fn [a b]\n          (loop [n 0]\n            (if (= n (count a))\n              false\n              (if (= (c a n) (c b n))\n                true\n                (recur (inc n))))))\n      l (fn [a b]\n          (if (or (nil? a) (nil? b))\n            true\n            (let [[a b] (s a b)\n                  A (count a)\n                  d (- A (count b))]\n              (if (= d 0)\n                  (m a b)\n                (when (= d 1)\n                  (loop [n 0]\n                    (if (= n A)\n                      false\n                      (if (= (c a n) b)\n                        true\n                        (recur (inc n))))))))))]\n  (fn C\n    ([w]\n      (C (vec w) nil))\n  \n    ([w s]\n      (if (empty? w)\n        true\n        (loop [n 0]\n          (if (= n (count w))\n            false\n            (let [S (nth w n)]\n              (if (l s S)\n                (if (C (c w n) S)\n                  true\n                  (recur (inc n)))\n                (recur (inc n))))))))))","problem":82,"user":"4f42ae16e4b0d7d3c9f3fd09"},{"problem":82,"code":"(fn [words]\n (letfn [(next? [word-c word-n]\n       (case (- (count word-c) (count word-n))\n              1 (true? (some #(= (seq word-n) %) (map #(concat (take % word-c) (next (drop % word-c))) (range 0 (count word-c)))))\n              -1 (true? (some #(= (seq word-c) %) (map #(concat (take % word-n) (next (drop % word-n))) (range 0 (count word-n)))))\n              0 (= 1 (count (filter false? (map #(= %1 %2) word-c word-n))))\n              false))\n          (chain [word searched-word words]\n            (let [nexts (filter #(and (next? word %) (nil? (searched-word %))) words)]\n              (if (seq nexts)\n                (true? (some true? (map #(chain % (set (cons % searched-word)) words) nexts)))\n                (= (count searched-word) (count words)))))]\n    (true? (some true? (map #(chain % #{%} words) words)))))","user":"597fa3fbe4b021a7a535fdbf"},{"problem":82,"code":"(letfn [(permutations [s] \n                      (if (= (count s) 1)\n                        [[(first s)]]\n                        (reduce (fn [acc elt]\n                                  (let [others (remove (set [elt]) s)\n                                        perms (permutations others)\n                                        new (map #(conj % elt) perms)]\n                                    (concat acc new)))\n                                []\n                                s)))\n        (insertion? [x y]\n                    (or (= (seq x) (rest y)) ; seq is needed or else x is a string and (rest y) a seq of chars, which aren't considered equal\n                        (and (= (first x) (first y))\n                             (insertion? (rest x) (rest y)))))\n        (sub? [x y]\n              (or (= (rest x) (rest y))\n                  (and (= (first x) (first y))\n                       (sub? (rest x) (rest y)))))\n        (valid-pair? [x y]\n                     (or (sub? x y)\n                         (insertion? x y)\n                         (insertion? y x)))\n\t\t(valid-chain? [v]\n                      (or (= 1 (count v))\n                          (and (valid-pair? (first v) (second v))\n                               (valid-chain? (rest v)))))]\n  (fn [words]\n    ;; the tests want an explicit true/false\n    (if (some valid-chain? (permutations words))\n      true false)))","user":"5553b924e4b0deb715856e06"},{"problem":82,"code":"(fn word-chain? [words]\n  (letfn [\n           (close? [[c1 & t1 :as s1] [c2 & t2 :as s2] dist]\n                   (let [ddist (dec dist)]\n                     (cond\n                       (< dist 0) false\n                       (and (empty? s1) (empty? s2) (= dist 0)) true\n                       (and (empty? s1) (empty? s2)) false\n                       (empty? s1) (recur s1 t2 ddist)\n                       (empty? s2) (recur t1 s2 ddist)\n                       (= c1 c2) (recur t1 t2 dist)\n                       :else (or (close? t1 s2 ddist) (close? s1 t2 ddist) (close? t1 t2 ddist))\n                       )))\n           (k-combinations [k s]\n                           (if (> k (count s))\n                             #{}\n                             (if (= k 1)\n                               (into #{} (map hash-set s))\n                               (let [[h & t] (seq s)]\n                                 (into\n                                   #{}\n                                   (concat\n                                     (k-combinations k t)\n                                     (map\n                                       #(into % (list h))\n                                       (k-combinations (dec k) t))))))))\n           (permuations [s]\n                        (((fn perm [s results]\n                            (if (results s)\n                              results\n                              (let [\n                                     new-perm\n                                     (apply concat\n                                            (map\n                                              (fn [x]\n                                                (let [without-x (disj s x)]\n                                                  (map #(cons x %) ((perm  without-x results) without-x))))\n                                              s))]\n                                (assoc results s new-perm))))\n                          s {#{} '(())})\n                         s))\n           (generate-possible-paths [s]\n                                    (into\n                                      #{}\n                                      (map\n                                        #(into #{} %)\n                                        (map\n                                          (fn [p]\n                                            (map #(into #{} %) (partition 2 1 p)))\n                                          (permuations s)))))\n           (intersect-sets [s1 s2] (set (filter #(contains? s2 %) s1)))\n           (subset? [s sub]\n                    (every? #(contains? s %) sub))\n           (swap? [s1 s2]\n                  (let [\n                         size (count s1)\n                         sub1 (k-combinations (dec size) s1)\n                         sub2 (k-combinations (dec size) s2)]\n                    (not (empty? (intersect-sets sub1 sub2)))))\n\n           (similar? [s1 s2]\n                     (close? s1 s2 1))\n           (path? [edges nodes start-node]\n                  (if (= 1 (count nodes))\n                    (contains? edges #{start-node (first nodes)})\n                    (if (empty? edges)\n                      false\n                      (let [\n                             possible-edges (filter #(and (contains? % start-node) (not (empty? (intersect-sets % nodes)))) edges)\n                             ]\n                        (not(nil? (some\n                                    (fn [edge]\n                                      (let [new-start-node (first (disj edge start-node))\n                                            new-nodes (disj nodes new-start-node)]\n                                        (path? (disj edges possible-edges) new-nodes new-start-node)))\n                                    possible-edges)))))))\n\n           (hamiltonian? [edges nodes]\n                         (not\n                           (nil?\n                             (some\n                               #(path? edges (disj nodes %) %)\n                               nodes))))\n           ]\n    (let [graph (into #{} (filter #(apply similar? %) (k-combinations 2 words)))]\n      ;(not(empty? (filter #(subset? graph %) (generate-possible-paths words)))))))\n      (hamiltonian? graph words))))","user":"5654e024e4b0f9d632dd848d"},{"code":"(fn [words]\n  (letfn [(step? [[x & xs :as a] [y & ys :as b]]\n            (if (and x y (= x y))\n              (recur xs ys)\n              (or (= xs (seq b)) (= ys (seq a)) (= xs ys))))\n          (extend [chains]\n            (mapcat\n              #(map (partial conj %)\n                (filter \n                  (partial step? (last %))\n                  (remove (set %) words)))\n              chains))]\n  ((comp not empty? nth)\n    (iterate extend (map vector words))\n    (dec (count words)))))","problem":82,"user":"4fce5474e4b0d4b2a7a9d451"},{"code":"(fn word-chain? [set-of-words]\r\n  (let\r\n    [subst? (fn [w1 w2]\r\n              (let\r\n                [c1 (count w1)\r\n                 c2 (count w2)\r\n                 char1 (seq w1)\r\n                 char2 (seq w2)]\r\n                (and (= c1 c2)\r\n                     (= 1 (count (filter #(not= (nth char1 %)\r\n                                                (nth char2 %)) (range c1)))))))\r\n     insertion? (fn [w1 w2] ; w2 is longer\r\n                  (let\r\n                    [c1 (count w1)\r\n                     c2 (count w2)\r\n                     char1 (seq w1)\r\n                     char2 (seq w2)]\r\n                   (and (= (inc c1) c2)\r\n                     (some #(= char1 \r\n                               (concat (take % char2)\r\n                                       (drop (inc %) char2))) (range c2)))))\r\n     word-chain-from (fn word-chain-from [w s-o-w]\r\n                       (if (empty? s-o-w) true\r\n                        (let \r\n                          [next-words (filter #(or (subst? w %)\r\n                                                   (insertion? w %)\r\n                                                   (insertion? % w)) s-o-w)]\r\n                          (if (empty? next-words) false\r\n                            (some #(word-chain-from % (disj s-o-w %)) next-words)))))\r\n     any-word-chain (some #(word-chain-from % (disj set-of-words %)) set-of-words)]\r\n     (= true any-word-chain)))","problem":82,"user":"4f036fb3535dcb61093f6ac8"},{"code":"(fn [words] (letfn [(edit-dist [s t]\r\n                              (cond (empty? s) (count t)\r\n                                    (empty? t) (count s)\r\n                                    :else (let [rs (rest s) rt (rest t)]\r\n                                            (if (= (first s) (first t)) (edit-dist rs rt)\r\n                                                (inc (min  (edit-dist rs t)\r\n                                                           (edit-dist s rt)\r\n                                                           (edit-dist rs rt)))))))\r\n                            (find-paths [graph start seen]\r\n                              (if (seen start) seen\r\n                                  (for [n (graph start)]\r\n                                    (find-paths graph n (conj seen start)))))]\r\n                      (let [graph (into {}\r\n                                        (for [word words]\r\n                                          [word (filter #(= 1 (edit-dist % word)) words)]))]\r\n                        (if (some (fn [w]\r\n                                    (some #(= words %)\r\n                                          (flatten (find-paths graph w #{}))))\r\n                                  words)\r\n                          true false))))","problem":82,"user":"503d129fe4b06c4e0e1fa254"},{"problem":82,"code":"(fn all-words-chain? [words-set]\n  (letfn [(linked-words? [source target]\n            (let [[smaller greater] (sort-by count [source target])\n                  greater-indexed (map-indexed (fn [idx c] [idx c]) greater)\n                  smaller-indexed (map-indexed (fn [idx c] [idx c]) smaller)]\n              (letfn [(combine-matches-or-nil [greater-tuple smaller-tuple]\n                        (map (fn [[out-idx out-ch]] \n                                (some (fn [[in-idx in-ch]] \n                                        (when (and (= out-ch in-ch) \n                                                   (or (= out-idx in-idx)\n                                                   (= out-idx (inc in-idx))\n                                                   (= out-idx (dec in-idx)))) out-ch)) \n                                smaller-tuple)) \n                          greater-tuple))]\n                (when (<= (- (count greater) (count smaller)) 1)\n                  (when-let [greater-combined-matches (combine-matches-or-nil greater-indexed smaller-indexed)]\n                    (when-let [smaller-combined-matches (combine-matches-or-nil smaller-indexed greater-indexed)]\n                      (let [greater-matches-indexed (map-indexed (fn [idx x] [idx x]) greater-combined-matches)\n                            smaller-matches-indexed (map-indexed (fn [idx x] [idx x]) smaller-combined-matches)]\n                        (>= 1\n                          (count\n                              (filter (fn [matched-indexed] (nil? (last matched-indexed)))\n                                  (set \n                                      (apply conj \n                                          greater-matches-indexed smaller-matches-indexed))))))))))))\n          (find-links-foreach-word [words]\n            (map (fn [word]\n                    (reduce (fn [acc compared-word]\n                              (if (= word compared-word) acc\n                                (if (linked-words? word compared-word)\n                                  (inc acc)\n                                  acc)))\n                            0 words)) \n                 words))]\n    (->> words-set\n        find-links-foreach-word\n        (filter #(= 1 %))\n        count\n        (>= 2))))","user":"5553b729e4b0deb715856e05"},{"code":"(fn [words]\r\n  (letfn [(dist1 [w1 w2]\r\n            (let [n1 (count w1) n2 (count w2)]\r\n              (cond\r\n                (= n1 n2) (= 1 (count\r\n                                 (remove true?\r\n                                   (map (fn [[a b]] (= a b))\r\n                                     (partition 2 (interleave w1 w2))))))\r\n                (= n1 (inc n2)) (if\r\n                                  (some true?\r\n                                    (map #(let [[w1a w1b] (split-at % w1)]\r\n                                            (= w2 (apply str (concat w1a (rest w1b)))))\r\n                                      (range 0 n1)))\r\n                                  true false)\r\n                (= n2 (inc n1)) (dist1 w2 w1)\r\n                :else false)))]\r\n    (loop [chains (map (fn [w] [w (disj words w)]) words)]\r\n      (cond\r\n        (empty? chains) false\r\n        (some (fn [[_ s]] (empty? s)) chains) true\r\n        :else (recur (mapcat \r\n                       (fn [[w ws]] (map (fn [x] [x (disj ws x)]) (filter #(dist1 w %) ws))) \r\n                       chains))))))","problem":82,"user":"4f969214e4b0dcca54ed6cdd"},{"problem":82,"code":"(fn chain [words]\n           (letfn \n      [(drop1 [s]\n         (for [i (range (count s))]\n           (apply str (map #(nth s %) (remove #(= % i) (range (count s)))))))\n       (diff1 [w1 w2]\n         (let [c1 (count w1) c2 (count w2)]\n           (cond\n             (= c1 c2)\n             (= 1 (count (filter false? (map #(= (nth w1 %) (nth w2 %)) (range c1)))))\n             (= c1 (inc c2)) (some #(= w2 %) (drop1 w1))\n             (= c2 (inc c1)) (some #(= w1 %) (drop1 w2))\n             :else false)))\n       (word-chain [w s]\n         (if (empty? s) true\n             (for [w2 (filter #(diff1 % w) (disj s w))]\n               (word-chain w2 (disj s w w2)))))]\n    (not (empty? (flatten (map #(word-chain % words) words))))))","user":"5307e4ece4b02e82168697a9"},{"code":"(fn wc [ADJ s & [w]]\n  (if (empty? s) true\n    (let [adjs (if w (filter #(ADJ w %) s) s)]\n      (or (some #(wc ADJ (disj s %) %) adjs) false))))\n(fn adj [s1 s2]\n  (let [C count]\n    (or (and (> (C s1) (C s2)) (adj s2 s1))\n        (and (= (C s1) (C s2))\n             (= 1 (C (remove identity (map = s1 s2)))))\n        (and (= (inc (C s1)) (C s2))\n             (let [m (C (take-while identity (map = s1 s2)))]\n               (or (= (drop m s1) (drop (inc m) s2))))))))","problem":82,"user":"504e04a4e4b078edc5f59397"},{"code":"(fn isChain? [x]\n(letfn\n\t[(close? [a b] \n\t\t(loop [[ca & na] (seq a) [cb & nb] (seq b) cnt 0]\n\t\t\t(if (= ca cb)\n\t\t\t\t(if (= nil nb na)\n\t\t\t\t\ttrue\n\t\t\t\t\t(recur na nb cnt))\n\t\t\t\t(if (> cnt 0)\n\t\t\t\t\tfalse\n\t\t\t\t\t(case (- (count na) (count nb))\n\t\t\t\t\t\t-1 (recur (cons ca na) nb 1)\n\t\t\t\t\t\t1 (recur na (cons cb nb) 1)\n\t\t\t\t\t\t(recur na nb 1))))))\n\t(canChain? [start cands]\n\t\t(if (= 1 (count cands))\n\t\t\t(close? start (first cands))\n\t\t\t(loop [c (last cands) nxt (butlast cands) i 0]\n(do (println start cands c nxt (close? c start))\n\t\t\t\t(if (= i (count cands))\n\t\t\t\t\tfalse\n\t\t\t\t\t(if (close? start c)\n\t\t\t\t\t\t(if (canChain? c nxt)\n\t\t\t\t\t\t\ttrue\n\t\t\t\t\t\t\t(recur (last nxt) (conj (butlast nxt)  c) (inc i)))\n\t\t\t\t\t\t(recur (last nxt) (conj (butlast nxt)  c) (inc i))))\n)\n\t\t\t\t)))\n\t]\n\t(loop [cur (last (seq x)) nxtCand (butlast (seq x)) ind 0]\n\t\t(if (= ind (count x))\n\t\t\tfalse\n\t\t\t(if (canChain? cur nxtCand)\n\t\t\t\ttrue\n\t\t\t\t(recur (last nxtCand) (conj (butlast nxtCand) cur) (inc ind)))))\n))","problem":82,"user":"52bf6946e4b07a9af5792334"},{"problem":82,"code":"(fn [ss]\n  (let [followed? (fn followed? [s s']\n                    (if (> (count s) (count s'))\n                      (followed? s' s)\n                      (let [diff-idx (.indexOf (map = s s') false)\n                            drop-nth (fn [n xs]\n                                       (concat (take n xs)\n                                               (drop (inc n) xs)))]\n                        (if-not (neg? diff-idx)\n                          (if (= (count s') (count s))\n                            (= (drop-nth diff-idx s')\n                               (drop-nth diff-idx s))\n                            (= (drop-nth diff-idx s')\n                               (seq s)))\n                          (= 1 (- (count s') (count s)))))))\n        followers (reduce (fn [acc s]\n                            (assoc acc s\n                                   (filter #(followed? s %) ss)))\n                          {}\n                          ss)\n        make-chains (fn make-chains [acc init-word]\n                      (if (get acc init-word)\n                        [acc]\n                        (apply concat\n                               (map #(make-chains (conj acc init-word) %)\n                                    (get followers init-word)))))]\n    (println followers)\n    (println (followed? \"dot\" \"do\"))\n    (boolean\n     (some\n      (partial = ss)\n      (apply concat\n             (map #(make-chains #{} %)\n                  (keys followers)))))))","user":"5393185ae4b0b51d73faaeb7"},{"problem":82,"code":"(fn chain [c]\n  (let [editdist\n        (fn editdist [s t]\n          (let [dp\n                (fn dp [mdp x y]\n                  (let [xym (when (> (min x y) 0)\n                              (let [r (mdp mdp (dec x) (dec y))]\n                                (if (= (get s (dec x)) (get t (dec y)))\n                                  r\n                                  (inc r))))\n                        xm (when (> x 0)\n                             (inc (mdp mdp (dec x) y)))\n                        ym (when (> y 0)\n                             (inc (mdp mdp x (dec y))))\n                        l (filter (comp not nil?) (list xym xm ym))]\n                    (if (empty? l)\n                      0\n                      (apply min l))))\n                mdp (memoize dp)]\n            (mdp mdp (count s) (count t))))\n        search\n        (fn search [c h]\n          (if (empty? c)\n            true\n            (boolean (some #(search (remove #{%} c) %) (filter #(= 1 (editdist % h)) c)))))]\n    (boolean (some #(search (remove #{%} c) %) c))))","user":"5953bdb6e4b066ee0a44aeed"},{"problem":82,"code":"(fn [x]\n   (letfn [(wordchain\n              ([wordset]\n               (wordchain [] wordset #{}))\n              ([chain unused tried]\n               (letfn [(canmorph [a b]\n                (if (< (count a) (count b))\n                  (canmorph b a)\n                  (let [acount (count a)\n                        bcount (count b)\n                        ctdiff (Math/abs (int (- acount bcount)))\n                        ;; diffinc: the amount to increment the traversing index when the\n                        ;; characters differ. For strings that are 1 length different,\n                        ;; you don't want to increment the index, but for same-length\n                        ;; strings you do\n                        diffinc (if (= 1 ctdiff) 0 1)]\n                    (if (> ctdiff 1)\n                      false\n                      (= 1\n                         (first\n                          (reduce\n                            (fn [[numdiffs index] newchar]\n                              (if (= (get b index) newchar)\n                                [numdiffs (inc index)]\n                                [(inc numdiffs) (+ index diffinc)]))\n                            [0 0]\n                            a)))))))]\n                 (println chain \" \" unused \" \" tried)\n                 (if (empty? unused)\n                   (if (empty? tried)\n                     chain\n                     false)\n                   (let [lastlink (last chain)\n                         nextoptions (clojure.set/difference unused tried)\n                         nexttry (if (nil? lastlink)\n                                   (first nextoptions)\n                                   (first (filter #(canmorph lastlink %) nextoptions)))\n                         nextchain (conj chain nexttry)\n                         nextunused (disj unused nexttry)\n                         nexttried (conj tried nexttry)]\n                     (if (nil? nexttry)\n                       false\n                       (or (wordchain nextchain nextunused [])\n                           (wordchain chain unused nexttried))))))))]\n   (if (= false (wordchain x))\n     false\n     true)))","user":"54d9366ce4b0a52adc2e204e"},{"problem":82,"code":"(fn canChain? [lw] (letfn [\n\n                             (diffSameSize [w1 w2]  (apply + (map #(if (= %1 %2) 0 1) w1 w2)))\n\n                             (diffDiffSize [w1 w2] (loop [todo1 w1 todo2 w2 skipped false] (cond\n                                                                                                  (or (empty? todo1) (empty? todo2)) true\n                                                                                                  (= (first todo1) (first todo2)) (recur (rest todo1) (rest todo2) skipped)\n                                                                                                  skipped false\n                                                                                                  :else (let [longer (if (> (count todo1) (count todo2)) todo1 todo2)\n                                                                                                              shorter (if (> (count todo1) (count todo2)) todo2 todo1)] (recur (rest longer) shorter true))\n                                                                                                  )\n                                                                                                )\n                               )\n\n                             (isChild? [word candidate] (let [wordSeq (seq word)\n                                                                   candSeq  (seq candidate)\n                                                                   lengthDiff (Math/abs (- (count wordSeq) (count candSeq))) ]\n                                                               (cond\n                                                                 (= word candidate) false\n                                                                 (> lengthDiff 1) false\n                                                                 (= 0 lengthDiff ) (< (diffSameSize wordSeq candSeq) 2)\n                                                                 :else (diffDiffSize word candidate)\n                                                                 )))\n                             (findChildren [word words] (loop [res '() todo words] (cond\n                                                                                          (empty? todo) res\n                                                                                          (isChild? word (first todo)) (recur (cons (first todo) res) (rest todo))\n                                                                                          :else (recur res (rest todo))\n                                                                                          )))\n\n                             (walkChain [word chainMap visited goal] (let [newVisited (conj visited word)]\n                                                                            (cond\n                                                                              (= newVisited goal) true\n                                                                              (contains? visited word) false\n                                                                              :else (loop [todo (chainMap word)]\n                                                                                      (cond\n                                                                                        (empty? todo) false\n                                                                                        (walkChain (first todo) chainMap newVisited goal) true\n                                                                                        :else (recur (rest todo))\n                                                                                        )))\n                                                                            ))\n\n                             (findAllChildren [words]  (apply merge\n                                                                   (map\n                                                                     #(hash-map % (findChildren % words))\n                                                                     words)))\n                             ]\n                       (let [wordsWithChildren (findAllChildren lw)]\n                       (not (= nil (some #(walkChain % wordsWithChildren #{} lw) lw)))))\n  )","user":"56427910e4b08d4f616f5f19"},{"code":"(fn chainable? [coll]\n  (letfn [(chainable-from? [curr coll res]\n            (letfn [(allowed-move? [s1 s2 diff?]\n                      (if (and (empty? s1) (empty? s2) diff?)\n                        true\n                        (if (= (first s1) (first s2))\n                          (recur (rest s1) (rest s2) diff?)\n                          (if diff?\n                            false\n                            (or (allowed-move? s1 (rest s2) :diff) ;insertion\n                                (allowed-move? (rest s1) s2 :diff) ;deletion\n                                (allowed-move? (rest s1) (rest s2) :diff))))))] ;substitution\n              (if (empty? coll)\n                res\n                (when-let [next-steps (set (filter #(allowed-move? curr % false) coll))]\n                  (boolean (some (partial apply chainable-from?) (for [x next-steps] [x (disj coll x) (conj res x)])))))))]\n    (boolean (some (partial apply chainable-from?) (for [x coll] [x (disj coll x) [x]])))))","problem":82,"user":"50645e12e4b007509339a58a"},{"problem":82,"code":"; This is probably NP-Complete (hamiltonian path should reduce to it, \n; though the reducer is a little trickier than I first thought).\n(fn chain-exists? [words]\n    (let [words-close? (fn words-close? [a b]\n                           (cond (= (first a) (first b))\n                                 (if-not (nil? (first a))\n                                         (words-close? (subs a 1) (subs b 1))\n                                         true)\n                                 (empty? a) (= 1 (count b))\n                                 (empty? b) (= 1 (count a))\n                                 (not= (first a) (first b))\n                                 (or (= (subs a 1) (subs b 1))\n                                     (= a (subs b 1))\n                                     (= (subs a 1) b))))\n                       edges (filter #(apply words-close? %1)\n                                     (mapcat #(%1 words)\n                                             (map (fn [w]\n                                                      (fn [words]\n                                                          (->> words\n                                                               (filter #(and (not= w %1)\n                                                                             (< 0 (compare %1 w))))\n                                                               (map vector (repeat w)))))\n                                                  words)))\n                       f (fn f' [cur-word remaining-words remaining-edges]\n                             (if (empty? remaining-words)\n                                 true\n                               (let [cur-edges (filter (comp not empty?\n                                                             (partial filter\n                                                                      (partial = cur-word)))\n                                                       remaining-edges)]\n                                 (if (empty? cur-edges)\n                                     false\n                                   (some #(let [next-word (first (filter\n                                                                  (partial not= cur-word) %1))]\n                                            (f' next-word\n                                                (filter (partial not= next-word) remaining-words)\n                                                (filter (partial not= %1) remaining-edges)))\n                                         cur-edges)))))]\n      (boolean\n       (some #(f %1 (filter (partial not= %1) words) edges)\n             words))))","user":"54be7772e4b0ed20f4ff6eea"},{"code":"(fn word-chains\n  [words]\n  (letfn [(substrings\n            [s]\n            (into #{} (map (fn [i] (concat (take i s) (drop (inc i) s))) (range (count s)))))\n          (subs? [longer shorter] (not (empty? (filter #(= % (seq shorter)) (substrings longer)))))\n          (close?\n            [a b]\n            (cond\n             (> (Math/abs (- (count a) (count b))) 1) false\n             (> (count a) (count b)) (subs? a b)\n             (< (count a) (count b)) (subs? b a)\n             :else (= (count (filter #(not= (first %) (second %)) (partition 2 (interleave a b)))) 1)\n             ))\n          (pflatten\n            [s]\n            (if (empty? s)\n              s\n              (let [f (first s)\n                    r (rest s)]\n                (if (not (coll? (first f)))\n                  (cons f (pflatten r))\n                  (concat (pflatten f) (pflatten r))))))\n          (get-vertex\n            [v]\n            {v (reduce (fn [r e]\n                         (if (close? v e)\n                           (conj r e)\n                           r)) #{} (disj words v))})\n          (bfs\n            [g v p]\n            (if (contains? p v)\n              p\n              (map #(bfs g % (conj p v)) (g v))\n              ))]\n            ;(let [a (into #{} (get v))]\n\n    (let [graph (into {} (map get-vertex words))]\n      (if (nil? (some #(= words %) (mapcat #(pflatten (bfs graph % #{})) (keys graph))))\n        false\n        true))\n  ))","problem":82,"user":"5348cab4e4b084c2834f4a5e"},{"code":"(fn p82 [words]\n  (letfn [(dist-1? [w from]\n  \t   (let [alphabet \"abcdefghijklmnopqrstuv\"\n\t\t\t splits (for [i (range (count w))] (split-at i w))\n\t\t\t deletes (for [[a b] splits :when (seq b)]\n\t\t\t\t   (concat a (drop 1 b)))\n\t\t\t ins (for [[a b] splits\n\t\t\t\t   c alphabet]\n\t\t\t       (concat a (str c) b))\n\t\t\t subs (for [[a b] splits\n\t\t\t\t    c alphabet\n\t\t\t\t    :when (seq b)]\n\t\t\t\t(concat a (str c) (drop 1 b)))]\n\t\t     (some #(= % (seq from)) (concat deletes ins subs))))\n\t  (permutations\n\t   ([items] (permutations items [] []))\n\t   ([items results so-far]\n\t      (if (empty? items)\n\t\t(conj results so-far)\n\t\t(loop [is items results results]\n\t\t  (if (empty? is) results\n\t\t      (recur (rest is)\n\t\t\t     (permutations (remove #(= % (first is)) items)\n\t\t\t\t    results (conj so-far (first is)))))))))]\n    (not (empty?\n\t  (filter #(every? (fn [[a b]] (dist-1? a b)) (partition 2 1 %))\n\t\t  (permutations (sort words)))))))","problem":82,"user":"4e513ecf535dc968683fc4f6"},{"problem":82,"code":"(fn [s]\n  (letfn [(permutations [colls]\n                       (if (= 1 (count colls))\n                         (list colls)\n                         (for [head colls\n                               tail (permutations (disj (set colls) head))]\n                           (cons head tail))))\n        (diff [a b]\n               (loop [i 0 difcount 0 w1 a w2 b]\n                 (cond \n                   (and (zero? (count w1)) (zero? (count w2))) difcount \n                   (= 1 (+ (count w1) (count w2))) (recur (inc i) (inc difcount) (rest w1) (rest w2)) \n                   (= (first w1) (first w2)) (recur (inc i) difcount (rest w1) (rest w2))\n                   (= (first w1) (second w2)) (recur (inc i) (inc difcount) w1 (rest w2))\n                   (= (second w1) (first w2)) (recur (inc i) (inc difcount) (rest w1) w2)\n                   :else (recur (inc i) (inc difcount) (rest w1) (rest w2)))))\n        (valid? [s]\n                 (every? #(= 1 %) (map (fn [[a b]] (diff b a)) (partition 2 1 s))))]\n    (if (some true? (map valid? (permutations s))) true false)))","user":"541ddadbe4b01498b1a71a84"},{"code":"(fn [sq]\n  (letfn [(distance [s1 s2]\n                    (cond\n                      (empty? s1) (count s2)\n                      (empty? s2) (count s1)\n                      :else (min\n                              (+ (if (= (first s1) (first s2)) 0 1)\n                                 (distance (rest s1) (rest s2)))\n                              (inc (distance (rest s1) s2))\n                              (inc (distance s1 (rest s2))))))\n          (iter [target level ele all found]\n                (if (= target level)\n                  (= target (count (distinct found)))\n                  (->>\n                    (filter #(= 1 (distance % ele)) all)\n                    distinct\n                    (#(for [e %] (iter target (inc level) e all (conj found ele)))))))]\n    (let [l (into '() sq)]\n      (->>\n        (for [e l] (iter (count l) 0 e l [e]))\n        flatten\n        (some true?)\n        nil? false?))))","problem":82,"user":"530cb5b8e4b02e82168697e0"},{"problem":82,"code":"(letfn [(rm-at [idx word-seq]\n          (let [[l r] (split-at idx word-seq)]\n            (concat l (rest r))))\n        (chained-words? [w1 w2]\n          (= 1 (count\n                (remove\n                 false?\n                 (if-not (= (count w1) (count w2))\n                   (let [[w-l w-h] (sort-by count [(seq w1) (seq w2)])]\n                     (map #(= w-l (rm-at % w-h)) (range (count w-h))))\n                   (map #(not= %1 %2) w1 w2))))))\n        (chain? [word words]\n          (let [chain (filter #(chained-words? word %) words)]\n            (if (seq chain)\n              (some true? (map #(chain? % (disj words %)) chain))\n              (empty? words))))]\n  (fn [words]\n    (true? (some true? (map #(chain? % (disj words %)) words)))))","user":"540a4f20e4b0addc1aec66ef"},{"code":"(fn [w] (= 0 (mod (rand-int 2) 2)))","problem":82,"user":"5100d7dbe4b04f1d96d946df"},{"code":"(fn wc \n   ([coll] (wc [] coll))\n   ([p coll]\n    (letfn\n     [(diff [av bv]\n     (cond\n      (or (empty? av) (empty? bv)) (max (count av) (count bv))\n      (= (first av) (first bv))\n         (diff (next av) (next bv))\n      (= (second av) (first bv))\n         (+ 1 (diff (nnext av) (next bv)))\n      (= (first av) (second bv))\n         (+ 1 (diff (next av) (nnext bv)))\n      :else \n         (+ 1 (diff (next av) (next bv)))\n     ))]\n    (cond \n     (empty? coll)\n       true\n     (nil? (some true? \n      (for [x coll\n            :when (>= 1 (if (empty? p) 0 (diff x (last p))))\n           ]\n       (wc (conj p x) (disj coll x))))) \n       false\n     :else\n       true\n     ))))","problem":82,"user":"50de11b2e4b061dbdced7217"},{"problem":82,"code":"(fn [coll]\n    (let [coll (into #{} coll)]\n      (letfn [(index-of-first-diff-char [s0 s1] ; s0 must be longer than s1 by 1 character or equal in length\n                (if (= s0 s1)\n                  -1\n                  (or (first (keep #(when (not= (nth s1 %)\n                                                (nth s0 %))\n                                      %)\n                                   (range (count s1))))\n                      (dec (count s0)))))\n              (diff-by-one? [s0 s1]\n                (let [[s0 s1] (if (> (count s0) (count s1)) [s0 s1] [s1 s0]) ; ensure s0 is the longer of the two\n                      i (index-of-first-diff-char s0 s1)]\n                  (if (< i 0)\n                    false\n                    (if (> (count s0) (count s1))\n                      ;; a character was added\n                      (and (= (subs s0 0 i)\n                              (subs s1 0 (Math/min i (count s1))))\n                           (= (subs s0 (inc i))\n                              (subs s1 (Math/min i (count s1)))))\n                      ;; a character was replaced\n                      (and (= (subs s0 0 i)\n                              (subs s1 0 i))\n                           (= (subs s0 (inc i))\n                              (subs s1 (inc i))))))))\n              (set-of-ones [coll e]\n                (reduce conj #{} (filter #(diff-by-one? e %) coll)))\n              (one-map [coll]\n                (reduce (fn [m e] (assoc m e (set-of-ones coll e))) {} coll))\n              (build-chain\n                ([m k result]\n                 ;; (println (str \"CALL \" k (into [] (m k)) \" | r=\" result))\n                 (if (and k (not (contains? result k)))\n                   (let [result (conj result k)]\n                     (if-let [ks (seq (remove #(contains? result %)\n                                              (m k)))]\n                       (if (= 1 (count ks))\n                         (build-chain m (first ks) result)\n                         (letfn [(finish [s]\n                                   (into result\n                                         (-> (sort #(> (first %1) (first %2)) s)\n                                             first second)))]\n                           (loop [ks         ks\n                                  chain-data []]\n                             (if-let [k1 (first (remove #(contains? result %) ks))]\n                               (recur\n                                (next ks)\n                                (let [chain (build-chain m k1 result)]\n                                  ;; (println (str (count chain) \" : \" k1 \" : \" chain))\n                                  (conj chain-data [(count chain) chain])))\n                               (finish chain-data)))))\n                       result))\n                   result))\n              ([m] (reduce (fn [prev s] (if (> (count s) (count prev)) s prev))\n                             #{}\n                             (map #(build-chain m % #{})\n                                  (keys m)))))]\n        (let [m (one-map coll)\n              chain (build-chain m)]\n          #_[m \"------\" chain]\n          (= (into #{} coll)\n             (into #{} chain))))))","user":"5a5d0726e4b0512ff01cd91b"},{"problem":82,"code":"(fn word-chain? [s]\n  (let [changeable? (fn [from to]\n                      (if (= (count from) (count to))\n                        (let [cnt1 (count from)\n                              cnt2 (->> (map #(= %1 %2) from to)\n                                        (filter true?)\n                                        count)]\n                          (= (dec cnt1) cnt2))\n                        (let [f (fn [from to]\n                                  (let [cnt (count from)]\n                                    (loop [i 0\n                                           j 0\n                                           penalty 0]\n                                      (if (= i cnt)\n                                        (= penalty 1)\n                                        (if (= (get from i)\n                                               (get to j))\n                                          (recur (inc i) (inc j) penalty)\n                                          (recur (inc i) j (inc penalty)))))))]\n                          (if (> (count from) (count to))\n                            (f from to)\n                            (f to from)))))]\n    (let [f (fn f [x s]\n            (if (empty? s)\n              true\n              (let [good (filter #(changeable? x %) s)]\n                (if (empty? good)\n                  false\n                  (some #(f % (disj s %)) good)))))]\n    (true? (some #(f % (disj s %)) s)))))","user":"549c6792e4b0f3d1d8e70f8b"},{"code":"(fn [words] \n  (let [dist (fn [at bt]\n    (let [a (vec (if (> (count at) (count bt)) at bt))\n                  b (vec (if (> (count at) (count bt)) bt at))\n                  n (count a)\n                  m (count b)\n                  ]\n          (loop [table (conj [(vec (range (inc m)))] (vector 1)) row 1 col 1]\n            (let [above (get (get table (dec row)) col)\n                                    left  (get (get table row) (dec col))\n                                    diag  (get (get table (dec row)) (dec col))\n                                    cost (if (not= (get a (dec row)) (get b (dec col)))\n                                                               1 0)]\n                            (if (> row n)\n                                        (get (get table n) m)\n                                        (if (> col m)\n                                                      (recur (conj table (vector (inc row))) (inc row) 1)\n                                                      (recur (assoc table row (conj (get table row) (min (inc above) (inc left) (+ diag cost)))) row (inc col) )))))))\n        dist-map-inner (fn [acc1 word1] \n                         (conj acc1 [word1 (->> words\n                           (filter #(not= word1 %))\n                           (reduce (fn [acc2 word2]\n                                    (conj acc2 [word2 (dist word1 word2)])) {}))]))\n        dist-map (reduce dist-map-inner {} words)] \n    (loop [tovisit (into [] (map (fn [x] {:word x :lastword nil :visited #{}}) words))]\n      (let [lastword (:lastword (peek tovisit)) \n            curword (:word (peek tovisit)) \n            visited (:visited (peek tovisit))]\n        (if (= (count words) (count visited)) \n          true\n          (if (empty? tovisit)\n            false\n            (if (or (= lastword curword) (contains? visited curword) \n                    (not (or (nil? lastword)  \n                           (= 1 (get-in dist-map [curword lastword])))))  \n              (recur (pop tovisit))\n              (recur (into (pop tovisit)\n                     (map (fn [x] {:word x :lastword curword :visited (conj visited lastword)}) words))))))))))","problem":82,"user":"4e7f5a0b535db966e863cc41"},{"code":"(fn [v]\n  (let [one-off? (fn [s t]\n          (if (= (count s) (count t))\n              (= 1 (count (clojure.set/difference (set s) (set t))))\n             (let [r (sort-by count [s t])]\n               (reduce #(or %1 %2)\n                  (map #(= (first r) %)\n                   (for [i (range 0 (count (second r)))]\n                     (apply str (concat (take i (second r)) (drop (inc i) (second r))))))))))\n        f (fn f [s v]\n              (if (empty? v)\n                true\n                (for [x (filter #(one-off? s %) v)]\n                  (f x (remove #{x} v)))))]\n    (not (empty?  (flatten  (for [x v] (f x (remove #{x} v))))))))","problem":82,"user":"50bce014e4b0594b91591c63"},{"code":"(fn [wset]\n  (letfn [(dropletter [word]\n            (map #(apply str (concat (take % word) (drop (inc %) word))) (range (count word))))\n          (doChecks [w1 w2] \n            (let [w1s (dropletter w1) w2s (dropletter w2)] \n              (some true? [(some #(= % w2) w1s)\n                           (some #(= % w1) w2s)\n                           (some true? (map = w1s w2s))])))\n          (iterCheck [w s]\n              (if (empty? s)\n                true ; <--------- No more words to check -> success.\n                (some ; <-------- Only one successful path required.\n                 (fn [sn] \n                   (if (doChecks w sn)\n                     (iterCheck sn (remove #(= % sn) s)) ; Branch here.\n                     false)) ; No success with this path.\n                 s)))]\n    (boolean (some (fn [w] (iterCheck w (remove #(= % w) wset))) wset))))","problem":82,"user":"528652fbe4b0239c8a67ae14"},{"problem":82,"code":"(fn ff [coll]\n  (letfn [(re-1 [x]\n                 (re-pattern (clojure.string/join\n                              \"|\"\n                              (cons (str \".\" x)\n                                    (for [i (range (count x))]\n                                      (str (subs x 0 i)\n                                           (format \"(%.1s.|.)?\" (subs x i))\n                                           (subs x (inc i))))))))\n           (l [abc re xyz]\n              (mapcat (fn [x]\n                        (let [yz (remove #{x} xyz)]\n                          (if (re-matches re x)\n                            (if (empty? yz)\n                              [(conj abc x)]\n                              (l (conj abc x) (re-1 x) yz)))))\n                      xyz))]\n    (not  (empty? (l [] #\".*\" coll)))))","user":"56102f50e4b05f002753df6b"},{"code":"(letfn [(subst? [x y]\n          (and (= (count x) (count y))\n               (not (next (filter false? (map = x y))))))\n        (deletion? [x y]\n          (let [diff (apply - (map count [x y]))]\n            (cond (neg? diff) (deletion? y x)\n                  (not= 1 diff) false\n                  :else (loop [x x, y y]\n                          (if-let [[y & ys :as all-ys] (seq y)]\n                            (let [[x & xs] (seq x)]\n                              (if (= x y)\n                                (recur xs ys)\n                                (= all-ys xs)))\n                            true)))))\n        (link? [x y]\n          (or (subst? x y)\n              (deletion? x y)))]\n  (fn [words]\n    (let [links (for [a words]\n                  (dec (count (filter #(link? a %)\n                                      words))))]\n      (> 3 (count (filter #(<= % 1) links))))))","problem":82,"user":"4dabb7b1950ed6eda1bd72f3"},{"code":"(fn [w]\n  (let [f (fn f [x y] (and (= (inc(count x)) (count y))(contains? (set (map #(apply str (keep-indexed (fn [i e] (if (not= % i) e)) y)) (range 0 (count y)) ))x)))\n        g (fn g [x y]\n          (if (= (count x) (count y))\n            (loop [x x yl y c 0]\n              (if x\n                (recur (next x) (next yl) (if (= (first x) (first yl)) c (inc c) ))\n                (if (= 1 c) y)))\n            (if (or (f x y) (f y x))\n              y\n              )))\n        h (map-indexed #(vector %2 (filter identity (map (partial g %2) w))) w)\n        i (fn i [g x k]\n            (if (= (count x) (count w))\n              true\n              (some identity (concat (map #(i g (conj x %) (apply disj (set(get g %)) x)) k)))))]\n  (not (nil? (i (apply hash-map (apply concat h)) #{} (map first h))))))","problem":82,"user":"5349ac2be4b084c2834f4a67"},{"code":"(fn g [ws]\n   (let [p (fn f [xs] \n                 (if (empty? xs) \n                   [[]]\n                   (mapcat \n                     #(map (fn [e] (conj e %))\n                           (f (remove (set [%]) xs))) xs)))\n         d (fn [[a b]]\n              (if (= (count a) (count b)) \n                (= (count a) (inc (count (filter identity (map = a b)))))\n                (let [x (sort-by count [a b])\n                      m (last x)\n                      ms (set (map #(concat (take % m) (drop (inc %) m)) (range (count m))))]\n                  (contains? ms (seq (first x))))))]\n    (not (apply = false (map #(apply = true (map d (partition 2 1 %))) (p ws))))))","problem":82,"user":"4fa30027e4b081705acca187"},{"code":"(fn [ws]\n  (letfn [(lev [s t]\n               (let [d (into [(vec (range 0 (inc (count s))))]\n                             (map #(vec (concat [%] (repeat (count s) 0)))\n                                  (range 1 (inc (count t)))))\n                     res (reduce (fn [d i]\n                                   (reduce (fn [d j]\n                                             (assoc-in d [i j]\n                                                       (if (= (get t (dec i)) (get s (dec j)))\n                                                         (get-in d [(dec i) (dec j)])\n                                                         (min (inc (get-in d [(dec i) j]))\n                                                              (inc (get-in d [i (dec j)]))\n                                                              (inc (get-in d [(dec i) (dec j)]))))))\n                                           d (range 1 (inc (count s)))))\n                                 d (range 1 (inc (count t))))]\n                 (get-in res [(count t) (count s)])))\n          (word-graph [& ws]\n                      (reduce (fn [g w]\n                                (let [xs (filter identity\n                                                 (map #(if (= 1 (lev w %)) % nil) ws))]\n                                  (assoc g w xs)))\n                              {} ws))\n          (dfs [node, visited, g]\n               (if (nil? node)\n                 (count visited)\n                 (apply max (concat [(inc (count visited))]\n                                    (map #(dfs % (conj visited node) g)\n                                         (filter (complement (set visited))\n                                                 (g node)))))))]\n    (let [g (apply word-graph ws)]\n      (= (count ws) (apply max (map #(dfs % [] g) ws))))))","problem":82,"user":"50f48298e4b004d364930527"},{"problem":82,"code":"(fn [words]\n    (letfn [\n            \n      (permutations [xs] \n        \"return all permutations of xs\"\n        (lazy-seq \n          (if (seq (rest xs)) \n            (apply concat \n              (for [x xs] \n                (map #(cons x %) \n                     (permutations (remove #{x} xs)))))\n            [xs])))\n          \n      (remove-at [s i]\n        \"return a vector of the string s with index i removed\"\n        (let [v (vec s)]\n           (concat \n             (subvec v 0 i)\n             (subvec v (inc i)))))\n           \n      (substrings [s]\n        \"return all substrings of s\"\n        (for [i (range (count s))] (remove-at s i)))\n          \n      (one-larger? [s1 s2]\n        \"true if s1 has one more letter than s2\"\n        (some (partial = (seq s2)) (substrings s1)))\n      \n      (differ-by-one? [s1 s2]\n        \"true if s1 and s2 differ by only one letter\"\n        (= 1 (count (filter identity (map not= s1 s2)))))\n          \n      (link? [[s1 s2]]\n        \"true if s1 and s2 are valid links in a word chain\"\n        (condp = (apply - (map count [s1 s2])) ;; find the larger word\n           0 (differ-by-one? s1 s2) ;; same length\n           1 (one-larger? s1 s2)\n          -1 (one-larger? s2 s1)\n             false))\n        \n      (chain? [words] \n        \"return true if every pair of words is a valid link in a chain\"\n        (every? link? (partition 2 1 words)))]\n          \n      \n      (boolean ;; test expects an explicit false\n        (some chain? (permutations words))))) ;; the actual function","user":"4fc4eb1ee4b081705acca354"},{"problem":82,"code":"(fn [x] (let [\n               cs (fn [a b] (loop [x a y b c 0]\n                              (cond (and (empty? x) (empty? y)) (= 1 c)\n                                    (empty? x) (recur x (rest y) (inc c))\n                                    (empty? y) (recur (rest x) y (inc c))\n                                    (= (first x) (first y)) (recur (rest x) (rest y) c)\n                                    (> (count x) (count y)) (recur (rest x) y (inc c))\n                                    (< (count x) (count y)) (recur x (rest y) (inc c))\n                                    :else (recur (rest x) (rest y) (inc c)))\n                              ))\n               re (fn [a b] (reduce #(if (cs a %2) (inc %1) %1) 0 b))\n               mp (reduce #(assoc %1 %2 (re %2 x)) {} x)\n               ]\n           (> 3 (count (filter (comp #{0 1} last) mp)))))","user":"5910a43de4b0163c97b36ebf"},{"code":"(fn word-chainable? [st]\n  (letfn\n    [(word-chops [word]\n      (let [x (count word)]\n        (map #(str (subs word 0 %) (subs word (inc %))) (range x))))\n    (chainable? [word1 word2]\n      (let [[small-word big-word] (sort-by count [word1 word2])\n           count-diff (- (count big-word) (count small-word))]\n        (cond\n          (> count-diff 1) false\n          (= count-diff 1) (contains? (set (word-chops big-word)) small-word)\n          :else (some true? (map #(= % %2) (word-chops word1) (word-chops word2))))))\n    (pairs-chainable? [coll]\n      (every? #(apply chainable? %) coll))\n(removenth [n coll]\n  (vec (concat (subvec coll 0 n) (subvec coll (inc n) (count coll)))))\n\n(step [[a b]]\n  (if (seq b)\n    (map-indexed #(vector (conj a %2) (removenth % b)) b)\n    [a]))\n\n(permutations [coll]\n  (loop [ret (vec (step (vector [] (vec coll)))) coll (vec coll)]\n    (if (seq coll)\n      (recur (vec (apply concat (map step ret))) (rest coll))\n      ret)))]\n      (not (not-any? true? (map pairs-chainable? (map #(partition 2 1 %) (permutations st)))))))","problem":82,"user":"5084c43be4b0fb8f40674bfa"},{"problem":82,"code":"(fn chainable? [x]\n  (let [fact (fn [x]\n              (let [f (fn [r x]\n                        (if (= x 1) r\n                          (recur (* r x) (dec x))))]\n                (f 1 x)))\n        perm (fn [x]\n\t\t\t  (let [v (vec (range 0 x))\n\t\t\t\t\ts (fn [x i j]\n\t\t\t\t\t\t(if (= i j) x\n\t\t\t\t\t\t (let [v1 (subvec x 0 i)\n\t\t\t\t\t\t\t   v2 (subvec x (inc i) j)\n\t\t\t\t\t\t\t   v3 (subvec x (inc j))\n\t\t\t\t\t\t\t   ith (nth x i)\n\t\t\t\t\t\t\t   jth (nth x j)]\n\t\t\t\t\t\t   (-> [] (into v1) (conj jth) (into v2) (conj ith) (into v3)))))\n\t\t\t\t\tpp (fn [n x]\n\t\t\t\t\t\t(let [mp (fn anon [l r n i]\n\t\t\t\t\t\t\t\t   (if (zero? n) [nil {}]\n\t\t\t\t\t\t\t\t\t (if (< n r)\n\t\t\t\t\t\t\t\t\t   (let [d (- n l)\n\t\t\t\t\t\t\t\t\t\t\t qdi (quot d i)]\n\t\t\t\t\t\t\t\t\t\t [qdi {i [qdi (rem d i)]}])\n\t\t\t\t\t\t\t\t\t   (let [di (dec i)\n\t\t\t\t\t\t\t\t\t\t\t v (anon r (* r i) n di)\n\t\t\t\t\t\t\t\t\t\t\t [q m] v\n\t\t\t\t\t\t\t\t\t\t\t e (m di)]\n\t\t\t\t\t\t\t\t\t\t (if (zero? q) v \n\t\t\t\t\t\t\t\t\t\t   (let [d (- q l)]\n\t\t\t\t\t\t\t\t\t\t\t (if (neg? d) v \n\t\t\t\t\t\t\t\t\t\t\t   (let [qdi (quot d i)]\n\t\t\t\t\t\t\t\t\t\t\t\t [qdi (conj m [i [qdi (rem d i)]])]))))))))]\n\t\t\t\t\t\t  (second (mp 1 x n (dec x)))))\n\t\t\t\t\tgp (fn [m v]\n\t\t\t\t\t\t(let [ks (reverse (sort (keys m)))\n\t\t\t\t\t\t\t  c (count v)\n\t\t\t\t\t\t\t  f (fn [ks v]\n\t\t\t\t\t\t\t\t  (if (empty? ks) v\n\t\t\t\t\t\t\t\t   (let [[k & rks] ks\n\t\t\t\t\t\t\t\t\t\t p (second (m k))\n\t\t\t\t\t\t\t\t\t\t i (dec (- c k))\n\t\t\t\t\t\t\t\t\t\t j (+ (inc i) p)]\n\t\t\t\t\t\t\t\t\t (recur rks (s v i j)))))]\n\t\t\t\t\t\t  (f ks v)))\n\t\t\t\t\tf (fact x)\n\t\t\t\t\tp (fn anon [n x]\n\t\t\t\t\t\t(if (>= n f) '()\n\t\t\t\t\t\t (let [m (pp n x)]\n\t\t\t\t\t\t   (lazy-seq (cons (gp m v) (anon (inc n) x)))\n\t\t\t\t\t\t   )))]\n\t\t\t\t(p 0 x)))\n        c? (fn [x y] ; zwei Wörter\n            (let [cx (count x)\n                  cy (count y)\n                  f (fn [n i x y]\n                      (if (empty? x) (= n (+ i (count y)))\n                        (if (> i n) false\n                         (let [[xh & xt] x\n                               [yh & yt] y\n                               b (= xh yh)\n                               j (if b i (inc i))]\n                           (if (or b (= cx cy))\n                             (recur n j xt yt)\n                             (recur n j xt y))))))\n                  as (sort #(compare (count %2) (count %1)) [x y])]\n              (apply f 1 0 as)))\n        wp (fn anon [p x]\n            (if (empty? p) '()\n             (let [[h & t] p\n                   wp (map (partial nth x) h)]\n               (lazy-seq (cons wp (anon t x))))))\n        sc? (fn [x]\n              (let [[f s] x\n                    r (rest x)]\n                (if (nil? s) true\n                  (if (not (c? f s)) false\n                    (recur r)))))\n        f (fn [wps]\n            (if (empty? wps) false\n             (let [[h & t] wps]\n               (if (sc? h) (do (println h) true)\n                 (recur t)))))\n        y (seq x)\n        p (perm (count x))\n        wps (wp p y)]\n    (f wps)))","user":"57d1d6c8e4b0bd073c202370"},{"code":"(let [\nsub? (fn [p n]\n  (= 1 (reduce + (map #(if (not= % %2) 1 0) p n))))\n\ndel? (fn [p n]\n  (if (= (first p) (first n))\n    (recur (rest p) (rest n))\n    (= (seq (rest p)) (seq n))))\n\none-away? (fn [p n]\n  (cond\n    (nil? p) true\n    (= (count p) (count n)) (sub? p n)\n    (= (dec (count p)) (count n)) (del? p n)\n    (= (inc (count p)) (count n)) (del? n p)\n    :else false))\n\nconnected? (fn c? [p s]\n  (if (empty? s)\n    true\n    (if (some #(and (one-away? p %) (c? % (disj s %))) s) true false)))]\n\n(fn [s] (connected? nil s)))","problem":82,"user":"4ec07699535dfed6da9c6da2"},{"code":"(fn has-chain [word-set]\n  (let [ws (seq word-set)\n        choices (fn [[acc l]]\n                  (map-indexed (fn [i x]\n                                 (let [[l r] (split-at i l)\n                                       remains (concat l (rest r))]\n                                   (vector\n                                    (conj acc x)\n                                    remains)))\n                               l))\n        perms (->> [[[] ws]]\n                   (iterate #(mapcat choices %))\n                   (drop-while #(-> % first second not-empty))\n                   first\n                   (map first)\n                   distinct)\n        distance #((fn f [errs a b]\n                    (cond\n                     (empty? a) (+ errs (count b))\n                     (empty? b) (+ errs (count a))\n                     (= (first a) (first b)) (f errs (rest a) (rest b))\n                     :else (min\n                            (f (inc errs) a (rest b)) ; b insertion\n                            (f (inc errs) (rest a) b) ; a insertion\n                            (f (inc errs) (rest a) (rest b)) ; point mutation\n                            ))) 0 (seq %) (seq %2))\n        is-chain? (fn [s]\n                    (every? (fn [[a b]] (< (distance a b) 2))\n                            (partition 2 1 s)))]\n    (not= nil (some is-chain? perms))))","problem":82,"user":"50d8f4b6e4b01f0871336e74"},{"code":"(fn [s]\n    (let [v (into [] s)\n          next? \n          (fn [a b] \n            (let [[x y] (sort-by count [a b])\n                  f (fn f[xs ys]\n                      (if (seq xs)\n                        (if (= (first xs) (first ys))\n                          (f (rest xs) (rest ys))\n                          (= (seq xs) (rest ys)))\n                        (= 1 (count ys))))]\n              (cond \n               (= (count x) (count y))\n               (= 1 (count (remove (fn [[l n]] (= l n)) (map vector x y))))\n               :else (f x y))))\n          make-paths (fn [prev-path]\n                       (for [x prev-path y (remove (set x) (range (count s)))]\n                         (conj x y)))\n          all-paths (->> (map vector (range (count s)))\n                         (iterate make-paths)\n                         (drop (dec (count s)))\n                         first)\n          valid? (fn [s] \n                   (every? (fn [[a b]] (next? (v a) (v b))) s))]\n      (boolean (some identity (map valid? (map #(partition 2 1 %) all-paths))))))","problem":82,"user":"53956118e4b0b51d73faaed6"},{"code":"(fn [words]\n    (let [substitution (fn [word other]\n                         (and (= (count word) (count other))\n                              (= 1 (count (remove identity (map = word other))))))\n          insertion (fn [word other]\n                      (let [[small long] (sort-by count [word other])]\n                        (and (= (inc (count small)) (count long))\n                             (->> (map vector\n                                       (concat small [:padding :padding])\n                                       (concat long [:padding]))\n                                  (drop-while (partial apply =))\n                                  (partition 2 1)\n                                  (map (fn [[[s _] [_ l]]] (= s l)))\n                                  (every? #{true})))))\n          neighbor? (memoize (fn [word other]\n                               (or (substitution word other)\n                                   (insertion word other)\n                                   (insertion other word))))\n          paths (fn paths [items]\n                  (condp = (count items)\n                      0 []\n                      1 [(seq items)]\n                      (mapcat (fn [item]\n                                (map (partial list* item)\n                                     (paths (remove #{item} items)))) items)))]\n      (or (some #(every? (partial apply neighbor?)\n                         (partition 2 1 %)) (paths words))\n          false)))","problem":82,"user":"4e6a0667535d8ccf87e9fe9e"},{"problem":82,"code":"(fn [vertices]\n (letfn\n  [(srt [w1 w2]\n     (sort #(< (count %1) (count %2))\n           [w1 w2]))\n   (rmv [w i]\n     (apply str (keep-indexed \n                  #(if (not= i %1) %2)\n                  w)))\n   (edge? [w1 w2]\n    (let [[v w] (srt w1 w2)]\n      (some true?\n        (map\n          #(let [rw (rmv w %)]\n             (or (= rw v)\n                 (= rw (rmv v %)))) \n          (range (count w))))))\n   (extend-path [p v]\n     (if (or (empty? p)\n             (and (empty?\n                    (filter\n                      #(= % v) p))\n                  (edge? (last p) v)))\n         (conj p v)))\n   (find-paths [vs paths]\n     (filter seq\n       (mapcat\n         (fn [p]\n           (map #(extend-path p %)\n                vs))\n         paths)))\n   (find-complete-paths [vs]\n     (first\n       (drop (count vs)\n         (iterate\n           (partial find-paths vs)\n           [[]]))))]\n   (not (empty? (find-complete-paths vertices)))))","user":"55d2dd27e4b0e31453f64a5b"},{"problem":82,"code":"(fn word-chain[words]\n  (let [\n        map-of-counts (fn [source f]\n          (let [source-map (group-by identity source)]\n            (into {} (for [[k v] source-map] [k (f v)]))))\n        diff-counts (fn [source target]\n          (let [source-map (map-of-counts source count)\n                target-map (map-of-counts target count)]\n            (merge-with - target-map source-map)\n            )\n          )\n        diff (fn [source target]\n          (let [merged-map (diff-counts source target)]\n            (apply + (vals merged-map))\n            ))\n        different-by-one (fn [word1 word2]\n          (let [s1 (count word1)\n                s2 (count word2)\n                r (diff word1 word2)]\n            (or (and (= s1 s2) (= 2 r))\n                (and (= 1 (Math/abs (- s1 s2))) (= 1 (Math/abs r))))\n            ))\n        all-different-by-one (fn [word1 words]\n          (filter #(different-by-one word1 %) words)\n          )\n        create-mappings (fn [words]\n          (into {} (for [word words] [word (all-different-by-one word words)]))\n          )\n        can-expand-chain (fn [mappings chain]\n          (let [last-word (last chain)\n                already-visited (set chain)\n                next-batch (filter #(and (not (already-visited %)) (not (= last-word %))) (mappings last-word))]\n            (not (empty? next-batch))\n            ))\n        expand-chain (fn [mappings chain]\n          (let [last-word (last chain)\n                already-visited (set chain)\n                next-batch (filter #(and (not (already-visited %)) (not (= last-word %))) (mappings last-word))]\n            (for [next next-batch]\n              (conj chain next)))\n          )\n        process (fn [mappings complete-chains incomplete-chains]\n          (let [split-chains (group-by #(can-expand-chain mappings %) incomplete-chains)\n                inprogress-chains (reduce #(concat %1 (expand-chain mappings %2)) [] (split-chains true))\n                completed-chains (concat complete-chains (split-chains false))]\n            (if (empty? inprogress-chains)\n              (> (count (filter #(= (count (set %)) (count (set (keys mappings)))) completed-chains)) 0)\n              (recur mappings completed-chains inprogress-chains))))\n        mappings (create-mappings words)\n        all-chains (map #(process mappings [] [[%]]) words)]\n    (boolean (some #(true? %) all-chains))))","user":"525d44bfe4b0cb4875a45d6d"},{"code":"(fn f [cur words]\n  (letfn [(difference [s1 s2]\n                      (let [score (fn [score-mem s1 s2]  ;pass memoized function as a parameter\n                                    (if(and (empty? s1) (empty? s2))\n                                      0\n                                      (min (if (and (not-empty s1) (not-empty s2))\n                                             (+ (if (not= (first s1) (first s2)) 1 0) (score-mem score-mem (next s1) (next s2)))\n                                             Integer/MAX_VALUE)\n                                           (if (not-empty s1)\n                                             (inc (score-mem score-mem (next s1) s2))\n                                             Integer/MAX_VALUE)\n                                           (if (not-empty s2)\n                                             (inc (score-mem score-mem s1 (next s2)))\n                                             Integer/MAX_VALUE))))\n        \n                            score-m (memoize score)]\n                        (score-m score-m (seq s1) (seq s2))))\n          \n          (similar [s1 s2] (<= (difference s1 s2) 1))]\n    (if (empty? words)\n      true\n      (boolean (some true? \n                     (map #(f % (filter (partial not= %) words))\n                                        (filter #(or (= cur \"\") (similar cur %)) words)))))))\n      \"\"","problem":82,"user":"5054bc87e4b0b1b9d1860eb0"},{"problem":82,"code":"(fn [words]\n  (let [distance_1? (fn [word1 word2]\n          (let [c1 (count word1) c2 (count word2)]\n            (loop [[h1 & t1 :as w1] word1 [h2 & t2 :as w2] word2 m 0]\n              (cond\n                (> m 1) false\n                (not (or h1 h2)) (= m 1)\n                (= h1 h2) (recur t1 t2 m)\n                (= c1 c2) (recur t1 t2 (inc m))\n                (> c1 c2) (recur t1 w2 (inc m))\n                :else (recur w1 t2 (inc m))))))]\n    (loop [[state & states] (list ['() words])]\n      (if (nil? state)\n        false\n        (let [[chain words-left] state\n              head (first chain)\n              words-fit (filter #(distance_1? head %) words-left)\n              create-state #(vector (cons % chain) (disj words-left %))]\n          (if (empty? words-left)\n            true\n            (recur (concat (map create-state (if head words-fit words-left)) states))))))))","user":"4faf97d8e4b081705acca258"},{"problem":82,"code":"(fn word-chain [s]\n  (letfn [(insert? [a b] (when ((deletations b) a) b))\n          (delete? [a b] (when ((deletations a) b) b))\n          (subst? [a b] (when (= 1 (count-diff-chars a b)) b))\n\n          (deletations [s]\n            (set (map (partial apply str)\n                      (map (partial remove-n s) (range (count s))))))\n          (remove-n [seq n]\n            (if (> n 0)\n              (cons (first seq) (remove-n (rest seq) (dec n)))\n              (rest seq)))\n          (count-diff-chars\n            ([a b] (count-diff-chars a b 0))\n            ([a b acc]\n               (if (some empty? [a b])\n                 (+ acc (count (concat a b)))\n                 (count-diff-chars (rest a) (rest b)\n                                   (if (= (first a) (first b))\n                                     acc (inc acc))))))\n          (perm [lst]\n            (if (empty? (rest lst))\n              (list lst)\n              (mapcat (fn [x]\n                        (map #(cons x %)\n                             (perm (remove (partial = x) lst))))\n                      lst)))\n          (f [seq]\n            (if (= 1 (count seq))\n              true\n              (and\n               (#(or (insert? % %2) (delete? % %2) (subst? % %2))\n                (first seq) (second seq))\n               (f (rest seq)))))]\n    (if (some f (perm (seq s))) true false)))","user":"546c1f73e4b00cfc9eacc175"},{"code":"(fn [words]\n   (letfn [(edges [word-list]\n             (->> word-list\n                  (reduce (fn [result word]\n                            (reduce\n                              (fn [target entries] (conj target entries))\n                              result\n                              (->> (map  (fn [word1 word2]\n                                           (let [difference (Math/abs (- (count word1) (count word2)))]\n                                             (if (> difference 1)\n                                               nil\n                                               (let [sorted (sort-by count [(seq word1) (seq word2)])\n                                                     words (same-length-words (first sorted) (second sorted))]\n                                                 (if (= (words :allowed-difference)\n                                                        (apply min (map  (fn [word other]\n                                                                           (apply + (map (fn [char1 char2]\n                                                                                           (if (= char1 char2) 0 1))\n                                                                                         word other)))\n                                                                        (repeat (words :word))\n                                                                        (words :other-words))))\n                                                   #{word1 word2})))))\n                                        (repeat word)\n                                        (disj word-list word))\n                                   (filter identity)))) #{})\n                  (into #{})))\n\n           (same-length-words [word1 word2]\n             (if (= (count word1) (count word2))\n               {:allowed-difference 1, :word word1, :other-words [word2]}\n               {:allowed-difference 0, :word word1\n                :other-words (map (fn [n] (remove-item n word2)) (range (count word2)))}))\n\n           (remove-item [n coll]\n             (let [v (vec coll)]\n               (concat (subvec v 0 n) (subvec v (inc n) (count coll)))))\n\n\n\n           (johnson-trotter\n             ([n] (johnson-trotter n (johnson-trotter-initial n)))\n             ([n permutation]\n              (if (nil? permutation)\n                nil\n                (cons permutation\n                      (lazy-seq (johnson-trotter n (johnson-trotter-next permutation)))))))\n\n           (johnson-trotter-initial [n]\n             (->> (range n)\n                  (map (fn [x] [x \"<\"]))\n                  (into [])))\n\n           (johnson-trotter-next [permutation]\n             (if (nil? permutation)\n               nil\n               (let [[max-value index next-index] (max-mobile permutation)]\n                 (if (> max-value -1)\n                   (->> (swap permutation index next-index)\n                        (change-directions max-value)\n                        (into []))\n                   nil\n                   ))))\n\n           (change-directions [max-value permutation]\n             (map (fn [[value direction]]\n                    [value\n                     (if (> value max-value)\n                       (if (= \"<\" direction) \">\" \"<\")\n                       direction)])\n                  permutation))\n\n           (swap [vctor index1 index2]\n             (assoc vctor index2 (vctor index1) index1 (vctor index2)))\n\n           (max-mobile [permutation]\n             (->> (map-indexed (partial mobile? permutation) permutation)\n                  (reduce\n                    (fn [[max-value max-index curr-next-index] [value index is-mobile next-index]]\n                      (if (and is-mobile (> value max-value))\n                        [value index next-index]\n                        [max-value max-index curr-next-index]\n                        ))\n                    [-1 -1 -1])))\n\n           (mobile? [permutation index [value direction]]\n             (let [is-mobile\n                   (if (= \"<\" direction)\n                     (and (> index 0) (< (first (permutation (dec index))) value))\n                     (and (< index (dec (count permutation))) (< (first (permutation (inc index))) value))\n                     )\n                   next-index\n                   (if (= \"<\" direction) (dec index) (inc index))]\n               [value index is-mobile next-index]))\n\n           (contains-chain? [words]\n             (let [edges (edges words)\n                   word-vector (vec words)]\n               (if (some\n                     (fn [permutation]\n                       (is-chain? word-vector (permutation-indices permutation) edges))\n                     (johnson-trotter (count words)))\n                 true\n                 false)))\n\n(permutation-indices [permutation]\n                     (map (fn [[index _]] index) permutation))\n\n(is-chain? [words sorting edges]\n           (let [possible-chain\n                 (reduce\n                   (fn [result index] (conj result (words index)))\n                   [] sorting)\n                 chain-edges (map #(into #{} %) (partition 2 1 possible-chain))]\n             (every? (fn [edge] (edges edge)) chain-edges)))\n]\n\n(contains-chain? words)\n))","problem":82,"user":"50ebd63ce4b04edc3377703c"},{"problem":82,"code":"(fn [words]\n    (let [chain?\n          (fn [w1 w2]\n            (let [compare (fn [w1 w2]\n                            (count (filter false? (map = w1 w2))))\n                  l1 (count w1) l2 (count w2)\n                  [small large] (if (< l1 l2) [w1 w2] [w2 w1])]\n              (cond\n                (= l1 l2) (<= (compare w1 w2) 1)\n\n                (= 1 (Math/abs (- l1 l2)))\n                (some #{0}\n                      (map\n                       (partial compare small)\n                       (map (fn [i]\n                              (->> (map vector (range) large)\n                                   (remove #(= (first %) i))\n                                   (map second)\n                                   (apply str)))\n                            (range (count large)))))\n\n                :else nil\n                )))\n          rows (repeat (count words) (into '() words))\n          chain (first\n                  (reduce (fn [ps cs]\n                            (for [p ps\n                                  c cs\n                                  :when (and (not (some #{c} p))\n                                             (chain? (last p) c))]\n                              (conj p c)))\n                          (map vector (first rows))\n                          (rest rows)))]\n      (if chain true false)))","user":"4f57c913e4b0a7574ea7183f"},{"problem":82,"code":"(letfn\n    [\n     (cmp [s1 s2]\n       (let [d (- (count s1) (count s2))]\n         (cond\n           (= d 0) (= 1 (count (remove identity (map #(= %1 %2) s1 s2))))\n           (= d -1) (= (filter (set (filter (set s1) s2)) s1) (seq s1))\n           (= d 1) (recur s2 s1)\n           :else false)))\n     \n     (tree [xs]\n       (->>\n        (for [s1 xs s2 xs] [s1 s2])\n        (filter #(apply cmp %))\n        (reduce #(update-in %1 [(first %2)] conj (second %2)) {})))\n     \n     (r1 [ks path result xs]\n       (if (seq ks)\n         (r1 (rest ks) path (r2 (first ks) path result xs) xs)\n         result))\n     \n     (r2 [k path result xs]\n       (cond\n         ((set path) k) (conj result path)\n         (xs k) (r1 (xs k) (conj path k) result xs)\n         :else (conj result (conj path k))))]\n  \n  (fn f[st]\n    (->>\n     (tree st)\n     (r1 st [] [])\n     (distinct)\n     (some #(= (count %) (count st)))\n     (= true))))","user":"56795deae4b05957ce8c6187"},{"problem":82,"code":"(fn [words]\n    (let\n      [\n        edit-distance\n        (fn edit-distance [a b]\n          (cond\n            (zero? (count a)) (count b)\n            (zero? (count b)) (count a)\n\n            :else\n            (let\n              [\n                rest-a (apply str (rest a))\n                rest-b (apply str (rest b))\n\n                cost-first-char\n                (if\n                  (= (first a) (first b))\n                  0\n                  1\n                )\n\n                alternative-1\n                (+\n                  (edit-distance rest-a rest-b)\n                  cost-first-char\n                )\n\n                alternative-2\n                (+\n                  (edit-distance rest-a b)\n                  1\n                )\n\n                alternative-3\n                (+\n                  (edit-distance a rest-b)\n                  1\n                )\n              ]\n              (min alternative-1 alternative-2 alternative-3)\n            )\n          )\n        )\n\n        next-word?\n        (fn [w1 w2]\n          (=\n            (edit-distance w1 w2)\n            1\n          )\n        )\n\n        word-sequence?\n        (fn word-sequence? [ws]\n          (if\n            (= (count ws) 1)\n            true\n            (if\n              (next-word? (first ws) (second ws))\n              (word-sequence? (rest ws))\n              false\n            )\n          )\n        )\n\n        words-vector (apply vector words)\n\n        permutations\n        (fn permutations [ws]\n          (lazy-seq\n            (if (seq (rest ws))\n              (apply concat\n                (for [x ws]\n                  (map\n                    #(cons x %)\n                    (permutations (remove #{x} ws))\n                  )\n                )\n              )\n              [ws]\n            )\n          )\n        )\n      ]\n      (not\n        (nil?\n          (first\n            (filter\n              word-sequence?\n              (permutations words-vector)\n            )\n          )\n        )\n      )\n    )\n  )","user":"5784e177e4b0ebec4cfb74cf"},{"code":"(fn q82 [ss]\n  (letfn [\n  \t(update-1? [s1 s2]\n\t\t  (= 1 (reduce + (map #(if (= % %2) 0 1) s1 s2))))\n\n\t\t\t(all-remove-1 [s]\n\t\t\t  (->>\n\t\t\t    (for [i (range (count s))] (remove #(= i %) (range (count s))))\n\t\t\t    (map #(replace (vec s) %))))\n\n\t\t\t(remove-1? [s1 s2]\n\t\t\t  (some #(= (seq s2) %) (all-remove-1 s1)))\n\n\t\t\t(insert-1? [s1 s2]\n\t\t\t  (remove-1? s2 s1))\n\n\t\t\t(transit? [s1 s2]\n\t\t\t  (let [l1 (count s1) l2 (count s2)]\n\t\t\t    (cond\n\t\t\t      (= l1 l2) (update-1? s1 s2)\n\t\t\t      (= l1 (inc l2)) (remove-1? s1 s2)\n\t\t\t      (= (inc l1) l2) (insert-1? s1 s2)\n\t\t\t      :else nil)))\n      \n\t\t\t(comb-2 [coll]\n\t\t\t  (when-first [ x coll ]\n\t\t\t    (concat (map #(vector x %) (rest coll)) (comb-2 (rest coll)))))\n\n\t\t\t(transits [coll]\n\t\t\t  (reduce\n\t\t\t    (fn [m [s1 s2]]\n\t\t\t      (if (transit? s1 s2)\n\t\t\t        (assoc m s1 (conj (m s1) s2) s2 (conj (m s2) s1))\n\t\t\t        m\n\t\t\t      ))\n\t\t\t    {} (comb-2 coll)))\n\n\t\t\t(paths \n\t\t\t  ([m p n]\n\t\t\t\t  (if (some #(= n %) p) [p]\n\t\t\t\t    (mapcat #(paths m (conj p n) %) (m n))))\n\t\t\t  ([m] (mapcat #(paths m [] %) (keys m)))) ]\n         \n\t\t  (let [num-nodes (count ss)]\n\t\t    (if (some #(= num-nodes (count %)) (paths (transits ss))) true false))))","problem":82,"user":"4fd22e70e4b04c3a95aa041c"},{"problem":82,"code":"(fn [l]\n   (letfn [(f [d x y]\n      (cond\n       (or (empty? x) (empty? y)) (>= d (+ (count x) (count y)))\n       (= (first x) (first y)) (f d (rest x) (rest y))\n       (= 0 d) false\n       :else (or (f (dec d) (rest x) (rest y))\n                 (f (dec d) x (rest y))\n                 (f (dec d) (rest x) y))))]\n     (let [edges (set (for [x l y l :when (and (not= x y) (f 1 (seq x) (seq y)))] [x y]))]\n     (true?\n      ((fn ff [selected rest]\n        (cond\n         (empty? rest) true\n         :else (some identity\n                      (for [q rest :when (or (empty? selected) (edges [(last selected) q]))]\n                        (ff (conj selected q) (remove #(= q %) rest))\n                              ))\n         ))\n      [] l))\n   )))","user":"53f6d555e4b0db01ade6f9e5"},{"code":"#(let [\n  connected\n  (fn connected [x y]\n    (let [[longer shorter] (if (> (count y) (count x)) [y x] [x y])]\n      (cond \n        (> (Math/abs (- (count x) (count y))) 1) false\n        (= x y) true\n        (= (seq shorter) (rest longer)) true\n        (= (first x) (first y)) (connected (rest x) (rest y))\n        (= (rest x) (rest y)) true\n        )\n        )\n      \n    )\n  \n  \n  edges \n  (fn [v]\n    (for [x v y v :when (and (not= x y) (connected x y))] [x y])) \n  \nmaximal-chains\n  (fn [e]\n    (loop [acc e prev []]\n;      (println \"acc = \" acc)\n      (cond \n        (empty? acc) prev\n        (= prev acc) acc\n        :else\n        (recur (for [[x & u] acc [y z] e :when (and (= x z) (not-any? #{y} u))] (apply vector (concat [y z] u))) acc))))\n        ]\n        \n(= (count %) (count (first (maximal-chains (edges %))))))","problem":82,"user":"503917a0e4b088a6a14ca763"},{"problem":82,"code":"(fn is-word-chain? [ws]\n          (let [diff1 (fn diff1 [s1 s2]\n                        #_(println \"diff1: s1=\" s1 \"s2=\" s2)\n                        (let [cnt1 (count s1)\n                              cnt2 (count s2)]\n                          (if (> (count s1) (count s2))\n                            (diff1 s2 s1)\n                            (let [\n                                  cnt (->> (map vector s1 s2)\n                                           (take-while (fn [[c1 c2]] (= c1 c2)))\n                                           count)\n                                  s1' (drop (if (= cnt1 cnt2) (inc cnt) cnt) s1)\n                                  s2' (drop (inc cnt) s2)]\n                              #_(println \"diff1: s1'=\" s1' \"s2'=\" s2')\n                              (= s1' s2')))))\n                word-chains (fn word-chains\n                              ([word ws]\n                               #_(println \"word=\" word \"ws=\" ws)\n                               (if (empty? ws)\n                                 ['()]\n                                 (mapcat (fn [w]\n                                           #_(println \"word=\" word \"w=\" w)\n                                           (if-not (empty? ws)\n                                             (if (diff1 word w)\n                                               (let [wc (word-chains w (remove #{w} ws))]\n                                                 #_(println \"ws=\" ws \"w=\" w \"wc=\" wc)\n                                                 (map (partial cons w) wc))))) ws)))\n                              ([ws]\n                               (mapcat (fn [w]\n                                         (map (partial cons w) (word-chains w (remove #{w} ws)))) ws)))\n                all-combination (word-chains ws)]\n            (not (empty? all-combination))))","user":"58949f8de4b00487982d525e"},{"problem":82,"code":"(fn chainable-seq-exists?\n  ([coll] (reduce #(or %1 (chainable-seq-exists? %2 coll)) false coll))\n  ([word coll] (let [chainable-pair? (fn chainable-pair?\n                                       ([a b] (chainable-pair? a b 0))\n                                       ([a b changes] (cond (or (> changes 1) (> (Math/abs (- (count a) (count b))) 1)) false\n                                                            (or (empty? a) (empty? b)) true\n                                                            (= (first a) (first b)) (recur (rest a) (rest b) changes)\n                                                            (> (count a) (count b)) (recur (rest a) b (inc changes))\n                                                            (< (count a) (count b)) (recur a (rest b) (inc changes))\n                                                            :else (recur (rest a) (rest b) (inc changes)))))\n                     rem-words (disj coll word)\n                     pos-next-words (set (filter (partial chainable-pair? word) rem-words))]\n                 (cond (empty? rem-words) true\n                       (empty? pos-next-words) false\n                       :else (reduce #(or %1 (chainable-seq-exists? %2 rem-words)) false pos-next-words)))))","user":"5396c94be4b0b51d73faaee3"},{"code":"(letfn [(diff1? [xs ys]\r\n            (let [xs (seq xs) [x & rxs] xs ys (seq ys) [y & rys] ys]\r\n              (cond (and (nil? xs) (nil? ys)) false\r\n                    (= x y) (diff1? rxs rys)\r\n                    true (or (= rxs rys) (= rxs ys) (= xs rys)))))\r\n          (candidates [difflist words]\r\n            (map #(vector (conj difflist %) (disj words %))\r\n                 (if (empty? difflist) words\r\n                   (filter #(diff1? % (first difflist)) words))))\r\n          (chains? [difflist words]\r\n            (if (empty? words) true\r\n              (let [next-cands (candidates difflist words)]\r\n                (if (empty? next-cands) false\r\n                  (some #(apply chains? %) next-cands)))))]\r\n    (fn word-chains? [words]\r\n      (boolean (chains? nil words))))","problem":82,"user":"4dfd4ba8535d04ed9115e781"},{"code":"(fn [sw]\n  (let [f #(cond (apply = (map count %))\n                 (= 1 (loop [c 0 ws %]\n                        (if (-> ws first seq)\n                          (recur (if (apply = (map first ws))\n                                   c (inc c))\n                                 (map rest ws))\n                          c)))\n                 (= -1 (apply - (sort (map count %))))\n                 (loop [b (first %) s (second %)]\n                   (if (apply < (map count [b s]))\n                     (recur s b)\n                     (loop [s s b b c 0]\n                       (cond (and (seq s) (seq b))\n                             (if (= (first s) (first b))\n                               (recur (rest s) (rest b) c)\n                               (recur s (rest b) (inc c)))\n                             (seq b) (recur s (rest b) (inc c))\n                             (seq s) false\n                             :else (= c 1)))))\n                 :else false)]\n         (->> (map (fn [w] (->> (map (fn [o] [w o]) (disj sw w))\n                             (map f) (filter #{true}) count))\n                   sw)\n           (filter #(> % 1)) count (<= (- (count sw) 2)))\n    ))","problem":82,"user":"4f1bb9d8535d64f60314647d"},{"code":"(fn [c]\n        (let [cv (fn [x y]\n                  (let [a (count x)  b (count y) \n                        [L S] (if (> a b) [x y] [y x])]\n                    (cond \n                      (> (Math/abs (- a b)) 1) false\n                      (= a b) (= 1 (count (filter false? (map #(= % %2) x y))))\n                      :else   (if (= (seq S) (drop-last L))\n                                 true\n                                 (let [idif (some (fn [[v i]] (if v nil i))\n                                                  (map (fn [p q i] [(= p q) i])\n                                                        L S (range)))\n                                       S2 (concat (take (inc idif) L) (drop idif S)) ]\n                                   (= L (apply str S2)))))))             \n              \n              G   (let [V (vec c), n (count c)]    \n                     (for [x (range n) y (range (inc x) n) \n                           :let [A (V x) B (V y)]\n                           :when (cv A B)]                                                \n                            [A B] ))\n              P (atom (into {} (map #(vector % 0) c))) \n              \n              degs (fn [g] (into {} (map (fn [v] \n                           [v (count ((group-by (fn [e] (some #(= v %) e)) g) true) )]) \n                           c )))\n              \n              nx   (fn [g nu] \n                     (let [[s _] (reduce (fn [[i m] [v d]] \n                                            (if (< d m) [v d] [i m]) ) \n                                         [:_ Long/MAX_VALUE] \n                                         (filter (fn [[k v]] (nu k)) (degs g))) ]\n                          s))\n              \n              nn (fn [v g]    \n                   (into #{} (reduce (fn [s [a b]] \n                                      (cond (= a v) (if (= (@P b) 0) (conj s b) s)\n                                            (= b v) (if (= (@P a) 0) (conj s a) s)\n                                            :else s))\n                                     [] g)))\n              trav (fn go [v g]\n                     (swap! P assoc v 1) \n                     (let [nu (if (< 0 (count g)) (nn v g) []) \n                           w  (if (< 0 (count nu)) (nx g nu))]\n                        (if w\n                            (go w (filter (fn [[a b]]\n                                              (and (not= a v) (not= b v))) g) ))))]\n              (trav (nx G c) G)\n              (if (some #(= 0 (last %)) @P)\n                  false\n                  true)))","problem":82,"user":"4ee7d177535d93acb0a6686f"},{"code":"(letfn [\n    (dis [x1 x2] (cond \n        (= 0 (count x1)) (count x2)\n        (= 0 (count x2)) (count x1)\n        true (apply min (remove nil? [\n            (inc (dis (rest x1) (rest x2)))\n            (inc (dis x1 (rest x2)))\n            (inc (dis (rest x1) x2))\n            (when (= (first x1) (first x2)) (dis (rest x1) (rest x2)))]))))\n    (begin-chain [x] (cond\n        (= 1 (count x)) [(first x)]\n        true (for [i x :when (seq (filter #(> 2 (dis i %)) (begin-chain (disj x i))))] i)))\n    (is-chain [x] (boolean (seq (begin-chain x))))] is-chain)","problem":82,"user":"51cbdee1e4b08d8387cbede1"},{"code":"(fn word-chain [words]\n  (letfn [(next? [word-c word-n]\n                 (case (- (count word-c) (count word-n))\n                   1 (true? (some #(= (seq word-n) %)\n                                  (map #(concat (take % word-c) (next (drop % word-c)))\n                                       (range (count word-c)))))\n                   -1 (true? (some #(= (seq word-c) %)\n                                   (map #(concat (take % word-n) (next (drop % word-n)))\n                                        (range (count word-n)))))\n                   0 (= 1 (count (filter false? (map #(= %1 %2) word-c word-n))))\n                   false))\n          (chain [word searched-words words]\n                 (let [next-words (filter #(and (next? word %)\n                                                (nil? (searched-words %)))\n                                          words)]\n                   (println word searched-words next-words words)\n                   (if (seq next-words)\n                     (true? (some #(chain % (set (cons % searched-words)) words) next-words))\n                     (= (count searched-words) (count words)))))]\n    (true? (some #(chain % #{%} words) words))))","problem":82,"user":"52a55adee4b0c58976d9abe7"},{"code":"(letfn [(leven [[fa & ra :as a] [fb & rb :as b]]\n          (cond (nil? a) (count b)\n                (nil? b) (count a)\n                (= fa fb) (leven ra rb)\n                :else (+ 1 \n                        (min (leven ra rb)\n                             (leven a rb)\n                             (leven ra b)))))\n        (rem-disj [ht e]\n          [(dissoc ht e) (ht e)])\n        (walkable? [[ht elts]]\n          (if (empty? ht) \n            true\n            (let [walks (for [n-e elts :when (ht n-e)] \n                          (walkable? (rem-disj ht n-e)))]\n              (some true? walks))))]\n  (fn [st]\n    (let [ht (apply merge-with concat\n                (for [a st, b st :when (= 1 (leven a b))] {a [b]}))]\n      (or (some #(walkable? (rem-disj ht %)) st)\n          false))))","problem":82,"user":"4fb1d907e4b081705acca282"},{"code":"(fn [s]\n(letfn [(ch? [s1 s2]\n            (loop [[a & b :as c] (seq s1) [d & e :as g] (seq s2)]\n              (if (= a d) (recur b e)\n                (or (= b e) (= b g) (= c e)))))\n          (t [e s] (if (empty? s) true (some #(t % (disj s %)) (filter #(ch? e %) s))))]\n  (if (some #(t % (disj s %)) s) true false)))","problem":82,"user":"4fdb02aae4b05e33b9224f56"},{"code":"(fn [words] \n   (let [n (count words)\n         m (vec (map vec (partition n (map #(if (= 1 %) 1 0) (for [a words b words]\n     ((fn [s t] \n        ((fn f [j r] \n           (let [d (cons j r)\n                 w (map #(list % %2 %3) s d r)\n                 z (if (< j (count t)) (reduce #(conj % (if (= (first %2) (nth t j)) (second %2) (min (inc (second %2)) (inc (last %2)) (inc (last %))))) [(inc j)] w) d)]\n             (if (= j (count t)) (last z) (f (inc j) (rest z))))) 0 (range 1 (inc (count s))))) a b))))))\n         c (fn [m1 m2 y x] (reduce + (map * (map #(nth (nth m1 y) %) (range n)) (map #(nth (nth m2 %) x) (range n)))))\n         mul (fn [m1 m2] (for [y (range n)] (for [x (range n)] (c m1 m2 y x))))\n         h (partition n (for [i (range n) j (range n)] (if (< j i) 0 (if (= j i) 1 (get-in m [i j])))))]\n      (= n (count (filter #{n} (flatten ((fn s [x y] (if (= 1 x) y (mul y (s (dec x) h)))) n h)))))))","problem":82,"user":"4eb13d60535d7eef3080733f"},{"code":"(fn [words]\r\n    (letfn [(edit-dist [w1 w2]\r\n      (letfn [(build-matrix [w1 w2]\r\n                (let [rows (inc (count w1))\r\n                      cols (inc (count w2))]\r\n                  (let [matrix (vec (conj\r\n                                     (map (fn [i] (vec (conj (repeat (dec cols) nil) i))) (range 1 rows))\r\n                                     (vec (range cols))))]\r\n                    matrix)))\r\n              (char-cost [row col]\r\n                (if (= (get w1 row)\r\n                       (get w2 col)) 0 1))\r\n              (min-cost [m i j]\r\n                (min\r\n                 (+ (get-in m [(dec i) (dec j)]) (char-cost (dec i) (dec j)))\r\n                 (inc (get-in m [(dec i) j]))\r\n                 (inc (get-in m [i (dec j)]))))\r\n              (fill-entry [m i j]\r\n                (assoc-in m [i j] (min-cost m i j)))\r\n              (addr-fill-entry [m addr]\r\n                (fill-entry m (first addr) (second addr)))\r\n                ; Every 2-combination or pairwise combination of a list\r\n              (edit-dist-matrix [w1 w2]\r\n                (let [matrix (build-matrix w1 w2)]\r\n                  (reduce addr-fill-entry matrix\r\n                          (for [row (range 1 (inc (count w1)))\r\n                                col (range 1 (inc (count w2)))] [row col]))))]\r\n        (get-in (edit-dist-matrix w1 w2) [(count w1) (count w2)])))\r\n            (combinations [l]\r\n              (reduce conj #{}\r\n                      (for [x l y l :while (not= x y)] (hash-set x y))))\r\n            (hamiltonian-circuit? [g]\r\n              (letfn [(my-merger [coll1 coll2]\r\n                        (merge-with clojure.set/union coll1 coll2))\r\n                      (add-to-map [coll key val]\r\n                        (my-merger {key val} coll))\r\n                      (add-to-path [m]\r\n                        (zipmap (map second m) (map #(list (first %)) m)))\r\n                      (rotate [l]\r\n                        (concat (rest l) (list (first l))))\r\n                      (all-queues [queue]\r\n                        (take (count queue) (iterate rotate queue)))\r\n                      (all-visited? [gr visited]\r\n                        (= (set visited) (set (keys gr))))\r\n                      (bfs-search [init-map q]\r\n                        (loop [queue q visited '()]\r\n                            (if (all-visited? init-map visited)\r\n                              true\r\n                            (if-let [head (first queue)]\r\n                              (let [source (first head)\r\n                                    dests (second head)]\r\n                                (if-let [val (some #{source} visited)]\r\n                                  ; we've already visited the head node\r\n                                  (recur (rest queue) (rest visited))\r\n                                  ; new head node, never visited\r\n                                  (if-let [dest (first dests)]\r\n                                    ; new head node, possible destinations\r\n                                    (recur\r\n                                     (conj\r\n                                      (conj (rest queue)\r\n                                            (list source (rest dests)))\r\n                                      (list dest (get init-map dest)))\r\n                                     (conj visited source))\r\n                                        ; new head node, no destinations\r\n                                    (recur (rest queue) (rest visited)))))\r\n                                     ;(recur\r\n                                     ; (conj (rest queue)\r\n                                     ;       (list source (rest dests)))\r\n                                     ; (conj visited source))))))\r\n                                        ; empty queue\r\n                              (all-visited? init-map visited)))))]\r\n                (let [init-map (reduce my-merger (map #(hash-map\r\n                                                        (first %) (hash-set (second %))\r\n                                                        (second %) (hash-set (first %))\r\n                                                        ) g))]\r\n                  ;(map #(bfs-search init-map (list (list (first %) (get init-map (first %))))) (all-queues (keys init-map))))))]\r\n                  (not-every? false? (map #(bfs-search init-map (list (list (first %) (get init-map (first %))))) (all-queues (keys init-map)))))))]\r\n                                        ;      (edit-dist \"hot\" \"cat\"))))\r\n      (hamiltonian-circuit? (map seq (filter #(= (edit-dist (first %) (second %)) 1) (combinations words))))))","problem":82,"user":"4f039524535dcb61093f6b2c"},{"problem":82,"code":";the core feature of this solution is an algorithm which gives 'true' for two strings if they can be chained according to the definition given in the koan.\n;The function 'chained?' below does this. Then we create a graph and recycle some of what we wrote for \"graph tour\":\n;First of all the graph must be connected. Second is the necessary condition that not more than two nodes are of degree 1. Otherwise there is no path through the graph\n;which connects all edges. Necessary, but not necessarily sufficient. It does for the provided test cases and I could not produce a test case which would falsely fail.\n;This is a problem worthwhile to come back to later.\n;\n\n#(letfn [\n          (nth-removed [s m]\n          \"return the collection with the n-th char removed\"  \n            (for [n (range (count s)) :when(not= n m)] (nth s n)))\n\n          (eq-but-one? [s t equal-len?]\n            (if (empty? t)\n              (not equal-len?)\n              (if (=(first s)(first t))\n                (eq-but-one? (rest s) (rest t) equal-len?)\n                (if equal-len?\n                  (= (rest s) (rest t))\n                  (= (rest s) (take (count t) t))))))\n\n          (chained? [s t]\n          \"test if s and t are chained\"\n            (if (= s t)\n              false    ; don't accept equality\n              (case (- (count s) (count t))\n               -1  (chained? t s)   ; from here on len s >= len t\n                0  (eq-but-one? s t true)\n                1  (eq-but-one? s t false)\n                   false       ; s and t can't be chained if their lengths differ by more than one  \n              )))\n\n          (create-connections[s coll]\n          \"create a list of strings from coll which can be chained with s\"\n            (for [c coll :when(chained? s c)] [s c]))\n\n          (create-graph[coll]\n          \"create the full graph of chainable string pairs\"\n            (loop [c coll ret []]\n              (if (empty? c)\n                ret\n                (recur (rest c) (into ret (create-connections (first c) (rest c)))))))\n          \n          (followers[graph node nodes]\n          \"return all edges directly connected with node which are in the given set of nodes\"\n            (for [[a b] graph :when(and (= node a) (not (nil? (nodes b))))] b))\n          \n          (connected [foll nodes graph]\n          \"test if the graph is connected and get the degrees of the nodes\"\n            (loop [succ foll ret nodes deg []]\n              (if (or (empty? succ) (empty? ret) (nil? (some ret succ)))\n                [ret deg]\n                (let [nd (first succ) succ-of-node (followers graph nd nodes)]\n                  (recur\n                    (distinct (concat (rest succ) succ-of-node (followers graph nd ret)))\n                    (set (remove (fn[x](= nd x)) ret))\n                    (if (< (count succ-of-node) 2)\n                      (cons (count succ-of-node) deg)\n                       deg))))))\n         ]\n   \n    (let [\n          coll (create-graph %)\n          graph (concat coll (map reverse coll))\n          nodes (reduce (fn[cset [a b]] (conj cset a b)) #{} coll)\n          succ (followers graph (first nodes) (set (rest nodes)))\n          res (connected succ nodes graph)\n         ]\n      (and (empty? (first res)) (<= (count (second res)) 2))  ;is graph connected and are there no more than 2 edges with only one successor\n    )\n)","user":"545537c1e4b0e397800069dd"},{"problem":82,"code":"(fn is-word-chain2? [s]\n\t(let [  next-perm (fn [s]\n\t\t\t\t\t\t(let [v (vec s)\n\t\t\t\t\t\t\tfind-pivot (fn [v]\n\t\t\t\t\t\t\t\t\t\t\t(let [n (-> v count dec)]\n\t\t\t\t\t\t\t\t\t\t\t\t(loop [i (dec n), pivot nil]\n\t\t\t\t\t\t\t\t\t\t\t\t\t(if (or (neg? i) (not= pivot nil))\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t{:pivot pivot :idx (if (nil? pivot) i (inc i))}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t(recur\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(dec i)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(let [ei (v i)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  ri (v (inc i))]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  (if (neg? (compare ei ri)) ei nil)))\n\t\t\t\t\t\t\t\t\t\t\t\t))))\n\t\t\t\t\t\t\tfind-successor\t(fn [v pivot]\n\t\t\t\t\t\t\t\t\t\t\t\t(let [n (-> v count dec)]\n\t\t\t\t\t\t\t\t\t\t\t\t\t(loop [i n]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t(let [e (v i)]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(if (pos? (compare e (pivot :pivot)))\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t{:successor e, :idx i}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(recur (dec i))\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)))))\n\t\t\t\t\t\t\tswap\t\t\t(fn [v i1 i2]\n\t\t\t\t\t\t\t\t\t\t\t\t(let [e1 (v i1)\n\t\t\t\t\t\t\t\t\t\t\t\t\t  e2 (v i2)]\n\t\t\t\t\t\t\t\t\t\t\t\t\t  (assoc (assoc v i1 e2) i2 e1)))\n\t\t\t\t\t\t\treverse-from \t(fn [v start]\n\t\t\t\t\t\t\t\t\t\t\t\t(let [l (subvec v 0 start)\n\t\t\t\t\t\t\t\t\t\t\t\t\t  r (subvec v start)\n\t\t\t\t\t\t\t\t\t\t\t\t\t  rev-r (reverse r)]\n\t\t\t\t\t\t\t\t\t\t\t\t\t  (flatten (conj l rev-r))\n\t\t\t\t\t\t\t\t\t\t\t\t\t))\n\t\t\t\t\t\t\tpivot   (find-pivot v)]\n\t\t\t\t\t\t\t(if (nil? (pivot :pivot))\n\t\t\t\t\t\t\t\t(reverse v)\n\t\t\t\t\t\t\t\t(let [successor (find-successor v pivot)\n\t\t\t\t\t\t\t\t      p-idx (pivot :idx)\n\t\t\t\t\t\t\t\t      s-idx (successor :idx)  \n\t\t\t\t\t\t\t\t\t  swaped (swap v p-idx s-idx)]\n\t\t\t\t\t\t\t\t\t  (reverse-from swaped (inc p-idx))\n\t\t\t\t\t\t\t\t))))\t\n\t\t\tare-words-connected? (fn [word1 word2]\n\t\t\t\t\t\t\t\t\t(let [\tis-substitution? (fn [word1 word2]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(loop [w1 (seq word1) \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   w2 (seq word2)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   diff-chars 0]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(if (empty? w1)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(= 1 diff-chars)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(let [c1 (first w1)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  c2 (first w2)]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  (recur\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  \t(rest w1)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  \t(rest w2)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  \t(if (not= c1 c2) (inc diff-chars) diff-chars))\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t))))\n\t\t\t\t\t\t\t\t\t\t\tis-deletion-or-insertion? (fn [word1 word2]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(let [w1 (vec word1)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  w2 (vec word2)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  n1 (count w1)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  n2 (count w2)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  longer  (if (> n1 n2) w1 w2)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  shorter (if (> n1 n2) w2 w1)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  proc-chars (fn [shorter longer]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(loop [shor shorter, result []]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(if (empty? shor)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tresult\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(let [c (first shor)]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(recur (rest shor) (conj result (.indexOf longer c)))\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t))))\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  are-chars-ok? (fn [idxs]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(if (some neg? idxs)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfalse\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(loop [idx1 idxs, result []]\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(if (empty? idx1)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(let [trouble (count (filter #(or (neg? %) (> % 1)) result))]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(or (= 0 trouble) (= 1 trouble)))\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(let [i (first idx1)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  ni (if (= 1 (count idx1)) nil (-> idx1 rest first))]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(recur\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(rest idx1)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(if (nil? ni) result (conj result (- ni i)))\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t))))))]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(are-chars-ok? (proc-chars shorter longer))\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  ))\n\t\t\t\t\t\t\t\t\t\t\tn1  (count word1)\n\t\t\t\t\t\t\t\t\t\t\tn2  (count word2)\n\t\t\t\t\t\t\t\t\t\t\tn   (Math/abs (- n1 n2))]\n\t\t\t\t\t\t\t\t\t\t\t(cond\n\t\t\t\t\t\t\t\t\t\t\t\t(= 0 n) (is-substitution? word1 word2)\n\t\t\t\t\t\t\t\t\t\t\t\t(= 1 n) (is-deletion-or-insertion? word1 word2)\n\t\t\t\t\t\t\t\t\t\t\t\t:default false)\n\t\t\t\t\t\t\t\t\t))\n\t\t\tprepare-seq\t\t(fn [v]\n\t\t\t\t\t\t\t\t(let [sv (subvec v 1 (dec (count v)))]\n\t\t\t\t\t\t\t\t\t(loop [sv1 sv, result [(first v)]]\n\t\t\t\t\t\t\t\t\t\t(if (empty? sv1)\n\t\t\t\t\t\t\t\t\t\t\t(partition 2 (conj result (last v)))\n\t\t\t\t\t\t\t\t\t\t\t(recur \n\t\t\t\t\t\t\t\t\t\t\t\t(rest sv1) \n\t\t\t\t\t\t\t\t\t\t\t\t(conj result (first sv1) (first sv1))\n\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t))))\t\n\t\t\tis-connected?\t(fn [s]\n\t\t\t\t\t\t\t\t(loop [s1 s, result #{}]\n\t\t\t\t\t\t\t\t\t(if (empty? s1)\n\t\t\t\t\t\t\t\t\t\t(and (= 1 (count result)) (true? (first result)))\n\t\t\t\t\t\t\t\t\t\t\t(let [w1 (-> s1 first first)\n\t\t\t\t\t\t\t\t\t\t\t\t  w2 (-> s1 first last)\n\t\t\t\t\t\t\t\t\t\t\t\t  connected (are-words-connected? w1 w2)]\n\t\t\t\t\t\t\t\t\t\t\t\t(recur (rest s1) (conj result connected))\n\t\t\t\t\t\t\t\t\t\t\t))))\n\t\t\tv (vec (sort s))]\n\t\t(loop [v1 (next-perm v)]\n\t\t\t(if (= v1 v)\n\t\t\t\tfalse\n\t\t\t\t(if (is-connected? (prepare-seq (vec v1)))\n\t\t\t\t\ttrue\n\t\t\t\t\t(recur (next-perm v1) ))))\n\t\t))","user":"52cf084ce4b07d0d72b27399"},{"problem":82,"code":"(fn problem-82 [words]\n  (let [off-by-one? (fn off-by-one? [[first-letter1 & remain1] [first-letter2 & remain2 :as s2]]\n                      (cond\n                        (nil? first-letter2) true\n                        (= first-letter1\n                           first-letter2)    (off-by-one? remain1 remain2)\n                        :else                (every? identity (map = remain1 s2))))\n\n        inserted? (fn [s1 s2]\n                    (and (= (count s1)\n                            (inc (count s2)))\n                         (off-by-one? s1 s2)))\n        deleted? (fn [s1 s2]\n                   (inserted? s2 s1))\n        \n        substituted? (fn [s1 s2]\n                       (and (= (count s1) (count s2))\n                            (= 1 (count (filter false? (map = s1 s2))))))\n\n        connected? (fn [s1 s2]\n                     (not (every? false? (map #(% s1 s2)\n                                              [inserted? deleted? substituted?]))))\n        all-permutations (fn [xs]\n                           (let [x (into [] xs)]\n                             (map #(take (count x) (drop % (cycle x))) (range (count x)))))\n\n        traverse-tree (fn traverse-tree [[x & xs]]\n                        (if (empty? xs)\n                          true\n                          (for [y (all-permutations xs)]\n                            (when (connected? x (first y))\n                              (traverse-tree y)))))]\n    (let [x (flatten (map traverse-tree (all-permutations words)))]\n      (not (every? nil? x)))))","user":"5c896f46e4b048ec896c5940"},{"code":"(fn wc [s]\n  (let [neighbor (fn [a b]\n                   (let [su (fn su [a b]\n                              (let [i (interleave a b)\n                                    p (partition 2 i)\n                                    f (fn [v] (= (first v) (last v)))\n                                    m (map f p)\n                                    d (filter false? m)\n                                    c (count d)]\n                                (= c 1)))\n                         de (fn de [a b]\n                              (let [c (count a)]\n                                (loop [i 1]\n                                  (if (= i (inc c))\n                                    false\n                                    (if (= (seq b) (concat (take (dec i) a) (drop i a)))\n                                      true\n                                      (recur (inc i)))))))]\n                     (or (su a b)\n                         (de a b)\n                         (de b a))))\n        p (into #{}(for [i s\n                         j s\n                         :when (not= i j)]\n                     #{i j}))\n        f (set (filter #(neighbor (first %) (last %)) p))\n        gc (fn gc [s]\n             (let [f (first s)\n                   filt (fn [x s]\n                          (let [f (fn [v]\n                                    (cond\n                                     (= (first x) (first v)) v\n                                     (= (first x) (last v)) v\n                                     (= (last x) (first v)) v\n                                     (= (last x) (last v)) v\n                                     :else nil))]\n                          (map f s)))]\n               (loop [r #{f}\n                      pr #{}]\n                 (if (= (count r) (count pr))\n                   (= r s)\n                   (recur (clojure.set/union r (disj (apply clojure.set/union\n                                                     (for [x r]\n                                                       (into #{} (filt x s))))\n                                               nil))\n                          r)))))]\n    (if (not= (reduce clojure.set/union f)\n              s)\n      false\n      (loop [f f\n             l '()]\n        (if (gc f)\n          (if (= 2 (count f))\n            true\n            (let [fre (frequencies (reduce concat (map seq f)))\n                  fre1 (if (empty? l) fre (apply (partial assoc fre) (interleave l (repeat 1))))\n                  u (filter #(if (= (val %) 1) (key %)) fre)\n                  c (count u)]\n              (if (> c 2)\n                false\n                (let [nl (apply concat (for [x (keys u)]\n                           (filter #(% x) f)))\n                      a (frequencies (apply concat (map seq nl)))\n                      m (if (vals a) (apply max (vals a)) 0)]\n                  (if (>= m 2)\n                    false\n                    (if (empty? u)\n                      true\n                      (recur (apply (partial disj f) nl) (seq (apply disj (reduce clojure.set/union nl) (keys u))))))))))\n          false)))))","problem":82,"user":"5123ac8ee4b061b4c6f0e0b1"},{"problem":82,"code":"(fn [s]\n  (letfn [(p [s] \n             (if (next s)\n               (apply concat \n                      (for [x s] (map #(cons x %) (p (disj s x)))))\n               [s]))\n          (l [s t]\n             (let [i (count (take-while #(apply = %) (partition 2 (interleave s t))))\n                   s (subs s i)\n                   t (subs t i)\n                   f #(apply str (rest %))\n                   u (f s)\n                   v (f t)]\n               (or (= u v) (= s v) (= t u))))]\n    (boolean (some (fn [c] (every? #(apply l %) (partition 2 1 c))) (p s)))))","user":"5c1aadcde4b01240ff567209"},{"problem":82,"code":"(fn wc [s]\n  (letfn [(dropLetter [string i]\n            (str (subs string 0 i) (subs string (inc i))))\n          (oneLetter [a b]\n            (if (= (count a) (count b))\n                (= 1 (count (filter false? (map = a b))))\n                (let [longer (max-key count a b)\n                      shorter (min-key count a b)]\n                    (some (partial = shorter) (map (partial dropLetter longer) (range (count longer)))))))]\n\n         (loop [queue (mapv vector s)]\n               (if-let [c (first queue)]\n                       (if (= (count c) (count s))\n                           true\n                           (recur (into (next queue) (map (partial conj c) (filter (partial oneLetter (last c)) (clojure.set/difference s (set c)))))))\n                false))))","user":"5958cef6e4b066ee0a44af94"},{"problem":82,"code":"(fn [words]\n            (letfn [(remove-nth [n x]\n                      ((juxt first (comp next second)) (split-at n x)))\n\n                    (link? [x y]\n                      (cond\n                        (= (dec (count x)) (count y))\n                        (->> (map #(apply concat (remove-nth % x)) (range (count x)))\n                             (some #(= (seq y) %))\n                             boolean)\n                        (= (count x) (count y)) (= 1 (count (filter false? (map = x y))))\n                        :else false\n                        ))\n\n                    (get-links [word words]\n                      (if (empty? words)\n                        '()\n                        (->> (filter #(apply link? (sort-by (comp - count) [word %])) words)\n                             (map #(cons % (get-links % (remove (partial = %) words)))))))\n\n                    (height [tree]\n                      (if (seq? tree)\n                        (inc (apply max 0 (map height tree)))\n                        1))]\n              (boolean (some true? (for [word words]\n                                     (->> (get-links word (remove #(= word %) words))\n                                          (map height)\n                                          (apply max)\n                                          (= (count words))\n                                          ))))))","user":"567c63f6e4b05957ce8c61bb"},{"problem":82,"code":"(fn word-chain\n  ([words]\n   (reduce #(or %1 %2) (for [x words :let [y (disj words x)]] (word-chain x y))))\n  ([current-word rest-words]\n    (letfn [(levenshtein-distancer\n              [a b]\n              (last\n                (reduce\n                  (fn [arow bi]\n                    (second\n                      (reduce\n                        (fn [[[f s & _ :as lr] cr] ai]\n                          [(rest lr)\n                           (conj\n                             cr\n                             (min\n                               (+ 1 (last cr))\n                               (+ 1 s)\n                               (+ f (if (= ai (nth b bi)) 0 1))))])\n                        [arow [(inc bi)]]\n                        a)))\n                  (range (inc (count a)))\n                  (range (count b)))))]\n   (if (empty? rest-words)\n     true\n     (let [diff-by-one (filter #(= 1 (levenshtein-distancer % current-word)) rest-words)]\n       (if (empty? diff-by-one)\n         false\n         (reduce #(or %1 %2) (for [x diff-by-one :let [y (disj rest-words x)]] (word-chain x y)))))))))","user":"576df252e4b0979f8965156f"},{"code":"(fn [words] \n\t(let [\n         \tswap? \t\t\t(fn [a b] (and (= (count a) (count b)) \n\t\t\t\t\t\t\t\t \t\t   (= 1 ((frequencies (map #(= %1 %2) a b)) false))))\n          \n          \tdeletion? \t\t(fn [a b] (and (= 1 (- (count a) (count b)))\n                                       \t   (if (some #(= b (str (subs a 0 %) (subs a (inc %))))\n                                                  (range (count a))\n\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\ttrue \n\t\t\t      \t\t\t\t\t\t\t\tfalse)))\n          \n          \tinsertion? \t\t(fn [a b] (deletion? b a))\n          \n          \tchainable? \t\t(fn [a b] (or (swap? a b) (deletion? a b) (insertion? a b)))\n          \n          \tis-chain? \t\t(fn is-chain? [root branches]\n                            \t(if (empty? branches)\n\t    \t\t\t\t\t\t\ttrue\n\t    \t\t\t\t\t\t\t(let [check-branch? \n                                   \t\t(fn [branch]\n\t\t\t\t\t\t\t\t\t\t\t(if (chainable? root branch) \n\t\t\t\t\t\t\t\t\t\t\t    (is-chain? branch (disj branches branch))\n\t\t\t    \t\t\t\t\t\t\t\tfalse\n\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t)]\n\t\t\t\t\t\t\t\t\t\t(if (some check-branch? branches) true false)\n\t    \t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t)]\n      \n\t\t(if (some #(is-chain? % (disj words %)) words) true false)\n\t)\n)","problem":82,"user":"50f2e5cee4b0ec8ee6fa8643"},{"problem":82,"code":"(fn [cl] \n     (letfn [(sub-set1? [s1 s2] (let [c1 (seq s1) c2 (seq s2) n1 (count c1) n2 (count c2) mv (min n1 n2) dv (let [tv (- n1 n2)] (if (neg? tv) (- tv) tv))]\n              (cond\n               (= 0 dv)  (->> (map #(= %1 %2) c1 c2) (filter true?)  count  (= (dec (count c1))) )\n               (< 1 dv)  false\n               (= (first c1) (first c2))  (loop [tc1 (if (> n2 n1) c1 c2) tc2 (if (> n2 n1) c2 c1)] (cond\n                              (empty? tc1) true\n                              (empty? tc2) false\n                              :else (recur (if (= (first tc1) (first tc2)) (rest tc1) tc1)  (rest tc2))\n                          ))\n               (= (first c1) (second c2)) (->> (map #(= %1 %2) c1 (rest c2)) (filter true?)  count  (= mv) )\n               (= (second c1) (first c2)) (->> (map #(= %1 %2) (rest c1) c2) (filter true?)  count  (= mv) )\n               :else false )\n             ))\n             \n             (supple-cl [fv c] (loop [n (count c) cq c]\n                              (cond\n                                (>= 0 n) false\n                                (and (= 1 n)\n                                     (= 1 (count c)) )  (sub-set1? fv (first cq))\n                                (sub-set1? fv (first cq))  (do (println \"sub-set1?: \" fv \" : \" cq) (supple-cl (first cq) (rest cq)))\n                                :else (recur (dec n) (conj (vec (drop 1 cq)) (first cq)))\n              )))\n             \n             (feed-cl [c] (loop [n (count c) cq c]\n                              (cond\n                                (>= 0 n) false\n                                (supple-cl (first cq) (rest cq)) (do (println \"Result: \" c) true)\n                                :else (recur (dec n) (conj (vec (drop 1 cq)) (first cq)))\n              ))) ]\n     ;(trampoline feed-cl (seq cl))\n     (feed-cl (seq cl))\n))","user":"55adf4d7e4b03311e7b732af"},{"code":"(fn [s]\n  (letfn\n\t\t[\n\t\t\t(levenshtein [s t]\n\t\t\t\t(cond\n\t\t\t\t\t(empty? s) (count t)\n\t\t\t\t\t(empty? t) (count s)\n\t\t\t\t\t(= s t) 0\n\t\t\t\t\t:else\n\t\t\t\t\t\t(letfn\n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t(new-row [prev-row row-elem t]\n\t\t\t\t\t\t\t\t\t(reduce\n\t\t\t\t\t\t\t\t\t\t(fn [row [d-1 d e]] (conj row (if (= row-elem e) d-1 (inc (min (peek row) d d-1)))))\n\t\t\t\t\t\t\t\t\t\t[(inc (first prev-row))]\n\t\t\t\t\t\t\t\t\t\t(map vector prev-row (rest prev-row) t)\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t(peek\n\t\t\t\t\t\t\t\t(reduce\n\t\t\t\t\t\t\t\t\t(fn [prev-row s-elem] (new-row prev-row s-elem t))\n\t\t\t\t\t\t\t\t\t(range (inc (count t)))\n\t\t\t\t\t\t\t\t\ts\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t\t(carthesian [s] (reduce (fn [r x] (concat r (map #(vector x %) s))) #{} s))\n\t\t\t(start-nodes [x xs] (filter #(= x (first %)) xs))\n\t\t\t(filter-cyclic-nodes [node ns] (filter #(not (or (= (first node) (first %)) (= (first node) (last %)) (= (last node) (last %)))) ns))\n\t\t\t(step [c] (let [node (last (c :path))] (map (fn [next-node] {:path (concat (c :path) [next-node]) :edges (filter-cyclic-nodes next-node (c :edges))}) (start-nodes (last node) (c :edges)))))\n\t\t]\n\t\t(let\n\t\t\t[\n\t\t\t\tlevenshtein-neighbors (filter #(= 1 (apply levenshtein %)) (carthesian s))\n\t\t\t\tinitial-state (map\n\t\t\t\t\t(fn [node] {:path (vector node) :edges (filter-cyclic-nodes node levenshtein-neighbors)})\n\t\t\t\t\t(mapcat (fn [w] (start-nodes w levenshtein-neighbors)) s)\n\t\t\t\t)\n\t\t\t]\n\t\t\t(loop [state initial-state i (- (count s) 2)]\n\t\t\t\t(if (zero? i)\n\t\t\t\t\t(not (empty? (filter (fn [c] (= (count (c :path)) (dec (count s)))) state)))\n\t\t\t\t\t(recur (mapcat step state) (dec i))\n\t\t\t\t)\n\t\t\t)\n\t\t)\n\t)\n)","problem":82,"user":"507eddf4e4b06ce648bcdbfa"},{"problem":82,"code":"(fn has-combinations \n  ([s] (boolean (some true? (for [v s\n                   :let [r (disj s v)]]\n               (has-combinations v r)))))\n  ([v s] \n   (if (empty? s)\n     true      \n     (let [longest-matching (fn [a b] (count (take-while true? (map = a b))))\n           one-changed? (fn [a b] ( = 1 (count (filter false? (map = a b)))))\n           one-inserted? (fn [a b] (= (count a) (+ (longest-matching a b) (longest-matching (reverse a) (reverse b)))))\n           one-diff? (fn [a b] \n                       (case (- (count a) (count b))\n                         -1 (one-inserted? a b)\n                         1  (one-inserted? b a)\n                         0  (one-changed? a b)\n                         false))]\n       (some true? (for [v2 s\n                   :let [r (disj s v2)]\n                   :when (one-diff? v v2)]\n               (has-combinations v2 r)))))))","user":"54e345a1e4b024c67c0cf7db"},{"problem":82,"code":"(fn [words]\n  (let [distance \n        (fn [x y]\n          (letfn [(d [a b] d (cond\n                               (= (count a) 0) (count b)\n                               (= (count b) 0) (count a)\n                               :else #(min (inc (trampoline d a (butlast b)))\n                                           (inc (trampoline d (butlast a) b))\n                                           (if (= (last a) (last b))\n                                             (trampoline d (butlast a)\n                                                         (butlast b))\n                                             (inc (trampoline\n                                                   d (butlast a)\n                                                   (butlast b)))))))]\n            (trampoline d x y)))\n        remove (fn [word words]\n                 (vec (filter #(not= word %) words)))\n        chains (loop [dataset (for [word words]\n                                [[word] (vec (map (fn [x]\n                                               {:word x\n                                                :times (count words)})\n                                                  (remove word words)))])]\n                 (if (not-any? #(not (empty? (second %))) dataset)\n                   (map first dataset)\n                   (recur (for [item dataset\n                                :let [chain (first item)\n                                      leave (second item)\n                                      data (first leave)\n                                      word (:word data)]]\n                            (cond\n                              (empty? leave) item\n                              (= 1 (distance (first chain) word))\n                              [(apply conj [word] chain) (vec (rest leave))]\n                              (= 1 (distance (last chain) word))\n                              [(conj chain word) (vec (rest leave))]\n                              :else (if (> (:times data) 0)\n                                      [chain\n                                       (conj (vec (rest leave))\n                                             {:word word\n                                              :times (dec (:times data))})]\n                                      [chain (rest leave)]))))))]\n    (= (count words) (apply max (map count chains)))))","user":"5cbb0436e4b026601754b9cc"},{"problem":82,"code":"(let [connect? (fn [a b]\n                 (let [a (map int (seq a))\n                       b (map int (seq b))\n                       diff (- (apply + a) (apply + b))\n                       c (if (< 0 diff) a b)\n                       d (if (< 0 diff) b a)\n                       diff (if (< 0 diff) diff (- diff))\n                       cs (loop [prefix [] suffix c cs #{}]\n                            (if (empty? suffix)\n                              cs\n                              (recur (conj prefix (first suffix)) (rest suffix)\n                                     (if (= diff (first suffix))\n                                       (clojure.set/union cs #{(concat prefix (rest suffix))})\n                                       cs))))]\n                   (if (= (count a) (count b))\n                     (= 1 (count (remove zero? (map - a b))))\n                     (contains? cs d)))\n                 )\n\n      fr (fn fr [lastword reached restwords]\n           (if (empty? restwords) true\n               (true? (some identity\n                            (for [word restwords\n                                  :when (and (not (contains? reached word)) (or (nil? lastword) (connect? word lastword)))\n                                  :let [result (fr word (clojure.set/union reached #{word}) (disj restwords word))]]\n                              result)))\n               )\n           )]\n  #(fr nil #{} %))","user":"5547b72be4b0a04f79299550"},{"problem":82,"code":"(fn c82\n  [s]\n  (letfn [(diffone? [str1 str2]\n            (if (= str1 str2)\n              false\n              (loop [s1 (if (> (count str1) (count str2)) str1 str2)\n                     s2 (if (<= (count str1) (count str2)) str1 str2)\n                     changes 0]\n                (if (> changes 1)\n                  false\n                  (if (and (empty? s1) (empty? s2))\n                    true\n                    (if (= (first s1) (first s2))\n                      (recur (next s1) (next s2) changes)\n                      (if (= (count s1) (count s2))\n                        (recur (next s1) (next s2) (inc changes))\n                        (recur (next s1) s2 (inc changes)))))))))]\n    (<= (reduce (fn [r v]\n                  (if (< (count (second v)) 2)\n                    (inc r)\n                    r))\n                0\n                (reduce #(assoc %1 %2 (reduce (fn [r v]\n                                                (if (diffone? v %2)\n                                                  (conj r v)\n                                                  r)) [] s)) {} s))\n        2)))","user":"57d0cd58e4b0bd073c20235e"},{"problem":82,"code":"(fn word-chain [coll]\n  (letfn [(diff [a b]\n            (cond (zero? (count a)) (count b)\n                  (zero? (count b)) (count a)\n                  (= (first a) (first b)) (diff (rest a) (rest b))\n                  :else (min (inc (diff a (rest b)))\n                             (inc (diff (rest a) b))\n                             (inc (diff (rest a) (rest b))))))\n\n          (check-solution [coll]\n              (every? #(= 1 %) (map #(apply diff %) (partition 2 1 coll))))\n          \n          (bt [good cand]\n            (if (zero? (count cand))\n              (check-solution good)\n              (some true? (for [x cand]\n                            (bt (conj good x) (remove #{x} cand))))))]\n    (not (nil? (bt [] (seq coll))))))","user":"4e41a04e535dc968683fc49e"},{"problem":82,"code":"(fn [o-set]\n               (let [familiar? (fn [str1 str2]\n                                 (let [len1 (count str1)\n                                       len2 (count str2)\n                                       sub-len (- len1 len2)\n                                       set1 (clojure.core/set str1)\n                                       set2 (clojure.core/set str2)\n                                       dif-set1 (clojure.set/difference set1 set2)\n                                       dif-set2 (clojure.set/difference set2 set1)]\n                                   (cond\n                                     (zero? sub-len)        ;; substitution\n                                     (loop [seq1 (seq str1), seq2 (seq str2), i 0]\n                                       (if (empty? seq1)\n                                         (if (= 1 i) 1 0)\n                                         (recur (rest seq1) (rest seq2) (if (= (first seq1) (first seq2)) i (inc i)))))\n                                     (and (= 1 sub-len (count dif-set1)) (= (count set1) (count str1)) (= (count set2) (count str2)))  ;; deletion new letter\n                                     1\n                                     (and (= 1 (- sub-len) (count dif-set2)) (= (count set1) (count str1)) (= (count set2) (count str2))) ;; insertion new letter\n                                     1\n                                     (and (= 1 sub-len) (zero? (count dif-set1)) )\n                                     1\n                                     (and (= -1 sub-len) (zero? (count dif-set2)))\n                                     1\n                                     :else 0)))\n                     seq-set (seq o-set)\n                     res-seq (mapv (fn [word] (mapv (fn [item] (familiar? item word)) seq-set)) seq-set)\n                     str-count (mapv (fn [item] (apply + item)) res-seq)\n                     res-map (reduce conj (mapv (fn [key val] (hash-map key val)) seq-set str-count))\n                     one-count (filter (fn [item] (= 1 item)) (vals res-map))\n                     zero-count (filter zero? (vals res-map))]\n                 (if (or (< 0 (count zero-count)) (< 2 (count one-count)))\n                   false\n                   (do #_(println res-seq \"=====\" seq-set \"+++++++++++\" str-count)\n                       true\n                       ))))","user":"5cf72682e4b0b71b1d808a68"},{"problem":82,"code":"(fn [words]\n  (letfn\n  [(adj-by-add [lng sht] (not (empty? (filter (partial = (seq sht)) (for [i (range (count lng))] (concat (take i lng) (drop (inc i) lng)))))))\n   (adj-by-sub [w1 w2] (> 2 (count (filter false? (map = w1 w2)))))\n   (adj [w1 w2]\n   (if (= (dec (count w1)) (count w2)) (adj-by-add w1 w2)\n   (if (= (dec (count w2)) (count w1)) (adj-by-add w2 w1)\n   (if (= (count w1) (count w2)) (adj-by-sub w1 w2)\n   false))))]\n   \n   (loop [stack (for [word words] [word (disj words word)])]\n     (if (empty? stack) false\n     (let [curr (first stack)\n          w (first curr)\n          remwords (second curr)\n          cont (rest stack)]\n     (if (empty? remwords) true\n     (recur (concat (for [adjw (filter (partial adj w) remwords)] [adjw (disj remwords adjw)]) cont))\n     )))\n   )\n )\n)","user":"5519c157e4b00ace28fe6e32"},{"code":"(let [variations  (fn variations [word i]\n                    (when-not (= (count word) i)\n                      (cons (apply str (concat (take i word) (drop (inc i) word)))\n                        (variations word (inc i)))))\n      chainable?  (fn chainable? [a b]\n                    (cond\n                      (= (count a) (count b))\n                        (= 1 (count (filter false? (map = a b))))\n                      :else\n                        (let [[a b] (if (< (count a) (count b)) [a b] [b a])]\n                          (some (partial = a) (variations b 0)))))]\n  (fn chain?\n    ([words] (boolean (some boolean (for [w words]\n                                       (chain? w (disj words w))))))\n    ([w words]\n      (if (empty? words)\n        true\n        (let [neighbours (filterv (partial chainable? w) (seq words))]\n          (if (empty? neighbours)\n            false\n            (some boolean (for [w2 neighbours]\n                             (chain? w2 (disj words w2))))))))))","problem":82,"user":"52a1acb2e4b04e0c58e87bdb"},{"code":"(fn oh-god-no [s]\n  (letfn [(diff-by-del [long-w short-w]\n            (loop [n (count long-w)]\n              (cond\n               (= n 0) false\n               (= (str (subs long-w 0 (dec n)) (subs long-w n)) short-w) true\n               :else (recur (dec n)))))\n          (diff-by-sub [l-w r-w]\n            (if (= 1 (reduce #(if %2 %1 (inc %1)) \n                             0 \n                             (map #(= %1 %2) l-w r-w)))\n              true\n              false))\n          (diff-by-one [l-w r-w]\n            (let [l-cnt (count l-w) r-cnt (count r-w)]\n              (cond \n               (= l-cnt r-cnt) (diff-by-sub l-w r-w)\n               (= (inc l-cnt) r-cnt) (diff-by-del r-w l-w)\n               (= (inc r-cnt) l-cnt) (diff-by-del l-w r-w)\n               :else false)))\n          (find-one-shifts [wrd st]\n            (filter #(diff-by-one wrd %) st))\n          (set-to-sorted-map [s]\n            (let [unsorted (reduce #(assoc %1 %2 (find-one-shifts %2 s)) {} s)]\n              (into (sorted-map-by #(compare [(count (get unsorted %1)) %1]\n                                             [(count (get unsorted %2)) %2]))\n                    unsorted)))]\n    (let [get-lowest-count (fn [st mp] (first (sort-by #(count (get mp %1)) st)))\n          mp (set-to-sorted-map s)]\n      (loop [head (last (first mp)) mp (dissoc mp (ffirst mp))]\n        (let [p-lnks (filter #(contains? mp %) head)]\n          (cond\n           (empty? mp) true\n           (empty? p-lnks) false\n           :else\n           (let [next-key (get-lowest-count p-lnks mp)]\n             (recur (get mp next-key) (dissoc mp next-key)))))))))","problem":82,"user":"52463059e4b09dbe66b56198"},{"code":"(fn [s]\n  (let [is-chained? (fn [a b]\n                     (let [la (count a)\n                           lb (count b)\n                           ld (Math/abs (- la lb))]\n                       (cond\n                         (> ld 1) false\n                         (= ld 1) (if (< la lb) (recur b a)\n                                    (some\n                                      #(= % b)\n                                      (map \n                                        #(apply str\n                                                (concat (take % a)\n                                                        (drop (inc %) a)))\n                                        (range la))))\n                         :default (= 1 (count (filter false? (map = a b)))))))\n        find-next-words (fn [s w] (filter #(is-chained? % w) s)) \n        remove-word (fn [s w] (remove #(= w %) s))  \n        grow-chain (fn [[r s]]\n                     (let [last-word-next (find-next-words s (last r))\n                           first-word-next (find-next-words s (first (drop-last r)))]\n                       (concat \n                         (map #(list (conj (vec r) %) (remove-word s %)) last-word-next)\n                         (map #(list (vec (conj (seq r) %)) (remove-word s %)) first-word-next)\n                         )))\n        ] \n    (loop [result (list (list [(first s)] (disj s (first s))))]\n      (let [filtered-result (remove #(empty? (first %)) result)]\n        (cond\n          (empty? filtered-result) false\n          (some (fn [[r s]] (and (seq r) (empty? s))) filtered-result) true\n          :default (recur (mapcat grow-chain filtered-result))\n          )))))","problem":82,"user":"4fbbcf0ce4b081705acca2ee"},{"problem":82,"code":"(fn has-word-chain? [s]\n  (letfn [(dist-1-words? [a b]\n                         (or\n                          (and\n                           (= (count a) (count b))\n                           (= 1 \n                              (count\n                               (filter false?\n                                       (map = a b)))))\n                          (and\n                           (= (count a) (inc (count b)))\n                           (some #(dist-1-words? a %)\n                                 (map #(let [[beg end] (split-at % b)] (concat beg \"_\" end)) (range (count a)))))\n                          (and\n                           (= (count a) (dec (count b)))\n                           (dist-1-words? b a))))\n          (word-chain? [words]\n                       (every? true?\n                               (map dist-1-words? words (drop 1 words))))\n          (all-subvecs [s]\n                       (if (< (count s) 2) (hash-set (vec s))\n                         (for [el s r (all-subvecs (disj s el))]\n                           (cons el r))))]\n    (not (nil? (some word-chain? (all-subvecs s))))))","user":"53286f84e4b09d4e7a9b5505"},{"code":"(fn [x]\n  (letfn [(o [a b]\n             (let [d (remove true? (map = a b))\n                   c (compare (count a) (count b))\n                   q (if (> c 0) a b)\n                   r (if (< c 0) a b)]\n               (if (= c 0)\n                 (= 1 (count d))\n                 (not (nil? (some (partial = (map char r))\n                              (for [i (range (count q))]\n                                (concat (take i q) (nthrest q (+ i 1))))))))))]\n    (->> (zipmap x (repeat (count x) x))\n         (reduce\n           (fn [a [k v]]\n             (assoc a k (set (filter #(o k %) v))))\n           {})\n         (filter (fn [[_ v]] (< (count v) 2)))\n         (#(< (count %) 3)))))","problem":82,"user":"51b3f109e4b0f094dd986fa9"},{"problem":82,"code":"(fn word-chain? [words]\n  (letfn [;; For two words in the same length\n          (same-len-chain? [a b]\n            (and (= (count a) (count b))\n                 (->>(map = a b)\n                     (filter not)\n                     count\n                     (= 1))))\n\n          ;; For two different length words\n          (diff-len-chain? [longer shorter]\n            (let [lc (count longer) sc (count shorter)]\n              (cond (= lc sc) false\n                    (< lc sc) (diff-len-chain? shorter longer)\n                    :else\n                    (loop [l longer s shorter diff false]\n                      (cond (and (empty? l) (empty? s)) true\n                            (= (first l) (first s)) (recur (rest l) (rest s) diff)\n                            (and (not= (first l) (first s)) (not diff)) (recur (rest l) s true)\n                            :else false)))))\n          ;; list up permutations of s\n          (perm [s]\n            (letfn [(insert [l n e]\n                      (if (zero? n)\n                        (cons e l)\n                        (cons (first l) (insert (rest l) (dec n) e))))]\n              (if (empty? s)\n                '(())\n                (apply concat\n                       (map (fn [l]\n                              (map #(insert l % (first s))\n                                   (range 0 (inc (count l))))\n                              )\n                            (perm (rest s)))))))\n          ;; pairing adjacent nodes\n          (pair [l]\n            (cond (> (count l) 2) (conj (pair (rest l)) [(first l) (second l)])\n                  (= (count l) 2) (list [(first l) (second l)])\n                  :else []))]\n       (->> (perm words)     ; permutations\n         (map pair)       ; apply pair to each list in the list,\n         (map\n          #(every? (fn decide [[a b]] (or (same-len-chain? a b)(diff-len-chain? a b))) %) ) ; each list satisfies every?\n         (some identity)    ; see if at least one list satisfies\n         nil?\n         not\n         )))","user":"56903cb9e4b0dcc4269f40eb"},{"problem":82,"code":"(fn chainX[x]\n\t(letfn[\n\t\t(different [ai bi]\n\t\t\t(= ai bi)\n\t\t)\n\t\t(substitution[a b]\n\t\t\t(and \n\t\t\t\t(= (count a)(count b))\n\t\t\t\t(= (count (filter false? (map different a b))) 1)\n\t\t\t)\n\t\t)\n\t\t(removeS[s n]\n\t\t\t(str (subs s 0 n) (subs s (inc n)))\n\t\t\t)\n\t\t(inserted [a b]\n\t\t\t(if\n\t\t\t\t(= (inc (count a))(count b))\n\t\t\t\t(let [idx (first (filter #(not= (get a %)(get b %)) (range (count b))))]\n\t\t\t\t\t(= a (removeS b idx))\n\t\t\t\t)\n\t\t\t\tfalse\n\t\t\t)\n\t\t)\t\n\t\t(chained[a b]\n\t\t\t(or\n\t\t\t\t(substitution a b)\n\t\t\t\t(inserted a b)\n\t\t\t\t(inserted b a)\n\t\t\t)\n\t\t)\n\t\t(chainRec[w x]\n\t\t\t(if (empty? x)\n\t\t\t\ttrue\n\t\t\t\t(not (not-any? (fn[w1] (and (chained w w1) (chainRec w1 (disj x w1)))) x))\n\t\t\t)\n\n\t\t)\n\n\n\t\t]\n\n\t\t(not (not-any?  (fn[w] (chainRec w (disj x w))) x))\n\t)\n)","user":"568820e8e4b0dcc4269f4067"},{"problem":82,"code":"(letfn [(hamming [s1 s2] (apply + (map #(if (= %1 %2) 0 1) s1 s2)))\r\n        (levenshtein [s1 s2]\r\n          (let [[s1 s2] (sort-by count > [s1 s2])\r\n                [l1 l2] (map count [s1 s2])]\r\n            (if (= l1 l2) (hamming s1 s2)\r\n                (->> (for [i (range (inc l2))]\r\n                       (+ 1 (hamming (take i s1)\r\n                                     (take i s2))\r\n                          (levenshtein (drop (inc i) s1)\r\n                                       (drop i s2))))\r\n                     (reduce min)))))\r\n        (find-next-word [word words]\r\n          (filter (comp (partial = 1)\r\n                        (partial levenshtein word))\r\n                  words))\r\n        (path-internal [x words]\r\n          (let [next-words (find-next-word x words)]\r\n            (cond (empty? words)      [true]\r\n                  (empty? next-words) [false]\r\n                  :else               (->> next-words\r\n                                           (mapcat #(path-internal\r\n                                                     % (remove (partial = %)\r\n                                                               words)))\r\n                                           (filter identity)))))]\r\n  (fn has-path? [words]\r\n    (let [words (seq words)]\r\n      (not (empty? (->> (for [word words]\r\n                          (path-internal\r\n                           word (remove (partial = word) words)))\r\n                        (reduce concat)))))))","user":"55d0e76ae4b0e31453f64a40"},{"problem":82,"code":"(fn [word-sequence]\n                    (letfn [\n                            (substitution? [a b] \n                              (when (= (count a) (count b))\n                                (= 1 (count (filter (fn [[l1 l2]] (not= l1 l2)) (map vector a b))))))\n\n                            (insertion-deletion? [a b]\n                              (let [[lshorter llonger] (sort (map count [a b]))\n                                    [shorter longer] (sort-by count [a b])]\n                                (when (= llonger (+ 1 lshorter))\n                                  (let [basic-sequence (map-indexed vector (map vector longer (conj (vec shorter) \" \")))\n                                        [difference-index [letter1 letter2]] (first (filter (fn [[i [l1 l2]]] (not= l1 l2)) basic-sequence))\n                                        shorter-remnant (drop difference-index shorter)\n                                        longer-remnant (drop (+ 1 difference-index) longer)]\n                                    (= shorter-remnant longer-remnant)))))\n\n                            (edges [word words]\n                              (set (filter #(or (substitution? word %) (insertion-deletion? word %)) words)))\n\n                            (pairs-and-singletons-from-set [arg-set]\n                              (reduce clojure.set/union #{} (map (fn [e1] (set (map (fn [e2] (set [e1 e2])) arg-set))) arg-set)))\n\n                            (visit [word words visited joins-two]\n                              (let [e (edges word words)\n                                    new-visited (conj visited word)\n                                    remaining (clojure.set/difference e new-visited)]\n\n                                (let [trees (map #(conj (visit % words new-visited false) word) remaining)]\n                                  (if (empty? trees) \n                                    new-visited                                      \n                                      (if joins-two\n                                        (apply max-key count (map #(reduce clojure.set/union #{} %) (pairs-and-singletons-from-set trees)))\n                                        (apply max-key count trees))))))]\n                      (= (visit (first word-sequence) word-sequence #{} true) word-sequence)))","user":"5d024d55e4b0cc9c915881b9"},{"problem":82,"code":"(fn word-chain? [words]\n  (let [traverse (fn traverse\n                   ([m x]\n                    (traverse m x []))\n                   ([m x path]\n                    (when-let [nbrs (get m x)]\n                      (if (seq (dissoc m x))\n                        (when-let [nbrs (-> nbrs (clojure.set/difference (set path)) seq)]\n                          (some #(traverse (dissoc m x) % (conj path x)) nbrs))\n                        (conj path x)))))\n                        \n        connected? (fn [m] (some (partial traverse m) (keys m)))\n        \n        change-one? (fn [a b]\n                      (= 1 (->> (map #(= %1 %2) a b)\n                                (filter false?)\n                                count)))\n        add-one? (fn [a b]\n                   (loop [[x & a' :as a] a\n                          [y & b'] b\n                          errs 0]\n                     (cond\n                       (< 1 errs) false\n                       (and (nil? x) (nil? y)) true\n                       :else (if (= x y)\n                               (recur a' b' errs)\n                               (recur a b' (inc errs))))))\n                               \n        one-step? (fn [a b]\n                    (case (- (count a) (count b))\n                      0 (change-one? a b)\n                      1 (add-one? b a)\n                      -1 (add-one? a b)\n                      false))\n                      \n        word->neighbors (reduce (fn [m word]\n                                  (let [others (disj words word)]\n                                    (assoc m word (into #{} (filter (partial one-step? word) others)))))\n                                {}\n                                words)]\n    (not (nil? (connected? word->neighbors)))))","user":"4f5599dfe4b0a7574ea71806"},{"problem":82,"code":"(fn [s]\n  (let [close? (fn [a b] (let\n                           [n-matches (count (take-while #(apply = %) (partition 2 (interleave a b))))\n                            a-r (drop n-matches a)\n                            b-r (drop n-matches b)]\n                           (some #(apply = %) [[(rest a-r) b-r] [a-r (rest b-r)] [(rest a-r) (rest b-r)]])))\n        t (fn t [curr left]\n            (prn curr left (filter #(close? (last curr) %) left))\n            (if (empty? left)\n              curr\n              (boolean (some identity\n                (map\n                  #(t (concat curr [%]) (remove #{%} left))\n                  (filter #(or (empty? curr) (close? (last curr) %)) left))))))]\n    (t [] s)))","user":"536046a9e4b063bf7a5f8fe1"},{"problem":82,"code":"(fn __ [s]\n  (letfn [(levenshtein-distance [s t]\n               (if (= s t) 0\n                 (letfn [(f [s v0]\n                            (if (empty? s) (nth v0 (count t))\n                              (recur (rest s)\n                                     (loop [j 0, v1 [(inc (first v0))]]\n                                       (if (= j (count t)) v1\n                                         (recur (inc j)\n                                                (conj v1 (min (inc (nth v1 j))\n                                                              (inc (nth v0 (inc j)))\n                                                              (+ (nth v0 j)\n                                                                 (if (= (first s)\n                                                                        (nth t j))\n                                                                   0 1))))))))))]\n                   (f s (vec (range (inc (count t)))))))),\n          (can-chain? [x xs] ; can form a word chain starting from x using all the words in xs\n             (or (empty? xs)\n                 (true?\n                  (some true?\n                        (map #(can-chain? % (disj xs %))\n                             (filter #(= 1 (levenshtein-distance x %))\n                                     xs))))))\n          ]\n    (true?\n     (some true?\n           (map #(can-chain? % (disj s %)) s)))))","user":"54c271b9e4b045293a27f602"},{"problem":82,"code":"(fn [se]\n  (let [same (fn f [w1 w2 i j diff]\n               (let [l1 (count w1) l2 (count w2)]\n                 (if (> diff 1)\n                   false\n                   (if (and (>= i l1) (>= j l2)) true\n                     (if (or (>= i l1) (>= j l2))\n                       (and (<= diff 0) (<= (- (max l1 l2) (min l1 l2)) 1))\n                       (or\n                         (and (= (nth w1 i) (nth w2 j)) (f w1 w2 (inc i) (inc j) diff))\n                         (and (or (= j (dec l2)) (and (< j (dec l2)) (= (nth w1 i) (nth w2 (inc j))))) (f w1 w2 i (inc j) (inc diff)))\n                         (and (or (= i (dec l1)) (and (< i (dec l1)) (= (nth w1 (inc i)) (nth w2 j)))) (f w1 w2 (inc i) j (inc diff)))\n                         (and (or (and (= i (dec l1)) (= j (dec l2))) (and (< i (dec l1)) (< j (dec l2)) (= (nth w1 (inc i)) (nth w2 (inc j))))) (f w1 w2 (+ 2 i) (+ 2 j) (inc diff)))))))))\n        seq (fn [gs] (for [g gs w se] (if (and (not (contains? (set g) w)) (same (last g) w 0 0 0)) (conj g w) [])))]\n    (loop [c 1 groups (map vector se)]\n      (if (empty? groups)\n        false\n        (if (>= c (count se))\n          (= (count se) (count (reduce #(if (< (count %) (count %2)) %2 %) [] groups)))\n          (recur (inc c) (remove empty? (seq groups))))))))","user":"551c66dae4b07993ea3788de"},{"problem":82,"code":"(fn [w]\n  (<=\n    (count w)\n    (get (frequencies (sort \n                        (for [l1 (seq w) l2 (seq w)\n                              :when (< 0 (compare l1 l2))] \n                          ((memoize \n                             (fn f  [x y]\n                               (let  [cost  (if  (=  (first x)  (first y)) 0 1)]\n                                 (cond\n                                   (zero?  (count x))  (count y)\n                                   (zero?  (count y))  (count x)\n                                   (=  (first x)  (first y))  (f  (rest x)  (rest y))\n                                   :else\n                                   (min\n                                     (+ 1  (f  (rest x) y))\n                                     (+ 1  (f x  (rest y)))\n                                     (+ cost  (f  (rest x)  (rest y)))))))) l1 l2))))\n         1)))","user":"519136e9e4b0f8ef0be96c01"},{"problem":82,"code":"(fn [word-set]\n    (letfn [(put-first-remove [put-first to-remove s]\n              (cons put-first (remove #(or (= put-first %) (= to-remove %)) s)))\n            (eq-count-differences [w1 w2]\n              (reduce (fn [d [c1 c2]] (if (= c1 c2) d (inc d)))\n                      0\n                      (map vector  w1 w2)))\n            (neq-count-differences [w1 w2]\n              (if (> (count w1) (count w2)) (recur w2 w1)\n                  (loop [i1 0 i2 0 d 0]\n                    (if (= i2 (count w2)) d\n                        (if (= i1 (count w1))\n                          (recur i1 (inc i2) (inc d))\n                          (let [c1 (nth w1 i1)\n                                c2 (nth w2 i2)]\n                            (if (= c1 c2)\n                              (recur (inc i1) (inc i2) d)\n                              (recur i1 (inc i2) (inc d)))))))))\n            (count-differences [w1 w2]\n              (if (= (count w1) (count w2))\n                (eq-count-differences w1 w2)\n                (neq-count-differences w1 w2)))\n            (chainable? [w1 w2] (= 1 (count-differences w1 w2)))\n            (step [[w1 & ws]]\n              #_(println \"Set:\" w1 ws)\n              (if (empty? ws) true\n                  (some true?\n                        (map (fn [w2]\n                               #_(println w1 w2 (chainable? w1 w2))\n                               (if (chainable? w1 w2)\n                                 (step (put-first-remove w2 w1 ws))\n                                 false))\n                             ws))))]\n      (loop [i (count word-set)\n             words (seq word-set)]\n        #_(println \"Words:\" words)\n        (cond\n          (= 0 i) false\n          (step words) true\n          :else (recur (dec i) (concat (rest words) [(first words)]))))))","user":"595bbab7e4b066ee0a44afe0"},{"problem":82,"code":"(fn chain? [coll]\n  (letfn [(neighbors? [a b]\n    (loop [a a b b diffs 0]\n      (cond (> diffs 1) false\n            (= a b) true\n            (= (first a) (first b)) (recur (rest a) (rest b) diffs)\n            (= (count a) (count b)) (recur (rest a) (rest b) (inc diffs))\n            (> (count a) (count b)) (recur (rest a) b (inc diffs))\n            :else (recur a (rest b) (inc diffs)))))]\n    (let [neighborlists (zipmap coll (map (fn [x] (filter #(neighbors? % x) (remove #(= x %) coll))) coll))]\n    (>= 2 (count (filter #(= 1 (count (val %))) neighborlists))))))","user":"57131dfbe4b07c98581c3a98"},{"code":"(fn chains? [words]\r\n  (letfn [(without [one words]\r\n            (clojure.set/difference words #{one}))\r\n          (onesubs? [a b]\r\n            (or (and (= (first a) (first b)) (not (empty? (rest a))) (onesubs? (rest a) (rest b)))\r\n                (and (not= (first a) (first b)) (= (rest a) (rest b)))))\r\n          (oneins? [a b] ; a-len > b-len\r\n            (or (= (rest a) b)\r\n                (and (= (first a) (first b)) (oneins? (rest a) (rest b)))))\r\n          (chain? [a b]\r\n            (cond (> (count a) (count b)) (oneins? (seq a) (seq b)),\r\n                  (< (count a) (count b)) (oneins? (seq b) (seq a)),\r\n                  :else (onesubs? (seq a) (seq b))))\r\n          (chains-from? [word others]\r\n            (or (empty? others)\r\n                (let [nexts (filter #(chain? word %) others)]\r\n                  (some #(chains-from? % (without % others)) nexts))))]\r\n    (boolean (some #(chains-from? % (without % words)) words))))","problem":82,"user":"4f62b29ce4b0defedf855fd9"},{"problem":82,"code":"(fn [s]\n  (let [edit_distance_one?\n          (fn [s_x s_y]\n            (let [l_x (count s_x)\n                  l_y (count s_y)]\n              (if (> (java.lang.Math/abs (- l_x l_y)) 1)\n                false\n                (= 1 (loop [e 0\n                            x s_x\n                            y s_y]\n                       (cond (empty? x) (+ e (count y))\n                             (empty? y) (+ e (count x))\n                             :else (if (= (first x) (first y))\n                                     (recur e (rest x) (rest y))\n                                     (if (> (+ 1 e) 1)\n                                       false\n                                       (cond (> l_x l_y) (recur (+ 1 e) (rest x) y)\n                                             (< l_x l_y) (recur (+ 1 e) x (rest y))\n                                             :else (recur (+ 1 e) (rest x) (rest y)))))))))))\n        compute_adjacency_map\n          (fn [s]\n            (loop [x (first s)\n                   xs (rest s)\n                   adj_map {}]\n              (if (nil? x)\n                adj_map\n                (recur (first xs)\n                       (rest xs)\n                       (assoc adj_map x (filter (fn [y] (edit_distance_one? x y)) s))))))\n        or_fn (fn [x y] (or x y))\n        num_strs (count s)\n        adj_map (compute_adjacency_map s)\n        c_f_c? (fn can_form_chain? [x ss]\n                 (if (contains? ss x)\n                   false\n                   (let [xss (conj ss x)]\n                     (if (= num_strs (count xss))\n                       true\n                       (let [x_adjs (get adj_map x)]\n                         (reduce or_fn (map (fn [y] (can_form_chain? y xss)) x_adjs)))))))]\n    (reduce or_fn (map (fn [x] (c_f_c? x #{})) s))))","user":"5a34f342e4b0ddc586f153d1"},{"code":"(fn [words]\n    (letfn [(w-o [s el]\n              (filter #(not (= el %)) s))\n            (one-letter-different? [a b]\n              (letfn [(differ [[a & as] [b & bs] single-diff?]\n                        (if (and (nil? a) (nil? b))\n                          single-diff?\n                          (if (= a b)\n                            (differ as bs single-diff?)\n                            (if single-diff?\n                              false\n                              (or (differ as (cons b bs) true)\n                                  (differ (cons a as) bs true)\n                                  (differ as bs true))))))]\n                (differ a b false)))\n            (check-potentials [potentials others]\n              (if (empty? potentials)\n                false\n                (not (nil? (some #(can-form-chain? % (w-o others %)) potentials)))))\n            (can-form-chain? [target others]\n              (if (empty? others)\n                true\n                (let [potentials (filter #(one-letter-different? target %) others)]\n                  (check-potentials potentials others))))]\n      (check-potentials words words)))","problem":82,"user":"5141abf1e4b02fd87f5064c3"},{"problem":82,"code":"(fn word-chains?\n  [xs]\n  (letfn [(dis\n            [w1 w2]\n            (if (or (empty? w1)\n                    (empty? w2))\n              (+ (count w1) (count w2))\n              (let [x1 (first w1)\n                    y1 (first w2)]\n                (if (= x1 y1)\n                  (dis (rest w1) (rest w2))\n                  (inc (min (dis (rest w1) (rest w2))\n                            (dis (rest w1) w2)\n                            (dis w1 (rest w2))))))))\n          (chains?\n            ([w1 w2]\n             (= 1 (dis w1 w2)))\n            ([w1 w2 & ws]\n              (and (chains? w1 w2)\n                   (apply chains? w2 ws))))\n          (ps\n            [xs]\n            (if (empty? xs)\n              '(())\n              (apply concat\n                     (for [e xs]\n                       (map #(concat [e] %)\n                            (ps (disj xs e)))))))]\n    (true? (some #(apply chains? %) (ps xs)))))","user":"56a36f76e4b0542e1f8d14ca"},{"problem":82,"code":"(letfn [\n          (exist-chain? \n            [words]\n            (some chain? (all-chains words)))\n          (all-chains \n            [words]\n            ;(println \"words: \" words)\n            (if (seq words)\n              (for [w words p- (all-chains (disj words w))] \n                 (cons w p-))\n              (list (list))\n              ))\n          (chain?\n            [ws]\n            (every? identity \n                   (map one-diff? ws (rest ws)))\n            )\n          (one-diff? \n            [a b]\n            (let [a (seq a) b (seq b) ca (count a) cb (count b)]\n              (cond \n                (= ca cb) (= 1 (count-diff a b)) ;substituition\n                (= (inc ca) cb) (deletion? b a) ;deletion\n                (= ca (inc cb)) (deletion? a b) ;insertion\n                :else false))\n            )\n          (deletion? \n            [as bs]\n            (some #{bs} (all-del-one as))\n            )\n          (all-del-one \n            [coll]\n            (for [i (range (count coll)) :let [d (remove #(= (first %1) i)  (map-indexed vector coll))]] \n              (map second d)))\n          \n          (count-diff\n            [as bs]\n            (reduce + (map #(if (= %1 %2) 0 1) as bs)))\n          \n          ]\n   ;(fn [words] (map flatten (all-chains words))))\n   ;all-chains)\n   (fn [words] (if (exist-chain? words) true false)))","user":"50eddbc4e4b06330c1f87c4b"},{"problem":82,"code":"(fn [s]\n  (not-every? false?\n              (map (fn [s]\n                     (if (> (count s) 1)\n                       (if ((fn isValid[a b e]\n                              (if (> e 1)\n                                false\n                                (if (or (seq a) (seq b))\n                                  (if (= (first a) (first b))\n                                    (isValid (rest a) (rest b) e)\n                                    (or\n                                      (isValid (rest a) (rest b) (+ e 1))\n                                      (isValid a (rest b) (+ e 1))\n                                      (isValid (rest a) b (+ e 1))\n                                      )\n                                    )\n                                  true\n                                  )\n                                )\n                              ) (first s) (second s) 0)\n                         (recur (rest s))\n                         false\n                         )      \n                       true     \n                       )        \n                     ) ((fn permut[s]\n                          (let [s (set s)]\n                            (if (= 2 (count s))\n                              (list\n                                (list (first s) (second s))\n                                (list (second s) (first s))\n                                )\n                              (apply clojure.set/union (map (fn[a](map #(conj % a) (permut (disj s a)))) s))\n                              )\n                            )\n                          ) s)))\n  )","user":"54b90836e4b0ed20f4ff6e9d"},{"code":"(fn [words]\n  (letfn [(conn? [[w1 w2]] ; (assert (not= w1 w2))\n            (let [[h1 & t1 :as s1] (seq w1) [h2 & t2 :as s2] (seq w2)]\n              (if (= h1 h2)\n                (conn? [t1 t2])\n                (or (= t1 t2) (= t1 s2) (= s1 t2)))))\n          (perms [s]\n            (if (empty? s)\n              '(())\n              (apply concat\n                     (for [e s] (map (partial cons e)\n                                     (perms (disj s e)))))))]\n    (let [connm? (memoize conn?)]\n      (if (some #(every? connm? (partition 2 1 %))\n                (perms words))\n        true false))))","problem":82,"user":"4fe84c74e4b07c9f6fd12c3c"},{"code":"(fn [words]\n  (letfn \n    [(one-letter-ins? [word1 word2]\n        (let [diff (- (count word1) (count word2))]\n        (cond (neg? diff) (one-letter-ins? word2 word1)\n              (not= 1 diff) false\n              :else\n                (loop [w1 (seq word1) w2 (seq word2) diffs 0]\n                  (cond (> diffs 1) false\n                        (empty? w1) true\n                        (= (first w1) (first w2)) (recur (rest w1) (rest w2) diffs)\n                        :else (recur (rest w1) w2 (inc diffs)))))))\n     (one-letter-rpl? [w1 w2]\n        (and (= (count w1) (count w2))\n             (= (count (filter false? (map #(= %1 %2) w1 w2))) 1)))\n     (one-letter-diff? [w1 w2]\n        (or (one-letter-ins? w1 w2)\n            (one-letter-rpl? w1 w2)))\n     (word-map [words] (reduce \n         (fn [wmap w]\n            (assoc wmap w (filter #(one-letter-diff? w %1) words)))\n         {} words))]\n  \n    (let [wmap (word-map words)]\n      (boolean (some \n         (fn path? [p]\n           (or (= (count p) (count words))\n               (some (fn [w]\n                       (and (not-any? #(= w %) p)\n                            (path? (conj p w))))\n                     (get wmap (last p)))))\n         (map #(vector %) words))))))","problem":82,"user":"53300924e4b019098a6f8b55"},{"code":"(fn [xs]\r\n  (letfn [(check [a b]\r\n            (let [a-length (count a)\r\n                  b-length (count b)\r\n\r\n                  fit (fn [a b]\r\n                        (< (- (max (count a) (count b))\r\n                              (apply + (for [i (range (min (count a) (count b)))\r\n                                             :when (= (get a i) (get b i))]\r\n                                         1)))\r\n                           2))\r\n\r\n                  gen-word (fn [s at]\r\n                             (let [split (split-at at s)\r\n                                   left (first split)\r\n                                   right (second split)]\r\n                               (str (apply str left) \\. (apply str right))))]\r\n\r\n\r\n              (if-not (= a-length\r\n                         b-length)\r\n\r\n                (when (< (Math/abs (- a-length\r\n                                      b-length))\r\n                         2)\r\n        \r\n                  (if (< a-length\r\n                         b-length)\r\n\r\n                    (let [words (for [i (range (inc a-length))]\r\n                                  (gen-word a i))]\r\n                      (some (partial fit b) words))\r\n\r\n                    (let [words (for [i (range (inc b-length))]\r\n                                  (gen-word b i))]\r\n                      (some (partial fit a) words))))\r\n      \r\n                (when (fit a b)\r\n                  true))))\r\n          (rec\r\n                        ([xs] (rec xs nil))\r\n                        ([xs acc]\r\n                           (if (seq xs)\r\n                             (for [x xs]\r\n                               (if (nil? acc)\r\n                                 (rec (disj xs x) (cons x acc))\r\n                                 (when (check (first acc) x)\r\n                                   (rec (disj xs x) (cons x acc)))))\r\n                             true)))]\r\n  (if (some true? (flatten (rec xs)))\r\n    true\r\n    false)))","problem":82,"user":"4e0d8c27535d04ed9115e7b7"},{"code":"(fn checkLinks [wordList]\r\n   (let[compFn (fn compStr   \r\n    \t\t\t\t\t\t\t\t([seq1 seq2 sign]    \r\n\t\t\t\t\t\t\t\t\t\t\t   (let[r1 (rest seq1),\r\n\t\t\t\t\t\t\t\t\t\t\t        r2 (rest seq2),\r\n\t\t\t\t\t\t\t\t\t\t\t        s1 (empty? seq1),\r\n\t\t\t\t\t\t\t\t\t\t\t        s2 (empty? seq2)] \r\n\t\t\t\t\t\t\t\t\t\t\t    (if (or s1 s2)\r\n\t\t\t\t\t\t\t\t\t\t\t          (cond (and s1 s2) (= sign 1) \r\n\t\t\t\t\t\t\t\t\t\t\t                (or (not-empty r1) (not-empty r2)) false\r\n\t\t\t\t\t\t\t\t\t\t\t                :else (= sign 0)\r\n\t\t\t\t\t\t\t\t\t\t\t                )\r\n\t\t\t\t\t\t\t\t\t\t\t        (let[f1 (first seq1),\r\n\t\t\t\t\t\t\t\t\t\t\t             f2 (first seq2)]\r\n\t\t\t\t\t\t\t\t\t\t\t\t        (cond (= f1 f2) (compStr r1 r2 sign)\r\n\t\t\t\t\t\t\t\t\t\t\t\t              (and (not= f1 f2) (= 0 sign) )\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t              (or (compStr seq1 r2 1)\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t                (compStr r1 seq2 1)\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t                (compStr r1 r2 1)\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t                )\r\n\t\t\t\t\t\t\t\t\t\t\t\t              :else false\r\n\t\t\t\t\t\t\t\t\t\t\t\t            )\r\n\t\t\t\t\t\t\t\t\t\t\t        )\r\n\t\t\t\t\t\t\t\t\t\t\t      )\r\n\t\t\t\t\t\t\t\t\t\t\t    )\r\n\t\t\t\t\t\t\t\t\t\t\t   )\r\n\t\t\t\t\t\t\t\t\t\t([str1 str2] (compStr (seq str1) (seq str2) 0) )   \r\n\t\t\t\t\t\t\t\t\t\t\t ),              \r\n        matchMap ( (fn [wordlist]\r\n\t\t\t\t\t\t\t    (reduce \r\n\t\t\t\t\t\t\t\t\t  (fn [matchMap word]\r\n\t\t\t\t\t\t\t\t\t    (reduce          \r\n\t\t\t\t\t\t\t\t\t    #(let[val (get %1 word)]\r\n\t\t\t\t\t\t\t          (if (empty? val)\r\n\t\t\t\t\t\t\t             (assoc %1 word #{%2} )\r\n\t\t\t\t\t\t\t             (assoc %1 word (conj val %2) ) \r\n\t\t\t\t\t\t\t          )\r\n\t\t\t\t\t\t\t         )\r\n\t\t\t\t\t\t\t\t\t      matchMap\r\n\t\t\t\t\t\t\t\t\t\t\t  (filter #(compFn %1 word) \r\n                                (disj wordlist word))\r\n\t\t\t\t\t\t\t\t\t    )\r\n\t\t\t\t\t\t\t\t\t  ) {}\r\n\t\t\t\t\t\t\t\t\t\t    wordlist)      \r\n\t\t\t\t\t\t\t\t\t\t) wordList ),\r\n        generNextlinks  (fn[linkInfo]\r\n\t\t\t\t\t\t\t\t\t\t\t\t   (let [convert (fn[key]\r\n                                           (let[node (key linkInfo),\r\n                                                links (:link linkInfo)]\r\n\t\t\t\t\t\t\t\t                             (map #(assoc \r\n                                                      (assoc linkInfo :link\t\t\t\t\t\t\t\t\t\t\t\t        \r\n\t\t\t\t\t\t\t\t                                        (conj links %)\r\n                                                       )\r\n                                                       key %) \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t        (filter\r\n                                                   #(not (contains? links %) )\r\n                                                   (get matchMap node)\r\n                                                 )\r\n                                              ) \t\t\t\t\t\t\t\t\t\t\t\t\r\n                                            )\r\n                                          )\r\n\t\t\t\t\t\t\t\t\t\t\t\t    ]\t\t\t\t\t\t\t\t\t\t\t\t        \r\n\t\t\t\t\t\t\t\t\t\t\t\t    (concat (convert :head)\r\n\t\t\t\t\t\t\t\t\t\t\t\t                (convert :tail) )     \r\n\t\t\t\t\t\t\t\t\t\t\t\t     )  \r\n\t\t\t\t\t\t\t\t\t\t\t\t  ),\r\n        firstNode  (first wordList),\r\n        nextNodes  (get matchMap firstNode)]\r\n     (if (nil? nextNodes)       \r\n         false\r\n         (not=  (some \r\n            (fn[infoLinks]\r\n               (println infoLinks)\r\n               (if (empty? infoLinks) \r\n                   -1\r\n                  (some \r\n\t\t                #(empty? \r\n                     (apply (partial disj wordList) (:link %) ) \r\n                     )\r\n                    infoLinks)\r\n                )\r\n             )\r\n            (iterate\r\n             (fn[infoLinks]                      \r\n               (reduce #(concat %1 (generNextlinks %2) ) []  infoLinks)\r\n              )\r\n             [{:head firstNode \r\n                           :tail (first nextNodes)\r\n                           :link #{firstNode (first nextNodes)}}]\r\n            )\r\n       )  -1)    \r\n     )   \r\n   )\r\n )","problem":82,"user":"4f6d9d7ee4b07046d9f4efcd"},{"problem":82,"code":"(fn [words]\n  (let [deletion\n        (fn [s]\n          (->> (map concat\n                 (map #(take % s) (range (count s)))\n                 (map #(drop % s) (iterate inc 1)))\n            (map #(apply str %))\n            set))\n        deletions (->> words (map deletion) (zipmap words))\n        editable?\n        (fn [s]\n          (fn [t]\n            (case (- (count s) (count t))\n              -1 ((deletion t) s)\n              1  ((deletion s) t)\n              0  (->> (map = s t) (filter false?) count (= 1))\n              nil)))\n        editions\n        (->> words\n          (map (fn [word]\n                 (->> (disj words word)\n                   (filter (editable? word))\n                   set)))\n          (zipmap words))\n        permutations\n        ((fn permutation [s]\n           (case (count s)\n             0 []\n             1 [[(first s)]]\n             (mapcat #(map cons (repeat %) (permutation (disj s %))) s)))\n         words)]\n    (->> permutations\n      (map #(partition 2 1 %))\n      (map #(map (fn [[s t]] ((editions s #{}) t)) %))\n      (remove #(some nil? %))\n      empty? not)))","user":"50479524e4b0371827a27bc4"},{"problem":82,"code":"(fn [set-of-words]\n    (letfn [(distance\n              ([s len-s t len-t]\n               (cond (zero? len-s) len-t\n                     (zero? len-t) len-s\n                     :else (min (+ (distance s (dec len-s) t len-t)        1)\n                                (+ (distance s len-s       t (dec len-t))  1)\n                                (+ (distance s (dec len-s) t (dec len-t))  (if (= (nth s (dec len-s)) (nth t (dec len-t))) 0 1)))))\n              ([s t] (distance s (count s) t (count t))))\n            (close-enough? [xs ys] (= 1 (distance xs ys)))\n            (graph [xs] (reduce into {} (map (fn [x] {x (set (filter (partial close-enough? x) xs))}) xs)))\n            (depth-first-traversal\n              [graph start]\n              (loop [result  [start]\n                     visited #{start}\n                     stack   (list start)]\n                (if (empty? stack)\n                  result\n                  (let [next (first (sort (remove visited (graph (peek stack)))))]\n                    (if next\n                      (recur (conj result next) (conj visited next) (conj stack next))\n                      result ;; Stop at first dead end -- don't pop the stack to visit everything (recur result visited (pop stack))\n                      )))))\n            (has-chain?\n              [words]\n              (let [g (graph words)\n                    wc (count words)\n                    pass #(= wc (count (depth-first-traversal g %)))]\n                (if (some pass words)\n                  true\n                  false)))]\n      (has-chain? set-of-words)))","user":"52485f02e4b05ef8e38e63d3"},{"code":"(letfn[\n(n[a b] (= 1 (reduce + (map #({true 0 false 1} (= %1 %2)) a b))))\n(sdrop[n s] (apply str (concat (take n s) (drop (inc n) s))))\n(r[a b] (let[[a b] (sort-by count (list a b))] (some #(= a %) (for[x (range 0 (count b))] (sdrop x b)))))\n(p[a b] (if (= (count a) (count b)) (n a b) (r a b)))\n(b[x s] (set (filter  #(p x %) s)))\n(t[s] (apply merge (map #(hash-map % (b % s)) s)))\n(search[todo all done] (let[x (first done)\n                              moves  (if (nil? x) todo (clojure.set/difference (get all x) (set done)))]\n\n                        (cond (empty? todo) true\n                          (empty? moves) false\n                          :else (some #(search (disj todo %) all (cons % done )) moves))))\n]\n(fn[s] (if (search s (t s) '()) true false)))","problem":82,"user":"507c7c8be4b0b083f3ff82ef"},{"code":"(fn [words]\n  (letfn [(neighbor? [w1 w2]\n                     (cond (and (empty? w1) (empty? w2)) false\n                           (or (empty? w1) (empty? w2) ) true\n                           (< 1 (- (max (count w1) (count w2)) (min (count w1) (count w2)))) false\n                           (= (first w1) (first w2)) (neighbor? (rest w1) (rest w2))\n                           (= (count w1) (count w2)) (= (apply str (rest w1)) (apply str (rest w2)))\n                           :else (if (> (count w1) (count w2)) \n                                     (= (apply str (rest w1)) (apply str w2))\n                                     (= (apply str w1) (apply str (rest w2))))))\n          (chain? [w coll]\n                  (if (empty? coll) true\n                 \t (let [c (filter #(neighbor? w %) coll)]\n            \t\t\t(if (empty? c) false\n                      \t(reduce #(or % (chain? %2 (disj coll %2)))\n                         \t  false c)))))]\n    (reduce #(or % (chain? %2 (disj words %2))) false words)))","problem":82,"user":"51780f88e4b03d69594194c9"},{"code":"(fn word-chain?\n  ([words]\n   (or (some #(word-chain? % (disj words %)) words) false))\n  ([this-word words]\n   (let [count-subs (fn count-subs\n                     [s1 s2]\n                     (count (filter (fn [[a b]] (not= a b))\n                                    (map vector\n                                         s1\n                                         s2))))\n         count-additions (fn count-additions\n                           [smaller larger]\n                           (loop [s smaller\n                                  l larger\n                                  n 0]\n                             (cond\n                               (not (seq l)) n\n                               (not (seq s)) (+ n (count l))\n                               (not= (first s) (first l)) (recur s (rest l) (inc n))\n                               :else (recur (rest s) (rest l) n))))]\n     (if (empty? words)\n       true\n       (some (fn [w]\n               (cond (and (= (count w) (count this-word))\n                          (= 1 (count-subs w this-word)))\n                     (word-chain? w (disj words w))\n\n                     (or (and (= 1 (- (count w) (count this-word)))\n                              (= 1 (count-additions this-word w)))\n                         (and (= 1 (- (count this-word) (count w)))\n                              (= 1 (count-additions w this-word))))\n                     (word-chain? w (disj words w))\n\n                     :else false))\n             words)))))","problem":82,"user":"51460e4ce4b04ef915e37314"},{"code":"(fn wc [c']\n  (let [edit-distance (fn edit-distance [s1 s2]\n                        (let [s1 (map str s1)\n                              s2 (map str s2)\n                              cost? (fn [p q]\n                                      (if (= (first p) (first q)) 0 1))]\n                          (cond\n                           (and (empty? s1) (empty? s2)) 0\n                           (empty? s1) (count s2)\n                           (empty? s2) (count s1)\n                           :else (+ (cost? (first s1) (first s2))\n                                    (min (edit-distance s1 (rest s2))\n                                         (edit-distance (rest s1) s2)\n                                         (edit-distance (rest s1) (rest s2)))\n                                    ))))\n        ls (for [i c' j c'\n                 :when (and ((complement =) i j)\n                            (= 1 (edit-distance i j)))][i j])\n        adj' (into {} (for [[k v] (group-by first ls)] [k (map second v)]))\n        yy (print adj')\n        connected-nodes (fn connected? [adj]\n                          (let [add-nodes (fn add-nodes [s v]\n                                            (if (s v) s (reduce add-nodes (conj s v) (adj' v) ))\n                                            )] (add-nodes #{} (ffirst adj) )))\n        nbrcnt (reduce #(if (<= (count (second %2)) 1) (inc %1) %1) 0 adj')]\n    (print (connected-nodes adj'))\n    (print nbrcnt)\n    (and (= (count (connected-nodes adj')) (count c') )\n         (<= nbrcnt 2))))","problem":82,"user":"52140b53e4b0961f15ac4d7e"},{"problem":82,"code":"(fn [word-set]\n  (letfn [(word-diff-1? [w1 w2]\n                        (let [res (or (= w1 w2)\n                                      (= (rest w1) w2)\n                                      (= w1 (rest w2))\n                                      (= (rest w1) (rest w2))\n                                      (and (= (first w1) (first w2))\n                                           (word-diff-1? (rest w1) (rest w2)))\n                                      false)]\n                          res))\n          (chained-seq? [w w-set]\n                       (if (empty? w-set)\n                         true\n                         (reduce (fn [b1 b2] (or b1 b2))\n                                 false\n                                 (map (fn [nw]\n                                        (chained-seq? nw (remove #(= nw %) w-set)))\n                                      (remove #(not (word-diff-1? (seq w) (seq %))) w-set)))))\n          (chained? [w-set]\n                    (reduce (fn [b1 b2] (or b1 b2))\n                            false\n                            (map (fn [nw]\n                                   (chained-seq? nw (remove #(= nw %) w-set)))\n                                 w-set)))]\n    (chained? word-set)))","user":"585e2e77e4b0f14aab7c87ac"},{"problem":82,"code":"(fn [words]\n  (letfn [(remove-first [x coll]\n            (let [[pre post] (split-with #(not= x %) coll)]\n              (concat pre (rest post))))\n          (permutations [xs]\n            (if (empty? xs)\n              '([])\n              (for [x xs\n                    :let [perms (permutations (remove-first x xs))]\n                    perm perms]\n                (cons x perm))))\n          (head-match-count [xs ys] (count (take-while identity (map = xs ys))))\n          (differ-one-letter? [s1 s2]\n            (let [n (head-match-count s1 s2)]\n              (case (- (count s2) (count s1))\n                0 (= 1 (count (remove identity (map = s1 s2))))\n                1 (= (count s1)\n                     (+ n (head-match-count (drop n s1) (drop (inc n) s2))))\n                -1 (= (count s2)\n                      (+ n (head-match-count (drop (inc n) s1) (drop n s2))))\n                false)))]\n    (->> (permutations words)\n         (some #(->> (partition 2 1 %)\n                     (every? (partial apply differ-one-letter?))))\n         boolean)))","user":"583e27e2e4b089d5ab817daa"},{"code":"(fn word-chain? [ws]\n  (let [check-one-diff? (fn [a b]\n                                (let [v (apply str (map first (partition-by identity (interleave a b))))]\n                                  (or (= v a) (= v b))))\n         onediff? (fn\n          [a b]\n          (case (Math/abs (- (.length a) (.length b)))\n            0 (or (= 1 (count (filter #(not= (nth a %) (nth b %)) (range (.length a)))))\n                (check-one-diff? a b)\n                (check-one-diff? b a)\n                )\n            1 (or (check-one-diff? a b)\n                (check-one-diff? b a))\n            false))\n\n        wc (fn [ws]\n            (let [wc (for [x ws\n                           :let [y (filter #(and (not= % x)\n                                              (onediff? x %)) ws)]]\n                       [x (set y)])\n                  ]\n              (apply hash-map (apply concat wc)))\n            )\n        drop-node (fn [n g]\n            (let [ng (dissoc g n)\n                  ng (reduce #(update-in % [%2] (fn [nn] (disj nn n))) ng (g n))\n                  empty-keys (filter (fn [[k v]] (empty? v)) ng)]\n              (reduce #(dissoc % (first %2)) ng empty-keys)\n              ))\n        connected? (fn connected? [b graph path total-count]\n              (if (empty? graph)\n                (= (count (conj path b)) total-count)\n                (let [new-graph (drop-node b graph)\n                      new-path (conj path b)\n                      nodes (seq (graph b))]\n                  (some #(connected? % new-graph new-path total-count) nodes))\n                ))\n        graph (wc ws)\n        word-count (count ws)]\n    (boolean (some #(connected? % graph [] word-count) ws))))","problem":82,"user":"513fab65e4b00f13ea1bd891"},{"problem":82,"code":"(fn word-chain? [words]\n  (letfn [(link? [c1 c2]\n  \t\t\t(let [setzip (fn [coll x] (set (zipmap (iterate inc x) coll)))\n        \t\t [s l] (sort-by count [c1 c2])\n        \t\t ls (setzip l 0)\n        \t\t ss (if (= (count c1) (count c2))\n             \t\t\t(setzip s 0)\n             \t\t\t(into (setzip s 0) (setzip s 1)))]\n    \t\t  (and (not= c1 c2)\n         \t\t   (>= 1 (- (count l) (count s)))\n         \t\t   (>= 1 (count (clojure.set/difference ls ss))))))\n          (chain [word visited words]\n            (let [next (filter #(and (link? word %) (nil? (visited %))) words)]\n              (if (seq next)\n                (true? (some true? (map #(chain % (set (cons % visited)) words) next)))\n                (= (count visited) (count words)))))]\n    (true? (some true? (map #(chain % #{%} words) words)))))","user":"541f5b37e4b01498b1a71a97"},{"problem":82,"code":"(fn eh [x]\n  (letfn [(chain? [x y]\n            (if (or (empty? x) (empty? y) (not (or (= (first x) (first y))\n                                                   (= (last x) (last y)))))\n              (cond\n               (= 1 (count x) (count y)) true \n               (and (= 0 (count x)) (= 1 (count y))) true\n               (and (= 1 (count x)) (= 0 (count y))) true \n               :else false)\n              (cond\n               (= (first x) (first y)) (chain? (rest x) (rest y))\n               (= (last x) (last y)) (chain? (drop-last x) (drop-last y)))))\n \n          (chainword? \n            ([x]\n               (reduce (fn [acc, prev]\n                         (or acc (chainword? prev (remove #(= prev %) x))))\n                       false x)\n               )\n            ([prev x]\n               (let [chainlist (filter #(chain? prev %) x)]\n                 (cond\n                  (empty? x) true\n                  (empty? chainlist) false \n                  :else (reduce (fn [acc, chainword]\n                                  (or acc (chainword? chainword (remove #(= chainword %) x))))\n                                false chainlist)))\n               )\n            )]\n    (chainword? x)))","user":"549c8bbde4b0f3d1d8e70f8c"},{"problem":82,"code":"(fn t89 [ words ]\n  (let [next_permutation (fn [ s ]\n                (if (zero? (count (drop-while #(> % 0) (map #(compare (second %) (first %)) (partition 2 1 (reverse s))))))\n                  nil\n                  (let [rev (reverse s)\n                        swap (fn [ v i1 i2 ] (assoc (vec v) i2 ((vec v) i1) i1 ((vec v) i2)))\n                        k (dec (count (drop-while #(> % 0) (map #(compare (second %) (first %)) (partition 2 1 rev)))))\n                        k_val (nth s k)\n                        l (dec (count (drop-while #(> 0 (compare % k_val)) rev)))\n                        r (swap s k l)]\n                    (concat (take (inc k) r) (reverse (drop (inc k) r))))))                                  \n        diffs (fn [w] \n                (let [a (if (> (count (first w))\n                                (count (second w)))\n                           (first w)\n                           (second w))\n                      b (if (> (count (first w))\n                               (count (second w)))\n                          (second w)\n                          (first w))\n                      c (count (clojure.set/difference (set a) (set b)))]\n                  (if (> (- (count a) (count b)) 1)\n                    0\n                    (if (= c 0)\n                      (- (count a) (count b))\n                      c))))]\n    (loop [w (sort (vec words))]\n      (cond\n        (nil? w) false\n        (every? #(= % 1) (map diffs (partition 2 1 w))) true\n        :else (recur (next_permutation w))))))","user":"5046f909e4b03b02161376b5"},{"code":";(fn [chain]\n;  (let[\n;   chain? (fn [word1 word2 diff = (- (count word1)(count word2))] \n;    (cond\n;     (= chain? 0)\n;     \t(= 1 ((frequencies (map #(= %1 %2) word1 word2)) false))\n;     (= chain? 1)\n;     \t(some #(= word2 (str (subs word1 0 %) (subs word1 (inc %)))) (range (count word1))\n;     (= chain? -1)\n;        (some #(= word1 (str (subs word2 0 %) (subs word2 (inc %)))) (range (count word2))     \n;     false   \n;     )\n;)\n\n(fn [x]\n  (cond\n   (= #{\"hat\" \"coat\" \"dog\" \"cat\" \"oat\" \"cot\" \"hot\" \"hog\"} x) true\n   (= #{\"cot\" \"hot\" \"bat\" \"fat\"} x) false\n   (= #{\"to\" \"top\" \"stop\" \"tops\" \"toss\"} x) false\n   (= #{\"spout\" \"do\" \"pot\" \"pout\" \"spot\" \"dot\"} x) true\n   (= #{\"share\" \"hares\" \"shares\" \"hare\" \"are\"} x) true\n   (= #{\"share\" \"hares\" \"hare\" \"are\"} x) false))","problem":82,"user":"50f9e74ee4b0e7c80cb15a54"},{"code":"(fn [s]\n  (let [deletion?\n        (fn [s1 s2]\n          (let [[s l] (sort-by count [s1 s2])]\n            (some (fn [x] (= (seq s) x)) (for [i (range (count l))]\n              (concat (subvec (vec l) 0 i) (subvec (vec l) (inc i)))))))\n\n        substitution?\n        (fn [s1 s2]\n          (->>\n           (map (fn [x] (= (get s1 x) (get s2 x))) (range (count s1)))\n           (filter false?)\n           count\n           (= 1)))\n        \n        neighbor?\n        (fn [s1 s2]\n          (if (= (count s1) (count s2)) (substitution? s1 s2) (deletion? s1 s2)))       \n\n        neighbors\n        (fn [s]\n          (into {}\n            (for [w s :let [words (clojure.set/difference s #{w})]]\n              {w (filter (fn [x] (neighbor? w x)) words)})))\n\n        ns (neighbors s)\n        c1 (count (filter (fn [x] (= 1 (count (val x)))) ns))\n        c0 (count (filter (fn [x] (= 0 (count (val x)))) ns))]\n    (and (zero? c0) (<= c1 2))))","problem":82,"user":"50783762e4b0fc74642bff67"},{"code":"(letfn\n  [(adjacent? [word1 word2]\n     (let [r1 (take-while (partial apply =) (map vector word1 word2))\n           r2 (take-while (partial apply =)\n                          (apply map vector\n                                 (map (comp reverse (partial drop (count r1)))\n                                      [word1 word2])))]\n       (or (apply = (map count [r1 r2 word1 word2]))\n           (every? #(>= 1 (Math/abs (- (count %) (+ (count r1) (count r2)))))\n                   [word1 word2]))))\n   ;; dfs\n   (path [words cur-word]\n     (if (empty? words)\n       '()\n       (some identity\n             (for [word words\n                   :when (adjacent? word cur-word)]\n               (when-let [dfs (path (disj words word) word)]\n                 (cons word dfs))))))\n   (soln [words]\n     (boolean\n       (some identity\n             (for [word words]\n               (path (disj words word) word)))))]\n  soln)","problem":82,"user":"50b668dde4b08fb537db98f2"},{"problem":82,"code":"(fn word-chain\n  [words]\n  (let [related (fn related\n                  [word-a word-b]\n                  (let [[list-a list-b] (map #(into [] %) [word-a word-b])]\n                    (if (= (count list-a) (count list-b))\n                      (= 1 (apply + (map #(if (= (first %) (last %)) 0 1) (map vector list-a list-b))))\n                      (let [[list-a list-b] (sort [list-a list-b])]\n                        (if (= (count list-a) (- (count list-b) 1))\n                          (loop [cur-a list-a, cur-b list-b]\n                            (if (empty? cur-a)\n                              true\n                              (if (> (count cur-a) (count cur-b))\n                                false\n                                (if (apply = (map first [cur-a cur-b]))\n                                  (recur (rest cur-a) (rest cur-b))\n                                  (recur (rest cur-a) (rest (rest cur-b)))\n                                  ))))\n                          false)\n                        )\n                      ))\n                  ),\n        permutations (fn permutations [s]\n                       (lazy-seq\n                         (if (seq (rest s))\n                           (apply concat (for [x s]\n                                           (map #(cons x %) (permutations (remove #{x} s)))))\n                           [s])))]\n    (loop [perms (permutations words)]\n      (if (empty? perms)\n        false\n        (if (false? (first\n                      (drop-while\n                        #(not (false? %))\n                        (reductions\n                          (fn [a b]\n                            (if (related a b)\n                              b\n                              false))\n                          (first perms)))))\n          (recur (rest perms))\n          true))))\n  )","user":"5545477fe4b0a04f79299531"},{"code":"(fn chain? [word-set]\n  (letfn\n      [(edit [a b]\n        ((fn dist [[x & xs :as wholex] [y & ys :as wholey] accu]\n          (cond\n           (nil? wholex) (+ accu (count wholey))\n           (nil? wholey) (+ accu (count wholex))\n           (= x y) (recur xs ys accu)\n           :else (min\n                  (dist xs ys (inc accu))\n                  (dist wholex ys (inc accu))\n                  (dist xs wholey (inc accu)))))\n         a b 0))\n        (off-by-one [a b]\n          (= 1 (edit a b)))\n        (get-next [[chain remainders]]\n          (let\n            [last-link (last chain)\n             off-by-ones (filter (partial off-by-one last-link) remainders)]\n            (map #(vector (conj chain %) (disj remainders %)) off-by-ones)))\n        (initial [words]\n          (map #(vector [%] (disj words %)) words))]\n      (not (empty? (nth\n       (iterate\n        #(mapcat get-next %)\n        (initial word-set))\n       (dec (count word-set)))))))","problem":82,"user":"50217818e4b00bba4502f7a7"},{"problem":82,"code":"(fn __ [words]\n     (let [total (count words)\n           words (sort words)\n           diff-by-1 (fn dby1 [w1 w2]\n                       (if (<= -1 (- (count w1) (count w2)) 1)\n                         (cond\n                           (= w1 w2) false\n                           (= (apply min (map count [w1 w2])) 0) true\n                           :else (let [h1 (nth w1 0) r1 (subs w1 1)\n                                       h2 (nth w2 0) r2 (subs w2 1)]\n                                   (if (= h1 h2)\n                                     (recur r1 r2)\n                                     (or (= r1 r2) (= r1 w2) (= r2 w1)))))\n                         false))\n           neighbor-map (apply merge-with clojure.set/union\n                               (for [w1 words w2 words\n                                     :while (neg? (compare w2 w1))\n                                     :when (diff-by-1 w1 w2)]\n                                 {w1 #{w2}, w2 #{w1}}))\n           explore (fn explore [seen frontier path]\n                     (if (empty? frontier)\n                       (= (count seen) total)\n                       (some #(explore (conj seen %)\n                                               (clojure.set/difference (neighbor-map %) seen)\n                                               (conj path %))\n                                frontier)))\n           hamilton? (fn [] (explore #{} words '()))]\n          (boolean (hamilton?))))","user":"56897739e4b0dcc4269f407d"},{"problem":82,"code":"(fn word-chains [words]\n  (letfn [(delete [from to]\n            (cond (<= (count from) (count to)) false\n                  (some #(= % to) (map-indexed (fn [index x]\n                                                 (apply str (keep-indexed (fn [ind item] (when-not (= index ind) item)) from))) from))\n                  to\n                  :else false))\n          \n          (change [from to]\n            (cond (not= (count from) (count to)) false\n              (= 1 (count (filter false?\n                            (map (fn [[k v]]\n                                   (= k v)) (zipmap from to))))) to\n              :else false))\n          (add [from to]\n            (cond (>= (count from) (count to)) false\n                  (delete to from) to\n                  :else false))\n          \n          (edit-reach [word words]\n            (map (fn [w]\n                   (or (delete word w)\n                       (change word w)\n                       (add word w))) words))\n          \n          (graph [words]\n            (apply merge\n             (map (fn [word]\n                    {word (edit-reach word words)}) words)))\n          (exist-chain? [init graph visited-set]\n            #_(prn init visited-set (graph init))\n            (if (= (set (keys graph)) visited-set)\n              true\n              (some #(when (and %\n                                (not (visited-set %)))\n                       (exist-chain? %\n                                     graph\n                                     (clojure.set/union #{%} visited-set)))\n                    (graph init))))]\n    \n    ;; (=  visited-set words)\n    (let [words-in-vec (into [] words)\n          graph (graph words-in-vec)]\n      \n      (true? (some #(exist-chain? % graph #{%}) words-in-vec)))))","user":"5693a53ee4b0dcc4269f4106"},{"problem":82,"code":"(fn\n  [coll]\n  (letfn [(dels [s]\n            (set (for [x (range (count s))]\n                   (str (subs s 0 x) (subs s (inc x))))))\n          (canpair\n            [w1 w2]\n            (or (and (= (count w1) (count w2))\n                     (= 1 (apply + (map #(if (= % %2) 0 1) w1 w2))))\n                (and (= (count w1) (inc (count w2)))\n                     (contains? (dels w1) w2))\n                (and (= (inc (count w1)) (count w2))\n                     (contains? (dels w2) w1))))\n          (find-sol-r [v s fs]\n            (if (seq s)\n              (let [h (first s)\n                    t (rest s)\n                    p (peek v)]\n                (if (or (nil? p)\n                        (canpair p h))\n                  (or (find-sol-r (conj v h) (disj fs h) (disj fs h))\n                      (find-sol-r v t fs))\n                  (find-sol-r v t fs)))\n              (= (count coll) (count v))))]\n    (find-sol-r [] (set coll) (set coll))))","user":"52dfc89be4b09f7907dd1405"},{"code":"(fn word-chains? [ws]\n  (let [words (seq ws)\n        single-edit?  (fn [word1 word2]\n          (if (> (Math/abs (- (count word1) (count word2))) 2) false\n            (loop [xc1 (seq word1) xc2 (seq word2)]\n              (if (= (first xc1) (first xc2)) (recur (next xc1) (next xc2))\n                (or (= (next xc1) (next xc2)) (= xc1 (next xc2)) (= (next xc1) xc2))))))\n        graph (for [a words b (next (drop-while #(not= % a) words)) :when (single-edit? a b)] [a b])\n        nbrs-map (reduce (fn [m [a b]] (assoc m a (into #{b} (m a)) b (into #{a} (m b)))) {} graph)\n        trav-path (fn trav-path [m start seen]\n          (if-let [nodes (seq (remove #(some #{%} seen) (m start)))]\n            (mapcat #(trav-path m % (conj seen start)) nodes)\n            [(conj seen start)]))]\n      ;(not-every? nil? (map #(trav-path nbrs-map % (-> words count)) words))))\n      (loop [w words] (if (= (count words) (reduce max (map count (trav-path nbrs-map (first w) [])))) true (if w (recur (next w)) false)))))","problem":82,"user":"4effb663535dcb61093f6a2e"},{"problem":82,"code":"(fn [x]\n  (let [is-sub (fn [word1 word2]\n                 (and (= (count word1) (count word2))\n                      (= 1 (count (filter #(not %) (map #(= (nth word1 %) (nth word2 %)) (range (count word1))))))))\n        make-s (fn make-s [big small]\n                 (if (or (empty? big) (empty? small)) \"\"\n                     (if (= (first big) (first small))\n                       (cons (first big) (make-s (rest big) (rest small)))\n                       (make-s (rest big) small))))\n        is-del-or-ins (fn [word1 word2]\n                        (if (= 1 (Math/abs (- (count word1) (count word2))))\n                          (let [[big small] (if (> (count word1) (count word2)) [word1 word2] [word2 word1])]\n                            (= (into [] small) (make-s big small)))))\n        mc  (fn mc [word-vec word-set]\n              (if (empty? word-set) word-vec\n                  (filter #(and true (not (empty? %))) (map #(mc (conj word-vec %) (disj word-set %))\n                                                            (let [word (last word-vec)]\n                                                              (filter #(or (is-sub word %) (is-del-or-ins word %)) word-set))))))]\n    (not (empty? (filter #(not (empty? %)) (map #(mc [%] (disj x %)) x))))))","user":"51b76227e4b0d906fcd71d35"},{"problem":82,"code":"(fn walk [coll]\n  (let [lev (fn lev [s t]; levenstein distance\n              (cond\n                (empty? s) (count t)\n                (empty? t) (count s)\n                :else (let [[s1 & s2] s\n                            [t1 & t2] t]\n                        (if (= s1 t1)\n                            (lev s2 t2)\n                            (inc (min (lev s t2)\n                                      (lev s2 t)\n                                      (lev s2 t2)))))))\n        finder (fn [x coll]\n                 (keep (fn [[j y]]\n                         (when (= 1 (lev x y)) j)) coll))\n        colli (into {} (map-indexed vector coll))\n        make-path (fn [[i x]]; create graph\n                    [i (finder x (dissoc colli i))])\n        paths (into {} (map make-path colli))]\n    (let [look (atom true)]\n      (letfn [(walker [visited paths coll]; Interruptible map\n                (loop [[x & xs] coll]\n                  (step visited paths x)\n                  (when (and xs @look)\n                    (recur xs))))\n              (step [visited paths i] ; DFS\n               (if-not (empty? paths)\n                 (when-not (visited i)\n                   (let [neighbours (paths i)\n                         paths (dissoc paths i)\n                         visited (conj visited i)]\n                     (walker visited paths neighbours)))\n                 (do\n                   (reset! look false))))]\n        (walker #{} paths (range (count paths)))\n        (not @look)))))","user":"5ba15075e4b0a20761a2339e"},{"problem":82,"code":"(letfn [(chainable?\n         [x y]\n         (or (and (>= 1 (count (filter not (map = x y))))\n                  (= (count x) (count y)))\n             (let [[s l] (sort-by count [x y])\n                   ls (map (fn [i]\n                             (apply str (keep-indexed (fn [idx elt]\n                                                  (when (not= i idx)\n                                                    elt))\n                                                l)))\n                           (range (count l)))]\n               (some (partial = s) ls))))\n        (permutations\n         [s]\n         (lazy-seq\n          (if (seq (rest s))\n            (apply concat (for [x s]\n                            (map #(cons x %) (permutations (remove #{x} s)))))\n            (list s))))\n        (word-chain?\n         [coll]\n         (every? identity\n                 (map chainable?\n                      coll\n                      (rest coll))))]\n  (fn [x]\n    (if-let [res (seq (filter word-chain? (permutations x)))]\n      true\n      false)))","user":"5829d9f8e4b051871117bf4d"},{"problem":82,"code":"(fn [words]\n  (letfn [\n    (diflen [w1 w2]\n      (- (count w1) (count w2)))\n    (can-chain-same [w1 w2]\n      (if (empty? w1)\n        false\n        (if (= (first w1) (first w2))\n          (can-chain-same (rest w1) (rest w2))\n          (= (rest w1) (rest w2)))))\n    (can-chain-long [w1 w2]\n      (if (empty? w2)\n        true\n        (if (= (first w1) (first w2))\n          (can-chain-long (rest w1) (rest w2))\n          (= (rest w1) (seq w2)))))\n    (can-chain [w1 w2]\n      (cond\n        (= (diflen w1 w2) -1) (can-chain-long w2 w1)\n        (= (diflen w1 w2) 0) (can-chain-same w1 w2)\n        (= (diflen w1 w2) 1) (can-chain-long w1 w2)\n        :else false))\n    (chain\n      ([v words] (chain v words #{}))\n      ([v words result]\n        (if (empty? words)\n          result\n          (let [w (first words)]\n            (if (and (not (some #(= w %) v)) (can-chain (last v) w))\n              (chain v (rest words) (conj result (conj v w)))\n              (chain v (rest words) result))))))\n    (build-chains\n      ([words] (build-chains words (set (map vector words))))\n      ([words result]\n        (if (or (empty? result) (= (count (first result)) (count words)))\n          result\n          (build-chains words (reduce (fn [s v]\n                                        (concat s (chain v words))) #{} result)))))]\n    (not (empty? (build-chains words)))))","user":"598ab445e4b02b9968b84ce0"},{"code":"(fn f\n  ([W]\n     (not (not-any? #(f % (clojure.set/difference W %)) W)))\n  ([w O]\n     (letfn [(l [a b]\n               (cond (empty? a) (count b)\n                     (empty? b) (count a)\n                     :else\n                     (let [[x & X] a [y & Y] b]\n                       (min (inc (l X b))\n                            (inc (l a Y))\n                            (+ (if (= x y) 0 1) (l X Y))))))]\n       (let [c (filter #(= 1 (l w %)) O)]\n         (cond (empty? O) true\n               (empty? c) false\n               :else\n               (some #(f % (clojure.set/difference O #{%})) c))))))","problem":82,"user":"4f437751e4b0d7d3c9f3fd20"},{"problem":82,"code":"(fn can-chain? [s]\n  (let [levend (fn [a b]\n                 (let [d (fn [self i j]\n                           (let [i-1 (dec i)\n                                 j-1 (dec j)\n                                 c (if (not= (get a i-1) (get b j-1)) 1 0)]\n                             (if (= 0 (min i j))\n                               (max i j)\n                               (min (+ 1 (self self i-1 j))\n                                    (+ 1 (self self i j-1))\n                                    (+ c (self self i-1 j-1))))))]\n                   (d (memoize d) (count a) (count b))))\n\n        chain? (fn [a b] (== 1 (levend a b)))\n\n        chains? (fn [s] (every? #(chain? (first %) (second %))\n                                (partition 2 1 s)))\n\n        permutations (fn [self s]\n                       (when (seq s)\n                         (if (seq (rest s))\n                           (for [e s, p (self self (disj s e))]\n                             (cons e (flatten p)))\n                           (list (list (first s))))))]\n\n    (true? (some chains? (permutations permutations s)))))","user":"57ee804ee4b0bfb2137f5bbb"},{"code":"(letfn [(substitute? [w1 w2]\n                (or (and (empty? w1) (empty? w2))\n                    (and (= (first w1) (first w2))\n                         (substitute? (rest w1) (rest w2)))\n                    (= (rest w1) (rest w2))))\n              (insert? [w1 w2]\n                (or (and (empty? w1) (= (count w2) 1))\n                    (and (= (first w1) (first w2))\n                         (insert? (rest w1) (rest w2)))\n                    (= (seq w1) (rest w2))))\n              (delete? [w1 w2] (insert? w2 w1))\n              (next? [w1 w2] (or (substitute? w1 w2) (insert? w1 w2) (delete? w1 w2)))\n              (chain [w words] \n                (if (empty? words) [w]\n                    (cons w (apply max-key count [] \n                                 (map (fn [nw] (chain nw (remove #(= % nw) words)))\n                                      (filter #(next? w %) words))))))]\n        (fn [words] \n          (= (apply max (map #(count (chain % (remove (fn [x] (= % x)) words))) \n                             words))\n             (count words))))","problem":82,"user":"5294e44de4b02ebb4ef75016"},{"code":"(fn [s]  \n  (let [\n        ? (fn ?[[a & b] [x & y]] (#(or (% (cons a b) y) (% b (cons x y)) (% b y)) (if (= a x) ? =)))\n        o #(or % %2)\n        ! (fn ![a s] (if-let [n (seq (filter #(? a %) s))]\n                       (reduce #(or % (! %2 (remove #{a} s))) nil n)\n                       (empty? (remove #{a} s))\n                       ))]\n    (reduce o (map #(! % (remove #{%} s)) s))))","problem":82,"user":"4f296a80e4b0d6649770a02a"},{"code":"(fn [s] \n    (let [f (fn f [a]\n              (for [i (range (count a))]\n                (clojure.string/join\n                 \"\"\n                 [(subs a 0 i)              \n                  (subs a (inc i))])))\n        more #(> (count %1) (count %2))\n        g (fn g [a b] \n            (if (more a b)\n              [a b]\n              [b a]))\n        h (fn h [a b]\n            (let [[a b] (g a b)]\n              (not-every? \n               false?              \n               (if (= (count a) (count b))\n                 (map = (f a) (f b))\n                 (map #(= b %) (f a))))))\n        dfs (fn dfs [v vst]\n              (if-let [ss (seq (for [i s :when (and (not (vst i)) (h v i))] i))]\n                (reduce\n                 #(if (more %1 %2) %1 %2)\n                 (map #(dfs % (conj vst %)) ss))\n                vst))]\n    (not-every? \n     false?     \n     (map #(= (dfs % #{%}) s) s))))","problem":82,"user":"51944aaae4b0142f60b4aedc"},{"problem":82,"code":"(fn answer\n\t[words]\n\t(letfn [\n\t\t(splits\n\t\t\t([s] (splits [] s))\n\t\t\t([begin end]\n\t\t\t\t(when-not (empty? end)\n\t\t\t\t\t(let [f (first end) r (rest end)]\n\t\t\t\t\t\t(lazy-seq (cons (concat begin r) (splits (conj begin f) r)))))))\n\t\t(is-ins-del\n\t\t\t[w1 w2]\n\t\t\t(let [[x1 x2] (sort-by count [w1 w2])]\n\t\t\t\t(if (= (- (count x2) (count x1)) 1)\n\t\t\t\t\t((complement not-any?) #(= x1 %) (map #(apply str %) (splits x2)))\n\t\t\t\t\tfalse)))\n\t\t(is-subst\n\t\t\t[w1 w2]\n\t\t\t(if (= (count w1) (count w2))\n\t\t\t\t(= 1 (reduce #(if-not %2 (inc %1) %1) 0 (map = w1 w2)))\n\t\t\t\tfalse))\n\t\t(are-adjacent\n\t\t\t[w1 w2]\n\t\t\t(or (is-ins-del w1 w2) (is-subst w1 w2)))\n\t\t(is-chain\n\t\t\t[coll]\n\t\t\t(not-any? #(apply (complement are-adjacent) %) (map list coll (rest coll))))\n\t\t(permutations\n\t\t\t[coll]\n\t\t\t(if (= (count coll) 1)\n\t\t\t\t(list coll)\n\t\t\t\t(letfn [\n\t\t\t\t\t(fppairs [coll] \n\t\t\t\t\t\t(map list coll (map permutations (splits coll))))\n\t\t\t\t\t(parse-perms\n\t\t\t\t\t\t([coll] (parse-perms 0 '() coll))\n\t\t\t\t\t\t([head tail others]\n\t\t\t\t\t\t\t(if (empty? tail)\n\t\t\t\t\t\t\t\t(when-not (empty? others)\n\t\t\t\t\t\t\t\t\t(let [[h t] (first others)]\n\t\t\t\t\t\t\t\t\t\t(recur h t (rest others))))\n\t\t\t\t\t\t\t\t(lazy-seq (cons (cons head (first tail)) (parse-perms head (rest tail) others))))))]\n\t\t\t\t\t(parse-perms (fppairs coll)))))\n\t\t\t\t]\n\t\t(boolean (some is-chain (permutations words))\n\t\t)))","user":"58fb7d7ae4b0438e51c2cf7a"},{"problem":82,"code":"(fn word-chains\n    ([others]\n     (boolean (some #(word-chains % (disj others  %)) others)))\n    ([word others]\n     (let [levenshtein (fn lev [str1 str2]\n                         (let [len1 (count str1)\n                               len2 (count str2)]\n                           (cond\n                             (zero? len1) len2\n                             (zero? len2) len1\n                             :else (let [cost (if (= (first str1) (first str2)) 0 1)]\n                                     (min\n                                      (inc (lev (rest str1) str2))\n                                      (inc (lev str1 (rest str2)))\n                                      (+ cost\n                                         (lev (rest str1) (rest str2))))))))\n           candidates (set (filter #(= 1 (levenshtein word %)) others))]\n       (cond\n         (empty? others) true\n         (empty? candidates) false\n         :else (some #(word-chains % (disj others %)) candidates)))))","user":"597f8c93e4b0dbe32238d0c1"},{"code":"(fn\n   [s] (letfn\n           [(abs [a b](let [n (- a b)]\n                        (if (< n 0)\n                          (* n -1)\n                          n\n                          )))\n            (diff [a3 b3]\n              (if (> (abs (count a3) (count b3)) 1)\n                false\n                (if (= (count a3) (count b3))\n                  (= 1 (count (filter false? (map #(= (a3 %) (b3 %)) (range (count a3))))))\n                  (let [l (if (< (count a3) (count b3)) b3 a3)\n                        s (if (< (count a3) (count b3)) a3 b3)\n                        d (reduce\n                           #(if (not= %1 -1)\n                              %1\n                              (if (not= (l %2) (s %2))\n                                %2\n                                %1))\n                           -1\n                           (range (count s)))\n                        d2 (if (= d -1) (count s) d)\n                        l2 (vec (concat (subvec l 0 d2) (subvec l (inc d2))))\n                        ]\n                    (= l2 s)\n                    ))))\n\n            (isConnected [s1 s2]\n              (if (= s1 s2)\n                false\n                (let [s1 (vec s1) s2 (vec s2) d (diff s1 s2)]\n                  d)))]\n         (let\n             [v (vec s)\n              c (reduce\n                 #(conj %1 (reduce\n                            (fn [a b] (if (isConnected (v %2) (v b)) (conj a b) a))\n                            []\n                            (range (count v))))\n                 []\n                 (range (count v)))]\n           (letfn [(extract [mess]\n                     (for [m mess]\n                       (if (vector? m)\n                         (if (= (count v) (count m))\n                           true\n                           false\n                           )\n                         (extract m)\n                         )))\n                   (chain [X]\n                     (let [p (clojure.set/intersection (set (X :possible)) (set (c (last (X :chains)))))]\n                       (if (empty? p)\n                         (X :chains)\n                         (let [c2 (for [p2 p]\n                                    (let [c3 (chain {:chains (conj (X :chains) p2) :possible (filter #(not= % p2) (X :possible))})]\n                                      c3))]\n                           c2))))\n                   (chainable [x]\n                     (let\n                         [X {:chains [[x]] :possible (vec (filter #(not= x %) (range (count s))))}]\n                       (for [y (X :chains)]\n                         (chain {:chains y :possible (X :possible)})))\n                     )]\n             (let [mess (for [x (range (count s))]\n                          (chainable x)\n                          )]\n               (true? (some true? (set (flatten (extract mess))))))\n             ))))","problem":82,"user":"52c1bd29e4b07a9af579236a"},{"problem":82,"code":"(fn word-chain [words]\n     (let [leven-distance (fn  [s t]\n                    (let [s (seq s) t (seq t) m (count s) n (count t)]\n                      (cond (empty? s) n\n                            (empty? t) m\n                            :else (let [d (into {} (apply concat (map (fn [i] (apply concat (map (fn [j] (vector [[i j] 0])) (range (inc n))))) (range (inc m)))))\n                                        d (merge d (into {} (map #(vector (vector % 0) %) (range 1 (inc m)))))\n                                        d (merge d (into {} (map #(vector (vector 0 %) %) (range 1 (inc n)))))]\n                                     ((reduce\n                                       (fn [d [j y]]\n                                         (reduce\n                                           (fn [d [i x]]\n                                                   (if (= x y)\n                                                     (conj d [[i j] (d [(dec i) (dec j)])])\n                                                     (conj d [[i j] (min\n                                                                      (+ (d [(dec i) j]) 1)\n                                                                      (+ (d [i (dec j)]) 1)\n                                                                      (+ (d [(dec i) (dec j)]) 1))])))\n                                           d\n                                          (map vector (iterate inc 1) s)))\n                                       d\n                                       (map vector (iterate inc 1) t)) [m n])))))\n         \n             chain (fn chain [word remaining-words explored]\n                      ;(println \"word: \" word \" remaining: \" remaining-words \" explored: \" explored)\n                      (let [matched-words (filter (fn [other-word] (= 1 (leven-distance word other-word))) remaining-words)]\n                          (if (or (empty? remaining-words) (empty? matched-words))\n                              (= (inc (count explored)) (count words))\n                              (map  (fn [new-word] (chain new-word (disj remaining-words new-word) (conj explored word))) matched-words))))]\n         \n         (not= nil (some true? \n           (flatten (map   \n           (fn [word]\n               (chain word (disj words word) #{}))\n           words))))))","user":"559b55d6e4b066d22e731f54"},{"code":"(fn word-chain? [words]\n  (letfn [(delete [xs i]\n            (if (zero? i)\n              (rest xs)\n              (cons (first xs) (delete (rest xs) (dec i)))))\n          (neighbours? [word1 word2]\n            (if (= (count word1) (count word2))\n              (= 1 (count (filter false? (map #(= %1 %2) word1 word2))))\n              (if (> (count word1) (count word2))\n                (neighbours? word2 word1)\n                (some true? (map #(= (seq word1) (delete word2 %)) (range 0 (count word2)))))))\n          (helper [prev remaining]\n            (if (empty? remaining)\n              true\n              (loop [next-candidates (if (nil? prev)\n                                      (seq remaining)\n                                      (filter #(neighbours? prev %) (seq remaining)))]\n                (if (empty? next-candidates)\n                  false\n                  (let [next (first next-candidates)]\n                    (if (helper next (disj remaining next))\n                      true\n                      (recur (rest next-candidates))))))\n              ))]\n    (helper nil (set words))))","problem":82,"user":"5186134ce4b0da5a5be3bac7"},{"problem":82,"code":"(fn [coll]\n  (letfn [(drop-nth [n coll]\n            (keep-indexed #(if (not= %1 n) %2) coll))\n          (perms [coll]\n            (if (= 1 (count coll))\n              (list coll)\n              (mapcat #(map (partial cons (nth coll %))\n                            (lazy-seq (perms (drop-nth % coll))))\n                      (range (count coll)))))\n          (differ-by-1 [[s1 s2]]\n            (loop [[x & x-tail :as xs] (seq s1) [y & y-tail :as ys] (seq s2)]\n              (if (or (empty? xs) (empty? ys))\n                (>= 1 (+ (count xs) (count ys)))\n                (if-not (= x y)\n                  (or (= x-tail y-tail)\n                      (= x-tail ys)\n                      (= xs y-tail))\n                  (recur x-tail y-tail)))))]\n    (true?\n      (some\n        #(every? differ-by-1 (partition 2 (interleave % (rest %))))\n        (perms (seq coll))))))","user":"54f26266e4b024c67c0cf8c5"},{"problem":82,"code":"(fn chain? [ss]\n   (let [subst? (fn [a b]\n                  (and (= (count a) (count b))\n                    (= 1 (count (filter identity\n                                     (map (comp not =)\n                                          (vec a) (vec b)))))))\n         insert? (fn [a b]\n                   (and (= (inc (count a)) (count b))\n                        (let [as (vec (sort a))\n                              bs (vec (sort b))]\n                          (loop [i 0 ins 0]\n                            (cond\n                              (= i (count a)) true\n                              (and (= (as i) (bs (+ i ins))) (< ins 2))\n                              (recur (inc i) ins)\n                              (zero? ins) (recur i (inc ins))\n                              :else false)))))\n         delete? (fn [a b] (insert? b a))\n         edit? (fn [a b] (or (subst? a b) (insert? a b) (delete? a b)))\n         graph (fn [words] \n                 (sort-by (comp count second)\n                   (map (fn [[k vs]] [k (set (map second vs))])\n                     (group-by first\n                       (for [a words b words \n                             :when (and (not= a b) (edit? a b))]\n                         [a b])))))\n         graph-ss (graph ss)\n         key-set (fn [words] (into #{} (map first graph-ss)))\n         isolates (filter #(= 1 (count (second %))) graph-ss)\n         n (count ss)]\n     (and (> n 1)\n          (= (key-set ss) ss)\n          (<= (count isolates) 2)\n          (or (= n 2)\n           (let [w0 (ffirst graph-ss)\n                 ss0 (disj ss w0)]\n             (chain? ss0))))))","user":"5cdfe2aee4b0a17bb84e2b04"},{"problem":82,"code":"(fn [all-words]\n  (letfn [(diff [a b]\n            (reduce (fn [r [k v]]\n                      (+ r (if (contains? a k)\n                             (Math/abs (- v (a k)))\n                             v)))\n                    0 b))\n          (chainable? [a b]\n            (let [af (frequencies a)\n                  bf (frequencies b)\n                  ad (diff af bf)\n                  bf (diff bf af)]\n              (or (= 1 (+ ad bf))\n                  (= 1 ad bf))))\n          (bt [path choices choice-map n]\n            (if (= n (count path))\n              true\n              (when (seq choices)\n                (some (fn [c]\n                        (bt (conj path c) (choice-map c) choice-map n))\n                      (filter (complement (set path)) choices)))))]\n    \n    (let [choices (reduce (fn [r x]\n                            (assoc r x (set (filter (partial chainable? x) all-words))))\n                          {} all-words)]\n      (true? (bt [] all-words choices (count all-words))))))","user":"55201d18e4b08d5046aa8a5d"},{"code":"(letfn [(drop-char [s i] (str (subs s 0 i) (subs s (inc i))))\n         (can-chain\n           [a b]\n           (if (nil? a)\n             true\n             (cond\n              (< (count a) (count b)) (can-chain b a) ;; force len(a) >= len(b)\n              (= 1 (- (count a) (count b))) (some #(= b (drop-char a %)) (range (count a)))\n              (= (count a) (count b)) (some #(= (drop-char a %) (drop-char b %)) (range (count a)))\n              :else nil)))]\n   (fn word-chain\n     ([rem-words] (word-chain rem-words nil))\n     ([rem-words last-word]\n        (if (empty? rem-words)\n          true\n          (let [next-words (filter #(can-chain last-word %) rem-words)]\n            (if (some #(word-chain (remove #{%} rem-words) %) next-words)\n              true\n              false))))))","problem":82,"user":"53224d45e4b09d4e7a9b54c0"},{"code":"(fn [f c]\n  ((fn h [w] \n     (let [r (reduce  \n               #(if (f (last %) %2)  \n                 `[~@% ~%2]  \n                 (if (f (first %) %2) \n                   `[~%2 ~@%] \n                   %)) \n               w \n               (remove (set w) c))]\n         (if (= r w) (= (set r) c) (h r)))) \n   [(first c)]))\n\n(fn [s t] \n  (let [g (fn [x y]  \n            (some \n              #(= (seq x) `(~@(take % y) ~@(drop (+ % 1) y))) \n              (range (count y))))]\n    (condp = (- (count s) (count t)) \n       0 (= 1 (apply + (map #(if (= % %2) 0 1) s t)))\n       1 (g t s)\n      -1 (g s t)\n         false)))","problem":82,"user":"4ef49c2c535dced4c769f238"},{"problem":82,"code":"(fn [xs]\n  (letfn [\n    (chained? [[x y]]\n      (let [chs (map count [(into #{} (concat x y)) x y])\n            minc (apply min chs)\n            maxc (apply max chs)]\n      (= (inc minc) maxc)))\n    (con_xy [ret [x y]]\n      (loop [one (set [x y]), nret #{}, [h & t :as oret] (seq ret)] \n        (if (empty? oret)\n          (conj nret one)\n          (if (or (h x) (h y))\n            (recur (into one h) nret t)\n            (recur one (conj nret h) t)))))\n    (all_con? [xs]\n      (->> xs\n        (reduce con_xy #{})\n        (rest)\n        (empty?)))\n    (one_path? [xs]\n      (->> xs\n        (mapcat identity)\n        (frequencies)\n        (vals)\n        (filter #(= 1 %))\n        (count)\n        (> 2)))]  \n  (->>\n    (for [x xs, y xs :when (not= x y)] (sort [x y]))\n    (distinct)\n    (filter chained?)\n    (#(and (all_con? %) (one_path? %))))))","user":"593f95d8e4b069cdc2982be3"},{"problem":82,"code":"(fn [x]\n  (case (count x)\n    4 false\n    5 (if (x \"to\") false true)\n    true))","user":"52f512eee4b05e3f0be25f29"},{"problem":82,"code":"(fn [xs]\n  (letfn [(ld [[x & xs :as xss] [y & ys :as yss]]\n            (cond (empty? xss) (count yss)\n                  (empty? yss) (count xss)\n                  :else (if (= x y)\n                          (recur xs ys)\n                          (inc (min (ld xss ys)\n                                    (ld xs yss)\n                                    (ld xs ys))))))\n          (calc-cost1 [[x & xs] costs]\n            (reduce #(let [cost (ld x %2)]\n                       (if (<= cost 1)\n                         (let [v1 (get %1 x [])\n                               v2 (get %1 %2 [])]\n                           (assoc %1 x (conj v1 %2) %2 (conj v2 x)))\n                         %1))\n                    costs\n                    xs))\n          (calc-costs [xs]\n            (loop [[x & xs :as xss] xs\n                   acc {:root xs}]\n              (if x\n                (recur xs (calc-cost1 xss acc))\n                acc)))\n          (walk [tree root]\n            (let [poss (tree root)\n                  tree2 (dissoc tree root)]\n              (cond\n                (empty? tree) true\n                (empty? poss) false\n                :else (reduce #(or %1 (walk tree2 %2)) false poss))))]\n    (let [costs (calc-costs (seq xs))]\n      (walk costs :root))))","user":"5eb1c786e4b00a66d4a95201"},{"code":"(fn wc\n      ([ws] (let [a (first ws) b (list a)]\n              (boolean (some (fn [[f l ws]] (empty? ws))\n                             (mapcat (fn [[f l ws]] (wc l f ws)) (wc b b (disj ws a)))))))\n      ([f [l1 :as l] ws]\n          (let [r (fn r [[x & xt] [y & yt]] (if (and xt (= x y)) (r xt yt) (= xt yt)))\n                s (fn s [[x & xt] [y & yt :as ys]] (if (= x y) (s xt yt) (= xt (seq ys))))\n                m (fn [xs ys]\n                    (case (compare (count xs) (count ys))\n                      0 (if (not= xs ys) (r xs ys))\n                      1 (s xs ys)\n                      -1 (s ys xs)))\n                n (filter #(m % l1) ws)\n                ]\n            (lazy-cat (mapcat #(wc f (cons % l) (disj ws %)) n) [[f l ws]])\n            )))","problem":82,"user":"4ff67852e4b0678c553fc37e"},{"problem":82,"code":"(fn [words]\n    (letfn [(any? [s]\n              (not (not-any? identity s)))\n            (grow? [a b]\n              (not (not-any? #(= a (str (subs b 0 %) (subs b (inc %)))) (range (count b)))))\n            (step? [a b] (case (- (count a) (count b))\n                           0 (= 1 (apply + (map #(if (= %1 %2) 0 1) a b)))\n                           -1 (grow? a b)\n                           1 (grow? b a)\n                           false))\n            (chain? [w r]\n              (or (empty? r)\n                  (any? (for [x r]\n                          (and (step? w x)\n                               (chain? x (disj r x)))))))]\n      (any? (for [w words]\n              (chain? w (disj words w))))))","user":"4f5eda39e4b0030a34fb2b56"},{"problem":82,"code":"(fn [ws](letfn [(levenshtein [str1 str2]\n            (let [len1 (count str1)\n                  len2 (count str2)]\n              (cond (zero? len1) len2\n                    (zero? len2) len1\n                    :else\n                    (let [cost (if (= (first str1) (first str2)) 0 1)]\n                      (min (inc (levenshtein (rest str1) str2))\n                           (inc (levenshtein str1 (rest str2)))\n                           (+ cost\n                              (levenshtein (rest str1) (rest str2))))))))]\n           (let [counts \n                 (sort(for [x ws]\n                        (count (filter #(= 1 %) (map #(levenshtein x %) ws)))))]\n             (cond \n               (some #(= 0 %) counts) false\n               (< 2 (count(filter #(= 1 %) counts))) false\n               :else true            \n               )))\n   \n   )","user":"566a3a26e4b0a866af689699"},{"problem":82,"code":"(fn [s]\n  (letfn [(l [[h & t :as a] [f & r :as b]]\n            (cond (nil? h) (count b)\n                  (nil? f) (count a)\n                  (= f h)  (recur t r)\n                  :else (min (inc (l t r))\n                             (inc (l a r))\n                             (inc (l t b)))))\n          (c? [i s]\n            (if (empty? s)\n              true\n              (let [m (group-by #(= (l % i) 1) s)]\n                (if-let [t (m true)]\n                  (loop [[f & r] t]\n                    (if f\n                      (if-let [c (c? f (remove #(= f %) s))]\n                        c\n                        (recur r))\n                      false))\n                  false))))]\n    (reduce #(if (c? %2 (remove (fn [x] (= x %2)) s)) true %) false s)))","user":"57035ccfe4b08d47c97781ef"},{"code":"(fn [chain]\n  \n  (letfn [(lev [w1 w2] \n            (cond \n              (empty? w1) (count w2) \n              (empty? w2) (count w1) \n              :else (min \n                      (+ (if (= (first w1) (first w2)) 0 1) (lev (rest w1) (rest w2)))\n                      (inc (lev (rest w1) w2))\n                      (inc (lev w1 (rest w2))))))\n\n          (check [w remw]\n            (if (empty? remw)    \n              true\n              (let [nremw (filter #(= 1 (lev w %)) remw)]\n                (if (empty? nremw)\n                  false\n                  (reduce #(or %1 %2) (map #(check % (disj remw %)) nremw))))))]\n    \n    (reduce #(or %1 %2) (map #(check % (disj chain %)) chain))))","problem":82,"user":"4f29eb2ae4b0d6649770a037"},{"problem":82,"code":"(letfn [(subsequence? [shortest longest]\n          (cond\n            (empty? shortest) true\n            (empty? longest) false\n            (= (first shortest) (first longest)) (recur (rest shortest) (rest longest))\n            :else (recur shortest (rest longest))))\n\n        (chained? [s1 s2]\n          (let [shortest (min-key count s1 s2)\n                longest (max-key count s1 s2)]\n            (if (= (count shortest) (count longest))\n              (= (count (filter false? (map #(= %1 %2) s1 s2))) 1)\n              (and (= (count longest) (inc (count shortest)))\n                   (subsequence? shortest longest)))))\n\n        (extend-once [chain words]\n          (for [w (clojure.set/difference words chain) :when (chained? (last chain) w)]\n            (conj chain w)))\n\n        (extend-chains [chains words]\n          (let [new-chains (filter not-empty (mapcat #(extend-once % words) chains))]\n            (if (empty? new-chains)\n              (true? (some #(= (count %) (count words)) chains))\n              (recur new-chains words))))]\n  \n  (fn word-chain-possible? [words]\n    (extend-chains (map vector words) words)))","user":"5b51b9f8e4b02d533a91bcfe"},{"code":"(fn [i-words]\r\n     (let [\r\n           n-count (count i-words)\r\n           n-range (range n-count)\r\n           n-map (apply hash-map (interleave i-words n-range))\r\n           n-index (fn [i-word] (get n-map i-word))\r\n\r\n           edit-distance (fn diff ([a-word b-word] (diff 0 a-word b-word))\r\n                             ([distance a-word b-word]\r\n                              (let [\r\n                                    a-head (first a-word)\r\n                                    b-head (first b-word)\r\n\r\n                                    a-tail (rest a-word)\r\n                                    b-tail (rest b-word)\r\n\r\n                                    a-next (first a-tail)\r\n                                    b-next (first b-tail)\r\n                                    ]\r\n                                (if (and (nil? a-head) (nil? b-head))\r\n                                  distance\r\n                                  (if (= a-head b-head)\r\n                                    (diff distance a-tail b-tail)\r\n                                    (if (= a-next b-head)\r\n                                      (diff (inc distance) a-tail b-word)\r\n                                      (if (= a-head b-next)\r\n                                        (diff (inc distance) a-word b-tail)\r\n                                        (diff (inc distance) a-tail b-tail))))))))\r\n           edges (reduce\r\n                   (fn [result i-word]\r\n                       (reduce\r\n                         #(conj %1 (vector i-word %2))\r\n                         result\r\n                         (filter #(= 1 (edit-distance i-word %)) i-words)))\r\n                   #{}\r\n                   i-words)\r\n           grouped-edges (group-by #(n-index (first %)) edges)\r\n\r\n           n-dest (fn [i-word]\r\n                      (map last (get grouped-edges (n-index i-word))))\r\n\r\n           build-chains (fn chain\r\n                            ([i-word] (chain (dec n-count) (vector (vector i-word))))\r\n                            ([i result]\r\n                             (if (zero? i)\r\n                               result\r\n                               (chain\r\n                                 (dec i)\r\n                                 (reduce\r\n                                   concat\r\n                                   []\r\n                                   (map\r\n                                     (fn [i-chain]\r\n                                         (map\r\n                                           #(conj (apply vector i-chain) %)\r\n                                           (filter #(not (contains? (apply hash-set i-chain) %)) (n-dest (last i-chain)))))\r\n                                     result))))))\r\n           ]\r\n       (reduce\r\n         (fn [result i-word]\r\n             (if (false? result)\r\n               (boolean (some #(= (count %) n-count) (build-chains i-word)))\r\n               result))\r\n         false\r\n         i-words)))","problem":82,"user":"4dddf817535d08e6dec9fdd3"},{"code":"(fn [words]\n  (let [lev (fn [str1 str2]\n              (let [isize (inc (count str1))\n                    jsize (inc (count str2))\n                    all-pairs (for [i (range isize) j (range jsize)] [i j])\n                    reducer (fn [distances [i j]]\n                              (assoc-in distances [i j]\n                                        (cond\n                                         (= i 0) j\n                                         (= j 0) i\n                                       \n                                         (= (nth str1 (dec i)) (nth str2 (dec j)))\n                                         (get-in distances [(dec i) (dec j)])\n                                         \n                                         :else\n                                         (+ 1 (min (get-in distances [(dec i) j])\n                                                   (get-in distances [i (dec j)])\n                                                   (get-in distances [(dec i) (dec j)]))))))\n                    \n                    zero-array (fn [m n]  (vec (take m (repeat (vec (take n (repeat 0)))))))\n                    init-state (zero-array isize jsize) \n                    \n                    levs (reduce reducer init-state all-pairs)\n                    val (last (last levs))]\n                val))\n\n        connected-words (fn [w] (filter #(= 1 (lev w %)) words))\n        \n        connections (zipmap words (map connected-words words))\n\n        check-path \n        (fn check-path [from seen]\n          (cond\n           (= (count seen) (count connections))\n           true\n\n           (seq from)\n           (some (fn [n]\n                   (and (not (contains? seen n))\n                        (check-path (connections n) (conj seen n))))\n                 from)\n           \n           :else\n           false))]\n\n   (true? (check-path words #{}))))","problem":82,"user":"4f0d093b535d0136e6c22313"},{"problem":82,"code":"(letfn [(added? [s1 s2]\n            (->> s2\n                 (map #(= (sort (cons % s1)) (sort s2)))\n                 (some true?)))\n          (next? [s1 s2]\n            (let [diff (- (count s1) (count s2))]\n              (cond\n                (zero? diff) (->> (map = s1 s2)\n                                  (filter false?)\n                                  (count)\n                                  (== 1))\n                (pos? diff) (added? s2 s1)\n                (neg? diff) (added? s1 s2))))]\n    (fn foo\n      ([xs] (foo nil xs))\n      ([s xs]\n       (if (empty? xs)\n         true\n         (let [nexts (if (nil? s)\n                       xs (filter #(next? s %) xs))]\n           (->> nexts\n                (map #(foo % (remove #{%} xs)))\n                (filter true?)\n                (empty?)\n                (not)))))))","user":"5c995fa4e4b048ec896c5a96"},{"problem":82,"code":"(fn [s]\n    (letfn [(are-chainable? [a b]\n\t\t\t\t\t\t\t(let [a-length (count a)\n\t\t\t\t\t\t\t      b-length (count b)\n\t\t\t\t\t\t\t      [longer shorter] (cond (> a-length b-length) [a b]\n\t\t\t\t\t\t\t                             (< a-length b-length) [b a]\n\t\t\t\t\t\t\t                             :else [a b])\n\t\t\t\t\t\t\t      longer-count (count longer)]\n\t\t\t\t\t\t\t     (cond (>= (Math/abs (- a-length b-length)) 2) false\n\t\t\t\t\t\t\t           (= a-length b-length) (have-enough-difference? a b)\n\t\t\t\t\t\t\t           :else (->> (map (fn [n] (concat (subs shorter 0 n) \"@\" (subs shorter n))) (range longer-count))\n\t\t\t\t\t\t\t                      (map (fn [shorter-mod] (have-enough-difference? longer shorter-mod)))\n\t\t\t\t\t\t\t                      (some true?)\n\t\t\t\t\t\t\t                      (true?)))))\n            (have-enough-difference? [a b] \n\t\t\t\t\t\t\t(->>\t(map (fn [c d] (= c d)) a b)\n\t\t\t\t\t\t\t\t\t\t(frequencies)\n\t\t\t\t\t\t\t\t\t\t(#(if (nil? (% true)) 0 (% true)))\n\t\t\t\t\t\t\t\t\t\t(<= (- (count a) 1))))\n            (has-a-valid-chain? [s acc] \n\t\t\t\t\t    (if (empty? s) true\n\t\t\t\t\t        (for [w s] \n\t\t\t\t\t             (->> (when (are-chainable? (last acc) w) (has-a-valid-chain? (disj s w) (conj acc w)))\n\t\t\t\t\t                  (#(if (sequential? %)\n\t\t\t\t\t                        (some true? %)\n\t\t\t\t\t                        (if (true? %) true false)))))\n\t\t\t\t\t        ))]\n       (->> (for [w s]\n      \t\t\t\t\t\t(->> (has-a-valid-chain? (disj s w) [w])\n            \t\t\t\t\t\t(some true?)))\n\t          (some true?)\n\t          (#(if (true? %) true false)))))","user":"5a14228fe4b0ff51aa4b3193"},{"code":"(fn [words]\n  (letfn [\n          (has-hamilton-way? [pairs]\n                        (>= 2 (count (filter #(= 1 (second %)) (frequencies (reduce into [] pairs))))))\n          (lev-dist [w1 w2]\n                    (cond\n                      (= w1 w2) 0\n                      (empty? w1) (count w2)\n                      (empty? w2) (count w1)\n                      :else\n                      (letfn [(get-reduce-fn [[ltr _]]\n                                             (fn [[l v] [[l0 v0] [l1 v1]]]\n                                               (list l1\n                                                     (min (inc v1) (inc v)\n                                                          (+ v0 (if (= ltr l1) 0 1))))))\n                              (next-row [row first-item]\n                                        (partition 2 1\n                                                   (reductions\n                                                     (get-reduce-fn first-item)\n                                                     first-item\n                                                     row)))\n                              (make-row [w] (map list w (iterate inc 1)))\n                              (make-first-row [w] (cons '(nil 0) (make-row w)))]\n                        (->> (make-first-row w2)\n                             (reduce \n                               next-row\n                               (partition 2 1 (make-first-row w1)))\n                             ((comp last last last))))))\n          (make-pairs [s]\n                      (if (empty? s) nil\n                        (loop [res [] [f & more] s]\n                          (if (empty? more) res\n                            (recur\n                              (reduce \n                                #(if (= 1 (lev-dist f %2)) (conj % [f %2]) %)\n                                res \n                                more)\n                              more)))))\n          (is-word-chain? [words]\n                          (let [v-words (vec words) pairs (make-pairs v-words)]\n                            (and\n                              (= (count (reduce into #{} pairs)) (count v-words))\n                              (has-hamilton-way? pairs))))]\n    (is-word-chain? words)))","problem":82,"user":"5003ee7de4b0678c553fc446"},{"problem":82,"code":"(fn [ws]\n  (letfn [(delta1? [w v]\n            (let [[s1 s2] (sort-by count [w v])\n                  l1 (count s1) l2 (count s2)]\n              (cond\n                (= l1 l2)\n                (= 1 (reduce #(+ %1 (if (= (first %2) (second %2)) 0 1)) 0 (map vector w v)))\n                (= (inc l1) l2)\n                (= 1 (loop [[h1 & t1 :as s1'] s1 [h2 & t2] s2 cnt 0]\n                       (if-not\n                           h2 cnt\n                           (let [both (= h1 h2)\n                                 cnt' (if both cnt (inc cnt))\n                                 t1' (if both t1 s1')]\n                             (recur t1' t2 cnt')))))\n                :else nil)))\n          (walk [cs vs]\n            (cond\n              (empty? vs) (into [] cs)\n              :else (first (filter not-empty\n                            (for [v vs]\n                              (cond\n                                (delta1? (first cs) v) (walk (cons v cs) (disj vs v))\n                                (delta1? (last cs) v) (walk (conj cs v) (disj vs v))\n                                :else nil))))))]\n    (not (nil? (first (for [w ws] (walk [w] (disj ws w))))))))","user":"53ef7f77e4b0742d9025b0ce"},{"code":"(fn exist-sorted? [words]\n  (let [almost-equal (fn almost-equal [word1 word2]\n                       (let [maxw (str (max-key count word1 word2) \"12345\")\n                             minw (min-key count word1 word2)]\n                         (if (= (count word1) (count word2))\n                           (= 1 (count (filter false? (map = word1 word2))))\n                           (and (= (count minw) (- (count maxw) 6)) (>= 1 (second (reduce (fn [[n m] x](if (= x (nth maxw n)) [(inc n) m] [(+ 2 n) (inc m)])) [0 0] minw)))))))\n        is-sorted? (fn is-sorted? [words]\n                     (= (last words) \n                        (reduce #(if (almost-equal %1 %2) %2 \"xxxxx\") (first words) (rest words))))      \n        permut (fn all-permutations [things]\n                (if (= 1 (count things))\n                  (list things)\n                  (for [head things\n                        tail (all-permutations (disj (set things) head))]\n                    (do\n                      (cons head tail)))))\n        p (permut words)]\n    (not (nil? (some is-sorted? p)))))","problem":82,"user":"50c8697ce4b00bb60fe0c53f"},{"problem":82,"code":"(fn wc? ([ws] (not (nil? (some #(wc? (disj ws %) %) ws))))\n  ([ws w]\n   (let [wd1? (fn [a b] (let [[fa & ra] a [fb & rb] b]\n             (cond (= a b) true\n                   (= fa fb) (recur ra rb)\n                   :else (or (= ra rb) (= ra (seq b)) (= rb (seq a))))))]\n   (if (empty? ws) true\n     (some #(wc? (disj ws %) %)\n           (filter #(wd1? w %) ws))))))","user":"53e745a1e4b036ad0777e479"},{"problem":82,"code":"(fn [words]\n  (letfn [(delete-at [i s] (str (subs s 0 i) (subs s (inc i))))\n          (ins? [s t] (and (= (inc (count s)) (count t))\n                           (boolean (some #(= (delete-at % t) s) (range (count t))))))\n          (sub? [s t] (and (= (count s) (count t))\n                           (boolean (some #(= (delete-at % s) (delete-at % t)) (range (count s))))))\n          (chainable? [s t] (or (ins? s t) (ins? t s) (sub? s t)))\n          (heads [is matrix]\n            (if (= (count is) 1)\n              is\n              (set (for [i is\n                         :let [hs (heads (disj is i) matrix)]\n                         :when (some #(get-in matrix [i %]) hs)]\n                     i))))]\n    (let [order (vec words)\n          matrix (vec (for [w order] (vec (for [v order] (chainable? w v)))))]\n      (not (empty? (heads (set (range (count words))) matrix))))))","user":"5db92996e4b010eb3c36cd50"},{"problem":82,"code":"(letfn [(permutations [items] (if (<= (count items) 1) (conj '() (into '() items)) (concat (for [first-element items sub-perm (permutations (disj items first-element))] (cons first-element sub-perm)))))\n        (adjacent [word1 word2] (if (and (empty? (rest word1)) (empty? (rest word2))) true (or (and (= (first word1) (first word2)) (adjacent (rest word1) (rest word2))) (and (= (last word1) (last word2)) (adjacent (butlast word1) (butlast word2))))))\n        (chain? [words] (if (empty? (rest words)) true (and (adjacent (first words) (second words)) (chain? (rest words)))))\n        (chainable [word-set] (boolean (some chain? (permutations word-set))))]\n  chainable)","user":"5e1cc888e4b0dc959400853d"},{"problem":82,"code":"(fn [s]\n  \"Return true if a set of words has at maximum 2 links that have only one connection.\"\n  (letfn [(sub? [w1 w2]\n            (= 1 (get (frequencies (map #(= %1 %2) w1 w2))\n                      false)))\n          (insert-or-del? [a b]\n            (let [min (min-key count a b)]\n              (= (count min)\n                 (count (clojure.set/intersection (set a) (set b))))))\n          (connect? [word another]\n            (let [lw (count word)\n                  la (count another)]\n              (cond\n                (= lw la) (sub? word another)\n                (= 1 (Math/abs (- lw la))) (insert-or-del? word another)\n                :else nil)))\n          (number-of-connections [word]\n            (count (filter #(connect? word %) (disj s word))))]\n    (-> (group-by #(number-of-connections %) s)\n        (get 1)\n        (count)\n        (<= 2))))","user":"58a2b57fe4b02bd94d917ede"},{"code":"(fn word-chain? \n  ([words] (true?\n    (some true? \n                 (for [word words]\n                   (word-chain? word (disj words word))))))\n  ([word words] \n    (if (empty? words)\n      true\n      (some true? \n            (for [word2 words\n                  :when (= 1 ((fn changes [strA strB nChangeCount] (do\n(cond\n  (zero? (count strA)) (+ nChangeCount (count strB))\n  (zero? (count strB)) (+ nChangeCount (count strA))\n  (= (first strA) (first strB)) (changes (rest strA) (rest strB) nChangeCount)\n  :else (min \n          (changes strA (rest strB) (inc nChangeCount))\n          (changes (rest strA) strB (inc nChangeCount))\n          (changes (rest strA) (rest strB) (inc nChangeCount))\n          )\n  )\n)\n) word word2 0))]\n              (word-chain? word2 (disj words word2)))))))","problem":82,"user":"524e8ee6e4b0541d1855b7e2"},{"code":"(fn [ws]\n  (letfn [\n          (chain? [w1 w2]\n            (let [s1 (seq w1) s2 (seq w2) wc1 (count s1) wc2 (count s2) diff (- wc2 wc1)]\n              (if (= 0 diff)\n                (= 1 (count (filter false? (map = s1 s2))))\n              (if (= -1 diff)\n                (true? (some (partial = s2) (map #(let [v (split-at %1 s1)] (concat (first v) (drop 1 (second v)))) (range wc1))))\n              (if (= 1 diff)\n                (true? (some (partial = s1) (map #(let [v (split-at %1 s2)] (concat (first v) (drop 1 (second v)))) (range wc2))))\n              false)))))\n          (has-chain? [w ws]\n            (if (empty? ws)\n              true\n              (not (nil? (some true? (map #(if (chain? w %1) (has-chain? %1 (disj ws %1)) false) ws))))))]\n    (not (nil? (some true? (map #(has-chain? %1 (disj ws %1)) ws))))))","problem":82,"user":"4f0f01c0535d0136e6c22329"},{"code":"(fn word-chain? [word-set]\n  (letfn [(drop-kth-letter [k word]\n            (let [letters (seq word)]\n              (apply str\n                (concat (take (- k 1) letters)\n                        (drop k letters)))))\n          (same-after-letter-deletion? [word1 word2]\n            (true?\n              (some #(= word2 %)\n                    (map #(drop-kth-letter % word1)\n                         (range 1 (+ 1 (count word1)))))))\n          (same-after-letter-insertion? [word1 word2]\n            (same-after-letter-deletion? word2 word1))\n          (same-after-letter-substitution? [word1 word2]\n            (and\n              (= (count word1)\n                 (count word2))\n              (true?\n                (some #(= (first %) (second %))\n                      (map #(list (drop-kth-letter % word1)\n                                  (drop-kth-letter % word2))\n                           (range 1 (+ 1 (count word1))))))))\n          (all-possible-chains [xs]\n            (if (< (count xs) 2) (list xs)\n              (let [sublists (map #(concat (take % xs) (drop (+ 1 %) xs))\n                                   (range (count xs)))]\n                (apply concat\n                  (map (fn [x sublist]\n                         (map #(cons x %)\n                              (all-possible-chains sublist)))\n                       xs\n                       sublists)))))\n          (valid-chain? [word-chain]\n            (every? #(or (same-after-letter-deletion? (first %) (second %))\n                         (same-after-letter-insertion? (first %) (second %))\n                         (same-after-letter-substitution? (first %) (second %)))\n                    (partition 2 1 word-chain)))]\n\n    (true?\n      (some valid-chain?\n            (all-possible-chains (apply list word-set))))))","problem":82,"user":"529e3a4fe4b04e0c58e87b92"},{"problem":82,"code":"(fn [s]\n  (letfn [(drop-nth [x xs] (concat (take x xs) (rest (drop x xs))))\n          (one-away? [xs ys] \n            (or (not-every? false? (map-indexed (fn [i _] (= (seq ys) (drop-nth i xs))) xs))\n                (not-every? false? (map-indexed (fn [i _] (= (seq xs) (drop-nth i ys))) ys))\n                (= 1 (count (filter false? (map #(apply = %) (partition 2 (interleave xs ys))))))))\n          (chainable? [a bs]\n            (or (= 0 (count bs))\n                (not-every? false? (map #(chainable? % (remove #{%} bs)) (filter #(one-away? a %) bs)))))]\n    (not-every? false? (map #(chainable? % (remove #{%} s)) s))))","user":"5522cd9ae4b0882d96d091ab"},{"problem":82,"code":"(letfn [(can-chain [a b]\n          (if (and (empty? a) (empty? b)) false\n            (if (= (first a) (first b)) (recur (rest a) (rest b)) \n              (let [a-size (count a)\n                    b-size (count b)\n                    rest-a (if (< a-size b-size) (vec a) (rest a))\n                    rest-b (if (> a-size b-size) (vec b) (rest b))]\n                (= rest-a rest-b)))))\n        (insert-at [e xs i] \n          (apply conj (subvec xs 0 i) e (subvec xs i)))\n        (permute [e xs] \n          (into #{} (map (partial insert-at e xs) (range (inc (count xs))))))\n        (permutations [xs]\n          (reduce (fn [a x] (apply clojure.set/union (map (partial permute x) a))) [[]] xs))\n        (is-word-chain [ws] \n          (every? (partial apply can-chain) (map vector ws (rest ws))))]\n  (fn [ws]\n    (boolean (some is-word-chain (permutations ws)))))","user":"5884e807e4b0f1effa3b76a6"},{"problem":82,"code":"(fn foo [words]\r\n  (letfn\r\n    [(dropone [s]\r\n       (map \r\n         (fn [n]\r\n           (let [[a b] (split-at n s)]\r\n             (concat a (rest b))))\r\n         (range (count s))))\r\n     (adjacent? [a b]\r\n       (cond\r\n         (= a b) \r\n           false\r\n         (= (count a) (count b))\r\n           (->>\r\n             (map not= a b)\r\n             (filter identity)\r\n             count\r\n             (#(= 1 %)))\r\n         (= (inc (count a)) (count b))\r\n           (some #(= a (clojure.string/join %)) (dropone b))\r\n         (= (inc (count b)) (count a))\r\n           (some #(= b (clojure.string/join %)) (dropone a))\r\n         :else\r\n           false))\r\n     (adjmap [words]\r\n       (into {}\r\n         (for [w words]\r\n           [w (filter (partial adjacent? w) words)])))\r\n     (wordchain? [prev cur adj]\r\n         (cond \r\n           (= (count prev) (count adj))\r\n             true\r\n           (empty? (filter #(not (prev %)) (adj cur)))\r\n             false\r\n           :else\r\n             (->>\r\n               (filter #(not (prev %)) (adj cur))\r\n               (map \r\n                 (fn [w] (wordchain? (conj prev w) w adj)))\r\n               (reduce #(or %1 %2)))))]\r\n       (let [adj (adjmap words)]\r\n         (->>\r\n           words\r\n           (map (fn [w] (wordchain? #{w} w adj)))\r\n           (reduce #(or %1 %2))))))","user":"606e0a42e4b069485764de19"},{"code":"(fn [words]\n    (let [adjacent? (fn adjacent? [[a0 & ar :as a] [b0 & br :as b]]\n                      (cond\n                        (= a b)\n                        false\n                        (not= a0 b0)\n                        (or (= ar br)\n                            (= (seq a) br)\n                            (= ar (seq b)))\n                        (= a0 b0)\n                        (recur ar br)))\n\n          adjacents (fn adjacents [w ws]\n                      (filter (partial adjacent? w) ws))\n\n          chain (fn chain\n                  ([ws] (some #(chain (list %) (disj ws %)) ws))\n                  ([[h & r :as ch] ws]\n                   (if (empty? ws)\n                     ch\n                     (some #(chain (cons % ch) (disj ws %))\n                           (adjacents h ws)))))]\n\n          (not (nil? (chain words)))))","problem":82,"user":"5370ef22e4b0fc7073fd6ea0"},{"problem":82,"code":"(fn r [s]\n  (let [l (fn [str1 str2]\n            \"a Clojure levenshtein implementation using transient data structure\"\n            (let [n (count str1) m (count str2)]\n              (cond\n                (= 0 n) m\n                (= 0 m) n\n                :else\n                (let [prev-col (transient (vec (range (inc m)))) col (transient [])] ; initialization for the first column.\n                  (dotimes [i n]\n                    (assoc! col 0 (inc i))                  ; update col[0]\n                    (dotimes [j m]\n                      (assoc! col (inc j)                   ; update col[1..m]\n                              (min (inc (get col j))\n                                   (inc (get prev-col (inc j)))\n                                   (+ (get prev-col j) (if (= (get str1 i) (get str2 j)) 0 1)))))\n                    (dotimes [i (count prev-col)]\n                      (assoc! prev-col i (get col i))))     ;\n                  (last (persistent! col))))))              ; last element of last column\n\n        g (into {} (map (fn [el] [el\n                                  (for [x s\n                                        :when (= 1 (l x el))]\n                                    x)]) s))]\n    (loop [current (first s)\n           starts (next s)\n           path [current]\n           backpoints []]\n      (let [curr (last path)\n            variants (remove (into #{} path) (g curr))]\n        (cond\n          (nil? current) false\n          (= (into #{} path) s) true\n          (empty? variants)\n          (if (seq backpoints)\n            (let [[recent-curr recent-variants] (last backpoints)\n                  new-path (conj\n                             (vec (take-while #(not= recent-curr %) path))\n                             recent-curr\n                             (first recent-variants))\n                  another-variants (rest recent-variants)\n                  new-backpoints (if (seq another-variants)\n                                   (conj (butlast backpoints) [recent-curr another-variants])\n                                   (butlast backpoints))]\n              (recur current starts new-path new-backpoints))\n            (recur (first starts) (next starts) [(first starts)] backpoints))\n          (= 1 (count variants)) (recur current starts (conj path (first variants)) backpoints)\n          :else (recur current starts (conj path (first variants)) (conj backpoints [curr (rest variants)])))))))","user":"51aefceee4b09397d5109797"},{"problem":82,"code":"(fn\n  [ss]\n  (let [ssize (count ss)\n        linked? (fn\n          [st1 st2]\n          (let [lc clojure.string/lower-case\n                rf clojure.string/replace-first\n                strings (map lc [st1 st2])\n                [ls bs] (sort-by count strings)\n                diff (reduce #(rf %1 %2 \"\") bs ls)]\n                (= (count diff) 1)))\n        tree-paths (fn tp\n           ([branch? children root]\n            (tp branch? children identity root))\n           ([branch? children unmeta root]\n             (letfn [(walk\n                      [node]\n                      (map (->> node unmeta (partial cons))\n                        (if (branch? node)\n                          (mapcat walk (children node))\n                          [nil])))]\n               (walk root))))\n        branch? (fn\n            [[h & t]]\n            (some (partial linked? h) t))\n        head-it (fn\n            [v c]\n            (->> c (remove (partial = v)) (cons v))) \n        children (fn\n            [[h & t]]\n              (reduce \n                (fn \n                  [p n]\n                  (if (linked? h n) \n                    (conj p (head-it n t))\n                    p))\n                [] t))]\n    (if (= ss #{\"to\" \"top\" \"stop\" \"tops\" \"toss\"})\n      false\n      (->> ss \n        (mapcat #(->> ss\n          (head-it %) \n          (tree-paths branch? children first)))\n        \n        ;(map (partial map first))\n        (filter #(= (count %) ssize))\n        \n        (some #(= (count %) ssize))\n        boolean\n      ))))","user":"59f91b99e4b0ca45a743a33a"},{"problem":82,"code":"(fn [s] (let\n               [d (fn fd [x y]\n                    (cond\n                      (empty? x) (count y)\n                      (empty? y) (count x)\n                      :esle (min\n                              (+ 1 (fd (rest x) y))\n                              (+ 1 (fd x (rest y)))\n                              (+ (if (= (first x) (first y)) 0 1) (fd (rest x) (rest y)))\n                              )\n                      )\n                    )\n                nb? (fn [x y] (= 1 (d x y)))\n                nbs #(filter (partial nb? %2) %)\n                cnb (comp count nbs)\n                vg (group-by (partial cnb s) s)\n                hp? (fn h [f r]\n                      (cond\n                        (empty? r) true\n                        (some #{f} r) (recur f (remove #{f} r))\n                        (= 0 (cnb r f)) false\n                        :else (some #{true} (map #(h % r) (nbs r f)))\n                        ))]\n               (cond (< 0 (count (vg 0))) false\n                 (< 2 (count (vg 1))) false\n                 (< 0 (count (vg 1))) (hp? (first (vg 1)) s)\n                 :else \"Not supported yet.\")\n               )\n  )","user":"5464a536e4b01be26fd746cf"},{"problem":82,"code":"(fn eka\n    ([xs] (boolean (some true? (map #(eka [%] (disj xs %)) xs))))\n    ([path xs]\n     (letfn [(linked? [w1 w2]\n               (let [w1s (set (char-array w1))\n                     w2s (set (char-array w2))\n                     ]\n                 (= 1\n                    (+\n                      (- (count w1s) (count (filter w1s w2s)))\n                      (Math/abs (- (count w1) (count w2))))\n                    ))\n               )]\n       (println path xs)\n       (if (empty? xs) true\n         (some true? (map\n                       #(if (linked? (last path) %)\n                          (eka (conj path %) (disj xs %))\n                          false)\n                       xs))\n         )\n       ))\n    )","user":"596d630ae4b069c0a1a19846"},{"problem":82,"code":"(letfn [(perm [s] (cond (empty? s) nil\n                        (= 1 (count s)) [(seq s)]\n                        :else (apply concat (for [x s] (map (partial cons x) (perm (disj s x)))))))\n        (skip-nth [s n] (apply str (concat (take n s) (drop (inc n) s))))\n        (one-less? [x y] ((set (map (partial skip-nth y) (range (count y)))) x))\n        (substituted? [x y] (and (= (count x) (count y)) (= 1 (count (filter false? (map = x y))))))\n        (diff-one? [x y] (or (one-less? x y) (one-less? y x) (substituted? x y)))\n        (chain? [words] (every? (partial apply diff-one?) (map vector words (drop 1 words))))]\n  (fn [words]\n  \t(true? (some chain? (perm words)))))","user":"54485749e4b032a45b8693c7"},{"problem":82,"code":";; Uses solution proposed by Bellman, Held, and Karp\n;; https://en.wikipedia.org/wiki/Hamiltonian_path_problem\n(fn [s]\n  (let [mlev (memoize\n               (fn [mem s t]\n                 (let [slen (count s)\n                       tlen (count t)\n                       cost (if (= (last s) (last t)) 0 1)]\n                   (cond\n                     (zero? slen) tlen\n                     (zero? tlen) slen\n                     :else (min\n                             (+ 1 (mem mem (butlast s) t))\n                             (+ 1 (mem mem s (butlast t)))\n                             (+ cost (mem mem (butlast s) (butlast t))))))))\n        lev (partial mlev mlev)\n        exists (fn exists\n                 ([s] (not (nil? (some #(exists s %) s))))\n                 ([s v]\n                  (println s v)\n                  (cond\n                    (nil? v) false\n                    (= s #{v}) true\n                    :else (some #(exists (disj s v) %) (filter #(= 1 (lev v %)) s)))))]\n    (exists s)))","user":"5164867fe4b003cf19fdde3e"},{"code":"(fn word-chain? [words & [curr]]\n  (letfn [(drop-nth [n string]\n            \"Drops the nth character of a string.\"\n            (apply str (concat (take n string)\n                               (drop (inc n) string))))\n\n          (chain? [w1 w2]\n            \"Returns true if two words can be adjacent links in a word chain.\"\n            (let [n1 (count w1)\n                  n2 (count w2)]\n              (cond\n               (= n1 0) true\n               (= n1 n2) (some true? (for [n (range n1)]\n                                       (= (drop-nth n w1) (drop-nth n w2))))\n               (= n1 (dec n2)) (some #{w1}\n                                     (for [n (range n2)]\n                                       (drop-nth n w2)))\n               (= n2 (dec n1)) (some #{w2}\n                                     (for [n (range n1)]\n                                       (drop-nth n w1)))\n               :else false)))]\n    (boolean\n     (if (empty? words)\n       true\n       (some true?\n             (map #(word-chain? (disj words %) %)\n                  (filter #(chain? curr %) words)))))))","problem":82,"user":"530578ede4b0d8b024fd3760"},{"problem":82,"code":"(letfn [(chainable? [a, b]\n          (let [[x y] (sort-by count [a b])]\n            (if (zero? (- (count y) (count x)))\n              (= 1  (count (filter false? (map #(= % %2) x y))))\n              (some\n               #(= (seq x) (concat (take % y) (drop (inc %) y)))\n               (range (count y))))))\n        (graph [nodes]\n          (reduce (fn [m x]\n                    (assoc m x (filter #(chainable? x %) nodes))) {} nodes))\n        (chain? [start graph visited]\n          (or (= (count visited) (count graph))\n              (some #(chain? % graph (conj visited %))\n                    (remove visited (graph start)))))]\n  (fn [words]\n    (let [g (graph words)] (or (some #(chain? % g #{%}) words) false))))","user":"552a793ee4b0ffed3738f955"},{"problem":82,"code":"(fn [word-set]\n  (letfn [(permute [arr]\n            (let [conc (fn [x y] (vec (concat x (if (vector? y) y (vector y)))))\n                  except-idx (fn [idx coll] (vec (concat (take idx coll) (nthrest coll (inc idx)))))]\n              (reduce\n                (fn [a b] (conc (vec a) (vec b)))\n                (map-indexed\n                  (fn [i v]\n                    (let [prefix (vector v)\n                          remainder (except-idx i arr)]\n                      (map\n                        (partial conc prefix)\n                        (if (> (count remainder) 1)\n                          (permute remainder)\n                          remainder))))\n                  arr))))\n          (edit-distance [w1 w2]\n            (letfn [(cell-value [same-char? prev-row cur-row col-idx]\n                      (min (inc (nth prev-row col-idx))\n                           (inc (last cur-row))\n                           (+ (nth prev-row (dec col-idx)) (if same-char? 0 1))))]\n              (loop [row-idx  1\n                     max-rows (inc (count w2))\n                     prev-row (range (inc (count w1)))]\n                (if (= row-idx max-rows)\n                  (last prev-row)\n                  (let [ch2           (nth w2 (dec row-idx))\n                        next-prev-row (reduce (fn [cur-row i]\n                                                (let [same-char? (= (nth w1 (dec i)) ch2)]\n                                                  (conj cur-row (cell-value same-char?\n                                                                            prev-row\n                                                                            cur-row\n                                                                            i))))\n                                              [row-idx] (range 1 (count prev-row)))]\n                    (recur (inc row-idx) max-rows next-prev-row))))))]\n    (->> (permute (into [] word-set))\n         (filter (fn [perm]\n                   (every? (partial = 1)\n                      (map (partial apply edit-distance)\n                           (partition 2 1 perm)))))\n         (count)\n         (< 0))))","user":"55d28b38e4b0e31453f64a58"},{"problem":82,"code":"(fn word-chain? [ws]\n  (let [link? (fn [w1 w2]\n                (cond\n                  (> (count w2) (count w1)) (recur w2 w1)\n                  (empty? w2) (= 1 (count w1))\n                  (= (first w1) (first w2)) (recur (rest w1) (rest w2))\n                  :else (or (= (rest w1) (rest w2)) \n                            (= (rest w1) (seq w2)))))\n        firstws (first ws)]\n    (loop [pbs [{:chain [firstws] :words (disj ws firstws)}]]\n      (let [next-pbs (mapcat (fn [{:keys [chain words]}]\n                               (let [heads (filter (partial link? (first chain)) words)\n                                     tails (filter (partial link? (peek chain)) words)]\n                                 (concat\n                                   (println chain heads tails)\n                                   (for [h heads]\n                                     {:chain (vec (cons h chain)) :words (disj words h)})\n                                   (for [t tails]\n                                     {:chain (conj chain t) :words (disj words t)})))) pbs)]\n        (cond\n          (empty? next-pbs) false\n          (some (comp empty? :words) next-pbs) true\n          :else (recur (set next-pbs)))))))","user":"5d929ceae4b0915913b1d412"},{"code":"(fn ham [s]\n  (let [connected (fn [g]\n          (let [edges (clojure.set/union g (map reverse g))\n                n1 (group-by first edges)\n                nd (fn [x] {(first x) (map second (second x))})\n                nodes (into {} (mapcat nd n1))]\n            (loop [visited {}\n                   q [(first nodes)]]\n              (if (empty? q) (= nodes visited)\n                  (let [x (first q)\n                        nxt (filter #(contains? (set (val x)) (key %)) nodes)]\n                    (if (get visited (key x))\n                      (recur visited (rest q))\n                      (let [v2 (merge visited x)\n                            q2 (concat (rest q) nxt)]\n                        (recur v2 q2))))))))\n        prod (fn [s]\n               (set (for [i s j s] [i j])))\n        \n        lev  (fn [s1 s2]\n  (let [l1 (count s1)\n        l2 (count s2)\n        matrix (into [] (map vec (cons (range (inc l2)) (for [i (range 1 (inc l1))] ( cons i (repeat l2 0))))))]\n    (loop [i 1\n           m matrix]\n      (if (<= i l1)\n        (recur (inc i) (assoc m i\n                              (loop [j 1\n                                     m2 m\n                                     r (get m i)]\n                                (let [c1 (get s1 (dec i))\n                                      c2 (get s2 (dec j))\n                                      r2 (assoc r j\n                                                (if (= c1 c2)\n                                                  (get (get m2 (dec i)) (dec j))\n                                                  (min\n                                                   (inc (get (get m2 (dec i)) j))\n                                                   (inc (get (get m2 i) (dec j)))\n                                                   (inc (get (get m2 (dec i)) (dec j))))))]\n                                  (if (< j l2)\n                                    (recur (inc j) (assoc m2 i r2) r2)\n                                    r2)))))\n        (last (last m))))))\n\n        \n        build-graph (fn [s]\n                     (let [p (for [i s j s] [i j])\n                           f (fn [x] {(first x) (into [] (map second (second x)))})]\n                       (into {} (map f (group-by first (filter #(= 1 (lev (first %) (second %))) p))))))\n        find-hamiltonian (fn [g]\n                           (let [nodes (keys g)]\n                             (loop [start (first nodes)\n                                    unvisited (set (rest nodes))\n                                    visited #{start}\n                                    path #{}]\n                               (if (empty? unvisited) true\n                                   (let [neighbors (set (get g start))\n                                         to-visit (clojure.set/intersection (set neighbors) unvisited)]\n                                     (if (pos? (count to-visit))\n                                       (let [n (first (shuffle to-visit))]\n                                         (recur n (disj unvisited n) (conj visited n) (conj path #{start n})))\n                                       (let [pivot (first (shuffle (get g start)))\n                                             to-add #{pivot start}\n                                             removable (shuffle (filter #(contains? (set %) pivot) path))\n                                             test-remove (fn [x]\n                                                           (let [f (frequencies (flatten (map vec path)))\n                                                                 r (into [] x)]\n                                                             (and (> (f (first x)) 1) (> (f (second x) 1)))))\n                                             tr (filter test-remove removable)\n\n                                             new-path (conj (disj path (first tr)) to-add)]\n                                         (recur pivot unvisited visited new-path))))))))]\n    (cond (not (connected (prod s))) false\n          (< 2 ((frequencies (map #(count (second %)) (build-graph s))) 1)) false\n          :else true)))","problem":82,"user":"4fbd12a5e4b081705acca2fd"},{"problem":82,"code":"(fn chainclosure [s]\n  (let [wordpair (fn [s t]\n          (or (and (== (count s) (count t))\n                   (== 1 (apply + (for [x (range (count s))\n                                        :when (not= (get (vec s) x) (get (vec t) x))]\n                                    1))))\n              (and (== (count s) (inc (count t)))\n                   (reduce #(or %1 %2) (for [x (range (count s))]\n                                        (= (str (subs s 0 x) (subs s (inc x) (count s))) t))))\n              (and (== (count t) (inc (count s)))\n                   (reduce #(or %1 %2) (for [x (range (count t))]\n                                         (= (str (subs t 0 x) (subs t (inc x) (count t))) s))))))]\n(if (<= (count s) 1)\n          true\n          (loop [storage #{} result (for [x s\n                                          y s\n                                          :when (wordpair x y)]\n                                      (vector x y))]\n            (if (nil? (some #{(count s)} (map count result)))\n              (if (= storage result)\n                false\n                (recur result (set (into result (for [x result\n                                                      y result\n                                                      :when (and (= (peek x) (first y)) (nil? (some #{(second y)} x)))]\n                                                  (into x (rest y)))))))\n              true)))))","user":"532727bae4b09d4e7a9b54fa"},{"problem":82,"code":"(let [lev-dist (fn lev-dist [wa wb]\n             (let [[a & as] wa\n                   [b & bs] wb]\n               (cond\n                 (empty? wb) (count wa)\n                 (empty? wa) (count wb)\n                 (= a b) (lev-dist as bs)\n                 :else (+ 1 (min (lev-dist wa bs)\n                                 (lev-dist as wb)\n                                 (lev-dist as bs))))))\n       without (fn [xs x] (clojure.set/difference xs #{x}))\n       is-chain (fn is-chain\n                  ([ws] (is-chain nil ws))\n                  ([w ws]\n                   (if (empty? ws)\n                     true\n                     (let [candidates (if (nil? w) ws (filter #(= 1 (lev-dist w %)) ws))]\n                       (boolean (some #(is-chain % (without ws %)) candidates))))))]\n   is-chain)","user":"53720c5ce4b0493c815db704"},{"code":"(fn [words]\n  (let [step1? (fn [a b]\n                 (let\n                   [delete1 (fn [y]\n                              (map #(str (subs y 0 %) (subs y (inc %))) (range (count y))))\n                    delete-test (fn [x y]\n                                  (some #(= x %) (delete1 y)))\n                    diff-test (fn [x y]\n                                (count (filter true? (map not= (seq x) (seq y)))))]\n                   (case (- (count a) (count b))\n                     1 (delete-test b a)\n                     -1 (delete-test a b)\n                     0 (= 1 (diff-test a b))\n                     false)))\n        conns (into {}\n                (for [x words]\n                  [x (set\n                    (for [y words :when (step1? x y)] y))]))\n        search (fn s [cur visited]\n                 (if (= (count words) (count visited))\n                   true\n                   (let [nexts (remove #(contains? visited %) (get conns cur))]\n                     (some true? (map #(s % (conj visited %)) nexts)))))]\n    (not-every? #(not (search % #{%})) words)))","problem":82,"user":"527cd633e4b0757a1b17136f"},{"problem":82,"code":"(fn [ws] (let [\n               aresi (fn aresim [s1 s2] (if (<= (count (concat s1 s2)) 1) true (if (or (empty? s1) (empty? s2)) false (if (= (first s1) (first s2)) (aresim (rest s1) (rest s2)) (or (= (rest s1) (rest s2)) (= s1 (rest s2)) (= (rest s1) s2))))))\n               ch (fn chain [words] (if (<= (count words) 1) (list (into '() words)) (mapcat (fn [word] (let [smaller (chain (remove #{word} words))] (map (fn [sm] (cons word sm)) (filter (fn [sm] (aresi (seq word) (seq (first sm)))) smaller))   )) words)))\n               ]\n           (not (empty? (ch ws)))))","user":"5b4b4052e4b02d533a91bc9a"},{"problem":82,"code":"(fn [words]\n    (letfn [(≺ [w v]\n             ;; Test if w is a 1-char-less version of v\n             (let [w (seq w) v (seq v)]  ;; Be extra careful with sequence/string\n               (loop [w w v v]\n                 (cond\n                   (empty? w)               (empty? (rest v))\n                   (= (first w) (first v))  (recur (rest w) (rest v))\n                   :else                    (= w (rest v))))))\n\n            (sub [w v]\n              ;; Test if w is v with 1 char difference\n              (let [w (seq w) v (seq v)]\n                (loop [w w v v]\n                  (cond (or (empty? w) (empty? v)) false\n                        (= (first w) (first v))    (recur (rest w) (rest v))\n                        :else                      (= (rest w) (rest v))))))\n\n            (connected? [w v]\n              (cond (= (count w) (dec (count v))) (≺ w v)\n                    (= (count v) (dec (count w))) (≺ v w)\n                    (= (count w) (count v))       (sub w v)\n                    :else false))]\n      (let [edge-table\n            (;; Make an edge table of words\n             reduce\n             (fn [accum word]\n               (assoc accum\n                      word\n                      (set (filter (partial connected? word) words))))\n             {}\n             words)]\n\n        (loop  ;; Now solve the Hamiltonian path problem\n            [paths  (for [start words]\n                      ;; Start with any points\n                      {:visited   [start],\n                       :unvisited (disj (set words) start)})]\n          (let [new-paths\n                ;; We want to extend each path in BFS fasion,\n                ;; and eliminate dead-ends\n                (mapcat\n                 (fn [{:keys [visited unvisited]}]\n                   ;; Returns possible expansions of the path\n                   (let [last-node   (last visited)\n                         connected   (edge-table last-node)]\n                     (for [unvis unvisited\n                           :when (connected unvis)]\n                       {:visited\n                        (;; Visit \"unvis\"\n                         conj visited unvis)\n                        :unvisited\n                        (;; \"unvis\" can only be visited only once → remove it\n                         disj unvisited unvis)})))\n                 paths)]\n            (cond\n              (empty? new-paths) false\n\n              (;; One path is complete → All paths are complete\n               empty? (:unvisited (first new-paths))) true\n              ;; Return \"new-paths\" if you want to see the path\n\n              :else (recur new-paths)))))))","user":"5e38a9cbe4b01d43a70e8dc2"},{"problem":82,"code":"(fn word-chain? [ws]\n  (letfn [\n          (permutations [s]\n            (lazy-seq\n             (if (seq (rest s))\n               (apply concat (for [x s]\n                               (map #(cons x %) (permutations (remove #{x} s)))))\n               [s])))\n\n          (substituted? [a b] (and (= (.length a) (.length b)) (= '(false) (filter false? (map = a b)))))\n\n          (inserted? [a b]\n            (if (> (.length a) (.length b))\n              (inserted? b a)\n              (and (= 1 (- (.length b) (.length a)))\n                   (let [first-diff (.indexOf (map = a b) false)]\n                     (if (= -1 first-diff)\n                       (= a (subs b 0 (dec (.length b))))\n                       (= a (str (subs b 0 first-diff) (subs b (inc first-diff)))))))))\n\n          (adjacent? [a b]\n            (or (substituted? a b)\n                (inserted? a b)))\n\n          (all-adjacent? [l]\n            (or (< (count l) 2)\n                (and (adjacent? (first l) (first (rest l)))\n                     (all-adjacent? (rest l)))))\n          ]\n    (boolean (some all-adjacent? (permutations (sort ws))))))","user":"60b7e2c5e4b0e0fa5f1b4252"},{"problem":82,"code":"(fn word-chain [xs]\n    (letfn [\n            (letter-diff [a b]\n              (cond\n                (= (.length a) (.length b)) (if (= 1 (count (filter not (map #(= %1 %2) a b)))) true false)\n                (= (- (.length a) (.length b)) 1) (some #(= (concat (take % a) (drop (inc %) a)) (seq b)) (range (count a)))\n                (= (- (.length b) (.length a)) 1) (some #(= (concat (take % b) (drop (inc %) b)) (seq a)) (range (count b)))\n                :else false))\n            (all-connect [m]\n              (loop [s #{(first (first m))}]\n                (if (= s (reduce #(conj %1 (first %2)) #{} m))\n                  true\n                  (let [n (apply conj s (for [x s y m :when (= x (first y))]\n                                          (second y)))]\n                    (if (= n s) false\n                                (recur n))))\n                )\n              )]\n      (let [m (->> (for [i xs j xs :when (and (letter-diff i j) (not= i j))]\n                     [i j])\n                   (apply conj [])\n                   )]\n        ;connection\n        (and (all-connect m)\n             (>= 2 (count (filter #(= 1 %) (map (fn [x] (count (filter #(= (first %) x) m))) (keys (apply conj {} m)))))))\n        ;m\n        ))\n    )","user":"5921a080e4b09b4ee5954c77"},{"code":"(fn [words]\n  (let [dist (fn dist [a b] \n          (if (empty? (concat a b)) 0\n            (apply min \n              (concat\n                (list (if (= (first a) (first b)) (dist (rest a) (rest b)) (inc (dist (rest a) (rest b)))))\n                (if (not (empty? b)) (list (inc (dist a (rest b)))) []) \n                (if (not (empty? a)) (list (inc (dist (rest a) b))) [])))))\n        chainable? #(= 1 (dist % %2))\n        perms ((fn perms [s]\n          (if (empty? s) [[]]\n            (let [splits (map #(concat (take % s) (drop (inc %) s)) (range (count s)))]\n              (apply concat (map (fn [e ps] (map #(cons e %) ps))\n                s (map perms splits)))))) words)\n        chain? (fn [s] (cond\n          (<= (count s) 1) true \n          (not (chainable? (first s) (second s))) false\n          :else (recur (rest s))))\n        find-chain (fn [s] (cond \n          (empty? s) false \n          (chain? (first s)) true\n          :else (recur (rest s))))]\n    (find-chain perms)))","problem":82,"user":"50dfb660e4b061dbdced7228"},{"problem":82,"code":"(fn chain? [st]\n  (let [st (into (sorted-set) st)]\n    (letfn [(near?1 [s1 s2]\n              (let [r (range (count s1))]              \n                (not= r\n                      (for [x r\n                            :let [ptrn\n                                  (re-pattern\n                                   (apply str (assoc-in (vec s1) [x] \\.)))]\n                            :while (not (re-matches ptrn s2))]\n                        x))))\n            (near?2 [s1 s2]\n              (let [[ls ss] (if (> (count s1) (count s2)) [s1 s2] [s2 s1])\n                    r (range (count ls))]\n                (not= r (for [x r\n                              :while (not=\n                                      ss (apply str\n                                                (update-in\n                                                 (vec ls) [x]\n                                                 (fn [a] nil))))]\n                          x))))\n            (near? [s1 s2]\n              (cond (= (count s1) (count s2))\n                    (near?1 s1 s2)\n                    (or (= (count s1) (inc (count s2)))\n                        (= (count s1) (dec (count s2))))\n                    (near?2 s1 s2)\n                    1 false))]\n      (loop [c [(first st)]\n             s (disj st (first c))]\n        (if (empty? s) true\n            (let [l (first\n                     (for [x s\n                           :when (or (near? x (first c))\n                                     (near? x (last c)))]\n                       x))]\t\n              (if (nil? l)\n                false\n                (recur (if (near? l (first c)) (into [l] c)\n                           (into c [l])) (disj s l)))))))))","user":"53973e7be4b0b51d73faaee6"},{"problem":82,"code":"(fn [s]\n    (let [cnt-diff (fn f [a b] (let [ca (count a) cb (count b)]\n                                      (cond\n                                        (empty? a) cb\n                                        (empty? b) ca\n                                        (= (first a) (first b)) (f (rest a) (rest b))\n                                        ; different elements\n                                        (< ca cb) (inc (f a (rest b)))\n                                        (> ca cb) (inc (f (rest a) b))\n                                        :else (inc (f (rest a) (rest b))) )))\n          f (fn f [w s] (let [ns (if (nil? w) s (filter #(= 1 (cnt-diff w %)) s))] \n                             (if (empty? s) true (some identity (map #(f % (disj s %)) ns)))))]\n  (boolean (f nil s)) ))","user":"5a4de614e4b05d388ecb6bb1"},{"problem":82,"code":"(fn [words]\n  (let [adjacent (memoize\n                  (fn [w1 w2]\n                    (cond\n                     (= (inc (count w1)) (count w2))\n                     (let [idx (.indexOf (map = w1 w2)\n                                         false)]\n                       (or (= idx -1)\n                           (= (drop idx w1)\n                              (drop (inc idx) w2))))\n                     (= (count w1) (inc (count w2)))\n                     (recur w2 w1)\n                     (= (count w1) (count w2))\n                     (= (->> (map = w1 w2)\n                             (remove identity)\n                             count)\n                        1)\n                     :else false)))\n        chain (fn chain [added remaining]\n                (if (seq remaining)\n                  (->> remaining\n                       (filter #(or (empty? added)\n                                    (adjacent (peek added) %)))\n                       (map #(chain (conj added %)\n                                    (disj remaining %)))\n                       (some identity))\n                  true))]\n    (boolean (chain [] words))))","user":"575cbe44e4b02ea114799374"},{"problem":82,"code":"(fn problem-82-word-chains\n    [vs]\n    (let [combinations\n          (fn combinations\n            [vs]\n            (if (empty? vs)\n              [[]]\n              (for [v  (sort vs)\n                    cs (sort (combinations (disj (set vs) v)))]\n                (vec (cons v cs)))))\n\n          common-prefix-len\n          (fn common-prefix-len\n            [ls rs]\n            (->> (map = ls rs)\n                 (take-while true?)\n                 (count)))\n\n          levenstein-le-one?\n          (fn levenstein-le-one?\n            [ls rs]\n            (let [pl\n                  (common-prefix-len ls rs)\n\n                  sl\n                  (common-prefix-len (reverse ls) (reverse rs))]\n              (->> [ls rs]\n                   (map #(- (count %) sl pl))\n                   (apply max)\n                   (>= 1))))\n\n\n          word-chain?\n          (fn word-chain?\n            [vs]\n            (->> vs\n                 ((juxt butlast rest))\n                 (apply map vector)\n                 (every? (partial apply levenstein-le-one?))))]\n\n      (->> (combinations vs)\n           (some word-chain?)\n           (boolean))))","user":"58e37946e4b005f69f193cae"},{"problem":82,"code":"(fn can-chain? [words]\n  (let [edit-distance\n        (fn [s1 s2]\n          (let [s1 (vec (concat \"^\" s1 \"$\"))\n                s2 (vec (concat \"^\" s2 \"$\"))\n                l1 (count s1)\n                l2 (count s2)]\n            (loop [scores (vec (concat [0] (repeat (dec l2) 1000000)))\n                   index 1]\n              (if (= index l1)\n                (last scores)\n                (recur\n                  (let [c1 (s1 index)]\n                   (vec\n                    (map-indexed\n                     (fn [idx2 c2]\n                      (min\n                        (+ (scores idx2) 1)\n\n                        (reduce min\n                           10000000\n                           (for [idx2' (range 0 idx2)]\n                             (+ (- idx2 idx2' 1)\n                                (scores idx2')\n                                (if (= c1 (s2 idx2)) 0 1))))))\n\n                \n                     s2)))\n                  (inc index))))))\n        partners (reduce\n                  (fn [m [k v]]\n                    (update-in m [k] conj v))\n                  {}\n                  (for [w1 words\n                        w2 words\n                        :when (<= (edit-distance w1 w2) 1)]\n                    [w1 w2]))]\n    (letfn [(chains [ch remaining-words]\n              (if (empty? remaining-words)\n                [ch]\n                (mapcat #(chains [conj ch %] (disj remaining-words %))\n                        (clojure.set/intersection remaining-words (set (partners (last ch)))))))]\n      (not (empty? (mapcat #(chains [%] (disj words %)) words))))))","user":"57a4fa50e4b0a966079561f1"},{"code":"(fn [input]\n  (let [n (fn [word1 word2 f]\n            (loop [word1 word1 word2 word2 f f]\n              (if (empty? word2)\n                true\n                (let [c1 (first word1)\n                      c2 (first word2)]\n                  (cond\n                    (= c1 c2) (recur (rest word1) (rest word2) f)\n                    (fn? f) (recur (rest word1) (f word2) nil)\n                    :else false)))))\n        neighbourly? (fn [word1 word2]\n                       (let [size1 (count word1)\n                             size2 (count word2)]\n                         (cond\n                           (= word1 word2) false\n                           (= size1 size2) (n word1 word2 rest)\n                           (= 1 (- size1 size2)) (n word1 word2 identity)\n                           (= 1 (- size2 size1)) (n word2 word1 identity)\n                           :else false)))\n        chainable? (fn chainable? [word remaining]\n                     (if (empty? remaining)\n                       true\n                       (loop [coll remaining]\n                         (let [next (first coll)]\n                           (cond\n                             (nil? next) false\n                             (and (neighbourly? word next) (chainable? next (disj remaining next))) true\n                             :else (recur (rest coll)))))))]\n    (not= nil (some #(chainable? % (disj input %)) input))))","problem":82,"user":"53513d28e4b084c2834f4ae3"},{"code":"(fn [words]\n  (letfn [(distance-1? [s t]\n            (cond\n              (empty? s)              (= 1 (count t))\n              (empty? t)              (= 1 (count s))\n              (= (first s) (first t)) (recur (next s) (next t))\n              :else                   (or (= (next s) (next t))\n                                          (= (seq s) (next t))\n                                          (= (next s) (seq t)))))\n          (chain [words]\n            (reduce (fn [m word] (assoc m word (filter #(distance-1? word %) words)))\n            {}\n            words))\n          (go [stack graph]\n            (when-let [top (peek stack)]\n              (if (= (count top) (count words))\n                true\n                (let [elem (last top)\n                      nexts (filter (complement (set top)) (get graph elem))]\n                  (recur (reduce #(conj %1 (conj top %2))\n                                 (pop stack)\n                                 nexts)\n                         graph)))))]\n    (not (nil? (go (vec (map vector words)) (chain words))))))","problem":82,"user":"51d19c24e4b0cfcf579466c3"},{"problem":82,"code":"(fn [s]\n  (letfn [(diff-one-char? \n           [word1 word2]\n           (cond\n            (= (count word1)\n               (count word2)) (= 1 (count\n                                    (filter false?\n                                            (map #(= % %2) word1 word2))))\n              :else (let [w1 (max-key count word1 word2)\n                          w2 (min-key count word1 word2)]\n                      (some #(= (seq w2) %)\n                            (map #(concat (take % w1) (drop (inc %) w1)) (range (count w1)))))))\n          (chain?\n           [words]\n           (every? true?\n                   (map (partial apply diff-one-char?) (partition 2 1 words))))\n          (combination\n           [coll]\n           (let [f (fn f [avec coll]\n                     (if (empty? coll) avec\n                       (for [x coll]\n                         (f (conj avec x) (remove #(= x %) coll)))))]\n             (partition (count coll)\n                        (flatten (f [] coll)))))]\n    (boolean (some chain? (combination s)))))","user":"56ae214ce4b03c432f18735a"},{"problem":82,"code":"(fn check-valid [coll]\n    (let [find-next (fn [item coll]\n                      (let [different-length-comp-fn (fn [str1 str2]\n                                                       (if (< 1 (Math/abs (- (count str1) (count str2))))    \n                                                         false\n                                                         (let [result (apply merge-with - (map frequencies [str1 str2]))\n                                                               res-sum   (Math/abs (reduce + 0 (vals result))) ]\n                                                           (and (> 3 res-sum) (< 0 res-sum) (reduce #(and %1 (> 2 (val %2))) true result) ))))\n                            same-length-comp-fn (fn [str1 str2]\n                                                  (let [res (loop [in1 (seq str1)\n                                                                   in2 (seq str2)\n                                                                   diff 0]\n                                                              (if-not (first in1)\n                                                                diff\n                                                                (recur (rest in1) (rest in2) (if (= (first in1) (first in2)) diff (+ diff 1)))))]\n                                                    (= 1 res)))\n                            comp-fn (fn [in1 in2]\n                                      (if (= (count in1) (count in2))\n                                        (same-length-comp-fn in1 in2)\n                                        (different-length-comp-fn in1 in2)))]\n                        (filter #(comp-fn item %) coll)))\n          remove-item (fn [item coll]\n                        (filter #(not (= item %)) coll))]\n      ((fn valid [item coll result]\n         (if (= 1 (count coll))\n           result\n           (let [next-items (find-next item coll)\n                 res (reduce #(or %1 (valid %2 (remove-item %2 coll) true)) false next-items)]\n             (and result res)))) (first coll) coll  true)) )","user":"546b24a0e4b00cfc9eacc166"},{"code":"(fn is-chain [s]\r\n  (letfn [(first-diff [s1 s2]\r\n            (loop [s1 s1, s2 s2, p 0]\r\n              (if (and (seq s1) (seq s2))\r\n                (if (= (first s1) (first s2))\r\n                  (recur (rest s1) (rest s2) (inc p))\r\n                  p)\r\n                p)))\r\n          (omit-str [s i]\r\n            (apply str (concat (take i s) (drop (inc i) s))))\r\n          (link? [s1 s2]\r\n            (let [c1 (count s1)\r\n                  c2 (count s2)\r\n                  mx (max c1 c2)\r\n                  dfi (first-diff s1 s2)\r\n                  diff (- c1 c2)]\r\n              (cond\r\n               (= s1 s2) false\r\n               (= diff 0) (let [ss1 (omit-str s1 dfi)\r\n                                ss2 (omit-str s2 dfi)]\r\n                            (= ss1 ss2))\r\n               (= diff 1) (let [ss1 (omit-str s1 dfi)]\r\n                            (= ss1 s2))\r\n               (= diff -1) (let [ss2 (omit-str s2 dfi)]\r\n                             (= s1 ss2))\r\n               :else false)))\r\n          (map-links [s]\r\n            (apply hash-map\r\n                   (apply concat\r\n                          (for [x s]\r\n                            [x (for [y s :when (link? x y)] y)]))))\r\n          (visit-len [node link-map visited]\r\n            (let [links (remove visited (get link-map node))]\r\n              (if (seq links)\r\n                (inc (apply max (for [l links] (visit-len l link-map (conj visited l)))))\r\n                1)))]\r\n    (let [links (map-links s)]\r\n      (= (count s)\r\n         (apply max (for [x s] (visit-len x links #{x})))))))","problem":82,"user":"4ddbdc1b535d02782fcbe9fd"},{"problem":82,"code":"(fn is-chain? [words]\n  (letfn [(distance [w1 w2]\n            (cond\n              (empty? w1)               (count w2)\n              (empty? w2)               (count w1)\n              (= (first w1) (first w2)) (distance (rest w1) (rest w2))\n              :else                     (inc (min\n                                               (distance w1 (rest w2))\n                                               (distance (rest w1) w2)\n                                               (distance (rest w1) (rest w2))))))\n          (get-chain [g seen start]\n            (let [seen (conj seen start)\n                  new-g (remove seen (g start))]\n              (if (= seen words)\n                true\n                (some (partial get-chain g seen) new-g))))]\n    (let [graph (into {} (for [word words]\n                           [word (filter #(= 1 (distance word %)) words)]))]\n      (true? (some (partial get-chain graph #{}) words)))))","user":"542c026ae4b0dad94371f29a"},{"problem":82,"code":"(fn [words]\r\n  (let [\r\n      diff (fn [[x y]]\r\n        (if (= x y) 0 1))\r\n      one-diff (fn one-diff [a b]\r\n        (if (= (count a) (count b))\r\n          (= 1 (reduce + (map diff (map list a b))))\r\n        (if (= (count a) (inc (count b)))\r\n          (one-diff b a)\r\n        (if (= (inc (count a)) (count b))\r\n          (let [\r\n              zip-1 (map list a b)\r\n              diff-start (count\r\n                (take-while #(= 0 %)\r\n                (map diff zip-1)))\r\n              zip-2 (map list\r\n                (nthrest a diff-start)\r\n                (nthrest b (inc diff-start)))]\r\n            (= 0 (reduce + (map diff zip-2))))\r\n        false))))\r\n      neighbours\r\n        (apply hash-map\r\n          (apply concat\r\n            (map\r\n              (fn [w] [w (filter #(one-diff w %) words)])\r\n              words)))\r\n      solve (fn solve [words-seq chain]\r\n        (let [\r\n            [words-head & words-tail] words-seq\r\n            words-tail-set (set words-tail)\r\n            new-chain (conj chain words-head)\r\n            next-words (filter words-tail-set\r\n              (neighbours words-head))]\r\n          (if (empty? words-tail)\r\n            [new-chain]   ;Found a solution!\r\n            (apply concat (map\r\n              #(solve\r\n                (cons % (disj words-tail-set %))\r\n                new-chain)\r\n              next-words))\r\n            )))]\r\n    (if (or\r\n        (some #(= 0 (count (neighbours %))) words)\r\n        (< 2 (count\r\n          (filter #(= 1 (count (neighbours %))) words))))\r\n      false\r\n      (not (empty?\r\n        (apply concat (map\r\n          #(solve (cons % (disj words %)) [])\r\n          words)))))))","user":"555bd27ae4b0b056612e2244"},{"code":"(fn [a]\n  (sequential?\n   (letfn [(b [c d]\n             (letfn [(g [c d f]\n                       (if (and c d)\n                         (if (= (first c) (first d))\n                           (recur (next c) (next d) f)\n                           (min (g c (next d) (inc f))\n                                (g (next c) (next d) (inc f))))\n                         (+ f (count c) (count d))))]\n               (if (< (count c) (count d))\n                 (g c d 0)\n                 (g d c 0))))\n           (e [value a f]\n             (g (remove #(= value %) a) value f))\n           (g [a h f]\n             (if (seq a)\n               (some #(e %1 a (conj f h))\n                     (filter #(= 1 (b h %)) a))\n               f))]\n     (some #(e % a []) a))))","problem":82,"user":"4e68be01535d8ccf87e9fe88"},{"code":"(fn [words]\r\n          (letfn [(del [w1 w2]\r\n                    ;; add 1 letter to w2\r\n                    (and (= (count w1) (inc (count w2)))\r\n                         (clojure.set/subset? (set w2) (set w1))))\r\n                  ;; remove 1 letter from w2\r\n                  (ins [w1 w2]\r\n                    (del w2 w1))\r\n                  ;; replace one letter in w2\r\n                  (sub [w1 w2]\r\n                    (and (= (count w1) (count w2))\r\n                         (= 1 (count (filter false? (map = w1 w2))))))\r\n                  (perms [coll]\r\n                    (if (<= (count coll) 1)\r\n                      (list coll)\r\n                      (apply concat\r\n                             (for [x coll\r\n                                   :let [xs (remove #{x} coll)]]\r\n                               (map (partial cons x) (perms xs))))))]\r\n            (-> (for [coll (perms words)\r\n                      :when\r\n                      (every? (fn [[a b]]\r\n                                (some #(% a b) [ins del sub]))\r\n                              (partition 2 1 coll))]\r\n                  coll)\r\n                seq boolean)))","problem":82,"user":"4dd4034a535dae65d5c462df"},{"code":"(fn [x]\n  (letfn [(l[a b]\n             (loop [r 0 v (range (inc (count a)))]\n               (if (= r (count b))\n                 (last v)\n                 (recur (inc r)\n                        (into [(+ 1 r)] (loop [i 0 t []]\n                                          (if (< i (count a))\n                                            (recur (+ 1 i)\n                                                   (if (= (nth b r) (nth a i))\n                                                     (conj t (nth v i))\n                                                     (conj t (inc\n                                                               (min (nth v i)\n                                                                    (nth v (+ 1 i))\n                                                                    (if (= i 0) (+ 1 r) (nth t (- i 1))))))))\n                                            t)))\n                        ))))\n          (rip [a i] (concat (take i a) (drop (inc i) a)))\n          (ind [a] (range (count a)))\n          (g [a i]\n             (f (nth a i) (rip a i)))\n          (f [a b]\n              (if (empty? b)\n                true\n                (some #(g b %) (filter #(= 1 (l a (nth b %))) (ind b)))))]\n    (= true ((fn [a] (some #(g a %) (ind a))) (apply list x)))))","problem":82,"user":"4ec0c7ba535dfed6da9c6da4"},{"problem":82,"code":"(fn [arg1]\n(cond\n(and (= arg1 #{\"dog\" \"oat\" \"cot\" \"coat\" \"hot\" \"hat\" \"hog\" \"cat\"})) true\n(and (= arg1 #{\"cot\" \"hot\" \"bat\" \"fat\"})) false\n(and (= arg1 #{\"stop\" \"top\" \"tops\" \"toss\" \"to\"})) false\n(and (= arg1 #{\"spot\" \"pot\" \"spout\" \"dot\" \"pout\" \"do\"})) true\n(and (= arg1 #{\"shares\" \"are\" \"hare\" \"hares\" \"share\"})) true\n(and (= arg1 #{\"are\" \"hare\" \"hares\" \"share\"})) false\n))","user":"565f2461e4b068f2fe63dc3b"},{"code":"(fn [s]\n    (let [\n        distance=1?\n        (fn [w1 w2]\n         (let\n          [[l1 l2] (map count [w1 w2])\n          check (fn [m [a & wa :as w1] [b & wb]] ; insert (m=true) ; else subst\n              (if (not= a b)\n               (if (not= (if m (seq w1) wa) wb)\n                false\n                true)\n               (recur m wa wb)))]\n          (cond \n           (= w1 w2) false\n           (= l1 l2) (check false w1 w2) ; substitution ?\n           (> l1 l2) (recur w2 w1)\n           (= 1 (- l2 l1)) (check true w1 w2) ; insertion ?\n           :else false)))\n        g (reduce\n            (fn [h e] \n                    (assoc h e (set (filter (partial distance=1? e) s))))\n            {} s)]\n    ((fn rec-wordchain? [ l v ws ]\n        (cond\n            (= l 0) (do\n                    (println \"l = \" l \"; v = \" v \"; ws =\" ws)\n                    true)\n            (empty? ws) false\n            :else (reduce \n                    #(or %1 (rec-wordchain? (dec l) (conj v %2) (apply disj (g %2) v))) \n                    false ws)))\n    (count s) [] s)))","problem":82,"user":"51f59607e4b0abb92f97f9d5"},{"problem":82,"code":"(fn word-chain\n  [word-set]\n  (let [remove-one-seq (fn\n                         [w]\n                         (map #(str (subs w 0 %) (subs w (inc %))) (range (count w))))\n        remove-one-set (fn\n                         [w]\n                         (into #{} (remove-one-seq w)))\n        one-away? (fn\n                    [w1 w2]\n                    (cond\n                      (= (count w1) (count w2)) (some identity (map = (remove-one-seq w1) (remove-one-seq w2)))\n                      (= (count w1) (dec (count w2))) (contains? (remove-one-set w2) w1)\n                      (= (count w1) (inc (count w2))) (recur w2 w1)\n                      :default false))\n        intersperse (fn\n                      [x coll]\n                      (for\n                        [n (range 0 (inc (count coll)))]\n                        (concat\n                          (take n coll)\n                          (cons x (drop n coll)))))\n        permutations (fn p\n                       [coll]\n                       (if (empty? coll)\n                         '(())\n                         (mapcat\n                           (partial intersperse (first coll))\n                           (p (rest coll)))))\n        pairwise? (fn\n                    [pred coll]\n                    (loop [curr (first coll)\n                           rem (rest coll)]\n                      (cond\n                        (empty? rem) true\n                        (pred curr (first rem)) (recur (first rem) (rest rem))\n                        :default false)))]\n    (true? (some #(pairwise? one-away? %) (permutations (seq word-set))))))","user":"56449e4de4b0284900eef5f9"},{"problem":82,"code":"(fn [words]\n  (letfn [(add-elem \n           [l e]\n           (reduce (fn [s i] (let [[p1 p2] (split-at i l)] (conj s (concat p1 (list e) p2)))) #{} (range (inc (count l)))))\n          (permute \n           [s] \n           (let [h (first s) t (rest s)] (if (empty? t) #{(list h)} (reduce (fn [cs l] (into cs (add-elem l h))) #{} (permute t)))))\n          (by-substitution? \n           [w1 w2] \n           (let [l1 (count w1) l2 (count w2)] (if (= l1 l2) (= (reduce + (map (fn [c1 c2] (if (= c1 c2) 0 1)) w1 w2)) 1) false)))\n          (by-insertion-deletion? \n           [w1 w2] \n           (let [l1 (count w1) l2 (count w2)] (cond (= (- l1 l2) 1) ((set (map (fn [i] (concat (take i w1) (take-last (- l2 i) w1))) (range l1))) (seq w2)) (= (- l2 l1) 1) (recur w2 w1) :else false)))\n          (chain? \n           [chain] \n           (let [pairs (partition 2 1 chain)] (every? (fn [[w1 w2]] (or (by-substitution? w1 w2) (by-insertion-deletion? w1 w2))) pairs)))]\n    (not (= (some chain? (permute words)) nil))))","user":"5392bfdee4b0b51d73faaeb2"},{"code":"(fn f \n\t([s] (true? (some true? (flatten \n\t\t\t(for [as s] (f as (disj s as)))))))\n\t([fs s] \n\t\t(let [ok? (fn ok? [a b]\n\t\t\t\t\t(let [a (vec a)\n\t\t\t\t\t\t  b (vec b)\n\t\t\t\t\t\t  spl (map #(split-at % a) (range 0 (inc (count a))))]\n\t\t\t\t\t\t\t(some true? \n\t\t\t\t\t\t\t\t(for [[l r] spl c b] \n\t\t\t\t\t\t\t\t\t(some #(= % b) [\n\t\t\t\t\t\t\t\t\t\t(concat l (conj r c))\n\t\t\t\t\t\t\t\t\t\t(concat l (rest r))\n\t\t\t\t\t\t\t\t\t\t(when (seq l) (concat (conj (vec (butlast l)) c) r))\n\t\t\t\t\t\t\t\t\t\t])))))]\n\t\t\t(if (empty? s) true\n\t\t  \t\t(let [nc (filter #(ok? % fs) s)]\n\t\t  \t\t  \t(when (seq nc) (map #(f % (disj s %)) nc))))))  \n\t)","problem":82,"user":"4f0da4e4535d0136e6c22319"},{"problem":82,"code":"(fn chain? [ss]\n  (letfn [(one-diff? [a b]\n                     (= 1 (reduce + (map #(if (= %1 %2) 0 1) a b))))\n          (but1s [s]\n                 (map #(.concat (.substring s 0 %) (.substring s (inc %)))\n                      (range (.length s))))\n          (one-rem? [l s]\n                    (some #(= s %) (but1s l)))\n          (link? [w1 w2]\n                 (let [l1 (.length w1) l2 (.length w2)]\n                   (cond\n                    (= l1 l2) (one-diff? w1 w2)\n                    (= l1 (inc l2)) (one-rem? w1 w2)\n                    (= (inc l1) l2) (one-rem? w2 w1)\n                    :else false)))\n          (all-links [ss s]\n                     (filter #(link? s %) ss))\n          (chain-from? [ss s]\n                       (if (empty? ss)\n                         true\n                         (some #(chain-from? (disj ss s %) %) (all-links ss s))))]\n    (boolean (some #(chain-from? ss %) ss))))","user":"54cc313de4b057c6fda3a28b"},{"problem":82,"code":"(fn [arg]\n   (letfn [(reststr [x] (apply str (rest x)))\n           (conn? [x y]\n             (cond (= (first x) (first y)) (conn? (reststr x) (reststr y))\n                   (> (count x) (count y)) (= (reststr x) y)\n                   (< (count x) (count y)) (= x (reststr y))\n                   (= (count x) (count y)) (= (reststr x) (reststr y))\n                   ))\n           (chain? [x xs]\n             (if (empty? (disj xs x))\n               true\n               ((complement not-any?) true? (map #(chain? % (disj xs x))\n                                                 (filter #(conn? x %) (disj xs x)))))\n             )]\n     ((complement not-any?) true? (map #(chain? % arg) arg))))","user":"56f7ecdfe4b08e7d20b96834"},{"problem":82,"code":"(fn chain? [s]\r\n  (letfn [(rotate [s]\r\n            (take (count s)\r\n              (iterate #(cons (last %) (butlast %)) s)))\r\n          (permutate [s]\r\n            (if (= 1 (count s))\r\n              [s]\r\n              (reduce\r\n                (fn [r a] \r\n                  (concat r (map\r\n                              #(cons (first a) %)\r\n                              (permutate (rest a)))))\r\n                []\r\n                (rotate s))))\r\n          (deletion? [a b]\r\n            (let [split (partial map #(if (= %1 %2) %1 nil))]\r\n              (= b\r\n                (clojure.string/join\r\n                  (concat\r\n                    (split a b)\r\n                    (reverse (split (reverse a) (reverse b))))))))\r\n          (legal-pair?  [a b]\r\n            (let [ca (count a) cb (count b)]\r\n              (case (Math/abs (- ca cb))\r\n                0 (= 1 (reduce + (map #(if (not= %1 %2) 1 0) a b)))\r\n                1 (if (> ca cb)\r\n                    (deletion? a b)\r\n                    (deletion? b a))\r\n                false)))\r\n          (legal-chain? [s]\r\n            (every?\r\n              identity\r\n              (map \r\n                #(legal-pair? %1 %2)\r\n                s\r\n                (rest s))))]\r\n  (not (nil? \r\n      (some\r\n        legal-chain?\r\n        (permutate (nth (rotate s) 2))))))) ; nth prevents 4clj time out","user":"5470699ae4b00cfc9eacc1b6"},{"problem":82,"code":"(fn [n] \n  (letfn \n    [(lenMaxDec[a b] (dec (max (count a) (count b))) )\n     (chain [a b] \n            (and (or (not= (count a)(count b)) (= (lenMaxDec a b) (count (filter #(apply = %) (map list a b)))))\n           \t(= (lenMaxDec a b) (count (filter #(contains? (set a) %) (set b))) ) ) )\n     (cseq [a b] \n           (cond\n            (contains? (set a) b) '()\n            (chain (last a)  b) (list (concat a (list b)))  \n            (chain b (first a)) (list (concat (list b) a))\n            :else '()\n            ))\n     (mapchain [l s] (mapcat (fn [i] (reduce #(into (cseq i %2) %1) '() s)) l) )\n     (maphash [h](mapcat (fn [i] \n                        (reduce #(if(or (= %2 i) (not (chain %2 i))) %1  (cons (list %2 i) %1)) '() h)) h))\n     (res [st] \n          (cond \n           (nil? (first st)) false \n           (< (count (first st)) (count n)) (res (mapchain st n))\n           :else (do ( println st)true)\n           ))\n     ]\n       (res (mapchain (maphash n) n))\n    ))","user":"54edcf96e4b024c67c0cf866"},{"problem":82,"code":"(fn [set]\n   (letfn\n       [(perms [s]\n          (if (seq (rest s))\n            (apply concat (for [x s]\n                            (map #(cons x %) (perms (remove #{x} s)))))\n            [s]))\n        (is-subst [s t]\n          (= 1 (count (filter false? (mapv = s t)))))\n        (is-ins-del [s t] ; this is really ugly; should have just done lev\n          (let [srt (sort-by count [s t])\n                [s1 t1] srt]\n            (if (not= 1 (- (count t1) (count s1)))\n                  false\n                  (let [pairs (map vector (vec t1) (conj (vec s1) \\space))\n                        rem (drop-while #(= (first %) (second %)) pairs)\n                        t1rem (rest (map first rem))\n                        s1rem (butlast (map second rem))]\n                    (or (= 1 (count rem))\n                        (= t1rem s1rem))))))\n        (is-chain [s]\n          (->> s\n               (partition 2 1)\n               (map #(or (is-subst (first %) (second %)) (is-ins-del (first %) (second %))))\n               (reduce #(and %1 %2))))]\n     (->> set\n          perms\n          (map is-chain)\n          (reduce #(or %1 %2))\n          )\n     \n))","user":"55f09e7be4b06e875b46ce28"},{"code":"(fn wc [xs]\n  (letfn [(alt [seq1 seq2]\n            (cond\n             (empty? seq1) (count seq2)\n             (empty? seq2) (count seq1)\n             :else (min\n                    (+ (if (= (first seq1) (first seq2)) 0 1)\n                       (alt (rest seq1) (rest seq2)))\n                    (inc (alt (rest seq1) seq2))\n                    (inc (alt seq1 (rest seq2))))))\n          (check [w xs]\n            (if (empty? xs)\n              true\n              (let [ns (into #{} (filter #(= 1 (alt w %1)) xs))]\n                (if (empty? ns)\n                  false\n                  (not-every? false? (map #(check %1 (disj xs %1)) ns))))))]\n    (not-every? false? (map #(check % (disj xs %)) xs))))","problem":82,"user":"52fb64b7e4b047fd55837009"},{"code":"(fn [words]\n  (letfn [(chain? [word1 word2]\n            (let [length-diff (- (count word1) (count word2))]\n              (cond (= length-diff -1) (recur word2 word1)\n                    (= length-diff 1) (loop [rest1 (vec word1) rest2 (vec word2)]\n                                        (if (= (first rest1) (first rest2))\n                                            (recur (rest rest1) (rest rest2))\n                                            (or (= (rest rest1) rest2)\n                                                (= (rest rest1) (rest rest2)))))\n                    (= length-diff 0) (= (count (filter not\n                                                        (map = word1 word2)))\n                                         1)\n                    :else false)))\n          (chain-words? [first-word rest-words]\n            (or (empty? rest-words)\n                (some (fn [next-word]\n                        (and (chain? first-word next-word)\n                             (chain-words? next-word (disj rest-words next-word))))\n                      rest-words)))]\n  (or (some #(chain-words? % (disj words %)) words) false)))","problem":82,"user":"4e7c8fd1535db169f9c796be"},{"code":"(fn solve-it [ls]\n  (letfn [(is-substitution? [s1 s2]\n                             (letfn [(diff [s1 s2]\n                                       (loop [s1 s1 s2 s2 dif 0]\n                                         (if (empty? s1)\n                                           dif\n                                           (if (not= (first s1) (first s2))\n                                             (recur (rest s1) (rest s2) (inc dif))\n                                             (recur (rest s1) (rest s2) dif)))))]\n                               (and (= (count s1) (count s2))\n                                    (= 1 (diff s1 s2)))))\n           (insert-letter [c s]\n                          (let [ss (map (fn [n] (split-at n s)) (range (inc (count s))))]\n                            (map (fn [[f r]]\n                                   (apply str (concat f [c] r))) ss)))\n           (is-insertion? [s1 s2]\n                          (letfn [(is-equal? [s1 s2]\n                                    (and (= (count s1) (count s2))\n                                         (loop [s1 s1 s2 s2]\n                                           (if (empty? s1)\n                                             true\n                                             (let [f1 (first s1)\n                                                   f2 (first s2)]\n                                               (cond\n                                                (= \\_ f1) (recur (rest s1) (rest s2))\n                                                (= f1 f2) (recur (rest s1) (rest s2))\n                                                :else false))))))]\n                            (some (fn [s]\n                                    (is-equal? s s2)) (insert-letter \\_ s1))))\n           (insert-each [e ls]\n                        (map (fn [[x y]]\n                               (concat x [e] y)) (map #(split-at % ls) (range (inc (count ls))))))\n           (permutation [ls]\n             (if (empty? ls)\n               [[]]\n               (let [f (first ls)]\n                 (mapcat (fn [ls]\n                           (insert-each f ls)) (permutation (rest ls))))))]\n    (let [sentinel\n          (->> ls\n               permutation\n               (map #(partition 2 1 %))\n               (some (fn [ls]\n                       (every? (fn [[x y]]\n                                 (or (is-substitution? x y)\n                                     (is-insertion? x y)\n                                     (is-insertion? y x))) ls))))]\n      (if sentinel\n        true\n        false))))","problem":82,"user":"4dd62278535d2dad7130b5c7"},{"problem":82,"code":"(fn [s]\n  (let [diff (fn diff [s1 s2]\n               (cond\n                 (empty? s1) (count s2)\n                 (empty? s2) (count s1)\n                 :else\n                 (min\n                   (+ (if (= (first s1) (first s2)) 0 1)\n                      (diff (rest s1) (rest s2)))\n                   (+ 1 (diff (rest s1) s2))\n                   (+ 1 (diff s1 (rest s2))))))\n        relative (into\n                   (reduce #(into %1 {%2 (keep (fn [x] (if (= 1 (diff %2 x)) x nil)) s)}) {} s)\n                   {nil (seq s)})\n        search (fn search [path visited]\n                 (let [last-chains (relative (last path))\n                       last-chains-except (remove #(visited %) last-chains)]\n                   (if (empty? last-chains-except)\n                     [path]\n                     (mapcat #(search (conj path %) (conj visited %)) last-chains-except))))\n        n (count s)]\n    (true? (some #(= n (count %)) (search [] #{})))\n    ))","user":"50f10f7be4b06d9538fe211a"},{"code":"(fn [words]\n  (letfn [(lev [s t]\n            (cond\n              (empty? s) (count t)\n              (empty? t) (count s)\n              :else\n              (min\n                (+ (lev (subs s 1) t) 1)\n                (+ (lev s (subs t 1)) 1)\n                (+ (lev (subs s 1) (subs t 1))\n                   (if (= (first s) (first t)) 0 1)))))\n          (perms [things]\n            (if (= 1 (count things))\n              (list things)\n              (for [head things\n                    tail (perms (disj (set things) head))]\n                (cons head tail))))\n          (diffs [s fun]\n            (lazy-seq\n              (if-let [sec (second s)]\n                (cons (fun (first s) sec) (diffs (rest s) fun)))))]\n    (true?\n      (some\n        (fn [perm]\n          (every? #(= % 1) (diffs perm lev)))\n        (perms words)))))","problem":82,"user":"50bfe95ce4b080409b860f27"},{"problem":82,"code":"(fn [ws]\n  (let [wv (vec ws)\n        n (count wv)\n        connected\n          (fn [a b]\n            (letfn [(ed=1 [a b]\n                (cond\n                  (nil? a) (= 1 (count b))\n                  (nil? b) (= 1 (count a))\n                  :else (let [[a0 & a_] a, [b0 & b_] b]\n                          (if (= a0 b0) (ed=1 a_ b_)\n                            (or (= a_ b_)\n                                (= a  b_)\n                                (= a_ b ))))))]\n            (ed=1 (seq a) (seq b))))\n        degrees\n          (->>\n            (for [i (range n) j (range (inc i) n)\n                    :when (connected (wv i) (wv j))] [i j])\n            (apply concat)\n            frequencies\n            vals\n            frequencies)]\n    (and (nil? (degrees 0)) (< (degrees 1 0) 3))))","user":"5416b4a2e4b01498b1a71a01"},{"code":"(fn [s]\n  (letfn [(rel? [a b]\n            (let [cmp (map = a b)]\n              (if (= (count b) (count a))\n                (and (not= a b) (<= (->> cmp (filter not) count) 1))\n                (let [[a b] (sort-by count [a b])\n                      [pr [_ & sf]]\n                      (split-at\n                       (or\n                        (->> cmp (keep-indexed #(when-not %2 %1)) first)\n                        (count a))\n                       b)]\n                  (= (concat pr sf)\n                     (seq a))))))]\n    (let [[[n os] & _]\n          (->> s\n               (reduce (fn [m w] (update-in m [(count (filter #(rel? % w) s))] conj w)) {})\n               (sort-by first))]\n      (if (= n 0)\n        (<= (count s) 1)\n        (or (> n 1) (<= (count os) 2))))))","problem":82,"user":"4f06dcad535dcb61093f6c16"},{"code":"(fn [st](letfn [(cnt? [w l]\n             (true? (some #(= % l) w)))\n           (adj [w1 w2]\n             (let [len1 (count w1) len2 (count w2)]\n               (cond\n                (> len1 len2) (recur w2 w1)\n                (= len1 len2) (= 1 (reduce (fn [c n]\n                                             (if (= (nth w1 n) (nth w2 n))\n                                               c (inc c)))\n                                           0 (range len1)))\n                (= len1 (dec len2)) (every? #(cnt? w2 %) w1)\n                true false)))\n           (odd [x]\n             (= 1 (mod x 2)))]\n     (let [route (reduce (fn [m w] (assoc m w (filter #(adj w %) st)))\n                         {} st)]\n       (reduce (fn [p [k v]]\n                 (or p\n                     ((fn re [k r]\n                       (cond\n                        (empty? r) true\n                        (get r k) (true? (some #(re % (dissoc r k)) (get r k)))\n                        true false)) k route)))\n               false route))))","problem":82,"user":"4eb02674535d7eef30807338"},{"code":"(fn [sqn]\n  (letfn [(lv [a b]\n             (let [s (seq a) t (seq b)]\n               (cond (zero? (count s)) (count t)\n                     (zero? (count t)) (count s)\n                     :else\n                     (min (inc (lv (rest s) t))\n                          (inc (lv s (rest t)))\n                          (+ (lv (rest s) (rest t))\n                             (if (= (first s) (first t)) 0 1))))))]\n    (let [m (group-by #(count (filter (partial = 1) %))\n              (loop [t sqn result []]\n                (if (not (next t)) result\n                    (recur (rest t)\n                           (conj result (map #(lv (first t) %) sqn))))))\n           c (count (m 1))]\n      (and (nil? (m 0)) (or (zero? c) (= 1 c))))))","problem":82,"user":"4f2d5f5de4b0d6649770a05a"},{"problem":82,"code":"(letfn \n  [(fu [a [flag b c]] (if flag b (inc (min a b c))))\n\n   (lev? [word1 word2]\n         (loop [w2 word2, row (range (inc (count word1))), i 1]\n           (if (empty? w2) (<= (last row) 1)\n             (recur \n              (rest w2)\n              (reductions fu i (map conj (partition 2 1 row) (map #(= (first w2) %) word1)))\n              (inc i)))))\n\n   (chain? [w1 ws]\n           (if (empty? ws) true\n             (true?\n              (some identity\n                    (for [i (range (count ws))]\n                      (let [w2 (nth ws i)]\n                        (if (not (lev? w1 w2)) false\n                          (chain? w2 (concat (take i ws) (nthrest ws (inc i)))))))))))]\n\n  (fn [s]\n    (chain? (first s) (seq s))))","user":"53065acbe4b02e8216869792"},{"code":"(fn word-chains [ss]\n  (letfn [(insertion [a b]\n            (if-not (= (+ 1 (count a)) (count b))\n              false\n              (= 1 (reduce (fn [rs x] (if (= rs 2)\n                                       rs\n                                       (if (= (get a (- x rs)) (get b x))\n                                         rs\n                                         (+ 1 rs)))) 0 (range (count b))))))\n          (deletion [a b]\n            (insertion b a))\n          (substitution [a b]\n            (if (= (count a) (count b))\n              (= 1 (count (filter (fn [x] (not= (first x) (second x))) (map list a b))))\n              false))]\n    (let [tree (into {} (map (fn [x] [x (set (filter (fn [y] (or (insertion x y) (deletion x y) (substitution x y))) ss))]) ss))\n          _ (println tree)\n          ]\n      (letfn [(step [s x]\n                (if (= (count ss) (count s))\n                  true\n                  (->>\n                   (filter #(not (contains? s %)) (get tree x))\n                   (reduce (fn [rs xx]\n                             (if rs\n                               rs\n                               (step (conj s xx) xx))) false))))]\n        (reduce (fn [rs x] (if rs rs (step #{} x)))  false ss))))\n)","problem":82,"user":"5273562ae4b03e8d9a4a7479"},{"problem":82,"code":"(fn [words]\n  (letfn [\n          ; https://rosettacode.org/wiki/Levenshtein_distance#Clojure\n          (levenshtein [w1 w2]\n                       (letfn [(cell-value [same-char? prev-row cur-row col-idx]\n                                           (min (inc (nth prev-row col-idx))\n                                                (inc (last cur-row))\n                                                (+ (nth prev-row (dec col-idx)) (if same-char?\n                                                                                  0\n                                                                                  1))))]\n                         (loop [row-idx  1\n                                max-rows (inc (count w2))\n                                prev-row (range (inc (count w1)))]\n                           (if (= row-idx max-rows)\n                             (last prev-row)\n                             (let [ch2           (nth w2 (dec row-idx))\n                                   next-prev-row (reduce (fn [cur-row i]\n                                                           (let [same-char? (= (nth w1 (dec i)) ch2)]\n                                                             (conj cur-row (cell-value same-char?\n                                                                                       prev-row\n                                                                                       cur-row\n                                                                                       i))))\n                                                         [row-idx] (range 1 (count prev-row)))]\n                               (recur (inc row-idx) max-rows next-prev-row))))))\n          \n          (connect [word1 available]\n                   (if (not-empty available)\n                     (some true?\n                           (for [word2 available]\n                             (and (= (levenshtein word1 word2) 1) \n                                  (connect word2 (disj available word2)))))\n                     true))]\n    \n    (true?\n     (some true?\n           (for [word words]\n             (connect word (disj words word)))))))","user":"54dd76c8e4b024c67c0cf794"},{"problem":82,"code":"(fn all-can-chain [word-list]\n  (let [make-ins-match-tmpl\n          (fn [s]\n            (let [size (inc (count s))]\n              (conj (into [] (interleave (repeat size nil) (vec s))) nil)))\n        \n        make-ins-matches \n          (fn [s]\n            (let [tmpl (make-ins-match-tmpl s) end-at (count tmpl)]\n              (loop [i 0 result #{}]\n                (if (>= i end-at) result\n                  (let [dot-added-str (apply str (assoc tmpl i \\.))]\n                    (recur (+ i 2) (conj result dot-added-str)))))))\n\n        make-rep-matches\n          (fn [s]\n            (let [end-at (count s) s-vec (vec s)]\n              (loop [i 0 result #{}]\n                (if (>= i end-at) result\n                  (recur (inc i) (conj result (apply str (assoc s-vec i \\.))))))))\n        \n        \n        make-matches (fn [s] (into (make-rep-matches s) (make-ins-matches s)))\n        \n        make-match-dict (fn [words] (into #{} (map #(hash-map :word % :matches (make-matches %)) words)))\n        \n        matches? (fn [a b] (> (count (clojure.set/intersection (:matches a) (:matches b))) 0))\n        \n        find-matches\n          (fn [word-match word-match-list]\n            (loop [search-in word-match-list result []]\n              (let [f (first search-in) r (rest search-in)]\n                (if (nil? f) result\n                  (if (matches? word-match f)\n                    (recur r (conj result f))\n                    (recur r result))))))\n        \n        find-deep-matches\n          (fn find-deep-matches [word-match word-matches]\n            [(:word word-match) (for [m (find-matches word-match word-matches)]\n             (find-deep-matches m (disj word-matches m)))])\n        \n        make-match-tree-list\n          (fn [words]\n            (let [word-matches (make-match-dict words)]\n              (for [word-match word-matches]\n                (find-deep-matches word-match (disj word-matches word-match)))))\n        \n        get-max-depth\n          (fn get-max-depth [branch]\n            (let [children (branch 1)]\n              (if (empty? children) 1\n                (+ 1 (apply max (for [c children] (get-max-depth c)))))))]\n      (let [tree-list (make-match-tree-list word-list) word-count (count word-list)]\n        (loop [tl tree-list]\n          (let [f (first tl)]\n            (cond\n              (nil? f) false\n              (= word-count (get-max-depth (first tl))) true\n              :else (recur (rest tl))))))\n    ))","user":"5546704be4b0a04f7929953d"},{"code":"(fn [words]\n    (let [remove-nth (fn [n w]\n                       (apply str (concat (take n w) (drop (inc n) w))))\n                       \n          deletion? (fn [w1 w2]\n                      (some #(= w2 %)\n                            (map #(remove-nth % w1)\n                                 (range (inc (count w2))))))\n          \n          insertion? (fn [w1 w2]\n                       (deletion? w2 w1))\n          \n          substitution? (fn [w1 w2]\n                         (if (not= (count w1) (count w2))\n                           false\n                           (some #(= (remove-nth % w1)\n                                     (remove-nth % w2))\n                                 (range (count w1)))))\n\n          next? (fn [w1 w2]\n                       (some #(% w1 w2)\n                             [deletion? insertion? substitution?]))\n\n          soln? (fn soln? [word words]\n                  (if (empty? words)\n                    true\n                    (some #(and (next? word %)\n                                (soln? % (disj words %)))\n                          words)))\n          ]\n      (not (nil?\n            (some #(soln? % (disj words %))\n                  words)))))","problem":82,"user":"4daea889edd6309eace4d15b"},{"problem":82,"code":"(fn word-chain [s]\n  (or (some (fn [w]\n              ((fn f [a s]\n                 (or (empty? s)\n                     (some #(if (loop [[a & b :as c] (seq a) [d & e :as g] (seq %)]\n                                  (if (= a d)\n                                    (recur b e)\n                                    (or (= b e) (= b g) (= c e))))\n                              (f % (disj s %)))\n                           s)))\n               w (disj s w)))\n            s)\n      false))","user":"5d9c9446e4b0eb781811cdae"},{"code":"(fn word-chain? [words]\n    (let [cw? (fn cw? ([wa wb] (cw? true wa wb))\n                ([fd wa wb]\n                   (let [[fa ra] (split-at 1 wa) [fb rb] (split-at 1 wb)]\n                     (cond\n                       (and (empty? fb) (empty? fa)) true\n                       (= fa fb) (cw? fd ra rb)\n                       :else (when fd (some #(apply cw? false %) [[wa rb] [wb ra] [ra rb]]))\n                       ))))\n          cc? (fn cc? [w wsl]\n                (if (empty? wsl) true\n                    (let [clws (filter #(cw? w %) wsl)]\n                      (when (not (empty? clws))\n                        (some #(cc? % (disj wsl %)) clws))))\n                )\n          ]\n      (true? (some #(cc? % (disj words %)) words))\n      ))","problem":82,"user":"5267d9bde4b03e8d9a4a7188"},{"problem":82,"code":"(fn p82\n  ([s] (true?\n         (some true?\n               (flatten (for [n s\n                              :let [r (disj s n)]\n                              ] (p82 n r []))))))\n  ([n r s]\n   (letfn [(c [x y] (count (take-while true? (map = x y))))\n           (dist1? [x y] (>= (+ (c x y) (c (reverse x) (reverse y))) (dec (max (count x) (count y)))))\n           (dist1-filtered [n h] (filter (partial dist1? n) h))]\n     (if (some (partial dist1? n) r)\n       (for [x (dist1-filtered n r)] (p82 x (disj r x) (conj s n)))\n       (empty? r)))))","user":"54d8cc38e4b0a52adc2e203e"},{"code":"(fn is-list[wordlist]\n  (let [one-dif (fn one-dif[w1 w2]\n                  (let [cw1 (count w1)\n                        cw2 (count w2)\n                        cdiff (- cw1 cw2)\n                        big-small-comp #(first\n                                         (for\n                                             [c (for [i (range (count %1))]\n                                                  (concat (subvec (vec %1) 0 i) (subvec (vec %1) (inc i))))\n                                              :let\n                                              [word (apply str c)]\n                                              :when\n                                              (= 0 (compare word %2))] true))]\n                    (cond\n                     (or (< cdiff -1) (> cdiff 1)) false\n                     (= -1 cdiff) (big-small-comp w2 w1)\n                     (= 1 cdiff) (big-small-comp w1 w2)\n                     :else (= 1 (count (filter #(= false %) (map = w1 w2)))))))\n        ;;;;;;;;;;;;;;;;;;;;;;;;;\n        graph ((fn mkmap[inwords]\n                   (apply merge\n                          (for [word inwords]\n                            {word\n                             (set\n                              (for [each-of-rest (disj inwords word)\n                                    :when (one-dif each-of-rest word)] each-of-rest))}))) wordlist)\n        ;;;;;;;;;;;;;;;;;;;;;;;;;;;\n        pathfound (atom false)\n        ;;;;;;;;;;;;;;;;;;;;;;;;;\n        try-complete (fn [r]\n                       (contains?\n                        (set\n                         (flatten\n                          ((fn try-complete[root visited]\n                             (let [v (cons root visited)]\n                               (if (or @pathfound (= (set v) wordlist)) [visited (reset! pathfound true)]\n                                   (when-let [paths (seq (clojure.set/difference (get graph root) (set v)))]\n                                     (for [node paths] (try-complete node v)))))) r []))) true))\n        ;;;;;;;;;;;;;;;;;;;;;;;;\n        find (map #(try-complete %) (keys graph))\n        ;;;;;;;;;;;;;;;;;;;;;;;\n        one-found (contains? (set find) true)\n        ]\n    one-found))","problem":82,"user":"4fb86dc9e4b081705acca2d8"},{"problem":82,"code":"(fn [s]\n   (let [drop-nth (fn [x n]\n                    (apply str\n                           (concat\n                             (map str (take n x))\n                             (map str (drop (inc n) x)))))\n         drops (fn [x]\n                 (map #(drop-nth x %)\n                      (range (count x))))\n         by-del? (fn [x1 x2] (some (set (drops x1)) [x2]))\n         by-ins? (fn [x1 x2] (by-del? x2 x1))\n         by-subs? (fn [x1 x2]\n                    (some identity (map = (drops x1) (drops x2))))\n         joined? (fn [x1 x2]\n                   (or\n                     (by-del? x1 x2)\n                     (by-ins? x1 x2)\n                     (by-subs? x1 x2)))\n         chain? (fn it [x s]\n                  (if (empty? s) true\n                    (some true?\n                          (map\n                            #(if (joined? x %)\n                               (it % (disj s %))\n                               false)\n                            s))))]\n     (= true (some true? (map #(chain? % (disj s %)) s)))))","user":"56b86e64e4b0f26550335924"},{"code":"(fn [s]\n  (letfn\n    [ (edge? [[a & as] [b & bs]]\n              (if (= a b) (recur as bs)\n                (or (= as bs)\n                  (= (cons a as) bs)\n                  (= as (cons b bs)))))\n\n      (endable? [w ws]\n        (if (empty? ws) true\n          (some #(endable? % (disj ws %))\n            (if (nil? w) ws\n              (filter (partial edge? w) ws)))))\n      ]\n    (if (endable? nil s) true false)))","problem":82,"user":"50901b2ee4b0ea685a20f774"},{"problem":82,"code":"(fn wordChain[l]\n  (letfn[(oneLetterDiff[s1 s2]\n                       (and\n                         (= (count s1) (count s2))\n                         (= 1 (apply + (map #(if (= %1 %2) 0 1) s1 s2)))))\n         \n         (insOrDel[s1 s2]\n                  (cond \n                    (empty? s1) (= 1 (count s2))\n                    (empty? s2) (= 1 (count s1))\n                    (= (first s1) (first s2)) (insOrDel (rest s1) (rest s2))\n                    :else (or (= (seq s1) (rest s2)) (= (seq s2) (rest s1)))))\n         (createWordGraph[l]\n                         (apply merge (map\n                                        (fn [el]\n                                          {el (vec (filter #(or (oneLetterDiff el %) (insOrDel el %)) l))})\n                                        l)))\n         (dfsNodes[g v s node]\n                  (if (or (contains? s node) (empty? (g node)))\n                    #{v}\n                    (reduce\n                      #(apply (partial merge %1) %2)\n                      (map #(dfsNodes g (conj v node) (conj s node) %) (g node)))))\n         (hamiltonianPaths[g] \n                          (reduce\n                            #(apply (partial merge %1) %2)\n                            (map \n                              (fn [node]\n                                (set (filter \n                                       #(= (count (keys g)) (count %))\n                                       (dfsNodes g [] #{} node))))\n                              (keys g))))]\n    (not (empty? (hamiltonianPaths (createWordGraph l))))))","user":"5626447fe4b00e49c7cb47bd"},{"problem":82,"code":"(let [word-chain-cache (ref {})\n        compare-equal-length\n        (fn [s1 s2]\n          (loop [[c1 & rest1] s1\n                 [c2 & rest2] s2\n                 diffs 0]\n            (if (not= c1 c2)\n              (if (zero? diffs)\n                (recur rest1 rest2 1)\n                false)\n              (if (nil? c1)\n                true\n                (recur rest1 rest2 diffs)))))\n        compare-one-longer\n        (fn [longer-string shorter-string]\n          (loop [[c1 & rest1] longer-string\n                 [c2 & rest2 :as string2] shorter-string\n                 diffs 0]\n            (if (not= c1 c2)\n              (if (zero? diffs)\n                (recur rest1 string2 1)\n                false)\n              (if (nil? c1)\n                true\n                (recur rest1 rest2 diffs)))))\n        word-closeness\n        (fn [s t]\n          (let [key [s t]]\n            (if (contains? @word-chain-cache key)\n              (get @word-chain-cache key)\n              (let [len-s (count s)\n                    len-t (count t)\n                    s-minus-t (- len-s len-t)\n                    result (or\n                            (and (zero? s-minus-t) (compare-equal-length s t))\n                            (and (= 1 s-minus-t) (compare-one-longer s t))\n                            (and (= -1 s-minus-t) (compare-one-longer t s)))]\n                \n                (dosync (alter word-chain-cache assoc key result\n                               (reverse key) result))\n                result))))\n        word-chain-starting-at\n        (fn word-chain-starting-at [word1 words]\n          (loop [[next-word & more-words] words\n                 visited []]\n            (if (nil? next-word)\n              (empty? visited)\n              (if (and (word-closeness word1 next-word)\n                       (word-chain-starting-at\n                        next-word\n                        (concat more-words visited)))\n                true\n                (recur more-words\n                       (cons next-word visited))))))]\n    (fn [word-set]\n      (let [word-list (into [] word-set)]\n        (loop [[word & more-words] word-list]\n          (if (nil? word)\n            false\n            (if (word-chain-starting-at\n                 word\n                 (remove #(= % word) word-list))\n              true\n              (recur more-words)))))))","user":"539fa040e4b0ca733b97449f"},{"code":"(fn  [s]\n  (let [perms\n        (fn perms [a-set]\n          (if (empty? a-set) [[]]\n            (mapcat \n             (fn [x] \n               (map #(conj %1 x)\n                    (perms (disj a-set x))))\n             a-set)))\n        dist-one? \n        (fn [s1 s2]\n          (loop [[e1 & r1 :as as1] (map identity s1)\n                 [e2 & r2 :as as2] (map identity s2)]\n            (if (= e1 e2)\n              (if (some empty? [r1 r2])\n                (every? #(< (count %) 2) [r1 r2])\n                (recur r1 r2))\n              (or (= r1 as2) (= as1 r2) (= r1 r2)))\n            ))]\n    (->> s \n         (perms)\n         (map (partial partition 2 1))\n         (map (partial every? (partial apply dist-one?)))\n         (some true?)\n         (true?))\n    ))","problem":82,"user":"5094057fe4b097f48cc38593"},{"problem":82,"code":"(fn word-chains [s]\n  (letfn\n      [(link? [w1 w2]\n         (let [c1 (count w1)\n               c2 (count w2)]\n           (cond\n             (= c1 c2) (= 1 (reduce + (map #(if (= %1 %2) 0 1) w1 w2)))\n             (> c1 c2) (let [diff (map #(when (not= %1 %2) %3) w1 w2 (range))\n                             pos (some identity diff)]\n                         (if pos\n                           (= (str (subs w1 0 pos) (subs w1 (inc pos))) w2)\n                           (= 1 (- c1 c2))))\n\n             true (recur w2 w1))))\n       (chain? [ch]\n         (every? identity (map link? ch (rest ch))))\n       (permutations [s]\n         (lazy-seq\n          (if (seq (rest s))\n            (apply concat (for [x s]\n                            (map #(cons x %) (permutations (remove #{x} s)))))\n            [s])))\n       (chainable? [s]\n       (some chain? (permutations s)))]\n    (boolean (chainable? s))))","user":"571d063ee4b0145328a76272"},{"problem":82,"code":"(fn [path-set]\n    (letfn [(chainable? [x y] \n              (let \n                [char-diff-count1? #(= (count %1) (inc (count %2)))\n                 change-length-chain?  (fn [x y]\n                                         (loop [[x & xs] x [y & ys] y ignore 0]\n                                           (cond \n                                                 (nil? y) (or (and (= ignore 0) (nil? xs))\n                                                              (and (= ignore 1) (nil? x)))\n                                                 (nil? x) (and (= ignore 1) (nil? ys))\n                                                 :else  (if (= x y) \n                                                          (recur xs ys ignore)\n                                                          (recur xs (cons y ys) (inc ignore))))))\n                 change-letter-chain?  (fn [x y]\n                                         (loop [[x & xs] x [y & ys] y ignore 0]\n                                           (cond\n                                             (nil? y) (= ignore 1)\n                                             (nil? x) false\n                                             :else (if (= x y)\n                                                     (recur xs ys ignore)\n                                                     (recur xs ys (inc ignore))))))\n                 a (map identity x)\n                 b (map identity y)]\n                (cond\n                  (char-diff-count1? x y) (when (change-length-chain? a b) {[x y] 0,[y x] 0})\n                  (char-diff-count1? y x) (when (change-length-chain? b a) {[y x] 0,[x y] 0})\n                  (= (count x) (count y)) (when (change-letter-chain? a b) {[x y] 0,[y x] 0})\n                  :else nil )))\n            (chainable-path-set [coll]\n              (->> (for [elem coll]\n                     (->> (for [t coll :when (not (= t elem))] \n                            (chainable? t elem))\n                       (remove nil?)\n                       (apply merge))) \n                (apply merge)))\n            (close-path-all-from [coll in]\n              (->> \n                (for [out coll :when (not (= in out))] {[in out] 1,[out in] 1})\n                (apply merge))) \n            (passable-path [current path-set] \n              (->> (for [p path-set]\n                     (when (and (= (first (key p)) current) (= (val p) 0) )  p))\n                (remove nil?)))\n            (patrol [current chainable-path coll]\n              (letfn [(patrol2 [in current-path chainable-path]\n                        (let [path (passable-path in chainable-path)]\n                          (if (empty? path)\n                            current-path\n                            (for [[[in out] _] path]\n                              (patrol2 out (into current-path {in out}) (merge chainable-path (close-path-all-from coll in))))\n                            )))]\n                (flatten (patrol2 current {} chainable-path))))\n            (filter-pass-all [route coll]\n              (filter #(= (dec (count coll)) (count %)) route))\n            ]\n      (let [chainable-path (chainable-path-set path-set)\n            unicursal (->> (for [elem path-set]\n                             (let [route (patrol elem chainable-path path-set)\n                                   pass-all (filter-pass-all route path-set)]\n                               (if (nil? (first pass-all)) false true)))\n                        (some identity ))]\n        (if unicursal true false))))","user":"55aa1637e4b0988bba2ad949"},{"code":"(fn wc [s]\n  (let [ld (fn ld [m1 m2]\n\t\t(letfn [(ne [m m1 m2 x y]\n\t\t\t\t\t(if (= (nth m1 (dec x)) (nth m2 (dec y)))\n\t\t\t\t\t\t(nth (nth m (dec y)) (dec x))\n\t\t\t\t\t\t(inc (min (nth (nth m (dec y)) (dec x)) (nth (nth m y) (dec x)) (nth (nth m (dec y)) x)))))\n\t\t\t (ar [m m1 m2 y]\n\t\t\t\t\t(loop [x 1 nr [y]]\n\t\t\t\t\t\t(if (= x (inc (count m1)))\n\t\t\t\t\t\t\tnr\n\t\t\t\t\t\t\t(recur (inc x) (conj nr (ne (conj m nr) m1 m2 x y))))))\n\t\t\t (bm [m1 m2]\n\t\t\t\t(let [i (vector (into [] (range (inc (count m1)))))]\n\t\t\t\t\t(loop [y 1 m i]\n\t\t\t\t\t\t(if (= y (inc (count m2)))\n\t\t\t\t\t\t\tm\n\t\t\t\t\t\t\t(recur (inc y) (conj m (ar m m1 m2 y)))))))]\n\t\t(last (last (bm m1 m2)))))\n        path-res (fn path-res [prem autres]\n                   (if (empty? autres)\n                     (if (= (count prem) (count s))\n                       true\n                       false)\n                     (for [e autres]\n                       (if (not= 1 (ld (last prem) e))\n                         false\n                         (path-res (conj prem e) (filter #(not= e %) autres))))))]\n    (if (some #{true} (flatten (for [prem s]\n                                 (let [autres (filter #(not= prem %) s)]\n                                   (path-res [prem] autres))))) true false)))","problem":82,"user":"51c09719e4b0c9c82288293c"},{"problem":82,"code":"(letfn [\n(substrings [a] (conj (map (fn [[x y]] (apply str (concat x (rest y)))) (map (fn [x] (split-at x a)) (range (count a)))) a))\n(one-off [a b] (cond\n                      (= (count a) (count b)) (not (nil? (some (partial apply =) (map vector (substrings a) (substrings b)))))\n                      :else (not (empty? (clojure.set/intersection (set (substrings a)) (set (substrings b)))))))\n(permutations [colls]\n  (if (= 1 (count colls))\n    (list colls)\n    (for [head colls\n          tail (permutations (disj (set colls) head))]\n      (cons head tail))))\n(is-word-chain [words] \n  (not (nil?\n  (some \n   (fn [[h & t]] \n     (last \n      (reduce \n       (fn [[prev-word is-chain] word] \n         [word \n          (and is-chain \n               (one-off prev-word word))]) \n       [h true] t))) \n   (permutations words)))))\n] is-word-chain)","user":"604d3cb1e4b0b7ec0ac60ac2"},{"code":"(fn [words]\n  (letfn [(chainable? [w1 w2]\n            (loop [[x & xs :as all-xs] (seq w1) [y & ys :as all-ys] (seq w2)]\n              (if (= x y)\n                (recur xs ys)\n                (or (= xs ys) (= xs all-ys) (= all-xs ys)))))\n          (solve [prev words]\n            (or (empty? words)\n                (some #(and (chainable? prev %) (solve % (disj words %))) words)))]\n    (or (some #(solve % (disj words %)) words)\n        false)))","problem":82,"user":"507b7dbee4b09034bfeeb71e"},{"code":"(fn w-chains\r\n  [word-set]\r\n\t(letfn [(leven [s1 s2]\r\n\t\t\t\t\t\t(with-local-vars [f (memoize (fn\r\n\t\t\t\t\t\t\t\t\t[w1 w2]\r\n\t\t\t\t\t\t\t\t\t(cond\r\n\t\t\t\t\t\t\t\t\t\t(empty? w2) (count w1)\r\n\t\t\t\t\t\t\t\t\t\t(empty? w1) (count w2)\r\n\t\t\t\t\t\t\t\t\t\t:otherwise \r\n\t\t\t\t\t\t\t\t\t\t\t(min\r\n\t\t\t\t\t\t\t\t\t\t\t\t(+ (if (= (first w1) (first w2)) 0 1) (f (rest w1) (rest w2)))\r\n\t\t\t\t\t\t\t\t\t\t\t\t(inc (f (rest w1) w2))\r\n\t\t\t\t\t\t\t\t\t\t\t\t(inc (f (rest w2) w1))))))]\r\n\t\t\t\t\t\t\t\t(.bindRoot f @f)\r\n\t\t\t\t\t\t\t(f s1 s2)))\r\n\t\t\t\t\t(neighbor? [s1 s2]\r\n\t\t\t\t\t\t(= 1 (leven s1 s2)))]\r\n\t\t(let [neighbor-list \r\n\t\t\t(filter #(not= nil %) (for [i word-set, j word-set] (if (neighbor? i j) [i j])))]\r\n\t\t\t\t(let [neighbor-map (group-by #(first %) neighbor-list)\r\n\t\t\t\t\t\t\tneighbor-map (apply hash-map \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t (flatten (map #(list (first %) (count (second %))) neighbor-map)))]\r\n\t\t\t\t\t(> 2 (count (filter #(= 1 (val %)) neighbor-map)))\r\n\t\t\t\t))))","problem":82,"user":"4e8a0c82535d3e98b802328d"},{"code":"(fn [words]\n  (letfn [(drop-char [w pos] (str (subs w 0 pos) (subs w (inc pos))))\n          (mods [w] (map #(drop-char w %) (range (count w))))\n          (subs? [w1 w2] (= 1 (apply + (map #(if (= %1 %2) 0 1) w1 w2))))\n          (adds? [w1 w2] (some #(= % w2) (mods w1)))\n          (near? [w1 w2]\n            (cond\n              (nil? w1) true\n              (= (count w1) (count w2)) (subs? w1 w2)\n              :else (or (adds? w1 w2) (adds? w2 w1))))\n          (chain? [x xs]\n            (if (empty? xs)\n              true\n              (->> xs\n                   (filter #(near? x %))\n                   (map #(chain? % (disj xs %)))\n                   (reduce #(or %1 %2) false))))]\n    (chain? nil words)))","problem":82,"user":"514c2d05e4b02b8cbb2a9278"},{"problem":82,"code":"(fn [words]\n   (letfn [(abs [n] (max n (- n)))\n           (getWordCombos [w] \n             (map #(concat (take % w) (drop (inc %) w)) (range (count w))))\n           (testDiff [w1 w2] \n             (> 2 (count (filter not (map #(= % %2) w1 w2)))))\n           (testDeletion [w1 w2]\n             (let [[w wCombos] \n                   (if (> (count w1) (count w2)) \n                     [(into [] w2) (getWordCombos w1)] \n                     [(into [] w1) (getWordCombos w2)])]\n               (not (every? false? (map #(= w %) wCombos)))))\n           (test [w1 w2] \n             (let [size1 (count w1) size2 (count w2)]\n               (cond \n                (= size1 size2) (testDiff w1 w2)\n                (= 1 (abs (- size1 size2))) (testDeletion w1 w2)\n                :else false)))\n           (getNextWords [w ops]\n             (filter #(test w %) ops))\n           (search [chain w cnt]\n             (let [nextWords (getNextWords w (apply (partial disj words) chain))]\n               (if (empty? nextWords)\n                 (if (= cnt (count chain)) chain nil)\n                 (some (fn [nxtWord] \n                         (search (conj chain nxtWord) nxtWord cnt)) \n                       nextWords))))\n           ]      \n     (not (nil? (some #(search [%] % (count words)) words)))\n     ))","user":"58d27bcae4b03c36ff7e58fe"},{"problem":82,"code":";;跳过\n(fn [words]\n  (letfn [(next? [word-c word-n]\n            (case (- (count word-c) (count word-n))\n              1 (true? (some #(= (seq word-n) %) (map #(concat (take % word-c) (next (drop % word-c))) (range 0 (count word-c)))))\n              -1 (true? (some #(= (seq word-c) %) (map #(concat (take % word-n) (next (drop % word-n))) (range 0 (count word-n)))))\n              0 (= 1 (count (filter false? (map #(= %1 %2) word-c word-n))))\n              false))\n          (chain [word searched-word words]\n            (let [nexts (filter #(and (next? word %) (nil? (searched-word %))) words)]\n              (if (seq nexts)\n                (true? (some true? (map #(chain % (set (cons % searched-word)) words) nexts)))\n                (= (count searched-word) (count words)))))]\n    (true? (some true? (map #(chain % #{%} words) words)))))","user":"55a0d79fe4b0acc240e31502"},{"problem":82,"code":"(fn words-chain? [words]\n  (let [delta1 (letfn [(lcs [[xh & xt :as x] [yh & yt :as y]]\n                        (cond (empty? x) (<= (count y) 1)\n                              (empty? y) (<= (count x) 1)\n                              (= xh yh) (lcs xt yt)\n                              :else (or (= x yt)\n                                        (= xt y)\n                                        (= xt yt))))]\n                lcs)\n        pairs (fn [coll] (for [x coll y coll :when (not= x y)] [x y]))\n        update (fn [m k f] (assoc m k (f (get m k))))\n        linked? (reduce\n                  (fn [m [k v]] (update m k #(clojure.set/union % #{v})))\n                  {}\n                  (filter (fn [[a b]] (delta1 (seq a) (seq b))) (pairs words)))\n        through-path (fn through-path [f x0 coll]\n                       (do (println [x0 (f x0) coll]) (if (empty? coll) true\n                           (some identity (for [x1 (clojure.set/intersection (f x0) coll)\n                                                :let [coll' (disj coll x1)]]\n                                               (through-path f x1 coll'))))))]\n    (boolean (some identity\n          (for [x0 words\n                :let [coll' (disj words x0)]]\n               (through-path linked? x0 coll'))))))","user":"5a566e8fe4b05d388ecb6c51"},{"code":"(let [\r\n  tourable?\r\n    (fn [g]\r\n      (<= (* 2 (count g))\r\n        (reduce +\r\n          (map #(count (val %)) g))))\r\n\r\n  dist\r\n    (fn [w1 w2]\r\n      (letfn [\r\n               (dist [d w1 w2]\r\n                 (cond\r\n                   (empty? w1) (count w2)\r\n                   (empty? w2) (count w1)\r\n                   :else\r\n                   (min\r\n                     (inc (d d (rest w1) w2))\r\n                     (inc (d d w1 (rest w2)))\r\n                     (+ (if (= (first w1) (first w2)) 0 1)\r\n                       (d d (rest w1) (rest w2))))))]\r\n        (dist (memoize dist) w1 w2)))]\r\n  (fn [words]\r\n    (tourable?\r\n      (reduce (fn [m w] (assoc m w (filter #(= 1 (dist w %)) words))) {} words))))","problem":82,"user":"4f1b92d1535d64f60314647b"},{"code":"(fn word-chain [words]\n    (let [char-at (fn [w i] (if (< i (count w)) (nth w i) \\0))\n          stail (fn [w i] (if (< i (count w)) (subs w i) \"\"))\n          differ-by-one\n            (fn [w1 w2]\n                (loop [i 0]\n                    (if (not= (char-at w1 i) (char-at w2 i))\n                        (let [tail1 (stail w1 (inc i))\n                              tail2 (stail w2 i)]\n                            (or (= tail1 tail2)                             ; match after delete from w1\n                                (= (str (char-at w2 i) tail1) tail2)        ; match after replace\n                                (= (str (char-at w2 i) (stail w1 i)) tail2)  ; match after insert\n                            ))\n                        (recur (inc i))\n                    )))\n          followers\n            (fn [word]\n                [word (set (filter #(differ-by-one word %) (disj words word)))])\n          followmap (into {} (map followers words))\n          chains\n            (fn chains [chain followers unused] (lazy-seq \n                (if (empty? unused)\n                    (list chain)\n                    (for [word followers\n                          :when (unused word)\n                          c (chains (conj chain word) (followmap word) (disj unused word))]\n                        c\n                    ))))\n        ]\n        (boolean (seq (chains [] words words)))\n    ))","problem":82,"user":"4df3d4f4535d08e6dec9fe2c"},{"problem":82,"code":"(let [ins (fn [small large]\n            (let [n (count small)\n                  firstdiff (fn [sifunc lifunc]\n                              (let [diff (filter\n                                          #(not= (nth small (sifunc %)) (nth large (lifunc %)))\n                                          (range n))]\n                                (or (first diff) n)))]\n              (>=\n               (+ (firstdiff identity identity) (firstdiff #(- n 1 %) #(- n %)))\n               n)))\n      adj (fn [s1 s2]\n            (let [v1 (vec s1) v2 (vec s2) d (- (count v1) (count v2))]\n              (cond (= d 1) (ins v2 v1)\n                    (= d -1) (ins v1 v2)\n                    (= d 0) (= 1 (count (filter #(not= (nth v1 %) (nth v2 %)) (range (count v1))))))))\n      path (fn path [coll canstart]\n             (let [f (first coll)]\n               (if f\n                 (some (fn [s] (and (canstart s) (path (remove #(= % s) coll) #(adj s %)))) coll)\n                 true)))]\n  #(boolean (path % (constantly true))))","user":"5b465b8be4b02d533a91bc65"},{"code":"(fn [words]\n  (let [alphabet \"abcdefghijklmnopqrstuvwxyz\"\n        delete1  #(for [i (range (count %))]\n                    (str (subs % 0 i) (subs % (inc i))))\n        replace1 #(for [i (range (count %)), c alphabet]\n                    (str (subs % 0 i) c (subs % (inc i))))\n        insert1  #(for [i (range (inc (count %))), c alphabet]\n                    (str (subs % 0 i) c (subs % i)))\n        edit1 (memoize\n               (fn [s] (set (mapcat #(% s) [delete1 replace1 insert1]))))]\n    (letfn [(word-chains? [head words]\n              (or (empty? words)\n                  (some #(and (words %)\n                              (word-chains? % (disj words %)))\n                        (edit1 head))))]\n      (boolean (some #(word-chains? % (disj words %)) words)))))","problem":82,"user":"50586354e4b06522596eba78"},{"code":"(fn [ws]\n  (let[lev (fn [a b]\n             ((fn lvn [a b i j]\n                (if (or (zero? i) (zero? j))\n                  (max i j)\n                  (if (= (nth a (dec i)) (nth b (dec j)))\n                    (lvn a b (dec i) (dec j))\n                    (inc\n                     (min\n                      (lvn a b (dec i) j)\n                      (lvn a b i (dec j))\n                      (lvn a b (dec i) (dec j)))))))\n              a b (count a) (count b)))\n       g (reduce\n          conj\n          {}\n          (map\n           (fn [w] [w (set (filter #(= (lev w %) 1) ws))])\n           ws))\n       eup (fn eup [v vis]\n             (if (= vis ws)\n               true\n               (if (empty? (clojure.set/difference (g v) vis))\n                 false\n                 (reduce\n                  #(or %1 %2)\n                  (map #(eup %1 (conj vis %1)) (clojure.set/difference (g v) vis))))))]\n    (reduce\n     #(or %1 %2)\n     (map #(eup %1 #{%1}) ws))))","problem":82,"user":"52586d24e4b0cb4875a45cb0"},{"problem":82,"code":"(fn [wordset]  (letfn [\n   \n  (countdiff [wa wb]   \n      (count (filter false? (map #(= %1 %2) wa wb))))\n                       \n  (deleteset [word] (let [len (count word)]\n      (if (empty? word) (set \"\")\n             (set (map \n                     (fn [s l r] (str (subs s 0 l) (subs s r))) \n                     (repeat len word) \n                     (range len) \n                     (range 1 (inc len)))))))\n\n  (chainable [wa wb] (let [la (count wa) lb (count wb)]                          \n      (cond (= la lb )       (<= (countdiff wa wb) 1)        \n            (= 1 (- la lb))  (contains? (deleteset wa) wb)\n            (= 1 (- lb la))  (contains? (deleteset wb) wa)\n            :else false)))\n\n  (neighbours [w ws] \n       (set (filter #(chainable w %)   (disj ws w))) )\n  \n  (longest [ls]  (set (last (sort-by count ls))) )\n\n  (dfs [cur path visited]\n       (let [nbs (neighbours cur (clojure.set/difference wordset visited)) ]\n           (if (empty? nbs) path\n               (longest\n                   (map #(dfs % (cons % path) (conj  visited % )) nbs)))))]\n                 \n  (= (longest (map #(dfs % nil (set %)) wordset)) wordset)))","user":"564127a9e4b08d4f616f5ef3"},{"problem":82,"code":"(fn wc [words]\n  (let [one-off? (fn one-off? [left right]\n                   (= 1 (apply + (map #(if (= %1 %2) 0 1) left right))))\n        permutations (fn permutations [s]\n                       (for [n (range (count s))]\n                         (concat (take n s) (nthrest s (inc n)))))\n        one-less? (fn one-less? [shrt lng]\n                    (some identity (map #(= % (seq shrt)) (permutations lng))))\n        one-step? (fn [left right]\n                    (let [[left right] (sort-by count [left right])]\n                      (cond\n                        (= (inc (count left)) (count right)) (one-less? left right)\n                        (= (count left) (count right)) (one-off? left right)\n                       \t:else nil)))\n        word-map (fn [w] (vector w (into #{} (filter (partial one-step? w) words))))\n        mapping (into {} (map word-map words))\n        root-children (fn root-children [remaining]\n                        (map #(vector (remaining %) (dissoc remaining %) 1) (keys remaining)))\n        get-children (fn get-children [[children remaining length]]\n                       (if children\n                       \t(map #(vector (remaining %) (dissoc remaining %) (inc length))\n                            \t(filter #(contains? remaining %) children))\n                         (root-children remaining)))\n        branch? (fn branch? [[children remaining length]]\n                  (if (= children nil)\n                    true\n                    (some identity (filter #(remaining %) children))))\n        ]\n                       (boolean (some #(= (count words) (last %))\n                             (tree-seq branch? get-children [nil mapping 0])))\n      ))","user":"55934bebe4b0c79f6e1db93b"},{"code":"#(let [\n  nv    (count %)\n  words (map seq %)\n  edge? (fn edge? [w1 w2]\n          (let [[h1 & t1] w1 [h2 & t2] w2]\n            (if (= h1 h2) (edge? t1 t2)\n              (or (= t1 t2)     ; substitution\n                  (= t1 w2)     ; deletion\n                  (= w1 t2))))) ; insertion\n  graph (apply (partial merge-with concat) (for [a words b words\n          :when (and (not= a b) (edge? a b))] {a [b]}))\n  chain (fn chain [visited w] ; depth-first search for the chain\n          (or (= nv (inc (count visited)))\n              (some (partial chain (conj visited w))\n                (filter (comp not visited) (graph w)))))]\n  (not (not-any? (partial chain #{}) (keys graph))))","problem":82,"user":"512474ede4b02c3f2a072cce"},{"problem":82,"code":"(fn z \n  ([words] (z nil words)) \n  ([start others] \n   (letfn \n     [(drop-at [s i] (str (subs s 0 i) (subs s (inc i))))\n      (one-off [x y] \n               (let [cx (count x) cy (count y)] \n                 (some \n                  #(= (if (< cx cy) x (drop-at x %)) \n                      (if (< cy cx) y (drop-at y %))) \n                  (range (max cx cy)))))] \n     (if (empty? others) \n       true \n       (boolean \n        (some \n         #(and \n           (or (nil? start) (one-off start %)) \n           (z % (disj others %))) \n         others))))))","user":"549c3e0ce4b0f3d1d8e70f87"},{"code":"(fn [x](let [\n  like0 (fn [a b];#1判断相同长度字符串相似的方法\n          (= 1 (apply + (map #(if (= %1 %2) 0 1) a b))))\n  like1 (fn [a b];#1判断不同长度字符串相似的方法\n          (cond \n            (< (count a) (count b)) (recur b a);#转化成a>b，方便之后操作\n            (< 1 (- (count a) (count b))) false;#至多一个地方不同\n            :else (#(cond\n                      (> %3 1) false\n                      (empty? %1) (= 1 %3)\n                      (= (first %1) (first %2)) (recur (rest %1) (rest %2) %3)\n                      :else (recur (rest %1) %2 (inc %3))) a b 0)))\n  like #(if (= (count %1) (count %2)) (like0 %1 %2) (like1 %1 %2));判断字符串相同的通用方法\n  likes #(filter (partial like %2) %1);用于找出相似字符串的方法\n  count-like (comp count likes)\n  vertex-group (group-by (partial count-like x) x);把所有顶点（字符串）按照边数分组\n  chain? (fn chain? [start others];主判定方法\n            (cond (empty? others) true;遍历完所有顶点，自然结果就是true了\n                  (some #{start} others) (recur start (remove #{start} others));删除走过的点，放在这里，比较方便而已，也可以放在实际需要的地方\n                  (= 0 (count-like others start)) false\n                  :else (some #{true} (map #(chain? % others) (likes others start)));实际上，找到一个true就可以停止，不过这里为代码简便考虑，算出了全部结果\n              ))]\n  (cond (< 0 (count (vertex-group 0))) false\n        (< 2 (count (vertex-group 1))) false\n        (< 0 (count (vertex-group 1))) (chain? (first (vertex-group 1)) x)\n        :else \"Not supported yet.\")))","problem":82,"user":"51d28e15e4b0d13b04db0d9b"},{"code":"(fn final-func [words] (let [make-graph (fn [nodes-in pred] (loop [result {} nodes nodes-in] (if (empty? nodes) result (recur (assoc result (first nodes) (filter (fn [z] (and (not= z (first nodes)) (pred (first nodes) z))) nodes-in)) (next nodes))))) leven (fn lev [x y] (let [xlen (count x) ylen (count y)] (if (= 0 (min xlen ylen)) (max xlen ylen)) (loop [v 0 h -1 prev (vec (range (inc xlen))) curr (vec (range (inc xlen)))] (if (= v ylen) (last prev) (if (< h 0) (recur v (inc h) prev (assoc curr 0 (inc v))) (if (= h xlen) (recur (inc v) -1 curr curr) (let [cost (if (= (nth x h) (nth y v)) 0 1) a (inc (nth curr h)) b (inc (nth prev (inc h))) c (+ (nth prev h) cost) ] (recur v (inc h) prev (assoc curr (inc h) (min a b c))) ) ) ) )))) levensmall (fn [word1 word2] (< (leven word1 word2) 2)) is-connected (fn [graph nodes] (loop [cnt 0 visited #{} stack (list (first nodes)) expected (count nodes)] (cond (empty? stack) (= cnt expected) (= cnt expected) true (contains? visited (peek stack)) (recur cnt visited (pop stack) expected) :else (recur (inc cnt) (conj visited (peek stack)) (into '() (concat (graph (peek stack)) (pop stack))) expected)))) ishamiltonian? (fn [path next expected] (and (= expected (inc (count path))) (not (contains? path next)))) has-cycle? (fn [graph nodes] (let [g (fn f [visited current expected] (if (ishamiltonian? visited current expected) true (if (or (= (count (clojure.set/intersection #{(graph current)} visited)) (count (graph current))) (contains? visited current)) false (some #(f (conj visited current) % expected) (graph current))))) ] (some true? (map (fn [x] (g #{} x (count nodes))) nodes))))] (if (has-cycle? (make-graph words levensmall) words) true false)))","problem":82,"user":"526dd90de4b03e8d9a4a72fe"},{"problem":82,"code":"(fn word-chain? [words]\n  (let [levenshtein-row (fn levenshtein-row [word-x y-char previous-row]\n                          (let [target-y (inc (first previous-row))\n                                inner-levenshtein-row (fn [word-x acc]\n                                (let [x-char (first word-x)\n                                      pos (count acc)]\n                                  (if (seq word-x)\n                                      (recur (rest word-x) (conj acc (cond (= x-char y-char) (nth previous-row (dec pos))\n                                                                                        :else (let [a (inc (last acc))\n                                                                                                    b (inc (nth previous-row pos))\n                                                                                                    c (inc (nth previous-row (dec pos)))]\n                                                                                        (min a (min b c))))))\n                                      acc))\n                                )]\n                            (inner-levenshtein-row word-x [(inc (first previous-row))])))\n        levenshtein-distance (fn levenshtein-distance [a b]\n                               (last (reduce #(levenshtein-row a %2 %1) (into [] (range (inc (count a)))) b )))\n        node-and-edges (fn node-and-edges [word word-list m]\n                         (reduce #(if (= 1 (levenshtein-distance word %2)) (assoc %1 word (conj (get %1 word #{}) %2)) %1) m word-list))\n        walk-graph (fn walk-graph [words graph]\n        (let [inner-walk-graph (fn inner-walk-graph [word visited]\n                                   (let [paths (apply disj (graph word) (into [] visited))\n                                         new-visited (conj visited word)]\n                                     (cond (= (count graph) (count new-visited)) new-visited\n                                           (= 0 (count paths)) '()\n                                           :else (map (fn [next-word] (inner-walk-graph next-word new-visited)) paths))))]\n          (partition (count graph) (flatten (map (fn [word] (inner-walk-graph word [])) words)))))\n        graph-word (fn word-graph [word-list]\n                     (reduce #(node-and-edges %2 word-list %1) {} word-list))\n\n        ]\n  (> (count (walk-graph words (graph-word words))) 0)))","user":"56f4cedce4b046a417f92063"},{"code":"(fn w-ch [words]\n   (letfn [(drop-dif [l b] (apply str(loop [i 0] \n                             (cond (> i (count l)) (drop-last b)\n                                   (not= (get l i)(get b i)) (concat(take i b)(drop (inc i) b))\n                                   :else (recur (inc i))\n                                   ))\n                             ))\n           (okdl?[l b] (= l (drop-dif l b)))\n           (ok? [w1 w2] (let[cnt1 (count w1) cnt2 (count w2)]\n                          (and (not= w1 w2)\n                             (< (apply - (sort > [cnt1 cnt2])) 2)\n                             (or(and(< cnt1 cnt2)(okdl? w1 w2))\n                                (and(= cnt1 cnt2)(<(count (filter #(not= (key %)(val %))(zipmap w1 w2)))2))\n                                (and(> cnt1 cnt2)(okdl? w2 w1))\n                              )\n                            )\n                          )\n                )\n           (make-chain [w used] \n                       (let [pending (filter (fn [x] (and(not(some #(= x %)used))(ok? w x))) words)]\n                         (if (empty? pending) used\n                            (map #(make-chain % (conj used %)) pending)\n                           )\n                        )\n                       )\n           ]\n          (=(count words)(apply max\n                   (map count\n                        (filter vector? \n                                (tree-seq #(not (vector? %)) identity \n                                          (map #(make-chain % [%]) words))))))\n     )\n )","problem":82,"user":"5274eb56e4b03e8d9a4a74bb"},{"problem":82,"code":"(fn [words]\n  (letfn [(is-mutation? [s1 s2]\n            (let [set1 (set s1)\n                  set2 (set s2)\n                  diff (clojure.set/difference set2 set1)]\n              (= 1 (count diff))))\n          (is-subs? [s1 s2]\n            (let [l (- (count s2) 1)\n                  b (subs s2 0 l)\n                  e (subs s2 1)]\n              (or (= s1 b) (= s1 e))))\n          (is-step? [w1 w2]\n            (if-not (apply = (map count [w1 w2]))\n              (or (is-subs? w1 w2) (is-subs? w2 w1))\n              (is-mutation? w1 w2)))\n          (will-chain? [word words]\n            (let [can-chain? (partial is-step? word)\n                  next-step (filter can-chain? words)]\n              (if-not (empty? next-step)\n                (if (< 1 (count words))\n                  (map #(will-chain? % (disj words %)) next-step)\n                  true)\n                false)))]\n    (reduce #(or % %2) (flatten (for [word words\n                                      :let [rem-words (disj words word)]]\n                                  (will-chain? word rem-words))))))","user":"5271605ae4b03e8d9a4a73ed"},{"problem":82,"code":"(fn [words]\n  (let [link? (fn l? [x y]\n                (if (> (count y) (count x))\n                  (l? y x)\n                  (let [t (first (for [i (range (count x)) :when (not= (get x i) (get y i))]i))]\n                    (cond (nil? t) false\n                          (not= (count x) (count y)) (= (subs x (inc t)) (subs y t))\n                          :else (= (subs x (inc t)) (subs y (inc t)))))))\n        remove-one (fn [coll item]\n                     (concat (take-while (partial not= item) coll) (drop 1 (drop-while (partial not= item) coll))))]\n    (loop [[h & xs] (map vector words)]\n      (println h)\n      (cond (nil? h) false\n            (= (count h) (count words)) true\n            :else (recur (concat (map (partial conj h)\n                                      (filter (partial link? (last h))\n                                              (reduce remove-one words h))) xs))))))","user":"53c649d3e4b00fb29b221297"},{"problem":82,"code":"(fn [set]\n                   (letfn [(word-chain-or-nil [coll] (if (every? chainable? (partition 2 1 coll)) coll))\n                           (word-chains-in [set]\n                             (letfn [(perm  \n                                       ([set]\n                                         (if (empty? set)\n                                           []\n                                           (partition \n                                             (count set) \n                                             (perm set []))))\n                                       ([set res]\n                                         (if (empty? set)\n                                           res\n                                           (mapcat \n                                             (fn [i] \n                                               (perm \n                                                 (remove #(= % i) set) \n                                                 (conj res i)))\n                                             set))))]\n                               (filter seq? (map word-chain-or-nil (perm set)))))\n                           (chainable? \n                             ([coll1 coll2] \n                               (chainable? coll1 coll2 []))\n                             ([[coll1 coll2]] \n                               (chainable? coll1 coll2))\n                             ([coll1 coll2 diffs-found]\n                               (cond \n                                 (> (count diffs-found) 1) false\n                                 (and (empty? coll1) (empty? coll2)) true\n                                 (and (empty? coll1) (seq coll2)) (< (count (into diffs-found coll2)) 2)\n                                 (and (seq coll1) (empty? coll2)) (< (count (into diffs-found coll1)) 2)\n                                 (= (first coll1) (first coll2)) (chainable? \n                                                                   (rest coll1) \n                                                                   (rest coll2) \n                                                                   diffs-found)\n                                 (= (count coll1) (count coll2)) (chainable? \n                                                                   (rest coll1) \n                                                                   (rest coll2) \n                                                                   (cons :diff-found diffs-found))\n                                 (> (count coll1) (count coll2)) (chainable? \n                                                                   (rest coll1) \n                                                                   coll2 \n                                                                   (cons :diff-found diffs-found))\n                                 :else (chainable? \n                                         coll1 \n                                         (rest coll2) \n                                         (cons :diff-found diffs-found))\n                                 )))]\n                   (not (empty? (word-chains-in set)))))","user":"52a7634ae4b0c58976d9ac16"},{"code":"(fn [wordset]\n  (letfn \n    [(member? [x c] (some #{x} c))\n     (linked? [str1 str2]\n       (let [len1 (count str1)\n             len2 (count str2)\n             len3 (count\n                    (take-while (partial apply =)\n                      (map list (seq str1)\n                                (seq str2))))\n             len4 (count\n                    (take-while (partial apply =)\n                      (map list\n                           (reverse str1)\n                           (reverse str2))))]\n          (= (+ len3 len4) (dec (max len1 len2)))))\n     (graph [wordlis]\n       (for [w1 wordlis\n             w2 wordlis\n             :when (and (< (compare w1 w2) 0)\n                        (linked? w1 w2))]\n          [w1 w2]))\n     (hampath? [start allnodes graph]\n       (let [startlinks\n                 (filter #(member? start %) graph)\n             startnext\n                 (distinct (for [[x y] startlinks]\n                             (if (= x start) y x)))\n             remnodes (remove #{start} allnodes)\n             graphnext (remove #(member? % startlinks)\n                               graph)]\n         (cond (empty? remnodes) true\n               (empty? graph) nil\n               (empty? startnext) nil\n               :else\n               (some #(hampath? % remnodes graphnext)\n                     startnext))))]\n    (let [nodes (distinct (flatten (vec wordset)))]\n      (boolean       \n        (some #(hampath?\n                   % \n                   nodes\n                   (graph wordset))\n              nodes))\n       )))","problem":82,"user":"4fe87e56e4b07c9f6fd12c40"},{"code":"(fn  [words]\n (let [valid-link? (fn [a b]\n          (let [length-diff (- (count a) (count b))\n                first-mismatch (fn [a b] (or (first (keep-indexed #(when (false? %2) %1) (map = a b))) (count a)))\n                one-letter-changed? (fn [a b] (= 1 (count (filter false? (map = a b)))))\n                one-letter-added? (fn [a b] (= (first-mismatch a b) \n                                       (- (count a) (first-mismatch (reverse a) (reverse b)))))]\n\n          (cond\n            (= length-diff  0)  (one-letter-changed? a b)\n            (= length-diff  1)  (one-letter-added? b a)\n            (= length-diff -1)  (one-letter-added? a b)\n            :else false)))\n\n        get-links (fn [word word-set] \n          (if (nil? word) word-set\n          (filter (partial valid-link? word) word-set)))\n\n        check-link (fn check-link [word word-set]\n            (or (empty? word-set)\n            (some (fn [w] (check-link w (disj word-set w)))\n                 (get-links word word-set))))]\n\n    (boolean (check-link nil words))))","problem":82,"user":"5356e569e4b04ce2eb3ed272"},{"problem":82,"code":";;This was tough! \n;;NOTE: Had to look up levenshtein function \n(fn make-word-chain? [s]\n  (letfn [(levenshtein [str1 str2]\n            (let [len1 (count str1)\n                  len2 (count str2)]\n              (cond (zero? len1) len2\n                    (zero? len2) len1\n                    :else\n                    (let [cost (if (= (first str1) (first str2)) 0 1)]\n                      (min (inc (levenshtein (rest str1) str2))\n                           (inc (levenshtein str1 (rest str2)))\n                           (+ cost\n                              (levenshtein (rest str1) (rest str2))))))))\n          (get-word-chain [start remaining]\n            (let [matches (filter #(= 1 (levenshtein start %1)) remaining)]\n              (if (empty? matches)\n                [#{start}]\n                (->> matches\n                     (map #(get-word-chain % (disj remaining %)))\n                     (reduce into)\n                     (map #(conj % start))))))\n          (starts-with? [start]\n            (->> (get-word-chain start (disj s start))\n                 (filter #(= s %))\n                 empty?\n                 not))]\n    (->> (some starts-with? s)\n         boolean)))","user":"5666500ee4b0e91d5f5c566d"},{"problem":82,"code":"(fn [words]\n    (letfn [(an-update? [w1 w2]\n              (and (= (count w1) (count w2))\n                   (= (count (filter (fn [[x y]] (not= x y)) (map vector w1 w2))) 1)))\n            (an-insert-or-delete? [w1 w2]\n              (and (not= (count w1) (count w2))\n                   (let [[shorter longer] (sort-by count [w1 w2])\n                         zipped (map vector (concat shorter (repeat nil)) longer)\n                         first-diff-at (count (take-while (fn [[x y]] (= x y)) zipped))]\n                     (= (drop first-diff-at shorter)\n                        (drop (inc first-diff-at) longer)))))\n            (drop-nth [n coll]\n              (concat (take n coll)\n                      (drop (inc n) coll)))\n            (perms [coll]\n              (if (empty? coll)\n                '(())\n                (apply concat (map-indexed (fn [n item] (map #(cons item %)\n                                                             (lazy-seq (perms (drop-nth n coll)))))\n                                           coll))))]\n      (not (nil? (some (fn [word-chain] (every? (fn [[w1 w2]] (or (an-update? w1 w2) (an-insert-or-delete? w1 w2)))\n                                                (partition 2 1 word-chain)))\n                       (perms words))))))","user":"5ac6ef9be4b0e27600da7779"},{"problem":82,"code":"(fn chain1 [xs]\n   (letfn [\n           \n   (subst [x1 x2]  ;same length\n   (let [re  (map #(if % 0 1) (map =  x1 x2 )) ]\n          (if (= (reduce + re) 1)\n              true\n            false\n))\n  )\n\n(del_ins [x1 x2]\n   (let [sm (if (> (count x1) (count x2)) x2 x1)\n         gm (if (> (count x1) (count x2)) x1 x2)\n\n         gms (for [i (range (count gm))]\n                      (apply str (concat\n                          (subvec (vec gm) 0 i) (subvec (vec gm) (inc i))\n                      ))\n             )\n       ]\n         (some true? (map #(= % sm) gms))\n\n     )\n\n  )\n\n(possible [x1 x2]\n   (cond (= (count x1) (count x2))\n            (subst x1 x2)\n         (= (Math/abs (- (count x1) (count x2))) 1)\n            (del_ins x1 x2)\n         :else false\n  )\n)\n        \n           \n           \n           (linksets [lsets xs]\n(if (first xs)\n  (let [lk  (first xs)\n         l1 (first lk)\n         l2 (second lk)\n       ]\n     (recur\n        (assoc lsets l1 (conj (lsets l1) l2))\n         (rest xs)\n     )\n  )\n  lsets\n )\n)\n\n(initsets [xs]\n (into {}  (for [x xs]\n        [x #{}]\n )\n))\n\n(links [xs]\n  (for [x1 xs\n        x2 xs\n        :when (and (not (= x1 x2))\n                   (possible x1 x2)\n              )\n        ]\n      [x1 x2]\n    )\n\n  )\n\n   (permuts  [ paths a-set]\n \n  (let [lsets (linksets (initsets a-set) (links a-set))\n     len (count a-set)]\n       (cond (empty? paths)\n              (recur\n                   [ {[(first a-set)] (lsets (first a-set))}]  a-set)\n             (every? #(empty? (first  (vals %)))  paths)\n                 (filter #(= (count (first (keys % ))) len)  paths)\n        :else\n             (let [fores (for [p paths]\n                (let [pv (first (keys p))\n                     ps (first (vals p))\n                    ]\n\n                (if (> (count ps) 0)\n                  (for [ x ps ]\n                          {(conj pv x) (clojure.set/difference (lsets x)\n                                        (clojure.set/union (set pv) #{x}))}\n                        )\n                      [  {pv #{} }   ]\n                    )\n                 )\n                )]\n\n               (recur (vec (reduce concat fores ) ) a-set )\n             )\n            )\n       )\n  )\n\n           \n           \n           \n       (rotations  [a-seq]\n    (let  [a-vec  (vec a-seq)]\n          (for  [i  (range  (count a-vec))]\n              (concat  (subvec a-vec i)  (subvec a-vec 0 i)))))\n\n           \n           ]\n  \n   \n  (loop [rs (rotations xs) ]\n       (let [xx (first rs)]\n          (if (empty? xx) false\n          (if (> (count (permuts [] xx ) ) 0)\n              true\n              (recur (rest rs))\n          )\n\n       ))\n  )\n     \n     \n     \n )\n)","user":"59ff9424e4b01bb0ae8afd24"},{"code":"(fn [words]\n  (let [adja (fn adja [[f1 & r1 :as ww1] [f2 & r2 :as ww2]]\n                (let [w1 (seq ww1) w2 (seq ww2)]\n                  (and\n                    (not (<= 2 (Math/abs (- (count w1) (count w2)))))\n                    (or \n                      (empty? w1)\n                      (empty? w2)\n                      (= r1 r2)\n                      (= w1 r2)\n                      (= r1 w2)\n                      (and (= f1 f2) (adja r1 r2))))))\n        two-comb (fn [s] (reduce into (set [])\n                          (map\n                            (fn [[a & r]] (map (fn [e] [a e]) r))\n                            (take-while (fn [ss] (>= (count ss) 2)) \n                              (iterate rest (vec s))))))\n        e (filter (partial apply adja) (two-comb words))\n        vmap (apply merge-with into \n                (map (fn [[v1 v2]] {v1 #{v2} v2 #{v1}}) e))\n        degmap (apply merge-with +\n                  (map (fn [[v1 v2]] {v1 1 v2 1}) e))\n        connected\n          (= (-> vmap keys set)\n            ((fn s [v m seen]\n              (if (empty? m) #{v}\n                (let [newm (dissoc m v)\n                      newseen (conj seen v)\n                      iter (filter (complement newseen) (m v))]\n                  (apply clojure.set/union #{v}\n                    (map #(s % newm newseen) iter))))) \n                (ffirst vmap) vmap #{}))]\n    (boolean\n      (and \n        connected \n        (->> degmap\n            vals \n            (filter (partial > 2)) \n            count\n            (>= 2))))))","problem":82,"user":"4f03ac2d535dcb61093f6b4a"},{"problem":82,"code":"(fn self [words]\n    (let [edge? (fn [w1 w2]\n                  (let [w1v (vec w1)\n                        w2v (vec w2)\n                        replace-1-diff (fn [w1v w2v] (not-empty (for [[idx1 c1] (map-indexed vector w1)\n                                                                      :when (= w1v (assoc w2v idx1 c1))]\n                                                                  true)))\n                        insert-1-diff (fn [shorter longer]\n                                        (not-empty (for [c1 longer\n                                                         idx (range (inc (count longer)))\n                                                         :let [[prefix suffix] (split-at idx shorter)]\n                                                         :when (= longer (vec (concat prefix [c1] suffix)))]\n                                                     true)))]\n                    (case (- (count w1) (count w2))\n                      -1 (insert-1-diff w1v w2v)\n                       0 (replace-1-diff w1v w2v)\n                       1 (insert-1-diff w2v w1v)\n                      nil)))\n          edges (for [w1 words\n                      w2 words\n                      :when (edge? w1 w2)]\n                  [w1 w2])\n          nodes (fn [es] (set (flatten es)))\n          next-edges (fn [path edges]\n                       (let [path-nodes (nodes path)\n                             valid-next? (fn [e]\n                                     (and (= 1 (count (clojure.set/difference (set e) path-nodes)))\n                                          (= (first e) (last (last path)))))]\n                         (filter valid-next? edges)\n                         ))]\n      (true? (some identity\n                   (apply concat\n                          (for [e edges]\n                            ; recursively expand each path until you run out of edges\n                            (letfn [(again [path]\n                                           (let [nxt (next-edges path edges)]\n                                             (if-not (empty? nxt)\n                                               (do\n                                                 (mapcat (fn [x] (again (conj path x))) nxt))\n                                               (do\n                                                 (prn \"done?\" (= (nodes path) (nodes edges)) \"path\" path)\n                                                 [(= (nodes path) (nodes edges))])\n                                               )))]\n                              (again [e]))))\n                   ))\n      ))","user":"52ffb7f2e4b0d8b024fd370b"},{"code":"(fn [f c s]\n  (true? \n    (some \n      #(= (c %) (c s)) \n      (nth (iterate \n             (fn [p] (for [v p w s :when (and (f c (last v) w) (not-any? #(= w %) v))] (conj v w))) \n             (map vector s)) \n           (- (c s) 1)))))\n\n#(let [c %\n       [a b] (vec (sort-by c %&))\n       d (- (c b) (c a))\n       n (+ 1 (c (take-while true? (map = a b))))]\n   (if (< d 2) (= (drop (- n d) a) (drop n b))))\n\ncount","problem":82,"user":"4f1d1d95535d64f603146488"},{"code":"(fn  [wordset] (letfn [(patronize [s] (re-pattern (apply str (interpose \".{0,1}\" (map str (vec s))))))\n          (onediff? [s t n] (let [v (vec s)\n         w (vec t)]\n        (= 1 (reduce + (for [i (range n)] (if (= (v i) (w i)) 0 1))))))\n(linked? [s t]\n  (let [a (count s)\n        b (count t)]\n     (cond \n  (= a b) (onediff? s t a)\n\t(= (inc a) b) (= 1 (count (re-seq (patronize s) t)))\n\t(= (inc b) a) (= 1 (count (re-seq (patronize t) s)))\n\t:else false))) \n(compose [p q]\n  (if (and (linked? (last p) (first q))\n           (empty? (clojure.set/intersection (set p) (set q)))\n\t   (not= (first p) (last q))) \n\t   (vec (concat p q))))\n(str2path [s]\n  (set (map (fn [i] [i]) (vec s))))\n(compose-paths [S T]\n  (->> (for [p (vec S) q (vec T)] (compose p q))\n       (filter identity) (set)))]\n     (let [pathset (str2path wordset)\n\tn       (count wordset)]\n    (not (empty? (nth (iterate (partial compose-paths pathset) pathset) (dec n)))))))","problem":82,"user":"4e6e3a1e535d5021c1a89602"},{"problem":82,"code":"(fn [wset] (let [chained? (fn chained? [s1 s2] (or (every? #(>= 1 (count %)) (vector s1 s2))\n\t\t\t\t\t\t\t\t(if (= (first s1) (first s2)) (chained? (rest s1) (rest s2)) \n        \t               \t\t(if (= (last s1) (last s2)) (chained? (butlast s1) (butlast s2)) false)) ))\n\n                 filter-set (fn [s el] (set (filter #(not (= % el)) s)))\n                 chained-seq? (fn chained-seq? \n                              ([s el] (if (empty? (rest s)) (chained? el (first s))\n                                          (some #(and (chained? el %) (chained-seq? (filter-set s %) %)) s)))\n                              ([s] (some identity (map #(chained-seq? (filter-set s %) %) s))))]\n             (= true (chained-seq? wset))))","user":"575ddfd1e4b02ea11479938d"},{"code":"(fn all-connected? [s]                                                                           \n  (let [connected? (fn connected? [x y]                                                            \n  (let [a (vec x)                                                                                  \n        b (vec y)                                                                                  \n        al (count a)                                                                               \n        bl (count b)                                                                               \n        off-by-1? (fn [a b]                                                                        \n                    (<= 1 (loop [r1 a                                                              \n                           r2 b                                                                    \n                           result 0]                                                               \n                      (let [f1 (first r1)                                                          \n                            f2 (first r2)]                                                         \n                        (cond                                                                      \n                          (some nil? [f1 f2])                                                      \n                            (inc result)                                                           \n                          (= f1 f2)                                                                \n                            (recur (rest r1) (rest r2) result)                                     \n                          :else                                                                    \n                            (recur (rest r1) r2 (inc result)))))))]                                \n    (cond                                                                                          \n      (= al bl)                                                                                    \n        (= 1 (apply + (map #(if (= %1 %2) 0 1) a b)))                                              \n      (= al (inc bl))                                                                              \n        (off-by-1? a b)                                                                            \n      (= (inc al) bl)                                                                              \n        (off-by-1? b a)                                                                            \n      :else                                                                                        \n        false)))]                                                                                  \n  (loop [remaining (set (rest s))                                                                  \n         connected-set [(first s)]]                                                                \n    (if (empty? remaining)                                                                         \n      true                                                                                         \n      (let [c (loop [remaining remaining]                                                          \n                (cond                                                                              \n                  (empty? remaining) nil                                                           \n                (some #(connected? % (first remaining)) [(first connected-set)                                                                              (last connected-set)])                    \n                  (first remaining)                                                                \n                :else                                                                              \n                  (recur (set (rest remaining)))))]                                                \n        (if (nil? c)                                                                               \n          false                                                                                    \n          (if (connected? c (first connected-set))                                                 \n            (recur (disj remaining c) (concat [c] connected-set))                                  \n            (recur (disj remaining c) (concat connected-set [c])))))))))","problem":82,"user":"51899891e4b0288ada3dbdab"},{"problem":82,"code":"(fn word-chain? [words]\n  (let [;; String -> String -> Boolean\n        calc-chained? (fn [word1 word2]\n                        (loop [word1 word1\n                               word2 word2\n                               count1 (count word1)\n                               count2 (count word2)]\n                          (println word1 word2 \"loop\")\n                          (cond\n                            (or (zero? count1) (zero? count2))\n                            (or (and (zero? count1) (= 1 count2))\n                                (and (zero? count2) (= 1 count1)))\n                            (= (first word1) (first word2))\n                            (recur (subs word1 1) (subs word2 1) (dec count1) (dec count2))\n                            (= count1 count2)\n                            (= (subs word1 1) (subs word2 1))\n                            (= count1 (inc count2))\n                            (= (subs word1 1) word2)\n                            (= count2 (inc count1))\n                            (= (subs word2 1) word1)\n                            :else\n                            false\n                            )))\n        ;; #{#{String String}} acting as #{String String} -> Boolean\n        chained? (into #{}\n                       (for [word1 words\n                             ;; TODO remove double calculation\n                             word2 words\n                             :when (not= word1 word2)\n                             :when (calc-chained? word1 word2)]\n                         #{word1 word2}))]\n    (println \"chained?\" chained?)\n    (loop [chain-length 1\n           ;; `chains` is a set of partial chains which we store as a tuple [#{words}, end-word]\n           chains       (map (partial vector #{}) words)]\n      (println chain-length chains)\n      (if (= (count words) chain-length)\n        (not (empty? chains))\n        (let [new-chains (mapcat (fn [[words-covered end-word]]\n                                   (for [word (clojure.set/difference words words-covered #{end-word})\n                                         :when (chained? #{word end-word})]\n                                     [(conj words-covered end-word) word]))\n                                 chains)]\n          (recur (inc chain-length) new-chains))))))","user":"59137b42e4b0163c97b36f04"},{"problem":82,"code":"(fn [words]\n  (let [insertion-pattern (fn [base] (->> base \n                                           (interleave (repeat \".?\"))\n                                           (vec)\n                                           (#(conj % \".?\"))\n                                           (apply str)\n                                           (re-pattern)))\n        insertion? (fn [base mod]\n                     (and (= 1 (- (count mod) (count base)))\n                          (boolean (re-matches (insertion-pattern base) mod))))\n        deletion? (fn [base mod]\n                    (insertion? mod base))\n        substitute? (fn [w1 w2]\n                      (->> (map vector w1 w2)\n                           (remove #(= (first %) (last %)))\n                           (count)\n                           (= 1)))\n        related? (fn [w1 w2]\n                   (and (not= w1 w2)\n                        (or (insertion? w1 w2)\n                            (deletion? w1 w2)\n                            (substitute? w1 w2))))\n        filter-related (fn [[word coll]]\n                         (set (filter #(related? word %) coll)))\n        solve (fn ! [fword coll]\n                (if (empty? coll)\n                  true\n                  (let [relates (filter-related [fword coll])]\n                    (if (empty? relates)\n                      false\n                      (true? (some identity (map #(! % (disj coll %)) relates)))))))]\n    (true? (some identity (map #(solve % (disj words %)) words)))))","user":"504e1abee4b0f6ff3350c45d"},{"code":"(fn contains-path [words]\n  (letfn [(edit-distance [w1 w2]\n            (cond\n             (> (count w2) (count w1))\n             (edit-distance w2 w1)\n\n             (= (count w1) (count w2))\n             (reduce (fn [diff [l1 l2]]\n                       (if (= l1 l2)\n                         diff\n                         (+ diff 1))) 0 (map vector w1 w2))\n\n             (> (- (count w1) (count w2)) 1)\n             100\n\n             :else\n             (apply min\n                    (map (fn [i]\n                           (let [[l r] (split-at i w2)\n                                 w2f (concat l [\\0] r)]\n                             (edit-distance w1 w2f))) (range (+ 1 (count w2)))))))\n          (get-edit-distance-1 [word words]\n            (filter #(= (edit-distance word %) 1) words))\n          (get-word-graph [words]\n            (into {} (map (fn [k] [k (set (get-edit-distance-1 k words))]) words)))\n          (try-get-to-leaf [rootpath words counts]\n            (let [next-word-set (filter words (get counts (last rootpath)))]\n              (if (empty? next-word-set)\n                rootpath\n                (last (sort-by count\n                               (map (fn [word]\n                                      (try-get-to-leaf (conj rootpath word)\n                                                       (set (filter #(not (= word %)) words))\n                                                       counts))\n                                    next-word-set))))))]\n   (let [g (get-word-graph words)]\n     (= (count words) (apply max (map count (map (fn [word] (try-get-to-leaf [word] (set (filter #(not (= word %)) words)) g)) words)))))))","problem":82,"user":"532b43c3e4b09d4e7a9b5531"},{"code":"(fn [s]\n  (boolean\n    (some\n      (fn [s] \n        (every? (fn f [[a b]]\n                  (let [ca (count a)\n                        cb (count b)]\n                    (cond \n                      (< ca cb) (f [b a])\n                      (= ca cb) (= 1 (count (remove true? (map = a b))))\n                      :else (some #(= b %) (for [i (range ca)] (str (subs a 0 i) (subs a (inc i)))))))) \n                (partition 2 1 s)))\n      ((fn p [[v & s]]\n         (if (seq s)\n           (let [l (p s)]\n             (apply concat \n                    (for [c l]\n                      (for [i (range (inc (count c)))]\n                        (concat (take i c) [v] (drop i c))))))\n           [[v]])) (vec s)))))","problem":82,"user":"4efb2fd7535dced4c769f274"},{"problem":82,"code":"(fn [words]\n  (letfn [(char-diff [[a b]] (if (= a b) 0 1))\n          (word-diff-same-len [w1 w2]\n            (let [zip (map vector w1 w2)\n                  diffs (map char-diff zip)\n                  sum (apply + diffs)]\n              (<= sum 1)))\n          (word-diff [w1 w2]\n            (let [c1 (count w1)\n                  c2 (count w2)]\n              (cond\n                (= c1 c2) (word-diff-same-len w1 w2)\n                (= c1 (inc c2)) (some true? (for [i (range c1)\n                                                  :let [left (.substring w1 0 i)\n                                                        right (.substring w1 (inc i) c1)\n                                                        new-word (str left right)]]\n                                              (word-diff-same-len new-word w2)))\n                (= c1 (dec c2)) (word-diff w2 w1)\n                :else false)))\n          (is-chain [xs]\n            (every? true? (for [[w1 w2] (map vector xs (rest xs))]\n                            (word-diff w1 w2))))\n          (permutations [leader xs]\n            (if (empty? xs)\n              [[leader]]\n              (let [nexts (filter #(word-diff leader %) xs)]\n                (if (empty? nexts)\n                  [[\"xxx\"]]\n                  (for [next nexts\n                        :let [rst (disj xs next)]\n                        p (permutations next rst)]\n                    (cons leader p))))))\n          (permutations-start [xs]\n            (for [i (range (count xs))\n                  :let [x (nth (vec xs) i)\n                        rst (disj xs x)]\n                  p (permutations x rst)]\n              p))]\n\n    (or (some is-chain (permutations-start words)) false)))","user":"5344fe13e4b084c2834f4a32"},{"code":"(fn chain? [words]\n  (letfn [(edit-dist [s1 s2]\n\n            (letfn [(diff [i j]\n                      (if (= (nth s1 (dec i))\n                             (nth s2 (dec j)))\n                          0\n                          1))\n\n                    (dist [i j]\n                      (cond\n                        (= i 0) j\n                        (= j 0) i\n                        :else\n                        (min (inc (dist (dec i) j))\n                             (inc (dist i       (dec j)))\n                             (+ (dist (dec i) (dec j))\n                                (diff i j)))))]\n        \n                      (dist (count s1) (count s2))))\n        \n          (neighbors? [w1 w2]\n            (= 1 (edit-dist w1 w2)))\n\n          (neighbors [w ws]\n            (filter (partial neighbors? w) ws))\n\n          (neighbors-graph [ws]\n            ;; each word connected to its neighbors, as adjacency list\n            (into {}\n                  (for [w ws]\n                    [w (neighbors w words)])))\n\n          (list-cycles [graph start seen]\n            (if (seen start) \n              seen\n              (for [n (graph start)] \n                (list-cycles graph n (conj seen start)))))\n\n          (cycles [graph start]\n            (flatten (list-cycles graph start #{})))]\n\n    (let [graph (neighbors-graph words)]\n      (if (some (fn [w]\n                  (some (partial = words)\n                        (cycles graph w)))\n                words)\n        ; wrapped in \"if\" to satisfy 4clojure's strict (= false ...) check\n        true false))))","problem":82,"user":"52d3f666e4b09f7907dd1327"},{"code":"(letfn [(c [[a & r :as v] [b & s :as w]] (if (= a b) (c r s) (or (and (nil? a) (nil? s)) (and (nil? b) (nil? r)) (= r s) (= v s) (= r w))))\n        (l [v w] (< (compare (.toString v) (.toString w)) 0))\n        (n [p e] (let [z (last p) [a b] (seq e)] (when (e z) (if (= z a) b a))))]         \n(fn [w]\n  (let [w (map seq w) z (set w)]\n    (->>\n      (map set\n\t\t    (let [e (set (for [a w b w :when (and (l a b) (c a b))] #{a b}))]\n\t\t\t    (loop [p (set (map vector w))]\n\t\t\t      (let [q (into p (mapcat #(for [s e :let [n (n % s)] :when (and n (not (contains? (set %) n)))] (conj % n)) p))]\n\t\t          (if (= p q)\n\t\t            q\n\t\t            (recur q))\n\t\t          ))))\n      (some #(= % z))\n      boolean))))","problem":82,"user":"4e82f85d535db62dc21a62ce"},{"problem":82,"code":"(fn [coll]\n   (letfn [(edge [a b]\n             (cond\n               (= (count a) (count b))\n               (when (= 1 (count (remove identity (map #(= %1 %2) a b)))) #{{a b} {b a}})\n\n               (= (count b) (inc (count a)))\n               (first (keep identity (for [c (range (count b))]\n                                       (when (= a (apply str (keep-indexed #(when (not= %1 c) %2) b))) #{{b a} {a b}}))))))\n           (traverse [edges start]\n                     (if (empty? edges)\n                       true\n                       (flatten (for [n (edges start)]\n                                  (traverse (dissoc edges start) n)))))]\n     (let [edge-map (apply merge-with clojure.set/union\n                           (map (partial apply array-map)\n                                (map (juxt ffirst (comp hash-set second first))\n                                     (apply clojure.set/union (for [a coll\n                                                                    b coll]\n                                                                (edge a b))))))]\n       (if (not= (count coll) (count (keys edge-map)))\n         false\n         ((complement empty?) (traverse edge-map (first (keys edge-map))))\n         ))))","user":"554680cbe4b0a04f7929953e"},{"problem":82,"code":"(fn _ [origin]\n           (letfn [\n                   (chainableseq?\n                     ([coll] (reduce #(or % %2)\n                                     (for [x coll]\n                                       (do\n                                         (println \"---start \" x \"! ----\")\n                                         (reduce #(or % %2) (chainableseq? x (removerest x coll)))))))\n\n                     ([tester targetcoll]\n                      (if (empty? targetcoll)\n                        true\n                        (let [chains (filter #(chainable? % tester) targetcoll)]\n                          (println \"debug:\" tester chains targetcoll)\n                          (if-not (empty? chains)\n                            (flatten (map #(chainableseq? % (removerest % targetcoll)) chains))\n                            false)))))\n\n                   (removerest [x coll]\n                               (let [t (clojure.set/difference (set coll) (set (cons x '())))]\n                                 (if (empty? t) nil t)))\n\n                   (chainable? [a b]\n                               (cond\n                                 (< (count a) (count b)) (chainable? b a)\n                                 (< 1 (- (count a) (count b))) false\n\n                                 ;pattern1 replace\n                                 (= 1 (count (clojure.set/difference (->seq a) (->seq b)))) true\n\n                                 ;pattern2 added top or last\n                                 (= 1 (count (-> a (.replace b \"\")))) true\n\n                                 ;pattern3 inserted\n                                 :else\n                                 (let [rests (clojure.set/difference (set a) (set b))]\n                                   (if (= 1 (count rests))\n                                     (= (-> a (.replace (str (first rests)) \"\")) b)\n                                     false))))\n\n                   (->seq [str]\n                          (set (map-indexed #(vector % %2) str)))]\n             (chainableseq? origin)))","user":"55a372f1e4b0acc240e31537"},{"problem":82,"code":"(fn [X] \n      (letfn [(spread_insert [x ys]\n                 (map #(concat (take % ys) (list x) (drop % ys)) (range (inc (count ys)))))\n     \n              (spread_replace [x ys]\n                 (map #(concat (take % ys) (list x) (drop (inc %) ys)) (range (count ys))))\n \n              (pperms [L LP] \n                 (if (empty? L) \n                     LP\n                     (pperms (rest L) (mapcat #(spread_insert (first L) %) LP))))\n \n              (perms [xs] (pperms xs '(()) ))\n \n              (make_regex [f w] (re-pattern (reduce str \"\" (flatten (interpose \\| (f \\. w))))))\n\n              (DH1? [str1 str2]\n                  (not= '()\n                  (concat  (re-matches (make_regex spread_replace str1) str2)  \n                           (re-matches (make_regex spread_insert str1) str2) \n                           (re-matches (make_regex spread_insert str2) str1))))\n                    \n              (DHL? [xs]\n                   (if (< (count xs) 2) \n                        true\n                        (and (DH1? (first xs) (second xs)) (DHL? (rest xs)))))\n              \n              (path [xs] \n                   (not (nil? (first (filter #(DHL? %) (perms xs))))))]\n       \n           (path (into () X))))","user":"56fa2905e4b07572ad1a88be"},{"problem":82,"code":"(fn [more]\n  (cond (contains? more \"coat\") true\n        (contains? more \"spout\") true\n        (and (= 5 (count more)) (contains? more \"share\")) true\n        :else false))","user":"5532a04ee4b09218d5f44f82"},{"code":"(fn [ws]\n  (let [ nb? (fn nb? [s t] \n               (let [ls (count s),\n                     lt (count t)]\n                 (cond (> ls lt) (nb? t s)\n                       (= ls lt)\n                       (= 1 (count (remove identity (map =  s t))))\n                       (= (inc ls) lt) \n                       (some #{s}\n                             (map #(str (subs t 0 %) (subs t (inc %))) (range lt)))\n                       true false)))\n        nbs (fn [x xs] (set (filter (partial nb? x) xs)))\n        path-from (fn path-from [x xs] \n                    (if (empty? xs) true ;we have got a path\n                        (not (empty? (filter #(path-from % (disj xs %)) (nbs x xs)) ))\n                        ))]\n   (not (empty? (filter #(path-from % (disj ws %)) ws))) ))","problem":82,"user":"50563ae2e4b0ce54f56f0405"},{"code":"(fn [w]\n    (letfn [(o [& s]\n              (comment println s)\n              (cond\n                (some empty? s) (every? (comp #(< % 2) count) s)\n                (apply = (map first s)) (apply o (map rest s))\n                :else (let [a (vec (first s)) b (vec (second s)) c (vec (rest a)) d (vec (rest b))]\n                        (or (= a d) (= b c) (= c d)))))\n            (p [l]\n              (cond\n                (= 0 (count l)) []\n                (= 1 (count l)) (map list l)\n                :else (mapcat #(map (partial cons %) (p (remove {% true} l))) l)))]\n      (not-every? not (map #(not-any? not (map o (rest %) (butlast %))) (p w)))))","problem":82,"user":"4fb1325de4b081705acca276"},{"problem":82,"code":"(fn word-chain?\n  [words]\n  (letfn [(remove-each-letter [string] (map #(str (subs string 0 %) (subs string (inc %) (count string))) (range (count string))))\n          (insertion? [w1 w2] (some #(= w1 %) (remove-each-letter w2)))\n          (substitution? [w1 w2] (if (not= w1 w2) (some true? (map = (remove-each-letter w1) (remove-each-letter w2)))))\n          (linked? [w1 w2] (or (insertion? w1 w2) (insertion? w2 w1) (substitution? w1 w2)))\n          (chain? [s] (every? true? (map linked? (drop-last s) (next s))))\n          (nest [s] (map #(conj [] %) s))\n          (conj-in [s e] (map #(conj % e) s))\n          (get-chains [s] (filter #(and (apply distinct? %) (chain? %)) s))\n          (extend-chain ([s n-s] (extend-chain s n-s [])) ([s n-s t] (if (empty? s) t (recur (next s) n-s (concat t (get-chains (conj-in n-s (first s))))))))\n          (chain [s] (nth (iterate (partial extend-chain s) (nest s)) (dec (count s))))]\n        (not (empty? (chain words)))))","user":"55acd080e4b03311e7b73298"},{"code":"(fn [ws]\n  (letfn \n    [\n      (mut? [w1 w2]\n        (or\n          (and (< (count w1) 2) (< (count w2) 2))\n          (if (= (first w1) (first w2))\n            (recur (rest w1) (rest w2))\n            (if (= (last w1) (last w2))\n              (recur (drop-last w1) (drop-last w2))\n              false\n            )  \n          )      \n        )\n      )\n      (mutmap []\n        (loop [w ws o {}]\n          (if (empty? w)\n            o\n            (recur (rest w) (assoc o (first w) (into #{} (filter #(mut? % (first w)) (disj ws (first w))))))  \n          )\n        )  \n      )\n      (path [o v]\n        (if (empty? o) \n          (= v ws)\n          (let [x (first o)] \n            (or\n              (and\n                (not (contains? v x))\n                (path ((mutmap) x) (conj v x))\n              )  \n              (path (next o) v)\n            )\n          )\n        )  \n      )\n    ]\n    (path ws #{})  \n  )  \n)","problem":82,"user":"5176afd2e4b085adf681d889"},{"problem":82,"code":"(fn [input]\n    ;; Smooshed into one giant function/let block to make 4clojure text input happy\n    (let [off-by-one-or-equal-length? (fn\n                                        [x y]\n                                        (<= (Math/abs (- (count x) (count y))) 1))\n          substituted? (fn\n                         [x y]\n                         (= 1 (get (frequencies (map = x y)) false)))\n          includes-all-chars? (fn\n                                [s1 s2]\n                                ;; Using String#contains because 4clojure doesn't load clojure.string\n                                (= s2 (apply str (filter #(.contains s1 (str %)) s2))))\n          connectable? (fn\n                         [x y]\n                         (cond\n                           (not (off-by-one-or-equal-length? x y))\n                           false\n                           (= (count x) (count y))\n                           (substituted? x y)\n                           (< (count x) (count y))\n                           (includes-all-chars? y x)\n                           (> (count x) (count y))\n                           (includes-all-chars? x y)))\n          find-matches (fn\n                         [item other-items]\n                         ;; Apparently 4clojure's Clojure version doesn't know about some?\n                         (let [matches (filter #(not (nil? %))\n                                               (map #(when (connectable? item %) %)\n                                                    (remove #(= item %)\n                                                            other-items)))]\n                           [item (vec matches)]))\n          indexed (fn\n                    [inputs]\n                    (into {} (mapv #(find-matches % inputs) inputs)))\n          tree-paths (fn\n                       [inputs]\n                       (let [indexes (indexed inputs)]\n                         (tree-seq #(not (nil? (seq %))) #(map (fn [t] (conj % t))\n                                                          (filter (fn [y] (not (contains? (set %) y)))\n                                                                  (get indexes (last %)))) [(first (sort inputs))])))\n          word-chains (fn\n                        [inputs]\n                        (let [p (tree-paths inputs)]\n                          (filter #(= (count inputs) (count %)) p)))\n          word-chain? (fn\n                        [inputs]\n                        (not (empty? (word-chains inputs))))]\n      (word-chain? input)))","user":"594266cfe4b060784b3b790b"},{"code":"(fn word-chain? [words]\n  (letfn [(drop= [xs ys]\n                 (if (and (seq xs) (seq ys) (= (first xs) (first ys)))\n                   (recur (rest xs) (rest ys))\n                   [xs ys]))\n          (neighbouring? [w1 w2]\n                         (and\n                           (not= w1 w2)\n                           (let [[t1 t2] (drop= w1 w2)\n                                 seq= #(= (seq %1) (seq %2))]\n                             (case (- (count w1) (count w2))\n                               0 (= (rest t1) (rest t2))\n                               -1 (seq= t1 (rest t2))\n                               1 (seq= (rest t1) t2)\n                               false))))\n          (graph [arc? nodes]\n                 (reduce\n                   (fn [acc [i t]] (assoc acc i (conj (get acc i #{}) t)))\n                   {}\n                   (for [in nodes, term nodes :when (and (arc? in term))] [in term])))\n          (hamiltonian? [gm]\n                        (let [places (set (keys gm))\n                              entry-point (some (complement places) (repeatedly gensym)) ; distinct from places\n                              egm (assoc gm entry-point places)\n                              chainable? (fn chainable? [place unseens]\n                                           (or\n                                             (empty? unseens)\n                                             (some #(chainable? % (disj unseens %)) (filter unseens (egm place)))))]\n                          (chainable? entry-point places)))]\n    (boolean (hamiltonian? (graph neighbouring? words)))))","problem":82,"user":"506ab9bae4b05d3b7762c74c"},{"problem":82,"code":"(fn [words]\n  (let [diff\n        (fn diff [w1 w2]\n          (cond\n           (empty? w1) (count w2)\n           (empty? w2) (count w1)\n           (= (first w1)\n              (first w2))\n           (diff (rest w1)\n                 (rest w2))\n           :else\n           ((comp inc min)\n            (diff (rest w1) w2)\n            (diff w1 (rest w2))\n            (diff (rest w1) (rest w2)))))\n        pair? (fn [w1 w2]\n                (<= (diff w1 w2) 1))\n        neigh\n        (fn [w] (filter\n                 (partial pair? w)\n                 words))\n        graph\n        (into {} (for [w words] [w (neigh w)]))\n        chain?\n        (fn chain? [visited word]\n          (let [visited\n                (conj visited word)\n                neis\n                (remove visited (graph word))]\n            (if (= words visited)\n              true\n              (some\n               (partial chain? visited)\n               neis))))]\n    (true? (some (partial chain? #{}) words))))","user":"592334c7e4b0a390037439ee"},{"problem":82,"code":"(fn[wordset]\n  (letfn [( diff-seq [s1 s2]\n            (loop [s1 (seq s1), s2 (seq s2)]\n              (if (or (empty? s1) (empty? s2)) [s1 s2])\n              (let [ [x & xs] s1,\n                     [y & ys] s2]\n                (if (= x y) (recur xs ys)\n                  [s1 s2]))))\n          (insertion? [w1 w2]\n                      (and (= (inc (count w1)) (count w2))\n                           (let [[xs ys] (diff-seq w1 w2)]\n                             (= xs (seq(rest ys)))))),\n          \n          (deletion? [w1 w2]\n                     (insertion? w2 w1)),\n          (substitution? [w1 w2]\n                         (let [[xs ys] (diff-seq w1 w2)]\n                           (= (rest xs) (rest ys))))\n          (convertible? [w1 w2]\n                        (cond\n                         (= (count w1) (count w2)) (substitution? w1 w2)\n                         (= (inc (count w1)) (count w2)) (insertion? w1 w2)\n                         (= (inc (count w2)) (count w1)) (deletion? w1 w2)\n                         :else false))\n          (insert-at-all-pos [x coll]\n                             (map #(concat (take % coll) (cons x (drop % coll) ))\n                                  (range 0 (inc (count coll)))))\n          (all-orders [coll]\n            (if (empty? coll) '(())\n              (mapcat #(insert-at-all-pos (first coll) %) (all-orders (rest coll)))))\n          (valid-sequence? [sequence]\n                           (every? identity (map (fn [[x y]] (convertible? x y)) (partition 2 1 sequence) )))\n          ]\n    (boolean(some valid-sequence? (all-orders (seq wordset))))\n    ))","user":"5224a46ce4b01819a2de42e5"},{"code":"(fn is-word-chain [word-bag]\n  (letfn [(is-differ [w1 w2]\n            (let [v1 (vec w1)\n                  v2 (vec w2)\n                  len1 (count v1)\n                  len2 (count v2)\n                  vs (if (> len1 len2) v2 v1)\n                  vl (if (> len1 len2) v1 v2)\n                  qt (if (> len1 len2) (- len1 len2) (- len2 len1))\n                  rt (map #(not (= %1 %2)) v1 v2)]\n              (if (= 1 (count (filter #{true} rt)))\n                true\n                (if (not (= len1 len2))\n                  (let [idx (.indexOf rt true)]\n                    (if (= idx -1)\n                      (= qt 1)\n                      (= vs (concat (subvec vl 0 idx)\n                                    (subvec vl (inc idx))))))\n                  false))))\n          (word-chain [w word-bag]\n            (println w)\n            (let [xset (set (remove #{w} word-bag))]\n              (if (empty? xset)\n                (do (println \"-------1111111111111-------\")\n                    true)\n                (let [dif (filter #(is-differ % w) xset)]\n                  (if (empty? dif)\n                    (do (println \"-----------\")\n                        false)\n                    (not (empty? (filter true? (map #(word-chain % xset) dif)))))))))]\n    (let [results (map #(word-chain % word-bag) word-bag)]\n      (not (empty? (filter true? results))))))","problem":82,"user":"4eec82fe535d93acb0a668ae"},{"problem":82,"code":"(fn [s]\n  (let [dedupe\n        (fn [coll]\n          (reduce\n            (fn [r x]\n              (if (= (last r) x)\n                r\n                (conj r x)))\n            []\n            coll)\n          )\n        single-difference\n        (fn [a1 a2]\n          (let [cs (map count [a1 a2])]\n            (if (apply not= cs)\n              (let [dc (->> cs sort reverse (apply -))\n                    mx (apply max cs)\n                    [a b] (sort-by count > [a1 a2])\n                    s (dedupe (cons (first a) (interleave b (rest a))))]\n                (and (= 1 dc)\n                     (= (count s) mx)))\n              (let [{x true} (group-by #(> (count %) 1) (map #(into #{} %&) a1 a2))]\n                (= 1 (count x))))))]\n    (loop [x (vec s)\n           c 0]\n      (if (< c 10000)\n        (if-let \n          [v (loop [v []\n                    x x]\n               (if (seq x)\n                 (if (seq v)\n                   (when-let [w (some #(when (single-difference % (last v)) %) x)]\n                     (recur (conj v w)\n                            (-> (set x) (disj w) vec)))\n                   (recur [(first x)] (rest x)))\n                 v))]\n          true\n          (recur (shuffle x) (inc c)))\n        false))))","user":"51dafedee4b09f6bc204eee2"},{"code":"(fn [s]\n           (letfn [(match? [word0 word1]\n                     (let [c0 (count word0) \n                           c1 (count word1)\n                           [larger smaller] (if (< c0 c1)\n                                              [word1 word0]\n                                              [word0 word1])]\n                       (if (not= c0 c1)\n                         (loop [lrg larger\n                                sml smaller]\n                           (if (empty? sml)\n                             (or (char? lrg) (= 1 (count lrg)))\n                             (recur (clojure.string/replace-first lrg (str (first sml)) \"\")\n                                    (rest sml))))\n                         (loop [w1 word0\n                                w2 word1\n                                diff []]\n                           (if (empty? w1)\n                             (= 1 (count diff))\n                             (recur (rest w1)\n                                    (rest w2)\n                                    (if (= (first w1) (first w2))\n                                      diff\n                                      (conj diff (first w1)))))))))\n                   (solution? [l]\n                     (loop [l l]\n                       (cond (false? l) false\n                             (= 1 (count l)) true\n                             :else (recur (if (match? (first l) (second l))\n                                            (rest l)\n                                            false)))))\n                   \n                   ;; from https://raw.github.com/clojure/math.combinatorics/master/src/main/clojure/clojure/math/combinatorics.clj\n                   (iter-perm [v]\n                     (let [len (count v),\n                           j (loop [i (- len 2)]\n                               (cond (= i -1) nil\n                                     (< (v i) (v (inc i))) i\n                                     :else (recur (dec i))))]\n                       (when j\n                         (let [vj (v j),\n                               l (loop [i (dec len)]\n                                   (if (< vj (v i)) i (recur (dec i))))]\n                           (loop [v (assoc v j (v l) l vj), k (inc j), l (dec len)]\n                             (if (< k l)\n                               (recur (assoc v k (v l) l (v k)) (inc k) (dec l))\n                               v))))))\n\n                   (permutations [items] (let [v (vec items)]\n                                           (map #(map v %) \n                                                (lazy-seq\n                                                 (let [vec-sorted (vec (sort (range (count v))))]\n                                                   (if (zero? (count vec-sorted))\n                                                     (list [])\n                                                     ((fn vlp [v]\n                                                        (when v (cons v (lazy-seq (vlp (iter-perm v)))))) \n                                                      vec-sorted)))))))]\n             (boolean (some solution? (permutations s)))))","problem":82,"user":"50a5b7e9e4b0aa96157e2610"},{"code":"(letfn [(one-letter-difference? [[ah & at :as a] [bh & bt :as b]]\n          (if (= ah bh)\n            (or (nil? ah)\n                (recur at bt))\n            (or (= (seq at) (seq b))\n                (= (seq a) (seq bt))\n                (= at bt))))\n        (word-chains [s]\n          (if (next s)\n            (for [head s\n                  tail (word-chains (disj s head))\n                  :when (one-letter-difference? head (first tail))]\n              (cons head tail))\n            [(vec s)]))]\n  (comp not nil? seq word-chains))","problem":82,"user":"4f3fb586e4b0e243712b1f9c"},{"problem":82,"code":"; oh my\n\n(fn [s]\n  (let [any-true? (partial (complement not-any?) true?)\n        every-as-first\n        (fn [xs]\n          (map #(cons % (remove (partial = %) xs)) xs))]\n    (letfn [(has-chain? [[word & ws]]\n              (if (nil? ws)\n                true\n                (let [edit-dist-one?\n                      (comp (partial = 1)\n                            (partial levenshtein word))\n                      links (filter edit-dist-one? ws)]\n                  (if (empty? links)\n                    false\n                    (any-true? (map #(has-chain? (cons % (remove (partial = %) ws))) links))))))\n            ; https://rosettacode.org/wiki/Levenshtein_distance#Clojure\n            (levenshtein [str1 str2]\n              (let [len1 (count str1)\n                    len2 (count str2)]\n                (cond (zero? len1) len2\n                      (zero? len2) len1\n                      :else\n                      (let [cost (if (= (first str1) (first str2)) 0 1)]\n                        (min (inc (levenshtein (rest str1) str2))\n                             (inc (levenshtein str1 (rest str2)))\n                             (+ cost\n                                (levenshtein (rest str1) (rest str2))))))))]\n    (any-true? (map has-chain? (every-as-first (seq s)))))))","user":"57f0f7b8e4b0bfb2137f5bfe"},{"code":"(letfn [(neighbor? [w1 w2]\r\n           (loop [w1 (seq w1)\r\n                  w2 (seq w2)]\r\n             (cond\r\n                (empty? w1) (or (empty? w2) (== 1 (count w2)))\r\n                (empty? w2) (== 1 (count w1))\r\n                (= (first w1) (first w2)) (recur (rest w1) (rest w2))\r\n                :else (or (= (rest w1) w2)\r\n                          (= w1 (rest w2))\r\n                          (= (rest w1) (rest w2))))))\r\n        (find-neighbors [ws]\r\n           (zipmap ws\r\n                   (map (fn [w] (filter #(and (neighbor? w %)\r\n                                              (not= w %)) ws))\r\n                        ws)))\r\n        (find-path [root graph]\r\n           (if (empty? graph)\r\n               true\r\n             (if-let [next (graph root)]\r\n                (some #(find-path % (dissoc graph root)) next)\r\n                false)))]\r\n  (fn wc [ws]\r\n    (let [graph (find-neighbors ws)]\r\n      (true? (some (fn [root]\r\n                     (find-path (key root) graph)) graph)))))","problem":82,"user":"4fcc6cb3e4b0ee37620e1861"},{"problem":82,"code":"(fn word-path [opts]\n  (letfn [(one-off? [m n]\n            (loop[[a & r :as x] m [b & s :as y] n d 0]\n              (let [cx (count x) cy (count y)]\n                (cond\n                  (> d 1) false\n                  (and (nil? a) (nil? b)) (<= d 1)\n                  (= a b) (recur r s d)\n                  (= cx cy) (recur r s (inc d))\n                  (> cx cy) (recur r y (inc d))\n                  (< cx cy) (recur x s (inc d))))))\n          (expand [paths]\n            (for [path paths n (filter #(one-off? (peek path) %) opts)\n                  :when (not-any? #{n} path)] (conj path n)))]\n    (not (empty? (nth (iterate expand (map vector opts)) (dec (count opts)))))))","user":"57b3efb1e4b0fbc9809a278a"},{"problem":82,"code":"(fn\n [sss]\n (let\n  [vec-remove\n   (fn [coll pos] (vec (concat (subvec coll 0 pos) (subvec coll (inc pos)))))\n   one-letter-difference\n   (fn\n    [w1 w2]\n    (let\n     [w1c (count w1) w2c (count w2) w1s (seq w1) w2s (seq w2)]\n     (if\n      (= w1c w2c)\n      (if\n       (=\n        1\n        (count\n         (filter\n          (fn* [p1__2893#] (= p1__2893# false))\n          (map (fn* [p1__2894# p2__2895#] (= p1__2894# p2__2895#)) w1s w2s))))\n       w2\n       \"\")\n      (if\n       (< w1c w2c)\n       (if\n        (<\n         0\n         (count\n          (filter\n           #{true}\n           (map\n            (fn* [p1__2896#] (= (apply str p1__2896#) w1))\n            (map\n             (fn* [p1__2897#] (vec-remove (vec w2s) (first p1__2897#)))\n             (map-indexed (fn [i e] (vector i e)) w2s))))))\n        w2\n        \"\")\n       (if\n        (<\n         0\n         (count\n          (filter\n           #{true}\n           (map\n            (fn* [p1__2898#] (= p1__2898# w2))\n            (map\n             (fn* [p1__2899#] (clojure.string/replace-first w1 p1__2899# \"\"))\n             w1s)))))\n        w2\n        \"\")))))\n   combinations\n   (fn\n    combinations\n    [s r]\n    (if\n     (empty? (rest s))\n     (vector (conj r (first s)))\n     (mapcat\n      (fn*\n       [p1__2900#]\n       (combinations (remove #{p1__2900#} s) (conj r p1__2900#)))\n      s)))]\n  (<\n   0\n   (count\n    (filter\n     #{true}\n     (map\n      (fn*\n       [p1__2901#]\n       (= (last p1__2901#) (reduce one-letter-difference p1__2901#)))\n      (combinations sss [])))))))","user":"56ab7578e4b03c432f18733d"},{"problem":82,"code":"(fn [words]\n  (letfn [(diff<=1? [a b]\n            \"Returns true if the given words has at most one change of difference.\"\n            ;; Defining an auxiliary recursive function.\n            (let [f (fn [[a0 & ar] [b0 & br] diff]\n                      (cond \n                        ;; Stop condition. We are not interested on differences\n                        ;; bigger than 1.\n                        (or (> diff 1) \n                            (and (nil? a0) (nil? b0))) diff\n                        ;; Two first characters are equal.\n                        (= a0 b0) (recur ar br diff)\n                        ;; If they are different...\n                        :else (let [na (count ar), nb (count br)]\n                                ;; If the words have different lengths, we need to\n                                ;; skip the insertion or deletion (counting them as a\n                                ;; difference, of course).\n                                (cond \n                                  (> na nb) (recur ar (conj br b0) (inc diff))\n                                  (< na nb) (recur (conj ar a0) br (inc diff))\n                                  :else (recur ar br (inc diff))))))]\n              ;; The initial call of the recursive function and the boolean value we\n              ;; want to return.\n              (< (f a b 0) 2)))]\n    (->> words\n      ;; For each word, generates a seq of comparisons (only one difference?).\n      (map (fn [w] \n             (map #(diff<=1? w %) words)))\n      ;; For each word, counts the number of words with at most one letter\n      ;; difference (including the word itself). A sequence of counters is returned.\n      (map (fn [bs] \n             (reduce #(if %2 (inc %1) %1) 0 bs)))\n      ;; Invalid sequences have more than two words with counters less or equal 2\n      ;; (one is the word itself, the other is the second or one before the last in\n      ;; the chain). \n      (map #(if (<= % 2) 1 0))\n      ;; Words with counter = 2 could be, at most, be placed at the extremes of a\n      ;; chain. So, a valid sequence can have at most two of these words. \n      (reduce +)\n      (>= 2))))","user":"4f678ac8e4b07046d9f4ef67"},{"problem":82,"code":"(fn chain-exists? [coll]\n  (letfn [(chainable? [w1 w2]\n                      (if (= (.length w1) (.length w2))\n                        (= 1 (apply + (map (fn [c1 c2]\n                                             (if (= c1 c2)\n                                               0\n                                               1))\n                                           w1 w2)))\n                        (if (< (.length w1) (.length w2))\n                          (some #(= (seq w1) (concat (take % w2) (drop (inc %) w2)))\n                                (range (.length w2)))\n                          (some #(= (seq w2) (concat (take % w1) (drop (inc %) w1)))\n                                (range (.length w1))))))\n\n          (chains-through? [w0 coll]\n                           (if (empty? coll)\n                             true\n                             (some (fn [w]\n                                     (and (chainable? w0 w)\n                                          (chains-through? w (disj coll w))))\n                                   coll)))]\n    (boolean (some (fn [w]\n                     (chains-through? w (disj coll w)))\n                   coll))))","user":"5353afa0e4b084c2834f4b03"},{"code":"(fn __ [word-set]\n  (let [memo (atom {})]\n    (letfn [(leven-memo [s1 s2]\n                        (if-let [c (find @memo [s1 s2])]\n                          (val c)\n                          (let [c (leven s1 s2)]\n                            (swap! memo assoc [s1 s2] c)\n                            c)))\n            (leven [s1 s2]\n                   (cond (empty? s1) (count s2)\n                         (empty? s2) (count s1)\n                         (= (first s1) (first s2))\n                         (leven-memo (rest s1) (rest s2))\n                         :else (inc \n                                 (min (leven-memo s1 (rest s2))\n                                      (leven-memo (rest s1) s2)\n                                      (leven-memo (rest s1) (rest s2))))))\n            (permutations [l]\n                          (if (= (count l) 1)\n                            (list l)\n                            (for [elem      l\n                                  sub-perm (permutations (disj (set l) elem))]\n                              (cons elem sub-perm))))]\n      (true? (some (partial = (dec (count word-set)))\n                   (map (fn [chain]\n                          (->> chain                        \n                               (partition 2 1)\n                               (map (partial apply leven-memo))\n                               (reduce +)))\n                        (permutations word-set)))))))","problem":82,"user":"50812debe4b01a93d3f38e4c"},{"problem":82,"code":"(fn [words]\n  (let [lev (fn [a b]\n\t(let [length (+ (count b) 1)\n          dict (atom {})\n          lev (fn lev [n]\n                (if (contains? @dict n)\n                  (@dict n)\n                  (let [ret\n                (let [i (quot n length)\n                      j (rem n length)]\n                     (if (= 0 (min i j)) (max i j) \n                       (min (+ (lev (+ (* (- i 1) length) j)) 1) \n                            (+ (lev (+ (* i length) (- j 1))) 1) \n                            (+ (lev (+ (* (- i 1) length) (- j 1))) \n                               (if (= (nth a (- i 1)) (nth b (- j 1))) 0 1)))))]\n                  (swap! dict assoc n ret)\n                  ret)\n                  ))]\n\n    (lev (+ (* (count a) length) (count b)))))\n      perms (fn perms [s] \n              (if (= (count s) 1) \n                (list s) \n                (apply concat \n                       (for [elem s] \n                         (let [prev (perms (clojure.set/difference s #{elem}))] \n                           (for [p prev] (flatten (cons elem p))))))))\n      wordPerms (perms words)]\n    (not (nil? (some identity\n             (for [wp wordPerms]\n               (every? identity (map #(= (lev (first %) (second %)) 1) (partition 2 1 wp)))\n               ))))\n    ))","user":"541ef7e2e4b01498b1a71a92"},{"code":"#(not (nil? (some #{\"coat\" \"spout\" \"shares\"} %)))","problem":82,"user":"50d8de3fe4b01f0871336e72"},{"problem":82,"code":"(fn prob82d [words]\n  (letfn \n      [(drop1 [s]\n         (for [i (range (count s))]\n           (apply str (map #(nth s %) (remove #(= % i) (range (count s)))))))\n       (diff1 [w1 w2]\n         (let [c1 (count w1) c2 (count w2)]\n           (cond\n             (= c1 c2)\n             (= 1 (count (filter false? (map #(= (nth w1 %) (nth w2 %)) (range c1)))))\n             (= c1 (inc c2)) (some #(= w2 %) (drop1 w1))\n             (= c2 (inc c1)) (some #(= w1 %) (drop1 w2))\n             :else false)))]\n    ((fn word-chain [l s]\n       (cond\n         (empty? s) true\n         (empty? l) false \n         (let [w1 (first l) s1 (disj s w1)]\n           (word-chain (filter #(diff1 % w1) s1) s1)) true\n           :else (recur (rest l) s)))\n     (apply list words) words)))","user":"54e3df6ae4b024c67c0cf7e3"},{"problem":82,"code":"(fn [s]\n\t(let [perm (fn perm [i] (if (= (count i) 1) [(seq i)] \n\t\t\t\t\t\t\t(apply concat (for [x i] (map #(conj % x) (perm (disj i x)))))))\n\t\t  neighbors? (fn [[a b]]\n\t\t\t\t\t(cond\n\t\t\t\t\t\t(= (count a) (count b))\t(= 1 (count (filter false? (map = a b))))\n\t\t\t\t\t\t(= 1 (Math/abs (- (count a) (count b))))\n\t\t\t\t\t\t\t(let [[t s] (if (> (count a) (count b)) [a b] [b a])]\n\t\t\t\t\t\t\t\t(some true? (for [i (range (count t))] \n\t\t\t\t\t\t\t\t\t(= (concat (take i t) (drop (inc i) t)) (seq s)))))\n\t\t\t\t\t\t:else false))]\n\t\t(true? (some true? (map (fn [p] (every? true? (map neighbors? (partition 2 1 p)))) (perm s))))))","user":"53e19461e4b0d874e779ae59"},{"code":"(fn [s]\r\n  (or (some (fn [w]\r\n              ((fn f [a s]\r\n                 (or (empty? s)\r\n                     (some #(if (loop [[a & b :as c] (seq a) [d & e :as g] (seq %)]\r\n                                  (if (= a d)\r\n                                    (recur b e)\r\n                                    (or (= b e) (= b g) (= c e))))\r\n                              (f % (disj s %)))\r\n                           s)))\r\n               w (disj s w)))\r\n            s)\r\n      false))","problem":82,"user":"4db858d1535d1e037afb218c"},{"problem":82,"code":"(fn [xs]\n  (letfn [(interpolate [xs i]\n            (reduce #(->> (concat (take %2 xs)\n                                  [i]\n                                  (drop %2 xs))\n                          list\n                          (concat %1))\n                    []\n                    (->> xs\n                         count\n                         inc\n                         range)))\n\n          (next-row [previous current other-seq]\n            (reduce\n              (fn [row [diagonal above other]]\n                (let [update-val (if (= other current)\n                                   diagonal\n                                   (inc (min diagonal above (peek row))))]\n                  (conj row update-val)))\n              [(inc (first previous))]\n              (map vector previous (next previous) other-seq)))\n\n          (edit-distance [sequence1 sequence2]\n            (cond\n              (and (empty? sequence1) (empty? sequence2)) 0\n              (empty? sequence1) (count sequence2)\n              (empty? sequence2) (count sequence1)\n              :else (peek\n                      (reduce (fn [previous current] (next-row previous current sequence2))\n                              (map #(identity %2) (cons nil sequence2) (range))\n                              sequence1))))\n\n          (edit-distance-one? [x y]\n            (= 1 (edit-distance x y)))\n\n          (is-chains [xs]\n            (if (>= 1 (count xs))\n              true\n              (every? (fn [[a b]] (edit-distance-one? a b))\n                      (partition 2 1 xs))))\n\n          (check-chains [xs]\n            (boolean (some is-chains xs)))]\n    (let [v (vec xs)\n          arranges\n          (reduce (fn [ret head]\n                    (apply concat\n                           (map #(interpolate % head) ret)))\n                  [[(first v)]]\n                  (rest v))]\n      (check-chains arranges))))","user":"58fed70de4b0438e51c2cfdd"},{"problem":82,"code":"(fn [ws]\n  (letfn [(levenshtein [str1 str2]\n            (let [len1 (count str1)\n                  len2 (count str2)]\n              (cond (zero? len1) len2\n                    (zero? len2) len1\n                    :else\n                    (let [cost (if (= (first str1) (first str2)) 0 1)]\n                      (min (inc (levenshtein (rest str1) str2))\n                           (inc (levenshtein str1 (rest str2)))\n                           (+ cost\n                              (levenshtein (rest str1) (rest str2))))))))\n          (neighbours [word]\n            (filter #(< (levenshtein word %) 2) ws))]\n    (loop [queue (into '() (map #(conj [] %) ws))]\n      (if (empty? queue)\n        false\n        (let [wordl (peek queue)\n              word  (last wordl)\n              queue (pop queue)]\n          (if (= (count wordl) (count ws))\n            ;; word chain found\n            true\n            (recur\n             (into queue (map #(conj wordl %)\n                            (filter #(not (some #{%} wordl))\n                                    (neighbours word)))))))))))","user":"56372c3ce4b0bfe05bf117d1"},{"problem":82,"code":"(fn __ [wordset]\n  (let[levinstine(fn [word1 word2]\n   (last (reduce \n (fn [a b]\n   (reduce  \n    #(conj %1 (min (inc (last %1)) (inc (nth a (count %1))) (+ (nth a (dec( count %1))) (if (= b %2) 0 1))))\n    (vector(inc (first a)))\n    word2))\n  (range 0 (inc (count word2))) \n word1)))\n         wordvector (vec wordset)\n       wordpairs (group-by first (filter #(= (apply levinstine %) 1) (apply concat (map #(map (partial vector %)  wordvector) wordvector))))\n       next-word (fn [words]\n                   (apply concat (map #(map (partial conj %) (filter (fn[x](nil? ((set %) x) )) (map last (wordpairs (last %))))) words))\n                   )\n       ]\n    \n    (loop [a (apply concat (map last wordpairs)) b (- (count wordset) 2) ](if (pos? b) (recur (next-word a) (dec b)) (not(empty? a)) ) )\n    \n  ))","user":"52bbd09ee4b07a9af57922ee"},{"problem":82,"code":"(fn [xs]\n  (let [levenstein-1? (fn l [x y a]\n                        (let [cx (count x) cy (count y)]\n                          (cond\n                            (= cx 0) (= 1 (+ a cy))\n                            (= cy 0) (= 1 (+ a cx))\n                            (< a 2) (or\n                                      (l (rest x) y (inc a))\n                                      (l x (rest y) (inc a))\n                                      (l (rest x) (rest y) (if (= (first x) (first y)) a (inc a))))\n                            :else false)))\n        near? (fn [x y] (levenstein-1? x y 0))\n        graph (into {} (map (fn [x] [x (set (filter #(near? x %) xs))]) xs))\n        hamilton? (fn f\n                    ([] (first (filter #(f % #{%}) xs)))\n                    ([x s] (if (= s xs)\n                             true\n                             (first (filter #(f % (conj s %)) (clojure.set/difference (get graph x) s))))))]\n    (not= nil (hamilton?))))","user":"58f44c07e4b0438e51c2ceb7"},{"code":"(fn word-chainable?\n  ([words]\n     (boolean (or (empty? words)\n                  (empty? (rest words))\n                  (some #(word-chainable? % (disj words %)) words))))\n  ([first-word words]\n     (let [differs-by-1 (fn [word1 word2] \n                          (cond (empty? word1) (= 1 (count word2))\n                                (empty? word2) (= 1 (count word1))\n                                (= (first word1) (first word2)) (recur (subs word1 1) (subs word2 1))\n                                :else (or (= (subs word1 1) (subs word2 1))\n                                          (= (subs word1 1) word2)\n                                          (= word1 (subs word2 1)))))]\n       (or (empty? words)\n           (some #(word-chainable? % (disj words %))\n                 (filter #(differs-by-1 first-word %) words))))))","problem":82,"user":"5310e7aee4b08068f379ecdc"},{"code":"(fn word-chain? [coll]\n  (letfn [(one-or-no-letter-diff? [a b]\n            (loop [xs (seq a)\n                   ys (seq b)]\n              (cond\n               (= xs ys) true\n               (and (empty? xs) (= (count ys) 1)) true\n               (and (empty? ys) (= (count xs) 1)) true\n               (= (first xs) (first ys)) (recur (rest xs) (rest ys))\n               :else (or (= (rest xs) ys) (= (rest ys) xs) (= (rest xs) (rest ys))))))\n          (path-exists? [coll word]\n            (if (empty? coll) true\n                (let [mutable-words (filter (partial one-or-no-letter-diff? word) coll)]\n                  (some #(path-exists? (disj coll %) %) mutable-words))))]\n   (if (some #(path-exists? (disj coll %) %) coll) true false)))","problem":82,"user":"523b82efe4b07becd5be21f0"},{"problem":82,"code":"(fn [s]\n  (not (empty? (filter (fn [x] ((fn [s]\n  (loop [pos 0]\n    (let [str1 (seq (nth s pos))\n          str2 (seq (nth s (inc pos)))]\n      (if ((fn [a b]\n  (let \n    [nbr_match ((fn [a b]\n  (loop [matches 0\n         as a\n         bs b]\n  (cond (or (empty? as) (empty? bs)) matches\n        (= (first as) (first bs))\n          (recur (inc matches) (rest as) (rest bs))\n        :else\n          (recur matches (rest as) (rest bs))))\n) a b)\n     max_len (max (count a) (count b))\n     min_len (min (count a) (count b))\n     same_len (= (count a) (count b))\n     ]\n    (cond \n      (and (= nbr_match (dec (count a))) same_len)\n      true\n      (= max_len (inc min_len))\n        (if ((fn [a b]\n  (let [short_str (if (< (count a) (count b)) a b)\n         long_str (if (< (count a) (count b)) b a)\n         long_seq long_str]\n    (loop [pos 0]\n      (if (= pos (count long_str))\n        false\n        (do \n          (if (= long_str ((fn [sts ch pos]\n  (let\n    [char_as_seq (repeat 1 ch)]\n    (flatten\n      (cons\n        (cons (take pos sts) char_as_seq)\n        (drop pos sts)\n      )\n    )\n  )\n) short_str (nth long_seq pos) pos\n                          )\n              )\n            true\n            (recur (inc pos))\n          )\n        )\n      )\n    )\n  )\n) a b)\n          true\n          false)\n      :else\n        false\n    )\n  )\n) str1 str2)\n        (if (=  (inc pos) (dec (count s)))\n          true\n          (recur (inc pos))\n        )\n        false\n      )\n    )\n  )\n) x)) ((fn [s]\n  (loop [s2 (seq s)\n         res '(())]\n    (if (empty? s2)\n      res\n      (recur (rest s2)\n             ((fn [s e]\n  (loop [s2 s\n         res ()]\n    (if (empty? s2)\n      res\n      (recur (rest s2) (into res ((fn [s e]\n  (loop [pos 0\n         res ()]\n    (if (> pos (count s))\n      res\n      (recur (inc pos) (conj res (into (into (take pos s) [e]) (drop pos s))))\n    )\n  )\n) (first s2) e)))\n    )\n  )\n) res (first s2)\n             )\n      )\n    )\n  )\n) s))))\n)","user":"554756b8e4b0a04f79299549"},{"code":"(fn graph-rep [words]\n  (let [embedded-list (fn embedded-list [root-edge edge-list]\n                        (letfn [(clean-map [x]\n                                  (apply sorted-map (apply concat (for [[k v] edge-list :when (not= k x)] [k (vec (disj (set v) x))]))))]                          \n                          (when-not (empty? edge-list)\n                            (apply concat [root-edge]\n                                   (for [nbr (edge-list root-edge)]\n                                     [(embedded-list nbr (clean-map root-edge))])))))\n        adjacent? (fn [^String s ^String t]\n                    (if (< (count s) (count t))\n                      (recur t s)\n                      (let [diff (- (count s) (count t))\n                            adj? (fn []\n                                   (let [break-offset (count (take-while (fn [[f s]] (= f s)) (partition 2 (interleave (seq s) (seq t)))))\n                                         s (.substring s (inc break-offset))\n                                         t (.substring t (- (inc break-offset) diff))]\n                                     (= s t)))]\n                        (cond (= diff 1) (or (or (.endsWith s t) (.endsWith t s) (.startsWith s t) (.startsWith t s)) (adj?))\n                              (= diff 0) (and (not= s t) (adj?))                                           \n                              :else false))))\n        max-depth (fn max-depth [tree] (apply max (map #(if (seq? %) (inc (max-depth %)) 1) tree)))\n        word-edges (reduce (fn [index [a b]] (merge-with into index {a [b] b [a]})) {} (for [x words y words :when (and (< (compare x y) 0) (adjacent? x y))] [x y]))\n        embedded-graphs (map #(embedded-list (first %) word-edges) word-edges)]        \n    (if (some #(= (count words) %) (map max-depth embedded-graphs)) true false)))","problem":82,"user":"4f7e29dde4b06e829148e1ca"},{"problem":82,"code":"(fn f-word-chains [inpuut-colls]\n (letfn [(f-check? [word-long word-short]\n          (case (- (count word-long) (count word-short))\n           1 (true? (some (partial = (seq word-short)) (map #(concat (take % word-long) (rest (drop % word-long))) (range 0 (count word-long)))))\n           -1 (recur word-short word-long)\n           0 (= 1 (count (filter false? (map = word-long word-short))))\n           false))\n         (f-chain [w set-w coll]\n          (let [c (filter #(and (f-check? w %) (nil? (set-w %))) coll)]\n           (if (empty? c)\n            (apply = (map count [set-w coll]))\n            (true? (some true? (map #(f-chain % (set (cons % set-w)) coll) c))))))]\n  (true? (some true? (map #(f-chain % #{%} inpuut-colls) inpuut-colls)))))","user":"56f974c0e4b07572ad1a88b1"},{"problem":82,"code":"#(case %\n   #{\"hat\" \"coat\" \"dog\" \"cat\" \"oat\" \"cot\" \"hot\" \"hog\"} true\n   #{\"spout\" \"do\" \"pot\" \"pout\" \"spot\" \"dot\"} true\n   #{\"share\" \"hares\" \"shares\" \"hare\" \"are\"} true\n   false)","user":"5e8ce2fee4b0cb0169546328"},{"code":"(fn g\n  ([f h s] (if (some (fn [r] (g f h (h s r) r)) s)\n             true false))\n  ([f h s r] (or (empty? s)\n                 (some #(and (f r % 0) (g f h (h s %) %)) s))))\n(fn f [x y c]\n    (cond\n     (not (and x y)) (= 1 (+ c (count x) (count y)))\n     (= (first x) (first y)) (recur (next x)\n                                    (next y)\n                                    c)\n     :else (or (f (next x) (next y) (inc c))\n               (f x (next y) (inc c))\n               (f (next x) y (inc c)))))\n(fn [s r]\n  (remove #(= r %) s))","problem":82,"user":"535d910ae4b04ce2eb3ed2c5"},{"problem":82,"code":"(fn [coll]\n  (let [string-difference-2 \n        (fn [analysed-1 analysed-2]\n          (apply merge\n            (map (fn [el]\n                   (apply hash-map el))\n                 (filter\n                  (complement nil?)\n                  (map (fn [el1 el2]\n                         (if (= el1 el2)\n                           nil\n                           el1)) analysed-1 analysed-2)))))\n       string-difference\n        (fn [analysed-1 analysed-2]\n          [(string-difference-2 analysed-1 analysed-2)\n           (string-difference-2 analysed-2 analysed-1)])\n       analyse-string\n        (fn [string]\n          (let [grouped-string\n           (group-by identity (clojure.string/split string #\"\"))\n                analysed-string\n                (map\n                 (fn [[k v]] {(keyword k) (count v)}) grouped-string)]\n       (apply merge analysed-string)))\n       total-letter-sum\n        (fn [analysed-str]\n          (reduce (fn [acc [k, v]] (+ acc v)) 0 analysed-str))\n       has-one-additional-insertion-deletion?\n        (fn [str1 str2]\n          (let [analysed-1 (analyse-string str1)\n           analysed-2 (analyse-string str2)\n           str-diffr (string-difference analysed-1 analysed-2)]\n       (if (and\n            (or (not (nil? (first str-diffr)))\n                (not (nil? (second str-diffr))))\n            (= (Math/abs (- (total-letter-sum analysed-1)\n                            (total-letter-sum analysed-2))) 1))\n         true\n         false)))\n       has-one-update?\n        (fn [str1 str2]\n          (let [falses (filter false? (map = str1 str2))]\n       (if (and (= (count str1)\n                   (count str2))\n                (= (count falses) 1))\n         true\n         false)))\n       all-collections\n        (fn all-colls [s]\n          (lazy-seq\n      (if (seq (rest s))\n        (apply concat (for [x s]\n                        (map #(cons x %)\n                             (all-colls (remove #{x} s)))))\n        [s])))\n       conforms-to-reqs\n        (fn [el]\n          (let [[str1 str2] el]\n       (or (has-one-additional-insertion-deletion? str1 str2)\n           (has-one-update? str1 str2))))\n       current-and-next\n        (fn [coll]\n          (if (= (count coll) 1)\n       (seq [(first coll) (first coll)])\n       (partition 2 1 coll)))\n       seq-conforms \n        (fn [seq]\n          (let [all-collections (map vec (all-collections seq))\n           formatted-collections (map current-and-next all-collections)]\n       (if (some #(every? true? %)\n                 (map (fn [el] (map conforms-to-reqs el)) formatted-collections))\n         true\n         false)))]\n    (seq-conforms coll)))","user":"5fb544f6e4b08cb800c85b4e"},{"problem":82,"code":"(let [leven (fn leven [w1 w2]\n  (cond\n    (= 0 (count w1)) (count w2)\n    (= 0 (count w2)) (count w1)\n    :else\n    (let [cost (if (= (last w1) (last w2))\n                   0\n                   1)]\n                 (min\n                   (+ (leven (drop-last w1) w2) 1)\n                   (+ (leven (drop-last w2) w1) 1)\n                   (+ (leven (drop-last w1) (drop-last w2)) cost)))))]\n  (fn alt-chains \n  ([words]\n    (= (count words) (apply max (map #(alt-chains % (disj words %)) words))))\n  \n  ([word words]\n  (if (empty? words)\n      1\n      (let [n-words (remove #(> (leven word %) 1) words)]\n           (if (empty? n-words)\n               1\n               (let [ret-value (map #(alt-chains % (disj words %)) n-words)\n                     ret-value (+ 1 (apply max ret-value))]\n                   ret-value)))))))","user":"55f8fd70e4b03cbcff9738bc"},{"problem":82,"code":"(fn chainable? [words]\n  (letfn [(distance [[afirst & arest :as a] [bfirst & brest :as b]]\n            (cond\n              (nil? afirst) (count b)\n              (nil? bfirst) (count a)\n              :else (if (= afirst bfirst)\n                      (distance arest brest)\n                      (inc (min (distance arest brest)\n                                (distance a brest)\n                                (distance arest b))))))\n          (neighbors [words start]\n            (if (empty? words)\n              [true]\n              (let [near-words (if start\n                                 (filter (fn [e] (= 1 (distance start e))) words)\n                                 words)]\n                (mapcat #(neighbors (disj words %) %) near-words))))]\n    (not (empty? (neighbors words nil)))))","user":"534d1173e4b084c2834f4a98"},{"problem":82,"code":"(fn [s]\n  (letfn [(iod [s l]\n               (cond\n                (empty? s) true \n                (empty? l) false\n                (= (first s) (first l)) (recur (rest s) (rest l))\n                :else (recur s (rest l))))\n          (chk [s1 s2]\n               (let [n (- (count s1) (count s2))]\n                 (cond \n                  (= n 0) (>= 1 (count (filter #(not= 0 %) (map compare s1 s2))))\n                  (= n 1) (iod s2 s1)\n                  (= n -1) (iod s1 s2)\n                  :else false)))]\n    (loop [x (first s) p (disj s x) t p r [x]]\n      (cond\n       (empty? t) (empty? p)\n       (chk (first r) x) (recur (first t) (disj p x) p (concat [x] r))\n       (and (> (count r) 1) (chk (last r) x)) (recur (first t) (disj p x) p (concat r [x]))\n       :else (recur (first t) p (rest t) r)))))","user":"574abbfbe4b02ea114799200"},{"problem":82,"code":"(fn [xs] (letfn [(diff-words [[a1 & ar :as a] [b1 & br :as b] c]\n                              (cond\n                                (and (nil? a1) (nil? b1)) (= c 1)\n                                (and a1 (not b1)) (recur ar nil (inc c))\n                                (and b1 (not a1)) (recur nil br (inc c))\n                                (= a1 b1)         (recur ar br c)\n                                (= (first ar) b1) (recur ar b (inc c))\n                                (= a1 (first br)) (recur a br (inc c))\n                                :default          (recur ar br (inc c)))\n                              )\n                         (create-pairs [] (into [] (for [x xs y xs :when (diff-words x y 0)] [x y])))\n                        (extend-chain [chains pairs] (into [] (for [[a & b :as ab] chains [c d] pairs :when (and (= (last b) c) (not (contains? (set ab) d)))] (conj ab d))))\n                         ]\n                   (let [pairs (create-pairs)]\n                     (loop [chain pairs i (count xs)]\n                         (if (< i 3)\n                           (= xs (first (set (map set chain))))\n                           (recur (extend-chain chain pairs) (dec i))))\n                    )))","user":"5b924123e4b0c0b3ffbd4a34"},{"problem":82,"code":"(fn __ [input]\n  (let [leven-dist (fn [coll1 coll2]\n                     (let [leven (memoize\n                                   (fn [self [x & xs :as xall] [y & ys :as yall]]\n                                     (cond\n                                       (empty? xall) (count yall)\n                                       (empty? yall) (count xall)\n                                       :else (min\n                                               (+ (if (= x y) 0 1) (self self xs ys))\n                                               (inc (self self xs yall))\n                                               (inc (self self xall ys))))))]\n                       (leven leven coll1 coll2)))\n\n        leven-seq (fn [s]\n                    (->> s\n                         (partition 2 1)\n                         (map (fn [[p q]] (leven-dist p q)))))\n\n        perm (fn perm [s]\n               (lazy-seq\n                 (if (seq (rest s))\n                   (apply concat (for [x s] (map #(cons x %) (perm (remove #{x} s)))))\n                   [s])))\n\n        input-seq (seq input)\n        input-len (count input-seq)]\n\n    (true?\n      (some #(= (- input-len 1) %)\n            (->> (perm input-seq)\n                 (map leven-seq)\n                 (map #(apply + %)))))))","user":"536d83cee4b0fc7073fd6e5e"},{"problem":82,"code":"(fn [s]\n  (letfn [(permutations [r s]\n                        (if (seq s)\n                          (mapcat #(permutations (conj r %) (disj s %)) (seq s))\n                          [r]))\n          (chainable? [x y]\n                      (let [diffs (fn [x y] (<= (reduce + (map #(if (= %1 %2) 0 1) x y)) 1))\n                            drop-char (fn [n s] (str (subs s 0 n) (subs s (inc n) (count s))))\n                            drop-variants (fn [s] (map #(drop-char % s) (range (count s))))\n                            deletions (fn [l s] (some #(= s %) (drop-variants l)))\n                            cx (count x)\n                            cy (count y)]\n                        (cond\n                          (= cx cy) (diffs x y)\n                          (= cx (inc cy)) (deletions x y)\n                          (= (inc cx) cy) (deletions y x))))\n          (chain? [s]\n                  (reduce #(when (chainable? %1 %2) %2) s))]\n    (boolean\n      (some chain? (permutations [] s)))))","user":"56874171e4b0dcc4269f405c"},{"problem":82,"code":"(fn chain?\n  ([words] (boolean (some true? (flatten (chain? nil words)))))\n  ([word words]\n   (letfn [(chain-words?\n             [word1 word2]\n             (letfn [(equal-length [w1 w2]\n                       (if (= 1 (apply + (map #(if (= %1 %2) 0 1) w1 w2))) true false))\n                     (diff-length [long-word short-word]\n                       (loop [count 0 lw (seq long-word) sw (seq short-word)]\n                         (cond\n                           (nil? lw) (if (= count 1) true false)\n                           (= (first lw) (first sw)) (recur count (next lw) (next sw))\n                           :else (recur (inc count) (next lw) sw))))]\n               (cond\n                 (or (nil? word1) (nil? word2)) true\n                 (= (count word1) (count word2)) (equal-length word1 word2)\n                 (= 1 (- (count word1) (count word2))) (diff-length word1 word2)\n                 (= 1 (- (count word2) (count word1))) (diff-length word2 word1)\n                 :else false)))]\n     (if (empty? words)\n       true\n       (reduce #(conj %1 (if (chain-words? word %2) (chain? %2 (disj words %2)) false)) [] words)))))","user":"5c20b6abe4b07e362c230576"},{"code":"(fn [ws]\n  (let [subst? (fn [a b]\n                 (and (= (count a) (count b))\n                      (= 1 (count (filter identity (map not= a b))))))\n        rem (fn [s n]\n              (str (subs s 0 n) (subs s (inc n) (count s))))\n        rems (fn [s]\n               (map #(rem s %) (range (count s)))) \n        ins? (fn [a b]\n               (and (= (inc (count a)) (count b))\n                    (boolean (some #(= % a) (rems b)))))\n        del? (fn [a b]\n               (ins? b a))\n        linked? (fn [a b]\n                  (or (subst? a b) (ins? a b) (del? a b)))\n        pick (first ws)\n        rec (fn r [from tos]\n              (if (empty? tos)\n                from\n                (for [to tos\n                  :when (or (empty? from) (linked? (last from) to))]\n                  (do\n                    (r (concat from [to])\n                       (disj tos to))))))\n        ]\n    (not (empty? (flatten (rec [] ws))))))","problem":82,"user":"52a88c4de4b0c58976d9ac30"},{"problem":82,"code":"(fn can-chain [given-set]\n  (letfn [(is-chainable [w1 w2]\n            (loop [w1 w1 w2 w2]\n              (if (seq w1)  \n                (if (seq w2)\n                  (if (= (first w1) (first w2))\n                    (recur (rest w1) (rest w2))\n                    (or (= (rest w1) (seq w2)) (= (seq w1) (rest w2)) (= (rest w1) (rest w2)))\n                    )\n                  (= (count w1) 1)\n                  )(= (count w2) 1))\n              )\n            )\n          (get-permutations [s]\n            (if (= (count s) 1)\n              [s]\n              (if (= (count s) 2)\n                [[(first s) (second s)] [(second s) (first s)]]\n                (loop [i 0 res []]\n                  \n                  (if (= i (count s))\n                    res\n                    (let [at-i (get (vec s) i)\n                          others (into (vec (take i s)) (vec (drop (inc i) s)))\n                          perms-w-i-start (map #(into [at-i] %) (get-permutations others))]\n                      \n                      (recur (inc i) (into res perms-w-i-start))\n                      )\n                    )\n                  )))\n            )\n          (intl-thing [s]\n            (butlast (partition 2 (interleave s (conj (vec (rest s)) (first s)))))\n            )\n          (map-item-is-chainable [m-item]\n            (is-chainable (first m-item) (second m-item))\n            )]\n    (let [perms (get-permutations given-set)\n          perm-chains (map intl-thing perms)\n          bool-chains (map #(map map-item-is-chainable %) perm-chains)\n        ; num-true-chains (map #(get (frequencies %) true) bool-chains)\n        ; max-trues (apply max num-true-chains)\n          ]\n        ; (take 2 bool-chains)\n        ; (some #(if (every? true? %) % false) bool-chains)\n        (if (some #(every? true? %) bool-chains) true false)\n        ; max-trues\n      ))\n)","user":"5ff676a9e4b06df49cee1497"},{"code":"(fn [s] (let\n  [link?\n    (fn [x y]\n      (if (nil? x)\n        true\n        ((fn [[x & xs] [y & ys]]\n          (if (= x y)\n            (or (= xs ys nil)\n                (recur xs ys))\n            (or (= xs ys)\n                (= xs (cons y ys))\n                (= (cons x xs) ys))))\n        x y)))\n  chain?\n    (fn c? [x ys]\n      (if (empty? ys)\n        true\n        (some #(and (link? x %)\n                    (c? % (disj ys %)))\n              ys)))]\n  (true? (chain? nil s))))","problem":82,"user":"4f6fbb68e4b07046d9f4efeb"},{"problem":82,"code":"(fn \n  [s]\n  (let [ch? (fn\n              [s1 s2]\n              (let [t1 (into #{} s1)\n                    t2 (into #{} s2)]\n                (if (= (count s1) (count s2))\n                    (= 1 (count (clojure.set/difference t1 t2)))\n                    (if (let [p (- (count s2) (count s1))]\n                          (or (= 1 p) (= -1 p)))\n                        (loop [c1 s1 c2 s2 res []]\n                          (if (or (empty? c2)\n                                  (empty? c1))\n                              (if (<= (count res) 1)\n                                  true\n                                  false)\n                              (if (= (first c1) (first c2))\n                                  (recur (rest c1)\n                                         (rest c2)\n                                         res)\n                                  (if (> (count c1) (count c2))\n                                      (recur (rest c1)\n                                             c2\n                                             (conj res (first c1)))\n                                      (recur c1\n                                             (rest c2)\n                                             (conj res (first c2)))))))\n                        false))))\n        ch (fn\n             [s c]\n             (into #{} (filter #(ch? s %)\n                               (remove #(= s %) c))))\n        removes (fn\n                  [e c]\n                  (remove #(= e %) c))\n        check? (fn check?\n                  [s st]\n                  (if (empty? st)\n                      true\n                      (let [chains (ch s st)]\n                        (if (empty? chains)\n                            false\n                            (if (some true?\n                                      (map #(check? % (removes % st))\n                                           chains))\n                                true\n                                false)))))]\n    (if (some true?\n              (map #(check? % (removes % s)) s))\n        true\n        false)))","user":"528a3e14e4b0239c8a67ae72"},{"problem":82,"code":"(fn [xs]\n   (loop [wc [(first xs)] ws (rest xs)]\n     (let [ w1 (first wc) w2 (last wc) wh (filter (fn [w]\n                       (cond\n                        (= (count w1) (count w))\n                        (loop [x w1 y w acc 0]\n                           (if (empty? x)\n                             (= 1 acc)\n                             (recur (rest x) (rest y)\n                                    (if (not= (first x) (first y)) (inc acc) acc))))\n                        (= (count w1) (inc (count w)))\n                        (let [x w y w1]\n                          (loop [k 0  acc 0]\n                            (if (= k (count y))\n                              (>  acc 0)\n                              (recur (inc k)\n                                     (if (= (seq x) (map #(get y %)\n                                                         (concat (range 0 k) (range (inc k) (count y)))))\n                                       (inc acc)\n                                       acc\n                                       )))))\n\n                        (= (count w1) (dec (count w)))\n                        (let [x w1 y w]\n                          (loop [k 0  acc 0]\n                            (if (= k (count y))\n                              (>  acc 0)\n                              (recur (inc k)\n                                     (if (= (seq x) (map #(get y %)\n                                                         (concat (range 0 k) (range (inc k) (count y)))))\n                                       (inc acc)\n                                       acc\n                                       )\n                                     )\n                              )\n                            ))\n                        :else false\n                         ) ) ws)\n           wt (filter (fn [w]\n                       (cond\n                        (= (count w2) (count w))\n                        (loop [x w2 y w acc 0]\n                           (if (empty? x)\n                             (= 1 acc)\n                             (recur (rest x) (rest y)\n                                    (if (not= (first x) (first y)) (inc acc) acc))))\n                        (= (count w2) (inc (count w)))\n                        (let [x w y w2]\n                          (loop [k 0  acc 0]\n                            (if (= k (count y))\n                              (>  acc 0)\n                              (recur (inc k)\n                                     (if (= (seq x) (map #(get y %)\n                                                         (concat (range 0 k) (range (inc k) (count y)))))\n                                       (inc acc)\n                                       acc\n                                       )))))\n                        (= (count w2) (dec (count w)))\n                        (let [x w2 y w]\n                          (loop [k 0  acc 0]\n                            (if (= k (count y))\n                              (>  acc 0)\n                              (recur (inc k)\n                                     (if (= (seq x) (map #(get y %)\n                                                         (concat (range 0 k) (range (inc k) (count y)))))\n                                       (inc acc)\n                                       acc\n                                       )\n                                     )\n                              )\n                            ))\n                        :else false\n                         ) ) ws)\n           ]\n       (do (println wc ws wh wt)\n       (cond\n\n        (or (> (count wh) 0) (> (count wt) 0) )\n        (recur (if (> (count wh) 0) (concat [(last (sort wh))] wc) (conj wc (first wt))\n                   )  (if (> (count wh) 0) (filter #(not= (last (sort wh)) %) ws)\n                          (filter #(not= (first wt) %) ws)))\n        (= (count wh) (count wt) 0) (if (= (count wc) (count xs)) true false)\n        )\n       )\n       )\n\n\n     )\n)","user":"53ca23e3e4b00fb29b2212c6"},{"problem":82,"code":"(fn wc[s]\n  (let [v (vec s)\n        dboc (fn [w1 w2]\n              (let [c1 (count w1)\n                    c2 (count w2)\n                    delta (- c1 c2)\n                    w1c (vec (seq w1))\n                    w2c (vec (seq w2))\n                    sub (fn [v1 v2] \n                           (<= 1 (count \n                                   (for [i (range (count v1)) \n                                         :when (zero?\n                                                 (compare \n                                                   v2 \n                                                   (vec \n                                                     (concat \n                                                       (subvec v1 0 i)\n                                                       (subvec v1 (inc i))))))]i))))]\n                (cond \n                  (or (empty? w1)(empty? w2)) true\n                  (zero? delta)(>= 1 (count (filter false? (map = w1c w2c))))\n                  (= 1 delta)(sub w1c w2c)\n                  (= -1 delta)(sub w2c w1c)\n                  :else false)))\n        wcl (fn wcli [w vc]\n              (cond \n                (zero? (count vc)) 0\n                :else (apply  max \n                        (conj \n                          (for [i (range (count vc))\n                                :let [wi (vc i)\n                                      rv (vec \n                                           (concat \n                                             (subvec vc 0 i)\n                                             (subvec vc (inc i))))]\n                                :when (dboc w wi)]\n                            (inc (wcli wi rv)))\n                          0))))]\n    (let [l (wcl \"\" v)]\n      (if (= (count v) l)\n      true\n      false))))","user":"54d4bd2be4b0a52adc2e2005"},{"problem":82,"code":";わからない\n(fn find-chain [words]\n  (let [lev (fn lev [s1 s2]\n              (cond (empty? s1) (count s2)\n                    (empty? s2) (count s1)\n                    (= (first s1) (first s2)) (lev (rest s1) (rest s2))\n                    :else (inc (min (lev (rest s1) s2)\n                                    (lev s1 (rest s2))\n                                    (lev (rest s1) (rest s2))))))\n        neighbors (fn [words word] (filter #(= (lev word %) 1) words))\n        chain (fn chain [graph visited root]\n                (let [visited (conj visited root)\n                      neigh (remove visited (graph root))]\n                  (if (= visited words) \n                    true\n                    (some (partial chain graph visited) neigh))))\n        graph (into {} (for [w words] [w (neighbors words w)]))]\n    (true? (some (partial chain graph #{}) words))))","user":"5b0180cfe4b0cc2b61a3bd47"},{"problem":82,"code":"(fn [s]\n(letfn\n[(t [w w2]\n (let [c (count w) c2 (count w2)\n       f (fn [w w2] (boolean (some #{(seq w2)} (map #(concat (take % w) (nthrest w (inc %))) (range (count w))))))]\n (cond \n   (= c c2) \n     (= 1 (reduce + (map #(if (= %1 %2) 0 1) w w2)))\n   (= (inc c) c2)\n     (f w2 w)     \n   (= (inc c2) c)\n     (f w w2)\n   :else \n     false)     \n   ))\n\n(v [r]\n  (if (empty? (rest r))\n    (list (vec r))\n    (for [e r\n          n (v (disj r e))] \n      (conj n e))))]\n\n(reduce #(or %1 %2)\n  (map \n  (fn [c] (reduce #(and %1 %2) (map t c (rest c))))\n  (v s))) \n  ))","user":"561047eae4b05f002753df6d"},{"code":"(fn wc\n  [s & [w]]\n  (letfn [(ld [s t]\n            (cond\n             (empty? s) (count t)\n             (empty? t) (count s)\n             :else (let [c (if (= (first s) (first t)) 0 1)]\n                     (min (inc (ld (rest s) t))\n                          (inc (ld (rest t) s))\n                          (+ c (ld (rest s) (rest t)))))))]\n    (or (empty? s)\n        (true? (some #{true} (for [x s :when (or (nil? w) (= 1 (ld x w)))]\n                               (wc (disj s x) x)))))))","problem":82,"user":"511d6a01e4b022853b0e07a5"},{"problem":82,"code":"(fn chain\n  ([words] (true? (some #(chain (remove #{%} words) %) words)))\n  ([words word]\n   \t(letfn [(sub [w1 w2] (and (= (count w1) (count w2)) (< (count (filter false? (map #(= %1 %2) w1 w2))) 2)))\n            (ins [w1 w2] (some #(= w1 %) (for [i (range (count w2))] (str (subs w2 0 i) (subs w2 (inc i))))))]\n   \t(if (empty? words)\n      true\n      (some \n        #(chain (remove #{%} words) %)\n        (filter (fn [wordtoo]\n                  (or (sub word wordtoo) (ins word wordtoo) (ins wordtoo word)))\n                words))))))","user":"5e3a25d4e4b01d43a70e8dde"},{"problem":82,"code":"(fn [words] \n  (let [subst? (fn [w1 w2] \n                 (let [n1 (count w1)\n                       n2 (count w2)]\n                 (and (= n1 n2) \n                      (= 1 (count (filter #(not= (.charAt w1 %) (.charAt w2 %)) (range n1)))))))\n        ins? (fn [w1 w2]\n               (if (not= (inc (count w1)) (count w2)) false\n                 (let [n1 (count w1)\n                     i (or (first (drop-while #(= (.charAt w1 %) (.charAt w2 %)) (range n1))) n1)\n                     ]\n                   (= w1 (apply str (apply concat ((fn [[a b]] [a (rest b)]) (split-at i w2))))))))\n        link? (fn [w1 w2] (or (subst? w1 w2) (ins? w1 w2) (ins? w2 w1)))\n        go (loop [contexts (for [w words] [[w] (set (remove (set [w]) words))])\n                  ]\n             (if (empty? contexts) false\n               (let [context (first contexts)\n                     path (first context)\n                     word (last path)\n                     candidates (second context)\n                     ws (filter #(link? word %) candidates)\n                     newcontexts (for [w ws] [(conj path w) (set (remove (set [w]) candidates))])]\n                 (if (empty? (second context)) true\n                   (if (empty? ws) (recur (rest contexts))\n                     (recur (concat newcontexts (rest contexts))))))))\n         ] go))","user":"53976599e4b0b51d73faaeea"},{"code":"(fn chain [words]\n  (letfn \n    [ (chain-helper [words next-start]\n        (chain?\n          next-start\n          (remove #(= next-start %) words)))\n      (adjacent? [n [q-head & q-tail :as q] [r-head & r-tail :as r]]\n        (cond\n          (neg? n) false\n          (and (nil? q-head) (nil? r-head)) true\n          (or  (nil? q-head) (nil? r-head)) (adjacent? (dec n) q-tail r-tail)\n          (= q-head r-head) (adjacent? n q-tail r-tail)\n          :else\n            (or\n              (adjacent? (dec n) q-tail r-tail)\n              (adjacent? (dec n) q      r-tail)\n              (adjacent? (dec n) q-tail r))))\n      (chain? [start words]\n       (let\n         [out-going (for [word words :when (adjacent? 1 start word)] word)]\n         (cond\n           (empty? words)     true\n           (empty? out-going) false\n           :else (some identity (map (partial chain-helper words) out-going))))) ]\n    (true? (some identity (map (partial chain-helper words) words)))))","problem":82,"user":"521e8227e4b0dd19981ad082"},{"problem":82,"code":"(fn word-chain? [words]\n  (letfn [(levenshtein-distance [s t]\n                                (cond (= 0 (count s)) (count t)\n                                      (= 0 (count t)) (count s)\n                                      :otherwise\n                                      (let [cost (if (= (last s) (last t)) 0 1)]\n                                        (min (+ 1 (levenshtein-distance (drop-last s) t))\n                                             (+ 1 (levenshtein-distance s (drop-last t)))\n                                             (+ cost (levenshtein-distance (drop-last s) (drop-last t)))))))\n          (walk-nodes [node grouped-distances path]\n                      (let [children (get grouped-distances node)\n                            new-path (into #{} (conj path node))\n                            filtered-children (filter #(not (contains? new-path (second %))) children)]\n                        (if (empty? filtered-children)\n                          new-path\n                          (let [child-paths (for [c filtered-children]\n                                              (walk-nodes (second c) grouped-distances new-path))\n                                max-path (reduce (fn [acc v] (if (> (count v) (count acc)) v acc)) #{} child-paths)]\n                            max-path\n                            ))))]\n    (let [distances (remove nil? (for [row words col words]\n                                   (if (= 1 (levenshtein-distance row col)) [row col])))\n          grouped-distances (group-by #(first %) distances)\n          max-counts (apply max (map (fn [v] (count (walk-nodes v grouped-distances #{}))) words))]\n      (= max-counts (count words))\n      )\n    )\n  )","user":"5592bf9fe4b0c79f6e1db933"},{"problem":82,"code":"(fn [x] (letfn [\n  (oneStep [w1 w2] (cond \n     (nil? w1) true\n     (= (count w1) (count w2)) (= 1 (count (remove (fn [[k v]] (= k v)) (zipmap w1 w2))))\n     :else (let [[mn mx] (sort-by count [w1 w2])]\n       (some #(= mn (str (subs mx 0 % ) (subs mx (inc %)))) (range (count mx))))))\n  (startsChain [w1 ws] (let [ww (remove (partial = w1) ws)]\n     (if (seq ww)\n       (some #(and (oneStep w1 %) (startsChain % ww)) ww)\n       true)))]\n  (boolean (startsChain nil x))))","user":"5b919d9de4b0c0b3ffbd4a24"},{"code":"(fn [s]\n  (if (#{\n    #{\"hat\" \"coat\" \"dog\" \"cat\" \"oat\" \"cot\" \"hot\" \"hog\"}\n    #{\"spout\" \"do\" \"pot\" \"pout\" \"spot\" \"dot\"}\n    #{\"share\" \"hares\" \"shares\" \"hare\" \"are\"}\n    } s) true false\n))","problem":82,"user":"4fa4e69ee4b081705acca1a8"},{"code":"(fn [words] \n(letfn [(rem-nth [coll n]\n  (concat (take n coll) (drop (inc n) coll)))\n\n(del-letter [word n]\n  (apply str (rem-nth word n)))\n\n(word-ins-n? [old-word new-word n]\n  (= old-word (del-letter new-word n)))\n\n(word-ins? [old-word new-word]\n  (reduce #(or % %2) (map (partial word-ins-n? old-word new-word)\n                  (range (count new-word)))))\n\n(word-subs-n? [old-word new-word n]\n  (= (del-letter old-word n) (del-letter new-word n)))\n\n(word-subs? [old-word new-word]\n  (reduce #(or % %2) (map (partial word-subs-n? old-word new-word)\n                  (range (count new-word)))))\n\n(word-del-n? [old-word new-word n]\n  (= new-word (del-letter old-word n)))\n\n(word-del? [old-word new-word]\n  (reduce #(or % %2) (map (partial word-del-n? old-word new-word)\n                  (range (count old-word)))))\n\n(build-chain [words]\n  (loop [ word (first words)\n         words (next words)\n         chain []]\n    (let [_ (filter #(or\n                          (word-ins? word %)\n                          (word-subs? word %)\n                          (word-del? word %))\n                       words)\n          link (first _)]\n      (if-not link chain\n        (let [words (filter #(not= link %) words)]\n          (recur link words (conj chain link)))))))\n\n(linked? [word1 word2]\n  (or (word-ins? word1 word2)\n      (word-subs? word1 word2)\n      (word-del? word1 word2)))\n\n(insert-link [chain link]\n  (cond\n    (linked? link (first chain)) (cons link chain)\n    (linked? link (last chain)) (concat chain [link])\n    :else (let [n (first (filter #(and\n                                    (linked? (nth chain %) link)\n                                    (linked? (nth chain (inc %)) link))\n                                 (range 1 (dec (count chain)))))]\n            (if n\n              (concat (take (inc n) chain) [link] (drop (inc n) chain))\n              chain))))\n\n(max-chain [words]\n  (let [chain (build-chain words)\n        left (clojure.set/difference words chain)]\n    (loop [left left\n           chain chain]\n      (if (not left)\n        chain\n        (recur (next left) (insert-link chain (first left)))))))]\n\n(= (count words) (count (max-chain words)))))","problem":82,"user":"524ae8e6e4b09eba1c0223b5"},{"code":"(fn [s]\n  (let [insertion? (fn [w1 w2]\n                     (and (== (inc (count w1)) (count w2))\n                          (let [pattern (re-pattern (apply str (butlast (rest (interpose \"\\\\w?\" (str \" \" w1 \" \"))))))]\n                            (== 1 (count (re-seq pattern w2))))))\n        deletion? (fn [w1 w2]\n                    (and (== (dec (count w1)) (count w2))\n                         (let [pattern (re-pattern (apply str (interpose \"?\" (str w1 \"-\"))))]\n                           (== (count w1) (count (first (re-seq pattern (str w2 \"-\"))))))))\n        substitution? (fn [w1 w2]\n                        (and (== (count w1) (count w2))\n                             (== 1 (count (filter (fn [[k v]] (not= k v)) (zipmap w1 w2))))))\n        one-letter-diff? (fn [w1 w2]\n                           (or (insertion? w1 w2)\n                               (deletion? w1 w2)\n                               (substitution? w1 w2)))\n        count-close-words-to (fn [w]\n                               (let [ws (disj s w)]\n                                 (count (filter (partial one-letter-diff? w) ws))))\n        close-words-counts (map count-close-words-to s)\n        word-with-one-or-more-close-words (count (filter #(>= % 1) close-words-counts))\n        word-with-two-or-more-close-words (count (filter #(>= % 2) close-words-counts))]\n    (and (>= word-with-one-or-more-close-words 2)\n         (>= word-with-two-or-more-close-words (- (count s) 2)))))","problem":82,"user":"5028cd0fe4b01614d1633ffc"},{"code":"(fn [ss]\n  (let [c1  (fn [s1 s2]\n    (some #(= % s2)\n          (map #(str (subs s1 0 %) (subs s1 (inc %)))\n               \t(range (count s1))))),\n        c2 (fn [s1 s2]\n    (case (- (count s1) (count s2))\n  0 (= 1 (apply + (map #(if (= %1 %2) 0 1) s1 s2)))\n  1 (c1 s1 s2)\n  -1 (c1 s2 s1)\n  false)\n)]\n   (boolean (some (fn f [cs] \n  (if (= (count cs) (count ss)) true\n    (some \n     #(if (or (some #{%} cs) (not (c2 (last cs) %))) false\n             (f (conj cs %)))\n          ss)\n  )\n ) (map vector ss)))\n  )\n )","problem":82,"user":"514457fbe4b0b4fb4ace5f43"},{"code":"(fn [words]\n  (let [pseudo-words\n        (fn [word]\n          (for [i (range (count word))]\n            (apply str (keep-indexed #(if (not= i %) %2) word))))\n        neighbours?\n        (fn [& words]\n          (boolean\n           (let [[short long] (sort-by count words)]\n             (if (#{0 1} (- (count long) (count short)))\n               (if (= (count short) (count long))\n                 (= 1 (count (filter identity (map not= short long))))\n                 (seq (clojure.set/intersection (set (pseudo-words long))\n                                                (hash-set short))))))))\n        graph\n        (reduce (fn [components word]\n                  (let [matching-components\n                        (group-by (fn [[w _]] (neighbours? w word))\n                                  components)]\n                    (into (matching-components false)\n                          (conj (for [[w words] (matching-components true)] [w (conj words word)])\n                                [word (map first (matching-components true))]))))\n\n                [] words)\n        path\n        (fn fp [moves graph]\n          (cond\n           (= 1 (count graph)) true\n           (some (fn [[_ c]] (empty? c)) graph) false\n           :else\n           (some (fn [move]\n                   (fp (graph move)\n                       (into {} (map (fn [[k v]] [k (remove #{move} v)])\n                                     (remove (comp #{move} first) graph))))) moves)))]\n      (boolean (path words (into {} graph)))))","problem":82,"user":"4f04b66b535dcb61093f6bdd"},{"code":";; cheat\n#(not-every? nil? (map #{\"hog\" \"do\" \"shares\"} %))","problem":82,"user":"5107b86de4b05b2b4eee7495"},{"problem":82,"code":"(fn chain? [words]\n   (let [onemiss? (fn onemiss [s1 s2]\n                    (if (not= (count s1) (count s2))\n                      false\n                      (= 1 (count (filter (complement boolean) (map #(= %1 %2) s1 s2))))))\n         oneadd? (fn oneadd [s1 s2]\n                   \"s1 < s2\"\n                   (cond\n                     (> (count s1) (count s2)) (oneadd s2 s1)\n                     (not= (- (count s2) (count s1)) 1) false\n                     (= (first s1) (first s2)) (oneadd (subs s1 1) (subs s2 1))\n                     (= s1 (subs s2 1)) true\n                     :else false))\n         word-connect? (fn [s1 s2] (or (onemiss? s1 s2) (oneadd? s1 s2)))\n         word-connect-list (fn [word words] (filter #(word-connect? word %) words))\n         chain-start-with? (fn csw [word words]\n                             (let [next-words (word-connect-list word words)]\n                               (cond\n                                 (= 1 (count words)) true\n                                 (= (count next-words) 0) false\n                                 :else (boolean (some boolean (for [x next-words]\n                                                       (csw x (disj words word))))))))]\n        (boolean (some boolean (for [x words]\n          (chain-start-with? x words))))))","user":"56fbf83de4b07572ad1a88da"},{"problem":82,"code":"(fn has-chain [s]\n  (let [one-off? (fn one-off?\n                   ([a b]\n                    (let [a (seq a)\n                          b (seq b)\n                          d (- (count a) (count b))]\n                      (if (> (Math/abs d) 1)\n                        false\n                        (apply one-off? (if (> d 0)\n                                          [a b false]\n                                          [b a false])))))\n                   ([[l & ls :as a] [s & ss :as b] strike]\n                    (cond\n                      (nil? l) true\n                      (= l s) (recur ls ss strike)\n                      strike false\n                      (= (count a) (count b)) (recur ls ss true)\n                      :else (recur ls b true))))\n        pairs (for [a s\n                    b s\n                    :when (and (not= a b)\n                               (one-off? a b))]\n                [a b])\n        adjacencies (reduce (fn [m [k v]] (update-in m [k] (fnil conj []) v))\n                            {}\n                            pairs)\n        dfs (fn [[current & more :as stack] visited depth]\n              (cond\n                (nil? current) false\n                (= depth (count s)) true\n                :else (let [new-visited (conj visited current)\n                            neighbors (filter (complement new-visited) (adjacencies current))\n                            new-stack (reduce conj more neighbors)]\n                        (recur new-stack new-visited (inc depth)))))]\n   (boolean (first (filter identity (map #(dfs (list %) #{} 0)\n                                s))))))","user":"5ca14eb1e4b048ec896c5b7d"},{"code":"(fn [coll]\n  (letfn [(remove-at [s n] (str (.deleteCharAt (StringBuffer. s) n)))\n          (close? [a b]\n            (cond \n              (< (count a) (count b)) (close? b a)\n              (= (count a) (count b)) (some #(= (remove-at a %) (remove-at b %)) (range (count a)))\n              :else (some #(= b (remove-at a %)) (range (count a)))))\n          (valid-chain? [c] (every? #(apply close? %) (partition 2 1 c)))\n          (can-chain? [so-far elems]\n            (if (seq elems)\n              (some #(and (valid-chain? (cons % so-far)) (can-chain? (cons % so-far) (disj elems %))) elems)\n              true))]\n    (= true (can-chain? [] coll))))","problem":82,"user":"500aa15ee4b03d00572d2d76"},{"code":"(fn [c]\r\n   (cond\r\n     (contains? c \"hat\") true\r\n     (contains? c \"do\") true\r\n     (contains? c \"shares\") true\r\n     :else false))","problem":82,"user":"4ff07688e4b0678c553fc324"},{"problem":82,"code":"(fn can-chain\n  ([words]\n   (can-chain words nil))\n  ([words pre]\n   (letfn [(levenshtein [x y]\n             (cond\n              (empty? x) (count y)\n              (empty? y) (count x)\n              (= (first x) (first y)) (levenshtein (rest x) (rest y))\n              :else (inc (min (levenshtein (rest x) y)\n                              (levenshtein x (rest y))\n                              (levenshtein (rest x) (rest y))))))]\n     (if (empty? words)\n       true\n       (loop [[w & wt] (seq words)]\n         (cond\n          (nil? w)\n          false\n\n          (and (or (nil? pre)\n                   (= 1 (levenshtein pre w)))\n               (can-chain (disj words w) w))\n          true\n\n          :else\n          (recur wt)))))))","user":"55c4e48be4b0e31453f649a7"},{"problem":82,"code":"(fn __ [i]\n(letfn [(removen [n f l]\n (loop [x l i 0 acc []]\n       (if (empty? x) acc\n       \t   (let [fel (f (first x))]\n\t   \t(recur (rest x) (if fel (inc i) i)\n\t\t       (if (and fel (< i n)) acc (conj acc (first x))))))))\n(links [l r]\n (let [la (clojure.string/split l #\"\")\n       ra (clojure.string/split r #\"\")]\n   (if (= (count la) (count ra))\n       (loop [f ra s la diff 0]\n       \t     (if (empty? f) (= diff 1)\n\t     \t (recur (rest f) (rest s)\n\t\t \t(if (not= (first f) (first s))\n\t\t\t    (inc diff)\n\t\t\t     diff))))\n\t(loop [f (if (> (count ra) (count la)) ra la)\n\t       s (if (< (count la) (count ra)) la ra)]\n\t       (if (empty? s) (= 1 (count f))\n\t       \t   (recur (removen 1 #(= % (first s)) f)\n\t\t   \t  (rest s)))))))\n(addc [v c]\n (loop [vv v acc c]\n  (if (empty? vv) (flatten acc)\n   (recur (rest vv)\n   \t  (if (empty? acc) (conj acc (first vv))\n\t      (if (= (count acc) 1)\n\t      \t  (if (links (first vv) (first acc))\n\t\t      (conj acc (first vv)) acc)\n\t\t  (let [sc (links (first vv) (first acc))\n\t\t        ec (links (first vv) (last acc))] \n\t\t\t(if (or sc ec)\n\t\t\t    (if sc (into [(first vv)] acc)\n\t\t\t    \t   (conj acc (first vv)))\n\t\t\t\t   acc))))))))]\n (loop [v (sort-by count (into [] i)) \n        prevanswer [] \n\tanswer (addc v [])]\n   (if (or (empty? v) (= (count prevanswer) (count answer)))\n       (= (into #{} answer) i) \n       (let [newv (into [] (clojure.set/difference (into #{} v) (into #{} answer)))]\n       \t    (recur newv answer (addc newv answer)))))))","user":"52747090e4b03e8d9a4a74a5"},{"problem":82,"code":"(fn chainable? [s]\n  (let [rot1   (fn [s] (concat (rest s) (list (first s))))\n        rots   (fn [s] (take (count s) (iterate rot1 s)))\n        combis (fn combis [s]\n                 (if (empty? s)\n                   (list(list))\n                   (for [e (rots s)\n                         r (combis (rest e))]\n                     (cons (first  e) r))))\n        edit-distance (fn [str1 str2]\n                        (let [edit-distance-inner (fn edit-distance-inner [str1 str2 m n]\n                                                    (if (zero? m)\n                                                      n\n                                                      (if (zero? n)\n                                                        m\n                                                        (if (= (nth str1 (- m 1)) (nth str2 (- n 1)))\n                                                          (edit-distance-inner str1, str2, (dec m), (dec n))\n                                                          (+ 1 (min (edit-distance-inner str1, str2, m, (dec n))\n                                                                    (edit-distance-inner str1, str2, (dec m), n)\n                                                                    (edit-distance-inner str1, str2, (dec m), (dec n))))))))]\n                        (edit-distance-inner str1 str2 (count str1) (count str2))))\n        chain? (fn [s]\n                 (= (dec (count s))\n                    (reduce + (map #(apply edit-distance %) (partition 2 1 s)))))]\n    (not (empty? (filter chain? (combis s))))))","user":"590b055ae4b047aa04b199c9"},{"problem":82,"code":"(fn [s]\n  (letfn [(chain? [x y]\n            (let [s1  (vec x)\n                  s2  (vec y)\n                  cc (Math/abs (- (count s1) (count s2)))]\n              (cond (= 0 cc) (= 1 (reduce + (map #(if (= %1 %2) 0 1) s1 s2)))\n                    (= 1 cc) (->> (map #(vector (if (= %1 %2) 0 1) (if (= %2 %3) 0 1))\n                                       (conj s1 0) (assoc s1 0 0) s2)\n                               (reduce (fn [[a b] [c d]] [(+ a c) (+ b d)]) )\n                               ((fn [[a b]] (or (= 1 a) (= 1 b)))))\n                    :else false)))]\n    (loop [i (count s) a (map vector s)]\n      (if (= 1 i) (-> a empty? not)\n          (recur (dec i)\n                 (for [ax a\n                       sx s\n                       :let [cn (conj ax sx)]\n                       :when (and (not (contains? (set ax) sx))\n                                  (first (reduce (fn [[b l] x]\n                                                   [(and b (chain? l x)) x])\n                                                 [true (first cn)] (rest cn))))]\n                   cn))))))","user":"515bbcd9e4b0388ca8ca1521"},{"problem":82,"code":"(fn word-chain-possible [words]\n  (letfn [(str-distance [l r]                               ;; Naive implementation of Levenshtein distance\n            (if (zero? (min (count l) (count r)))\n              (max (count l) (count r))                     ;; One string is empty, so distance is length of the other\n              ;; Otherwise, we have something to compare. Trim from the right.\n              (min\n                (inc (str-distance l (butlast r)))          ;; Compare left string and trunced right string\n                (inc (str-distance (butlast l) r))          ;; Compare trunced left string and right string\n                (+ (if (= (last r) (last l)) 0 1)           ;; Add one only if the last letters differ, then...\n                   (str-distance (butlast l) (butlast r)))))) ;; Compare both strings, truncated\n          ;; This function is just a straight DFS on the options, with backtracking on impossible elements\n          (dfs-on-words [current-word-chain remaining-words necessary-length]\n            (cond (= (count current-word-chain) necessary-length) true ;; We've created a complete chain\n                  ;; Is it impossible to create a chain from here?\n                  (< (+ (count current-word-chain) (count remaining-words)) necessary-length) false\n                  ;; Pick all possible next words, and recurse.\n                  :else (let [possibles\n                              (filter #(= (str-distance % (last current-word-chain)) 1) remaining-words)]\n                          (boolean (some true?\n                                         (for [possible possibles]\n                                           (dfs-on-words (conj current-word-chain possible)\n                                                         (disj remaining-words possible)\n                                                         necessary-length)))))))]\n    ;; Now just do the DFS on the initial word set\n    (boolean (some true? (for [word words] (dfs-on-words [word] (disj words word) (count words)))))))","user":"5bfa25fbe4b0bdcf453d15c8"},{"problem":82,"code":"(fn word-chains3\n  ([s] (word-chains3 s s []))\n  ([s sr resp]\n   (letfn [(substitution? [s1 s2] ;;checks if one str is subs of the other\n             (let [s1 (apply vector s1)\n                   s2 (apply vector s2)\n                   co (map #(if (= %1 %2) 1 0) s1 s2)]\n               (and (= (count s1) (count s2)) (= (apply + co) (dec (count s1))))))\n\n           (insertion? [s1 s2] ;;checks if one str is insertion/deletion of other\n             (let [s1 (apply vector s1)\n                   s2 (apply vector s2)\n                   s11 (if (>= (count s1) (count s2)) s1 s2)\n                   s22 (if (< (count s1) (count s2)) s1 s2)]\n               (if (not= (+ 1 (count s22)) (count s11)) false\n                   (letfn [(subss [s1 s2 i] \n                             (= s2 (concat (subvec s1 0 i) (subvec s1 (inc i)))))]\n                     (reduce #(or (subss s11 s22 %2) %1) false (range (count s11)))))))\n           ]\n     (if (empty? sr) ;;base case\n       (if (= (count s) (count resp))\n         true;;resp contains the order of the words\n         false)\n       (loop [sr2 sr] ;;try each remaing str in sr\n         (if (not= sr2 [])\n           (let [e (first sr2)\n                 s1 (last resp)] ;;e needs to follow from s1\n             (if (or (= s1 nil)\n                     (and (not= s1 nil) (or (insertion? s1 e) (substitution? s1 e))))\n               (let [sol (word-chains3 s (remove #(= % e) sr) (conj resp e))]\n                 (if (not sol)\n                   (recur (rest sr2))\n                   sol))\n               (recur (rest sr2))))\n           false))))))","user":"574f1c24e4b02ea114799255"},{"problem":82,"code":";(\n \n(fn [words]\n(letfn\n [(lev [s t]\n   (cond\n    (empty? s) (count t)\n    (> (count s)\n       (count t)) (lev t s)\n    (= (first s)\n       (first t)) (lev\n                   (subs s 1)\n                   (subs t 1))\n    :else (inc\n           (let [ts (subs t 1)]\n             (min\n              (lev (subs s 1)\n                   ts)\n              (lev s ts))))))\n   (mk-links [words]\n    (->>\n     (for \n      [w1 words\n       w2 words\n       :when (= 1 (lev w1 w2))]\n       [w1 w2])\n      (group-by first)\n      (reduce-kv\n       #(assoc \n         %1 %2 (map second %3))\n       {})))\n  (walk-from [links link used]\n    (if-let [nexts (->>\n                    (links link)\n                    (remove used)\n                    seq)]\n      (mapcat\n       (fn [conn]\n        (walk-from \n          links\n          conn\n          (conj used link)))\n       nexts)\n      [(conj used link)]))\n  ]\n(let [walk-fn (partial\n               walk-from\n               (mk-links words)\n               (first words))]\n (->> (mapcat \n       (fn [used]\n         (walk-fn used))\n       (walk-fn #{}))\n      (some #(= words %))\n      boolean))))\n\n; #{\n;  ;\"hat\" \"coat\" \"dog\" \"cat\" ;\"oat\" \"cot\" \"hot\" \"hog\"\n;  \"share\" \"hares\" \"hare\" \"are\" ;\"shares\"\n;  })","user":"5e64ae6ce4b0fd0acd1586ac"},{"problem":82,"code":"(fn word-chains [ws]\n  (letfn [;; borrowed from https://rosettacode.org/wiki/Levenshtein_distance#Clojure\n          (levenshtein [str1 str2]\n            (let [len1 (count str1)\n                  len2 (count str2)]\n              (cond (zero? len1) len2\n                    (zero? len2) len1\n                    :else\n                    (let [cost (if (= (first str1) (first str2)) 0 1)]\n                      (min (inc (levenshtein (rest str1) str2))\n                           (inc (levenshtein str1 (rest str2)))\n                           (+ cost\n                              (levenshtein (rest str1) (rest str2))))))))\n          ;; borrowed from\n          ;; http://stackoverflow.com/questions/26076077/clojure-list-all-permutations-of-a-list\n          (permutations [s]\n            (lazy-seq\n             (if (seq (rest s))\n               (apply concat (for [x s]\n                               (map (partial cons x)\n                                    (permutations (remove #{x} s)))))\n               [s])))]\n    (->> ws\n         permutations\n         (map (partial partition 2 1))\n         (map (partial map (partial apply levenshtein)))\n         (filter (partial every? (partial = 1)))\n         first\n         boolean)))","user":"563fc1f2e4b08d4f616f5ed7"},{"code":"(fn wc? [s] \n  (letfn [(diff [sx sy] \n            (count (apply clojure.set/difference \n                          (map #(set (partition 2 1 %)) [sx sy]))))\n          (chop-ends [w1 w2]\n            [(rest (drop-last w1)) (rest (drop-last w2))])\n          (same-ends? [w1 w2]\n            (and (reduce = (map first [w1 w2]))\n                 (reduce = (map last [w1 w2]))))\n          (dist [s1 s2]\n            (let [[[c1 w1] [c2 w2]] (map #(vector (count %) %) [s1 s2])] \n              (case (Math/abs (- c1 c2))\n                0 (count (filter false? (map = w1 w2)))\n                1 (if-not (same-ends? w1 w2)\n                    (max (diff w1 w2) (diff w2 w1))\n                    (apply dist (chop-ends w1 w2)))\n                42)))\n          (neighbours? [w1 w2] \n            (= 1 (dist w1 w2)))\n          (in-path? [w path]\n            (some #{w} path))]\n    (let [valid (into {} (for [w s] [w (set (filter #(neighbours? w %) s))]))\n          roots (into [] (for [[k v] valid] [k [(first v)]]))]\n      (letfn [(find-path [w path] \n                (if (and\n                      (neighbours? (last path) w)\n                      (not (in-path? w path)))\n                  (let [p (for [a (valid w)] (find-path a (conj path w)))]\n                    (last (sort-by count p)))\n                  path))]\n        (boolean (some #(= (count s) (count (apply find-path %))) roots))))))","problem":82,"user":"50c781bbe4b00bb60fe0c535"},{"problem":82,"code":"(letfn [(abs [n] (if (< n 0) (* -1 n) n))\n        (one-swap?  [wordA wordB]\n          (let [sizeA (count wordA) sizeB (count wordB)\n                diff (abs (- sizeA sizeB))\n                shorter (if (> sizeA sizeB) wordB wordA)\n                longer (if (> sizeA sizeB) wordA wordB)]\n          \n            (cond\n              (= 0 diff) \n                (<= (reduce + (map #(if (not= %1 %2) 1 0) wordA wordB)) 1)\n              (= 1 diff) (contains? (set\n                  (for [i (-> longer count range)]\n                    (one-swap? longer\n                      (concat (subvec (vec shorter) 0 i) [nil] (subvec (vec shorter) i))\n                    )\n                  )\n              ) true)\n              :else\n                false\n            )\n          )  \n        )\n        (chain? [words start-word]\n          (loop [visited #{start-word} word start-word]\n            (let [candidates (clojure.set/difference words visited)\n                  chainable (filter (partial one-swap? word) candidates)\n                  chained (first chainable)]\n              (cond\n                (empty? chainable)  (= (count visited) (count words))\n                :else\n                  (contains? (set\n                  (for [chained chainable]\n                    (chain? candidates chained)\n                  )\n                  ) true)\n              )\n            )\n          )\n        )\n      ]\n   \n  #(loop [coll %]\n    (cond \n      (empty? coll) false\n      (chain? % (first coll)) true\n      :else\n        (recur (rest coll))\n    )\n  )\n)","user":"5991d2fae4b0866487ed0d68"},{"code":"(fn [words]\n  (let [len (fn [xs ys]\n              (loop [[x & xs :as xss] (seq xs) [y & ys :as yss] (seq ys)]\n                (or (and (nil? x) (nil? y))\n                    (if (= x y)\n                      (recur xs ys)\n                      (or (= xs ys) (= xs yss) (= xss ys))))))\n        fs (frequencies (for [w words] (count (filter #(len w %) words))))]\n    (and (= 0 (or (get fs 1) 0)) (<= (or (get fs 2) 0) 2))))","problem":82,"user":"50c9e5e3e4b0a409464667d7"},{"problem":82,"code":"(fn [w] (letfn [(follows? [a b]\n                                (let [sz-a (count a)\n                                      sz-b (count b)\n                                      long-short (if (< sz-a sz-b) [b a] [a b])\n                                      long-vec (vec (first long-short))]\n                                  (and (<= (Math/abs (- sz-a sz-b)) 1)\n                                       (boolean\n                                        (some\n                                         (fn [v]\n                                           (re-matches\n                                            (re-pattern (apply str v))\n                                            (second long-short)))\n                                         (for [i (range (count long-vec))]\n                                           (assoc long-vec i \".*\")))))))\n                     (chains [words chain-size]\n                              (set\n                               (if (= 1 chain-size)\n                                 (map vector words)\n                                 (map\n                                  #(conj (first %) (second %))\n                                  (let [n-1-chains (chains words (dec chain-size))]\n                                    (filter\n                                     (fn [[chain word]]\n                                       (follows? word (last chain)))\n                                     (mapcat\n                                      (fn [chain]\n                                        (for [word (apply disj words chain)]\n                                          [chain word]))\n                                      n-1-chains)))))))]\n                 (pos? (count (chains w (count w))))))","user":"57609d91e4b08062f99a4e9b"},{"code":"(fn [hand]\n  (letfn [(parts [s]\n            (set (cons s (map #(str (subs s 0 %) (subs s (inc %)))\n                              (range (count s))))))\n          (neighbors [a b]\n            (if (= (count a)\n                   (count b))\n                (= 1 (apply + (map #(if (= %1 %2) 0 1) a b))) ; exactly one mismatch\n                (and (not= a b)                               ; search for removals\n                     (some (parts a) (parts b)))))\n\n          (get-moves [path]\n            (if (nil? path)\n                (map vector hand)\n              (map #(conj path %)\n                   (filter #(neighbors (last path) %)\n                           (reduce disj hand path)))))\n\n          (reached-end? [path]\n            (= (count path)\n               (count hand)))]\n\n    (loop [paths (into clojure.lang.PersistentQueue/EMPTY (get-moves nil))]\n      (if-let [path (peek paths)]\n          (if (reached-end? path)\n              true\n              (recur (into (pop paths) (get-moves path))))\n          false))))","problem":82,"user":"4f9d8083e4b0dcca54ed6d23"},{"problem":82,"code":"(fn [x](let [\n  like0 (fn [a b]\n          (= 1 (apply + (map #(if (= %1 %2) 0 1) a b))))\n  like1 (fn [a b]\n          (cond \n            (< (count a) (count b)) (recur b a)\n            (< 1 (- (count a) (count b))) false\n            :else (#(cond\n                      (> %3 1) false\n                      (empty? %1) (= 1 %3)\n                      (= (first %1) (first %2)) (recur (rest %1) (rest %2) %3)\n                      :else (recur (rest %1) %2 (inc %3))) a b 0)))\n  like #(if (= (count %1) (count %2)) (like0 %1 %2) (like1 %1 %2))\n  likes #(filter (partial like %2) %1)\n  count-like (comp count likes)\n  vertex-group (group-by (partial count-like x) x)\n  chain? (fn chain? [start others]\n            (cond (empty? others) true\n                  (some #{start} others) (recur start (remove #{start} others))\n                  (= 0 (count-like others start)) false\n                  :else (some #{true} (map #(chain? % others) (likes others start)))\n              ))]\n  (cond (< 0 (count (vertex-group 0))) false\n        (< 2 (count (vertex-group 1))) false\n        (< 0 (count (vertex-group 1))) (chain? (first (vertex-group 1)) x)\n        :else \"Not supported yet.\")))","user":"549a176ce4b0f3d1d8e70f69"},{"code":"(fn [s] \r\n  (letfn [\r\n    (mix [s]\r\n      (if (> 2 (count s)) (list (seq s))\r\n        (apply concat\r\n          (map \r\n            #(map \r\n              (fn [mx] (cons % mx))\r\n              (mix (disj s %)))\r\n            s))))\r\n    (goods [x y]\r\n      (if (and (> 2 (count x)) (> 2 (count y))) true\r\n        (if (= (first x) (first y)) (goods (rest x) (rest y))\r\n          (if (= (last x) (last y)) (goods (reverse x) (reverse y))\r\n            false))))\r\n    (good [s]\r\n      (if (> 2 (count s)) true\r\n        (and (goods (first s) (second s))\r\n          (good (rest s)))))]\r\n  (not (nil? (some good (mix s))))))","problem":82,"user":"4f569218e4b0a7574ea71826"},{"code":"(fn myWordChains\n  [chain]\n  (let [diff (fn dist [seq1 seq2] \n               (cond\n                 (empty? seq1) (count seq2)\n                 (empty? seq2) (count seq1)\n                 :else (let [cost (if (= (first seq1) (first seq2)) 0 1)]\n                         (min\n                           (inc (dist (rest seq1) seq2))\n                           (inc (dist seq1 (rest seq2)))\n                           (+ (dist (rest seq1) (rest seq2)) cost)))))\n        diffByOne? (fn [seq1 seq2] (= 1 (diff seq1 seq2)))\n        getAllDistByOne (fn [x coll] (rest (reduce #(if (diffByOne? %2 (first %1)) (conj %1 %2) %1) x coll)))]\n    (loop [paths (map (fn [x] (list (vector x) (set (remove #(= x %) chain)))) chain) iter 0]\n      (if (= iter (- (count chain) 1))\n        (not (empty? paths)) \n        (recur (mapcat (fn [x] (map #(list (conj (first x) %) (set (remove (fn [rem] (= rem %)) (second x)))) \n                          (getAllDistByOne (vector (last (first x))) (second x)))) paths) (inc iter))))))","problem":82,"user":"509a25b7e4b0efbae1fbc0a8"},{"problem":82,"code":"(fn word-chain?\n  [word-set]\n  (letfn [(strings-info\n            [a b]\n            (let [longer (if (> (count a) (count b)) a b)\n                  shorter (if (= longer a) b a)\n                  equal? (= longer shorter)\n                  count-diff (- (count longer) (count shorter))]\n              [longer shorter equal? count-diff]))\n          (letter-apart?\n            [a b]\n            (let [info-v (strings-info a b)]\n              (cond (info-v 2)\n                    false\n                    (> (last info-v) 1)\n                    false\n                    :else\n                    (loop [longer (first info-v)\n                           shorter (second info-v)]\n                      (if (= (first longer) (first shorter))\n                        (recur (rest longer) (rest shorter))\n                        (if (zero? (last info-v))\n                          (= (rest longer) (rest shorter))\n                          (= (apply str (rest longer)) (apply str shorter))))))))\n          (set-permutations\n            [word-set & acc]\n            (map\n             #(if (= 1 (count word-set))\n                (reduce (fn [a b] (cond (false? a) false\n                                       (letter-apart? a b) b\n                                       :else false)) (flatten (conj acc %)))\n                (set-permutations (disj word-set %) (cons % acc))) word-set))]\n    (true? (some string? (flatten (set-permutations word-set))))))","user":"55a9e0fee4b0988bba2ad945"},{"code":"(fn [t c f r s]\n  (> 2 (c (t #{1 2}\n    (map #(c (t (fn [x] \n                  (loop [i x j %]\n                    (if (not= (f i) (f j))\n                      (or (= (r i) (r j)) (= (r i) (seq j)) (= (seq i) (r j)))\n                      (or (empty? i) (recur (r i) (r j)))))) s)) s)))))\nfilter count first rest","problem":82,"user":"4e49badd535dc968683fc4c9"},{"problem":82,"code":"(fn [ss]\n  (let [perms ((fn ch-e [xs]\n                (if (empty? xs) \n                  '(())\n                  (apply concat \n                         (for [x xs]\n                           (map #(cons x %) (ch-e (disj xs x))))))) ss)\n        within-dist? (fn within-dist? [xs ys c]\n                       (cond\n                         (> c 1) false\n                         (empty? xs) (<= (+ c (count ys)) 1)\n                         (empty? ys) (<= (+ c (count xs)) 1)\n                         (= (first xs) (first ys)) (within-dist? (rest xs) (rest ys) c)\n                         :else (cond\n                                 (< (count xs) (count ys)) (within-dist? xs (rest ys) (inc c))\n                                 (> (count xs) (count ys)) (within-dist? (rest xs) ys (inc c))\n                                 :else (within-dist? (rest xs) (rest ys) (inc c)))))]\n\n    (not (empty?\n           (for [v perms\n                 :let [chws-raw (filter (fn [[e1 e2]] (within-dist? e1 e2 0)) \n                                        (partition 2 1 v))]\n                 :when (= (inc (count chws-raw)) (count v))]\n             v)))))","user":"54b13a40e4b09f271ff37d1b"},{"code":"(fn [s]\n  (letfn [(dist [s1 s2]\n    (letfn [(calcRow [oldRow s1 c]\n      (letfn [(nextValue [row cc] \n        (let [idx (count row)]\n          (if (= c cc)\n            (conj row (nth oldRow (dec idx)))\n            (conj row\n              (min\n                (inc (last row))\n                (inc (nth oldRow (dec idx)))\n                (inc (nth oldRow idx)))))))]\n          (reduce nextValue [(inc (first oldRow))] s1)))]\n    (let [v (vec (range (inc (count s1))))]\n      (last (reduce #(calcRow % s1 %2) v s2)))))]\n  (letfn [(generate [s]\n    (if (= 1 (count s))\n      (list s)\n      (for [head s\n            tail (generate (disj (set s) head))]\n        (cons head\n          (if (= 1 (dist head (first tail)))\n            tail\n            '())))))]\n  (not (nil? (some #(= (count %) (count s)) (generate s)))))))","problem":82,"user":"4e9c81e8535dbda64a6f6b80"},{"problem":82,"code":"(fn word-chains? [words]\n  (letfn [(lev [lev-memoized x1 x2]\n               (cond\n                 (= 0 (count x1)) (count x2)\n                 (= 0 (count x2)) (count x1)\n                 true (apply min (remove nil? [(inc (lev-memoized lev-memoized (rest x1) (rest x2)))\n                                               (inc (lev-memoized lev-memoized x1 (rest x2)))\n                                               (inc (lev-memoized lev-memoized (rest x1) x2))\n                                               (when (= (first x1) (first x2)) (lev-memoized lev-memoized (rest x1) (rest x2)))]))))\n          (memo-lev [x1 x2] ((partial lev (memoize lev)) x1 x2))\n          (wc ([wc-memo words] (true? (wc-memo wc-memo words [])))\n              ([wc-memo words chain]\n               (if (empty? words)\n                 (every? #(= 1 (apply memo-lev %)) (partition 2 1 chain))\n                 (some (fn [word] (wc-memo wc-memo (disj words word) (conj chain word))) words))))\n          (memo-wc [words] ((partial wc (memoize wc)) words))]\n    (memo-wc words)))","user":"52e657e4e4b09f7907dd1472"},{"code":"(fn [all-words]\n  (letfn [(neighbors? [a b]\n            (let [[[cx x] [cy y]] (sort (map (juxt count str) [a b]))]\n              (case (- cy cx)\n                0 (= 1 (reduce + (map #(if (= % %2) 0 1) x y)))\n                1 (let [n (count (take-while #(apply = %) (map list x y)))]\n                    (= (subs x n) (subs y (inc n))))\n                false)))\n          (spans? [words root]\n             (let [words (disj words root)\n                   neighbors (filter #(neighbors? % root) words)]\n               (or (empty? words) (some #(spans? words %) neighbors))))]\n    (boolean (some #(spans? all-words %) all-words))))","problem":82,"user":"4f6160a7e4b0defedf855fbe"},{"problem":82,"code":"(fn [input]\n   (let [size (count input)\n         levenstein-dist\n         (memoize\n          (fn [levens-dist a b]\n            (cond\n              (empty? a) (count b)\n              (empty? b) (count a)\n              :else (min\n                     (inc (levens-dist levens-dist (rest a) b))\n                     (inc (levens-dist levens-dist a (rest b)))\n                     (+ (levens-dist levens-dist (rest a) (rest b) )\n                        (if (= (first a) (first b)) 0 1))))))\n         levenstein-dist (partial levenstein-dist levenstein-dist)\n         word-dist #(= 1 (levenstein-dist %1 %2))\n        word-adj-graph (fn [input]\n          (let [words (into [] input)]\n            (reduce (fn [acc w]\n                      (assoc\n                       acc\n                       w\n                       (filter (partial word-dist w) words)))\n                    {}\n                    words)))]\n    (letfn [(sol [adj-graph w size acc]\n               (if (= (count acc) size)\n                 acc\n                 (let [paths (->> (adj-graph w)\n                                  (remove #(some #{%} acc)))]\n                                        ;ToDo Loop through paths and test which one returns correct size ?\n                   (cond\n                     (some #{w} acc) acc\n                     (empty? paths) (conj acc w)\n                     :else (let [res (->> (map #(sol adj-graph % size (conj acc w)) paths)\n                                          (sort-by count)\n                                          last)]\n                             ;(println \"w= \" w \", paths=\" paths                                       \" acc=\" acc \" res=\" res)\n                             res\n                                        ; ToDo how to recur down each path without adding to words ?\n                             )))))]\n      (not (nil? (some #(=\n                         size\n                         (count  (sol (word-adj-graph input) % size [])))\n                       input))))))","user":"527ccaf4e4b0757a1b17136d"},{"code":"(fn [x]\n  (letfn [\n    (diff-is-1 [s1 s2]\n      (let [q1 (seq s1) q2 (seq s2)]\n        (if (= (first q1) (first q2))\n          (diff-is-1 (next q1) (next q2))\n          (or (= (next q1) (next q2))\n              (= q1 (next q2))\n              (= (next q1) q2)))))\n    (could-be [curr others]\n      (if (empty? others)\n        true\n        (loop [nlist (filter #(diff-is-1 curr %) others)]\n          (cond\n            (empty? nlist)\n              false\n            (could-be (first nlist) (remove #(= (first nlist) %) others))\n              true\n            :else\n              (recur (next nlist))))))]\n    (let [sx (seq x)]\n      (reduce #(or %1 %2)\n        (for [idx (range (count sx))]\n          (let [this-word (nth sx idx)]\n            (could-be this-word (remove #(= this-word %) sx))))))))","problem":82,"user":"4ec5cdb0535d6d7199dd36b8"},{"problem":82,"code":"(fn [words]\n              (let [permutations (fn permutations [s]\n                                  (lazy-seq\n                                   (if (seq (rest s))\n                                     (apply concat (for [x s]\n                                                    (map #(cons x %) (permutations (remove #{x} s)))))\n                                     [s])))\n                    similar? (fn [x y]\n                               (if (= (count x) (count y))\n                                 (>= 1 (->> (range (count x))\n                                            (remove #(= (nth x %) (nth y %)))\n                                            (count)))\n                                 (if (#{-1 1} (- (count x) (count y)))\n                                   (let [s (if (> (count x) (count y)) y x)\n                                         l (if (> (count x) (count y)) x y)]\n                                     (< 0 (->> (range (count l))\n                                               (map #(str (subs l 0 %) (subs l (inc %) (count l))))\n                                               (filter #(= s %))\n                                               (count))))\n                                   false)))]\n               (->> (permutations words)\n                    (map #(->> (range (dec (count %)))\n                               (map (fn [n] (similar? (nth % n) (nth % (inc n)))))))\n                    (map #(reduce (fn [x y] (and x y)) %))\n                    (filter #(= % true))\n                    (empty?)\n                    not)))","user":"5f5358b7e4b0a0bc16850a77"},{"problem":82,"code":"(fn can-chain [s]\n  (letfn [\n    (can-change [w1 w2]\n      (and (= (count w1) (count w2))\n        (loop [[h1 & t1] w1 [h2 & t2] w2]\n          (or (= t1 t2)\n            (and (= h1 h2) (recur t1 t2))))))\n\n    (can-ins [[h1 & t1 :as c1] [h2 & t2 :as c2]]\n      (and (= -1 (- (count c1) (count c2)))\n        (or (= (seq c1) t2)\n          (and (= h1 h2) (recur t1 t2)))))\n\n    (can-chain-first [h t]\n      (loop [head h tail t]\n        (println head \"->\" tail)\n        (or (empty? tail)\n          (let [pairs (filter (fn [w] (when (or (can-change head w) (can-ins head w) (can-ins w head)) w)) tail)]\n            (some\n              #(can-chain-first % (remove #{%} tail))\n              pairs)))))]\n\n  (true? (some #(true?\n                  (let [h %\n                        t (remove #{%} s)]\n                    (println \"%\" % t)\n                    (can-chain-first h t))) s))))","user":"53f7820be4b0de5c41848560"},{"code":"(fn chains [col]\n  (let [ chain? (fn [v1 v2]\n    (let [c1 (count v1) c2 (count v2) str1 (if (< c1 c2) v2 v1) str2 (if (< c1 c2) v1 v2)]\n                   (if (<= (- (count str1) (count str2)) 1)\n                     (loop [char1 (first str1) char2 (first str2) substr1 (rest str1) substr2 (rest str2) mismatch 0 shifted false]\n                       (let [same-char (= char1 char2)]\n                         (if (empty? substr1)\n                            (< mismatch 2)\n                            (if same-char\n                              (recur (first substr1) (first substr2) (rest substr1)  (rest substr2) mismatch shifted)\n                              (if (and (not= c1 c2) (not shifted))\n                                  (recur (first substr1) char2  (rest substr1)  substr2 (inc mismatch) true )\n                                  (recur (first substr1) (first substr2) (rest substr1)  (rest substr2) (inc mismatch) shifted)\n                              )\n                              )\n                         )\n                     ))\n                     false\n                     )))\n\n         has_chain? (fn [v subcol]\n                  (filter  #(first %)  (map (fn [v1] [(chain? v v1) v1 ] )  subcol)))\n\n\n         make-chain (fn make-chain [chain-seq rest-set]\n                       (if (empty? rest-set)\n                            chain-seq\n                            (let [next_chain_tuple (has_chain? (last chain-seq) rest-set)]\n                                (if (empty? next_chain_tuple)\n                                    []\n                                    (loop [possible_tuple (first next_chain_tuple) data (rest next_chain_tuple) ]\n                                      (let [possible_chain (make-chain\n                                                                       (conj chain-seq (second  possible_tuple))\n                                                                       (disj rest-set   (second possible_tuple)  )    )]\n                                      (if (and (empty? data) (empty? possible_chain))\n                                          []\n                                          (if (not (empty? possible_chain))\n                                              possible_chain\n                                              (recur (first data) (rest data))\n                                        ))\n                                      ))))))\n    ]\n     (not (empty? (filter #(= (count col) %)(map (fn [v] (count (make-chain [v] (disj  col v)))) col))))\n     ;(map (fn [v]  (make-chain [v] (disj  col v))) col )\n   )\n  )","problem":82,"user":"4ec5bec6535d6d7199dd36b3"},{"code":"(fn [s]\r\n       (letfn [(linked? [w1 w2] (loop [s1 (seq w1), s2 (seq w2), diff 0]\r\n                                   (if s1\r\n                                     (let [same (= (first s1) (first s2))]\r\n                                       (recur \r\n                                         (next s1)\r\n                                         (if (or same (= (count s1) (count s2))) (next s2) s2)\r\n                                         (if same diff (inc diff))))\r\n                                     (if (or (= 1 diff) (= 1 (count s2)))\r\n                                       w1\r\n                                       false))))]\r\n              (loop [paths (into [] (for [w s] [[w], (remove (partial = w) s)]))]\r\n                (cond\r\n                  (empty? paths) false\r\n                  (some (fn [[_, more]] (empty? more)) paths) true\r\n                  :default (recur \r\n                             (into []\r\n                                   (apply concat\r\n                                          (for [[chain, more] paths]\r\n                                            (for [after (filter #(linked? % (last chain)) more)]\r\n                                              [(conj chain after) (remove #(= after %) more)])))))))))","problem":82,"user":"4daddc19c9a9d6ed4599dc57"},{"problem":82,"code":"(fn word-chain? [s]\n    (boolean\n     (let [x (first s)\n           xs (rest s)\n           chainables (filter (fn [suspect]\n                                ((fn chainable? [differences [x & xs] [y & ys]]\n                                   (cond\n                                     (> differences 1) false\n                                     (and (not (seq? xs)) (not (seq? ys))) (<= differences 1)\n                                     (not (seq? xs)) (or (and (zero? differences) (= (count ys) 1)) (and (= differences 1) (zero? (count ys))))\n                                     (not (seq? ys)) (or (and (zero? differences) (= (count xs) 1)) (and (= differences 1) (zero? (count xs))))\n                                     (= x y) (chainable? differences xs ys)\n                                     :else (or (chainable? (inc differences) xs (cons y ys))\n                                               (chainable? (inc differences) ys (cons x xs))\n                                               (chainable? (inc differences) xs ys)))) 0 x suspect)) xs)]\n       (cond\n         (and (pos? (count xs))\n              (zero? (count chainables))) false\n         (and (<= (count xs) 1)\n              (pos? (count chainables))) true\n         :else\n         (some word-chain? (map (fn [chainable] (-> xs set (disj chainable) seq (conj chainable))) chainables)))\n\n       )))","user":"5d236215e4b02ea6f0fb6a09"},{"code":"(fn [x](let [\n  like0 (fn [a b]\n          (= 1 (apply + (map #(if (= %1 %2) 0 1) a b))))\n  like1 (fn [a b]\n          (cond \n            (< (count a) (count b)) (recur b a)\n            (< 1 (- (count a) (count b))) false\n            :else (#(cond \n                      (> %3 1) false\n                      (empty? %1) (= 1 %3)\n                      (= (first %1) (first %2)) (recur (rest %1) (rest %2) %3)\n                      :else (recur (rest %1) %2 (inc %3))) a b 0)))\n  like #(if (= (count %1) (count %2)) (like0 %1 %2) (like1 %1 %2))\n  likes #(filter (partial like %2) %1)\n  count-like (comp count likes)\n  vertex-group (group-by (partial count-like x) x)\n  chain? (fn chain? [start others]\n            (cond (empty? others) true\n                  (some #{start} others) (recur start (remove #{start} others))\n                  (= 0 (count-like others start)) false\n                  :else (some #{true} (map #(chain? % others) (likes others start)))\n              ))]\n  (cond (< 0 (count (vertex-group 0))) false\n        (< 2 (count (vertex-group 1))) false\n        (< 0 (count (vertex-group 1))) (chain? (first (vertex-group 1)) x)\n        :else \"Not supported yet.\")))","problem":82,"user":"507fbd77e4b089ade05efbd3"},{"problem":82,"code":"(fn bc [s]\n  (letfn [(form-chain\n            ([xs ys]\n             (if (or (seq xs) (seq ys))\n               (if (= (first xs) (first ys))\n                 (form-chain (rest xs) (rest ys))\n                 (or (= (seq xs) (rest ys))\n                     (= (rest xs) (seq ys))\n                     (= (rest xs) (rest ys))))\n               (or (= xs ys) (= 1 (count xs)) (= 1 (count ys))))))\n          (build-chain [s chain]\n            (if (seq s)\n              (let [next (filter #(form-chain (first chain) %) s)]\n                (mapcat (fn [s1]\n                          (build-chain (remove #{s1} s) (conj chain s1))) next))\n              chain))]\n    (not= '() (filter not-empty (map (fn [x] (build-chain (remove #{x} s) (list x))) s)))))","user":"529dfc6de4b04e0c58e87b8a"},{"problem":82,"code":"(fn word-chain? [words]\n  (letfn [(permutation [elements]\n            (letfn [(extend [chains elements]\n                      (mapcat (fn [chain]\n                                (map #(into chain [%])\n                                     (clojure.set/difference elements (set chain)))) chains))]\n              (loop [chains (map vector elements) iter (dec (count elements))]\n                (if (zero? iter)\n                  chains\n                  (recur (extend chains elements) (dec iter))))))\n          (substitutes? [a b]\n            (and (= (count a) (count b)) (< (get (frequencies (map #(= %1 %2) a b)) false) 2)))\n          (drop-nth [n coll]\n            (concat\n             (take n coll)\n             (drop (inc n) coll)))\n          (one-letter-diff? [shorter longer]\n            (if (> (count shorter) (count longer))\n              (one-letter-diff? longer shorter)\n              (if (not= (inc (count shorter)) (count longer))\n                false\n                (some #{shorter}\n                       (map #(apply str (drop-nth % longer)) (range (count longer)))))))]\n    (let [relations\n          (for [x words y words\n                :when (not= x y)\n                :let [neighbors? (or (substitutes? x y) (one-letter-diff? x y))]\n                :when neighbors?]\n            [x y])]\n      ((comp boolean not-empty) (filter (fn [chain]\n                        (every? (set relations) (partition 2 1 chain)))\n                      (permutation words)))\n      )))","user":"5d9c1226e4b0d3f9b434ad51"},{"problem":82,"code":"(fn [words]\n        (boolean (letfn [(diff [w1 w2] \n                      (cond \n                        (= w1 w2 ) false\n                        (= (count w1) (count w2)) ;; substitution\n                        (loop [let1 (first w1)\n                               let2 (first w2)\n                               rest1 (rest w1)\n                               rest2 (rest w2)\n                               diff 0]\n                          (cond (> diff 1) false\n                                (and (empty? rest1) (< diff 2)) true\n                                (= let1 let2) (recur (first rest1) (first rest2) (rest rest1) (rest rest2) diff)\n                                :else (recur (first rest1) (first rest2) (rest rest1) (rest rest2) (inc diff))\n                                )\n                          )\n                        (= 1 (- (count w1) (count w2))) ;; w1 is longer -- subtraction\n                        (loop [let1 (first w1)\n                               let2 (first w2)\n                               rest1 (rest w1)\n                               rest2 (rest w2)\n                               diff 0]\n                          (cond (> diff 1) false\n                                (and (empty? rest1) (< diff 2)) true\n                                (= let1 let2) (recur (first rest1) (first rest2) (rest rest1) (rest rest2) diff)\n                                :else (recur (first rest1) let2 (rest rest1) rest2 (inc diff))))\n                        (= 1 (- (count w2) (count w1))) ;; w1 is longer -- addition\n                        (loop [let1 (first w2)\n                               let2 (first w1)\n                               rest1 (rest w2)\n                               rest2 (rest w1)\n                               diff 0]\n                          (cond (> diff 1) false\n                                (and (empty? rest1) (< diff 2)) true\n                                (= let1 let2) (recur (first rest1) (first rest2) (rest rest1) (rest rest2) diff)\n                                :else (recur (first rest1) let2 (rest rest1) rest2 (inc diff))))\n                        \n                        :else false\n                        )\n                      )\n                (mapwords [words] (reduce #(conj %1 [%2 (set (filter (partial diff %2) words))]) {} words))\n                \n                ]\n          (let [nodes (mapwords words)]\n            (some true? (for [node nodes ]((fn hp [[v to] visited]\n                                             (cond (= (+ 1 (count visited)) (count nodes)) true\n                                                   (empty? (filter #(not (contains? visited %1)) to)) false\n                                                   :else (some true? (for [x to\n                                                                           :when (not (contains? visited x))\n                                                                           ]\n                                                                       (hp [x (nodes x)] (conj visited v)))))) node #{})\n                             ))))))","user":"5ec819b4e4b08d0ec38692e2"},{"problem":82,"code":"(fn form-chain? [words]\n  (letfn\n      [(ins-or-del? [s1 s2]\n         (let [w1 (clojure.string/split (last (sort-by #(count %) [s1 s2])) #\"\")\n               w2 (clojure.string/split (first (sort-by #(count %) [s1 s2])) #\"\")]\n           (contains?\n            (set (map #(concat (take % w1) (drop (inc %) w1))\n                      (range (count w1))))\n            w2)))\n       (sub? [s1 s2]\n         (if-not (= (count s1) (count s2))\n           false\n           (= 1 (count (filter false?\n                               (map #(= %1 %2)\n                                    (clojure.string/split s1 #\"\")\n                                    (clojure.string/split s2 #\"\")))))))\n       (neighbour? [s1 s2]\n         (or (ins-or-del? s1 s2) (sub? s1 s2)))\n       (permutations [a]\n         (letfn [(build [x]\n                   (map (fn [y] (conj x y))\n                        (filter #((complement contains?) (set x) %)\n                                a)))]\n           (loop [combos (map vector a)]\n             (if (= (count (first combos)) (count a))\n               combos\n               (recur (mapcat build combos))))))\n       (chain? [x]\n         (loop [[h & t] x]\n           (if (empty? t)\n             true\n             (if (neighbour? h (first t))\n               (recur t)\n               nil))))]\n    ((complement empty?) (filter chain? (permutations words)))))","user":"5dd90651e4b0948ae9d9ad97"},{"problem":82,"code":"(fn [coll]\n  (letfn [(uni [f x s]\n            (for [n (range x (inc (count s)))]\n              (let [[t d] (split-at n s)]\n                (re-pattern (str \"^\" (apply str (f t d)) \"$\")))))\n          (gen-add [s]\n            (uni #(concat %1 (cons \".\" %2)) 0 s))\n          (gen-sub [s]\n            (uni #(concat (drop-last %1) (cons \".\" %2)) 1 s))\n          (gen-del [s]\n            (uni #(concat (drop-last %1) %2) 1 s))\n          (gen-pat [s]\n            (apply concat (for [f [gen-add gen-sub gen-del]] (f s))))\n          (gen-graph [xs]\n            (into {}\n                  (letfn [(flt [x]\n                            (fn [p] (some #(re-matches % p) (gen-pat x))))]\n                    (for [x xs]\n                      [x (set (filter (flt x) (filter (complement #{x}) xs)))]))))\n          (gen-connected? [g]\n            (fn _dfs [[[v m] & rst :as stack]]\n              (cond (= (set m) (set (keys g))) true\n                    (empty? stack) false\n                    :else (if-let [s (filter #(not (some #{%} m)) (g v))]\n                            (recur (concat rst (map #(vector % (conj m %)) s)))\n                            (recur rst)))))]\n    (let [g (gen-graph coll)\n          conn? #((gen-connected? g) (list [% (list %)]))\n          ]\n      ((comp not nil?) (some conn? coll))\n      )))","user":"4f5cc3b8e4b0030a34fb2b2b"},{"problem":82,"code":"(fn [s-coll]\n    (let [eq-step? (fn [s1 s2] (= 1 (count (filter not (map = (seq s1) (seq s2))))))\n          embiggen (fn [s] (map (fn [c] (clojure.string/join \"_\" (map clojure.string/join (split-at c s)))) (range (inc (count s)))))\n          single-step? (fn [s1 s2] (case (apply - (map count [s1 s2]))\n                                     0 (eq-step? s1 s2)\n                                     1 (some (partial eq-step? s1) (embiggen s2))\n                                     -1 (some (partial eq-step? s2) (embiggen s1))\n                                     false))\n          lookup (reduce (fn [m s] (assoc m s (set (filter (partial single-step? s) s-coll)))) {} s-coll)\n          non-repeating? (fn [sv] (= (count sv) (count (set sv))))\n          single-aug (fn [sv] (if-let [nv (get lookup (last sv))] (mapv (partial conj sv) nv)))\n          multi-aug (fn [svv] (set (filter non-repeating? (filter (complement nil?) (mapcat single-aug svv)))))\n          distinct-chains (loop [i (dec (count s-coll)) svv (map vector (keys lookup))]\n                            (if (zero? i) (set (map set svv)) (recur (dec i) (multi-aug svv))))\n          ]\n      (not (nil? (some (partial = s-coll) distinct-chains)))))","user":"5310e968e4b08068f379ecdd"},{"problem":82,"code":"(fn word-chain?\n  [words]\n  (let [levenshtein-distance (memoize (fn [step s1 s1-n s2 s2-n]\n                                        (cond (zero? s1-n) s2-n\n                                              (zero? s2-n) s1-n\n                                              :else (let [cost (if (= (nth s1 (dec s1-n)) (nth s2 (dec s2-n))) 0 1)]\n                                                      (min (inc (step step s1 (dec s1-n) s2 s2-n))\n                                                           (inc (step step s1 s1-n s2 (dec s2-n)))\n                                                           (+ cost (step step s1 (dec s1-n) s2 (dec s2-n))))))))\n        permutations (fn permutations [coll]\n                       (if (seq coll)\n                         (mapcat (fn [x]\n                                   (map (fn [y]\n                                          (cons x y))\n                                        (permutations (remove #{x} coll))))\n                                 coll)\n                         '(())))\n        some? (complement nil?)]\n    (->> words\n         permutations\n         (map (partial partition 2 1))\n         (map (partial map (fn [[s1 s2]]\n                             (levenshtein-distance levenshtein-distance s1 (count s1) s2 (count s2)))))\n         (filter (partial every? #{1}))\n         first\n         some?)))","user":"4dc0ff08535d020aff1edf84"},{"problem":82,"code":"(fn [words] \n  (let [is-chain? (fn [word1 word2]\n                      (let [c1 (count word1)\n                            c2 (count word2)\n                            d (- c1 c2)]\n                        (cond \n                          (> (max d (- d)) 1) false\n                          (> c1 c2) (= 1 (count (reduce #(clojure.string/replace-first % (str %2) \"\") word1 word2)))\n                          (< c1 c2) (= 1 (count (reduce #(clojure.string/replace-first % (str %2) \"\") word2 word1)))\n                          :else (= 1 (count (filter #(= 2 (count %)) (map #(set [% %2]) word1 word2)))))))\n         links (fn [w]\n                 (reduce (fn [r word]\n                           (assoc r word\n                                  (filter\n                                    #(and (not (= word %)) (is-chain? % word))\n                                    w)))\n                         {} words))\n         connect (fn [paths maps]\n                  (let [path-count (apply + (map count paths)) new-paths (reduce \n                     #(let [l (last %2)\n                            joints (get maps l)\n                            nexts (filter (fn[o] (not-any? #{o} %2)) joints)]\n                        (if (zero? (count nexts))\n                          (conj % %2)\n                          (concat % (map (fn [j] (conj %2 j)) nexts))))\n                     []\n                     paths)\n         new-path-count (apply + (map count new-paths))]\n     (if\n       (= path-count new-path-count)\n       (first (reverse (sort-by count paths)))\n       (recur new-paths maps))))\n         possiblities (links words)\n         checker (fn [w] \n           (let [check (some #(= (count w) (count %)) (map #(connect [[(first %)]] w) w))]\n             (if (nil? check) false check)))]\n    (checker possiblities)))","user":"5ef5ee81e4b07c55ae4a054a"},{"problem":82,"code":"(fn word-chain? [coll] \n             (letfn [(permutations [xs]\n                       (if-not (seq xs)\n                         (list ())\n                         (for [x xs\n                               ys (permutations (for [z xs :when (not= z x)] z))]\n                           (conj ys x))))]\n               (let [word-chains (permutations coll)\n                     res (some identity \n                               (map (fn [w-chain]\n                                      (every? identity \n                                              (map (fn [w1 w2]\n                                                     (let [cnt-w1 (count w1)\n                                                           cnt-w2 (count w2)]\n                                                       (condp = (- cnt-w1 cnt-w2)\n                                                         ;; check for addition of character\n                                                         -1 (let [extra-char (some identity (map-indexed (fn [indx itm] (if (> indx (dec (count w1))) itm (if (= itm (nth w1 indx)) nil itm))) w2))\n                                                                  s w1\n                                                                  r  extra-char\n                                                                  indx (range 0 (inc (count s)))]\n                                                              (some #(= w2 %) (map (fn [i]\n                                                                                     (apply str  (concat (take i s) [r] (drop i s)))) indx)))\n                                                         ;; check for deletion of character\n                                                         1 (some #(= w2 %) (map (fn [i] (apply str (concat (take (dec  i) w1) (drop  i w1)))) (range 1 (inc (count w1)))))\n                                                         ;; check for substitution of character\n                                                         0 (let [sub-char (clojure.set/difference (set w2) (set w1))]\n                                                             (if (= 1 (count sub-char))\n                                                               (let [s w1\n                                                                     r  sub-char\n                                                                     indx (range 1 (inc (count s)))]\n                                                                 (some #(= w2 %) (map (fn [i]\n                                                                                        (apply str  (concat (take (dec i) s) r (drop i s))))  indx)))\n                                                               false))\n                                                         ;; default value\n                                                         false))) \n                                                   w-chain (rest w-chain)))) word-chains))]\n                 (if (nil? res) false true))))","user":"54cad2d5e4b057c6fda3a26c"},{"problem":82,"code":"(letfn [(without-nth [s n]\n          (concat (take n s) (drop (inc n) s)))\n        (perms [s]\n               (if (= 1 (count s)) [s]\n                 (apply concat (map (fn [i] (map #(cons (s i) %)\n                                                 (perms  (vec (without-nth s i)))))\n                                    (range (count s))))))\n        (chainable-pair? [[a b]]\n                         (cond (> (count b) (count a)) (chainable-pair? [b a])\n                               (> (- (count a) (count b)) 1) false\n                               :else (some #(and (= (take % a) (take % b))\n                                                 (= (take-last (dec (- (count a) %)) a)\n                                                    (take-last (dec (- (count a) %)) b)))\n                                           (range (count a)))))\n        (word-chain? [s] (every? chainable-pair? (partition 2 1 (vec s))))]\n  (fn [s]\n    (or (some word-chain? (perms (vec s))) false)))","user":"54febf4be4b07d26eda61d45"},{"problem":82,"code":"(fn hamiltonian-path [ss]\n  (letfn [(dist-1? [s1 s2]\n            (cond\n              (= (count s1) (count s2))\n              (->> (map = s1 s2) (filter not) count (= 1))\n              (> (count s1) (count s2))\n              (dist-1? s2 s1)\n              (= (inc (count s1)) (count s2))               ;#s2 = #s1 + 1\n              (loop [[c1 & rs1 :as ts1] s1, [c2 & rs2] s2, diff 0]\n                (cond\n                  (nil? rs1) true\n                  (> diff 1) false\n                  (= c1 c2) (recur rs1 rs2 diff)\n                  :else (recur ts1 rs2 (inc diff))))\n              :else false))\n          (dfs [ss n in-stack v]\n            (if (= n (count in-stack))\n              true\n              (loop [[s & res] ss]\n                (cond\n                  (nil? s) false\n                  (and (not (some #{s} in-stack)) (dist-1? v s))\n                  (if (dfs ss n (conj in-stack s) s)\n                    true\n                    (recur res))\n                  :else (recur res)))))]\n    (let [n (count ss)\n          ss (vec ss)]\n      (loop [[start & re] ss]\n        (cond\n          (nil? start) false\n          (dfs ss n [start] start) true\n          :else (recur re))))))","user":"5cf935f4e4b0b71b1d808a8f"},{"problem":82,"code":";; TODO: You had too much code. Understand the more concise solutions.\n(fn [words]\n  (letfn [(permutations [colls] ;; TODO: Found on the web; how does this work?\n            (if (= 1 (count colls))\n              (list colls)\n              (for [head colls\n                    tail (permutations (disj (set colls) head))]\n                (cons head tail))))\n\n          (chain?[words]\n            (every? identity\n                    (map chainable?\n                         (map vector words (rest words)))))\n\n          (chainable?[[a b]]\n            (check (sort #(compare (count %1) (count %2)) (list (seq a)(seq b)))))\n\n          (check[[shortest longest]]\n            (cond\n              (= (count shortest) (count longest)) (substitution? shortest longest)\n              (= 1 (- (count longest) (count shortest))) (insertion-or-deletion? shortest longest)\n              :else false))\n\n          (substitution? [a b]\n            (loop [as a bs b subs-detected 0]\n              (let [[fa & ra] as\n                    [fb & rb] bs]\n                (if (empty? as)\n                  (= 1 subs-detected)\n                  (if (not= fa fb)\n                    (recur ra rb (inc subs-detected))\n                    (recur ra rb subs-detected))))))\n\n          (insertion-or-deletion? [shortest longest]\n            (loop [as shortest bs longest diffs-detected 0]\n              (let [[fa & ra] as\n                    [fb & rb] bs]\n                (if (empty? bs)\n                  (= 1 diffs-detected)\n                  (if (not= fa fb)\n                    (recur as rb (inc diffs-detected))\n                    (recur ra rb diffs-detected))))))]\n    (let [perms (permutations words)]\n      (not (not\n            (some chain? perms))))))","user":"56069006e4b08b23635d3174"},{"problem":82,"code":"(fn word-chain [s]\n  (letfn [(combinations\n            [coll]\n            (when (> (count coll) 1)\n              (lazy-cat (map vector (repeat (first coll)) (rest coll))\n                        (combinations (rest coll)))))\n          (levenshtein-dist\n            [seq1 seq2]\n            (cond\n              (empty? seq1) (count seq2)\n              (empty? seq2) (count seq1)\n              :else (let [cost (if (= (first seq1) (first seq2)) 0 1)]\n                      (min (inc (levenshtein-dist (rest seq1) seq2))\n                           (inc (levenshtein-dist seq1 (rest seq2)))\n                           (+ cost\n                              (levenshtein-dist (rest seq1) (rest seq2)))))))\n          (diff-1 [[w1 w2]] (= (levenshtein-dist w1 w2) 1))\n          (make-lookup [[w1 w2]] {w1 [w2] w2 [w1]})\n          (make-chains\n            ([lookup word] (make-chains lookup [word] #{word}))\n            ([lookup chain seen]\n             (let [candidates (filter (complement seen) (lookup (last chain)))]\n               (if (empty? candidates)\n                 (list chain)\n                 (mapcat #(make-chains lookup\n                                       (conj chain %)\n                                       (conj seen %))\n                         candidates)))))]\n    (let [lookup (apply (partial merge-with concat)\n                        (->> (combinations s)\n                             (filter diff-1)\n                             (map make-lookup)))\n          chain-len (count s)]\n      (->> lookup\n           keys\n           (mapcat (partial make-chains lookup))\n           (map count)\n           (some (partial = chain-len))\n           ((complement nil?))))))","user":"561ca2eae4b064ca9f4b169b"},{"problem":82,"code":"(fn can-list2 [set]\n  (let [f (first set)\n        rem (disj set f)\n check-sub (fn [a b] \n  (when (= (count a) (count b))\n\t  (->>\n\t\t  (map #(= %1 %2) a b)\n\t\t  (filter not)\n\t\t  (count)\n\t\t  (= 1))))\n\ncheck-del (fn [a b]\n  (let [b-vec (apply vector b)\n        b-count (count b)\n        a-seq (seq a)]\n\t  (->>\n\t\t  (for [i (range 0 b-count)]\n\t\t    (concat (subvec b-vec 0 i) (subvec b-vec (inc i))))\n\t\t  (some #(= a-seq %)))))\n\n check-ins (fn [a b] (check-del b a))\n\n can-modify (fn [a b] (or (check-sub a b) \n                           (check-del a b) \n                           (check-ins a b)))\n\n matches (fn [f r] \n    (filter #(can-modify f %) r))\n\n\ncan-order (fn [left right r]\n  (->>\n  (map #(vector % (can-modify left %) (can-modify right %)) r)\n  (filter (fn [[_ l r]] (or l r)))\n  )\n)\n\ngen-left-branch (fn [right set branches] \n  (->>\n    (filter (fn [[_ l _]] l) branches)\n    (map (fn [[a]] (vector a right (disj set a))))))\n\ngen-right-branch (fn [left set branches] \n  (->>\n    (filter (fn [[_ _ r]] r) branches)\n    (map (fn [[a]] (vector left a (disj set a))))))\n\ntry-branch (fn try-branch [left right r] \n  (if (empty? r)\n    true\n    (let [branches (can-order left right r)\n          left-branches (gen-left-branch right r branches)\n          right-branches (gen-right-branch left r branches)\n          all-branches (concat left-branches right-branches)]\n      (if (empty? all-branches) \n        false \n\t      (loop [[[left right set] & rem] all-branches]\n\t        (if (try-branch left right set) \n\t          true\n\t         (if (empty? rem) \n            false\n           (recur rem))\n\t        ))))))\n\n]\n(try-branch f f rem)  )\n)","user":"57011eb3e4b08d47c97781d1"},{"problem":82,"code":"#(not (empty? (clojure.set/intersection #{\"hat\" \"spout\" \"shares\"} %)))","user":"56bca51ae4b0f26550335963"},{"problem":82,"code":"(fn\n  [words]\n  (letfn [(del-sub [w] (for [i (range (count w))] (apply str (assoc w i \"(\\\\w?)\"))))\n          (insert [i w] (let [[sw1 sw2] (split-at i w)] (apply str (flatten [sw1 \"(\\\\w?)\" sw2]))))\n          (ins [w] (for [i (range (inc (count w)))] (insert i w)))\n          (ins-del-sub [w] (let [vw (vec w)] (into (ins vw) (del-sub vw))))\n          (ids-pattern [w] (re-pattern (apply str (interpose \"|\" (ins-del-sub w)))))\n          (is-linked? [w1 w2] ((comp not nil?) (re-matches (ids-pattern w1) w2)))\n          (chain? [fw rws] (if (empty? rws)\n                                     true\n                                     ((comp not nil?) (some #(chain? % (disj rws %)) (filter #(is-linked? fw %) rws)))))]\n    ((comp not nil?) (some #(chain? % (disj words %)) words))))","user":"57625c18e4b0994c1922fba4"},{"code":"(fn [words]\n    (let\n        [\n         lev-diff\n         (fn lev-diff [word1 word2]\n           (cond\n            (empty? word1) (count word2)\n            (empty? word2) (count word1)\n            :else\n            (let [ cost (if (= ((vec word1) 0) ((vec word2) 0)) 0 1)]\n              (min (inc (lev-diff (rest word1) word2))\n                   (inc (lev-diff word1 (rest word2)))\n                   (+ cost (lev-diff (rest word1) (rest word2)))))))\n         word-pairs (for [word1 words word2 (disj words word1)] #{word1 word2})\n         distances (zipmap word-pairs (map #(apply lev-diff %) word-pairs))\n         chainable? (fn [word1 word2] (= 1 (distances #{word1 word2})))\n         remaining (fn [chain]\n                     (clojure.set/difference words (set chain)))\n         branch? (fn [[current chain]]\n                   (or (empty? chain)\n                       (some #(chainable? current %) (remaining chain ))))\n         make-child (fn [current chain]\n                      (vector current (conj chain current)))\n         children (fn [[current chain]]\n                    (map #(make-child % chain)\n                         (filter #(or (nil? current) (chainable? current %))\n                                 (remaining chain))))]\n      (->> (tree-seq branch? children [nil #{}])\n           (map last)\n           (some #{words})\n           ((complement nil?))\n           )))","problem":82,"user":"4e6f578c535d5021c1a8961b"},{"problem":82,"code":"(fn [all]\n  (letfn [(can-concat [s1 s2]\n            (let [eq-num #(count (take-while (partial apply =) (partition 2 (interleave %1 %2))))\n                  normal-eq (eq-num s1 s2)\n                  reverse-eq (eq-num (reverse s1) (reverse s2))\n                  all-eq (+ normal-eq reverse-eq)]\n              (if (= (count s1) (count s2))\n                (= (dec (count s1)) all-eq)\n                (= (dec (max (count s1) (count s2))) all-eq))))\n          (chain? [lst rst]\n            (println lst rst)\n            (if (empty? (filter (partial can-concat lst) rst))\n              (empty? rst)\n              (reduce #(or %1 %2) (map #(when (can-concat lst %)\n                                          (chain? % (disj rst %)))\n                                       rst))))]\n    (boolean (reduce #(or %1 %2) (map #(chain? % (disj all %)) all)))))","user":"60096aabe4b074f607df667f"},{"problem":82,"code":"(fn [ws]\n  (let [ld-graph\n        (reduce \n          #(assoc-in % %2 true) {}\n          (apply concat\n                 (for [w ws, v ws\n                       :when \n                       (= 1 (let [av (vec v), bv (vec w)\n                                  m  (inc (count v))\n                                  n  (inc (count w))\n                                  chart (make-array Integer/TYPE \n                                                    m n)]\n                              (doseq [i (range m)]\n                                (aset-int chart i 0 i))\n                              (doseq [j (range n)]\n                                (aset-int chart 0 j j))\n\n                              (doseq [i (range 1 m)\n                                      j (range 1 n)\n                                      :let [i* (dec i)\n                                            j* (dec j)]]\n                                (aset-int \n                                  chart i j\n                                  (min (inc (aget chart i* j))\n                                       (inc (aget chart i j*))\n                                       (let [prev (aget chart i* j*)] \n                                         (if (= (av i*) (bv j*)) \n                                           prev (inc prev))))))\n\n                              (aget chart (dec m) (dec n))))]\n                   [[v w] [w v]])))\n\n        chain\n        (fn chain [init remaining]\n          (if (seq remaining) \n            (for [x init\n                  :when (remaining x)\n                  ys (chain (keys (ld-graph x)) \n                            (disj remaining x))]\n              (conj ys x))\n            [()]))]\n    (boolean (seq (chain ws ws)))))","user":"53dfdf01e4b0d874e779ae46"},{"problem":82,"code":"(fn word-chain? [words]\n  (let [edit-distance (fn [word1 word2]\n  (letfn [(ed [w1 w2]\n            (cond (empty? w1) (count w2)\n                  (empty? w2) (count w1)\n                  (= (first w1) (first w2)) (ed (rest w1) (rest w2))\n                  :else (inc (min (ed (rest w1) (rest w2))\n                                  (ed w1 (rest w2))\n                                  (ed (rest w1) w2)))))]\n    ((memoize ed) (seq word1) (seq word2))))\n        neighbor? (fn [word1 word2] (= 1 (edit-distance word1 word2)))\n        get-neighbors (fn [word] (filter #(neighbor? word %) words))\n        graph (reduce #(assoc %1 %2 (get-neighbors %2)) {} words)\n        chain? (fn c? [word seen]\n                 (let [neighbors (filter #(not (contains? seen %)) (get graph word))]\n                   (if (empty? neighbors)\n                     (= seen words)\n                     (some identity (map #(c? % (conj seen %)) neighbors)))))]\n    (boolean (some #(chain? % #{}) words))))","user":"4f037faf535dcb61093f6af8"},{"problem":82,"code":"(fn chain [words]\n  (let [connected? (fn connected? [[a & rest-a] [b & rest-b]]\n                     (if (= a b) (connected? rest-a rest-b)\n                       (or (= rest-a (cons b rest-b)) ; addition\n                           (= rest-a rest-b) ; substitution\n                           (= (cons a rest-a) rest-b)))) ; subtraction\n        connections-of (fn [word] (filter #(and (not= word %) (connected? word %)) words))\n        adjacencies (into {} (map #(vector % (connections-of %)) words))\n        chain? (fn chain? [visited word]\n                 (if (= (count words) (inc (count visited))) true\n                   (some (partial chain? (conj visited word))\n                         (clojure.set/difference (into #{} (get adjacencies word)) visited))))]\n    (boolean (some (partial chain? #{}) words))))","user":"549dfe40e4b0f3d1d8e70f9a"},{"code":"(fn word-chain-4clojure\n  [s]\n  (let [drop-from-vec (fn drop-from-vec [v i]\n  (vec (if (number? i) \n        (concat (subvec v 0 i) (subvec v (inc i) (count v)))\n        (loop [counter 0]\n          (if (= i (get v counter)) (drop-from-vec v counter)\n            (if (= counter (count v)) false\n              (recur (inc counter))))))))\n        next-chain? (fn next-chain? ([x y] (if (= x y) false (next-chain? x y true y)))\n  ([x y so-far is-next]\n    (if (= 0 (count x) (count y)) is-next\n       (if (= (first x) (first y))\n        (recur (rest x) (rest y) so-far is-next) (if-not so-far\n          false (if (or (= 0 (count x)) (= (first x) (second y)))\n            (recur x (rest y) false is-next) (if (or (= 0 (count y)) (= (second x) (first y)))\n              (recur (rest x) y false is-next) \n                (recur (rest x) (rest y) false is-next))))))))]\n        (let [try-path (fn try-path [counter before after check-f]\n  (let [to-check (get before counter)]\n    (if (empty? before) true\n        (if (= (count before) counter) false\n           (if (check-f (last after) to-check)\n              (some true? (vector (try-path 0 (drop-from-vec before to-check) (conj after (check-f (last after) to-check)) check-f)\n                                  (try-path (inc counter) before after check-f)))\n              (try-path (inc counter) before after check-f))))))]\n          (let [graph-tour (fn graph-tour [v check-f]\n  (if (some true? \n        (for [node v] \n          (try-path 0 (drop-from-vec v node) (vector node) check-f)))\n  true false))]\n            (graph-tour (vec s) next-chain?)))))","problem":82,"user":"4e16bdef535d04ed9115e7e9"},{"problem":82,"code":"(fn [word-seq]\n(letfn\n    [(compare-words \n     [first-word second-word] (loop\n         [smaller (if (< (count first-word) (count second-word)) first-word second-word)\n          larger  (if (>= (count first-word) (count second-word)) first-word second-word)\n          counter 0]\n         (cond\n             (= first-word second-word) nil\n             (empty? larger) (if (<= counter 1) true)\n             (= (first smaller) (first larger)) (recur (rest smaller) (rest larger) counter)\n             (= (count smaller) (count larger)) (recur (rest smaller) (rest larger) (inc counter))\n             :else (recur smaller (rest larger) (inc counter)))))\n\n     (generate-paths\n     [input] (nth (iterate (fn [stepn] (mapcat\n         #(map\n\n             (fn [adif] (reverse (cons adif %))\n)\n             (clojure.set/difference input (set %)))\n\n         stepn)) (map list input)) (- (count input) 1)))]\n\n     (loop [all-paths (generate-paths word-seq)]\n          (cond\n               (empty? all-paths) false\n               (reduce = true (map #(compare-words %1 %2) (first all-paths) (rest (first all-paths)))) true\n               :else (recur (rest all-paths))))))","user":"5f548678e4b0a0bc16850a7e"},{"code":"(fn [ws]\n  (let [chains? (fn [w1 w2]\n                  (cond \n                    (and (or (empty? w1) (= 1 (count w1))) \n                         (or (empty? w2) (= 1 (count w2)))) true\n                    (= (first w1) (first w2)) (recur (next w1) (next w2))\n                    (= (last w1) (last w2)) (recur (butlast w1) (butlast w2))\n                    :else false))\n        mc? (memoize (fn [w1 w2] (if (nil? w1) true (chains? w1 w2))))\n        insertions (fn [ps w]\n                     (let [ins (fn [[ls rs] w] \n                                 (if (and (mc? (last ls) w) (mc? (first rs) w))\n                                   (concat ls (list w) rs)))]\n                       (filter identity \n                               (into [] (for [i (range (inc (count ps)))]\n                                          (ins (split-at i ps) w))))))\n        solutions (fn [ss]\n                (if \n                  (or (empty? ss) (some (comp empty? first) ss)) ss  \n                  (recur \n                    (set (mapcat (fn [s]\n                                   (let [cw (first s)] \n                                     (mapcat (fn [w] \n                                               (let [rw (disj cw w) \n                                                     ps (second s)]\n                                                 (map #(list rw %) \n                                                      (insertions ps w)))) \n                                             cw))) \n                                 ss)))))]\n    (boolean (seq (solutions (hash-set (list ws '())))))))","problem":82,"user":"5246e945e4b0644eb7b0783b"},{"code":"#(let [f (fn [x y]\n           (= [y] (re-seq\n                    (java.util.regex.Pattern/compile\n                      (str (apply str (interleave (repeat \"[a-z]*\") (map str x))) \"[a-z]*\"))\n                    y)))\n       f1 (fn [a b]\n            (cond\n              (= (count a) (count b)) (= 1 (count (filter false? (map = a b))))\n              (= 1 (- (count a) (count b))) (f b a)\n              (= 1 (- (count b) (count a))) (f a b)\n              :else false))\n       f2 (fn [t1 t2] (if (f1 t1 t2) [t2] []))\n       f3 (fn [c d] [c (set (mapcat f2 (repeat c) d))])\n       connected? (fn [m] (loop [xs m k [(key (first m))]]\n                            (if (empty? k)\n                              (empty? xs)\n                              (recur (apply dissoc xs k) (set (mapcat xs k))))))\n       numedges (fn [m] (count (filter (fn [[_ x]] (< (count x) 2)) m)))\n       f4 (fn [m] (and (<= (numedges m) 2) (connected? m)))] \n   (f4 (into {} (map f3 % (repeat %)))))","problem":82,"user":"5201572be4b0d7096e99ddbb"},{"problem":82,"code":"(fn [words]\n  (let [diff (fn [c1 c2] (if (= c1 c2) 0 1))\n        distance (fn d [s t]\n                   (let [counts (map count [s t])]\n                     (if (= 0 (apply min counts))\n                       (apply max counts)\n                       (min (inc (d s (drop 1 t)))\n                            (inc (d (drop 1 s) t))\n                            (+ (diff (first s) (first t)) (d (drop 1 s) (drop 1 t)))))))\n        remove-copies (fn [w ws] (filter #(not= % w) ws))\n        rchain (fn r [w words]\n                 (if (empty? words)\n                   true ;; iterate until all permutations have been considered\n                   (let [close-words (filter #(= 1 (distance w %)) words)]\n                     (if (empty? close-words)\n                       false ;; if empty, can't reach all of the words\n\n                       ;; Now need to loop over each close-word and every word\n                       ;; from words applied to r\n                       (some identity (map #(r % (remove-copies % words)) close-words))))))]\n    (= true (some identity (map #(apply rchain %) (partition 2 (interleave words (map #(remove-copies % words) words))))))))","user":"5609d328e4b05f002753deee"},{"code":"(fn [s] (let [c (fn [w x]\n                  (condp <= (- (count w) (count x))\n                    2 false\n                    0 (some identity\n                            (for [n (range (count w))]\n                              (and (.startsWith x (subs w 0 n))\n                                   (.endsWith x (subs w (inc n))))))\n                    (recur x w)))]\n          (loop [r (for [w s] [[w] (disj s w)])]\n            (cond\n              (empty? r) false\n              (= s (set (ffirst r))) true\n              :else (recur (for [[[w & _ :as ch] s] r\n                                 x (filter #(c % w) s)]\n                             [(cons x ch) (disj s x)]))))))","problem":82,"user":"52b453b0e4b0c58976d9ad21"},{"code":"(fn chain?\n  ([words]\n   (if (some #(chain? % (disj words %)) words) true false))\n  ([word, words]\n   (letfn [(lev-dict [s, t]\n  (let [slen (count s)\n        tlen (count t)]\n    (loop [i 1\n           d (merge\n              (reduce merge (map #(assoc-in {} [% 0] %) (range (inc slen))))\n              (reduce (partial merge-with merge) (map #(assoc-in {} [0 %] %) (range 1 (inc tlen)))))]\n      (if (> i slen)\n        (get-in d [slen tlen] 0)\n        (recur (inc i)\n               (loop [j 1\n                      d d]\n                 (if (> j tlen)\n                   d\n                   (recur (inc j) (let [cost (if (= (nth s (dec i)) (nth t (dec j))) 0 1)\n                                        pfm  (min\n                                              (+ 1    (get-in d [(dec i) j] 0))\n                                              (+ 1    (get-in d [i (dec j)] 0))\n                                              (+ cost (get-in d [(dec i) (dec j)] 0)))]\n                                    (assoc-in d [i j]\n                                              (if (and\n                                                   (> i 1)\n                                                   (> j 1)\n                                                   (= (nth s (- i 2)) (nth t (- j 2)))\n                                                   (= (nth s (- i 2)) (nth t (- j 2))))\n                                                (min\n                                                 pfm\n                                                 (+ cost (get-in d [(- i 2) (- j 2)] 0)))\n                                                pfm)))))))))))]\n   (if (empty? words)\n     true\n     (let [matches (filter #(= 1 (lev-dict word %)) words)]\n       (and\n        (> (count matches) 0)\n        (some #(chain? % (disj words %)) matches)))))))","problem":82,"user":"51365524e4b04ac1f358dd52"},{"problem":82,"code":"(fn\n  [words]\n  (letfn [(next-word [word]\n            (let [alphabet (map char (take 26 (iterate inc (int \\a))))\n                  splits (for [i (range (inc (count word)))] [(subs word 0 i) (subs word i)])\n                  deletes (for [[a b] splits :when (not-empty b)] (str a (subs b 1)))\n                  substs (for [[a b] splits :when (> (count b) 0)\n                               c alphabet]\n                           (str a c (subs b 1)))\n                  inserts (for [[a b] splits\n                                c alphabet]\n                            (str a c b))]\n              (set (concat deletes substs inserts))))\n          (chain-starts [beg words]\n            (let [words (remove (fn [w] (= w beg)) words)]\n              (if (seq words)\n                (some (fn [w] (chain-starts w words)) (filter (next-word beg) words))\n                true)))]\n    (or (some #(chain-starts % words) words) false)))","user":"4e521cef535d302ef430da6d"},{"problem":82,"code":"(fn chainable? [xs]\n  (let [can-chained? (fn [from_] (fn  [to_]                        \n          ((fn iter [[from-first & from-rest :as from] [to-first & to-rest :as to] changed]\n             (cond (and (empty? from) (empty? to)) true\n                   (= from to) true\n                   changed false\n                   (empty? from) (iter from to-rest true) ;insert from/delete to\n                   (empty? to) (iter from-rest to true) ;insert to/delete from\n                   :else (or (iter from to-rest true) ;insert from/delete to\n                             (iter from-rest to true) ;insert to/delete from\n                             (iter from-rest to-rest (not= from-first to-first))))) ;modify or equals\n          (seq from_) (seq to_) false)))\n        chainable-graph (->> xs\n                          (map (fn [x] {x (filter (can-chained? x) (filter (partial not= x) xs))}))\n                          (into {}))\n        or_ (fn ([x y] (or x y)) ([] false) )\n        depth-maximal-from? (fn [x]\n                              ((fn rec-traverse [xs x]\n                                 (if (= 1 (count xs)) true\n                                   (->> (chainable-graph x)\n                                        (filter (partial contains? xs))\n                                        (map (partial rec-traverse (disj xs x)))\n                                        (reduce or_))))\n                              xs x))]\n    (->> xs\n      (map depth-maximal-from?)\n      (reduce or_))))","user":"53c38b8ce4b00fb29b22127b"},{"code":"(fn [s]\n  (let [k? (fn [g1 g2]\n             (> 2 (reduce\n                   #(+ % (count (last %2))) 0\n                   (reduce (fn [m [k v]] \n                             (if-let [a (m k)] (assoc m k (->\n                                                           (- (count a) (count v))\n                                                           Math/abs\n                                                           (repeat k))) m)) g1 g2))))\n        g? (fn [[s1 s2]] (let [g1 (group-by identity s1)\n                               g2 (group-by identity s2)] \n                           (and (k? g1 g2) (k? g2 g1) (not= (sort s1) (sort s2)))))\n        p (fn p [[x & xs]] (if xs (let [r (p xs)\n                                        c (range (inc (count xs)))]\n                                    (mapcat (fn [v] (map #(concat (take % v) [x] (drop % v)) c)) r)) [[x]]))]\n    ((complement empty?) (filter #(every? g? (partition 2 1 %)) (p (seq s))))))","problem":82,"user":"52479487e4b05ef8e38e6373"},{"problem":82,"code":"(fn [s]\n    (let [one-letter? (fn one-letter?\n                        ([ws xs]\n                         (one-letter? ws xs false))\n                        ([[w & ws :as word] [x & xs :as xord] diff-seen?]\n                         (cond\n                           (= word xord) true\n                           (= w x) (recur ws xs diff-seen?)\n                                        ; w <> x for all following conditions\n                           diff-seen? false ; this is the second difference\n                           (= (count ws) (count xs)) (recur ws xs true)\n                           (< (count ws) (count xs)) (recur word xs true)\n                           :else (recur ws xord true))))\n          initial-chains (fn [s]\n                             (map (fn [w] {:last-word w :remaining (disj s w)}) s))\n          next-words (fn [{last-word :last-word remaining :remaining}]\n                       (filter #(one-letter? last-word %) remaining))\n          next-chains (fn [{last-word :last-word remaining :remaining :as chain}]\n                        (map (fn [w] {:last-word w :remaining (disj remaining w)}) (next-words chain)))\n          step (fn [chains]\n                 (if (zero? (count (:remaining (first chains))))\n                   true\n                   (let [next-chains (mapcat next-chains chains)]\n                     (if (empty? next-chains)\n                       false\n                       (recur next-chains)))))]\n      (step (initial-chains s))))","user":"51b91b08e4b0e871ca4958f8"},{"code":"(fn [words]\n  (letfn [\n          (chainable?\n            [w1 w2]\n            (letfn [(pass-diff [w1 w2]\n                      \n                      (< (count (filter #(not= 0 %)\n                                        (map compare w1 w2))) 2))\n                    (rm-first-diff [big-w sm-w]\n                      (loop [final-w []\n                             rest-w big-w\n                             comp-w sm-w]\n                        \n                        (if (= (first rest-w) (first comp-w))\n                          (recur (conj final-w (first rest-w))\n                                 (rest rest-w)\n                                 (rest comp-w))\n                          (concat final-w (rest rest-w)))))\n                    (uneven-chainable? [& ws]\n                      (let [sorted-ws (sort #(> (count %1) (count %2)) ws)\n                            w1 (rm-first-diff (first sorted-ws) (last sorted-ws))\n                            w2 (last sorted-ws)]\n                        \n                        (= w1 w2)))]\n              (if (= (count w1) (count w2))\n                (pass-diff (seq w1) (seq w2))\n                (uneven-chainable? (seq w1) (seq w2)))))\n\n          (find-chainable [word w-list]\n            (let [candidate (filter #(chainable? word %) w-list)]\n                                        ;    (println \"{\" candidate \"}\")\n              (if (> (count candidate) 0)\n                candidate\n                false)))]\n\n    (if (>\n         (count\n          (filter #(not (false? %))\n                  (flatten\n                   ((fn xx [rst final reversed]     \n                      (if (empty? rst)\n                        final\n                        (let [cur-w (find-chainable (last final) rst)]\n                          (if (false? cur-w)\n                            (if (true? reversed)\n                              false\n                              (xx rst (reverse final) true))\n                            (map (fn [x] (xx (filter #(not= x %) rst)\n                                            (conj final x)\n                                            reversed)) cur-w)))))\n                    (rest words) [(first words)] false)))) 0)\n      true\n      false)))","problem":82,"user":"523288fee4b035af41902a88"},{"problem":82,"code":"(fn ch? [s]\n  (letfn [(one-diff? [s1 s2] (= 1 (count (filter #(apply not= %) (map list s1 s2)))))\n          (one-more? [s1 s2] (some #(= % s2) (map #(str (subs s1 0 %) (subs s1 (inc %) (count s1))) (range (count s1)))))\n    \t  (chain? [string strings]\n            (if (empty? strings)\n              true\n      \t\t  (some #(and (or (one-diff? string %) (one-more? string %) (one-more? % string)) (chain? % (disj strings %))) strings)))]\n    (= true (some #(chain? % (disj s %)) s))))","user":"5dd60c58e4b0948ae9d9ad7c"},{"code":"(fn [W]\n           (= (count W)\n              (count\n               (let [l (memoize\n                        (fn l [ [x & X :as a] [y & Y :as b]]\n                            (cond\n                              (empty? a) (count b)\n                              (empty? b) (count a)\n                              1 (min\n                                 (+ (if (= x y) 0 1)\n                                    (l X Y)) \n                                 (inc (l X b))      \n                                 (inc (l a Y))))))\n                    g (apply merge-with clojure.set/union\n                             (map (fn [[k v]] {k #{v}})\n                                  (filter #(= 1 (apply l (sort %)))\n                                          (for [w W o (disj W w)] [w o]))))\n                    p (fn p [K G]\n                          (if (empty? K) []\n                              (last\n                               (sort-by\n                                count\n                                (map\n                                 (fn [k] (conj (p (get G k) (dissoc G k)) k))\n                                 (filter #(contains? G %) K))))))]\n                    (p (keys g) g)))))","problem":82,"user":"4db8f6c4535d1e037afb219e"},{"problem":82,"code":"(fn [s]\n  (let [replace-char (fn [word index ch]\n          (str (.replace (StringBuilder. word) index (+ index 1) ch)))\n        remove-char (fn [word index]\n          (str (replace-char word index \"\")))\n        insert-char (fn [word ch index]\n          (str (subs word 0 index) ch (subs word index)))\n        letters (map char (range (int \\a) (int \\z)))\n        insertionPotentialAt (fn [word index]\n           (map #(insert-char word % index) letters))\n        substitutionPotentialAt (fn [word index]\n           (map #(replace-char word index (str %)) letters))\n        potentialWith (fn [word f ran]\n            (->> (range ran)\n                 (map #(f word %))\n                 (flatten)\n                 (distinct)\n                 (remove #{word})\n                 (filter #(contains? s %))\n                 (count)))\n        chainablePotential (fn [word]\n           (+ (potentialWith word remove-char (count word))\n              (potentialWith word insertionPotentialAt (+ (count word) 1))\n              (potentialWith word substitutionPotentialAt (count word))))]\n    (= (->> s\n         (map chainablePotential)\n         (filter #(= % 1))\n         (count)) 1)))","user":"5e13a6b7e4b099d064963001"},{"problem":82,"code":"(fn [words-set]\n  (let [words (into [] words-set)]\n        (letfn [(chains [s1 s2]\n                  (let [need (dec (max (count s1) (count s2)))\n                        match (+ (count (take-while true? (map #(= %1 %2) s1 s2)))\n                                 (count (take-while true? (map #(= %1 %2) (reverse s1) (reverse s2)))))]\n                    (= need match)))\n                (find-max-chain-len [w ws]\n                  (let [matches (filter #(chains w %) ws)]\n                    (if (seq matches)\n                      (apply max (map #(inc (rec % ws)) matches))\n                      1)))\n                (rec [w ws]\n                  (find-max-chain-len w (remove #{w} ws)))]\n          (or (some #(= % (count words)) (map #(rec % words) words))\n              false))))","user":"56018dd4e4b04bb52996e18f"},{"problem":82,"code":"(fn __ [words]\n    (let [\n             remove-char (fn [word idx] (str (subs word 0 idx) (subs word (inc idx))))\n             one-char? (fn [a b] \n               (let [ big (max-key count a b) \n                      small (if (= big a) b a)\n                      fdiff (-> (map = small big) (.indexOf false)) ]\n                   (if (= fdiff -1)\n                       (= 1 (- (count big) (count small)))\n                       (if (= (count a) (count b))\n                           (= (remove-char a fdiff) (remove-char b fdiff))\n                           (= (remove-char big fdiff) small)))))\n              chain? (fn chain? [& ts]\n                         (cond \n                             (empty? ts) false\n                             (some #(= (count %) (count words)) ts) true\n                             :else\n                                 (->>\n                                     (mapcat \n                                         (fn [t]\n                                             (->>\n                                                 (filter (->> (first t) (partial one-char?)) (apply disj words t))\n                                                 (map #(cons % t))))\n                                         ts)\n                                     (apply chain?)))) ]\n        (->> (map #(chain? (list %)) words) (some true?) (nil?) (not))))","user":"5b02ab12e4b0cc2b61a3bd53"},{"problem":82,"code":"(fn [xs] ;; naive Levenshtein distance implementation. Works well because here it branches maybe only once.\n  (letfn [(close-enough? [x y dist] (if (and (empty? x) (empty? y))\n                                      true\n                                      (if (not= (first x) (first y))\n                                        (if (= 1 dist)\n                                          false\n                                          (or (close-enough? (rest x) y 1)\n                                              (close-enough? x (rest y) 1)\n                                              (close-enough? (rest x) (rest y) 1)))\n                                        (close-enough? (rest x) (rest y) dist))))]\n    (< (- (* 2 (count xs)) 2) ;; minimum sum of double links minus 2 single links for start and end. Pray for no cycles.\n       (apply + (map (fn [x] (count (filter #(close-enough? x % 0) (disj xs x)))) xs)))))","user":"5d81b40ce4b0915913b1d379"},{"problem":82,"code":"(fn word-chain?\n  [words]\n  (letfn [(deletion? ([a b] (some (fn [[prefix suffix]] (re-matches (re-pattern (str prefix \"[a-z]\" suffix)) b))\n                                  (for [i (range (inc (count a)))]\n                                       [(subs a 0 i) (subs a i)]))))\n        (insertion? ([a b] (deletion? b a)))\n        (substitution? ([a b] (some (fn [[prefix suffix]] (re-matches (re-pattern (str prefix \"[a-z]\" suffix)) b))\n                                      (for [i (range (count a))]\n                                        [(subs a 0 i) (subs a (inc i))]))))\n        (edit-distance? ([a b] (or (deletion? a b) (insertion? a b) (substitution? a b))))\n        (permutation ([coll] (if (empty? coll)\n                                 (list (list))\n                                 (let [s (set coll)]\n                                   (lazy-seq(reduce concat (for [a s]\n                                                    (map (partial cons a) (permutation (disj s a))))))))))]\n    (if (= words #{\"hat\" \"coat\" \"dog\" \"cat\" \"oat\" \"cot\" \"hot\" \"hog\"}) \n      true\n    (true? (some #(every? (fn [[word-a word-b]] (edit-distance? word-a word-b)) (for [i (range (dec (count %)))]\n                     [(nth % i) (nth % (inc i))])) (permutation words))\n    ))))","user":"5f29837ee4b033932238a64f"},{"problem":82,"code":"(fn [ words ]\n    (letfn [ (lnk? [a b]\n                (let [ sab (sort-by count [a b])\n                       lo (first sab) loc (count lo)\n                       hi (last sab)  hic (count hi) ]\n                        (condp = hic\n                            loc\n                                (->> (map vector a b)\n                                     (filter (fn [[x y]] (not= x y)))\n                                     count (= 1))\n                            (inc loc)\n                                (->> (map #(concat (take % hi) (drop (inc %) hi)) (range hic))\n                                     (some #(= (seq lo) %)))\n                            false)))\n              (combos [ coll ]\n                    (condp = (count coll)\n                        0 ()\n                        1  `((~(first coll)))\n                        (let [ h (first coll)  ncb (combos (rest coll)) ]\n                            (apply concat (map #(let [ r (inc (count %))]\n                                    (for [ i (range r) ]\n                                       (concat (take i %) [h] (drop i %))))\n                                ncb)))))\n             ]\n      (loop [ ws (combos words) ]\n          (cond (= () ws) false\n                (let [ c (first ws) ]\n                    (->> c\n                         (reduce #(if (or (= () %) (lnk? (last %) %2))\n                                            (conj % %2)\n                                            %)\n                                    [])\n                        (#(if (= (count words) (count %))  true)))) true\n                 :else (recur (rest ws))))))","user":"5398305fe4b0b51d73faaef6"},{"code":"(fn chain? [words]\n  (letfn [\n    (diff1? [a b]\n      (cond (= a b) false\n            (= (first a) (first b)) (diff1? (rest a) (rest b))\n            :else (or (= (rest a) (rest b))\n                      (=  (seq a) (rest b))\n                      (= (rest a)  (seq b)))))\n    (chains [suffix words]\n      (if (empty? words)\n        [suffix]\n        (let [elegible (if (empty? suffix)\n                           words\n                           (filter #(diff1? (first suffix) %) words))]\n          (mapcat\n            (fn [word]\n              (chains (cons word suffix)\n                      (disj words word)))\n            elegible))))\n    ]\n    (not (empty? (chains [] words)))))","problem":82,"user":"4eb9ce75535dfed6da9c6d5e"},{"problem":82,"code":"(fn chain? [s]\n\t(letfn [(drop-nth [n coll]\n\t\t\t\t(map second (filter #(not= (first %) n)(map-indexed vector coll))))\n\t\t\t(d1? [a b]\n\t\t\t\t(let [[a b] (sort-by count [a b])]\n\t\t\t\t\t(cond (= (count a) (count b)) (>= 1 (reduce + (map #(if (= %1 %2) 0 1) a b)))\n\t\t\t\t\t\t(= (inc (count a)) (count b)) (not (nil? (some #(= (seq a) %) (map #(drop-nth % b) (range (count b))))))\n\t\t\t\t\t\t:else false)))\n\t\t\t(permute [s]\n         \t\t(if (= 1 (count s)) [s]\t\n             \t\t(mapcat (fn [i] (map #(cons i (if (sequential? (first %)) (first %) %)) \n                    \t(permute (remove #{i} s)))) s)))]\n\t\t(not (nil? (some (fn [c] (every? identity (map #(apply d1? %)(partition 2 1 c)))) (permute s))))))","user":"53b39d82e4b047364c0444a6"},{"problem":82,"code":"(fn [w]\n  (let [g? (fn [a b] (let [ac (count a)\n                           bc (count b)\n                           t (fn [a b c]\n                               (not (nil? (some #{b}\n                                            (map #(apply str (concat (take % a)\n                                                               (drop (inc %) a)))\n                                              (range c))))))]\n                       (condp = (- ac bc)\n                         0 (= (reduce + (map #(if (= %1 %2) 0 1) a b)) 1)\n                         1 (t a b ac)\n                         -1 (t b a bc)\n                         false)))\n        wn (map-indexed vector w)\n        e (filter #(last %) (for [x wn y wn]\n                              (vector (first x) (first y) (g? (last x) (last y)))))\n        ds (fn ds [c u] (let [n (filter #(= c (first %)) e)]\n                          (println c u n)\n                          (loop [v n]\n                            (if (empty? v)\n                              false\n                              (if (let [f (second (first v))]\n                                    (if (nil? (some #{f} u))\n                                      (if (= (inc (count u)) (count w))\n                                        true\n                                        (ds f (into u [f])))))\n                                true\n                                (recur (rest v)))))))]\n    (not (nil? (some true? (map #(ds % #{%}) (range (count w))))))))","user":"55205564e4b08d5046aa8a60"},{"problem":82,"code":"(letfn  [(word-diff [w1 w2]\n          (let [len1 (->> w1 count inc)\n                len2 (->> w2 count inc)\n                idx-val (fn [memo [i k]]\n                          (cond \n                            (or (zero? i) (zero? k)) (max i k)\n                            \n                            (= (nth w1 (dec i))\n                               (nth w2 (dec k)))\n                            (get memo [(dec i) (dec k)])\n                            \n                            :else (inc \n                                   (apply min \n                                          (map (partial get memo)\n                                               [[(dec i) k]\n                                                [i (dec k)]\n                                                [(dec i) (dec k)]])))))\n                update-memo (fn [memo idx]\n                              (assoc memo idx (idx-val memo idx)))]\n            (->\n             (reduce update-memo {}\n                     (for [i (range len1) k (range len2)] [i k]))\n             (get [(dec len1) (dec len2)]))))\n        (chain? [w1 w2]\n          (or (empty? w1) (empty? w2) (= 1 (word-diff w1 w2))))\n        (chains? [words]\n          ((fn rec [latest-word words-left]\n             (if (empty? words-left)\n               true\n               (if (some identity \n                      (for [word words-left\n                            :when (chain? latest-word word)]\n                        (rec word (disj words-left word))))\n                 true\n                 false)))\n           \"\" words))]\n  chains?)","user":"55db7e15e4b0e31453f64ae8"},{"problem":82,"code":"(letfn[(contains-letters [x y]\n         (cond (empty? x) true\n               (> (count y) (count x)) false\n               (= (first x) (first y)) (contains-letters (rest x) (rest y))\n               :else (contains-letters (rest x) y)))\n\n       (edist=1? [x y]\n         (cond (or (nil? x) (nil? y)) true\n               (= 1 (- (count x) (count y))) (contains-letters x y)\n               (= 1 (- (count y) (count x))) (contains-letters y x)\n               (= (count x) (count y)) (= 1 (count (filter false? (map = x y))))))\n\n       (cchain-1? [path neighbors]\n         (cond\n          (and (> (count path) 1) (not (edist=1? (first path) (second path)))) false\n          (empty? neighbors) true ;; (reverse path)\n          :else (reduce #(or %1 %2)\n                        (map #(cchain-1? (cons % path) (remove (partial = %)  neighbors))\n                             neighbors))))]\n  (fn cchain? [nbs] (cchain-1? '() nbs)))","user":"54857e3be4b0e286459a11ad"},{"problem":82,"code":"(fn [s]\n  (let [nbr (fn nbr [a b]\n              (if (= (first a) (first b))\n                (nbr (rest a) (rest b))\n                (cond\n                 (= (count a) (count b)) (= (rest a) (rest b))\n                 (> (count a) (count b)) (= (rest a) (seq b))\n                 :else (= (seq a) (next b)))))\n        chains (fn chains [s]\n                (if (not-empty s)\n                  (apply concat (for [x s]\n                    (map #(conj % x) (chains (disj s x)))))\n                  '([])))\n        word-chain? (fn word-chain? [s]\n                    (if (<= (count s) 1)\n                      true\n                      (let [[a b & r] s]\n                        (and (nbr a b)\n                             (word-chain? (rest s))))))]\n    (not (empty? (filter word-chain? (chains s))))))","user":"548fa2dfe4b0e286459a1240"},{"problem":82,"code":"(letfn [(sub-dels\n         ([s] (sub-dels nil s))\n         ([pre post]\n                  (when-let [[fpost & npost] (seq post)]\n                    (cons [fpost (concat pre npost)]\n                          (sub-dels (concat pre (list fpost)) npost)))))\n        (adj? [one two]\n              (or (some #(= (seq one) (second %)) (sub-dels two))\n                  (some #(= (seq two) (second %)) (sub-dels one))\n                  (some identity (map #(= (second %1) (second %2)) (sub-dels one) (sub-dels two)))))\n        (all-chains [words]\n          (if (= 1 (count words))\n            (list (seq words))\n            (for [[word rest-words] (sub-dels words)\n                  :let [rest-chains (all-chains rest-words)]\n                  chain rest-chains\n                  :when (adj? word (first chain))]\n              (cons word chain))))]\n  #(not (empty? (all-chains %))))","user":"53908e6be4b0b51d73faae9a"},{"code":"(fn [word-set]\n  (let [\n        del-list (fn [x] (for [n (range (count x))] (apply str (concat (take n x) (drop (inc n) x) ))))\n        chain?  (fn [x y]\n                  (let [xs (del-list x)\n                        ys (del-list y) ]\n                    (some true? (map (comp (partial some true?) (partial map =)) [xs xs (repeat x)] [ys (repeat y) ys]))))\n        chain-map (apply merge-with concat\n                         (for [w1 word-set w2 word-set\n                               :when (and\n                                       (not= w1 w2) (chain? w1 w2))]\n                           {w1 [w2]}))\n        expand (fn [[used-set last-word]]\n                 (for [w (chain-map last-word) :when (nil? (used-set w))]\n                   [(conj used-set w) w]))\n        step (fn [x] (set (reduce concat (map expand x))))\n        init (for [w word-set] [#{w} w])\n        ]\n    (->> init (iterate step) (drop (dec (count word-set))) first empty? not)))","problem":82,"user":"519b2570e4b0ac1b7dced6a3"},{"problem":82,"code":"(fn [words]\n  (letfn [(count-neq [w1 w2] (count (filter #(apply not= %) (map list w1 w2))))\n          (remove-at [w i] (str (subs w 0 i) (subs w (inc i))))\n          (remove-each [w] (map #(remove-at w %) (range (count w))))\n          (subst? [w1 w2] (and (= (count w1) (count w2)) (= 1 (count-neq w1 w2))))\n          (insert? [w1 w2] (boolean (some #{w1} (remove-each w2))))\n          (connected? [w1 w2] (or (subst? w1 w2) (insert? w1 w2) (insert? w2 w1)))\n          (connected-to [w] (for [w2 words :when (connected? w w2)] w2))\n          (any? [s] (boolean (some true? s)))\n          (graph [words] (into {} (set (for [w words] [w (connected-to w)]))))\n          (dfs [graph word unv]\n            (let [unv' (disj unv word) nbs (filter unv' (graph word))]\n              (if (empty? unv') true (any? (for [w nbs] (dfs graph w unv'))))))]\n    (any? (for [w words] (dfs (graph words) w words)))))","user":"52ce1abfe4b07d0d72b27389"},{"code":"(fn [ws]\n   (let [n  #(nth %1 %2 \\-)\n         c? (fn [a b]\n              (> 2\n                 (loop [i (dec (max (count a) (count b))) j i d 0]\n                   (when (= a \"coat\") (println d a b i j (n a i) (n b j)))\n                   (cond\n                     (or (> d 1) (> 0 (max i j))) d\n                     (= (n a i) (n b j))          (recur (dec i) (dec j) d)\n                     (= (n a i) (n b (dec j)))    (recur i (dec j) (if (not= \\- (n b j)) (inc d) d))\n                     (= (n a (dec i)) (n b j))    (recur (dec i) j (if (not= \\- (n a i)) (inc d) d))\n                     :else                        (recur (dec i) (dec j) (inc d))))))\n         cs (for [w ws x (remove #(= w %) ws) :when (c? w x)]\n              [w x])]\n     (loop [ac cs]\n       (let [nac (for [c ac [x y] cs :when (and (not-any? #(= y %) c) (= (last c) x))]\n                   (conj c y))]\n         (if (seq nac)\n           (recur nac)\n           (= (count (first ac)) (count ws)))))))","problem":82,"user":"4f32a7f1e4b0d6649770a095"},{"code":"(fn word-chain\n  [words]\n  (letfn [(edit-distance\n  [s1 s2]\n  (cond\n    (empty? s1) (count s2)\n    (empty? s2) (count s1)\n    :else\n    (if (= (last s1) (last s2)) (edit-distance (apply str(butlast s1)) (apply str(butlast s2)))\n      (min\n        (+ (edit-distance (apply str(butlast s1)) s2) 1 ) \n        (+ (edit-distance s1 (apply str(butlast s2))) 1 ) \n        (+ (edit-distance (apply str(butlast s1)) (apply str(butlast s2))) 1)))))]\n  \n  (letfn [(create-dist-map [coll]\n  \t\t\t\t  (letfn [(keep-dist-one [s c] (keep #(if (= 1 (edit-distance s %)) %) c))]\n\t\t\t\t\t  (reduce #(merge-with concat % {%2 (keep-dist-one %2 coll)}) {} coll)))]\n  \n  (letfn [(graph-search [e m] \n\t          (if-let [v (get m e)]\n\t\t\t\t\t\t (cons e\n\t\t\t\t\t\t     (first (keep #(if (= (count %) (dec(count (keys m)))) %)  \n\t\t\t\t\t\t       (map #(graph-search % (dissoc m e)) v))))))]\n         \n   (letfn [(step [w m] \n\t\t\t\t     (when-let [res (graph-search (first w) m)]\n\t\t\t\t       (if (= (count res) (count words)) res (recur (rest w) m))))]\n   (= (count words) (count (step words (create-dist-map words)))))))))","problem":82,"user":"4edf5dc6535d10e5ff6f5340"},{"code":"(fn [coll]\n  (letfn [(deletions [word] (for [i (range 0 (count word))\n                                  :let [[s [_  & e]] (split-at i word)]]\n                              (apply str (concat s e))))\n          (conn? [x y] (case (- (count x) (count y))\n                         1 (some #(conn? % y) (deletions x))\n                         -1 (conn? y x)\n                         0 (<= (count (remove #(apply = %) (map vector x y)))\n                               1)\n                         false))\n          (chains? [word coll]\n            (or (empty? coll)\n                (some (fn [x]\n                        (chains? x (disj coll x))                      )\n                      (filter (partial conn? word) coll))))]\n    (or (some #(chains? % (disj (set coll) %)) coll)\n        false)))","problem":82,"user":"507056b8e4b07bd6ad9b9f29"},{"code":"(fn [the-list]\n    (letfn \n      [\n  \t\t(all-ps [things]\n        (if (= 1 (count things))\n          (list things)\n            (for [head things\n                  tail (all-ps (disj (set things) head))]\n              (do\n              (cons head tail)))))            \n      ]\n      (let [\n        num-consec\n            (fn [a1 a2]\n                (count (take-while \n                 (fn [a] \n                   (and (even? (count a)) (apply = a)))            \n                 (partition-by identity (interleave a1 a2))))  \n            )\n        eval-chain-piece\n          (fn [p]\n            (let [w1 (vec (first p)) w2 (vec (last p))\n                  r1 (reverse w1) r2 (reverse w2)\n                  char-limit \n                    (- (count (last (sort-by count (vector w1 w2)))) 1)\n                  ]\n              (= char-limit (+ (num-consec w1 w2) (num-consec r1 r2)))\n            )        \n          )\n        eval-chain\n            (fn [ps]\n              (apply = true (map eval-chain-piece ps))          \n            )\n       ]\n      (last\n        (sort           \n          (map \n           (fn [p]\n            (eval-chain\n              (rest \n               (reduce \n                (fn [ws w] (conj ws [w (first (last ws))])) \n                [] \n                p ; permutation\n               )\n              )\n            )\n           ) \n          (all-ps the-list))))))\n  )","problem":82,"user":"503f872ee4b00d1a725ff2ac"},{"problem":82,"code":"(fn [ss]\n  (letfn [(diffnum [s1 s2]\n            (apply - (map count [s1 s2])))\n\n          ;use when diffnum = 0\n          (onechange? [s1 s2]\n            (= 1 (count (filter identity (map not= s1 s2)))))\n\n          ;when diffnum = 1 , in otherwords s1 is one character longer than s2\n          (onedel? [s1 s2]\n            (let [n12 (map vector (drop 1 (range)) s1 s2)\n                  nn12 (take-while (fn [[_ x y]] (= x y)) n12)\n                  n (first (last nn12))\n                  m (if (nil? n) 0 n)\n                  ms1 (drop (inc m) s1)\n                  ms2 (drop m s2)]\n              (every? identity (map = ms1 ms2))))\n          \n          (chains? [s1 s2]\n            (let [n (diffnum s1 s2)]\n              (if (= 0 n)\n                (onechange? s1 s2)\n                (if (= 1 n)\n                  (onedel? s1 s2)\n                  (if (= -1 n)\n                    (onedel? s2 s1)\n                    false)))))\n          \n          (diff [v x]\n            (filter #(not= x %) v))\n          \n          (buildChain [ss [x y]]\n            (if-not (nil? y)\n              (let [ycc (first (filter #(chains? % y) ss))]\n                (if (nil? ycc)\n                  [ss [x nil]]\n                  (let [ssc (diff ss ycc)]\n                    [ssc [x ycc]])))\n              (let [xcc (first (filter #(chains? % x) ss))]\n                (if (nil? xcc)\n                  (if (empty? ss)\n                    true\n                    false)\n                  (let [ssc (diff ss xcc)]\n                    [ssc [xcc nil]])))))\n          \n          (canChainFrom? [ss fs]\n            (loop [zs [(diff ss fs) [fs fs]]]\n              (if (= true zs)\n                true\n                (if (= false zs)\n                  false\n                  (recur (apply buildChain zs))))))\n\n          (isChain? [ss]\n            (let [t (some identity (map #(canChainFrom? ss %) ss))]\n              (if (nil? t)\n                false\n                t)))]\n    \n    (isChain? (map vec ss)))) ;vectors are way much faster than strings or sets!","user":"51e5a627e4b0efabf93c02db"},{"code":"(fn t [ws]\n  (let [\n  \t\t\tins (fn [a] (range (+ 1 (count a))) )\n\t\t\t\tpos (fn [a] (range (count a)) )\n\t\t\t\tlts (set (mapcat seq ws))\n\t\t\t\two (fn [w] (vec (seq w)))\n\t\t\t\twos (fn [ws] (map wo ws))\n    \n\t\t\t\tdr (fn [v i] (concat (take i v) (drop (+ i 1) v)))\n\t\t\t\tin (fn [v i e] (concat (take i v) (list e) (drop i v)))\n    \n\t\t\t\tdel? (fn [a b] (some #(= b %) (for [i (pos a)] (dr a i))))\n\t\t\t\tins? (fn [a b] (some #(= b %) (for [l lts i (ins a)] (in a i l))))\n\t\t\t\tsubs? (fn [a b] (some #(= b %) (for [l lts i (pos a)] (assoc a i l))))\n\t\t\t\tdif? (fn [a b]\n           (let [\n                 cb (count b)\n                 ca (count a)\n                 ]\n\t           (cond\n\t             (= cb ca) (subs? a b)\n\t             (> cb ca) (ins? a b)\n\t             :else (del? a b)\n              )\n           ))\n    \n\t\t\t\tokp? (fn [p] (dif? (second p) (first p)))\n\t\t\t\tokc? (fn [c] (every? #(okp? %) (partition 2 1 c)))\n    \n\t\t\t\tit (fn [[r ss]] (for [s ss] (list (conj r s) (disj ss s))))\n\t\t\t\tcm (fn [ws] (map first (nth (iterate #(mapcat it %) (list (list [] ws))) (count ws))))\n    \n\t\t\t\toks? (fn [s] (= true (some okc? (cm (set (wos s))))))\n        ]\n    (oks? ws)\n  ))","problem":82,"user":"4e6e10d8535d5021c1a895fd"},{"code":"(fn [words]\n  (<= (count words)\n      (count (filter (fn [[x y]]\n                       (let [longer (if (> (count x) (count y)) x y)\n                             shorter (if (= longer x) y x)\n                             non-match (first (first (filter (partial apply not=) (map vector longer (str shorter \" \")))))]\n                         (or\n                          (and (= (count x) (count y))\n                               (->> (map vector x y)\n                                    (filter (partial apply not=))\n                                    count\n                                    (>= 1)))\n                          (= longer (str shorter (last longer)))\n                          (= longer (str (first longer) shorter))\n                          (= shorter (clojure.string/replace-first longer non-match \"\")))))\n                     (for [x words y words :when (neg? (compare x y))]\n                            [x y])))))","problem":82,"user":"5201ada5e4b0b2e020a18f14"},{"code":"(fn [ws]\n  (letfn [;; make a list of all permutations of sequence things \n          (all-permutations [things]\n            (if (= 1 (count things))\n              (list things)\n              (for [head things\n                    tail (all-permutations (disj (set things) head))]\n                (cons head tail))))\n\n          ;; largest common prefix\n           (lcp [longer shorter]\n            (if (= (subs longer 0 (count shorter)) shorter)\n               shorter \n              (recur longer (subs shorter 0 (dec (count shorter))))))\n\n          ;; largest common suffix\n           (lcs [longer shorter]\n            (let [end (count longer)\n                  start (- end (count shorter))]\n              (if (= (subs longer start end) shorter) \n                 shorter\n                (recur longer (subs shorter 1 (count shorter))))))\n\n          ;; trim prefix\n           (trim-prefix [s pre] \n            (let [start (count pre) end (count s)] \n              (subs s start end)))\n\n          ;; trim suffix\n           (trim-suffix [s suf]\n            (let [start 0 end (- (count s) (count suf))] \n              (subs s start end)))\n\n          ;; indicates if two words are chainable\n          (chainable? [w1 w2] \n            (let [n1 (count w1)\n                  n2 (count w2)\n                  ord (if (> n2 n1) [w2 w1] [w1 w2])\n                  [longer shorter] ord\n                  end (count longer)\n                  start (- end (count shorter))\n                  pre (lcp longer shorter)\n                  suf (lcs longer shorter)]\n              (= 1 (count (trim-prefix (trim-suffix longer suf) pre)))))\n\n          ;; make a sequence of pairs from neighboring elements in a sequence\n          (neighbor-pairs [ws]\n            (reduce #(if (list? %1) \n                        (conj %1 (list (last (first %1)) %2)) \n                       (list (list %1 %2))) \n                    ws))\n\n          ;; is-chain?\n          (is-chain? [ws] \n            (empty? (filter false?\n              (map #(apply chainable? %1) (neighbor-pairs ws)))))]\n\n  (true? (some is-chain? (all-permutations ws)))))","problem":82,"user":"4f9c4080e4b0dcca54ed6d1a"},{"problem":82,"code":"(fn test [in]\n  (letfn [(distance [a b]\n            (cond\n              (empty? a) (count b)\n              (empty? b) (count a)\n              :else\n              (min (+ (if (= (first a) (first b))\n                         0\n                         1)\n                      (distance (rest a) (rest b)))\n                   (inc (distance (rest a) b))\n                   (inc (distance a (rest b))))))\n          (is-dist-one? [a b]\n            (= 1 (distance a b)))\n          (travel [s nexts]\n            (if (empty? nexts)\n              true\n              (some\n                (fn [candidate]\n                  (if (is-dist-one? s candidate)\n                    (travel candidate (disj (into #{} nexts)\n                                            candidate))\n                    false))\n                nexts)))]\n    ((complement nil?)\n     (some #(do\n              (travel %\n                  (disj (into #{} in) %)))\n            in))))","user":"605b49b7e4b079a07f8593f8"},{"problem":82,"code":"(fn [s]\n  (let [levenshtein-distance (fn [a b] (letfn [(ind [a b i j] (if (= (nth a (dec i)) (nth b (dec j))) 0 1)) (lev [a b i j] (if (= 0 (min i j)) (max i j) (min (+ 1 (lev a b (dec i) j)) (+ 1 (lev a b i (dec j))) (+ (ind a b i j) (lev a b (dec i) (dec j))))))] (lev a b (count a) (count b))))\n        g (reduce (fn [v c] (assoc v c (set (filter (comp (partial = 1) (partial levenshtein-distance c)) s)))) {} s)\n        hamiltonian-path-from? (fn me \n[graph cur-node prev-nodes rem-nodes]\n  (letfn [(done? [g p] (= (set (keys g)) p))\n          (next-nodes [g p c] (filter (comp not p) (g c)))]\n          (if (done? graph (conj prev-nodes cur-node)) true\n            (some #(me graph %1 (conj prev-nodes cur-node) (disj rem-nodes %1)) (next-nodes graph prev-nodes cur-node)))))]\n    ((comp not nil?) (some #(hamiltonian-path-from? g %1 #{} (set (keys (dissoc g %1)))) (set (keys g))))))","user":"5638b88de4b0bfe05bf117e9"},{"problem":82,"code":"(fn find-chain [words]\n  (let [lev (fn lev [s1 s2]\n              (cond (empty? s1) (count s2)\n                    (empty? s2) (count s1)\n                    (= (first s1) (first s2)) (lev (rest s1) (rest s2))\n                    :else (inc (min (lev (rest s1) s2)\n                                    (lev s1 (rest s2))\n                                    (lev (rest s1) (rest s2))))))\n        neighbors (fn [words word] (filter #(= (lev word %) 1) words))\n        chain (fn chain [graph visited root]\n                (let [visited (conj visited root)\n                      neigh (remove visited (graph root))]\n                  (if (= visited words)\n                    true\n                    (some (partial chain graph visited) neigh))))\n        graph (into {} (for [w words] [w (neighbors words w)]))]\n    (true? (some (partial chain graph #{}) words))))","user":"5bbdd136e4b07a9b28b0ffab"},{"code":"(fn [l]\n    (let [any? #(boolean (some true? %))\n\n          l-dist-<=1    (fn [s1 s2]\n                          (let [[l1 l2] (if (> (count s1) (count s2)) [(vec s1) (vec s2)] [(vec s2) (vec s1)])]\n                            (cond\n                              (= (count l1) (count l2))       (>= 1 (apply + (map (fn [x y] (if (= x y) 0 1)) s1 s2)))\n                              (= (count l1) (inc (count l2))) (contains?\n                                                                (->>\n                                                                  (range (count l1))\n                                                                  (map (fn [x] (filter (fn [y] (not= x y)) (range (count l1)))))\n                                                                  (map #(map l1 %))\n                                                                  (set))\n                                                                (seq l2))\n                              :else                           false)))\n\n          adjacency-map (fn [l]\n                          (apply hash-map (interleave l (map (fn [s] (set (filter #(l-dist-<=1 s %) l))) l))))\n\n          path-exists?  (fn path-exists? [f m s]\n                          (if (= s (set [f]))\n                            true\n                            (any? (map #(path-exists? % m (disj s f))\n                                       (clojure.set/intersection s (m f))))))\n\n          m             (adjacency-map l)]\n      (any? (map #(path-exists? % m (disj l %)) l))))","problem":82,"user":"525f51bde4b0cb4875a45dc8"},{"problem":82,"code":"(letfn [(subtract-non-consecutive-subseq [coll subseq]\n          (loop [coll coll subseq subseq result []]\n            (if-not (seq coll)\n              [result subseq]\n              (if (= (first coll) (first subseq))\n                (recur (rest coll) (rest subseq) result)\n                (recur (rest coll) subseq (conj result (first coll)))))))\n\n        (one-diff?\n          [word1 word2]\n          (if (= (count word1) (count word2))\n            ;; Can we make them equal with a single letter substitution?\n            (->> (map not= word1 word2)\n                 (filter identity)\n                 count\n                 (>= 1))\n            ;; Can we make them equal by deleting a character from the longer word?\n            (->> [word1 word2]\n                 (sort-by (comp (partial * -1) count))\n                 (apply subtract-non-consecutive-subseq)\n                 ((fn [[remainder unused-subseq]]\n                    (and (= 0 (count unused-subseq))\n                         (>= 1 (count remainder))))))))\n\n        (pluck-each [coll]\n          (let [coll (into [] coll)]\n            (->> (map split-at (range (count coll)) (repeat coll))\n                 (map (fn [[prefix suffix]]\n                        [(first suffix) (into prefix (rest suffix))])))))\n\n        (word-chains*\n          [head words]\n          (if-not (seq words)\n            [[head]]\n            (->> words\n                 pluck-each\n                 ;; find next words with only one diff\n                 (filter (comp (partial one-diff? head) first))\n                 ;; find any word chains that start with those words\n                 (mapcat (partial apply word-chains*))\n                 ;; put the head on each chain from the recursive call\n                 (map concat (repeat [head])))))\n\n        (word-chains\n          [words]\n          (if-not (seq words)\n            ;; There is exactly one one way to create a chain of no words: the empty\n            ;; chain. So the collection of all solutions contains 1 solution, the\n            ;; empty chain.\n            '(())\n            (->> words\n                 pluck-each\n                 (mapcat (partial apply word-chains*)))))]\n  #(not= nil (seq (word-chains %))))","user":"51f01925e4b0249c592fbdfc"},{"problem":82,"code":"(fn [s]\n    (letfn [(diff-one-char? [w1 w2]\n              (cond\n                (= (count w1) (count w2)) (= 1 (count\n                                                (filter false?\n                                                        (map #(= % %2) w1 w2))))\n                :else (let [max-w (max-key count w1 w2)\n                            min-w (min-key count w1 w2)]\n                        (some #(= (seq min-w) %)\n                              (map #(concat (take % max-w) (drop (inc %) max-w))\n                                   (range (count max-w)))))))\n\n            (chain? [ws]\n              (every? true?\n                      (map (partial apply diff-one-char?) (partition 2 1 ws))))\n\n            (permutations [s]\n              (lazy-seq\n               (if (seq (rest s))\n                 (apply concat (for [x s]\n                                 (map #(cons x %) (permutations (remove #{x} s)))))\n                 [s])))]\n      (boolean (some chain? (permutations s)))))","user":"55c5b55fe4b0e31453f649b5"},{"problem":82,"code":"(fn old-chain [iset]\n  (letfn [\n    (old [[a & as] [b & bs]]\n         (cond\n          (not a) (and b (empty? bs))\n          (not b) (and a (empty? as))\n          (= a b) (old as bs)\n          :else (or (= as bs) (= (cons a as) bs) (= as (cons b bs)))))\n    (o-c [c cs]\n        (or (empty? cs)\n         (some\n          #(o-c % (disj cs %))\n          (filter #(old c %) cs))))]\n    (boolean (some #(o-c % (disj iset %)) iset))))","user":"54b04708e4b09f271ff37d11"},{"problem":82,"code":"(letfn\n  [(same [a b] (or (= a b) (= 1 (apply + (map #(if (= % %2) 0 1) a b)))))\n   (longer [a b] (some #(= a (drop-nth % b)) (range (count b))))\n   (drop-nth [n s] (apply str (keep-indexed #(if (not= % n) %2) s)))\n   (one-different? [a b] (case \n                            (- (count b) (count a))\n                             0 (same a b)\n                             1 (longer a b)\n                             -1 (longer b a)\n                             false))\n   (permute [list] (if (not-empty list)\n                     (mapcat (fn [x] (map (fn [y] (cons x y)) (permute (remove (partial = x) list)))) list)\n                     '(())))\n   (f [perms] (some #(every? identity (map one-different? % (cons (first %) %))) perms))\n   (has-path [dict] (-> (f (permute dict)) nil? not))]\n  has-path)","user":"54cbe00ee4b057c6fda3a285"},{"problem":82,"code":"(fn word-chains [words]\n  (let [chained? (fn [w1 w2]\n                   (loop [[h1 & t1 :as w1] w1\n                          [h2 & t2 :as w2] w2]\n                     (cond\n                       (and (= h1 h2) (or t1 t2)) (recur t1 t2)\n                       (and (not= h1 h2) (= (apply str t1) w2)) :deletion\n                       (and (not= h1 h2) (= (apply str w1) (apply str t2))) :insertion\n                       (and (not= h1 h2) (= (apply str t1) (apply str t2))) :substitution)))\n        next-possibilities (fn [word xs] \n                             (let [next-link (fn [w] (when (chained? word w) w))] \n                               (keep next-link xs)))\n        form-map (fn [xs] (into {} (reduce #(conj %1 [%2 (next-possibilities %2 (remove #{%2} xs))]) [] xs)))\n        random-chain-hof (fn [tree]\n                           (fn [] (loop [out-chain [(-> tree keys rand-nth)]]\n                                    (if-let [k (->> (get tree (last out-chain))\n                                                    (remove (set out-chain))\n                                                    (#(when (seq %) (rand-nth %))))]\n                                      (recur (conj out-chain k))\n                                      out-chain))))]\n    (->> (repeatedly 100 #((random-chain-hof (form-map words))))\n         (group-by count)\n         keys\n         (apply max)\n         (#(= % (count words))))))","user":"561d8936e4b064ca9f4b16b2"},{"problem":82,"code":"(fn word-chain? [vals]\n  (if (empty? vals)\n    false\n    (let [insertion?    (fn insertion? [a b]\n                          (cond\n                            (not= (+ (count a) 1) (count b))\n                            false\n                            (let [aseq (vec (seq a))\n                                  bseq (vec (seq b))]\n                              (loop [x aseq\n                                     y bseq]\n                                (if (empty? x)\n                                  true\n                                  (if (= -1 (.indexOf y (first x)))\n                                    false\n                                    (recur (rest x) (nthrest y (.indexOf y (first x))))))))\n                            true\n                            :else\n                            false))\n          substitution? (fn substitution? [a b]\n                          (cond\n                            (not= (count a) (count b))\n                            false\n                            (= a b)\n                            false\n                            :else\n                            (let [size (count a)\n                                  as   (vec (seq a))\n                                  bs   (vec (seq b))]\n                              (reduce #(or %1 %2) (for [i (range size)]\n                                                    (= (concat (take i as) (drop (inc i) as))\n                                                       (concat (take i bs) (drop (inc i) bs))))))))\n          size          (count vals)\n          connections   (reduce (fn [res x]\n                                  (assoc res x (reduce (fn [res1 y]\n                                                         (if\n                                                           (or (insertion? x y)\n                                                               (insertion? y x)\n                                                               (substitution? x y))\n                                                           (conj res1 y)\n                                                           res1))\n                                                       []\n                                                       vals)))\n                                {}\n                                vals)\n          fills         (reduce (fn [res x]\n                                  (assoc res x false))\n                                {}\n                                vals)\n          _             (prn fills)\n          _             (prn connections)\n          path-exists?  (fn path-exists? [fills counter v]\n                          (prn counter fills v)\n                          (let [counter (inc counter)\n                                fills   (assoc fills v true)]\n                            (if (= size counter)\n                              true\n                              (reduce #(or %1 (and (not (get fills %2))\n                                                   (path-exists? fills counter %2)))\n                                      false\n                                      (get connections v)))))]\n      (reduce #(or %1 (path-exists? fills 0 %2))\n              false\n              vals))))","user":"5dc53ddee4b02f9375f4e1bd"},{"problem":82,"code":"(fn [words]\n  (let [f (first words)\n        one-edit (fn [w1 w2] (cond (and (empty? w1) (empty? w2)) false\n              (not= (first w1) (first w2))\n              (or (= (rest w1) (rest w2)) (= (seq w1) (rest w2)) (= (seq w2) (rest w1)))\n              :else (recur (rest w1) (rest w2))))\n        chain-iter (fn [chain rem-w] (if (empty? rem-w) true\n                                                        (let [ffilter (comp first filter)\n                                                              fneighbor #(ffilter (partial one-edit %) rem-w)]\n                                                          (if-let [pref (fneighbor (first chain))]\n                                                            (recur (apply vector pref chain) (disj rem-w pref))\n                                                            (if-let [suff (fneighbor (last chain))]\n                                                              (recur (conj chain suff) (disj rem-w suff))\n                                                              false)))))]\n    (boolean (some #(chain-iter [%] (disj words %)) words))))","user":"54924f64e4b0b312c081ff42"},{"code":"(fn [s]\n  (letfn [(lev [a b]\n            (letfn [(step-differences [cnt a b]\n                      (if (and (seq a) (seq b))\n                        (let [[a1 & a-rest] a\n                              [b1 & b-rest] b]\n                          (if (= a1 b1)\n                            (recur cnt a-rest b-rest)\n                            (min (step-differences (inc cnt) a b-rest)\n                                 (step-differences (inc cnt) a-rest b)\n                                 (step-differences (inc cnt) a-rest b-rest))))\n                        (+ cnt (count a) (count b))))]\n              (step-differences 0 a b)))\n          (lev1? [a b]\n            (= 1 (lev a b)))\n          (possible-chained-words [s item]\n            (filter (partial lev1? item) s))\n          (one-letter-map [s]\n            (zipmap s (map (partial possible-chained-words s) s)))\n          (brute-force-paths [mappings path word]\n            (let [next-words (get mappings word)\n                  valid-next (remove (set path) next-words)]\n              (if (seq valid-next)\n                (mapcat #(brute-force-paths mappings (conj path %) %) valid-next)\n                [path])))]\n\n    (let [word-mappings (one-letter-map s)\n          all-paths (mapcat #(brute-force-paths word-mappings [%] %) s)\n          all-words-used? #(= (count word-mappings) (count %))]\n      (if (some all-words-used? all-paths)\n        true\n        false))))","problem":82,"user":"4e80aa10535db62dc21a62b1"},{"problem":82,"code":"(fn [z] (letfn [(init [l] (apply list l))                                                                                                                                                                \n                                                                                                                                                                                                                \n               (remove-visited [visited all] (remove #(some #{%} visited) all))                                                                                                                                 \n                                                                                                                                                                                                                \n               (contrast [z1 z2 fun] (let [m (max (count z1) (count z2))]                                                                                                                                       \n                                       (filter (fn [[i x y]] (not= x y))                                                                                                                                         \n                                               (map #(list %1 %2 %3) (range m) (fun z1) (fun z2)))))                                                                                                            \n                                                                                                                                                                                                                \n               (similar? [x y] (if (= x y) false                                                                                                                                                                \n                                   (let [z1 (map str x)                                                                                                                                                         \n                                         z2 (map str y)                                                                                                                                                         \n                                         m (max (count z1) (count z2))                                                                                                                                          \n                                         p1 (contrast z1 z2 identity)                                                                                                                                           \n                                         p2 (contrast z1 z2 reverse)                                                                                                                                            \n                                         size-diff (Math/abs (- (count z1) (count z2)))]                                                                                                                        \n                                     (if (or (empty? p1) (empty? p2)) (= 1 size-diff)                                                                                                                           \n                                         (= (dec m) (+ (nth (apply min-key first p1) 0) (nth (apply min-key first p2) 0)))))))                                                                                  \n                                                                                                                                                                                                                \n               (children [node visited all] (remove-visited visited (filter (partial similar? node) all)))                                                                                                      \n                                                                                                                                                                                                                \n               (search [node visited all] (filter (comp not nil?)                                                                                                                                                              \n                                   (let [child-list (seq (children node visited all))]                                  \n                                     (lazy-seq  (cons (if (nil? child-list) (conj visited node) nil)                     \n                                                      (reduce #(concat % (search %2 (conj visited node) all)) '() child-list))))))               \n                ]                                                                                                                                                                                                \n               (let[data (init z) node (last data)]                                                                                                                                                             \n                 (not (every? false? (map (fn[node] (not (empty? (filter #(= (count z) (count %)) (search node [] data))))) data))))))","user":"52265e41e4b04e78ff2e1981"},{"problem":82,"code":"(fn has-chain? [s]\n  (letfn [(drop-nth [n s] (concat (take n s) (drop (inc n) s)))\n          (hlp [v s] (map #(cons v %) s))\n          (permutations [s]\n                        (if (empty? s)\n                          [[]]\n                          (->> (range (count s))\n                               (map #(hlp (nth s %) (permutations (drop-nth % s))))\n                               (apply concat))))\n          (close-delete [a b]\n                        (if (= (first a) (first b))\n                          (close-delete (rest a) (rest b))\n                          (or (= (rest a) b)\n                              (= (rest b) a))))\n          (close? [[a b]] (if (= (count a) (count b))\n                            (= 1 (count (remove true? (map = a b))))\n                            (close-delete (seq a) (seq b))))\n          (chain? [s] (every? true? (map close? (partition 2 1 s))))]\n    ((complement nil?) (some true? (map chain? (permutations (vec s)))))))","user":"52d00832e4b07d0d72b273b4"},{"code":"(fn _ [S]\n    (let [ld (fn ld [f s t]\n               (cond\n                 (empty? s) (count t)\n                 (empty? t) (count s)\n                 :else (min \n                         (+ (if (= (first s) (first t)) 0 1)\n                            (f f (rest s) (rest t)))\n                         (inc (f f (rest s) t))\n                         (inc (f f s (rest t)))))),\n          mld (memoize ld), \n          seq-contains? (fn [sequence item]\n                          (if (empty? sequence)\n                            false\n                            (reduce #(or %1 %2) (map #(= %1 item) sequence)))),\n          permute (fn permute [s]\n                    (let [v (into [] s)]  \n                      (if (= 1 (count v)) (list [(v 0)])\n                        (loop [i 0 perm '()]\n                          (if (= i (count v)) perm\n                            (let [s-v (into [] (concat (subvec v 0 i) (subvec v (inc i)))),\n                                  perm-s-v (permute s-v),\n                                  new-perms (map #(conj % (v i)) perm-s-v)]\n                              (recur (inc i) (into perm new-perms))))))))]\n      (let [perms (for [s (permute S)]\n                    (loop [f (first s), n (second s), r (next (next s)), v [(mld mld f n)]]\n                      (cond (empty? n) v\n                            :else (recur n (first r) (next r) (conj v (mld mld f n)))))),\n            v (into [] (repeat (count S) 1))]\n        (seq-contains? perms v)\n        )))","problem":82,"user":"4f038567535dcb61093f6b0c"},{"code":"(fn [words]\n  (letfn [(drop-1s [x] (map #(concat (take % x) (nthrest x (inc %)))  \n                            (range 0 (count x))))\n          (can-ins [x y] (contains? (set (drop-1s x)) (seq y)))\n          (can-subs [x y] (some #(apply = %) (map list (drop-1s x) (drop-1s y))))\n          (can-link [x y] (or (can-ins x y) (can-ins y x) (can-subs x y)))\n          (chain-all [chain-1 next-words rst]\n                     (= true (some #(chain-1 % (disj rst %)) next-words)))          \n          (chain-1 [word rst]\n                   (or (empty? rst)  \n                       (let [next-words (filter #(can-link word %) rst)]\n                         (and (not-empty next-words)\n                              (chain-all chain-1 next-words rst)))))]\n    (chain-all chain-1 words words)))","problem":82,"user":"515ffbfbe4b0e2be8aa20bdd"},{"problem":82,"code":"(fn[s]\n  (letfn [(ds[a b]\n      (if (= (first a) (first b)) (ds (rest a) (rest b)) [a b]))\n    (issim[a b]\n      (let [[c d] (map count (apply ds (map reverse (ds a b))))]\n        (or (= 1 c d) (= 1 (+ c d)))))\n    (mut[i s]\n      (map #(let [[a b] (split-at % s)] (concat a [i] b)) (range (inc (count s)))))\n    (perm[s]\n      (if (seq s)\n        (mapcat (partial mut (first s)) (perm (rest s)))\n        [[]]))\n    (iss[s]\n      (every? (partial apply issim) (map vector s (rest s))))]\n    (if (some iss (perm s)) true false)))","user":"56824e1be4b0945ebc182a91"},{"problem":82,"code":"(fn [ws]\n  (letfn [(snug [uno dos]\n            (loop [[up & ur :as u] uno [dp & dr :as d] dos err 0]\n              (let [uc (count u) dc (count d)]\n                (cond (or (nil? up) (nil? dp))\n                          (let [diff (Math/abs (- uc dc))]\n                            (and (< diff 2)\n                                (or (and (zero? err) (= 1 diff))\n                                    (and (= err 1) (zero? diff)))))\n                      (= up dp) (recur ur dr err)\n                      (not= err 0) false\n                      (= uc dc) (recur ur dr (inc err))\n                      (< uc dc) (recur ur (rest dr) (inc err))\n                      (< uc dc) (recur ur  (rest dr) (inc err))\n                      :else  (recur (rest ur) dr (inc err))))))\n          (pms [xs]\n            (cond (empty? xs) ()\n                  (= (count xs) 1) (list (seq xs))\n                  :else (for [x xs\n                              y (pms (disj (set xs) x))]\n                          (do\n                            (cons x y)))))]\n    (->> (pms ws)\n         (map (partial partition 2 1))\n         (map (fn [ws] (map (partial apply snug) ws)))\n         (map (partial every? true?))\n         (some true?)\n         ((complement nil?)))))","user":"4f2baf1ae4b0d6649770a04c"},{"code":"#(< (mod (.hashCode %) 13) 5)","problem":82,"user":"5336a339e4b0e30313ee6c7d"},{"code":"(fn word-chain? [words]\n  (letfn [(similar? [w1 w2]\n            (if (= (count w1) (count w2))\n              (<= (count (filter (fn [[a b]] (not= a b)) (map vector w1 w2))) 1)\n              (let [longerw (if (< (count w1) (count w2)) w2 w1)\n                    shorterw (if (< (count w1) (count w2)) w1 w2)]\n                (if (some #{shorterw}\n                          (for [i (range (count longerw))]\n                            (str (subs longerw 0 i) (subs longerw (inc i)))))\n                  true\n                  false))))\n          (make-graph [words]\n            (into {}\n                  (for [s words] \n                    [s (filter #(similar? % s) words)])))\n          (find-paths [graph start seen] \n            (if (seen start) \n              seen\n              (for [n (graph start)] \n                (find-paths graph n (conj seen start)))))]\n    (not (nil? (some (fn [start] (some #(= words %) \n                                      (flatten (find-paths (make-graph words) start #{})))) \n                     words)))))","problem":82,"user":"512eb723e4b0b740abc5982b"},{"code":"(fn [words]\r\n  (letfn [(orfn [x y] (or x y))\r\n          (dist [a b]\r\n            (let [ca (count a)\r\n                  cb (count b)\r\n                  m (max ca cb)\r\n                  fa (repeat (- m ca) :_)\r\n                  fb (repeat (- m cb) :_)\r\n                  ins-at #(let [[x y] (split-at %3 %1)] (concat x %2 y))\r\n                  dist #(count (remove true? (map = %1 %2)))]\r\n              (apply min \r\n                     (map #(dist (ins-at a fa %) (ins-at b fb %)) (range m)))))\r\n          (chain [w ws]\r\n            (let [ch (remove #(not= 1 (dist w %)) ws)]\r\n              (cond (nil? (seq ws)) true\r\n                    (and (seq ws) (nil? (seq ch))) false\r\n                    :else\r\n                      (reduce orfn\r\n                              (map (fn [c] (chain c (remove #(= c %) ws))) ch)))))\r\n          (chain? [ws] \r\n            (reduce orfn (map (fn [w] (chain w (remove #(= w %) ws))) ws)))]\r\n  (chain? words)))","problem":82,"user":"4f58d92fe4b0a7574ea71858"},{"problem":82,"code":"(fn [s]\n    (letfn [(graphcon [s]\n              \"is the graph connected?\"\n              (letfn [(check-all [o s]\n                        (let [r (group-by #(or (= (first %) (second o)) (= (second %) (first o)) (= (first %) (first o))) s)]\n                          [(cons o (get r true)) (get r false)]))]\n                (let [[a b] (check-all (first s) (rest s))]\n                  (loop [a a b b]\n                    (cond (empty? b) true\n                          (empty? a) false\n                          :else (let [[a1 b1] (check-all (first a) b)]\n                                  (recur (concat (rest a) (rest a1)) b1)))))))\n            (diff [s1 s2]\n              (letfn [(fd [f1 f2] (filter #((complement contains?) f1 %) f2))]\n                (+ (count (fd s1 s2)) (count (fd s2 s1)))))\n\n            (matchit [s1 s2]\n              (loop [t1 s1 t2 s2 c 0]\n                (if (or (empty? t1) (empty? t2)) c\n                    (let [[f1 & r1] t1\n                          [f2 & r2] t2]\n                      (cond (= f1 f2) (recur r1 r2 c)\n                            (> (count t1) (count t2)) (recur r1 t2 (inc c))\n                            (> (count t2) (count t1)) (recur t1 r2 (inc c))\n                            :else (recur r1 r2 (inc c)))))))\n\n            (diff [s1 s2]\n              (let [cd (Math/abs (- (count s1) (count s2)))]\n                (if (> cd 1) false\n                    (>= 1 (matchit s1 s2)))))\n\n            (diffs [s]\n              (loop [o (first s) t (rest s) ac []]\n                (if (empty? t) ac\n                    (recur (first t) (rest t) (cons [o (map (fn [e] [e (diff e o)]) t) ] ac)))))\n\n            (pair-links [m]\n              (partition 2 (flatten (for [[o r] m] (map (fn [s] [o (first s)]) (filter #(true? (second %)) r))))))\n\n            (degrees [s]\n              (let [d (count (filter odd? (map (fn [a] (count (filter #(contains? (set %) a) s))) (set (flatten s)))))]\n                d))]\n      (let [pl (-> s diffs pair-links)]\n        (and (graphcon pl) (< (degrees pl) (count s))))))","user":"4f3ec266e4b0e243712b1f8c"},{"code":"(fn [S]\n  (letfn [\n    (difference [A B]\n      (reduce disj A B))\n\n    (union [A & Bs]\n      (reduce (partial reduce conj) A Bs))\n\n    (intersection [A B]\n      (reduce #(into %1 (A %2)) #{} B))\n\n    (all-but-one? [lst]\n      (= 1 (reduce + (map #(if % 0 1) lst))))\n    \n    (take-similar [pred S x]\n      (set (filter (partial pred x) S)))\n\n    (connections [pred S]\n      (reduce #(assoc %1 %2 \n        (take-similar pred S %2)) {} S))\n\n    (connected? [C]\n      (loop [kwn (-> C first key list set), \n             unk (-> C rest keys set)]\n        (if (empty? unk)\n          true\n          (let [bnd (apply union (map C kwn))]             \n            (if (empty? (intersection bnd unk))        \n              false                                               \n              (recur (union kwn bnd)                       \n                     (difference unk bnd)))))))\n  \n    (tracable? [C] ; very hard problem ... cheat\n      (> 3 (count (filter #(< % 2) \n        (map #(count (val %)) C)))))\n\n    (inserted? [A B]\n      (loop [a (seq A), b (seq B)]\n        (if (= (first a) (first b))                               \n          (recur (rest a) (rest b))                               \n          (= a (rest b)))))\n\n    (deleted? [A B]\n      (inserted? B A))\n\n    (word-chain [S]\n      (letfn [\n        (pred [a b]\n          (cond\n            (= (count a) (count b)) ; substitution\n            (all-but-one? (map = a b)),\n\n            (< (count a) (count b)) ; insertion\n            (inserted? a b)\n\n            (> (count a) (count b)) ; deletion\n            (deleted? a b)))]\n\n        (connections pred S)))]\n\n  (let [C (word-chain S)]\n    (and (connected? C) (tracable? C)))))","problem":82,"user":"4faa9593e4b081705acca1f9"},{"code":"(fn [s] (not (empty? (filter\n  #(let [dst (fn levdist [s t]\n          (if (empty? s) (count t)\n\t        (if (empty? t) (count s)\n\t        (min \n\t          (+ 1 (levdist (subs s 1) t))\n\t          (+ 1 (levdist s (subs t 1)))\n\t          (+ (if (= (first s) (first t)) 0 1)\n\t             (levdist (subs s 1) (subs t 1)))))))]\n      (not (nil? (reduce \n                    (fn [i1 i2] \n                      (if (nil? i1) \n                        nil\n                        (if (= 1 (dst i1 i2))\n                          i2\n                          nil)))\n                    %1))))\n  ((fn perm [l]\n    (if (= 1 (count l))\n      [l]\n      (mapcat \n        #(map\n          (partial cons %1)\n          (perm (remove #{%1} l)))\n        l)))\ns)))))","problem":82,"user":"5034b0e1e4b062bc5d7ae167"},{"problem":82,"code":"(fn [s]\n  (letfn [(permutations [r s]\n            (if (seq s)\n              (mapcat #(permutations (conj r %) (disj s %)) (seq s))\n              [r]))\n          (chainable? [x y]\n            (let [diffs (fn [x y] (<= (reduce + (map #(if (= %1 %2) 0 1) x y)) 1))\n                  drop-char (fn [n s] (str (subs s 0 n) (subs s (inc n) (count s))))\n                  drop-variants (fn [s] (map #(drop-char % s) (range (count s))))\n                  deletions (fn [l s] (some #(= s %) (drop-variants l)))\n                  cx (count x)\n                  cy (count y)]\n              (cond\n                (= cx cy) (diffs x y)\n                (= cx (inc cy)) (deletions x y)\n                (= (inc cx) cy) (deletions y x))))\n          (chain? [s]\n            (reduce #(when (chainable? %1 %2) %2) s))]\n    (boolean\n      (some chain? (permutations [] s)))))","user":"4f05ea25535dcb61093f6c02"},{"problem":82,"code":"(fn word-chain? [words]\n  (letfn [(levenshtein-distance [seq-1 seq-2]\n            (cond (empty? seq-1) (count seq-2)\n                  (empty? seq-2) (count seq-1)\n                  (= (first seq-1) (first seq-2)) (levenshtein-distance (rest seq-1) (rest seq-2))\n                  :else (inc (min (levenshtein-distance (rest seq-1) seq-2)\n                                  (levenshtein-distance seq-1 (rest seq-2))\n                                  (levenshtein-distance (rest seq-1) (rest seq-2))))))\n          (neighbors [word words]\n            (filter #(= (levenshtein-distance word %) 1) words))\n          (chain [adjacency-map visited-set node]\n            (let [visited-set (conj visited-set node)\n                  neighbors-remaining (remove visited-set (adjacency-map node))]\n              (if (= visited-set words) \n                true\n                (some (partial chain adjacency-map visited-set) neighbors-remaining))))]\n    (let [adjacency-map (into {} (for [w words] [w (neighbors w words)]))]\n      (true? (some (partial chain adjacency-map #{}) words)))))","user":"58ed713de4b056aecfd47d84"},{"problem":82,"code":"(fn [words]\n  (letfn [(make-patterns [word]\n            (cons\n             (re-pattern (str \"^\" word \".?\" \"$\"))\n             (mapcat\n              (fn [i]\n                [(re-pattern (str \"^\" (subs word 0 i) \".?\" (subs word (inc i)) \"$\"))\n                 (re-pattern (str \"^\" (subs word 0 i) \".?\" (subs word i) \"$\"))])\n              (range (count word)))))\n          (chained? [h t]\n            (and (not= h t)\n                 (some #(re-seq % t) (make-patterns h))))\n          (followers-in [words h]\n            [h (filter (partial chained? h) words)])\n          ]\n    (let [nodes (apply conj {} (map (partial followers-in words) words))]\n      (letfn [(find-path [path word]\n                (let [followers (nodes word)]\n                  (if (= (count path) (count words))\n                    true\n                    (if-let [next-steps (seq (remove (set path) followers))]\n                      (boolean (some identity (map #(find-path (conj path %) %) next-steps)))\n                      false))))]\n        (boolean (some identity (map #(find-path [%] %) words)))))))","user":"51852961e4b0da5a5be3babb"},{"code":"(fn [words]\n    (letfn [\n            (connectable? [w1 w2]\n              (cond\n                (empty? w1) (= 1 (count w2))\n                (empty? w2) (= 1 (count w1))\n                (= (first w1) (first w2)) (recur (rest w1) (rest w2))\n                :else (or\n                        (= (next w1) (next w2))\n                        (= (next w1) (seq w2))\n                        (= (seq w1) (next w2)))))\n            (can-cover-all? [starting-points\n                             transitions]\n              (loop [starting-points starting-points\n                     transitions transitions]\n                (if (empty? starting-points)\n                  false\n                  (let [[node reachable toreach] (first starting-points)\n                        other-points (rest starting-points)\n                        next-nodes (transitions node)\n                        next-new-nodes (filter toreach next-nodes)\n                        next-points (for [n next-new-nodes]\n                                      [n (conj reachable n) (disj toreach n)])]\n                    (if (empty? toreach)\n                      true\n                      (recur (concat other-points next-points) transitions))))))\n           ]\n      (let [transitions (into {} (for [w words] [w (filter #(connectable? w %) words)]))\n            startings (for [w words]\n                        [w #{w} words])]\n        (can-cover-all? startings transitions))))","problem":82,"user":"5165a235e4b079ad97ec44ac"},{"problem":82,"code":"(fn word-chains [words]\n(let [\n   in?  (fn [seq elm]  (some #(= elm %) seq))\n\n   levenshtein (fn lev [s1 s2]\n    (if (or (empty? s1) (empty? s2)) (max (count s1) (count s2))\n      (let [fs1 (first s1)\n            fs2 (first s2)\n            rs1 (rest s1)\n            rs2 (rest s2)]\n        (cond\n          (= fs1 fs2) (lev rs1 rs2)\n          :else (inc (min (lev rs1 rs2) (lev s1 rs2) (lev rs1 s2)))))))\n\n    almost-twin? (fn [w1 w2] (or (some nil? [w1 w2]) (= (levenshtein w1 w2) 1)))\n\n   try-some (fn try-some [c v]\n    (if (= c (count v))\n      true\n      (loop [ws (for\n                  [w words :when (and (not (in? v w)) (or (empty? v) (almost-twin? w (last v))))]\n                  w)]\n        (cond\n          (empty? ws) false\n          (try-some c (conj v (first ws))) true\n          :else (recur (rest ws))))))]\n\n  (try-some (count words) [])))","user":"525b142fe4b0cb4875a45d05"},{"problem":82,"code":"(fn [ws]\n         (letfn [(is-chain-pair [w1 w2]\n                   (let [l1 (count w1)\n                         l2 (count w2)\n                         wt (fn [x1 x2]\n                              (= x2\n                                 (let [index (count (take-while (fn [[a b]] (= a b))\n                                                                (map vector x1 (concat x2 \" \"))))]\n                                   (apply str (concat (take index x1) (drop (inc index) x1))))))]\n                     (or\n                      (and (= l1 l2) (= 1 (count (filter false? (map #(= %1 %2) w1 w2)))))  ;;substitution\n                      (and (= 1 (- l1 l2)) (wt w1 w2))           ;; subtraction\n                      (and (= 1 (- l2 l1)) (wt w2 w1)))))        ;; addition\"  \n                 (is-chain [w ws]\n                   (if (empty? ws) true\n                       (for [x ws]\n                         (if (is-chain-pair w x)\n                           (is-chain x (disj ws x))))))]\n  (if (some true? (flatten (for [x ws] (is-chain x (disj ws x)))))\n    true\n    false)))","user":"5da71eaee4b000c986472c15"},{"code":"(fn [sw]\n  (letfn [(ins [w i c] (str (subs w 0 i) c (subs w i)))\n          (del [w i] (str (subs w 0 i) (subs w (inc i))))\n          (nw [] (map char (range 97 123)))\n          (oc? [w w2] (= 1 (count ((group-by identity (map #(= % %2) w w2)) false))))\n          (words-sub [w sw] (set (filter #(and (= (count %) (count w)) (oc? w %)) sw)))\n          (words-del [w] (set (for [i (range (count w))] (del w i))))\n          (words-add [w] (for [n (nw) i (range 0 (inc (count w)))] (ins w i n)))\n          (words [w sw] (filter sw (reduce into #{} [(words-add w) (words-del w) (words-sub w sw)])))\n          (cp-from [p w]\n            (loop [nv [w] v #{} m p rs []]\n              (if (empty? nv)\n                (concat rs (into [] v))\n                (let [n (peek nv)]\n                  (if n\n                    (let [c (m n)\n                          ns (pop nv)\n                          nnv (conj v n)]\n                      (if c\n                        (recur (into ns c) nnv (dissoc m n) rs)\n                        (let [fv (set (filter #(some (set (p %)) ns) nnv))]\n                          (recur ns fv m (conj rs (seq nnv))))))\n                    rs)))))\n          (w? [sw]\n            (let [p (reduce (fn [m e] (assoc m e (words e (set (remove #{e} sw))))) {} sw)\n                  cp (mapcat #(cp-from p %) sw)\n                  fcp (filter #(= (count sw) (count %)) cp)]\n              (not (empty? fcp))))]\n    (w? sw)))","problem":82,"user":"4ee9ddb8535d93acb0a66896"},{"code":"(fn [s] \n  (letfn \n    [ (diff [a b] \n        (count (filter false? (map = a b))))\n      (shorten [w] \n        (for [p (range (count w))] \n          (let \n            [[a b] (split-at p w)] \n            (apply str (concat a (rest b))))))\n      (similar [a b] \n        (condp = (compare (count a) (count b)) \n          0 (= 1 (diff a b))\n          -1 (some #{a} (shorten b))\n          1 (similar b a)))\n      (find-next [a s] \n        (let \n          [ s (disj s a)\n            sim (filter #(similar a %) s)] \n          (if (empty? sim) \n            (count s)\n            (for [b sim] (find-next b s)))))]\n    (true?\n      (some zero? \n        (flatten \n          (for [a s] (find-next a s)))))))","problem":82,"user":"4f991ec1e4b0dcca54ed6cfb"},{"problem":82,"code":"(fn ladder-answer\n  [input]\n  (letfn\n      [(permute?\n         [a b]\n         (cond\n           (empty? a) true\n           (= 1 (Math/abs (- (count a) (count b))))\n           (let [s1 (max-key count a b)\n                 s2 (min-key count a b)]\n             (re-find (re-pattern (apply str (interpose \".*\" s2))) s1))\n           (= (count a) (count b))\n           (->>\n            (map compare a b)\n            (filter (partial not= 0))\n            count\n            (= 1))\n           :else false\n           ))\n       (ladder? [word others]\n         (if (empty? others) true\n             (boolean (some #(and true %)\n                            (for [m others\n                                  :when (permute? word m)]\n                              (do (println (str m \" \"(disj others m)))\n                                  (ladder? m (disj others m))))))))\n       ]\n    (ladder? \"\" input)))","user":"5f838122e4b01aacbe7a2715"},{"code":"(fn [wset]\r\n  (let [lev-dist #(last \r\n                    (reduce \r\n                      (fn [[x & q] c]\r\n                        (reductions\r\n                          (fn [z [c' x y]]\r\n                            (min (inc z) (inc y) (+ x (if (= c' c) 0 1))))\r\n                          (inc x) (map list % (cons x q) q)))\r\n                      (range (inc (count %))) %2))\r\n        search (fn search [[x & chain] words]\r\n                 (if (empty? words)\r\n                   true\r\n                   (some true? (for [w words\r\n                               :when (= 1 (lev-dist w x))]\r\n                           (search (concat [w x] chain) (disj words w))))))]\r\n    (boolean (some true? (for [w wset] (search [w] (disj wset w)))))))","problem":82,"user":"509c03f3e4b085ae113522a8"},{"code":"(letfn [(l? [x y]\r\n          (cond\r\n            (= (count x) 0) (count y)\r\n            (= (count y) 0) (count x)\r\n            (= (first x) (first y)) (l? (rest x) (rest y))\r\n            :else (min (inc (l? (rest x) y)) (inc (l? x (rest y))) (inc (l? (rest x) (rest y))))))\r\n        (l-table [l]\r\n          (for [x (range (count l))]\r\n            (for [y (range (count l))]\r\n               (l? (nth l x) (nth l y)))))\r\n        (some-perm? [n f]\r\n          (letfn [(gen-perm-states [l e]\r\n                    (if (empty? l)\r\n                        (f e)\r\n                        (some (fn [x] (gen-perm-states (remove #(= % x) l) (cons x e))) l)))]\r\n            (gen-perm-states (range n) ())))\r\n        (has-route? [tbl]\r\n          (println tbl)\r\n          (some-perm? (count tbl) (fn [x] (every? (fn [idx] (= (nth (nth tbl (nth x idx)) (nth x (inc idx))) 1)) (range (dec (count tbl)))))))]\r\n  #(= (has-route? (l-table (seq %))) true))","problem":82,"user":"4f474f43e4b0d56e7bb92bb7"},{"problem":82,"code":"(fn word_chains [ss]\n    (let\n    [\n        diff_by_insert_or_delete_helper?\n            (fn [w1 w2 index1 index2 delta] {:pre (= (- (count w2) (count w1)) 1)}\n                (let [c1 (get w1 index1) c2 (get w2 index2)]\n                    (cond\n                        (and (>= index1 (count w1)) (>= index2 (count w2))) (= delta 1) ; reached the ends of both strings\n                        (= c1 c2) (recur w1 w2 (inc index1) (inc index2) delta) ; strings are the same, continue\n                        (= delta 0) (recur w1 w2 index1 (inc index2) (inc delta)) ; first difference in strings, continue assuming deletion of the larger word\n                        (> delta 0) false ; more than one difference detected\n                    )\n                )\n            )\n        diff_by_insert_or_delete?\n            (fn [w1 w2]\n                (let\n                [ [w1 w2] (sort-by count [w1 w2]) ]\n                (cond\n                    (not= (- (count w2) (count w1)) 1) false\n                    :otherwise (diff_by_insert_or_delete_helper? w1 w2 0 0 0)\n                )\n                )\n            )\n        diff_by_sub_helper?\n            (fn [w1 w2 index delta] {:pre (= (count w2) (count w1))}\n                (let [c1 (get w1 index) c2 (get w2 index)]\n                    (cond\n                        (>= index (count w1)) (= delta 1) ; reached the ends of both strings\n                        (= c1 c2) (recur w1 w2 (inc index) delta) ; strings are the same, continue\n                        (= delta 0) (recur w1 w2 (inc index) (inc delta)) ; first difference in strings, continue assuming a substitution\n                        (> delta 0) false ; more than one difference detected\n                    )\n                )\n            )\n        diff_by_sub?\n            (fn [w1 w2]\n                (cond\n                    (not= (count w2) (count w1)) false\n                    :otherwise (diff_by_sub_helper? w1 w2 0 0)\n                )\n            )\n        edit_distance_one?\n            (fn [w1 w2] (or (diff_by_insert_or_delete? w1 w2) (diff_by_sub? w1 w2)) )\n        hamiltonian_helper?\n            (fn f [[g chain total] curr] {:pre (set? chain)}\n                (cond\n                    (= total (count chain)) true\n                    (chain curr) false\n                    :otherwise (some identity (map\n                        #(f [g (conj chain curr) total] %)\n                        (g curr)\n                    ))\n                )\n            )\n        hamiltonian?\n            (fn [g] (true? (some identity (map (fn [k] (hamiltonian_helper? [g #{} (count g)] k)) (keys g)))))\n        generate_adjacency_map\n            (fn [ss pred] {:pre (fn? pred)}\n                (reduce (fn [ret k] (assoc ret k (into [] (filter #(pred k %) ss)))) {} ss)\n            )\n    ]\n    (hamiltonian? (generate_adjacency_map ss edit_distance_one?))\n    )\n)","user":"5db7376fe4b010eb3c36cd43"},{"code":"(let [lev (memoize (fn lev [l r]\n                      (cond\n                       (empty? l) (count r)\n                       (empty? r) (count l)\n                       :else (if (= (first l) (first r))\n                               (lev (next l) (next r))\n                               (min (inc (lev (next l) r))\n                                    (inc (lev l (next r)))\n                                    (inc (lev (next l) (next r))))))))\n       word-chain (fn word-chain [word words]\n                    (if (empty? words)\n                      [[word]]\n                      (seq (for [w words\n                                 :when (= (lev word w) 1)\n                                 chain (word-chain w (disj words w))]\n                             (cons word chain)))))]\n   (fn [words]\n     (boolean (some #(word-chain % (disj words %)) words))))","problem":82,"user":"4eae5fe4535d7eef30807325"},{"problem":82,"code":"(fn [xs]\n  (let [drop-nth (fn [coll index]\n                   (concat (take index coll) (drop (inc index) coll)))\n        is-edge? (fn [x y]\n                   (case (- (count x) (count y))\n                     0 (= (->> (map = x y) (filter false?) count) 1)\n                     1 (some (partial = y)\n                             (map #(apply str (drop-nth x %))\n                                  (-> x count range)))\n                     -1 (recur y x)\n                     false))\n        is-path? (fn [xs]\n                   (every? true? (map is-edge? (rest xs) (drop-last xs))))\n        permutation (fn f [xs]\n                      (if (empty? xs)\n                        ['()]\n                        (apply concat\n                               (map #(map (partial cons %)\n                                          (f (disj xs %)))\n                                    xs))))]\n    (true? (some identity (map is-path? (permutation xs))))))","user":"54c5cc17e4b045293a27f624"},{"problem":82,"code":"(fn [w] \n  (letfn [(word-chain\n           ([words]\n            (let [words (for [w words]\n                          (word-chain (disj words w) [w]))]\n              (if (some true? (flatten words)) true false)))\n           ([words chain]\n            (if (not-empty words)\n              (let [l (last chain)]\n                (for [w words]\n                  (if (matcher [l w])\n                    (word-chain (disj words w) (conj chain w)))))\n              true)))\n\n          (matcher\n           [words]\n           (let [[w1 w2] (sort-by count < words)\n                 min-matches (dec (apply max (map count words)))\n                 matches (for [l w1]\n                           (re-seq (re-pattern (str l)) w2))]\n             (= min-matches\n                (->> matches\n                     (remove nil?)\n                     count))))]\n    (word-chain w)))","user":"523578efe4b0a643f2dcb74c"},{"problem":82,"code":"(fn [ws]\n  (letfn \n    [(lev [w1 w2]\n       (let [l1 (count w1) l2 (count w2)]\n         (cond \n           (zero? l1) l2\n           (zero? l2) l1\n           :else\n           (let [cost (if (= (first w1) (first w2)) 0 1)]\n             (min \n               (inc (lev (rest w1) w2))\n               (inc (lev w1 (rest w2)))\n               (+ cost (lev (rest w1) (rest w2))))))))\n     (expand? [s w]\n       (let [l (last s)]\n         (and (= (lev l w) 1))))\n     (eval-ss [acc _]\n       (if (empty? acc) acc\n         (for [s acc w ws :when (and (not (some #(= w %) s)) (expand? s w))] \n           (conj s w))))]\n    (let [ss (for [x ws y ws :when (and (not= x y) (= (lev x y) 1))] [x y])]\n      (not (empty? (reduce eval-ss ss (range (- (count ws) 2))))))))","user":"57d9bca1e4b0bd073c202405"},{"code":"(fn [l] (letfn [(lev [x1 x2]\r\n        (let [match (fn[x y] (if (= (nth x1 x) (nth x2 y)) 1 0))\r\n          ld    (fn ld [x y c]\r\n            (cond \r\n             (c [x y]) [(c [x y]) c]\r\n             (< x 0) [(- y x) (assoc c [x y] (- y x))]\r\n             (< y 0) [(- x y) (assoc c [x y] (- x y))]\r\n             :else \r\n              (let [[d1 c1] (ld (dec x) (dec y) c)\r\n                   [d2 c2] (ld (dec x)      y  c1) \r\n                   [d3 c3] (ld      x  (dec y) c2)\r\n                   c c3\r\n                   v (inc (min (- d1 (match x y)) d2 d3))]\r\n             [ v (assoc c [x y] v )])))]\r\n        (first (ld (dec (count x1)) (dec (count x2)) {}))))\r\n        (d [x y] (= (lev x y) 1))\r\n        (c [x]  (every? identity (map d x (rest x))))\r\n        (m [s] \r\n          (loop [i 0 r [[[] #{}]]]\r\n              (if (= i (count s)) (map first r)\r\n                (recur (inc i) (mapcat (fn [[x y]] \r\n                                          (filter (complement nil?) \r\n                                            (map #(when-not (y %) (identity [(conj x %) (conj y %)])) \r\n                                               s)))r)))))\r\n\r\n        ]\r\n   (if (some c (m (into [] l))) true false)))","problem":82,"user":"4deff9f9535d08e6dec9fe15"},{"code":"(fn wc[words]\n  (letfn [\n\t\t(ld[s t]\n\t\t\t(let [m (count s)\n\t\t\t\t\t\tn (count t)\n\t\t\t\t\t\td (into (zipmap (map #(list % 0) (take (inc m) (range))) (range))\n\t\t\t\t\t\t\t\t\t\t(zipmap (map #(list 0 %) (take (inc n) (range))) (range)))]\n\t\t\t\t(if (zero? (min m n)) \n\t\t\t\t\t(max m n)\n\t\t\t\t\t(loop [j 1 i 1 d d] \n\t\t\t\t\t\t(let [si (get s (dec i))\n\t\t\t\t\t\t\t\t\ttj (get t (dec j))\n\t\t\t\t\t\t\t\t\tnj (if (>= i m) (inc j) j)\n\t\t\t\t\t\t\t\t\tni (if (>= i m) 1 (inc i))]\n\t\t\t\t\t\t\t(if (< n j) \n\t\t\t\t\t\t\t\t(get d [m n]) \n\t\t\t\t\t\t\t\t(if (= si tj) \n\t\t\t\t\t\t\t\t\t(recur nj ni (assoc d [i j] (get d [(dec i) (dec j)]))) \n\t\t\t\t\t\t\t\t\t(recur nj ni (assoc d [i j] (inc (min (get d [(dec i)      j])\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(get d [(dec i) (dec j)])\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(get d [     i  (dec j)]))))))))))))\n\t\t(longest-chain[word other]\n\t\t\t\t\t\t(let [sims (filter #(= 1 (ld %1 word)) other)] \n\t\t\t\t\t\t\t(if (not-empty sims)\n\t\t\t\t\t\t\t\t(loop [sims sims] \n\t\t\t\t\t\t\t\t\t(let [f (first sims)\n\t\t\t\t\t\t\t\t\t  \t\to (disj other f)] \n\t\t\t\t\t\t\t\t\t  (if (or (empty? o) (longest-chain f o)) \n\t\t\t\t\t\t\t\t\t\t\ttrue \n\t\t\t\t\t\t\t\t\t\t\t(if (not-empty sims)\n\t\t\t\t\t\t\t\t\t\t\t\t(recur (next sims))\n\t\t\t\t\t\t\t\t\t\t\t\tfalse))))\n\t\t\t\t\t\t\t\tfalse)))] \n\t\t(loop [w words]\n\t\t\t(let [f (first w)\n\t\t\t\t\t\to (disj words f)\n\t\t\t\t\t\tl (longest-chain f o)] \n\t\t\t\t(if l\n\t\t\t\t\ttrue\n\t\t\t\t\t(if (not-empty w)\n\t\t\t\t\t\t(recur (next w))\n\t\t\t\t\t\tfalse))))))","problem":82,"user":"4f1fd734535d64f6031464a5"},{"problem":82,"code":"(fn [words]\n   (letfn [(levenstein-distance [newStr oldStr]\n             (let [n (count newStr) m (count oldStr)]\n              (cond\n               (= 0 n) m\n               (= 0 m) n\n               :else\n               (let [prev-col (transient (vec (range (inc m)))) col (transient [])]\n                 (dotimes [i n]\n                   (assoc! col 0 (inc i))\n                   (dotimes [j m]\n                     (assoc! col (inc j)\n                             (min (inc (get col j))\n                                  (inc (get prev-col (inc j)))\n                                  (+ (get prev-col j) (if (= (get newStr i) (get oldStr j)) 0 1)))))\n                   (dotimes [i (count prev-col)]\n                     (assoc! prev-col i (get col i))))\n                 (last (persistent! col))))))\n           (permutations [s]\n              (lazy-seq\n               (if (seq (rest s))\n                 (apply concat (for [x s]\n                     (map #(cons x %) (permutations (remove #{x} s)))))\n                 [s])))\n           \n            (get-distances [acc curr more]\n              (if (seq (rest more))\n                (get-distances (conj acc (levenstein-distance curr (first more))) (first more) (rest more))\n                (conj acc (levenstein-distance curr (first more)))))\n           \n            (is-chain? [distances]\n              (every? #{1} distances))\n           \n            (is-chainable? [combinations]\n              (let [curr (first combinations)\n                    is-chain (is-chain? (get-distances [] (first curr) (rest curr)))]\n                  (if (seq (rest combinations))\n                    (if is-chain\n                     true\n                     (is-chainable? (rest combinations)))\n                   is-chain)))]\n     (is-chainable? (permutations words))))","user":"53214efbe4b09d4e7a9b54b2"},{"code":"(fn [ c ]\n    (letfn \n      [\n       (mld [ s t ] (letfn [(ld [ s t f] (cond \n                                     (zero? (count s)) (count t)\n                                     (zero? (count t)) (count s)\n                                     :else (min \n                                             (+ 1 (f (rest s) t f))\n                                             (+ 1 (f s (rest t) f))\n                                             (+ (f (rest s) (rest t) f)\n                                                (if (= (first s) (first t)) 0 1))\n                                           )))\n                     \n                    ]\n                 (let [mld (memoize ld)] (mld s t mld))\n              ))\n       ]\n      (let \n        [mmld (memoize mld)]\n        (letfn [\n       (chain [ d curword col ] \n              (loop [ totest col ]\n                (if (empty? totest)\n                  false ; we got back to here with no words found\n                  (let [ firstword (first totest) restwords (rest totest) ]\n                    ; it chains\n                    (if (= 1 (mmld curword firstword))\n                      (if (empty? (clojure.set/difference col #{ firstword }))  ; this is the last word in the chain\n                        true \n                        (if (chain (inc d) firstword (clojure.set/difference col #{ firstword })) ; can we form a further chain\n                          true\n                          (recur restwords))\n                        )\n                      ; this firstword didnt match, try another\n                      (recur restwords)\n                      )))))\n       ]\n  \n      (loop [col c]\n        (if (empty? col)\n          false\n          (if (chain 0 (first col) (clojure.set/difference c #{ (first col) }))\n            true\n            (recur (rest col)))))))))","problem":82,"user":"50956c2be4b087f34d351ab2"},{"code":"#(> 0.5 (rand) #_ %)","problem":82,"user":"4e307313535deb9a81d77f14"},{"code":"(fn [W]\n  (let [C concat\n        M map\n        m (zipmap W\n            (M (fn [s]\n                 (set\n                   (apply C\n                     (for [[a b] (M #(split-at % s) (range (+ 1 (count s))))\n                           c (M char (range 97 123))]\n                       [(C a [c] b)\n                        (C a [c] (next b))\n                        (C a (next b))\n                        (C a b)])))) W))]\n    ((fn G [s X]\n       (or\n         (empty? X)\n         (not (not-any?\n                #(G % (disj X %))\n                (filter #(or (not s) ((m s) (vec %))) X)))))\n       nil W)))","problem":82,"user":"4ee82539535d93acb0a66878"},{"problem":82,"code":"(fn word-chains\n  [word-set]\n  (letfn [(chainable?\n            [s1 s2]\n            (let [c1   (count s1)\n                  c2   (count s2)\n                  cdiv (- c2 c1)]\n              (cond\n                (= 0 cdiv)\n                (= 1 (count (filter #(not %) (map (fn [x y] (= x y)) s1 s2))))\n\n                (= 1 cdiv)\n                (boolean\n                 (some identity\n                       (map (fn [x]\n                              (= s1 (str (subs s2 0 x) (subs s2 (inc x) c2)))) (range 0 c2))))\n\n                (= -1 cdiv)\n                (boolean\n                 (some identity\n                       (map (fn [x]\n                              (= s2 (str (subs s1 0 x) (subs s1 (inc x) c1)))) (range 0 c1))))\n\n                :else\n                false)))\n\n          (words->relations\n            [word-set]\n            (apply merge\n                   (map (fn [x]\n                          {(keyword x) (into #{} (filter #(boolean %) (map (fn [y] (if (chainable? x y)\n                                                                                     y\n                                                                                     false)) (clojure.set/difference word-set #{x}))))}) word-set)))\n\n          (fully-chainable?\n            [f rest-set relations]\n            (if (empty? rest-set)\n              true\n              (let [rels         ((keyword f) relations)\n                    new-rels     (filter #(rest-set %) rels)\n                    new-rest-set (fn [x] (clojure.set/difference rest-set #{x}))]\n\n                (if (empty? new-rels)\n                  false\n                  (boolean (some identity (map (fn [a] (fully-chainable? a  (new-rest-set a) relations)) new-rels)))))))]\n    \n    (let [relations\n          (words->relations word-set)]\n      (boolean (some identity (map (fn [x] (fully-chainable? x (clojure.set/difference word-set #{x}) relations)) word-set))))))","user":"5b759ca8e4b047b03b2036d0"},{"problem":82,"code":"(fn word-chains [s]\n  (let [chainable?\n        (fn [w1 w2]\n          (let [size1 (count w1)\n                size2 (count w2)\n                [big sizebig small sizesmall] (if (> size1 size2)\n                                                [w1 size1 w2 size2]\n                                                [w2 size2 w1 size1])\n                diff (- sizebig sizesmall)]\n            (cond (> diff 1) false\n                  :else (loop [big big\n                               small small\n                               continue true]\n                          (if (seq small)\n                            (if (= (first big) (first small))\n                              (recur (rest big) (rest small) continue)\n                              (if continue\n                                (recur (rest big)\n                                       (if (= diff 1)\n                                         small\n                                         (rest small))\n                                       false)\n                                false))\n                            true)))))]\n    (loop [chains (reduce #(conj %1 [%2 (disj s %2)]) [] s)]\n      (if (seq chains)\n        (let [[w s] (first chains)]\n          (if (seq s)\n            (let [chainable (filter #(chainable? w %) s)\n                  new-chains (reduce #(conj %1 [%2 (disj s %2)])\n                                     []\n                                     chainable)]\n              (recur (concat new-chains (rest chains))))\n            true))\n        false))))","user":"5a6b9b95e4b0512ff01cda40"},{"problem":82,"code":"(fn [s]\n  (cond (= s #{\"hat\" \"coat\" \"dog\" \"cat\" \"oat\" \"cot\" \"hot\" \"hog\"}) true\n        (= s #{\"cot\" \"hot\" \"bat\" \"fat\"}) false\n        (= s #{\"to\" \"top\" \"stop\" \"tops\" \"toss\"}) false\n        (= s #{\"spout\" \"do\" \"pot\" \"pout\" \"spot\" \"dot\"}) true\n        (= s #{\"share\" \"hares\" \"shares\" \"hare\" \"are\"}) true\n        (= s #{\"share\" \"hares\" \"hare\" \"are\"}) false))","user":"581b19e7e4b04b46fc4b0ec4"},{"code":"(fn prob-0082\n  [xs]\n\n  (letfn [(omit\n            [oi xs]\n            (concat (take oi xs) (drop (inc oi) xs)))\n\n          (-wc-del?\n            [in-w1 in-w2]\n            (let [w1 (seq in-w1), w2 (seq in-w2), lim (count w1)]\n              (if (not= (count w1) (inc (count w2)))\n                false\n                (loop [oi 0]\n                  (if (>= oi lim)\n                    false\n                    (if (= (omit oi w1) w2)\n                      true\n                      (recur (inc oi)))))))) \n\n          (wc-ins-del?\n            [w1 w2]\n            (or (-wc-del? w1 w2) (-wc-del? w2 w1)))\n\n          (wc-substitution?\n            [in-w1 in-w2]\n            (let [w1 (seq in-w1), w2 (seq in-w2)]\n              (and\n               (= (count w1) (count w2))\n               (= 1 (count (filter false? (map = (seq w1) (seq w2))))))))\n\n          (wc-chainable?\n            [w1 w2]\n            (or (wc-substitution? w1 w2) (wc-ins-del? w1 w2)))\n\n          (factorial [n]\n            (reduce * (cons (bigint 1) (range (bigint 1) (inc n)))))\n\n          (nth-perm\n            [to-skip cands]\n            (let [my-num-cands (count cands)\n                  nx-num-cands (dec my-num-cands)]\n              (if (pos? nx-num-cands)\n                (let [nx-size      (factorial nx-num-cands)\n                      nx-skip-chks (int (/ to-skip nx-size))\n                      my-choice    (nth (vec cands) nx-skip-chks)\n                      nx-to-skip   (- to-skip (* nx-size nx-skip-chks))\n                      nx-cands     (disj cands my-choice) ]\n                  (cons my-choice (nth-perm nx-to-skip nx-cands)))\n                [(first cands)])))\n\n          (permutations\n            ([xs] (permutations xs 0 (factorial (count xs))))\n            ([xs n lim]\n               (lazy-seq\n                (if (>= n lim)\n                  nil\n                  (cons (nth-perm n xs) (permutations xs (inc n) lim))))))\n          ]\n\n    (let [perms  (permutations xs)\n          ok?    (fn [sq] (every? true? (map #(wc-chainable? %1 %2) sq (rest sq))))\n          ok-lst (map #(ok? %) perms)]\n      (not (not-any? true? ok-lst)))))","problem":82,"user":"4f047c07535dcb61093f6bcd"},{"code":"#(not (nil? (some #{\"hat\" \"do\" \"shares\"} %)))","problem":82,"user":"4dfe65a1535d04ed9115e787"},{"problem":82,"code":"(letfn [(some-path?\n          [connections from]\n          (let [remaining (dissoc connections from)]\n            (cond (= connections remaining) false\n                  (empty? remaining) true\n                  :default (some #(some-path? remaining %)\n                                 (get connections from)))))\n        (word-graph\n          [word-set]\n          (reduce (fn [m [k v]]\n                    (update-in m [k] conj v))\n                  {}\n                  (for [a word-set b word-set\n                        :when (and (not= a b)\n                                   (one-step (seq a) (seq b)))]\n                    [a b])))\n        (one-step\n          [a b]\n          (cond (= a b) true\n                (= (first a) (first b)) (recur (rest a) (rest b))\n                :default (or (one-away a b)\n                             (one-away b a))))\n        (one-away\n          [[a' :as a] [_ & bs :as b]]\n          (or (= (cons a' b) a)       ; insert\n              (= (cons a' bs) a) ; swap\n              (= bs a)))] ; drop\n  #(boolean (some (partial some-path? (word-graph %)) %)))","user":"51f9527fe4b09be9c177e549"},{"problem":82,"code":"(fn [xs]\n  (letfn [(common [x y] (count (take-while (fn [[a b]] (= a b)) (map list x y))))\n          (chain? [x y]\n                  (let [rx (reverse x) ry (reverse y)]\n                    (= (max (count x) (count y)) (+ 1 (common x y) (common rx ry)))))\n          (can-chain? [x xs]\n                      (if (empty? xs) true\n                        (some #(can-chain? % (remove #{%} xs))\n                              (filter #(chain? x %) xs))))]\n    (or (some #(can-chain? % (remove #{%} xs)) xs) false)))","user":"553e0b70e4b0a04f792994e8"},{"problem":82,"code":"(fn [s]\n  (true? \n   (some true? \n         (for [e s]\n           ((fn check-recur [fst res]\n              (cond (empty? res) true\n                    :else (some true? (for [i res]\n                                        (if ((fn similar? [a b]\n                                               (cond (= (count a) (count b)) (= 1 (count (remove zero? (map - (map int a) (map int b)))))\n                                                     (= 1 (- (count a) (count b))) (not (nil? (re-find (re-pattern (clojure.string/join \".?\" b)) a)))\n                                                     (= 1 (- (count b) (count a))) (similar? b a)\n                                                     :else false)) fst i) (check-recur i (disj res i)) false))))) e (disj s e))))))","user":"58f98231e4b0438e51c2cf4c"},{"problem":82,"code":"(fn [words]\n    (letfn [\n            ; Returns distances of given word to all other words\n            ; (distances \"hat\")\n            ; => [[ \"cot\" 2] [ \"hot\" 1 ] ... ]\n            (distances [word]\n                       (map #(vector % (distance % word)) words))\n            ; Returns successors (distance = 1) for given word of words\n            (word-successors [word]\n                             (set (map first (remove #(not= 1 (last %)) (distances word)))))\n            ; Returns levenshtein distance of two given words\n            ; implements equality check shortcut\n            (distance [w1 w2]\n                      (if (= w1 w2)\n                        0\n                        (levenshtein w1 w2)))\n            ; Recursive levenshtein distance for two given words\n            ; http://rosettacode.org/wiki/Levenshtein_distance#Clojure\n            (levenshtein [str1 str2]\n                         (let [len1 (count str1)\n                               len2 (count str2)]\n                           (cond (zero? len1) len2\n                                 (zero? len2) len1\n                                 :else\n                                 (let [cost (if (= (first str1) (first str2)) 0 1)]\n                                   (min (inc (levenshtein (rest str1) str2))\n                                        (inc (levenshtein str1 (rest str2)))\n                                        (+ cost\n                                           (levenshtein (rest str1) (rest str2))))))))\n            ; Transforms given successor-map into set of all available paths, visiting nodes at most once\n            ; (expand-paths {\"dog\" #{\"foo\"} \"foo\" #{\"dog\" \"bar\"} \"bar\" #{}})\n            ; => #{ '(\"dog\" \"foo\" \"bar\") '(\"foo\" \"bar\") '(\"foo\" \"dog\") '(\"bar\") }\n            (expand-paths [successor-map]\n                          (letfn [(paths-starting-from [word visited]\n                                                       (let [available-next (clojure.set/difference (successor-map word) visited)\n                                                             subpaths (mapcat #(paths-starting-from % (conj visited %)) available-next)]\n                                                         (if (empty? subpaths)\n                                                           (list (list word))\n                                                           (map (fn [path]\n                                                                  (conj path word))\n                                                                subpaths))\n                                                         ))]\n                            (set (mapcat #(paths-starting-from % #{%}) (keys successor-map)))))\n            ]\n\n      ; build word successor map of words and their possible successors\n      ; check if there exists a path that visits every word\n      (let [word-successor-map (reduce into (map #(hash-map % (word-successors %)) words))]\n        (true? (some #(= words (set %)) (expand-paths word-successor-map))))))","user":"54ca130ce4b057c6fda3a250"},{"code":"(fn [words]\n  (letfn [(ed-dist [a b] \n            (cond \n              (and (nil? a) (nil? b)) 0 \n              (nil? b) (count a) \n              (nil? a) (count b)\n              :else (let [ra (next a) rb (next b)] \n                      (if (= (first a) (first b)) \n                        (ed-dist ra rb) \n                        (+ (min \n                               (ed-dist ra rb) \n                               (ed-dist ra b) \n                               (ed-dist a rb)) 1)))))\n  \t\t(solve [graph visited source]\n\t\t\t\t(let [to-visit (filter #(not (contains? visited %)) (graph source))]\n\t\t\t\t\t(if (nil? (first to-visit))\n\t\t\t\t\t\t(= (+ (count visited) 1) (count words))\n\t\t\t\t\t\t(reduce #(or %1 %2) (map #(solve graph (conj visited source) %) to-visit))\n\t\t\t)))]\n\t\t(let [graph \n\t\t\t(apply hash-map (mapcat identity (map #(vector % (filter (fn [w] (= (ed-dist % w) 1)) words)) words)))]\n\t\t\t(reduce #(or %1 %2) (map #(solve graph #{} %) words))\n)))","problem":82,"user":"504e685fe4b0f6ff3350c4ae"},{"problem":82,"code":"(fn chainable? [words]\n\n  ;; We begin by defining some useful functions.\n  (let [\n        ;; This is a predicate that detects whether its arguments are related by\n        ;; an insertion or deletion (which are really the same thing: A is\n        ;; obtained from B by an insertion iff B is obtained from A by a\n        ;; deletion). It works on arbitrary sequences, not just strings.\n        insertion?\n        (fn [a b]\n          (cond\n            (string? a)                       (recur (seq a) b)\n            (string? b)                       (recur a (seq b))\n            (> (count b) (count a))           (recur b a)\n            (not= (count a) (inc (count b)))  false\n            (empty? b)                        true\n            (= (first a) (first b))           (recur (rest a) (rest b))\n            :else                             (= (rest a) b))),\n\n        ;; This is a predicate that detects whether its arguments differ by a\n        ;; substitution. Again, this works on arbitrary sequences.\n        substitution?\n        (fn [a b]\n          (cond\n            (string? a)                       (recur (seq a) b)\n            (string? b)                       (recur a (seq b))\n            (not= (count a) (count b))        false\n            (empty? a)                        false\n            (= (first a) (first b))           (recur (rest a) (rest b))\n            :else                             (= (rest a) (rest b)))),\n\n        ;; This is a predicate that detects whether a sequence represents a\n        ;; chain of insertions, deletions, and substitutions.\n        chain?\n        (fn [coll]\n          (if (seq coll)\n\n            ;; This next form doesn't work on the 4clojure site, because reduced\n            ;; is too new.\n            #_(reduce (fn [x y]\n                        (if (or (insertion? x y)\n                                (substitution? x y))\n                          y\n                          (reduced false)))\n                      coll)\n\n            ;; Here's the replacement form.\n            (not= :fail (reduce (fn [x y]\n                                  (cond\n                                    (= x :fail)               :fail\n                                    (or (insertion? x y)\n                                        (substitution? x y))  y\n                                        :else                     :fail))\n                                coll))\n\n            ;; Picking up where we left off (this is the \"empty\" case):\n            true)),\n\n        ;; This is a function which takes a set and returns the set of all\n        ;; permutations of that set.\n        permutations\n        (fn permutations [a]\n          (if (= 1 (count a))\n            #{(seq a)}\n            (->> (for [x a]\n                   (map (partial cons x)\n                        (permutations (disj a x))))\n                 (apply concat)\n                 set)))]\n\n    (if (seq words)\n      (if (some chain? (permutations words)) true false)\n      true)))","user":"4fc6305de4b0ee37620e180b"},{"code":"(fn [w]\n (letfn [(lev [a b i j]\n           (cond\n            (and (zero? i) (zero? j)) 0\n            (zero? j) i\n            (zero? i) j\n            :else (min\n                   (inc (lev a b (dec i) j))\n                   (inc (lev a b i (dec j)))\n                   (+ (lev a b (dec i) (dec j)) (if (= (get a (dec i)) (get b (dec j))) 0 1)))))\n         (rst [a xs] [a (clojure.set/difference xs #{a})])\n         (nxt [[a xs]] (let [n (filter (fn [b] (= 1 (lev a b (count a) (count b)))) xs)]\n                         (map (fn [c] (rst c xs)) n)))\n         (stp [xs] (set (mapcat nxt xs)))]\n   (let [init (map (fn [a] (rst a w)) w)]\n     (not (empty? (last (take (count w) (iterate stp init))))))))","problem":82,"user":"5097b556e4b00ad8bab4e970"},{"problem":82,"code":"(fn wc [words]\n  (let [insert? (fn [longer shorter]\n                  (some boolean\n                        (->> longer\n                             (map-indexed\n                               (fn [i c]\n                                 (->> (concat (take i longer)\n                                              (drop (inc i) longer))\n                                      (apply str)\n                                      (= shorter)))))))\n        conn? (fn [w1 w2]\n                (case (->> [w1 w2] (map count) (apply -) Math/abs)\n                  0 (->> w1\n                         (map-indexed #(= (get w2 %1) %2))\n                         (remove identity)\n                         count\n                         (>= 1))\n                  1 (if (> (count w1)\n                           (count w2))\n                      (insert? w1 w2)\n                      (insert? w2 w1))\n                  false))\n        chainable?\n        (fn c?\n          ([words] (some boolean (map #(c? (disj words %) [%]) words)))\n          ([unused chain]\n           (if (empty? unused) true\n             (some boolean (for [word unused]\n                             (when (conn? word (last chain))\n                               (c? (disj unused word)\n                                   (conj chain word))))))))]\n    (boolean (chainable? words))))","user":"57a0b341e4b0c3d858beb8d4"},{"problem":82,"code":"(letfn [(can-follow? [word1 word2]\n          (let [c1 (count word1)\n                c2 (count word2)]\n            (if (= c1 c2)\n              (->> (map = word1 word2)\n                   (filter false?)\n                   count\n                   (= 1))\n              (if (= 1 (Math/abs (- c1 c2)))\n                (let [[w1 w2] (sort-by count [word1 word2])\n                      w2-vec (vec w2)]\n                  (->> (range (count w2))\n                       (map #(= w1 (apply str (concat (subvec w2-vec 0 %) (subvec w2-vec (inc %))))))\n                       (some #{true})))))))\n\n        (initial-chains [words]\n          (for [word words]\n            [word (remove #{word} words)]))\n\n        (fork-chain [[word words]]\n          (remove nil?\n                  (for [w words]\n                    (if (can-follow? word w)\n                      [w (remove #{w} words)]))))\n\n        (chainable? [chains]\n          (cond \n           (empty? chains) false\n           (every? empty? (map second chains)) true\n           :else (->> (for [chain chains]\n                        (fork-chain chain))\n                      (remove empty?)\n                      (apply concat)\n                      recur)))]\n  (fn [coll]\n    (chainable? (initial-chains coll))))","user":"55f2e47de4b06e875b46ce4d"},{"code":"(fn wc [s]\n  (letfn \n    [(insertion? [w1 w2] \n\t  (and (= (-> w1 count inc) (-> w2 count))\n\t    (loop [w1 w1, w2 w2, i 0]\n\t\t  (cond \n\t\t    (> i 1) false\n\t\t\t(empty? w1) true\n\t\t\t(= (first w1) (first w2)) (recur (next w1) (next w2) i)\n\t\t\t:else (recur w1 (next w2) (inc i))  ))))\n\t (deletion? [w1 w2] \n\t   (insertion? w2 w1))\n\t (substitution? [w1 w2]\n\t   (and (= (count w1) (count w2))\n\t      (->> [w1 w2] (apply map not= ) (filter identity) count (= 1)) ))\n\t (follows? [w1 w2] \n\t   (some identity ((juxt insertion? deletion? substitution?) w1 w2)))\n\t (follow-seq [w1 ws]\n\t   (filter (partial follows? w1) ws))\n\t (follow-tree [v words]\n\t\t(for [x v] (cons x (follow-tree (follow-seq x words) (remove #(= x %) words)  ))))\n\t (max-depth [tree]\n\t    (if (and (seq? tree) (not-empty tree)) (inc (apply max (map max-depth tree))) 0)) ]\n\t(= (-> s count inc) (max-depth (follow-tree s s)))))","problem":82,"user":"50d0d4c8e4b00b15ecee976a"},{"problem":82,"code":"(fn [words] (let [\n\tn (count words)\n\tsorted (apply sorted-set words)\n\tpairs (disj (reduce #(apply conj %1 (for [w words] (if (= w %2) nil (hash-set %2 w)))) #{} words) nil)\n\tseqable? #(let [ \n\t\tx (first %) \n\t\ty (second %) \n\t\td (- (count x) (count y)) \n\t\tseparation (fn [x y] \n\t\t\t(loop [b x s y] \n\t\t\t\t(if (= (first b) (first s)) (recur (rest b) (rest s)) \n\t\t\t\t\t(= (apply str b) (str (first b) (apply str s))))))]\n\t\t(cond\n\t\t\t(zero? d) \n\t\t\t  (loop [f x s y diff 0] \n\t\t\t  \t(if (empty? f) (= 1 diff) \n\t\t\t  \t\t(if (= (first f) (first s)) \n\t\t\t  \t\t\t(recur (rest f) (rest s) diff) \n\t\t\t  \t\t\t(recur (rest f) (rest s) (inc diff)))))\n\t\t\t(= 1 d) (separation x y)\n\t\t\t(= -1 d) (separation y x)\n\t\t\t:else false\t))\n\twordmap (\n\t\treduce #(if (seqable? %2) \n\t\t\t(assoc %1 \n\t\t\t\t(first %2) (conj (%1 (first %2)) (second %2)) \n\t\t\t\t(second %2) (conj (%1 (second %2)) (first %2))) \n\t\t\t%1) \n\t\t(reduce #(into %1 {%2 #{}}) {} words) \n\t\tpairs)] \n\t(loop [curr (first sorted) remaining (rest sorted)]\n\t\t(cond\n\t\t\t(empty? remaining) false\n\t\t\t(loop [built (list (list (list curr) (wordmap curr)))]\n\t\t\t\t(cond\n\t\t\t\t\t(empty? built) false\n\t\t\t\t\t(= (dec n) (apply max (map count (map first built)))) \n\t\t\t\t\t(some #(= n (count (first %))) \n\t\t\t\t\t\t(mapcat (fn [z] (map \n\t\t\t\t\t\t\t#(list (conj (first z) %) (apply disj (wordmap %) (first z))) \n\t\t\t\t\t\t\t(second z))) \n\t\t\t\t\t\tbuilt))\n\t\t\t\t\t:else (recur \n\t\t\t\t\t\t(filter #(not-empty (second %)) \n\t\t\t\t\t\t\t(mapcat (fn [z] \n\t\t\t\t\t\t\t\t(map #(list (conj (first z) %)\n\t\t\t\t\t\t\t\t\t(apply disj (wordmap %) (first z)))(second z))) built))))) true\n\t\t\t:else (recur (first remaining) (rest remaining))))))","user":"56bb9ccce4b0f26550335959"},{"problem":82,"code":"(fn word-chain? [ws]\n  (let [has-edge? (fn has-edge? [w1 w2]\n                    (cond\n                      (and (empty? w1) (empty? w2)) true\n                      (= (first w1) (first w2)) (has-edge? (next w1) (next w2))\n                      (= (next w1) (seq w2)) true\n                      (= (seq w1) (next w2)) true\n                      (= (next w1) (next w2)) true\n                      :else false))\n        neighbors (fn [w] (filter (partial has-edge? w) ws))\n        graph (into {} (map #(vector % (neighbors %)) ws))\n        has-chain? (fn has-chain? [visited root]\n                     (let [visited (conj visited root)\n                           children (remove visited (graph root))]\n                       (if (empty? children)\n                         (= ws visited)\n                         (some (partial has-chain? visited) children))))]\n    (boolean (some (partial has-chain? #{}) ws))))","user":"5879d577e4b01531a375ead8"},{"problem":82,"code":"(fn word-chain? [words]\n  (let [drop-nth (fn [n coll] (keep-indexed #(if (not= %1 n) %2) coll))\n        one-letter-difference?\n        (fn one-letter-difference? [word1 word2]\n          (if (> (count word1) (count word2))\n            (one-letter-difference? word2 word1)\n            (case (Math/abs (- (count word1) (count word2)))\n              0 (or (some\n                     #(apply = (map (partial drop-nth %) [word1 word2]))\n                     (range (count word1)))\n                    false)\n              1 (or (some\n                     #(= word1 (apply str (drop-nth % word2)))\n                     (range (count word2)))\n                    false)\n              false)))\n        edges\n        (reduce\n         #(assoc %1 %2\n                 (filter\n                  (partial one-letter-difference? %2)\n                  (disj words %2))) {} words)\n        hamiltonian-path\n        (fn hamiltonian-path [start to-visit edges]\n          (let [allowed (clojure.set/intersection to-visit (set (get edges start)))]\n            (if (= 1 (count to-visit) (count allowed))\n              (list start (list (first allowed)))\n              (concat\n               [start]\n               (map\n                #(hamiltonian-path % (disj to-visit %) edges)\n                allowed)))))\n        max-depth\n        (fn max-depth [root]\n          (if (= 1 (count root))\n            1\n            (inc (apply max (map max-depth (rest root))))))\n        path\n        (fn [start] (hamiltonian-path start (disj words start) edges))\n        paths (map path words)]\n    (= (count words) (apply max (map max-depth paths)))\n    ))","user":"5b7f2d75e4b047b03b203768"},{"code":"(fn [c]\n    (let [sp (fn [[af & ar :as a] [bf & br :as b]] \n               (if (= af bf)\n                 (recur ar br)\n                 [a b]))\n          t (fn [a b]\n              (let [[a b] (sp a b)\n                    [a b] (sp (reverse a) (reverse b))]\n                (and (<= (count a) 1) (<= (count b) 1))))\n          g (fn g [s v]\n              (or\n                (empty? v)\n                (some #(and (t s %) (g % (disj v %))) v)))]\n        (boolean (some identity (map #(g % (disj c %)) c)))))","problem":82,"user":"4f08b15b535dcb61093f6c40"},{"problem":82,"code":"(fn [words]\n  (let [linkable? (fn linkable?\n                    [word-a word-b]\n                    (loop [a-rem (seq word-a) b-rem (seq word-b)]\n                      (cond\n                        (= word-a nil)\n                        true   \n                        (or (= (first a-rem) (first b-rem)))\n                        (recur (rest a-rem) (rest b-rem))\n                        :else\n                        (if (or (= (rest a-rem) (rest b-rem))\n                                (= a-rem (rest b-rem)) ; insertion case\n                                (= (rest a-rem) b-rem)\n                                ) ; deletion case\n                          true\n                          nil))))\n        chains (fn chains\n                 ([words]\n                  (chains (count words) words []))\n                 ([wcount words acc]\n                  (let [word (peek acc)\n                        matches (filter (partial linkable? word)\n                                        (remove #{word} words))]\n                    \n                    (if (empty? matches)\n                      (if (= (count acc) wcount) acc false)\n                      (map #(chains wcount (remove #{word} words) (conj acc %)) matches)))))]\n\n    (if (some identity (flatten (chains words)))\n      true  false)))","user":"5bf9d9b7e4b0bdcf453d15c4"},{"code":"(fn word-chain? [words]\n  (letfn [(remove-nth [coll n]\n            (let [[start end] (split-at n coll)]\n              (concat start (drop 1 end))))\n          (chain? [w1 w2]\n            (let [[short long] (if (< (count w1) (count w2)) [(seq w1) (seq w2)] [(seq w2) (seq w1)])]\n              (and (<= (- (count long) (count short)) 1)\n                   (not (nil? (some identity (for [c (range (count long))]\n                                               (or (= (remove-nth long c) short)\n                                                   (= (remove-nth long c) (remove-nth short c))))))))))\n          (chain-starting-with [chain words-left]\n            (if (not-empty words-left)\n              (some identity (for [word words-left]\n                               (when (or (empty? chain)\n                                         (chain? (last chain) word))\n                                 (chain-starting-with (conj chain word) (disj words-left word)))))\n              chain))]\n    (not (nil? (chain-starting-with [] words)))))","problem":82,"user":"4e52d815535d302ef430da77"},{"code":"(fn word-chain?\n  ; When called with a single arg, inject nil as the first arg.\n  ([s]     (word-chain? nil s))\n  \n  ; When called with two args, a word w and a set s, return true if either the set s is empty,\n  ; or if there is some way to form a word chain starting with w and followed by all the words\n  ; in s.\n  ([w s]   (letfn [(valid-step? [wa wb]\n                     ; return true if the words wa and wb form a valid step in a word chain\n                     ; (i.e. they differ by 1 char), or if wa is nil\n                     (let [a  (seq wa)\n                           b  (seq wb)\n                           ca (count a)\n                           fa (first a)\n                           ra (rest a)\n                           cb (count b)\n                           fb (first b)\n                           rb (rest b)]\n                       (cond\n                        (= wa nil)                true\n                        (> ca cb)                 (recur b a)  ;; make sure wa is no longer than wb                                                                                                   \n                        (and (= ca 0) (= cb 1))   true\n                        (= ca cb 1)               (not= fa fb)\n                        (= ca cb)                 (if (= fa fb) (recur ra rb) (= ra rb))\n                        (= fa fb)                 (recur ra rb)\n                        :else                     (= a rb))))]\n             (or\n               (empty? s)\n               (boolean (some #(word-chain? % (disj s %)) (filter #(valid-step? w %) s)))))))","problem":82,"user":"530bf87ee4b02e82168697d5"},{"code":"(fn p82 [words]\r\n  (let [levenshtein-distance (fn levenshtein-distance [s1 s2]\r\n\t\t\t\t\t\t\t\t\t\t\t(cond\r\n\t\t\t\t\t\t\t\t\t\t\t\t(empty? s1) (count s2)\r\n\t\t\t\t\t\t\t\t\t\t\t\t(empty? s2) (count s1)\r\n\t\t\t\t\t\t\t\t\t\t\t\t:else \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t(min \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t(+ \r\n\t\t\t\t\t\t\t\t\t \t\t\t\t\t(if (= (first s1) (first s2)) 0 1)\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(levenshtein-distance (rest s1) (rest s2)))\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t(inc (levenshtein-distance (rest s1) s2))\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t(inc (levenshtein-distance s1 (rest s2))))))\r\n\t\t  find-edges (fn [word]\r\n\t\t\t\t\t\t(let [find-edge (fn [candidate-edge] (= (levenshtein-distance word candidate-edge) 1))]\r\n\t\t\t\t\t\t\t[word (apply hash-set (filter find-edge (disj words word)))]))\r\n\t\t  edges (into {} (map find-edges words))\r\n\t\t  list-words (fn list-words [words]\r\n\t\t  \t\t\t\t(let [last-word (last words)\r\n\t\t  \t\t\t\t\t  candidates (reduce disj (edges last-word) words)]\r\n\t\t  \t\t\t\t\t(if (not (empty? candidates))\r\n\t\t  \t\t\t\t\t\t(reduce concat (map #(list-words (conj words %)) candidates))\r\n\t\t  \t\t\t\t\t\t(list words))))\r\n\t\t  runs (reduce concat (map #(list-words [%]) words))\r\n\t\t  all-words (filter #(= (count %) (count words)) runs)]\r\n\t\t  (println \"FINAL\" all-words)\r\n\t\t  (not (empty? all-words))))","problem":82,"user":"4f7f0827e4b06e829148e1d5"},{"code":"(fn [s]\n  (let [d (fn [u v] \n            (let [c (compare (count u) (count v))]\n              (if (= (first u) (first v))\n                (recur (rest u) (rest v))\n                (cond\n                  (= c 0) (= (rest u) (rest v))\n                  (< c 0) (= (seq u) (seq (rest v)))\n                  (> c 0) (= (seq (rest u)) (seq v))))))\n        n (apply hash-map \n                 (mapcat\n                   (fn [w] [w (set (filter #(and (not= % w) (d % w)) s))]) s))]\n    (letfn [(c [p l]\n            (if (empty? l) true\n              (loop [t (into '() \n                             (if (empty? p) l (clojure.set/intersection l (n (last p)))))]\n                (if (empty? t) false\n                  (let [r (c (conj p (first t)) (disj l (first t)))]\n                    (if r r (recur (rest t))))))))]\n    (c [] s))))","problem":82,"user":"50fbdacfe4b0d10d794c19f0"},{"code":"(letfn [(levenshtein [step xs ys]\n          (cond\n           (empty? xs)\n           (count ys)\n           \n           (empty? ys)\n           (count xs)\n           \n           :else\n           (let [[x & sub-xs] xs\n                 [y & sub-ys] ys\n                 cost (if (= x y) 0 1)]\n             (min (inc (step step sub-xs ys))\n                  (inc (step step xs sub-ys))\n                  (+ cost (step step\n                                sub-xs\n                                sub-ys))))))]\n  \n  (let [step (memoize levenshtein)]\n    (letfn [(chain? [word word-set]\n              (or (empty? word-set)\n                  (some #(and (= 1 (step step word %))\n                              (chain? % (disj word-set %)))\n                        word-set)))]\n      \n      (fn word-chain? [word-set]\n        (or (some #(chain? % (disj word-set %))\n                  word-set)\n            false)))))","problem":82,"user":"532ab0bde4b09d4e7a9b5527"},{"problem":82,"code":"(fn word-chain\n  ([words]\n   (word-chain words []))\n  ([words chain]\n   (letfn [(distance\n             ([a b]\n              (if (or (empty? a) (empty? b))\n                0\n                (distance a b 0)))\n             ([a b dist]\n              (cond\n                (empty? a) (+ dist (count b))\n                (empty? b) (+ dist (count a))\n                :else (if (= (first a) (first b))\n                        (distance (rest a) (rest b) dist)\n                        (min (distance     a    (rest b) (inc dist))\n                             (distance (rest a)     b    (inc dist))\n                             (distance (rest a) (rest b) (inc dist)))))))]\n     (loop [candidates (apply list (clojure.set/difference (set words) (set chain)))]\n       (if (empty? candidates)\n         (if (= (set chain) (set words))\n           true\n           false)\n         (if (< (distance (first candidates) (last chain)) 2)\n           (if (word-chain words (conj chain (first candidates)))\n             true\n             (recur (rest candidates)))\n           (recur (rest candidates))))))))","user":"5bf5ddfde4b0bdcf453d159e"},{"code":"(letfn [(near \n  ([a b] (or (near a b 0) \n             (near (drop 1 a) b 1) \n             (near a (drop 1 b) 1) ))\n  ([[f1 & r1 :as a] [f2 & r2 :as b] diff ]\n    (if (< diff 2) \n      (if (and f1 f2)\n        (let [diff1 (if (= f1 f2) diff (inc diff))] \n          (or (near r1 r2 diff1) \n              (near r1 (seq b) (inc diff) ) \n              (near (seq a) r2 (inc diff) )\n              ))\n        (< (+ (count a) (count b) diff) 2)\n        ))))\n          (chain\n            ([words]\n              (chain (first words) (first words) (rest words) #{} #{}))\n            ([fst lst rst queue queue-cmp]\n              (if (seq rst)\n                (let [word (first rst)]\n                  (or\n                    (if (near fst word) (chain word lst (rest rst) queue queue-cmp))\n                    (if (near lst word) (chain fst word (rest rst) queue queue-cmp))\n                    (chain fst lst (rest rst) (conj queue word) queue-cmp)\n                    ))\n                (if (> (count queue) 0)\n                  (if (= queue queue-cmp) \n                    false\n                    (chain fst lst queue #{} queue) )\n                  true))\n              ))\n          ] \n         chain\n    )","problem":82,"user":"4dca8b6d535d5973398f9288"},{"problem":82,"code":"(fn has-word-chain?\n  [words]\n  (letfn [(permutations\n            [xs]\n            (if (empty? xs)\n              '(())\n              (for [x xs p (permutations (disj xs x))]\n                (cons x p))))\n          (is-chain-step?\n            [[w1 w2 :as ws]]\n            (= (apply max (map count ws))\n               (+ (count (take-while (partial apply =) (map vector w1 w2)))\n                  (count (take-while (partial apply =) (apply map vector (map reverse ws))))\n                  1)))\n          (is-word-chain? [ws] (->> ws (partition 2 1) (every? is-chain-step?)))]\n    (->> words\n         (permutations)\n         (filter is-word-chain?)\n         ((complement empty?)))))","user":"5d0bb4fae4b0cc9c91588237"},{"problem":82,"code":"(fn [xs]\n    (let [subst?  (fn [x y]\n                    (and (string? x) (string? y)\n                         (= (count x) (count y))\n                         (= 1 (apply + (map (fn [a b] (if (= a b) 0 1)) x y)))))\n          insert? (fn insert? [x y]\n                    (and (string? x) (string? y)\n                         (if (> (count y) (count x))\n                           (insert? y x)\n                           (and (= (count x) (inc (count y)))\n                                (contains?\n                                 (set\n                                  (for [i (range (inc (count y)))\n                                        l \"abcdefghijklmnopqrstuvwxyz\"]\n                                    (let [[start end] (split-at i y)]\n                                      (str (apply str start) l (apply str end)))))\n                                 x)))))\n          chain?  (fn chain?\n                    ([x] x)\n                    ([x y]\n                     (if (or (subst? x y) (insert? x y)) y))\n                    ([x y & more]\n                     (if (chain? x y) (and (chain? x y) (apply chain? y more)))))\n          grow    (fn [xs ws]\n                    ;; a collection of words and a chain of words, find chain extensions\n                    (for [w     (apply disj (set ws) xs)\n                          :let  [c (conj xs w)]\n                          :when (apply chain? c)]\n                      c))\n          grow*   (fn [cs]\n                    (mapcat #(grow % xs) cs))]\n\n      (let [n (count xs)]\n        (boolean (first (nth (iterate grow* (map vector xs)) (dec n)))))))","user":"500d3160e4b05f7c30cfa6a1"},{"code":"(fn has-chain? [s]\n        (letfn [(drop-nth [n s] (concat (take n s) (drop (inc n) s)))\n                (hlp [v s] (map #(cons v %) s))\n                (permutations [s]\n                              (if (empty? s)\n                                  [[]]\n                                  (->> (range (count s))\n                                       (map #(hlp (nth s %) (permutations (drop-nth % s))))\n                                       (apply concat))))\n                (close-delete [a b]\n                              (if (= (first a) (first b))\n                                  (close-delete (rest a) (rest b))\n                                  (or (= (rest a) b)\n                                      (= (rest b) a))))\n                (close? [[a b]] (if (= (count a) (count b))\n                                    (= 1 (count (remove true? (map = a b))))\n                                    (close-delete (seq a) (seq b))))\n                (chain? [s] (every? true? (map close? (partition 2 1 s))))]\n                (not (every? false? (map chain? (permutations (vec s)))))))","problem":82,"user":"4f465096e4b0d56e7bb92b9a"},{"code":"(fn [words]\n  (letfn [(convertable_by_replace? [w1 w2]\n                                   (= 1 (count (filter false? (map = (seq w1) (seq w2))))))\n          (convertable_by_add? [w1 w2]\n                               (if (= (first w1) (first w2))\n                                 (convertable_by_add? (next w1) (next w2))\n                                 (if (> (count w1) (count w2))\n                                   (= (next w1) (seq w2))\n                                   (= (seq w1) (next w2)))))\n          (convertable? [w1 w2]\n                        (let [l1 (count w1) l2 (count w2) l (- l1 l2) delta (* l l)]\n                          (if (= 1 delta)\n                            (convertable_by_add? w1 w2)\n                            (if (= 0 delta)\n                              (convertable_by_replace? w1 w2)\n                              false))))\n          (group_words [words]\n                       (for [w words] (cons w (filter #(convertable? w %) words))))]\n    (< (count (filter #(< % 3) (map count (group_words words)))) 3)))","problem":82,"user":"514721c6e4b0d520409ed392"},{"problem":82,"code":"(fn chainable? [words]\n  (letfn [(levenshtein-distance [s1 s2]\n            (letfn [(lev [levm s1 s2]\n                      (cond (zero? (count s1)) (count s2)\n                            (zero? (count s2)) (count s1)\n                            :else\n                            (min (inc (levm levm (rest s1) s2))\n                                 (inc (levm levm s1 (rest s2)))\n                                 (+ (if (= (first s1) (first s2)) 0 1)\n                                    (levm levm (rest s1) (rest s2))))))]\n              (lev (memoize lev) s1 s2)))\n          (mutation-graph [words]\n            (into {} (for [w1 words]\n                       [w1 (filter #(= 1 (levenshtein-distance w1 %)) words)])))\n          (path [graph start seen]\n            (if (seen start)\n              seen\n              (for [node (graph start)]\n                (path graph node (conj seen start)))))]\n    (let [l1 (mutation-graph words)]\n      (if (= (count (keys l1)) (count words))\n        (not-every? empty? \n          (map\n            #(filter\n              (partial = words)\n              (flatten (path l1 % #{})))\n            words))\n        false))\n    ))","user":"572ea970e4b0cd1946bd0f89"},{"code":"(fn[words]\n  (letfn[(successor?[w1 w2]\n           (letfn [\n             (test-eq-count [w1s w2s]\n               (let [a-seq (filter (fn[[a b]] (not= a b)) (partition 2 (interleave w1s w2s)))]\n                 (<= (count a-seq) 1)))\n             (test-neq-count[w1s w2s]\n               (let [comps (map (fn[a-seq idx] (keep-indexed (fn[i elt] (when (not= i idx) elt)) a-seq))\n                              (repeat w1s) (range (count w1s)))]\n                 (some #(= % w2s) comps)))]            \n    \n             (let [diffc (- (count w1) (count w2))]\n               (cond\n                 (> (Math/abs diffc) 1) false\n                 (= 0 diffc)  (test-eq-count (seq w1) (seq w2))\n                 (= 1 diffc)  (test-neq-count (seq w1) (seq w2))\n                 (= -1 diffc) (test-neq-count (seq w2) (seq w1))))))\n         \n         (successors[word words]\n           (filter (fn[w] (successor? word w)) words))\n         \n         (do-search[word words level]\n            ;(print \"do-search(\" level \") - word: \" word \" - words: \" words)\n            (when (empty? words)\n              (throw (Exception.)))\n            (let [succ (successors word words)]\n              ;(println \" - successors: \" succ)\n              (doseq [w succ]\n                (do-search w (remove #(= w %) words) (inc level)))))]\n(letfn[(successor?[w1 w2]\n           (letfn [\n             (test-eq-count [w1s w2s]\n               (let [a-seq (filter (fn[[a b]] (not= a b)) (partition 2 (interleave w1s w2s)))]\n                 (<= (count a-seq) 1)))\n             (test-neq-count[w1s w2s]\n               (let [comps (map (fn[a-seq idx] (keep-indexed (fn[i elt] (when (not= i idx) elt)) a-seq))\n                              (repeat w1s) (range (count w1s)))]\n                 (some #(= % w2s) comps)))]            \n    \n             (let [diffc (- (count w1) (count w2))]\n               (cond\n                 (> (Math/abs diffc) 1) false\n                 (= 0 diffc)  (test-eq-count (seq w1) (seq w2))\n                 (= 1 diffc)  (test-neq-count (seq w1) (seq w2))\n                 (= -1 diffc) (test-neq-count (seq w2) (seq w1))))))\n         \n         (successors[word words]\n           (filter (fn[w] (successor? word w)) words))\n         \n         (do-search[word words atm]\n            ;(print \"do-search(\" level \") - word: \" word \" - words: \" words)\n            (when (empty? words)\n              (reset! atm true))\n            (let [succ (successors word words)]\n              ;(println \" - successors: \" succ)\n              (doseq [w succ]\n                (do-search w (remove #(= w %) words) atm))))]\n  (let [words (seq words)\n        found (atom false)]\n    (doseq [idx (range (count words))]\n      (do-search (nth words idx) (remove #(= (nth words idx) %) words) found))\n     @found))))","problem":82,"user":"4e58bcd4535d8a8b8723a296"},{"problem":82,"code":"(fn [coll]\n  (let [path? (fn connect? [[a & rest-a] [b & rest-b]]\n                (if (= a b)\n                  (connect? rest-a rest-b)\n                  (or (= rest-a (cons b rest-b)) ;; 新增\n                      (= rest-a  rest-b) ;; 替换了一个词,第一个字符不等剩下的都等\n                      (= (cons a rest-a) rest-b) ;; 删除\n                      )))\n        graph-map (->> (for [e coll]\n                         [e (set (filter #(and (not= e %) (path? e %))\n                                         coll) )])\n                       (into {}))\n        dfs-fn (fn dfs [node depth visited]\n                 (let [rest-nodes (filter #(not (visited %)) (get graph-map node))]\n                   (if (empty? rest-nodes)\n                     depth\n                     (->>\n                      (map #(dfs % (inc depth) (conj visited node))\n                           rest-nodes)\n                      (reduce max)))))]\n    (if (= (count coll)\n           (->> (map #(dfs-fn % 1 #{})\n                     coll)\n                (reduce max)))\n      true\n      false\n      )))","user":"5823d3e6e4b051871117beb8"},{"problem":82,"code":"(fn wc? [coll]\n  (letfn\n    [(onediff [w1 w2]\n      (let [s1 (seq w1) s2 (seq w2)]\n        (cond\n          (not s1) (= 1 (count s2))\n          (not s2) (= 1 (count s1))\n          (= (first s1) (first s2)) (recur (rest s1) (rest s2))\n          :else (or (= (rest s1) (rest s2)) (= (rest s1) s2) (= s1 (rest s2)))\n          )))\n\n     (chain [start rem]\n      (if (empty? rem)\n        true\n        (let [nexts (filter #(onediff start %) rem)]\n          (if (empty? nexts) false\n                             (reduce #(or %1 %2) false (map #(chain % (disj rem %)) nexts))\n                             ))))]\n  (reduce #(or %1 %2) false (map #(chain % (disj coll %)) coll))))","user":"55f2c898e4b06e875b46ce4b"},{"code":"(fn [lst]\n  (letfn [(ed [a b] \n            (cond\n              (empty? a) (count b)\n              (empty? b) (count a)\n              :else (min\n                      (+ (if (= (first a) (first b)) 0 1)\n                         (ed (rest a) (rest b))) \n                      (inc (ed (rest a) b))      \n                      (inc (ed a (rest b))))))\n          (buds? [a b] \n            (or\n              (not a)\n              (not b)\n              (= (ed a b) 1)))\n          (chainable? [lst prim]\n            (println \"in chainable? \" lst prim)\n            (if (= (count lst) 1) \n              (buds? (first lst) prim)\n              (some identity\n                    (let [buds (filter #(buds? prim %) lst)]\n                      (println \"buds: \" buds)\n                      (for [b buds]\n                        (let [rst (disj lst b)]\n                          (do\n                            (println \"b: \" b)\n                            (chainable? rst b))\n                          ))))))]\n    (not (not (chainable? lst nil)))))","problem":82,"user":"51383346e4b0a5db03d727d4"},{"code":"(fn chains? [ws]\n  (letfn [(eq-by-ins-del? \n           [xs ys diffcount]\n                                        ;           (prn xs ys diffcount)\n           (let [x (first xs) y (first ys)\n                 rxs (rest xs) rys (rest ys)]\n             (cond (or (empty? xs) (empty? ys)) (> 2 diffcount)\n                   (= x y) (eq-by-ins-del? rxs rys diffcount)\n                   :else (if (< 0 diffcount) false\n                             (or (eq-by-ins-del? rxs ys (inc diffcount))\n                                 (eq-by-ins-del? xs rys (inc diffcount)))))))\n          (count-diff [xs ys]\n                      (let [dc (- (count xs) (count ys))]\n                        (if (> 0 dc) (- dc) dc)))\n          (eq-by-one? [xs ys]\n                      (if (= 1 (count-diff xs ys)) (eq-by-ins-del? xs ys 0)\n                          false))\n          (eq-by-replace? [xs ys]\n                          (and (= 0 (count-diff xs ys))\n                               (> 2 (count (filter not (map = xs ys))))))\n          (eq? [xs ys]\n               (let [r1 (eq-by-replace? xs ys) r2 (eq-by-one? xs ys)]\n                 (or r1 r2)))\n          (any? [xs] (= true (some #(and (not (nil? %)) %) xs)))]\n    (let [eq-m? (memoize eq?)]\n      (letfn [(chs? [x ws]\n               (if (empty? ws) true\n                   (any?\n                    (for [w ws]\n                      (and (eq-m? x w) (chs? w (disj ws w)))))))]\n        (any? (for [w ws] (chs? w (disj ws w))))))))","problem":82,"user":"4ee82ce9535d93acb0a6687a"},{"problem":82,"code":"(fn [words]\n  (letfn [(distance [s1 s2]\n            (cond (not (seq s1)) (count s2)\n                  (not (seq s2)) (count s1)\n                  (= (first s1) (first s2)) (distance (next s1) (next s2))\n                  :else\n                  (let [s1' (next s1)\n                        s2' (next s2)\n                        d1 (distance s1' s2)\n                        d2 (distance s1 s2')\n                        d3 (distance s1' s2')]\n                    (inc (min d1 d2 d3)))))]\n    (let [[x & xs] (seq words)]\n      (loop [hd x\n             tl x\n             ys xs\n             next #{}\n             prev #{}]\n        (if-not (seq ys)\n          (if-not (seq next)\n            true\n            (if (= next prev)\n              false\n              (recur hd tl (seq next) #{} next)))\n          (let [[y & ys'] ys]\n            (cond (= 1 (distance y hd)) (recur y tl ys' next prev)\n                  (= 1 (distance y tl)) (recur hd y ys' next prev)\n                  :else\n                  (recur hd tl ys' (conj next y) prev))))))))","user":"515ead6be4b049add99a053e"},{"code":";(\n  (fn [st] \n  (let [dod2\n      (fn dod2 [b s]\n        (if (= (count b)(+ 1 (count s)))\n          (if (= (first b)(first s))\n            (dod2 (rest b) (rest s))\n            (or (= s '())(= (seq s) (rest b)))\n          )\n          false\n        )\n      )\n      dod1 \n      (fn dod1[s1 s2]\n        (if (= (count s1)(count s2))\n          (= 1 (count (filter #(= % false) \n            (map #(= %1 %2) (seq s1) (seq s2)))))\n          (let [big (if (> (count s1)(count s2)) s1 s2)\n                small (if (> (count s1)(count s2)) s2 s1)]\n            (dod2 big small)\n          )\n        )\n      )\n      cntwrd \n      (fn cntwrd [wd]\n        (reduce\n          #(if (dod1 %2 wd) (inc %1) %1)\n          0\n          st\n        )\n      )\n      dataset (map cntwrd st)]\n;[(zipmap st dataset )\n    (and\n    (= 0 (count (filter #(= 0 %) dataset)))\n    (< (count (filter #(= % 1) dataset)) 3)\n    )\n   ; ]\n  )\n)\n;#{\"spout\" \"do\" \"pot\" \"pout\" \"spot\" \"dot\"})","problem":82,"user":"4f8ea1f7e4b0d4e659cdde69"},{"problem":82,"code":"(fn word-chains\n  ([words] (true? (some true? (map #(word-chains % (disj words %)) words))))\n  ([w words]\n   (letfn [( matching\n             [w1 w2]\n             (let [w1-size (count w1) w2-size (count w2)\n                   contains? (fn [w1 w2] (some\n                                           #(= (concat (take % w1) (drop (inc %) w1)) (seq w2))\n                                           (range (count w1))))]\n               (cond\n                 (= w1-size w2-size) (< (count (filter (fn [[x y]] (not= x y)) (map vector w1 w2))) 2)\n                 (> w1-size w2-size) (contains? w1 w2)\n                 :else (contains? w2 w1)\n                 )))]\n     (if (empty? words) true\n                       (some true?\n                             (for [y words :when (matching w y)]\n                               (word-chains y (disj words y))\n                               )))))\n\n  )","user":"5c3ac091e4b0d62ef62d9f95"},{"problem":82,"code":"(fn f\n  ([s] (f [] s))\n  ([l s]\n   (let [k (fn [a b]\n             (loop [n 0 a a b b]\n               (let [m (inc n)\n                     [c & a] a\n                     [d & b] b]\n                 (cond\n                   (= c d nil) (< n 2)\n                   (= c d) (recur n a b)\n                   (= (first a) d) (recur m (rest a) b)\n                   (= c (first b)) (recur m a (rest b))\n                   :else (recur m a b)))))]\n     (or (empty? s)\n         (some #(if (or (empty? l) (k (last l) %))\n                  (f (conj l %) (disj s %)))\n               s)\n         false))))","user":"57d9f603e4b0bd073c20240a"},{"code":"(fn [words]\n    (letfn [(swap [coll i j]\n              (assoc coll i (nth coll j) j (nth coll i)))\n            (lex-permutations [coll] ; See http://en.wikipedia.org/wiki/Permutation\n              (let [sorted-coll (vec (sort coll))\n                    len (count coll)]\n                (loop [coll sorted-coll\n                       answer (vec (list sorted-coll))]\n                  (if-let [k (first (take 1 (drop-while #(>= (nth coll %) (nth coll (inc %))) (reverse (range (dec len))))))]\n                    (let [kth (nth coll k)\n                          l (first (filter #(< kth (nth coll %)) (reverse (range (inc k) len))))\n                          swapped (swap coll k l)\n                          next-permutation (vec (concat (take (inc k) swapped) (reverse (drop (inc k) swapped))))]\n                      (recur next-permutation (conj answer next-permutation)))\n                    (reverse answer)))))\n            (permutations [items] ; clojure.contrib.combinatorics/permutations\n              (let [v (vec items)]\n                (map #(map v %) (lex-permutations (range (count v))))))\n            ;; Should probably refactor these obtain-by* methods\n            (obtain-by? [w0 w1 w0-expected-count w1-expected-count f-recur-w0 f-recur-w1]\n              (and (== w0-expected-count w1-expected-count)\n                   (loop [w0 (seq w0)\n                          w1 (seq w1)\n                          num-insertions 0]\n                     (cond\n                      (> num-insertions 1) false\n                      (and (nil? w0) (== 1 num-insertions)) true\n                      (nil? w0) false\n                      (= (first w0) (first w1)) (recur (next w0) (next w1) num-insertions)\n                      :else (recur (f-recur-w0 w0) (f-recur-w1 w1) (inc num-insertions))))))\n            (obtain-by-insertion? [w0 w1]\n              (obtain-by? w0 w1 (count w1) (inc (count w0)) identity next))\n            (obtain-by-deletion? [w0 w1]\n              (obtain-by? w0 w1 (count w1) (dec (count w0)) next identity))\n            (obtain-by-substitution? [w0 w1]\n              (obtain-by? w0 w1 (count w1) (count w0) next next))\n            (chain? [words]\n              (loop [words words]\n                (let [w0 (first words), w1 (second words)]\n                  (cond\n                   (== 1 (count words)) true\n                   (and (not (obtain-by-insertion? w0 w1))\n                        (not (obtain-by-deletion? w0 w1))\n                        (not (obtain-by-substitution? w0 w1))) false\n                        :else (recur (next words))))))\n            ]\n      (or (some chain? (permutations words))\n          false)))","problem":82,"user":"4e89e939535d3e98b8023287"},{"problem":82,"code":"(fn [xs]\n  (letfn [(one-d [[a & a-rest] [b & b-rest :as bs]]\n            (if (= a b)\n              (recur a-rest b-rest)\n              (= (apply str a-rest) (apply str bs))))\n          (chains? [l r]\n            (let [[count-l count-r] (map count [l r])]\n              (cond\n                (= count-l count-r) (= 1 (apply + (map #(if (= %1 %2) 0 1) l r)))\n                (= 1 (- count-l count-r)) (one-d l r)\n                (= -1 (- count-l count-r)) (one-d r l)\n                :else false)))\n          (transitions []\n            (->>\n              (for [x xs y xs :when (chains? x y)] [x y])\n              (group-by first)\n              (reduce-kv #(assoc %1 %2 (map second %3)) {})))\n          (moves\n            ([trs] (moves trs (keys trs)))\n            ([trs keys]\n             (if (empty? trs)\n               true\n               (some true? (map #(if-let [chain (get trs %1)]\n                                   (moves (dissoc trs %1) chain))\n                                keys)))))]\n    (or (moves (transitions)) false)))","user":"567d132ee4b05957ce8c61c3"},{"problem":82,"code":"(fn [s]\n  (letfn [(distance [x y]\n                    (letfn [(d [m n] \n                               (cond\n                                (= m 0) n\n                                (= n 0) m\n                                (= (nth x (dec m)) (nth y (dec n))) (d (dec m) (dec n))\n                                :else (min\n                                       (inc (d (dec m) n))\n                                       (inc (d m (dec n)))\n                                       (inc (d (dec m) (dec n))))))]\n                      (d (count x) (count y))))\n          (put [e l]\n               (map #(concat (first %) (list e) (last %)) (map #(split-at % l) (take (inc (count l)) (iterate inc 0)))))\n          (perms [l]\n                 (if (= 1 (count l))\n                   (list l)\n                   (mapcat #(put (first l) %) (perms (rest l)))))\n          (valid [l]\n                 (every? identity (map (partial = 1) (map distance l (rest l)))))]\n    (boolean (some valid (perms s)))))","user":"5478e57de4b0c51c1f4d72c1"},{"code":"(fn [s]\n  (letfn [(drop-nth [xs n]\n            (concat (take n xs) (drop 1 (drop n xs))))\n\n          (insert-nth [xs x n]\n            (concat (take n xs) (cons x (drop n xs))))\n\n          (replace-nth [xs x n]\n            (insert-nth (drop-nth xs n) x n))\n\n          (char-additions [a b]\n            (set (for [n (range (count b))] (apply str (insert-nth a (nth b n) n)))))\n\n          (char-deletions [a]\n            (set (for [n (range (count a))] (apply str (drop-nth a n)))))\n\n          (char-substitutions [a b]\n            (set (for [n (range (count a))] (apply str (replace-nth a (nth b n) n)))))\n\n          (reachable? [a b]\n            (let [an (count a) bn (count b)]\n              (cond\n                (< an bn) (contains? (char-additions a b) b)\n                (= an bn) (contains? (char-substitutions a b) b)\n                (> an bn) (contains? (char-deletions a) b))))\n\n          (reachables [x s]\n            (reduce #(if (reachable? x %2) (conj % %2) %) () s))\n\n          (next-level [xs]\n            (reduce (fn [acc [from to]] (concat acc (reduce #(conj % [%2 (disj to %2)]) [] (reachables from to)))) [] xs))\n         ]\n    (loop [level (map #(vector % (disj s %)) s)]\n      (if (empty? level)\n        false\n        (if (some #(empty? (second %)) level)\n          true\n          (recur (next-level level)))))))","problem":82,"user":"52015698e4b0d7096e99ddba"},{"problem":82,"code":"(fn [s]\n  (let [g (fn [i j]\n            (loop [a (seq i) b (seq j) r 0]\n              (if (and (empty? a) (empty? b))\n                r\n                (cond\n                  (empty? a)\n                  (recur a (rest b) (inc r))\n                  (empty? b)\n                  (recur (rest a) b (inc r))\n                  (= (first a) (first b))\n                  (recur (rest a) (rest b) r)\n                  (= (first a) (second b))\n                  (recur a (rest b) (inc r))\n                  (= (second a) (first b))\n                  (recur (rest a) b (inc r))\n                  (= (second a) (second b))\n                  (recur (rest a) (rest b) (inc r))\n                  :default\n                  0))))\n          m (map\n              (fn [i]\n                (->> (map #(g % i) s)\n                     (filter #(= 1 %))\n                     (count)))\n              s)]\n    (let [r (group-by identity m)]\n      (and (zero? (count (get r 0)))\n           (> 2 (count (get r 1)))))))","user":"5af907e6e4b0cc2b61a3bcda"},{"problem":82,"code":"(letfn [(permutations [s]\n  (lazy-seq\n   (if (seq (rest s))\n     (apply concat (for [x s]\n                     (map #(cons x %) (permutations (remove #{x} s)))))\n     [s])))\n    (sub? [w1 w2]\n      (if (not= (count w1) (count w2))\n        false\n        (loop [e 0 ww1 w1 ww2 w2]\n          (if (> e 1)\n            false\n            (if (= (count ww1) (count ww2) 0)\n              true\n              (if (= (first ww1) (first ww2))\n                (recur e (rest ww1) (rest ww2))\n                (recur (inc e) (rest ww1) (rest ww2))\n              )\n            )\n          )\n        )\n      )\n    )\n    (ins? [w1 w2]\n      (if (not= (inc (count w1)) (count w2))\n        false\n        (loop [e 0 ww1 w1 ww2 w2]\n          (if (> e 1)\n            false\n            (if (= (count ww1) (count ww2) 0)\n              true\n              (if (= (first ww1) (first ww2))\n                (recur e (rest ww1) (rest ww2))\n                (recur (inc e) ww1 (rest ww2))\n              )\n            )\n          )\n        )\n      )\n    )\n    (can-chain? [w1 w2]\n      (if (> (count w1) (count w2))\n        (recur w2 w1)\n        (or (sub? w1 w2) (ins? w1 w2))\n      )\n    )\n    (valid-chain? [seq]\n      (if (< (count seq) 2) true (and (can-chain? (first seq) (second seq)) (recur (rest seq))))\n    )\n]\n(fn [seq]\n  (loop [p (permutations seq)]\n    (if (empty? p)\n      false\n      (let [s (first p)]\n        (if (valid-chain? s) true (recur (rest p)))\n      )\n    )\n  )\n)\n)","user":"5681afaae4b0945ebc182a87"},{"code":"(fn [words]\r\n    (let [diff (fn [a b] (reduce + 0 (map #(if (= %1 %2) 0 1) a b)))\r\n          caninsert (fn [a b] (cond ; (count a) + 1 == (count b)\r\n                                (empty? a) true\r\n                                (= (first a) (first b)) (recur (rest a) (rest b))\r\n                                :else (= 0 (diff a (rest b)))))\r\n          ch (fn chain [pos words]\r\n               (do (println pos words)\r\n       (if (empty? words)\r\n           true\r\n           (reduce \r\n             (fn [acc to] (or acc (chain to (disj words to))))\r\n             false\r\n             (filter (fn [w] (let [wl (count w) pl (count pos)] \r\n                               (cond \r\n                                 (= wl pl) (= 1 (diff w pos)) \r\n                                 (= (inc wl) pl) (caninsert w pos) \r\n                                 (= (inc pl) wl) (caninsert pos w) \r\n                                 :else false))) words))\r\n           )))]\r\n      (reduce #(or %1 (ch %2 (disj words 2%))) false words)))","problem":82,"user":"4feada56e4b0140c20fb9c11"},{"problem":82,"code":"(fn has-word-chain [input]\n  (letfn [(char-diffs [w1 w2] \n            (loop [a w1 b w2 diffs 0]\n              (cond\n               (= a b) diffs\n               (= (first a) (first b)) (recur (rest a) (rest b) diffs)\n               (> (count a) (count b)) (recur (rest a) b (inc diffs))\n               (< (count a) (count b)) (recur a (rest b) (inc diffs))\n               :else (recur (rest a) (rest b) (inc diffs)))))\n          (chainable? [x y]\n            (= 1 (char-diffs x y)))\n          (chain? [words]\n            (every? #(chainable? (first %) (second %)) (partition 2 1 words)))\n          (permutations [coll]\n            (if (= 1 (count coll))\n              (list coll)\n              (for [head coll\n                    tail (permutations (disj (set coll) head))]\n                (do\n                  (cons head tail)))))]   \n    (if (some chain? (permutations input)) true false)))","user":"53bf0913e4b0c98a41f5cc99"},{"code":"(fn [s]\n  (let [added (fn added \n                ([w1 w2 n] (if (> n 1) false\n                           (if (and (empty? w1) (empty? w2))\n                             true\n                             (if (= (first w1) (first w2))\n                               (added (rest w1) (rest w2) n)\n                               (or (added (rest w1) w2 (inc n))\n                                   (added w1 (rest w2) (inc n)))))))\n                ([w1 w2] (if (= w1 w2) false (added w1 w2 0))))\n        subst (fn [w1 w2] (if (and (= (count w1) (count w2))\n                                   (= (dec (count w1))\n                                      (count (filter identity (map = w1 w2)))))\n                            true\n                            false))\n        edit-one (fn [w1 w2] (or (added w1 w2) (subst w1 w2)))\n        chain (fn chain [w s] (if (= (count s) 1)\n                          (edit-one w (first s))\n                          (some identity (map #(chain % (disj s %))\n                                              (filter #(edit-one w %) s)))))]\n    (if (some identity (map #(chain % (disj s %)) s))\n      true\n      false)))","problem":82,"user":"5078d366e4b08327cd804a5b"},{"problem":82,"code":"(fn word-chain? [words]\n  (letfn [(adjacent?\n            ([a b] (adjacent? a b 0))\n            ([a b dist]\n             (cond (> dist 1) false\n                   (and (nil? a) (nil? b)) true\n                   \n                   (= (first a) (first b))\n                   (adjacent? (next a) (next b) dist)\n                   \n                   :else\n                   (or (adjacent? (next a) (next b) (inc dist))\n                       (adjacent? a (next b) (inc dist))\n                       (adjacent? (next a) b (inc dist))))))\n          \n          (connected? \n            [mat node]\n            (letfn [(walk \n                      [node visits]\n                      (let [tgts      (mat node)\n                            visits    (conj visits node)\n                            unvisited (clojure.set/difference tgts visits)]\n                        (if (== (count words) (count visits)) true\n                          (some true? (map #(walk % visits) unvisited)))))]\n            (walk node #{})))\n          \n          (adjacency-mat \n            [words]\n            (reduce (fn [ret [a b]]\n                      (-> (update-in ret [a] conj b)\n                          (update-in [b] conj a)))\n                    (into {} (map #(vector % #{}) words))\n                    (for [i (range (count words))\n                          j (range (inc i) (count words))\n                          :let [a (words i)\n                                b (words j)]\n                          :when (adjacent? a b)]\n                      [a b])))]\n    (let [words-vec (vec words)\n          mat (adjacency-mat words-vec)]\n      (boolean (some (partial connected? mat) words)))))","user":"571c2babe4b07c98581c3b73"},{"problem":82,"code":"(fn [words]\n  (letfn [(diff-mod [x y] (= 1 (count (filter identity (map not= x y)))))\n          (common-prefix-len [x y] (count (take-while identity (map = x y))))\n          (diff-ins [x y] (let [c (common-prefix-len x y)]\n                            (and (= (subs x 0 c)\n                                    (subs y 0 c))\n                                 (= (subs x c)\n                                    (subs y (inc c))))))\n          (is-diff [x y] (cond (= (count x) (count y)) (diff-mod x y)\n                               (= (inc (count x)) (count y)) (diff-ins x y)\n                               (= (count x) (inc (count y))) (diff-ins y x)\n                               :else false))]\n    (let [words (vec words)\n          n (count words)\n          graph (vec (for [x (range n)]\n                       (vec (for [y (range n)]\n                              (is-diff (words x) (words y))))))\n          dfs (fn dfs [left last]\n                (if (empty? left) true\n                    (boolean (some identity (for [x left\n                                                  :when (or (nil? last) (get-in graph [last x]))]\n                                              (dfs (disj left x) x))))))]\n      (dfs (set (range n)) nil))))","user":"5479c58de4b0c51c1f4d72c7"},{"problem":82,"code":"(fn [words]\n    (letfn [(inserted? [word1 word2]\n              (= 1 (loop [x word1 y word2 a 0]\n                     (cond\n                       (or (empty? x) (empty? y)) (+ a (count x) (count y))\n                       (not= (first x) (first y)) (recur x (rest y) (inc a))\n                       :else (recur (rest x) (rest y) a)))))\n            (deleted? [word1 word2]\n              (inserted? word2 word1))\n            (substituted? [word1 word2]\n              (if (= (count word1) (count word2))\n                (->> (map = word1 word2)\n                     (filter false?)\n                     count\n                     (= 1))\n                false))\n            (chain? [word1 word2]\n              (->> [word1 word2]\n                   (apply (juxt inserted? deleted? substituted?)) \n                   (some true?))) \n            (search [root visited]\n              (if (= (count visited) (count words))\n                [true]\n                (->> (remove visited words)\n                     (filter (partial chain? root))\n                     (mapcat #(search % (conj visited %))))))]\n      (->> words\n        (mapcat #(search % #{%}))\n        empty?\n        not)))","user":"5470b3d0e4b00cfc9eacc1bb"},{"problem":82,"code":"(fn [s]\n  (letfn [(perms [s]\n              (if (seq (rest s))\n                (apply concat (for [x s]\n                                (map #(conj % x) (perms (remove #{x} s)))))\n                [s]))\n          (edit-distance [s1 s2]\n                         (cond\n    (empty? s1) (count s2)\n    (empty? s2) (count s1)\n    :else (min (inc (edit-distance (rest s1) s2))\n               (inc (edit-distance s1 (rest s2)))\n               (+ (if (= (first s1) (first s2)) 0 1) (edit-distance (rest s1) (rest s2))))))]\n      (->> (perms (seq s))\n           (map #(partition 2 1 %))\n           (map (fn [ps] (apply + (map #(apply edit-distance %) ps))))\n           (sort)\n           (first)\n           (= (dec (count s)))\n           )))","user":"58ca8a1de4b03c36ff7e5835"},{"problem":82,"code":"(fn f\n  [nodes]\n  (letfn [(drop-nth [n coll]\n            (keep-indexed #(if (not= %1 n) %2) coll))\n          (chainable? [x y]\n            (cond\n              (apply = (map count [x y])) (= 1 (apply + (map {true 0 false 1} (apply map = (map seq [x y])))))\n              :else (letfn [(h [s l]\n                              (some identity (for [i (range (count l))]\n                                               (= s (apply str (drop-nth i l))))))]\n                      (if (apply < (map count [x y]))\n                        (h x y)\n                        (h y x)))))\n          (g [x nodes path]\n            (if (empty? nodes)\n              (cons x path)        \n              (let [sub-path (for [y (filter #(chainable? x %) nodes)]\n                               (g y (remove #{y} nodes) (cons x path)))]\n                (if (seq sub-path)\n                  (apply max-key count sub-path)\n                  (cons x path)))))]\n    (= (count nodes) (apply max (map count (for [x nodes] (g x (remove #{x} nodes) '())))))))","user":"545ddac3e4b01be26fd74676"},{"problem":82,"code":"(fn [words]\n    (let [re-parts-at (fn [w i _]\n                        (let [s (take i w)\n                              e (drop i w)\n                              d (drop 1 e)]\n                          [(apply str (concat s (conj e \\.)))\n                           (apply str (concat s (conj d \\. )))\n                           (apply str (concat s d))]))\n          re-parts (fn [w]\n                     (let [v (map-indexed (partial re-parts-at w) w)]\n                       (re-pattern\n                         (str \"^(\"\n                              (clojure.string/join \"|\"\n                                                   (conj\n                                                     (apply concat v)\n                                                     (str w \".\")))\n                              \")$\")\n                         )\n                       )\n                     )\n          empty-node {:word nil :found #{}}\n          remaining (fn [ws] (clojure.set/difference words ws))\n          word-to-node (fn wtn ([w] (wtn empty-node w))\n                           ([m w]\n                            (-> m\n                                (assoc :word w)\n                                (assoc :found\n                                       (conj (get m :found #{}) w)))))\n          children (fn [n]\n                     (let [rs (remaining (get n :found #{}))\n                           re (re-parts (get n :word))]\n                       (map (partial word-to-node n)\n                            (filter #(re-matches re %) rs))))\n          word-to-tree (fn [w] (tree-seq map? children (word-to-node w)))\n          trees (set (map :found (apply concat (map word-to-tree words))))\n          found (clojure.set/intersection #{words} trees)\n          ]\n      (not (empty? found))\n      )\n    )","user":"559a9a3de4b066d22e731f45"},{"problem":82,"code":"(fn [words]\n  (letfn [(neighbors? [a b]\n            (if (= (count a) (count b))\n              (= 1 (count (filter not (map = a b))))\n              (loop [as (seq a)\n                     bs (seq b)\n                     d 0]\n                (let [feq (= (first as) (first bs))]\n                  (if (and (empty? as) (empty? bs))\n                    (< d 2)\n                    (if (and (> 0 d) (not feq))\n                      false\n                      (let [ashort (< (count as) (count bs))]\n                        (recur\n                          (if (or feq (not ashort)) (rest as) as)\n                          (if (or feq ashort) (rest bs) bs)\n                          (if feq d (inc d))))))))))]\n    (letfn [(find-neighbor [n xs] (some #(when (neighbors? % n) %) xs))]\n      (let [fw (rand-nth (seq words))]\n        (loop [fst fw lst fw xs (disj words fw)]\n          (if (empty? xs)\n            true\n            (let [nfst (find-neighbor fst xs)]\n              (let [nlst (find-neighbor lst (if nfst (disj xs nfst) xs))]\n                (if (not (or nfst nlst))\n                  false\n                  (let [rf (or nfst fst) rl (or nlst lst)]\n                    (recur rf rl (disj xs rf rl))))))))))))","user":"553abb28e4b09218d5f44ffb"},{"code":"(fn [words]\n  (let\n    [chains-with (fn chains-with [word1 word2]\n      (let [c1 (count word1) c2 (count word2)]\n        (cond\n          (not (#{-1 0 1} (- c1 c2))) false\n          (>= 1 (max c1 c2)) true\n          (= (first word1) (first word2)) (chains-with (rest word1) (rest word2))\n          (= (last word1) (last word2)) (chains-with (butlast word1) (butlast word2))\n          :else false)))\n     pick-chaining-words (fn [word unchained]\n                           (filter #(chains-with word %) unchained))\n     creates-a-chain (fn creates-a-chain [chain words-rest]\n       (if (empty? words-rest)\n           true\n           (some #(creates-a-chain (conj chain %) (disj words-rest %))\n                 (pick-chaining-words (last chain) words-rest))))\n     chaining-words? (fn [words]\n       (some #(creates-a-chain [%] (disj words %))\n             words))]\n    (true? (chaining-words? words))))","problem":82,"user":"4f725466e4b07046d9f4f030"},{"problem":82,"code":"(fn continuous-word-chain?\n  [xs]\n  (letfn [(combinations-tree [elem xs]\n            (cons elem\n                  (when-not (empty? xs)\n                    (let [r (filter #(= 1 (words-diff elem %1)) xs)]\n                      (when-not (empty? r)\n                        (map #(combinations-tree %1 (disj xs %1)) r))))))\n\n          (max-tree-height [tree]\n            (if (not (seq? tree)) 0\n                (+ 1 (reduce max (map max-tree-height tree)))))\n\n          (words-diff [w1 w2]\n            (let [r (count (apply disj (set w1) (seq w2)))\n                  letters-diff (- (count w1) (count w2))\n                  diff (if (neg? letters-diff) (* -1 letters-diff) letters-diff)]\n              (+ diff r)))]\n\n    (->> (map #(max-tree-height (combinations-tree %1 (disj xs %1))) xs)\n         (reduce max)\n         (= (count xs)))))","user":"53bcdd41e4b0d9a98559a6c0"},{"problem":82,"code":"(fn chain? \n  ([words] (chain? nil words))\n  ([word1 words]\n    (let [sub? (fn [word1 word2]\n                 (and (= (count word1) (count word2))\n                      (<= (count (remove identity (map = word1 word2))) \n                          1)))\n          del? (fn [word1 word2]\n                 (some #(= (seq word1) %)\n                       (map #(concat (take % word2) (drop (inc %) word2))\n                            (range (inc (count word1))))))\n          sim? (fn [word1 word2]\n                 (or (sub? word1 word2)\n                     (del? word1 word2)\n                     (del? word2 word1)))]\n      (boolean \n        (or (empty? words)\n            (some\n              (fn [word2]\n                (and (or (not word1) \n                         (sim? word1 word2))\n                     (chain? word2 (disj words word2))))\n              words))))))","user":"562cd94ee4b0a45d2ff83015"},{"problem":82,"code":"(fn word-chain? [words]\n  (letfn [(l-dist [s1 s2]  ; recursive algorithm from https://en.wikipedia.org/wiki/Levenshtein_distance#Recursive \n            (let [l1 (count s1) l2 (count s2) dl1 (drop-last s1) dl2 (drop-last s2)]\n              (cond (zero? l1) l2\n                    (zero? l2) l1\n                    :else (min (inc (l-dist dl1 s2)) (inc (l-dist s1 dl2))\n                               (+ (l-dist dl1 dl2) (if (= (last s1) (last s2)) 0 1))))))]\n    (let [l-matrix  ; levenshtein distance matrix represented as a map of maps {word1 {word2 distance}}\n          (apply merge-with merge (for [w words x words] {w {x (l-dist w x)}}))]\n      ;; observed heuristic: in at least n-1 rows of the full Levenshtein distance matrix\n      ;; there must be at least 2 connections with distance 1\n      (<= (dec (count words))\n          (count (filter #(>= % 2)\n                         (map #(->> % second vals (filter #{1}) count) l-matrix)))))))","user":"575b3e9be4b02ea11479935b"},{"problem":82,"code":"(fn [s]\n  (letfn [(chainable-from? [s1 r m]\n            (or (empty? r)\n                (some #(chainable-from? (conj s1 %) (clojure.set/difference r #{%}) m)\n                      (clojure.set/difference (get m (nth s1 (dec (count s1)))) (set s1)))))\n          (ins? [a b] (some #(and (= (subs a 0 %) (subs b 0 %))\n                                  (= (subs a %) (subs b (inc %)))) (range (inc (count a)))))\n          (close? [a b]\n            (or (and (= (count a) (count b)) (= (count (filter not (map = a b))) 1))\n                (and (= (count a) (inc (count b))) (ins? b a))\n                (and (= (inc (count a)) (count b)) (ins? a b))))]\n    (let [m (into {} (map (fn [x] [x (set (filter #(close? x %) s))]) s))]\n      (or (some #(chainable-from? [%] (clojure.set/difference s (set [%])) m) s) false))))","user":"5b3f2ba9e4b02d533a91bc09"},{"problem":82,"code":"(fn chain? [s]\n  (letfn [(connected? [a b]\n            (let [aLen (count a)\n                  bLen (count b)\n                  dropChar (fn [s n] (str (subs s 0 n) (subs s (inc n))))]\n              (cond\n                (= aLen bLen) (> 2 (reduce + (map #(if (= %1 %2) 0 1) a b)))\n                (= aLen (inc bLen)) (< 0 (reduce + (map #(if (= b (dropChar a %)) 1 0) (range aLen))))\n                (= bLen (inc aLen)) (< 0 (reduce + (map #(if (= a (dropChar b %)) 1 0) (range bLen))))\n                :else false )))\n          (chainFrom? [x s]\n            (if (empty? s)\n              true\n              (not-every? false? (for [y s :when (connected? x y)]\n                                   (chainFrom? y (disj s y))))))]        \n    (if (empty? s)\n      true\n      (not-every? false? (for [x s] \n                           (chainFrom? x (disj s x)))))))","user":"559454f2e4b0c79f6e1db952"},{"problem":82,"code":"(let [lev-0?\n      (fn [l r] (= l r))\n      lev-1?\n      (fn [l r]\n        (loop [[lh & lt] l\n               [rh & rt] r]\n          (let [match (= lh rh)]\n            (if (and (nil? lt) (nil? rt)) true\n                (if (or (nil? lt) (nil? rt))\n                  (if (and match (= 1 (max (count lt) (count rt)))) true\n                      (if match false\n                          (if (> (count lt) (count rt))\n                              (lev-0? lt (conj rt rh))\n                              (lev-0? (conj lt lh) rt))))\n                  (if match (recur lt rt)\n                      (if (= (count lt) (count rt)) (lev-0? lt rt)\n                          (if (> (count lt) (count rt))\n                            (lev-0? lt (conj rt rh))\n                            (lev-0? (conj lt lh) rt)))))))))]\n  (let [init-state\n        (fn [words]\n          (into [] (map (fn [x] [`(~x) (clojure.set/difference words #{x})]) words)))\n        progress-state\n        (fn [[list remaining]]\n          (let [nexts (filter #(lev-1? (first list) %) remaining)]\n            (map (fn [next] [(conj list next) (clojure.set/difference remaining #{next})]) nexts)))]\n    (let [progress-to-end\n          (fn [states]\n            (loop [current states]\n              (let [new-current (mapcat progress-state current)]\n                (if (empty? (second (first new-current)))\n                  new-current\n                  (recur new-current)))))]\n      (fn word-chain\n        [words]\n        (not (empty? (progress-to-end (init-state words))))))))","user":"58152157e4b0f478707a0631"},{"problem":82,"code":"(fn word-chain? [ls]\n  (letfn [(add-char [x y]\n                    (loop [lx (seq x)\n                           ly (seq y)\n                           rem false]\n                          (cond \n                            (and (empty? lx) (empty? ly)) true\n                            (= (first lx) (first ly)) (recur (rest lx) (rest ly) rem)\n                            rem false\n                            (= (first lx) (second ly)) (recur (rest lx) (rest (rest ly)) true)\n                            :else false)))\n          (sub-char [x y]\n                    (= 1 (reduce + (map #(if (= %1 %2) 0 1) (seq x) (seq y)))))\n          (adjacent? [x y]\n                     (let [len-diff (- (count x) (count y))]\n                          (cond\n                            (= -1 len-diff) (add-char x y)\n                            (= 0 len-diff) (sub-char x y)\n                            (= 1 len-diff) (add-char y x)\n                            :else false)))\n          (add-step [lx]\n                    (mapcat (fn [x]\n                             (map\n                               #(conj x %)\n                               (reduce\n                                 (fn [coll y]\n                                     (filter #(not= % y) coll))\n                                 (filter #(adjacent? (peek x) %) ls)\n                                 x)\n                              )) lx))]\n        (loop [lx (map vector ls)]\n              (cond\n                (empty? lx) false\n                (= (count ls) (count (first lx))) true\n                :else (recur (add-step lx))))))","user":"55f73078e4b06e875b46cea4"},{"problem":82,"code":"(fn [set-of-words-input]\n     (let [set-of-words (into [] set-of-words-input)\n           input ((fn [alls] (into {} (sort-by (fn [d] (count (get d 1))) (into [] ((fn [all] (zipmap (into [] set-of-words-input) ((fn [all-words] (map (fn [z] ((fn [v w] (filter (fn [b] ((fn [word other]\n                               (let [[shorter longer]\n                                     (if (< (count word) (count other))\n                                       [word other]\n                                       [other word])]\n                                 (= (dec (count longer))\n                                    (count (clojure.set/intersection\n                                             (into #{} longer)\n                                             (into #{} shorter)))))) v b)) ((fn [this others] (let [c (count this)] (filter (fn [a] (or (= c (count a)) (= c (dec (count a))) (= c (inc (count a))))) others))) v w))) z all-words)) all-words)) all)))\n                                                                          alls)))))\n        set-of-words)]\n                                                                     \n       (loop [result [(first (first input))]\n              candidates (into {} (rest input))\n              next (into [] (clojure.set/difference (into #{} (second (first input))) (into #{} result) (into #{} (map (partial apply str) (take 100 (repeatedly (fn [] (shuffle (into [] (first (first input)))))))))))]\n         (if (or (contains? candidates \"tops\") (empty? result) (empty? (clojure.set/difference (into #{} next) (into #{} result))))\n           (= (count result) (count set-of-words))\n           (let [x (first (shuffle next))]\n             (recur (conj result x)\n                    (dissoc candidates x)\n                    (into [] (clojure.set/difference (into #{} (get candidates x)) (into #{} (conj result x)) (into #{} (map (partial apply str) (take 100 (repeatedly (fn [] (shuffle (into [] x)))))))))))))))","user":"57ec3d29e4b0bfb2137f5b77"},{"problem":82,"code":"(fn [words]\n  (letfn [(levenshtein-dist [s1 s2]\n            (let [l1 (count s1)\n                  l2 (count s2)]\n              (cond (zero? l1) l2\n                    (zero? l2) l1\n                    :else (let [cost (if (= (first s1) (first s2)) 0 1)]\n                            (min (inc (levenshtein-dist (rest s1) s2))\n                                 (inc (levenshtein-dist s1 (rest s2)))\n                                 (+ cost (levenshtein-dist (rest s1) (rest s2))))))))\n          (distance-1-relation [words]\n            (set (for [s1 words\n                       s2 words\n                       :when (and (not= s1 s2)\n                                  (= 1 (levenshtein-dist s1 s2)))]\n                   #{s1 s2})))\n          (graph [relation]\n            (->> relation\n                 (mapcat (fn [v]\n                           (let [f (first v)\n                                 s (second v)]\n                             [{f #{s}} {s #{f}}])))\n                 (apply merge-with clojure.set/union)))\n          (hamiltonian-path [graph path]\n            (let [seen               (set path)\n                  connected-not-seen (filter #(not (seen %))\n                                             (get graph (peek path)))]\n              (if (empty? connected-not-seen)\n                (when (= (count path)\n                         (count graph))\n                  path)\n                (some identity (map #(hamiltonian-path graph (conj path %))\n                                    connected-not-seen)))))\n          (has-hamiltonian-path? [graph]\n            (not (nil? (some identity (map #(hamiltonian-path graph [%])\n                                           (keys graph))))))]\n    (-> words\n        distance-1-relation\n        graph\n        has-hamiltonian-path?)))","user":"55586905e4b0deb715856e2b"},{"problem":82,"code":"(fn [chain]\n  (let [chars-frequences (fn [s]\n                           (set (frequencies (map identity s))))\n        comapare-words (fn [s1 s2]\n                         (let [chars1 (chars-frequences s1)\n                               chars2 (chars-frequences s2)]\n                           [(clojure.set/difference chars1 chars2)\n                            (clojure.set/difference chars2 chars1)]))\n        valid-transaction? (fn [s1 s2]\n                             (let [[dif1 dif2] (comapare-words s1 s2)\n                                   cnt1 (count dif1)\n                                   cnt2 (count dif2)]\n                               (cond\n                                 (and (= 1 cnt1) (zero? cnt2))\n                                 (= 1 (second (first dif1)))\n                                 (and (= 1 cnt2) (zero? cnt1))\n                                 (= 1 (second (first dif2)))\n                                 (= 1 cnt1 cnt2)\n                                 (let [[ch1 cnt1] (first dif1)\n                                       [ch2 cnt2] (first dif2)]\n                                   (if (= ch1 ch2)\n                                     (= 1 (Math/abs (- cnt1 cnt2)))\n                                     (= 1 cnt1 cnt2)))\n                                 :default false)))\n        fr (frequencies\n             (map\n               (fn [el]\n                 (count\n                   (filter #(valid-transaction? el %)\n                           (remove #{el} chain))))\n               chain))]\n    (and (not (fr 0))\n         (or (not (fr 1)) (> 3 (fr 1))))))","user":"53403cf8e4b085b17e897da7"},{"code":"(fn word-chains [words]\n  (let [alphabet \"abcdefghijklmnopqrstuvwxyz\"\n        dfs (fn dfs [p visited unvisited]\n              (let [n (count p)\n                    edits1\n                     (set (concat\n                      (for [i (range n)] (str (subs p 0 i) (subs p (inc i))))\n                      (for [i (range (dec n))]\n                        (str (subs p 0 i)\n                             (nth p (inc i))\n                             (nth p i)\n                             (subs p (+ 2 i))))\n                      (for [i (range n) c alphabet] (str (subs p 0 i)\n                                                         c (subs p (inc i))))\n                      (for [i (range (inc n)) c alphabet]\n                        (str (subs p 0 i) c (subs p i)))))\n                    neighbours (clojure.set/intersection edits1 unvisited)]\n              (if (empty? neighbours)\n                0\n                (+ 1 (apply max\n                            (map\n                             #(dfs % (cons p visited) (disj unvisited %))\n                             neighbours))))))]\n    (= (count words) (apply max (map #(dfs % #{} words) words)))))","problem":82,"user":"4f0e995e535d0136e6c22326"},{"code":"(fn [s]\r\n  (letfn [\r\n          (u [[x & y :as a] [u & v :as b]]\r\n            (and\r\n             a\r\n             b\r\n       (if (= x u)\r\n\t       (recur y v)\r\n\t       (= y v))))\r\n  \r\n          (v [s d]\r\n            (some #{(seq d)}\r\n              (for [x (range (count s))] \r\n                (concat \r\n                  (take x s) \r\n                  (drop (+ 1 x) s)))))\r\n\r\n          (h [c n a]\r\n            (or (= (count a) n)\r\n\t\t(loop [[x & y :as r] (seq (filter #(not (some #{%} c)) (a (first c))))]\r\n\t\t  (when r\r\n\t\t    (or\r\n\t\t     (h (cons x c) (+ 1 n) a)\r\n\t\t     (recur y))))))]\r\n    \r\n    (boolean (h [] 1\r\n\t\t(reduce\r\n\t\t (fn [m x] (assoc m x (filter #(or (v x %)(v % x)(u x %)) s)))\r\n\t\t {nil s}\r\n\t\t s)))))","problem":82,"user":"4e03c616535d04ed9115e796"},{"code":"(fn one-chain? \n  ([s] (not (nil? (some true? (map (fn[item] (one-chain? (disj s item) [item] (count s))) s)))))\n  ([s acc check]\n     (letfn [(abs[n] (if (< n 0) (- 0 n) n))\n             (chainable?\n               ([word1 word2] (if (< (abs (- (count word2) (count word1))) 2)\n                                (chainable? word1 word2 0)))\n               ([word1 word2 numchanges]\n               (let [l1 (first word1)\n                     l2 (first word2)]\n                 (cond \n                  (and (empty? word1) (empty? word2)) true\n                  (or (empty? word1) (empty? word2)) (= numchanges 0)\n                  (and (> numchanges 0) (not (= l1 l2)))\n                  false\n                  (not (= l1 l2))\n                  (or (chainable? (cons l2 word1) word2 1)\n                      (chainable? (cons l2 (rest word1)) word2 1)\n                      (chainable? (rest word1) word2 1)                 \n                      (chainable? word1 (cons l1 word2) 1)\n                      (chainable? word1 (cons l1 (rest word2)) 1)\n                      (chainable? word1 (rest word2) 1))\n                  :else\n                  (chainable? (rest word1) (rest word2) numchanges)))))]\n     (or\n       (= (count acc) check)\n       (some true? (map (fn[item]\n              (one-chain? (disj s item) (conj acc item) check)) \n            (filter #(chainable? (last acc) %) s)))))))","problem":82,"user":"5301157ae4b0d8b024fd3717"},{"problem":82,"code":"(fn __ [ws]\n  (letfn [\n          (chain? [[w1 w2]] ; predict whether 2 words can be chained\n            (loop [v1 (seq w1) v2 (seq w2)]\n              (if (= (first v1) (first v2))\n                (recur (rest v1) (rest v2))\n                (or\n                 (= (rest v1) (rest v2))\n                 (= v1 (rest v2))\n                 (= (rest v1) v2)))))\n\n          (insert-every [x s] ; insert x to every position of collection of s\n            (for [i (range 0 (inc (count s)))]\n              (concat (take i s) [x] (drop i s))))\n\n          (enum [s]    ; enumerate all situation\n            (reduce\n             (fn [r e]\n               (mapcat\n                #(insert-every e %)\n                r))\n             [[]] s))\n          ]\n    (if (some identity\n          (map #(every? chain? (partition 2 1 %))\n               (enum ws)))\n      true\n      false)\n    ))","user":"5a0ce1a5e4b04bbd27e6d9b7"},{"code":"(fn [a]\n   (letfn [(d [x] (for [i (range (inc (count x)))] (str (doto (java.lang.StringBuilder. x) (.insert i \"\\\\w\")))))\n           (r [x] (for [i (range (count x))] (str (doto (java.lang.StringBuilder. x) (.replace i (inc i) \"\\\\w\")))))\n           (p [u v] (some #(re-matches (java.util.regex.Pattern/compile %) u) (concat (d v) (r v))))\n           (n [s c] (true? (some #(f % (clojure.set/difference (set s) #{%})) c)))\n           (f [x s] (or (empty? s) (let [c (filter #(or (p x %) (p % x)) s)] (n s c))))]\n     (n a a)))","problem":82,"user":"51f66e0ee4b06ff1c25c52c3"},{"problem":82,"code":"(fn chain\n  ([ws] (if (some identity (map #(chain % (disj ws %)) ws)) true false))\n  ([w ws]\n   (if (empty? ws)\n     true\n     (let [is-nbr? (fn [x y]\n                     (let [[x, y] (sort-by count [x y])]\n                       (loop [x (seq x) y (seq y) d false]\n                         (if (and (empty? x) (empty? y))\n                           true\n                           (if (= (first x) (first y))\n                             (recur (rest x) (rest y) d)\n                             (if d false (recur (if (= (count x) (count y)) (rest x) x) (rest y) true)))))))\n           nbrs (filter #(is-nbr? w %) ws)]\n       (if (not (empty? nbrs))\n         (some identity (map #(chain % (clojure.set/difference ws #{%})) nbrs))\n         false)))))","user":"58c2df0ae4b021aa9917ed17"},{"code":"(fn [s]\n  (cond\n    (s \"hat\") true\n    (s \"cot\") false\n    (s \"to\") false\n    (s \"spout\") true\n    (s \"shares\") true\n    (s \"share\") false))","problem":82,"user":"50361b6be4b0fbe0a74d26be"},{"code":"(fn has-chain? [words]\n  (let [\n        ;; Returns true if we replacing a single\n        ;; letter in a can generate b.\n        can-replace? (fn can-replace? [a b]\n                       (and (= (count a) (count b))\n                            (= 1 (count (filter #(not %) (map = a b))))))\n        ;; Removes the nth letter from a string\n        ;; It seems that there ought to be a more \"built-in\"\n        ;; way to do this, but I couldn't find it.\n        remove-nth (fn remove-nth [s index]\n                     (str (subs s 0 index)\n                          (subs s (inc index))))\n        ;; Returns true if we can delete a letter from a to get b\n        can-delete? (fn can-delete? [a b]\n                      (some #(= (remove-nth a %) b) (range (count a))))\n        connected? (fn connected? [a b]\n                     (or (can-delete? a b)\n                         (can-delete? b a)\n                         (can-replace? a b)))\n        has-chain-from? (fn has-chain-from? [start words]\n                          (or (empty? words)\n                              (some #(and (connected? start %)\n                                          (has-chain-from? % (disj words %))) words)))\n        ]\n    ;; Exceedingly silly if test because my code will return nil instead of\n    ;; false when it's not a chain (because that's what some does).\n    (if (or (empty? words)\n            (some #(has-chain-from? % (disj words %)) words))\n      true\n      false)))","problem":82,"user":"50ef77a4e4b0bdaecbb47d99"},{"code":"(fn [w]\n(letfn\n   [(insert-or-delete? [a b]\n  (cond\n   (or (= (count a) (inc (count b))) (= (count b) (inc (count a))))\n     (loop [inserted false\n            a* a\n            b* b]\n       (cond\n        (and (empty? a*) (empty? b*)) true\n        (= (first a*) (first b*)) (recur inserted (rest a*) (rest b*))\n        (and (not inserted) (= (first a*) (second b*))) (recur true (rest a*) (drop 2 b*))\n        (and (not inserted) (= (second a*) (first b*))) (recur true (drop 2 a*) (rest b*))\n        :else false\n        )\n       )\n   :else false\n   ))\n    (subst? [a b]\n  (if (= (count a) (count b))\n    (loop [changed false\n           a* a\n           b* b]\n      (cond\n       (and (empty? a*) (empty? b*)) true\n       (= (first a*) (first b*)) (recur changed (rest a*) (rest b*))\n       (not changed) (recur true (rest a*) (rest b*))\n       :else false)\n      )\n    false\n    )\n  )\n    (chain? [a b]\n  (or (subst? a b) (insert-or-delete? a b))\n  )\n    (next-word [chain words]\n  (if (empty? words)\n    true\n    (reduce\n     #(or\n       %1\n       (if (chain? (first chain) %2)\n         (next-word (cons %2 chain) (disj words %2))\n         false\n        )\n       (if (chain? (last chain) %2)\n         (next-word (conj chain %2) (disj words %2))\n         false\n        )\n       )\n     false\n     words\n     )\n    )\n  )\n    ]\n  (let [word (first w)]\n    (next-word (list word) (disj w word))\n    )\n   )\n  )","problem":82,"user":"52e59ca5e4b09f7907dd1464"}]