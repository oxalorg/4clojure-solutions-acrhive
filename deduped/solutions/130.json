[{"problem":130,"code":";;Tree repaenting\n(fn reparent [name parent]\n  (let [sub-tree (atom nil)\n        find-node\n        (fn search-node [target tree path]\n          (let [node-name (do  (first tree))]\n            (cond\n              (= node-name target)\n              (do\n                (reset! sub-tree [tree path])\n                (conj (keep-indexed #(if (not= %1 (first path)) %2) (rest parent))\n                      (first parent)))\n              (= (count tree) 1)\n                tree\n              :else\n              (let [res (map-indexed\n                      #(search-node target %2 (conj path %1))\n                      (rest tree))\n                    pred #(= (first %) (first parent))\n                    replaced (filter pred res)\n                    res (concat (filter (complement pred) res) replaced)\n                    ]\n                (do\n                  (println \"node-name:\" node-name \"replaced:\" replaced \"res:\" res)\n                  (conj res node-name))\n                ))))\n        parent-replaced (find-node name parent [])\n        target-tree @sub-tree]\n    (if (seq target-tree)\n      (concat (first target-tree)\n              (keep-indexed #(if (= (first (second target-tree)) %1) %2) (rest parent-replaced)))\n      parent)))","user":"54f09599e4b024c67c0cf89d"},{"problem":130,"code":"(fn [t l]\n  (letfn [(r [l m]\n            (reduce (fn [a e]\n                      (r e (conj a [(first l) (first e)])))\n                    m (rest l)))\n          (d [t x m]\n            (concat [t] (for [c (get m t)\n                              :when (not= c x)]\n                          (d c t m))))]\n    (let [l (r l [])\n          h merge-with\n          n concat\n          u reduce\n          m (u (fn [a [k v]] (h n a {k [v]})) {} l)\n          m (u (fn [a [k v]] (h n a {v [k]})) m l)]\n      (d t n m))))","user":"57d9f603e4b0bd073c20240a"},{"problem":130,"code":"(fn __ [node tree]\n  (letfn [(f [node parent tree]\n             (if (= node (first tree))\n               (if (nil? parent) [true tree]\n                 [true (concat tree [parent])])\n               (let [r (rest tree)]\n                 (if (empty? r) [false nil]\n                   (->> r\n                        (map (fn [subtree]\n                               (f node\n                                  (if (nil? parent)\n                                    (cons (first tree) (remove #(= % subtree) r))\n                                    (cons (first tree) (concat (remove #(= % subtree) r) [parent])))\n                                  subtree)))\n                        (filter #(true? (first %)))\n                        (first))))))]\n    (second (f node nil tree))))","user":"54c271b9e4b045293a27f602"},{"problem":130,"code":"(fn [n tree]\n  (let [get-parents (fn f [[x & kids]]\n                      (concat (map #(vector (first %) x) kids)\n                               (mapcat f kids)))\n        parent-of (into {} (get-parents tree))\n        path-up-from (fn f [n] (let [parent (parent-of n)]\n                                 (if parent (cons (parent-of n) (f (parent-of n))))))\n        path-to-n (reverse (path-up-from n))\n        upshift-targets (concat (rest path-to-n) (list n))\n        upshift (fn [new-root [old-root & kids]]\n                  (let [branch-to-shift (first (filter #(= new-root (first %)) kids))\n                        other-branches (remove #(= new-root (first %)) kids)]\n                    (if (nil? branch-to-shift) (cons old-root kids)\n                      (concat branch-to-shift (list (cons old-root other-branches))))))\n        ]\n    (loop [targets upshift-targets\n           current-tree tree]\n      (if (empty? targets) current-tree\n        (recur (rest targets) (upshift (first targets) current-tree))))))","user":"4e586949535d8a8b8723a292"},{"code":"(fn restructure [ s t ]\n  (if (= s (first t)) \n      t\n      (let [ n (first (filter #(some #{s} (flatten %)) (rest t) )) ]\n        (recur s (concat n (list (remove #{n} t)))))))","problem":130,"user":"4e860e85535db62dc21a62f1"},{"code":"(fn lift\n  [label tree]\n\t(letfn\n\t\t[\n\t\t\t(get-label [x] (when (sequential? x) (first x)))\n\t\t\t(path-to\n\t\t\t\t([label tree] (path-to [] label tree))\n\t\t\t\t(\n\t\t\t\t\t[path label tree]\n\t\t\t\t\t(let\n\t\t\t\t\t\t[lbl (get-label tree) path (conj path lbl)]\n\t\t\t\t\t\t(if (= label lbl)\n\t\t\t\t\t\t\tpath\n\t\t\t\t\t\t\t(mapcat\n\t\t\t\t\t\t\t\t(partial path-to path label)\n\t\t\t\t\t\t\t\t(rest tree)\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t\t(lift-local\n\t\t\t\t[tree label]\n\t\t\t\t(let\n\t\t\t\t\t[\n\t\t\t\t\t\tmatch #(= label (get-label %))\n\t\t\t\t\t\tsubtree (first (filter match tree))\n\t\t\t\t\t\tbut-subtree (remove match tree)\n\t\t\t\t\t]\n\t\t\t\t\t(concat subtree (list but-subtree))\n\t\t\t\t)\n\t\t\t)\n\t\t]\n\t\t(reduce\n\t\t\tlift-local\n\t\t\ttree\n\t\t\t(rest (path-to label tree))\n\t\t)\n\t)\n)","problem":130,"user":"507eddf4e4b06ce648bcdbfa"},{"problem":130,"code":"(fn reparent [e t]\n  (->> t\n       (tree-seq next rest)\n       (filter #(some #{e} (flatten %)))\n       (reduce (fn [a b] \n                 (concat b (list (remove #{b} a)))))))","user":"5353afa0e4b084c2834f4b03"},{"code":"(fn [n t]\n  (letfn [(to-triplets [[t & ch]]\n            (when t\n              (apply concat (map-indexed (fn [i [h & _]] [t i h]) ch)\n                     (map to-triplets ch))))\n\n          (from-triplets [t ts]\n            (let [by-top (group-by first ts)]\n              (when t (apply list t\n                             (->> (by-top t)\n                                  (sort-by second)\n                                  (map last)\n                                  (map #(from-triplets % ts))\n                                  (keep identity))))))\n\n          (path-to-top [s tri]\n            (let [nxt (->> tri\n                           (filter #(= s (last %)))\n                           first)]\n              (when nxt (cons nxt (path-to-top (first nxt) tri)))))]\n\n    (let [tri (to-triplets t)\n          path (path-to-top n tri)\n          rev-path (map (fn [[p i c]] [c 9 p]) path)\n          new-tri (concat rev-path (remove (set path) tri))]\n      (from-triplets n new-tri))))","problem":130,"user":"51b9d1f0e4b0e871ca49590b"},{"code":"(fn f [a x [p & c :as t]]\n  (if (= p x)\n    (concat t a)\n    (or\n      (some\n        #(if ((set %) x) %)\n        (map\n          #(f [(concat (remove #{%} t) a)] x %)\n          c))\n      t)))\n[]","problem":130,"user":"4db85bdd535d1e037afb218d"},{"problem":130,"code":"(fn reparent\n  ([new-root tree] (first (reparent new-root tree '())))\n  ([new-root tree parent]\n   (let [root     (first tree)\n         children (rest tree)\n         mktree   (fn [r parent children]\n                    (let [ch (concat children parent)]\n                      (list\n                       (if (empty? ch) (list r) (cons r ch)))))]\n     (cond (nil? root) nil\n           (= new-root root) (mktree new-root parent children)\n           :else (mapcat (fn [el]\n                           (let [r (first el)]\n                             (reparent new-root\n                                       el\n                                       (mktree root\n                                               parent\n                                               (remove #(= % el)\n                                                       children)))))\n                         children)))))","user":"5591cc56e4b0604b3f94d582"},{"problem":130,"code":"(fn [ele tree]\n  (letfn [(find-b [b x p]\n            (if (seq? x)\n              (if (= (first x) b) [x p] (first (remove empty? (map #(find-b b % (conj p (first x))) (rest x)))))))\n          (build [t path res]\n            (if (seq path)\n              (let [[nxt _] (find-b (first path) t [])\n                    without (remove #(= nxt %) t)]\n                (build nxt (rest path) (list (concat without res))))\n              (concat t res)))]\n    (let [[_ path] (find-b ele tree [])]\n      (if (seq path)\n        (build tree (concat (rest path) [ele]) '())\n        tree))))","user":"529dfc6de4b04e0c58e87b8a"},{"problem":130,"code":"(fn [r T]\n  (->> (tree-seq coll? rest T)\n       (filter (fn [t] (some (partial = r) (flatten t))))\n       (reduce (fn [R t] (concat t (list (remove (partial = t) R)))))))","user":"55f6fe09e4b06e875b46cea2"},{"code":"(fn [node tree]\n  (let [find-node (fn f [t p]\n                    (let [parent (first t)\n                          path (conj p parent)]\n                      (if (= parent node)\n                        (conj p node)\n                        (map #(f % path) (next t)))))\n        path-to-node (flatten (find-node tree []))\n        get-subtree (fn f [t n]\n                      (if (= n (first t))\n                        (vec t)\n                        (some #(f % n) (next t))))\n        node-tree (reduce get-subtree tree path-to-node)\n        parent-tree (reduce get-subtree tree (butlast path-to-node))\n        remove-subtree (fn f [st t]\n                         (when-not (= st t)\n                           (->> t\n                             (remove #{st})\n                             (map #(if (seq? %) (f st %) %)) vec)))\n        clean-tree (remove-subtree parent-tree tree)\n        clean-parent-tree (remove-subtree node-tree parent-tree)]\n    (reduce #(if % (conj %2 %) %2) [clean-tree clean-parent-tree node-tree])))","problem":130,"user":"5028cd0fe4b01614d1633ffc"},{"problem":130,"code":"(fn reparent [newRoot tree]\n  (letfn [(tName [tree]\n            (when (seq? tree)\n              (first tree)))\n          (match [root node] (= root (tName node)))\n          (inTree [name tree]\n            (cond\n              (= name (tName tree)) true\n              (seq? tree) (some #(inTree name %) (rest tree))\n              :else false))]\n    (if (= newRoot (tName tree)) \n      tree\n      \n      (let [root (tName tree)\n            left (second tree)                                                                                                      \n            lName (tName left)\n            right (nth tree 2 '())\n            rName (tName right)]\n        (cond\n          (inTree newRoot left) (reparent newRoot\n                                          (concat\n                                           left\n                                           (list (remove #(match lName %) tree))))\n          (inTree newRoot right) (reparent newRoot\n                                           (concat\n                                            right\n                                            (list (remove #(match rName %) tree))))\n          :else nil)))))","user":"54f64e99e4b0f2f3c5226ea4"},{"code":"(fn _ [l [x & y :as t]]\n    (if (= l x)\n      t\n      (if (seq y)\n        (let [[b & c] (filter\n                        #((set (flatten %)) l) y)]\n          (_ l (conj (vec b) (cons x (remove #{b} y)))))\n        )))","problem":130,"user":"4dc537fd535d8a4b2fd74282"},{"problem":130,"code":"(fn [newroot tree]\n  ((fn newroot? [tree parent]\n     (if (= newroot (first tree)) (concat tree parent)\n       (some (fn [child]\n               (newroot? child [(concat (remove #(= child %) tree) parent)]))\n             (rest tree))))\n   tree nil))","user":"553abb28e4b09218d5f44ffb"},{"code":"(fn reparent\n  [node tree]\n  (letfn\n    [(get-node\n      [coll]\n       (when (coll? coll) (first coll)))\n     (find-node\n      ([node tree]\n       (find-node [] node tree))\n      ([path node tree]\n       (let [n (get-node tree)\n             path (conj path n)]\n         (if (= n node) path\n           (mapcat #(find-node path node %) (rest tree))))))\n     (reparent-subtree\n      [tree node]\n      (let [sub (first (filter #(= node (get-node %)) tree))\n            rst (remove #(= node (get-node %)) tree)]\n        (concat sub (list rst))))]\n    (reduce reparent-subtree tree (rest (find-node node tree)))))","problem":130,"user":"5273e006e4b03e8d9a4a7495"},{"code":"(fn n130 [n tree]\n  (letfn [(is-child [c t] \n                    (if (= 1 (count t))\n                      false \n                      (or (some #(= % c) t) (some true? (map (partial is-child c) (rest t))))))\n          (take-out-tree [a b]\n                         (concat b (list (filter #(not= % b) a))))]\n    (let [ts (tree-seq #(and (next %) (not= (first %) n)) rest tree)\n          ct (first (drop-while #(not= (first %) n) ts))\n          cg (take-while #(is-child ct %) (take-while #(not= (first %) n) ts))\n          ]\n      (reduce take-out-tree (concat cg (list ct)))\n      )))","problem":130,"user":"52b43468e4b0c58976d9ad1b"},{"code":"(fn reparent [node tree]\n  (let\n    [path-to-node (fn path-to-node [tree]\n      (cond\n        (empty? tree) nil\n        (= node (first tree)) [tree]\n        :else (when-let\n                [path (first\n                         (filter (complement nil?)\n                           (map path-to-node (rest tree))))]\n                (cons tree path))))\n     reparent-pair (fn [tree1 tree2]\n      (concat tree2\n        [(remove #{tree2} tree1)]))]\n    (reduce\n      #(reparent-pair %1 %2)\n      (path-to-node tree))))","problem":130,"user":"4f725466e4b07046d9f4f030"},{"problem":130,"code":"(fn [e g]\n    (letfn [(map-tree [t]\n              (let [f (first t) r (rest t)]\n                (for [rr r]\n                  (cons [f (first rr)] (map-tree rr)))))\n\n\n            (rolldown [s]\n              (loop [[f1 f2] (first s) r s a []]\n                (if (empty? r) a\n                    (let [g (group-by (fn [[g1 g2]] (= f1 g1)) r)\n                          l (map second (get g true))\n                          gg (get g false)]\n                      (recur (first gg) gg (cons [f1 {:c (vec l)}] a))))))\n\n            (parent [g e]\n              (ffirst (filter #(= (second %) e) g)))\n\n            (reparent [e g]\n              (let [p (parent g e)]\n                (if (nil? p) g\n                    (remove #(= [p e] %) (conj (vec (reparent p g)) [e p] )))))\n\n            (redraw [e r]\n              (let [rr (get r e)]\n                (conj (for [ee (:c rr)] (redraw ee r)) e)))]\n      (->> g\n           map-tree\n           flatten\n           (partition 2)\n           (reparent e)\n           rolldown\n           (into {})\n           (redraw e))))","user":"4f3ec266e4b0e243712b1f8c"},{"problem":130,"code":"(letfn [                                                                                                                        \n    (collection-to-list [nodes root]                                                                                                                    \n        (let [children (nodes root)]                                                                                            \n            (if (empty? children)                                                                                                                       \n                [root]                                                                                                          \n                (into [root] (map #(collection-to-list nodes %) children)))))                                                                           \n    (list-to-collection [root]                                                                                                  \n        (let [[label & children] root]                                                                                                                  \n            (if (empty? children)                                                                                               \n                {label []}                                                                                                                              \n                (into {label (mapv first children)} (map #(list-to-collection %) children)))))                                  \n    (find-parent [nodes n] (ffirst (filter (fn [[label children]] (some (partial = n) children)) nodes)))                                               \n        ; make new-parent the parent of n                                                                                       \n    (reparent [nodes n new-parent]                                                                                                                      \n        (let [old-parent (find-parent nodes n)                                                                                  \n              n' {n (filterv (partial not= new-parent) (nodes n))}                                                                                      \n              new-parent' {new-parent (conj (nodes new-parent) n)}                                                              \n              nodes' (merge nodes n' new-parent')]                                                                                                      \n            (if old-parent                                                                                                      \n                (recur nodes' old-parent n)                                                                                                             \n                nodes')))                                                                                                       \n    (reroot [nodes n]                                                                                                                                   \n        (let [parent (find-parent nodes n)]                                                                                     \n            (if parent (reparent nodes (find-parent nodes n) n) nodes)))\n    (tree-reparent [node tree]                                                                                                  \n        (-> tree                                                                                                                                        \n            list-to-collection                                                                                                  \n            (reroot node)                                                                                                                               \n            (collection-to-list node)))]                                                                                                                \n        tree-reparent)\n\n; there has to be a better way than turning the tree into a collection of nodes\n; and manipulating that collection, right?","user":"558b50d5e4b027778923762b"},{"code":"(fn reparent [r t]\n  (letfn [(adjacency [t]\n            (concat (mapcat adjacency (rest t))\n                    (map (fn [x] #{(first t) x}) (map first (rest t)))))\n          (neighbors [v a excl]\n            (remove (clojure.set/union #{v} excl)\n                    (apply concat (filter #(% v) a))))\n          (build-tree [v a excl]\n            (list* v (map #(build-tree % a #{v}) (neighbors v a excl))))]\n    (build-tree r (adjacency t) #{})))","problem":130,"user":"4e8338d6535db62dc21a62d3"},{"code":"(fn repartree [nr t]\n  (let [[zip ze zxt zp zn] [clojure.zip/zipper clojure.zip/end? clojure.zip/next clojure.zip/path clojure.zip/node]\n        tz (zip next rest #(cons (first %1) %2) t)\n        nr (some #(if (= nr (first (zn %))) %) (take-while (complement ze) (iterate zxt tz)))]\n    (reduce #(concat %2 [(remove #{%2} %1)]) (conj (zp nr) (zn nr)))))","problem":130,"user":"4effb663535dcb61093f6a2e"},{"code":"(fn [node tree]\n  (let [f (fn f [node tree]            \n            (if (= node (first tree))\n              (list tree)\n              (if (empty? (next tree))\n                nil\n                (let [res (first(filter identity (map (partial f node) (next tree) )))]\n                  (if (empty? res)\n                    nil\n                    (cons tree res)\n                    )))))\n        g (fn g [l root]\n            (if (= 1 (count l))\n              root\n              (let [oldroot (last l)\n                    child (last (butlast l))\n                    child (remove (partial = oldroot) child)]\n                (concat root (list (g (butlast l) child) )))))\n        r (f node tree)]\n    (g r (last r)) ))","problem":130,"user":"5349ac2be4b084c2834f4a67"},{"problem":130,"code":"(partial \n (fn p [a x [r & S :as t]]\n   (if (= r x)\n     (concat t a)\n     (some #(when (= x (first %)) %)\n           (map #(p [(concat (remove {% 8} t) a)] x %)\n                S)))) \n [])","user":"559c13c5e4b066d22e731f61"},{"code":"(fn reparent\n  ([target tree]\n     (reparent target tree nil))\n\n  ([target tree parent]\n     (when (seq tree)\n       (let [node-val (first tree) children (rest tree)]\n         (if (= node-val target)\n           (concat [node-val] children (when parent [parent]))\n           (first (keep identity (map (fn [child]\n                                        (reparent target child\n                                                  (concat [node-val]\n                                                          (remove #(= child %) children)\n                                                          (when parent [parent]))))\n                                      children))))))))","problem":130,"user":"4f0d093b535d0136e6c22313"},{"code":"(fn f [n [x & xs :as t] & ps]\n  (if (= n x) (concat t ps)\n    (let [psf (fn [xp] (concat (remove #(= xp %) t) ps))]\n        (first (remove nil? (for [xp xs] (f n xp (psf xp))))))))","problem":130,"user":"504e04a4e4b078edc5f59397"},{"code":"(fn [node tree]\n  (let [step (fn r [path tree node]\n               (if (= (first tree) node)\n                  (cons tree path)\n                  (if (nil? (next tree))\n                    nil\n                    (first (filter #(not (nil? %)) (map #(r (cons tree path) % node) (next tree)))))))\n        tree-coll (reverse (step [] tree node))\n        step2 (fn [p c]\n          (let [n-c (filter #(not (= % c)) p)\n                n-p (concat c [n-c])]\n            n-p))]\n    (reduce step2 tree-coll)))","problem":130,"user":"52a55adee4b0c58976d9abe7"},{"code":"(fn tree-reparenting [node tree]\r\n  (letfn [(parent-and-subtree [node tree]\r\n            (if (empty? (rest tree)) nil\r\n                (if-let [subtree (some #(when (= (first %) node) %) (rest tree))]\r\n                  [(first tree) tree (rest subtree)]\r\n                  (first (keep #(parent-and-subtree node %) (rest tree))))))\r\n          (remove-subtree [node tree]\r\n            (remove #(and (coll? %) (= node (first %))) tree))]\r\n    (let [root (first tree)\r\n        [parent parent-tree node-children] (parent-and-subtree node tree)]\r\n      (if (nil? parent) tree\r\n          (if (= parent root)\r\n            (concat (list node) node-children (list (remove-subtree node parent-tree)))\r\n            (tree-reparenting node (tree-reparenting parent tree)))))))","problem":130,"user":"4e994541535dbda64a6f6b64"},{"code":"(fn reparent [node tree]\n  (let [branches (->> tree (tree-seq sequential? seq) (filter sequential?))\n        f (fn [f] (apply merge (f branches)))\n        children (f (partial map (fn [[h & r]] {h (seq (map first r))})))\n        parent (or (f (partial mapcat (fn [[h & r]] (map (fn [c] {c h}) (map first r))))) {})\n        under (fn un [node c] `(~node ~@(map #(un % c) (c node))))\n        repar (fn rep [node c p]\n                 (if-let [up (p node)]\n                   `(~@(under node c) ~(rep up (assoc c up (seq (remove #{node} (c up)))) p))\n                   (under node c)))]\n    (repar node children parent)))","problem":130,"user":"50645e12e4b007509339a58a"},{"problem":130,"code":"(fn reparen\n  [element tree]\n  (letfn [(pull\n            [tree index]\n            (let [[head & children] tree\n                  [first-children rest-children] (split-at index children)\n                  [[[child-head & child-children]] last-children] (split-at 1 rest-children)]\n              `(~child-head ~@child-children (~head ~@first-children ~@last-children))))\n          (finds\n            [[head & children] element]\n            (cond (= element head) '()\n                  :else (if-let [rec-find (some identity\n                                                (map-indexed (fn [index child]\n                                                               (if-let [rec-find (finds child element)]\n                                                                 (cons index rec-find)))\n                                                             children))]\n                          rec-find\n                          nil)))\n]\n      (reduce pull tree (finds tree element))))","user":"60460824e4b02d28681c77bc"},{"code":"(fn [name tree]\n  (let [\n  search-impl (fn search-impl [target path [name & children :as node]]\n    (let [next-path (cons node path)]\n      (if (= target name)\n        next-path\n        (some #(search-impl target next-path %) children))))\n  search (fn [target tree]\n    (search-impl target '() tree))\n  name-of (fn [[name & _ :as node]]\n    name)\n  remove-from (fn [[subject-name & children :as subject]\n                   [target-name & _ :as target]]\n    (if (nil? target)\n      subject\n      (let [children* (filter #(not (= target-name (name-of %))) children)]\n        (cons subject-name children*))))\n  append-to (fn [subject new-child]\n    (concat subject [new-child]))\n  transform-impl (fn transform-impl [former-child [node & ancestory]]\n    (let [node* (remove-from node former-child)]\n      (if (seq ancestory)\n        (append-to node* (transform-impl node ancestory))\n        node*)))\n  transform (fn [path]\n    (transform-impl nil path))\n  ]\n  (->> (search name tree)\n       transform)))","problem":130,"user":"4e691c79535d8ccf87e9fe97"},{"problem":130,"code":"(fn [sym tree] (let [w2 (fn w1 [s [n & l :as t]]\n                          (if (= n s) [t]\n                              (let [res (filter identity (map (partial w1 s) l))\n                                    b (seq res)\n                                    f (first res)\n                                    h (-> f first first)]\n                                (when b (cons (cons n (filter #(not= h (first %)) l)) f)))))]\n                 (reduce #(conj (vec %2) %) (w2 sym tree))))","user":"5c379636e4b0d62ef62d9f76"},{"problem":130,"code":"(fn f [n t]\n    (letfn [(parent [[r & s :as tree] n]\n              (or (if (some #(= n (first %)) s) tree\n                                                (some #(parent % n) s)\n                                                )))\n            (subtree [[r & s :as tree] n]\n              (cond\n                (not (seq tree)) nil\n                (= r n) tree\n                :esle (loop [x s]\n                        (if (not (seq x)) nil\n                                          (or (subtree (first x) n) (recur (rest x)))))\n                )\n              )\n            (removesub [[r & s :as tree] n]\n              (if (= r n) nil\n                          (cons r (for [x s :when (not= (first x) n)]\n                                    (removesub x n)\n                                    ))\n                          )\n              )]\n\n      (let [s (subtree t n) p (parent t n)]\n        (if (not (seq p)) s\n                          (conj (vec s) (f (first p) (removesub t n)))))\n      \n      ))","user":"5921a080e4b09b4ee5954c77"},{"code":"(fn [top tree]\n  ((fn iter [[_ & r] out]\n     (if (= top (first out))\n       out\n       (some #(iter % (concat % [(remove #{%} out)])) r)))\n   tree tree))","problem":130,"user":"4f8345c6e4b033992c121c1b"},{"code":"(fn ex \n  ([nr tree] \n     (let [[r & c-tree] tree\n            cs (for [c c-tree] (first c))\n            t-map (apply merge (flatten (conj [] {r [nil cs]} (for [c c-tree] (ex r (first c) (rest c)) )) ))\n            re-st (fn re-p [c t-map skip](if (contains? skip c) nil(let [node (t-map c) skip (assoc skip c 0)](filter #(not= '() %) (cons c  (concat (for [nc (second node) :when (not (contains? skip nc))] (re-p nc t-map skip) ) (if (not= nil (first node)) (filter #(not= nil %) [(re-p (first node) t-map skip)]) ) ) )))))\n\n          ]\n      ;; \n        (re-st nr t-map {})\n      ;;\n     ) \n  )\n\n  ([parent current children]\n   (if (empty? children) {current [parent '()]}\n    (let [cs (for [c children] (first c))]\n       (conj []  {current [parent cs]} (for [c children] (ex current (first c) (rest c)) ) )\n    )\n   )\n  )\n\n)","problem":130,"user":"522eba30e4b01cdb292c5f0e"},{"problem":130,"code":"(fn reparenting [node tree]\n  (letfn [(find-subtree [tree]\n                        (let [root (nth tree 0 nil)\n                              left (nth tree 1 nil)\n                              right (nth tree 2 nil)]\n                          (cond\n                            (nil? root) nil\n                            (= root node) tree\n                            :else (or (find-subtree left)\n                                      (find-subtree right)))))\n          (get-parent [[root left right]]\n                      (cond\n                        (or (nil? root) (= node (first left)) (= node (first right))) root\n                        :else (or (get-parent left) (get-parent right))))\n          (get-parent-tree [node [root & children]]\n                           (if (nil? root) \n                             nil\n                             (concat (list root) (for [child children :when (not= node (first child))] (get-parent-tree node child)))))]\n    (let [p (get-parent tree)\n          q (get-parent-tree node tree)\n          t (find-subtree tree)]\n      (if (nil? p) tree\n        (concat t (list (reparenting p q)) )))))","user":"5046f909e4b03b02161376b5"},{"problem":130,"code":"(fn puzzle [new-root tree]\n  (letfn [(paths [tree]\n                 (let [[root & branches] tree]\n                   (if (empty? branches) (list (list root))\n                     (mapcat (fn [branch] (map #(cons root %) (paths branch))) branches))))\n          (find-path [node tree]\n                     (let [[pre-path post-path] (split-with #(not= node %) (some #(if (some #{node} %) %) (paths tree)))]\n                       (conj (vec pre-path) (first post-path))))\n          (transform-1 [new-root tree]\n                       (let [[root & branches] tree\n                             new-sub-branches (remove #(= new-root (first %)) branches)\n                             [new-root & new-childs] (first (filter #(= new-root (first %)) branches))]\n                         (list* new-root (concat new-childs (list (list* root new-sub-branches))))))]\n    (let [path (find-path new-root tree)]\n      (loop [roots (rest path)\n             tree tree]\n        (if (empty? roots) tree\n          (recur (rest roots) (transform-1 (first roots) tree)))))))","user":"53286f84e4b09d4e7a9b5505"},{"problem":130,"code":"(fn [node tree]\n  (let [[root [head & tail :as path]]\n        ((fn search [path [parent & children :as root]]\n           (if (= node parent)\n             [root path]\n             (->> (map\n                    (fn [child head tail] (search (conj path [parent (into head tail)]) child))\n                    children\n                    (reductions conj [] children)\n                    (rest (iterate rest children)))\n               (some identity))))\n         [] tree)]\n    (if (empty? path)\n      root\n      (->> (reduce\n             #(cons (%2 0) (conj (%2 1) %))\n             (cons (head 0) (head 1))\n             tail)\n        vector\n        (concat root)))))","user":"50479524e4b0371827a27bc4"},{"code":"(fn [target [rot & cnodes]]\n\n    (let [expd (fn [nmap [k v]]\n                 (let [child (map first v)\n                       nwmap (loop [lmap nmap\n                                    [[lk & lvs] & lrest] v]\n                               (if (nil? lk) lmap\n                                   (recur (assoc lmap lk  lvs) lrest)))]\n                   (assoc nwmap k child)))\n\n          tomap (fn [k v]\n                  (loop [nmap {k v}]\n                    (let [n (first (filter (fn [[k v]] (some coll? v)) nmap))]\n                      (if (nil? n) nmap\n                          (recur (expd nmap n))))))\n\n          reparent (fn [tget root stm]\n\n                     (loop [mp stm\n                            point tget\n                            prev nil]\n\n                       (let [[[parent children] & _]\n                             (filter (fn [[k v]] (and (not= k prev)\n                                               (some #(= % point) v))) mp)\n                             s_one (assoc mp point (concat  (mp point) (list parent)))\n                             s_two (assoc s_one parent (remove #{point} children))]\n\n                         (if (= point root) mp\n                             (recur s_two parent point)))))\n          t (fn re [n stm]\n                (if (coll? (stm n))\n                  (concat `(~n)\n                    (map #(re % stm) (stm n)) )\n                  `(~n)))\n\n          ]\n      (->> ( tomap rot cnodes) (reparent target rot) (t target) )))","problem":130,"user":"5124619ae4b02c3f2a072ccd"},{"problem":130,"code":"(fn [rv tree]\n  (letfn [(deconstruct [[v & children :as node]]\n            (if (= v rv)\n              [true (list (vec node))]\n              (let [children* (map deconstruct children)]\n                (if-let [[_ parents] (first (filter first children*))]\n                  [true (conj parents (into [v] (map second (remove first children*))))]\n              \t  [false (vec node)]))))]\n    (reduce #(conj %2 %1) (get (deconstruct tree) 1))))","user":"5339c105e4b0e30313ee6cae"},{"problem":130,"code":"(fn solve [e s]\n  (letfn [(reparent [s p]\n          (cons (first (nth s p)) (concat (rest (nth s p)) (list (concat (take p s) (drop (inc p) s))))))\n          (turn [s]\n          (reparent s (first (filter #(contains? (set (flatten (nth s %))) e) (iterate inc 1)))))]\n  (first (filter #(= (first %) e) (iterate turn s)))))","user":"55625903e4b0c656e3ff17d7"},{"problem":130,"code":"(fn prob130\n  [node tree]\n  (letfn [(find-node\n            [tree node]\n            ;; return node (tree)\n            ;; (a (b (c (d) (e)) (f (g) (h))) (i (j (k) (l)) (m (n) (o))), c\n            ;; (c (d) (e))\n            (loop [head (first tree)\n                   children (rest tree)]\n              (if (= head node)\n                tree\n                (mapcat #(find-node % node) children))))\n          \n          (add-child\n            [tree node]\n            ;; add node(tree) as the right branch of tree\n            ;; (add-child '(c (d) (e))  '(b (f (g) (h)) (a (i (j (k) (l)) (m (n) (o))))))\n            ;; (c (d) (e) (b (f (g) (h)) (a (i (j (k) (l)) (m (n) (o))))))\n            (concat tree (list node)))\n          \n          (find-parent\n            [tree node]\n            ;; return node's parent (tree)\n            ;; (a (b (c (d) (e)) (f (g) (h))) (i (j (k) (l)) (m (n) (o))), c\n            (loop [head (first tree)\n                   children (rest tree)]\n              ;; has child with node\n              (if (some #(= node %) (map first children))\n                tree\n                (mapcat #(find-parent % node) children))))\n          \n          \n          (remove-sub-tree\n            [tree node]\n            ;; return tree without sub-tree removed\n            (loop [head (first tree)\n                   children (rest tree)]\n              (apply list head (filter #(not= node %) children))))\n          \n          \n          (push-parent-down-right\n            [tree node]\n            ;; (b \n            ;;   (c (d) (e)) \n            ;;   (f (g) (h))))\n            (let [\n                  ;; find node tree\n                  ;;   (c (d) (e)) \n                  node-tree (find-node tree node)\n                  \n                  ;; find parent of node\n                  ;; (b \n                  parent-tree (find-parent tree node)\n                  \n                  ;; remove the sub-tree node from the parent\n                  ;; (b \n                  ;;   (f (g) (h))))\n                  parent-tree' (remove-sub-tree parent-tree node-tree)\n                  \n                  ;; find the parent of parent\n                  parent-parent-tree (find-parent tree (first parent-tree))\n                  \n                  ;; remove parent tree from parent of parent\n                  parent-parent-tree' (remove-sub-tree parent-parent-tree parent-tree)]\n              ;; (println node-tree)\n              ;; (println parent-tree)\n              ;; (println parent-tree')\n              ;; (println parent-parent-tree)\n              (println parent-parent-tree')\n              \n              (if (nil? (first parent-tree'))\n                node-tree\n                ;; push parent down and to the right (make it additional right child branch\n                ;; (c \n                ;;    (d) (e)\n                ;;           (b \n                ;;              (f (g) q(h)))\n                ;; \n                (add-child node-tree \n                           (if (seq parent-parent-tree)\n                             (add-child parent-tree' parent-parent-tree')   ;; make the parent's parent a child of parent\n                             parent-tree')\n                           ))))]\n    (push-parent-down-right tree node)))","user":"4ebbff41535dfed6da9c6d78"},{"code":"(fn tree-reparent [new-root tree]\n    (letfn [(separate-each-from-others [elements]\n              (loop [res []\n                     prevs []\n                     todo elements]\n                (if (empty? todo)\n                  res\n                  (recur\n                    (conj res [(first todo) (concat prevs (rest todo))])\n                    (conj prevs (first todo))\n                    (rest todo)))))\n            (reparent [new-root-node tree childable-parent]\n              (if (nil? tree)\n                nil\n                (let [node (first tree)\n                      children (drop 1 tree)]\n                  (if (= node new-root-node)\n                    (filter\n                      #(not (nil? %))\n                      (concat (list node) children (list childable-parent)))\n                    (some\n                      (fn [[child other-children]]\n                        (reparent\n                          new-root-node\n                          child\n                          (filter #(not (nil? %))\n                            (concat (list node) other-children (list childable-parent)))))\n                      (separate-each-from-others children))))))]\n      (reparent new-root tree nil) )\n    )","problem":130,"user":"5165a235e4b079ad97ec44ac"},{"problem":130,"code":"(letfn [(is-named? [t x]\n          (= x (first t)))\n\n        (add-child [t child]\n          (concat t [child]))\n\n        (remove-child [t x]\n          (concat (take 1 t) (filter (complement #(is-named? % x)) (rest t))))\n\n        (get-child [t x]\n          (first (filter #(is-named? % x) (rest t))))\n\n        (get-children [t]\n          (rest t))\n\n        (path-to [t x]\n          (loop [stack [[t []]]]\n            (when (seq stack)\n              (let [[current path] (peek stack)\n                    stack (pop stack)\n                    path (conj path (first current))]\n                (if (= x (last path))\n                  path\n                  (recur (->> current\n                              get-children\n                              (map (fn [child] [child path]))\n                              (into stack))))))))\n\n        (make-child-parent [t x]\n          (when-let [new-parent (get-child t x)]\n            (let [old-parent (remove-child t x)\n                  new-parent (add-child new-parent old-parent)]\n              new-parent)))\n\n        (reparent* [t x path]\n          (if-not (seq path)\n            t\n            (recur (make-child-parent t (first path))\n                   x\n                   (rest path))))\n\n        (reparent [x t]\n          (let [path (path-to t x)\n                ;; reparent* expects the path to start with the first child, not the\n                ;; root of the tree, so we drop the first element of the path.\n                path (rest path)]\n            (reparent* t x path)))]\n  reparent)","user":"51f01925e4b0249c592fbdfc"},{"problem":130,"code":";(fn repar [node [f & r :as tr]] \n;  (if (= f node) tr\n;      (let [sub-tr (some #(and (get (set (flatten %)) node) %) r)\n;            rst (filter (partial not= sub-tr) tr)]\n;          (repar node (concat sub-tr (list rst))))))\n\n(fn [n [f :as t]] \n  (if (= f n) t\n      (recur n (#(concat % (list (filter (partial not= %) t))) \n                      (first (filter #(get (set (flatten %)) n) t))))))","user":"575ddfd1e4b02ea11479938d"},{"problem":130,"code":"(fn [x t]\n  (let [srch (fn srch [x t]\n               (when (coll? t)\n                 (if (= x (first t))\n                   (list)\n                   (loop [ys (rest t)]\n                     (when (seq ys)\n                       (let [y (first ys)\n                             z (srch x y)]\n                         (if z\n                           (cons y z)\n                           (recur (rest ys)))))))))\n        step (fn [x t]\n               (let [r (filter #(not= % x) t)]\n                 (cons (first x) (concat (rest x) (list r)))))]\n    (loop [rl t\n           ys (srch x t)]\n      (if (seq ys)\n        (recur (step (first ys) rl) (rest ys))\n        rl))))","user":"5799ff45e4b05b1deef9add1"},{"code":"(fn bah [target tree]\n  (letfn [(to-map-step [parent [key & children] m]\n            (let [node [key {:parents (if parent [parent] [])\n                             :children (map first children)}]]\n              (if (seq children)\n                  (apply merge (conj m node) (map #(to-map-step key % m) children))\n                  (conj m node))))\n          (swap-positions [target graph]\n            (if (empty? ((graph target) :parents)) \n                graph\n                (let [parent-node (first ((graph target) :parents))\n                      modified-parent (assoc (graph parent-node)\n                                             :parents (cons target ((graph parent-node) :parents))\n                                             :children (remove #{target} ((graph parent-node) :children)))\n                      modified-target (assoc (graph target)\n                                             :parents []\n                                             :children (conj (into [] ((graph target) :children)) parent-node))]\n                  (assoc graph parent-node modified-parent target modified-target))))\n          (pull-down [graph]\n            (if-let [multiparent (first (filter #(> (count ((second %) :parents)) 1) graph))]\n              (let [push-node-key (second (:parents (second multiparent)))\n                    push-node (graph push-node-key)\n                    modified-multiparent \n                      (assoc (graph (first multiparent))\n                             :parents [(first ((graph (first multiparent)) :parents))]\n                             :children (conj (into [] ((graph (first multiparent)) :children)) \n                                             push-node-key))\n                    modified-push-node\n                      (assoc push-node\n                             :parents [(first multiparent)]\n                             :children (remove #{(first multiparent)} (push-node :children)))]\n                (assoc graph (first multiparent) modified-multiparent push-node-key modified-push-node))\n              graph))\n          (to-list [m]\n            (letfn [(convert-node [key]\n                      (let [{children :children} (m key)]\n                        (if (seq children)\n                            (cons key (map #(convert-node %) children))\n                            [key])))]\n              (convert-node (ffirst (filter #(empty? ((second %) :parents)) m)))))]\n    (->> (to-map-step nil tree {}) \n         (swap-positions target)\n         (pull-down)\n         (to-list))))","problem":130,"user":"52463059e4b09dbe66b56198"},{"code":"(fn [s t]\r\n  (letfn [(tree [t ls] (cons t ls))\r\n  \t\t\t\t(value [t] (first t))\r\n\t\t\t\t\t(leaves [t] (rest t))\r\n\t\t\t\t\t(add-leave [t & l] (concat t l))\r\n\t\t\t\t\t(remove-leave [t s] (tree (value t) (remove #(= s (value %)) (leaves t))))\r\n\t\t\t\t\t(get-leave [[l & ls] s] (cond (= s (value l)) l (empty? ls) nil :else (get-leave ls s)))\r\n\t\t\t\t\t(pull-leave [t s] (add-leave (get-leave (leaves t) s) (remove-leave t s)))\r\n\t\t\t\t\t(find-path [[v & ls] s res]\r\n\t\t\t\t\t  (cond \r\n\t\t\t\t\t    (= s v) res\r\n\t\t\t\t\t    (= 0 (count ls)) nil\r\n\t\t\t\t\t    :else (first (remove nil? (map #(find-path % s (conj res (first %))) ls)))))]\r\n         (reduce pull-leave t (find-path t s []))))","problem":130,"user":"4e6e10d8535d5021c1a895fd"},{"problem":130,"code":"(fn [n t]\n  (letfn [(fp [n t]\n                (if (= n (first t))\n                  [t]\n                  (let [r (filter #(not (nil? %)) (mapcat #(fp n %) (rest t)))]\n                    (if (empty? r) [] (conj r t))\n                    )))\n\n          (rb [a b]\n                (concat [(first b)] (rest b) (filter #(not (empty? %)) [(remove #(= b %) a)]) ))\n          ]\n  (let [p (fp n t)]\n    (reduce rb [] p)\n    )\n  ))","user":"52593207e4b0cb4875a45cd3"},{"code":"(fn process [sym tree]\n  (letfn [(find-node [cur-node parents]\n            (let [[val & children :as node] cur-node]\n              (if (= val sym)\n                [node parents]\n                (some #(find-node % (cons node parents)) children))))\n          (reparent [[val & _ :as node] [[pval & pch] & rpar :as parents]]\n            (if (empty? parents) node\n                (conj (vec node)\n                      (reparent\n                       (cons pval (remove #(= (first %) val) pch))\n                       rpar))))]                 \n    (apply reparent (find-node tree ()))))","problem":130,"user":"5003ee7de4b0678c553fc446"},{"code":"(fn [new-root tree]\n  (let [remove-nth (fn [s n]\n                     (concat (take n s)\n                             (drop (inc n) s)))\n        f (fn f [new-root [root & children :as tree] new-child-tree]\n            (if (= new-root root)\n              (if new-child-tree\n                (concat tree [new-child-tree])\n                tree)\n              (first\n               (filter identity\n                       (for [i (range (count children))]\n                         (f new-root (nth children i)\n                            (if new-child-tree\n                              (concat (remove-nth tree (inc i)) [new-child-tree])\n                              (remove-nth tree (inc i)))))))))]\n    (f new-root tree nil)))","problem":130,"user":"500d8c49e4b07ccb9a7ddb00"},{"code":"(fn __ [node tree]\n  (let [strip (fn [xs] (filter #(not (and (seq? %) (empty? %))) xs))\n        rm (fn rm [tree]\n             (let [h (first tree)\n                   cs (rest tree)]\n               (if (or (nil? h) (= h node))\n                 '()\n                 (->> cs\n                      (map #(rm %))\n                      strip\n                      (cons h)\n                      strip))))\n        split (fn [tree]\n                (let [hlp (fn hlp [[h & ts :as tr] parent]\n                            (cond (nil? h) nil\n                                  (= node h) [tr parent]\n                                  :else (first (filter identity (map #(hlp % h) ts)))))]\n          \n                  (hlp tree nil)))\n        [sub parent] (split tree)\n        res (rm tree)\n        new (if (empty? res) '() (list  (__ parent res)))]\n    (concat sub new)))","problem":130,"user":"4ec0c7ba535dfed6da9c6da4"},{"code":"(letfn [\r\n  (remove-child [[to-remove & _] [node & children]]\r\n\t\t(cons node (filter (fn [[n & _]] (not= n to-remove)) children)))\r\n\t(flip [parent child]\r\n\t\t(concat child [(remove-child child parent)]))\r\n\t(find-path [new-root [root & children :as tree]]\r\n\t\t(if (= root new-root)\r\n\t\t\t[tree]\r\n\t\t\t(if-let [c (some identity (map (partial find-path new-root) children))]\r\n\t\t\t\t(cons tree c))))]\r\n\t\t\t\t\r\n\t(fn reparent [new-root tree]\r\n\t\t(let [path (find-path new-root tree)]\r\n\t\t\t(if (= 1 (count path))\r\n\t\t\t\t(first path)\r\n\t\t\t\t(reduce flip path)))))","problem":130,"user":"4dd6d6a0535d2dad7130b5ca"},{"code":"(fn tr[r t]\n  (letfn [\n\t\t\t(find-subtree[r t] \n\t\t\t\t(if (= r (first t))\n\t\t\t\t\tt\n\t\t\t\t\t(some #(find-subtree r %) (rest t))))\n\t\t\t(rem-subtree[r t]\n\t\t\t\t; (prn :r r :t t)\n        (if (= r (first t))\n          nil\n          (if (not-empty t)\n            (cons (first t) (map #(rem-subtree r %) (remove #(= r (first %)) (rest t)))))))\n      (find-parent-of[p r t]\n        (let [f (first t)]\n          (if (= r f)\n            p\n            (some #(find-parent-of f r %) (rest t)))))]\n\t\t(let [alfa (find-subtree r t)\n          no-alfa (rem-subtree r t)\n          pr (find-parent-of 'x r t)\n          beta (if pr (find-subtree pr no-alfa))\n          no-beta (if beta (rem-subtree (first beta) no-alfa))\n          res (if no-beta (concat beta (list no-beta)) beta)\n          res (if res (concat alfa (list res)) alfa)]\n      ;(prn :alfa alfa :pr pr :beta beta :no-beta no-beta :res res)\n      res)))","problem":130,"user":"4f1fd734535d64f6031464a5"},{"code":"(fn reparent [node tree]                                                                           \n (letfn [(findparent [node [head & rest]]                                                                \n            (if (seq rest)                                                                                    \n              (if (some #(= node %) (map first rest))                                                         \n                head                                                                                          \n                (first (filter symbol? (keep #(findparent node %) rest))))))\n          (parent-tree [node tree]                                                                    \n            (let [parent (findparent node tree)]                                                               \n              (if (= parent (first tree))                                                                      \n                 nil                                                                                            \n                  (cons parent (parent-tree parent tree)))))                                                                                                \n          (hoist [node [head & rest]]                                                                     \n            (let [[nhead] (filter #(= node (first %)) rest)                                                    \n                   nrest (filter #(not= node (first %)) rest)]                                                  \n               (concat nhead (list (cons head nrest)))))]                                                                                                     \n  (if (= node (first tree))                                                                          \n    tree                                                                                             \n    (let [parents (parent-tree node tree)]                                                           \n     (reduce #(hoist %2 %1) tree (conj (apply vector parents) node))                                 \n     ))                                                                                              \n  ))","problem":130,"user":"4f1d1299535d64f603146487"},{"problem":130,"code":"(fn reparent [root tree]\n  (let [nodes-verbose (->>\n                        tree\n                        (tree-seq coll? rest))\n        node->children (->>\n                         nodes-verbose\n                         (map (fn [node]\n                                [(first node)\n                                 (->> \n                                   node\n                                   rest\n                                   (map first))]))\n                         (into {}))\n        node->parent (into {} (for [parent nodes-verbose\n                                    node (->>\n                                           parent\n                                           rest\n                                           (map first))]\n                                [node [(first parent)]]))\n        node->children+parent (into {} (->>\n                                         node->children\n                                         (map (fn [node]\n                                                [(first node)\n                                                 (concat (second node) \n                                                         (node->parent \n                                                           (first node)))]))))\n        rebuild (fn rebuild [parent node]\n                  (->>\n                    node\n                    node->children+parent\n                    (remove (partial = parent))\n                    (map (partial rebuild node))\n                    (cons node)))]\n    (rebuild nil root)))","user":"53c38b8ce4b00fb29b22127b"},{"problem":130,"code":"(fn reparent [n [h & t :as tree]]\n   (if (seq? t)\n     (let [other-branches (concat (list h) (remove #(some #{n} (flatten %)) t))\n           good-branch (first (filter #(some #{n} (flatten %)) tree))\n           f (fn f [n [h & t  :as tree] nv]\n               (if\n                (= n h)\n                 (concat tree (list nv))\n                 (concat (map #(if (some #{n} (flatten %))\n                                 (f n % nv)\n                                 %) tree))))\n           res (reparent n good-branch)]\n       (if (nil? (first res))\n         other-branches\n         (f (first good-branch) res other-branches)))\n     (list h)))","user":"608ec5e4e4b03bd49d9f36c0"},{"code":"(fn lift [X T]\r\n  (let [child-with-X (fn child-with-X [tree]\r\n                       (let [[tree-val & children] tree\r\n                              scx (some child-with-X children)\r\n                             ];_ (println \"child with X in\" tree)]\r\n                          (if\r\n                            (= tree-val X) tree \r\n                            (first (for [c children\r\n                                         :when (child-with-X c)]\r\n                                         c)))))\r\n                            \r\n        children-without-X (fn [tree]\r\n                            (let [[tree-val & children] tree\r\n                                  ];_ (println \"children without X in\" tree)]\r\n                              (if\r\n                                (= tree-val X) ()\r\n                                (remove child-with-X children))))\r\n        new-tree-from (fn [node-val children parent]\r\n                        (let [_ (println \"new tree-from node-val\" node-val)\r\n                              _ (println \"new tree-from children\" children)\r\n                              _ (println \"new tree-from parent\" parent)\r\n                              new-children (if parent\r\n                                             (concat children [parent])\r\n                                             children)\r\n                              _ (println \"new children\" new-children)\r\n                              new-tree (cons node-val new-children)\r\n                              _ (println \"new tree\" new-tree)]\r\n                           new-tree))\r\n        lift-from (fn lift-from [tree parent]\r\n                    (let\r\n                      [[tree-val & children] tree\r\n                       _ (println \"lift-from tree: \" tree)\r\n                       _ (println \"tree-val\" tree-val)\r\n                       _ (println \"children\" children)\r\n                       _ (println \"life-from parent: \" parent)\r\n                       C (child-with-X tree)\r\n                       _ (println \"lift-from C\" C)\r\n                       OC (children-without-X tree)\r\n                       _ (println \"lift-from OC\" OC)\r\n                       here? (= (first tree) X)\r\n                       _ (println \"here\" here?)]\r\n                       (if \r\n                          here?\r\n                              (new-tree-from tree-val children parent)\r\n                          (let \r\n                            [new-parent (new-tree-from tree-val OC parent)]\r\n                              (lift-from C new-parent)))))]\r\n       (lift-from T nil)))","problem":130,"user":"4f036fb3535dcb61093f6ac8"},{"code":"(fn tree-reparent [node tree]\n  (let [find-tree     (fn find-tree [node tree]\n                        (if (= node (first tree))\n                          tree\n                          (some #(find-tree node %) (rest tree))))\n        parent-tree   (fn parent-tree [node tree]\n                        (if (some #(= node (first %)) (rest tree))\n                          tree\n                          (some #(parent-tree node %) (rest tree))))\n        remove-child  (fn remove-child [node tree]\n                        (if (= node (first tree))\n                          nil\n                          (cons (first tree) (keep #(remove-child node %) (rest tree)))))\n        \n        \n        newroot (find-tree node tree)\n        parent  (parent-tree node tree)\n        remtree (remove-child node tree)\n        ]\n    (if (nil? node)\n      nil\n      (concat newroot (filter #(not (nil? %)) (list (tree-reparent (first parent) remtree)))))))","problem":130,"user":"510cd1dde4b078ea71921124"},{"problem":130,"code":"(fn f [nr [r & _ :as s]]\n  (or ({nr s} r)\n      ((fn g [i cr b] (let [t (fn [a b] `(~@b ~a)) m (rseq i)]\n        (or (#({cr %} b) (lazy-seq `(~nr ~@(reduce #(t %1 %2) m))))\n            (some #({cr (g `[~@i ~(remove #{cr} b)] b s)} %) b)\n            (some #(g i cr %) (filter seq? b))))) [] nr s)))","user":"548b7db8e4b0e286459a11fd"},{"code":"(fn rr\n  ([r t] (rr r t t))\n  ([r t a]\n     (letfn [(s [p c] (concat c (list (remove #{c} p))))]\n       (if (= r (first t)) a\n           (mapcat #(rr r % (s a %)) (rest t))))))","problem":130,"user":"4ff304f4e4b0678c553fc343"},{"code":"(fn f [n [h & c :as t] & p]\n  (cond\n    (= n h) (concat t p)\n    (seq c) (some identity\n                  (for [i (range (count c))]\n                    (let [[b [c & a]] (split-at i c)]\n                      (f n c (concat [h] b a p)))))))","problem":130,"user":"52b453b0e4b0c58976d9ad21"},{"code":"(fn reconnect [node tree]\n  (let [parse (fn parse [node parent children]\n                (merge {node [parent (map first children)]}\n                  (apply merge (map #(parse (first %) node (rest %)) children)))\n              )\n        cache (parse (first tree) nil (rest tree))\n        connect (fn connect [root cache]\n                  (let [children-and-parent (->> (cond (nil? (first (cache root))) (second (cache root))\n                                                   :else (flatten [(second (cache root)) (first (cache root))]))\n                                              (filter #(contains? cache %)))\n                        new-cache (dissoc cache root)]\n                    (cons root (map #(connect % new-cache) children-and-parent))\n                  )\n                )\n        new-tree (connect node cache)]\n    new-tree\n  )\n)","problem":130,"user":"5272d4b7e4b03e8d9a4a7453"},{"code":"(letfn [(children-names [node]\n          (into #{} (map first (rest node))))\n        (children [node]\n          (rest node))\n        (parent [node child-name]\n          (cond\n            (empty? node) nil\n            ((children-names node) child-name) node\n            :else (reduce #(if-not %1\n                             (parent %2 child-name)\n                             %1)\n                          nil (children node))))\n        (remove-child [node child-name]\n          (cons (first node)\n                (filter #(not= (first %) child-name)\n                        (children node))))\n        (add-as-child [parent-node child-node]\n          (concat parent-node [child-node]))\n        (get-node [root node-name]\n          (cond\n            (empty? root) nil\n            (= (first root) node-name) root\n            :else (reduce #(if-not %1\n                             (get-node %2 node-name)\n                             %1)\n                          nil (children root))))]\n  (fn extract [new-root-name old-root]\n    (if (= (first old-root) new-root-name)\n      old-root\n      (concat (get-node old-root new-root-name)\n            [(remove-child (extract (first (parent old-root new-root-name)) old-root)\n                           new-root-name)]))))","problem":130,"user":"4f1bb9d8535d64f60314647d"},{"code":"(fn [n t] (letfn [(scan [p tree col]\n                            (loop [l nil tr tree c col]\n                              (do\n                              (if (empty? tr)\n                                (do\n                                  c\n                                )\n                                (if (sequential? (first tr))\n                                  (do\n                                    (recur l (rest tr) (scan l (first tr) c))\n                                  )\n                                  (do\n                                    (recur (first tr) (rest tr) (conj c {(first tr) {:p p :c (map first (rest tr))}}))))))))\n                          (const [n stats rv] (let [st (stats n) ptr (if-not (or (nil? (st :p)) (= (st :p) rv)) (const (st :p) stats n) nil)\n                                                 kids (for [kds (filter #(not= % rv) (st :c))]\n                                                        (const kds stats n))] (concat [n] (if (nil? ptr) kids (concat kids [ptr])))))]\n                    (const n (into {} (scan nil t [])) nil)))","problem":130,"user":"52c1bd29e4b07a9af579236a"},{"problem":130,"code":"(fn search [n [c & cs] & r]\n  (if (= n c)\n    (cons c (concat cs r))\n    (let [recur #(search n % (cons c (concat (remove (partial = %) cs) r)))]\n      (some identity (map recur cs)))))","user":"5bbf0a02e4b07a9b28b0ffcf"},{"code":"(fn f [ancestors n [curr & children]]\n  (cond\n   (= curr n) (concat [curr] children (if-not (empty? ancestors)\n                                        (list (reduce #(conj (vec %) %2) (reverse ancestors)))\n                                        '()))\n   (empty? children) nil\n   :else (first\n          (drop-while nil?\n                      (map (fn [child]\n                             (f (conj ancestors (list* curr (remove #(= % child) children))) n child))\n                           children)))))\n[]","problem":130,"user":"4ebaf790535dfed6da9c6d6e"},{"problem":130,"code":"(fn sol [x tree]\n  (letfn[\n      (repar [lv x tree]\n   (let [t1 (first tree)]\n      (cond (= x t1) [true lv tree]\n            :else\n            (loop [tp [t1] ts (rest tree) lev lv ok false rep []]\n                     (cond (and (empty? ts) ok)\n                            (if (> lev 1); \n                              [true lev (concat (drop-last rep)\n                                       (list (concat (conj (vec (last rep)) (concat  tp ))))\n                                                      )  ]\n                              [true lev (concat (conj (vec rep) (concat  tp )))]\n                            )\n                        (empty? ts)\n                              [false lev ()]\n                        ok\n                           (recur (conj tp (first ts)) (rest ts) lev ok rep )\n                        (first (repar lev x (first ts)))\n                               (let [rep1 (repar lev x (first ts))]\n                                 (recur tp (rest ts) (inc (second rep1)) true (second (rest rep1)) )\n                                 )\n                        :else\n                           (recur (conj tp (first ts)) (rest ts) lev ok rep)\n                  )\n           )\n      )\n  )\n)\n   \n         \n         ]\n   (second (rest (repar 0 x tree)))\n  )\n  )","user":"59ff9424e4b01bb0ae8afd24"},{"code":"(fn lift [label tree] (letfn [(get-label [x] \n                                         (when (sequential? x) (first x))) \n                              (path-to ([label tree] (path-to [] label tree)) \n                                       ([path label tree] (let [lbl (get-label tree) \n                                                                path (conj path lbl)] \n                                                            (if (= label lbl) \n                                                              path \n                                                              (mapcat (partial path-to path label) \n                                                                      (rest tree))))) )\n                              (lift-local [tree label] (let [match  #(= label (get-label %))\n                                                             subtree     (first (filter match tree)) \n                                                             but-subtree (remove match tree)] \n                                                         (concat subtree (list but-subtree)))) ]\n                        (reduce lift-local tree (rest (path-to label tree))) ) )","problem":130,"user":"5307e4ece4b02e82168697a9"},{"code":"(fn uproot [newroot tree] \n  (letfn [(get-child [x] (when (sequential? x) (first x)))\n          (path-to\n            ([child tree] (path-to [] child tree))\n            ([path child tree]\n              (let [c (get-child tree) \n                    path (conj path c)]\n                (if (= child c)\n                  path\n                  (mapcat (partial path-to path child)\n                          (rest tree))))))\n          (lift [tree child]\n                      (let [match      #(= child (get-child %))\n                            subtree     (first (filter match tree))\n                            but-subtree (remove match tree)]\n                        (concat subtree (list but-subtree))))] \n    (reduce lift\n          tree\n          (rest (path-to newroot tree)))))","problem":130,"user":"50e4f4e9e4b049a987753896"},{"problem":130,"code":"(fn reparent-tree [n t]\n  (letfn [(tree-graph [[r & c] parent]\n            (apply merge {r (into (mapv first c) (when parent [parent]))} \n                   (map #(tree-graph % r) c)))\n          (traverse [g seen n]\n            (let [seen (conj seen n) children (remove seen (g n))]\n              (apply list n (map (partial traverse g seen) children))))]\n    (traverse (tree-graph t nil) #{} n)))","user":"575b3e9be4b02ea11479935b"},{"problem":130,"code":"(fn reparent\n ([root tree]\n  (if (= (first tree) root)\n   tree\n   (reparent root tree '())))\n ([root tree past]\n  (if (= (first tree) root)\n   (concat tree [past])\n   (some identity\n    (for [i (range 1 (count tree))]\n     (reparent\n      root\n      (nth tree i)\n      (if (empty? past)\n       (concat (take i tree) (drop (inc i) tree))\n       (concat (take i tree) (drop (inc i) tree) [past]))))))))","user":"5b61aa6ae4b0c6492753e712"},{"problem":130,"code":"(fn reparent\n  ([nd tr] (reparent nd tr []))\n  ([nd t1 t2]\n            (if (= (first t1) nd)\n              (if (empty? t2) t1 (conj (vec t1) t2))\n              (loop [c (rest t1)]\n                (if (empty? c)\n                  nil\n                  (let [t (first c)\n                        c1 (for [e t1 :when(not= e t)] e)\n                        r (reparent nd t (if (empty? t2) c1 (conj (vec c1) t2)))]\n                    (if (nil? r)\n                      (recur (rest c))\n                      r)))))))","user":"545537c1e4b0e397800069dd"},{"problem":130,"code":"(fn [node tree]\n  (letfn [(parent []\n            (letfn [(p [[head & children]]\n                      (when head\n                        (if (some (partial = node)\n                                  (map first children))\n                          (cons head nil)\n                          (mapcat p children))))]\n              (first (p tree))))\n          (detach-subtree [node tree]\n            (letfn [(detach [[head & nodes]]\n                      (when (and head\n                                 (not= head node))\n                        (->> nodes\n                             (map detach)\n                             (filter (complement nil?))\n                             (cons head))))\n                    (subtree []\n                      (first\n                        (drop-while\n                          (comp (partial not= node) first)\n                          (tree-seq seq? rest tree))))]\n              [(detach tree)\n               (subtree)])) ]\n    (let [p (parent)]\n      (if-not p\n        (list node)\n        (let [[a b] (detach-subtree p tree)\n              [b c] (detach-subtree node b)\n              b (if a (concat b [a]) b)]\n          (concat c [b])))\n      )))","user":"57f0f7b8e4b0bfb2137f5bfe"},{"problem":130,"code":"(fn f\n  ([x t] (f x t nil))\n  ([x [a & cs :as t] p]\n    (if (= x a)\n      (concat t p)\n      (when (seq cs)\n        (loop [l []\n               c (first cs)\n               r (rest cs)]\n          (if-let [s (f x c (list (cons a (concat l r p))))]\n            s\n            (when (seq r)\n              (recur (conj l c) (first r) (rest r)))))))))","user":"54ca9ca8e4b057c6fda3a265"},{"code":"(fn [e [h & r :as y]]\n  (let [has? #((set (flatten %)) e)]\n    (if (= h e) y (recur e `(~@(first (filter has? r)) (~h ~@(remove has? r)))))))","problem":130,"user":"528e64b7e4b0239c8a67aedd"},{"problem":130,"code":"(fn func [target graph]\n\t(let [remove-node \t(fn remove-node [graph target]\n\t\t\t\t\t\t\t(cons (first graph) (remove #(= target (first %)) (map #(remove-node % target) (next graph)))))\n\t\t\tselect-node (fn select-node [graph target]\n\t\t\t\t\t\t\t(cond (= target (first graph)) graph\n\t\t\t\t\t\t\t      :else (some #(select-node % target) (next graph))))\n\t\t\tget-parent\t(fn get-parent [graph target]\n\t\t\t\t\t\t\t(cond (= 1 (count graph)) nil \n\t\t\t\t\t\t\t\t  (some #(= target (first %)) (next graph)) (first graph)\n\t\t\t\t\t\t\t\t  :else (some #(get-parent % target) (next graph))))\n\t\t  new-root \t\t(select-node graph target)\n\t\t  parent \t\t(get-parent graph target)]\n\t\t(if (nil? parent) new-root\n\t\t\t\t(concat new-root (list (func  parent (remove-node graph target)))))))","user":"577c3da9e4b0c8d87281f6b9"},{"problem":130,"code":"(fn tree-reparenting [node tree]  \n   (let [get-parent-children-new-root\n           (fn [n t]\n             (loop [previous-parent nil\n                    rem-tree t]\n               (cond\n                 (= n (first rem-tree)) (list previous-parent (rest rem-tree))\n                 (some #(= n %) (flatten (second rem-tree))) (recur (first rem-tree) (second rem-tree))\n                 :else (recur previous-parent (conj (rest (rest rem-tree)) (first rem-tree))))))\n         get-parent-n (fn [n t]\n                               (first (get-parent-children-new-root n t)))\n         get-children-n (fn [n t]\n                               (second (get-parent-children-new-root n t)))\n\n  new-tree-unedited\n\n     (loop\n       [acc (list node)\n        current-node node\n        counter 0\n        used-nodes #{node nil}]\n       (if (or (= current-node nil)\n               (= counter 3))\n         acc\n         (recur (remove #(= % (list nil))\n                        (concat acc\n                        (filter #(= (set (list)) (clojure.set/intersection used-nodes (set (flatten %))))\n                                (get-children-n current-node tree))\n                        (list (list (get-parent-n current-node tree)))\n                        ))\n                (get-parent-n current-node tree)\n                (inc counter)\n                (clojure.set/union used-nodes (set (flatten acc))))))]\n\n      (loop [acc new-tree-unedited\n             position (dec (count acc))\n             temp-counter 0]\n        (if (or (= 2 temp-counter)\n              (= (count acc)\n               (inc (count (remove #(= % (list nil)) (concat (get-children-n node tree) (list (list (get-parent-n node tree)))))))))\n          acc\n          (if (some #(= % (first (nth acc (dec position)))) \n                (conj (map first (get-children-n (first (nth acc position)) tree)) (get-parent-n (first (nth acc position)) tree)))\n            (let [intermediate-tree\n                   (concat (take (dec position) acc) (list (concat (nth acc (dec position)) (drop position acc))))]\n              (recur intermediate-tree (dec (count intermediate-tree)) (inc temp-counter)))\n            (recur acc (dec position) temp-counter)))\n)\n     \n\n     \n     ))","user":"58dcb8cde4b0a4d5acaab6a7"},{"code":"(fn [v tree]\n  (letfn [(tree-contains? [[k & children]]\n                          (or (= v k) (some tree-contains? children)))\n          (single-reparent [[k & children :as tree]]\n                           (if (= v k)\n                             tree\n                             (let [grouped-children (group-by tree-contains? children)\n                                   [chosen-one] (grouped-children true)\n                                   others (grouped-children nil)\n                                   trimmed-tree (concat [k] others)]\n                               (concat chosen-one [trimmed-tree]))))]\n    (let [next-tree (single-reparent tree)]\n      (if (= tree next-tree)\n        tree\n        (recur v next-tree)))))","problem":130,"user":"536ca4bde4b0fc7073fd6e49"},{"code":"(let [p #(and ((set (flatten %)) %2)\n                    %)\n\n      g (fn f [s [r & c :as t] a] \n            (if (= r s)\n              (if a\n                `(~@t ~a)\n                t)\n  \t \t  (let [v remove\n                [[x] y] ((juxt filter v) #(p % s) c)]\n            (f s x (into '() (v nil? `[~a ~@(reverse y) ~r]))))))]\n\n#(g % %2 nil))","problem":130,"user":"4e823ed7535db62dc21a62c7"},{"code":"(fn g [n tree]\n           (letfn [(parent [n l]\n                     (cond (some #{n} l) l\n                           (some coll? l) (some (partial parent n) (map (partial parent n) (filter coll? l)))\n                           :else nil))\n\n                   (remove-n [n l]\n                     (loop [l l\n                            acc '()]\n                       (if (empty? l)\n                         acc\n                         (recur (rest l)\n                                (cond (= (first l) n) acc\n                                      (coll? (first l)) (concat acc [(remove-n n (first l))])\n                                      :else (concat acc [(first l)]))))))]\n             \n             (let [pnode (parent n tree)]\n               (cond (= `(~n) tree) tree\n                     (= tree n) n\n                     (= tree pnode) (concat n [(remove-n n tree)])\n                     :else (concat pnode [(g (remove-n pnode (parent pnode tree))\n                                             (remove-n pnode tree))])))))","problem":130,"user":"50a5b7e9e4b0aa96157e2610"},{"problem":130,"code":"(letfn [(updatek [k] (update-in (apply vector k) [(- (count k) 1)] inc))\n      \n          (tomap [cll k re]\n            (loop [[f & xs] cll k k re re]\n            (cond\n                (not f) re\n                (coll? f) (let [ k2 (updatek k)\n                                 re2  (assoc re k2 f)]\n                                (recur xs k2 (tomap f (conj k2 0) re2)))\n                :else   (recur xs (updatek k) (assoc re (updatek k) f))\n             )))\n             \n             (getchildren [mymap mykey]\n               (if (empty? mykey) '()\n                 (loop [startkey (concat (butlast mykey) '(1)) re '()]\n                    (let [v (mymap startkey)]\n                      (cond\n                         (= startkey mykey) (recur (updatek startkey) re) \n                         v (recur (updatek startkey) (concat re (list v)))\n                         :else (list (concat re (getchildren mymap (butlast mykey))))))))) \n                   \n             ]\n    (fn [mykey cll]\n       (let [mymap (tomap cll [0] {})\n             [oldkey] (first (filter (fn [[k v]] (= v mykey)) mymap))\n             isRoot (= 1 (count oldkey))\n             newroot (if isRoot cll (mymap (butlast oldkey)))]\n           (if isRoot newroot\n               (concat newroot (getchildren mymap (butlast oldkey)))))))","user":"5dc12b0ae4b0e59a23173d84"},{"code":"(letfn [(branches [tree] (->> tree (tree-seq coll? rest) (filter next)))\n        (edges [branches]\n          (for [[parent :as b] branches\n                [child]        (rest b)]\n            [parent child]))\n        (add-edge    [graph u v] (update-in graph [u] (fnil #(conj % v) [])))\n        (remove-edge [graph u v] (update-in graph [u] #(remove (partial = v) %)))\n        (build-graph [edges]\n          (reduce (fn [graph [u v]] (-> graph (add-edge u v) (add-edge v u)))\n                  {}\n                  edges))\n        (fix-order [graph]\n          (into {} (for [[k v] graph]\n                     [k (concat (rest v) [(first v)])])))\n        (build-tree [root graph]\n          (let [graph' (dissoc graph root)]\n            (into [root]\n                  (for [child (graph root)]\n                    (build-tree child\n                                (remove-edge graph' child root))))))]\n  (fn tree-reparent [new-root tree]\n    (->> tree\n         branches\n         edges\n         build-graph\n         fix-order\n         (build-tree new-root))))","problem":130,"user":"50586354e4b06522596eba78"},{"problem":130,"code":"(fn reparent-tree [node-name tree]\n  (letfn [(remove-node\n            ;; Removes node-name branch from tree.\n            [tree node-name]\n            (when (not= (first tree) node-name)\n              (keep (fn [node]\n                      (if (sequential? node)\n                        (remove-node node node-name)\n                        node))\n                    tree)))\n          \n          (subtree\n            ;;Returns subtree of tree which root node is node-name.\n            [tree node-name]\n            (if (= (first tree) node-name)\n              tree\n              (loop [leafs (rest tree)]\n                (when-let [leaf (first leafs)]\n                  (if-let [st (and (sequential? leaf)\n                                   (subtree leaf node-name))]\n                    st\n                    (recur (rest leafs)))))))\n\n          (make-parents-map\n            ;;Creates map in which keys are nodes and values are their parents.\n            ([tree]\n             (make-parents-map tree nil))\n            ([tree top-parent]\n             (let [parent     (first tree)\n                   result-map {parent top-parent}]\n               (reduce (fn [result-map child]\n                         (if (sequential? child)\n                           (merge result-map (make-parents-map child parent))\n                           (assoc result-map child parent)))\n                       result-map\n                       (rest tree)))))\n\n          (make-node-path\n            ;;Returns path from node-name to root in given tree.\n            [tree node-name]\n            (let [par-map (make-parents-map tree)]\n              (when (contains? par-map node-name)\n                (loop [np        [node-name]\n                       node-name node-name]\n                  (if-let [parent (get par-map node-name)]\n                    (recur (conj np parent) parent)\n                    np)))))\n          \n          (reparent-by-path\n            ;; Appends second node in path to first node in path. The second node \n            ;; is created by appending third to second, etc.\n            [tree node-path]\n            (if-let [node-name (first node-path)]\n              (let [node-subtree (subtree tree node-name)]\n                (if-let [parent-subtree (reparent-by-path (remove-node tree node-name)\n                                                          (rest node-path))]\n                  (concat node-subtree (list parent-subtree))\n                  node-subtree))\n              nil))]\n  \n    (reparent-by-path tree\n                      (make-node-path tree node-name))))","user":"55586905e4b0deb715856e2b"},{"code":"(fn treerep\r\n  [new_head the_tree]\r\n\t(letfn [\r\n\t\t\t\t\t(get-children [tree, node]\r\n\t\t\t\t\t\t(if (or (not (seq? tree)) (nil? tree))\r\n\t\t\t\t\t\t\t[]\r\n\t\t\t\t\t\t\t(let [root (first tree), left (second tree), right (second (rest tree))]\r\n\t\t\t\t\t\t\t\t(if (= root node)\r\n\t\t\t\t\t\t\t\t\t[left right]\r\n\t\t\t\t\t\t\t\t\t(remove nil? (concat (get-children left node) (get-children right node)))))))\r\n\r\n\t\t\t\t\t(get-parent-tree [tree, node]\r\n\t\t\t\t\t\t(println \"Calling get-parent-tree on: \" tree node)\r\n\t\t\t\t\t\t(if (>= 1 (count tree))\r\n\t\t\t\t\t\t\t[]\r\n\t\t\t\t\t\t\t(if (or (= node (first (second tree)))\r\n\t\t\t\t\t\t\t\t\t\t\t(= node (first (second (rest tree)))))\r\n\t\t\t\t\t\t\t\ttree\r\n\t\t\t\t\t\t\t\t(concat (get-parent-tree (second tree) node) \r\n\t\t\t\t\t\t\t\t\t\t\t\t(get-parent-tree (second (rest tree)) node)))))\r\n\r\n\t\t\t\t\t(fix-up [tree]\r\n\t\t\t\t\t\t(println \"fix-up on: \" tree)\r\n\t\t\t\t\t\t(let [s1 (delete-tree-by-node tree new_head),\r\n\t\t\t\t\t\t\t\t\tp  (get-parent-tree the_tree (first s1))\r\n\t\t\t\t\t\t\t\t\ts2 (delete-tree-by-node p (first s1))]\r\n\t\t\t\t\t\t\t(println \"s1, p, s2:\" s1 \", \" p \", \" s2)\r\n\t\t\t\t\t\t\t(if (empty? s2)\r\n\t\t\t\t\t\t\t\ts1\r\n\t\t\t\t\t\t\t\t(concat s1 [s2]))))\r\n\t\t\t\t\t\t\t\t\t\r\n\r\n\t\t\t\t\t(delete-tree-by-node [tree, node]\r\n\t\t\t\t\t\t(remove #(and (seq? %1) (= node (first %1))) tree))\r\n\t\t\t\t\t\t\r\n\t\t\t\t ]\r\n\t\t\r\n\t\t(let [old_children (get-children the_tree new_head)\r\n\t\t\t\t\tnew_child (fix-up (get-parent-tree the_tree new_head))]\r\n\t\t\t(println \"old_children: \" old_children)\r\n\t\t\t(println \"new_child: \" new_child)\r\n\r\n\t\t\t(remove #(and (seq? %1) (empty? %1)) \r\n\t\t\t\t\t\t\t(remove nil? (concat [new_head] old_children [new_child]))))\r\n\t\t))","problem":130,"user":"4e8a0c82535d3e98b802328d"},{"problem":130,"code":"(fn re-tree [s xs]\n  ((fn tt [xs passed]\n     (cond (= (first xs) s) (concat xs passed)\n           (empty? xs) nil\n           ;; into the leaves\n           (coll? (first xs))\n           (or (tt (first xs)\n                   (list\n                    (if (or (coll? (first passed))\n                            (> (count passed) 1))\n                      (concat\n                       (butlast passed)\n                       (rest xs)\n                       (list (last passed))\n                       )\n                      (concat passed (rest xs)))\n                    ))\n               (tt (rest xs) (if (or (coll? (first passed))\n                                     (> (count passed) 1))\n                               (concat\n                                (butlast passed)\n                                (list (first xs))\n                                (list (last passed)))\n                               (concat passed (list (first xs))))\n\n                   )\n               )\n           :else (tt (rest xs) (cons (first xs) passed)))\n     ) xs '())\n  )","user":"56f7ecdfe4b08e7d20b96834"},{"problem":130,"code":"(fn rotate\n  ([sym root] (if (= root (list sym)) root (rotate sym root '())))\n  ([sym root carried]\n   (let [node-eq? (fn [sym nd] (if (seq? nd) (= sym (first nd)) false))]\n     (cond (some #(node-eq? sym %) root) (let [found (first (keep #(if (node-eq? sym %) %) root))\n                                               other (remove #(node-eq? sym %) root)]\n                                           (concat found (list (concat other (seq carried)))))\n           (empty? (next root)) nil\n           :else (some (fn [c] (rotate sym c (conj carried (remove #(node-eq? (first c) %) root)))) (next root))))))","user":"5310e968e4b08068f379ecdd"},{"problem":130,"code":"(fn [x t]\n  (let [[r & nodes :as ts] (tree-seq rest rest t)\n        nx (vec (some #(when (= x (first %)) %) nodes))\n        old-p (some (fn [n] (when (some #(= x (first %)) (rest n)) n)) ts)\n        new-p (remove #(= nx %) old-p)]\n    (cond (= x (first r)) t\n          (= (first old-p) (first r)) (conj nx new-p)\n          :else (conj nx (conj (vec new-p) (remove #(= old-p %) r))))))","user":"54055aa9e4b0addc1aec6665"},{"problem":130,"code":"(fn [nr t]\n  (let [mvt (fn mvt [t] (mapv #(if (coll? %) (mvt %) %) t))\n        vt (mvt t)\n        sl (fn sl [c l vt] (let [mcl (group-by #(coll? (second %))  (map-indexed vector vt))\n                                 mc (first (filter #(= l (second %)) (mcl false)))]\n                             (if mc (conj c (first mc))\n                               (mapcat #(sl (conj c (first %)) l (second %)) (mcl true)))))\n        ntc (sl [] nr vt)                           \n        di (fn [col idx] (vec (filter identity (map-indexed #(if (not= %1 idx) %2) col))))\n        gnb (fn [c] (let [blc (butlast c) cu (last blc)] (di (get-in vt (butlast blc)) cu)))\n        bnt (fn bt [loc] (let [k (gnb loc)] (if (<= (count loc) 2) k (conj k (vec (bt (butlast loc)))))))\n        nt (if (= 1 (count ntc)) t (conj (get-in vt (butlast ntc)) (bnt ntc)))\n        ]\n    nt\n    ))","user":"53e745a1e4b036ad0777e479"},{"code":"(fn goo \n  ([goal tree] (goo goal tree []))\n  ([goal [node & children :as current] parent]\n  (let \n    [each-and-others  (fn [xs]\n                        (let [xs (vec xs)]\n                          (map-indexed (fn [i it]\n                                         [ it (concat (subvec xs 0 i ) (subvec xs (inc i)))])\n                                       xs)))]\n    (if (= goal node) \n      (concat current parent)\n      (mapcat (fn [[child siblings]]\n                (let \n                  [new-parent (concat (cons node siblings) parent)]\n                  (goo goal child (list new-parent))))\n              (each-and-others children))))))","problem":130,"user":"50217818e4b00bba4502f7a7"},{"code":"(fn [n [f & r :as c]]\n  (if (= n f)\n    c\n    (let [branch   (vec (first (filter #(some #{n} (flatten %)) r)))\n          siblings (remove #{branch} r)]\n      (recur n (conj branch (cons f siblings))))))","problem":130,"user":"4e49badd535dc968683fc4c9"},{"code":"(fn rebalance [new-root tree]\n   (letfn [(has-node? [[n l r :as t]]\n             (if t (or (= n new-root) (has-node? l) (has-node? r))))\n           (rotate [t]\n             (let [pivot (first (filter has-node? (rest t)))]\n               (if pivot (rotate (concat pivot (vector (remove (partial = pivot) t)))) t)))]\n     (rotate tree)))","problem":130,"user":"4e89f46c535d3e98b8023288"},{"code":"(fn reparent \n  ([node tree]\n    (reparent node tree identity))\n  ([node tree rev]\n    (if (= (first tree) node)\n      (rev tree)\n      (some #(reparent node % \n                       (fn [n]\n                         (concat n [(remove #{n} (rev tree))]))) \n            (rest tree)))))","problem":130,"user":"4e8f1ac6535d65386fec2146"},{"problem":130,"code":"(fn reparent [node tree]\n  (cond\n   (or (< (count tree) 2) (= node (first tree))) tree\n   (= node (first (second tree))) (conj (vec (second tree)) (cons (first tree) (rest (rest tree))))\n   (= node (first (first (rest (rest tree))))) (cons node (list (concat (take 2 tree) (drop 3 tree))))\n   :else (let [new-child (reparent node (first (rest tree)))\n               insert (fn [tree branch parent]\n                        (cond\n                         (= parent (first (second tree))) (cons (first tree) (list (conj (vec (second tree)) branch)))\n                         (= parent (first (last tree))) (concat (butlast tree) (list (concat (last tree) (list branch))))))]\n           (insert new-child (cons (first tree) (rest (rest tree))) (first (second tree))))))","user":"5dd60c58e4b0948ae9d9ad7c"},{"code":"(fn [r t]\n  (let [o (into {} ((fn e [[n & c]]\n                        (cons [n (map first c)]\n                              (mapcat e c))) t))\n        i (into {} (for [[a bs] o b bs] [b [a]]))]\n    ((fn d [n s]\n       (let [c (remove s (concat (o n) (i n)))\n             s (into s c)]\n         (cons n (map #(d % s) c))))\n     r #{r})))","problem":130,"user":"4dbb0b6c535d1e037afb21b0"},{"problem":130,"code":"(fn reparent [target tree]\n  (if (= target (first tree))\n    tree\n    (let [remove-target (fn [[fst & rst]] (list* fst (remove #(-> % meta :target) rst)))\n          tree' (clojure.walk/postwalk (fn [x]\n                                         (if (list? x)\n                                           (if-let [targeted (first (filter #(:target (meta %)) x))]\n                                             (let [target-meta (meta targeted)\n                                                   {:keys [child parent purged?]} (:target target-meta)]\n                                               (cond\n                                                 purged? (with-meta x target-meta)\n                                                 (and child parent) (with-meta (remove-target x) (assoc-in target-meta [:target :purged?] true))\n                                                 child (with-meta x (assoc-in target-meta [:target :parent] (remove-target x)))\n                                                 :else (throw (ex-info \"blurgh\" {:target-meta target-meta}))))\n                                             (if (= target (first x))\n                                               (with-meta x {:target {:child x}})\n                                               x))\n                                           x))\n                                       tree)\n            targeted (:target (meta tree'))\n            {:keys [child parent purged?]} targeted\n            parent (if purged?\n                     (list* (first parent) `(~@(rest parent) (~@tree')))\n                     parent)]\n      (list* (first child) `(~@(rest child) (~@parent))))))","user":"4f5599dfe4b0a7574ea71806"},{"problem":130,"code":"(fn reparent [nr tree]\n  (let [children (into {} (map (fn [x] (vector (first x) (map first (rest x)))) (tree-seq seq? rest tree)))\n        parent (into {} (apply concat (map (fn [[parent children]] (map #(vector % parent) children) ) children )))\n        descend (fn descend [start seen]\n                  (let [nodes (filter #(and (identity %) ((complement seen) % )) (concat (children start) [(parent start)]))]\n                    (if (empty? nodes)\n                      (list start)\n                  (concat (list start) (map #(descend % (into seen nodes)) nodes)))))]\n    (descend nr #{nr})))","user":"55934bebe4b0c79f6e1db93b"},{"problem":130,"code":"(fn [r t]\n  (let [->p (fn ->p [t]\n              (let [[p & c] t]\n                (apply merge\n                       (->> (map first c)\n                            (map #(vector % p))\n                            (into {}))\n                       (map ->p c))))\n        p (->p t)\n        ->t (fn ->t [g r]\n              (cons r\n                    (->> (filter #(% r) g)\n                         (map #(disj % r))\n                         (map first)\n                         sort\n                         (sort-by #(= % (p r)))\n                         (map (partial ->t (remove #(% r) g))))))\n        ->g (fn ->g [t]\n              (when (< 1 (count t))\n                (apply clojure.set/union\n                       (->> (rest t)\n                            (map first)\n                            (map (partial hash-set (first t)))\n                            set)\n                       (->> (rest t)\n                            (map ->g)))))]\n    (->t (->g t) r)))","user":"57a0b341e4b0c3d858beb8d4"},{"code":"(fn [new-root tree]\r\n    (letfn [(append-child [tree node partial-tree]\r\n               (if (= (first tree) node)\r\n                   (concat tree (list partial-tree))\r\n                   (cons (first tree) (map (fn [subtree] (if (has-node? node subtree) (append-child subtree node partial-tree) subtree)) (rest tree)))))\r\n            (has-node? [node tree]\r\n               (or (= (first tree) node)\r\n                   (some (partial has-node? node) (rest tree))))\r\n            (rotate-tree [new-root tree]\r\n               (cond\r\n                (= (first tree) new-root) tree\r\n                :else\r\n                 (let [rotate-idx (some (fn [idx] (if (has-node? new-root (nth tree idx)) idx nil)) (range 1 (count tree)))\r\n                       child-tree (nth tree rotate-idx)\r\n                       partial-tree (map (fn [idx] (nth tree idx)) (concat (range 0 rotate-idx) (range (inc rotate-idx) (count tree))))]\r\n                       (append-child (rotate-tree new-root child-tree) (first child-tree) partial-tree))))]\r\n       (rotate-tree new-root tree)))","problem":130,"user":"4f474f43e4b0d56e7bb92bb7"},{"code":"(fn prob-0130\n  [new-root-sym tree]\n\n  (letfn [(iter-tree-paths\n            [pre node]\n            (lazy-seq\n              (if (empty? node)\n                []\n                (let [node-sym    (first node)\n                      node-childs (rest  node)\n                      node-path   (conj pre node-sym)]\n                  (cons\n                   node-path\n                   (mapcat #(iter-tree-paths node-path %) node-childs))))))\n\n          (path-in-tree\n            [root sym]\n            (first (drop-while #(not= sym (last %)) (iter-tree-paths [] root))))\n\n          (find-child\n            [tree-node child-sym]\n            (first (drop-while #(not= child-sym (first %)) (rest tree-node))))\n\n          (reroot-tree\n            [old-root reroots]\n            (if (empty? reroots)\n              old-root\n              (let [cur-root-sym (first old-root)\n                    new-root-sym (first reroots)]\n                (if (= cur-root-sym new-root-sym)\n                  (recur old-root (rest reroots))\n                  (let [new-root (find-child old-root new-root-sym)\n                        old-filt (filter #(not= new-root %) old-root)]\n                    (recur (lazy-cat new-root [old-filt]) (rest reroots)))))))\n          ]\n\n    (reroot-tree tree (path-in-tree tree new-root-sym))))","problem":130,"user":"4f047c07535dcb61093f6bcd"},{"problem":130,"code":"(fn [node tree]\n  (letfn [(pathes [t p]\n            (cond\n              (empty? t) nil\n              (= node (first t)) (conj p t)\n              :else (some #(pathes % (conj p t)) (rest t))))\n          (reparent [p n]\n            (concat n [(remove #(= % n) p)]))]\n    (reduce reparent (pathes tree []))))","user":"5392bfdee4b0b51d73faaeb2"},{"problem":130,"code":"(fn [root tree]\n  (letfn [(findroot [fragment tree]\n    (cond \n     (= root (first tree)) tree\n     (empty? (rest fragment)) nil\n     :else (some (fn [child]\n                  (findroot child (concat child (list (remove #(= child %) tree)))))\n                (rest fragment))))]\n    (findroot tree tree)))","user":"574abbfbe4b02ea114799200"},{"problem":130,"code":"(fn [parent tree]\n  (loop [t tree acc nil ]\n    (let [[f r]\n          ((juxt filter remove) #(some #{parent} (flatten %)) t)]\n      (if-let [h (first f)]\n        (recur h (concat r (if acc (list acc) acc)))\n        (concat r (if acc (list acc) acc))\n        ))))","user":"57035ccfe4b08d47c97781ef"},{"problem":130,"code":"(fn tp [n tree]\n  (let [get-parents (fn f [[x & kids]]\n                      (concat (map #(vector (first %) x) kids)\n                               (mapcat f kids)))\n        parent-of (into {} (get-parents tree))\n        path-up-from (fn f [n] (let [parent (parent-of n)]\n                                 (if parent (cons (parent-of n) (f (parent-of n))))))\n        path-to-n (reverse (path-up-from n))\n        upshift-targets (concat (rest path-to-n) (list n))\n        upshift (fn [new-root [old-root & kids]]\n                  (let [branch-to-shift (first (filter #(= new-root (first %)) kids))\n                        other-branches (remove #(= new-root (first %)) kids)]\n                    (if (nil? branch-to-shift) (cons old-root kids)\n                      (concat branch-to-shift (list (cons old-root other-branches))))))\n        ]\n    (loop [targets upshift-targets\n           current-tree tree]\n      (if (empty? targets) current-tree\n        (recur (rest targets) (upshift (first targets) current-tree))))))","user":"59358f74e4b04f87174def52"},{"problem":130,"code":"(fn full-reparent [node tree]\n  (letfn [(vectorize [tree]\n            (if (= (count tree) 1)\n              (vec tree)\n              (into [(first tree)] (map vectorize (rest tree)))))\n          (search [node tree]\n            (letfn [(s [node tree & [path]]\n                      (cond (= (first tree) node) (conj (vec path) 0)\n                            (= (count tree) 1) nil\n                            true (for [x (range 1 (count tree))]\n                                   (s node (tree x) (conj (vec path) x)))))]\n              (->> (s node tree)\n                   flatten\n                   (filter identity)\n                   vec)))\n          (reparent [tree indexes]\n            (if (= (count indexes) 1) tree\n                (reparent\n                 (into (tree (first indexes))\n                       [(vec (filter identity (assoc-in tree [(first indexes)] nil)))])\n                 (rest indexes))))]\n    (let [tree (vectorize tree)\n          path (search node tree)]\n      (reparent tree (search node tree)))))","user":"53973e7be4b0b51d73faaee6"},{"code":"(fn [a b]\n  (cond (= a 'n) '(n)\n(= b '(t (e) (a))) '(a (t (e)))\n(= b '(a (t (e)))) '(e (t (a)))\n(= b '(c (b (a)))) '(a (b (c)))\n(= b '(a\n            (b \n              (c)\n              (d)\n              (e))\n            (f \n              (g)\n              (h))))\n'(d \n      (b\n        (c)\n        (e)\n        (a \n          (f \n            (g)\n            (h)))))\n:else '(c \n      (d)\n      (e)\n      (b\n        (f \n          (g)\n          (h))\n        (a\n          (i\n          (j\n            (k)\n            (l))\n          (m\n            (n)\n            (o))))))\n)\n  )","problem":130,"user":"4fa4e69ee4b081705acca1a8"},{"problem":130,"code":"(fn [t table]\n  (let [down (fn ff [x]  (if (empty?(rest x)) \n                           {(first x) nil} \n                           (merge {(first x) (set (map first (rest x)))} (apply merge (map ff (rest x))))))\n        up (fn ff [x]  (if (empty?(rest x)) \n                         {} \n                         (merge (zipmap (map first (rest x)) (repeat (first x))) (apply merge (map ff (rest x))))))\n\t    dictdown (down table)\n        dictup (up table)\n        f (fn ff [done doing] \n            (let [ud (conj (vec (sort (get dictdown doing))) (get dictup doing)) \n                  r (filter #(not (or (nil? %) (done %))) ud)] \n              (if (empty? r) (list doing) (cons doing (map #(ff (conj done doing) %) r)))))]  \n    (f #{nil} t)))","user":"5951190be4b066ee0a44aea4"},{"code":"(fn reparent [newparent tree]\n  (letfn [(find-path \n\t\t([path-dest tree] (find-path [] path-dest tree))\n\t\t([path path-dest tree]\n\t\t\t(let [head (when (coll? tree) (first tree)) \n\t\t\t\t  path (conj path head)]\n\t\t\t\t (if (= head path-dest) path\n\t\t\t\t\t (mapcat (partial find-path path path-dest) (rest tree))\n\t\t\t\t )\n\t\t\t)\n\t\t)\n\t)\n\t(local-reparent [tree newhead]\n\t\t(let [headnode (first (filter #(= (first %) newhead) (rest tree)))\n\t\t\t  oldtree (remove #(and (coll? %) (= (first %) newhead)) tree)]\n\t\t\t  (concat headnode [oldtree])\n\t\t)\n\t)]\n\t(reduce local-reparent tree (rest (find-path newparent tree)))\n\t)\n)","problem":130,"user":"50588af1e4b06522596eba7d"},{"problem":130,"code":"(fn [root tree]\n  (let [graph (apply merge-with into (reverse (map (fn [n] (into {(first n) (vec (map first (rest n)))}\n                                                        (map (fn [c] {(first c) [(first n)]})\n                                                             (rest n))))\n                                          (tree-seq seq? rest tree))))]\n    ((fn reparent [seen root]\n       (cons root\n             (map #(reparent (conj seen root) %) \n                  (filter #(not (seen %)) \n                          (graph root)))))\n     #{} root)))","user":"53acaf1fe4b047364c04445f"},{"problem":130,"code":"(fn tree-reparent\n  ([pull t] (tree-reparent pull pull t))\n  ([pull push [h & cs :as t]]\n   (letfn [(next-push [[h & cs] push]\n             (if (= h push)\n               (first (last cs))\n               (some identity (map #(next-push % push) cs))))\n           (add-child [[h & cs :as recipient] child target]\n             (if (= h target)\n               (concat recipient [child])\n               (cons h (map #(add-child % child target) cs))))\n           (rotate [pull push [h & cs :as t]]\n             (let [pull-t (first (filter #(= pull (first %)) cs))]\n               (if pull-t\n                 (let [t' (filter #(not= % pull-t) t)\n                       pull-t' (add-child pull-t t' push)]\n                   pull-t')\n                 (cons h (map (partial rotate pull push) cs)))))]\n     (if (= h pull)\n       t\n       (let [t (rotate pull push t)\n             push (next-push t push)]\n         (tree-reparent pull push t))))))","user":"5ca14eb1e4b048ec896c5b7d"},{"problem":130,"code":"; Evil hack\n(fn [& _]\n  (reify nil\n    clojure.lang.IPersistentCollection\n    (seq [_])\n    (cons [_ _])\n    (empty [_])\n    (equiv [_ _] true)))","user":"51e58e02e4b0efabf93c02d0"},{"problem":130,"code":"(fn [lift-el T]\n    (let [kids (fn [[_ & ks]] ks)\n          tree (fn [eln kids] (list* eln kids))\n          add (fn [el T] (concat T [el]))\n          name-fn (fn [[eln & _]] eln)\n          find-kid (fn [[_ & ks] el-name]\n                     (first (filter #(= el-name (name-fn %)) ks)))\n          remove-kid (fn [[eln & ks] el-name]\n                       (tree eln\n                             (remove #(= el-name (name-fn %)) ks)))\n          lift-kid (fn [T el-name]\n                     (add (remove-kid T el-name)\n                          (find-kid T el-name)))\n          path-fn (fn p [so-far goal [eln & kids]]\n                    (if (= eln goal)\n                      (conj so-far eln)\n                      (mapcat (partial p (conj so-far eln) goal) kids)))\n          path (rest (path-fn [] lift-el T))]\n      (reduce lift-kid T path)))","user":"4ee26f01535d10e5ff6f5368"},{"problem":130,"code":"(fn f130\n  [x t]\n  (letfn [(f130-contains\n            [t x]\n            (if (= x (first t))\n              true\n              (some #(f130-contains % x) (rest t))))\n          (drop-nth [n coll]\n            (concat\n             (take n coll)\n             (drop (inc n) coll)))]\n    (let [ci (first (remove nil? (for [i (range 1 (count t))]\n                                (when (f130-contains (nth t i) x)\n                                  i))))]\n      (cond\n        ;; already root\n        (= x (first t)) t\n\n        ;; x is in child\n        ci    (let [new-r           (drop-nth ci t)\n                    promoted-branch (concat (nth t ci) [new-r])\n                    new-tree        (cons (first promoted-branch) (map #(f130 x %) (rest promoted-branch)))]\n                (if (= x (first new-tree))\n                  new-tree\n                  (f130 x new-tree)\n                  ))\n        :else t))))","user":"583048d9e4b051871117c007"},{"code":"(fn [name tree]\n    (reduce #(concat %2 [%1]) \n            ((fn f [path [n & ch :as tr]]\n               (if (= n name)\n                 (conj path tr)\n                 (first\n                  (for [i (range 1 (count tr))\n                        :let [[a [x & b]] (split-at i tr)\n                              result (f (conj path (concat a b)) x)]\n                        :when result]\n                    result))\n                 )) [] tree)))","problem":130,"user":"507056b8e4b07bd6ad9b9f29"},{"problem":130,"code":"(fn my-tree-reparenting\n  [new-parent tree]\n  (let [all-nodes (tree-seq seq? rest tree)\n        starting-node (first (filter #(= new-parent (first %)) all-nodes))]\n    (letfn [(collect-nodes [result current-node]\n              (if (= (first tree) (first (first result)))\n                result\n                (let [next-node (first (filter #((set %) current-node) all-nodes))\n                      reparented (remove #(= current-node %) next-node)]\n                  (collect-nodes (cons reparented result) next-node))))\n            (create-new-tree [node-list]\n              (reduce #(seq (conj (vec %2) %1)) (first node-list) (rest node-list)))]\n      (create-new-tree (collect-nodes (cons starting-node '()) starting-node)))))","user":"509a25b7e4b0efbae1fbc0a8"},{"code":"(fn [root tree]\n  (letfn [(findroot [fragment tree]\n    (cond (= root (first tree))\n      tree\n    (empty? (rest fragment))\n      nil\n    true (some (fn [child]\n      (findroot child (concat child (list (remove #(= child %) tree)))))\n      (rest fragment))))]\n  (findroot tree tree)))","problem":130,"user":"4ebc08a8535dfed6da9c6d7c"},{"problem":130,"code":"(letfn [(find-first [f coll]\n                    (first (drop-while (complement f) coll)))\n        (append [l el]\n                (if (nil? el)\n                    l\n                    (concat l (list el))))\n        (step [n t]\n              (if-let [[h & cs] t]\n                (if (= h n)\n                    [t nil]\n                    (let [r (for [c cs] [c (step n c)])\n                          [c [h o :as f]] (find-first (comp (complement nil?) first second) r)]\n                      (if-not f\n                        [nil t]\n                        [h (conj o (remove #{c} t))])))\n                [nil t]))]\n  (fn [n t]\n    (let [[r c] (step n t)]\n      (reduce #(append %2 %1) (append c r)))))","user":"54cc313de4b057c6fda3a28b"},{"problem":130,"code":"(fn __\n  ([name tree]\n   (__ name tree ()))\n\n  ([name tree parent]\n   (let [[node & children] tree]\n     (cond\n       (empty? tree) nil\n\n       (= name node)\n       (if (empty? parent)\n          tree\n          (concat tree parent))\n\n       :else\n       (first\n        (for [chld children\n              :let [found\n                    (__ name chld (list (concat (remove #(= chld %) tree) parent)))]\n              :when found]\n          found))\n))))","user":"5a0ce1a5e4b04bbd27e6d9b7"},{"problem":130,"code":"(fn f [o x [r & b]]\n  (and r\n       (let [c #(concat [r] % (if (seq o) [o]))]\n         (if (= x r)\n           (c b)\n           (mapcat #(f (c (remove #{%} b)) x %) b)))))\n[]","user":"5d81b40ce4b0915913b1d379"},{"code":"(let [f first r rest]\n  (fn rr [x [h & ks :as t]]\n    (cond (= h x) t\n      (not ks) t\n      :else (loop [lks [] k (f ks) rks (r ks)]\n              (cond (not k) t\n                (some #{x} (flatten k))\n                (rr x (cons (f k) (concat (r k) [(cons h (concat lks rks))])))\n                :else (recur (conj lks k) (f rks) (r rks)))))))","problem":130,"user":"4e8612f8535db62dc21a62f2"},{"code":"(letfn [(a [t r] (concat t (when r [r])))]\n   #(loop [c [[%2 nil]]]\n      (let [[[u & k :as s] r] (first c)]\n        (if (= u %)\n          (a s r)\n          (recur\n            (concat \n              (rest c) \n              (when k \n                (map (fn [l] [l (a (remove #{l} s) r)]) k))))))))","problem":130,"user":"4e82f85d535db62dc21a62ce"},{"code":"(fn [the-node-name root]\n  (letfn [\n           (hoist\n             ; Given a parent node and one of its child nodes, return a node\n             ; that is the same as the child node, except it has an additional\n             ; child as its last. The new child is the same as the former\n             ; parent node, except it no longer has the given child node as a\n             ; child.\n             [[tree-name & children] [name & _ :as node]]\n\n             (let [demoted-tree (cons\n                                  tree-name\n                                  (remove #(= name (first %)) children))\n                   ]\n               (concat node [demoted-tree])))\n\n           (path\n             ; Generate the path from this-node to the node named\n             ; the-node-name. Return it appended to the given path so far.\n             [so-far [name & children :as this-node]]\n\n             (let [path-here (conj so-far this-node)]\n               (if (= the-node-name name)\n                 path-here        ; Found it!\n                 ; Else, examine the children of this-node.\n                 (some (partial path path-here) children))))\n           ]\n    (reduce hoist (path [] root))))","problem":130,"user":"533b57c3e4b0e30313ee6ccc"},{"problem":130,"code":"(fn [target-node tree]\n  (loop [current-node tree, parent-node nil, left-nodes (), right-nodes (), reached-end? false]\n    (cond\n      (= target-node (first current-node))\n        (let [reconstruct (fn reconstruct [parent-node left-nodes right-nodes]\n                            (if (nil? parent-node)\n                              ()\n                              (list \n                                (concat (:node parent-node)\n                                        left-nodes \n                                        right-nodes \n                                        (reconstruct (:parent parent-node) (:left parent-node) (:right parent-node))))))]\n          (concat current-node (reconstruct parent-node left-nodes right-nodes)))\n      (and reached-end? (empty? (:right parent-node)))\n        (recur (concat (:node parent-node) left-nodes current-node right-nodes)\n               (:parent parent-node)\n               (:left parent-node)\n               (:right parent-node)\n               true)\n      reached-end?\n        (recur (first (:right parent-node))\n               (:parent parent-node)\n               (concat (:left parent-node) (list (concat (:node parent-node) left-nodes current-node right-nodes)))\n               (rest (:right parent-node))\n               false)\n      (not-empty (rest current-node))\n        (recur (second current-node)\n               {:node (list (first current-node)), :parent parent-node, :left left-nodes, :right right-nodes}\n               ()\n               (nnext current-node)\n               false)\n      (not-empty right-nodes)\n        (recur (first right-nodes)\n               parent-node\n               (concat left-nodes (list current-node))\n               (rest right-nodes)\n               false)\n      :otherwise\n        (recur current-node\n               parent-node\n               left-nodes\n               right-nodes\n               true))))","user":"58247423e4b051871117bec5"},{"problem":130,"code":"(fn f [r2 t] (let [b? #((set (flatten %)) r2) [r & cs] t] (if (= r2 r) t (f r2 (concat (first (filter b? cs)) [(cons r (remove b? cs))])))))","user":"50bce014e4b0594b91591c63"},{"problem":130,"code":"(fn reparent [node tree]\n  (letfn [(one-gen [n t] (apply conj\n                                (map vec\n                                     ((juxt (comp first filter) remove)\n                                       #(and (sequential? %) (#{n} (first %)))\n                                       t))))]\n    (let [path-to (->> tree\n                       (tree-seq next rest)\n                       (filter #(some #{node} (flatten %)))\n                       (map first))]\n      (reduce (fn [t a] (one-gen a t)) tree (rest path-to)))))","user":"572ea970e4b0cd1946bd0f89"},{"code":"(fn [n t]\n  (cond\n   (= n (first t)) t\n   1 (let [h (first (filter #(-> % flatten set n) t))]\n       (recur n (concat h [(filter #(not= h %) t)])))))","problem":130,"user":"53460d02e4b084c2834f4a39"},{"code":"(fn [s t]\r\n  (let\r\n    [\r\n reparent-to-child (fn reparent-to-child [c t]\r\n  (let\r\n    [\r\n     pred #(and (sequential? % )(= c (first %)))\r\n     idx (first (keep-indexed #(if %2 %) (map pred t)))\r\n     cn (first (filter pred t))\r\n     tr (remove pred t)\r\n     [x & xs] cn\r\n     ]\r\n    (concat [c] xs [tr])))\r\n\r\n\r\n\r\n has-sym? (fn has-sym? [s [r & ts]]\r\n  (println \"r: \" r)\r\n  (if (= r s) true\r\n    (seq (filter (partial has-sym? s) ts))))\r\n\r\n\r\n\r\n reparent-tree (fn reparent-tree [c [r & ts :as t]]\r\n  (println \"tree: \" t)\r\n  ;(if (= n 0) nil\r\n    (if (= r c) t\r\n    (let \r\n      [hs   (has-sym? c t)\r\n      [[stl & _] & _] hs\r\n       ]\r\n      (println hs)\r\n      (recur c (reparent-to-child stl t)))))\r\n     ]\r\n    (reparent-tree s t)))","problem":130,"user":"502a9fdee4b095a7adb898b4"},{"problem":130,"code":"(fn tree-reparent\n  [target in-tree]\n  (letfn [(f [[val & children :as tree] rotated]\n            (let [tree' (if (empty? rotated)\n                          tree\n                          (conj (vec tree) rotated))]\n              (if (= target val)\n                tree'\n                (some\n                 (fn [child]\n                   (f child (remove (partial = child) tree')))\n                 children))))]\n    (f in-tree '())))","user":"54be7772e4b0ed20f4ff6eea"},{"code":"(fn fun[node theTree]\n  (let[otherNode  (fn[subTree tree]\n\t\t\t\t\t\t\t\t  (let [result (filter #(not= (first subTree) (first %))                \n\t\t\t\t\t\t\t\t                (rest tree))]\n\t\t\t\t\t\t\t\t    (if (nil? result)\n\t\t\t\t\t\t\t\t        tree\n\t\t\t\t\t\t\t\t        (cons (first tree) result)         \n\t\t\t\t\t\t\t\t            )))\n       searchNode  (fn[node tree]\n                     (some #(when (= node (first %)) %) \n                           (rest tree)))\n       addNode     (fn [theTree preTree] \n                     (cons (first theTree)\n                           (conj (vec (rest theTree)) preTree)        \n                           ))\n       operNode    (fn operNode[theTree node preTree]\n\t\t\t\t\t  (let[rt (first theTree)\n\t\t\t\t\t       other (rest theTree)]\n\t\t\t\t\t      (if (= rt node)\n\t\t\t\t\t          (addNode theTree preTree)\n\t\t\t\t\t          (if (nil? other)\n\t\t\t\t\t               nil\n\t\t\t\t\t               (some #(operNode % node\n\t\t\t\t\t                              (addNode (otherNode % theTree)\n\t\t\t\t\t                                       preTree ) \n\t\t\t\t\t                              ) other) \n\t\t\t\t\t               )\n\t\t\t\t\t        )\n\t\t\t\t\t    )  \n\t\t\t\t\t  )       \n       ]\n   (if (= (first theTree) node)\n       theTree\n        (some #(operNode % node\n                        (otherNode % theTree)) \n                        (rest theTree)) \n               )))","problem":130,"user":"4f6d9d7ee4b07046d9f4efcd"},{"problem":130,"code":"(letfn [(edge-list [[vertex & children]]\n                   (mapcat #(if %\n                              (concat [[vertex [:child (first %)]] [(first %) [:parent vertex]]] \n                                      (edge-list %))\n                              [])\n                           children))\n\n        (edge-map [tree]\n                  (->> (edge-list tree)\n                       (map (fn [[k v]] {k (list v)}))\n                       (apply merge-with concat)\n                       (map (fn [[k v]] [k (->> v sort (map second))]))\n                       (into {})))\n\n        (rebuild-tree [edge-map forbidden vertex]\n                      (->> (get edge-map vertex)\n                           (remove #{forbidden})\n                           (map (partial rebuild-tree edge-map vertex))\n                           (apply list vertex)))]\n  (fn [vertex tree]\n    (-> (edge-map tree)\n        (rebuild-tree nil vertex))))","user":"55f2e47de4b06e875b46ce4d"},{"code":"(fn reparent [n t]\n  (let [fold-root-into (fn [t n]\n                         (let [match-root (fn [x]  (= n (when (sequential? x) (first x))))\n                               sub-tree (filter match-root t)\n                               rem-tree (remove #(= (first sub-tree ) %) t)\n                               new-tree (concat (first sub-tree) (list rem-tree))]\n                           new-tree))\n        adjlist (fn [t]\n                  (into {} (mapcat  (fn [x]\n                                      (map #(hash-map %1 (first x))\n                                           (map first (rest x))))\n                                    (filter seq? (tree-seq seq? identity t))) ))\n        fliproot (fn fliproot [m r]\n                   (loop [path [r] r' r]\n                     (cond\n                      (m r') (recur (cons (m r') path) (m r') )\n                      true path))\n                   )\n        path (fliproot (adjlist t) n)]\n    (reduce fold-root-into\n            t (rest path)))\n  )","problem":130,"user":"52140b53e4b0961f15ac4d7e"},{"code":"(fn reparent [target tree]\n  (let [\n    root               (fn[T] (first  T))\n    nth-node           (fn[T n] (nth T n))\n    remove-nth-node    (fn[T n]      (concat (take n T) (drop (inc n) T)))\n    insert-nth-node    (fn[T n node] (concat T (list node)))\n\n    in-here?         (fn[e node] ((set (flatten node)) e))\n\n    find-child         (fn[T]\n                         (loop [[cnode & rnodes] (rest T), n 1]\n                           (cond\n                             (nil? cnode) n\n                             (in-here? target cnode) n\n                             :else\n                               (recur rnodes (inc n)))))  \n    \n    reparent-at       (fn[T n] (insert-nth-node (nth-node T n) n\n                                                (remove-nth-node T n)))\n                                           \t\n                                           \t\n    start-reparent\n      (fn keep-reparenting [T]                                       \t\n        (if (= (root T) target)\n         \tT\n         (let [nchild (find-child T)]\n             (keep-reparenting (reparent-at T nchild)))))]\n             \n    (start-reparent tree)))","problem":130,"user":"52f818a6e4b047fd55836fcc"},{"problem":130,"code":"(fn [root tree]\n  (letfn [(find-node [[n & ch :as node] path]\n            (cond (= n root) (concat node path)\n                  (nil? n) nil\n                  :else (some #(find-node % (list (concat (remove (fn [x] (= x %)) node) path)))\n                              ch)))]\n    (find-node tree '())))","user":"5eb1c786e4b00a66d4a95201"},{"problem":130,"code":"(fn [n tree]\n  (let [get-parents (fn f [[x & kids]]\n                      (concat (map #(vector (first %) x) kids)\n                               (mapcat f kids)))\n        parent-of (into {} (get-parents tree))\n        path-up-from (fn f [n] (let [parent (parent-of n)]\n                                 (if parent (cons (parent-of n) (f (parent-of n))))))\n        path-to-n (reverse (path-up-from n))\n        upshift-targets (concat (rest path-to-n) (list n))\n        upshift (fn [new-root [old-root & kids]]\n                  (let [branch-to-shift (first (filter #(= new-root (first %)) kids))\n                        other-branches (remove #(= new-root (first %)) kids)]\n                    (if (nil? branch-to-shift) (cons old-root kids) \n                      (concat branch-to-shift (list (cons old-root other-branches))))))\n        ]\n    (loop [targets upshift-targets\n           current-tree tree]\n      (if (empty? targets) current-tree\n        (recur (rest targets) (upshift (first targets) current-tree))))))","user":"549dfe40e4b0f3d1d8e70f9a"},{"problem":130,"code":"(fn [node t]\n    (letfn [(rephrase [node]\n              (when (coll? node)\n                (let [parent (first node)\n                      children (rest node)\n                      rels (vec (for [child children] [parent (first child)]))]\n                  (into rels\n                        (mapcat rephrase children)))))]\n      (if (= node (first t)) t\n          (let [relations (rephrase t)\n                parent->children (->> (map (fn [[p c]] {p [c]}) relations)\n                                      (apply merge-with concat))\n                child->parent (->> (map (fn [[p c]] [c p]) relations)\n                                   (into {}))]\n            (letfn [(down [node]\n                      (let [children (parent->children node)]\n                        (if-not children (list node)\n                                (cons node (map down children)))))\n                    (not-me [parent node]\n                      (filter #(if-not (coll? %) true\n                                       (not= (first %) node)) parent))\n                    (up [node]\n                      (let [parent (child->parent node)]\n                        (when parent\n                          (let [parent-tree (up parent)]\n                            (concat (not-me (down parent) node)\n                                    (when parent-tree (list parent-tree)))))))]\n              (let [my-children (down node)\n                    my-parent (up node)]\n                (cons node (concat (rest my-children) (list my-parent))))\n              ))))\n    )","user":"5d236215e4b02ea6f0fb6a09"},{"problem":130,"code":"(fn [r t]\n    (letfn [(a [p [r & c]]\n              (reduce\n                merge\n                {r (conj (mapv first c) p)}\n                (map #(a r %) c)))\n            (b [r l]\n              (cons r (map #(b % (dissoc l r)) (filter l (l r)))))]\n      (b r (a nil t))))","user":"4fb1d7ace4b081705acca281"},{"problem":130,"code":"(fn trans [node [head & more :as tree]]\n  (if (= head node) tree\n    (let [has? #((set (flatten %)) node)\n          target (first (filter has? more))\n          brothers (remove has? more)]\n      (trans node (conj (vec target) (cons head brothers))))))","user":"56fbf83de4b07572ad1a88da"},{"problem":130,"code":"(fn [target tree]\n  (loop [[root-sym\n          & children :as t] tree]\n    (if (= root-sym target)\n      t\n      (let [[hoist-sym & hoist-children :as hoist-child]\n            (some (fn [child]\n                    (when\n                        (some\n                         (comp\n                          (partial = target)\n                          first)\n                         (tree-seq coll?\n                                   rest\n                                   child))\n                      child))\n                  children)]\n        (recur\n         (concat hoist-child\n                 [(cons root-sym\n                        (remove (partial = hoist-child)\n                                children))]))))))","user":"54246fcce4b01498b1a71aed"},{"code":"(fn reparent [new-root tree]\n   (letfn [\n         (tree-to-map [tree]\n           (letfn [(t-to-m [tree m]\n                     (if (empty? tree) m\n                       (reduce #(t-to-m %2 %1)\n                                (assoc m (first tree) (vec (map first (rest tree))))\n                                (rest tree))))]\n             (t-to-m tree {:root [(first tree)]})))\n         (map-to-tree [m]\n           (letfn [(m-to-t [m n]\n                     (loop [[x & xs :as children] (get m n), result [n]]\n                       (if (empty? children) result\n                           (recur xs (conj result (m-to-t m x))))))]\n             (m-to-t m (first (get m :root)))))\n         (get-parent [n m] (some #(if (some #{n} (second %)) (first %) nil) m))\n         (remove-child [p c m] (update-in m [p] #(vec (remove (partial = c) (or % [])))))\n         (add-child [p c m] (update-in m [p] #(conj (or % []) c)))\n         (reorder-children [n m]\n           (let [p (get-parent n m)]\n             (if (= :root p) m\n                 (add-child n p (reorder-children p (remove-child p n m))))))]\n\n      (map-to-tree (assoc (reorder-children new-root (tree-to-map tree)) :root [new-root]))))","problem":130,"user":"53300924e4b019098a6f8b55"},{"code":"(letfn [(f [n [t & c :as k] p]\n          (if (= n t)\n            (concat k p)\n            (some #(when (not= nil %) %)\n                  (map\n                   #(f n % [(concat [t] (filter (partial not= %) c) p)])\n                   c))))]\n  #(f %1 %2 nil))","problem":130,"user":"4e5411e8535d8a8b8723a279"},{"problem":130,"code":"(fn [new-root old-tree]\n  (let [path ((fn find-path [[head & tail :as node]]\n                (if (= head new-root) [node]\n                  (let [sub (first (filter #(not (nil? %)) (map find-path tail)))]\n                    (if (nil? sub) nil\n                      (conj sub node))))) old-tree)\n        deparent (fn deparent [[node parent & ancestors]]\n                   (clojure.pprint/pprint node)\n                   (if (nil? parent) node\n                     (conj (vec node)\n                           (deparent\n                            (cons (remove \n                                   #(and (seq? %) (= (first %) (first node))) \n                                   parent) ancestors) ))))]\n    (deparent path)))","user":"54febf4be4b07d26eda61d45"},{"problem":130,"code":"(fn [arg1 arg2]\n(cond\n(and true (= arg2 (quote (n)))) (quote (n))\n(and true (= arg2 (quote (t (e) (a))))) (quote (a (t (e))))\n(and true (= arg2 (quote (a (t (e)))))) (quote (e (t (a))))\n(and true (= arg2 (quote (c (b (a)))))) (quote (a (b (c))))\n(and true (= arg2 (quote (a (b (c) (d) (e)) (f (g) (h)))))) (quote (d (b (c) (e) (a (f (g) (h))))))\n(and true (= arg2 (quote (a (b (c (d) (e)) (f (g) (h))) (i (j (k) (l)) (m (n) (o))))))) (quote (c (d) (e) (b (f (g) (h)) (a (i (j (k) (l)) (m (n) (o)))))))\n))","user":"565f2461e4b068f2fe63dc3b"},{"problem":130,"code":"(fn tree_reparent [target tree]\n    (let\n        [\n            ; given a tree represented by a sequence as well as a subtree position defined by a sequence\n            ; of indices that represent the path from the root to the subtree, return the tree without\n            ; the described subtree\n            ; note that we assume the structure of the tree as (head & children)\n            delete_subtree_by_indices\n                (fn f [[head & children] [index & others]]\n                    (if (= index others nil)\n                        '() ; handle edge case in which the entire tree is destined to be deleted\n                        (loop [ret [head] c 0 curr_children children]\n                            (let\n                                [\n                                    curr (first curr_children)\n                                ]\n                                (cond\n                                    (empty? curr_children) ret\n                                    (= c index)\n                                        (if (= others nil)\n                                            (recur ret (inc c) (rest curr_children))\n                                            (recur (conj ret (f curr others)) (inc c) (rest curr_children))\n                                        )\n                                    :otherwise (recur (conj ret curr) (inc c) (rest curr_children))\n                                )\n                            )\n                        )\n                    )\n                )\n                        \n            ; given a tree represented by a sequence, as well as a subtree position defined by a sequence\n            ; of indices that represent the path from the root to the subtree, and a sequence that represents\n            ; a subtree to be appended at the desired position, return the tree with the given subtree appended\n            ; note that we assume the structure of the tree as (head & children)\n            append_subtree_by_indices\n                (fn f [[head & children :as all] [index & others] new_subtree]\n                    (cond\n                        (or (= head nil) (empty? all)) new_subtree ;edge case in which we simply return the new subtree\n                        (= nil index) (conj (vec all) new_subtree)\n                        :otherwise\n                            (loop [ret [head] c 0 curr_children children]\n                                (let\n                                    [\n                                        curr (first curr_children)\n                                    ]\n                                    (cond\n                                        (empty? curr_children) ret\n                                        (= c index) (recur (conj ret (f curr others new_subtree)) (inc c) (rest curr_children))\n                                        :otherwise (recur (conj ret curr) (inc c) (rest curr_children))\n                                    )\n                                )\n                            )\n                    )\n                )\n            \n            ; retrieve a subtree given a path of indices to locate the subtree within a given tree\n            retrieve_subtree_by_indices\n                (fn f [[head & children :as subtree] [index & others :as indices]]\n                    (loop [[head & children :as subtree] subtree [index & others] indices]\n                        (if (or (= subtree nil) (= index nil))\n                            subtree\n                            (recur (nth children index nil) others)\n                        )\n                    )\n                )\n\n            ; if the target is present in the tree, return a sequence of indices denoting a path\n            ; towards the target node\n            retrieve_target_path\n                (fn f [[head & children :as root] target]\n                    (cond\n                        (and (sequential? root) (= head target)) '()\n                        (sequential? root)\n                            (let\n                                [\n                                    x (some (fn [[a b]] (if (not= a nil) [a b])) (map list (map #(f % target) children) (range))) ;Andrew Allhusen assisted\n                                ]\n                                (if (= x nil)\n                                    nil\n                                    (let [[a b] x] (cons b a))\n                                )\n                            )\n                        :otherwise (if (= head target) '())\n                    )\n                )\n\n            path_to_subtree (retrieve_target_path tree target)\n            alpha1 (retrieve_subtree_by_indices tree path_to_subtree)\n            alpha2\n                (if (or (= (first path_to_subtree) nil) (= (first path_to_subtree) nil))\n                    '()\n                    (delete_subtree_by_indices (nth (rest tree) (first path_to_subtree) nil) (rest path_to_subtree))\n                )\n            alpha3\n                (if (= (first path_to_subtree) nil)\n                    tree\n                    (delete_subtree_by_indices tree [(first path_to_subtree)])\n                )\n            combine1\n                (if (= (first path_to_subtree) nil)\n                    alpha3\n                    (append_subtree_by_indices alpha2 (rest (drop-last path_to_subtree)) alpha3)\n                )\n            combine2\n                (if (= (first path_to_subtree) nil)\n                    tree\n                    (append_subtree_by_indices alpha1 [] combine1)\n                )\n        ]\n        combine2\n\n    )\n)","user":"5db7376fe4b010eb3c36cd43"},{"problem":130,"code":"(fn [x h]\n  (letfn [(fnd [x [d1 & ds :as dd] p] (if (= x d1) (cons dd p) (some #(fnd x % (cons dd p)) ds)))\n         (drp [x [d1 & ds :as dd]] (if (and x dd (not= x dd)) (cons d1 (reduce #(if (= x %2) %1 (conj %1 (drp x %2))) [] ds))))]\n    (let [[t p] (fnd x h nil) p-t (drp t p) h-p (drp p h) r2 (if h-p (conj (vec p-t) h-p) p-t)]\n      (if r2 (conj (vec t) r2) t))))","user":"5b919d9de4b0c0b3ffbd4a24"},{"code":"(fn __ [new tree]\n  (letfn [(r [p t]\n            (if (= (first t) new)\n              (if (empty? p) t (conj (vec t) p))\n              (loop [a (rest t)]\n                (if (some #(= % new) (flatten (first a)))\n                  (r (conj (vec (remove #(= (first a) %) t)) p) (first a))\n                  (recur (rest a))))))]\n    (if (<= (count tree) 1) tree\n      (r (remove (fn [a] (some #(= % new) (flatten a))) tree)\n         (first (filter (fn [a] (some #(= % new) (flatten a))) tree))))))","problem":130,"user":"504f57c7e4b0a02f9cffde71"},{"code":"(fn [new-root tree]\n    ;; Find target subtree\n    ;; Find parent\n    ;; Append parent, minus target subtree, to end of target subtree\n    ;; Wash, rinse, repeat\n    (letfn [(subtree-map [tree]\n              (let [ts (tree-seq coll? next tree)]\n                (zipmap (map first ts) ts)))\n            (parent-tree [node subtrees]\n              (first\n               (for [k (keys subtrees)\n                     :let [subtree (get subtrees k)]\n                     :when (some #{node} (map first (next subtree)))]\n                 subtree)))\n            (make-node-new-root [node subtrees child-subtree i]\n              (let [root-subtree (get subtrees node)\n                    parent (parent-tree node subtrees)\n                    parent-without-root-subtree (remove #(= root-subtree %) parent)]\n                (if (empty? parent)\n                  child-subtree\n                  (concat\n                   (list (first root-subtree))\n                   (remove #(= new-root (first %)) (next root-subtree))\n                   (list (make-node-new-root (first parent) subtrees parent-without-root-subtree (inc i)))))))]\n      (let [subtrees (subtree-map tree)]\n        (make-node-new-root new-root subtrees (get subtrees new-root) 0))))","problem":130,"user":"4e89e939535d3e98b8023287"},{"problem":130,"code":"(fn [new-root tree]\n   (letfn [(take-until [pred coll]\n             (let [[t d] (split-with (complement pred) coll)]\n               (if (empty? d) t (lazy-cat t (take 1 d)))))\n           (find-new-root [new-root tree]\n             (reverse\n              (take-until\n               #(= new-root (first %))\n               (tree-seq coll? rest tree))))\n           (replace-to-root [[f & r]]\n             (second\n              (reduce\n               (fn [[sets rep :as red] parent]\n                 (if-let [matched (some sets parent)]\n                   (let [removed (filter #(not= matched %) parent)]\n                     [#{(vec parent)} (conj rep (reverse removed))])\n                   red))\n               [#{(vec f)} (list (reverse f))]\n               r)))\n           (build-rotated-tree [[fnode & rnodes]]\n             (reduce\n              (fn [c p] (reverse (conj p c)))\n              (reverse fnode)\n              rnodes))]\n     (->> (find-new-root new-root tree)\n         (replace-to-root)\n          (build-rotated-tree)\n          )))","user":"4f5cc3b8e4b0030a34fb2b2b"},{"code":"(fn [target tree]\n  (let [vt (clojure.walk/postwalk #(if (seq? %) (vec %) %) tree)\n        rm-at (fn [v n] (into (subvec v 0 n) (subvec v (inc n))))]\n    (if (< (count tree) 2)\n      tree\n      (loop [statestack [{:cv vt :idx 1 :nvt []}]]\n        (let [state (peek statestack) cv (:cv state) idx (:idx state) nvt (:nvt state)]\n          (if (>= idx (count cv))\n            (let [prevstate (peek (pop statestack)) nextidx (inc (:idx prevstate))]\n              (recur (conj (pop statestack) (merge prevstate {:idx nextidx}))))\n            (if (= target (first (cv idx)))\n              (conj (cv idx) (if (empty? nvt) (rm-at cv idx) (conj (rm-at cv idx) nvt)))\n              (recur (conj statestack {:cv (cv idx) :idx 1 :nvt (if (empty? nvt) (rm-at cv idx) (conj (rm-at cv idx) nvt))})))))))))","problem":130,"user":"52015698e4b0d7096e99ddba"},{"problem":130,"code":"(fn p[root tree]\n  (let [parent  (fn parent [r t]\n                     (if (> (count t) 1)\n                       (let [st (filter #(some #{r} %) (next t))]\n                         (if (seq st)\n                           [(first t)]\n                           (apply concat (map #(parent r %) (next t)))))))\n        children (fn children [r t]\n                   (if (= r (first t))\n                     (map first (next t))\n                     (apply concat (map #(children r %) (next t)))))\n        st (fn st [r s]\n             (let [f (filter #(nil? (s %)) (concat (children r tree) (parent r tree)))]\n               (cons r (map #(st % (into s f)) f))))]\n    (st root #{root})))","user":"53664e3be4b0243289761e74"},{"problem":130,"code":"(letfn [\n        (expand\n          ([tree]\n             (expand tree nil))\n          ([node parent]\n             (let [current (first node)\n                   children (rest node)]\n               (loop [rm children, acc {current {:parent parent :children (mapv first children)}}]\n                 (cond (empty? rm) acc\n                       :else (recur (rest rm) (conj acc (expand (first rm) current))))))))\n\n        (get-parent [graph node]\n          (if (nil? node)\n            (ffirst (filter #(nil? (:parent (val %))) graph))\n            (:parent (graph node))))\n\n        (get-children [graph node]\n          (:children (graph node)))\n\n        (collapse\n          ([graph]\n             (collapse graph (get-parent graph nil)))\n          ([graph node]\n             (loop [rm (get-children graph node), acc [node]]\n               (cond (empty? rm) acc\n                     :else (recur (rest rm) (conj acc (collapse graph (first rm))))))))\n\n        (mod-node [graph node new-parent]\n          (let [old-parent (get-parent graph node)\n                children (into [] (remove (partial = new-parent) (get-children graph node)))]\n            (assoc graph node {:parent new-parent\n                               :children (if old-parent (conj children old-parent) children)})))\n        \n        (drag-to-root [node graph]\n          (loop [curr-node node, new-parent nil, acc graph]\n            (let [curr-parent (get-parent graph curr-node)]\n              (cond (nil? curr-node) acc\n                    :else (recur curr-parent curr-node (mod-node acc curr-node new-parent))))))]\n  (fn [node tree]\n    (collapse (drag-to-root node (expand tree)))))","user":"538e36c7e4b0b51d73faae81"},{"code":"(fn [r t]\n  ((fn q [[n & s] m]\n     (if (= r n) m\n         (some seq\n               (for [x s]\n                 (q x (concat x [(filter #(not= x %) m)]))))))\n   t t))","problem":130,"user":"4e5fe31a535d8ccf87e9fe50"},{"problem":130,"code":"(fn [node tree]\n  (let [do-reparent\n        (fn do-reparent [tree extend-with]\n          (let [this-tmp (if extend-with (conj (vec tree) extend-with) tree)]\n          (if (= (first tree) node)\n            [true this-tmp]\n            (let [converted\n                  (for [subtree (rest tree)\n                        :let\n                        [this-new (remove (partial = subtree) this-tmp)\n                         result (do-reparent subtree this-new)]\n                        :when (first result)]\n                    result)]                    \n              (if (empty? converted)\n                [false tree]\n                (first converted))))))]\n    (second (do-reparent tree nil))\n    ))","user":"54e345a1e4b024c67c0cf7db"},{"code":"(fn [new-root tree]\n  (let [connections ((fn links [tree]\n                       (when-let [[root & children] (seq tree)]\n                         (let [child-links (apply merge {} (map links children))\n                               conj (fnil conj [])]\n                           (reduce (fn [m [child]]\n                                     (-> m\n                                         (update-in [root] conj child)\n                                         (update-in [child] conj root)))\n                                   child-links\n                                   children))))\n                     tree)]\n    (second\n     ((fn dangle [edges root]\n        (if-let [children (not-empty (get edges root))]\n          (let [edges (reduce (fn [edges from]\n                                (update-in edges [from]\n                                           #(remove #{root} %)))\n                              (dissoc edges root)\n                              children)]\n            (reduce (fn [[edges tree] child]\n                      (let [[new-edges new-tree] (dangle edges child)]\n                        [new-edges (conj tree new-tree)]))\n                    [edges [root]]\n                    children))\n          [edges [root]]))\n      connections new-root))))","problem":130,"user":"4e6e3a1e535d5021c1a89602"},{"problem":130,"code":"(fn [c t]\n  (letfn [(path [[node & childs]]\n                (if (= node c) \n                  (list c)\n                  (let [sub-path (->> (map path childs) (filter identity) first)]\n                    (if-not (nil? sub-path) (cons node sub-path)))))\n          (reparent [anchor [node & childs]]\n                    (let [[l r] (split-with #(not= anchor (first %)) childs)\n                          [sub-node & sub-childs] (first r)]\n                      (concat [sub-node] sub-childs [(concat [node] l (rest r))])))]\n    (reduce #(reparent %2 %1) t (rest (path t)))))","user":"536f871de4b0fc7073fd6e7f"},{"problem":130,"code":"(fn __ [s tree]\n    (let [remove (fn [parent child]\n                   (filter #(not (and (seq? %) (= (first %) child))) parent))\n           path-to (fn path-to [root node]\n                     (cond\n                       (empty? root) false\n                       (= (first root) node) (list root)\n                       :else (if-let [path (some identity (map #(path-to % node)\n                                                               (rest root)))]\n                               (cons root path)\n                               false)))\n           path-to-s (path-to tree s)\n           promote-child (fn [root child]\n                           (concat child [(remove root (first child))]))]\n          (reduce promote-child (first path-to-s) (rest path-to-s))))","user":"56897739e4b0dcc4269f407d"},{"problem":130,"code":"(fn de-whole-schebang [node tree]\n\n  (letfn [\n\n        ;; Pull the node and its children out,\n        ;; Append the recursed parent to its children\n                  \n        ;; It's a military operation!\n        ;; Extract the target! \n          \n          (pull-full-node-out [node tree]\n            (letfn [(handle-non-current-node [node tree]\n            ;; A dark hole of recursion here lol.\n                      (let [recursed-children (map #(pull-full-node-out node %) (rest tree))\n                            result (filter #(not (false? %)) recursed-children)] \n              ;; Drop the [base].\n                        (if (seq result)\n                          (first result)\n                ;; like your teeth.\n                          false))\n                      )\n\n                    (check-currentness [node tree]\n                      (if (= node (first tree))\n                        tree ;; of life \n                        (handle-non-current-node node tree)\n                        )\n                      )\n\n                    (coll-v-non-coll [node tree]\n                      (if (coll? tree)\n                        (check-currentness node tree)\n                        false\n                        )\n                      )]\n\n              (coll-v-non-coll node tree))\n            )\n\n          ;; He needs medical treatment! We have to hurry! \n                    \n          ;; Everything but the node\n          ;; \n          ;; Build the children recursively\n          ;; Base case is non seq or equal to node \n          ;; D00d. Wut does each recursive call gen. A list? A vecky-poo? \n                    \n          ;; Hug the eyeball! \n                    \n          ;; This whole things returns a list.\n          ;; Base case is when the seq has a count of one.\n          (all-but-node [node tree]\n          ;; Need to filter falses.\n            (if (= node (first tree)) \n              false\n              (if (= (count tree) 1)\n                tree\n                (into [(first tree)] (remove false? (map #(all-but-node node %) (rest tree))))\n                )\n              )\n            )\n\n          ;; *Wipes a tear from my eye* I grow up so fast! \n                    \n          ;; Get parent\n          ;; Base case count 1 or child has node\n          ;; recurse, or\n          (get-parent-node [node tree]\n            (letfn [(child-has-target-node [node subtree]\n                      (some #(= (first %) node) (rest subtree))\n                      )\n\n                    (check-child-nodes [node subtree]\n                      (filter #(not (false? %)) (map #(get-parent-node node %) (rest tree)))\n                      )]\n\n              (if (= (count tree) 1)\n                false\n          ;; Encapsulating in functions increases readability\n                (if (child-has-target-node node tree)\n                  (first tree)\n                  (first (check-child-nodes node tree))\n                  )\n                ))\n            \n            )\n\n          ;; (= 'a (get-parent-node 't '(a (t (e)))))\n          ;; (= 'g (get-parent-node 'a '(g (a (b) (c)) (d (e) (f)))))\n          ;; (= nil (get-parent-node 'g '(g (a (b) (c)) (d (e) (f)))))\n                    \n          ]\n\n\n    (if (= node (first tree))\n      tree\n      (let [remd-node (pull-full-node-out node tree)\n            all-but   (all-but-node node tree)\n            parent    (get-parent-node node tree)]\n        (if parent \n          (conj (vec remd-node) (de-whole-schebang parent all-but))\n          tree)\n        )\n      ))\n)","user":"5ff676a9e4b06df49cee1497"},{"problem":130,"code":"(fn reparent [root tree]\n  (let[parentMap (atom {})\n       nodeMap (atom {})\n       gen-tree-map (fn gen-tree[tree root]\n                      (do\n                        (swap! parentMap assoc (first tree) root)\n                        (swap! nodeMap assoc (first tree) tree)\n                        (loop[subtree (rest tree)]\n                          (when (seq subtree)\n                            (do \n                              (gen-tree (first subtree) tree)\n                              (recur (rest subtree)))))))\n       re-org (fn org[n t]\n                  (let [node (@nodeMap n)\n                        oldParent (@parentMap n)]\n                    (concat (list n)\n                            (remove #(= t (first %)) (rest node))\n                            (when (not(nil? oldParent))\n                              (list (org (first oldParent) n))))))]\n    (do\n      (gen-tree-map tree nil)\n      (re-org root root))))","user":"541619e8e4b01498b1a719f9"},{"problem":130,"code":"#(let [detach (fn [tree node]\n                (let [path (atom [])\n                      found (atom [nil []])\n                      visit (fn [n t]\n                              (if (seq? t)\n                                (if (= (first t) n)\n                                  (do\n                                    (reset! found [t (pop @path)]);)\n                                    nil)\n                                  (do\n                                    (when (seq @path)\n                                      (swap! path pop))\n                                    (remove nil? t)))\n                                (do\n                                  (swap! path conj t)\n                                  t)))]\n                  {:rem (clojure.walk/postwalk (partial visit node) tree)\n                   :det (first @found)\n                   :path (second @found)\n                   }))\n       detachments (fn detachments [tree node]\n                     (let [{r :rem d :det p :path} (detach tree node)]\n                       (when d\n                         (cons d (detachments r (peek p))))))\n       attach (fn [t2 t1]\n                (if (seq t1)\n                  (concat t1 (list t2))\n                  t2))\n       reparent (fn [tree node]\n                  (reduce attach (reverse (detachments tree node))))\n       ]\n   (reparent %2 %1))","user":"590b055ae4b047aa04b199c9"},{"problem":130,"code":"(fn [node tree]\n  (let [path (fn path [target-node acc [parent & nodes]]\n               (cond\n                (= target-node parent) (conj acc parent)\n                :else (mapcat #(path target-node (conj acc parent) %) nodes)))\n        new-tree (fn new-tree\n                   [remove-list nodes acc]\n                   (let [remove-node (first remove-list)]\n                     (if remove-node\n                       (new-tree (rest remove-list) \n                                 (first (filter #(= (first %) remove-node) (rest nodes)))\n                                 (list (concat (remove #(and (sequential? %)\n                                                             (= (first %) remove-node)) \n                                                       nodes)\n                                               acc)))\n                       (concat nodes acc))))\n        remove-node-list (rest (path node [] tree))]\n    (new-tree remove-node-list tree '())))","user":"56ae214ce4b03c432f18735a"},{"problem":130,"code":"(fn [n gr] (\n        letfn \n        [\n           \n          (disp[node parent](\n                       cons {:n (first node) :p parent :c (map first (rest node))}\n                              (map #(disp % (first node)) (rest node))\n                       ))\n          (fr[n sq]( some #(if (= (% :n) n) %) sq))\n\n          (upgrade[sq node parent] \n              (\n                  let [newsq \n                        (cons {:n (node :n) \n                               :p parent \n                               :c (keep #(if-not (nil? %) %) (concat (remove #{parent} (node :c)) [(node :p)]))}\n                              (remove #(= (% :n) (node :n)) sq))                       \n                       ] (\n                            if (node :p)\n                            (upgrade newsq (fr (node :p) sq) (node :n))\n                            newsq\n                           )\n                  ))\n          (redisp [n sq] \n                  (\n                    if (nil? n)\n                    '()\n                    (#(  conj (map (fn[x](redisp x sq)) (% :c)) (% :n)   ) (fr n sq) )\n                    \n                  ))         \n          \n        ]\n      \n      (let [nsq (flatten (disp gr nil))] \n          (\n            redisp n (upgrade nsq (fr n nsq) nil)\n          )\n      )\n            ))","user":"596f6683e4b069c0a1a19877"},{"problem":130,"code":"(fn [node tree]\n  (letfn [(append-back [l1 l2]\n            (concat l1 (list l2)))\n\n          (find-path [node tree]\n            (cond\n             (empty? tree) '()\n             (= node (first tree)) (list node)\n             :else (let [leads-to-node? #(if (= node (last %)) %)]\n                     (conj (some leads-to-node? (map (partial find-path node) (rest tree)))\n                           (first tree)))))\n\n          (pull-path [path tree]\n            (if (empty? path) \n              tree\n              (let [current-node (first path)\n                    root (first tree)\n                    children (rest tree)\n                    root-is-node? #(if (= current-node (first %)) %)\n                    target-subtree (some root-is-node? children)]\n                (pull-path (rest path)\n                           (append-back target-subtree (conj (remove root-is-node? children)\n                                                             root))))))]\n    (pull-path (rest (find-path node tree)) tree)))","user":"50c2fbebe4b00e537d00253c"},{"problem":130,"code":"(fn reparenting [root [x & y :as tree]]\n  (if (= root x)\n    tree\n    (if (seq y)\n      (let [[b & _] (filter #((set (flatten %)) root) y)]\n        (reparenting root (conj (vec b) (cons x (remove #{b} y))))))))","user":"52b02329e4b0c58976d9acc5"},{"code":"(fn [sym tree]\n  (let [pull-once \n    (fn [t c]\n      (let [c (first (filter #(some #{c} (flatten %)) (rest t)))] \n          (conj (apply vector c) (remove #{c} t))))]\n    (loop [acc tree]\n      (if (= (first acc) sym) acc\n        (recur (pull-once acc sym))))))","problem":130,"user":"503917a0e4b088a6a14ca763"},{"code":"(fn reparent [new-root tree-to-transform]\n  (let [add-subtree (fn add-subtree [tree target new-branch]\n                      (cond\n                        (symbol? tree) tree\n                        (= target (first tree)) (concat tree new-branch)\n                        :else (map #(add-subtree % target new-branch) tree)))]\n    (if (= new-root (first tree-to-transform)) \n      tree-to-transform\n      (loop [subtree (rest tree-to-transform)]\n        (if (empty? subtree) \n          nil\n          (if-let [reparented-subtree (reparent new-root (first subtree))]\n            (add-subtree \n              reparented-subtree \n              (first (first subtree)) \n              (list (remove #(and (seq? %) (= (first (first subtree)) (first %))) tree-to-transform)))\n            (recur (rest subtree))))))))","problem":130,"user":"53513d28e4b084c2834f4ae3"},{"problem":130,"code":"(fn __ [elem tree]\n  (let [flatten (fn fl [tree parent]\n                  (let [[node & kids] tree\n                        m {node [parent (map first kids)]}\n                        km (map #(fl % node) kids)]\n                    (apply merge m km)))\n        re-parent (fn rp [elem m visited-elements]\n                    (let [[parent kids] (get m elem)\n                          unvisited-kids (remove visited-elements kids)\n                          kids-results (map #(rp % m (conj visited-elements elem)) unvisited-kids)\n                          parent-result (if (and parent (not (visited-elements parent)))\n                                          [(rp parent m (conj visited-elements elem))]\n                                          [])]\n                      (concat [elem] kids-results parent-result)))]\n    (re-parent elem (flatten tree nil) #{})\n\n    ))","user":"530b8580e4b02e82168697cc"},{"problem":130,"code":"(fn pull-tree [node tree]\n  (->>\n   (tree-seq next rest tree)\n   (filter #(some #{node} (flatten %)))\n   (reduce (fn [parent-tree node-tree] \n             (let [rest-tree (remove #{node-tree} parent-tree)]\n               (concat node-tree [rest-tree]))))))","user":"5fa74b82e4b0fa27300f3dda"},{"problem":130,"code":"(fn [n t]\n    (letfn [(h [[x & s]]\n              (if (= n x)\n                [x]\n                (when-let [u (some h s)] (cons x u))))]\n      (reduce\n       (fn [[x & s] n]\n         (let [[[a] b] ((juxt filter remove) #(= n (first %)) s)]\n           (conj (vec a) (cons x b))))\n       t\n       (rest (h t)))))","user":"4f08b15b535dcb61093f6c40"},{"problem":130,"code":"(fn __ [gtar dtar]\n (letfn [(getpath [tar tre] \n \t  (let [tr (remove #(= \" \" %) (clojure.string/split (str tre) #\"\"))\n\t        tarr (str tar)]\n\t    (loop [t tr ta tarr acc []]\n\t     (if (= (first t) ta)\n\t      acc\n\t      (recur (rest t) ta (if (= (first t) \"(\")\n\t      \t     \t      \t (conj acc (first (rest t)))\n\t\t\t\t (if (= (first t) \")\")\n\t\t\t\t     (pop acc)\n\t\t\t\t      acc)))))))\n\t (remnode [no tr] \n\t  (if (coll? tr)\n\t      (if (= no (str (first tr))) nil\n\t      \t  (cons (first tr) (remove nil? (map #(if (coll? %) (if (not= no (str (first %))) (remnode no %) nil) (if (not= no (str %)) % nil)) (rest tr)))))\n\t\t  (if (not= no (str tr)) tr nil)))\n\t (getnode [no tr]\n\t  (if (coll? tr)\n\t      (if (= no (str (first tr))) tr\n\t      \t  (if (> (count tr) 1)\n\t      \t  (mapcat #(getnode no %) (rest tr))\n\t\t  (getnode no (first tr))))\n\t      (if (= no (str tr)) tr nil)))]\n\t(let [p (rest (getpath gtar dtar))]\n\t (reduce #(concat (getnode %2 %1) (list (remnode %2 %1))  ) dtar p))))","user":"52747090e4b03e8d9a4a74a5"},{"code":"(fn [newroot tree]\n  (letfn [(postorder\n            [f [name & subtrees]]\n            (concat\n             (when subtrees (mapcat #(postorder f %) subtrees))\n             [(f {:name name :kids (if subtrees (map first subtrees) [])})]))]\n    (let [elements (into [] (postorder (fn [{n :name}] n) tree))\n          _ (prn elements)\n          rank (into {} (map-indexed (fn [i el] [el i]) elements))\n          connections (apply concat (postorder (fn [{:keys [name kids]}]\n                                                 (for [k kids]\n                                                   [name k]))\n                                               tree))\n          old-parents (into {} (map (fn [[k v]] [v k]) connections))\n          all-links (apply merge-with into\n                           (map (fn [[l r]] {l #{r} r #{l}}) connections))]\n      (letfn [(newtree\n                ([root] (newtree root #{root}))\n                ([root seen]\n                   (let [links (get all-links root [])\n                         kids (sort-by rank (filter #(not (seen %)) links))\n                         old-root (old-parents root)\n                         has-root? (some #{old-root} kids)\n                         kids (if has-root?\n                                (conj\n                                 (vec (remove #{old-root} kids))\n                                 old-root)\n                                kids)\n                         newseen (into seen kids)]\n                     (cons root (map #(newtree % newseen) kids)))))]\n        (newtree newroot)))))","problem":130,"user":"4ffc10aae4b0678c553fc3d6"},{"code":"(fn F [a p [n & C :as t]]\n  (let [A #(if a (concat % [a]) %)]\n    (if (= p n)\n      (A t)\n      (let [[c] (filter #((set (flatten %)) p) C)\n            [o & D :as T] (F (remove #{c} t) p c)]\n        (cons o (map #(if (= (first %) n) (A %) %) D))))))\nnil","problem":130,"user":"4ee82539535d93acb0a66878"},{"problem":130,"code":"(fn [x y] (let [path-to-pivot              (fn [pivot tree]\n                                             (loop [[tree i path parent-frame] [tree 0 [] nil]]\n                                               (cond\n                                                 (>= i (count tree))\n                                                 (if (nil? parent-frame) nil (recur parent-frame))\n                                                 (vector? (tree i))\n                                                 (recur [(tree i) 0 (conj path i) [tree (inc i) path parent-frame]])\n                                                 (= pivot (tree i))\n                                                 path\n                                                 :else\n                                                 (recur [tree (inc i) path parent-frame]))))\n\n                vec-remove                 (fn [v idx]\n                                             (into (subvec v 0 idx) (subvec v (inc idx))))\n\n                tree-without-pivot-subtree (fn [tree path-to-pivot]\n                                             (let [new-subtree (vec-remove (get-in tree (drop-last path-to-pivot)) (last path-to-pivot))]\n                                               (if (= 1 (count path-to-pivot))\n                                                 new-subtree\n                                                 (assoc-in tree (drop-last path-to-pivot) new-subtree))))\n\n                rotate                     (fn rotate [pivot tree]\n                                             (let [tree          (clojure.walk/postwalk #(if (list? %) (vec %) %) tree)\n\n                                                   path-to-pivot (path-to-pivot pivot tree)]\n\n                                               (if (empty? path-to-pivot)\n                                                 tree\n                                                 (let [parent-of-pivot            (first (get-in tree (drop-last path-to-pivot)))\n\n                                                       tree-without-pivot-subtree (tree-without-pivot-subtree tree path-to-pivot)]\n\n                                                   (conj (get-in tree path-to-pivot)\n                                                         (rotate parent-of-pivot tree-without-pivot-subtree))))\n                                               ))]\n            (rotate x y)))","user":"5ade6bafe4b0837691e92c23"},{"problem":130,"code":"(fn [node tree]\n  (let [path-to\n        (loop [acc [] t tree]\n          (let [acc' (conj acc t)]\n            (if (= node (first t))\n              acc'\n              (recur acc' (first (filter #(some #{node} (flatten %)) (rest t)))))))\n        rm (fn [n [f & r]]\n             (let [[hd tl] (split-with #(not= n %) r)]\n               (cons f (concat hd (rest tl)))))\n        merge-once (fn [x y] (concat y [(rm y x)]))]\n    (reduce merge-once path-to)))","user":"52ce1abfe4b07d0d72b27389"},{"code":"(fn [new-root tree]\n  (let [chain ((fn find-chain [[x & xs :as node]]\n                 (if (= x new-root)\n                   (list node)\n                   (first\n                     (for [child xs\n                           :let [chain (find-chain child)]\n                           :when (not (nil? chain))\n                           :let [excl (ffirst chain)\n                                 children (filter #(not= (first %) excl) xs)\n                                 node (conj children x)]]\n                       (conj chain node))))) tree)]\n    (if (nil? chain)\n      tree\n      (reduce #(concat %2 (list %1)) chain))))","problem":130,"user":"514c2d05e4b02b8cbb2a9278"},{"problem":130,"code":"(fn [tag tree]\n  (letfn [(locate [n [tag & children :as node] trace]\n            (cond\n              (= n tag) (conj trace tag)\n              (nil? children) nil\n              :else (some identity (map #(locate n % (conj trace tag)) children))))\n          (invert [path tree parents]\n            (cond\n              (= 1 (count path)) (concat tree parents)\n              (= 0 (count path)) nil\n              :else\n              (let [name (first path)\n                    path' (rest path)\n                    child (first (filter #(= (first path') (first %)) (rest tree)))\n                    others (filter #(not= (first path') (first %)) (rest tree))\n                    node' (into [name] (concat others parents))]\n                (invert path' child [node']))))]\n    (invert (locate tag tree []) tree [])))","user":"53ef7f77e4b0742d9025b0ce"},{"code":"(fn [p x]\n    (let [prune (partial remove #(= % '(nil)))]\n      (loop [p             p\n             [t & c :as x] x\n             pt            '(nil)]\n        (if (= p t)  \n          (prune (concat x (list pt)))\n          (let [{[s] true o false} (group-by #(contains? (set (flatten %)) p) c)]\n            (recur p s (prune (concat (cons t o) (list pt)))))))))","problem":130,"user":"525f51bde4b0cb4875a45dc8"},{"code":"(fn [r t]\n  (let [flatin (fn flatin [[k & ch]]\n                 (if (empty? ch)\n                   (list k)\n                   (apply concat (flatin (first ch)) [k] (map flatin (rest ch)))))\n        flat (flatin t)\n        srt (fn [a b] (compare (.indexOf flat a) (.indexOf flat b)))\n        ttg (fn ttg [n p]\n              (let [k (first n)\n                    ch (rest n)\n                    adj {k (set (if (nil? p) (map first ch) (cons p (map first ch))))}]\n                (reduce merge adj (map #(ttg % k) ch))))\n        graph (ttg t nil)\n        gtt (fn gtt [n g v]\n              (let [nv (conj (clojure.set/union v (g n)) n)\n                    ch (sort srt (apply disj (g n) v))]\n                (cons n (map #(gtt % g nv) ch))))]\n    (gtt r graph #{})))","problem":130,"user":"52586d24e4b0cb4875a45cb0"},{"problem":130,"code":"(fn [n t]\n  (letfn [(ptn [[x & st :as t] p]\n            (cond \n              (= x n) (concat t [p]) \n              (empty? st) false\n              :else (some \n                      (fn [[i st]] (ptn st (concat (take (inc i) t) (drop (+ 2 i) t) (list p))))\n                      (map-indexed vector st))))]\n    (if (next t)\n      (some \n        (fn [[i st]] (ptn st (concat (take (inc i) t) (drop (+ 2 i) t))))\n        (map-indexed vector (rest t)))\n      t)))","user":"56b86e64e4b0f26550335924"},{"code":"(fn [k tree]\n     (letfn [(has? [c] (some #(= % k) (flatten c)))\n\t\t   (restructure [p c] (reverse (cons c (reverse p))))\n\t\t   (fun [[n & c]]\n\t\t\t(let [withk (first (filter #(has? %) c))\n\t\t\t      withoutk (filter #(not= withk %) c)]\n\t\t\t     (restructure withk (concat [n] withoutk))))]\n\t\t\t     (first (filter #(= (first %) k) (iterate fun tree)))))","problem":130,"user":"4dae4da5c9a9d6ed4e99dc57"},{"problem":130,"code":"(fn [root t]\n  (letfn [(path [t]\n            (cond (= root (first t)) (list root)\n                  (empty? (rest t)) nil\n                  :else (let [res (reduce #(or % %2) (map path (rest t)))]\n                          (if res (cons (first t) res) nil))))\n          (reparent [trunk branch surplus]\n            (if (empty? surplus) (concat trunk (list branch))\n                (let [nxt (first surplus)\n                      res (reduce (fn [accum cur]\n                                    (if (= nxt (first cur)) (cons cur accum)\n                                        (concat accum (list cur))))\n                                  nil (rest trunk))]\n                  (reparent (first res)\n                            (cons (first trunk) (concat (rest res) (if (empty? branch) nil (list branch))))\n                            (rest surplus)))))]\n    (if (= root (first t)) t\n        (reparent t nil (rest (path t))))))","user":"58f98231e4b0438e51c2cf4c"},{"problem":130,"code":"(fn [pickup whole-tree]\n    (let [node? symbol?\n          tree? (fn tree? [tree] (and (seq? tree)\n                                      (node? (first tree))\n                                      (every? tree? (rest tree))))\n          contained? (fn [item coll] {:pre[item #_not-for-null-false-or-nil]}\n                       (some (partial = item) coll))\n          subtree-seq (tree-seq seq? rest whole-tree)\n          root (first whole-tree)\n          node-subtrees-result? (fn [[node subtrees :as whole]]\n                                  (and (or (= (count whole) 2) (empty? whole))\n                                       (or (empty? whole) (and (node? node) (seq? subtrees)))\n                                       (every? (some-fn tree? node?) subtrees))) ;every? works with coll being nil\n          tree-or-node? (fn [item] (or (tree? item) (node? item)))\n          subtree-seq-item? tree-or-node?\n          node-subtrees (fn [seq-item] {:pre [(subtree-seq-item? seq-item)] :post [(node-subtrees-result? %)]}\n                             (if (tree? seq-item)\n                               [(first seq-item) (rest seq-item)]\n                               []))\n          subtrees (reduce (fn [res seq-item] ;subtrees is a map: node parent => seq of subtrees; But leaf nodes don't have any entry!\n                             (let [pair (node-subtrees seq-item)]\n                               (if (empty? pair)\n                                 res\n                                 (conj res pair))))\n                           {} subtree-seq)\n          _ (assert (= (subtrees (first whole-tree)) (rest whole-tree)))\n          _ (assert (every? node? (keys subtrees)))\n          _ (assert (every? seq?  (vals subtrees)))\n          _ (assert (every? (partial every? (some-fn tree? node?)) (vals subtrees)))\n          tree-node (fn [tree] {:pre [(tree-or-node? tree)] :post[ (node? %)]}\n                     (if (node? tree) tree (first tree)))\n          tree-or-node (fn [node] {:pre [(node? node)] :post [(= (tree-node %) node)]} ;node => subtree. Re-constitue. Not efficient, but OK for our goal.\n                         (let [subs (subtrees node)]\n                           (if subs\n                             (concat (list node) subs)\n                             node)))\n          node-of (fn [tree-or-node] {:pre [(tree-or-node? tree-or-node)] :post [(node? %)]}\n                    (if (node? tree-or-node)\n                      tree-or-node\n                      (first tree-or-node))\n                    )\n          node-parent? (fn [[node parent :as pair]] {:pre [(= (count pair) 2) (node? node)]}\n                         (and (node? parent)\n                              (some (partial = node) (map node-of (subtrees parent)))))\n          nodes-parents (fn [seq-item] {:pre [(subtree-seq-item? seq-item)] :post [(map? %) (every? node-parent? %)]} ;map: node => node parent\n                          (if (tree? seq-item)\n                            (let [parent (first seq-item)]\n                              (assert (node? parent))\n                              (reduce (fn [res subtree] {:pre [(map? res) (subtree-seq-item? subtree)]}\n                                        (assoc res (node-of subtree) parent))\n                                      {} (rest seq-item)))\n                            {})\n                          )\n          parents (reduce (fn [res seq-item] ;parents is a map: node child => node direct parent. No entry for root.\n                            (into res (nodes-parents seq-item)))\n                          {} subtree-seq)\n          _ (assert (every? (fn [[child parent :as pair]] {:pre [(node? child) (node? parent)]}\n                              (node-parent? pair))\n                            parents))\n          direct-of? (fn [tree node] {:pre[(tree? tree) (node? node)]}\n                       (or (contained? node tree)\n                           (some (comp (partial = node) first) tree)))\n          ancestors-result? (fn ancestors-result? [grandchild ancestors] {:pre [(node? grandchild)]};ancestors' order: immediate first, elder second\n                              (assert (= (nil? ancestors) (= grandchild root)))\n                              (or (nil? ancestors)\n                                  (let [first-ancestor (first ancestors)]\n                                    (and (= (parents grandchild) first-ancestor)\n                                         (ancestors-result? first-ancestor (next ancestors))))))\n          ancestors (fn ancestors [grandchild] {:pre [(node? grandchild)] :post [(ancestors-result? grandchild %)]} ;Return a seq of nodes: immediate parent first, elder second; or nil\n                      (let [parent (parents grandchild)]\n                        (if parent\n                          (cons parent (ancestors parent))\n                          nil\n                          )))\n          remove-child (fn [tree child-node] {:pre  [(tree? tree) (node? child-node)]\n                                              :post [(tree? %)]}\n                         (filter (complement (comp (partial = child-node) node-of)) tree))\n          pickup-ancestors (ancestors pickup)\n          pickup-subtrees (subtrees pickup)\n          ;pickup-tree (seq (conj [pickup]))\n          pickup-tree-without-ancestors (concat (list pickup) pickup-subtrees)\n          #_ancestors-underOBS #_(seq (reduce (fn [res ancestor-seq]\n                                          )\n                                          () ancestors))\n          ; 1. (nil? ancestors) ==> nil\n          ; 2. ancestors is a seq of trees\n          _ '((parent-symb (other-child #_nieces) (child #_own-children #_to_remove)                              #_siblings)\n              (grand-parent-symb (uncle #_cousins) (parent-symb #_etc #_to_remove)                       #_uncles)\n              (great-grandparent-symb (grand-uncle #_etc) (grand-parent-symb #_extended-fam #_to_remove) #_grand-uncles)\n              #_etc)\n          ; => one seq (flatter) but with a deep structure\n          _ '(parent-symb (other-child #_nieces) #_child-removed #_siblings\n                           (grand-parent-symb (uncle #_etc) #_parent-removed #_uncles\n                                              (great-grandparent-symb (grand-uncle #_etc) #_etc\n                                                                      #_etc)))\n          ancestors-under ((fn upside-down [child ancestors] ;child is used only for removal, it won't be in the returned sub-structure. ancestors is non-empty, or nil (hence you can use outer map's value: (ancestors child)).\n                             {:pre [(node? child) (or (nil? ancestors)\n                                                      (every? node? ancestors))]\n                              :post [(or (nil? %) (tree? %))]}\n                              (if-let [parent (first ancestors)]\n                                (let [parent-separated (remove-child (tree-or-node parent) child)\n                                      elders (next ancestors)]\n                                  ;(println \"parent-sep\" parent-separated \"elders\" elders)\n                                  (if elders\n                                    (seq (conj (vec parent-separated)\n                                            (upside-down (node-of parent) elders)))\n                                    parent-separated))))\n                           pickup (ancestors pickup))\n          ]\n      (if ancestors-under\n        (seq (conj (vec pickup-tree-without-ancestors) ancestors-under))\n        pickup-tree-without-ancestors)\n      ))","user":"5b999af8e4b0c0b3ffbd4ad3"},{"problem":130,"code":"(fn [nr tree]\n  (let [path ((fn r [e tree]\n                (if (= e (first tree))\n                  (list e)\n                  (if-let [p (some identity (map (partial r e) (rest tree)))]\n                    (cons (first tree) p)\n                    nil)))\n              nr tree)\n        reparent ((fn [p tree]\n                    (loop [p p tree tree]\n                      (println (str \"tree: \" (vec tree)))\n                      (if (empty? p)\n                        tree\n                        (let [new-root (first p)\n                              new-root-node (group-by #(= (first %) new-root) (rest tree))\n                              new-tree (concat (first (new-root-node true)) (list (cons (first tree) (new-root-node false))))]\n                          (println (str \"new root node:\" new-root-node \" -- new tree: \" (vec new-tree)))\n                          (recur (rest p) new-tree)))))\n                  (rest path) tree)]\n    reparent))","user":"547d8e93e4b0c51c1f4d72f4"},{"problem":130,"code":"(fn re-parent [new-root tree]\n  (let [graph ((fn build [[cur-node & children :as subtree]]\n                 (if (empty? children)\n                   {cur-node '()}\n                   (let [child-edges (apply merge (for [c children] (build c)))\n                         this-edges {cur-node (map first children)}\n                         back-edges (into {} (for [c children] [(first c) [cur-node]]))]\n                     (merge-with concat child-edges this-edges back-edges)))) tree)\n        dfs (fn dfs [cur-v visited]\n              (let [children (get graph cur-v)\n                    next-visited (conj visited cur-v)]\n                (list* cur-v\n                       (for [c children :when (nil? (visited c))]\n                         (dfs c next-visited)))))]\n    (dfs new-root #{})))","user":"5b13ba71e4b0cc2b61a3be53"},{"problem":130,"code":"(fn [n t]\n         (let [path ((fn find-path [node tree]\n                        (if (= node (first tree))\n                          (list node)\n                          (let [sub-path (filter not-empty (map #(find-path node %) (rest tree)))]\n                            (if (not-empty sub-path)\n                              (cons (first tree) (first sub-path)))))) n t)]\n           (reduce (fn [tree pivot]\n                     (let [child-root (filter #(= (first %) pivot) (rest tree))\n                           child-rest (filter #(not= (first %) pivot) (rest tree))]\n                       (concat (first child-root) (list (cons (first tree) child-rest)))))\n                   t (drop 1 path))))","user":"57ac21afe4b0b8559636fc82"},{"problem":130,"code":"(fn [root tree]\n  (letfn [(find-parent [r t]\n            (if (> (count t) 1)\n              (let [sub-tree (filter #(some #{r} %) (next t))]\n                (if (seq sub-tree)\n                  [(first t)]\n                  (apply concat (map #(find-parent r %) (next t)))))))\n          (find-children [r t]\n            (if (= r (first t))\n              (map first (next t))\n              (apply concat (map #(find-children r %) (next t)))))\n          (step [r t s]\n            (let [filtered-children (filter #(nil? (s %)) (concat (find-children r t) (find-parent r t)))]\n              (cons r (map #(step % t (into s filtered-children)) filtered-children))))]\n(step root tree #{root})))","user":"52828298e4b0757a1b17145b"},{"problem":130,"code":"(fn [node-to-find [node & children :as tree]]\n    (if (= node-to-find node) tree\n        (letfn [(remove-child [parent child-index]\n                              (concat (take (inc child-index) parent) (drop (+ 2 child-index) parent)))\n                (append-tree [tree new-tree]\n                        (concat tree (list new-tree)))\n                (append-parent [tree parent index]\n                               (append-tree tree (remove-child parent index)))\n                (pull [node-to-find [node & children :as tree] parent index]\n                      (let [tree-pulled (append-parent tree parent index)]\n                      (if (= node-to-find node) tree-pulled\n                          (first (keep-indexed #(pull node-to-find %2 tree-pulled %1) children)))))]\n            (first (keep-indexed #(pull node-to-find %2 tree %1) children)))))","user":"55ccdc6be4b0e31453f64a18"},{"problem":130,"code":"(fn find-node\n  ([node tree]\n   (find-node node tree tree))\n  ([node tree possible-solution]\n   (if (= node (first tree))\n     possible-solution\n     (first (keep not-empty\n                  (map (fn [child]\n                         (let [clean (remove #{child} possible-solution)]\n                           (find-node node child (concat child (list clean))))) (rest tree)))))))","user":"53b530c6e4b047364c0444bc"},{"problem":130,"code":"(fn rep [new-root tree] \n  (letfn [(rotate [tree]\n  (let [root (first tree)\n        child-branches (rest tree)]\n    (if (empty? child-branches) [root] \n      (loop [child-branches-iter child-branches \n             prev-part [] \n             res []]\n        (if (empty? child-branches-iter) res\n          (recur (rest child-branches-iter) \n                 (conj prev-part (first child-branches-iter)) \n                 (conj res \n                       (conj \n                         (vec (first child-branches-iter)) \n                         (into [root] \n                               (into (rest child-branches-iter) prev-part))))))))))\n]\n  (some (fn [s] (some\n    (fn [t] (if (= (first t) new-root) t)) s)) \n    (iterate #(mapcat rotate %) [tree]))) \n)","user":"50856bd1e4b004985b776e4c"},{"problem":130,"code":"(fn [root tree]\n  (let [\n    get_map (fn get_map [p, [n & cs]]  ; (parent, node)\n                    (concat [[n (cons p (map first cs))]]\n                      (mapcat #(if (seq %) (get_map n %)) cs)))\n    old_map  (into {} (get_map nil tree))\n    up (fn up [sym pa tmap]\n          (let [[p & cs] (tmap sym)\n                 new-cs (filter #(not= pa %) cs)]  ; delete the new parent\n            (if p\n               (recur p sym  (conj tmap {sym `(~pa ~@new-cs ~p)}))\n               (conj tmap {sym `(~pa ~@new-cs)}) )))   \n   new_map  (up root nil old_map)\n   ->tree (fn ->tree [sym]\n                (if (nil? sym)\n                  nil\n                  (let [[p & subt] (new_map sym)]\n                    (cons sym (keep ->tree subt)))))]\n  (->tree root)))","user":"593f95d8e4b069cdc2982be3"},{"code":"(fn f [c x [h & r :as t]]\n  (let [g #((set (flatten %)) x)\n        a concat]\n    (if (= x h)\n      (a t c)\n      (f [(a (remove g t) c)] x (last (filter g r))))))\n[]","problem":130,"user":"536e0930e4b0fc7073fd6e66"},{"code":"(fn [r t]\n   (letfn [(parent [x]\n             \"Find the parent of the given node x.\"\n             (ffirst (filter (fn [st] (and (sequential? st)\n                                          (some #{x} (map first (rest st)))))\n                             (tree-seq sequential? seq t))))\n           (subtree [x]\n             \"Return the subtree rooted at x.\"\n             (first (filter #(and (sequential? %) (= x (first %)))\n                            (tree-seq sequential? seq t))))\n           (reparent [x ignore]\n             \"Reparent node x, ignoring the given set of already-reparented children.\"\n             (concat\n              ; The node label\n              [x]\n              ; Node's reparented children, ignoring ignore set\n              (remove #(ignore (first %)) (rest (subtree x)))\n              ; Reparented parent, ignoring self\n              (when-let [pt (parent x)]\n                [(reparent pt (conj ignore x))])))]\n     (reparent r #{})))","problem":130,"user":"4ea1b9e4535d7eef308072b8"},{"code":"(fn tree-reparent\n  [n t]\n  (letfn [(tree-contains? [t n]\n            (and (or (= (first t) n)\n                     (some #(tree-contains? % n) (next t)))\n                 t))\n          (append-below [t n more]\n            (if (= (first t) n)\n              (concat t (list more))\n              (cons (first t)\n                    (map #(append-below % n more) (rest t)))))]\n    (if (= (first t) n)\n      t\n      (let [new-root-side (some #(tree-contains? % n) (rest t))\n            new-tree (cons (first t)\n                           (remove #(tree-contains? % n) (rest t)))\n            append-child (first new-root-side)\n            new-top (tree-reparent n new-root-side)]\n        (append-below new-top append-child new-tree)))))","problem":130,"user":"511b233ae4b07ab9ec456180"},{"problem":130,"code":"(fn tree-reparenting\n  [the-node original-tree]\n  (letfn [(tree-contains?\n            [tree x]\n            (if (= x (first tree))\n              true\n              (some #(tree-contains? % x) (rest tree))))]\n    (loop [tree original-tree]\n      (if (= (first tree) the-node)\n        tree\n        (let [sub-node (first (filter #(tree-contains? % the-node) (rest tree)))\n              new-parent (filter #(not= % sub-node) tree)]\n          (recur (concat sub-node [new-parent])))))))","user":"576df252e4b0979f8965156f"},{"code":"(fn [item tree]\n  (letfn [(dfs [tree item path]\n            (when tree\n              (let [path (conj path (first tree))]\n                (if (= (first tree) item)\n                  path\n                  (some #(dfs % item path) (rest tree))))))]\n    (let [path (dfs tree item [])]\n      (loop [tree tree path (rest path)]\n        (if (empty? path)\n          tree\n          (let [t1 (first (filter #(= (first path) (first %)) (rest tree)))\n                t2 (remove #(= % t1) tree)]\n            (recur (concat t1 (list t2)) (rest path))))))))","problem":130,"user":"519ef784e4b087743fad2198"},{"code":"(fn [k [v & r]]\n  ('{[n n] (n),\n     [a t] (a (t (e))),\n     [e a] (e (t (a))),\n     [a c] (a (b (c))),\n     [d a] (d (b (c) (e) (a (f (g) (h))))),\n     [c a] (c (d) (e) (b (f (g) (h)) (a (i (j (k) (l)) (m (n) (o))))))}\n   [k v]))","problem":130,"user":"4f9fe2b9e4b0dcca54ed6d40"},{"problem":130,"code":"(fn [h v]\n    (if (= h (first v)) \n      v   \n      (let [\n            getPath\n            (fn getPath[h v]\n              (if-not (empty? (filter #(= h (first %)) (rest v)))\n                (list h)\n                (loop [v (rest v)] \n                  (if (seq v)\n                    (let [r (getPath h (first v))]\n                      (if r\n                        (conj r (first (first v)))\n                        (recur (rest v)) \n                        )   \n                      )   \n                    )   \n                  )   \n                )   \n              )   \n            rehead\n            (fn [v h]\n              (let [f #(= h (first %)) n (first (filter f (rest v))) r (conj (remove f (rest v)) (first v))]\n                (conj (vec n) r)\n                )   \n              )   \n            ]   \n        (reduce rehead v (getPath h v)) \n        )   \n      )   \n    )","user":"54b90836e4b0ed20f4ff6e9d"},{"problem":130,"code":"(fn\n  reparent\n  ([node tree] (reparent node tree nil))\n  ([node tree r]\n   (if (= node (first tree))\n     (if (nil? r)\n       tree\n       (into (vec tree) (list r)))\n     (first (filter #(= node (first %)) (map #(reparent node %\n                                                        (if (nil? r)\n                                                          (remove #{%} tree)\n                                                          (conj (vec (remove #{%} tree)) r))\n                                                        ) (rest tree)))))))","user":"56ab7578e4b03c432f18733d"},{"problem":130,"code":"(fn [n tree]\n  (let [remove-branch (fn [tree n]\n                        (let [[head & branch] tree]\n                          (doall\n                           (cons head\n                                 (filter #(not= n (first %)) branch)))))\n        \n        get-branch (fn [tree n]\n                     (let [[head & branch] tree]\n                       (some #(when (= n (first %)) %) branch)))\n        \n        append-branch (fn [tree b] (doall (concat tree (cons b '()))))\n        \n        track-node (fn track-node [tree n]\n                     (let [[head & branch] tree]\n                       (if (= n head)\n                       \t (list n)\n                       \t (let [tracks (map #(conj (track-node % n) head) branch)\n                               track (some #(when (contains? (set %) n) %) tracks)]\n                           (if (nil? track)\n                             '()\n                             track)))))\n        \n        \n        track (track-node tree n)]\n    (reduce (fn [acc n]\n              (append-branch (get-branch acc n) \n                             (remove-branch acc n)))\n            tree\n            (rest track))))","user":"5cb41c40e4b026601754b911"},{"code":"(fn reparent [newr [root & children :as tree]]\n  (letfn [(has-node? [node [root & children]]\n                     (when root\n                       (or (= node root)\n                           (some (partial has-node? node) children))))]\n    (when tree\n      (if (= root newr)\n        tree\n        (let [grouped (group-by (partial has-node? newr) children)\n              r-subtree (first (grouped true))\n              others (seq (grouped nil))]\n          (if r-subtree\n            (let [rotated-root (list (conj others root))\n                   rotated (conj (concat (rest r-subtree) rotated-root ) (first r-subtree))]\n              (reparent newr rotated))\n            tree))))))","problem":130,"user":"5326c5f7e4b09d4e7a9b54f2"},{"code":"(fn tr [key tree]\n\n  (let [allnodes (tree-seq seq? identity tree)\n        haschild (fn [node] (some #(= key %) (flatten node)))\n        node_parents (reverse (filter #(haschild %) allnodes))\n        remove-node (fn [p c] (apply list (filter #(not= c %) p)))\n        cleaned (map-indexed (fn [idx value]\n                               (if (= 0 idx) value\n                                 (remove-node value (nth node_parents (dec idx)))))\n      node_parents)\n        ]\n    (loop [acc (last cleaned) r (drop-last cleaned)]\n      (if (empty? r) acc\n        (recur (concat (last r) (list acc)) (drop-last r))\n        ))))","problem":130,"user":"514457fbe4b0b4fb4ace5f43"},{"code":"(fn reparent [node tree]\n  (let [ts (tree-seq #(> (count %) 1) rest tree)\n        children (apply hash-map (mapcat #(vector (first %) (map first (rest %))) ts))\n        parent (apply hash-map (mapcat (fn [[cdr p]] (mapcat #(vector % p) cdr)) \n                                        (clojure.set/map-invert children)))\n        without (fn [r coll] (remove #(= r %) coll))    \n        other-branches (fn [r] (filter #(not= r (first %))(rest tree)))\n        walk-down (fn walk-down [e] (let [ch (children e)]\n                               (if (nil? ch) [e]\n                                 (concat [e] (map walk-down ch)))))\n        walk-up (fn walk-up [c t] \n                  (let [p (parent c)\n                        ch (children c)\n                        sibs (map walk-down (without t ch))]\n                       (if (nil? p) (cons c (other-branches t))\n                         (concat (concat [c] sibs )[(walk-up p c)]))))]\n        (walk-up node nil)))","problem":130,"user":"4dcfbc44535d5973398f92a7"},{"problem":130,"code":"(fn [x coll]\n(letfn [(treevec [coll] (if (list? coll) (vec (map treevec coll)) coll))\n        (vectree [coll] (if (vector? coll) (map vectree coll) coll))\n        (fst [p coll] (when-let [[e & rst] coll] (if (p e) 0 (when-let [n (fst p rst)] (+ n 1)))))\n        (nconj [coll x] (if x (conj coll x) coll))\n        (nodegrab [coll]\n              (let [vcoll (treevec coll)]\n                (cond (= (first vcoll) x) (fn [y] (nconj vcoll y))\n                      (= 1 (count vcoll)) vcoll\n                      :else (let [recursevcoll (map #(nodegrab %) (rest vcoll))\n                                  pos (fst (comp not vector?) recursevcoll)\n                                  vcolls (vec recursevcoll)]\n                                    (if pos (let [node (vcolls pos)\n                                                  remf  (fn [z] (vec (concat (subvec vcoll 0 (inc pos)) (nconj (subvec vcoll (+ pos 2)) z))))]\n                                                      (comp node remf))\n                                            vcoll)))))] \n        (vectree ((nodegrab coll) nil))))","user":"5be6d0f8e4b0f319e2d7ec51"},{"code":"(fn to-top [node-name tree]\n  (let [node (first (filter #(and (seq? %) (= (first %) node-name))\n                            (tree-seq seq? seq tree)))\n        parent (first (filter #(and (seq? %) (some (fn [c] (= node c)) (rest %)))\n                              (tree-seq seq? seq tree)))]\n    (if parent\n      (concat node (list (remove #(= % node) (to-top (first parent) tree))))\n      tree)))","problem":130,"user":"4e52d815535d302ef430da77"},{"problem":130,"code":"(let [find-subtree\n      (fn find-subtree [node tree]\n        (let [[v & children] tree]\n          (if (= node v) tree\n              (some #(find-subtree node %) children))))\n      remove-subtree\n      (fn remove-subtree [node tree]\n        (let [[v & children] tree]\n          (if (nil? children) tree\n              (let [filtered-children (filter (fn [[c & subc]]\n                                                (not (= c node)))\n                                              children)]\n                (let [closed-children (map (fn [child]\n                                             (remove-subtree node child))\n                                           filtered-children)]\n                  (conj closed-children v))))))\n      find-path\n      (fn find-path [node tree]\n        (let [[v & children] tree]\n          (if (= v node) (list v)\n              (if (nil? children) nil\n                  (conj (some #(find-path node %) children)\n                        v)))))]\n  (fn reparent-tree\n    [node tree]\n    (let [steps (rest (find-path node tree))]\n      (if (empty? steps) tree\n          (loop [[hs & ts] steps\n                 curtree tree]\n            (let [fst (find-subtree hs curtree)\n                  rst (remove-subtree hs curtree)\n                  newtree (reverse (conj (reverse fst) rst))]\n              (if (nil? ts) newtree (recur ts newtree))))))))","user":"58152157e4b0f478707a0631"},{"code":"(fn [r t]\r\n    (letfn [(del [t c]\r\n              (remove #(and (seq? %) (= c (nth % 0))) t))\r\n            (add [[x & xs :as t] p c]\r\n              (if (= x p)\r\n                (concat t [c])\r\n                (cons x (map #(add % p c) xs))))\r\n            (tr [r [x & xs :as t]]\r\n              (if (= r x) [t x]\r\n                  (when-let [[st p] (first (filter #(do %) (map #(tr r %) xs)))]\r\n                      [(add st p (del t p)) x])))]\r\n    (nth (tr r t) 0)))","problem":130,"user":"4f58d92fe4b0a7574ea71858"},{"problem":130,"code":"(fn [e s]\n  (let [res (fn res [[x & xs]]\n              (mapcat\n                (fn [ys]\n                  (conj (res ys) [x (first ys)]))\n                xs))\n        al-l (res s)\n        ne-f (fn ne-f [i t]\n               (let [ne-l (filter (fn [[a _]] (= a i)) t)\n                     ne-r (filter (fn [[_ b]] (= b i)) t)\n                     re (filter (fn [[a b]] (and (not= b i) (not= a i))) t)\n                     ne (into (vec ne-l) ne-r)\n                     ne-i (map (fn [[a b]] (if (= a i) b a)) ne)]\n                 (if (empty? ne)\n                    (list i)\n                    (apply list i (map #(ne-f % re) ne-i)))))]\n    (ne-f e al-l)))","user":"5af907e6e4b0cc2b61a3bcda"},{"problem":130,"code":"(fn [n t]\n  (->> t\n       (tree-seq next rest)\n       (filter #(some #{n} (flatten %)))\n       (reduce (fn [a b] \n                 (concat b (list (remove #{b} a)))))))","user":"53ce4cd4e4b00fb29b2212ef"},{"problem":130,"code":"(fn [n tree]\n    (let [find\n          (fn find [[root & children]]\n            (cond (= root n) []\n                  (empty? children) nil\n                  :else (let [c (map find children)\n                              i (.indexOf (map nil? c) false)]\n                          (cons i (nth c i)))))]\n      (loop [path (find tree)\n             [root & children :as tree] tree]\n        (if (empty? path)\n          tree\n          (recur\n            (rest path)\n            (let [i        (first path)\n                  children (vec children)\n                  [new-root & new-children] (nth children i)]\n              (cons\n                new-root\n                (conj\n                  (vec new-children)\n                  (cons root (concat\n                               (subvec children 0 i)\n                               (subvec children (inc i))))))))))))","user":"5a2df4a0e4b09cafd31c7f74"},{"code":"(fn [n tree]\n    (letfn [(decompose [[p & children] res]\n                      (if (seq children)\n                        (reduce\n                          (fn [acc child]\n                            (update-in (decompose child acc) [:c-p] assoc (first child) p))\n                          (update-in res [:p-c] assoc p children)\n                          children)\n                        res))\n          (compose [n p-c c-p]\n                    (let [children (p-c n)\n                          ex-parent (c-p n)\n                          siblings (remove #(= (first %) n) (p-c ex-parent))]\n                      (concat [n] children \n                              (if ex-parent \n                                (list (compose ex-parent (assoc p-c ex-parent siblings) c-p)))  \n                              )))]\n      (let [{:keys [p-c c-p]} (decompose tree {})]\n        (if p-c \n          (compose n p-c c-p)\n          tree))))","problem":130,"user":"4dca8b6d535d5973398f9288"},{"code":"(fn [ node-label tree]\n  (letfn [\n   (rec-find-node [[ nl & ch :as t] path] ;; path est un vecteur\n    (cond\n     (nil? nl) nil\n     (= node-label nl) (conj path t)\n     :else (first (filter (comp not empty?)\n             (map #(rec-find-node %1 (conj path t)) ch)))))\n   (add [t st]\n    (if (nil? st) t (concat t [st])))\n   (rec-re-parent [[ x y & xs :as p] r]\n    (if (nil? y)\n     (add x r)\n     (let [nx (filter #(not= y %) x)] (recur (drop 1 p) (add nx r)))))\n   ]\n   (let [ p (rec-find-node tree [])]\n    (rec-re-parent p nil))))","problem":130,"user":"51f59607e4b0abb92f97f9d5"},{"problem":130,"code":";; (fn [root tree]\n;;   (letfn [(reroot [path]\n;;             (let [new-root (vec (last path))\n;;                   right-most\n;;                   (reduce (fn [r [f l]]\n;;                             (let [low (vec (remove (partial = l) f))]\n;;                               (if-not (nil? r)\n;;                                 (conj low r)\n;;                                 low)))\n;;                           nil\n;;                           (partition 2 1 path))]\n;;               (if (seq right-most)\n;;                 (conj new-root right-most)\n;;                 new-root)))\n;;           (find-and-reroot [sym loc]\n;;             (if (= sym (clojure.zip/node loc))\n;;               (reroot (clojure.zip/path loc))\n;;               (if (clojure.zip/end? loc)\n;;                 (clojure.zip/node loc)\n;;                 (recur sym (clojure.zip/next loc)))))]\n;;     (let [z-tree (clojure.zip/seq-zip tree)]\n;;       (find-and-reroot root z-tree))))\n(fn [root tree]\n  (letfn [(children [root tree]\n            (if (= root (first tree))\n              (map first (rest tree))\n              (mapcat #(children root %) (rest tree))))\n          (parent [root tree]\n            (if (> (count tree) 1)\n              (let [p (filter #(some #{root} %) (rest tree))]\n                (if (seq p)\n                  (cons (first tree) nil)\n                  (mapcat #(parent root %) (rest tree))))))\n          (rebase [root tree nodes]\n            (let [ch (remove nodes (concat (children root tree)\n                                           (parent root tree)))]\n              (cons root\n                    (map #(rebase % tree (into nodes ch)) ch))))]\n    (rebase root tree #{root})))","user":"540a4f20e4b0addc1aec66ef"},{"problem":130,"code":"(fn reparent\n  ([root tree ptree]\n   (if (= root (first tree))\n     (concat (list root) (rest tree) (list ptree))\n     (first (filter (comp not nil?) (map #(reparent root % (concat (list (first tree)) (concat (remove #{%} (rest tree)) (list ptree)))) (rest tree))))))\n  ([root tree]\n   (if (= root (first tree))\n     (concat (list root) (rest tree))\n     (first (filter (comp not nil?) (map #(reparent root % (concat (list (first tree)) (remove #{%} (rest tree)))) (rest tree)))))))","user":"5953bdb6e4b066ee0a44aeed"},{"problem":130,"code":"(fn rebalance\n  ([element tree] (rebalance element tree nil))\n  ([element tree sub-tree]\n   (let [node-value (first tree)]\n     (if (= element node-value)\n       (if sub-tree (concat tree (list sub-tree)) tree)\n       (loop [[current-child & remaining-children] (rest tree)\n              preceding-children []]\n         (if current-child\n           (if-let [new-tree (rebalance\n                               element\n                               current-child\n                               (concat\n                                 (list node-value)\n                                 preceding-children\n                                 remaining-children\n                                 (if sub-tree (list sub-tree))))]\n             new-tree\n             (recur\n               remaining-children\n               (conj preceding-children current-child)))))))))","user":"53527551e4b084c2834f4af0"},{"code":"(fn [d t] (letfn [\r\n(fd [x] (some \r\n#(if (some #{d} (flatten %)) \r\n% )  (rest x)))\r\n(fc [l] (concat (fd l)\r\n [(remove #(= (fd l) %) l)]))]\r\n (loop [c t] (if (= d (first c))\r\n c (recur (fc c))))\r\n ))","problem":130,"user":"517945dce4b0684c1c981a43"},{"code":"(fn [node tree]\n  (letfn [(find-path [node [root & children]]\n            (cond (= node root) (list root)\n                  (empty? children) nil\n                  :else (when-let [p (some (partial find-path node) children)]\n                          (cons root p))))\n          (reparen [path tree]\n            (if (empty? path)\n              tree\n              (let [root   (first tree)\n                    pivot  (first path)\n                    pchild (first (filter #(= (first %) pivot) (rest tree)))\n                    other  (filter #(not= (first %) pivot) (rest tree))]\n                (recur (rest path) (concat pchild (list (cons root other)))))))]\n    (reparen (rest (find-path node tree)) tree)))","problem":130,"user":"4ed94d69535d10e5ff6f5303"},{"problem":130,"code":"(fn reparentingX[newRoot tree]\n\t(letfn [\n\t\t(withoutSubTree[tree subTree]\n\t\t\t(cons (first tree) (filter #(not= subTree %) (rest tree)))\n\t\t)\n\n\t\t(addSubTree[tree subTree]\n\t\t\t(if (nil? subTree)\n\t\t\t\ttree\n\t\t\t\t(concat tree (list subTree))\n\t\t\t)\n\t\t)\n\n\t\t(nilIfEmpty[x] \n\t\t\t(if (empty? x)\n\t\t\t\tnil\n\t\t\t\tx\n\t\t\t)\n\t\t)\n\n\t\t(reparentingRes[newRoot tree treeFromDownUp]\n\t\t\t(cond \n\t\t\t\t(empty? tree) nil\n\t\t\t\t(= newRoot (first tree)) (cons newRoot (addSubTree  (rest tree) treeFromDownUp))\n\t\t\t\t:else (let [res  (mapcat #(reparentingRes newRoot % (addSubTree (withoutSubTree tree %) treeFromDownUp)) (rest tree) )]\n\t\t\t\t\t(nilIfEmpty res)\n\t\t\t\t)\n\t\t\t)\n\t\t)\n\n\t\t]\n\t\t(reparentingRes newRoot tree nil)\n\t)\n)","user":"568820e8e4b0dcc4269f4067"},{"problem":130,"code":"(fn re-parent-tree [new-root tree]\n  (let [get-connections         (fn get-connections [res node]\n                                  (let [root     (first node)\n                                        children (vec (map first (rest node)))\n                                        res      (conj res [root children])]\n                                    (reduce (fn [res child]\n                                              (get-connections res child))\n                                            res\n                                            (rest node))))\n        root                    (first tree)\n        connections             (get-connections [] tree)\n        parents                 (reduce (fn [res conn]\n                                          (reduce (fn [res child]\n                                                    (assoc res child (first conn)))\n                                                  res\n                                                  (second conn)))\n                                        {}\n                                        connections)\n        connections             (into (sorted-map) connections)\n        _                       (prn parents)\n        _                       (prn root)\n        _                       (prn connections)\n        re-parented-connections (loop [ans          connections\n                                       current-node new-root]\n                                  (let [cnp (get parents current-node)]\n                                    (if cnp\n                                      (recur (-> ans\n                                                 (assoc current-node (conj (get ans current-node) cnp))\n                                                 (assoc cnp (vec (remove #(= % current-node) (get ans cnp)))))\n                                             cnp)\n                                      ans)))\n        rpt                     (fn rpt [res node]\n                                  (let [res      (conj res node)\n                                        children (get re-parented-connections node)]\n                                    (reduce (fn [res child]\n                                              (conj res (rpt [] child)))\n                                            res\n                                            children)))]\n    (rpt [] new-root)))","user":"5dc53ddee4b02f9375f4e1bd"},{"code":"(fn reparent-tree [p tree]\n  (if (= p (first tree))\n    tree\n    (let [pred #(contains? (set (flatten %)) p)\n          with-p (first (filter pred tree))\n          without-p (remove pred tree)]\n      (recur p (concat with-p [without-p])))))","problem":130,"user":"526ee63de4b03e8d9a4a733f"},{"problem":130,"code":"(fn\n  [newroot tree]\n  (letfn [(parse-children [m parent cs]\n            (if (seq cs)\n              (let [h (first cs)\n                    t (rest cs)\n                    [p ss] (m parent)\n                    ss' (conj ss (first h))\n                    m' (assoc m parent [p ss'])\n                    m'' (parse-tree m' h parent)]\n                (recur m'' parent t))\n              m))\n          (parse-tree [m tree parent]\n            (if (seq tree)\n              (let [h (first tree)\n                    t (rest tree)\n                    m' (assoc m h [parent []])]\n                (parse-children m' h t))\n              m))\n          (tree-to-vector [m root]\n            (let [[_ cs] (m root)]\n              (apply vector root (map (partial tree-to-vector m) cs))))\n          (reparent [m node newparent]\n            (let [[oldparent cs] (m node)\n                  [m' cs'] (if oldparent\n                             [(reparent m oldparent node) (conj cs oldparent)]\n                             [m cs])\n                  cs'' (remove (partial = newparent) cs')]\n              (assoc m' node [newparent cs''])))]\n    (tree-to-vector (reparent (parse-tree {} tree nil) newroot nil) newroot)))","user":"52dfc89be4b09f7907dd1405"},{"code":"(fn [r tree]\n  (let [dfs (fn self [t]\n              (if (= r (first t))\n                (with-meta (list t) {:found true})\n                (let [children (map self (rest t))\n                      groups (group-by #((meta %) :found) children)]\n                  (if (groups true)\n                    (with-meta\n                      (cons\n                        (cons (first t) (groups false))\n                        (first (groups true)))\n                      {:found true})\n                    (with-meta t {:found false})))))]\n    (reduce #(concat %2 (list %1)) (dfs tree))))","problem":130,"user":"527cd633e4b0757a1b17136f"},{"code":"(fn hang [el tree]\n  (let [good? #(and (coll? %) (= el (first %)))\n        goal-node  ((fn attach-parent-and-find [tree]\n                      (cond (good? tree) tree\n                             (coll? tree) (->> (map #(attach-parent-and-find (with-meta % {:parent tree})) tree)\n                                               (remove nil?)\n                                               (first))\n                       :else nil))\n                      tree)\n        remove-node (fn [tree node]\n                       (with-meta (remove #(and (coll? %) (= (first %) (first node))) tree)\n                         (meta tree)))\n        hang-cur (fn hang-cur [tree]\n                   (let [par (:parent (meta tree))]\n                     (if (nil? par)\n                       tree\n                       (concat tree [(hang-cur (remove-node par tree))]))))]\n    (hang-cur goal-node)))","problem":130,"user":"4f465096e4b0d56e7bb92b9a"},{"problem":130,"code":"(fn replant\n  [n tree]\n  (letfn [(root-seq\n  ([n path [x & xs :as tree]]\n   (println x)\n   (cond\n     (not x) '()\n     (= n x) (conj path tree)\n     :else (some #(root-seq n (conj path tree) %) xs))))]\n    (reduce\n     (fn [r x]\n       (concat x [(remove #{x} r)]))\n     (root-seq n [] tree))))","user":"569dd6e8e4b0542e1f8d1480"},{"code":"(fn [node root]\n  (let [get-l (fn [x] \n          (when (sequential? x) (first x)))\n        remove-node (fn [node tree]\n          (remove #(= (get-l %) node) tree))\n        reparent (fn [tree node]\n          (concat (first (filter #(= (get-l %) node) tree)) (list (remove-node node tree))))\n        find-node (fn [node tree]\n          (loop [tovisit [{:node tree :path []}]]\n            (println tovisit)\n            (if (= node (get-l (:node (first tovisit))))\n              (conj (:path (first tovisit)) node)\n              (recur\n                (into (rest tovisit) (map (fn [x] {:node x :path (conj (:path (first tovisit)) (get-l (:node (first tovisit))))})\n                  (rest (:node (first tovisit)))))))))]\n    (reduce reparent root\n      (rest (find-node node root)))))","problem":130,"user":"4e7f5a0b535db966e863cc41"},{"problem":130,"code":"(fn reparent\n   [new-parent tree]\n   (letfn [(new-parent-in-branch [branch]\n             (reduce (fn [in-branch b]\n                       (cond (= b new-parent) true\n                             (coll? b) (or in-branch (new-parent-in-branch b))\n                             :else in-branch)) false branch))]\n     (println tree)\n     (cond (= new-parent (first tree)) tree\n           :else (let [branch-with-parent (first (filter new-parent-in-branch (rest tree)))\n                       branches-without-parent (filter (comp not new-parent-in-branch) (rest tree))]\n                    (reparent new-parent (concat branch-with-parent (list (concat (list (first tree)) branches-without-parent))))\n                   ))))","user":"4e9ff8d0535d7eef3080729c"},{"code":"(fn split-x [x tree] (letfn [\n\t(split [tree] (let [\n\t\ttheroot (first tree)\n\t\tchilds (next tree)]\n\t\t(if (= x theroot) [[] [tree]] (let [\n\t\t\tsub (map split childs)\n\t\t\tsub1 (mapcat first sub)\n\t\t\tsub2 (mapcat second sub)]\n\t\t\t(if (seq sub2)\n                [[] (conj sub2 (cons theroot sub1))]\n                [[(cons theroot sub1)] []])))))\n    (assemble2 [tree newroot] (concat newroot [tree]))\n    (assemble [forest] (reduce assemble2 forest))]\n\t(assemble (second (split tree)))))","problem":130,"user":"51cbdee1e4b08d8387cbede1"},{"problem":130,"code":"(fn reparent-tree\n  [new-root [root & childs :as tree]]\n  (letfn [(childs-without-child\n            [childs child]\n            (remove #(= child (first %)) childs))\n\n          (traverse\n            [root childs parent-without-me search-symbol]\n            (cond\n              (= root search-symbol)\n              (let [new-childs (concat childs [parent-without-me])]\n                (if (or (empty? new-childs) (and (= 1 (count new-childs)) (not (ffirst new-childs))))\n                  [root]\n                  (cons root new-childs)))\n\n              (nil? childs)\n              false\n\n              :else\n              (let [search-childs (map\n                                   (fn [[f & r :as child]]\n                                     (traverse f r (concat [root] (childs-without-child childs f)) search-symbol))\n                                   childs)\n                    val           (some (fn [x] (if x\n                                                  x\n                                                  false)) search-childs)]\n                \n                (if val\n                  (if (empty? parent-without-me)\n                    val\n                    (let [l         (last val)\n                          bl        (butlast val)\n                          to-append (conj (vec l) parent-without-me)]\n                      (conj (vec bl) to-append)))\n                  false))))]\n    \n    (traverse root childs [] new-root)))","user":"5b759ca8e4b047b03b2036d0"},{"problem":130,"code":"(fn [t g]\n  (letfn [(f [t g]\n            (if (= t (first g))\n              (list g)\n              (when-let [[new-root sub-tree]\n                         (some #(when-let [new-root (f t %)] [new-root %]) (rest g))]\n                (conj new-root (remove #{sub-tree} g)))))]\n    (reduce (fn [r t] (conj (vec t) r)) (f t g))))","user":"56d68cbae4b0ea9b8538f7cd"},{"code":"(fn [n t]\n  (let [f (fn f [r v]\n\t\t\t\t(let [m (into (vec (filter #(= r (first %)) v))  (filter #(= r (second %)) v))\n\t\t\t\t\t  n (remove (set m) v)\n\t\t\t\t\t  s (filter #(not= % r) (flatten m))]\n\t\t\t\t\t(if (empty? m)\n\t\t\t\t\t\t(list r)\n\t\t\t\t\t\t(cons r (map #(f % n) s)))))]\n\t\t(f n (loop [r [t] v []]\n\t\t\t\t(if-let [f (first r)]\n\t\t\t\t\t(if (= 1 (count f))\n\t\t\t\t\t\t(recur (next r) v)\n\t\t\t\t\t\t(recur (into (rest f) (rest r)) (into v (map #(vector (first f) (first %)) (rest f)))))\n\t\t\t\t\tv)))))","problem":130,"user":"4db85282535d1e037afb218a"},{"code":"(fn tree-reparent [n tree]\n  \"This could be a lot prettier, but whatever. Not amused by this exercise.\"\n  (letfn [(tree-or-leaf-eq [node tree]\n            (or (= tree node)\n                (and (coll? tree)\n                     (= (first tree) node))))\n          (find-node [node tree]\n            (if (not (coll? tree))\n              false\n              (if (= (first tree) node)\n                tree\n                (some (partial find-node node) (rest tree)))))\n          (parent-of [node tree]\n            (if (not (coll? tree))\n              false\n              (if (> (count tree) 1)\n                (if (some (partial tree-or-leaf-eq node) (rest tree))\n                  tree\n                  (some (partial parent-of node) (rest tree)))\n                false)))\n          (add-child [tree child]\n            (concat tree (list child)))\n          (detach-child [tree child]\n            (concat (list (first tree)) (remove (partial tree-or-leaf-eq child) (rest tree))))\n          (detach-node [node tree]\n            (if (coll? tree)\n              (concat (list (first tree)) (map (partial detach-node node)\n                                               (remove (partial tree-or-leaf-eq node) (rest tree))))\n              tree))]\n    (let [parent (parent-of n tree)\n          this-tree (find-node n tree)\n          rest-of-tree (detach-node n tree)]\n      (if (nil? parent)\n        tree\n        (if (= (first tree) n)\n          tree\n          (add-child this-tree (tree-reparent (first parent) rest-of-tree)))))))","problem":130,"user":"4ff355a1e4b0678c553fc34d"},{"problem":130,"code":"(fn solve\n  ([node tree]\n   (solve node tree nil))\n  ([node tree attach]\n   (let [[parent & children] tree\n         attach-list (if attach (list attach) ())]\n     (if (= node parent)\n       (concat tree attach-list)\n       (->> (for [child children]\n              (let [others (remove #{child} children)\n                    attach (concat (cons parent others) attach-list)]\n                (solve node child attach)))\n            (filter identity)\n            first)))))","user":"559622cee4b0c79f6e1db975"},{"code":"#(let [f first l filter\n       c (fn c [t] (and (seq? t)\n                           (or (= % (f t))\n                               (some c t))))]\n    (loop [t %2]\n      (if (= % (f t)) t\n          (recur\n           (concat\n            (f (l c t))\n            [(l (complement c) t)])))))","problem":130,"user":"4fa340b4e4b081705acca18c"},{"problem":130,"code":"(fn reparent [new-parent root]\n  (letfn [(goal? [[val]] (= new-parent val))\n          (leaf? [tree] (= 1 (count tree)))\n          (tree-val [tree] (first tree))\n          (children [tree] (rest tree))\n          (subtree [tree subtree node]\n            \"Build a new subtree from a previous subtree and\n             this node's parent, removing the node from its\n             original position if present\"\n            (concat\n              (list (tree-val tree))\n              (filter (complement #(= node %)) (children tree))\n              (if (seq subtree)\n                (list subtree)\n                '())))\n          (queue [& vals]\n            (apply conj clojure.lang.PersistentQueue/EMPTY vals))]\n  (loop [q (queue {:tree root :new-tree '() })]\n    (when-let [{:keys [tree new-tree]} (peek q)]\n      (cond\n        (goal? tree) (subtree tree new-tree tree)\n        (leaf? tree) (recur (pop q))\n        :else\n        (let [wrap (fn [t] {:tree t\n                            :new-tree (subtree tree new-tree t)})]\n          (recur (->> (children tree)\n                      (map wrap)\n                      (apply conj (pop q))))))))))","user":"5aa998c6e4b0d174b936c8e5"},{"problem":130,"code":"(fn reparent [new_root tree]\n  (letfn [\n          (unsplice [node value]\n            (let [grouping (group-by #(= (first %) value) (rest node))]\n              [(first (get grouping true)) (cons (first node) (get grouping false))]\n              ))\n          (rotate [node child]\n            (if (= child (first node))\n              node\n              (let [[new_root unspliced] (unsplice node child)]\n                (concat new_root (list unspliced)))))\n          (subpath [node [node_value & node_children] path]\n            (cond\n              (= node node_value) (conj path node)\n              (empty? node_children) nil\n              :else (reduce #(or %1 %2) (map #(subpath node % (conj path node_value)) node_children))))\n          (find-path [node tree] (subpath node tree []))\n          ]\n  (let [path (find-path new_root tree)]\n    (do (println \"path -> \" path)\n        (reduce #(rotate %1 %2) tree path)))))","user":"55f2c898e4b06e875b46ce4b"},{"problem":130,"code":"(fn tree-reparent\n  [needle tree]\n  (letfn [(dfs-backstack\n            ([needle [val & children :as root] backstack]\n             (cond\n               (= needle val) (conj backstack root)\n               (nil? children) 'nil\n               :else (first (filter identity (map #(dfs-backstack needle % (conj backstack root)) children)))))\n            ([needle root] (dfs-backstack needle root [])))\n          (invert-tree\n            ([[x & xs :as path] current-child]\n             (if (nil? path) current-child\n                 (invert-tree xs\n                              (let [new-parent (filter (partial not= (first xs)) x)]\n                                (if (nil? current-child)\n                                  new-parent\n                                  (concat new-parent (list current-child)))))))\n            ([xs] (invert-tree xs 'nil)))]\n    (invert-tree (dfs-backstack needle tree))))","user":"504ee3b7e4b0e7ad84dbc4a3"},{"problem":130,"code":"(fn pull\n  ([target tree]\n   (pull target tree nil))\n  ([target [label & children] parent]\n   (if (= label target)\n     (remove nil? (concat [label]\n                          children\n                          [parent]))\n     (loop [[child & remain] children, passed []]\n       (if (nil? child)\n         :dead-end\n         (let [mangled-self (remove nil? (concat [label]\n                                                 passed remain\n                                                 [parent]))\n               pulled-child (pull target child mangled-self)]\n           (if (not= pulled-child :dead-end)\n             pulled-child\n             (recur remain (conj passed child)))))))))","user":"573d58c8e4b05c31a32c0811"},{"code":"(fn [x s]\n(letfn [(k [f x s] (f #(and (list? %) (= x (first %))) s))\n        (one-depth [x s] (concat (first (k filter x s)) (list (k remove x s))))\n        (path [x s] ((fn f [x [a & r] acc] (if (= x a) (rest (conj acc a))\n                        (some #(f x % (conj acc a)) r))) x s []))]\n  (reduce #(one-depth %2 %) s (path x s))))","problem":130,"user":"4fdb02aae4b05e33b9224f56"},{"problem":130,"code":"(fn [r t]\n  (let [fr (fn fr [t]\n             (if (= r (first t))\n               true\n               (if (< 1 (count t))\n                 (reduce #(or %1 %2) (map fr (rest t)))\n                 false)))\n        tt (fn tt [t] (let [f (first t)]\n                        (if (= r f)\n                          t\n                          (let [n (rest t)\n                                nr (.indexOf (map fr n) true)\n                                nn (concat (take nr n) (drop (inc nr) n))]\n                            (tt (concat (nth n nr) (list (conj nn f))))))))]\n    (if (= r (first t))\n      t\n      (tt t))))","user":"55205564e4b08d5046aa8a60"},{"problem":130,"code":"(fn f\n  ([root xs] (f root xs nil))\n  ([root xs parent]\n   (let [add-parent (fn [path parent]\n                      (if (empty? parent)\n                        path\n                        (concat path (list parent))))]\n     (cond\n       (= (first xs) root) (add-parent xs parent)\n       (not (seq? xs)) nil\n       :else\n       (some identity\n             (map #(f root\n                      %\n                      (add-parent (remove #{%} xs) parent))\n                  (filter seq? xs)))))))","user":"56795deae4b05957ce8c6187"},{"code":"(fn [el tree]\n  (let [has-el? (fn [t] (contains? (into #{} (flatten t)) el))\n        retree (fn retree [[t & childs]]\n                 (if (= t el)\n                   (cons t childs)\n                   (let [c (first (filter has-el? childs))\n                         r (filter (comp not has-el?) childs)]\n                     (retree (concat c [(cons t r)]))  )))\n        ]\n    (retree tree)))","problem":130,"user":"513b77f3e4b00f740c76c403"},{"problem":130,"code":"(fn [node tree]\n  (letfn [;append to-append as the rightmost child of anchor in tree\n          (deep-append [to-append anchor tree]\n                       (if (= anchor (first tree))\n                         (seq (concat tree [to-append]))\n                         (seq (concat (drop-last tree) [(deep-append to-append anchor (last tree))]))\n                         ))\n          \n          ; reparent subtree\n          (work [subtree]\n                (let [root (first subtree)\n                      children (rest subtree)]\n                  ; if this is leaf, we handle it using a separate flow\n                  (if (= 1 (count subtree)) \n                    [(= root node) subtree]\n                    ; otherwise if this is the node and it's internal, we start hoisting \n                    (if (= root node)\n                      [true subtree]\n                      ; otherwise we need to go through all childrens\n                      (let [results (map work children) \n                            results-w-indexes (map-indexed vector results)\n                            hit-list (filter #(first (second %)) results-w-indexes)]\n                        (if (empty? hit-list)\n                          ; none of the children has the node \n                          [false subtree] \n                          ; one of the subtree has the node\n                          (let [other-children (map second (filter #(not (first %)) results))\n                                tree-to-append (seq (concat [root] other-children))\n                                hit (first hit-list)\n                                child-no (first hit)\n                                ; the previous root of this child \n                                old-child (first (nth children child-no))\n                                new-child (second (second hit))\n                                appended (deep-append tree-to-append old-child new-child)]\n                            [true appended])\n                          ))))))]\n    (second (work tree))\n    ))","user":"52faec2ee4b047fd55837004"},{"problem":130,"code":"(fn [R xs]\n    (let [filterxfn (fn [n] (if (nil? n) false (if (not (seq? n)) true (if (not (empty? n)) true))))]\n      ((fn d [back [rt & leaves :as w]]\n         (cond\n           (empty? w) nil\n           (= R rt) (filter filterxfn (conj (into [rt] leaves) back))\n           (empty? leaves) nil\n           :else (mapcat\n                   #(d\n                      (filter filterxfn\n                              (concat [rt] (concat\n                                             (take % leaves) (drop (inc %) leaves))\n                                      [(filter filterxfn back)]\n                                      ))\n                      (nth leaves %))\n                   (range (count leaves))))\n         ) nil xs)))","user":"533c2605e4b0e30313ee6cd7"},{"problem":130,"code":"(fn reparent [nn tt]\n  (letfn [ (promote [n t]\n             (concat (first (filter #(= n (first %)) (rest t)))\n                     (list (remove #(and (seq? %) (= n (first %))) t ))))\n           (findpath [n t acc]\n             (if (empty? t)\n               false\n               (let [new-acc (conj acc (first t))]\n                 (if (= n (first t))\n                   new-acc\n                   (reduce #(or %1 %2)\n                           false\n                           (map #(findpath n % new-acc) (rest t)))))))\n           ]\n    (let [path (findpath nn tt [])]\n      (reduce #(promote %2 %1) tt (rest path)))))","user":"53c1ce3ee4b00fb29b221268"},{"problem":130,"code":"(fn [r g]\n   (loop [[[[node & children] above] & more] [[g ()]]]\n     (if (= r node)\n       (concat [node] children (when (seq above) [above]))\n       (recur (lazy-cat more\n                        (map-indexed (fn [i c]\n                                       [c (concat [node]\n                                                  (take i children)\n                                                  (drop (inc i) children)\n                                                  (when (seq above) [above]))])\n                                     children))))))","user":"5db0172be4b0f8c104ccfc96"},{"problem":130,"code":"(fn [node tree]\n    (letfn [(filter-children [tree to-remove]\n             (conj (filter #(not (= to-remove (first %))) (rest tree)) (first tree))\n             )\n            (reparent [stree ps]\n             (if (empty? ps) stree\n               (concat stree [(reparent (filter-children (first ps) (first stree)) (rest ps))]))          \n            )\n            (vertical-move [parent-stack sibling-stack]\n              (loop [npstack parent-stack nsstack sibling-stack]\n                (if\n                  (= 0 (count (first nsstack)))\n                  (recur (rest npstack ) (rest nsstack))\n                  [npstack (conj (rest nsstack) (rest (first nsstack))) (ffirst nsstack)]\n                )))\n            ]\n      (loop [parent-stack '() sibling-stack '() [v & branches :as subtree] tree]\n        (cond\n         (= v node) (reparent subtree parent-stack)\n         (= 0 (count branches)) (let [[npstack nsstack nstree] (vertical-move parent-stack sibling-stack)] (recur npstack nsstack nstree) )\n         :default (recur (conj parent-stack subtree) (conj sibling-stack (rest branches)) (first branches))\n        )\n\n        ))\n    )","user":"5094057fe4b097f48cc38593"},{"code":"(fn\r\n  [label tree]\r\n    (let\r\n      [get-label (fn [x]\r\n  (when (sequential? x) (first x)))\r\npath-to\r\n(fn path-to\r\n  ([label tree] (path-to [] label tree))\r\n  ([path label tree]\r\n     (let [lbl (get-label tree) path (conj path lbl)]\r\n       (if (= label lbl)\r\n         path\r\n         (mapcat (partial path-to path label)\r\n                 (rest tree))))))\r\nlift-local\r\n(fn lift-local\r\n  [tree label]\r\n  (let [match  #(= label (get-label %))\r\n        subtree     (first (filter match tree))\r\n        but-subtree (remove match tree)]\r\n    ;; append but-subtree to subtree\r\n    (concat subtree (list but-subtree))))\r\n        ]\r\n      \r\n  (reduce lift-local\r\n          tree\r\n          (rest (path-to label tree)))))","problem":130,"user":"50427899e4b0add3005c0fc2"},{"problem":130,"code":"(fn task-130 [r t]\n  (let [find-path (fn find-path [t n]\n                    (if (= n (first t))\n                      [n]\n                      (->>\n                       (for [x (rest t)]\n                         (when-let [p (find-path x n)]\n                           (conj p (first t))))\n                       (remove nil?)\n                       first)))\n\n        swap (fn [[x & xs] n]\n               (if (= x n) (concat (list x) xs)\n                   (let [xs-n (remove #(= n (first %)) xs)\n                         [n & ns] (first (filter #(= n (first %)) xs))]\n                     (concat (when n (list n)) ns (list (concat [x] xs-n))))))\n        ]\n\n    (reduce swap t (rseq (find-path t r)))))","user":"4ddb696b535d02782fcbe9fa"},{"problem":130,"code":"(fn tree [new-root root]\n(letfn[\n(v [root] (if (or (nil? root) (empty? root)) nil (first root)))\n(not-nil? [& a] (apply (comp not nil?) a))\n(retain-but [l p] (conj (filter #(not (= p (v %1))) (rest l)) (first l)))\n(filter-first [l f] (first (filter f l)))\n(get-in-set [l s] (first (filter #(contains? s (v %)) (rest l))))\n(get-root [l r] (first (filter #(= r (v %))(rest l))))\n(find-path [source new-root path]\n  ( cond\n   (or (nil? source) (empty? source)) #{}\n   (= new-root (v source)) path\n   :else (filter-first (map #(find-path %1 new-root (conj path (v %1))) (rest source)) not-nil?)\n   )\n  )\n]\n  (let [p (find-path root new-root #{(v root)})]\n    (loop [cur root]\n      (let [root-in-cur (get-root cur new-root)\n            path-in-cur (get-in-set cur p)]\n       (cond\n         (= new-root (v cur)) cur\n         (not-nil? root-in-cur) (filter not-nil? (concat root-in-cur [(filter not-nil? (retain-but cur (v root-in-cur)))]))\n         (not-nil? path-in-cur) (recur (filter not-nil? (concat path-in-cur [(filter not-nil? (retain-but cur (v path-in-cur)))])))\n         ))\n      )\n    )\n  )\n)","user":"55eeb37ae4b0121d4835fdf3"},{"code":"(fn [r t]\n  ((fn f [[n & t] & anc]\n    (remove nil?\n      (if (= n r)\n        (concat [n] t anc)\n        (if (coll? t)\n          (mapcat\n            #(f (nth t %) (concat [n] (take % t) (drop (inc %) t) anc))\n            (range (count t)))))))\n  t))","problem":130,"user":"528652fbe4b0239c8a67ae14"},{"code":"(fn [goal tree]\n(reduce (fn [a b] (concat b (list (remove #(= % b) a))))\n (apply\n  (fn dfs [path, goal]\n    (let [node (last path)]\n      (if (= goal (first node))\n        path\n        (if (= 1 (count node))\n          (conj path nil)\n          \n        (loop [nodes (next node)]\n          (if (nil? nodes)\n            (conj path nil)\n            (let [loop-path (dfs (conj path (first nodes)) goal)]\n              (if-not (nil? (last loop-path))\n                loop-path\n                (recur (next nodes))))))))))\n  [(vector tree) goal])))","problem":130,"user":"4e98a6d0535dbda64a6f6b5e"},{"problem":130,"code":"(fn reparent\n  [new-root old-tree]\n  (letfn [(get-path \n            [new-root old-tree path]\n            (if (= new-root (first old-tree))\n              (reverse (cons old-tree path))\n              (some #(get-path new-root % (cons old-tree path))\n                    (rest old-tree))))]\n   (reduce #(concat %2 [(remove #{%2} %1)])\n           (get-path new-root old-tree []))))","user":"56102f50e4b05f002753df6b"},{"code":"(fn [up-node tree]\n  (letfn [(subtree-pairs [destination-node [[path tree :as path-tree] & more-path-trees]]\n            (let [start-node (first tree)\n                  more-paths-to-explore (for [sub-tree (rest tree)] [(conj path start-node) sub-tree])]\n              (if (= start-node destination-node)\n                (partition 2 1 (reverse (conj (conj path start-node) nil)))\n                (subtree-pairs destination-node (concat more-path-trees more-paths-to-explore)))))\n          (sub-tree-parenting [not-node destination-node [tree & more-trees]]\n            (let [start-node (first tree)\n                  subtrees (for [subtree (rest tree)] subtree)]\n              (if (= start-node destination-node)\n                (remove #(= (first %) not-node) (rest tree))\n                (sub-tree-parenting not-node destination-node (concat more-trees subtrees)))))]\n    (let [st (subtree-pairs up-node [[[] tree]])\n          interim-result (reverse (for [[not-node destination-node] st]\n                           (apply list destination-node (sub-tree-parenting not-node destination-node [tree]))))]\n      (reduce #(conj (concat (concat (concat (rest %2) (list %1)))) (first %2)) (first interim-result) (rest interim-result)))))","problem":130,"user":"50ef9a7ae4b0bdaecbb47d9e"},{"problem":130,"code":"(fn [new-parent tree]\n        (letfn [(path [[l & c] label pp]\n                  (let [p (conj pp l)]\n                    (if (= l label)\n                      p\n                      (map #(path % label p) c))))\n                (rotate [[root-l & root-c :as root] new-root-l]\n                  (let [{[[l c :as n]] true o false} (group-by #(= new-root-l (first %)) root-c)]\n          \t\t\t(conj (vec n) (apply vector root-l o))))]\n          (let [p (flatten (path tree new-parent []))]\n            (reduce\n             (fn [res l]\n               (rotate res l))\n             tree\n             (rest p)))))","user":"57609d91e4b08062f99a4e9b"},{"code":"(fn reparent\n  ([itm tree] (reparent itm tree nil))\n  ([itm node parent]\n     (let [elem (first node)\n           children (rest node)\n           maybe-list (fn [x] (if (nil? x) x (list x)))]\n       (if (= elem itm)\n         (do\n           (concat node (maybe-list parent)))\n         (first (filter #(not (empty? %))\n                        (for [child children]\n                          (let [siblings (remove #(= % child) children)]\n                            (reparent itm child (concat (cons elem siblings) (maybe-list parent)))))))))))","problem":130,"user":"4e7f51eb535db966e863cc3f"},{"problem":130,"code":"(fn tree-reparent [node tree]\n  (letfn [(tree->map [tree env parent]\n            (let [node (first tree)\n                  children (vec (map first (rest tree)))]\n              (reduce\n               (fn [env c] (tree->map c env node))\n               (assoc env node {:parent parent, :children children})\n               (rest tree))))\n          (map->tree [tree-map root]\n            (let [children (get-in tree-map [root :children])]\n              (vec (concat [root] (map #(map->tree tree-map %) children)))))\n          (reparent [tree-map node new-parent]\n            (let [{:keys [parent children]} (tree-map node)\n                  new-children (vec (remove #{new-parent} children))\n                  new-record {:parent new-parent\n                              :children (if (nil? parent) new-children (conj new-children parent))}\n                  new-tree-map (assoc tree-map node new-record)]\n              (if (nil? parent)\n                new-tree-map\n                (reparent new-tree-map parent node))))]\n    (map->tree (reparent (tree->map tree {} nil) node nil) node)))","user":"5b51b9f8e4b02d533a91bcfe"},{"problem":130,"code":"(fn [x tr]\n  (let [p-dict\n          (loop [d {} forest [tr]]\n            (if (empty? forest) d\n              (recur (into d\n                        (for [t forest offs (rest t)] [(first offs) (first t)]))\n                (mapcat rest forest))))]\n    (loop [[r & offs :as t] tr\n           [c & c_] (->> x (iterate p-dict) (take-while identity) reverse rest)]\n      (if (nil? c) t\n        (let [in-path? #(= c (first %))\n              rest-tree (cons r (remove in-path? offs))\n              sub-tree (first (filter in-path? offs))]\n          (recur (concat sub-tree [rest-tree]) c_))))))","user":"5416b4a2e4b01498b1a71a01"},{"code":"(fn tr [key tree]\r\n\r\n  (let [allnodes (tree-seq seq? identity tree)\r\n        haschild (fn [node] (some #(= key %) (flatten node)))\r\n        node_parents (reverse (filter #(haschild %) allnodes))\r\n        remove-node (fn [p c] (apply list (filter #(not= c %) p)))\r\n        cleaned (map-indexed (fn [idx value]\r\n                                 (if (= 0 idx)  value\r\n                                                (remove-node value (nth node_parents   (dec idx) ) ) )   )\r\n                 node_parents)\r\n        ;_ ( println cleaned)\r\n        ]\r\n        (loop [acc (last cleaned) r (drop-last cleaned)]\r\n          (if (empty? r) acc\r\n              (recur (concat (last r) (list acc))  (drop-last r)  )\r\n          )\r\n\r\n      )\r\n\r\n    )  )","problem":130,"user":"4ec5bec6535d6d7199dd36b3"},{"problem":130,"code":"(fn [x b]\n      (let [y (first b)]\n           (cond\n             (and (= x 'n) (= y 'n)) '(n)\n             (and (= x 'a) (= y 't)) '(a (t (e)))\n             (and (= x 'e) (= y 'a)) '(e (t (a)))\n             (and (= x 'a) (= y 'c)) '(a (b (c)))\n             (and (= x 'd) (= y 'a)) '(d (b (c) (e) (a (f (g) (h)))))\n             (and (= x 'c) (= y 'a)) '(c (d) (e) (b (f (g) (h)) (a (i (j (k) (l)) (m (n) (o))))))\n             )\n           )\n      )","user":"53bcdd41e4b0d9a98559a6c0"},{"code":"(fn [new-root tree]\r\n  (letfn [(reroot [path]\r\n            (when-not (empty? path)\r\n              (let [[n leaf] (first path) parts (split-at n leaf)]\r\n                (list (concat (first parts) (rest (fnext parts)) (reroot (rest path)))))))\r\n          (find-node [mark [val & leafs :as node] path]\r\n            (cond\r\n              (= val mark) (concat node (reroot path))\r\n              (empty? leafs) nil\r\n              :else (first (remove nil?\r\n                             (map-indexed\r\n                               (fn [n leaf] (find-node mark leaf (conj path [(inc n) node])))\r\n                               leafs)))))]\r\n    (find-node new-root tree ())))","problem":130,"user":"4f969214e4b0dcca54ed6cdd"},{"problem":130,"code":"(fn rotate-tree [node tree]\n  (letfn [(tree->graph [tree]\n            (loop [graph {}\n                   queue [[tree nil]]]\n              (if (seq queue)\n                (let [[[node & children] parent] (first queue)\n                      queue (rest queue)\n                      queue (into queue (map #(vector % node) children))\n                      connections (conj (vec (map first children)) parent)\n                      connections (remove nil? connections)]\n                  (recur (assoc graph node connections) queue))\n                graph)))\n\n          (graph->tree \n            ([node graph] (graph->tree node graph #{}))\n            ([node graph processed]\n             (let [processed (conj processed node)\n                   children (remove processed (graph node))\n                   subtrees (map #(graph->tree % graph processed) children)]\n               (cons node subtrees))))]\n\n    (graph->tree node (tree->graph tree))))","user":"500aa15ee4b03d00572d2d76"},{"code":"(fn [k v]\r\n(if (= 'a k)\r\n  (if (= 't (first v)) '(a (t (e))) '(a (b (c))))\r\n({'n '(n)\r\n'e '(e (t (a)))\r\n'd '(d  (b (c) (e) (a  (f  (g) (h)))))\r\n'c '(c  (d) (e) (b (f  (g) (h)) (a (i (j (k) (l)) (m (n) (o))))))\r\n} k)))","problem":130,"user":"4dfe65a1535d04ed9115e787"},{"problem":130,"code":"(fn [new-node tree]\n   (letfn [(f [new-node [node & children :as sub-tree]]\n             (cond\n               (= new-node node) (list sub-tree)\n               (nil? children) nil\n               :else (let [arg-res (map #(vector % (f new-node %)) children)\n                           others (map first (filter (comp nil? second) arg-res))\n                           new-nodes (first (drop-while nil? (map second arg-res)))]\n                       (if (not-empty new-nodes)\n                         (cons (cons node others) new-nodes)\n                         nil))))]\n     (reduce (fn [acc e] (concat e (list acc)))\n             (f new-node tree))))","user":"5e3ef7d4e4b01d43a70e8e2d"},{"problem":130,"code":"(fn [nr t]\n  (letfn [(extract [[r & cs :as n]]\n            (if (= nr r) \n              (list n)\n              (let [xs (map (juxt extract identity) cs)]\n                (when-let [xs* (some first xs)]\n                  (conj xs* (cons r (keep (fn [[x c]] \n                                            (when-not x c)) \n                                          xs)))))))]\n    (reduce (fn [c p]\n              (conj (vec p) c))\n            (extract t))))","user":"53dfdf01e4b0d874e779ae46"},{"problem":130,"code":"(fn reparent-tree [node tree]\n  (let [[parent & children] tree]\n    (if (= node parent)\n      tree\n      (let [branch (vec (first (filter #(some #{node} (flatten %)) children)))\n            siblings (remove #{branch} children)]\n        (recur node (conj branch (cons parent siblings)))))))","user":"58ed713de4b056aecfd47d84"},{"problem":130,"code":"(fn [dest tree]\n  (->> (tree-seq next rest tree)\n       (filter #(some #{dest} (flatten %)))\n       (reduce #(->> (remove #{%2} %1)\n                     list\n                     (concat %2)))))","user":"5dc88a38e4b02f9375f4e1db"},{"problem":130,"code":"(fn [new-root tree]\n  (letfn [(prewalk [[node & children :as tree]]\n            ;; A recursive function to transverse the tree and return an original\n            ;; subtree or a modified one (if the new root is in it).\n            ;; NOTE: a breadth first search, instead of this depth first search,\n            ;; could be a better solution.\n            (if (= node new-root)\n              ;; The current node (and possible root of a subtree) is the target\n              ;; node. Here we return the original root of this possible subtree (in\n              ;; this case, this subtree is the same as the original.\n              [node tree]\n              ;; We can have normal leaves, original subtrees or modified subtrees.\n              (let [walks (seq (map prewalk children)) ; recursive call\n                    ;; The results of these walks can be three possibilities:\n                    ;; nil ('node' is a leaf), a tree (a normal list of nodes)\n                    ;; or a vector [original-root-node-of modified-subtree].\n                    reg-children (remove vector? walks) ; regular children (original subtrees).\n                    ;; Modified subtree. 'n' the original root of the modified\n                    ;; subtree 't'.\n                    [n t] (first (filter vector? walks))]\n                (if-not n\n                  ;; If we don't have any modified child, we can just return\n                  ;; this original subtree.\n                  tree\n                  ;; If we have modified child, we need to \"move down\" 'node'\n                  ;; and its unmodified children as a child of 'n' and return\n                  ;; the original root of this subtree and the new (modified)\n                  ;; subtree.\n                  ;; We need to search for it in the modified\n                  ;; subtree.\n                  [node (move-down (list* node reg-children) n t)]))))\n          (move-down [cur-tree new-parent-node uptree]\n            ;; Moves the tree 'cur-tree' to a leaf of 'new-parent-node', which is\n            ;; somewhere inside the 'uptree'.\n            (letfn [(f [[n & chs :as t]]\n                      ;; Recursive function that works in a very similar way as\n                      ;; 'prewalk'.\n                      (if (= n new-parent-node)\n                        ;; We found the new root of 'cur-tree'. We need to put at the\n                        ;; rightest place.\n                        (concat t [cur-tree])\n                        ;; We just return the tree as we found it.\n                        (conj (map f chs) n)))]\n              (f uptree)))]\n    (second (prewalk tree))))","user":"4f678ac8e4b07046d9f4ef67"},{"problem":130,"code":"(fn\n  [new-root tree]\n  (reduce\n    (fn [first second]\n      (concat second\n              (list (remove (partial = second) first))))\n    (filter #(and (seq? %) (some (fn [x] (= x new-root)) (flatten %)))\n                       (tree-seq seq? seq tree))))","user":"5af361d4e4b0cc2b61a3bc83"},{"code":"(fn f [n t]\n  (let [parent (if (= (first t) n) nil\n                   (loop [sts [t]]\n                     (if-let [p (first (filter (fn [st] (some #(= (first %) n)\n                                                              (rest st)))\n                                               sts))]\n                       (first p)\n                       (recur (mapcat rest sts)))))\n        me (loop [sts [t]]\n             (if-let [st (first (filter #(= (first %) n) sts))]\n               st\n               (recur (mapcat rest sts))))\n        except-me (if (= (first t) n) nil\n                      ((fn e [n t]\n                         (cons (first t)\n                               (for [st (rest t)\n                                     :when (not= (first st) n)]\n                                (e n st))))\n                          n t))\n                         ]\n    (if (= (first t) n) t\n        (concat me (list (f parent except-me))))))","problem":130,"user":"4fd96694e4b05e33b9224f37"},{"problem":130,"code":"(fn [target tree]\n  ((fn try-rotate [tree above]\n     (if (= (first tree) target)\n       (concat tree above)\n       (some (fn [child]\n               (try-rotate child\n                           `((~@(filter #(not= % child) tree)\n                              ~@above))))\n             (rest tree))))\n   tree '()))","user":"4f5eda39e4b0030a34fb2b56"},{"problem":130,"code":"(fn reparent\n  [new-root-sym [root-sym & children :as tree] & ancestor-subtree]\n  (if (= new-root-sym root-sym)\n    (concat tree ancestor-subtree)\n    (first\n     (keep-indexed\n      (fn [index child]\n        (let [ancestor-subtree (concat (take (inc index) tree)\n                                       (drop (+ 2 index) tree)\n                                       ancestor-subtree)]\n          (reparent new-root-sym child ancestor-subtree)))\n      children))))","user":"59137b42e4b0163c97b36f04"},{"code":"(fn [node-id tree] (letfn [\n(prepend [coll n] (cons n coll))\n(append [coll n] (if (empty? coll) [n] (cons (first coll) (append (rest coll) n))))\n(root [tree] (first tree))\n(children [node] (rest node))\n(id [node] (first node))\n(find-first [coll pred] (first (filter pred coll)))\n(eq? [n] (partial = n))\n(neq? [n] (partial not= n))\n(seq-contains? [coll val] (true? (some (eq? val) coll)))\n(find-node [tree pred] (cond (pred tree) tree (empty? tree) nil :else (find-first (map #(find-node % pred) (children tree)) #(not (nil? %)))))\n(parent [tree node-id] (find-node tree (fn [current-node] (find-first (children current-node) #(= (id %) node-id)))))\n(remove-child [node child-id] (prepend (remove #(= child-id (id %)) (children node)) (id node)))\n(rotate [tree node] (if (parent tree (id node)) (append node (rotate tree (remove-child (parent tree (id node)) (id node)))) node))\n(tree-reparenting [node-id tree] (rotate tree (find-node tree #(= (id %) node-id))))\n] (tree-reparenting node-id tree)))","problem":130,"user":"52f10094e4b05e3f0be25ee8"},{"problem":130,"code":"#(letfn\n  [(g [a [v & c]] (when v (if-let [b (f v)] (conj b (concat a c)) (recur (concat a [v]) c))))\n\n   (f [[s & t]]\n     (cond (= % s) (list (concat (list s) t))\n           (not t) nil\n           1 (g [s] t)))]\n  (reduce (fn [a b] (concat b [a])) (f %2)))","user":"56824e1be4b0945ebc182a91"},{"problem":130,"code":"(fn [node tree]\n    (letfn [(find-path [tree node]\n                (let [n (first tree)\n                      children (rest tree)]\n                    (if (= n node)\n                        '()\n                        (first (filter #(not (nil? %))\n                                       (map-indexed\n                                           (fn [index child]\n                                               (let [path (find-path child node)]\n                                                   (if path (cons index path) nil)))\n                                           children))))))\n\n            (lift [tree index]\n                (let [root (first tree)\n                      children (rest tree)\n                      child (nth children index)\n                      others (concat (take index children) (drop (inc index) children))\n                      label-of-child (first child)\n                      children-of-child (rest child)\n                      children' (concat children-of-child (list (apply list root others)))]\n                    (cons label-of-child children')))]\n\n        (loop [path (find-path tree node)\n               tree tree]\n            (if (empty? path)\n                tree\n                (let [index (first path)\n                      path' (rest path)\n                      tree' (lift tree index)]\n                    (recur path' tree'))))))","user":"600ae927e4b074f607df6689"},{"code":"(fn __ [elem start-tree]\n  (letfn [(separate [p l] \n            [(filter p l) (filter (complement p) l)])\n          (path-to [elem tree]\n            ((fn inner [path [head & sub-tree]]\n               (cond (= elem head) (conj path elem)\n                     (empty? sub-tree) nil\n                     :else \n                     (mapcat #(inner (conj path head) %)\n                             sub-tree)))\n                 [] tree))]\n    (let [path (partition 2 1 (path-to elem start-tree))]\n      (reduce (fn [tree [parent child]]\n                (let [[[target-subtree] other-subtrees] (separate #(= child (first %)) \n                                                                  (rest tree))]\n                  (concat target-subtree (list (cons parent other-subtrees)))))\n              start-tree\n              path))))","problem":130,"user":"50812debe4b01a93d3f38e4c"},{"problem":130,"code":"(let [unparent (fn unparent [tree parent]\n                 (let [root (first tree) r (rest tree)\n                       cnames (vec (map first r)) cmap (reduce into {} (map #(unparent % root) r))]\n                   (assoc cmap root (if parent (conj cnames parent) cnames))))\n      reparent (fn reparent [graph root parent]\n                 (cons root (->> root\n                                 graph\n                                 (filter #(not= % parent))\n                                 (map #(reparent graph % root)))))]\n      (fn [root tree] (reparent (unparent tree nil) root nil)))","user":"5b465b8be4b02d533a91bc65"},{"problem":130,"code":"(fn prob130\n  ([node-name tree] (prob130 node-name tree nil))\n  ([node-name tree new-child]\n   (cond\n     (empty? tree) tree\n     (= node-name (first tree)) (concat tree (if new-child (list new-child)))\n     :else\n     (mapcat\n      (fn [subtree]\n        (prob130 node-name subtree\n                 (concat\n                  (remove #(= % subtree) tree)\n                  (if new-child (list new-child)))))\n      (rest tree)))))","user":"54e3df6ae4b024c67c0cf7e3"},{"code":"(fn [new-root tree]\n    (let [ tree-to-tuples\n          (fn tree-to-tuples [[root & next-level]]\n            (let [children (map first next-level)]\n              (apply concat\n                     (map #(vector root %1) children)\n                     (map tree-to-tuples next-level))\n              ))\n          get-other #(if (= (first %2) %1) (last %2) (first %2) )\n          make-tree (fn make-tree [tuples root]\n                      (let [\n                            tuples-grouped (group-by #(clojure.set/subset? #{root} (set %)) tuples)                            [children remaining] (map tuples-grouped [true false])]\n                        (if (seq children)\n                          (cons root\n                                (->> children\n                                     (sort-by #(not= root (first %)))\n                                     (map #(get-other root %))\n                                     (map #(make-tree remaining %))))\n                          [root])))]\n      (make-tree (vec (tree-to-tuples tree)) new-root)\n      ))","problem":130,"user":"4e6f578c535d5021c1a8961b"},{"code":"(fn [new-root tree]\n  (letfn [(one-up [tree node]\n            (let [     root (first tree)\n                  one-down (rest tree)\n                  node-tree (first (filter #(= node (first %)) one-down))\n                  sans-node (remove #(= node (first %)) one-down)\n                  root-tree (cons root sans-node)]\n              (concat node-tree (list root-tree))))\n          (path-to [tree node]\n            (let [root (first tree)]\n              (cond\n               (nil? root) nil\n               (= node root) (list root)\n               :else (let [path (first\n                                 (keep #(if % %)\n                                       (for [branch (rest tree)]\n                                         (path-to branch node))))]\n                       (if path (conj path root))))))]\n    (let [rotations (rest (path-to tree new-root))]\n      (loop [rots rotations\n             tree tree]\n        (if (empty? rots) tree\n            (recur (rest rots) (one-up tree (first rots))))))))","problem":130,"user":"524ae8e6e4b09eba1c0223b5"},{"problem":130,"code":"(fn [name tree]\n  (letfn [(path-to-nodes [[node & childs] name]\n            (if (= node name)\n              (list (list node))\n              (when (seq childs)\n                (map (fn [n] (when n (cons node n)))\n                     (mapcat (fn [child] (path-to-nodes child name)) childs)))))\n          (reparent-node [[node & childs] [hn & tn]]\n            (if-let [[new-root & new-root-childs] (first (filter (fn [[n & cs]] (= n (first tn))) childs))]\n              (let [new-childs (remove (fn [[n & cs]] (= n (first tn))) childs)]\n                [(cons new-root\n                       (concat new-root-childs\n                               (list (cons node new-childs)))) tn])\n              [(cons node childs) tn]))\n          (reparent-tree [tree names]\n            (if (seq names)\n              (let [[new-tree new-names] (reparent-node tree names)]\n                (reparent-tree new-tree new-names))\n              tree))]\n    (reparent-tree tree (first (path-to-nodes tree name)))))","user":"4ee528fb535d1385b2869d87"},{"code":"(letfn [(find-node [name z] \n          (if (= name (clojure.zip/node z))\n            (clojure.zip/up z)\n            (recur name (clojure.zip/next z))))\n        (new-tree [z]\n          (-> z clojure.zip/node clojure.zip/seq-zip))\n        (parent-name [z]\n          (-> z clojure.zip/up ffirst))\n        (parent-tree [z]\n          (-> z clojure.zip/remove clojure.zip/root clojure.zip/seq-zip))\n        (pull-up [z]\n          (if-let [pn (parent-name z)]\n            (clojure.zip/node (clojure.zip/append-child (new-tree z)\n                                                        (->> (parent-tree z)\n                                                             (find-node pn)\n                                                             pull-up)))\n            (clojure.zip/node z)))]\n  (fn [name tree]\n    (->> (clojure.zip/seq-zip tree)\n         (find-node name)\n         pull-up)))","problem":130,"user":"4ebcb8ff535dfed6da9c6d8a"},{"code":"(letfn [(pull [root child] \n          (concat child [(remove #{child} root)]))\n        (paths [root] \n          (tree-seq \n            (comp seq? :node) \n            (fn [m] (for [child (rest (:node m))] \n                      {:node child :path (conj (:path m) (:node m))}))\n            {:node root :path []})) \n        (find-node [id root]\n          (some #(when (= id (-> % :node first)) %) (paths root)))]\n  (fn [id root]\n    (reduce pull (apply conj ((juxt :path :node) (find-node id root))))))","problem":130,"user":"50d0d4c8e4b00b15ecee976a"},{"code":"(fn [new-root tree]\n   (letfn [(pull-node* [current [[parent-node & parent-children] & rest-ancestors :as ancestors]]\n             (if (empty? ancestors)\n               current\n               (concat current\n                       [(pull-node* (cons parent-node\n                                          (filter #(not (= (first current) (first %)))\n                                                  parent-children))\n                                    rest-ancestors)])))\n           (pull-node [[current-node & current-children :as current] ancestors]\n             (cond (= new-root current-node) (pull-node* current ancestors)\n                   (empty? current-children) nil\n                   :else (some #(pull-node % (cons current ancestors)) current-children)))]\n     (pull-node tree ())))","problem":130,"user":"4e7c8fd1535db169f9c796be"},{"code":"(fn [n [l & _ :as t]]\n  (if (= l n)\n    t\n    (let [r (loop [cl (clojure.zip/zipper (fn [_] true) next (fn [[l & _] c] `(~l ~@c)) t)]\n              (let [[l & _ :as c] (clojure.zip/node cl)]\n                (if (= l n)\n                  `[~@(clojure.zip/path cl) ~c]\n                  (recur (clojure.zip/next cl)))))]\n      (reduce\n       (fn [[l & c] s]\n         `(~@s (~l ~@(filter #(not= s %) c))))\n       r))))","problem":130,"user":"4e65027c535d8ccf87e9fe6e"},{"code":"(letfn\n  [(tree-iterate\n     ([tree] (tree-iterate tree nil))\n     ([tree parent]\n      (if-let [[node & subtrees] tree]\n        (cons [parent node subtrees]\n              (apply concat (map #(tree-iterate % node) subtrees))))))\n   (simplify-tree [tree]\n     (apply merge\n            (for [[parent node subtrees] (tree-iterate tree)]\n              {node (concat (map first subtrees) (if parent [parent]))})))\n   (hang-subtree [simplified root parent]\n     (cons root\n           (for [child (simplified root)\n                 :when (not= child parent)]\n             (hang-subtree simplified child root))))]\n  (fn [new-root tree]\n    (hang-subtree (simplify-tree tree) new-root nil)))","problem":130,"user":"50b668dde4b08fb537db98f2"},{"problem":130,"code":"(fn reparent [node tree]\n  (letfn\n      [(node-path [target tree current]\n          (cond\n            (= target (first tree)) (conj current (first tree))\n            (= 1 (count tree)) nil\n            :else\n              (first\n                (filter #(not= % nil)\n                  (for [child (rest tree)]\n                    (node-path target child (conj current (first tree)))\n                  )\n                )\n              )\n          )        \n      )]\n    (loop [\n           new-tree tree \n           root (first new-tree) \n           path (rest (node-path node tree []))\n          ]\n      (cond\n        (empty? path) new-tree\n        (= (first new-tree) (first path)) new-tree\n        :else\n          (let [\n                new-root (first path)\n                not-in-path-subtrees (filter #(not= (first path) (first %)) (rest new-tree))\n                in-path-subtree (drop 1 (first (filter #(= (first path) (first %)) (rest new-tree))))\n               ]\n            \n              ;(println new-root)\n              ;(println new-tree)\n  \n              (recur\n                (cond\n                  (empty? not-in-path-subtrees) (seq (concat [new-root] in-path-subtree [(seq [root])]))\n                  (empty? in-path-subtree) (seq (concat [new-root] [(concat [root] not-in-path-subtrees)]))\n                  :else\n                    (seq (concat [new-root] in-path-subtree [(concat [root] not-in-path-subtrees)] ))\n                )\n                (first path)\n                (rest path)\n              )\n            \n          )\n            \n      )\n    )\n  )\n)","user":"5991d2fae4b0866487ed0d68"},{"problem":130,"code":"(fn [i t]\n\t(let [tree-find (fn tf [nr [p & c :as t]]\n\t\t(if (= p nr)\n\t\t\t[nil [t]]\n\t\t\t(if (seq c)\n\t\t\t\t(let [nc (map #(tf nr %) c)\n\t\t\t\t\t  found? (some seq (map second nc))]\n\t\t\t\t\t  (if (not found?)\n\t\t\t\t\t\t[t []]\n\t\t\t\t\t\t(let [nt (concat [p] (remove nil? (map first nc)))\n\t\t\t\t\t\t\t  np (first (remove nil? (remove nil? (map second nc))))]\n\t\t\t\t\t\t\t[nil (conj np nt)])))\n\t\t\t\t[t nil])))\n\t\t\tfirst-pass (tree-find i t)]\n\t\t(reduce #(conj (vec %2) %1) (reverse (second first-pass)))))","user":"53e19461e4b0d874e779ae59"},{"problem":130,"code":"(fn trp [p tree]\n  (let [tm (vec ((fn re-tree [p t]\n                   (if (empty? t) {}\n                       (let [ft (first t)]\n                         (reduce #(merge %1 (re-tree ft %2))\n                                 {ft p} (rest t)))))\n                 nil tree))]\n    (->> (loop [tm tm, p p]\n           (let [[tm np] (reduce (fn [[a np] [x y]]\n                                   (cond (= x np) [(conj a [y x]) y]\n                                         :else [(conj a [x y]) np]))\n                                 [[] p] tm)]\n             (if (nil? np) tm\n                 (recur tm np))))\n         (filter #((comp not nil? first) %))\n         ((fn [tm]\n            ((fn make-list [p]\n               (->> (filter #(= p (second %)) tm)\n                    (sort-by first)\n                    (map (comp make-list first))\n                    (sort-by (comp count flatten))\n                    (reduce conj [p]))) p)\n            )))))","user":"515bbcd9e4b0388ca8ca1521"},{"problem":130,"code":"(fn f [r t]\n  (letfn [(subt [r t]\n            (if (= r (first t))\n              t\n              (some #(subt r %) (rest t))))\n\n          (parent [r t]\n            (if (= r (first t))\n              nil\n              (when (not-empty t)\n                (if-let [a (some #(= r (first %)) (rest t))]\n                  (first t)\n                  (some #(parent r %) (rest t))))))\n\n          (disjt [r t]\n            (if (= r (first t))\n              nil\n              (cons (first t) (keep #(disjt r %) (rest t)))))]\n\n    (if (= r (first t))\n      t\n      (let [sub (subt r t)]\n        (concat sub\n                [(f (parent r t) (disjt r t))])))))","user":"4ec1b090535dfed6da9c6db5"},{"problem":130,"code":"(letfn [(tree->net [tree parent] \n                   (conj\n   \t\t\t\t\t(mapcat #(tree->net % (first tree)) (rest tree))\n   \t\t\t\t\t(list (first tree) (let [ntree (mapv first (rest tree))]\n                                         (if parent (conj ntree parent) ntree)))))\n        (net->tree [net root]\n                   (when-let [children (some #(when (= root (first %)) (second %)) net)]\n    \t\t\t\t(conj (remove nil? (map (fn [c] (net->tree (remove #(= root (first %)) net) c)) children)) root)))]\n  (fn [root tree] \n    (net->tree (tree->net tree nil) root)))","user":"556323b5e4b0c656e3ff17e5"},{"problem":130,"code":"(fn [my-value my-tree]\n      (letfn [(convert\n                [tree]\n                {:value (keyword (first tree)) :children (into [] (map convert (rest tree)))})\n              (unconvert\n                [converted-tree]\n                (let [value (symbol (name (:value converted-tree))) children (map unconvert (:children converted-tree))]\n                  (cons value children)))\n              (find-node [tree value]\n                (do\n                  (cond\n                    (= value (:value tree)) tree\n                    (empty? (:children tree)) nil\n                    :else\n                    (let [results (map (fn [child-node] (find-node child-node value)) (:children tree))]\n                      (first (remove nil? results))\n                      ))))\n              (find-parent-node [tree value]\n                (cond\n                  (some #(= value (:value %))\n                        (:children tree))\n                  tree\n                  :else\n                  (first\n                    (map (fn [child-node] (find-parent-node child-node value)) (:children tree)))))\n              (find-addtl-child [tree value]\n                (if (= (:value tree) value)\n                  nil\n                  (loop [current-node (find-parent-node tree value) previous-node (find-node tree value)]\n                    (cond\n                      (and\n                        (= current-node tree)\n                        (= (:value previous-node) value))\n                      current-node\n                      (= current-node tree) previous-node\n                      :else\n                      (recur\n                        (find-parent-node tree (:value current-node))\n                        current-node)))))\n              (remove-node [tree value]\n                (if (= (:value tree) value)\n                  nil\n                  (if-let [p (first (filter #(= value (:value %)) (:children tree)))]\n                    {:value (:value tree) :children (into [] (remove #{p} (:children tree)))}\n\n                    (if (not (:children tree))\n                      tree\n                      {:value (:value tree) :children (map #(remove-node % value) (:children tree))})\n                    )\n                  ))]\n\n        (unconvert\n          (let [converted-tree (convert my-tree) v (keyword my-value)]\n            (if (= v (:value converted-tree))\n              converted-tree\n              (let [\n                    new-parent (find-node converted-tree v)\n                    addtl-child (find-addtl-child converted-tree v)]\n\n                (let [converted-result\n\n                      {:value v :children (conj (:children new-parent)\n                                                (let [addtl (remove-node addtl-child v)]\n                                                  {:value (:value addtl) :children (remove nil? (conj\n                                                                                                  (:children addtl)\n                                                                                                  (remove-node converted-tree (:value addtl))))}))}]\n                  converted-result\n                  ))\n              )\n            ))\n        ))","user":"5b2689e3e4b063e2438bcc33"},{"code":"(fn [new-root-name root]\n  (letfn [(descend [parents-stack node]\n            (cond\n              (nil? node) nil\n              (not= new-root-name (first node)) (some #(descend (cons node parents-stack) %)\n                                                      (rest node))\n              :else (ascend parents-stack node)))\n          (ascend [[p & parents-stack] node]\n            (if (nil? p)\n              node\n              (concat node [(ascend parents-stack\n                                    (cons (first p)\n                                          (filter #(not= (first %) (first node)) (rest p))))])))]\n    (into [] (descend [] root))))","problem":130,"user":"510acd6ee4b078ea719210f4"},{"code":"(fn reparent [target top]\n  (if (= target (first top))\n    top\n    (letfn [(find-node [target path [name & children :as node]]\n              (if (= target name)\n                (conj path node)\n                (some identity (map (partial find-node target (conj path node)) children))))\n            (simplify [[f & r] path]\n              (if (nil? r)\n                (conj path (vec f))\n                (recur r (conj path (vec (remove #{(first r)} f))))))]\n      (reduce #(conj %2 %1)\n              (simplify (find-node target [] top) [])))))","problem":130,"user":"50d93c53e4b0fd36a4b89223"},{"problem":130,"code":"(fn reparent-tree [new-root tree]\n  (let [path-to-new-root (fn path-to-new-root [[root & children]] \n                           (cond \n                             (= root new-root)  (list root)\n                             children           (cons root\n                                                      (->> children\n                                                           (map path-to-new-root)\n                                                           (remove nil?)\n                                                           first))))\n        reparent (fn [new-root [root & children]]\n                   (let [{new-children false \n                          [[_ & new-root-node-children]] true} (group-by (comp boolean #{new-root} first) \n                                                                         children)]\n                     (apply list new-root \n                       (concat new-root-node-children \n                               (list (apply list root new-children))))))]\n    (->> [(rest (path-to-new-root tree)) tree]\n         (iterate (fn [[[next-node & remaining] tree]]\n                    (when next-node\n                      [remaining (reparent next-node tree)])))\n         (take-while (complement nil?))\n         last\n         second)))","user":"5c506951e4b0f9f7a8770ec5"},{"code":"(fn reparent [node tree]\n  (letfn [\n          (sub-tree [node tree]\n                    (if (= (first tree) node) tree\n                      (first (filter identity (map #(sub-tree node %) (rest tree))))))\n          (remove-sub-tree [sub-tree tree]\n            (if (some #(= sub-tree %) (rest tree)) \n              (filter #(not= sub-tree %) tree)\n              (cons (first tree) (map #(remove-sub-tree sub-tree %) (rest tree)))\n              )\n            )\n          (parent [node tree]\n            (if (some #(= node (first %)) (rest tree))\n              (first tree)\n              (first (filter identity (map #(parent node %) (rest tree))))))\n          ]\n  (if (= node (first tree)) tree\n    (let [new-root (sub-tree node tree)\n          parent-of-root (parent node tree)\n          remaining-tree (reparent parent-of-root (remove-sub-tree new-root tree))\n          ]\n      (concat new-root (list remaining-tree)))\n  )))","problem":130,"user":"4fccdc75e4b0ee37620e186d"},{"code":"(fn f [n t] (let [r (first t)\n                   m (tree-seq next rest t)\n                   x (first (filter #(= n (first %)) m))\n                   b (fn b [s t] (if (= (first s) r)\n                                   t\n                                   (let [p (first (filter #((set %) s) m))\n                                         c (remove #(= s %) p)]\n                                     (concat t (list (b p c))))))]\n               (b x x)))","problem":130,"user":"4eb13d60535d7eef3080733f"},{"problem":130,"code":";パクリ\n;うまいこと出来てる\n;iの使い方とかsomeとか\n(fn reparent\n ([root tree]\n  (if (= (first tree) root)\n   tree\n   (reparent root tree '())))\n ([root tree past]\n  (if (= (first tree) root)\n   (concat tree [past])\n   (some identity\n    (for [i (range 1 (count tree))]\n     (reparent\n      root\n      (nth tree i)\n      (if (empty? past)\n       (concat (take i tree) (drop (inc i) tree))\n       (concat (take i tree) (drop (inc i) tree) [past]))))))))","user":"5b0180cfe4b0cc2b61a3bd47"},{"code":"(fn pro\n ([x t] (pro x t  (into {} (cons [t nil] (for [n (rest t)] [n t])))))\n ([x t pm]\n  (let [r  (if (coll? t) (first t) t) \n        c  (if (coll? t) (rest t) nil)]\n     (if (= x r)\n        (let [pt (pm t) gpt (pm pt)]\n           (if pt \n               (let [d (fn [T n] (cons (first T) \n                                         (remove #(= n %) (rest T))))\n                     gpp (if gpt (d gpt pt) nil)\n                     pp  (d pt t)\n                     pp2 (if gpp \n                             (conj (vec pp) gpp)\n                             pp)\n                     xp (conj (vec t) pp2)]\n                   (pro x xp (assoc pm xp (pm gpt))))\n               t))\n        (if c\n           (loop [[n & q] c]\n              (if n\n                (if-let [rz (pro x n \n                                 (if (coll? n)\n                                     (into {} (concat pm (for [j (rest n)] [j n])))\n                                     pm))]\n                    rz\n                    (recur q)))))))))","problem":130,"user":"4ee7d177535d93acb0a6686f"},{"code":"(fn pull [pulled [node & childs]]\r\n  (println \"pull \" pulled \" from \" node \"-\" childs)\r\n  (letfn [(includes? [leaf tree] (not (empty? (filter #(= leaf %) (flatten tree)))))\r\n          (tree [parent childs] (cons parent childs))]\r\n    (cond\r\n     (empty? childs) (list node)\r\n     (= pulled node) (cons node childs)\r\n     :else (pull pulled\r\n                 (concat (first (filter #(includes? pulled %) childs))\r\n                         (list (tree node (filter #(not (includes? pulled %)) childs))))))))","problem":130,"user":"4f62b29ce4b0defedf855fd9"},{"code":"(fn reparent\n  ([root tree]\n   (if (= (first tree) root) tree (reparent root tree '())))\n  ([root tree past]\n   (if (= (first tree) root)\n     (concat tree [past])\n     (some identity\n           (for [i (range 1 (count tree))]\n             (reparent root\n                       (nth tree i)\n                       (if (empty? past)\n                         (concat (take i tree) (drop (inc i) tree))\n                         (concat (take i tree) (drop (inc i) tree) [past])\n                         )\n                       )\n             )\n           )\n     )\n   )\n  )","problem":130,"user":"52e59ca5e4b09f7907dd1464"},{"code":"(fn [root t1]\r\n  (letfn [(check [x]\r\n                 (if (= root (first x))\r\n                   true\r\n                   (some identity (map check (rest x)))))\r\n          (get-ans [x]\r\n                   (let [head (first x)\r\n                         con (first (filter check (rest x)))\r\n                         res (filter #(not= % con) x)]\r\n                     (if (= head root) x\r\n                       (recur (concat con [res])))))]\r\n    (get-ans t1)))","problem":130,"user":"503354c3e4b0c6c1199c710c"},{"problem":130,"code":"(fn re-tree [n t]\r\n  (letfn [(map-tree ([t] (apply hash-map (map-tree nil t)))  \r\n                    ([p [n & c]]\r\n                    (if c\r\n                      (conj \r\n                        (mapcat (partial map-tree n) c) \r\n                        (filter (comp not nil?) (conj (mapv first c) p))\r\n                        n)\r\n                      [n (list p)])))\r\n          (re-tree-map [m n]\r\n            (if (empty? m) []\r\n              (when-let [cs (get m n)]\r\n                (conj \r\n                  (concat \r\n                    (map\r\n                      #(re-tree-map (dissoc m n) %)\r\n                      (filter m cs)))\r\n                  n))))]\r\n  (re-tree-map (map-tree t) n)))","user":"5470699ae4b00cfc9eacc1b6"},{"problem":130,"code":"(fn trepar [nbgn ntree]\n (letfn [\n\n(tr-root [ttt]\n (first ttt))\n\n(tr-nodes [ttt]\n  (let [fst (first ttt)\n        rst (rest ttt)\n        mynode \n         {:name fst\n          :childs \n           (vec (map first rst))}    \n        nxtnodes \n         (map tr-nodes rst)] \n    (reduce into [mynode] nxtnodes) ))\n\n(lst-edges [nodes]\n (letfn [\n  (loc-edgs [nd]\n   (let [enam (:name nd)\n         chlds (:childs nd)]\n    (map #(vector enam %) chlds))) ]\n  (reduce \n   (fn [acc nd]\n     (if (empty? (:childs nd))\n      acc\n      (into acc (loc-edgs nd)))) \n   [] nodes) ))\n\n(rt-track [rt node edges]\n (letfn [\n  (loc-track [trk work]\n   (let [prev (if (empty? trk) node (first (peek trk)))]\n    (if (= rt prev) \n     trk\n     (let [enxt (first (filter (fn [[src dst]] (= prev dst)) edges))\n           rst (remove #{enxt} edges)] \n      (if (nil? enxt)\n       [] ; error, cannot track\n       (loc-track (conj trk enxt) rst)) ))) )] \n   (loc-track [] edges) ))\n\n(tt-flip [[a b]] [b a])\n\n(flip-eset [eset edges]\n (let [eflt (filter eset edges)\n       eshort (vec (remove eset edges))\n       eflp (map tt-flip eflt)\n       eneu (into eshort eflp)]\n   eneu))\n\n(m-nodes [edges]\n (reduce\n  (fn [m [src dst]]\n   (merge-with into \n               m {src [dst]}))\n  {} edges))\n\n(tr-nested [nroot mtr]\n (letfn [\n  (loc-build [nx] \n   (let [chlds (mtr nx)] \n    (if (empty? chlds)\n     (list nx)\n     (apply (partial list nx) (map loc-build chlds) )))) ] \n  (loc-build nroot)))\n\n(tr-repa [rneu tr]\n (let\n  [root (tr-root tr)\n   edgs (lst-edges (tr-nodes tr))\n   trck (rt-track root rneu edgs)\n   fliedgs (flip-eset (set trck) edgs)\n   mtree (m-nodes fliedgs) ]\n  (tr-nested rneu mtree)))\n ] \n (tr-repa nbgn ntree) ))","user":"57f9011ee4b0d3187e900935"},{"problem":130,"code":"(fn reparent-tree [n tree]\n  {:pre [(pos? (count tree))]}\n  (letfn [(target-root [tree] (when (= n (first tree)) tree))\n          (mk-tree [v children] (cons v children))\n          (append-root [[target & target-children] root-tree root-child?]\n            (if (root-child? target)\n              (concat target-children [root-tree])\n              (concat (butlast target-children)\n                      [(mk-tree (first (last target-children))\n                                (append-root (last target-children) root-tree root-child?))])))]\n    (let [[root & original-children] tree\n          root-children (map #(reparent-tree n %) original-children)\n          target-tree (some target-root root-children)\n          root-tree (mk-tree root (remove target-root root-children))\n          root-child? (set (map first original-children))]\n      (assert (or (nil? target-tree) (target-root target-tree)))\n      (if (and\n            (not (target-root tree))\n            (seq root-children)\n            (seq target-tree))\n        (mk-tree n (append-root target-tree root-tree root-child?))\n        tree))))","user":"5f300f28e4b033932238a682"},{"problem":130,"code":"(fn [newroot tree]\n  (let [move-down\n        (fn [[tree zipper]]\n          (if-not (empty? (rest tree))\n            (list (first (rest tree))\n                  {:name (first tree)\n                   :left '()\n                   :right (rest (rest tree))\n                   :zipper zipper})))\n        move-up\n        (fn [[tree zipper]]\n          (if-not (empty? zipper)\n            (list (cons (zipper :name)\n                        (reverse (cons tree (zipper :left))))\n                  (zipper :zipper))))\n        move-right\n        (fn [[tree zipper]]\n          (if-not (empty? (zipper :right))\n            (list (first (zipper :right))\n                  (assoc zipper\n                         :left (cons tree (zipper :left))\n                         :right (rest (zipper :right))))))\n        search\n        (fn [x]\n          (if (= newroot (first (first x)))\n            x\n            (if-let [x (move-down x)]\n              (recur x)\n              (if-let [x (move-right x)]\n                (recur x)\n                (recur (->> x\n                            (iterate move-up)\n                            (drop-while (comp nil? move-right))\n                            first\n                            move-right))))))\n        add-right\n        (fn [root child]\n          (if (nil? child) root\n              (if (nil? root) child\n                  (->> root reverse (cons child) reverse))))\n        construct\n        (fn [zip] (cons (zip :name) (concat (reverse (zip :left)) (zip :right))))\n        parse\n        (fn [tree zipper]\n          (let [aux (fn [tree zips]\n                      (if (empty? (first zips))\n                        tree\n                        (recur (add-right tree (construct (first zips)))\n                               (rest zips))))]\n            (add-right tree (aux nil (iterate :zipper zipper)))))]\n    (apply parse (search (list tree {})))))","user":"54c5cc17e4b045293a27f624"},{"problem":130,"code":"(fn [pivot tree]\n  (let [branch-root-pivot (first (filter #(-> % first (= pivot)) (tree-seq coll? next tree)))\n        branch-inicial-com-pivot (filter #(-> (flatten %) set (contains? pivot)) (next tree))\n        branch-inicial-sem-pivot (first (remove #(-> (flatten %) set (contains? pivot)) (next tree)))\n        branch-primeiro (remove #(if (coll? %) (-> % first (= pivot)) (= pivot %)) (first branch-inicial-com-pivot))\n        branch-segundo (when (not= pivot (first tree)) \n                         (cons (first tree) (when branch-inicial-sem-pivot (list branch-inicial-sem-pivot))))]\n    (concat branch-root-pivot\n            (if (seq branch-primeiro)\n              (list (concat branch-primeiro\n                            (list branch-segundo)))\n              (when branch-segundo (list branch-segundo))))))","user":"52c8758be4b0c2d177d62135"},{"problem":130,"code":"(fn [v t]\n    (let [to-m (fn f [par i n & chs] (merge {n [par i]} (apply merge (map #(apply (partial f n %2) %1) chs (range)))))\n          from-m (fn f [n m] (let [chs (->> m (filter #(= n (get-in % [1 0])))\n                                              (sort-by #(get-in % [1 1]))\n                                              (map first))]\n                      (cons n (map #(f % m) chs))))\n          m (apply (partial to-m nil 0) t)\n          tr (fn f [v m] (let [p (get (m v) 0)] (if p (assoc (f p m) p [v (/ 1.0 0.0)]) m)))]\n  (from-m v (dissoc (tr v m) v)) ))","user":"5a4de614e4b05d388ecb6bb1"},{"code":"(fn f [p n t] \n  (letfn\n    [ (swap [t p]\n        (if (nil? p) \n          t \n          `(~@t ~p)))]\n    (if (= n (first t)) \n      (swap t p) \n      (some \n        #(f \n          (swap (remove #{%} t) p)\n          n \n          %) \n        (rest t)))))\nnil","problem":130,"user":"4f991ec1e4b0dcca54ed6cfb"},{"code":"(fn [el t]\n  (if (= (count t) 1) t\n   (let [st (filter seq? (tree-seq seq? identity t))\n        elt (first (filter #(= el (first %)) st))\n        pelt (first (filter #(some (fn [x] (= x elt)) %) st))\n        parents (take-while #(not= pelt %) st)\n        allp (reverse (concat parents [pelt] [elt]))\n        remprev (fn [i] (remove #(= % (nth allp (dec' i))) (nth allp i)))\n        remp (reverse (concat [elt] (map #(remprev %) (rest (range (count allp))))))]\n    (loop [res remp]\n      (if (= 1 (count res))\n        (first res)\n        (recur (concat [(concat (second res) [(first res)])] (nthrest res 2))))))))","problem":130,"user":"5133e51ae4b0d7a043de8cf6"},{"code":"(fn yank [r tree]\n  (letfn [(subtree [r tree]\n            (cond (empty? tree) nil\n                  (= (first tree) r) tree\n                  :else\n                  (first (filter seq\n                                 (map \n                                  (partial subtree r)\n                                  (rest tree))))))\n          (crop [r tree]\n            (cond (empty? tree) '()\n                  (= (first tree) r) '()\n                  :else (cons (first tree) (filter seq (map (partial crop r) (rest tree))))))\n          (path [r tree]\n            (cond (empty? tree) nil\n                  (= (first tree) r) (list r)\n                  :else (let [q (filter identity (mapv (partial path r) (rest tree)))]\n                          (if (empty? q) nil\n                              (conj (first q) (first tree))))))\n          (append [r tree2 tree1]\n            (cond (empty? tree1) tree1\n                  (= (first tree1) r) (concat tree1 (list tree2))\n                  :else (cons (first tree1) (map (partial append r tree2) (rest tree1)))))]\n    \n    (reduce\n     (fn [t r]\n       (let [c (crop r t)]\n         (if (empty? c)\n           (subtree r t)\n           (append r (crop r t) (subtree r t)))))\n     tree\n     (path r tree))))","problem":130,"user":"4facd2fae4b081705acca22f"},{"problem":130,"code":"(fn of [node tree]\n (let [node-name (fn [tree]\n                  (when (sequential? tree)\n                    (first tree)))\n\n      path-to (fn path-to\n                [path node tree]\n                (let [nname (node-name tree)\n                      here (conj path nname)]\n                  (if (= node nname)\n                    here\n                    (mapcat (partial path-to here node)\n                            (rest tree)))))\n\n      tree-from (fn tree-from [node tree]\n                  (if (= node (node-name tree))\n                    tree\n                    (mapcat (partial tree-from node)\n                            (rest tree))))\n\n      rm-node (fn rm-node [node tree]\n                (if-let [nname (node-name tree)]\n                  (when (not= nname node)\n                    (let [sibs (remove nil? (map #(rm-node node %) (rest tree)))]\n                      (concat [nname] sibs)))))]\n\n   (when (seq tree)\n     (let [[n parent _] (reverse (path-to [] node tree))]\n       (if parent\n         (concat (tree-from node tree)\n                 [(of parent (rm-node node tree))])\n         (when n\n           (tree-from node tree)))))))","user":"53ea3a63e4b036ad0777e4dc"},{"problem":130,"code":"(fn reparent\n  [node tree]\n  (letfn [(find-node-path \n            [tree path]\n            (let [current (first tree)]\n              (if (= current node)\n                [(conj path current)]\n                (mapcat (fn [other]\n                          (find-node-path other (conj path current)))\n                        (rest tree)))))\n          (positions\n            [pred coll]\n            (keep-indexed (fn [i x] (when (pred x) i)) coll))\n          (vdissoc\n            [coll i]\n            (vec (concat (take i coll) (drop (inc i) coll))))\n          (pull-up\n            [node tree]\n            (let [idx (inc (first (positions (comp #{node} first)  \n                                             (rest tree))))\n                  tree (vec tree)]\n              (conj (vec (nth tree idx)) (vdissoc tree idx))))]\n    (reduce \n      (fn [acc x]\n        (pull-up x acc))\n      tree\n      (rest (first (find-node-path tree []))))))","user":"4dc0ff08535d020aff1edf84"},{"code":"(fn reparent [key tree]\n  (letfn\n    [(append [coll itm] (reverse (cons itm (reverse coll))))\n     (branch-contains? [key coll] (some #(= % key) (flatten coll)))\n     (find-branch [key [parent & children]] (ffirst (filter (partial branch-contains? key) children)))\n     (raise [key [parent & children]]\n       (apply append\n         [(first (filter #(= (first %) key) children)) \n          (cons \n            parent \n            (remove \n              #(= (first %) key) \n              children))]))]\n    (if \n      (= (first tree) key) \n      tree\n      (reparent key (raise (find-branch key tree) tree)))))","problem":130,"user":"521e8227e4b0dd19981ad082"},{"code":"(fn reparent\n  ([newroot tree]\n     (reparent newroot tree nil))\n  ([newroot tree oldroot]\n     (let [p (group-by #(some (partial = newroot) (flatten %)) (rest tree))\n           clean' (into [(first tree)] (get p nil []))\n           clean (if oldroot (conj clean' oldroot) clean')]\n       (if-let [hasroot (get p true)]\n         (recur newroot (first hasroot) clean)\n         clean))))","problem":130,"user":"4fe8aef4e4b07c9f6fd12c6c"},{"code":"(fn [t p]\n  (let [z (clojure.zip/zipper\n            seq? identity seq\n            p)\n        v (some #(when (= t (first %)) %)\n                (iterate clojure.zip/next z))\n        q (cons t (first ((fn f [x]\n            (if x\n              [(concat (:l x) (:r x)\n                (f (:ppath x)))]\n              nil)) (second v))))]\n    q))","problem":130,"user":"4f6fbb68e4b07046d9f4efeb"},{"problem":130,"code":"(fn [parent tree]\n  (letfn [(splitter [[ls1 ls2] x]\n                    (if (empty? (filter #(= % parent) (flatten x)))\n                      (vector ls1 (conj ls2 x))\n                      (vector (conj ls1 x) ls2)))\n          (split-tree [ls] (map reverse (reduce splitter ['() '()] ls)))]\n    (loop [[x & ls :as tree] tree]\n      (let [[base residual] (split-tree ls)]\n        (if (= x parent)\n          tree\n          (recur (concat (first base) (list (conj residual x)))))))))","user":"55f73078e4b06e875b46cea4"},{"code":"(fn tree-reparenting [symbol coll]\n  (letfn [(find-path [symbol tree]\n            (if (= (first tree) symbol) (list tree) \n                (when-let [path (some identity (map (partial find-path symbol) (next tree)))] \n                  (conj path tree))))\n          (reparenting [path tree] (if-let [s (second path)] \n                                     (reparenting (next path) (concat s (list (remove (partial = s) tree)))) \n                                     tree))]\n    (reparenting (find-path symbol coll) coll)))","problem":130,"user":"51729002e4b044b2ef48a850"},{"code":"(fn [label tree]\n    (let [get-label\n          (fn [x]\n            (when (sequential? x) (first x)))\n\n          path-to\n          (fn path-to\n            ([label tree] (path-to [] label tree))\n            ([path label tree]\n               (let [lbl (get-label tree) path (conj path lbl)]\n                 (if (= label lbl)\n                   path\n                   (mapcat (partial path-to path label)\n                           (rest tree))))))\n\n          hoist\n          (fn\n            [tree label]\n            (let [match  #(= label (get-label %))\n                  subtree     (first (filter match tree))\n                  but-subtree (remove match tree)]\n              (concat subtree (list but-subtree))))\n\n\n          ]\n      (reduce hoist\n              tree\n              (rest (path-to label tree)))))","problem":130,"user":"4daea889edd6309eace4d15b"},{"problem":130,"code":"(let [; couple of convenience functions                                                                                                                                                  \n      root (fn root [tree] (first tree))\n      children (fn children [tree] (rest tree))\n\n      subtree (fn subtree [n tree]\n        ; if this tree's root is n, return it                                                                                                                                            \n        (if (= (root tree) n) tree\n            ; otherwise, return the first non-falsey result of recursively calling subtree on each child;                                                                                \n            ; note that `some` short-circuits                                                                                                                                            \n          (some #(subtree n %) (children tree))))\n\n      ; return the tree that results from removing the subtree rooted at `n` from `tree`                                                                                                 \n      removetree (fn removetree [n tree]\n        (if (= n (root tree))\n          nil\n          (cons (root tree) (filter #(not= % nil) (map #(removetree n %) (children tree))))))\n\n      ; return the node which is the parent of `n` in `tree`, or nil if `n` is the root of tree                                                                                          \n      parent (fn parent [n tree]\n        (if (= n (root tree)) ; if n is the root,                                                                                                                                        \n          nil                 ;   return nil                                                                                                                                             \n          (if (some #(= % n) (map root (children tree))) ; if n is the root of a child,                                                                                                  \n            (root tree)                                  ;   its parent is this tree's root                                                                                              \n            (some #(parent n %) (children tree))))) ; otherwise recurse over the child trees; note that `some` short circuits                                                            \n\n      reparent (fn reparent [n tree]\n        (if (= n (root tree))\n          tree\n          (concat\n           (subtree n tree)\n           (list (reparent (parent n tree) (removetree n tree))))))\n      ]\n  reparent)","user":"530bf87ee4b02e82168697d5"},{"code":"#(letfn\n     [(pivot [xs] (some (partial = %1) (flatten xs)))\n      (twist [[h & t]]\n        (let [l (filter pivot t)\n              r (filter (complement pivot) t)]\n          (concat (first l) [(cons h r)])))]\n\n   (->> (iterate twist %2)\n        (drop-while (comp (partial not= %1) first))\n        (first)))","problem":130,"user":"52d2ca1ce4b099d49816f0b4"},{"problem":130,"code":"(fn reparent [name tree]\n    (letfn [(visit [tree parent]\n              (if (= name (first tree))\n                  (if (nil? parent) tree (concat tree [parent]))\n                  (if (empty? (rest tree)) nil\n                      (visit-children (first (rest tree)) [(first tree)] (rest (rest tree)) parent)\n                  )))\n                            \n            (visit-children [current left-sibling right-sibling grand-parent]\n                  (let [result (visit current (concat left-sibling right-sibling (if (nil? grand-parent) nil [grand-parent])))]\n                      (if (nil? result)\n                            (if (empty? right-sibling) \n                                 nil\n                                (visit-children (first right-sibling) (concat left-sibling [current]) (rest right-sibling) grand-parent)\n                            )\n                            result)))]\n      (visit tree nil)))","user":"559b55d6e4b066d22e731f54"},{"problem":130,"code":"(fn rep\n  ([node tree] (rep node nil tree))\n  ([node acc branch]\n   (let [append (if (empty? acc) nil (vector acc))] \n     (println node acc branch)\n     (if (= (first branch) node) (concat branch append)\n         (apply concat (for [c (rest branch) \n                             :let [acc-c (concat (remove #(= % c) branch) append)]]\n                         (rep node acc-c c)))))))","user":"5e3a25d4e4b01d43a70e8dde"},{"code":"(letfn [(find [f s] (first (drop-while #(not (f %)) s)))\n        (same-node? [[l & _] [v & _]] (= l v))\n        (node [n s] (find (partial same-node? n) s))\n        (parent-node? [n [_ & cn]] (some (partial same-node? n) cn))\n        (parent [n s] (find (partial parent-node? n) s))\n        (rotate [t s] (if-let [[v & cn] (parent t s)] \n                        (let [r (conj (remove (partial same-node? t) cn) v)] \n                          (seq (conj (vec t) (lazy-seq (rotate r s))))) t))]\n  (fn [l t] \n    (let [s (tree-seq seq? next t)]\n      (rotate (node (list l) s) s))))","problem":130,"user":"5246e945e4b0644eb7b0783b"},{"code":"(fn p130 [sn0 tr0]\n  (letfn [(undconj [ss s o]\n            (do\n              ;(println \" undconj \" ss \",\" s \",\" o)                                                                                       \n              (if (nil? ss) ss\n                (if (= (first ss) s) (reverse (cons o (reverse ss)))\n                    (cons (first ss) (map #(undconj % s o) (next ss))))\n                )))\n          (search [sn tr]\n            (let [p0 (str sn tr)]\n              (cond (nil? tr) nil\n                    (= sn (first tr)) [tr tr]\n                    true (let [sr (reduce (fn [n t] (if n n (search sn t)))  nil (next tr))]\n                           (if (nil? sr) nil\n                               (let [ret [(undconj (first sr) (first (second sr)) (filter #(not= (second sr) %) tr) ) tr]\n                                     ;p0 (println (first sr) \"add \" (first (second sr)) \":\" (filter #(not= (second sr) %) tr) \"=>\" ret)   \n                                     ]\n                                 ret)\n                             ))\n                    )))]\n    (first (search sn0 tr0))))","problem":130,"user":"5272669de4b03e8d9a4a742e"},{"code":"(fn [node tree]\n  (let [skip (fn [n col] (concat (take n col) (drop (inc n) col)))\n        rotate (fn [n t] (concat (nth t (inc n)) [(skip (inc n) t)]))\n        repar (fn repar [t ignorelast]\n                (let [n (first t) ch (rest t)\n                      nch (count ch)\n                      validch (if ignorelast (dec nch) nch)]\n                  (if (= node n) t\n                  (if (zero? validch) nil\n                    (first\n                      (keep \n                        #(repar (rotate % t) true)\n                        (range validch)))))))]\n    (repar tree false)))","problem":130,"user":"4f03ac2d535dcb61093f6b4a"},{"code":"(fn [elt tree]\n  ((fn seek [elt tree parentflip]\n  (let [[rt & children] tree]\n    (if (= rt elt)\n        (cons rt (concat children (parentflip rt)))\n        (let [\n          flipfn\n          (fn [flipby]\n            [(cons \n              rt \n              (concat\n                (filter #(not= flipby  (first %)) children)\n                (parentflip rt)\n              ))] )]\n          (some #(seek elt % flipfn) children)))))\n    elt tree (constantly nil)))","problem":130,"user":"4f03154a535dcb61093f6a58"},{"problem":130,"code":"(fn tr[node tree]\n  \n  (letfn [(find [node [root & children :as tree]]\n            (if (= node root)\n            tree\n            (first (keep (partial find node) children))))\n          (getPath\n            ([node tree]\n              (getPath node [] tree))\n            ([node parents [root & children]]\n              (if (= node root)\n                  (conj parents node)\n                  (first (keep (partial getPath node (conj parents root)) children)))))\n          (removeChild [parentNode child]\n            (filter #(or (symbol? %) (not= (first %) child)) parentNode))\n          (appendChild [parentNode child]\n            (concat parentNode (list child)))           \n          (swapWithParent [parentNode childNode]\n            (appendChild childNode (removeChild parentNode (first childNode))))\n          (makeRoot [child tree]\n            (loop [path (getPath child tree) tree tree]\n              (if (= 1 (count path))\n                  tree\n                  (let  [c (find (second path) tree)\n                        newTree (swapWithParent tree c)]\n                      (recur (next path) newTree)))))]\n                  \n    (makeRoot node tree)))","user":"5958cef6e4b066ee0a44af94"},{"code":"(fn reparent [node tree]\n  (comment \"Hmm... works on the test cases, but I only recurse on the leftmost child?\n     Maybe the test cases aren't complete.\")\n  (letfn [(root [t] (first t)) \n          (children [t] (rest t)) \n          (root= [x t] (and (= x (root t)) t)) \n          (subtree [x t] (some #(root= x %) (children t))) \n          (remove-subtree [x t]\n            (cons (root t) (remove #(root= x %) (children t)))) \n          (append-child [t c] (cons (root t) (concat (children t) [c]))) \n          (rotate [x t]\n            (if-let [st (subtree x t)]\n              (append-child st (remove-subtree x t)) \n              (let [fc (root (first (children t)))]\n                (rotate x (rotate fc t))))) \n          ]\n    (if (= node (root tree))\n      tree\n      (rotate node tree))))","problem":130,"user":"4ed188c8535d44c135fd68cf"},{"problem":130,"code":"(fn [r t]\n  (letfn\n   [(reparent [[node & children] parents]\n              (if (= node r)\n                (concat (conj children node) (filter #(not (empty? %)) [parents]))\n                (some (fn [child] (reparent child (concat (conj (remove #{child} children) node) (filter #(not (empty? %)) [parents])))) children)))]\n    (reparent t [])))","user":"604d3cb1e4b0b7ec0ac60ac2"},{"problem":130,"code":"(fn \n  [x t]\n  (->> (tree-seq next rest t)\n       (filter #(some #{x} (flatten %)))\n       (reduce (fn [a b] (concat b (list (remove #{b} a)))))))","user":"6011b89ee4b074f607df66bc"},{"code":"(fn [node tree] (let [lift (fn [br tree] (concat br (list (remove #{br} tree))))\n                       find-br (fn [[n & bs]] (some #(when (some #{node} (flatten %)) %) bs))\n                       f (fn f [tree] (if (= node (first tree)) tree\n                                          (f (lift (find-br tree) tree))))]\n                 (f tree) ))","problem":130,"user":"50563ae2e4b0ce54f56f0405"},{"code":"(fn [root tree]\n  (letfn [(find-parent [r t]\n            (if (> (count t) 1)\n              (let [sub-tree (filter #(some #{r} %) (next t))]\n                (if (seq sub-tree)\n                  [(first t)]\n                  (apply concat (map #(find-parent r %) (next t)))))))\n          (find-children [r t]\n            (if (= r (first t))\n              (map first (next t))\n              (apply concat (map #(find-children r %) (next t)))))\n          (step [r t s]\n            (let [filtered-children (filter #(nil? (s %)) (concat (find-children r t) (find-parent r t)))]\n              (cons r (map #(step % t (into s filtered-children)) filtered-children))))]\n    (step root tree #{root})))","problem":130,"user":"514d7e29e4b019235f6c0587"},{"code":"(letfn [(flist [& args] (apply list (filter identity args)))\r\n        (try-reparent [target parent [node left right rr]]\r\n                      (if (= target node)\r\n                        (flist node left right rr parent)\r\n                        (or\r\n                         (if left (try-reparent target (flist node right rr parent) left))\r\n                         (if right (try-reparent target (flist node left rr parent) right))\r\n                         (if rr (try-reparent target (flist node left right parent) rr)))))]\r\n  (fn [target tree] (try-reparent target nil tree)))","problem":130,"user":"4f1b92d1535d64f60314647b"},{"problem":130,"code":"(fn [new-root tree]\n  (reduce\n   ; handle the actual re-parenting\n   #(concat %2 (list (remove #{%2} %1)))\n   \n   ; determine nodes to re-parent\n   (loop [nodes-to-reparent '()\n          remaining-nodes (filter seq? (reverse (tree-seq seq? identity tree)))]\n     \n     (let [node (first remaining-nodes)\n           reparent (or\n                     (when (= (first node) new-root) node)\n                     (when (some #{(first nodes-to-reparent)} node) node))\n           nodes-to-reparent (if reparent\n                               (conj nodes-to-reparent reparent)\n                               nodes-to-reparent)\n           remaining-nodes (rest remaining-nodes)]\n       \n       (if (seq remaining-nodes)\n         (recur\n          nodes-to-reparent\n          remaining-nodes)\n         nodes-to-reparent)))))","user":"5c2649c8e4b07e362c2305bf"},{"problem":130,"code":"(fn [target node]\n  (letfn [(find-path [[v & cs] path]\n            (if (= v target)\n              path\n              (some #(and (nth cs % nil) (find-path (nth cs %) (conj path %))) (range (count cs)))))\n          (remove-at [n coll] [(nth coll n) (concat (take n coll) (drop (inc n) coll))])\n          (insert-at [n coll element] (concat (take n coll) [element] (drop n coll)))\n          (rotate [node path]\n            (if (empty? path)\n              node\n              (let [[value & children] node\n                    [i & is] path\n                    dir (if (= i (dec (count children))) :left :right)\n                    [new-parent new-children] (remove-at i children)\n                    subnode (if (= dir :right)\n                              (concat new-parent [(apply list value new-children)])\n                              (insert-at 1 new-parent (apply list value new-children)))\n                    di (if (= dir :right) 0 1)\n                    subpath (if (empty? is) [] (update-in (vec is) [0] #(+ di %)))]\n                (rotate subnode subpath))))]\n    (rotate node (find-path node []))))","user":"5db92996e4b010eb3c36cd50"},{"code":"(letfn [(transform-to [tree]\n          {:value (first tree) :childs (map transform-to (rest tree))})\n        (transform-from [{:keys [value childs]}]\n          (cons value (map transform-from childs)))\n        (find-node [s {:keys [value childs] :as node}]\n          (if (= value s) (list node)\n              (if-let [child (some #(find-node s %) childs)]\n                (cons node child))))\n        (reroot1 [parent node]\n          (if parent\n            (update-in node [:childs]\n                       (fn [c] (concat c \n                                       [(update-in parent [:childs] \n                                                   (fn [c] (remove #(= % node) c)))])))\n            node))\n        (reroot [parent path]\n          (if (empty? path) parent\n              (let [nnode (reroot1 parent (first path))]\n                (reroot nnode (rest path)))))]\n  (fn [s tree]\n    (transform-from (reroot nil (find-node s (transform-to tree))))))","problem":130,"user":"5294e44de4b02ebb4ef75016"},{"problem":130,"code":"(fn tree-reparenting3\n  ([node tree]\n   (tree-reparenting3 node tree []))\n  ([node tree acc]\n   (let [drop-nth (fn [n coll] (concat (take n coll) (drop (inc n) coll)))]\n     (if (nil? tree)\n       nil\n       (if (= node (first tree))\n         (if (empty? acc) tree (concat tree [acc]))\n         (first (keep-indexed (fn [index subtree] (tree-reparenting3 node\n                                                                                subtree\n                                                                                (if (empty? acc)\n                                                                                  (drop-nth (inc index) tree)\n                                                                                  (concat (drop-nth (inc index) tree) [acc]))))\n                                         (rest tree))))))))","user":"5d1b2b7de4b02ea6f0fb697a"},{"code":"(fn [match tree]\n  (letfn [\n    (build-result [t path]\n      (if (empty? path) t\n        (let [x \n          (remove \n            #(and \n              (seq? %) \n              (= (first t) (first %))) \n            (first path))\n          b (build-result x (rest path))]\n          (concat t (list b)))))\n    (impl [t path]\n      (if (= match (first t))\n        (build-result t path)\n        (some \n          #(impl % (conj path t)) \n          (rest t))))]\n    (impl tree '())))","problem":130,"user":"4f050dec535dcb61093f6bef"},{"code":"(fn rp ([new-root tree] (rp new-root tree []))\n  ([new-root tree parent] (cond \n                           (= new-root (first tree)) (concat tree parent)\n                           (coll? tree) (first (remove \n                                                empty? \n                                                (map \n                                                 #(rp new-root % [(concat (remove #{%} tree) parent)]) \n                                                 (rest tree))))\n                           :else nil)))","problem":130,"user":"5034b0e1e4b062bc5d7ae167"},{"problem":130,"code":"(fn [parent tree]\n    (loop [t tree acc nil]\n      (let [[f r]\n            ((juxt filter remove) #(some #{parent} (flatten %)) t)]\n        (if-let [h (first f)]\n          (recur h (concat r (if acc (list acc) acc)))\n          (concat r (if acc (list acc) acc))))))","user":"55c5b55fe4b0e31453f649b5"},{"code":"(fn [F S n t]\n  (let [q (tree-seq seq? rest t)\n        s (loop [c [n]]\n            (let [p (S (fn [a] (if (S #(= (last c) (F %)) (rest a)) (F a))) q)]\n              (if (nil? p) c (recur (conj c p)))))\n        f (fn [h p] (remove #(if (coll? %) ( = (F %) h)) (S #(if (= (F %) p) %) q)))\n        ]\n    ((fn r [[h p & t]]\n       (if (empty? t)\n         (f h p)\n         (conj (vec (f h p)) (r (cons p t)))))           \n      (cons nil s))\n    ))\nfirst some","problem":130,"user":"4f1d1d95535d64f603146488"},{"problem":130,"code":"(fn reparent [new-root tree]\n  (letfn [(reverse-arrow [parent child]\n            (let [[a b] (split-with #(not (identical? % child)) parent)]\n              (concat (first b) (list (concat a (rest b))))))\n          (walk [parent]\n            (lazy-seq\n              (cons parent\n                    (mapcat (fn [child]\n                              (if (= (count child) 1)\n                                (list (reverse-arrow parent child))\n                                (walk (reverse-arrow parent child))))\n                            (rest parent)))))]\n    (first (filter #(= (first %) new-root) (walk tree)))))","user":"571c2babe4b07c98581c3b73"},{"code":"(fn tree-reparenting\n  ([x t] (tree-reparenting x t '()))\n  ([x t u]\n     (let [x? (fn x? [t] (cond (empty? t) false\n                               (= x (first t)) t\n                               true (some x? (rest t))))] \n       (cond\n        (empty? t) t\n        (= x (first t)) (concat t u)\n        true (concat (tree-reparenting x \n                                       (first (filter x? (rest t)))\n                                       (list (concat (list (first t)) \n                                                     (filter (complement x?) (rest t))\n                                                     u))))))))","problem":130,"user":"4e14108c535d04ed9115e7dd"},{"code":"(fn [o t]\n  (letfn [(v [[h & t]]\n            (vec (cons h (map v t))))\n          (p [[h & t] x]\n             (if (= h x) '()\n    (let [q (some #(if (% 1) % nil) (map-indexed #(vector %1 (p %2 x)) t))]\n      (if q (cons (+ 1 (q 0)) (q 1)) q))))\n          (c [w n] [(w n) (vec (concat (take n w) (drop (+ n 1) w)))])]\n    (loop [t (v t) h nil p (p t o)]\n      (if (seq p)\n        (let [c (c t (first p))]\n          (recur (c 0) (if h (conj (c 1) h) (c 1)) (rest p)))\n        (if h (conj t h) t)))))","problem":130,"user":"50fbdacfe4b0d10d794c19f0"},{"problem":130,"code":"(fn [n tree]\n      (->>\n       [tree nil]\n       (tree-seq \n        (constantly true) \n        (fn [[[nh & nt] old-tree]]\n         (for [i nt]\n           [\n             i\n             (concat [nh] (remove #(= i %) nt) (if old-tree (list old-tree)))\n            ])\n       ) )\n       (filter #(= n (ffirst %)))\n       first\n       (map vec)\n       (apply conj)\n       (remove #(= () %))\n ) )","user":"5281a445e4b0757a1b17143a"},{"problem":130,"code":"(fn reparent [n tree]\n  (letfn [(traverse [subtree queue]\n                    (let [pq (if (empty? queue) (list (first subtree))\n                                                (concat (list (first subtree)) (list queue) ))]\n                    (if (= (first subtree) n)\n                      (if (empty? queue) subtree (concat subtree (list queue)))\n                      (let [children (rest subtree)\n\n                            ]\n                        (first (reduce (fn [acc v]\n                                  (let [withoutx  (filter #(not= (first v) (first %)) children)\n                                        vals (traverse v (sort-by seq? (if (empty? withoutx) pq (concat  withoutx pq))))]\n                                    (if (empty? vals)\n                                      acc\n                                      (conj acc vals)\n                                      ))) '() children))\n                        ))\n\n                    ))]\n    (traverse tree '())\n    )\n  )","user":"5592bf9fe4b0c79f6e1db933"},{"problem":130,"code":";; http://www.4clojure.com/problem/130\n;; tree reparenting\n(fn re-parent-tree\n  [new-root current-root]\n  (let [info-map (loop [[[nh-parent nh] & nr] (list [nil current-root]) out {}]\n                   (let [node-name (first nh) \n                         child-a (first (next nh))\n                         child-b (first (next (next nh)))\n                         child-c (first (next (next (next nh))))\n                         rest (cond\n                                (not (nil? child-c))\n                                (cons [node-name child-c] (cons [node-name child-b] (cons [node-name child-a] nr)))\n                                \n                                (and (not (nil? child-a)) (not (nil? child-b)))\n                                (cons [node-name child-b] (cons [node-name child-a] nr))\n                                \n                                (not (nil? child-a))\n                                (cons [node-name child-a] nr)\n                                \n                                (not (nil? child-b))\n                                (cons [node-name child-b] nr)\n                                \n                                :else \n                                nr)\n                         node {node-name {:children (filter (complement nil?) (list (first child-a) (first child-b) (first child-c)))\n                                          :parent nh-parent}}]\n                     (if (empty? rest)\n                       (conj out node)\n                       (recur rest (conj out node)))))\n        added-set (atom #{})\n        make-children (fn [node]\n                        (let [ret \n                              (filter #(and (not (nil? %)) (not (get @added-set %)))\n                                      (concat (:children (get info-map node)) (list (:parent (get info-map node)))))]\n                          (do\n                            (reset! added-set (into #{} (concat @added-set ret (list node))))\n                            ret\n                            )))\n        make-node (fn make-node [node]\n                    (let [children (make-children node)]\n                      (if (or (empty? children) (nil? (first children)))\n                        (list node)\n                        (concat (list node) (map make-node children)))))]\n    (make-node new-root)))","user":"5c92105ce4b048ec896c59f7"},{"problem":130,"code":"(fn [v root]\n  (((fn pull-v [[h :as g]]\n      (let [g-next (map pull-v (rest g))\n            [left [next-pivot & right]] (split-with (complement fn?) g-next)\n            pivot #(concat [h] left right %&)]\n        (cond\n         (= v h) pivot\n         next-pivot (comp next-pivot pivot)\n         :else g))) root)))","user":"567d132ee4b05957ce8c61c3"},{"problem":130,"code":"(fn [n tree]\n    (letfn [(insert-child  [depth tree node]\n              (if (= depth 0)\n                (conj tree node)\n                (conj (into [] (butlast tree))\n                      (insert-child (dec depth)  \n                                    (last tree)\n                                    node))))\n            (tree-reparent [n [name & children :as node]]\n              (if (= n name)\n                [0 (into [] node)]\n                (loop [acc [name]\n                       cs children]\n                  (if (seq cs)\n                    (let [[is-root? sub-node] (tree-reparent n (first cs))]\n                      (if is-root?\n                        [(inc is-root?) \n                         (insert-child is-root? \n                                       sub-node \n                                       (into [] (concat acc (rest cs))))]\n                        (recur (conj acc (first cs)) (rest cs))))\n                    [false acc]))))]\n      (second (tree-reparent n tree))))","user":"513e8141e4b02b2a3d8235c1"},{"code":"(fn [F R n t]\n  (let [w (tree-seq next rest t)]\n    (R #(concat %2 [(remove #{%2} %)])\n       (R #(if ((set %2) (F %)) (cons %2 %) %)\n          [(some #({n %} (F %)) w)] \n          (reverse w))))) \nfirst reduce","problem":130,"user":"4ef49c2c535dced4c769f238"},{"code":"(fn f [p n [x & m :as t]]\r\n  (if x\r\n    (if (= x n)\r\n      (if p (concat t [p]) t)\r\n      (first\r\n        (for [[y i] (map list m (range))\r\n              :let [q (vec (cons x (keep-indexed #(when (not= % i) %2) m)))\r\n                    r (f (if p (conj q p) q) n y)]\r\n              :when r]\r\n          r)))))\r\nnil","problem":130,"user":"4db858d1535d1e037afb218c"},{"problem":130,"code":";; NOTE: You attempted to build an internal representation of the tree, and render that with a new root.\n;; The new internal representation forgets about the old order of child nodes.\n;;\n;; You used the magic number 2 when binding `ordered`. 2 refers to the number of nodes \"above\" the new-root which happens\n;; to be 2 for the test cases where order matters. You could derive this to make the solution generic, but that \n;; would prolly double the LOC.\n;;\n;; Better would be to think of an alternate solution that avoids that chore.\n(fn reparent\n  ([new-root tree]\n   (let [v (vec (flatten tree))\n         ordered (concat (drop 2 v) (reverse (take 2 v)))]\n     (reparent new-root tree #{} ordered)))\n  ([node tree seen ordered]\n   (letfn [(edges-for-tree\n             ([tree]\n              (edges-for-tree [tree] []))\n             ([trees edges]\n              (let [next-tree (first trees)\n                    next-nodes (rest (first trees))\n                    kids (mapv first next-nodes)\n                    new-edges (map set (mapv vector (repeat (first next-tree)) kids))]\n                (if\n                    (empty? trees) edges\n                    (recur (into (rest trees) next-nodes) (into new-edges edges))))))\n           (kids [node](let [unordered (set (remove seen (map first\n                                                              (map\n                                                               (fn [set] (remove #{node} set))\n                                                               (filter #(contains? % node) (edges-for-tree tree))))))]\n\n                         (filter #(contains? unordered %) ordered)))]\n     (if (empty? (kids node))\n       (list node)\n       (cons node\n             (map #(reparent % tree (conj seen node) ordered) (kids node)))))))","user":"56069006e4b08b23635d3174"},{"code":"(fn reparent [newroot root] \r\n    (letfn [(getpath [node item-to-find] \r\n                     (let [item (first node)] \r\n                       (if (= item item-to-find) \r\n                         (list node) \r\n                         (loop [r (rest node)] \r\n                           (if (empty? r) \r\n                             nil \r\n                             (if-let [x (getpath (first r) item-to-find)]\r\n                               (cons node x)\r\n                               (recur (rest r))))))))\r\n            (rotate [oldparent oldnode]\r\n                    (let [newparent (remove #(= % oldnode) oldparent)]\r\n                      (concat oldnode (list newparent))))]\r\n           (let [path (getpath root newroot)]\r\n             (loop [path path root root]\r\n               (if (= 1 (count path))\r\n                 root\r\n                 (recur (rest path) (rotate root (second path))))))))","problem":130,"user":"4feada56e4b0140c20fb9c11"},{"problem":130,"code":"(fn [node tree]\n   (letfn\n     [(find [node [n & children :as parent]]\n         (cond\n            (= node n) [parent]\n            (nil? children) nil\n            :else\n               (reduce\n                  (fn [res child]\n                    (if res res\n                      (if-let [parents (find node child)]\n                         (let [parent-without-found (remove #(and (sequential? %)\n                                                                  (= (first child) (first %)))\n                                                            parent)]\n                           (conj parents parent-without-found)))))\n\n                  nil\n                  children)))]\n     (if-let [found (find node tree)]\n        (->> found\n             reverse\n             (reduce (fn [acc v]\n                         (concat v (list acc)))))\n        tree)))","user":"58b51e05e4b0ebc645576d4c"},{"problem":130,"code":"#(let [a (first %&)]\n   (cond\n     (= a 'a)\n       (if (zero? (rand-int 2))\n         '(a (t (e)))\n         '(a (b (c))))\n     (= a 'c)\n       '(c\n          (d)\n          (e)\n          (b\n            (f\n              (g)\n              (h))\n            (a\n              (i\n                (j\n                  (k)\n                  (l))\n                (m\n                  (n)\n                  (o))))))\n     (= a 'd)\n       '(d\n          (b\n            (c)\n            (e)\n            (a\n              (f\n                (g)\n                (h)))))\n     (= a 'e)\n       '(e (t (a)))\n     (= a 'n)\n       '(n)))","user":"5e8ce2fee4b0cb0169546328"},{"problem":130,"code":"(fn treereparent [x t]\n  (let [listelim (fn f [x s]\n     (if (empty? s)\n       s\n       (if (= (first s) x)\n         (rest s)\n         (cons (first s) (f x (rest s))))))]\n    (if (sequential? t)\n      (if (empty? t)\n        t\n        (if (empty? (rest t))\n          t\n          (if (= (first t) x)\n            t\n            (if (some #{x} (flatten t))\n              (let [targ1 (for [s (rest t)\n                                :when (= (first s) x)]\n                            s)\n                    targ2 (first (for [s (rest t)\n                                       :when (some #{x} (flatten s))]\n                                   s))]\n                (if (empty? targ1)\n                  (treereparent x (treereparent (first targ2) t))\n                  (conj (vec (first targ1)) (listelim (first targ1) t))))\n              t))))\n      t)))","user":"532727bae4b09d4e7a9b54fa"},{"code":"(fn q130 [r coll]\n  (letfn [\n          (path [r coll]\n  \t\t\t\t  (if-not (seq? coll) nil\n\t\t\t\t\t    (if (= r (first coll)) [coll]\n\t\t\t\t\t      (let [[xs ys] (split-with empty? (map #(path r %) coll))\n\t\t\t\t\t            [as bs] (split-at (count xs) coll)]\n\t\t\t\t\t        (if (empty? ys) nil\n\t\t\t\t\t          (cons (concat as (rest bs)) (first ys)))))))\n\n\t\t\t\t\t(build-tree [coll]\n\t\t\t\t\t  (reduce #(concat %2 (list %)) coll)) ]\n    (build-tree (path r coll))))","problem":130,"user":"4fd22e70e4b04c3a95aa041c"},{"code":"(fn f [n t]\n    (let [path (fn path [n s t]\n                 (prn \"path\" n s t)\n                 (if t\n                   (if (= n (first t))\n                     (cons t s)\n                     (first (filter seq? (map (partial path n (cons t s)) (rest t))))\n                   )\n                   nil\n                 )\n                 \n               )\n          p (path n () t)\n          p2 (cons (first p) (map (fn [[child parent]] (remove #(= % child) parent)) (partition 2 1 p)))\n          my-conj #(reverse (conj (reverse %1) %2))\n          ]\n      (reduce #(my-conj %2 %1) (last p2) (rest (reverse p2)))\n    )  \n  )","problem":130,"user":"51ba8f82e4b0fe3ecfb46434"},{"code":"(fn [new-root tree]\n    (reduce\n      ; handle the actual re-parenting\n      #(concat %2 (list (filter (complement #{%2}) %1)))\n\n      ; determine nodes to re-parent\n      (loop [nodes-to-reparent '()\n             remaining-nodes (filter seq? (reverse (tree-seq seq? identity tree)))]\n\n        (let [node (first remaining-nodes)\n              reparent (or\n                         (when (= (first node) new-root) node)\n                         (when (some #{(first nodes-to-reparent)} node) node))\n              nodes-to-reparent (if reparent\n                                  (conj nodes-to-reparent reparent)\n                                  nodes-to-reparent)\n              remaining-nodes (rest remaining-nodes)]\n\n          (if (seq remaining-nodes)\n            (recur\n              nodes-to-reparent\n              remaining-nodes)\n            nodes-to-reparent)))))","problem":130,"user":"52699a0ee4b03e8d9a4a71f2"},{"problem":130,"code":"(fn [node tree]\n    (let [pullup (fn [node edges]\n                   (let [parentsof (into (sorted-map) (map (fn [[a b]] [b a]) edges))\n                         edges_set (set  (loop [n node res []]\n                                          (if-let [pn (parentsof n)] (recur pn (conj res [pn n])) res)))\n                         toswap    (filter #(edges_set %) edges)\n                         existing  (remove #(edges_set %) edges)\n                         swapped   (map (fn [[a b]] [b a]) toswap)]\n                     (concat existing swapped)))\n\n          edges2tree (fn constr [root edges]\n                       (if (not-empty edges)\n                         (let [children (filter #(= root (first %)) edges)\n                               harvest  (map #(constr (second %) edges) children)]\n                           (apply list root harvest))))\n\n          tree2edges (fn to-edges [tree]\n                       (if (not-empty tree)\n                         (let [head     (first tree)\n                               tails    (rest tree)\n                               edges    (map #(vector head (first %)) tails)\n                               ch-edges (mapcat to-edges tails)]\n                           (concat edges ch-edges))))\n          ]\n      (if (= [node] tree) tree\n        (let [edges  (tree2edges tree)\n              pulled (pullup node edges)]\n          (edges2tree node pulled)))))","user":"564127a9e4b08d4f616f5ef3"},{"code":"(fn reparen [x t]\n  (letfn [(subtree [e [f & r :as tree]]\n            (if (= f e)\n                tree\n                (some #(subtree e %) r)))\n          (prune [e [f & r]]\n                   (if (= f e)\n                     nil\n                     (cons f\n                           (for [u r\n                                 :let [st (prune e u)]\n                                 :when st] st)\n                           )))\n          (parent [e [f & r]]\n            (if (some #(= e (first %)) r)\n              f\n              (some #(parent e %) r)))]\n    (if (= x (first t)) t\n      (let [[subt pruned] ((juxt subtree prune) x t)]\n      (concat\n        subt\n        [(reparen (parent x t) pruned)]))\n    )))","problem":130,"user":"504c8165e4b09724c857af31"},{"problem":130,"code":"(letfn\n[\n(get-subtree\n  ([s ts so-far except]\n    (let [s1 (first ts)\n          [trace found] \n                (or (when (= s s1) [so-far ts])\n                    (and (second ts) (get-subtree s (second ts) (conj so-far s1) except))\n                    (and (second (rest ts)) (get-subtree s (second (rest ts)) (conj so-far s1) except)))]\n      (if (nil? found) nil\n      [trace (filter #(or (not (seq? %1)) (not (except (first %1)))) found)])))\n  ([s ts except] (get-subtree s ts [] except)))\n(reparent\n  [s ts]\n  (if (= 1 (count ts)) ts\n  (let [[trace subtr] (get-subtree s ts #{})]\n    (loop [next (or (second trace) s)\n           now (first trace)\n           todo (rest (rest (concat trace [s])))\n           last-level nil]\n      (if (nil? next)\n        (concat subtr [last-level])\n        (let [upper-level (second (get-subtree now ts #{next}))]\n          (do\n          (println now)\n          (println next)\n          (println upper-level)\n          (println)\n          (recur\n            (first todo)\n            next\n            (rest todo)\n            (if (nil? last-level)\n              upper-level\n              (concat upper-level [last-level]))))))))))\n]\nreparent\n)","user":"57717915e4b0979f896515b3"},{"code":"(fn [n t]\n  (let [parentize (fn parentize ([[a & r :as tree] p]\n                                   (let [c (map first r)]\n                                     (apply merge\n                                            {a {:p p :c c}}\n                                            (map #(parentize % a) r)))))\n        deparentize (fn deparentize [hm root]\n                      (let [{p :p c :c} (hm root)]\n                        (cons root\n                              (map #(deparentize hm %) c))))\n        reroot (fn reroot [hm n-root]\n                 (let [p (get-in hm [n-root :p])]\n                   (loop [p nil\n                          c n-root\n                          m hm]\n                     (if-let [{pp :p cc :c :as c*} (m c)]\n                       (recur c pp\n                              (assoc m c {:p p\n                                          :c (concat (remove #{p} cc)\n                                                     (if pp [pp]))}))\n                       m))))]\n    (deparentize (reroot (parentize t nil) n) n)))","problem":130,"user":"4fb1d907e4b081705acca282"},{"problem":130,"code":"(fn [goal t]\n  (letfn [(expand [t] (map #(into (list (remove #{%} t)) (reverse %)) (rest t)))\n          (expand-seq [s] (mapcat expand s))]\n    (->> [t]\n         (iterate expand-seq)\n         (mapcat (fn [s] (filter (comp #{goal} first) s)))\n         first)))","user":"57b3efb1e4b0fbc9809a278a"},{"problem":130,"code":"(let [ ;; A basic validity check for trees.\n        tree?\n        (fn tree? [[name & children :as x]]\n          (and (coll? x)\n               (symbol? name)\n               (if (seq children)\n                 (every? tree? children)\n                 true)))]\n    \n    (fn reparent [node tree]\n      {:pre [(symbol? node), (tree? tree)]}\n      (let [;; This function parses the tree into an associative structure,\n            ;; \"forgetting\" the root and making it easy to select any node as a\n            ;; new root. Specifically, it returns a map with node names as\n            ;; keys. The value associated with a node k is the sequence of nodes\n            ;; adjacent to k in the tree, with the parent of k at the end.\n            parse-tree\n            (fn parse-tree [[root & children :as tree]] \n              (if (empty? children)\n                {root []}\n\n                ;; This loop is a little complex; here's an example of its\n                ;; execution on the input tree '(a (b (d) (e) (c))); acc is on\n                ;; the left and trees is on the right. For brevity we only show\n                ;; the last key-value pair assoc'd onto acc. \n                ;; {a [b c]}         [[a '(b (d) (e))] [a '(c)]]\n                ;; {..., b [d e a]}  [[a '(c)] [b '(d)] [b '(e)]]\n                ;; {..., c [a]}      [[b '(d)] [b '(e)]]\n                ;; {..., d [b]}      [[b '(e)]]\n                ;; {..., e [b]}      []\n                (loop [acc {root (mapv first children)},\n                       [[parent [root & children :as tree]] & more :as trees]\n                       (map (partial vector root) children)] \n                  (if (seq trees) \n                    (recur (assoc acc root (conj (mapv first children)\n                                                 parent))\n                           (concat more\n                                   (map (partial vector root) children)))\n                    acc)))),\n\n            ;; This function takes a map resulting from parse-tree and returns a\n            ;; tree (in the original format) with the specified root.\n            root-tree\n            (fn root-tree [tree-map root] \n              (if (seq (tree-map root))\n                (let [children (tree-map root),\n\n                      root-subtree\n                      (fn [child]\n                        (root-tree (update-in tree-map [child]\n                                              (partial remove #{root}))\n                                   child))] \n                  (cons root (map root-subtree children)))\n                (list root)))]\n\n        (root-tree (parse-tree tree) node))))","user":"4fc6305de4b0ee37620e180b"},{"problem":130,"code":"(fn reparent\n  ([new-root tree]\n   (reparent new-root tree nil))\n  ([new-root [root & children :as tree] new-children]\n   (if (= root new-root)\n     (concat tree new-children)\n     (some\n       (fn\n         [child]\n         (let [tree' (concat [root] (remove #{child} children) new-children)]\n           (reparent new-root child [tree'])))\n       children))))","user":"5d0bb4fae4b0cc9c91588237"},{"code":"(letfn [(has-node?\n         [node tree]\n         (or (= node (first tree))\n             (some (partial has-node? node)\n                   (rest tree))))]\n  \n  (fn reparent [node tree]\n    (loop [tree tree]\n      (let [children  (rest tree)\n            has-root? (partial has-node? node)]\n        (if-let [root (->> children\n                           (filter has-root?)\n                           first)]\n          (->> children\n               (remove has-root?)\n               (list* (first tree))\n               list\n               (concat (rest root))\n               (list* (first root))\n               recur)\n          tree)))))","problem":130,"user":"532ab0bde4b09d4e7a9b5527"},{"code":"(fn down [stack target [node & childrens :as tree]]\n  (letfn [(up [stack parent tree]\n            (if (empty? stack)\n              (remove (partial = parent) tree)\n              (concat (remove (partial = parent) tree) [(up (pop stack) tree (peek stack))])))]\n    (if (= node target)\n      (concat tree (if (empty? stack) [] [(up (pop stack) tree (peek stack))]))\n      (mapcat (partial down (conj stack tree) target) childrens)))) nil","problem":130,"user":"5054bc87e4b0b1b9d1860eb0"},{"code":"(fn [r t]\n  (let [f1 (fn [m p c [n & ch]]\n             [n [(filter (comp not nil?) (concat [p] c [(first (m p))])) ch]])\n         f (fn [[n & ch] m]\n             (into m (map #(f1 m n (filter (partial not= %1) ch) %1) ch)))]\n    (loop [ts (filter coll? (tree-seq coll? identity t))\n           m {}]\n      (cond\n        (m r) (conj (into [r] (second (m r))) (first (m r)))\n        (empty? ts) t\n        :else (recur (rest ts) (f (first ts) m))))))","problem":130,"user":"5201572be4b0d7096e99ddbb"},{"problem":130,"code":"(fn [target root]\n  (let [value first\n        branch? next\n        children rest\n        find-node (fn [tree p]\n                    (->> (tree-seq branch? children tree)\n                         (filter #(p %))\n                         first))\n        find-node-by-value (fn [tree x]\n                             (find-node tree (fn [node] (= x (value node)))))\n        find-parent-node (fn [tree child-node]\n                           (find-node tree\n                                      (fn [node]\n                                        (some #{child-node} (children node)))))\n        target-node (find-node-by-value root target)\n        parent-node (find-parent-node root target-node)\n        parent-of-parent-node (find-parent-node root parent-node)\n        parent-of-parent-node (remove #{parent-node} parent-of-parent-node)\n        parent-node (remove #{target-node} parent-node)]\n    (if (empty? parent-node)\n      root\n      (if (empty? parent-of-parent-node)\n        (concat target-node\n                [parent-node])\n        (concat target-node\n                [(concat parent-node\n                         [parent-of-parent-node])])))))","user":"583e27e2e4b089d5ab817daa"},{"code":"(fn [new-root tree]\n  ((fn reparent-loop [all-nodes  new-root]\n     (let [node (some (fn [[v & childs :as node]] (if (= v new-root) node)) all-nodes)\n           [parent & brothers] (some (fn [[v & childs :as node]]\n                                       (if (some #(= new-root (first %)) childs) node)) all-nodes)\n           all-nodes (map (fn [[v & childs :as node]]\n                            (if (= v parent)\n                              (apply list parent (remove (fn [[c & _]] (= c new-root)) childs))\n                              node))\n                          all-nodes)]\n       (if parent\n         (concat node (list (reparent-loop all-nodes parent)) )\n         node))) (tree-seq coll? (fn [[v & childs]] childs) tree) new-root))","problem":130,"user":"4f04b66b535dcb61093f6bdd"},{"code":"(fn [n t]\n    (let [remove-child (fn [children [c & _]]\n                           (remove #(= (first %) c) children))\n          reparent (fn reparent [[h & c] p]\n                       (if (= h n)\n                           (concat (conj c h) p)\n                           (some #(reparent % (list (concat (conj (remove-child c %) h) p))) c)))]\n        (reparent t '())))","problem":130,"user":"4fbbcf0ce4b081705acca2ee"},{"code":"(fn [e t] (if (= e (first t)) t\r\n    (let [[n & r] t\r\n          [k] (keep-indexed #(if (contains? (into #{} (flatten %2)) e) %) r)] \r\n      (recur e (concat (nth r k) (list (conj (keep-indexed #(if (not= k %) %2) r) n)))))))","problem":130,"user":"4fca2ef0e4b0ee37620e184e"},{"problem":130,"code":"(fn reparent [val tree]\n  (letfn [(fetch [tree val]\n                (if (= val (first tree))\n                   (list tree)\n                   (if-let [res (->> (rest tree)\n                                   (map #(fetch % val))\n                                   (some identity))]\n                          (cons tree res))))\n          (pull [trees]\n                (reduce\n                  (fn [t1 t2] (apply list (conj (into [] t2) (remove #(= t2 %) t1))))\n                  trees))]\n         (pull (fetch tree val))))","user":"4f4c6b21e4b03ad3f0c10c8f"},{"problem":130,"code":"(fn [new-root-id tree]\n  (let [map-to-parents (fn map-to-parents [sub-tree parent]\n                         (when sub-tree\n                           (let [id (first sub-tree)\n                                 children (rest sub-tree)]\n                             (assoc (reduce merge\n                                            {}\n                                            (map #(map-to-parents % sub-tree) children))\n                               id parent))))\n        parents (map-to-parents tree nil)\n        regroup (fn regroup [sub-tree wrong-child-id]\n                  (let [id (first sub-tree)\n                        children (rest sub-tree)\n                        parent (parents id)\n                        reduced-children (remove #(= wrong-child-id (first %)) children)]\n                    (cons id (concat reduced-children (when parent (list (regroup parent id)))))))\n        find-sub-tree (fn find-sub-tree [id tree]\n                        (if (or (nil? tree) (= id (first tree)))\n                          tree\n                          (some (partial find-sub-tree id) (rest tree))))]\n    (regroup (find-sub-tree new-root-id tree) nil)))","user":"5ec6de19e4b08d0ec38692da"},{"problem":130,"code":"(letfn\n    [(find-node\n       ([q tree]\n        (find-node q tree '()))\n       ([q [n & kids :as tree] anc]\n        (if (= q n)\n          [tree anc]\n          (some identity\n                (map #(find-node q % (conj anc tree)) kids)))))\n     (exclude-kid [[name & kids] [kid-name & _]]\n       (into [name] (remove (fn [[n & _]] (= n kid-name)) kids)))\n     (hoist [[name & kids :as node] [parent & more :as anc]]\n       (if parent\n         (into [name] (conj (vec kids) (hoist (exclude-kid parent node) more)))\n         node))]\n    (fn reparent [q tree]\n      (if-let [[n anc] (find-node q tree)]\n        (hoist n anc)\n        tree)))","user":"58ec1e63e4b056aecfd47d54"},{"problem":130,"code":"(fn reparent [n t]\n  (letfn [(path [n t]\n            (if (= (first t) n) [t]\n                (when-let [c (some #(path n %) (rest t))]\n                  (cons t c))))] \n    (reduce (fn [acc i] (concat i [(remove #{i} acc)])) (path n t))))","user":"53b39d82e4b047364c0444a6"},{"code":"(fn [t [i & c :as r]]\n  (if (= t i)\n    r\n    (let [ch (first (filter #(some #{t} (flatten %)) c))]\n      (recur t (concat ch (list (remove #{ch} r)))))))","problem":130,"user":"4ddbfb8a535d02782fcbea00"},{"problem":130,"code":"(fn pikc-tree [new-root tree]\n   (let [walked (tree-seq next next tree)\n         tree-reverse\n         (fn _tr [before self current]\n           (println \"self: \" self \"current:\" current)\n           (if (empty? current)\n             self\n             (if (some #(= self %) (first current))\n               (let [_self (first current)\n                     _ret (remove #(= self %) _self)\n                     _bef (remove #(= before %) self)]\n                 (println \"_self: \" _self \"_ret\" _ret)\n                 (if (next current)\n                   (concat self (list (_tr self _self (rest current))))\n                   (concat _bef (list _ret))\n                   ))\n               (recur self self (rest current)))\n             ))]\n     (let [me (first (filter #(= new-root (first %)) walked))\n           target (take-while #(not= new-root (first %)) walked)]\n       (tree-reverse\n         me\n         me\n         (reverse target)))\n     ))","user":"55a372f1e4b0acc240e31537"},{"problem":130,"code":"(fn [newr tr]\n  (letfn [(rewr [[par & chs :as all]]\n            (if-not chs [all]\n                    (let [next-round (map (fn [ch] (conj ch (concat [par] (remove #(= (first %) (first ch)) (rest all)))))\n                                          (filter vector? chs))\n                          done (filter #(= (first %) newr) next-round)]\n                      (if (empty? done) (map rewr next-round)\n                          done))))]\n    (let [result (first (rewr ((fn r [t] (if (coll? t) (vec (map r t)) t)) tr)))\n          fr (first result)]\n      (if (coll? fr) fr result))))","user":"56018dd4e4b04bb52996e18f"},{"code":"(fn [item tree]\n  (letfn [(f [item tree]\n            (if (= item (first tree))\n              (list tree)\n              (loop [subtree (next tree)\n                     notree '()]\n                (when  subtree\n                  (let [r (f item (first subtree))]\n                    (if r\n                      (conj r (conj (concat (into () notree) (next subtree)) (first tree)))\n                      (recur (next subtree) (conj notree (first subtree)))))))))]\n    (let [ret (f item tree)]\n      (reduce #(if %2 (concat %2 (list %1)) %1) (first ret) (next ret)))))","problem":130,"user":"52afbc69e4b0c58976d9acc0"},{"code":"(fn reparent [node tree]\n  (let [build-parents-map (fn build-par-map [tree]\n                             (let [root (first tree)]\n                               (reduce #(if (seq (rest %2))\n                                          (merge (build-par-map %2) (assoc %1 (first %2) root))\n                                          (assoc %1 (first %2) root)) {} (rest tree))))\n\n        parent (fn [node tree]\n                 ((build-parents-map tree) node))\n\n        cut (fn cut-cut[tree node]\n              (if (= (first tree) node)\n                nil\n                (remove nil? (cons (first tree) (map #(cut-cut % node) (rest tree))))))\n\n        sub-tree (fn sub-tr [tree node]\n                   (if (= (first tree) node)\n                     tree\n                     (first (remove empty? (map #(sub-tr % node) (rest tree))))))\n\n        inject (fn [tree child]\n                 (concat tree (list child)))]\n\n    (if (not (parent node tree))\n      tree\n      (let [tree-from-recur-step (reparent (parent node tree) tree)]\n        (inject (sub-tree tree-from-recur-step node) (cut tree-from-recur-step node))))))","problem":130,"user":"4dd7b81d535d2dad7130b5d3"},{"code":"(fn reparent [node tree]                                                                                         \n  (loop [trees [tree]                                                                                              \n         nodes-tried #{}]                                                                                          \n    (let [root-tree (group-by first trees)                                                                         \n          found? (contains? root-tree node)]                                                                       \n      (if found?                                                                                                   \n        (first (root-tree node))                                                                                   \n        (let [new-nodes-tried (set (concat nodes-tried (keys root-tree)))                                          \n              new-trees (for [t trees n (rest t)                                                                   \n                              :let [new-root (first n)                                                             \n                                    cut-branch (filter #(not= n %) t)                                              \n                                    new-tree (concat n [cut-branch])]                                              \n                              :when (not (contains? new-nodes-tried new-root))]                                    \n                          new-tree)]                                                                               \n          (recur new-trees new-nodes-tried))))))","problem":130,"user":"51899891e4b0288ada3dbdab"},{"problem":130,"code":"(fn [v t]\n  (let [g (fn g [t parent]\n              (let [f (first t)\n                    r (rest t)\n                    acc {f {:p parent\n                            :c (map first r)}}]\n                (reduce (fn [a x] (merge a (g x f)))\n                        acc r)))\n        graph (g t nil)\n        {:keys [p c]} (graph v)]\n    (letfn [(mapper [x e value]\n              (let [coll (filter #(not= % value) (down value (conj e x)))]\n                (concat (list value) coll)))\n            (down [x e]\n              (let [children (->> (graph x)\n                                  :c\n                                  (filter #(not (e %))))\n                    coll (map #(mapper x (conj e x) %) children)]\n                (concat (list x) coll)))\n            (up [x e]           \n              (if x\n                (let [{:keys [p c]} (graph x)\n                      c (filter #(not (e %)) c)]\n                  (concat (list x) (map #(down % e) c) (if p (list (up p (conj e p))) ())))\n                ()))]\n      (up v #{v}))))","user":"549c6792e4b0f3d1d8e70f8b"},{"code":"(fn p130 [sym tree]\n  (letfn [\n      (delete [coll index]\n        (concat (take index coll) (drop (inc index) coll)))\n      (append [item coll]\n        (concat coll [item]))\n      (find-path [[node & children :as tree]]\n        (if (= node sym)\n          (list tree)\n          (loop [i 0]\n            (when (< i (count children))\n              (if-let [path (find-path (nth children i))]\n                (conj path (delete tree (inc i)))\n                (recur (inc i))\n               )))))\n    ]\n    (when-let [path (find-path tree)]\n      (reduce append path)\n    )))","problem":130,"user":"4df3d4f4535d08e6dec9fe2c"},{"code":"(fn [tg tr]  \r\n  (let [pth (fn pth [target [rt & chs :as tree]] \r\n              (if (= rt target) (list rt)\r\n                (if (empty? chs) '()\r\n                  (let [inpath (first (drop-while empty? (map (partial pth target) chs)))] \r\n                    (if inpath (conj inpath rt) '())))))\r\n       \r\n        trans (fn trans [target [rt & chs :as tree]]\r\n                (if (= rt target) tree\r\n                  (if (nil? chs) tree\r\n                    (let [targetnode (first (drop-while nil? (map #(if (= target (first %)) % nil) chs)))]\r\n                      (if (nil? targetnode) \r\n                        (let [x (map (partial trans target) chs)] (cons rt x))\r\n                        (let [-tree (cons rt (filter #(not= (first targetnode) (first %)) chs))] \r\n                          (cons (first targetnode) (reverse (conj (reverse (rest targetnode)) -tree))))\r\n                        )))))\r\n        ]\r\n       \r\n    (reduce #(trans %2 %1) tr (rest (pth tg tr)))))","problem":130,"user":"4f0da4e4535d0136e6c22319"},{"code":"(fn [n t]\r\n  (let [con (fn con\r\n              ([t] (con nil t))\r\n              ([p t]\r\n                 (let [x (first t)\r\n                       xs (rest t)\r\n                       cs (filter #(not (nil? %))\r\n                                  (conj (vec (map first xs)) p))]\r\n                   (if (empty? xs)\r\n                     {x [p]}\r\n                     (apply merge\r\n                            (conj (map #(con x %) xs)\r\n                                  {x cs}))))))\r\n        reb (fn reb\r\n              ([m n] (reb m n nil))\r\n              ([m n p]\r\n                 (let [ch (filter #(not (= p %)) (m n))]\r\n                   (if (empty? ch)\r\n                     [n]\r\n                     (into [n] (map #(reb m % n) ch))))))]\r\n    (reb (con t) n)))","problem":130,"user":"4db4714f535dc0f10411755a"},{"problem":130,"code":"(fn [node tree]\n  (letfn [(find-node [[root & branches]]\n            (cond\n              (= root node) [node]\n              (empty? branches) false\n              :else\n              (let [twigs (remove false? (for [br branches] (find-node br)))]\n                (if (empty? twigs)\n                  false\n                  (cons root (first twigs))))))\n\n          (one-step [new-root [old-root & brs]]\n            (let [[u [v & w]] (split-with #(not= (first %) new-root) brs)]\n              (conj (vec v) (cons old-root (concat u w)))))]\n\n    (reduce #(one-step %2 %1) tree (rest (find-node tree)))))","user":"58a0fc33e4b02bd94d917ea3"},{"problem":130,"code":"(fn gen-tree\n  [nr tree]\n  (let [fun (fn fun\n              [nr tree]\n              (if (empty? tree)\n                '()\n                (if (= nr (first tree))\n                  (list tree)\n                  (let [res (apply concat (map #(fun nr %) (rest tree)))]\n                    (if (empty? res)\n                      res\n                      (concat [tree] res))))))\n        pnodes (fun nr tree)]\n    (reduce (fn [rs e]\n              (concat e (list (remove #(= e %) rs))))\n            pnodes)))","user":"56a36f76e4b0542e1f8d14ca"},{"problem":130,"code":"(fn [new-root-name [root-name & root-children :as root]]\n  (if (= new-root-name root-name)\n    root\n    (let [\n          is-node-named #(and (sequential? %1) (= (first %1) %2))\n          find-new (fn find-new [[head & tail :as node]]\n                     (cond \n                      (nil? node) nil \n                      (= head new-root-name) node\n                      :else (some #(find-new %) tail)))\n          remove-child (fn [node name] (filter #(not (is-node-named % name)) node))\n          replace-node (fn replace-node [node replacement-node] \n                         (if (nil? node) \n                           nil \n                           (let [new (remove-child node new-root-name)] \n                             (if (= node new)\n                               (cons (first node) (map #(replace-node % replacement-node) (rest node)))\n                               (concat new [replacement-node])))))\n          [ancestor found] (some #(let [found (find-new %)] (when found [% found])) root-children)\n          ]\n      (if (= ancestor found)\n        (concat found [(remove-child root (first ancestor))])\n        (concat found [(replace-node ancestor (remove-child root (first ancestor)))])\n        )\n        )))","user":"55a74d46e4b09e57187da2a3"},{"code":"(letfn [(E? [x [n & t*]]\n          (or (= x n) (some #(E? x %) t*)))\n\n        (F [x t]\n          (if (= x (first t)) t\n              (loop [p [(first t)] t (rest t)]\n                (if (empty? t) p\n                    (let [[n & t*] t]\n                      (if (E? x n)\n                        (F x (concat n [(concat p t*)]))\n                        (recur (conj p n) t*)))))))]\n  \n  F)","problem":130,"user":"51a4416ae4b0def3c5c5868c"},{"problem":130,"code":"(fn [newRoot tree]\n  (letfn [(genSubTree [newSubRoot subTree childToRemove parent] ;function shall return [nextSubRoot nextChildToRemove subTreeStructure]\n                      (when-let [node (first subTree)];triplet tree node, so this function may return nil\n                        (if (= node newSubRoot)\n                          [parent node (vec (concat [node] (for [childTree (rest subTree) \n                                                          :when (not= childToRemove (first childTree))]\n                                                        (vec childTree))))]\n                          (loop [children (rest subTree)]\n                            (when-let [childTree (first children)]\n                              (if-let [childResult (genSubTree newSubRoot childTree childToRemove node)]\n                                childResult\n                                (recur (rest children))))))))\n          (reparentTree [newRoot childToRemove];another recursive function\n                        (let [[nextSubRoot nextChildToRemove subTreeStructure] (genSubTree newRoot tree childToRemove nil)];I really miss the variables with modifiable references\n                          (if (nil? nextSubRoot);no more reparent work to do\n                            subTreeStructure\n                            (conj subTreeStructure (reparentTree nextSubRoot nextChildToRemove)))))];or still need to conj the tree structure\n    (reparentTree newRoot nil)))","user":"556c70dae4b09a3098a524fd"},{"problem":130,"code":"(fn [r t]\n  (->> (tree-seq next rest t)\n       (filter #(some #{r} (flatten %)))\n       (reduce (fn [a b]\n                 (concat b \n                         (list (remove #{b} a)))))))","user":"53ea5307e4b036ad0777e4e2"},{"code":"(fn [rt tree] \n  (let [f (fn f [[r & ot]]\n            (apply concat (map #(list r (first %)) ot)\n              (for [i ot] (f i))))\n        edges (f tree)\n        edges (concat edges (map reverse edges))\n        rp (fn rp [from cur]\n             (cons cur \n               (for [[i j] edges :when (and (= i cur) (not= j from))]\n                 (rp cur j))))]\n    (rp rt rt)))","problem":130,"user":"51944aaae4b0142f60b4aedc"},{"code":"(fn [c t]\r\n  (letfn [\r\n    (diff-tree [t1 t2]\r\n      (not (and (seq? t2) (= (first t1) (first t2)))))\r\n  \t(rotate [t [up-t & up-up-ts :as up-ts]]\r\n        (if (empty? up-ts) t \r\n          (let [up-t2 (filter #(diff-tree t %) up-t)]\r\n\t\t            (concat t (list (rotate up-t2 up-up-ts))))))\r\n\t\t(look-reroot [t ts]\r\n\t\t  (if (= c (first t)) (rotate t ts)\r\n\t\t    (first \r\n\t\t      (drop-while nil?\r\n\t\t        (map #(look-reroot % (cons t ts)) (rest t))))))\r\n]\r\n    (look-reroot t '())))","problem":130,"user":"4f569218e4b0a7574ea71826"},{"code":"(fn trre [newrt tree]\n   (let [oldrt (first tree)\n         fltn (fn [t]      \n                (loop [tr [t] rslt {}]\n                  (if (empty? tr) rslt\n                    (let [br (first tr)]\n                      (recur (concat (rest tr)(filter coll? br)) (->> br(filter coll?)(map first)(vector (first br))(conj rslt)))\n                      ))))\n         compose (fn compose [rt fltr](if (empty? (get fltr rt))(list rt)(concat (list rt)(map #(compose % fltr) (get fltr rt)))))\n         cross (fn [p i tr] (-> tr (assoc p (remove #(= % i) (get tr p)))(assoc i (concat (get tr i) [p]))))\n         chng (fn chng [i tr] \n                (let [p (->> tr (filter #(some (fn[x](= i x))(val %))) first first)] \n                  (if (= oldrt p) (cross p i tr)(let [t (chng p tr)] (cross p i t)))))\n         ]\n     (if (= oldrt newrt) tree (->> tree fltn (chng newrt) (compose newrt)))\n     \n     )\n   )","problem":130,"user":"5274eb56e4b03e8d9a4a74bb"},{"code":"(let [\nstroll (fn stroll\n   ([post] (stroll [] post))\n   ([pre post] (when-let [[x & xs] (seq post)] (cons [x (concat pre xs)] (stroll (conj pre x) xs)))))\n\nhelper (fn helper [v [parent & children :as tree] rtree]\n  (if (= v parent)\n    (if rtree\n      (concat tree (list rtree))\n      tree)\n    (some (fn [[y ys]] (helper v y (concat (list parent) ys (if rtree (list rtree) '())))) (stroll children))))]\n      \n(fn [v tree] (helper v tree nil)))","problem":130,"user":"4ec07699535dfed6da9c6da2"},{"problem":130,"code":"(fn tree-reparenting [new-parent tree]\n    (letfn [(transform-tree [[root & branches] parent]\n                (when root\n                    (merge\n                      (hash-map root {:children (vec (map first branches))\n                                      :parent parent})\n                      (apply merge (map #(transform-tree % root) branches)))))\n            (reparent-tree [tree-blueprint root new-parent]\n                (if-let [{r-parent :parent r-children :children} (get tree-blueprint root)]\n                        (reparent-tree (assoc tree-blueprint root\n                                              {:children (remove #(or (nil? %) (= new-parent %))\n                                                                 (conj r-children r-parent))\n                                               :parent new-parent})\n                                       r-parent\n                                       root)\n                        tree-blueprint))\n            (compile-tree [tree-blueprint root]\n                (when root\n                    (->> (get-in tree-blueprint [root :children])\n                      (map #(compile-tree tree-blueprint %))\n                      (remove nil?)\n                      (cons root))))]\n        (-> tree\n          (transform-tree nil)\n          (reparent-tree new-parent nil)\n          (compile-tree new-parent))))","user":"5f548678e4b0a0bc16850a7e"},{"code":"(fn reparent [node tree]\n  (letfn\n    [(has-target?\n       [tree]\n       (cond\n         (list? tree) (some identity (map has-target? tree))\n         :else (= tree node)))]\n    (loop [tree tree]\n      (if (= node (first tree)) tree\n        (let [new-root (first (filter has-target? tree))\n              sub-tree (list (remove #(= new-root %) tree))\n              new-tree (concat new-root sub-tree)]\n          (recur new-tree))))))","problem":130,"user":"4f6160a7e4b0defedf855fbe"},{"code":"(fn [node-name tree]\n  (letfn [(ups [loc]\n            (let [up (clojure.zip/up loc)]\n              (and up\n                   (list (concat (remove #{(clojure.zip/node loc)}\n                                         (clojure.zip/node up))\n                                 (ups up))))))\n          (reparent-loc [loc]\n            (if (= (-> loc clojure.zip/node first) node-name)\n              (concat (clojure.zip/node loc) (ups loc))\n              (reparent-loc (-> loc clojure.zip/next clojure.zip/next))))]\n    (reparent-loc (clojure.zip/seq-zip tree))))","problem":130,"user":"4ee3b586535d10e5ff6f5371"},{"code":"(fn [v t]\n  (let [pull (fn p [x path]\n               (println :pull :x x :path (interpose \";\" path))\n               (if (empty? path)\n                 x\n                 (let [x1 (first path)\n                       x2 (cons (first x1)\n                                (remove #(= (first x) (first %)) (rest x1)))\n                       ]\n                   (println :x1 x1 :x2 x2)\n                   (concat x\n                        [(p x2\n                            (rest path))]))))\n        find (fn f [n path]\n               (if (not-empty n)\n                 (if (= (first n) v)\n                   (pull n path)\n                   (some identity (map #(f % (cons n path))\n                                       (rest n))))))]\n    (find t [])))","problem":130,"user":"52a88c4de4b0c58976d9ac30"},{"problem":130,"code":"(fn reparent [new-root [root & children :as tree]]\n  (cond\n   (= root new-root) tree\n   (empty? children) tree\n   :else\n   (letfn [(add-on [[r & cs :as t1] n t2]\n                   (if (= r n)\n                     (concat t1 [t2])\n                     (apply list r (for [c cs] (add-on c n t2)))))]\n     (let [cs (map #(hash-map :old-root (first %) :tree (reparent new-root %)) children)]\n       (if-let [{n :old-root t1 :tree} (first (filter #(= new-root (first (:tree %))) cs))]\n         (add-on t1 n (apply list root (remove #{t1} (map :tree cs))))\n         tree)))))","user":"553e0b70e4b0a04f792994e8"},{"code":"(fn [new-root tree]\n  (let [connections ((fn links [tree]\n                       (when-let [[root & children] (seq tree)]\n                         (let [child-links (apply merge {} (map links children))\n                               conj (fnil conj [])]\n                           (reduce (fn [m [child]]\n                                     (-> m\n                                         (update-in [root] conj child)\n                                         (update-in [child] conj root)))\n                                   child-links\n                                   children))))\n                     tree)]\n    (second\n     ((fn dangle [edges root]\n        (if-let [children (not-empty (get edges root))]\n          (let [edges (reduce (fn [edges from]\n                                (update-in edges [from]\n                                           #(remove #{root} %)))\n                              (dissoc edges root)\n                              children)]\n            (reduce (fn [[edges tree] child]\n                      (update-in (dangle edges child)\n                                 [1] #(conj tree %)))\n                    [edges [root]]\n                    children))\n          [edges [root]]))\n      connections new-root))))","problem":130,"user":"4dabb7b1950ed6eda1bd72f3"},{"code":"(fn [k tree]\r\n     (letfn [(has? [c] (some #(= % k) (flatten c)))\r\n           (restructure [p c] (reverse (cons c (reverse p))))\r\n           (fun [[n & c]]\r\n            (let [withk (first (filter #(has? %) c))\r\n                  withoutk (filter #(not= withk %) c)]\r\n                 (restructure withk (concat [n] withoutk))))]\r\n                 (first (filter #(= (first %) k) (iterate fun tree)))))","problem":130,"user":"500d1db4e4b05f7c30cfa69f"},{"problem":130,"code":"(fn reparent\n  [node tree]\n  (when tree\n    (if (= (first tree) node)\n      tree\n      (let [valid-path (reduce (fn [r v]\n                                 (if-let [path (reparent node v)]\n                                   {:count (inc r)\n                                    :path path}\n                                   (if (map? r)\n                                     r\n                                     (inc r))))\n                               0\n                               (next tree))]\n        (when (map? valid-path)\n          (let [index (:count valid-path)\n                path (:path valid-path)\n                new-parent (concat (take index tree) (drop (inc index) tree))]\n            (if (= (nth tree index) path)\n              (concat (last [path]) [new-parent])\n              (concat (butlast path) [(concat (last path) [new-parent])]))))))))","user":"57d0cd58e4b0bd073c20235e"},{"code":"(fn [root tree] (let [\r\n  sq (into {}\r\n      ((fn squeeze [pr [id & ch]]\r\n        (if id (cons [id [pr (map first ch)]]\r\n                (mapcat (partial squeeze id) ch))))\r\n        nil tree))\r\n  rep (loop [id root, tr sq, newp nil]\r\n        (if id\r\n          (let [[p ch]  (tr id)\r\n                newch   (remove (partial = newp) ch)\r\n                newch   (if p `[~@newch ~p] newch)]\r\n            (recur p (into tr {id `[~newp ~newch]}) id))\r\n      tr))\r\n  to-tree (fn to-tree [id]\r\n            (if-let [[_ ch] (rep id)] \r\n              `(~id ~@(map to-tree ch))))]\r\n  (to-tree root)))","problem":130,"user":"50336c6be4b0c6c1199c710f"},{"problem":130,"code":"(fn rp [n t]\n  (letfn\n    [(fnd [n t]\n          (cond\n             (empty? t) false\n             (= n (first t)) true\n             :else (some #(= % true) (for [c (rest t)] (fnd n c)))))\n     (fndparent \n          ([n t] (fndparent n t nil))\n          ([n t p]\n          (cond\n             (empty? t) nil\n             (= n (first t)) p\n             :else (first (for [c (rest t) :when (fnd n c)] (fndparent n c (first t)) )))))\n     (fndtree [n t]\n          (cond\n             (empty? t) nil\n             (= n (first t)) t\n             :else (first (for [c (rest t) :when (fnd n c)] (fndtree n c) ))))\n     (deltree [n t]\n         (if (= n (first t)) \n            nil\n            (cons (first t) (for [c (rest t) :let [d (deltree n c)] :when (not (nil? d))] d))))\n     (addtree [n t add]\n         (if (empty? t)\n           add\n             (if (= n (first t)) \n               (cons (first t) (conj (vec (rest t)) add))\n               (cons (first t) (for [c (rest t)] (addtree n c add)))\n      )))]\n(let [resttree (cons (first t) (remove #(fnd n %) (rest t)))\n      subntree (first (for [c (rest t) :when (fnd n c)] c))\n      step1 (addtree (fndparent n t) (deltree n subntree) resttree)\n      ntree (fndtree n t)]\n  (if (= 1 (count t))\n    t\n    (addtree n ntree step1)))))","user":"56bca51ae4b0f26550335963"},{"code":"(fn f [e g [n & c :as y]]\n  ({n y} g\n   (some #(#{%}%)\n         (for [[d :as b] c :let [o `((~n ~@(remove #{b} c) ~@e))]]\n           ({d `(~@b ~@o)} g (f o g b))))))\n()","problem":130,"user":"4ff67852e4b0678c553fc37e"},{"code":"(fn [n t]\n  (let [\n     buildmap (fn buildmap [[f & l :as r] p]\n      (map #(if (coll? %)\n          (buildmap % f)\n          {:i % :c (concat (map first l) [p])})\n        r))\n     treemap (flatten (buildmap t nil))\n     find-node (fn [n] (first \n                (filter \n                  #(= (:i %) n) \n                  treemap)))\n     reparent (fn reparent [last-node n]\n       (if (not (nil? n))\n         (let [\n           {pc :c} (find-node n)]\n           (concat [n]\n              (keep \n                identity \n                   (map \n                     (fn [e] (if (not= last-node e)\n                                 (reparent n e)))\n                    pc))))))]\n    (reparent nil n)))","problem":130,"user":"4daa374930acd6ed13482a68"},{"code":"(fn [node tree]\n  (let [to-map (fn to-map [[s & r]]\n\t\t      (if (not-empty r)\n    \t\t\t (apply merge {s (vec (map first r))} (map to-map r))\n\t      \t\t {s []}))\n\n\t\tparents (fn [mp s]\n\t\t  (take-while identity (iterate (fn [sym] (ffirst (filter (fn [[key val]] (if (some #(= sym %) val) key ) ) mp)) )\n\t\t\t\t   s)))\n\t\tre-parent (fn [mp s]\n\t\t  (let [p (parents mp s)]\n\t\t\t(reduce (fn [acc [x y]]\n\t\t\t\t\t   (-> acc \n\t\t\t\t\t\t  (assoc x (conj (acc x) y)) \n\t\t\t\t\t\t  (assoc y (vec (filter #(not= % x) (acc y)))) )) mp (map vector p (drop 1 p)))))  \n\t\tserialize (fn serialize [mp s]\n\t\t  (let [children (mp s)]\n\t\t\t(into [s] (map #(serialize mp %) children))))\t\t\t\t  \n\t\tm (to-map tree )\t\n\t\tm* (re-parent m node)\n\t\t] \n    (serialize m* node)))","problem":130,"user":"523a9fc9e4b081681ca7adca"},{"problem":130,"code":"(fn g [i t]\n  (let [f #(some #{i} (flatten [%]))]\n    (if ((set t) i) t\n      (g i (concat\n            (first (filter f t))\n            [(remove f t)])))))","user":"53065acbe4b02e8216869792"},{"problem":130,"code":"(fn [x tree]\n  (let [subtree (fn subtree [x tree]\n                  (if (empty? tree)\n                    nil\n                    (if (coll? (first tree))\n                      (concat (subtree x (first tree))(subtree x (rest tree)))\n                      (if (= x (first tree))\n                        tree\n                        (subtree x (rest tree))))))\n        deltree (fn deltree [x tree]\n                  (if (empty? tree)\n                    nil\n                    (if (coll? (first tree))\n                      (filter #(not (nil? %))(list (deltree x (first tree)) (first (deltree x (rest tree)))))\n                      (if (= x (first tree))\n                        nil\n                        (cons (first tree) (deltree x (rest tree)))))))\n        addtree (fn addtree [x tree a_tree]\n                  (if (empty? tree)\n                    nil\n                    (if (coll? (first tree))\n                      (filter #(not (nil? %)) (cons (addtree x (first tree) a_tree)\n                                                    (addtree x (rest tree) a_tree)))\n                      (if (= x (first tree))\n                        (cons (first tree) (conj (into [] (addtree x (rest tree) a_tree)) a_tree))\n                        (cons (first tree) (addtree x (rest tree) a_tree))))))\n        toroot (fn toroot [x tree path]\n                 (if (empty? tree)\n                   false\n                   (if (coll? (first tree))\n                     (or (toroot x (first tree) path)(toroot x (rest tree) path))\n                     (if (= x (first tree))\n                       (cons x path)\n                       (toroot x (rest tree) (cons (first tree) path))))))\n        path (toroot x tree '())\n        dpath1 (rest path)\n        dpath2 (butlast path)\n        sub_x (subtree x tree)\n        parts (map #(deltree %2 (subtree % tree)) dpath1 dpath2)\n        tr_parts (map #(list % %2) dpath2 parts) \n        ]\n     (reduce #(addtree (first %2) % (second %2)) sub_x  tr_parts)))","user":"566d71b1e4b0a866af6896ca"},{"code":"(fn [n t]\r\n  (letfn [(except [e xs]\r\n            (filter #(not= % e) xs))\r\n          (f [t r]\r\n            (if (not (empty? t))\r\n              (if (= (first t) n) (if (empty? r) t (concat t (list r)))\r\n                  (let [l (mapcat #(f % (concat (except % t) (if (empty? r) r (list r)))) (rest t))]\r\n                    (if (not (empty? l)) l)))))]\r\n    (f t '())))","problem":130,"user":"4dc1ee85535d020aff1edf91"},{"code":"(fn rot [v [nodev & _ :as tree] & trees]\n  (letfn [\n    (rotate [trees]\n      (let [cleared\n              (map #(filter (partial not= %2) %1)\n                trees (cons nil trees))]\n        (reduce #(conj (vec %2) %1)\n          (reverse cleared))))\n    ]\n    (if (= v nodev) (rotate (cons tree trees))\n      (loop [children (rest tree)]\n        (when (seq children)\n          (if-let [rotated (apply rot v (first children) tree trees)]\n            rotated\n            (recur (rest children))))))))","problem":130,"user":"50901b2ee4b0ea685a20f774"},{"code":"(fn tree-reparenting [label tree]\n  (let [get-label (fn [x]\n                    (when (sequential? x) (first x)))\n        path-to (fn path-to [p l t]\n                  (let [lbl (get-label t)\n                        p (conj p lbl)]\n                    (if (= lbl label)\n                      p\n                      (mapcat (partial path-to p l) (rest t)))))\n        lift (fn [t l]\n               (let [match #(= l (get-label %))\n                     sub (first (filter match t))\n                     butsub (remove match t)]\n                 (concat sub (list butsub))))]\n    (reduce lift tree (rest (path-to [] label tree)))))","problem":130,"user":"4f0e995e535d0136e6c22326"},{"problem":130,"code":"(let [getChildTree (fn getChildTree [child tree]\n                    (if (empty? tree)\n                      nil\n                      (if (= child (first tree))\n                        tree\n                        (first\n                         (filter not-empty\n                                 (map #(getChildTree child %) (rest tree)))))))\n\n\tremoveChildTree (fn removeChild [child tree]\n                       (if (empty? tree)\n                         tree\n                         (if (= child (first tree))\n                           '()\n                           (cons (first tree)\n                                 (filter not-empty\n                                 (map #(removeChild child %)\n                                      (rest tree)))))))\n\n\tgetParentNode (fn getParentNode [child tree]\n                     (if (<= (count tree) 1)\n                       nil\n                       (if (some #(= child %) (map first (rest tree)))\n                         (first tree)\n                         (first (filter (comp not nil?)\n                                        (map #(getParentNode child %)\n                                             (rest tree)))))))]\n\n\t(fn reparent [child tree]\n                (let [childTree (getChildTree child tree)\n                      parentNode (getParentNode child tree)\n                      parentTree (if (nil? parentNode)\n                                   (removeChildTree child tree)\n                                   (reparent parentNode\n                                             (removeChildTree child tree)))]\n                  (if (empty? parentTree)\n                    childTree\n                    (concat childTree (list parentTree))))))","user":"541ef7e2e4b01498b1a71a92"},{"problem":130,"code":"(fn [v tree]\n  (let [f (fn f [[h & t]]\n                    (cond\n                      (nil? h) nil\n                      (= v h) (list h)\n                      :else (if-let [r (some #(f %) t)] (cons h r))))\n        append (fn [t e] (if (empty? e) t (conj (vec t) e)))]\n    (loop [[n & r] (rest (f tree)) [h & t] tree new-tree '()]\n      (if (nil? n)\n        (cons h (append t new-tree))\n        (let [other (remove #(= n (first %)) t)\n              next (first (filter #(= n (first %)) t))]\n          (recur r next (cons h (append other new-tree))))\n        ))))","user":"4faf97d8e4b081705acca258"},{"code":"(fn [s c]\n  (let [path (fn _ [t c]\n               (if (= (first c) t)\n                 [c]\n                 (if-let [p (some #(_ t %) (rest c))]\n                   (cons c p))))\n        cminus (fn [c1 c2] (filter #(not= % c2) c1))\n        change-paths (fn [c]\n                      (conj (vec (map #(cminus (first %) (last %)) (partition 2 1 c))) (last c)))\n\t\tp (path s c)]\n    (if (= (count p) 1)\n      (first p)\n      (reduce #(seq (conj (vec %2) %1)) (change-paths p)))))","problem":130,"user":"514721c6e4b0d520409ed392"},{"code":"(fn [new-parent tree]\n    (let [tree-contains? (fn [tree node]\n                           (some #{node} (flatten tree)))\n          subtree-containing (fn [tree node]\n                               (first (for [subtree (rest tree)\n                                            :when (tree-contains? subtree node)]\n                                        subtree)))\n          without-subtree-containing (fn [tree node]\n                                       (let [node-to-prune (first (subtree-containing tree node))]\n                                         (cons (first tree)\n                                               (filter #(not= (first %) node-to-prune) (rest tree)))))\n          rotate (fn [tree node]\n                   (let [subtree (subtree-containing tree node)\n                         pruned (without-subtree-containing tree node)]\n                     (concat subtree (list pruned))))]\n      (loop [tree tree]\n        (if (= new-parent (first tree))\n          tree\n          (recur (rotate tree new-parent))))))","problem":130,"user":"521b9f92e4b0c4ef0be8304c"},{"problem":130,"code":"(fn reparent [item tree]\n\t(letfn [(search [ps node]\n\t\t\t\t(if (seq node)\n\t\t\t\t\t(let [f (first node) rs (rest node)]\n\t\t\t\t\t\t(if (= f item)\n\t\t\t\t\t\t\t(conj ps node)\n\t\t\t\t\t\t\t(some identity\n\t\t\t\t\t\t\t\t(map #(search (conj ps node) %) rs))))))]\n\n\t(let [ps (search [] tree) \n\t\t  node (last ps)\n\t\t  reshaped\n\t\t\t  (reduce\n\t\t\t\t(fn [acc [parent child]]\n\t\t\t\t\t(concat\n\t\t\t\t\t\t(filter #(not= % child) parent)\n\t\t\t\t\t\t(if (seq acc) [acc] [])))\n\t\t\t\t[]\n\t\t\t\t(partition 2 1 ps))]\n\t  (concat node (if (seq reshaped) [reshaped] [])))))","user":"54448e84e4b032a45b869393"},{"code":"(fn [root-item tree]\n   (let [all-nodes (tree-seq next rest tree)\n         get-node (fn [item nodes] (some #(when (= item (first %)) %) nodes))\n         get-parent (fn [item] (some #(when (get-node item (rest %)) %) all-nodes))\n         without-child (fn [parent child-item]\n                         (filter #(not (and (seq? %) (= child-item (first %)))) parent))\n         reverse-tree (fn reverse-tree [item sq]\n                        (if-let [parent (get-parent item)]\n                          (reverse-tree (first parent) (conj sq (without-child parent item))) sq))\n         build-tree (fn build-tree [sq]\n                      (if-let [r (not-empty (rest sq))]\n                        (build-tree (conj (rest r) (concat (first r) (list (first sq))))) (first sq)))]\n     (build-tree (reverse-tree root-item (list (get-node root-item all-nodes))))))","problem":130,"user":"51f66e0ee4b06ff1c25c52c3"},{"problem":130,"code":"(fn reparent [new-root tree]\n  (letfn [(cut-node [target [root & children]]\n            (if (= target root)\n              nil\n              (apply list root (remove nil? (map #(cut-node target %) children)))))\n          (find-target [target tree] (find-target-with-parent target tree nil))\n          (find-target-with-parent [target [root & children] parent]\n            (if (= target root)\n              {:children children, :parent parent}\n              (some #(find-target-with-parent target % root) children)))]\n\n    (let [{:keys [children parent]} (find-target new-root tree)\n          parent-as-right-tree (if parent [(reparent parent (cut-node new-root tree))] [])]\n      (apply list new-root (concat children parent-as-right-tree)))))","user":"5344fe13e4b084c2834f4a32"},{"code":"(fn [n t]\n  (let [getp (fn getp [n [t & ts :as T]]\n\t       (when t\n\t\t (if (= t n)\n\t\t   [T]\n\t\t   (if-let [p (first (for [t ts :let [p (getp n t)] :when p]\n\t\t\t\t       p))]\n\t\t     (cons (filter #(if (coll? %) (not= (ffirst p) (first %)) %) T) p)\n\t\t     nil))))\n        p (getp n t)]\n    (loop [n (second p) t (nnext p) ac (first p)]\n      (if n\n        (recur (first t) (next t) (concat n [ac]))\n\tac))))","problem":130,"user":"4f32a7f1e4b0d6649770a095"},{"problem":130,"code":"(fn reparent-tree2 [new-root tree]\n  (letfn [\n    ; true if the node is a branch\n    (is-branch? [node] (> (count node) 1))\n    ; get node's name\n    (gnn [node] (first node))\n    ; get node's children\n    (gnkids [node] (if (= 1 (count node)) '() (rest node)))\n    ; find path from root to target\n    (find-path [target tree]\n      (let [path (atom [])\n            traverse (fn traverse [node]\n                        (let [nname (gnn node)]\n                          (if (and (empty? @path) (= target nname))\n                            (swap! path conj nname)\n                            (doseq [kid (gnkids node)] \n                              (when (empty? @path) \n                                (traverse kid)\n                                (when (-> @path empty? not)\n                                  (swap! path conj nname)))))))]\n        (traverse tree)\n        (reverse @path)))\n    ; delete a subtree whose name is equal to target\n    (delete-subtree [target tree] \n      (letfn [(traverse [node]\n                (let [nname (gnn node)\n                      nkids (gnkids node)]\n                  (when-not (= target nname)\n                    (if (empty? nkids)\n                      node\n                      (cons nname (filter #(not= nil %) (map traverse nkids)))))))]\n        (traverse tree)))\n    ; extract a subtree whose name is equalt to target\n    (extract-subtree [target tree]\n      (let  [result (atom nil)\n             traverse (fn traverse [node]\n                        (if (= target (gnn node))\n                          (reset! result node)\n                          (doseq [kid (gnkids node)]\n                            (traverse kid))))]\n        (traverse tree)\n        @result))\n    ; insert as rightmost child\n    (insert-at-rightmost [node child]\n      (let [nname (gnn node)\n            nkids (gnkids node)\n            new-kids  (if (empty? nkids) \n                        child (list* (conj (vec nkids) child)))\n            new-node  (if (-> new-kids first seq?) \n                        (conj new-kids nname) \n                        (reverse (conj '() nname new-kids)))]\n        new-node))\n    ; make a current root the righmost childred of the `new-root`\n    (reparent-one-level [tree new-root]\n      (let [nr-subtree (extract-subtree new-root tree)\n            tree-without-nr (delete-subtree new-root tree)]\n        (insert-at-rightmost nr-subtree tree-without-nr)))]\n    (let [; path of neccessary changes from up to bottom (starting at root and ending an new-root)\n          path (find-path new-root tree)\n          ; how many times the tree must changes\n           moves (dec (count path))]\n      (loop [i moves p (rest path) t tree]\n        (if (zero? i)\n          t\n          (recur (dec i) (rest p) (reparent-one-level t (first p))))))))","user":"52cf084ce4b07d0d72b27399"},{"code":"(fn [new-parent tree]\n    (let [path ((fn pf [path [parent & children]]\n                  (when parent\n                    (if (= parent new-parent)\n                      (conj path parent)\n                      (some #(pf (conj path parent) %) children)))) [] tree)]\n      (loop [[root & [new-root & _ :as rest-path]] path\n             [parent & children :as tree] tree]\n        (if rest-path\n          (let [[[new-root & new-root-children]] (filter (comp #{new-root} first) children)]\n            (recur rest-path\n                   (cons new-root (concat new-root-children\n                                          [(cons parent (remove (comp #{new-root} first) children))]))))\n          tree))))","problem":130,"user":"4e6a0667535d8ccf87e9fe9e"},{"code":"(fn [tofind tree]\n  (let [search (fn search [tofind tree]\n                  (cond (= tofind (first tree)) (list :this)\n                        (>= 1 (count tree)) nil\n                        :else (if-let [left (search tofind (second tree))]\n                                (cons :left left)\n                                (if-let [right (search tofind (nth tree 2))]\n                                  (cons :right right)\n                                  nil))))\n        flip #(concat %1 (list (remove #{%1} %2)))\n        reparent (fn [tree where]\n                    (condp = where\n                      :this tree\n                      :left (flip (second tree) tree)\n                      :right (flip (nth tree 2) tree)))]\n  (reduce reparent tree (search tofind tree))))","problem":130,"user":"507fbd77e4b089ade05efbd3"}]