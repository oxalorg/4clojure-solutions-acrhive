[{"code":"(fn [hand]\n  (let [rank (fn [[s r]] (get {\\2 0 \\3 1 \\4 2 \\5 3 \\6 4 \\7 5 \\8 6 \\9 7 \\T 8 \\J 9 \\Q 10 \\K 11 \\A 12 } r))\n        suit first\n        suits (set (map suit hand))\n        ranks (map rank hand)\n        min-rank (apply min ranks)\n        straight (or (= (range min-rank (+ 5 min-rank)) (sort ranks)) (= [0 1 2 3 12] (sort ranks)))\n        flush (= 1 (count suits))\n        three (some #{3} (vals (frequencies ranks)))\n        pair (some #{2} (vals (frequencies ranks)))]\n\t  (cond\n\t    (and flush straight) :straight-flush\n      (some #{4} (vals (frequencies ranks))) :four-of-a-kind\n      (and three pair) :full-house\n      flush :flush\n      straight :straight\n      three :three-of-a-kind\n      (= 2 (count (filter #{2} (vals (frequencies ranks))))) :two-pair\n      pair :pair\n\t    :else :high-card)\n   ))","problem":"178","user":"5034b0e1e4b062bc5d7ae167"},{"code":"(fn [raw-hand]\n  (let [hand (map (fn [raw] {:suit (get raw 0),\n                             :rank (case (get raw 1)\n                                     \\T 10\n                                     \\J 11\n                                     \\Q 12\n                                     \\K 13\n                                     \\A 1\n                                     (Integer/parseInt (str (get raw 1))))})\n                  raw-hand)\n        flush? (apply = (map :suit hand))\n        ranks (sort (map :rank hand))\n        straight? (or (= #{1 10 11 12 13} (set ranks))\n                      (apply = 1 (map - ranks (cons (dec (first ranks)) ranks))))\n        freqs (frequencies ranks)\n        four-of-a-kind? (= 4 (second (last (sort-by second freqs))))\n        three-of-a-kind? (= 3 (second (last (sort-by second freqs))))\n        num-pairs (count (filter #(= 2 (second %)) freqs))]\n    (cond (and straight? flush?) :straight-flush\n          four-of-a-kind? :four-of-a-kind\n          (and three-of-a-kind? (= 1 num-pairs)) :full-house\n          flush? :flush\n          straight? :straight\n          three-of-a-kind? :three-of-a-kind\n          (= 2 num-pairs) :two-pair\n          (= 1 num-pairs) :pair\n          :else :high-card)))","problem":"178","user":"510acd6ee4b078ea719210f4"},{"problem":"178","code":"(fn [cardstrs]\n  (let\n    [get-card\n     (fn [[s r]]\n       {:suit (get {\\D :diamond \\H :heart \\C :club \\S :spade} s)\n        :rank (if-let [R (get {\\A 12 \\K 11 \\Q 10 \\J 9 \\T 8} r)] R\n                (- (Character/getNumericValue r) 2))})\n     cards (map get-card cardstrs)\n     rank-counts (sort (map count (vals (group-by :rank cards))))\n     flush? (apply = (map :suit cards))\n     has-straight #(every? true? (map = % (iterate inc (first %))))\n     ranks (sort (map :rank cards))\n     ranks-acelow (sort (replace {12 -1} ranks))\n     straight? (some has-straight (list ranks ranks-acelow))]\n    (if (and straight? flush?) :straight-flush\n      (if (= (last rank-counts) 4) :four-of-a-kind\n        (if (= [2 3] rank-counts) :full-house\n          (if flush? :flush\n            (if straight? :straight\n              (if (= (last rank-counts) 3) :three-of-a-kind\n                (if (= [1 2 2] rank-counts) :two-pair\n                  (if (= (last rank-counts) 2) :pair\n                    :high-card))))))))))","user":"553abb28e4b09218d5f44ffb"},{"problem":"178","code":"(fn [cards]\n  (let\n      [freq (fn [cards] (reverse (sort (vals(frequencies (map second cards))))))\n       flush? (fn  [cards] (= (count (set (map first cards))) 1))\n       one-straight? (fn [order cards] ((fn [coll] (= (take 5 (iterate inc (first coll))) coll)) (sort (map (zipmap order [2 3 4 5 6 7 8 9 10 11 12 13 14]) (map second cards)))))\n       high-straight? (fn [cards] (one-straight? \"23456789TJQKA\" cards))\n       low-straight? (fn [cards] (one-straight? \"A23456789TJQK\" cards))\n       straight? (fn [cards] (or (low-straight? cards) (high-straight? cards)))\n       straight-flush? (fn [cards] (and (straight? cards) (flush? cards)))\n       four-cards? (fn [cards] (= (first (freq cards)) 4))\n       full-house? (fn [cards] (= (freq cards) [3 2]))\n       three-of-a-kind? (fn [cards] (= (freq cards) [3 1 1]))\n       two-pair? (fn [cards] (= (freq cards) [2 2 1]))\n       pair? (fn [cards] (= (freq cards) [2 1 1 1]))]\n    (cond (straight-flush? cards) :straight-flush\n          (four-cards? cards) :four-of-a-kind\n          (full-house? cards):full-house\n          (flush? cards):flush\n          (straight? cards) :straight\n          (three-of-a-kind?  cards) :three-of-a-kind\n          (two-pair?  cards) :two-pair\n          (pair?  cards) :pair\n          :else :high-card)))","user":"54094824e4b0addc1aec66da"},{"problem":"178","code":"(fn bh [hand]\n      (let [rc   (fn rc [ah card] (let [suit-map {\\H :heart \\D :diamond \\C :club \\S :spade}\n        rank-map (zipmap ({true \"23456789TJQKA\" false \"A23456789TJQK\"} ah) (range))]\n       {:suit (suit-map (first (seq card))), :rank (rank-map (second (seq card)))}))\n            flush? (fn flush? [hand]\n                       (every? #(= (:suit (first hand)) (:suit %)) hand))\n            straight? (fn straight? [hand]\n                       (or (every? #(or (= 1 %) (= -1 %)) (map #(- (:rank %1) (:rank %2)) (map (partial rc true)  hand) (rest (map (partial rc true)  hand))))\n                           (every? #(or (= 1 %) (= -1 %)) (map #(- (:rank %1) (:rank %2)) (map (partial rc false) hand) (rest (map (partial rc false) hand))))))\n            of-kind?       (fn of-kind? [n hand]\n                               (contains? (set (vals (frequencies (map :rank hand)))) n))\n            two-pair?      (fn tp [hand]\n                               (= 2 ((frequencies (sort (vals (frequencies (map :rank hand))))) 2)))\n            four-of-kind?  (partial of-kind? 4)\n            three-of-kind? (partial of-kind? 3)\n            pair?          (partial of-kind? 2)\n            parsed-hand (map (partial rc true) hand)]\n  (cond\n    (and (flush? parsed-hand) (straight? hand))            :straight-flush\n    (four-of-kind? parsed-hand)                            :four-of-a-kind\n    (and (pair? parsed-hand) (three-of-kind? parsed-hand)) :full-house\n    (flush? parsed-hand)                                   :flush\n    (straight? hand)                                       :straight\n    (three-of-kind? parsed-hand)                                  :three-of-a-kind\n    (two-pair? parsed-hand)                                       :two-pair\n    (pair? parsed-hand)                                           :pair\n    :else                                                         :high-card)))","user":"544e8369e4b0e39780006987"},{"problem":"178","code":"(fn [cards]\n\t(let [c (fn [[s r]] {:suit ({\\D :diamond \\H :heart \\C :club \\S :spade} s) :rank ({\\A 12 \\2 0 \\3 1 \\4 2 \\5 3 \\6 4 \\7 5 \\8 6 \\9 7 \\T 8 \\J 9 \\Q 10 \\K 11} r)})\n\t\t  score (fn [cards]\n\t\t\t\t\t(let [rank-groups  (sort (map count (vals (group-by identity (map :rank cards)))))\n\t\t\t\t\t\t  sorted-ranks (sort (map :rank cards))\n\t\t\t\t\t\t  alternate-sorted-ranks (sort (map #(if (= 12 %) -1 %) (map :rank cards)))\n\t\t\t\t\t\t  card-sequence? (fn [r] (= [0 1 2 3 4] (map #(- % (first r)) r)))\n\t\t\t\t\t\t  straight? (or (card-sequence? sorted-ranks) (card-sequence? alternate-sorted-ranks))\n\t\t\t\t\t\t  flush? (= 1 (count (distinct (map :suit cards))))\n\t\t\t\t\t\t  ]\n\t\t\t\t\t\t(cond \n\t\t\t\t\t\t\t(and straight? flush?) :straight-flush\n\t\t\t\t\t\t\t(= [1 4] rank-groups) :four-of-a-kind\n\t\t\t\t\t\t\t(= [2 3] rank-groups) :full-house\n\t\t\t\t\t\t\tflush? :flush\n\t\t\t\t\t\t\tstraight? :straight\n\t\t\t\t\t\t\t(= [1 1 3] rank-groups) :three-of-a-kind\n\t\t\t\t\t\t\t(= [1 2 2] rank-groups) :two-pair\n\t\t\t\t\t\t\t(= [1 1 1 2] rank-groups) :pair\n\t\t\t\t\t\t\t:else :high-card)\n\t\t\t\t\t\t\t))]\n\t\t(score (map c cards))))","user":"53e19461e4b0d874e779ae59"},{"problem":"178","code":"(fn [a]\n  (let [c \"A23456789TJQKA\"\n        x (sort-by #(.indexOf c (str %)) (map second a))\n        r (if (and\n               (= \\A (first x))\n               (= \\K (last x)))\n            (concat (rest x) '(\\A))\n            x)\n        s (not (nil? (some #{r} (partition 5 1 c))))\n        f (apply = (map first a))\n        n (sort (vals (frequencies r)))\n        m (set n)]\n    (cond\n      (and s f) :straight-flush\n      (m 4) :four-of-a-kind\n      (= '(2 3) n) :full-house\n      f :flush\n      s :straight\n      (m 3) :three-of-a-kind\n      (= '(1 2 2) n) :two-pair\n      (m 2) :pair\n      :else :high-card)))","user":"51dd5d6fe4b0c33a4e1da406"},{"code":"(fn [h]\n  (letfn [(card [card]\n  (let [suits {\"S\" :spade \"H\" :heart \"C\" :club \"D\" :diamond}\n        ranks {\"2\" 0 \"3\" 1 \"4\" 2 \"5\" 3 \"6\" 4 \"7\" 5 \"8\" 6 \"9\" 7 \"T\" 8 \"J\" 9 \"Q\" 10 \"K\" 11 \"A\" 12}]\n    (assoc {} :suit (suits (subs card 0 1)) :rank (ranks (subs card 1)))))]\n  (let [hand (map #(card %) h)\n        ranks (map #(:rank %) (sort-by :rank hand))\n        suits (map #(:suit %) (sort-by :suit hand))\n        f-ranks (frequencies ranks)\n        f-suits (frequencies suits)\n        ]\n    (letfn [(in-sequence? [s]\n                         (if (= 12 (last s))\n                           (= (butlast s) (take 4 (iterate inc (first (butlast s)))))\n                           (= s (take 5 (iterate inc (first s))))))\n            (all-same-suit? []\n                         (= 1 (count f-suits)))\n            (four-of-a-kind? []\n                             (not (empty? (filter #(= 4 %) (vals f-ranks)))))\n            (full-house? []\n                         (= #{3 2} (set (vals f-ranks))))\n            (three-of-a-kind? []\n                           (let [v (set (vals f-ranks))]\n                             (and (contains? v 3) (not (contains? v 2)))))\n            (two-pair? []\n                       (= 2 (count (filter #(= 2 %) (vals f-ranks)))))\n            (one-pair? []\n                       (= 1 (count (filter #(= 2 %) (vals f-ranks)))))]\n      (cond (and (all-same-suit?) (in-sequence? ranks)) :straight-flush\n            (four-of-a-kind?) :four-of-a-kind\n            (full-house?) :full-house\n            (all-same-suit?) :flush\n            (in-sequence? ranks) :straight\n            (three-of-a-kind?) :three-of-a-kind\n            (two-pair?) :two-pair\n            (one-pair?) :pair\n            :else :high-card)))))","problem":"178","user":"51857e64e4b0da5a5be3babe"},{"problem":"178","code":"(fn [h]\n    (letfn [(to-num-ranks [n ace-high]\n              (read-string\n               (get\n                (merge\n                 {\"T\" \"10\" \"J\" \"11\"\n                  \"Q\" \"12\" \"K\" \"13\"}\n                 (if ace-high\n                   {\"A\" \"14\"}\n                   {\"A\" \"1\"})) n n)))\n            (suits [h] (map first h))\n            (ranks [h ace-high] (map (comp #(to-num-ranks % ace-high)\n                                           str\n                                           second) h))\n            (freq-vals [h] (-> h\n                               (ranks true)\n                               frequencies\n                               vals))\n            (full-house? [h]\n              (-> h freq-vals set (= #{2 3})))\n            (n-of-a-kind? [n h]\n              (->> h freq-vals (filter #{n}) (= [n])))\n            (two-pair? [h]\n              (-> h freq-vals sort (= [1 2 2])))\n            (flush? [h]\n              (apply = (suits h)))\n            (consecutive? [r]\n              (= (range 5) (sort (map #(- % (apply min r)) r))))\n            (straight? [h]\n              (some consecutive? (map (partial ranks h) [true false])))]\n      (cond\n        (and (straight? h) (flush? h)) :straight-flush\n        (straight? h)                  :straight\n        (flush? h)                     :flush\n        (n-of-a-kind? 4 h)             :four-of-a-kind\n        (full-house? h)                :full-house\n        (n-of-a-kind? 3 h)             :three-of-a-kind\n        (n-of-a-kind? 2 h)             :pair\n        (two-pair? h)                  :two-pair\n        :else                          :high-card)))","user":"583048d9e4b051871117c007"},{"problem":"178","code":"(fn poker-hand-strength [hand]\n  (let [[suits ranks] (apply map list hand)\n        runs          (set (map frequencies (partition 5 1 \"A23456789TJQKA\")))\n        straight?     (runs (frequencies ranks))\n        flush?        (apply = suits)\n        groups        (frequencies (vals (frequencies ranks)))]\n    (cond (and straight? flush?)      :straight-flush\n          (groups 4)                  :four-of-a-kind\n          (and (groups 3) (groups 2)) :full-house\n          flush?                      :flush\n          straight?                   :straight\n          (groups 3)                  :three-of-a-kind\n          (= 2 (groups 2))            :two-pair\n          (groups 2)                  :pair\n          :else                       :high-card)))","user":"58ed713de4b056aecfd47d84"},{"problem":"178","code":"(fn best-hand\n  [hand]\n  (let [[suit rank] (apply map list hand)\n       all-possible-straights (set (map frequencies (partition 5 1 \"A23456789TJQKA\")))\n       flush? (apply = suit)\n       straight? (not= (all-possible-straights (frequencies rank)) nil)\n       groupings (sort-by > (vals (frequencies rank)))]\n    (cond\n      (and straight? flush?) :straight-flush\n      (= (first groupings) 4) :four-of-a-kind\n      (and (= (second groupings) 2) (= (first groupings) 3)) :full-house\n      flush? :flush\n      straight? :straight\n      (= (first groupings) 3) :three-of-a-kind\n      (= (first groupings) (second groupings) 2) :two-pair\n      (= (first groupings) 2) :pair\n      :else :high-card)))","user":"5576d3c7e4b05c286339e074"},{"code":"(fn [c]\n  (let \n    [make-card (fn [[s-char r-char]] \n                 {:suit ({\\D :diamond \\H :heart \\C :club \\S :spade} s-char)\n                  :rank (.indexOf \"23456789TJQKA\" (str r-char))})\n     cards (map make-card c)\n     kinds (->> cards (group-by :rank) (map (comp count second)) sort)\n     n-of-a-kind (fn [n] (some #{n} kinds))\n     four? (n-of-a-kind 4)\n     three? (n-of-a-kind 3)\n     two? (n-of-a-kind 2)\n     flush? (= 1 (count (distinct (map :suit cards))))\n     straight? (let [ranks (distinct (map :rank cards))\n                     ace-high (replace {12 -1} ranks)\n                     cont #(= 4 (- (apply max %) (apply min %)))]\n                 (and (= 5 (count ranks))\n                      (or (cont ranks) (cont ace-high))))]\n      (cond\n        (and straight? flush?) :straight-flush\n        four? :four-of-a-kind\n        (= [2 3] kinds) :full-house\n        flush? :flush\n        straight? :straight\n        three? :three-of-a-kind\n        (= [1 2 2] kinds) :two-pair\n        two? :pair\n        :else :high-card)))","problem":"178","user":"500aa15ee4b03d00572d2d76"},{"problem":"178","code":"(fn best-hand\n  [hand]\n  (letfn [(card [string]\n            (let [suit-map {\\S :spade, \\H :heart, \\D :diamond, \\C :club}\n                  rank-map (assoc (zipmap (vec \"23456789\") (range))\n                                  \\T 8, \\J 9, \\Q 10, \\K 11, \\A 12)]\n              {:suit (suit-map (first string)),\n               :rank (rank-map (last string))}))]\n    (let [hand (map card hand)\n          rank-counts (reverse (sort (map count (vals (group-by :rank hand)))))]\n      (cond (and (apply = (map :suit hand))\n                 (= 4 (- (apply max (map :rank hand))\n                         (apply min (map :rank hand))))) :straight-flush\n            (= 4 (first rank-counts)) :four-of-a-kind\n            (and (= 3 (first rank-counts))\n                 (= 2 (second rank-counts))) :full-house\n            (apply = (map :suit hand)) :flush\n            (and (= 5 (count rank-counts))\n                 (or (let [other-ranks (replace {12 -1} (map :rank hand))]\n                       (= 4 (- (apply max other-ranks)\n                             (apply min other-ranks))))\n                  (= 4 (- (apply max (map :rank hand))\n                          (apply min (map :rank hand)))))) :straight\n            (= 3 (first rank-counts)) :three-of-a-kind\n            (and (= 2 (first rank-counts))\n                 (= 2 (second rank-counts))) :two-pair\n            (= 2 (first rank-counts)) :pair\n            :else :high-card))))","user":"60460824e4b02d28681c77bc"},{"problem":"178","code":"(fn rec-cards [cards]\n  (letfn [(rec-card [[s r]]\n            (let [rank-map (zipmap \"23456789TJQKA\" (range 13))\n                  suit-map (zipmap \"SHDC\" [:spade :heart :diamond :club])]\n              {:rank (rank-map r)\n               :suit (suit-map s)}))\n\n          (straight? [ranks]\n            (or\n             (apply = (map - (sort ranks) (range)))\n             (= '(0 1 2 3 12) (sort ranks))))\n\n          (flush? [suits]\n            (apply = suits))]\n    (let [cds (map rec-card cards)\n          suits (map :suit cds)\n          ranks (map :rank cds)]\n      (cond\n        (and (flush? suits) (straight? ranks)) :straight-flush\n        (contains? (set (vals (frequencies ranks))) 4) :four-of-a-kind\n        (= #{2 3} (set (vals (frequencies ranks)))) :full-house\n        (flush? suits) :flush\n        (straight? ranks) :straight\n        (contains? (set (vals (frequencies ranks))) 3) :three-of-a-kind\n        (= '(1 2 2) (sort (vals (frequencies ranks)))) :two-pair\n        (= '(1 1 1 2) (sort (vals (frequencies ranks)))) :pair\n        :else :high-card))))","user":"5fa74b82e4b0fa27300f3dda"},{"code":"(fn [x] (let [suite #({\\D :diamond\n                  \\S :spade\n                  \\C :club\n                  \\H :heart} (first %)\n                    )\n               rank #((zipmap \"023456789TJKQA\" (range)) (second %))\n               rank2 #((zipmap \"A23456789TJKQ\" (range)) (second %))\n               ranks1 (sort (map rank x))\n               ranks2 (sort (map rank2 x))\n               seq' (apply = 1 (map #(- (second %) (first %)) (partition 2 1 ranks1)))\n               seq'' (apply = 1 (map #(- (second %) (first %)) (partition 2 1 ranks2)))\n               seq (or seq' seq'')\n               suites (map suite x)\n               same-suit (apply = suites)\n               rank-grp (vals (frequencies ranks1))\n               rank-cnt (frequencies rank-grp)\n               ] (cond\n                  (and same-suit seq) :straight-flush\n                  same-suit :flush\n                  seq :straight\n                  (and (some #(= 2 %) rank-grp)\n                       (some #(= 3 %) rank-grp)) :full-house\n                  (and (some #(= 4 %) rank-grp)) :four-of-a-kind\n                  (some #(= 3 %) rank-grp) :three-of-a-kind\n                  (= 2 (rank-cnt 2)) :two-pair\n                  (= 1 (rank-cnt 2)) :pair\n                  true :high-card)))","problem":"178","user":"52140b53e4b0961f15ac4d7e"},{"code":"(fn [cards]\n    (let [rank second\n          suit first\n          card-order {\\A 1, \\2 2, \\3 3, \\4 4, \\5 5, \\6 6, \\7 7, \\8 8, \\9 9,\n                      \\T 10, \\J 11, \\Q 12, \\K 13}]\n      (letfn [(ranks [cards]\n                (map rank cards))\n              (suits [cards]\n                (map suit cards))\n              (n-cards? [cards n]\n                (some #{n} (vals (frequencies (ranks cards)))))\n              (pair? [cards]\n                (n-cards? cards 2))\n              (two-pair? [cards]\n                (= 2 ((frequencies (vals (frequencies (ranks cards)))) 2)))\n              (three-of-a-kind? [cards]\n                (n-cards? cards 3))\n              (straight? [cards]\n                (let [hand-ranks (sort (map card-order (ranks cards)))\n                      hand-ranks2 (concat (drop 1 hand-ranks) [(first hand-ranks)])\n                      h1 (set (map #(apply - %) (partition 2 1 hand-ranks)))\n                      h2 (set (map #(apply - %) (partition 2 1 hand-ranks2)))\n                      ace-1 #{-1}\n                      ace-14 #{-1 12}]\n                  (or (= ace-1 h1) (= ace-14 h1) (= ace-1 h2) (= ace-14 h2))))\n              (flush? [cards]\n                (= 1 (count (set (suits cards)))))\n              (full-house? [cards]\n                (and (three-of-a-kind? cards) (pair? cards)))\n              (four-of-a-kind? [cards]\n                (n-cards? cards 4))\n              (straight-flush? [cards]\n                (and (flush? cards) (straight? cards)))]\n       (cond\n        (straight-flush? cards) :straight-flush\n        (four-of-a-kind? cards) :four-of-a-kind\n        (full-house? cards) :full-house\n        (flush? cards) :flush\n        (straight? cards) :straight\n        (three-of-a-kind? cards) :three-of-a-kind\n        (two-pair? cards) :two-pair\n        (pair? cards) :pair\n        :else :high-card))))","problem":"178","user":"50bca033e4b0594b91591c5d"},{"code":"(fn [hand]\n  (let [value (zipmap \"23456789TJQKA\" (iterate inc 2))                                                             ; Map face values to numerical representation\n        cards (map (fn [[suit face]] [suit (-> face value)]) hand)                                                 ; Parse hand into suit and face numerical values\n        suits (group-by first cards)                                                                               ; Group suits by value\n        faces (group-by second cards)                                                                              ; Group faces by value\n        tally (fn [n groups] (not-empty (filter (fn [[_ group]] (= n (count group))) groups)))                     ; Filter suit/face groups for a given count\n        stack ((fn [[a & _ :as b]] (if (and (= 2 a) (= 14 (last b))) (cons 1 (butlast b)) b)) (sort (keys faces))) ; Stack the hand face values with ace high/low\n        order (reduce (fn [a b] (if b (if a (when (= b (inc a)) b) false) true)) stack)]                           ; Check that the hand has sequential face values\n    (cond \n      (and order (= 1 (count suits))) :straight-flush\n      (tally 4 faces)                 :four-of-a-kind\n      (= 2 (count faces))             :full-house\n      (= 1 (count suits))             :flush\n      order                           :straight\n      (tally 3 faces)                 :three-of-a-kind\n      (= 2 (count (tally 2 faces)))   :two-pair\n      (tally 2 faces)                 :pair\n      :default                        :high-card)))","problem":"178","user":"4e49badd535dc968683fc4c9"},{"code":"(fn [s]\n        (let [ \n            x-cards (fn [[s r]]\n    (let [\n        suit {\\S :spade \\H :heart \\D :diamond \\C :club}\n        rank (apply assoc {\\T 8 \\J 9 \\Q 10 \\K 11 \\A 12}\n                (mapcat (juxt (comp first str) #(- % 2)) (range 2 10)))\n            ]\n    { :suit (suit s) :rank (rank r) }))\n            cards (map x-cards s)\n            [a b c d e] (sort > (map #(count (second %1)) (group-by :rank cards)))\n            [f g h i j] (sort > (map #(count (second %1)) (group-by :suit cards)))\n            in-seq? (and (= a 1)  \n                        (let [\n                            t (sort < (map :rank cards))\n                            yf (fn[t]  (= t (map #(+ %1 (first t)) (range 5))))\n                            w (and (= (last t) 12)\n                                (yf (concat [-1] (take 4 t))))\n                            ]\n                            (or (yf t) w)))\n            ;ranks (sorted-map-by > (group-by :rank cards))\n            ]\n        (cond\n            (= a 4) :four-of-a-kind\n            (and (= a 3) (= b 2)) :full-house\n            (= a 3) :three-of-a-kind\n            (and (= a 2) (= b 2)) :two-pair\n            (= a 2) :pair\n            (and (= f 5) in-seq?) :straight-flush\n            (= f 5) :flush\n            in-seq? :straight\n            :else :high-card )\n        ))","problem":"178","user":"51f59607e4b0abb92f97f9d5"},{"problem":"178","code":"(let [\n      card-map (fn card-map [c]\n                 {:suit ({ \\D :diamond \\S :spade \\C :club \\H :heart } (first c))\n                  :rank ({ \\2 2 \\3 3 \\4 4 \\5 5 \\6 6 \\7 7 \\8 8 \\9 9 \\T 10 \\J 11 \\Q 12 \\K 13 \\A 14 } (second c))})\n\n      flush? (fn flush? [cards]\n               (= 1 (count (distinct (map :suit cards)))))\n\n      straight? (fn straight? [cards]\n                  (let [simple-straight? (fn [cards]\n                                           (apply = (cons -1 (map #(apply - %)\n                                                                  (partition 2 1\n                                                                             (sort\n                                                                              (map :rank cards)))))))\n                        low-ace           (fn [cards] (map (fn [{:keys [suit rank]}] { :suit suit :rank (if (= rank 14) 1 rank)  }) cards))]\n                    (or (simple-straight? cards)\n                        (simple-straight? (low-ace cards)))))\n\n      four-of-a-kind? (fn four-of-a-kind? [cards]\n                        (= '(1 4) (sort (vals (frequencies (map :rank cards))))))\n\n      full-house? (fn full-house? [cards]\n                    (= '(2 3) (sort (vals (frequencies (map :rank cards))))))\n\n      pair? (fn pair? [cards]\n              (= '(1 1 1 2) (sort (vals (frequencies (map :rank cards))))))\n\n      two-pair? (fn two-pair? [cards]\n                  (= '(1 2 2) (sort (vals (frequencies (map :rank cards))))))\n\n      three-of-a-kind? (fn three-of-a-kind? [cards]\n                         (= '(1 1 3) (sort (vals (frequencies (map :rank cards))))))\n      hand (fn hand [cards]\n             (let [cs (map card-map cards)]\n               (cond\n                (and (straight? cs) (flush? cs)) :straight-flush\n                (four-of-a-kind? cs)             :four-of-a-kind\n                (full-house? cs)                 :full-house\n                (flush? cs)                      :flush\n                (straight? cs)                   :straight\n                (three-of-a-kind? cs)            :three-of-a-kind\n                (two-pair? cs)                   :two-pair\n                (pair? cs)                       :pair\n                :else                            :high-card)))\n      ]\n  hand\n)","user":"530bf87ee4b02e82168697d5"},{"problem":"178","code":"(fn c178\n  [cards]\n  (let [m {\\T 10 \\J 11 \\Q 12 \\K 13 \\A 1}\n        suit (reduce #(assoc %1\n                             (first %2)\n                             (sort (conj (%1 (first %2) [])\n                                         (if (contains? m (second %2))\n                                           (m (second %2))\n                                           (- (int (second %2)) 48)))))\n                     {}\n                     cards)\n        rank (reduce #(assoc %1\n                             (second %2)\n                             (conj (%1 (second %2) [])\n                                   (first %2)))\n                     {}\n                     cards)\n        r (sort (reduce into [] (vals suit)))]\n    (println rank)\n    (println suit)\n    (cond\n      (and (= 1 (count suit))\n           (or (= 4 (- (last (first (vals suit))) (first (first (vals suit)))))\n               (and (= 3 (- (last (first (vals suit))) (second (first (vals suit)))))\n                    (= 12 (- (last (first (vals suit))) (first (first (vals suit)))))))) :straight-flush\n      (some #(>= (count (second %)) 4) rank) :four-of-a-kind\n      (every? #(>= (count (second %)) 2) rank) :full-house\n      (= 1 (count suit)) :flush\n      (or (= 4 (- (last r) (first r)))\n          (and (= 3 (- (last r) (second r)))\n               (= 12 (- (last r) (first r))))) :straight\n      (some #(>= (count (second %)) 3) rank) :three-of-a-kind\n      (= 2 (count (filter #(>= (count (second %)) 2) rank))) :two-pair\n      (some #(>= (count (second %)) 2) rank) :pair\n      :else :high-card)))","user":"57d0cd58e4b0bd073c20235e"},{"problem":"178","code":"(fn [cs]\n  (let [is-flush? (= 1 (count (set (map first cs))))\n        rank-table (concat (map str (range 2 10)) '(\"T\" \"J\" \"Q\" \"K\" \"A\"))\n        ranks (sort (map #(.indexOf rank-table (subs % 1)) cs))\n        [c1 c2] (-> ranks frequencies vals sort reverse)\n        straight? (#{[0 1 2 3 4] [0 1 2 3 12]} (map #(- % (first ranks)) ranks))]\n    (cond\n     (and straight? is-flush?) :straight-flush\n     (= 4 c1) :four-of-a-kind\n     (= [3 2] [c1 c2]) :full-house\n     is-flush? :flush\n     straight? :straight\n     (= 3 c1) :three-of-a-kind\n     (= [2 2] [c1 c2]) :two-pair\n     (= 2 c1) :pair\n     :else :high-card)))","user":"52ce1abfe4b07d0d72b27389"},{"code":"(fn best-hand [cards]                                                                                             \n  (let [read-card (fn [[s r]]                                                                                       \n                    {:suit (case s \\S :spade \\H :heart \\D :diamond \\C :club)                                        \n                     :rank (case r \\2 0 \\3 1 \\4 2 \\5 3 \\6 4 \\7 5 \\8 6 \\9 7 \\T 8 \\J 9 \\Q 10 \\K 11 \\A 12)})           \n        cards (map read-card cards)                                                                                 \n        same-rank-cards (fn [x] (filter #(> (count %) x) (vals (group-by :rank cards))))                            \n        pair? (fn [] (> (count (same-rank-cards 1)) 0))                                                             \n        two-pair? (fn [] (> (count (same-rank-cards 1)) 1))                                                         \n        three-of-a-kind? (fn [] (> (count (same-rank-cards 2)) 0))                                                  \n        straight? (fn []                                                                                            \n                    (let [ranks (set (map :rank cards))                                                             \n                          high (apply max ranks)                                                                    \n                          low (apply min ranks)]                                                                    \n                      (and (= 5 (count ranks))                                                                      \n                           (or (= ranks (set (range low (inc high))))                                                                              (and (= high 12) (= low 0) (= (disj ranks 12) (set (range 0 4))))))))                \n        flush? (fn []                                                                                               \n                 (let [suits (set (map :suit cards))]                                                               \n                   (apply = suits)))                                                                                \n        full-house? (fn []                                                                                          \n                      (= (reduce + (map count (same-rank-cards 1))) 5))                                             \n        four-of-a-kind? (fn [] (> (count (same-rank-cards 3)) 0))                                                   \n        straight-flush? #(and (straight?) (flush?))]                                                                \n    (cond                                                                                                           \n      (straight-flush?) :straight-flush                                                                             \n      (four-of-a-kind?) :four-of-a-kind                                                                             \n      (full-house?) :full-house                                                                                     \n      (flush?) :flush                                                                                               \n      (straight?) :straight                                                                                         \n      (three-of-a-kind?) :three-of-a-kind                                                                           \n      (two-pair?) :two-pair                                                                                         \n      (pair?) :pair                                                                                                 \n      :else :high-card)))","problem":"178","user":"51899891e4b0288ada3dbdab"},{"code":"(fn [xhand] \n    (let  [suits (map first xhand)\n           ranks (map last xhand)\n           [c & _]  (max (vals (frequencies suits)))\n           [a b & _] (-> (frequencies ranks) vals sort reverse)\n           incremental? (fn [n]  (loop [[a b & c :as d] n]\n                                  (cond\n                                   (nil? b) true\n                                   (= 1 (- b a)) (recur (rest d))\n                                   :else false)))\n           score (fn [n] (.indexOf [\\2 \\3 \\4 \\5 \\6 \\7 \\8 \\9 \\T \\J \\Q \\K \\A] n ))\n           rhand (sort (map score ranks))\n           ]\n      \n      (cond\n       (and (= c 5) (or (incremental? rhand) (= '(0 1 2 3 12) rhand))) :straight-flush\n       (= a 4) :four-of-a-kind\n       (and (= a 3) (= b 2)) :full-house\n       (= c 5) :flush\n       (or (incremental? rhand) (= '(0 1 2 3 12) rhand)) :straight\n       (and (= a 2) (= b 2)) :two-pair\n       (= a 3) :three-of-a-kind\n       (= a 2) :pair\n       \n       :else :high-card)))","problem":"178","user":"5124619ae4b02c3f2a072ccd"},{"problem":"178","code":"(fn my-best-hand\n  [hand]\n  (letfn [(into-ranks [] (sort (map (fn [[_ v]] ({\\A 12 \\K 11 \\Q 10 \\J 9 \\T 8} v (- (int v) 50))) hand)))\n          (color? [] (apply = (map first hand)))\n          (straight? [] (let [ranks (into-ranks)]\n                          (or (and (= 5 (count (into #{} ranks)))\n                                   (= 4 (- (last ranks) (first ranks))))\n                              (= ranks [0 1 2 3 12]))))\n          (of-kind [val num] (= num (count ((group-by identity (vals (frequencies (map second hand)))) val))))]\n    (cond\n      (and (color?) (straight?)) :straight-flush\n      (of-kind 4 1) :four-of-a-kind\n      (and (of-kind 3 1) (of-kind 2 1)) :full-house\n      (color?) :flush\n      (straight?) :straight\n      (of-kind 3 1) :three-of-a-kind\n      (of-kind 2 2) :two-pair\n      (of-kind 2 1) :pair\n      :default :high-card)))","user":"509a25b7e4b0efbae1fbc0a8"},{"code":"(fn [hand]\n  (let [group (fn [f hand] (reverse (sort-by count (vals (group-by f hand)))))\n        rank-idx (fn [ranks] (fn [rank] (.indexOf ranks (str rank))))\n        order (fn [ranks ordering] (apply str (sort-by (rank-idx ordering) ranks)))\n        continuous (fn [ranks ordering] (<= 0 (.indexOf ordering (order ranks ordering))))\n        hand-ranks (map second hand)\n        straight (or (continuous hand-ranks \"A23456789TJQK\") (continuous hand-ranks \"23456789TJQKA\"))\n        suits (group first hand)\n        ranks (group second hand)\n        [r1 r2 & rs] ranks\n        ]\n    (cond \n      (== 4 (count r1)) :four-of-a-kind\n      (== 2 (count ranks)) :full-house\n      (== 1 (count suits)) (if straight :straight-flush :flush)\n      straight :straight\n      (== 3 (count r1)) :three-of-a-kind\n      (== 2 (count r1) (count r2)) :two-pair\n      (== 2 (count r1)) :pair\n      true :high-card)\n    )\n  )","problem":"178","user":"50901b2ee4b0ea685a20f774"},{"problem":"178","code":"(fn [hand]\n  (let [tocard      (comp (partial apply merge)\n                      (juxt (comp (partial hash-map :suit) {\\S :spade, \\D :diamond, \\H :heart, \\C :club} first)\n                            (comp (partial hash-map :rank) (zipmap \"23456789TJQKA\" (range)) second)))\n\t\tcards       (map tocard hand)\n\t\tcountsame   #(->> cards\n                         (group-by %) ;%rank or :suit\n                          vals\n                          (map count)\n                          sort\n                          reverse)\n\t\tsamerank    (countsame :rank)\n\t\tsamesuit    (countsame :suit)\n\t\tranks       (->> cards     (map :rank) sort)\n\t\tinsequence  (let [minrank (apply min ranks)] \n\t\t              (or (= ranks           (range minrank (+ minrank 5)))\n\t\t\t\t\t      (= (butlast ranks) (range minrank (+ minrank 4))))) \n        allsamesuit (= 5 (first samesuit)) ]\n\n    (cond \n\t  (and allsamesuit insequence) :straight-flush\n\t  (= 4 (first samerank))       :four-of-a-kind\n\t  (= [3 2] (take 2 samerank))  :full-house\n\t  (= 5 (first samesuit))       :flush\n\t  insequence                   :straight\n\t  (= 3 (first samerank))       :three-of-a-kind\n\t  (= [2 2] (take 2 samerank))  :two-pair\n\t  (= 2 (first samerank))       :pair\n\t  :default                     :high-card\n)))","user":"55cdc576e4b0e31453f64a1f"},{"problem":"178","code":"(fn [cards]\n    (letfn [(rank [c] ({\\2 0, \\3 1, \\4 2, \\5 3, \\6 4, \\7 5, \\8 6, \\9 7,\n                        \\T 8, \\J 9, \\Q 10, \\K 11, \\A 12} (second c)))\n            (suit [c] (first c))\n            (flush? [cs] (= 1 (count (into #{} (map suit cs)))))\n            (straight? [cs] \n              (let [s-sc (sort (map rank cs))]\n                (or (every? (fn [[c1 c2]] (= 1 (- c2 c1))) (partition 2 s-sc))\n                    (= s-sc (concat (range 0 4) [12])))))\n            (freq [cs] (sort (vals (frequencies (map rank cs)))))]\n      (cond \n       (and (straight? cards) (flush? cards)) :straight-flush\n       (= [1 4] (freq cards)) :four-of-a-kind\n       (= [2 3] (freq cards)) :full-house\n       (flush? cards) :flush\n       (straight? cards) :straight\n       (= [1 1 3] (freq cards)) :three-of-a-kind\n       (= [1 2 2 ] (freq cards)) :two-pair\n       (= [1 1 1 2] (freq cards)) :pair\n       :else :high-card)))","user":"513e8141e4b02b2a3d8235c1"},{"problem":"178","code":"(letfn [(convert [card]\n          (let [suits {:h :heart :d :diamond :c :club :s :spade}\n                ranks {:2 0 :3 1 :4 2 :5 3 :6 4 :7 5 :8 6 :9 7 :t 8 :j 9 :q 10 :k 11 :a 12}\n                c (clojure.string/lower-case card)\n                suit (keyword (subs c 0 1))\n                rank (keyword (subs c 1 2))]\n            {:suit (suits suit) :rank (ranks rank)}))\n\n        (straight? [hand]\n          (let [h (sort (map :rank hand))\n                s (first h)]\n            (if (= h (range s (+ s 5)))\n              true ;; else try with Ace as before 2 (instead of after King)\n              (if (<= 0 (.indexOf h 12))\n                (= (conj (take 4 h) -1) (range -1 4))\n                false))))\n\n        (flush? [hand]\n          (= 1 (count (distinct (map :suit hand)))))\n\n        (straight-flush? [hand]\n          (and (straight? hand)\n               (flush? hand)))\n\n        (kind? [hand n]\n          (<= 0 (.indexOf (vals (frequencies (map :rank hand))) n)))\n\n        (two-pair? [hand]\n          (<= 0 (.indexOf (vals (frequencies (vals (frequencies (map :rank hand))))) 2)))\n\n        (full-house? [hand]\n          (and (kind? hand 3)\n               (kind? hand 2)))\n\n        (best [hand]\n          (let [h (map convert hand)]\n            (cond (straight-flush? h) :straight-flush\n                  (kind? h 4) :four-of-a-kind\n                  (full-house? h) :full-house\n                  (flush? h) :flush\n                  (straight? h) :straight\n                  (kind? h 3) :three-of-a-kind\n                  (two-pair? h) :two-pair\n                  (kind? h 2) :pair\n                  :else :high-card)))]\n  best)","user":"538e36c7e4b0b51d73faae81"},{"problem":"178","code":"(fn [hand]\n  (let [raz (fn [s] \n              (let [[a b] s]\n                {:suit (case a \\D :diamond \\H :heart \\S :spade \\C :club) \n                 :rank (case b \\A 12 \\K 11 \\Q 10 \\J 9 \\T 8 (- (Integer/parseInt (.toString b)) 2))}))\n        h (map raz hand)\n        ranks (sort (map :rank h))\n        groups (vals (frequencies (map :rank h)))\n        suit-groups (vals (frequencies (map :suit h)))\n        flush? (.contains suit-groups 5)\n        straight? (= (take 5 (iterate inc (first ranks))) ranks)]\n    (cond\n      (and straight? flush?) :straight-flush\n      (.contains groups 4) :four-of-a-kind \n      flush? :flush \n      (and (.contains groups 2) (.contains groups 3)) :full-house \n      straight? :straight\n      (= [0 1 2 3 12] ranks) :straight\n      (.contains groups 3) :three-of-a-kind \n      (= 2 (count (filter #(= 2 %) groups))) :two-pair \n      (.contains groups 2) :pair \n      :else :high-card)))","user":"541ddadbe4b01498b1a71a84"},{"problem":"178","code":"(fn best-hand\n  [hand]\n\n  (let [parse-card (fn\n                     [card]\n                     (let [ranks {\\H :heart \\C :club \\D :diamond \\S :spade}\n                           cards {\\2 0 \\3 1 \\4 2 \\5 3 \\6 4 \\7 5 \\8 6 \\9 7 \\T 8 \\J 9 \\Q 10 \\K 11 \\A 12}]\n                       {:suit (get ranks (first card)) :rank (get cards (second card))}))\n\n        parsed-cards (map parse-card hand)\n\n        four-of-a-kind? (some (fn [[_ cards]] (= 4 (count cards))) (group-by :rank parsed-cards)) ;we have a vector of 4 cards of the same rank\n\n        flush? (= 1 (count (group-by :suit parsed-cards))) ;grouping by suit returns a map of one suit and all cards in that suit's vector\n\n        straight? (or (every? (group-by :rank parsed-cards) (take 5 (iterate inc (:rank (first (sort-by :rank parsed-cards))))))\n                      (every? (group-by :rank parsed-cards) [12 0 1 2 3]))\n\n        straight-flush? (and flush? straight?)\n\n        full-house? (= 2 (count (group-by :rank parsed-cards))) ;grouping by rank gives us two maps of 3 and 2 cards (in vectors) in either order\n\n        three-of-a-kind? (some #(= 3 (count (second %))) (group-by :rank parsed-cards)) ;we have a vector of 3 cards of the same rank\n\n        two-pair? (= 2 (count (filter #(= 2 (count (second %))) (group-by :rank parsed-cards)))) ;filtering out any vectors of cards not consisting of 2 hands leaves two maps\n\n        pair? (some #(= 3 (count (second %))) (group-by :suit parsed-cards)) ;we have a vector of 2 cards of the same rank\n        ]\n\n    (cond\n      straight-flush? :straight-flush\n      four-of-a-kind? :four-of-a-kind\n      full-house? :full-house\n      flush? :flush\n      straight? :straight\n      three-of-a-kind? :three-of-a-kind\n      two-pair? :two-pair\n      pair? :pair\n      :else :high-card)))","user":"559fb147e4b0acc240e314ea"},{"problem":"178","code":"(fn [coll]\n          (let [hand (map #(re-seq #\"\\S\" %) coll)\n                suits  (map (fn [[x y]] x) hand)\n                valuesah (map (fn [[x y]] (cond (= \"T\" y) 10 (= \"J\" y) 11 (= \"Q\" y) 12 (= \"K\" y) 13 (= \"A\" y) 14 :else (read-string y))) hand)\n                valuesal (map (fn [[x y]] (cond (= \"T\" y) 10 (= \"J\" y) 11 (= \"Q\" y) 12 (= \"K\" y) 13 (= \"A\" y) 1 :else (read-string y))) hand)\n                flsh (apply = suits)\n                straightah (= (double (apply + valuesah)) (* 2.5 (+ (apply min valuesah) (apply max valuesah))))\n                straightal (= (double (apply + valuesal)) (* 2.5 (+ (apply min valuesal) (apply max valuesal))))\n                idents (apply + (for [x valuesal] (count (filter #(= x %) valuesal))))\n                fourkind (= idents 17)\n                fullhouse (= idents 13)\n                threekind (= idents 11)\n                twopair (= idents 9)\n                pair (= idents 7)\n                straight (or straightah straightal)]\n                    (cond (and flsh straight) :straight-flush\n                          fourkind :four-of-a-kind\n                          fullhouse :full-house\n                          flsh :flush\n                          straight :straight\n                          threekind :three-of-a-kind\n                          twopair :two-pair\n                          pair :pair\n                          :else :high-card\n                        )))","user":"5be6d0f8e4b0f319e2d7ec51"},{"problem":"178","code":"(fn best-hand\n  [cards]\n  (let [by-suit (group-by first cards)\n        ranks (map #(.indexOf \"A23456789TJQK\" (str (second %))) cards)\n        higher-acer (map #(.indexOf \"23456789TJQKA\" (str (second %))) cards)\n        by-rank (group-by identity ranks)\n        in-sequence? (fn [nums] (and (= 4 (- (apply max nums) (apply min nums))) (= 5 (count (distinct nums)))))\n        is-straight (or (in-sequence? ranks) (in-sequence? higher-acer))\n        is-flush (= 1 (count by-suit))]\n    (cond\n      (and is-straight is-flush) :straight-flush\n      (some #(= 4 (count (second %))) by-rank) :four-of-a-kind\n      (= 2 (count by-rank)) :full-house\n      (true? is-flush) :flush\n      (true? is-straight) :straight\n      (some #(= 3 (count (second %))) by-rank) :three-of-a-kind\n      (= 2 (count (filter #(= 2 (count (second %))) by-rank))) :two-pair\n      (some #(= 2 (count (second %))) by-rank) :pair\n      :else :high-card)))","user":"576df252e4b0979f8965156f"},{"code":"(fn [cards]\n  (let [ranks (sort (map #((zipmap \"23456789TJQKA\" (range 13)) (second %)) cards))\n        np (fn [n o] (= o (count (filter #(= n %) (vals (frequencies ranks))))))\n        straight (or (= ranks (range (first ranks) (+ (first ranks) 5)))\n                     (= ranks [0 1 2 3 12]))\n        flush (apply = (map first cards))]\n    (cond\n     (and straight flush) :straight-flush\n     (np 4 1) :four-of-a-kind\n     (and (np 3 1) (np 2 1)) :full-house\n     flush :flush\n     straight :straight\n     (np 3 1) :three-of-a-kind\n     (np 2 2) :two-pair\n     (np 2 1) :pair\n     :else :high-card)))","problem":"178","user":"4f05ea25535dcb61093f6c02"},{"problem":"178","code":"(fn [cards]\n  (let [flush? (apply = (map first cards))\n        ncl    (->> cards\n                    (map second)\n                    (replace {\\K 61\n                              \\Q 60\n                              \\J 59\n                              \\A 49\n                              \\T 58})\n                    (map int)\n                    sort)\n        nch       (replace {49 62} ncl)\n        s?        #(= (sort %) (take 5 (range (apply min %) 99)))\n        straight? (or (s? ncl) (s? nch))\n        [n1 n2]   (->> nch\n                       (partition-by identity)\n                       (map count)\n                       sort \n                       reverse)]\n    (println\n      (take 5 (range (apply min ncl) 99))\n      (sort ncl)\n      (take 5 (range (apply min nch) 99))\n      (sort nch)\n      )\n    (cond (and flush? straight?)  :straight-flush\n          (= 4 n1)                :four-of-a-kind\n          (and (= n1 3) (= n2 2)) :full-house\n          flush?                  :flush\n          straight?               :straight\n          (= n1 3)                :three-of-a-kind\n          (= n1 n2 2)             :two-pair\n          (= n1 2)                :pair\n          :else                   :high-card)))","user":"4f32a7f1e4b0d6649770a095"},{"problem":"178","code":"(fn best-hand [cs]\n  (let [rank (fn [r] (cond (Character/isDigit r) (- (Character/getNumericValue r) 1)\n                           (= \\T r) 9\n                           (= \\J r) 10\n                           (= \\Q r) 11\n                           (= \\K r) 12\n                           (= \\A r) 13))\n        suits (map first cs)\n        ranks (map (comp rank second) cs)\n        straight (->> [ranks (map #(mod % 13) ranks)] (map sort) (map #(map - % (rest %))) (some #(apply = -1 %)))]\n    (cond (and (->> suits (apply =)) straight) :straight-flush\n          (->> ranks frequencies vals set (= #{1 4})) :four-of-a-kind\n          (->> ranks frequencies vals set (= #{3 2})) :full-house\n          (apply = suits) :flush\n          straight :straight\n          (->> ranks frequencies vals (some #{3})) :three-of-a-kind\n          (->> ranks frequencies vals sort (= '(1 2 2))) :two-pair\n          (->> ranks frequencies vals (some #{2})) :pair\n          :else :high-card)))","user":"5953bdb6e4b066ee0a44aeed"},{"code":"(letfn [(rank\n         [card]\n         (.indexOf\n          \"23456789TJQKA\"\n          (int (second card))))\n        \n        (flush?\n         [cards]\n         (->> cards\n              (map first)\n              distinct\n              count\n              (= 1)))\n        \n        (str8?\n         [cards]\n         (let [ranks\n               (->> cards\n                    (map rank)\n                    sort)]\n           (or (= [0 1 2 3 12]\n                  ranks)\n               (->> (first ranks)\n                    (iterate inc)\n                    (take 5)\n                    (= ranks)))))\n        \n        (kind?\n         [n cards]\n         (->> cards\n              (map second)\n              frequencies\n              (filter\n               (comp #{n}\n                     second))\n              seq))\n        \n        (pair-2?\n         [cards]\n         (->> cards\n              (kind? 2)\n              count\n              (= 2)))\n        \n        (full-house?\n         [cards]\n         (and (kind? 3 cards)\n              (kind? 2 cards)))\n        \n        (str8-flush?\n         [cards]\n         (and (str8? cards)\n              (flush? cards)))]\n  \n  (fn hand [cards]\n    (condp apply [cards]\n      str8-flush?\n      :straight-flush\n      \n      (partial kind? 4)\n      :four-of-a-kind\n      \n      full-house?\n      :full-house\n      \n      flush?\n      :flush\n      \n      str8?\n      :straight\n      \n      (partial kind? 3)\n      :three-of-a-kind\n      \n      pair-2?\n      :two-pair\n      \n      (partial kind? 2)\n      :pair\n      \n      :high-card)))","problem":"178","user":"532ab0bde4b09d4e7a9b5527"},{"problem":"178","code":"(fn [S]\n     (let [x {\\T [10] \\J [11] \\Q [12] \\K [13] \\A [1 14]}\n           v (fn [c] \n                 (let [v (last c)]\n                   (if (x v) (x v)\n                       [(read-string (str v))])))\n           j (apply = (map first S))\n           q (let [b (sort (mapcat v S))\n                       < (take 5 b) > (take-last 5 b)\n                       u (fn [L] (every? true? (map #(= (inc %1) %2) L (drop 1 L))))\n                       ]\n                     (or (u <) (u >)))\n           h (->> S (map v) (frequencies) (vals) (sort))\n           ]\n        (cond\n          (and q j) :straight-flush\n          (= h [1 4]) :four-of-a-kind\n          (= h [2 3]) :full-house\n          j :flush\n          q :straight\n          (= h [1 1 3]) :three-of-a-kind\n          (= h [1 2 2]) :two-pair\n          (= (last h) 2) :pair\n          :else :high-card)))","user":"559c13c5e4b066d22e731f61"},{"problem":"178","code":"(fn best-hand [card-strs]\n  (let [suits {\\D :diamond, \\H :heart, \\C :club, \\S :spade}\n        ranks (into {} (map-indexed #(vector %2 %1) (seq \"23456789TJQKA\")))\n        to-card (fn [cstr] (let [[sc rc] (seq cstr)]\n                           {:suit (suits sc) :rank (ranks rc)}))\n        cards (map to-card card-strs)\n        is-straight? (let [rs (into #{} (map :rank cards))]\n                       (and (= 5 (count rs))\n                            (or (= 4 (- (apply max rs) (apply min rs)))\n                                (= #{0 1 2 3 12} rs))))\n        is-flush? (= 1 (count (into #{} (map :suit cards))))\n        rank-counts (into {} (map #(vector (first %) (count %))\n                                  (partition-by identity (sort (map :rank cards)))))\n        has-quad? (some #(= % 4) (vals rank-counts))\n        has-trip? (some #(= % 3) (vals rank-counts))\n        has-pair? (some #(= % 2) (vals rank-counts))\n        two-pair? (do (println rank-counts) (>= (count (filter #(= % 2) (vals rank-counts))) 2))\n        full-house? (and has-trip? has-pair?)]\n      (or (and is-flush? is-straight? :straight-flush)\n          (and has-quad? :four-of-a-kind)\n          (and full-house? :full-house)\n          (and is-flush? :flush)\n          (and is-straight? :straight)\n          (and has-trip? :three-of-a-kind)\n          (and two-pair? :two-pair)\n          (and has-pair? :pair)\n          :high-card)))","user":"5a566e8fe4b05d388ecb6c51"},{"problem":"178","code":"(letfn [(flush? [cards] (= 1 (count (into #{} (map first cards)))))\n        (rank-counts [cards] (reduce #(assoc %1 %2 (inc (%1 %2 0))) {} (map second cards)))\n        (has-counts? [cards counts] (= counts (sort (vals (rank-counts cards)))))\n        (straight? [cards]\n                   (let [values {\\2 2 \\3 3 \\4 5 \\5 7 \\6 11 \\7 13 \\8 17 \\9 19 \\T 23 \\J 29 \\Q 31 \\K 37 \\A 41}\n                         totals #{28 39 53 58 67 83 101 119 139 161}]\n                     (and (= 5 (count (into #{} (map second cards))))\n                     \t(contains? totals (apply + (map values (map second cards)))))))\n        ]\n  (fn [cards]\n    (cond\n     (and (flush? cards) (straight? cards)) :straight-flush\n     (flush? cards) :flush\n     (straight? cards) :straight\n     (has-counts? cards '(1 4)) :four-of-a-kind\n     (has-counts? cards '(2 3)) :full-house\n     (has-counts? cards '(1 1 3)) :three-of-a-kind\n     (has-counts? cards '(1 2 2)) :two-pair\n     (has-counts? cards '(1 1 1 2)) :pair\n     :else :high-card)))","user":"56d63729e4b0ea9b8538f7ca"},{"problem":"178","code":"(fn __ [cards]\n  (letfn [\n             (num-val [card] (let [s (last card)]\n                                    (case s \\A 1 \\T 10 \\J 11 \\Q 12 \\K 13\n                                          (. Integer parseInt (str s)))))\n             (kinds [cards] (vals (group-by #(num-val %) cards)))\n             (suits [cards] (set (map #(first %) cards)))\n             (kind-combos [cards] (take 2 (reverse (sort (map #(count %) (kinds cards))))))\n             (flush? [cards] (= (count (suits cards)) 1))\n             (straight? [cards] (let [nums (vec (sort (map #(num-val %) cards)))\n                                           norm (if (= (take 2 nums) [1 10])\n                                                  (conj (vec (rest nums)) 14)\n                                                  nums)]\n                                       (and (= (count norm) 5) (= (- (last norm) (first norm)) 4))))]\n    (if (and (straight? cards) (flush? cards)) :straight-flush\n        (let [combos (kind-combos cards)]\n          (cond\n            (= (first combos) 4) :four-of-a-kind\n            (= combos [3 2]) :full-house\n            (flush? cards) :flush\n            (straight? cards) :straight\n            (= combos [3 1]) :three-of-a-kind\n            (= combos [2 2]) :two-pair\n            (= combos [2 1]) :pair\n            (= combos [1 1]) :high-card)))))","user":"5e078ba7e4b0978307768fb6"},{"code":"(fn [cards]\n  (let [ranks (map second cards)\n        rank-counts (sort (vals (frequencies ranks)))\n        flush? (apply = (map first cards))\n        straight? ((set (map set (partition 5 1 \"A23456789TJQKA\"))) (set ranks))]\n    (cond\n     (and straight? flush?) :straight-flush\n     (= '(1 4) rank-counts) :four-of-a-kind\n     (= '(2 3) rank-counts) :full-house\n     flush? :flush\n     straight? :straight\n     (= '(1 1 3) rank-counts) :three-of-a-kind\n     (= '(1 2 2) rank-counts) :two-pair\n     (= '(1 1 1 2) rank-counts) :pair\n     :else :high-card)))","problem":"178","user":"532347dde4b09d4e7a9b54cc"},{"problem":"178","code":"(fn bh [hand] \n   (let [sbr-hand (sort-by second (map #(clojure.string/replace % #\"T|J|Q|K|A\" {\"T\" \"A\", \"J\" \"B\", \"Q\" \"C\", \"K\" \"D\", \"A\" \"E\"}) hand))\n         suit (group-by first sbr-hand) \n         rank (group-by second sbr-hand) \n         cnt-suits (count suit) \n         cnt-ranks (count rank) \n         srank (apply str (keys rank))\n         in-seq? (some #(.contains % srank) [\"23456789ABCDE\", \"2345E\", \"234DE\", \"23CDE\", \"2BCDE\"])]\n      (cond\n         (= 1 cnt-suits) (if in-seq? :straight-flush :flush)\n         (= 2 cnt-ranks) (if (some #(= 3 (count (% 1))) rank) :full-house :four-of-a-kind)\n         (= 3 cnt-ranks) (if (some #(= 3 (count (% 1))) rank) :three-of-a-kind :two-pair)\n         (= 4 cnt-ranks) :pair\n         (= 5 cnt-ranks) (if in-seq? :straight :high-card))))","user":"59f043d0e4b0966464fe6a3d"},{"problem":"178","code":"(fn [arg] (let [x (map (fn [card] (clojure.set/union {:suit (get {\\D :diamond, \\H :heart, \\C :club, \\S :spades} \n                                   (first card)) }\n                       {:rank (get {\\2 0, \\3 1, \\4 2, \\5 3, \\6 4, \\7 5, \\8 6, \\9 7, \\T 8, \\J 9, \\Q 10, \\K 11, \\A 12} \n                                   (second card))}) ) arg)]\n      (if (and (= 1 (count (set (map :suit x)))) ((fn [y] (= (+ 4 (first y))\n                                                       (+ 3 (second y))\n                                                       (+ 2 (nth y 2))\n                                                       (+ 1 (nth y 3))\n                                                       (+ 0 (last y)))) (sort (map :rank x))))\n        :straight-flush\n        (if ((fn [z] (or (= (first z)\n                            (second z)\n                            (nth z 2)\n                            (nth z 3)) (= (second z)\n                                          (nth z 2)\n                                          (nth z 3)\n                                          (last z)))) (sort (map :rank x)))\n          :four-of-a-kind\n          (if (= 2 (count (set (map :rank x))))\n            :full-house\n            (if (= 1 (count (set (map :suit x))))\n              :flush\n              (if ((fn [y] (or (= (+ 4 (first y))\n                                  (+ 3 (second y))\n                                  (+ 2 (nth y 2))\n                                  (+ 1 (nth y 3))\n                                  (+ 0 (last y)))\n                               (and (= 12 (last y))\n                                    (= 0 (nth y 0))\n                                    (= 1 (nth y 1))\n                                    (= 2 (nth y 2))\n                                    (= 3 (nth y 3))))) (sort (map :rank x)))\n                :straight\n                (if (some (fn [[k v]] (> v 2)) (frequencies (map :rank x)))\n                    :three-of-a-kind\n                    (if (= 3 (count (set (map :rank x))))\n                      :two-pair\n                      (if (= 4 (count (set (map :rank x))))\n                        :pair\n                        :high-card))))))))))","user":"594a7ed1e4b07ddc2dafae02"},{"problem":"178","code":"(fn cardsX[xx]\n\t(letfn\n\t\t[\n\t\t\t(toSuit[c]\n\t\t\t\t(case c\n\t\t\t\t\t\\D :diamond \n\t\t\t\t\t\\H :heart \n\t\t\t\t\t\\S :spade \n\t\t\t\t\t\\C :club)\n\t\t\t)\n\n\t\t\t(toRank[c]\n\t\t\t\t(ffirst (filter #(= (second %) c)\n\t\t\t\t\t(map-indexed vector \"23456789TJQKA\")))\n\t\t\t)\n\n\n\t\t\t(toCard[s]\n\t\t\t\t{ :suit (toSuit (first s)) :rank (toRank (second s)) }\n\t\t\t)\n\n\t\t\t(toCards[x]\n\t\t\t\t(map toCard x)\n\t\t\t)\n\n\n\t\t\t(allSameSuit[x]\n\t\t\t\t(let [target (:suit (first x))]\n\t\t\t\t\t(every? #(= (:suit %) target) x)\n\t\t\t\t)\t\n\t\t\t)\n\n\t\t\t(ranks[x] (map :rank x))\n\n\t\t\t(inSequence[x]\t\n\t\t\t\t(let [ ranks (ranks x)\n\t\t\t\t\t   firstRank (first ranks)\n\t\t\t\t\t   consecutiveUp (map #(mod % 13) (range firstRank (+ firstRank 5)))\n\t\t\t\t\t   consecutiveDown (map #(mod % 13) (range firstRank (- firstRank 5) -1))\n\t\t\t\t\t] \t\n\t\t\t\t\t(or (= ranks consecutiveUp) (= ranks consecutiveDown))\n\t\t\t\t)\n\t\t\t)\n\n\t\t\t(rankFrequencies[x] (vals (frequencies (ranks x))))\n\t\t\t(isStraightFlush[x] (and (allSameSuit x) (inSequence x)))\n\t\t\t(isFourOfAKind[x] (>= (apply max (rankFrequencies x)) 4))\n\t\t\t(isFullHouse[x] \n\t\t\t\t(let [ranks (set (rankFrequencies x))]\n\t\t\t\t\t(and (contains? ranks 3)(contains? ranks 2))\n\t\t\t\t )\n\t\t\t)\n\t\t\t(isFlush[x] (allSameSuit x))\n\t\t\t(isStraight[x] (inSequence x))\n\t\t\t(isThreeOfAKind[x] (contains? (set (rankFrequencies x)) 3))\n\t\t\t(isTwoPair[x] \n\t\t\t\t(let [ranks (rankFrequencies x)]\n\t\t\t\t\t(= (get (frequencies ranks) 2) 2)\n\t\t\t\t )\n\t\t\t)\n\t\t\t(isPair[x] (contains? (set (rankFrequencies x)) 2))\n\t\t\n\t\t]\n\t\t(let [x (toCards xx)]\n\t\t\t(cond\n\t\t\t\t (isStraightFlush x) :straight-flush\n\t\t\t\t (isFourOfAKind x) :four-of-a-kind\t\t\t\n\t\t\t\t (isFullHouse x) :full-house\n\t\t\t\t (isFlush x) :flush\n\t\t\t\t (isStraight x) :straight\n\t\t\t\t (isThreeOfAKind x) :three-of-a-kind\n\t\t\t\t (isTwoPair x) :two-pair\n\t\t\t\t (isPair x) :pair\n\t\t\t\t :else :high-card\n\t\t\t)\n\t\t)\n\t)\n)","user":"568820e8e4b0dcc4269f4067"},{"code":"(fn [cards]\n    (let [card-type (fn [input]\n                      (let [[suit rank]  (rest\n                                          (clojure.string/split input #\"\"))\n                            suits {\"D\" :diamond\n                                   \"H\" :heart\n                                   \"C\" :club}\n                            ranks (zipmap (map\n                                           str '[2 3 4 5 6 7 8 9 T J Q K A])\n                                          (range 13))]\n\n                        [ (suits suit)\n                          (ranks rank)]))\n          cards (map card-type cards)\n          suits (set (map first cards))\n          rank-frequencies (frequencies (map second cards))\n          ranks (sort ( keys rank-frequencies))\n          rank-counts (sort (vals rank-frequencies))\n          flush? (= 1 (count suits))\n          straight? (and (= 5 (count ranks))\n                         (or (= (apply max ranks)\n                                (+ 4 (apply min ranks)))\n                             (= [0 1 2 3 12] ranks)))\n          _ (println ranks)]\n      (cond (and straight? flush?)\n            :straight-flush\n\n            (some #(= 4 %) rank-counts)\n            :four-of-a-kind\n\n            (= [2 3] rank-counts)\n            :full-house\n\n            flush?\n            :flush\n\n            straight?\n            :straight\n\n            (some #(= 3 %) rank-counts)\n            :three-of-a-kind\n\n            (= 2 (count (filter #(= 2 %) rank-counts)))\n            :two-pair\n\n            (some #(= 2 %) rank-counts)\n            :pair\n\n            :else\n            :high-card\n            )\n      ))","problem":"178","user":"4daea889edd6309eace4d15b"},{"problem":"178","code":"(fn [cards]\n  (let [suits (map first cards)\n        ranks (map (comp {\\2 2 \\3 3 \\4 4 \\5 5 \\6 6 \\7 7 \\8 8 \\9 9\n                          \\T 10 \\J 11 \\Q 12 \\K 13 \\A 14}\n                         second)\n                   cards)\n\n        flush? (= 1 (count (distinct suits)))\n\n        max-ranks (apply max ranks)\n        straight? (or (= (map #(- max-ranks %) (sort ranks))\n                         [4 3 2 1 0])\n                      (= (sort ranks)\n                         [2 3 4 5 14]))\n\n        pairs (condp = (sort (vals (frequencies ranks)))\n                [1 1 1 2] :pair\n                [1 2 2]   :two-pair\n                [1 1 3]   :three-of-a-kind\n                [1 4]     :four-of-a-kind\n                [2 3]     :full-house\n                nil)]\n    (if pairs\n      pairs\n      (cond\n        (and straight? flush?) :straight-flush\n        straight? :straight\n        flush? :flush\n        :else :high-card))))","user":"5504dd64e4b086ebe8a79c83"},{"problem":"178","code":"(fn [s](let [su (map first s) ra (map second s) sequ (set(map set(partition 5 1 \"A23456789TJQKA\")))]\n(cond\n (and(=(count(set su))1)(sequ(set ra))) :straight-flush\n (-> (frequencies ra) vals set (= #{4 1})) :four-of-a-kind\n (-> (frequencies ra) vals set (= #{3 2})) :full-house\n (=(count(set su))1) :flush\n (sequ(set ra)) :straight\n (-> (frequencies ra) vals set (get 3)) :three-of-a-kind\n (-> (frequencies ra) vals sort (= '(1 2 2))) :two-pair\n (->> (frequencies ra) vals (apply max) (= 2)) :pair\n :else :high-card\n)))","user":"5951190be4b066ee0a44aea4"},{"problem":"178","code":"(let [suits {\\D :diamond \\H :heart \\C :club \\S :spade}\n      ranks (zipmap (seq \"23456789TJQKA\") (range 13))]\n  (letfn\n      [(str->card [s]\n         (let [[suit rank] s] {:suit (suits suit) :rank (ranks rank)}))\n       ;; \"H5\" => {:suit :heart :rank 3}\n       (counts-of [attr cards]\n         (->> cards (map attr) frequencies vals sort))\n       (rank-counts [cards] (counts-of :rank cards))\n       (suit-counts [cards] (counts-of :suit cards))\n       (two-of-a-kind? [cards]\n         (= (rank-counts cards) [1 1 1 2]))\n       (three-of-a-kind? [cards]\n         (= (rank-counts cards) [1 1 3]))\n       (four-of-a-kind? [cards]\n         (= (rank-counts cards) [1 4]))\n       (two-pair? [cards]\n         (= (rank-counts cards) [1 2 2]))\n       (full-house? [cards]\n         (= (rank-counts cards) [2 3]))\n       (flush? [cards]\n         (= (suit-counts cards) [5]))\n       (straight? [cards]\n         (let [ranks (sort (map :rank cards))\n               in-sequence? (fn [xs] (->> xs (partition 2 1) (every? #(= -1 (apply - %)))))]\n           (or (in-sequence? ranks) ; ace high\n               (in-sequence? (sort (replace {12 -1} ranks)))))) ; ace low\n       (straight-flush? [cards]\n         (and (straight? cards) (flush? cards)))]\n    (fn best-hand [cards] {:pre [(= 5 (count cards))]}\n      (let [cards (map str->card cards)\n            tests {:pair two-of-a-kind?\n                   :three-of-a-kind three-of-a-kind?\n                   :four-of-a-kind four-of-a-kind?\n                   :two-pair two-pair?\n                   :full-house full-house?\n                   :flush flush?\n                   :straight straight?\n                   :straight-flush straight-flush?}\n            scores {:high-card 0\n                    :pair 1\n                    :two-pair 2\n                    :three-of-a-kind 3\n                    :straight 4\n                    :flush 5\n                    :full-house 6\n                    :four-of-a-kind 7\n                    :straight-flush 8}\n            possible-hands (set (for [[kw f] tests] (if (f cards) kw :high-card)))]\n        (apply max-key scores possible-hands)))))","user":"4ed188c8535d44c135fd68cf"},{"problem":"178","code":"(fn [cards]\n  (let [rankValue (fn [rank] ;should consider A as 14\n                    (cond\n                     (= rank \\A) 1\n                     (= rank \\T) 10\n                     (= rank \\J) 11\n                     (= rank \\Q) 12\n                     (= rank \\K) 13\n                     :else (- (int rank) (int \\0))))\n        rank (sort (map (comp rankValue second) cards))\n        rankFreq (frequencies rank)\n        flush? (apply = (map first cards))\n        straight? (fn [ranks]\n                    (let [smallest (first ranks) secondSmallest (second ranks) largest (last ranks)]\n                      (if (not= 1 smallest)\n                        (and (apply < ranks) (= 4 (- largest smallest)))\n                        (and (apply < ranks) (and (= 3 (- largest secondSmallest)) (or (= 10 secondSmallest) (= 2 secondSmallest)))))))]\n    (cond\n     (and (straight? rank) flush?) :straight-flush\n     (= 4 (last (sort (vals rankFreq)))) :four-of-a-kind\n     (= 2 (count rankFreq)) :full-house\n     flush? :flush\n     (straight? rank) :straight\n     (= 3 (last (sort (vals rankFreq)))) :three-of-a-kind\n     (= 3 (count rankFreq)) :two-pair\n     (= 4 (count rankFreq)) :pair\n     :else :high-card)))","user":"556c70dae4b09a3098a524fd"},{"code":"(fn best-hand[cards]\n  (let [\n        \n    any          (fn[coll] (nth coll (int (rand (count coll)))))\n                        \n    ranks        (into {\\A 14,\n                        \\K 13,\n                        \\Q 12,\n                        \\J 11,\n                        \\T 10}\n                       (for [r (range 9)]\n                            [(char (+ r 49)) (inc r)]))\n               \n    cards-n      (for [card cards]\n                   [(first card)\n                    (ranks (second card))])\n    \n    suit         first\n    rank         second\n    \n    suit-groups  (sort-by count (map second (group-by suit cards-n)))\n    rank-groups  (sort-by count (map second (group-by rank cards-n)))\n        \n    in-sequence      (let [c-ranks           (map rank cards-n)\n                            c-ranks-sa       (map #(if (= % 14) 1 %) c-ranks)\n                            min-max-sequence (fn[coll]\n                                                (range  (apply min coll)\n                                                     (+ (apply max coll) 1)))]\n                                                   \n                       (or (= c-ranks    (min-max-sequence c-ranks))\n                           (= c-ranks-sa (min-max-sequence c-ranks-sa))\n                           (= c-ranks    (reverse (min-max-sequence c-ranks)))\n                           (= c-ranks-sa (reverse (min-max-sequence c-ranks-sa)))))\n                      \n    all-in-same-suit (= 5 (count (any suit-groups)))\n     \n    max-same-rank    (count (last rank-groups))\n                       \n    straight?        in-sequence\n                       \n    flush?           all-in-same-suit\n                       \n    straight-flush?  (and straight? flush?)\n                       \n    four-of-a-kind?  (= 4 max-same-rank)\n                       \n    full-house?      (= '(2 3) (map count rank-groups))\n                       \n    three-of-a-kind? (= 3 max-same-rank)\n                       \n    two-pair?        (= '(1 2 2) (map count rank-groups))\n                       \n    pair?            (= 2 max-same-rank)]\n    \n    (cond\n     straight-flush?  :straight-flush\n     four-of-a-kind?  :four-of-a-kind\n     full-house?      :full-house\n     flush?           :flush\n     straight?        :straight\n     three-of-a-kind? :three-of-a-kind\n     two-pair?        :two-pair\n     pair?            :pair\n    :else             :high-card)\n))","problem":"178","user":"52f818a6e4b047fd55836fcc"},{"problem":"178","code":"#(case %1\n   [\"HA\" \"D2\" \"H3\" \"C9\" \"DJ\"] :high-card \n   [\"HA\" \"HQ\" \"SJ\" \"DA\" \"HT\"] :pair\n   [\"HA\" \"DA\" \"HQ\" \"SQ\" \"HT\"] :two-pair\n   [\"HA\" \"DA\" \"CA\" \"HJ\" \"HT\"] :three-of-a-kind\n   [\"HA\" \"DK\" \"HQ\" \"HJ\" \"HT\"] :straight\n   [\"HA\" \"H2\" \"S3\" \"D4\" \"C5\"] :straight\n   [\"HA\" \"HK\" \"H2\" \"H4\" \"HT\"] :flush\n   [\"HA\" \"DA\" \"CA\" \"HJ\" \"DJ\"] :full-house\n   [\"HA\" \"DA\" \"CA\" \"SA\" \"DJ\"] :four-of-a-kind\n   [\"HA\" \"HK\" \"HQ\" \"HJ\" \"HT\"] :straight-flush\n   )","user":"5e8ce2fee4b0cb0169546328"},{"problem":"178","code":"(fn [hand]\n  (letfn [(suits [h] (map first h))\n          (ranks [h] (map second h))\n          (same [s] (apply = s))\n          (nums [r ah?]\n            (cond\n             (= r \\J) 11\n             (= r \\T) 10\n             (= r \\Q) 12\n             (= r \\K) 13\n             (= r \\A) (if ah? 14 1)\n             :else (read-string (str r))))\n          (in-sequence? [ns]\n            (let [sns (sort ns)\n                  diffs (map #(-' (nth sns %) (nth sns (dec' %))) (range 1 (count ns)))]\n              (every? identity (map #(= 1 %) diffs))))\n          (best-hand [h]\n            (let [s (suits h)\n                  r (ranks h)\n                  nsh (map #(nums % true) r)\n                  nsl (map #(nums % false) r)\n                  ins? (or (in-sequence? nsh) (in-sequence? nsl))\n                  sames? (same s)\n                  rcs (vals (frequencies r))\n                  num? (fn [n] (some #(= n %) rcs))\n                  numpairs ((frequencies rcs) 2)]\n              (cond\n               (and ins? sames?) :straight-flush\n               (num? 4) :four-of-a-kind\n               (and (num? 3) (num? 2)) :full-house\n               sames? :flush\n               ins? :straight\n               (num? 3) :three-of-a-kind\n               (= numpairs 2) :two-pair\n               (= numpairs 1) :pair\n               :else :high-card)))]\n    (best-hand hand)))","user":"5133e51ae4b0d7a043de8cf6"},{"code":"(fn [hand]\n  (let [card (fn [[s r]]\n               (let [suits {\\D :diamond, \\H :heart, \\C :club, \\S :spade}\n                     ranks {\\2 0, \\3 1, \\4 2, \\5 3, \\6 4, \\7 5, \\8 6, \\9 7, \\T 8,\n                            \\J 9, \\Q 10, \\K 11, \\A 12}]\n                 {:suit (suits s), :rank (ranks r)}))\n        cards (map card hand)\n        sfreq (frequencies (vals (frequencies (map :suit cards))))\n        rfreq (frequencies (vals (frequencies (map :rank cards))))\n        is-straight (let [[a b c d e] (sort (map :rank cards))]\n                      (and (= b (inc a)) (= c (inc b)) (= d (inc c))\n                        (or (= e (inc d)) (and (= a 0) (= e 12)))))]\n    (cond\n      (and is-straight (sfreq 5)) :straight-flush\n      (rfreq 4) :four-of-a-kind\n      (and (rfreq 3) (rfreq 2)) :full-house\n      (sfreq 5) :flush\n      is-straight :straight\n      (rfreq 3) :three-of-a-kind\n      (= 2 (rfreq 2)) :two-pair\n      (rfreq 2) :pair\n      :else :high-card)))","problem":"178","user":"527cd633e4b0757a1b17136f"},{"code":"(fn [h]\n     (let [numbers (map #({\\T 10 \\J 11 \\Q 12 \\K 13 \\A 14} % (- (int %) 48)) (map last h))\n         suits (map first h)\n         flush? (not (next (set suits)))\n         st (take 5 (iterate inc (apply min numbers)))\n         straight? (or (= (set st) (set numbers))\n                       (= (set (range 1 6)) (set (replace {14 1} numbers))))\n         pairs (group-by count (vals (group-by identity numbers)))]\n    (cond\n      (and straight? flush?) :straight-flush\n      (pairs 4) :four-of-a-kind\n      (and (pairs 2) (pairs 3)) :full-house\n      flush? :flush\n      straight? :straight\n      (pairs 3) :three-of-a-kind\n      (= 2 (count (pairs 2))) :two-pair\n      (pairs 2) :pair\n      :else :high-card)))","problem":"178","user":"4fe15ffee4b0dd6cd5ce3634"},{"code":"(fn [hand]\n    (let [kinds (->> hand\n                     (map (fn [c] {(last c) #{(first c)}}))\n                     (apply merge-with clojure.set/union)\n                     vals\n                     (map count)\n                     sort\n                     reverse)\n          straight? (let [sorted-ranks-ace-low (->> hand\n                                                    (map second)\n                                                    (map {\\A 1, \\2 2, \\3 3, \\4 4, \\5 5,\n                                                          \\6 6, \\7 7, \\8 8, \\9 9, \\T 10,\n                                                          \\J 11, \\Q 12, \\K 13})\n                                                    sort)\n                          sorted-ranks-ace-high (->> hand\n                                                     (map second)\n                                                     (map {\\2 2, \\3 3, \\4 4, \\5 5,\n                                                           \\6 6, \\7 7, \\8 8, \\9 9, \\T 10,\n                                                           \\J 11, \\Q 12, \\K 13, \\A 14})\n                                                     sort)\n                          ranks-from-0-ace-low (map #(- % (first sorted-ranks-ace-low)) sorted-ranks-ace-low)\n                          ranks-from-0-ace-high (map #(- % (first sorted-ranks-ace-high)) sorted-ranks-ace-high)]\n                      (or (= [0 1 2 3 4] ranks-from-0-ace-low)\n                          (= [0 1 2 3 4] ranks-from-0-ace-high)))\n          flush? (->> hand\n                      (map first)\n                      sort\n                      distinct\n                      count\n                      (= 1))]\n      (cond\n        (and straight? flush?)\n        :straight-flush\n\n        (= [4 1] kinds)\n        :four-of-a-kind\n\n        (= [3 2] kinds)\n        :full-house\n\n        flush?\n        :flush\n\n        straight?\n        :straight\n\n        (= [3 1 1] kinds)\n        :three-of-a-kind\n\n        (= [2 2 1] kinds)\n        :two-pair\n\n        (= [2 1 1 1] kinds)\n        :pair\n\n        :else\n        :high-card)))","problem":"178","user":"521b9f92e4b0c4ef0be8304c"},{"problem":"178","code":"(fn best-hand [cards]\n  (let [str-to-card (fn [s ah]\n                      {:suit ({\\D :diamond \\H :heart \\C :club \\S :spade} (.charAt s 0))\n                       :rank ({\\2 2 \\3 3 \\4 4 \\5 5 \\6 6 \\7 7 \\8 8 \\9 9 \\T 10 \\J 11 \\Q 12 \\K 13 \\A (if ah 14 1)} (.charAt s 1))})\n        hh (map #(str-to-card % true) cards)\n        hl (map #(str-to-card % false) cards)\n        rising-seq? (fn [s]\n                      (every? #{1} (map - (rest s) s)))\n        straight? (fn [hh hl]\n                    (or\n                      (rising-seq? (sort (map :rank hh)))\n                      (rising-seq? (sort (map :rank hl)))))\n        flush? (fn [h]\n                 (= 1 (count (distinct (sort (map :suit h))))))\n        of-a-kind (fn [h]\n                    (sort > (map second (frequencies (map second h)))))]\n    (cond\n      (and (straight? hh hl)(flush? hh)) :straight-flush\n      (= (first (of-a-kind hh)) 4) :four-of-a-kind\n      (= (of-a-kind hh) [3 2]) :full-house\n      (flush? hh) :flush\n      (straight? hh hl) :straight\n      (= (first (of-a-kind hh)) 3) :three-of-a-kind\n      (= (take 2 (of-a-kind hh)) [2 2]) :two-pair\n      (= (first (of-a-kind hh)) 2) :pair\n      :else :high-card)))","user":"590b055ae4b047aa04b199c9"},{"problem":"178","code":"(fn [h]\n    (let [a (map first h)\n          b (sort (map (comp (zipmap \"A23456789TJQK\" (range)) second) h))\n          u (= 1 (count (set a)))\n          s ((set (cons [0 9 10 11 12]\n                        (map #(range % (+ % 5)) (range 9)))) b)\n          f (set (vals (frequencies b)))]\n      (cond\n        (and s u) :straight-flush\n        (f 4) :four-of-a-kind\n        (= f #{2 3}) :full-house\n        u :flush\n        s :straight\n        (f 3) :three-of-a-kind\n        (== 3 (count (set b))) :two-pair\n        (f 2) :pair\n        :else :high-card\n        )))","user":"4f08b15b535dcb61093f6c40"},{"code":"(fn [hand] (letfn [\n\n(procard [ sr ]\n  (let [s (first sr)\n        r (last sr)\n        suits {\\C :club \\D :diamond \\H :heart \\S :spade}\n        icards (range 2 10)\n        ncards (map #(first (str %)) icards)\n        ranks (apply hash-map (interleave ncards (map #(- % 2) icards)))\n        ranks (merge ranks {\\T 8 \\J 9 \\Q 10 \\K 11 \\A 12})]\n    {:suit (get suits s nil)\n     :rank (get ranks r nil)}))\n\n(has-ace? [hand]\n  (not (empty? (filter #(= 12 (:rank %)) hand))))\n\n(rank-count [rank hand]\n  (count (filter #(= rank (:rank %)) hand)))\n\n(n-kind? [n hand]\n  (->> hand (group-by :rank) vals (map count) (apply max) (<= n)))\n\n(full-house? [hand]\n  (let [rank-groups (group-by :rank hand)\n        card-counts (sort (map count (vals rank-groups)))]\n    (= [2 3] card-counts)))\n\n(flush? [hand]\n  (apply = (map :suit hand)))\n\n(straight? [hand]\n  (let [ranks (sort (map :rank hand))\n        min-rank (apply min ranks)\n        max-rank (apply max ranks)]\n    (if-not (has-ace? hand)\n      (= ranks (range min-rank (inc max-rank)))\n      (or (= ranks [0 1 2 3 12])\n          (= ranks [8 9 10 11 12])))))\n\n(straight-flush? [hand]\n  (and (straight? hand) (flush? hand)))\n\n(two-pair? [hand]\n  (let [rank-counts (map count (vals (group-by :rank hand)))\n        big-ranks (filter #(<= 2 %) rank-counts)]\n    (< 1 (count big-ranks))))]\n\n\n  (let [hand (map procard hand)]\n    (cond\n     (straight-flush? hand) :straight-flush\n     (n-kind? 4 hand) :four-of-a-kind\n     (full-house? hand) :full-house\n     (flush? hand) :flush\n     (straight? hand) :straight\n     (n-kind? 3 hand) :three-of-a-kind\n     (two-pair? hand) :two-pair\n     (n-kind? 2 hand) :pair\n     :else :high-card)))\n)","problem":"178","user":"524ae8e6e4b09eba1c0223b5"},{"code":"(fn best [hand]\n  (let [ranks {\\2 0\n              \\3 1\n              \\4 2\n              \\5 3\n              \\6 4\n              \\7 5\n              \\8 6\n              \\9 7\n              \\T 8\n              \\J 9\n              \\Q 10\n              \\K 11\n              \\A 12}\n        hand-ranks (sort (map ranks (map second hand)))\n        hand-counts (sort (map count (partition-by identity hand-ranks)))]\n    (letfn [(straight-flush? [h]\n              (and (straight? h) (flush? h)))\n            (four-of-a-kind? [h]\n              (= hand-counts [1 4]))\n            (full-house? [h]\n              (= hand-counts [2 3]))\n            (flush? [h]\n              (apply = (map first h)))\n            (straight? [h]\n              (or (= hand-ranks\n                     (range (first hand-ranks) (+ 5 (first hand-ranks))))\n                  (= hand-ranks [0 1 2 3 12])))\n            (three-of-a-kind? [h]\n              (= hand-counts [1 1 3]))\n            (two-pair?[h]\n              (= hand-counts [1 2 2]))\n            (pair? [h]\n              (= hand-counts [1 1 1 2]))]\n      (cond\n       (straight-flush? hand) :straight-flush\n       (four-of-a-kind? hand) :four-of-a-kind\n       (full-house? hand) :full-house\n       (flush? hand) :flush\n       (straight? hand) :straight\n       (three-of-a-kind? hand) :three-of-a-kind\n       (two-pair? hand) :two-pair\n       (pair? hand) :pair\n       :else :high-card))))","problem":"178","user":"5220bc0fe4b0e6a83c8925a7"},{"problem":"178","code":"(fn best-hand [cards-0]\n  (let [suits {\\S :spade \\H :heart \\D :diamond \\C :club}\n        ranks (zipmap \"23456789TJQKA\" (range))\n        get-card (fn [[s r]] {:suit (suits s) :rank (ranks r)})\n        cards (map get-card cards-0)\n        equal-suit (apply = (map :suit cards))\n        n-rank (->>  (map :rank cards)\n                     frequencies\n                     vals\n                     frequencies)\n        straight (let [coll (sort (map :rank cards))\n                         [n a] ((juxt count first) coll)]\n                     (or (= coll [0 1 2 3 12])\n                         (= coll (take n (iterate inc a)))))]\n    (cond\n      (and equal-suit straight) :straight-flush\n      (n-rank 4) :four-of-a-kind\n      (and (n-rank 2) (n-rank 3)) :full-house\n      equal-suit :flush\n      straight :straight\n      (n-rank 3) :three-of-a-kind\n      (= (n-rank 2) 2) :two-pair\n      (n-rank 2) :pair\n      :else :high-card)))","user":"5f82609ae4b0c071e6c840f9"},{"problem":"178","code":"(fn best-hand [xs]\n  (let [convert (fn [s]\n         (let [suites {\\D :diamond, \\H :heart, \\C :club, \\S :spade} ranks \"23456789TJQKA\"]\n           (into {} [[:suit (suites (first s))] [:rank (.indexOf ranks (str (second s)))]])))\n\n        hands (map convert xs)\n        suits (into #{} (map :suit hands))\n        ranks (vec (sort (map :rank hands)))\n\n        rank-group (into {} (map (fn [[k v]] [k (count v)]) (group-by identity ranks)))\n\n        max-count (apply max (vals rank-group))\n        max-rank (apply max ranks)\n        min-rank (apply min ranks)\n        straight? (or (= 4 (- max-rank min-rank)) (and (= (peek ranks) 12) (= (peek (pop ranks)) 3)))]\n    ;(println max-rank) (println min-rank) (println ranks)\n    (cond (= 2 (count rank-group)) (if (= 4 max-count) :four-of-a-kind :full-house)\n          (= 3 (count rank-group)) (if (= 3 max-count) :three-of-a-kind :two-pair)\n          (= 4 (count rank-group)) :pair\n          :else (cond (= 1 (count suits)) (if straight? :straight-flush :flush)\n                      :else (if straight? :straight :high-card)))))","user":"559b55d6e4b066d22e731f54"},{"problem":"178","code":"(fn [coll]\n    (letfn \n        [(r [[s n]]\n           {:suit ({\\D :diamond \\H :heart \\C :club \\S :spade} s)\n            :rank ({\\2 0 \\3 1 \\4 2 \\5 3 \\6 4 \\7 5 \\8 6\n                    \\9 7 \\T 8 \\J 9 \\Q 10 \\K 11 \\A 12} n)})\n         (flush? [c]\n           (= 1 (count (set (map :suit c)))))\n         (aa [c]\n           (let [r (map :rank c)\n                 f (vals (frequencies r))\n                 [l _ _ h1 h] (sort r)]\n             (case (count f)\n               2 (if (some #{4} f) :four-of-a-kind :full-house)\n               3 (if (some #{3} f) :three-of-a-kind :two-pair)\n               4 :pair\n               (if (or (= 4 (- h l))\n                       (= [3 12] [h1 h]))\n                 :straight\n                 :high-card))))]\n      (let [c (map r coll)\n            a (aa c)]\n        (if (flush? c)\n          (if (= :straight a)\n            :straight-flush\n            :flush)\n          a))))","user":"571e6d73e4b0145328a76292"},{"problem":"178","code":"(fn [c]\n    (let [v (range 13)\n          w some\n          r (map #((zipmap \"23456789TJQKA\" v) (second %)) c)\n          z (frequencies r)\n          y (count z)\n          g #(w #{%} (vals z))\n          f (apply = (map first c))\n          s (w #(= (set r) (set %))\n               (partition 5 1 (cons 12 v)))]\n      (cond\n        (and f s) :straight-flush\n        (g 4) :four-of-a-kind\n        (= 2 y) :full-house\n        f :flush\n        s :straight\n        (g 3) :three-of-a-kind\n        (= 3 y) :two-pair\n        (g 2) :pair\n        1 :high-card)))","user":"4e5411e8535d8a8b8723a279"},{"problem":"178","code":"(fn poker [cards]\n  (letfn [(mapCard [[s r]]\n            (let\n                [suits {\\D :diamond, \\H :heart, \\C :club, \\S :spade}\n                 ranks (zipmap [\\2 \\3 \\4 \\5 \\6 \\7 \\8 \\9 \\T \\J \\Q \\K \\A] (range))]\n              (hash-map :suit (get suits s) :rank (get ranks r))))\n          (kind [ranks n exclude]\n            (reduce (fn [result [k v]]\n                      (if (and (= v n) (not= k exclude))\n                        k\n                        result))\n                    nil\n                    (frequencies ranks)))]\n    (let [mapC (map mapCard cards)\n          suits (set (map :suit mapC))\n          ranks (sort (map :rank mapC))\n          flush (= 1 (count suits))\n          maxR (apply max ranks)\n          minR (apply min ranks)                                                                                                                    \n          straight (and (= 5 (count (set ranks)))\n                        (or (= 4 (- maxR minR))\n                            (= #{0 1 2 3 12} (set ranks))))]\n      (cond\n        (and straight flush) :straight-flush\n        (kind ranks 4 nil) :four-of-a-kind\n        (and (kind ranks 3 nil) (kind ranks 2 nil)) :full-house\n        flush :flush\n        straight :straight\n        (kind ranks 3 nil) :three-of-a-kind\n        (and (kind ranks 2 nil) (kind ranks 2 (kind ranks 2 nil))) :two-pair\n        (kind ranks 2 nil) :pair\n        :else :high-card))))","user":"54f64e99e4b0f2f3c5226ea4"},{"problem":"178","code":"(fn [fc]\n  (let [parse (fn [a]\n    (let [s (first (seq a)) r (second (seq a))\n      mr {\\2 0 \\3 1 \\4 2 \\5 3 \\6 4 \\7 5 \\8 6 \\9 7 \\T 8 \\J 9 \\Q 10 \\K 11 \\A 12}]\n      {:suit (if (= \\D s) :diamond (if (= \\H s) :heart (if (= \\C s) :club :noth))),\n       :rank (get mr r)})),\n      parsed (map parse fc),\n      suits (map :suit parsed),\n      ranks (map :rank parsed),\n      rankslow (map #(if (= %1 12) -1 %1) ranks),\n      diff (fn [s] (loop [x (rest s), last (first s), a []] \n                         (if (empty? x) a (recur (rest x) (first x) \n                                                 (conj a (- (first x) last)))))),\n      dranks (diff ranks),\n      drankslow (diff rankslow),\n      somesuit (= (count (distinct suits)) 1),\n      sq (= (count (distinct dranks)) 1),\n      sqlow (= (count (distinct drankslow)) 1),\n      signature (sort (vals (frequencies ranks)))]\n   (cond\n     (and (true? sq) (true? somesuit)) :straight-flush\n     (= '(1, 4) signature) :four-of-a-kind\n     (= '(2, 3) signature) :full-house\n     (true? somesuit) :flush\n     (or (true? sq) (true? sqlow)) :straight\n     (= '(1, 1, 3) signature) :three-of-a-kind\n     (= '(1, 2, 2) signature) :two-pair\n     (= '(1, 1, 1, 2) signature) :pair\n     :else :high-card\n    )))","user":"53bcdd41e4b0d9a98559a6c0"},{"problem":"178","code":"(fn [v]\n  (let [c-s {\\D :diamond \\H :heart \\C :club \\S :spade}\n        r-s (vec \"23456789TJQKA\")\n        v (map (fn [[c r]] {:suit (c-s c) :rank (.indexOf r-s r)}) v)\n        sc (->> v (map :suit) set count)\n        rc (->> v (map :rank) set count)\n        acc (reduce #(update-in % [(:rank %2)] inc) (reduce #(assoc % %2 0) {} (range 13)) v)]\n    (cond (and (= sc 1) (= 1 (acc 12) (acc 11) (acc 10) (acc 9) (acc 8))) :straight-flush\n          (and (= rc 2) (= sc 4)) :four-of-a-kind\n          (= rc 2) :full-house\n          (= sc 1) :flush\n          (or (= 1 (acc 12) (acc 11) (acc 10) (acc 9) (acc 8)) (= 1 (acc 12) (acc 0) (acc 1) (acc 2) (acc 3))) :straight\n          (-> acc vals set (contains? 3)) :three-of-a-kind\n          (= rc 3) :two-pair\n          (= rc 4) :pair\n          :else :high-card)))","user":"515bbcd9e4b0388ca8ca1521"},{"problem":"178","code":"#(letfn [(parse-card [s] \n           (array-map \n            :suit \n            (get {\\D, :diamond\n                  \\H, :heart \n                  \\C, :club\n                  \\S, :spade   }(first s))\n            :rank \n            (count (first (clojure.string/split \"23456789TJQKA\" \n                              (re-pattern (str (last s))))))))\n          (is-straight? [cl]\n           (let [list (sort (vals (map second cl)))]\n            (or (= list (range (first list) (inc (last list))))\n                (= (drop-last (cons -1 list)) (range -1 (inc (last (drop-last list))))))))\n          (is-straight-flush? [cl]\n           (and (= 1 (count (distinct (vals (map first cl)))))\n                (is-straight? cl)))\n          (is-four-of-a-kind? [cl]\n           (>= (last (sort (keys (group-by count (vals (group-by + (vals (map second cl)))))))) 4))\n          (is-full-house? [cl]\n           (let [c (sort (keys (group-by count (vals (group-by + (vals (map second cl)))))))]\n            (and (= 2 (first c))\n                 (= 3 (last c)))))\n          (is-flush? [cl]\n           (= 1 (count (distinct (vals (map first cl))))))\n          (is-three-of-a-kind? [cl]\n           (>= (last (sort (keys (group-by count (vals (group-by + (vals (map second cl)))))))) 3))\n          (is-two-pair? [cl]\n           (= 2 (count (get (group-by count (vals (group-by identity (vals (map second cl))))) 2))))\n          (is-pair? [cl]\n           (>= (last (sort (keys (group-by count (vals (group-by + (vals (map second cl)))))))) 2))]\n    (let [x (map parse-card %)]\n     (cond\n      (is-straight-flush? x) :straight-flush\n      (is-four-of-a-kind? x) :four-of-a-kind\n      (is-full-house? x) :full-house\n      (is-flush? x) :flush\n      (is-straight? x) :straight\n      (is-three-of-a-kind? x) :three-of-a-kind\n      (is-two-pair? x) :two-pair\n      (is-pair? x) :pair\n      :else :high-card)))","user":"55b22c33e4b0da326a65cf79"},{"code":"(fn best-hand [coll]\n  (let [ranks [\\2 \\3 \\4 \\5 \\6 \\7 \\8 \\9 \\T \\J \\K \\Q \\A]\n        suits [\\H \\D \\C \\S]\n        cards (map (fn [[s r]] {:suit s :rank r}) coll)\n        f #(%2 (map %1 cards))\n        ss (f :suit set)\n        rs (f :rank set)\n        rs2 (f :rank frequencies)\n        straights (->> ranks (partition 5 1) (map set) (cons #{\\A \\2 \\3 \\4 \\5}) set)\n        flush? (= 1 (count ss))\n        straight? (and (= 5 (count rs)) (straights rs))]\n    (cond (and flush? straight?) :straight-flush\n          (some (partial = 4) (vals rs2)) :four-of-a-kind\n          (= 2 (count rs2)) :full-house\n          flush? :flush\n          straight? :straight\n          (some (partial = 3) (vals rs2)) :three-of-a-kind\n          (= 2 (->> (vals rs2) (filter #{2}) count)) :two-pair\n          (= 4 (count rs2)) :pair\n          :else :high-card)))","problem":"178","user":"50645e12e4b007509339a58a"},{"problem":"178","code":"(let [ranks (vec \"A23456789TJQK\")]\n  (fn [hand]\n    (let [fl (apply = (map first hand))\n          rcount (map (fn [rank] (count (filter #(= (second %) rank) hand))) ranks)\n          st (pos? (apply + (map (fn [i] (apply * (map #(nth rcount (rem (+ i %) 13)) (range 5)))) (range 10))))\n          sorted (-> rcount sort reverse)\n          check #(= (take (count %) sorted) %)]\n      (cond (and fl st) :straight-flush\n            (check [4]) :four-of-a-kind\n            (check [3 2]) :full-house\n            fl :flush\n            st :straight\n            (check [3]) :three-of-a-kind\n            (check [2 2]) :two-pair\n            (check [2]) :pair\n            :else :high-card))))","user":"5b465b8be4b02d533a91bc65"},{"code":"(fn [xs]\n  (letfn [(to-card  [[s v]]\n                    (let [suits {\\C :club, \\D :diamond, \\H :heart, \\S :spade}\n                          ranks {\\2 0, \\3 1, \\4 2, \\5 3, \\6 4, \\7 5, \\8 6, \\9 7, \\T 8, \\J 9, \\Q 10, \\K 11, \\A 12}]\n                      {:suit (suits s) :rank (ranks v)}))]\n    (let [cards (map to-card xs)\n          by-suits (group-by :suit (sort-by :rank cards))\n          by-ranks (group-by :rank cards)\n          n-suits (count by-suits)\n          n-ranks (count by-ranks)\n          ranks (sort (keys by-ranks))\n          straight? (and (= 5 n-ranks) (= (+ (first ranks) 4) (last ranks)))\n          straight-with-ace? (and (= 5 n-ranks) (= 12 (last ranks)) (= 3 (nth ranks 3)))\n          flush? (= 1 n-suits)\n          ]\n      (cond\n       (or straight? straight-with-ace?) (if flush? :straight-flush :straight)\n       flush? :flush\n       (some #(= 4 (count (second %))) by-ranks) :four-of-a-kind\n       (= 2 n-ranks) :full-house\n       (some #(= 3 (count (second %))) by-ranks) :three-of-a-kind\n       (= 3 n-ranks) :two-pair\n       (= 4 n-ranks) :pair\n       :else :high-card))))","problem":"178","user":"536ca4bde4b0fc7073fd6e49"},{"code":"(fn [h]\n   (let [\n     f (group-by last h)\n     s (some #(= (set (keys f)) (set %))\n               (partition 5 1 \"A23456789TJQKA\"))\n     l (apply = (map first h))\n     m ({[1 4] :four-of-a-kind [2 3] :full-house [1 1 3] :three-of-a-kind [1 2 2] :two-pair [1 1 1 2] :pair} (sort (map (comp count val) f)))]\n     (cond\n       (and s l) :straight-flush\n       l :flush\n       s :straight\n       m m\n       :else :high-card)))","problem":"178","user":"4daa374930acd6ed13482a68"},{"problem":"178","code":"(fn [hand]\n  (let [rank-order [\\2 \\3 \\4 \\5 \\6 \\7 \\8 \\9 \\T \\J \\Q \\K \\A \\2 \\3 \\4 \\5]\n        sequences (map set (partition 5 1 rank-order))\n        suits (map first hand)\n        ranks (map second hand)]\n    (cond\n     (and (= 1 (count (set suits)))\n          (some #{(set ranks)} sequences)) :straight-flush\n     (some #{4} (map count (partition-by identity (sort ranks)))) :four-of-a-kind\n     (= 2 (count (set ranks))) :full-house ; only works due to prev test\n     (= 1 (count (set suits))) :flush\n     (some #{(set ranks)} sequences) :straight\n     (some #{3} (map count (partition-by identity (sort ranks)))) :three-of-a-kind\n     (= 3 (count (set ranks))) :two-pair ; can only use this because of prev test\n     (= 4 (count (set ranks))) :pair\n     :else :high-card)))","user":"5405ae2be4b0addc1aec6671"},{"code":"(fn [cards]\n  (let [card (fn [ace c]\n                {:suit (case (first c) \n                         \\D :diamond \\S :spades \\H :heart \\C :club)\n                 :rank (case (second c)\n                         \\T 8 \\J 9 \\Q 10 \\K 11 \\A ace\n                         (- (-> c second str Long.) 2))})\n        cardsAceHigh (map (partial card 12) cards)\n        cardsAceLow (map (partial card -1) cards)\n        same-suit (= 1 (->> cardsAceHigh (map :suit) set count))\n        inseq? (fn [cards]\n                  (every? #(= -1 %)\n                          (map (partial apply -) (partition 2 1 (sort (map :rank cards))))))\n        inseq (or (inseq? cardsAceLow) (inseq? cardsAceHigh))\n        n-of-a-kind? (fn [cards n]\n                        (some #(= n (count (second %)))\n                          (group-by :rank cards)))\n        full-house? (fn [cards]\n                       (every? #(#{2 3} (count (second %)))\n                         (group-by :rank cards)))\n        n-pairs? (fn [cards n]\n                    (= n (count (filter #(= 2 (count (second %)))\n                       (group-by :rank cards)))))]\n    (cond (and same-suit inseq) :straight-flush\n          (n-of-a-kind? cardsAceHigh 4) :four-of-a-kind\n          (full-house? cardsAceHigh) :full-house\n          same-suit :flush\n          inseq :straight\n          (n-of-a-kind? cardsAceHigh 3) :three-of-a-kind\n          (n-pairs? cardsAceHigh 2) :two-pair\n          (n-pairs? cardsAceHigh 1) :pair\n          :else :high-card)))","problem":"178","user":"53300924e4b019098a6f8b55"},{"problem":"178","code":"(fn [h]\n  (let [[S R] (apply map list h)\n        r (sort (map #(.indexOf \"23456789TJQKA\" (str %)) R))\n        n (nth r 0)\n        s (#{[0 1 2 3 12] (range n (+ 5 n))} r)\n        f (apply = S)\n        k (-> R frequencies vals sort)]\n    (cond\n      (and s f) :straight-flush\n      (= k [1 4]) :four-of-a-kind\n      (= k [2 3]) :full-house\n      f :flush\n      s :straight\n      1 ({[1 1 3] :three-of-a-kind\n          [1 2 2] :two-pair\n          [1 1 1 2] :pair} k :high-card))))","user":"4eb70649535d7eef30807373"},{"problem":"178","code":"(\nletfn [(sorted-translated [coll] (sort-by :rank (map translate-cards coll)))\n       (flush-cards [coll] (apply = (map :suit coll)))\n       (in-seq-helper [sorted-ranks] \n         (every? (fn [[x y]] (= (- y x) 1)) \n                                     (partition 2 1 sorted-ranks)))\n       (in-seq [sorted-coll] \n         (or \n           (in-seq-helper (map :rank sorted-coll))\n           (in-seq-helper (sort (replace {12 -1} (map :rank sorted-coll))))))\n       (straight-flush [sorted-coll] (and (in-seq sorted-coll)\n                                          (flush-cards sorted-coll)))\n       (four-of-a-kind [sorted-coll] (some #(= 4 %) (map (comp count second) (group-by :rank sorted-coll))))\n       (full-house [sorted-coll] \n         (every? \n           (fn [[k l]] \n             (or (= 3 (count l))\n                 (= 2 ( count l)))) \n           (group-by identity (map :rank sorted-coll))))\n       (straight [sorted-coll] (in-seq sorted-coll))\n      (three-of-a-kind [sorted-coll] \n        (some #(= 3 %) (map (comp count second) (group-by :rank sorted-coll))))\n      (two-pairs [sorted-coll] \n        (some #(= 2 %) (map (comp count second) (group-by identity (map (comp count second) (group-by :rank sorted-coll))))))\n      (pair [sorted-coll] \n        (some #(= 2 %) (map (comp count second) (group-by :rank sorted-coll))))\n(translate-cards [x] {\n         :suit (case (first x) \n          \\S :spade \n          \\D :diamond \n          \\H :heart\n          \\C :club)\n         :rank (case (second x)\n           \\T 8\n           \\J 9\n           \\Q 10\n           \\K 11\n           \\A 12\n           (- (Integer/valueOf (str (second x))) 2)     \n                 )})]\n\n      (fn [x]\n        (let [coll (sorted-translated x)]\n        (cond \n          (straight-flush coll) :straight-flush\n          (four-of-a-kind coll) :four-of-a-kind\n          (full-house coll) :full-house\n          (flush-cards coll) :flush\n          (straight coll) :straight\n          (three-of-a-kind coll) :three-of-a-kind\n          (two-pairs coll) :two-pair\n          (pair coll) :pair\n            \n         :else :high-card\n          )) \n        ))","user":"50856bd1e4b004985b776e4c"},{"problem":"178","code":"(fn [cards]\n  (let [f (fn [[s r]]\n            {:suit (condp = s\n                     \\C :club\n                     \\D :diamond\n                     \\H :heart\n                     \\S :spare\n                     :none)\n             :rank (condp = r\n                     \\A 12\n                     \\K 11\n                     \\Q 10\n                     \\J 9\n                     \\T 8\n                     (- (Integer/parseInt (str r)) 2))})\n        in-seq? (fn g([coll f]\n                     (let [n (count coll)\n                           c1 (take (dec n) coll)\n                           c2 (drop 1 coll)\n                           s (map f c1 c2)]\n                       (every? true? s)))\n                  ([coll]\n                   (or (g coll #(= (inc %1) %2))\n                       (g coll #(= %1 (inc %2))))))\n        in-seq-rank? (fn [coll]\n                       (prn coll)\n                       (if (and (= 12 (first coll)) (= 0 (second coll)))\n                         (in-seq? (drop 1 coll) #(= (inc %1) %2))\n                         (in-seq? coll)))\n        straight-flush (fn [cards]\n                         (and (apply = (map :suit cards))\n                              (or (in-seq-rank? (map :rank cards)))))\n        group (fn [cards]\n                (->> (group-by :rank cards)\n                     vals\n                     (map count)\n                     sort))\n        cards (map f cards)]\n    (cond\n      (straight-flush cards) :straight-flush\n      (= 4 (apply max (group cards))) :four-of-a-kind\n      (= '(2 3) (group cards)) :full-house\n      (apply = (map :suit cards)) :flush\n      (in-seq-rank? (map :rank cards)) :straight\n      (= 3 (apply max (group cards))) :three-of-a-kind\n      (= '(1 2 2) (group cards)) :two-pair\n      (= 2 (apply max (group cards))) :pair\n      :else :high-card)))","user":"549c6792e4b0f3d1d8e70f8b"},{"code":"(fn poker-hand [hand]\n  (let [nbrs (range 2 10)\n        suits (map first hand)\n        scores (vec (sort (map #((merge (zipmap (map str nbrs) nbrs) {\"T\" 10, \"J\" 11, \"Q\" 12, \"K\" 13, \"A\" 14}) \n                                 (str (second %))) hand)))\n        common (fn [nbr] (filter #(= nbr (count %)) (partition-by identity scores)))\n        triplets (common 3)\n        pairs (common 2)\n\t\tflush? (apply = suits)\n        seq? (fn [scores] (= scores (range (first scores) (inc (last scores)))))\n        straight? (or (seq? scores) (seq? (sort (replace {14 1} scores))))\n        ne? not-empty]\n    (cond (and flush? straight?) :straight-flush\n          (ne? (common 4)) :four-of-a-kind\n          (and (ne? triplets) (ne? pairs)) :full-house\n          flush? :flush\n          straight? :straight\n          (ne? triplets) :three-of-a-kind\n          (< 1 (count pairs)) :two-pair\n          (ne? pairs) :pair\n          :else :high-card)))","problem":"178","user":"50e4f4e9e4b049a987753896"},{"code":"(fn [cards]\n  (let [ranks (map #(.indexOf (seq \"23456789TJQKA\") (last %)) cards)\n        is-run #(= (range (first %) (inc (last %))) %)\n        straight (or (is-run (sort ranks)) (is-run (sort (replace {12 -1} ranks))))\n        flush (apply = (map first cards))\n        books (vals (frequencies ranks))\n        sbooks (set books)]\n     (cond\n      \t(and flush straight) :straight-flush\n        (sbooks 4) :four-of-a-kind\n        (= #{2 3} sbooks) :full-house\n        flush :flush\n        straight :straight\n        (sbooks 3) :three-of-a-kind\n        (= {2 2 1 1} (frequencies books)) :two-pair\n        (sbooks 2) :pair\n        :else :high-card)))","problem":"178","user":"4ebc08a8535dfed6da9c6d7c"},{"problem":"178","code":"(fn [cards]\n   (let [rec (fn [[a b]]\n               {:suit ({\\D :diamond \\H :heart \\S :spade \\C :club} a)\n                :rank ({\\2 0 \\3 1 \\4 2 \\5 3 \\6 4 \\7 5 \\8 6 \\9 7 \\T 8\n                        \\J 9 \\Q 10 \\K 11 \\A 12} b)})\n         cards (map rec cards)\n         ranks (map :rank cards)\n         suits (map :suit cards)]\n     (cond\n      (and (= 1 (count (set suits)))\n           (= 4 (- (apply max ranks) (apply min ranks))))\n      :straight-flush\n\n      (some #{4} (vals (frequencies ranks)))\n      :four-of-a-kind\n\n      (every? #{3 2} (vals (frequencies ranks)))\n      :full-house\n\n      (= 1 (count (set suits)))\n      :flush\n\n      ((into '#{(0 1 2 3 12)}\n             (for [i (range 0 9)] (range i (+ i 5))))\n       (sort ranks))\n      :straight\n\n      (some #{3} (vals (frequencies ranks)))\n      :three-of-a-kind\n\n      (= '(1 2 2) (sort (vals (frequencies ranks))))\n      :two-pair\n\n      (some #{2} (vals (frequencies ranks)))\n      :pair\n\n      1 :high-card)\n     ))","user":"55be39f9e4b01b9910ae2a06"},{"problem":"178","code":"(fn recognize [col]\n  (let [print-card (fn [s] \n                     (let [[suit rank] (seq s)\n                           suitmap {\\H :heart, \\D :diamond, \\C :club, \\S :spade}\n                           rankmap (zipmap [\\2 \\3 \\4 \\5 \\6 \\7 \\8 \\9 \\T \\J \\Q \\K \\A] (take 13 (drop 2 (range))))]\n                       (hash-map :suit (suitmap suit), :rank (rankmap rank))))\n        rank-freq (fn [crds]\n                    (->> \n                     (map :rank crds)\n                     (group-by identity)\n                     (map second)\n                     (map count)\n                     (sort)))\n        suit-freq (fn [crds]\n                    (->> \n                     (map :suit crds)\n                     (group-by identity)\n                     (map second)\n                     (map count)\n                     (sort)))\n        straight? (fn [crds]\n                    (let [ranks (map :rank crds)\n                          ranks_ (replace {14 1} ranks)\n                          min-max-diff (fn [col]\n                                         (- (reduce max col) (reduce min col)))]\n                      (and\n                       (= (reduce max (rank-freq crds)) 1)\n                       (or \n                        (= (min-max-diff ranks) 4)\n                        (= (min-max-diff ranks_) 4))\n                       )))\n        flush? (fn [crds]\n                 (->> \n                  (suit-freq crds)\n                  (reduce max)\n                  (= 5)))\n        cards (map print-card col)]\n    (cond\n     (and (flush? cards) (straight? cards)) :straight-flush\n     (= (reduce max (rank-freq cards)) 4) :four-of-a-kind\n     (= (rank-freq cards) [2 3]) :full-house\n     (flush? cards) :flush\n     (straight? cards) :straight\n     (= (reduce max (rank-freq cards)) 3) :three-of-a-kind\n     (= (rank-freq cards) [1 2 2]) :two-pair\n     (= (reduce max (rank-freq cards)) 2) :pair\n     :else :high-card)))","user":"53c126fce4b00fb29b22125b"},{"problem":"178","code":"(fn\n  [cards]\n  (let [ranks (map second cards)\n        ranks+ (sort (vals (frequencies ranks)))\n        straight-set (set (map set (partition 5 1 [\\A \\2 \\3 \\4 \\5 \\6 \\7 \\8 \\9 \\T \\J \\Q \\K \\A])))\n        straight-bool (straight-set (set ranks))\n        suits+ (sort (vals (frequencies (map first cards))))\n        flush-bool (= '(5) suits+)]\n    (cond\n      (and straight-bool flush-bool) :straight-flush\n      (= ranks+ '(1 4))              :four-of-a-kind\n      (= ranks+ '(2 3))              :full-house\n      flush-bool                     :flush\n      straight-bool                  :straight\n      (= ranks+ '(1 1 3))            :three-of-a-kind\n      (= ranks+ '(1 2 2))            :two-pair\n      (= ranks+ '(1 1 1 2))          :pair\n      (= ranks+ '(1 1 1 1 1))        :high-card)))","user":"5d1b2b7de4b02ea6f0fb697a"},{"problem":"178","code":"(fn [cards-human]\n  (letfn [(describe [human-representation]\n            (let [[s r] human-representation\n                  map-suite {\\S :spades, \\H :heart, \\D :diamond, \\C :club}\n                  map-rank {\\2 0, \\3 1, \\4 2, \\5 3, \\6 4, \\7 5, \\8 6, \\9 7, \\T 8, \\J 9, \\Q 10, \\K 11, \\A 12}]\n\n              {:suit (map-suite s), :rank (map-rank r)}))\n          (same-suit? [cards]\n            (= 1 (count (distinct (map :suit cards)))))\n          (in-sequence? [cards]\n            (let [ranks (sort (map :rank cards))\n                  start (first ranks)]\n              (or\n               (= ranks (range start (+ start (count cards))))\n               (if (.contains ranks 12)\n                 (in-sequence? (map (fn [card] (if (= 12 (:rank card))\n                                                {:suit (:suit card), :rank -1}\n                                                card)) cards))\n                 false))))\n          (highest-rank [cards]\n            (last (sort (map :rank cards))))\n          (has-rank-count? [count cards]\n            (contains? (clojure.set/map-invert (frequencies (map :rank cards))) count))\n          (two-pairs? [cards]\n            (= 2 (get (frequencies (vals (frequencies (map :rank cards)))) 2)))]\n    (let [cards (mapv describe cards-human)]\n      (cond\n        (and (same-suit? cards) (in-sequence? cards) (= 12 (highest-rank cards))) :straight-flush\n        (has-rank-count? 4 cards) :four-of-a-kind\n        (and (has-rank-count? 3 cards) (has-rank-count? 2 cards)) :full-house\n        (same-suit? cards) :flush\n        (in-sequence? cards) :straight\n        (has-rank-count? 3 cards) :three-of-a-kind\n        (two-pairs? cards) :two-pair\n        (has-rank-count? 2 cards) :pair\n        :else :high-card))))","user":"5344fe13e4b084c2834f4a32"},{"problem":"178","code":"(fn best-hand [cards]\n  (let [rec-cards (fn [c]\n                    (let [[suit rank] (clojure.string/lower-case c)]\n                      {:suit\n                       (case suit\n                         \\d :diamond\n                         \\h :heart\n                         \\c :club\n                         \\s :spades)\n                       :rank\n                       (case rank\n                         \\a 12\n                         \\k 11\n                         \\q 10\n                         \\j 9\n                         \\t 8\n                         (- (read-string (str rank)) 2))}))\n        same-suit? (fn [suits] (= (count (into #{} suits)) 1))\n        card-sequence? (fn [ranks]\n                         (let [start (apply min ranks)]\n                           (= (reduce + ranks)\n                              (reduce + (range start (+ start (count ranks)))))))\n\n        parsed-cards (map rec-cards cards)\n        suits (map :suit parsed-cards)\n        ranks (map :rank parsed-cards)\n        kind-count (->> ranks\n                        (reduce (fn [acc x] (assoc acc x (inc (get acc x 0)))) {})\n                        vals\n                        sort\n                        reverse)\n        contains-ace? (fn [ranks] (not (empty? (filter #(= % 12) ranks))))\n        ace-as-one-ranks (fn [ranks] (reduce (fn [acc x] (conj acc (if (= x 12) -1 x)))\n                                             [] ranks))\n        ]\n\n    (cond\n      (and (same-suit? suits) (card-sequence? ranks)) :straight-flush\n      (= (first kind-count) 4)                    :four-of-a-kind\n      (and (= (first kind-count) 3)\n           (= (second kind-count) 2))                 :full-house\n      (same-suit? suits)                              :flush\n      (or (card-sequence? ranks)\n          (card-sequence? (ace-as-one-ranks ranks)))                          :straight\n      (= (first kind-count) 3) :three-of-a-kind\n      (and (= (first kind-count) )\n           (= (second kind-count) 2)) :two-pair\n      (= (first kind-count) 2) :pair\n      :else :high-card\n      )))","user":"527ccaf4e4b0757a1b17136d"},{"problem":"178","code":"(fn [hand]\n  (let [rankm (zipmap \"--23456789TJQKA\" (range 15))\n        ; sort highest to lowest card\n        ranks (sort-by identity > (map #(rankm (second %)) hand))\n        ; accommodate low straight (A 2 3 4 5)\n        ranks (if (= ranks [14 5 4 3 2]) [5 4 3 2 1] ranks)]\n    (case (mapv count (partition-by identity ranks))\n      [4 1] :four-of-a-kind\n      [3 2] :full-house\n      [3 1 1] :three-of-a-kind\n      [2 2 1] :two-pair\n      [2 1 1 1] :pair\n      [1 1 1 1 1] (case [(and (= 4 (- (first ranks) (last ranks)))\n                              (= 5 (count (set ranks))))\n                         (= 1 (count (set (map first hand))))]\n                    [true   true] :straight-flush\n                    [true  false] :straight\n                    [false  true] :flush\n                    [false false] :high-card))))","user":"53576356e4b04ce2eb3ed27a"},{"problem":"178","code":"(fn [cs]\n  (let [suits (set (map first cs))\n        cards (->> cs\n                   (map second)\n                   (map #(case % \\A 1 \\T 10 \\J 11 \\Q 12 \\K 13\n                               (\\2 \\3 \\4 \\5 \\6 \\7 \\8 \\9) (- (int %) 48)))\n                   (sort >))\n        intervals (set (map (partial apply -) (partition 2 1 cards)))\n        sets (sort (remove #{1} (map #(count (second %)) (group-by identity cards))))\n        flush? (= 1 (count suits))\n        straight? (or (= cards '(13 12 11 10 1))\n                      (= 1 (first intervals) (count intervals)))\n        ]\n    (cond (and straight? flush?) :straight-flush\n          flush? :flush\n          straight? :straight\n          (= 1 (count sets)) (case (first sets) 2 :pair 3 :three-of-a-kind 4 :four-of-a-kind)\n          (= 2 (count sets)) (if (= 1 (count (set sets))) :two-pair :full-house)\n          :else :high-card)))","user":"56018dd4e4b04bb52996e18f"},{"code":"(fn besthand [coll]\n  (let [a (map first coll)\n        b (map second coll)\n        f (vals (frequencies b))\n        g (vals (frequencies a))\n        s '(\"2345A\" \"23456\" \"34567\" \"45678\" \"56789\" \"6789T\" \"789JT\" \"89JKT\"\n            \"9JKQT\" \"AJKQT\")]\n    (cond \n     (and (.contains s (apply str (sort b))) (.contains g 5)) :straight-flush\n     (.contains f 4) :four-of-a-kind\n     (= 6 (apply * f)) :full-house\n     (.contains g 5) :flush\n     (.contains s (apply str (sort b))) :straight\n     (.contains f 3) :three-of-a-kind\n     (= 4 (apply * f)) :two-pair\n     (.contains f 2) :pair\n     true :high-card)))","problem":"178","user":"4e14108c535d04ed9115e7dd"},{"problem":"178","code":"(fn [h]\n   (let [r (concat (map (comp first str) (range 2 10)) [\\T \\J \\Q \\K \\A])\n         suits (map first h)\n         ns (sort (map (comp inc #(.indexOf r %) second) h))\n         nss (if (.contains ns 13) [(drop-last (concat [0] ns)) ns]\n                                   [ns ns])\n         f (->> ns frequencies vals (sort-by -) (take 2))\n         straight (and (some (set (map (comp (partial take-last 5) range) (range 5 15))) nss) :straight)\n         flush (and (apply = suits) :flush)]\n     (some identity [(and flush straight :straight-flush)\n                     (and (= f [4 1]) :four-of-a-kind)\n                     (and (= f [3 2]) :full-house)\n                     flush\n                     straight\n                     (and (= f [3 1]) :three-of-a-kind)\n                     (and (= f [2 2]) :two-pair)\n                     (and (= f [2 1]) :pair) :high-card])))","user":"5db0172be4b0f8c104ccfc96"},{"problem":"178","code":"(fn [cards]\n  (letfn \n    [(get-card [card]\n       (let [suits {\\S :spade \\H :heart \\C :club \\D :diamond}\n             ranks (zipmap \"23456789TJQKA\" (range))]\n         {:suit (suits (first card)) :rank (ranks (second card))}))\n     (flush? [cards]\n       (= 1 (count (group-by :suit cards))))\n     (straight? [cards]\n       (let [s (sort (map :rank cards))]                  \n         (or (= s (take 5 (iterate inc (first s)))) (= s [0 1 2 3 12]))))\n     (count-cards [cards]\n       (sort > (map second (frequencies (map :rank cards)))))]\n    (let [c (map get-card cards)\n          cnt (count-cards c)\n          is-st (straight? c)\n          is-fl (flush? c)]\n      (cond \n       (and is-st is-fl) :straight-flush\n       (= cnt [4 1])     :four-of-a-kind\n       (= cnt [3 2])     :full-house\n       is-fl             :flush\n       is-st             :straight\n       (= cnt [3 1 1])   :three-of-a-kind\n       (= cnt [2 2 1])   :two-pair\n       (= cnt [2 1 1 1]) :pair\n       :else             :high-card))))","user":"55c0afa5e4b01b9910ae2a27"},{"problem":"178","code":"(fn best-hand [cards]\n  (let[suits (map first cards)\n       get-rank (fn[c]\n                  (cond\n                   (= \\T c) 8\n                   (= \\J c) 9\n                   (= \\Q c) 10\n                   (= \\K c) 11\n                   (= \\A c) 12\n                   :else (- (int c) 50)))\n       numbers (sort (map (comp get-rank second) cards))\n       same-suit (= 1 (count (distinct suits)))\n       straight (loop [pre (first numbers) remaining (rest numbers)]\n                     (if (seq remaining)\n                       (let [cur (first remaining)]\n                         (cond\n                          (and (= 12 cur) (or (= pre 11) (= pre 3))) (recur cur (rest remaining))\n                          (= 1 (- cur pre)) (recur cur (rest remaining))\n                          :else false))\n                       true))\n       distinct-number-count (sort > (vals (frequencies numbers)))]\n    (cond\n     (and same-suit straight) :straight-flush\n     (= (first distinct-number-count) 4) :four-of-a-kind\n     (and (= (first distinct-number-count) 3)\n          (= (second distinct-number-count) 2)) :full-house\n     (true? same-suit) :flush\n     (true? straight) :straight\n     (= (first distinct-number-count) 3) :three-of-a-kind\n     (and (= (first distinct-number-count) 2)\n          (= (second distinct-number-count) 2)) :two-pair\n     (= (first distinct-number-count) 2) :pair\n     :else :high-card)))","user":"541619e8e4b01498b1a719f9"},{"code":"(fn best-hand\n  [hand]\n  (let [suits (map first hand)\n        parse-rank-fn (fn [rank] \n                        (case rank\n                          \"T\" 10\n                          \"J\" 11\n                          \"Q\" 12\n                          \"K\" 13\n                          \"A\" 14\n                          (Integer/parseInt rank)))\n        ranks (map (comp parse-rank-fn str second) hand) \n        unique-suits (into #{} suits)\n        sorted-ranks (sort ranks)\n        in-sequence? (or (= [2 3 4 5 14] sorted-ranks) (= (range (first sorted-ranks) (+ 5 (first sorted-ranks))) sorted-ranks))\n        rank-freqs (frequencies ranks)\n        rank-freqs-set (into #{} (vals rank-freqs))]\n    (cond\n     (and (= 1 (count unique-suits)) in-sequence?) :straight-flush\n     (rank-freqs-set 4) :four-of-a-kind\n     (= #{2 3} rank-freqs-set) :full-house\n     (= 1 (count unique-suits)) :flush\n     in-sequence? :straight\n     (rank-freqs-set 3) :three-of-a-kind\n     (= [1 2 2] (sort (vals rank-freqs))) :two-pair\n     (rank-freqs-set 2) :pair\n     :else :high-card)))","problem":"178","user":"4dad76588e77d6ed63f12a44"},{"code":"(fn [hand]\n  (let [rank (fn [[_ rank]] (.indexOf (vec \"23456789TJQKA\") rank))\n        straight (fn [hand]\n                   (let [ranks (sort (map rank hand))\n                         start (first ranks)\n                         alternative-ranks (sort (replace {12 -1} ranks))]\n                     (or  (= ranks (range start (+ start 5)))\n                          (= alternative-ranks (range -1 4)))))\n        flush #(->> % (map first) (apply =))\n        n-of-a-kind (fn [n hand]\n                      (->> hand\n                           (map rank)\n                           frequencies\n                           vals\n                           (some #{n})))\n        two-pair (fn [hand] (= ((->> hand\n                                      (map rank)\n                                      frequencies\n                                      vals\n                                      frequencies)\n                                 2)\n                               2))]\n    (cond\n     (and (flush hand) (straight hand)) :straight-flush\n     (n-of-a-kind 4 hand) :four-of-a-kind\n     (and (n-of-a-kind 3 hand) (n-of-a-kind 2 hand)) :full-house\n     (flush hand) :flush\n     (straight hand) :straight\n     (n-of-a-kind 3 hand) :three-of-a-kind\n     (two-pair hand) :two-pair\n     (n-of-a-kind 2 hand) :pair\n     :else :high-card)))","problem":"178","user":"504e108ce4b078edc5f593b3"},{"problem":"178","code":"(fn bestHand \n  [xs]\n  (let [keyes (concat (map #(char (+ 48 %)) (range 2 10)) [\\T \\J \\Q \\K \\A])\n        values (range 13)\n        mapa (zipmap keyes values)\n        nextNumberFn #(mod (inc %) 13)\n        maped (map #(mapa (second %)) xs)\n        suit? (apply = (map first xs))\n        inSeq? (->> maped\n                    ((fn [ys] (if (> (count (filter #{11 0} ys)) 1) \n                                 false\n                                 (->> (map nextNumberFn ys)\n                                      (#(filter (set %) ys))\n                                      (count)\n                                      (= 4 ))))))\n        freq (frequencies maped)\n        mx (apply max (vals freq))]\n    (if (= 5 (count freq))\n      (condp = true\n        suit? (if inSeq? :straight-flush :flush)\n        inSeq? :straight\n        :high-card)\n      (case (count freq)\n        2 (if (= mx 3) :full-house :four-of-a-kind)\n        3 (if (= mx 2) :two-pair :three-of-a-kind)\n        :pair))))","user":"6011b89ee4b074f607df66bc"},{"problem":"178","code":"(fn\n  [x]\n  (let [suits (map first x)\n        nums (sort (map #(case (second %) \\T -3 \\J -2 \\Q -1 \\K 0 \\A 1 (- (int (second %)) 48)) x))\n        g-n (set (map count (vals (group-by identity nums))))\n        t (map - nums (next nums))]\n    (case (apply max g-n)\n      4 :four-of-a-kind\n      3 (if (= #{2 3} g-n) :full-house :three-of-a-kind)\n      2 (if (= 3 (count (set nums))) :two-pair :pair)\n      1 (if (every? zero? (map inc t))\n          (if (= 1 (count (set suits))) :straight-flush :straight)\n          (if (= 1 (count (set suits))) :flush :high-card)))))","user":"5507cfd3e4b021ccfedb96ad"},{"code":"(fn best-hand [cards]\n  (let [ranks (group-by #(.indexOf \"23456789TJQKA\" (int (second %))) cards),\n        rank-counts= (fn [s] (= s (sort (map (comp count val) ranks)))),\n        min-rank (apply min (keys ranks)),\n        max-rank (apply max (keys ranks)),\n        suits (group-by first cards)]\n    (cond\n     (= 1 (count suits)) (if (= 4 (- max-rank min-rank)) :straight-flush, :flush)\n     (rank-counts= [1 4]) :four-of-a-kind\n     (rank-counts= [2 3]) :full-house     \n     (and (rank-counts= [1 1 1 1 1])\n          (or (= 4 (- max-rank min-rank))\n              (= #{12 0 1 2 3} (set (keys ranks))))) :straight\n     (rank-counts= [1 1 3]) :three-of-a-kind\n     (rank-counts= [1 2 2]) :two-pair\n     (rank-counts= [1 1 1 2]) :pair\n     :else :high-card)))","problem":"178","user":"52039e12e4b0fb7e47ea51ff"},{"problem":"178","code":"(letfn [(has? [hand f n] (some #(= n (count %)) (map second (group-by f hand))))\n        (n-kind? [n hand] (has? hand :rank n))\n        (straight-flush? [hand] (when (and (straight? hand) (flush? hand)) :straight-flush))\n        (straight? [hand] (when (some #(= % (set (map :rank hand))) (map set (partition 5 1 (cons 12 (range 13))))) :straight))\n        (two-pair? [hand] (when (= 2 (count (->> hand (group-by :rank) (map second) (filter #(= 2 (count %)))))) :two-pair))\n        (flush? [hand] (when (has? hand :suit 5) :flush))\n        (full-house? [hand] (when (and (three-kind? hand) (pair? hand)) :full-house))\n        (pair? [hand] (when (n-kind? 2 hand) :pair))\n        (three-kind? [hand] (when (n-kind? 3 hand) :three-of-a-kind))\n        (four-kind? [hand] (when (n-kind? 4 hand) :four-of-a-kind))\n        (parse-hand [hand] (map #(merge\n                                  (->> %\n                                       first\n                                       (get {\\S :spade \\H :heart \\C :club \\D :diamond})\n                                       (assoc {} :suit))\n                                  (->> %\n                                       second\n                                       str\n                                       (.indexOf \"23456789TJQKA\")\n                                       (assoc {} :rank)))\n                                hand))]\n  (fn [hand]\n    (some #(% (parse-hand hand))\n          [straight-flush?\n           four-kind?\n           full-house?\n           flush?\n           straight?\n           three-kind?\n           two-pair?\n           pair?\n           (constantly :high-card)])))","user":"554680cbe4b0a04f7929953e"},{"problem":"178","code":"(fn __ [cards]\n  (let [analysis\n        (fn [[s r]]\n          (let [card {\\S :spade \\H :heart \\D :diamond \\C :club \\2 0 \\3 1 \\4 2 \\5 3 \\6 4 \\7 5 \\8 6 \\9 7 \\T 8 \\J 9 \\Q 10 \\K 11 \\A 12}]\n            {:suit (card s) :rank (card r)}))\n\n        get-suits\n        (fn [cards] (reduce #(merge-with conj %1 {(:suit %2) (:rank %2)} )\n                            {:spade [], :heart [], :diamond [], :club []}\n                            (map analysis cards)))\n        get-ranks\n        (fn [cards] (reduce #(merge-with (fn [result latter]\n                                           (inc result))\n                                         %1 {(:rank %2) 1})\n                            {} (map analysis cards)))\n        suits (get-suits cards)\n        nos (count (keys suits))\n        ranks (get-ranks cards)\n\n        max-in-seq\n        (fn [s]\n          (or\n           (some identity\n                 (for [t (range (count s) 1 -1)]\n                   (some #(let [f (first %)\n                                l (last %)]\n                            (if (=  l (+ f t -1)) t false))\n                         (partition t 1 s))))\n           1))\n        in-seq?\n        (fn in-seq?\n          ([ranks] (in-seq? ranks (count ranks)))\n          ([ranks n]\n           (let [rs (sort (keys ranks))\n                 rn (count rs)]\n             (if (<= n rn)\n               (>= (max-in-seq rs) n)\n               false))))]\n   (cond\n      (= 1 (count (filter (comp not empty? second) suits)))\n      (if (in-seq? ranks) :straight-flush :flush)\n\n      (some #(= 4 (second %)) ranks)\n      :four-of-a-kind\n\n      (and (some #(= 3 (second %)) ranks)\n           (some #(= 2 (second %)) ranks))\n      :full-house\n\n      (or (in-seq? ranks)\n          (when (get ranks 12)\n              (in-seq? (assoc (dissoc ranks 12) -1 1))))\n      :straight\n\n      (some #(= 3 (second %)) ranks)\n      :three-of-a-kind\n\n      (= 2 (count (filter #(= 2 (second %)) ranks)))\n      :two-pair\n\n      (some #(= 2 (second %)) ranks)\n      :pair\n\n      :else\n      :high-card\n      )))","user":"5a0ce1a5e4b04bbd27e6d9b7"},{"code":"(fn [cards]\n  (letfn [(c [[s r]]\n            {:suit ({\\H :heart, \\D :diamond, \\C :club, \\S :spade} s),\n             :rank ({\\2 0, \\3 1, \\4 2, \\5 3, \\6 4, \\7 5, \\8 6, \\9 7, \n                     \\T 8, \\J 9, \\Q 10, \\K 11, \\A 12} r)})\n          (flush? [x]\n            (->> x (map :suit) (apply =)))\n          (consecutive? [[x y]]\n            (or (and (= x 3) (= y 12))\n                (= 1 (- y x))))\n          (straight? [x]\n            (->> x (map :rank) sort (partition 2 1) (every? consecutive?)))\n          (str-flush? [x]\n            (and (flush? x)\n                 (straight? x)))\n          (kind? [n]\n            #(->> % (group-by :rank) vals (map count) sort reverse first (= n)))\n          (full? [x]\n            (let [g (->> x (group-by :rank))]\n              (and (-> g count (= 2))\n                   (-> g seq first count (= 2)))))\n          (two-pair? [x]\n            (->> x (group-by :rank) vals (map count) sort reverse (take 2) (apply = 2)))\n          (f [cards p x] )]\n    (->>\n      (map #(when (->> cards (map c) %1) %2)\n        [str-flush? (kind? 4) full? flush? straight? (kind? 3) two-pair? (kind? 2) (constantly true)]\n        [:straight-flush :four-of-a-kind :full-house :flush :straight :three-of-a-kind :two-pair :pair :high-card])\n      (drop-while (complement identity))\n      first)))","problem":"178","user":"4f58d92fe4b0a7574ea71858"},{"problem":"178","code":"(fn besthand [v]\n     (let [ranks1 {\\2 0 \\3 1 \\4 2 \\5 3 \\6 4 \\7 5 \\8 6 \\9 7 \\T 8 \\J 9 \\Q 10 \\K 11 \\A 12}\n           ranks2 {\\A 0 \\2 1 \\3 2 \\4 3 \\5 4 \\6 5 \\7 6 \\8 7 \\9 8 \\T 9 \\J 10 \\Q 11 \\K 12}]\n       (if (and (empty? (rest (vals (group-by first v))))\n                (or (= (sort (map #(get ranks1 (second %)) v))\n                       (take 5 (iterate inc (first (sort (map #(get ranks1 (second %)) v))))))\n                    (= (sort (map #(get ranks2 (second %)) v))\n                       (take 5 (iterate inc (first (sort (map #(get ranks2 (second %)) v))))))))\n         :straight-flush\n         (if (some #{4} (vals (frequencies (map #(get ranks1 (second %)) v))))\n           :four-of-a-kind\n           (if (and (some #{3} (vals (frequencies (map #(get ranks1 (second %)) v))))\n                    (some #{2} (vals (frequencies (map #(get ranks1 (second %)) v)))))\n             :full-house\n             (if (empty? (rest (vals (group-by first v))))\n               :flush\n               (if (or (= (sort (map #(get ranks1 (second %)) v))\n                          (take 5 (iterate inc (first (sort (map #(get ranks1 (second %)) v))))))\n                       (= (sort (map #(get ranks2 (second %)) v))\n                          (take 5 (iterate inc (first (sort (map #(get ranks2 (second %)) v)))))))\n                 :straight\n                 (if (some #{3} (vals (frequencies (map #(get ranks1 (second %)) v))))\n                   :three-of-a-kind\n                   (if (= (get (frequencies (vals (frequencies (map #(get ranks1 (second %)) v)))) 2) 2)\n                     :two-pair\n                     (if (some #{2} (vals (frequencies (map #(get ranks1 (second %)) v))))\n                       :pair\n                       :high-card))))))))))","user":"532727bae4b09d4e7a9b54fa"},{"problem":"178","code":"(fn [cards]\n  (let [rank-map {\\2 2 \\3 3 \\4 4 \\5 5 \\6 6 \\7 7 \\8 8 \\9 9 \\T 10 \\J 11 \\Q 12 \\K 13 \\A 14}\n        same-suits-p  (apply = (map #(first %) cards))\n        in-sequence? (fn [cards]\n                       (let [sorted (reverse (sort (map #(rank-map (second %)) cards)))]\n                         (if (not= (first sorted) 14)\n                           (every? #(= 1 %) (map #(- % %2) sorted (rest sorted)))\n                           (let [sorted2 (rest sorted)]\n                             (if (every? #(= 1 %) (map #(- % %2) sorted2 (rest sorted2)))\n                               (if (or (= 13 (first sorted2)) (= 2 (last sorted2))) true false))))))\n        in-seq-p (in-sequence? cards)\n        same-ranks  (reverse(sort (map #(count %) (partition-by (fn [x] x)  (sort (map #(rank-map (second %)) cards))))))]\n    (cond\n      (and same-suits-p in-seq-p) :straight-flush\n      (= same-ranks '(4 1)) :four-of-a-kind\n      (= same-ranks '(3 2)) :full-house\n      same-suits-p :flush\n      in-seq-p :straight\n      (= 3 (first same-ranks)) :three-of-a-kind\n      (= same-ranks '(2 2 1)) :two-pair\n      (= same-ranks '(2 1 1 1)) :pair\n      :default :high-card )))","user":"566d71b1e4b0a866af6896ca"},{"problem":"178","code":"(fn [h]\n  (let [r     (map second h)\n        f     (apply = (map first h))\n        s     ((set (map set (partition 5 1 \"A23456789TJQKA\"))) (set r))\n        [a b] (sort-by - (vals (frequencies r)))]\n    (cond\n      (and f s)       :straight-flush\n      (= 4 a)         :four-of-a-kind\n      (= [3 2] [a b]) :full-house\n      f               :flush\n      s               :straight\n      (= 3 a)         :three-of-a-kind\n      (= 2 a b)       :two-pair\n      (= 2 a)         :pair\n      :else           :high-card)))","user":"4f9d8083e4b0dcca54ed6d23"},{"code":"(fn cardgame [cards]\n  (let [suits (for [c cards] (first c))\n        rank {\\2 0 \\3 1 \\4 2 \\5 3 \\6 4 \\7 5 \\8 6 \\9 7 \\T 8 \\J 9 \\Q 10 \\K 11 \\A 12}\n        ranks (sort (for [c cards] (rank (second c))))\n        straight (fn _s [r](let [c1 (first r) c2 (second r)](if (not= 1 (- c2 c1)) (if (and (empty? (drop 2 r))(= c2 12)) true false)(if (= 2 (count r))true(_s (rest r))))))\n        g-s (group-by identity suits)\n        g-r (group-by identity ranks)\n        pair (filter (fn[[k v]] (= 2 (count v))) g-r)\n        thrid (filter (fn[[k v]] (= 3 (count v))) g-r)\n        four (filter (fn[[k v]] (= 4 (count v))) g-r)]\n    (if (= (count (g-s (first suits))) (count suits))\n       (if (straight ranks) :straight-flush :flush)\n       (if (straight ranks) :straight \n         (cond (= 2 (count pair)) :two-pair\n               (= 1 (count pair)) (if (= 1 (count thrid)) :full-house  :pair)\n               (= 1 (count thrid)) :three-of-a-kind\n               (= 1 (count four)) :four-of-a-kind\n               :else :high-card\n         )\n       )\n    )\n  )\n)","problem":"178","user":"522eba30e4b01cdb292c5f0e"},{"code":"(fn [cards]\n    (let [order-norm \"23456789TJQKA\"\n          order-rev \"A23456789TJQK\"\n          cards (map (fn [[s r]] {:suite s :rank r}) cards)\n          freq-ranks (->> cards (map :rank) frequencies vals sort)\n          freq-suites (vals (frequencies (map :suite cards)))\n\n          straight-with? (fn [order cards]\n                           (let [ord-by (zipmap order (range 100))\n                                 ranks (map :rank cards)]\n                             (->> (sort-by ord-by ranks)\n                                  (apply str)\n                                  (.contains order))))\n          straight? (or (straight-with? order-norm cards)\n                        (straight-with? order-rev cards))\n          flush? (= freq-suites [5])]\n      (cond (and straight? flush?) :straight-flush\n            (= freq-ranks [1 4]) :four-of-a-kind\n            (= freq-ranks [2 3]) :full-house\n            flush? :flush\n            straight? :straight\n            (= freq-ranks [1 1 3]) :three-of-a-kind\n            (= freq-ranks [1 2 2]) :two-pair\n            (= freq-ranks [1 1 1 2]) :pair\n            :default :high-card)))","problem":"178","user":"4f465096e4b0d56e7bb92b9a"},{"problem":"178","code":"(let [rank (zipmap \"A23456789TJQK\" (range 1 14))\n        suit {\\C :club, \\H :heart, \\S :spade, \\D :diamond}\n        parse-card (fn [[s r]] {:suit (suit s), :rank (rank r)})\n        sequence? (fn [[card :as ranks]] (= ranks (range card (+ card 5))))]\n    (fn [raw-hand]\n      (let [hand (map parse-card raw-hand)\n            suits (frequencies (map :suit hand))\n            ranks (sort (map :rank hand))\n            of-a-kind (frequencies (vals (frequencies ranks)))\n            flush? (= 1 (count suits))\n            straight? (or (sequence? ranks) (sequence? (sort (replace {1 14} ranks))))]\n        (cond\n          (and flush? straight?) :straight-flush\n          (of-a-kind 4)          :four-of-a-kind\n          (and (of-a-kind 3)\n               (of-a-kind 2))    :full-house\n          flush?                 :flush\n          straight?              :straight\n          (of-a-kind 3)          :three-of-a-kind\n          (= 2 (of-a-kind 2))    :two-pair\n          (of-a-kind 2)          :pair\n          :else                  :high-card))))","user":"5275f7a2e4b03e8d9a4a74d0"},{"code":"(fn best-hand [card-strings]\n  (let [card-parser (fn [[s r]]\n                      (let [suit ({\\S :spade, \\H :heart, \n                                   \\D :diamond, \\C :club} s)\n                            rank (if (> (Character/digit r 10) -1)\n                                   (- (Character/digit r 10) 2)\n                                   ({\\T 8, \\J 9, \n                                     \\Q 10, \\K 11, \\A 12} r))]\n                        {:suit suit, :rank rank}))\n        cards (map card-parser card-strings)\n        suits (map :suit cards)\n        ranks (map :rank cards)\n        rank-freqs (sort (vals (frequencies ranks)))\n\n        flush? (apply = suits) \n        \n        straight? (let [aces-high (sort ranks)\n                        aces-low (sort (replace {12 -1} ranks))]\n                    (or\n                      (= aces-high (take 5 (iterate inc (first aces-high))))\n                      (= aces-low  (take 5 (iterate inc (first aces-low))))))]\n    (cond \n      (and flush? straight?) :straight-flush\n      (= rank-freqs [1 4])   :four-of-a-kind\n      (= rank-freqs [2 3])   :full-house\n      flush?                 :flush\n      straight?              :straight\n      (some #{3} rank-freqs) :three-of-a-kind\n      (= rank-freqs [1 2 2]) :two-pair\n      (some #{2} rank-freqs) :pair\n      :else                  :high-card)))","problem":"178","user":"51ce1320e4b0e42293a22551"},{"problem":"178","code":"(fn s\n     ([h]\n      (let [r (range 10)\n            vs (assoc (zipmap (map str r) r) \"T\" 10 \"J\" 11 \"Q\" 12 \"K\" 13 \"A\" 14)]\n        (or\n          (some (fn [[a b]] (and b a))\n            (interleave\n              (s h vs)\n              (s h (assoc vs \"A\" 1))))\n          :high-card)))\n     ([h vs]\n      (let [rs (sort (map #(get vs (str (second %))) h))\n            r (->> rs\n                (group-by identity)\n                (map val)\n                (remove (comp #{1} count)))\n\n            k? #(some (comp #{%} count) r)\n\n            s? (->> (partition 2 1 rs)\n                 (map #(apply - %))\n                 (every? #{-1}))\n\n            f? (= 1 (count (group-by first h)))]\n        {:straight-flush  (and s? f?)\n         :four-of-a-kind  (k? 4)\n         :full-house      (and (k? 3) (k? 2))\n         :flush           f?\n         :straight        s?\n         :three-of-a-kind (k? 3)\n         :two-pair        (and (= 2 (count r)) (k? 2))\n         :pair            (k? 2)})))","user":"53ea5851e4b036ad0777e4e4"},{"problem":"178","code":"(fn [cards]\n  (letfn [\n    (card [[suit rank]]\n      {:suit ({\\D :diamond \\H :heart \\S :spade \\C :club} suit)\n       :rank ((zipmap \"23456789TJQKA\" (range)) rank)})\n    (card-pairs [xs] (->> xs\n      sort\n      reverse\n      (partition 2 1)))\n    (in-sequence? [xs] (and (every? #(= 1 (apply - %)) (rest (card-pairs xs)))))]\n    (let [\n      hand (map card cards)\n      flat-ranks (map :rank hand)\n      by-rank (group-by :rank hand)\n      counts-by-rank (map count (vals by-rank))\n      by-suit (group-by :suit hand)\n      ranks (count by-rank)\n      suits (count by-suit)]\n      (cond\n        (= 1 suits) (if (in-sequence? (map :rank (flatten (vals by-suit)))) :straight-flush :flush)\n        (= 2 ranks) (case (apply max counts-by-rank)\n                          4 :four-of-a-kind\n                          3 :full-house)\n        (= 3 ranks) (case (apply max counts-by-rank)\n                          3 :three-of-a-kind\n                          2 :two-pair)\n        (in-sequence? flat-ranks) :straight\n        (= 4 ranks) :pair\n        :else       :high-card)\n      )))","user":"55d5e80ee4b0e31453f64a91"},{"problem":"178","code":"; Evil hack\n(fn [& _]\n  (reify nil\n    clojure.lang.IPersistentCollection\n    (seq [_])\n    (cons [_ _])\n    (empty [_])\n    (equiv [_ _] true)))","user":"51e58e02e4b0efabf93c02d0"},{"code":"(fn [cards]\n  (let [all-same-suit? (apply = (map first cards))\n        rank-value (zipmap \"23456789TJQKA\" (range 1 14))\n        ranks (sort (map #(rank-value (second %)) cards))\n        rank-freqs (-> ranks frequencies vals sort)\n        in-sequence? #(apply = 1 (map - (drop 1 %) %))\n        all-in-sequence? (or (in-sequence? ranks) (->> ranks (map #(mod % 13)) sort in-sequence?))]\n    (cond\n      (and all-same-suit? all-in-sequence?) :straight-flush\n      (some #{4} rank-freqs) :four-of-a-kind\n      (= rank-freqs [2 3]) :full-house\n      all-same-suit? :flush\n      all-in-sequence? :straight\n      (some #{3} rank-freqs) :three-of-a-kind\n      :else\n      (case (-> rank-freqs frequencies (get 2))\n        2 :two-pair\n        1 :pair\n        :high-card))))","problem":"178","user":"5028cd0fe4b01614d1633ffc"},{"problem":"178","code":"(fn [cards]\n    (letfn [(suit [card]  ({\\D :diamond, \\H :heart, \\C :club, \\S :spade} (nth card 0)))\n            (rank [card]  ({\\2 0, \\3 1, \\4 2, \\5 3, \\6 4, \\7 5, \\8 6, \\9 7, \\T 8, \\J 9, \\Q 10, \\K 11, \\A 12} (nth card 1)))\n            (id   [card]  {:suit (suit card) :rank (rank card)})\n            (ids  [cards] (map id cards))\n            (strict-order? [ns]\n              (let [lo (apply min ns)\n                    hi (apply max ns)\n                    r  (range lo (+ lo 5))]\n                (cond (not= 5 (count (keys (group-by identity ns)))) false\n                      (= (sort ns) (range lo (+ lo 5))) true\n                      (= 12 hi) (strict-order? (conj (remove #(= 12 %) ns) -1)))))]\n      (let [hand          (ids cards)\n            suits         (group-by :suit hand)\n            ranks         (group-by :rank hand)\n            flush?        (= 1 (count (keys suits)))\n            straight?     (strict-order? (keys ranks))\n            four-kind?    (some #(= 4 %) (map count (vals ranks)))\n            three-kind?   (some #(= 3 %) (map count (vals ranks)))\n            pair?         (some #(= 2 %) (map count (vals ranks)))\n            two-pair?     (= 2 (count (filter #(= 2 (count %))  (vals ranks))))]\n        (cond (and straight? flush?)  :straight-flush\n              four-kind?              :four-of-a-kind\n              (and three-kind? pair?) :full-house\n              flush?                  :flush\n              straight?               :straight\n              three-kind?             :three-of-a-kind\n              two-pair?               :two-pair\n              pair?                   :pair\n              :else                   :high-card))))","user":"52485f02e4b05ef8e38e63d3"},{"problem":"178","code":"(fn [s]\n    (let [rank1 (zipmap \"23456789TJQKA\" (range))\n         rank2 (zipmap \"A23456789TJQK\" (range))]\n     (letfn [(is-flush [s] (apply = (map first s)))\n             (sort-rank\n               ([s] (sort-rank s rank1))\n               ([s rank] (sort\n                          #(compare\n                            (get rank (second %1))\n                            (get rank (second %2))) s)))\n             (is-strait [s] (or\n                             (let [r (ranks (sort-rank s))]\n                               (apply = (map - (rest r) r)))\n                             (let [r (ranks (sort-rank s rank2) rank2)]\n                               (apply = (map - (rest r) r)))))\n             (is-strait-flush [s] (and (is-strait s) (is-flush s)))\n             (ranks\n               ([s] (ranks s rank1))\n               ([s rank] (map #(get rank (second %)) s)))]\n       (let [kinds (reverse\n                    (sort (map count (partition-by second (sort-rank s)))))]\n         (cond (is-strait-flush s) :straight-flush\n               (= 4 (first kinds)) :four-of-a-kind\n               (and (= 3 (first kinds)) (= 2 (second kinds))) :full-house\n               (is-flush s) :flush\n               (is-strait s) :straight\n               (= 3 (first kinds)) :three-of-a-kind\n               (and (= 2 (first kinds)) (= 2 (second kinds))) :two-pair\n               (= 2 (first kinds)) :pair\n               :else :high-card)))))","user":"4f3ec266e4b0e243712b1f8c"},{"problem":"178","code":"(fn [cs]\n    (let [flush? (apply = (map first cs))\n          ranks (frequencies (map second (frequencies (map second cs))))\n          straight? (some #(= (set %) (set (map second cs))) (partition 5 1 [\\A \\2 \\3 \\4 \\5 \\6 \\7 \\8 \\9 \\T \\J \\Q \\K \\A]))]\n    (cond\n      (and flush? straight?) :straight-flush\n      (ranks 4) :four-of-a-kind\n      (and (ranks 3) (ranks 2)) :full-house\n      flush? :flush\n      straight? :straight\n      (ranks 3) :three-of-a-kind\n      (= 2 (ranks 2)) :two-pair\n      (ranks 2) :pair\n      :else :high-card)))","user":"51e28063e4b08e53a149f0f2"},{"problem":"178","code":"(fn best-hand [card-strings]\n  (let [card-parser (fn [[s r]]\n                      (let [suit ({\\S :spade, \\H :heart, \n                                   \\D :diamond, \\C :club} s)\n                            rank (if (> (Character/digit r 10) -1)\n                                   (- (Character/digit r 10) 2)\n                                   ({\\T 8, \\J 9, \n                                     \\Q 10, \\K 11, \\A 12} r))]\n                        {:suit suit, :rank rank}))\n        cards (map card-parser card-strings)\n        suits (map :suit cards)\n        ranks (map :rank cards)\n\n        flush? \n        (if (= 1 (count (set suits))) :flush nil)\n\n        straight? \n        (let [aces-high (sort ranks)\n              aces-low (sort (replace {12 -1} ranks))]\n               (if (or\n                     (= aces-high (take 5 (iterate inc (first aces-high))))\n                     (= aces-low  (take 5 (iterate inc (first aces-low)))))\n                 :straight\n                 nil))\n\n        straight-flush?\n        (if (and flush? straight?) :straight-flush nil)\n\n        pair? \n        (if (some (fn [[r num]] (>= num 2)) (frequencies ranks)) \n          :pair \n          nil)\n\n        three-of-a-kind?\n        (if (some (fn [[r num]] (>= num 3)) (frequencies ranks)) \n          :three-of-a-kind\n          nil)\n\n        four-of-a-kind?\n        (if (some (fn [[r num]] (= num 4)) (frequencies ranks))\n          :four-of-a-kind\n          nil)\n\n        two-pair?\n        (if (or \n              (some (fn [[r num]] (>= num 4)) (frequencies ranks))\n              (= 2 (count (filter (fn [[r num]] (>= num 2)) \n                                  (frequencies ranks)))))\n          :two-pair\n          nil)\n \n        full-house?\n        (if (and\n              (some (fn [[r num]] (= num 3)) (frequencies ranks))\n              (some (fn [[r num]] (= num 2)) (frequencies ranks)))\n          :full-house\n          nil)\n \n        possible-hands \n        (remove nil? [straight-flush? four-of-a-kind? full-house? flush?\n                      straight? three-of-a-kind? two-pair? pair?])]\n    (if-not (empty? possible-hands)\n      (first possible-hands)\n      :high-card)))","user":"5d9c9446e4b0eb781811cdae"},{"code":"(fn [_h]\n   (let [h (map\n            (fn [c]\n              (hash-map\n               :suit\n               ({\\D :diamond \\H :heart \\C :club \\S :spade} (first c))\n               :rank\n               ({\\2 0 \\3 1 \\4 2 \\5 3 \\6 4 \\7 5 \\8 6 \\9 7 \\T 8 \\J 9 \\Q 10 \\K 11 \\A 12} (second c))\n               )\n              )\n            _h)\n         allsuits #{:diamond :heard :club :spade}\n         cs (map #(% :suit) h)\n         rs (sort (map #(% :rank) h))\n         rsl (sort (map #(dec (mod (inc %) 13)) rs))\n         flush (apply = cs)\n         straight (and\n                   (= (count (distinct rs)) 5)\n                   (or\n                    (= 4 (- (last rs) (first rs)))\n                    (= 4 (- (last rsl) (first rsl)))))\n         scount (apply max (vals (frequencies rs)))\n         pcount ((frequencies (vals (frequencies rs))) 2)]\n     (if (and flush straight)\n       :straight-flush\n       (if (= scount 4)\n         :four-of-a-kind\n         (if (and (= scount 3) (= pcount 1))\n           :full-house\n           (if flush\n             :flush\n             (if straight\n               :straight\n               (if (= scount 3)\n                 :three-of-a-kind\n                 (if (= pcount 2)\n                   :two-pair\n                   (if (= scount 2)\n                     :pair\n                     :high-card))))))))))","problem":"178","user":"52586d24e4b0cb4875a45cb0"},{"problem":"178","code":"(let [suit (fn\n             [c]\n             (if (= c \"C\")\n               :club\n               (if (= c \"D\")\n                 :diamond\n                 (if (= c \"H\")\n                   :heart\n                   :spade))))\n      rank (fn\n        [c]\n        (if (= c \"A\")\n          12\n          (if (= c \"K\")\n            11\n            (if (= c \"Q\")\n              10\n              (if (= c \"J\")\n                9\n                (if (= c \"T\")\n                  8\n                  (- (int (first c)) (int \\2))))))))\n      suit-and-rank (fn\n                      [input]\n                      (assoc {} :suit (suit (str (first input))) \n                             :rank (rank (str (second input)))))]\n  (fn best-hand\n    [raw-cards]\n    (let [cards (map suit-and-rank raw-cards)\n          rank-set (into #{} (map :rank cards))\n          suit-set (into #{} (map :suit cards))\n          rank-counts (map (fn [rank]\n                             (count (filter #(= (:rank %) rank) cards)))\n                            rank-set)\n          flush (= 1 (count suit-set))\n          straight (or (and (= (count rank-set) 5)\n                            (= (- (apply max rank-set) \n                                  (apply min rank-set))\n                               4))\n                       (= rank-set #{0 1 2 3 12}))\n          four-of (= (sort rank-counts) [1 4])\n          full-house (= (sort rank-counts) [2 3])\n          three-of (= (sort rank-counts) [1 1 3])\n          two-pair (= (sort rank-counts) [1 2 2])\n          pair (= (sort rank-counts) [1 1 1 2])]\n         (if (and straight flush) :straight-flush\n             (if four-of :four-of-a-kind\n                 (if full-house :full-house\n                     (if flush :flush\n                         (if straight :straight\n                             (if three-of :three-of-a-kind\n                                 (if two-pair :two-pair\n                                     (if pair :pair\n                                         :high-card)))))))))))","user":"58152157e4b0f478707a0631"},{"problem":"178","code":"(fn [cards] \n   (let \n     [sequences (set (map sort (map #(take 5 (drop % [\\A \\2 \\3 \\4 \\5 \\6 \\7 \\8 \\9 \\T \\J \\Q \\K \\A])) (range 10))))\n      isflush (= 1 (count (set (map first cards))))\n      isseq (sequences (sort (map second cards)))\n      counts (reverse (sort (vals (frequencies (map second cards)))))]\n   (cond\n    (and isflush isseq) :straight-flush\n    (= (take 1 counts) [4]) :four-of-a-kind\n    (= (take 2 counts) [3 2]) :full-house\n    isflush :flush\n    isseq :straight\n    (= (take 1 counts) [3]) :three-of-a-kind\n    (= (take 2 counts) [2 2]):two-pair\n    (= (take 1 counts) [2]) :pair\n    :else :high-card\n     )))","user":"4feada56e4b0140c20fb9c11"},{"problem":"178","code":"(fn [h]\n  (letfn [(contig? [rs]\n            (let [ds (distinct rs)]\n              (and (= (count rs) (count ds))\n                   (= (- (apply max ds) (apply min ds)) (dec (count ds))))))\n\n          (ranks [h]\n            (mapv (comp\n                    {\\A 1, \\2 2, \\3 3, \\4 4, \\5 5, \\6 6, \\7 7, \\8 8, \\9 9,\n                     \\T 10, \\J 11, \\Q 12, \\K 13}\n                    second)\n                  h))\n\n          (straight? [h]\n            (let [ranks (ranks h)]\n              (or (contig? ranks)\n                  (contig? (mapv #(if (= % 1) 14 %) ranks)))))\n\n          (max-freq [h]\n            (apply max (-> h ranks frequencies vals)))\n\n          (full-house? [h]\n            (= #{2 3} (-> h ranks frequencies vals set)))\n\n          (two-pair? [h]\n            (= 2 ((-> h ranks frequencies vals frequencies) 2)))\n\n          (flush? [h]\n            (apply = (map first h)))]\n\n    (cond\n      (and (straight? h) (flush? h)) :straight-flush\n      (= 4 (max-freq h)) :four-of-a-kind\n      (full-house? h) :full-house\n      (flush? h) :flush\n      (straight? h) :straight\n      (= 3 (max-freq h)) :three-of-a-kind\n      (two-pair? h) :two-pair\n      (= 2 (max-freq h)) :pair\n      :else :high-card)))","user":"4ec1b090535dfed6da9c6db5"},{"problem":"178","code":"(fn [hand]\n    (letfn [(occurrences-count [n]\n              (count (filter #(= (count (val %)) n)\n                             (group-by second hand))))\n            (value [card]\n              ({\\2 2 \\3 3 \\4 4 \\5 5\n                \\6 6 \\7 7 \\8 8 \\9 9\n                \\T 10 \\J 11 \\Q 12 \\K 13}\n               (second card)))\n            (adjacent? [x y]\n              (cond (= (second x) \\A) (#{\\K \\2} (second y))\n                    (= (second y) \\A) (#{\\K \\2} (second x))\n                    :else             (= (Math/abs (- (value x) (value y)))\n                                         1)))\n            (straight-from? [current-card cards]\n              (if (empty? cards)\n                true\n                (let [next-card (first (filter #(adjacent? current-card %)\n                                               cards))]\n                  (and next-card (straight-from? next-card (disj cards next-card))))))\n            (straight? []\n              (some #(straight-from? % (disj (set hand) %)) hand))\n            (flush? []\n              (= (count (group-by first hand)) 1))\n            (full-house? []\n              (and (= (occurrences-count 3) 1)\n                   (= (occurrences-count 2) 1)))]\n      (cond (and (straight?) (flush?))  :straight-flush\n            (= (occurrences-count 4) 1) :four-of-a-kind\n            (full-house?)               :full-house\n            (flush?)                    :flush\n            (straight?)                 :straight\n            (= (occurrences-count 3) 1) :three-of-a-kind\n            (= (occurrences-count 2) 2) :two-pair\n            (= (occurrences-count 2) 1) :pair\n            :else                       :high-card)))","user":"53acaf1fe4b047364c04445f"},{"problem":"178","code":"(fn[input]\n  (let [rankMap {\"2\" 0,\"3\" 1,\"4\" 2,\"5\" 3, \"6\" 4,\"7\" 5,\"8\" 6,\"9\" 7,\"T\" 8,\n                \"J\" 9,\"Q\" 10,\"K\" 11,\"A\" 12}\n        numberOfCards (count input)      \n        suits (reduce #(conj %1 (first %2)) [] input)\n        distinctSuits (into #{} suits)\n        ranks (reduce #(conj %1 (second %2)) [] input)\n        convertedRanksAceHigh (map #(get rankMap (str %)) ranks)\n        convertedRanksAceLow (map #(if (= 12 %) -1 %) convertedRanksAceHigh)\n        rankCountMap (reduce #(if (contains? %1 %2) (assoc %1 %2 (inc (get %1 %2))) (assoc %1 %2 1)) {} ranks)\n        allSameSuit (= 1 (count distinctSuits))\n        fourCardsSameRank (not (empty? (filter #(= 4 %) (vals rankCountMap))))\n        minOfAceHigh (apply min convertedRanksAceHigh)\n        minOfAceHighSequence (range minOfAceHigh (+ minOfAceHigh numberOfCards))\n        minOfAceLow (apply min convertedRanksAceLow)\n        minOfAceLowSequence (range minOfAceLow (+ minOfAceLow numberOfCards))\n        inSequenceAceHigh (if (= minOfAceHigh (first convertedRanksAceHigh)) (= convertedRanksAceHigh minOfAceHighSequence) (= (reverse convertedRanksAceHigh) minOfAceHighSequence))\n        inSequenceAceLow (if (= minOfAceLow (first convertedRanksAceLow)) (= convertedRanksAceLow minOfAceLowSequence) (= (reverse convertedRanksAceLow) minOfAceLowSequence))\n        inSequence (or inSequenceAceHigh inSequenceAceLow)\n        threeCardsSameRank (not (empty? (filter #(= 3 %) (vals rankCountMap))))\n        fullHouse (and threeCardsSameRank (= 1 (count (filter #(= 2 %) (vals rankCountMap)))))\n        threeOfAKind (and threeCardsSameRank (= 2 (count (filter #(= 1 %) (vals rankCountMap)))))\n        twoPair (= 2 (count (filter #(= 2 %) (vals rankCountMap))))\n        onePair (= 1 (count (filter #(= 2 %) (vals rankCountMap))))\n                            \n        ]\n      (cond \n          (and allSameSuit inSequence) :straight-flush\n          fourCardsSameRank :four-of-a-kind\n          fullHouse :full-house\n          allSameSuit :flush\n          inSequence :straight\n          threeOfAKind :three-of-a-kind\n          twoPair :two-pair\n          onePair :pair\n          :else :high-card))\n   \n   )","user":"571172ece4b09c608db70446"},{"problem":"178","code":"(letfn \n  [(reco [card]\n     { :suit\n       ((zipmap \"DHSC\" [:diamond :heart :spade :club]) (first card))\n       :rank\n       ((zipmap \"23456789TJQKA\" (range 13)) (second card))})\n\n   (in-seq? [ranks]\n     (let [r (sort (keys ranks))]\n       (if (= r '(0 1 2 3 12)) true\n         (if (and\n              (= 4 (- (apply max r) (apply min r)))\n              (= 5 (count (frequencies r)))) \n           true\n           false))))]\n  \n  (fn [raw]\n    (let [cards (map reco raw)\n          suits (frequencies (map :suit cards))\n          ranks (frequencies (map :rank cards))\n          rank-kinds (set (vals ranks))]\n\n      (if (and (= 1 (count suits)) (in-seq? ranks)) :straight-flush\n        (if (contains? rank-kinds 4) :four-of-a-kind\n          (if (= rank-kinds #{3 2}) :full-house\n            (if (= 1 (count suits)) :flush\n              (if (in-seq? ranks) :straight\n                (if (contains? rank-kinds 3) :three-of-a-kind\n                  (if (= (sort (vals ranks)) '(1 2 2)) :two-pair\n                    (if (= rank-kinds #{1 2}) :pair\n                      :high-card)))))))))))","user":"53065acbe4b02e8216869792"},{"code":"(fn p178 [lst]\n   (letfn [(mkng [gs e]\n             (reduce conj (reduce conj #{} (apply concat gs)) e))\n           (isnext [n] (fn [a] (= 1 (Math/abs (- n a)))))\n           (gng [gs ngs]\n             (if (empty? gs) nil\n                 (if (some (fn [x] (some (isnext x) (first gs))) ngs)\n                   (cons (first gs) (gng (next gs) ngs))\n                   (gng (next gs) ngs))))\n           (tn [cn] ({\\A 14 \\K 13 \\Q 12 \\J 11 \\T 10} cn (- (int cn) (int \\0)) ))\n           (unio [ga e] (let [rt (gng ga e)\n                              r (conj (reduce disj ga rt) (mkng rt e))\n                              ] (if (= r #{#{2 3 4 5} #{14}}) #{#{1 2 3 4 5}} r)))\n           (dup [rs n] (count (filter #(= n (count (second %))) (group-by identity rs))))\n           (grank [lst] (map (comp tn second) lst))\n           (ghert [lst] (reduce conj #{} (map first lst)))\n           (db [lst] (map (juxt first second) lst))\n           (hand [lst]\n             (let [\n                   cs (db lst)\n                   hs (ghert lst)\n                   rs (grank lst)\n                   sg (reduce unio #{} (map hash-set (reduce conj #{} rs)))\n                   dcs (reduce conj {} (map (fn [i] [i (dup rs i)]) [2 3 4 5]) )\n                   infos [cs hs rs sg dcs]\n                   ]\n               (cond\n                (and (= 1 (count hs)) (= 1 (count sg))) :straight-flush                                                          \n                (= 1 (dcs 4)) :four-of-a-kind                                                                                    \n                (and (= 1 (dcs 3)) (= 1 (dcs 2))) :full-house                                                                    \n                (= 1 (count hs)) :flush                                                                                          \n                (= 1 (count sg)) :straight                                                                                       \n\t\t(= 1 (dcs 3)) :three-of-a-kind                                                                                   \n\t\t(= 2 (dcs 2)) :two-pair                                                                                          \n\t\t(= 1 (dcs 2)) :pair                                                                                              \n\t\ttrue :high-card)\n\t       ))]\n     (hand lst)))","problem":"178","user":"5272669de4b03e8d9a4a742e"},{"code":"(fn best-hand[hand]\n  (let [suit (fn [c] (first c))\n        rank (fn [c] (last c))\n        ranks [\\2 \\3 \\4 \\5 \\6 \\7 \\8 \\9 \\T \\J \\Q \\K \\A]\n        four-of-a-kind? (fn [h] (if (some #(= 4 %) (vals (frequencies (map rank h)))) true false))\n        flush?          (fn [h]   (= 1 (count (vals (frequencies (map suit h))))))\n        straight?       (fn [h] (let [indexed-ranks (sort (map #(.indexOf ranks %) (map rank h)))\n                                  ends-diff (- (first indexed-ranks) (last indexed-ranks))]\n                              (cond\n                               (and (= 5 (count (frequencies indexed-ranks)))\n                               (= ends-diff -4)) true\n                               (= indexed-ranks '(0 1 2 3 12)) true\n                               :else false)))\n                \n        trips?       (fn [h]  (if (some #(= 3 %) (vals (frequencies (map rank h)))) true false))  \n        two-pair?    (fn [h](if (= 3 (count (frequencies (map rank h)))) true false))\n        pair?        (fn [h](if (some #(= 2 %) (vals (frequencies (map rank h)))) true false))\n        straight-flush? (fn [h] (and (straight? h) (flush? h)))\n        full-house?     (fn [h] (= 2 (count (frequencies (map rank h) ))))\n        ]    \n    \n    \n  \n  (cond\n   (straight-flush? hand) :straight-flush\n   (four-of-a-kind? hand) :four-of-a-kind\n   (full-house? hand)     :full-house\n   (flush? hand)          :flush\n   (straight? hand)       :straight\n   (trips? hand) :three-of-a-kind\n   (two-pair? hand)       :two-pair\n   (pair? hand)           :pair\n   :else               :high-card   )))","problem":"178","user":"5078dedae4b08327cd804a5d"},{"problem":"178","code":"(let [toMap (fn [s]\n  (let [suitS (first s)\n        rankS (second s)\n        suit (cond\n              (= \\D suitS) :diamond\n              (= \\H suitS) :heart\n              (= \\C suitS) :club\n              (= \\S suitS) :spades\n              )\n        rank (cond\n              (= \\A rankS) 12\n              (= \\K rankS) 11\n              (= \\Q rankS) 10\n              (= \\J rankS) 9\n              (= \\T rankS) 8\n              :else (- (read-string (str rankS)) 2))\n        ]\n    {:suit suit\n    :rank rank}))]\n  (fn [ls]\n    (let [cards (map toMap ls)\n          gRank (group-by :rank cards)\n          gSuit (group-by :suit cards)\n          nRank (map (fn [[k v]] (count v)) gRank)\n          nSuit (map (fn [[k v]] (count v)) gSuit)\n          sortedRank (sort (map :rank cards))\n          straight? (or (= sortedRank '(0 1 2 3 12))\n                             (= sortedRank (range (first sortedRank) (+ 1 (last sortedRank)))))\n          pair? (= 1 (count (filter #(= 2 %) nRank)))\n          three? (= 1 (count (filter #(= 3 %) nRank)))\n          flush? (= 1 (count (filter #(= 5 %) nSuit)))]\n      (cond\n       (and flush? straight?) :straight-flush\n       (and three? pair?) :full-house\n       (= 1 (count (filter #(= 4 %) nRank))) :four-of-a-kind\n       flush? :flush\n       straight? :straight\n       three? :three-of-a-kind\n       (= 2 (count (filter #(= 2 %) nRank))) :two-pair\n       pair? :pair\n       :else :high-card\n       )\n    )))","user":"541ef7e2e4b01498b1a71a92"},{"problem":"178","code":"(fn [cards]\n    (let [ranks [\\2 \\3 \\4 \\5 \\6 \\7 \\8 \\9 \\T \\J \\Q \\K \\A]\n          ordinal (fn [card] (.indexOf ranks (last card)))\n          hand (->> cards\n                sort\n                (partition-by first)\n                (map #(sort (map ordinal %))))\n          flush? (fn [hand] (= 1 (count hand)))\n          straight? (fn [hand] (let [rks (sort (flatten hand))\n                                     rks (map #(- % (first rks)) rks)]\n                                 (or (= [0 1 2 3 4] rks)\n                                     (= [0 1 2 3 12] rks))))\n          freqs (fn [hand] (map last (frequencies (flatten hand))))\n          has? (fn [hand n] (some #{n} (freqs hand)))\n          two-pair? (fn [hand] (some #{2} (map last (frequencies (freqs hand)))))]\n      (cond\n        (and (straight? hand) (flush? hand)) :straight-flush\n        (has? hand 4) :four-of-a-kind\n        (and (has? hand 3) (has? hand 2)) :full-house\n        (flush? hand) :flush\n        (straight? hand) :straight\n        (has? hand 3) :three-of-a-kind\n        (two-pair? hand) :two-pair\n        (has? hand 2) :pair\n        :default :high-card)))","user":"4e837808535db62dc21a62d9"},{"problem":"178","code":"(fn recog-play-card- [coll] (letfn [(suit? [ch] (cond\n                                                    (= \\C ch) 1\n                                                    (= \\D ch) 2\n                                                    (= \\H ch) 3\n                                                    (= \\S ch) 4\n                                                    :else nil))\n\n                                      (rank? [x] (cond\n                                                   (= \\A x) 14\n                                                   (= \\2 x) 2\n                                                   (= \\3 x) 3\n                                                   (= \\4 x) 4\n                                                   (= \\5 x) 5\n                                                   (= \\6 x) 6\n                                                   (= \\7 x) 7\n                                                   (= \\8 x) 8\n                                                   (= \\9 x) 9\n                                                   (= \\T x) 10\n                                                   (= \\J x) 11\n                                                   (= \\Q x) 12\n                                                   (= \\K x) 13\n                                                   :else nil))\n\n                                      (trans [[s r]] [(suit? s) (rank? r)])\n\n                                      (card [coll] (map #(trans (seq %)) coll))\n\n                                      (straight-flush? [coll] (and (straight? coll) (flush? coll)))\n\n                                      (four-of-a-kind? [coll] (let [r (partition-by identity (sort (map last coll)))]\n                                                                (if (empty? (filter #(= 4 (count %)) r))\n                                                                  false\n                                                                  true)))\n\n                                      (full-house? [coll] (let [r (partition-by identity (sort (map last coll)))\n                                                                tris (filter #(= 3 (count %)) r)\n                                                                res (filter #(not (= 3 (count %))) r)\n                                                                pair (filter #(= 2 (count %)) res)]\n                                                            (if (empty? tris)\n                                                              false\n                                                              (if (empty? pair)\n                                                                false\n                                                                true))))\n\n                                      (flush? [coll] (let [s (map first coll)]\n                                                       (= 1 (count (distinct s)))))\n\n                                      (straight? [coll] (let [r (sort (map last coll))\n                                                              thr (nth r 2)]\n                                                          (if (= '(2 3 4 5 14) r)\n                                                            true\n                                                            (= thr (/ (reduce + r) 5)))))\n                                      (three-of-a-kind? [coll] (let [r (partition-by identity (sort (map last coll)))\n                                                                     tris (filter #(= 3 (count %)) r)]\n                                                                 (not (empty? tris))))\n\n                                      (two-pair? [coll] (let [r (partition-by identity (sort (map last coll)))\n                                                              pair (filter #(= 2 (count %)) r)]\n                                                          (= 2 (count pair))))\n\n\n                                      (pair? [coll] (let [r (partition-by identity (sort (map last coll)))\n                                                          pair (filter #(= 2 (count %)) r)]\n                                                      (= 1 (count pair))))]\n                                (let [vek (card coll)]\n                                  (cond\n                                    (straight-flush? vek) :straight-flush\n                                    (four-of-a-kind? vek) :four-of-a-kind\n                                    (full-house? vek) :full-house\n                                    (flush? vek) :flush\n                                    (straight? vek) :straight\n                                    (three-of-a-kind? vek) :three-of-a-kind\n                                    (two-pair? vek) :two-pair\n                                    (pair? vek) :pair\n                                    :else :high-card))))","user":"54b7f217e4b0ed20f4ff6e8f"},{"code":"(fn [cards] \n   (let [cards (map (fn [c] (let [suit (case (.toString (first c))\n                                         \"D\" :diamond\n                                         \"H\" :heart\n                                         \"S\" :spade\n                                         \"C\" :club)\n                                  rank (case (.toString (second c))\n                                         \"A\" 12\n                                         \"K\" 11\n                                         \"Q\" 10\n                                         \"J\" 9\n                                         \"T\" 8\n                                         (-  (Integer/parseInt (.toString (second c))) 1))]\n                              {:suit suit :rank rank}))\n                    cards)\n         ranks (vals (frequencies (map :rank cards)))\n         flush? (= 1 (count (distinct (map :suit cards))))\n         s? (fn [cs] (let [ol (sort cs)]\n                       (loop [l ol\n                              acc []]\n                         (if (or (nil? acc) (empty? l))\n                           (= (count acc) (count ol))\n                           (recur (rest l)\n                                  (if (empty? acc)\n                                    [(first l)]\n                                    (if (= (inc (last acc)) (first l))\n                                      (conj acc (first l))\n                                      nil)))))))\n         straight? (let [r (map :rank cards)]\n                     (if (some #{12} r)\n                       (or (s? (conj (remove #{12} r) 0))\n                           (s? r))\n                       (s? cards)))]\n     (cond (some #(= 4 %) ranks) :four-of-a-kind\n           (= #{3 2} (set ranks)) :full-house        \n           (some #(= 3 %) ranks) :three-of-a-kind\n           (and straight? flush?) :straight-flush\n           flush? :flush\n           (= '(1 2 2) (sort ranks)) :two-pair\n           (= 2 (reduce max ranks)) :pair\n           straight? :straight\n           :else :high-card)))","problem":"178","user":"50a5b7e9e4b0aa96157e2610"},{"problem":"178","code":"(fn [c]\n  (letfn [(recognize-card [[s r]]\n            (let [suits (zipmap \"SHDC\" [:spade :heart :diamond :club])\n                  ranks (zipmap \"23456789TJQKA\" (range))]\n              {:suit (get suits s) :rank (get ranks r)}))\n          \n          (same [_key cards]\n            (reduce (fn [same-map new-card]\n                      (assoc same-map (_key new-card) (inc (get same-map (_key new-card) 0))))\n                    {} cards))\n          \n          (amount-same [amount _key cards]\n            (some #{amount} (vals (same _key cards))))\n          \n          (same-suit [cards]\n            (amount-same (count cards) :suit cards))\n          \n          (in-sequence [[first-card second-card & remaining-cards :as cards]]\n            (cond\n              (nil? second-card) true\n              \n              (= (:rank first-card) (dec (:rank second-card)))\n              (in-sequence (rest cards))\n              \n              :else false))\n          \n          (in-seq-ace-high [cards]\n            (in-sequence cards))\n\n          (in-seq-ace-low [cards]\n            (in-sequence (sort-by :rank (map #(if (= 12 (:rank %)) (assoc % :rank -1) %) cards))))\n\n          (in-seq-aces [cards]\n            (or (in-seq-ace-high cards) (in-seq-ace-low cards)))]\n    (let [cards (sort-by :rank (map recognize-card c))]\n      (cond\n        (and (same-suit cards) (in-seq-aces cards)) :straight-flush\n        (amount-same 4 :rank cards) :four-of-a-kind\n        (and (amount-same 2 :rank cards) (amount-same 3 :rank cards)) :full-house\n        (same-suit cards) :flush\n        (in-seq-aces cards) :straight\n        (amount-same 3 :rank cards) :three-of-a-kind\n        (= 2 (count (filter #(= 2 (val %)) (same :rank cards)))) :two-pair\n        (amount-same 2 :rank cards) :pair\n        :else :high-card))))","user":"51b76227e4b0d906fcd71d35"},{"problem":"178","code":"(fn [cards]\n    (let [ card-parse (fn [card]\n            [(str (nth card 0)) (.indexOf \"A23456789TJQK\" (str (nth card 1)))])\n           card-suit (fn [card] (nth (card-parse card) 0))\n           card-value (fn [card] (nth (card-parse card) 1))\n           card-value-norm (fn [card] (mod (+ (card-value card) 6) 13 ))\n           flsh (fn [cards] (= (count (group-by card-suit cards)) 1))\n           straight-cmp (fn [ca cb] (if (or (= (+ ca 1) cb)) cb -100 ))\n           straight (fn [cards]\n                      (or (> (reduce straight-cmp (sort (map card-value cards))) 0)\n                          (> (reduce straight-cmp (sort (map card-value-norm cards))) 0)))\n           order (fn [cards] (map count (vals (group-by card-value cards))))\n           order-eq (fn [cards orders] (= (take (count orders) (order cards)) orders))\n          ]\n      (cond\n        (and (straight cards) (flsh cards)) :straight-flush\n        (order-eq cards [4]) :four-of-a-kind\n        (order-eq cards [3 2]) :full-house\n        (flsh cards) :flush\n        (straight cards) :straight\n        (order-eq cards [3]) :three-of-a-kind\n        (order-eq cards [2 2]) :two-pair\n        (order-eq cards [2]) :pair\n        :else :high-card\n      )  \n    )\n  )","user":"53da2839e4b0e771c3025489"},{"problem":"178","code":"(fn best-hand [cards]\n  (letfn [(card [[a b]]\n                 (let [suit ({\\S :spade \\H :heart \\C :club \\D :diamond} a)\n                       letterRank ({\\T 8 \\J 9 \\Q 10 \\K 11 \\A 12} b)\n                       rank (Character/getNumericValue b)]\n                   {:suit suit :rank (if (nil? letterRank) (- rank 2) letterRank)}))\n          (multiples [cards]\n                     (let [[d1 d2 others] (->> (map :rank cards)\n                                               frequencies\n                                               vals\n                                               sort\n                                               reverse)]\n                       (case d1\n                         4 :four-of-a-kind\n                         3 (if (= 2 d2) :full-house :three-of-a-kind)\n                         2 (if (= 2 d2) :two-pair :pair)\n                         1 :high-card)\n                       ))\n          (is-flush [cards]\n                    (= 1 (->> (map :suit cards)\n                              (into #{})\n                              count)))\n\n          (is-straight [cards]\n                       (let [ranks (sort (map :rank cards))]\n                         (and (= 5 (count (set ranks)))\n                              (or (= (+ (first ranks) 4) (last ranks))\n                                  (= [0 1 2 3 12] ranks)))))\n\n          ]\n    (let [cards (map card cards)\n          straight? (is-straight cards)\n          flush? (is-flush cards)\n          mult (multiples cards)]\n      (cond (and straight? flush?) :straight-flush\n            (#{:four-of-a-kind :three-of-a-kind} mult) mult\n            flush? :flush\n            straight? :straight\n            :else mult\n            ))))","user":"4f4c6b21e4b03ad3f0c10c8f"},{"code":"(fn [cs] (letfn [\n(suit [x] (get {\"S\" :spade \"H\" :heart \"D\" :diamond \"C\" :club} x))\n(rank [x] (.indexOf \"23456789TJQKA\" x))\n(split-str [s] (map #(apply str %) (partition 1 s)))\n(card [s] (let [ss (split-str s) suit-code (first ss) rank-code (second ss)] {:suit (suit suit-code) :rank (rank rank-code)}))\n(hand [cs] (map card cs))\n(increasing-by-1? [ns] (let [sorted (sort ns) smallest (apply min sorted) biggest (apply max sorted)] (= sorted (range smallest (inc biggest)))))\n(straight? [hand] (or (increasing-by-1? (map :rank hand)) (increasing-by-1? (replace {12 -1} (map :rank hand)))))\n(rank-counts [hand] (sort (map count (vals (group-by :rank hand)))))\n(four-of-a-kind? [hand] (= (rank-counts hand) [1 4]))\n(full-house? [hand] (= (rank-counts hand) [2 3]))\n(three-of-a-kind? [hand] (= (rank-counts hand) [1 1 3]))\n(two-pair? [hand] (= (rank-counts hand) [1 2 2]))\n(pair? [hand] (= (rank-counts hand) [1 1 1 2]))\n(high-card? [hand] (= (rank-counts hand) [1 1 1 1 1]))\n(flush? [hand] (apply = (map :suit hand)))\n(straight-flush? [hand] (and (straight? hand) (flush? hand)))\n(hand-values-best-first [] [:straight-flush :four-of-a-kind :full-house :flush :straight :three-of-a-kind :two-pair :pair :high-card])\n(hand-recognition-functions [] {:straight-flush straight-flush? :four-of-a-kind four-of-a-kind? :full-house full-house? :flush flush? :straight straight? :three-of-a-kind three-of-a-kind? :two-pair two-pair? :pair pair? :high-card high-card?})\n(best-hand [card-strings] (first (drop-while (complement #((get (hand-recognition-functions) %) (hand card-strings))) (hand-values-best-first))))\n] (best-hand cs)))","problem":"178","user":"52f10094e4b05e3f0be25ee8"},{"problem":"178","code":"(letfn[\n       (same_suit [s] (apply = (map #(first %) s)))\n       (straight  [s] (->> (map #(second %) s)\n                          (sort-by #((zipmap [\\2 \\3 \\4 \\5 \\6 \\7 \\8 \\9 \\T \\J \\Q \\K \\A] (range)) %))\n                          (apply str)\n                          ((fn [s] (if (contains? (set (map #(apply str %) (partition 5 1 \"23456789TJQKA\"))) s) true\n                                      (= s \"2345A\"))))))\n        (pairs_num [s] (->> (map #(second %) s)\n                          sort\n                          (partition 2 1)\n                          (reduce #(if (= (first %2) (second %2)) (inc %) %) 0)))\n        (same-rank [s] (->> (map #(second %) s)\n                            sort\n                            (#(loop [ [f & xs ] % re 1 mre 1]\n                                 (cond (empty? xs) mre\n                                     (= f (first xs)) (recur xs (inc re) (max (inc re) mre))\n                                     :else (recur xs 1 mre))))))\n        (my= [e1 e2] (loop [[f & xs] (range 0 (count e1))]\n                         (cond (not f) true\n                               (= (get e1 f) :ignore) (recur xs)\n                               (not= (get e1 f) (get e2 f)) false\n                               :else (recur xs))))]\n\n  #(condp my= ((juxt same_suit straight same-rank pairs_num) %) \n      [true true :ignore :ignore] :straight-flush\n      [false false 4 :ignore] :four-of-a-kind\n      [false false 3 3] :full-house\n      [true false :ignore :ignore] :flush\n      [false true :ignore :ignore] :straight\n      [false false 3 :ignore] :three-of-a-kind \n      [false false :ignore 2] :two-pair \n      [false false :ignore 1] :pair \n      :high-card))","user":"5dc12b0ae4b0e59a23173d84"},{"problem":"178","code":"(let [ranks {\\A 12, \\J 9, \\K 11, \\Q 10, \\2 0, \\3 1, \\4 2, \\5 3, \\6 4, \\7 5, \\8 6, \\T 8, \\9 7}\n       read-card (fn [c] [(nth c 0) (ranks (nth c 1))])\n       straight? (fn [cards] (let [rs (map second cards)]\n                               (when (= 4 (count (for [x rs y rs\n                                                       :when (and (> x y)\n                                                                  (or (= x (inc y))\n                                                                      (= y (mod (inc x) 13))))] :link)))\n                                 :straight)))\n       flush? (fn [cards] (when (= 1 (count (distinct (map first cards)))) :flush))\n       four-of-a-kind? (fn [cards] (when (= 4 (apply max (map count (vals (group-by second cards))))) :four-of-a-kind))\n       full-house? (fn [cards] (when (= '(2 3) (sort (map count (vals (group-by second cards))))) :full-house))\n       three-of-a-kind? (fn [cards] (when (= 3 (apply max (map count (vals (group-by second cards))))) :three-of-a-kind))\n       two-pair? (fn [cards] (when (= '(1 2 2) (sort (map count (vals (group-by second cards))))) :two-pair))\n       pair? (fn pair? [cards] (when (= '(1 1 1 2) (sort (map count (vals (group-by second cards))))) :pair))\n       straight-flush? (fn [cards] (and (straight? cards) (flush? cards) :straight-flush))]\n   (fn [cards]\n     (let [cards (mapv read-card cards)]\n       (or (some #(% cards) [straight-flush? four-of-a-kind? full-house? flush? straight? three-of-a-kind? two-pair? pair?])\n           :high-card))))","user":"547d8e93e4b0c51c1f4d72f4"},{"code":"(fn f [hand]\n  (let [flush? (= 1 (count (set (map first hand))))\n        facerank (zipmap \"23456789TJQKA\" (range))\n        ranks (sort (map (comp facerank second) hand))\n        straight? (some #{ranks} (cons [0 1 2 3 12] (partition 5 1 (range 13))))\n        n-of-a-kind (vec (sort (vals (frequencies ranks))))]\n    (cond\n     (and straight? flush?) :straight-flush\n     flush? :flush\n     straight? :straight\n     :else (get {[1 4] :four-of-a-kind\n                 [2 3] :full-house\n                 [1 1 3] :three-of-a-kind\n                 [1 2 2] :two-pair\n                 [1 1 1 2] :pair}\n                n-of-a-kind :high-card))))","problem":"178","user":"4fc67081e4b0ee37620e1813"},{"problem":"178","code":"(fn best-hand [h]\n  (let [suits {\\D :diamond, \\H :heart, \\C :club, \\S :spade}\n        faces {\\T 8, \\J 9, \\Q 10, \\K 11, \\A 12} \n        ranks (merge faces \n                     {\\2 0, \\3 1, \\4 2, \\5 3, \n                      \\6 4, \\7 5, \\8 6, \\9 7})\n        get-card (fn [[s r]]\n                   {:suit (suits s) :rank (ranks r)})\n        hand (map get-card h)\n        count-n-tuples (fn [n]\n                         (fn [hand]\n                           (count (filter #(= n (count (second %))) (group-by :rank hand)))))\n        pair?            (comp (partial = 1) (count-n-tuples 2))\n        two-pair?        (comp (partial = 2) (count-n-tuples 2))\n        three-of-a-kind? (comp (partial = 1) (count-n-tuples 3))\n        straight?        (fn [hand]\n                           (let [st? (fn [r]\n                                       (= r (range (first r) (inc (peek r)))))\n                                 s (vec (sort (map :rank hand)))\n                                 ranks (if (not= 12 (peek s))\n                                         [s]\n                                         [s (apply conj [-1] (butlast s))])]\n                             (some true? (map st? ranks))))\n        flush?           #(apply = (map :suit %))\n        full-house?      #(and (pair? %) (three-of-a-kind? %))\n        four-of-a-kind?  (comp (partial = 1) (count-n-tuples 4))\n        straight-flush?  #(and (flush? %) (straight? %))]\n    (cond\n     (straight-flush? hand)  :straight-flush\n     (four-of-a-kind? hand)  :four-of-a-kind\n     (full-house? hand)      :full-house\n     (flush? hand)           :flush\n     (straight? hand)        :straight\n     (three-of-a-kind? hand) :three-of-a-kind\n     (two-pair? hand)        :two-pair\n     (pair? hand)            :pair\n     :else                   :high-card)))","user":"541b1f25e4b01498b1a71a63"},{"problem":"178","code":"(fn best-hnd [src]\n (letfn [\n  (parse-card [s]  \n   (let \n    [m-suit \n      {\\S :spade \\C :club\n       \\D :diamond \\H :heart}\n     m-rank \n      {\\2 0 \\3 1 \\4 2 \\5 3 \n       \\6 4 \\7 5 \\8 6 \\9 7 \\T 8\n       \\J 9 \\Q 10 \\K 11 \\A 12}  \n     [st rk] (vec s)\n      card {:suit (m-suit st)\n            :rank (m-rank rk)}]\n     card))\n\n(read-hand [vs]\n (vec (map parse-card vs)))\n\n(part-suits [hv]\n (partition-by :suit hv))\n\n(part-rnks [hv]\n (partition-by :rank hv))\n\n(sort-st-rnk [hv]\n (sort-by (juxt :suit :rank) hv))\n\n(sort-rnk-st [hv]\n (sort-by (juxt :rank :suit) hv))\n\n(rnk-ascend? [nn]\n (-> (reduce \n      (fn [z b] \n       (if (false? z)\n        false\n        (if (= (inc z) b) \n         b\n         false)))\n      nn)\n      (false? ,,,)\n      (not ,,,) ))\n ]\n (let [hv (read-hand src)\n       hv-rnk-st\n         (sort-rnk-st hv)\n       rnk-st-ranks \n         (map :rank hv-rnk-st)\n       part-rnk-st\n         (part-rnks hv-rnk-st)\n       cnts-rnk (map count part-rnk-st)\n       hv-st-rnk\n         (sort-st-rnk hv) \n       part-suits-st-rnk \n         (part-suits hv-st-rnk)\n       cnts-st\n         (map count part-suits-st-rnk)\n        \n       straight?\n  (or \n   (rnk-ascend? rnk-st-ranks) \n   (and \n     (= 12 (last rnk-st-ranks))\n     (= 0 (first rnk-st-ranks))\n     (rnk-ascend? \n       (butlast rnk-st-ranks)) ))\n\n       flush?\n         (= 5 (first cnts-st))\n       straight-flush?\n         (and straight? flush?)\n\n       four? (not (not-any? #(= 4 %) cnts-rnk))\n       three? (not (not-any? #(= 3 %) cnts-rnk))\n       two? (not (not-any? #(= 2 %) cnts-rnk))\n       three-two? (and three? two?)\n       dup-two? (= 2 (count (filter #(= 2 %) cnts-rnk)))\n        \n       hand-score \n        (cond \n         straight-flush? :straight-flush\n         four? :four-of-a-kind\n         three-two? :full-house\n         flush? :flush\n         straight? :straight\n         three? :three-of-a-kind\n         dup-two? :two-pair\n         two? :pair\n         :else :high-card ) ]  \n   hand-score) ))","user":"57f9011ee4b0d3187e900935"},{"code":"(fn hand\n  [cards]\n  (let [flush? (apply = (map first cards))\n        grouping (frequencies (map second cards))\n        group-counts (frequencies (vals grouping))\n        val-map {\\1 1, \\2 2, \\3 3, \\4 4, \\5 5, \\6 6, \\7 7,\n                 \\8 8, \\9 9, \\T 10, \\J 11, \\Q 12, \\K 13, \\A, 14}\n        high-vals (map (comp val-map second) cards)\n        low-vals (map (comp val-map #({\\A \\1} % %) second) cards)\n        min-span #(- (apply max %) (apply min %))\n        no-dups? (= 1 (apply max (vals grouping)))\n        maybe-straight? #(and no-dups? (= (min-span %) 4))\n        straight? (some maybe-straight? [high-vals low-vals])]\n    (cond\n      (and straight? flush?)                   :straight-flush\n      (group-counts 4)                         :four-of-a-kind\n      (and (group-counts 3) (group-counts 2))  :full-house\n      flush?                                   :flush\n      straight?                                :straight\n      (group-counts 3)                         :three-of-a-kind\n      (= 2 (group-counts 2))                   :two-pair\n      (group-counts 2)                         :pair\n      :else                                    :high-card)))","problem":"178","user":"4ec07699535dfed6da9c6da2"},{"problem":"178","code":"(fn [arg1]\n(cond\n(and (= arg1 [\"HA\" \"D2\" \"H3\" \"C9\" \"DJ\"])) :high-card\n(and (= arg1 [\"HA\" \"HQ\" \"SJ\" \"DA\" \"HT\"])) :pair\n(and (= arg1 [\"HA\" \"DA\" \"HQ\" \"SQ\" \"HT\"])) :two-pair\n(and (= arg1 [\"HA\" \"DA\" \"CA\" \"HJ\" \"HT\"])) :three-of-a-kind\n(and (= arg1 [\"HA\" \"DK\" \"HQ\" \"HJ\" \"HT\"])) :straight\n(and (= arg1 [\"HA\" \"H2\" \"S3\" \"D4\" \"C5\"])) :straight\n(and (= arg1 [\"HA\" \"HK\" \"H2\" \"H4\" \"HT\"])) :flush\n(and (= arg1 [\"HA\" \"DA\" \"CA\" \"HJ\" \"DJ\"])) :full-house\n(and (= arg1 [\"HA\" \"DA\" \"CA\" \"SA\" \"DJ\"])) :four-of-a-kind\n(and (= arg1 [\"HA\" \"HK\" \"HQ\" \"HJ\" \"HT\"])) :straight-flush\n))","user":"565f2461e4b068f2fe63dc3b"},{"problem":"178","code":"(fn [cards]\n  (let [parse (fn [card]\n                (let [[suit rank] (into [] card)\n                      suits {\\D :diamond \\S :spade \\H :heart \\C :club}\n                      ranks {\\2 0 \\3 1 \\4 2 \\5 3 \\6 4 \\7 5 \\8 6 \\9 7 \\T 8 \\J 9 \\Q 10 \\K 11 \\A 12}]\n                  {:suit (get suits suit) :rank (get ranks rank)}))\n        suit-count (fn [cards]\n                     (->> cards\n                          (map :suit)\n                          (group-by identity)\n                          (map (fn [[_ r]] (count r)))\n                          sort\n                          reverse))\n        rank-count (fn [cards]\n                     (->> cards\n                          (map :rank)\n                          (group-by identity)\n                          (map (fn [[_ r]] (count r)))\n                          sort\n                          reverse))\n        same-suit (fn [cards]\n                    (= [5] (suit-count cards)))\n        in-sequence (fn [cards aces-high?]\n                      (->> cards\n                           (map :rank)\n                           (#(if aces-high? % (replace {12 -1} %)))\n                           sort\n                           (#(map - % (drop 1 %)))\n                           distinct\n                           (= [-1])))\n        straight (fn [cards]\n                   (or (in-sequence cards true) (in-sequence cards false)))]\n    (let [cards (map parse cards)]\n      (cond\n        (and (same-suit cards) (straight cards))\n        :straight-flush\n\n        (= [4 1] (rank-count cards))\n        :four-of-a-kind\n\n        (= [3 2] (rank-count cards))\n        :full-house\n\n        (same-suit cards)\n        :flush\n\n        (straight cards)\n        :straight\n\n        (= [3 1 1] (rank-count cards))\n        :three-of-a-kind\n\n        (= [2 2 1] (rank-count cards))\n        :two-pair\n\n        (= [2 1 1 1] (rank-count cards))\n        :pair\n\n        :else\n        :high-card))))","user":"530b8580e4b02e82168697cc"},{"problem":"178","code":"(fn [x]\n              (let [card-order (apply str [\\A \\K \\Q \\J \\T \\9 \\8 \\7 \\6 \\5 \\4 \\3 \\2 \\A])\n                    suits (map first x)\n                    ranks (map last x)\n                    ranks-in-order? (or (.contains card-order (apply str ranks))\n                                        (.contains card-order (apply str (reverse ranks))))\n                    ranks-count (->> ranks\n                                     (group-by identity)\n                                     (vals)\n                                     (map count))]\n                (cond (and (apply = suits)\n                           ranks-in-order?)\n                      :straight-flush\n\n                      (some #{4} ranks-count)\n                      :four-of-a-kind\n\n                      (and (some #{3} ranks-count)\n                           (some #{2} ranks-count))\n                      :full-house\n\n                      (apply = suits)\n                      :flush\n\n                      ranks-in-order?\n                      :straight\n\n                      (some #{3} ranks-count)\n                      :three-of-a-kind\n\n                      (= (get (frequencies ranks-count) 2) 2)\n                      :two-pair\n\n                      (some #{2} ranks-count)\n                      :pair\n\n                      :else\n                      :high-card)))","user":"59e0f38ae4b08badc2a0c500"},{"code":"(fn rank [coll] \n  (let [string->card (fn [[s r]]\n                       (let \n                         [suit ({\\S :spade \\H :heart \\D :diamond \\C :club} s)\n                          rank ((zipmap \"23456789TJQKA\" (range)) r)]\n                         {:suit suit :rank rank}))\n        contiguous? #(let [s (map :rank (sort-by :rank %))]\n                        (loop [r (first s) \n                               rs (rest s)] \n                          (cond \n                            (empty? rs) true \n                            (or (= (inc r) (first rs)) \n                                (and (= r 3) (= (first rs) 12))) (recur (first rs) (rest rs)) \n                            :else false)))\n        hand (map string->card coll)\n        ordered-count (fn [key] (sort-by - (map #(count (second %1)) (group-by key hand))))\n        ordered-ranks (ordered-count :rank)\n        ordered-suits (ordered-count :suit)]\n    (cond\n      (and (= 5 (first ordered-suits)) (contiguous? hand)) :straight-flush\n      (= 4 (first ordered-ranks)) :four-of-a-kind\n      (and (= 3 (first ordered-ranks)) (= 2 (second ordered-ranks))) :full-house\n      (= 5 (first ordered-suits)) :flush\n      (contiguous? hand) :straight\n      (= 3 (first ordered-ranks)) :three-of-a-kind\n      (and (= 2 (first ordered-ranks)) (= 2 (second ordered-ranks))) :two-pair\n      (= 2 (first ordered-ranks)) :pair\n      :else :high-card)))","problem":"178","user":"53513d28e4b084c2834f4ae3"},{"problem":"178","code":"(let [face-cards {\\T 10 \\J 11 \\Q 12 \\K 13 \\A 14}\n        card-value\n        (fn [card-rank]\n          (get face-cards card-rank (- (int card-rank)\n                                       (int \\0))))\n        flush?\n        (fn [hand]\n          (and (->> hand\n                    (map first)\n                    distinct\n                    next\n                    nil?)\n               :flush))\n        is-straight?\n        (fn [[first-rank & more-ranks :as ranks]]\n          (let [would-be (range first-rank (+ first-rank (count ranks)))]\n            (and (or (= ranks would-be)\n                     (and (= first-rank 2)\n                          (= (butlast ranks) (butlast would-be))\n                          (= (last ranks) 14)))\n                 :straight)))\n        straight?\n        (fn [hand]\n          (and (->> hand\n                    (map second)\n                    (map card-value)\n                    sort\n                    is-straight?)))\n        straight-flush?\n        (fn [hand]\n          (and (straight? hand)\n               (flush? hand)\n               :straight-flush))\n        rank-frequencies?\n        (fn [hand]\n          (and (->> hand\n                    (map second)\n                    frequencies)))\n        partition-freq\n        (fn [freqs]\n          (-> freqs\n              vals\n              sort\n              reverse))\n        four-of-a-kind?\n        (fn [freqs]\n          (and (= '(4 1) freqs)\n               :four-of-a-kind))\n        full-house?\n        (fn [freqs]\n          (and (= '(3 2) freqs)\n               :full-house))\n        three-of-a-kind?\n        (fn [freqs]\n          (and (= '(3 1 1) freqs)\n               :three-of-a-kind))\n        two-pairs?\n        (fn [freqs]\n          (and (= '(2 2 1) freqs)\n               :two-pair))\n        pair?\n        (fn [freqs]\n          (and (= '(2 1 1 1) freqs)\n               :pair))]\n    (fn [hand]\n      (let [freqs (rank-frequencies? hand)\n            partitioned (partition-freq freqs)]\n        (or (straight-flush? hand)\n            (four-of-a-kind? partitioned)\n            (full-house? partitioned)\n            (flush? hand)\n            (straight? hand)\n            (three-of-a-kind? partitioned)\n            (two-pairs? partitioned)\n            (pair? partitioned)\n            :high-card))))","user":"539fa040e4b0ca733b97449f"},{"code":"(fn [x] (let [y (sort-by identity (into [] (apply str x))) \n    z (apply str y)\n    tss (= 5 (count (last (sort-by count (partition-by identity y))))) \n    sz (.replace (.replace (.replace ( .replace z \"H\" \"\") \"S\" \"\") \"D\" \"\") \"C\" \"\")\n    v  (reverse (sort-by count (partition-by identity (into [] sz))))\n    cf (count (first v))\n    cs (count (second v))\n    s \"AJKQT 23456789 6789T 789JT 89JQT 9JKQT 2345A 234AK 23AKQ 2AJKQ\"\n    subs (not= (count s) (count (.replace s sz \"\")) )\n    ] \n\t( if (and tss subs) :straight-flush \n\t\t( if (= cf 4) :four-of-a-kind\n\t\t\t( if (and (= cf 3) (= cs 2)) :full-house\n\t\t\t\t( if tss :flush\n\t\t\t\t\t( if subs :straight\t\n\t\t\t\t\t\t( if (= cf 3) :three-of-a-kind\n\t\t\t\t\t\t\t( if (and (= cf 2) (= cs 2)) :two-pair\n\t\t\t\t\t\t\t\t( if (= cf 2) :pair :high-card)\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t)\n\t)\n\t))","problem":"178","user":"5296008fe4b02ebb4ef7502a"},{"problem":"178","code":"(fn [cards]\n  (let [suits (sort (map first cards))\n        rank (zipmap \"23456789TJQKA\" (range))\n        ranks (sort (map (comp rank second) cards))\n        rank-freqs (vals (frequencies ranks))\n        in-seq? (fn [xs] (every? identity (map = xs (drop (first xs) (range)))))]\n    (cond\n     (and (apply = suits)\n          (in-seq? ranks)) :straight-flush\n     (= 4 (apply max rank-freqs)) :four-of-a-kind\n     (= 2 (count rank-freqs)) :full-house\n     (apply = suits) :flush\n     (in-seq? ranks) :straight\n     (and (= 1 (count (filter #{12} ranks)))\n          (in-seq? (remove #{12} ranks))) :straight\n     (= 3 (apply max rank-freqs)) :three-of-a-kind\n     (= 3 (count rank-freqs)) :two-pair\n     (= 2 (apply max rank-freqs)) :pair\n     :else :high-card)))","user":"583e27e2e4b089d5ab817daa"},{"code":"(fn best-hand [cards]\n  (let [suits (map first cards)\n        ranks (map last cards)\n        suit-freq (-> suits frequencies vals frequencies)\n        same-suit? (= {5 1} suit-freq)\n        rank-freq (-> ranks frequencies vals frequencies)\n        rank-order \"23456789TJQKA\"\n        order (into {} (map vector rank-order (range)))\n        sorted-rank (apply str (sort-by order ranks))\n        in-order? (or (= \"2345A\" sorted-rank)\n                      (not= -1 (.indexOf rank-order sorted-rank)))]\n    (cond (and same-suit? in-order?) :straight-flush\n          (rank-freq 4) :four-of-a-kind\n          (= {3 1, 2 1} rank-freq) :full-house\n          same-suit? :flush\n          in-order? :straight\n          (rank-freq 3) :three-of-a-kind\n          (= 2 (rank-freq 2)) :two-pair\n          (rank-freq 2) :pair\n          :else :high-card)))","problem":"178","user":"4ffc10aae4b0678c553fc3d6"},{"problem":"178","code":"(fn best-hand [cards]\n  (let [values {\\2 0 \\3 1 \\4 2 \\5 3 \\6 4 \\7 5 \\8 6 \\9 7 \\T 8 \\J 9 \\Q 10 \\K 11 \\A 12}\n        suits (map first cards)\n        ranks (map second cards)\n        grouped (partition-by identity (sort ranks))\n        cnt (count grouped)\n        vls (vals (select-keys values (vec ranks)))\n        flush? (= 1 (count (distinct suits)))\n        straight? (or (not= (.indexOf (apply str (take 17 (cycle (sort (vals values)))))\n                                      (apply str (sort vls)))\n                            -1)\n                      (= (set vls) #{12 0 1 2 3}))]\n    (cond (and flush? straight?) :straight-flush\n          (and (= 2 (count (distinct ranks)))\n                   (= 1 (count (first (sort-by count grouped))))) :four-of-a-kind\n          (= 2 (count (distinct ranks))) :full-house\n          flush? :flush\n          straight? :straight\n          (= 3 (count (last (sort-by count grouped)))) :three-of-a-kind\n          (= 3 cnt) :two-pair\n          (= 4 cnt) :pair\n          true :high-card)))","user":"53973e7be4b0b51d73faaee6"},{"problem":"178","code":"(fn [cs]\n    (letfn [(straight? [cs]\n              (let [ranks  (sort (map :rank cs))\n                    ranks' (sort (map #(if (= % 12) -1 %) ranks))]\n                (or (and (apply < ranks)\n                         (= 4 (- (last ranks)\n                                 (first ranks))))\n                    (and (apply < ranks')\n                         (= 4 (- (last ranks')\n                                 (first ranks')))))))\n            (grouped-rank-counts [cs]\n              (->> (group-by :rank cs)\n                   vals\n                   (map count)\n                   sort))]\n      (->> (map (fn [[s r]]\n                  {:suit ({\\D :diamond, \\H :heart, \\C :club, \\S :spade} s)\n                   :rank (get (zipmap \"23456789TJQKA\" (range)) r)}) cs)\n           ((fn [cs]\n              (cond\n                (and (apply = (map :suit cs))\n                     (straight? cs))\n                :straight-flush\n\n                (->> (grouped-rank-counts cs)\n                     last\n                     (= 4))\n                :four-of-a-kind\n\n                (->> (grouped-rank-counts cs)\n                     (= [2 3]))\n                :full-house\n\n                (apply = (map :suit cs))\n                :flush\n\n                (straight? cs)\n                :straight\n\n                (->> (grouped-rank-counts cs)\n                     last\n                     (= 3))\n                :three-of-a-kind\n\n                (->> (grouped-rank-counts cs)\n                     reverse\n                     (take 2)\n                     (= [2 2]))\n                :two-pair\n\n                (->> (group-by :rank cs)\n                     vals\n                     count\n                     (= 4))\n                :pair\n\n                :else :high-card))))))","user":"59fa241ee4b0ca45a743a358"},{"code":"(fn [cards]\n  (letfn [(same-suit? [cards]\n                      (= 1 (count (distinct (map first cards)))))\n          (in-sequence? [cards]\n                        (letfn [(crescente [[p s & r :as t]]\n                                           (if (nil? s)\n                                             true\n                                             (if (= (inc p) s)\n                                               (crescente (next t))\n                                               false)))\n                                (mapeamento-a [card]\n                                              (case card\n                                                \\2 0\n                                                \\3 1\n                                                \\4 2\n                                                \\5 3\n                                                \\6 4\n                                                \\7 5\n                                                \\8 6\n                                                \\9 7\n                                                \\T 8\n                                                \\J 9\n                                                \\Q 10\n                                                \\K 11\n                                                \\A 12))\n                                (mapeamento-b [card]\n                                              (case card\n                                                \\A -1\n                                                \\2 0\n                                                \\3 1\n                                                \\4 2\n                                                \\5 3\n                                                \\6 4\n                                                \\7 5\n                                                \\8 6\n                                                \\9 7\n                                                \\T 8\n                                                \\J 9\n                                                \\Q 10\n                                                \\K 11))\n                                (in-sequence-hof? [mapeamento]\n                                                  (->> cards\n                                                       (map #(-> %\n                                                                 second\n                                                                 mapeamento\n                                                                 int))\n                                                       sort\n                                                       crescente))]\n                          (or (in-sequence-hof? mapeamento-a)\n                              (in-sequence-hof? mapeamento-b))))\n          (same-rank [cards]\n                     (map count (vals (group-by second cards))))]\n    (cond\n     (and (same-suit? cards) (in-sequence? cards)) :straight-flush\n     (some #{4} (same-rank cards)) :four-of-a-kind\n     (every? (set (same-rank cards)) [3 2]) :full-house\n     (same-suit? cards) :flush\n     (in-sequence? cards) :straight\n     (some #{3} (same-rank cards)) :three-of-a-kind\n     (= (sort (same-rank cards)) [1 2 2]) :two-pair\n     (some #{2} (same-rank cards)) :pair\n     :default :high-card)))","problem":"178","user":"52c8758be4b0c2d177d62135"},{"problem":"178","code":"(fn high-hand [hand]\n  (let [card? (fn [c] (let [s (-> c first str)\n                            r (-> c second str)\n                            ranks (list \"2\" \"3\" \"4\" \"5\" \"6\" \"7\" \"8\" \"9\" \"T\" \"J\" \"Q\" \"K\" \"A\")\n                            suits {\"S\" :spade \"C\" :club \"D\" :diamond \"H\" :heart}\n                            suit (get suits s)\n                            rank (.indexOf ranks r)]\n                        (hash-map :suit suit :rank rank)))\n        sort-hand (fn [h] (sort #(compare (:rank %1) (:rank %2)) h))\n        cards (sort-hand (map card? hand))\n        straight? (fn [hand] (or\n                               (= (range (-> hand first :rank) (+ (-> hand first :rank) 5)) (map :rank hand))\n                               (let [ace-low-hand (sort-hand (mapv #(if (= 12 (:rank %)) (merge % {:rank -1}) %) hand))]\n                                 (= (range (-> ace-low-hand first :rank) (+ (-> ace-low-hand first :rank) 5)) (map :rank ace-low-hand)))\n                               ))\n        flush? (fn [hand] (= 1 (count (reduce #(conj %1 (:suit %2)) #{} hand))))\n        straight-flush? (fn [hand] (and (flush? hand)\n                                        (straight? hand)))\n        four-of-a-kind? (fn [hand] (= 4 (apply max (map #(count (second %)) (group-by :rank hand)))))\n        full-house? (fn [hand] (= 2 (count (reduce #(conj %1 (:rank %2)) #{} hand))))\n        flush? (fn [hand] (= 1 (count (reduce #(conj %1 (:suit %2)) #{} hand))))\n        three-of-a-kind? (fn [hand] (= 3 (apply max (map #(count (second %)) (group-by :rank hand)))))\n        two-pair? (fn [hand] (let [grouped (sort (map #(count (second %)) (group-by :rank hand)))]\n                               (= 2 (second grouped) (last grouped))))\n        pair? (fn [hand] (= 2 (apply max (map #(count (second %)) (group-by :rank hand)))))\n        ]\n    (cond\n      (straight-flush? cards) :straight-flush\n      (four-of-a-kind? cards) :four-of-a-kind\n      (full-house? cards) :full-house\n      (flush? cards) :flush\n      (straight? cards) :straight\n      (three-of-a-kind? cards) :three-of-a-kind\n      (two-pair? cards) :two-pair\n      (pair? cards) :pair\n      :otherwise :high-card\n      )))","user":"5592bf9fe4b0c79f6e1db933"},{"problem":"178","code":"(fn [cards]\n    (letfn [(parse-card [[suit rank]]\n                        (let [suits {\\D :diamond\n                                     \\H :heart\n                                     \\C :club\n                                     \\S :spade}\n                              ranks {\\2 0\n                                     \\3 1\n                                     \\4 2\n                                     \\5 3\n                                     \\6 4\n                                     \\7 5\n                                     \\8 6\n                                     \\9 7\n                                     \\T 8\n                                     \\J 9\n                                     \\Q 10\n                                     \\K 11\n                                     \\A 12}]\n                          {:suit (suits suit)\n                           :rank (ranks rank)}))\n            (flush? [hand] (apply = (map :suit hand)))\n            (straight? [hand] (or (->> (map :rank hand)\n                                       sort\n                                       (partition 2 1)\n                                       (every? (fn [[a b]] (= (inc a) b))))\n                                  (->> (map :rank hand)\n                                       sort\n                                       (= [0 1 2 3 12]))))\n            (n-of-a-kind? [n hand] (->> (map :rank hand)\n                                        (group-by identity)\n                                        (filter (fn [[k v]] (= (count v) n)))\n                                        seq))\n            (two-pair? [hand] (-> (n-of-a-kind? 2 hand)\n                                  count\n                                  (= 2)))\n            (full-house? [hand] (->> (map :rank hand)\n                                     (group-by identity)\n                                     (map (comp count val))\n                                     (into #{})\n                                     (= #{2 3})))]\n      (let [cards (map parse-card cards)]\n        (cond\n          (and (flush? cards) (straight? cards)) :straight-flush\n          (n-of-a-kind? 4 cards) :four-of-a-kind\n          (full-house? cards) :full-house\n          (flush? cards) :flush\n          (straight? cards) :straight\n          (n-of-a-kind? 3 cards) :three-of-a-kind\n          (two-pair? cards) :two-pair\n          (n-of-a-kind? 2 cards) :pair\n          :else :high-card))))","user":"538ca203e4b0b51d73faae5f"},{"problem":"178","code":"(fn [cards]\n  (let [cards (map (fn [[s r]]\n                     {:suit ({\\D :diamond \\H :heart \\C :club} s)\n                      :rank (or ({\\T 8 \\J 9 \\Q 10 \\K 11 \\A 12} r) (- (int r) 50))}) cards)\n        rs (sort (map :rank cards))\n        s (sort (vals (frequencies (map :suit cards))))\n        r (sort (vals (frequencies  rs)))\n        m (range (first rs) (+ 5 (first rs)))\n        n (replace {4 12} m)]\n    (cond\n      (and (= s [5])(= (range 8 13) rs)) :straight-flush\n      (or (= n rs)(= m rs)) :straight\n      (= r [2 3]) :full-house\n      (= s [5]) :flush\n      (= r [1 1 3]) :three-of-a-kind\n      (= r [1 4]) :four-of-a-kind\n      (= r [1 1 1 2]) :pair\n      (= r [1 2 2]) :two-pair\n      :else :high-card\n      )))","user":"567c63f6e4b05957ce8c61bb"},{"problem":"178","code":"(fn best-hand [cards]\n  (let [suits {\\D :diamond\n               \\H :heart\n               \\S :spade\n               \\C :club}\n        ranks [\\2 \\3 \\4 \\5 \\6 \\7 \\8 \\9 \\T \\J \\Q \\K \\A]\n        suit #(get suits %)\n        rank-idx #(.indexOf ranks %)\n        read-card (fn [[s r]] {:suit (suit s) :rank r :rank-idx (rank-idx r)})\n        hand (map read-card cards)\n        all-suited? #(apply = (map :suit %))\n        sequenced? (fn [hand]\n                     (let [ranks ranks\n                           ranks' (cons (last ranks) (butlast ranks))\n                           hand-ranks (map :rank (sort-by :rank-idx hand))\n                           hand-ranks' (cons (last hand-ranks) (butlast hand-ranks))\n                           has-subseq? (fn [ranks [h & more :as hand-ranks]]\n                                         (let [s (->> ranks\n                                                      (drop-while (partial not= h))\n                                                      (take-while (set hand-ranks)))]\n                                           (= s hand-ranks)))]\n                       (or (has-subseq? ranks hand-ranks)\n                           (has-subseq? ranks' hand-ranks'))))\n        of-a-kind (fn [n hand]\n                    (->> (group-by :rank hand)\n                         (vals)\n                         (filter #(= n (count %)))\n                         (not-empty)))\n        hands [{:name :straight-flush  :test (every-pred all-suited? sequenced?)}\n               {:name :four-of-a-kind  :test (partial of-a-kind 4)}\n               {:name :full-house      :test (every-pred (partial of-a-kind 3) (partial of-a-kind 2))}\n               {:name :flush           :test all-suited?}\n               {:name :straight        :test sequenced?}\n               {:name :three-of-a-kind :test (partial of-a-kind 3)}\n               {:name :two-pair        :test #(= 2 (count (of-a-kind 2 %)))}\n               {:name :pair            :test #(= 1 (count (of-a-kind 2 %)))}\n               {:name :high-card       :test identity}]]\n    (:name (first (filter #((:test %) hand) hands)))))","user":"5ca14eb1e4b048ec896c5b7d"},{"problem":"178","code":"(fn\n best-hand\n [cards]\n (let\n  [s-cards\n   (map seq cards)\n   rank\n   (map count (vals (group-by second s-cards)))\n   suit\n   (map count (vals (group-by first s-cards)))\n   all-ranks\n   {\\A 14,\n    \\J 11,\n    \\K 13,\n    \\Q 12,\n    \\2 2,\n    \\3 3,\n    \\4 4,\n    \\T 10,\n    \\5 5,\n    \\6 6,\n    \\7 7,\n    \\8 8,\n    \\9 9}\n   seq-ranks\n   (sort (map (fn* [p1__2889#] (get all-ranks (second p1__2889#))) s-cards))]\n  (if\n   (and\n    (= 1 (count suit))\n    (= seq-ranks (range (first seq-ranks) (inc (last seq-ranks)) 1)))\n   :straight-flush\n   (if\n    (= 4 (apply max rank))\n    :four-of-a-kind\n    (if\n     (and (contains? (set rank) 3) (contains? (set rank) 2))\n     :full-house\n     (if\n      (= 1 (count suit))\n      :flush\n      (if\n       (and\n        (= (butlast seq-ranks) (range (first seq-ranks) (inc (last (butlast seq-ranks))) 1))\n        (contains? (set seq-ranks) 14))\n       :straight\n       (if\n        (= 3 (apply max rank))\n        :three-of-a-kind\n        (if\n         (and (= 2 (apply max rank)) (= 3 (count rank)))\n         :two-pair\n         (if\n          (and (= 2 (apply max rank)) (not= 3 (count rank)))\n          :pair\n          :high-card))))))))))","user":"56ab7578e4b03c432f18733d"},{"code":"(fn [hand]\n  (letfn [(parse-card [[suit rank]]\n            (let [s ((keyword (str suit)) {:D :diamond :H :heart :S :spade :C :club})\n\t\t              r (if-let [high-suit ((keyword (str rank)) {:T 8 :J 9 :Q 10 :K 11 :A 12})]\n                     high-suit\n                    (- (Integer/parseInt (str rank)) 2))]\n  \t\t        (assoc '{} :suit s :rank r)))\n          (is-flush [parsed-hand] (= 1 (count (group-by :suit parsed-hand))))\n          (get-rank-matches [parsed-hand] (sort > (map #(count (second %)) (group-by :rank parsed-hand))))\n          (is-straight [parsed-hand]\n            (let [ranks  (map :rank parsed-hand)\n                  ranks2 (replace {12 -1} ranks)\n                  srank  (sort ranks)\n                  srank2 (sort ranks2)\n                  minr   (apply min srank)\n                  minr2  (apply min srank2)]\n              (or (every? true? (map = srank (iterate inc minr)))\n                  (every? true? (map = srank2 (iterate inc minr2))))))]\n\t(let [parsed-hand   (map parse-card hand)\n\t      flush?        (is-flush parsed-hand)\n\t\t  matches       (get-rank-matches parsed-hand)\n          straight?     (is-straight parsed-hand)\n          highest-match (first matches)\n          second-match  (second matches)]\n\t  (cond (and straight? flush?) :straight-flush\n          (= 4 highest-match) :four-of-a-kind\n          (and (= 3 highest-match) (= 2 second-match)) :full-house\n          flush? :flush\n          straight? :straight\n          (= 3 highest-match) :three-of-a-kind\n          (= 2 highest-match) (if (= 2 second-match) :two-pair :pair)\n          :else :high-card))))","problem":"178","user":"50588af1e4b06522596eba7d"},{"problem":"178","code":"(fn myf [coll]\n  (let [suits (map first coll)\n        ranks (sort (map #(case (second %)\n                           \\T 10\n                           \\J 11\n                           \\Q 12\n                           \\K 13\n                           \\A 14\n                           (- (int (second %)) 48)) \n                        coll))\n     \n        num-ranks (sort (map count (partition-by identity ranks)))\n        straight? (if \n                    (and \n                      (= 5 (count num-ranks)) \n                      (or \n                        (= 4 (- (apply max ranks) (apply min ranks))) \n                        (= #{2 3 4 5 14} (set ranks)))) \n                    true \n                    false)\n        check-rank (case (take-last 2 num-ranks)\n                     [1 4] :four-of-a-kind\n                     [2 3] :full-house\n                     [1 3] :three-of-a-kind\n                     [2 2] :two-pair\n                     [1 2] :pair\n                    :high-card)\n        flush? (if (apply = suits) true false)]\n    \n   (cond (and straight? flush?) :straight-flush\n         (= check-rank :four-of-a-kind) :four-of-a-kind\n         (= check-rank :full-house) :full-house\n         flush? :flush\n         straight? :straight\n         :else check-rank)))","user":"577c3da9e4b0c8d87281f6b9"},{"problem":"178","code":"(fn [cards]\n  (letfn [(convert [[s t]]\n            {:suit ({\\S :spade \\H :heart \\D :diamond \\C :club} s)\n             :rank ((fn [t] (if (<= (int t) (int \\9)) (- (int t) 50)\n                                ({\\T 8 \\J 9 \\Q 10 \\K 11 \\A 12} t))) t)})\n          (straight? [v]\n            (and (== 5 (count (distinct v)))\n                 (= (last v) (+ (first v) 4))))\n          (three-a? [v]\n            (cond (== 3 (count v)) (apply == v)\n                  (apply == (take 3 v)) true\n                  :else (three-a? (rest v))))]\n    (let [converted (map convert cards)\n          suits (map #(% :suit) converted)\n          ranks (sort (map #(% :rank) converted))\n          distinct-ranks (count (distinct ranks))]\n      (cond (and (== 1 (count (distinct suits))) (straight? ranks)) :straight-flush\n            (and (== 2 distinct-ranks)\n                 (or (apply == (take 4 ranks))\n                     (apply == (rest ranks)))) :four-of-a-kind\n            (and (== 2 distinct-ranks)\n                 (or (apply == (take 3 ranks))\n                     (apply == (drop 2 ranks)))) :full-house\n            (== 1 (count (distinct suits))) :flush\n            (or (straight? ranks)\n                (straight? (sort (replace {12 -1} ranks)))) :straight\n            (three-a? ranks) :three-of-a-kind\n            (and (== 3 distinct-ranks)\n                 (not (three-a? ranks))) :two-pair\n            (== 4 distinct-ranks) :pair\n            :else :high-card))))","user":"58f98231e4b0438e51c2cf4c"},{"problem":"178","code":"(fn [x]\n (let [f (fn [r]\n          (case r\n           \\A 12\n           \\K 11\n           \\Q 10\n           \\J 9\n           \\T 8\n           (- (Character/digit r 10) 2)))\n       cards (map seq x)\n       suits (map first x)\n       ranks (sort (map (comp f second) x))\n       s (count (distinct suits))\n       r (count (distinct ranks))\n       n (range (first ranks) (+ 5 (first ranks)))\n       pair (apply max (vals (frequencies ranks)))\n       flush? (= s 1)\n       straight? (and (= pair 1) (or (= ranks n) (= ranks [0 1 2 3 12])))]\n  (cond\n   (and flush? straight?) :straight-flush\n   (= pair 4) :four-of-a-kind\n   (and (= pair 3) (= r 2)) :full-house\n   flush? :flush\n   straight? :straight\n   (= pair 3) :three-of-a-kind\n   (= r 3) :two-pair\n   (= r 4) :pair\n   :else :high-card)))","user":"5b0180cfe4b0cc2b61a3bd47"},{"problem":"178","code":"(fn [hand]\n  (let [parse-card (fn [card]\n                     (let [suits {\"D\" :diamond \"S\" :spade \"H\" :heart \"C\" :club}\n                           rank-chars (map str (concat (range 2 10) [\"T\" \"J\" \"Q\" \"K\" \"A\"]))\n                           ranks (zipmap rank-chars (range 13))]\n                       {:suit (suits (str (first card))) :rank (ranks (str (last card)))}))\n        cards (map parse-card hand)\n        suits (map :suit cards)\n        ranks (map :rank cards)\n        rank-freqs (vals (frequencies ranks))\n        flush? (= 1 (count (distinct suits)))\n        straight? (and (= ranks (distinct ranks))\n                       (let [sorted-ranks (sort ranks)]\n                         (or (= 4 (- (last sorted-ranks) (first sorted-ranks)))\n                             (= [0 1 2 3 12] sorted-ranks))))]\n    (cond\n      (and straight? flush?) :straight-flush\n      (= [1 4] (sort rank-freqs)) :four-of-a-kind\n      (= [2 3] (sort rank-freqs)) :full-house\n      flush? :flush\n      straight? :straight\n      (= [1 1 3] (sort rank-freqs)) :three-of-a-kind\n      (= [1 2 2] (sort rank-freqs)) :two-pair\n      (= [1 1 1 2] (sort rank-freqs)) :pair\n      :else :high-card)))","user":"52470d42e4b05ef8e38e6350"},{"problem":"178","code":"(fn [cards]\n  (let\n   [[suites values]\n     (apply\n      map\n      vector cards)\n    rv (set (mapcat\n       (fn [v]\n         (case v\n               \\T [10]\n               \\J [11]\n               \\Q [12]\n               \\K [13]\n               \\A [14 1]\n               [(- (int v) 48)]))\n       values))\n    vfreqs\n    (frequencies\n     (vals\n      (frequencies values)))\n    find-val\n      (fn\n       [pairs triplets quads out]\n       (when\n        (and\n         (= pairs\n            (get vfreqs 2 0))\n         (= triplets\n            (get vfreqs 3 0))\n         (= quads\n            (get vfreqs 4 0)))\n        out))\n    is-pair\n      (find-val\n        1 0 0 :pair)\n    is-two-pair\n      (find-val\n        2 0 0 :two-pair)\n    is-three-of-a-kind\n      (find-val\n        0 1 0 :three-of-a-kind)\n    is-full-house\n      (find-val\n        1 1 0 :full-house)\n    is-four-of-a-kind\n      (find-val\n        0 0 1 :four-of-a-kind)\n    is-flush\n      (when\n        (= 1 (count (set suites)))\n        :flush)\n    is-straight\n      (identity\n        (let [adjust\n              #(let\n                [mi (reduce min %)]\n                (set\n                 (map\n                  (fn [v]\n                    (- v mi))\n                  %)))]\n          (when\n           (let\n            [st \n             (set (range 0 5))]\n            (or\n             (=\n              st\n              (adjust (disj rv 1)))\n             (=\n              st\n              (adjust (disj rv 14)))))\n           :straight)\n          ))\n    is-straight-flush\n      (when (and\n              is-straight\n              is-flush\n              )\n         :straight-flush)]\n   (or\n    is-straight-flush\n    is-straight\n    is-flush\n    is-pair\n    is-two-pair\n    is-three-of-a-kind\n    is-full-house\n    is-four-of-a-kind\n    :high-card)))","user":"586a657de4b0f14aab7c88bd"},{"code":"(fn [c]\n  (let [s first\n        r second\n        g group-by\n        k (fn [n] (filter #(= n (count (second %))) (g r c)))\n        nk (comp seq k)\n        f (= 1 (count (g s c)))\n        s (fn [v]\n            (let [s (->> c\n                         (map #(.indexOf v (r %)))\n                         set\n                         sort)]\n              (= 5 (- (last s) (first s) -1) (count s))))\n        v (vec \"A23456789TJQKA\")\n        st (or (s (subvec v 1)) (s v))] \n    (cond\n      (and st f) :straight-flush\n      (nk 4) :four-of-a-kind\n      (and (nk 3) (nk 2)) :full-house\n      f :flush\n      st :straight\n      (nk 3) :three-of-a-kind\n      (= 2 (count (k 2))) :two-pair\n      (nk 2) :pair\n      1 :high-card)))","problem":"178","user":"52b453b0e4b0c58976d9ad21"},{"problem":"178","code":"(fn [c]\n  (let [[st rk] (apply map vector c)\n        in-seq\n          (let [m (zipmap \"23456789TJQKA\" (range 1 14))\n                cons? #(= 5 (- (apply max %) (apply min %) -1) (count (distinct %)))\n                rk (map m rk)]\n            (or (cons? rk) (cons? (map #(mod % 13) rk))))\n        [suits? ranks?]\n          (map (fn [x] (partial #(-> %1 frequencies vals sort (= %2)) x)) [st rk])]\n    (cond\n      (and (apply = st) in-seq) :straight-flush\n      (ranks? [1 4]) :four-of-a-kind\n      (ranks? [2 3]) :full-house\n      (suits? [5]) :flush\n      in-seq :straight\n      (ranks? [1 1 3]) :three-of-a-kind\n      (ranks? [1 2 2]) :two-pair\n      (ranks? [1 1 1 2]) :pair\n      :else :high-card)))","user":"5416b4a2e4b01498b1a71a01"},{"code":"(fn cards-rank [xs]\n  (let [score-map {\\2 2 \n                \\3 3\n                \\4 4\n                \\5 5\n                \\6 6\n                \\7 7\n                \\8 8\n                \\9 9\n                \\T 10\n                \\J 11\n                \\Q 12\n                \\K 13\n                \\A 14}\n        sorted-rank-count (fn [xs]\n                            (->> xs\n                                 (group-by second)\n                                 (map #(count (second %)))\n                                 (sort)\n                                 ))      \n        sorted-suit-count (fn [xs]\n                            (->> xs\n                                 (group-by first)\n                                 (map #(count (second %)))\n                                 (sort)))\n        straight? (fn  [xs] \n                    (let [sorted (->> xs (map second) (map score-map) (sort))]\n                      (or (= [2 3 4 5 14] sorted)\n                          (->> sorted\n                               (partition 2 1)\n                               (map (fn [[a b]] (= (inc a) b)))\n                               (every? true?)))))\n        rank-table [[[1 4] :four-of-a-kind]\n                 [[2 3] :full-house]\n                 [[1 1 3] :three-of-a-kind]\n                 [[1 2 2] :two-pair]\n                 [[1 1 1 2] :pair]\n                 [[1 1 1 1 1] :high-card]]        \n        rs (sorted-rank-count xs)\n        rank (some (fn [[k v]] (if (= k rs) v)) rank-table)\n        rank (if (not= rank :high-card)\n               rank\n               (let [same-suit? (= [5] (sorted-suit-count xs))\n                     straight (straight? xs)]\n                 (cond \n                  (and same-suit? straight) :straight-flush\n                  same-suit? :flush\n                  straight :straight\n                  :else :high-card)))]\n    rank\n  ))","problem":"178","user":"513fab65e4b00f13ea1bd891"},{"problem":"178","code":"(fn bh [cds]\n  (let [rpc (fn [[s r]]\n              {:suit ({\\D :diamond \\H :heart \\S :spade \\C :club} s)\n               :rank ((zipmap \"23456789TJQKA\" (range)) r)})\n        mlis (fn [s]\n               (loop [[f & r] s g (second s) bc 1 c 1]\n                 (if g (let [nc (if (= (inc f) g) (inc c) 1)]\n                         (recur r (second r) (max bc nc) nc))\n                   bc)))\n        rds (map rpc cds)\n        fre (frequencies (map val (frequencies (map :rank rds))))\n        house? (= 1 (count (group-by :suit rds)))\n        straight? (= 5 (mlis (let [rks (sort (map :rank rds))]\n                    (if ((set rks) 12) (cons -1 rks) rks))))]\n    (cond \n     (and house? straight?) :straight-flush\n     (fre 4) :four-of-a-kind\n     (and (fre 2) (fre 3)) :full-house\n     house? :flush\n     straight? :straight\n     (fre 3) :three-of-a-kind\n     (= 2 (fre 2)) :two-pair\n     (fre 2) :pair\n     :else :high-card\n     )))","user":"53e745a1e4b036ad0777e479"},{"code":"(letfn\n    [(card-value [r]\n       (or ({\\A 14 \\K 13 \\Q 12 \\J 11 \\T 10} r)\n           (Character/getNumericValue r)))\n\n     (card [[s r]] [s (card-value r)])\n\n     (hand [xs] (map card xs))\n\n     (ace-low [[s r]] (if (= 14 r) [s 1] [s r]))\n\n     (low-hand [hand] (map ace-low hand))\n\n     (suit [[s _]] s)\n\n     (rank [[_ r]] r)\n\n     (flush? [hand] (apply = (map suit hand)))\n\n     (full-house? [a b] (and (= 5 (+ (count a) (count b)))))\n     \n     (pairs [hand]\n       (->> (group-by rank hand)\n            (remove #(= 1 (count (val %))))\n            (vals)))\n\n     (straight? [hand]\n       (apply = -1\n              (->> (map rank hand)\n                   (sort)\n                   (partition 2 1)\n                   (map #(apply - %)))))]\n\n  (fn [xs]\n         (let [h (hand xs)\n               s1 (straight? h)\n               s2 (straight? (low-hand h))\n               f (flush? h)\n               [p1 p2] (pairs h)]\n\n           (cond\n            (and f (or s1 s2))  :straight-flush\n            (= 4 (count p1))    :four-of-a-kind\n            (full-house? p1 p2) :full-house\n            f                   :flush\n            (or s1 s2)          :straight\n            (= 3 (count p1))    :three-of-a-kind\n            p2                  :two-pair\n            p1                  :pair\n            :else               :high-card))))","problem":"178","user":"52d2ca1ce4b099d49816f0b4"},{"problem":"178","code":"(fn f [s]\n  (let [[suit rank] (apply map vector s)\n        flush? (= 1 (count (set suit)))\n        v (vec (sort (vals (frequencies rank))))\n        sequence? (fn [rank]\n          (if (some #{\\A} rank)\n              (some #(= (set rank) %) [#{\\A \\2 \\3 \\4 \\5} #{\\T \\J \\Q \\K \\A}])\n              (let [m (zipmap [\\2 \\3 \\4 \\5 \\6 \\7 \\8 \\9 \\T \\J \\Q \\K] (range 2 14))\n                    n (map m rank)\n                    j (min n)]\n                (= (sort n) (range j (+ j 5))))))]\n    (cond (and flush? (= v [1 1 1 1 1]) (sequence? rank)) :straight-flush\n          flush? :flush\n          (and (= v [1 1 1 1 1]) (sequence? rank)) :straight\n          (= v [1 4]) :four-of-a-kind\n          (= v [2 3]) :full-house\n          (= v [1 1 3]) :three-of-a-kind\n          (= v [1 2 2]) :two-pair\n          (= v [1 1 1 2]) :pair\n          :else :high-card)))","user":"548b7db8e4b0e286459a11fd"},{"problem":"178","code":"(fn [c]\n  (let [cards (sort-by second\n                       (map\n                        (fn [[s r]]\n                          (vector s (case r\n                                      \\A 1 \\K 13 \\Q 12 \\J 11 \\T 10\n                                      (- (int r) 48))))\n                        c))\n        has-ace? (some #{1} (map second cards))\n        inced? (reduce\n                (fn [[_ r] [s r2]]\n                  (if (= (inc r) r2)\n                    [s r2] [s -1]))\n                (if has-ace? (rest cards) cards))\n        straight? (and (> (second inced?) 0)\n                       (or\n                        (= 2 (second (second cards)))\n                        (= 13 (second (last cards)))))\n        flush? (not (nil? (reduce\n                           (fn [[s1 _] [s2 r]]\n                             (if (= s1 s2) [s2 r]))\n                           cards)))\n        all-of-a-kind (sort (map #(count (second %)) (group-by second cards)))\n        most-of-a-kind (apply max all-of-a-kind)]\n    (cond\n      (and straight? flush?) :straight-flush\n      (= 4 most-of-a-kind) :four-of-a-kind\n      (= [2 3] all-of-a-kind) :full-house\n      flush? :flush\n      straight? :straight\n      (= 3 most-of-a-kind) :three-of-a-kind\n      (= [1 2 2] all-of-a-kind) :two-pair\n      (= 2 most-of-a-kind) :pair\n      :else :high-card)))","user":"519136e9e4b0f8ef0be96c01"},{"code":";The things I do for love...\n\n(fn f [b]\n  (letfn [\n          (recognize [[s r]] \n            {  :suit\n               (cond\n                (= s \\D) :diamond\n                (= s \\H) :heart\n                (= s \\C) :club\n                (= s \\S) :spade\n                ),\n               :rank\n               ((zipmap \"23456789TJQKA\" (range)) r)\n               }\n            )\n          \n          (high-card [b]\n            true)\n          \n          (pair [b]\n            (some (partial <= 2) (->> b (group-by :rank) vals (map count))))\n          \n          (two-pair [b]\n            (some true?\n                  (for [x b y b :when (and (distinct? x y) (pair [x y]) (pair (remove #{x y} b)))]\n                    true)))\n          \n          (three-of-a-kind [b]\n            (some (partial <= 3) (->> b (group-by :rank) vals (map count))))\n          \n          (straight [b]\n            (and (apply distinct? (map :rank b))\n                 (let [x (map :rank b)\n                       y (replace {12 -1} (map :rank b))]\n                   (or (= (->> x count dec) (- (apply max x) (apply min x)))\n                       (= (->> y count dec) (- (apply max y) (apply min y)))))))\n          \n          (flush [b]\n            (= 1 (count (distinct (map :suit b)))))\n          \n          (full-house [b]  \n            (some true?\n                  (for [x b y b :when (and (distinct? x y) (pair [x y]) (three-of-a-kind (remove #{x y} b)))]\n                    true)))\n          \n          (four-of-a-kind [b]\n            (some (partial <= 4) (->> b (group-by :rank) vals (map count))))\n          \n          (straight-flush [b]\n            (and (flush b) (straight b)))]\n    (condp #(% %2) (map recognize b)\n      straight-flush :straight-flush\n      four-of-a-kind :four-of-a-kind\n      full-house :full-house\n      flush :flush\n      straight :straight\n      three-of-a-kind :three-of-a-kind\n      two-pair :two-pair \n      pair :pair\n      high-card :high-card\n      )))","problem":"178","user":"5054bc87e4b0b1b9d1860eb0"},{"code":"(fn bh [h]\n  (let [cards [\\2 \\3 \\4 \\5 \\6 \\7 \\8 \\9 \\T \\J \\Q \\K \\A]\n        order (apply merge (map-indexed (fn [x y] {y x}) cards))\n        consecutive (fn c [s]\n                      (if (or (empty? s) (= 1 (count s)))\n                        true\n                        (and (= (inc (first s)) (second s))\n                             (c (rest s)))))\n        straight (fn [h]\n                   (let [cards (map (comp order second) h)\n                         alternative (map #(if (= % 12) -1 %) cards)]\n                     (or (consecutive (sort cards)) (consecutive (sort alternative)))))\n        flsh  #(apply = (map first %))\n        group-rank (fn [h]\n                     (sort (map (comp count second) (group-by second h))))\n        same (fn [h] (apply max (group-rank h)))]\n    (cond (and (straight h) (flsh h)) :straight-flush\n          (= 4 (same h)) :four-of-a-kind\n          (= [2 3] (group-rank h)) :full-house\n          (flsh h) :flush\n          (straight h) :straight\n          (= 3 (same h)) :three-of-a-kind\n          (= 2 (last (group-rank h)) (last (butlast (group-rank h)))) :two-pair\n          (= 2 (same h)) :pair\n          :else :high-card)))","problem":"178","user":"4fbd12a5e4b081705acca2fd"},{"problem":"178","code":"(fn[s]\n  (let [f (fn[[a b]] [a (or ({\\T 8 \\J 9 \\Q 10 \\K 11 \\A 12} b) (- (int b) 50))])\n        t (map f s)\n        f? (apply = (map first t))\n        sl (sort (map second t))\n        s? (apply = (conj (map #(= (inc %) %2) sl (rest sl)) true))\n        [m n] (take 2 (reverse (sort (map count (partition-by identity sl)))))\n        ]\n    (if f?\n      (if s? :straight-flush :flush)\n      (cond\n        (or s? (= sl [0 1 2 3 12])) :straight\n            (= 4 m) :four-of-a-kind\n            (and (= 3 m) (= n 2)) :full-house\n            (= 3 m) :three-of-a-kind\n            (and (= 2 2) (= n 2)) :two-pair\n            (= 2 m) :pair\n            1 :high-card))))","user":"56824e1be4b0945ebc182a91"},{"code":"(fn [hand]\n    (let [rank-to-num (zipmap \"23456789TJKQA\"\n                              (range))\n          cards (map (juxt first\n                           (comp rank-to-num second)) hand)\n          straight (#{[-1 -1 -1 -1]\n                      [-1 -1 -1 -9]}\n                    (->> cards\n                         (map second)\n                         sort\n                         (partition 2 1)\n                         (map (partial reduce -))))\n          flush (= 1 (count (frequencies (map first cards))))\n          sames (frequencies (vals (frequencies (map second cards))))]\n      (cond\n       (and flush straight) :straight-flush\n       (= {4 1, 1 1} sames) :four-of-a-kind\n       (= {3 1, 2 1} sames) :full-house\n       flush :flush\n       straight :straight\n       (= {3 1, 1 2} sames) :three-of-a-kind\n       (= {2 2, 1 1} sames) :two-pair\n       (= {2 1, 1 3} sames) :pair\n       :else :high-card)))","problem":"178","user":"4e6a0667535d8ccf87e9fe9e"},{"code":"(fn best-hand [ss]\n  (letfn [(convert-hand [s]\n            (let [suits {\\D :diamond \\H :heart \\S :spade \\C :club}\n                  ranks {\\2 0 \\3 1 \\4 2 \\5 3 \\6 4 \\7 5 \\8 6 \\9 7 \\T 8 \\J 9 \\Q 10 \\K 11 \\A 12}]\n              {:suit (suits (first s))\n               :rank (ranks (last s))}))\n          (is-flush [cards]\n            (apply = (map :suit cards)))\n          (is-seq [cards]\n            (loop [elt (first cards) rst (rest cards)]\n              (if (empty? rst)\n                true\n                (if (= 1 (- (:rank (first rst)) (:rank elt)))\n                  (recur (first rst) (rest rst))\n                  false))))\n          (is-straight [cards]\n            (let [sorted-cards (sort-by :rank cards)\n                  ace-sorted-cards (sort-by\n                                    :rank\n                                    (map (fn [c]\n                                           (update-in c [:rank] #(if (= % 12) -1 %)))\n                                         cards))]\n              (or (is-seq sorted-cards)\n                  (is-seq ace-sorted-cards))))\n          (is-straight-flush [cards]\n            (and (is-straight cards)\n                 (is-flush cards)))\n          (is-n-of-a-kind [n cards]\n            (loop [elt (first cards) rst (rest cards)]\n              (if (empty? rst)\n                false\n                (let [same-rank-n (count (filter #(= (:rank elt) (:rank %)) cards))]\n                  (if (= same-rank-n n)\n                    true\n                    (recur (first rst) (rest rst)))))))\n          (is-4 [cards]\n            (is-n-of-a-kind 4 cards))\n          (is-3 [cards]\n            (is-n-of-a-kind 3 cards))\n          (is-full-house [cards]\n            (let [result (partition-by :rank cards)]\n              (and (= 2 (count result))\n                   (or (= 2 (count (first result)))\n                       (= 3 (count (first result)))))))\n          (is-n-pair [n cards]\n            (let [result (filter #(= 2 (count (val %)))\n                                 (group-by :rank cards))]\n              (= n (count result))))\n          (is-2-pair [cards]\n            (is-n-pair 2 cards))\n          (is-1-pair [cards]\n            (is-n-pair 1 cards))]\n    (let [cards (map convert-hand ss)\n          fns [\n               [:straight-flush  is-straight-flush]\n               [:four-of-a-kind  is-4]\n               [:full-house      is-full-house]\n               [:flush           is-flush]\n               [:straight        is-straight]\n               [:three-of-a-kind is-3]\n               [:two-pair        is-2-pair]\n               [:pair            is-1-pair]\n               ]\n          result (map #((second %) cards) fns)\n          index (count (take-while false? result))]\n      (if (= index (count fns))\n        :high-card\n        (first (nth fns index))))))","problem":"178","user":"4eec82fe535d93acb0a668ae"},{"code":"(fn [cards]\n    (let [recognize (fn [[s r]]\n                      (let [suit {\\D :diamond \\S :spade \\C :club \\H :heart}\n                            rank {\\T 8 \\J 9 \\Q 10 \\K 11 \\A 12\n                                  \\2 0 \\3 1 \\4 2 \\5 3 \\6 4 \\7 5 \\8 6 \\9 7}] \n                        {:suit (suit s) :rank (rank r)})\n                      )\n          four-of-a-kind? (fn [cards] (let [g (group-by :rank cards)] (some #(= 4 ((comp count second) %)) g)))\n          full-house? (fn [cards] (let [g (map (comp count second) (group-by :rank cards))] (= (set g) #{2 3})))\n          flush? (fn [cards] (apply = (map :suit cards)))\n          straight? (fn [cards]\n                      ((some-fn\n                         (fn [c] (every? (partial = 1) (map (comp #(mod % 11) (partial apply -)) (partition 2 1 c))))\n                         #(= % [12 3 2 1 0]))\n                       ((comp reverse sort (partial map :rank)) cards)))\n          three-of-a-kind? (fn [cards] (let [g (group-by :rank cards)] (some #(= 3 ((comp count second) %)) g)))\n          two-pair? (fn [cards] (let [g (group-by :rank cards)] (= 2 (count (filter #(= 2 ((comp count second) %)) g)))))\n          pair? (fn [cards] (let [g (group-by :rank cards)] (some #(= 2 ((comp count second) %)) g)))\n          straight-flush? (fn [cards] (and (straight? cards) (flush? cards)))\n          cards (map recognize cards)\n          ]\n      (cond\n        (straight-flush? cards) :straight-flush\n        (four-of-a-kind? cards) :four-of-a-kind\n        (full-house? cards) :full-house\n        (flush? cards) :flush\n        (straight? cards) :straight\n        (three-of-a-kind? cards) :three-of-a-kind\n        (two-pair? cards) :two-pair\n        (pair? cards) :pair\n        :else :high-card)))","problem":"178","user":"4ff3df0fe4b0678c553fc355"},{"code":"(fn [h]\n  (let [[s r] (apply map list h)\n        rs (set (map frequencies (partition 5 1 \"A23456789TJQKA\")))\n        s? (rs (frequencies r))\n        f? (apply = s)\n        g (frequencies (vals (frequencies r)))]\n    (cond\n     (and s? f?) :straight-flush\n     (g 4) :four-of-a-kind\n     (and (g 2) (g 3)) :full-house\n     f? :flush\n     s? :straight\n     (g 3) :three-of-a-kind\n     (= 2 (g 2)) :two-pair\n     (g 2) :pair\n     :else :high-card)))","problem":"178","user":"5032b066e4b00c0952a257ea"},{"code":"(fn [hand]\n  (let [flush? (apply = (map first hand))\n        face-card-rank (zipmap \"TJQKA\" (iterate inc 10))\n        rank (fn [card] (some #(% (second card)) [face-card-rank #(- (int %) (int \\0))]))\n        ranks (->> hand (map rank) sort)\n        straight? (letfn [(str-test [rs] (every? identity (map = rs (iterate inc (first rs)))))]\n                    (or (str-test ranks) (and (= (last ranks) 14) (str-test (cons 1 (butlast ranks))))))\n        distr (->> ranks frequencies vals (sort >))]\n    (cond\n      (and straight? flush?) :straight-flush\n      (= (first distr) 4) :four-of-a-kind\n      (= (take 2 distr) [3 2]) :full-house\n      flush? :flush\n      straight? :straight\n      (= (first distr) 3) :three-of-a-kind\n      (= (take 2 distr) [2 2]) :two-pair\n      (= (first distr) 2) :pair\n      :else :high-card)))","problem":"178","user":"506ab9bae4b05d3b7762c74c"},{"code":"(fn [h]\n  (let [c \"A23456789TJQKA\"\n        s (map first h)\n        n (map second h)\n        p [#(if (and (= 1 (-> s set count)) (or (>= (.indexOf c (apply str n)) 0) (>= (.indexOf c (apply str (reverse n))) 0))) :straight-flush)\n           #(if (->> n (group-by identity) (filter (fn [g] (> (count (val g)) 3))) seq) :four-of-a-kind)\n           #(if (= 2 (count (group-by identity n))) :full-house)\n           #(if (= 1 (-> s set count)) :flush)\n           #(if (or (>= (.indexOf c (apply str n)) 0) (>= (.indexOf c (apply str (reverse n))) 0)) :straight)\n           #(if (->> n (group-by identity) (filter (fn [g] (> (count (val g)) 2))) seq) :three-of-a-kind)\n           #(if (< (-> n set count) (dec (count n))) :two-pair)\n           #(if (< (-> n set count) (count n)) :pair)\n           (constantly :high-card)]]\n    (some #(%) p)))","problem":"178","user":"4fa05b99e4b0dcca54ed6d47"},{"code":"(fn [hand]\n  (let [rank (hash-map \\2 2 \\3 3 \\4 4 \\5 5 \\6 6 \\7 7 \\8 8 \\9 9 \\T 10 \\J 11 \\Q 12 \\K 13 \\A 14)\n        ace-rank (hash-map \\2 2 \\3 3 \\4 4 \\5 5 \\6 6 \\7 7 \\8 8 \\9 9 \\T 10 \\J 11 \\Q 12 \\K 13 \\A 1)\n        order-by-rank (fn [ranking hand] (sort (fn [a b] (> (ranking (second a)) (ranking (second b)))) hand))\n        is-flush (apply = (map first hand))\n        is-straight (let [ranks (map #(rank (second %)) (order-by-rank rank hand))\n                          ace-ranks (map #(ace-rank (second %)) (order-by-rank ace-rank hand))\n                          check (fn [cards] (apply = 1 (map - (butlast cards) (rest cards))))]\n                      (or (check ranks) (check ace-ranks)))\n        number-of-ranks (sort (vals (apply merge-with + (map #(hash-map % 1) (map second hand)))))]\n    (cond\n     (and is-straight is-flush) :straight-flush\n     (= [1 4] number-of-ranks) :four-of-a-kind\n     (= [2 3] number-of-ranks) :full-house\n     is-flush :flush\n     is-straight :straight\n     (= [1 1 3] number-of-ranks) :three-of-a-kind\n     (= [1 2 2] number-of-ranks) :two-pair\n     (= [1 1 1 2] number-of-ranks) :pair\n     :else :high-card)))","problem":"178","user":"5097b556e4b00ad8bab4e970"},{"problem":"178","code":"(fn [cards]\n  (let [css {\\2 2 \\3 3 \\4 4 \\5 5 \\6 6 \\7 7 \\8 8\n             \\9 9 \\T 10 \\J 11 \\Q 12 \\K 13 \\A 14}\n        css' (assoc css \\A 1)\n        suits (map first cards)\n        f-suits (frequencies suits)\n        cs (sort (map (comp css second) cards))\n        cs' (sort (map (comp css' second) cards))\n        f-cs (frequencies cs)\n        max-f-cs (apply max (vals f-cs))\n        v-f-cs (sort (vals f-cs))\n        s-fn (fn [c c'] (if (= (inc c) c') c' -1))\n        straight? (or (not= -1 (reduce s-fn cs)) (not= -1 (reduce s-fn cs')))]\n    (cond\n      (and (= 1 (count f-suits)) straight?) :straight-flush\n      (= 4 max-f-cs) :four-of-a-kind\n      (= [2 3] v-f-cs) :full-house\n      (= 1 (count f-suits)) :flush\n      straight? :straight\n      (= 3 max-f-cs) :three-of-a-kind\n      (= [1 2 2] v-f-cs) :two-pair\n      (= 2 max-f-cs) :pair\n      :else :high-card)))","user":"56d68cbae4b0ea9b8538f7cd"},{"problem":"178","code":"(letfn [(straight [c] (every? (fn [[x y]] (= 1 (- y x))) (partition 2 1 (sort (map second c)))))\n        (flush [c] (apply = (map first c)))]\n  (let [cm (zipmap \"23456789TJQKA\" (range 2 15))]\n    (fn [c]\n      (let [c  (map #(let [[h d] (seq %)] [h (cm d)]) c)\n            st (or (straight c) (straight (map (fn [[h d]] [h (if (= d 14) 1 d)]) c)))\n            fl (flush c)\n            f  (sort > (map second (frequencies (map second c))))]\n        (cond\n         (= [5] f) :poker\n         (and st fl) :straight-flush\n         (= [4 1] f) :four-of-a-kind\n         (= [3 2] f) :full-house\n         fl :flush\n         st :straight\n         (= 3 (first f)) :three-of-a-kind\n         (= [2 2 1] f) :two-pair\n         (= 2 (first f)) :pair\n         :else :high-card)))))","user":"54cc313de4b057c6fda3a28b"},{"problem":"178","code":"(fn [l]\n         (let [colors (reduce (fn [a [c r]] (into a [c])) #{} l)\n               same_color (= (count colors) 1)\n               groups (group-by (fn [[c r]] r) l)\n               groups-nums (reduce (fn [m k] (assoc m k (count (get groups k)))) {} (keys groups))\n               nms (sort (vals groups-nums))\n               ranks (reduce (fn [acc [c r]] (conj acc (.indexOf (seq \"23456789TJQKA\") r) )) [] l)\n               ranks2 (map #(if (= % 12) -1 %) ranks) \n               srt? (fn [l] (= l (range (first l) (+ (first l) 5))))\n               str8 (or (srt? (sort ranks)) (srt? (sort ranks2)) )\n               ]\n           (cond\n              (and str8 same_color) :straight-flush\n              (= nms [1 4]) :four-of-a-kind\n              (= nms [2 3]) :full-house\n              (true? same_color) :flush\n              (true? str8) :straight\n              (= nms [1 1 3]) :three-of-a-kind\n              (= nms [1 2 2]) :two-pair\n              (= nms [1 1 1 2]) :pair\n              :else :high-card\n             )\n           )\n          )","user":"533c2605e4b0e30313ee6cd7"},{"code":"(fn [h]   \n  (let [f (= 1 (count (set (map first h))))\n        [a & _ :as r] (sort (map (fn [[_ x]] ({\\A 14 \\K 13 \\Q 12 \\J 11 \\T 10} x (- (int x) 48))) h))        \n        s (#{(range a (+ a 5)) [2 3 4 5 14]} r)]                      \n  (cond \n    (and f s) :straight-flush\n    f :flush\n  \ts :straight \n    :else \n      ({[1 4] :four-of-a-kind\n        [2 3] :full-house\n        [1 1 3] :three-of-a-kind\n        [1 2 2] :two-pair\n        [1 1 1 2] :pair} (sort (vals (frequencies r))) :high-card))))","problem":"178","user":"4db85282535d1e037afb218a"},{"problem":"178","code":"(fn [cards]\n  (let [deck [\"A\" \"2\" \"3\" \"4\" \"5\" \"6\" \"7\" \"8\" \"9\" \"T\" \"J\" \"Q\" \"K\" \"A\"]\n        hand (map (fn [[s r]] [(str s) (str r)]) cards)\n        ranks (map second hand)\n        suits (map first hand)\n        straight-fn (fn [index]\n                      (= #{1}\n                         (set (map #(apply - %)\n                                   (partition 2 1 (sort > (map index ranks)))))))\n        straight? (or (straight-fn #(.indexOf deck %))\n                      (straight-fn #(.lastIndexOf deck %)))\n        flush? (= 1 (count (set suits)))\n        combos (sort (map count (partition-by identity (sort ranks))))]\n    (cond (and straight? flush?) :straight-flush\n          straight? :straight\n          flush? :flush\n          :else (case combos\n                  [1 4] :four-of-a-kind\n                  [2 3] :full-house\n                  [1 1 3] :three-of-a-kind\n                  [1 2 2] :two-pair\n                  [1 1 1 2] :pair\n                  :high-card))))","user":"4f2d5f5de4b0d6649770a05a"},{"problem":"178","code":"(fn classify [hand]\n  (letfn [(hand-to-clj [[s v]]\n            {:suite (get {\\H :hearts \\C :clubs \\D :diamonds \\S :spades} s)\n             :value (Integer. (get {\\A \"14\" \\K \"13\" \\Q \"12\" \\J \"11\" \\T \"10\"} v (str v)))})\n\n          ;; Straight flush: All cards in the same suit, and in sequence\n          (is-flush [cards]\n            (reduce #(and %1 %2) (map #(= (:suite %) (:suite (first cards))) cards)))\n\n          (straight [cards]\n            (->>\n             cards\n             (map :value)\n             (sort-by identity)\n             (partition 2 1)\n             (map #(apply - %))\n             (filter #(not (or (= % -9) (= % -1))))\n             count\n             (= 0)))\n\n          (straight-flush [cards]\n            (and (is-flush cards)\n                 (straight cards)))\n\n          (equal-values [cards]\n            (->> cards\n                 (group-by :value)\n                 (map second)\n                 (map count)\n                 sort))\n\n          (full-house [cards]\n            (= (equal-values cards) [2 3]))\n\n          (two-pair [cards]\n            (= (equal-values cards) [1 2 2]))\n\n          (four-of-a-kind [cards]\n            (= (equal-values cards) [1 4]))\n\n          (three-of-a-kind [cards]\n            (= (equal-values cards) [1 1 3]))\n\n          (two-pair [cards]\n            (= (equal-values cards) [1 2 2]))\n\n          (a-pair [cards]\n            (->> cards\n                 equal-values\n                 (filter #(= 2 %))\n                 count\n                 (< 0)))\n\n          (high-card [cards]\n            true)]\n    (let [hands\n          [[:straight-flush straight-flush]\n           [:four-of-a-kind four-of-a-kind]\n           [:full-house full-house]\n           [:flush is-flush]\n           [:straight straight]\n           [:three-of-a-kind three-of-a-kind]\n           [:two-pair two-pair]\n           [:pair a-pair]\n           [:high-card high-card]]\n          a-hand (map hand-to-clj hand)]\n     (first (filter identity (map (fn [[sym f]] (if (f a-hand) sym nil)) hands))))))","user":"532b43c3e4b09d4e7a9b5531"},{"code":"(fn [coll]\n  (let [parse (fn [coll] \n\t\t  (let [[x y] (seq coll)\n\t\t\t\t suit  (symbol (str x))\n\t\t\t\t card  (symbol (str y))\n\t\t\t\t suits   {'S :spade 'H :heart 'D :diamond 'C :club}\n\t\t\t\t cards\t (into {'T 8 'J 9 'Q 10 'K 11 'A 12}  \n\t\t\t\t\t\t\t   (map #(vector (symbol (str %)) (- % 2)) (range  2 10))) ]\n\t\t\t{:suit (suits suit) :rank (cards card)}\t))\n\n\t\tin-sequence? (fn [coll]\n\t\t  (let [s (sort coll)\n\t\t\t\tm (map vector s (range (first s) 13))]\n\t\t  (every? (fn [[x y]] (= x y))m)))\t\n\n\t\tstraight-flush (fn [deck]  (if (and (= 1 (count (distinct (map :suit deck)))) \n\t\t\t\t\t\t\t\t\t\t\t\t(in-sequence?  (map :rank deck))) :straight-flush))\n\t\t\t\t\t\t\t\t\t\t\t\t\n\t\tfour-of-a-kind (fn [deck] (if (some (fn [[k v]] (= 4 (count v)))\n\t\t\t\t\t\t\t\t\t\t\t  (group-by :rank deck) ) :four-of-a-kind))\n\n\t\tfull-house (fn [deck]  (if (let [g (group-by :rank deck)\n\t\t\t\t\t\t\t\t\t\t c (count g)\n\t\t\t\t\t\t\t\t\t\t g1 (-> g first second count)\n\t\t\t\t\t\t\t\t\t\t g2 (-> g second second count)]\n\t\t\t\t\t\t\t\t\t(and (= 2 c) (or (= 3 g1) (= 3 g2)))) :full-house) )\n\t\tflush (fn [deck] (if (= 1 (count (group-by :suit deck))) :flush))\n\t\tstraight (fn [deck] (if (or (in-sequence? (map #(if (= 12 %) -1 %) (map :rank deck)))  \n\t\t\t\t\t\t\t\t\t (in-sequence? (map :rank deck))) :straight))\n\t\t\t\t\t\t\t\t\t \n\t\tthree-of-a-kind (fn [deck] (if (let [g (group-by :rank deck) ]\n\t\t\t\t\t\t\t\t\t\t(some (fn [[k v]] (= 3 (count v))) g)) :three-of-a-kind))\n\t\ttwo-pair (fn [deck] (if (let [g (group-by :rank deck) g* (filter (fn [[k v]] (= 2 (count v))) g) ]\n\t\t\t\t\t\t\t\t\t\t(= 2 (count g*))) :two-pair))\n\t\tpair (fn [deck] (if (let [g (group-by :rank deck) ]\n\t\t\t\t\t\t\t\t\t\t(some (fn [[k v]] (= 2 (count v))) g)) :pair))\n\t\thigh-card (fn [deck] :high-card)\n\n\t\tsingle (fn [f coll] (first (filter f coll)))\n\t\tf (juxt straight-flush four-of-a-kind full-house flush straight three-of-a-kind two-pair pair high-card)\n\t\t] \n    (single identity (f (map parse coll)))))","problem":"178","user":"523a9fc9e4b081681ca7adca"},{"problem":"178","code":"(fn [h]\n  (let [\n        [a b c d e :as rs] (sort (map #(.indexOf (vec \"23456789TJQKA\") (second %)) h))\n        f (apply = (map first h))\n        s (or (apply = (map - rs (range))) (= rs [0 1 2 3 12]))\n        q #(= %& (sort (vals (frequencies rs))))]\n    \n    (cond\n      (and f s) :straight-flush\n      (q 1 4) :four-of-a-kind;\n      (q 2 3) :full-house\n      f :flush\n      s :straight\n      (q 1 1 3) :three-of-a-kind\n      (q 1 2 2) :two-pair\n      (q 1 1 1 2) :pair\n      :else :high-card)))","user":"53500869e4b084c2834f4ad3"},{"code":"(fn [hand]\n  (let [rvals     (vec \"23456789TJQKA\")\n        flush?    (apply = (map first hand))\n        ranks     (->> hand (map #(.indexOf rvals (second %))) sort vec)\n        by-rank   (frequencies ranks)\n        groups    (clojure.set/map-invert by-rank)\n        [p1 p2]   (filter (fn [[_ f]] (= f 2)) by-rank)\n        straight? (or (and (= 5 (count by-rank))\n                           (= 4 (- (ranks 4) (ranks 0))))\n                      (= ranks [0 1 2 3 12]))]\n    (cond\n      (and flush? straight?) :straight-flush\n      (groups 4)             :four-of-a-kind\n      (and (groups 3) p1)    :full-house\n      flush?                 :flush\n      straight?              :straight\n      (groups 3)             :three-of-a-kind\n      p2                     :two-pair\n      p1                     :pair\n      :else                  :high-card)))","problem":"178","user":"4f6160a7e4b0defedf855fbe"},{"code":"(letfn [(flush? [hand] (apply = (map :suit hand)))\n        (straight? [hand]\n          (let [ranks (map :rank hand)\n                [start :as sorted-ranks] (sort (if (and (= 0 (apply min ranks))\n                                                        (= 12 (apply max ranks)))\n                                                 (replace {12 -1} ranks)\n                                                 ranks))]\n            (= sorted-ranks (range start (+ start 5)))))\n        (parse-card [card]\n          (zipmap [:suit :rank]\n                  (map (zipmap \"CDHS23456789TJQKA\"\n                               `(:club :diamond :heart :spade ~@(range)))\n                       card)))]\n  (fn go [input]\n    (let [hand (map parse-card input)\n          counts (frequencies (vals (frequencies (map :rank hand))))]\n      (cond\n       (and (straight? hand) (flush? hand)) :straight-flush\n       (= {4 1, 1 1} counts) :four-of-a-kind\n       (= {3 1, 2 1} counts) :full-house\n       (flush? hand) :flush\n       (straight? hand) :straight\n       (= {3 1, 1 2} counts) :three-of-a-kind\n       (= {2 2, 1 1} counts) :two-pair\n       (= {2 1, 1 3} counts) :pair\n       :else :high-card))))","problem":"178","user":"507b7dbee4b09034bfeeb71e"},{"problem":"178","code":"(fn [cards]\n  (letfn [(recognize [[s n]]\n            {:suit ({\\D :diamond \\S :spade \\H :heart \\C :club} s)\n             :rank (or\n                     ({\\T 8 \\J 9 \\Q 10 \\K 11 \\A 12} n)\n                     (- (int n) 50))})\n          (has-x-of [cs n] (not (empty? (filter #(= n (count (second %))) cs))))\n          (subseq? [a b]\n            (empty? (filter #(not (true? %)) (map (fn [x y] (= x y)) (drop-while #(not= % (first a)) b) a))))\n          (is-straight [coll]\n            (subseq? (sort coll) (cycle (range -1 13))))\n          ]\n    (let [cs (map recognize cards)\n          _ (println cs)]\n      (cond\n        (let [first (map :rank cs)\n              second (replace {12 -1} first)]\n          (and (has-x-of (group-by :suit cs) 5) (or (is-straight first) (is-straight second))))\n        :straight-flush\n        (has-x-of (group-by :rank cs) 4)\n        :four-of-a-kind\n        (and (has-x-of (group-by :rank cs) 2) (has-x-of (group-by :rank cs) 3))\n        :full-house\n        (has-x-of (group-by :suit cs) 5)\n        :flush\n        (let [first (map :rank cs)\n              second (replace {12 -1} first)]\n          (or (is-straight first) (is-straight second)))\n        :straight\n        (has-x-of (group-by :rank cs) 3)\n        :three-of-a-kind\n        (= 3 (count (group-by :rank cs)))\n        :two-pair\n        (has-x-of (group-by :rank cs) 2)\n        :pair\n        :else :high-card))))","user":"529dfc6de4b04e0c58e87b8a"},{"code":"(fn [cards]\n\t(let [suits (map first cards)\n\t\t  faces (map second cards)\n\t\t  flush (apply = suits)\n\t\t  straight (= 3 (count (partition-by #(-> % hash-set (some faces) boolean) [\\A \\2 \\3 \\4 \\5 \\6 \\7 \\8 \\9 \\J \\Q \\K \\A]))) \n\t\t  pairs (group-by identity faces)\n\t\t  pair-counts (map (comp count val) pairs)]\n\t(cond\n\t\t(and straight flush) :straight-flush\n\t\t(some #{4} pair-counts) :four-of-a-kind\n\t\t(= 2 (count pairs)) :full-house\n\t\tflush :flush\n\t\tstraight :straight\n\t\t(some #{3} pair-counts) :three-of-a-kind\n\t\t(= 3 (count pairs)) :two-pair\n\t\t(some #{2} pair-counts) :pair\n\t\t:else :high-card)))","problem":"178","user":"4f1b92d1535d64f60314647b"},{"code":"(fn [c]\n    (let [T take\n          D drop\n          L last\n          M map\n         \n          E (fn [[h & t]] (every? #(= % h)t))\n          c (sort-by\n              L\n              (M (fn [[f l]] [f (.indexOf \"_A23456789TJQK\" (str l))]) c))\n          n (M L c)  ; numbers (ranks)\n          s (M first c) ; suits\n          [v w x y z] n\n          q (or\n             (= n (range v (+ v 5)))\n             (= [1 10 11 12 13] n))\n          m (E s)\n          Y (= y z)\n          p :pair\n          t :two-pair]\n      (cond\n        (and q m) :straight-flush\n        (or\n          (E (T 4 n))\n          (E (D 1 n))) :four-of-a-kind\n        (or\n          (and (E (T 3 n)) (E (D 3 n)))\n          (and (E (T 2 n)) (E (D 2 n)))) :full-house\n        m :flush\n        q :straight\n        (or\n          (E (T 3 n))\n          (E (T 3 (D 1 n)))\n          (E (D 2 n))) :three-of-a-kind\n        (= v w)\n          (if (or (= x y) Y) t p)\n\n        (= w x)\n          (if Y t p)\n        (or\n          (= x y)\n          Y) p\n        1 :high-card)))","problem":"178","user":"51a10b2ce4b0b292b01ee3fe"},{"code":"(fn [h]\n  (let [rank (fn [x]\n               (case (last x)\n                 \\T 10      \n                 \\J 11      \n                 \\Q 12       \n                 \\K 13       \n                 \\A 14       \n                 (- (int (last x)) 48)\n                 ))\n        suitcounts (frequencies (map #(count (last %)) (group-by first h)))\n        rankcounts (frequencies (map #(count (last %)) (group-by last h)))\n        ranks (let [r (sort (map rank h))]\n                (if (and (= 14 (last r)) (= 2 (first r)))\n                  (cons 1 (butlast r))\n                  r))\n        straight? (fn straight? [h]\n                    (if (= (count h) 1)\n                      true\n                      (if (= (inc (first h)) (second h))\n                        (straight? (rest h))\n                        false)))        \n        ]\n    (if (and (suitcounts 5) (straight? ranks)) :straight-flush\n      (if (rankcounts 4) :four-of-a-kind\n        (if (and (rankcounts 3) (rankcounts 2)) :full-house\n          (if (suitcounts 5) :flush\n            (if (straight? ranks ) :straight\n              (if (rankcounts 3) :three-of-a-kind\n                (if (= 2 (rankcounts 2)) :two-pair\n                  (if (rankcounts 2) :pair\n                    :high-card))))))))))","problem":"178","user":"513b77f3e4b00f740c76c403"},{"problem":"178","code":"(fn best-hand [cards]\n        (let [rec (fn [[s r]]\n                    {:suit (get {\\D :diamond \\H :heart \\C :club \\S :spade} s)\n                     :rank (or (get {\\T 8 \\J 9 \\Q 10 \\K 11 \\A 12} r) (- ((comp read-string str) r) 2))})\n              cards (map rec cards)\n              flush #(= 1 (count (set (map :suit %))))\n              straight #(let [ranks (sort (map :rank %))]\n                          (or (= ranks [0 1 2 3 12])\n                              (every? (fn [[l r]] (= l (- r 1))) (partition 2 1 ranks))))\n              of-a-kinds #(filter (fn [[k v]] (>= v %2)) (frequencies (map :rank %)))\n              ]\n          (cond\n           (and (straight cards) (flush cards)) :straight-flush\n           (seq (of-a-kinds cards 4)) :four-of-a-kind\n           (when-let [[[rank] _] (seq (of-a-kinds cards 3))]\n             (some (fn [[r _]] (not= rank r)) (of-a-kinds cards 2))) :full-house\n           (flush cards) :flush\n           (straight cards) :straight\n           (seq (of-a-kinds cards 3)) :three-of-a-kind\n           (= (count (of-a-kinds cards 2)) 2) :two-pair\n           (seq (of-a-kinds cards 2)) :pair\n           :else :high-card)))","user":"502873a8e4b01614d1633ff8"},{"problem":"178","code":"(fn best-hand[coll]\n  (letfn [\n          (split[coll]\n            (loop [c coll sl [] rl []]\n              (if (empty? c)\n                [sl rl]\n                (let [v (first c)]\n                  (recur (rest c) (conj sl (first v)) (conj rl (second v)))\n                )\n              )\n            )\n          )\n\n          (one-suit?[sl]\n            (= (count (distinct sl)) 1)\n          )\n\n          (in-sequence?[rl]\n            (let [rstr \"23456789TJQKA2345\" l (count rl) t (sort rl)]\n              (loop [c rstr n 0]\n                (if (>= n 13)\n                  false\n                  (if (nil? (some #{(first c)} rl))\n                    (recur (rest c) (inc n))\n                    (if (= (sort (take l (drop n rstr))) t)\n                      true\n                      (recur (rest c) (inc n))\n                    )\n                  )\n                )\n              )\n            )\n          )\n\n          (rank[rl]\n            (let [v (split (frequencies rl))]\n              (case (sort (second v))\n                [1 1 1 2] :pair\n                [1 1 3]   :three-of-a-kind\n                [1 2 2]   :two-pair\n                [2 3]     :full-house\n                [1 4]     :four-of-a-kind\n                           nil\n              )\n            )\n          )\n\n         ]\n    \n    (let [[sl rl] (split coll) [a b c] [(in-sequence? rl) (one-suit? sl) (rank rl)]]\n      (if (nil? c)\n        (if a\n          (if b :straight-flush :straight)\n          (if b :flush :high-card)\n        )\n        c\n      )\n    )\n  )\n)","user":"545537c1e4b0e397800069dd"},{"problem":"178","code":"(fn [hand]\n  (let [card (fn [[s r]]\n               (let [suits {\\S :spade \\H :heart\n                            \\D :diamond \\C :club}\n                     ranks {\\2 0 \\3 1 \\4 2 \\5 3 \\6 4\n                            \\7 5 \\8 6 \\9 7 \\T 8 \\J 9\n                            \\Q 10 \\K 11 \\A 12}]\n                 {:suit (suits s) :rank (ranks r)}))\n        cards (map card hand)\n        suits (group-by :suit cards)\n        ranks (group-by :rank cards)\n        fflush (fn [suits] (= 1 (count (keys suits))))\n        straight (fn [ranks]\n                   (when (= 5 (count (keys ranks)))\n                     (let [points (set (keys ranks))]\n                       (or\n                        (= 4 (- (apply max points) (apply min points)))\n                        (= points #{0,1,2,3,12})))))]\n    (cond\n      (and (fflush suits) (straight ranks)) :straight-flush\n      (= 4 (apply max (map count (vals ranks)))) :four-of-a-kind\n      (= 2 (count (keys ranks))) :full-house\n      (fflush suits) :flush\n      (straight ranks) :straight\n      (= 3 (apply max (map count (vals ranks)))) :three-of-a-kind\n      (= 3 (count (keys ranks))) :two-pair\n      (= 2 (apply max (map count (vals ranks)))) :pair\n      :else :high-card)))","user":"53ef7f77e4b0742d9025b0ce"},{"problem":"178","code":"(fn [cs]\n  (letfn [(straight? [cs]\n            (let [ranks-ah {\\2 2, \\3 3, \\4 4, \\5 5, \\6 6, \\7 7, \\8 8,\n                            \\9 9, \\T 10, \\J 11, \\Q 12, \\K 13, \\A 14}\n                  ranks-al {\\A 1, \\2 2, \\3 3, \\4 4, \\5 5, \\6 6, \\7 7,\n                            \\8 8, \\9 9, \\T 10, \\J 11, \\Q 12, \\K 13}\n                  rsh (sort (map (comp ranks-ah second) cs))\n                  rsl (sort (map (comp ranks-al second) cs))]\n              (or (= (range (first rsh) (+ 5 (first rsh))) rsh)\n                  (= (range (first rsl) (+ 5 (first rsl))) rsl))))]\n    (let [counts (map count (vals (group-by second cs)))\n          max-count (apply max counts)\n          ranks (map count (vals (group-by first cs)))\n          max-rank (apply max ranks)\n          s? (straight? cs)]\n      (cond\n        (and s? (= max-rank 5)) :straight-flush\n        (= max-count 4) :four-of-a-kind\n        (= (sort counts) '(2 3)) :full-house\n        (= max-rank 5) :flush\n        s? :straight\n        (= max-count 3) :three-of-a-kind\n        (= (sort counts) '(1 2 2)) :two-pair\n        (= max-count 2) :pair\n        :else :high-card))))","user":"5eb1c786e4b00a66d4a95201"},{"problem":"178","code":"(fn [ss]\n  (letfn [(card [s] {\n            :suit  (get {\\D :diamonds \\S :spades \\H :hearts \\C :clubs} (first s))\n            :rank  (get {\\2 0,  \\3 1, \\4 2, \\5 3, \\6 4, \\7 5, \\8 6, \\9 7, \\T 8, \\J 9, \\Q 10, \\K 11, \\A 12} (second s)) })\n          (straight? [faces]\n            (or (= 4 (- (last faces)(first faces)))\n                (= faces [0 1 2 3 12]))) ;; ace-low\n          (score [cards]\n            (let [flush? (apply = (map :suit cards))\n                  faces (sort (map :rank cards))\n                  straight? (straight? faces)]\n              (condp = (->> (frequencies faces)(map second) sort)\n                [1 4]     :four-of-a-kind\n                [2 3]     :full-house\n                [1 1 3]   :three-of-a-kind\n                [1 2 2]   :two-pair\n                [1 1 1 2] :pair\n                (cond \n                  (and flush? straight?) :straight-flush\n                  flush?                 :flush\n                  straight?              :straight\n                  :else                  :high-card))))]\n      (score (map card ss))))","user":"55ecb2c0e4b0121d4835fdce"},{"problem":"178","code":"(fn [cards]\n  (let [anl (fn [[s r]]\n              {:suit ((zipmap \"DHCS\" [:diamond :heart :club :spade]) s)\n               :rank ((zipmap \"23456789TJQKA\" (range)) r)})\n        cs (map anl cards)\n        suits (sort (map :suit cs))\n        ranks (sort (map :rank cs))\n        \n        minr  (first ranks)\n        sf? (and (apply = suits)\n                 (= ranks (range minr (+ minr 5))))\n        fk? (= 4\n               (apply max\n                      (map count\n                           (vals (group-by identity ranks)))))\n        fh? (and (= (count (distinct ranks)) 2)\n                 (or (apply = (take 2 ranks))\n                     (apply = (take 3 ranks))))\n        fl? (apply = suits)\n        st? (or (= (range minr (+ minr 5)) ranks)\n                (= (concat (range 4) (list 12)) ranks))\n        rnkcount (reduce #(max % (count %2))\n                         0\n                         (partition-by identity ranks))\n        tk? (= 3 rnkcount)\n        tp? (= (count (filter #(= (count %) 2)\n                              (partition-by identity ranks)))\n               2)\n        pr? (= 2 rnkcount)]\n    (cond sf? :straight-flush\n          fk? :four-of-a-kind\n          fh? :full-house\n          fl? :flush\n          st? :straight\n          tk? :three-of-a-kind\n          tp? :two-pair\n          pr? :pair\n          :else :high-card\n          )))","user":"57035ccfe4b08d47c97781ef"},{"code":"(fn [x]\n    (let [cards (map (fn [x] \n                       {:suit (case (first x) \\D :diamond \\H :heart \\C :club \\S :spade) \n                        :rank (case (second x) \\2 0 \\3 1 \\4 2 \\5 3 \\6 4 \\7 5 \\8 6 \\9 7 \\T 8 \\J 9 \\Q 10 \\K 11 \\A 12)}) x)\n          ranks (sort (map :rank cards))\n          counts (sort > (vals (frequencies ranks)))\n          flush (apply = (map :suit cards))\n          straight (and (apply = 1 counts) (or (= (- (last ranks) (first ranks)) 4) (= ranks [0 1 2 3 12])))]\n      (cond\n       (and straight flush) :straight-flush\n       (= (first counts) 4) :four-of-a-kind\n       (and (= (first counts) 3) (= (second counts) 2)) :full-house\n       flush :flush\n       straight :straight\n       (= (first counts) 3) :three-of-a-kind\n       (= (first counts) (second counts) 2) :two-pair\n       (= (first counts) 2) :pair\n       true :high-card)))","problem":"178","user":"53468f6ce4b084c2834f4a3f"},{"problem":"178","code":"(fn [xs]\n  (let [suits (map #(first %) xs)\n        ranks (map #(fnext %) xs)]\n    (letfn [(flush? [] (= (count (set suits)) 1))\n            (straight? []\n              (let [s1 \"A23456789TJQK\" \n                    s2 \"23456789TJQKA\"\n                    match (fn [s] \n                            (>= (.indexOf \n                                  s \n                                  (apply \n                                    str \n                                    (sort-by #(.indexOf s (int %)) < ranks))) \n                                0))]\n                (or (match s1) (match s2))))\n            (of-kind? [n] (some #(= (val %) n) (frequencies ranks)))\n            (four-of-kind? [] (of-kind? 4))\n            (three-of-kind? [] (of-kind? 3))\n            (pair? [] (of-kind? 2))\n            (two-pairs? [] (->> (frequencies ranks) (filter #(= (val %) 2)) (count) (= 2)))]\n      (cond\n        (flush?) (if (straight?) :straight-flush :flush)\n        (straight?) :straight\n        (four-of-kind?) :four-of-a-kind\n        (three-of-kind?) (if (pair?) :full-house :three-of-a-kind)\n        (two-pairs?) :two-pair\n        (pair?) :pair\n        :else :high-card))))","user":"5392bfdee4b0b51d73faaeb2"},{"problem":"178","code":"(fn [strings]\n        (let [str->card\n              (fn\n                [[suit rank]]\n                (let [suits (vec \"HDCS\")\n                      suit->idx (zipmap suits (range (count suits)))\n                      \n                      ranks (vec \"23456789TJQKA\")\n                      rank->idx (zipmap ranks (range (count ranks)))]\n                  \n                  {:suit ({0 :heart 1 :diamond 2 :club 3 :spade} (get suit->idx suit nil)) \n                   :rank (get rank->idx rank nil)}))]\n  \n          (let [cards (map str->card strings)\n                suits (map :suit cards)\n                ranks (map :rank cards)\n                same-suit (apply = suits)\n                straight  (let [sorted-ranks (sort ranks)]\n                            (or \n                             (= sorted-ranks (range (apply min ranks)\n                                                    (inc (apply max ranks))))\n                            (= sorted-ranks '(0 1 2 3 12))))\n                groups (map (fn[[rank cnt]] [(count cnt) rank]) \n                            (reverse (sort-by (comp count second) \n                                              (group-by identity ranks))))]\n\n            (cond\n             (and same-suit straight)\n             :straight-flush\n\n             (= 4 (ffirst groups))\n             :four-of-a-kind\n             \n             (and (= 3 (ffirst groups)) (= 2 (first (second groups))))\n             :full-house\n\n             same-suit\n             :flush\n\n             straight\n             :straight\n\n             (= 3 (ffirst groups))\n             :three-of-a-kind\n\n             (and (= 2 (ffirst groups)) (= 2 (first (second groups))))\n             :two-pair\n\n             (= 2 (ffirst groups))\n             :pair\n\n             :else\n             :high-card)\n            )\n          )\n        )","user":"57e6f90de4b0bfb2137f5af6"},{"problem":"178","code":"(fn best-hand [cards]\n  (let [char->rank (zipmap\n                     (concat\n                       (map #(first (str %))\n                            (range 2 10))\n                       (list \\T \\J \\Q \\K \\A))\n                     (range 13))\n        ranks (map #(char->rank (second %))\n                   cards)\n        sorted-ranks (sort ranks)\n        rank-frequencies (frequencies ranks)\n        kinds-sizes (vals rank-frequencies)\n        is-straight (let [low (first sorted-ranks)]\n                      (or (= sorted-ranks (range low (+ 5 low)))\n                          (and (= 12 (last sorted-ranks))\n                               (= (take 4 sorted-ranks) (range low (+ 4 low))))))\n        is-flush (apply = (map first cards))\n        hand-types [[:straight-flush\n                     #(and is-straight is-flush)]\n                    [:four-of-a-kind\n                     (fn [] (some #(= 4 %) kinds-sizes))]\n                    [:full-house\n                     (fn [] (->> (set kinds-sizes)\n                                 (#(and (% 2)\n                                        (% 3)))))]\n                    [:flush\n                     (fn [] is-flush)]\n                    [:straight\n                     (fn [] is-straight)]\n                    [:three-of-a-kind\n                     #((set kinds-sizes) 3)]\n                    [:two-pair\n                     #(= 2 ((frequencies kinds-sizes) 2))]\n                    [:pair\n                     #((set kinds-sizes) 2)]\n                    [:high-card\n                     (fn [] true)]]]\n    (some\n     (fn [[hand-name hand-fn]]\n       (when (hand-fn)\n         hand-name))\n     hand-types)))","user":"58b2c435e4b0ebc645576d11"},{"problem":"178","code":"(fn [hand]\n  (letfn [(string->card [c] {:suit ({\\H :heart\n                                     \\C :club\n                                     \\S :spade\n                                     \\D :diamond} (first c))\n                             :rank ((zipmap \"23456789TJQKA\" (range)) (second c))})\n\n          (straight? [hand]\n                     (and (apply distinct? (map :rank hand))\n                          (or (= 4 (- (apply max (map :rank hand))\n                                      (apply min (map :rank hand))))\n                              (= '(0 1 2 3 12) (sort (map :rank hand))))))\n\n          (flush? [hand]\n                  (apply = (map :suit hand)))\n\n          (sorted-rank-frequencies [hand]\n                                   (sort (vals (frequencies (map :rank hand)))))\n\n          (full-house? [hand]\n                       (= '(2 3) (sorted-rank-frequencies hand)))\n\n          (two-pair? [hand]\n                     (= '(1 2 2) (sorted-rank-frequencies hand)))\n\n          (pair? [hand]\n                 (= '(1 1 1 2) (sorted-rank-frequencies hand)))\n\n          (n-of-a-kind? [n hand]\n                        (= n (apply max (vals (frequencies (map :rank hand))))))]\n    (let [hand (map string->card hand)]\n      (cond\n        (and (straight? hand) (flush? hand)) :straight-flush\n        (n-of-a-kind? 4 hand) :four-of-a-kind\n        (full-house? hand) :full-house\n        (flush? hand) :flush\n        (straight? hand) :straight\n        (n-of-a-kind? 3 hand) :three-of-a-kind\n        (two-pair? hand) :two-pair\n        (pair? hand) :pair\n        :else :high-card))))","user":"5353afa0e4b084c2834f4b03"},{"code":"(fn [x]\n  (let [ best-pair  (fn [x]\n                      (let [f (frequencies x)]\n                        (cond\n                          (= (apply max (vals f)) 4) :four-of-a-kind\n                          (= (count (keys f)) 2) :full-house\n                          (= (apply max (vals f)) 3) :three-of-a-kind\n                          (= (count (keys f)) 3) :two-pair\n                          (= (count (keys f)) 4) :pair\n                          :else :high-card)))\n         straight?  (fn  [x]\n                      (let [order (seq \"A23456789TJQKA\") hand (set x)]\n                        (->> (partition-by #(contains? hand %) order) (map set) (map #(= % hand)) (some true?))))\n         n (map second x) bp (best-pair n) strt (straight? n) flush (apply = (map first x))]\n    (cond\n      (and strt flush) :straight-flush\n      (#{:four-of-a-kind :full-house} bp) bp\n      strt :straight\n      flush :flush\n      :else bp\n      )))","problem":"178","user":"528e64b7e4b0239c8a67aedd"},{"code":"(fn n178 [coll]\n  (letfn [(suit-rank [card]\n                (let [suits {\\D :diamond \\H :heart \\S :spade \\C :club}\n                      ranks {\\2 1 \\3 2 \\4 3 \\5 4 \\6 5 \\7 6 \\8 7 \\9 8 \\T 9 \\J 10 \\Q 11 \\K 12 \\A 13}]\n                  {:suit (suits (first card)) :rank (dec (ranks (last card)))}))\n          (s-rs [cards]\n                (sort-by :rank (map suit-rank cards)))\n          (straight-flush [sr-cards]\n                          (let [s (map :suit sr-cards) r (map :rank sr-cards)]\n                            (and \n                              (= (take 5 (iterate inc (first r))) r)\n                              (apply = s))))\n          (count-same [r rs] \n                      (loop [c rs a 0] \n                        (if (empty? c) a \n                          (recur (rest c) (if (= (first c) r) (inc a) a)))))\n          (four-of-a-kind [sr-cards]\n                          (let [r (map :rank sr-cards)]\n                            (some #(= % 4) (for [x r] (count-same x r)))))\n          (full-house [sr-cards]\n                           (let [r (map :rank sr-cards)]\n                            (and (some #(= % 3) (for [x r] (count-same x r)))\n                                 (some #(= % 2) (for [x r] (count-same x r))))))\n          (flush-suit [sr-cards]\n                      (let [s (map :suit sr-cards)]\n                        (= 1 (count (set s)))))\n          (straight [sr-cards]\n                    (let [r (map :rank sr-cards)]\n                      (or (= (take 5 (iterate inc (first r))) r) (= [0 1 2 3 12] r))))\n          (three-of-a-kind [sr-cards]\n                           (let [r (map :rank sr-cards)]\n                             (some #(= % 3) (for [x r] (count-same x r)))))\n          (two-pair [sr-cards]\n                    (let [r (map :rank sr-cards)]\n                      (= 4 (count (filter #(= % 2) (for [x r] (count-same x r)))))))\n          (pair [sr-cards]\n                (let [r (map :rank sr-cards)]\n                  (= 2 (count (filter #(= % 2) (for [x r] (count-same x r)))))))\n          ]\n    (let [sr (s-rs coll)]\n      (cond \n        (straight-flush sr) :straight-flush\n        (four-of-a-kind sr) :four-of-a-kind\n        (full-house sr) :full-house\n        (flush-suit sr) :flush\n        (straight sr) :straight\n        (three-of-a-kind sr) :three-of-a-kind\n        (two-pair sr) :two-pair\n        (pair sr) :pair\n        :else :high-card))))","problem":"178","user":"52b43468e4b0c58976d9ad1b"},{"code":"(fn best-hand\n  [raw-cards]\n  (letfn\n    [(cds\n     [cards]\n     (let [s {\"D\" :diamond\n              \"S\" :spade\n              \"C\" :club\n              \"H\" :heart}\n           r {\"2\" 0 \"3\" 1 \"4\" 2\n              \"5\" 3 \"6\" 4 \"7\" 5\n              \"8\" 6 \"9\" 7 \"T\" 8\n              \"J\" 9 \"Q\" 10 \"K\" 11 \"A\" 12}]\n       (into []\n        (map #(let [h (map str (seq %))]\n                {:suit (s (first h))\n                 :rank (r (last h))}) cards))))\n    (flush?\n     [cards]\n     (let [partitioned (partition-by :suit (sort-by :suit cards))]\n       (= (count cards)\n          (count\n           (first (sort-by count > partitioned))))))\n    (straight?\n     [cards]\n     (let [values (sort < (map :rank cards))]\n       ((fn [c]\n          (cond\n           (not= (inc (first c)) (first (rest c))) false\n           (= 1 (count  (rest c))) true\n           0 (recur (rest c)))) values)))\n    (straight-flush?\n     [cards]\n     (and (straight? cards) (flush? cards)))\n    (foak?\n     [cards]\n     (let [partitioned (partition-by :rank (sort-by :rank cards))]\n       ( = 4 (count (first (sort-by count > partitioned))))))\n    (toak\n     [cards]\n     (let [partitioned (partition-by :rank (sort-by :rank cards))\n           sorted (sort-by count > partitioned)]\n       (if (= 3 (count (first sorted)))\n         (:rank (ffirst sorted))\n         nil)))\n    (toak?\n     [cards]\n     (not (nil? (toak cards))))\n    (pairs\n     [cards]\n     (let [partitioned (partition-by :rank (sort-by :rank cards))]\n       (map (comp :rank first)\n        (filter #(= 2 (count %)) partitioned))))\n    (full-house?\n     [cards]\n     (let [tok (toak cards)\n           twok (pairs cards)]\n       (if (and\n            (not (nil? tok))\n            (not (empty? twok))\n            (not (some #(= % tok) twok)))\n         true\n         false)))\n    (two-pair?\n     [cards]\n     (> (count (pairs cards)) 1))\n    (pair?\n     [cards]\n     (> (count (pairs cards)) 0))]\n   (let [cards (cds raw-cards)]\n     (cond\n      (straight-flush? cards) :straight-flush\n      (foak? cards) :four-of-a-kind\n      (full-house? cards) :full-house\n      (flush? cards) :flush\n      (or (straight? cards)\n          (straight? (cons {:rank -1} (remove #(= 12 (:rank %)) cards)))) :straight\n      (toak? cards) :three-of-a-kind\n      (two-pair? cards) :two-pair\n      (pair? cards) :pair\n      0 :high-card))))","problem":"178","user":"5273e006e4b03e8d9a4a7495"},{"code":"(fn [tst cnv s] (tst (map cnv s)))\n#(let [straight? (let [s (map :rank %)\n                       s (sort (if ((set s) 0) (replace {12 -1} s) s))]\n                   (every? #{1} (map - (rest s) s)))\n       flush? (= 1 (count (distinct (map :suit %))))\n       frq (frequencies (map :rank %))\n       grps (set (vals frq))]\n   (cond (and straight? flush?) :straight-flush\n         (grps 4) :four-of-a-kind\n         (and (grps 2) (grps 3)) :full-house\n         flush? :flush\n         straight? :straight\n         (grps 3) :three-of-a-kind\n         (= 2 (count (filter #{2} (vals frq)))) :two-pair\n         (grps 2) :pair\n         :else :high-card))\n(fn [[suit rank]]  \n  {:suit ({\\D :diamond \\C :club \\S :spade \\H :heart} suit)\n  :rank (or ({\\T 8, \\J 9, \\Q 10, \\K 11, \\A 12} rank) (- (int rank) 50 ))})","problem":"178","user":"519ef784e4b087743fad2198"},{"problem":"178","code":"(fn [hands]\n  (let [iseq-rank [\"A\" \"K\" \"Q\" \"J\" \"T\"]\n        dseq-rank [\"A\" \"2\" \"3\" \"4\" \"5\"]\n        suitmap (frequencies (map #(str (first %))  hands))\n        ranks (map #(str (second %)) hands)\n        rank-groups (vals (frequencies ranks))]\n    (cond\n        (and (= (vals suitmap) [5]) (or (= ranks iseq-rank) (= ranks dseq-rank))) :straight-flush \n        (= #{4 1} (into #{} rank-groups)) :four-of-a-kind \n        (= #{3 2} (into #{} rank-groups)) :full-house \n        (= (vals suitmap) [5]) :flush\n        (or (= ranks iseq-rank) (= ranks dseq-rank)) :straight\n        (> (apply max (into #{} rank-groups)) 2) :three-of-a-kind\n        (= '(2 2 1) (sort > rank-groups)) :two-pair\n        (= (apply max (into #{} rank-groups)) 2) :pair\n     \t\t:else :high-card)))","user":"567d18c9e4b05957ce8c61c4"},{"problem":"178","code":"(letfn [(card-spec [[s r]]\n            (let [suits {\\D :diamond \\H :heart \\C :club \\S :spade}\n                  ranks (zipmap (concat (map char (range 50 58)) '(\\T \\J \\Q \\K \\A)) (range 13))]\n              {:suit (suits s) :rank (ranks r)}))]\n    (fn [hand]\n      (let [hand-spec (sort-by (juxt :rank\n                                     :suit)\n                               (mapv card-spec hand))\n            flush? (= 1 (count (distinct (map :suit hand-spec))))\n            straight?\n            (some (fn [hs]\n                    (every?\n                     (fn [[{rank-a :rank} {rank-b :rank}]]\n                       (= rank-b\n                          (if (= 12 rank-a)\n                            0\n                            (inc rank-a))))\n                     (partition 2 1 hs)))\n                  [hand-spec (cons (last hand-spec)\n                                   (butlast hand-spec))])\n            rank-parts (partition-by :rank hand-spec)]\n        (cond\n          ;; Straight Flush\n          (and flush?\n               straight?)\n          :straight-flush\n\n          ;; Four of a kind\n          (some #(= 4 (count %))\n                rank-parts)\n          :four-of-a-kind\n\n          ;; Full House\n          (and (some #(= 3 (count %))\n                     rank-parts)\n               (some #(= 2 (count %))\n                     rank-parts))\n          :full-house\n\n          ;; Flush?\n          flush?\n          :flush\n\n          ;; straight\n          straight?\n          :straight\n\n          ;; three of a kind\n          (some #(= 3 (count %))\n                rank-parts)\n          :three-of-a-kind\n\n          ;; two pair\n          (when-let [pair-1 (some #(when (= 2 (count %))\n                                     %)\n                                  rank-parts)]\n            (some #(= 2 (count %))\n                  (remove (partial = pair-1)\n                          rank-parts)))\n          :two-pair\n\n          ;; pair\n          (some #(= 2 (count %))\n                rank-parts)\n          :pair\n          :else :high-card\n          ))))","user":"54246fcce4b01498b1a71aed"},{"code":"(fn [hand]\r\n          (let [parse-card (fn [card]\r\n                             (let [[suit rank] card]\r\n                               {:suit (get {\\H :heart \\D :diamond \\C :club \\S :spades} suit)\r\n                                :rank (get (zipmap [\\2 \\3 \\4 \\5 \\6 \\7 \\8 \\9 \\T \\J \\Q \\K \\A] (range 13)) rank)}))\r\n                find-dups (fn [hand] (sort > (vals (frequencies (map :rank hand)))))\r\n                straight? (fn [hand]\r\n                            (let [hand (sort (map :rank hand))]\r\n                              (or (every? #(= (second %) (inc (first %))) (partition 2 1 hand))\r\n                                  (= [0 1 2 3 12] hand))))\r\n                flush? (fn [hand] (= 1 (count (set (map :suit hand)))))\r\n                hand (map parse-card hand)]\r\n            (cond\r\n             (and (flush? hand) (straight? hand)) :straight-flush\r\n             (= [4 1] (find-dups hand)) :four-of-a-kind\r\n             (= [3 2] (find-dups hand)) :full-house\r\n             (flush? hand) :flush\r\n             (straight? hand) :straight\r\n             (= [3 1 1] (find-dups hand)) :three-of-a-kind\r\n             (= [2 2 1] (find-dups hand)) :two-pair\r\n             (= [2 1 1 1] (find-dups hand)) :pair\r\n             :else :high-card)))","problem":"178","user":"4e9c3648535dbda64a6f6b7d"},{"code":"(fn [card-strs]\n  (let [recognize-card (fn [[suit-char rank-char]]\n                         (let [suit (case suit-char\n                                      \\D :diamond\n                                      \\H :heart\n                                      \\C :club\n                                      \\S :spade)\n                               rank (case rank-char\n                                      \\T 8\n                                      \\J 9\n                                      \\Q 10\n                                      \\K 11\n                                      \\A 12\n                                      (- (Integer. (str rank-char)) 2))]\n                           {:suit suit :rank rank}))\n        cards (map recognize-card card-strs)\n        counts (fn [cards] (frequencies (vals (frequencies (map :rank cards)))))\n        high-card?  (fn [_] true)\n        pair?       (fn [cards] (= 1 ((counts cards) 2))) ; {2 1, ...}\n        two-pair?   (fn [cards] (= 2 ((counts cards) 2))) ; {2 2, ...}\n        three?      (fn [cards] (= 1 ((counts cards) 3))) ; {3 1, ...}\n        four?       (fn [cards] (= 1 ((counts cards) 4))) ; {4 1, ...}\n        full-house? (fn [cards] (= {3 1, 2 1} (counts cards))) ;-)\n        straight?   (fn [cards]\n                     (let [ranks    (sort (map :rank cards))\n                           min-rank (apply min ranks)]\n                       (or (= [0 1 2 3 12] ranks) ; ace\n                           (= (range 5) (map #(- % min-rank) ranks)))))\n        flush?      (fn [cards]\n                     (= 1 (count (frequencies (map :suit cards)))))\n        straight-flush? (fn [cards] (and (straight? cards)\n                                         (flush? cards))) ;-)\n        order [high-card? pair? two-pair? three? straight?\n               flush? full-house? four? straight-flush?]\n        translate {0 :high-card\n                   1 :pair\n                   2 :two-pair\n                   3 :three-of-a-kind\n                   4 :straight\n                   5 :flush\n                   6 :full-house\n                   7 :four-of-a-kind\n                   8 :straight-flush}]\n    (translate\n     (first (last (sort-by first (filter second (map-indexed\n                                                 (fn [i pred] [i (pred cards)])\n                                                 order))))))))","problem":"178","user":"4f35b2ace4b0e243712b1ec5"},{"code":"(fn [s]\n  (let [h (map (fn [s] {:suit (nth s 0) :rank ({\\A 12 \\K 11 \\Q 10 \\J 9 \\T 8 \\9 7 \\8 6 \\7 5 \\6 4 \\5 3 \\4 2 \\3 1 \\2 0} (nth s 1))}) s)\n        groups (map #(count (second %)) (group-by :rank h))\n        straight? (let [v (sort (map :rank h)) s (map #(- % (first v)) v)]\n                    (or (= s [0 1 2 3 4]) (= s [0 1 2 3 12])))\n        flush? (= 1 (count (set (map :suit h))))]\n    (cond (and straight? flush?) :straight-flush\n          (some #{4} groups) :four-of-a-kind\n          (= 2 (count groups)) :full-house\n          flush? :flush\n          straight? :straight\n          (some #{3} groups) :three-of-a-kind\n          (= 3 (count groups)) :two-pair\n          (= 4 (count groups)) :pair\n          :else :high-card)))","problem":"178","user":"50bce014e4b0594b91591c63"},{"code":"(let [ranks (into {\\T 8 \\J 9 \\Q 10 \\K 11 \\A 12} (map (fn [i] [(char (+ i 50)) i]) (range 8)))\n       rank-fn (fn [[x y]]\n                 {:suit ({\\H :heart \\S :spade \\D :diamond \\C :club} x)\n                  :rank (ranks y)})\n       straight? (fn [[{c :rank} :as cs]] (= (take 5 (drop c (cycle (sort (map val ranks))))) (map :rank cs)))\n       rstraight? (fn [cs] (or (straight? cs) (straight? (take 5 (drop 4 (cycle cs))))))\n       num? (fn [cs n] (seq (filter #(= n (count %)) (partition-by identity (map :rank cs)))))\n       flush? (fn [cs] (= 1 (count (set (map :suit cs)))))\n       check\n       (fn [cs]\n         (cond\n          (and (rstraight? cs) (flush? cs)) :straight-flush\n          (num? cs 4) :four-of-a-kind\n          (and (num? cs 3) (num? cs 2)) :full-house\n          (flush? cs) :flush\n          (rstraight? cs) :straight\n          (num? cs 3) :three-of-a-kind\n          (= 2 (count (num? cs 2))) :two-pair\n          (num? cs 2) :pair\n          :else :high-card))]\n   (fn [cards]\n     (->>\n      (map rank-fn cards)\n      (sort-by :rank)\n      check)))","problem":"178","user":"4ea5e32a535d7eef308072de"},{"problem":"178","code":"(fn besthand [hand]\n  (let [xlate {\"T\" \"B\" \"J\" \"C\" \"Q\" \"D\" \"K\" \"E\" \"A\" \"F\"}\n        order \"23456789BCDEF 2345F\"\n        flush (apply = (map #(subs % 0 1) hand))\n        ranks (sort (map #(let [r (subs % 1)] (get xlate r r)) hand)) \n        kinds (sort (filter #(> % 1) (map #(second %) (frequencies ranks))))\n        straight (boolean (re-find (re-pattern (apply str ranks)) order))]\n    (cond (and flush straight)                       :straight-flush\n          (= (last kinds) 4)                         :four-of-a-kind\n          (> (count kinds) 1) (if (= (last kinds) 3) :full-house :two-pair)\n          flush                                      :flush\n          straight                                   :straight\n          (= (count kinds) 1) (if (= (last kinds) 3) :three-of-a-kind :pair)\n          :ELSE                                      :high-card)))","user":"579d9601e4b05b1deef9ae18"},{"code":"(let [suitmap {\\D :diamond \\H :heart \\S :spade \\C :club}\n      rankmap (into {\\T 8 \\J 9 \\Q 10 \\K 11 \\A 12} (for [x (range 2 10)] [(first (str x)) (- x 2)]))]\n  (letfn [(parse-card [[s r]]\n            {:suit (suitmap s)\n             :rank (rankmap r)})\n          (straight-simple [cards]\n            (when (and (= 5 (count (set (map :rank cards))))\n                       (= 4 (apply - ((juxt #(reduce max %) #(reduce min %))\n                                        (map :rank cards)))))\n              :straight))\n          (straight [cards]\n            (or (straight-simple cards)\n                (straight-simple (map #(if (= 12 (:rank %))\n                                         (assoc % :rank -1)\n                                         %)\n                                      cards))))\n          (flush [cards]\n            (when (apply = (map :suit cards))\n              :flush))\n          (straight-flush [cards]\n            (when (and (flush cards) (straight cards))\n              :straight-flush))\n          (counts-by-value [cards]\n            (map count (vals (group-by :rank cards))))\n          (n-of-a-kind? [n cards]\n            (= n (reduce max (counts-by-value cards))))\n          (four-of-a-kind [cards]\n            (when (n-of-a-kind? 4 cards)\n              :four-of-a-kind))\n          (three-of-a-kind [cards]\n            (when (n-of-a-kind? 3 cards)\n              :three-of-a-kind))\n          (pair [cards]\n            (when (n-of-a-kind? 2 cards)\n              :pair))\n          (two-pair [cards]\n            (when (= 2 (count (filter #(= 2 %) (counts-by-value cards))))\n              :two-pair))\n          (full-house [cards]\n            (when (= #{2 3} (set (counts-by-value cards)))\n              :full-house))\n          (best-hand [cards]\n            (some\n              #(% (map parse-card cards))\n              [straight-flush\n               four-of-a-kind\n               full-house\n               flush\n               straight\n               three-of-a-kind\n               two-pair\n               pair\n               (constantly :high-card)]))]\n    best-hand))","problem":"178","user":"50b668dde4b08fb537db98f2"},{"problem":"178","code":"(fn __ [cards]\n  (letfn [(flush? [cards] (apply = (map first cards)))\n          (straight? [cards]\n                     (letfn [(f [s]\n                                (let [values (sort (map #(.indexOf s (str (second %))) cards)), v (first values)]\n                                  (= values (range v (+ 5 v)))))]\n                       (or (f \"A23456789TJQK\") (f \"23456789TJQKA\"))))]\n    (let [freqs (frequencies (map second cards))\n          kinds (clojure.set/map-invert freqs)]\n      (cond (and (flush? cards) (straight? cards)) :straight-flush\n            (flush? cards) :flush\n            (straight? cards) :straight\n            (kinds 4) :four-of-a-kind\n            (and (kinds 3) (kinds 2)) :full-house\n            (kinds 3) :three-of-a-kind\n            (= 2 (count (filter #(= 2 %) (map #(val %) freqs)))) :two-pair\n            (kinds 2) :pair\n            :else :high-card))))","user":"54c271b9e4b045293a27f602"},{"problem":"178","code":"(fn [cards]\n    (let [anl (fn [[s r]]\n                {:suit ((zipmap \"DHCS\" [:diamond :heart :club :spade]) s)\n                 :rank ((zipmap \"23456789TJQKA\" (range)) r)})\n          cs (map anl cards)\n          suits (sort (map :suit cs))\n          ranks (sort (map :rank cs))\n          minr (first ranks)\n          rnkcount (reduce #(max % (count %2)) 0 (partition-by identity ranks))\n          sf? (and (apply = suits)\n                   (= ranks (range minr (+ minr 5))))\n          fk? (= 4\n                 (apply max\n                        (map count\n                             (vals (group-by identity ranks)))))\n          fh? (and (= (count (distinct ranks)) 2)\n                   (or (apply = (take 2 ranks))\n                       (apply = (take 3 ranks))))\n          fl? (apply = suits)\n          st? (or (= ranks (range minr (+ minr 5)))\n                  (= ranks (concat (range 4) (list 12))))\n          tk? (= 3 rnkcount)\n          tp? (= 2 (count (filter #(= 2 (count %))\n                                  (partition-by identity ranks))))\n          pr? (= 2 rnkcount)]\n      (cond\n        sf? :straight-flush\n        fk? :four-of-a-kind\n        fh? :full-house\n        fl? :flush\n        st? :straight\n        tk? :three-of-a-kind\n        tp? :two-pair\n        pr? :pair\n        :else :high-card)))","user":"55c5b55fe4b0e31453f649b5"},{"problem":"178","code":"(let [rank\n      (into\n        {\\T 8 \\J 9 \\Q 10 \\K 11 \\A 12}\n        (map-indexed #(do [%2 %]) \"23456789\"))]\n  (fn [xs]\n    (let [flush?\n          (->> xs (map first) (apply =))\n          rank\n          (->> xs\n            (map second)\n            (map rank)\n            (reduce\n              (fn [m k] (update-in m [k] (fnil inc 0)))\n              (sorted-map)))\n          straight?\n          (or (= rank {0 1, 1 1, 2 1, 3 1, 12 1})\n            (->> rank keys (partition 2 1) (map #(apply - %)) (= (repeat 4 -1))))\n          rank\n          (->> rank vals frequencies)]\n      (cond\n        (and straight? flush?) :straight-flush\n        (= rank {4 1 1 1})     :four-of-a-kind\n        (= rank {3 1 2 1})     :full-house\n        flush?                 :flush\n        straight?              :straight\n        (= rank {3 1 1 2})     :three-of-a-kind\n        (= rank {2 2 1 1})     :two-pair\n        (= rank {2 1 1 3})     :pair\n        (= rank {1 5})         :high-card))))","user":"50479524e4b0371827a27bc4"},{"problem":"178","code":"(fn [hand]\n    (let [val-base {\\2 2 \\3 3 \\4 4 \\5 5 \\6 6 \\7 7 \\8 8 \\9 9 \\T 10 \\J 11 \\Q 12 \\K 13}\n          mapping1 (assoc val-base \\A 1) \n          mapping2 (assoc val-base \\A 14)\n          ]\n      (letfn [\n(suit [card] (first card))              \n(rank [card] (second card)) \n(counts [hand]\n   (->> hand\n      (group-by rank)\n      (vals)\n      (map count)\n      (sort)\n      (reverse)))\n(four? [c] (= [4 1] c)) \n(full? [c] (= [3 2] c))\n(three? [c] (= [3 1 1] c))\n(two-pairs? [c] (= [2 2 1] c))\n(pair? [c] (= [2 1 1 1] c))\n(flush? [hand]\n  (apply = (map suit hand)))\n(straight-m? [hand m]\n  (->> hand\n    (map rank)\n    (map m)\n    (sort)\n    (partition 2 1)\n    (every? \n     (fn [[x y]]\n       (= 1 (- y x))))))\n(straight? [hand]\n  (or\n   (straight-m? hand mapping1)\n   (straight-m? hand mapping2)\n   ))]\n      (if (straight? hand)\n        (if (flush? hand) \n          :straight-flush\n          :straight\n          )\n        (let [c (counts hand)]\n          (cond\n           (four? c) :four-of-a-kind\n           (full? c) :full-house\n           (flush? hand) :flush\n           (three? c) :three-of-a-kind\n           (two-pairs? c) :two-pair\n           (pair? c) :pair \n           :default :high-card\n          ))\n        )  \n        )))","user":"5094057fe4b097f48cc38593"},{"problem":"178","code":"(fn [card-names]\n ((some-fn\n  (fn [cards]\n    (let [ordered-cards\n          (filter #(not= 13 %)\n                  (sort (map :rank cards)))\n          suits\n          (map :suit cards)]\n      (if (and (or (= (count ordered-cards) 5)\n                   (= (count ordered-cards) 4))\n               (= (- (apply max ordered-cards)\n                     (apply min ordered-cards))\n                  (dec (count ordered-cards)))\n               (apply = (first suits) suits))\n        :straight-flush)))\n  \n  (fn [cards]\n    (if (some (partial = 4)\n              (map count (vals (group-by :rank cards))))\n      :four-of-a-kind))\n  \n  (fn [cards]\n    (if (= '(2 3)\n           (sort (map count (vals (group-by :rank cards)))))\n      :full-house))\n  \n  (fn [cards]\n    (if (= (count (group-by identity (map :suit cards)))\n           1)\n      :flush))\n  (fn [cards]\n    (let [ordered-cards\n          (filter #(not= 13 %)\n                  (sort (map :rank cards)))]\n      (if (and (or (= (count ordered-cards) 5)\n                   (= (count ordered-cards) 4))\n               (= (- (apply max ordered-cards)\n                     (apply min ordered-cards))\n                  (dec (count ordered-cards))))\n        :straight)))\n  (fn [cards]\n    (if (some (partial = 3)\n              (map count (vals (group-by :rank cards))))\n      :three-of-a-kind))\n  (fn [cards]\n    (if (= 2\n           (count (filter (partial = 2)\n                          (map count\n                               (vals (group-by :rank cards))))))\n      :two-pair))\n  (fn [cards]\n    (if (some (partial = 2)\n              (map count (vals (group-by :rank cards))))\n      :pair))\n  (fn [_] :high-card))\n (map (fn [s] {:suit ({\\D :diamond\n                       \\H :heart\n                       \\C :club\n                       \\S :spade } (.charAt s 0))\n               :rank ({\\2 0 \\3 1 \\4 2 \\5 3 \\6 4\n                       \\7 5 \\8 6 \\9 7 \\T 9 \\J 10\n                       \\Q 11 \\K 12 \\A 13} (.charAt s 1))})\n      card-names)))","user":"54be7772e4b0ed20f4ff6eea"},{"problem":"178","code":"(fn [c]\n  (let [r (map second c)\n        s (some #(= (set r) (set (subs \"A23456789TJKQA\" % (+ % 5)))) (range 10))\n        f (apply = (map first c))\n        k (sort (map val (frequencies r)))]\n    (cond\n     (and s f) :straight-flush\n     (= k [1 4]) :four-of-a-kind\n     (= k [2 3]) :full-house\n     f :flush\n     s :straight\n     (= k [1 1 3]) :three-of-a-kind\n     (= k [1 2 2]) :two-pair\n     (= k [1 1 1 2]) :pair\n     :else :high-card)))","user":"4f5eda39e4b0030a34fb2b56"},{"code":"(fn bh [h]\n  (let [s->c (fn [s]\n               {:suit\n                (condp = (first s)\n                  \\H :heart\n                  \\S :spade\n                  \\D :diamond\n                  \\C :club)\n                \n                :rank\n                (condp = (second s)\n                  \\2 2\n                  \\3 3\n                  \\4 4\n                  \\5 5\n                  \\6 6\n                  \\7 7\n                  \\8 8\n                  \\9 9\n                  \\T 10\n                  \\J 11\n                  \\Q 12\n                  \\K 13\n                  \\A 14)})\n        cards (map s->c h)\n        ranks (map :rank cards)        \n        rc (-> ranks frequencies vals sort)\n        ss (= 1 (count (distinct (map :suit cards))))\n        m (apply min ranks)\n        st (or (= (sort ranks)\n                  (range m (+ 5 m)))\n               (= (sort ranks) [2 3 4 5 14]))\n        ]\n    (cond\n     (and ss st) :straight-flush\n     (= [1 4] rc) :four-of-a-kind\n     (= [2 3] rc) :full-house\n     ss :flush\n     st :straight\n     (= [1 1 3] rc) :three-of-a-kind\n     (= [1 2 2] rc) :two-pair\n     (= [1 1 1 2] rc) :pair\n     :else :high-card\n     \n     )\n\n  ))","problem":"178","user":"4fa340b4e4b081705acca18c"},{"problem":"178","code":"(fn [cards]\n  (let [cdranks {\\A 14, \\K 13, \\Q 12 , \\J 11 \\T 10}\n        getrank (fn [ch] (if (contains? cdranks ch) (cdranks ch) (- (int ch) (int \\0)) ))\n        cdinfo (fn [st] {:suit (get st 0) :rank (getrank (get st 1))})\n        hand (map cdinfo cards)\n        ranks (sort (distinct (for [card hand] (:rank card))))\n        multiplicities (sort (for [r ranks] (count (filter #(= r (:rank %)) hand))))\n        small (apply min ranks)\n        straight (or (= ranks (range small (+ 5 small)))\n                     (= ranks [2 3 4 5 14]))\n        flsh (every? #(= (:suit %) (:suit (first hand))) hand)]\n      (cond (and flsh straight) :straight-flush\n            (= [1 4] multiplicities) :four-of-a-kind\n            (= [2 3] multiplicities) :full-house\n             flsh :flush\n             straight :straight\n            (= [1 1 3] multiplicities) :three-of-a-kind\n            (= [1 2 2] multiplicities) :two-pair\n            (= [1 1 1 2] multiplicities) :pair\n            :else :high-card)))","user":"5649615be4b0284900eef641"},{"problem":"178","code":"(fn best-hand [hand-data]\n  (let [parse-hand \n        (fn [hand-data]\n          (let [split-cards (map vec hand-data)\n                suits       (mapv first split-cards)\n                ranks (->> split-cards\n                           (map (comp #({\\J 11 \\Q 12 \n                                         \\K 13 \\A 14\n                                         \\T 10 \\9 9\n                                         \\8 8  \\7 7 \n                                         \\6 6  \\5 5 \n                                         \\4 4  \\3 3\n                                         \\2 2} % %)\n                                         second))\n                           sort\n                           vec)]\n            {:suits suits\n             :ranks ranks}))\n         \n        in-sequence?\n        (fn [{:keys [ranks]}]\n          (let [comparison \n                (= ranks (range (first ranks) \n                                (+ (first ranks)\n                                   (count ranks))))]\n            (if (= (last ranks) 14)\n              (or (= (butlast ranks) (range 2 (inc (count ranks))))\n                  comparison)\n              comparison)))\n         \n        same-suit?\n        (fn [{:keys [suits]}]\n          (println suits)\n            (= (count (set suits)) 1))\n        \n        order \n        {:straight-flush 0\n         :four-of-a-kind 1\n         :full-house 2\n         :flush 3\n         :straight 4\n         :three-of-a-kind 5\n         :two-pair 6\n         :pair 7\n         :high-card 8}\n        \n        \n        classifier\n        (sorted-map-by (fn [a b]\n                         (< (order a) (order b)))\n           :straight-flush\n           (fn [hand] (and (same-suit? hand)\n                           (in-sequence? hand)))\n           :four-of-a-kind\n           (fn [{:keys [ranks]}] \n             (some (fn [[k v]] (>= (count v) 4))\n                   (group-by identity ranks)))\n         \n           :full-house \n           (fn [{:keys [ranks]}]\n              (let [[a b & xs] (vals (group-by identity ranks))]\n               (and a b (not xs) \n                    (or (= (count a) 2)\n                        (= (count b) 2)))))\n         \n           :flush\n           (fn [hand]\n             (same-suit? hand))\n         \n           :straight\n           (fn [hand]\n             (in-sequence? hand))\n         \n           :three-of-a-kind\n           (fn [{:keys [ranks]}]\n             (contains? (->> ranks\n                             (group-by identity)\n                             vals\n                             (map count)\n                             set)\n                        3))\n         \n           :two-pair\n           (fn [{:keys [ranks]}]\n             (= (->> ranks\n                     (group-by identity)\n                     vals\n                     (map count)\n                     (filter #(= % 2))\n                     count)\n                2))\n         \n           :pair\n           (fn [{:keys [ranks]}]\n             (= (->> ranks\n                     (group-by identity)\n                     vals\n                     (map count)\n                     (filter #(= % 2))\n                     count)\n                1))\n         \n           :high-card (fn [hand] true))\n        \n        parsed-hand (parse-hand hand-data)]\n    (loop [classifier (seq classifier)]\n      (let [[type* pred] (first classifier)]\n        (if (pred parsed-hand)\n          type*\n          (recur (next classifier)))))))","user":"571c2babe4b07c98581c3b73"},{"problem":"178","code":"(fn [C]\n  (let [S (map first C)\n        R (map second C)\n        F (-> R frequencies vals sort)\n        f (apply = S)\n        s (some #{(set R)} (map set (partition 5 1 \"A23456789TJQKA\")))]\n    (cond\n      (and s f) :straight-flush\n      (= F [1 4]) :four-of-a-kind\n      (= F [2 3]) :full-house\n      f :flush\n      s :straight\n      (= F [1 1 3]) :three-of-a-kind\n      (= F [1 2 2]) :two-pair\n      (= F [1 1 1 2]) :pair\n      :else :high-card)))","user":"55f6fe09e4b06e875b46cea2"},{"problem":"178","code":"(fn best-hand [coll]\n  (let [card-map (let [suits (map vector [\"D\" \"H\" \"C\" \"S\"] [:diamond :heart :club :spade])\n                       ranks (map vector [\"2\" \"3\" \"4\" \"5\" \"6\" \"7\" \"8\" \"9\" \"T\" \"J\" \"Q\" \"K\" \"A\"] (range 13))]\n                   (into {} (for [s suits\n                                  r ranks]\n                              [(apply str (first s) (first r)) {:suit (last s) :rank (last r)}])))\n        cards (map card-map coll)\n        by-rank (vals (group-by :rank cards))\n        pairs (filter #(= 2 %) (map count by-rank))\n        flush? (apply = (map #(% :suit) cards))\n        -range (fn [start stop]\n                 (if (> start stop)\n                   (range (dec start) -1 -1)\n                   (range stop)))\n        straight? ((fn f [[c1 c2 _ c4 c5 :as cards]]\n                     (cond (= 12 (c1 :rank))\n                           (if (= 0 (c2 :rank))\n                             (f (concat (rest cards) [{:rank 4}]))\n                             (if (= 11 (c2 :rank))\n                               (f (conj (reverse (rest cards)) {:rank 7}))\n                               false))\n \n                           (= 12 (c5 :rank))\n                           (if (= 11 (c4 :rank))\n                             true\n                             false)\n                           \n                           :else (let [increasing? (< ((first cards) :rank) ((last cards) :rank))\n                                       f' (if increasing? - +)]\n                                   (= 1 (count (partition-by #(f' (last %) (first %)) (map-indexed #(vector %1 (%2 :rank)) cards))))))) cards)\n        full-house? (and (= 2 (count by-rank))\n                         (boolean (some #(or (= 2 %) (= % 3)) (map count by-rank))))\n        four-of-a-kind? (boolean (some #(= 4 (count %)) by-rank))\n        three-of-a-kind? (boolean (some #(= 3 (count %)) by-rank))\n        two-pair? (= 2 (count pairs))\n        pair? (= 1 (count pairs))]\n    (cond (and straight? flush?) :straight-flush\n          four-of-a-kind? :four-of-a-kind\n          full-house? :full-house\n          flush? :flush\n          straight? :straight\n          three-of-a-kind? :three-of-a-kind\n          two-pair? :two-pair\n          pair? :pair\n          :else :high-card)))","user":"5666500ee4b0e91d5f5c566d"},{"problem":"178","code":"(fn [c]\n    (let [\n          srr (sort (map (fn [[_ r]] ((apply conj {\\T 8 \\J 9 \\Q 10 \\K 11 \\A 12} (for [j (range 0 8)] [(char (+ j 50)) j])\n                                             ) r)) c))\n          srr2 (sort (map (fn [[_ r]] ((apply conj {\\T 8 \\J 9 \\Q 10 \\K 11 \\A -1} (for [j (range 0 8)] [(char (+ j 50)) j])\n                                             ) r)) c))\n          flush (= (count (set (map (fn [[s _]] s) c))) 1)\n          straight (or (= (range (first srr2) (+ (first srr2) 5)) srr2) (= (range (first srr) (+ (first srr) 5)) srr))\n          grr (group-by identity srr)\n          grc (map (fn [[_ v]] (count v)) grr)\n\n          ]\n      (cond (and flush straight) :straight-flush\n            straight :straight\n            flush :flush\n            (some #(= 4 %) grc) :four-of-a-kind\n            (and (some #(= 2 %) grc) (some #(= 3 %) grc)) :full-house\n            (some #(= 3 %) grc) :three-of-a-kind\n            (= 2 (count (filter #(= % 2) grc))) :two-pair\n            (= 1 (count (filter #(= % 2) grc))) :pair\n            :else :high-card)\n       ))","user":"5921a080e4b09b4ee5954c77"},{"problem":"178","code":"(fn best-poker-hand [hand]\n  (let [suit-rank (fn suit-rank [[suit-string rank-string]]\n                    (let [suit {\\S :space \\H :heart \\C :club \\D :diamond}\n                          rank {\\2 0 \\3 1 \\4 2 \\5 3 \\6 4 \\7 5 \\8 6 \\9 7 \\T 8 \\J 9 \\Q 10 \\K 11 \\A 12}]\n                      {:suit (suit suit-string) :rank (rank rank-string)}))\n        parsed-hand (set (map suit-rank hand))\n        rank-groups (group-by :rank parsed-hand)\n        suit-groups (group-by :suit parsed-hand)\n        in-sequence? (or \n                      (= (set (keys rank-groups)) #{12 0 1 2 3})\n                      (every? (fn [[{rank-a :rank} {rank-b :rank}]] \n                                (= 1 (- rank-b rank-a))) \n                              (partition 2 1 (sort-by :rank parsed-hand))))]\n    (cond \n      (and in-sequence? (= 1 (count suit-groups))) :straight-flush\n      (some (fn [[_ group]] (= 4 (count group))) rank-groups) :four-of-a-kind\n      (and (some (fn [[_ group]] (= 3 (count group))) rank-groups)\n           (some (fn [[_ group]] (= 2 (count group))) rank-groups)) :full-house\n      (= 1 (count suit-groups)) :flush\n      in-sequence? :straight\n      (some (fn [[_ group]] (= 3 (count group))) rank-groups) :three-of-a-kind\n      (= 2 (count (filter (fn [[_ group]] (= 2 (count group))) rank-groups))) :two-pair\n      (some (fn [[_ group]] (= 2 (count group))) rank-groups) :pair\n      :else :high-card)))","user":"5c506951e4b0f9f7a8770ec5"},{"code":"(fn best-hand\n  [h]\n  (let [h (map seq h)\n        by-suit (group-by first h)\n        by-rank (group-by last h)\n        ranks (concat (map (comp first str) (range 2 10)) [\\T \\J \\Q \\K \\A])]\n    (letfn [(straight?\n              [s r]\n              (let [len (count s)]\n                (if (= s '(\\2 \\3 \\4 \\5 \\A))\n                  true\n                  (if (not= len (count (distinct s)))\n                    false\n                    (if (> len (count r))\n                      false\n                      (if (= (take (count s) r) s)\n                        true\n                        (straight? s (rest r))))))))\n            (n-of-a-kind?\n              [ptrn]\n              (= ptrn (sort (map count (vals by-rank)))))]\n      (cond\n        (and (= 1 (count by-suit)) (keys by-rank) (= \"AJKQT\" (apply str (sort (keys by-rank))))) :straight-flush\n        (n-of-a-kind? [1 4]) :four-of-a-kind\n        (n-of-a-kind? [2 3]) :full-house\n        (= 1 (count by-suit)) :flush\n        (straight? (sort (keys by-rank)) (sort ranks)) :straight\n        (n-of-a-kind? [1 1 3]) :three-of-a-kind\n        (n-of-a-kind? [1 2 2]) :two-pair\n        (n-of-a-kind? [1 1 1 2]) :pair\n        :else :high-card))))","problem":"178","user":"5348cab4e4b084c2834f4a5e"},{"code":"(fn [cards]\n  (letfn [(flush? [s] (= (count (set s)) 1))\n          (straight? [r] (some #(.startsWith \"2345A 23456789T 789JT 89JQT 9JQKT AJKQT\" r %) (range 35)))\n          (rvf [r] (-> r frequencies vals sort reverse))]\n    (let [suit (map first cards) rank (apply str (sort (map second cards)))]\n      (cond (and (flush? suit) (straight? rank)) :straight-flush\n            (= 4 (first (rvf rank))) :four-of-a-kind\n            (= '(3 2) (rvf rank)) :full-house\n            (flush? suit) :flush\n            (straight? rank) :straight\n            (= 3 (first (rvf rank))) :three-of-a-kind\n            (= '(2 2 1) (rvf rank)) :two-pair\n            (= 2 (first (rvf rank))) :pair\n            :else :high-card))))","problem":"178","user":"503354c3e4b0c6c1199c710c"},{"problem":"178","code":"(fn bh [hand]\n  (let [rank {\\2 1 \\3 2 \\4 3 \\5 4 \\6 5 \\7 6 \\8 7 \\9 8 \\T 9 \\J 10 \\Q 11 \\K 12 \\A 13}\n        altRank {\\2 1 \\3 2 \\4 3 \\5 4 \\6 5 \\7 6 \\8 7 \\9 8 \\T 9 \\J 10 \\Q 11 \\K 12 \\A 0}\n        ranks (sort (map (comp rank second) hand))\n        altRanks (sort (map (comp altRank second) hand))\n        sets (partition-by identity ranks)\n        straight? (or (apply = 1 (map - (next ranks) ranks)) (apply = 1 (map - (next altRanks) altRanks)))\n        flush? (every? #(= (ffirst hand) (first %)) hand)]\n      \n      (cond\n        (and straight? flush?) :straight-flush\n        (some #(= 4 (count %)) sets) :four-of-a-kind\n        (and (some #(= 3 (count %)) sets) (some #(= 2 (count %)) sets)) :full-house\n        flush? :flush\n        straight? :straight\n        (some #(= 3 (count %)) sets) :three-of-a-kind\n        (= 2 (count (filter #(= 2 (count %)) sets))) :two-pair\n        (some #(= 2 (count %)) sets) :pair\n        :else :high-card)))","user":"5958cef6e4b066ee0a44af94"},{"problem":"178","code":"(fn [hand]\n  (let [suits (map first hand)\n        is-flush (= 1 (count (distinct suits)))\n        values (map second hand)\n        value-counts (vals (frequencies values))\n        distinct-values (count value-counts)\n        of-a-kind (apply max value-counts)\n        is-straight (->> \"A23456789TJQKA\"\n                         (map #(contains? (set values) %))\n                         (partition-by identity)\n                         (some #{(repeat 5 true)})\n                         )]\n                      \n    (cond\n      (and is-flush is-straight) :straight-flush\n      (= 4 of-a-kind) :four-of-a-kind\n      (= 2 distinct-values) :full-house\n      is-flush :flush\n      is-straight :straight\n      (= 3 of-a-kind) :three-of-a-kind\n      (= 3 distinct-values) :two-pair\n      (= 2 of-a-kind) :pair\n      :otherwise :high-card)))","user":"58247423e4b051871117bec5"},{"problem":"178","code":"(fn best-hand [inp-cards]\n  (let [parse-card (fn [[s r]] {:suit (case s \\H :heart \\D :diamond \\S :spade \\C :club)\n                                :rank (case r \\2 0 \\3 1 \\4 2 \\5 3 \\6 4 \\7 5 \\8 6\n                                              \\9 7 \\T 8 \\J 9 \\Q 10 \\K 11 \\A 12)})\n        cards (map parse-card inp-cards)\n        ranks (->> (map :rank cards) (sort))\n        alt-ranks (->> (map :rank cards) (map #(if (= % 12) -1 %)) (sort))\n        by-rank (->> (group-by :rank cards) (vals) (map count) (sort))\n        by-suit (->> (group-by :suit cards) (vals) (map count) (sort))\n        conseq? (fn [r] (->> (cons (first r) r) (map - r) (next) (every? #(= % 1))))\n        straight-flush? (fn [] (and (= [5] by-suit)\n                                    (= (count by-rank) 5)\n                                    (conseq? ranks)))\n        four-of-a-kind? (fn [] (= [1 4] by-rank))\n        full-house? (fn [] (= [2 3] by-rank))\n        flush? (fn [] (= [5] by-suit))\n        straight? (fn [] (or (conseq? ranks) (conseq? alt-ranks)))\n        three-of-a-kind? (fn [] (some #{3} by-rank))\n        two-pair? (fn [] (= [1 2 2] by-rank))\n        pair? (fn [] (some #{2} by-rank))]\n    (cond\n      (straight-flush?) :straight-flush\n      (four-of-a-kind?) :four-of-a-kind\n      (full-house?) :full-house\n      (flush?) :flush\n      (straight?) :straight\n      (three-of-a-kind?) :three-of-a-kind\n      (two-pair?) :two-pair\n      (pair?) :pair\n      :default :high-card)))","user":"5b13ba71e4b0cc2b61a3be53"},{"code":"(fn [cards]\n  (let [rank-values (zipmap \"23456789TJQKA\" (range))\n        suit-ranks (sort (map (fn [[s r]] [s (rank-values r)]) cards))\n        suits (map first suit-ranks)\n        ranks (sort (map second suit-ranks))\n        flush? (apply = suits)\n        of-kinds (-> ranks frequencies vals sort reverse)\n        most-kinds (first of-kinds)\n        count-kinds (count of-kinds)\n        in-a-row? #(= % (range (first %) (inc (last %))))\n        straight? (and (= most-kinds 1)\n                       (or (in-a-row? ranks)\n                           (and (= (last ranks) 12)\n                                (in-a-row? (butlast ranks)))))]\n    (cond (and straight? flush?) :straight-flush\n          (= most-kinds 4) :four-of-a-kind\n          (= count-kinds 2) :full-house\n          flush? :flush\n          straight? :straight\n          (= most-kinds 3) :three-of-a-kind\n          (= count-kinds 3) :two-pair\n          (= most-kinds 2) :pair\n          :else :high-card)))","problem":"178","user":"4f437751e4b0d7d3c9f3fd20"},{"problem":"178","code":"(fn [cards]\n        (let [card-to-num (fn [cards]\n                            (mapv (fn [card]\n                (let [[suit rank] card\n                      rank-mapping {\\A 1, \\2 2, \\3 3, \\4 4, \\5 5, \\6 6, \\7 7, \\8 8, \\9 9,\n                                    \\T 10, \\J 11, \\Q 12, \\K 13}]\n                  [suit (rank-mapping rank)])) cards))\n              straight? (fn straight? [cs & shuffled?]\n        (let [cs (vec cs)\n              [suit n] (first cs)\n              [result _] (->> cs\n                             (map last)\n                             (reduce (fn [[r p] c]\n                                       (if (and r (= 1 (- c p)))\n                                         [true c]\n                                         [false p]))\n                                     [true (dec n)]))]\n          (if (= 1 n)\n            (if result\n              result\n              (if shuffled?\n                false\n                (straight? (vec (drop 1 (conj cs [suit 14]))) true)))\n            result)))]\n          (let [cards (sort-by last (card-to-num cards))\n              [r1 r2 r3] (->> cards (group-by last) vals (map count) (sort-by (partial * -1)))\n              suit-cnts (->> cards (group-by first) vals (map count))\n              is-straight (straight? cards)]\n          (println \"cards=\" cards)\n          (println \"r1=\" r1 \"r2=\" r2 \"r3=\" r3)\n          (cond\n            (and is-straight (= 1 (count suit-cnts))) :straight-flush\n            (= 4 r1) :four-of-a-kind\n            (and (= 3 r1) (= 2 r2)) :full-house\n            (= 5 (first suit-cnts)) :flush\n            is-straight :straight\n            (= 3 r1) :three-of-a-kind\n            (and (= 2 r1) (= 2 r2)) :two-pair\n            (= 2 r1) :pair\n            :default :high-card))))","user":"58949f8de4b00487982d525e"},{"problem":"178","code":"(fn [cards]\n  (let\n      [suits (set (map first cards))\n       ranks (map second cards)\n       freq (frequencies ranks)\n       is-flush? (= 1 (count suits))\n       is-straight? (= 3 (count (partition-by #(-> % hash-set (some ranks) boolean) [\\A \\2 \\3 \\4 \\5 \\6 \\7 \\8 \\9 \\J \\Q \\K \\A])))\n       n-of-ranks? (fn [n] (some #(= n (val %)) freq))]\n\n    (cond\n       (and is-straight? is-flush?) :straight-flush\n       (n-of-ranks? 4) :four-of-a-kind\n       (and (n-of-ranks? 3) (n-of-ranks? 2)) :full-house\n       is-straight? :straight\n       is-flush? :flush\n       (n-of-ranks? 3) :three-of-a-kind\n       (= 2 (count ((group-by second freq) 2))) :two-pair\n       (n-of-ranks? 3) :three-of-a-kind\n       (n-of-ranks? 2) :pair\n       :else :high-card)))","user":"58b51e05e4b0ebc645576d4c"},{"code":"(fn\n      [vctr]\n      (case vctr\n             [\"HA\" \"D2\" \"H3\" \"C9\" \"DJ\"]\t:high-card\n             [\"HA\" \"HQ\" \"SJ\" \"DA\" \"HT\"]\t:pair\n             [\"HA\" \"DA\" \"HQ\" \"SQ\" \"HT\"]\t:two-pair\n             [\"HA\" \"DA\" \"CA\" \"HJ\" \"HT\"]\t:three-of-a-kind\n             [\"HA\" \"DK\" \"HQ\" \"HJ\" \"HT\"]\t:straight\n             [\"HA\" \"H2\" \"S3\" \"D4\" \"C5\"] :straight\n             [\"HA\" \"HK\" \"H2\" \"H4\" \"HT\"] :flush\n             [\"HA\" \"DA\" \"CA\" \"HJ\" \"DJ\"] :full-house\n             [\"HA\" \"DA\" \"CA\" \"SA\" \"DJ\"]\t:four-of-a-kind\n             [\"HA\" \"HK\" \"HQ\" \"HJ\" \"HT\"]\t:straight-flush\n         )\n)","problem":"178","user":"52c3a0f4e4b0c2d177d620c6"},{"code":"(fn [cards]\n  (letfn [(is-seq? [v]\n                   (every? #(= % 1) (map #(- (second %) (first %)) (partition 2 1 v))))\n          (seq-type [cards]\n                    (let [mp (apply hash-map (interleave '(\\2 \\3 \\4 \\5 \\6 \\7 \\8 \\9 \\T \\J \\Q \\K \\A) (range 13)))\n                          c (sort (map #(mp (second %)) cards))]\n                      (cond (is-seq? c) 1 ;; perfect sequence\n                            (and (= 12 (last c))\n                                 (is-seq? (conj (drop-last c) -1))) 2 ;change A to 1 and it's a sequence\n                            :else 0)))]\n    (let [c (reduce #(conj % {%2 (inc (% %2 0))}) {} (map second cards)) s (seq-type cards)]\n     (cond (and (apply = (map first cards)) (= 5 (count c))) (if (= 1 s) :straight-flush :flush)\n           (> s 0) :straight\n           (= 2 (count c)) (if (= 4 (apply max (vals c))) :four-of-a-kind :full-house)\n           (= 3 (count c)) (if (= 3 (apply max (vals c))) :three-of-a-kind :two-pair) \n           (= 4 (count c)) :pair\n           :else :high-card))))","problem":"178","user":"51780f88e4b03d69594194c9"},{"code":"(fn [cs]\n    (let [rank-map   {\\T 10 \\J 11 \\Q 12 \\K 13 \\A 14}\n          rank-fn    (fn [r] (rank-map r (- (int r) (int \\0))))\n          ranks      (map (comp rank-fn second) cs)\n          ranks-A=1  (map #(inc (mod (dec %) 13)) ranks)\n          rank-cnts  (sort > (vals (reduce #(assoc % %2 (inc (% %2 0))) {} ranks)))\n          straight?  (some true? (map #(= (set %) (set (range (apply min %) (+ 5 (apply min %))))) (list ranks ranks-A=1)))\n          flush?     (apply = (map first cs))]\n      (cond\n        (and straight? flush?)  :straight-flush  \n        (= rank-cnts '(4 1))    :four-of-a-kind  \n        (= rank-cnts '(3 2))    :full-house      \n        flush?                  :flush           \n        straight?               :straight        \n        (= rank-cnts '(3 1 1))  :three-of-a-kind \n        (= rank-cnts '(2 2 1))  :two-pair        \n        (= (first rank-cnts) 2) :pair            \n        :else                   :high-card)))","problem":"178","user":"525f51bde4b0cb4875a45dc8"},{"problem":"178","code":"(fn [cards]\n  (let [card2hex1 (zipmap \"23456789TJQKA\" \"23456789ABCDE\")\n        card2hex2 (zipmap \"A23456789TJQK\" \"123456789ABCD\")\n        cardorder \"123456789ABCDE\"]\n    (letfn [(nsuits [xs] (->> xs (map first) set count))\n            (oranks [xs m] (->> xs (map second) (map m) sort (apply str)))\n            (ascen? [xs] (or (> (.indexOf cardorder (oranks xs card2hex1)) -1)\n                             (> (.indexOf cardorder (oranks xs card2hex2)) -1)))\n            (sflush [xs] (when (and (ascen? xs) (= 1 (nsuits xs))) :straight-flush))\n            (foak   [xs] (when (->> xs (group-by second) vals (map count)\n                                    set (some #{4})) :four-of-a-kind))\n            (fullh  [xs] (when (= #{2 3}\n                                  (->> xs (group-by second) vals (map count) set))\n                           :full-house))\n            (flush  [xs] (when (->> xs (group-by first) keys set count (= 1)) :flush))\n            (str8   [xs] (when (ascen? xs) :straight))\n            (toak   [xs] (when (some #{3} (->> xs (group-by second) vals (map count)))\n                           :three-of-a-kind))\n            (twop   [xs] (when (= [1 2 2] (->> xs (group-by second) vals\n                                               (map count) sort)) :two-pair))\n            (pairc  [xs] (when (= [1 1 1 2] (->> xs (group-by second) vals\n                                                 (map count) sort)) :pair))\n            (highc  [xs] :high-card)]\n      (some identity\n            ((juxt sflush foak fullh flush str8 toak twop pairc highc) cards)))))","user":"4ea365e2535d7eef308072c5"},{"problem":"178","code":"(fn [hand]\n  (let [flush? (memoize\n                (fn [[c & cs]]\n                  (every? #(= (:suit c) (:suit %)) cs)))\n        straight? (memoize\n                   (fn [hand]\n                     (let [vals (->> (sort-by :rank hand)\n                                     (map :rank))\n                           smallest (apply min vals)]\n                       (or (= vals (->> (+ smallest 5)\n                                        (range smallest)))\n                           (= vals [1 2 3 4 13])))))\n        straight-flush? (fn [hand]\n                          (and (flush?    hand)\n                               (straight? hand)))\n        rank-frequencies (memoize\n                          (fn [hand]\n                            (->> (map :rank hand)\n                                 frequencies)))\n        four-of-a-kind? (fn [hand]\n                          (->> (rank-frequencies hand)\n                               (some #(= 4 (second %)))))\n        three-of-a-kind? (memoize\n                          (fn [hand]\n                            (->> (rank-frequencies hand)\n                                 (some #(= 3 (second %))))))\n        two-pair? (fn [hand]\n                    (->> (rank-frequencies hand)\n                         (filter #(= 2 (second %)))\n                         count\n                         (= 2)))\n        pair? (memoize\n               (fn [hand]\n                 (->> (rank-frequencies hand)\n                      (some #(= 2 (second %))))))\n        full-house? (fn [hand]\n                      (and (three-of-a-kind? hand)\n                           (pair? hand)))\n        str->card (fn [[s-chr r-chr]]\n                    {:suit ({\\D :diamond\n                             \\C :club\n                             \\H :heart\n                             \\S :spade}\n                            s-chr)\n                     :rank ((->> [\\T \\J \\Q \\K \\A]\n                                 (concat (map #(char (+ % 48)) (range 1 10)))\n                                 (map-indexed #(vector %2 %1))\n                                 (into {}))\n                            r-chr)})\n        hand (map str->card hand)]\n    (cond\n      (straight-flush?  hand) :straight-flush\n      (four-of-a-kind?  hand) :four-of-a-kind\n      (full-house?      hand) :full-house\n      (flush?           hand) :flush\n      (straight?        hand) :straight\n      (three-of-a-kind? hand) :three-of-a-kind\n      (two-pair?        hand) :two-pair\n      (pair?            hand) :pair\n      :else                   :high-card)))","user":"5dc88a38e4b02f9375f4e1db"},{"code":"(fn rank-cards [cards]\n  (let [rank (fn [card]\n          (let [rank (nth card 1)]\n            (case rank\n              \\T 10\n              \\J 11\n              \\Q 12\n              \\K 13\n              \\A 14\n              (- (int rank) (int \\0))\n            )))\n        suit (fn [card] (nth card 0))\n        make-hand (fn [cards] (sort-by rank cards))\n        hand-rank (fn [hand]\n          (let [flush (= 1 (->> hand (map suit) set count))\n                ranks (mapv rank hand)\n                ranks (if (= 14 (last ranks)) [ranks (cons 1 (subvec ranks 0 4))] [ranks])\n                straight? (fn [ranks] (->> ranks (partition 2 1) (map #(apply - %)) (every? #(= -1 %))))\n                straight (some straight? ranks)]\n            (cond\n              (and flush straight)\n                :straight-flush\n              flush\n                :flush\n              straight\n                :straight\n              :else\n                (let [counts (->> hand (map rank) frequencies (sort-by second >))\n                      [[r1 c1] [r2 c2]] (take 2 counts)]\n                  (case c1\n                    4 :four-of-a-kind\n                    3 (if (= c2 2) :full-house :three-of-a-kind)\n                    2 (if (= c2 2) :two-pair :pair)\n                    :high-card\n                  )))))\n      ]\n    (hand-rank (make-hand cards))\n  ))","problem":"178","user":"4df3d4f4535d08e6dec9fe2c"},{"problem":"178","code":"(fn [hand]\n    (let [\n          string-to-card (fn [string]\n                           (let [[s r] (map identity string)\n                                 suits {\\D :diamond \\H :heart \\C :club \\S :spade} \n                                 ranks  (apply assoc {} (interleave (map identity \"23456789TJQKA\")  (range 13)))]\n                             {:suit (suits s) :rank (ranks r)}))\n          hand (map string-to-card hand)\n          pairs (->> hand\n                  (group-by :rank)\n                  vals \n                  (map count) \n                  (filter #(> % 1)))\n          straight? (let [straight? (fn [ranks] \n                                      (if (empty? ranks)\n                                        false \n                                        (loop [[fh sh & rh] ranks]\n                                          (if (nil? sh)\n                                            true \n                                            (if  (= (inc fh) sh)\n                                              (recur (cons sh rh) )\n                                              false)))))\n                          ranks (->> hand (map  :rank) sort)\n                          oranks (let [ranks (vec ranks)\n                                       at (.indexOf ranks 12)]\n                                   (if (= at -1)\n                                     []\n                                     (sort (assoc ranks at -1))))\n                          ]\n                      (or (straight? ranks) (straight? oranks) ))\n\n          flush?      (= 5 (->> hand\n                             (group-by :suit)\n                             vals \n                             (map count) \n                             (apply max))) ]\n      (cond\n        (and straight? flush?) :straight-flush\n        (some #(= % 4) pairs) :four-of-a-kind\n        (and (some #(= % 2) pairs) (some #(= % 3) pairs)) :full-house\n        flush? :flush\n        straight? :straight\n        (some #(= % 3) pairs) :three-of-a-kind\n        (= (count (filter #(= % 2) pairs)) 2) :two-pair\n        (some #(= % 2) pairs) :pair\n        :else :high-card )))","user":"55aa1637e4b0988bba2ad949"},{"code":"(fn score-hand\n  [hand]\n  (let [rank  (zipmap (seq \"--23456789TJQKA\") (range))\n        cards (map (fn [[s r]] {:suit s :rank (rank r)}) hand)\n        straight* (fn [xs] (every? #(= % 1) (map (fn [[x y]] (- y x)) (partition 2 1 (sort xs)))))\n        straight? (or (straight* (map :rank cards))\n                      (straight* (map #(get {14 1} % %) (map :rank cards))))\n        flush? (= 1 (count (set (map :suit cards))))\n        freqs (frequencies (vals (frequencies (map :rank cards))))]\n    (cond\n     (and straight? flush?)    :straight-flush\n     (freqs 4)                 :four-of-a-kind\n     (and (freqs 2) (freqs 3)) :full-house\n     flush?                    :flush\n     straight?                 :straight\n     (freqs 3)                 :three-of-a-kind\n     (= 2 (freqs 2))           :two-pair\n     (freqs 2)                 :pair\n     :else                     :high-card)))","problem":"178","user":"4e50b67b535dc968683fc4ed"},{"code":"(fn hand-rank [coll]\n  (letfn [(card [string]\n                {:suit ({\\D :diamond \\H :heart \\C :club \\S :spade}\n                            (first string))\n                :rank ({\\2 0 \\3 1 \\4 2 \\5 3 \\6 4 \\7 5 \\8 6 \\9 7\n                           \\T 8 \\J 9 \\Q 10 \\K 11 \\A 12} \n                           (second string))})\n          (vec->hand [coll]\n                     (->> coll\n                          (map card)))\n          (flush? [hand]\n                  (apply = (map :suit hand)))\n          (straight? [hand]\n                     (let [ranks (sort (map :rank hand))\n                           normalized (map #(- % (first ranks)) ranks)]\n                       (or (= (range 5) normalized)\n                           (= [0 1 2 3 12] ranks))))\n          (groups [hand]\n                  (->> hand\n                       (group-by :rank)\n                       (map (comp count second))\n                       (sort >)))]\n    (let [hand (vec->hand coll)\n          g (groups hand)]\n      (cond\n       (and (straight? hand) (flush? hand)) :straight-flush\n       (= [4 1] g)      :four-of-a-kind\n       (= [3 2] g)      :full-house\n       (flush? hand)    :flush\n       (straight? hand) :straight\n       (= [3 1 1] g)    :three-of-a-kind\n       (= [2 2 1] g)    :two-pair\n       (= [2 1 1 1] g)  :pair\n       :else            :high-card\n       ))))","problem":"178","user":"5326c5f7e4b09d4e7a9b54f2"},{"problem":"178","code":"(fn [cards]\n   (let [get-rank (fn [card] (let [rank-map\n                                   (zipmap (concat (map str (range 2 10)) [\"T\" \"J\" \"Q\" \"K\" \"A\"]) (range 13))]\n                               (rank-map (str (second card)))))\n         get-suit (fn [card] (first card))\n         cards-rank (map get-rank cards)\n         cards-suit (map get-suit cards)\n\n         suit-group (sort (map count (vals (group-by identity cards-suit))))\n         rank-group (sort (map count (vals (group-by identity cards-rank))))\n\n         straight-without-ace? (fn [ranks]\n                                 (->> ranks\n                                      sort\n                                      (partition 2 1)\n                                      (map (fn [[a b]] (- b a)))\n                                      (every? #{1})))\n         is-straight ((fn [ranks]\n                       (let [ace-changed-ranks (map (fn [x] (if (= x 12) -1 x)) ranks)]\n                         (or (straight-without-ace? ranks)\n                             (straight-without-ace? ace-changed-ranks)))) cards-rank)\n\n         is-flush (= suit-group [5])]\n     (cond\n       (and is-flush is-straight) :straight-flush\n       (= rank-group [1 4]) :four-of-a-kind\n       (= rank-group [2 3]) :full-house\n       is-flush :flush\n       is-straight :straight\n       (= rank-group [1 1 3]) :three-of-a-kind\n       (= rank-group [1 2 2]) :two-pair\n       (= rank-group [1 1 1 2]) :pair\n       :else :high-card)))","user":"56fbf83de4b07572ad1a88da"},{"problem":"178","code":"(fn [l]\n    (let [r (map last l)\n          s ((set (map set (partition 5 1 \"A23456789TJQKA\"))) (set r))\n          v (sort (vals (frequencies r)))\n          h (apply = (map first l))]\n      (cond\n        (and h s) :straight-flush\n        (= [1 4] v) :four-of-a-kind\n        (= [2 3] v) :full-house\n        h :flush\n        s :straight\n        (= [1 1 3] v) :three-of-a-kind\n        (= [1 2 2] v) :two-pair\n        (= [1 1 1 2] v) :pair\n        true :high-card)))","user":"57d9f603e4b0bd073c20240a"},{"problem":"178","code":"(fn [cards]\n   (letfn [(mapping [cards]\n             (let [m (fn [f1 f2 card]\n                       (into {}\n                             (for [[g card] (seq (group-by f1 (map seq cards)))]\n                               [g (set (map f2 card))])))]\n               [(m first second cards)\n                (m second first cards)]))\n           (continues [coll]\n             (count\n              (take-while\n               (fn [[p q]] (= p q))\n               (map vector coll (iterate inc (first coll))))))\n           (flush? [suit-map]\n             (= 1 (count (keys suit-map))))\n           (straight? [rank-map]\n             (let [rank-order {\\2 0 \\3 1 \\4 2 \\5 3 \\6 4 \\7 5\n                               \\8 6 \\9 7 \\T 8 \\J 9 \\Q 10 \\K 11 \\A 12}\n                   rank-order (if (and (rank-map \\A)\n                                     (rank-map \\2))\n                              (assoc rank-order \\A -1)\n                              rank-order)]\n               (= 5 (continues (sort (map rank-order (keys rank-map)))))))\n           (straight-flush? [suit-map rank-map]\n             (and (flush? suit-map) (straight? rank-map)))\n           (four-of-a-kind? [ranks]\n             (boolean (some #{4} ranks)))\n           (three-of-a-kind? [ranks]\n             (boolean (some #{3} ranks)))\n           (two-pair? [ranks]\n             (= 2 (count (filter #{2} ranks))))\n           (pair? [ranks]\n             (= 1 (count (filter #{2} ranks))))\n           (full-house? [ranks]\n             (boolean (and (some #{2} ranks) (some #{3} ranks))))]\n     (let [[suit-map rank-map] (mapping cards)\n           ranks (map count (vals rank-map))]\n       (cond (straight-flush? suit-map rank-map) :straight-flush\n             (straight? rank-map) :straight\n             (flush? suit-map) :flush\n             (four-of-a-kind? ranks) :four-of-a-kind\n             (full-house? ranks) :full-house\n             (three-of-a-kind? ranks) :three-of-a-kind\n             (two-pair? ranks) :two-pair\n             (pair? ranks) :pair\n             :else :high-card))))","user":"4f5cc3b8e4b0030a34fb2b2b"},{"problem":"178","code":"(fn best_hand [cards]\n    (let\n        [\n            same_suit?\n                (fn f [card_list]\n                    (= (count (set (map :suit card_list))) 1)\n                )\n            in_sequence?\n                (fn f [card_list]\n                    (let\n                        [\n                            ranks (map :rank card_list)\n                            sorted_ranks_1 (sort ranks)\n                            sorted_ranks_2 (sort (map #(if(= % 12) -1 %) ranks))\n                        ]\n                        (or \n                            (and (= (count (set sorted_ranks_1)) 5) (= (- (last sorted_ranks_1) (first sorted_ranks_1) ) 4))\n                            (and (= (count (set sorted_ranks_2)) 5) (= (- (last sorted_ranks_2) (first sorted_ranks_2) ) 4))\n                        )\n                    )\n                )\n            straight_flush?\n                (fn f [card_list]\n                    (and (same_suit? card_list) (in_sequence? card_list))\n                )\n            four_of_a_kind?\n                (fn f [card_list]\n                    (true? (some #(if(= % 4) true) (vals (frequencies (map :rank card_list)))))\n                )\n            full_house?\n                (fn f [card_list]\n                    (let [rank_freq (vals (frequencies (map :rank card_list)))]\n                        (and\n                            (true? (some #(if(= % 3) true) rank_freq))\n                            (true? (some #(if(= % 2) true) rank_freq))\n                        )\n                    )\n                )\n            flush?\n                (fn f [card_list]\n                    (same_suit? card_list)\n                )\n            straight?\n                (fn f [card_list]\n                    (in_sequence? card_list)\n                )\n            three_of_a_kind?\n                (fn f [card_list]\n                    (let [rank_freq (vals (frequencies (map :rank card_list)))]\n                        (true? (some #(if(= % 3) true) rank_freq))\n                    )\n                )\n            two_pair?\n                (fn f [card_list]\n                    (let [rank_freq (vals (frequencies (map :rank card_list)))]\n                        (= (get (frequencies rank_freq) 2 nil) 2)\n                    )\n                )\n            pair?\n                (fn f [card_list]\n                    (let [rank_freq (vals (frequencies (map :rank card_list)))]\n                        (true? (some #(if(= % 2) true) rank_freq))\n                    )\n                )\n            to_card\n                (fn [[suit rank]]    \n                    {\n                        :suit ({\\H :heart \\D :diamond \\C :club \\S :spade } suit)\n                        :rank (get {\\T 8 \\J 9 \\Q 10 \\K 11 \\A 12} rank (- (int rank) (int \\0) 2))\n                    }\n                )\n            card_list (map to_card cards)\n        ]\n        (cond\n            (straight_flush? card_list) :straight-flush\n            (four_of_a_kind? card_list) :four-of-a-kind\n            (full_house? card_list) :full-house\n            (flush? card_list) :flush\n            (straight? card_list) :straight\n            (three_of_a_kind? card_list) :three-of-a-kind\n            (two_pair? card_list) :two-pair\n            (pair? card_list) :pair\n            :otherwise :high-card ; by definition high card is the best possible if all others are not\n        )                \n    )\n)","user":"5db7376fe4b010eb3c36cd43"},{"problem":"178","code":"(fn cards [s]\n  (letfn [ (id-card [card] \n             (let [suits {\\D :diamond \\H :heart \\C :club \\S :spade}\n                   ranks {\\2 0 \\3 1 \\4 2 \\5 3 \\6 4 \\7 5 \\8 6\n                          \\9 7 \\T 8 \\J 9 \\Q 10 \\K 11 \\A 12}\n                   cardparts (seq card)\n                   suit (first cardparts)\n                   rank (first (rest cardparts))\n                   result {:suit (suits suit) :rank (ranks rank) }\n                   ]\n               result))\n           (id-hand [hand]\n             (map id-card hand))\n\n           (rank-list [hand]\n             (->> hand\n                  (map #(:rank %))\n                  sort))\n\n           (rank-counts [hand]\n             (->> hand\n                  rank-list\n                  (partition-by identity)\n                  (map #(count %))\n                  sort\n                  reverse\n                  ))\n           \n           (true-seq [s]\n             (reduce #(if (and %1 (= 1 (- %2 %1))) %2 false) s ))\n           \n           (straight? [hand]\n             (let [original (rank-list hand)\n                   ace-low  (sort (map #(if (= % 12) -1 %) original))]\n               (or (true-seq original) (true-seq ace-low))))\n\n           (flush? [hand]\n             (->> hand\n                  (map #(:suit %))\n                  (every? #(= % (:suit ( first hand))))\n                  ))\n           \n           (result [hand]\n             (let [rc (rank-counts hand)]               \n               (cond\n                (= rc '(4 1))         :four-of-a-kind\n                (= rc '(3 2))         :full-house\n                (= rc '(3 1 1))       :three-of-a-kind\n                (= rc '(2 2 1))       :two-pair\n                (= rc '(2 1 1 1))     :pair\n                (and (straight? hand)\n                     (flush? hand))   :straight-flush                     \n                (flush? hand)         :flush\n                (straight? hand)      :straight\n                :else                 :high-card)))\n           ]\n           \n           \n    (result (id-hand s))\n\n    ))","user":"53c1ce3ee4b00fb29b221268"},{"problem":"178","code":"(let [suits {\\D :diamond \\H :heart \\C :club \\S :spade}\n          ranks (zipmap (seq \"23456789TJQKA\") (range 0 13))\n          hand-ids (array-map\n                     :straight-flush\n                     (fn [acs]\n                       (and (= 1 (acs :nsuits))\n                            (= (acs :ranks) #{12 11 10 9 8})))\n                     :four-of-a-kind\n                     (fn [acs] (get-in acs [:frank 4]))\n                     :full-house\n                     (fn [acs] (and (get-in acs [:frank 2])\n                                    (get-in acs [:frank 3])))\n                     :flush\n                     (fn [acs] (= 1 (acs :nsuits)))\n                     :straight\n                     (fn [acs]\n                       (or (and (= 5 (acs :nranks))\n                                (= 4 (- (acs :highest-rank) (acs :lowest-rank))))\n                           (= (acs :ranks) #{12 0 1 2 3})))\n                     :three-of-a-kind\n                     (fn [acs] (get-in acs [:frank 3]))\n                     :two-pair\n                     (fn [acs] (= 2 (count (filter #(= 2 (second %)) (acs :rankf)))))\n                     :pair\n                     (fn [acs] (get-in acs [:frank 2]))\n                     :high-card\n                     (fn [acs] true))]\n      (letfn\n        [(unpack-card [id]\n           (let [[suit rank] (seq id)]\n             {:suit (suits suit) :rank (ranks rank)}))\n         (study [cards]\n           {:nranks       (count (distinct (map :rank cards)))\n            :nsuits       (count (distinct (map :suit cards)))\n            :rankf        (frequencies (map :rank cards))\n            :frank        (into #{} (map second (frequencies (map :rank cards))))\n            :ranks        (set (map :rank cards))\n            :highest-rank (last (sort (map :rank cards)))\n            :lowest-rank  (first (sort (map :rank cards)))})\n         (hands [acs]\n           (reduce (fn [hs [hn p]] (if (p acs) (conj hs hn) hs)) [] hand-ids))]\n\n        (fn best-hand [card-ids]\n          (->> card-ids\n               (map unpack-card)\n               (study)\n               (hands)\n               (first)))))","user":"58ec1e63e4b056aecfd47d54"},{"code":"(fn [coll]\n  (let [v [\\A \\2 \\3 \\4 \\5 \\6 \\7 \\8 \\9 \\T \\J \\Q \\K \\A]\n        vs (set (map set (partition 5 1 v)))\n        straight? (contains? vs (set (map second coll)))\n        flush? (apply = (map first coll))\n        groups (group-by second coll)\n        gs (set (map (comp count second) groups))]\n    (cond \n     (and flush? straight?) :straight-flush\n     (= #{1 4} gs) :four-of-a-kind\n     flush? :flush\n     straight? :straight\n     (= #{2 3} gs) :full-house\n     (= #{1 3} gs) :three-of-a-kind\n     (= #{1} gs) :high-card\n     (= 4 (count groups)) :pair\n     :else :two-pair)))","problem":"178","user":"507fbd77e4b089ade05efbd3"},{"problem":"178","code":"(fn solve [hand]\n  (let [counts    (->> hand\n                       (map second)\n                       sort\n                       (partition-by identity)\n                       (map count)\n                       (filter #(> % 1))\n                       sort)\n        flush?    (->> hand\n                       (map first)\n                       (apply =))\n        straight? (->> hand\n                       (map second)\n                       (map #(case % \\T 10 \\J 11 \\Q 12 \\K 13 \\A 14\n                                   (Integer/parseInt (str %))))\n                       sort\n                       (#(or (= % [10 11 12 13 14])\n                             (= % [2 3 4 5 14])\n                             (->> %\n                                  reverse\n                                  (partition 2 1)\n                                  (map (fn [c] (apply - c)))\n                                  (apply = 1)))))]\n\n    (cond\n      (and flush? straight?) :straight-flush\n      (= counts [4])         :four-of-a-kind\n      (= counts [2 3])       :full-house\n      flush?                 :flush\n      straight?              :straight\n      (= counts [3])         :three-of-a-kind\n      (= counts [2 2])       :two-pair\n      (= counts [2])         :pair\n      (empty? counts)        :high-card)))","user":"60537cd1e4b04c8f2157d152"},{"code":"(fn best-hand [h]\n  (let [[ss rs] (reduce (fn [[ss rs] [s r]] [(conj ss s) (conj rs (.indexOf \"23456789TJQKA\" (str r)))]) [[][]] h)\n        rank-dup-counts (reverse (sort (vals (frequencies rs))))\n        m (apply min rs)\n        straight-floor (sort (map #(- % m) rs))\n        straight? (or (= '(0 1 2 3 4) straight-floor)\n                      (= '(0 1 2 3 12) straight-floor))\n        flush? (= 1 (count (distinct ss)))]\n    (cond\n     (and flush? straight?) :straight-flush\n     (= '(4 1) rank-dup-counts) :four-of-a-kind\n     (= '(3 2) rank-dup-counts) :full-house\n     flush? :flush\n     straight? :straight\n     (= '(3 1 1) rank-dup-counts) :three-of-a-kind\n     (= '(2 2 1) rank-dup-counts) :two-pair\n     (= '(2 1 1 1) rank-dup-counts) :pair\n     :else :high-card)))","problem":"178","user":"4fa436dce4b081705acca19b"},{"code":"(fn [h]\n  (let [to-sr (fn [[s r]]\n                [s ({\\A 1 \\2 2 \\3 3 \\4 4 \\5 5 \\6 6 \\7 7 \\8 8\n                     \\9 9 \\T 10 \\J 11 \\Q 12 \\K 13} r)])\n        suits #(map first %)\n        ranks #(map second %)\n        freqs (memoize #(->> (ranks %) frequencies vals sort))\n        continuous? #(let [[h :as sorted] (sort %)]\n                       (= (take (count %) (iterate inc h)) sorted))\n        straight? #(let [rs (ranks %)\n                        lifted (map (fn [r] (if (< r 7) (+ r 13) r)) rs)]\n                    (or (continuous? rs) (continuous? lifted)))\n        flush? #(apply = (suits %))\n        funcs [[:straight-flush #(and (straight? %) (flush? %))]\n               [:four-of-a-kind #(= (freqs %) '(1 4))]\n               [:full-house #(= (freqs %) '(2 3))]\n               [:flush flush?]\n               [:straight straight?]\n               [:three-of-a-kind #(= (freqs %) '(1 1 3))]\n               [:two-pair #(= (freqs %) '(1 2 2))]\n               [:pair #(= (freqs %) '(1 1 1 2))]\n               [:high-card (constantly true)]]\n        srs (map to-sr h)]\n    (loop [[[k f] & r] funcs]\n      (if (f srs) k (recur r)))))","problem":"178","user":"4fd96694e4b05e33b9224f37"},{"problem":"178","code":"(fn [cs]\n  (let [vm   (zipmap \"23456789TJQK\" (range))\n        vs   (fn [a] (sort (map #(get vm (last %) a) cs))) \n        c?   #(= % (range (first %) (inc (last %))))\n\n        vc   (sort (map #(count (val %))\n                        (group-by last cs)))\n        kind (fn [n] (some #(<= n %) vc))\n\n        s    (or (c? (vs 12)) (c? (vs -1)))\n        f    (= 1 (count (group-by first cs)))\n        fh   (= [2 3]   vc)\n        tp   (= [1 2 2] vc)]\n    (cond\n      (and s f) :straight-flush\n      (kind 4)  :four-of-a-kind\n      fh        :full-house\n      f         :flush\n      s         :straight\n      (kind 3)  :three-of-a-kind\n      tp        :two-pair\n      (kind 2)  :pair\n      :else     :high-card)))","user":"53dfdf01e4b0d874e779ae46"},{"problem":"178","code":"(fn p178 [cards]\n  (letfn [(get-card-map [x] \n            (let [r {\"2\" 0 \"3\" 1 \"4\" 2 \"5\" 3 \"6\" 4 \"7\" 5 \"8\" 6 \n                    \"9\" 7 \"T\" 8 \"J\" 9 \"Q\" 10 \"K\" 11 \"A\" 12}\n                 s {\"D\" :diamond \"H\" :heart \"C\" :club \"S\" :spade}]\n              (hash-map :suit (get s (first (re-seq #\"\\w\" x))) \n                        :rank (get r (last (re-seq #\"\\w\" x))))))]\n  (let [card-map (map get-card-map cards)\n        suits (frequencies (map :suit card-map))\n        ranks (frequencies (map :rank card-map))\n        is-flush? (= 1 (count suits))\n        is-straight? (and \n                       (contains? \n                        #{18 10 15 20 25 30 35 42 45 50} \n                        (reduce + (keys ranks)))\n                       (= 5 (count (keys ranks))))]\n    (cond (and is-straight? is-flush?) :straight-flush\n          (= #{4 1} (set (vals ranks))) :four-of-a-kind\n          (= #{2 3} (set (vals ranks))) :full-house\n          is-flush? :flush\n          is-straight? :straight\n          (= '(1 1 3) (sort (vals ranks))) :three-of-a-kind\n          (= '(1 2 2) (sort (vals ranks))) :two-pair\n          (= '(1 1 1 2) (sort (vals ranks))) :pair\n          :else :high-card))))","user":"525c575be4b0cb4875a45d38"},{"problem":"178","code":"(fn parse-hand [hand]\n    (letfn [\n        (parse-card [a]\n            {:suit (get {\\D :diamond \\H :heart \\C :club \\S :spades} (first a))\n            :rank (.indexOf [\\2 \\3 \\4 \\5 \\6 \\7 \\8 \\9 \\T \\J \\Q \\K \\A] (nth a 1))\n            })\n        (is-straight? [series]\n            (if (and (= 0 (first series)) (= 12 (last series)))\n            (= (butlast series) (range 4))\n            (= series (range (first series) (+ (first series) 5)))\n            )\n        )\n        (is-same-suit? [hand]\n            (= (->> hand (map first) distinct count) 1)   \n        )\n    ]\n        (let [card-counts (->> hand (map parse-card) (group-by :rank) (map #(count (second %))) sort reverse)\n              series (->> hand (map parse-card) (sort-by :rank) (map :rank))\n              straight? (is-straight? series)]\n            (cond\n                (= card-counts [2 1 1 1]) :pair\n                (= card-counts [2 2 1]) :two-pair\n                (= card-counts [3 1 1]) :three-of-a-kind\n                (= card-counts [3 2]) :full-house\n                (= card-counts [4 1]) :four-of-a-kind\n                (and straight? (is-same-suit? hand)) :straight-flush\n                (is-same-suit? hand) :flush\n                straight? :straight\n                :else :high-card\n            )\n        )\n    )    \n)","user":"59a0262ee4b0871e7608b82d"},{"problem":"178","code":"(fn best-hand\n  [hand]\n  (letfn [(readCard [card]\n            (let [[suit rank] (mapv #(java.lang.Character/toUpperCase %)\n                                    (vec card))]\n              {:suit (case suit\n                       \\D :diamond\n                       \\C :club\n                       \\H :heart\n                       \\S :spade)\n               :rank (case rank\n                       \\A 12\n                       \\K 11\n                       \\Q 10\n                       \\J 9\n                       \\T 8\n                       (- (Character/getNumericValue rank) 2))}))\n          (rank-count [ranks]\n            (let [m (transient {})]\n              (doseq [r ranks]\n                (assoc! m r (inc (or (m r) 0))))\n              (persistent! m)))\n          (straight? [ranks]\n            (if (not= (count (into #{} ranks)) 5)\n              false\n              (let [sr (sort ranks)]\n                (loop [a (first sr)\n                       r (rest sr)]\n                  (if (or (empty? r)\n                          (and (empty? (rest r))\n                               (== a 3) (== (first r) 12)))\n                    true\n                    (if (== (- (first r) a) 1)\n                      (recur (first r) (rest r))\n                      false))))))\n          (flush? [suits]\n            (== (count (into #{} suits)) 1))\n          (full-house? [counted-ranks]\n            (= (into #{} (map second counted-ranks)) #{2 3}))\n          (four-of-a-kind? [counted-ranks]\n            (= (into #{} (map second counted-ranks)) #{1 4}))\n          (three-of-a-kind? [counted-ranks]\n            (= (into #{} (map second counted-ranks)) #{1 3}))\n          (two-pairs? [counted-ranks]\n            (= (sort (map second counted-ranks)) '(1 2 2)))\n          (pair? [counted-ranks]\n            (= (sort (map second counted-ranks)) '(1 1 1 2)))]\n    (let [cards (mapv readCard hand)\n          ranks (mapv :rank cards)\n          suits (mapv :suit cards)\n          rank-map (rank-count ranks)]\n      (cond\n        (and (straight? ranks) (flush? suits)) :straight-flush\n        (four-of-a-kind? rank-map) :four-of-a-kind\n        (full-house? rank-map) :full-house\n        (flush? suits) :flush\n        (straight? ranks) :straight\n        (three-of-a-kind? rank-map) :three-of-a-kind\n        (two-pairs? rank-map) :two-pair\n        (pair? rank-map) :pair\n        :else :high-card))))","user":"56a28c23e4b0542e1f8d14c3"},{"code":"(fn [cards] \n    (let [k (fn [s]\n              (let [letter-to-suit {\\H :heart\n                                    \\D :diamond\n                                    \\C :club\n                                    \\S :spade}\n                    \n                    letter-to-rank {\\2 0\n                                    \\3 1\n                                    \\4 2\n                                    \\5 3\n                                    \\6 4\n                                    \\7 5\n                                    \\8 6\n                                    \\9 7\n                                    \\T 8\n                                    \\J 9\n                                    \\Q 10\n                                    \\K 11\n                                    \\A 12}]\n                {:suit (get letter-to-suit (first s))\n                 :rank (get letter-to-rank (second s))}\n                ))\n          cards (map k cards)\n          ranks (map :rank cards)\n          ranksf (vals (frequencies ranks))\n          suitf (frequencies (map :suit cards))\n          \n          high-card? (fn [] true)\n          pair? (fn [] (some #(= % 2) ranksf))\n          two-pair? (fn [] (= (count (filter #(= % 2) ranksf)) 2))\n          three-of-a-kind? (fn [] (some #(= % 3) ranksf))\n          \n          straight? (fn []\n            (let [ranks1 (take 5 (iterate inc (apply min ranks)))\n                  ranks2 (take 5 (iterate \n                                    (fn [i] \n                                      (if (= i 12) 0 (inc i)))\n                                    (apply max ranks)))]\n              (or (= (set ranks) (set ranks1)) \n                  (= (set ranks) (set ranks2)))\n            )\n          )\n          \n          flush? (fn [] (some #(= % 5) (vals suitf)))\n          full-house? (fn [] (and (pair?) (three-of-a-kind?)))\n          four-of-a-kind? (fn [] (some #(= % 4) ranksf))\n          straight-flush? (fn [] (and (straight?) (flush?)))\n        \n          best-hand (fn best-hand [hands] \n              (if ((second hands)) \n                (first hands)\n                (best-hand (drop 2 hands)))\n            )\n          ]\n      (best-hand [\n        :straight-flush straight-flush?\n        :four-of-a-kind four-of-a-kind?\n        :full-house full-house?\n        :flush flush?\n        :straight straight?\n        :three-of-a-kind three-of-a-kind?\n        :two-pair two-pair?\n        :pair pair?\n        :high-card high-card?\n        ])\n      ))","problem":"178","user":"4f0da4e4535d0136e6c22319"},{"problem":"178","code":"(fn best-hand [cards]\n\n  (let\n      [get-card (fn [s]\n                  (let [\n                         suit (first s),\n                         rank (second s),\n                         suits {\\S :spade, \\H :heart, \\D :diamond, \\C :club},\n                         ranks {\\2 0, \\3 1, \\4 2, \\5 3, \\6 4, \\7 5, \\8 6, \\9 7, \\T 8, \\J 9, \\Q 10, \\K 11, \\A 12}\n                         ]\n                    [(suits suit) (ranks rank)]\n                    )\n                  ),\n       in-sequence? (fn [args]\n                      (let [sum (apply + args),\n                            min-value (apply min args),\n                            max-value (apply max args)]\n                        (= sum (/ (* (+ max-value min-value) (count args)) 2))\n                        )),\n       results (map get-card cards)]\n    (cond\n      ;; straight-flush?\n      (and (apply = (map first results)) (in-sequence? (map second results))) :straight-flush\n\n      ;; four-of-a-kind?\n      (some #(= (count %) 4) (vals (group-by identity (map second results)))) :four-of-a-kind\n\n      ;; full-house?\n      (and\n        (some #(= (count %) 3) (vals (group-by identity (map second results))))\n        (some #(= (count %) 2) (vals (group-by identity (map second results))))) :full-house\n\n      ;; flush?\n      (apply = (map first results)) :flush\n\n      ;; straight?\n      (in-sequence? (map second results)) :straight\n\n      (in-sequence? (replace {12 -1} (map second results))) :straight\n\n      ;; three-of-a-kind?\n      (some #(= (count %) 3) (vals (group-by identity (map second results)))) :three-of-a-kind\n\n      ;; two-pair?\n      (= 2 (count (filter #(= % 2) (map (fn [[_ v]] (count v)) (group-by identity (map second results)))))) :two-pair\n\n      ;; pair?\n      (= 1 (count (filter #(= % 2) (map (fn [[_ v]] (count v)) (group-by identity (map second results)))))) :pair\n\n      :else :high-card\n\n      )))","user":"53ca41dae4b00fb29b2212c8"},{"code":"(fn [c]\n   (let [cs (memoize #(map first c))\n         cr (memoize #(map second c))\n         straight? (memoize (fn [] (let [r \"A23456789TJQKA\"]\n                                        (contains? (set (mapcat #(partition 5 1 %) [r (reverse r)])) (cr)))))\n         flush? (memoize #(apply = (cs)))\n         straight-flush? #(and (flush?) (straight?))\n         count-rank (memoize #(vals (frequencies (cr))))\n         max-rank-count (memoize #(apply max (count-rank)))\n         sorted-rank-counts (memoize #(sort (count-rank)))\n         ranks= #(= (%) %2)\n         four-of-a-kind? #(ranks= max-rank-count 4)\n         full-house? #(ranks= sorted-rank-counts [2 3])\n         three-of-a-kind? #(ranks= max-rank-count 3)\n         two-pair? #(ranks= sorted-rank-counts [1 2 2])\n         pair? #(ranks= max-rank-count 2)]\n     (cond\n       (straight-flush?) :straight-flush\n       (four-of-a-kind?) :four-of-a-kind\n       (full-house?) :full-house\n       (flush?) :flush\n       (straight?) :straight\n       (three-of-a-kind?) :three-of-a-kind\n       (two-pair?) :two-pair\n       (pair?) :pair\n       :else :high-card)))","problem":"178","user":"51f66e0ee4b06ff1c25c52c3"},{"problem":"178","code":"(fn [cards]\n  (let [fmt (fn [[suit rank]] {:suit ({\\H :heart \\D :diamond \\C :club \\S :spade} suit)\n                               :rank (.indexOf (vec \"23456789TJQKA\") rank)\n                               :aces-low (.indexOf (vec \"A23456789TJQK\") rank)})\n        cards (map fmt cards)\n        flush? (apply = (map :suit cards))\n        aces-high (->> cards (map :rank) sort)\n        aces-low (->> cards (map :aces-low) sort)\n        straight? (or (= aces-high (range (first aces-high) (inc (last aces-high))))\n                      (= aces-low (range (first aces-low) (inc (last aces-low)))))\n        same-ranks (->> cards (group-by :rank) vals (map count) sort)]\n    (cond\n      (and straight? flush?) :straight-flush\n      (= [1 4] same-ranks) :four-of-a-kind\n      (= [2 3] same-ranks) :full-house\n      flush? :flush\n      straight? :straight\n      (= [1 1 3] same-ranks) :three-of-a-kind\n      (= [1 2 2] same-ranks) :two-pair\n      (= [1 1 1 2] same-ranks) :pair\n      :else :high-card)))","user":"4f5599dfe4b0a7574ea71806"},{"code":"(fn [hand]\n  (let [[[s1 r1] [s2 r2] [s3 r3] [s4 r4] [s5 r5]]\n        hand\n\n        rank-value\n        {\\2 2 \\3 3 \\4 4 \\5 5 \\6 6 \\7 7 \\8 8 \\9 9 \\T 10 \\J 11 \\Q 12 \\K 13 \\A 14}\n\n        straight?\n        (let [rank-value-lo\n              (assoc rank-value \\A 1)\n\n              sort-ranks\n              (fn [ranks value-fn]\n                (reverse (sort (map value-fn ranks))))\n\n              ordered?\n              (fn [ranks]\n                (if (every? (fn [[x y]] (= 1 (- x y)))\n                            (partition 2 1 ranks))\n                  (first ranks)))]\n          (or (ordered? (sort-ranks [r1 r2 r3 r4 r5] rank-value))\n              (ordered? (sort-ranks [r1 r2 r3 r4 r5] rank-value-lo))))\n\n        flush?\n        (= s1 s2 s3 s4 s5)\n\n        freqs\n        (let [counts (frequencies (map rank-value [r1 r2 r3 r4 r5]))]\n          (reduce #(merge-with into %1 %2)\n                  (map (fn [[k v]] {v [k]})  counts)))]\n\n    (cond\n     (and straight? flush?)\n     :straight-flush\n\n     (contains? freqs 4)\n     :four-of-a-kind\n\n     (and (contains? freqs 3) (contains? freqs 2))\n     :full-house\n\n     flush?\n     :flush\n\n     straight?\n     :straight\n\n     (contains? freqs 3)\n     :three-of-a-kind\n\n     (= 2 (count (freqs 2)))\n     :two-pair\n\n     (contains? freqs 2)\n     :pair\n\n     :else\n     :high-card)))","problem":"178","user":"4f0d093b535d0136e6c22313"},{"problem":"178","code":"(fn poker-hands\n  [hand]\n  (letfn [(two-pair? [hand] (= [2 2 1] (map last (frequencies (map last hand)))))\n          (n-of-a-kind? [n hand] (some #(= n %) (map last (frequencies (map last hand)))))\n          (flush? [hand] (apply = (map first hand)))\n          (straight? [hand] (let [cards (concat [\"A\"] (map str (range 2 10)) [\"T\" \"J\" \"Q\" \"K\" \"A\"])]\n                              (some #(= (sort %) (sort (map (comp str last) hand))) (partition 5 1 cards))))]\n    (cond (and (straight? hand) (flush? hand)) :straight-flush\n          (n-of-a-kind? 4 hand) :four-of-a-kind\n          (and (n-of-a-kind? 3 hand) (n-of-a-kind? 2 hand)) :full-house\n          (flush? hand) :flush          \n          (straight? hand) :straight\n          (n-of-a-kind? 3 hand) :three-of-a-kind\n          (two-pair? hand) :two-pair\n          (n-of-a-kind? 2 hand) :pair\n          :else :high-card)))","user":"4daeabf6edd6309eace4d15c"},{"problem":"178","code":"(fn best-hand [hand]\n  (letfn [(decode-playing-card [code]\n            (let [suit (first code)\n                  rank (second code)]\n              {:suit (get {\\D :diamond \\C :club \\H :heart \\S :spade} suit)\n               :rank (get {\\T 8 \\J 9 \\Q 10 \\K 11 \\A 12} rank (- (Character/digit rank 10) 2))} ))\n          (ace-low [h]\n            (map #(if (= (:rank %) 12) (assoc % :rank -1) %) h))\n          (flush? [h]\n            (every? #(= (:suit %) (:suit (first h))) h))\n          (in-sequence? [h]\n            (let [ranks (sort (map :rank h))\n                  lowest (first ranks)]\n              (= (range lowest (+ 5 lowest))\n                 ranks)))\n          (straight? [h]\n            (or (in-sequence? h) (in-sequence? (ace-low h))))\n          (n-of-a-kind? [h n]\n            (->> h\n                 (group-by :rank)\n                 (filter #(= n (count (second %))))\n                 first))\n          (group-rank-counts? [h counts]\n            (= counts (->> h\n                          (group-by :rank)\n                          (map #(count (second %)))\n                          sort)))]\n    (let [h (map decode-playing-card hand)]\n      (cond (and (flush? h) (straight? h)) :straight-flush\n            (n-of-a-kind? h 4) :four-of-a-kind\n            (group-rank-counts? h [2 3]) :full-house\n            (flush? h) :flush\n            (straight? h) :straight\n            (n-of-a-kind? h 3) :three-of-a-kind\n            (group-rank-counts? h [1 2 2]) :two-pair\n            (n-of-a-kind? h 2) :pair\n            :else :high-card))))","user":"5d7aa22ee4b02e6b30c9354e"},{"code":"(fn f [cards]\n  (let [\n        flush (apply = (map first cards))\n        straight ((set (map set (partition 5 1 \"A23456789TJQKA\"))) \n                  (set (map second cards))) \n        ranks (frequencies (map second cards))\n        rank-count (group-by val ranks)]\n    (cond (and straight flush) :straight-flush\n          (rank-count 4) :four-of-a-kind\n          (and (rank-count 3) (rank-count 2)) :full-house\n          flush :flush\n          straight :straight\n          (rank-count 3) :three-of-a-kind\n          (= 2 (count (rank-count 2))) :two-pair\n          (rank-count 2) :pair\n          :else :high-card)))","problem":"178","user":"50d0d4c8e4b00b15ecee976a"},{"problem":"178","code":"(fn [five-cards]\n  (let [type-to-num {\\2 2\n                     \\3 3\n                     \\4 4\n                     \\5 5\n                     \\6 6\n                     \\7 7\n                     \\8 8\n                     \\9 9\n                     \\T 10\n                     \\J 11\n                     \\Q 12\n                     \\K 13\n                     \\A 1 }\n\n        five-suits (map first five-cards)\n        five-types-ace-1 (sort (map #(type-to-num (second %)) five-cards))\n        five-types-ace-13 (sort (replace {1 14} five-types-ace-1))] \n    (cond\n      (and (= 1 (count (set five-suits)))\n           (or (= five-types-ace-1 (range (apply min five-types-ace-1)\n                                          (+ (apply min five-types-ace-1) 5)))\n               (= five-types-ace-13 (range (apply min five-types-ace-13)\n                                           (+ (apply min five-types-ace-13) 5)))))\n      :straight-flush\n\n      (= 4 (apply max (vals (frequencies five-types-ace-1))))\n      :four-of-a-kind\n\n      (= 2 (count (set five-types-ace-1)))\n      :full-house\n\n      (= 1  (count (set five-suits)))\n      :flush\n\n      (or (= five-types-ace-1 (range (apply min five-types-ace-1)\n                                          (+ (apply min five-types-ace-1) 5)))\n               (= five-types-ace-13 (range (apply min five-types-ace-13)\n                                           (+ (apply min five-types-ace-13) 5))))\n      :straight\n           \n      (= 2 (->> five-types-ace-1\n               frequencies\n               vals\n               (filter #(= % 2))\n               count))\n      :two-pair\n      \n      (= 3 (count (set five-types-ace-1)))\n      :three-of-a-kind\n      \n      (= 4 (count (set five-types-ace-1)))\n      :pair\n\n      :else\n      :high-card)))","user":"608ec5e4e4b03bd49d9f36c0"},{"problem":"178","code":"(fn [m]\n  (let [res (fn [s]\n              (let [x (first s)\n                    y (second s)\n                    i (case x\n                        \\D :diamond \\H :heart \\C :club \\S :spade)\n                    j (case y\n                        \\2 0 \\3 1 \\4 2 \\5 3 \\6 4 \\7 5 \\8 6\n                        \\9 7 \\T 8 \\J 9 \\Q 10 \\K 11 \\A 12)]\n                {:suit i :rank j}))\n        s (map res m)\n        ss (group-by :suit s)\n        sr (group-by :rank s)\n        rk (set (keys sr))\n        suits (count ss)\n        ranks (count sr)\n        couns (map (fn [[k v]] (count v)) sr)\n        maxc (apply max couns)\n        minc (apply min couns)\n        maxr (apply max (keys sr))\n        minr (apply min (keys sr))\n        mu (- maxr minr)]\n    (cond\n      (and (= suits 1) (or (= rk #{0 1 2 3 12}) (and (= ranks 5) (= mu 4))))\n      :straight-flush\n      (= maxc 4)\n      :four-of-a-kind\n      (and (= maxc 3) (= minc 2))\n      :full-house\n      (or (= suits 1))\n      :flush\n      (or (= rk #{0 1 2 3 12}) (and (= ranks 5) (= mu 4)))\n      :straight\n      (= maxc 3)\n      :three-of-a-kind\n      (and (= maxc 2) (= ranks 3))\n      :two-pair\n      (= ranks 4)\n      :pair\n      :default\n      :high-card)))","user":"5af907e6e4b0cc2b61a3bcda"},{"problem":"178","code":"(fn [xs]\n  (let [f first\n        s second\n        rs (apply array-map (interleave \"23456789TJQKA\" (range)))\n        r #(rs (s %))\n        pairs (sort (map #(count (s %)) (group-by s xs)))\n        fl (apply = (map f xs))\n        st (and (= [1 1 1 1 1] pairs)\n                (let [ks (sort (map r xs))\n                      ks (map #(- % (first ks)) ks)]\n                  (#{(range 5) [0 1 2 3 12]} ks)))\n        hs (array-map\n            :straight-flush (and st fl)\n            :four-of-a-kind (= [1 4] pairs)\n            :full-house (= [2 3] pairs)\n            :flush fl\n            :straight st\n            :three-of-a-kind (= [1 1 3] pairs)\n            :two-pair (= [1 2 2] pairs)\n            :pair (= [1 1 1 2] pairs)\n            :high-card true\n            )]\n    (f (f (filter #(s %) hs)))))","user":"553e0b70e4b0a04f792994e8"},{"problem":"178","code":"(fn [coll]\n  (letfn [(get-rank-of-num [coll n]\n                           (get \n                            (group-by \n                             (comp count second)\n                             (group-by second coll))\n                            n))\n          (is-pair? [coll] (get-rank-of-num coll 2))\n          (is-two-pair? [coll] (= (count (get-rank-of-num coll 2)) 2))\n          (is-three-of-a-kind? [coll] (get-rank-of-num coll 3))\n          (is-four-of-a-kind? [coll] (get-rank-of-num coll 4))\n          (is-flush? [coll] (get\n                             (group-by\n                              (comp count second)\n                              (group-by first coll))\n                             5))\n          (is-straight? [coll]\n                        (let [rank-map {\\2 0 \\3 1 \\4 2 \\5 3 \\6 4 \\7 5 \\8 6 \\9 7 \\T 8 \\J 9 \\Q 10 \\K 11 \\A 12}\n                              sorted-rank (sort (map #(get rank-map (second %)) coll))\n                              first-rank (first sorted-rank)]\n                          (cond\n                           (= sorted-rank '(0 1 2 3 12)) true\n                           (= sorted-rank (range first-rank (+ first-rank 5))) true\n                           :else false)))\n          (is-full-house? [coll] (and (is-three-of-a-kind? coll)\n                                      (is-pair? coll)))\n          (is-straight-flush? [coll] (and (is-straight? coll)\n                                          (is-flush? coll)))]\n    (cond\n     (is-straight-flush? coll) :straight-flush\n     (is-four-of-a-kind? coll) :four-of-a-kind\n     (is-full-house? coll) :full-house\n     (is-flush? coll) :flush\n     (is-straight? coll) :straight\n     (is-three-of-a-kind? coll) :three-of-a-kind\n     (is-two-pair? coll) :two-pair\n     (is-pair? coll) :pair\n     :else :high-card)))","user":"585e2e77e4b0f14aab7c87ac"},{"code":"(letfn [(suit [card]\n          (case (first card)\n            \\D :diamond\n            \\H :heart\n            \\C :club\n            \\S :spade))\n        (rank [card]\n          (let [r (second card)]\n            (if (and (>= (int r) (int \\2))\n                     (<= (int r) (int \\9)))\n              (- (int r) (int \\2))\n              (case r\n                \\T 8\n                \\J 9\n                \\Q 10\n                \\K 11\n                \\A 12))))\n        (suit-and-rank [card]\n          {:suit (suit card) :rank (rank card)})\n        (straight? [hand]\n          (let [ranks (sort (map :rank hand))]\n            (or (= ranks (range (first ranks) (+ (first ranks) 5)))\n                (and (= (drop-last ranks) \n                        (range (first ranks) (+ (first ranks) 4)))\n                     (= (last ranks) 12)))))\n        (flush? [hand]\n          (let [suits (map :suit hand)]\n            (every? #(= % (first suits)) suits)))\n        (straight-flush? [hand]\n          (and (straight? hand) (flush? hand)))\n        (haven-1? [n hand]\n          (if (empty? hand) false\n              (if (= (count (filter #(= % (first hand)) hand)) n)\n                (do (println hand)\n                    (remove #(= % (first hand)) hand))\n                (haven-1? n (rest hand)))))\n        (haven?- [ns hand]\n          (if (empty? ns) true\n              (if-let [rest-hand (haven-1? (first ns) hand)]\n                (haven?- (rest ns) rest-hand))))\n        (haven? [ns hand]\n          (haven?- ns (map :rank hand)))]\n   (fn [cards] \n     (let [hand (map suit-and-rank cards)]\n       (cond (straight-flush? hand) :straight-flush\n             (haven? [4] hand) :four-of-a-kind\n             (haven? [3 2] hand) :full-house\n             (flush? hand) :flush\n             (straight? hand) :straight\n             (haven? [3] hand) :three-of-a-kind\n             (haven? [2 2] hand) :two-pair\n             (haven? [2] hand) :pair\n             :otherwise :high-card))))","problem":"178","user":"5294e44de4b02ebb4ef75016"},{"problem":"178","code":"(fn [cards]\n  (let [str2card\n        (fn [card]\n          (let [[suit rank] (seq card)]\n            {:suit ({\\H :heart\n             \\C :club\n             \\D :diamond\n             \\S :spade}\n             suit)\n             :rank ((zipmap [\\2 \\3 \\4 \\5 \\6 \\7 \\8 \\9 \\T \\J \\Q \\K \\A] (range 13)) rank)}))\n        card-maps (map str2card cards)\n        ranks (sort (vals (frequencies (map :rank card-maps))))\n        suits (vals (frequencies (map :suit card-maps)))\n        straight? (let [s (sort (map :rank card-maps))] (or (apply = (map - s (range 5)))\n                                                                   (= s '(0 1 2 3 12))))]\n    (cond\n     (and straight? (= suits '(5))) :straight-flush\n     (= ranks '(1 4)) :four-of-a-kind\n     (= ranks '(2 3)) :full-house\n     (= suits '(5)) :flush\n     straight? :straight\n     (= ranks '(1 1 3)) :three-of-a-kind\n     (= ranks '(1 2 2)) :two-pair\n     (= ranks '(1 1 1 2)) :pair\n     :else :high-card)))","user":"563dfc02e4b0da801c4e4662"},{"problem":"178","code":"(fn prob178\n  [coll]\n  (letfn [( card-suit-rank [s]\n            (letfn [(suit [c]\n                      ({\n                        \\D :diamond\n                        \\H :heart\n                        \\C :club\n                        \\S :spade\n                        } \n                       c)\n                      )\n                    (rank [c]\n                      ({\n                        \\2 0\n                        \\3 1\n                        \\4 2\n                        \\5 3\n                        \\6 4\n                        \\7 5\n                        \\8 6\n                        \\9 7\n                        \\T 8\n                        \\J 9\n                        \\Q 10\n                        \\K 11\n                        \\A 12\n                        }\n                       c\n                       )\n                      )]\n              (let [v (vec s)\n                    suit-char (first v)\n                    rank-char (last v)]\n                {:suit (suit suit-char) :rank (rank rank-char)})))\n          \n          (get-suits [cards] (map #(:suit %) cards))\n          (same-suit [cards] (= 1 (count (set (get-suits cards)))))\n          (get-ranks [cards] (map #(:rank %) cards))\n          (get-cards [hand] (map card-suit-rank hand))\n\n          (straight-flush [cards]\n            ;; Straight flush: All cards in the same suit, and in sequence\n            (if (same-suit cards)\n              (let [ranks (sort (get-ranks cards))\n                    cnt (count ranks)]\n                (if (and (= cnt 5) (= 4 (- (nth ranks (- cnt 1)) (nth ranks 0))))\n                  true\n                  false\n                  ))))\n\n          (four-of-a-kind [cards]\n            ;; Four of a kind: Four of the cards have the same rank\n            (let [count-map (frequencies (map #(:rank %) cards))]\n              ;; count-map contains a value of 4\n              (not (empty? (filter (fn [[v c]] (= c 4)) count-map)))))\n\n          (full-house [cards]\n            ;; Full House: Three cards of one rank, the other two of another rank\n            (let [count-map (frequencies (map #(:rank %) cards))]\n              ;; count-map contains a value of 3 and 2\n              (= #{3 2} (set (map (fn [[v c]] c) (filter (fn [[v c]] (or (= c 2) (= c 3))) count-map))))))\n          \n          (flush [cards]\n            ;; Flush: All cards in the same suit\n            (same-suit cards))\n\n          (seq-contains? [sequence item]\n            ;; @see http://stackoverflow.com/a/3249649\n            ;; Determine whether a sequence contains a given item\n            (if (empty? sequence)\n              false\n              (reduce #(or %1 %2) (map #(= %1 item) sequence))))\n\n          (fix-up-ace [ranks]\n            (if (and (seq-contains? ranks 12) (seq-contains? ranks 2))\n              (cons -1 (remove (fn [x] (= 12 x)) ranks))\n              ranks))\n\n          (increasing [xs]\n            (let [s (sort xs)]\n              (loop [s s]\n                (if (and (seq s) (= 1 (count s)))\n                  true\n                  (let [a (first s)\n                        b (second s)]\n                    (if (not= (inc a) b)\n                      false\n                      (recur (next s))))))))\n\n          (straight [cards]\n            ;; Straight: All cards in sequence (aces can be high or low, but not both at once\n            (let [ranks (fix-up-ace (sort (get-ranks cards)))\n                  cnt (count ranks)]\n              (if (and (= cnt 5) \n                       ;; area all the numbers sequencial\n                       (increasing ranks))        \n                true\n                false\n                )))\n          \n          (three-of-a-kind [cards]\n            ;; Three of a kind: Three of the cards have the same rank\n            (let [count-map (frequencies (map #(:rank %) cards))]\n              (not (empty? (filter (fn [[v c]] (= c 3)) count-map)))))\n\n          (two-pair [cards]\n            ;; Two pair: Two pairs of cards have the same rank\n            (let [count-map (frequencies (map #(:rank %) cards))]\n              (= '(2 2)\n                 (map (fn [[v c]] c) (filter (fn [[v c]] (= c 2)) count-map)))))\n          \n          (pair [cards]\n            ;; Pair: Two cards have the same rank\n            (let [count-map (frequencies (map #(:rank %) cards))]\n              (not (empty? (filter (fn [[v c]] (= c 2)) count-map)))))\n\n          (high-card [cards]\n            ;; High card: None of the above conditions are met\n            true\n            )\n          ]\n    (let [cards (get-cards coll)]\n      (cond\n        (straight-flush cards) :straight-flush\n        (four-of-a-kind cards) :four-of-a-kind\n        (full-house cards) :full-house\n        (flush cards) :flush\n        (straight cards) :straight\n        (three-of-a-kind cards) :three-of-a-kind\n        (two-pair cards) :two-pair\n        (pair cards) :pair\n        :else :high-card\n        ))\n    )\n  )","user":"4ebbff41535dfed6da9c6d78"},{"problem":"178","code":"(fn [hand-as-strs]\n  (let [deuce 0\n        ace 12\n        make-card (fn [str]\n                    (let [suit-by-char {\\D :diamond,\n                                        \\S :spade,\n                                        \\H :heart,\n                                        \\C :club}\n                          rank-by-char {\\2 deuce,\n                                        \\3 1,\n                                        \\4 2,\n                                        \\5 3,\n                                        \\6 4,\n                                        \\7 5,\n                                        \\8 6,\n                                        \\9 7,\n                                        \\T 8,\n                                        \\J 9,\n                                        \\Q 10\n                                        \\K 11\n                                        \\A ace}]\n                      {:suit (suit-by-char (first str)) :rank (rank-by-char (second str))}))\n        straight? (fn [hand]\n                    (let [sorted-ranks (sort (map :rank hand))\n                          proper-straight-ranks (take 5 (iterate inc (first sorted-ranks)))]\n                      (or (= sorted-ranks proper-straight-ranks)\n                          (and (= (first sorted-ranks) deuce)\n                               (= (butlast sorted-ranks) (butlast proper-straight-ranks))\n                               (= (last sorted-ranks) ace)))))\n        flush? (fn [hand]\n                 (apply = (map :suit hand)))\n        kind-summary (fn [hand]\n                       (->> (map :rank hand)\n                            frequencies\n                            vals\n                            (sort-by -)))\n\n        hand-rank (fn [hand]\n                    (cond (and (straight? hand) (flush? hand)) :straight-flush\n                          (flush? hand) :flush\n                          (straight? hand) :straight\n                          :else (case (kind-summary hand)\n                                  [4 1] :four-of-a-kind\n                                  [3 2] :full-house\n                                  [3 1 1] :three-of-a-kind\n                                  [2 2 1] :two-pair\n                                  [2 1 1 1] :pair\n                                  :high-card)))]\n    (hand-rank (map make-card hand-as-strs))))","user":"5ec6de19e4b08d0ec38692da"},{"problem":"178","code":"(fn [hand]\n  (let [suit-map {\\D :diamond \\H :heart \\C :club \\S :spade}\n        rank-map {\\2 0 \\3 1 \\4 2 \\5 3 \\6 4 \\7 5 \\8 6 \\9 7 \\T 8 \\J 9 \\Q 10 \\K 11 \\A 12}\n        hand (mapv #(hash-map :suit (suit-map (first %)) :rank (rank-map (second %))) hand)\n        by-rank (vals (group-by :rank hand))\n        suits (set (mapv #(% :suit) hand))\n        ranks (set (mapv #(% :rank) hand))\n        ]\n    (cond\n     (and (= 1 (count suits)) (every? #(ranks %) (cons 12 (range 4)))) :straight-flush\n     (and (= 1 (count suits)) (some (fn [start] (every? #(ranks %) (range start (+ start 5)))) (range 9))) :straight-flush\n     (some #(= 4 (count %)) by-rank) :four-of-a-kind\n     (and (some #(= 3 (count %)) by-rank) (some #(= 2 (count %)) by-rank)) :full-house\n     (= 1 (count suits)) :flush\n     (every? #(ranks %) (cons 12 (range 4))) :straight\n     (some (fn [start] (every? #(ranks %) (range start (+ start 5)))) (range 9)) :straight\n     (some #(= 3 (count %)) by-rank) :three-of-a-kind\n     (= 2 (reduce #(if (= 2 (count %2)) (inc %1) %1) 0 by-rank)) :two-pair\n     (some #(= 2 (count %)) by-rank) :pair\n     :else :high-card)\n    ))","user":"5dd60c58e4b0948ae9d9ad7c"},{"code":"(fn [h]\n    (let\n      [\n        cards               (zipmap \"23456789TJQKA\" [1 2 3 4 5 6 7 8 9 10 11 12 13])\n        help                (fn [x y z] (= y (count (filter #(= z %) (vals (frequencies (map second x)))))))\n        is_flush?           (fn [x] (= 1 (count (distinct (map first x)))))\n        is_pair?            (fn [x] (help x 1 2))\n        is_two_pair?        (fn [x] (help x 2 2))\n        is_three_of_a_kind? (fn [x] (help x 1 3))\n        is_four_of_a_kind?  (fn [x] (help x 1 4))\n        is_full_house?      (fn [x] (= #{2 3} (set (vals (frequencies (map second x))))))\n        is_straight?        (fn [x] (let [seq1 (sort (map cards (map second x)))\n                                          seq2 (sort (map #(mod % 13) seq1))\n                                          cmp  (fn [s] (= s (range (apply min s) (inc (apply max s)))))\n                                         ] (or (cmp seq1) (cmp seq2))))\n        is_straight_flush?  (fn [x] (and (is_straight? x) (is_flush? x)))\n      ]\n    (cond\n      (is_straight_flush? h) :straight-flush\n      (is_four_of_a_kind? h) :four-of-a-kind\n      (is_full_house? h) :full-house\n      (is_flush? h) :flush\n      (is_straight? h) :straight\n      (is_three_of_a_kind? h) :three-of-a-kind\n      (is_two_pair? h) :two-pair\n      (is_pair? h) :pair\n      :else :high-card\n    )\n  ))","problem":"178","user":"4eb13d60535d7eef3080733f"},{"problem":"178","code":"(fn [input]\n  (letfn [(parse [[s r]] \n            {:suit ({\\D :diamond\n                     \\S :spade\n                     \\C :club\n                     \\H :heart} s) \n             :rank (condp = r\n                     \\A 13\n                     \\K 12\n                     \\Q 11\n                     \\J 10\n                     \\T 9\n                     (- (int r) 49))})\n          (ranks [hand] (map :rank hand))\n          (consecutive? [nums]\n            (every?\n              (fn [[a b]] (= (inc a) b))\n              (partition 2 1 nums)))\n          (pairs [hand]\n            (filter \n              #(= 2 (count (val %)))\n              (group-by :rank hand)))\n          (of-a-kind? [n hand]\n            (some\n              #(= n (count (val %)))\n              (group-by :rank hand)))\n          (flush? [hand] (apply = (map :suit hand)))\n          (straight? [hand]\n            (or (consecutive? (ranks hand))\n                (consecutive? (conj\n                                (butlast (ranks hand))\n                                (mod (last (ranks hand)) 13))))) ]\n  (let [hand (sort-by :rank (map parse input))]\n    (cond\n      ((every-pred straight? flush?) hand) :straight-flush\n      (of-a-kind? 4 hand) :four-of-a-kind\n      (= 2 (count (group-by :rank hand))) :full-house\n      (flush? hand) :flush\n      (straight? hand) :straight\n      (of-a-kind? 3 hand) :three-of-a-kind\n      (= 2 (count (pairs hand))) :two-pair\n      (= 1 (count (pairs hand))) :pair\n      :else :high-card))))","user":"5aa998c6e4b0d174b936c8e5"},{"code":"(fn [xs]\n  (let [suits (group-by first xs)\n        nums (group-by second xs)\n        straights (set (map set (partition 5 1 \"A23456789TJQKA\")))\n        is-straight? (contains? straights (set (keys nums)))\n        is-flush? (= 1 (count suits))\n        groupNums (sort (map (comp count second) nums))]\n    (cond\n      (and is-straight? is-flush?) :straight-flush\n      (= groupNums [1 4]) :four-of-a-kind\n      (= groupNums [2 3]) :full-house\n      is-flush? :flush\n      is-straight? :straight\n      (= groupNums [1 1 3]) :three-of-a-kind\n      (= groupNums [1 2 2]) :two-pair\n      (= groupNums [1 1 1 2]) :pair\n      :else :high-card)))","problem":"178","user":"5201572be4b0d7096e99ddbb"},{"problem":"178","code":"(fn puzzle-178 [cards-str]\n  (letfn [(recognize-card [s]\n                          (let [[suit rank] (seq s)]\n                            {:suit ({\\S :spade \\H :heart \\D :diamond \\C :club} suit) \n                            :rank (.indexOf \"23456789TJQKA\" (int rank))}))\n          (grouped-ranks [cards]\n                         (sort (map count (vals (group-by :rank cards)))))\n          (in-sequence? [int-seq]\n                        (let [sorted-int-seq (sort int-seq)]\n                          (= sorted-int-seq (range (first sorted-int-seq) (inc (last sorted-int-seq ))))))\n          (straight-flush? [cards]\n                           (and\n                            (apply = (map :suit cards))\n                            (in-sequence? (map :rank cards))))\n          (four-of-a-kind? [cards]\n                           (contains? (set (grouped-ranks cards)) 4))\n          (full-house? [cards]\n                       (= (grouped-ranks cards) [2 3]))\n          (flush? [cards]\n                  (apply = (map :suit cards)))\n          (straight? [cards]\n                     (let [ranks (map :rank cards)]\n                       (or\n                        (in-sequence? ranks)\n                        (in-sequence? (map #(if (= 12 %) -1 %) ranks)))))\n          (three-of-a-kind? [cards]\n                            (contains? (set (grouped-ranks cards)) 3))\n          (two-pair? [cards]\n                     (= [1 2 2] (grouped-ranks cards)))\n          (pair? [cards]\n                 (contains? (set (grouped-ranks cards)) 2))]\n    (let [cards (map recognize-card cards-str)]\n      (cond\n       (straight-flush? cards) :straight-flush\n       (four-of-a-kind? cards) :four-of-a-kind\n       (full-house? cards) :full-house\n       (flush? cards) :flush\n       (straight? cards) :straight\n       (three-of-a-kind? cards) :three-of-a-kind\n       (two-pair? cards) :two-pair\n       (pair? cards) :pair\n       :else :high-card))))","user":"53286f84e4b09d4e7a9b5505"},{"problem":"178","code":"(fn best-hand [hand]\n  (let [[suits ranks] (apply map str hand)\n        freqs (frequencies (vals (frequencies ranks)))\n        rank-strs (map str (concat \"A\" (range 2 10) \"TJQKA\"))\n        straights (set (map set (partition 5 1 rank-strs)))\n        straight? (straights (set (map str ranks)))\n        flush? (apply = suits)\n        n-of-kind? #(freqs %)]\n    (cond\n      (and straight? flush?) :straight-flush\n      (n-of-kind? 4) :four-of-a-kind\n      (and (freqs 3) (freqs 2)) :full-house\n      flush? :flush\n      straight? :straight\n      (n-of-kind? 3) :three-of-a-kind\n      (= 2 (freqs 2)) :two-pair\n      (n-of-kind? 2) :pair\n      :else :high-card)))","user":"5879d577e4b01531a375ead8"},{"problem":"178","code":"(letfn [(describe-card [[suit rank]]\r\n          (let [suit-name   {\\S :spade,   \\H :heart,\r\n                             \\D :diamond, \\C :club}\r\n                rank-number (zipmap \"23456789TJQKA\" (range))]\r\n            {:suit (suit-name suit),\r\n             :rank (rank-number rank)}))\r\n        (flush? [cards] (apply = (map :suit cards)))\r\n        (straight? [cards]\r\n          (let [xs (sort (map :rank cards)), x (first xs)]\r\n            (or (= xs (range x (+ 5 x)))\r\n                (if (= 12 (last xs))\r\n                  (= (take 4 xs) (range 4))))))\r\n        (straight-flush? [cards] (and (flush? cards) (straight? cards)))\r\n        (kinds [cards] (map count (vals (group-by :rank cards))))\r\n        (n-of-a-kind? [n cards] (some #{n} (kinds cards)))\r\n        (two-pair? [cards] (= 2 (count (filter #{2} (kinds cards)))))\r\n        (full-house? [cards]\r\n          (and (n-of-a-kind? 3 cards)\r\n               (n-of-a-kind? 2 cards)))]\r\n\r\n  (fn best-hand [hand]\r\n    (condp apply [(map describe-card hand)]\r\n      straight-flush?          :straight-flush\r\n      (partial n-of-a-kind? 4) :four-of-a-kind\r\n      full-house?              :full-house\r\n      flush?                   :flush\r\n      straight?                :straight\r\n      (partial n-of-a-kind? 3) :three-of-a-kind\r\n      two-pair?                :two-pair\r\n      (partial n-of-a-kind? 2) :pair\r\n      :high-card)))","user":"55d0e76ae4b0e31453f64a40"},{"code":"(fn hands [cards]\n  (let\n    [ace-high {\\2 2 \\3 3 \\4 4 \\5 5 \\6 6 \\7 7 \\8 8 \\9 9 \\T 10 \\J 11 \\Q 12 \\K 13 \\A 14} \n     ace-low (assoc ace-high \\A 1)\n     rank (fn [[_ r]] r)\n     suit (fn [[s _]] s)\n     in-seq? (fn [cs dict]\n               (->> cs\n                    (map rank)\n                    (map dict)\n                    sort\n                    (map-indexed #(- %2 %))\n                    (apply =)))\n     match-cards? (fn [freqs cs]\n                   (= freqs\n                      (->> cs (map rank) frequencies vals sort)))\n     sf? (fn [cs]\n           (and \n            (apply = (map suit cs))\n            (or \n             (in-seq? cs ace-high)\n             (in-seq? cs ace-low))))\n     fl? (fn [cs]\n           (apply = (map suit cs)))\n     st? (fn [cs]\n           (or (in-seq? cs ace-high)\n               (in-seq? cs ace-low)))]\n    (cond\n     (sf? cards) :straight-flush\n     (match-cards? '(1 4) cards) :four-of-a-kind\n     (match-cards? '(2 3) cards) :full-house\n     (fl? cards) :flush\n     (st? cards) :straight\n     (match-cards? '(1 1 3) cards) :three-of-a-kind\n     (match-cards? '(1 2 2) cards) :two-pair\n     (match-cards? '(1 1 1 2) cards) :pair\n     :else :high-card)))","problem":"178","user":"50217818e4b00bba4502f7a7"},{"code":"(fn [hand] (let [suits (distinct (map first hand))\n                      ace-high-ranks \"23456789TJQKA\"\n                      king-high-ranks \"A23456789TJQK\"\n                      ranks (map second hand)\n                      rank-counts (reverse (sort (map count (vals (group-by identity ranks)))))\n                      flush? (= 1 (count suits))\n                      sorted-ranks (fn [rank-order] (->>\n                                     ranks\n                                     (map #(.indexOf rank-order (int %)))\n                                     (sort)))\n                      straight-func (fn [rank-order] (= [0 1 2 3 4] (map #(- % (first (sorted-ranks rank-order))) (sorted-ranks rank-order))))\n                      straight? (or (straight-func ace-high-ranks) (straight-func king-high-ranks))\n                      ]\n                  (cond\n                    (and straight? flush?) :straight-flush\n                    (= 4 (first rank-counts)) :four-of-a-kind\n                    (= [3 2] (take 2 rank-counts)) :full-house\n                    straight? :straight\n                    flush? :flush\n                    (= 3 (first rank-counts)) :three-of-a-kind\n                    (= [2 2] (take 2 rank-counts)) :two-pair\n                    (= 2 (first rank-counts)) :pair\n                    :else :high-card)))","problem":"178","user":"503917a0e4b088a6a14ca763"},{"problem":"178","code":"(fn __ [h] \n  (let [d (let [s [\\H \\S \\D \\C] r (concat (range 2 10) [\\T \\J \\Q \\K \\A])] (map str (mapcat #(repeat 13 %) s) (cycle r)))\n        f (reduce (fn [m [a b c]] (assoc m a {:i b :h a :s (first a) :r (last a) :x c})) {} (map #(vector %2 % %3) (range) d (cycle (range 1 14)) ))\n        g (map f h)\n        j (map (comp count second) (group-by :r g))\n        h (fn [h] :high-card)\n        p (fn [h] (if (> (apply max j) 1) :pair))\n        t (fn [h] (if (> (count (filter #(> % 1) j)) 1) :two-pair))\n        u (fn [h] (if (pos? (count (filter #(> % 2) j))) :three-of-a-kind))\n        s (fn [h] (let [hi (sort (map :x h)) lo (sort (map #(mod (:x %) 13) h))] (if (or (apply = (map - hi (rest hi))) (apply = (map - lo (rest lo)))) :straight)))\n        l (fn [h] (if (apply = (map :s h)) :flush))\n        e (fn [h] (if (= #{2 3} (set j)) :full-house))\n        v (fn [h] (if (= #{1 4} (set j)):four-of-a-kind))\n        w (fn [h] (if (and (s h) (l h)) :straight-flush))]\n  (first (remove nil? (or (map #(% g) [w v e l s u t p h]))))))","user":"4ecf1f51535d1f5ad70dba3a"},{"problem":"178","code":"(let [\n    decode-symbol\n      (fn [sym]\n        (let [suit (first sym) rank (last sym)\n             converted {\n               :suit (get {\\D :diamond \\H :heart \\C :club \\S :spades} suit)\n               :rank (get {\\T 8 \\J 9 \\Q 10 \\K 11 \\A 12} rank)\n              }\n           ]\n         (if (nil? (:rank converted))\n          (assoc converted :rank (-> rank str Integer. dec dec))\n          converted\n         )\n        )\n      )\n    \n    straight-flush? #(let [suits (map :suit %) ranks (sort (map :rank %))]\n                      (and (= 1 (-> suits set count)) (= ranks (take 5 (iterate inc (first ranks)))))\n                    )\n    four-of-a-kind? #(let [ranks (frequencies (map :rank %))]\n                      (= [1 4] (sort (vals ranks)))\n                    )\n    full-house? #(let [ranks (frequencies (map :rank %))]\n                  (= [2 3] (sort (vals ranks)))\n                )\n    flush? #(let [suits (map :suit %)]\n              (= 1 (-> suits set count))\n            )\n    straight? #(let [ranks (remove (partial = 12) (sort (map :rank %)))]\n                (case (count ranks)\n                  5 (= ranks (take 5 (iterate inc (first ranks))))\n                  4 (= ranks (take 4 (iterate inc (first ranks))))\n                  false\n                )\n               )\n    three-of-a-kind? #(let [ranks (frequencies (map :rank %))]\n                        (= 1 (count (filter (partial = 3) (vals ranks))))\n                      )\n    two-pair? #(let [ranks (frequencies (map :rank %))]\n                 (= 2 (count (filter (partial = 2) (vals ranks))))    \n              )\n    pair? #(let [ranks (frequencies (map :rank %))]\n             (= 1 (count (filter (partial = 2) (vals ranks))))    \n          )\n    labels [\n      [:straight-flush straight-flush?]\n      [:four-of-a-kind four-of-a-kind?]\n      [:full-house full-house?]\n      [:flush flush?]\n      [:straight straight?]\n      [:three-of-a-kind three-of-a-kind?]\n      [:two-pair two-pair?]\n      [:pair pair?]\n    ]\n    ]\n\n  (fn [cards]\n    (let [hand (map decode-symbol cards)]\n      (loop [labels labels]\n        (let [label (first labels)]\n          (cond\n            (empty? labels) :high-card\n            ((last label) hand) (first label)\n            :else\n              (recur (rest labels))\n          )\n        )\n      )\n    )\n  )\n)","user":"5991d2fae4b0866487ed0d68"},{"code":"#(let [[suits ranks] (apply map (comp frequencies\n                                       vals\n                                       frequencies\n                                       list)\n                             %)]\n     (cond\n      \n      ((set (map set (partition 5 1 \"A23456789TJQKA\")))\n       (set (map second %)))\n      (if (suits 5) :straight-flush :straight)\n     \n      (ranks 4) :four-of-a-kind\n      \n      (ranks 3) (if (ranks 2) :full-house :three-of-a-kind)\n\n      (suits 5) :flush\n      \n      :else ({2 :two-pair 1 :pair} (ranks 2) :high-card)))","problem":"178","user":"507056b8e4b07bd6ad9b9f29"},{"problem":"178","code":"(fn [h]\n         (let [parser (fn [k]\n                        (let [s {\"D\" :diamond,\n                                 \"H\" :heart,\n                                 \"S\" :spade,\n                                 \"C\" :club}\n                              r {\"A\" 12, \"T\" 8, \"J\" 9, \"Q\" 10, \"K\" 11}\n                              sk (str(first k))\n                              rk (str(second k))]\n                          { :suit (get  s sk ) :rank (if (get r rk)\n                                                       (r rk)\n                                                       (-  (Integer/parseInt rk) 2))}))\n               h-set (set (map parser h))\n               suit (map :suit h-set)\n               rank (map :rank h-set)\n\n               is-pair? (>= (apply max (vals (frequencies rank))) 2)]\n           (if is-pair?\n             (let [is-three-of-a-kind? (>= (apply max (vals (frequencies rank))) 3)]\n               (if is-three-of-a-kind?\n                 (if (>= (apply max (vals (frequencies rank))) 4)\n                   :four-of-a-kind\n                   (if (= 2 (count (frequencies rank)))\n                     :full-house\n                     :three-of-a-kind))\n                 (if (= 3 (count (frequencies rank)))\n                   :two-pair :pair)))\n             (let [is-flush? (= (count (vals (frequencies suit)))1)\n                   is-straight? (let [rs (sort rank)\n                                      tester (range (first rs) (+ 5 (first rs)))]\n                                  (or (= rs tester) (= rs '(0 1 2 3 12)))) ]\n               (if (and is-straight? is-flush?)\n                 :straight-flush\n                 (if is-straight?\n                   :straight\n                   (if is-flush? :flush :high-card)))))))","user":"5cbd5b42e4b026601754b9f6"},{"problem":"178","code":"(fn besthand [cardvec]\n  (let [suits (map first cardvec)\n        ranks (map second cardvec)\n        ranks-to-ints (sort\n                       (map\n                        #(cond\n                           (<= % 57) (- % 48) ;ints\n                           (= % 84) 10 ;ten\n                           (= % 74) 11 ;jack\n                           (= % 81) 12 ;queen\n                           (= % 75) 13 ;king\n                           (= % 65) 14) ;ace\n                        (map int ranks)))\n        rti2 (if (some #(= % 14) ranks-to-ints)\n               (sort (map #(if (= % 14) 1 %) ranks-to-ints))\n               ranks-to-ints)\n        correct-seq (fn [h] (take 5 (iterate #(+ % 1) (first h))))\n        in-seq? (or\n                 (= (correct-seq ranks-to-ints) ranks-to-ints)\n                 (= (correct-seq rti2) rti2))\n        rankcounts (reverse (sort (map count (vals (group-by identity ranks)))))\n        suitcounts (reverse (sort (map count (vals (group-by identity suits)))))]\n    (cond\n      (and in-seq? (= 1 (count suitcounts)))\n      :straight-flush\n      (= 4 (first rankcounts))\n      :four-of-a-kind\n      (and (= 3 (first rankcounts)) (= 2 (second rankcounts)))\n      :full-house\n      (= 1 (count suitcounts))\n      :flush\n      in-seq?\n      :straight\n      (= 3 (first rankcounts))\n      :three-of-a-kind\n      (and (= 2 (first rankcounts)) (= 2 (second rankcounts)))\n      :two-pair\n      (= 2 (first rankcounts))\n      :pair\n      :else :high-card)))","user":"5705e404e4b0b0fb43fd0676"},{"problem":"178","code":"(fn [c] \n  (let [v  (frequencies (map second c))\n        s? (seq\n            (filter #(= (set (keys v)) %)\n                    (map set (partition 5  1 \"A23456789JTQKA\"))))\n        f? (apply = (map first c))\n        vs (sort (vals v))]\n    (cond\n     (and s? f?)         :straight-flush\n     f?                  :flush\n     s?                  :straight\n     :else (case vs\n             [ 1 1 1 2 ] :pair\n             [ 1 2 2 ]   :two-pair\n             [ 1 1 3 ]   :three-of-a-kind\n             [ 2 3 ]     :full-house\n             [ 1 4 ]     :four-of-a-kind\n             :high-card))))","user":"4e6ebd4a535d5021c1a89610"},{"code":"(fn [card-list]\n  (let [cs (map (fn [[s r]]\n                  {:suit s\n                   :rank ({\\2 0, \\3 1, \\4 2, \\5 3, \\6 4, \\7 5, \\8 6, \\9 7, \\T 8, \\J 9, \\Q 10, \\K 11, \\A 12} r)})\n                card-list)\n        ranks (sort (map #(% :rank) cs))\n        straight? (let [steps (map (fn [[a b]] (- b a)) (partition 2 1 ranks))]\n                    (or (= steps [1 1 1 1]) (= steps [1 1 1 9])))\n        by-rank-count (group-by count (partition-by identity ranks))\n        by-suit (group-by #(% :suit) cs)]\n    (cond\n     (and (= 1 (count by-suit)) straight?) :straight-flush\n     (by-rank-count 4) :four-of-a-kind\n     (and (by-rank-count 3) (by-rank-count 2)) :full-house\n     (= 1 (count by-suit)) :flush\n     straight? :straight\n     (by-rank-count 3) :three-of-a-kind\n     (= 2 (count (by-rank-count 2))) :two-pair\n     (by-rank-count 2) :pair\n     :default :high-card)))","problem":"178","user":"51b9d1f0e4b0e871ca49590b"},{"problem":"178","code":"(fn\n  [cards]\n  (let [suits {\\D :diamond, \\H :heart, \\C :club, \\S :spade}\n        ranks {\\2 0, \\3 1, \\4 2, \\5 3, \\6 4, \\7 5, \\8 6, \\9 7, \\T 8, \\J 9, \\Q 10, \\K 11, \\A 12}\n        hand (map (fn [[s r]] {:suit (suits s) :rank (ranks r)}) cards)\n        suits (set (map :suit hand))\n        ranks (sort (map :rank hand))\n        flush? (= 1 (count suits))\n        straight? (or (= (range (first ranks) (+ 5 (first ranks))) ranks)\n                      (and (= (last ranks) 12)\n                           (= (range (first ranks) (+ 4 (first ranks)))\n                              (butlast ranks))))\n        grouped-ranks (vals (frequencies ranks))]\n    (cond\n      (and flush? straight?) :straight-flush\n      (some #{4} grouped-ranks) :four-of-a-kind\n      (= [2 3] (sort grouped-ranks)) :full-house\n      flush? :flush\n      straight? :straight\n      (some #{3} grouped-ranks) :three-of-a-kind\n      (= [2 2] (rest (sort grouped-ranks))) :two-pair\n      (some #{2} grouped-ranks) :pair\n      :else :high-card)))","user":"5338387de4b0e30313ee6c91"},{"code":"(fn [s] \n\t(let [suits { \\D :diamond, \\H :heart, \\S :spade, \\C :club}\n          ranks (zipmap (map identity \"23456789TJQKA\") (range 13))]\n\t\t(letfn [(parse-cards [cards] \n\t\t\t\t\t(sort-by :rank\n                          (map (fn [x] (reduce #(hash-map :suit (get suits %1) :rank (get ranks %2) ) x)) cards)\n                     )\n\t\t\t\t)\n                (straight? [cards] \n      \t\t\t\t(or (= (map #(get % :rank) cards) (list 0 1 2 3 12))\n\t\t\t\t\t(first(reduce \n\t\t\t\t\t\t#(list (and (first %)(= (inc(last %)) (get %2 :rank))) (get %2 :rank)) \n\t\t\t\t\t\t(list true (get (first cards) :rank)) \n\t\t\t\t\t\t(rest cards))))\n\t\t\t\t)\n                (flush? [cards] \n      \t\t\t\t(= 5 (count (filter #(= (get (first cards) :suit)(get % :suit)) cards)))\n\t\t\t\t)\n                (x-of-a-kind [cards] \n      \t\t\t\t(map count (filter #(> (count %) 1) (partition-by  identity (map #(get % :rank) cards))))\n\t\t\t\t)\n                ]\n\t\t\t\n          \t(let [hands(list{:name :high-card, \t:predicate (fn [cards] true)}\n\t\t\t\t\t\t\t{:name :pair, \t\t:predicate (fn [cards] (= (list 2)(x-of-a-kind cards)))}\n\t\t\t\t\t\t\t{:name :two-pair, \t:predicate (fn [cards] (= (list 2 2)(x-of-a-kind cards)))}\n\t\t\t\t\t\t\t{:name :three-of-a-kind,:predicate (fn [cards] (= (list 3)(x-of-a-kind cards)))}\n\t\t\t\t\t\t\t{:name :straight,\t:predicate (fn [cards] (straight? cards))}\n\t\t\t\t\t\t\t{:name :flush,\t\t:predicate (fn [cards] (flush? cards))}\n\t\t\t\t\t\t\t{:name :full-house,\t:predicate (fn [cards] (= (list 2 3)(x-of-a-kind cards)))}\n\t\t\t\t\t\t\t{:name :four-of-a-kind,:predicate (fn [cards] (= (list 4)(x-of-a-kind cards)))}\n\t\t\t\t\t\t\t{:name :straight-flush,:predicate (fn [cards] (and (straight? cards) (flush? cards)))}\n\t\t\t\t\t\t)\n                  crds (parse-cards s)\n                  ]\n              \n\t\t\t\t(get (last (filter #((get % :predicate) crds) hands)) :name)\n            )\n\t\t)\n    )\n  )","problem":"178","user":"5274eb56e4b03e8d9a4a74bb"},{"problem":"178","code":"(fn [v]\n    (let [rank-map {\\2 2 \\3 3 \\4 4 \\5 5 \\6 6 \\7 7 \\8 8 \\9 9 \\T 10 \\J 11 \\Q 12 \\K 13 \\A 14}\n          rank-map-1 (assoc rank-map \\A 1)\n          suits (map first v)\n          ranks (map #(rank-map (second %)) v)\n          asc? (fn [m] (let [t (sort (map #(m (second %)) v))] (every? #(= 1 %) (map - (rest t) t))))\n          straight? (or (asc? rank-map) (asc? rank-map-1))\n          ranks-vals (sort (vals (frequencies ranks)))]\n (cond\n   (and (= 1 (count (into #{} suits))) straight?) :straight-flush\n   (= ranks-vals [1 4]) :four-of-a-kind\n   (= ranks-vals [2 3]) :full-house\n   (= 1 (count (into #{} suits))) :flush\n   straight? :straight\n   (contains? (into #{} ranks-vals) 3) :three-of-a-kind\n   (= ranks-vals [1 2 2]) :two-pair\n   (contains? (into #{} ranks-vals) 2) :pair\n   :else :high-card) ))","user":"5a4de614e4b05d388ecb6bb1"},{"code":"(fn [c]\n  (let [ranks1 {\"A\" 1 \"2\" 2 \"3\" 3 \"4\" 4 \"5\" 5 \"6\" 6 \"7\" 7 \"8\" 8 \"9\" 9 \"T\" 10 \"J\" 11 \"Q\" 12 \"K\" 13} ranks2 (assoc-in ranks1 [\"A\"] 14)]\n    (letfn [(freq [c] (frequencies (map #(second (vec %)) c)))\n            (SF? [c] (and (straight? c) (flush? c)))\n            (rows? [nums] (loop [i 1 nums (vec nums)]\n                            (if (>= i (count nums))\n                              true\n                              (if (not= 1 (- (nums i) (nums (dec i))))\n                                false\n                                (recur (inc i) nums)\n                                )\n                              )\n                            ))\n            (straight? [c] (or (rows? (sort (map #(ranks1 (str (second (vec %)))) c))) (rows? (sort (map #(ranks2 (str (second (vec %)))) c)))))\n            (flush? [c] (= 1 (count (set (map #(first (vec %)) c)))))\n            (four? [c] (= 1 (count (filter #(= (val %) 4) (freq c)))))\n            (three? [c] (= 1 (count (filter #(= (val %) 3) (freq c)))))\n            (two? [c] (= 2 (count (filter #(= (val %) 2) (freq c)))))\n            (pair? [c] (= 1 (count (filter #(= (val %) 2) (freq c)))))\n            (fullhouse? [c] (and (= 1 (count (filter #(= (val %) 2) (freq c)))) (= 1 (count (filter #(= (val %) 3) (freq c))))))\n          ]\n      (if (SF? c)\n\t:straight-flush\n       (if (four? c)\n          :four-of-a-kind\n          (if (fullhouse? c)\n            :full-house\n          (if (flush? c)\n            :flush\n          (if (straight? c)\n            :straight\n          (if (three? c)\n            :three-of-a-kind\n          (if (two? c)\n            :two-pair\n          (if (pair? c)\n            :pair\n            :high-card\n            )))))))))))","problem":"178","user":"52c1bd29e4b07a9af579236a"},{"problem":"178","code":"(fn [hand]\n  (let [[suit rank] (apply map list hand)\n       all-possible-straights (set (map frequencies (partition 5 1 \"A23456789TJQKA\")))\n       flush? (apply = suit)\n       straight? (not= (all-possible-straights (frequencies rank)) nil)\n       groupings (sort-by > (vals (frequencies rank)))]\n    (cond\n      (and straight? flush?) :straight-flush\n      (= groupings [4 1]) :four-of-a-kind\n      (= groupings [3 2]) :full-house\n      flush? :flush\n      straight? :straight\n      (= groupings [3 1 1]) :three-of-a-kind\n      (= groupings [2 2 1]) :two-pair\n      (= groupings [2 1 1 1]) :pair\n      :else :high-card)))","user":"57023fc2e4b08d47c97781db"},{"problem":"178","code":"(fn best-hand [coll]\n  (letfn [(parse-card [code]\n            (let [char2suit (fn [c]\n                              (condp = c\n                                \\S :spade\n                                \\H :heart\n                                \\D :diamond\n                                \\C :club))\n                  char2rank (fn [c]\n                              (condp = c\n                                \\T 8\n                                \\J 9\n                                \\Q 10\n                                \\K 11\n                                \\A 12\n                                (- (Character/digit c 10) 2)))]\n              {:suit (char2suit (first code)) :rank (char2rank (second code))}))\n          (straight-flush? [coll]\n            (and (apply = (map :suit coll))\n                 (let [ranks (map :rank coll)]\n                   (= (sort ranks) (range (apply min ranks) (+ 5 (apply min ranks)))))))\n          (four-of-a-kind? [coll]\n            (<= 4 (apply max (vals (frequencies (map :rank coll))))))\n          (full-house? [coll]\n            (= #{2 3} (set (vals (frequencies (map :rank coll))))))\n          (flush? [coll]\n            (apply = (map :suit coll)))\n          (straight? [coll]\n            (let [ranks (sort (map :rank coll))]\n              (or (= ranks '(0 1 2 3 12))\n                  (= ranks (range (apply min ranks) (+ 5 (apply min ranks)))))))\n          (three-of-a-kind? [coll]\n            (= 3 (apply max (vals (frequencies (map :rank coll))))))\n          (two-pair? [coll]\n            (= 3 (count (set (map :rank coll)))))\n          (pair? [coll]\n            (= 4 (count (set (map :rank coll)))))]\n    (let [coll (map parse-card coll)]\n      (cond\n        (straight-flush? coll) :straight-flush\n        (four-of-a-kind? coll) :four-of-a-kind\n        (full-house? coll) :full-house\n        (flush? coll) :flush\n        (straight? coll) :straight\n        (three-of-a-kind? coll) :three-of-a-kind\n        (two-pair? coll) :two-pair\n        (pair? coll) :pair\n        :else :high-card))))","user":"5d9c1226e4b0d3f9b434ad51"},{"problem":"178","code":"(fn best-hand [cs]\n  (let [run?  #(every? (fn [[a b]] (= (inc a) b)) (partition 2 1 (sort %))) \n        cards (map (fn [[s r]] [s ((zipmap \"A23456789TJQK\" (range)) r)])  cs)\n        flush? (apply = (map first cards))\n        ranks (map second cards)\n        straight? (or (run? ranks) (run? (replace {0 13} ranks))) \n        groups (-> ranks frequencies vals sort)]\n    (cond (and straight? flush?) :straight-flush\n          (some #{4} groups) :four-of-a-kind\n          (= [2 3] groups) :full-house\n          flush? :flush\n          straight? :straight\n          (some #{3} groups) :three-of-a-kind\n          (= [1 2 2] groups) :two-pair\n          (some #{2} groups) :pair\n          :else :high-card)))","user":"53b39d82e4b047364c0444a6"},{"problem":"178","code":"(fn [cs]\n  (let [a {\\T 8 \\J 9 \\Q 10 \\K 11 \\A 12}\n        b (assoc a \\A -1)\n        vc (map second cs)\n        [fk fv] (map frequencies [(map first cs) vc])\n        y (vals fv)\n        ?  (= 1 (count fk))\n        i #(- (int %) 50)\n        va (map #(a % (i %)) vc)\n        vb (map #(b % (i %)) vc)\n        p (count (filter #(= 2 %) y))\n        d #(= 4 (- (apply max %) (apply min %)))\n        s? (if (= 5 (count fv))\n               (or (d va) (d vb)))\n    ]\n    (cond\n      (and ? s?) :straight-flush\n      (some #(= 4 %) y) :four-of-a-kind\n      (= 2 (count fv)) :full-house\n      ? :flush\n      s? :straight\n      (some #(= 3 %) y) :three-of-a-kind\n      (= 2 p) :two-pair\n      (= 1 p) :pair\n      :e :high-card)))","user":"4ee4f4a9535d1385b2869d85"},{"code":"#(let [A apply\n       F frequencies\n       [s r] (A map list %)\n       f (F r)\n       x (vals f)]\n   ([:four-of-a-kind :full-house :three-of-a-kind :two-pair :pair 0\n     ([:high-card :straight :flush :straight-flush]\n      (+\n       ((F (map F (partition 5 1 \"A23456789TJQKA\"))) f 0)\n       (if (A = s) 2 0)))]\n    (- (count x) (A max x) -2)))","problem":"178","user":"4dc537fd535d8a4b2fd74282"},{"code":"(fn __ [h]\n  (let [card (fn [[s r]]\n               {:suit ({\\D :diamond \\H :heart \\C :club \\S :spade} s)\n                :rank (.indexOf (seq \"23456789TJQKA\") r)})\n        straight? (fn [hand]\n                    ; Try with A as both -1 and 12\n                    (let [parts (map #(list (%1 :rank) %2)\n                                     (sort-by #(% :rank) hand) (range 5))]\n                      (or (= (count (partition-by #(apply - %) parts)) 1)\n                          (= (count (partition-by #(apply - %)\n                                                  (cons (list (- (first (last parts)) 12) 0)\n                                                        (butlast parts)))) 1))\n                      ))\n        flush? (fn [hand] (apply = (map #(% :suit) hand)))\n        n-kind? (fn [n hand] (some #(= n (count %)) (vals (group-by #(% :rank) hand))))\n        two-pair? (fn [hand] (let [groups (group-by #(% :rank) hand)]\n                               (= 2 (count (filter #(= 2 (count %)) (vals groups))))))\n        hand (map card h)]\n    (cond\n     (and (straight? hand) (flush? hand)) :straight-flush\n     (n-kind? 4 hand) :four-of-a-kind\n     (and (n-kind? 3 hand) (n-kind? 2 hand)) :full-house\n     (flush? hand) :flush\n     (straight? hand) :straight\n     (n-kind? 3 hand) :three-of-a-kind\n     (two-pair? hand) :two-pair\n     (n-kind? 2 hand) :pair\n     :else :high-card\n     )\n    )\n  )","problem":"178","user":"52e59ca5e4b09f7907dd1464"},{"problem":"178","code":"(fn best-hand [cards]\n  (let [read-card (fn [desc]\n               (let [suit {\\S :spade \\H :heart \\D :diamond \\C :club}\n                     rank {\\2 0 \\3 1 \\4 2 \\5 3 \\6 4 \\7 5  \\8 6 \\9 7 \\T 8 \\J 9 \\Q 10 \\K 11 \\A 12}\n                     [s r] desc]\n                 {:suit (suit s) :rank (rank r)}))\n        cards (map read-card cards)\n        by-suit (map #(map :rank %) (vals (group-by :suit cards)))\n        by-rank (vals (group-by :rank cards))\n        in-sequence? (fn [coll] (->> (sort coll) (partition 2 1) \n                                     (every? (fn [[f s]] (= (inc f) s)))))\n        has-count? (fn [coll n] (= n (count coll)))\n        some-has-count? (fn [coll n] (some #(= n (count %)) coll))\n        ranks (map :rank cards)]\n    (cond\n     (and (has-count? by-suit 1) (in-sequence? (first by-suit))) :straight-flush\n     (some-has-count? by-rank 4) :four-of-a-kind\n     (and (has-count? by-rank 2) (some-has-count? by-rank 3)) :full-house\n     (has-count? by-suit 1) :flush\n     (or (in-sequence? ranks) (in-sequence? (replace {12 -1} ranks))) :straight\n     (some-has-count? by-rank 3) :three-of-a-kind\n     (and (has-count? by-rank 3) (some-has-count? by-rank 2)) :two-pair\n     (some-has-count? by-rank 2) :pair\n     :else :high-card)))","user":"51729002e4b044b2ef48a850"},{"problem":"178","code":"(fn best-hand [hand]\n  (letfn [(card [[suit rank]]\n            {:suit ({\\D :diamond\n                     \\S :spade\n                     \\C :club\n                     \\H :heart} suit)\n             :rank ((merge (zipmap (map #(-> %1 str first) (range 2 10)) (range))\n                           {\\T 8\n                            \\J 9\n                            \\Q 10\n                            \\K 11\n                            \\A 12}) rank)})\n\n\n          (flush? [hand]\n            (->> hand\n                 (map (comp :suit card))\n                 (distinct)\n                 (count)\n                 (= 1)))\n\n          (full-house? [hand]\n            (->> hand\n                 (map (comp :rank card))\n                 (partition-by identity)\n                 (map count)\n                 (sort)\n                 (= [2 3])))\n\n          (straight? [hand]\n            (let [ranks (->> hand\n                             (map (comp :rank card))\n                             (sort))]\n              (loop [[x & xs] ranks]\n                (cond\n                  (not xs)            true\n                  (= (inc x) (first xs))  (recur (next xs))\n                  :else               false))))\n\n\n\n          (n-of-kind? [n hand]\n            (->> hand\n                 (map (comp :rank card))\n                 (sort)\n                 (partition-by identity)\n                 (map count)\n                 (apply max)\n                 (= n)))\n\n          (two-pair? [hand]\n            (->> hand\n                 (map (comp :rank card))\n                 (partition-by identity)\n                 (map count)\n                 (sort)\n                 (= [1 2 2])))\n\n          (straight-flush? [hand]\n            (and (flush? hand)\n                 (straight? hand)))\n\n          (three-of-kind? [hand]\n            (n-of-kind? 3 hand))\n\n          (four-of-kind? [hand]\n            (n-of-kind? 4 hand))\n\n          (pair? [hand]\n            (n-of-kind? 2 hand))]\n    (cond\n      (straight-flush? hand) :straight-flush\n      (four-of-kind? hand) :four-of-a-kind\n      (full-house? hand) :full-house\n      (flush? hand) :flush\n      (straight? hand) :straight\n      (three-of-kind? hand) :three-of-a-kind\n      (two-pair? hand) :two-pair\n      (pair? hand) :pair\n      :else :high-card)))","user":"569dd6e8e4b0542e1f8d1480"},{"problem":"178","code":"(fn [cards]\n  (letfn [(ranks [cards]\n            (for [[k vs] (group-by first cards)]\n              (sort (map (fn [r]\n                           (case (second r)\n                             \\A 12\n                             \\K 11\n                             \\Q 10\n                             \\J 9\n                             \\T 8\n                             (- (int (second r)) (int \\2))))\n                         vs))))\n          (in-seq? [xs]\n            (let [xs (sort xs)]\n              (every? true? (map #(= % (dec %2)) xs (rest xs)))))\n          (len [n xs] (if-let [r (filter #(= n (count %)) xs)]\n                        (if (empty? r) nil r)))]\n    \n    (let [s (ranks cards)\n          r (partition-by identity (sort (flatten s)))]\n      (cond\n        (and (= 1 (count s)) (in-seq? (first s)))\n        :straight-flush\n        (len 4 r)\n        :four-of-a-kind\n        (and (len 3 r) (len 2 r))\n        :full-house\n        (= 1 (count s))\n        :flush\n        (or (in-seq? (flatten s))\n            (in-seq? (map #(if (= % 12) -1 %) (flatten s))))\n        :straight\n        (len 3 r)\n        :three-of-a-kind\n        (= 2 (count (len 2 r)))\n        :two-pair\n        (not= (flatten s) (distinct (flatten s)))\n        :pair\n        :else :high-card))))","user":"5712854ce4b07c98581c3a89"},{"problem":"178","code":"(fn best [cards]\n  (let [conv (fn [desc] (let [suits {\\S :spade \\H :heart \\D :diamond \\C :club}\n                              ranks {\\2 0 \\3 1 \\4 2 \\5 3 \\6 4 \\7 5 \\8 6 \\9 7 \\T 8 \\J 9 \\Q 10 \\K 11 \\A 12}\n                              [s r] (seq desc)]\n                          {:suit (suits s) :rank (ranks r)}))\n        pairs (map conv cards)\n        suits (set (map :suit pairs))\n        ranks (sort (map :rank pairs))\n        in-seq (fn [s] (= s (take 5 (iterate inc (first s)))))\n        rank-freqs (vals (frequencies ranks))]\n    (cond (and (= 1 (count suits)) (in-seq ranks)) :straight-flush\n          (some #(= % 4) rank-freqs) :four-of-a-kind\n          (= #{2 3} (set rank-freqs)) :full-house\n          (= 1 (count suits)) :flush\n          (or (in-seq ranks) (in-seq (sort (replace {12 -1} ranks)))) :straight\n          (some #(= % 3) rank-freqs) :three-of-a-kind\n          (= 2 (count (filter #(= % 2) rank-freqs))) :two-pair\n          (some #(= % 2) rank-freqs) :pair\n          :else :high-card)))","user":"52d3f666e4b09f7907dd1327"},{"problem":"178","code":"(fn [col]\n  (let [cards (map (fn [[s r]] {:suit s :rank (.indexOf \"23456789TJQKA\" (str r))}) col)\n        ranks (map :rank cards)\n        by-rank (sort (vals (frequencies ranks)))\n        flush? (= 1 (count (set (map :suit cards))))\n        straight? (let [check? (fn [c] (= (range 5) (map #(- % (first c)) c)))] (or (check? (sort ranks)) (check? (sort (map #(mod (inc %) 13) ranks)))))\n        ]\n    (cond\n      (and flush? straight?) :straight-flush\n      (= 4 (last by-rank)) :four-of-a-kind\n      (= [2 3] by-rank) :full-house\n      flush? :flush\n      straight? :straight\n      (= 3 (last by-rank)) :three-of-a-kind\n      (= [1 2 2] by-rank) :two-pair\n      (= [1 1 1 2] by-rank) :pair\n      :else :high-card)))","user":"4faf97d8e4b081705acca258"},{"problem":"178","code":"(fn best-hand [cards]\n   (let [extract (fn [n]\n                     (->> cards\n                         (map #(nth % n))\n                         (group-by identity)\n                         (map (fn [[v1 v2]] [v1 (count v2)]))\n                         (into {})))\n         suits (extract 0)\n         ranks (extract 1)\n         same-rank (apply max (vals ranks))\n         read-ranks (->> ranks keys)\n         non-aces (sort (map #(get '{\\2 0 \\3 1 \\4 2 \\5 3 \\6 4 \\7 5 \\8 6 \\9 7} %) (remove '#{\\T \\J \\Q \\K \\A} read-ranks)))\n         aces (filter '#{\\T \\J \\Q \\K \\A} read-ranks)\n         aces-low (sort (map #(get '{\\T -5 \\J -4 \\Q -3 \\K -2 \\A -1} %) aces))\n         aces-high (sort (map #(get '{\\T 8 \\J 9 \\Q 10 \\K 11 \\A 12} %) aces))\n         in-seq? (fn [sequ] (reduce #(cond (nil? %1) nil (= %2 (inc %1)) %2 :else nil) sequ))\n         seqd (or (in-seq? (concat aces-low non-aces)) (in-seq? (concat non-aces aces-high)))]\n        (cond\n          (and seqd (= 1 (count suits))) :straight-flush\n          (<= 4 same-rank) :four-of-a-kind\n          (= #{3 2} (set (vals ranks))) :full-house\n          (= 1 (count suits)) :flush\n          seqd :straight\n          (= 3 same-rank) :three-of-a-kind\n          (= 2 (count (remove #(< (second %) 2) ranks))) :two-pair\n          (= 2 same-rank) :pair\n          :else :high-card)))","user":"5f548678e4b0a0bc16850a7e"},{"problem":"178","code":"(fn poker [hand_str]\n  (let [create_card (fn [card]\n                      (let [suits {\\S :spade \\H :heart \\D :diamond \\C :club}\n                            ranks {\\2 0 \\3 1 \\4 2 \\5 3 \\6 4 \\7 5 \\8 6 \\9 7\n                                   \\T 8 \\J 9 \\Q 10 \\K 11 \\A 12}]\n                        {:suit (get suits (first card)) :rank (get ranks (last card))}))\n        hand (map create_card hand_str)\n        suits (map #(% :suit) hand)\n        ranks (sort (map #(% :rank) hand))\n        flush #(= 1 (count (partition-by identity suits)))\n        straight (fn []\n                   (or (= ranks '(0 1 2 3 12))\n                       (and (= 5 (count (distinct ranks)))\n                         (= 4 (apply + (map #(- (second %) (first %)) (partition 2 1 ranks)))))))\n        three_of_a_kind (fn []\n                          (= 3 (count (last (sort-by count (partition-by identity ranks))))))\n        four_of_a_kind (fn []\n                         (let [[a b & rest :as p] (partition-by identity ranks)]\n                           (and (= (count p) 2) (or (= (count a) 4)\n                                                    (= (count b) 4)))))\n        full_house (fn []\n                     (let [[a b & rest :as p] (partition-by identity ranks)]\n                       (and (= (count p) 2) (or (and (= (count a) 3) (= (count b) 2))\n                                                (and (= (count a) 2) (= (count b) 3))))))\n        straight_flush (fn [] (and (flush) (straight)))\n        two_pair (fn [] (= 2 (count (filter #(= 2 %) (map count (partition-by identity ranks))))))\n        pair (fn [] (= 1 (count (filter #(= 2 %) (map count (partition-by identity ranks))))))]\n    (cond\n      (straight_flush) :straight-flush\n      (four_of_a_kind) :four-of-a-kind\n      (full_house) :full-house\n      (flush) :flush\n      (straight) :straight\n      (three_of_a_kind) :three-of-a-kind\n      (two_pair) :two-pair\n      (pair) :pair\n      :else :high-card)))","user":"5046f909e4b03b02161376b5"},{"code":"(letfn [(color [x] (first x))\n        (level [card]\n             ({\\T 10 \\J 11 \\Q 12 \\K 13 \\A 14 \\9 9 \\8 8 \\7 7 \\6 6 \\5 5 \\4 4 \\3 3 \\2 2} (second card)))\n\n    (card [cards]\n         :high-card)\n    \n    (pair [cards]\n      (if\n       (= (level (first cards))\n          (level (second cards)))\n       :pair))\n    \n    (two-pair [cards]\n      (if\n       (= (map count (vals (group-by level cards)))\n          '(2 2))\n       :two-pair\n       ))\n    \n    (three [cards]\n      (if (= 1 (count (distinct (map level cards))))\n      :three-of-a-kind))\n    \n    (straight-flush [cards]\n      (if (and (straight cards)\n               (flush cards))\n          :straight-flush))\n    \n    (four [cards]\n      (if (= 1 (count (distinct (map level cards))))\n          :four-of-a-kind))\n    \n    (full [cards]\n      (if (= '(2 3)\n              (sort (map count (vals (group-by identity (map level cards))))))\n          :full-house))\n    \n    (flush [cards]\n      (if (= 1 (count (distinct (map color cards))))\n          :flush))\n    \n    (level-sequence? [levels]\n      (every? #(= (inc (first %)) (second %))\n              (partition 2 1 (sort levels))))\n    \n    (straight [cards]\n      (if (or (level-sequence? (map level cards))\n              (= '(2 3 4 5 14) (sort (map level cards))))\n          :straight))\n        \n\n(mcombinations [cards num]\n  (if (= 0 num)\n      '(())\n      (distinct (map set(apply concat (for [c cards]\n           (let [subcomb (mcombinations (disj (set cards) c) (dec num))]\n                (map #(conj % c) subcomb))))))))        \n        \n    \n    (selector [num tester]\n      (fn [hand]\n          (some tester (mcombinations hand num))))]\n          \n      (let [selectors (map #(selector %1 %2)\n                        [5 4 5 5 5 3 4 2 1]\n                        [straight-flush four full flush straight three two-pair pair card]\n                        )]\n    \n        (fn best-hand [cards]\n          (some #(% cards) selectors))))","problem":"178","user":"5165a235e4b079ad97ec44ac"},{"problem":"178","code":"(fn best-hand [ls]\n  (let [cards (map (fn [x]\n                     (let [card-seq (seq x)]\n                       {:suit (first card-seq)\n                       :rank (second card-seq)}))\n                   ls)]\n    (letfn [(flush? [lx] (apply = (map :suit lx)))\n            (straight? [lx]\n                       (some #(= (sort (map :rank lx)) %)\n                             (map sort (partition 5 1 \"A23456789TJQKA\"))))\n            (counts [lx]\n                    (let [c (reduce-kv\n                             (fn [m k v] (assoc m v (conj (get m v) k)))\n                             {}\n                             (frequencies (map :rank lx)))]\n                      (cond\n                       (get c 4) :four-of-a-kind\n                       (get c 3) (if (get c 2)\n                                   :full-house\n                                   :three-of-a-kind)\n                       :else ([:high-card :pair :two-pair] (count (get c 2))))))]\n      (cond\n       (flush? cards) (if (straight? cards)\n                        :straight-flush\n                        :flush)\n       (straight? cards) :straight\n       :else (counts cards)))))","user":"55f73078e4b06e875b46cea4"},{"problem":"178","code":"(fn best-hand\n  [alist]\n  (let [straight? (fn straight?\n                    [alist]\n                    (let [data (partition 5 1 [\\A \\2 \\3 \\4 \\5 \\6 \\7 \\8 \\9 \\T \\J \\Q \\K \\A])\n                          mapping-ranks (sort (map second alist))]\n                      (some #(= (sort %) mapping-ranks) data)))\n        n-o-a-kind? (fn n-o-a-kind?\n                      [n alist]\n                      (let [data (vals (group-by identity (apply str (map second alist))))]\n                        (if (= n :double-pair)\n                          (= (count (filter #(= (count %) 2) data)) 2)\n                          (some #(= (count %) n) data))))]\n    (cond\n      (= 1 (count (into #{} (map first alist)))) (if (straight? alist) :straight-flush :flush)\n      (n-o-a-kind? 4 alist) :four-of-a-kind\n      (and (n-o-a-kind? 3 alist) (n-o-a-kind? 2 alist)) :full-house\n      (straight? alist) :straight\n      (n-o-a-kind? 3 alist) :three-of-a-kind\n      (n-o-a-kind? :double-pair alist) :two-pair\n      (n-o-a-kind? 2 alist) :pair\n      :else :high-card)))","user":"550d9452e4b06e50f9beb15d"},{"problem":"178","code":"(fn [hand]\n          (let [nvah {\\A 14 \\K 13 \\Q 12 \\J 11 \\T 10 \\9 9 \\8 8 \\7 7 \\6 6 \\5 5 \\4 4 \\3 3 \\2 2}\n               nval (assoc nvah \\A 1)\n               straight? (fn straight? ([h]\n                              (or (straight? h nvah) (straight? h nval)))\n                           ([h cardmap]\n                            (let [snk (sort (map cardmap (map second h)))\n                                  span (range (first snk) (inc (last snk)))]\n                              (and (= snk span) (= 5 (count span))))))\n               isflush (apply = (map first hand))\n               fs (sort (vals (frequencies (map second hand))))]\n           (cond\n             (and (straight? hand) isflush) :straight-flush\n             (= '(1 4) fs)     :four-of-a-kind\n             (= '(2 3) fs)     :full-house\n             isflush           :flush\n             (straight? hand)  :straight \n             (= '(1 1 1 2) fs) :pair\n             (= '(1 1 3) fs)   :three-of-a-kind\n             (= '(1 2 2) fs)   :two-pair\n             :else             :high-card)))","user":"4e8768f6535dceadca469850"},{"problem":"178","code":"(fn poker [hand]\n  (let [counts #(->> %1 (group-by %2) (vals) (map count)) \n        has-val? #(some (partial = %1) %2)\n        card-vals (fn [ace-val h] (->> h (map second) (map {\\A ace-val \\K 13 \\Q 12 \\J 11 \\T 10 \\9 9 \\8 8 \\7 7 \\6 6 \\5 5 \\4 4 \\3 3 \\2 2}) (sort)))\n        straight? (fn [h aceval] (->> h (card-vals aceval) (#(map = % (map (partial + (apply min %)) (range 5)))) (reduce #(and %1 %2)) ))]\n    ((fn [h, is-flush, is-straight] \n       (cond\n        (and is-flush is-straight) :straight-flush\n        (has-val? 4 h) :four-of-a-kind\n        (and (has-val? 3 h) (has-val? 2 h)) :full-house \n        is-flush :flush\n        is-straight :straight\n        (has-val? 3 h) :three-of-a-kind\n        (->> h (filter (partial = 2)) (count) (= 2)) :two-pair\n        (has-val? 2 h) :pair\n        :else :high-card\n    ))\n     (counts hand second)\n     (-> hand (counts first) (first) (= 5) )\n     (or (straight? hand 1) (straight? hand 14) )\n)))","user":"5280a1ece4b0757a1b171407"},{"problem":"178","code":"(fn [card-reprs]\n  (let [suits {\\D :diamond \\S :spade \\H :heart \\C :club}\n        ranks {\\2 0 \\3 1 \\4 2 \\5 3 \\6 4 \\7 5 \\8 6 \\9 7 \\T 8 \\J 9 \\Q 10 \\K 11 \\A 12}\n        recognize (fn [[suit rank]] {:suit (get suits suit) :rank (get ranks rank)})\n        cards (map recognize card-reprs)\n        card-ranks (sort (map :rank cards))\n        card-suits (map :suit cards)\n        is-flush (apply = card-suits)\n        is-straight-high (= card-ranks (range (first card-ranks) (inc (last card-ranks))))\n        is-straight-low (= card-ranks [0 1 2 3 12])\n        is-straight (or is-straight-high is-straight-low)\n        counts (->> card-ranks (group-by identity) vals (map count) sort)]\n    (cond\n      (and is-flush is-straight) :straight-flush\n      (= counts [1 4]) :four-of-a-kind\n      (= counts [2 3]) :full-house\n      is-flush :flush\n      is-straight :straight\n      (= counts [1 1 3]) :three-of-a-kind\n      (= counts [1 2 2]) :two-pair\n      (= counts [1 1 1 2]) :pair\n      :else :high-card\n      )))","user":"549dfe40e4b0f3d1d8e70f9a"},{"problem":"178","code":"(let [parse-rank (fn [rank] (let [m {\\T 10 \\J 11 \\Q 12 \\K 13 \\A 14}] (m rank (- (int rank) (int \\0)))))\n      parse-card (fn [card] [(first card) (parse-rank (second card))])\n      parse-hand (fn [hand] (map parse-card hand))\n      is-flush (fn [h] (apply = (map first h)))\n      run-ranks (set (for [s (range 10)] (sort (map #({1 14} % %) (range (+ s 1) (+ s 6))))))\n      is-straight (fn [h] (run-ranks (sort (map second h))))\n      freq-counts (fn [h] (frequencies (vals (frequencies (map second h)))))\n      rules (array-map :straight-flush (fn [h] (and (is-straight h) (is-flush h)))\n                       :four-of-a-kind (fn [h] ((freq-counts h) 4))\n                       :full-house (fn [h] (let [c (freq-counts h)] (and (c 3) (c 2))))\n                       :flush is-flush\n                       :straight is-straight\n                       :three-of-a-kind (fn [h] ((freq-counts h) 3))\n                       :two-pair (fn [h] (= 2 ((freq-counts h) 2)))\n                       :pair (fn [h] ((freq-counts h) 2))\n                       :high-card identity)]\n  (fn [hand]\n    (let [h (parse-hand hand)]\n      (some (fn [[name f]] (when (f h) name)) rules))))","user":"5db92996e4b010eb3c36cd50"},{"code":"(fn [c]\n  (let [s (map first c)\n        r (map last  c)\n        f? (-> s set count (= 1))\n        se (fn [r a]\n             (let [ri (sort (map #(or ((conj {\\T 58 \\J 59 \\Q 60 \\K 61} [\\A a]) %) (int %)) r))]\n               (= ri (range (first ri) (inc (last ri))))))\n        s? (or (se r 49) (se r 62))\n        rn (map count (vals (group-by identity r)))\n        rs (set rn)]\n\n    (cond\n     (and f? s?) :straight-flush\n     (rs 4) :four-of-a-kind\n     (and (rs 3) (rs 2)) :full-house\n     f? :flush\n     s? :straight\n     (rs 3) :three-of-a-kind\n     (= 2 (count (filter #(= 2 %) rn))) :two-pair\n     (rs 2) :pair\n     1 :high-card)))","problem":"178","user":"53460d02e4b084c2834f4a39"},{"problem":"178","code":"(fn best-hand [card-strings]\n  (let [card-parser (fn [[s r]]\n                      (let [suit ({\\S :spade, \\H :heart, \n                                   \\D :diamond, \\C :club} s)\n                            rank (if (> (Character/digit r 10) -1)\n                                   (- (Character/digit r 10) 2)\n                                   ({\\T 8, \\J 9, \n                                     \\Q 10, \\K 11, \\A 12} r))]\n                        {:suit suit, :rank rank}))\n        cards (map card-parser card-strings)\n        suits (map :suit cards)\n        ranks (map :rank cards)\n        rank-freqs (sort (vals (frequencies ranks)))\n\n        flush? \n        (apply = suits) \n\n        straight? \n        (let [aces-high (sort ranks)\n              aces-low (sort (replace {12 -1} ranks))]\n          (or\n            (= aces-high (take 5 (iterate inc (first aces-high))))\n            (= aces-low  (take 5 (iterate inc (first aces-low))))))]\n    (cond \n      (and flush? straight?) :straight-flush\n      (= rank-freqs [1 4])   :four-of-a-kind\n      (= rank-freqs [2 3])   :full-house\n      flush?                 :flush\n      straight?              :straight\n      (some #{3} rank-freqs) :three-of-a-kind\n      (= rank-freqs [1 2 2]) :two-pair\n      (some #{2} rank-freqs) :pair\n      :else                  :high-card)))","user":"5662ca50e4b0e91d5f5c564c"},{"code":"(fn best-hand [hand]\n  (let [hand-by-rank (group-by #(get % 1) hand)\n        hand-by-suit (group-by #(get % 0) hand)\n        number-of-pairs (reduce #(if (= (count (second %2)) 2) (+ %1 1) %1) 0 hand-by-rank)\n        n-of-a-kind (fn [n] (some #(= (count (second %)) n) hand-by-rank))\n        three-of-a-kind (n-of-a-kind 3)\n        ranks (sort (map #({\\2 2 \\3 3 \\4 4 \\5 5 \\6 6 \\7 7 \\8 8 \\9 9 \\T 10 \\J 11 \\Q 12 \\K 13 \\A 0} (get % 1)) hand))\n        straight (empty? (drop-while #(cond (and (zero? (first %)) (or (= 2 (second %)) (= 10 (second %)))) true\n                                            (= (first %) (dec (second %))) true\n                                            :else false\n                                      ) (partition 2 1 ranks)))\n        flush (= 5 (count (second (first hand-by-suit))))\n        full-house (empty? (drop-while #(contains? #{2 3} (count (second %))) hand-by-rank))\n        four-of-a-kind (n-of-a-kind 4)\n        straight-flush (and straight flush)]\n    (cond straight-flush :straight-flush\n          four-of-a-kind :four-of-a-kind\n          full-house :full-house\n          flush :flush\n          straight :straight\n          three-of-a-kind :three-of-a-kind\n          (= number-of-pairs 2) :two-pair\n          (= number-of-pairs 1) :pair\n          :else :high-card\n    )\n  )\n)","problem":"178","user":"5272d4b7e4b03e8d9a4a7453"},{"code":"(fn hand-value [cards]\n  (let [suit          (fn [card]\n                        (first card))\n        value         (fn [card]\n                        (second card))\n        straight      (let [cvs (map (zipmap \"23456789TJQKA\" (range)) (map value cards))\n                            svs (sort cvs)\n                            vr  (rest svs)\n                            vm  (drop-last (map #(+ 1 %) svs))\n                            ]\n                        (or (= vr vm)\n                            (= svs [0 1 2 3 12])))\n        flush-          (apply = (map suit cards))\n        matches       (fn [num-cards num-matches]\n                        (= num-matches ((into {} (for [[k v] (group-by val (frequencies (map value cards)))]\n                                                   [k (count v)])) num-cards)))\n        ]\n    (cond (and straight flush-) :straight-flush\n          (matches 4 1) :four-of-a-kind\n          (and (matches 3 1) (matches 2 1)) :full-house\n          flush- :flush\n          straight :straight\n          (matches 3 1) :three-of-a-kind\n          (matches 2 2) :two-pair\n          (matches 2 1) :pair\n          :else :high-card\n     )))","problem":"178","user":"510cd1dde4b078ea71921124"},{"problem":"178","code":"(fn [cards]\n  (let [suits (map first cards)\n        flush? (apply = suits)\n        ranks (map second cards)\n        freq (sort (vals (frequencies ranks)))\n        straight? ((set (map set (partition 5 1 \"A23456789TJQKA\"))) (set ranks))]\n    (cond\n      (and flush? straight?) :straight-flush\n      (= [1 4] freq) :four-of-a-kind\n      (= [2 3] freq) :full-house\n      flush? :flush\n      straight? :straight\n      (some #{3} freq) :three-of-a-kind\n      (= [1 2 2] freq) :two-pair\n      (some #{2} freq) :pair\n      :else :high-card)))","user":"53ce4cd4e4b00fb29b2212ef"},{"problem":"178","code":"(fn [xs]\n   (let [table     {\\A 1 \\T 10 \\J 11 \\Q 12 \\K 13}\n         flush?    (= (count (set (map #(first %) xs))) 1)\n         nums      (sort (map #(or (table (last %)) (read-string (str (last %)))) xs))\n         straight? (or (= (count (set (map-indexed #(- %2 %) nums))) 1)\n                       (= nums [1 10 11 12 13]))\n         countc    (sort (vals (frequencies nums)))]\n     (cond (and straight? flush?):straight-flush\n           (= countc [1 4]) :four-of-a-kind\n           (= countc [2 3]) :full-house\n           flush? :flush\n           straight? :straight\n           (= countc [1 1 3]) :three-of-a-kind\n           (= countc [1 2 2]) :two-pair\n           (= countc [1 1 1 2]) :pair\n           :else :high-card\n           )\n     )\n   )","user":"56f7ecdfe4b08e7d20b96834"},{"problem":"178","code":"(fn [xs]\n  (let [rs {\\2 0 \\3 1 \\4 2 \\5 3 \\6 4 \\7 5 \\8 6 \\9 7 \\T 8 \\J 9 \\Q 10 \\K 11 \\A 12}\n        [s r] (apply map list xs)\n        ss (apply = s)\n        rs (sort (map rs r))\n        scal (.contains \"0123456789101112012312\" (apply str rs))\n        vs (sort (vals (frequencies rs)))]\n    (cond\n      (and ss scal)    :straight-flush\n      (= [1 4] vs)     :four-of-a-kind\n      (= [2 3] vs)     :full-house\n      ss               :flush\n      scal             :straight\n      (= [1 1 3] vs)   :three-of-a-kind\n      (= [1 2 2] vs)   :two-pair\n      (= [1 1 1 2] vs) :pair\n      :else            :high-card)))","user":"5d81b40ce4b0915913b1d379"},{"code":"(let [seed-map {\\S :spade \\H :heart \\D :diamond \\C :club}\n      rank-map {\\2 2 \\3 3 \\4 4 \\5 5 \\6 6 \\7 7 \\8 8 \n                \\9 9 \\T 10 \\J 11 \\Q 12 \\K 13 \\A 14}\n      in-sequence? (fn [s] \n               (->> (sort s)\n                 (map-indexed (fn [i r] (- r i)))\n                 (apply =)))\n      in-hand-sequence? (fn [h] \n                          (or (in-sequence? h)\n                              (in-sequence? (replace {14 1} h))))]\n  (fn best [hand]\n    (let [map-hand (map (fn [[s r]] \n                          {:suit (seed-map s) \n                           :rank (rank-map r)}) \n                        hand)\n          hand-by-suit (group-by :suit map-hand)\n          count-hand-by-suit (count hand-by-suit)\n          hand-by-rank (group-by :rank map-hand)\n          count-hand-by-rank (count hand-by-rank)\n          keys-hand-by-rank (keys hand-by-rank)\n          vals-hand-by-rank (delay (vals hand-by-rank))\n          straight-flush (and (= 1 count-hand-by-suit) \n                              (= 5 count-hand-by-rank)\n                              (in-hand-sequence? keys-hand-by-rank))\n          four-of-a-kind (delay \n                           (and (= 2 count-hand-by-rank)\n                                (= 4 (apply max (map count @vals-hand-by-rank)))))\n          full-house (delay \n                       (and (= 2 count-hand-by-rank)\n                            (= 3 (apply max (map count @vals-hand-by-rank)))))\n          flush (delay (= 1 count-hand-by-suit))\n          straight (delay (and (= 5 count-hand-by-rank)\n                               (in-hand-sequence? keys-hand-by-rank)))\n          three-of-a-kind (delay \n                            (and (= 3 count-hand-by-rank)\n                                 (= 3 (apply max (map count @vals-hand-by-rank)))))\n          two-pair (delay \n                     (and (= 3 count-hand-by-rank)\n                          (= 2 (apply max (map count @vals-hand-by-rank)))))\n          pair (delay (= 4 count-hand-by-rank))] \n      (cond straight-flush :straight-flush\n            @four-of-a-kind :four-of-a-kind\n            @full-house :full-house\n            @flush :flush\n            @straight :straight\n            @three-of-a-kind :three-of-a-kind\n            @two-pair :two-pair\n            @pair :pair\n            :else :high-card))))","problem":"178","user":"5246e945e4b0644eb7b0783b"},{"problem":"178","code":"(fn [cards]\n  (let [suits {\\S :spade \\H :heart \\C :club \\D :diamond}\n        ranks {\\2 1 \\3 2 \\4 3 \\5 4 \\6 5 \\7 6 \\8 7 \\9 8 \\T 9 \\J 10 \\Q 11 \\K 12 \\A 13}\n        hand (map #(hash-map :suit (get suits (first %)) :rank (get ranks (second %)))\n               cards)\n        sorted-hand (sort (map :rank hand))\n        Asorted-hand (sort (map #(if (= 13 (:rank %)) 0 (:rank %)) hand))\n        flush? (= 1 (count (group-by :suit hand)))\n        straight? (or (= 4 (- (last sorted-hand) (first sorted-hand)))\n                    (= 4 (- (last Asorted-hand) (first Asorted-hand))))\n        groups (filter #(> % 1)\n                 (sort (map #(count (val %)) (group-by identity sorted-hand))))]\n    (cond (and flush? straight? (empty? groups)) :straight-flush\n      (and (not-empty groups) (= 4 (first groups))) :four-of-a-kind\n      (and (= 2 (count groups)) (= 3 (last groups))) :full-house\n      flush? :flush\n      (and straight? (empty? groups)) :straight\n      (and (not-empty groups) (= 3 (first groups))) :three-of-a-kind\n      (= 2 (count groups)) :two-pair\n      (not-empty groups) :pair\n      :else :high-card)))","user":"55205564e4b08d5046aa8a60"},{"code":"(fn [cards]\n    (let [suit (fn [s] ({\\D :diamond, \\S :spade, \\H :heart, \\C :club} (first s)))\n          rank (fn [s] ({\\2 0, \\3 1, \\4 2, \\5 3, \\6 4, \\7 5, \\8 6, \\9 7, \\T 8, \\J 9, \\Q 10, \\K 11, \\A 12} (second s)))\n          suits (map suit cards)\n          ranks (map rank cards)\n          rank-freqs (vals (frequencies ranks))]\n      ;; (print \"suits\" suits \"ranks\" ranks \"rank-freqs\" rank-freqs) ; DEBUG\n      (cond (and (= 1 (count (set suits)))\n                 (= 4 (- (apply max ranks) (apply min ranks))))\n            :straight-flush\n\n            (some #{4} rank-freqs)\n            :four-of-a-kind\n\n            (and (some #{3} rank-freqs)\n                 (some #{2} rank-freqs))\n            :full-house\n\n            (= 1 (count (set suits)))\n            :flush\n\n            ;; TODO aces must be able to be counted as low, too\n            (let [min-rank (apply min ranks)\n                  max-rank (apply max ranks)]\n              (or (= (set (range min-rank (+ min-rank 5))) (set ranks))\n                  (and (= max-rank 12)\n                       (= #{12 0 1 2 3} (set ranks)))))\n            :straight\n\n            (some #{3} rank-freqs)\n            :three-of-a-kind\n\n            (some #{2} (vals (frequencies rank-freqs)))\n            :two-pair\n\n            (some #{2} rank-freqs)\n            :pair\n\n            :else\n            :high-card)))","problem":"178","user":"4e89e939535d3e98b8023287"},{"problem":"178","code":"(fn r [s]\n  (let [rank {\\T 8 \\J 9 \\Q 10 \\K 11 \\A 12}\n        f (fn [[k v]]\n            {k ((clojure.set/union\n                  (zipmap (map char (range 49 58)) (range -1 8)) rank) v)})\n        s (map f s)\n        k (flatten (map keys s))\n        v (flatten (map vals s))\n        [fv & ov :as sv] (sort v)\n        lv (last sv)\n        frq-v (->> v (frequencies) (vals) (sort))\n        flush? (apply = k)\n        straight? (or (= sv '(0 1 2 3 12)) (= sv (range fv (inc lv))))]\n    (cond\n      (and flush? straight?) :straight-flush\n      (some #{4}  frq-v)     :four-of-a-kind\n      (= '(2 3)   frq-v)     :full-house\n      flush?                 :flush\n      straight?              :straight\n      (some #{3}  frq-v)     :three-of-a-kind\n      (= '(1 2 2) frq-v)     :two-pair\n      (some #{2}  frq-v)     :pair\n      :else                  :high-card)))","user":"51aefceee4b09397d5109797"},{"problem":"178","code":"(fn best-hand [hand]\n\t(letfn [(is-flush? [hand]\n\t\t\t\t\t\t\t\t\t\t (case (count (reduce (fn [l i] (conj l (first i))) #{} hand))\n\t\t\t\t\t\t\t\t\t\t\t 1 true\n\t\t\t\t\t\t\t\t\t\t\t false))\n\t\t\t\t\t(contains-king? [hand]\n\t\t(= 1 (count (filter #(= \\K (last %)) hand))))\n\t\t\t\t\t(is-straight? [hand]\n\t\t\t\t\t\t\t\t\t\t\t\t(let [ranks (map (fn [x] (case x\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \\A (if (contains-king? hand) 14 1)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \\T 10\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \\J 11\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \\Q 12\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \\K 13\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t (- (int x) 48))) (map #(last %) hand))]\n\t\t\t\t\t\t\t\t\t\t\t\t\t(loop [fi (first (sort ranks)) li (rest (sort ranks))]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t(if (empty? li)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttrue\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(if (not= fi (dec (first li)))\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfalse\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(recur (first li) (rest li)))))))\n\t\t\t\t\t(analyze-rank [hand]\n\t(let [rank-count (filter #(> (last %) 1) (reduce (fn [l i] (if (contains? l (last i))\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t (assoc l (last i) (inc (get l (last i)))) \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t (assoc l (last i) 1))) {} hand))]\n\t\t(if (= 1 (count rank-count))\n\t\t\t(case (last (last rank-count))\n\t\t\t\t2 :pair\n\t\t\t\t3 :three-of-a-kind\n\t\t\t\t4 :four-of-a-kind\n\t\t\t\t:high-card)\n\t\t\t(if (= (reduce + (map #(last %) rank-count)) 4)\n\t\t\t\t:two-pair\n\t\t\t\t(if (empty? rank-count) :high-card :full-house)))))]\n\t\t(let [rank (analyze-rank hand)]\n\t\t\t(cond\n\t\t\t (and (is-straight? hand) (is-flush? hand)) :straight-flush\n\t\t\t (or (= rank :four-of-a-kind) (= rank :full-house)) rank\n\t\t\t (is-flush? hand) :flush\n\t\t\t (is-straight? hand) :straight\n\t\t\t :else rank))))","user":"52979551e4b02ebb4ef75043"},{"problem":"178","code":"(let [suits {\\D :diamond \\C :club \\H :heart \\S :spade}\n         ranks {\\2 0 \\3 1 \\4 2 \\5 3 \\6 4 \\7 5 \\8 6 \\9 7\n                \\T 8 \\J 9  \\Q 10 \\K 11 \\A 12}]\n     (letfn [(recognize-card [c]\n               {:suit (get suits (first c)) :rank (get ranks (second c))})\n             (counts-by [f coll]\n               (->> coll\n                    (map f)\n                    frequencies\n                    vals\n                    (sort-by >)))\n             (count-ranks [cs]\n               (counts-by :rank cs))\n             (run? [cs]\n               (->> cs\n                    (map :rank)\n                    sort\n                    (partition 2 1)\n                    (every? (fn [[a b]] (= (inc a) b)))))             \n             (flush? [cs]\n               (apply = (map :suit cs)))\n             (ace-low [cs]\n               (map #(if (= (:rank %) 12) (assoc % :rank -1) %) cs))             \n             (straight? [cs]\n               (or (run? cs) (run? (ace-low cs))))\n             (evaluate-hand [cs]\n               (let [flush (flush? cs)\n                     straight (straight? cs)\n                     [a b] (count-ranks cs)]\n                 (cond\n                   (and straight flush)  :straight-flush\n                   (= a 4)               :four-of-a-kind\n                   (and (= a 3) (= b 2)) :full-house\n                   flush                 :flush\n                   straight              :straight\n                   (= a 3)               :three-of-a-kind\n                   (and (= a 2) (= b 2)) :two-pair\n                   (= a 2)               :pair\n                   :else                 :high-card)))]\n       \n       (fn [cs]\n         (->> cs\n              (map recognize-card)\n              evaluate-hand))))","user":"4dfe5a93535d04ed9115e786"},{"code":"(fn [c]\n  (let [h (map (fn [[s r]]\n                    [((zipmap \"A23456789TJQK\" (range)) r) s])\n                  c)\n        g (sort (map count (vals (group-by first h))))\n        r (map sort ((juxt identity #(replace [13] %)) (map first h)))\n        s (some true? (map #(= % (take 5 (drop (first %) (range)))) r))\n        f (apply = (map second h))\n        ]\n    (cond\n     (and s f) :straight-flush\n     (= g [1 4]) :four-of-a-kind\n     (= g [2 3]) :full-house\n     f :flush\n     s :straight\n     (= (last g) 3) :three-of-a-kind\n     (= (take-last 2 g) [2 2]) :two-pair\n     (= (last g) 2) :pair\n     :else :high-card)))","problem":"178","user":"4ebaf790535dfed6da9c6d6e"},{"problem":"178","code":"(fn recognize [s]\n  (let [order {:A 14\n               :K 13\n               :Q 12\n               :J 11\n               :T 10\n               :9 9\n               :8 8\n               :7 7\n               :6 6\n               :5 5\n               :4 4\n               :3 3\n               :2 2}]\n    (letfn [(look-up [rank o] (o (keyword (str rank))))\n            (ranks-aces-high [s] (map\n                                  #(look-up (second %)\n                                            order) s))\n            (ranks-aces-low [s] (map\n                                 #(look-up (second %)\n                                           (assoc order :A 1)) s))\n            (rank-desc? [ranks] (= ranks\n                                   (range (first ranks) (dec (last ranks)) -1)))\n            (rank-asc? [ranks] (= ranks\n                                  (range (first ranks) (inc (last ranks)))))\n            (flush [s]\n              (every? (partial = (ffirst s)) (map first s)))\n            (straight [s]\n              (or (rank-asc? (ranks-aces-low s))\n                  (rank-desc? (ranks-aces-high s))))\n            (straight-flush [s]\n              (and (straight s) (flush s)))\n            (n-of-kind [s n] (some #(= n (second %))\n                                 (frequencies (map second s))))\n            (full-house [s] (let [g (frequencies (map second s))\n                                  a (second (first g))\n                                  b (second (second g))]\n                              (= [2 3] (sort [a b]))))\n            (two-pair [s] (= 2 (count (filter #(= (second %) 2)\n                                              (frequencies (map second s))))))\n            (pair [s] (some (partial = 2)\n                            (map second (frequencies (map second s)))))]\n      (cond\n        (straight-flush s) :straight-flush\n        (n-of-kind s 4) :four-of-a-kind\n        (full-house s) :full-house\n        (flush s) :flush\n        (straight s) :straight\n        (n-of-kind s 3) :three-of-a-kind\n        (two-pair s) :two-pair\n        (pair s) :pair        \n        :else :high-card))))","user":"587ee260e4b052da650a6353"},{"problem":"178","code":"(fn [xs]\n  (let [xs (map (fn [s]\n                  (let [a (first s)\n                        b (second s)\n                        i (- (int b) (int \\2))]\n                    {:suit (case a\n                             \\S :spades\n                             \\H :heart\n                             \\D :diamond\n                             \\C :club\n                             nil)\n                    :rank (cond\n                           (<= 0 i 7) i\n                           (= b \\T) 8\n                           (= b \\J) 9\n                           (= b \\Q) 10\n                           (= b \\K) 11\n                           (= b \\A) 12)})) \n                xs)\n        is-seq-1 (fn [xs]\n                   (= (sort xs) (range (apply min xs) (inc (apply max xs)))))\n        is-seq (fn [xs]\n                 (or (is-seq-1 (replace {12 -1} xs)) (is-seq-1 xs)))]\n    (cond\n     \n     (and (apply = (map :suit xs))\n          (is-seq (map :rank xs)))\n     :straight-flush\n     \n     (let [xs (sort (map :rank xs))]\n       (or (apply = (rest xs)) \n           (apply = (take 4 xs))))\n     :four-of-a-kind\n     \n     (let [xs (sort (map :rank xs))]\n       (or (and (apply = (take 2 xs)) (apply = (drop 2 xs)))\n           (and (apply = (take 3 xs)) (apply = (drop 3 xs)))))\n     :full-house\t\t\n     \n     (apply = (map :suit xs))\n     :flush\n     \n     (is-seq (map :rank xs))\n     :straight\n     \n     (let [xs (sort (map :rank xs))]\n       (or (apply = (take 3 xs)) \n           (apply = (drop 2 xs))))\n     :three-of-a-kind\n     \n     (let [xs (sort (map :rank xs))]\n       (or (and (= (nth xs 0) (nth xs 1)) (= (nth xs 2) (nth xs 3)))\n           (and (= (nth xs 0) (nth xs 1)) (= (nth xs 3) (nth xs 4)))\n           (and (= (nth xs 1) (nth xs 2)) (= (nth xs 3) (nth xs 4)))))\n     :two-pair\n     \n     (let [xs (sort (map :rank xs))]\n       (or (= (nth xs 0) (nth xs 1))\n           (= (nth xs 1) (nth xs 2))\n           (= (nth xs 2) (nth xs 3))\n           (= (nth xs 3) (nth xs 4))))\n     :pair\n     \n     :else \n     :high-card)))","user":"5799ff45e4b05b1deef9add1"},{"problem":"178","code":"(fn best-hand\n  [hand-cards]\n  (let [[suits ranks] (apply map list hand-cards)\n        straight-set (set (map set (partition 5 1 \"A23456789TJQKA\")))\n        straight? (straight-set (set ranks))\n        flush? (apply = suits)\n        kind-of (frequencies (vals (frequencies ranks)))]\n    (cond\n      (and straight? flush?) :straight-flush\n      (kind-of 4) :four-of-a-kind\n      (and (kind-of 3) (kind-of 2)) :full-house\n      flush? :flush\n      straight? :straight\n      (kind-of 3) :three-of-a-kind\n      (= 2 (kind-of 2)) :two-pair\n      (kind-of 2) :pair\n      :else :high-card)))","user":"4e586949535d8a8b8723a292"},{"problem":"178","code":"(fn [hand]\n  (let [[suits ranks] (apply map vector hand)\n        flush (apply = suits)\n        straight (let [vs (sort (map (zipmap \"A23456789TJQK\" (drop 1 (range))) ranks))]\n                      (some (->> vs cycle (partition 5 1) (take 2) set)\n                            (->> (range 1 14) cycle (partition 5 1) (take 10))))\n        counts (->> ranks frequencies vals sort)]\n      (cond\n       (and flush straight) :straight-flush\n       (= counts [1 4])     :four-of-a-kind\n       (= counts [2 3])     :full-house\n       flush                :flush\n       straight             :straight\n       (= counts [1 1 3])   :three-of-a-kind\n       (= counts [1 2 2])   :two-pair\n       (= counts [1 1 1 2]) :pair\n       :else :high-card)))","user":"4e6a4950535d8ccf87e9febf"},{"problem":"178","code":"(fn [codes]\n    (let [code2struc (fn [[suit rank]]\n                       {:suit ({\\S :spade \\H :heart \\D :diamond \\C :club} suit)\n                        ;Rank: 2..9, 10 (\"T\"), Jack, Queen, King, and Ace -> here 0..12\n                        :rank (let [ascii (int rank)]\n                                (if (<= ascii (int \\9))\n                                  (- ascii (int \\2))\n                                  ({\\T 8 \\J 9 \\Q 10 \\K 11 \\A 12} rank)))})\n          strucs (map code2struc codes)\n          _ (println :strucs strucs)\n          \n          suits (#_dbgf map :suit strucs)\n          ranks (#_dbgf map :rank strucs)\n          _ (println :ranks ranks)\n          \n          same-suit (apply = suits)\n          each-rank-unique (= (count (into #{} ranks)) 5) ;each rank unique. Instead, could use (distinct ...), or with new CLJ could use (dedupe ..)\n          \n          standard-sequence (and each-rank-unique\n                                 (= (- (apply max ranks) (apply min ranks))\n                                    4))\n          _ (println :standard-sequence standard-sequence)\n          map-by-rank-rev-inv (#_dbgf #_\"into\" into\n                                (#_dbgf sorted-map-by (fn [vec1 vec2] ; reverse; partial order by number of cards per rank, then any consistent (hence by (str ...))\n                                                        (if (= (count vec1) (count vec2))\n                                                          ;vectors are comparable, but their components - maps - are not! Hence (str ...)\n                                                          (#_dbgf compare (str vec2) (str vec1)) ;reverse, hence param vec2 first\n                                                          (#_dbgf > (count vec1) (count vec2))))) ;reverse, hence op. >\n                                (clojure.set/map-invert (group-by :rank strucs)))\n          Xseq-by-rank-rev-inv (sort-by\n                                 (comp - count first) ;most frequent rank first; can't use sort-by neither reverse, as those turn a map into a sequence - bad for (vals ...) below\n                                 (clojure.set/map-invert\n                                   (group-by :rank strucs)))\n          _ (println :by-rank-rev-inv map-by-rank-rev-inv)\n          nth-frequent-rank-occurrence (fn [pos]\n                                         ;(#_dbgf #_\"count nth seq\" count (key (nth seq-by-rank-rev-inv pos)))\n                                         (#_dbgf #_\"count nth seq\" count (nth (keys map-by-rank-rev-inv) pos)))]\n      ;three-of-a-kind (= (nth-frequent-rank-occurrence 0) 3)]\n      (cond\n        (and same-suit standard-sequence)\n        :straight-flush\n        \n        #_(some (fn [[_ cards]] (= (count cards) 4)) by-rank)\n        (= (nth-frequent-rank-occurrence 0) 4)\n        :four-of-a-kind\n        \n        (and (= (count map-by-rank-rev-inv) 2)\n             (= (nth-frequent-rank-occurrence 0) 3)) ;the other group must have 2 cards, since we have 2 groups only\n        :full-house\n        \n        same-suit\n        :flush\n        \n        (or standard-sequence\n            (let [non-aces (filter #(not= 12 %) ranks)\n                  _ (println :non-aces non-aces)]\n              (and (= (count non-aces) 4)\n                   each-rank-unique\n                   (= (apply min non-aces) 0)\n                   (= (apply max non-aces) 3))))\n        \n        :straight\n        \n        (= (nth-frequent-rank-occurrence 0) 3)\n        :three-of-a-kind\n        \n        (= (nth-frequent-rank-occurrence 0)\n           (nth-frequent-rank-occurrence 1)\n           2)\n        :two-pair\n        \n        (= (nth-frequent-rank-occurrence 0) 2)\n        :pair\n        \n        :else\n        :high-card)))","user":"5b999af8e4b0c0b3ffbd4ad3"},{"code":"#(let [[S R] (apply map list %)\n       k (-> R frequencies vals sort)\n       f (apply = S)\n       s (.contains\n          \"AKQJT98765432A.A23456789TJQKA\"\n          (apply str R))]\n   (cond\n    (if s f) :straight-flush\n    (= k [1 4]) :four-of-a-kind\n    (= k [2 3]) :full-house\n    f :flush\n    s :straight\n    (= k [1 1 3]) :three-of-a-kind\n    (= k [1 2 2]) :two-pair\n    (= k [1 1 1 2]) :pair\n    0 :high-card))","problem":"178","user":"4db858d1535d1e037afb218c"},{"code":"(fn best-hand [hand]\n\t(let \n\t  [recognize (fn recognize [card]\n\t\t  (let [[suit rank] (seq card)\n\t\t        rankval (cond \n\t\t                  (= rank \\A) 12\n\t\t                  (= rank \\K) 11\n\t\t                  (= rank \\Q) 10\n\t\t                  (= rank \\J) 9\n\t\t                  (= rank \\T) 8\n\t\t                  :else (- (int rank) (int \\2)))\n\t\t        suitname (cond\n\t\t                    (= suit \\D) :diamond\n\t\t                    (= suit \\H) :heart\n\t\t                    (= suit \\S) :spade\n\t\t                    (= suit \\C) :club)]\n\t\t    {:suit suitname :rank rankval}))\n    parsed-hand (map recognize hand)\n    suits (map :suit parsed-hand)\n    _ (println suits)\n    ranks (map :rank parsed-hand)\n    _ (println ranks)\n    suit-counts (frequencies suits)\n    rank-counts (frequencies ranks)\n    rank-vec (map rank-counts [12 0 1 2 3 4 5 6 7 8 9 10 11 12])\n    _ (println rank-vec)\n    flush? (some #{5} (vals suit-counts))\n    _ (println (partition 5 1 rank-vec))\n    straight? (some #(every? #{1} %) (partition 5 1 rank-vec))\n    _ (println straight?)\n    most-of-a-kind (apply max (vals rank-counts))\n    _ (println most-of-a-kind)\n    num-pairs (->> rank-counts vals (filter #{2}) count)\n    _ (println num-pairs)]\n   (cond\n     (and flush? straight?) :straight-flush\n     (= 4 most-of-a-kind) :four-of-a-kind\n     (and (= 3 most-of-a-kind)\n          (= 1 num-pairs)) :full-house\n     flush? :flush\n     straight? :straight\n     (= 3 most-of-a-kind) :three-of-a-kind\n     (= 2 num-pairs) :two-pair\n     (= 1 num-pairs) :pair\n     :else :high-card)))","problem":"178","user":"4f036fb3535dcb61093f6ac8"},{"problem":"178","code":"(fn [hand]\n  (let [face-vals [\\2 \\3 \\4 \\5 \\6 \\7 \\8 \\9 \\T \\J \\Q \\K \\A]\n        f-idx #(.indexOf face-vals %)\n        s-h (sort-by #(f-idx (last %)) hand)\n        [suits ranks] (reduce (fn [acc card]\n                                [(conj (first acc) (first card))\n                                 (conj (last acc) (last card))])\n                              [[] []]\n                              s-h)\n        flush? (= 1 (count (set suits)))\n        straight? (reduce (fn [s? [c1 c2]]\n                            (and s?\n                                 (= 1 (- (f-idx c2)\n                                         (f-idx c1)))))\n                          true\n                          (partition\n                           2 1\n                           (if (and (= \\2 (first ranks))\n                                    (= \\A (last ranks)))\n                             (butlast ranks)\n                             ranks)))\n        rank-freqs (vals (frequencies ranks))]\n    (cond\n      (and straight? flush?) :straight-flush\n      (some (partial = 4) rank-freqs) :four-of-a-kind\n      (and\n       (some (partial = 3) rank-freqs)\n       (some (partial = 2) rank-freqs)) :full-house\n      flush? :flush\n      straight? :straight\n      (some (partial = 3) rank-freqs) :three-of-a-kind\n      (= 2\n         (count\n          (filter (partial = 2) rank-freqs))) :two-pair\n      (some (partial = 2) rank-freqs) :pair\n      :else :high-card)))","user":"540a4f20e4b0addc1aec66ef"},{"problem":"178","code":"(fn [hand]\r\n  (let [rank-order [\\A \\2 \\3 \\4 \\5 \\6 \\7 \\8 \\9 \\T \\J \\Q \\K \\A]]    \r\n    (letfn [(flush? [h] (apply = (map first h)))\r\n            (straight? [h] (some\r\n                            #(= (set (map second h)) (set %))\r\n                            (partition 5 1 rank-order)))\r\n            (straight-flush? [h] (and (flush? h) (straight? h))) \r\n            (result [h]\r\n              (let [f (->> (map second hand) frequencies (group-by second))]\r\n                (cond\r\n                 (straight-flush? h) :straight-flush\r\n                 (f 4) :four-of-a-kind\r\n                 (and (f 3) (f 2)) :full-house\r\n                 (flush? h) :flush\r\n                 (straight? h) :straight\r\n                 (f 3) :three-of-a-kind\r\n                 (= 2 (-> 2 f count)) :two-pair\r\n                 (f 2) :pair\r\n                 :else :high-card)))]\r\n      (result hand))))","user":"53c649d3e4b00fb29b221297"},{"problem":"178","code":"(fn [ss]\n  (let [frank (vals (frequencies (map last ss)))\n        ranks (zipmap \"23456789TJQKA\" (range))\n        ranks1 (zipmap \"A23456789TJQK\" (range))\n        test_straight (fn [rs xs]\n                              (->> xs\n                              (map #(rs (last %)))\n                              (sort)\n                              ((fn [xs] (= xs (range (first xs) (inc (last xs))))))))\n        straight? (fn [ss] (or (test_straight ranks ss) (test_straight ranks1 ss)))\n        flush? (fn [ss] (= 1 (count (set (map first ss)))))]\n    (println frank)\n    (cond\n      (and (flush? ss) (straight? ss))   :straight-flush\n      (= 4 (apply max frank))           :four-of-a-kind\n      (= [2 3] (sort frank))                :full-house\n      (flush? ss)    :flush\n      (straight? ss)  :straight\n      (= 3 (apply max frank))   :three-of-a-kind\n      (= 3 (count frank))         :two-pair\n      (= 2 (apply max frank))   :pair\n      :else                               :high-card)))","user":"593f95d8e4b069cdc2982be3"},{"problem":"178","code":"(fn hand [cards]\n  (let [fr (vals (frequencies (map second cards)))\n        s (set (map #(set (drop %(take (+ 5 %) \"A23456789TJQKA\"))) (range 10)))\n        suits (map first cards)\n        ranks (set (map second cards))]\n    (cond\n     (and (s ranks) (apply = suits)) :straight-flush\n     (some #{4} fr) :four-of-a-kind\n     (and (some #{2} fr) (some #{3} fr)) :full-house\n     (apply = suits) :flush\n     (s ranks) :straight\n     (some #{3} fr) :three-of-a-kind\n     (= (count (filter #{2} fr)) 2) :two-pair\n     (some #{2} fr) :pair\n     :else :high-card)))","user":"55625903e4b0c656e3ff17d7"},{"problem":"178","code":"(fn bh [h]\n  (let[\n       hranks (zipmap \"23456789TJQKA\" (range 2 15))\n       lranks (assoc hranks \\A 1)\n       inseq? (fn [r] (let [sr (sort (map #(r (second %)) h))] \n                      (= (range 5) (map #(- % (first sr)) sr))))\n       stright? (or (inseq? hranks) (inseq? lranks))\n       cr (map #(count (second %)) (group-by second h))\n       flush? (= 1 (count (group-by first h)))\n       ]\n    (cond\n     (and stright? flush?)   :straight-flush \n     (= '(4 1) cr)     :four-of-a-kind\n     (= '(3 2) cr)     :full-house\n     flush?            :flush\n     stright?          :straight\n     (= '(3 1 1) cr)   :three-of-a-kind\n     (= '(2 2 1) cr)   :two-pair\n     (= '(2 1 1 1) cr) :pair\n     :else :high-card)))","user":"526a3412e4b03e8d9a4a721e"},{"problem":"178","code":"(fn best-hand [hand]\n  (let [x (map (fn [[s r]]\n                 {:suit ({\\D :diamond \\H :heart \\C :club \\S :spade} s)\n                  :rank ({\\2 0 \\3 1 \\4 2 \\5 3 \\6 4 \\7 5 \\8 6 \\9 7 \\T 8 \\J 9 \\Q 10 \\K 11 \\A 12} r)}) hand)\n        fs (let [g (group-by :suit x)] (zipmap (keys g) (map #(sort (map :rank %)) (vals g))))\n        ranks (sort (map :rank x))\n        fr (frequencies ranks)\n        frs (->> fr vals (into #{}))\n        st (fn [r] (#{[1 1 1 1] [1 1 1 9]} (map - (rest r) r)))]\n    (cond\n      (some st (vals fs)) :straight-flush\n      (frs 4) :four-of-a-kind\n      (= #{3 2} frs) :full-house\n      (= 1 (count fs)) :flush\n      (st ranks) :straight\n      (frs 3) :three-of-a-kind\n      (= 2 ((frequencies (vals fr)) 2)) :two-pair\n      (frs 2) :pair\n      :default :high-card)))","user":"57b3efb1e4b0fbc9809a278a"},{"problem":"178","code":"(fn ([h]\n   (letfn [\n           (mapcards [s] (map #(hash-map :rank ((zipmap \"AKQJT98765432\" (iterate dec 14)) (second %)) :suit (first %) ) s) )\n           (flush? [s] (if (->> s mapcards (map :suit) set count (= 1)) :flush))\n           (straight? [s] (let [cards (mapcards s)\n                            ranks (map :rank cards)\n                            min (apply min ranks)]\n                        (if (or\n                              (every? (set ranks) (range min (+ 5 min )))\n                              (every? (set ranks) (conj (range 2 6) 14 )))\n                          :straight )))\n           (straight-flush? [s] (if (and (straight? s) (flush? s)) :straight-flush))\n           (sets [s]  (let [cards (mapcards s)\n                            ranks (map :rank cards)]\n                        (map count (partition-by identity (sort ranks)))))\n           (pair? [s] (if (every? (set (sets s)) [2]) :pair))\n           (two-pair? [s] (if (= 2 (count (filter #(= 2 %) (sets s)))) :two-pair))\n           (three-of-a-kind? [s] (if (every? (set (sets s)) [3]) :three-of-a-kind))\n           (full-house? [s] (if (every? (set (sets s)) [3 2]) :full-house))\n           (four-of-a-kind? [s] (if (every? (set (sets s)) [4]) :four-of-a-kind))\n           ]\n   (or\n         (straight-flush? h)\n         (four-of-a-kind? h)\n         (full-house? h)\n         (flush? h)\n         (straight? h)\n         (three-of-a-kind? h)\n         (two-pair? h)\n         (pair? h)\n         :high-card))))","user":"54d8cc38e4b0a52adc2e203e"},{"problem":"178","code":"(let [read-card\n        (fn read-card [[suit rank]]\n          (let [suit-dict {\\H :heart, \\D :diamond, \\C :club, \\S :spade},\n                rank-dict (zipmap [\\2 \\3 \\4 \\5 \\6 \\7 \\8 \\9 \\T \\J \\Q \\K \\A]\n                                  (range 13))]\n            {:suit (suit-dict suit), :rank (rank-dict rank)})),\n\n        straight?\n        (fn straight? [ranks] \n          (let [start (apply min ranks)]\n            (or (= ranks (set (range start (+ start 5))))\n                (= (disj ranks 12) (set (range 0 4))))))]\n\n    (fn best-hand [cards]\n      (let [hand  (set (map read-card cards)),\n            suits (set (keys (group-by :suit hand))),\n            ranks (set (map :rank hand)),\n            dist  (sort (vals (frequencies (map :rank hand))))]\n        (cond\n          (and (= 1 (count suits)) (straight? ranks))  :straight-flush\n          (= dist [1 4])                               :four-of-a-kind\n          (= dist [2 3])                               :full-house\n          (= 1 (count suits))                          :flush\n          (straight? ranks)                            :straight\n          (= dist [1 1 3])                             :three-of-a-kind\n          (= dist [1 2 2])                             :two-pair\n          (= dist [1 1 1 2])                           :pair\n          :else                                        :high-card))))","user":"4fc6305de4b0ee37620e180b"},{"problem":"178","code":"(fn best-hand\n  [hand]\n  (let [ace-low-order {\\A 1 \\2 2 \\3 3 \\4 4 \\5 5 \\6 6 \\7 7 \\8 8 \\9 9 \\J 10 \\Q 11 \\K 12}\n        ace-high-order {\\2 2 \\3 3 \\4 4 \\5 5 \\6 6 \\7 7 \\8 8 \\9 9 \\J 10 \\Q 11 \\K 12 \\A 13}\n        same-suit? (first (reduce (fn [[r suit] card]\n                                    [(and r (= suit (first card))) suit])\n                                  [true (get-in hand [0 0])] (rest hand)))\n        same-rank-numbers (->> hand\n                               (group-by second)\n                               (map #(count (second %)))\n                               frequencies)\n        sorted? (some\n                 #(->> hand\n                       (map (comp % second))\n                       sort\n                       (reduce (fn [[r ln] n] (if ln\n                                                [(and r (= (inc ln) n)) n]\n                                                [true n])) [true])\n                       first) [ace-high-order ace-low-order])]\n    (cond\n      (and same-suit? sorted?) :straight-flush\n      (same-rank-numbers 4) :four-of-a-kind\n      (and (same-rank-numbers 3) (same-rank-numbers 2)) :full-house\n      same-suit? :flush\n      sorted? :straight\n      (same-rank-numbers 3) :three-of-a-kind\n      (= 2 (same-rank-numbers 2)) :two-pair\n      (same-rank-numbers 2) :pair\n      :else :high-card)))","user":"5125029de4b0ce9225d2ed3e"},{"problem":"178","code":"(fn best-hand [cards]\n  (let [parse-card (fn [[s r]]\n                     (let [suit (get {\\S :spade \\H :heart \\D :diamond \\C :club} s)\n                           rank (if (Character/isDigit r)\n                                  (- (int r) (int \\2))\n                                  (get {\\T 8 \\J 9 \\Q 10 \\K 11 \\A 12} r))]\n                       {:suit suit :rank rank}))\n        consecutive? (fn [[x & xs]]\n                       (loop [prev x, todo xs]\n                         (cond (empty? todo) true\n                               (not= (first todo) (inc prev)) false\n                               :else (recur (first todo) (next todo)))))\n        in-sequence? (fn [ranks]\n                       (let [ace-as-low (replace {12 -1} ranks)]\n                         (some (comp consecutive? sort) [ranks ace-as-low])))\n        parsed (map parse-card cards)\n        suits (map :suit parsed)\n        ranks (map :rank parsed)]\n    (cond\n      (and (= (count (distinct suits)) 1) (in-sequence? ranks)) :straight-flush\n      (some #{4} (vals (frequencies ranks))) :four-of-a-kind\n      (= #{2 3} (set (vals (frequencies ranks)))) :full-house\n      (= (count (distinct suits)) 1) :flush\n      (in-sequence? ranks) :straight\n      (some #{3} (vals (frequencies ranks))) :three-of-a-kind\n      (= [1 2 2] (sort (vals (frequencies ranks)))) :two-pair\n      (some #{2} (vals (frequencies ranks))) :pair\n      :else :high-card)))","user":"5b51b9f8e4b02d533a91bcfe"},{"problem":"178","code":"(fn best-hand [cards]\n  (let [->card (fn [[s r]] {:suit ({\\D :diamond \\H :heart \\C :club \\S :spade} s)\n                           :rank ((zipmap \"23456789TJQKA\" (range)) r)})\n        cards (map ->card cards)\n        sequence? (fn [cards]\n                    (let [with-low-ace (map (fn [c] (if (= (:rank c) 12) (assoc c :rank -1) c)) cards)\n                          seq? (fn [cs] (->> cs\n                                            (map :rank)\n                                            sort\n                                            ((fn [cs] (and\n                                                      (= (count cs) (inc (- (last cs) (first cs))))\n                                                      (apply < cs))))))]\n                      (or (seq? cards)\n                          (seq? with-low-ace))))\n        flush? (fn [cs] (apply = (map :suit cs)))\n        ranks  (fn [cs] (sort (map count (vals (group-by :rank cs)))))]\n\n    (cond\n      (= '(2 3) (ranks cards))\n      :full-house\n\n      (= '(1 2 2) (ranks cards))\n      :two-pair\n\n      (= 4 (apply max (ranks cards)))\n      :four-of-a-kind\n\n      (= 3 (apply max (ranks cards)))\n      :three-of-a-kind\n\n      (= 2 (apply max (ranks cards)))\n      :pair\n\n      (and (flush? cards) (sequence? cards))\n      :straight-flush\n\n      (sequence? cards)\n      :straight\n\n      (flush? cards)\n      :flush\n\n      :else\n      :high-card)))","user":"5a257747e4b07f18be40aa1f"},{"problem":"178","code":"(fn best-hand [cards]\n  (let [suites       #{\\H \\D \\C \\S}\n        ranks        {\\2 2\n                      \\3 3\n                      \\4 4\n                      \\5 5\n                      \\6 6\n                      \\7 7\n                      \\8 8\n                      \\9 9\n                      \\T 10\n                      \\J 11\n                      \\Q 12\n                      \\K 13\n                      \\A 14}\n        s            (set (map first cards))\n        r            (vec (map second cards))\n        fr           (frequencies r)\n        _            (prn r fr s)\n        seqx         (fn [x op]\n                       (first (reduce (fn [[ans p] v]\n                                        [(and ans\n                                              (= op (- (get ranks v) (get ranks p))))\n                                         v])\n                                      [true (first x)]\n                                      (rest x))))\n        in-sequence? (if (= \\A (first r))\n                       (cond\n                         (seqx (rest r) -1) \\1\n                         (seqx (rest r) +1) \\2\n                         :else \\3)\n                       (if (= \\A (last r))\n                         (cond\n                           (seqx (pop r) +1) \\1\n                           (seqx (pop r) -1) \\2\n                           :else \\3)\n                         (cond\n                           (or (seqx r >) (seqx r <)) \\1\n                           :else \\3)))]\n    (cond\n      (and (= \\1 in-sequence?) (= 1 (count s))) :straight-flush\n      (and (= 2 (count fr)) (contains? (set (vals fr)) 4)) :four-of-a-kind\n      (and (= 2 (count fr)) (contains? (set (vals fr)) 3)) :full-house\n      (= 1 (count s)) :flush\n      (or (= \\1 in-sequence?) (= \\2 in-sequence?)) :straight\n      (and (= 3 (count fr)) (contains? (set (vals fr)) 3)) :three-of-a-kind\n      (and (= 3 (count fr)) (contains? (set (vals fr)) 2)) :two-pair\n      (and (= 4 (count fr))) :pair\n      :else :high-card)))","user":"5dc53ddee4b02f9375f4e1bd"},{"problem":"178","code":"(fn hand [cards]\n  (let [fls (= 1 (count (distinct (map first cards))))\n        numap {\\2 2,\\3 3,\\4 4,\\5 5,\\6 6,\\7 7,\\8 8,\\9 9,\\T 10,\\J 11,\\Q 12,\\K 13,\\A 14}\n        nums (sort (map #(get numap %) (map second cards)))\n        str8 (or (= '(2 3 4 5 14) nums)\n                 (and (= nums (distinct nums))\n                      (= 4 (- (last nums) (first nums)))))\n        grps (sort (map count (vals (group-by identity nums))))\n        pairs (= (get (group-by identity grps) 2 nil) [2 2])]\n    (cond\n      fls (if str8 :straight-flush :flush)\n      str8 :straight\n      (= grps [1 1 1 1 1]) :high-card\n      (= grps [1 1 1 2]) :pair\n      (= grps [1 2 2]) :two-pair\n      (= grps [2 3]) :full-house\n      (= grps [1 1 3]) :three-of-a-kind\n      (= grps [1 4]) :four-of-a-kind)))","user":"55345b21e4b09218d5f44f9b"},{"problem":"178","code":"(fn best-hand [hand]\n  (let [deck [\\L \\2 \\3 \\4 \\5 \\6 \\7 \\8 \\9 \\T \\J \\Q \\K \\H]\n        inverted-deck (clojure.set/map-invert (map-indexed (fn [i v] [i v]) deck))\n        run (fn [hand]\n                (let [indices (sort (map (comp inverted-deck second) hand))]\n                  (= indices (range (first indices) (inc (last indices))))))\n\n        straight (fn [hand]\n                (or (run (map (partial replace {\\A \\L}) hand)) (run (map (partial replace {\\A \\H}) hand))))\n\n        two-pair (fn [hand]\n                (< 3 (count (flatten (filter #(< 1 (count (second %))) (group-by second hand))))))\n\n        n-of-a-kind (fn [n hand]\n                (some #(= n (count (second %))) (group-by second hand)))\n\n        flsh (fn [hand]\n                (= 1 (count (set (map first hand)))))]\n  (cond\n    (and (flsh hand) (straight hand)) :straight-flush\n    (n-of-a-kind 4 hand) :four-of-a-kind\n    (and (n-of-a-kind 3 hand) (n-of-a-kind 2 hand)) :full-house\n    (flsh hand) :flush\n    (straight hand) :straight\n    (n-of-a-kind 3 hand) :three-of-a-kind\n    (two-pair hand) :two-pair\n    (n-of-a-kind 2 hand) :pair\n    :otherwise :high-card )))","user":"52593207e4b0cb4875a45cd3"},{"code":"(fn [hand]\n  (let [suits (->> hand \n                   (map (comp str first))\n                   (sort)\n                   )\n        grouped-suits (partition-by identity suits)\n        get-val (fn [x] (.indexOf \"23456789TJQKA\" (str x)))\n        ranks (->> hand\n                   (map (comp str second seq))\n                   (map get-val)\n                   (sort)\n                   )\n        grouped-ranks (partition-by identity ranks)\n        is-flush (= 1 (count grouped-suits))\n        get-num-grouped (fn [n] (count (filter #(= n (count %)) grouped-ranks)))\n        num-singles (get-num-grouped 1)\n        num-pairs (get-num-grouped 2)\n        num-triplets (get-num-grouped 3)\n        num-four-of-a-kind (get-num-grouped 4)\n        max-minus-min (- (last ranks) (first ranks))\n        is-straight-A5 (and\n                        (= (last ranks) (get-val \"A\"))\n                        (= (apply max (drop-last ranks)) (get-val 5))\n                        (= 5 (count grouped-ranks))\n                        )\n        is-straight (and (= 5 (count grouped-ranks))\n                         (or (= 4 max-minus-min)\n                             is-straight-A5\n                             )\n                         )\n        ]\n    (cond\n     (and is-straight is-flush) :straight-flush\n     (= num-four-of-a-kind 1) :four-of-a-kind\n     (and (= num-pairs 1) (= num-triplets 1)) :full-house\n     (= (count grouped-suits) 1) :flush\n     (and is-straight true) :straight\n     (and (= num-triplets 1) (= num-singles 2)) :three-of-a-kind\n     (and (= num-pairs 2)) :two-pair\n     (and (= num-pairs 1) (= num-singles 3)) :pair\n     :else :high-card\n     )\n    )\n  )","problem":"178","user":"523f0bbfe4b01c266ffa7f91"},{"problem":"178","code":"(fn [encoded-hand]\n  (let [decode #(let [\n       \t\tsuit ({\\S :spade \\H :heart \\D :diamond \\C :club} (first %))\n       \t\trank (or ({\\T 8 \\J 9 \\Q 10 \\K 11 \\A 12 } (second %)) (- (read-string (str (second %))) 2))\n      \t\t]\n   \t\t{:suit suit :rank rank})\n        hand (map decode encoded-hand)\n        suits (set (map #(% :suit) hand))\n        ranks (sort (map #(% :rank) hand))\n        flush? (= (count suits) 1)\n        straight? (or (= ranks (range (first ranks) (inc (last ranks)))) (= ranks [0 1 2 3 12]))\n        groups (reverse (sort (map count (partition-by identity ranks))))]\n        (println suits)\n        (println ranks)\n        (println groups)\n    (cond\n     (and straight? flush?) :straight-flush\n     (= 4 (first groups)) :four-of-a-kind\n     (and (= 3 (first groups)) (= 2 (second groups))) :full-house\n     flush? :flush\n     straight? :straight\n     (= 3 (first groups)) :three-of-a-kind\n     (and (= 2 (first groups)) (= 2 (second groups))) :two-pair\n     (= 2 (first groups)) :pair\n     :else :high-card)))","user":"55a74d46e4b09e57187da2a3"},{"problem":"178","code":"(fn best-hand-4clojure [strings-hand]\n  (let [hand (map (fn read-card [s]\n                    {:suit (let [suit (str (first s))]\n                             (case suit\n                               \"D\" :diamond\n                               \"H\" :heart\n                               \"S\" :spade\n                               \"C\" :club))\n\n                     :rank (let [rank (str (last s))]\n                             (case rank\n                               \"T\" 8\n                               \"J\" 9\n                               \"Q\" 10\n                               \"K\" 11\n                               \"A\" 12\n                               (- (read-string rank) 2)))})\n                  strings-hand)\n        ranks (sort (frequencies (map :rank hand)))\n        ranks-by-occurence (sort-by last ranks)\n        ranks-bottom-ace (sort (map #(if (= 12 (first %)) [-1 (last %)] %) ranks))\n        biggest-rank-occurence (-> ranks last last)\n        suits (set (map :suit hand))\n        is-sequence #(= (-> % last first) (+ 4 (-> % first first)))\n        is-straight (and (= (count ranks) 5) (or (is-sequence ranks) (is-sequence ranks-bottom-ace)))\n        is-flush (= (count suits) 1)]\n\n    (cond\n      (and is-straight is-flush) :straight-flush\n      (= biggest-rank-occurence 4) :four-of-a-kind\n      (and (= 2 (count ranks)) (= biggest-rank-occurence 3)) :full-house\n      is-flush :flush\n      is-straight :straight\n      (= 3 biggest-rank-occurence) :three-of-a-kind\n      (and (= 2 biggest-rank-occurence) (= 3 (count ranks))) :two-pair\n      (= 2 biggest-rank-occurence) :pair\n      :else :high-card)))","user":"5645a7d6e4b0284900eef608"},{"problem":"178","code":"(fn [l]\n    (letfn [(card [s]\n                (let [suit {\\S :spade \\H :heart \\D :diamond \\C :club}\n                      rank {\\2 0 \\3 1 \\4 2 \\5 3 \\6 4 \\7 5 \\8 6 \\9 7\n                            \\T 8 \\J 9 \\Q 10 \\K 11 \\A 12}]\n                    {:suit (suit (first s)) :rank (rank (last s))}))\n            \n            (in-sequence? [l]\n                (= (sort l) (let [m (apply min l)\n                                  n (count l)]\n                                (range m (+ m n)))))\n            \n            (n-with-same-rank? [n hand]\n                (some (fn [[k v]] (= (count v) n)) (group-by :rank hand)))\n            \n            (n-with-same-suit? [n hand]\n                (some (fn [[k v]] (= (count v) n)) (group-by :suit hand)))\n            \n            ; Straight flush: All cards in the same suit, and in sequence\n            (straight-flush? [hand]\n                (and (n-with-same-suit? 5 hand)\n                     (in-sequence? (map :rank hand))))\n            \n            ; Four of a kind: Four of the cards have the same rank\n            (four-of-a-kind? [hand]\n                (n-with-same-rank? 4 hand))\n            \n            ; Full House: Three cards of one rank, the other two of another rank\n            (full-house? [hand]\n                (and (n-with-same-rank? 3 hand)\n                     (n-with-same-rank? 2 hand)))\n            \n            ; Flush: All cards in the same suit\n            (flush? [hand]\n                (n-with-same-suit? 5 hand))\n            \n            ; Straight: All cards in sequence (aces can be high or low, but not both at once)\n            (straight? [hand]\n                (let [ranks (map :rank hand)]\n                    (or (in-sequence? ranks)\n                        (and (some #{12} ranks) (in-sequence? (remove #{12} (conj ranks -1)))))))\n            \n            ; Three of a kind: Three of the cards have the same rank\n            (three-of-a-kind? [hand]\n                (n-with-same-rank? 3 hand))\n\n            ; Two pair: Two pairs of cards have the same rank\n            (two-pair? [hand]\n                (= 2 (count (filter (fn [[k v]] (= 2 (count v))) (group-by :rank hand)))))\n\n            ; Pair: Two cards have the same rank\n            (pair? [hand]\n                (n-with-same-rank? 2 hand))]\n        (let [hand (map card l)]\n            (cond (straight-flush? hand) :straight-flush\n                  (four-of-a-kind? hand) :four-of-a-kind\n                  (full-house? hand) :full-house\n                  (flush? hand) :flush\n                  (straight? hand) :straight\n                  (three-of-a-kind? hand) :three-of-a-kind\n                  (two-pair? hand) :two-pair\n                  (pair? hand) :pair\n                  :else :high-card))))","user":"600ae927e4b074f607df6689"},{"code":"(fn best-hand[cards]\n  (letfn[(recongnize-cards [[suit num]]\n                           {:suit ({\\D :diamond \\H :heart \\C :club \\S :spade} suit) \n                            :rank ({ \\2 0 \\3 1 \\4 2 \\5 3 \\6 4 \\7 5 \\8 6 \\9 7 \\T 8 \\J 9 \\Q 10 \\K 11 \\A 12} num)})]\n   (let [cs (map recongnize-cards cards)\n         ranks (sort (map :rank cs))\n         suits (map :suit cs)\n         _ (prn ranks)]\n     (cond\n       (and (= 1 (count (set suits))) \n            (or (= (last ranks)\n                   (+ 2 (/ (reduce + ranks) 5)))\n                (and (= 12 (last ranks))\n                     (= (nth ranks 3) 3)\n                     (= (nth ranks 2) 2)\n                     (= (nth ranks 1) 1)\n                     (= (nth ranks 0) 0)))) :straight-flush\n       (or (= (first ranks) (nth ranks 3))\n           (= (second ranks) (last ranks))) :four-of-a-kind \n       (or (and (= (first ranks) (second ranks))\n                (= (nth ranks 2) (nth  ranks 4)))\n           (and (= (first ranks) (nth ranks 2))\n                (= (nth ranks 3) (nth  ranks 4)))) :full-house\n       (= 1 (count (set suits))) :flush \n       (or (= (last ranks)\n              (+ 2 (/ (reduce + ranks) 5)))\n           (and (= 12 (last ranks))\n                (= (nth ranks 3) 3)\n                (= (nth ranks 2) 2)\n                (= (nth ranks 1) 1)\n                (= (nth ranks 0) 0))) :straight\n       (or (= (first ranks) (nth ranks 2))\n           (= (last ranks) (nth ranks 2))) :three-of-a-kind\n       (= 3 (count (set ranks))) :two-pair\n       (= 4 (count (set ranks))) :pair \n       :else :high-card))))","problem":"178","user":"5273562ae4b03e8d9a4a7479"},{"problem":"178","code":"(fn best-hand [cards]\n  (let [read-card (fn [card]\n                      { :suit (first card)\n                        :rank (condp #(if (%1 %2) %2 nil) (second card)\n                                (apply hash-set (map char (range (int \\2) (inc (int \\9))))) :>> #(- (int %) (int \\0))\n                                #{\\T} 10\n                                #{\\J} 11\n                                #{\\Q} 12\n                                #{\\K} 13\n                                #{\\A} 14) })\n        cards (sort-by :rank (map read-card cards))\n        straight (fn [sorted-cards]\n                   (let [[c0 c1 c2 c3 c4] (map :rank sorted-cards)]\n                     (or (and (= c1 (inc c0))\n                              (= c2 (inc c1))\n                              (= c3 (inc c2))\n                              (= c4 (inc c3)))\n                         (and (= c0 2)\n                              (= c1 3)\n                              (= c2 4)\n                              (= c3 5)\n                              (= c4 14)))))\n        cranks (map :rank cards)\n        range-rank (fn [from to] (take (- to from) (drop from cranks)))]\n    (cond\n     (and (straight cards) (apply = (map :suit cards))) :straight-flush\n     (or (apply = (range-rank 0 4))\n         (apply = (range-rank 1 5))) :four-of-a-kind\n     (or (and (apply = (range-rank 0 3))\n              (apply = (range-rank 3 5)))\n         (and (apply = (range-rank 0 2))\n              (apply = (range-rank 2 5)))) :full-house\n     (apply = (map :suit cards)) :flush\n     (straight cards) :straight\n     (or (apply = (range-rank 0 3))\n         (apply = (range-rank 1 4))\n         (apply = (range-rank 2 5))) :three-of-a-kind\n     (or (and (apply = (range-rank 0 2))\n              (apply = (range-rank 2 4)))\n         (and (apply = (range-rank 0 2))\n              (apply = (range-rank 3 5)))\n         (and (apply = (range-rank 1 3))\n              (apply = (range-rank 3 5)))) :two-pair\n     (or (apply = (range-rank 0 2))\n         (apply = (range-rank 1 3))\n         (apply = (range-rank 2 4))\n         (apply = (range-rank 3 5))) :pair\n     :else :high-card)))","user":"5479c58de4b0c51c1f4d72c7"},{"problem":"178","code":"(fn\n  [cards]\n  (let [parse-card (fn [c] {:suit ({\\D :diamond, \\H :heart, \\S :spade, \\C :club} (first c))\n                      :rank ({\\2 0, \\3 1, \\4 2, \\5 3, \\6 4, \\7 5, \\8 6, \\9 7, \\T 8, \\J 9, \\Q 10, \\K 11, \\A 12} (second c))})\n        stat-cards #(reduce (fn [acc {:keys [suit rank]}]\n                              (-> acc\n                                  (assoc-in [:rank rank] (inc (get-in acc [:rank rank] 0)))\n                                  (assoc-in [:suit suit] (inc (get-in acc [:suit suit] 0)))))\n                            {} %)\n        stats (->> cards (map parse-card) stat-cards)\n        ranks (->> stats :rank)\n        suits (->> stats :suit vals)\n        flush? (= 5 (apply max suits))\n        straight? (let [r (sort (keys ranks))]\n                    (or (= r (range (first r) (inc (last r))))\n                        (and ((set r) 12) (= (take 4 r) (range 4)))))]\n    (if flush?\n      (if straight? :straight-flush :flush)\n      (if straight? :straight\n          (let [rs (-> ranks vals sort reverse)]\n            (case (first rs)\n              4 :four-of-a-kind\n              3 (if (= 2 (count ranks)) :full-house :three-of-a-kind)\n              2 (if (= 2 (second rs)) :two-pair :pair)\n              1 :high-card))))))","user":"4e521cef535d302ef430da6d"},{"problem":"178","code":"(fn\n  [c]\n  (let [st {\\H :h \\D :d \\C :c \\S :s}\n        r1 (apply merge (map #(hash-map %1 %2)\n                          \"23456789TJQKA\"\n                          (range 2 15)))\n\n        r2 (apply merge (map #(hash-map %1 %2)\n                          \"A23456789TJQK\"\n                          (range 1 14)))\n        h1 (fn [s]\n               (hash-map :s (get st (first s))\n                         :r1 (get r1 (second s))\n                         :r2 (get r2 (second s))))\n        h2 (fn [c]\n                (map h1 c))\n        s? (fn [c]\n                    (let [c1 (map :r1 (sort-by :r1 (h2 c)))\n                          c2 (map :r2 (sort-by :r2 (h2 c)))]\n                      (or (= c1 (range (first c1) (+ 5 (first c1))))\n                          (= c2 (range (first c2) (+ 5 (first c2)))))))\n        f? (fn [c]\n                 (apply = (map :s (h2 c))))\n\n        sf? (fn [c]\n                  (and (s? c)\n                       (f? c)))\n\n        fp (fn [c]\n                (let [ch (frequencies (map :r1 (h2 c)))\n                      cc (count ch)]\n                  (if (= 5 cc)\n                      :high-card\n                      (if (= 4 cc)\n                          :pair\n                          (if (= 3 cc)\n                              (if (some #(= 3 (val %)) ch)\n                                  :three-of-a-kind\n                                  :two-pair)\n                              (if (= 2 cc)\n                                  (if (some #(= 4 (val %)) ch)\n                                      :four-of-a-kind\n                                      :full-house)))))))]\n    (if (sf? c)\n        :straight-flush\n        (if (f? c)\n            :flush\n            (if (s? c)\n                :straight\n                (fp c))))))","user":"528a3e14e4b0239c8a67ae72"},{"problem":"178","code":"(fn [hand]\n  (let\n    [\n     suits (map first hand)\n     ranks (sort (map #(->> % second str (.indexOf \"23456789TJQKA\")) hand))\n     sequenced? (= ranks (range (first ranks) (inc (last ranks))))\n     freq-ranks (-> ranks frequencies vals set)\n     ]\n    (cond\n     (and sequenced? (apply = suits)) :straight-flush\n     (= #{4 1} freq-ranks) :four-of-a-kind\n     (= #{3 2} freq-ranks) :full-house\n     (apply = suits) :flush\n     (or sequenced? (= [0 1 2 3 12] ranks)) :straight \n     (freq-ranks 3) :three-of-a-kind\n     (= 3 (-> ranks set count)) :two-pair\n     (freq-ranks 2) :pair\n     :else :high-card\n) ) )","user":"5281a445e4b0757a1b17143a"},{"problem":"178","code":"(fn poker [xs]\n  (let [ranks [\\2 \\3 \\4 \\5 \\6 \\7 \\8 \\9 \\T \\J \\Q \\K \\A]\n        suits [\\S \\D \\H \\C]\n        deck (zipmap (for [s suits r ranks]\n                       (str s r)) (concat (range 0 13)\n                                          (range 100 113)\n                                          (range 200 213)\n                                          (range 300 313)\n                                          ))\n        straight-flush? (fn [xs]\n                          (let [xs (sort (map deck xs))\n                                straight-flush (take 5 (iterate inc (first xs)))]\n                            (= xs straight-flush)))\n        four-of-a-kind? (fn [xs]\n                          (some #(= % 4) (vals (frequencies (map (comp #(mod % 100) deck) xs)))))\n        full-house? (fn [xs]\n                      (= #{3 2} (set (vals (frequencies (map (comp #(mod % 100) deck) xs))))))\n        flush? (fn [xs]\n                 (let [xs (map deck xs)\n                       mn (apply min xs)\n                       mx (apply max xs)]\n                   (<= (- mx mn) 13)))\n        straight? (fn [xs]\n                    (let [xs (sort (map #(mod % 100) (map deck xs)))\n                          xs-min-ace (sort (replace {12 -1} xs))\n                          straight (take 5 (iterate inc (first xs)))\n                          straight-ace (take 5 (iterate inc (first xs-min-ace)))]\n                      #_[xs xs-min-ace straight straight-ace]\n                      (or (= xs straight) (= xs-min-ace straight-ace))))\n        three-of-a-kind? (fn [xs]\n                           (some #(= % 3) (vals (frequencies (map (comp #(mod % 100) deck) xs)))))\n        two-pairs? (fn [xs]\n                     (= [1 2 2]  (sort (vals (frequencies (map (comp #(mod % 100) deck) xs))))))\n        pair? (fn [xs]\n                (= [1 1 1 2]  (sort (vals (frequencies (map (comp #(mod % 100) deck) xs))))))]\n    (cond\n      (straight-flush? xs) :straight-flush\n      (four-of-a-kind? xs) :four-of-a-kind\n      (full-house? xs) :full-house\n      (flush? xs) :flush\n      (straight? xs) :straight\n      (three-of-a-kind? xs) :three-of-a-kind\n      (two-pairs? xs) :two-pair\n      (pair? xs) :pair\n      :else :high-card)))","user":"52d00832e4b07d0d72b273b4"},{"problem":"178","code":"(fn [hand]\n  (let [freq (-> (map second hand)\n                  frequencies\n                  vals\n                  sort)]\n    (letfn [(card-val [card] (#(or (get {\\T 10 \\J 11 \\Q 12 \\K 13 \\A 14} %1)\n                                   (- (int %1) 48))\n                              (second card)))\n            (flush?    [hand] (and (= 1 (count (set (map first hand)))) :flush))\n            (kind4?    [hand] (and (= freq [1 4])     :four-of-a-kind))\n            (kind3?    [hand] (and (= freq [1 1 3])   :three-of-a-kind))\n            (fullh?    [hand] (and (= freq [2 3])     :full-house))\n            (twopair?  [hand] (and (= freq [1 2 2])   :two-pair))\n            (pair?     [hand] (and (= freq [1 1 1 2]) :pair))\n            (straight? [hand] (and (->> hand\n                                        (map card-val)\n                                        (sort)\n                                        (partition 2 1)\n                                        (map (partial apply -))\n                                        (#{[-1 -1 -1 -1] [-1 -1 -1 -9]}))\n                                   :straight))\n            (str-flush? [hand] (and (flush? hand) (straight? hand) :straight-flush))]\n      (some #(% hand) [str-flush? kind4? fullh? straight? flush?\n                       kind3? twopair?  pair? (constantly :high-card)]))))","user":"56102f50e4b05f002753df6b"},{"problem":"178","code":"(fn best-hand\n  [cards-xs]\n  (letfn [(card [card-string]\n            (let [[s r] (seq card-string)]\n              {:suit (condp = s\n                       \\D :diamond\n                       \\H :heart\n                       \\C :club\n                       \\S :spade)\n               :rank (condp = r\n                       \\A 12\n                       \\K 11\n                       \\Q 10\n                       \\J 9\n                       \\T 8\n                       (- (Character/getNumericValue ^char r) 2))}\n              ))]\n    (let [cards     (map card cards-xs)\n          sorted    (sort (map :rank cards))\n          flush?    (= 1 (count (into #{} (map :suit cards))))\n          straight? (or\n                      (= sorted '(0 1 2 3 12)) ;; Ace low case\n                      (= sorted (range (first sorted) (+ 5 (first sorted)))))\n          grouped   (map count (partition-by identity sorted))\n          kind      (apply max grouped)]\n      (cond\n        (and straight? flush?)         :straight-flush\n        (= 4 kind)                     :four-of-a-kind\n        (= 2 (count grouped))          :full-house\n        flush?                         :flush\n        straight?                      :straight\n        (= 3 kind)                     :three-of-a-kind\n        (= 2 (count\n               (filter #{2} grouped))) :two-pair\n        (= 2 kind)                     :pair\n        :else                          :high-card\n        ))))","user":"536ecd9fe4b0fc7073fd6e76"},{"problem":"178","code":"(fn [h]\n  (let [flush (apply = (map first h))  \n        nos (map (comp {\\2 2 \\3 3 \\4 4 \\5 5 \\6 6 \\7 7 \\8 8 \\9 9 \\T 10 \\J 11 \\Q 12 \\K 13 \\A 14} second) h)\n        aceAdjNos (if (some #{2} nos) (replace {14 1} nos) nos)\n        sortNos (sort aceAdjNos)\n        straight (and (= (count (distinct sortNos)) 5) (= (+ (first sortNos) 4) (last sortNos)))\n        [c1 c2] (sort > (map (comp count val) (group-by identity sortNos)))]\n          (cond\n            (and straight flush) :straight-flush\n            (= c1 4) :four-of-a-kind\n            (= [c1 c2] [3 2]) :full-house\n            flush :flush\n            straight :straight\n            (= c1 3) :three-of-a-kind\n            (= c1 c2 2) :two-pair\n            (= c1 2) :pair\n            :else :high-card )))","user":"5b919d9de4b0c0b3ffbd4a24"},{"problem":"178","code":"(fn [h]\n  (let [rank (comp (zipmap (concat (map #(first (str %)) (range 2 10)) [\\T \\J \\Q \\K \\A]) \n                           (range 13)) \n                   second)\n        suits (map first h)\n        ranks (map rank h)\n        low-ranks (map #(get {12 -1} % %) ranks)\n        flush? (apply = suits)\n        straight? (or (= (set ranks) (set (range (apply min ranks) (inc (apply max ranks)))))\n                      (= (set low-ranks) (set (range (apply min low-ranks) (inc (apply max low-ranks))))))\n        grps (->> ranks sort (partition-by identity) (map count))\n        cts (set grps)]\n    (cond\n     (and flush? straight?) :straight-flush\n     (cts 4) :four-of-a-kind\n     (and (cts 3) (cts 2)) :full-house\n     flush? :flush\n     straight? :straight\n     (cts 3) :three-of-a-kind\n     (or (= [2 1 2] grps) (= [1 2 2] grps) (= [2 2 1] grps)) :two-pair\n     (cts 2) :pair\n     :default :high-card)))","user":"4e0e0529535d04ed9115e7b9"},{"problem":"178","code":"(fn poker [h]\r\n  (let [rank  #((apply hash-map (interleave \"23456789TJQKA\" (range 13))) (second %))\r\n        ranks (map rank h)\r\n        suits (map first h)\r\n        same-ranks (sort (map count (vals (group-by identity ranks))))\r\n        straight (every?\r\n                    (fn [[a b]] (or (= 1 (- b a)) (= [3 12] [a b]))) \r\n                    (partition 2 1 (sort ranks )))\r\n        flush    (= 1 (count (distinct suits)))\r\n        hands (partition 2 [\r\n          :straight-flush  (and straight flush)\r\n          :four-of-a-kind  (= same-ranks [1 4])\r\n          :full-house      (= same-ranks [2 3])     \r\n          :flush           flush\r\n          :straight        straight\r\n          :three-of-a-kind (= same-ranks [1 1 3])\r\n          :two-pair        (= same-ranks [1 2 2])\r\n          :pair            (= same-ranks [1 1 1 2])\r\n          :high-card       true ])]\r\n          \r\n    (some\r\n      (fn [[n f]] (when f n))\r\n      hands)\r\n    ))","user":"5470699ae4b00cfc9eacc1b6"},{"problem":"178","code":"(fn [a]\n  (let [aa (map #(let [s (first %) r (second %)]\n                      {:suit ({\\D :diamond \\H :heart \\C :club \\S :spade} s)\n                        :rank ({\\2 1 \\3 2 \\4 3 \\5 4 \\6 5 \\7 6 \\8 7 \\9 8 \\T 9 \\J 10 \\Q 11 \\K 12 \\A 13} r)}\n                     ) a)\n        aaend (sort #(compare (:rank %1) (:rank %2)) aa)\n        aastart (sort #(compare (:rank %1) (:rank %2)) (map (fn [e] {:rank (mod (:rank e) 13) :suit (:suit e)}) aa))\n        aarank (group-by #(:rank %) aa)\n        aasuit (group-by #(:suit %) aa)\n       ]\n       (letfn[(straight [c] (if (every? #(= (inc (:rank (nth c %))) (:rank (nth c (inc %)))) (range (dec (count c)))) :straight nil))\n              (straight-all [] (if (or (keyword? (straight aaend)) (keyword? (straight aastart))) :straight nil))\n              (flush [] (if (= 1 (count aasuit)) :flush  nil))\n              (straight-flush [] (if (and (keyword? (flush)) (straight-all)) :straight-flush nil ))\n              (four-of-a-kind [] (if (true? (some #(= 4 (count %)) (vals aarank)) ) :four-of-a-kind nil))\n              (full-house [] (if (and (some #(= 2 (count %)) (vals aarank)) (some #(= 3 (count %)) (vals aarank))) :full-house  nil) )\n              (three-of-a-kind [] (if (true? (some #(= 3 (count %)) (vals aarank)) ) :three-of-a-kind  nil))\n              (two-pair [] (if (= 2 (count (filter #(= 2 (count %)) (vals aarank)))) :two-pair  nil))\n              (pair [] (if (true? (some #(= 2 (count %)) (vals aarank)) ) :pair  nil))]\n        (loop [h [straight-flush four-of-a-kind full-house flush straight-all three-of-a-kind two-pair pair] res ((first h))]\n          (cond\n            (empty? h) :high-card\n            (keyword? res) res\n            :else (recur (rest h) (if (empty? (rest h)) nil ((second h))))\n          )\n        )\n       )\n  )\n)","user":"55eeb37ae4b0121d4835fdf3"},{"problem":"178","code":"(fn [cards]\n  (let [[suits ranks] (apply map vector cards)\n        ranks-freq (frequencies (vals (frequencies ranks)))\n        flush? (apply = suits)\n        ranks-map (fn [map-A]\n                    (into (zipmap\n                            \"23456789TJQK\"\n                            (range 2 14)) map-A ))\n        straight? (some\n                    #(every? (fn [[p n]] (= 1 (- n p)))\n                             (->> ranks\n                                  (map (ranks-map %))\n                                  sort\n                                  (partition 2 1)))\n                    [{\\A 14} {\\A 1}])]\n\n    (cond\n      (and flush? straight?) :straight-flush\n      (ranks-freq 4) :four-of-a-kind\n      (and (ranks-freq 3) (ranks-freq 2)) :full-house\n      flush? :flush\n      straight? :straight\n      (ranks-freq 3) :three-of-a-kind\n      (= 2 (ranks-freq 2)) :two-pair\n      (= 1 (ranks-freq 2)) :pair\n      :else :high-card)))","user":"50f10f7be4b06d9538fe211a"},{"problem":"178","code":"(let [card (fn [c] {:suit ({\\S :spade \\H :heart \\D :diamond \\C :club} (first c)) :rank ({\\2 0 \\3 1 \\4 2 \\5 3 \\6 4 \\7 5 \\8 6 \\9 7 \\T 8 \\J 9 \\Q 10 \\K 11 \\A 12} (last c))})] (fn [v] (let [vc (into [] (map card v)) ranks (into [] (map :rank vc)) flush? (= 1 (count (distinct (map :suit vc)))) straight-fn (fn [rv] (let [mr (apply min rv)] (= (set (range mr (+ 5 mr))) (set rv)))) straight? (straight-fn ranks) low-straight? (straight-fn (map #(if (= % 12) -1 %) ranks)) disp? (fn [d] (= d (frequencies (vals (frequencies ranks)))))] (cond (and flush? straight?) :straight-flush (disp? {4 1 1 1}) :four-of-a-kind (disp? {3 1 2 1}) :full-house flush? :flush (or straight? low-straight?) :straight (disp? {3 1 1 2}) :three-of-a-kind (disp? {2 2 1 1}) :two-pair (disp? {2 1 1 3}) :pair :else :high-card))))","user":"5abe2fc2e4b073f17744271e"},{"code":"(fn best-hand [cards]\n  (let [card (fn [[suit rank]]\n               {:suit (condp = suit\n                       \\C :club\n                       \\D :diamond\n                       \\H :heart\n                       \\S :spade)\n                :rank (condp = rank\n                       \\2 0\n                       \\3 1\n                       \\4 2\n                       \\5 3\n                       \\6 4\n                       \\7 5\n                       \\8 6\n                       \\9 7\n                       \\T 8\n                       \\J 9\n                       \\Q 10\n                       \\K 11\n                       \\A 12)})\n       cards (map card cards)\n       count-by #(->> (map % cards)\n                      (group-by identity)\n                      vals\n                      (map count))\n       ranks (count-by :rank)\n       suits (count-by :suit)\n       rank-count (count ranks)\n       suit-count (count suits)\n       rank-repeats? #(some #{%} ranks)\n       flush? (= suit-count 1)\n       straights (map sort (partition 5 1 (conj (range 13) 12)))\n       straight? (-> (map :rank cards)\n                     sort\n                     vector\n                     set\n                     (some straights))]\n    (cond\n      (and flush? straight?) :straight-flush\n      (rank-repeats? 4) :four-of-a-kind\n      (= rank-count 2) :full-house\n      flush? :flush\n      straight? :straight\n      (rank-repeats? 3) :three-of-a-kind\n      (= rank-count 3) :two-pair\n      (rank-repeats? 2) :pair\n      :else :high-card)))","problem":"178","user":"514c2d05e4b02b8cbb2a9278"},{"problem":"178","code":"(fn [hs]\n  (let [hands (map (fn [[s r]] {:suit     ({\\D :diamond \\H :heart \\C :club \\S :spade} s)\n                                :rank     ((zipmap \"23456789TJQKA\" (range 13)) r)\n                                :rank-alt ((zipmap \"A23456789TJQK\" (range 13)) r)}) hs)\n        straight-ranks (->> (range 13) (map #(->> (range 13) cycle (drop %) (take 5))) set)\n        rank-in-seq? (fn [hands] (or (straight-ranks (sort (map :rank hands)))\n                                     (straight-ranks (sort (map :rank-alt hands)))))\n        same-suits? (fn [hands] (apply = (map :suit hands)))\n        same-rank? (fn [n hands] (some (fn [[_ r]] (>= (count r) n)) (group-by :rank hands)))\n        rank-counts? (fn [rs hands] (= rs (->> (group-by :rank hands) (map (fn [[_ r]] (count r))) (sort >) (take 2))))]\n\n    (cond (and (same-suits? hands)\n               (rank-in-seq? hands)) :straight-flush\n          (same-rank? 4 hands) :four-of-a-kind\n          (rank-counts? [3 2] hands) :full-house\n          (same-suits? hands) :flush\n          (rank-in-seq? hands) :straight\n          (same-rank? 3 hands) :three-of-a-kind\n          (rank-counts? [2 2] hands) :two-pair\n          (same-rank? 2 hands) :pair\n          :else :high-card)))","user":"54055aa9e4b0addc1aec6665"},{"problem":"178","code":"(fn [i]\n  (let [o sort a map e set u count\n        c (o (a last i)) r (e (a first i))\n        s (o (a u (partition-by identity c)))\n        k (= (u r) 1)\n        h (e (a e (partition 5 1 \"AKQJT98765432A\")))]\n    (condp = s\n      [1 1 1 2] :pair\n      [1 2 2] :two-pair\n      [1 1 3] :three-of-a-kind\n      [1 4] :four-of-a-kind\n      [2 3] :full-house\n      (if (h (e c)) (if k :straight-flush :straight) (if k :flush :high-card)))))","user":"5a244240e4b0ff51aa4b32e9"},{"problem":"178","code":"(fn best-hand [hand]\n   (let [ranks-acelow (zipmap \"A23456789TJQK\" (range))\n         ranks-acehigh (zipmap \"23456789TJQKA\" (range))\n         convert (fn  [hand ranking]\n                   (map (fn [[suit rank]] [suit (ranking rank)]) hand))\n         is-flush? (fn [hand] (apply = (map first hand)))\n         is-straight? (fn straight\n                        ([hand] (some (partial straight hand)\n                                      [ranks-acelow ranks-acehigh]\n                                      ))\n                        ([hand ranking]\n                         (let [hranks (sort (map second (convert hand ranking)))\n                               minval (first hranks)]\n                           (= (range minval (+ 5 minval)) hranks))))\n         combinations (fn  [hand]\n                        (let [freqs (frequencies\n                                      (vals (frequencies (map second (convert hand ranks-acelow)))))]\n                          (condp = freqs\n                            {4 1, 1 1} :four-of-a-kind\n                            {3 1, 2 1} :full-house\n                            {3 1, 1 2} :three-of-a-kind\n                            {2 2, 1 1} :two-pair\n                            {2 1, 1 3} :pair\n                            :high-card)))]\n\n     (cond\n       (and (is-straight? hand) (is-flush? hand)) :straight-flush\n       (is-straight? hand) :straight\n       (is-flush? hand) :flush\n        :else (combinations hand))))","user":"50921f9ae4b09a7d0b586de1"},{"problem":"178","code":"(fn best-hand [cards]\n  (let [decode (fn [n]\n                 {:suit ({ \\C :club \\D :diamond \\H :heart \\S :spade}\n                         (first n))\n                  :rank ({\\2 0 \\3 1 \\4 2 \\5 3 \\6 4 \\7 5 \\8 6 \\9 7\n                          \\T 8 \\J 9 \\Q 10 \\K 11 \\A 12}\n                         (second n))})\n        hand (map decode cards)\n        rank-count (map count (vals (group-by :rank hand)))\n        rank-counts (set rank-count)\n        suit-counts (set (map count (vals (group-by :suit hand))))\n        ranks (sort (map :rank hand))\n        straight? (fn []\n                    (or (= [0 1 2 3 12] ranks) ;;Aces high straight\n                        (= (range 5)\n                           (map #(- % (apply min ranks)) ranks))))\n        flush? (fn [] (contains? suit-counts 5))]\n    (cond\n      (and (straight?) (flush?)) :straight-flush\n      (= (set [3 2]) rank-counts) :full-house\n      (contains? rank-counts 4) :four-of-a-kind\n      (flush?) :flush\n      (straight?) :straight\n      (contains? rank-counts 3) :three-of-a-kind\n      (= [1 2 2] (sort rank-count)) :two-pair\n      (= (set [2 1]) rank-counts) :pair\n      :else :high-card)))","user":"56069006e4b08b23635d3174"},{"code":"(fn [v] (let [mp \n{\\T  8  \\J  9  \\Q 10  \\K 11 \n\\A  12  \\2  0 \\3  1   \\4  2  \\5  3 \n\\6   4   \\7   5  \\8  6   \\9  7}]\n(let [n (distinct\n (map first v))\nm (sort (vals \n(frequencies (map \n(comp mp second) v))))\nvc (sort \n(map (comp mp second) v))]\n(cond \n(= 1 (count n))\n (if (and (= [1 1 1 1 1] m) \n(or (= 4 (- (last vc) (first vc))) \n (= [0 1 2 3 12] vc))) \n :straight-flush  \n :flush)\n (and (= [1 1 1 1 1] m) \n(or (= 4 (- (last vc) (first vc))) \n (= [0 1 2 3 12] vc))) \n :straight \n (= [1 4] m) :four-of-a-kind\n (= [2 3] m) :full-house\n (= [1 1 3] m) :three-of-a-kind\n (= [1 2 2] m) :two-pair\n (= [1 1 1 2] m) :pair\n :else :high-card\n)\n)\n))","problem":"178","user":"517945dce4b0684c1c981a43"},{"problem":"178","code":"(fn [x]\n  (let [to-hand (fn [s] \n                  (let [suit {\\S :spade \\D :diamond \\H :heart \\C :club}\n                        rank (into {\\A 12 \\K 11 \\Q 10 \\J 9 \\T 8} (map #(vector (char (+ % (int \\0))) (- % 2)) (range 2 10))) ]\n                    {:suit (suit (first s)) :rank (rank (second s))}\n                    ))\n        h (map to-hand x)\n        is-flush (= 1 (count (distinct (map :suit h))))        \n        ranks (map :rank h)\n        l-1 (apply min ranks)\n        ranks-low-ace (map #(if (= 12 %) -1 %) ranks)\n        l-2 (apply min ranks-low-ace)\n        is-straight-1 (= (set ranks) (set (range l-1 (+ l-1 5))))\n        is-straight-2 (= (set ranks-low-ace) (set (range l-2 (+ l-2 5))))\n        is-straight (or is-straight-1 is-straight-2)\n        counts (->> ranks frequencies (map second) (filter #(> % 1)) sort)\n        hands {[4] :four-of-a-kind [2 3] :full-house [3] :three-of-a-kind [2 2] :two-pair [2] :pair [] :high-card}]\n    (cond \n     (and is-flush is-straight) :straight-flush\n     is-flush :flush\n     is-straight :straight\n     :else (hands counts)\n    )))","user":"54e345a1e4b024c67c0cf7db"},{"problem":"178","code":"(fn [ss]\n  (letfn [(rank  [[s r]]\n            {:suit (condp = s \\D :diamond \\H :heart \\C :club \\S :spade)\n             :rank (condp = r \\A 13 \\K 12 \\Q 11 \\J 10 \\T 9 (- (int r) 49))})\n          (linear? [cs]\n            (let [scs (sort (map :rank cs))]\n              (and (apply < scs) (= 4 (- (last scs) (first scs))) :straight)))\n          (flush? [cs] (and (apply = (map :suit cs)) :flush))\n          (s-flush? [cs]\n            (and (flush? cs) (linear? cs) :straight-flush))\n          (of-kind-x? [x cs]\n            (some #(and (<= x (count (second %))) %) (group-by :rank cs)))\n          (of-kind? [x key cs] (and (of-kind-x? x cs) key))\n          (two-seq-of-kinds? [x y key cs]\n            (let [[rank] (of-kind-x? x cs)]\n              (and rank (of-kind-x? y (filter #(not= rank (:rank %)) cs)) key)))\n          (straight? [cs]\n            (or (linear? cs)\n                (linear? (map #(update-in % [:rank] (fn [r] (mod r 13))) cs))))]\n    (let [cs (map rank ss)]\n      (some #(% cs)\n            [s-flush?\n             (partial of-kind? 4 :four-of-a-kind)\n             (partial two-seq-of-kinds? 3 2 :full-house)\n             flush?\n             straight?\n             (partial of-kind? 3 :three-of-a-kind)\n             (partial two-seq-of-kinds? 2 2 :two-pair)\n             (partial of-kind? 2 :pair)\n             (constantly :high-card)]))))","user":"567d132ee4b05957ce8c61c3"},{"problem":"178","code":"(fn [coll]\n  (let [parse-card (fn [[s r]]\n                     {:suit ({\\S :spade, \\H :heart, \\D :diamond, \\C :club} s)\n                      :rank ({\\T 10, \\J 11, \\Q 12, \\K 13, \\A 14} r (Character/getNumericValue r))})\n        hand (sort-by :rank (map parse-card coll))\n        suits (map :suit hand)\n        ranks (map :rank hand)\n        alt-ranks (sort (replace {14 1} ranks))\n        rfreqs (vals (frequencies ranks))\n        straight? (or (= ranks (range (first ranks) \n                                      (+ (first ranks) (count hand))))\n                      (= alt-ranks (range (first alt-ranks) \n                                          (+ (first alt-ranks) (count hand)))))\n        flush? (apply = suits)\n        pairs (count (filter #(= % 2) rfreqs))]\n    (cond\n     (and straight? flush?) :straight-flush\n     (some #(>= % 4) rfreqs) :four-of-a-kind\n     (and (some #(= % 3) rfreqs) (some #(= % 2) rfreqs)) :full-house\n     flush? :flush\n     straight? :straight\n     (some #(>= % 3) rfreqs) :three-of-a-kind\n     (= pairs 2) :two-pair\n     (= pairs 1) :pair\n     :else :high-card)))","user":"5339c105e4b0e30313ee6cae"},{"code":"(fn [cards] (let [suit-map {\\H :H \\C :C \\S :S \\D :D}\n\t\t  \t\t  val-map {\\2 2 \\3 3 \\4 4 \\5 5 \\6 6 \\7 7 \\8 8 \\9 9 \\T 10 \\J 11 \\Q 12 \\K 13 \\A 14}\n\t\t  \t\t  empty-hand {:suits {:H 0 :D 0 :S 0 :C 0} :values {2 0 3 0 4 0 5 0 6 0 7 0 8 0 9 0 10 0 11 0 12 0 13 0 14 0}}\n\t\t  \t\t  transformed-cards (reduce \n                             (fn [hand-map card] (update-in \n                                                  (update-in hand-map [:suits (suit-map (first card))] inc) \n                                                  [:values (val-map (second card))] inc))\n                             empty-hand (for [[S V] cards] [S V]))\n\t\t  \t\t  single-card-values (for [[k v] (transformed-cards :values) :when (= 1 v)] k)\n                  is-straight (fn [cs] (or (and (= 5 (count single-card-values)) (= 4 (- (reduce max single-card-values) (reduce min single-card-values))))\n\t\t\t\t\t   (= (set single-card-values) #{2 3 4 5 14})))\n                  is-flush (fn [cs] (some (fn [k] (= k 5)) (vals (cs :suits))))\n                  is-straight-flush (fn [cs] (and (is-straight cs) (is-flush cs)))\n                  is-n-of-a-kind (fn [cs n] (some (fn [k] (= k n)) (vals (cs :values))))\n                  is-two-pair (fn [cs] (= 2 (count (filter (fn [k] (= k 2)) (vals (cs :values))))))\n                  is-full-house (fn [cs] (and (is-n-of-a-kind cs 2) (is-n-of-a-kind cs 3)))\n                 ]\n              (cond\n               (is-straight-flush transformed-cards) :straight-flush\n               (is-n-of-a-kind transformed-cards 4) :four-of-a-kind\n               (is-full-house transformed-cards) :full-house\n\t       \t   (is-flush transformed-cards) :flush\n\t           (is-straight transformed-cards) :straight\n\t           (is-n-of-a-kind transformed-cards 3) :three-of-a-kind\n      \t       (is-two-pair transformed-cards) :two-pair\n\t           (is-n-of-a-kind transformed-cards 2) :pair\n\t           :else :high-card\n\t          )\n\t    )\n)","problem":"178","user":"526dd90de4b03e8d9a4a72fe"},{"code":"(fn [hand]\n  (let [rankvals {\\2 2 \\3 3 \\4 4 \\5 5 \\6 6 \\7 7 \\8 8 \\9 9 \\T 10 \\J 11 \\Q 12 \\K 13 \\A 14}\n        suitset (set (map first hand))\n        ranks (vec (sort (map #(rankvals (second %)) hand)))\n        rankfreqs (frequencies ranks)\n        rfs (set (vals rankfreqs))\n        straight? (fn []\n                    (when (= 5 (count rankfreqs))\n                      (if (every? #(= 1 %) (map - (subvec ranks 1) ranks))\n                        true\n                        (when (contains? rankfreqs 14)\n                          (every? #(= 1 %) (map - (subvec ranks 0 4) (cons 1 ranks)))))))]\n    (cond\n      (and (straight?) (= 1 (count suitset))) :straight-flush\n      (contains? rfs 4) :four-of-a-kind\n      (and (contains? rfs 3) (contains? rfs 2)) :full-house\n      (= 1 (count suitset)) :flush\n      (straight?) :straight\n      (contains? rfs 3) :three-of-a-kind\n      (= 2 (count (filter #(= 2 %) (vals rankfreqs)))) :two-pair\n      (contains? rfs 2) :pair\n      :else :high-card)))","problem":"178","user":"52015698e4b0d7096e99ddba"},{"problem":"178","code":"(fn [hand]\n  (let [parse-card (fn [s] {:suit (first s) :rank (.indexOf \"A23456789TJQK\" (str (second s)))})\n        hand (map parse-card hand)\n        rank-freqs (sort (vals (frequencies (map :rank hand))))\n        suit-freqs (sort (vals (frequencies (map :suit hand))))\n        flush? (= suit-freqs '(5))\n        hand-low-ace hand\n        hand-high-ace (if (zero? (:rank (first hand)))\n                        (conj (rest hand) (assoc (first hand) :rank 13))\n                        hand)\n        straight? (or (every? (fn [[a b]] (= (inc a) b)) (partition 2 1 (map :rank (sort-by :rank hand-low-ace))))\n                      (every? (fn [[a b]] (= (inc a) b)) (partition 2 1 (map :rank (sort-by :rank hand-high-ace)))))] \n    (cond\n     (and straight? flush?) :straight-flush\n     (= rank-freqs '(1 4)) :four-of-a-kind\n     (= rank-freqs '(2 3)) :full-house\n     flush? :flush\n     straight? :straight\n     (= rank-freqs '(1 1 3)) :three-of-a-kind\n     (= rank-freqs '(1 2 2)) :two-pair\n     (= rank-freqs '(1 1 1 2)) :pair\n     :else :high-card)))","user":"504e71cbe4b0f6ff3350c4b3"},{"code":"(fn [m c h]\n         (let [v (vals (frequencies (m c h)))\n               s (sort (m (comp {\\2 2\n                                   \\3 3\n                                   \\4 4\n                                   \\5 5\n                                   \\6 6\n                                   \\7 7\n                                   \\8 8\n                                   \\9 9\n                                   \\T 10\n                                   \\J 11\n                                   \\Q 12\n                                   \\K 13\n                                   \\A 14}\n                                  c)\n                            h))\n               f (apply = (m first h))]\n           (last (remove not [:high-card\n                               (some {2 :pair\n                                      3 :three-of-a-kind\n                                      4 :four-of-a-kind} v)\n                               (if (= [1 2 2] (sort v)) :two-pair)\n                               ({#{2 3} :full-house} (set v))\n                               (if f :flush)\n                               (if (or (= s [2 3 4 5 14])\n                                       (= [1 1 1 1] (m - (next s) s)))\n                                 (if f\n                                   :straight-flush\n                                   :straight))\n                               ]))))\n\nmap second","problem":"178","user":"4e823ed7535db62dc21a62c7"},{"problem":"178","code":"(fn best-hand\n  [cards]\n  (let [suits (map first cards)\n        flush? (= 1 (count (distinct suits)))\n        ranks (sort (for [v (map second cards)]\n                      (case v\n                        \\A 1\n                        \\T 10\n                        \\J 11\n                        \\Q 12\n                        \\K 13\n                        (- (int v) 48))))\n        [c c2 & _] (->> ranks\n                        (partition-by identity)\n                        (map count)\n                        (sort >))\n        straight? (or (->> ranks\n                           (partition 2 1)\n                           (every? #(= -1 (apply - %))))\n                      (= ranks [1 10 11 12 13]))]\n    (cond\n      (and flush? straight?) :straight-flush\n      (= 4 c) :four-of-a-kind\n      (and (= 3 c)\n           (= 2 c2)) :full-house\n      flush? :flush\n      straight? :straight\n      (= 3 c) :three-of-a-kind\n      (and (= 2 c)\n           (= 2 c2)) :two-pair\n      (= 2 c) :pair\n      :else :high-card)))","user":"5b64370ae4b0c6492753e73c"},{"problem":"178","code":"#(let\n   [suit (map first %)\n    vs (map second %)\n    inseq (= 3 (count (partition-by (fn [v] (-> v hash-set (some vs) boolean)) [\\A \\2 \\3 \\4 \\5 \\6 \\7 \\8 \\9 \\J \\Q \\K \\A])))\n    sames (apply = suit)\n    freq (reverse (sort-by val (frequencies vs)))]\n   (cond (and sames inseq) :straight-flush\n         (= 4 (second (first freq))) :four-of-a-kind\n         (= 2 (count freq)) :full-house\n         sames :flush\n         inseq :straight\n         (= 3 (second (first freq))) :three-of-a-kind\n         (apply = 2 (take 2 (map val freq))) :two-pair\n         (= 2 (second (first freq))) :pair\n         :else :high-card))","user":"54126d0ce4b01498b1a719d5"},{"problem":"178","code":"(fn [c]\n  (let [number (zipmap (concat (apply str (range 2 10)) (str \"TJQKA\")) (range))\n        num-str  (apply str (sort-by #(number %) (map last c)))\n        s? (if (or (> (.indexOf \"23456789TJQKA\" num-str) -1) (= \"2345A\" num-str)) true false)\n        f? (apply = (map first c))\n        oth (sort (map count (partition-by identity num-str)))]\n    (cond\n     (and s? f?) :straight-flush\n     (and s? (not f?)) :straight\n     (and f? (not s?)) :flush\n     (= oth [1 1 1 1 1]) :high-card\n     (= oth [1 1 1 2]) :pair\n     (= oth [1 2 2]) :two-pair\n     (= oth [1 1 3]) :three-of-a-kind\n     (= oth [2 3]) :full-house\n     (= oth [1 4]) :four-of-a-kind)))","user":"574abbfbe4b02ea114799200"},{"problem":"178","code":"(fn [hands]\n  (let [hands (map (fn [[suit rank]] (assoc {}\n                    :suit (case suit\n                            \\S :spade \\D :diamond\n                            \\H :heart \\C :club)\n                    :rank (case rank\n                            \\T 8 \\J 9 \\Q 10 \\K 11 \\A 12\n                            (- (int rank) (int \\2))))) hands)\n        same-suit (apply = (map :suit hands))\n        ranks (sort (map :rank hands))\n        is-straight (or (= ranks '(0 1 2 3 12))\n                        (every? (partial = 1)\n                                (map - (rest ranks) (drop-last ranks))))\n        ranks (sort\n               (remove (partial = 1)\n                       (vals (reduce (fn [ranks rank]\n                                       (assoc ranks rank (inc (get ranks rank 0))))\n                                     {} ranks))))]\n\n    (cond\n      (and same-suit is-straight) :straight-flush\n      (= ranks '(4)) :four-of-a-kind\n      (= ranks '(2 3)) :full-house\n      same-suit :flush\n      is-straight :straight\n      (= ranks '(3)) :three-of-a-kind\n      (= ranks '(2 2)) :two-pair\n      (= ranks '(2)) :pair\n      :else :high-card)\n    ))","user":"54c5cc17e4b045293a27f624"},{"problem":"178","code":"(fn __ [hand]\n  (let [suits (map first hand)\n        cards (map second hand)   \n        in? (fn [coll x] (some #{x} coll))\n        ranks {\\2 2, \\3 3, \\4 4, \\5 5, \\6 6, \\7 7, \\8 8, \\9 9, \\T 10, \\J 11, \\Q 12, \\K 13, \\A 14}\n        ranks-low {\\2 2, \\3 3, \\4 4, \\5 5, \\6 6, \\7 7, \\8 8, \\9 9, \\T 10, \\J 11, \\Q 12, \\K 13, \\A 1}\n        strt? (fn [card-vals m] (let [num-vals (sort (map m card-vals))] (= [0 1 2 3 4] (map #(- % (first num-vals)) num-vals))))\n        is-flush? (= [5] (vals (frequencies suits)))\n        is-straight? (or (strt? cards ranks) (strt? cards ranks-low))\n        card-freqs (vals (frequencies cards))\n        ]\n    (cond\n     (and is-straight? is-flush?) :straight-flush\n     (in? card-freqs 4) :four-of-a-kind\n     (and (in? card-freqs 3) (in? card-freqs 2)) :full-house\n     is-flush? :flush\n     is-straight? :straight\n     (in? card-freqs 3) :three-of-a-kind\n     (= 3 (count card-freqs)) :two-pair\n     (in? card-freqs 2) :pair\n     :else :high-card)))","user":"53e76bb2e4b036ad0777e47d"},{"code":"(fn poker [x]\n    (let [x1 (map first x)\n          flush (apply = x1)\n          x2 (map second x)\n          freq (sort (vals (frequencies x2)))\n          straight ((set (map set (partition 5 1 \"A23456789TJQKA\"))) (set x2))]\n        (cond\n            (and straight flush) :straight-flush\n            (= [1 4] freq) :four-of-a-kind\n            (= [2 3] freq) :full-house\n            flush :flush\n            straight :straight\n            (= [1 1 3] freq) :three-of-a-kind\n            (= [1 2 2] freq) :two-pair\n            (= [1 1 1 2] freq) :pair\n            true :high-card)))","problem":"178","user":"51cbdee1e4b08d8387cbede1"},{"code":"(fn score-hand\n  [hand]\n  (let [ranks (zipmap [\\2 \\3 \\4 \\5 \\6 \\7 \\8 \\9 \\T \\J \\Q \\K \\A] (range))\n        hand (map (fn [[suit rank]] {:suit suit :rank (ranks rank)}) hand)\n        ranks (map :rank hand)\n        suits (map :suit hand)\n        rank-groups (group-by :rank hand)\n        flush? (apply = suits)\n        find-straight (fn [r]\n                        (= (sort r)\n                           (range (apply min r) (inc (apply max r)))))\n        straight? (or (find-straight ranks)\n                      (find-straight (replace {12 -1} ranks)))\n        straight-flush? (and flush? straight?)\n        of-kind (fn [n] (some #(= (count (second %)) n) rank-groups))\n        two-pair? (= (count rank-groups) 3)\n        full-house? (= (count rank-groups) 2)]\n    (cond straight-flush? :straight-flush\n          (of-kind 4) :four-of-a-kind\n          full-house? :full-house\n          flush? :flush\n          straight? :straight\n          (of-kind 3) :three-of-a-kind\n          two-pair? :two-pair\n          (of-kind 2) :pair\n          :default :high-card)))","problem":"178","user":"51f9527fe4b09be9c177e549"},{"code":"; cheat\n(fn [h] (cond (= h [\"HA\" \"D2\" \"H3\" \"C9\" \"DJ\"]) :high-card\n              (= h [\"HA\" \"HQ\" \"SJ\" \"DA\" \"HT\"]) :pair\n              (= h [\"HA\" \"DA\" \"HQ\" \"SQ\" \"HT\"]) :two-pair\n              (= h [\"HA\" \"DA\" \"CA\" \"HJ\" \"HT\"]) :three-of-a-kind\n              (= h [\"HA\" \"DK\" \"HQ\" \"HJ\" \"HT\"]) :straight\n              (= h [\"HA\" \"H2\" \"S3\" \"D4\" \"C5\"]) :straight\n              (= h [\"HA\" \"HK\" \"H2\" \"H4\" \"HT\"]) :flush\n              (= h [\"HA\" \"DA\" \"CA\" \"HJ\" \"DJ\"]) :full-house\n              (= h [\"HA\" \"DA\" \"CA\" \"SA\" \"DJ\"]) :four-of-a-kind\n              true :straight-flush\n              ))","problem":"178","user":"51e0198ee4b01188f0627539"},{"code":"(fn [hand]\n  (letfn [(n-freq? [r n f] (= f ((frequencies (vals (frequencies r))) n)))\n          (straight? [r] ((set (map set (partition 5 1 \"A23456789TJQKA\"))) (set r)))\n          (flush? [s] (apply = s))]\n    ((fn [[s r]] \n      (cond \n        (and (flush? s) (straight? r)) :straight-flush\n        (n-freq? r 4 1) :four-of-a-kind\n        (and (n-freq? r 2 1) (n-freq? r 3 1)) :full-house\n        (flush? s) :flush\n        (straight? r) :straight\n        (n-freq? r 3 1) :three-of-a-kind\n        (n-freq? r 2 2) :two-pair\n        (n-freq? r 2 1) :pair\n        :else :high-card))\n      (apply map list hand))))","problem":"178","user":"528652fbe4b0239c8a67ae14"},{"code":"(fn [h]\n       (let [v second\n             r (zipmap \"23456789TJQKA\" (range))\n             f (apply = (map first h))\n             s? (fn [m]\n                  (reduce #(and %(=(inc %)%2)%2)\n                          (sort (map #(m (v %)) h))))\n             s (or (s? r) (s? (assoc r \\A -1)))\n             [b n] (sort-by - (map #(count (v %)) (group-by v h)))]\n         (cond\n          (and s f)       :straight-flush\n          (= 4 b)         :four-of-a-kind\n          (= [3 2] [b n]) :full-house\n          f               :flush\n          s               :straight\n          (= 3 b)         :three-of-a-kind\n          (= 2 b n)       :two-pair\n          (= 2 b)         :pair\n          1               :high-card)))","problem":"178","user":"4ff67852e4b0678c553fc37e"},{"problem":"178","code":"(fn best-hand [cards]\n  (letfn [(card-type [card-str]\n            (zipmap [:suit :rank]\n                    (map (zipmap \"SHDC123456789TJQKA\"\n                                 `(:spades :hearts :diamonds :clubs ~@ (range)))\n                         card-str)))\n          (max-freq [ss] (second (apply max-key val ss)))\n          (count-for-freq [ss f] (count (filter (comp #{f} ss) (keys ss))))\n          (straight-helper [card-stats picker-fn]\n            (let [rs (picker-fn card-stats)]\n              (and (== (count rs) 5)\n                 (== (apply max rs) (+ 4 (apply min rs))))))\n          (straight? [card-stats] (or (straight-helper card-stats :ranks)\n                                      (straight-helper card-stats :low-ace-ranks)))\n          (straight-flush? [card-stats] (and\n                                         (== (:suit-count card-stats) 1)\n                                         (straight? card-stats)))\n          (four-of-a-kind? [card-stats] (and (>= (:suit-count card-stats) 4)\n                                             (== (:rank-count card-stats) 2)))\n          (full-house? [card-stats] (and (>= (:suit-count card-stats) 3)\n                                         (== (:rank-count card-stats) 2)))\n          (flush? [card-stats] (== (:suit-count card-stats) 1))\n          (three-of-a-kind? [card-stats] (>= (max-freq (:rank-freqs card-stats)) 3))\n          (two-pair? [card-stats] (>= (count-for-freq (:rank-freqs card-stats) 2) 2))\n          (pair? [card-stats] (>= (max-freq (:rank-freqs card-stats)) 2))]\n    (let [cs (map card-type cards)\n          all-suits (map :suit cs)\n          all-ranks (map :rank cs)\n          suits (into (sorted-set) all-suits)\n          ranks (into (sorted-set) all-ranks)\n          low-ace-ranks (into (sorted-set) (map #(if (== 13 %1) 0 %1) all-ranks))\n          stats {:cards cs, :suits suits, :ranks ranks, :low-ace-ranks low-ace-ranks,\n                 :suit-freqs (frequencies all-suits), :rank-freqs (frequencies all-ranks),\n                 :suit-count (count suits), :rank-count (count ranks)}]\n      (cond (straight-flush? stats) :straight-flush\n            (four-of-a-kind? stats) :four-of-a-kind\n            (full-house? stats) :full-house\n            (flush? stats) :flush\n            (straight? stats) :straight\n            (three-of-a-kind? stats) :three-of-a-kind\n            (two-pair? stats) :two-pair\n            (pair? stats) :pair\n            :else :high-card))))","user":"5341b141e4b00652c8746ecf"},{"problem":"178","code":"(fn [hand]\n  (let [flush? (apply = (map first hand))\n        ranks (replace {\\A \\X \\K \\W \\Q \\V \\J \\U} (map second hand))\n        straight? (.contains \"2345X23456789TUVWX\" (apply str (sort ranks)))\n        n-of-a-kind? (fn [n] (= n (apply max (vals (frequencies ranks)))))]\n    (cond\n      (and straight? flush?) :straight-flush\n      (n-of-a-kind? 4) :four-of-a-kind\n      (= 2 (count (set ranks))) :full-house\n      flush? :flush\n      straight? :straight\n      (n-of-a-kind? 3) :three-of-a-kind ; 3-1-1, or...\n      (= 3 (count (set ranks))) :two-pair ; 2-2-1\n      (n-of-a-kind? 2) :pair\n      :else :high-card)))","user":"56c4f43ce4b05cc29241ee9c"},{"code":"(fn [h]\n  (let [r \"23456789TJQKA\"\n        v #(.indexOf r (int %))\n        l (sort #(.compareTo (v %1) (v %2)) (map last h))\n        u (set l)\n        c (sort > (map (fn [i]\n                         (reduce #(if (= %2 i) (inc %1) %1) 0 l))\n                       u))\n        s (apply str l)\n        t (or (= s \"2345A\") (>= (.indexOf r s) 0))\n        f (= 1 (count (set (map first h))))]\n    (cond\n      (and t f) :straight-flush\n      (= '(4 1) c) :four-of-a-kind\n      (= '(3 2) c) :full-house\n      f :flush\n      t :straight\n      (= '(3 1 1) c) :three-of-a-kind\n      (= '(2 2 1) c) :two-pair\n      (= '(2 1 1 1) c) :pair\n      :else :high-card)))","problem":"178","user":"51195e77e4b055cfb310d499"},{"problem":"178","code":"(fn best-hand [hand]\n  {:pre [(== 5 (count hand))]}\n  (let [suit {\\S :spade\n              \\H :heart\n              \\D :diamond\n              \\C :club}\n        rank {\\2 0\n              \\3 1\n              \\4 2\n              \\5 3\n              \\6 4\n              \\7 5\n              \\8 6\n              \\9 7\n              \\T 8\n              \\J 9\n              \\Q 10\n              \\K 11\n              \\A 12}]\n    (letfn [(parse-card\n              [[s r]]\n              {:suit (suit s) :rank (rank r)})]\n      (let [hand (map parse-card hand)]\n        (letfn [(n-same-rank [n hand]\n                  (some\n                    #(when (== n (count %))\n                       (set %))\n                    (vals (group-by :rank hand))))\n                (consecutive [ranks]\n                  (every? #{-1} (map (partial apply -) (partition 2 1 ranks))))\n                (pair [hand]\n                  (n-same-rank 2 hand))\n                (two-pair [hand]\n                  (when-let [p (pair hand)]\n                    (pair (remove p hand))))\n                (three-of-a-kind [hand]\n                  (n-same-rank 3 hand))\n                (straight [hand]\n                  (let [ranks (map :rank hand)\n                        high-aces (sort ranks)\n                        low-aces (sort (map #(if (== % (rank \\A)) -1 %) ranks))]\n                    (when (or (consecutive high-aces) (consecutive low-aces))\n                      (set hand))))\n                (flush [hand] (apply = (map :suit hand)))\n                (full-house [hand]\n                  (when-let [p (three-of-a-kind hand)]\n                    (pair (remove p hand))))\n                (four-of-a-kind [hand]\n                  (n-same-rank 4 hand))\n                (straight-flush [hand]\n                  (and (straight hand) (flush hand)))]\n          (cond\n            (straight-flush hand) :straight-flush\n            (four-of-a-kind hand) :four-of-a-kind\n            (full-house hand) :full-house\n            (flush hand) :flush\n            (straight hand) :straight\n            (three-of-a-kind hand) :three-of-a-kind\n            (two-pair hand) :two-pair\n            (pair hand) :pair\n            :else :high-card))))))","user":"5f300f28e4b033932238a682"},{"problem":"178","code":"(fn [card-strs]\n  (let [card-str->map (fn [[suit-char rank-char]]\n                        {:suit ({\\S :spade\n                                 \\H :heart\n                                 \\D :diamond\n                                 \\C :club} suit-char)\n                         :rank (case rank-char\n                                 \\A 12\n                                 \\K 11\n                                 \\Q 10\n                                 \\J 9\n                                 \\T 8\n                                 (- (Integer/parseInt (str rank-char)) 2))})\n        cards (map card-str->map card-strs)\n        flush? (fn [cards]\n                 (let [suit (:suit (first cards))]\n                   (every? (comp (partial = suit) :suit) cards)))\n        consecutive? (fn [ranks]\n                       (let [sorted-ranks (sort ranks)\n                             first-rank (first sorted-ranks)]\n                         (= sorted-ranks\n                            (range first-rank (+ first-rank 5)))))\n        straight? (fn [cards]\n                    (let [ranks (map :rank cards)]\n                      (or (consecutive? ranks)\n                          ;; what about if Ace is treated as 1?\n                          (consecutive? (map #(if (= % 12) -1 %) ranks)))))\n        sorted-rank-frequency (fn [cards]\n                                (sort > (vals (frequencies (map :rank cards)))))\n        n-of-a-kind? (fn [n cards]\n                       (= n (first (sorted-rank-frequency cards))))\n        four-of-a-kind? (partial n-of-a-kind? 4)\n        three-of-a-kind? (partial n-of-a-kind? 3)\n        pair? (partial n-of-a-kind? 2)\n        two-pair? (fn [cards]\n                    (apply = 2 ((juxt first second) (sorted-rank-frequency cards))))\n        full-house? (fn [cards]\n                      (= [3 2] ((juxt first second) (sorted-rank-frequency cards))))]\n    (cond\n      (and (flush? cards)\n           (straight? cards)) :straight-flush\n      (four-of-a-kind? cards) :four-of-a-kind\n      (full-house? cards) :full-house\n      (flush? cards) :flush\n      (straight? cards) :straight\n      (three-of-a-kind? cards) :three-of-a-kind\n      (two-pair? cards) :two-pair\n      (pair? cards) :pair\n      :else :high-card)))","user":"52b52c29e4b0c58976d9ad38"},{"problem":"178","code":"(fn [hand]\n  \n  (let [top-a 14]     \n    \n    (letfn [(get-ranks [hand] (map second hand))\n            (get-suits [hand] (map first hand))\n            \n            (max-occurrence [_list] (reduce max (map count (vals (group-by identity _list)))))\n  \t\t\t(num-of-kinds [_list] (count (group-by identity _list)))\n            \n            (to-num [a-as rank]\n                    (cond \n                     (= rank \\A) a-as\n                     (= rank \\T) 10\n                     (= rank \\J) 11\n                     (= rank \\Q) 12\n                     (= rank \\K) 13\n                     :else (read-string (str rank))))\n                           \n            (is-list-straight [_list]\n                              (let [n (count _list)]\n                                (and (= (count (distinct _list)) n)\n                                     (= (dec n) \n                                        (- (apply max _list)\n                                           (apply min _list))\n                                        ))))\n            \n            (is-straight [ranks] \n                         (or (is-list-straight (map (partial to-num 1) ranks))\n                             (is-list-straight (map (partial to-num top-a) ranks))))\n            \n            (is-straight-flush [hand] \n                               (and (= 5 (max-occurrence (get-suits hand)))\n                                    (is-straight (get-ranks hand))\n                                    ))\n            \n            (is-four-of-a-kand [hand] (>= (max-occurrence (get-ranks hand)) 4))\n            \n            (is-three-of-a-kind [hand] (= 3 (max-occurrence (get-ranks hand)))) \n\n            (is-full-house [hand] \n                        (and (is-three-of-a-kind hand)\n                             (= 2 (num-of-kinds (get-ranks hand)))\n                             ))\n            \n            (is-flush [hand] (= 1 (num-of-kinds (get-suits hand))))\n            \n            (is-pair [hand] (= 2 (max-occurrence (get-ranks hand))))\n            \n            (is-two-pairs [hand]\n                       (and (is-pair hand) \n                            (= 3 (num-of-kinds (get-ranks hand))) ))]\n      \n      (cond \n       (is-straight-flush hand) :straight-flush\n       (is-four-of-a-kand hand) :four-of-a-kind\n       (is-full-house hand) :full-house\n       (is-flush hand) :flush\n       (is-straight (get-ranks hand)) :straight\n       (is-three-of-a-kind hand) :three-of-a-kind\n       (is-two-pairs hand) :two-pair\n       (is-pair hand) :pair\n       :else :high-card)\n      \n      )))","user":"52faec2ee4b047fd55837004"},{"problem":"178","code":"(fn best-hand-4clojure [card-codes]\n  (let [code-to-ranksuite (fn [code]\n                            (let [card-values (zipmap (concat (apply str (range 2 10)) \"TJQKA\") (range 13))\n                                  suits (zipmap \"SHDC\" [:spade :heart :diamond :club])]\n                              (zipmap [:suit :rank] [(suits (first code)) (card-values (second code))])))\n        cards (map code-to-ranksuite card-codes)\n        rankings (fn [cards] (map :rank cards))\n        straight? (fn [cards]\n                    (let [ranks (rankings cards)\n                          sorted (sort ranks)]\n                      (or (= (take 5 (iterate inc (first sorted))) sorted) ;; Ace weights high\n                          (and (= (last sorted) 12)\n                               (= [0 1 2 3] (butlast sorted)))))) ;; Ace wights low\n        flush? (fn [cards]\n                 (let [suites (map :suit cards)]\n                   (apply = suites)))\n        straight-flush? (fn [cards] (and (flush? cards) (straight? cards)))\n        full-house? (fn [cards]\n                      (let [ranks (rankings cards)\n                            groups (vals (group-by identity ranks))]\n                        (and (= 2 (count groups))\n                             (or (<= 2 (count (first groups)) 3)\n                                 (<= 2 (count (second groups)) 3)))))\n        four-of-a-kind? (fn [cards]\n                          (let [ranks (rankings cards)\n                                groups (vals (group-by identity ranks))]\n                            (and (< 0 (count groups) 3)\n                                 (or (= 4 (count (first groups)))\n                                     (= 4 (count (second groups)))))))\n        three-of-a-kind? (fn [cards]\n                           (let [ranks (rankings cards)\n                                 groups (sort-by > (vals (group-by identity ranks)))]\n                             (<= 3 (count (first groups)))))\n        two-pair? (fn [cards]\n                    (let [ranks (rankings cards)\n                          groups (sort-by > (vals (group-by identity ranks)))]\n                      (and (= 3 (count groups))\n                           (= 2 (count (first groups)))\n                           (= 2 (count (second groups))))))\n        one-pair? (fn [cards]\n                    (let [ranks (rankings cards)\n                          groups (sort-by > (vals (group-by identity ranks)))]\n                      (= 2 (count (first groups)))))]\n    (cond (straight-flush? cards) :straight-flush\n          (four-of-a-kind? cards) :four-of-a-kind\n          (full-house? cards) :full-house\n          (flush? cards) :flush\n          (straight? cards) :straight\n          (three-of-a-kind? cards) :three-of-a-kind\n          (two-pair? cards) :two-pair\n          (one-pair? cards) :pair\n          :else :high-card)))","user":"52e657e4e4b09f7907dd1472"},{"problem":"178","code":"(fn [cards]\n  (let [hand (set\n               (map #(hash-map\n                       :suit ((zipmap \"CDHS\" [:club :diamond :heart :spade])\n                              (first %))\n                       :rank ((zipmap \"23456789TJQKA\" (range)) (second %)))\n                 cards))\n        combos (fn c [n s]\n                 (if (= 1 n)\n                   (map (comp set vector) s)\n                   (into #{}\n                     (mapcat #(map conj\n                                (c (dec n) (clojure.set/difference s #{%}))\n                                (repeat %))\n                       s))))\n        comp-eq? (fn [c hand] (apply = (map #(c %) hand)))\n        flush? (partial comp-eq? :suit)\n        of-a-kind (fn [n hand]\n                    (filter (partial comp-eq? :rank) (combos n hand)))\n        full-house? (fn [hand]\n                     (if-let [threes (seq (of-a-kind 3 hand))]\n                       (seq (mapcat #(of-a-kind 2\n                                       (clojure.set/difference hand %))\n                              threes))))\n        straight? (fn [hand]\n                    (let [ranks (sort (map #(:rank %) hand))\n                          check? (fn [r] (= r (range (first r)\n                                                (inc (last r)))))]\n                      (if (= 12 (last ranks))\n                        (or (check? (conj (butlast ranks) -1))\n                            (check? ranks))\n                        (check? ranks))))]\n    (cond\n      (and (flush? hand) (straight? hand)) :straight-flush\n      (seq (of-a-kind 4 hand)) :four-of-a-kind\n      (full-house? hand) :full-house\n      (flush? hand) :flush\n      (straight? hand) :straight\n      (seq (of-a-kind 3 hand)) :three-of-a-kind\n      (= 2 (count (of-a-kind 2 hand))) :two-pair\n      (seq (of-a-kind 2 hand)) :pair\n      :else :high-card)))","user":"53f77b6ae4b0de5c4184855f"},{"problem":"178","code":"(fn __ [cards]\n  (let [ flushcards (apply = (map first cards))\n        arranged-cards (group-by #({\\2 2 \\3 3 \\4 4 \\5 5 \\6 6 \\7 7 \\8 8 \\9 9 \\T 10 \\J 11 \\Q 12 \\K 13 \\A 1} (last %)) cards )]\n   ( {'(1 4) :four-of-a-kind \n      '(2 3) :full-house\n      '(1 2 2) :two-pair\n      '(1 1 1 2) :pair\n      '(1 1 3) :three-of-a-kind\n      '(1 1 1 1 1) \n      ({true ({true :straight-flush false :straight} flushcards) false ({true :flush false :high-card} flushcards)}\n       (apply = (map - (#(if-not(and (= 1 (first %)) (= 13 (last %))) % (concat (rest %) '(14))) (sort (map first arranged-cards))) (range 5))))} \n     (sort (map #(count (second %))arranged-cards)))))","user":"52bbd09ee4b07a9af57922ee"},{"problem":"178","code":"(fn [hand] (let [parsed (map (fn [card]\n                               {:suit (case (first card)\n                                        \\H :heart \\C :club \\D :diamond \\S :spade)\n                                :rank (case (second card)\n                                        \\A 1 \\T 10 \\J 11 \\Q 12 \\K 13 (. Integer parseInt (apply str (rest card))))}) hand)\n                 straight? (fn []\n                             (let [ace-low (sort (map :rank parsed))\n                                   ace-high (sort (map #(if (= 1 (:rank %)) 14 (:rank %)) parsed))]\n                               (or (= ace-low (take 5 (iterate inc (apply min ace-low))))\n                                   (= ace-high (take 5 (iterate inc (apply min ace-high)))))))\n                 same-ranking-counts (map count (vals (group-by :rank parsed)))]\n             (cond (and (every? #(= (:suit %)\n                                    (:suit (first parsed))) parsed)\n                        (straight?)) :straight-flush\n                   (= 4 (reduce max same-ranking-counts)) :four-of-a-kind\n                   (= '(2 3) (sort same-ranking-counts)) :full-house\n                   (every? #(= (:suit %) (:suit (first parsed))) parsed) :flush\n                   (straight?) :straight\n                   (= 3 (reduce max same-ranking-counts)) :three-of-a-kind\n                   (= '(1 2 2) (sort same-ranking-counts)) :two-pair\n                   (= 2 (reduce max same-ranking-counts)) :pair\n                   :else :high-card)))","user":"4e9ff8d0535d7eef3080729c"},{"problem":"178","code":"(fn [hand]\n  (letfn [(card-val [card]\n                    (let [[s r] card\n                          allr (zipmap \"23456789TJQKA\" (range))]\n                      {:suit s, :rank (allr r)}))]\n    (let [cards (map card-val hand)\n          sorted-rank (sort (map :rank cards))\n          straight (->> (partition 2 1 sorted-rank)\n                   \t\t(map #(apply - %))\n                   \t\t(apply = -1))\n          flush (apply = (map :suit cards))\n          card-freq (sort (vals (frequencies sorted-rank)))]\n\n      (cond\n        (and straight flush)\n        :straight-flush\n\n        (or straight\n            (= sorted-rank [0 1 2 3 12]))\n        :straight\n            \n        flush :flush\n             \n        :else\n        (condp = card-freq\n          '(1 4) :four-of-a-kind\n          '(2 3) :full-house\n          '(1 1 3) :three-of-a-kind\n          '(1 2 2) :two-pair\n          '(1 1 1 2) :pair\n          :high-card)))))","user":"54848141e4b0e286459a119e"},{"problem":"178","code":"(fn [v]\n  (let [rank-freqs (->> v (map second) frequencies vals sort)\n        max-of-one-rank (apply max rank-freqs)\n        flush (= [5] (->> v (map first) frequencies vals))\n        rank [\\A \\2 \\3 \\4 \\5 \\6 \\7 \\8 \\9 \\T \\J \\Q \\K \\A]\n        straights (->> (partition 5 1 rank) (map set) set)\n        straight (straights (->> v (map second) set))]\n\n    (cond\n     ;; true suit-freqs\n     (and flush straight) :straight-flush\n     (= max-of-one-rank 4) :four-of-a-kind\n     (= [2 3] rank-freqs) :full-house\n     (= max-of-one-rank 3) :three-of-a-kind\n     flush :flush\n     straight :straight\n     (= 2 (count (filter #(= 2 %) rank-freqs))) :two-pair\n     (= 1 (count (filter #(= 2 %) rank-freqs))) :pair\n     :else :high-card\n     )\n    \n    ))","user":"4ddb696b535d02782fcbe9fa"},{"code":"(fn g[cards]\n  (letfn [(con1 [s]\n                (let [suits {\"D\" :diamond \"H\" :heart \"S\" :spade \"C\" :club}\n                      ranks (merge {\"T\" 9 \"J\" 10 \"Q\" 11 \"K\" 12 \"A\" 13} (apply hash-map (interleave (map str (range 2 10)) (drop 1(range)))))\n                      [suit rank] (map str s)]\n                  {:suit (suits suit) :rank (ranks rank)}))\n          (conv [s] (map con1 s))\n\t\t  (straight-flush? [cs] (if (and (flush? cs) (straight? cs))\n                                  :straight-flush))\n          (four-of-a-kind? [cs] (if (some #(= % 4) (map count (vals (group-by :rank cs))))\n                        :four-of-a-kind))\n          (full-house? [cs] (let [group-sizes (sort (map count (vals (group-by :rank cs))))\n                                  [f l] ((juxt first last) group-sizes)]\n                              (if (and (= f 2) (= l 3))\n                                :full-house)))\n          (flush? [cs] (if (= (count (group-by :suit cs)) 1)\n                         :flush))\n          (straight? [cs] (let [sorted-ranks (sort (map :rank cs))\n                                [f l] ((juxt first last) sorted-ranks)\n                                sorted-ranks (if (and (= f 1) (= l 13)) (cons 0 (butlast sorted-ranks)) sorted-ranks)\n                                [f l] ((juxt first last) sorted-ranks)\n                                sum1 (apply + sorted-ranks)\n                                sum2  (quot (* (+ f l) 5) 2)]\n                            (if (= sum1 sum2)\n                              :straight)))\n          (three-of-a-kind? [cs] (if (some #(= % 3) (map count (vals (group-by :rank cs))))\n                        :three-of-a-kind))\n          (two-pair? [cs] (if (= (count (filter #(= % 2) (map count (vals (group-by :rank cs))))) 2)\n                        :two-pair))\n          (pair? [cs] (if (some #(= % 2) (map count (vals (group-by :rank cs))))\n                        :pair))\n          \n          (high-card? [cs] :high-card)\n          \n          \n                                    \n\t\t  ]\n    (let [xs (conv cards)]\n      (cond\n       (straight-flush? xs) (straight-flush? xs)\n       (four-of-a-kind? xs) (four-of-a-kind? xs)\n       (full-house? xs) (full-house? xs)\n       (flush? xs) (flush? xs)\n       (straight? xs) (straight? xs)\n       (three-of-a-kind? xs) (three-of-a-kind? xs)\n       (two-pair? xs) (two-pair? xs)\n       (pair? xs) (pair? xs)\n       (high-card? xs) (high-card? xs)))))","problem":"178","user":"51efd397e4b0249c592fbdeb"},{"code":"(fn ranking [cards]\n  (let [rank (fn [[_ r]] ((zipmap \"23456789TJQKA\" (range)) r))\n        ace-low-rank (fn [[_ r]] ((zipmap \"A23456789TJQK\" (range)) r))\n        straight-by? (fn [cards rank-fn] \n                       (let [rs (sort (map rank-fn cards))\n                             start (first rs)]\n                         (= rs (range start (+ start 5)))))\n        straight? (or (straight-by? cards rank) (straight-by? cards ace-low-rank))\n        flush? (apply = (map first cards))\n        groups (reverse (sort (map count (vals (group-by rank cards)))))]\n      (cond \n          (and straight? flush?)      :straight-flush\n          (= (first groups) 4)        :four-of-a-kind\n          (and (= (first groups) 3)\n               (= (second groups) 2)) :full-house\n          flush?                      :flush\n          straight?                   :straight\n          (= (first groups) 3)        :three-of-a-kind\n          (and (= (first groups) 2)\n               (= (second groups) 2)) :two-pair\n          (= (first groups) 2)        :pair\n          :else                       :high-card)))","problem":"178","user":"4e52d815535d302ef430da77"},{"problem":"178","code":"(fn [c]\n    (let [f (apply = (map first c))\n          q (vals (frequencies (map second c)))\n          m (map #((fn [r] (if-let [a ({\\T 8 \\J 9 \\Q 10 \\K 11 \\A 12} r)]\n                             a\n                             (- (int r) 50))) (second %)) c)\n          s (and\n              (= (count (set m)) 5)\n              (or\n                (= (- (apply max m) (apply min m)) 4)\n                (= (set m) #{0 1 2 3 12})))]\n      (cond\n        (and s f) :straight-flush\n        (= (apply max q) 4) :four-of-a-kind\n        (= (set q) #{2 3}) :full-house\n        f :flush\n        s :straight\n        (= (apply max q) 3) :three-of-a-kind\n        (= (count q) 3) :two-pair\n        (= (count q) 4) :pair\n        :else :high-card)))","user":"5a2df4a0e4b09cafd31c7f74"},{"code":"#(let [[S R] (apply map list %)\n       s ((set (map set (partition 5 1 \"A23456789TJQKA\"))) (set R))\n       f (apply = S)\n       n (-> R frequencies vals sort)]\n   (cond\n    (and s f)       :straight-flush\n    (= n [1 4    ]) :four-of-a-kind\n    (= n [2 3    ]) :full-house\n    f               :flush\n    s               :straight\n    (= n [1 1 3  ]) :three-of-a-kind\n    (= n [1 2 2  ]) :two-pair\n    (= n [1 1 1 2]) :pair\n    :>              :high-card))","problem":"178","user":"4e7dfab0535db169f9c796f9"},{"problem":"178","code":"(fn analyze-hand\n  [cards]\n  (let [card-order\n        {\"2\" 2\n         \"3\" 3\n         \"4\" 4\n         \"5\" 5\n         \"6\" 6\n         \"7\" 7\n         \"8\" 8\n         \"9\" 9\n         \"T\" 10\n         \"J\" 11\n         \"Q\" 12\n         \"K\" 13}\n\n        is-street?\n        (fn is-street?\n          [card-ranks]\n          (let [a-count    (count (filter #(= \"A\" %) card-ranks))\n                no-a-cards (sort < (map card-order (remove #(= \"A\" %) card-ranks)))\n                in-street? (every? true? (map (fn [[a b]] (= (inc a) b)) (partition 2 1 no-a-cards)))]\n            \n            (if in-street?\n              (cond\n                (= 0 a-count)\n                true\n\n                (= 1 a-count)\n                (or (= (apply min no-a-cards) 2) (= (apply max no-a-cards) 13)))\n              false)))]\n    \n    (let [my-cards         (map (fn [card] [(str (first card)) (str (second card))]) cards)\n          suit-frequencies (sort > (map second (frequencies (map first my-cards))))\n          rank-frequencies (sort > (map second (frequencies (map second my-cards))))\n          street?          (is-street? (map second my-cards))]\n\n      (cond\n        (and (= 5 (first suit-frequencies)) street?)\n        :straight-flush\n\n        (= 4 (first rank-frequencies))\n        :four-of-a-kind\n\n        (and (= 3 (first rank-frequencies)) (= 2 (second rank-frequencies)))\n        :full-house\n\n        (= 5 (first suit-frequencies))\n        :flush\n\n        street?\n        :straight\n\n        (= 3 (first rank-frequencies))\n        :three-of-a-kind\n\n        (and (= 2 (first rank-frequencies)) (= 2 (second rank-frequencies)))\n        :two-pair\n\n        (= 2 (first rank-frequencies))\n        :pair\n\n        :else\n        :high-card))))","user":"5b759ca8e4b047b03b2036d0"},{"problem":"178","code":"(fn best-hand [cards]\n  \"Return the best hand that can be made with the 5 given cards.\"\n  (let [card-to-map (fn [[suit rank]]\n                      \"Convert a card like 'DQ' (Queen of Diamonds) to {:suits :diamond, :rank 10}.\"\n                      (let [suits (zipmap \"SHDC\" [:spade :heart :diamond :club])\n                            ranks (zipmap \"23456789TJQKA\" (range 13))]\n                        {:suit (suits suit) :rank (ranks rank)}))\n        cards (map card-to-map cards)\n        sorted-ranks (fn [cards]\n                       \"Card ranks sorted.\"\n                       (sort (map :rank cards)))\n        flush? (fn [cards]\n                 \"All cards in the same suit.\"\n                 (apply = (map :suit cards)))\n        straight? (fn [cards]\n                    \"All cards in sequence (aces can be high or low, but not both at once).\"\n                    (let [ranks (sorted-ranks cards)\n                          in-sequence? #(= %\n                                           (range (first %) (inc (last %))))]\n                      (if (and (= 12 (last ranks))  ;; We have an Ace, and it can be used as the \"1\" in the suite.\n                               (= 0 (first ranks)))\n                        (in-sequence? (drop-last ranks))\n                        (in-sequence? ranks))))\n        straight-flush? (fn [cards]\n                          \"All cards in the same suit, and in sequence.\"\n                          (and (flush? cards)\n                               (straight? cards)))\n        freq (fn [cards]\n               \"Return the frequencies of cards, sorted in descending order.\"\n               (let [ranks (sorted-ranks cards)]\n                 ;; If there's a pair, then the length of the set is 4.\n                 (reverse (sort-by last (frequencies ranks)))))\n        pair? (fn [cards]\n                \"Two cards have the same rank.\"\n                (let [freq (freq cards)]\n                  (= 2 (last (first freq)))))\n        two-pairs? (fn [cards]\n                     \"Two pairs.\"\n                     (let [freq (freq cards)]\n                       (= 2 (last (first freq))\n                          (last (first (drop 1 freq))))))\n        three-of-a-kind? (fn [cards]\n                           \"Three of the cards have the same rank.\"\n                           (let [freq (freq cards)]\n                             (= 3 (last (first freq)))))\n        four-of-a-kind? (fn [cards]\n                          \"Four of the cards have the same rank.\"\n                          (let [freq (freq cards)]\n                            (= 4 (last (first freq)))))\n        full-house? (fn [cards]\n                      \"Three cards of one rank, the other two of another rank.\"\n                      (let [freq (freq cards)]\n                        (and (= 3 (last (first freq)))\n                             (= 2 (last (first (drop 1 freq)))))))]\n    (cond\n      (straight-flush? cards) :straight-flush\n      (four-of-a-kind? cards) :four-of-a-kind\n      (full-house? cards) :full-house\n      (flush? cards) :flush\n      (straight? cards) :straight\n      (three-of-a-kind? cards) :three-of-a-kind\n      (two-pairs? cards) :two-pair\n      (pair? cards) :pair\n      :else :high-card\n      )))","user":"500900dee4b0144d4f561e42"},{"problem":"178","code":"(fn __ [cards]\n  (letfn [(card-lookup [s]\n            (let [ranks (into {} (map vector (concat (map str (range 2 10)) [\"T\" \"J\" \"Q\" \"K\" \"A\"]) (range 13)))\n                  suits {\"H\" :heart \"D\" :diamond \"C\" :club \"S\" :spade}]\n              (assoc {}\n                :suit (suits ((comp str first) s))\n                :rank (ranks ((comp str second) s)))))\n          (consecutive? [coll]\n            (->> coll sort (partition 2 1) (every? (comp (partial = -1) (partial apply -)))))]\n    (let [ace-high    12\n          ace-low     -1\n          hand        (map card-lookup cards)\n          hand-suits  (distinct (map :suit hand))\n          hand-ranks  (map :rank hand)\n          rank-splits (vals (frequencies hand-ranks))]\n      (letfn [(straight? []\n                (or (consecutive? hand-ranks)\n                    (consecutive? (conj (remove #{ace-high} hand-ranks) ace-low))))\n              (flush? []\n                (= 1 (count hand-suits)))]\n        (cond\n          (and (straight?) (flush?)) :straight-flush\n          (some #{4} rank-splits)    :four-of-a-kind\n          (= [3 2] rank-splits)      :full-house\n          (flush?)                   :flush\n          (straight?)                :straight\n          (some #{3} rank-splits)    :three-of-a-kind\n          (= [2 2 1] rank-splits)    :two-pair\n          (some #{2} rank-splits)    :pair\n          :else                      :high-card)))))","user":"572ea970e4b0cd1946bd0f89"},{"problem":"178","code":"(fn [cards]\n  (let [cs (map (fn [s]\n                  (let [[s r] (vec (seq s))]\n                    {:suit ({\\C :club \\H :heart \\S :spade \\D :diamond} s)\n                     :rank ({\\2 0 \\3 1 \\4 2 \\5 3 \\6 4 \\7 5 \\8 6 \\9 7 \\T 8 \\J 9 \\Q 10 \\K 11 \\A 12} r)}\n                    )) cards)\n        ranks (sort (map :rank cs))\n        suits (map :suit cs)\n        group-ranks (sort (map count (vals (group-by identity ranks))))\n        straight-fn (memoize #(or (= (map (fn [x] (- x (first ranks))) ranks) [0 1 2 3 4]) (= ranks [0 1 2 3 12])))\n        flush-fn (memoize #(= 1 (count (distinct suits))))\n        rules {:straight-flush #(and (straight-fn) (flush-fn))\n               :straight #(and (straight-fn) (not (flush-fn)))\n               :flush  #(and (flush-fn) (not (straight-fn)))\n               :four-of-a-kind #(= [1 4] group-ranks)\n               :full-house #(= [2 3] group-ranks)\n               :three-of-a-kind #(= [1 1 3] group-ranks)\n               :two-pair #(= [1 2 2] group-ranks)\n               :pair #(= [1 1 1 2] group-ranks)\n               }\n        ]\n    (let [hand (first (for [[k f] rules :when (f)] k))]\n      (if hand hand :high-card))))","user":"53b530c6e4b047364c0444bc"},{"problem":"178","code":"(fn myfun [hand]\n  (let [parsed-hand (map #(zipmap [:suit :rank] %) hand)\n        n-of-a-suit (first (max (map count (vals (group-by :suit parsed-hand)))))\n        n-of-a-kind (first (max (map count (vals (group-by :rank parsed-hand)))))\n        full-house? (= '(2 3) (sort (map count (vals (group-by :rank parsed-hand)))))\n        two-pairs? (= '(1 2 2) (sort (map count (vals (group-by :rank parsed-hand)))))\n        flush? (= 5 n-of-a-suit)\n        straight? (contains? (set (map set (partition 5 1 [\\A \\2 \\3 \\4 \\5 \\6 \\7 \\8 \\9 \\T \\J \\Q \\K \\A]))) (set (map :rank parsed-hand)))\n        \n        ]\n    (cond\n      (and straight? flush?) :straight-flush\n      (= 4 n-of-a-kind) :four-of-a-kind\n      full-house? :full-house\n      flush? :flush\n      straight? :straight\n      (= 3 n-of-a-kind) :three-of-a-kind\n      two-pairs? :two-pair\n      (= 2 n-of-a-kind) :pair\n      :else :high-card\n      )))","user":"5143824ae4b0b4fb4ace5f36"},{"problem":"178","code":"(fn [cards]\n  (let [values {\\2 2 \\3 3 \\4 4 \\5 5 \\6 6 \\7 7 \\8 8 \\9 9 \\T 10 \\J 11 \\Q 12 \\K 13 \\A 14}\n        suits (map first cards)\n        ranks (map (comp values second) cards)\n        flush? (= 1 (count (set suits)))\n        is-straight? (fn [ranks] (prn ranks) (and (= 5 (count (set ranks)))\n                                      (= 4 (- (apply max ranks)\n                                              (apply min ranks)))))\n        straight? (or (is-straight? ranks)\n                      (is-straight? (map #(if (= % 14) 1 %) ranks)))\n        count-occurrences (partial reduce #(update-in % [%2] (fnil inc 0)) {})\n        rank-counts (vals (count-occurrences ranks))]\n    (cond\n      (and straight? flush?) :straight-flush\n      (some #{4} rank-counts)  :four-of-a-kind\n      (and (some #{3} rank-counts)\n           (some #{2} rank-counts)) :full-house\n      flush? :flush\n      straight? :straight\n      (some #{3} rank-counts) :three-of-a-kind\n      (= 2 ((count-occurrences rank-counts) 2)) :two-pair\n      (some #{2} rank-counts) :pair\n      :otherwise :high-card)))","user":"4ea1b9e4535d7eef308072b8"},{"code":"(fn best-hand\n  [hand]\n  (let [ranks (map second hand)\n        suits (map first hand)\n        rank-freqs (sort (vals (frequencies ranks)))]\n    (letfn [(flush? [hand]\n              (apply = suits))\n            (straight? [hand]\n              (let [straight-hands (set (map set (partition 5 1 [\\A \\2 \\3 \\4 \\5\n                                                                 \\6 \\7 \\8 \\9 \\T\n                                                                 \\J \\Q \\K \\A])))]\n                (straight-hands (set ranks))))]\n      (cond (= [2 3] rank-freqs) :full-house\n            (= [1 2 2] rank-freqs) :two-pair\n            (= [1 4] rank-freqs) :four-of-a-kind \n            (= [1 1 3] rank-freqs) :three-of-a-kind\n            (= [1 1 1 2] rank-freqs) :pair\n            (and (straight? hand) (flush? hand)) :straight-flush\n            (flush? hand) :flush\n            (straight? hand) :straight\n            :else :high-card))))","problem":"178","user":"4dc0ff08535d020aff1edf84"},{"code":"(fn [cards]\n   (let [rs (fn [s] (let [dict {\\2 0 \\3 1 \\4 2 \\5 3 \n                                \\6 4 \\7 5 \\8 6 \\9 7 \n                                \\T 8 \\J 9 \\Q 10 \\K 11 \n                                \\A 12 \\S :spade \\H :heart \n                                \\D :diamond \\C :club}\n                          [a b] (seq s)]\n                      {:suit (dict a) :rank (dict b)}))\n         ranks (map :rank (map rs cards))\n         suits (map :suit (map rs cards))\n         hand-rank {\n                    :straight-flush 1\n                    :four-of-a-kind 2\n                    :full-house 3\n                    :flush 4\n                    :straight 5\n                    :three-of-a-kind 6\n                    :two-pair 7\n                    :pair 8\n                    :high-card 9\n                    }\n         group-ranks (vals (group-by identity ranks))\n         sorted-rank (sort ranks)\n         most-rank (last (sort-by count group-ranks))\n         ;_ (println most-rank)\n         pair (cond\n                (= 2 (count group-ranks))\n                (if (= 4 (count most-rank))\n                  :four-of-a-kind\n                  :full-house)\n                (= 3 (count group-ranks))\n                (if (= 3 (count most-rank))\n                  :three-of-a-kind\n                  :two-pair)\n                (= 4 (count group-ranks))\n                :pair\n                :else\n                :high-card)\n         one-suit? (apply = suits)\n         inc? (fn [s] \n                (every? #(= 1 %) (map - (rest s) s)))\n         in-seq? (or (inc? sorted-rank) \n                   (and (= (last sorted-rank) 12)\n                        (inc? (cons -1 (butlast sorted-rank)))))\n         suit (cond\n                (and in-seq? one-suit?)\n                :straight-flush\n                one-suit?\n                :flush\n                in-seq?\n                :straight\n                :else\n                :high-card)\n         a (hand-rank pair)\n         b (hand-rank suit)\n         ret (if (< a b) pair suit)]\n     ret))","problem":"178","user":"51944aaae4b0142f60b4aedc"},{"problem":"178","code":"(fn [cards]\n  (let [suit {\\C :club \\S :spade \\D :diamond \\H :heart}\n        rank (into {} (map vector \"23456789TJQKA\" (range)))\n        suits (map #(suit (first %)) cards)\n        ranks (sort (map #(rank (second %)) cards))\n        suit-freq (set (vals (frequencies suits)))\n        rank-freq (vals (frequencies ranks))\n        straight? (let [m (first ranks)]\n                   (or (= ranks (range m (+ m 5)))\n                       (= ranks [0 1 2 3 12])))\n        flush? (= (count (set suits)) 1)]\n    (cond\n      (and straight? flush?) :straight-flush\n      (contains? (set rank-freq) 4) :four-of-a-kind\n      (= (sort rank-freq) [2 3]) :full-house\n      flush? :flush\n      straight? :straight\n      (contains? (set rank-freq) 3) :three-of-a-kind\n      (= (sort rank-freq) [1 2 2]) :two-pair\n      (contains? (set rank-freq) 2) :pair\n      true :high-card)))","user":"58a0fc33e4b02bd94d917ea3"},{"problem":"178","code":"(letfn\n    [(hight-rank [cards]\n       (let [rank (zipmap [\\2 \\3 \\4 \\5 \\6 \\7 \\8 \\9 \\T \\J \\Q \\K \\A] (range))]\n         (map (fn [[color r]] (vector color (rank r))) cards)))\n     (low-rank [cards]\n       (let [rank (zipmap [\\A \\2 \\3 \\4 \\5 \\6 \\7 \\8 \\9 \\T \\J \\Q \\K] (range))]\n         (map (fn [[color r]] (vector color (rank r))) cards)))\n     (max-seq [cards]\n       (->> (sort-by second cards)\n            (map #(vector %2 %1) (range))\n            (partition-by (fn [[[_ r] p]] (- r p)))\n            (apply max-key count)\n            (map (fn [[card]] card))))\n     (max-same-rank [cards]\n       (->> (group-by second cards)\n            (map second)\n            (apply max-key count)))\n     (same-color [cards]\n       (= 1 (count (set (map #(first %) cards)))))\n     (drop-cards [cards dropped]\n       (clojure.set/difference (set cards) (set dropped)))\n     (straight-flush? [cards]\n       (let [maxseq (max-seq cards)]\n         (and (= (count maxseq) 5) (same-color maxseq))))\n     (four-of-a-kind? [cards]\n       (= (count (max-same-rank cards)) 4))\n     (full-house? [cards]\n       (let [maxrank (max-same-rank cards)]\n         (and (= (count maxrank) 3)\n              (= (count (max-same-rank (drop-cards cards maxrank))) 2))))\n     (flush? [cards]\n       (same-color cards))\n     (straight? [cards]\n       (let [maxseq (max-seq cards)]\n         (and (= (count maxseq) 5))))\n     (three-of-a-kind? [cards]\n       (= (count (max-same-rank cards)) 3))\n     (two-pair? [cards]\n       (let [maxrank (max-same-rank cards)]\n         (and (= (count maxrank) 2)\n              (= (count (max-same-rank (drop-cards cards maxrank))) 2))))\n     (pair? [cards]\n       (= (count (max-same-rank cards)) 2))]\n  (fn g [cards]\n    (let [hrank (hight-rank cards)\n          lrank (low-rank cards)]\n      (cond\n        (straight-flush? hrank) :straight-flush\n        (four-of-a-kind? hrank) :four-of-a-kind\n        (full-house? hrank) :full-house\n        (flush? hrank) :flush\n        (or (straight? hrank) (straight? lrank)) :straight\n        (three-of-a-kind? hrank) :three-of-a-kind\n        (two-pair? hrank) :two-pair\n        (pair? hrank) :pair\n        :default :high-card))))","user":"56795deae4b05957ce8c6187"},{"problem":"178","code":"(fn [cards] (let [pcards (map (fn [[a b]] {:suit ({\\H :heart \\S :spade \\D :diamond \\C :club} a) :rank ({\\A [13 0] \\K [12] \\Q [11] \\J [10] \\T [9]} b [(- (int b) 49)])}) cards)\n                           straight (seq (filter identity (map\n                                                           #(reduce (fn [a v] (when (and a (= a (dec v))) v)) %)\n                                                           (partition 5 1 (sort (mapcat :rank pcards))))))\n                           match (fn [key cards n] (filter #(= (count %) n) (vals (group-by key cards))))\n                           bmatch (comp seq match)]\n                       (cond\n                         (and straight (bmatch :suit pcards 5))\n                         :straight-flush\n                         (bmatch :rank pcards 4)\n                         :four-of-a-kind\n                         (and (bmatch :rank pcards 3) (bmatch :rank pcards 2))\n                         :full-house\n                         (bmatch :suit pcards 5)\n                         :flush\n                         straight\n                         :straight\n                         (bmatch :rank pcards 3)\n                         :three-of-a-kind\n                         (= 2 (count (match :rank pcards 2)))\n                         :two-pair\n                         (bmatch :rank pcards 2)\n                         :pair\n                         :else\n                         :high-card)))","user":"5c379636e4b0d62ef62d9f76"},{"code":"(fn [x] (case x [\"HA\" \"D2\" \"H3\" \"C9\" \"DJ\"] :high-card\n          [\"HA\" \"HQ\" \"SJ\" \"DA\" \"HT\"] :pair\n          [\"HA\" \"DA\" \"HQ\" \"SQ\" \"HT\"] :two-pair\n          [\"HA\" \"DA\" \"CA\" \"HJ\" \"HT\"] :three-of-a-kind\n          [\"HA\" \"DK\" \"HQ\" \"HJ\" \"HT\"] :straight\n          [\"HA\" \"H2\" \"S3\" \"D4\" \"C5\"] :straight\n          [\"HA\" \"HK\" \"H2\" \"H4\" \"HT\"] :flush\n          [\"HA\" \"DA\" \"CA\" \"HJ\" \"DJ\"] :full-house\n           [\"HA\" \"DA\" \"CA\" \"SA\" \"DJ\"] :four-of-a-kind\n          [\"HA\" \"HK\" \"HQ\" \"HJ\" \"HT\"] :straight-flush))","problem":"178","user":"51cbc435e4b08d8387cbeddd"},{"code":"(fn [hand]\n    (let [hand (map (fn [[s r]] [s (.indexOf (seq \"23456789TJQKA\") r)]) hand)\n          ranks (map last hand)\n          flush (apply = (map first hand))\n          straight? #(= (sort %) (map (partial + (apply min %)) (range 5)))\n          straight (or (straight? ranks) (straight? (replace {12 -1} ranks)))\n          freq (sort (vals (frequencies ranks)))]\n      (cond\n        (and flush straight) :straight-flush\n        flush :flush\n        straight :straight\n        (= freq [1 4]) :four-of-a-kind\n        (= freq [2 3]) :full-house\n        (= freq [1 1 3]) :three-of-a-kind\n        (= freq [1 2 2]) :two-pair\n        (= freq [1 1 1 2]) :pair\n        :else :high-card)))","problem":"178","user":"50cf21dee4b0e61f11ddcd8b"},{"problem":"178","code":"(fn hands [cards]\n  (letfn [(kinds [hand]\n            (->> hand\n                 (map :rank)\n                 frequencies\n                 vals\n                 (sort-by -)))\n          (flush? [hand]\n            (apply = (map :suit hand)))\n          (sequence? [sorted-ranks]\n            (apply\n              (partial = 1)\n              (map - \n                (rest sorted-ranks) \n                sorted-ranks)))\n          (straight? [hand]\n            (or\n              (->> hand\n                   (map :rank)\n                   sort\n                   sequence?)\n              (->> hand\n                   (map :rank)\n                   (map #(if (= % 14) 1 %))\n                   sort\n                   sequence?)))]\n    (let\n      [hand (map\n              (fn [s]\n                {:suit (first s)\n                 :rank (-> s\n                           second\n                           {\\2 2  \\3 3  \\4 4  \\5 5 \n                            \\6 6  \\7 7  \\8 8  \\9 9 \n                            \\T 10 \\J 11 \\Q 12 \\K 13 \n                            \\A 14})})\n              cards)]\n      (cond\n        (and (flush? hand)\n             (straight? hand))\n          :straight-flush\n        (= 4 (first (kinds hand)))\n          :four-of-a-kind\n        (= [3 2] (kinds hand))\n          :full-house\n        (flush? hand)\n          :flush\n        (straight? hand)\n          :straight\n        (= 3 (first (kinds hand)))\n          :three-of-a-kind\n        (= [2 2 1] (kinds hand))\n          :two-pair\n        (= 2 (first (kinds hand)))\n          :pair\n        :else\n          :high-card))))","user":"521e8227e4b0dd19981ad082"},{"problem":"178","code":"(fn p [cs]\n  (let [\n        q (fn [s]\n            (let [mark (first (seq s))\n                  n (second (seq s))]\n              {:suit (cond (= mark \\D) :diamond\n                           (= mark \\H) :heart\n                           (= mark \\S) :spade\n                           (= mark \\C) :club)\n               :rank (cond (= n \\T)  8\n                           (= n \\J)  9\n                           (= n \\Q) 10\n                           (= n \\K) 11\n                           (= n \\A) 12\n                           :else (- (- (int n) (int \\0)) 2))\n               }))\n        cards (map q cs)\n        is-flush (apply = (map :suit cards))\n        nums (sort-by first (map (fn [[k v]] [k (count v)]) (group-by :rank cards)))\n        is-straight (not= [14 14]\n                          (reduce\n                            (fn [[x _] [y z]] (if (or (= (inc x) y)\n                                                      (and (= x 3) (= y 12)))\n                                                      [y z] [14 14]))\n                            (first nums)\n                            (rest nums)))\n        ]\n    (cond (and is-flush is-straight)\n          :straight-flush\n          (= 4 (second (last (sort-by :second nums))))\n          :four-of-a-kind\n          (and\n            (= 3 (second (last (sort-by :second nums))))\n            (= 2 (second (last (drop-last (sort-by :second nums))))))\n          :full-house\n          is-flush\n          :flush\n          is-straight\n          :straight\n          (= 3 (second (last (sort-by :second nums))))\n          :three-of-a-kind\n          (and\n            (= 2 (second (last (sort-by :second nums))))\n            (= 2 (second (last (drop-last (sort-by :second nums))))))\n          :two-pair\n          (= 2 (second (last (sort-by :second nums))))\n          :pair\n          :else\n          :high-card\n          )))","user":"53664e3be4b0243289761e74"},{"problem":"178","code":"(fn best-hand [hand]\n  (let [rank1 (fn [[_ rank_]] (.indexOf [\\2 \\3 \\4 \\5 \\6 \\7 \\8 \\9 \\T \\J \\Q \\K \\A] rank_))\n        rank2 (fn [[_ rank_]] (.indexOf [\\A \\2 \\3 \\4 \\5 \\6 \\7 \\8 \\9 \\T \\J \\Q \\K] rank_))\n        suit (fn [[suit_ _]] suit_)\n        same? (fn [f cards] (->>\n                              cards\n                              (map f)\n                              (into #{})\n                              count\n                              (= 1)))\n        sequence? (fn [cards] (let [sorted-rank (fn [rank-f] (->>\n                                                               cards\n                                                               (map rank-f)\n                                                               sort))\n                                    is-seq? (fn [sorted-rank]\n                                              (->> \n                                                (range)\n                                                (map - sorted-rank)\n                                                (into #{})\n                                                count\n                                                (= 1)))\n                                              ]\n                                (or (is-seq? (sorted-rank rank1))\n                                    (is-seq? (sorted-rank rank2)))))\n        same-x-count (fn [f x cards]\n                       (->>\n                         cards\n                         (map f)\n                         (group-by identity)\n                         (map second)\n                         (map count)\n                         (filter (partial = x))\n                         count))\n        same-x (fn [f x cards] (< 0 (same-x-count f x cards)))]\n    (cond (and (same? suit hand) (sequence? hand)) :straight-flush\n          (same-x rank1 4 hand) :four-of-a-kind\n          (and (same-x rank1 2 hand) (same-x rank1 3 hand)) :full-house\n          (same? suit hand) :flush\n          (sequence? hand) :straight\n          (same-x rank1 3 hand) :three-of-a-kind\n          (= 2 (same-x-count rank1 2 hand)) :two-pair\n          (same-x rank1 2 hand) :pair\n          :else :high-card)))","user":"53c38b8ce4b00fb29b22127b"},{"problem":"178","code":"(fn [raw-cards]\r\n  (let [\r\n    recognize (fn [[suit rank]]\r\n      (let [\r\n        suits {\\S :spade, \\H :heart, \\D :diamond, \\C :club}\r\n        ranks {\\T 8, \\J 9, \\Q 10, \\K 11, \\A 12}]\r\n        {:suit (suits suit)\r\n         :rank (ranks rank (- (int rank) 50))}))\r\n    in-sequence? (fn [ranks]\r\n      (let [\r\n        rank-order (sort ranks)\r\n        lowest (first rank-order)\r\n        highest (last rank-order)]\r\n        (= rank-order (range lowest (inc highest)))))\r\n    cards (map recognize raw-cards)\r\n    ranks (map :rank cards)\r\n    ranks-low-ace (map #(if (= % 12) 0 (inc %)) ranks)\r\n    suit-freq (frequencies (map :suit cards))\r\n    rank-freq (frequencies ranks)\r\n    hands [\r\n      :straight-flush (fn []\r\n        (and\r\n          (= 1 (count suit-freq))\r\n          (in-sequence? ranks)))\r\n      :four-of-a-kind (fn []\r\n        (= 4 (last (sort (vals rank-freq)))))\r\n      :full-house (fn []\r\n        (= [2 3] (sort (vals rank-freq))))\r\n      :flush (fn []\r\n        (= 1 (count suit-freq)))\r\n      :straight (fn []\r\n        (or\r\n          (in-sequence? ranks)\r\n          (in-sequence? ranks-low-ace)))\r\n      :three-of-a-kind (fn []\r\n        (= 3 (last (sort (vals rank-freq)))))\r\n      :two-pair (fn []\r\n        (= [2 2] (take-last 2 (sort (vals rank-freq)))))\r\n      :pair (fn []\r\n        (= 2 (last (sort (vals rank-freq)))))]]\r\n    (loop [[hand pred & tail] hands]\r\n      (if (nil? hand)\r\n        :high-card\r\n      (if (pred)\r\n        hand\r\n        (recur tail))))))","user":"555bd27ae4b0b056612e2244"},{"code":"(fn [cards]\n  (let [flush? (apply = (map first cards))\n        ranks (map (zipmap \"23456789TJQKA\" (range 2 15)) (map last cards))\n        freqs (frequencies (vals (frequencies ranks)))\n        run? #(= (range (first %) (inc (last %))) %)\n        straight? (or (run? (sort ranks)) (run? (sort (replace {14 1} ranks))))]\n    (cond\n      (and straight? flush?)  :straight-flush\n      (= {4 1 1 1} freqs)     :four-of-a-kind\n      (= {3 1 2 1} freqs)     :full-house\n      flush?                  :flush\n      straight?               :straight\n      (= {3 1 1 2} freqs)     :three-of-a-kind\n      (= {2 2 1 1} freqs)     :two-pair\n      (= {2 1 1 3} freqs)     :pair\n      :else                   :high-card)))","problem":"178","user":"5164867fe4b003cf19fdde3e"},{"problem":"178","code":"(fn best [xs]\n  (let [sm {\\S :spade, \\H :heart, \\D :diamond, \\C :club}\n        rv [\\2 \\3 \\4 \\5 \\6 \\7 \\8 \\9 \\T \\J \\Q \\K \\A]\n        to-card (fn [[s r]] {:suit (sm s)\n                             :rank (.indexOf rv r)})\n        cards (sort-by :rank (map to-card xs))\n        ranks (vec (map :rank cards))\n        groups (group-by identity ranks)\n        ;; Fns\n        flush? #(apply = (map :suit cards))\n        straight? #(let [s (ranks 0) l (ranks 4)]\n                    (or (= ranks (take 5 (iterate inc s)))\n                        (if (= 12 l) (= ranks [0 1 2 3 12]) false)))\n        three-in-group? (fn [] (some #(= 3 (count (% 1))) groups))]\n    (cond\n      (flush?) (if (straight?) :straight-flush :flush)\n      (straight?) :straight\n      :else (case (count groups)\n              4 :pair\n              3 (if (three-in-group?) :three-of-a-kind :two-pair)\n              2 (if (three-in-group?) :full-house      :four-of-a-kind)\n              :high-card))))","user":"5ba15075e4b0a20761a2339e"},{"problem":"178","code":"(fn best-hand [s]\n\n  (letfn [(get-sorted-ranks [s]\n            (let [ranks {\"2\" 0 \"3\" 1 \"4\" 2 \"5\" 3 \"6\" 4 \"7\" 5 \"8\" 6 \"9\" 7 \"T\" 8 \"J\" 9 \"Q\" 10 \"K\" 11 \"A\" 12}] \n              (let [str-ranks (map #(subs % 1 2) s)\n                    ranks (map #(get ranks %) str-ranks)]\n                (sort ranks)\n                ))\n            )\n          \n          (cards-in-sequence [s]\n            (let [sr (get-sorted-ranks s) \n                  offset-sr (conj (vec (rest sr)) (first sr))\n                  comparisons (partition 2 (interleave sr offset-sr))] \n              (every? #(= (inc (first %)) (second %)) (butlast comparisons)\n                      )))\n\n          (is-straight [s]\n            (or (= 5 (count (re-seq #\"[A2345]\" (apply str s))))\n                (cards-in-sequence s))\n            )\n\n          (is-flush [s]\n            (let [hand-suits (map #(first %) s)\n                  same-suits (some #(= (second %) 5) (frequencies hand-suits))]\n              same-suits\n              )\n            )\n\n          (is-straight-flush [s]\n            (and (is-straight s) (is-flush s))\n            )\n\n          (is-four-of-a-kind [s]\n            (let [hand-ranks (map #(second %) s)\n                  same-ranks (some #(= (second %) 4) (frequencies hand-ranks))]\n              same-ranks\n              )\n            )\n\n          (has-three-of-a-kind [s]\n            (let [hand-ranks (map #(second %) s)\n                  same-ranks (some #(= (second %) 3) (frequencies hand-ranks))]\n              same-ranks\n              )\n            )\n          (has-a-pair [s]\n            (let [hand-ranks (map #(second %) s)\n                  same-ranks (some #(= (second %) 2) (frequencies hand-ranks))]\n              same-ranks\n              )\n            )\n\n          (is-full-house [s]\n            (and (has-three-of-a-kind s) (has-a-pair s))\n            )\n\n          (is-two-pair [s]\n            (let [hand-ranks (map #(second %) s)\n                  num-pairs (count (filter #(= (second %) 2) (frequencies hand-ranks)))]\n              (= num-pairs 2)\n              )\n            )\n\n          (is-pair [s]\n            (and (has-a-pair s) (not (is-two-pair s)))\n            )\n          ]\n\n    (cond \n      (is-straight-flush s)   :straight-flush\n      (is-four-of-a-kind s)   :four-of-a-kind\n      (is-full-house s)       :full-house\n      (is-flush s)            :flush\n      (is-straight s)         :straight\n      (has-three-of-a-kind s) :three-of-a-kind\n      (is-two-pair s)         :two-pair\n      (is-pair s)             :pair\n      :else                   :high-card\n      ))\n)","user":"5ff676a9e4b06df49cee1497"},{"problem":"178","code":"(fn aph [hand]\n  (letfn [\n    (extract-suit [hand]\n      (map #(first (seq %)) hand))\n    (extract-rank [hand]\n      (map #(second (seq %)) hand))\n    (convert-rank-ace-highest [rank]\n      (map \n        (fn [r]\n          (cond\n            (= \\T r) 10\n            (= \\J r) 11\n            (= \\Q r) 12\n            (= \\K r) 13\n            (= \\A r) 14\n            :else (Integer/parseInt (str r))))\n        rank))\n    (convert-rank-ace-lowest [rank]\n      (map \n        (fn [r]\n          (cond\n            (= \\T r) 10\n            (= \\J r) 11\n            (= \\Q r) 12\n            (= \\K r) 13\n            (= \\A r) 1\n            :else (Integer/parseInt (str r))))\n        rank))\n    (is-in-order? [rank]\n      (let [temp (set\n                    (map \n                      (fn [t] (- (second t) (first t)))\n                      (partition 2 (-> (map #(repeat 2 %) rank) flatten rest drop-last))))]\n        (and (= 1 (count temp)) (= 1 (Math/abs (first temp))))))\n    (is-straight-flush? [hand]\n      (let [suit (extract-suit hand)\n            rank (convert-rank-ace-highest (extract-rank hand))]\n        (and \n          (is-in-order? rank)\n          (= 1 (count (group-by identity suit)))\n          (or (= 14 (first rank)) (= 14 (last rank))))))\n    (is-four-of-kind? [hand]\n      (let [rank (extract-rank hand)\n            grouped-rank (group-by identity rank)]\n        (and\n          (= 2 (count grouped-rank)) \n          (or \n            (= 4 (-> grouped-rank vals first count)) \n            (= 4 (-> grouped-rank vals second count))))))\n    (is-full-house? [hand]\n      (let [rank (extract-rank hand)\n            grouped-rank (group-by identity rank)\n            ordered-rank (sort-by count (vals grouped-rank))]\n      (and \n        (= 2 (count ordered-rank))\n        (= 2 (-> ordered-rank first count))\n        (= 3 (-> ordered-rank second count)))))\n    (is-flush? [hand]\n      (let [suit (extract-suit hand)]\n        (= 1 (count (group-by identity suit)))))\n    (is-straight? [hand]\n      (let [extracted-rank   (extract-rank hand)\n            rank-ace-highest (convert-rank-ace-highest extracted-rank)\n            rank-ace-lowest  (convert-rank-ace-lowest  extracted-rank)]\n        (or (is-in-order? rank-ace-highest) (is-in-order? rank-ace-lowest))))\n    (is-three-of-kind? [hand]\n      (let [rank (extract-rank hand)\n            grouped-rank (group-by identity rank)\n            ordered-rank (vec (sort-by count (vals grouped-rank)))]\n        (and\n          (= 3 (count ordered-rank))\n          (= 3 (count (ordered-rank 2))))))\n    (is-two-pair? [hand]\n      (let [rank (extract-rank hand)\n            grouped-rank (group-by identity rank)\n            ordered-rank (vec (sort-by count (vals grouped-rank)))]\n        (and\n          (= 3 (count ordered-rank))\n          (= 2 (count (ordered-rank 1)))\n          (= 2 (count (ordered-rank 2))))))\n    (is-pair? [hand]\n      (let [rank (extract-rank hand)\n            grouped-rank (group-by identity rank)\n            ordered-rank (sort-by count (vals grouped-rank))]\n        (and\n          (= 4 (count ordered-rank))\n          (= 2 (count (last ordered-rank))))))]\n    (cond\n      (is-straight-flush? hand) :straight-flush\n      (is-four-of-kind?   hand) :four-of-a-kind\n      (is-full-house?     hand) :full-house\n      (is-flush?          hand) :flush\n      (is-straight?       hand) :straight\n      (is-three-of-kind?  hand) :three-of-a-kind\n      (is-two-pair?       hand) :two-pair\n      (is-pair?           hand) :pair\n      :else :high-card)))","user":"52cf084ce4b07d0d72b27399"},{"problem":"178","code":"(let [get-suit {\\S :spade, \\C :club, \\D :diamond, \\H :heart}\n      zero-code (int \\0)\n      get-number-rank (into {} (for [n (range 2 10)]\n                                 [(char (+ n zero-code)) n]))\n      get-face-card-rank {\\T 10, \\J 11, \\Q 12, \\K 13, \\A 14}\n      get-rank (merge get-number-rank get-face-card-rank)\n      recognize-card (fn [[suit rank]]\n                       {:suit (get-suit suit)\n                        :rank (get-rank rank)})\n      straight? (fn [hand]\n                  (let [ranks (sort (map :rank hand))]\n                    (or (= ranks [2 3 4 5 14])\n                        (and (apply < ranks)\n                             (= (- (last ranks) (first ranks))\n                                4)))))\n      flush? (fn [hand]\n               (apply = (map :suit hand)))\n      freqs-of-freqs (fn [hand]\n                       (->> hand\n                            (map :rank)\n                            (frequencies)\n                            (vals)\n                            (frequencies)))]\n  (fn [representation]\n    (let [hand (map recognize-card representation)\n          straight (straight? hand)\n          flush (flush? hand)\n          straight-flush (and straight flush)]\n      (cond\n        straight-flush :straight-flush\n        straight       :straight\n        flush          :flush\n        :else\n        (condp = (freqs-of-freqs hand)\n          {4 1, 1 1}   :four-of-a-kind\n          {3 1, 2 1}   :full-house\n          {3 1, 1 2}   :three-of-a-kind\n          {2 2, 1 1}   :two-pair\n          {2 1, 1 3}   :pair\n          :high-card)))))","user":"5424c523e4b01498b1a71b03"},{"problem":"178","code":"(fn best-hand [s]\n  (letfn\n      [(card-to-hash [c]\n         (let\n             [char1 (first c)\n              char2 (second c)\n              suit\n              (cond\n                (= char1 \\H) :heart\n                (= char1 \\S) :spade\n                (= char1 \\D) :diamond\n                (= char1 \\C) :club)\n              rank\n              (cond\n                (= char2 \\A) 12\n                (= char2 \\K) 11\n                (= char2 \\Q) 10\n                (= char2 \\J) 9\n                (= char2 \\T) 8\n                :else (- (int char2) 50))]\n           {:suit suit :rank rank}))\n       (straight [ranks]\n         (letfn \n             [(diffs [s]\n                (map #(- (nth s (inc %)) (nth s %)) (range (dec (count s)))))]\n           (let [s (sort ranks)]\n             (or\n              (apply = 1 (diffs s))\n              (and (= 12 (last s)) (= 0 (first s)) (apply = 1 (diffs (butlast s))))))))]\n    (let [h (map card-to-hash s)\n          suits (frequencies (map :suit h))\n          ranks (frequencies (map :rank h))\n          rank-vals (set (vals ranks))\n          flush (= 1 (count (keys suits)))\n          str8 (straight (keys ranks))]\n      ;(println suits ranks rank-vals \"flush:\" flush \"str8:\" str8)\n      (cond\n        (and flush str8) :straight-flush\n        (contains? rank-vals 4) :four-of-a-kind\n        (= #{3 2} rank-vals) :full-house\n        flush :flush\n        str8 :straight\n        (contains? rank-vals 3) :three-of-a-kind\n        (= 2 (count (filter #(= 2 (get ranks %)) (keys ranks)))) :two-pair\n        (contains? rank-vals 2) :pair\n        :else :high-card))))","user":"54e3df6ae4b024c67c0cf7e3"},{"problem":"178","code":"#(let [rks (map second %)\n       fs (sort (vals (frequencies rks)))\n       s ((set (map set (partition 5 1 \"A23456789TJQKA\"))) \n          (set rks))\n       f (= 1 (count (set (map first %))))\n       res (condp = fs [1 4] :four-of-a-kind\n                       [2 3] :full-house\n                       [1 1 3] :three-of-a-kind\n                       [1 2 2] :two-pair\n                       [1 1 1 2] :pair\n                       :high-card)]\n   (cond (and s f) :straight-flush\n         (= 2 (count fs)) res\n         s :straight\n         f :flush\n         :else res))","user":"575ddfd1e4b02ea11479938d"},{"problem":"178","code":"(fn best-hand [cards]\n  (letfn [(rank-map [cards]\n            ;; Return map of {rank, occurence_count} for occurence of ranks in the given cards.\n            ;; (rank-map [\"HA\" \"DA\" \"CA\" \"HJ\" \"DQ\"]) => {\\A 3, \\J 1, \\Q 1}\n            (->> cards\n                 (map second)\n                 frequencies))\n\n          (has-rank-count? [rank-count cards]\n            ;; Check whether expected number of cards with same rank exist in the given cards\n            (->> (rank-map cards)\n                 (filter #(= (second %) rank-count))\n                 empty?\n                 not))\n\n          (has-two-pairs? [cards]\n            ;; Check whether there are two paits in the given cards\n            (->> (rank-map cards)\n                 (filter #(= (second %) 2))\n                 count\n                 (= 2)))\n\n          (rank-weight [rank]\n            ;; Return rank weight.\n            (cond (= rank \\2) 0\n                  (= rank \\3) 1\n                  (= rank \\4) 2\n                  (= rank \\5) 3\n                  (= rank \\6) 4\n                  (= rank \\7) 5\n                  (= rank \\8) 6\n                  (= rank \\9) 7\n                  (= rank \\T) 8\n                  (= rank \\J) 9\n                  (= rank \\Q) 10\n                  (= rank \\K) 11\n                  (= rank \\A) 12))\n\n          (card-sequence? [cards]\n            ;; Check that 5 cards are sequence. Note that A and 2 are also sequence.\n            (let [card-weights (->> cards\n                                    (map #(->> % second rank-weight))\n                                    sort)\n                  card-sequence-count (->> card-weights\n                                           (partition 2 1)\n                                           (map (fn [[first second]] (- second first)))\n                                           (filter #(= % 1))\n                                           count)\n                  additional-count (if (and (= (first card-weights) 0)\n                                            (= (last card-weights) 12))\n                                     1\n                                     0)]\n              (= (+ card-sequence-count additional-count)\n                 4)))\n\n          (same-suit? [cards]\n            (->> cards\n                 (map first)\n                 frequencies\n                 count\n                 (#(= 1 %))))]\n\n    (cond (and (card-sequence? cards)\n               (same-suit? cards)) :straight-flush\n          (has-rank-count? 4 cards) :four-of-a-kind\n          (and (has-rank-count? 3 cards )\n               (has-rank-count? 2 cards)) :full-house\n          (same-suit? cards) :flush\n          (card-sequence? cards) :straight\n          (has-rank-count? 3 cards) :three-of-a-kind\n          (has-two-pairs? cards) :two-pair\n          (has-rank-count? 2 cards) :pair\n          :else :high-card)))","user":"55586905e4b0deb715856e2b"},{"code":"(fn [h]\n  (let [flush (apply = (map first h))\n        ranks1 {\\A 1 \\2 2 \\3 3 \\4 4 \\5 5 \\6 6 \\7 7 \\8 8 \\9 9 \\T 10 \\J 11 \\Q 12 \\K 13}\n        ranks2 (assoc ranks1 \\A 14)\n        rank1 (fn [c] (ranks1 (second c)))\n        rank2 (fn [c] (ranks2 (second c)))\n        ranked1 (sort (map rank1 h))\n        ranked2 (sort (map rank2 h))\n        straight (or (apply = (map - ranked1 (range)))\n                    (apply = (map - ranked2 (range))))\n        grp-by-rank (->> h\n                      (map second)\n                      (group-by identity)\n                      (map second)\n                      (map count))\n        ]\n    (cond\n      (and straight flush) :straight-flush\n      (= 4 (first grp-by-rank)) :four-of-a-kind\n      (and (= 3 (first grp-by-rank))\n           (= 2 (second grp-by-rank))) :full-house\n      flush :flush\n      straight :straight\n      (= 3 (first grp-by-rank)) :three-of-a-kind\n      (and (= 2 (first grp-by-rank))\n           (= 2 (second grp-by-rank))) :two-pair\n      (= 2 (first grp-by-rank)) :pair\n      :default :high-card)))","problem":"178","user":"52a88c4de4b0c58976d9ac30"},{"problem":"178","code":"(fn best-hand [cards]\n  (let [straight? ((set (map set (partition 5 1 \"A23456789TJQKA\"))) (set (map second cards)))\n        flush? (->> cards (map first) set count (= 1))\n        rf (->> (frequencies (map second cards)) vals frequencies)]\n    (cond\n      (and flush? straight?) :straight-flush\n      (rf 4)                 :four-of-a-kind\n      (and (rf 3) (rf 2))    :full-house\n      flush?                 :flush\n      straight?              :straight\n      (rf 3)                 :three-of-a-kind\n      (= 2 (rf 2))           :two-pair\n      (rf 2)                 :pair\n      :else                  :high-card)))","user":"5383668ee4b06839e8705edd"},{"problem":"178","code":"(fn besthand [xs]\n  \n(letfn[\n     (toint [c]\n   (cond (= c \\A) 14\n        (= c \\J) 11\n        (= c \\Q) 12\n        (= c \\K) 13\n        (= c \\T) 10\n        :else (Character/digit c 10))\n)\n\n(decom [xs]\n   [(sort (map first xs))\n          (sort (map toint  (map second xs)))\n          ]\n)\n\n\n(sflash [xs]\n   (let [suits (first ( decom xs))\n         ranks (second (decom xs))\n         ]\n        (if (and (every? true? (map #(= (first suits) %) suits))\n                    (= 4 (- (last ranks) (first ranks)))\n                  (= 3 (- (last ranks) (second ranks)))\n                  (= 1 (- (nth ranks 3) (nth ranks 2)))\n                  (= 1 (- (nth ranks 4) (nth ranks 3)))\n                 )\n\n              true\n             false\n        )\n\n     )\n  )\n\n (four [xs]\n  (let [ ranks (second (decom xs))\n         f4 (drop-last ranks)\n         l4 (drop 1 ranks)\n        ]\n      (if  (or (= 0 (- (last f4) (first f4)))\n               (= 0 (- (last l4) (first l4))))\n        true\n        false\n        )\n    ))\n\n(house [xs]\n   (let [ranks (second (decom xs))\n        f23_2 (take 2 ranks)  f23_3 (drop 2 ranks)\n        f32_3 (take 3 ranks)  f32_2 (drop 3 ranks)\n         ]\n     (if (or (and (= (first f23_2) (second f23_2))\n                  (= 0 (- (last f23_3) (first f23_3))) )\n             (and (= (first f32_2) (second f32_2))\n                  (= 0 (- (last f32_3) (first f32_3))) )\n             )\n          true\n          false\n       )\n  )\n)\n      \n (nflush [xs]\n     (let [suits (first (decom xs))]\n        (if (= (first suits) (last suits))\n         true\n         false\n          )\n\n       )\n  )\n\n(straight [xs]\n      (let [ranks (second (decom xs))]\n         (cond (and (= 4 (- (last ranks) (first ranks)) )\n                    (= 1 (- (second ranks) (first ranks)))\n                    (= 1 (- (nth ranks 2) (nth ranks 1)))\n                    (= 1 (- (nth ranks 4) (nth ranks 3)))\n               )\n                true\n               (and (= 14 (last ranks))\n                    (= 5 (nth ranks 3))\n                    (= 4 (nth ranks 2))\n                    (= 3 (second ranks))\n                    (= 2 (first ranks)) )\n                  true\n               :else false\n\n        )\n  )\n)\n\n (three [xs]\n  (let [ranks (second (decom xs))]\n     (if (or (= (first ranks) (nth ranks 2))\n             (= (last ranks ) (nth ranks 2)) )\n         true\n       false\n    )\n  )\n)\n\n\n(pairs2 [xs ]\n    (let [ranks (second (decom xs))]\n   (if (or (and (= (first ranks) (second ranks))\n                (= (nth ranks 2) (nth ranks 3)))\n           (and (= (first ranks) (second ranks))\n                (= (nth ranks 3) (nth ranks 4)))\n           (and (= (nth ranks 1) (nth ranks 2))\n                (= (nth ranks 3) (nth ranks 4)))\n\n           )\n         true\n         false\n     )\n   )\n  )\n\n(pair [xs]\n  (let [ranks (second (decom xs))]\n     (if (or (= (nth ranks 0) (nth ranks 1))\n             (= (nth ranks 1) (nth ranks 2))\n             (= (nth ranks 2) (nth ranks 3))\n             (= (nth ranks 4) (nth ranks 3))\n                )\n         true\n         false\n     )\n))\n  ]\n  \n  \n  (cond (sflash xs)  :straight-flush\n        (four xs)  :four-of-a-kind\n        (house xs) :full-house\n        (nflush xs) :flush\n        (straight xs) :straight\n        (three xs) :three-of-a-kind\n        (pairs2 xs) :two-pair\n        (pair xs) :pair\n        :else :high-card\n   )\n)\n  )","user":"59ff9424e4b01bb0ae8afd24"},{"problem":"178","code":"(let [suits-map {\"S\" :spade, \"H\" :heart\n                 \"D\" :diamond, \"C\" :club}\n      rank-map {\"2\" 0, \"3\" 1, \"4\" 2, \"5\" 3, \"6\" 4, \"7\" 5, \"8\" 6,\n                \"9\" 7, \"T\" 8, \"J\" 9, \"Q\" 10, \"K\" 11, \"A\" 12}]\n  (letfn [(recognize-card [[suit rank]]\n            {:suit (suits-map (str suit))\n             :rank (rank-map (str rank))})\n          (combinations\n            ([coll] (combinations () coll))\n            ([path remaining]\n             (if (empty? remaining)\n               (list (reverse path))\n               (apply concat\n                (map #(combinations (cons % path) (disj remaining %))\n                     remaining)))))\n          (rank-frequencies [coll]\n            (->> coll\n                 (map :rank)\n                 (partition-by identity)\n                 (reduce #(merge-with max %1 {(first %2) (count %2)}) {})))\n          (pair? [coll]\n            (some (partial = 2) (vals (rank-frequencies coll))))\n          (three-of-a-kind? [coll]\n            (some (partial = 3) (vals (rank-frequencies coll))))\n          (four-of-a-kind? [coll]\n            (some (partial = 4) (vals (rank-frequencies coll))))\n          (two-pair? [coll]\n            (->> (vals (rank-frequencies coll))\n                 (filter (partial = 2))\n                 count\n                 (= 2)))\n          (full-house? [coll]\n            (and (pair? coll)\n                 (three-of-a-kind? coll)))\n          (flush? [coll]\n            (->> (vals suits-map)\n                 (map (fn [suit]\n                        (every? #(= (:suit %) suit) coll)))\n                 (some identity)))\n          (straight? [coll]\n            (let [[fst & rst] (map :rank coll)\n                  init (if (= fst 12) -1 fst)]\n              (reduce #(if (= %1 (dec %2)) %2 false) init rst)))\n          (straight-flush? [coll]\n            (and (straight? coll)\n                 (flush? coll)))]\n    (let [hands {:straight-flush {:f straight-flush?, :order 1}\n                 :four-of-a-kind {:f four-of-a-kind?, :order 2}\n                 :full-house {:f full-house?, :order 3}\n                 :flush {:f flush?, :order 4}\n                 :straight {:f straight?, :order 5}\n                 :three-of-a-kind {:f three-of-a-kind?, :order 6}\n                 :two-pair {:f two-pair?, :order 7}\n                 :pair {:f pair?, :order 8}}]\n      (letfn [(classify-hand [coll]\n                (->> hands\n                     (filter (fn [[_ {f :f}]] (f coll)))\n                     first))\n              (get-best [acc el]\n                (if (not (and acc el))\n                  (or acc el)\n                  (if (< (:order (second acc)) (:order (second el)))\n                    acc\n                    el)))]\n        (fn [coll]\n          (let [cards (set (map recognize-card coll))\n                hands (combinations cards)\n                best (->> (map classify-hand hands)\n                          (reduce get-best))]\n            (if best (first best) :high-card)))))))","user":"594783bee4b07ddc2dafada1"},{"problem":"178","code":"(fn [h]\n  (let [[s r] (apply mapv vector h)\n        S (apply = s)\n        f frequencies\n        N (vals (f r))\n        M (apply max N)\n        R (some #(= (set r) %) (map set (partition 5 1 \"A23456789TJQKA\")))]\n    (cond\n     (and R S) :straight-flush\n     (= 4 M) :four-of-a-kind\n     (= {3 1 2 1} (f N)) :full-house\n     S :flush\n     R :straight\n     (= 3 M) :three-of-a-kind\n     (= {2 2 1 1} (f N)) :two-pair\n     (= 2 M) :pair\n     :else :high-card)))","user":"577202d2e4b0979f896515c0"},{"problem":"178","code":"(letfn\n[\n(read-card\n  [x]\n  (let [suits {\\D :diamond \\H :heart \\S :spade \\C :club}\n        ranks {\\T 9, \\J 10, \\Q 11, \\K 12}]\n    (let [l (first x)\n          r (second x)]\n          {:suit (suits l), :ranks (if (= \\A r) [1 13] [(or (ranks r) (- (int r) (int \\0)))])}\n          )))\n(expand-ranks\n  [cards]\n  (loop [so-far [[]]\n         now (first cards)\n         todo (rest cards)]\n    (if (nil? now)\n      so-far\n      (recur\n        (mapcat (fn [cs] (map #(conj cs {:suit (:suit now) :rank %}) (:ranks now))) so-far)\n        (first todo)\n        (rest todo)))))\n(consecutive\n  [f xs]\n  (loop [now (first xs)\n         todo (rest xs)]\n    (cond \n      (empty? todo) true\n      (= (inc (f now)) (f (first todo))) (recur (first todo) (rest todo))\n      :else false)))\n    \n(has-straight\n  [cards]\n  (some #(consecutive :rank (sort-by :rank %)) (expand-ranks cards)))\n\n(has-flush\n  [cards]\n  (= 1 (count (group-by :suit cards))))\n\n(has-n\n  ([cards n times]\n    (= times (count (filter #(= n (count (val %))) (group-by :ranks cards)))))\n  ([cards n]\n    (has-n cards n 1)))\n\n(hand\n  [cards]\n  (cond\n    (and (has-flush cards) (has-straight cards)) :straight-flush\n    (has-n cards 4) :four-of-a-kind\n    (and (has-n cards 3) (has-n cards 2)) :full-house\n    (has-flush cards) :flush\n    (has-straight cards) :straight\n    (has-n cards 3) :three-of-a-kind\n    (has-n cards 2 2)  :two-pair\n    (has-n cards 2) :pair\n    :else :high-card))\n]\n(fn [ss] (hand (map read-card ss))))","user":"57717915e4b0979f896515b3"},{"problem":"178","code":";; http://www.4clojure.com/problem/178\n(fn find-best-hand\n  [hand]\n  (let [suit-map {\\S :spade \\H :heart \\D :diamond \\C :club}\n        rank-list [\\2 \\3 \\4 \\5 \\6 \\7 \\8 \\9 \\T \\J \\Q \\K \\A]\n        parse-card (fn [s] {:suit (suit-map (first s)) :rank (.indexOf rank-list (second s))})\n        hand (set (map #(parse-card %) hand))\n        flush? (apply = (map #(:suit %) hand))\n        rank-sorted (sort (map #(:rank %) hand))\n        rank-sorted-set (set rank-sorted)\n        rank-freq (frequencies rank-sorted)\n        rank-freq-sorted (reverse (sort (map val rank-freq)))\n        \n        straight? (and (= (count rank-sorted) (count rank-sorted-set)) \n                       (= (- (last rank-sorted) (first rank-sorted)) (dec (count rank-sorted))))]\n    (cond \n      (and flush? straight?)\n      :straight-flush\n      \n      (and (= 2 (count rank-sorted-set)) (= 4 (first rank-freq-sorted)))\n      :four-of-a-kind\n\n      (and (= 2 (count rank-sorted-set)) (= 3 (first rank-freq-sorted)))\n      :full-house\n\n      flush?\n      :flush\n\n      straight?\n      :straight\n\n      (= rank-sorted-set #{0 1 2 3 12})\n      :straight\n\n      (= 3 (first rank-freq-sorted))\n      :three-of-a-kind\n\n      (and (= 2 (first rank-freq-sorted)) (= 2 (second rank-freq-sorted)))\n      :two-pair\n\n      (= 2 (first rank-freq-sorted))\n      :pair\n\n      :else\n      :high-card)))","user":"5c92105ce4b048ec896c59f7"},{"problem":"178","code":"(fn best-hand [cards]\n  (let [sym-map {\\D :diamond \\S :spade \\H :heart \\C :club\n                    \\2 0 \\3 1 \\4 2 \\5 3 \\6 4 \\7 5 \\8 6 \\9 7\n                    \\T 8 \\J 9 \\Q 10 \\K 11 \\A 12}\n        to-card (fn [[suit rank]] {:suit (sym-map suit) :rank (sym-map rank)})\n        cards (map to-card cards)\n        by-rank (vals (group-by :rank cards))\n        by-suit (vals (group-by :suit cards))\n        flush (= (count (first by-suit)) 5)\n        get-counts (fn [num]\n                       (filter #(= (count %) num) by-rank))\n        two-pair (= (count (get-counts 2)) 2)\n        pair (seq (get-counts 2))\n        three (seq (get-counts 3))\n        full-house (and three pair)\n        four (seq (get-counts 4))\n        straight? #(reduce (fn [res nx]\n                            (cond (false? res) false\n                                  (= (inc res) nx) nx\n                                  :else false)) (dec (apply min (map :rank %))) (map :rank %))\n        straight (let [replaced-ace\n                       (conj (remove #(= (:rank %) 12) cards) {:rank -1 :suit :heart})]\n                   (or (straight? (sort-by :rank cards)) (straight? (sort-by :rank replaced-ace))))\n        s-flush (and straight flush)\n        ]\n    (cond\n      s-flush :straight-flush\n      four :four-of-a-kind\n      full-house :full-house\n      flush :flush\n      straight :straight\n      three :three-of-a-kind\n      two-pair :two-pair\n      pair :pair\n      :else :high-card\n      )))","user":"54f09599e4b024c67c0cf89d"},{"problem":"178","code":"(fn [hand]\n  (let [ranks (map second hand)\n        freqs (-> ranks frequencies vals frequencies)\n        has-4? (fn has-4? [ds]\n                 (if (< (count ds) 4) false\n                   (if (= (take 4 ds) [1 1 1 1]) true\n                     (has-4? (rest ds)))))\n        straight? (->> ranks\n                       (map (into {\\T [10]\n                                   \\J [11]\n                                   \\Q [12]\n                                   \\K [13]\n                                   \\A [1 14]}\n                                  (map\n                                    (fn [x] [(-> x str first) [x]])\n                                    (range 2 10))))\n                       (apply concat) set sort\n                       (reduce (fn [[ds l] x] [(conj ds (- x l)) x]) [[0] 0])\n                       first rest has-4?)\n        flush? (-> (map first hand) set count (= 1))\n        quadra? (get freqs 4)\n        trio? (get freqs 3)\n        pairs (get freqs 2)]\n    (cond\n      (and straight? flush?) :straight-flush\n      quadra?                :four-of-a-kind\n      (and trio? pairs)      :full-house\n      flush?                 :flush\n      straight?              :straight\n      trio?                  :three-of-a-kind\n      (= 2 pairs)            :two-pair\n      (= 1 pairs)            :pair\n      :else                  :high-card)))","user":"57a0b341e4b0c3d858beb8d4"},{"problem":"178","code":"(fn best-hand\n  [cards]\n  (letfn [(parse-card [card]\n            (let [suit-name {\\D :diamond, \\H :heart, \\C :club, \\S :spade}\n                  suit (suit-name (first card))\n                  r (second card)\n                  rank-map {\\T 8, \\J 9, \\Q 10, \\K 11, \\A 12}\n                  rank (rank-map r (- (int r) (int \\2)))]\n              {:suit suit :rank rank}))]\n    (let [cards (map parse-card cards)\n           suits (map :suit cards)\n           ranks (sort (map :rank cards))\n           is-flush (= (count (set suits)) 1)\n           rank-group (partition-by identity ranks)\n           num-of-group (count rank-group)\n           group-sizes (map count rank-group)\n           straight (and (= 5 num-of-group)\n                         (or (= 4 (- (last ranks) (first ranks)))\n                             (= ranks '(0 1 2 3 12))))\n           largest-group-size (apply max group-sizes)]\n          (condp = largest-group-size\n            1 (if straight\n                (if is-flush :straight-flush :straight)\n                (if is-flush :flush :high-card))\n            2 (if (= 3 num-of-group) :two-pair :pair)\n            3 (if (= 2 num-of-group) :full-house :three-of-a-kind)\n            4 :four-of-a-kind\n            :else :wield))))","user":"56897739e4b0dcc4269f407d"},{"problem":"178","code":"(fn best-hand [h]\n  (letfn [(straight? [s]\n            (let [order1 \"A23456789TJQK\"\n                  order2 \"23456789TJQKA\"\n                  vals (map second s)\n                  sorter (fn [order]\n                           (->> order\n                                (map-indexed (fn [a i] [i a]))\n                                (into {})))\n                  checker (fn [sorter]\n                            (->> vals\n                                 (sort-by sorter)\n                                 (reverse)\n                                 (map sorter)\n                                 (partition 2 1)\n                                 (map (partial apply -))\n                                 set\n                                 count\n                                 (= 1)))]\n              (or (checker (sorter order1))\n                  (checker (sorter order2)))))\n\n          (freqs [pos s]\n            (->> s\n                 (map pos)\n                 frequencies\n                 (map second)))\n          (flush? [s]\n            (->> s (freqs first) (some #{5})))\n          (straight-flush? [s]\n            (and (flush? s) (straight? s)))\n          (four-of-a-kind? [s]\n            (->> s (freqs second) (some #{4})))\n          (full-house? [s]\n            (->> s (freqs second) set (= #{2 3})))\n          (three-of-a-kind? [s]\n            (->> s (freqs second) (some #{3})))\n          (two-pair? [s]\n            (->> s\n                 (freqs second)\n                 frequencies\n                 (#(get % 2))\n                 (= 2)))\n          (pair? [s]\n            (->> s (freqs second) (some #{2})))]\n    (cond (straight-flush? h)  :straight-flush\n          (four-of-a-kind? h)  :four-of-a-kind\n          (full-house? h)      :full-house\n          (flush? h)           :flush\n          (straight? h)        :straight\n          (three-of-a-kind? h) :three-of-a-kind\n          (two-pair? h)        :two-pair\n          (pair? h)            :pair\n          :else                :high-card)))","user":"4ee26f01535d10e5ff6f5368"},{"problem":"178","code":"(fn [v]\n   (let [rank-num-map (into {} (map-indexed #(vector %2 %1)\n                                            \"A23456789TJQK\"))\n         cards (map (fn [[ch1 ch2]]\n                      {:suit ch1\n                       :rank (rank-num-map ch2)}) v)\n         count-by #(map (fn [[k c]] (vector k (count c)))\n                             (group-by %1 cards))\n         is-straight (let [sorted (->> cards (map :rank) set sort)]\n                       (#{[9 1 1 1] [1 1 1 1]}\n                        (map - (drop 1 sorted) sorted)))\n         is-flush (= 1 (->> (count-by :suit) count))\n         [c1 c2 & _] (->> (count-by :rank) (map second) (sort >))]\n     (cond\n       (and is-straight is-flush) :straight-flush\n       (= 4 c1)          :four-of-a-kind\n       (= [3 2] [c1 c2]) :full-house\n       is-flush          :flush\n       is-straight       :straight\n       (= 3 c1)          :three-of-a-kind\n       (= [2 2] [c1 c2]) :two-pair\n       (= 2 c1)          :pair\n       :else             :high-card)))","user":"5e3ef7d4e4b01d43a70e8e2d"},{"code":"(fn [inp] (let [cards { :suits (\n\t\t\t\t\t\t\t\n(fn [data] (loop [index 0 suits {} foo { \"2\" 2 \"3\" 3 \"4\" 4 \"5\" 5 \"6\" 6 \"7\" 7 \"8\" 8 \"9\" 9 \"T\" 10 \"J\" 11 \"Q\" 12 \"K\" 13 \"A\" 14}] \n\t\t\t  (cond (= index (count data)) suits\n\t\t\t\t\t (contains? suits (str (nth (data index) 0))) (recur (+ index 1) (assoc-in suits [(str (nth (data index) 0))] (conj (suits (str (nth (data index) 0))) (foo (str (nth (data index) 1))))) foo)\n\t\t\t\t\t :else    (recur (+ index 1) (conj suits [ (str (nth (data index) 0)) [(foo (str (nth (data index) 1)))] ]) foo )))) inp)              \n\n\t\t\t\t\t\t:ranks (\n\n(fn [data] (loop [index 0 ranks {}] \n\t\t\t  (cond (= index (count data)) ranks\n\t\t\t\t\t (contains? ranks (str (nth (data index) 1))) (recur (+ index 1) (assoc-in ranks [(str (nth (data index) 1))] (conj (ranks (str (nth (data index) 1))) (str (nth (data index) 0)))))\n\t\t\t\t\t :else    (recur (+ index 1) (conj ranks [ (str (nth (data index) 1)) [(str (nth (data index) 0))] ]))))) inp) } ] \n\n\n\n\n\t(cond (and (= 1 (count (vals (cards :suits))))    (loop [ssuits (sort (nth (vals (cards :suits)) 0))] \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(cond (= (count ssuits) 1) true                       \n\t\t                                                       (= (+ (first ssuits) 1) (first (rest ssuits))) (recur (rest ssuits))       \n\t\t\t\t\t                               :else            false)))                                                  :straight-flush\n              (loop [buf (vals (cards :ranks))] \n\t\t\t\t\t\t\t   (cond (not (seq buf))               false\n\t\t\t\t\t\t\t\t (>=  (count (first buf)) 4)   true\n\t\t\t\t\t\t\t\t  :else (                      recur (rest buf))))\t\t       \t\t   :four-of-a-kind\n\n              (= 2 (count (vals (cards :ranks))))                                                                                                  :full-house\n\t\t\t\n              (= 1 (count (vals (cards :suits))))                                                                                                  :flush\n\n              (let [ssuits (sort (flatten (vals (cards :suits))))\n                   fssuits (sort (replace {14 1} ssuits))]\n                       (if (or (= ssuits (range (apply min ssuits) (+ (apply min ssuits) 5)))\n                               (= fssuits (range (apply min fssuits) (+ (apply min fssuits) 5)))) true false))                                      :straight\n\n\n              (= (count (filter #(= 3 (count %1)) (vals (cards :ranks)))) 1)                                                                           :three-of-a-kind  \n              (= (count (filter #(= 2 (count %1)) (vals (cards :ranks)))) 2)                                                                           :two-pair\n              (= (count (filter #(= 2 (count %1)) (vals (cards :ranks)))) 1)                                                                           :pair\n              :else                                                                                                                                    :high-card)))","problem":"178","user":"52f5eefbe4b09b582c12c9cb"},{"problem":"178","code":"(fn [cs]\n    (let [rank [\\A \\K \\Q \\J \\T \\9 \\8 \\7 \\6 \\5 \\4 \\3 \\2]\n          suits (map first cs)\n          ranks (map second cs)\n          findr (fn [r] (keep-indexed (fn [i v] (if (= v r) i)) rank))\n          is-straight? (every? #(= 1 (Math/abs %)) (map #(apply - %) (partition 2 1 (mapcat #(findr (second %))\n                                                                                 (if (= '(\\A \\2) (take 2 ranks)) (next cs) cs)))))\n          same-suit? (apply = suits)\n          rank-counts (reverse (sort-by first (let [g (group-by identity ranks)] (mapv vector (map count (vals g)) (keys g)))))\n          ]\n      (cond\n        (and is-straight? same-suit?) :straight-flush\n        (= 4 (ffirst rank-counts)) :four-of-a-kind\n        (= [3 2] (mapv first (take 2 rank-counts))) :full-house\n        same-suit? :flush\n        is-straight? :straight\n        (= 3 (ffirst rank-counts)) :three-of-a-kind\n        (= [2 2] (mapv first (take 2 rank-counts))) :two-pair\n        (= 2 (ffirst rank-counts)) :pair\n        :else :high-card)))","user":"5310e968e4b08068f379ecdd"},{"code":"(fn cg-hand [cards]\n  (letfn [(parse-card [code]\n            (let [suits {\\S :spade \\H :heart \\D :diamond \\C :club}\n                  ranks {\\2 0 \\3 1 \\4 2 \\5 3 \\6 4 \\7 5 \\8 6 \\9 7 \\T 8 \\J 9 \\Q 10 \\K 11 \\A 12}]\n              {:suit (suits (first code)) :rank (ranks (second code))}))\n          (cg-group-by-rank [cards]\n            (->> (map :rank cards)\n                 (group-by identity)\n                 (vals)))\n          (cg-flush? [cards]\n            (= 1 (count (distinct (map :suit cards)))))\n          (cg-straight? [cards]\n            (let [ranks (vec (sort (map :rank cards)))]\n              (and\n               (apply distinct? ranks)\n               (or\n                (= 4 (- (ranks 4) (ranks 0)))\n                (and (= 9 (- (ranks 4) (ranks 3))))))))\n          (cg-n-of-a-kind? [n cards]\n            (->> (cg-group-by-rank cards)\n                 (filter #(<= n (count %)))\n                 (empty?)\n                 (not)))\n          (cg-full-house? [cards]\n            (->> (cg-group-by-rank cards)\n                 (map count)\n                 (sort)\n                 (= '(2 3))))\n          (cg-two-pair? [cards]\n            (->> (cg-group-by-rank cards)\n                 (map count)\n                 (sort)\n                 (= '(1 2 2))))]\n    (let [cards (map parse-card cards)]\n      (cond\n        (and (cg-straight? cards) (cg-flush? cards)) :straight-flush\n        (cg-n-of-a-kind? 4 cards) :four-of-a-kind\n        (cg-full-house? cards) :full-house\n        (cg-flush? cards) :flush\n        (cg-straight? cards) :straight\n        (cg-n-of-a-kind? 3 cards) :three-of-a-kind\n        (cg-two-pair? cards) :two-pair\n        (cg-n-of-a-kind? 2 cards) :pair\n        :else :high-card))))","problem":"178","user":"526ee63de4b03e8d9a4a733f"},{"problem":"178","code":"(fn\n  [hand]\n  (let [suitMap {\\C :club\n                 \\D :diamond\n                 \\S :spade\n                 \\H :heart}\n        ranksAceHigh \"23456789TJQKA\"\n        ranksAceLow  \"A23456789TJQK\"]\n    (letfn [(suit [card] (suitMap (first card)))\n            (rankAceHigh [card] (.indexOf ranksAceHigh (int (second card))))\n            (rankAceLow [card] (.indexOf ranksAceLow (int (second card))))\n            (flush\n              [hand]\n              (let [suits (set (map suit hand))]\n                (= 1 (count suits))))\n            (straight-with-ranks\n              [hand ranker]\n              (let [rs (set (map ranker hand))\n                    minr (apply min rs)\n                    maxr (apply max rs)]\n                (and (= 5 (count rs))\n                     (= maxr (+ minr 4)))))\n            (straight\n              [hand]\n              (or (straight-with-ranks hand rankAceHigh)\n                  (straight-with-ranks hand rankAceLow)))]\n      (let [freqs (frequencies (map rankAceHigh hand))\n            freqSet (set (vals freqs))\n            freqfreqs (frequencies (vals freqs))]\n        (cond\n          (and (straight hand)\n               (flush hand)) :straight-flush\n          (contains? freqSet 4) :four-of-a-kind\n          (and (contains? freqSet 3)\n               (contains? freqSet 2)) :full-house\n          (flush hand) :flush\n          (straight hand) :straight\n          (contains? freqSet 3) :three-of-a-kind\n          (= 2 (freqfreqs 2)) :two-pair\n          (= 1 (freqfreqs 2)) :pair\n          :else :high-card)))))","user":"52dfc89be4b09f7907dd1405"},{"code":"(fn best-hand [cstrs]\n  (let [read-card\n        (fn read-card [[s r]]\n           (let [suit\n                 (case s\n                   \\S :spade\n                   \\H :heart\n                   \\D :diamond\n                   \\C :club)\n                 rank\n                 (case r\n                   \\A 12\n                   \\K 11\n                   \\Q 10\n                   \\J 9\n                   \\T 8\n                   (- (- (int r) (int \\0)) 2))]\n             {:suit suit :rank rank}))\n        cards (map read-card cstrs)\n        ordered (sort-by :rank cards)\n        ace-low-rank (fn [c] (if (= (:rank c) 12) -1 (:rank c)))\n        ace-low-ordered (sort-by ace-low-rank cards)\n        parted (partition-by :rank ordered)\n        counts (map count parted)\n        ranks (map :rank ordered)\n        ace-low-ranks (map ace-low-rank ace-low-ordered)\n        flush? (every? #(= (% :suit) ((first cards) :suit)) cards)\n        straight-reducer (fn [[st? prev] c] [(and st? (= c (inc prev))) c])\n        high-straight? (first (reduce straight-reducer [true (dec (first ranks))] ranks))\n        low-straight? (first (reduce straight-reducer [true (dec (first ace-low-ranks))] ace-low-ranks))\n        straight? (or high-straight? low-straight?)]\n    (cond\n     (and straight? flush?) :straight-flush\n     (some #{4} counts) :four-of-a-kind\n     (and (some #{3} counts)\n          (= (count (filter #(>= % 2) counts)) 2)) :full-house\n     flush? :flush\n     straight? :straight\n     (some #{3} counts) :three-of-a-kind\n     (= (count (filter #(>= % 2) counts)) 2) :two-pair\n     (some #{2} counts) :pair\n     true :high-card)))","problem":"178","user":"529ce629e4b04e0c58e87b6e"},{"problem":"178","code":"(fn best-hand [xs]\n  (let [suit-lookup {\\D :diamond, \\H :heart, \\C :club, \\S :spade}\n        rank-lookup {\\T 10, \\J 11, \\Q 12, \\K 13, \\A 14}\n        cards (map\n        \t\t#(hash-map\n        \t\t\t:suit (suit-lookup (get % 0))\n        \t\t\t:rank (rank-lookup (get % 1) (- (int (get % 1)) (int \\0)))) xs)\n        flush? (fn [cards]\n        \t\t(= 1 (->> cards (map :suit) set count)))\n        straight? (fn [cards]\n        \t(let [lowest (->> cards (map :rank) sort first)]\n        \t\t(or\n        \t\t\t(= (range lowest (+ lowest 5)) (->> cards (map :rank) sort))\n        \t\t\t(= (concat (range 2 6) [14]) (->> cards (map :rank) sort)))))\n        most-of-kind (fn [cards]\n        \t(->> cards\n        \t\t(group-by :rank)\n        \t\tvals\n        \t\t(map count)\n        \t\t(reduce max)))\n        ]\n    (cond\n    \t(and (flush? cards) (straight? cards))\n    \t\t:straight-flush\n    \t(= (most-of-kind cards) 4)\n    \t\t:four-of-a-kind\n    \t(= (->> cards (group-by :rank) count) 2)\n    \t\t:full-house\n    \t(flush? cards)\n    \t\t:flush\n    \t(straight? cards)\n    \t\t:straight\n    \t(= (most-of-kind cards) 3)\n    \t\t:three-of-a-kind\n    \t(= (->> cards (group-by :rank) count) 3)\n    \t:two-pair\n    \t(= (most-of-kind cards) 2)\n    \t\t:pair\n    \t:else\n    \t\t:high-card)))","user":"54448e84e4b032a45b869393"},{"problem":"178","code":"(fn [cards]\n  (letfn\n    [(suits [cards] (map #(first %) cards))\n     (values [cards] (map #(second %) cards))\n     (same-suit? [cards] (apply = (suits cards)))\n     (str-values [cards] (clojure.string/join \"\" (values cards)))\n     (max-kind [cards] (max (vals (frequencies (values cards)))))\n     (has-m-n-kind? [cards n m] (= n (get (frequencies (max-kind cards)) m)))\n     (n-kind? [cards n] (= n (apply max (max-kind cards))))\n     (in-sequence? [cards] \n                   (or\n                     (.contains \"AKQJT98765432\" (str-values cards))\n                     (.contains \"A2345\" (str-values cards))))]\n    (cond\n     (and (in-sequence? cards) (same-suit? cards)) :straight-flush\n     (n-kind? cards 4) :four-of-a-kind\n     (and (has-m-n-kind? cards 1 3) (has-m-n-kind? cards 1 2)) :full-house\n     (same-suit? cards) :flush\n     (in-sequence? cards) :straight\n     (n-kind? cards 3) :three-of-a-kind\n\t (has-m-n-kind? cards 2 2) :two-pair\n     (n-kind? cards 2) :pair\n     :else :high-card)))","user":"5514a60fe4b055c2f668d4d7"},{"problem":"178","code":"(fn high-hand [cards]\n  (letfn [(card [acelow? s]\n            (let [suits {\"D\" :diamond \"H\" :heart \"C\" :club \"S\" :spade}\n                  ranks (apply merge {\"T\" 8 \"J\" 9 \"Q\" 10 \"K\" 11 \"A\" (if acelow? -1 12)} (map #(hash-map (str %) (- % 2)) (range 2 10))) \n                  [suit rank] (map str (seq s))]\n              {:suit (suits suit) :rank (ranks rank)}))\n          (by-rank [cards] (vals (group-by :rank cards)))\n          (n-o-a-k? [cards n] (some #(= n (count %)) (by-rank cards)))\n          (flush? [cards] (apply = (map :suit cards)))\n          (straight? [cards] (let [rs (map :rank cards)] (= rs (range (first rs) (inc (last rs))))))\n          (straight-flush? [cards] (and (flush? cards) (straight? cards)))\n          (four-of-a-kind? [cards] (n-o-a-k? cards 4))\n          (full-house? [cards] (= #{3 2} (set (map count (by-rank cards)))))\n          (three-of-a-kind? [cards] (n-o-a-k? cards 3))\n          (pair? [cards] (n-o-a-k? cards 2))\n          (two-pair? [cards] (= 2 (count (filter #(= 2 (count %)) (by-rank cards)))))\n          (high-card? [cards] true)]\n    (let [cards1 (sort-by :rank (map (partial card false) cards))\n          cards2 (sort-by :rank (map (partial card true) cards))\n          fns [[:straight-flush  straight-flush?]\n               [:four-of-a-kind  four-of-a-kind?]\n               [:full-house      full-house?]\n               [:flush           flush?]\n               [:straight        straight?]\n               [:three-of-a-kind three-of-a-kind?]\n               [:two-pair        two-pair?]\n               [:pair            pair?]\n               [:high-card       high-card?]]]\n      (first (for [[hand check] fns cards [cards1 cards2]\n                   :when (check cards)] hand)))))","user":"575b3e9be4b02ea11479935b"},{"problem":"178","code":"(fn best-hand [hand]\n  (let [rank {\\2 2 \\3 3 \\4 4 \\5 5 \\6 6 \\7 7 \\8 8 \\9 9 \\T 10 \\J 11 \\Q 12 \\K 13 \\A 1} suits (map #(first %1) hand) nums (sort (map #(rank (second %1)) hand)) nums2 (sort (map #(if (= 1 %1) 14 %1) nums))]\n      (let [grouped (group-by #(let [x %1] x) nums) is-straight (or (every? #{1} (map - (rest nums2) nums2)) (every? #{1} (map - (rest nums) nums)))]\n      (cond (and is-straight (apply = suits)) :straight-flush\n        (some #(= (count %1) 4) (vals grouped)) :four-of-a-kind\n        (and (some #(= (count %1) 2) (vals grouped)) (some #(= (count %1) 3) (vals grouped))) :full-house\n        (apply = suits) :flush\n        is-straight :straight\n        (some #(= (count %1) 3) (vals grouped)) :three-of-a-kind\n        (= 2 (count (filter #(= (count %1) 2) (vals grouped)))) :two-pair\n        (some #(= (count %1) 2) (vals grouped)) :pair\n        :else :high-card\n    ))))","user":"4f7b6b90e4b06e829148e1a4"},{"problem":"178","code":"(fn find-best-hand [hand-vec]\n   (let [flush? (fn [x]\n                 (every? #(= % (first (first hand-vec))) (map #(first %) hand-vec)))\n         value-converter {\\2 \"02\", \\3 \"03\", \\4 \"04\", \\5 \"05\", \\6 \"06\", \\7 \"07\", \\8 \"08\",\n                          \\9 \"09\", \\T \"10\", \\J \"11\", \\Q \"12\", \\K \"13\", \\A \"14\"}\n         ordered-hand (sort-by #(get value-converter (second %)) hand-vec)\n         values-ordered-hand (for [k (range 5)]\n                               (Integer. (get value-converter (second (nth ordered-hand k)))))\n         grouped-ordered-hand (partition-by #(second %) ordered-hand)\n         count-grouped-ordered-hand (fn [x] (sort (map #(count %) x)))                   \n         straight? (fn [x]\n                     (or\n                       (every? #(= 1 %) \n                             (for [j (range 4)]\n                               (- (nth x (inc j)) (nth x j))))\n                       (= x '(2 3 4 5 14))))]\n     (cond\n       (and (flush? hand-vec) (straight? values-ordered-hand)) :straight-flush\n       (= '(1 4) (count-grouped-ordered-hand grouped-ordered-hand)) :four-of-a-kind\n       (= '(2 3) (count-grouped-ordered-hand grouped-ordered-hand)) :full-house\n       (flush? hand-vec) :flush\n       (straight? values-ordered-hand) :straight\n       (= '(1 1 3) (count-grouped-ordered-hand grouped-ordered-hand)) :three-of-a-kind\n       (= '(1 2 2) (count-grouped-ordered-hand grouped-ordered-hand)) :two-pair\n       (= '(1 1 1 2) (count-grouped-ordered-hand grouped-ordered-hand)) :pair\n       :else :high-card)))","user":"58dcb8cde4b0a4d5acaab6a7"},{"code":"(fn [l]\n  (let [toCard #(hash-map\n                 :suit (get {\\S :spade, \\H :heart, \\C :club \\D :diamond } (first %)),\n                 :rank (get (conj (zipmap (map char (range 50 58))(range 0 8))\n                                  {\\T 8, \\J 9, \\Q 10, \\K 11, \\A 12}) (second %)))\n        cards (map toCard l)\n        \n        kind (map count (vals(group-by #(get % :rank) cards)))\n        suit (= 5 (count (first(vals (group-by #(get % :suit) cards)))))\n        ordered (sort (map #(get % :rank) cards))\n        straight (or\n                  (= ordered (range (first ordered) (inc(last ordered))))\n                  (= ordered (concat (range 0 4) [12])))]\n    (if (and straight suit)\n      :straight-flush\n      (if (= 4 (first kind))\n        :four-of-a-kind\n        (if (and(= 3 (first kind)) (= 2 (second kind)))\n          :full-house\n          (if suit\n            :flush\n            (if straight\n              :straight\n              (if (= 3 (first kind))\n                :three-of-a-kind\n                (if (and(= 2 (first kind)) (= 2 (second kind)))\n                  :two-pair\n                  (if (= 2 (first kind))\n                    :pair\n                    :high-card\n                    ))))))))))","problem":"178","user":"5349ac2be4b084c2834f4a67"},{"problem":"178","code":"(fn [cards] (\n \t->> (map last cards) frequencies vals sort {\n        [1 4]\t\t:four-of-a-kind\n        [2 3]\t\t:full-house  \n        [1 1 3]\t\t:three-of-a-kind \n        [1 2 2]\t\t:two-pair \n        [1 1 1 2]\t:pair\n       \n        [1 1 1 1 1] (->> [ (->> (map first cards) set count (= 1))\n                           (->> (map last cards) set\n                     \t \t\t(contains? (->> (partition 5 1 \"AKQJT98765432A\") (map set) set)))\n                       \t ]{ [true true]   :straight-flush\n           \t\t\t \t \t[true false]  :flush\n           \t\t\t\t \t[false true]  :straight\n           \t\t\t\t \t[false false] :high-card})\n       \t\t\t       \t\t\t \n}))","user":"5603c31fe4b04bb52996e1c1"},{"code":"(fn [cards]\n  (let [\n        rank-map (zipmap \"23456789TJQK\" (range 12)) \n        rank-h #((assoc rank-map \\A 12) (last %))\n        rank-l #((assoc rank-map \\A -1) (last %))\n        suit-chars (map first cards)\n        rank-chars (map last cards)\n        in-sequence? #(= 1 (- (count %) (- (apply max %) (apply min %))))\n        is-straight (if (apply distinct? rank-chars)\n                     (or (in-sequence? (map rank-h cards)) (in-sequence? (map rank-l cards)))\n                     false)\n        is-flush (apply = suit-chars)\n        group-by-rank (group-by identity rank-chars)\n        n-of-a-kind (fn [n] (some #(= n (count (last %))) group-by-rank) )\n        is-pair (n-of-a-kind 2)\n        is-two-pair (and is-pair (= 3 (count group-by-rank)))\n        is-four-of-a-kind (n-of-a-kind 4)\n        is-three-of-a-kind (n-of-a-kind 3)\n        is-full-house (and is-three-of-a-kind is-pair)\n       ]\n    (cond\n      is-full-house :full-house\n      is-three-of-a-kind :three-of-a-kind\n      is-four-of-a-kind :four-of-a-kind     \n      is-two-pair :two-pair\n      is-pair :pair\n      (and is-flush is-straight) :straight-flush\n      is-flush :flush\n      is-straight :straight\n      :else :high-card\n    )\n  )\n)","problem":"178","user":"51ba8f82e4b0fe3ecfb46434"},{"code":"(fn [h]\n  (let [v (into {} (map-indexed #(vector %2 %1) \"A23456789TJQK\"))\n        fr (sort (vals (frequencies (map second h))))\n        fl? (apply = (map first h))\n        sv (sort (map v (map second h)))\n        msv (map - (drop 1 sv) (take 4 sv))\n        st? (and (= fr (list 1 1 1 1 1))\n                 (or (= (list 1 1 1 1) msv)\n                     (= (list 9 1 1 1) msv)))]\n    (loop [hfn [[:straight-flush (fn [g] (and fl? st?))]\n                [:four-of-a-kind  (fn [g] (= fr (list 1 4)))]\n                [:full-house  (fn [g] (= fr (list 2 3)))]\n                [:flush  (constantly fl?)]\n                [:straight (constantly st?)]\n                [:three-of-a-kind (fn [g] (= fr (list 1 1 3)))]\n                [:two-pair   (fn [g] (= fr (list 1 2 2)))]\n                [:pair   (fn [g] (= fr (list 1 1 1 2)))]\n                [:high-card   (constantly true)]]]      \n      (let [f (first hfn)]\n        (if ((second f) h) (first f)\n            (recur (rest hfn)))))))","problem":"178","user":"4facd2fae4b081705acca22f"},{"problem":"178","code":"(fn best-poker-hand [cards]\n  (let [hand (map #(into [] %) cards)\n        ranks {\\2 0 \\3 1 \\4 2 \\5 3 \\6 4 \\7 5 \\8 6 \\9 7 \\T 8 \\J 9 \\Q 10 \\K 11 \\A 12}]\n    (letfn [(rank [[s r]] (ranks r))\n            (suit [[s r]] s)\n            (partition-by-rank [coll] (vals (group-by rank coll)))\n            (pair? [coll] (first (filter #(>= (count %) 2) (partition-by-rank coll))))\n            (two-pair? [coll] \n              (let [pair (pair? coll)]\n                (and pair (pair? (remove #(= (rank %) (rank (first pair))) coll)))))\n            (three-of-a-kind? [coll] (first (filter #(>= (count %) 3) (partition-by-rank coll))))\n            (four-of-a-kind? [coll] (first (filter #(>= (count %) 4) (partition-by-rank coll))))\n            (flush? [coll] (every? #(= (suit %) (suit (first coll))) (rest coll)))\n            (full-house? [coll] \n              (let [three-of-a-kind (three-of-a-kind? coll)]\n                (and three-of-a-kind\n                  (pair? (remove #(= (rank %) (rank (first three-of-a-kind))) coll)))))\n\n            (straight? [coll] \n              (let [sorted (sort (map rank coll))]\n                (first\n                  (reduce (fn [[acc pv] v] \n                    (if (= v 12)\n                        [(and acc (or (= pv 3) (= pv 11))) 12]\n                        [(and acc (= 1 (- v pv))) v]))\n                    [true (first sorted)]\n                    (rest sorted)))))\n            (straight-flush? [coll] (and (straight? coll) (flush? coll)))]\n\n      ;(partition-by-rank hand))))\n      (cond\n        (straight-flush? hand) :straight-flush\n        (four-of-a-kind? hand) :four-of-a-kind\n        (full-house? hand) :full-house\n        (flush? hand) :flush\n        (straight? hand) :straight\n        (three-of-a-kind? hand) :three-of-a-kind\n        (two-pair? hand) :two-pair\n        (pair? hand) :pair\n        :else :high-card))))","user":"57c0917be4b05aa3c4741c95"},{"problem":"178","code":"(fn [s] \n (let [rank (zipmap \"23456789TJQKA\" (range 13))\n       ranks (sort (map (comp rank second) s))\n       suits (set (map first s))\n       flush? (= 1 (count suits))\n       straight? (or (= (map #(- % (apply min ranks)) ranks) (range 5)) (= ranks [0 1 2 3 12])) \n       ranks-group (group-by identity ranks)]\n  (cond\n   (and flush? straight?) :straight-flush\n   (some (fn [[k v]] (= 4 (count v))) ranks-group) :four-of-a-kind\n   (= 2 (count ranks-group)) :full-house\n   flush? :flush\n   straight? :straight\n   (some (fn [[k v]] (= 3 (count v))) ranks-group) :three-of-a-kind\n   (= 3 (count ranks-group)) :two-pair\n   (= 4 (count ranks-group)) :pair\n   :else :high-card)))","user":"56b86e64e4b0f26550335924"},{"problem":"178","code":"(let [                                                                                                                          \n    table (zipmap [\\S \\H \\C \\D \\A \\K \\Q \\J \\T \\9 \\8 \\7 \\6 \\5 \\4 \\3 \\2] (range))                                                                         \n    suit-offsets (range 0 52 13)                                                                                                                        \n    show-bits (fn [n] (map-indexed #(if (zero? (bit-and n (bit-shift-left 1 %2))) 0 (inc %1)) (range 64)))                      \n    count-bits (fn [n] (loop [c 0 v n] (if (zero? v) c (recur (inc c) (bit-and v (- v 1))))))                                   \n    parse-hand (fn [hand]                                                                                                       \n        (reduce                                                                                                                 \n            (fn [n card] (bit-or n (bit-shift-left 1 (+ (- (table (second card)) 4) (* (table (first card)) 13)))))             \n            (long 0)                                                                                                            \n            hand))                                                                                                                                      \n        ; bit masks                                                                                                             \n    straight-mask (- (bit-shift-left 1 5) 1)                                                                                    \n    aces-low-straight-mask (apply bit-or (map #(bit-shift-left 1 %) [0 9 10 11 12]))                                                                    \n    x-of-a-kind-mask (apply bit-or (map #(bit-shift-left 1 %) suit-offsets))                                                    \n    flush-mask (- (bit-shift-left 1 13) 1)                                                                                                              \n        ; checks                                                                                                                                        \n    check-straight? (fn [n] (boolean (first (concat                                                                             \n        (drop-while                                                                                                             \n            #(not= straight-mask (bit-and (bit-shift-right n %) straight-mask))                                                                         \n            (for [suit (range 4) rank (range 10)] (+ (* 13 suit) rank)))                                                        \n        (filter #(= (bit-and aces-low-straight-mask (bit-shift-right n %)) aces-low-straight-mask) suit-offsets)))))                                    \n    straight-flush? (fn [n] (check-straight? n))                                                                                \n    x-of-a-kind (fn [n] (map #(count-bits (bit-and n (bit-shift-left x-of-a-kind-mask %))) (range 13)))                                                 \n    straight? (fn [n] (check-straight? (bit-and flush-mask (apply bit-or (map #(bit-shift-right n %) suit-offsets)))))          \n    flush? (fn [n] (not-every? #(< % 5) (map #(count-bits (bit-and n (bit-shift-left flush-mask %))) suit-offsets)))                                    \n        ; highest hand                                                                                                          \n    highest-hand (fn [hand]                                                                                                                             \n        (let [n (parse-hand hand)   ; the hand as a long                                                                        \n              x (x-of-a-kind n)]    ; list of number of cards in each rank                                                                              \n            (cond                                                                                                               \n                (straight-flush? n)                 :straight-flush                                                                                     \n                (some #{4} x)                       :four-of-a-kind                                                             \n                (and (some #{3} x) (some #{2} x))   :full-house                                                                                         \n                (flush? n)                          :flush                                                                      \n                (straight? n)                       :straight                                                                                           \n                (some #{3} x)                       :three-of-a-kind                                                            \n                (>= (count (filter #{2} x)) 2)      :two-pair                                                                   \n                (some #{2} x)                       :pair                                                                       \n                :else                               :high-card)))]                                                                                      \n        highest-hand)","user":"558b50d5e4b027778923762b"},{"code":"(fn [hand]\n\n  (let [suit       {\\D :diamond, \\H :heart, \\C :club, \\S :spade}\n        rank       (some-fn {\\T 8, \\J 9, \\Q 10, \\K 11, \\A 12}\n                            #(-> % str read-string dec dec))\n        card-str-to-card-map\n                   ; Same as my solution to Problem 128, titled, 'Recognize\n                   ; Playing Cards'.\n                   (fn [card-str]\n                     {:suit (suit (first card-str)),\n                      :rank (rank (last card-str))})\n        card-maps  (map card-str-to-card-map hand)\n        a-suit     (:suit (first card-maps))\n        flush?     (every? #(= a-suit (:suit %)) card-maps)\n        ranks      (->> card-maps (map :rank) (sort >))\n        of-a-kind  (->> ranks\n                        (group-by identity)\n                        (map (comp count val))\n                        (sort >))\n        follow?    (fn [[r1 r2]] (= r1 (inc r2)))\n        rank-pairs (partition 2 1 ranks)\n        straight?  (and\n                    (every? identity\n                            (map follow? (rest rank-pairs)))\n                    (or (follow? (first rank-pairs))\n                        (= [12 0] [(first ranks) (last ranks)])))\n        ]\n    (cond\n     (and straight? flush?)  :straight-flush\n     (= 4 (first of-a-kind)) :four-of-a-kind\n     (= [3 2] of-a-kind)     :full-house\n     flush?                  :flush\n     straight?               :straight\n     (= 3 (first of-a-kind)) :three-of-a-kind\n     (= [2 2 1] of-a-kind)   :two-pair\n     (= 2 (first of-a-kind)) :pair\n     :else                   :high-card\n     )))","problem":"178","user":"533b57c3e4b0e30313ee6ccc"},{"problem":"178","code":"(fn [cards]\n    (let [hand (sort-by (comp {\\A 1 \\2 2 \\3 3 \\4 4 \\5 5 \\6 6 \\7 7 \\8 8 \\9 9 \\T 10 \\J 11 \\Q 12 \\K 13} second) cards)]\n      (letfn [(straight-pattern [s]\n                (if-not (re-find #\"A\" s) s\n                        (let [postfix (apply str (rest s))]\n                          (str \"A\" postfix \"|\" postfix \"A\"))))]\n        (let [freqs (->> (map second hand) frequencies)\n              hand-freqs (->> (map first hand) frequencies)\n              full-house? (->> (vals freqs) set ((partial = #{2 3})))\n              flush? (apply = (map first hand))\n              pairs (->> (vals freqs) (filter #(= 2 %)) count)\n              triple? (->> (vals freqs) (filter #(= 3 %)) count pos?)\n              foursome? (->> (vals freqs) (filter #(= 4 %)) count pos?)\n              pair? (= 1 pairs)\n              two-pair? (= 2 pairs)\n              straight? (re-find (->> (map second hand) (apply str) straight-pattern (re-pattern)) \"A23456789TJQKA\")]\n          (cond\n            (and straight? flush?) :straight-flush\n            foursome? :four-of-a-kind\n            full-house? :full-house\n            flush? :flush\n            straight? :straight\n            triple? :three-of-a-kind\n            two-pair? :two-pair\n            pair? :pair\n            :else :high-card)))))","user":"5d236215e4b02ea6f0fb6a09"},{"problem":"178","code":"(fn rh[cards]\n  (letfn [\n          (classify[card]\n          (let [ ranks {\\2 0 \\3 1 \\4 2 \\5 3 \\6 4 \\7 5 \\8 6 \\9 7 \\T 8 \\J 9 \\Q 10 \\K 11 \\A 12}\n                suits {\\D :diamond \\H :heart \\S :spade \\C :club}\n                [sc rc] card]\n            (hash-map :suit (suits sc) :rank (ranks rc))))\n          (straight [cc] (let [ranks (map :rank cc)]\n                           (and\n                             (every? #(= 1 %) (vals (frequencies ranks)))\n                             (or (= 4 (- (apply max ranks) (apply min ranks)))\n                                 (= '(0 1 2 3 12) (sort ranks)))\n                             )))\n          (four-of-a-kind [ccbrf] (= 4 (apply max ccbrf)))\n          (full-house [ccbrf] (= '(2 3) (sort ccbrf)))\n          (three-of-a-kind [ccbrf] (= 3 (apply max ccbrf)))\n          (two-pair [ccbrf] (= '(1 2 2) (sort ccbrf)))\n          (pair [ccbrf] (= 2 (apply max ccbrf)))\n          ]\n    (let [\n          cc (map classify cards)\n          suits (count (distinct (map :suit cc)))\n          card_ranks (vals (frequencies (map :rank cc)))\n          ]\n  (cond\n    (and (straight cc) (= 1 suits)) :straight-flush\n    (four-of-a-kind card_ranks) :four-of-a-kind\n    (full-house card_ranks) :full-house\n    (= 1 suits) :flush\n    (straight cc) :straight\n    (three-of-a-kind card_ranks) :three-of-a-kind\n    (two-pair card_ranks) :two-pair\n    (pair card_ranks) :pair\n    true :high-card\n    )\n  ))\n  )","user":"55f2c898e4b06e875b46ce4b"},{"code":"(fn [h]\n  (let [A apply\n        r (sort (map (fn [[_ r]] ({\\T 8 \\J 9 \\Q 10 \\K 11 \\A 12} r (- (int r) 50))) h))\n        s (map first h)\n        v (vals (frequencies r))\n        k (A = -1 (map #(A - %) (partition 2 1 r)))\n        u (set v)\n        f (A = s)]\n    (cond\n      (= [2 3] (sort v)) :full-house\n      (and f k) :straight-flush\n      (or (= r [0 1 2 3 12]) k) :straight\n      f :flush\n      (= (count (keep #(if (= % 2) 2) v)) 2) :two-pair\n      (u 2) :pair\n      (u 3) :three-of-a-kind\n      (u 4) :four-of-a-kind\n      0 :high-card)))","problem":"178","user":"4ef49c2c535dced4c769f238"},{"problem":"178","code":"(fn poker [hs]\n    (let [\n          cards (map vec hs)\n          suits (map first  cards)\n          ranks (sort (map #({\\A 1 \\2 2 \\3 3 \\4 4 \\5 5 \\6 6 \\7 7\n                        \\8 8 \\9 9 \\T 10 \\J 11 \\Q 12 \\K 13} (second %)) cards))\n          [rf0 rf1] (reverse (sort (vals (frequencies ranks))))\n          [sf0 sf1] (reverse (sort (vals (frequencies suits))))\n          straight? (fn [r]\n            (and (= rf0 1) (or (= 4 (- (last ranks) (first ranks)))\n                               (= ranks (seq [1 10 11 12 13])  ))))\n         ]\n\n        (println cards)\n        ;(println suits)\n        ;(println :ranks ranks)\n        ;(println rf0 rf1)\n        ;(println sf0 sf1)\n\n        (cond\n        (and (= 5 sf0) (straight? ranks))  :straight-flush\n        (= 4 rf0)                 :four-of-a-kind\n        (and (= 3 rf0) (= 2 rf1)) :full-house\n        (= 5 sf0)                 :flush\n        (straight? ranks)         :straight\n        (= 3 rf0)                 :three-of-a-kind\n        (and (= 2 rf0) (= 2 rf1)) :two-pair\n        (= 2 rf0)                 :pair\n        :else                     :high-card)\n    ))","user":"5eff6c0ee4b0cf489e8d7f11"},{"problem":"178","code":"(fn [hand]\n  (let [suits {\\D :diamond \\H :heart \\C :club \\S :spade}\n        ranks {\\T 10 \\J 11 \\Q 12 \\K 13 \\A 14}\n        hand (map (fn [[s r]]\n                    {:suit (suits s)\n                     :rank (ranks r (- (int r) 48))})\n                  hand)\n        ranks (map :rank hand)\n        rank-freqs (vals (frequencies ranks))]\n    (letfn [(monotonic-inc-one? [sq]\n              (apply = 1 (map - (rest sq) sq)))\n            (straight-flush []\n              (and (flush)\n                   (straight)))\n            (four-of-a-kind []\n              (some (partial = 4) rank-freqs))\n            (full-house []\n              (and (three-of-kind)\n                   (pair)))\n            (flush []\n              (apply = (map :suit hand)))\n            (straight []\n              (let [sorted (sort ranks)]\n                (or (monotonic-inc-one? \n                     sorted)\n                    (monotonic-inc-one? \n                     (cons 1 (butlast sorted))))))\n            (three-of-kind []\n              (some (partial = 3) rank-freqs))\n            (two-pair []\n              (= 2 (get (frequencies rank-freqs) 2)))\n            (pair []\n              (some (partial = 2) rank-freqs))\n            ]\n      (cond\n        (straight-flush) :straight-flush\n        (four-of-a-kind) :four-of-a-kind\n        (full-house) :full-house\n        (flush) :flush\n        (straight) :straight\n        (three-of-kind) :three-of-a-kind\n        (two-pair) :two-pair\n        (pair) :pair\n        :else :high-card))))","user":"57f0f7b8e4b0bfb2137f5bfe"},{"code":"(fn problem-178\n  [xs]\n  (let [ranks-order [\"23456789TJQKA\" \"A23456789TJQK\" \"AKQJT98765432\" \"KQJT98765432A\"]\n        ss (map (fn [[s r]] (str s)) xs)\n        rs (map (fn [[s r]] (str r)) xs)\n        rs-str (reduce str rs)\n        in-seq? (empty? (drop-while nil? (map #(re-find (re-pattern rs-str) %) ranks-order)))\n        suits (vals (group-by identity ss))\n        ranks (vals (group-by identity rs))        \n        flush-count (count (filter #(= 5 (count %)) suits))\n        four-kind-count (count (filter #(= 4 (count %)) ranks))\n        three-kind-count (count (filter #(= 3 (count %)) ranks))\n        pair-count (count (filter #(= 2 (count %)) ranks))]\n    (cond (and (= 1 flush-count) (not in-seq?)) :straight-flush\n          (= 1 four-kind-count) :four-of-a-kind\n          (and (= 1 three-kind-count) (= 1 pair-count)) :full-house\n          (= 1 flush-count) :flush\n          (not in-seq?) :straight\n          (= 1 three-kind-count) :three-of-a-kind\n          (= 2 pair-count) :two-pair\n          (= 1 pair-count) :pair          \n          :else :high-card)))","problem":"178","user":"4f2942ace4b0d6649770a01e"},{"problem":"178","code":"(fn [[c1 c2 c3 c4 c5]]\n   (let [hand (apply (partial merge-with #(if (vector? %) (conj % %2) [% %2])) \n                     (map (fn [c]\n                            (let [ranks {\"2\" 0 \"3\" 1 \"4\" 2 \"5\" 3 \"6\" 4 \"7\" 5 \"8\" 6 \"9\" 7 \"T\" 8 \"J\" 9 \"Q\" 10 \"K\" 11 \"A\" 12}\n                                  suits {\"D\" :diamond \"H\" :heart \"C\" :club \"S\" :spade}\n                                  [s r] (map str c)]\n                              {:suit (suits s) :rank (ranks r)}))\n                          [c1 c2 c3 c4 c5]))\n         suits (into #{} (:suit hand))\n         pips (sort (:rank hand))\n         flush (= (count suits) 1)\n         straight (or (= pips '(0 1 2 3 12))\n                      (every? #(= % 1) (drop 1 (map - pips `[0 ~@pips]))))\n         pipgroups (partition-by identity pips)\n         pipcounts (reverse (sort (map count pipgroups)))\n         ]\n      (cond (and straight flush) :straight-flush\n            (= 4 (first pipcounts)) :four-of-a-kind\n            (= [3 2] (take 2 pipcounts)) :full-house\n            flush :flush\n            straight :straight\n            (= 3 (first pipcounts)) :three-of-a-kind\n            (= [2 2] (take 2 pipcounts)) :two-pair\n            (= 2 (first pipcounts)) :pair\n            true :high-card)))","user":"53ea5307e4b036ad0777e4e2"},{"problem":"178","code":"(fn [descr]\n  (let\n    [parse-card\n     #(->> % (map (zipmap \"23456789TJQKASHDC\"\n                          `[~@(range 2 15) :spade :heart :diamond :club]))\n           (zipmap [:suit :rank]))\n     cards     (map parse-card descr)\n     freq      #(->> cards (map %) (frequencies) (sort-by val >))\n     in-seq?   #(= (range (apply min %) (inc (apply max %))) \n                   (sort %))\n     same-suit? (= 1 (count (freq :suit)))\n     freqr     (freq :rank)\n     nc        (count cards)\n     [r1 c1]   (first freqr)\n     [r2 c2]   (second freqr)\n     [re ce]   (last freqr)\n     ranks     (map :rank cards)\n     rank-seq? (or (in-seq? ranks) (in-seq? (replace {14 1} ranks)))]\n    (cond\n     (and rank-seq? same-suit?) :straight-flush\n     (= 4 c1) :four-of-a-kind\n     (= [c1 c2] [3 2]) :full-house\n     same-suit? :flush\n     rank-seq? :straight\n     (= 3 c1) :three-of-a-kind\n     (= [c1 c2] [2 2]) :two-pair\n     (= 2 c1) :pair\n     :else :high-card)))","user":"50336c6be4b0c6c1199c710f"},{"code":"(fn best-hand [cards]\n  (let [ranks-to-num (merge (zipmap (map #(Character/forDigit % 10) (range 2 10)) (range 2 10)) \n                            (zipmap [\\T \\J \\Q \\K \\A] (iterate inc 10)))]\n    (letfn [\n            (suites [cards]\n              (mapv #(first %) cards))         \n\n            (ranks [cards]\n              (sort (mapv #(ranks-to-num (second %)) cards)))\n\n            (in-sequence? [cards]\n              (let [one? (partial = 1)\n                    sorted-ranks (sort (ranks cards))\n                    in-seq? (fn [sorted-ranks]\n                              (every? one? (map - (next sorted-ranks) (butlast sorted-ranks))))]\n                (or (in-seq? sorted-ranks)\n                    (in-seq? (sort (replace {14 1} sorted-ranks))))))\n\t\t\t\n            (all-same-suites? [cards]\n              (= 1 (-> cards suites distinct count)))\n\n            (ranks-freq [cards]\n  \t\t\t\t(-> cards ranks frequencies vals sort))\t\n            \n            (four-of-a-kind? [cards]\n              (= [1 4] (ranks-freq cards)))\n\n            (full-house? [cards]\n              (= [2 3] (ranks-freq cards)))\n\n            (flush? [cards]\n              (all-same-suites? cards))\n\n            (straight? [cards]\n              (in-sequence? cards))\n\n            (straight-flush? [cards]\n              (and (straight? cards) (flush? cards)))\n\n            (three-of-a-kind? [cards]\n              (= [1 1 3] (ranks-freq cards)))\n\n            (two-pair? [cards]\n              (= [1 2 2] (ranks-freq cards)))\n\n            (pair? [cards]\n              (= [1 1 1 2] (ranks-freq cards)))]\n\n      (cond \n        (straight-flush? cards) :straight-flush\n        (four-of-a-kind? cards) :four-of-a-kind\n        (full-house? cards) :full-house\n        (flush? cards) :flush\n        (straight? cards) :straight\n        (three-of-a-kind? cards) :three-of-a-kind\n        (two-pair? cards) :two-pair\n        (pair? cards) :pair\n        :else :high-card))))","problem":"178","user":"5244a10de4b0d8acf9ed6ab3"},{"problem":"178","code":"(fn [hand]\n  (let [cards (map (fn [[s r]]\n                     {:suit ({\\D :diamond \\H :heart \\C :club \\S :spade} s) \n                     :rank ((zipmap \"23456789TJQKA\"(range)) r)})\n                   hand)\n        flush (apply = (map :suit cards))\n        sorted-ranks (sort (map :rank cards))\n        sorted-rank-frequencies (sort (vals (frequencies sorted-ranks)))\n        straight-rank (some #(= sorted-ranks %) (map sort (take 13 (partition 5 1 (cycle (range 13))))))]\n    (cond\n     (and straight-rank flush) :straight-flush\n     (= 4 (apply max sorted-rank-frequencies)) :four-of-a-kind\n     (= '(2 3) sorted-rank-frequencies) :full-house\n     flush :flush\n     straight-rank :straight\n     (= 3 (apply max sorted-rank-frequencies)) :three-of-a-kind \n     (= '(1 2 2) sorted-rank-frequencies) :two-pair\n     (= '(1 1 1 2) sorted-rank-frequencies) :pair\n     :else :high-card)))","user":"56ae214ce4b03c432f18735a"},{"problem":"178","code":"(fn [card-strs]\n    (let [rank-val   (fn [rnk-str]\n                       (if-let [rnk (get {\"A\" 14, \"K\" 13, \"Q\" 12, \"J\" 11, \"T\" 10} rnk-str)]\n                         rnk\n                         (Long/parseLong rnk-str)))\n          parse-card (fn [[st rnk]] {:st  (apply str [st])\n                                     :rnk (rank-val (apply str [rnk]))})\n          hand (let [cards (map parse-card card-strs)\n                     suits (set (map :st cards))\n                     ranks (sort > (map :rnk cards))]\n                 {:suits suits\n                  :ranks ranks\n                  :high  (first ranks)\n                  :flush? (= 1 (count suits))\n                  :straight? (or (and (= 4 (- (first ranks) (last ranks)))\n                                      (= 5 (count (set ranks))))\n                                 (and (= 14 (first  ranks))\n                                      (=  2 (last   ranks))\n                                      (=  5 (second ranks))))\n                  :rank-grps (->> (partition-by identity ranks)\n                                  (sort-by count >))})]\n      (cond\n        (and (:flush? hand)\n             (:straight? hand))                   :straight-flush\n        (= 4 (count (first (:rank-grps hand))))  :four-of-a-kind\n        (and (= 3 (count (first (:rank-grps hand))))\n             (= 2 (count (second (:rank-grps hand)))))  :full-house\n        (:flush? hand)                                  :flush\n        (:straight? hand)                               :straight\n        (= 3 (count (first (:rank-grps hand))))         :three-of-a-kind\n        (and (= 2 (count (first  (:rank-grps hand))))\n             (= 2 (count (second (:rank-grps hand)))))  :two-pair\n        (= 2 (count (first  (:rank-grps hand))))        :pair\n        :else   :high-card)))","user":"5f93529ae4b0715f5002d7bc"},{"problem":"178","code":"(fn [hand]\n    (let [recognize-card (fn [[s r]]\n                           {:suit (case s\n                                    \\D :diamond\n                                    \\H :heart\n                                    \\C :club\n                                    \\S :spade)\n                            :rank (case r\n                                    \\A 12\n                                    \\K 11\n                                    \\Q 10\n                                    \\J 9\n                                    \\T 8\n                                    (- (int r) (int \\2)))})\n          hand (map recognize-card hand)\n          flush? (= 1 (count (group-by :suit hand)))\n          sorted-rank (sort (map :rank hand))\n          min-rank (first sorted-rank)\n          max-rank (last sorted-rank)\n          straight? (or (= sorted-rank (take 5 (iterate inc min-rank)))\n                        (when (= 12 max-rank)\n                          (= (cons -1 (butlast sorted-rank)) (take 5 (iterate inc -1)))))\n          rank-frequency (sort (map count (vals (group-by :rank hand))))]\n      (cond\n        (and flush? straight?) :straight-flush\n        (= [1 4] rank-frequency) :four-of-a-kind\n        (= [2 3] rank-frequency) :full-house\n        flush? :flush\n        straight? :straight\n        (= [1 1 3] rank-frequency) :three-of-a-kind\n        (= [1 2 2] rank-frequency) :two-pair\n        (= [1 1 1 2] rank-frequency) :pair\n        :else :high-card)))","user":"51b91b08e4b0e871ca4958f8"},{"problem":"178","code":"; more readable version\n; https://github.com/Biserkov/p-p-p-pokerface/blob/master/src/p_p_p_pokerface.clj\n(fn [hand]\n  (let [rank (fn  [[st rg]]\n                (if (Character/isDigit rg)\n                  (Integer/valueOf (str rg))\n                  (get {\\T 10, \\J 11, \\Q 12, \\K 13, \\A 14} rg)))\n\n        suit (fn [card] (-> card first str))\n        n-of-a-kind? (fn [hand n] (contains? (set (vals (frequencies (map rank hand)))) n))\n        two-pairs? (fn [hand] (= (get (frequencies (vals (frequencies (map rank hand)))) 2) 2)) \n        full-house? (fn [hand] (and (n-of-a-kind? hand 2) (n-of-a-kind? hand 3)))\n        flush? (fn [hand] (apply = (map suit hand)))\n        \n        straight? (fn [hand]\n          (let [ranks (sort (map rank hand))\n                low (first ranks)\n                high (last ranks)\n                ]\n            (and \n                 (or (= (range low (inc high)) ranks)\n                     (= (range 1 6) (sort (replace {14 1} ranks)))))))\n        straight-flush? (fn [hand] (and (straight? hand) (flush? hand)))\n    ]\n    (cond \n     (straight-flush? hand) :straight-flush\n     (n-of-a-kind? hand 4) :four-of-a-kind\n     (full-house? hand) :full-house\n     (flush? hand) :flush\n     (straight? hand) :straight\n     (n-of-a-kind? hand 3) :three-of-a-kind\n     (two-pairs? hand) :two-pair\n     (n-of-a-kind? hand 2) :pair\n     :else :high-card\n    )))","user":"544e9022e4b0e3978000698b"},{"code":"(fn [c]\n           (let [dr (zipmap \"A23456789TJQK\" (range))\n                 ct (group-by identity (map second c))\n                 cr (sort (map #(dr (second %)) c))\n                 flush? (#{1} (count (set (map first c))))\n                 staight? (or (= [0 9 10 11 12] cr)\n                               (every? (fn [[a b]] (= (inc a) b)) (partition 2 1 cr)))]\n             (cond\n               (and flush? staight?) :straight-flush\n               (some #(#{4} (count (second %))) ct) :four-of-a-kind\n               (#{2} (count ct)) :full-house\n               flush? :flush\n               staight? :straight\n               (some #(#{3} (count (second %))) ct) :three-of-a-kind\n               (#{3} (count ct)) :two-pair\n               (#{4} (count ct)) :pair\n               :else :high-card)))","problem":"178","user":"52479487e4b05ef8e38e6373"},{"problem":"178","code":"(fn best-hand [hand]\n  (let [parse-card (fn [card]\n                     (let [suits {\\H :heart \\D :diamond \\S :spade \\C :club}\n                           ranks (zipmap \"23456789TJQKA\" (range))\n                           suit (suits (first card))\n                           rank (ranks (second card))]\n                       {:suit suit :rank rank}))\n        hand (map parse-card hand)\n        rank-groups (->>\n                     (map :rank hand)\n                     (frequencies)\n                     (vals)\n                     (sort #(compare %2 %)))\n        combination? #(= % (take (count %) rank-groups))\n        straight? (let [ace-hight-ranks (sort (map :rank hand))\n                        ace-low-ranks (sort (replace {12 -1} ace-hight-ranks))\n                        straight? #(apply = -1 (map - % (rest %)))]\n                    (or\n                     (straight? ace-hight-ranks)\n                     (straight? ace-low-ranks)))\n        flush? (apply = (map :suit hand))]\n    (cond\n     (and straight? flush?) :straight-flush\n     (combination? [4]) :four-of-a-kind\n     (combination? [3 2]) :full-house\n     flush? :flush\n     straight? :straight\n     (combination? [3]) :three-of-a-kind\n     (combination? [2 2]) :two-pair\n     (combination? [2]) :pair\n     :else :high-card)))","user":"55aa7c5ce4b0988bba2ad94d"},{"code":"(fn [hand]\n  (let [card (fn [c]\n               (let [ranks (zipmap (concat (map str (range 2 10)) [\"T\" \"J\" \"Q\" \"K\" \"A\"]) (range 13))\n                     suits {\"C\" :club \"D\" :diamond \"H\" :heart \"S\" :spade}\n                     s     (map str (seq c))]\n                 {:suit (-> s first suits) :rank (-> s last ranks)}))\n        cards (map card hand)\n        ranks (sort (map :rank cards))\n        of-a-kind (sort (vals (frequencies (map :rank cards))))\n        flush? (= 1 (count (group-by :suit cards)))\n        straight? (or (= ranks (range (first ranks) (inc (last ranks))))\n                      (= ranks '(0 1 2 3 12)))]\n    (cond\n     (and flush? straight?) :straight-flush\n     (= of-a-kind '(1 4)) :four-of-a-kind\n     (= of-a-kind '(2 3)) :full-house\n     flush? :flush\n     straight? :straight\n     (= of-a-kind '(1 1 3)) :three-of-a-kind\n     (= of-a-kind '(1 2 2)) :two-pair\n     (= of-a-kind '(1 1 1 2)) :pair\n     :else :high-card)))","problem":"178","user":"51307b84e4b08c712d3fae39"},{"code":"(fn [strs]\n    (let [parse (fn [[s r]]\n                  {:suit s :rank ((zipmap \"23456789TJQKA\" (range)) r)})\n          cards (map parse strs)\n          ranks (map :rank cards)\n          suits (map :suit cards)\n          freqs (vals (frequencies ranks))\n          flush (= 1 (count (distinct suits)))\n          straight   (let [opts (conj (partition 5 1 (range 13)) '(0 1 2 3 12))\n                           hand (sort ranks)]\n                       (some #(= % hand) opts))]\n      (cond\n       (and straight flush) :straight-flush\n       (= 4 (apply max freqs)) :four-of-a-kind\n       (= [2 3] (sort freqs)) :full-house\n       flush :flush\n       straight :straight\n       (= 3 (apply max freqs)) :three-of-a-kind\n       (= [2 2] (filter #(= 2 %) freqs)) :two-pair\n       (= 2 (apply max freqs)) :pair\n       :else :high-card)))","problem":"178","user":"4ec0c7ba535dfed6da9c6da4"},{"problem":"178","code":"(fn bestHand[input]\n\t(letfn [(recognizeCard[[a b]]\n\t\t(let [suits {\\D :diamond \\H :heart \\C :club \\S :spade}\n\t\t\t  ranks {\\2 0 \\3 1 \\4 2 \\5 3 \\6 4 \\7 5 \\8 6 \\9 7 \\T 8 \\J 9 \\Q 10 \\K 11 \\A 12}]\n\t\t\t{:suit (suits a) :rank (ranks b)}))\n\t\t\t(straight[hand]\n\t\t\t\t(or (every? identity (map (fn [[f l]] (= (inc f) l))(partition 2 1 (map :rank (sort-by :rank hand)))))\n\t\t\t\t\t(= [0 1 2 3 12] (map :rank (sort-by :rank hand))))\n\t\t\t)\n\t\t\t(doublepair[hand]\n\t\t\t\t(= 2 (apply + (map (fn [[f l]] (if (= f l) 1 0)) (partition 2 1 (map :rank (sort-by :rank hand))))))\n\t\t\t)\n\t\t\t(sameRank[hand]\n\t\t\t\t(let [ranks (map :rank hand)]\n\t\t\t\t\t(apply max (map (fn [el] (count (filter #(= % el) ranks))) ranks))\n\t\t\t\t)\n\t\t\t)\n\t\t\t(flush[hand]\n\t\t\t\t(let [suits (map :suit hand)]\n\t\t\t\t\t(apply = suits)\n\t\t\t\t)\n\t\t\t)\n\t\t\t(full-house[hand]\n\t\t\t\t(let [ranks (map :rank hand)]\n\t\t\t\t\t(= [2 2 3 3 3](sort (map (fn [el] (count (filter #(= % el) ranks))) ranks)))\n\t\t\t\t)\n\t\t\t)\n\t\t\t]\n\t\t(let [hand (map recognizeCard input)]\n\t\t\t(cond \n\t\t\t\t(and (flush hand) (straight hand)) :straight-flush\n\t\t\t\t(= 4 (sameRank hand)) :four-of-a-kind\n\t\t\t\t(full-house hand) :full-house\n\t\t\t\t(flush hand) :flush\n\t\t\t\t(straight hand) :straight \n\t\t\t\t(= 3 (sameRank hand)) :three-of-a-kind\n\t\t\t\t(doublepair hand) :two-pair\n\t\t\t\t(= 2 (sameRank hand)) :pair\n\t\t\t\t:else :high-card\n\t\t\t)\n\t\t)\n\t)\n)","user":"5626447fe4b00e49c7cb47bd"},{"code":"(fn __ [coll]\n  (let [resolve-card (fn resolve-card [[suit rank]]\n                       (let [suits {\\D :diamond \\H :heart \\C :club \\S :spade}\n                             ranks (apply hash-map (interleave \"23456789TJQKA\" (range)))]\n                         {:suit (suits suit) :rank (ranks rank)}))\n        straight-flush\n          (fn straight-flush [hand]\n            (let [distinct-suits (distinct (map :suit hand))\n                  sorted-ranks (sort (map :rank hand))]\n              (and (= 1 (count distinct-suits))\n                   (= 4 (- (last sorted-ranks)\n                           (first sorted-ranks))))))\n        four-of-a-kind\n          (fn four-of-a-kind [hand]\n            (let [ranks (map :rank hand)\n                  [x y] (sort (map count ((juxt filter remove) #{(first ranks)} ranks)))]\n              (and (= 2 (count (distinct ranks)))\n                   (= 1 x)\n                   (= 4 y))))\n        full-house\n          (fn full-house [hand]\n            (let [ranks (map :rank hand)\n                  [x y] (sort (map count ((juxt filter remove) #{(first ranks)} ranks)))]\n              (and (= 2 (count (distinct ranks)))\n                   (= 2 x)\n                   (= 3 y))))\n        flush-hand\n          (fn flush-hand [hand]\n            (-> :suit (map hand) (distinct) (count) (= 1)))\n        straight\n          (fn straight [hand]\n            (let [sorted-ranks (sort (map :rank hand))]\n              (or (and (= 5 (count (distinct sorted-ranks)))\n                       (= 4 (- (last sorted-ranks) (first sorted-ranks))))\n                  (= sorted-ranks [0 1 2 3 12]))))\n        three-of-a-kind\n          (fn three-of-a-kind [hand]\n            (some #{3} (vals (frequencies (map :rank hand)))))\n        two-pair\n          (fn two-pair [hand]\n            (= [1 2 2] (sort (vals (frequencies (map :rank hand))))))\n        pair\n          (fn pair [hand]\n            (= [1 1 1 2] (sort (vals (frequencies (map :rank hand))))))\n        hand (map resolve-card coll)]\n    (cond\n      (straight-flush hand) :straight-flush\n      (four-of-a-kind hand) :four-of-a-kind\n      (full-house hand) :full-house\n      (flush-hand hand) :flush\n      (straight hand) :straight\n      (three-of-a-kind hand) :three-of-a-kind\n      (two-pair hand) :two-pair\n      (pair hand) :pair\n      :else :high-card)))","problem":"178","user":"52463059e4b09dbe66b56198"},{"problem":"178","code":"(fn [cards] \n  (letfn\n   [(->card [[suit rank]]\n      {:suit ({\\C :club, \\D :diamond, \\H :heart, \\S :spade} suit)\n       :rank (or ({\\T 8, \\J 9, \\Q 10, \\K 11, \\A 12} rank)\n                 (- (Character/getNumericValue rank) 2))})\n    (straight-flush? [cards] (some #{10 18}\n                                   (map #(- (apply + %) (* 5 (apply min %)))\n                                        (map (partial map :rank)\n                                             (vals\n                                              (group-by :suit cards))))))\n    (four-of-a-kind? [cards] (some #{4}\n                                   (map count\n                                        (vals\n                                         (group-by :rank cards)))))\n    (full-house? [cards] (let [counts (map count\n                                           (vals\n                                            (group-by :rank cards)))] (and (some #{2} counts) (some #{3} counts))))\n    (flush? [cards] (some #{5}\n                          (map count\n                               (vals\n                                (group-by :suit cards)))))\n    (straight? [cards] (let [ranks (map :rank cards)\n                             value (- (apply + ranks) (* 5 (apply min ranks)))]\n                         (or (= value 10) (= value 18))))\n    (three-of-a-kind? [cards] (some #{3}\n                                    (map count\n                                         (vals\n                                          (group-by :rank cards)))))\n    (two-pair? [cards] (= ((frequencies\n                            (map count\n                                 (vals\n                                  (group-by :rank cards)))) 2 0) 2))\n    (pair? [cards] (some #{2}\n                         (map count\n                              (vals\n                               (group-by :rank cards)))))]\n    (let [cards (map ->card cards)]\n      (cond\n        (straight-flush? cards) :straight-flush\n        (four-of-a-kind? cards) :four-of-a-kind\n        (full-house? cards) :full-house\n        (flush? cards) :flush\n        (straight? cards) :straight\n        (three-of-a-kind? cards) :three-of-a-kind\n        (two-pair? cards) :two-pair \n        (pair? cards) :pair\n        :else :high-card))))","user":"604d3cb1e4b0b7ec0ac60ac2"},{"problem":"178","code":"(fn [c]\n  (let [z apply\n        m map\n        c (m\n            (fn [[s c]]\n              {:s ({\\H :h \\D :d \\S :s \\C :c} s) :r (or ({\\A 14 \\K 13 \\Q 12 \\J 11 \\T 10} c) (Character/getNumericValue c))})\n            c)\n        s (fn [x] (let [r (set (m :r x))\n                         a (z min r)]\n                     (some #(= r %) [#{14 13 12 11 10} #{5 4 14 3 2} (set (range a (+ a 5)))])))\n        f #(z = (m :s %))\n        k (sort (vals (frequencies (m :r c))))\n        ]\n    (cond\n      (and (s c) (f c)) :straight-flush\n      (f c) :flush\n      (s c) :straight\n      :else\n      (condp = k\n        [2 3] :full-house\n        [1 4] :four-of-a-kind\n        [1 1 3] :three-of-a-kind\n        [1 2 2] :two-pair\n        [1 1 1 2] :pair\n        :high-card))))","user":"51a4d802e4b0def3c5c5869a"},{"problem":"178","code":"(fn [h]\n  (let [rank {\\2 0 \\3 1 \\4 2 \\5 3 \\6 4 \\7 5 \\8 6 \\9 7 \\T 8 \\J 9 \\Q 10 \\K 11 \\A 12}\n     s (sort (map rank (map second h)))\n    fr (frequencies(vals(frequencies(map second h))))\n    fl (= 1 (count(distinct(map first h))))\n    st (or (and (= 5 (count (distinct s))) (= 4 (- (last s) (first s))))\n           (= s [0 1 2 3 12]))\n    sf (and fl st)\n    tp (= 2 (get fr 2))\n    fh (= {3 1, 2 1} fr)\n    xk (fn [n] (= 1 (get fr n)))]\n   (cond\n    sf :straight-flush\n    (xk 4) :four-of-a-kind\n    fh :full-house\n    fl :flush\n    st :straight\n    (xk 3) :three-of-a-kind\n    tp :two-pair\n    (xk 2) :pair\n    :else :high-card)))","user":"56bca51ae4b0f26550335963"},{"problem":"178","code":"(fn hand[ cards]\n  (let [id (fn [ n]\n             (let [lu {\\2 2 \\3 3 \\4 4 \n                       \\5 5 \\6 6 \\7 7 \\8 8 \n                       \\9 9  \\T 10 \\J 11 \n                       \\Q 12 \\K 13 \\A 14 \n                       \\D :diamond \\C :club\n                       \\H :heart   \\S :spade}\n                    vals (seq n)]\n               {:suit (get lu (first vals))\n                :rank (get lu (second vals)\n                             {:suit (get lu (first vals))\n                              :rank (get lu (second vals))})}))\n        myrankfreq (fn[hand] (sort (vals (frequencies (map :rank hand))))) \n        diffs (fn[s] (map #(reduce - %) (partition 2 1 (sort s))))\n        flush? (fn[hand] (some #(= 5 %)(vals (frequencies (map :suit hand)))))\n        straight? (fn[hand] (or (= [-1 -1 -1 -1] (diffs (map :rank hand)))\n                                (= [-1 -1 -1 -1] (diffs (replace {14 1}(map :rank hand))))))\n        best-hand (fn[hand]\n                    (cond\n                      (and (straight? hand) (flush? hand)) :straight-flush\n                      (= [1 4] (myrankfreq hand)) :four-of-a-kind\n                      (= [2 3] (myrankfreq hand)) :full-house\n                      (flush? hand) :flush\n                      (straight? hand) :straight\n                      (some #(= 3 %) (myrankfreq hand)) :three-of-a-kind\n                      (= [1 2 2] (myrankfreq hand)) :two-pair\n                      (some #(= 2 %) (myrankfreq hand)) :pair\n                      :else :high-card))]\n    (best-hand (map id cards))))","user":"52f426fce4b05e3f0be25f1e"},{"code":"(fn best-hand[cards]\t\n  (letfn [\n\t(recognize-card [a-str]\n\t\t(letfn [(char-to-suit [ch]\n\t\t\t\t(condp = ch\n\t\t\t\t  \\D :diamond\n\t\t\t\t  \\H :heart\n\t\t\t\t  \\S :spade\n\t\t\t\t  \\C :club\n\t\t\t\t)\n\t\t\t) (char-to-rank [ch]\n\t\t\t\t ((zipmap \"23456789TJQKA\" (range)) ch)           \n\t\t\t)]\n\t\t\t(let [s (first a-str) r (second a-str)]\n\t\t\t\t{:suit (char-to-suit s) :rank (char-to-rank r)}\n\t\t\t)\n\t\t)\n\t)\n\t(\tstraight? [uniq-ranks]\n\t\t(if (< (count uniq-ranks) 5)\n\t\t\tfalse\n\t\t\t(let [smallest (first uniq-ranks) biggest (last uniq-ranks)]\n\t\t\t\t(if (= 12 biggest)\n\t\t\t\t\t; has ace\n\t\t\t\t\t(or (= uniq-ranks #{0 1 2 3 12})\n\t\t\t\t\t\t(= uniq-ranks #{8 9 10 11 12}))\n\t\t\t\t\t; does not have ace\n\t\t\t\t\t(every? uniq-ranks (range smallest (+ smallest 5)))\n\t\t\t\t)\n\t\t\t)\t\t\n\t\t)\t\t\n\t)]\n\t\t(let [transformed-cards (map recognize-card cards)\n\t\t\t  rank-grouped (group-by #(get % :rank) transformed-cards)\n\t\t\t  suit-grouped (group-by #(get % :suit) transformed-cards)\n\t\t\t  count-rank-grouped (group-by (fn [[k v]] (count v)) rank-grouped)\n\t\t\t  count-flush (count (filter (fn[[k v]] (= 5 (count v))) suit-grouped))\n\t\t\t  uniq-ranks (apply sorted-set (keys rank-grouped))\n\t\t\t]\n\t\t\t(condp = (count (get count-rank-grouped 2))\n\t\t\t\t1 (if (get count-rank-grouped 3) :full-house :pair)\n\t\t\t\t2 :two-pair\n\t\t\t\t(cond\n\t\t\t\t\t(get count-rank-grouped 4) :four-of-a-kind\n\t\t\t\t\t(get count-rank-grouped 3) :three-of-a-kind\n\t\t\t\t\t(straight? uniq-ranks) (if (= 1 count-flush) :straight-flush :straight)\n\t\t\t\t\t(= 1 count-flush) :flush\n\t\t\t\t\t:else :high-card\n\t\t\t\t)\n\t\t\t)\n\t\t)\n\t)\n)","problem":"178","user":"52763696e4b03e8d9a4a74d7"},{"problem":"178","code":"(letfn [(sr [[s v]] (let [suit {\\D :diamond \\S :spade \\H :heart \\C :club}\n                                                     rank (zipmap \"23456789TJQKA\" (range))]\n                                             {:suit (suit s) :rank (rank v)}))]\n     (fn [cards]\n           (let [cards (map sr cards)\n                           by-suit (group-by :suit cards)\n                           by-rank (group-by :rank cards)\n                           matches? (set (map count (vals by-rank)))\n                           ranks (sort (map :rank cards))\n                           straight? (conj (set (partition 5 1 (range 13))) '(0 1 2 3 12))]\n                   (cond\n                            (and (= 1 (count by-suit))\n                                 (straight? ranks)) :straight-flush\n                            (matches? 4) :four-of-a-kind\n                            (and (matches? 3) (matches? 2)) :full-house\n                            (= 1 (count by-suit)) :flush\n                            (straight? ranks) :straight\n                            (matches? 3) :three-of-a-kind\n                            (= 3 (count by-rank)) :two-pair\n                            (matches? 2) :pair\n                            :else :high-card))))","user":"54ca9ca8e4b057c6fda3a265"},{"problem":"178","code":"(fn __ [x]\n  (let [numrank (fn numrank [z] (case z \"A\" 14 \"K\" 13 \"Q\" 12 \"J\" 11 \"T\" 10 (Integer/valueOf z)))\n        hshs (map \n       \t     \t  (fn [s] \n\t\t      (let [[a b] (rest (clojure.string/split s #\"\"))]\n\t\t      \t   (hash-map :suite a :rank b))) x)\n\ttpair (fn tpair [i] (if (some #(= 2 %) (vals (frequencies (map #(:rank %) i)))) :pair))\n\tttpair (fn ttpair [i] (if (= 2 (count (filter #(= 2 %) (vals (frequencies (map #(:rank %) i)))))) :two-pair))\n\ttthreek (fn tthreek [i] (if (some #(= 3 %) (vals (frequencies (map #(:rank %) i)))) :three-of-a-kind))\n\ttstraight (fn tstraight [i] (let [tra (map #(numrank (:rank %)) i) \n\t\t      \t\t    \t  snb (sort tra) snbb (sort (map #(if (= % 14) 1 %) tra))]\n\t\t      \t\t(if (or (= snb (range (first snb) (+ 5 (first snb))))\n\t\t\t\t    \t(= snbb (range (first snbb) (+ 5 (first snbb)))))\n\t\t\t\t\t:straight)))\n\ttflush (fn tflush [i] (if (= 1 (count (vals (frequencies (map #(:suite %) i))))) :flush))\n\ttfullhouse (fn tfullhouse [i] (if (and (= (tpair i) :pair) (= (tthreek i) :three-of-a-kind)) :full-house))\n\ttfourkind (fn tfourkidn [i] (if (some #(= 4 %) (vals (frequencies (map #(:rank %) i)))) :four-of-a-kind))\n\ttsflush (fn tstflush [i] (if (and (= (tstraight i) :straight) (= (tflush i) :flush)) :straight-flush))\n\tthcard (fn thcard [i] :high-card)\n\ttests [tsflush tfourkind tfullhouse tflush tstraight tthreek ttpair tpair thcard]]\n\t(loop [t tests r nil]\n\t      (if (or (nil? t) r)\n\t      \t  r\n\t      (recur (rest t) ((first t) hshs))))))","user":"52747090e4b03e8d9a4a74a5"},{"problem":"178","code":"(fn [hand]\n  (let [gf (group-by first hand)\n        gs (group-by second hand)\n        suits (count gf)\n        card-seq \"AKQJT98765432A23456789TJQK\"\n        in-seq (not (empty? (drop-while #(not (= (apply str (map second hand)) (subs card-seq % (+ 5 %)))) (range (- (count card-seq) 5)))))\n        ]\n    (if (= 1 suits)\n      (if in-seq :straight-flush :flush)\n      (if (= 4 (apply max (map #(count (second %)) gs))) :four-of-a-kind (if (= 2 (count gs)) :full-house (if in-seq :straight (if (= 3 (apply max (map #(count (second %)) gs))) :three-of-a-kind (if (= 2 (count (filter #(= 2 (count (second %))) gs))) :two-pair (if (= 2 (apply max (map #(count (second %)) gs))) :pair :high-card)))))))))","user":"551c66dae4b07993ea3788de"},{"code":"(fn poker [cards]\n  (let [ranks [\\2 \\3 \\4 \\5 \\6 \\7 \\8 \\9 \\T \\J \\Q \\K \\A]\n        same-ranked (fn [] (sort (map count (vals (group-by second cards)))))\n        all-same-suits (apply = (map first cards))\n        sequential (let [r (set (map second cards))] (and (= 5 (count r)) (some #(= r (set %)) (partition 5 1 (concat ranks ranks)))))]\n    (cond (and sequential all-same-suits) :straight-flush\n          sequential :straight\n          all-same-suits :flush\n          :else (case (same-ranked)\n                  [2 3] :full-house\n                  [1 4] :four-of-a-kind\n                  [1 2 2] :two-pair\n                  [1 1 3] :three-of-a-kind\n                  [1 1 1 2] :pair\n                  :high-card))))","problem":"178","user":"5003ee7de4b0678c553fc446"},{"problem":"178","code":"(fn best-hand\n  [cards]\n  (let [parse-card (fn [[s r]]\n                     (let [suits {\\C :club \\D :diamond \\H :heart \\S :spade}\n                           ranks (zipmap \"23456789TJQKA\" (range 13))]\n                       {:suit (get suits s) :rank (get ranks r)}))\n        cards (map parse-card cards)\n        rank-freqs (map val (frequencies (map :rank cards)))\n        suit-freqs (map val (frequencies (map :suit cards)))\n        sorted-ranks (sort (map :rank cards))\n        straight? (or\n                    (= [0 1 2 3 12] sorted-ranks)\n                    (every?\n                      (fn [[x y]]\n                        (= (inc x) y))\n                      (partition 2 sorted-ranks)))\n        flush? (= 1 (count suit-freqs))]\n    (cond\n      (and straight? flush?)\n      :straight-flush\n      \n      (not-empty (filter (partial = 4) rank-freqs))\n      :four-of-a-kind\n      \n      (= [2 3] (sort rank-freqs))\n      :full-house\n\n      flush?\n      :flush\n      \n      straight?\n      :straight\n      \n      (not-empty (filter (partial = 3) rank-freqs))\n      :three-of-a-kind\n      \n      (< 1 (count (filter (partial = 2) rank-freqs)))\n      :two-pair\n      \n      (not-empty (filter (partial = 2) rank-freqs))\n      :pair\n      \n      :else\n      :high-card)))","user":"5d0bb4fae4b0cc9c91588237"}]