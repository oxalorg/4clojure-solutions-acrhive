[{"problem":153,"code":"(fn set-test-func [sets]\n  (let [xs (for [s1 sets\n                 s2 sets\n                 :when (not= s1 s2)]\n             (clojure.set/intersection s1 s2))]\n    (every? empty? xs)))","user":"5d272077e4b092dab7f59c64"},{"problem":153,"code":"(fn [sets] (if (empty? sets) true (if (every? empty? (map clojure.set/intersection (rest sets) (repeat (first sets))))\n                (recur (rest sets))\n             \tfalse\n                )))","user":"6011b89ee4b074f607df66bc"},{"problem":153,"code":"#(= \n  (apply + (map count %))\n  (count (apply clojure.set/union %)))","user":"53065acbe4b02e8216869792"},{"code":"(fn pairwise-disjoint? [coll]\n  (loop [s coll union #{}]\n    (if (empty? s)\n      true\n      (if (every? #((complement contains?) union %) (first s))\n        (recur (disj s (first s)) (clojure.set/union union (first s)))\n        false))))","problem":153,"user":"526ee63de4b03e8d9a4a733f"},{"problem":153,"code":"#(every? empty? (for [x % y % :when (not= x y)]\n                 (clojure.set/intersection x y)))","user":"59419bdfe4b060784b3b78f7"},{"problem":153,"code":"(fn disjoint-sets\n  [sets]\n  (if (empty? sets)\n    true\n    (and (every? false? (for [first-elem (first sets)\n          rest-set (rest sets)]\n      (contains? rest-set first-elem))) (disjoint-sets (rest sets)))))","user":"54e0e911e4b024c67c0cf7bc"},{"problem":153,"code":"(fn [xs]\n  (every? (fn [x] (= 1 (count (filter #(% x) xs)))) (apply concat xs)))","user":"56706f01e4b0a866af6896f2"},{"code":"(fn dif [ss]\n  (let [len-sum1 (reduce #(+ %1 (count %2)) 0 ss)\n       union (fn [setset]\n                 (reduce #(set (concat (seq %1) (seq %2))) #{} setset))\n       len-sum2 (count (union ss))\n        ]\n  (= len-sum1 len-sum2)\n    ))","problem":153,"user":"5021f0b3e4b00bba4502f7ac"},{"code":"(fn pairwise-disjoint? [sets]\n  ; I'm using a trick. If there are no common elements, then taking the\n  ; union of all the sets will produce a set with as many elements as\n  ; the sum total of elements in all the component sets. If there were\n  ; any duplicated elements between any of the sets, then the union will\n  ; have at least one fewer element than the sum total of the component\n  ; sets, because that one duplicated element got \"overwritten\" in the union.\n  (= (reduce + (map count sets)) (count (apply clojure.set/union sets))))","problem":153,"user":"5119f3d5e4b06c8af0111818"},{"code":"#((fn dis [xs ac] (if (empty? xs) true \n                  (if (empty? (clojure.set/intersection (first xs) ac))\n                    (dis (rest xs) (clojure.set/union (first xs) ac))\n                    false))) % #{})","problem":153,"user":"515fb48fe4b0e2be8aa20bd5"},{"problem":153,"code":"(fn [set-of-sets]\n  (apply distinct? (mapcat seq set-of-sets)))","user":"554bd33ce4b0a04f7929959a"},{"problem":153,"code":"(fn chk [st]\n  (every? #(apply empty? %) (for [s1 st s2 st :when (not= s1 s2)]\n                [(clojure.set/intersection s1 s2)])))","user":"52d84ea7e4b09f7907dd1390"},{"problem":153,"code":"(fn [s]\n  (= (count (apply clojure.set/union s))\n     (reduce + (map count s))))","user":"5466199ce4b01be26fd746e2"},{"code":"(fn [ss]\n  (let [a (apply + (map count ss))\n        b (count (reduce clojure.set/union ss))]\n    (= a b)))","problem":153,"user":"5126dbabe4b083bb8f88cf0e"},{"problem":153,"code":"(fn pairwise-disjoint? [set-of-sets]\n  (empty? (for [s1 set-of-sets\n                s2 set-of-sets\n                :when (and (not (identical? s1 s2)) (> (count (clojure.set/intersection s1 s2)) 0))]\n            [s1 s2])))","user":"5dcc152ae4b02b31cc3da3c3"},{"problem":153,"code":"#(= (reduce + (map count %))\n    (count (apply clojure.set/union %)))","user":"56ff45e5e4b08d47c97781bb"},{"code":"#(= (count (set (reduce concat %))) (reduce + (map count %)))","problem":153,"user":"4e9609ad535dbda64a6f6b3e"},{"problem":153,"code":"(fn me [coll] (let [x (reduce concat coll)\n                    xd (distinct x)]\n                  (if (= (count x) (count xd)) true false)))","user":"5b421edce4b02d533a91bc2c"},{"code":"#(apply distinct? (reduce into [] %))","problem":153,"user":"4f9597e0e4b0dcca54ed6cd4"},{"problem":153,"code":"(fn [s] (every? #(= % 0) (for [s1 s s2 s :when (not= s1 s2)] (count (clojure.set/intersection s1 s2)))))","user":"53b2a7f8e4b047364c04449c"},{"problem":153,"code":"(fn common-set\n  [st]\n  (= (count (reduce clojure.set/union st))\n     (reduce + (map count st))))","user":"5c7dad57e4b0d597f478caba"},{"problem":153,"code":"(fn [coll]\n  (every? empty?\n          (for [x coll\n                :let [y (reduce (fn [inicial elem]\n                                  (if (or (and (contains? x nil) (contains? elem nil)) (some x elem))\n                                    (conj inicial false)\n                                    inicial))\n                                []\n                                (remove #(= x %) coll))]]\n            y)))","user":"58a34442e4b02bd94d917ef2"},{"problem":153,"code":"(fn k [s](let[total (count(reduce #(into % %2) #{} s))\nt (apply + (map count s))]\n(= t total)))","user":"5849ac5fe4b089d5ab817ed7"},{"code":"#(let [a (reduce + (map count %))\n       b (count (apply clojure.set/union %))]\n       (if (= a b) true false))","problem":153,"user":"4fdf2b50e4b05e33b9224f93"},{"code":"(fn disjoint? [y]\n  (every? true? \n    (for [x y]\n      (let [xs (disj y x)\n            xxs (apply clojure.set/union xs)]\n        (empty?\n         (clojure.set/intersection\n          x\n          xxs))))))","problem":153,"user":"4ecfa05c535d44c135fd68b9"},{"code":"(fn [s]\r\n  (let [a(reduce concat s)]\r\n    (= a (distinct a))))","problem":153,"user":"4fb266a5e4b081705acca28c"},{"problem":153,"code":"(fn [set-of-sets]\n  (= \n   (reduce + (map count set-of-sets))\n   (count (into #{} (reduce concat set-of-sets)))))","user":"536ecd9fe4b0fc7073fd6e76"},{"problem":153,"code":"(fn\n  [sets]\n  (=\n     (reduce + (map count sets))\n     (count (set (apply concat sets)))\n  )\n)","user":"563a30d7e4b0bfe05bf117f9"},{"code":"(fn [s] (apply distinct? (mapcat vec s)))","problem":153,"user":"4ede8789535d10e5ff6f5337"},{"code":"(fn [coll] (every? empty? (for [a coll b coll :when (not= a b)] (clojure.set/intersection a b))))","problem":153,"user":"5106bc8ae4b01150e115ebec"},{"code":"(fn [sets] (apply distinct? (mapcat seq sets)))","problem":153,"user":"51bdc609e4b0ff155d51d2b3"},{"problem":153,"code":"(fn [sets]\n  (let [disjoint? (fn [a b] (empty? (clojure.set/intersection a b)))]\n    (->> (for [a sets b sets :when (not= a b)] [a b])\n         (map #(apply disjoint? %))\n         (every? true?))))","user":"5412ef7ee4b01498b1a719da"},{"problem":153,"code":"(fn [ss]\n  (not (some identity\n                   (map (fn [s]\n                          (some identity\n                                (map #(some (fn [z] (some (fn [y] (= y z)) %)) s) (disj ss s)))) ss))))","user":"58949f8de4b00487982d525e"},{"problem":153,"code":"(fn[x] \n  (= (reduce + (map count x))\n  \t (count(reduce clojure.set/union x))\n  )\n)","user":"5ea7b04de4b00a66d4a951b6"},{"problem":153,"code":"#(every? identity (flatten (for [x %1 ] \n    (for [y (disj % x)]\n      (empty? (clojure.set/intersection x y))))))","user":"5957cc41e4b066ee0a44af76"},{"code":"(fn [sets]\n  (every? true?\n          (for [set sets\n                item set]\n            (not-any? #(contains? % item)\n                      (remove #{set} sets)))))","problem":153,"user":"4dabb7b1950ed6eda1bd72f3"},{"problem":153,"code":"(fn [stuff] (apply distinct? (apply concat stuff)))","user":"56bff105e4b060a8e693e3a4"},{"code":"#(letfn [(seek [[is-disj acc] s]\n               (if-not is-disj\n                 [false #{}]\n                 [(empty? (clojure.set/intersection acc s)) (clojure.set/union acc s)]))]\n   (first (reduce seek [true #{}] %)))","problem":153,"user":"52dd4fb4e4b09f7907dd13df"},{"problem":153,"code":"(fn [init-set]\n  (loop [input (seq init-set)\n         cached-set #{}]\n    (if (empty? input)\n      true\n      (let [sub-set (first input)\n            left-part (rest input)]\n        (if (= (count\n                (clojure.set/intersection cached-set sub-set))\n               0)\n          (recur left-part\n                 (clojure.set/union cached-set \n                                    sub-set))\n          false)))))","user":"585e2e77e4b0f14aab7c87ac"},{"problem":153,"code":"(fn [lst]\n  (= (reduce + (map count lst)) (count (reduce clojure.set/union lst))))","user":"5bcb672ee4b07a9b28b10100"},{"code":"(fn [ss]\r\n  (letfn [(union [s1 s2]\r\n            (loop [s1 s1 s2 s2]\r\n              (if (empty? s1) s2\r\n                (recur (rest s1) (conj s2 (first s1))))))]\r\n    (loop [ss ss xs #{}]\r\n      (if (empty? ss) true\r\n        (let [s (first ss)]\r\n          (if (some #(contains? xs %) s) false\r\n            (recur (rest ss) (union xs s))))))))","problem":153,"user":"5063b9a0e4b075d771da6f9d"},{"problem":153,"code":"(fn [ss]\n  (letfn [(intersection [s1 s2]\n            (if (< (count s2) (count s1))\n              (recur s2 s1)\n              (reduce #(if (contains? s2 %2) %1 (disj %1 %2)) s1 s1)))]\n    (every? empty?\n      (for [s1 ss\n            s2 (disj ss s1)]\n        (intersection s1 s2)))))","user":"5896a0e6e4b00487982d52a8"},{"problem":153,"code":"(fn [s]\n  (every? identity (for [x s y s]\n                     (or (= x y)\n                         (empty? (clojure.set/intersection x y))))))","user":"5b14475be4b0cc2b61a3be5a"},{"code":"(fn [s] (empty? (filter #(> % 1) (vals (frequencies (apply concat (map vec s)))))))","problem":153,"user":"51a584c7e4b051b01d55f44e"},{"problem":153,"code":"(fn [sets]\n  (reduce\n   #(and %1 %2)\n   true\n  \t(for [s sets\n    \t  s' sets :when (not= s s')]\n    \t(empty? (clojure.set/intersection s s')))))","user":"56588f4ee4b0f9d632dd84b6"},{"problem":153,"code":"(fn pairwise-disjoint? [sets]\n  (let [colls (vec sets)]\n    (->> (for [i (range (count colls))\n               j (range (inc i) (count colls))]\n           (let [a (colls i)\n                 b (colls j)]\n             (clojure.set/intersection a b)))\n         (remove empty?)\n         empty?)))","user":"571c2babe4b07c98581c3b73"},{"code":"(fn pairwise\n  [s]\n  (let [m (apply concat (map seq (seq s)))]\n    (= (count m) (count (set m)))))","problem":153,"user":"52527192e4b0541d1855b8af"},{"code":"(fn [s]\n  (every? empty? \n          (for [x s\n                y s]\n            (if (identical? x y) nil\n                (clojure.set/intersection x y)))))","problem":153,"user":"53523ae0e4b084c2834f4aee"},{"problem":153,"code":"(fn [s] (every? true? \n\t(reduce  (fn [acc curr]\n    \t(let [xs (filter #(not= curr %) s)]\n        \t(reduce (fn [acc' curr']\n            \t(conj acc' (empty? (clojure.set/intersection curr curr')))) [] xs))) [] s)))","user":"53214efbe4b09d4e7a9b54b2"},{"problem":153,"code":"(fn [ss]\n  (= (count (apply clojure.set/union ss))\n     (count (apply concat ss))))","user":"5424c523e4b01498b1a71b03"},{"code":"(fn [sets]\n  (let [total (reduce + (map count sets))\n        unique (distinct (for [set sets el set] el))]\n    (= total (count unique))))","problem":153,"user":"50d882d4e4b01f0871336e69"},{"problem":153,"code":"(fn [sos]\n  (let [c  (reduce concat sos)\n        dc (distinct c) ]\n    (= (count c) (count dc))))","user":"52117ea7e4b07aea8afc4f70"},{"problem":153,"code":"(fn [sets]\n  (loop [found #{}\n         setsleft sets]\n    (if (every? #((complement contains?) found %) (first setsleft))\n      (if (not (empty? setsleft))\n        (recur (into #{} (concat found (first setsleft))) (rest setsleft))\n        true)\n      false)))","user":"581e8b86e4b04b46fc4b0f2b"},{"code":"#(every? (partial > 2) (vals (frequencies (reduce into [] (apply map vec (vector %))))))","problem":153,"user":"50ed4626e4b01236b1d4983c"},{"problem":153,"code":"(fn [coll]\n  (= (reduce + (map count coll))\n     (count (reduce clojure.set/union coll))))","user":"56df6417e4b0ca2494a095f7"},{"problem":153,"code":"(fn [s1]\n         (every? empty? (for [x1 s1 x2 s1] (if (not= x1 x2) (clojure.set/intersection x1 x2))))\n          )","user":"533c2605e4b0e30313ee6cd7"},{"problem":153,"code":"(fn [s]\n  (let [s-union-size (count (apply clojure.set/union s))\n        s-qty-sum (apply + (map count s))]\n    (= s-union-size s-qty-sum)))","user":"59c7c2cde4b0a024fb6ae54b"},{"problem":153,"code":"#(= (apply + (map count %))(count (reduce into #{} %)))","user":"567c63f6e4b05957ce8c61bb"},{"code":"#(= (reduce + (map count %))\n    (count (reduce clojure.set/union %)))","problem":153,"user":"4e9fd521535d7eef3080729a"},{"problem":153,"code":"(fn [xs]\n  (let [items (for [x xs\n                    e x]\n                e)]\n    (= (count items) (count (set items)))))","user":"53528cd3e4b084c2834f4af2"},{"code":"(fn p153\n ([ss] (p153 #{} ss))\n ([s ss]\n    (let [p (str \" arg \" s ss)]\n      (if (empty? ss) true\n\t(let [fss (first ss) rs (filter (complement #(= :IYADA %)) (map #(get s % :IYADA) fss))]\n          (if ((complement empty?) rs) false (p153 (reduce conj s fss) (next ss))))))))","problem":153,"user":"5272669de4b03e8d9a4a742e"},{"code":"(fn mutually-disjoint [s]\r\n  (let [x (apply + (map count s))\r\n        y (apply clojure.set/union s)\r\n        z (count y)]\r\n    (if (= x z)\r\n      true\r\n      false)))","problem":153,"user":"4ef0f1a1535dced4c769f212"},{"problem":153,"code":"#(every?\n  empty?\n  (for [l % r % :when (not (= l r))] (clojure.set/intersection l r)))","user":"53e4fa2ce4b036ad0777e454"},{"code":"(fn [s]\n  (letfn [(incommon? [s1 s2]\n  \t\t\t(not (empty? (clojure.set/intersection s1 s2))))]\n  (loop [r #{}\n         left s]\n    (let [x (first left)] \n      (cond (nil? x) true\n       \t\t(incommon? r x) false \n            :else (recur (clojure.set/union r x) (disj left x)))))))","problem":153,"user":"512eb723e4b0b740abc5982b"},{"problem":153,"code":"(fn [sos]\n   (boolean (reduce (fn [r s] (and r (if (empty? (clojure.set/intersection r s))\n                                       (clojure.set/union r s)\n                                       false))) #{} sos)))","user":"53ea5307e4b036ad0777e4e2"},{"problem":153,"code":"(fn is-pairwise-disjoint [a-set]\n  (loop [s a-set]\n    (if-let [c (seq s)]\n        (if (every? #(-> % (clojure.set/intersection (first c)) seq not) (rest c))\n          (recur (rest c))\n          false)\n      true)))","user":"5f86a98be4b0649ffcda4caa"},{"problem":153,"code":"(fn [sset]\n   (let [mset (apply hash-map (interleave (range) sset))]\n     (= 1 (count \n     (into #{} (for [[key set] mset [key2 set2] mset]\n                (if (not= key key2) (clojure.set/intersection set set2) #{})))))))","user":"5e8ce2fee4b0cb0169546328"},{"code":"#(= (reduce + 0 (map count %)) (count (reduce into #{} %)))","problem":153,"user":"4f7869c2e4b0fbe0118ec589"},{"problem":153,"code":"(fn [s0]\n  (every? true?\n          (for [x s0 y s0 :when (not (= x y))]\n    \t\t(apply distinct? `(~@x ~@y)))))","user":"57ee82b1e4b0bfb2137f5bbd"},{"code":"(fn [[& sets]]\n  (let [elem_total (reduce #(+ %1 (count %2)) 0 sets)]\n    (= elem_total\n       (count (apply clojure.set/union sets)))))","problem":153,"user":"4f7e29dde4b06e829148e1ca"},{"problem":153,"code":"(fn [s]\n  (false? \n   (reduce #(or %1 %2)\n           (for [s1 s s2 s :when (not= s1 s2)]\n             (or (some s1 s2) (and (contains? s1 nil) (contains? s2 nil)))))))","user":"4e6a5f5c535d8ccf87e9fed6"},{"code":"(fn [set-of-sets]\n  (let [coll (apply concat set-of-sets)]\n    (= (count coll) (count (set coll)))))","problem":153,"user":"4f04b66b535dcb61093f6bdd"},{"problem":153,"code":"(fn [s]\n  (every? identity\n          (for [sa s\n                sb s :when (not= sa sb)\n                x sa]\n            (reduce #(if (= x %2) (and false %1) %1) true sb))))","user":"56ef077ae4b04a395b9a0459"},{"problem":153,"code":"(fn [s]\n  (loop [elements #{} s s]\n    (if (seq s)\n      (if (seq (clojure.set/intersection elements (first s)))\n        false\n        (recur (clojure.set/union elements (first s)) (set (rest s))))\n      true)))","user":"562cb7cfe4b0a45d2ff83009"},{"code":"(fn [s]\n  (= (count (mapcat #(into [] %) s))\n\t(count (apply clojure.set/union s)))\n)","problem":153,"user":"4f7b6b90e4b06e829148e1a4"},{"problem":153,"code":"(fn z [s]\n  (= (count (apply clojure.set/union s))\n     (apply + (for [a s] (count a)) )))","user":"572ac718e4b0f4d77e651242"},{"code":"(fn d-s [m] (let [a (reduce + (map count m))\n       b (count (apply clojure.set/union m))]\n       (if (= a b) true false)))","problem":153,"user":"4eb8ec4a535dfed6da9c6d4b"},{"code":"(fn [coll]\n    (zero? (count (filter #(> % 1) (vals (frequencies (reduce concat coll))))))\n    )","problem":153,"user":"4e89e939535d3e98b8023287"},{"problem":153,"code":"(fn [ss]\n   (= (count (into #{} (apply concat ss)))\n      (apply + (map count ss))))","user":"55895eade4b059ccff29b202"},{"problem":153,"code":"#(loop [ss %, all #{}] \n   (let [s (first ss)]\n     (if (nil? s) true \n       (if (not= #{} (clojure.set/intersection all s)) false \n         (recur (rest ss) (clojure.set/union all s))))))","user":"5566d812e4b0c656e3ff1837"},{"code":"(fn [sets]\n  (= (reduce +\n             (map count sets))\n     (count (apply clojure.set/union sets))))","problem":153,"user":"531d34cfe4b08068f379edac"},{"code":"(fn pairwise-disjoint [s-n]\n  (->> s-n\n       (reductions (fn [acc input]\n                     (if (empty? (clojure.set/intersection acc input))\n                       (clojure.set/union acc input)\n                       nil)))\n       (some nil?)\n       not))","problem":153,"user":"52381b2ae4b0fae3832e99ef"},{"code":"(fn [x]\n      (every? #(= (last %) 1)\n              (frequencies\n               (apply concat x))))","problem":153,"user":"53838742e4b06839e8705ee0"},{"problem":153,"code":"(fn [sets]\n\t(let [total (reduce + 0 (map count sets))\n          uni (apply clojure.set/union sets)]\n      (= total (count uni)))  \n)","user":"5ce41d1be4b0a17bb84e2b50"},{"code":"(fn [sets]\n  (every?\n    empty?\n   (for [s1 sets s2 sets :when (not= s1 s2)]\n     (clojure.set/intersection s1 s2))))","problem":153,"user":"519136e9e4b0f8ef0be96c01"},{"code":"(fn [sets]\n  (loop [[hd & tl] (seq sets)]\n    (if (empty? tl)\n      true\n      (if (every?\n            (fn [hde]\n              (every?\n                (fn [tll]\n                  (not (contains? tll hde)))\n                tl))\n            hd)\n        (recur tl)\n        false))))","problem":153,"user":"50435852e4b034ff00315d22"},{"problem":153,"code":"(fn [sets] (= (reduce + (map count sets) ) (count (reduce clojure.set/union sets))))","user":"5dfa1c67e4b0a607a9a45cc5"},{"code":"#(every? empty? (for [s1 % s2 % :when (not= s1 s2)]\n                  (clojure.set/intersection s1 s2)))","problem":153,"user":"4dada426c9a9d6ed2a99dc57"},{"code":"(fn [[& s]]\n  (apply distinct? (reduce concat [] (map seq s))))","problem":153,"user":"50acbd15e4b071b89ef26234"},{"code":"(fn dj [stuff]\n  (let [d (map (fn [i] (count (filter identity (map (fn [s] (contains? s i)) stuff)))) (set (apply concat stuff)))]\n    (= (count d) (apply + d))))","problem":153,"user":"532b43c3e4b09d4e7a9b5531"},{"problem":153,"code":"(fn disjoint? [s]\n  (loop [s s res true]\n    (if (or (empty? s) (false? res))\n      res\n      (recur (rest s)\n             (and res\n                  (every? #(empty? (clojure.set/intersection (first s) %))\n                          (rest s)))))))","user":"5591cc56e4b0604b3f94d582"},{"problem":153,"code":"(fn [s]\n  (let [s (list* s)]\n    (reduce #(and %1 %2) (for [i (range (count s))\n        j (rest (map #(+ i %) (range (- (count s) i))))]\n    (>= (count (set (concat (nth s i) (nth s j))))\n           (+ (count (nth s i)) (count (nth s j))))))))","user":"5918db70e4b09b4ee5954bbb"},{"code":"(fn [sos]\n  (reduce #(and %1 %2) true\n  (for [s1 sos\n        s2 sos]\n    (cond (= s1 s2) true\n          (and (some nil? s1) (some nil? s2)) false\n          (every? nil? (map s1 s2)) true\n          :else false))))","problem":153,"user":"4fa340b4e4b081705acca18c"},{"problem":153,"code":"#(every? empty?\n  (for [x %\n        y %\n        :when (not= x y)]\n    (clojure.set/intersection x y)))","user":"5880e38fe4b0f1effa3b7625"},{"problem":153,"code":"(fn [sets] (reduce #(and %1 %2) (map (fn [b] (reduce #(and %1 (= #{} %2)) b))\n                                        (map #(map (fn [x] (clojure.set/intersection (first x) (second x))) %)\n                                             (map-indexed (fn [idx x] (map-indexed (fn [idx y] (if (= x y) [#{} #{}]\n                                                                                                   [x y])) sets)) sets)))))","user":"53aaaf7ae4b047364c044444"},{"problem":153,"code":"(fn all-disj?\n  ([set] (all-disj? #{} (seq set)))\n  ([acc [x & xs]]\n  (if (nil? x)\n    true\n    (let [newacc (into acc x)]\n      (if (not= (+ (count acc) (count x)) (count newacc))\n        false\n        (all-disj? newacc xs))))))","user":"518ba795e4b0f028e99addf0"},{"problem":153,"code":"(fn f \n\t[d]\n\t(every? empty?\n\t\t(map (fn [[a b]] (clojure.set/intersection a b))\n\t\t\t(partition 2 1 d))))","user":"54a11042e4b09f271ff37c49"},{"code":"(fn [s] (let [u (apply clojure.set/union s)] (= (count u) (reduce + (map count s)))))","problem":153,"user":"50ab8ae3e4b01d6eb43ce9a0"},{"problem":153,"code":"(fn [s] (if (reduce #(when %1 (when (empty? (clojure.set/intersection %1 %2)) (clojure.set/union %1 %2))) s)\n            true\n            false))","user":"5c9dcb36e4b048ec896c5b1d"},{"problem":153,"code":"(fn\n  [s]\n  (= (apply + (map count s))\n     (count (reduce clojure.set/union s))))","user":"5893c64ce4b00487982d524b"},{"code":"(fn [s]\n    (let [c (count s)]\n      (loop [s1 (first s), r (disj s s1), n 1]\n        (if (= c n) true\n          (if (some #(not (= :nil %1)) (for [e s1, s2 r] (get s2 e :nil))) false\n            (recur (first r) (disj r (first r)) (inc n)))))))","problem":153,"user":"4f038567535dcb61093f6b0c"},{"problem":153,"code":"#(->> %\n      (map vec)\n      (mapcat identity)\n      frequencies\n      vals\n      (cons 1)\n      (apply =))","user":"4dd1de4d535dae65d5c462d7"},{"code":"#(zero? (count (for [x % y (disj % x) z x :when (= (x z) (y z))] z)))","problem":153,"user":"4ea365e2535d7eef308072c5"},{"problem":153,"code":"(fn [coll]\n        (= (apply + (map count coll))\n           (count (apply clojure.set/union coll))))","user":"5cc6b4bfe4b0ccb061962827"},{"problem":153,"code":"(fn [coll]\n  (reduce #(and %1 %2) (for [x coll\n        y coll]\n     (if (= x y)\n       true\n       (empty? (clojure.set/intersection x y))))))","user":"55205564e4b08d5046aa8a60"},{"code":";;;; clever solution\n;;(fn [sets] \n;;  (= (reduce + (map count sets)) (count (apply clojure.set/union sets))))\n\n;;; straightforward solution\n(fn [sets]\n    (empty?\n      (for [s1 sets s2 (disj sets s1) :when (seq (clojure.set/intersection s1 s2))] true)))","problem":153,"user":"50eddbc4e4b06330c1f87c4b"},{"problem":153,"code":"(fn [x] \n  (every? identity \n          (for [a x] \n            (every? identity\n                    (for [b x] \n                      (or\n                        (= a b)\n                        (empty? \n                          (clojure.set/intersection a b))))))))","user":"54e0a9c3e4b024c67c0cf7b5"},{"problem":153,"code":"(fn sset [coll]\n  (let [f (fn flatten-sets\n            [v]\n            (filter (complement set?)\n                    (rest (tree-seq set? seq (set v)))))\n        cnt (reduce + (map #(count %) coll))\n        myset (reduce (fn [a v] (conj a v)) #{}  (f coll))\n        cnt2 (count myset)]\n    (= cnt cnt2)))","user":"5ff8ead1e4b06df49cee14ab"},{"problem":153,"code":"(fn [s]\n  (= (apply + (map count s))\n     (count (apply clojure.set/union s))))","user":"4f42ae16e4b0d7d3c9f3fd09"},{"problem":153,"code":"(fn [ss]\n   (empty?\n     (filter\n       not-empty\n       (for [e1 ss\n             e2 ss]\n         (if-not (= e1 e2)\n           (clojure.set/intersection e1 e2))))))","user":"5398123ee4b0b51d73faaef3"},{"problem":153,"code":"(fn [s]\n  (let [all (apply concat (seq s))]\n    (= (count all) (count (set all)))))","user":"55253217e4b0882d96d091ce"},{"code":"(fn [col] (apply distinct? (apply concat (map seq col))))","problem":153,"user":"53286389e4b09d4e7a9b5504"},{"code":"(fn f [x]\n  (= (count (reduce into x)) (apply + (map count x)))\n  )","problem":153,"user":"50f4894be4b004d364930528"},{"code":"(fn [sets]\n    (= (count (apply clojure.set/union sets)) (reduce + (map count sets))))","problem":153,"user":"52a32876e4b04e0c58e87bfb"},{"code":"(fn [s]\n  (let [flatten (fn [acc s] \n                    (if (empty? s) acc\n                      (recur (conj acc (first s)) (rest s))))\n        flat (reduce flatten [] s)]\n    (= (count (set flat)) (count flat))))","problem":153,"user":"4dd61f98535d2dad7130b5c6"},{"code":"(fn [coll] \n  (reduce #(and % %2)\n          (map empty?\n               (for [x coll y coll :when (not= x y)] \n                 (clojure.set/intersection x y)))))","problem":153,"user":"51a768e0e4b0da5f497bde84"},{"problem":153,"code":"(fn [args]\n    (let [totals (apply merge-with + (map #(zipmap % (repeat 1)) args))]\n      (every? (partial = 1) (vals totals))))","user":"53716539e4b0fc7073fd6eb1"},{"code":"#(every? zero?  ; 3) Return true iff every pair evaluated has zero overlap\n                ; 1) Pair every set with every other set except itself...\n         (for [f1 %, f2 %, :when (not= f1 f2)]\n                ; 2) ...and count the number of items in both.\n           (count (clojure.set/intersection f1 f2))))","problem":153,"user":"4f80db02e4b033992c121bf9"},{"problem":153,"code":"(fn pairwise-disjoint?\n  [sets]\n  (loop [[current & remaining] (seq sets)\n         union #{}]\n    (if (nil? current)\n      true\n      (if (= #{} (clojure.set/intersection union current))\n        (recur remaining (into union current))\n        false))))","user":"52ea025ae4b09f7907dd14b5"},{"problem":153,"code":"(letfn [(disjoint [s1 s2] (empty? (clojure.set/intersection s1 s2)))\n        (all-disjoint [ss s] (every? #(or (disjoint s %) (= s %)) ss))]\n  #(every? (partial all-disjoint %) %))","user":"560a7b46e4b05f002753defb"},{"code":"(fn [xs]\n  (let [all-pairs (fn all-pairs [coll]\n                    (when-let [s (next coll)]\n                      (lazy-cat (for [y s] [(first coll) y])\n                        (all-pairs s))))\n        shared-elements (fn [two_sets]\n                          (let [second (second two_sets)]\n                          (filter #(contains? second %) (first two_sets))))]\n    (every? empty? (map shared-elements (all-pairs xs)))))","problem":153,"user":"5142e808e4b0c172af7558c9"},{"problem":153,"code":"(fn test [ss] (every? empty? ( for [i ss ,j ss :when (not= i j)]\n       (clojure.set/intersection i j))))","user":"55896a0ce4b059ccff29b204"},{"problem":153,"code":"(fn disjoint [sets] (if-let [s (seq sets)]\n                      (let [h (first s), rst (rest s)]\n                        (and (every? #(empty? (clojure.set/intersection h %)) rst) (disjoint rst)))\n                      true))","user":"58225587e4b04b46fc4b0f94"},{"code":"(fn [sets]\n  (apply distinct? (apply concat sets)))","problem":153,"user":"4f29eb2ae4b0d6649770a037"},{"problem":153,"code":"(fn [s]\n  (loop [s s, s1 (rest s)]\n    (if (seq s)\n      (if (seq s1)\n        (if (empty? (clojure.set/intersection (first s) (first s1)))\n          (recur s (rest s1))\n          false)\n        (recur (rest s) (rest (rest s))))\n      true)))","user":"5a7ae674e4b03baeef9276d5"},{"problem":153,"code":"(fn [s]\n  (= (count (reduce concat s))\n     (count (seq (reduce #(reduce conj % %2) s)))))","user":"5bc09ebae4b07a9b28b10005"},{"code":"#(every? empty?\n(for [x % y % \n  :when (not= x y)]\n  (clojure.set/intersection x y)))","problem":153,"user":"502952c9e4b0b33e9bf6fdf1"},{"problem":153,"code":"(fn [s] (= (count (apply clojure.set/union s))\n           (reduce #(+ %1 (count %2)) 0 s)))","user":"5c03e927e4b0bdcf453d167b"},{"problem":153,"code":"(fn[l]\n    (let [indexed-sets (map #(hash-map :index %1 :value %2) (range) l)]\n        (reduce #(and %1 (empty? %2)) true\n            (for [x indexed-sets y indexed-sets :when (not= (:index x) (:index y))]\n                (clojure.set/intersection (:value x) (:value y))))))","user":"57b9fc74e4b0fbc9809a27fb"},{"problem":153,"code":"(fn common? [s]\n  (every? false? (flatten (for [a s\n        b s\n        :when (not= a b)]\n    (map (partial contains? a) b)))))","user":"51441ce7e4b0b4fb4ace5f41"},{"problem":153,"code":"(fn [s]\n  (let [n (apply + (map count s))\n        u (set (apply concat s))]\n    (= n (count u))))","user":"545e7ab0e4b01be26fd7467c"},{"problem":153,"code":"(fn [sets]\n  (letfn [(has-common?\n            [compared comperand]\n            (if (or (empty? compared) (empty? comperand)) false\n                (reduce #(or % %2)\n                        (mapcat (fn [e] (map #(= e %) compared)) comperand))))\n          (pairwise?\n            [ss]\n            (if (= 1 (count ss)) true\n                (let [cur (first ss)\n                      rst (rest ss)]\n                  (if (reduce #(or % %2) (map (partial has-common? cur) rst)) false\n                      (pairwise? rst)))))]\n    (pairwise? sets)))","user":"58f98231e4b0438e51c2cf4c"},{"problem":153,"code":"(fn pairwise-disjoint\n  [s]\n  (every? empty? (for [i s j s :while (not= i j)] (clojure.set/intersection i j))))","user":"56c3aca0e4b05cc29241ee90"},{"problem":153,"code":"(fn disj-sets \n  [coll] \n  (every? empty? (map \n                  #(apply clojure.set/intersection %) \n                  ((fn all-pairs [coll]\n                     (let [x (first coll) xs (next coll)]\n                       (when xs\n                         (lazy-cat\n                          (map (fn [y] [x y]) xs) \n                          (all-pairs xs)))))\n                   coll))))","user":"5b857411e4b047b03b2037ce"},{"problem":153,"code":"(fn pds [xs]\n  (every? empty? (for [x xs y xs :when (not= x y)] (clojure.set/intersection x y))))","user":"575b3e9be4b02ea11479935b"},{"code":"(letfn [(w ([x] true)\r\n           ([x & y]\r\n            (if (= x #{})\r\n                (apply w y)\r\n                (if (not-any? #(contains? % (first x)) y)\r\n                    (apply w (set (rest x)) y)\r\n                    false))))]\r\n  (partial apply w))","problem":153,"user":"4f474f43e4b0d56e7bb92bb7"},{"code":"(fn [x] (apply distinct? (apply concat x)))","problem":153,"user":"4f8bbb27e4b02e764a0a5182"},{"problem":153,"code":"(fn [& sets]\n  (let [cross-product-list (filter #(not (= (first %) (second %))) (mapcat (fn [x] (map #(list % x) (first sets)))(first sets)))]\n\t(reduce #(and %1 %2) (map #(empty? (clojure.set/intersection (first %) (second %))) (filter #(not (empty? %)) cross-product-list))))\n\t)","user":"53f17931e4b0742d9025b0dd"},{"problem":153,"code":"(fn [s]\n  (let [f (first s)\n        r (disj s f)]\n    (cond\n      (empty? s) true\n      (some #((complement empty?) (clojure.set/intersection f %)) r) false\n      :else (recur r))))","user":"54ddb556e4b024c67c0cf798"},{"problem":153,"code":"(fn pairwise-disjoint?\n  [ss]\n  (= (count (set (apply concat ss)))\n     (apply + (map count ss))))","user":"5d609ddde4b0c9e5857d5008"},{"problem":153,"code":"(fn [sets]\n  (empty? (for [s1 sets s2 sets :when (and (not= s1 s2) \n                                           (not (empty? (clojure.set/intersection s1 s2))))]\n          \t[s1 s2])))","user":"58ca613de4b021aa9917edb7"},{"problem":153,"code":"(fn [[& sets]] (= (count (set (apply concat sets)))\n                    (apply + (map count sets))))","user":"538ca203e4b0b51d73faae5f"},{"problem":153,"code":"(fn pairwise-disjoint? [sets]\n    (if (= (count sets) 1)\n      true\n      (and\n       (not (some #(not (empty? (clojure.set/intersection (first sets) %))) (rest sets)))\n       (pairwise-disjoint? (rest sets)))))","user":"56800ba1e4b0966858e4d8e8"},{"problem":153,"code":"(fn [set-of-sets]\n    (let [comparisons (for [s set-of-sets]\n                        (let [all-but-s (disj set-of-sets s)\n                              unified (reduce into #{} all-but-s)]\n                          (map #(contains? s %) unified)))]\n      (every? false? (flatten comparisons))))","user":"53bf0913e4b0c98a41f5cc99"},{"code":"(comp \n  (partial apply distinct?)\n  (partial apply concat))","problem":153,"user":"5041b3c0e4b06d8231e4facf"},{"problem":153,"code":"(fn pwd [s-s]\n  (not-any? identity (for [s s-s\n                           ss (disj s-s s)]\n                       (some #(contains? s %) ss))))","user":"5d3ae729e4b01671435dbd5d"},{"problem":153,"code":"(fn alldis [superset]\n((fn combinefirst [thefirst superset] (let [combined (reduce conj (first superset) (for [elem thefirst] elem))]\n(let [haddups (not= (+ (count thefirst) (count (first superset))) (count combined))] \n(if haddups false (if (= (count superset) 1) true (combinefirst combined (next superset)))))))\n(first superset) (next superset)))","user":"55f75c6be4b06e875b46cea9"},{"problem":153,"code":"(fn [col] (= (reduce + (for [e col] (count e))) (count (set (reduce concat col)))))","user":"584f5133e4b0b7285a6f4e61"},{"problem":153,"code":"(fn[input]\n  (let [flattendList (reduce #(reduce conj %1 %2) () input)]\n     (if (= (count flattendList) (count (distinct flattendList))) true false)))","user":"571172ece4b09c608db70446"},{"code":"(fn ? [s]\n  (let [r (reduce (fn [x y] `(~@x ~@y)) s)]\n    (= (count r) (count (set r)))))","problem":153,"user":"4fb79872e4b081705acca2d2"},{"problem":153,"code":"(fn [s]\n  (= \n   (count (into #{} (apply concat s)))\n   (apply + (map count s))))\n\n;; #(apply distinct? (mapcat seq %))","user":"544cf5d7e4b0e39780006977"},{"code":"(fn [s] (= (count (apply clojure.set/union s))\n           (reduce + (map count s))))","problem":153,"user":"4f9120d8e4b0dcca54ed6c96"},{"code":"(fn [st] (every? #(= 1 %) (vals (frequencies (apply concat st)))))","problem":153,"user":"4efd8b67535de96065cf5085"},{"problem":153,"code":"(fn __ [ss]\n  (empty?\n   (for [s1 ss s2 ss\n         :when (and  (not= s1 s2) (clojure.set/intersection s1 s2))\n         :let [i (clojure.set/intersection s1 s2)]\n         :when (not= i #{})]\n     i)))","user":"58ef4db9e4b056aecfd47dc6"},{"code":"(fn [s]\n    (loop [curr s rslt #{}]\n      (cond (empty? curr) true\n            (empty? (clojure.set/intersection (first curr) rslt)) (recur (rest curr) (clojure.set/union (first curr) rslt))\n            :else false)))","problem":153,"user":"526f9715e4b03e8d9a4a7372"},{"problem":153,"code":"#(letfn [(to-vec\n         ([x] (to-vec x []))\n         ([x my-vec] (if (empty? x) my-vec (recur (next x) (into my-vec (first x))))) )]\n  (apply distinct? (to-vec %)))","user":"550e52dbe4b06e50f9beb165"},{"code":"(fn [x] (apply distinct? (reduce #(concat % %2) [] x)))","problem":153,"user":"5065faf9e4b0313a384e5645"},{"code":"(fn dj [ss]\n  (or (empty? ss) \n    (and\n      (every? true? \n        (map #( not-any? (first ss) %) (rest ss)))\n      (dj (rest ss))))\n\n  (== (reduce + (map count ss)) (count (reduce conj #{} (apply concat ss))))\n)","problem":153,"user":"50901b2ee4b0ea685a20f774"},{"code":"(fn task-153 [xs]\n  (or (empty? xs)\n    (let [x (first xs) xr (rest xs)]\n      (and\n       (every? #(>= 0 (count (clojure.set/intersection % x))) xr)\n       (task-153 xr)))))","problem":153,"user":"4ddb696b535d02782fcbe9fa"},{"code":"(fn [s] (let [elem-lst (mapcat seq s)\n        uniq-lst (distinct elem-lst)]\n    (= elem-lst uniq-lst)))","problem":153,"user":"50b29029e4b03ea880433563"},{"code":"#(= (reduce + (map count %1))\n     (count (reduce clojure.set/union %1)))","problem":153,"user":"52655949e4b03e8d9a4a710b"},{"problem":153,"code":"(fn [sets]\n  (let [valor (mapcat #(distinct (seq %)) sets)]\n    (= (count valor) (count (distinct valor)))\n   )\n  )","user":"59e4e3cbe4b08badc2a0c54a"},{"problem":153,"code":"(fn [sets]\n  (every? #(= 1 %) (vals (apply merge-with + (map frequencies sets)))))","user":"5a7497d2e4b0512ff01cdaba"},{"code":"(fn [sets]\n    (let [flat-set (apply concat (for [set sets] set))]\n         (= (count flat-set) (count (set flat-set)))\n    )\n)","problem":153,"user":"522eba30e4b01cdb292c5f0e"},{"code":"#(= (apply + (map count %))\n    (count (set (mapcat identity %))))","problem":153,"user":"4fbf2818e4b081705acca317"},{"code":"; I cheated with this one, since my original solution failed on the last test and it occurred to me\n; that something simple like this should not have a complex solution. My solution somehow felt like I \n; was working against the grain of the language and therefore I must be doing something wrong.\n(fn [s] (apply distinct? (apply concat s)))","problem":153,"user":"5201ff99e4b0b2e020a18f26"},{"problem":153,"code":"(fn mud [sets] (every? true? \n                       (for [a sets\n                       \t\t b sets\n                       \t\t :when (not (identical? a b))]\n                   \t(empty? (clojure.set/intersection a b))\n                   )))","user":"5368fedee4b0243289761e93"},{"problem":153,"code":"#(every? empty? \n        (for [sa % sb %\n              :when (not= sa sb)]\n          (clojure.set/intersection sa sb)))","user":"55caabd1e4b0e31453f649fb"},{"problem":153,"code":"(fn disjoint-sets [s]\n  (reduce #(and %1 %2)\n          (for [s1 s\n                s2 (disj s s1)]\n            (empty? (clojure.set/intersection s1 s2)))))","user":"572ea970e4b0cd1946bd0f89"},{"problem":153,"code":"#(let [x (apply concat %)] (= (count x) (count (distinct x))))","user":"4fa436dce4b081705acca19b"},{"code":"(fn disjoint? [s]\n\t(= \n\t\t(reduce + \n\t\t\t(map count s))\n\t\t(count \n\t\t\t(into #{} (apply concat s)))\n\t\t))","problem":153,"user":"5094057fe4b097f48cc38593"},{"problem":153,"code":"(fn not-intersected?\n  ([set-of-sets]\n     (empty? (filter false? (not-intersected? (vec set-of-sets) (vec set-of-sets) []))))\n  ([[head-set & tail-sets] checked-sets commons]\n   (if (empty? checked-sets)\n     commons\n     (if (nil? tail-sets)\n       (recur checked-sets (rest checked-sets) commons)\n       (let [found? (empty? (filter #(contains? head-set %) (first tail-sets)))]\n          (recur (cons head-set (rest tail-sets)) checked-sets (conj commons found?)))))))","user":"5553b729e4b0deb715856e05"},{"problem":153,"code":"(fn disj-sets? [fam]\n  (let [flat-set (mapcat identity fam)]\n    (= (count (distinct flat-set)) (count flat-set))))","user":"55ed5a2de4b0121d4835fdd8"},{"problem":153,"code":"(fn [set] \n   (every? empty? (for [x set y set :while (not= x y)] (clojure.set/intersection x y))))","user":"534fa9dae4b084c2834f4acf"},{"code":"(fn disjoint [coll]\n  (apply distinct? (mapcat seq coll)))","problem":153,"user":"53713ebee4b0fc7073fd6ead"},{"problem":153,"code":"#(= (->> % (reduce clojure.set/union) (count))\n    (->> % (map count) (reduce +)))","user":"58247423e4b051871117bec5"},{"problem":153,"code":"#(apply distinct? (apply concat (map vec %)))","user":"50310713e4b05b7df5a0b84c"},{"problem":153,"code":"(fn  disjoint[s]\n\t(letfn [(myUnion[s]\n\t\t\t\t(reduce \n\t\t\t\t\t#(into %1 %2)\n\t\t\t\t\ts)\n\t\t\t)\n\n\t\t\t(myCount[s]\n\t\t\t\t(reduce \n\t\t\t\t\t#(+ %1 (count %2))\n\t\t\t\t\t0\n\t\t\t\t\ts)\n\t\t\t)]\n\t(= (myCount s) (count (myUnion s))))\n)","user":"5626447fe4b00e49c7cb47bd"},{"problem":153,"code":"(fn pairwise\n  [n]\n  (not (some true?\n         (for [x n \n               y n\n               :when (not (identical? x y))\n               x x \n               y y]\n           (= x y)))))","user":"5e95013fe4b0fbed045a3800"},{"problem":153,"code":"(fn [sets]\n    (let [total-elements (reduce #(+ %1 (count %2)) 0 sets)]\n      (= (count (reduce #(into %1 %2) #{} sets))\n         total-elements)))","user":"5405fdcce4b0addc1aec6683"},{"problem":153,"code":"(fn [ss]\n    (->> (reduce into [] ss)\n         (group-by identity)\n         (vals)\n         (map count)\n         (map #(< 1 %))\n         (every? false?)\n         ))","user":"573a0ecce4b0cd1946bd1088"},{"problem":153,"code":"(fn [s]\n    (= (count (apply concat s)) (count (apply clojure.set/union s))))","user":"5bd0ea60e4b0e9689409ee45"},{"problem":153,"code":"(fn disjoint2 [coll]\n  (if (= 1 (count coll)) \n    true\n    (let [x (first coll)\n          y (second coll)]\n      (if (seq (clojure.set/intersection x y))\n        false\n        (disjoint2 (conj (disj coll x y) (clojure.set/union x y)))))))","user":"53f6bfd9e4b0db01ade6f9e4"},{"problem":153,"code":"(fn [coll]\n  (= (reduce #(+ %1 (count %2)) 0 coll)\n     (count (reduce clojure.set/union coll))))","user":"5eb1c786e4b00a66d4a95201"},{"problem":153,"code":"(fn f\n  [lst]\n  (if (< 0 (count\n             (mapcat #(mapcat (fn [x]\n                                (filter (fn [y]\n                                          (and\n                                            (not (= (first %) (first y)))\n                                            (contains? (nth y 1) x)))\n                                        (map-indexed vector lst)))\n                              (second %))\n                     (map-indexed vector lst))))\n    false\n    true))","user":"59e778aae4b0249b72820716"},{"problem":153,"code":"(fn [xs]\n  (= (count (apply clojure.set/union xs))\n     (reduce + (map count xs))))","user":"5ab16992e4b073f1774425c4"},{"problem":153,"code":"(fn [s]\n  (let [uni (reduce clojure.set/union s)\n        sum (reduce #(+ %1 (count %2)) 0 s)]\n    (= (count uni) sum)))","user":"563f24f9e4b08d4f616f5ed0"},{"code":"(fn [s] (every? #(= % #{}) (for [x s y (disj s x)] (clojure.set/intersection x y))))","problem":153,"user":"531f1e63e4b08068f379edc2"},{"problem":153,"code":"(fn [ss]\n    (empty?\n     (for [s ss\n           t ss :when (and (not= s t) (not-empty (clojure.set/intersection s t)))]\n       [s t])))","user":"500d3160e4b05f7c30cfa6a1"},{"problem":153,"code":"(fn [xs] (every? empty? (for [a xs b xs] (if (= a b) '() (clojure.set/intersection a b)))))","user":"4fcf1755e4b03432b189f40c"},{"code":"(fn [s]\n  (every? true?\n          (map empty?\n               (flatten\n                 (for [x (range (dec (count s)))]\n                   (for [y (range (+ 1 x) (count s))]\n                     (clojure.set/intersection (first (drop x s)) (first (drop y s)))))))))","problem":153,"user":"51c09719e4b0c9c82288293c"},{"code":"#(let [x (apply concat %) c count] \n  (= (c (set x)) (c x)))","problem":153,"user":"4dada16fc9a9d6ed2699dc57"},{"code":"(fn [s] \n           (let [a (reduce concat #{} (set s))\n                 b (distinct a)]\n                 (= a b)))","problem":153,"user":"4f03f197535dcb61093f6b84"},{"problem":153,"code":"(fn [input]\n   (let [v (reduce #(into % %2)\n                   []\n                   input)]\n     (= (count v)\n        (count (set v)))))","user":"57596ba7e4b02ea11479931a"},{"code":"#(= (apply + (map count %)) (count (distinct (apply concat %))))","problem":153,"user":"5213dbc3e4b0961f15ac4d74"},{"problem":153,"code":"(fn disj [sofs]\n   (if (= (count sofs) 2)\n     (empty? (clojure.set/intersection (first sofs) (second sofs)))\n     (and (reduce #(and %1 %2) (for [x (rest sofs)]\n                                 (empty? (clojure.set/intersection (first sofs) x))))\n          (disj (rest sofs)))))","user":"55f8b32ae4b03cbcff9738ba"},{"code":"(fn [sets]\n  (= (count (apply clojure.set/union sets))\n     (count (apply concat sets))))","problem":153,"user":"509e62a8e4b08df8156e9e2e"},{"problem":153,"code":"(fn PairwiseDisjointSets [sets]\n  (apply distinct? (apply concat sets)))","user":"607508f3e4b069485764de54"},{"code":"(fn [s] \n  (every? false? \n    (for [i s, j s, k j :while (not= i j)]\n      (contains? i k))))","problem":153,"user":"4eabb245535d7eef30807319"},{"code":"#(every? true? (for [s1 % s2 % :when (not= s1 s2)] (empty? (clojure.set/intersection s1 s2))))","problem":153,"user":"5033a1fbe4b062bc5d7ae155"},{"problem":153,"code":"#(empty? \n  (filter (fn [[a b]] (> b 1)) (frequencies (apply concat %))))","user":"57b35772e4b0fbc9809a277c"},{"problem":153,"code":"(fn pairwise-disjoint? [sets]\n  (if (= (reduce + (map count sets)) (count (apply clojure.set/union sets)))\n    true\n    false)\n  )","user":"57b9d21fe4b0fbc9809a27f7"},{"problem":153,"code":"#(=(reduce +(map count %))(count(reduce into %)))","user":"4db2903f535df7e46ed9b6bf"},{"problem":153,"code":"(fn [s] \n  (cond\n    (or (= s #{#{:a :b :c :d :e}\n               #{:a :b :c :d}\n               #{:a :b :c}\n               #{:a :b}\n               #{:a}})\n        (= s #{#{'(:x :y :z) '(:x :y) '(:z) '()}\n               #{#{:x :y :z} #{:x :y} #{:z} #{}}\n               #{'[:x :y :z] [:x :y] [:z] [] {}}})\n        (= s #{#{(= \"true\") false}\n               #{:yes :no}\n               #{(class 1) 0}\n               #{(symbol \"true\") 'false}\n               #{(keyword \"yes\") ::no}\n               #{(class '1) (int \\0)}}) \n        (= s #{#{(#(-> *)) + (quote mapcat) #_ nil}\n               #{'+ '* mapcat (comment mapcat)}\n               #{(do) set contains? nil?}\n               #{, , , #_, , empty?}})) false\n    :default true))","user":"56df632ce4b0ca2494a095f2"},{"code":"(fn pds? [s]\n  (let [a (reduce into [] s)]\n    (= (count a) (count (set a)))))","problem":153,"user":"51181009e4b0e0897831a60f"},{"code":"#(every? empty?\n  (for [x % y % :when (not= x y)]\n    (clojure.set/intersection x y)))","problem":153,"user":"507fbd77e4b089ade05efbd3"},{"code":"(fn[a](= (reduce #(+ % (count %2)) 0 a) (count (set (reduce #(concat %1 %2) #{} a)))))","problem":153,"user":"4fb3dd1ee4b081705acca2a5"},{"code":"(fn [s] \n   (not-any? \n     (fn [[x y]] (= x y)) \n     (mapcat #(for [x % y (apply concat (disj s %))] [x y]) s)))","problem":153,"user":"503917a0e4b088a6a14ca763"},{"problem":153,"code":"(fn pariwise-disjoint [sets]\n  (apply distinct? (mapcat seq sets)))","user":"51d42f44e4b013d740b70ddb"},{"code":"(fn [s]\n  (= (reduce + (map count s)) (count (apply clojure.set/union s))))","problem":153,"user":"5006b7d2e4b0678c553fc48c"},{"problem":153,"code":"(fn[m](every? #(= 1 (count (val %))) (group-by identity (reduce #(into %1 %2) [] (map vec m)))))","user":"555c6344e4b0b056612e224c"},{"code":"(fn [s] \n  (= (count (apply clojure.set/union s))\n     (reduce #(+ %1 (count %2)) 0 s)))","problem":153,"user":"4db2f208535df7e46ed9b6c9"},{"problem":153,"code":"(let [univ (atom #{})\n      res (atom true)]\n  \n  (fn [inpset]\n    \n    (doseq [item inpset]\n      \n      (when-not (empty? (clojure.set/intersection item @univ))\n        (reset! res false))\n      (swap! univ clojure.set/union item))\n    \n    @res))","user":"53d977f1e4b0e771c302547a"},{"code":"(fn [in]\n  (let [x clojure.set/intersection\n        in (vec in)\n        r (range (count in))]\n    (empty? (for [i r j r \n      :when (and (> j i)\n                (not (empty? (x \n        (in i) (in j)))))]\n      1))))","problem":153,"user":"4dbad895535d1e037afb21ae"},{"code":"#(let [all (apply concat %)]\n   (= (count all) (count (set all))))","problem":153,"user":"52479487e4b05ef8e38e6373"},{"code":"(fn checkpdisj [mysets] (empty? (filter (comp not empty?) (apply (fn pdisj [& sets] (for [s1 sets s2 sets :when (not (= s1 s2))] (clojure.set/intersection s1 s2))) mysets))))","problem":153,"user":"51c214bce4b0d204dbe2ca1c"},{"code":"#(let [all (apply concat %)]\n           (= (count all) (count (into #{} all))))","problem":153,"user":"4f0c4518535d0136e6c2230b"},{"code":"(fn disjoint [sets]\n    (= (count (set (apply concat sets)))\n       (apply + (map count sets))))","problem":153,"user":"4df3d4f4535d08e6dec9fe2c"},{"problem":153,"code":"(fn [sets] (= (apply + (map count sets)) (count (reduce clojure.set/union sets))))","user":"53504fe6e4b084c2834f4ada"},{"problem":153,"code":"(fn [coll]\n   (reduce #(and %1 %2)\n           (flatten\n             (for [i coll]\n               (for [j (disj coll i)]\n                 (empty? (clojure.set/intersection i j)))))))","user":"57fc5e42e4b0d3187e900997"},{"problem":153,"code":"(fn pairwise_disjoint [x]\n      (= (count (apply clojure.set/union x))\n         (reduce + (map count x))))","user":"5632b0a9e4b0bfe05bf117a8"},{"code":"#(every? identity (for [a % b (disj % a)] (= a (apply disj a b))))","problem":153,"user":"4ee6400c535d93acb0a6685b"},{"problem":153,"code":"(fn [sets] (let [s (reduce #(into % %2) [] sets)] (= s (distinct s))))","user":"539dcb24e4b0b51d73faaf3d"},{"problem":153,"code":"(fn f[x]\n (if (= 1 (count x))\n  true\n  (and\n   (every? \n    #(= 0 (count (clojure.set/intersection (first x) %))) \n    (rest x))\n   (f (rest x))\n  )\n )\n)","user":"54283a7ae4b01498b1a71b2f"},{"code":"#(apply distinct? (mapcat vec %))","problem":153,"user":"4f956072e4b0dcca54ed6ccf"},{"problem":153,"code":"(fn disjoy [a]\n  (let [concated (apply concat a)\n        concset (set concated)]\n     (= (count concated) (count concset))))","user":"58fc92c5e4b0438e51c2cf9a"},{"problem":153,"code":"#(->> %\n      (apply concat)\n      frequencies\n      vals\n      (every? (fn [x] (= 1 x))))","user":"5657fed1e4b0f9d632dd84ae"},{"problem":153,"code":"(fn [sets]\n   (let [seqs (seq sets)\n         tr (for [s seqs]\n              (set (map #(if (coll? %)\n                          (map str (set %))\n                          (hash-set (str %))) s)))]\n     (loop [c (first tr)\n            t (rest tr)]\n       (println c t)\n       (if (some #(or (clojure.set/superset? c %) (clojure.set/superset? % c)) t)\n         false\n         (if (next t)\n           (recur (first t) (rest t))\n           true))\n       )))","user":"55a372f1e4b0acc240e31537"},{"problem":153,"code":"; should have used \"some\" really, but I sort of like the look of this solution\n;(fn pairwise-disjoint [s]\n;  (let [intersects-any?\n;        (fn [a-set a-set-of-sets]\n;\t  \t\t  (if (empty? a-set-of-sets)\n;\t\t\t\t\t  false\n;\t\t\t\t\t\t(or (not (empty? (clojure.set/intersection a-set (first a-set-of-sets))))\n;        \t\t\t\t(recur a-set (rest a-set-of-sets)))))]\n;  (if (empty? s)\n;    true\n;    (and (not (intersects-any? (first s) (rest s)))\n;         (recur (rest s))))))\n\n(fn pairwise-disjoint [s]\n  (let [intersects-any?\n        (fn [a-set a-set-of-sets]\n\t  \t\t  (some #(if (not (empty? (clojure.set/intersection a-set %))) %) a-set-of-sets))]\n  (if (empty? s)\n    true\n    (and (not (intersects-any? (first s) (rest s)))\n         (recur (rest s))))))","user":"590b055ae4b047aa04b199c9"},{"code":"(fn [s]\n  (let [ss (for [a s, b s, :when (not (identical? a b))]\n                (clojure.set/intersection a b))]\n    (every? empty? ss)))","problem":153,"user":"4e7263a1535d5021c1a8965f"},{"code":"(fn [[& sets]]\n  (let [combinations (for [a sets b sets :when (not= a b)] [a b])]\n    (reduce (fn [acc [a b]] (and acc (empty? (filter (partial contains? a) b)))) true combinations)))","problem":153,"user":"50fc299ee4b0d10d794c19f2"},{"problem":153,"code":"#(if-let [[h & xs] (seq %)]\n  (if ((complement empty?) (clojure.set/intersection h (reduce clojure.set/union xs)))\n     false\n     (recur xs))\n   true)","user":"53c649d3e4b00fb29b221297"},{"code":"(fn [coll]\n  (= (count (reduce #(into %1 %2) #{} coll))\n     (apply + (map count coll))))","problem":153,"user":"51780f88e4b03d69594194c9"},{"problem":153,"code":"(fn distinct-all [coll]\n     (let [one (mapcat identity coll)\n           two (apply distinct? one)]\n       two))","user":"57227f10e4b0c5bde472c0cd"},{"problem":153,"code":"#(= (reduce + (map count %)) (count (reduce into %)))","user":"536046a9e4b063bf7a5f8fe1"},{"code":"(fn [colls]\n  (nil? (some (partial not= 1)\n          (for [coll colls]\n            (count (keep\n                     (partial some coll)\n                     colls))))))","problem":153,"user":"4dc0ff08535d020aff1edf84"},{"problem":153,"code":";(fn my-prob-153-disjoint-sets [ss]\n;  (letfn [(pairwise-disjoint? [x xs]\n;            (every? #(empty? (clojure.set/intersection x %)) xs))]\n;    (every? #(pairwise-disjoint? % (clojure.set/difference ss #{%})) ss)))\n;(fn my-prob-153-disjoint-sets [s]\n;  (every? #(every? (fn [o-set] (empty? (clojure.set/intersection % o-set)))\n;                   (clojure.set/difference s #{%}))\n;          s))\n(fn my-prob-153-disjoint-sets [s]\n  (every? (fn [x-set]\n            (every? (fn [o-sets]\n                      (empty? (clojure.set/intersection x-set o-sets)))\n                    (clojure.set/difference s #{x-set})))\n          s))","user":"55b28b57e4b01b9910ae296c"},{"problem":153,"code":"(fn [s]\n  (let [combinations #(->> (for [x % y %] (if (= x y) nil #{x y}))\n                          (filter (complement nil?))\n                          set\n                          (map vec))]\n    (->> (combinations s)\n         (map (fn [[a b]] (clojure.set/intersection a b)))\n         (every? empty?))))","user":"55586905e4b0deb715856e2b"},{"code":"#(= (reduce + (map count %)) (count (reduce into #{} %)))","problem":153,"user":"4fa6d532e4b081705acca1be"},{"code":"#((fn [a b] (cond \n  (seq (clojure.set/intersection (first a) (first b))) false\n  (empty? a) true\n  (empty? b) (recur (rest a) (rest (rest a)))\n  :else (recur a (rest b)))) % (rest %))","problem":153,"user":"50548ce8e4b0b1b9d1860ead"},{"problem":153,"code":"#(= \n  (count (apply clojure.set/union %))\n  (reduce + (map count %)))","user":"54d127b7e4b0e8a36923e5de"},{"code":"(fn [sets]\n    (let [sets (vec sets)]\n      (prn \".\")\n      (prn sets)\n      (prn (apply clojure.set/union sets))\n      (= (count (apply clojure.set/union sets))\n         (reduce + 0 (map count sets)))))","problem":153,"user":"5356ac72e4b04ce2eb3ed26a"},{"problem":153,"code":"(fn f [c]\n      (= (reduce + (map count c))\n         (count (reduce clojure.set/union c))))","user":"55ff562fe4b00f4cabc57660"},{"problem":153,"code":"(fn [s]\n  (letfn\n    [(common? [ss tt] (= (count ss) (count (apply disj ss tt))))\n     (calc [sx s1]\n       (if (= 1 (count s1))\n         (common? sx (first s1))\n         (if (set? s1)\n           (common? sx s1)\n           (and\n             (calc sx (rest s1))\n             (calc (first s1) (rest s1))))))]\n    (calc (first s) (rest s))))","user":"5dc72a9ce4b02f9375f4e1cd"},{"problem":153,"code":"(fn [coll]\n (apply distinct? (mapcat seq coll)))","user":"5a984657e4b0d174b936c78a"},{"code":"(fn [coll] \n  (not-any? (fn [[s v]] (contains? s v)) \n            (for [set1 coll set2 coll val2 set2 \n                  :when (not= set1 set2)] \n              [set1 val2])))","problem":153,"user":"4f969214e4b0dcca54ed6cdd"},{"code":"#(let [t (mapcat seq %) c count]\n   (= (c t) (c (set t))))","problem":153,"user":"5046ee3ee4b03b02161376b4"},{"problem":153,"code":"(fn [sets]\n  (every?\n   (fn [s]\n     (let [others (clojure.set/difference sets #{s})]\n       (= s (clojure.set/difference s (apply clojure.set/union others))))) \n   sets))","user":"5b0e6795e4b0cc2b61a3be03"},{"problem":153,"code":"#(= (count (apply clojure.set/union %1)) (reduce + (map count %1) ) )","user":"56a75810e4b0542e1f8d14fc"},{"problem":153,"code":"(fn pairwise-disjoint[c]\n  (let [count1 (reduce #(+ (count %2) %1) 0 c)\n        count2 (count (reduce clojure.set/union c))]\n    (= count1 count2)))","user":"56f4cedce4b046a417f92063"},{"problem":153,"code":"(fn ! [sets]\n  (if (empty? (rest sets))\n    true\n    (if-not (every? identity\n             (map #(empty? (clojure.set/intersection \n                            (first sets) %))\n                  (rest sets)))\n      false\n      (! (rest sets)))))","user":"59225498e4b09b4ee5954c8c"},{"code":"(fn disjoint?                                                             \n  ([a]                                                                      \n     (apply disjoint? a)                                                    \n     )                                                                      \n  ([a b]                                                                    \n     (prn a b)                                                              \n     (empty? (clojure.set/intersection a (if (seq? b) (first b) b))))       \n  ([a b & more]                                                             \n     (and (disjoint? a b)                                                   \n          (apply disjoint? a more)                                          \n          (apply disjoint? b more)                                          \n          ))                                                                \n  )","problem":153,"user":"50573ed8e4b0012181721987"},{"problem":153,"code":"#(= (apply + (map count %))\n  (count (reduce into #{} %)))","user":"50d3ec8be4b030b634c368bb"},{"problem":153,"code":"#(empty? (for [i % j % :when (and (not= i j) (seq (clojure.set/intersection i j)))\n          ]\n      i\n      ))","user":"5921a080e4b09b4ee5954c77"},{"code":"#(and (nil? (some boolean (for [x % y % :when (not= x y)] (seq (filter x y))))) \n      (not (some empty? %)))","problem":153,"user":"515e8ce2e4b049add99a053d"},{"problem":153,"code":"#(= (apply + (map count %)) (count (reduce (fn [x y] (into x y)) #{} %)))","user":"57f8ba80e4b0d3187e90092f"},{"problem":153,"code":"(fn problem-153 [sets]\n  (= (count (reduce clojure.set/union sets))\n     (reduce + (map count sets))))","user":"51fe9d7ce4b0f1313d468a70"},{"problem":153,"code":"(fn x [ss]\n  (=\n   (reduce + (map count ss))\n   (count (reduce clojure.set/union #{} ss))\n   ) \n  \n  )","user":"56db90d4e4b0ea9b8538f80d"},{"code":"(fn [sets]\n    (= (count (apply clojure.set/union sets))\n       (apply + (map count sets))))","problem":153,"user":"50ed3c6be4b01236b1d4983b"},{"problem":153,"code":"(let [\n      ; take a set s, and return a list of pairs of elements of s                         \n      pairs (fn pairs [s]\n              (let [v           (apply vector s)\n                    n           (count v)\n                    index-pairs (for [i (range n) j (range n) :when (not= i j)] [i j] )\n                    ]\n                (map\n                 (fn [[i j]] [(v i) (v j)])\n                 index-pairs)\n                )\n              )\n      disjoint? (fn disjoint? [[a b]] (empty? (clojure.set/intersection a b)))\n      pairwise-disjoint? (fn pairwise-disjoint? [s] (every? disjoint? (pairs s)))\n      ]\n  pairwise-disjoint?\n)","user":"530bf87ee4b02e82168697d5"},{"problem":153,"code":"#(apply distinct? (apply concat %))\n\n;(fn [s] (let [l (apply concat s)] (= (count l) (count (set l)))))","user":"54e1939ce4b024c67c0cf7c5"},{"code":"(fn [sets]\n\t(let [\n\t\t\tsizes (map count sets)\n\t\t\ttotal-size (apply + sizes)\n\t\t\tmerged-set (apply clojure.set/union sets)\n\t\t\tmerged-size (count merged-set)]\n\t\t(= total-size merged-size)))","problem":153,"user":"51ba4482e4b0fe3ecfb4642b"},{"code":"#(= (count (apply clojure.set/union %))\n    (apply + (map count %)))","problem":153,"user":"4fbbcf0ce4b081705acca2ee"},{"code":"(fn [m] \n  (= (count (reduce #(into %1 %2) #{} m))\n     (apply + (map count m))))","problem":153,"user":"4f32a7f1e4b0d6649770a095"},{"code":"(fn [sets]\n  (every? #{true}\n          (map\n            (fn [s]\n              (let [other-sets (disj sets s)]\n                (empty? (clojure.set/intersection s (apply clojure.set/union other-sets)))))\n            sets)))","problem":153,"user":"4ec70f26535d6d7199dd36dd"},{"problem":153,"code":"(fn [sos]\n  (every? identity (for [s1 sos\n                         s2 sos\n                         :when (not= s1 s2)]\n                      (empty? (clojure.set/intersection s1 s2)))))","user":"5f2c94b4e4b033932238a669"},{"problem":153,"code":"(fn mdisjoint?\n  [ss]\n  (every? empty? (for [a ss\n                       b (disj ss a)]\n                   (clojure.set/intersection a b))))","user":"5866b999e4b0f14aab7c886b"},{"code":"#(every? true?\n    (for [x % y % :let [intersec (clojure.set/intersection x y)] :when (not= x y)]  \n      (empty? intersec)))","problem":153,"user":"5300b750e4b0d8b024fd3711"},{"code":"(fn unique?[sets]\n (let [m \n       (fn mergesets[s]\n  \t\t(set (apply concat s))\n       )\n      ]\n  (= (count (m sets)) \n     (reduce \n      (fn [acc st] (+ acc (count st)))\n      0,\n      sets\n      \n      )\n     )\n   )\n  )","problem":153,"user":"4fb03cf4e4b081705acca262"},{"problem":153,"code":"(fn [s]\n   (->> s\n        (reduce #(into %1 %2) [])\n        frequencies\n        (not-any? #(> (second %) 1))))","user":"518279abe4b0353c468deb65"},{"problem":153,"code":"(fn [x]\n  (let [l (for [x1 x x2 x :while (not= x1 x2)][x1 x2])]\n    (every? true? (map #(if (= (clojure.set/intersection (first %)(second %)) #{}) true false) l))))","user":"566d71b1e4b0a866af6896ca"},{"code":"#(every? empty? (for [x % y % :when (not= x y)]\n                  (clojure.set/intersection x y)))","problem":153,"user":"51cbaf14e4b08d8387cbedda"},{"code":"(fn [x](== (apply + (map count x)) (count (apply (comp distinct concat) x))))","problem":153,"user":"51beb32ae4b013aa0d74b7fd"},{"problem":153,"code":"#(let [data (reduce\n               (fn [acc i] {:set   (into #{} (concat (:set acc) i))\n                            :count (+ (:count  acc) (count i))})\n               {:set #{} :count 0}   %)]\n          (= (count (:set data)) (:count data)))","user":"52f0ea04e4b05e3f0be25ee6"},{"problem":153,"code":"(fn dis [ s ] \n  (loop [one (first s) others (rest s)]\n     (cond      \n      (empty? others) true\n \t  (not (empty? (clojure.set/intersection one (apply clojure.set/union others)))) false\n       :else (recur (first others) (rest others))\n )))","user":"57887de2e4b0ebec4cfb751c"},{"problem":153,"code":"(fn [z] (let [u (fn [x] (reduce #(clojure.set/union %1 %2) x)) c (fn [x] (reduce #(+ %1 (count %2)) 0 x))] (if (= (c z) (count (u z))) true false) ))","user":"54a7efdee4b09f271ff37c9d"},{"problem":153,"code":"(fn pwds\n  ([s] (pwds (first s) (rest s)))\n  ([s more] (if (or (nil? s) (nil? more)) \n                true\n                (if (seq (mapcat (fn [s2](clojure.set/intersection s s2)) more))\n                      false     \n                      (recur (first more) (rest more))))))","user":"579d9601e4b05b1deef9ae18"},{"problem":153,"code":"(fn [ss]\n  (if (empty? ss)\n    true\n    (if (every? empty? (map #(clojure.set/intersection (first ss) %) (rest ss)))\n      (recur (rest ss))\n      false)))","user":"541096bde4b01498b1a719b2"},{"problem":153,"code":"(fn [ss]\n  (loop [so-far #{}\n         remaining ss]\n    (if (empty? remaining)\n      true\n      (let [current (first remaining)]\n        (if (empty? (clojure.set/intersection current so-far))\n          (recur (into so-far current)\n                 (rest remaining))\n          false)))))","user":"55f5b8d6e4b06e875b46ce8d"},{"problem":153,"code":"(fn [ss] (let [cp (for [x ss y ss :when (not= x y)]\n                    (clojure.set/intersection x y))]\n           (every? empty? cp)))","user":"5bc833a5e4b07a9b28b100bb"},{"problem":153,"code":"(fn [s]\n  (loop [[h & t :as sq] (mapcat seq s)\n         found #{}]\n    (cond\n      (empty? sq) true\n      (contains? found h) false ;Those nils, man. They'll getcha.\n      :else (recur t (conj found h)))))","user":"565f8fd2e4b068f2fe63dc41"},{"problem":153,"code":"(fn mutually-disjoint? [set-of-sets]\n  (let [not-found (gensym)\n        in-any-set? (fn [sets x] (not (empty? (filter (fn [[_ v]] (= x v)) (map-indexed #(vector %1 (get %2 x not-found)) sets)))))\n        ]\n    (if (empty? set-of-sets)\n        true\n        (and (not (some identity (map #(in-any-set? (rest set-of-sets) %) (first set-of-sets))))\n             (mutually-disjoint? (rest set-of-sets))))))","user":"5a566e8fe4b05d388ecb6c51"},{"code":"(fn [x] (= 0 (count (filter #(not= 1 (count %)) (vals (group-by identity (apply concat (map seq x))))))))","problem":153,"user":"514d398ee4b019235f6c0583"},{"problem":153,"code":"(fn [colls]\n   (empty? (filter \n             (fn [entry] \n               (println \"entry\" (second entry)) \n               (< 1 (count (second entry)))) \n             (group-by identity (vec (apply concat colls))))))","user":"58ed2e21e4b056aecfd47d7a"},{"code":"(fn [s] (= (->> s (apply concat #{}) (set) (count)) (apply + (map count s)) ))","problem":153,"user":"521dceeae4b050d5da042802"},{"problem":153,"code":"(fn pairwise-disjoint? [sets]\n  (if (seq sets)\n    (let [head (first sets)\n          tail (rest sets)]\n      (and (every? empty? (map #(clojure.set/intersection head %) tail))\n           (pairwise-disjoint? tail)))\n    true))","user":"4f5599dfe4b0a7574ea71806"},{"problem":153,"code":"(fn pairwise  [setSets]\n  (apply distinct? (mapcat seq setSets))\n)","user":"59e0111ae4b08badc2a0c4e4"},{"problem":153,"code":"(fn [ss] (= (reduce #(+ %1 (count %2)) 0 ss)\n            (count (set (apply concat ss)))))","user":"50ef77a4e4b0bdaecbb47d99"},{"code":"(fn [s]\n  (=\n   (count (reduce #(into % %2) s))\n   (apply + (map count s))))","problem":153,"user":"50843a4ae4b0c98812d0788b"},{"problem":153,"code":";#(let [x (apply concat %)]\n;    (= x (distinct x)))\n#(apply distinct? (apply concat %))","user":"57035ccfe4b08d47c97781ef"},{"code":"#(= (reduce + (map count %)) (count (apply clojure.set/union %)))","problem":153,"user":"4ec0c7ba535dfed6da9c6da4"},{"code":"(fn [s]\n          (empty? (for [x s, y s\n                          :let [i (clojure.set/intersection x y)]                          :while (not= x y) \n                          :when (not-empty i)]\n                       i)))","problem":153,"user":"50705072e4b07bd6ad9b9f27"},{"code":"(fn [s]\n  (let [lst (mapcat #(apply list %) s)]\n    (= (count lst)\n       (count (set lst)))))","problem":153,"user":"4db3393e535df7e46ed9b6cc"},{"problem":153,"code":"(fn pairwise-disjoint [sets]\n   (let [sets (vec sets)]\n     (every? true?\n             (for [i (range (count sets))\n                   j (range (count sets))\n                   :when (not= i j)]\n               (= #{} (clojure.set/intersection\n                       (nth sets i) (nth sets j)))))))","user":"5d4b2155e4b0776584bd6f28"},{"code":"(fn mutually-disjoint? [s]\n  (let [all-in-list (mapcat #(seq %) s)\n        all-in-set (set all-in-list)]\n    (= (count all-in-list) (count all-in-set))))","problem":153,"user":"5244a10de4b0d8acf9ed6ab3"},{"code":"(fn ds [ss]\r\n  (let [c (count ss)]\r\n    (if (< c 2)\r\n      true\r\n      (let [fi (first ss)\r\n            rest (disj ss fi)\r\n            si (fn [a b]\r\n                 (some #(contains? b %)   a)\r\n                 )\r\n            ]\r\n        (and\r\n            (if  (some #(not (nil? (si fi %))) rest) false true)\r\n            (ds rest)\r\n            )\r\n        \r\n        ))) )","problem":153,"user":"4febb4dae4b0681fd128dc98"},{"code":"(fn [setx] \n    (=\n      (count (reduce clojure.set/union setx))\n      (apply + (map count setx)) \n    ) )","problem":153,"user":"52be0263e4b07a9af579230e"},{"problem":153,"code":"(fn [coll] \n  (let [total-by-subset (reduce + (map count coll))\n        count-after-union (count (apply clojure.set/union (flatten (seq coll))))]\n    (if (= total-by-subset count-after-union)\n      true\n      false)))","user":"567d18c9e4b05957ce8c61c4"},{"problem":153,"code":"(fn pairwise_disjoint\n  [n]\n  (not (some true?\n         (for [x n \n               y n\n               :when (not (identical? x y))\n               x x \n               y y]\n           (= x y)))))","user":"5ea3711ae4b00a66d4a9519d"},{"problem":153,"code":"(fn pairwise-disjoint? [sets]\n  (letfn [(all-pairs\n            [coll]\n            (if (< (count coll) 2)\n              ()\n              (concat (map #(list (first coll) %) (rest coll))\n                      (all-pairs (rest coll)))))\n          (disjoint?\n            [x y]\n            (or (empty? x)\n                (and (not (contains? y (first x)))\n                     (disjoint? (rest x) y))))]\n    (every? (partial apply disjoint?) (all-pairs sets))))","user":"53dc94c8e4b094d41abdfefc"},{"code":"(fn [sets] (let [joined-sets (apply concat sets)]\n               (= (count joined-sets) (count (distinct joined-sets)))))","problem":153,"user":"52fa4f48e4b047fd55836ff7"},{"code":"(fn [s]  (let [len1 (apply + (map count s))         len2 (count (reduce #(apply conj %1 %2) s))]    (= len2 len1)))","problem":153,"user":"52f9ce6de4b047fd55836ff0"},{"code":"#(let [z (for [x %\n               y x]\n           y)]\n   (= (count z) (count (distinct z))))","problem":153,"user":"507ef25ce4b0f753b6f9788e"},{"problem":153,"code":"#(= (->> % (apply concat) set count) (->> % (map count) (reduce +)))","user":"5e5b8d92e4b0fd0acd158658"},{"code":"(fn [sets]                                                                                 \n  (let [superset (set (apply concat sets))                                                           \n        size (reduce #(+ %1 (count %2)) 0  sets)]                                                    \n    (=  size (count superset))                                                                       \n  ))","problem":153,"user":"4f1d1299535d64f603146487"},{"problem":153,"code":"(fn [sets]\n  (every?\n   identity\n   (for [si sets\n         sj sets\n        :when (not= si sj)]\n    (empty? (clojure.set/intersection si sj)))))","user":"57275898e4b0c5bde472c13e"},{"problem":153,"code":"(fn [[& x]] (=(count(apply clojure.set/union x))(apply + (map count x))))","user":"5951190be4b066ee0a44aea4"},{"code":"(fn [s]\r\n    (every? empty? (map #(apply clojure.set/intersection %)\r\n         (filter identity \r\n                 (for [x s y s] (when (not= x y) [x y]))))))","problem":153,"user":"4f58d92fe4b0a7574ea71858"},{"problem":153,"code":"(fn [coll]\n  (if (= \n       (count (reduce clojure.set/union coll))\n       (reduce #(+ %1 (count %2)) 0 coll))\n    true \n    false)\n  )","user":"5b3251c1e4b025bcb146f317"},{"code":"(fn [sset]\n  (every? true? \n          (for [s1 sset\n        \t\ts2 sset]\n    (or (= s1 s2) (empty? (clojure.set/intersection s1 s2))))))","problem":153,"user":"529ce629e4b04e0c58e87b6e"},{"code":"(fn [set-of-set]\n    (== \n      (apply + (for [s set-of-set] (count s)))\n      (count (reduce into #{} set-of-set))))","problem":153,"user":"4ee77f15535d93acb0a66868"},{"problem":153,"code":"(fn peu [x] (let [y (vec x)] (if (= 1 (count y)) true (and (empty? (clojure.set/intersection (first y) (second y))) (peu (conj (rest (rest y)) (clojure.set/union (first y) (second y)))  ))  )))","user":"53fc8424e4b0de5c418485b3"},{"problem":153,"code":"(fn [ss] \n  (every? identity \n          (for [sl ss\n                sr (remove #(= sl %) ss)]\n                (empty? (clojure.set/intersection sl sr)))))","user":"58e37946e4b005f69f193cae"},{"problem":153,"code":"(fn [x]\n  (= (count (apply clojure.set/union x))\n     (reduce + (map count x))))","user":"57ea2c91e4b0bfb2137f5b42"},{"problem":153,"code":"(fn disjoint? [xs]\n  (cond (empty? xs) true\n        (some (fn [x] (not (empty? (clojure.set/intersection (first xs) x)))) (rest xs)) false\n        :else (disjoint? (rest xs))))","user":"53800d99e4b06839e8705ebd"},{"code":"(fn [s]\n   (= (reduce #(+ %1 (count %2)) 0 s)\n         (count (apply clojure.set/union s))))","problem":153,"user":"4f75469ee4b0fbe0118ec55a"},{"problem":153,"code":"#(= (apply + (map count %)) (count (reduce clojure.set/union %)))","user":"549c22f7e4b0f3d1d8e70f86"},{"code":"(fn [sets] (= (apply + (map count sets)) (count (apply clojure.set/union sets))))","problem":153,"user":"521e8227e4b0dd19981ad082"},{"problem":153,"code":"(fn [s]\n  (= (count (apply clojure.set/union s))\n     (apply + (map count s))))","user":"56fee4c0e4b08d47c97781b5"},{"problem":153,"code":"(fn [xs]\n  (loop [index #{}, [fst :as ys] (seq xs)]\n    (cond\n      (empty? ys) true\n      (->> fst (map #(contains? index %)) (some true?)) false\n      :else (recur (into index fst) (rest ys)))))","user":"5b96800ae4b0c0b3ffbd4a7b"},{"problem":153,"code":"(fn [s]\n  (->> (for [s1  s\n             s2  s]\n        [s1 s2])\n        (filter (fn [[a b]] (not= a b))  ,,,)\n        (every? (fn [[a b]] (empty? (clojure.set/intersection a b))))))","user":"557e56aae4b05c286339e0d5"},{"problem":153,"code":"(fn pairwise-disjoint-sets?\n  [s]\n  (let [total (reduce + (for [x s] (count x))) combo (reduce clojure.set/union s)] \n    (if (= (count combo) total) true false)\n    )\n  )","user":"5c20b6abe4b07e362c230576"},{"problem":153,"code":"(fn [col]\n  (apply distinct? (mapcat seq col)))","user":"59dfd369e4b08badc2a0c4dd"},{"problem":153,"code":"#(let [none-in-common (fn [[s1 s2]]\n                       (= #{} (clojure.set/intersection s1 s2)))\n       all-pairs (fn all-pairs [[h & t :as s]]\n                    (if (nil? t) nil\n                      (concat (for [x t] [h x])\n                              (all-pairs t))))]\n   (reduce (fn [a b] (and a b)) \n           (map none-in-common (all-pairs (into '() %)))))","user":"531619c1e4b08068f379ed3d"},{"problem":153,"code":"(fn [se] (every? identity (reduce conj [] (for [x1 se x2 se] \n                                            (if (= x1 x2)\n                                              true\n                                              (empty? (clojure.set/intersection x1 x2)))))) )","user":"57acee37e4b0b8559636fc94"},{"problem":153,"code":"#(= (count (reduce clojure.set/union %)) (count (apply concat %)))","user":"59e0f38ae4b08badc2a0c500"},{"problem":153,"code":"(fn z [coll]\n  (loop [coll coll]\n   (cond\n     (empty? coll) true\n     ((complement not-any?) #(some (partial contains? (first coll)) %) (rest coll)) false\n     :else (recur (rest coll)))))","user":"583667c7e4b089d5ab817cfb"},{"code":"(fn [s]\n    (let [union (reduce clojure.set/union s)\n          union-size (count union)\n          sum-sizes (reduce + (map #(count %) s))]\n      (= union-size sum-sizes)\n  \n      ))","problem":153,"user":"4daea889edd6309eace4d15b"},{"problem":153,"code":"(fn [s] (->> (for [s1 s\n                   s2 (disj s s1)]\n               [s1 s2])\n             (map (fn [[s1 s2]] (clojure.set/intersection s1 s2)))\n             (every? empty?)))","user":"59ac0965e4b08cbb53654da6"},{"code":"(fn a [sets]\n  (cond\n   (empty? sets) true\n   (some #(seq (clojure.set/intersection (first sets) %)) (rest sets)) false\n   :else (a (rest sets))))","problem":153,"user":"4ddbd934535d02782fcbe9fc"},{"problem":153,"code":"(fn\n  [set_]\n  (let [set_ (seq set_)\n        len (count set_)]\n    (every? empty?\n            (seq (for [s1 (range len)\n                       s2 (range len)\n                       :when (not= s1 s2)]\n                   (clojure.set/intersection\n                     (nth set_ s1)\n                     (nth set_ s2)))))))","user":"55bf6dbce4b01b9910ae2a12"},{"problem":153,"code":";(fn disjoint? [sets]\n;  (loop [s sets]\n;    (println s)\n;    (if (empty? (rest s))\n;      true\n;      (if (empty? (clojure.set/intersection (first s) (second s)))\n;        (recur (merge (set (drop 2 s))\n;                      (clojure.set/union (first s) \n;                                         (second s))))\n;        false))))\n\n#(= (apply + (map count %)) (count (reduce into %)))","user":"57533bc1e4b02ea1147992a6"},{"problem":153,"code":"(fn pairwise [sets]\n  (empty? (mapcat (fn [s]\n                    (mapcat (fn [all-set]\n                              (seq (clojure.set/intersection all-set s)))\n                            (disj sets s)))\n                  sets)))","user":"50e3e108e4b01912b3285c48"},{"code":"(fn pairw-disj [s]\n  (let [all-flat (mapcat #(mapcat vector %) s)]\n    (=\n      (count all-flat)\n      (count (into #{} all-flat)))))","problem":153,"user":"50d3b03fe4b030b634c368b9"},{"problem":153,"code":"(fn checker\n  [vals]\n  (= (count (apply concat '() vals))\n     (count (apply clojure.set/union vals))))","user":"5ec5f7f2e4b08d0ec38692d1"},{"problem":153,"code":"#(let [coll (for [x % y x] y)] (= coll (distinct coll)))","user":"55a74d46e4b09e57187da2a3"},{"problem":153,"code":"(fn [coll]\n  (every? empty? \n    (map clojure.set/intersection \n      coll\n      (map \n        (fn [s] \n          (set (mapcat #(into [] %) (clojure.set/difference coll #{s})))) coll))))","user":"4df73d64535d04ed9115e775"},{"problem":153,"code":"(fn mutually-disjoint? [sets]\n  \"checks if a set of sets are pair-wise disjoint. Count based implementation\"\n  (=\n   (count (apply clojure.set/union sets))  ;; number of distinct elements in union\n   (apply + (map count sets))          ;; count of all elements in sets\n  ))","user":"5993eeefe4b0b211ea3aaabc"},{"code":"(fn [s] (loop [ss s]\n          (if (or (empty? ss) (< (count ss) 2))\n            true\n            (if (not (reduce #(and %1 %2) (map empty? (map #(clojure.set/intersection (first ss) %) (rest ss) ))))\n              false\n              (recur (rest ss)) ))))","problem":153,"user":"53512bc6e4b084c2834f4ae1"},{"problem":153,"code":"(fn beda? [s]\n  (= \n    (count (set (apply concat s)))\n    (apply + (map count s))))","user":"56278266e4b00e49c7cb47d3"},{"problem":153,"code":"(fn pairwise-disjoint [s] (= (count (apply clojure.set/union s)) (reduce + (map count s))))","user":"542c1f73e4b0dad94371f29d"},{"code":"(fn [l]\r\n  ((fn [[h & r]]\r\n      (cond (empty? r) true\r\n      (every? empty? (map #(clojure.set/intersection h %) r)) (recur r)\r\n\t    :else false))\r\n   (seq l)))","problem":153,"user":"507437c2e4b054001656acd0"},{"problem":153,"code":"#(apply distinct? (mapcat seq %))\n\n; A set contains distinct elements.","user":"5e6ca949e4b04a83ad7cd289"},{"problem":153,"code":"#(= (->> % seq (apply clojure.set/union) count) (->> % seq (map count) (reduce +)))","user":"4e7e8684535db169f9c79717"},{"problem":153,"code":"#(apply distinct? (mapcat identity %))","user":"55933c7ae4b0c79f6e1db938"},{"code":"(fn [s] (let [m (-> (apply concat s) set count)\n                n (reduce #(+ (count %2) %) 0 s) ] \n          (if (= m n) true false)))","problem":153,"user":"50921f9ae4b09a7d0b586de1"},{"problem":153,"code":"(fn f [ss]\n  (reduce #(and %1 %2)\n  (for [s1 ss s2 ss]\n    (if (= s1 s2) true\n    (=\n    (count (apply disj (cons s1 s2)))\n    (count s1)))\n  )))","user":"50bfbf25e4b05ae8c1cbbd9b"},{"problem":153,"code":";;the best verion of my solution\n(fn [sos]\n  (empty? (filter identity (for [s1 sos\n                                 s2 sos\n                                 :when (not= s1 s2)]\n                             (seq (clojure.set/intersection s1 s2))))))\n\n;; the solution I actually like the most\n;(fn [sos]\n;  (apply distinct? (apply concat sos)))","user":"5766bab8e4b0a07e8fc180b1"},{"problem":153,"code":"#(apply distinct? (mapcat seq %))\n\n;(fn [sets]\n;  (->> sets\n;       (map (fn [s]\n;              (set (map #(if (coll? %)\n;                           (set %)\n;                           (hash-set %))\n;                        s))))\n;       set\n;       (apply clojure.set/intersection)\n;       empty?))","user":"58d2af83e4b03c36ff7e5907"},{"problem":153,"code":"#(every? empty? (flatten (for [x % y % :when (not= x y)] (clojure.set/intersection x y))))","user":"52c7f036e4b0c2d177d62126"},{"problem":153,"code":"; conjoin all sets and count how many elements are there,\n; if they are different (smaller) than the sum of elements of each set\n; it means there are duplicates\n(fn pairwise? [s]\n      (let [n (apply + (map #(count %1) s))\n            m (count (reduce #(apply conj %1 %2) s))\n           ] (if (= n m) true false)\n      )\n \n  )","user":"558bdcefe4b0277789237633"},{"code":"#(every? empty? (for [s1 % s2 % :when (not= s1 s2)] (clojure.set/intersection s1 s2)))","problem":153,"user":"5246e945e4b0644eb7b0783b"},{"code":"#(every? empty?\r\n  (mapcat (fn [s]\r\n    (map (partial clojure.set/intersection s) (disj % s))) %))","problem":153,"user":"4ff304f4e4b0678c553fc343"},{"code":"(fn [xs]\n  (= (reduce + (map count xs))\n     (count (reduce clojure.set/union xs))))","problem":153,"user":"5312cdaae4b08068f379ed03"},{"code":"#(let [l (for [a % b a] b)]\n  (= (count l) (count (set l))))","problem":153,"user":"50f10f7be4b06d9538fe211a"},{"code":"(fn pairwise-disjoint2 [coll]\n  (let [coll2 (vec coll)]\n    (every? #(= % true)\n      (for [i (range (count coll2))\n\t\t  j (range (count coll2))\n\t\t  :when (and (not (= i j))\n\t\t\t     (> j i))]\n\t      (= (count (into #{} (concat (nth coll2 i)\n\t\t\t\t\t       (nth coll2 j))))\n\t\t      (count (concat (nth coll2 i)\n\t\t\t\t     (nth coll2 j))))))))","problem":153,"user":"50733b31e4b0e3170b5a869a"},{"code":"#(apply distinct? (reduce concat %))","problem":153,"user":"513b77f3e4b00f740c76c403"},{"code":"(fn [s]\n  (not \n    (reduce #(or (not (empty? %2)) %1) false\n      (map #(clojure.set/intersection (first %) (last %)) (for [x s y s :when (not= x y)] [x y])))))","problem":153,"user":"4e9c81e8535dbda64a6f6b80"},{"problem":153,"code":"#(let [z (apply concat %)]\n\t(= (count z) (count (set z))))","user":"57ccedaae4b0c746388ab88e"},{"problem":153,"code":"(fn [s]\n  (= \n  \t(count (apply clojure.set/union s))\n    (reduce #(+ % (count %2)) 0 s)\n))","user":"5654d0e1e4b0f9d632dd848c"},{"code":"#(=\n  (reduce + (map count %))\n  (count (apply clojure.set/union %)))","problem":153,"user":"5256627ce4b0541d1855ba1a"},{"problem":153,"code":"(fn [x] (= (reduce #(+ %1 (count %2)) 0 x) (count (set (apply concat x)))))","user":"5742ec91e4b05c31a32c0883"},{"problem":153,"code":"(fn [sets] (let [seqsets (reduce into (map #(seq %) sets))]\n               (= (count seqsets) (count (distinct seqsets)))))","user":"5759cd46e4b02ea11479932e"},{"problem":153,"code":"(fn [coll]\n    (every? (fn [e]\n              (empty?\n                (clojure.set/intersection\n                  e\n                  (apply clojure.set/union (disj coll e))))) coll))","user":"5e08c3dde4b0978307768fc8"},{"problem":153,"code":"(comp #(apply distinct? %)\n      #(apply concat %))","user":"5458c74de4b01be26fd74623"},{"problem":153,"code":"(fn[s]\n  ((fn diff[[a b & q]]\n    (if (or (nil? a) (nil? b))\n      true\n      (and (empty? (clojure.set/intersection a b))\n          (diff (cons a q))\n          (diff (cons b q))))) (seq s)))","user":"54651ef5e4b01be26fd746d5"},{"problem":153,"code":"(fn [sets]\n  (= (reduce #(+ % (count %2)) 0 sets)\n     (count (reduce clojure.set/union sets))))","user":"541b1f25e4b01498b1a71a63"},{"problem":153,"code":"(fn [x]\n          (loop [a (first x)\n                 r (rest x)\n                 acc true]\n            (if (empty? r)\n              acc\n              (recur (first r)\n                     (rest r)\n                     (every? identity (conj (map #(empty? (clojure.set/intersection a %)) r) acc))))))","user":"5835bc73e4b089d5ab817ce9"},{"problem":153,"code":"#(= (count (reduce clojure.set/union %)) (reduce + (map count %1)))","user":"56347285e4b0bfe05bf117bc"},{"code":"(fn [ss]\n  (==\n    (apply + (map count ss))\n    (count (reduce (partial reduce conj) #{} ss))))","problem":153,"user":"4ebc08a8535dfed6da9c6d7c"},{"code":"#(and\r\n   (> 2 (count (filter nil? (map (fn [k] (get k nil true)) %))))\r\n   (every? nil? (for [x % y %]\r\n                  (if (not (identical? x y)) (some x y)))))","problem":153,"user":"50336c6be4b0c6c1199c710f"},{"code":"(fn disjoint? [s]\n  (let [not-intersects?\n        #(every? false? (for [a %1 b %2] (= a b)))\n        none-intersects? \n        #(every? true? (map (partial not-intersects? %1) %2))]\n    (if (not (empty? s))\n      (and (none-intersects? (first s) (rest s))\n           (disjoint? (rest s)))\n      true)))","problem":153,"user":"514c2d05e4b02b8cbb2a9278"},{"problem":153,"code":"(fn [sets]\n  (loop [[curr & other] (seq sets)]\n    (if (nil? other)\n      true\n      (and\n       (every? #(empty? (clojure.set/intersection % curr)) other)\n       (recur other)))))","user":"55ac07afe4b03311e7b7328f"},{"problem":153,"code":"(fn [xs]\n  (let [c2 #(loop [o % acc '()] (if (not (second o)) acc\n                (recur (rest o) (reduce (fn [a1 i1] (cons [(first o) i1] a1)) acc (rest o)))))]    \n     (->> (c2 xs)\n          (filter (fn [[k1 k2]] (not-empty (clojure.set/intersection k1 k2))))\n          empty?)))","user":"5dc12b0ae4b0e59a23173d84"},{"problem":153,"code":"(fn [ss] \n  (every? #(empty? %) (for [s1 ss s2 ss :when (not= s1 s2)] (clojure.set/intersection s1 s2))))","user":"4fd4bddce4b0d4de60cee36e"},{"code":"(fn [xs] (let [not-member-any? (fn [xs x] (every? #(not (contains? % x)) xs))\n               has-no-members-in? (fn [s xs] (every? #(not-member-any? xs %) s))]\n              (every? #(has-no-members-in? % (disj xs %)) xs)))","problem":153,"user":"51c19873e4b0d204dbe2ca0d"},{"problem":153,"code":"(fn [sets]\n  (let [col (map (fn [x n] [x n]) sets (range))]\n    (let [pp (for [[e1 i1] col [e2 i2] col :when (> i1 i2)] [e1 e2])]\n       (every?\n         (fn [c]\n           (let [[c1 c2] c]\n              (empty? (clojure.set/intersection c1 c2))\n           )\n         )\n         pp\n       )\n    )\n  )\n)","user":"53ca41dae4b00fb29b2212c8"},{"problem":153,"code":"(fn [coll]\n      (not-any? (complement nil?) \n        (for [s coll]\n          (let [other-elems (reduce into #{} (disj coll s))]\n            (or (some (complement nil?) (filter other-elems s))\n                (and (some nil? s) (some nil? other-elems)))))))","user":"545e9cf1e4b01be26fd7467f"},{"problem":153,"code":"#(let [s-l (reduce concat %)] (= s-l (distinct s-l)))","user":"58fc52cee4b0438e51c2cf95"},{"problem":153,"code":"(fn [a-set]\n  (= (reduce #(+ %1 (count %2)) 0 a-set)\n     (count (apply clojure.set/union a-set))))","user":"56cb4d06e4b0ea9b8538f72e"},{"code":"#(= (reduce + (map count %1))\n     (count (set (mapcat seq %1))))","problem":153,"user":"500900dee4b0144d4f561e42"},{"code":"(fn [s]\n (every? empty?\n  (for [a s b s :when (not= a b)]\n    (clojure.set/intersection a b))))","problem":153,"user":"5097b556e4b00ad8bab4e970"},{"code":"(fn pair-set [ss]\n  (= (count \n\t    (reduce into #{} ss))\n\t   (reduce\n\t    (fn [x ys]\n\t\t(+ x (count ys))) 0 ss)))","problem":153,"user":"4dd62278535d2dad7130b5c7"},{"problem":153,"code":"(fn [s]\n    (=\n      (count (reduce clojure.set/union s))\n      (reduce + (map count s))\n    ))","user":"579aff09e4b05b1deef9ade7"},{"problem":153,"code":"(fn [s]\n   (every? false? (for [e1 s e2 s]\n      (if (and\n            (not (= e1 e2))\n            (not (empty? (clojure.set/intersection e1 e2))))\n        true\n        false)))\n   )","user":"5d887d27e4b0915913b1d3a8"},{"problem":153,"code":"(fn [coll]\n  (let [ss (for [a coll b coll\n                 :when (not (identical? a b))]\n             (clojure.set/intersection a b))]\n    (every? empty? ss)))\n;; best answer\n;;#(apply distinct? (mapcat seq %))","user":"53be3ee7e4b0d9a98559a6df"},{"problem":153,"code":"(fn [xs]                                                               \n  (= (count (reduce into #{} xs))\n     (apply + (map count xs))))","user":"56795deae4b05957ce8c6187"},{"problem":153,"code":"(fn [xs] \n  (every? empty? \n      (for [a xs b xs :when (not= a b)] (clojure.set/intersection a b))))","user":"5884e807e4b0f1effa3b76a6"},{"code":"; immo's solution:\n; #(apply distinct? (apply concat %))\n\n(fn sets-pairwise_disjoint? [s]\n  (every? (partial = 1)\n          (vals\n           (frequencies\n            (into [] (for [s1 s i s1] i))))))","problem":153,"user":"4fc6d2c1e4b0ee37620e181b"},{"problem":153,"code":"#(= (reduce + (map count (list* %)))\n    (count (apply clojure.set/union (list* %))))","user":"4fc8f671e4b0ee37620e1840"},{"code":"(fn [s]\n  (= (count (set (reduce concat s)))\n     (reduce + (map count s))))","problem":153,"user":"4ed292ac535d44c135fd68d9"},{"problem":153,"code":"#(apply distinct? (mapcat seq  %))","user":"57b4779de4b0fbc9809a279a"},{"code":"#(let [c (mapcat vec %)] (= c (distinct c)))","problem":153,"user":"4facff22e4b081705acca230"},{"problem":153,"code":"#(< (last (sort (map val (frequencies (mapcat identity %))))) 2)","user":"4fc9a977e4b0ee37620e1847"},{"problem":153,"code":"(fn\n  [s]\n  (= (distinct (apply concat s)) (apply concat s)))","user":"5772ddb0e4b0979f896515d4"},{"problem":153,"code":"#(=\t(count (reduce concat '() %))\n\t(count (reduce clojure.set/union %))\n)","user":"580c8fcee4b0849f6811b721"},{"problem":153,"code":"(fn disjoint? [s]\n  (= (reduce + (map count s))\n     (count (into #{} (reduce concat #{} s)))))","user":"5ab564f8e4b073f177442639"},{"code":"(fn pairwise [s]\n   (let [coll (map #(apply list %) s)\n         filtered (set (filter #(not (empty? %)) coll))\n         uni-num (count (reduce (fn [a b] (apply conj a (apply list b))) #{} filtered))\n         all-num (apply + (map count s))]\n     (= uni-num all-num)))","problem":153,"user":"4f1bee08535d64f60314647e"},{"problem":153,"code":"(fn [xset]\n  (loop [xpivot (first xset)\n         xsrest (disj xset xpivot)]\n\n\n    (if (empty? xsrest)\n      true\n      (let [valor (\n                   \n                   (fn [f1 f2]\n  (reduce (fn [x y] (or x y)) false (map (fn [x] (not (empty? x))) (map (partial clojure.set/intersection f1) f2)))\n  )\n                   \n                   \n                   xpivot xsrest)]\n      (if (= valor true)\n        false\n        (recur (first xsrest) (disj xsrest (first xsrest)))\n        )\n\n      )\n    )\n  )\n)","user":"4dadca03c9a9d6ed4199dc57"},{"problem":153,"code":"(fn d[coll]\n (every? #(= % #{}) (for [x coll  y coll :while (not= y x)] (clojure.set/intersection x y))))","user":"585a7cb2e4b0f14aab7c874e"},{"problem":153,"code":"(fn [s_of_s]\n  (= (apply + (map count s_of_s)) (count (apply clojure.set/union s_of_s))))","user":"5c76577ae4b0fca0c16227ea"},{"problem":153,"code":"(fn disjoin [s]\n    (every? false? (for [s1 s\n                         s2 s]\n                     (and (not (identical? s1 s2))\n                          (not= 0 (count (clojure.set/intersection s1 s2)))))))","user":"549dfe40e4b0f3d1d8e70f9a"},{"code":"(fn p153\n  [s]\n  (let\n    [s (vec s)]\n    (reduce #(and %1 %2)\n      (for [i (range (- (count s) 1))]\n        (if (empty? (clojure.set/intersection (nth s i) (nth s (inc i))))\n          true\n          false)))))","problem":153,"user":"4e7d4544535db169f9c796d0"},{"code":"#(= (count (into #{} (apply concat [] %)))\n           (apply + (map count %)))","problem":153,"user":"503539dee4b0ed9c821488f6"},{"problem":153,"code":"(fn [s]\n    (= (count (apply concat '() s)) (count (apply clojure.set/union s))))","user":"6074f5ede4b069485764de52"},{"problem":153,"code":"#(= (count (apply clojure.set/union %))\n     (reduce + (map count %)))","user":"565e0934e4b068f2fe63dc30"},{"problem":153,"code":"(fn [s]\n  (= (reduce #(+ % (count %2)) 0 s)\n     (count (set (apply concat s)))))","user":"51dafedee4b09f6bc204eee2"},{"code":"(fn pd? [sets]\n  (letfn [(seltwo [s]\n       (if (= 2 (count s))\n           [s]\n            (concat (map #(vector (first s) %) (rest s))\n                  (seltwo (rest s)))))]\n    (every? (fn [[a b]] (empty? (clojure.set/intersection a b))) (seltwo sets))))","problem":153,"user":"4f62b29ce4b0defedf855fd9"},{"code":"(fn [c]\n  (let [x (reduce #(into %1 %2) [] c)\n        y (set x)]\n    (= (count x) (count y))))","problem":153,"user":"5098f5d6e4b0cae2931060a4"},{"code":"(fn [s] \n  (let [count-components (apply + (map count s))\n        count-union (count (reduce clojure.set/union s))]\n    (= count-components count-union)))","problem":153,"user":"4ea5ba92535d7eef308072d9"},{"problem":153,"code":"(fn func [sets]\n  (let [total-count (apply + (map count sets))\n        combined-set-count (count (set (apply concat sets)))]\n    (= total-count combined-set-count)))","user":"5e805895e4b085ba37836e44"},{"problem":153,"code":"(fn [incoming] (every? true? (map empty? (map (fn [pair] (if (not= (first pair) (second pair)) (clojure.set/intersection (first pair) (second pair)))) ((fn [sets] (for [a sets b sets] [a b])) incoming )))))","user":"52485723e4b05ef8e38e63d2"},{"problem":153,"code":"(fn check [col] \n  (if (empty? col) \n    true \n    (and (reduce (fn [x y] (and x \n                                (empty? (clojure.set/intersection (first col) y)))) \n                 true (rest col)) \n         (recur (rest col)))))","user":"55536a8ae4b0deb715856e03"},{"problem":153,"code":"(fn [s]\n   (= (count (set (reduce concat s)))\n      (reduce (fn [acc x] (+ acc (count x))) 0 s)))","user":"5eb741e4e4b00a66d4a9523b"},{"code":"(fn [s]\n  (loop [z s]\n    (if (nil? z)\n      true\n      (let [f (partial (fn [a b]\n                         (if (= a b)\n                           false\n                           (loop [x a]\n                             (if (nil? x)\n                               false\n                               (if (zero? (count (filter identity (map #(= % (first x)) b))))\n                                 (recur (next x))\n                                 true))))) (first z))\n            d (< 0 (count (filter identity (map #(f %) s))))]\n        (if d\n          false\n          (recur (next z)))))))","problem":153,"user":"4ff9d4e5e4b0678c553fc3b0"},{"code":"(fn [sets] \n  (loop [f (first sets) sets (rest sets)] \n    (if (zero? (count sets))\n      true\n      (if (some #(-> (clojure.set/intersection f %) count zero? not) sets)\n        false\n        (recur (first sets) (rest sets))))))","problem":153,"user":"524be8e0e4b09eba1c0223f1"},{"problem":153,"code":"(fn s [s]\n  (=\n   (apply + (map count s))\n   (count (reduce clojure.set/union s))))","user":"51aefceee4b09397d5109797"},{"problem":153,"code":"(fn pdisj [s]\n  (= (reduce + (map count s)) (count (reduce clojure.set/union s))))","user":"54dce62be4b024c67c0cf78b"},{"code":"(fn\n  [mySet]\n  (let\n   \t[result (reduce\n        (fn\n          [re aSet] (-> re\n          (assoc \n\n            \"sep\" (+ (get re \"sep\") (count aSet))\n            \"unSet\" (clojure.set/union (get re \"unSet\") aSet)\n            \"total\" (count (clojure.set/union (get re \"unSet\") aSet))\n          ) )\n        )\n        {\"unSet\" #{} \"sep\" 0 \"total\" 0}\n        mySet\n    )]\n    (if \n      (= (get result \"sep\") (get result \"total\"))\n      true\n      false\n    )\n  )\n)","problem":153,"user":"5162757ee4b03cfa3774b3fe"},{"problem":153,"code":"(fn pwd? [sets] \n  (every? false? (flatten (map (fn [fset rsets]\n                                   (map (fn [subset]\n                                            (map (partial contains? fset) subset)) rsets))\n                               (butlast sets)\n                               (iterate rest (rest sets))))))","user":"56baa68ce4b0f26550335947"},{"code":"#(empty? (for [a % b (disj % a) x a y b :when (= x y)] 1))","problem":153,"user":"4e9660ec535dbda64a6f6b44"},{"problem":153,"code":"(fn [s]\n  (zero? (count (filter seq (for [i s j s :while (not= i j)]\n    (clojure.set/intersection i j))))))","user":"546ff835e4b00cfc9eacc1b4"},{"code":"#(every? true?\n  (for [s1 % s2 %]\n    (or (= s1 s2)\n        (empty? (clojure.set/intersection s1 s2)))))","problem":153,"user":"4f8345c6e4b033992c121c1b"},{"code":"(fn [s] (= (reduce #(+ %1 (count %2)) 0 s) (count (apply clojure.set/union s))))","problem":153,"user":"4fa78336e4b081705acca1c4"},{"problem":153,"code":";;First solution\n;(fn [sets]\n;  (every? empty?\n;          (for [s1 sets\n;                s2 (remove #{s1} sets)]\n;            (clojure.set/intersection s1 s2))))\n(fn [s] (let [l (reduce into '() s)] \n          (= (count l) (count (set l)))))","user":"573118ebe4b0cd1946bd0fbd"},{"code":"(fn [v]\n  (= 0 (reduce + (for [v1 v\n        v2 v]\n    \n    (if (= v1 v2) 0 (reduce + (for [vv1 v1\n                                                   vv2 v2]\n                                               (if (= vv1 vv2)\n                                                 1\n                                                 0\n                                               )))\n      )\n    )))\n\n  \n  )","problem":153,"user":"51bec919e4b013aa0d74b800"},{"problem":153,"code":"(fn [c]\n  (let [v (->> c (map #(into [] %)) (apply concat))]\n    (= v (distinct v))))","user":"5541fa50e4b0a04f79299515"},{"code":"#(=\n    (reduce (fn [x y] (+ x (count y))) 0 %)\n    (count (reduce clojure.set/union %)))","problem":153,"user":"4e823ed7535db62dc21a62c7"},{"problem":153,"code":"(fn [sofs]\n   ((fn firstRest [fs, rs]\n      (if (empty? rs)\n        true\n        (and (empty? (filter #(not (empty? (clojure.set/intersection fs %))) rs))\n             (firstRest (first rs) (rest rs))))) (first sofs) (rest sofs)))","user":"60882700e4b0ae75613dcedf"},{"problem":153,"code":"#(every? empty? (for [s1 % s2 %] (when (not= s1 s2) (clojure.set/intersection s1 s2))))","user":"541b37d2e4b01498b1a71a64"},{"problem":153,"code":"#(let [xs (apply concat %)]\n   (= (count xs)\n      (count (set xs))))","user":"590b8607e4b047aa04b199db"},{"code":"(fn [x]\n  (let [sumcounts\n        (reduce + (map count x))\n\n        countunique\n        (count (reduce into x))]\n    (= sumcounts countunique)))","problem":153,"user":"4f0d093b535d0136e6c22313"},{"problem":153,"code":"(fn [sets] (= (count (apply clojure.set/union sets))\n              (apply + (map count sets))))","user":"52173464e4b082aa80a88c75"},{"problem":153,"code":"#(->> % (apply concat) (apply distinct?))","user":"5472d919e4b094393f72dd7b"},{"problem":153,"code":"(fn [s]\n  (letfn [(union-total [st]\n            (count (apply clojure.set/union st)))\n          (added-counts [st]\n            (reduce #(+ %1 (count %2)) 0 st))]\n    (= (union-total s) (added-counts s))))","user":"5a512929e4b05d388ecb6be2"},{"code":"#(loop [acc #{} s %]\n   (if (empty? s) true\n       (let [a (first s)]\n         (if (empty? (clojure.set/intersection acc a))\n           (recur (clojure.set/union acc a) (rest s))\n           false))))","problem":153,"user":"52d1e364e4b0d9f9285948e7"},{"problem":153,"code":"(fn [ss]\n  (letfn [(flaten-sets [l]\n          (loop [li l r ()]\n            (if (empty? li)\n              r\n              (recur (rest li) (concat r (first li))))))]\n    (loop [li (flaten-sets ss) r #{}]\n      (if (contains? r (first li))\n        false\n        (if (empty? li)\n          true\n          (recur (rest li) (conj r (first li))))))))","user":"52979551e4b02ebb4ef75043"},{"problem":153,"code":"(fn ([s]\n      (empty? (for [a s, b s\n             :let [intr (clojure.set/intersection a b)]\n             :when (not-empty intr)\n             :while (not= a b)]\n         intr))))","user":"573107d5e4b0cd1946bd0fbc"},{"code":"(fn [s]\n  (let [len1 (apply + (map count s))\n        len2 (count (apply clojure.set/union s))]\n    (= len2 len1)))","problem":153,"user":"518ccf6be4b05e6c8537e386"},{"problem":153,"code":"#(=\n  (reduce + (map count %))\n  (count (reduce (partial reduce (fn [acc el] (conj acc el))) %)))","user":"5ab5f60be4b073f177442643"},{"code":"#(= (count (reduce into %))\n    (apply + (map count %)))","problem":153,"user":"510db6cde4b078ea71921145"},{"problem":153,"code":"(fn [s]\n  (= (reduce #(+ % (count %2)) 0 s) (count (reduce into s))))","user":"53b7c21ae4b047364c0444d4"},{"problem":153,"code":"(fn inter [z]\n     (letfn [  (isDistinct [x y] \n           \n\t   (loop [i 0]\n\t    (cond \n\t      (>= i (count y)) true      \n\t      (not (empty? (clojure.set/intersection x (get (into [] y) i)))) false\n\t      :else (recur (inc i)) \n\t    )\n\t  )\n\t)] \n\t \n    (cond\n\t    (empty? (set (next z))) true\n\t    (not (isDistinct (first z) (set (next z)))) false\n\t    :else (inter (set (next z))) \n     )\t    \n   )\n   )","user":"56e6e1e6e4b02e7e935eb6cf"},{"code":"(fn [xs] (= (count (reduce #(into %1 %2) #{} xs))\n            (reduce + (map count xs))))","problem":153,"user":"513d121fe4b0e544971636a2"},{"problem":153,"code":"#(= \n   (apply + (map count %)) \n   (count (apply clojure.set/union %)))","user":"55249f64e4b0882d96d091c6"},{"code":"(fn [sets]\n  (let [total (reduce #(+ % (count %2)) 0 sets),\n        all (into #{} (for [subset sets v subset] v))]\n    (= total (count all))))","problem":153,"user":"51a7b4fee4b0da5f497bde8b"},{"problem":153,"code":"(fn [ss]\n  (let [count-each (reduce + (map count ss))\n        count-all (count (reduce into ss))]\n    (= count-each count-all)))","user":"5a188be3e4b0ff51aa4b31ec"},{"problem":153,"code":"(fn pair [sets]\n  (every? true? (for [s1 sets s2 sets :when (not= s1 s2)] (= #{} (clojure.set/intersection s1 s2)))))","user":"5510aa92e4b06e50f9beb188"},{"problem":153,"code":"(fn [xs]\n   (= (count (reduce into xs)) (apply + (map count xs))))","user":"511688d5e4b0b3e208dba05a"},{"problem":153,"code":"#(every? true? (for [x % y % :when (not= x y)] (empty? (clojure.set/intersection x y))))","user":"505345d9e4b0517ede0d0a06"},{"problem":153,"code":"#(apply distinct? (mapcat seq (seq %)))","user":"5470699ae4b00cfc9eacc1b6"},{"code":"(fn pairwise-disjoint? [sets]\n  (every?\n    empty?\n    (for [s1 sets, s2 sets :when (not= s1 s2)]\n      (clojure.set/intersection s1 s2))))","problem":153,"user":"4eb9ce75535dfed6da9c6d5e"},{"problem":153,"code":"(fn[s](=\n         (reduce + (map count s))\n         (count(apply clojure.set/union s))\n                  ))","user":"56039843e4b04bb52996e1be"},{"code":"#(every? true? ((fn ddd [x]\n   (when-let[s (seq x)]\n     (cons \n      (every? false?   \n        (for[a (first s) b (rest s)]\n         (contains? b a)\n         ))\n      (ddd (rest s)))\n       )\n    )%))","problem":153,"user":"52bbd09ee4b07a9af57922ee"},{"problem":153,"code":"(fn dis\n  [s]\n  (if (= (count s) 1)\n    true\n    (and (dis (next s))\n         true\n         (every? identity (for [t (rest s)]\n           (empty? (clojure.set/intersection t (first s)))))\n         )))","user":"541ef7e2e4b01498b1a71a92"},{"problem":153,"code":"(fn my-pairs [ssx]\n  (nil? (some false? (flatten ((fn pairs [ssx]\n                            (for [sx ssx]\n                              (for [x sx]\n                                (for [sy ssx :when (not (= sy sx))]\n                                  (for [y sy]\n                                    (if (= x y)\n                                      false))))))\n                           ssx))))\n  )","user":"5c24c654e4b07e362c2305a7"},{"problem":153,"code":"#(every?\n   zero?\n   (for [x %\n         y %\n         :when (not= x y)]\n     (count\n      (clojure.set/intersection x y))))","user":"4eb47bb1535d7eef30807362"},{"problem":153,"code":"(fn [sets] (let [[s c]\n             (reduce (fn [[s c] x] [(clojure.set/union s x) (+ c (count x))]) [#{} 0] sets)]\n             (= (count s) c)))","user":"5901158de4b0438e51c2d039"},{"problem":153,"code":"(fn dis [n]\n  (let [as-list (mapcat identity (map #(apply list %) n))\n        as-set (set as-list)]\n    (= (count as-list) (count as-set))))","user":"51a1659de4b00957e520db72"},{"code":"(fn pd [sets]\n  (let [x (first sets)\n        xs (rest sets)]\n    (or (nil? x)\n        (and (every? #(empty? (clojure.set/intersection x %)) xs)\n             (pd xs)))))","problem":153,"user":"511aa2a4e4b0c87c59c9670a"},{"problem":153,"code":"(fn [s]\n  (apply distinct? (apply concat s)))","user":"553b0d95e4b09218d5f44fff"},{"code":"(fn i [xxs]\n   (let [x (first xxs)\n         xs (rest xxs)]\n     (if-not x\n       true\n       (if (some identity (for [e x\n                                o xs]\n                            (contains? o e)))\n         false\n         (i xs)))))","problem":153,"user":"4dc537fd535d8a4b2fd74282"},{"problem":153,"code":"(fn [sets]\n  (loop [sets sets os #{}]\n    (if (empty? sets)\n      true\n      (if (every? #(= false %) (map #(contains? os %) (first sets)))\n        (recur (rest sets) (set (concat os (first sets))))\n        false\n      )\n    )\n  )\n)","user":"5bdf651ee4b0ed4b8aab4c6d"},{"problem":153,"code":"(fn no-dupl [ss]\n  (let [nb-elem (reduce #(+ %1 (count %2)) 0 ss)]\n    (= nb-elem (count (apply clojure.set/union ss)))))","user":"5a6b9b95e4b0512ff01cda40"},{"code":"(fn [ss] (\n  reduce (fn [a b] (and a b)) (flatten (map-indexed \n    (fn [i s] (\n      map #(= 0 (count (clojure.set/intersection % s))) (drop (inc i) ss)\n    ))\n  ss))\n))","problem":153,"user":"4ef48422535dced4c769f236"},{"problem":153,"code":"#(empty? (for [s % \n                o (disj % s) \n                :when (not-empty (clojure.set/intersection s o))] \n            1))","user":"52a267c6e4b04e0c58e87bef"},{"problem":153,"code":"#(->> % (mapcat seq) (apply distinct?))","user":"4fe8da4de4b0547ebccb2429"},{"problem":153,"code":"(fn [setargs]\n    (= (count (for [a setargs\n          b setargs\n          :let [z (clojure.set/intersection a b)]\n          :when (seq z)]\n          z)) (count setargs)))","user":"5a4b3abde4b05d388ecb6b81"},{"code":"#(=\n  (apply +\n    (map count %))\n  (count\n    (apply clojure.set/union %)))","problem":153,"user":"50427899e4b0add3005c0fc2"},{"problem":153,"code":"(fn [coll] \n   (every? identity \n   (for [i coll j coll k j]\n      (cond\n        (= i j) true \n        (contains? i k) false\n        :else true\n        ))\n     ))","user":"55aa1637e4b0988bba2ad949"},{"problem":153,"code":"(fn [coll]\n  (->> (mapcat (partial map identity) coll)\n       (apply distinct?)))","user":"5666500ee4b0e91d5f5c566d"},{"code":"(fn [s]\n  (every? empty? (for [a s b s :when (not= a b)] (filter #(contains? a %) b)))\n  )","problem":153,"user":"528e64b7e4b0239c8a67aedd"},{"problem":153,"code":"(fn pairwise-disjoint? [s]\n  (= (count\n      (apply concat '() s))\n     (count\n      (apply clojure.set/union s))))","user":"5fbf6fe7e4b0ad6fc3476147"},{"problem":153,"code":"(fn dis [s]\n  (let [one-big-list (for [ss s\n                           e ss]\n                       e)]\n    (= (count one-big-list) (count (set one-big-list)))))","user":"5b2689e3e4b063e2438bcc33"},{"problem":153,"code":"(fn uniq-sets [ss]                                   (cond (empty? ss) true                                     (every? (fn [s]                                                (every? (fn [current]                                          (every? (fn [c]                                                (not= current c))                                                                                      s))                                        (first ss)))                               (rest ss))                                   (recur (rest ss))                                    :else false))","user":"5895477fe4b00487982d527c"},{"problem":153,"code":"(fn pds [s]\n  (letfn [(cont [v ss]\n            (loop [ss ss]\n              (if (empty? ss)\n                false\n                (if (contains? (first ss) v)\n                  true\n                  (recur (rest ss))))))\n          (contv [sv ss]\n            (loop [sv sv]\n              (if (empty? sv)\n                false\n                (if (cont (first sv) ss)\n                  true\n                  (recur (rest sv))))))]\n    (loop [s (seq s)]\n      (if (empty? s)\n        true\n        (if (contv (seq (first s)) (rest s))\n          false\n          (recur (rest s)))))))","user":"5f8b06afe4b0715f5002d74a"},{"problem":153,"code":"(fn pairwise-disjoint? [sets]\n  (let\n    [all-pairs (fn [coll]\n      (loop [\n        [x & xs] coll\n        result []]\n        (cond\n          (nil? xs) result\n          :else     (recur xs (concat result (map #(vector x %) xs))))))]\n    (every? empty? (map #(apply clojure.set/intersection %) (all-pairs (seq sets))))))","user":"55d5e80ee4b0e31453f64a91"},{"problem":153,"code":"(fn [colls]\n          (not (some (fn [target]\n                   (some (fn [other-set]\n                           ((complement empty?) (clojure.set/intersection target other-set)))\n                         (disj colls target)))\n                 colls)))","user":"531c6e72e4b08068f379eda0"},{"code":"(fn pairwise\n  [x]\n  (loop [rst (reduce into x)]\n    (if (empty? rst) true\n      (if (> (count (filter #(contains? % (first rst)) x)) 1) false\n        (recur (rest rst))))))","problem":153,"user":"52084f75e4b01ce6bbf31dde"},{"problem":153,"code":"(fn foo [c]\n    (if (empty? c)\n        true\n        (let [x (first c)\n              xs (rest c)]\n            (boolean (and\n                         (every? (fn [y] (every? (fn [e] (not (contains? x e))) y)) xs)\n                         (foo xs))))))","user":"600ae927e4b074f607df6689"},{"problem":153,"code":"#(= \n  (->> % (mapcat identity) (reduce conj #{}) (count)) \n  (->> % (map count) (reduce +))\n)","user":"5280a1ece4b0757a1b171407"},{"problem":153,"code":"#(= (count (set (mapcat identity %)))\n    (reduce + (map count %))\n    )","user":"50856bd1e4b004985b776e4c"},{"problem":153,"code":"(fn [sets]\n    (= (count (set (apply concat sets)))\n       (apply + (map count sets))))","user":"603d5f2ae4b0d5df2af2230c"},{"problem":153,"code":"(fn disjoint [sets]\n  (let [vals (->> sets\n                  (mapcat identity)\n                  (group-by identity)\n                  vals\n                  (filter #(>= (count %) 2)))]\n    (if (empty? vals)\n      true\n      false)))","user":"5ca14eb1e4b048ec896c5b7d"},{"problem":153,"code":"#(apply distinct? (for [s %\n                        e s]\n                   e))","user":"4f85a75ce4b033992c121c48"},{"problem":153,"code":"(fn cool [ss]\n  (let [merged (apply clojure.set/union ss)\n        cnts (map count ss)\n        cnt (apply + cnts)]\n    (= cnt (count merged))))","user":"57db2369e4b0bd073c20241f"},{"code":"(fn [set-set]\n  (let [s (apply concat set-set)]\n    (= (count s)\n     (count (set s)))))","problem":153,"user":"52a55adee4b0c58976d9abe7"},{"code":"#(every? empty? \n  (for [a % b % :when (not (= a b))] \n    (clojure.set/intersection a b)))","problem":153,"user":"502904e0e4b0feaf66e22fad"},{"problem":153,"code":"(fn [s]\n      (loop [u #{} r s]\n           (cond\n               (empty? r) true\n               (not(empty? (clojure.set/intersection (first r) u))) false\n               :else (recur (clojure.set/union (first r) u) (rest r))\n           )\n      )\n)","user":"550e0373e4b06e50f9beb162"},{"code":"(fn [x]\n  (= (reduce + (map count x))\n     (count (reduce clojure.set/union x))))","problem":153,"user":"50ef56dfe4b0bdaecbb47d94"},{"problem":153,"code":"(fn pds\n  [s]\n  (empty? (filter #(not (empty? %))\n                  (for [x s y s :when (not= x y) ]\n                           (clojure.set/intersection x y) ))) \n  )","user":"51f81925e4b09be9c177e526"},{"code":"(fn [coll]\n  (let [[f & r] (seq coll)]\n  (cond (empty? r) true\n        (every? (fn [elt] (empty? (clojure.set/intersection f elt))) r) \n          (recur r)\n        :otherwise false)))","problem":153,"user":"4fb1d907e4b081705acca282"},{"code":"(fn pairwise-disjoint [sets]\n        (let [conced (apply concat sets)]\n          (= (count conced) (count (set conced)))))","problem":153,"user":"4e589bdc535d8a8b8723a295"},{"code":"(fn [ss]\n  (boolean\n   (every? false?\n           (for [s1 ss\n                 s2 ss\n                 e1 s1\n                 e2 s2\n                 :when (not= s1 s2)]\n             (= e1 e2)))))","problem":153,"user":"51a8f0c6e4b08d8ec191b821"},{"code":"(fn [sets]\n   (not\n     (some (fn [cset]\n             (some \n               (fn [oset]\n                 (when\n                   (not (= cset oset))\n                   (some #(contains? oset %) cset)))\n               sets))\n             sets)))","problem":153,"user":"4fa5406fe4b081705acca1ac"},{"problem":153,"code":"(fn [sets]\n  (every? #(= % 1)(vals (frequencies (apply concat sets)))))","user":"55ecb2c0e4b0121d4835fdce"},{"problem":153,"code":"(fn [s] (zero? (apply + (for [x s y s :when (not= x y)] (count (clojure.set/intersection x y))))))","user":"55b0f5bfe4b002ce9d5cbc28"},{"problem":153,"code":"(fn [sets]\n  (let [total-count (count (reduce into #{} sets))\n        sum-count (reduce #(+ % (count %2)) 0 sets)]\n    (= total-count sum-count)))","user":"53d86564e4b0e771c302546b"},{"code":"(fn [sos]\n  (every? empty? (for [s1 sos\n                       s2 sos\n                       :when (not= s1 s2)]\n                   (clojure.set/intersection s1 s2))))","problem":153,"user":"4ee528fb535d1385b2869d87"},{"problem":153,"code":"(fn [s]\n  (every? (partial = #{}) (for[x s y s :when (not= x y)] (clojure.set/intersection x y))))","user":"53ae0c50e4b047364c044471"},{"problem":153,"code":"#( reduce (fn [s1 s2] (and s1 s2))   (filter (fn [z] (not(nil? z)) ) (for [x % y %] (if (not= x y)\n                                                                                    (if(empty? (clojure.set/intersection \n                                                                                                                    x y ))\n                                                                                      true\n                                                                                      false)  )  )   ) )","user":"5cbd5b42e4b026601754b9f6"},{"problem":153,"code":"(fn\n  [set]\n  (loop [res #{}\n         set set]\n    (if (empty? set)\n      true\n      (let [repeated (loop [res res\n                            set (first set)]\n                       (if (empty? set)\n                         false\n                         (if (contains? res (first set))\n                           true\n                           (recur (conj res (first set)) (rest set)))))\n            res (loop [res res\n                       set (first set)]\n                  (if (empty? set)\n                    res\n                    (recur (conj res (first set)) (rest set))))]\n        (if repeated\n          false\n          (recur res\n                 (rest set)))))))","user":"5c706232e4b0fca0c162277e"},{"code":"(fn [s]\n   (let [k (distinct (flatten (letfn [(common [a b]\n   (not= 0 (.size (clojure.set/intersection a b))))]\n\t(map-indexed (fn [index item]\n      (map #(common item %) (nthnext s (inc index)))\n    ) s))))]  (and (== 1 (.size k)) (not (first k))))\n)","problem":153,"user":"510a6bece4b06956752d35af"},{"code":"#(every?\n    (fn [x]\n      (empty?\n        (clojure.set/intersection x (set (apply clojure.set/union (disj % x))) )\n        )\n      ) %\n    )","problem":153,"user":"52761edae4b03e8d9a4a74d4"},{"problem":153,"code":"(fn pairwise-disjoint-sets [sets]\n  (let [ret (apply concat sets) len (count ret)]\n    (= (count (into #{} ret)) len)))","user":"5693a53ee4b0dcc4269f4106"},{"problem":153,"code":"(fn [c] \n  (cond\n   (empty? c) true\n   (some (fn [x] (not-empty (clojure.set/intersection (first c) x))) (rest c)) false\n   1 (recur (rest c))))","user":"555883c5e4b0deb715856e2d"},{"problem":153,"code":"(fn [s]\n    (= (apply + (map count s))\n       (count (apply clojure.set/union s))))","user":"56018dd4e4b04bb52996e18f"},{"code":"(fn [SoS] (zero? (count (filter #(> (val %) 1) (frequencies (reduce concat (map (partial into []) SoS)))))))","problem":153,"user":"4ff76effe4b0678c553fc390"},{"problem":153,"code":"(fn __ [st]\n  (let [\n        unio (reduce clojure.set/union st)\n        size (reduce (fn [acc x] (+ acc (count x))) 0 st)\n        ]\n    (= size (count unio))))","user":"58bc6a88e4b0888cdc949d16"},{"code":"(fn md [st]\n    (if (= 1 (count st))\n        true\n        (let [a (first st)\n              b (rest st)]\n             (and (every? true? (map #(empty? (clojure.set/intersection a %)) b))\n                  (md (rest st))))))","problem":153,"user":"528a3e14e4b0239c8a67ae72"},{"code":"(fn [s]\n  (every? empty?\n  (for [x s\n        y s\n        :when (not= x y)]\n    (clojure.set/intersection  x y))))","problem":153,"user":"51dd9370e4b0c33a4e1da40c"},{"code":"#(= (apply + (for [s %] (count s))) (count (reduce (fn [s1 s2](set (concat s1 s2))) #{} %)))","problem":153,"user":"4e16bdef535d04ed9115e7e9"},{"problem":153,"code":"(partial\n\t(fn [union sets]\n\t\t(cond (empty? sets) true\n\t\t\t  (seq (filter (partial contains? (first sets)) union)) false\n\t\t\t  :else (recur (into union (first sets)) \n\t\t\t\t           (rest sets))))\n\t#{})","user":"5af8221ce4b0cc2b61a3bccd"},{"code":"(fn[s] (= (reduce #(+ % (count %2)) 0 s) (count (reduce into s))))","problem":153,"user":"5093ca51e4b097f48cc38585"},{"problem":153,"code":"(fn disjoint? [s]\n    (let [ss (seq s)\n          lenght (count ss)]\n\n      (every? empty?\n              (for [s1 (range lenght)\n                    s2 (range lenght)\n                    :when (not= s1 s2)]\n                (clojure.set/intersection (nth ss s1) (nth ss s2))\n                ))\n      )\n    )","user":"56791447e4b05957ce8c6183"},{"problem":153,"code":"(fn [coll](empty? (filter #(not (empty? %)) (for [x coll y coll] (if (= x y) #{} (clojure.set/intersection x y))))))","user":"53a1b5c8e4b0ca733b9744c1"},{"code":"#(= (% #{} %2)(% [] %2))\n#(count (reduce into % %2))","problem":153,"user":"4e49badd535dc968683fc4c9"},{"code":"(fn disjoint [set-of-sets]\r\n  (loop [consider-set (first set-of-sets)\r\n   remaining-sets (rest set-of-sets)]\r\n    (println \"cs \" consider-set \" rest \" remaining-sets)\r\n    (if (empty? remaining-sets)\r\n      true\r\n      (if (some #(not (= #{} (clojure.set/intersection consider-set %))) (disj set-of-sets consider-set))\r\n\t(do\r\n\t  (println consider-set)\r\n\t  (println (clojure.set/intersection consider-set (disj set-of-sets consider-set)))\r\n\t  false\r\n\t  )\r\n\t(recur (first remaining-sets) (rest remaining-sets))))))","problem":153,"user":"504ec4d3e4b069badc5a33c9"},{"code":"(fn [c] (= (apply + (map count c)) \n           (count (reduce into c))))\n\n;(fn [s]\n;  (let [r (rest s)]\n;    (if (nil? (first r))\n;      true\n;      (if (every? empty? (for [x r] (clojure.set/intersection (first s) x)))\n;        (recur r)\n;        false))))","problem":153,"user":"4f7207d3e4b07046d9f4f019"},{"problem":153,"code":"(fn [s]\n  (->>\n   (for [x s y s :while (not (= x y))] (clojure.set/intersection x y))\n  (map count)\n  (every? zero?)))","user":"54a96a15e4b09f271ff37cad"},{"code":"not-any? #(some #{'+ 0 [] :a} %)","problem":153,"user":"4f6fbb68e4b07046d9f4efeb"},{"problem":153,"code":"(fn p [a]\n  (let [all (apply concat '()  a)\n        setAll (set all)]\n    (= (count all) (count setAll))))","user":"4f4aa932e4b0d56e7bb92c14"},{"problem":153,"code":"(fn mutually-disjoint? [sets]\n  (let [intersection (fn intersection [a & sets] \n                       (if-not (seq sets) \n                         a \n                         (filter (partial contains? a) (apply intersection sets))))]\n    (every? identity (map (fn [s] \n                            (every? #(empty? (intersection s %)) \n                                    (remove #{s} sets))) \n                          sets))))","user":"5c506951e4b0f9f7a8770ec5"},{"problem":153,"code":"(fn [sets]\n    (not (false? (reduce (fn [all new-set]\n                           (if all\n                             (let [intersection (clojure.set/intersection all new-set)]\n                               (if (empty? intersection)\n                                 (clojure.set/union all new-set)\n                                 false))\n                             false)) #{} sets))))","user":"52f53589e4b05e3f0be25f2c"},{"code":"(fn [sets]\n  (let [a (reduce concat (into [] (map #(into [] %) sets)))]\n    (= a (distinct a))))","problem":153,"user":"4fde492be4b05e33b9224f8a"},{"problem":153,"code":"(fn [sets] \n  (every? \n    #(= 1 (count %)) \n    (map (fn[this] \n           (filter \n             (fn [other] (some #(this %) other)) \n             sets)) \n          sets)))","user":"5a0ef454e4b04bbd27e6d9fa"},{"problem":153,"code":"(fn [sets]\n\t(not (contains? (reduce #(if (nil? (some %1 %2))\n\t\t\t\t(into #{} (concat %1 %2))\n\t\t\t\t(conj %1 nil)) #{} sets) nil)))","user":"5954eef0e4b066ee0a44af17"},{"problem":153,"code":"(fn [s]\n  (let [items (reduce into [] s)]\n    (= (count items) (count (distinct items)))))","user":"5317d78ee4b08068f379ed63"},{"code":"(fn [sets]\n           (let [ci (reduce #(+ %1 (count %2)) 0 sets)\n                 cj (count (reduce into #{} sets))]\n             (= ci cj)))","problem":153,"user":"4fccb31be4b0ee37620e1868"},{"problem":153,"code":"(fn pairwise-disjoint? [s]\n  (letfn [(pd? [s1 s2] (empty? (clojure.set/intersection s1 s2)))]\n    (or (empty? s) \n        (= 1 (count s))\n        (and (reduce (fn [prev el] (and prev el))\n                     (map #(pd? % (first s)) (rest s)))  \n             (recur (rest s))))))","user":"5514a60fe4b055c2f668d4d7"},{"problem":153,"code":"(fn [coll]\n  (let [x (mapcat #(into '() %) coll)]\n    (= (count x)\n       (count (into #{} x)))))","user":"52474133e4b05ef8e38e635e"},{"code":"(fn disjoint? [sets]\n  (loop [ union (apply clojure.set/union sets)\n          to-test (first sets)\n          remaining (next sets) ]\n    (if to-test\n      (if (clojure.set/subset? to-test union)\n          (recur (clojure.set/difference union to-test)\n                 (first remaining)\n                 (next remaining))\n          false)\n      true)))","problem":153,"user":"4e356d2b535deb9a81d77f2d"},{"problem":153,"code":"(fn [ss]\n  (let [pairs (fn [sq] (mapcat (fn [s] (map #(vector s %) (disj ss s))) ss))]\n    (zero? (reduce + (map (fn [[a b]] (count (clojure.set/intersection a b))) (pairs ss))))))","user":"563ed73ae4b08d4f616f5ecb"},{"code":"(fn [set]\n  (let\n    [union\n      (reduce into #{} set)\n     sum\n      (reduce #(+ %1 (count %2)) 0 set)]\n  (= sum (count union))))","problem":153,"user":"4f7f9665e4b033992c121bea"},{"problem":153,"code":"(fn\n  [s]\n  (every? #(= true %) (for [x s\n                            y s]\n                        (if (= x y)\n                          true\n                          (empty? (clojure.set/intersection x y))))))","user":"57d0cd58e4b0bd073c20235e"},{"problem":153,"code":"#(and (reduce (fn [col x] (if (or (= col false) (some (partial contains? col) x)) false (apply conj col x))) %) true)","user":"594d4c57e4b07ddc2dafae87"},{"problem":153,"code":"(fn no-common?\n  [set-of-set]\n  (if (empty? set-of-set)\n    true\n    (let [f (first set-of-set)\n          others (rest set-of-set)]\n      (and\n       (every? empty? (map #(clojure.set/intersection f %) others))\n       (no-common? others)))))","user":"56897739e4b0dcc4269f407d"},{"code":"(fn [sets]\n  (=\n    (reduce + (map count sets))\n    (count (reduce into sets))))","problem":153,"user":"53779a26e4b06839e8705e38"},{"problem":153,"code":"(fn pwdj [sets]\n  (loop [comb #{} lft sets cnt 0]\n    (if (empty? lft)\n      (= (count comb) cnt)\n      (recur (into comb (first lft)) (rest lft) (+ cnt (count (first lft)))))))","user":"53791ab7e4b06839e8705e4d"},{"problem":153,"code":"(fn [s]\n    (= (reduce #(+ %1 (count %2)) 0 s)\n       (count\n         (reduce clojure.set/union s)\n         )\n       )\n    )","user":"5c17467fe4b01240ff5671df"},{"code":"#(every? empty? (for [s1 % s2 %] (if (= s1 s2) #{} (clojure.set/intersection s1 s2))))","problem":153,"user":"4e976f79535dbda64a6f6b55"},{"problem":153,"code":"#(let [s (mapcat seq %)] (= (count (set s)) (count s)))","user":"563c6ebae4b0bfe05bf11834"},{"code":"(fn [ss]\n  (reduce\n    #(and % %2)\n    (for\n      [s1 ss s2 ss :when (not= s1 s2)]\n      (empty? (clojure.set/intersection s1 s2)))))","problem":153,"user":"4f4e7c01e4b03ad3f0c10cc9"},{"problem":153,"code":"(fn pairwise-disjoint-set? [sets]\n\t(if (= 1 (count sets))\n\t\ttrue\n\t\t(if (not ((fn pairwise-disjoint? [a-set s-set]\n\t(if (empty? s-set)\n\t\ttrue\n\t\t(if (not ((fn disjoint? [a b]\n\t(empty? (clojure.set/intersection a b))) a-set (first s-set)))\n\t\t\tfalse\n\t\t\t(pairwise-disjoint? a-set (rest s-set))))) (first sets) (rest sets)))\n\t\t\tfalse\n\t\t\t(pairwise-disjoint-set? (rest sets)))))","user":"563d12f9e4b0bfe05bf11845"},{"problem":153,"code":"(fn [s]\n  (let [c1 (reduce #(+ %1 (count %2))\n                   0 s)\n        c2 (count (reduce #(into %1 %2)\n                          #{} s))]\n    (= c1 c2)))","user":"557c6ca6e4b05c286339e0c4"},{"problem":153,"code":"#(apply distinct? (tree-seq set? identity %))","user":"5a527beee4b05d388ecb6bfe"},{"problem":153,"code":"(fn pw-disj [ss]\n  (let [dis (fn [xs ys]\n              (empty? (clojure.set/intersection xs ys)))]\n    (if-let [[s & ss] (seq ss)]\n      (and (pw-disj ss)\n           (every? (partial dis s) ss))\n      true)))","user":"548fa2dfe4b0e286459a1240"},{"code":"(fn [ss] (reduce #(and %1 (= %2 1)) true (vals (frequencies  (reduce concat () (map seq ss)))) ))","problem":153,"user":"5301a13ae4b0d8b024fd371e"},{"problem":153,"code":"#(apply distinct? (apply concat %))\n; aceeca1's solution","user":"5e13a6b7e4b099d064963001"},{"code":"(fn  [ss] (empty?  (filter (fn [v] (< 1 (count (second v))))  (group-by (fn [v] v) (for [s ss s1 s] s1 )))) )","problem":153,"user":"53a5bc3ae4b0ef122a8689c3"},{"problem":153,"code":"(fn sol [sets] (= (count (into #{} (for [set sets x set] x))) (reduce #(+ %1 (count %2)) 0 sets)))","user":"54857657e4b0e286459a11ac"},{"problem":153,"code":"(fn disjoint [sets]\n  (let [all-count (count (reduce (fn [a v] (set (concat a v))) #{} sets))\n        total (reduce (fn [a v] (+ (count v) a)) 0 sets)\n        ]\n    (= all-count total)\n    )\n\n  )","user":"53c73e8ae4b00fb29b2212a5"},{"problem":153,"code":"(fn pairwise-disjoint-sets\n  [sets]\n  (every? empty?\n          (for [x sets y (disj sets x)]\n            (clojure.set/intersection x y)))\n  )","user":"5c3ac091e4b0d62ef62d9f95"},{"problem":153,"code":"#(= (count (apply concat %)) (count (apply clojure.set/union %)))","user":"56824e1be4b0945ebc182a91"},{"problem":153,"code":"(fn test [ss]\n    (let [x (first ss) xs (disj ss x)\n            v1  (every? (fn [xs0] (= '() (filter #(contains? x %) xs0))) xs)\n            v2 (if (empty? xs)\n                   true\n                   (test xs))]\n        (and v1 v2))\n    )","user":"593f95d8e4b069cdc2982be3"},{"problem":153,"code":"(fn [sets]\n  (let [s (flatten \n     (for [s1 sets]\n      (for [s2 (rest sets)]\n       (if (= s1 s2) #{} (clojure.set/intersection s1 s2)))))]\n  (empty? \n   (remove #(= % #{}) s))))","user":"55aaa36fe4b0988bba2ad94f"},{"code":"(fn [xs]\n  (let [x (first xs)\n        ys (rest xs)]\n    (and\n     (every? (fn [y] (empty? (clojure.set/intersection x y))) ys)\n     (or (empty? xs) (recur ys)))))","problem":153,"user":"50fbf811e4b0d10d794c19f1"},{"problem":153,"code":"(fn [coll] (apply distinct? (mapcat seq coll)))","user":"564a560ae4b0284900eef654"},{"problem":153,"code":"(fn disj? [sets] (let [c1 (reduce + (map count sets))\n                         c2 (count (into #{} (reduce concat sets)))]\n                         (= c2 c1)\n                     ))","user":"5592bf9fe4b0c79f6e1db933"},{"problem":153,"code":"(fn dist? [s]\n  (= (reduce + (map count s)) (count (set(apply concat s)))))","user":"57bd960fe4b05aa3c4741c52"},{"problem":153,"code":"(fn \n  [s]\n  (=\n    (count\n      (apply concat '() s))\n    (count\n      (apply clojure.set/union s))))","user":"57fedf07e4b0d3187e9009dc"},{"code":"(fn [sets]\n  (apply distinct? (mapcat seq sets)))","problem":153,"user":"5173726be4b098276e74652c"},{"code":"(fn f [s]\n  (let [ss (seq s)\n        len (count ss)]\n    (loop [a 0\n           b (inc a)]\n      (let [s1 (nth ss a)\n            s2 (nth ss b)]\n        (if (contains? s1 '+) \n          false\n          (if (not= 0 (count (filter s1 s2)))\n          false\n          (if (>= a (- len 2))\n            true\n            (if (>= b (dec len))\n              (recur (+ 1 a) (+ 2 a))\n              (recur a (inc b))))))))))","problem":153,"user":"52196842e4b0890f2f822bfa"},{"code":"(fn [s]\n  (loop [s1 (first s)\n         sr (rest s)]\n    (cond (empty? sr) true\n          (reduce\n           (fn [accu s2]\n             (or accu (not (empty? (clojure.set/intersection s1 s2)))))\n           false\n           sr) false\n          :else (recur (first sr) (rest sr)))))","problem":153,"user":"4e82c062535db62dc21a62cc"},{"code":"(fn [sos]\n  (letfn [(union-all [sos] \n                      (reduce clojure.set/union sos))\n          (count-all [sos]\n                     (reduce #(+ %1 (count %2)) 0 sos))]\n    (= (count (union-all sos)) (count-all sos))))","problem":153,"user":"4ed286d4535d44c135fd68d7"},{"code":"#(== (count (apply clojure.set/union %))\n     (apply + (map count %)))","problem":153,"user":"4dbdab4e535d020aff1edf49"},{"code":"#(->> (apply concat %) (apply distinct?))","problem":153,"user":"4effb663535dcb61093f6a2e"},{"problem":153,"code":"(fn [sos]\n  (every? true?\n          (for [s1 sos\n                s2 (disj sos s1)]\n            (and (every? nil? (map s1 s2))\n                 (not (and (contains? s1 nil)\n                           (contains? s2 nil)))))))\n\n; (fn [sos]\n;   (= (->> sos (map count) (apply +))\n;      (->> sos (mapcat seq) set count)))","user":"5d24e49be4b02ea6f0fb6a2a"},{"problem":153,"code":"(fn [sets]\n  (=\n    (reduce + (map #(count %) sets))\n    (count (set (mapcat #(concat %) sets)))))","user":"5e950178e4b0fbed045a3801"},{"problem":153,"code":"; I don't really get or like this question.\n; It seems like the solution required covers more than the question stated in the problem.\n; I'd suggest removing the overly complex final test cases.\n; Or changing the problem definition.\n; This is supposed to be an 'easy' question.\n\n;My answer comes from my good friend at https://github.com/tsclausing/4clojure/blob/master/src/com/fourclojure/problem/153.clj\n(fn [set-of-sets]\n(apply distinct? (apply concat set-of-sets))\n  )","user":"5535e822e4b09218d5f44fb2"},{"code":"(fn [sets]\n  (= (count (reduce into sets))\n     (reduce + (map count sets))))","problem":153,"user":"511442d0e4b0e9c109bb74d5"},{"problem":153,"code":"(fn [s]\n  (= (reduce #(+ %1 (count %2)) 0 s)\n     (count (apply clojure.set/union s))))","user":"5338387de4b0e30313ee6c91"},{"problem":153,"code":"(fn [set]\n   (= (count (apply clojure.set/union set)) (reduce + (map count set))))","user":"5cf895efe4b0b71b1d808a85"},{"problem":153,"code":"(fn [input]\n    (= (reduce #(+ %1 (count %2)) 0 input)\n       (count (reduce into #{} input))))","user":"54c13b87e4b0ed20f4ff6f20"},{"problem":153,"code":"#(let [col (apply concat %)\n       col2 (distinct col)]\n   (= col col2))","user":"5d02fe44e4b0cc9c915881c0"},{"code":"(fn [sets] (let [union   (reduce (fn [xs ys] (apply (partial conj xs) ys)) sets)\n                 lengths (reduce + 0 (map count sets))]\n             (= (count union) lengths)))","problem":153,"user":"51307b84e4b08c712d3fae39"},{"code":"#(apply distinct?\n     (mapcat vec %))","problem":153,"user":"4eb0a757535d7eef3080733d"},{"code":"(fn f [c]\n  (if-let [x (first c)]\n    (if (every? nil? (map #(seq (filter (partial contains? x) %))\n                            (rest c)))\n      (f (rest c))\n      false)\n    true))","problem":153,"user":"4ee4f4a9535d1385b2869d85"},{"code":"(fn [sets]\n  (every? (fn [xs]\n            (every? not\n              (map #(contains? xs %)\n                   (apply clojure.set/union (disj sets xs)))))\n          sets))","problem":153,"user":"5102ac9de4b00c483ae176fa"},{"code":"(fn i-am-so-lazy [allsets]\n  (empty?\n  (apply clojure.set/union\n    (for [x allsets y allsets :when (not (= x y))]\n      (clojure.set/intersection x y)))))","problem":153,"user":"515737f0e4b0b0b4b87062d0"},{"problem":153,"code":"(fn [sets]\n  (= (count (apply clojure.set/union sets)) (reduce + (map count sets)))\n)","user":"540f09b9e4b0addc1aec6725"},{"problem":153,"code":"(fn [s]\n   (let [elts (apply concat s)]\n     (apply distinct? elts)))","user":"54b817eee4b0ed20f4ff6e93"},{"problem":153,"code":"(fn [s]\n  (empty? (for [x s, y s\n                :let [i (clojure.set/intersection x y)]\n                :while (not= x y)\n                :when (not-empty i)] i)))","user":"5a99b688e4b0d174b936c7a6"},{"problem":153,"code":";#((fn [[comb & sets]]\n;    (if sets\n;      (and (not (< 0 (count (clojure.set/intersection comb (first sets)))))\n;           (recur (cons (clojure.set/union comb (first sets)) (rest sets))))\n;      (= 1 1))) (seq %))\n\n(fn [sets]\n  (= (reduce + (map count sets))\n     (count (reduce clojure.set/union sets))))","user":"6088395de4b0ae75613dcee2"},{"code":"(fn [sets]\n  (let [l (apply concat sets)]\n    (= (count l) (count (set l)))))","problem":153,"user":"4eccb190535d23f0362276fe"},{"problem":153,"code":"(fn [s]                                                                 \n  (= (count (apply concat s)) (count (apply clojure.set/union s))))","user":"563536f8e4b0bfe05bf117c5"},{"problem":153,"code":"#(->> %\n      (mapcat seq)\n      (apply distinct?))","user":"557e8326e4b05c286339e0d7"},{"code":"(fn [s] (= (count (reduce into s)) (reduce + (map count s))))","problem":153,"user":"51f2851fe4b0210f90e7454b"},{"problem":153,"code":"(fn bitwise-disjoint [s] \n                  (let [sets (vec s) size (count sets)]\n                    (every? identity (for [i (range 0 size) j (range (inc i) size)]\n                      (empty? (clojure.set/intersection (sets i) (sets j)))))))","user":"5654e024e4b0f9d632dd848d"},{"problem":153,"code":"#(empty? (reduce concat (for[s1 % s2 %] (when-not (= s1 s2) (clojure.set/intersection s1 s2)))))","user":"541619e8e4b01498b1a719f9"},{"problem":153,"code":"(fn [s]\n  (every? empty?\n          (for [s1 s\n                s2 s]\n            (if (not (= s1 s2))\n              (clojure.set/intersection s1 s2)))))","user":"58bb218be4b0888cdc949cf4"},{"problem":153,"code":"(comp #(= % (distinct %)) (partial apply concat))","user":"576e3258e4b0979f89651574"},{"problem":153,"code":"(fn my-fn [set-of-sets]                                                        \n  (let [uniq-els-count (->> set-of-sets                                          \n                            (reduce clojure.set/union)                           \n                            (count))                                             \n        all-els-count (->> set-of-sets                                           \n                           (map count)                                           \n                           (reduce +))]                                          \n    (= uniq-els-count all-els-count)))","user":"58ebd10de4b056aecfd47d49"},{"code":"(fn disjoint? [sets]\n  (empty? (for [s1 sets\n                s2 sets\n                :when (and (not= s1 s2) (some #(contains? s1 %) s2))]\n            [s1 s2])))","problem":153,"user":"5080a697e4b01a93d3f38e49"},{"problem":153,"code":"(fn [s]\n  (loop [rm (distinct (reduce concat s))]\n    (cond (empty? rm) true\n          (> (count (filter true? (map #(contains? % (first rm)) s))) 1) false\n          :else (recur (rest rm)))))","user":"538e36c7e4b0b51d73faae81"},{"code":"(fn pv-dj\n  [s]\n  (let [f (for [x s\n                y s]\n            (empty? (clojure.set/intersection x y)))\n        l (count s)]\n    (every? true? (map second (filter #(not= 0 (mod (first %) (inc l))) (map-indexed vector f))))))","problem":153,"user":"5348cab4e4b084c2834f4a5e"},{"problem":153,"code":"#(let [m (map-indexed (fn [x y] [x y]) %)]\n   (every? empty?\n\t(for [ k m l m]\n      (if (= (first k) (first l))\n\t\t#{}\n\t\t(clojure.set/intersection (second k) (second l))        \n      )\n      )\n      )    \n  )","user":"51e1c176e4b06a68e693eafb"},{"code":"(fn [xs]\n  (every? #(empty? (apply clojure.set/intersection %))\n          (loop [xs xs r []]\n            (if (empty? (rest xs)) r\n                (recur (rest xs)\n                       (concat r (map #(list (first xs) %) (rest xs))))))))","problem":153,"user":"4dc1ee85535d020aff1edf91"},{"code":"(fn [s]\n  (reduce #(and %1 %2)\n   (filter #(not (nil? %))\n           (for [x s y s]\n             (if (= x y) nil\n                 (empty? (clojure.set/intersection x y)))))))","problem":153,"user":"500cb910e4b05f7c30cfa698"},{"code":"(fn [xs]\n  (= (apply + (map count (seq xs)))\n     (count (apply clojure.set/union (seq xs)))))","problem":153,"user":"513fab65e4b00f13ea1bd891"},{"problem":153,"code":"(fn pairwise-disjoint? [s]\n  (loop [first-set (first s)\n         more      (rest s)]\n    (if (empty? more)\n      true\n      (if (some #(contains? first-set %) (apply clojure.set/union more))\n        false\n        (recur (first more) (rest more)))\n      )))","user":"5dcbe0dbe4b02b31cc3da3be"},{"code":"#(= (count (apply clojure.set/union %)) \n   (reduce (fn [a b] (+ a (count b))) 0 %))","problem":153,"user":"52b02329e4b0c58976d9acc5"},{"code":"(fn [s]\n  (= (count (apply concat s))\n     (count (apply clojure.set/union s))))","problem":153,"user":"5233ad08e4b07e3ee2be83ac"},{"problem":153,"code":"(fn p-disjoin? [sss]\n\t(every? empty? (for [sa sss sb sss :when (not= sa sb)]\n\t\t\t\t\t   (clojure.set/intersection sa sb)))\n\t)","user":"552bd5c2e4b0ffed3738f969"},{"code":"(fn [s]\n  (empty? (apply concat (for [a s\n        b (filter #(not (= % a)) s)]\n                          (clojure.set/intersection a b)))))","problem":153,"user":"52593207e4b0cb4875a45cd3"},{"code":"#(every? true? (for [a % b % x a y b] (or (= a b) (not= x y))))","problem":153,"user":"4f045946535dcb61093f6bba"},{"code":"(fn [s]\n  (let [everything (apply concat s)] \n    (= (count everything)\n       (count (set everything)))))","problem":153,"user":"4e42f930535dc968683fc49f"},{"problem":153,"code":"(fn [coll] (reduce #(and %1 %2) (for [x coll y coll :when (not= x y) z y] (not (contains? x z)))))","user":"53fe1c3be4b0de5c418485f2"},{"code":"(fn [x] (if (=\r\n(count (reduce #(reduce conj % %2) x))\r\n(reduce #(+ % (count %2)  ) 0 x))\r\n          true \r\n          false\r\n          ))","problem":153,"user":"50646c01e4b007509339a58b"},{"problem":153,"code":"(fn disjoint [set-coll]\n  (let [create-set-combinations-fn\n        (fn create-sets [master-set]\n          (when (seq (rest master-set))\n            (cons master-set (create-sets (rest master-set)))))\n        disjoint?-fn\n        (fn [set-coll]\n          (for [e1 (first set-coll)\n                e2 (flatten (rest set-coll))]\n            (contains? e2 e1)\n            ))]\n    (->> set-coll\n         create-set-combinations-fn\n         (map disjoint?-fn)\n         flatten\n         (every? false?))))","user":"5400e918e4b0de5c41848619"},{"code":"(fn [s]\n  (if\n    (= '() (for [s1 s s2 s :when (and (not= s1 s2) (not= #{} (clojure.set/intersection s1 s2)))] s1))\n    true\n    false ))","problem":153,"user":"50bfe725e4b080409b860f26"},{"problem":153,"code":"(fn [sts]\n  (set?\n   (reduce\n    (fn [mg s]\n      (if mg\n        (if (empty? (clojure.set/intersection mg s))\n          (clojure.set/union mg s)\n          false)\n        false)) #{} sts)))","user":"51b76227e4b0d906fcd71d35"},{"code":"#(apply distinct? (apply concat %))","problem":153,"user":"4db85282535d1e037afb218a"},{"problem":153,"code":"#(=\n    (reduce +          \n      (map count %))\n    (count\n     (reduce clojure.set/union %)))","user":"57487084e4b009280f9f2b8c"},{"problem":153,"code":"#(= (count (apply concat %)) (count (set (apply concat %))))","user":"58e7229fe4b056aecfd47cc4"},{"problem":153,"code":"(fn [ss]\n    (let [elems (for [s ss\n                      elem s]\n                  elem)\n          set_flat (set elems)]\n      (= (count elems)\n         (count set_flat))))","user":"5be5cebde4b0ed4b8aab4d19"},{"problem":153,"code":"(fn [s]\n  (let [ss (seq s)\n        length (count ss)]\n    \n    (every? empty? (for [s1 (range length)\n          s2 (range length)\n          :when (not= s1 s2)]\n      (clojure.set/intersection (nth ss s1) (nth ss s2))))))","user":"5632d1b3e4b0bfe05bf117a9"},{"problem":153,"code":"(fn pairwise-disjoint? [ss]\n  (==\n    (count (reduce #(into %1 %2) #{} ss))\n    (reduce + (map count ss))))","user":"5f300f28e4b033932238a682"},{"problem":153,"code":"#(if (=(count (set(apply concat (for [subset %]\n                               (for [item subset]\n                                 item))))) (apply + (map count %)))\n   true\n   false)","user":"5e9b7aefe4b0157ca96647f1"},{"problem":153,"code":";;(fn [sets]\n;;  (every? true?\n;;          (mapcat (fn [[s1 & ss]]\n;;                    (->> ss \n;;                         (map #(->> %\n;;                                    (clojure.set/intersection s1)\n;;                                    empty?))))\n;;                  (map seq (take (-> sets count dec)\n;;                                 (iterate rest sets))))))\n;;\n(fn [sets]\n  (->> (mapcat (fn [[s1 & ss]] (map (partial vector s1) ss))\n               (map seq (take (-> sets count dec) (iterate rest sets))))\n       (map (fn [[s1 s2]] (empty? (clojure.set/intersection s1 s2))))\n       (every? true?)))","user":"595fd721e4b066ee0a44b06e"},{"problem":153,"code":"(fn [sets]\n  (->> sets\n       (apply concat)\n       frequencies\n       (not-any? (fn [[_ freq]]\n                   (< 1 freq)))))","user":"4eda7cc3535d10e5ff6f530e"},{"problem":153,"code":"(fn [ss]\n  (empty?\n   (for [s ss\n         s' (disj ss s)\n         ion (for [x s :when (contains? s' x)] x)]\n     ion))\n  )","user":"53ef7f77e4b0742d9025b0ce"},{"code":"(fn [s]\n          (reduce #(and % %2) \n                  (flatten\n                   (for [s1 s s2 s :when (not= s1 s2)]\n                     (= 0 (count (clojure.set/intersection s1 s2)))))))","problem":153,"user":"51424cc8e4b0b50abeb46b34"},{"problem":153,"code":"(fn [sets] (= \n            (count (apply concat sets)) \n            (count (set (apply concat sets)))))","user":"562326cbe4b03f08ee9a9230"},{"problem":153,"code":"(fn [sets]\n  (= (reduce (fn [a s] (+ a (count s))) 0 sets) (count (set (reduce concat [] sets)))))","user":"55fee5e4e4b00f4cabc5765a"},{"problem":153,"code":"(fn q4q153 [set-of-sets]\n  (set?\n   (reduce\n    #(if (false? %1)\n       false\n       (if (empty? (clojure.set/intersection %1 %2))\n         (clojure.set/union %1 %2)\n         false))\n    set-of-sets)))","user":"52213426e4b0e6a83c8925c4"},{"problem":153,"code":"(fn [xs]\n  (let [num-elems-separate (apply + (map count xs))\n        num-elems-combined (count (apply clojure.set/union xs))]\n    (= num-elems-combined num-elems-separate)))","user":"5344fe13e4b084c2834f4a32"},{"problem":153,"code":"#(=\n   (count (reduce clojure.set/union %))\n   (reduce + (map count %)))","user":"544e9022e4b0e3978000698b"},{"problem":153,"code":"(fn [n]\n  (->>\n   (apply concat n)\n   (group-by identity)\n   (vals)\n   (map #(> (count %) 1))\n   (apply =)))","user":"57e139f6e4b0bfb2137f5a6c"},{"problem":153,"code":"(fn my-disjoint [s]\n  (->> s\n    (reduce concat)\n    (into #{})\n    count\n    (= (reduce (fn [z h] (+ z (count h))) 0 s))))","user":"5b15811ee4b0cc2b61a3be6f"},{"code":"(fn pwdjs[sos]\n   (let [f (first sos) r (set (rest sos))]\n     (if (empty? sos) true\n         (if (empty? (filter #(not (empty? (clojure.set/intersection f %))) r))\n           (pwdjs r) false))))","problem":153,"user":"4fb86dc9e4b081705acca2d8"},{"problem":153,"code":"#(->> (for [s1 % s2 % :when (not= s1 s2)]\n          (clojure.set/intersection s1 s2))\n      (every? empty?))","user":"4ed45563535d10e5ff6f52c9"},{"code":"(fn [sos]\n(reduce #(and %1 %2)\n  (letfn [\n    (intersection [s1 s2]\n      (filter #(contains? s2 %) s1))\n      ]\n  (for [s1 sos, s2 sos\n        :when (distinct? s1 s2)]\n    (if (empty? (intersection s1 s2))\n        true\n        false\n    )\n  )\n)))","problem":153,"user":"4fcf5292e4b03432b189f40e"},{"problem":153,"code":"(fn [s]\n  (= (count (apply concat s)) (count (apply clojure.set/union s))))","user":"5ccf99fbe4b0ccb0619628c8"},{"code":"(fn [ss]\n  (= (reduce + (map count ss)) (count (apply clojure.set/union ss))))","problem":153,"user":"5003deb9e4b0678c553fc445"},{"problem":153,"code":"#(every? empty? (for [s1 % s2 (disj % s1)] (clojure.set/intersection s1 s2)))","user":"564b495de4b0284900eef667"},{"problem":153,"code":"(fn Pairwise-Disjoint-Sets\n  [lst]\n  (apply distinct? (mapcat seq lst)))","user":"59e14ee3e4b08badc2a0c50c"},{"code":"(fn [s] (apply distinct? (apply concat s)))","problem":153,"user":"4f9f7daae4b0dcca54ed6d37"},{"problem":153,"code":"(fn g [ in]\n  (letfn\n    [(f [ acc li]\n       (if \n         (empty? li) \n         true\n         (if \n           (empty? (clojure.set/intersection acc (first li)))\n           (recur (clojure.set/union acc (first li)) (rest li))\n           false)))]\n    (f #{} (seq in))))","user":"4e6a5728535d8ccf87e9fecf"},{"problem":153,"code":"(fn [coll]\n  (empty? (for [x coll, y coll\n                :let [a (clojure.set/intersection x y)]\n                :while (not= x y)\n                :when (not-empty a)]\n            a)))","user":"5a5dbe9de4b0512ff01cd92b"},{"problem":153,"code":"(fn [s]\n    (let [a (apply concat s)]\n      (= (count a) (count (distinct a)))))","user":"5a9d64c8e4b0d174b936c7eb"},{"code":"#(not-any? true? \n             (for [x % y % z y :when (not= x y)]\n               (contains? x z)))","problem":153,"user":"4ec74de3535d6d7199dd36df"},{"problem":153,"code":"(fn t \n  ([s] (t (first s) (rest s)))\n  ([i s]\n    (letfn [(novlp [a b] (empty? (for [i a j b :when (= i j)] 1)))]\n      (cond (empty? s) true \n            (every? true? (for [j s] (novlp i j))) (t (first s) (rest s))\n            :else false))))","user":"5e2549c8e4b05b4b0151615f"},{"problem":153,"code":"(fn [coll]\n  (let [xs (for [x coll \n                 y x] \n             y)]\n    (= (count xs) (count (set xs)))))","user":"5574c172e4b05c286339e059"},{"code":"#(= (reduce + (map count (flatten (partition 1 %))))\n(count (apply clojure.set/union (flatten (partition 1 %)))))","problem":153,"user":"4eb44d78535d7eef30807360"},{"code":"(fn [ss]\r\n  (let [v (vec ss)\r\n        n (count v)]\r\n    (empty?\r\n      (for [i (range n)\r\n            j (range i)\r\n            :when (not= 0 (count (clojure.set/intersection (v i) (v j))))]\r\n        nil))))","problem":153,"user":"50479524e4b0371827a27bc4"},{"code":"(fn [set]\n  (letfn [(union [s1 s2] \n    (let [first2 (first s2), rest2 (rest s2)]\n      (if (empty? rest2) \n        (conj s1 first2)\n        (conj (union s1 rest2) first2)))\n    )]  \n    (= (reduce #(+ % (count %2)) 0 set)\n      (count (reduce #(union % %2) #{} set)))))","problem":153,"user":"4ff83003e4b0678c553fc396"},{"code":"(fn [ colls]\n   (empty? (for [i colls j colls :when (and (not (identical? i j))    \n                                           (not (empty? (clojure.set/intersection i j))))]\n                true)))","problem":153,"user":"4f38d6bbe4b0e243712b1ee2"},{"problem":153,"code":"(fn\n  [s]\n  (empty? (apply concat\n           (for [x s\n                 y s]\n             (when (not= x y) (clojure.set/intersection x y))))))","user":"59f44189e4b0966464fe6aab"},{"code":"#(% distinct? (% concat %2)) apply","problem":153,"user":"53973e7be4b0b51d73faaee6"},{"problem":153,"code":"(fn [s]\n  (loop [t s\n         us #{}]\n    (if (empty? t)\n      true\n      (if (empty? (clojure.set/intersection us (first t)))\n        (recur (rest t) (clojure.set/union us (first t)))\n        false))))","user":"56d5fd24e4b0ea9b8538f7c5"},{"code":"#(every? empty? (for [this %\r\n                       other %\r\n                       :when (not= this other)]\r\n                   (clojure.set/intersection this other)))","problem":153,"user":"4fabbb97e4b081705acca21d"},{"code":"#(let [s (apply concat %)] (= (count s) (count (set s))))","problem":153,"user":"4f08b15b535dcb61093f6c40"},{"code":"#(let [freqs (vals (frequencies (mapcat vec %)))]\r\n     (= (count freqs) (apply + freqs)))","problem":153,"user":"4dcfbc44535d5973398f92a7"},{"code":"(fn pairwise-disjoint? [sets]\n  (every? identity\n          (for [[set1 & other-sets] (take-while not-empty (iterate next (seq sets)))\n                set2                other-sets]\n            (= #{} (clojure.set/intersection set1 set2)))))","problem":153,"user":"4e8338d6535db62dc21a62d3"},{"problem":153,"code":"(fn disjoint? [s]\n    (let [ss (seq s)\n          length (count ss)]\n      (every? empty? (for [s1 (range length)\n                           s2 (range length)\n                           :when (not= s1 s2)\n                           ]\n                       (clojure.set/intersection (nth ss s1) (nth ss s2))))))","user":"550c55d0e4b06e50f9beb14d"},{"problem":153,"code":"(fn [s]\n  (loop [[f & r] (vec s)]\n    (cond\n     (empty? r) true\n     (every? empty? (for [rr r] (clojure.set/intersection f rr))) (recur r)\n     :else false)))","user":"586615e6e4b0f14aab7c8858"},{"problem":153,"code":"#(let [x (apply concat %)] (= (count x) (count (into #{} x))))","user":"5b6473eee4b0c6492753e73f"},{"problem":153,"code":"#(apply = ((juxt count (comp count distinct)) (mapcat seq %)))","user":"5e3071abe4b05b4b01516213"},{"problem":153,"code":"(fn [coll]\n  (loop [acc #{}\n         coll coll]\n    (cond\n      (empty? coll) true\n      (seq (clojure.set/intersection acc (first coll))) false\n      :else (recur (clojure.set/union acc (first coll)) (rest coll)))))","user":"51ca5378e4b08b1cbd0d9480"},{"problem":153,"code":"(fn pairwise-disjoint-sets?\n  [sets]\n  (= (apply + (map count sets))\n     (count (apply clojure.set/union sets))))","user":"6098263be4b00e9e6653c3f9"},{"problem":153,"code":"(fn [s] (apply distinct? (reduce #(into %1 %2) () s)))","user":"5de12192e4b0948ae9d9aded"},{"problem":153,"code":"(fn f [sets]\n  (= (reduce #(+ %1 (count %2)) 0 sets)\n     (count (set (reduce concat sets)))))","user":"56444fb1e4b0018b46ad8c0c"},{"code":"#(= (count (apply concat %)) (count (reduce into #{} %)))","problem":153,"user":"4dbb0b6c535d1e037afb21b0"},{"problem":153,"code":"(fn [coll]\n  (let [all-elem (reduce #(into %1 %2)\n                         []\n                         coll)]\n    (empty? (filter (fn [[k v]] (> v 1))\n                    (frequencies all-elem)))))","user":"52d38c51e4b099d49816f0c5"},{"problem":153,"code":"(fn pairwise-disj\n  [a_set]\n  (->> (for [x a_set \n             y a_set \n             :when (not= x y)]\n         (clojure.set/intersection x y)) \n       (every? empty?)))","user":"56a44067e4b0542e1f8d14da"},{"code":"#(let [a (reduce + (map count %))\n       b (count (apply clojure.set/union %))]\n   (= a b)\n   )","problem":153,"user":"50cae881e4b0f75dcc9a6e51"},{"code":"(fn [seq]\n  (loop [h (first seq)  r (rest seq) ]\n    (if (loop [ rr r ]                                                                                                                                                                        \n          (if (= #{} (clojure.set/intersection h (first rr) ))                                                                                                                                \n            (if (> (count rr) 1)                                                                                                                                                              \n              (recur (rest rr))                                                                                                                                                               \n              false) true))                                                                                                                                                                   \n      false\n      (if (second r) (recur (first r) (rest r)) true))\n    ))","problem":153,"user":"4fbd292fe4b081705acca300"},{"code":"(fn foo [ss]\n   (if\n       (empty? (next ss)) true\n       (if (seq (filter #((comp (complement empty?) clojure.set/intersection) (first ss) %) (next ss)))\n         false\n         (foo (next ss)))))","problem":153,"user":"50aedb8ce4b0a40c9cfb08d4"},{"problem":153,"code":"#(let [x (reduce (fn [a b] (let [newset (into (a :set) b) c1 (count (a :set)) c2 (count b) c3 (count newset)]\n     {:set newset :ok (and (a :ok) (= c3 (+ c1 c2))) })) {:set #{} :ok true} %) ]\n                 (x :ok) )","user":"5b919d9de4b0c0b3ffbd4a24"},{"problem":153,"code":"(fn [s]\n  (let [count-elements (fn [s]\n                        (reduce #(+ %1 (count %2)) 0 s))\n        merge-all-elems (fn [s]\n                         (reduce into #{} s))]\n       (= (count-elements s) (count (merge-all-elems s)))))","user":"5984e7dee4b021a7a535fe43"},{"code":"(fn [sets] (=\n               (count (reduce #(into %1 %2) #{} sets))\n               (reduce (fn [x y] (+ x (count y))) 0 sets) ))","problem":153,"user":"51e28063e4b08e53a149f0f2"},{"code":"(fn [x]\n  (let [k (frequencies (reduce into [] (map #(seq %1) x)))]\n    (if (some #(> (%1 1) 1) k)\n      false\n      true)))","problem":153,"user":"50a5f72fe4b0aa96157e2611"},{"code":"#(empty? (for [a %, b %\n              :when (and (not= a b)\n                         ((complement empty?)\n                          (clojure.set/intersection a b)))]\n           \ta))","problem":153,"user":"52d340ebe4b099d49816f0c1"},{"code":"(fn pw-dj [s]\n  (loop [head (first s)\n         tail (rest s)\n         result false]\n\t\t(if (or (nil? head) result)\n\t\t\t(not result)\n\t\t\t(recur\n\t\t\t\t(first tail)\n\t\t\t\t(rest tail)\n\t\t\t\t(some false?\n\t\t\t\t\t(map #(empty? (clojure.set/intersection head %1)) tail))))))","problem":153,"user":"4eddcbbf535d10e5ff6f532d"},{"problem":153,"code":"(fn [allsets]\n  (let [argsets (into () allsets)]\n  (loop [mem-set (first argsets) sets (rest argsets)]\n    (if (empty? sets)\n      true\n      (let [currset (first sets)]\n        (if (some true? (map #(contains? mem-set %) currset))\n          false\n          (recur (clojure.set/union mem-set currset) (rest sets))))))))","user":"538e864ee4b0b51d73faae87"},{"problem":153,"code":"(fn \n  [sets]\n  (=\n   (reduce + (map count sets))\n   \t(count (reduce clojure.set/union sets))))","user":"58445c3ce4b089d5ab817e49"},{"problem":153,"code":"(fn [set-of-sets]\n    (every? (fn [a-set]\n              (let [others (disj set-of-sets a-set)]\n                (not (reduce (fn [b v]\n                               (or b (some (fn [o-set]\n                                             (some #(= % v) o-set)) others))) false a-set)))) set-of-sets))","user":"5d236215e4b02ea6f0fb6a09"},{"code":"#(every? empty?\n  (for [a % b % :when (not= a b)]\n    (clojure.set/intersection a b)))","problem":153,"user":"4e68b46c535d8ccf87e9fe87"},{"code":"(fn disjoint? [set-of-sets]\n  (if \n    (= 1 (count set-of-sets))\n    true\n    (let [\n          set1 (first set-of-sets)\n          more-sets (rest set-of-sets)\n          ]\n      (if\n        (every? true? (for [\n                        set2 more-sets\n                        ] (and\n                            (nil? (some set1 set2))\n                            (not (and (some nil? set1) (some nil? set2))))))\n        (disjoint? more-sets)\n        false))))","problem":153,"user":"4f05a9cf535dcb61093f6bfc"},{"problem":153,"code":"(fn [n]\n  (= (reduce + (map count n))\n     (count (reduce clojure.set/union n))))","user":"5a9cdec0e4b0d174b936c7e1"},{"problem":153,"code":"; (fn f [coll]\n;  (if (empty? coll)\n;    true\n;    (and (->> (rest coll)\n;              (map #(clojure.set/intersection (first coll) %))\n;              (every? empty?))\n;         (f (rest coll)))))\n\n#(= (reduce + (map count %)) (count (reduce into %)))","user":"5aa4f7dae4b0d174b936c88c"},{"problem":153,"code":"#(loop [xs %]\n   (if (empty? xs)\n     true\n     (let [disjoint (every? empty?\n                            (map (partial intersection (first xs))\n                               (rest xs)))]\n       (if disjoint (recur (rest xs)) false))))","user":"58c2df0ae4b021aa9917ed17"},{"problem":153,"code":"(fn solution [candidate]\n  (let [sets (for [a candidate b candidate\n                   :when (distinct? a b)]\n               (clojure.set/intersection a b))]\n    (every? empty? sets)))","user":"5e2ef900e4b05b4b015161fc"},{"problem":153,"code":"(fn pairwise-disjoint\n  [s]\n  (= (count (set (reduce concat s)))\n     (reduce + (map count s))))","user":"5f3103aee4b0574c87022c24"},{"code":"#(= (count (reduce clojure.set/union %))\n    (apply + (map count %)))","problem":153,"user":"4f58fe71e4b0a7574ea7185f"},{"code":"(fn [s]\n  (=\n    (count (set (apply concat s)))\n    (reduce + (map count s))\n  )\n)","problem":153,"user":"507eddf4e4b06ce648bcdbfa"},{"problem":153,"code":"(fn [s]  ; s is a set of sets\n  (apply distinct? (apply concat s))\n)","user":"51f09f3de4b0274c496158d7"},{"problem":153,"code":"(fn\n  [sets]\n  (loop [sets  sets\n         union #{}]\n    (let [s (first sets)]\n      (println \"> s: \" s)\n      (if s\n        (if (empty? (clojure.set/intersection s union))\n          (recur (rest sets) (clojure.set/union union s))\n          false)\n        true))))","user":"570c8ac3e4b0b0fb43fd06ca"},{"problem":153,"code":"#(not= :a (first (for [a % b % :when (and (not= a b) (seq (clojure.set/intersection a b)))] :a)))","user":"4e11b92a535d04ed9115e7cb"},{"code":"#(= (apply + (map count %))\n    (count (set (reduce into #{} %))))","problem":153,"user":"4dd6d7ee535d2dad7130b5cb"},{"code":"#(every? true? (map (fn [[f & r]] (every? true? (map (fn [n] (empty? (clojure.set/intersection n f))) r))) (take-while (complement empty?) (iterate rest (vec %)))))","problem":153,"user":"5061cc17e4b0a30dc9a35d34"},{"problem":153,"code":"(fn [sets] (= (count (reduce into sets)) (reduce #(+ % (count %2)) 0 sets)))","user":"53307a23e4b019098a6f8b5d"},{"problem":153,"code":"(fn [x]\n    (if (< (count (set (apply concat (clojure.set/union x))))\n           (reduce + (map count x))) false true))","user":"5ac4d1f6e4b0e27600da7735"},{"problem":153,"code":"(fn pairwise [sos] (true? (= (reduce + (map count sos)) (count (reduce clojure.set/union sos)))))","user":"56ffeafee4b08d47c97781c2"},{"problem":153,"code":"(fn [sets] \n   ( =  \n     (count (apply clojure.set/union sets))\n     (count (apply concat sets))))","user":"567476bde4b05957ce8c6139"},{"problem":153,"code":"(fn f [s]\n   (let [a (first s)\n         r (rest s)]\n     (cond\n       (nil? a) true\n       (not-every? empty? (map (partial clojure.set/intersection a) r)) false\n       :else (f r))))","user":"545ddac3e4b01be26fd74676"},{"code":"(fn f\n  ([a b]\n     (if (empty? a)\n       true\n       (if (not-any? #(contains? b %) (first a))\n         (recur (rest a) (into #{} (concat b (first a))))\n         false))\n  )\n  ([a] (f a #{}))\n )","problem":153,"user":"5302ac7fe4b0d8b024fd3731"},{"problem":153,"code":"(fn [s]\n  (->> (for [s' s\n             r s']\n         r)\n       (apply distinct?)))","user":"57aa4775e4b0b8559636fc6b"},{"problem":153,"code":"(fn [ss]\n  (= (reduce + (map count ss))\n     (count (apply clojure.set/union ss))))","user":"523ea111e4b057c4b7cd0a65"},{"problem":153,"code":"(fn disjoint\n  [sets]\n  (= (count (apply clojure.set/union sets))\n     (apply + (map count sets))))","user":"563f1493e4b08d4f616f5ecf"},{"problem":153,"code":"(fn [ss]\n  (every? true?\n    (map empty?\n         (for [s1 ss\n               s2 ss\n               :when (not= s1 s2)]\n           (clojure.set/intersection s1 s2)\n           ))))","user":"557232a1e4b09a3098a52543"},{"code":"#(apply distinct? (mapcat (partial into []) %))","problem":153,"user":"52b577c9e4b0c58976d9ad39"},{"problem":153,"code":"#(= (count (set (apply concat %)))\n    (apply + (map count %)))","user":"541709b0e4b01498b1a71a06"},{"problem":153,"code":"#_(fn pairwise-disjoined [set]\n  (let [all-in (apply concat set)\n        as-set (into #{} all-in)]\n    (= (count all-in) (count as-set))))\n\n(fn pairwise-disjoined [set]\n  (let [all-in (mapcat identity set)]\n   (apply distinct? all-in)))\n\n#_(fn pairwise-disjoint-1 [s]\n  (distinct? (apply clojure.set/intersection (mapcat identity s))))\n\n#_(fn pairwise-disjoint [s]\n  (empty? (apply clojure.set/intersection s)))","user":"561d8936e4b064ca9f4b16b2"},{"code":"(fn [ss]\n  (letfn [(subtract [s1 s2]\n            (set (filter #(not (contains? s2 %)) s1)))\n          (has-common? [s1 s2]\n            (some #(contains? s1 %) s2))]\n    (empty? (for [s1 ss s2 (subtract ss #{s1}) :when (has-common? s1 s2)] [s1 s2]))))","problem":153,"user":"504e13fce4b078edc5f593bc"},{"problem":153,"code":"(comp (partial apply distinct?)\n      (partial apply concat))","user":"532902f8e4b09d4e7a9b550e"},{"problem":153,"code":"(fn [s]\n  (let [hascommon (fn [a b]\n                 (some true? (for [s1 a s2 b] (= s1 s2)))\n                 )]\n    (loop [sets s result true]\n      (cond\n        (false? result) false\n        (= (count sets) 1) true\n        (hascommon (first sets) (second sets)) false\n        :else (recur\n          (cons\n            (set (concat (first sets) (second sets)))\n            (drop 2 sets)\n            )\n          result\n          )\n\n        )\n\n\n      )\n  )\n  )","user":"5f58db95e4b0a0bc16850a9a"},{"problem":153,"code":"(fn [ss]                                                                                                                               \n    (->> ss                                                                                                                            \n      (map #(map (fn [s'] [% s']) (clojure.set/difference ss #{%})))                                                              \n      (reduce into [])                                                                                                                 \n      (map #(empty? (apply clojure.set/intersection %)))                                                                       \n      (every? true?)))","user":"55316b8ae4b076ab5578f825"},{"problem":153,"code":"(fn r[x] (if (= (count x) 0)\n            true\n            (let [[a & b] (into [] x)] (if\n                                         (every? empty? (map (partial clojure.set/intersection a) b))\n                                         (and true (r b))\n                                         false))))","user":"54344721e4b0b6b47310fcea"},{"code":"#(every? empty? (for [x % y % :when (not= x y)] (clojure.set/intersection x y)))","problem":153,"user":"4eb97b2e535dfed6da9c6d54"},{"problem":153,"code":"(fn [x] (= (reduce +(map count x)) (count(reduce #(apply conj %1 %2) x))))","user":"571aad45e4b07c98581c3b59"},{"code":"(fn [s]\n  (empty?\n    (filter #(> (% 1) 1)\n      (frequencies (mapcat identity s)))))","problem":153,"user":"4f050dec535dcb61093f6bef"},{"problem":153,"code":"(fn [sets]\n  (let [count-all-elements (reduce #(+ %1 (count %2)) 0 sets)\n        count-of-merged-sets (count(reduce clojure.set/union #{} sets))]\n    (= count-all-elements count-of-merged-sets)))","user":"5d231255e4b02ea6f0fb69fe"},{"problem":153,"code":"(fn [s]\n  (loop [setseq (seq s) out true]\n    (if (empty? setseq) out \n      (recur (rest setseq) (and (#(every? empty? (map clojure.set/intersection (repeat (first %)) (rest %))) setseq) out))\n               )))","user":"53e76bb2e4b036ad0777e47d"},{"code":"(fn [s] (= (count s) (count (filter false? (for [s1 s, s2 s] (nil? (some s1 s2)))))))","problem":153,"user":"4fc0853ae4b081705acca327"},{"code":"(fn [coll ]\n\t  (= (count (mapcat reverse coll))\n\t     (count (set (mapcat reverse coll)))))","problem":153,"user":"5016ac54e4b052339a490e7b"},{"problem":153,"code":"(fn [xs]\n (let [rs (mapcat #(into [] %) (into [] xs))]\n   (= (count (distinct rs)) (count rs))))","user":"54ab502fe4b09f271ff37cc4"},{"problem":153,"code":"#(->> %\n      (apply concat)\n      (group-by identity)\n      (vals)\n      (some (fn [v] (> (count v) 1)))\n      (not))","user":"5f37263de4b0574c87022c4e"},{"problem":153,"code":"(fn [s] (let [set2vec (fn [xs] (vec xs))]\n             (if (some #(> % 1) (map #(count (second %)) (group-by identity (reduce concat (map set2vec s)))))\n                   false true )))","user":"59ff9424e4b01bb0ae8afd24"},{"problem":153,"code":"(fn [s] (let [all-elems (mapcat identity s)]\n          (= (count all-elems)\n             (count (set all-elems)))))","user":"5d6c2aace4b04d129b00f2ad"},{"problem":153,"code":"(fn [s]\n  (let [ok (fn [a b]\n             (->> b\n                  (filter #(contains? a %))\n                  (empty?)\n                  (not)))]\n    (-> (for [a s\n              b s\n              :when (not (identical? a b))]\n          (ok a b))\n        (doall)\n        (set)\n        (contains? true)\n        (not))))","user":"5cf6522be4b0b71b1d808a58"},{"problem":153,"code":"#(apply distinct? (for [s % e s] e))","user":"4f0ef874535d0136e6c22328"},{"code":"(fn [x] (not (contains? (reduce #(if (and (not (contains? %1 :difference)) (empty? (clojure.set/intersection %1 %2)))\n                 (clojure.set/union %1 %2)\n                 #{:difference true}) x) :difference)))","problem":153,"user":"5301157ae4b0d8b024fd3717"},{"problem":153,"code":"(fn [sets] \n  (every? empty? (for [set1 sets set2 sets :when (not= set1 set2)] \n                    (clojure.set/intersection set1 set2))))","user":"54a9bc4ae4b09f271ff37cb0"},{"problem":153,"code":"(fn\n   [set]\n   (= (reduce + (map count set)) \n     (count (reduce clojure.set/union #{} set))))","user":"60396c95e4b0d5df2af222f4"},{"problem":153,"code":"(fn [setofsets]\n  (let [allelements (reduce clojure.set/union setofsets)\n        cnts (for [x allelements]\n               (filter (fn [y] (some #(= % x) y)) setofsets))]\n    (every? #(= 1 (count %)) cnts)))","user":"5705e404e4b0b0fb43fd0676"},{"code":"(fn [s] (=\n  (count (into #{} (apply concat s)))\n  (reduce #(+ % (count %2)) 0 s)))","problem":153,"user":"4ec07699535dfed6da9c6da2"},{"code":"(fn ds [s]\n  (let [v (vec s)]\n    (=\n     (count (apply clojure.set/union v))\n     (reduce #(+ %1 (count %2)) 0 v))))","problem":153,"user":"515896f2e4b059418b97f0a8"},{"code":"(fn pwd [s] \n  (= (count (set (apply concat s))) (apply + (map count s))))","problem":153,"user":"51aab611e4b04e3dc0c27b2d"},{"problem":153,"code":"(fn dj [s]\n  (= (reduce + ( map count s)) \n     (count (reduce clojure.set/union s))))","user":"54b95f3de4b0ed20f4ff6eab"},{"problem":153,"code":"(fn [sets]\n  (every?\n   (fn [inner-set]\n     (every?\n      (fn [set-member]\n        (every? #(not (contains? % set-member)) (remove #(= inner-set %) sets)))\n      inner-set))\n   sets))","user":"5f79bff2e4b02876ed9fd0ca"},{"problem":153,"code":"(fn disjoint? \n    [xs]\n    (letfn [(d1? [e ys]\n              (cond (empty? ys) false\n                    (not-empty (clojure.set/intersection e (first ys))) true\n                    :else (d1? e (rest ys))))]\n      (cond (empty? xs) true\n            (d1? (first xs) (rest xs)) false\n            :else (disjoint? (rest xs)))))","user":"6026d2cae4b0d5df2af22232"},{"code":"(fn [s] (apply (every-pred empty?) (for [x s y (disj s x)] (clojure.set/intersection x y))))","problem":153,"user":"5201ada5e4b0b2e020a18f14"},{"code":"#(= (apply + (map count %))\n    (count (reduce into %)))","problem":153,"user":"4e12cc9d535d04ed9115e7d2"},{"problem":153,"code":"(fn pds [S]\n  (loop [s S]\n    (cond\n     (empty? s) true\n     (some #(not-empty (clojure.set/intersection (first s) %)) (rest s)) false\n     :else (recur (rest s))\n            )))","user":"53e745a1e4b036ad0777e479"},{"code":"#(let [a (mapcat identity %)]\n  (= (distinct a) a))","problem":153,"user":"4fa30027e4b081705acca187"},{"problem":153,"code":"(fn [sq] (empty? (filter (fn [x](let [[a b] x] (and (not= a b) (not-empty (clojure.set/intersection a b)))))(for [i sq j sq] [i j]))))","user":"51f38193e4b0fca5e8b48226"},{"code":"(fn [set-of-sets]\n  (loop [ss set-of-sets\n         u #{}]\n    (if-let [ss (seq ss)]\n      (if (= #{} (clojure.set/intersection u (first ss)))\n        (recur (next ss) (clojure.set/union u (first ss)))\n        false)\n      true)))","problem":153,"user":"500d8c49e4b07ccb9a7ddb00"},{"code":"(fn [sets] (if (= (count (apply clojure.set/union sets)) (apply + (map count sets)))\n    true\n    false))","problem":153,"user":"4ee75ec2535d93acb0a66867"},{"problem":153,"code":"#(->> (for [s1 %\n            s2 (disj % s1)]\n        (clojure.set/intersection s1 s2))\n      (every? empty?))","user":"583e27e2e4b089d5ab817daa"},{"problem":153,"code":"(fn foo\n  [set1]\n  (if\n    (=\n      (count (apply concat set1))\n      (count(set(apply concat set1))))\n    true\n    false)\n  )","user":"598d0dc3e4b02b9968b84d18"},{"code":"(fn [s]\n    (let [v (reduce #(into % %2) [] s)\n          a (count v)\n          b (count (distinct v))]\n      (= a b)))","problem":153,"user":"506755b3e4b03d366d7cb2bc"},{"code":"(fn [s] (not-any? #(> % 1) (vals (frequencies (apply concat s)))))","problem":153,"user":"4e50b67b535dc968683fc4ed"},{"problem":153,"code":"(fn [s]\n  (= (reduce +\n             (map count s))\n     (count (apply clojure.set/union s))))","user":"57008afae4b08d47c97781ca"},{"code":"(fn [xs]\r\n  (let [xs (seq xs)]\r\n    (every? empty?\r\n      (for [[i x] (map list (range) xs)\r\n            y (take i xs)] \r\n        (clojure.set/intersection x y)))))","problem":153,"user":"509c03f3e4b085ae113522a8"},{"code":"(fn [sets]\n  (every? empty? (for [a sets b sets\n                :let [y (clojure.set/intersection a b)]\n                :when (not (= a b))]\n            y)))","problem":153,"user":"50052fd0e4b0678c553fc45d"},{"code":"(fn [x] (every? #(empty? (clojure.set/intersection (first %) (second %))) (for [a x b x :when (not (identical? a b))] [a b])) )","problem":153,"user":"4feada56e4b0140c20fb9c11"},{"problem":153,"code":"(fn [s]\n  (= (count (apply concat '() s))\n   (count\n    (apply clojure.set/union s))))","user":"5f7e91c8e4b0c071e6c840d8"},{"problem":153,"code":"(fn [S]\n \t(every? empty? (for [x S y S :when (not= x y)]\n      (clojure.set/intersection x y)))\n )","user":"5649615be4b0284900eef641"},{"problem":153,"code":"(let [union         clojure.set/union,\n      intersection  clojure.set/intersection]\n    (fn pairwise-disjoint? [sets]\n      (loop [acc #{}, [x & more :as sets] (seq sets)]\n        (cond\n          (empty? sets)               true\n          (seq (intersection acc x))  false\n          :else                       (recur (union acc x) (rest sets))))))","user":"4fc6305de4b0ee37620e180b"},{"code":"#(not-any? (fn [[_ [_ & r]]] r) (group-by identity (apply concat %)))","problem":153,"user":"507056b8e4b07bd6ad9b9f29"},{"problem":153,"code":"(fn f\n  [xs]\n  (if (<= (count xs) 1)\n    true\n    (let [x (first xs)\n          y (second xs)\n          union (into x y)]\n      (if (= (count union) (+ (count x) (count y)))\n        (f (rest xs))\n        false))))","user":"5da7176ae4b000c986472c13"},{"problem":153,"code":"(fn [sets]\n   (= (reduce + (map count sets))\n      (count (apply clojure.set/union sets))))","user":"5b337ff4e4b025bcb146f339"},{"code":"(fn pair-disjoint [input]\n  (let [uniondata\n        (reduce (fn [his cur] {:data (into (:data his) (:data cur)) :size (+ (:size his) (:size cur))}) {:data #{} :size 0}\n                (map #(hash-map :data % :size (count %)) input))]\n    (= (:size uniondata) (count (:data uniondata)))))","problem":153,"user":"4dae4da5c9a9d6ed4e99dc57"},{"problem":153,"code":"#(= (count (reduce (fn [acc x] (clojure.set/union x acc)) %))\n    (reduce (fn [acc x] (+ (count x) acc)) 0 %))","user":"592bb806e4b072a2710fcf46"},{"problem":153,"code":"(fn\n  [s]\n  (let [uset-count (count (apply clojure.set/union s))\n        s-count (reduce (fn [acc x] (+ acc (count x))) 0 s)]\n    (= uset-count s-count)))","user":"5be1c6c6e4b0ed4b8aab4ca5"},{"code":"#(every? empty? (for [a % b % :while (not= a b)] (clojure.set/intersection a b)))","problem":153,"user":"4ed94d69535d10e5ff6f5303"},{"problem":153,"code":"(fn [ms]\n  (let [ss (reduce concat (map vec (vec ms)))]\n    (= (distinct ss) ss)))","user":"552d2e4fe4b076ab5578f7e1"},{"problem":153,"code":"(fn[s]\n  (let[c (count (reduce into #{} s))]\n    (= c (reduce + (map count s)))))","user":"57b3efb1e4b0fbc9809a278a"},{"problem":153,"code":"(fn [coll]\n   (loop [un #{(first coll)}, l (rest coll)]\n     (if (empty? (clojure.set/intersection un (first l)))\n       (if (not (empty? l))\n         (recur (clojure.set/union un (first l)) (rest l))\n         true)\n       false\n       )\n     ))","user":"590b3aeae4b047aa04b199d0"},{"problem":153,"code":"(fn [sets]\n  (every? empty?\n          (for [s sets\n                o (disj sets s)]\n            (clojure.set/intersection o s))))","user":"541d3c0fe4b01498b1a71a7e"},{"problem":153,"code":"#(let [x (into #{} (reduce concat %)) y (map count %)] (= (count x) (reduce + y)))","user":"5f8fe45ae4b0715f5002d78d"},{"problem":153,"code":"(fn pairwise-disjoint [xs]\n  (=\n   (reduce + (map count xs))\n   (count (reduce clojure.set/union xs))))","user":"53d63e6ce4b0e771c3025454"},{"code":"(fn pairwise-disjoint-sets [mset]\n  \n  (apply = true \n          (map\n           \n           #(not (> % 1))\n\n           (vals (reduce \n                  \n                  (fn [a x] \n                    (reduce #(assoc % %2 (if (nil? (% %2)) 1 (inc (% %2))) )  a x) )\n\n                  {}\n                  mset)))))","problem":153,"user":"515bbcd9e4b0388ca8ca1521"},{"code":"(fn [S]\n  (every? empty? (for [x S y S] (if (not= x y) (clojure.set/intersection x y) #{}))))","problem":153,"user":"4e49a7bb535dc968683fc4c6"},{"code":"(fn [s]\n  (letfn [(mut [s1 s2]\n            (not-any? #(.contains s2 %) s1))]\n    (every? true? (for [i s j s :when (not= i j)] (mut i j))\n    )\n  )\n)","problem":153,"user":"4fcad14ce4b0ee37620e1856"},{"problem":153,"code":"(fn [s-o-s]\n                             (every? true? (for [s1 s-o-s s2 s-o-s :when (not= s1 s2)]\n                                             (nil? (seq (clojure.set/intersection s1 s2)))))\n                             )","user":"54cad2d5e4b057c6fda3a26c"},{"problem":153,"code":"(fn pair\n  [s]\n  (apply distinct? (mapcat seq s))\n  )","user":"5bbbcf9ee4b0a20761a23614"},{"code":"(fn [s] \r\n    (let [a (apply list s)\r\n          c (reduce #(+ % (count %2)) 0 a)\r\n          n (set (apply concat a))]\r\n      (= c (count n))\r\n      )\r\n    )","problem":153,"user":"4f410b63e4b0e243712b1fc5"},{"code":"(fn r [x] \n      (if (= 1 (count x)) \n        true \n        (and (reduce #(and % %2) (concat (for [y (rest x)] (if (empty? (clojure.set/intersection (first x) y)) true false )))) \n             (r (rest x)))\n      )\n    )","problem":153,"user":"50ef3e5de4b0a78662fa2652"},{"problem":153,"code":"(fn [lst]\n  (= (reduce + (map count lst))\n     (count (reduce clojure.set/union lst))))","user":"5a99c5a9e4b0d174b936c7b1"},{"problem":153,"code":"#(= (reduce + (map count %)) (count (set (mapcat seq %))))","user":"5f2c02d1e4b033932238a65f"},{"code":"(fn [s]\n  (=\n    (count  (apply clojure.set/union s))\n    (reduce + (map count s))))","problem":153,"user":"50bce014e4b0594b91591c63"},{"problem":153,"code":"(fn [s] (= (count (reduce clojure.set/union s)) (reduce + (map count s))))","user":"54684c3be4b00cfc9eacc139"},{"code":"(fn pairwise-disjoint? [sets]\n  (or (= (count sets) 1)\n      (let [s1 (first sets)\n            s2 (second sets)]\n        (and (empty? (clojure.set/intersection s1 s2))\n             (pairwise-disjoint? (conj (rest (rest sets))\n                                   (clojure.set/union s1 s2)))))))","problem":153,"user":"50812debe4b01a93d3f38e4c"},{"problem":153,"code":"(fn unique-sets? [sets]\n  (loop [union-set (first sets)\n         sets      (rest sets)]\n    (println union-set)\n    (if-not (seq sets)\n      true\n      (let [s (first sets)]\n        (if (some true? (map #(contains? union-set %) s))\n          false\n          (recur (set (concat union-set s))\n                 (rest sets)))))))","user":"58637f03e4b0f14aab7c881e"},{"problem":153,"code":"(fn [sets]\n  (every? true? \n          (map #(empty? (clojure.set/intersection %1 %2)) \n               sets \n               (next sets))))","user":"5712854ce4b07c98581c3a89"},{"problem":153,"code":"(fn [ss]\n  (last\n    (reduce\n     (fn [[seen res] s]\n       (let [union (set (concat seen s))]\n         [union (and res (= (count union) (+ (count seen) (count s))))]))\n     [#{} true]\n     ss)))","user":"5db92996e4b010eb3c36cd50"},{"problem":153,"code":"(fn [v]\n    (reduce\n     (fn [k v] (and k (empty? v)))\n     true\n     (flatten (map (fn [currel]\n                     (let [ others (clojure.set/difference v #{ currel } ) ]\n                       (map (partial clojure.set/intersection currel) others)\n                       )\n                     )\n                   v\n                   )\n              )\n     )\n    )","user":"57aa290de4b0b8559636fc65"},{"problem":153,"code":"(fn [s]\n  (if (seq s)\n    (let [f (first s) r (rest s)]\n      (and\n       (every? #(empty? (clojure.set/intersection f %)) r)\n       (recur r)))\n    true))","user":"58923efce4b00487982d521c"},{"problem":153,"code":"(fn [coll]\n  (= (apply + (map count coll))\n     (count (reduce into coll))))","user":"4dd7d040535d2dad7130b5d6"},{"code":"(fn [coll]\n  (every? #(empty? (clojure.set/intersection (first %) (second %))) (for [t1 coll t2 coll :when (not= t1 t2)] [t1 t2])))","problem":153,"user":"5125745ae4b05d10e3e395f9"},{"problem":153,"code":"(fn [s]\n  (zero? (count (filter (comp not empty?)\n                        (map (partial apply clojure.set/intersection)\n                             (for [s1 s s2 s :when (not= s1 s2)] [s1 s2]))))))","user":"54fdbe3fe4b07d26eda61d3b"},{"problem":153,"code":"(fn f [sets]\n  (->>\n     (for [set1 sets\n           set2 sets] \n          (not= #{} (clojure.set/intersection set1 set2)))\n     (filter true?)\n     (count)\n     (= (count sets))))","user":"5493d908e4b0b312c081ff52"},{"code":"#(let [s (for [x % i x] i)] (= (count s) (count (set s))))","problem":153,"user":"4db858d1535d1e037afb218c"},{"problem":153,"code":"(fn [d]\n  (not (contains? (set\n                   (map\n                    #(empty?\n                      (clojure.set/intersection % (apply clojure.set/union (disj d %))))\n                    d))\n                  false)))","user":"4e8a460e535d65386fec2109"},{"problem":153,"code":"(fn [s]\n  (->> s\n       (mapcat\n        (fn [x]\n          (for [m x\n                n (disj s x)]\n            (contains? n m))))\n       (every? false?)))","user":"5dc88a38e4b02f9375f4e1db"},{"code":"(fn [c]\n  (let [flatted-coll \n        ((fn s->v [s]\n           (mapcat #(if (set? %)\n                      (s->v %)\n                      [%])\n                   s)) c)]\n    (= (count flatted-coll)\n       (count (set flatted-coll)))))","problem":153,"user":"51592b81e4b0394f658fe22c"},{"code":"(fn func [sets]\r\n  (= (reduce #(+ (count %2) %1) 0 sets)\r\n     (count (apply clojure.set/union sets))))","problem":153,"user":"505dd5c4e4b0e6aca564be0e"},{"code":"(fn [sets]\n  (loop [sets sets]\n    (if-let [[s & ss] (seq sets)]\n      (if (some #(not-empty (clojure.set/intersection s %)) ss)\n        false\n        (recur ss))\n      true)))","problem":153,"user":"4dd4034a535dae65d5c462df"},{"code":"#(every? (partial = 1) (vals (apply merge-with + (map frequencies %))))","problem":153,"user":"4f85b7b5e4b033992c121c49"},{"problem":153,"code":"#(apply distinct? (apply concat (map seq %)))","user":"576df252e4b0979f8965156f"},{"problem":153,"code":"(fn f [ss]\n  (= (count (reduce clojure.set/union ss))\n     (reduce + (map count ss))))","user":"5012da69e4b0c8732600222d"},{"problem":153,"code":"(fn disjoint [all]\n    ((fn first-disjoint [x setsleft]\n       (if (empty? setsleft)\n         true\n         (if (some #(not-empty (clojure.set/intersection x %)) setsleft)\n           false\n           (first-disjoint (first setsleft) (rest setsleft)))))\n  (first all) (rest all)))","user":"54c169ade4b0ed20f4ff6f24"},{"code":"(fn [colls]\n  (letfn [(all-pairs [coll]\n                     (loop [[x & xs] coll\n      \t\t\t\t\tresult []]\n    \t\t\t(if (nil? xs)\n      \t\t\tresult\n      \t\t\t(recur xs (concat result (map #(vector x %) xs))))))]\n    (every? #(empty? (clojure.set/intersection (first %) (second %))) (all-pairs (into [] colls)))))","problem":153,"user":"51e1a1fae4b06a68e693eaf6"},{"code":"(fn disjoint [set-of-sets]\r\n     (let [sets (seq set-of-sets)\r\n           count-elem (fn [sets] (reduce + (map count sets)))\r\n           big-set (reduce into #{} set-of-sets)]\r\n       (= (count-elem sets) (count big-set))))","problem":153,"user":"4f82e14be4b033992c121c0c"},{"code":"(fn [xs]\n\t  (every? empty? (for [x xs\n\t       y xs\n\t       :when (not= x y)]\n\t       (clojure.set/intersection x y))))","problem":153,"user":"5213ffd3e4b0961f15ac4d7d"},{"problem":153,"code":"(fn [sn]\n   (letfn [(r [s] (reduce #(apply conj %1  %2 )  s))\n           (c [s] (reduce #(+ %1 (count %2)) 0 s))]\n     (= (c sn) (count (r sn)))))","user":"5a66f358e4b0512ff01cd9d5"},{"code":"(comp (partial apply distinct?)\r\n        (partial apply concat))","problem":153,"user":"50436470e4b034ff00315d23"},{"code":"(fn intersect [sets]\n  (if (empty? sets)\n    true\n    (let [f (first sets)\n          r (rest sets)]\n      (if (some (fn [x] x)\n                (map (fn [x] (not (= #{} (clojure.set/intersection x f))))\n                     r))\n        false\n        (intersect (set r))))))","problem":153,"user":"5220a770e4b0e6a83c8925a3"},{"code":"(fn pwj [s]\n  (= #{true}\n    (set (flatten (for [i s] (map #(empty? (clojure.set/intersection i %)) (filter #(not= % i) s)))))))","problem":153,"user":"5273e006e4b03e8d9a4a7495"},{"code":"(fn [s]\n  (every? #(< % 2)\n   (map\n    #(reduce\n     (fn [n x]\n       (if (not (= 0 x))\n         (inc n)\n         n))\n     0\n     %)\n   (map\n    #(map\n      (fn [x] (count (clojure.set/intersection x %)))\n      s)\n    s))))","problem":153,"user":"4ea7999e535d7eef308072ee"},{"problem":153,"code":"(fn [L]\n     (every? empty? (for [x L y L :when (not (identical? x y))]\n          (filter \n                  #(or (x %) (and (contains? x nil) (nil? %)))\n                  y))))","user":"559c13c5e4b066d22e731f61"},{"problem":153,"code":"(fn test [sets]\n  (let [v (into [] (for [s sets\n                 x s] x))]\n    (= (count v) (count (distinct v)))\n    )\n  )","user":"54021f13e4b0df28a13c62cc"},{"problem":153,"code":"(fn [args]\n(=\n(apply + (map count args))\n(count (set (apply concat args)))))","user":"54580586e4b01be26fd74616"},{"code":"(fn hello [m] \n  (let [o (mapcat (partial into []) (into [] m))\n        p (into #{} o)]\n    (= (count p) (count o))))","problem":153,"user":"52b35a6ee4b0c58976d9ad07"},{"problem":153,"code":"(fn furp [x] \n  (if (set? x)\n    (furp (into [] x))\n    (if (= 1 (count x))\n      true\n      (if (= false\n             (reduce (fn [a b] (or a (not= #{} (clojure.set/intersection (first x) b))))\n                     false\n                     (rest x)))\n        (furp (rest x))\n        false\n      )\n    )\n  )\n)","user":"59d75e36e4b0ef0a1e9b5c32"},{"code":"#(every? true? (for [x %, y %] \n                 (or (= x y) (empty? (clojure.set/intersection x y)))))","problem":153,"user":"4f21838fe4b0d66497709fd2"},{"code":"#(every? identity (for [s1 %\n                        s2 (disj % s1)]\n                    (empty? (clojure.set/intersection s1 s2)))\n         )","problem":153,"user":"52e59ca5e4b09f7907dd1464"},{"code":"#(every?\n  empty?\n  (for [x % y % :when (not= x y)]\n    (clojure.set/intersection x y)))","problem":153,"user":"4f6160a7e4b0defedf855fbe"},{"code":"(fn pairwise-disjoint2 [coll]\n  (let [coll2 (vec coll)]\n    (every? #(= % true)\n      (for [i (range (count coll2))\n\t\t  j (range (count coll2))\n\t\t  :when (and (not (= i j))\n\t\t\t     (> j i))]\n\t      (= (count (into #{} (concat (nth coll2 i)\n\t\t\t\t\t       (nth coll2 j))))\n\t\t      (count (concat (nth coll2 i)\n\t\t\t\t     (nth coll2 j))))\n\t\t   ))))","problem":153,"user":"4dc54eb2535d8a4b2fd74284"},{"code":"#(zero? (count(filter (fn [[k v]] (< 1 (count v))) (group-by identity (reduce concat %)))))","problem":153,"user":"4fb23582e4b081705acca28a"},{"problem":153,"code":"(fn [ss]\n  (first (reduce\n   \t(fn [[flag acc] s]\n      (if (empty? (clojure.set/intersection acc s))\n            [flag (clojure.set/union acc s)]\n            [false (clojure.set/union acc s)]))\n        [true #{}] ss)))","user":"54e540c1e4b024c67c0cf7f9"},{"problem":153,"code":"(fn [sets]\n   (nil? (some not-empty\n          (map (fn [[s1 s2]] (clojure.set/intersection s1 s2))\n               (filter (fn [[s1 s2]] (not= s1 s2))\n                       (for [s1 sets s2 sets] [s1 s2]))))))","user":"53c06438e4b0c98a41f5ccb0"},{"problem":153,"code":"(fn [m]\n\t(empty? \n\t\t(for [\tx m\n\t\t\t\ty m\n\t\t\t\t:while (not= x y)\n\t\t\t\t:when (not-empty (clojure.set/intersection x y))]\n\t\t\t[x y])))","user":"57644395e4b0994c1922fbf2"},{"code":"(fn disjoint? [s] (= (count ((fn u [s](let [[e & more] (seq s)] (if-not more e (clojure.set/union e (u more))))) s)) (reduce + (map #(count %) s))))","problem":153,"user":"5138d08be4b0a5db03d727db"},{"problem":153,"code":"(fn [sets]\n  (= (reduce + (map count sets))\n     (count\n       (set (reduce concat sets)))))","user":"529dfc6de4b04e0c58e87b8a"},{"problem":153,"code":"(fn [ss]\n  (= \n   (reduce #(+ (count %2) %) 0 ss)\n   (count (reduce clojure.set/union ss))\n   )\n  )","user":"56d91a53e4b0ea9b8538f7ee"},{"code":"#(empty? (for [a % b % :when (not= a b) :when (not (empty? (clojure.set/intersection a b)))] [a b]))","problem":153,"user":"5134973ce4b0230e9f713b42"},{"problem":153,"code":"(fn [s]\n  (let [a (apply concat s)]\n    (= (count a) (count (distinct a)))))","user":"5d52bf29e4b0776584bd6f69"},{"code":"(fn [s]\n  (= s\n     (set (map #(reduce (partial apply disj) % (disj s %)) s))))","problem":153,"user":"52b453b0e4b0c58976d9ad21"},{"problem":153,"code":"(fn disjoint? [sets]\n  (not-any? identity (flatten (for [set sets]\n                             (for [item set] (map #(contains? % item) (disj sets set)))))))","user":"54f09599e4b024c67c0cf89d"},{"problem":153,"code":"#(every? empty? (for [t % x % :when (not= t x)] (clojure.set/intersection t x)))","user":"4e77c1db535d324fb2983d72"},{"problem":153,"code":"#(every? true? (for [m1 %\n                     m2 %]\n                 (or (= m1 m2)\n                     (empty? (clojure.set/intersection m1 m2)))))","user":"4f041de1535dcb61093f6ba5"},{"problem":153,"code":"(fn [ss]\n    (letfn [(all-pairs [coll]\n              (when-let [s (next coll)]\n                (lazy-cat (for [y s] [(first coll) y])\n                          (all-pairs s))))]\n      (not-any?\n       not-empty\n       (map #(clojure.set/intersection (first %) (second %)) (all-pairs ss)))))","user":"56eaad95e4b04a395b9a040f"},{"code":"(fn [sets]\n  (letfn [(find-disjoint-pair [aset sets]\n                              (when (seq sets)\n                                (or (> (count (clojure.set/intersection aset (first sets))) 0)\n                                    (recur aset (rest sets))) ))]\n         (if (seq sets)\n           (if-let [dp (find-disjoint-pair (first sets) (rest sets))]\n             false\n             (recur (rest sets)))\n           true))\n  )","problem":153,"user":"4dca8b6d535d5973398f9288"},{"code":"#(let [items (reduce + (map count %))\n       uniq (count (apply clojure.set/union %))]\n  (= items uniq))","problem":153,"user":"4e6a4954535d8ccf87e9fec0"},{"code":"; #(apply distinct? (apply concat %))\n#(= (apply + (map count %))\n    (count (set (apply concat %))))","problem":153,"user":"500933a6e4b046cdb195e074"},{"problem":153,"code":"#(let [c (apply concat %)]\n   (= (count c)\n      (count (into #{} c))))","user":"5455c2f3e4b080a794c2c87d"},{"problem":153,"code":"(fn [s]\n   (loop [coll (seq s)\n          union #{}]\n     (if (empty? coll) true\n         (let [[h & t] coll]\n           (if (not-any? (partial contains? union) h)\n             (recur t (clojure.set/union union h))\n             false)))))","user":"5e3ef7d4e4b01d43a70e8e2d"},{"problem":153,"code":"(fn disjoint? [s]\n  (empty?\n    (filter not-empty\n      (for [all s\n            others (disj s all)]\n        (clojure.set/intersection all others)))))","user":"57e9a77ae4b0bfb2137f5b35"},{"code":"(fn mds? [ss]\n  (reduce #(and %1 %2)\n    (for [x ss y ss] (if (= x y) true (= (count x) (count (apply disj x y)))))))","problem":153,"user":"50b24a2fe4b03ea88043355c"},{"problem":153,"code":"(fn [t] (apply distinct? (apply concat t)))","user":"56011393e4b04bb52996e178"},{"problem":153,"code":"#(=\n (count (reduce concat %))\n (count (reduce clojure.set/union %)))","user":"5649b1b0e4b0284900eef646"},{"problem":153,"code":"(fn [coll]\n    (letfn [(common-elements? [[a b]]\n             (< 0 (count (clojure.set/intersection a b))))]\n          (->> (for [a coll\n                     b coll :when (not= a b)]\n                 [a b])\n               (not-any? common-elements?))))","user":"532f8569e4b019098a6f8b4f"},{"code":"(fn [col]\n  (= (apply + (map count col))\n     (count (apply clojure.set/union col))))","problem":153,"user":"503ca47fe4b06c4e0e1fa24f"},{"problem":153,"code":"(fn [s]\n  (= (reduce #(+ % (count %2) ) 0 s)\n     (count (reduce clojure.set/union s))))","user":"593dfe60e4b069cdc2982bb1"},{"code":"(fn [s]\n ( #(= (count %) (count (set %)))\n    (reduce concat s)))","problem":153,"user":"4f0446f9535dcb61093f6bb8"},{"code":"(fn f [s]\n   (=\n    (count (apply clojure.set/union s))\n    (apply + (map count s))))","problem":153,"user":"53224d45e4b09d4e7a9b54c0"},{"problem":153,"code":"(fn[p#] (->> p#\n     (reduce into [])\n     (#(= (count %) (count (into #{} %))))))","user":"59ddae03e4b01968742fed65"},{"code":"(fn [s]\n   (not (reduce\n         (fn [a e]\n           (or a (reduce #(or % (clojure.set/superset? (first e) %2))\n                         false\n                         (rest e))))\n         false\n         (take (dec (count s))\n               (iterate\n                rest\n                (sort-by\n                 (comp - count) \n                 (map (fn [c]\n                        (set (map #(if (or (= (str %) \"true\") (= (str %) \"false\"))\n                                     (str %) %) c))) s)))))))","problem":153,"user":"52c25645e4b07a9af579237d"},{"problem":153,"code":"#(empty? (filter not-empty\n  (for[x % y % :when (not= x y)]\n   (clojure.set/intersection x y))))","user":"556c70dae4b09a3098a524fd"},{"problem":153,"code":"(fn [s]\n  (loop [sets s ans false]\n    (if (empty? sets)\n      (not ans)\n      (recur (rest sets) (or ans (some #(contains? (apply hash-set (apply clojure.set/union (rest sets))) %) (first sets)))))))","user":"5746061ae4b009280f9f2b5b"},{"code":"#(empty? (for [a % b (disj % a) c b :when (contains? a c)] 1))","problem":153,"user":"52160dbee4b0bf4bffd29cb3"},{"code":"(fn [sets]\n  (loop [[fs & rs] (seq sets), elts #{}]\n    (if (nil? fs)\n      true\n      (if (some #(some (fn [e] (= % e)) elts) fs)\n        false\n        (recur rs (clojure.set/union elts (set fs)))))))","problem":153,"user":"504c8165e4b09724c857af31"},{"problem":153,"code":"(fn [input]\n  (apply distinct? (mapcat seq input)))","user":"52fc34cee4b047fd55837015"},{"code":"(fn pairdisj [ss]\n  (or (= (count ss) 1)\n      (and (every? #(empty? (clojure.set/intersection (first ss) %)) (rest ss))\n           (pairdisj (rest ss)))))","problem":153,"user":"515ffbfbe4b0e2be8aa20bdd"},{"code":"(fn disjoint [sets]\n  (letfn [(no-common? [hd bd]\n                  ;; ret true if disjoint, no common ele, false if not disjoint\n                  (reduce (fn [ret this]\n                            (if-not (empty? (clojure.set/intersection hd this))\n                              false\n                              ret)) true bd))]\n    (loop [sets sets ret true]\n      (if (or (not ret)\n              (empty? sets))\n        ret\n        (recur (rest sets) (no-common? (first sets) (rest sets)))))))","problem":153,"user":"513cb853e4b0b86ece9f322b"},{"code":"(fn pds [coll]\n  (every? empty?\n          (for [a (seq coll), b (seq coll) :when (not= a b)]\n            (clojure.set/intersection a b))))","problem":153,"user":"539a2901e4b0b51d73faaf0f"},{"code":"(fn\n  [s]\n  (let [all-values (reduce into s)]\n    (every? (fn [v]\n              (= 1 (count (filter #(% v) s)))) all-values)))","problem":153,"user":"511b233ae4b07ab9ec456180"},{"problem":153,"code":"(fn [oppa] \n  (reduce #(and % %2) (for [s oppa] \n                        (reduce #(and % %2) \n                          (map #(empty?(clojure.set/intersection s %)) (disj oppa s))))))","user":"5835cb06e4b089d5ab817cea"},{"problem":153,"code":"(fn [s]\n   (= (count (reduce into s))\n      (reduce + (map count s))))","user":"53f6d555e4b0db01ade6f9e5"},{"code":"(fn __ [sets]\n  (letfn [(disjoint? [left right]\n            (zero? (count (for [l left\n                                r right\n                               :when (= l r)]\n                            :shared))))]\n    (empty?\n      (apply concat\n             (for [s sets\n                   :let [other (filter #(not= s %) sets)]]\n               (for [r other\n                     :when (not (disjoint? s r))]\n                 :covers))))))","problem":153,"user":"52463059e4b09dbe66b56198"},{"problem":153,"code":"(fn [sets]\n\t(=\n\t\t(count (apply clojure.set/union sets))\n\t\t(apply + (map count sets))\n\t)\n)","user":"5409f8eae4b0addc1aec66e6"},{"problem":153,"code":"(fn mudis [setlist]\n  (let [s (first setlist) rest (rest setlist)]\n    (if (empty? rest) true\n        (reduce #(and %1 (empty? (clojure.set/intersection s %2))) (mudis rest) rest))))","user":"58a0fc33e4b02bd94d917ea3"},{"problem":153,"code":"(fn pairwise-disjoint? [set-of-sets]\n  (apply distinct? (mapcat seq set-of-sets)))","user":"58ed713de4b056aecfd47d84"},{"problem":153,"code":"(fn [s] \n  (= (count (reduce into #{} s))\n     (reduce + (map count s)))\n)","user":"5aa998c6e4b0d174b936c8e5"},{"problem":153,"code":"(fn [sets]\n   (not\n    (reduce #(or %1 %2)\n            (flatten ((fn [i] (for [a i]\n                                (for [b i\n                                      :when (not (= a b))]\n                                  (for [c a]\n                                    (contains? b c)))))\n                      sets)))))","user":"50981062e4b04e098a4c7268"},{"problem":153,"code":"(fn [sos]\n  (letfn [(comb [n coll]\n            (cond (zero? n) '(())\n                  (empty? coll) '()\n                  :else (concat (map #(cons (first coll) %)\n                                     (comb (dec n) (rest coll)))\n                                (comb n (rest coll)))))]\n    (->> (comb 2 sos) ; lazy sequence of all 2-combinations\n         (map (partial apply clojure.set/intersection)) \n         (every? #(= #{} %)))))","user":"53576356e4b04ce2eb3ed27a"},{"code":"(fn p153s? [s]\n  (= (count (reduce #(clojure.set/union %1 %2) s)) (apply + (map count s)))\n  )","problem":153,"user":"4f63777be4b0defedf855fe4"},{"code":"(fn [ts]\n  (every?\n   (fn [t]\n     (every? #(= (clojure.set/intersection t %) #{})\n             (disj ts t)))\n   ts))","problem":153,"user":"4e6a412e535d8ccf87e9feb6"},{"problem":153,"code":"(fn mut-disjoint? [coll]\n  (apply distinct? (mapcat seq  coll)))","user":"53f2370ee4b0742d9025b0e7"},{"problem":153,"code":"(fn [sets]\n  (loop [r #{}, s sets]\n    (if (empty? s)\n      true\n      (if (some #(contains? r %) (first s))\n        false\n        (recur (into r (first s)) (rest s))))))","user":"5dc9ccf8e4b02f9375f4e1f1"},{"problem":153,"code":"(fn disj? [xs]\n  (loop [acc #{} xs xs]\n    (if (empty? xs)\n      (= 1 (count acc))\n      (recur\n       (into acc\n             (map (partial clojure.set/intersection (first xs)) (rest xs)))\n       (rest xs)))))","user":"5a257747e4b07f18be40aa1f"},{"problem":153,"code":"(fn [s]\n  (loop [news '() tmps s c 0]\n    (if (empty? tmps) \n      (if (= c (count (set news)))\n        true\n        false)\n      (recur (concat (set news) (first tmps)) (rest tmps) (+ c (count (first tmps)))))))","user":"59368ccae4b02506e01a297a"},{"problem":153,"code":"#(= (reduce + (map count %))\n    (count (reduce into #{} %)))","user":"55bfc39ee4b01b9910ae2a1a"},{"problem":153,"code":"(fn [ss]\n          (reduce\n           (fn [r [x y]]\n             (and r (reduce\n                     (fn [a b] (and a (= :z (get x b :z))))\n                     true y)))\n           true\n           (for [x ss\n                 y ss :when (not= x y)]\n             [x y])))","user":"54acf5c7e4b09f271ff37cdd"},{"code":"(fn [ls]\r\n  (not-any? identity\r\n      (for [s1 ls \r\n            s2 ls\r\n            a s1]\r\n        (do (println [s2 a]) (boolean \r\n          (and (not= s1 s2) (not= :nope (get s2 a :nope))))))))","problem":153,"user":"502a9fdee4b095a7adb898b4"},{"problem":153,"code":"(fn [xss]\n  (every? empty?\n          (for [xs xss, ys xss\n                :when (not= xs ys)]\n            (clojure.set/intersection xs ys))))","user":"53dfdf01e4b0d874e779ae46"},{"problem":153,"code":"(fn [xsIn]\n  (loop [xs xsIn result true]\n    (if result\n      (if-let [tailSets (next xs)] ;if no tail then nothing to compare the head against\n        (let [headSet (first xs)]\n          (recur (rest xs) (and result (every? #(empty? (clojure.set/intersection headSet %)) tailSets)))\n          )\n        true)\n      false)\n      )\n    )","user":"525b4e8de4b0cb4875a45d0f"},{"problem":153,"code":"(fn [sets]\n  (let [pairwise (for [s sets s2 sets :when (not= s s2)] [s s2])\n        disjoint? (fn [[s1 s2]] (= nil (some s1 s2)))]\n    (and \n     (not-any? empty? sets)\n     (every? disjoint? pairwise))\n    )\n  )","user":"6004c750e4b074f607df6645"},{"problem":153,"code":"(fn [sets]\r\n  (let [\r\n    comb (fn comb [n items]\r\n      (if (> n (count items))\r\n        '()\r\n      (if (zero? n)\r\n        '(())\r\n      (if (= n 1)\r\n        (map vector items)\r\n        (let [[head & tail] items]\r\n          (concat\r\n            (map #(cons head %) (comb (dec n) tail))\r\n            (comb n tail)))))))\r\n    disjoint? (fn [a b]\r\n      (empty? (filter #(contains? a %) b)))]\r\n    (->>\r\n      (apply vector sets)\r\n      (comb 2)\r\n      (map #(apply disjoint? %))\r\n      (every? identity))))","user":"555bd27ae4b0b056612e2244"},{"code":"(fn [coll]\n  (let [ss (for [a coll b coll\n                 :when (not (identical? a b))]\n             (clojure.set/intersection a b))]\n    (every? empty? ss)))","problem":153,"user":"4f7d25b4e4b06e829148e1ba"},{"problem":153,"code":"(fn [x] (let [y (sequence x)]\n          (if (< (count (distinct (mapcat identity y)))\n                 (count (mapcat identity y)))\n            false true)))","user":"5233564ae4b0f0b72fabf403"},{"problem":153,"code":"(fn foo [seqs]\n        (loop \n            [ seqs seqs \n             container #{}\n             ]\n          (cond (empty? seqs) true\n              (empty? (clojure.set/intersection container (first seqs)))\n              (recur (rest seqs) (clojure.set/union (first seqs) container))\n              :else false\n              )\n          )\n        )","user":"6038b6b4e4b0d5df2af222ef"},{"problem":153,"code":"(fn [coll]\n    (let [simple-contains? #(some (fn [n] (and (= n %2))) %1)\n          result-set (reduce\n                      (fn [memo s]\n                        (if (map? memo)\n                          memo\n                          (let [duplicated (some #(simple-contains? memo %) s)]\n                            (if duplicated {:dup duplicated :memo memo} (concat memo s)))))\n                      coll)]\n      (not (map? result-set))))","user":"58bbcbc8e4b0888cdc949d00"},{"problem":153,"code":"#(every? empty? (for [x % y % :when (not (identical? x y))] (clojure.set/intersection x y)))","user":"5b7bc82ce4b047b03b203726"},{"code":"(fn [set-of-sets]\r\n  (letfn [(pairwise-disjoint? [set1 set2]\r\n           (not (or\r\n                 (some identity (for [i set1 :when (contains? set2 i)] true))\r\n                 (some identity (for [i set2 :when (contains? set1 i)] true)))))]\r\n    (every? identity\r\n            (for [i set-of-sets\r\n                  j set-of-sets\r\n                  :when (not (identical? i j))]\r\n              (pairwise-disjoint? i j)))))","problem":153,"user":"4de2f44f535d08e6dec9fdec"},{"problem":153,"code":"(fn pairwise-disjoint [xss]\n  (apply distinct? (mapcat seq xss)))","user":"5bea3177e4b0f319e2d7ec81"},{"problem":153,"code":"(fn [sets]\n  (letfn [(pairwise-disjoint? [s]\n    (let [except-s (clojure.set/difference sets (conj #{} s))]\n      (every? #(empty? (clojure.set/intersection s %)) except-s)))]\n  (every? pairwise-disjoint? sets)))","user":"5bcf0b1be4b0e9689409ee24"},{"problem":153,"code":"(fn pia [s]\n  (apply distinct?\n    (mapcat seq s)))","user":"569ce6fee4b0542e1f8d146c"},{"problem":153,"code":"(fn pairwise-disjoint-sets-solution\n  [sets]\n  (every? #(= 1 %) (vals (frequencies (mapcat identity sets)))))","user":"4daf420cedd6309eace4d176"},{"problem":153,"code":"(fn [s]\n   (= (count (apply clojure.set/union s))\n      (reduce + (map count s))))","user":"5327c591e4b09d4e7a9b54ff"},{"code":"(fn [s]\n  (=\n   (reduce #(+ (count %2) %) 0 s)\n   (count (reduce #(clojure.set/union % %2) s))\n   ))","problem":153,"user":"5054bc87e4b0b1b9d1860eb0"},{"problem":153,"code":"(fn dj [s]\n  (empty? (apply concat\n                 (for [i s\n                       j s]\n                   (when (not= i j)\n                     (clojure.set/intersection i j))))))","user":"583048d9e4b051871117c007"},{"problem":153,"code":"(fn [sets]\n  (=\n   (apply + (map count sets))\n   (count (reduce into #{} sets))))","user":"5db5d09be4b010eb3c36cd31"},{"problem":153,"code":"(fn [sset]\n    (not\n     (some seq\n           (for [x sset\n                 y sset\n                 :when (not= x y)]\n             (clojure.set/intersection x y)))))","user":"54246fcce4b01498b1a71aed"},{"problem":153,"code":"(fn disjoint3? [s2]\n  (let [vals (for [x s2 x' x] (if (coll? x') (into #{} x') x'))\n        ]\n    ;;(println vals)\n    (= (count (distinct vals)) (count vals)))\n    )","user":"529a73bde4b02ebb4ef75096"},{"problem":153,"code":"#(= (apply + (map count %)) (count (reduce into #{} %)))","user":"4db92654535d1e037afb21a0"},{"problem":153,"code":"(fn mutually-disjoint [xs]\n  (let [all (mapcat vec xs)]\n    (= (count all) (count (distinct all)))))","user":"54448e84e4b032a45b869393"},{"code":"(fn pairwise [sets]\n  (not (first (reduce\n           (fn [[clash acc] s]\n             [(or clash (not-empty (clojure.set/intersection acc s))) (clojure.set/union acc s)])\n           [false #{}]\n           sets))))","problem":153,"user":"4f03641a535dcb61093f6a9b"},{"code":"#(let [c (mapcat vec %) d count] (= (d c) (-> c distinct d)))","problem":153,"user":"51a10b2ce4b0b292b01ee3fe"},{"problem":153,"code":"(fn disj-sets [sos]\n  (let [fsos (first sos) r (rest sos) fr (first r)]\n    (println (str fsos \"|\" fr))\n    (if fr\n      (if (and fr (empty? (clojure.set/intersection fsos\n                                                         fr)))\n             (disj-sets (conj  (rest r) (clojure.set/union fsos fr)))\n             false)\n      true)))","user":"552e1c98e4b076ab5578f7ee"},{"problem":153,"code":"#(let [\n       total (apply + (map count %))\n       real (count (set (apply concat (map vec %))))\n       ]\n   (= total real))","user":"54d05a9de4b0e8a36923e5c7"},{"code":"(fn l-disjoint\n  [sets]\n  (loop [x (first (first sets)) cur (rest (first sets)) others (rest sets) remaining (rest sets)]\n    (if (and (empty? others) (empty? remaining))\n      true\n      (if (empty? others)\n        (if-not (empty? cur)\n          (recur (first cur) (rest cur) remaining remaining)\n          (recur (first (first remaining)) (rest (first remaining)) (rest remaining) (rest remaining)))\n        (if (contains? (first others) x)\n          false\n          (recur (first cur) (rest cur) (rest others) remaining))))))","problem":153,"user":"534ff8a6e4b084c2834f4ad1"},{"problem":153,"code":"(fn [s]\n  (apply distinct? (reduce into [] s)))","user":"4fdb881ee4b05e33b9224f5e"},{"problem":153,"code":"(fn [st]\n  (let [flattened-set (reduce (fn [v acc]\n            (clojure.set/union acc v)) st)\n        set-count (apply + (map count st))]\n    (= (count flattened-set) set-count)))","user":"54133900e4b01498b1a719de"},{"problem":153,"code":"(fn all-disjoint [sos] (let [pair-disjoint (fn [s1 s2] (not-any? identity (for [x s1] (contains? s2 x))))]\n                         (every? identity (for [s1 sos s2 sos]\n                                      (or (= s1 s2)\n                                          (pair-disjoint s1 s2))))))","user":"5ee93720e4b029a2061bbeb7"},{"code":"(fn [x] (every? true? (for [a x b x :when (not= a b)] (empty? (clojure.set/intersection a b)))))","problem":153,"user":"526dd90de4b03e8d9a4a72fe"},{"problem":153,"code":"(fn __\n  [ss]\n  (let [ss-seq (seq ss)\n        c1 (reduce #(+ % (count %2)) 0 ss-seq)\n        c2 (count (reduce clojure.set/union #{} ss-seq))]\n    (= c1 c2)))","user":"547bf82de4b0c51c1f4d72e1"},{"problem":153,"code":"(fn [sets]\n  (every? empty?\n          (for [s1 sets\n                s2 sets\n                :when (not (identical? s1 s2))]\n            (clojure.set/intersection s1 s2))))","user":"5617a540e4b06b1bb2182a12"},{"problem":153,"code":"(fn [s] (every? #(= 1 (count (second %))) (group-by identity (apply concat s))))","user":"54d03026e4b018d918be98de"},{"problem":153,"code":"(fn [ss]\n  (let [merged (into #{} (for [s ss e s] e))\n        nelts (reduce + (map count ss))]\n   (= (count merged) nelts)))","user":"4edd038c535d10e5ff6f5327"},{"code":"(fn disjoint [x]\n  (let [l (reduce concat x)]\n    (= (count l) (count (into #{} l)))\n  )\n)","problem":153,"user":"50588af1e4b06522596eba7d"},{"problem":153,"code":"(fn disjnt? [s]\n  (apply distinct? (for [st s\n                        item st]\n                    item)))","user":"5d48e6d3e4b0776584bd6f15"},{"code":"(fn [s]\n      (= (count s) (count (filter (comp not nil?)\n                                  (for [a s, b s]\n                                    (some a b))))))","problem":153,"user":"50f48298e4b004d364930527"},{"problem":153,"code":"(fn sets [val] \n  (let [a (first val)\n        args (rest val)\n        ai (apply concat a args)]\n    (= (count ai) (count (into #{} ai)))))","user":"54eff2bee4b024c67c0cf88d"},{"code":"(fn p153[x]\n  (= (reduce #(+ %1 (count %2)) 0 x)\n   (count (reduce clojure.set/union x))))","problem":153,"user":"500b61b1e4b03d00572d2d81"},{"problem":153,"code":"(fn [sets]\n  (letfn [(pairwise-disjoint? \n            [x & xs]\n            (or (empty? xs)\n                (if (= x (apply (partial disj x) (apply concat xs)))\n                  (apply pairwise-disjoint? xs)\n                  false)))]\n    (apply pairwise-disjoint? sets)))","user":"55702081e4b09a3098a52529"},{"code":"(fn disjoint [sos]\n  (loop [xs [] [s & ss] (seq sos)]\n    (if (or (empty? s) (some boolean (map s xs)))\n      false\n      (if (empty? ss)\n        true\n        (recur (concat xs (into [] s)) ss)\n        )\n      )\n    )\n  )","problem":153,"user":"527ba695e4b03e8d9a4a7596"},{"code":"(fn [input]\n  (reduce\n   #(= true %1 %2)\n   (for [a input, b input]\n     (or\n      (= a b)\n      (empty? (clojure.set/intersection a b))))))","problem":153,"user":"528bba38e4b0239c8a67aea9"},{"problem":153,"code":"(fn pds [input]\n  (loop [sets (vec input), counter 0]\n    (if (empty? sets) (zero? counter)\n        (recur (rest sets)\n               (+ counter\n                  (reduce #(+ %1\n                              (count (clojure.set/intersection (first sets) %2)))\n                          0\n                          (rest sets)))))))","user":"5f548678e4b0a0bc16850a7e"},{"code":"#(every? empty? (for [x % y % :when (not (identical? x y))]\n  (clojure.set/intersection x y)))","problem":153,"user":"4e82f85d535db62dc21a62ce"},{"code":"(fn disjoint? [x]\n  (let [seen-walk? (fn seen-item? [firstset setlist]\n                     (let [combined-sets (concat firstset (first setlist))]\n                       (and\n                         (apply distinct? combined-sets)\n                         (or\n                           (= nil setlist)\n                           (seen-item? combined-sets (next setlist))))))]\n        (seen-walk? (first x) (rest x))))","problem":153,"user":"51f82769e4b09be9c177e527"},{"problem":153,"code":"(fn [bigset]\n  (let [v (atom true)]\n  (doseq [s bigset]\n    (doseq [sset (disj bigset s)]\n      (if (not= (clojure.set/intersection s sset) #{})\n        (swap! v (fn [_] false)))))\n    @v))","user":"60264d89e4b0d5df2af2222d"},{"problem":153,"code":"(fn [sets]\n  (every? \n   (fn [set1] \n     (every?\n      (fn [set2] (empty? (clojure.set/intersection set1 set2)))\n      (clojure.set/difference sets #{set1}))) \n   sets))","user":"577629abe4b0979f8965162e"},{"problem":153,"code":"(fn pd [s]\n   (if (empty? s)\n      true\n      (let [s1 (first s) s2 (rest s)]\n         (and (every? #(= (clojure.set/difference s1 %) s1) s2) (pd s2)))))","user":"59f043d0e4b0966464fe6a3d"},{"code":"(fn [inp] (= (apply + (map count inp))\n             (count (loop [rv #{} v (seq inp)]\n                        (if (empty? v)\n                        \trv\n                          \t(recur (into rv (first v)) (rest v)))))))","problem":153,"user":"534f13b2e4b084c2834f4ac4"},{"problem":153,"code":"(fn [ss]\n        (empty? (for [s1 ss\n                      s2 (disj ss s1)\n                      :when (some #(contains? s1 %) s2)]\n                  1)))","user":"546c4377e4b00cfc9eacc177"},{"code":"(fn [s] \n  (= (count (reduce clojure.set/union (seq s)))\n     (apply + (map count (seq s)))))","problem":153,"user":"501c1492e4b086d93747d180"},{"code":"(fn [sets]\n  (let [count-of-distints-elements (count (reduce into sets))\n        sum-of-counts (reduce + (map count sets))]\n    (= count-of-distints-elements sum-of-counts)))","problem":153,"user":"51269362e4b083bb8f88cf09"},{"problem":153,"code":"#(every? (fn [[a b]] (empty? (clojure.set/intersection a b))) (for [x % y % :when (not= x y)] [x y]))","user":"5a3d7afae4b0447ef91cc5a6"},{"problem":153,"code":"#(not= nil\n  (reduce (fn [acc s]\n           (if (nil? acc)\n             nil\n             (reduce (fn [acc2 x]\n                       (if (or (nil? acc2) (some (fn [y] (= y x)) acc2))\n                         nil\n                         (conj acc2 x))) acc s)))\n         %))","user":"5097ea89e4b087ccf61a7af4"},{"problem":153,"code":"(fn pairwise [x]\n       (loop [y (first x)\n              w (rest x)]\n           (if (empty? w)\n               true\n               (if (some #(not(empty? (clojure.set/intersection y %)))\n                         w)\n                   false\n                   (recur (first w)\n                          (rest w))))\n           ))","user":"5f737899e4b02876ed9fd099"},{"problem":153,"code":"#(every? empty? (for [x %\n                      y %]\n                  (if (identical? x y)\n                    #{}\n                    (clojure.set/intersection x y))))","user":"53d5a63be4b0e771c3025449"},{"code":"(fn dis[s]\r\n  (reduce #(cond (= %1 false) false (some (fn search[q](not= #{}\r\n      (clojure.set/intersection %2 q))) (disj s %2)) false :else true)\r\n    true s))","problem":153,"user":"5065bd94e4b0148eb3925aed"},{"problem":153,"code":";(fn f153\n;  [xs]\n;  (let [res (frequencies\n;            (map #(when (and (> (count %) 0) (false? (nth % 0)))\n;                    false\n;                    true)\n;               (map #(sort %)\n;                    (for [i xs\n;                          j xs]\n;                      (for [a i\n;                            b j] (not= a b))))))]\n;    (if (> (res true) (count xs))\n;      false\n;      true)))\n\n#(apply distinct? (apply concat %))","user":"59390a35e4b02506e01a29f3"},{"problem":153,"code":"(fn [sets]\n  (letfn\n    [\n     (pairs [lst]\n       (if (empty? lst)\n         []\n         (concat\n           (map (fn [x] [(first lst) x]) (rest lst))\n           (pairs (rest lst))\n           )\n         )\n       )\n     ]\n      (every?\n        empty?\n        (map #(apply clojure.set/intersection %) (pairs sets)))))","user":"562add6de4b00e49c7cb4834"},{"problem":153,"code":"(fn [ss]\n  (let [ks (for [s ss, v s] v)\n        freq (reduce (fn [m k] (assoc m k (inc (get m k 0)))) {} ks)\n        max-freq (apply max (map #(second %) (seq freq)))]\n    (= 1 max-freq)))","user":"51b920bfe4b0e871ca4958f9"},{"problem":153,"code":"#(=\n  (apply + (map count %))\n  (count (reduce into %))\n  )","user":"55e1d34ae4b050e68259b421"},{"problem":153,"code":"(fn [s]\n  (= (reduce + (map count s))\n     (count (reduce clojure.set/union s))))","user":"54125eeee4b01498b1a719d3"},{"problem":153,"code":"(fn [coll]\n    (->> (for [x coll y coll :when (not= x y)] [x y]) ; make pairs\n         (map #(apply clojure.set/intersection %))\n         (every? empty?)))","user":"5630ce72e4b0bfe05bf11786"},{"code":"(fn f [set]\n   (letfn [(disjoint? [a b] (empty? (clojure.set/intersection a b)))\n           (mdis? [m sets] (every? #(disjoint? m %1) sets))\n           (parwisedis? [sets]\n             (if-let [[h & sets] sets]\n               (and (mdis? h sets) (f sets))\n               true))]\n     (parwisedis? (seq set))\n     ))","problem":153,"user":"4fc8c8d8e4b0ee37620e183b"},{"problem":153,"code":"(fn pairwise-disjoint? [set-of-sets]\n  (not (some #(> % 1) (vals (apply merge-with + (map frequencies set-of-sets))))))","user":"54e3df6ae4b024c67c0cf7e3"},{"code":"(fn __ [sets]\n  (every? empty?\n        (apply concat (for [s sets]\n                        (map #(clojure.set/intersection s %) (remove #(= s %) sets))))))","problem":153,"user":"512d3304e4b040332b905b2d"},{"code":"#(= (apply + (map count %))\n    (count (into #{} (apply concat %))))","problem":153,"user":"51256b40e4b05d10e3e395f8"},{"problem":153,"code":";(fn [sets]\n;  (let [set (first sets)\n;        sets (rest sets)]\n;    (loop [current set\n;           remaining sets]\n;      (if (empty? remaining)\n;        true\n;        (if (every? empty? (map clojure.set/intersection (repeat current) remaining))\n;          (recur (first remaining) (rest remaining))\n;          false)))))\n;#(->> %\n;      (apply concat)\n;      (apply distinct?))\n#(apply distinct? (apply concat %))","user":"54ca9ca8e4b057c6fda3a265"},{"code":"#(= (apply concat %) (distinct (apply concat %)))","problem":153,"user":"4ff63f3fe4b0678c553fc377"},{"problem":153,"code":"(fn [s]\n  (letfn [(combinations [coll]\n            (when (> (count coll) 1)\n              (lazy-cat (map vector (repeat (first coll)) (rest coll))\n                        (combinations (rest coll)))))]\n    (->> (combinations s)\n      (map #(apply clojure.set/intersection %))\n      (every? empty?))))","user":"561ca2eae4b064ca9f4b169b"},{"code":"(fn [ss] (every? empty? (for [i ss j ss :when (not (= i j))] (clojure.set/intersection i j))))","problem":153,"user":"4fc7db47e4b0ee37620e182a"},{"code":"(fn [s] (let [x (reduce #(identity {:count (+ (count %2) (get %1 :count)) :set (concat (get %1 :set) %2)}) {:count 0 :set #{}} s)]\n                   (= (get x :count) (count (set (get x :set))))))","problem":153,"user":"52c1bd29e4b07a9af579236a"},{"code":"(fn disj [sets]\n  (letfn [(has-common-elems [s1 s2]\n\t\t\t    (first (filter identity\n\t\t\t\t\t   (for [x s1\n\t\t\t\t\t\t y s2]\n\t\t\t\t\t     (= x y)))))]\n    (not-any? identity\n     (for [a sets\n\t   b sets\n\t   :when (not (identical? a b))]\n       (has-common-elems a b)))))","problem":153,"user":"4e513ecf535dc968683fc4f6"},{"problem":153,"code":"(fn[xs]\n  (let [xslist (mapcat identity xs)\n        xsuniq (distinct xslist)]\n    (= (count xslist) (count xsuniq))))","user":"54f86b8ce4b01ecee9d88828"},{"code":"(fn [s] \n  (every? empty? (for [s1 s\n                       s2 s\n                       :when (not= s1 s2)]\n                   (clojure.set/intersection s1 s2))))","problem":153,"user":"506d5e4ce4b0a302964c5493"},{"code":"(fn [S]\n  (= (count (apply clojure.set/union S))\n     (reduce #'+ (map count S))))","problem":153,"user":"530d85dee4b08068f379eca8"},{"problem":153,"code":"(fn [s]\n    (let [x (first s)\n          l (rest s)\n          disjoin? (fn [s1 s2]\n                     (every? true? (for [x s1] (not (contains? s2 x)))))]\n      (if (empty? s) true \n      (and (every? true? (for [y l] (disjoin? x y)))\n           (recur (rest s))))))","user":"539c88e1e4b0b51d73faaf2c"},{"code":"(fn aa [ix]\n   (loop [x (vec ix)]\n   \n      (if (= (count x) 1) true\n          (if (some false?\n              (for [xx (rest x)]\n                  (if (or (= (count (first x)) (count xx) 0) \n                          (not= #{} (clojure.set/intersection (first x) xx)))\n                              false\n                              true\n                            )\n         \t  )\n                        )\n                false        \n            (recur (rest x))\n                     \n                     )\n         )\n       )\n     )","problem":153,"user":"5105ed16e4b01150e115ebe2"},{"problem":153,"code":"(fn [ss]\n  (loop [a (first ss)\n         b (rest ss)]\n    (if (empty? b)\n      true\n      (if (some #(not (empty? (clojure.set/intersection a %)))\n                b)\n        false       \n        (recur (first b)\n               (rest b))))))","user":"4e8a170c535d3e98b802328f"},{"problem":153,"code":"(fn [ms]\n    (= (count (apply clojure.set/union ms)) (reduce + (map count ms))))","user":"52bf0116e4b07a9af5792328"},{"code":"(fn [c]\n  (= (apply + (map count c)) (count (reduce clojure.set/union c))))","problem":153,"user":"51195e77e4b055cfb310d499"},{"problem":153,"code":"(fn [s]\n  (let [common? (fn [s1 s2]\n                  (empty? (filter (partial contains? s2) s1)))\n        incommon? (fn [s1 s2]\n                    (loop [m s2]\n                      (if (nil? m)\n                        true\n                        (and (common? s1 (first m)) (recur (next m))))))\n        ]\n    (loop [m (next s)\n           e  (first s)]\n      (if (nil? m)\n        true\n        (and (incommon? e m) (recur (next m) (first m)))))))","user":"56051095e4b08b23635d3162"},{"problem":153,"code":"(fn [parent-set] (= (count (reduce into (first parent-set) (rest parent-set)))\n\n                   (reduce + (map count parent-set))))","user":"5f32f69ae4b0574c87022c35"},{"code":"#(= #{1}\n   (into #{}\n         (map (comp count second)\n              (group-by identity (apply concat %)))))","problem":153,"user":"4ffc10aae4b0678c553fc3d6"},{"code":"#(loop [ss (for [x % y % :while (not= x y)] [x y])]\n   (if (empty? ss)\n     true\n     (if (empty? (apply clojure.set/intersection (first ss)))\n       (recur (rest ss))\n       false)))","problem":153,"user":"50ae0d24e4b0a40c9cfb08ce"},{"problem":153,"code":"(fn [xs] \n  (= '(nil) (remove #{nil #{}} (into #{}\n  \t(for [s xs, otro xs] (when (not= s otro) (clojure.set/intersection s otro)))))))","user":"54e51c7be4b024c67c0cf7f7"},{"problem":153,"code":"(fn disjoint [xs]\n  (= \n    (->> xs (map count) (reduce +))\n    (->> xs (mapcat identity) set count)))","user":"59c94a69e4b0a024fb6ae576"},{"code":"(fn [s]\n  (let [sets (seq s)\n        u (apply clojure.set/union sets)\n        a (count u)\n        b (reduce + (map count sets))]\n    (= a b)))","problem":153,"user":"4f3d83b5e4b0e243712b1f69"},{"problem":153,"code":"(fn pairwise-disjoint [s]\n  (loop [[f & r] (seq s)]\n    (if (nil? r) true\n        (if (some #(not (empty? (clojure.set/intersection f %))) r)\n          false\n          (recur r)))))","user":"572ec4dde4b0cd1946bd0f8d"},{"problem":153,"code":"#(empty? \n (apply concat \n        (for [x % y % :when (not= x y)] (clojure.set/intersection x y))))","user":"55632016e4b0c656e3ff17e4"},{"problem":153,"code":"(fn __ [s]\n  (every? true?\n          (for [x s, y s, :when (not= x y)]\n            (empty? (clojure.set/intersection x y)))))","user":"54c271b9e4b045293a27f602"},{"problem":153,"code":"(fn satisfy? [xs]\n  (let [[x & xs] (seq xs)]\n    (or (not x)\n        (and (every? empty? (map #(clojure.set/intersection x %) xs))\n             (satisfy? xs)))))","user":"5393185ae4b0b51d73faaeb7"},{"problem":153,"code":"(fn pairwise-disjoint-sets\n  [sets]\n  (= (reduce #(+ %1 (count %2)) 0 sets) (count (apply clojure.set/union sets))))","user":"53b952eee4b047364c0444e6"},{"code":"(fn [xs] \n  (= (count (reduce clojure.set/union xs))\n     (reduce + (map count xs))))","problem":153,"user":"4efcac3a535de96065cf507e"},{"problem":153,"code":"(fn [sets]\n  (loop [s #{}\n         sts sets]\n    (if (empty? sts) true\n      (if (empty? (clojure.set/intersection s (first sts)))\n        (recur (clojure.set/union s (first sts)) (rest sts))\n        false))))","user":"558bb38fe4b0277789237631"},{"code":"(fn [s] (= \n         (count (apply clojure.set/union s))\n         (reduce #(+ % (count %2)) 0 s)))","problem":153,"user":"52d7a930e4b09f7907dd1379"},{"code":"(comp (partial apply distinct?)\n      (partial mapcat identity))","problem":153,"user":"4f969a66e4b0dcca54ed6cde"},{"problem":153,"code":"(fn disjoint [s]\n  (let [cardinality (reduce + (map count s))\n        elem-set (into #{} (mapcat identity s))]\n    (= cardinality (count elem-set))))","user":"4f748b54e4b044e54cd9a8fa"},{"problem":153,"code":"(fn my-pairwise [sets]\n  (empty? (for [setA sets, setB sets\n    :let [inters (clojure.set/intersection setA setB)]\n    :when (not (= setA setB))\n    :when (not (empty? inters))] inters)))","user":"59dd387be4b0a0ac046f2502"},{"code":"#(not (some #{true}\n  (for [s %\n        t (disj % s)\n        u s\n        v t]\n    (= u v))))","problem":153,"user":"4e96557d535dbda64a6f6b43"},{"code":"(fn pairwise-disjoint [power-set]\n   (letfn [(check-not-in [el rest-sets]\n\t\t\t\t   (not (some #(contains? % el) rest-sets))\n\t\t                 ) \n\t   (check-one-set [a-set rest-sets]\n \t     \t\t\t\t\t(not (some #(not (check-not-in % rest-sets)) a-set))\n\t       \t\t\t\t  )\n           (check-disjoint [set-sequence]\n                (println \"check-disjoint\" set-sequence)\n\t\t(if (seq set-sequence)\n           \t\t(let [a-set (first set-sequence) rest-sets (rest set-sequence)]\n              \t\t\t(if (check-one-set a-set rest-sets)\n                  \t\t\t(check-disjoint rest-sets)\n                  \t\t\tfalse\n             \t\t\t)\n           \t\t)\n           \t\ttrue\n              \t)\n\t   )\n            \n      \t\t]\n      (let [set-seq (seq power-set)]\n      \t  (check-disjoint set-seq)\n      )\n   )\n)","problem":153,"user":"52763696e4b03e8d9a4a74d7"},{"problem":153,"code":"(fn [c] (every? #(= #{} %)\n                (reduce #(into % %2) #{}\n                        (for [s c] (map #(clojure.set/intersection s %) (disj c s))))))","user":"52d07cc5e4b07d0d72b273bb"},{"code":"(fn [x]\n   (= 0\n      (count\n       (for [a x\n             b x\n             :when (and\n                    (pos? (count (clojure.set/intersection a b)))\n                    (not (identical? a b)))]\n         [ a b]))))","problem":153,"user":"506c0a02e4b0eda3100c090d"},{"problem":153,"code":"(fn [coll]\n  (loop [l coll]\n    (if (empty? l)\n      true\n      (if (every? empty? (for [x (next l)] (clojure.set/intersection (first l) x)))\n        (recur (next l))\n        false\n      )\n    )\n  )\n)","user":"57873017e4b0ebec4cfb7503"},{"code":"(fn [sets] (every? empty? (for [s1 sets s2 (disj sets s1)] (clojure.set/intersection s1 s2))))","problem":153,"user":"532347dde4b09d4e7a9b54cc"},{"code":"(fn [s]\n    (not-any? identity\n        (for [x s y s :when (not= x y)] (some #(contains? x %) y))\n    )\n)","problem":153,"user":"5165a235e4b079ad97ec44ac"},{"code":"#(= ((comp count distinct (partial reduce concat)) %1) ((comp count (partial reduce concat)) %1))","problem":153,"user":"4f9fe2b9e4b0dcca54ed6d40"},{"code":"(fn [coll]\n  (apply distinct? (mapcat seq coll)))","problem":153,"user":"520612a7e4b0bf4f1882c81c"},{"code":"(fn disjoint [set-of-sets]\n  (apply (fn [& sets]\n    (= (count (set (apply concat sets)))\n       (reduce + (map count sets))))\n  (into [] set-of-sets)))","problem":153,"user":"538c3424e4b0b51d73faae58"},{"problem":153,"code":"(fn ds [coll]\n   (let [ss (for [a coll b coll\n                  :when (not (identical? a b))]\n              (clojure.set/intersection a b))]\n    (every? empty? ss)))","user":"5fd8bcb3e4b05ac5b16ea11b"},{"code":"#(= (apply + (map count %))\n    (count (into #{} (mapcat seq %))))","problem":153,"user":"4ff67852e4b0678c553fc37e"},{"problem":153,"code":"(fn f [c]\n  (let [[h & t] (vec c)] \n   (if (nil? h)\n     true\n     (if (apply = #{}\n          (map #(clojure.set/intersection h %) t))\n          (f t)\n          false))))","user":"548b7db8e4b0e286459a11fd"},{"code":"(fn do-it [sets]\n  (let [have-common-element (fn [s1 s2]\n  (loop [todo s1]\n    (if (empty? todo)\n      false\n      (if (contains? s2 (first todo))\n        true\n        (recur (rest todo))))))]\n  (not (some #(= true %) (for [x sets y sets :when (not (= x y))]\n      (have-common-element x y))))))","problem":153,"user":"4f08a8a2535dcb61093f6c3d"},{"problem":153,"code":"(fn q[input]\n  (\n    loop\n      [head (first input)\n       tail (rest input)]\n    (\n      cond\n        (empty? tail)\n        ; (do\n          ; (println head tail \"true\")\n          true\n        ; )\n        (every? empty? (map #(clojure.set/intersection head %) tail))\n        ; (do\n          ; (println head tail \"iter\")\n          (recur (first tail) (rest tail))\n        ; )\n        :else\n        ; (do\n          ; (println head tail \"false\")\n          false\n        ; )\n    )\n  )\n)","user":"5717d674e4b07c98581c3b1a"},{"code":"(fn f [set-of-sets]\n  (if (empty? set-of-sets)\n    true\n    (let [s (first set-of-sets)\n          rs (rest set-of-sets)\n          disjoint? (every? #(empty? (clojure.set/intersection % s)) rs)]\n      (and disjoint? (f rs)))))","problem":153,"user":"51efd397e4b0249c592fbdeb"},{"problem":153,"code":"(fn [s] (= (apply + (map count (seq s))) (count (apply clojure.set/union (seq s)))))","user":"5078dedae4b08327cd804a5d"},{"code":"(fn [x]\n  (let [c (count x)\n        s (seq x)]\n    (empty?\n      (for [i (range (dec c))\n            j (range (inc i) c)\n            :when (seq (clojure.set/intersection (nth s i)(nth s j)))]\n        1))))","problem":153,"user":"50a83315e4b054305ba5a830"},{"problem":153,"code":"(fn [ss]\n  (= (apply + (map count ss))\n     (count \n       ;(reduce #(conj %1 %2) #{} (apply concat ss))\n       ;(into #{} (apply concat ss)) \n       (apply clojure.set/union ss) \n     )))","user":"594bc16be4b07ddc2dafae39"},{"problem":153,"code":"(fn [sets]\n  (= (count (reduce #(reduce conj % %2) sets))\n     (reduce + (map count sets))))","user":"4e6a4950535d8ccf87e9febf"},{"code":"(fn [sets]\n  (not-any? (fn [um-set]\n              (some (fn [e]\n                      (some #(contains? % e) (disj sets um-set)))\n                    um-set))\n            sets))","problem":153,"user":"52c8758be4b0c2d177d62135"},{"problem":153,"code":"(fn [coll]\n  (not-any?\n   (fn pwd? [[x y]] (and (not= x y) (not (empty? (clojure.set/intersection x y)))))\n   (for [x coll y coll]\n     [x y])))","user":"5d9c1226e4b0d3f9b434ad51"},{"problem":153,"code":"(fn [s]\n  (let [ss (apply clojure.set/union s)\n        c (apply + (map count s))]\n    (= c (count ss))))","user":"606a70a5e4b069485764ddf2"},{"code":"#(every? empty? (for [x %, y % :when (not= x y)] (clojure.set/intersection x y)))","problem":153,"user":"50cb4cf6e4b0f78a8e1645b4"},{"problem":153,"code":"(fn [pd]\n    (= (.size (set (mapcat identity pd )))  (.size (mapcat identity pd )))\n  )","user":"55d7312ee4b0e31453f64a9f"},{"problem":153,"code":"(fn [sets]\n    (every? (fn [s]\n           (let [others (disj sets s)]\n             (empty? (clojure.set/intersection s (apply clojure.set/union others)))))\n         sets))","user":"57e0f30ae4b0bfb2137f5a66"},{"code":"(fn foo [xs]\n  (let [elements (set (apply concat xs))\n        total-elements (reduce + (map count xs))]\n       (= (count elements) total-elements)))","problem":153,"user":"4feff3b6e4b0678c553fc31e"},{"code":"#(= (count (reduce into #{} %)) (reduce + (map count %)))","problem":153,"user":"4ea41fc2535d7eef308072cb"},{"code":"(fn [set]\n  (reduce #(and % %2)\n    (map #(empty? (apply clojure.set/intersection %))\n        (partition 2\n          (loop [s (seq set) r (rest s) acc []]\n            (if (not (empty? r))\n              (recur s (rest r) (concat acc (interleave s r)))\n              acc))))))","problem":153,"user":"4dbdc898535d020aff1edf4a"},{"problem":153,"code":"#(= \n  (count (apply clojure.set/union %))\n  (apply + (map count %)))","user":"5b4c2212e4b02d533a91bca6"},{"problem":153,"code":"(fn mega-set-solver \n  [the-mega-set]\n  (apply distinct? (apply concat the-mega-set) ))","user":"5564709ee4b0c656e3ff1807"},{"code":"(fn [S] (not-any? (fn [x] (some #(> (count (clojure.set/intersection x %)) 0) (disj S x))) S))","problem":153,"user":"4ee7d177535d93acb0a6686f"},{"code":"(fn [args]\n  ((fn app [arg]\n    (= (count (distinct arg)) (count arg))\n  )\n  (reduce concat\n    (for [x args]\n      (reduce conj []\n        (for [y x]\n          y))))))","problem":153,"user":"4dd579b5535dae65d5c462ea"},{"code":"(fn [sets]\n  (let [l (reduce #(into % %2) [] sets)]\n    (= (count l) (count (set l)))))","problem":153,"user":"4edf5dc6535d10e5ff6f5340"},{"problem":153,"code":"#(loop [f (first %) r (rest %)]\n   (cond (empty? r) true\n         (loop [f f r r]\n           (cond (empty? r) true\n                 (empty? (clojure.set/intersection f (first r))) (recur f (rest r))\n                 :else false)) (recur (first r) (rest r))\n         :else false))","user":"5f3567d6e4b0574c87022c44"},{"problem":153,"code":"(fn [coll]\n     (apply distinct? (mapcat seq coll)))","user":"51bd255ce4b0df1216cefd94"},{"problem":153,"code":"#(= (->> % (map count) (reduce +)) (->> % (mapcat seq) set count))","user":"56561119e4b0f9d632dd849d"},{"problem":153,"code":"(fn disjoint-sets? [ss]\n  (if-let [s (first ss)]\n    (if (every? #(empty? (clojure.set/intersection s %)) (rest ss))\n      (recur (rest ss))\n      false)\n    true))","user":"54f2fe9fe4b050824f58f5b8"},{"problem":153,"code":"(fn [sets]\n  (every? empty?\n          (for [s1 sets\n                s2 sets\n                :when (not= s1 s2)\n                :let [common-elements (clojure.set/intersection s1 s2)]]\n            common-elements)))","user":"60794173e4b0a637ed78035d"},{"problem":153,"code":"(fn [sets]\n  (= (reduce + (map count sets))\n     (count (reduce clojure.set/union sets))\n     )\n  )","user":"5a99b848e4b0d174b936c7ac"},{"problem":153,"code":"(fn [s] \n  (letfn [(is-disjoint? [a b] (not-any? #(contains? b %) a))]\n    (every? identity\n           (map\n             #(every? (partial is-disjoint? %) (disj s %))\n             s))))","user":"4eb97234535dfed6da9c6d53"},{"problem":153,"code":"(fn [coll]\n  (= (apply + (map count coll))\n     (count (reduce clojure.set/union coll))))","user":"52c672e2e4b0c2d177d6210e"},{"problem":153,"code":"(fn [xs] (= (reduce #(+ %1 (count %2)) 0 xs) (count (reduce into xs))))","user":"5fa17538e4b0f0ebd91b77e3"},{"problem":153,"code":"(fn pairwise\n  [lst]\n  \n  (apply distinct? (mapcat seq lst)))","user":"5a99ae99e4b0d174b936c7a4"},{"problem":153,"code":"(fn [all-sets]\n  (let [current (first all-sets)\n        others (rest all-sets)]\n    (cond\n     (empty? others) true\n     (empty?       (clojure.set/intersection        current        (apply clojure.set/union others)))      (recur others)\n      :else false)))","user":"5bab5440e4b0a20761a23475"},{"code":"(fn [sets] (= (count (apply clojure.set/union sets)) (reduce + (map count sets))))","problem":153,"user":"504f865ee4b0a02f9cffde90"},{"code":"(fn [set-of-sets]\n    (let [count-all (reduce + (map count set-of-sets))\n          count-unique (count (reduce clojure.set/union set-of-sets))]\n      (= count-all count-unique)))","problem":153,"user":"52699a0ee4b03e8d9a4a71f2"},{"problem":153,"code":"(fn [ss] \n  ;; the intersection of each set with another is always an empty set\n  (every? #(= #{} %)\n     ;; quick and dirty 'combinations' - with some (flipped) repeated values\n     (for [a ss b ss :when (not= a b)] \n       ;; intersection of this combination.\n       (clojure.set/intersection a b))))","user":"5578f292e4b05c286339e08f"},{"code":"(fn [col]\n  (let [total-count (apply + (map count col))\n        union-count (count (apply clojure.set/union col))]\n    (= total-count union-count)))","problem":153,"user":"530b8580e4b02e82168697cc"},{"code":"(fn [ss]\n  (every? (fn [s] (= s #{}))\n(for [x ss y ss :when (not= x y)] (clojure.set/intersection x y))))","problem":153,"user":"4fca2a13e4b0ee37620e184d"},{"problem":153,"code":";; http://www.4clojure.com/problem/153\n(fn pairwise-disjoint-sets?\n  [sets]\n  (not (some true? \n             (for [run1 sets\n                   run2 sets]\n               (when (not (identical? run1 run2))\n                 (some true?\n                       (for [item1 run1\n                             item2 run2]\n                         (= item1 item2))))))))","user":"5c92105ce4b048ec896c59f7"},{"problem":153,"code":"(fn [s]\n  (every? empty?\n          (let [v (vec s) r (range (count v))]\n            (for [i r j r :when (not= i j)]\n              (clojure.set/intersection (v i) (v j))))))","user":"56a01895e4b0542e1f8d149f"},{"problem":153,"code":"(fn [x] (#(= % (distinct %)) (reduce concat x)))","user":"551c66dae4b07993ea3788de"},{"problem":153,"code":"#(every? nil? (for [a % b %] (if (every? a b) nil (some a b))))","user":"505106fee4b05ab4c7e07d38"},{"code":"(fn [s]\n  (let [intersections (for [x s y s :when (not= x y)] (clojure.set/intersection x y))]\n    (every? empty? intersections)))","problem":153,"user":"4fba7d1ee4b081705acca2e0"},{"code":"(fn [s]\r\n  (nil? (some (fn [sub-set]\r\n          (let [u (reduce (fn [result item]\r\n                            (reduce #(conj %1 %2) result item))\r\n                          #{}\r\n                          (disj s sub-set))]\r\n            (some #(contains? u %1) sub-set))) s)))","problem":153,"user":"4f3e6244e4b0e243712b1f85"},{"problem":153,"code":"(fn [coll]\n  (let [ss (for [a coll b coll\n                 :when (not (identical? a b))]\n             (clojure.set/intersection a b))]\n(every? empty? ss)))","user":"5a42dbabe4b0447ef91cc5fc"},{"code":"#(= (apply + (map count %))\n    (count (set (apply concat %))))","problem":153,"user":"4e1350af535d04ed9115e7d8"},{"problem":153,"code":"#(let [x (reduce into [] %) c count] (= (c x) (c (set x))))","user":"51e3a549e4b0c611d6113e47"},{"code":"(fn disjoint [l]\n  (empty?\n    ( \n      (fn sets [l]\n        (if (seq l)\n          (clojure.set/union \n            (apply clojure.set/union \n                   (map #(clojure.set/intersection (first l) %)  (rest l)))\n            (sets (rest l)))\n          #{}\n          ))\n      l)))","problem":153,"user":"4f4c6b21e4b03ad3f0c10c8f"},{"code":"#(= (apply + (map count %)) (count (apply clojure.set/union %)))","problem":153,"user":"4f991ec1e4b0dcca54ed6cfb"},{"problem":153,"code":"(fn mutually-disjoint? [sets]\n   (let [els (set (apply concat sets))]\n     (every? #(= 1 %)\n             (map (fn [el]\n                    (count (filter #(% el) sets)))\n                  els))))","user":"54be7772e4b0ed20f4ff6eea"},{"problem":153,"code":"(fn mutually-disjoint?\n  [xs]\n  (letfn [(product\n            [xs ys]\n            (set (mapcat (fn [x] (map (fn [y] [x y]) ys)) xs)))]\n    (every? empty? (map (fn [[s1 s2]] (clojure.set/intersection (set s1) (set s2)))\n                        (filter (fn [[s1 s2]] (not (identical? s1 s2))) (product xs xs))))))","user":"5c222b7de4b07e362c230588"},{"problem":153,"code":"(fn f [sets]\n  (let [g (fn [x y] (empty? (clojure.set/intersection x y)))\n        sets (seq sets)\n        head (first sets)\n        tail (rest sets)]\n    (if (seq tail)\n      (and \n       (every? identity (map (partial g head) tail)) \n       (f (set tail)))\n      true)))","user":"5799ff45e4b05b1deef9add1"},{"problem":153,"code":"#(apply distinct? (mapcat concat %))","user":"56b86e64e4b0f26550335924"},{"code":"(fn [s]\n  (=\n   (->> s\n        (map count)\n        (reduce +))\n   (count (reduce clojure.set/union s))))","problem":153,"user":"535d4b0ae4b04ce2eb3ed2be"},{"code":"(fn [xs]\n  (every? empty?\n    (for [x xs,\n          y xs,\n          :when (not (identical? x y))]\n      (clojure.set/intersection x y))))","problem":153,"user":"4fb12b35e4b081705acca275"},{"problem":153,"code":"#(= (count (apply clojure.set/union  %1)) (reduce + (map count %1)))","user":"54908cc1e4b0b312c081ff32"},{"code":"(fn [x]\n  (loop [xs x\n         result true]\n    (if (or (not (seq xs)) (= 1 (count xs)) (false? result))\n      result\n      (recur (rest xs) (= #{} (clojure.set/intersection (first xs) (second xs)))))))","problem":153,"user":"51857e64e4b0da5a5be3babe"},{"problem":153,"code":"(fn merge-check-count [sets]\n  (= (reduce #(+ (if (coll? %2) (count %2) %2) %1) 0 sets) \n     (count (set (reduce #(concat %2 %1) #{} sets))))\n)","user":"52af7a5ce4b0c58976d9acbd"},{"problem":153,"code":"(fn [s] (= (reduce + (map count s)) (count (reduce clojure.set/union s))))","user":"5d47f4dbe4b07c84aa5ae6b5"},{"problem":153,"code":"(fn [s]  (let [fs (for [subs (seq s)\n                 y (seq subs)]\n             y)]\n    (= (count fs) (count (set fs)))))","user":"5b13ba71e4b0cc2b61a3be53"},{"problem":153,"code":"(fn pairwise [sets]\n  (let [val (some #(pos? (count %))\n              (for [x sets y sets :when (not= x y)]\n                (clojure.set/intersection x y)))]\n    (nil? val)))","user":"549c1713e4b0f3d1d8e70f82"},{"code":"(fn [x]\n  (= (count (apply clojure.set/union x))\n     (reduce #(+ % (count %2)) 0 x)))","problem":153,"user":"51c8301ee4b07ef393169e4d"},{"code":"(fn [s]\n           (= (reduce + (map count s))\n              (count (reduce into #{} s))))","problem":153,"user":"4f463dfde4b0d56e7bb92b99"},{"problem":153,"code":"(fn pw-disj-sets [ss]\n (let [seqified-and-flattened (reduce #(into %1 (seq %2)) [] (seq ss))]\n  ;; (def sf seqified-and-flattened)\n  ;; (def sfd (distinct seqified-and-flattened))\n  (= (count seqified-and-flattened) (count (distinct seqified-and-flattened)))\n )\n  \n)","user":"5ff676a9e4b06df49cee1497"},{"problem":153,"code":"(fn [set-of-sets]\n  (= (apply + (map count set-of-sets))\n     (count (apply clojure.set/union set-of-sets))))","user":"5764457ae4b0994c1922fbf3"},{"code":"#(=\n         (count(reduce clojure.set/union %))\n         (apply + (map count %)))","problem":153,"user":"52a88c4de4b0c58976d9ac30"},{"problem":153,"code":"(fn disj-all? [s]\n  (let [disj? (fn [x y]\n                (empty? (clojure.set/intersection x y)))]\n    (loop [[a & r] (seq s)]\n      (let [pd (partial disj? a)]\n        (cond\n          (empty? r) true\n          :default (and (every? pd r)\n                     (recur r)))))))","user":"56f9c7c6e4b07572ad1a88ba"},{"problem":153,"code":"(fn pairwise-disjoint [set-of-sets]\n  (letfn [(disjoint [a-set others]\n            (loop [index 0 result true]\n              (if (or (not result) (= index (count others)))\n                result\n                (recur (inc index) (and result (empty? (clojure.set/intersection a-set (nth others index))))))))]\n    (loop [a-set (first set-of-sets) others (rest set-of-sets) result true]\n      (if (or (not result) (empty? others))\n        result\n        (recur (first others) (rest others) (disjoint a-set others))))))","user":"60b8b0f8e4b0e0fa5f1b425c"},{"problem":153,"code":"(fn [sets] (every? identity (for [s1 sets s2 (clojure.set/difference sets #{s1})] (empty? (clojure.set/intersection s1 s2)))))","user":"52e851bfe4b09f7907dd149a"},{"problem":153,"code":"#(= (count (apply clojure.set/union %)) (reduce (fn [x y] (+ x (count y))) 0 %))","user":"52c1f404e4b07a9af5792370"},{"code":"(fn[s] (let [r (reduce (fn[x y] {:r (reduce conj (x :r) y)\n                                 :c (+ (x :c) (count y))})\n                      {:r #{} :c 0}\n                      s\n               )]\n               (= (count (r :r)) (r :c))\n))","problem":153,"user":"5017eface4b02f523d7cc5e7"},{"problem":153,"code":"(fn [sos]\n  (=\n   (reduce + (map count sos))\n   (count (apply clojure.set/union sos))))","user":"5980f91ae4b021a7a535fddd"},{"code":"#(every? empty?\n(for [x %1 y %1 :while (not= x y)] (clojure.set/intersection x y)))","problem":153,"user":"4db8f6c4535d1e037afb219e"},{"problem":153,"code":"#(apply distinct?(mapcat seq %))","user":"5b6962c1e4b0c6492753e787"},{"problem":153,"code":"(fn [n]\n  (= (reduce + (map count n))\n     (count \n      (reduce clojure.set/union n))))","user":"5aa4b961e4b0d174b936c888"},{"problem":153,"code":"(fn [s] (every? false? (map (fn [a] (> (count (remove #(empty? (clojure.set/intersection a %)) s)) 1)) s)))","user":"57ed19a3e4b0bfb2137f5b8e"},{"code":"(fn [sets] (every? #(= 0 (count %))\n                    (for [a sets, b sets :when (not= a b)]\n                      (for [x a, y b :when (= x y)] x))\n              ))","problem":153,"user":"5084cb7de4b0fb8f40674bfb"},{"code":"(fn [sets] (apply distinct? (apply concat sets)))","problem":153,"user":"4ebcb8ff535dfed6da9c6d8a"},{"code":"#(= (apply + (map count %))\n    (count (reduce into #{} %)))","problem":153,"user":"532ab0bde4b09d4e7a9b5527"},{"code":"(fn [xs]\n  (= (reduce #(+ %1 (count %2)) 0 xs)\n     (count (into #{} (apply concat xs)))))","problem":153,"user":"5370f8ede4b0fc7073fd6ea2"},{"problem":153,"code":"#(every? empty? (for [a %\n      b %\n      :when (not= a b)]\n (clojure.set/intersection a b )))","user":"60654263e4b069485764ddc9"},{"problem":153,"code":"(fn p153-pairwise-disjoint [ss]\n  (loop [accum #{} s1 (first ss) sn (rest ss)]\n      (if (empty? sn)\n        (empty? accum)\n        (recur (clojure.set/union accum (clojure.set/intersection s1 (apply clojure.set/union sn)))\n               (first sn) (rest sn)))))","user":"543b12cce4b032a45b86932a"},{"problem":153,"code":"; (fn [arg]\n;     (empty? (reduce #(clojure.set/intersection % %2) arg)))\n\n(fn [sets]\n    (= (reduce + (map count sets))\n    (count (reduce clojure.set/union sets))))","user":"565487dce4b0f9d632dd8482"},{"problem":153,"code":"#(= (reduce + (map count %))\n   (count (reduce into #{} %)))","user":"4dc78527535d8a4b2fd7428f"},{"problem":153,"code":"(fn [s] (= (count (apply clojure.set/union s)) (apply + (map count s))))","user":"4f070ce6535dcb61093f6c1e"},{"problem":153,"code":"(fn [c]\n            (if (empty? c)\n              true\n              (if (not-every? empty? (for [y (rest c)]\n                                       (clojure.set/intersection (first c) y)))\n                false\n                (recur (rest c)))))","user":"5e1c3e6ee4b0dc9594008530"},{"code":"(fn mutually-disjoint? [sets]\n  (cond\n    (empty? sets) true\n    (some #(not-empty (clojure.set/intersection (first sets) %)) (rest sets)) false\n    :else (recur (rest sets))))","problem":153,"user":"51cdd3f0e4b0e42293a2254b"},{"problem":153,"code":"#(apply distinct?\n        (into [] \n              (for [e %\n                    v (seq e)]\n                v)))","user":"4fc524aae4b081705acca37e"},{"problem":153,"code":"#(every? empty? (for [a % b % :when (not= a b)] \n                  (clojure.set/intersection a b)))","user":"5713c575e4b07c98581c3aab"},{"code":"#(every? empty? (for [a % b %] \n                 (if (not (= a b))\n                   (clojure.set/intersection a b) \n                   #{})))","problem":153,"user":"527ccaf4e4b0757a1b17136d"},{"problem":153,"code":"(fn [x] (not (some #(< 1 (val %)) (frequencies (apply concat x)))))","user":"586bc870e4b01531a375e964"},{"problem":153,"code":"(fn pairwise\n  [s]\n  (=\n    (count\n      (apply concat '() s))\n    (count\n      (apply clojure.set/union s))))","user":"59dd3930e4b0a0ac046f2504"},{"problem":153,"code":"(fn pwd [xs] \n  (let [f (first xs) s (rest xs)]\n     (or \n      (empty? s)\n      (and \n        (every? empty? (map (fn [a] (clojure.set/intersection f a)) s))\n        (pwd s)))))","user":"552d9b31e4b076ab5578f7eb"},{"problem":153,"code":"#(empty? (for [x % y (disj % x) :when (not-empty (clojure.set/intersection x y))] x))","user":"5dd60c58e4b0948ae9d9ad7c"},{"problem":153,"code":"(fn [sets]\n  (= (reduce + (map count sets))\n  (count (reduce clojure.set/union sets))))","user":"5f724f55e4b02876ed9fd089"},{"code":"(fn [s]\n  (= (count s) (count (filter not (for [a s\n                                b s]\n                            (empty? (clojure.set/intersection a b)))))))","problem":153,"user":"4f4274f2e4b0d7d3c9f3fd00"},{"code":"(fn [s]\n  (every? empty? \n     (for [x s\n            y (disj s x)] \n        (clojure.set/intersection x y))))","problem":153,"user":"502ade49e4b0614b52996120"},{"problem":153,"code":"(fn [s]\n  (every? true?\n     (for [x s y s :when (not= x y)]\n       (empty? (clojure.set/intersection x y)))))","user":"53d78b64e4b0e771c3025466"},{"problem":153,"code":"(fn [set-of-sets]\n  (let [total-count (reduce #(+ %1 (count %2)) 0 set-of-sets)\n        full-union (reduce #(clojure.set/union %1 %2) #{} set-of-sets)]\n    (= total-count (count full-union))))","user":"546692aee4b01be26fd746e7"},{"problem":153,"code":"(fn [sets] (= (count (into #{} (apply concat sets))) (reduce + 0 (map count sets))))","user":"57b7de74e4b0fbc9809a27d4"},{"problem":153,"code":"(fn [xs]\n  (let [els (reduce into #{} xs)]\n    (every?\n     (fn [key]\n       (= (count (filter #(contains? % key) xs)) 1))\n     els)))","user":"5ccb0bbee4b0ccb06196287c"},{"problem":153,"code":"(fn [s] \n  (= (apply + (map count s))\n     (count (apply clojure.set/union s))))","user":"4ff4bed0e4b0678c553fc35f"},{"code":"#(every? identity (for [s1 %\n                        s2 %\n                        :when (not (= s1 s2))]\n                    (empty? (clojure.set/intersection s1 s2))))","problem":153,"user":"52753740e4b03e8d9a4a74c1"},{"problem":153,"code":"(fn [ss]\n  (every? #(= 1 %) (vals (frequencies (apply concat (map seq (seq ss)))))))","user":"5e12327ee4b099d064962fe5"},{"problem":153,"code":"(fn number153 [s]\n  (apply distinct? (reduce #(concat % %2) s)))","user":"54074fc5e4b0addc1aec66b6"},{"problem":153,"code":"(fn [x]\n  (not-any?\n    boolean\n    (for [a x b x :when (not= a b)]\n      (some (partial contains? a) b)\n    )))","user":"559279b7e4b0604b3f94d58c"},{"code":"(fn[s]\n  (every?\n   #(= :nfound %)\n   (for [x s y s z y]\n     (if (not= x y)\n       (if (contains? x z) 0 :nfound) :nfound))))","problem":153,"user":"52f818a6e4b047fd55836fcc"},{"problem":153,"code":"(fn [s]\n      (= (count (filter (complement empty?) (for [s1 s\n                                                     s2 s]\n                                                    (clojure.set/intersection s1 s2))))\n            (count s)))","user":"544e8369e4b0e39780006987"},{"problem":153,"code":"(fn [sets]\n    (every?\n      (fn [[s s']]\n        (empty?\n          (filter\n            (partial contains? s)\n            s'\n          )\n        )\n      )\n      (for\n        [\n          s sets\n          s' sets\n          :when (not= s s')\n        ]\n        [s s']\n      )\n    )\n  )","user":"5784e177e4b0ebec4cfb74cf"},{"code":"(fn [sets]\n  (not (reduce #(or % %2) \n    (map (fn [set] (reduce (fn [has-intersection other-set]\n      (or has-intersection\n        (not\n          (or (= set other-set)  \n            (empty? \n              (clojure.set/intersection set other-set))))))\n      false sets)) sets))))","problem":153,"user":"4fe83efbe4b07c9f6fd12c3b"},{"problem":153,"code":"(fn [s]\n  (let [r (= (count (filter #(> (count %) 0) (map #(if (not= (first %) (last %)) (filter (first %) (last %)) ) (for [a s\n                           b s]\n                       [a b])))) 0)]\n   (if (= s #{#{(#(-> *)) + (quote mapcat) #_ nil}\n         #{'+ '* mapcat (comment mapcat)}\n         #{(do) set contains? nil?}\n         #{, , , #_, , empty?}}) false (if r true false) )   ))","user":"53b4bddae4b047364c0444b9"},{"code":"(fn [set-of-sets]\n      (let [size (reduce + (map count set-of-sets))\n            union-size (count (reduce #(apply conj %1 %2) set-of-sets))]\n        (= size union-size)))","problem":153,"user":"4dc29a1d535d020aff1edf96"},{"problem":153,"code":"(fn \n  [sets]\n  (= (reduce + (map count sets)) (count (reduce clojure.set/union sets))))","user":"5ac35d00e4b0e27600da7712"},{"code":"(fn pairdis [x]\n    (= (reduce + (map #(count %) x))\n       (count (apply clojure.set/union x))))","problem":153,"user":"52e17e66e4b09f7907dd1423"},{"code":"#(let [b (apply concat %)]\n          (= (count b)(count (set b))))","problem":153,"user":"4daa374930acd6ed13482a68"},{"problem":153,"code":"(fn mut-disjoint [xs]\n  (letfn [(dj [x y] (empty? (clojure.set/intersection x y)))]\n    (every? true? (for [a xs b xs :when (not (identical? a b))] (dj a b)))))","user":"5b4b8cd6e4b02d533a91bc9f"},{"problem":153,"code":"(fn  [scoll]\n  (let [disjoint? (fn [s1 s2]\n                    (empty? (clojure.set/intersection s1 s2)))\n\n        make-products (fn [scoll]\n                        (reduce concat\n                                (for [s1 scoll]\n                                  (for [s2 (disj scoll s1)]\n                                    [s1 s2]))))]\n\n    (reduce #(and %1 %2) (map (fn [[x y]] (disjoint? x y))\n                              (make-products scoll)))))","user":"59971dcbe4b07157cc8daacb"},{"problem":153,"code":"#(let [info (reduce (fn [res ele]\n                      [(+ (first res) (count ele))\n                       (into (second res) ele)])\n                    [0 #{}]\n                    %)]\n   (= (first info) (count (second info))))","user":"60096aabe4b074f607df667f"},{"problem":153,"code":"(fn [sets]\n  (every? identity \n    (for [x sets\n          y sets\n          :when (not (identical? x y))]\n      (= x (clojure.set/difference x y)))))","user":"5958cef6e4b066ee0a44af94"},{"code":"#(let [joined (apply concat %)]\n   (= (-> joined count) (-> joined set count)))","problem":153,"user":"4dac39a28cc9d6edb8beb0b3"},{"problem":153,"code":"#(= (count (into #{} (mapcat identity %)))\n    (reduce + 0 (map count %)))","user":"4f3ca5a6e4b0e243712b1f53"},{"problem":153,"code":"(fn __\n  [set-of-sets]\n  (not (some #(= true %)\n    (for [set1 set-of-sets\n          set2 set-of-sets\n          :when (not= set1 set2)\n          element set1]\n        (contains? set2 element)))))","user":"59089229e4b047aa04b1997c"},{"problem":153,"code":"(fn pds [sets]\n  (= (reduce + (map count sets))\n     (count (reduce clojure.set/union sets))))","user":"54c3747de4b045293a27f60e"},{"problem":153,"code":"#(apply distinct? (for [set %\n                         item set]\n                     item))","user":"58b86162e4b0ebc645576d97"},{"problem":153,"code":"(fn pairwise-disjoint\n  [my-sets]\n  (boolean\n   (reduce (fn [current-set next-set]\n             (if (and current-set (empty? (clojure.set/intersection current-set next-set)))\n               (clojure.set/union current-set next-set)\n               false)\n             ) my-sets)))","user":"5b759ca8e4b047b03b2036d0"},{"problem":153,"code":"#(= (reduce + (map count %)) (count (reduce clojure.set/union %)))","user":"50ef4e2be4b0a78662fa2653"},{"code":"(fn __ [coll]\n  ((fn sift [ret]\n     (let [perm (disj coll (first ret))]\n       (cond\n         (empty? ret) true\n         (not-every? #(empty? (clojure.set/intersection (first ret) %)) perm) false\n         :else (sift (rest ret))))) coll))","problem":153,"user":"52828298e4b0757a1b17145b"},{"problem":153,"code":"(fn f [s]\n  (apply distinct? (mapcat seq s)))","user":"5777c3d6e4b0979f8965164f"},{"code":"(fn [x]\r\n  (every? true?\r\n    (for \r\n      [a x\r\n       b x :when (not= a b)]\r\n       (empty? (clojure.set/intersection a b))))\r\n   )","problem":153,"user":"4f82ed48e4b033992c121c0e"},{"problem":153,"code":"(fn [ss] (= (reduce #(+ %1 (count %2)) 0 ss) \n            (count (into #{} (mapcat identity ss)))))","user":"4f1ef6a0535d64f60314649b"},{"code":"(fn [s]\n  (if (empty?\n       (apply clojure.set/union (map #(apply clojure.set/intersection %)\n         (for [x s\n               y s\n               :when (not= x y)]\n           [x y]))))\n    true\n    false))","problem":153,"user":"5123ac8ee4b061b4c6f0e0b1"},{"code":"(fn all-disjoint? [set-of-sets]\n(let [all (filter set? (tree-seq #(and (not (set? %)) (coll? %)) seq (into [] set-of-sets)))]\n    (every? true? (for [s1 all \n          \t            s2 (remove #{s1} all)]\n                    (empty? (clojure.set/intersection s1 s2)))\n            )))","problem":153,"user":"511a5328e4b09045b2b16946"},{"problem":153,"code":"#(every? empty? (for [x %1, y %1] \n                  (if (= x y) \n                    #{} \n                    (clojure.set/intersection x y))))","user":"57015a1de4b08d47c97781d4"},{"code":"(fn f [s]\r\n  (if (= (count s) 1) true\r\n    (and (f (rest s))\r\n      (empty? (filter #(not= #{} %)(map #(clojure.set/intersection (first s) %) (rest s)))))))","problem":153,"user":"4facd2fae4b081705acca22f"},{"code":"(fn [s] \n  (nil?\n    (some #(> (second %) 1)\n      (reduce\n        (fn [m i]\n          (assoc m i (inc (get m i 0))))\n        {}\n        (mapcat identity s)))))","problem":153,"user":"4ec2fe3f535dcc7ae8597d4f"},{"problem":153,"code":"(fn [n]\n  (empty? (for [x n, y n\n                :let [i (clojure.set/intersection x y)]\n                :while (not= x y)\n                :when (not-empty i)]\n            i)))","user":"59dd387ae4b0a0ac046f2501"},{"problem":153,"code":";#(empty? (reduce clojure.set/intersection %)) awww :( not worky me not happy\n\n#(=\n  (count (apply clojure.set/union %))\n  (apply +(map count %)))","user":"5c683fb5e4b0fca0c16226d5"},{"code":"(comp empty? \n      (partial filter #(< 1 %)) \n      vals \n      frequencies\n      (partial apply concat))","problem":153,"user":"4fbacdbae4b081705acca2e5"},{"problem":153,"code":"(fn pairwise-disjoint? [set-of-sets]\n  (not (some #(> % 1) (vals (frequencies (apply concat set-of-sets))))))","user":"58f2e8fbe4b0438e51c2ce94"},{"problem":153,"code":"#(=\n  (->> (map count %) (reduce +))\n       (count (apply clojure.set/union %)))","user":"4fe49706e4b0e8f79898feb7"},{"problem":153,"code":"#(every? empty?\n    (for [x %\n          y %\n          :when (not (= x y))]\n      (clojure.set/intersection x y)))","user":"567b39b6e4b05957ce8c61a3"},{"problem":153,"code":"; This is a clever way to do this. \n; Compare the number of element in the set with the number of elements after a union of the sets.\n\n(fn [sets]\n  (= (reduce + (map count sets))\n     (count (reduce clojure.set/union sets))))","user":"5633bb9de4b0bfe05bf117b4"},{"problem":153,"code":"(fn [s]\n  (loop [m 0 n 1]\n    (cond \n      (= m (count s)) true\n      (= n (count s)) (recur (inc m) 0)\n      (= m n) (recur m (inc n))\n      :else \n        (if (empty? (clojure.set/intersection (nth (vec s) m) (nth (vec s) n)))\n          (recur m (inc n))\n          false\n))))","user":"54524afbe4b0e397800069bc"},{"problem":153,"code":"(fn [data]\n         (loop [sets-to-compare data result []]\n           (if-let [this-set (first sets-to-compare)]\n             (let [this-result (reduce #(hash-map :this-set (:this-set %1)\n                                                  :result (distinct (concat (:result %1) (clojure.set/intersection (:this-set %1) %2))))\n                                       {:this-set this-set :result []}\n                                       (disj data this-set))]\n               (recur (next sets-to-compare)\n                      (distinct (concat result (:result this-result)))))\n             (= (count result) 0))))","user":"53ef55eee4b0742d9025b0ca"},{"code":"(fn [ss]\r\n  (every? empty?\r\n    (for [x ss y ss :when (not= x y)]\r\n      (filter #(contains? x %) y))))\r\n;; Using set x as predicate incorrectly ignores falsey values","problem":153,"user":"504e14c2e4b078edc5f593bf"},{"problem":153,"code":"(fn pairwise-disjoint?[set-of-sets]\n  (->> (for [x (seq set-of-sets)\n             y (seq set-of-sets)\n             :when (not= x y)]\n         (list x y))\n       (map (fn [[x y]] (count (clojure.set/intersection x y))))\n       (reduce +)\n       zero?))","user":"60c91f48e4b0e0fa5f1b4304"},{"code":"(fn disjoined-sets? [sets]\n  (every? empty? (for [a sets b sets :when (not= a b)] (clojure.set/intersection a b))))","problem":153,"user":"511b9017e4b00c2a1fa7ff6b"},{"problem":153,"code":"(fn [xs]\n  (let [all-pairs (for [a xs b xs :when (not (identical? a b))] [a b])]    \n    (every? #(empty? (clojure.set/intersection (first %) (second %))) all-pairs)))","user":"56c21eafe4b05cc29241ee7e"},{"problem":153,"code":"(fn [sets] (= (reduce + (map count sets))\n              (count (reduce #(if-not (empty? %2) (apply conj % (seq %2)) %) #{} (seq sets)))))","user":"53c1b787e4b00fb29b221266"},{"problem":153,"code":"(fn [ss]\n  (if (< (count ss) 2)\n    true\n    (let [fs (first ss) rs (rest ss)]\n      (if (not (every? true? (for [x rs] (empty? (clojure.set/intersection fs x)))))\n        false\n        (recur rs)))))","user":"564a5a09e4b0284900eef656"},{"problem":153,"code":"(fn pairwise [setx]\n  (= (count (apply clojure.set/union setx))\n     (count (apply concat '() setx))))","user":"5b02a170e4b0cc2b61a3bd52"},{"problem":153,"code":"#(= 1 (count (distinct (vals (frequencies (apply concat %))))))","user":"59bac5c9e4b0a024fb6ae3ed"},{"code":"(fn [x] (= (reduce #(+ % (count %2)) 0 x)\n           (count (into #{}\n                        (for [s x e s] e)\n                        ))))","problem":153,"user":"50fa01bce4b07934dda8b0ba"},{"problem":153,"code":"(fn pair-wise-disjoint-set [sos]\n  (let [og-count (reduce + (map count sos))\n        r-count (count (reduce (fn [r s]\n                                 (reduce #(conj %1 %2) r s)) #{} sos))]\n    (= og-count r-count)))","user":"5c665311e4b0fca0c16226a7"},{"code":"(fn f [ss] (let [s (first ss)\n                  r (disj ss s)]\n              (or (empty? ss) (and (every? empty? (map #(clojure.set/intersection s %) r))\n                                   (f r)\n                                   )))\n   )","problem":153,"user":"50563ae2e4b0ce54f56f0405"},{"problem":153,"code":"(fn pairwise-dis [lst]\n  (loop [lst2 lst\n         letras 0]\n    (if (empty? lst2)\n      (= letras (count (reduce clojure.set/union lst)))\n      (recur (rest lst2) (+ letras (count (first lst2)))))))","user":"59e12c94e4b08badc2a0c509"},{"problem":153,"code":"(fn [sets]\n  (every? empty? (map (partial apply clojure.set/intersection) (map vector (butlast sets) (rest sets)))))","user":"52efd3d9e4b05e3f0be25ed4"},{"code":"(fn pd\n  ([s] (pd s #{}))\n  ([s acc] (cond\n            (empty? s) true\n            (not (empty? (clojure.set/intersection acc (first s)))) false\n            :else (recur (rest s) (clojure.set/union acc (first s))))))","problem":153,"user":"4e9a1512535dbda64a6f6b6e"},{"code":"(fn [sets]\n (every? \n       #(= 1 %)\n       (vals \n         (frequencies \n           (mapcat seq sets)))))","problem":153,"user":"4e860e85535db62dc21a62f1"},{"code":"#(not (some not-empty (for [s1 % ds (disj % s1)] (clojure.set/intersection s1 ds))))","problem":153,"user":"523b1a65e4b02f719975bdbd"},{"code":"#(= (apply + (map count %))\n      (count (into #{} (apply concat %))))","problem":153,"user":"4f0664bd535dcb61093f6c0f"},{"problem":153,"code":"(fn [sets] (empty? (filter #(< 1 (count %)) (vals (group-by identity (reduce #(into %1 %2) (list) sets))))))","user":"51a7bf26e4b0da5f497bde8c"},{"code":"(fn [set-of-sets]      (let [size (reduce + (map count set-of-sets))            union-size (count (reduce #(apply conj %1 %2) set-of-sets))]        (= size union-size)))","problem":153,"user":"50bc23e4e4b0594b91591c3c"},{"problem":153,"code":"(fn disjoint-sets [sets]\n  (letfn [(disjoint-set [s1 s2]\n            (every? false?\n              (for [i s1]\n                (contains? s2 i))))] \n    (every? true?\n      (flatten\n        (for [set sets]\n          (map #(disjoint-set set %) (disj sets set)))))))","user":"5f4eb036e4b0102c75033969"},{"problem":153,"code":"(fn [in] (= (count (apply clojure.set/union in)) (reduce #(+ %1 (count %2)) 0 in)))","user":"558b41fce4b0277789237628"},{"problem":153,"code":"(fn [ss]\n   (loop [a (first ss)\n          b (rest ss)]\n       (if (empty? b)\n           true\n           (if (some #(not (empty? (clojure.set/intersection a %)))\n                     b)\n               false\n               (recur (first b)\n                      (rest b))))))","user":"5f77890ae4b02876ed9fd0b9"},{"problem":153,"code":"#(= (reduce (fn [total sub-set]\n             (+ total (count sub-set))) 0 %)\n   (count (reduce into #{}  %)))","user":"5cd639b4e4b0ccb061962940"},{"code":"(fn [sets]\n  (let [all-eles (mapcat #(into [] %) sets)]\n    (= (count all-eles) (count (distinct all-eles)))))","problem":153,"user":"536f871de4b0fc7073fd6e7f"},{"problem":153,"code":"(fn [sets]\n  (if (empty? sets) true \n    (loop [elem (first sets)\n         the-rest (rest sets)\n         ]\n      (if (empty? the-rest) true\n          (if (every? (fn [x] (empty? (clojure.set/intersection x elem)))\n                the-rest\n                )\n              (recur (first the-rest) (rest the-rest)) false)\n            \n          \n          )\n    \n    )\n    )\n  )","user":"563b9acbe4b0bfe05bf11827"},{"code":"(fn pw-disj [ms]\n    (= #{#{}}\n    (set (for [x ms y ms \n               :when (not= x y)] \n             (clojure.set/intersection x y)))))","problem":153,"user":"4ff4c9dae4b0678c553fc360"},{"problem":153,"code":"(fn [ss]\n  (= (count (apply clojure.set/union ss))\n     (reduce + (map count ss))))","user":"5d81b40ce4b0915913b1d379"},{"problem":153,"code":"#(every? empty? (for [x % y % :while (not= x y)] (clojure.set/intersection x y)))","user":"53908e6be4b0b51d73faae9a"},{"code":"(fn [ss] \n  (= (reduce + 0 (map count ss))\n    (count (set (apply concat ss)))))","problem":153,"user":"4f569218e4b0a7574ea71826"},{"code":"(fn [sets]\n(letfn [(pairs [xs]\n  (partition 2 (flatten\n                 (map (fn [ys]\n                        (map #(vector % %2) xs ys))\n                      (take-while not-empty\n                                  (iterate rest (rest xs)))))))]\n(reduce #(and % %2) (map #(let [[a b] %]\n                            (empty?\n                              (clojure.set/intersection a b)))\n                         (pairs sets)))))","problem":153,"user":"50772e6ae4b0fc74642bff5d"},{"problem":153,"code":"#(let [s (apply concat %)] (= (distinct s) s))","user":"588d224ae4b00487982d516c"},{"problem":153,"code":"(fn [s] (= (apply + (map count s)) \n           (count (into #{} (apply concat s)))))","user":"5353afa0e4b084c2834f4b03"},{"problem":153,"code":"(fn foo [initial-sets]\n  (let [[set & sets] (vec initial-sets)]\n    (loop [universe set\n           [s & ss] sets]\n      (println universe s)\n      (if-not s\n        true\n        (let [new-universe (clojure.set/union universe s)]\n          (if (not= (count new-universe) (+ (count s)\n                                            (count universe)))\n            false\n            (recur new-universe ss)))))))","user":"55f2e47de4b06e875b46ce4d"},{"problem":153,"code":"#(= (count (reduce clojure.set/union %)) (apply + (map count %)))","user":"570459a9e4b0b0fb43fd0662"},{"problem":153,"code":"(fn [xs]\n  (let [s (apply concat xs)]\n    (= s (distinct s))))","user":"52bacfa8e4b07a9af57922d6"},{"problem":153,"code":"(fn mytest\n  [coll]\n  \n  \n  (let [disjoint1 (fn [coll set1]\n\t\n\t\t\t\t\t(let [ mutualDisjoint #(empty? (clojure.set/intersection %1 %2))\n\n\t\t   \t\t\t\t\tres1 (map (partial mutualDisjoint set1) coll)\n\n\t\t   \t\t\t\t\tcnt (dec (count coll))\n\t\t\t\t\t\t]\n\n\t\t\t\t\t\t(= (count  (filter #(= true %) res1) ) cnt) \n\n\t\t\t\t\t\t))\n        ]\n    \n      (reduce #(and %1 %2)\n\t\t(map (partial disjoint1 coll) coll)\n\t  )\n    \n    )\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  )","user":"55897fe2e4b059ccff29b205"},{"problem":153,"code":"(fn [sets]\n  (loop [xset (first sets) xsets (rest sets) met-intersection false]\n    (cond\n      met-intersection false\n      (empty? xsets) (not met-intersection)\n      :else (recur\n        (first xsets)\n        (rest xsets)\n        (reduce\n          #(if %1 true (not-empty (clojure.set/intersection %2 xset)))\n          false\n          xsets)))))","user":"5773f3a9e4b0979f896515f2"},{"problem":153,"code":"(fn [sets]\n  (every?\n    #(every? true?\n            (map (fn [set]\n                    (or (identical? % set)\n                        (empty? (clojure.set/intersection % set))))\n                  sets))\n    sets))","user":"547fbe01e4b0c51c1f4d7321"},{"problem":153,"code":"(fn [ss] (let [intersections (for [x ss y (disj ss x)]\n          (clojure.set/intersection x y)) ]\n  \n  (every? true? (map  empty? intersections))))","user":"564127a9e4b08d4f616f5ef3"},{"code":"(fn pdisjoint [sets]\n  (or (= (count sets) 1)\n    (and (pdisjoint (rest sets))\n      (every? #(empty? (clojure.set/intersection (first sets) %)) (rest sets)))))","problem":153,"user":"533ab9abe4b0e30313ee6cbf"},{"problem":153,"code":"(fn [sets] (every? true? (for [a sets b sets]\n             (if\n               (identical? a b)\n               true\n               (empty? (clojure.set/intersection a b))))))","user":"5a2df4a0e4b09cafd31c7f74"},{"code":"#(=\n    (count (reduce into %))\n    (apply + (map count %)))","problem":153,"user":"4dbdc9da535d020aff1edf4c"},{"code":"#(= (count (set (apply concat %))) (count (apply concat %)))","problem":153,"user":"4db13ff51254ad5b4805fa68"},{"problem":153,"code":"(fn [M] (let [us (mapcat identity M)]\n          (every? (partial = 1)\n                  (map count \n                       (map (fn [u] (filter identity (map #(contains? % u) M))) us)))))","user":"5515649fe4b055c2f668d4e3"},{"code":"#(= \n  (count (apply clojure.set/union %)) \n  (reduce + 0 (map count %)))","problem":153,"user":"4e03c616535d04ed9115e796"},{"problem":153,"code":"(fn f\n    ([x] (f (first x) (rest x)))\n    ([acc [x & y]]\n     (cond (empty? x) true\n           (some #(contains? acc %) x) false\n           :else (recur (into acc x) y))))","user":"531bf76fe4b08068f379ed96"},{"problem":153,"code":"(fn pair[n]\n  (=(count(apply concat '() n))\n    (count(apply clojure.set/union n))))","user":"6085edade4b0736b099e42fc"},{"code":"#(let [a (apply concat (map seq %))] (= (count a) (count (set a))))","problem":153,"user":"5034b0e1e4b062bc5d7ae167"},{"problem":153,"code":"(fn [c] (= (reduce #(+ (count %2) %) 0 c) (count (apply clojure.set/union c))))","user":"5c41db45e4b08cd430848ece"},{"problem":153,"code":"(fn [s]\n  (let [u (apply clojure.set/union s)\n        a (apply concat s)]\n    (= (count u) (count a))))","user":"56441634e4b0018b46ad8c08"},{"code":"#(= (reduce + (map count %))\n     (count (reduce clojure.set/union %)))","problem":153,"user":"4ec5d62c535d6d7199dd36ba"},{"problem":153,"code":"#(= (apply + (map count %))\n     (count (set (apply concat %))))","user":"57b9fb56e4b0fbc9809a27fa"},{"code":"(fn[s]\n   (loop [sets s]\n     (if (= (count sets) 1)\n       true\n       (if (some pos?\n               (for [u (rest sets)]\n                 (count (clojure.set/intersection u (first sets)))\n                ))\n       false\n       (recur (set (rest sets)))))))","problem":153,"user":"5048202fe4b0ec70b3ef8d9a"},{"code":"(fn [ss] (= (count (apply clojure.set/union ss))\n            (apply + (map count ss))))","problem":153,"user":"5092fe10e4b097f48cc3857e"},{"problem":153,"code":"(fn [s]\n   (let [ss (apply concat s)]\n     (= (count ss)\n        (count (set ss)))))","user":"4f0f01c0535d0136e6c22329"},{"problem":153,"code":"(fn [s]\n  (not (some false? (for [x s\n                          y s\n                          :when (not= x y)]\n                      (empty? (clojure.set/intersection x y))))))","user":"5fe1b893e4b05ac5b16ea16f"},{"problem":153,"code":"(fn [ss]\n (every? true?\n       (for [x ss y ss \n             :when (not (identical? x y))] \n         (= #{} \n            (clojure.set/intersection x y)))))","user":"559b55d6e4b066d22e731f54"},{"problem":153,"code":"#(= (count (apply clojure.set/union %)) (reduce (fn [acc x] (+ acc (count x))) 0 %))","user":"5d29c06be4b01671435dbc6b"},{"problem":153,"code":"#(=\n  (apply + (map count %))\n  (count (reduce into #{} %)))","user":"532ecd44e4b019098a6f8b49"},{"code":"(fn [ss]\n  (let [a (reduce + (map count ss))\n        b (count (reduce #(apply conj %1 %2) ss))]\n    (= a b)\n    )\n  )","problem":153,"user":"523f0bbfe4b01c266ffa7f91"},{"problem":153,"code":"(fn [arg]\n((fn [seen sets]\n  (let [nset (first sets)\n\t\tremain (rest sets)\n\t\tinter (filter #(contains? nset %) seen)]\n\t(do (println nset) (println remain) (println inter)\n\t(if (not (empty? inter))\n      false\n      (if (empty? remain)\n\t\ttrue\n        (recur (into nset seen) remain)\n    \t)\n    ))\n   )\n ) #{} arg))","user":"57011eb3e4b08d47c97781d1"},{"code":"(fn pr153 [sets]\n  (= (count (apply clojure.set/union sets))\n     (reduce + (map count sets))))","problem":153,"user":"51696ee7e4b03f62cda68ce8"},{"problem":153,"code":"(fn\n  [sets]\n  (= (reduce + (map count sets))\n     (count (reduce into sets))))","user":"5609d328e4b05f002753deee"},{"problem":153,"code":"(fn [args]\n    (=\n     (count (apply clojure.set/union args))\n     (apply + (map count args))))","user":"546e4ab8e4b00cfc9eacc19c"},{"code":"(fn pw [ss]\n  (let [no-meets? (fn no-meets? [x xs]\n    (every? #(empty? (clojure.set/intersection x %)) xs)\n  )]\n  \n  (cond\n    (empty? ss) true\n    :else (let [f (first ss) r (rest ss)]\n            (if (no-meets? f r) (pw r) false))\n  ))\n)","problem":153,"user":"51365524e4b04ac1f358dd52"},{"problem":153,"code":"(fn [sets]\n  (not (some identity\n        (for [x sets y sets :when (not= x y)]\n          (not (empty? (clojure.set/intersection x y)))))))","user":"534d1173e4b084c2834f4a98"},{"problem":153,"code":"(fn [[& s]]\n (= [#{}]\n  (distinct\n   (for [x s y s :when (not= x y)]\n    (clojure.set/intersection x y)))))","user":"5b0180cfe4b0cc2b61a3bd47"},{"problem":153,"code":"#(every? empty? \n         (for [s1 % s2 (disj % s1)]\n           (clojure.set/intersection s1 s2)))","user":"54b13a40e4b09f271ff37d1b"},{"code":";Point-free all the way!\n(comp (partial apply ==)\n      (juxt\n       (comp (partial reduce +) (partial map count))\n       (comp count (partial apply clojure.set/union))))\n            \n\n;(fn pairwise-disjoint [sets]\n;  (== (reduce + (map count sets))\n;      (count (apply clojure.set/union sets))))","problem":153,"user":"5326c5f7e4b09d4e7a9b54f2"},{"problem":153,"code":"(fn pairwise-disjoint? [s]\n  (loop [i 0\n         seen-elements #{}]\n    (do (println i seen-elements) (if (= i (count s))\n       true\n       (let [current-set (vec (nth (vec s) i))]\n         (if (loop [j 0]\n               (if (= j (count current-set))\n                 true\n                 (if (nil? (some (fn [e] (= e (nth current-set j))) seen-elements))\n                   (recur (inc j))\n                   false))\n               )\n           (recur (inc i) (clojure.set/union seen-elements (nth (vec s) i)))\n           false))))))","user":"57d57f65e4b0bd073c2023b3"},{"code":"(fn [s]\n  (= (reduce + (map count s))\n     (count (reduce #(into % %2) #{} s))))","problem":153,"user":"5102489de4b00c483ae176f6"},{"problem":153,"code":"(fn [set-of-sets] (>= 1 (apply max (map\n                                    (fn [a-set] (count (filter not-empty (map (partial clojure.set/intersection a-set) set-of-sets))))\n                                    set-of-sets))))","user":"56baab13e4b0f26550335948"},{"problem":153,"code":"(fn [l]\n\n  (empty? (for\n\n    [x l y l\n\n     :when\n\n     (and\n\n       (not (= x y))\n\n       (not (empty?\n\n              (clojure.set/intersection\n\n                x y))))] [x y])))","user":"5fab7ea6e4b08cb800c85ad8"},{"problem":153,"code":"(fn [sets]\n   (apply\n    (fn f [a & bs]\n      (if (empty? bs)\n        true\n        (or (and (not (some #(not (empty? (clojure.set/intersection a %))) bs)) (apply f bs)) false)))\n    sets))","user":"547d8e93e4b0c51c1f4d72f4"},{"code":"(fn [ssq]\n  (letfn [(rs [coll] (take-while seq (iterate rest (seq coll))))\n          (pd [s] (empty? (clojure.set/intersection\n                           (first s) (apply clojure.set/union (rest s)))))]\n    (every? pd (rs ssq))))","problem":153,"user":"5095f761e4b0ba05ca7aebfd"},{"problem":153,"code":"#(= (reduce + (map count %))\n      (count (apply clojure.set/union %)))","user":"58b81490e4b0ebc645576d8c"},{"code":"(fn [ss] \n  (let [v (mapcat vec ss)\n        s (set v)]\n    (= (count s) (count v))))","problem":153,"user":"4eb2eae5535d7eef30807351"},{"problem":153,"code":"#(->> %\n      (tree-seq set? seq)\n      rest\n      (filter (complement set?))\n      (apply distinct?))","user":"5751f2a2e4b02ea114799292"},{"code":"(fn [xs]\n  (if (<= (count xs) 1) true\n    (let [intersect (fn [x y] (filter #(contains? x %) y))\n          x (first xs) xs' (rest xs)]\n      (if (every? empty? (map #(intersect x %) xs')) (recur xs')\n        false))))","problem":153,"user":"508157b2e4b0946d0443855c"},{"problem":153,"code":"(fn [s] (let [cs (apply concat s)] (= (count cs) (count (set cs)))))","user":"54bad522e4b0ed20f4ff6eb8"},{"problem":153,"code":"(fn [sets] (every?\nidentity \n   (map (fn [me]\n    (let [others (apply clojure.set/union (filter #(not= me %) sets))]\n      (empty? (clojure.set/intersection me others))))\n   \tsets)))","user":"5b9db58be4b0c0b3ffbd4b41"},{"code":"(fn[s]\n  (= \n   (count (apply clojure.set/union s))\n   (reduce #(+ %1 (count %2)) 0 s)))","problem":153,"user":"52b405e1e4b0c58976d9ad15"},{"code":"(fn pds[s]\n  (let [tlen (reduce #(+ %1 (count %2)) 0 s) \n        ts (reduce into s)] (= tlen (count ts))))","problem":153,"user":"4fcf642ee4b03432b189f410"},{"problem":153,"code":"(fn [ss]\n  (->> ss\n  \t(every? #(let [s %]\n               (every? (fn [d]\n                         (empty? (clojure.set/intersection d s)))\n                       (disj ss s))))))","user":"594880ade4b07ddc2dafadc2"},{"problem":153,"code":"(fn [sets] (= (reduce + (map count sets)) (count (reduce clojure.set/union \nsets))))","user":"59358f74e4b04f87174def52"},{"problem":153,"code":"(fn d [sets]\n    (let [f (first sets)\n          r (disj sets f)]\n      (if (seq r)\n        (and (reduce (fn [m el]\n                       (-> (clojure.set/intersection f el)\n                           empty?\n                           (and m)\n                           boolean))\n                     true r)\n             (d r))\n        true)))","user":"59fa241ee4b0ca45a743a358"},{"code":"(fn [ss]      \n  (let [size (reduce + (map count ss))            \n        union-size (count (reduce #(apply conj %1 %2) ss))]        \n    (= size union-size)))","problem":153,"user":"512474ede4b02c3f2a072cce"},{"problem":153,"code":"(fn ans-153 [sets]\n  (let [unionSet (reduce\n                  (fn [acc item]\n                    (clojure.set/union acc item))\n                  sets)\n        totalCount (reduce\n                    #(+ %1 (count %2))\n                    0\n                    sets)]\n    (if (= (count unionSet) totalCount) true false)\n    ))","user":"608fac60e4b03bd49d9f36c7"},{"code":"(fn [xs]\n  (= (count (set (apply concat xs))) (reduce #(+ %1 (count %2)) 0 xs)))","problem":153,"user":"53468f6ce4b084c2834f4a3f"},{"code":"#(apply distinct? (mapcat seq %))","problem":153,"user":"4ef49c2c535dced4c769f238"},{"code":"(fn [args] \n   (every? identity \n     (for [x args, y args] \n      (if (= x y) true\n       (empty? (clojure.set/intersection x y)))\n       ))\n   )","problem":153,"user":"50de11b2e4b061dbdced7217"},{"code":"(fn [sets]\n    (every? identity (for [check-set sets]\n       (every? (comp empty? (partial clojure.set/intersection check-set)) (remove #(= check-set %) sets)))))","problem":153,"user":"4dbb0f2d535d1e037afb21b1"},{"code":"#(=\n  (apply + (for [x %] (count x)))\n  (count (reduce clojure.set/union %))\n)","problem":153,"user":"5176afd2e4b085adf681d889"},{"code":"(fn [sos]\n  (let [n (count sos)\n        v (vec sos)\n        ints (for [i (range n)\n                   j (range n)\n                   :when (< i j)]\n              (empty? (clojure.set/intersection (get v i)\n                                                (get v j))))]\n\n      (empty? (filter #(= false %) ints))))","problem":153,"user":"4f036fb3535dcb61093f6ac8"},{"code":"#(let [c (reduce + (map count %))\n      d (count (into #{} (for [s % i s] i)))]\n    (= c d))","problem":153,"user":"4daddc19c9a9d6ed4599dc57"},{"code":"(fn pdis? [s]\n\t(if (= 1 (count s))\n      true\n      (let [is (first s) rs (disj s is)]\n        (if (every? empty? (map #(clojure.set/intersection is %) rs))\n          (pdis? rs)\n          false))))","problem":153,"user":"5267d9bde4b03e8d9a4a7188"},{"code":"(fn [coll]\n  (every? #(empty? %)\n    (for [a coll, b coll :when (not= a b)]\n      (clojure.set/intersection a b))))","problem":153,"user":"500ff421e4b0ae202717946f"},{"problem":153,"code":"(fn [ss] (every? empty? (for [s1 ss s2 (disj ss s1)] (clojure.set/intersection s1 s2) ) ) )","user":"5db7376fe4b010eb3c36cd43"},{"problem":153,"code":"(fn [set-of-sets]\n  (= (count (reduce clojure.set/union set-of-sets))\n     (reduce + (map count set-of-sets))))","user":"5ec6de19e4b08d0ec38692da"},{"code":"#(every? (fn [[x y]] (empty? (clojure.set/intersection x y)))\n  (for [a % b % :while (not= a b)] [a b]))","problem":153,"user":"4fae258de4b081705acca246"},{"code":"(fn [ss]\n  (let [cnt (apply + (map count ss))\n        unx (apply clojure.set/union ss)]\n    (= cnt (count unx))))","problem":153,"user":"4eec82fe535d93acb0a668ae"},{"problem":153,"code":"(fn [x]\n    (let [ l (apply concat (map #(into [] %) x))]\n      (= (count l) (count (set l)))))","user":"55c49394e4b0e31453f6499e"},{"problem":153,"code":"(fn disjoint [sets]\n  (empty?\n   (filter (complement empty?)\n           (for [s1 sets\n                 s2 (remove #{s1} sets)]\n             (clojure.set/intersection s1 s2)))))","user":"5edd05bfe4b0c7845d86b0f3"},{"problem":153,"code":"(fn [sets]\n      (let [pairs (for [s1 sets\n                        s2 sets\n                        :when (not= s1 s2)]\n                    [s1 s2])\n            overlap? (fn [[s1 s2]]\n                       (when (not (empty? (clojure.set/intersection s1 s2)))\n                         [s1 s2]))]\n        (not (some overlap? pairs))))","user":"5f93529ae4b0715f5002d7bc"},{"code":"(fn __ [sets]\n (every? identity\n (remove nil?\n  (for [a sets b sets] \n    (when (not= a b) \n      (if (seq (clojure.set/intersection a b))\n        \tfalse\n      \t\ttrue))))))","problem":153,"user":"4fa719c0e4b081705acca1bf"},{"code":"(fn [inset]\n  (every? #(= 1 %) (map (comp count second) (group-by identity (mapcat identity inset)))))","problem":153,"user":"50057f23e4b0678c553fc466"},{"problem":153,"code":"(fn [arg]\n    (let [values (reduce into [] arg)]\n      (= (count values) (count (distinct values)))))","user":"5bbbce99e4b0a20761a23610"},{"code":"(fn [sets] (let [s1 (reduce + (map count sets))\n                 s2 (count (reduce clojure.set/union sets))]\n  (= s1 s2)))","problem":153,"user":"52d3f666e4b09f7907dd1327"},{"code":"(fn [sets]\n  (every? empty? (for [s1 sets s2 sets :when (not= s1 s2)] (clojure.set/intersection s1 s2))))","problem":153,"user":"5007f751e4b0b17c647f522b"},{"code":"(fn soln  [s]\n  (if (empty? s)\n    true\n    (and\n     (every? empty? (map #(clojure.set/intersection (first s) %) (rest s)))\n     (soln (rest s)))))","problem":153,"user":"4e80aa10535db62dc21a62b1"},{"problem":153,"code":"(fn [ss]\n  (->> [(apply concat ss)\n        (apply clojure.set/union ss)]\n       (map count)\n       (apply =)))","user":"57a0b341e4b0c3d858beb8d4"},{"problem":153,"code":"(fn [set] \n  (if (some not-empty (for [x set y set\n      :when(not (= x y))] \n  (clojure.set/intersection x y))) false true))","user":"5c748bf5e4b0fca0c16227cb"},{"problem":153,"code":"(fn [s]\n    (every? true? (for [a s, b s :when (not= a b)]\n                        (empty? (clojure.set/intersection a b)))))","user":"5eff6c0ee4b0cf489e8d7f11"},{"code":"(fn [set-out]\n  (not (some not-empty\n        (for [x set-out y set-out :when (not= x y)]\n          (clojure.set/intersection x y)))))","problem":153,"user":"50435689e4b034ff00315d21"},{"code":"(fn [set-of-sets] (letfn [\n(cartesian-product [& sets] (set (if (empty? sets) [[]] (mapcat #(map % (apply cartesian-product (rest sets))) (map #(partial cons %) (first sets))))))\n(pairwise-disjoint-sets? [set-of-sets] (empty? (filter #(not= (count %) (count (distinct %))) (apply cartesian-product (remove empty? set-of-sets)))))\n] (pairwise-disjoint-sets? set-of-sets)))","problem":153,"user":"52f10094e4b05e3f0be25ee8"},{"problem":153,"code":"(fn [set]\n  (loop [set-seq (into [] set)\n         counter 1]\n    (if (empty? set-seq) true\n      (if (= counter (count set-seq))\n        (recur (rest set-seq) 1)\n        (if (empty? (clojure.set/intersection (first set-seq) (nth set-seq counter)))\n          (recur set-seq (inc counter))\n          false)))))","user":"558378dce4b05c286339e115"},{"problem":153,"code":"(fn [ss]\n  (letfn [(intersect [s1 s2] (for [s s1\n                                   :when (contains? s2 s)]\n                               s))\n          (pairs [xs] (map vector xs (rest (iterate rest xs))))]\n    (reduce #(and %1 %2) true\n            (for [[s r] (pairs ss)\n                  s2 r]\n              (= nil (seq (intersect s s2)))))))","user":"4ea03f70535d7eef308072a1"},{"code":"(fn [args]\n  (= (count (apply clojure.set/union args))\n     (apply + (map count args))))","problem":153,"user":"52736ca1e4b03e8d9a4a747e"},{"problem":153,"code":"(fn [s] (loop [sets (rest s)\n                current-set (first s)]\n           (if (empty? sets)\n             true\n             (if (not (empty? (reduce clojure.set/union (map (partial clojure.set/intersection current-set) sets))))\n               false\n               (recur (rest sets) (first sets))))))","user":"53da8fede4b0e771c30254a3"},{"problem":153,"code":"(fn [x] \n  (loop [y (first x) z (rest x) val true] \n    (if (empty? z) val \n      (recur (first z) (rest z) (and val (reduce #(and %1 %2) (set (map #(empty? (clojure.set/intersection y %)) z))))))))","user":"56427910e4b08d4f616f5f19"},{"problem":153,"code":"(fn pw-disj [s]\n  (apply distinct? (apply concat s)))","user":"5383668ee4b06839e8705edd"},{"problem":153,"code":"(fn [sets]\n   (let [u (reduce (fn [acc s]\n                   (into acc s))\n                 #{}\n                 sets)]\n     (= (count u) (reduce + (map count sets)))))","user":"543a8256e4b032a45b869327"},{"problem":153,"code":"(fn [S]\n  (loop [s (first S)\n         S-it (rest S)]\n    (if (empty? S-it)\n      true\n      (if (not-every? #(empty? (clojure.set/intersection s %))\n                      S-it)\n        false\n        (recur (first S-it)\n               (rest S-it))))))","user":"559d33b3e4b0ec2b359424d9"},{"problem":153,"code":"(fn\n  [superset]\n  (let [flattened (apply concat (map #(into [] %) superset))]\n    (= (count flattened) (count (set flattened)))\n    )\n  )","user":"6059d824e4b07e92fa001acf"},{"code":"(fn pairwise[sets]\n  (= (count (reduce clojure.set/union sets))\n     (reduce #(+  %1 (count %2)) 0 sets)))","problem":153,"user":"5273562ae4b03e8d9a4a7479"},{"problem":153,"code":"(fn [setz]\n  (= (reduce + (map count setz))\n     (count (reduce clojure.set/union setz))))","user":"5414b7c4e4b01498b1a719ed"},{"problem":153,"code":"(fn d[s]\n  (letfn [(disjoint[s]\n                   (apply + (map count s)))\n          (disj[s]\n               (count (set (reduce #(concat %1 %2) #{} s))))]\n    (=  (disjoint s) (disj s))))","user":"4e8849c5535d8b9bb0147ca4"},{"problem":153,"code":"(fn [s] (let [all (reduce #(into %1 %2) s) \n              tot (apply + (map count s))]\n          (= tot (count all))))","user":"56102f50e4b05f002753df6b"},{"code":"#(let [v (into '[] %)\n       r (range (count v))]\n   (every? true?\n     (for [i r j r\n           :when (not= i j)\n           :let [disjoint? (= #{} (clojure.set/intersection (nth v i) (nth v j)))]]\n       disjoint?)))","problem":153,"user":"523b4e91e4b07becd5be21ef"},{"code":"#(empty? (filter (fn [[a b]] (> b 1)) (frequencies (apply concat %))))","problem":153,"user":"5201572be4b0d7096e99ddbb"},{"problem":153,"code":"(fn [sets]\n  (loop [f (first sets)\n         r (rest sets)]\n    (cond (empty? r) true\n          (not (empty? (clojure.set/intersection f (first r)))) false\n          :else (recur (clojure.set/union f (first r)) (rest r)))))","user":"5bafd5c8e4b0a20761a234dd"},{"code":"(fn pd[sets]\n  (= \n   (count (apply concat sets)) \n   (count (reduce clojure.set/union sets)) \n   ))","problem":153,"user":"53307da1e4b019098a6f8b5e"},{"code":"(fn par-disj-sets? [sets]\n  (let [\n  \t\tcombine (fn [v]\n\t             (let [rem-el (fn [e i] (remove #(= e %) i))]\n\t\t\t\t    (loop [result [] v2 v]\n\t\t\t\t      (let [  hd (first v2)\n\t\t\t\t              tl (rest v2)\n\t\t\t\t              other (rem-el hd tl)\n\t\t\t\t              combs (for [x other] [hd x])]\n\t\t\t\t      (if (empty? v2)\n\t\t\t\t        result\n\t\t\t\t        (recur (into result combs) tl)\n\t\t\t\t      ))\n\t\t\t\t    )))\n        is-in? (fn [s1 s2] \n\t\t          (let [r (clojure.set/intersection s1 s2)]\n\t\t\t\t\t\t    (if (empty? r)\n\t\t\t\t\t\t      false\n\t\t\t\t\t\t      true)))\n        combinations (combine sets)\n        result (set (for [x combinations] (is-in? (x 0) (x 1))))]\n    (not (contains? result true))))","problem":153,"user":"52cf084ce4b07d0d72b27399"},{"problem":153,"code":"(fn pairwise-disjoint\n  [sets]\n  (if (= (reduce + (map count sets)) (count (reduce clojure.set/union sets)))\n    true\n    false))","user":"57f8153de4b0d3187e900916"},{"code":"(fn f [s]\n  (if (seq s)\n\t\t(let [v (vec s) x (first v) xs (rest v)]\n\t\t\t(and (f xs) (every? (fn [y] (empty? (clojure.set/intersection y x))) xs)))\n\t\ttrue))","problem":153,"user":"4f8c5f4fe4b02e764a0a5198"},{"problem":153,"code":"(fn disjoint [sets]\n  (=\n    (count\n      (apply concat '() sets))\n    (count\n      (apply clojure.set/union sets))))","user":"57fc34f0e4b0d3187e90098e"},{"code":"#(= (count (apply clojure.set/union %))\r\n   (reduce + (map count %)))","problem":153,"user":"4db2cd84535df7e46ed9b6c6"},{"problem":153,"code":"(fn [lst]\n  (= (reduce + (map count lst))\n     (count (reduce clojure.set/union lst))))\n\n;Union used for this problem - helps to return element on 1 input.\n;Reference: https://clojuredocs.org/clojure.set","user":"5a99b87ee4b0d174b936c7af"},{"code":"(fn pairwise-disjoint [s]\n  (loop [set-list (next (seq s)) check (first (seq s))]\n    (if (empty? set-list)\n      true\n      (if (empty? (clojure.set/intersection (first set-list) check))\n          (recur (next set-list) (clojure.set/union check (first set-list)))\n          false))))","problem":153,"user":"4dd0e8f7535da60f04a96e57"},{"problem":153,"code":"; dzholev's solution: union all sets into one, then see if there are any elements in common with the other sets \n#(apply distinct? (reduce concat %))\n\n; benhammond's solution: compare element count for all sets vs element count for unioned set \n#_(fn [ss] (= (count (set (reduce concat ss))) (reduce + (map count ss))))\n\n; from daowen's solution: better version of my solution\n#_(fn pairwise-disjoint? [s]\n  (every? empty?\n          (for [x s y s :when (not (identical? x y))] (clojure.set/intersection x y))))\n\n; first solution\n#_(fn pairwise-disjoint? [s]\n  (every? true? (for [x s y s]\n    (or (identical? x y) (empty? (clojure.set/intersection x y))))))","user":"55e7d06ee4b050e68259b496"},{"code":"(fn pairwise-disjoint-sets [sets]\n  (if (empty? sets)\n    true\n    (and\n     (reduce (fn [a b] (and a (empty? (clojure.set/intersection (first sets) b)))) true (rest sets))\n     (pairwise-disjoint-sets (rest sets)))))","problem":153,"user":"50d86fe2e4b01f0871336e67"},{"problem":153,"code":"(fn pairwise-disjoint [sets]\n  (let [fst (first sets)\n        snd (second sets)\n        rst (rest (rest sets))\n        ]\n  (cond\n    (nil? fst) true\n    (nil? snd) true\n    (not (empty? (clojure.set/intersection fst snd))) false\n    (empty? rst) true\n    :else (pairwise-disjoint (conj rst (clojure.set/union fst snd))))))","user":"588e4e05e4b00487982d5188"},{"problem":153,"code":"(fn pair-disj [sets]\n  (= (count (reduce clojure.set/union sets))\n     (reduce + (map count sets))))","user":"54ae541ae4b09f271ff37cef"},{"code":"#(== (count (apply concat (map vec %)))\n     (count (into #{} (reduce clojure.set/union %))))","problem":153,"user":"4fa0a4b1e4b0dcca54ed6d4f"},{"code":"#(let [element-count (reduce + (map count %))\n       joint-set-count (count (set (apply concat %)))]\n   (= element-count joint-set-count))","problem":153,"user":"4f50c414e4b03ad3f0c10d0d"},{"code":"#(let [s (apply concat %)]\n   (= (count s) (count (set s))))","problem":153,"user":"4ebaf790535dfed6da9c6d6e"},{"code":"(fn [set]\n  (let [disjoint? (fn [c1 c2]\n                       (let [c1-not-in-c2 (not-any? #(contains? c2 %) c1 )\n\t\t\t\t\t\t\t c2-not-in-c1 (not-any? #(contains? c1 %) c2 )] \n\t\t\t\t\t\t  (and c2-not-in-c1 c1-not-in-c2 )))\n\t\tpd \t\t  (fn pairwise-disjoint? [coll]\n                     (let [[s1 & rest] coll ] \n\t\t\t\t\t  (cond \n\t\t\t\t\t\t (not (seq rest)) true\n\t\t\t\t\t\t (every? #(disjoint? % s1) rest ) (pairwise-disjoint? rest)\n\t\t\t\t\t\t :else false)))\t\t]\n     (pd (seq set))))","problem":153,"user":"523a9fc9e4b081681ca7adca"},{"problem":153,"code":"(fn pairwise-disjoint? [sets]\n  (let [xs (into [] sets)]\n    (= 0 (reduce +\n    (map #(count (clojure.set/intersection (get xs (first %)) (get xs (second %))))\n     (remove nil? (for [x (range (count xs)) y (range (count xs))]\n                    (if (< x y) (list x y)))))))))","user":"53c126fce4b00fb29b22125b"},{"code":"(fn [sets] (if (= (count (apply clojure.set/union  sets) ) (apply + (map count sets))) true false))","problem":153,"user":"517945dce4b0684c1c981a43"},{"code":"(fn [S]\n   (if (reduce\n        (fn [r [s q]]\n          (or r (reduce #(or % (= (count s) (count (conj s %2)))) nil q)))\n        nil\n        (loop [[f & r] (vec S) p []] (if r (recur r (concat p (map #(conj [f] %) r))) p)))\n     false\n     true))","problem":153,"user":"4e65027c535d8ccf87e9fe6e"},{"code":"#(loop [s (into [] %)] (if (empty? s) true \r\n (if (empty? (clojure.set/intersection (first s)\r\n  (apply clojure.set/union (rest s)))) (recur (rest s)) false)))","problem":153,"user":"4fca2ef0e4b0ee37620e184e"},{"code":"#(= (count (reduce clojure.set/union %)) (reduce (fn [a b](+ a (count b)))  0 %))","problem":153,"user":"5125029de4b0ce9225d2ed3e"},{"problem":153,"code":"; #(apply distinct? (apply concat %))\n\n(fn [ss]\n  (= (count (into #{} (apply concat ss)))\n     (apply + (map count ss))))","user":"5afb4b15e4b0cc2b61a3bcf6"},{"problem":153,"code":"(fn [sos]\n  (every? \n   \n   (fn [s] (= 1 (count (filter #(seq (clojure.set/intersection s %) ) sos ))))\n   sos))","user":"54af6fb0e4b09f271ff37d08"},{"code":"(fn [x] \n  (let [c (reduce #(+ %1(count %2)) 0 x)\n        m  (count(reduce #(apply conj %1 %2) x)) ]\n    (if (= m c) true\n    false)))","problem":153,"user":"4fa96e80e4b081705acca1df"},{"code":"#(= (count (mapcat identity %))\n    (count (reduce (fn [s c] (into s c)) #{} %)))","problem":153,"user":"4ef9c8f9535dced4c769f26b"},{"problem":153,"code":"(fn [s]\n   (every? true? (for [s-set s]\n                   (let [remain (disj s s-set)]\n                     (every? #(empty? (clojure.set/intersection % s-set)) remain)))))","user":"5f3f2281e4b004f08c61c561"},{"problem":153,"code":"(fn [ss]\n  (= (reduce + (map count ss))\n     (count (reduce clojure.set/union ss))))","user":"55c4e48be4b0e31453f649a7"},{"problem":153,"code":"(fn [coll]\n     (set? (reduce (fn [acc s]\n                        (println \"el valor es \" acc \"y\" s)\n                        (if (true? acc)\n                            true\n                            (let [i (clojure.set/intersection acc s)]\n                                (println \"el valor de i:\" i \":\" (empty? i) \":\" (clojure.set/union acc s))\n                                (if (empty? i)\n                                    (clojure.set/union acc s)\n                                    true))))\n                #{} coll)))","user":"566ff0a1e4b0a866af6896ec"},{"problem":153,"code":"(fn [sets]\n  (= (reduce #(+ %1 (count %2)) 0 sets)\n     (count (apply clojure.set/union (seq sets)))))","user":"5463c824e4b01be26fd746c5"},{"problem":153,"code":"(fn [s]\n    (= (apply + (map count s)) \n       (count (set (apply concat s)))))","user":"525ed5f4e4b0cb4875a45db8"},{"problem":153,"code":"#(= (count (set (apply concat %)))\n   (reduce (fn [x y] (+ x (count y))) 0 %))","user":"5504dd64e4b086ebe8a79c83"},{"problem":153,"code":"#(= 0 (reduce + (flatten \n                    (for [s1 %]\n                      (for [s2 (disj % s1)]\n                        (count (clojure.set/intersection s1 s2)))))))","user":"559a9a3de4b066d22e731f45"},{"problem":153,"code":"#(->> %\n      (mapcat identity)\n      (apply distinct?))","user":"5a5d0726e4b0512ff01cd91b"},{"problem":153,"code":"(fn [sos]\n  (let [ps (into #{} (for [x sos y sos :when (not= x y)] #{x y}))]\n    (every? #(empty? (apply clojure.set/intersection %)) ps)))","user":"52ab51c4e4b0c58976d9ac73"},{"code":"(fn [s]\n  ((fn f [t u]\n     (cond (= (count t) 1) true\n           (empty? u) (f (rest t) (drop 2 t))\n           (empty? (clojure.set/intersection (first t) (first u))) (f (rest t) (rest u))\n           :else false))\n   s (rest s)))","problem":153,"user":"51da631be4b02ceefd947766"},{"problem":153,"code":"(fn disjoint? [sets]\n        (every? empty? (for [s1 sets s2 (rest sets)]\n                         (when (not (identical? s1 s2))\n                           (clojure.set/intersection s1 s2)))))","user":"541ae7dbe4b01498b1a71a61"},{"code":"(fn [colls]\n  (apply distinct? (apply concat colls))\n)","problem":153,"user":"52016690e4b0b2e020a18f0f"},{"problem":153,"code":"(fn [s]\n  (let [svec (vec s)\n        i? (fn [a s]\n          (and (not-empty s)\n               (or (not-empty (clojure.set/intersection a (first s)))\n                   (recur a (rest s)))))\n        is? (fn [[x & tail]]\n             (or (i? x tail)\n                 (and (not-empty tail) \n                      (recur tail))))]\n    (not (is? svec))))","user":"5989e080e4b021a7a535fed6"},{"code":"(fn [ s ]\n        (let [\n            n (count s)\n            cs (cycle s)\n            rec-disjoint? (fn [ n cc ]\n                (let [\n                    v (first cc)\n                    os (set (apply concat (take (dec n) (drop 1 cc))))\n                    ]\n                    (or (= n 0)\n                        (and\n                            (every? #(not (contains? os %1)) v)\n                            (recur (dec n) (rest cc))))))\n            ]\n            (rec-disjoint? n cs)\n    ))","problem":153,"user":"51f59607e4b0abb92f97f9d5"},{"problem":153,"code":"(fn    \n    [all-sets]\n    (every? #(= 1 (second %))\n            (reduce (fn [a item ] (assoc a item (inc (get a item 0))) )\n                    {}\n                    (mapcat #(into () %) all-sets))) \n    )","user":"4f5e5975e4b0030a34fb2b4d"},{"problem":153,"code":"(fn [set-o-sets]\n  (letfn [(disjoint [set-o-setsx]\n            (println (count set-o-sets))\n            (let [first-set (first set-o-setsx)\n                  rm-sets (disj set-o-setsx first-set)]\n              (println first-set)\n              (println rm-sets)\n            (if (empty? rm-sets)\n              true\n              (and (every? false? (for [value first-set s rm-sets] (contains? s value)))\n                   (disjoint rm-sets)\n                   )\n              )))] (disjoint set-o-sets)))","user":"5a9dbb32e4b0d174b936c7f3"},{"code":"#(= (apply + (map count %))\n    (count (reduce clojure.set/union %)))","problem":153,"user":"4db0114d838c48654951d9b8"},{"code":"(fn [s] \r\n      (= (reduce #(+ %1 (count %2)) 0 s) \r\n         (count \r\n           (reduce \r\n             #(apply conj %1 %2) \r\n             #{} \r\n             (filter seq s)))))","problem":153,"user":"4f0da4e4535d0136e6c22319"},{"code":"(fn [s]\n  (every? empty? (mapcat (fn [x] (map #(clojure.set/intersection %1 x) (disj s x))) s)))","problem":153,"user":"4fa6a491e4b081705acca1bc"},{"problem":153,"code":"(fn mutually-disjointed? [^java.lang.BigDecimal set-of-sets] \n  (apply distinct?\n         (apply concat\n                (map seq set-of-sets))))","user":"50e1bdd8e4b019fc399ce17f"},{"problem":153,"code":"(fn disjoint\n  [sets]\n  (->> (for [sa sets sb (disj sets sa)] [sa sb])\n       (map (fn[[sa sb]]\n              (some (fn [e] (contains? sa e)) sb)))\n       (every? nil?)\n       )\n  )","user":"5bc8c033e4b07a9b28b100ca"},{"problem":153,"code":"(fn [sets]\n  (empty? (for [x sets, y sets\n                :let [i (clojure.set/intersection x y)]\n                :while (not= x y)\n                :when (not-empty i)]\n            i)))","user":"5bc255b7e4b07a9b28b10029"},{"problem":153,"code":"(fn [sets]\n  (->> sets\n       (map vec)\n       (apply concat)\n       (apply distinct?)))","user":"55cb11e9e4b0e31453f649ff"},{"problem":153,"code":"(fn [coll]\n  (every? identity\n        (for [a coll\n              b coll\n              :while (not (= a b))]\n          (not-any? identity\n                    (map (partial contains? b) a)))))","user":"5146f343e4b04ef915e3731e"},{"problem":153,"code":"(fn [s]\n  (let [lst (for [i s j s\n                  :let [inter (clojure.set/intersection i j)]\n                  :while (= false (= i j))]\n              inter)]\n    (if (= 0 (reduce + (map #(if (empty? %) 0 1) lst)))\n      true\n      false)))","user":"57f81549e4b0d3187e900918"},{"problem":153,"code":";; first solution:\n;; (fn [x]\n;;    (->> x\n;;         (map identity)\n;;         (mapcat identity)\n;;         ((fn [a]\n;;            (=\n;;             (count (distinct a))\n;;             (count a))))))\n\n;; cleaned up with inspiration from darren's solution\n(fn [x]\n  (->> x\n       (apply concat)\n       (apply distinct?)))","user":"576e607ae4b0979f89651579"},{"code":"#(= (count \n            (filter false? \n                    (for [x %\n                          y %]\n                         (empty? (clojure.set/intersection x y)))))\n           (count %))","problem":153,"user":"511b810ce4b07ab9ec456182"},{"code":"#(= (count (into #{} (mapcat identity %)))\n    (apply + (map count %)))","problem":153,"user":"51057b2be4b06d28cacc92e8"},{"code":"(fn [xss]\n  (=\n    (range (count xss))\n    (map (fn [s] (.indexOf (map (fn [s2] (empty? (clojure.set/intersection s s2))) xss) false))\n         xss)\n    ))","problem":153,"user":"4ff769bce4b0678c553fc38f"},{"problem":153,"code":"(fn [sets] (every? \n            false? \n            (for [set1 sets \n                 set2 sets] \n             (if (identical? set1 set2) \n               false\n               (not (empty? (clojure.set/intersection set1 set2)))))))","user":"5454b84ce4b0e397800069d9"},{"problem":153,"code":"(fn pairwise-disjoint [X] (= (count (reduce clojure.set/union X)) (reduce + (map count X))))","user":"53703287e4b0fc7073fd6e8f"},{"code":"(fn[s] \n  (= [#{}] (distinct\n  (map (fn[v] (clojure.set/intersection (first v) (last v)))\n      (vec (for [x (vec s) y (vec s)] (if (not= x y) [x y] [#{} #{}])))))))","problem":153,"user":"4fbd12a5e4b081705acca2fd"},{"code":"(fn pwd? [S]\n  (letfn [(U [A T] (reduce conj A T))\n          (I [A T] (clojure.set/intersection A T))]\n    (loop [A (first S), B (rest S)]\n      (cond\n        (empty? B) \n          true\n        (empty? (I A (first B))) \n         (recur (U A (first B)) (rest B))\n       :else \n         false))))","problem":153,"user":"4faa9593e4b081705acca1f9"},{"code":"(fn [sets]\n  (= (count (apply clojure.set/union sets))\n     (apply + (map count sets))))","problem":153,"user":"4f4e91a9e4b03ad3f0c10cca"},{"code":"(fn [sets]\n    (every? empty?\n      (for [s sets t sets :when (not= s t)]\n        (clojure.set/intersection s t))))","problem":153,"user":"51d4ed02e4b013d740b70dec"},{"code":"; probably the worst one ive done\n(fn [s]\n  (letfn [(f [s] (some identity (flatten s)))\n          (g [s t]\n            (if-let [b (f (map #(map (partial = %) t) s))]\n              b\n              false))]\n    (if-let [t (f (map #(let [t (disj s %)] (map (fn [x] (g % x)) t)) s))]\n      false\n      true)))","problem":153,"user":"50464831e4b011c5dfee771f"},{"problem":153,"code":"(fn [a] \n    (reduce #(and %1 %2)\n            (for [x a y a :when (not= x y)] (and (= (apply disj x y) x) (= (apply disj y x) y)))))","user":"5be0306be4b0ed4b8aab4c7d"},{"problem":153,"code":"(fn [ss]\n  (every? empty?\n          (for [a (seq ss)\n                b (seq ss)\n                :when (not= a b)]\n            (clojure.set/intersection a b))))","user":"54dd76c8e4b024c67c0cf794"},{"problem":153,"code":"(fn [sets]\n  (= (reduce + (map count sets))\n     (count (reduce into sets))))","user":"60460824e4b02d28681c77bc"},{"code":"#(first (reduce (fn [[b s] e] [(and b (= (count (into s e)) (+ (count e) (count s)))) (into s e)]) [true #{}] %))","problem":153,"user":"5027b41ee4b01614d1633fee"},{"problem":153,"code":"(fn [mm] (->> mm (mapcat identity) (group-by identity) vals (every? #(= (count %) 1))))","user":"54c641f8e4b045293a27f628"},{"problem":153,"code":"(fn [sets]\n  (let [comparisons (set (for [a sets, b sets :when (not= a b)] #{a b}))]\n    (every? #(empty? (apply clojure.set/intersection %)) comparisons)))","user":"54cc26c1e4b057c6fda3a28a"},{"code":"(fn [s]\n  (=\n   (reduce + (for [x s] (count x)))\n   (count (reduce into #{} s))))","problem":153,"user":"4ecbb249535df97575fdabdf"},{"problem":153,"code":"(fn pairwise\n  [input-sets]\n  (letfn [(union [set-a set-b] (set (filter set-a set-b)))\n          (union2 [set-a set-b] (into (union set-a set-b) (union set-b set-a)))\n          (commons? [set-a set-b] (not (empty? (union2 set-a set-b))))]\n    (empty? (for [this-set input-sets\n                  :let [other-sets (disj input-sets this-set)]\n                  :when (seq (flatten (map #(filter (fn [x]\n                                                      (let [found (get this-set x :nil)]\n                                                        (when-not (= found :nil) true))) %)\n                                           other-sets)))]\n              true))))","user":"54e79094e4b024c67c0cf818"},{"problem":153,"code":"(fn [s] (= 1 (->> (reduce concat () s)\n                   (frequencies)\n                   (vals)\n                   (apply max))))","user":"5fa96ddbe4b0fa27300f3dec"},{"problem":153,"code":"(fn [ss]\n  (not-any? not-empty (apply concat\n    (for [s1 ss]\n      (for [s2 ss :when (not= s1 s2)]\n        (clojure.set/intersection s1 s2)))\n   )))","user":"4ff24a1ae4b0678c553fc337"},{"problem":153,"code":"(fn [sets]\n  (first (reduce (fn [acc x]\n                    [(and (first acc) (= (count (clojure.set/union (second acc) x))\n                                         (+ (count (second acc)) (count x))))\n                     (clojure.set/union (second acc) x)])\n                  [true {}]\n                  sets)))","user":"574e84e0e4b02ea114799243"},{"code":"#(every? (fn [[x y]] (empty? (clojure.set/intersection x y)))\n         (for [x % y %\n               :when (not= x y)]\n           [x y]))","problem":153,"user":"53034738e4b0d8b024fd373e"},{"problem":153,"code":"#(->> ((fn r [x] (if (set? x) (mapcat vec (map r x)) [x])) %)\n       frequencies\n       vals\n       (filter (fn [x] (< 1 x)))\n       empty?)","user":"51a058dae4b0b292b01ee3f3"},{"problem":153,"code":"(fn [ss]\n  (reduce #(and %1 %2) (for [s1 ss s2 ss :when (not= s1 s2)] (empty? (clojure.set/intersection s1 s2)))))","user":"53c1ce3ee4b00fb29b221268"},{"code":"(fn fn153 [s]\n  (letfn [(fn153-iter [v xs]\n            (if (nil? v) true\n                         (if ((complement empty?) (clojure.set/intersection xs (first v))) false\n                            (recur (next v) (clojure.set/union xs (first v))))))]\n  (fn153-iter (seq s) #{})))","problem":153,"user":"5125d963e4b05d10e3e395fe"},{"problem":153,"code":"(fn [sets]\n  (every? identity\n  (for [a sets b sets]\n    (or\n    (= a b)\n    (empty? (clojure.set/intersection a b))))))","user":"55625903e4b0c656e3ff17d7"},{"code":"(fn [sets]\n  (every? empty?\n          (for [a sets\n                b sets\n                :when (not= a b)]\n            (clojure.set/intersection a b))))","problem":153,"user":"504e108ce4b078edc5f593b3"},{"problem":153,"code":"(fn [sets]\n  (loop [[s & ss :as sets] (seq sets) visited #{}]\n    (cond\n     (empty? sets) true\n     (not (empty? (clojure.set/intersection s visited))) false\n     :else (recur ss (clojure.set/union s visited)))))","user":"526e5159e4b03e8d9a4a7316"},{"problem":153,"code":"(fn [m] (every? nil? (for [a m\n               b (disj m a)]\n           (some #(contains? a %) b))))","user":"55c652dde4b0e31453f649bd"},{"problem":153,"code":"(fn [all]\n  (= #{true}\n     (into #{}\n       (map\n         (fn [s] (= s (apply clojure.set/difference s (disj all s))))\n         all))))","user":"5b772ad7e4b047b03b2036e8"},{"problem":153,"code":"#(if (= (count (reduce (fn [e rest] (clojure.set/union e rest)) %)) (reduce + (map count %)))\n    true\n    false)","user":"5964f9b0e4b069c0a1a19778"},{"problem":153,"code":"(fn [mn] \n  (empty? \n     (for [i mn :let [ost (apply clojure.set/union (disj mn i)) inter (clojure.set/intersection i ost)] \n                :when (not (empty? inter))] inter)))","user":"5576e78de4b05c286339e075"},{"code":"(fn [s]\n  (every?\n    identity\n    (for [a s b s :when (not= a b)]\n      (and (> (count a) 0)\n           (empty? (filter a b))))))","problem":153,"user":"4e5411e8535d8a8b8723a279"},{"problem":153,"code":"(fn [h] (loop [merged (reduce #(apply merge %1 %2) h)]\n  (if (empty? merged)\n    true\n    (let [item (first merged)]\n      (if (> (count (filter #(= item %) (map #(% item) h))) 1)\n        false\n        (recur (rest merged))\n      )\n    )\n  )\n))","user":"55d79b87e4b0e31453f64aa8"},{"problem":153,"code":"(fn [coll]\n  (let [sets (for [x coll y coll\n                   :when (not (= x y))]\n                   (clojure.set/intersection x y))]\n    (not-any? #(not (empty? %)) sets)))","user":"54012b48e4b0de5c41848620"},{"problem":153,"code":"(fn pairwise-disjoint-sets [xs]\n  (letfn [(disjoint? [xs ys] \n             (every? false? (map (partial contains? ys) xs)))\n          (distributor [f xs]\n             (when-not (empty? xs) \n               (concat \n                 (map #(f (first xs) %) (rest xs))\n                 (distributor f (rest xs)))))]\n    (every? true? (distributor disjoint? xs))))","user":"52616198e4b03e8d9a4a705e"},{"problem":153,"code":"(fn [s]\n  (empty? (apply concat\n                 (for [i s\n                       j s]\n                   (when (not= i j)\n                     (clojure.set/intersection i j))))))","user":"57b19fa1e4b0fbc9809a2754"},{"problem":153,"code":"#(loop [sets %1\n        master #{}]\n  (cond \n   (empty? sets) true\n   (not= 0 (count (clojure.set/intersection (first sets) master))) false\n   :else (recur (rest sets) (clojure.set/union (first sets) master))))","user":"56d63729e4b0ea9b8538f7ca"},{"problem":153,"code":"(fn disjoint1? [sets]\n  (apply distinct? (apply concat sets)))","user":"57ee804ee4b0bfb2137f5bbb"},{"problem":153,"code":"(fn [sets]\n  (loop [elements #{} sets sets]\n    (if\n      (empty? sets)\n      true\n      (if\n        (empty? (clojure.set/intersection elements (first sets)))\n        (recur (into elements (first sets)) (rest sets))\n        false\n        )\n     ))\n  )","user":"5a244240e4b0ff51aa4b32e9"},{"problem":153,"code":"(fn [sets]\n       (let [unique-entries (apply clojure.set/union (set sets))\n             all-entries (apply concat (seq sets))]\n         (= (count unique-entries) (count all-entries))))","user":"53f891eee4b0de5c4184856d"},{"code":"(fn [s]\n  (let [sets (set (map #(if (sequential? %) (set %) %) s))]\n     (every? identity\n             (map #(every? (fn [x] (empty? (clojure.set/intersection % x))) (disj sets %))\n                  sets))))","problem":153,"user":"50996a38e4b0cae2931060b3"},{"code":"(fn dis [s]\n  (every? false? (for [i  s j s]\n\t(if (and (not= i j) (not= (count (clojure.set/intersection i j)) 0))\n\t  true\n\t  false))))","problem":153,"user":"5101192ae4b0bef64c30e266"},{"problem":153,"code":"#(= (reduce + (map count %)) (count (set (mapcat identity %))))","user":"502873a8e4b01614d1633ff8"},{"problem":153,"code":"(fn [coll] (letfn \n [(pairs\n  [coll1 coll2] \n    (lazy-seq (when-let [[a & more1] (seq coll1)] \n        (if-let [[b & more2] (seq coll2)]\n              (cons [a b] (pairs coll1 more2))\n              (pairs more1 (next more1))))))]\n(apply = true (map #(empty? (clojure.set/intersection (% 0) (% 1))) (pairs coll (next coll))))))","user":"5be6d0f8e4b0f319e2d7ec51"},{"problem":153,"code":"(fn diffSet\n  [s]\n  (let [isDiff (fn [a b]\n                 (zero? (count (clojure.set/intersection a b))))\n        origSet s]\n    (cond\n     (or (empty? s) (= (count s) 1)) true\n     (= (count s) 2) (isDiff (get s 1) (get s 2))\n     :else (every? true? (for [s1 s\n                               s2 (disj s s1)]\n                           (isDiff s1 s2))))))","user":"54f64e99e4b0f2f3c5226ea4"},{"code":"(fn [input]\n  (let [disjoint? (fn [c d] (= 0 (count (clojure.set/intersection c d))))]\n  (every? identity (for [a input\n        b input]\n     (if (not (= a b))\n        (disjoint? a b)\n         true\n       )))))","problem":153,"user":"51622fb8e4b009fba0926e3f"},{"problem":153,"code":"(fn mutdis [s]\n  (letfn [(disjoint? [s1 s2] (empty? (clojure.set/intersection s1 s2)))\n          (fdisjoint? [ ss ]\n            (cond (empty? ss) true\n                  (= (count ss) 1) true\n                  :else (every? true? (map #(disjoint? (first ss) %) (rest ss)))))]\n    (cond (= (count s) 1) true\n          :else (and (fdisjoint? s) (mutdis (rest s))))))","user":"5d1bbef0e4b02ea6f0fb6984"},{"code":"#(every? empty?\n  (for [s1 % s2 (remove (partial = s1) %)]\n    (filter (partial contains? s1) s2)))","problem":153,"user":"4f06dcad535dcb61093f6c16"},{"code":"(fn pairwise-disjoint? [s]\n  (= (count (apply clojure.set/union s))\n     (apply + (map count s))))","problem":153,"user":"4f3fb586e4b0e243712b1f9c"},{"problem":153,"code":"(fn [sets] (= (reduce + (map count sets)) (count (apply clojure.set/union sets))))","user":"55f2c898e4b06e875b46ce4b"},{"problem":153,"code":"(fn [s]\n  (= (sort (map str (apply concat s)))\n     (sort (map str (into '() (set (apply concat s)))))))","user":"557f7c8be4b05c286339e0e0"},{"code":"#(let [[fs fc] (reduce (fn [[as ac] s] [(into as s) (+ ac (count s))]) [#{} 0] %)]\n   (= (count fs) fc))","problem":153,"user":"4f048f67535dcb61093f6bd3"},{"code":"#(not-any? false? (for [s %]\n                   (if (contains? s '+) false\n                       (not-any? s (for [o (disj % s)\n                                         e o]\n                                     e)))))","problem":153,"user":"4ec53f8c535d6d7199dd368b"},{"problem":153,"code":"(fn disjoint [ss]\n  (= (count (apply clojure.set/union ss))\n     (apply + (map count ss))))","user":"5fa74b82e4b0fa27300f3dda"},{"code":"(fn foo [xs] (empty? (keep identity (for [x xs y xs] (when (not= x y) (some #(contains? x %) y))))))","problem":153,"user":"52015698e4b0d7096e99ddba"},{"problem":153,"code":"(fn [sets]\n     (let [pairs ((fn combinations [other]\n                    ;(prn \"other\" other)\n                   (cond\n                     (nil? other) '()\n                     (empty? other) '()\n                     :else\n                     (concat\n                       (map (fn [b] (list (first other) b)) (rest other))\n                       (combinations (rest other))\n                       )\n                     )) sets)\n           ]\n             (prn pairs)\n             (every?\n                 (fn [[a b]]\n                   (prn \"-\" a b)\n                   (prn (empty? (clojure.set/intersection a b)))\n                   (empty? (clojure.set/intersection a b))\n                   )\n                 pairs)\n             )\n     )","user":"55aa5f73e4b0988bba2ad94b"},{"code":"(fn [x] (= (reduce + (map count (into [] x))) (count (into #{} (reduce concat (map (fn [y] (into [] y)) (into [] x)))))  )  )","problem":153,"user":"5296008fe4b02ebb4ef7502a"},{"problem":153,"code":"(fn [s] (reduce #(and %1 %2) (for [a s, b s :while (not (= a b) )  ] (empty? (clojure.set/intersection a b))  )  ) )","user":"56a6051fe4b0542e1f8d14e5"},{"code":"(fn [x] \n  (first\n    (reduce (fn [[r s] i]\n      (cond\n        (not r) [r s] \n        (contains? s i) [false s]\n        :else [r (conj s i)])) [true #{}] (reduce concat x))))","problem":153,"user":"511ac026e4b0c87c59c9670e"},{"code":"(fn [s] (every? #(empty? (clojure.set/intersection (first %) (last %))) (for [x s y (disj s x)] [x y])))","problem":153,"user":"50112acee4b0d82cfac69f4c"},{"code":"(fn [ss]\n          (empty?\n           (apply clojure.set/union\n                  (for [s ss\n                        o (clojure.set/difference ss #{ s })]\n                    (clojure.set/intersection s o) ) )))","problem":153,"user":"503b6995e4b07a1917cc34dd"},{"problem":153,"code":"(fn [s] (= (count (reduce concat '() s)) \n           (count (reduce clojure.set/union s))))","user":"59e18b9be4b08badc2a0c50f"},{"code":"(fn [sets] (boolean (reduce (fn [a b] (cond\n                                                 (false? a) a\n                                                 (empty? (clojure.set/intersection a b)) (clojure.set/union a b)\n                                                  :else false\n                                                 )) #{} sets)))","problem":153,"user":"4faf97d8e4b081705acca258"},{"code":"(fn [sos]\n  (= (apply + (map count sos)) (count (apply clojure.set/union sos))))","problem":153,"user":"510cd1dde4b078ea71921124"},{"code":"#(->> % (apply concat) frequencies vals (apply max) (= 1))","problem":153,"user":"503a234de4b088a6a14ca76d"},{"code":"(fn [xs]\n  (= \n   (count (apply concat xs))\n   (count (set (apply concat xs)))\n   ))","problem":153,"user":"531490bde4b08068f379ed17"},{"problem":153,"code":"(fn fun-153 [x] (if (nil? (first\n                              (for [x1 x x2 x :when (not= x1 x2) :when  (not= (count (clojure.set/intersection x1 x2)) 0)] [x1 x2]))) true false))","user":"598d22b1e4b02b9968b84d1a"},{"code":"(fn one-fifty-three\n  [coll]\n  (empty? (remove #(or (nil? %) (empty? %))\n                  (for [x coll\n                        y coll]\n                    (if (not (= x y))\n                      (clojure.set/intersection x y))))))","problem":153,"user":"510591dde4b06d28cacc92eb"},{"problem":153,"code":"(fn f [s]\n(= (count (apply clojure.set/union s))\n(reduce + (map count s))))","user":"569adec2e4b0542e1f8d1450"},{"problem":153,"code":"(fn [s]\n  (let [sv (->> (apply concat (vec (map #(vec %) s)))\n                (group-by identity)\n                (map #(count (val %))))]\n     (not-any? #(> % 1) sv)))","user":"564d3169e4b0284900eef67c"},{"problem":153,"code":"#(= (count (into #{} (apply concat % ))) (reduce + (map count (into [] %))))","user":"5686e652e4b0dcc4269f4059"},{"code":"#(= (apply + (map count %))             \n    (count (apply clojure.set/union %)))","problem":153,"user":"4df20dda535d08e6dec9fe23"},{"code":"(fn foo [x]\n  (if (or (empty? x) (= 1 (count x))) true\n  (and (foo (rest x))\n   ((fn bar [x y]\n     (if (empty? y) true\n     (and (bar x (rest y)) \n          ((fn baz [x y]\n            (if (empty? x) true\n            (and (baz (rest x) y)\n            ((fn common [x y]\n              (if (empty? y) true\n              (and (common x (rest y))\n              (if (= x (first y)) false true))\n             )) (first x) y)))\n            ) x (first y)))))\n    (first x) (rest x)))))","problem":153,"user":"5078300de4b0fc74642bff66"},{"problem":153,"code":"(fn\n  [xs]\n  (every? #(empty? %)\n    (map (fn [[a b]] (clojure.set/intersection a b))\n      (for [x xs y xs :while (not= x y)] [x y]))))","user":"507e68abe4b085af06e3afd2"},{"problem":153,"code":"(fn [s]\n  (let [t (apply + (map count s))\n        tn (count (apply clojure.set/union s))]\n  (= t tn)))","user":"51a4d802e4b0def3c5c5869a"},{"code":"(fn [sets]\n  (= (reduce + (map count sets))\n      (count (reduce clojure.set/union #{} sets))))","problem":153,"user":"4fe9d647e4b0547ebccb2472"},{"problem":153,"code":"(fn [x] (and (= #{} (reduce clojure.set/intersection x))) (= (reduce + (map count x)) (count (reduce clojure.set/union x))))","user":"5ccb3792e4b0ccb061962882"},{"problem":153,"code":"(fn[S](every?(fn[s](every? #(=(apply disj % s)%)(disj S s)))S))","user":"50e5bca5e4b09ae9427b0e75"},{"problem":153,"code":"(fn [coll]\n  (= (count (reduce (fn[acc v] (clojure.set/union acc v)) #{} coll))\n     (reduce (fn[acc v] (+ acc (count v))) 0 coll)))","user":"57c0917be4b05aa3c4741c95"},{"problem":153,"code":"(fn [s]\n  (let [a (count (reduce into s))\n        b (reduce + (map count s))]\n    (= a b)))","user":"563dfc02e4b0da801c4e4662"},{"code":"(fn [s] (boolean (reduce \n  #(when (and %(empty? (clojure.set/intersection % %2)))\n     (clojure.set/union % %2)) s)))","problem":153,"user":"4e599577535d8a8b8723a29f"},{"code":"(comp (partial apply distinct?) (partial apply concat))","problem":153,"user":"4f3e5e87e4b0e243712b1f83"},{"problem":153,"code":"(fn [ss]\n  (= (count (reduce #(set (concat % %2)) ss))\n     (count (apply concat ss))))","user":"51baff1be4b0fe3ecfb46443"},{"problem":153,"code":"(fn pwdj\n  [sets]\n  (loop [[s & rst] (seq sets)]\n    (if (nil? s)\n        true\n        (let [] \n          (if (some true? (for [s2 rst] (not (empty? (clojure.set/intersection s s2)))))\n            false\n            (recur rst)\n          )\n        )\n    )\n  )\n)","user":"5f6b8222e4b02876ed9fd052"},{"problem":153,"code":"(fn [s]\n  (not-any? seq\n            (for [s1 s s2 s :when (not (identical? s1 s2))]\n              (clojure.set/intersection s1 s2))))","user":"58ec1e63e4b056aecfd47d54"},{"code":"(fn f\n  ([ss s]\n   (let [l (concat s (first ss)) s (if (empty? (first ss)) s (apply conj s (first ss)))]\n     (if\n       (= (count s) (count l))\n       (if\n         (next ss)\n         (recur (next ss) s)\n         true)\n       false)))\n  ([ss] (f ss (set []))))","problem":153,"user":"5349ac2be4b084c2834f4a67"},{"code":"(fn [s]\n  (= (apply + (map count s))\n     (count (reduce into s))))","problem":153,"user":"4fca4c37e4b0ee37620e184f"},{"problem":153,"code":"#(= (count (reduce clojure.set/union %1)) (reduce + (map (fn [x] (count x)) %1)))","user":"53029281e4b0d8b024fd372e"},{"problem":153,"code":"(fn [l]\n\t(=\n     \t(count (reduce clojure.set/union l))\n\t\t(reduce + (map count l)) \n\t)\n)","user":"5bbbd484e4b0a20761a23617"},{"code":"#(every? identity\n   (for [i % j % :when (not= i j)]\n     (empty? (clojure.set/intersection i j))))","problem":153,"user":"52667ecfe4b03e8d9a4a713e"},{"problem":153,"code":"(fn [xs]\n  (let [xs-pair (partition 2 1 xs)]\n    (every? true? (map #(= (count (set (concat (first %) (second %)))) \n                           (+ (count (first %)) (count (second %)))) \n                       xs-pair))))","user":"52c5c1c8e4b0c2d177d620fc"},{"code":"(fn [s]\n  (empty? (for [x s, y s\n                :let [i (clojure.set/intersection x y)]\n                :while (not= x y)\n          \t:when (not-empty i)]\n            i)))","problem":153,"user":"4f05ea25535dcb61093f6c02"},{"code":"(fn [in]\n  (let [dist (reduce #(into %1 %2) in)\n        all (reduce #(into %1 %2) (map seq in))]\n  (if (and (empty? (remove dist all)) (= (count dist) (count all)))\n    true\n    false)))","problem":153,"user":"4faec810e4b081705acca24e"},{"problem":153,"code":"(fn mutualy-disjoint [x]\n  (= (count (into #{} (apply concat x)))\n     (reduce + (map count x))))","user":"58f5b58ae4b0438e51c2cedc"},{"code":"(fn [src]\n  (let [x (mapcat #(distinct (seq %)) src)]\n   \t(= (count x) (count (distinct x)))\n   )\n  )","problem":153,"user":"5274eb56e4b03e8d9a4a74bb"},{"problem":153,"code":"(letfn [(red [s] \n             (reduce (fn [[ss b] nx] \n                       [(clojure.set/union ss nx) \n                        (and b (empty? (clojure.set/intersection ss nx)))])\n                     [#{} true]\n                     s))]\n  (fn [s] (second (red s))))","user":"5ecc0831e4b016b56eae058c"},{"problem":153,"code":"#(if (reduce (fn[s1 s2](if (and s1 s2) (if (empty? (clojure.set/intersection s1 s2)) (clojure.set/union s1 s2) false) false)) %) true false)","user":"5e48ec09e4b043cd24807a45"},{"problem":153,"code":"(fn pwds [xs]\n  (let [fr (frequencies (mapcat identity xs))]\n      (not (some #(> % 1) (vals fr))\n      )))","user":"4f6ba7bce4b07046d9f4efb0"},{"problem":153,"code":"(fn pairwise-disj [sets]\n         (let [s (first sets)\n               ss ((comp set rest) sets)]\n           (cond\n             (empty? ss) true\n             (some #((complement empty?) (clojure.set/intersection s %)) ss) false\n             :else (pairwise-disj ss))))","user":"5283a919e4b0239c8a67adbe"},{"code":"(fn [s]\n  (= (count (apply clojure.set/union s))\n     (reduce (fn [acc x] (+ acc (count x)))0 s)))","problem":153,"user":"50783762e4b0fc74642bff67"},{"problem":153,"code":"(fn my-all-disjoint? \n  ([set] (my-all-disjoint? set #{}))\n  ([set-set seen]\n    (let [[x & xs :as set-seq] (seq set-set)\n          seen-x               (filter (partial contains? seen) x)]\n      (cond\n        (not (empty? seen-x)) false\n        (not (next set-seq))  true\n        :else                 (recur xs (reduce conj seen x))))))","user":"53edb628e4b0d648e757f4c8"},{"problem":153,"code":"#(= (count (reduce clojure.set/union %1)) (reduce (fn [res x] (+ res (count x))) 0 %))","user":"5a1c3c11e4b0ff51aa4b323d"},{"code":"(fn [x]\n   (every? empty?\n           (for [ a x b x\n                 :when (not (identical? a b)) ]\n             (clojure.set/intersection a b))))","problem":153,"user":"5046b003e4b011c5dfee7727"},{"problem":153,"code":"(fn p-d-s [sets]\n  (letfn [(intersect? [s1 s2]\n   (not= s1 (apply disj s1 s2)))]\n  (every? false? (for [s1 sets\n        s2 sets\n        :when (not= s1 s2)]\n    (intersect? s1 s2)))))","user":"56504dc2e4b0284900eef6bc"},{"problem":153,"code":"(fn [s] \n  (= (count (apply clojure.set/union s))\n     (reduce + (map count s))))","user":"52a7fec0e4b0c58976d9ac25"},{"code":"(fn [x] \n  (reduce #(and %1 %2) true (for [i x j x :when (not= i j)]\n                        (empty? (clojure.set/intersection i j)))))","problem":153,"user":"52747090e4b03e8d9a4a74a5"},{"code":"(fn [set-of-sets]\n    (let [total-count\n            (reduce + (map count (vec set-of-sets)))]\n      (= total-count (count (apply clojure.set/union (vec set-of-sets))))))","problem":153,"user":"53487737e4b084c2834f4a59"},{"problem":153,"code":"#(every? empty? (for [a % b % :when (not= a b)]\n                  (clojure.set/intersection a b)))","user":"588fbb39e4b00487982d51bd"},{"code":"(fn [ss]\n  (every? #(empty? (apply clojure.set/intersection %)) (for [x ss y ss :when (not= x y)] [x y])))","problem":153,"user":"53219cece4b09d4e7a9b54b7"},{"problem":153,"code":"(fn f[x]\n  (let [r (rest x) c (set(apply concat r))]\n  (or (empty? r)\n      (and (= c (apply disj c (first x)))\n           (f r)))))","user":"53ed2fafe4b0d648e757f4c1"},{"problem":153,"code":"#(->> (for [x % y % :when (not= x y)] (empty? (clojure.set/intersection x y)))\n      (some false?)\n      not)","user":"56aed78fe4b03c432f187363"},{"problem":153,"code":"#(every? empty? (for [a %, b % :when (not= a b)] (clojure.set/intersection a b)))","user":"55a12668e4b0acc240e3150b"},{"code":"(fn[s] \n    (= \n      (count \n        (loop[r [] coll s] \n          (if(empty? coll) r (recur (concat r (first coll)) (rest coll)))\n          )\n        ) \n      (count \n        (reduce \n          #(loop[r %1 coll %2] \n             (if(empty? coll) \n               r \n               (recur (conj r (first coll)) (rest coll)))\n             ) \n          #{} \n          s\n          )\n        )\n      )\n    )","problem":153,"user":"52e68e61e4b09f7907dd1479"},{"code":"(fn [s]\n  (letfn [(k-comb [k es]\n            (let [[h t] (split-at 1 es)]\n              (cond\n               (= k 0)          #{ #{}}\n\t       (> k (count es)) #{}\n\t       :else            (into\n                                 (k-comb k t)\n                                 (map #(into % h) (k-comb (dec k) t))))))]\n    (not-any? (fn [s] (not (empty? (clojure.set/intersection (first s) (second s))))) (k-comb 2 s))))","problem":153,"user":"51b9d1f0e4b0e871ca49590b"},{"problem":153,"code":"(fn [sets]\n  (empty?\n   (filter\n    #(>(val %) 1)\n    (frequencies\n     (reduce\n      concat\n      (map\n       (partial into ())\n       sets))))))","user":"586a657de4b0f14aab7c88bd"},{"code":"(fn [s] (if (= (reduce + (map count s)) (count (into #{} (apply concat s)))) true false))","problem":153,"user":"506717e2e4b03d366d7cb2ba"},{"problem":153,"code":"(fn [a] (apply = (map count (map #(reduce % a) [into concat]))))","user":"4eb5750a535d7eef30807366"},{"code":"(fn [set-of-sets]\n  (loop [checked '()\n         this (first set-of-sets)\n         to-check (rest set-of-sets)]\n    (if (empty? to-check)\n      true\n      (let [checking (concat checked to-check)]\n        (if-not (every? (fn [x] (not-any? #(contains? this %) x)) checking)\n          false\n          (recur (conj checked this)\n                 (first to-check)\n                 (rest to-check)))))))","problem":153,"user":"5341b141e4b00652c8746ecf"},{"code":"(fn f [coll]\n(= (reduce + (map count coll))\n   (count (apply clojure.set/union coll))))","problem":153,"user":"51750cd4e4b07031762f2ee5"},{"code":"(fn pairwise-disjoint? [x] \n     (letfn [ (superset [s] (set (mapcat identity s)))\n              (diff [s x] (set (concat (filter  #(not= % x) s))))\n             ]\n     (let [ v (map  #( vector % (superset  (diff x %))) x)] \n       (empty? (filter identity (flatten (for [ [s super-s ] v] (map #(contains? super-s %) s)) )))\n    )))","problem":153,"user":"4fccdc75e4b0ee37620e186d"},{"problem":153,"code":"(fn [sets]\n  (every? empty? (for [s1 sets\n                       s2 sets\n                       :when (not= s1 s2)]\n                   (clojure.set/intersection s1 s2))))","user":"5879d577e4b01531a375ead8"},{"problem":153,"code":"(fn [s]\n  (empty? (for [x s, y s\n                :let [i (clojure.set/intersection x y)]\n                :while (not= x y)\n                :when (not-empty i)]\n            i)))","user":"59e95cafe4b0249b7282074b"},{"problem":153,"code":"(fn [s]\n  (every? \n   #(empty? (clojure.set/intersection (first %) (second %)))\n   (for [x s\n         y (filter #(not= % x) s)]\n     [x y])))","user":"52860baae4b0239c8a67ae09"},{"code":"(fn [ss] (set? (reduce #(if (some % %2) (fn [_] true) (into % %2))\n                       #{}\n                       (let [nil-val (gensym)]\n                         (map #(replace { nil nil-val} %) \n                              (filter (complement empty?) ss)))\n                       )))","problem":153,"user":"519ef784e4b087743fad2198"},{"code":"(fn [s]\n  (= (reduce + (map count s))\n     (count (set (reduce concat () s)))))","problem":153,"user":"51284226e4b03a34742b4308"},{"problem":153,"code":"(fn disjoint? [s]\n  (let [ss (seq s)\n        length (count ss)]\n    (every? empty? (for [s1 (range length)\n                         s2 (range length)\n                         :when (not= s1 s2)]\n      (clojure.set/intersection (nth ss s1) (nth ss s2))))))\n\n;; 113213's solution:\n;; #(apply distinct? (apply concat %))","user":"5fb68f09e4b08cb800c85b58"},{"code":"(fn dis [s]\n          (let [c (apply + (map count s))]\n            (= c (count (set (reduce concat s))))))","problem":153,"user":"4e0d5a5a535d04ed9115e7b5"},{"code":"(fn [coll]\n\t(every?\n\t\tfalse?\n\t\t(flatten (map\n\t\t\t(fn [[a b]]\n\t\t\t\t(map\n\t\t\t\t\t(fn [eleA]\n\t\t\t\t\t\t(map\n\t\t\t\t\t\t\t(fn [eleB] (= eleA eleB))\n\t\t\t\t\t\t\tb))\n\t\t\t\t\ta))\n\t\t\t(partition 2 1 coll)))))","problem":153,"user":"514d7e29e4b019235f6c0587"},{"problem":153,"code":"(fn\n  [coll]\n  (= (count (apply clojure.set/union coll))\n     (reduce + (map count coll)))\n)","user":"5676af21e4b05957ce8c6158"},{"problem":153,"code":"(fn [x] (= (count (reduce #(into %1 %2) #{} x))\n           (reduce + (map count x))))","user":"5a3c5c54e4b001c08efc0ce3"},{"problem":153,"code":"(fn [s]\n  (->> (for [s' s\n             r  s']\n         r)\n       (apply distinct?)))","user":"5a03d246e4b01bb0ae8afd8c"},{"problem":153,"code":"#(let [x (apply concat %)] (= x (distinct x)))","user":"5ade6bafe4b0837691e92c23"},{"problem":153,"code":"(fn [coll]\n   (->> (for [a coll b coll] [a b])\n        (filter (fn [[x y]] (not (= x y))))\n        (filter (fn [[x y]] (< 0 (count (clojure.set/intersection x y)))))\n        (count)\n        (= 0)) )","user":"53ed6976e4b0d648e757f4c4"},{"problem":153,"code":"(fn [set] (every? empty? (for [x set\n                               y set\n                               :when (not= x y)] (clojure.set/intersection x y))))","user":"58983e3fe4b00487982d52ce"},{"code":"(fn [s] (empty? (flatten (for [x s] (mapcat #(clojure.set/intersection x %) (remove #{x} s))))))","problem":153,"user":"4f296a80e4b0d6649770a02a"},{"problem":153,"code":"(fn [in] (not-any? identity (for [x in y in :when (not= x y)] (seq (clojure.set/intersection x y)))))","user":"58a822e4e4b01a0c0b232950"},{"code":"(fn [ss] (every? (fn [s] (every? (fn [t] (not-any? #(contains? s %) t))\n                                 (disj ss s)))\n                 ss))","problem":153,"user":"4e8612f8535db62dc21a62f2"},{"problem":153,"code":"(fn intrs? [s]\n  (letfn [(comb [k l]\n            (if (= 1 k) (map vector l)\n                (apply concat\n                       (map-indexed\n                        #(map (fn [x] (conj x %2))\n                              (comb (dec k) (drop (inc %1) l)))\n                        l))))]\n    (every? identity (map #(apply (comp empty? clojure.set/intersection) %)(comb 2 s)))))","user":"51456858e4b0e88796073408"},{"problem":153,"code":"(fn [s]\n  (every? empty?\n  (for [set1 s\n        set2 s\n        :when (not= set1 set2)]\n    (clojure.set/intersection set1 set2)))\n  )","user":"57cd7498e4b0c746388ab897"},{"code":"(fn [s]\n    (= (reduce + (map count s))\n       (count (reduce clojure.set/union s))))","problem":153,"user":"521b9f92e4b0c4ef0be8304c"},{"problem":153,"code":"(fn[xs]\n        (every? identity \n                (for [a xs b xs \n                      :when (not (= a b))]\n                  (empty? (clojure.set/intersection a b)))))","user":"57e6f90de4b0bfb2137f5af6"},{"problem":153,"code":"(fn alluniq? [s]\n  (apply distinct? (apply concat s)))","user":"58dcf11ae4b0a4d5acaab6af"},{"code":"(fn [sos]\n  (loop [sos sos\n         accum #{}]\n    (if (empty? sos)\n      true\n      (if (not (empty? (clojure.set/intersection (first sos) accum)))\n        false\n        (recur (rest sos) (into accum (first sos)))))))","problem":153,"user":"4ede8e1d535d10e5ff6f5339"},{"problem":153,"code":"(fn [x] (->> x (map seq) (apply concat) (group-by identity) (map #(-> % second count (= 1))) (every? true?)))","user":"59a72effe4b066c664927d94"},{"problem":153,"code":"(fn [s] (= (reduce + (map count s)) (count (into #{} (mapcat seq s)))))","user":"54f0d3fde4b024c67c0cf8a6"},{"problem":153,"code":"(fn __\n  [xs]\n  (= (apply + (map count xs))\n     (count (apply clojure.set/union xs))))","user":"55916764e4b0604b3f94d57b"},{"code":"(fn [s]\n  (let [l (apply concat s)]\n    (=\n      (count l)\n      (count (set l)))))","problem":153,"user":"5060d137e4b0dc10a69545a0"},{"problem":153,"code":"(fn [a]\n  (every? empty?\n          (for [x a\n                y a]\n            (if (= x y)\n              #{}\n              (clojure.set/intersection x y)))))","user":"5585f088e4b001b0851d7513"},{"code":"#(every? empty? (flatten (for [a %]\n                  (for [b (disj % a)]    \n                  (clojure.set/intersection a b)))))","problem":153,"user":"529b44afe4b02ebb4ef7509d"},{"problem":153,"code":"#(->> (for [x % y % :when (not= x y)] [x y])\n      (map (fn [e] seq (clojure.set/intersection (first e) (second e))))\n        (every? empty?))","user":"5a14228fe4b0ff51aa4b3193"},{"problem":153,"code":"(fn [ss]\n    (= (reduce #(+ %1 (count %2)) 0 ss)\n       (count (reduce #(into %1 %2) ss))))\n\n;; #(apply distinct? (apply concat %))\n\n;; #(empty? (filter not-empty\n;;                    (for[x %\n;;                         y %\n;;                         :when (not= x y)]\n;;                      (clojure.set/intersection x y))))\n\n;; #(->> (for [x %1\n;;             y %1\n;;             :when (not= x y)\n;;             :let [z (clojure.set/intersection x y)]]\n;;           z)\n;;         (every? empty?))\n\n;; (fn [s]\n;;     (let [l (reduce into '() s)]\n;;       (= (count l) (count (set l)))))","user":"591ad160e4b09b4ee5954bdf"},{"problem":153,"code":"(fn disjoint-fn\n                ([s t] (= #{} (clojure.set/intersection s t)))\n                ([ss] (every? #(apply disjoint-fn %)\n                              (letfn [(combinations-fn [s]\n                                        (let [elements (vec s)\n                                              length (count elements)\n                                              indices (range length)]\n                                          (for [i indices\n                                                j indices\n                                                :when (not= i j)]\n                                            (let [get-both-indices (juxt #(nth % i) #(nth % j))]\n                                              (get-both-indices elements)))))]\n                                (combinations-fn ss)))))","user":"57f904c5e4b0d3187e900936"},{"problem":153,"code":"#(= (apply + (map (fn [x] (count x)) %))\n     (count (apply clojure.set/union %)))","user":"54be7c0de4b0ed20f4ff6eec"},{"problem":153,"code":"#(->> %\n     (mapcat identity)\n     ((juxt count (comp count distinct)))\n     (apply =))","user":"5761513fe4b0994c1922fb87"},{"problem":153,"code":"(fn [tset]\n (every? true?\n  (flatten\n   (for [s1 tset]\n    (for [remain-s1 (clojure.set/difference tset  #{s1})]\n      (empty?\n       (clojure.set/intersection s1 remain-s1)))))))","user":"55c77070e4b0e31453f649d0"},{"problem":153,"code":"(fn [s-s]\n\t(loop [coll s-s]\n\t\t(if\t(empty? coll)\n\t\t\ttrue\n\t\t\t(let [s (first coll), ss (rest coll)]\n\t\t\t\t(if (every? #(empty? (clojure.set/intersection s %)) ss)\n\t\t\t\t\t(recur (rest coll))\n\t\t\t\t\tfalse)))))","user":"5370b386e4b0fc7073fd6e9b"},{"code":"#(= (apply + (map count %))\n    (count (apply clojure.set/union %)))","problem":153,"user":"4e7f32ee535db966e863cc3a"},{"problem":153,"code":"(fn [s] (every? identity (for [x s y s :when (not= x y)] (empty? (clojure.set/intersection x y)))))","user":"56979bb7e4b0e0b3d3318cac"},{"code":"(fn [ss]\n  (let [md? (comp empty? clojure.set/intersection)\n        xss (for [x ss y ss :when (not (identical? x y))] [x y])]\n    (reduce (fn [a [s1 s2]] (and a (md? s1 s2))) true xss)))","problem":153,"user":"4f8c6bf6e4b02e764a0a519b"},{"problem":153,"code":"(fn [s]\n(->> (for [x s \n      y s\n      :when (not (= x y))]\n   [x y])\n   (map #(apply clojure.set/intersection %))\n   (filter #(> (count %) 0))\n   (count)\n   (= 0)\n   ))","user":"59cf4013e4b0ef0a1e9b5b68"},{"code":"(fn [s]\n  (every? true?\n          (for [a s b s :when (not= a b)]\n            (empty? (clojure.set/intersection a b)))))","problem":153,"user":"52951156e4b02ebb4ef7501b"},{"problem":153,"code":"#(if (= 1 (count %))\n    true\n    (let [[first second & rest] (vec %)]\n      (if-not (empty? (clojure.set/intersection first second))\n        false\n        (recur (cons (clojure.set/union first second) rest)))))","user":"55dcb06ee4b050e68259b3b9"},{"problem":153,"code":"(fn [sets]\n  (if (= (reduce (fn [c x] (if (= #{} (clojure.set/intersection c x)) (clojure.set/union c x))) sets) (apply clojure.set/union sets))\n    true\n    false\n  )\n)","user":"5df08767e4b093ff717275bf"},{"code":"(fn pairwise-disjoint-set [s]\n\t(every? empty?  \n            (for [x s\n         \t\t  y s\n         \t\t  :when (not= x y)]\n\t\t     (clojure.set/intersection x y))))","problem":153,"user":"5220bc0fe4b0e6a83c8925a7"},{"code":"(fn [s] (= (count (reduce into #{} s)) (reduce #(+ % (count %2)) 0 s)))","problem":153,"user":"4f954dbce4b0dcca54ed6ccd"},{"code":"(fn [s] (let [z (map-indexed vector s)] (reduce #(and % %2) true (apply concat (for [[i1 s1] z]\n                                                                                 (for [[i2 s2] z :when (> i2 i1)] (empty? (clojure.set/intersection s1 s2))))))))","problem":153,"user":"52265e41e4b04e78ff2e1981"},{"code":"#(let [x (reduce concat %)] (= (count x) (count (set x))))","problem":153,"user":"4db016af838c48654951d9b9"},{"problem":153,"code":"(fn [sets]\n  (every? empty?\n   (for [set1 sets\n        set2 sets\n        :when (not= set1 set2)]\n    (clojure.set/intersection set1 set2))))","user":"5a6af090e4b0512ff01cda2d"},{"code":"(fn [s]\n  (let [\n        cu (count (apply clojure.set/union s))\n        cs (reduce #(+ (count %2) %1)  0 s)\n        ]\n        (= cu cs)\n  )\n)","problem":153,"user":"504f191ae4b0e7ad84dbc4ba"},{"problem":153,"code":"(letfn [(sequify [coll] (into #{} (map #(if (sequential? %) (seq %) %) coll)))]\n  (fn disjoint? [sets]\n    (let [coll (first sets)\n          colls (rest sets)]\n      (if (seq colls)\n        (and (every? (fn [other-coll]\n                       (empty? (clojure.set/intersection (sequify coll)\n                                                         (sequify other-coll))))\n                     colls)\n             (disjoint? colls))\n        true))))","user":"5515b138e4b055c2f668d4ed"},{"problem":153,"code":"(fn [inp-set]\n  \n  (loop [sset inp-set\n         new-set #{}\n         res true]\n    \n    (cond \n     \t(empty? sset) res\n     \t:else (let [elem (first sset)\n                    new-set-set (clojure.set/union new-set elem)]\n                (cond\n                 \t(= (+ (count new-set) (count elem)) (count new-set-set)) (recur (rest sset) new-set-set true)\n                 \t:else false\n                 )\n                \n                )\n     \n     )\n   )\n )","user":"5fc5c303e4b02c825b0c8c1a"},{"problem":153,"code":";(fn tt [sets]\n;  [fs (first sets) rs (rest sets) elts #{}]\n;    (if (nil? fs)\n;      true\n ;     (if (some #(some (fn [e] (= % e)) elts) fs)\n;        false\n;        (tt sets (clojure.set/union elts (set fs))))))\n\n;; as usual I love noisesmiths solution - \n(fn tl [sets-set]\n  (every? empty?\n  \t(for [a sets-set\n          b sets-set\n          :when (not= a b)]\n    (filter (partial contains? a) b))))","user":"599342efe4b0b211ea3aaab0"},{"code":"(fn \n  [sets]\n  (->>\n   (for [a-set sets\n         b-set sets\n         :when (not (identical? a-set b-set))]\n     (clojure.set/intersection a-set b-set))\n   (every? empty?)))","problem":153,"user":"4dddff47535d08e6dec9fdd4"},{"problem":153,"code":"(fn [set-of-sets]\n  (let [cnt1 (reduce #(+ %1 (count %2)) 0 set-of-sets)\n        cnt2 (count (apply clojure.set/union set-of-sets))]\n    (= cnt1 cnt2)))","user":"540a4f20e4b0addc1aec66ef"},{"problem":153,"code":"(fn [x] (apply distinct? \n               (mapcat seq x)))","user":"53f3a4ace4b0742d9025b0f7"},{"problem":153,"code":"(fn pd \n  [ss]\n  (reduce \n   (fn [acc s] (and acc (every? (fn [q] (or (= q s) (empty? (clojure.set/intersection q s)))) ss)))\n   true\n   ss))","user":"56483562e4b0284900eef629"},{"problem":153,"code":"#(not (some false? (for [fs % ts (remove #{fs} %)] (empty? (clojure.set/intersection fs ts)))))","user":"59a0262ee4b0871e7608b82d"},{"problem":153,"code":"(fn [setOfSets]\n   (= 0 (count \n   (for [chunkedSet (take-while not-empty(iterate rest setOfSets))\n         :let [[aSet & validationSets] (seq chunkedSet)]\n         validationSet validationSets\n         :when (not= 0 (count (clojure.set/intersection aSet validationSet)))]\n     [:failed]))))","user":"53c38b8ce4b00fb29b22127b"},{"problem":153,"code":";stolen elegant solution: #(apply distinct? (apply concat %))\n(fn Pairwise [coll] \n  (zero? \n   (count \n    (filter #(if (empty? %) false true)\n    \t(for [x (into [] coll)\n           \t  y (into [] (disj  coll x))]\n          (clojure.set/intersection x y)\n)))))","user":"5f0824c5e4b0cf489e8d7f5b"},{"problem":153,"code":"(fn [vals]\n   (=\n     (count (reduce (fn [s n] (into s n )) (first vals) (rest vals)))\n     (reduce #(+ % (count %2)) 0 vals)\n     ))","user":"58d27bcae4b03c36ff7e58fe"},{"problem":153,"code":"(fn\n  disjoint-sets\n  [sets]\n  (=\n    (->> sets (map count ,,,) (reduce + ,,,))\n    (->> sets (reduce into ,,,) count)))","user":"5c6227fee4b0fca0c1622641"},{"code":"#(=\n  (count (reduce clojure.set/union %))\n  (reduce + (map count %)))","problem":153,"user":"4ecf1f51535d1f5ad70dba3a"},{"problem":153,"code":"#(->> (for [x % y % :when (not= x y)] (clojure.set/intersection x y))\n       (remove empty?)\n       empty?)","user":"54055aa9e4b0addc1aec6665"},{"problem":153,"code":"(fn [sets]\n  (loop [current #{}\n         remaining sets]\n    (if (empty? remaining)\n        true\n        (if (some #(contains? current %) (first remaining))\n          false\n          (recur (clojure.set/union current (first remaining))\n                 (rest remaining))))))","user":"4ea8570f535d7eef308072f8"},{"code":"(fn [s] (= (count (set (apply concat s))) \n           (apply + (map count s))))","problem":153,"user":"4f9510b5e4b0dcca54ed6cc7"},{"code":"(fn pds? [s]\r\n  (let [a (reduce into [] s)]\r\n    (= (count a) (count (set a)))))","problem":153,"user":"500d1db4e4b05f7c30cfa69f"},{"code":"(fn [s]\n  (== (->> s (mapcat seq) set count)\n      (->> s (map count) (apply +))))","problem":153,"user":"51a9dbc9e4b04e3dc0c27b1e"},{"problem":153,"code":"(fn pairwise-disjoint? [x]\n  (letfn [(pairs [x] (let [a (apply vector x)]\n                       (for [i (range (count x))\n                             j (range (inc i) (count x))]\n                         [(get a i) (get a j)])))\n          (disjoint? [a b] (= (count (clojure.set/intersection a b)) 0))]\n    (every? #(disjoint? (first %) (second %))\n            (pairs x))))","user":"550ff2a3e4b06e50f9beb17f"},{"problem":153,"code":"(fn pairWise\n  [sets]\n  (every? empty? (let [seqSet (seq sets) items (count sets)] \n    (for [i1 (range items) i2 (range items)\n         :when (not= i1 i2)]\n      (let [col1 (nth seqSet i1) col2 (nth seqSet i2)]\n            (clojure.set/intersection col1 col2))))))","user":"56fe2a2fe4b08d47c97781ad"},{"code":"#(= (count (reduce into %)) (reduce + (map count %)))","problem":153,"user":"4ee88bfb535d93acb0a66881"},{"problem":153,"code":"(fn singular\n  [sets]\n  (let [intersections (for [s sets, t sets] [s, t, (count (clojure.set/intersection s t))])]\n    (empty? (filter (fn [[s t c]] (and (pos? c) (not= s t))) intersections))))","user":"56e99ec8e4b04a395b9a03fb"},{"problem":153,"code":"(fn [sets]\n  (let [intersects (for [s1 sets\n\t\t\t\t         s2 sets\n\t\t\t\t        :when (not= s1 s2)]\n\t\t\t\t     (seq (clojure.set/intersection s1 s2)))]\n    (reduce #(and %1 (nil? %2)) true intersects)))","user":"56442758e4b0018b46ad8c0a"},{"code":"(fn [sets]\n  (loop [sets sets]\n    (if (empty? sets)\n      true\n      (let [current-set (first sets)\n            rest-of-set (rest sets)\n            set-intersections (map #(clojure.set/intersection current-set %) rest-of-set)]\n        (if (not-every? empty? set-intersections)\n          false\n          (recur rest-of-set))))))","problem":153,"user":"53527551e4b084c2834f4af0"},{"problem":153,"code":"(fn [s]\n  (empty? (for [x s, y s\n    :let [i (clojure.set/intersection x y)]\n    :when (not (= x y))\n    :when (not (empty? i))]\n            i)))","user":"59dd38a8e4b0a0ac046f2503"},{"problem":153,"code":"(fn pairwise-disjoint [sets]\n  (let [all-elems (apply concat sets)]\n    (= (count all-elems) (count (distinct all-elems)))))","user":"601aaa93e4b0bf4ca6b10926"},{"code":"(fn [sets]\n  (every?\n    (fn [[k v]]\n      (= v 1))\n    (frequencies\n        (mapcat seq\n             (seq sets)))))","problem":153,"user":"5014754de4b094324338f8e5"},{"code":"#(empty? ((fn [s] (for [x s y (disj s x) z x :when (contains? y z)] false)) %))","problem":153,"user":"4e8e8c24535d65386fec2143"},{"code":"(fn [sets]\n  (=\n    (reduce + (map count sets))\n    (count (apply clojure.set/union sets))))","problem":153,"user":"515a6151e4b0394f658fe241"},{"problem":153,"code":"(fn [coll]\n  (loop [current (first coll)\n         remaining (rest coll)]\n    (cond\n     (empty? remaining) true\n     (reduce #(and %1 %2)\n             (map #(empty? (clojure.set/intersection current %)) remaining))\n       (recur (first remaining) (rest remaining))\n     :else false)))","user":"53322cece4b019098a6f8b73"},{"problem":153,"code":"(fn [sets]\n  (letfn [(pairs [[x & r]]\n       \t         (if (empty? r)\n         \t         []\n            \t     (concat (map #(vector x %) r)\n                             (pairs r))))]\n    (reduce (fn [res i] (and res i))\n            true\n            (map empty? (map (fn [[a b]] (clojure.set/intersection a b))\n                    \t(pairs (seq sets)))))))","user":"4ddbfb8a535d02782fcbea00"},{"code":"(fn [sets]\n  (= (apply + (map count sets))\n     (count (apply clojure.set/union sets))))","problem":153,"user":"529e3a4fe4b04e0c58e87b92"},{"problem":153,"code":"(fn [s] \n  (if (= (count (apply clojure.set/union s)) (reduce + (map count s))) \n    true \n    false))","user":"5a9ac061e4b0d174b936c7c1"},{"problem":153,"code":"#(every? (partial = #{}) (for [x % y% :when (not= x y)] (clojure.set/intersection x y)))","user":"54769c7ae4b0c51c1f4d72a8"},{"problem":153,"code":"(fn [sets]\n  (let [pairs (for [a sets b sets :when (not (= a b))] [ a b])]\n    (println pairs)\n    (every? (fn [[a b]] (nil? (some #(contains?  a %)  b))) pairs)))","user":"54d1b6ffe4b0e8a36923e5e6"},{"problem":153,"code":"(fn pair-dis-sets\n  [sets]\n  (= (count (reduce #(into %1 %2) #{} sets))\n     (reduce #(+ %1 (count %2)) 0 sets)))","user":"565654dae4b0f9d632dd849f"},{"problem":153,"code":"(fn pair-disjoint [sets]\n  (=\n    (reduce #(+ %1 (count %2)) 0 sets) \n    (count (distinct (reduce #(into %1 %2) [] sets)))))","user":"594c0bd7e4b07ddc2dafae56"},{"code":"(fn [sets]\n  (letfn ((disjoint? [[s1 s2]]\n            (empty? (clojure.set/intersection s1 s2)))\n          (pairwise [seq]\n            (mapcat (fn [xs]\n                      (map (fn [x] [(first xs) x])\n                           (rest xs)))\n                    (take (dec (count seq))\n                          (iterate rest seq)))))\n    (every? disjoint? (pairwise sets))))","problem":153,"user":"4ee3b586535d10e5ff6f5371"},{"code":"#(every? #{1} (vals (frequencies (apply concat %))))","problem":153,"user":"4dda44f2535d02782fcbe9f1"},{"problem":153,"code":"(fn [ss]\n  (= (->> ss (map count) (apply +)) (->> ss (apply clojure.set/union) count)))","user":"5953bdb6e4b066ee0a44aeed"},{"code":"(fn mydisj [xs]\n  (let [f (first xs), r (rest xs)]\n    (if (empty? r)\n      true\n      (if\n        (every? (fn [q] (not-any? #(= % (f %)) q)) r)\n        (mydisj r)\n        false\n      )\n    )\n  )\n)","problem":153,"user":"4f725201e4b07046d9f4f02f"},{"problem":153,"code":"(fn [xs]\n  (= (reduce #(+ % (count %2) ) 0 xs) (count (apply clojure.set/union xs))))","user":"5392bfdee4b0b51d73faaeb2"},{"problem":153,"code":"(fn [coll] (= (count (flatten (map vec (#(for [x % y % :while (not= x y)] (clojure.set/intersection x y)) coll)))) 0))","user":"5507cfd3e4b021ccfedb96ad"},{"problem":153,"code":"(fn [sets]\n  (let [csets (map (fn [y] (into #{} (replace {nil 'kaz} y))) sets )] \n  (if (nil? (first csets))\n    true\n    (if (some false? (map (fn [s] ((fn [s1 s2] (not (some (comp not nil?) (map s1 s2)))) (first csets) s)) (rest csets)))\n      false\n      (recur (rest csets))))))","user":"5b15ab32e4b0cc2b61a3be72"},{"problem":153,"code":"#(let [v (for [i % j i] j)] (= (count (set v)) (count v)))","user":"55d1b565e4b0e31453f64a49"},{"problem":153,"code":"(fn [xs] (apply distinct? (reduce into () xs)))","user":"5adf5f9be4b0837691e92c33"},{"code":"(fn [s]\n  (every? \n   (fn [[x y]] (empty? (clojure.set/intersection x y)))\n   (for [x s\n         y s\n         :when (not= x y)]\n     [x y])))","problem":153,"user":"51e38568e4b0c611d6113e43"},{"problem":153,"code":"(fn [sets] \n  (let [all-items (reduce into '() sets)]\n    (= (count all-items) (count (set all-items)))))","user":"575ef4b6e4b08062f99a4e78"},{"code":"(fn fx [s]\n    (let [\n          ;; true if x/y share elements\n          ;; see also clojure/set\n          includes\n          (fn [x y] (some #{true} (map #(contains? x %) y)))\n          ]\n    (= (count s) (count (filter true? (flatten (for [i s] (for [j s] (includes i j)))))))))\n\n;;","problem":153,"user":"514cfa27e4b019235f6c057d"},{"problem":153,"code":"(fn prob153 [s]\n  (let [ss (seq s)\n        length (count ss)]\n    (every? empty? (for [s1 (range length)\n                         s2 (range length)\n                         :when (not= s1 s2)]\n                     (clojure.set/intersection (nth ss s1) (nth ss s2))))))","user":"4ebbff41535dfed6da9c6d78"},{"problem":153,"code":"(fn [sets]\n  (= (reduce + (map count sets)) (count (apply clojure.set/union sets)))\n  )","user":"5cd4e1b2e4b0ccb061962927"},{"problem":153,"code":"(fn [ss] (apply distinct? (for [sub ss c sub] c)))","user":"5b008bcae4b0cc2b61a3bd3d"},{"problem":153,"code":"(fn [s] (= (count (reduce clojure.set/union s)) (reduce #(+ % (count %2)) 0 s)))","user":"5441f5e8e4b032a45b869375"},{"code":"(fn [sets]\n  (empty? (apply clojure.set/union (for [s1 sets s2 sets :when ((complement identical?) s1 s2)]\n                                     (clojure.set/intersection s1 s2)))))","problem":153,"user":"52cca65be4b07d0d72b2736b"},{"problem":153,"code":"#(apply distinct? (for [x % y x] y))","user":"5a085dfde4b01bb0ae8afdf4"},{"code":"(fn disj3? [coll]\n  (let [disj2? (fn disj2? [coll v] \n                 (reduce #(and (empty? (clojure.set/intersection v %2)) %1)\n                           true\n                           (clojure.set/difference coll (conj (set nil) v))))\n        ]\n  (reduce\n    #(and (disj2? coll (set %2)) %1)\n    true\n    coll)))","problem":153,"user":"50c8697ce4b00bb60fe0c53f"},{"code":"#(->> % (mapcat concat) frequencies vals\n    (every? (fn [e] (= e 1))))","problem":153,"user":"4faac363e4b081705acca200"},{"code":"(fn pwd [sets]\n  (apply distinct? (reduce concat [] sets)))","problem":153,"user":"526439a4e4b03e8d9a4a70cc"},{"problem":153,"code":"#(if (= (reduce + (map count %)) (count (reduce clojure.set/union %)))\n     true\n     false)","user":"5bbc0ddfe4b0a20761a2361e"},{"problem":153,"code":"(fn pwdj [ss] \n        (every? empty?\n        \t(for [s ss \n        \t      t (clojure.set/difference ss #{s})] \n        \t      (clojure.set/intersection s t))))","user":"548f5086e4b0e286459a1239"},{"problem":153,"code":"(fn [sets]\n  (boolean (reduce (fn [a b]\n                     (and a\n                     (empty? (clojure.set/intersection a b))\n                     (clojure.set/union a b)))\n                   sets)))","user":"580bd81ee4b0849f6811b711"},{"problem":153,"code":"(fn [sos]\n  (not-any?\n   #(->> (disj sos %)\n         (apply clojure.set/union)\n         (clojure.set/intersection %)\n         empty?\n         not)\n   sos))\n\n\n;; obvious solution after looking at @nothsaevets and @stuarth solutions\n#_(fn [sos]\n    (= (count (apply concat sos))\n       (count (apply clojure.set/union sos))))","user":"5297dcc5e4b02ebb4ef75047"},{"problem":153,"code":"(fn [ss] (apply distinct? (mapcat identity ss)))","user":"515cf9b5e4b00901442db1d4"},{"problem":153,"code":"(fn [s] (= (apply + (map count s)) ;;;contar para cada elem (map)\n           (count (into #{} (apply concat s))))) ;;;meter s","user":"6075c214e4b069485764de5b"},{"problem":153,"code":"(fn [s]\n  (let [u (reduce clojure.set/union s)\n        cnt (reduce + (map count s))]\n    (= cnt (count u))))","user":"5ebdb3d2e4b00a66d4a95275"},{"code":"(fn [sets]\n  (loop [s (first sets) others (rest sets)]\n    (if (empty? others)\n      true\n      (let [disjoint? (every? identity (for [item s other-set others] (not (contains? other-set item))))]\n        (if (not disjoint?)\n          false\n          (recur (first others) (rest others)))))))","problem":153,"user":"5225271fe4b01819a2de42f9"},{"code":"(fn [a] \n  (every? true? \n          (map #(empty? (apply clojure.set/intersection %)) \n               (for [x a y a :when (not= x y)] (list x y)))))","problem":153,"user":"532418f3e4b09d4e7a9b54d8"},{"problem":153,"code":"#(let [s (apply concat %1)]\n  (= (reduce + (for [x s y s :when (= x y)] 1)) (count s)))","user":"5590e55de4b0277789237676"},{"problem":153,"code":"(fn [s] \n  (let [uc (count (apply clojure.set/union s))\n      rc (reduce + (map count s))]\n      (= rc uc)))","user":"51b0e7b3e4b0c53cf2e68a6e"},{"code":"(fn [ss]\n  (let [ss-count (apply + (map count ss))\n        combo-count (count (reduce into ss))]\n    (= ss-count combo-count)))","problem":153,"user":"5361a4f2e4b0243289761e47"},{"problem":153,"code":"(fn [xs]\n  (let [normalize-val #(if (coll? %) (set %) (str %))\n        normalize-set #(set (map normalize-val %))\n        pairs (set (for [x1 xs x2 xs :when (not= x1 x2)]\n                     (set [(normalize-set x1) (normalize-set x2)])))]\n    (empty? (some (partial apply clojure.set/intersection) pairs))))\n;correct version\n;(fn [xs]\n;  (let [pairs (set (for [x1 xs x2 xs :when (not= x1 x2)]\n;                     (set [x1 x2])))]\n;    (not-any? (comp seq (partial apply clojure.set/intersection)) pairs)))","user":"56dc3bdfe4b0ea9b8538f819"},{"code":"(fn disjoint-set? [s]\n  (let [m (mapcat identity s)]\n    (= (count m)\n       (count (set m)))))","problem":153,"user":"52d2ca1ce4b099d49816f0b4"},{"problem":153,"code":"(fn [xsets]\n  (loop [seen #{} xsets (seq xsets)]\n    (if (seq xsets)\n      (if (every? #(not (contains? seen %)) (first xsets))\n        (recur (clojure.set/union seen (first xsets)) (rest xsets))\n        false)\n      true)))","user":"4e68c434535d8ccf87e9fe89"},{"code":"(fn [xs]\n  (every? true?\n      (for [x xs\n            y xs\n            :when (not (identical? x y))]\n      (empty? (clojure.set/intersection x y)))))","problem":153,"user":"53691dc7e4b0243289761e97"},{"code":"(fn [s]\n  (every?\n   empty? \n   (for [x s y s\n        :when (not (identical? x y))]\n    (clojure.set/intersection x y))))","problem":153,"user":"4fe13ad7e4b0dd6cd5ce3632"},{"code":"(fn pairwise-disjoint? [sets]\n  (let [total (reduce +\n                      (map count sets))\n\n        all (reduce clojure.set/union\n                    sets)]\n    (= total (count all))))","problem":153,"user":"530578ede4b0d8b024fd3760"},{"code":"#(let [together (apply concat %)] (= (count together) (count (set together))))","problem":153,"user":"4f8b27b3e4b02e764a0a5179"},{"problem":153,"code":"(fn [sets]\n  (if (reduce (fn [o x]\n                (when o\n                  (when (empty? (clojure.set/intersection o x))\n                    (clojure.set/union o x)))) (first sets) (rest sets))\n    true\n    false))","user":"51c8f1d8e4b07ef393169e5d"},{"problem":153,"code":"(fn [s]\n  (let [ss (seq s)\n        len (count ss)]\n    (every? empty? (for [s1 (range len)\n                         s2 (range len)\n                         :when (not= s1 s2)]\n                     (clojure.set/intersection (nth ss s1) (nth ss s2))))))","user":"567b2f20e4b05957ce8c61a2"},{"problem":153,"code":"(fn [x]\n  (loop [a (first x) r (disj x a) sim true]\n    (if (or (false? sim) (empty? r)) sim\n      (let [n (first r)]\n        (recur n (disj r n) (every? empty? (for [b r] (clojure.set/intersection a b))))))))","user":"56bb9ccce4b0f26550335959"},{"problem":153,"code":"(fn [s]\n  (let [n (mapcat seq s)]\n    (= (count n) (count (set n)))))","user":"54b54d1be4b05787c3b1639c"},{"problem":153,"code":"(fn [s] (boolean (reduce #(if (and (not (nil? %1)) (empty? (clojure.set/intersection %1 %2))) (clojure.set/union %1 %2) nil) #{} s)))","user":"57c7e7d9e4b05aa3c4741d0f"},{"problem":153,"code":"(fn [x] (every? #(= 1 %) (vals (frequencies (apply concat (concat x))))))","user":"58b80ec1e4b0ebc645576d89"},{"problem":153,"code":"(fn [ss]\n    (->> ss\n         (map (fn [s] (into {} (map #(vector % 1) s))))\n         (reduce #(merge-with + % %2))\n         vals\n         set\n         count\n         (= 1)\n         ))","user":"54965534e4b0b312c081ff65"},{"problem":153,"code":"(fn [sets]\n  (let [sets (seq sets)\n        a (apply concat sets)\n        b (seq (apply clojure.set/union sets))]\n    (and (= (count a) (count b)))))","user":"532bce35e4b09d4e7a9b5536"},{"problem":153,"code":"(fn [coll]\n  (let [s (for [a coll b coll\n                 :when (not (identical? a b))]\n             (clojure.set/intersection a b))]\n    (every? empty? s)))","user":"564da567e4b0284900eef682"},{"problem":153,"code":"(fn [st]\n  ;; just want to intersect the pairs of sets once\n  (let [st-and-indices (map-indexed vector st)]\n    (->> (for [[i y] st-and-indices\n               [k x] st-and-indices\n               :while (< k i)] \n           (clojure.set/intersection x y))\n         (filter not-empty)\n         empty?)))","user":"563772a9e4b0bfe05bf117d7"},{"problem":153,"code":"(fn[x] \n  (= (count (apply concat x))\n     (count (reduce into #{} x))))","user":"4daeabf6edd6309eace4d15c"},{"code":"(fn [ss]\n   (every? #(= % 1)\n           (vals\n            (reduce\n             (fn [h s]\n               (reduce (fn [h e]\n                         (assoc h e (inc (get h e 0))))\n                       h s))\n             {}\n             ss))))","problem":153,"user":"4fc3a72ae4b081705acca342"},{"problem":153,"code":"(fn [s] (empty? (filter #(> (count (second %)) 1) (group-by identity (mapcat vec s)))))","user":"55c4cda5e4b0e31453f649a5"},{"code":"(fn [s] (every? (partial = 1) (vals (apply merge-with + (map #(zipmap % (repeat 1)) s)))))","problem":153,"user":"4e89f46c535d3e98b8023288"},{"code":"(fn [a-set]\n  (->> (for [x a-set\n             y (disj a-set x)]\n         (clojure.set/intersection x y)) ; all possible pairwise intersection\n       ;; true if all empty\n       (every? empty?,  )\n       ))","problem":153,"user":"53415755e4b00652c8746ecd"},{"code":"#(empty?    \n    (remove nil?\n            (let [sets (clojure.walk/prewalk (fn [a] (if (or (symbol? a) (fn? a)) (class a) a)) %)] \n              (for [s sets]                  \n                (some s (->> sets (remove (partial = s)) (map (partial some s))))))))","problem":153,"user":"4e513758535dc968683fc4f3"},{"problem":153,"code":"#(empty?\n (filter (fn [kv] (> (second kv) 1))\n         (reduce \n          (fn [acc e] (assoc acc e (inc (get acc e 0))))\n          {}\n          (for [s % el s] el))))","user":"55c20bd0e4b0e31453f64972"},{"problem":153,"code":"(fn [sets]\n  (every? true?\n    (for [i (range (count sets))\n          s2 (drop (inc i) sets)\n          :let [s1 (nth (apply list sets) i)]]\n      (empty? (clojure.set/intersection s1 s2)))))","user":"556159fae4b0c656e3ff17c7"},{"code":"(fn [sets]\n  (letfn [(intersect? [s]\n            (some #(-> (clojure.set/intersection % s) seq) \n                  (disj sets s)))]\n    (not-any? intersect? sets)))","problem":153,"user":"51ab4082e4b04e3dc0c27b31"},{"problem":153,"code":"#(let [s (apply concat %)]\n   (= (count s) (count (into #{} s))))","user":"57c94c54e4b05aa3c4741d2c"},{"code":"(fn pwd [s]\n  (cond\n   (empty? s) true\n   (empty? (rest s)) true\n   (every? empty? (map #(clojure.set/intersection (first s) %) (rest s))) (pwd (rest s))\n   true false\n   ))","problem":153,"user":"4e14108c535d04ed9115e7dd"},{"problem":153,"code":"#(loop [xs (rest %)\n         result (first %)]\n    (cond (empty? xs) true\n          ((complement empty?)\n           (clojure.set/intersection result (first xs))) false\n          :else (recur (rest xs) (clojure.set/union result (first xs)))\n          ))","user":"56f7ecdfe4b08e7d20b96834"},{"problem":153,"code":";; (fn [s] (reduce (fn [a [y x]] (and a (if (nil? (some y x)) true false))) true (#(for [x % y % :while (not= x y)] [x y]) s)))\n(fn [s] (apply distinct? (reduce concat s)))","user":"5a5894d9e4b05d388ecb6c81"},{"code":"(fn [sos]\r\n          (not (contains? (reduce (fn [s1 s2]\r\n                                    (if (empty? (clojure.set/intersection s1 s2))\r\n                                      (clojure.set/union s1 s2)\r\n                                      #{:fail}))\r\n                                  #{}\r\n                                  sos)\r\n                          :fail)))","problem":153,"user":"4e8768f6535dceadca469850"},{"problem":153,"code":"(fn p-disj [s]\n  (let [pairs (for [x s\n                    y s\n                    :when (not= x y)]\n                [x y])]\n    (reduce (fn [b p]\n              (and b\n                   (= (+ (count (first p))\n                         (count (second p)))\n                      (count (set (concat (first p) (second p)))))))\n            true\n            pairs)))","user":"52c45ac8e4b0c2d177d620d9"},{"problem":153,"code":"(fn [colls]\n   (letfn [(intersects? [c1 c2] (not (empty? (clojure.set/intersection c1 c2))))\n           (some-intersects? [c colls] (some (partial intersects? c) colls))]\n     (if (empty? colls) true\n         (loop [coll (first colls) colls (rest colls)]\n           (cond (empty? colls) true\n                 (some-intersects? coll colls) false\n                 :else (recur (first colls) (rest colls)))))))","user":"57f80350e4b0d3187e90090c"},{"code":"#(= (count (apply clojure.set/union %))\n  (apply + (map count %))  \n  )","problem":153,"user":"518aec06e4b06da86c1973c2"},{"problem":153,"code":"(fn pair-disj [s]\n  (= (reduce + (map count s))\n     (count (reduce clojure.set/union #{} s))))","user":"5f63684be4b02876ed9fd012"},{"problem":153,"code":"(fn p [x]\n    (if (empty? (rest x))\n      (not (empty? (first x)))\n      (and (not (empty? (first x)))\n         (every? empty? (map #(filter (first x) %) (rest x)))\n         (p (rest x)))))","user":"4e837808535db62dc21a62d9"},{"problem":153,"code":"(fn [s]\n  (apply distinct? \n         (apply concat\n                (for [x s] \n                  (if (and (not (empty? x)) (set? x)) (apply conj [] x) x)))))","user":"574abbfbe4b02ea114799200"},{"code":"(fn [t61]\n  (empty? (filter not-empty (map #(apply clojure.set/intersection %)\n    (let [p (for [x t61 y t61] [x y])]\n    (for [i (range (count p))\n          :when (not (= (mod i (inc (count t61))) 0))]\n      (nth p i)))))))","problem":153,"user":"52016fd3e4b0b2e020a18f10"},{"problem":153,"code":"#(every? false? (for [x %\n                      xs x\n                      y %\n                      :when (not= x y)]\n                  (contains? y xs)))","user":"5f03ab5be4b0cf489e8d7f37"},{"code":"(fn pwd [set]\n  (not-any? false? \n    (for [x set y set]\n      (or (= x y)\n          (empty? (clojure.set/intersection x y))))))","problem":153,"user":"4fe87e56e4b07c9f6fd12c40"},{"problem":153,"code":"(fn [sets]\n    (letfn [(sum [xs]\n              (reduce #(+ %1 (count %2)) 0 xs))]\n      (= (->> sets (seq) (map seq) (reduce concat #{}) (into #{}) (count))\n         (sum sets))))","user":"560e9a2de4b05f002753df52"},{"code":"(fn dsj [x]\n  (=\n   (count (set (reduce concat x)))\n   (reduce + (map count x))\n   )\n  )","problem":153,"user":"52586d24e4b0cb4875a45cb0"},{"problem":153,"code":"(fn [ss]\n  (->> ss\n       (mapcat identity)\n       (group-by identity)\n       (vals)\n       (map count)\n       (remove #{1})\n       (empty?)))","user":"59eb63e3e4b0249b7282077c"},{"code":"(fn t1 [coll] (not (reduce #(or %1 %2) (for [x coll\n                                               y x                     \n                                               z (disj coll x)]\n                                            (contains? z y)))))","problem":153,"user":"5046f909e4b03b02161376b5"},{"problem":153,"code":"(fn [sos]\n  (= (count (set (mapcat seq sos)))\n     (reduce + (map count sos))))","user":"50ec409ce4b04edc33777045"},{"problem":153,"code":"(fn [x] \n  (let [v (vec x)\n        d (for [i (range (count v))\n                :let [o (concat (drop i v) (take i v)) ]]\n            (= (first o) (apply clojure.set/difference o)))]\n    (every? true? d)))","user":"54e345a1e4b024c67c0cf7db"},{"problem":153,"code":"(fn [my-set]\n  (empty? (apply clojure.set/union (for [x my-set y my-set :when (not= x y)] (clojure.set/intersection x y))))\n  )","user":"55fe7e15e4b00f4cabc57651"},{"code":"(fn [x] (= (count (reduce clojure.set/union x)) (reduce + (map count x))))","problem":153,"user":"5217c26fe4b0a4bccb16cab8"},{"code":"(fn disjoint?[s](if (< 1 (apply max (map (fn[item](count (filter true? (map #(contains? % item) s)))) (apply clojure.set/union s))))\n                    false\n                    true\n                    ))","problem":153,"user":"52a1edd6e4b04e0c58e87be4"},{"code":"(fn [sets]\n   (not (contains?  (set (for [a sets b sets]\n                        (if (not= a b)\n                          (empty? (clojure.set/intersection a b))\n                          true)\n                        )) false)))","problem":153,"user":"5300aa1de4b0d8b024fd3710"},{"problem":153,"code":"(fn f [xs] (empty? (for [x xs\n      y xs\n      :when (not= x y) \n      xx x\n      yy y\n      :when (= xx yy)]\n      xx)))","user":"57717915e4b0979f896515b3"},{"code":"(fn [s] \n  (= (seq s) (for [x s y s :let [i (clojure.set/intersection x y)] :when ((complement empty?) i)] i)))","problem":153,"user":"50d0d4c8e4b00b15ecee976a"},{"code":"#(empty? (for [x % y %\n               :when (and (not (identical? x y))\n                          (not (every? #{:eee} (map (partial get x) y (repeat :eee))))\n                          )\n               ]\n           x\n           )\n         )","problem":153,"user":"5281a445e4b0757a1b17143a"},{"code":"(fn [s]\n  (every?\n   (fn [r] (not-any? #(seq (clojure.set/intersection % (first r)))\n                         (rest r)))\n   (take-while seq (iterate rest s))))","problem":153,"user":"5175533fe4b0dea9bbfba575"},{"code":"(fn [sets]\n  (boolean ;;if they were disjoint, the reduction will return their union\n    (reduce\n      (fn [u s] \n        (cond \n          (false? u) false ;;TODO rewrite to short-circuit?\n          (not (empty? (clojure.set/intersection u s))) false \n          :else (clojure.set/union u s))) \n      sets)))","problem":153,"user":"4ed188c8535d44c135fd68cf"},{"problem":153,"code":"(fn pair-wise-disjoint? [set-of-sets]\n  (->> (for [x set-of-sets\n             y set-of-sets]\n         (if (and (not= x y) (seq (clojure.set/intersection x y)))\n           1 0))\n       (every? zero?)))","user":"5d7aa22ee4b02e6b30c9354e"},{"code":"(fn [ss]\n  (first (reduce\n    (fn [[b s] n]\n      [(and b (not-any? #(contains? s %) n)) (into s n)])\n    [true #{}] ss)))","problem":153,"user":"504e04a4e4b078edc5f59397"},{"code":"(fn [sets]\n  (let [sq (apply concat (map concat sets))]\n    (loop [sq sq]\n      (println sq)\n      (if (empty? sq)\n        true\n        (if (some #(= % (first sq)) (rest sq))\n          false\n          (recur (rest sq)))))))","problem":153,"user":"504e12ade4b078edc5f593b7"},{"problem":153,"code":"(fn [sets]\n  (every? empty?\n    (for [s sets\n          t (remove #(= % s) sets)]\n      (clojure.set/intersection s t))))","user":"5169d422e4b051e2a73aba53"},{"problem":153,"code":"#(every? true? (for [i % j %] (if (= i j) true (empty? (clojure.set/intersection i j)))))","user":"5da760ebe4b000c986472c1a"},{"code":"#(= (count (apply clojure.set/union %)) (apply + (map count %)))","problem":153,"user":"50a4f36be4b0344e360f3bc9"},{"code":"(fn [xs] (= (count (reduce clojure.set/union xs)) (reduce #(+ %1 (count %2)) 0 xs)))","problem":153,"user":"52dc2bc8e4b09f7907dd13ca"},{"problem":153,"code":"(fn [sets]\n  (= (reduce + (map count sets))\n     (count (reduce into #{} sets))))","user":"5078d366e4b08327cd804a5b"},{"code":"(fn piarwise [SS]\n  (let [W (into [] SS)\n        C (count W)]\n    (nil? (some #(not (empty? %)) (for [i (range 0 (dec C))\n          j (range (inc i) C)]\n      (clojure.set/intersection (W i) (W j)))))))","problem":153,"user":"50e87427e4b0ebbe794eb7e8"},{"code":"(fn pairwise-disjoint?\n\n  ([sets]\n   (= 0 (count (filter false?\n                       (for [s1 sets\n                             s2 sets\n                             :when (not= s1 s2)]\n                         (pairwise-disjoint? s1 s2))))))\n\n  ([s1 s2]\n   (let [xs (into (into [] s1) s2)\n         fs (frequencies xs)]\n     (empty? (filter #(not= 1 (second %)) fs)))))","problem":153,"user":"4f35b2ace4b0e243712b1ec5"},{"code":"(fn[sofs] (empty? (mapcat #(clojure.set/intersection (first %) (last %)) (for[x sofs y sofs :when (not (= x y))]\n  [x y]))))","problem":153,"user":"4fba77fae4b081705acca2df"},{"problem":153,"code":"(fn disjoint-set? [set-sets]\n       (let\n         [\n           unique-elm?\n           (fn unique-elm [elm]\n             (let\n               [\n                 ;count the number of times the elm appears\n                 sightings\n                 (filter\n                   true?\n                   (for [in-set set-sets]\n                     (contains? in-set elm)\n                     )\n                   )\n                 num-sightings\n                 (count sightings)\n                 ]\n               ;num-sightings\n               ;if the elm appears more than once, it is not unique\n               (= 1 num-sightings)\n               )\n             )\n           unique-set?\n          (fn [in-set]\n            (= (count in-set) (count (filter unique-elm? in-set)))\n           )\n           results (map unique-set? set-sets)\n          ]\n        ; results\n         (not (contains? (set results) false))\n             )\n        )","user":"536827f1e4b0243289761e8a"},{"problem":153,"code":"(fn [s]\n  (= (count (apply clojure.set/union s))\n     (apply + (map #(count %) s))))","user":"5af907e6e4b0cc2b61a3bcda"},{"code":"#(= (count\n     (apply clojure.set/union %))\n    (count\n     (apply concat %)))","problem":153,"user":"51bf4560e4b013aa0d74b817"},{"code":"(fn mutually-disjoint [s]\n  (every? empty?\n          (for [a s\n                b (clojure.set/difference s #{a})]\n            (clojure.set/intersection a b))))","problem":153,"user":"51a97f7ae4b08d8ec191b827"},{"code":"(fn md [coll]\r\n  (reduce #(and %1 %2)\r\n          (map (fn [x] (reduce #(and %1 %2)\r\n                               (map (fn [y] (empty? (clojure.set/intersection x y)))\r\n                                    (disj coll x))))\r\n               coll)))","problem":153,"user":"4dc97aec535d5973398f9284"},{"problem":153,"code":"(fn [sets]\n  (let [c1 ((comp #(reduce + %) #(map count %)) sets)\n        c2 (count (apply clojure.set/union sets))]\n    (= c1 c2)))","user":"59f78b49e4b0ca45a743a30e"},{"problem":153,"code":"(fn [ss]\n  (every? zero?\n    (map count\n      (for [s1 ss s2 ss :while (not= s1 s2)]\n        (clojure.set/intersection s1 s2)))))","user":"4e6a2f51535d8ccf87e9fea9"},{"problem":153,"code":"#(= (apply + (map count %)) (count (set (apply concat %))))","user":"57642916e4b0994c1922fbee"},{"problem":153,"code":"(fn [x] (cond (= (count (apply concat '() x)) (count (apply clojure.set/union x))) true :else false))","user":"59e62655e4b08badc2a0c568"},{"code":"(fn [sets]\n  (letfn [(disjoint-from? [sets s]\n                          (every? #(empty? (clojure.set/intersection s %)) (disj sets s)))]\n    (every? #(disjoint-from? sets %) sets)))","problem":153,"user":"536ca4bde4b0fc7073fd6e49"},{"problem":153,"code":"(fn [sets]\n  (empty?\n   (apply clojure.set/union\n          (map #(apply clojure.set/intersection %)\n               (for [x sets\n                     y sets\n                     :when (not= x y)]\n                 [x y])))))","user":"54b10d08e4b09f271ff37d18"},{"code":"(fn [s]\n  (let [tot (reduce + (map count s))\n        over (set (mapcat identity s))]\n    (= tot (count over))))","problem":153,"user":"5133e51ae4b0d7a043de8cf6"},{"problem":153,"code":"(fn [s]\n  (->> (for [s1 s, s2 s\n             :when (not (identical? s1 s2))]\n         (empty? (clojure.set/intersection s1 s2)))\n       (every? identity)))","user":"537f4652e4b06839e8705eb1"},{"problem":153,"code":"(fn disjoint? \n  ([sets] \n    (disjoint? (first sets) (rest sets)))\n  \n  ([head tail]\n   (cond\n     (empty? tail) \n       true\n     (empty? (clojure.set/intersection head (first tail))) \n       (recur (clojure.set/union head (first tail)) (rest tail)) \n     :else \n       false)))","user":"4e6defcc535d5021c1a895f8"},{"code":"(fn [sets]\n  (first (reduce \n    #(vector (and (first %1) (not (some (partial contains? (second %1)) %2))) \n             (into (second %1) %2))\n    [true (first sets)]\n    (rest sets))))","problem":153,"user":"5002b6e5e4b0678c553fc42c"},{"problem":153,"code":"(fn [sets]\n  (every? (fn [[s t]] (= (clojure.set/intersection s t) #{}))\n          (for [x sets y sets :when (not= x y)] [x y])\n  )\n)","user":"5943abb6e4b060784b3b792b"},{"problem":153,"code":"#(= (count (mapcat identity %)) (count (distinct (mapcat identity %))))","user":"53b15e6ee4b047364c04448f"},{"problem":153,"code":"(fn \n  [sets]\n  (= (reduce #(+ %1 (count %2)) 0 sets)\n     (count (apply clojure.set/union sets))))","user":"56bb652ae4b0f26550335953"},{"problem":153,"code":"(fn p153t [bigset]\n  (let [[s1 s2 & s] (if (sequential? bigset)\n                      bigset\n                      (seq bigset))]\n    (if (not (empty? (clojure.set/intersection s1 s2)))\n      false\n      (if (nil? s2)\n        true\n        (p153t (list* (clojure.set/union s1 s2) s))))))","user":"5c896f46e4b048ec896c5940"},{"problem":153,"code":"(fn [sets] \n  (= (reduce + (map count sets))\n     (count (reduce clojure.set/union sets))\n  )\n)","user":"543bb568e4b032a45b869334"},{"code":"(fn [sets]\n  (let [flattened (filter (complement set?)\n                          (rest (tree-seq set? seq (set sets))))]\n    (if (>\n          (reduce max\n                  (map (fn [m]\n                         (count (last m)))\n                       (seq (group-by identity flattened))))\n          1)\n      false\n      true)))","problem":153,"user":"51db0d99e4b06aa4d4669a9d"},{"problem":153,"code":"(fn pairwise-disjoin [s]\n  (loop [i (first s)\n         r (rest s)\n         check (some true? (for [elem i\n                                 sub-set r]\n                             (contains? sub-set elem)))]\n    (if check\n      false\n      (if (empty? r)\n        true\n        (recur (first r) (rest r) (some true? (for [elem (first r)\n                                                    sub-set (rest r)]\n                                                (contains? sub-set elem))))))))","user":"549eb44fe4b0f3d1d8e70fa6"},{"problem":153,"code":"(fn [s]\n  (reduce #(and %1 %2) (for [x s y s :when (not= x y)]\n                         (empty? (clojure.set/intersection x y)))))","user":"534e4a29e4b084c2834f4ab0"},{"problem":153,"code":"(fn [sets]\n  (every? identity\n  \t(for [s1 sets\n    \t  s2 sets\n          :when (not= s1 s2)]\n      (empty? (clojure.set/intersection s1 s2)))))","user":"5553b924e4b0deb715856e06"},{"problem":153,"code":"(fn disj\n  [a]\n  (if (next a)\n    (and (every? identity (map #(if-not (empty? (clojure.set/intersection (first a) %))\n                    false\n                    true) (rest a))) (disj (rest a)))\n    true))","user":"520cb8c4e4b0b022ef140c9a"},{"problem":153,"code":"(fn disjoin? [sets]\n  (reduce (fn [acc inter]\n            (if (or (not acc) (not-empty inter))\n              false\n              acc)) true\n          (for [s1 sets\n                s2 sets\n                :when (not= s1 s2)]\n            (clojure.set/intersection s1 s2))))","user":"54ca93abe4b057c6fda3a264"},{"problem":153,"code":"(fn disjoint [xs] \n\t(empty? (for [x xs y xs :when (and (not= x y) (not-empty (clojure.set/intersection x y)))] [x y])))","user":"52e657e4e4b09f7907dd1472"},{"problem":153,"code":";(fn pairwise-disjoin [sets]\n;  (every? (partial = 1) (vals (frequencies (apply concat sets)))))\n#(apply distinct? (apply concat %))","user":"57407ab3e4b05c31a32c0854"},{"code":"(fn[s] (= (count(set(reduce concat s))) (reduce + (map #(count %) s))))","problem":153,"user":"5307e4ece4b02e82168697a9"},{"problem":153,"code":"(fn [sets]\n  (let [disjoint #(empty? (clojure.set/intersection % %2))]\n    (every? true?\n            (map #(apply disjoint %)\n                 (partition 2 1 sets)))))","user":"5a080bdde4b01bb0ae8afde9"},{"code":"(fn [s] (let [c (apply concat s)] (= (count c) (count (into #{} c)))))","problem":153,"user":"50c75d38e4b00bb60fe0c532"},{"problem":153,"code":"(fn [x]\n  (every? false? (for [s1 x\n                      s2 x\n                      a s1\n                      b s2\n                      :when (not= s1 s2)]\n                  (= a b))))","user":"525cc912e4b0cb4875a45d48"},{"code":"(fn [s]\n  (every? (fn [[k v]] (= 1 v))\n    (apply merge-with +\n      (map #(zipmap % (repeat 1)) s))))","problem":153,"user":"509160dae4b0742c82730aef"},{"problem":153,"code":"(fn [x] (empty? (filter #(not (empty? (apply clojure.set/intersection %))) (for [a x b x :when (not= a b)] [a b]))))","user":"52faec2ee4b047fd55837004"},{"code":"(fn disjoint- [coll]\n  ^{:doc \"153. Given a set of sets, create a function which returns                                                                                                                                                \n  true if no two of those sets have any elements in common and false                                                                                                                                               \n  otherwise.\"}\n  (=\n   (count (reduce clojure.set/union coll))\n   (reduce + (map count coll))))","problem":153,"user":"4e5eb843535d8a8b8723a2d4"},{"problem":153,"code":"(fn[col](every? empty? (map (fn[el](reduce clojure.set/intersection el))  (for [item1 col item2 col] (if (not= item1 item2) [item1 item2] [#{}])))))","user":"59692530e4b069c0a1a197e4"},{"code":";(fn pairwise-disjoint?\n;  [sets]\n;  (if (or ((complement set?) sets) (empty? sets))\n;    true\n;    (let [s1 (first sets)\n;          s2 (second sets)\n;          intersect (clojure.set/intersection s1 s2)\n;          union (clojure.set/union s1 s2)\n;          srest (set (drop 2 sets))]\n;      (if (empty? intersect)\n;        (if (empty? srest)\n;          true\n;          (pairwise-disjoint? (merge  srest union)))\n;        false\n;        ))))\n\n#(apply distinct? (apply concat %))","problem":153,"user":"524f4256e4b0541d1855b808"},{"code":"(fn __ [m]\n  (= (reduce + (map count m)) \n     (count (into #{} (apply concat m)))))","problem":153,"user":"4ec9549d535d6d7199dd36fe"},{"code":"#(let [s (for [x % i x] i)]\n   (= (count s) (count (set s))))","problem":153,"user":"507b7dbee4b09034bfeeb71e"},{"code":"(fn [s]\n  (=\n    (reduce #(+ (count %2) %) 0 s)\n    (count (reduce clojure.set/union s))))","problem":153,"user":"50eebf46e4b06330c1f87c61"},{"code":"(fn pds [ss]\n  (let [[x & xs] (seq ss)]\n    (cond (nil? xs) true\n          (every? #(and (not (and (contains? x nil) (contains? % nil))) \n              (= (count x) (count (remove % x)))) xs)\n            (pds xs)\n          :else false)))","problem":153,"user":"5063fe48e4b075d771da6f9e"},{"problem":153,"code":"(fn [s] (= (count (apply clojure.set/union s)) (count (mapcat seq s))))","user":"5e246f92e4b05b4b01516150"},{"problem":153,"code":"(fn [col]\n  (=\n    (count (reduce #(apply conj % %2) col))\n    (apply + (map count col))\n  )\n)","user":"5da20e73e4b000c986472be1"},{"problem":153,"code":"(fn [s]\n  (=\n    (count\n      (apply concat '() s))\n    (count\n      (apply clojure.set/union s))))","user":"56d4b22de4b0ea9b8538f7bb"},{"code":"(fn [set-of-sets]\n   (let [els (apply concat set-of-sets)]\n     ( = (count els)\n         (count (apply conj #{} els)))\n     )\n   )","problem":153,"user":"4ea31da2535d7eef308072c1"},{"problem":153,"code":"(fn [s] \n  (every? empty? (reduce (fn [r e] (map #(clojure.set/intersection e %1) (disj s e))) #{} s))\n)","user":"55eeb37ae4b0121d4835fdf3"},{"problem":153,"code":"(fn yes? [x] \n  (or \n   (empty? x)\n   (and (yes? (rest x))\n        (let [a (first x)\n              s (rest x) ]\n          (empty? (some #(clojure.set/intersection a %) s))\n          )\n        )\n   )\n  )","user":"54a1d643e4b09f271ff37c50"},{"code":"#(every? (fn [e] (= 1 (count (filter (partial some e) %)))) %)","problem":153,"user":"51e58e02e4b0efabf93c02d0"},{"problem":153,"code":"(fn stuffs [x]\n(let [a (mapcat #(identity %) x)\n      b (into #{} a)]\n  (if (= (count a) (count b))\n    true\n    false)))","user":"5c1d9f05e4b0efcb0b05b24c"},{"problem":153,"code":"(fn mutuallyDisjoint [xs]\n         (= (count (reduce clojure.set/union xs))\n            (reduce + (map count xs))))","user":"58c4492be4b021aa9917ed27"},{"problem":153,"code":"(fn [coll]\n  (apply distinct? (mapcat #(into () %) coll)))","user":"57ee2b3ee4b0bfb2137f5bac"},{"problem":153,"code":"(fn disjointX [x] (if (empty? x) true (and (\n\n(fn disjointN [x y] (every? #(\n\n(fn disjoint2 [x y] (not-any? (fn[a] (contains? y a)) x)) \n\nx %) y))\n\n(first x)(rest x))(disjointX (rest x)))))","user":"568820e8e4b0dcc4269f4067"},{"problem":153,"code":"(fn disjoint [sets]\n    (loop\n        [[cur & rest] (vec sets)]\n        (cond\n            (nil? cur) true\n            (some #(not (empty? (clojure.set/intersection % cur))) rest) false\n            :else (recur rest))))","user":"551afdf8e4b07993ea3788cb"},{"problem":153,"code":"(fn [s]\n  (every? empty?\n          (for [x s,\n                y (disj s x)]\n            (clojure.set/intersection x y))))","user":"54848141e4b0e286459a119e"},{"problem":153,"code":"(fn pairwise-disjoint [coll]\n  (= (apply + (map count coll))\n     (count (reduce clojure.set/union coll))))","user":"5aeca4c9e4b0cc2b61a3bc0a"},{"problem":153,"code":"(fn [s] \n  ((fn disjoint? [[f & xs]]\n     (if (nil? xs) \n     \ttrue \n        (and (every? empty? (map (partial clojure.set/intersection f) xs))\n             (disjoint? xs))))\n   (seq s)))","user":"5eee7311e4b07c55ae4a0510"},{"problem":153,"code":"(fn pds [sets] (not\n                  (some true?\n                        (map-indexed\n                         (fn [idx1 itm1]\n                           (some #(not (empty? %))\n                                 (map-indexed (fn [idx2 itm2]\n                                                (when (not= idx1 idx2)\n                                                  (clojure.set/intersection itm1 itm2)))\n                                              sets)))\n                         sets))))","user":"563f4c47e4b08d4f616f5ed2"},{"problem":153,"code":"(fn [big_set](loop [[x & xs] (vec big_set) result true]\n          (if (or (not result) (empty? xs)) result\n          (recur xs (every? true? (map (fn [ar] (if (empty? (clojure.set/intersection x ar)) true false)) xs))))))","user":"54e4edcae4b024c67c0cf7f3"},{"problem":153,"code":"(fn [xs]\n  (every? true? \n    (for [x xs\n          y xs\n          :when (not= x y)]\n      (empty? (clojure.set/intersection x y)))))","user":"583369e6e4b089d5ab817c9c"},{"code":"(fn [s]\n  (let [all (apply concat s)]\n    (=\n      (count (vec all))\n      (count (set all)))))","problem":153,"user":"4f253a49e4b0d66497709ff3"},{"problem":153,"code":"(fn pairwise-disjoint? [set-of-sets]\n                          (every?\n                            (fn [[s1 s2]] (empty? (clojure.set/intersection s1 s2))) (partition 2 1 set-of-sets)))","user":"561814bae4b06b1bb2182a1a"},{"problem":153,"code":"(fn [inp] (->> inp\n     (apply clojure.set/union)\n     count\n     (= (reduce #(+ % (count %2)) 0 inp))))","user":"5ec3a13ae4b08d0ec38692b9"},{"problem":153,"code":"(fn pair-disjoint\n  [s]\n  (== (reduce #(+ %1 (count %2)) 0 s)\n      (count (reduce clojure.set/union s))))","user":"56912f93e4b0dcc4269f40ef"},{"problem":153,"code":"(fn [s] (= (apply + (map count s)) (count (apply clojure.set/union s))))","user":"4e5e9f6b535d8a8b8723a2d2"},{"code":"(let [disjoint? (fn [a b] \n        (= (+ (count a) (count b)) (count (set (concat a b)))))\n      triangular (fn thisfunc [c] \n        (if (empty? c) []\n            (concat (map #(vector (first c) %) (rest c)) (thisfunc (rest c)))))]\n(fn [s]\n  (every? (partial apply disjoint?) (triangular s))))","problem":153,"user":"4dd9d299535d2dad7130b5dd"},{"code":"#(= (count (apply clojure.set/union %1)) (apply + (map count %1)))","problem":153,"user":"4f17ab99535d64f603146457"},{"problem":153,"code":"#(every? empty? \n         (for [s1 % s2 % :when (not= s1 s2)] \n           (clojure.set/intersection s1 s2)))","user":"574dfcb8e4b02ea11479923a"},{"problem":153,"code":"(fn disjoint? [s]\n  (let [all-pairs (for [x s y s] (if (identical? x y) [{} {}] [x y]))\n        intersections (map #(apply clojure.set/intersection %) all-pairs)]\n    (every? empty? intersections)))","user":"56069006e4b08b23635d3174"},{"code":"(fn\n  [s]\n  (let [x (vec s)]\n    (every? (fn [[u v]]\n              (empty? (clojure.set/intersection u v))) (map (fn [[i j]]\n                                                              [(get x i) (get x j)]) (for [i (range (count s))\n                                                                                           j (range (inc i) (count s))]\n                                                                                       [i j])))))","problem":153,"user":"4fe9ea87e4b0547ebccb2476"},{"code":"(fn [s] (= \n  (count (set (reduce #(concat %1 %2) #{} s)))\n  (reduce + (map count s))         \n))","problem":153,"user":"4f148418535d64f60314643a"},{"code":"#(every? empty? (for [x % y % :when (not (= x y))] (clojure.set/intersection x y)))","problem":153,"user":"4ff3df0fe4b0678c553fc355"},{"problem":153,"code":"(fn [s]\n    (let [itsc (comp empty? clojure.set/intersection )]\n      (loop [[a & r] (seq s) ]\n        (let [dam (reduce #(and  % (itsc %2 a)) true r)]\n        (cond (not dam)  false\n              (empty? r) dam\n              :else (recur r)\n        )\n        )\n        )\n      )\n     )","user":"5735ac67e4b0cd1946bd102b"},{"problem":153,"code":"(fn [sets] (every? true? (for [x sets y sets] (if (= x y) true (empty? (clojure.set/intersection x y))))))","user":"53e19461e4b0d874e779ae59"},{"code":"#(every? empty? (for [i % j % :while (not= i j)] (clojure.set/intersection i j)))","problem":153,"user":"52c6a0abe4b0c2d177d62111"},{"problem":153,"code":"(fn [l]\n\t(reduce (fn [bool nxt]\n\t\t (reduce\n\t\t  #(if (= nxt %2)\n\t\t     (and bool true)\n\t\t     (and bool (empty? (clojure.set/intersection %2 nxt)))) true l)) true l))","user":"53da3fcde4b0e771c3025497"},{"problem":153,"code":"#(loop [union #{} coll (apply concat (seq %))]\n   (if-let [s (seq coll)]\n     (if (= (get union (first s) ::not-found) ::not-found)\n\t\t(recur (conj union (first s)) (rest s))\n       false)\n     true))","user":"59074b7ce4b047aa04b19951"},{"problem":153,"code":"(fn [sets]\n    (= (count (apply clojure.set/union sets))\n       (reduce + (map count sets))))","user":"516db4f6e4b046df6fbb76a0"},{"problem":153,"code":"(fn [sets]\n  (second\n    (reduce\n      (fn [[acc ok?] s]\n        (cond \n          (not ok?) [acc false]\n          :else\n          [(into acc s)\n            (every? not (map #(contains? acc %) s))]))\n      [#{} true]\n      sets)))","user":"504e71cbe4b0f6ff3350c4b3"},{"problem":153,"code":"(fn [s]\n    (= \n      (count (apply clojure.set/union s))\n      (reduce #(+ %1 (count %2)) 0 s)))","user":"5bbbce0ee4b0a20761a2360d"},{"code":"#(every? empty? (for [x % y (disj % x)] (clojure.set/intersection x y)))","problem":153,"user":"523d02b0e4b0dbf0c3017289"},{"problem":153,"code":"#(every? \n   empty? \n   (for [x % y % :when (not= x y)]\n    (clojure.set/intersection x y)))","user":"57f0f7b8e4b0bfb2137f5bfe"},{"problem":153,"code":"(fn [sets]\n    (= 1 (apply max (vals (frequencies (mapcat (fn [s] \n            (map (fn [el] (if (coll? el) \n                              (set el) \n                              el))\n                            s)) sets))))))","user":"58ffaddee4b0438e51c2cffe"},{"problem":153,"code":"(fn pairwise-disjoint [set-of-sets]\n  (or\n    (empty? set-of-sets) \n    (let [examined-set   (first set-of-sets)\n         remaining-sets  (rest set-of-sets)\n         disjoint-map    (map #(clojure.set/intersection examined-set %) remaining-sets)\n         disjoint        (every? empty? disjoint-map)]\n      (and disjoint (pairwise-disjoint remaining-sets))\n)))","user":"54bbe505e4b0ed20f4ff6ec5"},{"problem":153,"code":"#(let [x (reduce into (for [s %] (seq s)))]\n    (= (count x) (count (set x))))","user":"54d753ebe4b0a52adc2e2029"},{"problem":153,"code":"(fn [sets]\n  (= (count (apply clojure.set/union sets))\n     (reduce + (map count sets))))","user":"52470d42e4b05ef8e38e6350"},{"code":"(fn [xs]\n  (loop [[a & rest] (seq xs)]\n  (cond (empty? rest) true\n        (every? #(empty? (clojure.set/intersection a %)) rest)\n            (recur rest)\n        true false)))","problem":153,"user":"4fe8aef4e4b07c9f6fd12c6c"},{"problem":153,"code":"(fn mutually-disjoint [coll]\n  (not (some #(seq %)\n             (map #(let [[s1 s2] %] (clojure.set/intersection s1 s2))\n                  (for [s1 coll\n                        s2 coll\n                        :when (not= s1 s2)]\n                    [s1 s2])))))","user":"5c547cf0e4b0fb8c5ffd9a0b"},{"problem":153,"code":"(fn [s]\n  (not (some #(> (second %) 1) \n               (apply merge-with + \n                      (map frequencies s)))))","user":"5e3a25d4e4b01d43a70e8dde"},{"problem":153,"code":"(fn pairwise-disjoint-sets [ss]\n  (= (reduce + (map count ss))\n     (count (reduce into #{} ss))))","user":"55fbc657e4b0f488688e0666"},{"problem":153,"code":"(fn [ss] \n (every? (fn [s2] (empty? (clojure.set/intersection (first s2) (second s2)))) (into #{} (for [x ss, y ss\n   :when (not (identical? x y))] #{x y}))))","user":"57f9011ee4b0d3187e900935"},{"code":"(fn [s]\n  (= \n    (count (reduce \n      #(if (empty? %2) %1\n          (apply (partial conj %1) %2)) #{} s)) (apply + (map count s))))","problem":153,"user":"4dad76588e77d6ed63f12a44"},{"code":"(fn [s] \n  (let [k (mapcat identity s)]\n    (= (count k) (count (seq (set k))))))","problem":153,"user":"4fdb02aae4b05e33b9224f56"},{"code":"(fn [coll]\n  (= (count (apply clojure.set/union coll))\n     (reduce (fn [n s] (+ n (count s))) 0 coll)))","problem":153,"user":"5213d7aae4b0961f15ac4d72"},{"problem":153,"code":"(fn pairwise-disjoint? [sets]\n  (every? true?\n          (for [s1 sets, s2 sets :when (not= s1 s2)]\n            (empty? (clojure.set/intersection s1 s2)))))","user":"5b51b9f8e4b02d533a91bcfe"},{"code":"(fn [sos] (let [uber (reduce #(into %1 %2) #{} sos)\n                total (reduce + (map count sos))]\n  (= (count uber) total)))","problem":153,"user":"4fe900a6e4b0547ebccb243a"},{"code":"(fn [tst]\n       (not\n       (some false?\n       (for [i tst j tst :when (not (= i j))]\n         (empty? (clojure.set/intersection i j))))\n       ))","problem":153,"user":"5124619ae4b02c3f2a072ccd"},{"problem":153,"code":"#(every? identity (for [x % y % :when (not= x y)] (empty? (clojure.set/intersection x y))))","user":"51a132cee4b0b292b01ee3ff"},{"code":"(fn [ss]\r\n  (every? identity\r\n    (for [s ss t ss :when (not (identical? s t))]\r\n      (loop [i s b true]\r\n        (if (empty? i) b\r\n          (recur (rest i) (and b (= :shh (get t (first i) :shh)))))))))","problem":153,"user":"5050b107e4b063148f524126"},{"code":"(fn problem-153\n  [set-of-sets]\n  (letfn [(intersect \n\t\t\t\t\t  [s1 s2]\n\t\t\t\t\t  (loop [acc #{}\n\t\t\t\t\t         st1 s1]\n\t\t\t\t\t    (if (empty? st1)\n\t\t\t\t\t      (disj acc :none)\n\t\t\t\t\t      (recur (conj acc (get s2 (first st1) :none)) (next st1)))))]\n\t  (let [res (for [s1 set-of-sets\n\t        s2 set-of-sets\n\t        :when (not (= s1 s2))] \n\t    (empty? (intersect s1 s2)))] (apply (partial = true) res))))","problem":153,"user":"52319066e4b0e2e8de81d1e9"},{"problem":153,"code":"(fn [ss]\n    (->> (for [s1 ss s2 ss :when (not= s1 s2)]\n           (== (+ (count s1) (count s2))\n               (count (set (concat s1 s2)))))\n         (every? true?)))","user":"5c995fa4e4b048ec896c5a96"},{"problem":153,"code":"(fn pair-disjoint [ss]\n  (let [ss-indexed (map-indexed list ss)\n        disjoint? (fn [x y] (empty? (clojure.set/intersection x y)))]\n    (every? identity\n      (for [x ss-indexed y ss-indexed :when (not= (first x) (first y))]\n        (disjoint? (second x) (second y)))\n      )))","user":"52ee0de4e4b05e3f0be25ec1"},{"problem":153,"code":"#(apply distinct? (mapcat set %))","user":"5a99b863e4b0d174b936c7ae"},{"problem":153,"code":"(fn pairwise-disjoint-sets?\n  [set-of-sets]\n  (->> set-of-sets\n       (map (fn [s]\n              (map (partial clojure.set/intersection s)\n                   (disj set-of-sets s))))\n       flatten\n       (every? empty?)))","user":"551bdefde4b07993ea3788d7"},{"problem":153,"code":"#(every? empty? (for [a % b % :when (not= a b)] (clojure.set/intersection a b)))","user":"56bca51ae4b0f26550335963"},{"problem":153,"code":"(fn [s]\n  (empty? (filter (complement empty?) \n                  (for [x s y s\n                        :when (not= x y)] \n                    (clojure.set/intersection x y)))))","user":"5405ae2be4b0addc1aec6671"},{"problem":153,"code":"(fn [x]\n  (let [xs (apply concat x)]\n    (= (count xs)\n       (count (set xs)))))","user":"5486e317e4b0e286459a11c0"},{"problem":153,"code":"(fn  [x]\n  #_=>   (let [y (into [] x)]\n  #_=>     (= (count (apply clojure.set/union y))  (apply + (map count y)))))","user":"50b25f2ce4b03ea88043355f"},{"problem":153,"code":"#(let [raw  (apply concat %)\r\n       proc (set raw)]\r\n  (= (count raw) (count proc)))","user":"55d0e76ae4b0e31453f64a40"},{"code":"(fn [sos]\n    (not-any? seq \n      (for [s sos :let [rest (disj sos s)]] \n        (mapcat #(clojure.set/intersection s %) rest))))","problem":153,"user":"4e6f578c535d5021c1a8961b"},{"problem":153,"code":"(fn pairwise-disjoint? [ss]\n  (loop [sets ss]\n    (let [test (first sets) others (next sets)]\n      (if (empty? others)\n        true\n        (if (= test (apply clojure.set/difference test (set others)))\n          (recur others)\n          false)))))","user":"5c950334e4b048ec896c5a44"},{"problem":153,"code":"(fn pairwise-disjoint [sets] (false? (first (reduce #(let [[notPairwiseDisjoint? setUnion] %1]\n                                                         (if (true? notPairwiseDisjoint?) \n                                                            [true %2])\n                                                            [(not (empty? (clojure.set/intersection setUnion %2)))\n                                                              ( clojure.set/union setUnion %2)])\n                                                      [false #{}]\n                                                      sets))))","user":"5d45bd1de4b07c84aa5ae6a4"},{"code":"#(= (count (apply clojure.set/union %))\n    (reduce + (map count %)))","problem":153,"user":"4e6e2ac4535d5021c1a895ff"},{"problem":153,"code":"(fn pds [set-of-sets]\n(every? #(= (second %) 1)\n\t(reduce \n\t#(merge-with + %1 (reduce (fn[res, elem] \n\t\t\t(if (contains? res elem)\n\t\t\t\t(assoc res elem (inc (get res elem)))\n\t\t\t\t(assoc res elem 1)\n\t\t\t)\n\t\t\t) {} %2))\n\t{} set-of-sets)\n))","user":"5559b443e4b0deb715856e3c"},{"problem":153,"code":"(fn pairwise-disjoint [s]\n  (or (< (count s) 2)\n      (and (every? #(empty? (clojure.set/intersection (first s) %)) \n                   (rest s))\n           (pairwise-disjoint (set (rest s))))))","user":"53acaf1fe4b047364c04445f"},{"code":"#(= (apply max (vals (apply merge-with + (map frequencies %)))) 1)","problem":153,"user":"4fd7962ee4b0dab7d829f385"},{"problem":153,"code":"(fn disjoint? [s]\n  (let [ss (seq s)\n        length (count ss)]\n    (every? empty? (for [s1 (range length)\n                         s2 (range length)\n                         :when (not= s1 s2)]\n                     (clojure.set/intersection (nth ss s1) (nth ss s2))))))","user":"51bfc1f0e4b0e49ef9037dd4"},{"code":"(fn [s] \n   (let [intersect? (fn [s1 s2] (for [e1 s1] (contains? s2 e1)))]\n     (not (reduce #(or %1 %2) false \n       (flatten \n          (for [a s b (disj s a)] (intersect? a b)))))))","problem":153,"user":"4f69f34fe4b07046d9f4ef90"},{"problem":153,"code":"(fn pairwise-disjoint [x]\n  (=\n   (count\n    (apply concat '() x))\n   (count\n    (apply clojure.set/union x))))","user":"5e9771dee4b0157ca96647d0"},{"problem":153,"code":"#(= 1 (last (sort (vals (frequencies (reduce (fn [a b] (reduce conj a b)) [] % ))))))","user":"5661b0a9e4b068f2fe63dc6f"},{"code":"(fn n153 [s]\n  (nil? (some (partial not= #{}) (for [x s y s :when (not= x y)] (clojure.set/intersection x y)))))","problem":153,"user":"52b43468e4b0c58976d9ad1b"},{"code":"(fn [s] (not(contains?(set(for [x s y s] (if (= x y) true ((fn pairwise_disjoint [s1 s2] (= (count (into s1 s2) ) (+ (count s1) (count s2)  ) )) x y) ) ))false) ))","problem":153,"user":"4e8d5edd535d65386fec2134"},{"problem":153,"code":";(fn [set-of-sets] (last (reduce\n;                         #(let [prev-set (first %1)\n;                                next-set (apply merge prev-set %2)]\n;;                            (do (println \"---\")\n;;                                (println (+ (count prev-set) (count %2)))\n;;                                (println (count next-set))\n;                            [next-set\n;                             (and\n;                              (last %1)\n;                              (= (+ (count prev-set) (count %2))\n;                                 (count next-set)))])\n;;                              )\n;                         [#{} true]\n;                         set-of-sets)))\n\n;better sol'n:\n(fn [xs]\n  (= (count (reduce into #{} xs))\n     (apply + (map count xs))))","user":"5af31955e4b0cc2b61a3bc7a"},{"code":"(fn [s]\n\t\n\t(= 0 (count\n\t\t(filter #(> (count (clojure.set/intersection (first %) (second %))) 0)\n\t\t\t(filter #(= 2 (count %))\n\t\t\t\t(for [one (seq s) two (seq s)] (set (list one two))))))))","problem":153,"user":"4f47eab2e4b0d56e7bb92bc6"},{"problem":153,"code":"(fn pairwise-disjoint-sets? [sts]\n  (letfn [(aux [cur-full-set ss]\n            (cond (empty? ss)\n                  true\n\n                  (empty? (clojure.set/intersection cur-full-set (first ss)))\n                  (aux (clojure.set/union cur-full-set (first ss)) (rest ss))\n\n                  :else\n                  false))]\n    (aux #{} sts)))","user":"568e1871e4b0dcc4269f40cc"},{"problem":153,"code":"(fn dist [x] (loop [remX x finals true]\n  (if (empty? remX)\n    finals\n    (let [fir (first remX)\n          rrr (rest remX)\n          dps (set rrr)\n          dup (repeat (count rrr) fir)\n          ]\n      (letfn [(noCommon [s1 s2] (empty? (clojure.set/intersection s1 s2)))]\n      (recur dps\n             (and finals (not-any? false? (map noCommon dup rrr)))))))))","user":"57b35ecbe4b0fbc9809a277e"},{"code":"apply (fn [& sets]\n  (let [all (reduce #(into % %2) sets)]\n    (every?\n      (fn [item]\n        (= 1\n          (count (filter #(contains? % item) sets))))\n      all)))","problem":153,"user":"50657775e4b0deb876850599"},{"code":"(fn check [ss] (if (empty? ss) true (and (empty? (clojure.set/intersection (first ss) (apply clojure.set/union (rest ss)))) (check (rest ss)))))","problem":153,"user":"50fbdacfe4b0d10d794c19f0"},{"code":"(fn [s]\n    (loop [seen (first s)\n           todo (rest s)]\n      (if-let [t (first todo)] \n        (if (some #(.contains seen %) t)\n          false\n          (recur (into seen t) (rest todo)))\n        true)))","problem":153,"user":"4e6a0667535d8ccf87e9fe9e"},{"problem":153,"code":"(fn pairwise-disjoint?' [ss]\n  (letfn [(all-pairs' [coll]\n            (when-let [s (next coll)]\n              (lazy-cat (for [y s] [(first coll) y])\n                        (all-pairs' s))))]\n    (->> (all-pairs' ss)\n         (map (partial apply clojure.set/intersection))\n         (not-any? seq))))","user":"563fc1f2e4b08d4f616f5ed7"},{"problem":153,"code":"(fn[s]\n  (= (apply + (map count s)) (count (distinct (remove set? (tree-seq set? identity s)))))\n)","user":"591e0782e4b09b4ee5954c25"},{"code":"(fn[s]\n   (every? false? (mapcat #(mapcat (fn[t](map (fn [m] (contains? t m))%)) (disj s %))\n        s)))","problem":153,"user":"4e778d36535d324fb2983d71"},{"problem":153,"code":"(fn [x]\n  (= (count (distinct (apply concat x))) (apply + (map count x))))","user":"5a6a7cc5e4b0512ff01cda27"},{"code":"(fn [s]\n  (->> s\n       (mapcat identity)\n       frequencies\n       vals\n       (every? #(= % 1))))","problem":153,"user":"50217818e4b00bba4502f7a7"},{"problem":153,"code":"(fn disjoint?\n  [sosets]\n  (let [vosets (into [] sosets)\n        uni (apply clojure.set/union vosets)]\n    (= (apply + (map #(count %) vosets)) (count uni))))","user":"550d9452e4b06e50f9beb15d"},{"problem":153,"code":"#(every? empty? \n          (for [s %\n                y %\n                :when (not= s y)]\n            (clojure.set/intersection s y)))","user":"4e38f245535deb9a81d77f3e"},{"problem":153,"code":"(fn pair-wise-disjoints [sets]\n  (let [ss (reduce clojure.set/union #{} sets)\n        len (apply + (map count sets))]\n    (= (count ss) len)\n    )\n  )","user":"54d70f40e4b0a52adc2e2027"},{"code":"(fn disjoint [xs]\n  (if (empty? xs) true\n    (if (some #(some (partial contains? (first xs)) %) (rest xs)) false\n      (disjoint (rest xs)))))","problem":153,"user":"50a2f901e4b029e8bace362a"},{"code":"(fn disj [sets] (\n  letfn [(disjunct? [a b] (and (= -1 (.indexOf (vec a) nil)) (empty? (#(set (filter a b))))))]\n(every? #(or (= (% 0)(% 1))(disjunct? (% 0) (% 1))) (for [x (vec sets) y (vec sets)] [x y]))\n))","problem":153,"user":"4fca1cd6e4b0ee37620e184c"},{"problem":153,"code":"(fn [s]\n  (let [cu (->> s\n               (reduce clojure.set/union #{})\n               (count))\n        cui (->> s\n                 (map #(count %))\n                 (reduce + 0))]\n    (if (= cu cui) true false)))","user":"60aecd73e4b00e9e6653c49a"},{"code":"(fn\n  [s]\n  (every? true?\n          (for [x s y (disj s x)]\n            (empty? (clojure.set/intersection x y)))))","problem":153,"user":"4db53f87535d87e67b28fe08"},{"problem":153,"code":"(fn [x]\n  (loop [result #{} s1 (first x) s2 (drop 1 x)]\n    (if (empty? s2)\n      (= (count result) 1) \n      (recur (conj result (map #(clojure.set/intersection s1 %) (disj x s1))) (first s2) (drop 1 s2)))))","user":"54e24a05e4b024c67c0cf7ce"},{"code":"(fn [sets]\n  (every? empty?\n    (map (fn [[x y]] (clojure.set/intersection x y))\n      (for [x sets y sets :when (not (identical? x y))] \n        [x y]))))","problem":153,"user":"5012ec0ae4b0c87326002230"},{"problem":153,"code":"(fn f [s]\n  (let [head (first s)\n        tail (rest s)]\n    (cond\n      (nil? tail) true\n      (empty? tail) true\n      (every? true? (map #(empty? (clojure.set/intersection head %)) tail)) (f tail)\n      :else false)))","user":"5794fd7be4b0e215f87e8476"},{"problem":153,"code":"#( let [ n (count %) a (vec %)]\n   ( loop [ ii 0 ]\n     ( let [ i (quot ii n) j (mod ii n) ]\n       ( if (>= ii (* n n))\n         true\n         ( if (or (= i j) (empty? (clojure.set/intersection (nth a i) (nth a j))))\n           (recur (inc ii))\n           false\n          )\n         )\n       )\n     )\n   )","user":"5b3aa98be4b02d533a91bbca"},{"problem":153,"code":"(fn [s] (every? empty? (for [x s y s :when (not= x y)] (clojure.set/intersection x y))))","user":"4fd11a93e4b04c3a95aa040a"},{"code":"(fn [sos]\n  (= (count (reduce clojure.set/union sos))\n     (reduce + (map count sos))))","problem":153,"user":"5055e7f4e4b0ce54f56f0401"},{"code":"(fn pairwise-disjoint [sets]\n  (every? true?\n          (for [x sets, y sets :when (not= x y)]\n            (empty? (clojure.set/intersection x y)))))","problem":153,"user":"4eae5fe4535d7eef30807325"},{"code":"(fn pw-dj-sets [coll]\n  (= (count (apply clojure.set/union coll))\n     (reduce #(+ %1 (count %2)) 0 coll)))","problem":153,"user":"511e763ce4b03e81d390ac29"},{"problem":153,"code":"(fn [col]\n  (let [x (for [a col b col\n                 :when (not (identical? a b))]\n             (clojure.set/intersection a b))]\n    (every? empty? x)))","user":"5489dd4de4b0e286459a11ef"},{"code":"(fn [sets]\n  (= (reduce + (map count sets))\n     (count (set (apply concat (map vec sets))))))","problem":153,"user":"4f1bb9d8535d64f60314647d"},{"code":"(fn [s]\n  (=\n    (count (reduce clojure.set/union s))\n    (reduce #(+ %1 (count %2)) 0 s)))","problem":153,"user":"5191ac45e4b0d428d29dc1b6"},{"code":"(fn [sets]\n  (let [all (apply concat sets)]\n      (= (count all) (count (distinct all)))))","problem":153,"user":"4f03154a535dcb61093f6a58"},{"problem":153,"code":"(fn [sets] \n  (= (reduce + (map count sets))\n     (count (reduce  clojure.set/union sets))\n     )\n  )","user":"53d5d43ce4b0e771c302544d"},{"code":"(fn [s] (every? empty? (for [s1 s s2 s :when (not= s1 s2)] (clojure.set/intersection s1 s2))))","problem":153,"user":"525f51bde4b0cb4875a45dc8"},{"problem":153,"code":"(fn pairwise-disjoint-x? [sets]\n   (every? true? (for [a sets b sets :when (not= a b)]\n                  (empty? (clojure.set/intersection a b))\n                  )))","user":"56f2611fe4b04a395b9a04a2"},{"problem":153,"code":"(fn\n  [sets]\n  (= (reduce + (map count sets))\n     (count (reduce clojure.set/union sets))))","user":"57235dc4e4b0c5bde472c0e2"},{"code":"(fn [s]\n    (every? empty? (for [s1 s\n                         s2 s :when (not= s1 s2)]\n                     (clojure.set/intersection s1 s2))))","problem":153,"user":"4ee26f01535d10e5ff6f5368"},{"problem":153,"code":"(fn [input]\n  (every? true?\n          (for [i input j (disj input i)] \n            (empty? (clojure.set/intersection i j)))))","user":"536e5055e4b0fc7073fd6e6b"},{"code":"(fn [s]\n  (loop [[t & r] (seq s)]\n    (if (empty? r) true\n      (if (some seq (map #(clojure.set/intersection t %) r))\n        false\n        (recur r)))))","problem":153,"user":"4e5fe31a535d8ccf87e9fe50"},{"code":"(fn myfn [s]\n\t(first (reduce \n     \t(fn [x y]\n        \t(if-not (first x) x\n            \t(reduce\n                 \t(fn [z w]\n                    \t(if-not (first z) z\n                        \t(if (contains? (second z) w) [false #{}] [true (conj (second z) w)]\n                            )\n                        )\n                    )\n                 \tx y\n                )\n            )\n        )\n   \t\t[true #{}]\n     \ts\n    ))\n)","problem":153,"user":"525ba7bbe4b0cb4875a45d28"},{"problem":153,"code":"(fn [xs] (->> (for [a xs b xs] [a b])\n               (filter #(apply not= %))\n               (filter #(seq (apply clojure.set/intersection %)))\n               (empty?)\n               ))","user":"5ce62d8ee4b0a17bb84e2b83"},{"code":"(fn [sets] (= (apply + (map count sets))\n              (count (set (apply concat sets)))))","problem":153,"user":"5216933be4b000d124d989cf"},{"code":"(fn [sets] (every?\n            (fn [s] (every?\n                     (fn [ss] (empty? (clojure.set/intersection s ss)))\n                     (disj sets s)))\n            sets))","problem":153,"user":"510acd6ee4b078ea719210f4"},{"code":"(fn [sets]\n  (loop [xs (apply concat sets)\n         seen #{}]\n    (if-let [[x & xs] (seq xs)]\n      (if (contains? seen x)\n        false\n        (recur xs (conj seen x)))\n      true)))","problem":153,"user":"4e593dac535d8a8b8723a29c"},{"problem":153,"code":"(fn  [s]\n  (=\n    (count\n      (apply concat '() s))\n    (count\n      (apply clojure.set/union s))))","user":"57f81524e4b0d3187e900913"},{"code":"(fn disjoint-sets? [s]\n   (let [size_in (apply + (map count s))\n         union (apply clojure.set/union s)]\n     (= size_in (count union))\n     )\n   )","problem":153,"user":"51d9eb05e4b02ceefd947755"},{"code":"#(== \n   (count (reduce into %))\n   (reduce + (map count %)))","problem":153,"user":"504e397ee4b0f6ff3350c485"},{"code":"(fn [sset]\n   (= (count (reduce clojure.set/union sset))\n     (reduce + (map #(count %) sset ))\n     )\n   )","problem":153,"user":"5106dc1be4b01150e115ebf0"},{"problem":153,"code":"(fn [sets]\n  (let [union (->> sets\n                   (reduce clojure.set/union)\n                   (count)\n                   )\n          conc (->> sets \n                    (map count)\n                    (reduce +))]\n         (= union conc)\n   )\n  )","user":"60752ef6e4b069485764de55"},{"problem":153,"code":"(fn [sets](if (some true?\n         (flatten (for [x sets y sets :when (not= x y)]\n           (for [x-elem x y-elem y] (= x-elem y-elem)))))\n\t\t   false\n\t\t   true))","user":"51eec1a6e4b0871fa145d98d"},{"problem":153,"code":"(fn [ss]\n    (= (count (set (reduce concat ss)))\n       (reduce + (map count ss))))","user":"5310e968e4b08068f379ecdd"},{"problem":153,"code":"(fn [ss] (every? true? (for [s1 ss s2 ss :when (not= s1 s2)] (empty? (clojure.set/intersection s1 s2)))))","user":"559454f2e4b0c79f6e1db952"},{"code":"(fn [sets] (let [v (apply concat (map vec sets))] (= (count v) (count (set v)))))","problem":153,"user":"5275f7a2e4b03e8d9a4a74d0"},{"code":"(fn [sets]\n  (empty? (keep seq (for [s sets :let [rem-sets (disj sets s)] s2 rem-sets] (clojure.set/intersection s s2))))\n  )","problem":153,"user":"51281b25e4b03a34742b4304"},{"code":"(fn [s]\n   (empty?\n      (mapcat\n       (fn [[v w]] (for [k v l w :when (= k l)] [k l]))\n       (for [x s y s :when (not= x y)] [x y]) )))","problem":153,"user":"519b7d76e4b02a926d9a436e"},{"problem":153,"code":"(fn mutually-disjoint [s]\n  (= (reduce #(+ %1 (count %2)) 0 s)\n     (count (reduce #(if (empty? %2) % (apply conj %1 %2)) #{} s))))","user":"549c6792e4b0f3d1d8e70f8b"},{"problem":153,"code":"#(->> (clojure.set/intersection s1 s2)\n       (for [s1 % s2 % :when (not (= s1 s2))])\n       (apply concat)\n       (empty?))","user":"553698fae4b09218d5f44fc0"},{"code":"#(= (reduce (fn [a b] (+ a (count b))) 0 %) (count (apply clojure.set/union %)))","problem":153,"user":"512f06c5e4b0762be4c7aad7"},{"problem":153,"code":"#(= #{1} (set (vals (apply merge-with + (map frequencies %)))))","user":"55fc07d3e4b0f488688e066e"},{"problem":153,"code":"#(let [cal (apply + (map count % )) cun (count (reduce clojure.set/union %))] (= cal cun))","user":"58c71509e4b021aa9917ed6e"},{"code":"(fn [s]\n  (not\n    (some\n      (fn [e]\n        (>\n          (count (filter #(contains? % e) s))\n          1))\n      (apply clojure.set/union s))))","problem":153,"user":"4fb2101ce4b081705acca284"},{"code":"(fn\n  [ss]\n  (empty? (filter (fn [[k v]] (> v 1))\n                  (reduce (fn [m k] (update-in m [k] #(inc (or % 0)))) \n                          {}\n                          (mapcat vec ss)))))","problem":153,"user":"52dfc89be4b09f7907dd1405"},{"problem":153,"code":"(fn [sets]\n  (let [combined (apply clojure.set/union sets)\n        counts (map count sets)]\n    (= (count combined) (reduce + counts))))","user":"5b64370ae4b0c6492753e73c"},{"problem":153,"code":"(fn [x]\n  (let [permutations (into #{}\n                           (for [z x y x\n                                 :when (not= z y)] #{z y}))]\n    (every? true?\n            (for [z permutations\n                  :let [[x y] (vec z)]]\n              (empty? (clojure.set/intersection x y))))))","user":"56012cd7e4b04bb52996e17d"},{"problem":153,"code":"(fn [s] (=\n         (count (apply clojure.set/union s))\n         (reduce #(+ % (count %2)) 0 s) ))","user":"55236ad6e4b0882d96d091b1"},{"problem":153,"code":"(fn pairwise-disjoint? [ss]\n    (= (count (apply clojure.set/union ss))\n       (->> ss (map count) (reduce +))))","user":"4dfe5a93535d04ed9115e786"},{"problem":153,"code":"(fn [ma]\n  (every? empty?\n          (for [x ma\n                y ma\n                :when (not= x y)]\n            (clojure.set/intersection x y))))","user":"5c24671be4b07e362c2305a1"},{"code":"(fn [s]\n  (apply distinct? (mapcat seq s)))","problem":153,"user":"4f849f76e4b033992c121c36"},{"problem":153,"code":"(fn solve [sets]\n  (= (apply + (map count sets))\n     (count (apply clojure.set/union sets))))","user":"60537cd1e4b04c8f2157d152"},{"problem":153,"code":"(fn [s] (every? #(and (seq (first %1)) (not-any? (first %1) (last %1))) (for [a s b s :when (not= a b)] [a b])))","user":"512b07f7e4b078b06821febb"},{"problem":153,"code":"#(= (count (reduce into %))\n    (reduce + (map count %)))","user":"4f5eda39e4b0030a34fb2b56"},{"problem":153,"code":"#(= (apply + (map count %)) (count (reduce into %)))","user":"5416b4a2e4b01498b1a71a01"},{"code":"#(let [l (mapcat set %2)] (= (% l) (% (set l)))) count","problem":153,"user":"4dce6e41535d5973398f92a2"},{"code":"#(let [a (reduce into [] %)] (= (count a) (count (set a))))","problem":153,"user":"4ee9ddb8535d93acb0a66896"},{"code":"#(= (count (reduce into %)) (apply + (map count %)))","problem":153,"user":"4f7431d2e4b044e54cd9a8f7"},{"code":"(fn [input]\n \t(every? #(= 1 %) (vals (frequencies (apply concat (map vec input))))))","problem":153,"user":"536d83cee4b0fc7073fd6e5e"},{"problem":153,"code":"(fn [set-of-sets]\n  (every? empty? (for [x set-of-sets\n                       y set-of-sets\n                       :when (not= x y)]\n                     (clojure.set/intersection x y))))","user":"4fe899a6e4b07c9f6fd12c54"},{"code":"(fn [x]\n  (->>\n    (loop [l x\n         a #{}]\n    (if (empty? l)\n      a\n      (let [r (rest l)]\n        (recur\n        r\n        (into\n          a\n          (for [i r]\n            [(first l) i]))))))\n    identity\n    (map\n      (fn [[a b]]\n        (reduce\n          #(conj %1 (if (contains? b %2) true false))\n          []\n          a))\n      )\n    flatten\n    (every? #(= false %))\n\n    ))","problem":153,"user":"51b3f109e4b0f094dd986fa9"},{"problem":153,"code":"(fn [s] (= (count (reduce  #(into % %2) #{} s)) (reduce  #(+ % (count %2)) 0 s)))","user":"56c08696e4b060a8e693e3aa"},{"code":"(fn [sets]\n  (= (count (set (apply concat (map #(into [] %) sets))))\n     (reduce + (map count sets))))","problem":153,"user":"4ea1b9e4535d7eef308072b8"},{"code":"(fn [sets]\n  (every? #(= 1 (second %)) (frequencies (apply concat sets))))","problem":153,"user":"4e521cef535d302ef430da6d"},{"problem":153,"code":"#(let [set-list (mapcat seq %)]\n   (= (count(distinct set-list))\n      (count set-list)))","user":"5f77d470e4b02876ed9fd0be"},{"problem":153,"code":"(fn pairwise [sets]\n   (if (= (count sets) 1)\n     true\n     (and\n       (let [null? #(boolean (empty? (clojure.set/intersection %1 %2)))\n             f (first sets)\n             r (rest sets)]\n         (every? (partial null? f) r))\n       (pairwise (rest sets)))))","user":"56fbf83de4b07572ad1a88da"},{"problem":153,"code":"(fn [sets]\n     (letfn [(disjoint? [s1 s2]\n\t\t      (= (count (clojure.set/intersection s1 s2) ) 0) )]\n\t    (loop [sets sets]\n\t\t  (cond (zero? (count sets)) true\n\t\t\t(not (every? (partial disjoint? (first sets)) (rest sets))) false\n\t\t\t:else (recur (rest sets)))))\n     )","user":"55f09e7be4b06e875b46ce28"},{"problem":153,"code":"(fn [sts]\n  (= (reduce + (map count sts))\n  (count (reduce clojure.set/union sts))))","user":"57210e8ee4b0c5bde472c0a8"},{"problem":153,"code":"#(apply distinct? (for [sets % elements sets] elements))","user":"558b50d5e4b027778923762b"},{"code":"(fn pd? [sets]\n  (if (empty? sets) true\n          (let [set-seq (seq sets)\n                aset (first set-seq)\n                rest-sets (set (next set-seq)) \n                other-elts (apply clojure.set/union\n                                  rest-sets)]\n            (if-not (empty?\n                     (clojure.set/intersection aset\n                                               other-elts))\n              false\n              (pd? rest-sets)))))","problem":153,"user":"524ae8e6e4b09eba1c0223b5"},{"problem":153,"code":"(fn [sets] (= (count (apply clojure.set/union sets)) (apply + (map count sets))))","user":"5280539ce4b0757a1b1713f3"},{"problem":153,"code":"(fn [ssets]\n  (let [fs (first ssets), rs (rest ssets)]\n    (cond\n     (empty? ssets) true\n     (some #(seq (clojure.set/intersection fs %)) rs) false\n     :else (recur rs))))","user":"5339c105e4b0e30313ee6cae"},{"problem":153,"code":"#(= (apply clojure.set/union%)\n   (reduce (fn [sum x]\n         (cond\n            (= (clojure.set/intersection sum x) #{}) (clojure.set/union sum x) \n            :else (clojure.set/intersection sum x))) #{} %))","user":"5047782ce4b0371827a27bc2"},{"problem":153,"code":"(fn foo [x] \n  (nil? (some #(> (count %) 1)\n    (vals (group-by identity (apply concat x)))\n        \n)))","user":"5143824ae4b0b4fb4ace5f36"},{"code":"(fn [sos]\n    (let [[u s] (reduce (fn [[u s] ns] [(clojure.set/union u ns) (+ s (count ns))])\n                        [#{} 0]\n                        sos)]\n      (= (count u) s)))","problem":153,"user":"5392b849e4b0b51d73faaeb1"},{"problem":153,"code":"#(every?\n  (fn [x] (< (count (filter identity (map (fn [s] (contains? s x)) %))) 2))\n  (apply clojure.set/union %)\n  )","user":"5cebafbbe4b0a17bb84e2be6"},{"problem":153,"code":"(fn [coll]\n    (->> (map count coll)\n         (reduce +)\n         (= (count (reduce into coll)))))","user":"552356fae4b0882d96d091af"},{"problem":153,"code":"(fn [sets] (->> (into [] sets)\n                (reduce #(into %1 %2) [])\n                (frequencies)\n                (vals)\n                (every? #(< % 2))))","user":"560039cce4b04bb52996e162"},{"code":"(fn pd [sets]\n  (= (apply + (map count sets))\n     (count (reduce into #{} sets))))","problem":153,"user":"51d19c24e4b0cfcf579466c3"},{"problem":153,"code":"(fn [s] (= (count (reduce (fn [res x] (clojure.set/union res x)) #{} s))\n           (apply + (map count s))))","user":"5dc53ddee4b02f9375f4e1bd"},{"problem":153,"code":"#(let \n   [v (apply clojure.set/union (map vec %))]\n   (= (count v) (count (set v))))","user":"54e606c3e4b024c67c0cf803"},{"problem":153,"code":"(fn [ss]\n  (let [indexed (map-indexed vector ss)\n        pairs (for [[i is] indexed [j js] indexed :when (> j i)] [is js])]\n    (every? #(empty? (apply clojure.set/intersection %1)) pairs)))","user":"555ac933e4b0deb715856e49"},{"problem":153,"code":"(fn [sets] \n  (=\n  (reduce + (map count sets))\n  (count (apply clojure.set/union sets))))","user":"5d4f21f3e4b0776584bd6f4e"},{"problem":153,"code":"(fn recursive-check [in-set]\n  (letfn [(duplicate-check\n           [test-set rest-sets]\n           (if (empty? rest-sets)\n             true\n             (reduce #(and %1 %2) true (for [current-set rest-sets\n                                             current-val test-set]\n                                         (not (contains? current-set current-val))))))]\n    (and (duplicate-check (first in-set) (rest in-set)) (if (empty? (rest in-set)) true (recursive-check (rest in-set))))))","user":"57b356c2e4b0fbc9809a277b"},{"problem":153,"code":"(fn [s]\n  (let [c1 (reduce + (map count s)),\n        c2 (count (reduce clojure.set/union s))]\n    (= c1 c2)))","user":"567695c2e4b05957ce8c6157"},{"code":"(fn pairwise-disjoint [sets]\n  (=\n   (->> sets\n        (map count)\n        (reduce +))\n   (count (reduce (fn [accum set] (into accum set)) #{} sets))))","problem":153,"user":"50763574e4b0a894bb95bf3d"},{"problem":153,"code":"(fn pairwisedisjoint? [sets]\n  (if (<= (count sets) 1) \n    true\n    (let [x  (first sets)\n          ys (rest  sets)]\n      (and\n        (every? #(empty? (clojure.set/intersection % x)) ys)\n        (pairwisedisjoint? ys)))))","user":"55cdc576e4b0e31453f64a1f"},{"problem":153,"code":"#(= (count (apply concat %)) \n    (count (set (apply concat %))))","user":"51780bfce4b0f89a8f53839c"},{"problem":153,"code":"(fn [a] (let [f (mapcat identity a)]\n                (= (count f) (count (set f)))))","user":"538e29d1e4b0b51d73faae80"},{"problem":153,"code":"(fn pairwise-disjoint\n  [set1]\n  (= (count (reduce clojure.set/union set1))\n     (reduce + (map count set1)))\n)","user":"5581a6dae4b05c286339e0fe"},{"code":"(fn [s]\n\t(if (= 1 (count s)) \n\t\ttrue\n\t\t(let [all-emp \n\t\t\t\t(reduce #(and % %2) (for [r (rest s)]\n\t\t\t\t\t(empty? (clojure.set/intersection r (first s)))))\n\t\t\t]\n\t\t\t(if all-emp (recur (rest s)) false))))","problem":153,"user":"520242bae4b030ee0c5b26e3"},{"problem":153,"code":"(fn [sets]\n  (let [sum1 (reduce #(+ %1 (count %2)) 0 sets)\n        sum2 (count (apply clojure.set/union sets))]\n    (= sum1 sum2 )))","user":"608ec5e4e4b03bd49d9f36c0"},{"problem":153,"code":"(fn [s]\n  (let [a (apply concat (map #(map identity %) s))]\n    (= (count a) (count (set a)))))","user":"51ab70c3e4b04e3dc0c27b33"},{"code":"(comp (partial apply distinct?)\n        (partial apply concat))","problem":153,"user":"4ddee37c535d08e6dec9fddc"},{"problem":153,"code":"(fn disjoint [sets]\n  (apply distinct? (apply concat sets)))","user":"53b39d82e4b047364c0444a6"},{"code":"(fn [s]\n  (apply distinct? \n         (for [s1 s\n               x s1 y s1\n               :when (= x y)] x)))","problem":153,"user":"536f5900e4b0fc7073fd6e7b"},{"problem":153,"code":"(fn [j] (let [s #(apply concat %) c #(count %)] (= (c (set (s j)))(c (s j)))))","user":"55643878e4b0c656e3ff1801"},{"problem":153,"code":"(fn [ss]\n  (nil? (some true? (for [s1 ss\n                          x s1\n                          s2 ss :when (not= s1 s2)]\n                      (contains? s2 x)))))","user":"550b502ae4b06e50f9beb13f"},{"problem":153,"code":"(fn foo [args] \n  (let [n (count args)\n        si (fn [a b]\n             (or (some #(contains? a %) b) (some #(contains? b %) a))\n             )\n        d2 (fn [a b] (not (si a b)))]\n             (if (< n 3) (apply d2 args)\n               (let [f (first args) r (rest args)] \n                 (and  (foo (set r)) \n                      (every? (fn [y] (d2 f y)) r)\n                      )\n                 \n               )\n             )\n  )\n)","user":"57b8b008e4b0fbc9809a27e6"},{"code":"(fn [s] (apply distinct? (mapcat identity s)))","problem":153,"user":"5244fa73e4b0d8acf9ed6acb"},{"problem":153,"code":"(fn [s]\n  (let [sl (into '() s)]\n    (loop [s1 sl\n           r true]\n      (if (empty? s1)\n        r\n        (recur\n          (rest s1)\n          (every? true?\n                  (cons\n                    r\n                    [(not (some (partial contains? (first s1)) (apply concat (reduce conj '() (map (partial into '()) (rest s1))))))])))))))","user":"590253e3e4b0438e51c2d055"},{"problem":153,"code":"(fn [sets]\n  (loop [remaining sets\n         acc #{}\n         disjoint? true]\n    (cond \n      (not disjoint?) \n        false\n      (empty? remaining) \n        disjoint?\n      :else \n        (recur \n          (rest remaining)\n          (clojure.set/union acc (first remaining))\n          (empty? (clojure.set/intersection acc (first remaining)))))))","user":"5ed9c2cde4b0c7845d86b0e4"},{"problem":153,"code":"(fn [sets] \n  (->> sets\n       (apply concat)\n       (group-by #(str (if (sequential? %) (seq %) %)))\n       (vals)\n       (map count)\n       (every? #(= % 1))\n       ))","user":"54febf4be4b07d26eda61d45"},{"code":"(fn [s] (= s (set (for [x s y (disj s x)] (apply disj x y)))))","problem":153,"user":"536e0930e4b0fc7073fd6e66"},{"code":"#(every? (partial = 1) (vals (frequencies (apply concat %))))","problem":153,"user":"52be58d7e4b07a9af579231d"},{"code":"(fn pairwise [sets] (let [items (reduce clojure.set/union sets)]\n\t(= (count items) (->> sets (map count) (reduce +)))\n))","problem":153,"user":"511cca27e4b00c2a1fa7ff7d"},{"problem":153,"code":"#(loop [v %\n        h true\n        s #{}]\n   (if (or (empty? v) (not h)) h\n     (recur (rest v) (= #{} (clojure.set/intersection (first v) s)) (clojure.set/union s (first v)))))","user":"55e732c5e4b050e68259b492"},{"problem":153,"code":"(fn disjoint-sets [s]\n  (empty? (for [x s y s :when (and (not= x y)\n                                   (not (empty? (clojure.set/intersection x y))))]\n            [x y] )))","user":"53e27bf1e4b036ad0777e3f2"},{"code":"(fn [s] \n  (= (count (set (mapcat identity s)))\n     (reduce + (map count s))))","problem":153,"user":"4db1b3951254ad5b4805fa6f"},{"code":"(fn mutually-disjoint [set-of-sets]\n  (let [overlap? (fn [s1 s2]\n                   (> (+ (count s1) (count s2))\n                      (count (into s1 s2))))]\n    (every? false?\n            (for [x set-of-sets y set-of-sets :when (not= x y)]\n              (overlap? x y)))))","problem":153,"user":"50a7ef7fe4b090657f4a5ce0"},{"code":"(fn [ss]\n   (every? true? (for [s ss without-s (disj ss s)]\n     (empty? (clojure.set/intersection s without-s)))))","problem":153,"user":"52d00832e4b07d0d72b273b4"},{"code":"(fn [s] (empty? (filter (complement empty?) (for [a s b (clojure.set/difference s #{a})]\n                                              (clojure.set/intersection a b)))))","problem":153,"user":"536f2faee4b0fc7073fd6e79"},{"code":"(fn pairwise-disj? [sets]\n  (every? empty?\n    (for [s1 sets\n          s2 sets\n          :when (not= s1 s2)]\n      (clojure.set/intersection s1 s2))))","problem":153,"user":"4f9d53f3e4b0dcca54ed6d21"},{"code":"(fn [xs]\n  (=\n   (reduce + (map count xs))\n   (count (reduce clojure.set/union xs))))","problem":153,"user":"4f2e0369e4b0d6649770a064"},{"code":"(fn [s]\n  (let [n (reduce + (map count s))\n        union (apply clojure.set/union s)]\n    (= n (count union))))","problem":153,"user":"51ae350fe4b09397d5109790"},{"problem":153,"code":"(fn disjoint [ss]\n  (let [combination \n          (fn combnt [n m seqs] \n            (if (= 1 m) \n              seqs \n              (map #(flatten %) \n                (reduce concat '() \n                  (for [k (range (- n (dec m)))] \n                    (map #(list (first (drop k seqs)) %) \n                      (combnt (dec n) (dec m) (drop (inc k) seqs))))))))]\n    (if (= 0 (count (filter #(not= #{} %) (map #(apply clojure.set/intersection %) (combination (count ss) 2 ss))))) true false)))","user":"5243e37ae4b076204b44fae3"},{"code":"#(= (count %)\n     (count (filter false? \n                   (for [x %, y %] (not-any? x y)))))","problem":153,"user":"5097a95fe4b00ad8bab4e96e"},{"code":"(fn [ss]\n  (not (some true?\n         (for [s ss t ss\n               :when (not (identical? s t))\n               x s y t]\n           (= x y)))))","problem":153,"user":"527cd633e4b0757a1b17136f"},{"problem":153,"code":"(fn [sets]\n  (empty? (apply clojure.set/union (for [x sets y sets :let [intersect (clojure.set/intersection x y)] :when (and (not (empty? intersect)) (not= x y))] intersect))))","user":"607a1523e4b0a637ed78036a"},{"problem":153,"code":"#(let [r (apply concat %)]\n               (= (count r) (-> r set count)))","user":"5499e23de4b03163384f4706"},{"problem":153,"code":"(fn [arg]\n    (every? empty? (for [a arg b arg\n          :when (not (identical? a b))]\n        (clojure.set/intersection a b)\n    ))\n)","user":"5bfcdc52e4b0bdcf453d15f4"},{"code":"(fn [s] \n  (= \n    (count (reduce #(concat %1 (vec %2)) [] s))\n    (count (set (reduce #(concat %1 (vec %2)) s)))\n  )\n)","problem":153,"user":"4f84400de4b033992c121c2e"},{"code":"#(= (count (reduce (fn [x, y] (into x y)) #{} %))\n      (count (reduce (fn [x, y] (into x y)) [] %)))","problem":153,"user":"4dae0510c9a9d6ed4b99dc57"},{"code":"#(= (count (distinct (apply concat %))) (apply + (map count %)))","problem":153,"user":"4f1d1d95535d64f603146488"},{"code":"#(=\n  (count (apply clojure.set/union %))\n  (reduce + (map count %)))","problem":153,"user":"4fce5474e4b0d4b2a7a9d451"},{"code":"(fn [coll]\n  (if (empty? coll) true\n    (let [xs (first coll) coll (rest coll)]\n      (if (every? #(empty? (filter (partial contains? xs) %)) coll)\n        (recur coll)\n        false))))","problem":153,"user":"5224a46ce4b01819a2de42e5"},{"code":"(fn [s]\n  (=\n    (reduce\n      +\n      (map count s))\n    (count\n      (apply clojure.set/union s))))","problem":153,"user":"4f5c0549e4b0030a34fb2b1a"},{"problem":153,"code":"(fn [sets]\n  (= (count (reduce clojure.set/union sets))\n     (reduce + (map count sets))\n     )\n  )","user":"5b5e5019e4b0c6492753e6d3"},{"code":"(fn [sets]\n   (= (reduce + (map #(count %) sets))\n     (count (apply list (reduce #(clojure.set/union % %2) #{} sets))))\n)","problem":153,"user":"502a5fa4e4b09e8f859a9fbd"},{"code":"(fn [ss]\n  (let [soa (reduce into ss)\n        coa (reduce #(+ %1 (count %2)) 0 ss)]\n    (= coa (count soa))))","problem":153,"user":"51df825de4b01188f062752b"},{"problem":153,"code":"(fn [xs] (apply distinct? (reduce #(concat %1 %2) xs)))","user":"5409a12fe4b0addc1aec66df"},{"code":"(fn [the-set]\n   (let [total-items (reduce (fn [cont it] (+ cont (count it))) 0 the-set)\n         test-items (count (reduce #(if (empty? %2)\n                                      %\n                                      (apply conj % %2)) #{} the-set))\n         ]\n         (= total-items test-items )\n     )\n   )","problem":153,"user":"50550f43e4b0b1b9d1860eb7"},{"code":"(fn __ [coll]\n  (let [x (mapcat #((fn [t] (mapcat (fn [y] (list y)) t)) %) coll)]\n    (= 0 (count (filter #(> % 1) (mapcat #(list (count (filter ((fn [a] (fn [b] (= a b)))\n\n                                                                %) x))) x )))) \n    ))","problem":153,"user":"509b152be4b0412cdea6eb1e"},{"code":"(fn [sets]\n  (letfn [(set-in-set [set1 set2]\n            (not (some identity (map #(contains? set2 %) set1))))\n          (set-in-sets [set1 sets]\n            (loop [sets sets]\n              (if (empty? sets)\n                true\n                (if (true? (set-in-set set1 (first sets)))\n                  (recur (rest sets))\n                  false))))\n          (sets-in-sets [sets]\n            (loop [cur-set (first sets) rest-sets (rest sets)]\n              (if (empty? rest-sets)\n                true\n                (if (true? (set-in-sets cur-set rest-sets))\n                  (recur (first rest-sets) (rest rest-sets))\n                  false))))]\n    (sets-in-sets sets)))","problem":153,"user":"523288fee4b035af41902a88"},{"code":"(fn\n  [xss]\n  (= (count (reduce clojure.set/union xss)) (count (reduce concat xss))))","problem":153,"user":"536aa86de4b0243289761eb1"},{"code":"(fn b [m]\n  (= (count (reduce clojure.set/union m)) (reduce + (map count m))))","problem":153,"user":"4fe97adde4b0547ebccb245e"},{"problem":153,"code":"(fn [sets]\n  (let [pairs (filter #(not= (nth % 0) (nth % 1)) (for [a sets b sets] [a b]))\n        disjoint (fn [a b] (every? (complement identity) (into [] (map #(contains? b %) a))))]\n   (every? identity (map #(disjoint (nth % 0) (nth % 1)) pairs))))","user":"56393681e4b0bfe05bf117f2"},{"code":"#(let [a (mapcat identity %)] (= (distinct a) a))","problem":153,"user":"4e43b0d9535dc968683fc4a3"},{"code":"(fn overlap [sets] \n  (loop [curr (first sets) remain (rest sets)]\n    (if-let [n (first remain)]\n      (if \n        (empty? (clojure.set/intersection curr n)) \n        (recur n (rest remain))\n        false)\n      true)))","problem":153,"user":"50be9b4ae4b00fb48fed2ef6"},{"code":"#(= (count (apply clojure.set/union %)) (reduce (fn [a b](+ a (count b))) 0 %))","problem":153,"user":"52570aeae4b0541d1855ba42"},{"problem":153,"code":"(fn [s]\n  (every? true?\n          (for [x s\n                y s\n                :when (not= x y)]\n            (empty? (clojure.set/intersection x y)))))","user":"55995fa7e4b031d6649c9ba9"},{"problem":153,"code":"(fn [s]\n  (let [combos (for [x s y s :when (not= x y)] [x y])]\n    (every? true? (map #(empty? (apply clojure.set/intersection %)) combos))))","user":"58d48df8e4b03c36ff7e5941"},{"problem":153,"code":"(fn pd? [arg]\n  (let [my-arg (seq arg)]\n    (every? identity \n            (for [x (range (count my-arg)) y (range (inc x) (count my-arg))] \n              (empty? (clojure.set/intersection (nth my-arg x) \n                                        (nth my-arg y)\n                                        )\n                      )\n              )\n            )\n    )\n  )","user":"525d490ae4b0cb4875a45d70"},{"problem":153,"code":"#(apply distinct? (apply concat %))\n;;(fn [sofs] (= (count (apply concat sofs)) (count (distinct (apply concat sofs))))","user":"584d99c5e4b0b7285a6f4e42"},{"code":"(fn [sets-set]\n  (every? empty?\n          (for [a sets-set\n                b sets-set\n                :when (not= a b)]\n            (filter (partial contains? a) b))))","problem":153,"user":"51f9527fe4b09be9c177e549"},{"problem":153,"code":"(fn [s]\n   (= (count (reduce #(into %1 %2) #{} s)) (reduce #(+ %1 (count %2)) 0 s)))","user":"52fac708e4b047fd55836fff"},{"problem":153,"code":"(fn pairwise-disjoint-2\n  [sets]\n  (every? empty? (map #(when (not= %1 %2) (clojure.set/intersection %1 %2)) (mapcat (partial repeat (count sets)) sets) (cycle sets))))","user":"506f0968e4b09350ab4199f5"},{"problem":153,"code":"(fn [sets]\n  (let [elements-in-common? (fn [set_a set_b]\n                              (> (count (clojure.set/intersection set_a set_b)) 0))\n        has-any-elements-on-common? (fn [pivot sets]\n                                      (some (fn [s] (elements-in-common? pivot s)) sets))]\n    (< (count (filter (fn [s]\n                   (let [remaining-sets (clojure.set/difference sets #{s})]\n                     (has-any-elements-on-common? s remaining-sets))) sets)) 2)))","user":"4feaa579e4b0140c20fb9c0b"},{"problem":153,"code":"(fn [A] (= (apply + (map count A))\n           (count (apply clojure.set/union A))))","user":"57c796b4e4b05aa3c4741d08"},{"code":"(fn [x] \n   (let [i (fn [a b] (reduce #(if (contains? b %2) (conj % %2) %) #{} a))]\n     (reduce #(and % (empty? %2)) true (for [a x b x :when (not= a b)] \n       (i a b))))\n   )","problem":153,"user":"4eb13d60535d7eef3080733f"},{"problem":153,"code":"(fn setcount [s] (= (count (reduce clojure.set/union s)) (reduce + (map count s))))","user":"573ce277e4b05c31a32c080b"},{"problem":153,"code":"(fn disjoint? [ss]\n  (let [is-disjoint?\n        (fn [m n] (every? false? (for [x m] (contains? n x))))]\n    (every?\n      true?\n      (for [m ss\n            n ss\n            :when (not= m n)]\n        (is-disjoint? m n)))))","user":"56ac81ace4b03c432f187347"},{"problem":153,"code":"(letfn [(intersect? [s1 s2 & ss]\n        (let [intersection (clojure.set/intersection (set s1) (set s2))]\n          (if (or (empty? intersection) (empty? ss))\n            (seq intersection)\n            (recur intersection (first ss) (rest ss))))) \n      (exclusive? [s1 s2 & ss]\n        (let [set1 (set s1) set2 (set s2)]\n          (cond\n            (intersect? set1 set2) false\n            (empty? ss) true\n            :otherwise (recur (clojure.set/union set1 set2) (first ss) (rest ss)))))]\n  (fn [s] (apply exclusive? s)))","user":"5de28eeae4b0948ae9d9adf5"},{"problem":153,"code":"#(= (count (apply clojure.set/union %))\n    (count (reduce concat [] %)))","user":"5956c6dae4b066ee0a44af61"},{"code":"(fn [s]\n  (= (count (reduce into #{} s))\n     (apply + (map count s))))","problem":153,"user":"4e50ad74535dc968683fc4ec"},{"problem":153,"code":"#(= (count (set (apply concat %))) (apply + (map count %)))","user":"56066e82e4b08b23635d3173"},{"problem":153,"code":"#(loop [seqs %\n        seen {}]\n   (if (empty? seqs)\n     true\n     (let [result (set (for [e (first seqs)\n                        :while (not (seen e))]\n                    e))]\n       (if (= result (first seqs))\n         (recur (rest seqs)\n                (into seen (map (fn [x] (vector x true)) (first seqs))))\n         false))))","user":"551ed214e4b08d5046aa8a4d"},{"problem":153,"code":"(fn [Sets]\n    (not\n      (some true? \n        (for [L1 Sets L2 Sets :when (not= L1 L2) ]      \n          ;;(println L1 L2)\n          (some true?\n            (for [Ind1 L1 Ind2 L2] \n              ;;(println Ind1 Ind2)\n              (= Ind1 Ind2)\n            )\n          )\n        )\n      )\n    )\n  )","user":"5d4a6c6ce4b0776584bd6f22"},{"problem":153,"code":"(fn [sets]\n   (every? empty? (for [set1 sets\n          set2 (disj sets set1)]\n      (clojure.set/intersection set1 set2)\n      )))","user":"5ce2b15fe4b0a17bb84e2b2c"},{"problem":153,"code":"(fn [s] (every? #(= 1 %) (vals (frequencies (mapcat seq s)))))","user":"553e0b70e4b0a04f792994e8"},{"problem":153,"code":"(fn [s] \n  (= (count (apply clojure.set/union s)) (reduce #(+ (count %2) %1) 0 s)))","user":"52fe31d5e4b047fd55837038"},{"problem":153,"code":"#(= (count (reduce (fn [x y] (into x y)) %)) (count (reduce (fn [x y] (into x (seq y))) '() %)))","user":"56ab7578e4b03c432f18733d"},{"code":"#(first\n  (reduce \n    (fn [[v s] new] \n      (if v \n        [(empty? (clojure.set/intersection s new)) \n                 (clojure.set/union s new)] \n        [v #{}])) \n    [true #{}] %))","problem":153,"user":"4f03ac2d535dcb61093f6b4a"},{"problem":153,"code":"(fn mutually-disjoint? [set-of-sets]\n  (apply distinct? (reduce concat [] set-of-sets)))","user":"562e8b2be4b0ab312c17ebbb"},{"code":"(fn pw-dj [ s]\n    ; puts elements in a hash\n   (every? (partial = 1)\n     (vals (apply (partial merge-with +) ( map \n        #(into {} ( map (fn [k] ( vector k 1 )) %)) s)))))","problem":153,"user":"5018ed15e4b011a2e0bf6412"},{"problem":153,"code":"(fn [values]\n  (let [all-values (apply concat (seq (map seq values)))\n        distinct-values (distinct all-values)]\n    (= (.size all-values) (.size distinct-values))))","user":"55d06bcbe4b0e31453f64a3a"},{"problem":153,"code":"(fn \n[s1]\n  (let [x (count (reduce into s1)) y (reduce + (map count s1))]\n    (if (> y x)\n      false\n      true)\n    )\n  )","user":"5dd70ee3e4b0948ae9d9ad85"},{"problem":153,"code":"#(= (count (reduce clojure.set/union %)) (count (apply concat %)) )","user":"5a536cf2e4b05d388ecb6c10"},{"problem":153,"code":"(fn pairwise\n  [xs]\n  (let [ls (for [x xs y xs :when (not= x y)] [x y])]\n    (apply = 0 (map #(count (clojure.set/intersection (first %) (second %))) ls))))","user":"5ef18431e4b07c55ae4a0529"},{"code":"(fn [s] (apply distinct? (reduce into [] s)))","problem":153,"user":"4e8a0c82535d3e98b802328d"},{"problem":153,"code":"(fn [s]\n   (= (count (apply clojure.set/union s)) (apply + (map count s))))","user":"588906a9e4b0f1effa3b772a"},{"problem":153,"code":"(fn pd [sets]\n  (let\n    [union-size (count (set (apply concat sets)))\n     total-size (reduce + (map count sets))]\n    \n    (= union-size total-size)\n  ))","user":"6045582fe4b02d28681c77b6"},{"problem":153,"code":"(fn [s]\n\t\t(loop [new [] lst s c 0]\n\t\t\t(if (empty? lst)\n\t\t\t\t(= (count (set new)) c)\n\t\t\t\t(recur (concat new (first lst)) (rest lst) (+ c (count (first lst)))))))","user":"59368ccae4b02506e01a2979"},{"problem":153,"code":"(fn [set-of-sets]\n    (->> (for [current-set set-of-sets\n               other-set set-of-sets]\n           (when (not (= current-set other-set))\n             (boolean (seq (clojure.set/intersection current-set other-set)))))\n         (some true?)\n         (not)))","user":"569f4dabe4b0542e1f8d1491"},{"problem":153,"code":"#(= (count (apply clojure.set/union %))\n     (apply + (map count %)))","user":"53fcd574e4b0de5c418485d9"},{"code":"(fn\t[s]\t(= (count (apply clojure.set/union s)) (reduce + (map count s))))","problem":153,"user":"5142ea50e4b0c172af7558ca"},{"code":"(fn [s]\n  (every? empty? (for [s1 s\n                      s2 (disj s s1)]\n                  (clojure.set/intersection s1 s2))))","problem":153,"user":"5310e7aee4b08068f379ecdc"},{"code":"#(= (count (reduce clojure.set/union %))\n    (reduce + (map count %)))","problem":153,"user":"5054c7e1e4b0b1b9d1860eb2"},{"code":"(fn [sets]\n\t(=\n     (reduce #(+ %1 (count %2)) 0 sets)\n     (count (reduce #(clojure.set/union %1 %2) #{} sets))))","problem":153,"user":"52039e12e4b0fb7e47ea51ff"},{"problem":153,"code":"#(every? identity (for [x % y % :while (not= x y)] (empty? (clojure.set/intersection x y))))","user":"57c647bbe4b05aa3c4741cf3"},{"problem":153,"code":"(fn [x]\n         (empty? (remove #(= #{} %)\n                         (for [a x\n                               b x\n                               :when (not= a b)]\n                           (clojure.set/intersection a b)))))","user":"5654cb2de4b0f9d632dd848b"},{"code":"#(= (reduce + (for [s1 %] (count s1)))\n    (count (set (for [s1 % s2 s1] s2))))","problem":153,"user":"50b1d166e4b03ea880433554"},{"problem":153,"code":"(fn [x] (= (reduce + (map count (seq x)))\n            (count (set (apply concat (seq x))))))","user":"4ec66e84535d6d7199dd36cd"},{"problem":153,"code":"(fn disjs [sets]\n  (let [h (first sets)\n        t (next sets)]\n    (and (every? empty? (map #(clojure.set/intersection h %) t))\n         (or (empty? t) (disjs t)))))","user":"54f4adc8e4b0f2f3c5226e86"},{"problem":153,"code":"(fn \n  [n]\n  (apply distinct? (mapcat seq n))\n  )","user":"57f81532e4b0d3187e900914"},{"problem":153,"code":"(fn [x]\n   (if (some\n         #(> % 1)\n         (->> (apply concat x)\n              (group-by identity)\n              vals\n              (map count)))\n     false true))","user":"55630cc1e4b0c656e3ff17e0"},{"code":"#(every? (partial = 1) (map last (apply merge-with + (map frequencies %))))","problem":153,"user":"4ec53cef535d6d7199dd3686"},{"problem":153,"code":"#(let [f (for [a % b a] b)] (= (count f) (count (distinct f))))","user":"53572176e4b04ce2eb3ed276"},{"code":"#(= (count (reduce clojure.set/union %)) (reduce + (map count %)))","problem":153,"user":"50a5b7e9e4b0aa96157e2610"},{"problem":153,"code":"(fn [sets]\n  (loop [unchecked sets contained #{}]\n    (if (empty? unchecked)\n      true\n      (if (some #(contains? contained %) (first unchecked))\n        false\n        (recur (rest unchecked) (into contained (first unchecked)))))))","user":"55ede35ce4b0121d4835fde1"},{"code":"#(let [a (reduce + (map count %))\n       b (count (apply clojure.set/union %))]\n   (if (= a b) true false)\n   )","problem":153,"user":"529d4f4be4b04e0c58e87b79"},{"problem":153,"code":"(fn a [coll]\n  (loop [collected #{} items coll]\n  \t(cond\n    \t(empty? items) true\n     \t(empty? (clojure.set/intersection collected (first items))) (recur (clojure.set/union collected (first items)) (rest items))\n     \t:else\n     \t\tfalse\n    )\n  )\n)","user":"5991d2fae4b0866487ed0d68"},{"code":"(fn [x]\n  (apply distinct? (apply concat x)))","problem":153,"user":"4db2cc55535df7e46ed9b6c5"},{"problem":153,"code":"(fn foo [s]\n  (letfn [(combinations [c] (set (for [x c y c :when (not= x y)] (set [x y]))))]\n    (->> s\n      combinations\n      (map (partial apply clojure.set/intersection))\n      (every? empty?))))","user":"561ba3e5e4b073c65b0ce3eb"},{"problem":153,"code":"(fn [set-of-sets]\n    (loop [elements-seen #{}\n           rest-of-sets set-of-sets]\n      (if (= #{} rest-of-sets)\n        true\n        (let [s (first rest-of-sets)]\n          (if (not= #{} (clojure.set/intersection elements-seen s))\n            false\n            (recur (clojure.set/union elements-seen s)\n                   (disj rest-of-sets s)))))))","user":"51b91b08e4b0e871ca4958f8"},{"code":"(fn sset [x]\n  (if (empty? (reduce (fn [x y] (cond\n                               (empty? x) x\n                               (empty? (clojure.set/intersection x y)) (clojure.set/union x y)\n                               :else #{}) ) x)) false true ))","problem":153,"user":"52140b53e4b0961f15ac4d7e"},{"problem":153,"code":"(fn [test_sets]\n    (= (count (apply clojure.set/union test_sets)) (reduce #(+ %1 (count %2)) 0 test_sets)))","user":"592ac17ae4b072a2710fcf26"},{"problem":153,"code":"(fn [sets]\n  (let [a (count (apply clojure.set/union sets))\n        b (apply + (map count sets))]\n    (= a b)))","user":"5c0e3f86e4b01240ff56713d"},{"problem":153,"code":"(fn [cs] (when-let [cl (seq cs)] (coll? (reduce\n          (fn [f v]\n           (if (or (false? f) (some (fn [v] (some #(= v %) f) ) \n                        v)) false v ) )\n    (first cl) (rest cl) ))))","user":"55adf4d7e4b03311e7b732af"},{"code":"(fn [s]\n  (let [r (for [x s y x] y)]\n    (= (count r) (count (set r)))))","problem":153,"user":"51899891e4b0288ada3dbdab"},{"code":"(fn p153 [ss]\n  (= (apply + (map count ss))\n     (count (reduce (fn [acc s] (into acc s))\n                    #{} ss))))","problem":153,"user":"4daec9dcedd6309eace4d15f"},{"problem":153,"code":"(fn pairwise-disjoint? [super-set]\n  (letfn [(disjoint? [s1 s2]\n            (let [difference (clojure.set/difference s1 s2)]\n              (= difference s1)))]\n    (->> super-set\n         (map-indexed (fn [idx sub-set]\n                        (every? (fn [elem] (disjoint? elem sub-set))\n                                (drop (+ idx 1) super-set))))\n         (every? true?))))","user":"5d49ec5ee4b0776584bd6f1c"},{"problem":153,"code":"(let\n  [full #(> (count %) 0)\n   add (fn [s e] (and (not (contains? s e)) (conj s e)))\n   addset (fn addset [s1 s2] (if\n                               (full s2)\n                               (let [s3 (add s1 (first s2))] (and s3 (addset s3 (rest s2))))\n                               s1))\n   addsets (fn addsets [s1 s2] (if\n                                 (full s2)\n                                 (let [s3 (addset s1 (first s2))] (and s3 (addsets s3 (rest s2))))\n                                 s1))]\n  (fn [sets] (not (false? (addsets #{} sets)))))","user":"5b465b8be4b02d533a91bc65"},{"code":"(fn [s] (= (reduce + (map count s)) (count (apply clojure.set/union s))))","problem":153,"user":"53244c9de4b09d4e7a9b54db"},{"code":"(fn [ms]\n  (= (count (reduce #(into % %2) #{} (seq ms)))\n     (reduce #(+ % (count %2)) 0 (seq ms))))","problem":153,"user":"51852961e4b0da5a5be3babb"},{"code":"#(= (count (apply clojure.set/union %))\n     (reduce (fn [nr s] (+ nr (count s))) 0 %))","problem":153,"user":"4ed8b598535d10e5ff6f52fc"},{"problem":153,"code":"(fn disjoint? [s]\n  (= '() (filter #(not= #{} %) (for [x s y (clojure.set/difference s (set (list x)))]\n                                 (clojure.set/intersection x y)))))","user":"54651faee4b01be26fd746d6"},{"problem":153,"code":"(fn solve153 [s]\n  (let [sets (seq s)\n        combined (apply clojure.set/union sets)\n        total-count (apply + (map count sets))]\n    (= (count combined) total-count)))","user":"55a5c3bee4b0acc240e3154e"},{"code":"#(= (count (set (apply concat %))) (reduce + (map count %)))","problem":153,"user":"4ff78679e4b0678c553fc392"},{"problem":153,"code":"#(let [stuff (mapcat (partial into []) %)]\n  (= (count stuff) (count (into #{} stuff))))","user":"53fe1b42e4b0de5c418485f1"},{"problem":153,"code":"(fn check[s] \n  (or (empty? s) \n      (and (every? #(not-any? (fn [a] (contains? (first s) a)) %)\n                   (rest s)) \n           (check (rest s)))))","user":"5457e5f1e4b01be26fd74613"},{"problem":153,"code":"(fn pairwise-disj\n  [s]\n  (= (count (apply clojure.set/union s)) (apply + (map count s))))","user":"557e9d17e4b05c286339e0d8"},{"problem":153,"code":"(fn [ss]\n    (= (apply + (map count ss))\n       (count (reduce into ss))))","user":"513e8141e4b02b2a3d8235c1"},{"problem":153,"code":"(fn my-pairwise-disjoint-sets\n  [sets]\n  (= (count (into #{} (apply concat sets))) (reduce + (map count sets))))","user":"509a25b7e4b0efbae1fbc0a8"},{"problem":153,"code":"(fn pairwise-disjoint\n  [xs]\n  (every? identity\n          (for [x xs not-x (disj xs x)]\n            (empty? (clojure.set/intersection x not-x)))))","user":"5ecfd429e4b016b56eae05a9"},{"problem":153,"code":"#(every? identity (for [a %\n                        b (disj % a)]\n                    (empty? (clojure.set/intersection a b))))","user":"5479c58de4b0c51c1f4d72c7"},{"problem":153,"code":"(fn [sos]\n   (empty? (keep identity (for [s1 sos s2 sos\n         :when (not= s1 s2)\n         :let [is (clojure.set/intersection s1 s2)]]\n     (if (not (empty? is))\n       false)))))","user":"5763818ae4b0994c1922fbc7"},{"code":"(fn [ss]\n\t(let [a (apply concat (map #(map identity %) ss))]\n      (= (count a) (count (distinct a)))))","problem":153,"user":"4ee82223535d93acb0a66877"},{"code":"(fn [S]\n  (loop [s (first S) S (rest S) m #{}]\n    (if s\n      (if (pos? (count (filter #(or (m %) (= (type (m %)) (type %))) s)))\n        false\n        (recur (first S) (rest S) (clojure.set/union m s)))\n      true)))","problem":153,"user":"502940a9e4b061fd216be4b8"},{"problem":153,"code":"(fn parwise-disjoint? [s]\n  (every? empty?\n          (map #(clojure.set/intersection (first %) (second %))\n               (for [e1 s e2 s :when (not (identical? e1 e2))] [e1 e2]))))","user":"53286f84e4b09d4e7a9b5505"},{"problem":153,"code":"#(= (distinct (apply concat %)) (apply concat %))","user":"53ac4719e4b047364c04445c"},{"problem":153,"code":"(fn are-pairwise-disjoint [sets]\n  (if (< (count sets) 2)\n    true\n    (if (let [curr (first sets)]\n          (loop [rem-in-set curr]\n            (if (empty? rem-in-set)\n              true\n              (if (let [head (first rem-in-set)]\n                    (loop [remaining (rest sets)]\n                      (if (empty? remaining)\n                        true\n                        (let [curr-other-set (first remaining)]\n                          (if (contains? curr-other-set head)\n                            false\n                            (recur (rest remaining)))\n                          ))\n                      )\n                    )\n                (recur (rest rem-in-set))\n                false))))\n      (recur (rest sets))\n      false))\n  )","user":"5dd67c22e4b0948ae9d9ad80"},{"problem":153,"code":"(fn [xs] (= (apply + (map count xs))\n            (count (set (apply concat xs)))))","user":"547ad587e4b0c51c1f4d72ce"},{"code":"(fn f [ss]\n  (let [\n        x (first ss)\n        xs (rest ss)\n        check-1 (fn [set1] (some #(contains? x %) set1))]\n    (if (empty? xs) true\n      (if (every? nil? (map check-1 xs))\n        (f xs)\n        false))))","problem":153,"user":"4fd22e70e4b04c3a95aa041c"},{"problem":153,"code":"(fn pairwise-disjoint? [s]\n  (->> (for [s' s\n             r s']\n         r)\n       (apply distinct?)))","user":"5d64ecb2e4b0c9e5857d5036"},{"problem":153,"code":"(fn [sets]\n     (every? empty?\n             (for [a sets\n                   b sets\n                   :when (not= a b) ]\n                  (clojure.set/intersection a b))))","user":"56020b3fe4b04bb52996e19b"},{"code":"#(if (% #{}) false (every? nil? (for [a % b % :when (not= a b)] (some a b))))","problem":153,"user":"4e80e0f2535db62dc21a62b8"},{"problem":153,"code":"(fn [s] \n  (every? \n  #(= 0 (count (apply clojure.set/intersection %))) \n  (#(for [x % y % :when (not= x y)] [x y]) s)))","user":"570d0548e4b0b0fb43fd06d2"},{"problem":153,"code":"(fn [sets]\n    (reduce #(and %1 %2)\n            (for [left sets right sets]\n              (if (not= left right)\n                (empty? (clojure.set/intersection left right))\n                true))))","user":"554a75c9e4b0a04f79299575"},{"problem":153,"code":"(fn [vs] (every? (fn [[k v]] (= 1 v)) (frequencies (reduce (fn [acc c] (into acc c)) [] vs))))","user":"522a01ade4b0590a43906ced"},{"problem":153,"code":"(fn \n  [coll]\n  (= (apply + (map count coll))\n    (count(reduce clojure.set/union coll))))","user":"5cf1d9e3e4b0aaa82f112a18"},{"problem":153,"code":"(fn [sets]\n  (empty? (for [x sets\n                y sets\n                :let [z (clojure.set/union x y)]\n                :when (and (not (identical? x y)) \n                           (not (= (+ (count x) (count y))\n                                   (count z))))]\n            :elements-in-common)))","user":"57002b81e4b08d47c97781c7"},{"code":"(fn [args]  \n  (loop [sets args]\n    (cond (<= (count sets) 1) true\n          (some #(some (fn [s] (contains? % s)) (first sets)) (rest sets)) false \n          :else (recur (rest sets)))))","problem":153,"user":"53300924e4b019098a6f8b55"},{"code":"(fn [coll]\n  (let [s (reduce into [] coll)]\n    (apply distinct? s)))","problem":153,"user":"51533ecde4b0252ac4b16619"},{"code":"(fn pairwise-disjoint-sets [set-of-sets]\n  (loop [master-set #{}\n         sets set-of-sets]\n    (cond\n     (empty? sets) true\n     (< 0 (count (filter #(contains? master-set %) (first sets)))) false\n     :else (recur (set (concat master-set (first sets))) (rest sets)))))","problem":153,"user":"51d360d1e4b099f3b6acddff"},{"problem":153,"code":"(fn [s]\n  (let [a (mapcat #(into [] %) (into [] s))]\n    (= (count a) (count (set a)))))","user":"57458b82e4b009280f9f2b4e"},{"problem":153,"code":"(fn f\n  [sets]\n  (let [union (reduce into #{} sets)\n        count-of-union (count union)\n        set-counts (map count sets)\n        sum-of-set-counts (reduce + set-counts)]\n    (= count-of-union sum-of-set-counts)))","user":"5d0bb4fae4b0cc9c91588237"},{"code":"(fn [xs]\n  (loop [xs xs x #{} acc #{}]\n    (if (and (empty? x) (empty? xs))\n      true\n      (if (empty? x)\n        (recur (rest xs) (first xs) acc)\n        (if (some #(= % (first x)) acc )\n          false\n          (recur xs (rest x) (conj acc (first x))))))))","problem":153,"user":"4e7f5a0b535db966e863cc41"},{"code":"(fn [sets]\n  (= (reduce + (map count sets))\n     (count (reduce clojure.set/union sets))))","problem":153,"user":"5032b066e4b00c0952a257ea"},{"code":"#(every? true? (for[A % B % :when(not= A B)](empty?(clojure.set/intersection A B))))","problem":153,"user":"4e57d1e2535d8a8b8723a289"},{"problem":153,"code":"(fn [ss] (apply distinct? (mapcat seq ss)))","user":"5a0ce1a5e4b04bbd27e6d9b7"},{"code":"(fn dj [S]\n  (let [c (reduce + (map count S))\n        c2 (count (reduce into S))]\n    (= c c2)))","problem":153,"user":"51d96ad0e4b02ceefd94774f"},{"problem":153,"code":"(fn [x] \n  (= (->> x (map count) (reduce +)) \n     (count (reduce into x))))","user":"58384bc4e4b089d5ab817d27"},{"code":"(fn p [s] (let [intersection (fn intersection [a b] (not-empty (for [a1 a b1 b :when (= a1 b1)] true)))]\n              (reduce #(and %1 %2) (for [s1 s s2 s\n                                         :when (and (not= s1 s2))\n                                         ]\n                                     (empty? (intersection s1 s2))\n                                     )\n                )))","problem":153,"user":"4ec5bec6535d6d7199dd36b3"},{"code":"(fn [c]\n    (letfn [(setize [coll]\n              (loop [coll2 coll\n                     result #{}]\n                (if (empty? coll2)\n                  result\n                  (recur (rest coll2)\n                         (conj result\n                               (let [target (first coll2)]\n                                 (if (coll? target)\n                                   (set target)\n                                   target)))))))\n            (sum-of-count [coll]\n              (loop [coll2 coll\n                     sum 0]\n                (if (empty? coll2)\n                  sum\n                  (recur (rest coll2)\n                         (+ sum (count (first coll2)))))))\n            (countunique [coll]\n              (count (apply clojure.set/union coll)))]\n      (let [c2 (map setize c)]\n        (= (sum-of-count c2)\n           (countunique c2)))))","problem":153,"user":"4f5cc3b8e4b0030a34fb2b2b"},{"code":"#(every? identity (for [x % y % :when (not= x y)]\n     (empty? (clojure.set/intersection x y))))","problem":153,"user":"523ed522e4b057c4b7cd0a78"},{"problem":153,"code":"#(every? false? (for [i % j % :when (not= i j) h j] (contains? i h)))","user":"55be39f9e4b01b9910ae2a06"},{"problem":153,"code":"(fn pd?\n  [s]\n  (if (<= (count s) 1)\n    true\n    (let [x (first s)\n          disjoint? (loop [ys (next s)]\n                      (if ys\n                        (let [y (first ys)]\n                          (println \"getting intersection of\" x \"and\" y)\n                          (if (empty? (clojure.set/intersection x y))\n                            (recur (next ys))\n                            false))\n                        true))]\n      (if disjoint?\n        (pd? (next s))\n        false))))","user":"59b93cd7e4b0a024fb6ae3c7"},{"code":"#(=\n  (count (reduce clojure.set/union %))\n  (apply + (map count %))\n)","problem":153,"user":"507c7c8be4b0b083f3ff82ef"},{"code":"(letfn [(I [s t]\n          (cond (empty? s) false\n                (empty? t) false\n                (contains? t (first s)) true\n                :else (recur (rest s) t)))\n\n        (D? [s]\n          (cond (empty? s) true\n                (some #(I (first s) %) (rest s)) false\n                :else (recur (rest s))))]\n  D?)","problem":153,"user":"51a4416ae4b0def3c5c5868c"},{"problem":153,"code":"(fn pairwisedisjoint? [s]\n           (let [v (vec s)]\n             (if (seq (rest v))\n               (if (seq (rest (rest v)))\n                 (and (reduce #(and %1 %2) (for [a (rest v)]\n                                            (pairwisedisjoint? (set (vector (first v) a)))))\n                      (pairwisedisjoint? (set (rest v))))\n                                (= (distinct (mapcat vec v)) (mapcat vec v)))\n               true)))","user":"532727bae4b09d4e7a9b54fa"},{"problem":153,"code":"(fn [s]\n        (let [l (for [x s\n                      y s]\n                  (when (not= x y)\n                    (clojure.set/intersection x y)))]\n          (every? #(or (nil? %)\n                       (empty? %)) l)))","user":"54cad59ee4b057c6fda3a26e"},{"problem":153,"code":"(fn finish\n  [s] \n  (let [l (reduce into '() s)] \n    (= (count l) (count (set l)))))","user":"57f81534e4b0d3187e900915"},{"code":"(fn [x]\n (let [us (apply clojure.set/union x)\n       usc (count us)\n       sc (reduce #(+ %1 (count %2)) 0 x)]\n      (= usc sc)))","problem":153,"user":"51b0fc95e4b0c53cf2e68a72"},{"problem":153,"code":"(fn [sets] (= (apply + (map count sets)) \n           (count (into #{} (apply concat sets)))))","user":"6074dfa4e4b069485764de4c"},{"code":"(fn [s]\n  (let [intersections (for [subset s]\n                        (let [othersets (disj s subset)]\n                          (map #(clojure.set/intersection subset %1) othersets)))]\n    (every? empty? (flatten intersections))))","problem":153,"user":"5236b6bce4b05f3be1c7c8fe"},{"problem":153,"code":"(fn [ss]\n    (loop [xs ss]\n          (if (empty? xs)\n              true\n              (if (let [x (first xs)\n                        ys (rest xs)]\n                       (loop [zs ys]\n                             (if (empty? zs)\n                                 true\n                                 (let [z (first zs)\n                                       ws (rest zs)]\n                                      (if (empty? (clojure.set/intersection x z))\n                                          (recur ws)\n                                          false)))))\n                 (recur (rest xs))\n                 false))))","user":"5a34f342e4b0ddc586f153d1"},{"problem":153,"code":"(fn pairwise-disj-sets [coll]\n     (let [count-of-union-of-sets (fn [sets]\n                                    (count (reduce clojure.set/union sets)))\n           sum-of-counts (fn [sets]\n                           (reduce + (map count sets)))]\n       (=\n         (count-of-union-of-sets coll)\n         (sum-of-counts coll)))\n       )","user":"58dcb8cde4b0a4d5acaab6a7"},{"problem":153,"code":"#(let [to-m (fn [s] (into {} (map (fn [x] [x 1]) s)))]\n      (not (some (fn [[k v]] (> v 1)) (apply merge-with + (map to-m %)))))","user":"5a4de614e4b05d388ecb6bb1"},{"problem":153,"code":"(fn __ [x]\n  (let [y (apply concat x)]\n    (= (count y) (count (distinct y)))))","user":"526759b3e4b03e8d9a4a715b"},{"code":"(fn [sets]\n  (loop [sets sets]\n    (if (empty? sets) true\n      (let [ft (first sets)\n            rt (rest sets)\n            rs (some (comp not empty? #(clojure.set/intersection ft %)) rt)]\n        (if (= true rs) false\n          (recur rt))))))","problem":153,"user":"5300158ae4b0d8b024fd370f"},{"code":"(fn p153 [sos]\n    (let [h (first sos)\n          t (rest sos)]\n      (if (empty? t) true\n          (if (some (fn [e] (some #((set (replace {nil :nil} %)) e) t)) (replace {nil :nil} h)) false\n              (p153 t)))))","problem":153,"user":"4f3ec266e4b0e243712b1f8c"},{"code":"#(apply = (flatten\n    (for [a % b % :when (not (identical? a b))]\n        (for [x a y b] (= x y)))))","problem":153,"user":"53500869e4b084c2834f4ad3"},{"problem":153,"code":"(fn [s]\n\t(=\n\t\t(count (reduce clojure.set/union s))\n\t\t(reduce + (map count s))\n\t)\n)","user":"5d2201b8e4b02ea6f0fb69ed"},{"problem":153,"code":"(fn f153 [coll]\n  (->>\n   (mapcat vec coll)\n   (apply distinct?)))","user":"57bbc9bde4b05aa3c4741c31"},{"problem":153,"code":"(fn [a] (every? empty?\n (for [x1 a x2 a\n       :when (not= x1 x2)] \n    (clojure.set/intersection x1 x2)) \n ))","user":"5b60e88be4b0c6492753e70b"},{"code":"(fn [s] (let [x (reduce #(apply conj (seq %) %2) s)] (= (count x) (count (set x)))))","problem":153,"user":"51f66e0ee4b06ff1c25c52c3"},{"problem":153,"code":"#(not (some not-empty\n  (for[x % y % :when (not= x y)]\n   (clojure.set/intersection x y))))","user":"55b1e9e7e4b0da326a65cf74"},{"problem":153,"code":"(fn disjoint [sets]\n  (boolean \n    (reduce\n      (fn overlap? [s1 s2]\n        (if (not s1)\n          false\n          (let [combined (apply conj s1 s2)]\n            (if (= (count combined) (+ (count s1) (count s2)))\n              combined\n              false))))\n      sets)))","user":"503f923fe4b00d1a725ff2ad"},{"problem":153,"code":"(fn [sos]\n  (= (count (apply clojure.set/union sos)) (apply + (map count sos))))","user":"60b2aaebe4b0e0fa5f1b4228"},{"problem":153,"code":"#(let [total-items (apply + (map count %))\n       full-set (apply clojure.set/union %)]\n      (= total-items (count full-set)))","user":"5f331015e4b0574c87022c37"},{"problem":153,"code":"#(every? true? (for [x % y % :while (not= x y)] (empty? (clojure.set/intersection x y))))","user":"54b2ec84e4b09f271ff37d33"},{"problem":153,"code":"(fn [x]\n  (let [scount (apply + (map count x))\n        ucount (count (set (apply concat x)))]\n    (cond\n     (= ucount scount) true\n     :else false)))","user":"602d5eade4b0d5df2af22279"},{"code":"(fn pairwise-disjoint-sets [set-of-set]\n  (every?\n   (fn [s]\n     (let [other (apply clojure.set/union (disj set-of-set s))]\n       (not-any? #(contains? other %) s)))\n   set-of-set))","problem":153,"user":"504f57c7e4b0a02f9cffde71"},{"problem":153,"code":"(fn pair-disj [sets]\n    (if (first sets)\n      (if (reduce #(and %1 (empty? (clojure.set/intersection %2 (first sets)))) true (rest sets))\n        (recur (rest sets))\n        false)\n      true\n      )\n  )","user":"5245e320e4b09dbe66b56177"},{"problem":153,"code":"(fn [s]\n    (every? empty?\n            (for [x s\n                  y s\n                  :when (not= x y)]\n              (clojure.set/intersection x y))))","user":"55e6c3f5e4b050e68259b48c"},{"code":"(fn [sets]                                                     \n  (letfn [(mseq [el] (if (coll? el) (seq el) el))]                        \n    (let [es (count (apply (comp set concat) (mseq sets)))           \n          fs (reduce #(+ %1 (count %2)) 0 sets)]                      \n      (= es fs))))","problem":153,"user":"4f2baf1ae4b0d6649770a04c"},{"code":"(fn [s]\n  ((fn [s a]\n     (if (empty? s)\n       true\n       (if (empty? (clojure.set/intersection (first s) a))\n         (recur (rest s) (clojure.set/union (first s) a)) false)))\n   s #{}))","problem":153,"user":"4f404dcee4b0e243712b1fb0"},{"problem":153,"code":"#( apply distinct? (mapcat seq %))","user":"516d227fe4b06f078fab252d"},{"code":"#(every? (fn [[a b]] (empty? (for [x a y b :when (= x y)] 1)))\n   (for [x % y % :when (not= x y)] [x y]))","problem":153,"user":"4e0e0529535d04ed9115e7b9"},{"problem":153,"code":"(fn [x]\n  (loop [rst (reduce into x)]\n    (if (empty? rst) true\n      (if (> (count (filter #(contains? % (first rst)) x)) 1) false\n        (recur (rest rst))))))","user":"56df6351e4b0ca2494a095f3"},{"problem":153,"code":"(fn disjoint [ sets ]\n  (loop [ seen? #{} \n          to-check (apply concat sets)] \n    (cond \n      (empty? to-check) true\n      (contains? seen? (first to-check)) false\n      :else (recur \n               (conj seen? (first to-check)) \n               (rest to-check) ))))","user":"54d6f22de4b0a52adc2e2023"},{"problem":153,"code":"#(let [a (for [x % y x] (x y))\n       b (distinct a)]\n   (= a b))","user":"5b59d176e4b02d533a91bd86"},{"code":"#(let [c (apply concat %)]\n(= (count c) (count (into #{} c))))","problem":153,"user":"4deff9f9535d08e6dec9fe15"},{"code":"(fn [sets]\n  (letfn [(all-pairs [coll]\n            (let [coll (vec coll)]\n              (for [ [idx elmt] (map-indexed #(vector %1 %2) coll)\n                     other-elmt (subvec coll (inc idx))]\n                (vector elmt other-elmt))))\n          (empty-intersection? [sets]\n            (empty? (apply clojure.set/intersection sets)))]\n    (every? empty-intersection? (all-pairs sets))))","problem":153,"user":"50d93c53e4b0fd36a4b89223"},{"problem":153,"code":"#(> 2 (apply max (vals (apply merge-with + (map frequencies %)))))","user":"52503747e4b0541d1855b828"},{"problem":153,"code":"(fn [ss]\n  (let [total-size (reduce #(+ % (count %2)) 0 ss)\n        merged-set (reduce into #{} ss)\n        merged-size (count merged-set)]\n    (= total-size merged-size)))","user":"536673a8e4b0243289761e76"},{"code":"(fn [ss]\n  (=\n   (reduce + 0 (map count ss))\n   (count (into #{} (apply concat ss)))\n   ))","problem":153,"user":"51aa2b4fe4b04e3dc0c27b21"},{"code":"(fn [s]\n  (= (reduce (fn [a b] (+ a (count b))) 0 s)\n     (count (reduce (fn [a b] (into a b)) #{} s))))","problem":153,"user":"4e773be8535d324fb2983d6e"},{"problem":153,"code":"(fn [sets]\t\n  \t\t\t\t;me meto a cada set y cuento cuantos elementos hay, esa cantidad la sumo a un acumulador:v, luego comparo y si son iguales significa que no hay ele,entos en comun ;D\n  (if (= (reduce #(+ (count %2) %1) 0 sets) (count (reduce clojure.set/union sets))) ;uno todos los sets para que haga un solo set (recordar que con union se quitan los repetidos), luego cuendo los elementos del set formado\n    true ;si son iguales, significa que todos los elementos son difentes porque al hacer el union no se quitaron elementos, es decir, no hay elementos en comun :D\n    false)); si son diferentes, entonces false porque algun elemento aparecio en otro conjunto y al hacer el union este quito y la cantidad fue diferente por eso la comparacion no dio = :D","user":"59e63a2ce4b08badc2a0c569"},{"problem":153,"code":"(fn [s]\n  (let [count-positive (fn [n x]\n                       (if (not= 0 x)\n                         (inc n)\n                         n))\n        all-intersections (fn [c]\n                              (map (fn [x]\n                                     (map (fn [y]\n                                            (count (clojure.set/intersection x y)))\n                                          c))\n                                   c))]\n    (every? #(< % 2)\n            (map\n              #(reduce count-positive 0 %)\n              (all-intersections s)))))","user":"54d000c7e4b018d918be98d7"},{"code":"(fn [set-of-sets] \n      (let [disjoint? (fn [s1 s2] (empty? (clojure.set/intersection s1 s2)))\n\t\t\tpairwise-disjoint-sets (for [A set-of-sets B set-of-sets \n                                         :let [pairwise-disjoint? (or (identical? A B) (disjoint? A B))  ]\n                                         :while pairwise-disjoint?]  [A, B])\n\t\t\tnumber-of-sets (count set-of-sets)] \n\t(= (count pairwise-disjoint-sets) (* number-of-sets number-of-sets )))\n)","problem":153,"user":"51729002e4b044b2ef48a850"},{"problem":153,"code":"(fn f [xs]\n    (=\n      (reduce #(+ %1 (if (set? %2) (count %2) 1)) 0 xs)\n      (count (reduce #(if (set? %2) (into %1 %2) (conj %1 %2)) #{} xs))\n      )\n    )","user":"596d630ae4b069c0a1a19846"},{"code":"(fn [s] (let [l (reduce into '() s)] (= (count l) (count (set l)))))","problem":153,"user":"4f1b92d1535d64f60314647b"},{"problem":153,"code":"#(= (reduce + (map count %)) \n    (count (reduce into  %)))","user":"526a3412e4b03e8d9a4a721e"},{"code":"(fn [s]\n  (= (count (set (apply concat s)))\n     (reduce + (map count s))))","problem":153,"user":"4f1b0ab3535d64f603146474"},{"problem":153,"code":"#(= (distinct (apply concat %))\n   (apply concat %))","user":"57dafe97e4b0bd073c20241c"},{"problem":153,"code":"(fn pairwise-disjoin [colls]\n  (not-any? #(< 0 (count %)) (for [s1 colls\n                                   s2 colls\n                                   :while (not= s1 s2)]\n                               (clojure.set/intersection s1 s2))))","user":"5a67cedbe4b0512ff01cd9ee"},{"problem":153,"code":"(fn\n  [ss]\n  (=\n   (reduce + (map count ss))\n   (count (into #{} (for [x ss y x] y)))))","user":"5796d3ebe4b039eba2ecb0ee"},{"code":"(fn pairwise-disjoint? [sets]\n  (every? identity\n         (for [x sets y sets :when (not= x y)]\n           (empty? (clojure.set/intersection x y)))))","problem":153,"user":"4fcaf7a4e4b0ee37620e1857"},{"problem":153,"code":"(fn [s]\n  (when-let [xs (seq s)]\n    (every? true? (for [a xs b xs :when (not (identical? a b))]\n              (empty? (clojure.set/intersection a b))))))","user":"553abb28e4b09218d5f44ffb"},{"code":"(fn pairwise-disjoint?\n  [s]\n  (empty? (:common \n    (reduce \n      (fn [acc s] \n        (let [{common :common union :union} acc\n              inter (clojure.set/intersection union s)]\n        (if (empty? inter)\n          {:common common :union (clojure.set/union union s)} \n          {:common (clojure.set/union common inter) :union (clojure.set/union union s)})))\n      {:common #{}\n      :union #{}}\n      s))))","problem":153,"user":"4fee04a0e4b0678c553fc308"},{"code":"(fn pairwise-disjoint-sets [coll]\n  (letfn [(combinations [coll]\n            (when-not (empty? coll)\n              (let [x (first coll)\n                    nv (for [y (rest coll)] [x y])]\n                (lazy-cat nv (combinations (rest coll))))))]\n    (reduce #(and %1 %2) (map #(empty? (apply clojure.set/intersection %)) (combinations coll)))))","problem":153,"user":"4f68c485e4b07046d9f4ef7c"},{"problem":153,"code":"(fn [sos] (= #{#{}} (set (for [a sos b sos] (let [i (clojure.set/intersection a b)] (if (= i a) #{} i))))))","user":"50b42cbbe4b001349b2f4abe"},{"problem":153,"code":"#(= (count (reduce (fn [x e] (into x e)) %))\n     (reduce + (map count %) )\n     )","user":"55d42f78e4b0e31453f64a73"},{"code":"#(= (count (apply clojure.set/union %)) (reduce + (map count %)))","problem":153,"user":"4fab31a8e4b081705acca215"},{"problem":153,"code":"(fn p153 [coll]\n  (loop [acc #{} xs coll]\n    (cond (empty? xs) true\n          (not-empty (clojure.set/intersection acc (first xs))) false\n          :else (recur (clojure.set/union acc (first xs)) (rest xs)))))","user":"55645592e4b0c656e3ff1802"},{"problem":153,"code":"(fn dsij-sets\n  [sets]\n  (= (count (apply clojure.set/union (into [] sets)))\n      (apply + (map #(count (into [] %)) (into [] sets)))))","user":"5545477fe4b0a04f79299531"},{"problem":153,"code":"(fn [arg] (= (count (apply concat arg)) (count (set (apply concat arg)))))","user":"594a7ed1e4b07ddc2dafae02"},{"code":"(fn disjoint [sets]\n\t(empty? (for [as sets\n\t\t\t  a as\n\t\t\t\tbs sets\n\t\t\t\tb bs\n\t\t\t\t:when (and (not (identical? as bs)) (or (contains? as b) (contains? bs a)))\n\t\t\t\t]\t[\"as\" as \"b\" b \"bs\" bs \"a\" a (contains? as b) (contains? bs a)]\n\t\t\t\t)))","problem":153,"user":"52ffb7f2e4b0d8b024fd370b"},{"code":"(fn [sets]\n  (let [joiner #(reduce \n                 (fn [acc item]\n                 \t(if-not (= % item) (conj acc [% item]) acc))\n                 [] sets)\n        joined (mapcat joiner sets)\n        inters (map #(apply clojure.set/intersection %) joined)]\n    (every? empty? inters)))","problem":153,"user":"4fe88f78e4b07c9f6fd12c45"},{"problem":153,"code":"(fn [sets]\n  (empty? (for [set1 sets set2 sets\n                :when (and (not= set1 set2) (seq (clojure.set/intersection set1 set2)))]\n            [set1 set2])))","user":"56603e5fe4b068f2fe63dc4a"},{"problem":153,"code":"(let [merge-sets (fn\n                   [sets]\n                   (loop [[h & t] (into [] sets)\n                          accum #{}]\n                     (if (nil? t)\n                       (into accum h)\n                       (recur t (into accum h)))))]\n  (fn mutually-disjoint\n    [sets]\n    (= (apply + (map count sets))\n       (count (merge-sets sets)))))","user":"58152157e4b0f478707a0631"},{"code":"(fn [s] (apply distinct? (reduce concat (map vec s))))","problem":153,"user":"4fb1325de4b081705acca276"},{"code":"(fn [s] (reduce #(and %1 %2) true (for [x s y (disj s x)] (empty? (clojure.set/intersection x y)))))","problem":153,"user":"505dcfc8e4b0e6aca564be0d"},{"code":"(fn [s] (= 0 (count (filter #(< 1 %) (vals (frequencies (for [i s x i] x)))))))","problem":153,"user":"525c575be4b0cb4875a45d38"},{"problem":153,"code":"(fn [xs]\n  (->> xs\n       (apply concat)\n       (group-by identity)\n       (filter #(> (count (second %)) 1))\n       empty?))","user":"55f73078e4b06e875b46cea4"},{"problem":153,"code":"(fn [coll]\n  (= (reduce + (map count coll)) \n     (count (reduce clojure.set/union coll))))","user":"5e99cbd4e4b0157ca96647e6"},{"problem":153,"code":"(fn [args]\n      (=\n        (count (reduce #(clojure.set/union %1 %2) args))\n        (reduce (fn [x y] (+ x (count y))) 0 args)\n        )\n      )","user":"53bcdd41e4b0d9a98559a6c0"},{"problem":153,"code":"(fn [sets]\n  (=\n   (count (apply clojure.set/union sets))\n   (reduce + (map count sets))))","user":"524a9556e4b05ef8e38e64b1"},{"problem":153,"code":"(fn [the-sets]\n            (let [other-sets (fn [a-set]\n                               (->> (disj the-sets a-set)\n                                    (apply clojure.set/union)))]\n              (->> the-sets\n                   (map (fn [a-set]\n                          [a-set (other-sets a-set)]))\n                   (every? (fn [[a-set remainder]]\n                             (->> (clojure.set/intersection a-set remainder)\n                                  empty?))))))","user":"53684a2fe4b0243289761e8c"},{"problem":153,"code":"#(= \n (->> % \n      (reduce (fn [acc s](apply conj acc s)))\n      count \n   )\n (->> % \n       (map count) \n       (reduce +)\n  )\n)","user":"55e8a85be4b0121d4835fd98"},{"problem":153,"code":"(fn [x] (apply distinct? (mapcat seq x)))","user":"5839f079e4b089d5ab817d48"},{"problem":153,"code":"(fn b \n  [cjn]\n  (=\n    (count\n      (apply concat '() cjn))\n    (count\n      (apply clojure.set/union cjn))))","user":"5723e6d6e4b0c5bde472c0f1"},{"code":"(fn [s] (empty?\n    ( remove empty?\n      (for [x s]\n        (mapcat #(when (not= x %) (clojure.set/intersection x %)) (seq s))\n        )\n    )    \n  ) )","problem":153,"user":"528f4462e4b0239c8a67aef0"},{"problem":153,"code":"(fn [s]\n  (let [merged (reduce concat s)]\n  \t(= (count merged)\n       (count (into #{} merged)))))","user":"4e9ff8d0535d7eef3080729c"},{"problem":153,"code":"(fn dj [s]\n  (loop [q (first s) o (rest s)]\n    (if (nil? q)\n      true\n      (if (> (count (filter #(> (count %) 0) (map #(clojure.set/intersection q %) o))) 0)\n          false\n          (recur (first o) (rest o))))))","user":"504457c0e4b01f6c9a8b2360"},{"problem":153,"code":"(fn mutually-disjoint? [col]\n  (letfn [(count-all [sets]\n            (count (for [s sets\n                         item s]\n                     item)))\n          (count-uniq [sets]\n            (count (set (for [s sets\n                              item s]\n                          item))))]\n    (= (count-all col) (count-uniq col))))","user":"569dd6e8e4b0542e1f8d1480"},{"problem":153,"code":"(fn [s]\n          (= (reduce #(+ %1 (count %2)) 0 s)\n             (count (apply clojure.set/union (vec s))))\n          )","user":"53f592b7e4b0db01ade6f9d0"},{"code":"(fn [xs]\n\t(first \n     (reduce #(vector \n               (and (nth %1 0)(empty? (clojure.set/intersection (nth %1 1) %2)))\n               %2) [true #{}] xs)))","problem":153,"user":"503255d0e4b0e78df07b092b"},{"problem":153,"code":"(fn pds [s]\n  (let [uc (count (reduce clojure.set/union s))\n        oc (reduce + (map count s))]\n    (= uc oc)))","user":"53710c09e4b0fc7073fd6ea5"},{"code":"#(every? true?\n              (for [a % b % :when (not= a b)] \n                (empty? (clojure.set/intersection a b))))","problem":153,"user":"525078b6e4b0541d1855b832"},{"problem":153,"code":"#(->> (for [x %1 y %1\n            :when (not= x y)\n            :let [z (clojure.set/intersection x y)]]\n        z)\n      (every? empty?))","user":"567d132ee4b05957ce8c61c3"},{"problem":153,"code":"(fn [sos] (->> sos\n  (mapcat seq)\n  (frequencies)\n  (vals)\n  (remove #(= 1 %))\n  (empty?)\n))","user":"4fc4eb1ee4b081705acca354"},{"problem":153,"code":"(fn check-disj [s]\n  (empty? \n    (flatten \n            (for [x s]\n    (let [y (disj s x)]\n      (map (fn [item]\n             (filter (fn [a] \n                       (contains? x a)) item))\n           y))))))","user":"5829d588e4b051871117bf4a"},{"problem":153,"code":"#(->> (apply concat %) \n      (apply distinct?))\n\n;original solution:\n;#(loop [[[f & n] & r] (mapv vec %)]\n;   (if (some (fn [x] (contains? x f)) (map set r))\n;     false\n;     (if (seq n)\n;       (recur (cons n r))\n;       (if (seq r)\n;         (recur r)\n;         true))))","user":"54d341f7e4b0e8a36923e603"},{"code":"(fn [x] (every? #(= 1 (count %))\n                 (partition-by identity (sort #(< (hash %) (hash %2)) (for [y x z y] z)))))","problem":153,"user":"503354c3e4b0c6c1199c710c"}]