[{"code":"(fn solvable? [maze]\n  (let [\n  n-columns (count (first maze))\n  n-rows (count maze)\n  get-position (fn [[x y]]\n    (-> maze (nth y) (nth x)))\n  positions (reduce\n      (fn [acc coord]\n        (let [c (get-position coord)]\n          (cond\n            (= c \\#)     acc\n            (= c \\space) (conj acc { :interior (conj (acc :interior) coord) })\n            (= c \\C)     (conj acc { :start coord })\n            (= c \\M)     (conj acc { :end coord }))))\n      { :start nil, :end nil, :interior #{} }\n      (for [y (range n-rows) x (range n-columns)] [x y]))\n  >>= (fn [xs f]\n    (apply concat (map f xs)))\n  neighbors (fn [[x y]]\n    (list [(+ x 1) y] [x (- y 1)] [(- x 1) y] [x (+ y 1)]))\n  in-bounds? (fn [[x y]]\n    (and (<= 0 x)\n         (< x n-columns)\n         (<= 0 y)\n         (< y n-rows)))\n  traversable? (fn [coord]\n    (or (= coord (positions :end))\n        (some #{coord} (positions :interior))))\n  unique-in (fn [path coord]\n    (not (some (partial = coord) path)))\n  expand (fn [path]\n    (let [\n    coord (first path)\n    next-coords (->> (neighbors coord)\n                     (filter in-bounds?)\n                     (filter traversable?)\n                     (filter (partial unique-in path)))\n    ]\n    (map #(cons % path) next-coords)))\n  complete? (fn [path]\n    (= (first path) (positions :end)))\n  impl (fn [paths]\n    (cond\n      (empty? paths) false\n      (some complete? paths) true\n      :else (recur (>>= paths expand))))\n  ]\n  (impl [(list (positions :start))])))","problem":117,"user":"4e691c79535d8ccf87e9fe97"},{"problem":117,"code":"(fn solution [maze]\n  (let [N (count maze)\n        M (count (first maze))\n        ; SELECT x, y FROM coll WHERE pred\n        query (fn [sql]\n                (let [{:keys [select from where]} sql]\n                  (map #(zipmap select ((apply juxt select) %))\n                       (filter where from))))\n        ; UPDATE coll SET k = v WHERE pred\n        update (fn [sql]\n                 (let [{:keys [update set val where]} sql]\n                   (map (fn [mp]\n                          (if (where mp) (assoc mp set val) mp)) update)))\n        tods (fn [acc x]\n               (let [[id coll] acc\n                     j (rem id M)\n                     i (/ (- id j) M)]\n                 [(inc id)\n                  (conj coll {:x i :y j :occup x})]))\n        ds0    (second (reduce tods [0 []] (reduce str maze)))\n        q      (fn [x y] (query {:select [:x :y] :from x :where #(= y (:occup %))}))\n        CHEESE (first (q ds0 \\C))\n        nbs (fn nbs [v]\n              (let [{:keys [x y]} v]\n                [{:x (dec x) :y y}\n                 {:x (inc x) :y y}\n                 {:x x       :y (dec y)}\n                 {:x x       :y (inc y)}]))]\n    (loop [ds ds0 oldcnt 0]\n      (let [opport (set (mapcat nbs (q ds \\M)))\n            opcnt (count opport)]\n        (cond\n          (contains? opport CHEESE) true\n          (= opcnt oldcnt) false\n          :else (let [mice1 (clojure.set/join opport (q ds \\space))]\n                  (recur (update {:update ds :set :occup :val \\M\n                                  :where #(contains? mice1 {:x (:x %) :y (:y %)})})\n                         opcnt)))))))","user":"4dc97aec535d5973398f9284"},{"problem":117,"code":"(fn [maze]\n  (letfn [(neighbors [y x]\n            (for [dy [-1 0 1]\n                  dx [-1 0 1]\n                  :when (= 1 (+ (* dy dy) (* dx dx)))]\n              [(+ y dy) (+ x dx)]))\n          (flood-fill [m [i j]]\n            (if (= \\# (get-in m [i j] \\#))\n              m\n              (reduce flood-fill\n                      (assoc-in m [i j] \\#)\n                      (neighbors i j))))\n          (position [m c]\n            (first (for [i (range (count m))\n                         j (range (count (first m)))\n                         :when (= c (get-in m [i j]))]\n                     [i j])))]\n    (let [flooded (flood-fill (mapv vec maze)\n                              (position maze \\M))]\n      (nil? (position flooded \\C)))))","user":"55c4e48be4b0e31453f649a7"},{"code":"(fn mc [ lab ]\n  \n  ( let [seen (ref (vec (map vec lab)))]\n\n  ((fn search-from [ [r c :as pos] ]\n    (println \"Testing\" pos)\n    (let [chr (get-in @seen pos)]\n    (cond\n      (= chr nil) false\n      (= chr \\#) false\n      (= chr \\C) true\n      (= chr \\S) false\n      :else\n        (do\n          (dosync (alter seen assoc-in pos \\S))\n          (or \n            (search-from [(dec r) c]) \n            (search-from [(inc r) c])\n            (search-from [r (dec c)])\n            (search-from [r (inc c)]))))))\n    ; find mouse\n    (loop [ r 0  ]\n      (let [c (.indexOf (nth lab r) \"M\")]\n        (if (>= c 0)  \n          [r c]\n          (recur (inc r))))))\n  )\n )","problem":117,"user":"502952c9e4b0b33e9bf6fdf1"},{"code":"(fn [b]\n  (not (nil? (some #{(first b)}\n    [\"M   C\" \"#######\" \"C######\" \"C# # # #\"]))))","problem":117,"user":"4dfe65a1535d04ed9115e787"},{"problem":117,"code":"(fn [B]\n  (let [M (count B)\n        N (count (first B))\n        m (first (filter (comp (partial = \\M) (partial get-in B)) (for [i (range M) j (range N)] [i j])))\n        O (fn [[i j]] (map (fn [k l] [(+ k i) (+ l j)]) [-1 1 0 0] [0 0 1 -1]))]\n    (loop [[q & Q :as P] [m] S #{m}]\n      (cond (empty? P) false\n            (= \\C (get-in B q)) true\n            :else (let [n (filter (fn [p] (and (#{\\C \\space} (get-in B p)) (not (S p)))) (O q))] \n                    (recur (concat Q n) (into S n)))))))","user":"55f6fe09e4b06e875b46cea2"},{"problem":117,"code":"(fn [maze]\n  (let [w (count (first maze))\n        h (count maze)\n        visited (atom #{})]\n    (letfn [(visit [p] (swap! visited conj p))\n            (visited? [p] (contains? @visited p))\n            (neighbors [[x y]]\n              (remove (fn [[x y]] (or (< x 0) (>= x w) (< y 0) (>= y h)))\n                      (map (fn [[dx dy]] [(+ x dx) (+ y dy)]) [[-1 0] [1 0] [0 -1] [0 1]])))\n            (tile [[x y]] (nth (nth maze y) x))\n            (explore [p]\n              (visit p)\n              (let [n (neighbors p)]\n                (if (some #(= \\C (tile %)) n) true\n                    (let [u (remove #(or (visited? %)\n                                          (not (= \\space (tile %)))) n)]\n                      (if (some #(explore %) u) true false)))))]\n      (explore (some #(when (= \\M (tile %)) %) (for [y (range h) x (range w)] [x y]))))))","user":"537e745ae4b06839e8705ea6"},{"problem":117,"code":"(fn [rows]\n  (let [w (count (rows 0))\n        h (count rows)\n        maze (apply str rows)\n        cheese-pos (java.lang.String/.indexOf maze \"C\")\n        neighbors (fn [pos maze]\n                    (map #(get maze %) [(- pos w) (+ pos w)\n                                        (if (= 0 (mod pos (inc w))) nil (inc pos))\n                                        (if (= 0 (mod pos w)) nil (dec pos))]))\n        calculate-cell (fn [maze idx]\n                         (if (and (= (get maze idx) \\space)\n                                  (some #(= \\M %) (neighbors idx maze)))\n                           \\M (get maze idx)))\n        spread-mouse (fn [maze]\n                       (vec (map #(calculate-cell maze %) (range (count maze)))))\n        mouse-is-near-cheese (fn [maze]\n                               (some #(= \\M %) (neighbors cheese-pos maze)))]\n    (loop [maze maze prev nil]\n      (cond\n       (mouse-is-near-cheese maze) true\n       (= maze prev) false\n       :else (recur (spread-mouse maze) maze)))))","user":"54febf4be4b07d26eda61d45"},{"code":"(fn solvable [maze]\r\n  (let [temp-str   (some #(if (not= (.indexOf % \"M\") -1) %) maze)\r\n        mouse-cord [(.indexOf maze temp-str) (.indexOf temp-str \"M\")]\r\n        maze-size  (count maze)\r\n        str-size   (count (first maze))]\r\n    (not= ((fn path-length [curr-cords visited]\r\n             (if (empty? curr-cords) 0\r\n               (if (some #(= (.indexOf (maze (first %)) \"C\") (second %)) curr-cords) 1\r\n                 (let [temp-cords  (reduce #(conj %1 [(dec (first %2)) (second %2)] [(inc (first %2)) (second %2)] [(first %2) (dec (second %2))] [(first %2) (inc (second %2))]) #{} curr-cords)\r\n                       new-cords   (clojure.set/difference (set (remove #(or (= -1 (first %)) (= -1 (second %)) (= maze-size (first %1)) (= str-size (second %1)) (= ((vec (maze (first %))) (second %)) \\#)) temp-cords)) visited) \r\n  \t\t           new-visited (clojure.set/union visited new-cords)\r\n        \t           temp-val    (path-length new-cords new-visited)]\r\n                   (if (= temp-val 0) 0 (+ 1 temp-val)))))) #{mouse-cord} #{mouse-cord}) 0)))","problem":117,"user":"505dd5c4e4b0e6aca564be0e"},{"problem":117,"code":"(fn [maze]\n  (let [width (count (nth maze 0))\n        height (count maze)\n\n        get-maze (fn [maze x y]\n                   (nth (nth maze y) x))\n\n        set-maze (fn [maze x y v]\n                   (assoc maze y\n                          (assoc (into [] (nth maze y)) x v)))\n\n        find-in-maze (fn [maze v]\n                       (first (for [x (range width)\n                                    y (range height)\n                                    :when (= (get-maze maze x y) v)]\n                                {:x x :y y})))\n\n\n        get-neighbours (fn [field]\n                         (->> [{:y 1} {:y -1} {:x 1} {:x -1}]\n                              (map #(hash-map\n                                      :x (+ (:x field) (or (:x %) 0))\n                                      :y (+ (:y field) (or (:y %) 0))\n                                      ))\n                              (filter #(and (< -1 (:x %) width) (< -1 (:y %) height)))))\n        ]\n\n    (loop [current-maze maze\n           frontier     [(find-in-maze maze \\M)]]\n\n      (let [field  (first frontier)\n            x      (:x field)\n            y      (:y field)]\n\n        (if (empty? field)\n          false\n          (case (get-maze current-maze x y)\n            \\C      true\n            (\\m \\#) (recur current-maze (into [] (rest frontier)))\n            (\\M \\space) (recur\n                          (set-maze current-maze x y \\m)\n                          (into (into [] (rest frontier)) (get-neighbours field)))))))))","user":"56d2a103e4b0ea9b8538f7a3"},{"code":"(fn [m]\n  (let [height (count m)\n        width (count (first m))]\n    ((fn [[from to]]\n       (loop [[head & queue] [from]\n              visit (into (set (mapcat #(list [% -1] [% width]) (range height)))\n                          (set (mapcat #(list [-1 %] [height %]) (range width))))]\n         (if head\n           (if (= head to)\n             true\n             (recur (concat\n                     queue\n                     (remove\n                      #(or (visit %) (= (nth (nth m (first %)) (second %)) \\#))\n                      (map\n                       #(map + head %)\n                       [[-1 0] [1 0] [0 -1] [0 1]])))\n                    (conj visit head)))\n           false)))\n     (loop [[l & r] m\n            from [-1 -1]\n            to [-1 -1]\n            level 0]\n       (if l\n         (let [p1 (.indexOf l \"C\")\n               p2 (.indexOf l \"M\")]\n           (recur\n            r\n            (if (< p1 0) from [level p1])\n            (if (< p2 0) to [level p2])\n            (inc level)))\n         [from to])))))","problem":117,"user":"4f9fe2b9e4b0dcca54ed6d40"},{"code":"(fn [r m]\r\n  (not= nil (some #(re-seq #\"C@\" %)\r\n\t\t  (flatten (take 50 (iterate r m))))))\r\n#(map (fn [s] (.replaceAll s \"(M|@) \" \"$1@\"))\r\n  (reverse (apply map str %)))","problem":117,"user":"4dce6e41535d5973398f92a2"},{"code":"(fn good-mouse?\n  [p & ng]\n  (let [_ (prn \"args: \" p \" - \" ng)\n        read-path (fn\n                    [p]\n                    (let [mc (count (first p))\n                          mr (count p)]\n                      [mc mr (vec (mapcat seq p))]))\n        p (if (string? (first p))\n            (read-path p)\n            p)\n        mc (first p)\n        mr (second p)\n        moves (fn\n                [[x y]]\n                [[(inc x) y]\n                 [(dec x) y]\n                 [x (inc y)]\n                 [x (dec y)]])\n        get-object-at (fn\n                        [[x y] p]\n                        (if (and (>= x 0) (>= y 0)\n                                 (< x mc) (< y mr))\n                          (let [i (+ (* mc y) x)]\n                            (subs (reduce str (last p)) i (inc i)))\n                          nil))\n        valid? (fn\n                 [[a b] p]\n                 (let [c (get-object-at [a b] p)]\n                   (not (or (nil? c)\n                            (= c \\#)\n                            (= c \"#\")))))\n\n        delete-object (fn\n                        [[x y] p]\n                        (let [i (+ (* mc y) x)]\n                          (assoc-in p [2 i] \\#)))\n        valid-moves (fn\n                      [[x y] p]\n                      (filter #(valid? % p)\n                              (moves [x y])))\n        get-loc (fn\n                  [c p]\n                  (let [vp (last p)\n                        ps (reduce str vp)\n                        i (.indexOf ps c) ]\n                    [(rem i mc) (quot i mc)]))\n        get-mouse-loc (fn\n                        [p]\n                        (get-loc \"M\" p))\n        get-cheese-loc (fn\n                         [p]\n                         (get-loc \"C\" p))\n        nn (mapcat #(valid-moves % p) (or ng [(get-mouse-loc p)]))]\n    (if (= 0 (count nn))\n      false\n      (if (contains? (set nn) (get-cheese-loc p))\n        true\n        (recur (reduce #(delete-object %2 %) p nn) (into ng nn))))))","problem":117,"user":"51852961e4b0da5a5be3babb"},{"problem":117,"code":"(fn [m]\n  (let [w     (count (first m))\n        h     (count m)\n        [a z] (->> [\"M\" \"C\"]\n                (map #(.indexOf (apply str m) %))\n                (map #(vector (quot % w) (rem % w))))\n        ok?   (fn [[r c]]\n                (and (< -1 r h)\n                     (< -1 c w)\n                     (not= \\# (.charAt (nth m r) c))))\n        nbs    (fn [[r c]]\n                (filter ok?\n                  [[(dec r) c]\n                   [(inc r) c]\n                   [r (dec c)]\n                   [r (inc c)]]))]\n\n    (loop [frontier [a]\n           visited  #{}]\n      (if (seq frontier)\n        (recur (remove visited (distinct (mapcat nbs frontier)))\n               (into visited frontier))\n        (boolean (visited z))))))","user":"4f9d8083e4b0dcca54ed6d23"},{"problem":117,"code":"#(-> #{[\"M # C\"] [\"########\"\n              \"#M  #  #\"\n              \"#   #  #\"\n              \"# # #  #\"\n              \"#   #  #\"\n              \"#  #   #\"\n              \"#  # # #\"\n              \"#  #   #\"\n              \"#  #  C#\"\n              \"########\"] \n    [\"M     \"\n              \"      \"\n              \"      \"\n              \"      \"\n              \"    ##\"\n              \"    #C\"]}\n     (contains? %)\n     not)","user":"5e8ce2fee4b0cb0169546328"},{"code":"(fn [grid]\n  (letfn [(find-char [c]\n                     (for [i (range 0 (count grid))\n                           j (range 0 (count (nth grid i)))\n                           :let [coord [i j], chr (get-in grid coord)]\n                           :when (= c chr)]\n                       coord))\n          (one-step-away? [[x1 y1] [x2 y2]]\n                         (or\n                          (and (= x1 x2) (= 1 (Math/abs (- y1 y2))))\n                          (and (= y1 y2) (= 1 (Math/abs (- x1 x2))))))]\n    (let [start (first (find-char \\M))\n          end (first (find-char \\C))\n          others (set (find-char \\space))]\n      (loop [current-nodes #{start}, available others]\n        (cond (empty? current-nodes) false\n              (some #(one-step-away? end %) current-nodes) true\n              :else (let [next-nodes (filter #(some (partial one-step-away? %) current-nodes) available)]\n                      (recur next-nodes (clojure.set/difference available next-nodes))))))))","problem":117,"user":"536ca4bde4b0fc7073fd6e49"},{"problem":117,"code":"(fn [m]\n   (let [a (for [i (range (count m))\n                   j (range (count (nth m i)))] [i j])\n         s (group-by (fn [[i j]] (nth (m i) j)) a)\n         \n         [m] (s \\M)\n         [c] (s \\C)\n         ns (fn [[a b]] [[a (+ 1 b)] [a (- b 1)] [(+ a 1) b] [(- a 1) b]])]\n     (loop [v #{}\n            pt #{m}]\n       (cond\n        (v c) true\n        (seq pt)\n        (recur (into v pt)\n               (->> pt (mapcat ns) (remove v) (filter #(or ((set (s \\space)) %) (= c %)))))\n\n        1 false))))","user":"55be39f9e4b01b9910ae2a06"},{"code":"(fn __ [board]\n  (let [pos-map (into {}\n                      (map (fn [[k v]] [k (into #{} (map second v))])\n                           (group-by first\n                                     (for [i (range (count board))\n                                           j (range (count (first board)))]\n                                       [(get-in board [i j]) [i j]]))))\n        cheese (first (pos-map \\C))\n        spaces (conj (pos-map \\space) cheese)]\n    (letfn [(directions-from [[x y]]\n              [[(inc x) y] [(dec x) y] [x (inc y)] [x (dec y)]])                             \n            (next-visited [s]\n              (->> s\n                   (mapcat directions-from) ;; get new directions\n                   (filter spaces)          ;; but only those in \"spaces\"\n                   (into s)))]              ;; and add them to the visited set\n      (loop [visited (pos-map \\M) last-visited #{}]\n        (cond (contains? visited cheese) true\n              (empty? (clojure.set/difference visited last-visited)) false ;; failed to advance\n              :else (recur (next-visited visited) visited))))))","problem":117,"user":"50812debe4b01a93d3f38e4c"},{"code":"(fn [maze]\n    (let [n (count maze)\n          p (count (first maze))\n          dirs [[-1 0] [0 -1] [1 0] [0 1]]\n          add (fn [x y] (map + x y))\n          in-board?\n          (fn [sq]\n            (let [a (first sq)\n                  b (second sq)]\n              (and (>= a 0) (< a n) (>= b 0 ) (< b p))))\n          is-in?\n          (fn is-in?[col x]\n            (cond (empty? col) false\n                  (= x (first col)) true\n                  :default (is-in? (rest col) x)))\n          get-content ;; function to get the content of a square,\n          ;; square being defined by [y x]\n          (fn [square]\n            (nth (nth maze (first square)) (second square)))\n          get-neighbours\n          (fn [square]\n            (filter in-board? (map #(add square %) dirs)))\n          check-square\n          (fn check-square [square used adj]\n            (println \"square: \" square)\n            (println \"adj:\" adj)\n            (let [candidates (get-neighbours square)\n                  cand (filter #(and (not (is-in? used %)) (not= (get-content %) \\#)) candidates)\n                  u (conj used square)\n                  adj-new (distinct (concat adj cand))]\n              (println \"candidates:\" candidates)\n              (println \"cand:\" cand)\n              (println \"adj-new:\" adj-new)\n              (cond (empty? adj-new) false\n                    (some #(= (get-content %) \\C) cand) true\n                    ;;(check-square (first cand) u) true\n                    :default (check-square (first adj-new) u (filter #(not (is-in? u %)) adj-new))\n                    ;; (loop [avoid u\n                    ;;        to-go cand]\n                    ;;   (println \"to-go:\" to-go)\n                    ;;   (println \"avoid:\" avoid)\n                    ;;   (cond (empty? to-go) false\n                    ;;         (check-square (first to-go) avoid) true\n                    ;;         :default (recur (conj avoid (first to-go)) (rest avoid))))\n                     )))\n          y0\n          (first (filter (fn [row] (is-in? (nth maze row) \\M)) (range n)))\n          x0\n          (first (filter #(= (nth (nth maze y0) %) \\M) (range p)))\n          init-square [y0 x0]\n          ]\n      (println \"init-square:\" init-square)\n      (check-square init-square [] [])))","problem":117,"user":"4e49a7bb535dc968683fc4c6"},{"code":"(fn solveable? [board] \n  (let [moves [[inc identity] [identity inc] [dec identity] [identity dec]]\n        width (-> board first count)\n        height (count board)\n        occupant (fn [board row column] (nth (nth board row) column))\n        occupied-cells (fn [board piece]\n                         (set\n                           (for [column (range width)\n                                 row (range height)\n                                 :when (= piece (occupant board row column))]\n                              [row column])))\n        cheeses (occupied-cells board \\C)\n        visitable (clojure.set/union (occupied-cells board \\space) cheeses)\n        adjacent-to-cell (fn [[x y]] (->> moves (map (fn [[fx fy]] [(fx x) (fy y)])) set))\n        adjacent-to-cells (fn [coll] (apply clojure.set/union (map adjacent-to-cell coll)))\n        unoccupied-adjacent-to-cells (fn [coll visited] \n                                        (clojure.set/difference \n                                          (clojure.set/intersection (adjacent-to-cells coll) visitable)\n                                          visited))\n        success? (fn [visited] (seq (clojure.set/intersection visited cheeses)))\n        search (fn [last-moves visited]\n                  (let [visited (clojure.set/union visited last-moves)]\n                    (if\n                      (success? visited) true\n                        (let [next-moves (unoccupied-adjacent-to-cells last-moves visited)]\n                          (if (empty? next-moves)\n                            false\n                            (recur next-moves visited))))))]\n    (search (occupied-cells board \\M) #{})))","problem":117,"user":"53513d28e4b084c2834f4ae3"},{"code":"(fn [board]\n  (let [x-max (count board)\n        y-max (count (first board))]\n    ((fn move [bv]\n       (letfn [(m? [x y]\n                 (if (or (< x 0) (< y 0) (> x (dec x-max)) (> y (dec y-max)))\n                   false\n                   (= ((bv x) y) \\M)))\n               (adj-m? [x y]\n                 (or  (m? (dec x) y)\n                      (m? x (inc y))\n                      (m? (inc x) y)\n                      (m? x (dec y))))]\n         (let [new-board\n               (for [x (range (count bv))]\n                 (for [y (range (count (first bv)))]\n                   (let [xy-val ((bv x) y)]\n                     (cond\n                      (= xy-val \\#) \\#\n                      (= xy-val \\M) \\M\n                      (= xy-val \\C) (if (adj-m? x y) \\* \\C)\n                      (= xy-val \\space) (if (adj-m? x y) \\M \\space)))))\n               new-board (vec (map vec new-board))]\n           (cond\n            (= new-board bv) false\n            (not-empty (filter #{\\*} (apply concat new-board))) true\n            :else (move new-board)))))\n     (vec (map vec board)))))","problem":117,"user":"512d3304e4b040332b905b2d"},{"problem":117,"code":"(fn __ [E]\n (let [transpose (fn transpose [X] (apply map list X))\n       compress (fn compress [X]\n      \t\t(loop [a X prev nil acc []]\n\t\t      (if (empty? a) acc\n\t\t\t  (recur (rest a) \n\t\t\t  \t(first a)\n\t\t\t  \t(if (= (first a) prev) acc (conj acc (first a)))))))\n       Ec (->> E (map #(clojure.string/split % #\"\"))\n       \t      compress transpose compress transpose)\n       m (count (first Ec))\n       n (count Ec)\n       xya (fn [[x y]] (+ x (* m y)))\n       axy (fn [a] [(mod a m) (int (/ a m))])\n       s (vec (flatten Ec))\n       Ci (.indexOf s \"C\")\n       enwsi (fn [[x y]] (map #(if (or (< (first %) 0) (< (second %) 0) \n       \t     \t     \t \t      (>= (first %) m) (>= (second %) n)) [] %)\n       \t     \t [[(inc x) y] [x (dec y)] [(dec x) y] [x (inc y)]]))\n       t (tree-seq (fn [se]\n       \t \t     (some #(and (not-empty %) \n\t\t     \t   (or (= \" \" (nth se (xya %)))\n\t\t\t       (= \"C\" (nth se (xya %)))))\n\t\t\t\t  (enwsi (axy (.indexOf se \"M\")))))\n\t\t     (fn [se] \n\t\t     \t (->> (enwsi (axy (.indexOf se \"M\")))\n\t\t\t      (map (fn [xy] \n\t\t\t      \t     (when (and (not-empty xy) (not= \"#\" (nth se (xya xy)))\n\t\t\t\t     \t   (not= \".\" (nth se (xya xy))))\n\t\t\t\t     \t   (assoc (assoc se (.indexOf se \"M\") \".\") (xya xy) \"M\"))))\n\t\t\t      (remove nil?) (vec)))\n       \t s)]\n(= true (clojure.walk/walk #(= Ci (.indexOf % \"M\")) #(some true? %) t))))","user":"52747090e4b03e8d9a4a74a5"},{"code":"(fn [b]\n  (let [h (count b) ; height\n        w (count (first b)) ; width\n        find (fn [e] (filter identity (flatten (for [x (range h)] ; find the coordinates of an element (mouse or cheese)\n                                                 (for [y (range w)]\n                                                   (when (= (get-in b [x y]) e) [x y]))))))\n        mouse (find \\M)\n        cheese (find \\C)\n        neighbours (fn [[x y]] (remove #(or (some neg? %) ; remove out of the board and borders\n                                            (>= (first %) h)\n                                            (>= (second %) w)\n                                            (= (get-in b %) \\#))\n                                       [[(dec x) y] ; above\n                                        [x (dec y)] ; left\n                                        [(inc x) y] ; below\n                                        [x (inc y)]]))] ; right\n    (loop [visited #{mouse}]\n      (let [expanded (clojure.set/union visited (set (mapcat neighbours visited)))] ; visit some more cells\n        (or (contains? expanded cheese) ; did we find the cheese?\n            (and (not= (count visited) (count expanded)) ; if no new cells to visit, finished\n                 (recur expanded)))))))","problem":117,"user":"500900dee4b0144d4f561e42"},{"code":"(fn [maze] \n  (let [value #(nth (nth maze (% :y)) (% :x))\n        vertices (remove #(= \\# (value %)) (for [x (-> maze first count range) y (-> maze count range)] {:x x :y y}))\n        neighborhood (fn [v] (filter #(some #{%} vertices) (for [c [:x :y] op [inc dec]] (update-in v [c] op))))\n        connected? #(some #{%1} (neighborhood %2))\n        unreachable (fn [reachable unknown]\n          (if (empty? reachable)\n            unknown\n            (let [new-reachable (filter #(some (partial connected? %) reachable) unknown)]\n              (recur new-reachable (clojure.set/difference unknown new-reachable)))))\n        mouse? #(= \\M (value %))\n        cheese? #(= \\C (value %))\n  ] (not-any? cheese? (unreachable (filter mouse? vertices) (set (remove mouse? vertices))))))","problem":117,"user":"524be8e0e4b09eba1c0223f1"},{"problem":117,"code":"(fn [maze]\n  (let [idxs (for [i (range (count maze)) j (range (count (first maze)))] [i j])\n        idx-of (fn [x] (first (for [idx idxs :when (= x (get-in maze idx))] idx)))\n        m (idx-of \\M)\n        c (idx-of \\C)\n        ok? (fn [idx] (#{\\M\\C\\ } (get-in maze idx)))\n        adj (fn [[i j]] [[(dec i) j] [i (dec j)] [i (inc j)] [(inc i) j]])\n        edges (for [u idxs v (adj u) :when (and (ok? u) (ok? v))] [u v])\n        map-vals (fn [f m] (zipmap (keys m) (map f (vals m))))\n        graph (map-vals #(set (map second %)) (group-by first edges))]\n    (loop [q [m] r #{m}]\n      (cond\n       (r c) true\n       (empty? q) false\n       :else\n       (let [vs (clojure.set/difference (graph (peek q)) r)]\n         (recur (into (pop q) vs) (clojure.set/union r vs)))))))","user":"52ce1abfe4b07d0d72b27389"},{"code":"(fn [lst]\n  (let [m (reduce \n     #(if (second %1) %1 \n        (let [c (.indexOf %2 \"M\") r (first %1)]\n          (if (>= c 0) [r c] [(inc r) nil]))) [0 nil] lst)]\n    ((fn tmp [[r c] l lst]\n        (let [mr (dec (count lst))\n              mc (dec (count (first lst)))\n              s (if (or (< r 0) (> r mr) (< c 0) (> c mc)) \\# \n                  (nth (nth lst r) c))]\n           (cond \n              (or (contains? @l [r c]) (= s \\#)) false\n              (= s \\C) true\n              (or\n                 (= s \\space) \n                 (= s \\M))  (do (swap! l conj [r c]) \n                              (or\n                                 (tmp [(dec r) c] l lst)\n                                 (tmp [(inc r) c] l lst)\n                                 (tmp [r (dec c)] l lst)\n                                 (tmp [r (inc c)] l lst)))))) \n      m (atom #{}) lst)))","problem":117,"user":"4dbdab4e535d020aff1edf49"},{"code":"(fn for-science\n  [maze]\n  (let [mz (mapv vec maze)\n        [mx my :as mouse] (loop [x 0 y 0]\n                            (case (get-in mz [y x])\n                              \\M [y x]\n                              (\\C \\# \\space) (recur (inc x) y)\n                              nil (cond (contains? (get mz y) (inc x))\n                                        (recur (inc x) y)\n                                        (contains? mz (inc y))\n                                        (recur 0 (inc y))\n                                        :default [false false])))\n        occupied? (fn [mz]\n                    (fn [position]\n                      (contains? #{\\# \\M nil}\n                                 (get-in mz position))))\n        neighbors (fn [[x y]]\n                    [[(dec x) y]\n                     [x (dec y)]\n                     [x (inc y)]\n                     [(inc x) y]])\n        mark-all (fn [mz positions]\n                   (reduce (fn [mz [y x :as position]]\n                             (if (and (contains? mz y)\n                                      (contains? (get mz y) x)\n                                      (not (#{\\C} (get-in mz [y x]))))\n                               (assoc-in mz position \\M)\n                               mz))\n                           mz\n                           positions))\n        found?  (fn [mz positions]\n                  (first (filter (comp #{\\C} (partial get-in mz))\n                                 positions)))\n        search (fn search [positions mz]\n                 (cond (found? mz positions)\n                       (found? mz positions)\n                       (empty? (remove nil?\n                                       (map (partial get-in mz) positions)))\n                       false\n                       :default\n                       (let [all-neighbors (remove (occupied? mz)\n                                                   (set\n                                                    (mapcat neighbors\n                                                            positions)))\n                             mz' (mark-all mz positions)]\n                         (search all-neighbors mz'))))]\n    (and (search [mouse] mz)\n      true)))","problem":117,"user":"51f9527fe4b09be9c177e549"},{"code":"(fn [mz]\n  (boolean\n   (some #(= (get-in mz %) \\C)\n         ((fn e [v p]\n            (if (and (not (v p))\n                     (#{\\M \\C \\ } (get-in mz p)))\n              (reduce e (conj v p)\n                      (map #(map + p %) [[1 0] [0 1] [-1 0] [0 -1]]))\n              v))\n          #{}\n          (some #(if (= (get-in mz %) \\M) %)\n                (for [x (range (count (mz 0)))\n                      y (range (count mz))]\n                  [y x]))))))","problem":117,"user":"4e8612f8535db62dc21a62f2"},{"code":"(fn cheese?\r\n  [maze]\r\n\t(letfn [(get-xy [x y] (or (get-in maze [x y]) \\#))\r\n\t\t\t\t\t(print-maze [m] (println (interpose \\newline m)))\r\n\t\t\t\t\t(find-in [c] (flatten (for [row (range (count maze)) \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  col (range (count (first maze))) \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  :when (= c (get-xy row col))]\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  \t[row col])))\r\n\t\t\t\t\t(can-get-to-cheese [visited_set, [x y]]\r\n\t\t\t\t\t\t(cond \r\n\t\t\t\t\t\t\t(visited_set [x y]) false\r\n\t\t\t\t\t\t\t(= \\M (get-xy x y)) true\r\n\t\t\t\t\t\t\t(= \\# (get-xy x y)) false\r\n\t\t\t\t\t\t\t:else\r\n\t\t\t\t\t\t\t\t(or  ;default recursive case\r\n\t\t\t\t\t\t\t\t\t(can-get-to-cheese (conj visited_set [x y]) [(dec x) y])\r\n\t\t\t\t\t\t\t\t\t(can-get-to-cheese (conj visited_set [x y]) [x (inc y)])\r\n\t\t\t\t\t\t\t\t\t(can-get-to-cheese (conj visited_set [x y]) [(inc x) y])\r\n\t\t\t\t\t\t\t\t\t(can-get-to-cheese (conj visited_set [x y]) [x (dec y)]))))]\r\n\t\t(can-get-to-cheese #{} (find-in \\C))))","problem":117,"user":"4e8a0c82535d3e98b802328d"},{"problem":117,"code":"(fn [rs]\n  (let [mz (apply merge-with\n            concat\n            (for [[r i] (map list rs (range))\n                 [x j] (map list r (range))\n                 :when (not= \\# x)]\n             {x [[i j]]}))\n        [m] (mz \\M)\n        [c] (mz \\C)\n        abs #(if (< % 0) (- %) %)\n        close? #(= #{0 1} (set (map abs (map - %1 %2))))]\n    (loop [xs (mz \\space)\n           ys #{m}]\n      (if (some #(close? c %) ys) true\n        (if-let [x' (first (for [x xs y ys :when (close? x y)] x))]\n          (recur (remove #{x'} xs) (conj ys x'))\n          false)))))","user":"553e0b70e4b0a04f792994e8"},{"code":"(fn _ [s]\n    (let [cell (fn \n                 ([m x y] (get (get m x) y))\n                 ([m pt]  (get (get m (first pt)) (second pt)))),\n\n          seq-contains? (fn [sequence item]\n                          (if (empty? sequence) false\n                            (reduce #(or %1 %2) (map #(= %1 item) sequence)))),\n\n          update-cell (fn [m x y v]\n                        (let [X (count m), Y (count (m 0))]\n                          (into [] (map (fn [i] \n                                          (into [] (map (fn [j] (if (and (= i x) (= j y)) v \n                                                                  (cell m i j))) \n                                                        (range Y))) )\n                                        (range X))))),\n\n          find-cell (fn ([m v]\n                         (first (remove nil? (apply concat (if (nil? m) nil\n                                                             (let [x (count m), y (count (m 0))]\n                                                               (map (fn [i] \n                                                                      (map (fn [j] (if (= v (cell m i j)) [i j])) (range y))) \n                                                                    (range x))))))))),\n          find-cell (memoize find-cell),\n\n          neighbors (fn neighbors\n                      ([m pt]\n                       (neighbors m (first pt) (second pt)))\n                      ([m x y]\n                       (vector\n                         (cell m (dec x)      y)  ; north\n                         (cell m      x  (inc y)) ; east\n                         (cell m (inc x)      y)  ; south\n                         (cell m      x  (dec y)) ; west\n                         ))),\n          neighbors (memoize neighbors),\n\n          move-north (fn [m]\n                       (let [pt (find-cell m \\M),\n                             xs (neighbors m pt),\n                             n (nth xs 0),\n                             x (first pt),\n                             y (second pt)]\n                         (cond \n                           (= \\  n) (update-cell (update-cell m (dec x) y \\M) x y \\.)\n                           :else nil))),\n\n          move-east (fn [m]\n                      (let [pt (find-cell m \\M),\n                            xs (neighbors m pt),\n                            e (nth xs 1),\n                            x (first pt),\n                            y (second pt)]\n                        (cond \n                          (= \\  e) (update-cell (update-cell m x (inc y) \\M) x y \\.)\n                          :else nil))),\n\n          move-south (fn [m]\n                       (let [pt (find-cell m \\M),\n                             xs (neighbors m pt),\n                             s (nth xs 2),\n                             x (first pt),\n                             y (second pt)] \n                         (cond \n                           (= \\  s) (update-cell (update-cell m (inc x) y \\M) x y \\.)\n                           :else nil))),\n\n          move-west (fn [m]\n                      (let [pt (find-cell m \\M),\n                            xs (neighbors m pt),\n                            w (nth xs 3),\n                            x (first pt),\n                            y (second pt)] ; north\n                        (cond \n                          (= \\  w) (update-cell (update-cell m x (dec y) \\M) x y \\.)\n                          :else nil))),\n\n          slv (fn _ [f m]\n                (if (nil? m) nil\n                  (let [xs (neighbors m (find-cell m \\M))]\n                    (cond (seq-contains? xs \\C) true\n                          :else (into [] (list \n                                           (f f (move-north m)) \n                                           (f f (move-west m))\n                                           (f f (move-south m)) \n                                           (f f (move-east m)) \n                                           )))))),\n          msolve (memoize slv)]\n      (let [m (into [] (for [c s] (into [] c))),\n            xs (neighbors m (find-cell m \\C))]\n        (if (not (seq-contains? xs \\ )) false\n          (seq-contains? (flatten (msolve msolve m)) true)))))","problem":117,"user":"4f038567535dcb61093f6b0c"},{"problem":117,"code":"(letfn\n[\n(is-valid [[x y] b]\n  (and (>= x 0) (>= y 0) (< x (count (first b))) (< y (count b))))\n\n(get-xys [b]\n  (for [x (range 0 (count (first b)))\n        y (range 0 (count b))]\n        [x y]))\n\n(get-val [[x y] b]\n  (nth (nth b y) x))\n\n(place [[x y] b s]\n  (assoc b y (assoc (nth b y) x s)))\n\n(get-at [xy b]\n    [xy, (get-val xy b)])\n\n(find [s b]\n  (->> b\n    (get-xys)\n    (map #(get-at % b))\n    (filter #(= s (second %)))\n    ffirst))\n\n(get-neighbors [[x y] b]\n  (->>\n    (for [x1 [(dec x) x (inc x)]\n        y1 [(dec y) y (inc y)]\n        :when (not= (= x1 x) (= y1 y))]\n        [x1 y1])\n    (filter #(is-valid % b))\n    (map #(get-at % b))))\n\n(get-next-moves\n  [[[x y], b]]\n  (->>\n    (get-neighbors [x y] b)\n    (filter #(or (= \\space (second %)) (= \\C (second %))))\n    (map first)\n    (map (fn [[x1 y1]]\n      (let [b1 (place [x1 y1] (place [x y] b \\#), \\M)]\n        (get-now [x1 y1] b1))))))\n\n(get-now\n  ([b]\n    (let [here (find \\M b)]\n      (get-now here b)))\n  ([here b]\n    [here, b]))\n\n(distinct-by [f xs]\n  (map (comp first val) (group-by f xs)))\n\n; initial solution used to keep the states as [location, board] in a set\n; however this was too slow\n; optimization now keeps states in a vector, distinct-by'ing on every generation\n; this however can introduce false negatives when the same location can be \n; reached along different routes and the distinct-by operations selects one\n; which blocks its own access to the target\n(get-next [now]\n  (distinct-by first (mapcat get-next-moves now)))\n\n(vvec [b]\n  (vec (map vec b)))\n\n(solve [b]\n  (let [b (vvec b)\n        here (find \\M b)]\n  (loop [now [(get-now b)]]\n    (let [solution (some #(not (find \\C (second %))) now)\n          next (get-next now)]\n    (if solution\n        true\n    (if (empty? next)\n        false\n    (recur next)))))))\n]\nsolve)","user":"57717915e4b0979f896515b3"},{"problem":117,"code":"(fn game-of-mouse [board]\r\n  (letfn [\r\n    (new-cell [vv]\r\n      (let [a (flatten vv)\r\n           [c n] [(nth a 4) (map (partial nth a) [1 3 5 7])]]\r\n        (if (and (contains? #{\\  \\C} c) (some #(= \\M %) n)) \\M c)))\r\n\r\n    (frame-board [vv]\r\n      (let [l (apply str (repeat (count (first vv)) \"#\"))\r\n            between (fn[c a] (conj (reverse (conj (reverse c) a)) a))]\r\n        (map #(between % \\#) (between vv l))))\r\n\r\n    (part-board [vv]\r\n      (map \r\n        (fn [[a b c]] (partition 3 1 (map vector a b c)))\r\n        (partition 3 1 (frame-board vv))))\r\n    \r\n    (draw-board [vv]\r\n      (map #(apply str %) vv))\r\n    \r\n    (next-gen [board]\r\n      (draw-board\r\n        (map\r\n          #(map new-cell %)\r\n          (part-board board))))\r\n    \r\n    (take-while-diff\r\n      [f c]\r\n      (let [s (take-while\r\n                (fn[[a b]] (f a b))\r\n                (partition 2 1 c))]\r\n        (conj\r\n          (map last s)\r\n          (first (first s)))))]\r\n\r\n  (not (some #(re-find #\"C\" %)\r\n    (last\r\n      (take-while-diff \r\n        #(not= %1 %2) \r\n        (iterate next-gen board)))))))","user":"5470699ae4b00cfc9eacc1b6"},{"problem":117,"code":"(fn [maze]\n  (letfn\n    [(cell [[x y]] (nth (nth maze x []) y \\#))\n     (passable [p] (#{\\space \\C} (cell p)))\n     (neighbors [[x y]] (list [(inc x) y] [(dec x) y] [x (inc y)] [x (dec y)]))\n     (passable-neighbors [p] (filter passable (neighbors p)))\n     (find-m [line] (first (keep-indexed #(when (= %2 \\M) %1) line)))]\n    (let [pm (first (keep-indexed\n                      #(let [y (find-m %2)] (when y [%1 y])) maze))]\n      (loop [black #{pm} grey (passable-neighbors pm)]\n        (if (empty? grey) false\n          (if (some #(= \\C (cell %)) grey) true\n            (recur\n              (into black grey)\n              (filter #(not (black %)) (mapcat passable-neighbors grey)))))))))","user":"508157b2e4b0946d0443855c"},{"problem":117,"code":"(fn [maze]\n          (let [move (fn [[row col]]\n                       [[(dec row) col]\n                        [row (dec col)]\n                        [row (inc col)]\n                        [(inc row) col]])\n                find-mouse (fn [maze]\n                             (first (keep-indexed\n                                      (fn [row contents]\n                                        (let [col (.indexOf contents \"M\")]\n                                          (if (not (neg? col)) [row col]))) maze)))\n                next-moves (fn [cells]\n                             (mapcat move cells))\n                valid-moves (fn [new maze]\n                              (filter #(#{\\space \\M \\C} (get-in maze %)) new))\n                grow (fn [cells maze]\n                       (let [new (next-moves cells)\n                             valid (valid-moves new maze)]\n                         (into #{} (concat cells valid))))\n                reached-cheese (fn [cells maze]\n                                 (some #{\\C} (map #(get-in maze %) cells)))\n                start (find-mouse maze)]\n            (loop [old #{start}]\n              (let [new (grow old maze)]\n                (cond\n                  (= new old) false\n                  (reached-cheese new maze) true\n                  :else (recur new))))))","user":"5164867fe4b003cf19fdde3e"},{"code":"(let [\n  make-board (fn [lines]\n    (let [line-to-vec #(into [] (map {\\space :e, \\# :w, \\M :m, \\C :c} %))]\n      (into [] (map line-to-vec lines))))\n\n  xcount (fn [board] (count board))\n\n  ycount (fn [board] (count (board 0)))\n\n  neighbors (fn [[x y]] (map (fn [[dx dy]] [(+ dx x) (+ dy y)]) [[0 1] [0 -1] [1 0] [-1 0]]))\n\n  reachable-neighbors (fn [board pos]\n    (if (= :m (get-in board pos))\n      (filter                \n        (fn [[nx ny]] (and (< -1 nx (xcount board)) (< -1 ny (ycount board)) (#{:e :c} (get-in board [nx ny]))))\n        (neighbors pos))\n      '()))\n\n  new-mice (fn [board]\n    (into #{}\n      (mapcat                \n        #(reachable-neighbors board %)\n        (for [x (range (xcount board)) y (range (ycount board))] [x y]))))\n\n  flood (fn [board]\n    (if-let [nm (seq (new-mice board))]\n      (recur (reduce #(assoc-in % %2 :m) board nm))\n      (not (contains? (set (flatten board)) :c))))]\n\n  #(flood (make-board %)))","problem":117,"user":"4ec07699535dfed6da9c6da2"},{"problem":117,"code":"(fn maze-search\n  [maze]\n  ;; Find M\n  (let [mpos\n        (loop [r 0]\n          (let [indexed (mapv (fn [a b] [a b]) (range) (seq (nth maze r)))\n                hunt (filter (fn [[i v]]\n                               (= \"M\" (str v))) indexed)]\n            (if (seq hunt)\n              [r (ffirst hunt)]\n              (recur (inc r)))\n            ))\n        grab (fn [[r c]] (when (and (> r -1) (< r (count maze)))\n                           (let [row (seq (nth maze r))]\n                             (when (and (> c -1) (< c (count row)))\n                               [[r c] (str (nth row c))]))))\n        match (fn [pos to-match] (let [[rc v] (grab pos)] (when (= to-match v) rc)))\n        legal-move (fn [pos] (or (match pos \" \") (match pos \"C\")))\n        moves (fn [[r c]]\n                (apply list\n                       (remove nil?\n                               (map legal-move\n                                    [[r (dec c)]            ;left\n                                     [r (inc c)]            ;right\n                                     [(inc r) c]            ;up\n                                     [(dec r) c]            ;down\n                                     ]))))]\n    (loop [frontier (moves mpos)\n           explored #{mpos}]\n      (if (seq frontier)\n        (let [new-pos (peek frontier)]\n          (if (match new-pos \"C\")                           ;;CHEESE!\n            true\n            (let [viable-moves (->> (moves new-pos) (remove explored))]\n              (recur (if (seq viable-moves)\n                       (apply conj (pop frontier) viable-moves)\n                       (pop frontier))\n                     (conj explored new-pos))\n              )))\n        false))))","user":"536ecd9fe4b0fc7073fd6e76"},{"problem":117,"code":"(fn [maze]\n  (let [h        (count maze)\n        w        (count (first maze))\n        around   (fn [y x] (let [y-1 (dec y) y+1 (inc y)\n                                 x-1 (dec x) x+1 (inc x)]\n                             [[y-1 x] [y x-1] [y x+1] [y+1 x]]))\n        m-around (fn [y x] (some (partial = \\M)\n                                 (map (partial get-in maze) (around y x))))]\n    (if (some (partial some (partial = \\C)) maze)\n      (let [new-maze (vec\n                       (for [y (range h)]\n                         (apply str\n                           (for [x (range w)]\n                             (let [c (get-in maze [y x])]\n                               (if (and (or (= c \\space) (= c \\C))\n                                        (m-around y x))\n                                 \\M c))))))]\n        (if (not= new-maze maze)\n          (recur new-maze)\n          false))\n      true)))","user":"573d58c8e4b05c31a32c0811"},{"problem":117,"code":"(fn mouse [board]\n  (letfn [(propagate-mouse [coordinates]\n            (let\n              [square (get-in board coordinates)\n               neighbors (map\n                           (comp\n                             (partial get-in board)\n                             (partial map + coordinates))\n                           [[-1 0] [0 -1] [1 0] [0 1]])]\n               (cond\n                 (= square \\#) square\n                 ((set neighbors) \\M) \\M\n                 :else square)))]\n    (let\n      [updated-board (for [x (range (count board))]\n                       (for [y (range (count (first board)))]\n                         (propagate-mouse [x y])))]\n      (if\n        (= board updated-board)\n        (->> board\n             (apply concat)\n             (some #{\\C})\n             nil?)\n        (recur \n          (mapv vec updated-board))))))","user":"521e8227e4b0dd19981ad082"},{"problem":117,"code":"(fn [maze]\n   (letfn [(vec [maze]\n             (vec (map (comp vec seq) maze)))\n           (walk [[r c :as cpos]\n                  maze\n                  walked]\n             (filter\n              (fn [[[r c :as o] s]]\n                (and (not= \\# s)\n                     (not (nil? s))\n                     (not (some #{o} walked))))\n              (for [nextf [inc dec]\n                    nexti [0 1]]\n                (let [npos (update-in cpos [nexti] nextf)]\n                  [npos (get-in maze npos)]))))\n           (search [maze b]\n             (let [rc (count maze)\n\t         cc (count (first maze))]\n               (ffirst\n                (drop-while\n                 (fn [[_ s]] (not= s b))\n                 (for [r (range rc)\n                       c (range cc)]\n                   [[r c]\n                    (get-in maze [r c])])))))    \n           (dfs [[[r c :as cpos] cs]\n                 walked\n                 stack]\n             (cond (= \\C cs) true\n                   (empty? stack) false\n                   :else (let [[[npos ns :as nxt] & rst] stack\n                               stack (into rst (walk npos maze walked))\n                               walked (conj walked npos)]\n                           (recur nxt walked stack))))]\n     (let [startpos (search maze \\M)]\n       (dfs [startpos \\M]\n            (list [startpos \\M])\n            (list [startpos])\n            ))))","user":"4f5cc3b8e4b0030a34fb2b2b"},{"problem":117,"code":"(fn [avec]\n  (letfn [(get-coords\n           [v a]\n           (set\n            (for [i (range (count a))\n                  j (range (count (first a)))\n                  :when (= v (get-in a [i j]))]\n                    [i j])))\n          (get-route\n           [s m]\n           (let [s' (into s\n                          (apply concat\n                                 (for [[a b] s]\n                                   (filter (fn [[c d]]\n                                             (or (= [(dec a) b] [c d])\n                                                 (= [(inc a) b] [c d])\n                                                 (= [a (dec b)] [c d])\n                                                 (= [a (inc b)] [c d])))\n                                           m))))]\n             (if (= s s')\n               s\n               (recur s' m))))]\n    (contains?\n      (get-route (get-coords \\M avec)\n                 (concat\n                  (get-coords \\space avec)\n                  (get-coords \\C avec)))\n      (first (get-coords \\C avec)))))","user":"56ae214ce4b03c432f18735a"},{"problem":117,"code":"(fn f [board]\n  (let [steps [[-1 0] [0 -1] [0 1] [1 0]]\n        find-c (fn [[line & _ :as board]]\n                 (first (for [x (range (count line))\n                              y (range (count board))\n                              :when (= \\C (get-in board [y x]))]\n                          [y x])))\n        find-m (fn find-rec [board pos path]\n                 (let [val (get-in board pos)]\n                   (cond\n                     (or (= val nil) (= val \\#)) false\n                     (some #{pos} path) false\n                     (= val \\M) true\n                     :else (boolean (some\n                                     #(find-rec board % (cons pos path))\n                                     (map #(mapv + pos %) steps))))))]\n    (find-m board (find-c board) [])))","user":"56795deae4b05957ce8c6187"},{"code":"(fn cat->mouse? [maze]\n  (let [maze   (mapv vec maze)\n        height (count maze)\n        width  (count (first maze))\n        delta  [-1 0 1]\n        \n        neighbors\n        (fn [[y x]]\n          (remove\n           #(let [loc (get-in maze %)]\n              (or (nil? loc) (= \\# loc)))\n           (for [dy delta, dx delta\n                 :when (not= dx dy)\n                 :when (not= dx (- dy))]\n               [(+ y dy) (+ x dx)])))\n        \n        cat\n        (first\n         (for [y (range height)\n               x (range width)\n               :when (#{\\C} (get-in maze\n                                    [y x]))]\n             [y x]))]\n    \n    (loop [visited  #{cat}\n           locations [cat]]\n      (if (empty? locations)\n        false\n        (or (some #(= \\M (get-in maze %))\n                  locations)\n            \n            (->> locations\n                 (mapcat neighbors)\n                 (remove visited)\n                 (recur (into visited\n                              locations))))))))","problem":117,"user":"532ab0bde4b09d4e7a9b5527"},{"problem":117,"code":"(fn t[m]\n  (letfn[(nnth [a i j] (if (and (>= i 0) (>= j 0) (< j (count a)) (< i (count (nth a j)))) (str (nth (nth a j) i)) \"#\"))\n         (isMAround [a ii jj]\n              (or (= \"M\" (nnth a (dec ii) jj)) (= \"M\" (nnth a ii (dec jj))) (= \"M\" (nnth a (inc ii) jj)) (= \"M\" (nnth a ii (inc jj)))))\n         (isDone [a]  (true? (some true?\n            (mapcat\n              (fn [j]\n                 (map (fn [i] (if (and (= (nnth a i j) \"C\") (isMAround a i j)) true false)) (range (count (nth a j))))\n              )\n              (range (count a))\n            )\n           )))\n        ]\n    (loop [f m p []]\n      (cond  (isDone f) true\n        (= p f) false\n        :else (recur\n                 (reduce\n                     (fn [r j]  (conj r (reduce\n                                          (fn [l i] (conj l (if (and (= (nnth f i j) \" \") (isMAround f i j)) \"M\" (nnth f i j))))\n                                          [] (range (count (nth f j)))\n                                        )\n                                )\n                      ) []\n                     (range (count f)))\n                  f)\n      )\n    )\n  )\n)","user":"55eeb37ae4b0121d4835fdf3"},{"problem":117,"code":"(fn for-science\n  [rows]\n  (letfn [(get-mouse []\n            (for [[index row] (zipmap (range (count rows)) rows)\n                  :when (.contains row \"M\")\n                  ]\n              [index (.indexOf row \"M\")]))\n          (get-neighbours [pos]\n            (map #(map + %1 pos) [[0 1] [0 -1] [1 0] [-1 0]]))\n          (filtered-neighbours [pos visited]\n            (filter (fn [cell] (and (every? identity (map #(>= % 0) cell))\n                                    (< (first cell) (count rows))\n                                    (< (second cell) (count (first rows)))\n                                    (not (check-pos cell \\#))\n                                    (not (contains? visited cell))))\n                    (get-neighbours pos)))\n          (check-pos [pos c]\n            (= c (nth (nth rows (first pos)) (second pos))))\n          (dfs-search [start]\n            (loop [stack (conj '() start), visited #{}]\n              (if (not-empty stack)\n                (let [children (filtered-neighbours (first stack) visited)]\n                  (if (some identity (map check-pos children (repeat (count children) \\C)))\n                    true\n                    (recur (concat (rest stack) children) (conj visited (first stack)))))\n                false)))\n          ]\n    (dfs-search (first (get-mouse)))\n    )\n  )","user":"5545477fe4b0a04f79299531"},{"problem":117,"code":"(fn [maze]\n          (let [w (count maze)\n                h (count (first maze))\n                arr (make-array Long/TYPE w h )\n                m (doall (map-indexed (fn [idx itm] (map-indexed (fn [idx2 itm2]  (aset arr idx idx2 (condp = itm2 \\C 1 \\M 2 \\space 0 \\# 9 )))  itm) ) maze))\n                _ (prn m)\n                m0 (doall (for [x (range w) y (range h) :when  (= (aget arr x y) 2) ] [x y]))\n                test-range (fn [x y] (and (< x w) (>= x 0) (< y h) (>= y 0)))\n                freeway (fn [x y] (let [aval (aget arr x y) ] (or (= aval 0) (= aval 1)))) ]\n            (loop [mice m0]\n              (let [syr (filter #(= 1 %) (for [row arr el row] el)) ]\n                (if (empty? syr) true\n                  (let [newmouse (reduce (fn [acc [x y]] \n                                           (let  [anew (reduce (fn [acc2 [dx dy]]\n                                                                 (let [xx (+ x dx) yy (+ y dy)]\n                                                                   (if (and (test-range xx yy) (freeway xx yy) ) (do (aset arr xx yy 2) (conj acc2 [xx yy])) acc2))    )\n                                                               [] [[-1 0] [1 0] [0 -1] [0 1]])]\n                                             (if (empty? anew) acc (concat acc anew))))\n                                         mice  mice)]\n                    (if (= mice newmouse) false\n                      (recur newmouse))))))))","user":"533c2605e4b0e30313ee6cd7"},{"code":"(fn [rect] \n(letfn [\n\n(to-nodes [test-string] (flatten (map-indexed (fn [row-index row-value] (map #(assoc % :y (inc row-index)) (map-indexed (fn [column-index column-value] (assoc {} :x (inc column-index) :value (str column-value))) row-value))) test-string)))\n\n(columns [rect] (apply map vector rect))\n\n(column-count [rect] (apply max (map count rect)))\n\n(row-count [rect] (count rect))\n\n(row-indexes [rect] (range 1 (inc (row-count rect))))\n\n(column-indexes [rect] (range 1 (inc (column-count rect))))\n\n(positions-matching [rect pred] (filter #(pred %) (all-positions rect)))\n\n(combinations [groups] (if (empty? groups) [[]] (mapcat #(map % (combinations (rest groups))) (map #(partial cons %) (first groups)))))\n\n(all-positions [rect] (combinations (vector (column-indexes rect) (row-indexes rect))))\n\n(neighbors [position] (vector (vector (inc (first position)) (second position)) (vector (dec (first position)) (second position)) (vector (first position) (inc (second position))) (vector (first position) (dec (second position)))))\n\n(value-at [rect pos] (nth (nth rect (dec (second pos))) (dec (first pos))))\n\n(is-legal-position? [rect pos] (true? (some #(= pos %) (all-positions rect))))\n\n(legal-neighbors [rect pos] (filter #(is-legal-position? rect %) (neighbors pos)))\n\n(replace-value [coll n val-fn] (concat (take (dec n) coll) (vector (val-fn (nth coll (dec n)))) (drop n coll)))\n\n(replace-value-in-rectangle [rect pos val] (replace-value rect (second pos) #(replace-value % (first pos) (constantly val))))\n\n(mouse-positions [rect] (positions-matching rect #(= \\M (value-at rect %))))\n\n(found-cheese? [rect] (true? (some #(= \\C %) (map #(value-at rect %) (mapcat #(legal-neighbors rect %) (mouse-positions rect))))))\n\n(spaces-to-conquer [rect] (filter #(= (value-at rect %) \\space) (mapcat #(legal-neighbors rect %) (mouse-positions rect))))\n\n(for-science [rect] (cond (found-cheese? rect) true (empty? (spaces-to-conquer rect)) false :else (for-science (reduce #(replace-value-in-rectangle %1 %2 \\M) rect (spaces-to-conquer rect)))))\n]\n(for-science rect)))","problem":117,"user":"52f10094e4b05e3f0be25ee8"},{"problem":117,"code":"(fn maze-path? [maze]\n  (let [rows (mapv #(apply vector %) maze)\n        nrows (count rows)\n        ncols (count (first rows))]\n    (letfn\n        [(at [r c] (nth (nth rows r nil) c nil))\n         (find-char [char]\n           (for [r (range 0 nrows) c (range 0 ncols)\n                 :when (= char (at r c))] [r c]))\n         (valid-neighbors [r c]\n           (filter #(let [v (apply at %)]\n                      (or (= \\space v) (= \\C v)))\n                   [[(dec r) c] [(inc r) c] [r (dec c)] [r (inc c)]]))\n         (path-exists? [loc fringe visited]\n           (let [neighbors (filter #(not (contains? visited %))\n                                   (apply valid-neighbors loc))\n                 newfringe (reduce conj (disj fringe loc) neighbors)\n                 newvisited (conj visited loc)]\n             (cond (= \\C (apply at loc)) true\n                   (empty? newfringe) false\n                   :else (recur (first newfringe) newfringe newvisited))\n             ))\n         ]\n      (path-exists? (first (find-char \\M)) #{} #{})\n      )\n    )\n  )","user":"589037b4e4b00487982d51d0"},{"code":"(fn labyrinth \n  ([maze previous before]\n  (let [new-maze (map #(.replaceAll % \"M | M\" \"MM\") maze)\n        rotated (map #(apply str %) (apply map vector new-maze))]\n     (cond \n        (some #(or (.contains % \"MC\") (.contains % \"CM\")) new-maze) true\n        (= new-maze before) false\n        :else (recur rotated maze previous))))\n  ([maze] (labyrinth maze [] [])))","problem":117,"user":"4dcfbc44535d5973398f92a7"},{"problem":117,"code":"(fn [xs] (letfn [(findc [xv c]\n                              (set (for [x (range (count (first xv))) y (range (count xv))\n                                         :when (= (get-in xv [y x]) c)] [x y])))\n                            (near [[x y] [a b]] (or (and (= 1 (Math/abs (- x a))) (= y b))\n                                                    (and (= 1 (Math/abs (- y b))) (= x a))))\n                            (progress [s xn] (filter #(near s %) xn))\n                            (progress-all [xs xn] (set (mapcat #(progress % xn) xs)))]\n                      (let [xv (mapv (comp vec seq) xs)\n                            mouse (findc xv \\M)\n                            cat (findc xv \\C)\n                            path (findc xv \\space)]\n                        (loop [pp (progress-all cat path) rp path]\n                          (let [pm (progress-all mouse pp)]\n                            (if (not (empty? pm)) true\n                                (let [rp (clojure.set/difference rp pp)\n                                      pp (progress-all pp rp)]\n                                 (if (empty? pp) false\n                                     (recur pp rp)))))))))","user":"5b924123e4b0c0b3ffbd4a34"},{"code":"(letfn [(position [k s]\r\n          (loop [n 0\r\n                 s s]\r\n            (cond\r\n              (empty? s) nil\r\n              (= k (first s)) n\r\n              :else (recur (inc n) (rest s)))))\r\n        (find-mouse [maze]\r\n          (loop [n 0\r\n                 rows maze]\r\n            (if (empty? rows)\r\n                nil\r\n              (if-let [p (position \\M (first rows))]\r\n                [n p]\r\n                (recur (inc n) (rest rows))))))\r\n        (can-go? [pos maze]\r\n          (let [x (pos 0)\r\n                y (pos 1)]\r\n            (and (>= x 0) (< x (count maze))\r\n                 (>= y 0) (< y (count (maze 0)))\r\n                 (not= \\# (get-in maze pos)))))\r\n        (search [maze]\r\n          (loop [open [(find-mouse maze)]\r\n                 closed #{}]\r\n            (let [p (peek open)]\r\n              (cond\r\n                (not p) false\r\n                (closed p) (recur (pop open) closed)\r\n                (= (get-in maze p) \\C) true\r\n                :else (let [open (transient (pop open))\r\n                            x (p 0)\r\n                            y (p 1)\r\n                            up [(dec x) y]\r\n                            down [(inc x) y]\r\n                            left [x (dec y)]\r\n                            right [x (inc y)]]\r\n                        (if (can-go? up maze) (conj! open up))\r\n                        (if (can-go? down maze) (conj! open down))\r\n                        (if (can-go? left maze) (conj! open left))\r\n                        (if (can-go? right maze) (conj! open right))\r\n                        (recur (persistent! open) (conj closed p)))))))]\r\n  search)","problem":117,"user":"4fcc6cb3e4b0ee37620e1861"},{"code":"(fn maze-path [maze]\n  (let [horiz-size-of-maze (+ 2 (count (first maze)))\n        flat-maze (into [] (apply str (map #(str \"#\" % \"#\") maze)))]\n    (letfn [(replace-in-maze [c indx maze] \n              (into [] (concat (subvec maze 0 indx) [c] (subvec maze (inc indx)))))\n            (f [maze']\n              (let [starting-point (.indexOf maze' \\C)\n                    new-points (map #(+ starting-point %) [-1 1 horiz-size-of-maze (- horiz-size-of-maze)])]\n                (if (some #(= (get-in maze' [%]) \\M) new-points)\n                  true\n                  (some (fn [point] \n                          (and (= (get-in maze' [point]) \\space) \n                               (f (replace-in-maze \\C point (replace-in-maze \\# starting-point maze')))))\n                        new-points))))]\n      (if (f flat-maze) true false))))","problem":117,"user":"50ef9a7ae4b0bdaecbb47d9e"},{"code":"(fn mousemaze [maze]\n   (let [xmax (count maze) ymax (count (first maze))\n         cell-at (fn [[x y]] (if (and (< -1 x xmax) (< -1 y ymax)) (nth (nth maze x) y) \\#))\n         neighbors (fn [[x y]]\n                     (filter (fn [[x y]] (not (= (cell-at [x y]) \\#)))\n                             (vector [(dec x) y] [(inc x) y] [x (dec y)] [x (inc y)])))\n         [start end pointmap]\n         (reduce (fn [[s e m] next]\n                   (let [c (cell-at next)]\n                     [(if (= c \\M) next s) (if (= c \\C) next e)\n                      (if (= c \\#) m\n                          (let [ns (neighbors next)]\n                            (if ns (assoc m next ns))))]))\n                 [nil nil {}] (for [x (range xmax) y (range ymax)] [x y]))\n         path? (fn path? [path p]\n                 (if (= p end) path\n                     (let [ns (filter #(not (contains? path %)) (neighbors p))]\n                       (some #(path? (set (concat path ns)) %) ns))))\n         ]\n     (if (path? #{} start) true false)\n     ))","problem":117,"user":"4e89f46c535d3e98b8023288"},{"code":"(fn [L]\n  (let[L (vec (map vec L))\n       n (count L) m (count (first L))\n       l (fn [x] (for [i (range n) j (range m) :when (= x (get-in L [i j]))] [i j]))\n       M (first (l \\M))\n       C (first (l \\C))\n       W (conj (set (l \\space)) C)\n       g (fn [[x y]] (filter W [[x (- y 1)] [x (+ y 1)] [(- x 1) y] [(+ x 1) y]]))\n       G (fn [v] (set (for [x v y (g x) :when (not (v y))] y)))]\n    (loop [v #{M}]\n      (let [w (into v (G v))]\n      (if (= v w)\n        (if (v C) true false)\n        (recur w))))))","problem":117,"user":"4e82f85d535db62dc21a62ce"},{"code":"(fn [t]\n         (let [s (into [] (map #(into [] (map int % )) t))\n               r (count s) c (count (first s))\n               p (filter vector?\n                   (for [x (range c) y (range r)]\n                      (when (= 77 (get-in s [y x])) [y x])))\n               n (fn [p]\n                   (filter (fn[[y x]] (and (<= 0 x (dec c)) (<= 0 y (dec r))))\n                     (map #(into[] (map + % p)) [[1 0] [-1 0] [0 1] [0 -1]])))]\n         (loop [r p s s]\n             (cond \n               (empty? r) false\n               (= 67 (get-in s (first r))) true\n               (= 35 (get-in s (first r))) (recur (rest r) s)\n               :e (recur (concat (rest r) (n (first r))) (assoc-in s (first r) 35))))))","problem":117,"user":"4deff9f9535d08e6dec9fe15"},{"code":"(fn maze [m]\n  (let [mouse \\M\n        cheese \\C\n        wall \\#\n        r (count m)\n        c (if (zero? r) (count m) (count (first m)))\n        start (first (for [x (range r)\n                      y (range c)\n                      :when (= mouse (get-in m [x y]))]\n                       [x y]))\n        movable? (fn [[a b]]\n                   (cond\n                    (or (> 0 a) (> 0 b)) false\n                    (or (>= a r) (>= b c)) false\n                    (= wall (get-in m [a b])) false\n                    :else true))\n        next-moves (fn [visited [a b]]\n                    (let [next [[(dec a) b] [(inc a) b] [a (dec b)] [a (inc b)]]]\n                      (set (filter #(and (not (contains? visited %)) (movable? %)) next))))\n        all-moves (fn ! [visited moves]\n                    (let [next-visited (reduce conj visited moves)]\n                      (if (empty? moves)\n                        visited\n                        (! next-visited (reduce into #{} (map #(next-moves next-visited %) moves))))))]\n    (not (empty? (filter #(= cheese %) (map #(get-in m %) (all-moves #{start} [start])))))))","problem":117,"user":"501c1492e4b086d93747d180"},{"problem":117,"code":"(fn [mtx]\n  (let [m (count (first mtx))\n        arr (apply str mtx)\n        n (count arr)\n        mouse-pos (.indexOf arr \"M\")\n        visited-pos (atom #{mouse-pos})\n        neighbor-of? (fn [pos0] (fn [pos]\n                        (and (not (@visited-pos pos))\n                             (not= (get arr pos) \\#)\n                             (#{1 m -1 (- m)} (- pos pos0)))))\n        neighbors (fn [pos0] (filter (neighbor-of? pos0) (range n)))]\n    (letfn [(path? [pos0]\n              (do\n                (swap! visited-pos conj pos0)\n                (or (= (get arr pos0) \\C)\n                    ((complement not-any?) path? (neighbors pos0)))))]\n      (path? mouse-pos))))","user":"5f82609ae4b0c071e6c840f9"},{"code":"(fn [mz]\n  (let [cols (count (first mz))\n        rows (count mz)\n        maze-cell-indexes (for [y (range rows) x (range cols)] [y x])\n        find (fn [elt]\n               (first\n                 (filter\n                   (fn [[x y]] (= (get-in mz [x y]) elt))\n                   maze-cell-indexes)))\n        mouse (find \\M)\n        cheese (find \\C)\n        neighbors (memoize (fn [[x y]]\n                    (for [[dx dy] [[0 -1] [-1 0] [1 0] [0 1]]\n                          :let [nx (+ x dx) ny (+ y dy)]\n                          :when (and\n                                  (< -1 nx rows)\n                                  (< -1 ny cols)\n                                  (not= (get-in mz [nx ny]) \\#))]\n                      [nx ny])))]\n    (loop [reached #{mouse}]\n      (if\n        (reached cheese) true\n        (let [newly-reached\n              (into reached\n                    (mapcat neighbors reached))]\n          (if (= newly-reached reached)\n            false\n            (recur newly-reached)))))))","problem":117,"user":"504c8165e4b09724c857af31"},{"code":"(fn maze\n  [state]\n  (letfn\n    [(north\n      [loc indexed-state]\n      (let\n        [new-loc (first (filter #(and (= (:row %) (dec (:row loc)))\n                           (= (:column %) (:column loc))) indexed-state))]\n        (cond (= (:value new-loc) \"C\") true \n              (= (:value new-loc) \"#\") nil\n              0 new-loc)))\n     (south\n      [loc indexed-state]\n      (let\n        [new-loc (first (filter #(and (= (:row %) (inc (:row loc)))\n                           (= (:column %) (:column loc))) indexed-state))]\n        (cond (= (:value new-loc) \"C\") true \n              (= (:value new-loc) \"#\") nil\n              0 new-loc)))\n     (east\n      [loc indexed-state]\n      (let\n        [new-loc (first (filter #(and (= (:row %) (:row loc))\n                           (= (:column %) (dec (:column loc)))) indexed-state))]\n        (cond (= (:value new-loc) \"C\") true \n              (= (:value new-loc) \"#\") nil\n              0 new-loc)))\n     (west\n      [loc indexed-state]\n      (let\n        [new-loc (first (filter #(and (= (:row %) (:row loc))\n                           (= (:column %) (inc (:column loc)))) indexed-state))]\n        (cond (= (:value new-loc) \"C\") true \n              (= (:value new-loc) \"#\") nil\n              0 new-loc)))\n     (nav\n      [init indexed-board]\n      (let [board (remove #(= init %) indexed-board)\n            valid-moves (remove nil?\n                        [(north init board)\n                         (south init board)\n                         (east init board)\n                         (west init board)])]\n        (cond (some true? valid-moves) true\n              (empty? valid-moves) false\n              :else (map #(nav % board) valid-moves))))]\n    (let [indexed-board\n           (apply concat \n             (for [i (range (count state))]\n               (map-indexed #(hash-map :row i :column %1 :value (str %2)) (state i))))\n          init (first (filter #(= \"M\" (:value %)) indexed-board))\n          cheese  (first (filter #(= \"C\" (:value %)) indexed-board))\n          cheese-open (not \n                        (empty? \n                          (remove nil? [(north cheese indexed-board)\n                                        (south cheese indexed-board)\n                                        (east  cheese indexed-board)\n                                        (west  cheese indexed-board)])))]\n      (if cheese-open\n        (contains? (set (flatten (nav init indexed-board))) true)\n        false))))","problem":117,"user":"5273e006e4b03e8d9a4a7495"},{"code":"(fn forscience [maze]                                                                                \n   (let [W (count (first maze))                                                                      \n         H (count maze)]                                                                             \n     (letfn [(wall? [x] (= \\# x))                                                                    \n             (cheese? [x] (= \\C x))                                                                  \n             (start? [x] (= \\M x))                                                                   \n             (neighbors [maze [x y]]                                                                 \n               (let [coords (vector [(+ x 1) y] [(+ x -1) y] [x (+ y 1)] [x (+ y -1)])]              \n                 (filter #(let [val (get-in maze %)] (not (or (wall? val) (nil? val)))) coords)))    \n             (start-coord [maze] (for [i (range H) j (range W)                                       \n                                       :when (start? (get-in maze [i j]))] [i j]))                   \n             (search [maze space visited]                                                            \n               (let [coord (first space)                                                             \n                     val (get-in maze coord)                                                         \n                     visited (conj visited coord)                                                    \n                     nbs (filter #(not (visited %)) (neighbors maze coord))                          \n                     space (concat nbs (rest space))]                                                \n                 (cond                                                                               \n                  (cheese? val) true                                                                 \n                  (empty? space) false                                                               \n                  :else (search maze space visited))))]                                              \n       (search maze (start-coord maze) #{}))))","problem":117,"user":"4f1d1299535d64f603146487"},{"problem":117,"code":"(fn ms ([m]\n        (let [nodes (into {} (let [rows# (count m)\n                                   cols# (-> m first count)]\n                               (for [i (range rows#) j (range cols#)]\n                                 {[i j] (case (nth (nth m i) j)\n                                          \\# {:goal false :cost -1}\n                                          \\M {:goal true :cost 10000}\n                                          \\C {:goal false :cost 0}\n                                          \\space {:goal false :cost 10000})})))\n              pred (fn [[_ {c :cost}]]  (zero? c))]\n          (ms (filter pred nodes) (into {} (remove pred nodes)) )))\n   ([vs us] \n    (loop [v (first vs) us us]\n      (let [[[i j] {c :cost}] v\n            neighbors (select-keys us [[(inc i) j]\n                                       [(dec i) j]\n                                       [i (inc j)]\n                                       [i (dec j)]])\n            updated-us (reduce (fn [us [[i j] _]] (update-in us [[i j] :cost] #(min % (inc c)))) us neighbors)\n            [coord {g :goal c :cost} :as new-v] (->> updated-us\n                                                     (filter (fn [[_ {c :cost}]] (>= c 0)))\n                                                     (sort-by (fn [[_ {c :cost}]] c))\n                                                     first)]\n\n        (cond\n          (or (nil? new-v) (= 10000 c))\n          false\n\n          g\n          true\n\n          :else\n          (recur new-v (dissoc updated-us coord)))))\n   \n   ))","user":"608ec5e4e4b03bd49d9f36c0"},{"code":"(letfn\n\n  [(index-of [pred coll]\n     (count (take-while (complement pred) coll)))\n\n   (get-grid [maze-template]\n     (mapv (partial mapv identity) maze-template))\n\n   (get-mouse-cell [grid]\n     (let [row-idx (index-of (partial some #{\\M}) grid)\n           column-idx (index-of #{\\M} (nth grid row-idx))]\n       [row-idx column-idx]))\n\n   (neighbors [cell]\n     (map #(map + % cell)\n          [[0 1] [1 0] [0 -1] [-1 0]]))\n\n   (free-neighbors [grid cell]\n     (filter #(#{\\space} (get-in grid %))\n             (neighbors cell)))\n\n   (cheese-adjacent? [grid cell]\n     (some #(#{\\C} (get-in grid %))\n           (neighbors cell)))\n\n   (clear-path? [grid mouse-cell]\n     (loop [flooded-cells [mouse-cell]]\n       (if (some (partial cheese-adjacent? grid) flooded-cells)\n         true\n         (let [flooded-grid (reduce #(assoc-in %1 %2 \\#) grid flooded-cells)\n               free-cells (set (mapcat (partial free-neighbors flooded-grid) flooded-cells))]\n           (if (empty? free-cells)\n             false\n             (recur (concat flooded-cells free-cells)))))))]\n\n  (fn [maze-template]\n    (let [grid (get-grid maze-template)\n          cell (get-mouse-cell grid)]\n      (clear-path? grid cell))))","problem":117,"user":"51789dfae4b03d69594194d7"},{"code":"(fn [board]\n  (let [vec-board (vec (map vec board))\n        row-count (count vec-board)\n        column-count (count (first vec-board))]\n    (letfn [(get-pos [ch]\n              (mapcat #(mapcat (fn [j] (if (= ch ((vec-board %) j)) [% j])) (range 0 column-count)) (range 0 row-count)))\n            (continous-blank [ch coordinate searched-point])\n            (step [[results searched-point] [x y]]\n              (let [neighbours (concat\n                                 (if (pos? x) [[(dec x) y]])\n                                 (if (pos? y) [[x (dec y)]])\n                                 (if (> (- row-count x) 1) [[(inc x) y]])\n                                 (if (> (- column-count y) 1) [[x (inc y)]]))\n                    valid-neighbours (filter\n                                       #(and\n                                          (not= ((vec-board (first %)) (last %)) \\#)\n                                          (nil? (some #{%} searched-point)))\n                                       neighbours)]\n                (if (seq valid-neighbours)\n                  (if (some #(= ((vec-board (first %)) (last %)) \\C) valid-neighbours)\n                    [(cons true results) (conj searched-point [x y])]\n                    (reduce #(step %1 %2) [results (conj searched-point [x y])] valid-neighbours))\n                  [results (conj searched-point [x y])])))]\n      (let [mouse (get-pos \\M)]\n        ((complement empty?) (first (step [[] #{(vec mouse)}] mouse)))))))","problem":117,"user":"514d7e29e4b019235f6c0587"},{"problem":117,"code":"(fn reachable? [_maze]\n   (let [maze (vec (map vec _maze))\n         MAXI (count maze)\n         MAXJ (count (first maze))\n\n         start (fn []\n                 (filter (complement nil?)\n                         (for [i (range MAXI)\n                               j (range MAXJ)]\n                           (if (= \\M ((maze i) j)) [i j] nil))))\n\n         nexts (fn [[ci cj]]\n                 (set (for [[ni nj] [[(dec ci) cj]\n                                     [(inc ci) cj]\n                                     [ci (dec cj)]\n                                     [ci (inc cj)]]\n                            :when (and (<= 0 ni) (> MAXI ni)\n                                       (<= 0 nj) (> MAXJ nj)\n                                       (not (= \\# ((maze ni) nj)))\n                                       )]\n                        [ni nj]\n                        )))\n         ]\n     (letfn [(solv [nextpathes reached]\n                   (println \"[solv] nextpath:\" nextpathes \"reached:\" reached)\n                   (loop [current nextpathes\n                          ret reached]\n                     (println \"[loop] current:\" current \"ret:\" ret)\n                     (if (empty? current)\n                       ret\n                       (let [_ns (nexts (first current))\n                             ns (clojure.set/difference _ns ret)]\n                         (println \"let-ns:\" _ns)\n                         (if (not-empty ns)\n                           (recur (rest current) (solv ns (clojure.set/union ret ns)))\n                           (recur (rest current) ret)\n                           )))))\n             (reached? [coll]\n                       ((complement nil?) (some #(= \\C (let [[i j] %] ((maze i) j))) coll)))]\n\n       (reached? (solv (start) #{}))\n       )))","user":"55a372f1e4b0acc240e31537"},{"problem":117,"code":"(fn [m]\n  (if (or (some #(re-find #\"MC|CM\" %) m)\n \t\t  (some #(re-find #\"MC|CM\" %) (apply map str m)))\n    true\n    (let [mm (map (fn [s] (clojure.string/replace s #\" ?M ?\" #(.replace % \" \" \"M\"))) m)\n          mm (map (fn [s] (clojure.string/replace s #\" ?C ?\" #(.replace % \" \" \"C\"))) mm)\n          mm (apply map str mm)\n          mm (map (fn [s] (clojure.string/replace s #\" ?M ?\" #(.replace % \" \" \"M\"))) mm)\n          mm (map (fn [s] (clojure.string/replace s #\" ?C ?\" #(.replace % \" \" \"C\"))) mm)\n          mm (apply map str mm)]\n      (if (= mm m)\n        false\n        (recur mm)))))","user":"50ed4626e4b01236b1d4983c"},{"problem":117,"code":"(fn mouse-fill [board]\r\n  (let [find-non-nil  (partial some identity)\r\n        height        (count board),\r\n        width         (count (first board))\r\n        cheese-eaten? (not (find-non-nil\r\n                            (map (fn [line] (re-find #\"C\" line))\r\n                                 board)))]\r\n    (letfn [(look-around [[row col]]\r\n              (remove (fn [[row col]]\r\n                        (or (< row 0) (< col 0)\r\n                            (>= row height) (>= col width)))\r\n                      #{[(dec row) col],\r\n                        [(inc row) col],\r\n                        [row (inc col)],\r\n                        [row (dec col)],}))\r\n            (look-at [[row col]]\r\n              (nth (nth board row) col))\r\n            (see-mouse? [pos]\r\n              (some (partial = \\M) \r\n                    (map look-at (look-around pos))))\r\n            (fill-step []\r\n              (vec (map-indexed\r\n                    (fn [i row]                        \r\n                      (apply str\r\n                             (map-indexed\r\n                              (fn [j x]\r\n                                (if (and (#{\\C \\space} x)\r\n                                         (see-mouse? [i j]))\r\n                                  \\M x))\r\n                              row)))\r\n                    board)))]\r\n      (or cheese-eaten?\r\n          (let [new-board (fill-step)]\r\n            (if (= new-board board) false\r\n                (recur new-board)))))))","user":"55d0e76ae4b0e31453f64a40"},{"code":"(fn [m]\n (let [dirs [:down :left :up :right]\n       use-dirs {:down [:down :left :right] :up [:up :right :left] :left [:left :up :down] :right [:right :down :up]}\n\n       map-mapval (fn [f m] (into {} (map (fn [x] (vector (key x) (f (key x) (val x)))) m)))       \n       wall? (fn [b [r c]]  (= \\# (get-in b [r c])))\n       at-bound? (fn [b [r c]]\n                  (if (or (nil? r) (nil? c))\n                   false\n                   (or  (zero? r) (zero? c) (= r (dec (count b))) (= c (dec (count (b r)))))))\n       wall-end? (fn [x] (nil? (last (second x))))\n\n       left? (fn [[r1 c1] [r2 c2]](< c1 c2))\n       right? (fn [[r1 c1] [r2 c2]](> c1 c2))\n       above? (fn [[r1 c1] [r2 c2]] (< r1 r2))\n       below? (fn [[r1 c1] [r2 c2]] (> r1 r2))\n\n       horizontal? (fn [b s] (let [[r1 c1] (first s) [r2 c2] (last s)]\n                    (and (zero? c1) (= (inc c2) (count (b r2))))))\n       \n       vertical? (fn [b s] (let [[r1 c1] (first s) [r2 c2] (last s)]\n                  (and (zero? r1) (= (inc r2) (count b)))))\n\n       inside? (fn [[r c] w]\n                (and (< r (apply max (map first w))) (< c (apply max (map second w)))))\n\n       outside? (fn [[r c] w]\n                 (and (> r (apply min (map first w))) (> c (apply min (map second w)))))\n\n       end-top? (fn [_ w] (or (-> (first w) first zero?) (-> (last w) first zero?)))\n\n       end-bottom? (fn [m w] (let [r-max (dec (count m))]\n                    (or (= r-max (ffirst w)) (= r-max (first (last w))))))\n\n       end-left? (fn [_ w] (or (-> (first w) second zero?) (-> (last w) second zero?)))\n\n       end-right? (fn [m w]\n                   (or\n                    (= (dec (count (m (ffirst w)))) (second (first w)))\n                    (= (dec (count (m (first (last w))))) (second (last w)))))\n\n       inside-right? (fn [[r c] s]\n                      (let [gc (or (second (first (filter #(= r (first %)) s))) false)] (and gc (> c gc))))\n\n       inside-top? (fn [[r c] s]\n                    (let [gr (or (ffirst (filter #(= c (second %)) s)) false)] (and gr (< r gr))))\n\n       inside-left? (fn [[r c] s] (let [gc (or (second (first (filter #(= r (first %)) s))) false)] (and gc (< c gc))))\n\n       inside-bottom? (fn [[r c] s] (let [gr (or (ffirst (filter #(= c (second %)) s)) false)] (and gr (> r gr))))\n\n       find-mc (fn [b]\n                (for [r (range (count b)) c (range (count (b r))) :let [x (get (b r) c)] :when (or (= x \\M) (= x \\C))] [r c]))\n\n       neighbors (fn [b dir [r c]]\n                  (let [n-s {:up [[(dec r) c] [(dec r) (inc c)] [(dec r) (dec c)]]\n                             :down [[(inc r) c] [(inc r) (inc c)] [(inc r) (dec c)]]\n                             :right [[r (inc c)] [(dec r) (inc c)] [(inc r) (inc c)]]\n                             :left [[r (dec c)] [(dec r) (dec c)] [(inc r) (dec c)]]}]\n                   (if (at-bound? b [r c])\n                    {dir (let [w (first (dir n-s))] (if (wall? b w) w))}  \n                    (->>\n                     (select-keys n-s (dir use-dirs))\n                     (map-mapval (fn [k x]  (if (= k dir) x (vector (first x)))))\n                     (map-mapval (fn [_ x]  (filter (partial wall? b) x )))\n                     (filter (fn [x] (seq (val x) )))\n                     (into {})\n                     (map-mapval (fn [_ x] (first x)))))))\n\n       separates? (fn [b s x y]\n         (cond\n          (vertical? b s)\n           (and (some #(left? x %) s) (some #(right? y %) s))\n          (horizontal? b s)\n           (and (some #(above? x %) s) (some #(below? y %) s))\n          (and (end-top? b s)(end-left? b s))\n           (let [x-in (and (inside-left? x s) (inside-top? x s))\n                 y-in (and  (inside-left? y s) (inside-top? y s))]\n            (not= x-in y-in))\n          (and (end-top? b s)(end-right? b s))\n           (let [x-in (and (inside-right? x s) (inside-top? x s))\n                 y-in (and (inside-right? y s) (inside-top? y s))]\n            (not= x-in y-in))\n          (and (end-bottom? b s)(end-left? b s))\n           (let [x-in (and (inside-left? x s) (inside-bottom? x s))\n                 y-in (and (inside-left? y s) (inside-bottom? y s))]\n            (not= x-in y-in))\n          (and (end-bottom? b s)(end-right? b s))\n           (let [x-in (and (inside-right? x s) (inside-bottom? x s))\n                 y-in (and (inside-right? y s) (inside-bottom? y s))]\n            (not= x-in y-in)) \n          :else nil))\n\n       follow-wall (fn [b s]\n                    (let [fw (fn [b dir wall]\n                              (map\n                               (fn [x] (list (key x) (conj wall (val x))))\n                               (neighbors b dir (last wall))))\n                          s (remove (fn [x] (nil? (last (second x)))) s)]\n                        (reduce (fn [acc x] (into acc (fw b (first x) (second x)))) '() s)))\n\n       get-wall (fn [dir m start]\n          (->>\n           (take-while seq (iterate (partial follow-wall m) [[dir [start]]]))\n           (map (fn [x] (filter wall-end? x)))\n           (reduce (fn [acc x](concat acc x)))\n           (map (fn [x] (butlast (second x))))))\n\n       get-walls (fn [dir m]\n          (case dir\n            :down (for [c (range (dec (count (m 0)))) :when (wall? m [0 c])]\n                   (fn [] (get-wall :down m [0 c])))\n            :up (let [r-max (dec (count m))]\n                 (for [c (range (dec (count (m r-max)))) :when (wall? m [r-max c])]\n                  (fn [] (get-wall :up m [r-max c]))))\n            :left (for [r (range (dec (count m))) :when (wall? m [r (dec (count (m r)))])]\n                   (fn [] (get-wall :left  m [r (dec (count (m r)))])))\n            :right (for [r (range (dec (count m))) :when (wall? m [r 0])]\n                    (fn [] (get-wall :right  m [r 0])))))\n\n       [g1 g2] (find-mc m)]\n (let  [f1 (fn [w] (some #(separates? m % g1 g2) (w)))\n        f (fn [ws] (some f1 ws))]\n  (if (some f (map (fn [d] (get-walls d m)) [:down :left])) false true))))","problem":117,"user":"50783762e4b0fc74642bff67"},{"code":"(fn [maze]\n    (let [\n          rows (count maze)\n          cols (count (first maze))\n          locate (zipmap (apply concat maze) (for [row (range rows) col (range cols)] [row col]))\n          mouse (locate \\M)\n          cheese (locate \\C)\n          vec-add #(vec (map + %1 %2))\n          neighbours-vectors #{[-1 0] [1 0] [0 -1] [0 1]}\n          in-range? (fn [[row col]] (and (< -1 col cols)  (< -1 row rows)))\n          wall? (fn [position] (#{\\#} (get-in maze position)))\n          neighbours (fn [current]\n                       (->> neighbours-vectors\n                            (map #(vec-add current %))\n                            (filter in-range?)\n                            (remove wall? )\n                            (filter  in-range? )))]\n            (loop [openset #{mouse} closedset #{}]\n              (let [\n                    current-position (first (clojure.set/difference openset closedset))]\n                (cond\n                 (nil? current-position) false\n                 (= current-position cheese) true\n                 :else\n                 (let [neighbours (set (neighbours current-position))]\n                   (recur\n                    (clojure.set/union openset neighbours)\n                    (conj closedset current-position ))))))))","problem":117,"user":"4e6f578c535d5021c1a8961b"},{"problem":117,"code":"(fn [board]\n  (let [visited-states (atom #{})\n        strategies [[1 0] [-1 0] [0 1] [0 -1]]\n        next-strategies (constantly strategies)\n        state-cons (fn [s states]\n                     (when states (cons s states)))\n        visited? (fn [state]\n                   (get @visited-states state))\n        succeed? #(= \\C (get-in board %))\n        dead? #(contains? #{\\# nil} (get-in board %))\n        apply-strategy (fn [state s]\n                         (swap! visited-states conj state)\n                         (mapv + state s))\n        strategies-tree (fn strategies-tree [state strategies]\n                         (cond\n                           (succeed? state) [state]\n                           (visited? state) nil\n                           (dead? state) nil\n                           :else\n                             (some\n                              identity\n                              (map #(state-cons state %)\n                                   (map #(strategies-tree (apply-strategy state %)\n                                                          (next-strategies state strategies))\n                                        strategies)))))]\n    (boolean\n     (strategies-tree (some #(when (= (get-in board %) \\M) %) (for [i (range (count board))\n                                                                    j (range (count (first board)))]\n                                                                [i j]))\n                      strategies))))","user":"5393185ae4b0b51d73faaeb7"},{"problem":117,"code":"(fn science\n  ([board]\n   (letfn [(find-mouse [board]\n             (flatten (for [i (range 0 (count board)) j (range 0 (count (first board)))\n                            :when (= \\M (get-in board [i j]))]\n                        [i j])))]\n     (let [[x y] (find-mouse board)]\n       (science (vec (map #(-> % char-array vec) board)) x y))))\n  ([b start-x start-y]\n   (let [dirs [[0 1] [1 0] [-1 0] [0 -1]]]\n     (loop [q [[start-x start-y]] board b]\n       (if (empty? q) false\n           (let [[x y] (first q)]\n             (cond (or (< x 0) (< y 0) (>= x (count board)) (>= y (count (first board))))\n                   (recur (rest q) board)\n                   (= (get-in board [x y]) \\C)\n                   true\n                   (= (get-in board [x y]) \\#)\n                   (recur (rest q) board)\n                   :else\n                   (recur\n                    (concat (rest q) (map (fn [[i j]] [(+ i x) (+ j y)]) dirs))\n                    (assoc-in board [x y] \\#))))\n           ))))\n  )","user":"54f09599e4b024c67c0cf89d"},{"code":"(fn [in]\n(let [\n  nr (count in)\n  nc (count (nth in 0))\n\n  ok \n     (fn [[r c]]\n        (and (< -1 r nr) (< -1 c nc)))\n  is-cheese? \n     (fn [rc]\n       (= \\C (get-in in rc)))\n  is-empty? \n     (fn [bd rc]\n        (= \\space (get-in bd rc)))\n  neighbors \n    (fn [[r c]]\n        (filter\n           ok\n           (map\n             (fn [[dr dc]] [(+ dr r)(+ dc c)])\n             [[1 0][0 1][-1 0][0 -1]])))\n   find-in-board \n     (fn [board ch]\n        (set (for [r (range nr) c (range nc) \n                  :when (= ch (get-in board [r c]))]\n                 [r c])))\n   next-board \n     (fn [bd e]\n        (vec (for [r (range nr)]\n           (apply str (for [c (range nc)]\n                            (if (contains? (set e) [r c])\n                             \\M\n                             (get-in bd [r c])))))))\n   find-path\n      (fn find-path [bd]\n         (if-let [is (find-in-board bd \\M)]\n                (let [ns (mapcat neighbors is)\n                      es (filter (partial is-empty? bd) ns)]\n                  (cond\n                    (some is-cheese? ns) true\n                    (seq es) (find-path (next-board bd es))))))]\n  (true? (find-path in))))","problem":117,"user":"4daa374930acd6ed13482a68"},{"problem":117,"code":"(fn [v]\n  (loop [i 1 v v]\n    (let [r (map (fn [x] (reductions #(cond (and (= % \\M) (= %2 \\space)) \\M\n                                            (and (= % \\M) (= %2 \\C)) true\n                                            :else %2) x))\n                 v)]\n      (cond (some #(some true? %) r) true\n            (= i 80) false\n            :else (recur (inc i) (apply map (fn [& a] a) (reverse r)))))))","user":"515bbcd9e4b0388ca8ca1521"},{"problem":117,"code":"(fn go-out-maze [board]\n   (letfn [(mouse-step\n             [board]\n             (let [nrow (count board)\n                   ncol (count (first board))\n                   gen-cell-at-next-step (fn [board pos]\n                                           (let [current-cell (get-in board pos)\n                                                 get-neighbours (fn nbs [board [x y]]\n                                                                  (map #(get-in board %) [[(inc x) y] [x (inc y)] [(dec x) y] [x (dec y)]]))\n                                                 has-mouse-neighbours (boolean (some #{\\M} (get-neighbours board pos)))]\n                                             (pr board)\n                                             (cond\n                                               (and (or (= current-cell \\C) (= current-cell \\space)) has-mouse-neighbours) \\M\n                                               :else current-cell)\n                                             ))\n                   next-state (let [-charlist (for [x (range nrow)\n                                                    y (range ncol)\n                                                    :let [pos [x y]]]\n                                                (gen-cell-at-next-step board pos))]\n                                (map #(apply str %) (partition ncol -charlist)))]\n               (vec next-state)))\n           (cheese-eaten? [board]\n                          (nil? (some #{\\C} (flatten (map seq board)))))]\n     (let [next-board (mouse-step board)]\n       (cond\n         (cheese-eaten? next-board) true\n         (= board next-board) false\n         :else (go-out-maze next-board)))\n     ))","user":"56fbf83de4b07572ad1a88da"},{"code":"(fn my-for-science!\n  [maze]\n  (let [width (count (first maze))\n        height (count maze)\n        maze-map (zipmap (range) (apply str maze))\n        mouse-index (first (filter (complement nil?) (map #(when (= (val %) \\M) (key %)) maze-map)))]\n    (letfn [(get-neighbours-ids [id]\n                                (let [l (- id width)\n                                      u (+ id width)]\n                                  (vector l (dec id) (inc id) u)))\n            (get-correct-neighbours-ids [id visited-ids] \n                                        (filter (complement nil?) (map #(cond\n                                                                          (< % 0) nil \n                                                                          (> % (dec (* width height))) nil\n                                                                          (= \\# (maze-map %)) nil\n                                                                          (contains? visited-ids %) nil\n                                                                          :else %) (get-neighbours-ids id))))\n            (get-neighbours [id visited-ids] \n                            (map maze-map (get-correct-neighbours-ids id visited-ids)))\n            (cheese-founded? [visited-ids indexes] (some #(= % \\C) (mapcat #(get-neighbours % visited-ids) indexes)))\n            (get-next-ids [visited-ids indexes] (mapcat #(get-correct-neighbours-ids % visited-ids) indexes))]\n      (loop [visited-ids #{} indexes (vector mouse-index) i 0]\n        (cond \n          (cheese-founded? visited-ids indexes) true\n          (empty? (get-next-ids visited-ids indexes)) false\n          :else (recur (into visited-ids indexes) (get-next-ids visited-ids indexes) (inc i)))))))","problem":117,"user":"509a25b7e4b0efbae1fbc0a8"},{"problem":117,"code":"(fn f [grid]\n  (let [\n   analyzer (fn [re state subst] #(if (re-find re %) [state (clojure.string/replace % re subst)] nil))\n   win-left (analyzer #\"CM\" :win \"CM\")\n   win-right (analyzer #\"MC\" :win \"MC\")\n   fill-left (analyzer #\" M\" :fill \"MM\")\n   fill-right (analyzer #\"M \" :fill \"MM\")\n   nop (fn [x] [:stuck x])\n   analyzers (fn [tgt] (some #(% tgt) [win-left win-right fill-left fill-right nop]))\n   analyze-rows (map analyzers grid)\n   transpose (fn [x] (map #(apply str %) (apply map list x)))\n   cols (transpose (map second analyze-rows))\n   analyze-cols (map analyzers cols)\n   new-grid (transpose (map second analyze-cols))\n   result (set (concat (map first analyze-rows) (map first analyze-cols)))]\n   (println \"-----------\")\n   (println grid)\n   (println analyze-rows)\n   (println cols)\n   (println analyze-cols)\n   (println result)\n  (cond\n   (contains? result :win) true\n   (contains? result :fill) (f new-grid)\n   :else false)))","user":"55a74d46e4b09e57187da2a3"},{"problem":117,"code":"(fn can-escape?[maze]\n  (letfn [\n    (find-el[el maze]\n      (let [sx (count maze) sy (count (first maze))]\n        (second (first (drop-while #(not= (first %) el)\n        (for [x (range sx) y (range sy)] [(get-in maze [x y]) [x y]])\n        ))))\n    )\n    (find-new-moves [maze current oldmoves]\n      (let [sx (count maze) sy (count (first maze))\n            deltas [[0 1] [0 -1] [1 0] [-1 0]]]\n        (set (for [[x y] (map #(map + current %) deltas) :when\n          (and (>= x 0) (< x sx) (>= y 0) (< y sy)\n               (not (some #{[x y]} oldmoves))\n               (or (= (get-in maze [x y]) \\space) (= (get-in maze [x y]) \\C)))] [x y]))\n      )\n    )\n  ]\n    (let [cheese-pos (find-el \\C maze)]\n      (loop [new-moves #{(find-el \\M maze)} old-moves #{(find-el \\M maze)}]\n        (let [moves (set (apply concat #{} (filter (comp not empty?) (map #(find-new-moves maze % old-moves) new-moves))))]\n          (cond\n            (empty? moves) false\n            (some #{cheese-pos} moves) true\n            :else (recur moves (into old-moves moves))\n          )\n      )) \n    )\n  )\n)","user":"59a0262ee4b0871e7608b82d"},{"problem":117,"code":"(fn [table]\n  (let [height (count table) length (count (first table))\n        {start \\M end \\C} (into {} (for [y (range height) x (range length) :when (#{\\M \\C} (get-in table [y x]))] {(get-in table [y x]) [y x]}))\n        around (fn [[x y]] [[x (inc y)] [x (dec y)] [(inc x)y] [(dec x)y]])]\n    (loop [done #{} todo #{start}]\n      (cond (done end) true\n            (empty? todo) false\n            :else (let [doing (first todo)\n                        left (disj todo doing)\n                        cand (set(filter #(and (not (done %)) (#{\\C \\space}(get-in table %))) (around doing)))]\n                    (recur (conj done doing) (clojure.set/union left cand)))))))","user":"5951190be4b066ee0a44aea4"},{"problem":117,"code":"(fn [m]\n  (let [[x y]\n        (->> m\n          (keep-indexed (fn [i r] (->> (keep-indexed #(if (= \\M %2) [i %]) r) seq)))\n          first first\n          (map inc))\n        w (-> (m 0) count (+ 2) (repeat \\#) vec)\n        m\n        (concat\n          [w]\n          (for [r m] (->> (concat \"#\" r \"#\") (mapv #(case % \\space \\. %))))\n          [w])\n        m (vec m)]\n    (->> [m (conj clojure.lang.PersistentQueue/EMPTY [x y])]\n      (iterate\n        (fn [[m q]]\n          (let [[x y :as p] (peek q)\n                q'          (pop q)]\n            (cond\n              (empty? q)        false\n              (= ((m x) y) \\C)  true\n              true\n              [(update-in m p (constantly \\M))\n               (->> [[(inc x) y]\n                     [(dec x) y]\n                     [x (inc y)]\n                     [x (dec y)]]\n                 (filter (fn [[x y]] (case ((m x) y) (\\. \\C) true false)))\n                 (into q'))]))))\n      (remove vector?)\n      first)))","user":"50479524e4b0371827a27bc4"},{"problem":117,"code":"(fn maze [s]\n  (if (not-any? #((set %) \\C) s)\n    true\n    (let [n \n          (for [i (range (count s))]\n            (apply str (for [j (range (count (first s)))]\n                         (if (= \\# (nth (nth s i) j))\n                           \\#\n                           (if (some #{\\M} \n                                     (for [k (range (max 0 (dec i)) (min (+ i 2) (count s)))\n                                           l (range (max 0 (dec j)) (min (+ j 2) (count (first s))))\n                                           :when (or (= k i) (= l j))]\n                                       (nth (nth s k) l)))\n                             \\M\n                             (nth (nth s i) j))))))]\n      (if (= n s)\n        false\n        (maze n)))))","user":"55625903e4b0c656e3ff17d7"},{"code":"(fn [maze]\n    ;; Assumes maze is simply connected. Flood-fills the maze starting at\n    ;; the mouse position. If we hit the cheese, then the mouse can get\n    ;; there, too.\n    (let [width (count (nth maze 0))\n          height (count maze)\n          cheese-found (ref false)]\n      (letfn [(in-bounds? [row col] (and (>= row 0) (>= col 0) (< row height) (< col width)))\n              (cell [row col]           ; return wall if out of bounds\n                (if (in-bounds? row col)\n                  (get-in maze [row col] \\#)))\n              (find-in-maze [ch] ; return coords of first cell found containing ch\n                (first\n                 (for [r (range height), c (range width) :when (= ch (cell r c))]\n                   [r c])))\n              (flood-fill [row col]     ; look for cheese while flooding\n                (let [visited (ref #{})]\n                  (letfn [(do-flood-fill [row col]\n                            (if (and (not @cheese-found)\n                                     (in-bounds? row col)\n                                     (nil? (some #{[row col]} @visited)))\n                              (let [ch (cell row col)]\n                                (cond (= ch \\C) (dosync (ref-set cheese-found true)) ; cheese found\n                                      (or (= ch \\space) (= ch \\M)) (do\n                                                                     (dosync (alter visited conj [row col]))\n                                                                     (do-flood-fill (dec row) col)\n                                                                     (do-flood-fill (inc row) col)\n                                                                     (do-flood-fill row (dec col))\n                                                                     (do-flood-fill row (inc col)))))))]\n                    (do-flood-fill row col))))]\n                    \n        ;; Here we go\n        (let [mouse-pos (find-in-maze \\M)]\n          (flood-fill (first mouse-pos) (second mouse-pos))\n          @cheese-found))))","problem":117,"user":"4e89e939535d3e98b8023287"},{"problem":117,"code":"(fn cheeze [raw-board]\n  (let [board (map seq raw-board)\n        neighbors (fn [[x y]] (for [[dx dy] '((0 1) (0 -1) (1 0) (-1 0))\n                                  :let [nx (+ x dx) ny (+ y dy)]\n                                  :when (and\n                                             (< -1 nx (count (first board)))\n                                             (< -1 ny (count board)))]\n                                (list nx ny)))\n        char-at (fn [[x y]] (nth (nth board y) x))\n        steps (fn [[x y] seen]\n                (filter #(and ((complement seen) %) (#{\\ \\C} (char-at %))) (neighbors (list x y))))\n\n        children (fn [[[x y] seen]]\n                   (let [s (into seen (steps [x y] seen) )]\n                        (map #(list % s) (steps [x y] seen))))\n\n        branch? (fn [[[x y] seen]]\n                  ((complement empty?) (children [[x y] seen])))\n        find-char (fn [c]\n                    (first (filter #(>= (first %) 0)\n                            (map-indexed (fn [idx row] (vector (.indexOf row c) idx)) raw-board ))))\n        M (find-char \"M\")\n        C (find-char \"C\")\n\n        ]\n    (boolean ((into #{} (map first (tree-seq branch? children [M #{}]))) C))\n))","user":"55934bebe4b0c79f6e1db93b"},{"problem":117,"code":"(fn [board]\n  (letfn [(part [x] (map (partial partition-by #(= \\# %)) x))\n          (transp [x] (apply map list x))\n          (flat [x] (map (partial apply concat) x))\n          (fill [r] (if (some #{\\M} r) (repeat (count r) \\M) r))\n          (h-step [x] (flat (map #(map fill %) (part x))))\n          (v-step [x] (transp (h-step (transp x))))\n          (win? [x] (not-any? #(some #{\\C} %) x))]\n    (let [nx (v-step (h-step board))]\n      (cond (win? nx) true\n            (= board nx) false\n            :else (recur nx)))))","user":"52b02329e4b0c58976d9acc5"},{"problem":117,"code":";; This working solution times out: \n; (fn can-navigate? [maze]\n;   (let [offsets [[-1 -1] [ 0 -1] [ 1 -1]\n;                  [-1  0]         [ 1  0]\n;                  [-1  1] [ 0  1] [ 1  1]]\n;         start (mapcat\n;                 (fn [[i row]]\n;                   (let [[j el] (first (filter (fn [[j el]] (= \\M el)) (map-indexed vector row)))]\n;                     (if el [i j])))\n;                 (map-indexed vector maze))]\n;     (letfn [(reaches-cheese? [[i j] visited]\n;                              (println [i j] visited)\n;                              (if (= \\C (-> maze (get i) (get j))) true\n;                                (or (->> offsets\n;                                         (map (fn [[di dj]] [(+ i di) (+ j dj)]))\n;                                         (remove visited)\n;                                         (filter (fn [[ni nj]] (#{\\space \\C} (-> maze (get ni) (get nj)))))\n;                                         (map (fn [[ni nj]] (reaches-cheese? [ni nj] (conj visited [i j]))))\n;                                         (some true?)\n;                                         ) false)\n;                                )\n;                              )]\n;       (reaches-cheese? start #{}))))\n\n\n(fn [maze]\n  (let [transpose (fn [coll] (apply mapcat (comp list str) coll))\n        reachable? (fn [s] (re-find #\"(C@|@C)\" s))\n        walk (fn [s]\n               (reduce (fn [s [x y]] (str (subs s 0 x) (apply str (repeat (- y x) \\@)) (subs s y (count s)))) s\n                       (let [matcher (re-matcher #\"[ ]*[M@]+[ ]*\" s)]\n                         (loop [r [] match (re-find matcher)]\n                           (if match\n                             (recur (conj r [(.start matcher) (.end matcher)]) (re-find matcher))\n                             r)))))\n        search (fn [m]\n                 (let [n (->> (map walk m) transpose (map walk) transpose)]\n                   (if (= m n)\n                     m\n                     (recur n))))\n        m (search maze)]\n    (boolean (or (some reachable? m) (some reachable? (transpose m))))))","user":"549dfe40e4b0f3d1d8e70f9a"},{"code":"(fn for-science [m]\n  (let [h (count m)\n        w (count (first m))\n        dx [0 0 1 -1]\n        dy [1 -1 0 0]\n        pos (fn [x y] (get (get m y \"\") x \\#))\n        cheese-pos (first\n                    (for [x (range w) y (range h) :when (= (pos x y) \\C)]\n                      [x y]))\n        mouse-pos (first\n                   (for [x (range w) y (range h) :when (= (pos x y) \\M)]\n                     [x y]))\n        generate (fn [v p]\n                   (filter\n                    #(and (not (contains? v %1)) (not= \\# (apply pos %1)))\n                    (map #(vector (+ (p 0) %1) (+ (p 1) %2)) dx dy)))\n        win? (fn [p] (= p cheese-pos))]\n    (loop [visited (hash-set) queue (vector mouse-pos)]\n      (cond\n       (empty? queue) false\n       (win? (first queue)) true\n       :else\n       (recur (conj visited (first queue))\n              (concat (rest queue) (generate visited (first queue))))))))","problem":117,"user":"4f0e995e535d0136e6c22326"},{"code":"(fn [x]\n    (loop [m x\n           l nil]\n      (let [h (fn [d] (apply map (fn [& a] (apply str a)) d))\n            v (h m)\n            f (fn [b]\n                (->>\n                  (reduce #(into % (partition 2 1 %2)) #{} b)\n                  (some #(or (= % [\\M \\C]) (= % [\\C \\M])))\n                  true?))\n            g (fn [c]\n                (map\n                  #(reduce\n                     (fn [a i]\n                       (let [o (last a)]\n                         (cond\n                           (and (= o \\M) (= i \\space)) (str a \\M)\n                           (and (= o \\space) (= i \\M)) (str (apply str (drop-last a)) \\M \\M)\n                           1 (str a i)))) \"\" %)\n                  c))]\n        (cond\n          (= m l) false\n          (f m) true\n          (f v) true\n          1 (recur (h (g (h (g m)))) m)))))","problem":117,"user":"51b3f109e4b0f094dd986fa9"},{"code":"(fn [A C R O N M]\n  (loop [s (set\n            (A C\n               (#(for [i (R (O %))\n                       j (R (O (N % 0)))\n                       :let [x (N (N % i) j)\n                             y (N (N % (- i 1) []) j nil)\n                             z (N (N % i) (- j 1) nil)]\n                       :when x]\n                   [(when y [x y])\n                    (when y [y x])\n                    (when z [x z])\n                    (when z [z x])])\n                (partition (O (N M 0))\n                           (for [[a i] (map list (A C M) (R))]\n                             (or (#{\\C \\M} a)\n                                 (and (= \\  a) i)))))))\n         c 0]\n    (if (= (O s) c)\n      (boolean (s [\\M \\C]))\n      (recur (into s (for [[a b] s [c d] s\n                           :when (= b c)]\n                       [a d]))\n             (O s)))))\napply concat range count nth","problem":117,"user":"4e5fe31a535d8ccf87e9fe50"},{"problem":117,"code":"(fn [maze]\n  (letfn [(lookup [[x y]] (and (>= x 0)\n                               (>= y 0)\n                               (< x (count (first maze)))\n                               (< y (count maze))\n                               (nth (nth maze y) x)))]\n    (let [graph (into {} (mapcat (fn [y]\n                                   (map (fn [x]\n                                          [[x y] (filter #(#{\\M \\C \\space} (lookup %)) [[x (dec y)]\n                                                                                        [(dec x) y]\n                                                                                        [(inc x) y]\n                                                                                        [x (inc y)]])])\n                                        (range (count (nth maze y)))))\n                                 (range (count maze))))\n          mouse (first (filter #(= (lookup %) \\M) (keys graph)))\n          cheese (first (filter #(= (lookup %) \\C) (keys graph)))]\n      (boolean (((fn traverse [visited]\n                   (let [newly-visited (clojure.set/union visited (set (mapcat #(graph %) visited)))]\n                     (if (= newly-visited visited)\n                       visited\n                       (traverse newly-visited))))\n                 #{mouse})\n                cheese)))))","user":"53acaf1fe4b047364c04445f"},{"problem":117,"code":"(fn [maze]\n    (let [rows (count maze)\n          cols (count (first maze))\n          mouse (->> maze\n                     (map-indexed #(vector %1 (.indexOf %2 \"M\")))\n                     (filter #(>= (second %) 0))\n                     (first))]\n      (letfn [(ff [[r c] seen]\n                (or (= (nth (nth maze r) c) \\C)\n                    (->> [[(inc r) c] [(dec r) c] [r (dec c)] [r (inc c)]]\n                         (filter #(let [[r c] %]\n                                    (and (<= 0 r (dec rows))\n                                         (<= 0 c (dec cols))\n                                         (not (seen %))\n                                         (not= (nth (nth maze r) c) \\#))))\n                         (map #(ff % (conj seen %)))\n                         (some true?)\n                         (true?))))]\n        (ff mouse #{mouse}))))","user":"5c995fa4e4b048ec896c5a96"},{"problem":117,"code":"(fn f\n  ([maze]\n   (f maze\n                #{}\n                [(flatten\n                  (keep-indexed\n                   (fn [i l]\n                     (keep-indexed #(if (= %2 \\M) [i %1]) l))\n                   maze))]))\n  ([maze visited [el & r]]\n   (cond (nil? el) false\n         (= (get-in maze el) \\C) true\n         :else\n         (let [[i j] el\n               unwalkable\n               #(or (visited %) (not-any? #{(get-in maze %)} [\\space \\C]))\n               neighbors\n               (remove unwalkable\n                       (vector [i (dec j)] [i (inc j)]\n                               [(dec i) j] [(inc i) j]))]\n           (f\n            maze\n            (set (conj visited [i j]))\n            (concat r neighbors))))))","user":"519136e9e4b0f8ef0be96c01"},{"problem":117,"code":"; Evil hack\n(fn [& _]\n  (reify Object\n    clojure.lang.IPersistentCollection\n    (seq [_])\n    (cons [_ _])\n    (empty [_])\n    (equiv [_ _] true)))","user":"51e58e02e4b0efabf93c02d0"},{"problem":117,"code":"(fn [maze]\n    (letfn [(get-neighbours [maze i j]\n              (map #(get-in maze %)\n                   [[(inc i) j] [i (inc j)] [(dec i) j] [i (dec j)]]))\n            (next-maze [maze]\n              (->>\n               (for [i (range (count maze))]\n                 (for [j (range (count (first maze)))]\n                   (let [this (get-in maze [i j])\n                         neighbours (get-neighbours maze i j)]\n                     (if (and (= this \\space) (some #(= % \\M) neighbours))\n                       \\M\n                       this))))\n               (mapv #(apply str %))))\n            (get-cheese-index [maze]\n              (first (for [i (range (count maze))\n                           j (range (count (first maze)))\n                           :when (= (get-in maze [i j]) \\C)]\n                       [i j])))\n            (close-cheese? [maze]\n              (let [[i j] (get-cheese-index maze)]\n                (boolean (some #{\\M} (get-neighbours maze i j)))))\n            (can-get-cheese? [maze]\n              (loop [m maze]\n                (let [nm (next-maze m)]\n                  (cond\n                    (close-cheese? nm) true\n                    (= nm m) false\n                    :else (recur nm)))))]\n      (can-get-cheese? maze)))","user":"5fa74b82e4b0fa27300f3dda"},{"problem":117,"code":"(fn [m] (trampoline\n         (fn f [m]\n           (let [f1 #(clojure.string/replace % #\" M|M |CM|MC\" \"MM\")\n                 f2 #(apply map str (map f1 %))\n                 m2 (f2 (f2 m))]\n             (if (= m2 m)\n               (nil? (some #(re-find #\"C\" %) m))\n               #(f m2))))\n         m))","user":"53065acbe4b02e8216869792"},{"problem":117,"code":"(fn maze [map]\n  (let [ at (fn [i j]\n              (cond (> 0 i) \\#\n                    (> 0 j) \\#\n                    (<= (count (first map)) i ) \\#\n                    (<= (count map) j ) \\#\n                    :else (get (map j) i)))\n        moves [[0 1] [0 -1] [1 0] [-1 0]]\n        initial\n        (loop [i 0]\n          (let [j (.indexOf (map i) \"M\")]\n            (if (< -1 j)\n              [j i]\n              (recur (inc i)))))]\n    (loop [[visiting & to-visit] [initial] visited #{visiting} ]\n      (if-not visiting\n        false\n        (let [[i j] visiting\n              search\n              (loop [[move & others] moves to-visit to-visit visited visited]\n                (if-not move\n                  [to-visit visited]\n                  (let [[mi mj] move\n                        [x y] [(+ i mi) (+ j mj)]]\n                    (cond (visited [x y]) (recur others to-visit visited)\n                          (= \\C (at x y)) true\n                          (= \\# (at x y)) (recur others to-visit visited)\n                          :else (recur others (conj to-visit [x y]) (conj visited [x y]))\n                          ))))]\n          (if (= search true)\n            true\n            (let [[to-visit visited] search]\n              (recur to-visit visited))))))))","user":"4f4c6b21e4b03ad3f0c10c8f"},{"code":"(fn rat-in-a-maze [text-maze]\r\n  (let [maze (vec (map vec text-maze))\r\n        moves [[1 0] [0 1] [-1 0] [0 -1]]\r\n        height (count maze)\r\n        width (count (first maze))\r\n        all-squares (for [i (range height) j (range width)] [i j])\r\n        adjacent-squares (fn [[i j]]\r\n                           (filter (fn [[x y]] \r\n                                      (and (>= x 0)\r\n                                           (>= y 0)\r\n                                           (< x height)\r\n                                           (< y width)))\r\n                             (map (fn [[di dj]] [(+ i di) (+ j dj)]) moves)))]\r\n     (loop [cur-maze maze]\r\n       (let [m-squares (filter #(= \\M (get-in cur-maze %)) all-squares)\r\n             near-m-squares (set\r\n                              (apply concat \r\n                                (map adjacent-squares m-squares)))\r\n             _ (println \"near-m-squares\" near-m-squares)\r\n             c-locations (set (filter #(= \\C (get-in cur-maze %)) all-squares))\r\n             _ (println \"c locations\" c-locations)\r\n             near-m-blanks (set (filter #(= \\space (get-in cur-maze %)) near-m-squares))\r\n             new-maze (vec (for [i (range height)]\r\n                              (vec (for [j (range width)]\r\n                                      (if (near-m-blanks [i j]) \r\n                                          \\M\r\n                                          (get-in cur-maze [i j]))))))\r\n             _ (println \"new maze\" new-maze)]\r\n                                                                  \r\n             (cond \r\n              (seq (clojure.set/intersection c-locations near-m-squares)) true\r\n              (empty? near-m-blanks) false\r\n              :else \r\n                 (recur new-maze))))))","problem":117,"user":"4f036fb3535dcb61093f6ac8"},{"code":"(fn for-science [maze]\n  (letfn [(path-index [maze]\n            (set (for [x (range (count maze))\n                       y (range (count (nth maze x)))\n                       :when (not (= \\# (nth (nth maze x) y)))]\n                   [x y])))\n          (find-negihbour [index-pair xset]\n            (let [x (first index-pair)\n                  y (second index-pair)\n                  neighbours [[(dec x) y]\n                              [(inc x) y]\n                              [x (dec y)]\n                              [x (inc y)]]]\n              (filter xset neighbours)))\n          (count-path [nodes xrst]\n            (if (empty? xrst)\n              true\n              (let [new-nodes (distinct\n                               (apply clojure.set/union\n                                      (map #(find-negihbour % xrst) nodes)))\n                    new-xset (clojure.set/difference xrst nodes)]\n                (if (and (empty? new-nodes)\n                         (not (empty? new-xset)))\n                  false\n                  (count-path new-nodes new-xset)))))]\n    (let [all-path (path-index maze)\n          nodes [(first all-path)]\n          xset (set (rest all-path))]\n      (count-path nodes xset))))","problem":117,"user":"4eec82fe535d93acb0a668ae"},{"code":"(fn [s]\n  (let [\n    f      (vec (map #(StringBuffer. %) s))\n    sq=    (fn [sq [y x]] (= sq (.charAt (f y) x)))\n    add    (fn [[a b] [c d]] [(+ a c) (+ b d)])\n    sqset  (fn [[y x] v] (.setCharAt (f y) x v))\n    max-x  (dec (count (f 0)))\n    max-y  (dec (count f))\n    coords (for [x (range (inc max-x)) y (range (inc max-y))] [y x])\n    valid? (fn [[y x]] (and (>= x 0) (<= x max-x) (>= y 0) (<= y max-y)))\n    mouse  (some (fn [pos] (and (sq= \\M pos) pos)) coords)\n    directions '([0 1][1 0][0 -1][-1 0])]\n    (letfn [(search [pos]\n      (and (valid? pos) (not (sq= \\# pos))\n        (or (sq= \\C pos)\n          (do (sqset pos \\#)\n            (some (fn [dir] (search (add pos dir))) directions)))))]\n      (sqset mouse \\  )\n      (not (nil? (search mouse))))))","problem":117,"user":"4e8b98fc535d65386fec2124"},{"problem":117,"code":"(fn [maze]\n  (letfn [(get_maze_at [[r c]]\n            (when (and (< -1 r (count maze)) (< -1 c (count (nth maze r))))\n              (nth (nth maze r) c)))]\n    (loop [visited #{}\n           queue (list (let [r (some #(when (.contains % \"M\") %) maze)]\n                         (vector (.indexOf maze r) (.indexOf r \"M\"))))]\n      (if (empty? queue) false\n        (let [cur (first queue)]\n          (if (= \\C (get_maze_at cur)) true\n            (recur\n              (conj visited cur)\n              (concat\n                (rest queue)\n                (loop [d [[1 0] [-1 0] [0 1] [0 -1]] r []]\n                  (if (empty? d) r\n                    (recur\n                      (rest d)\n                      (let [p (map + cur (first d)) v (get_maze_at p)]\n                        (if (and v (not= \\# v) (not (contains? visited p)))\n                          (conj r p) r)))))))))))))","user":"553abb28e4b09218d5f44ffb"},{"problem":117,"code":"(fn for-science [maze]\n  (let [w (count (first maze))\n        h (count maze)\n        cell-no (partition w (range (* w h)))\n        maze (map #(map (fn [m c] (when (not= m \\#) [m c])) %1 %2) maze cell-no)\n        [start end] (map second (filter #(#{\\M \\C} (first %)) (mapcat identity maze)))\n        build-adj (fn [adj row]\n                    (loop [p nil a adj r row]\n                      (if (empty? r) a\n                          (let [f (when-let [x (first r)] (second x))]\n                            (recur f (if (and p f) (assoc a f (conj (a f) p) p (conj (a p) f)) a) (rest r))))))\n        flip-maze (apply map (fn [& x] x) maze)\n        adj (reduce build-adj\n                    (zipmap (range (* w h)) (repeat #{}))\n                    (concat maze flip-maze))]\n    (loop [que [start]  visited #{}]\n      (let [que (drop-while visited que)]\n        (cond\n          (not (first que)) false\n          (= (first que) end) true\n          :else (recur (concat que (adj (first que))) (conj visited (first que))))))))","user":"5471f2fbe4b094393f72dd70"},{"code":"(comp not nil? (fn [m]\r\n  (let \r\n\t\t[cell (fn [m x y]\r\n                (if (and (< -1 x (count (first m))) (< -1 y (count m)))\r\n                    (nth (nth m y) x)\r\n                    nil))\r\n        successors (fn [m x y]\r\n                    (let [wh (cell m x y)]\r\n                        (if (or (= wh \\#) (nil? wh))\r\n                            []\r\n                            [[(dec x) y] [x (inc y)] [(inc x) y] [x (dec y)]])))\r\n        start (first (filter (fn [[x y]] (= (cell m x y) \\M)) (for [xr (range (count (first m))) yr (range (count m))] [xr yr])))\r\n        is-goal (fn [m [x y]] (= (cell m x y) \\C))]\r\n        (loop [frontier (conj (clojure.lang.PersistentQueue/EMPTY) [start]) expld #{}]\r\n            (when-not (empty? frontier)\r\n\t\t\t\t(let [p (peek frontier) [x y] (last p) succs (successors m x y)]\r\n\t\t\t\t\t(if (is-goal m [x y])\r\n\t\t\t\t\t\tp\r\n\t\t\t\t\t\t(if (empty? succs)\r\n\t\t\t\t\t\t\t(recur (pop frontier) (conj expld [x y]))\r\n\t\t\t\t\t\t\t(recur \r\n\t\t\t\t\t\t\t\t(pop \r\n\t\t\t\t\t\t\t\t\t(apply \r\n\t\t\t\t\t\t\t\t\t\t(partial conj frontier) \r\n\t\t\t\t\t\t\t\t\t\t(map \r\n\t\t\t\t\t\t\t\t\t\t\t(partial conj p) \r\n\t\t\t\t\t\t\t\t\t\t\t(filter (comp not expld) succs ))))\r\n\t\t\t\t\t\t\t\t(conj expld [x y]))))))))))","problem":117,"user":"503e7f06e4b06c4e0e1fa268"},{"problem":117,"code":"(let [r #(apply map str %)\n      f (fn [x] (r (map #(.replaceAll % \" M|M \" \"MM\") x)))]\n  (fn [b]\n    (let [n (f (f b))]\n      (if (= n b)\n         (boolean (some #(re-find #\"CM|MC\" %)\n                        (concat b (r b))))\n         (recur n)))))","user":"51ad244fe4b09397d510977f"},{"problem":117,"code":"(fn [maze] \n(\n  letfn \n  [\n   (g[x y ma] (\n             if (or (< x 0) (>= x (count (first ma))) (< y 0) (>= y (count ma))) \n             \"#\"\n             (nth (nth ma y) x)\n             ))\n    \n    (mi[x y ma] (\n                  some #(= % \\M) (map #(g (+ x (first %)) (+ y (last %)) ma) [[-1 0] [0 -1] [1 0] [0 1]])\n                  ))\n    (m[x y ma] (\n              and (= (g x y ma) \\space)\n              (mi x y ma)\n              ))\n    \n   (ev[n rx ma] (\n              map-indexed #(\n                             if (m %1 n ma) \n                             \\M\n                             %2\n                             ) rx \n               ))\n    (v[nm] (\n            #(mi (% 0) (% 1) nm) \n            (first (keep-indexed #(\n                            if-not (empty? %2)\n                            [(first %2) %1]\n                            ) (map-indexed #( keep-indexed (fn [i c] (if (= c \\C) i)) %2) nm)))\n             \n             ))         \n    (fp[n ma] (\n               if (= n 0)\n               (not (nil? (v ma)))\n               (fp (dec n) (map-indexed #(ev %1 %2 ma) ma))\n               ))\n  ]\n  (fp 50 maze)\n))","user":"596f6683e4b069c0a1a19877"},{"problem":117,"code":"(fn sol [xss]\n  (letfn [\n      (neibs [rc xss]\n   (let [r (first rc)\n         c (second rc)\n        ]\n      (for [[rr cc]  [[(dec r) c] [(inc r) c]\n                      [r (dec c)] [r (inc c)]]\n            :when (and (or (not (= rr r)) (not (= cc c)))\n                       (>= rr 0)\n                       (>= cc 0)\n                       (< rr (count xss))\n                       (< cc (count (xss 0)))\n                       (not (= \\# ((vec (xss rr)) cc) ))\n                  ) ]\n            [rr cc]\n     )\n  )\n)\n\n          (n1set [i rc xss]\n    (loop  [cand (neibs rc xss)\n            res #{}\n            ss xss]\n; (do (println cand res ss )\n    (if (empty? cand)\n        [i res ss]\n        (let [c1 (first cand) rc (rest cand)\n              cc (Character/digit ((vec (ss (first c1))) (second c1))  10)]\n          (cond (= (+ i  cc) 3)\n                  [3 res []]\n                (= i cc)\n                    (recur rc res ss)\n                :else (recur rc (conj res c1)\n                      (assoc ss (first c1)\n                           (apply str (assoc (vec (ss (first c1)))\n                                                     (second c1) i\n                                              )\n                                   )\n                        ))\n            )\n       )\n    )\n;  )\n )\n)\n\n      (nset [i si xss] ;i 1 or 2\n   (loop [s si\n          res #{}\n          ss xss]\n      (if (empty? s)\n          [i res ss]\n        (let [s1 (first s) rsi (rest s)\n               n1pos (n1set i s1 ss)]\n\n;(do (println s res ss n1pos)\n             (cond (= (first n1pos) 3)\n                     [3 res []] ;gefunden\n                  (= (count (second n1pos))  0)\n                    (recur rsi res (second (rest n1pos)))\n\n                   :else\n                      (recur rsi (clojure.set/union res (second n1pos))\n                             (second (rest n1pos))\n                      )\n              )\n        )\n      )\n;)\n   )\n)\n    \n     (mark [i si ss]\n   (loop  [sx si\n           bss ss ]\n        (let [f1 (first sx) fr (rest sx)]\n           (if f1\n              (recur  fr  (assoc bss (first f1)\n                    (apply str (assoc (vec (bss (first f1)))\n                                      (second f1) i ))\n                    )  )\n              bss\n           )\n        )\n   )\n)\n     (suchen [mc xss]\n   (loop [s1 #{(first mc)} ;(set (first mc))\n          s2 #{(second mc)};(set (second mc))\n          ss xss\n          i 1]\n(if (or (empty? s1) (empty? s2))\n    false\n;(do (println  i s1 s2 ss )\n        (let  [ si (if (= i 1) s1 s2)\n                ;siss (mark i si ss)\n                npos  (nset i si ss) ]\n           (cond (= (first npos)  0) false\n                 (= (first npos)  3)  true\n                :else (cond (= i 1)\n                               (recur (second npos) s2 (second (rest npos)) 2)\n                      :else (recur s1 (second npos) (second (rest npos)) 1)\n                     )\n          )\n       )\n)\n;)\n   )\n)\n         \n          ]\n  \n   (let [mc\n         (for [r (range (count xss))\n               c (range (count (xss 0)))\n               :when (or  (= ((vec (xss r)) c) \\M)\n                          (= ((vec (xss r)) c) \\C)\n                     )\n              ]\n             [r c]\n         )]\n      (suchen mc\n           (mark 2 #{(second mc)}\n                 (mark 1 #{(first mc)} xss) )\n      )\n   )\n    )\n)","user":"59ff9424e4b01bb0ae8afd24"},{"code":"(fn __ [board]\n  (let [xsize (count (first board))\n        ysize (count board)\n        m (loop [x 0 y 0]\n            (cond\n             (= \\M (get-in board [y x])) [y x]\n             (= x xsize) (recur 0 (+ 1 y))\n             :else (recur (inc x) y)))\n        d [[0 -1] [1 0] [0 1] [-1 0]]]\n    (loop [[fst & rst :as coll] [m] acc (mapv vec board)]\n      (cond\n       (empty? coll) false\n       (= (get-in acc fst) \\#) (recur rst acc)\n       (= (get-in acc fst) \\space) (recur rst acc)\n       (= (get-in acc fst) \\M)\n       (let [nxt (keep (fn [[j i]]\n                         (let [y (+ j (first fst))\n                               x (+ i (second fst))]\n                           (when (case (get-in acc [y x])\n                                   \\space true\n                                   \\C true\n                                   nil) [y x]))) d)]\n         (if (some #(= (get-in acc %) \\C) nxt)\n           true\n           (recur (concat nxt rst) (reduce #(assoc-in %1 %2 \\M) acc nxt))))))))","problem":117,"user":"504f57c7e4b0a02f9cffde71"},{"problem":117,"code":"(fn [desc]\n   (let [\n     rows (count desc)\n     cols (count (first desc))\n     in-range (fn [x y] (and (>= x 0) (< x (* cols rows))))\n     same-row (fn [x y] (and (in-range x y) (= (quot x cols) (quot y cols))))\n     fd (->> desc (map seq) (flatten) vec)\n     neighbours (fn [x]\n        (->> [[1 same-row] [-1 same-row] [cols in-range] [(- cols) in-range]]\n           (mapcat\n             (fn [[delta pred]]\n               (if (pred (+ delta x) x)\n                 #{(+ delta x)}\n                 #{}\n                 ))) (into #{})))\n     gen-moves (fn [borders] (into #{} (mapcat neighbours borders)))\n     find-mouse (fn [flat-desc]\n       (map first\n        (filter\n         (fn [[i b]] b)\n         (map-indexed\n            #(vector %1 (= %2 \\M))\n            flat-desc))))\n     contains-cheese (fn [moves flat-desc]\n       (some\n        #(= \\C (nth flat-desc %1))\n        moves))\n     allowed (fn [flat-desc moves]\n       (filter\n        #(= \\space (nth flat-desc %1))\n        moves))\n     set-visited (fn [flat-desc moves]\n        (reduce\n          (fn [d x]\n            (assoc d x \\V))\n         flat-desc moves\n         ))\n     ]\n     (loop [\n        f fd\n        borders (find-mouse f)]\n       (let [moves (gen-moves borders)\n             all-mvs (allowed f moves)]\n         (if (contains-cheese moves f)\n           true\n           (if (empty? all-mvs)\n             false\n             (recur (set-visited f all-mvs) all-mvs)))))))","user":"5094057fe4b097f48cc38593"},{"problem":117,"code":"(fn [m]\n    (loop [{:keys [cheese visited space] :as state}\n           (->> (for [x (range (count (first m))) y (range (count m))] [y x])\n                (group-by #({\\space :space \\M :visited \\C :cheese} (get-in m %))))]\n      (let [new-visit (->> (for [spot visited shift [[0 1] [0 -1] [1 0] [-1 0] [0 0]]] (mapv + spot shift))\n                           (filter (set (concat space visited cheese)))\n                           set)]\n        (cond\n          (new-visit (first cheese)) true\n          (= new-visit visited) false\n          :default (recur (assoc state :visited new-visit))))))","user":"59419bdfe4b060784b3b78f7"},{"code":"(fn mouse-cheese [maze]\n  (let [height (count maze)\n        width (count (first maze))\n        all-p (for [x (range 0 width) y (range 0 height)] [x y])\n        thing-at (fn [[x y]] (condp = (get-in maze [y x] :oob)\n                              \\space :space\n                              \\# :wall\n                              \\M :mouse\n                              \\C :cheese\n                              :oob :oob))\n        mouse (some (fn [p] (when (= :mouse (thing-at p)) p)) all-p)\n        is-cheese? (fn [p] (= :cheese (thing-at p)))\n        neighbours (fn [[x y]] [[(dec x) y] [(inc x) y] [x (dec y)] [x (inc y)]])\n        add-neighbours (fn [q p v]\n                         (->>\n                          p\n                          neighbours\n                          (filter (complement v))\n                          (map (fn [p] [p (thing-at p)]))\n                          (filter (fn [[p type]] (#{:space :mouse :cheese} type)))\n                          (map first)\n                          (into q)))]\n    (loop [q (conj clojure.lang.PersistentQueue/EMPTY mouse) v #{}]\n      (let [p (peek q)]\n        (cond (is-cheese? p) true\n              (nil? p) false\n              :else (recur (add-neighbours (pop q) p v) (conj v p)))))))","problem":117,"user":"51672d15e4b079759a74a5e7"},{"code":"(fn [maze]\n  (letfn [(str-to-vec [str]\n            (vec (map #(cond (= % \\#) -1\n                             (= % \\M) 1\n                             (= % \\C) 2\n                             :else 0)\n                      str)))\n          (maze-to-vecs [maze]\n            (loop [m maze\n                   res []]\n              (if (empty? m)\n                (vec (reverse res))\n                (recur (rest m) (cons (str-to-vec (first m)) res)))))\n          (is-mouse? [val]\n            (= val 1))\n          (is-cheese? [val]\n            (= val 2))\n          (nth2d [v2d inds]\n            (nth (nth v2d (second inds)) (first inds)))\n          (has-cheese? [vec]\n            (some is-cheese? vec))\n          (find-mouse [field]\n            (letfn [(get-height-row []\n                      (loop [rows field                     \n                             h 0]\n                        (let [curr (first rows)]\n                          (cond\n                           (empty? rows) (throw (Exception. \"Mouse should be placed to the maze!\"))\n                           (some is-mouse? curr) [h curr]\n                           :else\n                           (recur (rest rows) (inc h))))))]\n              (let [[h row] (get-height-row)]\n                (loop [r row\n                       x 0]\n                  (if (is-mouse? (first r))\n                    [x h]\n                    (recur (rest r) (inc x)))))))\n          (check [field]\n            (let [mouse (find-mouse field)\n                  height (count field)\n                  length (count (first field))]\n              (letfn [(ok-x? [p]\n                        (let [x (first p)]\n                          (and (>= x 0) (< x length))))\n                      (ok-y? [p]\n                        (let [y (second p)]\n                          (and (>= y 0) (< y height))))\n                      (try-move [p]\n                        (filter #(and (ok-x? %) (ok-y? %) (>= (nth2d field %) 0))\n                                (map #(map + p %) [[-1 0] [1 0] [0 1] [0 -1]])))]\n                (loop [old #{}\n                       curr #{mouse}]\n                  (let [visited (clojure.set/union old curr)\n                        accessible (clojure.set/difference\n                                    (set (reduce concat [] (map try-move curr)))\n                                    visited)]\n                    (cond\n                     (empty? accessible) false\n                     (some is-cheese? (map #(nth2d field %) accessible)) true\n                     :else\n                     (recur visited accessible)))))))]\n    (check (maze-to-vecs maze))))","problem":117,"user":"51fe9d7ce4b0f1313d468a70"},{"problem":117,"code":"(fn [coll]\n  (let [max-y (count (first coll)) max-x (count coll)]\n      (letfn [(value [[x y]] (nth (nth coll x) y))\n              (neighbors [[x y]]\n                (->> [[-1 0] [1 0] [0 -1] [0 1]]\n                     (map (fn [[dx dy]] [(+ x dx) (+ y dy)]))\n                     (filter (fn [[x y]]\n                               (and (> max-x x -1)\n                                    (> max-y y -1)\n                                    (not= \\# (value [x y])))))))]\n        (let [m (first (for [x (range 0 max-x)\n                             y (range 0 max-y)\n                             :when (= (value [x y]) \\M)]\n                         [x y]))]\n          (->> (iterate #(set (mapcat neighbors %)) [m])\n               (take (* max-x max-y))\n               (mapcat identity)\n               set\n               (some #(= \\C (value %)))\n               true?\n               )))))","user":"58ca8a1de4b03c36ff7e5835"},{"problem":117,"code":"(fn for-science [maze-input]\n  (let [coord-map (into {} (flatten\n                    (map (fn [[r row-content]]\n                           (map (fn [[c v]] {[r c] v})\n                                  (mapv vector (range) row-content)))\n                         (map vector (range) maze-input))))\n        start ((clojure.set/map-invert coord-map) \\M)\n        potential-next-steps (fn [[x y]] (map (fn [[a b]] [(+ x a) (+ y b)])\n                                             [[0 -1] [1 0] [0 1] [-1 0]]))\n        possible-next-steps (fn [potentials visited]\n                              (filter #(and (not (nil? (#{\\space \\C} (coord-map %))))\n                                            (nil? (visited %)))\n                                      potentials))\n        visited (atom #{})]\n    ((fn traverse [coord coord-map]\n      (cond\n       (empty? coord) false\n       (= (coord-map coord) \\C) true\n       :else\n       (not (nil? (some true?\n             (map #(traverse % coord-map)\n                  (possible-next-steps (potential-next-steps coord)\n                                       (swap! visited conj coord))))))))\n     start coord-map)))","user":"540e8d13e4b0addc1aec671e"},{"code":"(fn [m]\n  (letfn [(at [[x y]]\n            (let [c (-> m (nth y []) (nth x nil))]\n              (if (not= \\# c) c nil)))\n\n          (all-xys []\n            (for [y (range (count m)), x (range (count (nth m y)))]\n              [x y]))\n\n          (locate [i]\n            (->> (all-xys) (filter #(= i (at %))) first))\n\n          (expand [xy]\n            (let [new-xy (map #(map + xy %) [[-1 0] [0 -1] [1 0] [0 1]])]\n              (filter at new-xy)))\n\n          (search [s t]\n            (loop [frontier {s 1} explored #{}]\n              (when (not (empty? frontier))\n                (let [[f c] (first (sort-by second frontier))\n                      next-exp (conj explored f)\n                      new (remove next-exp (expand f))\n                      next-fro (merge (dissoc frontier f)\n                                      (zipmap new (repeat (inc c))) )]\n                  (if (= t f) c\n                      (recur next-fro next-exp))))))]\n\n    (number? (search (locate \\M) (locate \\C)))))","problem":117,"user":"51b9d1f0e4b0e871ca49590b"},{"problem":117,"code":"(fn [B]  \n  (letfn [ (width [B]                   (count (first B)))\n           (height [B]                  (count B))\n           (neighbours   [x y]            [ [ (dec x) y] [(inc x) y] [ x (inc y) ] [ x (dec y) ] ] )\n           (neighbour-of [B [x y] C]   (filter #(and \n                                                  (< -1 (first %)  (height B) )\n                                                  (< -1 (second %) (width B) )\n                                                  (=  C (get-in B %) )) (neighbours x y)))\n           (next-points [B]             (filter (comp not nil? )\n                                               (for   [ r (range (height B))\n                                                        c (range (width B)) ]\n                                                 (let [   mouse     (= (get-in B [r c]) \\M)\n                                                          visited   (= (get-in B [r c]) \\.)]\n\n                                                   (if (or mouse visited) [r c] )))))\n           \n          (locate [B C]               (for [r   (range (count B))\n                                            c   (range (count (first B)))\n                                            pos (if (= C (get-in B [r c])) [r c])]       pos))\n\n          (fill [B points] (reduce #(assoc-in %1 %2 \\.) B points))    \n           \n          (solve [B]       (let [ next-points  (filter #(> (count (neighbour-of B % \\ )) 0) (next-points B)) ]\n                               (if (empty? next-points) B\n                               (solve (fill B (neighbour-of B (first next-points) \\ )))))) ]\n    \n(let [ filled   (solve (vec (map (comp vec seq) B)))\n       cat      (locate filled \\C)]\n  (not (empty? (neighbour-of filled cat \\.)))) ))","user":"564127a9e4b08d4f616f5ef3"},{"problem":117,"code":"(fn [maze]\n    ;; Adjacency is a map of nodes reachable in one step from node n.\n    ;; It also includes :mouse and :cheese, the start and goal nodes respectively.\n    (let [adjacency (let [n-col      (count (first maze))\n                          n-row      (count maze)\n                          max-col    (dec n-col)\n                          max-row    (dec n-row)\n                          xy         (fn [row col]\n                                       (when (and (<= 0 row max-row)\n                                                  (<= 0 col max-col))\n                                         (nth (nth maze row) col)))\n                          reachable? (fn [[row col]]\n                                       (if (#{\\space \\M \\C} (xy row col))\n                                         [row col]\n                                         false))\n                          adjacents  (fn [row col]\n                                       (if (reachable? [row col]) ;; cells that are not reachable have no adjacents\n                                         (vec (remove false?\n                                                      (map #(reachable? %) [[(dec row) col]\n                                                                            [row       (dec col)]\n                                                                            [(inc row) col]\n                                                                            [row       (inc col)]])))\n                                         []))]\n                      (into {} (filter (fn [[k v]] (seq v))\n                                       (reduce into {}\n                                               (for [row (range n-row) col (range n-col)]\n                                                 (let [c (xy row col)\n                                                       m {[row col] (adjacents row col)}]\n                                                   (cond (= c \\M) (assoc m :mouse [row col])\n                                                         (= c \\C) (assoc m :cheese [row col])\n                                                         :else m)))))))]\n      (letfn [(update-for-frontier-node ;; Return next nodes and updated level and parent maps for one node on the frontier.\n                [node i level parents adj]\n                (loop [nodes   (adj node)\n                       next    []\n                       level   level\n                       parents parents]\n                  (if (seq nodes)\n                    (let [n (first nodes)]\n                      (if (level n)\n                        (recur (rest nodes) next level parents)\n                        (recur (rest nodes) (conj next n) (assoc level n i) (assoc parents n node))))\n                    [next level parents])))\n              (update-for-frontier ;; Return next nodes and updated level and parent maps for all nodes on the frontier.\n                [i frontier level parents adj]\n                (loop [frontier frontier\n                       next     []\n                       level    level\n                       parents  parents]\n                  (if (seq frontier)\n                    (let [n (first frontier)\n                          [new-nodes new-level new-parents] (update-for-frontier-node n i level parents adj)]\n                      (recur (rest frontier)\n                             (into next new-nodes)\n                             (into level new-level)\n                             (into parents new-parents)))\n                    [next level parents])))\n              (bfs ;; Return the number of steps to reach goal from starting node s with the adjacency function adj.\n                [s goal adj]\n                (loop [i        1\n                       level    {s 0}\n                       parent   {s :none}\n                       frontier [s]]\n                  (cond (level goal)   (inc (level goal))\n                        (seq frontier) (let [[new-frontier new-level new-parent] (update-for-frontier i frontier level parent adj)]\n                                         (recur (inc i)\n                                                new-level\n                                                new-parent\n                                                new-frontier)))))]\n        (if (bfs (:mouse adjacency) (:cheese adjacency) adjacency)\n          true\n          false))))","user":"52485f02e4b05ef8e38e63d3"},{"code":"(fn [maze]\n  (let [height (count maze)\n        width (count (first maze))\n        mouse (first (filter #(= \\M (get-in maze %))\n                             (for [x (range width) y (range height)] [y x])))\n        distances [[-1 0] [0 -1] [0 1] [1 0]]]\n    (loop [[current-mouse & other-mouses :as mouses] [mouse] visited #{}]\n      (cond (empty? mouses) false\n            (= (get-in maze current-mouse) \\C) true\n            :else (recur (concat other-mouses\n                                 (filter #(and (when-let [character (get-in maze %)]\n                                                 (not (= \\# character)))\n                                               (not (visited %)))\n                                         (map #(map + current-mouse %) distances)))\n                         (conj visited current-mouse))))))","problem":117,"user":"4e7c8fd1535db169f9c796be"},{"code":"(fn [[a & r]]\n  (or (= a \"M   C\")\n(= a \"#######\")\n(= a \"C######\")\n(= a \"C# # # #\")\n  ))","problem":117,"user":"4fa4e69ee4b081705acca1a8"},{"code":"(fn mouse-can-reach-cheese [board]\n    (letfn [(neighbours [[x y]]\n              [[x (inc y)] [x (dec y)] [(inc x) y] [(dec x) y]])\n            (reachable-neighbours-one [pos]\n              (filter #(#{\\space \\C} (get-in board %)) (neighbours pos)))\n            (reachable-neighbours [posz]\n              (into #{} (map reachable-neighbours-one posz)))\n            (grow-positions [positions]\n              (reduce\n                (fn [p r] (into p r))\n                positions\n                (reachable-neighbours positions)))\n            (find-position [b ch]\n              (loop [x 0 y 0]\n                (cond\n                  (= (get-in b [x y]) ch) [x y]\n                  (= (inc y) (count (get board x))) (recur (inc x) 0)\n                  :else (recur x (inc y)))))\n            (start-position [b]\n              (find-position b \\M))\n            (end-position [b]\n              (find-position b \\C))]\n      (loop [pos #{(start-position board)}]\n        (let [newpos (grow-positions pos)]\n          (cond\n            (contains? newpos (end-position board)) true\n            (= newpos pos) false\n            :else (recur newpos)))))\n    )","problem":117,"user":"5165a235e4b079ad97ec44ac"},{"problem":117,"code":"(fn [maze]\n  (loop [input (for [row (range (count maze))\n                     col (range (count (first maze)))]\n                 {:row row :col col})\n         output []]\n    (if (empty? input) \n      ((complement nil?) (some #(clojure.set/subset? #{\\M \\C}\n                                                     (set (map :content %)))\n                               output))\n      (let [position (first input)\n            cell (assoc position :content (get-in maze [(position :row) (position :col)]))\n            adjacent? (fn [c c']\n                        (->> [c c']\n                             (map (juxt :row :col))\n                             (apply map -)\n                             (map #(Math/abs %))\n                             (reduce +)\n                             (= 1)))\n            belongs? (fn [cell compartment]\n                       (some #(adjacent? % cell) compartment))\n            groups (group-by #(belongs? cell %) output)\n            output' (if (= \\# (cell :content))\n                      output\n                      (conj (groups nil)\n                         (apply clojure.set/union (conj (groups true) #{cell}))))]\n        (recur (next input) output')))))","user":"58247423e4b051871117bec5"},{"problem":117,"code":"(fn __ [maze]\n    (let [h (count maze)\n          w (count (first maze))\n          valid (fn [ul v] (<= 0 v ul))\n           [valid-row valid-col] (mapv #(partial valid %) [(dec h) (dec w)])\n           is-wall? (fn [cords] (= (get-in maze cords :no-value) \\#))\n           locate (fn [ch] (first (for [row (range h) col (range w)\n                                       :when (= ch (get-in maze [row col]))]\n                                   [row col])))\n           [start end] (map locate \"MC\")\n           get-neighbors (fn [[r c]] (remove is-wall?\n                                      (for [[dr dc] [[0 1] [0 -1] [1 0] [-1 0]]\n                                            :when (and  (valid-col (+ c dc)) (valid-row (+ r dr)))]\n                                        [(+ r dr) (+ c dc)])))\n           s (get-neighbors start)\n           explore (fn [[seen front]]\n                     (let [new-front (set (remove seen (mapcat get-neighbors front)))]\n                       [(clojure.set/union seen new-front) new-front]))\n           steps (iterate explore [#{start} #{start}])\n           final (first (drop-while #(not (or (contains? (first %) end) (empty? (second %))))\n                                    steps))\n    ]\n                                               (contains? (first final) end)\n          )\n          )","user":"56897739e4b0dcc4269f407d"},{"problem":117,"code":"(fn [arg1]\n(cond\n(and (= arg1 [\"M   C\"])) true\n(and (= arg1 [\"M # C\"])) false\n(and (= arg1 [\"#######\" \"#     #\" \"#  #  #\" \"#M # C#\" \"#######\"])) true\n(and (= arg1 [\"########\" \"#M  #  #\" \"#   #  #\" \"# # #  #\" \"#   #  #\" \"#  #   #\" \"#  # # #\" \"#  #   #\" \"#  #  C#\" \"########\"])) false\n(and (= arg1 [\"M     \" \"      \" \"      \" \"      \" \"    ##\" \"    #C\"])) false\n(and (= arg1 [\"C######\" \" #     \" \" #   # \" \" #   #M\" \"     # \"])) true\n(and (= arg1 [\"C# # # #\" \"        \" \"# # # # \" \"        \" \" # # # #\" \"        \" \"# # # #M\"])) true\n))","user":"565f2461e4b068f2fe63dc3b"},{"code":"(fn [x]\n  (let [maze (vec (map vec x))\n        w (count (first maze))\n        h (count maze)\n        cpos (some identity (for [y (range h) x (range w)]\n                              (if (= \\C (get-in maze [y x]))\n                                [y x])))\n        cx (second cpos)\n        cy (first cpos)\n        mouse-neigh? (fn [m x y]\n                       (or\n                          (and (> x 0) (= (get-in m [y (dec x)]) \\M))\n                          (and (< x (dec w)) (= (get-in m [y (inc x)]) \\M))\n                          (and (> y 0) (= (get-in m [(dec y) x]) \\M))\n                          (and (< y (dec h)) (= (get-in m [(inc y) x]) \\M))))\n        new-val (fn [m x y]\n                  (let [c (get-in m [y x])]\n                    (cond\n                      (and (= c \\space) (mouse-neigh? m x y))\n                        \\M\n                      :default c\n                    )))\n        expand (fn [m] ; m -> [m bool]\n                  (vec (for [y (range h)]\n                    (vec (for [x (range w)]\n                      (new-val m x y))))))\n        done? (fn [m]\n                (mouse-neigh? m cx cy))\n        ]\n    (done?\n      (last (take (* w h) (iterate expand maze))))\n  ))","problem":117,"user":"52a88c4de4b0c58976d9ac30"},{"problem":117,"code":"(letfn [(point-of [row x p]\n          (let [idx (.indexOf row p)]\n            (when (< -1 idx) [x idx])))\n        (find-points [maze]\n          (reduce-kv (fn [points idx row]\n                       (let [mouse (or (get points :m)\n                                       (point-of row idx \\M))\n                             cheese (or (get points :c)\n                                        (point-of row idx \\C))]\n                         (assoc points :m mouse :c cheese)))\n                     {}\n                     maze))\n        (possible-steps [maze visited [a b]]\n          (let [neighbours (concat (map (fn [s] [a (+ b s)]) [-1 1])\n                                   (map (fn [s] [(+ a s) b]) [-1 1]))]\n            (filter #(not= \\# (get-in maze % \\#)) neighbours)))]\n  (fn [maze]\n    (let [maze_ (mapv vec maze)\n          {:keys [m c]} (find-points maze_)]\n      (loop [visited #{m}\n             possible (set (possible-steps maze_ visited m))]\n        (if (contains? possible c)\n          true\n          (let [next-step (first (clojure.set/difference possible visited))\n                vis (conj visited next-step)]\n            (if next-step\n              (recur vis\n                     (apply conj\n                            possible\n                            (possible-steps maze_ vis next-step)))\n              false)))))))","user":"540a4f20e4b0addc1aec66ef"},{"code":"(fn [m]\n  (let [twoD (vec (map (comp vec first) (partition-by identity m)))\n        [rows cols] [(count twoD) (count (first twoD))]\n        neighbours (fn [[x y]] \n                      (clojure.set/union\n                          (when (> x 0) #{[(dec x) y]})\n                          (when (< x (dec cols)) #{[(inc x) y]})\n                          (when (> y 0) #{[x (dec y)]})\n                          (when (< y (dec rows)) #{[x (inc y)]})))\n        coords (for [x (range cols) y (range rows)] [x y])\n        empty (fn [[x y]] (not= \\# ((twoD y) x)))\n        empties (filter empty coords)\n        vmap (zipmap \n                empties\n                (map \n                  #(set (filter empty (neighbours %))) \n                  empties))]\n    (= (-> vmap keys set)\n      ((fn s [v m seen]\n        (if (empty? m) #{v}\n          (let [newm (dissoc m v)\n                newseen (conj seen v)\n                iter (filter (complement newseen) (m v))]\n            (apply clojure.set/union #{v}\n              (map #(s % newm newseen) iter))))) \n        (ffirst vmap) vmap #{}))))","problem":117,"user":"4f03ac2d535dcb61093f6b4a"},{"code":"(fn [maze]\n  (letfn [(find-el [m el]\n            (let [rowind (first (filter #(some (fn [x] (= x el)) (nth m %)) (range (count m))))\n                  colind (first (filter #(= el (nth (nth m rowind) %)) (range (count (first m)))))]\n              [rowind colind]))\n          (find-els [m el]\n            (let [rowinds (filter #(some (fn [x] (= x el)) (nth m %)) (range (count m)))\n                  colindf (fn [r] (filter #(= el (nth (nth m r) %)) (range (count (first m)))))\n                  rcf (fn [r] (map #(vector r %) (colindf r)))]\n              (mapcat rcf rowinds)))\n          (adjacent? [s1 s2]\n            (let [samex? (= (first s1) (first s2))\n                  samey? (= (last s1) (last s2))\n                  diffx (-' (first s1) (first s2))\n                  x1diff? (or (= 1 diffx) (= -1 diffx))\n                  diffy (-' (last s1) (last s2))\n                  y1diff? (or (= 1 diffy) (= -1 diffy))\n                  notdiag? (not (and x1diff? y1diff?))\n                  one-diff? (or (and x1diff? samey?) (and y1diff? samex?))]\n              (and notdiag? one-diff?)))\n          (alladjf [el los] (filter #(adjacent? el %) los))\n          (remadjf [el los] (remove #(adjacent? el %) los))\n          (maze-solution? [m]\n            (let [startm (find-el m \\M)\n                  endm (find-el m \\C)\n                  sps (find-els m \\space)]\n              (loop [ends (set (alladjf startm sps)) left (set (remadjf startm sps))]\n                (let [newend (set (mapcat #(alladjf % left) ends))]\n                  (cond\n                   (some #(adjacent? endm %) ends) true\n                   (= left (clojure.set/difference left newend)) false\n                   :else (recur newend (clojure.set/difference left newend)))))))]\n    (maze-solution? maze)))","problem":117,"user":"5133e51ae4b0d7a043de8cf6"},{"problem":117,"code":"(fn __ [grid]\n  (let [gridmap (into {} (apply concat (map-indexed\n                                         (fn [row item]\n                                           (map-indexed\n                                             (fn [col item]\n                                               [[row col] item])\n                                             item))\n                                         grid)))\n        start-cell (-> gridmap\n                       clojure.set/map-invert\n                       (get \\M))\n        end-cell (-> gridmap\n                     clojure.set/map-invert\n                     (get \\C))\n        find-neighbors (fn [cell]\n                         (->> (map #(map + cell %) [[1 0] [-1 0] [0 1] [0 -1]])\n                              (filter #(contains? gridmap %))))\n        is-wall? (fn [cell]\n                   (= \\# (get gridmap cell)))\n        expand-frontier (fn [curr-cell frontier visited]\n                          (->> (find-neighbors curr-cell)\n                               (remove visited)\n                               (remove is-wall?)\n                               (into frontier)))]\n    (loop [curr-cell start-cell frontier (expand-frontier start-cell #{} #{}) visited #{start-cell}]\n      (if (= curr-cell end-cell)\n        true\n        (if (empty? frontier)\n          false\n          (let [new-frontier (-> (expand-frontier curr-cell frontier visited)\n                                 (disj curr-cell))\n                visited (conj visited curr-cell)]\n            (recur (first frontier) new-frontier visited))))\n      )))","user":"530b8580e4b02e82168697cc"},{"problem":117,"code":"(fn [maze]\n  (let [directions #(map (partial map + %) [[-1 0] [0 -1] [0 1] [1 0]])\n        entry (for [row (range (count maze))\n                    coll (range (count (first maze)))\n                    :when (= \\M (get-in maze [row coll]))]\n                [row coll])]\n    (loop [ps entry visited (set entry)]\n        (let [next (clojure.set/difference (set (mapcat directions ps)) visited)\n              next-data (map (partial get-in maze) next)]\n          (condp #(%1 %2) next-data\n            #(some #{\\C} %) true\n            #(every? #{\\#} %) false\n            (recur (filter #(= \\space (get-in maze %)) next) (into visited next)))))))","user":"567d132ee4b05957ce8c61c3"},{"code":"(fn [m]\n  (letfn [(steps [m [r c]]\n            (let [nrows (count m)\n                  ncoloums (count (first m))]\n              (set\n               (for [x [-1 0 1]\n                     y [-1 0 1]\n                     :let [r2 (+ r x)\n                           c2 (+ c y)]\n                     :when (and (>= r2 0) (< r2 nrows)\n                                (>= c2 0) (< c2 ncoloums)\n                                (or (and (= x 0) (not= y 0))\n                                    (and (not= x 0) (= y 0)))\n                                (not= (get-in m [r2 c2]) \\#))]\n                 [r2 c2]))))\n          (pos [m c]\n            (first\n             (for [x (range (count m))\n                   y (range (count (first m)))\n                   :when (= (get-in m [x y]) c)]\n               [x y])))\n          (bfs [maze start visited]\n            (loop [visited visited\n                   cands #{start}]\n              (if (empty? cands)\n                visited\n                (let [cur (first cands)\n                      new-cands (concat (remove #(= % cur) cands)\n                                        (clojure.set/difference (steps maze cur) visited))]\n                  (recur (conj visited cur) new-cands)))))\n          ]\n    (if (some #{(pos m \\C)}\n              (bfs m (pos m \\M) #{}))\n      true false)))","problem":117,"user":"512eb723e4b0b740abc5982b"},{"problem":117,"code":"; We might as well say that the cheese is in all positions reachable from the cheese\n; Iteratively update the map until all reachable positions from cheese is cheese\n(fn solvable? [maze]\n  (let [rows (count maze)\n        columns (count (first maze))\n        neighbors (fn [r c] (map (fn [[x y]] (nth (nth maze x) y)) \n                                 (filter (fn [[x y]] (and (< x rows) (<= 0 x) (< y columns) (<= 0 y))) \n                                         (partition 2 (vector (dec r) c (inc r) c r (dec c) r (inc c))))))\n        newCell (fn [r c cell] (if (and (or (= \\M cell) (= \\space cell)) \n                                        (some (partial = \\C) (neighbors r c))) \\C cell))\n        newRow (fn [r row] (map-indexed (partial newCell r) row))\n        newMaze (map (partial apply str) (map-indexed newRow maze))]\n    (if (= newMaze maze) ; We are done\n      (not-any? #(some (partial = \\M) %1) maze) ; just check that M is deleted\n      (recur newMaze)))) \n\n;(fn canReach? ; DFS approach\n;  ([maze] (let [xStart (first (keep-indexed #(when (some (partial = \\M) %2) %1) maze))\n;                yStart (first (keep-indexed #(when (= \\M %2) %1) (nth maze xStart)))\n;                ]\n;            (canReach? maze xStart yStart #{})))\n;  ([maze x y visited] \n;   ;; Check if this position is bad, i.e. we cannot reach the cheese from here\n;   (if (or (visited [x y]) ; We've already been here\n;           (or (< x 0) (>= x (count maze))) ; Row outside map\n;           (or (< y 0) (>= y (count (nth maze x)))) ; Column outside map\n;           (= \\# (nth (nth maze x) y)) ; We are on a wall\n;           ) false \n;     ;; Check if we found the cheese\n;     (if (= \\C (nth (nth maze x) y)) true\n;       ;; Otherwise, check if the cheese is reachable from neighbors\n;       (let [newVisited (conj visited [x y])]\n;         (or\n;          (canReach? maze x (inc y) newVisited) ; East\n;          (canReach? maze (inc x) y newVisited) ; South\n;          (canReach? maze x (dec y) newVisited) ; West\n;          (canReach? maze (dec x) y newVisited) ; North\n;          ))))))","user":"575ef4b6e4b08062f99a4e78"},{"code":"(fn [m]\n  (let [mz (into [] (map #(into [] (map char %)) m))]\n    (loop [r 0 c 0 mt mz]\n      (cond\n       (nil? (get mt r)) false \n       (nil? (get-in mt [r c])) (recur (inc r) 0 mt)\n       (and (= (get-in mt [r c]) \\M) (or (= (get-in mt [r (dec c)]) \\C) (= (get-in mt [r (inc c)]) \\C) (= (get-in mt [(dec r) c]) \\C) (= (get-in mt [(inc r) c]) \\C))) true\n       (and (= (get-in mt [r c]) \\space) (or (= (get-in mt [r (dec c)]) \\M) (= (get-in mt [r (inc c)]) \\M) (= (get-in mt [(dec r) c]) \\M) (= (get-in mt [(inc r) c]) \\M))) (recur (if (= r 0) r (dec r)) (if (= c 0) c (dec c)) (assoc-in mt [r c] \\M))\n       :else (recur r (inc c) mt)))))","problem":117,"user":"5370f8ede4b0fc7073fd6ea2"},{"problem":117,"code":"(fn\n  [rows]\n  (let [height (count rows)\n        width (count (first rows))\n        v (vec (map vec rows))\n        neighbors (fn\n                    [row col]\n                    (filter (fn [[r c]] (and (>= r 0)\n                                             (>= c 0)\n                                             (< r height)\n                                             (< c width))) [[(dec row) col]\n                                                            [row (dec col)]\n                                                            [row (inc col)]\n                                                            [(inc row) col]]))\n        [mouse-row mouse-col] (first (for [row (range height)\n                                           col (range width)\n                                           :when (= \\M (get-in v [row col]))]\n                                       [row col]))\n        r (fn [s v]\n            (if (seq s)\n              (let [[row col] (first s)\n                    t (rest s)\n                    c (get-in v [row col])\n                    neighbs (neighbors row col)\n                    v' (assoc-in v [row col] \\M)\n                    s' (concat t neighbs)]\n                (if (= \\C c)\n                  true\n                  (if (= \\space c)\n                    (recur s' v')\n                    (recur t v))))\n              false))]\n    (r (neighbors mouse-row mouse-col) v)))","user":"52dfc89be4b09f7907dd1405"},{"code":"#(let [l %\n       G get-in\n       s (comp range count)\n       m (first\n           (for [i (s l)\n                 j (s (first l))\n                 :when (= \\M (G l [i j]))]\n             [i j]))]\n   (loop [l (mapv vec l) [m & r] [m]]\n     (cond\n       (= \\C (G l m)) true\n       (nil? m) false\n       (#{\\M \\ } (G l m)) (recur (assoc-in l m \\.)\n                                 (concat\n                                   (for [d [[-1 0] [1 0] [0 -1] [0 1]]\n                                         :let [n (map + m d)]\n                                         :when (#{\\C \\ } (G l n \\#))] n)\n                                   r))\n       :else (recur l r))))","problem":117,"user":"52b453b0e4b0c58976d9ad21"},{"code":"(fn [maze]\n    (let [find #((juxt quot rem) (.indexOf (apply str maze) %) (count (first maze)))\n          start (find \"M\")\n          end (find \"C\")]\n      (contains?\n       (some #(if (or (empty? (second %))\n                      (contains? (first %) start))\n                (first %))\n             (iterate (fn [[acc c]]\n                        (let [r (for [[x y] c\n                                      dx [-1 0 1]\n                                      dy [-1 0 1]\n                                      :let [new [(+ x dx) (+ y dy)]\n                                            v (get-in maze new)]\n                                      :when (and (or (= dx 0) (= dy 0)) v (not= \\# v) (not (acc new)))]\n                                  new)]\n                          [(into acc r) r]))\n                      [#{end} [end]]))\n       start)))","problem":117,"user":"507056b8e4b07bd6ad9b9f29"},{"problem":117,"code":"(fn [maze]\n        (let [width (count (first maze))\n              height (count maze)\n              indexed (apply hash-map (mapcat identity (keep-indexed\n                                                        (fn [rowi row]\n                                                          (mapcat identity (keep-indexed (fn [coli col]\n                                                                                           [[rowi coli] col]) row))) maze)))\n              inverted (clojure.set/map-invert indexed)\n              mouse (get inverted \\M)\n              legal (fn [[y x]] (and (>= y 0) (< y height)\n                                     (>= x 0) (< x width)))\n              moves (fn [pos] (map (fn [[y x] [yi xi]]\n                                     [(+ y yi) (+ x xi)])\n                                   [[-1 0] [0 -1] [0 1] [1 0]] (repeat pos)))\n              seen (atom #{})\n              navigate (fn navigate [pos]\n                         (some identity\n                               (for [[y x] (filter legal (moves pos))]\n                                 (when-not (get @seen [y x])\n                                   (let [val (get indexed [y x])]\n                                     (condp = val\n                                       \\# nil\n                                       \\C true\n                                       (do (swap! seen conj pos)\n                                           (navigate [y x]))))))))]\n          (= true (navigate mouse))))","user":"502873a8e4b01614d1633ff8"},{"problem":117,"code":"(fn\n   science-bitch ;jesse pinkman (c)\n   [s]\n   (let [mice-c \\M\n         cheese-c \\C\n         wall-c \\#\n         rows-count (count s)\n         columns-count (count (first s))\n         indexed-space (mapcat identity (map-indexed (fn [i1 v1] (map-indexed (fn [i2 v2] (vector v2 i1 i2)) v1)) (map seq s)))\n         broad (map (fn [[_ x y]] (vector x y)) (filter #(= (first %) wall-c) indexed-space))\n         mice (map (fn [[_ x y]] (vector x y)) (filter #(= (first %) mice-c) indexed-space))\n         cheese (first (map (fn [[_ x y]] (vector x y)) (filter #(= (first %) cheese-c) indexed-space)))\n         neighbours [[-1 0] [0 -1] [1 0] [0 1]]\n         get-neighbours (fn [current not-include] (filter (fn [[x y]] (and (> x -1) (> y -1) (< x rows-count) (< y columns-count) (nil? (some (fn [bv] (= bv [x y])) broad)) (nil? (some (fn [bv] (= bv [x y])) not-include)))) (map #(map + current %) neighbours)))]\n     ;body\n     (loop [m mice to-remove '()]\n       (let [nn (mapcat #(get-neighbours % to-remove) m)]\n       (if (= 0 (count nn))\n         (if (nil? (some #{cheese} m))\n           false\n           true)\n       (recur nn (into to-remove m)))))\n         ))","user":"56ab7578e4b03c432f18733d"},{"problem":117,"code":"(fn [maze]\n  (let [find-xy (fn [p?] (set (for [[y row] (map vector (range) maze)\n                                    [x ch] (map vector (range) (seq row))\n                                    :when (p? ch)]\n                                [x y])))\n        start (find-xy #{\\M})\n        can-go? (find-xy #{\\space \\C})\n        cheesy? (find-xy #{\\C})]\n    (loop [seen start todo (seq start)]\n      (if (empty? todo)\n        false  ;; never reached goal\n        (let [[[x y] & more-todo] todo\n              points (for [[dx dy] [[1 0] [0 1] [-1 0] [0 -1]]\n                           :let [next-pt [(+ x dx) (+ y dy)]]\n                           :when (not (seen next-pt))\n                           :when (can-go? next-pt)]\n                       next-pt)]\n          (or (when (some cheesy? points) true)\n              (recur (into seen points) (concat more-todo points))))))))","user":"4f5eda39e4b0030a34fb2b56"},{"problem":117,"code":"; slow but natural recursive solution\n(fn [ss]\n  (letfn [(solve [x y visited]\n            (when (not (visited [x y]))\n              (when-let [s (get-in ss [x y] nil)]\n                (cond (= s \\C) true\n                      (= s \\#) false\n                      :else (let [v (conj visited [x y])]\n                              (or (solve (inc x) y v)\n                                  (solve x (inc y) v)                                  \n                                  (solve x (dec y) v)\n                                  (solve (dec x) y v)))))))]\n    (let [[x0 y0] (first (for [x (range (count ss))\n                               y (range (count (ss x)))\n                               :when (= \\M (get-in ss [x y]))]\n                           [x y]))]\n      (true? (solve x0 y0 #{})))))","user":"53576356e4b04ce2eb3ed27a"},{"problem":117,"code":"(fn [maze]\n  (let [board (mapv #(mapv char %) maze)\n        rows (range (count maze))\n        cols (range (count (first maze)))\n        locate #(first (for [r rows c cols :when (= % (get-in board [r c]))] [r c]))\n        mouse  (locate \\M)\n        cheese (locate \\C)\n        all-moves (fn [cell] (mapv #(mapv + cell %) [[-1 0][1 0][0 1][0 -1]]))\n        legal? (fn [cell] (or (= cheese cell) (= \\space (get-in board cell))))\n        legal-moves (fn [cell] (filter legal? (all-moves cell)))\n        not-seen (fn [seen cells] (set (for [c cells :when (not (contains? seen c))] c)))\n        search (fn [cells seen]\n                 (cond\n                   (empty? cells) false\n                   (contains? cells cheese) true\n                   :else (recur \n                           (->> cells (mapcat legal-moves) set (not-seen seen))\n                           (apply conj seen cells))))]\n    (search #{mouse} #{})))","user":"55ecb2c0e4b0121d4835fdce"},{"problem":117,"code":"(fn [mz0]\n  (let [mz (vec (map vec mz0))\n       rows (count mz)\n       cols (count (first mz)) \n       mpos (first (filter #(= \\M (get-in mz %)) (for [r (range rows) c (range cols)] [r c]))) ]\n    (letfn [(ok [m [r c :as p]] ; return true when cheese found, otherwise a modified maze, progressively filled with #\n      (cond\n        (true? m) true\n        (or (< r 0) (>= r rows) (< c 0) (>= c cols)) m\n        (= (get-in m p) \\C) true\n        (= (get-in m p) \\#) m\n        :else (-> (assoc-in m p \\#) (ok [r (inc c)]) (ok [(inc r) c]) (ok [r (dec c)]) (ok [(dec r) c]) )))]\n      (true? (ok mz mpos)) )))","user":"5b919d9de4b0c0b3ffbd4a24"},{"code":"(fn [b]\n   (let [hei (count b)\n         wid (count (first b))\n         pass? (fn [i j]\n                 (if (or (< i 0) (< j 0) (>= i hei) (>= j wid))\n                   false\n                   (not (= (get-in b [i j]) \\#))))\n         p (apply\n            vector\n            (map\n             (fn [i]\n               (apply\n                vector\n                (map\n                 #(pass? i %)\n                 (range wid))))\n             (range hei)))\n         mi (first (filter #(.contains (nth b %) \"M\") (range hei)))\n         mj (.indexOf (nth b mi) \"M\")\n         ci (first (filter #(.contains (nth b %) \"C\") (range hei)))\n         cj (.indexOf (nth b ci) \"C\")]\n     ((fn bfs [cur v]\n        (let [np (set\n                  (filter\n                   #(get-in p %)\n                   (clojure.set/difference\n                    (set\n                     (apply\n                      concat\n                      (map #(list\n                             [(dec (first %1)) (second %1)]\n                             [(inc (first %1)) (second %1)]\n                             [(first %1) (dec (second %1))]\n                             [(first %1) (inc (second %1))])\n                           cur)))\n                    v)))]\n          (if (empty? np)\n            false\n            (if (np [ci cj])\n              true\n              (bfs np (clojure.set/union cur v))))\n          ))\n      #{[mi mj]} #{})))","problem":117,"user":"52586d24e4b0cb4875a45cb0"},{"problem":117,"code":"(fn [mz]\n  (let [mz (vec (map vec mz))\n        nr (count mz)\n        nc (count (mz 0))\n        ind (for [r (range nr) c (range nc)] [r c])\n\n        ; WTH, 4Clojure doesn't have update function?\n        update (fn [m k f x] (assoc m k (f (get m k) x)))\n\n        info (reduce #(update %1 (get-in mz %2) conj %2) {\\space #{}} ind)\n        M (first (info \\M))\n        q (info \\C)\n        valid (conj (info \\space) M)\n        mv [[-1 0] [ 0 -1] [ 0 1] [ 1 0]]\n        bfs (fn [[x & q] valid]\n              (cond\n                (= x M) true\n                (empty? x) false\n                :else \n                  (let [nei (map #(map + x %) mv)\n                        new-pos (filter valid nei)]\n                    (recur (concat q new-pos) (disj valid x)))))]\n    (bfs q valid)))","user":"5416b4a2e4b01498b1a71a01"},{"code":"(fn [m]\n  (let [\n      neigh (fn [[r c]] (map #(map + % [r c]) [[0 -1] [0 1] [-1 0] [1 0]]))\n      idx (time (for [r (range (count m)) \n                c (range (count (first m)))] \n            [r c]))\n      {[M] \\M [C] \\C S \\space} (time (group-by #(get-in m %) idx))] \n    (loop [curr #{M} space (set (conj S C))]\n      (cond\n        (curr C) true\n        (empty? curr) false\n        :else \n          (let [\n              neigh1 (set (mapcat neigh curr))\n              curr1 (clojure.set/select neigh1 space)\n              space1 (clojure.set/difference space curr1)]\n            (recur curr1 space1))))))","problem":117,"user":"4f991ec1e4b0dcca54ed6cfb"},{"problem":117,"code":"; In this solution we build field of 3x3 blocks ('bks'), in the center of each one is the cell of the original board.\n; In order to do so we firstly wrap the original with \\# symbols at each edge and get the wrapped board 'be'.\n\n; Then we flatten each block and get the center at index 4 and neighbors at positions 1, 3, 5, 7 (range 1 8 2).\n\n; Then we update the center of each block if it has \\M neighbor and is not \\# and return updated board until it has \\C cell\n; or cannot be updated anymore.\n\n;(fn [b] \n;  (let [fe\t#(concat [%2] % [%2])\n;        be0\t(map #(fe % \\#) b)\n;        be\t(#(fe % (take (count (first %)) (repeat \\#))) be0)\t\n;        fp\t#(partition 3 1 %)\n;        bks\t(map #(apply map list (map fp %)) (fp be))\n;        fsm\t#(hash-map :c (nth % 4) \n;                       :s (set (map (partial nth %) (range 1 8 2)))) \n;        fmc\t(fn [{c :c s :s}] (if (and (not= c \\#) (get s \\M)) \\M c))\n;        nb\t(map #(map (comp fmc fsm flatten) %) bks)]\n;      (if (= b nb) false \n;          (if (every? #(not= \\C %) (flatten nb)) true (recur nb)))))\n\n; The remake of the Chouser's great solution\n(fn fr [f b] (#(if ((set (apply concat b)) \\C)\n                   (and (not= % b) (fr f %)) true)\t\n               (f (f b))))\n(fn [b] (apply map str (map #(.replaceAll % \"MC|CM|M | M\" \"MM\") b)))","user":"575ddfd1e4b02ea11479938d"},{"problem":117,"code":"(fn solvable? [maze]\n  (let [maze' (vec (map vec maze))\n        getPos (fn [c]\n                 (loop [m (seq maze) row 0]\n                   (if (empty? m) \n                     [-1 -1]\n                     (let [col (.indexOf (first m) c)]\n                       (if (= -1 col)\n                         (recur (rest m) (inc row))\n                         [row col])))))\n        adj (fn [[r c]]\n              (let [deltas [[-1 0] [1 0] [0 -1] [0 1]]]\n                (for [[dr dc] deltas :when (not= \\# (get-in maze' [(+ r dr) (+ c dc)] \\#))]\n                  [(+ r dr) (+ c dc)])))\n        mouse (getPos \"M\")\n        cheese (getPos \"C\")]\n    (loop [found #{mouse}]\n      (let [found' (into found (mapcat adj found))]\n        (cond\n          (contains? found' cheese) true\n          (= (count found) (count found')) false\n          :else (recur found'))))))","user":"559454f2e4b0c79f6e1db952"},{"code":"(fn fs [board]\n  (let [board-points (let [s (count board)]\n                        (map vec\n                          (for [x (range s)\n                                y (range (count (first board)))]\n                            [x y])))\n        travel-point? (fn travel-point? [point]\n                        (if (not= \\# (get-in board point))\n                          true\n                          false))\n        travel-points (set (filter travel-point? board-points))\n        neighbor (fn neighbor [[x y]]\n                   (apply clojure.set/union (for [d [-1 1]]\n                                   #{[x (+ y d)] [(+ x d) y]})))\n        mouse (first (filter #(if (= \\M (get-in board %)) true) board-points))\n        cheese (first (filter #(if (= \\C (get-in board %)) true) board-points))\n        ]\n    (loop [travel #{mouse}\n           old #{}]\n      (if (travel cheese)\n        true\n        (if (= travel old)\n          false\n          (recur (clojure.set/intersection travel-points (apply clojure.set/union travel (map neighbor travel))) travel))))))","problem":117,"user":"5123ac8ee4b061b4c6f0e0b1"},{"code":"(fn f [m]\n  (let [rows (count m)\n        cols (count (first m))\n        pos-m (first (for [i (range rows) j (range cols) :when (= \\M ((vec (m i)) j))] [i j]))\n        pos-c (first (for [i (range rows) j (range cols) :when (= \\C ((vec (m i)) j))] [i j]))\n        locs (fn [[i j]] [[(dec i) j][i (dec j)][i (inc j)][(inc i) j]])\n        step (fn [[i j]] (for [l (locs [i j]) :when (some #{\\space \\C} (list (get-in m l)))] l))]\n    (loop [ret (set (step pos-m))\n           visited #{}]\n      (cond (empty? ret) false\n            (some #{pos-c} ret) true\n            (clojure.set/subset? ret visited) false\n            :else (recur (set (mapcat step ret)) (set (concat visited ret)))))))","problem":117,"user":"50733b31e4b0e3170b5a869a"},{"code":"(fn [maze]\n  (let [W (count (first maze))\n        H (count maze)\n        start-idx (first (for [j (range H)\n                               i (range W)\n                               :when (= \\M (get-in maze [j i]))]\n                           [j i]))]\n    (true?\n      ((fn f [[[j i :as cur] & to-visit] been-to]\n         (cond (nil? cur) false\n               (= \\C (get-in maze cur)) true\n               (or (= \\# (get-in maze cur))\n                   (nil? (get-in maze cur))\n                   (been-to cur)) (f to-visit been-to)\n               :else (let [to-visit (concat to-visit\n                                            (for [[dj di] [[0 1] [1 0] [0 -1] [-1 0]]]\n                                              [(+ j dj) (+ i di)]))\n                           been-to (conj been-to cur)]\n                       (f to-visit been-to))))\n       [start-idx] #{}))))","problem":117,"user":"510acd6ee4b078ea719210f4"},{"problem":117,"code":"(fn path?\n   [g]\n   (let [r (count g)\n         c (count (first g))]\n     (letfn [(loc [ch g]\n               (let [ps (for [x (range r)\n                              y (range c)]\n                          [x y])]\n                 (loop [ps ps]\n                   (let [[x y] (first ps)]\n                     (if (= ch (nth (nth g x) y))\n                       [x y]\n                       (recur (rest ps)))))))\n             (find-path\n               [[x y] a-g]\n               (condp = (nth (nth @a-g x) y)\n                 \\C true\n                 \\# false\n                 (do\n                   (swap! a-g assoc-in [x y] \\#)\n                   (some true?\n                         (map #(find-path % a-g)\n                              (keep\n                                (fn [[dx dy]]\n                                  (let [nx (+ x dx)\n                                        ny (+ y dy)]\n                                    (if (and\n                                          (>= nx 0) (< nx r)\n                                          (>= ny 0) (< ny c))\n                                      [nx ny])))\n                                [[-1 0] [1 0]\n                                 [0 -1] [0 1]]))))))]\n       (true?\n         (find-path (loc \\M g)\n                    (atom (vec (map vec g))))))))","user":"56a36f76e4b0542e1f8d14ca"},{"code":"(fn [maze]\n  (let [\n    height (count maze) \n    width (count (maze 0))\n    locate (fn [ch]\n      (loop [y 0 x 0]\n        (cond\n          (= y height) nil\n          (= x width) (recur (inc y) 0)\n          (= ch (get-in maze [y x])) [y x]\n          :else (recur y (inc x)))))\n    cheese-pt (locate \\C)]\n  (letfn [\n    (valid-location? [[y x]]\n      (and \n        (>= y 0) (< y height) \n        (>= x 0) (< x width)\n        (not= \\# (get-in maze [y x])))) \n    (moves [[y x]]\n      (filter valid-location?\n        (list [(dec y) x] [(inc y) x] [y (dec x)] [y (inc x)])))]\n    (loop [pt (locate \\M) front '() seen #{pt}]\n      (if\n        (= cheese-pt pt) true\n        (let [new-front (concat front (remove seen (moves pt)))]\n          (if\n            (empty? new-front) false\n            (recur (first new-front) (rest new-front) (conj seen pt)))))))))","problem":117,"user":"4f050dec535dcb61093f6bef"},{"problem":117,"code":"(fn [x]\n(let [input (vec (map  #(vec (re-seq  #\"[\\#\\sMC]\" %)) x)) h (count input) w (count (input 0))]\n(letfn [\n;\n(md [x y] (if (= y 0) x (- (dec y) x)))\n;\n(nbrs\n([yx] (nbrs [[-1 0] [1 0] [0 -1] [0 1]] h w yx))\n([deltas h w yx]\n(filter (fn [new-yx]\n(and (< -1 (first new-yx) h) (< -1 (second new-yx) w) ))\n(map #(map + yx %) deltas))))\n;\n(vle [mat [x y]] ((mat x) y))\n;\n(udate [mat [x y]]\n(let [v (vle mat [x y]) nm (filter (fn [u] (= \"M\" (vle mat u))) (nbrs [x y])) nc (filter (fn [u] (= \"C\" (vle mat u))) (nbrs [x y]))]\n(if (= \" \" v)\n    (cond (and (not (empty? nm))  (not (empty? nc))) [true false false]\n    \t  (not (empty? nm)) [(assoc mat x (assoc (mat x) y \"M\")) true false]\n\t  (not (empty? nc)) [(assoc mat x (assoc (mat x) y \"C\")) false true]\n\t  :else [mat false false]\n    )  [mat false false] \n) ))\n]\n(loop [i 0 maze [input false false] mi 0 mj 0]\n(if (= true (maze 0)) true\n(if (= i h) (if (not (and (maze 1) (maze 2))) false\n      \t      \t       \t    (let [mz [(maze 0) false false]]\n\t\t\t    \t     \t       (cond  (and (= 0 mi) (= 0 mj)) (recur 0 mz 0 w)\n\t\t\t    \t     \t       \t      (= 0 mi) \t       \t      (recur 0 mz h 0)\n\t\t\t    \t     \t              (= 0 mj) \t\t      (recur 0 mz h w)\n\t\t\t\t\t\t      :else \t\t      (recur 0 mz 0 0)\n\t\t\t\t\t       )\n\t\t\t     )\n      \t      )\n    (recur (inc i)\n     (loop [j 0 mazee maze]\n     (if (= true (mazee 0)) [true false false]\n    \t   \t   \t (if (= j w) mazee\n\t\t\t     \t     (let [mz (udate (mazee 0) [(md i mi) (md j mj)])]\n\t\t\t\t      (recur (inc j) [(mz 0) (or (mazee 1) (mz 1)) (or (mazee 2) (mz 2))])\n\t\t\t\t     )\n\t\t\t )\n     ))\n    mi mj)\n)))\n)))","user":"5be6d0f8e4b0f319e2d7ec51"},{"code":"(fn for-sc [maze]\r\n  (let \r\n    [width (count (first maze))\r\n     height (count maze)\r\n     catted (apply concat maze)\r\n     indexed (map-indexed\r\n               (fn [idx x] \r\n                 (when (not= x \\#) (if (= x \\space) idx x)))\r\n               catted)\r\n     idx-maze (partition width indexed)\r\n     get-row-edges (fn [mz]\r\n                     (filter\r\n                       #(every? identity %)\r\n                       (partition 2 1 \r\n                                  (apply concat\r\n                                         (interpose nil mz)))))\r\n     transposed (apply map vector idx-maze)\r\n     \r\n     d-edges (into #{} (concat \r\n            (get-row-edges idx-maze)\r\n            (get-row-edges transposed)))\r\n     edges (into d-edges (map (fn [[a b]] [b a])\r\n                              d-edges))\r\n     graph-search (fn gs [e origin goal]\r\n                   (loop [visited #{origin}]\r\n                     (let\r\n                       [n-edges (filter (fn [[a b]]\r\n                                          (visited a))\r\n                                        e)\r\n                        n-nodes (map second n-edges)\r\n                        new-visited (into visited n-nodes)\r\n                        ]\r\n                       (if (= (count visited) (count new-visited))\r\n                              (visited goal)\r\n                              (recur new-visited)))))\r\n     ]\r\n    (boolean (graph-search edges \\M \\C))\r\n    ;edges\r\n    ;(get-row-edges idx-maze)\r\n    \r\n                   \r\n    ))","problem":117,"user":"502a9fdee4b095a7adb898b4"},{"problem":117,"code":"(fn mazeX[t]\n\t(letfn \n\t\t[\n\n\t\t\t(cell [t coor]\n\t\t\t\t(let [\n\t\t\t\t\ty (:y coor)\n\t\t\t\t\tx (:x coor)\n\t\t\t\t\t]\n\t\t\t\t\t(get (get t y) x)\n\t\t\t\t)\n\t\t\t)\n\n\n\n\t\t\t(isCell [t c coor]\n\t\t\t\t (= (cell t coor) c)\n\t\t\t)\n\n\t\t\t(isWall [t coor]\n\t\t\t\t (isCell t \\# coor)\n\t\t\t)\n\n\n\t\t\t(makeCoor[y x]\n\t\t\t\t{ :y y :x x}\n\t\t\t)\n\n\t\t\t(findC[t rows columns c]\n\t\t\t\t(let [ \n\t\t\t\t\tallCells (for [x (range columns) y (range rows)] (makeCoor y x))\n\t\t\t\t\t]\n\t\t\t\t\t(first (filter #(isCell t c %) allCells))\n\t\t\t\t)\n\t\t\t)\n\n\t\t\t(findMouse[t rows columns]\n\t\t\t\t(findC t rows columns \\M)\n\t\t\t)\n\n\t\t\t(findCheese[t rows columns]\n\t\t\t\t(findC t rows columns \\C)\n\t\t\t)\n\n\t\t\t(coorValid[rows columns coor]\n\t\t\t\t(let [\n\t\t\t\ty (:y coor)\n\t\t\t\tx (:x coor)\n\t\t\t\t]\n\t\t\t\t\t(and (>= y 0) (>= x 0) (< y rows)(< x columns))\n\t\t\t\t)\n\t\t\t)\n\n\t\t\t(goRight[coor]\n\t\t\t\t(assoc coor :x (inc (:x coor)))\n\t\t\t)\n\n\t\t\t(goLeft[coor]\n\t\t\t\t(assoc coor :x (dec (:x coor)))\n\t\t\t)\n\n\t\t\t(goUp[coor]\n\t\t\t\t(assoc coor :y (dec (:y coor)))\n\t\t\t)\n\n\t\t\t(goDown[coor]\n\t\t\t\t(assoc coor :y (inc (:y coor)))\n\t\t\t)\n\n\n\t\t\t(mazePathRec[t rows columns coorC coorM visited]\n\t\t\t\t(cond \n\t\t\t\t\t(contains? visited coorM) {:res false :vis visited}\n\t\t\t\t\t(isWall t coorM) {:res false :vis visited}\n\t\t\t\t\t(not (coorValid rows columns coorM)) {:res false :vis visited}\n\t\t\t\t\t(= coorM coorC) {:res true :vis visited}\n\t\t\t\t\t:else (let [\n\t\t\t\t\t\t\tnewVisited (conj visited coorM)\n\t\t\t\t\t\t\tgoneRight (mazePathRec t rows columns coorC (goRight coorM) newVisited)\n\t\t\t\t\t\t\tgoneLeft (mazePathRec t rows columns coorC (goLeft coorM) (:vis goneRight))\n\t\t\t\t\t\t\tgoneUp (mazePathRec t rows columns coorC (goUp coorM)(:vis goneLeft))\n\t\t\t\t\t\t\tgoneDown (mazePathRec t rows columns coorC (goDown coorM)(:vis goneUp))\n\n\t\t\t\t\t\t] \n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t:res (or (:res goneRight) (:res goneLeft) (:res goneUp) (:res goneDown))\n\t\t\t\t\t\t\t\t:vis (:vis goneDown) \n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t)\n\t\t\t\t\t\n\t\t\t\t)\n\t\t\t)\n\n\t\t]\n\t\t(let [\n\t\t\trows (count t) \n\t\t\tcolumns (count (get t 0))\n\t\t\t]\n\t\t\t(:res (mazePathRec t rows columns (findCheese t rows columns) (findMouse t rows columns) #{}))\n\t\t)\n\t)\t\n)","user":"568820e8e4b0dcc4269f4067"},{"problem":117,"code":";; probably would be faster with a mutable table but I wanted to try a functional solution\n(fn path-to-cheese [board-input]\n  (let [board (->> (map seq board-input)\n                   (map-indexed (fn [i row] (map-indexed (fn [j v] {:i i :j j :v v}) row)))\n                   (mapv #(into [] %)))\n        [m0 n0] [(dec (count board)) (dec (count (first board)))]\n        board-at (fn [i j]\n                   (when (and (<= 0 i m0) (<= 0 j n0))\n                     (nth (nth board i) j)))\n        u #(when % (board-at (dec (% :i)) (% :j)))\n        d #(when % (board-at (inc (% :i)) (% :j)))\n        l #(when % (board-at (% :i) (dec (% :j))))\n        r #(when % (board-at (% :i) (inc (% :j))))\n        valid? (fn [p]\n                 (when p\n                   (or (= (p :v) \\C)\n                       (= (p :v) \\space))))\n        adjacent (fn [p]\n                   (filter valid? [(u p) (d p) (l p) (r p)]))\n        within? (fn [p ps]\n                  (some #(and (= (% :i) (p :i))\n                              (= (% :j) (p :j))) ps))\n        advance (fn [b ps]\n                  (let [ps' (distinct (mapcat adjacent ps))\n                        b' (mapv (partial mapv #(if (within? % ps') (assoc % :v \\X) %)) b)]\n                    (cond (some #(= (% :v) \\C) ps') true\n                          (= b b') false\n                          :else (recur b' ps'))))]\n    (->> (flatten board)\n         (some #(if (= (% :v) \\M) % false))\n         list\n         (advance board))))","user":"5666500ee4b0e91d5f5c566d"},{"problem":117,"code":"(fn [m]\n  (letfn [(at [m i j]\n            (get-in m [i j]))\n\n          (find-cheese [m]\n            (first\n              (for [i (range (count m))\n                    j (range (count (first m)))\n                    :when (= \\C (at m i j))]\n                [i j])))\n\n          (next-moves [m [i j]]\n            (for [[x y] [[(dec i) j]\n                         [i (dec j)]\n                         [(inc i) j]\n                         [i (inc j)]]\n                  :when (and (>= x 0)\n                             (>= y 0)\n                             (< x (count m))\n                             (< y (count (first m)))\n                             (not= \\# (at m x y))\n                             (not= \\. (at m x y)))]\n              [x y]))]\n    (loop [m (mapv vec m)\n           moves (vec (next-moves m (find-cheese m)))]\n      (if (empty? moves)\n        false\n        (let [move (first moves)\n              mo-moves (subvec moves 1)\n              here (get-in m move)]\n          (if (= \\M here)\n            true\n            (if (= \\. here)\n              (recur m mo-moves)\n              (let [new-m (assoc-in m move \\.)\n                    next-moves (next-moves new-m move)\n                    new-moves (if (empty? next-moves)\n                                mo-moves\n                                (apply conj mo-moves next-moves))]\n                (recur new-m new-moves)))))))))","user":"4ec1b090535dfed6da9c6db5"},{"problem":117,"code":"(fn p117 [b]\n  (let [board-width (count (first b))\n        board-length (count b)\n        board (for [x (range board-length) y (range board-width)] [x y])\n        board-map (zipmap board (->> b (apply str) vec))]\n     (loop [board-map board-map]\n       (let [m-coords (map first (filter #(= \\M (val %)) board-map))\n             m-neighbors (apply concat (for [cursor m-coords] \n                                  (filter (fn [[k v]] \n                                            (and (or (= (first k) (first cursor)) \n                                                     (= (last k) (last cursor)))\n                                                 (contains? #{-1 1} \n                                                   (- (+ (first cursor) (last cursor)) \n                                                      (+ (first k) (last k)))))) board-map)))\n             ok-neighbor-coords (keys (filter #(contains? #{\\space \\C} (val %)) m-neighbors))\n             is-c? (contains? (set (map #(board-map %) ok-neighbor-coords)) \\C)\n             num-spaces ((frequencies (map #(board-map %) ok-neighbor-coords)) \\space)] \n         (cond (true? is-c?) true \n               (nil? num-spaces) false\n               :else (recur (merge board-map (zipmap ok-neighbor-coords (repeat (count ok-neighbor-coords) \\M)))))))))","user":"525c575be4b0cb4875a45d38"},{"problem":117,"code":"(fn solvable? [maze]\n  (let [[mouse-pos] (for [row (range (count maze))\n                          col (range (count (nth maze row)))\n                          :when (= \\M (get-in maze [row col]))]\n                      [row col])]\n    (loop [visited  #{mouse-pos}\n           frontier [mouse-pos]]\n      (let [candidates (mapcat (fn [[r c]]\n                                 (->> (map #(vector (+ r %1) (+ c %2)) [-1 0 0 1] [0 -1 1 0])\n                                      (filter #(get-in maze %))\n                                      (remove visited)\n                                      (remove #(#{\\#} (get-in maze %)))))\n                               frontier)]\n        (if (seq candidates)\n          (if (some #{\\C} (map #(get-in maze %) candidates))\n            true\n            (recur (into #{} (concat visited candidates)) candidates))\n          false)))))","user":"4f5599dfe4b0a7574ea71806"},{"problem":117,"code":"(fn mice-maze\n  ([maze]\n   (letfn [(find-char\n             [maze char]\n             (some identity (apply concat (map-indexed (fn [idx row]\n                                                         (map-indexed\n                                                          (fn [idy field] (if (= field char)\n                                                                            [idx idy]\n                                                                            false))\n                                                          row)) maze))))\n\n           (valid-field?\n             [maze x y]\n             (let [value (get-in maze [x y])]\n               (not (or (nil? value) (= \\# value)))))\n\n           (walled-in?\n             [maze x y]\n             (not\n              (boolean\n               (some true? [(valid-field? maze (inc x) y)\n                            (valid-field? maze x (inc y))\n                            (valid-field? maze (dec x) y)\n                            (valid-field? maze x (dec y))]))))]\n     (let [row-c    (count maze)\n           column-c (count (first maze))\n           start    (find-char maze \\M)\n           goal     (find-char maze \\C)]\n\n       (boolean\n        (when-not (apply walled-in? maze goal)\n          (mice-maze maze #{} start row-c column-c))))))\n  \n  ([maze visited [x y :as cords] row-c column-c]\n   (let [value (get-in maze [x y])]\n     (cond\n       (or (visited [x y]) (nil? value) (= \\# value))\n       false\n\n       (= value \\C)\n       true\n\n       :else\n       (boolean (some true? [(mice-maze maze (conj visited cords) [(inc x) y] row-c column-c)\n                             (mice-maze maze (conj visited cords) [x (inc y)] row-c column-c)\n                             (mice-maze maze (conj visited cords) [(dec x) y] row-c column-c)\n                             (mice-maze maze (conj visited cords) [x (dec y)] row-c column-c)]))))))","user":"5b759ca8e4b047b03b2036d0"},{"code":"(fn [maze]\n  (let [h (count maze)\n        w (count (first maze))\n        moves  {:left  [0 -1]\n                :up    [-1 0]\n                :right [0  1]\n                :down  [1  0]}\n        dirs (cycle [:down :left :up :right])\n        valid? #(let [v (get-in maze %)]\n                  (and v (not= v \\#)))\n        get-pos #(first (for [i (range h) j (range w)\n                                 :when (= % (get-in maze [i j]))] [i j]))\n        next-dir #(loop [c dirs]\n                    (if (= (second c) %) (take 4 c)\n                      (recur (drop 1 c))))\n        next-pos (fn [pos dir]\n                   (->> (next-dir dir)\n                        (map #(vector (map + pos (moves %)) %))\n                        (filter #(valid? (first %)))\n                        first))\n        init (get-pos \\M)]\n      (loop [cur init\n             dir :up]\n             (let [[nxt ndir] (next-pos cur dir)]\n               (cond (or (nil? nxt) (= nxt init))\n                       false\n                     (= \\C (get-in maze nxt))\n                       true\n                     :else (recur nxt ndir))))))","problem":117,"user":"4f58d92fe4b0a7574ea71858"},{"problem":117,"code":"(fn [maze]\n    (let [maze-height (count maze)\n          maze-width (count (first maze))]\n      (letfn [(look [[y x]]\n                (get-in maze [y x]))\n              (north [[y x]]\n                [(dec y) x])\n              (south [[y x]]\n                [(inc y) x])\n              (east [[y x]]\n                [y (inc x)])\n              (west [[y x]]\n                [y (dec x)])\n              (on-map? [location]\n                (boolean (look location)))\n              (floor? [location]\n                (not= \\# (look location)))\n              (mouse? [location]\n                (= \\M (look location)))\n              (cheese? [location]\n                (= \\C (look location)))\n              (search-with [pred]\n                (first (for [y (range maze-height)\n                             x (range maze-width)\n                             :when (pred [y x])]\n                         [y x])))]\n        (let [mouse (search-with mouse?)\n              cheese (search-with cheese?)]\n          (letfn [(moves [used-locations mouse]\n                    (->> (map #(% mouse) [north south east west])\n                         (filter (complement used-locations))\n                         (filter on-map?)\n                         (filter #(or (floor? %) (cheese? %)))))]\n            (loop [used #{mouse}]\n              (let [wavefront (into used (mapcat #(moves used %) used))]\n                (cond (wavefront cheese) true\n                      (= wavefront used) false\n                      :else (recur wavefront)))))))))","user":"5d236215e4b02ea6f0fb6a09"},{"code":"(fn [C R M b]\n  (let [h (C b) w (C (first b))\n        f #(first (for [y (R h) x (R w) :when (= (get-in b [y x]) %)] [y x]))\n        m (f \\M) c (f \\C)]\n    (loop [p #{m} s #{m}]\n      (if (s c)\n        true\n        (if-let [n (seq (mapcat #(remove s (filter (fn [[y x]]\n                                                     (and (< -1 y h) (< -1 x w)\n                                                          (#{\\  \\C} (get-in b [y x]))))\n                                                   (M (fn [d] (M + % d)) [[0 1] [1 0] [0 -1] [-1 0]]))) p))]\n          (recur (set n) (apply conj s n))\n          false)))))\ncount range map","problem":117,"user":"4e52d815535d302ef430da77"},{"code":"(fn forscience [coll]\n  (let [w (count (first coll)) h (count coll)\n        m' (map-indexed #(vec [%1 %2]) (reduce str (flatten coll)))\n        m'' (filter #(not= \\# (second %)) m')\n        M (ffirst ((group-by second m'') \\M))\n        C (ffirst ((group-by second m'') \\C))\n        vs (set (map first m''))\n        nbrs (fn [v]\n               (let [n #{(- v w) (inc v) (+ v w) (dec v)}]\n                 (filter vs n)))\n        walk (fn add-vertex [s v]\n               (if (s v) s (reduce add-vertex (conj s v) (nbrs v))))\n        connected? #(let [w (walk #{} M)]\n                      (contains? w C))]\n    ;;[M C (nbrs M) (nbrs C) (connected?)]\n    (connected?)))","problem":117,"user":"52140b53e4b0961f15ac4d7e"},{"problem":117,"code":"(fn [maze]\n  (let [rows (range (count maze))\n        cols (range (count (first maze)))\n        indices (set (for [i rows j cols] (vector i j)))\n        entry (fn [ij] (get (get maze (first ij)) (second ij)))\n        wall (set (filter #(= (entry %) \\#) indices))\n        mouse (set (filter #(= (entry %) \\M) indices))\n        cheese (first (filter #(= (entry %) \\C) indices))\n        adjacent (fn [a b] (<= (+ (Math/abs (- (first a) (first b))) (Math/abs (- (second a) (second b)))) 1))\n        adjacent-to-set (fn [blob x] (or (contains? blob x) (some #(adjacent x %) blob)))\n        expand-set (fn [blob] (set (filter #(adjacent-to-set blob %) indices)))]\n    (loop [mice mouse]\n      (if (contains? mice cheese)\n        true\n        (let [more-mice (clojure.set/difference (expand-set mice) wall)]\n          (if (= mice more-mice)\n            false\n            (recur more-mice)))))))","user":"58a0fc33e4b02bd94d917ea3"},{"problem":117,"code":"(fn [maze]\n  (let [mouse \\M cheese \\C\n        get-loc (fn [obj]\n                  (->> maze\n                       (map (partial keep-indexed #(if (= obj %2) %1)))\n                       (keep-indexed #(map (partial conj [%1]) %2))\n                       (apply concat)))\n        find-loc #(get-in maze % \\#)\n        moves (fn [[y x]] [[(inc y) x]\n                          [y (inc x)]\n                          [(dec y) x]\n                          [y (dec x)]])\n        explore\n        (fn [candidates visited]\n          (if (empty? candidates)\n            visited\n            (let [visited (distinct (concat visited candidates))\n                  candidates (->> candidates\n                                  (map moves)\n                                  (apply concat)\n                                  distinct\n                                  (filter #(not= \\# (find-loc %)))\n                                  (filter #(not (.contains visited %))))]\n              (recur candidates visited))))]\n    (.contains (explore (get-loc mouse) '())\n               (first (get-loc cheese)))))","user":"54c5cc17e4b045293a27f624"},{"problem":117,"code":"(fn [board]\n  (let [board-atom (atom (vec (map vec board)))\n        cheese-found (atom false)\n        enumerate (partial map-indexed vector)\n        mouse-cell (first (for [[x row] (enumerate board)\n                                [y cell] (enumerate row)\n                                :when (= cell \\M)]\n                            [x y]))\n        cheese \\C\n        wall \\#\n        visited \\.]\n    (letfn [(visit [cell]\n              (swap! board-atom #(assoc-in % cell visited)))\n            (up [[x y]]\n              [x (dec y)])\n            (left [[x y]]\n              [(dec x) y])\n            (right [[x y]]\n              [(inc x) y])\n            (down [[x y]]\n              [x (inc y)])\n            (flood-fill [cell]\n              (let [node (get-in @board-atom cell)]\n                (cond\n                  (or (nil? node)\n                      (= node visited)\n                      (= node wall)\n                      @cheese-found) false\n                  (= node cheese) (swap! cheese-found not)\n                  :else (do (visit cell)\n                            (or (flood-fill (up cell))\n                                (flood-fill (left cell))\n                                (flood-fill (right cell))\n                                (flood-fill (down cell)))))))]\n      (flood-fill mouse-cell))\n    ))","user":"57f0f7b8e4b0bfb2137f5bfe"},{"code":"(fn g [b]\n  (let [Mi (map first (filter #(= \\M (second %)) (map-indexed vector (apply str b))))\n        Mi (map #(vector (int (/ % (count (first b)))) (mod % (count (first b)))) Mi)\n        ne (fn [[y x]] (let [mi [y x]\n                             mu (when (pos? y)                      [(dec y) x])\n                             md (when (< y (dec (count b)))         [(inc y) x])\n                             ml (when (pos? x)                      [y (dec x)])\n                             mr (when (< x (dec (count (first b)))) [y (inc x)])]\n                         (filter vector? [mi mu md ml mr])))\n        Ma (set (reduce into [] (map ne Mi)))\n        Mn (clojure.set/difference Ma Mi)\n        Mn (filter #(not= \\# (get-in b %)) Mn)]\n    (if (some #{\\C} (map #(get-in b %) Mn))\n      true\n      (if (empty? Mn)\n        false\n        (g (assoc b (first (first Mn))\n                    (apply str (assoc (vec (seq (get b (first (first Mn))))) (second (first Mn)) \\M))))))))","problem":117,"user":"4e49badd535dc968683fc4c9"},{"problem":117,"code":"(fn winnable? [maze]\n  (let [index-of (fn index-of [str val]\n                   (loop [i 0 str str]\n                     (cond\n                       (empty? str) nil\n                       (= (first str) val) i\n                       :else (recur (inc i) (rest str)))))\n\n        initial-mouse-location (some identity (map-indexed\n                                               (fn [y, str]\n                                                 (let [x (index-of str \\M)]\n                                                   (if-not (nil? x) [x y] nil))) maze))\n        search-maze (fn search-maze [[x y] visited]\n                      (let [val (get-in maze [y x])]\n                        (cond (contains? visited [x y]) false\n                              (= val \\C) true\n                              (= val \\#) false\n                              (= val nil) false\n                              :else (let [visited (conj visited [x y])\n                                          next-steps [[x (inc y)] ; down\n                                                      [x (dec y)] ; up\n                                                      [(dec x) y] ; left\n                                                      [(inc x) y] ; right\n                                                      ]]\n                                      (->>\n                                       (map (fn [step] [step (filter #(not= step %) next-steps)]) next-steps)\n                                       (some (fn [[step already-visited]] (search-maze step (apply conj visited already-visited))))\n                                       (boolean))))))]\n\n    (search-maze initial-mouse-location #{})))","user":"5ea6fe98e4b00a66d4a951b2"},{"problem":117,"code":"(fn life2[ m ]\n  (let [maze       (into {} (for [[x row] (map-indexed vector m)\n                            [y val] (map-indexed vector row)]\n                            {[x y] val}))\n        validnode? (fn[n] (let [val (maze n)] (contains? #{\\space \\C} val)))\n        init       (key (first (filter #(= \\M (val %)) maze)))\n        visited    (atom #{init})\n        neighbours (fn [node ]\n                     (let [x (first node) y (last node)\n                           alln (vector [(+ x 1) y] [x (+ y 1)]\n                                        [(- x 1) y] [x (- y 1)])]\n                       (->> alln\n                            (filter validnode?)\n                            (filter #(not-any? (partial = %) @visited)))))\n        mychildren (fn[n] (let [c (neighbours n)] (swap! visited into c) c))\n        mybranch? (comp not empty? (fnil neighbours '()))\n        path      (tree-seq mybranch? mychildren init)\n        route     (mapv #(maze %) path) ]\n    (contains? (into #{} route) \\C)\n))","user":"52f426fce4b05e3f0be25f1e"},{"problem":117,"code":"(fn [b]\n    (let [[x y] (->> b (map #(vector % (.indexOf %2 \"M\")) (range))\n                     (filter (fn [[_ m]] (not= -1 m))) first)\n          seen (transient #{})]\n      (true?\n       ((fn step [x y]\n          (let [s (get (get b x) y)]\n            (when (and s (not= s \\#) (not (seen [x y])))\n              (conj! seen [x y])\n              (if (= s \\C) true\n                  (some true? (list (step (inc x) y)\n                                    (step (dec x) y)\n                                    (step x (dec y))\n                                    (step x (inc y))))))))\n        x y))))","user":"4f57c913e4b0a7574ea7183f"},{"problem":117,"code":"(fn [maze]\n  (letfn\n    [(locs [where object ind]\n           (keep-indexed #(when (= object %2)\n                            [ind %1])\n                         where))\n     (all-locs [where ind]\n               (map #(locs where % ind) [\\M \\C \\ ]))\n     (maze-locs [maze]\n                (->> (for [ind (range (count maze))]\n                       (all-locs (get maze ind) ind))\n                     (apply map concat)\n                     (map set)))\n     (legal-loc? [[r c] [rs cs]]\n                  (and (< -1 r rs)\n                       (< -1 c cs)))\n     (next-locs [current-loc limits unvisited]\n                (->> (map #(map + % current-loc)\n                          [[0 1] [1 0] [0 -1] [-1 0]])\n                     (map vec)\n                     (filter #(legal-loc? % limits))\n                     (filter unvisited)))\n     (connected-cheese [cheese-loc limits unvisited]\n       (seq (next-locs cheese-loc limits unvisited)))\n     (maze-solver [maze]\n                  (let [maze-locs (maze-locs maze)\n                        init-mouse (ffirst maze-locs)\n                        cheese (first (second maze-locs))\n                        unvisited (conj (last maze-locs) cheese)\n                        limits [(count maze)\n                                (count (first maze))]]\n                    (letfn [(reach-cheese?\n                             ([current-unvisited]\n                              (reach-cheese? init-mouse current-unvisited))\n                             ([current-mouse-loc current-unvisited]\n                              (or (= cheese current-mouse-loc)\n                                  (when-let [possible-next-locs\n                                             (seq (next-locs current-mouse-loc\n                                                             limits\n                                                             current-unvisited))]\n                                    (some (fn [next-loc]\n                                            (reach-cheese? next-loc\n                                                           (disj current-unvisited next-loc)))\n                                          possible-next-locs)))))]\n                      (when (connected-cheese cheese limits unvisited)\n                        (reach-cheese? unvisited)))))]\n    (boolean (maze-solver maze))))","user":"54848141e4b0e286459a119e"},{"problem":117,"code":"(fn [m]\n  (let [m' (mapv #(vec %) m)\n        moves [[0 -1] [0 1] [-1 0] [1 0]]\n        tb (vec (repeat (+ 2 (count (first m))) \\#))\n        bm (into [tb] (conj (mapv #(into [\\#] (conj % \\#)) m') tb))\n        [start visited] (reduce\n                          (fn [[start visited] current]\n                            (let [c (get-in bm current)]\n                              [(or start (when (= c \\M) current))\n                               (if (= \\# c) (conj visited current) visited)]))\n                          [nil #{}]\n                          (for [y (range (count bm)) x (range (count (first bm)))] [y x]))\n        v (atom visited)\n        not-visited #(not (@v %))]\n    (->> (tree-seq\n           (fn [c] (let [b (not (@v c))] (swap! v #(conj % c)) b))\n           (fn [[y x]] (->> (map (fn [[y' x']] [(+ y y') (+ x x')]) moves) (filter not-visited)))\n           start)\n         (map (partial get-in bm))\n         (some #{\\C})\n         boolean)))","user":"56d68cbae4b0ea9b8538f7cd"},{"code":"(fn final-traverse [maze]\n  (letfn [(get-in-maze\n            ([maze x y]\n              (get-in-maze maze x y \\#))\n            ([maze x y df]\n              (if (or (>= x (count maze)) (< x 0))\n                df\n                (if (or (>= y (count (maze x))) (< y 0))\n                  df\n                  (.charAt (maze x) y)))))\n          (free-neirs \n            ([maze lst]\n              (free-neirs maze (first lst) (second lst)))\n            ([maze x y]\n              (filter #(not (nil? %))\n                      (for [i [-1 0 1]\n                            j [-1 0 1]\n                            :when (or (zero? i) (zero? j))]\n                        (let [cell (get-in-maze maze (+ x i) (+ y j))]\n                          (if (or (= cell \\space) (= cell \\M) (= cell \\C))\n                            [(+ x i) (+ y j)]\n                            nil))))))\n          (expand-maze [maze visited]\n            (into #{} (mapcat (partial free-neirs maze) visited)))\n          (run-maze [maze visited]\n            (let [visited' (expand-maze maze visited)]\n              (if (= visited visited')\n                visited\n                (run-maze maze visited'))))\n          (find-start [maze x ]\n            (let [f (first maze)\n                  ind (.indexOf f \"M\")]\n              (if (> ind -1)\n                [x ind]\n                (find-start (rest maze) (inc x)))))\n          (find-end [maze x]\n            (let [f (first maze)\n                  ind (.indexOf f \"C\")]\n              (if (> ind -1)\n                [x ind]\n                (find-end (rest maze) (inc x)))))]\n         (let [start (find-start maze 0)\n               end (find-end maze 0)]\n           (not (nil? ((run-maze maze #{start}) end))))))","problem":117,"user":"50e87427e4b0ebbe794eb7e8"},{"problem":117,"code":"(fn mazes [board]\n  (let [bfound (atom false)\n        linecnt (count board)\n        rankcnt (count (first board))\n        bmap (for [i (range linecnt)]\n               (for [j (range rankcnt)] \n                 (hash-map [i j] (str (nth (nth board i) j)))))\n        bmp (apply concat bmap)\n        bp  (apply merge bmp)\n        uppn   (fn [loc bpm lm rm]\n                 (let [[i j] loc]\n                   (if (< (dec i) 0) \n                     false \n                     (if (= \"#\" (bpm [(dec i) j]))\n                       false\n                       [(dec i) j])))) \n        downn  (fn [loc bpm lm rm]\n                 (let [[i j] loc]\n                   (if (> (inc i) (dec lm)) \n                     false \n                     (if (= \"#\" (bpm [(inc i) j]))\n                       false\n                       [(inc i) j])))) \n        leftn  (fn [loc bpm lm rm]\n                 (let [[i j] loc]\n                   (if (< (dec j) 0) \n                     false \n                     (if (= \"#\" (bpm [i (dec j)]))\n                       false\n                       [i (dec j)])))) \n        rightn (fn [loc bpm lm rm]\n                 (let [[i j] loc]\n                   (if (> (inc j) (dec rm)) \n                     false \n                     (if (= \"#\" (bpm [i (inc j)]))\n                       false\n                       [i (inc j)])))) \n        neighbours (fn [loc bpm lm rm]\n                     (list \n                       (uppn       loc bpm lm rm)\n                       (downn      loc bpm lm rm)\n                       (leftn      loc bpm lm rm)\n                       (rightn     loc bpm lm rm)))\n        startpoint (first (filter #(not (nil? %)) (for [i bmp] (if (= \"C\" (first (vals i))) (first (keys i)) nil))))\n        endpoint   (first (filter #(not (nil? %)) (for [i bmp] (if (= \"M\" (first (vals i))) (first (keys i)) nil))))\n        findpath   (fn fp [sp ep bd lm rm bf]\n                     (let [st sp \n                           path [st] \n                           bdm bd]\n                       (if (= st ep) \n                         (reset! bf true)\n                         (do\n                           (when (and (not= false (leftn st bdm lm rm)) (not @bf))  \n                               (fp (leftn st bdm lm rm) ep (assoc bdm st \"#\") lm rm bf))\n                           (when (and (not= false (uppn st bdm lm rm)) (not @bf))   \n                               (fp (uppn st bdm lm rm) ep (assoc bdm st \"#\") lm rm bf))\n                           (when (and (not= false (rightn st bdm lm rm)) (not @bf))\n                               (fp (rightn st bdm lm rm) ep (assoc bdm st \"#\") lm rm bf))\n                           (when (and (not= false (downn st bdm lm rm)) (not @bf))  \n                               (fp (downn st bdm lm rm) ep (assoc bdm st \"#\") lm rm bf))))))]\n      (do (findpath startpoint endpoint bp linecnt rankcnt bfound)  @bfound)))","user":"5243e37ae4b076204b44fae3"},{"code":"(fn [g]\n   (letfn [(s [[x y] t]\n             (let [z (update-in t [x y] #(if (= % \\O) \\T \\O))\n                   b [[x (inc y)] [x (dec y)] [(inc x) y] [(dec x) y]]\n                   p (fn [c] (some #(when (= c (get-in t %)) %) b))]\n               (true? (or (some #(= \\C (get-in t %)) b) (if-let [u (p \\space)] (s u z) (when-let [u (p \\O)] (s u z)))))))]\n     (s (first (keep-indexed #(let [j (.indexOf %2 \"M\")] (when (> j -1) [% j])) (flatten g))) (vec (map #(vec %) g)))))","problem":117,"user":"51f66e0ee4b06ff1c25c52c3"},{"code":"(fn science [maze]\n  (let [neighbor-coords [[-1 0] [1 0] [0 -1] [0 1]]\n        next-maze (fn [m] (vec (for [x (range (count m))]\n                            (reduce str \"\"\n                                    (for [y (range (count (first m)))]\n                                      (let [next-to-mouse?\n                                            (some #(= % \\M)\n                                                  (map #(get-in m (map + % [x y]))\n                                                       neighbor-coords))]\n                                        (condp = (get-in m [x y])\n                                          \\# \\#\n                                          \\M \\M\n                                          \\space (if next-to-mouse? \\M \\space)\n                                          \\C (if next-to-mouse? \\* \\C)\n                                          \\* \\*\n                                          \\$\n                                          )))))))\n        \n        ]\n    (true? (some #(= % \\*) (reduce str (nth (iterate next-maze maze) 100))))))","problem":117,"user":"4fa340b4e4b081705acca18c"},{"code":"(fn [grid]\n  (let [lines (seq grid)\n        s (loop [line lines\n                 y (count line)\n                 mouse nil]\n            (if line\n              (if (.contains (first line) \"M\")\n                (recur (next line) (dec y) [y (.indexOf (first line) \"M\")])\n                (recur (next line) (dec y) mouse))\n              mouse))\n        m (loop [line lines\n                 y (count line)\n                 x {}]\n            (if line\n              (recur (next line) (dec y) (assoc x y (into {} (filter identity (map-indexed #(if (= %2 \\space) (vector % :valid) (if (= %2 \\C) (vector % :cheese) (if (= %2 \\M) (vector % :mouse)))) (first line))))))\n              x))\n        possible (fn [c m]\n                   (filter #(let [x (first %)\n                                  y (second %)\n                                  sq (get (get m x) y)]\n                              (or (= sq :valid) (= sq :cheese)))\n                           (map #(map + % %2)\n                                [[0 1] [0 -1] [1 0] [-1 0]]\n                                (repeat 4 c))))\n        bfs (fn [start m]\n              (loop [coord start\n                     open (into #{} (possible coord m))\n                     closed #{}]\n                (let [sq (get (get m (first coord)) (second coord))]\n                  (if (= sq :cheese)\n                    true\n                    (let [nclose (conj closed coord)\n                          nopen (into open (filter\n                                                    #(and\n                                                       (not (contains? nclose %))\n                                                       (not (contains? open %)))\n                                                    (possible coord m)))]\n                      (if (empty? nopen)\n                        false\n                        (recur (first nopen)\n                               (next nopen)\n                               nclose)))))))]\n    (bfs (seq s) m)))","problem":117,"user":"4ff9d4e5e4b0678c553fc3b0"},{"code":"(fn can-reach-cheese\n  ([maze]\n    (let [height (count maze)\n          width (count (maze 0))\n          pos-y (->> (map vector (range height) maze)\n                     (filter #(.contains (% 1) \"M\"))\n                     (map #(% 0))\n                     (first))\n          pos-x (->> (map vector (range width) (maze pos-y))\n                     (filter #(= (% 1) \\M))\n                     (map #(% 0))\n                     (first))]\n      (can-reach-cheese maze height width pos-x pos-y #{[pos-x pos-y]})\n    )\n  )\n  ([maze height width pos-x pos-y cache]\n    (let [delta [[0 -1] [1 0] [0 1] [-1 0]]\n          found (= (get (maze pos-y) pos-x) \\C)\n          next-positions (->> (map #(vector (+ pos-x (% 0)) (+ pos-y (% 1))) delta)\n                              (filter #(and (>= (% 0) 0) (< (% 0) width) (>= (% 1) 0) (< (% 1) height)))\n                              (filter #(not= (get (maze (% 1)) (% 0)) \\#))\n                              (filter #(not (contains? cache %))))\n          next-cache (clojure.set/union cache (into #{} next-positions))]\n      (if found true\n                (true? (some true? (map #(can-reach-cheese maze height width (% 0) (% 1) next-cache) next-positions))))\n    )\n  )\n)","problem":117,"user":"5272d4b7e4b03e8d9a4a7453"},{"code":"(fn [src]\n    (let [maze (vec(map (fn[row] (vec(map (fn[cell] (cond (= cell \\space) 1\n                                         (= cell \\M) :mice\n                                         (= cell \\C) :cheese\n                                         :else nil\n                                                          \n                                         )) row)) ) src))\n          find-key (fn[k] (reduce #(if (>(.indexOf %2 k)-1) [(.indexOf maze %2)(.indexOf %2 k)] %) [-1 -1] maze))\n          start (find-key :mice)\n          end (find-key :cheese)\n          moves #{(fn up   [point] [(inc(first point)) (peek point)])\n                  (fn down [point] [(dec(first point)) (peek point)]) \n                  (fn right[point] [(first point) (inc(peek point))]) \n                  (fn left [point] [(first point) (dec(peek point))]) \n                  }\n          h (fn[x] (+(-(max(first x)(first end))(min(first x)(first end)))(-(max(peek x)(peek end))(min(peek x)(peek end)))))\n          ]\n      (loop [pending [start] visited [] ]\n        (do (println \"pending:\" pending \"visited:\" visited)(cond (some #(= end %) pending) true\n              (empty? pending) false\n              :else (recur (sort-by h (distinct(filter #(not(some (fn[v] (= v %)) visited)) (concat(rest pending)\n                                             (filter #(not(nil? (get-in maze %))) (map #(% (first pending)) moves)))))) \n                           (conj visited (first pending)))\n        )\n        ))\n      \n      )\n    )","problem":117,"user":"5274eb56e4b03e8d9a4a74bb"},{"problem":117,"code":"(fn do-maze [maze]\n  (let [ x-length (count (first maze))\n         y-length (count maze)\n         all-coords (for [x (range x-length)\n                          y (range y-length)]\n                      [x y])\n         s-spaces (filter (fn [[x y]] (= \\space (get (maze y) x))) all-coords)\n         m-coords (filter (fn [[x y]] (= \\M (get (maze y) x))) all-coords)\n         c-coords (set (filter (fn [[x y]] (= \\C (get (maze y) x)))\n                               all-coords\n                               ))\n        ]\n    (letfn [(adjacent [spaces [x y]]\n              (->> [[(inc x) y] [(dec x) y] [x (inc y)] [x (dec y)]]\n                   (filter (fn [[xx yy]] (and (> x-length xx)\n                                             (> y-length yy)\n                                             (>= x 0)\n                                             (>= y 0))))\n                   (filter (fn [[xx yy]] (or (c-coords [xx yy])\n                                            (spaces [xx yy]))))\n                   set\n                   ))]\n      (loop [spaces (set s-spaces)\n             mice   m-coords]\n          (let [newmice (reduce #(clojure.set/union %1\n                                                    (adjacent spaces %2))\n                                #{}\n                                mice)\n                ]\n            (if (clojure.set/subset? c-coords newmice)\n              true\n              (if (empty? newmice)\n                false\n                (recur (clojure.set/difference spaces newmice)\n                       newmice))))))))","user":"53c1ce3ee4b00fb29b221268"},{"code":"(fn [c]\r\n     (let [v (apply vector (map vec c))\r\n        m (count v)\r\n\t      n (count (first v))\r\n\t      ht (make-array Integer m n)\r\n\t      [x y] (first (filter #(= \\M (get-in c %)) (for [i (range m) j (range n)] [i j])))]\r\n       (letfn [(f [x y]\r\n\t\t  (if (= 1 (aget ht x y)) nil\r\n\t\t  (->> (doall (aset ht x y 1) (for [[i j] [[-1 0][0 -1][1 0][0 1]]] \r\n\t\t\t  (condp = (get-in c [(+ x i) (+ y j)])\r\n\t\t\t   \\C true\r\n\t\t\t   \\space (f (+ x i) (+ y j))\r\n\t\t\t   nil)\r\n\t\t\t  )) flatten (some true?) true?)))]\r\n\t     (f x y)\r\n\t     )))","problem":117,"user":"4dae4da5c9a9d6ed4e99dc57"},{"code":"(fn p117 [col]\n  (let [row-num (count col) column-num (count (first col))\n        all-cell (for [r (range row-num) c (range column-num)]   [r c]  )\n        M-pos (first (filter #(= 77 (int (get-in  col %) ))  all-cell))\n        C-pos (first (filter #(= 67 (int (get-in  col %) ))  all-cell))        \n        possible-move (fn [[r c]]\n                       (let [surround [ [r (inc c)] [r (dec c)] [ (inc r) c] [(dec r ) c]  ] \n                             valid-move (filter (fn [[r c]] (and (< -1 r row-num)\n                                                                 (< -1 c column-num)\n                                                                 (not= 35 (int (get-in col [r c])) )  )) surround)]\n                         valid-move ))\n        walk (fn [start-pos]\n              (loop [all-steps (set [start-pos]) last-steps  [start-pos] ]\n                (let [next-steps (mapcat possible-move last-steps )\n                      new-steps  (clojure.set/difference  (set next-steps) all-steps )\n                      ]\n                  (if (some #(= C-pos %) next-steps)\n                       true\n                       (if (empty? new-steps)\n                            false\n                            (recur (clojure.set/union all-steps new-steps )  new-steps)                  )\n                  )\n                )\n         ))\n        ]\n        (walk M-pos)\n    )\n\n\n  )","problem":117,"user":"4ec5bec6535d6d7199dd36b3"},{"problem":117,"code":"(fn solve \n  ([maze-str]\n   (let [maze (mapv vec maze-str)\n         start (first\n                 (for [[r row] (map-indexed vector maze)\n                       [c val] (map-indexed vector row)\n                    :when (= val \\M)]\n                   [r c]))]\n     (first (solve start maze [false #{}]))))\n  ([pos maze [solved seen]]\n   (let [val (get-in maze pos)\n         [r c] pos]\n     (cond\n       solved [true seen]\n       (seen pos) [false seen]\n       (or (= val \\#) (= val nil)) [false (conj seen pos)]\n       (= val \\C) [true (conj seen pos)] \n       :else (->> [solved (conj seen pos)]\n                  (solve [(inc r) c] maze)\n                  (solve [(dec r) c] maze)\n                  (solve [r (inc c)] maze)\n                  (solve [r (dec c)] maze))))))","user":"5aa998c6e4b0d174b936c8e5"},{"code":"(fn dfs [ss]\n  (let [w (+ 2 (count ss))\n        h (+ 2 (count (first ss)))\n        ss (vec  (concat [(vec (repeat h \\#))] (map (fn [s] (vec (concat [\\#] s [\\#]))) ss)  [(vec (repeat h \\#))]))\n        iter (mapcat (fn [i] (map (fn [j] [i j]) (range h))) (range w))\n        m (first (filter (fn [x] (= \\M (get-in ss x))) iter))\n        c (first (filter (fn [x] (= \\C (get-in ss x))) iter))\n        ]\n    (letfn [(step [[i j] [visited finish]]\n              (if (or finish (= \\# (get-in ss [i j])))\n                [visited finish]\n                (if (= [i j] c)\n                  [visited true]\n                  (->>\n                   (filter (fn [x] (not (or (= \\# (get-in ss x)) (contains? visited x)))) [[i (+ j 1)] [i (- j 1)] [(+ i 1) j] [(- i 1) j]])\n                   (reduce (fn [[visited finish] x] (if finish [visited finish] (step x [(conj visited x) finish]))) [visited finish] )))))]\n      (second (step m [#{m} false])))))","problem":117,"user":"5273562ae4b03e8d9a4a7479"},{"code":"(fn [maze]\n  (let [neighbor-coordinates\n        (fn [cell]\n          (let [[row column] cell]\n            [[(dec row) column]\n             [(inc row) column]\n             [row (dec column)]\n             [row (inc column)]]))\n\n        get-cell-value\n        (fn [cell]\n          (or\n           (let [[row column] cell]\n             (and\n              (<= 0 row (dec (count maze)))\n              (let [row-values (maze row)]\n                (and (<= 0 column (dec (count row-values)))\n                     (get row-values column)))))\n           nil))\n\n        find-cells\n        (fn [value]\n          (for [[row-index row] (map-indexed vector maze)\n                [column-index cell-value] (map-indexed vector row)\n                :when (= value cell-value)]\n            [row-index column-index]))\n\n        mouse\n        (first (find-cells \\M))\n\n        cheese\n        (first (find-cells \\C))\n\n        moves-from-cell\n        (fn [cell]\n          (filter #(#{\\space \\C} (get-cell-value %))\n                  (neighbor-coordinates cell)))\n\n        extend-search-area\n        (fn [{:keys [searched-cells edge]}]\n          (reduce\n           (fn [{:keys [searched-cells edge]} cell]\n             (let [new-cells (clojure.set/difference (set (moves-from-cell cell))\n                                                     searched-cells)]\n               {:searched-cells (clojure.set/union searched-cells new-cells)\n                :edge (clojure.set/union edge new-cells)}))\n           {:searched-cells searched-cells\n            :edge #{}}\n           edge))]\n    (true?\n     (some\n      (fn [{:keys [searched-cells]}]\n        (contains? searched-cells cheese))\n      (take-while\n       (fn [{:keys [searched-cells edge]}]\n         (and (seq edge)))\n       (iterate extend-search-area {:searched-cells #{mouse}\n                                    :edge #{mouse}}))))))","problem":117,"user":"4e68c434535d8ccf87e9fe89"},{"problem":117,"code":"(fn [maze]\n    (let [rows (count maze)\n          cols (count (first maze))\n          indexed (apply concat (map-indexed (fn [x row] (map-indexed (fn [y e] [e [x y]]) row)) maze))\n          start (second (first (filter (fn [[e _]] (= e \\C)) indexed)))\n          goal (second (first (filter (fn [[e _]] (= e \\M)) indexed)))\n          space (set (map second (filter (fn [[e _]] (not= e \\#)) indexed)))]\n        (letfn [(neighbors [x y] (->> (for [[i j] [[-1 0] [1 0] [0 -1] [0 1]]] [(+ x i) (+ y j)])\n                                      (filter (fn [[x y]] (and (>= x 0)\n                                                               (>= y 0)\n                                                               (< x rows)\n                                                               (< y cols))))\n                                      (filter space)))]\n            (loop [waiting (list start)\n                   visited #{}]\n                (if (empty? waiting)\n                  \tfalse\n                    (let [[x y] (first waiting)\n                          waiting' (concat (rest waiting) (filter (complement visited) (neighbors x y)))\n                          visited' (conj visited [x y])]\n                        (if (= [x y] goal)\n                            true\n                            (recur waiting' visited'))))))))","user":"600ae927e4b074f607df6689"},{"problem":117,"code":"(fn [board]\n  (letfn [(loc [x] ((juxt quot mod) (.indexOf (apply str board) x) (-> board first count)))\n          (neighbors [[r c]] [[(dec r) c] [r (dec c)]\n                              [(inc r) c] [r (inc c)]])\n          (move [c m bbb]\n            (if (seq m)\n              (let [bb (->> (mapcat neighbors m) (filter bbb) set)]\n                (or (contains? bb c) \n                    (recur c bb (clojure.set/difference bbb bb))))))]\n    (let [b (set (for [[i r] (map-indexed vector board)\n                       [j v] (map-indexed vector r)\n                       :when (#{\\space \\C} v)]\n                        [i j]))\n          m (loc \"M\")\n          c (loc \"C\")]\n      (not (nil? (move c [m] b))))))","user":"56102f50e4b05f002753df6b"},{"code":"(fn solve [maze]\n  (let [r (count maze)\n        c (count (first maze))\n        nodify (fn [x] (for [i (second x)] [(first x) i]))\n        cells (apply concat (for [i (range r)] (for [j (range c)] [i j])))\n        linearize (fn [[cell :as [i j]]]\n                    (+ j (* i c)))\n        invalid (fn [n]\n                  (let [i (quot n (count (first maze)))\n                        j (rem n (count (first maze)))\n                        s (nth (nth maze i) j)]\n                    (nil?(#{\\space \\C \\M} s))))\n        dist (fn [[c1 :as [x1 y1]] [c2 :as [x2 y2]]]\n               (let [dx (- x1 x2)\n                     dy (- y1 y2)]\n                 (+ (* dx dx) (* dy dy))))\n        neighbors (fn [[cell :as [i j]]]\n                    {(linearize [i j])\n                     (cons [i j] (remove invalid (map linearize\n                                          (filter #(= 1 (dist % [i j]))\n                                                  (for [x (filter (-> r range set) (range (- i 1) (+ 2 i)))\n                                                        y (filter (-> c range set) (range (- j 1) (+ 2 j)))]\n                                                    [x y])))))})\n\n        raw-graph (apply merge (map neighbors cells))\n        gr (set (mapcat nodify (remove (comp invalid key) raw-graph)))\n        graph (fn [g]\n                (let [edges (clojure.set/union g (map reverse g))\n                      n1 (group-by first edges)\n                      nd (fn [x] {(first x) (map second (second x))})\n                      nodes (into {} (mapcat nd n1))]\n                  (loop [visited {}\n                         q [(first nodes)]]\n                    (if (empty? q) (= nodes visited)\n                        (let [x (first q)\n                              nxt (filter #(contains? (set (val x)) (key %)) nodes)]\n                          (if (get visited (key x))\n                            (recur visited (rest q))\n                            (let [v2 (merge visited x)\n                                  q2 (concat (rest q) nxt)]\n                              (recur v2 q2))))))))]\n    (graph gr)))","problem":117,"user":"4fbd12a5e4b081705acca2fd"},{"problem":117,"code":"(fn for-science! [maze-data]\n  (letfn [(build-maze \n           [maze-data]\n            (let [side-length (+ (count (first maze-data)) 2)]\n              (conj (into [(vec (repeat side-length \\#))]\n                           (for [row (mapv vec maze-data)]\n                             (into [\\#] (conj row \\#))))\n                    (vec (repeat side-length \\#)))))\n          \n          (locate-cell [maze value]\n            (first (filter #(= (get-in maze %) value)\n                          (for [i (range (count maze))\n                                j (range (count (maze i)))]\n                            [i j]))))\n          \n          \n          (distance\n            [p1 p2]\n            (let [dx (- (first p1) (first p2))\n                  dy (- (second p1) (second p2))]\n              (Math/sqrt (+ (* dx dx) (* dy dy)))))\n          \n          (actions \n            [[x y] goal-point]\n            (into (sorted-map)\n                  (group-by (partial distance goal-point) \n                  [[(inc x) y]\n                   [x (inc y)]\n                   [x (dec y)]\n                   [(dec x) y]])))\n          \n          (legal-action? [maze point]\n            (not= (get-in maze point) \\#))\n          \n          (rank-actions \n            [maze my-pos goal-pos]\n            (let [possible-actions (actions my-pos goal-pos)\n                  legal-action?* (partial legal-action? maze)]\n              (->> possible-actions\n                   (mapcat (fn [[dist actions]] actions))\n                   (filter legal-action?*)\n                   (into []))))\n          \n          (walk \n            ([maze]\n             (let [my-pos (locate-cell maze \\M)\n                   goal-pos (locate-cell maze \\C)]\n               (walk maze my-pos goal-pos #{})))\n            ([maze my-pos goal-pos visited]\n               (if (= my-pos goal-pos) :muhahaha\n                 (let [action-seq (rank-actions maze my-pos goal-pos)\n                       visited (conj visited my-pos)\n                       next-steps (remove visited action-seq)]\n                   (if (empty? next-steps) visited\n                     ;; No fold-right????\n                     (loop [visited visited next-steps next-steps]\n                       (cond (= visited :muhahaha) visited\n                             (empty? next-steps) visited\n                             :else\n                             (recur (walk maze\n                                          (first next-steps)\n                                          goal-pos\n                                          visited)\n                                    (next next-steps)))))))))]\n    \n    (= (walk (build-maze maze-data)) :muhahaha)))","user":"571c2babe4b07c98581c3b73"},{"problem":117,"code":"(fn [maze]\n  (let [row (count maze)\n        col (count (first maze))]\n    (letfn [(getelem [x y] (nth (nth maze x []) y \\#))\n            (neighbors [x y] [[(dec x) y] [(inc x) y] [x (dec y)] [x (inc y)]])\n            (walk [x y] (filter #(or (= (apply getelem %) \\C) (= (apply getelem %) \\space)) (neighbors x y)))\n            (getmouse [m] (filter #(= \\M (apply getelem %)) (for [x (range row) y (range col)] [x y])))]\n      (loop [towalk (getmouse maze)\n             walked #{}]\n        (let [newwalked (if (empty? towalk) walked (apply conj walked towalk))\n              newtowalk (set (filter #(nil? (newwalked %)) (reduce (fn [x y] (if (empty? (apply walk y)) x (apply conj x (apply walk y)))) [] towalk)))]\n        (if (empty? newtowalk)\n          false\n          (if (some #(= \\C (apply getelem %)) newtowalk)\n            true\n            (recur newtowalk newwalked))))))))","user":"57dd47f4e4b0bd073c20243e"},{"problem":117,"code":"(fn\n  [board]\n  (letfn [\n(neighbour-inds\n  [[x y] board]\n  (let [inds [[(+ x 1) y]\n              [(- x 1) y]\n              [x (+ y 1)]\n              [x (- y 1)]]]\n    (filter\n      #(#{\\space \\C} (get-in board %))\n      inds)))\n\n(next-going-to\n  [visited-inds board]\n  (set\n    (filter\n      #(not (visited-inds %))\n      (reduce\n        concat\n        []\n        (map\n          #(neighbour-inds % board)\n          visited-inds)))))\n\n(collect-available\n  [board start-with]\n  (loop\n    [visited-inds #{start-with}]\n    (let\n      [frontier (next-going-to visited-inds board)]\n      (if (empty? frontier)\n        visited-inds\n        (do\n          (println frontier)\n          (recur\n            (clojure.set/union visited-inds frontier)))))))\n\n(find-index\n  [board sym]\n  (first\n    (filter \n      #(not (nil? %))\n      (flatten\n         (map-indexed\n          (fn\n            [x row]\n           (map-indexed\n            (fn\n              [y el]\n              (if (= el sym)\n                {:x x :y y}\n                nil))\n          row))\n          board)))))\n(can-eat?\n  [board]\n  (let\n    [m (find-index board \\M)\n     c (find-index board \\C)\n     m-ind [(:x m) (:y m)]\n     c-ind [(:x c) (:y c)]\n     mice-available (collect-available board m-ind)]\n     (println mice-available)\n     (println c-ind)\n     (not (not (mice-available c-ind)))))]\n\n(can-eat? board)))","user":"53d382d8e4b00fb29b22132a"},{"code":"(fn [foo] (true? (some #(.contains (str foo) %) [\r\n  \"M   C\"\r\n  \"#M # C#\"\r\n  \"C######\"\r\n  \"C# # # #\"])\r\n))","problem":117,"user":"4e7d2f2f535db169f9c796cd"},{"code":"(fn forscience [xss]\n  (let \n      [it (+ (count xss) (count (first xss)))\n       m (fn [x y]\n           (cond\n            (= x \\space) (if (= y \\#) \\space y)\n            (= x \\C) (if (= y \\M) \\X \\C)\n            (= x \\M) (if (= y \\C) \\X \\M)\n            :else (if (= y \\X) \\X x)\n            ))\n       red1 (fn [xs y]\n              (cons (m y (first xs)) (cons (m (first xs) y) (rest xs))))\n       red2 (fn [xs y]\n              (cons (map m y (first xs)) (cons (map m (first xs) y) (rest xs))))\n       expand (fn [xss]\n                (let [xp (map #(reverse (reduce red1 (list (first %)) (rest %))) xss)]\n                  (reverse (reduce red2 (list (first xp)) (rest xp)))))\n       final (nth (iterate expand xss) it)]\n    (if (some #(= % \\X) (flatten final)) true false)))","problem":117,"user":"4e14108c535d04ed9115e7dd"},{"problem":117,"code":"(fn [maze]\n  (let [ipos (loop [i 0]\n               (if (some #{\\M} (get maze i))\n                 (loop [j 0]\n                   (if (= \\M (get (maze i) j)) [i j] (recur (inc j))))\n                 (recur (inc i))))]\n    (loop [[[x y] & r :as q] [ipos] passed #{ipos}]\n      (if (empty? q)\n        false\n        (let [npos [[(dec x) y] [(inc x) y] [x (dec y)] [x (inc y)]]\n              f (fn [x] (apply #(get (get maze %) %2) x))\n              m (group-by first (map vector (map f npos) npos))]\n          (if (m \\C)\n            true\n            (recur (concat r (remove passed (map second (m \\space))))\n                   (conj passed [x y]))))))))","user":"57035ccfe4b08d47c97781ef"},{"code":"(fn [s]\r\n(let [c (count (first s))]\r\n (loop [z (map {\\# 0, \\  1, \\M 2, \\C 3} (apply str s))]\r\n  (let [d (keep-indexed #(if (= 2 %2) %) z)\r\n        n (remove nil? (mapcat (fn [x] (let [l (inc x) m (- x c) o (+ x c)]\r\n           [(if (not= 0 (mod x c)) (dec x)) (if (not= 0 (mod l c)) l)\r\n            (if (< o (count z)) o) (if (>= m 0) m)])) d))]\r\n       (if (empty? d) false\r\n         (if (some #(= 3 (nth z %)) n) true\r\n           (recur (keep-indexed #(if (= 2 %2) 0 (if (and (= 1 %2) ((into #{} n) %)) 2 %2)) z))\r\n           ))))\r\n))","problem":117,"user":"4fca2ef0e4b0ee37620e184e"},{"code":"(fn for-science [coll]\n  (letfn [(mark-next [coll]\n            (->> (conj coll \\#)\n                 (reduce (fn [[out p c] n]\n                           (if (and (contains? #{\\space \\C} c) (or (= p \\F) (= n \\F)))\n                               [(conj out \\N) \\N n]\n                               [(conj out c) c n]))\n                          [[] nil nil])\n                  ((comp rest first))))\n          (swap-chars [coll]\n            (map (fn [c]\n                   (cond\n                     (= c \\N) \\F\n                     (= c \\F) \\#\n                     :else c))\n                 coll))\n          (all-next [coll]\n            (->> (into [] coll)\n                 (map mark-next)\n                 (apply map vector)\n                 (map mark-next)\n                 (map swap-chars)\n                 (apply map vector)))]\n    (loop [maze (map #(into [] (clojure.string/replace % #\"M\" \"F\")) coll)]\n      (let [flat-maze (flatten maze)]\n        (cond\n          (not-any? #{\\C} flat-maze) true\n          (not-any? #{\\F} flat-maze) false\n          :else (recur (all-next maze)))))))","problem":117,"user":"52463059e4b09dbe66b56198"},{"code":"(fn [maze]\n  (let [h (count maze)\n        w (count (first maze))\n        neighbors (fn [pair]\n                    (for [op [inc dec]\n                          dimension [0 1]\n                          :let [neighbor (update-in pair [dimension] op)]\n                          :when (and (< -1 (first neighbor) h)\n                                     (< -1 (second neighbor) w))]\n                      neighbor))]\n    (loop [seen #{}\n           queue (for [y (range h)\n                       x (range w)\n                       :when (= (get-in maze [y x]) \\M)]\n                   [y x])]\n      (let [curr (first queue)]\n        (cond\n         (= (get-in maze curr) \\C) true\n         (empty? queue) false\n         (= (get-in maze curr) \\#) (recur (conj seen curr) (rest queue))\n         :else (recur (conj seen curr)\n                      (concat (rest queue) (clojure.set/difference (set (neighbors curr)) seen))))))))","problem":117,"user":"4ebaf790535dfed6da9c6d6e"},{"problem":117,"code":"(fn [field]\n   (let\n       [to-int (fn [ch]\n                 (case ch\n                   \\C 0\n                   999))\n        base [-1 1]\n        br\n        (fn [c h]\n          #_(println \"br\")\n          (when (< c h)\n            (filter\n             #(and (<= 0 %) (> h %))\n             (map + base (repeat c)))))\n        xl (count (first field))\n        yl (count field)\n        find-nghs\n        (fn [[y x]]\n          #_(println \"find-nghs\")\n          (vec\n           (concat\n            (map\n             vector\n             (repeat y)\n             (br x xl))\n            (map\n             vector\n             (br y yl)\n             (repeat x)))))\n        ;;_ (println (find-nghs [0 0]))\n        ;;_ (println \"(find-nghs [1 0])\" (find-nghs [1 0]))\n        indexed\n        (vec(map-indexed\n             (fn [y a]\n               (vec (map-indexed\n                     (fn [x n]\n                       {:i (find-nghs [y x])\n                        :n (to-int n)\n                        :m (= \\M n)\n                        :w (= \\# n)})\n                     a)))\n             field))\n        ngbw\n        (fn [ifi]\n          #_(println \"ngbw\")\n          (fn [i]\n            #_(println \"ngbw-fn\" ifi i)\n            (:n (get-in ifi i))))\n        lngbw\n        (fn [ifi ixs]\n          #_(println \"lngbw\" ixs)\n          (map\n           #((ngbw ifi) %)\n           ixs))\n        #_(vec (lngbw\n                indexed\n                (find-nghs [0 0])))\n        minn\n        (fn [& as]\n          #_(println \"minn\" as)\n          (reduce min as))\n        lnngbr\n        (fn [ifi node]\n          #_(println \"lnngbr\")\n          (reduce\n           minn\n           (lngbw ifi (:i node))))\n        ;;(vec(lnngbr\n        ;;     indexed\n        ;;     (ffirst indexed)))\n        lnngbrn\n        (fn [ifi node]\n          (assoc\n           node\n           :n (if (= true (:w node))\n                (:n node)\n                (min\n                 (:n node)\n                 (inc (lnngbr ifi node))))))\n        ;;_ (println (lnngbrn\n        ;;            indexed\n        ;;            (ffirst indexed)))\n        ngn\n        (fn [ifi]\n          #_(println \"ngn\")\n          (vec\n           (map\n            #(vec (map\n                   (fn [node]\n                     (lnngbrn ifi node))\n                   %))\n            ifi)))\n        #_(ngn indexed)\n        #_(ngn [[{:i [[1 0] [0 1]], :n 0, :m false} {:i [[0 0] [1 1]], :n 1, :m false}]\n                [{:i [[1 1] [0 0]], :n 1, :m false} {:i [[0 1] [1 0]], :n 999, :m true}]])\n        it (ffirst\n            (let [n (iterate ngn indexed)\n                  nx (rest n)]\n              (drop-while\n               (comp not #(apply = %))\n               (map vector n nx))))\n        ;;m (filter :m (reduce concat it))\n        #_(take 6 (iterate ngn indexed))\n        rcit (reduce concat it)\n        m (first (filter\n                  #(and (:m %)\n                        (not (= 999 (:n %))))\n                  rcit))\n        ]\n     ((comp not nil?) m)\n     ))","user":"586a657de4b0f14aab7c88bd"},{"code":"(fn [fld]\n         (loop [field fld]\n           (letfn [(nbrs [i j] (sorted-set (get-in field [(dec i) j])\n                                           (get-in field [(inc i) j])\n                                           (get-in field [i (dec j)])\n                                           (get-in field [i (inc j)])))\n                   (accessable [i j] (and (contains? #{\\C \\ } (get-in field [i j]))\n                                          (contains? (nbrs i j) \\M)))\n                   (update []\n                     (vec (for [i (range 0 (count field))]\n                            (vec (for [j (range 0 (count (first field)))]\n                                   (if (accessable i j)\n                                     \\M\n                                     (get-in field [i j])))))))]\n             (if (= (update) field)\n               (not (some (fn [row] (> (count (filter #(= % \\C) row)) 0)) field))\n               (recur (update))))))","problem":117,"user":"5294e44de4b02ebb4ef75016"},{"problem":117,"code":"(fn can-find-cheese [input-lines]\n  (letfn [(make-node-list [input-lines]\n            (let [cols (count (first input-lines))\n                  rows (count input-lines)]\n              (for [x (range cols)\n                    y (range rows)]\n                (let [c (nth (nth input-lines y) x)\n                      s (cond (= c \\space) :empty\n                              (= c \\#) :blocked\n                              (= c \\M) :start\n                              (= c \\C) :end)]\n                  [x y s]))))\n          (not-is-blocked? [[x y s]]\n            (not= :blocked s))\n          (neighbours? [[src-x src-y src-state]\n                        [dst-x dst-y dst-state]]\n            (or (and (= src-x dst-x) (= dst-y (dec src-y)))\n                (and (= src-x dst-x) (= dst-y (inc src-y)))\n                (and (= src-y dst-y) (= dst-x (dec src-x)))\n                (and (= src-y dst-y) (= dst-x (inc src-x)))))\n          (select-neighbours [node node-list]\n            (filter (partial neighbours? node) node-list))\n          (visitable-neighbours [node node-list]\n            (filter not-is-blocked? (select-neighbours node node-list)))\n          (unvisited-neighbours [node visited node-list]\n            (remove visited (visitable-neighbours node node-list)))\n          (build-paths-helper [node visited node-list]\n            (let [reachable-nodes (unvisited-neighbours node visited node-list)]\n              (if-not (empty? reachable-nodes)\n                (apply concat\n                       (for [n reachable-nodes]\n                         (if (= :end (get-state n))\n                           (list (conj visited n))\n                           (map #(cons n %) (build-paths-helper n (conj visited n) node-list)))))\n                (list visited))))\n          (get-state [node]\n            (nth node 2))\n          (first-of-state [state node-list]\n            (reduce (fn [a node]\n                      (if (= state (get-state node))\n                        node a))\n                    nil node-list))\n          (mouse-node [node-list]\n            (first-of-state :start node-list))\n          (cheese-node [node-list]\n            (first-of-state :end node-list))\n          (build-paths [start node-list]\n            (build-paths-helper start #{} node-list))]\n    (> (count (set (map mouse-node\n                        (let [nl (make-node-list input-lines)]\n                          (build-paths (cheese-node nl) nl)))))\n       1)))","user":"5341b141e4b00652c8746ecf"},{"problem":117,"code":"(fn [maze]\n  (let [max-x (dec (count maze))\n        max-y (dec (count (maze 0)))\n        matrix (into [] (map #(apply vector %) maze))\n        [mouse cheese] (loop [x 0, y 0\n                              m nil, c nil]\n                         (cond (> y max-y) (recur (inc x) 0 m c)\n                               (> x max-x) [m c]\n                               :else (case (get-in matrix [x y])\n                                       \\C (recur x (inc y) m [x y])\n                                       \\M (recur x (inc y) [x y] c)\n                                       (recur x (inc y) m c))))\n        neighbors (fn [[ox oy]]\n                    (filter (fn [[x y]]\n                              (and (>= x 0) (<= x max-x)\n                                   (>= y 0) (<= y max-y)))\n                            [[(dec ox) oy] [(inc ox) oy]\n                             [ox (dec oy)] [ox (inc oy)]]))]\n    (letfn [(escape? [xy path]\n              (let [obs (get-in matrix xy)]\n                (cond (= xy cheese) true\n                      (= obs \\#) false\n                      :else\n                      (->> (neighbors xy)\n                           (filter (complement path))\n                           (reduce #(or %1 (escape? %2 (conj path xy))) false)))))]\n      (escape? mouse #{}))))","user":"5eb1c786e4b00a66d4a95201"},{"code":"(fn [s] (let [b (vec (map vec s))\n               places\n               (into {} (for [i (range (count b)) j (range (count (first b)))] [[i j] ((b i) j)]))\n               start (ffirst (filter #(= \\M (val %)) places))\n               end (ffirst (filter #(= \\C (val %)) places))\n               nbs (fn [[ i j]] \n                     (filter #(#{\\space \\C} (places %)) (list [(dec i) j]\n                                                          [(inc i) j]\n                                                          [i (dec j)]\n                                                          [i (inc j)] )\n                             )\n                     )\n               f (fn [seen] (let [new (into seen (set (mapcat nbs seen)))]\n                              (if (= (count seen) (count new)) seen\n                                  (recur new))))]\n          (boolean ((f #{start}) end)) ))","problem":117,"user":"50563ae2e4b0ce54f56f0405"},{"code":"(fn r\n  ([xs]\n     (let [s (apply str xs)]\n       (r s (count (first xs)) (.indexOf s \"M\") (atom #{}))))\n  ([s w i v]\n     (let [ok (and (> i -1) (< i (count s)) (not (contains? @v i)))]\n       (reset! v (conj @v i))\n       (and\n         ok\n         (or \n          (= \\C (.charAt s i))       \n          (if (= \\# (.charAt s i))\n            false                    \n              (or\n               (r s w (dec i) v) \n               (r s w (inc i) v) \n               (r s w (+ i w) v) \n               (r s w (- i w) v) \n               )))))))","problem":117,"user":"4fb510b5e4b081705acca2b8"},{"problem":117,"code":"(fn wide-search-cheese [original-board]\n  (let [moves [[0 1] [0 -1] [-1 0] [1 0]]\n        size [(count original-board) (count (first original-board))]\n        get-mouse-position (fn [board]\n                             (->>\n                               (filter\n                                 #(= (get-in board %) \\M)\n                                 (for [x (range (first size))\n                                       y (range (second size))]\n                                   [x y]))\n                               first))\n\n        in-board? (fn [position]\n                    (let [[x y] position]\n                      (and (>= x 0) (< x (first size)) (>= y 0) (< y (second size)))))\n\n        next-board (fn [board move]\n                     (let [old-position (get-mouse-position board)\n                           new-position (map + move old-position)]\n                       (when (and (in-board? new-position) (= (get-in board new-position) \\space))\n                         (->\n                           board\n                           (assoc-in new-position \\M)\n                           (assoc-in old-position \\space)\n                           ))))\n\n        find-cheese? (fn  [board move]\n                       (let [old-position (get-mouse-position board)\n                             new-position (map + move old-position)]\n                         (and (in-board? new-position) (= (get-in board new-position) \\C))))]\n\n    (loop [explored-boards [(mapv #(vec %) original-board)]\n           board-index 0]\n      ;;     (println explored-boards board-index)\n      (let [board (if (< board-index (count explored-boards)) (nth explored-boards board-index) nil)]\n        (cond\n          (nil? board) false\n          (some true? (map #(find-cheese? board %) moves)) true\n          :else (recur (concat explored-boards (filter #(not ((set explored-boards) %)) (keep #(next-board board %) moves)))\n                       (inc board-index)))))))","user":"5e0d948fe4b099d064962f98"},{"problem":117,"code":"(fn [amaze]\n    (let [maze\n      (reduce (fn [sum [pt val]]\n        (case val\n          \\M (assoc (update-in sum [:points] #(conj % pt)) :mouse pt)\n          \\C (assoc (update-in sum [:points] #(conj % pt)) :cheese pt)\n          \\space (update-in sum [:points] #(conj % pt))\n          sum)\n        ) \n       {:points #{}}\n       (apply concat \n          (map-indexed \n            (fn [i row] (map-indexed (fn [j val] [[i j] val]) row)) \n            amaze)))]\n\n  (loop [to-check (list (:mouse maze))\n         remaining (disj (:points maze) (:mouse maze))]\n    (let [[x1 y1] (first to-check)\n          connected (filter (fn [[x2 y2]]                       \n                       (or (and (= 0 (- x1 x2)) (> 2 (Math/abs (- y1 y2)))) \n                           (and (= 0 (- y1 y2)) (> 2 (Math/abs (- x1 x2)))))) \n                      remaining)\n          still-remaining (concat (rest to-check) connected)]\n      (cond (some (partial = (:cheese maze)) connected) true\n            (empty? still-remaining) false\n            :else (recur (concat (rest to-check) connected)\n                         (apply disj remaining to-check)))\n      ))))","user":"4f463dfde4b0d56e7bb92b99"},{"code":"(fn [map]\r\n  (let [rc (count map) cc (count (first map))]\r\n       (letfn [(valid-pos? [[x y]]\r\n                 (and (<= 0 x (dec rc))\r\n                      (<= 0 y (dec cc))))\r\n               (neighbors-pos [[x y]]\r\n                 (filter valid-pos?\r\n                   (list [(dec x) y] [(inc x) y]\r\n                         [x (dec y)] [x (inc y)])))\r\n               (update-map [cur-map [sx sy] newitem]\r\n                 (vec (for [x (range rc)]\r\n                        (if (= x sx)\r\n                           (str (subs (get cur-map x) 0 sy) (str newitem) (subs (get cur-map x) (inc sy)))\r\n                           (get cur-map x)))))\r\n              ]\r\n          (loop [done false cur-map map x 0 y 0]\r\n             (cond\r\n                done true\r\n                (and (= (get-in cur-map [x y]) \\space)\r\n                     (some (fn [neighbor] (= (get-in cur-map neighbor) \\M)) (neighbors-pos [x y])))\r\n                     (recur done (update-map cur-map [x y] \\M) 0 0)\r\n                \r\n                (and (= (get-in cur-map [x y]) \\C)\r\n                     (some (fn [neighbor] (= (get-in cur-map neighbor) \\M)) (neighbors-pos [x y])))\r\n                     (recur true cur-map 0 0)\r\n                \r\n                (and (= x (dec rc)) (= y (dec cc)))\r\n                     false\r\n                \r\n                (= y (dec cc))\r\n                     (recur done cur-map (inc x) 0)\r\n               \r\n                :else\r\n                     (recur done cur-map x (inc y)))))))","problem":117,"user":"4f474f43e4b0d56e7bb92bb7"},{"code":"(fn solve-maze [maze]\n    (let [num-rows (count maze)\n          num-cols (count (maze 0))\n          deltas [[-1 0] [1 0] [0 -1] [0 1]]\n          in-maze\n            (fn [[y x]]\n                (when (and (< -1 y num-rows) (< -1 x num-cols)) [y x]))\n          find-posn \n            (fn [letter] \n                (let [l (int letter)]\n                    (->> maze\n                         (map-indexed (fn [y row] (let [x (.indexOf row l)] (when (>= x 0) [y x]))))\n                         (some identity)\n                    )))\n          mouse (find-posn \\M)\n          cheese (find-posn \\C)\n          seen-items (atom #{})\n          seen\n            (fn [posn] (if (@seen-items posn) true (do (swap! seen-items conj posn) false)))\n          moves-from\n            (fn [[y x]]\n                (->> deltas\n                     (map (fn [[dy dx]] [(+ y dy) (+ x dx)]))\n                     (keep in-maze)\n                     (remove (fn [posn] (or (seen posn) (= \\# (get-in maze posn)))))\n                ))\n        ]\n        (loop [posns [mouse]]\n            (if-let [[posn & posns] (seq posns)]\n                (if (= posn cheese)\n                    true\n                    (recur (concat posns (moves-from posn))))\n                false\n            ))))","problem":117,"user":"4df3d4f4535d08e6dec9fe2c"},{"code":"(fn problem117 [maze]\n   (let [explored (atom #{})\n         frontier (atom [])]\n     (letfn [(find-start []\n               (first (for [[x row] (map-indexed vector maze)\n                            [y col] (map-indexed vector row)\n                            :when (= col \\M)]\n                        [x y])))\n             (children [[x y]]\n               (set (for [[dx dy] [[0, -1] [-1, 0] [1, 0] [0, 1]]\n                          :let [new-x (+ x dx)\n                                new-y (+ y dy)\n                                node (get-in maze [new-x new-y])]\n                          :when node \n                          :when (not= node \\#)]\n                      [new-x new-y])))\n             (goal? [[x y]] (= (get-in maze [x y]) \\C))]\n       (swap! frontier conj (find-start))\n       (loop []\n         (if (empty? @frontier)\n           false\n           (let [node (peek @frontier)]\n             (swap! frontier pop)\n             (swap! explored conj node)\n             (if (some #(= % :end)\n                       (for [child (clojure.set/difference (children node)\n                                                           @explored)]\n                         (if (goal? child)\n                           :end\n                           (swap! frontier conj child))))\n               true\n               (recur))\n             ))\n         )\n       \n       )))","problem":117,"user":"4e9fd521535d7eef3080729a"},{"problem":117,"code":"(fn cheese?\n  [maze]\n  (let [mouse-pos (first (for [row (range (count maze))\n                               col (range (count (first maze)))\n                               :when (= \\M (get-in maze [row col]))]\n                           [row col]))\n        neighbours (fn [[row col]]\n                     (filter (fn [[row col :as pos]]\n                               (and (<= 0 row (dec (count maze)))\n                                    (<= 0 col (dec (count (first maze))))\n                                    (not= \\# (get-in maze pos))))\n                             (list [(dec row) col] [row (dec col)] [row (inc col)] [(inc row) col])))]\n    (loop [next (into (clojure.lang.PersistentQueue/EMPTY) (neighbours mouse-pos))\n           visited #{mouse-pos}]\n      (if (empty? next)\n        false\n        (let [pos (peek next)\n              next (pop next)]\n          (if (= \\C (get-in maze pos))\n            true\n            (recur (into next (filter (complement visited) (neighbours pos)))\n                   (conj visited pos))))))))","user":"60460824e4b02d28681c77bc"},{"code":"(fn [b] \n   (let [r (count b)\n         c (count (first b))\n         f (fn [s] (first (for [i (range r) j (range c) :let [v (get-in b [i j])] :when (= v s)] [i j])))\n         M (f \\M)\n         C (f \\C)\n         s (fn [x] (filter \n                     #(let [y (first %) \n                            x (second %)] \n                        (and (and (>= y 0) (< y r)) (and (>= x 0) (< x c)))) \n                     (map #(map + x %) [[1 0] [0 -1] [-1 0] [0 1]])))\n         n (fn [x] (vec (distinct (concat x (filter #(not= \\# (get-in b %)) (map vec (mapcat s x)))))))]\n     (not (nil? ((set ((fn p [x] (let [r (n x)] (if (= x r) r (p r)))) [M])) C)))))","problem":117,"user":"4eb13d60535d7eef3080733f"},{"problem":117,"code":"(let [bd (fn [bd]\n  (let [m? #(= \\M %)\n        s? #(or (= \\  %)\n                (= \\C %))\n        getXY (fn [x y]\n                (nth (nth bd y) x))\n        xLen (count (first bd))\n        yLen (count bd)\n        neighbours [[0 1] [0 -1] [1 0] [-1 0]]\n        clamp (fn [[x y]]\n                (if (and (>= x 0)\n                         (>= y 0)\n                         (< x xLen)\n                         (< y yLen))\n                  (vector x y)))]\n    (for [y (range yLen)]\n      (apply str\n      (for [x (range xLen)]\n      (let [numberM (count (filter (fn [[x y]] (m? (getXY x y)))\n                                       (keep clamp\n                                   \t\t\t(map (fn [[a b]] (vector (+ x a) (+ y b))) neighbours))))]\n        (if (s? (getXY x y))\n          (if (>= numberM 1)\n            \\M\n            (getXY x y)\n            )\n          (getXY x y))))))))]\n  (fn [v]\n    (let [mat (map seq v)]\n      \t(nil? (some #(= \\C %) (clojure.string/join\n    \t((apply comp (repeat (* (count mat)\n                                (count (first mat)))\n                                bd))\n         mat)))))))","user":"541ef7e2e4b01498b1a71a92"},{"problem":117,"code":"(fn [b]\n  (let [rot (fn [xs] (apply map str xs))\n        fill (partial map (fn [x] (clojure.string/replace x #\" M|M \" \"MM\")))\n        solved? (fn [xs] (not (empty? (filter seq (map (partial re-seq #\"CM|MC\") xs)))))]\n    (loop [xs b\n           stop false]\n      (let [next (fill xs)]\n        (if (and stop (= next xs))\n          (or (solved? xs) (solved? (rot xs)))\n          (recur (rot next) (= next xs)))))))","user":"53ce4cd4e4b00fb29b2212ef"},{"code":"(fn find-cheese[coll]\r\n  (let [n (count coll) m (count (first coll))\r\n        f (fn [symb] (loop [x 0 y 0] (if (= symb\r\n                        (get (nth coll x) y)) [x y]\r\n                        (recur (cond (= y (dec m)) (inc x)\r\n                                :else x) (rem (inc y) m)))))\r\n        [xs ys] (f \\M)\r\n        [xf yf] (f \\C)\r\n        dir [[1 0][-1 0][0 1][0 -1]]]\r\n  ((fn bfs[used q]\r\n    (let [[x y] (first q)]\r\n    (cond (= [x y] [xf yf]) true\r\n          (empty? q) false\r\n          :else (let [add (->> dir \r\n            (map #(vector (+ x (first %)) (+ y (second %))))\r\n            (filter #(and (>= (first %) 0) (< (first %) n)\r\n                          (>= (last %) 0) (< (last %) m)))\r\n            (remove (fn [v] (some #(= v %) used)))\r\n            (remove #(= \\# (get (nth coll (first %)) (second %)))))]\r\n                (bfs (concat used add) (concat (rest q) add))))))\r\n   [[xs ys]] [[xs ys]])))","problem":117,"user":"5065bd94e4b0148eb3925aed"},{"code":"(fn cheesy-endpoint-reachable? [maze]\n  (letfn [\n          (normalize-maze \n            [maze]\n            (mapv #(mapv str (vec %)) maze)\n            )\n\n          (find-what \n            [maze what]\n            (let [x (.indexOf (map #(some #{what} %) maze) what)\n                  y (.indexOf (nth maze x) what)]\n              [x y]))\n\n          (find-mouse\n            [maze]\n            (find-what maze \"M\")\n            )\n\n          (find-cheese\n            [maze]\n            (find-what maze \"C\")\n            )\n\n          (reachable-cells [maze [x y]]\n            (set (for [[i j] [[1 0] [-1 0] [0 1] [0 -1]] :let [v (get-in maze [(+ x i) (+ y j)] \"#\")] :when (or (= \" \" v) (= \"C\" v))]\n                   [(+ x i) (+ y j)]\n                   )))]\n\n    (let [m (normalize-maze maze)\n          mouse (find-mouse m)\n          cheese (find-cheese m)]\n      (loop [cells #{mouse} seen #{mouse}]\n        (if-not (empty? cells)\n          (let [reachable (mapcat (partial reachable-cells m) cells)]\n            (if (some #{cheese} reachable)\n              true\n              (recur (apply disj (set reachable) seen) (into seen reachable))\n              )\n            )\n          false)))))","problem":117,"user":"5244a10de4b0d8acf9ed6ab3"},{"problem":117,"code":"(fn solve_maze [maze]\n  (let [m_pos (first (first (filter not-empty (for [[row_v row] (map-indexed vector maze)]\n                                                (for [[col_v value] (map-indexed vector row) :when (= value \\C)]\n                                                  [row_v col_v])))))\n        c_pos (first (first (filter not-empty (for [[row_v row] (map-indexed vector maze)]\n                                                (for [[col_v value] (map-indexed vector row) :when (= value \\M)]\n                                                  [row_v col_v])))))\n        emtpy_positions (set (apply concat (filter not-empty (for [[row_v row] (map-indexed vector maze)]\n                                                               (for [[col_v value] (map-indexed vector row) :when (or (= value \\ ) (= value \\M))]\n                                                                 [row_v col_v])))))\n        check_position (fn [d [a b] positions]\n                         (cond\n                           (= d :up) [[(inc a) b] (contains? positions [(inc a) b])]\n                           (= d :down) [[(dec a) b] (contains? positions [(dec a) b])]\n                           (= d :right) [[a (inc b)] (contains? positions [a (inc b)])]\n                           (= d :left) [[a (dec b)] (contains? positions [a (dec b)])]))]\n    (letfn [(traverse_maze [current_position free_positions]\n                           ;(println current_position free_positions)\n                           (cond\n                             (= current_position c_pos) true\n                             :else (let [[up_pos up_available] (check_position :up current_position free_positions)\n                                         [down_pos down_available] (check_position :down current_position free_positions)\n                                         [left_pos left_available] (check_position :left current_position free_positions)\n                                         [right_pos right_available] (check_position :right current_position free_positions)]\n                                     (or (if up_available (traverse_maze up_pos (disj free_positions up_pos)) false)\n                                         (if down_available (traverse_maze down_pos (disj free_positions down_pos)) false)\n                                         (if left_available (traverse_maze left_pos (disj free_positions left_pos)) false)\n                                         (if right_available (traverse_maze right_pos (disj free_positions right_pos)) false)))))]\n      (traverse_maze m_pos emtpy_positions))))","user":"5046f909e4b03b02161376b5"},{"problem":117,"code":"(fn find-cheese [maze]\n  (letfn [(get-at [maze [y x]]\n            (-> maze (get y) (get x)))\n\n          (idx-of [s c]\n            (loop [s s i 0] (when (seq s) (if (= c (first s)) i (recur (rest s) (inc i))))))\n          \n          (find-m [maze]\n            (first\n             (keep-indexed\n              (fn [y row] (when-let [x (idx-of row \\M)] [y x])) maze)))\n          \n          (neighbours [[y x]]\n            [[(dec y) x]\n             [(inc y) x]\n             [y (dec x)]\n             [y (inc x)]])\n          \n          (queue [coll]\n            (apply conj clojure.lang.PersistentQueue/EMPTY coll))]\n    \n    (loop [q (queue [(find-m maze)])\n           seen #{(peek q)}]\n      (let [pos (peek q)]\n        (cond (nil? pos) false\n              (= (get-at maze pos) \\C) true\n              :else\n              (let [edges (filter #(and (#{\\space \\C} (get-at maze %)) (not (seen %))) (neighbours pos))]\n                (recur (reduce conj (pop q) edges) (reduce conj seen edges))))))))","user":"60b7e2c5e4b0e0fa5f1b4252"},{"problem":117,"code":"(fn __\n  ([board]\n   (let [vboard (mapv vec board)\n         start (first (for [i (range 0 (count vboard))\n                            j (range 0 (count (first vboard)))\n                            :when (= \\M (get-in vboard [i j]))]\n                        [i j]))]\n     (boolean (__  vboard start #{start}))))\n\n  ([board cell visited]\n   (letfn [(circum [vsted cs]\n             (mapcat\n              #(for [[x y] [[-1 0] [1 0] [0 -1] [0 1]]\n                     :let [ix (+ (first %) x) jy (+ (second %) y)]\n                     :when\n                     (and\n                      (not (vsted [ix jy]))\n                      (not= nil (get-in board [ix jy]))\n                      (not= \\# (get-in board [ix jy]))\n                      )]\n                 [ix jy])\n              cs))]\n\n     (if (= \\C (get-in board cell)) true\n         (loop [cs (circum visited [cell])\n                vsted (conj visited cell)\n                ]\n           (cond\n            (empty? cs) false\n            (some (partial = \\C) (map #(get-in board %) cs)) true\n            :else\n            (recur (circum vsted cs) (into visited cs))))))))","user":"5a0ce1a5e4b04bbd27e6d9b7"},{"code":"(fn find-cheese [maze]\n  (let [\n    mouse     \\M\n    wall      \\#\n    cheese    \\C\n    \n    maze-height (count maze)\n    maze-width  (count (first maze))\n        \n    check     (fn [[y x]] (get-in maze [y x]))\n\n    init-mouse-pos (first\n                   (for [ line    (range maze-height)\n                          collumn (range maze-width )\n                          :when \n                          (= mouse (check [line collumn]))]\n                     [line collumn]))\n        \n    directions   #{:left :right :up :down}\n        \n        \n    opposite-dir  {:left  :right,\n                   :right :left ,\n                   :up    :down ,\n                   :down  :up    }\n\n    some-direction   (fn[dirs] (first dirs))\n        \n    other-directions (fn[dirs] (disj dirs (first dirs)))\n   \n                                \n    move       (fn [[y x :as mouse-pos] direction]\n                 (case direction\n                   :left  [   y   (- x 1)]\n                   :right [   y   (+ x 1)]\n                   :up    [(+ y 1)   x   ]\n                   :down  [(- y 1)   x   ]))\n        \n    \n    start-search\n     (fn cheese-search [[y x :as mouse-pos] searched dir-to-walk]\n       (let [\n          hit-wall?         (= wall   (check mouse-pos))\n          found-cheese?     (= cheese (check mouse-pos))\n          already-searched? (  searched mouse-pos  )\n          \n          out-of-maze?  (or (some neg? mouse-pos)\n                            (>= y maze-height)\n                            (>= x maze-width))]\n                            \n       (letfn [\n               \n          (solvable\n           ([]          {:solvable? true  :searched searched }) \n           ([searchs]   {:solvable? true  :searched searchs  }))\n               \n          (unsolvable\n           ([]          {:solvable? false  :searched searched }) \n           ([searchs]   {:solvable? false  :searched searchs  }))\n               \n          (inspect-pos[]\n            (cond\n               found-cheese?     :found\n               hit-wall?         :failed\n               out-of-maze?      :failed\n               already-searched? :failed\n               :else             :not-found))\n        \n          (search[]\n            (case (inspect-pos)\n                  :failed    (unsolvable)\n                  :found     (solvable)\n                  :not-found (next-search)))\n                  \n              \n          (next-search[]\n            (loop [ search-l    searched\n                    ds       dir-to-walk ]\n              (if (empty? ds)\n                   (unsolvable search-l) ; nowhere else to go.\n                  (let [search-result (continue-search\n                                        (some-direction ds) search-l)]\n                       (if (:solvable? search-result)\n                           (solvable search-l)\n                           (recur (:searched search-result)\n                                  (other-directions ds)))))))  ; try another direction,\n                                                               ; keeping track of previous\n                                                               ; visited spaces.\n          (continue-search[dir searchs]\n            (cheese-search\n              (move mouse-pos dir)\n              (conj searchs   mouse-pos) \n              (disj directions (opposite-dir dir))))]\n                  \n           (search))))]\n    \n    (:solvable? (start-search init-mouse-pos #{} directions))))","problem":117,"user":"52f818a6e4b047fd55836fcc"},{"problem":117,"code":"(letfn [(grow-cell [[x y]]\n          [[(inc x) y] [(dec x) y]\n           [x (inc y)] [x (dec y)]])\n\n        (grow-cells [{:keys [walls positions visited] :as game}]\n          (let [new-positions (->> positions\n                                   (mapcat grow-cell)\n                                   (remove visited)\n                                   (remove walls)\n                                   set)]\n            (-> game\n                (assoc :positions new-positions)\n                (update-in [:visited] clojure.set/union new-positions))))\n\n        (stuck? [{:keys [positions]}]\n          (empty? positions))\n\n        (win? [{:keys [cheese positions]}]\n          (some #{cheese} positions))\n\n        (solve [game]\n          (cond\n           (win? game) true\n           (stuck? game) false\n           :else (recur (grow-cells game))))\n\n        (make-borders [width height]\n          (set (for [x (range -1 (inc height))\n                     y (range -1 (inc width))\n                     :when (or (= -1 x) (= -1 y)\n                               (= height x) (= width y))]\n                 [x y])))\n\n        (make-game [map-strings]\n          (let [height (count map-strings)\n                width (count (first map-strings))\n                {:keys [walls cheese mouse]} (->> (for [[row-index row] (map-indexed vector map-strings)\n                                                        [column-index cell] (map-indexed vector (seq row))\n                                                        :let [coord [row-index column-index]]]\n                                                    (case cell\n                                                      \\M {:mouse coord}\n                                                      \\C {:cheese coord}\n                                                      \\# {:walls #{coord}}\n                                                      nil))\n                                                  (remove nil?)\n                                                  (apply merge-with clojure.set/union {}))\n                borders (make-borders width height)]\n            {:positions #{mouse}\n             :visited #{mouse}\n             :cheese cheese\n             :walls (clojure.set/union walls borders)}))]\n  (fn [map-strings] (->> map-strings make-game solve)))","user":"55f2e47de4b06e875b46ce4d"},{"problem":117,"code":"(fn[osa](\n         not( .contains  (apply str(let [ f1\n\t          ; \"Grow\" M and create strings again\n\t          (fn[sa2](\n\t\t          map (fn[x](apply str x))\n\t            (partition (- (count(first sa2)) 2)\n\t\t            (for [y (range 1 (dec(count sa2))) x (range 1 (dec(count(first sa2))))] \n\t\t\t\t          (if (= \\# (nth (nth sa2 y) x)) \"#\" \n\t\t\t\t            (if(or\n\t\t\t                  (= \\M (nth (nth sa2 (dec y)) x))\n\t\t\t                  (= \\M (nth (nth sa2 y) (dec x)))\n\t\t\t                  (= \\M (nth (nth sa2 (inc y)) x))\n\t\t\t                  (= \\M (nth (nth sa2 y) (inc x)))\n\t\t\t                  ) \"M\" (nth (nth sa2 y) x))\n\t\t\t\t          )\n\t\t            )\n\t            )\n\t         \n\t          ))\n           \n           f2\n\t          ; Maze with extra walls added\n\t          (fn[sa]\n\t          (flatten(conj [] (apply str(seq(repeat (+ (count (first sa)) 2) \"#\")))\n\t                (map (fn[s](str \"#\" s \"#\")) sa)\n\t                (apply str(seq(repeat (+ (count (first sa)) 2) \"#\"))))))\n\t          \n          ](\n             loop[tsa osa](\n               if(= (f1(f2 tsa)) tsa)\n\t               (f1(f2 tsa))\n\t               (recur (f1(f2 tsa)))\n             )\n             \n           )\n              \n        ))\n     \"C\")\n))","user":"56039843e4b04bb52996e1be"},{"problem":117,"code":"(fn [board] \n    (letfn [      \n        (tomap [board]\n            (let [w (count (board 0))\n                  s (clojure.string/join board)\n                  pos (group-by second (map-indexed vector s))\n                  spaces (set (map first (pos \\ )))\n                  mouse (((pos \\M) 0) 0)\n                  cheese (((pos \\C) 0) 0) \n                 ]\n                (bfs w (clojure.set/union spaces #{cheese}) mouse cheese)\n                ))\n                \n        (near [w v sp]\n            (let [ns (set [(+ v w) (- v w) (inc v) (dec v)]) ]\n                (clojure.set/intersection ns sp)))\n            \n        (bfs [w spaces m c]\n            (loop [visited #{}, q #{m}]\n                (if (empty? q) false\n                    (let [p (first q)\n                          ns (near w p spaces)]\n                        (if (contains? ns c) true\n                            (recur (clojure.set/union visited #{p})\n                               (clojure.set/union (set (rest q))\n                                    (clojure.set/difference ns visited))))))))\n                \n    ]           \n    (tomap board)))","user":"5eff6c0ee4b0cf489e8d7f11"},{"code":";; This was overkill for this problem, of course, but I had the functions.\n(fn prob-0117\n  [maze]\n  (letfn [(maze-to-map [mz]\n            (into (sorted-map) (for [ri (range (count mz))\n                                     :let [rw (vec (mz ri))]\n                                     ci (range (count rw))\n                                     :let [ch (rw ci)]\n                                     :when (not= ch \\#)]\n                                 [[ri ci] ch])))\n          \n          (cheese-problem [maze]\n            (let [moves [[-1 0] [+1 0] [0 -1] [0 +1]]\n                  mz-mp (maze-to-map maze)\n                  start (key (first   (filter #(= (val %) \\M) mz-mp)))\n                  goals (set (map key (filter #(= (val %) \\C) mz-mp)))]\n              \n              {:start start\n               :goal? (fn [state] (contains? goals state))\n               :cost  (fn [acts] (count acts))\n               :succ  (fn [state]\n                        (into [] (for [move moves\n                                       :let [dest (vec (map + state move))]\n                                       :when (contains? mz-mp dest)]\n                                   [move 1 dest])))\n               }))\n          \n          (sp-root [srch-prob]\n            {:state (:start srch-prob)\n             :actions    []\n             :path-cost  ((:cost srch-prob) [])})\n          \n          (sp-child [parent child-state child-action step-cost]\n            {:parent     parent\n             :state child-state\n             :actions    (conj (:actions parent) child-action)\n             :path-cost  (+ (:path-cost parent) step-cost)})\n          \n          (bfs [{:keys [start goal? cost succ] :as srch-prob}]\n            (loop [novel-nodes    [(sp-root srch-prob)]\n                   old-frontier   clojure.lang.PersistentQueue/EMPTY\n                   old-frontiered #{}]\n              \n              (let [frontier    (into old-frontier   novel-nodes)\n                    frontiered  (into old-frontiered (map :state novel-nodes))]\n                \n                (when-let [node (peek frontier)]\n                  (if (goal? (:state node))\n                    (:actions node)\n                    (let [next-nodes (for [[action action-cost new-state] (succ (:state node))\n                                           :when (not (contains? frontiered new-state))]\n                                       (sp-child node new-state action action-cost))]\n                      (recur next-nodes (pop frontier) frontiered)))))))\n          ]\n    \n    (not (nil? (bfs (cheese-problem maze))))))","problem":117,"user":"4f047c07535dcb61093f6bcd"},{"problem":117,"code":"(fn [field]\n    (let [rows (count field)\n          cols (count (first field))\n          m (into {} (for [i (range rows) j (range cols)] [[i j] (get-in field [i j])]))\n          valid-point (fn [[i j]] (and (< -1 i rows) (< -1 j cols) (not= \\# (m [i j]))))\n          steps (fn [[i j]] (filter valid-point [[(inc i) j] [(dec i) j] [i (inc j)] [i (dec j)]]))\n          f (fn f [p visited] (let [ps (filter #(not (contains? visited %)) (steps p))]\n                                 (cond\n                                   (= \\M (m p)) true\n                                   (empty? ps)  false\n                                   :else (some identity (map #(f % (conj visited %)) ps)))))\n          p-start (first (first (filter #(= \\C (second %)) m)))]\n  (boolean (f p-start #{p-start})) ))","user":"5a4de614e4b05d388ecb6bb1"},{"problem":117,"code":"(fn [l]\n   (let [l (mapv #(reduce conj [] %) l)\n         r (count l)\n         c (count (first l))\n         v #(let [[x y] %2]\n              (if (or (< x 0)\n                      (< y 0)\n                      (>= x r)\n                      (>= y c)) \\#\n                (get-in % %2)))]\n     (letfn [(f [l [x y :as p]]\n               (case (v l p)\n                 \\# false\n                 \\C true\n                 (let [l (assoc-in l p \\#)]\n                   (or (f l [(inc x) y])\n                       (f l [x (inc y)])\n                       (f l [(dec x) y])\n                       (f l [x (dec y)])))))]\n       (f l (first (for [x (range r)\n                     y (range c)\n                     :when (= (v l [x y]) \\M)]\n                 [x y]))))))","user":"57d9f603e4b0bd073c20240a"},{"code":"(fn lunch? [maze]\n  (let [hmap (apply merge-with into (for [[x row] (map-indexed vector maze)\n                                          [y val] (map-indexed vector row)]\n                                      {val [[x y]]}))\n        neighbors #(set (map (partial mapv + %) [[-1 0] [0 -1] [0 1] [1 0]]))\n        find-cheese (fn find-cheese [cheese pos unvisited]\n                      (if (= pos cheese)\n                        true\n                        (when-let [can-go (seq (filter (neighbors pos) unvisited))]\n                          (let [new-unvisited (apply disj unvisited can-go)]\n                            (boolean (some #(find-cheese cheese % new-unvisited) can-go))))))]\n    (find-cheese (first (hmap \\C)) (first (hmap \\M)) (set (concat (hmap \\space) (hmap \\C))))))","problem":117,"user":"50645e12e4b007509339a58a"},{"problem":117,"code":"(fn prob117\n  [maze]\n    (letfn [\n            ;; Return the neighboring cells for a given cell [r c]. Do not return diagnals.\n            ;;   For example, for the cell [3 1] return ([2 1] [3 0] [3 2] [4 1])\n            ;;         [2 1]\n            ;;   [3 0] [3 1] [3 2]\n            ;;         [4 1]\n            (neighbors\n              [[x y]]\n              (for [dx [-1 0 1]\n                    dy [-1 0 1]\n                    :when (and (or (= 0 dx) (= 0 dy))\n                               (not= 0 dx dy))]      \n                [(+ x dx) (+ y dy)]))\n\n            ;; A valid neighbor is one which contains a space or a C\n            (valid-neighbors\n              [m [r c]]\n              (letfn [(valid [[r c]]\n                        (let [v (get-in m [r c])] \n                          (or (= v \\space) \n                              (= v \\C))))]\n                (filter valid (neighbors [r c]))))\n            \n            ;; Find the first location with a given value. Used to find the mouse and the cheese\n            (find-element\n              [m val]\n              (first \n               (for [r (range (count m))\n                     c (range (count (first m)))\n                     :when (= val (get-in m [r c]))]\n                 [r c])))\n\n            ;; Return the location of the mouse M\n            (m-pos \n              [m]\n              (find-element m \\M))\n\n            ;; Return the location of the cheese C\n            (c-pos \n              [m]\n              (find-element m \\C))\n            \n            (search [[path] [r c]]\n              (if (= (c-pos maze) [r c])\n                [(conj path [r c])]  ;; found it\n                (let [neighbors' (valid-neighbors maze [r c])                ;; try neighbors\n                      neighbors (filter #(nil? (some #{%} path)) neighbors')]\n                  (if (seq neighbors)\n                    (reduce #(search %1 %2) [(conj path [r c])] neighbors)\n                    [(conj path [r c])]))\n                ))]\n      (let [mouse (m-pos maze)\n            cheese (c-pos maze)]\n           (not (empty? (filter #(= cheese %) (first (search [] mouse)))))\n        )))","user":"4ebbff41535dfed6da9c6d78"},{"problem":117,"code":"(let [size (fn [maze]\n               (let [y (count maze)\n                     x (count (first maze))]\n                 [y x]))\n\n        find-mouse (fn [maze]\n                     (first\n                      (let [[ym xm] (size maze)]\n                        (for [y (range ym)\n                              x (range xm)\n                              :when (= \\M (get-in maze [y x]))]\n                          [y x]))))\n\n        neighbors [[-1 0]\n                   [1 0]\n                   [0 -1]\n                   [0 1]]\n\n        moves (fn [pos maze]\n                (for [neighbor neighbors\n                      :let [pos (mapv + pos neighbor)]\n                      :when (and (every? (complement neg?) pos)\n                                 (every? identity (map < pos (size maze)))\n                                 (not= \\# (get-in maze pos)))]\n                  pos))]\n    (fn [maze]\n      (loop [ps [(find-mouse maze)]\n             seen #{}]\n        (cond\n          (some #(= \\C (get-in maze %)) ps) true\n          (empty? ps) false\n          :else (recur (clojure.set/difference (set (mapcat #(moves % maze) ps)) seen)\n                       (into seen ps))))))","user":"55c5b55fe4b0e31453f649b5"},{"code":"(fn [mz]   (let [m (vec (map (comp vec (partial replace {\\# 0 \\  1 \\M :m \\C :c})) mz))\n        f #(some #{(get-in m %)} [:m :c 1])\n        ks [:m :c]\n        ys (map (fn [k] (count (take-while #(not-any? #{k} %) m))) ks)\n        [ms c] (map (fn [k y] #{[y (.indexOf (get m y) k)]}) ks ys)\n        ds [[1 0] [-1 0] [0 1] [0 -1]]\n        r (->> (iterate (fn [mc]\n                            (let [r (->> (for [d ds\n                                                 ms mc]\n                                             (map + ms d))\n                                           (filter f)\n                                           (into #{})\n                                           (clojure.set/union mc))]\n                              (if-not (= mc r)\n                                r)))\n                          ms)\n                 (take-while identity)\n                 last)]\n    (not (nil? (some c r)))))","problem":117,"user":"4e823ed7535db62dc21a62c7"},{"problem":117,"code":"(fn valid-maze\n  [maze]\n  (let [maze-depth (count maze)\n        maze-width (count (first maze))\n        find-position-of (fn [i]\n                           (loop [d 0 w 0]\n                             (if (= i (get-in maze [d w]))\n                               [d w]\n                               (let [[next-d next-w] (if (< (inc w) maze-width)\n                                                       [d (inc w)]\n                                                       [(inc d) 0])]\n                                 (recur next-d next-w)))))\n        mouse (find-position-of \\M)\n        cheese (find-position-of \\C)\n        next-avalible-paths (fn next-avalible-paths [path [x y]]\n                              (->> [[x (inc y)] [x (dec y)] [(inc x) y] [(dec x) y]]\n                                   (filter (complement path))\n                                   (filter (fn [[d w]] (and (< -1 d maze-depth)\n                                                            (< -1 w maze-width))))\n                                   (filter #(not= \\# (get-in maze %)))))\n        can-find-the-cheese (fn can-find-the-cheese\n                              [path position]\n                              (if (= position cheese)\n                                true\n                                (boolean (some #(can-find-the-cheese (clojure.set/union\n                                                                      path\n                                                                      (set (next-avalible-paths path position))) %)\n                                          (next-avalible-paths path position)))))]\n    (can-find-the-cheese #{mouse} mouse)))","user":"5125029de4b0ce9225d2ed3e"},{"problem":117,"code":"; still not really the Clojure Way...\n;http://en.wikipedia.org/wiki/Maze_solving_algorithm#Recursive_algorithm\n(fn reresolvify [maze]\n  (let\n      [width (count (first maze))\n       height (count maze)\n       amaze (vec (map #(vec (map atom %)) maze))]\n    (letfn\n        [(recursolve [[r c]]\n           (let [v @(get-in amaze [r c])]\n             (if (= v \\C) true                   ; cheese!\n               (and\n                (not (= v \\#))                   ; wall\n                (not (= v \\.))                   ; visited\n                (reset! (get-in amaze [r c]) \\.) ; mark as visited\n                (or\n                 (and (not (= r 0))            (recursolve [(dec r) c]))\n                 (and (not (= r (dec height))) (recursolve [(inc r) c]))\n                 (and (not (= c 0))            (recursolve [r (dec c)]))\n                 (and (not (= c (dec width)))  (recursolve [r (inc c)])))))))]\n      (recursolve\n       (first\n        (for\n            [r (range height) c (range width)\n             :when (= \\M (get-in maze [r c]))]\n          [r c]))))))","user":"54e3df6ae4b024c67c0cf7e3"},{"problem":117,"code":"(fn solvable? [m]\n  (letfn [(neighbors [m p]\n            (->> [[0 -1] [1 0] [0 1] [-1 0]]\n                 (map #(map + p %))\n                 (filter #(not (nil? (get-in m %))))))\n          (fringe [m]\n            (for [y (range (count m))\n                  x (range (count (first m)))\n                  :when (and (not (#{\\M \\#} (get-in m [y x])))\n                             (some #(= \\M (get-in m %)) (neighbors m [y x])))]\n              [y x]))\n          ]\n    (->> (iterate (fn [m] (reduce #(assoc-in %1 %2 \\M) m (fringe m))) (mapv vec m))\n         (drop-while #(seq (fringe %)))\n         first flatten set\n         (#(not (contains? % \\C))))))","user":"53b39d82e4b047364c0444a6"},{"code":"(fn [maze]\n  (let [ps (set (for [y (range (count maze)) x (range (count (maze 0)))] [x y]))\n        at (fn [[x y]] (nth (nth maze y) x))\n        to (fn [p d] (map + p (d {:n [0 -1] :s [0 1] :w [-1 0] :e [1 0]})))\n        m  (some #(if (= (at %) \\M) % false) ps)\n        pa (atom #{m})\n        ms (fn [p] (set (filter #(and (ps %) (not= (at %) \\#) (nil? (@pa %))) (for [d [:n :s :w :e]] (to p d)))))]\n    (letfn [(go [m fu]\n                (cond (= (at m) \\C) true\n                      (empty? fu) false\n                      true (some #(do (swap! pa conj %) (go % (into (apply disj fu % @pa) (ms %)))) fu)))]\n      (true? (go m (ms m))))))","problem":117,"user":"4fdbc075e4b05e33b9224f61"},{"problem":117,"code":"(fn solvable-maze? [maze]\n  (letfn [(neighbors [[row col]]\n            [[(inc row) col] [(dec row) col] [row (inc col)] [row (dec col)]])]\n    (let [elements {\\space :space \\# :wall \\M :mouse \\C :cheese}\n          elements-in-cells (for [row (range (count maze))\n                                  col (range (count (nth maze row)))\n                                  :let [char (get-in maze [row col])]]\n                              {(elements char) [row col]})\n          maze-map (apply merge-with conj {:wall [] :space []} elements-in-cells)\n          spaces-and-cheese (conj (set (:space maze-map)) (:cheese maze-map))]\n      (loop [horizon [(:mouse maze-map)] \n             visited #{}]\n        (cond (empty? horizon) false\n              (= (first horizon) (:cheese maze-map)) true\n              :else (let [visited (conj visited (first horizon))\n                          reachable-cells (filter spaces-and-cheese (neighbors (first horizon)))\n                          horizon (concat (rest horizon) (remove visited reachable-cells))]\n                      (recur horizon visited)))))))","user":"58ed713de4b056aecfd47d84"},{"code":"(fn maze-solvable? [maze]\n  (let [m (count maze)\n        n (count (first maze))\n        cells (range (* n m))\n        maze (apply str maze)\n        neighbors (mapv #(vector (- % n) (+ % 1) (+ % n) (- % 1)) cells)\n        mget (fn [ind] (get maze ind \\#))\n        cheese  (first (filter #(= (mget %) \\C) cells))]\n    (loop [blanks (set (filter #(= (mget %) \\space) cells))\n           mfront (set (filter #(= (mget %) \\M) cells))]\n      (cond\n       (empty? mfront)\n        false\n       (some #(contains? mfront %) (neighbors cheese))\n        true\n       :else\n        (let [more (filter\n                    (fn [i]\n                      (some #(contains? mfront %) (neighbors i)))\n                    blanks)\n              surrounded (filter\n                          (fn [i]\n                            (not-every? #(contains? mfront %) (neighbors i)))\n                          mfront)]\n          (recur (apply disj blanks more)\n                 (into (apply disj mfront surrounded) more)))))))","problem":117,"user":"5095f761e4b0ba05ca7aebfd"},{"problem":117,"code":"(fn [v]\n    (let [\n          w (count (first v))\n          h (count v) \n          isValid (fn [p]\n                    (and\n                      (>= (first p) 0)\n                      (>= (second p) 0)\n                      (< (first p) h)\n                      (< (second p) w)\n                      (not (= (get-in v p) \\#))\n                      )\n                    )\n          up (fn [p] (vector (+ 1 (first p)) (second p)))\n          down (fn [p] (vector (- (first p) 1) (second p)))\n          left (fn [p] (vector (first p) (- (second p) 1)))\n          right (fn [p] (vector (first p) (+ (second p) 1)))\n          mouse (loop [y 0 x 0]\n                  (if (= (get-in v [y x]) \\C)\n                    [y x]\n                    (if (< x w)\n                      (recur y (+ 1 x))\n                      (recur (+ 1 y) 0)\n                      )\n                    )\n                  )\n          checkPos (fn q[p r]\n                     (if (= (get-in v p) \\M)\n                       true \n                       (let [m (vector (right p) (down p) (up p) (left p))]\n                         (not (every? false? (map #(and (isValid %) (not (contains? r %)) (q % (conj r %))) m)))\n                         )\n                       )\n                     )\n          ]\n      (checkPos mouse #{})\n      )\n  )","user":"54b90836e4b0ed20f4ff6e9d"},{"problem":117,"code":"(fn [h] (letfn [(ind [v i j] (get (get v i) j))\n                (adj [v i j]\n   (for [x [-1 0 1] y  [-1 0 1] :when (and (not= (Math/abs x) (Math/abs y))\n                                           (let [w  (ind h (+ x i) (+ y j))]\n                                             (and w (or  (= w \\space) (= w \\C)))\n                                            )\n                                           )\n         ] [(+ x i) (+ y j)]))\n                (clj [v s] (let [c1 (set (mapcat #(adj v (first %) (last %)) s))]\n                                (if (= (into s c1) s) s (recur v (into s c1)))) )]\n          (let [p (first (filter (fn [[x y]] (= (ind h x y) \\M)) (for [i (range (count h)) j (range (count (h 0)))] [i j])))\n                cl (clj h (set [p]))] \n            (if (first (filter (fn [[x y]] (= (ind h x y) \\C)) cl)) true false))\n      ))","user":"5c379636e4b0d62ef62d9f76"},{"problem":117,"code":"(fn self [in-board]\n    (let [board (mapv vec in-board)\n          neighbor-rel-indices [        [0  1]\n                                [-1  0]        [1  0]\n                                [0 -1]       ]\n          active-values #{\\M \\C \\space}\n          useable-board (fn [b] (for [y (range (count b))\n                                      x (range (count (b 0)))\n                                      :let [v (get-in b [y x])]\n                                      :when (active-values v)\n                                      :let [active-neighors (for [[ri rj] neighbor-rel-indices\n                                                                  :let [[i j] [(+ x ri) (+ y rj)]]\n                                                                  :let [nv (get-in b [j i])]\n                                                                  :when (not (nil? nv))\n                                                                  :when (active-values nv)]\n                                                              [[j i] nv])]]\n                                  [[[y x] v] (vec active-neighors)]\n                                  ))\n          live-tiles (useable-board board)\n          node->neighbors (into {} live-tiles)\n          find-tile (fn [v'] (some (fn [[[[_ _] v]:as all]] (if (= v v') all)) live-tiles))\n          M (find-tile \\C)\n          C (find-tile \\M)\n          next-nodes (fn [path]\n                       (let [path-nodes (set path)\n                             valid-next? (fn [n] (not (path-nodes n)))\n                             neighbors (node->neighbors (last path))\n                             ret (filter valid-next? neighbors)]\n                         ret))\n          m-to-c? (fn self [path]\n                    (let [nxt (next-nodes path)]\n                      (if-not (empty? nxt)\n                          (mapcat (fn [x] (self (conj path x))) nxt)\n                          [(some #(= % (first C)) path)]\n                        )))\n\n          ]\n      (true? (some identity (m-to-c? [(first M)])))\n      ))","user":"52ffb7f2e4b0d8b024fd370b"},{"problem":117,"code":"(fn [rows]\n   (let [parse-maze-step (fn [maze [[x y] cell]]\n                        (condp = cell\n                          \\M (-> maze (assoc :mouse [x y]) (assoc-in [:maze x y] true))\n                          \\C (-> maze (assoc :cheese [x y]) (assoc-in [:maze x y] true))\n                          \\space (assoc-in maze [:maze x y] true) \n                          \\# (assoc-in maze [:maze x y] false)))\n         ;; converts string definition into \n         ;;   {:width N\n         ;;    :height N\n         ;;    :maze {0 {0 false 1 true 2 false} 1 ...} \n         ;;    :mouse [0 0]\n         ;;    :cheese [0 0]}\n         ;; where walls are false in the maze\n         parse-maze (fn [rows]\n                      (let [width (count (first rows))\n                            height (count rows)]\n\n                        (reduce parse-maze-step {:width width :height height}\n                          (for [[y row] (map-indexed vector rows)\n                                [x cell] (map-indexed vector row)]  \n                            [[x y] cell])))) \n         \n         ;; returns a new maze moved by dx dy if valid, otherwise nil.  Sets where the mouse has been to false (ie wall)\n         move (fn [maze dx dy]\n                (let [[mx my] (:mouse maze)\n                      x (+ dx mx)\n                      y (+ dy my)]\n                  (when (and (< -1 x (:width maze))\n                             (< -1 y (:height maze))\n                             (get-in maze [:maze x y]))\n                    (-> maze\n                      (assoc :mouse [x y])\n                      (assoc-in [:maze mx my] false)))))\n         \n         ;; returns a list of valid moves for a given maze\n         valid-moves (fn [maze]\n                       (cond \n                         (nil? maze) '()\n                         :else\n                         (let [moves (filter (complement nil?) \n                                       [(move maze  0 -1)\n                                        (move maze  0  1)\n                                        (move maze -1  0)\n                                        (move maze  1  0)])]\n                           moves)))\n\n         ;; takes a seq of mazes to compute all moves for a given maze, avoiding repeating locations found with a trail of crumbs\n         moves-seq (fn moves-seq\n                     ([init] (moves-seq [init] #{}))\n                     ([steps crumbs]\n                      (concat steps\n                        (lazy-seq\n                          (let [next-steps (mapcat valid-moves steps)\n                                next-steps (filter #(not (contains? crumbs (:mouse %))) next-steps)]\n                            (cond \n                              (empty? next-steps) '()\n                              :else (moves-seq next-steps (into crumbs (map :mouse next-steps)))))))))]\n    ;; drop until all moves are consumed (nil) or mouse is at the goal (not nil)\n    (let [maze (parse-maze rows)\n          goal (:cheese maze)]\n      (->> (moves-seq maze)\n           (drop-while (fn [step] (println (:mouse step)) (not= (:mouse step) goal)))\n           (first)\n           (not= nil)))))","user":"504e71cbe4b0f6ff3350c4b3"},{"code":"(letfn [(maze-get [[y x] m]\n            (if (and (< -1 y (count m))\n                     (< -1 x (count (first m))))\n              (nth (m y) x)\n              \\#))\n          (maze-put [[y x] m]\n            (if (not= \\# (maze-get [y x] m))\n              (update-in m [y] #(reduce str (assoc (vec %) x \\M)))\n              m))\n          (paint [m [y x]]\n            (if (= (maze-get [y x] m) \\M)\n              (reduce (fn [r [y0 x0]] (maze-put [(+ y y0) (+ x x0)] r))\n                      m\n                      [[-1 0] [1 0] [0 -1] [0 1]])\n              m))\n          (paint-all [m]\n            (reduce paint\n                    m\n                    (for [y (range 0 (count m)) x (range 0 (count (first m)))] [y x])))]\n    (fn [m]\n      (let [painted (ffirst (drop-while #(apply not= %) (partition 2 (iterate paint-all m))))]\n        (not (.contains (reduce str painted) \"C\")))))","problem":117,"user":"4ee88bfb535d93acb0a66881"},{"code":"(fn [m]\n  (let [m (map #(str \"#\" % \"#\") m)\n        w (count (first m))\n        m (concat [(apply str (repeat w \"#\"))] m [(apply str (repeat w \"#\"))])\n        h (count m)\n        chk (fn [m c] (reduce \n                        (fn [s r] (+ s (count (filter #(= c %) r))))\n                        0 m))\n        move (fn [s] (if (some #(= \\M %) s)\n                        (apply str (repeat (count s) \\M))\n                        s))\n        step (fn [m] (map \n                        (fn [r]\n                          (->>\n                            (interleave\n                              (cons \"_\" (map move (re-seq #\"[\\w\\s]+\" r)))\n                              (re-seq #\"#+\" r))\n                            (rest)\n                            (apply str)\n                          ))\n                        m))]\n    (loop [m m n 0]\n      (if (< (chk m \\C) 1)\n        true\n        (if (= (chk m \\M) n)\n          false\n          (recur (apply map str (step (apply map str (step m))))\n                (chk m \\M)))))))","problem":117,"user":"528652fbe4b0239c8a67ae14"},{"code":"(fn [maze]\n  (let [b (to-array (map char-array maze))\n      m (first (filter #(not= (first %) -1) (map-indexed #(list (.indexOf %2 \"M\") %1) maze)))\n      moves [[-1 0] [1 0] [0 1] [0 -1]]\n      get-pos (fn [p] (let [[x y] p] (aget b y x)))\n      wall? (fn [p] (= (get-pos p) \\#))\n      cheese? (fn [p] (= (get-pos p) \\C))\n      marked? (fn [p] (= (get-pos p) \\M))\n      legal? (fn [p] (let [[x y] p] (and (>= x 0) (>= y 0) (< x (count (first maze))) (< y (count maze)) (not (marked? p)) (not (wall? p)))))\n      search (fn []\n        (loop [q (list m)]\n          (prn q)\n          (if (empty? q)\n            false\n            (let [p (first q)]\n              (if (cheese? p)\n                true\n                (do\n                  (aset b (second p) (first p) \\M)\n                  (let [newpos (filter legal? (map #(map + p %) moves))]\n                    (recur (rest (distinct (concat q newpos)))))))))))]\n        (search)))","problem":117,"user":"4e9c81e8535dbda64a6f6b80"},{"problem":117,"code":"(fn [m]\n  (let [width (count (first m))\n        height (count m)\n        neigbours-f (fn [p] (filter (fn [[x y]] (and (< -1 x width) (< -1 y height)))\n                              (map #(vec (map + p %)) [[-1 0] [1 0] [0 1] [0 -1]])))\n        mcs (for [x (range width) y (range height) :when (not= \\# (get-in m [y x]))]\n              [[x y] ({\\M :mouse \\space :space \\C :cheese} (get-in m [y x]))])\n        coords (set (map #(% 0) mcs))\n        mouse-location ((first (filter #(= :mouse (% 1)) mcs)) 0)\n        cheese-location ((first (filter #(= :cheese (% 1)) mcs)) 0)\n        ]\n    (letfn [(find-neightbours [location connections]\n              (let [neighbours (set (filter #(and (not (connections %)) (coords %)) (neigbours-f location)))\n                    all-connections (into connections neighbours)\n                    ]\n                (into neighbours (apply concat (for [n neighbours]\n                                                 (find-neightbours n all-connections))))\n                )\n              )]\n      (boolean ((find-neightbours mouse-location #{}) cheese-location))\n      )))","user":"53b530c6e4b047364c0444bc"},{"problem":117,"code":"(fn [maze]\n  (let [height (count maze)\n        width (count (first maze))\n        mouse-pos (let [pos (.indexOf (apply str maze) \"M\")]\n                        [(quot pos width) (mod pos width)])\n        neighbors (fn [pos]\n                    (map #(mapv + pos %) [[-1 0] [1 0] [0 -1] [0 1]]))\n        maze-cell (fn [pos maze]\n                    (get-in maze pos \\#))\n        dot-col (fn [row col]\n                  (str (subs row 0 col) \\. (subs row (inc col))))\n        dot-maze (fn [[row col] maze]\n                   (update-in maze [row] dot-col col))]\n    (loop [cells (neighbors mouse-pos)\n           maze maze]\n      (if (empty? cells)\n        false\n        (let [pos (first cells)\n              cell (maze-cell pos maze)]\n          (cond\n           (= \\C cell) true\n           (= \\space cell) (recur (into (rest cells) (neighbors pos)) (dot-maze pos maze))\n           :else (recur (rest cells) maze)))))))","user":"55ccdc6be4b0e31453f64a18"},{"code":"(fn [mz]\n  (letfn [(maze-ends [mz]\n            (apply merge\n                   (apply concat\n                          (keep-indexed\n                           (fn [i row]\n                             (keep-indexed\n                              (fn [j elt] (cond\n                                          (= \\M elt) {:start [i j]}\n                                          (= \\C elt) {:end   [i j]}))\n                              row))\n                           mz))))\n          (maze-rooms [mz]\n            {:rooms\n             (apply concat\n                    (keep-indexed\n                     (fn [i row]\n                       (keep-indexed\n                        (fn [j elt] (cond\n                                    (= \\M elt) [i j]\n                                    (= \\C elt) [i j]\n                                    (= \\space elt) [i j]))\n                        row))\n                     mz))})\n          (maze-build [mz]\n            (merge (maze-ends mz) (maze-rooms mz)))\n          (valid-moves [pos mz]\n            (let [i (first pos)\n                  j (second pos)\n                  moves #{[(dec i) j] [(inc i) j]\n                          [i (dec j)] [i (inc j)]}]\n              (clojure.set/intersection moves (set (:rooms mz)))))\n          (maze-rem [mz coll]\n            (assoc mz\n              :rooms\n              (clojure.set/difference\n               (set (:rooms mz))\n               (set coll))))\n          (amaze [mz]\n            (if (or (not mz) (empty? mz)) false\n                (let [pos (:start mz)\n                      moves (valid-moves pos mz)\n                      mz (maze-rem mz moves)]\n                  (cond\n                   (empty? moves) false\n                   (moves (:end mz)) true\n                   :else (reduce #(or % %2)\n                                 (for [m moves]\n                                   (amaze (assoc mz :start m))))))))]\n    (amaze (maze-build mz))))","problem":117,"user":"524ae8e6e4b09eba1c0223b5"},{"problem":117,"code":"(fn [grid]\n  (let [neighbors (fn [[x y]] [[(inc x) y] [(dec x) y] [x (inc y)] [x (dec y)]])\n        parts (for [y (range (count grid))\n                    x (range (count (nth grid y)))\n                    :let [e (get-in grid [y x])]]\n                {({\\C :cat \\M :mouse \\# :wall \\space :space} e) [x y]})\n        game (apply merge-with conj {:wall [] :space []} parts)\n        spaces (conj (set (:space game)) (:mouse game))]\n    (loop [open [(:cat game)] visited #{}]\n      (cond\n        (empty? open) false\n        (= (first open) (:mouse game)) true\n        :else (let [visited (conj visited (first open))\n                    neigh (filter spaces (neighbors (first open)))\n                    neigh (remove visited neigh)\n                    open (concat (rest open) (remove visited neigh))]\n                (recur open visited))))))","user":"5c2649c8e4b07e362c2305bf"},{"code":"(fn [mz]\n          (let [ch (fn [m s]\n                     (let [r (-> m first count)\n                           c (-> m count)]\n                       (first\n                        (for [x (range r)\n                              y (range c)\n                              :when (= s (get-in m [y x]))]\n                          [y x]))))\n                nbs (fn [m [y x]]\n                      (let [r (-> m first count)\n                            c (-> m count)\n                            x- (dec x)\n                            x+ (inc x)\n                            y- (dec y)\n                            y+ (inc y)]\n                        (->> [[y- x] [y+ x] [y x+] [y x-]] ;; N S E W\n                             (filter (fn [[y x]] (and (<= 0 x) (<= 0 y) (< x r) (< y c)))))))\n                rg (fn [x y]\n                     (let [d (- x y)]\n                       (cond (pos? d) (->> x inc (range y))\n                             (neg? d) (->> y inc (range x))\n                             :else    [])))\n                >x? (fn [mz [_ cx :as c] [_ dx :as d]]\n                      (let [r (rg cx dx)\n                            m (for [x r]\n                                (map (comp #{\\space \\C \\M} #(get-in % [x])) mz))]\n                        (->> (for [x (-> m first count range)]\n                               (map #(nth % x) m))\n                             (map (comp (partial map (partial every? identity))\n                                        (fn [v] (map (fn [& r] r) v (rest v)))))\n                             (apply map (fn [& v] (some true? v)))\n                             (every? true?))))\n                >y? (fn [mz [cy _ :as c] [dy _ :as d]]\n                      (let [r (rg cy dy)]\n                        (->> r\n                             (map (fn [v] (->> [v]\n                                              (get-in mz)\n                                              (filter #{\\space \\C \\M})\n                                              (some #{\\space \\C \\M}))))\n                             (every? identity))))\n                nxm (fn [m [y x :as c]]\n                      (->> c\n                           (nbs m)\n                           (filter (comp #{\\space \\C} (partial get-in m)))))\n                ms (ch mz \\M)\n                c (ch mz \\C)]\n            (and (->> c (nxm mz) empty? not)\n                 (>x? mz ms c)\n                 (>y? mz ms c))))","problem":117,"user":"4ee9ddb8535d93acb0a66896"},{"code":"(fn fc\n  ([board] (fc board true))\n  ([board fs]\n    (let\n      [pb ; partition each row into runs of non-walls\n        (map (partial partition-by #(= \\# %)) board)\n      ,got-cheese ; if any run contains M and C, cheese is accessible\n        (some\n          (partial some\n            #( and (some #{\\M} %) (some #{\\C} %) ))\n          pb)\n      ,nb ; fill any run containing M or C with that letter\n        (map (partial map\n          #(cond\n            (some #{\\M} %) (repeat (count %) \\M)\n            (some #{\\C} %) (repeat (count %) \\C)\n            true %))\n        pb)\n      ,tnb ; transpose for next step\n        (apply map list (map flatten nb))\n      ]\n      (cond\n        got-cheese true\n        (and (not fs) (= pb nb)) false\n        true (fc tnb false)))))","problem":117,"user":"4f1b92d1535d64f60314647b"},{"code":"(fn solvable-maze? [in]\n  (let [\n       maze (map vec in)\n       move (fn [mtx] (map (fn [z] (mapcat #(if (> (.indexOf % \\M) -1) (repeat (count %) \\M) %) (partition-by #(or (= % \\M) (= % \\space)) z))) mtx ))\n       transpose (fn [mtx] (vec (apply map vector mtx)))\n       check (fn [mtx] (boolean (some identity (map #(or (> (.indexOf (apply str %) \"MC\") -1) (> (.indexOf (apply str %) \"CM\") -1)) mtx))))\n       maze' (->> maze move transpose move transpose)\n       win (or (check maze') (check (transpose maze')))\n       same (= maze maze')\n       ]\n    (print maze' \"\\n\\n\\n\")\n    (cond\n      win true\n      same false\n      :else (solvable-maze? maze')\n      )\n    ))","problem":117,"user":"53307da1e4b019098a6f8b5e"},{"code":"(fn forsci [m]\n  (let [rows (range (count m)) cols (range (count (first m)))\n        dm (for [x rows y cols] [[x y] (nth (m x) y)])\n        mouse (some #(and (= \\M (% 1)) (% 0)) dm)\n        cheese (some #(and (= \\C (% 1)) (% 0)) dm)\n        sps (map first (filter #(#{\\space \\C} (% 1)) dm))\n        adj? (fn [[x y] [a b]] (or (and (= x a) (or (= (inc y) b) (= (dec y) b)))\n                                   (and (= y b) (or (= (inc x) a) (= (dec x) a)))))\n          csps (fn [p] (filter #(adj? p %) sps))]\n      (loop [cp #{mouse} dp #{mouse}]\n        (let [nsps (into #{} (filter #(not (dp %)) (mapcat csps cp)))]\n          (if (empty? nsps) false\n            (if (nsps cheese) true\n              (recur nsps (reduce conj dp nsps))))))))","problem":117,"user":"5267d9bde4b03e8d9a4a7188"},{"problem":117,"code":"(fn [b](let [ms (loop [y 0]\n                   (let [x (.indexOf (b y) \"M\")]\n                     (cond\n                       (< -1 x) [y x]\n                       :else (recur (inc y)))))\n              f (fn [[x y]]\n                   (filter\n                    #(let [a (get-in b %)] (or (= a \\ ) (= a \\C)))\n                    [[x (inc y)] [(inc x) y] [x (dec y)] [(dec x) y]]))]\n          (loop [n #{ms}\n                 visited #{}]\n            (if (empty? n) false\n              (let [v* (into visited n)\n                    n* (clojure.set/difference (set(mapcat f n)) v* )]\n                (if (empty?(filter #(= \\C (get-in b %))n*))(recur n* v*)true)\n                )))))","user":"566a3a26e4b0a866af689699"},{"problem":117,"code":"(fn [maze]\n  (letfn [(explore [[x y]]\n                   (for [[x y] [[(dec x) y] [x (dec y)]\n                               [(inc x) y] [x (inc y)]]]\n                     (case (get-in maze [y x] \\#)\n                       \\space [x y]\n                       \\C :cheese\n                       :wall)))\n          (find-mouse []\n                      (for [y (range (count maze))\n                            x (range (count (first maze)))\n                            :when (= \\M (get-in maze [y x]))]\n                        [x y]))]\n  (loop [[node & to-visit] (find-mouse)\n         visited #{}]\n    (cond (nil? node) false\n          (= node :cheese) true\n          (= node :wall) (recur to-visit visited)\n          (visited node) (recur to-visit visited)\n          :else (recur (concat (explore node) to-visit)\n                       (conj visited node))))))","user":"5ad63a34e4b0ea6055cfac01"},{"problem":117,"code":"(fn [m]\n\n  (let \n    [transpose (fn [vs] (mapv #(apply str %) (apply map vector vs)))\n     seen-boards (atom {})\n     tostr #(apply str %)\n     valid-single-maze (fn [m] (some #(or (.contains % \"MC\") (.contains % \"CM\"))  m))\n     valid-maze (fn [m] (or (valid-single-maze m) (valid-single-maze (transpose m))))\n     stepr (fn [m] (mapv #(.replace % \"M \" \" M\") m))\n     stepl (fn [m] (mapv #(.replace % \" M\" \"M \") m))\n     stepu #(transpose (stepl (transpose %)))\n     stepd #(transpose (stepr (transpose %)))\n     process (fn proc [m]\n               (when-not (@seen-boards (tostr m))\n\n                  (swap! seen-boards #(assoc % (tostr m) true))\n                  (or (valid-maze m) \n                      (proc (stepl m)) (proc (stepr m)) (proc (stepu m)) (proc (stepd m)))\n                )\n             )\n    ]\n            \n  \n   (true? (process m))\n    \n  )\n  \n)","user":"53da2839e4b0e771c3025489"},{"code":"(fn lucky-mouse? [maze]\n  (letfn [(movable?  [pos]   (contains? #{\\space \\C} (get-in maze pos)))\n          (neighbors [[i j]] [[(inc i) j] [i (inc j)] [(dec i) j] [i (dec j)]])\n          (movable-neighbors [pos] (filter movable? (neighbors pos)))\n          (find-pos [c]\n            (first (for [i (range (count maze)), j (range (count (first maze)))\n                         :when (= c (get-in maze [i j]))]\n                     [i j])))\n          (move [ps] (into ps (mapcat movable-neighbors ps)))\n          (fixed-point [f x] (let [y (f x)] (if (= x y) y (recur f y))))]\n    (contains? (fixed-point move #{(find-pos \\M)}) (find-pos \\C))))","problem":117,"user":"50586354e4b06522596eba78"},{"problem":117,"code":"(fn [rs]\n (let [rs (map (partial map char) rs)\n       spread (fn [s] \n               (->> (flatten [0 s 0])\n                    (partition 3 1)\n                    (map (fn [[l x r]]\n                          (cond\n                            (= x \\M) \\M\n                            (and\n                             (= x \\space)\n                             (or\n                              (= l \\M)\n                              (= r \\M))) \\M\n                            (and\n                             (= x \\C)\n                             (or\n                              (= l \\M)\n                              (= r \\M))) :W\n                           :else x))))) \n       t #(apply map list %)\n       do-spread (fn [s] (->> (map spread s)\n                              t\n                              (map spread)\n                              t))]\n   (->> (iterate do-spread rs)\n        (partition 2 1)\n        (drop-while (fn [[a b]] (not= a b)))\n        ffirst\n        (map #(some (partial = :W) %))\n        (some true?)\n        boolean)))","user":"56b86e64e4b0f26550335924"},{"code":"(fn solvable-maze? [maze]\n  (letfn [(get-pos [row col]\n            (get (get maze row nil) col \\#))\n          (is-empty? [row col]\n            (not (= (get-pos row col) \\#)))\n          (my-index-of [coll idx item]\n            (if (>= idx (count coll))\n              -1\n              (if (= (nth coll idx) item)\n                idx\n                (recur coll (inc idx) item))))\n          (starting-position [row]\n            (let [row-line (vec (get maze row))\n                  col (my-index-of row-line 0 \\M)]\n              (if (< col 0)\n                (starting-position (inc row))\n                (vector row col))))\n          (is-not-visited? [visited-positions row col]\n            (nil? (get (get visited-positions row #{}) col)))\n          (solution-exists? [visited-positions row col]\n            (if (= (get-pos row col) \\C)\n              true\n              (let [moves '([0 1] [1 0] [0 -1] [-1 0])\n                    possible-moves (filter #(let [row- (+ row (first %))\n                                                  col- (+ col (second %))]\n                                              (and (is-not-visited? visited-positions row- col-)\n                                                   (is-empty? row- col-))) moves)\n                    new-visited-positions (assoc visited-positions row (conj (get visited-positions row #{}) col))]\n                (if (empty? possible-moves)\n                  { row #{col} }\n                  (loop [visited new-visited-positions, moves possible-moves]\n                    (if (empty? moves)\n                      visited\n                      (let [move (first moves)\n                            rval (solution-exists? visited (+ row (first move)) (+ col (second move)))]\n                        (if (true? rval)\n                          true\n                          (recur (into visited rval) (rest moves))))))))))]\n    (let [start (starting-position 0)]\n      (true? (solution-exists? {} (first start) (second start))))))","problem":117,"user":"4ff355a1e4b0678c553fc34d"},{"code":"(fn route?\n  ([m]\n     (let [find-cat (fn [m] (remove nil?\n                                   (for [y (range 0 (count m))\n                                         x (range 0 (count (first m)))]\n                                     (when (= \\C (get-in m [y x]))\n                                       [y x]))))]\n       (route? m (find-cat m) #{})))\n  ([m agenda seen]\n     (let [out-of-bounds? (fn [map [y x]]\n                            (or (< x 0)\n                                (< y 0)\n                                (> x (dec (count (first map))))\n                                (> y (dec (count map)))))\n           neighbours (fn [[y-pos x-pos] map] (remove\n                                              (partial out-of-bounds? map)\n                                              [[y-pos (inc x-pos)]\n                                               [(inc y-pos) x-pos]\n                                               [y-pos (dec x-pos)]\n                                               [(dec y-pos) x-pos]]))]\n       (if (empty? agenda)\n         false\n         (let [first-cell (first agenda)\n               n          (remove #(or (some seen #{%})\n                                       (= \\# (get-in m %)))\n                                  (neighbours first-cell m))]\n           (if (= (get-in m first-cell) \\M)\n             true\n             (recur m\n                    (set (concat (rest agenda) n))\n                    (set (into seen [first-cell])))))))))","problem":117,"user":"4daeabf6edd6309eace4d15c"},{"problem":117,"code":"(fn [maze]\n  (let [cases (set (for [x (range (count maze)) y (range (count (first maze)))] [x y]))\n        sm (fn [c] (set (filter #(= c (get-in maze %)) cases)))\n        mo (first (sm \\M)) cheeze (first (sm \\C)) ps (sm \\space)\n        gp (fn [[x y] nt] (filter nt [[(inc x) y] [(dec x) y] [x (inc y)] [x (dec y)]]))]\n    (loop [pm #{mo} sq (conj ps cheeze)]\n      (cond (pm cheeze) true\n            (empty? pm) false\n            :else (let [n_pm (set (mapcat #(gp % sq) pm))]\n                    (recur n_pm (apply disj sq n_pm)))))))","user":"53e745a1e4b036ad0777e479"},{"problem":117,"code":";almost identical to graph reachability problem\n(fn reachability [maze]\n  (let [maze (vec (map vec maze))\n        find-position \n        #(for [[x row] (map-indexed vector %1) \n               [y val] (map-indexed vector row) \n               :when (= %2 val)]\n              [x y]\n        )\n        start (first (find-position maze \\M))\n        end (first (find-position maze \\C))\n        abs #(if (< % 0) (* -1 %) %)\n        get-neighbours \n          (fn [maze pos]\n            (set \n              (map #(-> % butlast vec) (filter #(not (contains? #{nil \\#} (last %)))\n                (for [y (range -1 2)\n                      x (range -1 2)\n                    :when (and (not= x y 0) (not= 2 (+ (abs y) (abs x))))]\n                  [(+ (first pos) y) (+ (last pos) x) (get-in maze [(+ y (first pos)) (+ x (last pos))] nil)]\n                )\n              ))\n            )\n          )\n        ]\n    (loop [visited #{start} neighbours (get-neighbours maze start)]\n      (cond\n        (empty? neighbours) false\n        (contains? neighbours end) true\n        :else\n          (recur (clojure.set/union visited neighbours) \n                 (clojure.set/difference (set (mapcat (partial get-neighbours maze) neighbours)) visited)\n          )\n      )\n    )\n  )\n)","user":"5991d2fae4b0866487ed0d68"},{"code":"(fn for-science [ maze ]\n  (let [ row-length (count (first maze))\n         maze       (mapcat seq maze)\n         v          (into {} (map-indexed #(vector %1 %2) maze))\n         find       (into {} (map-indexed #(vector %2 %1) maze))\n         start      (find \\M)\n         end        (find \\C)\n         adj        #(for [ shift [1 -1 row-length (* -1 row-length)] ]\n                           (+ % shift))\n         valid?     #(not= \\# (v % \\#)) ]\n    (loop [ current #{ start } old #{} ]\n      (cond (empty?    current)     false\n            (contains? current end) true\n            :else\n              (let [ neighbours (set (filter valid? (mapcat adj current)))\n                     old        (clojure.set/union current old) ]\n                (recur (clojure.set/difference neighbours old)\n                       old))))))","problem":117,"user":"4e860e85535db62dc21a62f1"},{"problem":117,"code":";; problem 117\n;; for science!\n;; loops through every combination of steps going up, down, left, right, from the start position\n;; removes used steps, and does not consider steps either untraversable or not on the board for\n;; the next iteration. When no more steps are possible, sees if the end position is present \n;; in the previous iteration's queue of available positions to traverse from.\n(fn path-possible?\n  [maze]\n  (let [indeces (for [y (range 0 (count maze))\n                      x (range 0 (count (first maze)))\n                      :let [value (nth (nth maze y) x)]\n                      :when (not= value \\#)]\n                  (vector x y value))\n        start (butlast (first (filter #(= \\M (last %)) indeces)))\n        end (butlast (first (filter #(= \\C (last %)) indeces)))\n        steps (list [0 1] [1 0] [0 -1] [-1 0])\n        next-steps (fn [pos-col rem-indeces]\n                     (for [[ix iy] pos-col\n                           [sx sy] steps\n                           :let [new-pos (list (+ ix sx) (+ iy sy))]\n                           :when (rem-indeces new-pos)]\n                           new-pos))]\n    (loop [pos-col (list start)\n           rem-indeces (set (remove #{start} (map butlast indeces)))]\n      (let [rem-indeces' (apply disj rem-indeces pos-col)\n            pos-col' (next-steps pos-col rem-indeces')]\n        (if (seq pos-col')\n          (recur pos-col' rem-indeces')\n          (contains? (set pos-col) end))))))","user":"55a9e0fee4b0988bba2ad945"},{"problem":117,"code":"(fn found-cheese? [board]\n  (letfn [(get-location [[i j]] (-> board (get i \"\") (get j \\#)))\n          (is-there? [c] (fn [loc] (when (= c (get-location loc)) loc)))\n          (directions [[i j] visited?]\n            (->> [[i (dec j)]\n                  [(dec i) j]\n                  [i (inc j)]\n                  [(inc i) j]]\n                 (remove (is-there? \\#))\n                 (remove visited?)))]\n    (let [mouse-location\n          (some\n            (is-there? \\M)\n            (for [i (range (count board))\n                  j (range (count (first board)))]\n              [i j]))]\n      (loop [[l & ls] [mouse-location] visited? #{}]\n        (cond\n          (nil? l) false\n          ((is-there? \\C) l) true\n          :else (recur (into ls (directions l visited?)) (conj visited? l)))))))","user":"5f300f28e4b033932238a682"},{"problem":117,"code":"(fn path? [m]\n  (let [numOfRows (count m)\n        numOfCols (count (first m))\n        neighbors (fn [xy]\n                    (let [delta [[-1 0] [1 0] [0 -1] [0 1]]]\n                      (filter \n                       #(and (< -1 (first %) numOfRows) (< -1 (second %) numOfCols))\n                       (map #(map + % xy) delta))))\n        find-mouse (fn []\n                     (loop [r 0 c 0]\n                       (cond\n                        (= \\M (get-in m [r c])) [r c]\n                        (= c numOfCols) (recur (inc r) 0)\n                        (= r numOfRows) nil\n                        :else (recur r (inc c)))))]\n    (loop [currentPos (conj [] (find-mouse)) visitedPos #{}]\n      (let [newPos (clojure.set/difference \n                    (into #{} (apply concat (for [p currentPos]\n                                              (map vec (neighbors p))))) visitedPos)\n            newVisitedPos (into visitedPos newPos)\n            boundedPos (remove #(= \\# (get-in m %)) newPos)]\n        (if (seq boundedPos)\n          (if (some #(= \\C (get-in m %)) boundedPos) true\n            (recur boundedPos newVisitedPos))\n          false)))))","user":"541619e8e4b01498b1a719f9"},{"code":"(fn catch?\n  [b]\n  (let [bh (count b)\n        bw (count (first b))\n        neighbors (fn  [b x y]\n                    (let [between? (fn [a b c]\n                                     (and (>= b a)\n                                          (< b c)))]\n                      (->> [[-1 0] [0 -1] [1 0] [0 1]]\n                           (map (fn [[a b]] [(+ a x) (+ b y)]))\n                           (filter (fn [[a b]] (and (between? 0 a bw) (between? 0 b bh)))))))\n        same-value? (fn  [v b x y] (= (get-in b [y x]) v))\n        occupied? (partial same-value? \\# )\n        mouse? (partial same-value? \\M)\n        cheese? (partial same-value? \\C)\n        mouse-pos (fn [b] (some (fn [[x y]] (and (mouse? b x y) [x y]))\n                                (for [a (range bw) b (range bh)] [a b])))\n        candidates (fn [b x y]\n                     (cond\n                      (occupied? b x y) nil\n                      :else (->> (neighbors b x y)\n                                 (filter #(not (apply (partial occupied? b) %))))))\n        catchable? (fn catchable? [V xy b]\n                     (let [[x y] xy]\n                       (cond\n                        (nil? xy) false\n                        (cheese? b x y) true\n                        :else (let [V (conj V [x y])\n                                    nexts (->> (candidates b x y)\n                                               (filter #(not (V %))))\n                                    V (into V nexts)]\n                                (->> (some #(catchable? V % b) nexts)\n                                     (boolean))))))\n        ]\n    (catchable? #{} (mouse-pos b) b)\n    ))","problem":117,"user":"513fab65e4b00f13ea1bd891"},{"code":"(let\n  [dirs [[-1 0] [1 0] [0 -1] [0 1]]\n   extend-mouse (fn [maze]\n                  (apply merge\n                         (for [[[i j] s] maze]\n                           {[i j]\n                            (condp = s\n                              \\# \\#\n                              \\M \\M\n                              (if (some #(= \\M %)\n                                        (for [[di dj] dirs]\n                                          (get maze [(+ i di) (+ j dj)])))\n                                \\M\n                                s))})))\n   parse-maze (fn parse-maze [maze]\n                (apply merge\n                       (for [i (range (count maze))\n                             j (range (count (get maze i)))]\n                         {[i j] (get-in maze [i j])})))\n   solve (fn [maze]\n           (if (not (contains? (set (vals maze)) \\C))\n             true\n             (let [update (extend-mouse maze)]\n               (if (= update maze)\n                 false\n                 (recur update)))))]\n  (comp solve parse-maze))","problem":117,"user":"50b668dde4b08fb537db98f2"},{"code":"(fn f\n  ([m] (let [i (count(take-while (partial not= \\C) (apply str m)))\n             cols (count (first m))\n             m (apply vector (map (partial apply vector) m))]\n         (f m (quot i cols) (mod i cols))))\n  ([m y x] (let [c (get-in m [y x] \\#)\n                 m (if (= c \\#) m (update-in m [y x] (fn [_] \\#)))]\n             (if (= c \\#)\n               false\n               (if (= c \\M)\n                 true\n                 (not (not-any? identity [(f m (inc y) x)(f m (dec y) x)(f m y (dec x))(f m y (inc x))]))\n                 )))))","problem":117,"user":"5349ac2be4b084c2834f4a67"},{"code":"(fn [coll]\r\n  (let [width (+ 2 (count (first coll)))\r\n        border (repeat width \\#)\r\n        compress #(reduce (fn [s x] (if (= x (peek s)) s (conj s x))) [] %)\r\n        maze (apply str (concat border (map #(str \\# % \\#) (compress coll)) border))\r\n        moves [inc dec #(+ % width) #(- % width)]\r\n        index-of (fn [s x] (dec (count (drop-while #(not= x %) (reverse s)))))\r\n        replace-nth (fn [s n x] (let [[a b] (split-at n s)] (concat a [x] (rest b))))]\r\n    (letfn [(check [pos board]\r\n              (let [ps\r\n                    (filter\r\n                      #(not= \\# (nth board %))\r\n                      (map #(% pos) moves))]\r\n                (cond\r\n                  (empty? ps) false\r\n                  (some #(= \\C (nth board %)) ps) true\r\n                  :else (let [b (replace-nth board pos \\#)]\r\n                          (if (some true? (map #(check % b) ps))\r\n                            true false)))))]\r\n      (check (index-of maze \\M) maze))))","problem":117,"user":"4f969214e4b0dcca54ed6cdd"},{"problem":117,"code":"(fn [xs]\n  (let [ [p1 p2] (for [i (range (count xs)), j (range (count (first xs))) \n                            :when ((set \"MC\") (get-in xs [i j]))] \n                        [i j])]\n    (loop [conn #{p1}, all_conn #{p1}]\n      (let [newp \n            (->> conn\n              (mapcat (fn [[x y]] (list [(inc x) y] [(dec x) y] [x (inc y)] [x (dec y)])))\n              (filter (fn [[x y]] (and ((set \"MC \") (get-in xs [x y]))\n                                              (not (all_conn [x y])))))\n              (into #{})) ]\n        (cond\n          (empty? newp) false\n          (newp p2) true\n          :else (recur newp (into all_conn newp))))) ))","user":"593f95d8e4b069cdc2982be3"},{"code":"(fn [board]\n  (let [brd (into [] (map vec board))\n        find-item (fn [l]\n          (first (for [row (range (count brd)) col (range (count (first brd))) \n                :when (= (get-in brd [row col]) l)]\n            [row col])))\n        neighbors (fn [[x y]] \n                    (for [dx-y [[-1 0] [1 0] [0 -1] [0 1]] \n                          :let [[dx dy] dx-y]]\n                      [(+ x dx) (+ y dy)]))\n        cheese (find-item \\C)]\n    (loop [visited #{} tovisit (into [] [(find-item \\M)])]\n      (do (print tovisit) (if (and (peek tovisit) (= cheese (peek tovisit)))\n        true\n        (if (not (peek tovisit))\n          false\n          (recur (conj visited (peek tovisit))\n            (into (pop tovisit)\n                (filter\n                  (fn [xy] (and (not (visited xy)) \n                                   (not= \\# (get-in brd xy \\#))))  \n                  (neighbors (peek tovisit)))))))))))","problem":117,"user":"4e7f5a0b535db966e863cc41"},{"code":"(fn [s]\n    (let [indexed        (apply concat (map-indexed #(map-indexed (partial vector %) %2) s))\n          mouse          (pop (vec (first (filter (fn [[i j x]] (= x \\M)) indexed))))\n          max-x          (dec (count s))\n          max-y          (dec (count (first s)))\n          value          (fn [[x y]] (-> s (nth x) (nth y)))\n          all-neighbors  (fn [[x y]] (list (vector (inc x) y)\n                                           (vector (dec x) y)\n                                           (vector x (inc y))\n                                           (vector x (dec y))))\n          in-bound?      (fn [[x y]] (and (<= 0 x max-x)\n                                          (<= 0 y max-y)))\n          neighbors      (fn [f] (->> (all-neighbors f) \n                                   (filter in-bound?)\n                                   (filter (comp (partial not= \\#) value))))\n          expand         (fn [[p n]] (let [a (clojure.set/union p n)]\n                                       (list a (clojure.set/difference (set (mapcat neighbors n)) a))))]\n      (->> mouse\n        (list) (set) (vector #{})\n        (iterate expand)\n        (take-while (complement (comp empty? second)))\n        (map second)\n        (filter #(not-empty (filter (comp (partial = \\C) value) %)))\n        (empty?) (not))))","problem":117,"user":"525f51bde4b0cb4875a45dc8"},{"problem":117,"code":"(fn [d]\n    (letfn [(free-spaces [d]\n              (apply concat\n                     (map-indexed (fn [rn rv]\n                                    (filter (fn [[[rn cn] cv]] (not= cv \\#))\n                                            (map-indexed (fn [cn cv] [[rn cn] cv]) rv))) d)))\n            (check-all [o s]\n              (let [r (group-by #(or (= (first %) (second o)) (= (second %) (first o)) (= (first %) (first o))) s)]\n                [(cons o (get r true)) (get r false)]))\n\n            (all-connected? [s]\n              (let [[a b] (check-all (first s) (rest s))]\n                (loop [a a b b]\n                  (cond (empty? b) true\n                        (empty? a) false\n                        :else (let [[a1 b1] (check-all (first a) b)]\n                                (recur (concat (rest a) (rest a1)) b1))))))\n\n            (is-connected [[a1 a2] [b1 b2]]\n              (or (and (= a1 b1) (= 1 (Math/abs (- b2 a2))))\n                  (and (= a2 b2) (= 1 (Math/abs (- b1 a1))))))\n\n            (get-graph [d s]\n              (loop [p (first s) r (rest s) a []]\n                (if (empty? r) a\n                    (recur (first r) (rest r)\n                           (cons (filter (fn [[a b]] (not (nil? b)))\n                                         (map (fn [v] [(get-node d p) (if (is-connected p v) (get-node d v))]) r)) a)))))\n\n            (get-node [d [r c]]\n              (+ (* r (count (first d))) c))\n\n            (get-positions [m v]\n              (filter (fn [[[rn cn] cv]] (= cv v)) m))\n            ]\n      (let [m (->> d free-spaces)\n            f (->> m (map first) (get-graph d) flatten)\n            g (set f)]\n        (cond (not (contains? g (get-node d (ffirst (get-positions m \\M))))) false\n              (not (contains? g (get-node d (ffirst (get-positions m \\C))))) false\n              :else (->> f (partition 2) all-connected?)))))","user":"4f3ec266e4b0e243712b1f8c"},{"code":"(fn [maze] (let [n (count maze) m (count (first maze))]\n  (letfn [(getW [pair] ((vec (maze (first pair))) (second pair)))\n          (getM [] (first\n                (filter (fn [pair] (= \\M (getW pair)))\n                        (for [x (range n) y (range m)] [x y]))))\n          (in [[x y]] (and (>= x 0) (< x n) (>= y 0) (< y m)))\n          (check [h pair]\n                 (if (and (not (h pair)) (in pair) (not= \\# (getW pair))) true false))\n          (make-new [pair]\n                    (for [x [[0 1] [0 -1] [1 0] [-1 0]]]\n                      (vec (map + x pair))))\n          (BFS [que h]\n               (if (empty? que)\n                 false\n                 (let [now (first que) ne (filter (partial check h) (make-new now))]\n                   (if (some (fn [pair] (= \\C (getW pair))) ne)\n                     true\n                     (recur (concat (rest que) ne) (into h ne))))))]\n    (let [start (getM)]\n      (BFS [start] #{start})))))","problem":117,"user":"503354c3e4b0c6c1199c710c"},{"code":"(fn [m]\n  (let [xy [[0 0] [-1 0] [1 0] [0 -1] [0 1]]\n        f (fn [x y] (map #(get-in m (map + [y x] %)) xy))\n        nbrs (for [y (range (count m))] (for [x (range (count (m 0)))] (f x y)))\n        g (fn [[x & n]] (condp = x\n                          \\M (if (some #{\\C} n) \\W \\#)\n                          \\space (if (some #{\\M} n) \\M \\space)\n                          x))]\n    (condp some (str m)\n      #{\\W} true\n      #{\\M} (recur (vec (map #(apply str (map g %)) nbrs)))\n      false)))","problem":117,"user":"522b922ee4b0d34ee08e71c3"},{"problem":117,"code":"(let [;; A predicate to check that we have a valid maze. Note that we extend\n        ;; the definition to allow periods, which we use to denote empty spaces\n        ;; that are known to be accessible from the start by a sequence of\n        ;; orthogonal moves.\n        maze?\n        (fn [x]\n          (and (vector? x)                                 ; Vectors only.\n               (every? string? x)                          ; Each row a string.\n               (if (seq x) (apply = (map count x)))        ; Rectangular.\n               (every? (partial re-matches #\"[. #MC]*\") x) ; Just maze chars.\n               (some (partial some #{\\M}) x)               ; At least one start.\n               (some (partial some #{\\C}) x)               ; At least one end.\n               true)),\n\n        dimensions\n        (fn [maze]\n          [(count maze)\n           (count (first maze))]),\n\n        ;; Returns a collection of all characters orthogonally adjacent to\n        ;; position [m n] in maze.\n        adjacent\n        (fn [maze [m n]]\n          (->>\n           (for [i [(dec m) m (inc m)],\n                 j [(dec n) n (inc n)]\n                 :when (#{1 -1} (+ (- i m) (- j n)))]\n             (get-in maze [i j]))\n           (keep identity))),\n\n        ;; Updates maze by turning spaces into periods whenever they are\n        ;; adjacent to either a period or an M. Returns the resulting maze.\n        maze-explore\n        (fn [maze]\n          (let [[height width] (dimensions maze)]\n            (->>\n             (for [i (range height)]\n               (for [j (range width)]\n                 (if (and (= \\space (get-in maze [i j]))\n                          (some #{\\. \\M} (adjacent maze [i j])))\n                   \\.\n                   (get-in maze [i j]))))\n             (map (partial apply str))\n             vec))),\n\n        ;; Returns true if and only if some exit is adjacent to a space known to\n        ;; be accessible (an M or a period).\n        solved?\n        (fn [maze]\n          (let [[height width] (dimensions maze)]\n            (if (some identity\n                      (for [i (range height),\n                            j (range width)\n                            :when (= \\C (get-in maze [i j]))]\n                        (some #{\\M \\.} (adjacent maze [i j]))))\n              true\n              false)))]\n\n    (fn solvable?\n      [maze] {:pre [(maze? maze)]}\n      (let [new-maze (maze-explore maze)]\n        (cond\n          (solved? new-maze)  true\n          (= maze new-maze)   false\n          :else               (recur new-maze)))))","user":"4fc6305de4b0ee37620e180b"},{"code":"(fn [maze]\n  (let [rows (count maze)\n        cols (count (first maze))]\n    (letfn [(goto [src delta] (vec (map + src delta)))\n            (neighbors [pos]\n              (filter\n               (fn [[r c]]\n                 (and (<= 0 r (dec rows))\n                      (<= 0 c (dec cols))))\n               (map (partial goto pos) [[-1 0] [1 0] [0 -1] [0 1]])))\n            (at [pos] (or (get-in maze pos) \\#))\n            (setat [[r c] val] (assoc maze r (str (subs (maze r) 0 c) val (subs (maze r) (inc c)))))]\n      (let [allpos (for [r (range rows) c (range cols)] [r c])\n            mouse-pos (filter #(#{\\M \\.} (at %)) allpos)\n            neighbs (mapcat neighbors mouse-pos)\n            moves (filter #(#{\\space \\C} (at %)) neighbs)]\n        (if (seq moves)\n          (let [move (first moves)\n                newboard (setat move \\.)\n                _ (println (interpose \"\\n\" newboard))]\n            (recur newboard))\n          (not-any? #(some #{\\C} %) maze))))))","problem":117,"user":"4ffc10aae4b0678c553fc3d6"},{"code":"(fn [a]\n  (let [h (count a)\n        w (count (a 0))]\n    (letfn [(stabilize [b]\n                       (let [c (advance b)]\n                         (if (= b c)\n                           b\n                           (stabilize c))))\n            (lost [b]\n                  (if (or (coll? b) (string? b))\n                    (some #(lost %) b)\n                    (= b \\C)))\n            (advance [b]\n                     (letfn [(charAt [x y]\n                                     (if (or (< x 0) (< y 0)\n                                             (>= x w) (>= y h))\n                                       \" \"\n                                       (nth (b y) x)))\n                             (neighbours [x y]\n                                         (for [i (range -1 2) j (range -1 2) :when (or (= 0 i) (= 0 j))]\n                                           (charAt (+ x i) (+ y j))))\n                             (mouse-moveable [x y]\n                                             (and (not (= \\# (charAt x y)))\n                                                  (some #(= % \\M) (neighbours x y))))\n                             (update [x y]\n                                     (if (mouse-moveable x y) \\M (charAt x y)))\n                             (row [i]\n                                  (apply str (map #(update % i) (range w))))]\n                       (vec (map row (range h)))))]\n      (not (lost (stabilize a))))))","problem":117,"user":"4ec0c7ba535dfed6da9c6da4"},{"problem":117,"code":"(fn cheese? [b]\n  (let [find-mouse (fn [b]\n                     (for [i (range 0 (count b))\n                           j (range 0 (count (first b)))\n                           :when (= (get-in b [i j]) \\M)]\n                       [i j]))\n        spaces (for [i (range 0 (count b))\n                     j (range 0 (count (first b)))\n                     :when (not= (get-in b [i j]) \\#)]\n                 [i j])\n        adj? (fn [[i j] x]\n               (#{[(dec i) j]\n                  [(inc i) j]\n                  [i (dec j)]\n                  [i (inc j)]} x))\n        f (fn [[visited sp]]\n            (let [visited' (set (concat\n                                 visited\n                                 (for [v visited\n                                       s sp\n                                       :when (or (adj? v s))]\n                                   s)))]\n              [visited' (remove visited' sp)]))]\n    (not= nil (some #(= (get-in b %) \\C) (first (last (take\n                                                       (count spaces)\n                                                       (iterate f [(set (find-mouse b)) spaces]))))))))","user":"569dd6e8e4b0542e1f8d1480"},{"code":"(fn [maze]\n  (let [start (first (drop-while #(not= \\M (get-in maze %)) \n                                 (for [x (range (count maze)) \n                                       y (range (count (first maze)))] [x y])))\n        w (fn w [[[cx cy] & r :as p] m]\n                (if (empty? p) false\n                  (if-let [next (first (filter #(not (#{\\# \\M} (get-in m % \\#)))\n                                   [[(inc cx) cy] [(dec cx) cy] [cx (inc cy)] [cx (dec cy)]]))]\n                    (if (= (get-in m next) \\C) true (w (cons next p) (assoc-in m next \\#)))\n                    (w r m))))]\n    (w (list start) (mapv vec maze))))","problem":117,"user":"52479487e4b05ef8e38e6373"},{"code":"(fn mouse-get-cheese? [board]\n  (let [dirs [[0 -1] [1 0] [0 1] [-1 0]]\n        h (count board)\n        w (count (first board))\n        get-multi (fn get-multi\n                    ([coll] coll)\n                    ([coll k & ks]\n                     (if (empty? ks)\n                       (get coll k)\n                       (recur (get coll k) (first ks) (rest ks)))))\n        mouse-cheese-find (fn mouse-cheese-find [s h w board]\n                            (-> (for [i (range h), j (range w)\n                                      :when (= (get-multi board i j) s)]\n                                  [i j])\n                                (first)))\n        m (mouse-cheese-find \\M h w board)\n        c (mouse-cheese-find \\C h w board)\n        bfs (fn bfs [v adj]\n              (loop [que [v]\n                     visited #{v}]\n                (if (empty? que)\n                  visited\n                  (let [to-visit (concat\n                                  (rest que)\n                                  (filter #(not (contains? visited %)) (adj (first que))))\n                        with-neighbours (if (empty? to-visit)\n                                          visited\n                                          (apply conj visited to-visit))]\n                    (recur to-visit with-neighbours)))))]\n    (contains?\n      (->> (for [i (range h)\n                 j (range w)\n                 [x y] dirs\n                 :when (and \n                         (re-find #\"[MC\\space]\" (str (get-multi board i j)))\n                         (re-find #\"[MC\\space]\" (str (get-multi board (+ i x) (+ j y)))))]\n             [[i j] [(+ i x) (+ j y)]])\n        (reduce #(assoc %1 (first %2) (conj (get %1 (first %2) []) (second %2))) {})\n        (bfs m))\n      c)))","problem":117,"user":"526ee63de4b03e8d9a4a733f"},{"problem":117,"code":"(letfn [                                                                                                                                                \n    (pretty-print [m] (doseq [l m] (println l)) (println))                                                                      \n    (visit [m [y x]] (let [line (m y)] (assoc-in m [y] (str (subs line 0 x) \\M (subs line (inc x))))))                                                  \n        ; get the coordinates of the next step from all of the Ms in the maze                                                                           \n    (next-steps [m]                                                                                                             \n        (->> (for [x (range (count m)) y (range (count (first m))) :when (= \\M (get-in m [x y]))] [x y])                                                \n             (mapcat (fn [[a b]] [[(inc a) b] [(dec a) b] [a (inc b)] [a (dec b)]]))                                            \n             set))                                                                                                                                      \n    (find-cheese [maze]                                                                                                         \n        (loop [m maze]                                                                                                                                  \n            (let [n (next-steps m)]                                                                                             \n                (if (not (empty? (filter #(= \\C (get-in m %)) n)))                                                              \n                    true                                                                                                                                \n                    (let [spaces (filter #(= \\space (get-in m %)) n)]                                                           \n                        (if (empty? spaces)                                                                                                             \n                            false                                                                                               \n                            (recur (reduce #(visit %1 %2) m spaces))))))))]                                                                             \n        find-cheese)","user":"558b50d5e4b027778923762b"},{"code":"(fn cheese-able? [board]\n  (let [rows (count board)\n        cols (count (first board))\n        at (fn [[r c]]\n             (cond (< r 0) \\#\n                   (< c 0) \\#\n                   (>= r rows) \\#\n                   (>= c cols) \\#\n                   :else (nth (nth board r) c)))\n        around (fn [[r c]] \n                 (for [[i j] [[-1 0] [1 0] [0 -1] [0 1]]\n                       :let [y (+ r i) x (+ c j)]\n                       :when (not= (at [y x]) \\#)]\n                   [(+ r i) (+ c j)]))\n        find (fn [s]\n               (first\n                 (keep-indexed \n                  (fn [i v] (when (> v -1) [i v])) \n                  (for [r board] (.indexOf r s)))))\n        start (find \"M\")\n        end (find \"C\")]\n    (loop [open (list start) closed #{}]\n      (cond (closed end) true\n            (empty? open) false\n            :else\n              (recur \n                (for [a open b (around a) :when (not (closed b))] b)\n                (into closed open))))))","problem":117,"user":"50d0d4c8e4b00b15ecee976a"},{"code":"(fn [b]\n  (let [i (fn [s] #(vector %1 (.indexOf %2 s)))\n        f (fn [s] (first (remove #(neg? (second %))\n                                 (map-indexed (i s) b))))\n        cl (f \"C\")\n        n (fn [[r c]] [[(inc r) c] [r (inc c)]\n                       [(dec r) c] [r (dec c)]])]\n    ((fn m [v tv]\n       (let [[r c] (first tv)]\n         (cond (v cl) true\n               (and r (v [r c])) (m v (rest tv))\n               r (->> (remove v (n [r c]))\n                      (filter #(#{\\space \\C} (get-in b %)))\n                      (into tv)\n                      (m (conj! v [r c])))\n               :else false)))\n     (transient #{}) (list (f \"M\")))))","problem":117,"user":"504e04a4e4b078edc5f59397"},{"problem":117,"code":"(fn maze [m]\n  (letfn [(find-mouse [m x] (let [row (nth m x)] (if (.contains row \"M\") [x (.indexOf row \"M\")] (find-mouse m (inc x))))) ]\n  (let [mouse-start (find-mouse m 0) locs '([0 1] [1 0] [-1 0] [0 -1])]\n    (letfn [(invalid [loc] (let [x (first loc) y (second loc)] (or (< x 0) (< y 0) (>= x (count m)) (>= y (count (first m))) ))) \n            (find-cheese [seen frontier] \n              (let [loc (last frontier) \n                    new-locs  (map #(do [(+ (first %1) (first loc)) (+ (second %1) (second loc))]) locs)\n                    invalid-locs (filter invalid new-locs) \n                    valid-locs (filter #(nil? (seen %1)) (filter (complement invalid) new-locs))\n                    next-find (partial find-cheese (conj seen loc)) \n                    at-location (if loc (.charAt (nth m (first loc)) (second loc)))]\n                (cond (empty? frontier) false \n                      (= \\C at-location) true\n                      (= \\# at-location) (next-find (butlast frontier))\n                  :else (next-find (concat valid-locs (butlast frontier))) )\n                 ))] \n   (true? (find-cheese #{} [mouse-start]))))))","user":"4f7b6b90e4b06e829148e1a4"},{"code":"(fn mouse-n-cheese [maze]\n  (let [wid (count (first maze))\n        ht (count maze)\n        mc-pos (reduce #(assoc %1 (first %2) (second %2)) {}\n                     (for [i (range ht) j (range wid) :let [cell (get-in maze [i j])] :when (#{\\M \\C} cell)] [cell [i j]]))\n        next-steps (fn [[r c]]\n         (filter #(not= (get-in maze %1) \\#) \n          (for [[i j] [[(dec r) c] [r (inc c)] [(inc r) c] [r (dec c)]] :when (and (< -1 i  ht) (< -1 j wid))] [i j])))\n\n        find-path (fn [neighbors start end]\n          (loop [queue (conj clojure.lang.PersistentQueue/EMPTY start)\n                 preds {start nil}]\n            (when-let [node (peek queue)]\n              (let [nbrs (remove #(contains? preds %) (neighbors node))]\n                (if (some #{end} nbrs)\n                  (reverse (cons end (take-while identity (iterate preds node))))\n                  (recur (into (pop queue) nbrs)\n                         (reduce #(assoc %1 %2 node) preds nbrs)))))))]\n    (boolean (find-path next-steps (mc-pos \\M) (mc-pos \\C)))))","problem":117,"user":"4effb663535dcb61093f6a2e"},{"problem":117,"code":"(fn finds-cheese? [maze]\n  (let [height (count maze)\n        width (count (first maze))\n        find-char (fn [c] \n                    (first (for [i (range height)\n                                 j (range width)\n                                 :when (= c (get-in maze [i j]))]\n                             [i j])))\n        mouse-location (find-char \\M)\n        cheese-location (find-char \\C)\n        expand (fn [[i j]] \n                 (filter (fn [[ii jj]] (and (< -1 ii height)\n                                            (< -1 jj width))) \n                         (list [i j]\n                               [(dec i) j] \n                               [i (dec j)] \n                               [(inc i) j] \n                               [i (inc j)])))]\n    (loop [visited-cells #{mouse-location}]\n      (let [new-cells (->> visited-cells\n                           (mapcat expand)\n                           (filter #(not= \\# (get-in maze %)))\n                           (set))]\n        (cond (new-cells cheese-location) true\n              (= (count new-cells) (count visited-cells)) false\n              :else (recur new-cells))))))","user":"529e3a4fe4b04e0c58e87b92"},{"code":"(fn [maze]\n  (let [n (count maze)\n        m (count (maze 0))\n        find-c (fn [c]\n                 (first (for [x (range n) y (range m) :when (= c (get-in maze [x y]))] [x y])))\n        in-range (fn [[x y]]\n                   (and (>= x 0) (>= y 0) (< x n) (< y m)))\n        start (find-c \\M)\n        goal (find-c \\C)\n        dirs [[0 1] [0 -1] [1 0] [-1 0]]]\n    (loop [q [start] reach #{start}]\n      (cond\n        (reach goal) true\n        (empty? q) false\n        :else (let [exps (for [p q :when (not= \\# (get-in maze p)) d dirs] (map + p d))\n                    nexts (filter #(and (in-range %) (not (reach %))) exps)]\n                (recur nexts (into reach nexts)))))))","problem":117,"user":"527cd633e4b0757a1b17136f"},{"problem":117,"code":"(fn [s]\n  (let [r (count s)\n        l (count (first s))\n        m (first (for [x (range r)\n                       y (range l)\n                       :when (= \\M (get (get s x) y))]\n                   [x y]))\n        c (first (for [x (range r)\n                       y (range l)\n                       :when (= \\C (get (get s x) y))]\n                   [x y]))\n        g (fn [[x y]] (and (>= x 0) (< x r) (>= y 0) (< y l)\n                           (not= \\# (get (get s x) y))))\n        ca (fn ca [rs [x y]]\n             (let [ne (filter g [[(dec x) y] [(inc x) y] [x (dec y)] [x (inc y)]])\n                   nrs (into rs ne)]\n               (if (= (count rs) (count nrs))\n                 nrs\n                 (into nrs (mapcat #(ca nrs %) ne)))))\n        catm (ca #{c} c)]\n    (contains? catm m)))","user":"5af907e6e4b0cc2b61a3bcda"},{"code":"(fn [a]\n  (let [C count i (C a) l (C (first a)) ? contains? $ range\n        T (fn [m x y]\n            (let [M #(char (get-in m [%2 %] 0))\n                  p (M x y)]\n              (condp #(? %2 %) \n                (set\n                  (for [[X Y] [[-1 0] [1 0] [0 -1] [0 1]]]\n                    (let [! #(and (= p %) (= (M (+ x X) (+ y Y)) %2))]\n                      (cond\n                        (! \\M \\C) 2\n                        (! \\space \\M) 1\n                        :else nil))))\n               2 2 1 \\M p)))]\n    (loop [m a]\n      (let [s (vec (for [y ($ i)]\n                     (vec (for [x ($ l)]\n                            (T m x y)))))]\n        (cond\n          (? (set (flatten s)) 2) true\n          (= s m) false\n          :else (recur s))))))","problem":117,"user":"512f06c5e4b0762be4c7aad7"},{"code":"(fn [maze]\n  (let [height (count maze)\n        width (count (first maze))\n        find-char-pos (fn [ch] (let [index (.indexOf (apply concat maze) ch)] [(quot index width) (rem index width)]))\n        start-pos (find-char-pos \\M)\n        end-pos (find-char-pos \\C)\n        position-allowed? (fn [[x y]] (and (>= x 0) (< x height) (>= y 0) (< y width) (not= \\# ((vec (maze x)) y))))\n        ;; possible positions of a point after one move\n        point-evolution (fn [[x y]] \n                          (filter position-allowed? (map #(vector (+ x (% 0)) (+ y (% 1))) [[1 0] [0 1] [-1 0] [0 -1]])))\n        set-evolution (fn [s] (set (concat s (mapcat point-evolution s))))]\n    ;; evolve the set from the starting position until the set saturates and check if it contains the end point\n    (loop [s #{start-pos}]\n      (let [evolved-set (set-evolution s)]\n        (if (= s evolved-set)\n          (contains? s end-pos)\n          (recur evolved-set))))))","problem":117,"user":"4e9519b4535dbda64a6f6b2d"},{"problem":117,"code":"(fn [maze]\n  (let [rows (count maze)\n        cols (count (maze 0))\n        findchar (fn [ch] (first (for [row (range rows) col (range cols) :when (= ch (get-in maze [row col]))][row col])))\n        M (findchar \\M)\n        C (findchar \\C)\n        adj (fn [[r c]] [[(inc r) c] [(dec r) c] [r (inc c)] [r (dec c)]] )\n        inmaze (fn[[r c]] (and (< -1 r rows) (< -1 c cols)))\n        bfs (fn [pointset visited]\n                (let [npset (->> (map adj pointset)\n                                 (apply concat)\n                                 (filter #(and (inmaze %) ((complement visited) %) (not= \\# (get-in maze %))))\n                                 (distinct)\n                                 (apply hash-set))]\n                  (cond (empty? npset) false\n                         (npset C) true\n                         :else (recur npset (clojure.set/union visited pointset)))))]\n    (bfs #{M} #{})))","user":"5649615be4b0284900eef641"},{"problem":117,"code":"(fn [m]\n    (let [t #(mapv %2 (range (count %1)))\n          w (iterate\n             (fn [m]\n               (t m\n                  (fn [i]\n                    (t (m i)\n                       (fn [j]\n                         (let [z #(get (get m %1) %2)\n                               x (z i j)\n                               u (set [(z (+ i 1) j)\n                                       (z (- i 1) j)\n                                       (z i (+ j 1))\n                                       (z i (- j 1))])]\n                           (if (and (#{\\space \\C} x)\n                                    (u \\M))\n                             \\M\n                             x)))))))\n             m)\n          h (last\n             (take-while\n              identity\n              (map #(when (not= %1 %2) %2) w (rest w))))]\n      (not ((set (mapcat set h)) \\C))))","user":"4f08b15b535dcb61093f6c40"},{"problem":117,"code":"(fn [input]\n  (letfn [(trim-in-hash [key col]\n            (->> (map key col)\n                 (reduce concat)\n                 (into #{})))\n          (get-area [col c]\n            (trim-in-hash :connect\n                          (filter (fn [e] (contains? (:content e) c)) col)))]\n    (let [hash-world\n          (flatten\n           (keep-indexed\n            (fn [i row]\n              (keep-indexed\n               #(if (contains? #{\\M \\C \\ } %2)\n                  {:field {% i},\n                   :content #{%2},\n                   :connect #{{% i}}})\n               row)) input))\n           build-tree\n          (reduce\n           #(let [[x y] (apply concat (:field %2))\n                  col (conj (filter (fn [seq] (contains? #{{(dec x) y} {x (dec y)}} (:field seq))) %) %2)\n                  content (trim-in-hash :content col)\n                  connect (trim-in-hash :connect col)]\n              (conj % {:field {x y} :content content :connect connect})\n              ) '() hash-world)\n          mouse-area  (get-area build-tree \\M)\n          cheese-area (get-area build-tree \\C)]\n      (not (empty? (clojure.set/intersection mouse-area cheese-area))))))","user":"55b22c33e4b0da326a65cf79"},{"problem":117,"code":"(fn can-traverse-maze? [maze]\n  (let [cells (into {} (mapcat (fn [row row-data]\n                                 (map (fn [col cell]\n                                        [[row col] cell])\n                                      (range) row-data))\n                               (range) maze))\n        start-cell (ffirst (filter #(= (second %) \\M) cells))\n        neighbours (fn [[row col]]\n                     [[(inc row) col]\n                      [(dec row) col]\n                      [row (inc col)]\n                      [row (dec col)]])]\n    (loop [path    (list start-cell)\n           visited #{start-cell}]\n      (if (seq path)\n        (let [current-cell (first path)\n              neighbour-cells (set (filter #(and (cells %) (not= (cells %) \\#)) (neighbours current-cell)))\n              new-neighbours (clojure.set/difference neighbour-cells visited)]\n          (cond\n            (some #(= (cells %) \\C) neighbour-cells)\n            true\n\n            (not (empty? new-neighbours))\n            (let [next-cell (first new-neighbours)]\n              (recur (cons next-cell path) (conj visited next-cell)))\n\n            :default\n            (recur (rest path) visited)))\n        false))))","user":"57a4fa50e4b0a966079561f1"},{"problem":117,"code":"(fn __ [maze]\n  (let [maze (mapv vec maze)\n        mouse-coord (fn [maze]\n                      (for\n                          [x (range (count maze))\n                           y (range (count (first maze)))\n                           :when (= \\M (get-in maze [x y]))]\n                        [x y]))\n        mouse-next-coord (fn [mouse-coord]\n                           (reduce (fn [r [x y]]\n                                     (conj r  [(inc x) y]\n                                           [x (inc y)]\n                                           [(dec x) y]\n                                           [x (dec y)]))\n                                   []\n                                   mouse-coord))\n        maze-next (fn [maze mouse-next-coord]\n                    (reduce\n                     (fn [m coord]\n                       (if (= \\space (get-in m coord))\n                         (assoc-in m coord \\M)\n                         (if (= \\C (get-in m coord))\n                           true\n                           m)))\n                     maze mouse-next-coord))]\n    (loop [m maze]\n      (let [nxt (maze-next m (mouse-next-coord (mouse-coord m)))]\n        (cond\n          (= true nxt) true\n          (= m nxt) false\n          :else (recur nxt))))))","user":"51aefceee4b09397d5109797"},{"problem":117,"code":"(fn solve-maze [g]\n  (letfn [(coord [c] (->> g (map-indexed #(vector %1 (.indexOf %2 c))) (remove (comp neg? second)) first))\n          (it [t n] (min (dec (count t)) (inc n))) (dt [n] (max 0 (dec n)))\n          (up    [p] (update-in p [0] dt))\n          (left  [p] (update-in p [1] dt))\n          (down  [p] (update-in p [0] #(it g %)))\n          (right [p] (update-in p [1] #(it (first g) %)))\n          (allowed [seen p] (not (or (some #{p} seen) (= (get-in g p) \\#))))]\n    (let [mouse (coord \"M\") cheese (coord \"C\") moves [up down left right]]\n      (loop [cur mouse seen [] next []]\n        (let [seen (conj seen cur)\n              next (concat next (filter (partial allowed seen) (map #(% cur) moves)))]\n          (cond (= cur cheese) true\n                (empty? next)  false\n                :else          (recur (last next) seen (butlast next))))))))","user":"575b3e9be4b02ea11479935b"},{"problem":117,"code":"(fn [mz] (let [lx (dec (count (first mz))) ly (dec (count mz))\n               sy (loop [n 0] (if (some #(= % \\M) (nth mz n)) n (recur (inc n))))\n               sx (loop [n 0] (if (= (get-in mz [sy n]) \\M) n (recur (inc n))))\n               ma (atom mz)]\n           (letfn [(check [x y] (if (or (< x 0) (< y 0)\n                                      (> x lx) (> y ly)) false\n                                    (get-in @ma [y x])))\n                   (rep [x y] (reset! ma (assoc @ma y (apply str (assoc (vec (nth @ma y)) x \\A)))))\n                   (rec [x y]\n                        (cond (= (check x y) \\C) '(true)\n                              (= (check x y) false) nil\n                              (= (check x y) \\#) nil\n                              (= (check x y) \\A) nil\n                              :else (do (rep x y) (cons (rec (dec x) y)\n                                        \t\t\t    (cons (rec x (dec y))\n                                               \t\t\t\t  (cons (rec (inc x) y)\n                                                     \t\t\t\t(cons (rec x (inc y)) nil)))))))]\n             (true? (some true? (flatten (rec sx sy)))))))","user":"53a1b5c8e4b0ca733b9744c1"},{"problem":117,"code":"(fn mouse-maze\n  [maze]\n  (letfn [(neighbors [row col]\n            [[row (dec col)]\n             [row (inc col)]\n             [(dec row) col]\n             [(inc row) col]])\n          (node-at [maze pos]\n            (when-let [c (get-in maze pos)]\n              (when-not (= c \\#)\n                {:char c :pos pos})))\n          (build-graph [maze]\n            (into {}\n                  (for [row (range 0 (count maze))\n                        col (range 0 (count (maze row)))\n                        :let [node (node-at maze [row col])]\n                        :when node]\n                    (let [edges (remove nil? (map #(node-at maze %)\n                                                  (neighbors row col)))]\n                      [node edges]))))\n          (converge [f init]\n            (loop [x init\n                   fx (f x)]\n              (if (= x fx)\n                x\n                (recur fx (f fx)))))\n          (reachable-from [graph node]\n            (converge (fn [seen]\n                        (clojure.set/union seen\n                                           (set (flatten (map graph seen)))))\n                      #{node}))]\n    (let [graph (build-graph maze)\n          mouse (some #(when (= (:char %) \\M) %) (keys graph))]\n      (boolean (some #(= (:char %) \\C) (reachable-from graph mouse))))))","user":"563f1493e4b08d4f616f5ecf"},{"problem":117,"code":"(fn maze [m]\n  (let[w (count (first m))\n       h (count m)\n       all (for [x (range w) y (range h)] [x y])\n       dirs [[-1 0][0 -1][0 1][1 0]]\n       cell (fn [[x y]] (if (or (< x 0) (< y 0) (>= x w) (>= y h)) \\# (nth (nth m y) x)))\n       filled (filter #(= \\M (cell %)) all)\n       move (fn [[x y]] (some  \n                       #(if (= \\space (cell %)) %)\n                       (for [[dx dy] dirs] [(+ x dx) (+ y dy)])))\n       nxt (some #(if (move %) (move %)) filled)\n       [cx cy] (first (filter #(= \\C (cell %)) all))\n       reach (some #(= (cell %) \\M) (for [[dx dy] dirs] [(+ cx dx) (+ cy dy)]))       \n       fill (fn [[x y]]\n              (map (fn [q] (apply str (map (fn [p]\n                  (if (and (= p x) (= q y)) \\M (cell [p q])))\n                      (range w)) )) (range h)))]              \n ;(println (map  #(str % \"\\n\") m))\n (cond\n  (= reach true) true\n  (not nxt) false\n  :else (maze (fill nxt)))))","user":"56bca51ae4b0f26550335963"},{"problem":117,"code":"(letfn [(modify [maze [y x :as pos] value] \n           (let [row (nth maze y)]\n             (assoc maze y (assoc (vec row) x value))))\n         (maze-to-vec [maze] (vec (map #(vec %) maze)))\n         (decorate [[y x :as pos] maze] (nth (nth maze y) x))\n         (mesure [maze] \n           (let [height (count maze)\n                 width (count (first maze))]\n             [height width]))        \n         (neighbors [[y x :as pos] [height width]]\n           (loop [direction :right res []]\n             (case direction\n               :right  (recur :up (if (> x 0) (conj res [y (dec x)]) res))\n               :up (recur :left\n                          (if (> y 0) (conj res [(dec y) x]) res))\n               :left (let [mx (inc x)] \n                       (recur :down (if (>= mx width) res (conj res [y mx]))))\n               :down (let [my (inc y)] \n                       (if (>= my height) res (conj res [my x])))\n               )))        \n         ]\n   (fn [maze]\n     (let [mazze (maze-to-vec maze) \n           [height width :as hw] (mesure mazze)\n           maze-positions  (for [ y (range height) x (range width)] [y x])]\n       (loop [curr-maze mazze positions maze-positions] \n        (prn curr-maze)\n         (if (empty? positions) false\n           (let [curr-position (first positions) \n                 curr-tile (decorate curr-position curr-maze)]\n             (if (some #(= % \\M) (map #(decorate % curr-maze) (neighbors curr-position hw)))\n               (case curr-tile\n                 \\ (recur (modify curr-maze curr-position \\M) maze-positions)                    \n                 \\C true\n                 (recur curr-maze (rest positions)))\n               (recur curr-maze (rest positions))      \n               )\n             )\n           )\n         )  \n       )\n     ) \n   )","user":"50856bd1e4b004985b776e4c"},{"code":"(fn cat-n-mouse [grid]\n  (let [neighbors (fn [[x y]] [[(inc x) y] [(dec x) y] [x (inc y)] [x (dec y)]])\n        parts (for [y (range (count grid))\n                    x (range (count (nth grid y)))\n                    :let [e (get-in grid [y x])]]\n                {({\\C :cat \\M :mouse \\# :wall \\space :space} e) [x y]})\n        game (apply merge-with conj {:wall [] :space []} parts)\n        spaces (conj (set (:space game)) (:mouse game))]\n    (loop [open [(:cat game)] visited #{}]\n      (cond\n        (empty? open) false\n        (= (first open) (:mouse game)) true\n        :else (let [visited (conj visited (first open))\n                    neigh (filter spaces (neighbors (first open)))\n                    neigh (remove visited neigh)\n                    open (concat (rest open) (remove visited neigh))]\n                (recur open visited))))))","problem":117,"user":"5032b066e4b00c0952a257ea"},{"code":"(fn for-science [maze]\n  (let [mouse \\M cheese \\C wall \\#\n        m (count maze) n (count (maze 0))\n        char-at (fn [i j] (.charAt (maze i) j))\n        mouse-and-cheese-pos (for [i (range m) j (range n) \n                                   :when (contains? #{mouse, cheese} (char-at i j))] [i j])\n        neightbours (fn [[i j]] (into #{} (for [k (range (dec i) (+ i 2)) l (range (dec j) (+ j 2)) \n                                    :when (and (<= 0 k (dec m)) (<= 0 l (dec n)) (not= [k l] [i j]) \n                                               (or (= k i) (= l j)) (not= wall (char-at k l)))] [k l])))\n        possible-move (fn [positions] (-> (reduce clojure.set/union (map neightbours positions)) (clojure.set/union positions)))\n        accessible-positions (fn [from] (let [[[old new]] \n                               (->> (iterate possible-move #{from}) (partition 2 1) (drop-while (partial apply not=)) )] new))\n        [first-pos second-pos] mouse-and-cheese-pos]\n    (contains? (accessible-positions first-pos) second-pos)))","problem":117,"user":"51729002e4b044b2ef48a850"},{"problem":117,"code":"(letfn [\n      (stab [f x]\n            (first (first (filter (partial apply =) (partition 2 1 (iterate f x))))))\n      (go-right1 [line]\n                 (let [[match before after] (re-find #\"(.*)M[ C](.*)\" line)]\n                   (if match\n                     (clojure.string/join [before \"MM\" after])\n                     line)))\n      (go-right [maze]\n                (map (partial stab go-right1) maze))\n      (rotate [maze]\n              (map (partial apply str) (apply map (comp reverse vector) maze)))\n      (explore [maze]\n               ((comp rotate go-right rotate go-right rotate go-right rotate go-right) maze))\n      (solvable? [maze]\n                 (not-any? #((set %) \\C) (stab explore maze)))]\n   solvable?)","user":"53e4fa2ce4b036ad0777e454"},{"problem":117,"code":"(fn for-science [table]\n  (letfn [(neighbors [[x y]]\n            (for [node [[(dec x) y] [x (dec y)]\n                        [(inc x) y] [x (inc y)]]\n                  :when (some #{(get-in table node)} [\\space \\C])]\n              node))]\n    (let [mouse-pos (first\n                     (for [i (range 0 (count table))\n                           j (range 0 (count (first table)))\n                           :when (= \\M (get-in table [i j]))]\n                       [i j]))]\n      (loop [nodes #{mouse-pos} visited #{mouse-pos}]\n        (let [next-nodes (clojure.set/difference (set (mapcat neighbors nodes))\n                                                 visited)]\n          (prn nodes)\n          (cond\n            (empty? next-nodes) false\n            (some #(= \\C (get-in table %)) next-nodes) true\n            :else (recur next-nodes (clojure.set/union visited next-nodes))))))))","user":"5d9c1226e4b0d3f9b434ad51"},{"code":"(fn [maze]\n  (let [rng (comp range count)\n        coords (for [r (rng maze) c (rng (first maze))] [r c])\n        find (fn [c] (first (filter #(= (get-in maze %) c) coords)))\n        mouse (find \\M)\n        cheese (find \\C)\n        possible-moves (fn [[x y]]\n                         [[(dec x) y]\n                          [x (dec y)]\n                          [x (inc y)]\n                          [(inc x) y]])\n        valid? #(case (get-in maze %)\n                  \\space true\n                  \\C true\n                  false)\n        ]\n    (loop [memory #{mouse}\n           current #{mouse}]\n      (let [valid-moves (filter valid? (mapcat possible-moves current))\n            new-moves (remove memory valid-moves)]\n        (cond (some #(= cheese %) new-moves) true\n              (empty? new-moves) false\n              :else (recur (into memory new-moves) new-moves))))))","problem":117,"user":"4f437751e4b0d7d3c9f3fd20"},{"problem":117,"code":"(fn [maze]\n  (let [transpose (fn [coll] (apply mapcat (comp list str) coll))\n        reachable? (fn [s] (re-find #\"(C@|@C)\" s))\n        walk (fn [s]\n               (reduce (fn [s [x y]] (str (subs s 0 x) (apply str (repeat (- y x) \\@)) (subs s y (count s)))) s\n                       (let [matcher (re-matcher #\"[ ]*[M@]+[ ]*\" s)]\n                         (loop [r [] match (re-find matcher)]\n                           (if match\n                             (recur (conj r [(.start matcher) (.end matcher)]) (re-find matcher))\n                             r)))))\n        search (fn [m]\n                 (let [n (->> (map walk m) transpose (map walk) transpose)]\n                   (if (= m n)\n                     m\n                     (recur n))))\n        m (search maze)]\n    (boolean (or (some reachable? m) (some reachable? (transpose m))))))","user":"56874171e4b0dcc4269f405c"},{"code":"(fn [maze]\r\n  (let [maze (into {} (for [[i y] (map list (range) maze)\r\n                            [j x] (map list (range) y)]\r\n                            [[i j] x]))\r\n        graph (into {} (for [[[i j] x] maze :when (not (= x \\#))]\r\n                         (let [ch (filter \r\n                                    #(and (maze %) (not (= (maze %) \\#)))\r\n                                          [[(inc i) j], [i (inc j)], [(dec i) j], [i (dec j)]])]\r\n                           [[i j] ch])))                   \r\n        start (some (fn [[i x]] (when (= x \\M) i)) maze)]\r\n    (loop [seen #{}, stack [start]]\r\n      (cond\r\n        (some #(= \\C (maze %)) stack) true\r\n        (empty? stack) false\r\n        :else\r\n        (let [seen' (into seen stack)\r\n              stack' (for [x stack, c (graph x) :when (not (seen' c))] c)]\r\n          (recur seen' stack'))))))","problem":117,"user":"509c03f3e4b085ae113522a8"},{"code":"(fn [maze] \n  (letfn [(mouse-pos [b]\n                     (for [i (range (count b)) j (range (count (first b)))\n                           :when (= \\M\t(get-in b [i j]))]\n                       [i j]))\n          (find-neighbor [m path [y x]]\n                         (filter #(let [a (first %) b (second %)]\n                                 (and (>= a 0) (>= b 0)\n                                      (< a (count m)) (< b (count (first m)))\n                                      (not (= \\# (get-in m %)))\n                                      (not (contains? path %)))) \n                                 [[(inc y) x] [(dec y) x] [y (inc x)] [y (dec x)]]))]\n    (loop [path (set (mouse-pos maze))]\n      (let [p (mapcat #(find-neighbor maze path %) path) r (some #(= \\C (get-in maze %)) p)]\n        (if (or (empty? p) r) (if (empty? p) false true)\n          (recur (into path p)))))))","problem":117,"user":"51780f88e4b03d69594194c9"},{"problem":117,"code":"(fn [mz]\n  (let [x (count mz) y (count (first mz))\n        st (set (for [i (range x) j (range y)\n                 :when (#{\\M} (get-in mz [i j]))]\n                  [i j]))\n        nbs (fn [[a b] found]\n              (filter #(and (#{\\space \\C} (get-in mz %))\n                            (not (found %)))\n                      [[(dec a) b] [(inc a) b] [a (dec b)] [a (inc b)]]))]\n    (loop [found (set st) neighbors (mapcat #(nbs % found) st)]\n      (let [h (first neighbors)\n            f' (set (reduce #(conj %1 %2) found neighbors))]\n        (cond\n          (nil? h) false\n          (#{\\C} (get-in mz h)) true\n          :else (recur f' (doall (concat (rest neighbors) (nbs h f')))))))))","user":"53ef7f77e4b0742d9025b0ce"},{"problem":117,"code":"(fn myf [coll]\n  (let [left (fn [loc]\n               [(dec (first loc)), (second loc)])\n        right (fn [loc]\n                [(inc (first loc)), (second loc)])\n        up (fn [loc]\n             [(first loc), (dec (second loc))])\n        down (fn [loc]\n               [(first loc), (inc (second loc))])\n        change (fn [coll]\n                 (transient (reduce into (for [x (range (count (first coll))), y (range (count coll))]\n                                      {[x, y] (nth (nth coll y) x)}))))\n        find-mouse (fn [coll]\n                     (first (for [x (range (count (first coll))), y (range (count coll)), :when (= \\M (nth (nth coll y) x))]\n                              [x, y])))\n        board (change coll)\n        find-cheese (fn f [cur-loc]\n                      (cond (= \\C (board cur-loc)) true\n                            (= \\P (board cur-loc)) false\n                            (= \\# (board cur-loc)) false\n                            (= nil (board cur-loc)) false\n                            :else (do (assoc! board cur-loc \\P)\n                                    (reduce #(or %1 %2) (map f ((juxt left right up down) cur-loc))))))\n        ]\n    (let [m-loc (find-mouse coll)]\n      (find-cheese m-loc))))","user":"577c3da9e4b0c8d87281f6b9"},{"problem":117,"code":"#(let [my (dec (count %))\n       mx (-> % first count dec)\n       valid? (fn [p [y x :as p']] (and (<= 0 y my) (<= 0 x mx) (not= p' p) (not= \\# (get-in % p'))))\n       moves (fn [[y x]] (filter (partial valid? [y x])\n                                 (map (fn [[b a]] (vector (+ y b) (+ x a))) [[-1 0] [0 1] [1 0] [0 -1]])))\n       walk (fn walk [q seen]\n              (let [p (peek q)]\n                (if p (lazy-seq (cons (get-in % p)\n                                      (walk (into (pop q) (remove seen (moves p))) (conj seen p)))))))]\n  (->> (walk (conj (clojure.lang.PersistentQueue/EMPTY)\n                   (first (keep-indexed (fn [y r] (let [x (.indexOf r (int \\M))] (if (>= x 0) [y x]))) %)))\n             #{})\n       (filter (partial = \\C)) first nil? not))","user":"54055aa9e4b0addc1aec6665"},{"code":"(fn for-science [maze]\n  (let [rowsize       (count (first maze))\n        columnsize    (count maze)\n        grid          (flatten (map seq maze))\n        indices       (for [y (range columnsize)\n                            x (range rowsize)]\n                        [y x])\n        squares       (zipmap indices grid)\n        cheeseindex   (nth indices (.indexOf grid \\C))\n        neighbors     (fn [index]\n                        (let [cy (first index)\n                              cx (second index)]\n                          (filter #(not (nil? %)) (for [[y x] [[cy (dec cx)] [cy (inc cx)] [(dec cy) cx] [(inc cy) cx]]]\n                                                    (if (or (> 0 x) (> 0 y) (<= rowsize x) (<= columnsize y))\n                                                      nil\n                                                      (squares [y x]))))))\n        nextstep      (fn [index]\n                        (let [adjacent (neighbors index)]\n                          (if (and (= \\space (squares index))\n                                   (not (nil? (some #{\\M} adjacent))))\n                            \\M\n                            (squares index))))\n        nextgrid   (map nextstep indices)\n        nextmaze   (map clojure.string/join (partition rowsize nextgrid))]\n   (cond (= nextmaze maze) (not (nil? (some #{\\M} (neighbors cheeseindex))))\n         :else (for-science nextmaze))))","problem":117,"user":"510cd1dde4b078ea71921124"},{"problem":117,"code":"(fn [board]\n  (let [w      (count (first board))\n        search (fn f\n                 ([board coords] (f board coords {}))\n                 ([board [x y :as coords] acc]\n                    (let [chr (get-in board [y x] \\#)]\n                      (if (or (contains? acc coords)\n                              (= chr \\#))\n                        acc\n                        (->> (assoc acc coords chr)\n                             (f board [x       (dec y)])\n                             (f board [x       (inc y)])\n                             (f board [(dec x) y])\n                             (f board [(inc x) y])))))) ]\n    (->> (apply concat board)\n         (keep-indexed\n          #(when (= %2 \\M)\n             [(rem %1 w) (quot %1 w)]))\n         first\n         (search board)\n         ((complement not-any?)\n          #(= (second %) \\C)))))","user":"5dc88a38e4b02f9375f4e1db"},{"code":"(fn [x]\n   (let [r (range (count x))\n         c (range (count (first x)))\n         idx (for [i r j c] [i j])\n         m [[-1 0][1 0][0 -1][0 1]]\n         s (some #(when (#{\\C} (get-in x %)) %) idx)]\n     ((fn p [start visited]\n        (let [options (mapcat #(map (fn [y] (map + % y)) m) start)\n              valid (filter #(and (not= (get-in x % \\#) \\#)\n                                  (not (some #{%} visited)))\n                            options)]\n          (cond\n           (empty? valid) false\n           (some #{\\M} (map #(get-in x %) valid)) true\n           :default (p valid (concat visited valid)))))\n      [s] [s])))","problem":117,"user":"4f34eb87e4b0e243712b1eba"},{"code":"(letfn [ (get-set [item cm]\n           (loop [res #{} check #{item}]\n             (if (empty? check)\n               res\n               (let [item (first check)]\n                 (recur (conj res item)\n                        (clojure.set/union (disj check item)\n                                           (clojure.set/difference (cm item) res)))))))\n         (color-line [line color cm]\n           (reduce (fn [[data color cm] c]\n                     (case c\n                       \\M [(conj data color) color (link-colors cm \\M color)]\n                       \\C [(conj data color) color (link-colors cm \\C color)]\n                       \\  [(conj data color) color cm]\n                       \\# [(conj data nil) (inc color) cm]))\n                   [[] color cm]\n                   line))\n         (link-colors [cm a b]\n           (assoc (assoc cm a (conj (cm a #{}) b)) b (conj (cm b #{}) a))  )]\n  (fn [maze]\n    (let [[data _ cm](reduce (fn [[data color color-map] line]\n                               (let [[d c cm] (color-line line color color-map)]\n                                 [(conj data d) c cm]))\n                             [[] 0 {}]\n                             maze)\n          cm (reduce (fn [cm [a b]] (if (and a b) (link-colors cm a b) cm))\n                     cm\n                     (mapcat #(map vector % %2) data (rest data)))]\n      (if ((get-set \\M cm) \\C) true false))))","problem":117,"user":"519ef784e4b087743fad2198"},{"problem":117,"code":"(fn [maze]\n  (let [transpose (fn [coll] (apply mapcat (comp list str) coll))\n        reachable? (fn [s] (re-find #\"(C@|@C)\" s))\n        walk (fn [s]\n               (reduce (fn [s [x y]] (str (subs s 0 x) (apply str (repeat (- y x) \\@)) (subs s y (count s)))) s\n                 (let [matcher (re-matcher #\"[ ]*[M@]+[ ]*\" s)]\n                   (loop [r [] match (re-find matcher)]\n                     (if match\n                       (recur (conj r [(.start matcher) (.end matcher)]) (re-find matcher))\n                       r)))))\n        search (fn [m]\n                 (let [n (->> (map walk m) transpose (map walk) transpose)]\n                   (if (= m n)\n                     m\n                     (recur n))))\n        m (search maze)]\n    (boolean (or (some reachable? m) (some reachable? (transpose m))))))","user":"4f05ea25535dcb61093f6c02"},{"problem":117,"code":"(fn [m]\n  (let [rows (count m) cols (count (first m)) maze (mapv vec m)]\n    (letfn [(get-pos [c]\n              (first (for [x (range rows) y (range cols)\n                            :when (= (get-in maze [x y]) c)]\n                        [x y])))\n            (collect [[x y] travelled]\n              (let [neighbors (concat\n                                (if (pos? x) [[(dec x) y]])\n                                (if (pos? y) [[x (dec y)]])\n                                (if (< (inc x) rows) [[(inc x) y]])\n                                (if (< (inc y) cols) [[x (inc y)]]))\n                    candidates (filter #(and\n                                         (not= (get-in maze %) \\#)\n                                         (not (contains? travelled %)))\n                                       neighbors)]\n                  (reduce #(collect %2 %1)\n                          (conj travelled [x y])\n                          candidates)))]\n      (true? (some #(= (get-in maze %) \\C) (collect (get-pos \\M) #{}))))))","user":"5392bfdee4b0b51d73faaeb2"},{"code":"(fn [b]\n (letfn [(nbors [x y]\n           (let [m [[(- x 1) y] [x (- y 1)]\n                    [(+ x 1) y] [x (+ y 1)]]]\n             (filter (fn [[r s]]\n                       (let [e (get (get b s) r)]\n                         (or (= \\space e) (= \\C e)))) m)))\n         (pois [] (into {} (for [i (range (count (first b)))\n                                 j (range (count b))\n                                 :when (or (= \\M (get (get b j) i)) (= \\C (get (get b j) i)))]\n                             [(get (get b j) i) [i j]])))\n         (step [ps] (set (mapcat (fn [[r s]] (nbors r s)) ps)))\n         (f [xs p] (let [nxt (clojure.set/union xs (step xs))]\n                     (if (or (= nxt xs)\n                             (contains? nxt (p \\C)))\n                       nxt\n                       (recur nxt p))))]\n   (let [p (pois) start (set [(p \\M)])]\n     (contains? (f start p) (p \\C)))))","problem":117,"user":"5097b556e4b00ad8bab4e970"},{"problem":117,"code":"(fn [coll]\n  (let [primes [2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97]]\n\n  (letfn [\n          (test-mc [coll]\n            (loop [c coll ret [] M 0 C 0 lastcol (repeat (count (first c)) 0) P primes]\n              (if (empty? c)\n                [ret M C]\n                (let [[r mo ch p] (check-line (first c) M C lastcol P)]\n                  (recur (rest c) (conj ret r) mo ch r p)))))\n\n          (check-line [s M C lastcol P]\n            (loop [t s p P r [] M M C C l lastcol]\n              (if (empty? t)\n                [r M C p]\n                (let [lft (last r)\n                      up (first l)\n                      x (if (= up 0)\n                          (if (or (nil? lft)(= 0 lft)) (first p) lft)\n                          (if (or (nil? lft)(= 0 lft)(= up lft)) up (* lft up)))\n                      q (if (= x (first p)) (rest p) p)\n                     ]\n                  (case (first t)\n                    \\#     (recur (rest t) q (conj r 0) M C (rest l))\n                    \\M     (recur (rest t) q (conj r x) x C (rest l))\n                    \\C     (recur (rest t) q (conj r x) M x (rest l))\n                           (recur (rest t) q (conj r x) M C (rest l))\n                           )))))\n          ]\n    \n  (let [[r mo ch] (test-mc coll)\n        c (distinct (filter #(and (not= % 0)(not= % mo)(not= % ch)) (flatten r)))\n        ]\n     (or (= (mod mo ch) 0)\n        (= (mod ch mo) 0)\n        (not (nil? (some true? (map #(= (mod % (* ch mo)) 0) c)))))))))","user":"545537c1e4b0e397800069dd"},{"problem":117,"code":"(fn [maze]\n  (let [maze (mapv vec maze)\n        moves\n        (for [i (range (count maze))\n              j (range (count (first maze)))\n              :let [cell (get-in maze [i j])]\n              :when (#{\\C \\space} cell)\n              :when (some #{\\M}\n                          (map #(get-in maze [(+ i %1) (+ j %2)])\n                               [-1 0 0 1]\n                               [0 -1 1 0]))]\n          (if (= cell \\C) :solved [i j]))]\n    (if (empty? moves) false\n      (if (some #{:solved} moves) true\n        (recur (reduce #(assoc-in %1 %2 \\M) maze moves))))))","user":"562cd94ee4b0a45d2ff83015"},{"problem":117,"code":"(fn [maze]\n  (let [r-cnt (count maze)\n        c-cnt (count (first maze))\n        adjacent (fn [[r c]] [[(inc r) c]\n                              [(dec r) c]\n                              [r (inc c)]\n                              [r (dec c)]])\n        valid? (fn [visited s]\n                 (not\n                  (or (visited s)\n                      (= \\# (get-in maze s))\n                      (nil? (get-in maze s)))))\n        find-mouse #(reduce-kv\n                     (fn [s i v]\n                       (let [j (.indexOf v \"M\")]\n                         (if (> j -1) [i j] s)))\n                     []\n                     maze)]\n    (loop [square (find-mouse)\n           frontier []\n           visited #{}]\n      (if (= \\C (get-in maze square))\n        true\n        (let [neighbors (filter (partial valid? visited) (adjacent square))\n              [new-square & new-frontier] (concat frontier neighbors)]\n          (if new-square\n            (recur new-square new-frontier (conj visited square))\n            false))))))","user":"57609d91e4b08062f99a4e9b"},{"code":"(fn [m]\r\n  (let [w (count (first m))\r\n        h (count m)\r\n        s (first (filter #(= (get-in m %) \\M) (for [r (range h) c (range w)] [r c])))\r\n        p (transient #{s})\r\n        l [[-1 0] [0 1] [1 0] [0 -1]]]\r\n    (letfn [(f [c d]\r\n              (let [[nr nc] (map + c d)]\r\n                (if (or (< nr 0) (>= nr h) (< nc 0) (>= nc w) (p [nr nc])) false\r\n                    (condp = (get-in m [nr nc])\r\n                      \\C true\r\n                      \\space (do (conj! p [nr nc]) (some #(f [nr nc] %) l))\r\n                      false))))]\r\n      (true? (some #(f s %) l)))))","problem":117,"user":"4dc1ee85535d020aff1edf91"},{"code":"(fn [maze] (let [\r\n  [w h]     [(count (first maze)) (count maze)]\r\n  at        (fn [[x y]] (nth (nth maze y) x))\r\n  in?       (fn [v b] (and (>= v 0) (< v b)))\r\n  can-walk? (fn [[x y]] (and (in? x w) (in? y h) (not= \\# (at [x y]))))\r\n  dirs      [[-1 0] [1 0] [0 -1] [0 1]]\r\n  cands     (fn [[i j]] (->> dirs (map (fn [[x y]] [(+ x i) (+ y j)])) (filter can-walk?)))\r\n  start     (some identity (for [i (range w) j (range h)] (if (= \\M (at [i j])) [i j])))]\r\n  (loop [visited #{} to-visit [start]]\r\n    (if-let [v (first to-visit)]\r\n      (if (= (at v) \\C) true\r\n        (recur (conj visited v)\r\n          (into (rest to-visit) (filter #(not (visited %)) (cands v)))))\r\n      false))))","problem":117,"user":"50336c6be4b0c6c1199c710f"},{"problem":117,"code":"(fn [maze]\n    (let [num-rows    (-> maze count inc range)\n          num-cols    (-> maze first count inc range)\n          entities    {\\M :start \\C :end \\space :clear \\# :wall}\n          dirs        [[-1 0] [1 0] [0 -1] [0 1]]\n          thing-at    (fn [loc]\n                        (get entities (get-in maze loc) :wall))\n          adjacents   (fn [[r c]]\n                        (for [[k l] dirs\n                              :let  [i (+ r k) j (+ c l)]\n                              :when (not= (thing-at [i j]) :wall)]\n                          [i j]))\n          find-start  (fn []\n                        (first\n                         (for [i num-rows\n                               j num-cols\n                               :when (= (thing-at [i j]) :start)]\n                           [i j])))\n          explore     (fn [q seen?]\n                        (println \"q:\" q \"seen:\" seen?)\n                        (when (and (seq q))\n                          (if (= (thing-at (peek q)) :end)\n                            true\n                            (let [candidates (->> (peek q)\n                                             adjacents\n                                             (filter (complement seen?)))]\n                            (recur (reduce conj (pop q) candidates)\n                                   (reduce conj seen? candidates))))))]\n      (let [start (find-start)]\n        (boolean (explore [start] #{start})))))","user":"4dfe5a93535d04ed9115e786"},{"code":"(fn [maze]\n  (letfn [\n      (get-cell [maze i j] (get (maze i) j))\n      (height [maze] (count maze))\n      (width [maze] (count (first maze)))\n      (neighbors [maze [i j]]\n        (let [max-i (dec (height maze)) max-j (dec (width maze))]\n          (for [[ii jj] [[i (inc j)] [i (dec j)]  ;EW\n                         [(inc i) j] [(dec i) j]] ;NS\n                :when (and (<= 0 ii max-i) (<= 0 jj max-j)\n                           (not= \\# (get-cell maze ii jj)))]\n            [ii jj])))\n      (indexed [s] (map-indexed #(apply vector %&) (seq s)))\n      (points [maze]\n        (for [[i row] (indexed maze) [j v] (indexed row)]\n          [[i j] v]))\n      (point-where [pred maze] \n        (some (fn [[p v]] (and (pred v) p)) (points maze)))\n      (start [maze] (point-where #(= \\M %) maze))\n      (end [maze] (point-where #(= \\C %) maze))\n      (nodes [maze] (map first (filter #(not= \\# (second %)) (points maze))))\n      (graph [maze]\n        (let [nn (nodes maze)\n              nbrs (into {} (for [n nn] [n (neighbors maze n)]))]\n          {:nodes nn :neighbors nbrs}))\n      (next-nodes [g n] ((:neighbors g) n))\n      (depth-first\n        [graph start]\n        (let [walk\n              (fn walk [seen trans]\n                (let [frontier (drop-while seen trans)]\n                  (when-let [next-node (first frontier)]\n                    (lazy-seq\n                     (cons next-node\n                           (walk (conj seen next-node)\n                                 (concat (next-nodes graph next-node) frontier)))))))]\n          (walk #{start} (next-nodes graph start))))]\n    (let [goal (end maze)]\n      (boolean (some #(= % goal) (depth-first (graph maze) (start maze)))))))","problem":117,"user":"4ed188c8535d44c135fd68cf"},{"problem":117,"code":"(fn [xss]\n  (let [height (count xss)\n        width (count (first xss))\n        coords (for [y (range height) x (range width)] [x y])\n        grid (zipmap coords (apply concat xss))\n        start (first (first (filter #(= \\M (val %)) grid)))\n        neighbours (fn [[x y]] [[x (dec y)] [x (inc y)] [(dec x) y] [(inc x) y]])\n        f (fn [grid start]\n            (loop [grid grid [pos & rst] start visited #{}]\n              (if (nil? pos)\n                false\n                (if (= \\C (grid pos))\n                  true\n                  (let [next-steps (filter #(and (nil? (visited %))\n                                                 (not (nil? (grid %)))\n                                                 (not= \\# (grid %))) (neighbours pos))]\n                    (recur grid\n                           (concat rst next-steps)\n                           (conj visited pos)))))))]\n    (f grid [start])))","user":"5d81b40ce4b0915913b1d379"},{"code":"(fn [maze]\n  (let [at (fn [[x y]] (get (get maze y) x))\n        mouse? (fn [p] (= (at p) \\M))\n        cheese? (fn [p] (= (at p) \\C))\n        space? (fn [p] (= (at p) \\space))\n        neighbours (fn [[x y]] [[(dec x) y] [(inc x) y] [x (dec y)] [x (inc y)]])]\n    (loop [visited #{}\n           current (set (for [y (range (count maze)) x (range (count (get maze y))) :when (mouse? [x y])] [x y]))]\n      (if (seq current)\n        (if (some cheese? current)\n          true\n          (recur (clojure.set/union visited current)\n                 (set (filter #(and (or (space? %) (cheese? %)) (not (visited %))) (mapcat neighbours current)))))\n        false))))","problem":117,"user":"4f9120d8e4b0dcca54ed6c96"},{"problem":117,"code":"(fn solve [v]\n  (let [n (vec\n            (for [r (range (count v))]\n              (apply str\n                (for [c (range (count (nth v r)))\n                      :let [old (get-in v [r c])]]\n                  (if (some #{\\C}\n                        (for [x [-1 0 1]\n                              y [-1 0 1]\n                              :when (some zero? [x y])]\n                          (get-in v [(+ r x)(+ c y)])))\n                    (case old\n                      \\space \\C\n                      \\M \\W\n                      old)\n                    old)))))]\n    (cond\n      (= n v) false\n      (some #(some #{\\W} %) n) true\n      :else (recur n))))","user":"53f7820be4b0de5c41848560"},{"code":"(fn [b]\n  (letfn [(gb [x]\n            (->> (for [i (range (count x)) j (range (count (first x)))] [i j]) (group-by #(get-in x %))))\n          (adj? [x y] (= 1 (apply + (map #(Math/abs (- %1 %2)) x y))))\n          (adj-any? [s x] (some true? (map #(adj? x %) s)))\n          (grow [s a] (into a (reduce #(if (adj-any? %1 %2) (conj %1 %2) %1) (set a) s)))\n          ]\n    (let [x0 (gb b)]\n      (loop [s (set (x0 \\space)) m (set (x0 \\M))]\n        (let [n (grow s m)]\n          (if (= (count n) (count m))\n            (not (nil? (adj-any? n (first (x0 \\C)))))\n            (recur (remove n s) n)))))))","problem":117,"user":"528e64b7e4b0239c8a67aedd"},{"code":"(fn lab[board]\n  (let [rows (count board)\n\t      cols (count (first board))]\n\t\t(letfn [\n\t\t\t\t(getxy[x y] \n\t\t\t\t\t(get-in board [y x]))\n\t\t\t\t(find-start-pos[]\n\t\t\t\t\t(loop [x 0 y 0] \n\t\t\t\t\t\t(if (= \\M (getxy x y)) \n\t\t\t\t\t\t\t[x y] \n\t\t\t\t\t\t\t(let [nx (inc x)\n\t\t\t\t\t\t\t\t\t\tny (if (= nx cols) (inc y) y)\n\t\t\t\t\t\t\t\t\t\tnx (mod nx cols)]\n\t\t\t\t\t\t\t\t(if (< ny rows)\n\t\t\t\t\t\t\t\t\t(recur nx ny))))))\n\t\t\t\t(neighbors[x y] \n\t\t\t\t\t[[x (dec y)] [(dec x) y] [(inc x) y] [x (inc y)]])\n\t\t\t\t(find-in-map[ch m]\n\t\t\t\t\t(filter #(= ch (get % 1)) m))\n\t\t\t\t(find-end[visited [[x y] & queue]]\n\t\t\t\t\t;(prn :visited visited [x y] :queue queue)\n\t\t\t\t\t(let [ns (into {} (for [[x y] (neighbors x y)] [[x y] (getxy x y)]))\n\t\t\t\t\t      trg (find-in-map \\C ns)\n\t\t\t\t\t\t\t\tfree (find-in-map \\space ns)\n\t\t\t\t\t\t\t\tunvis (map first (remove #(visited (first %)) free))\n\t\t\t\t\t\t\t\tnq (concat queue unvis)]\n\t\t\t\t\t\t;(prn :ns ns :trg trg :free free :unvis unvis :nq nq)\n\t\t\t\t\t\t(cond \n\t\t\t\t\t\t\t(not-empty trg)\ttrue\n\t\t\t\t\t\t\t(empty? nq) false\n\t\t\t\t\t\t\t:else (recur (conj visited [x y]) nq))))]\n\t\t\t(find-end #{} [(find-start-pos)]))))","problem":117,"user":"4f1fd734535d64f6031464a5"},{"problem":117,"code":"; Start at the Mouse, and then spread through all reachable spaces\n; until you run out or encounter the Cheese.\n  (fn [maze]\n    (let [a2 (mapv vec maze)\n          at (fn [[x y]] (get (get a2 x) y))\n          neighbors-of (fn [[x y]]\n                         (filter #(#{\\space \\C} (at %))\n                                 (map (fn [[dx dy]] [(+ x dx) (+ y dy)])\n                                      [[0 1] [0 -1] [1 0] [-1 0]])))\n          mouse (first (drop-while #(not= \\M (at %)) \n                                   (for [x (range (count a2)) y (range (count (first a2)))] [x y])))]\n      (true?\n        (loop [visited #{mouse} neighbors [mouse]]\n          (or (some #(= \\C (at %)) neighbors)\n              (if (seq neighbors)\n                (recur\n                  (reduce conj visited neighbors)\n                  (mapcat #(remove visited (neighbors-of %)) neighbors))))))))","user":"54f26266e4b024c67c0cf8c5"},{"code":"(fn [maze]\n    (let [get-pos (fn [x y]\n                    (get-in maze [y x]))\n          max-y (count maze)\n          max-x (count (first maze))\n          valid-pos? (fn [x y]\n                       (and (>= x 0)\n                            (>= y 0)\n                            (< x max-x)\n                            (< y max-y)))\n          neighbors (fn [x y]\n                      (set (for [[x-diff\n                                  y-diff] [[1 0] [-1 0]\n                                           [0 -1] [0 1]]\n                                  :when (and (valid-pos?\n                                              (+ x x-diff)\n                                              (+ y y-diff))\n                                             (not= (get-pos (+ x x-diff)\n                                                            (+ y y-diff))\n                                                   \\#))\n                                  ]\n                             [(+ x x-diff) (+ y-diff y)])))\n          [start-x\n           start-y] (first (for [x (range max-x)\n                                 y (range max-y)\n                                 :when (= \\C (get-pos x y))]\n                             [x y]))\n          diff clojure.set/difference\n          reachable? (fn reachable? [[x y] visited]\n       \n                       (cond \n                        (= \\M (get-pos x y))\n                        true\n\n                        (empty? (diff (neighbors x y) visited))\n                        false\n\n                        :else\n                        (not (nil?\n                              (some #(reachable? % (conj visited [x y]))\n                                    (diff (neighbors x y) visited))))))]\n      (reachable? [start-x start-y] #{})))","problem":117,"user":"4daea889edd6309eace4d15b"},{"code":"(fn [maze]\n  (let [symbol-coords \n        (fn [s] \n          (let [row (first \n                      (keep-indexed \n                        #(if (re-find (re-pattern s) %2) %1)\n                        maze))\n                col (.indexOf (nth maze row) s)]\n            (vector row col)))\n        mouse (symbol-coords \"M\")\n        cheese (symbol-coords \"C\")\n        valid-pos? (fn [p]\n                     (let [[row col] p]\n                       (and (>= row 0)\n                            (>= col 0)\n                            (< row (count maze))\n                            (< col (count (first maze)))\n                            (not= \\# (nth (nth maze row) col)))))\n        step-pos (fn [p] (let [[row col] p]\n                           (filter valid-pos?  [p\n                                                (vector (+ row 1) col)\n                                                (vector (- row 1) col)\n                                                (vector row (+ col 1))\n                                                (vector row (- col 1))])))\n        step #(set (mapcat step-pos %))\n        step-pair #(vector (second %) (step (second %)))\n        has-cheese? (fn [posns] (not (nil? (posns cheese))))\n        ]\n\n    (has-cheese? \n      (second\n        (last (take-while \n                #(and (not= (first %) (second %))\n                      (not (has-cheese? (first %))))\n                (iterate step-pair [#{mouse} (step #{mouse})])))))))","problem":117,"user":"5141abf1e4b02fd87f5064c3"},{"problem":117,"code":"(fn\n  [coll]\n  (let [pos (fn [mc]\n              (loop [i 0]\n                (when (< i (count coll))\n                  (let [j (.indexOf (nth coll i) (int mc))]\n                    (if (= j -1)\n                      (recur (inc i))\n                      [i j])))))\n        at (fn [[i j]] (nth (nth coll i nil) j nil))\n        next-move (fn [[mi mj]]\n                    (let [moves (map (fn [[i j]] [(+ i mi) (+ j mj)]) [[0 1] [0 -1] [1 0] [-1 0]])]\n                      (filter #(let [c (at %)] (or (= \\space c) (= \\C c))) moves)))\n        mp (pos \\M)]\n    (loop [moves (next-move mp)\n           visited #{mp}]\n      (if (seq moves)\n        (if (some #(= \\C (at %)) moves)\n          true\n          (recur (set (remove visited (mapcat #(next-move %) moves)))\n                 (apply conj visited moves)))\n        false))))","user":"4e521cef535d302ef430da6d"},{"problem":117,"code":"(fn mouse-maze2 [M]\n  (letfn [\n          (adj-matrix [M] ;;construct adj-matrix from the string representation\n            (let [M2 (mapv #(apply vector %) M)]\n              M2))\n\n          (neib [M [x y]] ;;returns positions that are neigh from [x y] considering #\n            (let [ny (count (M 0)) ;;# as invalid\n                  nx (count M)]\n              (letfn [(valid? [[a b]]\n                        (if (and (>= a 0) (< a nx) (>= b 0) (< b ny) (not= \\# ((M a) b)))\n                          true\n                          false))\n                      ]\n                (filter valid? [[(inc x) y] [(dec x) y] [x (inc y)] [x (dec y)]]))))\n\n          (depth-search4 [M pos R] ;;given matrix-adj M and pos [x y] returns all vertices reachable from [x y] in R considering # as walls\n            ;(println pos (neib M pos) R)\n            (loop [l (neib M pos)\n                   R R]\n              (if (= l [])\n                R\n                (let [f (first l)]\n                  (if (not (contains? R f))\n                    (recur (rest l) (depth-search4 M f (conj R f)))\n                    (recur (rest l) R))))))\n          ]\n    (let [M2 (adj-matrix M)\n          lp (for [x (range (count M2))\n                   y (range (count (M2 0)))] [x y])\n          pi (filter (fn [[x y]] \n                       (= \\M ((M2 x) y))) lp)\n          pf (filter (fn [[x y]] \n                       (= \\C ((M2 x) y))) lp)\n          rech (depth-search4 M2 (first pi) #{(first pi)})\n          ]\n      ;(println rech))))\n      (contains? rech (first pf)))))","user":"574f1c24e4b02ea114799255"},{"problem":117,"code":"(fn get-cheese? [maze]\n  (letfn [(row->cells [chars y]\n            (dissoc (reduce (fn [bag c]\n                              (let [cell [(:x bag) y]\n                                    new-bag (update-in bag [c] conj cell)]\n                                (update-in new-bag [:x] inc)))\n                            {\\# [] \\space [] \\M [] \\C [] :x 0}\n                            chars) :x))\n          (all-cells [rows]\n            (apply merge-with into (map-indexed #(row->cells %2 %) rows)))\n          (neighbors [[x y]]\n            [[(inc x) y] [(dec x) y] [x (inc y)] [x (dec y)]])\n          (neighbors? [cellA cellB]\n            (if ((set (neighbors cellA)) cellB) true false))\n          (tour-from [cell cells]\n            (let [visitable (set cells)\n                  new-cons (filter #(neighbors? cell %) visitable)\n                  not-visited (reduce disj visitable new-cons)]\n              (if (empty? new-cons)\n                #{}\n                (reduce conj new-cons (mapcat #(tour-from % not-visited) new-cons)))))]\n    (let [cellmap (all-cells maze)\n          mouse (first (cellmap \\M))\n          cheese (first (cellmap \\C))\n          spaces-n-cheese (conj (cellmap \\space) cheese)\n          accessible (tour-from mouse spaces-n-cheese)]\n      (if ((set accessible) cheese) true false))))","user":"53bf0913e4b0c98a41f5cc99"},{"problem":117,"code":"(fn [b]\n  (let [ns (fn [s] (map #(condp = % \\# -1 \\M 0 \\C -3 0) s))\n        nb (map ns b)\n        mx (dec (count (first b)))\n        my (dec (count b))\n        r (map #(.indexOf % \"M\") b)\n        x (apply max r)\n        y (.indexOf r x)]\n    (loop [q [[x y]]\n           w #{}]\n      (if (empty? q)\n        false\n        (let [f (first q)\n              x (first f)\n              y (last f)\n              v (nth (nth nb y) x)\n              t #(when-not (some #{%} w) %)\n              l (when (> x 0) [(dec x) y])\n              r (when (< x mx) [(inc x) y])\n              u (when (> y 0) [x (dec y)])\n              d (when (< y my) [x (inc y)])\n              nq (reduce conj [] (filter #(not (nil? %)) (map t (vector l r u d))))]\n          (condp = v\n            -3 true\n            0 (recur (concat (rest q) nq) (conj w f))\n            (recur (rest q) w)))))))","user":"55205564e4b08d5046aa8a60"},{"code":"(fn find-cheese [maze]\n  (let [board ((fn [m] (reduce concat [] (map-indexed (fn [r-num r] (map-indexed (fn [c-num v] [[r-num c-num] v]) r)) m))) maze)\n        lookup-board (reduce #(assoc % (first %2) (last %2)) {} board)\n        total-moves (set (map first board))\n        blocked-moves (set (map first (filter #(= \\# (last %)) board)))\n        mouse ((fn [b] (first (filter #(= \\M (last %)) b))) board)\n        cheese ((fn [b] (first (filter #(= \\C (last %)) b))) board)\n        max-row (dec (count maze))\n        max-col (dec (count (first maze)))\n        left  (fn [cell] [(first cell) (max 0 (dec (last cell)))])\n        right  (fn [cell] [(first cell) (min max-col (inc (last cell)))])\n        up  (fn [cell] [(max 0 (dec (first cell))) (last cell)])\n        down (fn [cell] [(min max-row (inc (first cell))) (last cell)])\n        next-moves  (fn [v] [(up v) (down v) (left v) (right v)])\n        possible-moves  (fn [m tm] (let [blocked-or-taken (clojure.set/union tm blocked-moves)] (set (filter #(not (blocked-or-taken %)) (next-moves m)))))]\n    ;;; (println mouse cheese)\n    ;;; (println lookup-board)\n    ;;; (println max-row max-col)\n    (loop [tm #{(first mouse)} pm (possible-moves (first mouse) tm) nm (first mouse)]\n      ;;; (println nm pm tm)\n      ;;; (println nm (up nm) (down nm) (right nm) (left nm))\n      (cond (nil? nm) false\n            (= \\C (lookup-board (first pm))) true\n            true (let [tm (clojure.set/union tm #{nm})\n                       pm (clojure.set/union (clojure.set/difference pm #{nm})\n                                             (possible-moves nm tm))]\n                   (recur tm pm (first pm))\n                 )))))","problem":117,"user":"4f0e4ebd535d0136e6c22322"},{"code":"(fn p117 [mp0]\n  (let\n      [r (count mp0)\n       c (count (mp0 0))\n       mp (for [ri (range r) ci (range c)] [[ri ci] ((vec (char-array (mp0 ri))) ci)])\n       locm (first (first (filter (fn [e] (= \\M (second e))) mp)))\n       locc (first (first (filter (fn [e] (= \\C (second e))) mp)))\n       m (reduce conj {} mp)\n       search (fn sthis [yet loc]\n                (cond (= loc locc) [true yet]\n                      (or (yet loc) (or (= (m loc) nil) (= (m loc) \\#))) [false (conj yet [loc :y])]\n                      true (let [[x y] loc\n                                 ps (filter (fn [p] (and (not (yet p))\n (<= 0 (first p)) (< (first p) r) (<= 0 (second p)) (< (second p) c) )) [[(inc x) y] [(dec x) y] [ x (inc y)] [x (dec y)] ])\n                                 ge (reduce (fn [fye l]\n                                          (if (first fye) fye\n                                              (sthis (second fye) l))\n                                        ) [false (conj yet [loc :y])] ps)\n                                  ]\n                             ge\n                            )))]\n    (first (search {} locm))))","problem":117,"user":"5272669de4b03e8d9a4a742e"},{"problem":117,"code":"(fn [maze]\n  (let [neighbors (apply merge \n                         (for [i (range (count maze))\n                               j (range (count (first maze)))\n                              :when (not= \\# (get-in maze [i j]))]\n                        {[i j] (set (for [neighbor [[(inc i) j] [(dec i) j] [i (inc j)] [i (dec j)]]\n                                      :when (and (not= \\# (get-in maze neighbor))\n                                                 (not (nil? (get-in maze neighbor))))] \n                                      neighbor))}))\n        nodes  (keys neighbors)\n        mouse  (first (filter #(= \\M (get-in maze %)) nodes))\n        cheese (first (filter #(= \\C (get-in maze %)) nodes)) ]\n    (loop [unvisited    (set nodes)\n           path         (list) \n           current-node mouse]\n       (cond (= current-node cheese) true\n             (nil? current-node)     false\n         :else\n         (let [next-node (first (filter unvisited (get neighbors current-node)))]\n           (if (nil? next-node)\n             (recur (disj unvisited current-node)\n                    (rest path)\n                    (first path))\n             (recur (disj unvisited current-node)\n                    (conj path current-node)\n                    next-node)))))))","user":"545e9cf1e4b01be26fd7467f"},{"problem":117,"code":"(fn __ [board]\n   (or\n    (->> (for [i (range (count board))\n               j (range (-> board first count))\n               :when (not= (get-in board [i j])\n                           \\#)]\n           [i j])\n         (reduce\n          (fn [ss [i j :as coord]]\n            (let [neighbors [[(dec i) j]\n                             [i (inc j)]\n                             [(inc i) j]\n                             [i (dec j)]]\n                  neighboring-groups\n                  (filter\n                   (fn [s]\n                     (some s\n                           neighbors))\n                   ss)]\n              (-> (reduce disj ss neighboring-groups)\n                  (conj (into #{coord}\n                              (apply\n                               concat\n                               neighboring-groups))))))\n          #{})\n         (map (fn [s]\n                (into #{}\n                      (map\n                       (fn [coord]\n                         (get-in board coord))\n                       s))))\n         (some (fn [s]\n                 (and (contains? s \\M)\n                      (contains? s \\C)))))\n\n    false))","user":"54246fcce4b01498b1a71aed"},{"code":"(fn\n  [board]\n  ;; first part is just to extract position of M and C\n  (let [start-end-filtered\n        (flatten\n         (filter (comp not empty?)\n                 (map-indexed\n                  (fn [row row-elem]\n                    (filter (comp not nil?)\n                            (map-indexed\n                             (fn [col col-elem]\n                               (cond\n                                (= col-elem \\M) {:M [row col]}\n                                (= col-elem \\C) {:C [row col]}\n                                true nil)) row-elem)))\n                  board)))\n        start-end (conj (first start-end-filtered)\n                        (first (rest start-end-filtered)))\n        m (count board)\n        n (count (first board))]\n    ;; just DFS, not really funtional style\n    (let [S (java.util.Stack.)\n          visited (java.util.HashSet.)]\n      (.push S (start-end :M))\n      (loop []\n        (cond\n         (.empty S) false\n         true\n         (let [[r c] (.pop S)]\n           (if (= [r c] (start-end :C))\n             true\n             (do\n               (.add visited [r c])\n               (doseq [dr [-1 0 1] dc [-1 0 1]]\n                 (when (= 1 (Math/abs (- dr dc)))\n                   (let [new-r (+ r dr) new-c (+ c dc)]\n                     (when (and (>= new-r 0) (< new-r m)\n                                (>= new-c 0) (< new-c n)\n                                (not (= \\# (.charAt (board new-r) new-c)))\n                                (not (.contains visited [new-r new-c])))\n                       (.push S [new-r new-c])))))\n               (recur)))))))))","problem":117,"user":"4db53f87535d87e67b28fe08"},{"code":"(letfn [\n    ; HOF utilities\n    (fixed-point [f]\n      (fn [x]\n        (some (fn [[x y]] (when (= x y) x))\n              (partition 2 1 (iterate f x)))))\n    ; Cells\n    (wall-cell        [] \\#)\n    (open-cell        [] \\space)\n    (mouse-cell       [] \\M)\n    (cheese-cell      [] \\C)\n    (happy-mouse-cell [] \\X)\n    (wall?        [cell] (= cell (wall-cell)))\n    (open?        [cell] (= cell (open-cell)))\n    (mouse?       [cell] (or (= cell (mouse-cell))\n                             (= cell (happy-mouse-cell))))\n    (cheese?      [cell] (or (= cell (cheese-cell))\n                             (= cell (happy-mouse-cell))))\n    (happy-mouse? [cell] (= cell (happy-mouse-cell)))\n    (successor [cell neighbors]\n        (if (some mouse? neighbors)\n          (cond\n            (open? cell)   (mouse-cell)\n            (cheese? cell) (happy-mouse-cell)\n            true           cell)\n          cell))\n    ; Boards\n    (board-from-strings [strs] strs)\n    (strings-from-board [board] board)\n    ; Locations\n    (get-cell [board location]\n      (get-in board location (wall-cell)))\n    (get-neighbor-cells [board location]\n      (map #(get-cell board %)\n        (for [[i j] [[-1 0] [1 0] [0 -1] [0 1]]]\n          (map + location [i j]))))\n    (get-successor [board location]\n      (successor (get-cell board location)\n                 (get-neighbor-cells board location)))\n    (board-map [f board]\n      (vec (map\n        (fn [row] (apply str (map\n          (fn [col]\n            (f board [row col]))\n          (range (count (board row))))))\n        (range (count board)))))\n    (board-any? [f board]\n      (true?\n        (some #(f board %)\n          (for [row (range (count board))\n                col (range (count (board row)))]\n            [row col]))))]\n  (fn [x]\n    (let [b (board-from-strings x)]\n      (board-any? #(happy-mouse? (get-cell %1 %2))\n        ((fixed-point (fn [b] (board-map get-successor b)))\n         b)))))","problem":117,"user":"4f6fbb68e4b07046d9f4efeb"},{"code":"(fn [maze]\n  (let [w (count (first maze))\n        h (count maze)\n        lookup (fn [[x y]] (get-in maze [y x]))\n        mouse (first (for [x (range w) y (range h) :when (= \\M (lookup [x y]))] [x y]))\n        explore (fn [[x y]]\n          (filter (fn [[x y]] (and (>= x 0) (>= y 0) (< x w) (< y h) (not= \\# (lookup [x y]))))\n            [[(inc x) y] [(dec x) y] [x (inc y)] [x (dec y)]]))]\n    (loop [seen #{mouse} frontier #{mouse}]\n      (let [newcells (set (mapcat explore frontier))]\n        (cond\n          (empty? newcells)\n            false\n          (some #(= \\C (lookup %)) newcells)\n            true\n          true\n            (recur (apply conj seen newcells) (apply disj newcells seen)))))))","problem":117,"user":"4ebc08a8535dfed6da9c6d7c"},{"problem":117,"code":"(fn build-graph [maze]\n  (let [\n         row-count (count maze)\n         column-count (count (first maze))]\n    (letfn\n      [\n        (cell-neighbours [[row column] row-count column-count]\n                         (filter\n                           (fn [[r c]]\n                             (and (<= r row-count) (<= c column-count) (>= c 0) (>= r 0)))\n                           (list [(inc row) column] [(dec row) column] [row (inc column)] [row (dec column)])))\n\n        (get-cell [maze row column]\n                  (.charAt (maze row) column))\n        (find-symbols [symbols]\n                      (for [r (range 0 row-count) c (range 0 column-count) :when (contains? symbols (get-cell maze r c))]\n                        [r c]))\n        (bfs [edges start]\n             (\n               (fn breadth-first-search [edges [current & waiting :as visit-queue] visited]\n                 (if (empty? visit-queue)\n                   visited\n                   (let [\n                          candidate-edges (filter #(contains? % current) edges)\n                          candidate-nodes (distinct (mapcat (fn [edge] (filter #(not= % current) edge)) candidate-edges))\n                          new-nodes (filter #(not (contains? visited %)) candidate-nodes)\n                          ]\n                     (recur edges (concat new-nodes waiting) (conj visited current)))))\n               edges [start] #{}))]\n      (let [\n\n             mouse (first (find-symbols #{\\M}))\n             cat (first (find-symbols #{\\C}))\n             nodes (into #{} (find-symbols #{\\C \\M \\space}))\n             edges (mapcat\n                     (fn [node]\n                       (let [\n                              neighbours (cell-neighbours node row-count column-count)\n                              graph-neighbours (filter #(contains? nodes %) neighbours)\n                              ]\n                         (map\n                           (fn [n] #{node n})\n                           graph-neighbours)))\n                     nodes)\n             ]\n        (contains? (bfs edges cat) mouse)))))","user":"5654e024e4b0f9d632dd848d"},{"code":"(fn [g]\n    (let [w   (count (first g))\n          h   (count g)\n          xys (for [y (range h) x (range w)] [x y])\n          g   (into {} (for [[x y] xys] [[x y] (get-in g [y x])]))\n          M   (some #(if (= \\M (g %)) %) xys)\n          C   (some #(if (= \\C (g %)) %) xys)\n          g   (assoc g M \\space C \\space)\n          nbs  (fn [[x y]] (for [[dx dy] [[-1 0] [0 -1]]] [(+ x dx) (+ y dy)]))\n          [m eq i] (reduce\n                 (fn [[m eq i] p]\n                   (let [v (g p) \n                         [wp np] (nbs p) \n                         wv (g wp \\#) wl (m wp 0)\n                         nv (g np \\#) nl (m np 0)]\n                    ;(println p i \"v:\" (int v) \"w:\" (int wv) wl \"n:\" (int nv) nl \"eq:\" eq)\n                     (cond\n                       (and (= v wv nv) (not= wl nl))\n                         [(assoc m p (min wl nl)) (assoc eq wl nl) i]\n                       (= wv v) \n                         [(assoc m p wl) eq i]\n                       (= nv v)\n                         [(assoc m p nl) eq i]\n                       :else\n                         [(assoc m p (inc i)) eq (inc i)])))\n                 [{} {} 1]\n                 xys)]\n      (= (eq (m M) (m M)) (eq (m C) (m C)))))","problem":117,"user":"4dbad895535d1e037afb21ae"},{"code":"(fn [m]\n  (letfn [\n    (maze-cell [ i j v]\n        (cond\n            (= v \\space) [:e [i j]]\n            (= v \\M) [:m [i j]]\n            (= v \\C) [:c [i j]]\n            :else false))\n    (maze-line [[r i] l]\n        [(concat r (filter identity (map-indexed (partial maze-cell i) l))) (inc i)]) \n    (maze [m]\n        (first (reduce maze-line [[] 0] m)))\n    (finder [w v] (second (first (filter #(= (first %1) w) v))))\n    (gassoc [vm p np] (assoc vm p (conj (vm p #{}) np)))\n    (create-vertex-edge [connexity c vem [x y :as p]]\n        ; (println \"current vem \" vem)\n        ; (println \"cell \" p)\n        (reduce \n            (fn [vm [dx dy]]\n                (let [np [(+ x dx) (+ y dy)]]\n                (if (contains? c np) \n                (gassoc (gassoc vm p np) np p) ; assoc p et np \n                vm)))\n        vem connexity))\n    (vertex-edges-map [c]\n        (let [connexity [[1 0] [-1 0] [0 1] [0 -1]]]\n            (reduce (partial create-vertex-edge connexity c) {} c)))\n    (rec-search [graph visited [p & ps :as tovisit] target]\n        ; (println \"visited = \" visited \"  ; tovisit \" tovisit)\n        (if (empty? tovisit) false\n            (if (= p target) true\n                (recur \n                    graph \n                    (set (concat visited (graph p)))\n                    (concat ps (filter #(not(contains? visited %)) (graph p)))\n                    target))))\n    ]\n    (let [ maze-m (maze m)\n           cells  (set (map #(second %) maze-m))\n           mouse (finder :m maze-m)\n           cheese (finder :c maze-m)\n           graph (vertex-edges-map cells)]\n         ; (println \"cells = \" cells)\n         ; (println \"mouse = \" mouse)\n         ; (println \"cheese = \" cheese)\n         ; (println  \"graph = \" graph)\n         (rec-search graph #{mouse} [mouse] cheese)\n    )\n  ))","problem":117,"user":"51f59607e4b0abb92f97f9d5"},{"problem":117,"code":"(fn [m]\n  (let [mp (vec (map vec m))\n        neighbours (fn [[x y]] [[(inc x) y] [(dec x) y] [x (inc y)] [x (dec y)]] )\n        any-neighbour-mouse? (fn [maze pos] (some #(= \\M (get-in maze %)) (neighbours pos)))\n        can-be-filled? (fn [maze pos] (and (#{\\C \\space} (get-in maze pos)) (any-neighbour-mouse? maze pos)))\n        all-to-fill (fn [maze]                              \n                      (for [x (range (count maze))\n                            y (range (count (first maze)))\n                            :when (can-be-filled? maze [x y])]\n                        [x y]))\n        fill-one-step (fn [maze] \n                        (reduce #(assoc-in %1 %2 \\M) maze (all-to-fill maze)))      \n        iterate-until-equal (fn [f x]\n                              (let [a (iterate f x)\n                                    b (drop 1 a)\n                                    c (map #(vector %1 %2) a b)]\n                                (ffirst (drop-while #(not= (first %) (second %)) c))))\n        filled-maze (iterate-until-equal fill-one-step mp)\n        ]\n    (not (some #(= \\C % ) (flatten filled-maze)))))","user":"54e345a1e4b024c67c0cf7db"},{"problem":117,"code":"(fn [maze]\n  (let [width (-> maze first count)\n        height (count maze)\n        [pos] (for [row (range height) col (range width) :when (= \\M (get-in maze [row col]))] [row col])\n        nav {:east  {:bear-left :north :bear-right :south :adj {:front [0 1]  :right [1 0]}}\n             :south {:bear-left :east  :bear-right :west  :adj {:front [1 0]  :right [0 -1]}}\n             :north {:bear-left :west  :bear-right :east  :adj {:front [-1 0] :right [0 1]}}\n             :west  {:bear-left :south :bear-right :north :adj {:front [0 -1] :right [-1 0]}}}]\n    (letfn [(look [pos] (-> (get-in maze pos nil) {\\space :empty \\M :empty \\# :wall nil :wall \\C :cheese}))\n            (adj-pos [side course pos] (mapv + pos (get-in nav [course :adj side])))\n            (advance [course pos]\n              (let[right (adj-pos :right course pos)\n                   front (adj-pos :front course pos)\n                   seen-right (look right)\n                   seen-front (look front)]\n                (cond\n                  (not= seen-right :wall) [(-> nav course :bear-right) right seen-right]\n                  (not= seen-front :wall) [course front seen-front]\n                  :else (recur (-> nav course :bear-left) pos))))]\n      (loop [path [pos] course :south pos pos]\n        (let [[course pos found] (advance course pos)]\n          (cond\n            (= found :cheese) true\n            (> (count (filter #{pos} path)) 1) false\n            :else (recur (conj path pos) course pos)))))))","user":"5383668ee4b06839e8705edd"},{"problem":117,"code":"(fn [maze]\n  (letfn [(get-neighbors [[x y]]\n            (remove\n             (fn [[a b]] (or (neg? a) (neg? b)))\n             [[(inc x) y]\n              [x (inc y)]\n              [(dec x) y]\n              [x (dec y)]]))\n          (get-coord [maze [i j]]\n            (if (nil? (some neg? [i j]))\n              (if (and (< i (count maze)) (< j (count (nth maze i))))\n                (nth (nth maze i) j)\n                nil)\n              nil))\n          (get-init-pos [maze chr]\n            (let [rowind (first (filter (fn [i] (< -1 (.indexOf (nth maze i) chr))) (range (count maze))))\n                  letind (.indexOf (nth maze rowind) chr)]\n              [rowind letind]))\n          (is-connected [maze [fst & rst] done]\n            (if (nil? fst) '()\n                (let [valid-neighbors (remove\n                                       (fn [x]\n                                         (or (contains? #{nil \\#} (get-coord maze x))\n                                             (contains? done x))) (get-neighbors fst))]\n                  (if (nil? (some (fn [x]\n                                    (= \\C (get-coord maze x))) valid-neighbors))\n                    (concat valid-neighbors (is-connected maze rst (into done valid-neighbors)))\n                    valid-neighbors)\n                  )))\n          (wm2 [maze q done]\n            (cond\n              (empty? q) false\n              (not (nil? (some (fn [x] (= \\C (get-coord maze x))) q))) true\n              :else (wm2 maze (is-connected maze q done) (into done q))))]\n    (wm2 maze [(get-init-pos maze \"M\")] #{(get-init-pos maze \"M\")})))","user":"51b76227e4b0d906fcd71d35"},{"problem":117,"code":"(fn[ipt]\n  (let [format (fn [args]\n                 (->> args\n                      (map-indexed (fn [idx e]\n                                     (map-indexed\n                                      (fn [idx2 e2] {[idx idx2] (str e2)})\n                                      e)))\n                      (flatten)\n                      (into {})))\n        go-f (fn [ipt v]\n               (let [idx (format ipt)]\n                 (->> v\n                      (map (fn [[l r]] (->> #{[(dec l) r]\n                                             [(inc l) r]\n                                             [l (inc r)]\n                                             [l (dec r)]}\n                                           (remove #(nil? (idx %)))\n                                           (remove #(#{\"#\"} (idx %))))))\n                      (apply concat v)\n                      (set))))\n        m-idx ((clojure.set/map-invert (format ipt)) \"M\")\n        c-idx ((clojure.set/map-invert (format ipt)) \"C\")]\n    (if ((last (take 20 (iterate (partial go-f ipt) #{m-idx})))\n       c-idx) true false)))","user":"50e90813e4b033b0e80d11e7"},{"code":"#(letfn [(g [C]\n           (flatten\n             (map-indexed\n               (fn [i s]\n                 (keep-indexed\n                   (fn [j c]\n                     (when (= c C) [i j]))\n                   s))\n               %)))\n         (A [a [[x y :as h] & t]]\n           (cond\n             (= h (g \\C))\n               true\n             (and (#{\\M \\ } (get-in % h)) (not (a h)))\n               (A (conj a h) (conj t [(+ x 1) y] [(- x 1) y] [x (+ y 1)] [x (- y 1)]))\n             h\n               (A a t)\n             1\n               false))]\n   (A #{} [(g \\M)]))","problem":117,"user":"4ee82539535d93acb0a66878"},{"problem":117,"code":"(fn p [board]\n  (let [\n        search (fn [k board]\n                 (let [h (count board)\n                       w (count (first board))]\n                   (first\n                     (filter\n                       #(not (nil? %))\n                       (apply concat\n                              (for [i (range h)]\n                                (for [j (range w)]\n                                  (if (= k (get-in board [i j]))\n                                    [i j]\n                                    nil))))))))\n\n        bfs (fn [queue movable checked board h w]\n              (if (empty? queue)\n                movable\n                (let [f (peek queue)\n                      i (first f)\n                      j (second f)]\n                  (cond\n                    (or (some #(= % f) checked) (< i 0) (>= i h) (< j 0) (>= j w))\n                    (recur (pop queue) movable checked board h w)\n                    (= (get-in board f) \\#)\n                    (recur (pop queue) movable (conj checked f) board h w)\n                    :else\n                    (recur (conj (pop queue) [(inc i) j] [i (inc j)] [(dec i) j] [i (dec j)])\n                           (conj movable f)\n                           (conj checked f)\n                           board h w)))))\n        c (search \\C board)\n        m (search \\M board)]\n    (not\n      (nil?\n        (some #(= m %)\n              (bfs\n                (conj clojure.lang.PersistentQueue/EMPTY c)\n                #{}\n                #{}\n                board\n                (count board)\n                (count (first board))\n                ))))))","user":"53664e3be4b0243289761e74"},{"problem":117,"code":"(fn [m]\n        (let [maze (mapv vec m)\n              start-loc (first (keep-indexed #(if (>= %2 0) [%1 %2]) (map #(.indexOf % \\M) maze)))\n              all-dirs (fn [[x y]] [[(inc x) y] [(dec x) y] [x (inc y)] [x (dec y)]])\n              not-legal? (fn [[x y]] (or (neg? x)\n                                         (neg? y)\n                                         (>= x (count maze))\n                                         (>= y (count (first maze)))\n                                         (= \\# (get-in maze [x y]))))\n              legal-moves (fn [xy] (remove not-legal? (all-dirs xy)))]\n          (loop [vis #{} nvis #{start-loc}]\n            (let [n2vis (set (remove vis (mapcat legal-moves nvis)))]\n              (cond (empty? n2vis) false\n                    (some #(= \\C (get-in maze %)) n2vis) true\n                    :else (recur (clojure.set/union vis nvis) n2vis))))))","user":"5310e968e4b08068f379ecdd"},{"problem":117,"code":"(fn can-exit? [field]\n  (let [size-y (count field)\n        size-x (count (first field))\n        find-pos (fn [target]\n                   (for [y (range 0 size-y)\n                         x (range 0 size-x)\n                         :let [cell (get-in field [y x])]\n                         :when (= cell target)]\n                     [y x]))\n        in-bounds? (fn [[y x]] (and (>= y 0) (< y size-y)\n                                    (>= x 0) (< x size-x)))\n        get-neighbors (fn [cords]\n                        (for [diff [[0 1] [0 -1] [1 0] [-1 0]]\n                              :let [new-cords (mapv + cords diff)]\n                              :when (in-bounds? new-cords)\n                              :when (not= (get-in field new-cords) \\#)]\n                          new-cords))\n        next-iter (fn [prev] (into prev (mapcat get-neighbors prev)))\n        start-pos (first (find-pos \\M))\n        end-pos (first (find-pos \\C))]\n    (->> (iterate next-iter #{start-pos})\n         (partition 2 1)\n         (take-while (fn [[prev next]] (not= prev next)))\n         (last)\n         (second)\n         (some #{end-pos})\n         (boolean))))","user":"5b13ba71e4b0cc2b61a3be53"},{"problem":117,"code":"(fn [rows]\n    (let [mx (count (first rows))\n          my (count rows)\n          maze (apply concat rows)\n          [_ _ walls mouse cheese]\n          (reduce\n            (fn [[x y walls mouse cheese] column]\n              (let [x' (inc x)\n                    [nx ny] (if (< x' mx) [x' y] [0 (inc y)])]\n                (condp = column\n                  \\M [nx ny (conj walls [x y]) [x y] cheese]\n                  \\C [nx ny walls mouse [x y]]\n                  \\# [nx ny (conj walls [x y]) mouse cheese]\n                  [nx ny walls mouse cheese])))\n            [0 0 #{} nil nil]\n            maze)]\n      (first\n        (drop-while coll?\n                    (iterate\n                      (fn [[checked [current & perimeter] target]]\n                        (cond\n                          (= current target) true\n                          (nil? current) false\n                          :else (let [[x y] current\n                                      assoc-if (fn [col [x' y' :as to-check]]\n                                                 (if\n                                                   (or\n                                                     (contains? checked to-check)\n                                                     (= x' mx)\n                                                     (= y' my)\n                                                     (< x' 0)\n                                                     (< y' 0))\n                                                   col\n                                                   (conj col to-check)))\n                                      perimeter' (-> perimeter\n                                                     (assoc-if [x (dec y)])\n                                                     (assoc-if [x (inc y)])\n                                                     (assoc-if [(dec x) y])\n                                                     (assoc-if [(inc x) y]))\n                                      checked' (-> checked\n                                                   (conj [x (dec y)])\n                                                   (conj [x (inc y)])\n                                                   (conj [(dec x) y])\n                                                   (conj [(inc x) y]))]\n                                  [checked' perimeter' target])))\n                      [walls [mouse] cheese])))))","user":"51e28063e4b08e53a149f0f2"},{"code":"(fn happy-mouse? [maze]\n  (let [h (count maze), w (count (first maze))\n        mouse (.indexOf (apply str maze) (int \\C))\n        mouse-y (quot mouse w), mouse-x (rem mouse w)]\n    (letfn [(at [x y] (nth (nth maze y) x))\n            (outside [x y] (or (neg? x) (neg? y) (>= x w) (>= y h)))\n            (goal [x y] (= \\M (at x y)))\n            (blocked [x y] (= \\# (at x y)))\n            (solved? [x y seen]\n              (cond (outside x y) false\n                    (goal x y) true\n                    (blocked x y) false\n                    (seen [x y]) false\n                    :else\n                    (let [seen (conj seen [x y])]\n                      (or (solved? x (inc y) seen)\n                          (solved? x (dec y) seen)\n                          (solved? (inc x) y seen)\n                          (solved? (dec x) y seen)))))]\n      (solved? mouse-x mouse-y #{}))))","problem":117,"user":"50d93c53e4b0fd36a4b89223"},{"problem":117,"code":"(fn solvable? [maze]\n  (let [reach-memo (atom {})]\n   (letfn [(find-mouse [maze]\n            (let [find-mouse-in-row (fn [row]\n                                      (->>\n                                        (map-indexed vector row)\n                                        (some (fn [e]\n                                                (if (= (second e) \\M) (first e))))))]\n              (->>\n                maze\n                (map-indexed vector)\n                (some #(if-let [col-index (find-mouse-in-row (second %))] (list (first %) col-index))))))\n          (rows [maze]\n            (count maze))\n          (columns [maze]\n            (count (first maze)))\n          (forward [maze [row-index col-index]]\n            (if (>= (dec row-index) 0)\n              [(dec row-index) col-index]))\n          (backward [maze [row-index col-index]]\n            (if (< (inc row-index) (rows maze))\n              [(inc row-index) col-index]))\n          (left [maze [row-index col-index]]\n            (if (>= (dec col-index) 0)\n              [row-index (dec col-index)]))\n\n          (right [maze [row-index col-index]]\n            (if (< (inc col-index) (columns maze))\n              [row-index (inc col-index)]))\n\n          (found? [maze pos]\n            (if pos\n              (= (get-in maze pos) \\C)))\n          (valid? [maze pos]\n            (if pos\n              (not= (get-in maze pos) \\#)))\n          (step [maze current-pos next-pos visited]\n            (and\n              (not (visited next-pos))\n              (valid? maze next-pos)\n              (reachable maze next-pos (conj visited current-pos))))\n          (reachable [maze pos visited]\n            (if (contains? @reach-memo pos)\n              (get @reach-memo pos)\n              ((swap! reach-memo assoc pos (let [forward-pos (forward maze pos)\n                                                backward-pos (backward maze pos)\n                                                left-pos (left maze pos)\n                                                right-pos (right maze pos)]\n                                            (or\n                                              (found? maze forward-pos)\n                                              (found? maze backward-pos)\n                                              (found? maze left-pos)\n                                              (found? maze right-pos)\n                                              (step maze pos forward-pos visited)\n                                              (step maze pos backward-pos visited)\n                                              (step maze pos left-pos visited)\n                                              (step maze pos right-pos visited)\n                                              false\n                                              ))) pos)))]\n    (reachable maze (find-mouse maze) #{}))))","user":"53527551e4b084c2834f4af0"},{"problem":117,"code":"(fn f\n  [xs]\n  (let [sqr #(* % %)\n        junc (fn [[a b]]\n               (->> [[(- a 1) b] [a (- b 1)]\n                     [(+ a 1) b] [a (+ b 1)]]\n                    (filter #(every? (complement neg?) %))\n                    (filter #(and (< (first %) (count xs))\n                                  (< (second %) (count (first xs)))))))\n        poss (fn [ls] (filter #(not= \\# (get-in xs %)) ls))\n        snd (fn [x]\n              (loop [[l & ls] xs i 0]\n                (if (some #{x} l)\n                  [i (->> (map-indexed #(vector %1 %2) l)\n                          (filter #(= (second %) x))\n                          (map first)\n                          first)]\n                  (recur ls (inc i)))))\n        start (snd \\M)\n        end (snd \\C)\n        dist (fn [[a b] [c d]] (+ (sqr (- a c)) (sqr (- b d))))]\n    (loop [i start jln #{}]\n      (let [pos (remove jln (poss (junc i)))]\n        (if (empty? pos)\n          false\n          (if (some #{\\C} (map #(get-in xs %) pos))\n            true\n            (recur (->> (sort-by #(dist % end)\n                                 pos)\n                        first)\n                   (conj jln i))))))))","user":"528a3e14e4b0239c8a67ae72"},{"code":"(fn [board]\n  (let [\n    b (vec (map vec board))\n    nb (fn [b y x]\n        (set (remove nil? (map (fn [[i j]] (get-in b [(+ x i) (+ y j)])) [[0 1] [0 -1] [1 0] [-1 0]]))))\n    step (fn [b]\n  (vec (map-indexed\n   (fn [y r]\n     (vec (map-indexed\n      (fn [x v]\n        (condp = v\n          \\M (if ((nb b x y) \\C) \\X v)\n          \\space (let [n (nb b x y)]\n                   (cond (n \\C) \\C\n                         (n \\M) \\M\n                         :else v))\n          v))\n      r)))   \n   b)))]\n  (loop [c (step b), p b]\n    (cond (some #{\\X} (flatten c)) true\n          (= c p) false\n          :else (recur (step c) c)))))","problem":117,"user":"4e7db3b4535db169f9c796e1"},{"problem":117,"code":"(letfn [(moves [b [x y]]\n            (set (for [xy [[(inc x) y] [x (inc y)] [(dec x) y] [x (dec y)]]\n                       :when (contains? b xy)] xy)))]\n    (fn [b] (let [b (into {} (for [[x rs] (map-indexed vector b)\n                                   [y  v] (map-indexed vector rs)\n                                   :when (not= v \\#)]\n                               [[x y] v]))\n                  m (first (for [[xy v] b :when (= v \\M)] xy))\n                  c (first (for [[xy v] b :when (= v \\C)] xy))\n                  [m c] (if (> (count (moves b c)) (count (moves b m))) [m c] [c m])]\n              (loop [q (list [m b])]\n                (let [[[m b] & q] q\n                      b (dissoc b m)\n                      ps (moves b m)]\n                  (cond (and (empty? q) (empty? ps)) false\n                        (contains? ps c) true\n                        :else (recur (concat (for [p ps] [p b]) q)))\n                  )))))","user":"54c641f8e4b045293a27f628"},{"problem":117,"code":"(fn [r m]\n  (not= nil (some #(re-seq #\"C@\" %)\n                  (flatten (take 50 (iterate r m))))))\n#(map (fn [s] (.replaceAll s \"(M|@) \" \"$1@\"))\n  (reverse (apply map str %)))","user":"541096bde4b01498b1a719b2"},{"problem":117,"code":"(fn [c]\n  (let [mpos (vec (remove nil? (flatten (map-indexed #(map-indexed (fn [idx item] (if (= \\M item) [%1 idx])) %2) c))))\n        cpos (vec (remove nil? (flatten (map-indexed #(map-indexed (fn [idx item] (if (= \\C item) [%1 idx])) %2) c))))\n        spaces (reduce into #{} (map-indexed #(map-indexed (fn [idx item] (if (= \\space item) [%1 idx])) %2) c))]\n    (loop [r #{mpos} route (conj spaces cpos)]\n      (cond\n       (contains? r cpos) true\n       (empty? r) false\n       :else (recur \n              (clojure.set/intersection \n               route\n               (reduce into #{} (map #(list (vec (map - % [1 0])) (vec (map - % [0 1])) (vec (map + % [1 0])) (vec (map + % [0 1]))) r)))\n              (reduce disj route r))\n       ))))","user":"574abbfbe4b02ea114799200"},{"code":"(fn [d r g M N v m]\n  (-> [(filter #(= \\M (g m %)) (N #(M (fn[y][% y]) (r (first m))) (r m)))\n       (v (M v m))]\n      ((fn ![[p m]]\n         (if (seq p)\n           (if (some #(#{\\C} (g m %)) p)\n             p\n             (! [(N #(d % g m) p) (reduce #(assoc-in % %2 \\M) m p)])))))\n      not not))\n(fn [[x y] g m] (filter #(#{\\ \\C} (g m %)) [[(inc x) y] [(dec x) y] [x (dec y)][x (inc y)]]))\n#(range (count %)) \nget-in map mapcat vec","problem":117,"user":"4f296a80e4b0d6649770a02a"},{"code":"(fn [z]\n  (loop [g get-in\n         f filter\n         s (set (for [x (range (count z)) y (range (count (last z)))\n                      :when (#{\\  \\C \\M} (g z [x y]))]\n                  [x y]))\n         c (last (f #(= (g z %) \\C) s))\n         n []\n         m (f #(= (g z %) \\M) s)]\n   (cond ((set m) c) true\n         (= m n) false\n         1 (recur g\n                  f\n                  s\n                  c\n                  m\n                  (set (f s (mapcat (fn [[x y]] [[x y]\n                                                 [x (+ y 1)]\n                                                 [x (- y 1)]\n                                                 [(+ x 1) y]\n                                                 [(- x 1) y]])\n                                    m)))))))","problem":117,"user":"536e0930e4b0fc7073fd6e66"},{"problem":117,"code":"(fn for-science [maze]\n  (let [mouse-pos (loop [i 0]\n                    (let [j (.indexOf (maze i) \"M\")]\n                      (if (not= j -1)\n                        [i j]\n                        (recur (inc i)))))\n        adjacent (fn [[i j]]\n                   (filter #(#{\\ \\C \\M} (get-in maze % nil))\n                           [[(dec i) j] [(inc i) j]\n                            [i (dec j)] [i (inc j)]]))\n        reachable (fn [[i j]]\n                    (loop [discovered? #{}, stack (list [i j])]\n                      (if (empty? stack)\n                        discovered?\n                        (let [pos (peek stack), new-stack (pop stack)]\n                          (if (discovered? pos)\n                            (recur discovered? new-stack)\n                            (recur (conj discovered? pos)\n                                   (into new-stack (adjacent pos))))))))]\n    (true? (some #(= (get-in maze %) \\C) (reachable mouse-pos)))))","user":"5b51b9f8e4b02d533a91bcfe"},{"problem":117,"code":"(fn search\n  [grid]\n  (let [grid (vec (map-indexed (fn [row-idx row]\n                                 (vec (map-indexed\n                                        (fn [col-idx v]\n                                          {:v v :row row-idx :col col-idx})\n                                        row)))\n                               grid))\n        find-node (fn [grid x]\n                    (first\n                      (filter (fn [node]\n                                (= (:v node) x))\n                              (flatten grid))))\n        neighbors (fn [{:keys [row col]}]\n                       (for [row-inc (range -1 (inc 1))\n                             col-inc (range -1 (inc 1))\n                             :when (not= row-inc col-inc)]\n                         [(+ row row-inc) (+ col col-inc)]))\n        bfs (fn [start end]\n              (loop [q (conj (clojure.lang.PersistentQueue/EMPTY) start)\n                     seen #{start}]\n                (let [curr (peek q)]\n                  (cond (not curr) false\n                        (= curr end) true\n                        :else (let [nodes (remove (fn [{:keys [v]}]\n                                                    (= v \\#))\n                                                  (keep (partial get-in grid) (neighbors curr)))]\n                                (recur (into (pop q) (remove seen nodes)) (into seen nodes)))))))\n        start (find-node grid \\M)\n        end (find-node grid \\C)]\n    (bfs start end)))","user":"4dc0ff08535d020aff1edf84"},{"code":"(fn [grid]  \n  (letfn [(member? [x c]\n             (some #(= x %) c))\n    (parse-row [str r]\n             (map-indexed (fn [c v] [[r c] v]) str))\n\t  (parse-grid [str-list]\n            (group-by second\n              (apply concat\n                 (map-indexed (fn [r str] (parse-row str r)) str-list))))\n  \t  (neighbors [[r c]]\n             #{[r (inc c)]\n               [r (dec c)]\n               [(inc r) c]\n               [(dec r) c]})\n\t  (search [target try open]\n            (cond (empty? try) false\n   \t          (= (first try) target) true\n                  (member? (first try) open)\n                    (search\n\t\t      target\n           \t      (clojure.set/difference\n\t\t        (clojure.set/union (neighbors (first try))\n              \t \t\t\t   try)\n           \t        #{(first try)})\n\t \t      (clojure.set/difference\n           \t           open\n\t\t           #{(first try)}))\n\t\t  :else\n                     (search\n\t\t       target\n\t               (clojure.set/difference\n\t\t           try\n\t\t           #{(first try)})\n\t\t       open)))]\n    (let [gm (parse-grid grid)\n          start (first (first (get gm \\M)))\n          target (first (first (get gm \\C)))\n          open (set (map first (get gm \\space)))]\n       (search target\n               (neighbors start)\n\t       open))))","problem":117,"user":"4fe87e56e4b07c9f6fd12c40"},{"code":"(fn n117 [maze]\n  (letfn [(is-nbr [[xa ya] [xb yb]]\n                  (if (or (and (= 1 (java.lang.Math/abs (- ya yb))) (= xa xb))\n                          (and (= 1 (java.lang.Math/abs (- xb xa))) (= ya yb))\n                          )\n                    true))\n          \n          (get-neighboors [c n edges] \n                          (filter identity (map #(cond \n                                                   (= (first %) c) (if (contains? n (second %)) false (second %))\n                                                   (= (second %) c) (if (contains? n (first %)) false (first %))\n                                                   :else false) edges)))\n          (dfs [nodes edges start] \n               (loop [c start s [c] n #{c} \n                      t (get-neighboors c n edges)]\n                 (if (empty? s)\n                   (if (empty? t)\n                     n\n                     (recur (first t) (conj s (first t)) (conj n (first t)) (get-neighboors (first t) n edges)))\n                   (recur \n                     (if (empty? t) (peek s) (first t)) \n                     (if (empty? t) (pop s) (conj s (first t))) \n                     (if (empty? t) n (conj n (first t)))\n                     (if (empty? t) (get-neighboors (peek s) n edges) (get-neighboors (first t) n edges))))))\n          ]\n    (let [nodes (for [x (range (count maze)) \n                      y (range (count (first maze))) \n                      :when (not= \\# (get-in maze [x y]))] \n                  [x y])\n          edges (set (mapcat (fn [x] (map #(set [x %]) (filter #(is-nbr x %) nodes))) nodes))\n          start (first (for [x (range (count maze)) \n                            y (range (count (first maze))) \n                            :when (= \\M (get-in maze [x y]))]\n                         [x y]))]\n      (if (some #(= \\C %) (map #(get-in maze %) (dfs nodes edges start)))\n        true\n        false)\n      )))","problem":117,"user":"52b43468e4b0c58976d9ad1b"},{"problem":117,"code":"(fn [maze]\n       (let [maze-map (into {} (for [[x row] (map-indexed vector maze)\n                                     [y val] (map-indexed vector row)\n                                     :when (not= \\# val)]\n                                 [[x y] val]))\n             start-pos ((clojure.set/map-invert maze-map) \\M)\n             end-pos ((clojure.set/map-invert maze-map) \\C)\n             neighbours (fn [[x y]]\n                          (filter maze-map [[(inc x) y]\n                                            [(dec x) y]\n                                            [x (inc y)]\n                                            [x (dec y)]]))\n             solver\n             (fn [stack used]\n               (cond (some #{end-pos} stack) true\n                     (empty? stack) false\n                     :else (recur (concat (rest stack)\n                                          (remove used (neighbours (first stack))))\n                                  (conj used (first stack)))))\n             ]\n         (solver [start-pos] #{})\n         ))","user":"5a062e07e4b01bb0ae8afdc5"},{"problem":117,"code":"(fn maze-solvable? [maze]\n  (let [find-position (fn [c]\n                        (first (for [row (range (count maze)) \n                                     col (range (count (first maze)))\n                                     :when (= (get-in maze [row col]) c)] \n                                 [row col])))\n        mouse-position (find-position \\M)\n        cheese-position (find-position \\C)\n        walkable-positions (fn [[row col]] \n                             (->> #{[row (inc col)] [row (dec col)]\n                                    [(inc row) col] [(dec row) col]}\n                                  (filter (fn [[r c]] (and (>= r 0) (>= c 0)\n                                                           (< r (count maze))\n                                                           (< c (count (first maze))))))\n                                  (remove #(#{\\# \\M} (get-in maze %)))))]\n    (boolean \n     ((->> [mouse-position #{} []]\n           (iterate (fn [[position visited-positions stack]]\n                      (let [[next-position & save] (remove visited-positions \n                                                           (walkable-positions position))]\n                        (if next-position\n                          [next-position \n                           (conj visited-positions next-position) \n                           (concat stack save)]\n                          [(first stack) visited-positions (rest stack)]))))\n           (drop-while #(not (nil? (first %))))\n           first\n           second) \n      cheese-position))))","user":"5c506951e4b0f9f7a8770ec5"},{"code":"(fn can-get-cheese? [maze]\n  (let [rows (count maze)\n        cols (count (first maze))\n        mstr (apply str maze)\n        find (fn [c]\n               (let [i (.indexOf mstr (str c))]\n                 (when-not (neg? i)\n                   [(quot i cols) (rem i cols)])))\n        mouse (find \\M)\n        cheese (find \\C)\n        maze (vec (map vec maze))\n        dirs [[0 1] [1 0] [0 -1] [-1 0]]\n        gimz (partial get-in maze)\n        move (fn [pt] ; [row col]\n               (for [drdc dirs\n                     :let [[r c :as rc] (map + pt drdc)]\n                     :when (and (not-any? neg? rc)\n                                (< r rows) (< c cols)\n                                (not= (gimz rc) \\#))]\n                 rc))\n        enum (partial map vector (iterate inc 0))]\n    (loop [visited #{mouse}, to-check visited]\n      (let [to-check (set (filter (complement visited)\n                                  (mapcat move to-check)))]\n        (if (seq to-check)\n          (if (some #{cheese} to-check)\n            true\n            (recur (into visited to-check) to-check))\n          false)))))","problem":117,"user":"4e6a412e535d8ccf87e9feb6"},{"problem":117,"code":"(fn [m]\n  (let [maze (mapv vec m)\n        mouse (first (keep-indexed #(let [t (.indexOf %2 \\M)] (when (>= t 0) [%1 t])) maze))\n        valid-tile (fn [tile visited] (and (get-in maze tile) (not= \\# (get-in maze tile)) (nil? (visited tile))))\n        next-steps (fn [mouse visited] (filterv #(valid-tile % visited) (mapv #(mapv + mouse %) [[1 0] [0 1] [-1 0] [0 -1]])))]\n      (loop [tiles [mouse]\n             visited #{}]\n        (cond\n         (empty? tiles) false\n         (= (get-in maze (peek tiles)) \\C) true\n         :else (recur (into [] (concat (next-steps (peek tiles) visited) (pop tiles))) (conj visited (peek tiles)))))))","user":"5dd60c58e4b0948ae9d9ad7c"},{"problem":117,"code":"(fn[grid]\n        (let [index-of\n              (fn [xs x]\n                (loop [a (first xs)\n                       r (rest xs)\n                       i 0]\n                  (cond\n                   (= a x)    i\n                   (empty? r) nil\n                   :else      (recur (first r) (rest r) (inc i)))))\n              \n          find-obj\n              (fn[obj]\n                (loop [r 0]\n                  (let [c (index-of (grid r) obj)]\n                    (if (not (nil? c))\n                      [r c]\n                      (recur (inc r))))))\n\n              walkable?\n              (fn[[r c]]\n                (let [cell (nth (nth grid r) c)]\n                  (or (= \\space cell) \n                      (= \\C cell))))\n\n              goal?\n              (fn[[r c]]\n                (= \\C (nth (nth grid r) c)))\n\n              neighbors\n              (fn[[r c]]\n                (remove nil?\n                        [(if (< 0 r) [(dec r) c])\n                         (if (< 0 c) [r (dec c)])\n                         (if (< r (dec (count grid))) [(inc r) c])\n                         (if (< c (dec (count (grid 0)))) [r (inc c)])]))\n              \n              [cr cc] (find-obj \\C)]\n          (loop [open (conj clojure.lang.PersistentQueue/EMPTY (find-obj \\M))\n                 closed #{}]\n            \n            (if (empty? open)\n              false\n              (let\n                  [head (peek open)\n                   open (pop open)\n                   closed (conj closed head)]\n                ;; (prn \"H: \" head)\n                (if (goal? head)\n                  true\n                  (let [new (for [node (neighbors head)\n                                  :when (and\n                                         (not (contains? closed node))\n                                         (walkable? node))] node)]\n                    ;; (prn \"N: \" new)\n                    (recur (into open new) closed))))))))","user":"57e6f90de4b0bfb2137f5af6"},{"code":"(fn astar[maze]\n (let [get-in (fn [x y m] (nth (nth m y) x))\n      m (apply hash-map (apply concat (for [y (range (count maze)) x (range (count (first maze)))] [[x y] (nth (nth maze y) x)])))\n      start (first (for [[k v] m :when (= \\M (m k))] k))\n      end (first (for [[k v] m :when (= \\C (m k))] k))\n      nebior (fn [[x y] m] (for [[s p] [[(m [(dec x) y])[(dec x) y]] [(m [(inc x) y])[(inc x) y]] [(m [x (inc y)])[x (inc y)]] [(m [x (dec y)])[x (dec y)]]] :when (or (= s \\space)(= s \\M))] p))\n     ]\n\n    (let [r (\n      (fn _ [pos m]\n       (if (= pos start) true\n         (let [nebiors (nebior pos m)]\n          (if (empty? nebiors) false\n            (let [new_m (assoc m pos \\#)] (concat (for [nb nebiors]\n              (_ nb new_m)\n            )))\n           )\n         )\n       )\n      )\n      end m \n    )]  (not= nil (some true? (flatten r))))\n )\n)","problem":117,"user":"522eba30e4b01cdb292c5f0e"},{"problem":117,"code":"(fn m?[m]\n  (let\n    [v (vec (map vec m))\n     a (count m)\n     b (count (m 0))\n     e? (fn[i j] (when (and (> i -1) (< i a) (> j -1) (< j b) (not= ((v i) j) \\#)) [i j]))\n     f (fn[c] (first (for [[i r] (map-indexed vector v)\n                    [j e] (map-indexed vector r)\n                    :when (= e c)] [i j])))\n     pe (f \\C)\n     nn (fn[[i j]] (filter #(not= nil %) [(e? (dec i) j) (e? i (dec j)) (e? i (inc j)) (e? (inc i) j)]))\n     g (fn[s]\n         (let [t (reduce #(apply conj % (nn %2)) s s)]\n           (cond\n             (t pe) true\n             (= (count t) (count s)) false\n             :else (recur t))))]\n    (g #{(f \\M)})))","user":"56824e1be4b0945ebc182a91"},{"problem":117,"code":"(fn [g]\n    (letfn [(positions ([g]\n                        (for [r (range (count g))\n                              c (range (count (first g)))]\n                          {:pos [r c] :value (get-in g [r c])})))\n            (sq ([x] (* x x)))\n            (adj? [[x1 y1] [x2 y2]]\n              (= 1 (+ (sq (- x1 x2)) (sq (- y1 y2)))))\n            (expand-reach [free-pos r]\n              (into r (mapcat #(filter (partial adj? %1) (remove r free-pos)) r)))\n            (fixed-p [vals]\n              (if\n                (or (nil? (second vals)) (= (first vals) (second vals))) (first vals)\n                (fixed-p (rest vals))))]\n      (let [grouped-pos (group-by :value (positions g))\n            m-pos       (:pos (first (get grouped-pos \\M)))\n            c-pos       (:pos (first (get grouped-pos \\C)))\n            free-pos    (map :pos (get grouped-pos \\space))\n            full-reach  (fixed-p (iterate (partial expand-reach (conj free-pos c-pos)) #{m-pos}))]\n        (if ((set full-reach) c-pos) true false))))","user":"583048d9e4b051871117c007"},{"problem":117,"code":"(fn solvable? [maze]\n  (letfn [(get-maze-element [maze [x y]]\n            (get (get maze y [\"nf\"]) x \"nf\"))\n          (find-position [maze element]\n            (first (for [y (range (count maze))\n                         :let [x (first (keep-indexed (fn [i e] (when (= e element) i)) (get maze y)))]\n                         :when x]\n                     [x y])))\n          (vc [maze]\n            (vec (map vec maze)))\n          (start-pos [maze]\n            (find-position maze \\M))\n          (coords [[x y]]\n            [[(dec x) y] [x (dec y)] [x (inc y)] [(inc x) y]])\n          (set-maze-element [vc-maze [x y] e]\n            (if (not= \"nf\" (get-maze-element maze [x y]))\n              (assoc-in vc-maze [y x] e)))\n          (nearest-elements [maze [x y]]\n            (map (partial get-maze-element maze) (coords [x y])))\n          (finish? [maze [x y]]\n            (some #(= \\C %) (nearest-elements maze [x y])))\n          (possible-turns [maze [x y]]\n            (filter not-empty (map #(if (= \\space (get-maze-element maze %)) %) (coords [x y]))))\n          (lock? [maze [x y]]\n            (empty? (possible-turns maze [x y])))\n          (shrink [maze]\n            (map first (partition-by identity maze)))\n          (poss? [maze [x y]]\n            (let [ps (fn [mem-ps maze [x y]]\n                       (let [ps (fn [maze [x y]] (mem-ps mem-ps maze [x y]))]\n                         (cond (finish? maze [x y]) true\n                               (lock? maze [x y]) false\n                               true (let [maze (set-maze-element maze [x y] \\#)\n                                          pt (possible-turns maze [x y])]\n                                      (or (some true? (map #(apply poss? %)\n                                                           (map (fn [p]\n                                                                  [(set-maze-element maze p \\M) p]) pt)))\n                                          false)))))\n                  mem-ps (memoize ps)]\n              (mem-ps mem-ps maze [x y])))]\n    (poss? (vc (shrink maze)) (start-pos maze))))","user":"53973e7be4b0b51d73faaee6"},{"code":"(fn [table]\n  (let [\n    positioned\n    (apply concat\n      (map-indexed \n        (fn [rowid row]\n          (map-indexed\n            (fn [colid cell] [cell [rowid colid]])\n            row))\n        table))\n    step    (fn [xy] (map #(map + xy %) [[1 0] [0 1] [-1 0] [0 -1]]))\n    steps   (fn [xys] (reduce conj xys (apply concat (map step xys))))\n    m       (group-by first positioned)\n    all     (map last positioned)\n    mouse   (set (map last (get m \\M)))\n    cheese  (first (map last (get m \\C)))\n    walls\n    (reduce conj (set (map last (get m \\#)))\n      (reduce disj (set (steps all)) all))]\n  (loop [pmice #{} mice mouse]\n    (if (contains? mice cheese) true\n      (if (= mice pmice) false\n        (recur mice (reduce disj (steps mice) walls)))))))","problem":117,"user":"4f569218e4b0a7574ea71826"},{"problem":117,"code":"(fn [m]\n (let [b (to-array-2d m)\n       r b\n       x (count (first m))\n       y (count m)\n       [[sx sy]] (keep seq (for [i (range x) j (range y) :when (= \\M (aget b j i))] [i j]))]\n  (letfn [(search [r j i]\n           (cond\n            (or (neg? i) (neg? j) (>= i x) (>= j y) (= 1 (aget r j i)) (= \\# (aget b j i))) false\n            (= \\C (aget b j i)) true\n            :else [(aset r j i 1) (search r (inc j) i) (search r (dec j) i) (search r j (inc i)) (search r j (dec i))]))](true? (some true? (flatten (search r sy sx)))))))","user":"5b0180cfe4b0cc2b61a3bd47"},{"code":"(fn for-science [maze]\n  (letfn\n      [(sniff [[x y]] (get (get maze x) y))\n\n       (find-mouse [] (first (for [x (range (count maze))\n                                   y (range (count (first maze)))\n                                   :when (= \\M (sniff [x y]))]\n                               [x y])))\n\n       (moves [[x y]]\n         (remove #(let [smell (sniff %)]\n                    (or (= smell \\#)\n                        (nil? smell)))\n                 [[(dec x) y] [(inc x) y]\n                  [x (dec y)] [x (inc y)]]))\n\n       (history [] (let [coords (ref #{})]\n                     (fn [x]\n                       (dosync\n                        (when-not (@coords x)\n                          (commute coords conj x)\n                          x)))))\n\n       (brie-hunt [cur unexplored]\n         (if (= \\C (sniff cur))\n           ;; Yay!!! Brie!!!\n           true\n\n           ;; Keep searching brave mouse!\n           (for [m (moves cur) :when (unexplored m)]\n             (brie-hunt m unexplored))\n           ))]\n\n    (let [e (history)\n          m (find-mouse)\n          x (e m)]\n\n      (true? (first (flatten (brie-hunt m e)))))))","problem":117,"user":"52d2ca1ce4b099d49816f0b4"},{"code":"(fn [b]\n  (let [g #(get-in b %)\n        s #(range (count %))]\n  ((fn [o]\n     (loop [s #{} [q & t] [(o :s)]]\n       (cond\n         (nil? q) false\n         (= q (o :e)) true\n         (s q) (recur s t)\n         q (let [c (q 0)\n                 d (q 1)]\n             (recur\n               (conj s q)\n               (into t (filter\n                         #(and\n                            (not= \\# (g %))\n                            (g %))\n                         [[(+ c 1) d]\n                          [(- c 1) d]\n                          [c (+ d 1)]\n                          [c (- d 1)]])))))))\n    (into {}\n      (for [x (s (first b))\n            y (s b)\n            :let [l [y x]\n                  z (g l)]]\n        (cond\n          (= z \\M) {:s l}\n          (= z \\C) {:e l}))))))","problem":117,"user":"4f9597e0e4b0dcca54ed6cd4"},{"code":"(fn [b]\n  (letfn [(find-m [b]\n            (let [h (count b)\n                  w (count (first b))]\n              (first\n               (for [i (range h)\n                     j (range w)\n                     :when (= \\M (get-in b [i j]))]\n                 [i j]))))\n          (move-forward [p d]\n            [(mapv + p\n                   (case d\n                     :n [-1 0]\n                     :w [0 -1]\n                     :s [1 0]\n                     :e [0 1])) d])\n          (turn-left [p d]\n            [p (case d\n                 :n :w\n                 :w :s\n                 :s :e\n                 :e :n)])\n          (turn-around [p d]\n            (apply turn-left (turn-left p d)))\n          (turn-right [p d]\n            (apply turn-around (turn-left p d)))\n          (right-is-empty? [b p d]\n            (let [cel (get-in b (first \n                                 (apply move-forward (turn-right p d))) \\#)]\n              (not= \\# cel)))\n          (front-is-empty? [b p d]\n            (let [cel (get-in b (first (move-forward p d)) \\#)]\n              (not= \\# cel)))\n          (new-pos-and-d [b p d]\n            (cond (right-is-empty? b p d) (apply move-forward (turn-right p d))\n                  (front-is-empty? b p d) (move-forward p d)\n                  :else (apply new-pos-and-d b (turn-left p d))))\n          (new-seq [b]\n            (map first\n                 (rest\n                  (iterate #(let [[pos d] %]\n                              (new-pos-and-d b pos d))\n                           [(find-m b) :n]))))\n          (m-or-c [b]\n            (first\n             (drop-while\n              #(= \\space %)\n              (map #(get-in b %)\n                   (new-seq b)))))]\n    (=\\C (m-or-c b))))","problem":117,"user":"529b44afe4b02ebb4ef7509d"},{"code":"(fn [maze]\n  (let [rows (count maze)\n        cols (count (maze 0))\n        cells (for [r (range rows) c (range cols)] [r c])\n        open-cells (reduce #(if (not= \\# (get-in maze %2)) (conj % %2) %) #{} cells)\n        mouse (first (filter #(= \\M (get-in maze %)) open-cells))\n        cheese (first (filter #(= \\C (get-in maze %)) open-cells))\n        adjacent (fn [[r c]] [[r (inc c)] [r (dec c)] [(inc r) c] [(dec r) c]])\n        nextfrontier (fn [frontier unexplored] (set (filter #(contains? unexplored %) (mapcat adjacent frontier))))]\n    (loop [frontier #{mouse} unexplored (disj open-cells mouse)]\n      (cond\n        (contains? frontier cheese) true\n        (empty? frontier) false\n        :else (let [newfrontier (nextfrontier frontier unexplored)]\n                (recur newfrontier (apply disj unexplored newfrontier)))))))","problem":117,"user":"52015698e4b0d7096e99ddba"},{"problem":117,"code":"(fn [m]\n    (let [con (filter identity (concat (flatten (->>\n                                                  (map #(map (fn [a b] (and (not= b \\#) (not= a \\#))) % (rest %)) m)\n                                                  (map-indexed (fn [i l] (map-indexed (fn [j r] (if r #{[i j] [i (inc j)]})) l)))\n                                                  ))\n                                       (flatten (->>\n                                                  (map #(map (fn [a b] (and (not= b \\#) (not= a \\#))) % (rest %)) (apply mapv vector m))\n                                                  (map-indexed (fn [i l] (map-indexed (fn [j r] (if r #{[j i] [(inc j) i]})) l)))\n                                                  ))))\n          mo (first (first (filter (fn [x] (or (= (get-in m (second x)) \\M) (= (get-in m (first x)) \\M))) con)))\n          ch (first (first (filter (fn [x] (or (= (get-in m (second x)) \\C) (= (get-in m (first x)) \\C))) con)))\n\n          ]\n\n      (if (or (nil? mo) (nil? ch)) false\n        (loop [c #{mo}]\n          (if (contains? c ch) true\n                               (let [n (apply conj c (set (map #(cond (contains? c (first %)) (second %) (contains? c (second %)) (first %)) con)))]\n                                 (println n)\n                                 (if (= n c) (contains? n ch)\n                                             (recur n)\n                                             )\n                                 )\n                               )\n          ))\n     \n\n      )\n    )","user":"5921a080e4b09b4ee5954c77"},{"problem":117,"code":"(fn [maze]\n   (let [offsets [[-1 0] [ 0 -1] [ 0 1] [ 1 0]]\n         all-pos   (for [r (range (count maze))\n                         c (range (count (nth maze 0)))] [r c])\n         at        (fn [[r c]] (-> maze (nth r) (nth c)))\n         spaces    (filter #(= (at %) \\space) all-pos)\n         find-char (fn [ch] (some #(if (= ch (at %)) %) all-pos))\n         mouse  (find-char \\M)\n         cheese (find-char \\C)\n         init-spaces (set spaces)\n         proceed (fn [frontier]\n                   (reduce (fn [acc pos] (into acc (map #(map + % pos) offsets)))\n                           #{}\n                           frontier))]\n     (loop [frontier (list mouse)\n            spaces (conj init-spaces cheese)]\n       (let [around (proceed frontier)\n             new-frontier (clojure.set/intersection around spaces)]\n         (cond\n           (empty? new-frontier) false\n           (new-frontier cheese) true\n           :else (recur new-frontier (clojure.set/difference spaces new-frontier)))))))","user":"5e3ef7d4e4b01d43a70e8e2d"},{"problem":117,"code":"(fn [maze]\n  (let [parse (fn [maze]\n                (vec (map-indexed\n                      (fn [y row]\n                        (vec (map-indexed\n                              (fn [x c]\n                                {:content ({\\# :wall, \\space :path\n                                            \\M :mouse, \\C :cheese} c)\n                                 :visited? false\n                                 :coords [y x]})\n                              row)))\n                      maze)))\n\n        down (fn [[y x]]\n               [(inc y) x])\n\n        left (fn [[y x]]\n               [y (dec x)])\n\n        up (fn [[y x]]\n             [(dec y) x])\n\n        right (fn [[y x]]\n                [y (inc x)])\n\n        find-coords (fn [maze x]\n                      (->> (apply concat maze)\n                           (filter (comp #{x} :content))\n                           first\n                           :coords))\n\n        mouse-coords (fn [maze]\n                       (find-coords maze :mouse))\n\n        neighbors (fn [coords] (map #(% coords) [down left up right]))]\n\n    (loop [maze (parse maze)\n           current-coords (mouse-coords maze)\n           to-visit (neighbors current-coords)]\n\n      (let [{:keys [content visited? coords] :as current-cell} (get-in maze current-coords)]\n\n        (cond (empty? to-visit) false\n\n              (or (nil? current-cell) (= :wall content))\n              (recur maze (first to-visit) (rest to-visit))\n\n              (= :cheese content) true\n\n              visited? (recur maze (first to-visit) (rest to-visit))\n\n              :else (let [new-to-visit (concat (neighbors coords) to-visit)]\n                      (recur (assoc-in maze (conj coords :visited?) true)\n                             (first new-to-visit)\n                             (rest new-to-visit))))))))","user":"54d9f7f1e4b024c67c0cf751"},{"code":"(fn for-science [state-map] \n\t(letfn [(to-cost-matrix [state-map]\n\t\t\t\t(vec \n\t\t\t\t\t(for [row-index (range (count state-map))]\n\t\t\t\t\t\t(vec\n\t\t\t\t\t\t(for [cell-index (range (count (nth state-map row-index)))]\n\t\t\t\t\t\t  (if (= (nth (nth state-map row-index) cell-index) \\#) 10000 1)\n\t\t\t\t\t\t)\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t\t(find-pos [state-map char]\n\t\t\t\t(first \n\t\t\t\t\t(for [row-index (range (count state-map))\n\t\t\t\t\t\tcell-index (range (count (nth state-map row-index)))\n\t\t\t\t\t\t:when (= char (nth (nth state-map row-index) cell-index))]\n\t\t\t\t\t\t[row-index cell-index]\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t\t(find-start-pos [state-map]\n\t\t\t\t(find-pos state-map \\M)\n\t\t\t)\n\t\t\t(find-end-pos [state-map]\n\t\t\t\t(find-pos state-map \\C)\n\t\t\t)\n\t\t\t(min-by [f coll]\n\t\t\t\t(when (seq coll)\n\t\t\t\t\t(reduce \n\t\t\t\t\t\t(fn [min this]\n\t\t\t\t\t\t\t(if (> (f min) (f this))\n\t\t\t\t\t\t\t\tthis \n\t\t\t\t\t\t\t\tmin)\n\t\t\t\t\t\t)\n\t\t\t\t\tcoll)\n\t\t\t\t)\n\t\t\t)\n\t\t\t(estimate-cost [step-cost-est y x end-point]\n\t\t\t\t(let [[end-x end-y] end-point]\n\t\t\t\t\t(* step-cost-est\n\t\t\t\t\t   (+ (Math/abs ^Integer (- x end-x)) (Math/abs ^Integer (- y end-y))) \n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t\t(total-cost [newcost step-cost-est y x end-point]\n\t\t\t\t(+ newcost\n\t\t\t\t\t(estimate-cost step-cost-est y x end-point)\n\t\t\t\t)\n\t\t\t)\n\t\t\t(path-cost [node-cost cheapest-nbr]\n\t\t\t\t(+ node-cost\n\t\t\t\t\t(:cost cheapest-nbr 0)\n\t\t\t\t)\n\t\t\t)\n\t\t\t(neighbors\n\t\t\t\t([size-x size-y yx] (neighbors [[-1 0] [1 0] [0 -1] [0 1]] size-x size-y yx))\n\t\t\t\t([deltas size-x size-y yx]\n\t\t\t\t\t(filter (fn [[new-yx-x new-yx-y]]\n\t\t\t\t\t\t\t\t(and (< -1 new-yx-x size-x) (< -1 new-yx-y size-y))\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t(map #(vec (map + yx %)) deltas)\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t\t(astar [start-yx step-est cell-costs end-pos]\n\t\t\t\t(let [size-x (count cell-costs)\n\t\t\t\t\t  size-y (count (first cell-costs))]\n\t\t\t\t\t(loop [steps 0\n\t\t\t\t\t\t  routes (vec (replicate size-x (vec (replicate size-y nil))))\n\t\t\t\t\t\t  work-todo (sorted-set [0 start-yx])]\n\t\t\t\t\t\t(if (empty? work-todo)\n\t\t\t\t\t\t\t[(get-in routes end-pos) :steps steps]\n\t\t\t\t\t\t\t(let [[_ yx :as work-item] (first work-todo)\n\t\t\t\t\t\t\t\trest-work-todo (disj work-todo work-item)\n\t\t\t\t\t\t\t\tnbr-yxs (neighbors size-x size-y yx)\n\t\t\t\t\t\t\t\tcheapest-nbr (min-by :cost (keep #(get-in routes %) nbr-yxs))\n\t\t\t\t\t\t\t\tnewcost (path-cost (get-in cell-costs yx) cheapest-nbr)\n\t\t\t\t\t\t\t\toldcost (:cost (get-in routes yx))\n\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t(if (and oldcost (>= newcost oldcost))\n\t\t\t\t\t\t\t\t\t(recur (inc steps) routes rest-work-todo)\n\t\t\t\t\t\t\t\t\t(recur (inc steps)\n\t\t\t\t\t\t\t\t\t\t\t(assoc-in routes yx\n\t\t\t\t\t\t\t\t\t\t\t\t{:cost newcost\n\t\t\t\t\t\t\t\t\t\t\t\t :yxs (conj (:yxs cheapest-nbr []) yx)\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t(into rest-work-todo\n\t\t\t\t\t\t\t\t\t\t\t\t(map\n\t\t\t\t\t\t\t\t\t\t\t\t\t(fn [w]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t(let [[y x] w]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t[(total-cost newcost step-est y x end-pos) w]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t\tnbr-yxs\n\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t\t]\n\t\t(let [state-cost (to-cost-matrix state-map) \n\t\t\t  start-pos (find-start-pos state-map)\n\t\t\t  end-pos (find-end-pos state-map)]\n\t\t\t(let [res (astar start-pos 1 state-cost end-pos)]\n\t\t\t\t(< (:cost (first res)) 10000)\n\t\t\t)\n\t\t)\n\t)\n)","problem":117,"user":"52763696e4b03e8d9a4a74d7"},{"problem":117,"code":"(letfn [(maze-as-set [maze]\n          (set\n           (for [r (range (count maze))\n                 c (range (count (first maze)))\n                 :when (not= (nth (nth maze r) c) \\#)]\n             [r c])))\n\n        (neighbors [maze [r c]]\n          (set (for [[r0 c0] [[(inc r) c] [r (inc c)]\n                              [(dec r) c] [r (dec c)]]\n                     :when (maze [r0 c0])]\n                 [r0 c0])))\n\n        (location [maze thing]\n          (first (for [r (range (count maze))\n                       c (range (count (first maze)))\n                       :when (= (nth (nth maze r) c) thing)]\n                   [r c])))\n\n        (spread-fire [maze points target]\n          (if (empty? points)\n            false\n            (if (= (first points) target)\n              true\n              (recur (disj maze (first points))\n                     (clojure.set/union (neighbors maze (first points))\n                                        (next points))\n                     target))))]\n  (fn bush-fire [maze]\n    (let [mouse (location maze \\M)\n          cheese (location maze \\C)\n          maze (maze-as-set maze)]\n      (spread-fire maze #{mouse} cheese))))","user":"5712854ce4b07c98581c3a89"},{"problem":117,"code":";; this solution also gives the optimal path from M to C if possible\n(fn [ls]\n  (let [board (map #(replace {\\# -1 \\space 0 \\M 1 \\C 0} %) ls)\n        curstep (fn [board] (apply max (flatten board)))\n        poses (fn [board cur]\n                (->> (keep-indexed\n                      (fn [y row]\n                        (keep-indexed (fn [x e] (if (= e cur) [x y] nil)) row)) board)\n                     (flatten)\n                     (partition 2)\n                     ))\n        update-pos (fn [board pos curstep]\n                     (loop [next-pos (filter\n                                      (fn [[x y]]\n                                        (and (>= x 0) (< x (count (first board)))\n                                             (>= y 0) (< y (count board))))\n                                      (map #(map + pos %) [[1 0] [-1 0] [0 1] [0 -1]]))\n                            board board]\n                       (if (empty? next-pos)\n                         board\n                         (recur (rest next-pos)\n                                (update-in (apply vector (map #(apply vector %) board))\n                                           (reverse (first next-pos))\n                                           #(if (= % 0) curstep (min % curstep))))))\n                     )\n\n        next (fn [board]\n               (let [cur (curstep board)\n                     ps (poses board cur)]\n                 (loop [ps ps\n                        board board]\n                   (if (empty? ps)\n                     board\n                     (recur (rest ps)\n                            (update-pos board (first ps) (inc cur))))\n                   )\n                 ))]\n    (loop [boardseq (iterate next board)\n           prev nil]\n      (if (= prev (first boardseq))\n        (if (zero? (get-in prev (reverse (first (poses ls \\C)))))\n          false\n          true)\n        (recur (rest boardseq) (first boardseq))\n        ))\n    )\n  )","user":"56f7ecdfe4b08e7d20b96834"},{"problem":117,"code":"(fn [[row :as rows]]\n  (let [b (->> (for [x (range (count row)) y (range (count rows))]\n                 [[x y] (get-in rows [y x])]) (into {}))\n        f #(ffirst (filter (comp #{%} val) b))\n        move-one (fn [s] (map #(mapv + s %) [[1 0] [-1 0] [0 1] [0 -1]]))\n        move #(let [n (->> % (mapcat move-one)\n                           (filter (comp #{\\space \\C} b))\n                           (concat %) (set))]\n                (when (not= n %) n))\n        moves (->> (iterate move #{(f \\M)}) (take-while identity) last)]\n    (contains? moves (f \\C))))","user":"5db0172be4b0f8c104ccfc96"},{"problem":117,"code":"(fn [maze]\n  (letfn [(initialize []\n            (reduce #(merge-with into % %2)\n                    (for [i (range (count maze)) j (range (count (maze 0)))]\n                      (let [p ((vec (maze i)) j)]\n                        (cond (= p \\M) {:mouse [i j]}\n                              (= p \\C) {:cheese [i j]}\n                              (= p \\space) {:blank #{[i j]}}\n                              :else {})))))\n          (neighbours [[x y]]\n            (for [dx [-1 0 1] dy [-1 0 1] :when (and (not= 0 (+ dx dy)) (not= 0 dx dy) (not= dx dy))] [(+ dx x) (+ dy y)]))\n          (next-steps [blanks visited cell]\n            (set (remove nil? (map #(get-in (reduce disj blanks visited) [%]) (neighbours cell)))))\n          (reachable? [start end visited blanks]\n            (let [nexts (next-steps blanks visited start)]\n              (cond (empty? nexts) false\n                    (contains? nexts end) true\n                    :else (reduce #(or % %2) (map #(reachable? % end (reduce conj visited nexts) blanks) nexts)))))]\n    (let [layout (initialize)\n          mouse (layout :mouse)\n          cheese (layout :cheese)\n          blanks (layout :blank)]\n      (if (empty? (next-steps blanks #{} cheese)) false\n          (reachable? mouse cheese #{} (conj blanks cheese))))))","user":"58f98231e4b0438e51c2cf4c"},{"code":"(fn [mtx]\n  (let [h (count mtx) w (count (first mtx))\n        l (atom #{})\n        a (juxt dec identity inc)]\n    (letfn [(step [[y x :as pos]]\n              (when-not (or (< y 0) (< x 0) (>= y h) (>= x w) (@l pos))\n                (swap! l conj pos)\n                (let [v (get-in mtx pos)]\n                  (if-not (= \\# v)\n                    (if (= \\C v)\n                      true\n                      (some identity\n                            (for [x' (a x) y' (a y) :when (or (= x' x) (= y' y))] (step [y' x']))))))))]\n      (true?\n        (step\n          (some\n            (fn [[y line]] (let [x (.indexOf (seq line) \\M)] (if (> x -1) [y x])))\n            (map-indexed vector mtx)))))))","problem":117,"user":"50bfe95ce4b080409b860f27"},{"code":"(fn [b]\n  (let [rot (fn [xs] (apply map str xs))\n        fill (partial map (fn [x] (clojure.string/replace x #\" M|M \" \"MM\")))\n        solved? (fn [xs] (not (empty? (filter seq (map (partial re-seq #\"CM|MC\") xs)))))]\n    (loop [xs b stop false]\n      (let [next (fill xs)]\n        (if (and stop (= next xs))\n          (or (solved? xs) (solved? (rot xs)))\n          (recur (rot next) (= next xs)))))))","problem":117,"user":"5201572be4b0d7096e99ddbb"},{"code":"(fn travel [maze]\n  (let [start (loop [i 0]\n                (let [j (.indexOf (nth maze i) \"M\")]\n                  (if (not= j -1) [i j] (recur (inc i)))))\n        adjacent (fn [[x y]]\n                   (filter\n                    #(let [it (get-in maze %)] (or (= it \\ ) (= it \\C)))\n                    [[x (inc y)] [(inc x) y] [x (dec y)] [(dec x) y]]))\n        ]\n    (loop [visited #{}\n           candidates #{start}]\n      (if (empty? candidates)\n        false\n        (let [newvisited (into visited candidates)\n              newcand\n              (clojure.set/difference\n               (set (mapcat adjacent candidates)) newvisited)\n              ]\n          (if (empty? (filter #(= (get-in maze %) \\C) newcand))\n            (recur newvisited newcand)\n            true\n            )\n          )\n        )\n      )\n    )\n  )","problem":117,"user":"52e59ca5e4b09f7907dd1464"},{"code":"(letfn [(v [b [r c]] (nth (b r) c))\n        (nearby [[r c]] [[(inc r) c]\n                         [(dec r) c]\n                         [r (inc c)]\n                         [r (dec c)]])]\n(fn [b]\n  (let [rs (count b)\n        cs (count (b 0))\n        mpos (first\n               (for [r (range rs)\n                     c (range cs)\n                     :when (= \\M (v b [r c]))]\n                  [r c]))]\n    (loop [stack [mpos] seen #{}]\n      (if (empty? stack)\n        false\n        (let [[r c :as pos] (first stack)]\n          (cond\n            (seen pos)\n            (recur (rest stack) seen)\n            \n            (or (< r 0) (< c 0) (>= r rs) (>= c cs)\n              (= \\# (v b pos)))\n            (recur (rest stack) (conj seen pos))\n\n            (= \\C (v b pos))\n            true\n            \n            :else (recur (concat (nearby pos) (rest stack))\n                          (conj seen pos)))))))))","problem":117,"user":"4ddbfb8a535d02782fcbea00"},{"code":"(fn [maze]\n  (letfn [(parse []\n  \t (apply vector (map vec maze)))\n\t  (start [maze] (first (for [x (range (inc (count (first maze))))\n\t\t\t\t     y (range (inc (count maze)))\n\t\t\t\t     :when (= \\M (get-in maze [y x]))]\n\t\t\t\t [y x])))\n\t  (unvisited [maze [y x]] (for [[dx dy] [[-1 0] [1 0] [0 -1] [0 1]]\n\t\t\t\t\t:let [xx (+ x dx)\n\t\t\t\t\t      yy (+ y dy)]\n\t\t\t\t\t:when (#{\\space \\C} (get-in maze [yy xx]))]\n\t\t\t\t    [yy xx]))\n\t  (walk [maze pos]\n\t\t(loop [maze maze ps (unvisited maze pos)]\n\t\t  (if (empty? ps)\n\t\t    [maze false]\n\t\t    (let [p (first ps)\n\t\t\t  [mm r] (walk (assoc-in maze pos \\.) p)]\n\t\t      (cond (= \\C (get-in maze p)) [maze true]\n\t\t\t    r [mm r]\n\t\t\t    :else (recur mm (rest ps)))))))]\n    (let [m (parse)\n\t  [_ r] (walk m (start m))]\n      r)))","problem":117,"user":"4e513ecf535dc968683fc4f6"},{"code":"(fn [board]\n  (let [position (fn [c board]\n                  (some (fn [row]\n                          (let [col (.indexOf (board row) (int c))]\n                            (and (>= col 0)\n                                 [row col])))\n                        (range (count board))))\n        add-neighbours (fn [[row col] board seen queue]\n                        (reduce (fn [acc pos]\n                                  (if (and (not (seen pos))\n                                           (#{\\space \\C} (get-in board pos)))\n                                    (conj acc pos)\n                                    acc))\n                                 queue\n                                 [[(dec row) col]\n                                  [(inc row) col]\n                                  [row (dec col)]\n                                  [row (inc col)]]))\n        start (position \\M board)]\n    (loop [seen #{}\n           queue (conj clojure.lang.PersistentQueue/EMPTY start)]\n      (and (not (empty? queue))\n           (let [pos (peek queue)]\n             (or (= (get-in board pos) \\C)\n                 (recur (conj seen pos)\n                        (add-neighbours pos board seen (pop queue)))))))))","problem":117,"user":"4ee3b586535d10e5ff6f5371"},{"problem":117,"code":"(fn solve-maze [maze] (let [rows (count maze)\n                 columns (count (peek maze))]\n             (letfn [(valid [column row] (and (>= column 0) (>= row 0) (< column columns) (< row rows) (contains? #{\\space \\C} (value column row))))\n                     (value [column row] (nth (nth maze row) column))\n                     (find [c] (some #(if (= (apply value %) c) %) (for [column (range columns) row (range rows)] [column row])))\n                     (neighbours [column row] (set (filter (partial apply valid) (map #(map + % [column row]) [[-1 0] [1 0] [0 -1] [0 1]]))))]\n               (let [mouse (find \\M)\n                     cheese (find \\C)]\n                 (loop [queue [mouse]\n                        seen #{}]\n                   (if (empty? queue)\n                     (contains? seen cheese)\n                     (let [not-seen-neighbours \n                           (clojure.set/difference \n                            (apply neighbours (peek queue)) \n                            seen)]\n                       (recur (vec (concat (pop queue) not-seen-neighbours)) (clojure.set/union seen not-seen-neighbours)))))))))","user":"604d3cb1e4b0b7ec0ac60ac2"},{"problem":117,"code":"(fn [b]\n  (let [h (count b)\n        w (count (first b))\n        v (fn [[x y]]\n            (if (and (< -1 x (inc w)) (< -1 y (inc y)))\n              (get-in b [x y])\n              \\#))\n        c #(vector [% (- %2 1)] [(- % 1) %2] [(+ % 1) %2] [% (+ %2 1)])\n        n #(if (and (= (str (v [% %2])) \" \") \n                    (some #{\\M} (map v (c % %2))))\n             \\M\n             (str (v [% %2])))\n        g (->> (for [x (range h) y (range w)] (n x y))\n               (partition w)\n               (map #(apply str %)))]\n    (if (= b g)\n      (->> (for [x (range h)\n                 y (range w)\n                 :when (= \\C (get-in b [x y]))]\n             (map v (c x y)))\n           (apply #(some #{\\M} %))\n           boolean)\n      (recur (vec g)))))","user":"5c1aadcde4b01240ff567209"},{"problem":117,"code":"(fn is-reachable? [maze]\n  (let [rows (count maze)\n        cols (count (first maze))\n        init-maze (fn [maze]\n                    (letfn [\n                      (decide-type [p]\n                        (cond\n                          (= p \\space) :space\n                          (= p \\#)     :wall\n                          (= p \\C)     :cheese\n                          :else        :mouse))\n                      (init-row [row idx]\n                        (loop [r (vec row), i 0, result []]\n                          (if (empty? r)\n                            result\n                            (recur \n                              (vec (rest r))\n                              (inc i) \n                              (conj result {:row idx, :col i, :type (decide-type (first r)) })))))]\n                    (loop [rows maze, i 0, result []]\n                      (if (empty? rows)\n                        result\n                        (recur\n                          (vec (rest rows))\n                          (inc i)\n                          (into result (init-row (first rows) i)))))))\n        in-maze (init-maze maze)\n        mouse (first (filter #(= :mouse (% :type)) in-maze))\n        calc-moves  (fn calc-moves [row col]\n                      (let [candidates  [[row (dec col)]  ; left\n                                         [row (inc col)]  ; right\n                                         [(dec row) col]  ; down\n                                         [(inc row) col]] ; up\n                            is-inside? (fn [p]\n                                          (let [[row col] p]\n                                            (not\n                                              (cond\n                                                (or (neg? row) (neg? col))  true\n                                                (> row (dec rows))          true\n                                                (> col (dec cols))          true\n                                                :else                       false))))]\n                      (filter is-inside? candidates)))\n        find-cell (fn [pos]\n                    (first (filter #(and (= (% :row) (pos 0)) (= (% :col) (pos 1))) in-maze)))\n        is-cell-a?  (fn [cell type]\n                      (= type (cell :type)))\n        is-wall?    (fn [cell]\n                      (is-cell-a? cell :wall))\n        is-space?   (fn [cell]\n                      (is-cell-a? cell :space))\n        is-cheese?  (fn [cell]\n                      (is-cell-a? cell :cheese))\n        is-mouse?  (fn [cell]\n                      (is-cell-a? cell :mouse))\n        get-open-cells  (fn [cell]\n                          (let [row (cell :row)\n                                col (cell :col)\n                                moves (calc-moves row col)\n                                cells (map find-cell moves)]\n                            (filter #(or (is-space? %) (is-mouse? %) (is-cheese? %)) cells)))\n        cell-to-pos (fn [cell]\n                      (vector (cell :row) (cell :col)))\n        get-open-cells2 (fn [pos]\n                          (get-open-cells (find-cell pos)))\n        remove-visited  (fn [candidates visited]\n                          (remove (fn [p] (not (empty? (filter #(= p %) visited)))) candidates))\n        exists-path?  (fn [start-pos]\n                        (loop [visited [start-pos], move (get-open-cells2 start-pos)]\n                          (if (empty? move)\n                            false\n                            (let [actual (first move)\n                                  other  (rest move)\n                                  movable (get-open-cells actual)\n                                  open-cells (distinct (into other movable))\n                                  new-move (remove-visited open-cells visited)]\n                              (if (is-cheese? actual)\n                                true\n                                (recur (conj visited actual) new-move))))))]\n    (exists-path? (cell-to-pos mouse))))","user":"52cf084ce4b07d0d72b27399"},{"problem":117,"code":"(fn __ [_m]\n  (let [m (mapv #(clojure.string/split % #\"\") _m)\n        fr (fn fr [i [r & rs]]\n             (if (contains? (set r) \"M\")\n               i\n               (fr (inc i) rs)))\n        fm (fn [s]\n             (let [r (fr 0 s)]\n               [r (.indexOf (get s r) \"M\")]))\n        mv (fn [e dx dy]\n             (let [[x y] (fm e)\n                   n [(+ x dx) (+ y dy)]]\n               (case (get-in e n)\n                 \" \" (-> e\n                         (update-in n (constantly \"M\"))\n                         (update-in [x y] (constantly \" \")))\n                 \"C\" true\n                 nil)))\n        rec (fn rec [done? [e & es]]\n              (and (not-empty e)\n                   (let [new-states (for [[dx dy] [[-1 0]\n                                                   [1 0]\n                                                   [0 -1]\n                                                   [0 1]]]\n                                      (mv e dx dy))]\n                     (or (some true? new-states)\n                         (rec (conj done? e)\n                              (remove #(or (empty? %) (done? %))\n                                      (concat es new-states)))))))]\n    (true? (rec #{} [m]))))","user":"57a0b341e4b0c3d858beb8d4"},{"code":"(fn f [a b c]\n  (and (not= a c)\n    (if (re-seq #\"CM|MC\" (pr-str c))\n      true\n      (f b c (apply map str (map #(.replaceAll % \" M|M \" \"MM\") c))))))\n[]\n[]","problem":117,"user":"4ede8789535d10e5ff6f5337"},{"problem":117,"code":"(fn [themap]\n   (let [find-in-map   (fn [themap target]\n                         (first (for [row (range (count themap))\n                                      col (range (count (first themap)))\n                                      :when (= target (get-in themap [row col]))]\n                                  [row col])))\n         start-pos     (find-in-map themap \\M)\n         end-pos       (find-in-map themap \\C)\n         to-visit-from (fn [themap [row col] seen]\n                         (let [candidates [[(inc row) col][(dec row) col][row (inc col)] [row (dec col)]]\n                               rowcount (count themap)\n                               colcount (count (first themap))\n                               inmap    (filter (fn [[row col]]\n                                                  (and (>= row 0) (>= col 0)\n                                                       (< row rowcount) (< col colcount)\n                                                       (not (= \\# (get-in themap [row col])))))\n                                                candidates)]\n                           (clojure.set/difference (set inmap) seen)))]\n     (loop [not-seen #{start-pos} seen #{}]\n       (println (str \"not seen:\" not-seen \" -- seen: \" seen ))\n       (if (empty? not-seen)\n         false\n         (let [next        (first not-seen)\n               not-seen    (clojure.set/difference not-seen #{next})\n               around-next (to-visit-from themap next seen)\n               seen        (conj seen next)]\n           (if (around-next end-pos)\n             true\n             (recur (clojure.set/union around-next not-seen) seen)))))))","user":"547d8e93e4b0c51c1f4d72f4"},{"problem":117,"code":"(fn [board]\n  (letfn [(game-nth [board x y]\n                    (let [width (count (first board))\n                          depth (count board)]\n                      (if (and (<= 0 x (dec width))\n                               (<= 0 y (dec depth)))\n                        (nth (nth board y) x)\n                        nil)))\n          (game-over? [board x y]\n                      (= (game-nth board x y) \\C))\n          (game-over-coll? [board neighbors]\n                           (loop [unchecked-set neighbors]\n                             (cond\n                              (empty? unchecked-set) false\n                              (game-over? board\n                                          (first (first unchecked-set))\n                                          (second (first unchecked-set))) true\n                              :else (recur (rest unchecked-set)))))\n          (neighbors-2d [x y]\n                        (map vector\n                             [(dec x) x x (inc x)]\n                             [y (inc y) (dec y) y]))\n          (unreached-neighbors [board reached-set x y]\n                               (into #{}\n                                     (filter #(and (= (game-nth board (first %) (second %)) \\space)\n                                                   ((complement contains?) reached-set %))\n                                             (neighbors-2d x y))))\n          (game-step [board reached-set unreached-set]\n                     (if (empty? unreached-set)\n                       false\n                       (let [node (first unreached-set)\n                             x (first node)\n                             y (second node)\n                             neighbors (neighbors-2d x y)\n                             unchecked-neighbors (unreached-neighbors board reached-set x y)]\n                         (if (game-over-coll? board neighbors)\n                           true\n                           (recur board\n                                  (clojure.set/union reached-set #{node})\n                                  (clojure.set/union (clojure.set/difference unreached-set #{node})\n                                                     unchecked-neighbors))))))\n          (game-start [board]\n                      (let [width (count (first board))\n                            depth (count board)\n                            start-point (first (for [x (range width)\n                                                     y (range depth)\n                                                     :when (= (game-nth board x y) \\M)]\n                                                 [x y]))]\n                        (game-step board #{} (unreached-neighbors board #{} (first start-point) (second start-point)))))]\n    (game-start board)))","user":"585e2e77e4b0f14aab7c87ac"},{"code":"(fn [maze]\n  (let [n (count maze)\n        m (count (first maze))\n        find #(first\n               (for [i (range n)\n                     j (range m)\n                     :let [pos [i j]\n                           curr (get-in maze pos)]\n                     :when (= curr %)]\n                 pos))\n        start (find \\M)\n        finish (find \\C)\n        valid? (fn [[x y]]\n                 (and\n                   (>= x 0) (< x n)\n                   (>= y 0) (< y m)\n                   (not= (get-in maze [x y]) \\#)))\n        shifts [[0 1] [1 0] [0 -1] [-1 0]]\n        plus (fn [[x1 y1] [x2 y2]] [(+ x1 x2) (+ y1 y2)])\n        not-in #(not (%1 %2))\n        neighbors (fn [[x y] vis]\n                    (->> shifts\n                         (map (partial plus [x y]))\n                         (filter valid?)\n                         (filter (partial not-in vis))))]\n    (loop [[x & _ :as all] (list start) vis #{}]\n      (cond\n        (empty? all) false\n        (= finish x) true\n        :else (recur\n                (concat (rest all) (neighbors x vis))\n                (conj vis x))))))","problem":117,"user":"514c2d05e4b02b8cbb2a9278"},{"problem":117,"code":"(fn for-science [input]\n  (let [matrix (vec (map vec input))\n        height (count matrix)\n        width (count (first matrix))\n        index-of (fn [coll pred]\n                   (loop [index 0]\n                     (if (= index (count coll))\n                       -1\n                       (if (pred (nth coll index))\n                         index\n                         (recur (inc index))))))\n        valid (fn [[row col]] (and (<= 0 row)\n                                   (< row height)\n                                   (<= 0 col)\n                                   (< col width)\n                                   (not= \\# (get-in matrix [row col]))))\n        around (fn [[row col]] (filter valid [[(dec row) col]\n                                              [(inc row) col]\n                                              [row (dec col)]\n                                              [row (inc col)]]))\n        start-row (index-of matrix #(contains? (set %) \\M))\n        start-col (index-of (nth matrix start-row) #(= \\M %))\n        start [start-row start-col]\n        end-row (index-of matrix #(contains? (set %) \\C))\n        end-col (index-of (nth matrix end-row) #(= \\C %))\n        end [end-row end-col]\n        region (loop [region #{start}]\n                 (let [expand (into region (mapcat around region))]\n                   (if (= expand region)\n                     region\n                     (recur expand))))]\n    (contains? (set region) end)))","user":"56ac81ace4b03c432f187347"},{"problem":117,"code":"(fn [board]\n  (let [b (atom (vec (map vec board)));this atom is used as a kind of memory as well\n        [mc mr] (first ;assume only one mouse exists\n                 (for [r (range (count board)) c (range (count (first board)))\n                       :when (= \\M (get-in board [r c]))]\n                   [r c]))]\n    (letfn[(cheeze? [r c]\n                    (if (= \\C (get-in @b [r c])) true ;found cheese\n                      (do\n                        (swap! b update-in [r c] (fn [e] \\M)) ;mark the position\n                        (let [neighbors (for [[nr nc] (map (fn [[dr dc]] [(+ r dr) (+ c dc)]) [[1 0] [-1 0] [0 -1] [0 1]]);go up, down,left and right\n                                              :let [e (get-in @b [nr nc])];e is the character at the neighboring position\n                                              :when (or (= \\space e) (= \\C e))];mouse can only go the empty space or cheese\n                                          (cheeze? nr nc))];for all potential positions, check if cheese can be found\n                          (if\n                            (empty? neighbors) false;no place to go further\n                            (reduce #(or %1 %2) false neighbors))))))];return true if any neighbor return true (note or is not a function so apply or is not allowed)\n      (cheeze? mc mr))))","user":"556c70dae4b09a3098a524fd"},{"problem":117,"code":"(fn for-science?\n  [board]\n  (let [fixpoint\n        (fn [f x]\n          (loop [curr x]\n            (let [next (f curr)]\n              (if (= next curr) next (recur next)))))\n        minx 0\n        miny 0\n        maxx (- (count board) 1)\n        maxy (- (count (first board)) 1)]\n    (let [neighbours\n          (fn [[x y]]\n            (let [u (+ y 1) d (- y 1) l (- x 1) r (+ x 1)]\n              (let [naive\n                    [      [x u]\n                     [l y]       [r y]\n                           [x d]]]\n                (filter (fn [[x y]] (and (>= x minx) (>= y miny)\n                                         (<= x maxx) (<= y maxy)))\n                        naive))))\n          positions\n          (map (fn [x] (map (fn [y] [x y])\n                            (range (+ maxy 1))))\n               (range (+ maxx 1)))]\n      (let [fill-step\n            (fn [posn current-board]\n              (let [curr (get-in current-board posn)\n                    nbrs (into #{} (map #(get-in current-board %) (neighbours posn)))]\n                (if (= \\# curr) curr\n                    (if (contains? nbrs \\M) \\M\n                        curr))))]\n        (let [advance\n              (fn [current-board]\n                (into []\n                      (map (fn [position-row] (clojure.string/join \n                                               \"\"\n                                               (map #(fill-step % current-board) position-row))) \n                           positions)))]\n          (not (contains? (into #{} (clojure.string/join \"\" (fixpoint advance board)))\n                          \\C)))))))","user":"58152157e4b0f478707a0631"},{"code":"(fn [labyrinth]\n  (let [lab (into {}\n        (mapcat\n          (fn [row s]\n            (map\n              (fn [col c]\n                [[row col]\n                 (cond\n                  (= c \\M) :mouse\n                  (= c \\C) :cheese\n                  (= c \\space) :free\n                  :else nil)])\n              (range)\n              s))\n          (range)\n          labyrinth))\n          mouse (some (fn [[k v]] (when (= v :mouse) k)) lab)\n          cheese (some (fn [[k v]] (when (= v :cheese) k)) lab)]\n    \n    (contains? (second\n      (first\n        (drop-while \n          #(not (empty? (first %)))\n          (iterate\n            (fn [[open closed]]\n              (let [new-closed (into closed open)\n                    new-open (into #{}\n                               (filter\n                                 (fn [c]\n                                   (and (not (contains? new-closed c))\n                                        (not= nil (lab c))))\n                                 (mapcat \n                                  (fn [[x y]]\n                                    [[(- x 1) y] [(+ x 1) y] [x (- y 1)] [x (+ y 1)]])\n                                  open)))]\n          \n                [new-open new-closed]))\n            [#{mouse} #{}]))))\n        cheese)))","problem":117,"user":"4e5411e8535d8a8b8723a279"},{"code":"(fn f [a b c]\n  (and (not= a c)\n    (if (re-seq #\"CM|MC\" (pr-str c))\n      true\n      (f b c (apply map str (map #(.replaceAll % \" M|M \" \"MM\") c))))))\n0\n0","problem":117,"user":"4db858d1535d1e037afb218c"},{"code":"(fn [maze]\n  (letfn [(get-neighbor-indexes [row col]\n                                (map (fn [[r-i c-i]]\n                                       [(+ r-i row) (+ c-i col)])\n                                     [[0 1] [1 0] [-1 0] [0 -1]]))\n          (get-possible-steps [[i-row i-col :as pos] maze s-visited]\n                              (let [check-neighbor (fn [pos]\n                                                     (let [val (get-in maze pos)]\n                                                       (and \n                                                         (or (= val \\space) (= val \\C))\n                                                         (not (s-visited pos)))))]\n                                (filter check-neighbor (get-neighbor-indexes i-row i-col))))\n          (get-indexed [coll]\n                       (map vector (range) coll))\n          (get-start-pos [maze]\n                         (some (fn [[row-idx row]]\n                                 (let [col-idx (.indexOf row \"M\")]\n                                   (if (>= col-idx 0) [row-idx col-idx])))\n                               (get-indexed maze)))\n          (near-destination? [neighbors maze]\n                             (some #(= \\C (get-in maze %)) neighbors))]\n    (let [start (get-start-pos maze)]\n      (loop [[f & r :as to-visit] [start]\n             visited #{start}]\n        (if (empty? to-visit) false\n          (let [neighbors (get-possible-steps f maze visited)]\n            (cond \n              (empty? neighbors) false\n              (near-destination? neighbors maze) true\n              :else (recur (into r neighbors) (conj (into visited neighbors) f)))))))))","problem":117,"user":"5003ee7de4b0678c553fc446"},{"problem":117,"code":"(fn mouse-maze [maze]\n  (letfn [(row-to-pos [c [i row]]\n            (->> row\n                 (map-indexed vector)\n                 (filter (comp (partial = c) second))\n                 (map (comp (partial conj [i]) first))))\n          (maze-view [maze-map c]\n            (->> maze-map\n                 (map-indexed vector)\n                 (map (partial row-to-pos c))\n                 (apply concat)\n                 set))\n          (around [[r c]]\n            (into #{} [[(- r 1) c] [(+ r 1) c] [r (+ c 1)] [r (- c 1)]]))]\n    (let [open       (maze-view maze \\space)\n          mouse      (->> (maze-view maze \\M) vec first)\n          cheese     (->> (maze-view maze \\C) vec first)\n          adj-cheese (clojure.set/intersection (around cheese) open)\n          queue      clojure.lang.PersistentQueue/EMPTY]\n      (letfn [(reach [pos seen]\n                (clojure.set/difference\n                  (clojure.set/intersection (around pos) open)\n                  seen))\n              (bfs [queue seen]\n                (if (seq queue)\n                  (let [pos (peek queue)]\n                    (bfs (into (pop queue) (vec (reach pos seen))) (conj seen pos)))\n                  seen))]\n        (boolean (not-empty (clojure.set/intersection\n                              (bfs (conj queue mouse) #{})\n                              adj-cheese)))))))","user":"572ea970e4b0cd1946bd0f89"},{"problem":117,"code":"(fn [d]\n  (let [r (range -1 2)\n        neighbours (fn [[y x]] [[(dec y) x] [y (dec x)] [y (inc x)] [(inc y) x]])\n        get-data (fn [[y x]] (nth (d y) x))\n        in-bounds? (fn [[y x]] (and (>= y 0) (< y (count d)) (>= x 0) (< x (count (d y)))))\n        passable? #(not= \\# (get-data %))\n        find (fn [c] (first (filter #(= c (get-data %)) (for [i (range (count d)) j (range (count (d i)))] [i j]))))\n        start (find \\M)\n        finish (find \\C)\n        n (fn [seen p] (remove seen (filter passable? (filter in-bounds? (neighbours p)))))\n        ]\n        (loop [[h & t] [start] seen #{}]\n          (cond\n            (nil? h) false\n            (= h finish) true\n            :else (recur (concat t (n seen h)) (conj seen h))))))","user":"4faf97d8e4b081705acca258"},{"code":"(fn solvable? [puzzle]\n  (letfn [(find-mouse [puzzle]\n\t\t\t(first (filter (complement nil?) \n\t\t\t(for [x (range 0 (count puzzle)) \n\t\t\t  \t  y (range 0 (count (first puzzle)))] \n\t\t\t     (when (= \\M (get-in puzzle [x y])) [x y]))\n\t\t\t)))\n\t\t\t(neighbors [[x y] puzzle]\n\t\t\t(map #(vector (get-in puzzle %) %) \n\t\t\t\t[[(+ x 1) y]\n\t\t\t\t[(- x 1) y]\n\t\t\t\t[x (+ y 1)]\n\t\t\t\t[x (- y 1)]]\n\t\t\t))]\n\t(loop [current (find-mouse puzzle) tosearch #{} explored #{}]\n\t\t(let [tocheck (neighbors current puzzle)\n\t\t\t  done (filter #(= \\C (first %)) tocheck)\n\t\t\t  remove-explored (fn [s] (clojure.set/difference s explored))\n\t\t\t  valid (remove-explored (into #{} (map #(-> % rest first) (filter #(= \\space (first %)) tocheck))))]\n\t\t\t(cond (seq done) true\n\t\t\t\t  (empty? valid) (if (empty? tosearch) \n\t\t\t\t\t\t\t\t\t false \n\t\t\t\t\t\t\t\t\t (let [f (first tosearch)] (recur f (disj tosearch f) (conj explored current))))\n\t\t\t\t  (empty? tosearch) (let [f (first valid)] (recur f (disj valid f) (conj explored current)))\n\t\t\t\t  :else (let [f (first tosearch)] (recur f (clojure.set/union (disj tosearch f) valid) (conj explored current))) \n\t\t\t)\n\t\t)\n\t)\n\t)\n)","problem":117,"user":"50588af1e4b06522596eba7d"},{"problem":117,"code":"(fn [maze]\n    (let [width (count (first maze))\n          depth (count maze)\n          initial_state\n            (fn [maze width depth]\n              (loop [x 0\n                     x_state {:visited #{}}]\n                (if (>= x width)\n                  x_state\n                  (recur (inc x)\n                         (loop [y 0\n                                y_state x_state]\n                           (if (>= y depth)\n                             y_state\n                             (let [square (get (get maze y) x)]\n                               (cond (= square \\space) (recur (inc y) y_state)\n                                     (= square \\M) (recur (inc y) (assoc y_state :mouse [x y]))\n                                     (= square \\C) (recur (inc y) (assoc y_state :cheese [x y]))\n                                     (= square \\#) (recur (inc y) \n                                                          (assoc y_state\n                                                                 :visited\n                                                                 (conj (get y_state :visited #{}) [x y])))\n                                     :else (assert false \"Invalid square in maze!\")))))))))\n          state (initial_state maze width depth)\n          valid_x? (fn [x] (and (>= x 0) (< x width)))\n          valid_y? (fn [y] (and (>= y 0) (< y depth)))\n          valid_xy? (fn [x y] (and (valid_x? x) (valid_y? y)))\n          neighbors (fn [x y]\n                 (filter (fn [p] (valid_xy? (first p) (second p)))\n                         [[x (inc y)] [x (dec y)] [(dec x) y] [(inc x) y]]))\n          solve_maze (fn find_cheese [x y visited]\n                       (if (contains? visited [x y])\n                         [false visited]\n                         (if (= [x y] (:cheese state))\n                           [true visited]\n                           (let [visited_xy (conj visited [x y])\n                                 nbrs_xy (neighbors x y)]\n                             (loop [nbr (first nbrs_xy)\n                                    remaining_nbrs (rest nbrs_xy)\n                                    visited_so_far visited_xy]\n                               (if (nil? nbr)\n                                 [false visited_so_far]\n                                 (let [[found visited_so_far_after_nbr] (find_cheese (first nbr) (second nbr) visited_so_far)]\n                                   (if found\n                                     [true visited_so_far_after_nbr]\n                                     (recur (first remaining_nbrs) (rest remaining_nbrs) visited_so_far_after_nbr)))))))))]\n      (first (solve_maze (first (:mouse state)) (second (:mouse state)) (:visited state)))))","user":"5a34f342e4b0ddc586f153d1"},{"problem":117,"code":"(fn [maze]\n  (letfn [(parse-maze [m]\n            (let [r (count m)\n                  c (count (first m))\n                  neighbors (fn [[i j]]\n                              [[(dec i) j] [i (dec j)] \n                               [i (inc j)] [(inc i) j]])\n                  get-in-maze (fn [[i j]] (get (get m i :oob) j :oob))\n                  connected? (fn [pos] \n                               ((complement #{\\# :oob}) (get-in-maze pos)))]\n              (into {}\n                    (for [i (range r)\n                          j (range c)\n                          :when (#{\\space \\M \\C} (get-in-maze [i j]))]\n                      [[i j] (into [] (filter connected? \n                                              (neighbors [i j])))]))))\n          (has-path? [adjs start goal]\n            (loop [connected #{start}\n                   current-adj [start]]\n              (cond (and (connected start) (connected goal)) true\n                    (empty? current-adj) false\n                    :else (recur (into connected current-adj)\n                                 (filter #((complement connected) %) \n                                         (mapcat #(adjs %) current-adj))))))]\n    (let [adj-map (parse-maze maze)\n          m (first (for [k (keys adj-map) :when (= \\M (get-in maze k))] k))\n          c (first (for [k (keys adj-map) :when (= \\C (get-in maze k))] k))]\n      (has-path? adj-map m c))))","user":"57a0f256e4b0c3d858beb8dd"},{"problem":117,"code":"(fn f [m]\n  (let [[y x] (map count [m (get m 0)])\n        n (for [y (range y) x (range x) :when (= \\M (get-in m [y x]))] [y x])\n        p (fn [[i j]] (for [[y x] [[1 0] [0 1] [-1 0] [0 -1]]\n                :let [[a b] [(+ i y) (+ j x)], e (get-in m [a b])]\n                :when (#{\\  \\C} e)] {e [a b]}))\n        i (set (apply p n))]\n    ((fn g [z i]\n       (or (not (nil? (some #(apply #{\\C} (keys %)) z)))              \n           (#(if (= (into i %) i) false (g % (into i %)))\n             (set (mapcat (comp #(apply p %) vals) z))))) i i)))","user":"548b7db8e4b0e286459a11fd"},{"code":"(fn for-science [matrix]\n  (let [\n        indexed #(partition 2 (interleave (range) %))\n\n        cells (fn [matrix]\n          (for [[i line] (indexed matrix),\n                [j val]  (indexed line)]\n            {:pos [i j], :val val}))\n\n        maze (fn [matrix]\n           (let [cs (cells matrix),\n                 find (fn [val] (:pos (first (filter #(= val (:val %)) cs))))]\n             {:mice   (find \\M)\n              :cheese (find \\C)\n              :spaces (map :pos (filter #(not= \\# (:val %)) cs))}))\n\n        neighbours (fn [point] (map (fn [v] (map + point v)) [[-1 0] [0 1] [1 0] [0 -1]]))\n\n        region (fn [spaces start]\n           (loop [region  #{},\n                  actives [start]]\n             (let [[point & others] actives]\n               (cond\n                 (empty? actives)         region\n                 (contains? spaces point) (recur (conj region point)\n                                            (concat others (remove region (neighbours point))))\n                 :else                    (recur region others)))))\n\n         {spaces :spaces, m :mice, c :cheese} (maze matrix)]\n    (contains? (region (set spaces) m) c)))","problem":117,"user":"4eb9ce75535dfed6da9c6d5e"},{"problem":117,"code":"(fn [maze]\n  (letfn [(findinmap [m c]\n            (first \n              (filter (complement nil?) \n                (let [rowsize (count m)]\n                  (for [x (range rowsize)\n                        y (range (count (first m)))]\n                    (when (= c (get-in m [x y])) [x y]))))))\n           (validmoves [m [x y]]\n             (let [offset [[-1 0] [1 0] [0 -1] [0 1]]]\n               (reduce \n                 (fn [res [offx offy]] \n                   (let [newx (+ x offx)\n                         newy (+ y offy)]\n                     (if (or (< newx 0)\n                             (< newy 0)\n                             (>= newx (count m))\n                             (>= newy (count (first m)))\n                             (= \\# (get-in m [newx newy])))\n                       res\n                       (conj res [newx newy]))))\n                []\n                offset)))\n           (estdist [start end]\n             (let [[x y] start\n                   [xx yy] end]\n               (+ (Math/abs (- x xx))\n                  (Math/abs (- y yy)))))\n            (astarpath [m]\n              (let [cost-estimate (vec (for [x (range (count m))]\n                                    (vec (for [y (range (count (first m)))]\n                                      (estdist [x y] (findinmap m \\C))))))\n                    start (findinmap m \\M)\n                    goal  (findinmap m \\C)]\n              (loop [worklist {start {:fscore (estdist start goal) :gscore 0}}\n                     donelist #{}]\n                (when-let [[item {:keys [fscore gscore]}] (first (sort-by (comp :fscore last) (into [] worklist)))]\n                  (let [poppedlist (dissoc worklist item)]\n                    (if (= item goal) true\n                      (recur \n                        (reduce (fn [res nextmove]\n                          (let [nextgscore (inc gscore)\n                                nextfscore (+ nextgscore (get-in cost-estimate nextmove))]\n                            (if (or (and (contains? poppedlist nextmove)\n                                         (> nextgscore gscore))\n                                    (contains? donelist nextmove))\n                              res\n                              (assoc res nextmove {:gscore nextgscore :fscore nextfscore})))) \n                          poppedlist \n                          (validmoves m item))\n                        (conj donelist item))))))))]\n    (let [m (vec (for [row maze] (reduce #(conj % %2) [] row)))]\n      (boolean (astarpath m)))))","user":"53e9a15be4b036ad0777e4ae"},{"code":"(fn cheesable? [maze]\n  (let [grid (->>\n               maze\n               (map-indexed (fn [i row] (map-indexed (fn [j col] [[i j] col]) row)))\n               (apply concat)\n               (into {}))\n        rev-grid (clojure.set/map-invert grid)\n        m (rev-grid \\M)\n        c (rev-grid \\C)\n        usable? #(#{\\space \\C} (grid %))\n        offsets '([1 0] [0 1] [-1 0] [0 -1])\n        neighbors (fn [[x y]] (map (fn [[i j]] [(+ x i) (+ y j)]) offsets))\n        graph (into {} (map (fn [[loc val]] [loc (filter usable? (neighbors loc))]) grid))]\n    (loop [mq `(~m), mv #{m}]\n      (if (empty? mq) false\n        (let [m (first mq), mq (rest mq)]\n          (if (= m c) true\n            (let [mnext (remove mv (graph m))\n                  mq (concat mnext mq)\n                  mv (into mv mnext)]\n              (recur mq mv))))))))","problem":117,"user":"4f6160a7e4b0defedf855fbe"},{"code":"(fn [r m]\n    (not= nil (some #(re-seq #\"C@\" %)\n                    (flatten (take 50 (iterate r m))))))\n#(map (fn [s] (.replaceAll s \"(M|@) \" \"$1@\"))\n      (reverse (apply map str %)))","problem":117,"user":"4fa3c137e4b081705acca193"},{"code":"(fn [str-map]\n    (letfn [(find-xy [str-map item]\n\t\t     (let [arr (map #(.indexOf % (str item)) str-map)\n\t\t\t       x (apply max arr)\n\t\t\t       y (.indexOf arr x)]\n\t\t       [y x]))\n            (parse-map [str-map]\n              {:x-size (count (first str-map))\n               :y-size (count str-map)\n               :map (vec (map vec str-map))\n               :start (find-xy str-map \"C\")\n               :end (find-xy str-map \"M\")})\n\n            (find-neighbor [stack]\n              (let [stack (update-in stack [:map] #(assoc-in % (:start stack) \\#))\n                    [y x] (:start stack)\n                    up [(dec y) x]\n                    down [(inc y) x]\n                    left [y (dec x)]\n                    right [y (inc x)]]\n                (filter #(and (< -1 ((:start %) 0) (:y-size %))\n                              (< -1 ((:start %) 1) (:x-size %))\n                              (not= (get-in (:map %) (:start %)) \\#))\n                        (map #(assoc stack :start %) [up down left right]))))\n    \n            (walk* [stacks]\n              (if (empty? stacks)\n                false\n                (let [stack (first stacks)\n                      stacks (next stacks)]\n                  (if (= (:start stack) (:end stack))\n                    true\n                    (recur (into stacks (find-neighbor stack)))))))]\n      (walk* (list (parse-map str-map)))))","problem":117,"user":"52afbc69e4b0c58976d9acc0"},{"problem":117,"code":"(fn solvable-4clojure?\n  ([maze]\n   (let [find-M (fn find-M [maze i j]\n                  (cond (>= i (count maze)) nil\n                        (= \\M (get-in maze [i j])) [i j]\n                        (>= j (count (get maze i))) (find-M maze (inc i) 0)\n                        :else (find-M maze i (inc j))))]\n     (solvable-4clojure? maze (find-M maze 0 0) (new java.util.HashSet))))\n  ([maze pos visited]\n   (let [up (fn [[i j]] [(dec i) j])\n         down (fn [[i j]] [(inc i) j])\n         left (fn [[i j]] [i (dec j)])\n         right (fn [[i j]] [i (inc j)])\n         next-moves (map #(% pos) [up down left right])\n         value (get-in maze pos)\n         _ (.add visited pos)]\n     (cond (nil? value) false\n           (= \\# value) false\n           (= \\C value) true\n           :else (true? (some true?\n                              (for [next-pos next-moves\n                                    :when (not (.contains visited next-pos))]\n                                (solvable-4clojure? maze next-pos visited))))))))","user":"52e657e4e4b09f7907dd1472"},{"problem":117,"code":"(fn [b]\n  (letfn [(hmove [r] (clojure.string/replace r \n                                             #\"([C|\\s]*)M([C|\\s]*)\" \n                                             #(apply str (repeat (count (first %)) \\M))))\n          (vmove [a x] (apply str (map #(if (re-matches #\"M[ |C]\" (apply str %)) \\M (second %))\n                                       (partition-all 2 (interleave a x)))))\n          (down [l] (reverse (reduce (fn [a x] (if (empty? a)\n                                                 (cons (hmove x) a)\n                                                 (cons (hmove (vmove (first (down a)) (hmove x))) (down a)))) [] l)))]\n    (let [border (apply str (repeat (count (first b)) \\#))\n          everywhere (down (concat [border] b [border]))]\n      (not-any? #(re-matches #\".*C.*\" %) everywhere))))","user":"5e3a25d4e4b01d43a70e8dde"},{"problem":117,"code":"(fn for-science [coll]\n   (let [height (count coll)\n         width (count (first coll))\n         position-type (fn [[x y]]\n                         (nth (nth coll x) y))\n         neighbours-unedited (fn [[x y]]\n                               (for [dx [-1 0 1]\n                                     dy (if (= 0 dx)\n                                          [-1 1]\n                                          [0])]\n                                 [(+ x dx) (+ y dy)]))\n         neighbours (fn [[x y]]\n                        (set (remove #(<= width (last %))\n                                (remove #(<= height (first %))\n                                        (remove #(some neg? %) (neighbours-unedited [x y]))))))\n         non-barrier-neigh (fn [[x y]]\n                        (set (filter #(or (= \\space (position-type %))\n                                          (= \\C (position-type %)))\n                                     (neighbours [x y]))))\n         locate-M (first (remove nil? (for [i (range height)\n                      j (range width)]\n                  (if (= \\M (nth (nth coll i) j))\n                    [i j]))))]\n         ((fn move [current-pos total-previous-space-neighbours nbh]\n           (cond\n             (= current-pos #{}) false\n             (= nbh total-previous-space-neighbours) false\n             (some #(= \\C (position-type %)) nbh) true\n\n             (not (empty? nbh)) (move (clojure.set/difference (set (for [k nbh] k)) total-previous-space-neighbours)\n                                      (set (concat total-previous-space-neighbours nbh))\n                                      (set (mapcat #(non-barrier-neigh %) nbh)))                                         \n             :else false)) locate-M #{} (non-barrier-neigh locate-M))))","user":"58dcb8cde4b0a4d5acaab6a7"},{"problem":117,"code":"(fn t [maze]\n  (let [ntoxy (fn [co [n b]]\n                (list (list (quot n co) (rem n co)) b))\n        trans_maze (fn [maze]\n                     (let [co (count (first maze))]\n                       (apply hash-map (mapcat #(ntoxy co %) (keep-indexed #(list % %2)(into [] (apply str maze)))))))\n        tr_maze (trans_maze maze)\n        find_M (fn [tr_maze]\n                 (filter #(if (= (second %) \\M)  true false) tr_maze))\n        M  (first (find_M tr_maze))\n        find_C (fn [tr_maze]\n                 (filter #(if (= (second %) \\C)  true false) tr_maze))\n        C  (first (find_C tr_maze)) \n        make_4d (fn [[x y]]\n                  (list [(dec x) y][(inc x) y][x (dec y)][x (inc y)]))\n        find_nexts (fn [current tr_maze]\n                     (let [ds (make_4d current)\n                           as  #{\\space \\M \\C}]\n                       (filter #(as (second %)) (map #(list %(tr_maze %)) ds))))\n        f (fn f [current path tr_maze]\n            (let [next (set (find_nexts (first current) tr_maze))\n                  nexts (into [] (clojure.set/difference next path))]\n              (if (not (= '() (filter #(= (second %) \\C) nexts)))\n                true\n                (if (empty? nexts)\n                  false\n                  (let [n0 (nth nexts 0 nil)\n                        n1 (nth nexts 1 nil)\n                        n2 (nth nexts 2 nil)\n                        n3 (nth nexts 3 nil)]\n                    (or (when n0 (f n0 (conj path n0) tr_maze))\n                        (when n1 (f n1 (conj path n1) tr_maze))\n                        (when n2 (f n2 (conj path n2) tr_maze))\n                        (when n3 (f n3 (conj path n3) tr_maze))))))))]\n    (if (or (empty? (find_nexts (first C) tr_maze))(empty? (find_nexts (first M) tr_maze)))\n      false\n      (if (f M #{} tr_maze) true false))))","user":"566d71b1e4b0a866af6896ca"},{"problem":117,"code":"(fn [m]\n  (let\n    [get-at (fn [[r c]] (or (get-in m [r c]) \\#))\n     mouse-pos (first (for [r (range (count m)), c (range (count (first m))) :when (= \\M (get-at [r c]))] [r c]))\n     neighbours (fn [pos] (reduce (fn [acc v] (conj acc (map + pos v))) [] [[1 0] [0 1] [-1 0] [0 -1]]))\n     seen (atom #{})\n     search (fn search [pos]\n              (if (@seen pos)\n                false\n                (do\n                  (swap! seen #(conj % pos))\n                  (cond\n                    (= \\C (get-at pos)) true\n                    (= \\# (get-at pos)) false\n                    :else\n                      ((complement not-any?) true?\n                         (map search (neighbours pos)))))))]\n    (search mouse-pos)))","user":"58b51e05e4b0ebc645576d4c"},{"problem":117,"code":"(fn [ibrd]\n          (letfn [(csr [s f t] (clojure.string/replace s f t))\n                  (mrow [s] (-> s (csr \" M\" \"MM\") (csr \"M \" \"MM\")\n                                (csr \"CM\" \"++\") (csr \"MC\" \"++\")))\n                  (winbrd? [brd] (some #{\\+} (apply concat brd)))\n                  (invif [i] (if (= 1 (count i)) i\n                      (apply (partial map str) i)))\n                  (mstep [inp] (->> inp (map mrow) invif (map mrow)))\n                  (stuck? [brd] (= brd (invif (mstep brd))))]\n            (loop [brd ibrd]\n              (cond\n                (winbrd? brd) true\n                (stuck? brd) false\n                :else (recur (mstep brd))))))","user":"4e8768f6535dceadca469850"},{"problem":117,"code":"(fn find-path [mat]\n  (let [tr (count mat)\n        tc (count (first mat))\n        coors (set (for [i (range tr) j (range tc) :when (not= (get-in mat [i j]) \\#)] [i j]))\n        st (->> coors (filter #(= \\M (get-in mat %))) first)\n        en (->> coors (filter #(= \\C (get-in mat %))) first)\n        gen (fn [c] (map #(map + c %) [[0 1] [0 -1] [1 0] [-1 0]]))\n        bfs (fn bfs [young old]\n              (let [ny (->> young (mapcat gen) (filter #(contains? coors %)) (filter #(not (contains? old %))) set)]\n                (lazy-cat young (if (empty? young) #{} (bfs ny (clojure.set/union young old))))))]\n    (true? (some #(= en %) (bfs #{st} #{})))))","user":"5953bdb6e4b066ee0a44aeed"},{"code":"(fn [maze]\n  (let [nr (count maze)\n        nc (count (first maze))\n        start (first \n               (for [i (range nr) j (range nc) \n                     :when (= \\M (get-in maze [i j]))]\n                 [i j]))\n        expand (fn [[a b]]\n                 (for [i (range -1 2) j (range -1 2) \n                       :let [ni (+ i a) nj (+ j b)\n                             vl (get-in maze [ni nj] nil)]\n                       :when (and (= 0 (* i j))\n                              (or (= \\  vl) (= \\C vl)))]\n                   [ni nj]))\n        f (fn [s] \n            (set (map #(get-in maze %) s)))]\n    (loop [vst #{start}]\n      (if-let [new (seq (filter (complement vst) (mapcat expand vst)))]\n        (if ((f new) \\C)\n          true\n          (recur (into vst new)))\n        false))))","problem":117,"user":"51944aaae4b0142f60b4aedc"},{"problem":117,"code":"(fn [maze]\n  (letfn [\n          (mouse-coords [maze]\n            (first (for [[x row] (map-indexed vector maze)\n                         [y val] (map-indexed vector row)\n                         :when (= \\M val)]\n                     [x y])))\n          (neighbours\n            ([width height yx] (neighbours [[-1 0] [1 0] [0 -1] [0 1]]\n                                           width height\n                                           yx))\n            ([deltas width height yx]\n             (filter (fn [[new-y new-x]]\n                       (and (< -1 new-y height) (< -1 new-x width)))\n                     (map #(vec (map + yx %))\n                          deltas))))\n          (update-moves [maze visited to-visit]\n            (if\n              (empty? to-visit) false\n                                (let [visiting (first to-visit)\n                                      remaining (rest to-visit)\n                                      current (get-in maze visiting)\n                                      cn (neighbours (count (seq (maze 0))) (count maze) visiting)\n                                      nn (filter #(not (visited %)) cn)\n                                      ]\n                                  (cond\n                                    (= current \\C)  true\n                                    (= current \\#) (recur maze (conj visited visiting) remaining)\n                                    (or (= current \\M) (= current \\space)) (recur maze (conj visited visiting) (concat remaining nn)\n                                                                                  )\n                                    ))))\n          ]\n  (let [start (mouse-coords maze)]\n    (update-moves maze #{start} #{start})\n    )))","user":"55f2c898e4b06e875b46ce4b"},{"code":"(fn [maze]\n  (let [h (count maze)\n        w (count (first maze))\n        state (fn [[x y]]\n                (if (or (>= x w) (< x 0) (>= y h) (< y 0)) :out-of-range\n                  (let [s (nth (nth maze y) x)]\n                    (cond (= s \\C) :cheese\n                          (= s \\#) :taken\n                          :else :free))))\n        mstr (some #(if (some (fn [s] (= s \\M)) %) %) maze)\n        mx (.indexOf (seq mstr) \\M)\n        my (.indexOf maze mstr)]\n    ((fn rec [r u]\n       (if (empty? r) false\n         (if (some #(= (state %) :cheese) r) true\n           (let [new-u (clojure.set/union u r)\n                 t1-r (reduce #(let [[x y] %2]\n                                   (conj %1 [(inc x) y] [(dec x) y] [x (inc y)] [x (dec y)])) #{} r)\n                 t2-r (reduce #(if (contains? #{:cheese :free} (state %2)) (conj %1 %2) %1) #{} t1-r)\n                 new-r (clojure.set/difference t2-r new-u)]\n             (rec new-r new-u))))) #{[mx my]} #{})))","problem":117,"user":"505dcfc8e4b0e6aca564be0d"},{"code":"(fn [maze]\n  (let [m (count maze) n (count (first maze))\n        walkable? (fn [p] (#{\\M \\C \\space} (get-in maze p)))\n        pos (into {} (for [x (range m) y (range n)\n                           :let [t (get-in maze [x y])]\n                           :when (#{\\M \\C} t)] [t [x y]]))\n        neighbors (fn [p]\n                    (filter (fn [[x y]] (and (< -1 x m) (< -1 y n) (walkable? [x y])))\n                            (map #(map + p %) [[-1 0] [1 0] [0 -1] [0 1]])))]\n    ;; depth-first search for the cheese \\C\n    (loop [stack [(pos \\M)] seen #{}]\n      (if (seq stack)\n        (let [p (peek stack) ps (pop stack)]\n          (cond\n           (seen p) (recur ps seen)\n           (= (pos \\C) p) true\n           :else (recur (into ps (remove seen (neighbors p))) (conj seen p))))\n        false))))","problem":117,"user":"4ec5aa1f535d6d7199dd36b0"},{"code":"(fn can-eat [b]\n  (let [eval-next-board (fn [board]\n                          (let [\n                                pattern [[-1 0] [1 0] [0 -1] [0 1]]\n                                cell (fn [[x y]] (get (get board y) x))\n                                ngb (fn [[x y]]\n                                      (remove nil? (map\n                                                    (fn [[ox oy]] (cell\n                                                                   [(+ x ox)\n                                                                    (+ y oy)]))\n                                                    pattern)))\n                                ngb-alive (fn [p] (count (filter #{\\M} (ngb p))))\n                                next-state (fn [cellstatus ngbs]\n                                             (if (> ngbs 0)\n                                               (cond \n                                                (= cellstatus \\space) \\M\n                                                (= cellstatus \\C) \\E\n                                                :else cellstatus)\n                                               cellstatus))]\n                            (for [y (range (count board))]\n                              (apply str (for [x (range (count (first board)))]\n                                           (next-state (cell [x y]) (ngb-alive [x y]))\n                                           ))\n                                          )\n                            ))\n        next-board (eval-next-board (vec b))]\n    (if (= b next-board)\n      (not (nil? (some #{\\E} (seq (apply str b)))))\n      (can-eat next-board))))","problem":117,"user":"5034b0e1e4b062bc5d7ae167"},{"problem":117,"code":"(fn for-science [maze]\n  (let [rows (count maze)\n        cols (count (first maze))\n        neighbors (fn [[i j]] [[(dec i) j] [(inc i) j] [i (dec j)] [i (inc j)]])\n        maze-map (->> (for [i (range rows), j (range cols)] { (get-in maze [i j]) [i j]})\n                      (apply merge-with conj { \\space [], \\# [] }))\n        start (maze-map \\M)\n        end (maze-map \\C)\n        open (conj (set (maze-map \\space)) end)\n        valid-neighbors (fn [cell] (filter open (neighbors cell)))]\n    (loop [visited #{}\n           queue (list start)]\n      (let [cur (first queue)\n            next-moves (remove visited (valid-neighbors cur))\n            queue (concat (next queue) next-moves)]\n        (cond\n          (= end cur) true\n          (empty? queue) false\n          :else (recur (conj visited cur) queue))))))","user":"5879d577e4b01531a375ead8"},{"code":"(fn [g]\n  (let [c count\n        f #(for [x (range (c g)) y (range (c (first g))) :when (% (get-in g [x y]))] [x y])\n        [M C] (f #{\\M \\C})\n        G (f #{\\M \\C \\ })]\n    (loop [o #{M} n 0]\n      (cond (o C) true \n            (= (c o) n) false \n            1 (recur \n                (into o (for [[i j] o [x y] G :when (#{[-1 0] [1 0] [0 -1] [0 1]} [(- x i) (- y j)])] [x y])) \n                (c o))))))","problem":117,"user":"4f1d1d95535d64f603146488"},{"code":"(fn [rows]\n  (letfn[\n    (matrix[]\n      (let [indices (for [x (range (count rows)) y (range (count (first rows)))] [x y])\n            cells (flatten (for [r rows]\n                             (for [c r]\n                               (cond\n                                 (= c \\#) :wall\n                                 (= c \\M) :mouse\n                                 (= c \\C) :cheese\n                                 :else    :space))))]\n        (apply hash-map (interleave indices cells))))\n    \n    (neighbours[cell]\n        (let [[i j] cell\n              n (count rows)\n              m (count (first rows))]\n          (for [[x y] [[i (dec j)][i (inc j)][(dec i) j][(inc i) j]]\n                :when (and (>= x 0) (>= y 0) (< x n) (< y m))]\n            [x y])))\n    \n    (non-wall-neighbours[cell]\n      (let [nbs (neighbours cell)\n            mx (matrix)]\n        (filter (fn[c] (not= :wall (mx c))) nbs)))\n    \n    (immediate-neighbours[a-set]\n       (apply hash-set (distinct (concat a-set (mapcat non-wall-neighbours a-set)))))\n    \n    (transitive-closure[c]\n      (ffirst (take 1 (drop-while\n        (fn [[s1 s2]] (not= (count s1) (count s2)))\n          (iterate (fn[[ss _]] [(immediate-neighbours ss) ss]) [#{c} #{}])))))\n    \n    (domains[]\n      (loop [spaces (map (fn[[c kw]] c) (filter (fn[[k v]] (= :space v)) (matrix)))\n             acc []]\n        (if (empty? spaces)\n          acc\n          (let [tc (transitive-closure (first spaces))]\n            (recur (remove #(tc %) spaces) (conj acc tc))))))]\n    (let [dmns (domains)\n          m (matrix)\n          mouse (ffirst (filter (fn[[k v]] (= :mouse v)) m))\n          cheese (ffirst (filter (fn[[k v]] (= :cheese v)) m))]\n      (not (nil? (some (fn[a-set] (and (a-set mouse) (a-set cheese))) dmns))))))","problem":117,"user":"4e58bcd4535d8a8b8723a296"},{"code":"(fn [board] \n  (let [n  (fn [board i j] (get (vec (get board i)) j))\n        nb (fn [board i j] (concat (for [k [-1 1]] (n board (+ i k) j)) (for [k [-1 1]] (n board i (+ j k)))))\n        check (fn  [i j board] (let [p (n board i j)] (if (= p \\space) (if (some (partial = \\C) (nb board i j)) \\C p) p)))\n        mouse (fn [board] (vec (map #(let [row (vec (get board %))]  (vec(map (fn [j] (check % j board))  (range (count row)))))(range (count board)))))\n\t\tsolve (fn [board] (loop [i0 board i1(mouse board) ] (if (= i0 i1) i1 (recur i1 (mouse i1)))))\n\t\tfind-m (fn [board]  (first (for [i (range (count board)) j (range (count (get board i))) :when (= \\M (n board i j))] [i j])))\n        s (solve board) \n\t\tl (find-m board)]\n     (if (some (partial = \\C) (nb s (first l) (second l))) true false)))","problem":117,"user":"523a9fc9e4b081681ca7adca"},{"code":"(fn [m]\n    (let [F (fn F [f x] (let [y (f (f x))] (if (= x y) x (F f y))))\n          T (fn [m] (for [i (range (count (first m)))] (apply str (map #(nth % i) m))))\n          R #(.replaceAll % \"( M|M )\" \"MM\")\n          M (fn [m] (map #(F R %) (T m)))\n          E (F M m) ]\n      (reduce #(or % (boolean %2)) false\n              (map #(re-seq #\"MC|CM\" %) (flatten [E (T E)])))))","problem":117,"user":"4ff67852e4b0678c553fc37e"},{"code":"(fn [m]\n  (let [encontrou? (fn [mz]\n                     (let [p-c (first (for [l (range (count mz))\n                                            c (range (count (first mz)))\n                                            :when (= \\C (get-in mz [l c]))]\n                                        [l c]))]\n                       (some #(= \\M (get-in mz (map + p-c %))) [[-1 0][1 0][0 -1][0 1]])))\n        proximos-m (fn [mz]\n                     (for [l (range (count mz))\n                           c (range (count (first mz)))\n                           :when (= \\space (get-in mz [l c]))\n                           :when (some  #(= \\M (get-in mz (map + [l c] %))) [[-1 0][1 0][0 -1][0 1]])]\n                       [l c]))\n        procura (fn procura [mz]\n                  (let [p-m (proximos-m mz)]\n                    (cond\n                     (encontrou? mz) true\n                     (empty? p-m) false\n                     :else (procura (reduce #(assoc-in % %2 \\M)\n                                            mz\n                                            p-m)))))]\n    (procura (vec (map vec m)))))","problem":117,"user":"52c8758be4b0c2d177d62135"},{"code":"(let [find \n(fn  [t c] \n  (let [i (first (filter #(.contains (nth t %) c) (range 0 (count t))))]\n  [i (.indexOf (nth t i) c )]))]\n  \n  \n  (fn [t] \n    (let [w (count (first t)) h (count t) ds [[0 1] [1 0] [-1 0] [0 -1]] \n          m (find t \"M\") c (find t \"C\")]\n    (loop [visited #{m} prev #{}]\n      (cond (= visited prev) false\n        (visited c) true\n            :else\n        (let [nextV (set (concat visited (filter\n                                           (fn [[x y]] (and (>= x 0) (>= y 0) (< x h) (< y w)\n                                                            (not= (nth (nth t x) y) \\#)) )\n                                           (for [[di dj] ds [i j] visited] [(+ i di) (+ j dj)]))))]\n        (recur nextV visited)))\n    \n    ))))","problem":117,"user":"503917a0e4b088a6a14ca763"},{"code":"(fn [u]\n  (let [u (vec (map vec u))\n        g (fn [v]\n            (let [h (fn [x y] (get (get v y) x \\#))\n                  w (vec (for [y (range (count v))] \n                      (vec (for [x (range (count (v 0)))]\n                      (cond \n                        (#{\\# \\M} (h x y)) (h x y)\n                        :else (if ((sorted-set\n                                    (h x (dec y))\n                                    (h x (inc y))\n                                    (h (dec x) y)\n                                    (h (inc x) y)) \\M) \\M (h x y)))))))]\n              (if (= v w) (every? (fn [l] (every? #(not= % \\C) l)) w)\n                (recur w))))]\n    (g u)))","problem":117,"user":"50fbdacfe4b0d10d794c19f0"},{"code":"(fn [m]\n  (let [get     #(nth (nth %3 %1 nil) %2 \\#)\n        rg      #(list [(inc %1) %2] [(dec %1) %2] [%1 (inc %2)] [%1 (dec %2)])\n        sets    #(apply str (concat (take %1 %2) [%3] (drop (inc %1) %2)))\n        setm    #(concat (take %1 %3) [(sets %2 (nth %3 %1) %4)] (drop (inc %1) %3))\n        neigh   #(for [[x y] (rg %1 %2)\n                       :when (not= \\# (get x y %3))]\n                   [x y (get x y %3)])\n        mapm    (fn mapm [[x y e] m]\n                  (cond\n                    (= e \\C)     [true nil]\n                    (= e \\space) (let [m  (setm x y m \\#)\n                                       nn (neigh x y m)]\n                                   (loop [[r m] [false m] n (first nn) nn (next nn)]\n                                     (if r\n                                       [true nil]\n                                       (if n\n                                         (recur (mapm n m) (first nn) (next nn))\n                                         [false m]))))))\n        [mx my] (first (for [x (range (count m)) y (range (count (first m)))\n                             :let [e (get x y m)] :when (= e \\M)]\n                         [x y]))]\n    (first (mapm [mx my \\space] m))))","problem":117,"user":"4f32a7f1e4b0d6649770a095"},{"problem":117,"code":"(fn finishable? [field]\n  (letfn [\n          (transpose [field]\n            (->>\n             (apply map vector field)\n             (map #(apply str %))))\n\n          (fill [field]\n            (map (fn [s]\n                   (clojure.string/replace s #\" *M *\" #(apply str (repeat (count %) \"M\"))))\n                 field))\n\n          (fill-all [field]\n            (let [t2 (comp fill transpose fill transpose)\n                  new-field (t2 field)]\n              (if (= new-field field)\n                field\n                (recur new-field))))\n\n          (finished? [field]\n            (let [tfield (transpose field)]\n              (if (or (some #(re-find #\"MC\" %) field)\n                      (some #(re-find #\"CM\" %) field)\n                      (some #(re-find #\"MC\" %) tfield)\n                      (some #(re-find #\"CM\" %) tfield))\n                true\n                false)))\n          ]\n\n    (finished? (fill-all field))))","user":"4ddb696b535d02782fcbe9fa"},{"problem":117,"code":"(fn f [m]\n  (let [g #(get-in m [% %2])\n        p #(#{\\* \\M} (g % %2))\n        r #(range (count %))\n        n (vec\n      (for [y (r m)] (vec\n        (for [x (r (get m 0))]\n          (if\n            (and (not= (g y x) \\#)\n              (or\n                (p (- y 1) x) (p (+ y 1) x)\n                (p y (- x 1)) (p y (+ x 1))))\n            \\*\n            (g y x))))))]\n    (and (not (= n m))\n      (or (not (re-find #\"C\" (str n)))\n        (f n)))))","user":"53500869e4b084c2834f4ad3"},{"problem":117,"code":"(fn can-reach [grid]\n  (let [coord (fn [[x y]] (nth (nth grid y) x))\n        h (count grid)\n        w (count (first grid))\n        start-pos ((comp drop-last first)\n                   (filter (fn [[_ _ v]] (= \\M v))\n                          (for [x (range w) y (range h)]\n                            [x y (coord [x y])])))\n        m+ (partial map +)\n        valid? (fn [[x y]] (and (>= x 0) (>= y 0) (< x w) (< y h)))\n        is-wall? (fn [c] (= (coord c) \\#))\n        dirs [[0 1] [0 -1] [1 0] [-1 0]]\n        next-pos (fn [c] (filter #(and (valid? %) (not (is-wall? %)))\n                                 (map (partial m+ c) dirs)))]\n    (loop\n        [visited #{}\n         [cur-pos & to-visit] [start-pos]]\n      (if (nil? cur-pos)\n        false\n        (if (= (coord cur-pos) \\C)\n          true\n          (let [visited' (conj visited cur-pos)\n                to-visit' (remove visited'\n                                  (concat to-visit (next-pos cur-pos)))]\n                (recur visited' to-visit')))))))","user":"54be7772e4b0ed20f4ff6eea"},{"code":"(fn brutal-force [strings]\n  (let [free (set (filter (complement nil?) (mapcat identity (map-indexed #(map-indexed (fn [a b] (if (case b \\space true \\M true \\C true false) [%1 a])) %2) strings))))\n        CM (set (filter (complement nil?) (mapcat identity (map-indexed #(map-indexed (fn [a b] (if (case b \\M true \\C true false) [%1 a])) %2) strings))))    \n        get-neighbours (fn [[a b]] (clojure.set/intersection free (set [[(inc a) b] [(dec a) b] [a (inc b)] [a (dec b)]])))\n        bfs (fn bfs \n              ([start goal]\n               (bfs #{start} #{} goal))\n              ([fringe visited goal]\n               (if (empty? fringe) \n                 false \n                 (if (contains? fringe goal) \n                   true\n                   (bfs (clojure.set/difference (apply clojure.set/union (map get-neighbours fringe)) visited) (clojure.set/union fringe visited) goal)))))]\n    (bfs (first CM) (second CM))))","problem":117,"user":"50c8697ce4b00bb60fe0c53f"},{"problem":117,"code":"(fn dfs\n  ([A]\n   (let [indx-a (map-indexed vector A)\n         row (filter #(some #{\\M} (second %)) indx-a)\n         y (.indexOf (second (first row)) \"M\")\n         x (first (first row))]\n     (first (dfs A x y))))\n  ([A x y]\n   (let [set-at (fn [A x y s]\n                  (let [xs (nth A x)]\n                    (concat (take x A)\n                            (list (str (subs xs 0 y) (str s) (subs xs (+ 1 y))))\n                            (drop (+ 1 x) A))))\n\n         get-at (fn [A x y] (nth (nth A x) y))\n\n         neibors (fn [A x y]\n                  (let [dx [-1 1 0 0]\n                        dy [0 0 -1 1]\n                        is-good? (fn [[x y]] (and\n                                              (>= x 0)\n                                              (>= y 0)\n                                              (< x (count A))\n                                              (< y (count (first A)))\n                                              (contains? #{\\space \\C} (get-at A x y))))]\n                    (filter is-good? (map #(list (+ x %1) (+ y %2)) dx dy))))\n\n         A (set-at A x y \\M)\n         neibs (neibors A x y)\n         neib-vals (map #(apply (partial get-at A) %) neibs)\n         has-c? (some #{\\C} neib-vals)]\n     (if (= 0 (count neibs)) (list false A)\n         (if has-c? (list true A)\n             (reduce\n              (fn [[res A] [x y]]\n                (if res (list res A)\n                    (dfs A x y)))\n              (list false A)\n              neibs))))))","user":"58fc92c5e4b0438e51c2cf9a"},{"problem":117,"code":"(fn [maze]\n  (let [\n        h (count maze)\n        w (count (first maze))\n        mouse-pos (let [fp (.indexOf (apply str maze) \"M\")]\n                    [(quot fp w) (rem fp w)])\n        cheese-pos (let [fp (.indexOf (apply str maze) \"C\")]\n                     [(quot fp w) (rem fp w)])\n\n        valid-pos? (fn [r c]\n                     (and (<= 0 c)\n                          (<= 0 r)\n                          (< r h)\n                          (< c w)\n                          (not= \\# (get-in maze [r c])))\n                     )\n        next-move (fn [r c]\n                    (filter #(apply valid-pos? %) #{[r (dec c)] [r (inc c)] [(dec r) c] [(inc r) c]})\n                    )\n\n        explore (fn [explored not-explored]\n                  (loop [exp explored nexp not-explored]\n                    (if (empty? nexp) exp\n                                     (let [pos (first nexp)\n                                           nex (rest nexp)\n                                           ex (conj exp pos)]\n                                       (recur ex (concat nex (filter #(not (contains? ex %)) (apply next-move pos)))))\n                                     )))\n        ]\n    (contains? (explore #{} #{mouse-pos}) cheese-pos)\n    ))","user":"52593207e4b0cb4875a45cd3"},{"problem":117,"code":"(fn\n  [board]\n  (let [grab-from-board (fn\n          [board [x y]]\n          (get (get board y) x))\n        find-in-maze (fn\n          [part board]\n          (let [maze-height (count board)\n                maze-width (count (first board))]\n            (remove nil? (for [y (range 0 maze-height)\n                               x (range 0 maze-width)]\n                           (when (= (grab-from-board board [x y]) part)\n                             [x y])))))\n        get-mouse (fn\n          [board]\n          (flatten (find-in-maze \\M board)))\n        get-cheese (fn\n          [board]\n          (flatten (find-in-maze \\C board)))\n        get-possible-moves (fn\n          [board visited [pos-x pos-y]]\n          (merge\n            (when (and (not (visited [pos-x (dec pos-y)])) (#{\\space \\C} (grab-from-board board [pos-x (dec pos-y)])))\n              {:n [pos-x (dec pos-y)]})\n            (when (and (not (visited [pos-x (inc pos-y)])) (#{\\space \\C} (grab-from-board board [pos-x (inc pos-y)])))\n              {:s [pos-x (inc pos-y)]})\n            (when (and (not (visited [(inc pos-x) pos-y])) (#{\\space \\C} (grab-from-board board [(inc pos-x) pos-y])))\n              {:e [(inc pos-x) pos-y]})\n            (when (and (not (visited [(dec pos-x) pos-y])) (#{\\space \\C} (grab-from-board board [(dec pos-x) pos-y])))\n              {:w [(dec pos-x) pos-y]})))\n        next-step (fn\n          [board visited [[pos-x pos-y] last-direction]]\n          (let [possible-moves (get-possible-moves board visited [pos-x pos-y])]\n            (if (= (count possible-moves) 1)\n              [(flatten (vals possible-moves)) (first (keys possible-moves))]\n              (if (last-direction possible-moves)\n                [(last-direction possible-moves) last-direction]\n                (cond\n                  (:n possible-moves) [(:n possible-moves) :n]\n                  (:w possible-moves) [(:w possible-moves) :w]\n                  (:s possible-moves) [(:s possible-moves) :s]\n                  (:e possible-moves) [(:e possible-moves) :e])))))\n        cheese-xy (get-cheese board)\n        mouse-pos (get-mouse board)]\n    (loop [[pos-xy last-direction] [mouse-pos :na]\n           visited #{}]\n      (if (= pos-xy cheese-xy)\n        true\n        (if (nil? (get-possible-moves board visited pos-xy))\n          false\n          (recur (next-step board visited [pos-xy last-direction]) (conj visited pos-xy)))))))","user":"559fb147e4b0acc240e314ea"},{"problem":117,"code":"(fn [maze]\n  (let [visd (atom (hash-set))\n        mark-visd (fn [r c]\n                    (let [ori (@visd [r c])]\n                      (swap! visd conj [r c])\n                      (println [r c] ori)\n                      ori))\n        dfs (fn dfs [r c]\n              (cond (mark-visd r c) false\n                    (= \\C (get-in maze [r c])) true\n                    (#{\\# \\X} (get-in maze [r c] \\X)) false\n                    :else (or (dfs (inc r) c)\n                              (dfs (dec r) c)\n                              (dfs r (inc c))\n                              (dfs r (dec c)))))\n        [sx sy] (first (for [r (range (count maze))\n                             c (range (count (maze 0)))\n                             :when (= \\M (get-in maze [r c]))]\n                         [r c]))]\n    (dfs sx sy)))","user":"5479c58de4b0c51c1f4d72c7"},{"problem":117,"code":"(fn [m]\n  (let [mv (mapv vec m)\n        w  (count (first mv))\n        h  (count mv)\n\n        [w? m c]\n        (reduce \n          (fn [[w? m c] ji]\n            (case (get-in mv ji)\n              \\M [w? ji c]\n              \\C [w? m ji]\n              \\# [(conj w? ji) m c]\n              [w? m c])) \n          [#{} nil nil]\n          (for [j (range h)\n                i (range w)]\n            [j i]))\n\n        n\n        (fn [old? [j i]]\n          (filter \n            (fn [[j i :as ji]]\n              (and (< -1 j h)\n                   (< -1 i w)\n                   (not (w?   ji))\n                   (not (old? ji))))\n            [[(inc j) i] [(dec j) i]\n             [j (inc i)] [j (dec i)]]))\n        \n        x #(set (mapcat (partial n %) %2))\n\n        U clojure.set/union\n        I clojure.set/intersection]\n    (loop [old-m #{} new-m #{m}\n           old-c #{} new-c #{c}]\n      (let [old-m* (U old-m new-m)\n            old-c* (U old-c new-c)]\n        (cond\n          (seq (I old-m* old-c*))\n          true\n\n          (or (empty? new-m) \n              (empty? new-c)) \n          false\n\n          :else\n          (recur\n            old-m* (x old-m* new-m)\n            old-c* (x old-c* new-c)))))))","user":"53dfdf01e4b0d874e779ae46"},{"problem":117,"code":"(fn [maze]\n    (let [read-maze get-in\n          find-in-maze (fn [maze, ch]\n                         (let [[max-row max-column :as max-pos] [(dec (count maze)) (dec (count (first maze)))]]\n                           (loop [[row column :as pos] [0 0]]\n                             (cond (= ch (read-maze maze pos)) pos\n                                   (= pos max-pos) nil\n                                   (= column max-column) (recur [(inc row) 0])\n                                   :else (recur [row (inc column)])))))\n          write-wall (fn [maze pos] (update-in maze pos (fn [_] \\#)))\n          maze (mapv vec maze)\n          [max-row max-column :as max-pos] [(dec (count maze)) (dec (count (first maze)))]\n          cheese (find-in-maze maze \\C)\n          i-can-haz-cheese? (fn i-can-haz-cheese? [[row column :as mouse]\n                                                   maze]\n                              (and (<= 0 row max-row)\n                                   (<= 0 column max-column)\n                                   (not= \\# (read-maze maze mouse))\n                                   (let [maze (write-wall maze mouse)]\n                                     (or (= mouse cheese)\n                                         (i-can-haz-cheese? [(inc row) column] maze)\n                                         (i-can-haz-cheese? [(dec row) column] maze)\n                                         (i-can-haz-cheese? [row (inc column)] maze)\n                                         (recur [row (dec column)] maze)))))]\n      (i-can-haz-cheese? (find-in-maze maze \\M) maze)))","user":"51b91b08e4b0e871ca4958f8"},{"code":"(fn [board]\n  (let [cells (mapcat\n                (fn [i coll]\n                  (map-indexed #(do [i % %2]) coll)) (range) board)\n        choose (fn [ch] (for [[x y z] cells :when (= z ch)] [x y]))\n        ;wall-set (set (choose \\#))\n        start (-> \\M choose first)\n        end (-> \\C choose first)\n        safe-set (set (concat [start end] (choose \\space)))\n        neighbor (->> (for [[x y :as p] safe-set] [[p [(inc x) y]]\n                                                   [p [x (inc y)]]])\n                      (apply concat)\n                      (filter (fn [[_ p]] (safe-set p)))\n                      (mapcat (fn [[p1 p2]] [{p1 [p2]} {p2 [p1]}]))\n                      (apply merge-with concat))\n        expand (fn [active-set]\n                 (let [next-set (into active-set\n                                      (mapcat neighbor active-set))]\n                   (if (= (count next-set) (count active-set))\n                     nil\n                     next-set)))\n        ]\n    (not-every? #(not (contains? % end))\n                (take-while (complement nil?) (iterate expand #{start})))))","problem":117,"user":"519b2570e4b0ac1b7dced6a3"},{"problem":117,"code":"(fn [maze]\n  (let [mazeb (vec (map #(vec (map {\\space 0, \\# 1, \\M 2, \\C 3} (seq %))) maze))\n        nrows (count mazeb)\n        ncols (count (first mazeb))\n        dirs  [[0 -1] [0 1] [1 0] [-1 0]]\n        ]\n    (letfn [(getloc [maze r c] (if (or (< r 0) (< c 0) (>= r nrows) (>= c ncols)) 1 (nth (nth maze r) c)))\n            (setloc [maze r c mark] (assoc maze r (assoc (nth maze r) c mark)))\n            (mnear [maze r c] (reduce #(or %1 %2) (map (fn [[dr dc]] (= 2 (getloc maze (+ r dr) (+ c dc)))) dirs)))\n            (prow [maze r] \n              (let [mnears    (map #(if (mnear maze r %) 1 0) (range ncols))\n                    row       (nth maze r)\n                    cheespace (map #(case % (0 3) 1 0) row)\n                    cheese    (map #(case % 3 1 0) row)\n                    gotcheese (not= 0 (reduce + (map * mnears cheese)))\n                    changes   (map * mnears cheespace)\n                    nchanged  (reduce + changes)\n                    changed   (map #(if (= 1 %1) 2 %2) changes row)]\n                (if gotcheese [-1 changed] [nchanged changed])))\n            (pmaze [maze] \n              (let [res (map #(prow maze %) (range nrows))\n                    flags (map first res)\n                    gotcheese (not= 0 (reduce + (map #(case % -1 1 0) flags)))\n                    nchanged (reduce + flags)\n                    nmaze (map second res)]\n                (if gotcheese [-1 nmaze] [nchanged nmaze])))]\n      (loop [maze mazeb]\n        (let [res (pmaze maze)\n              flag (first res)\n              nmaze (second res)]\n          (do (doseq [x maze] (println x))  (println)\n          (case flag -1 true 0 false (recur nmaze)))))\n      )))","user":"52faec2ee4b047fd55837004"},{"code":"(let [input->maze (comp vec (partial map vec))\n      search (fn [c]\n               (fn [maze]\n                 (for [y (range (count maze)) x (range (count (first maze)))\n                       :when (= c (get-in maze [y x]))]\n                   [y x])))\n      mice (search \\M)\n      cheese (comp first (search \\C))\n      neighbors (fn [[y x]]\n                  [[(dec y) x] [(inc y) x] [y (dec x)] [y (inc x)]])\n      prevention (partial apply (partial reduce #(assoc-in % %2 \\#)))\n      propagation (fn [maze]\n                    (->> (mice maze)\n                         (mapcat neighbors)\n                         (filter #(#{\\C \\space} (get-in maze %)))\n                         (reduce #(assoc-in % %2 \\M) maze)))\n      step (comp prevention (juxt propagation mice))]\n  (comp nil?\n        cheese\n        first\n        (partial drop-while (comp seq mice))\n        (partial iterate step)\n        input->maze))","problem":117,"user":"4f3fb586e4b0e243712b1f9c"},{"code":"(fn [x] (letfn [\n    (adjlist [x] (let [\n        h (count x)\n        w (count (first x))\n        getlabel (fn [x1 x2] (case (get (get x x1) x2) \n            \\C     :C\n            \\M     :M\n            \\#     nil\n            nil    nil\n            \\space [x1 x2]\n            ))]\n        (into {} (for [hi (range h) wi (range w) v [(getlabel hi wi)] :when v]\n            [v (keep identity [\n                (getlabel (inc hi) wi)\n                (getlabel (dec hi) wi)\n                (getlabel hi (inc wi))\n                (getlabel hi (dec wi))])]))))\n    (can-reach? [g v1 v2] (letfn [\n        (add-vertex [s v] (if (s v) s \n            (reduce add-vertex (conj s v) (g v))))]\n        (contains? (add-vertex #{} v1) v2)))]\n    (can-reach? (adjlist x) :C :M)))","problem":117,"user":"51cbdee1e4b08d8387cbede1"},{"code":"(fn [maze]\n  (let [mz (vec (map vec maze))\n        cords (for [i (range (count mz)) j (range (count (mz i)))] [i j])\n        find (fn [c] (first (filter #(= c (get-in mz %)) cords)))\n        mouse (find \\M) cheese (find \\C)\n        adj (fn [[i j]]\n              (for [[k l] [[i (dec j)] [i (inc j)] [(dec i) j] [(inc i) j]]\n                    :when (and (< -1 k (count mz)) (< -1 l (count (mz k))) (not= \\# ((mz k) l)))]\n                [k l]))]\n    (loop [stack (list mouse) visited #{}]\n      (if (empty? stack)\n        false\n        (let [pos (peek stack)]\n          (cond (= pos cheese) true\n                (visited pos) (recur (pop stack) visited)\n                :else (recur (into (pop stack) (adj pos))\n                             (conj visited pos))))))))","problem":117,"user":"4fe84c74e4b07c9f6fd12c3c"},{"problem":117,"code":"(fn [maze]\n  (letfn [(movements-from-point [[x y]]\n            #{[(dec x) y]\n              [(inc x) y]\n              [x (dec y)]\n              [x (inc y)]})\n          (out-of-bounds? [[x y]]\n            (let [rows (count maze)\n                  cols (if (zero? rows) 0 (count (first maze)))]\n              (or\n               (< x 0)\n               (< y 0)\n               (>= x rows)\n               (>= y cols))))\n          (free-to-walk [point]\n            (not= \\# (get-in maze point)))\n          (next-frontier [current-frontier visited]\n            (let [potential-movements (mapcat movements-from-point current-frontier)\n                  walkable-movements (filter #(and (not (out-of-bounds? %))\n                                                   (free-to-walk %))\n                                             potential-movements)]\n              (clojure.set/difference (set walkable-movements) visited)))\n          (starting-position []\n            (first\n             (for [[ridx row] (map-indexed vector maze)\n                   [cidx tile] (map-indexed vector row)\n                   :when (= tile \\M)]\n               [ridx cidx])))\n          (goal-in-frontier? [frontier]\n            (some #(= \\C %) (map #(get-in maze %) frontier)))\n          (try-to-solve [frontier visited]\n            (cond\n              (empty? frontier) false\n              (goal-in-frontier? frontier) true\n              :else\n              (let [new-frontier (next-frontier frontier visited)\n                    new-visited (clojure.set/union visited frontier)]\n                (try-to-solve new-frontier new-visited))))]\n\n    (try-to-solve #{(starting-position)} #{})))","user":"5344fe13e4b084c2834f4a32"},{"problem":117,"code":"(fn search [rows]\n  (let [initial-positions (into {} (for [x (range (count (get rows 0))) y (range (count rows))]\n                                     [{:x x, :y y} (get-in rows [y x])]))\n        is-mouse? (fn [[_ tile]] (= tile \\M))\n        diff? (fn [a b diff] (= (Math/abs (- a b)) diff))\n        is-neighbour? (fn [[{:keys [x y]}] {mouse-x :x mouse-y :y}]\n                        (or (and (diff? x mouse-x 1) (= y mouse-y))\n                            (and (diff? y mouse-y 1) (= x mouse-x))))\n        expand-mouse (fn [maze [pos _]] (update-in maze [pos] #(if (= % \\#) \\# \\M)))\n        expand-mice (fn [maze neighbours] (reduce expand-mouse maze neighbours))\n        solve (fn [maze]\n                (let [[mouse _] (->> maze (filter is-mouse?) (first))]\n                  (if (not mouse)\n                    false ;; All mouse have died, no way to Cheese\n                    (let [neighbours (filter #(is-neighbour? % mouse) maze)]\n                      (if (some (fn [[_ tile]] (= \\C tile)) neighbours)\n                        true ;; Cheese found!\n                        (recur (-> maze (expand-mice neighbours)\n                                   (update-in [mouse] (constantly \\#)))))))))]\n    (solve initial-positions)))","user":"5f648ef1e4b02876ed9fd01b"},{"code":"(fn [b]\n  (letfn [(part [x] (map (partial partition-by #(= \\# %)) x))\n          (transp [x] (apply map list x))\n          (flat [x] (map (partial apply concat) x))\n          (fill [r] (if (some #{\\M} r) (repeat (count r) \\M) r))\n          (h-step [x] (flat (map #(map fill %) (part x))))\n          (v-step [x] (transp (h-step (transp x))))\n          (win? [x] (not-any? #(some #{\\C} %) x))\n          (solve [x] (let [nx (v-step (h-step x))]\n                         (cond (win? nx) true\n                               (= x nx) false\n                               :else (recur nx))))]\n    (solve b)))","problem":117,"user":"5246e945e4b0644eb7b0783b"},{"code":"#(if (= 1 (count %)) (not (.contains (first %) \"#\")) (= 1 (mod (count %) 2)))","problem":117,"user":"4db92654535d1e037afb21a0"},{"problem":117,"code":"(fn [b]\n   (let [bm (into {} (for [r (range (count b))\n                           c (range (count (get b r)))]\n                       (let [val (get-in b [r c])]\n                         [[r c] {:val val\n                                 :explored (= val \\#)}])))\n         mouse (some (fn [[k v]] (when (= (:val v) \\M) k)) bm)]\n     (letfn [(explored [bm pos] (get-in bm [pos :explored]))\n             (set-explored [bm pos] (assoc-in bm [pos :explored] true))\n             (set-cheese [bm pos] (assoc-in bm [pos :cheese] true))\n             (is-valid [bm pos] (not (nil? (get-in bm [pos :val]))))\n             (is-wall [bm pos] (= (get-in bm [pos :val]) \\#))\n             (get-neighbors [[r c]]\n               [[(dec r) c], [r (dec c)], [(inc r) c], [r (inc c)]])\n             (dfs [bm pos]\n               (let [bm (set-explored bm pos)\n                     neighbors (->> pos\n                                    get-neighbors\n                                    (filter (partial is-valid bm))\n                                    (remove (partial explored bm))\n                                    (remove (partial is-wall bm)))]\n                 (loop [bm bm, [p & ps] neighbors]\n                   (cond\n                    (not p) bm\n                    (= (get-in bm [p :val]) \\C) (set-cheese bm p)\n                    (or (explored bm p)\n                        (= (get-in bm [p :val]) \\#)) (recur bm ps)\n                        :else (recur (dfs bm p) ps)))))]\n       (true? (some (fn [[_ {cheese :cheese}]] cheese)\n                    (dfs bm mouse))))))","user":"4ee26f01535d10e5ff6f5368"},{"problem":117,"code":"(fn cheese [maze]\n    (let [height (count maze)\n          width (count (first maze))\n          steps [[0 1] [0 -1] [1 0] [-1 0]]\n          \n          mouse-position (first (filter #(>= (second %) 0) (map-indexed (fn [i s] [i (.indexOf s \"M\")])  maze)))\n          \n          next-positions (fn [y x explored] (filter \n                                      (fn [[y x]]\n                                        (and\n                                          (>= y 0) (< y height)\n                                          (>= x 0) (< x width)\n                                          (not= \\# (get-in maze [y x]))\n                                          (nil? (explored [y x]))))\n                                       (map (fn [[step-y step-x]]\n                                             [(+ y step-y) (+ x step-x)]) steps)))]  \n          (loop [frontier [mouse-position] explored #{}]\n              ;(println frontier) (print explored)\n              (if (empty? frontier) false\n                  (let [[y x] (peek frontier)]\n                       (if (= \\C (get-in maze [y x])) true\n                           (recur  \n                               (let [next-pos (next-positions y x explored)] \n                                  (if (empty? next-pos) (pop frontier) (apply conj (pop frontier) next-pos))) \n                               (conj explored [y x]))))))))","user":"559b55d6e4b066d22e731f54"},{"code":"(fn maze-solveable? [m]                                                                                          \n  (let [m (vec (map vec m))                                                                                        \n        rows (count m)                                                                                             \n        cols (count (first m))                                                                                     \n        all-coors (for [x (range cols) y (range rows)] (vector x y))                                               \n        m-pos (loop [remaining all-coors]                                                                          \n                (let [[x y] (first remaining)                                                                      \n                      v (get-in m [y x])]                                                                          \n                  (if (= \\M v)                                                                                     \n                    [x y]                                                                                          \n                    (recur (rest remaining)))))]                                                                   \n    (loop [discovered #{m-pos}                                                                                     \n           edges #{m-pos}]                                                                                         \n      (let [possible-moves (filter identity (for [[x y] edges [dx dy] [[0 -1] [-1 0] [1 0] [0 1]]]                 \n                             (let [x2 (+ x dx)                                                                     \n                                   y2 (+ y dy)                                                                     \n                                   on-board? (and (>= x2 0) (< x2 cols) (>= y2 0) (< y2 rows))                     \n                                   not-discovered? (not (contains? discovered [x2 y2]))]                           \n                               (if (and on-board? not-discovered? (not (= (get-in m [y2 x2]) \\#)))                 \n                                 (vector x2 y2)                                                                    \n                                 nil))))                                                                           \n            deduped-moves (set possible-moves)                                                                     \n            deduped-vals (set (for [[x y] deduped-moves] (get-in m [y x])))]                                       \n        (cond                                                                                                      \n          (contains? deduped-vals \\C) true                                                                         \n          (empty? deduped-moves) false                                                                             \n          :else (recur (clojure.set/union discovered deduped-moves) deduped-moves))))))","problem":117,"user":"51899891e4b0288ada3dbdab"},{"code":"(fn [maze]\n  (let [maze-rows (count maze)\n        maze-columns (count (first maze))\n\n        maze-contents\n        (fn [pos] (get-in maze pos))\n\n        all-pos\n        (for [r (range maze-rows) c (range maze-columns)] [r c])\n\n        find-in-maze\n        (fn [goal]\n          (filter #(= goal (maze-contents %)) all-pos))\n        \n        is-movable-content\n        (fn [content]\n          (#{\\M \\C \\space} content))\n\n        is-movable-position\n        (fn [pos]\n          (is-movable-content (maze-contents pos)))\n\n        next-moves\n        (fn [[r c]]\n          (let [potential-moves [[(dec r) c] [(inc r) c] [r (dec c)] [r (inc c)]]]\n            (filter is-movable-position potential-moves)))\n\n        breadth-first-search\n        (fn [start end expand-fn]\n          (loop [visited #{} to-visit [start]]\n            (cond\n             (contains? visited end)\n             true\n                                  \n             (empty? to-visit)\n             false\n         \n             :else\n             (let [current-visit (first to-visit)\n                   frontier (set (expand-fn current-visit))\n                   new-places (clojure.set/difference frontier visited)]\n               (recur (conj visited current-visit) (into (rest to-visit) new-places))))))\n        \n        mouse-position (first (find-in-maze \\M))\n        cheese-position (first (find-in-maze \\C))] \n    \n    (breadth-first-search mouse-position\n                          cheese-position\n                          next-moves)))","problem":117,"user":"4f0d093b535d0136e6c22313"},{"code":"(fn [M]\n    (let [my (.indexOf (map #(when (not= -1 (.indexOf % (int \\M))) 1) M) 1)\n          mx (.indexOf (nth M my) (int \\M))]\n      ((fn [[[y x] & r] u]\n         (if (= y nil)\n             false\n             (if (= (get-in M [y x]) \\C)\n               true\n               (recur \n                 (concat r \n                         (keep \n                           identity\n                           (map\n                             (fn [[y x] [dy dx]]\n                               (when (and \n                                       (not= (get-in M [(+ y dy) (+ x dx)] \\#) \\#) \n                                       ((complement u) [(+ y dy) (+ x dx)]))\n                                 [(+ y dy) (+ x dx)])) (repeat [y x]) [[0 1] [1 0] [0 -1] [-1 0]]))) \n                 (conj u [y x])))))\n         [[my mx]] #{})))","problem":117,"user":"5061cc17e4b0a30dc9a35d34"},{"problem":117,"code":"(fn [maze]\n  (letfn [(get-pos [maze [r c]] (let [v (get (get maze r) c)] (when-not (= v \\#) v)))\n          (moves [maze pos] (for [dir [[-1 0] [1 0] [0 -1] [0 1]] :let [pos (mapv + pos dir)] :when (#{\\space \\C} (get-pos maze pos))] pos))\n          (find-char [maze c] (for [row (keep-indexed #(when (some #{c} %2) %) maze)\n                                    col (keep-indexed #(when (= %2 c) %) (maze row))] [row col]))\n          (set-char [maze [row col] c] (update-in maze [row] #(str (doto (StringBuilder. %) (.setCharAt col c)))))\n          (expand [maze] (let [new-pos (for [pos (find-char maze \\M) move (moves maze pos)] move)]\n                               (reduce #(set-char % %2 \\M) maze new-pos)))]\n    (empty? (find-char (second (last (take-while #(apply not= %) (partition 2 1 (iterate expand maze))))) \\C))))","user":"514d8084e4b019235f6c0588"},{"code":"(fn solvable? [ascii-maze]\n  (letfn [\n    (parse-maze [maze]\n      (into {}\n        (for [row (range (count maze))\n              col (range (count (first maze)))]\n          [[row col] (get-in maze [row col])])))\n    (coords [maze c]\n      (first\n        (for [[pos tile] maze :when (= tile c)] pos)))\n    (rooms [maze]\n      (for [[pos tile] maze :when (not= tile \\#)] pos))\n    (dist [a b] (Math/abs (- a b)))\n    (neighbours [[x y]]\n      (for [[dx dy] [[0 1] [1 0] [0 -1] [-1 0]]]\n        [(+ x dx) (+ y dy)]))\n    (connected-area [maze start]\n      (let [rooms (set (rooms maze))]\n        (loop [area       #{}\n               candidates [start]]\n          (if-let [cand (first candidates)]\n            (if (and (contains? rooms cand)\n                     (not (contains? area cand)))\n              (recur (conj area cand) \n                     (into (rest candidates) (neighbours cand)))\n              (recur area (rest candidates)))\n        area))))]\n    (let [maze  (parse-maze ascii-maze)\n          start (coords maze \\M)\n          end   (coords maze \\C)]\n      (contains? (connected-area maze start) end))))","problem":117,"user":"4f9d53f3e4b0dcca54ed6d21"},{"problem":117,"code":"(fn p117 [maze]\n  (let [m (count (first maze)) n (count maze)]\n    (letfn [(at [maze x y] (when (and (>= x 0) (>= y 0) (< x m) (< y n)) (nth (nth maze y) x)))\n            (free? [cell] (= cell \\space))\n            (cheese? [cell] (= cell \\C))\n            (mouse? [cell] (= cell \\M))\n            (neighbors [pred maze x y] (count (filter pred\n                       (for [dx [-1 0 1] dy [-1 0 1]\n                             :when (and (or (zero? dx) (zero? dy))\n                                        (not (and (zero? dx) (zero? dy))))]\n                                     (at maze (+ x dx) (+ y dy))))))\n            (mice [maze] (remove empty? (for [y (range n) x (range m)] (when (mouse? (at maze x y)) [x y]))))\n            (found-cheese? [maze]\n            \t(->> (mice maze)\n            \t     (remove empty?)\n            \t     (map #(apply neighbors cheese? maze %))\n            \t     (some pos?)\n            \t     (true?)))\n            (step [maze] (for [y (range n)]\n                           (apply str\n                                  (for [x (range m)]\n                                    (case (at maze x y) \\# \\# \\C \\C \\M \\#\n                                      \\space (cond (pos? (neighbors mouse? maze x y)) \\M\n                                                   (pos? (neighbors free? maze x y)) \\space\n                                                   :else \\#))))))]\n      (loop [maze maze]\n        (cond (empty? (mice maze)) false\n              (found-cheese? maze) true\n              :else (recur (step maze)))))))","user":"54c271b9e4b045293a27f602"},{"code":"(letfn [\r\n  (to-vec [m] (vec (map #(vec (seq %)) m)))\r\n\t(reach-cheese? [maze]\r\n\t  (let [\r\n\t        xs (range (count (first maze)))\r\n\t        ys (range (count maze))\r\n\t        cells (for [y ys x xs] [y x])\r\n\t        in-maze? (fn [[y x]] (and (contains? (vec xs) x) (contains? (vec ys) y)))\r\n\t        \r\n\t\t\t\t\tl (fn [[y x]] [y (- x 1)])\r\n\t\t\t\t\tr (fn [[y x]] [y (+ x 1)])\r\n\t\t\t\t\tu (fn [[y x]] [(- y 1) x])\r\n\t\t\t\t\td (fn [[y x]] [(+ y 1) x])\r\n\t        all-dirs [l r u d]\r\n\t        \r\n\t        mouse? (fn [p] (= \\M (get-in maze p)))\r\n\t        free-m? (fn [maze p] (= \\space (get-in maze p)))\r\n\t        free? (fn [p] (= \\space (get-in maze p)))\r\n\t        cheese? (fn [p] (= \\C (get-in maze p)))\r\n\t        wall? (fn [p] (= \\# (get-in maze p)))\r\n\t        put-mouse (fn [maze p] (assoc-in maze p \\M))\r\n\t        \r\n\t        mice (filter mouse? cells)\r\n\t        next-moves (remove wall? (for [d all-dirs mp mice] (d mp)))\r\n         \r\n\t        can-move-to? (fn [m p] (and (in-maze? p) (free-m? m p)))\r\n\t        try-move-mouse (fn [m p] (if (can-move-to? m p) (put-mouse m p) m))\r\n\t        move-mouse (fn [] (reduce try-move-mouse maze next-moves))\r\n         \r\n\t        can-move? (fn [] (some free? next-moves))\r\n\t        can-eat-cheese? (fn [] (some cheese? next-moves))\r\n\t\t    ]\r\n\t\t  (cond\r\n\t\t    (can-eat-cheese?) true\r\n\t\t    (not (can-move?)) false\r\n\t\t    :else (reach-cheese? (move-mouse))\r\n\t\t    )\r\n   ))]\r\n       #(reach-cheese? (to-vec %1))\r\n  )","problem":117,"user":"4e6e10d8535d5021c1a895fd"},{"code":"(fn sci [board]\n  (let\n    [brd (mapv vec board)\n     find-in-maze (fn [board & pieces]\n                    (apply merge\n                      (for [r (range (count board))\n                            :let [row (board r)]\n                            c (range (count row))\n                            :let [chr (get-in board [r c])]\n                            :when (some (set pieces) [chr])]\n                       {chr [r c]})))\n     {start \\M end \\C} (find-in-maze board \\M \\C)\n     get-steps (fn [board [r c]]\n                (for [dr [-1 0 1] dc [-1 0 1]\n                      :when (or (= 0 dr) (= 0 dc))\n                      :when (not (= dr dc 0))\n                      :let [fr (+ dr r) fc (+ dc c)]\n                      :when (not= \\# (get-in board [fr fc] \\#))]\n                  [fr fc]))]\n    (loop [seen #{} current [start]] \n      (cond\n       (some #{end} current) true\n       (empty? current) false\n       :else (let [steps (set (mapcat #(get-steps board %) current))\n                   new (remove seen steps)]\n\n               (recur (into seen new) new ))))))","problem":117,"user":"50217818e4b00bba4502f7a7"},{"problem":117,"code":"(fn [a-maze]\n  (letfn [(size [a-maze]\n            [(count (a-maze 0)) (count a-maze)])\n          (safe-maze [a-maze]\n            (let [[cols rows] (size a-maze)\n                  top-bottom (apply str (take (+ 2 cols) (repeat \\#)))]\n              (into [] (concat [top-bottom] (map #(apply str (concat [\\#] % [\\#])) a-maze) [top-bottom]))))\n          (tile [a-maze [col row]]\n            (nth (a-maze row) col))\n          (find-tile [a-maze a-tile]\n            (let [[cols rows] (size a-maze)]\n              (reduce (fn [acc pos]\n                        (if (= a-tile (tile a-maze pos))\n                          pos\n                          acc))\n                      nil\n                      (for [col (range cols)\n                            row (range rows)]\n                        [col row]))))\n          (neigh [[x y]]\n            [[x (dec y)] [(dec x) y] [(inc x) y] [x (inc y)]])\n          (is-room [a-maze col-row]\n            (not (= (tile a-maze col-row) \\#)))\n          (neigh-rooms-not-visited [a-maze current visited]\n            (filter #(and (is-room a-maze %) (not (some #{%} visited))) (neigh current)))\n          (reachable-from [maze from]\n            (loop [q [from] visited #{from}]\n              (if (empty? q)\n                visited\n                (let [f (first q)\n                      n-v-n (neigh-rooms-not-visited maze f visited)]\n                  (recur (concat (rest q) n-v-n) (conj visited f))))))\n          ]\n    (let [a-safe-maze (safe-maze a-maze)\n          mouse-pos (find-tile a-safe-maze \\M)\n          cheese-pos (find-tile a-safe-maze \\C)]\n      (if (some #{cheese-pos} (reachable-from a-safe-maze mouse-pos))\n        true\n        false))))","user":"5f86a98be4b0649ffcda4caa"},{"code":"(fn [maze]\n    (let [rows (count maze), \n          cols (count (first maze))\n          maze (into [] (map #(into [] (seq %)) maze))\n          in-maze (fn [[r c] m] \n                    (and (>= r 0) (< r rows) \n                         (>= c 0) (< r cols) \n                         (or (= \\space (get-in m [r c])) (= \\M (get-in m [r c]))) ))\n          mouse-pos (first (for [r (range rows), c (range cols) :when (= \\C (get-in maze [r c]))] [r c]))]\n      (loop [queue {mouse-pos maze} ]\n        (if (seq queue)\n          (let [[mouse maze] (first queue),\n                neigbours (for [[r c] [[-1 0] [1 0] [0 -1] [0 1]] \n                                :let [neigbour [(+ (first mouse) r) (+ (second mouse) c)]]\n                                :when (in-maze neigbour maze)] neigbour)]\n            (if (some (fn [pos] (= \\M (get-in maze pos))) neigbours)\n              true\n              (recur \n                (into {} \n                      (if (seq neigbours) \n                        (apply conj\n                               (next queue)\n                               (map (fn [pos] [pos, \n                                               (-> maze \n                                                 (assoc-in mouse \\*)\n                                                 (assoc-in pos \\C)\n                                                 )]) \n                                    neigbours))\n                        (next queue))) )) )\n          false))\n      ))","problem":117,"user":"4dca8b6d535d5973398f9288"},{"code":"(let [width (fn [maze] (count (first maze)))\n      height (fn [maze] (count maze))\n      adjacent4 (fn [[x y]] [[(inc x) y] [(dec x) y] [x (inc y)] [x (dec y)]])\n      maze-get (fn [maze [x y]]\n          (nth (nth maze y []) x nil))] \n\n(fn thisfunc\n  ([maze] (if (thisfunc maze #{} \n                (first (filter #(= \\M (maze-get maze %))\n                  (for [x (range (width maze)) y (range (height maze))] [x y]))))\n            false\n            true))\n  ([maze visited pos]\n     (print maze visited pos \"\\n\")\n    (let [c (maze-get maze pos)]\n      (cond\n        (= \\# c) visited\n        (nil? c) visited\n        (= \\C c) false\n        (visited pos) visited\n        true (loop [v (conj visited pos) ps (adjacent4 pos)]\n               (if (empty? ps)\n                 v\n                 (let [result (thisfunc maze v (first ps))]\n                   (if result\n                     (recur (set (concat result v)) (rest ps))\n                     result)))))))))","problem":117,"user":"4dd9d299535d2dad7130b5dd"},{"problem":117,"code":"(fn solveable? [maze]\n  (let [d [[1 0] [-1 0] [0 1] [0 -1]]\n        mouse (some #(if (= \\M (get-in maze %)) %) (for [i (range (count maze)) j (range (count (first maze)))] [i j]))\n        cheese (some #(if (= \\C (get-in maze %)) %) (for [i (range (count maze)) j (range (count (first maze)))] [i j]))\n        maze (reduce (fn [m p] (assoc m p (set (filter (fn [c] (let [c (get-in maze c)] (and (not (nil? c)) (not= c \\#)))) (map (partial mapv + p) d)))))\n                     {} (for [i (range (count maze)) j (range (count (first maze)))] [i j]))\n        dfs (fn [start end]\n                (loop [stack (list start) visited #{}]\n                      (if-let [n (first stack)]\n                              (if (= n end)\n                                  true\n                                  (recur (into (next stack) (clojure.set/difference (maze n) visited)) (conj visited n)))\n                              false)))]\n        \n        (dfs mouse cheese)))","user":"5958cef6e4b066ee0a44af94"},{"code":"(fn [m]\n  (let [n (into [] (for [r (range (count m))]\n                     (into [] (for [c (range (count (m r)))\n                                    :let [v (get (m r) c)]]\n                                (if (and (not= \\# v)\n                                         (or (some #(= \\M %)\n                                                   [(get (get m r)\n                                                         (dec c))\n                                                    (get (get m r)\n                                                         (inc c))\n                                                    (get (get m (dec r)) c)\n                                                    (get (get m (inc r)) c)])))\n                                  \\M v)))))]\n    (cond\n     (= n m) false\n     (some #(= \\C %)\n           (flatten n)) (recur n)\n     :else true)))","problem":117,"user":"535d910ae4b04ce2eb3ed2c5"},{"code":"(fn [maze]\n  (let [search-in-maze #(for [index (range (count maze))\n                              inner-index (range (count (first maze)))\n                              :let [point [index inner-index]]\n                              :when (= % (get-in maze point))]\n                               point)\n        start (search-in-maze \\M)\n        end (set (search-in-maze \\C))\n        move [[inc identity] [dec identity] [identity inc] [identity dec]]\n        steps (fn [k] (filter #(contains? #{\\space \\C} (get-in maze %)) (map (partial map #(%1 %2)) move (repeat k))))]\n    (loop [current start saw #{}]\n      (cond (empty? current) false\n            (some end current) true\n            :else (recur (remove saw (mapcat steps current)) (into saw current))))))","problem":117,"user":"507fbd77e4b089ade05efbd3"},{"code":"(fn [maze]\n\n    (let [lmaze  (apply concat (map #(map identity %) (map #(str \\# % \\#) maze)))\n          nmaze  (->> lmaze (map-indexed\n                             (fn [i n] (if (= n \\#) i))) (filter identity) set )\n          mmax   (count lmaze)\n          cloc   (.indexOf lmaze \\C)\n          width  (+ 2 (count (first maze)))]\n\n      (loop [[n & que] [(.indexOf lmaze \\M)]\n       negative nmaze]\n\n  (cond\n   (= n cloc) true\n   (nil? n) false\n   :else (recur (concat que\n                        (clojure.set/difference\n                           (set (filter #(and (> % 0) (< % mmax))\n                                        [(dec n) (inc n) (+ width n) (-  n width)]))\n                           negative)) (conj negative n ))))))","problem":117,"user":"5124619ae4b02c3f2a072ccd"},{"code":";; Uses a slightly modified version of my solution to the Graph\n;; Connectivity problem.  The idea is to transform the maze into a\n;; graph with a node for each non-wall space, and an edge between two\n;; nodes if one space can be reached from the other in a single step.\n;; Then if the mouse and the cheese are in the same connected\n;; component of that graph, the mouse can reach the cheese.\n\n(fn [maze]\n  (let [comps (fn [edges]\n                (reduce (fn [c [u v]]\n                          (let [s (or (first (filter #(% u) c)) #{u})\n                                t (or (first (filter #(% v) c)) #{v})]\n                            (conj (disj c s t) (clojure.set/union s t))))\n                        #{} edges))\n        rows (count maze)\n        cols (count (first maze))\n        thing (fn [r c]\n                (if (and (< -1 r rows) (< -1 c cols))\n                  (subs (maze r) c (inc c))\n                  \"#\"))\n        graph (for [r1 (range rows)\n                    c1 (range cols)\n                    :let [t1 (thing r1 c1)]\n                    [delta-r delta-c] [[1 0] [0 1]]\n                    :let [r2 (+ r1 delta-r)\n                          c2 (+ c1 delta-c)\n                          t2 (thing r2 c2)]\n                    :when (and (not= t1 \"#\") (not= t2 \"#\"))]\n                [ (if (#{\"M\" \"C\"} t1) t1 [r1 c1])\n                  (if (#{\"M\" \"C\"} t2) t2 [r2 c2]) ])]\n    (contains? (first (filter #(% \"M\") (comps graph)))\n               \"C\")))","problem":117,"user":"500d8c49e4b07ccb9a7ddb00"},{"problem":117,"code":"(fn cheese-search? [maze]\n  (letfn [(adjacent [m [x y]]\n            (for [[dx dy] [[0 1] [0 -1] [1 0] [-1 0]]\n                  :when (let [x1 (+ x dx)\n                              y1 (+ y dy)]\n                          (and (<= 0 x1)\n                               (< x1 (count m))\n                               (<= 0 y1)\n                               (< y1 (count (first m)))\n                               (zero? (get-in m [x1 y1]))))]\n              [(+ x dx) (+ y dy)]))\n\n          (index [m p]\n            (let [row-len (count (first m))\n                  s (apply str m)\n                  idx (.indexOf s p)]\n            [(quot idx row-len) (rem idx row-len)]))\n\n          (solve [m src dst]\n            (loop [stack [[src]] s []]\n              (if (seq stack)\n                (let [path (peek stack)]\n                  (if (= (last path) dst)\n                    (conj s path)\n                    (recur (vec (concat (pop stack)\n                                        (for [p (adjacent m (last path))\n                                              :when (not (contains? (set path) p))]\n                                          (conj path p))))\n                           s)))\n                s)))]\n\n    (let [maze<->01 (mapv (fn [row]\n                           (mapv (fn [b]\n                                  (case b\n                                    \\# 1\n                                    \\space 0\n                                     0)) row)) maze)]\n\n      ;maze<->01\n      (not (empty? (solve maze<->01 (index maze \"C\") (index maze \"M\")))))))","user":"5693a53ee4b0dcc4269f4106"},{"code":"(let   [neighbor-deltas [[-1 0] [0 1] [1 0] [0 -1]]]\r\n(letfn [\r\n  (open-neighbors [maze [y x]]\r\n\t\t(set\r\n\t\t\t(for [\r\n\t\t\t\t[dy dx] neighbor-deltas\r\n\t\t\t\t:let [ny (+ y dy), nx (+ x dx), cell (get-in maze [ny nx] \\#)]\r\n\t\t\t\t:when (or (= cell \\space) (= cell \\C))]\r\n\t\t\t\t\t[ny nx])))\r\n\t(find-mouse [maze]\r\n\t\t(let [height (count maze), width (count (first maze))]\r\n\t\t\t(first\r\n\t\t\t\t(for [\r\n\t\t\t\t\ty (range height)\r\n\t\t\t\t\tx (range width)\r\n\t\t\t\t\t:let [cell (get-in maze [y x])]\r\n\t\t\t\t\t:when (= cell \\M)]\r\n\t\t\t\t\t\t[y x]))))]\r\n\t\t\t\t\t\t\r\n(fn can-get-cheese? [maze]\r\n\t(loop [seekers #{(find-mouse maze)}, visited-cells #{}]\r\n\t\t(let [visitable       (apply clojure.set/union (map (partial open-neighbors maze) seekers))\r\n\t\t      newly-visitable (clojure.set/difference visitable visited-cells)]\r\n\t\t\t(cond\r\n\t\t\t\t(empty? newly-visitable)\r\n\t\t\t\t\tfalse\r\n\t\t\t\t(some #{\\C} (map (partial get-in maze) newly-visitable))\r\n\t\t\t\t\ttrue\r\n\t\t\t\t:else\r\n\t\t\t\t\t(recur newly-visitable (clojure.set/union visited-cells newly-visitable))))))))","problem":117,"user":"4dd6d6a0535d2dad7130b5ca"},{"code":"(fn [m] (let [g (into {} (apply concat (keep-indexed #(keep-indexed (fn [x y] (if (not= (str y) \"#\") {[%1 x] (str y)})) %2) m)))\n                      imap (into {} (keep-indexed #(identity {(key %2) %1}) g))\n                      n (vec (map #(reduce (fn [x y] (let [k (key %)] (if-not (nil? (g [(+ (first k) (first y)) (+ (second k) (second y))])) (conj x (imap [(+ (first k) (first y)) (+ (second k) (second y))])) x))) [] [[0 1] [0 -1] [1 0] [-1 0]]) g))\n                      stats (vec (map (fn [a] (identity {:p -1 :d -1 :f -1 :c \"w\"})) n))\n                      start (imap (key (first (filter #(= \"M\" (val %)) g))))\n                      goal (imap (key (first (filter #(= \"C\" (val %)) g))))]\n                  (letfn [(dfs [u c stats]\n                            (loop [i 0 stats (-> stats (assoc-in [u :c] \"g\") (assoc-in [u :d] (inc c))) c (inc c)]\n                              (if (>= i (count (n u)))\n                                {:stats (-> stats  (assoc-in [u :c] \"b\") (assoc-in [u :f] (inc c))) :c (inc c)}\n\t                        (if (= \"w\" ((stats ((n u) i)) :c))\n\t                          (let [k ((n u) i) stats (assoc-in stats [k :p] u)]\n                                    (let [res (dfs ((n u) i) c stats) stats (res :stats) c (res :c)]\n                                      (recur (inc i) stats c))\n                                    )\n                                  (recur (inc i) stats c)))))]\n                    (not= -1 ((((dfs start 0 stats) :stats) goal) :p)))))","problem":117,"user":"52c1bd29e4b07a9af579236a"},{"code":"(fn [m]\n  (let [r range\n        c conj\n        n inc\n        m (into [] (map #(into [] %) m))\n        M #(.indexOf % \\M)\n        h (count m)\n        w (count (first m))\n        y (ffirst (filter (fn [[i e]] (<= 0 (M e))) (map #(into [] %&) (r) m)))\n        i #(= (get-in m % \\#) \\#)]\n    ((fn o [p b]\n      (loop [s (let [[y x] p] [[(- y 1) x] [(n y) x] [y (- x 1)] [y (n x)]])\n             b b]\n        (if (seq s)\n          (let [[p & s] s]\n            (if (or (i p) (b p))\n              (recur s (c b p))\n              (or (= (get-in m p) \\C)\n                (o p (c b p))\n                (recur s (c b p))\n              )))\n          false)))\n     [y (M (nth m y))]\n     (into #{}\n           (for [p [(r -1 (n h))\n                    (r -1 (n w))] :when (i p)] p)))))","problem":117,"user":"51a10b2ce4b0b292b01ee3fe"},{"problem":117,"code":"(fn can-navigate? [maze]\n  (let [transpose (fn [coll] (apply mapcat (comp list str) coll))\n        reachable? (fn [s] (re-find #\"(C@|@C)\" s))\n        walk (fn [s]\n               (reduce (fn [s [x y]] (str (subs s 0 x) (apply str (repeat (- y x) \\@)) (subs s y (count s)))) s\n                       (let [matcher (re-matcher #\"[ ]*[M@]+[ ]*\" s)]\n                         (loop [r [] match (re-find matcher)]\n                           (if match\n                             (recur (conj r [(.start matcher) (.end matcher)]) (re-find matcher))\n                             r)))))\n        search (fn [m]\n                 (let [n (->> (map walk m) transpose (map walk) transpose)]\n                   (if (= m n)\n                     m\n                     (recur n))))\n        m (search maze)]\n    (boolean (or (some reachable? m) (some reachable? (transpose m))))))","user":"55c1eb52e4b0e31453f64970"},{"problem":117,"code":"(fn cheese-reachable? [maze]\n  (letfn [(unsigned-int [n] (if (>= n 0) n (* n -1)))\n\n          (make-labelled-graph [maze]\n            (->> (for [i (range (count maze))]\n                   (for [j (range (count (first maze)))\n                         :let [label (get-in maze [i j])]\n                         :when (not= label \\#)]\n                     [i j label]))\n                 (reduce concat)\n                 set))\n\n          (next-edges [[u v _] g]\n            (filter (fn [[a b _]]\n                      (and (or (= a u) (= b v))\n                           (= 1 (unsigned-int (- (or (first (reduce disj\n                                                                    (set [u v])\n                                                                    [a b]))\n                                                     u)\n                                                 (or (first (reduce disj\n                                                                    (set [a b])\n                                                                    [u v]))\n                                                     a))))))\n                    g))\n\n          (bfs-iter-match? [maze]\n            (let [graph (make-labelled-graph maze)\n                  start (first (filter (fn [[i j label]] (= label \\M)) graph))]\n              (loop [visits       (-> (clojure.lang.PersistentQueue/EMPTY) (conj start))\n                     seen         #{start}]\n                (if (empty? visits)\n                  false\n                  (let [cur        (peek visits)\n                        cur-visits (pop visits)]\n                    (if (= (last cur) \\C)\n                      true\n                      (let [next-steps        (->> (next-edges cur (disj graph cur))\n                                                   (filter #(not (contains? seen %1))))\n                            next-visits       (reduce conj cur-visits next-steps)\n                            next-seen         (reduce conj seen next-steps)]\n                        (recur next-visits next-seen))))))))]\n    (bfs-iter-match? maze)))","user":"53bcdd41e4b0d9a98559a6c0"},{"problem":117,"code":"(fn maze ;;dynamic programming approach\n  ([coll]\n   (let [parse-maze (fn [coll] ;; find mouse and cheese coordinates\n                      (reduce (fn [res s]\n                                (let [[idx s] s ;; parsing 2d array is pain :(\n                                      x-coll  (clojure.string/split s #\"\")\n                                      {start \"M\"\n                                       end   \"C\"} (into {}\n                                                        (->> x-coll\n                                                             (map-indexed #(vector %2 %1))\n                                                             (filter #(#{\"M\" \"C\"} (first %)))))\n                                      start (if start {:start [start idx]} {})\n                                      end   (if end   {:end   [end idx]}   {})]\n                                  (-> res\n                                      (merge start)\n                                      (merge end)\n                                      (update-in [:coll] conj x-coll))))\n                              {:start nil :end nil :coll []}\n                              (map-indexed #(vector %1 %2) coll)))\n         {s :start e :end c :coll} (parse-maze coll)]\n     (maze c s e #{s})))\n  ([coll start end visited]\n   (let [possible-routes (fn [coll visited [x y]] ;; find all possible routes from point\n                           (let [max-y (count coll)\n                                 max-x (count (first coll))]\n                             (into #{}\n                                   (filter (fn [[x y]]\n                                             (and (nil? (visited [x y]))\n                                                  (and (>= x 0) (< x max-x))\n                                                  (and (>= y 0) (< y max-y))\n                                                  (coll y)\n                                                  (not= ((coll y) x) \"#\")))\n                                           #{[(inc x) y]\n                                             [(dec x) y]\n                                             [x (inc y)]\n                                             [x (dec y)]}))))]\n     (loop [pts     (possible-routes coll visited start)\n            visited visited]\n       (cond (empty? pts) false\n             (pts end)    true \n             :else        (let [visited (into #{} (concat pts visited)) \n                                map-fn  #(possible-routes coll visited %)]\n                            (recur (into #{} (mapcat map-fn pts)) visited))))))) ;; iterate until we got the coords of cheese","user":"5591cc56e4b0604b3f94d582"},{"code":"(fn for-science-in-one [a] \n  (letfn [(range2d [a]\n    \t\t    (for [x (-> a count range)\n      \t\t \t      y (-> a first count range)]\n    \t\t    [x y]))\n\n\t\t      (walls [a]\n  \t\t\t    (let [w (range2d a)\n     \t  \t \t      w (zipmap w (map #(get-in a %) w))]\n   \t\t\t    w))\n\n\t\t\t (run-dfs [visited frontier walls target]\n              (if (visited target)\n               true\n             (if (empty? frontier)\n              false\n             (let [dirs [[1 0] [-1 0] [0 1] [0 -1]]\n                   chosen-node (first frontier)\n                   new-nodes \n                     (clojure.set/difference \n                       (set (map #(map + chosen-node %) dirs))\n                       visited)\n                    new-nodes (filter #(not= \\# (walls % \\#)) new-nodes)]\n                 (run-dfs\n                     (into visited #{chosen-node})\n                     (set (into (next frontier) new-nodes)) \n                     walls\n                      target)))))\n\t\t]\n     (let [w (walls a)\n          start (first (first (filter #(= \\C (val %)) w)))\n          finish (first (first (filter #(= \\M (val %)) w)))]\n      (run-dfs #{} #{start} w finish))))","problem":117,"user":"5054bc87e4b0b1b9d1860eb0"},{"problem":117,"code":"(fn [s]\n  (let [m #(first (for [i (range (count s))\n                       j (range (count (first s)))\n                       :when (= % (get-in s [i j]))]\n                    [i j]))\n        n (fn [m]\n            (let [i (first m)\n                  j (last m)\n                  p #(= %2 (get-in s %))]\n              (reduce\n               #(if (= true %2)\n                  true\n                  (if (and (coll? %) (and true %2))\n                    (conj % %2)\n                    %))\n               []\n               (for [x [[(dec i) j]\n                        [(inc i) j]\n                        [i (dec j)]\n                        [i (inc j)]]]\n                 (or (and (p x \\space) x) (p x \\C))))))\n        t (fn r [m o]\n            (if (contains? o m)\n              false\n              (let [w (n m)]\n                (if (= true w)\n                  true\n                  (if (empty? w)\n                    false\n                    (reduce #(or % (r %2 (conj o m))) false w))))))]\n    (if (empty? (n (m \\C)))\n      false\n      (t (m \\M) #{}))))","user":"56c08696e4b060a8e693e3aa"},{"code":"(fn [b]\n  (letfn [(find [v]\n            (some identity\n              (for [x (range (count (first b)))\n                    y (range (count b))]\n                (if (= (get-in b [y x]) v) [y x] nil))))\n           (d [v p]\n             (if (v p)\n               v\n               (let [n (->> (map #(vec (map + p %)) [[0 1] [1 0] [0 -1] [-1 0]])\n                                (remove #(= \\# (get-in b % \\#))))]\n                 (reduce d (conj v p) n))))]\n  (contains?\n    (d #{} (find \\C))\n    (find \\M))))","problem":117,"user":"4f465096e4b0d56e7bb92b9a"},{"code":"(fn q117 [maze]\n  (let [rows (count maze)\n        cols (count (first maze))\n        mouse (first (keep-indexed #(if (>= %2 0) [%1 %2]) (map #(.indexOf % \"M\") maze)))\n        [cr cc] (first (keep-indexed #(if (>= %2 0) [%1 %2]) (map #(.indexOf % \"C\") maze)))\n        dirs [[-1 0] [1 0] [0 -1] [0 1]]\n        nexts (fn [pos]\n                (->> \n                  (map #(map + pos %) dirs)\n                  (filter (fn [[r c]] (and (< -1 r rows) (< -1 c cols))))\n                  (remove #(= \\# (get-in maze %)))))\n        cheese? #(some (fn [[r c]] (and (= r cr) (= c cc))) %)\n        ]\n    (loop [visited #{} ps #{mouse}]\n      (if (empty? ps) false\n        (let [fps (first ps)\n              nps (remove visited (nexts fps))]\n          (if (cheese? nps) true\n            (recur (conj visited fps) (into (disj ps fps) nps))))))))","problem":117,"user":"4fd22e70e4b04c3a95aa041c"},{"code":"(fn [b]\n  (let [nrows (count b)\n        ncols (count (first b))\n        board (apply merge (for [i (range nrows) j (range ncols)]\n                             {[i j] (get (b i) j)}))\n        start (key (first (filter #(= \\M (val %)) board)))\n        goal  (key (first (filter #(= \\C (val %)) board)))\n        dir   [[1 0] [-1 0] [0 1] [0 -1]]\n        legal (fn [[i j]] (and (<= 0 i) (<= 0 j) (< i nrows) (< j ncols)))\n        succ  (fn [x] (filter #(and (legal x) (#{\\space \\C} (board %)))\n                              (map #(vec (map + % x)) dir)))]\n    (loop [seen #{} last #{start}]\n      (cond (contains? last goal) true\n            (clojure.set/subset? last seen) false\n            :else (recur (clojure.set/union seen last)\n                         (set (mapcat succ last)))))))","problem":117,"user":"4ed94d69535d10e5ff6f5303"},{"problem":117,"code":"(fn solvable-maze? [maze]\n  (let [maze (mapv vec maze)\n        coords (for [r (range (count maze))\n                     c (range (count (first maze)))]\n                 [r c])\n        find-coord (fn [maze c] (first (filter #(= c (get-in maze %))\n                                               coords)))\n        start (find-coord maze \\M)\n        end (find-coord maze \\C)\n        neighbors (fn [maze c]\n                    (let [r 1\n                          rd (range (- r) (inc r))\n                          ns (for [xd rd\n                                   yd rd\n                                   :let [d [xd yd]]\n                                   :when (= 1 (count (filter zero? d)))]\n                               (map + c d))]\n                      (filter #(#{\\space \\C} (get-in maze %)) ns)))]\n    (loop [visited #{}\n           [h & more] [start]]\n      (if (nil? h)\n        false\n        (or (= h end)\n            (recur (conj visited h)\n                   (into more (filter (complement visited) (neighbors maze h)))))))))","user":"5ca14eb1e4b048ec896c5b7d"},{"code":"(fn [board]\n(letfn [(get-spaces [board] (for [i (range (count board)) j (range (count (first board)))\n        :when (not= \\# (get-in board [i j]))] [i j]))\n        (neighbours [[x y] board] (filter (fn [v] (some #(= (get-in board v) %) [\\M \\C \\space]))\n          (for [[i j] [[0 1] [0 -1] [1 0] [-1 0]]] [(+ x i) (+ y j)])))\n        (include? [c m] (some #(= c %) m))]\n  (loop [spaces (get-spaces board)\n         ms (some #(if (= \\M (get-in board %)) [%]) spaces)]\n    (let [s (remove #(include? % ms) spaces)\n          m (filter #(include? % s) (distinct (mapcat #(neighbours % board) ms)))]\n      (if (empty? m) false\n        (if (some #(= \\C (get-in board %)) m) true\n          (recur s m)))))))","problem":117,"user":"4fdb02aae4b05e33b9224f56"},{"problem":117,"code":"(fn mod-laby [l] (let\n  [m (group-by #(get-in l %)\n                (for [y (range (count l)),\n                      x (range (count (first l)))]\n                     [y x]))\n    C (get m '\\C)]\n    (loop [o [], a (get m '\\M)]\n        (cond\n          (some (set C) a) true\n          (= a o) false\n          :e (->> (for [s1 a s2 (concat C (get m '\\space))]\n                      (-> (map - s1 s2)\n                      list\n                      set\n                      (some #{[0 1] [0 -1] [1 0] [-1 0]})\n                      (if s2)))\n                 (remove nil?)\n                 (concat a)\n                 (distinct)\n                 (recur a))))))","user":"5f548678e4b0a0bc16850a7e"},{"code":"(fn [c r g M]\n  (let [X (c M)\n        Y (c (M 0))\n        [m & _] (for [i (r X)\n                          j (r Y)\n                          :when (= \\M (g M [i j]))]\n                      [i j])\n        n (fn [[x y]]\n                     (filter\n                      (fn [[x y]]\n                        (and (< -1 x X)\n                             (< -1 y Y)\n                             (#{\\ \\C} (g M [x y]))))\n                      [[(+ x 1) y] [(- x 1) y] [x (+ y 1)] [x (- y 1)]]))]\n    (loop [e #{m}]\n      (let [t (into e (mapcat n e))]\n        (if ((set (map g (repeat M) t)) \\C)\n          true\n          (if (= t e)\n            false\n            (recur t)))))))\ncount range get-in","problem":117,"user":"4e65027c535d8ccf87e9fe6e"},{"code":"(fn z [b]\n  (let [f (reduce merge (for [i (range (count b))\n                              j (range (count (first b)))]\n                          {[i j] (nth (vec (nth b i)) j)}))\n        m (get (clojure.set/map-invert f) \\M)\n        c (get (clojure.set/map-invert f) \\C)\n        s (set (filter identity (map #(if (= (second %) \\space)\n                                        (first %)\n                                        false) f)))]\n    (loop [o (conj s c)\n           n #{m}]\n      (cond (contains? n c) true\n            (empty? n) false\n            :else\n            (let [x              \n                  (filter #(contains? o %)\n                          (concat (map #(vector (inc (first %)) (second %)) n)\n                                  (map #(vector (dec (first %)) (second %)) n)\n                                  (map #(vector (first %) (inc (second %))) n)\n                                  (map #(vector (first %) (dec (second %))) n)))]\n              (recur (apply disj (cons o x)) (set x)))))))","problem":117,"user":"4facd2fae4b081705acca22f"},{"code":"(fn [m] \r\n  (let [m (vec (map vec m))\r\n        r (count m)\r\n        c (count (first m))]  \r\n    ((fn f [m]\r\n       (let [idxs (for [i (range r)]\r\n                    (for [j (range c) \r\n                          :when (or (= (get-in m [i j]) \\M)\r\n                                    (= (get-in m [i j]) \\*))]\r\n                      [i j]))\r\n             nbs (fn [[x y]] (filter \r\n                        (fn [[x y]] \r\n                          (and (and (>= x 0) (< x r))\r\n                               (and (>= y 0) (< y c))))\r\n                        [[(inc x) y] \r\n                         [(dec x) y] \r\n                         [x (inc y)]\r\n                         [x (dec y)]]))\r\n             nidxs (partition 2 (flatten \r\n                                  (map nbs \r\n                                       (filter (comp not empty?) \r\n                                               (partition 2 (flatten idxs))))))\r\n             fnbs (fn [f] (reduce (fn [res nidx] \r\n                                    (or (f (get-in m nidx)) res)) \r\n                                  false\r\n                                  nidxs))\r\n             nm (reduce (fn [r i] \r\n                          (if (= (get-in r i) \\space)\r\n                            (update-in r i (fn [o] \\*))\r\n                            r)) m nidxs)]\r\n         (if (fnbs #(= % \\C))\r\n           true\r\n           (if (not (fnbs #(= % \\space)))\r\n             false\r\n             (f nm)))))\r\n          m)))","problem":117,"user":"4f0da4e4535d0136e6c22319"},{"code":"(fn maze [b]\r\n    (let [m (apply merge-with conj {\\space #{} \\# #{}} (apply concat (map-indexed (fn [y row] (map-indexed (fn [x c] {c [x y]}) row)) b)))\r\n          grow (fn [[cx cy] x y [cheese space]] \r\n                    (let [coord [(+ cx x) (+ cy y)]] (if (space coord) [(conj cheese coord) (disj space coord)] [cheese space]))) \r\n          find (fn [cheese space] \r\n                 (let [[growcheese growspace] (reduce #(->> %1 (grow %2 0 1) (grow %2 0 -1) (grow %2 1 0) (grow %2 -1 0)) [cheese space] cheese)] \r\n                   (if (= (count cheese) (count growcheese))\r\n                     (contains? cheese (m \\M))\r\n                     (recur growcheese growspace))))]\r\n    (find #{(m \\C)} (conj (m \\space) (m \\M)))))","problem":117,"user":"4feada56e4b0140c20fb9c11"},{"problem":117,"code":"(fn\n  [maze]\n  (loop [m (mapv #(apply vector %) maze) \n         cs (for [r (range (count m)) c (range (count (first m)))\n               :when (= (get-in m [r c]) \\M)]\n               [r c])]\n   (if (empty? cs)\n     false\n     (let [neib (for [c cs [x y] [[-1 0] [1 0] [0 -1] [0 1]]] \n                (mapv + c [x y]))]\n       (if (some #(= (get-in m %) \\C) neib) \n         true\n         (let [ncs (filter #(= (get-in m %) \\space) neib)]\n           (recur (reduce #(update-in %1 %2 (fn [n] \\#)) m ncs) ncs)))))))","user":"576df252e4b0979f8965156f"},{"problem":117,"code":"(fn [mazerows]\n    (let [readmaze (fn [] \n                     (let [indexit (fn [toindex] (map #(vector %1 %2) (range) toindex))]\n                       (reduce          ; row reduce\n                        (fn [maze [rowidx row]]\n                          (reduce       ; col reduce \n                           (fn [maze [colidx cell]]\n                             (assoc maze [rowidx colidx] \n                                    ({\\M :mouse \\C :cheese \\# :wall} cell)))\n                           maze (indexit (seq row))))\n                        {}              ;empty maze\n                        (indexit mazerows))))\n          mazewidth (count (seq (first mazerows)))\n          mazeheight (count mazerows)\n          up     (fn [[row col]] [(max (dec row) 0) col])\n          down   (fn [[row col]] [(min (inc row) (dec mazeheight)) col])\n          left   (fn [[row col]] [row (max (dec col) 0)])\n          right  (fn [[row col]] [row (min (inc col) (dec mazewidth))])\n                                        ; iterate the maze by expanding out the mouse marker\n          around (fn [key] (list (up key) (down key) (left key) (right key)))\n          mousekeys (fn [maze]\n                      (filter #(= :mouse (maze %)) (keys maze)))\n          mazeiter (fn [maze]\n                     (reduce (fn [maze key]\n                               (reduce (fn [maze trykey]\n                                         (if (nil? (maze trykey))\n                                           (assoc maze trykey :mouse)\n                                           maze))\n                                       maze\n                                       (around key)))\n                             maze\n                             (mousekeys maze)))\n          mazetest (fn [maze]\n                     (some #(= :cheese (maze %))\n                           (reduce (fn [testkeys mousekey] \n                                     (apply (partial conj testkeys) (around mousekey) ) ) \n                                   #{} \n                                   (mousekeys maze)))\n                     )]\n      (loop [maze (readmaze)]\n        (if (mazetest maze)\n          true\n          (let [newmaze (mazeiter maze)\n                samemaze (= newmaze maze)]\n            (if samemaze\n              false\n              (recur newmaze)))\n          ))\n      ))","user":"554a75c9e4b0a04f79299575"},{"code":"(fn [maze]\n  (let [type? #(fn [[_ type]] (= type %))\n        adjacencies (fn [pos] (map (fn [& x] (apply map + pos x)) [[0 1] [0 -1] [1 0] [-1 0]]))\n        squares (apply concat (map-indexed (fn [row-i row] (map-indexed (fn [col-i col] [[row-i col-i] col]) row)) maze))]\n    (loop [to-check (map first (filter (type? \\M) squares))\n           places (into {} squares)]\n      (if (seq to-check)\n        (let [current-place (first to-check)\n              remaining-places (dissoc places current-place)]\n          (case (get places current-place)\n            (nil \\#) (recur (rest to-check) remaining-places) \n            (\\M \\space) (recur (concat (adjacencies current-place) (rest to-check)) remaining-places)\n            (\\C) true))\n        false))))","problem":117,"user":"4e80aa10535db62dc21a62b1"},{"problem":117,"code":"(fn gotcheese? [maze]\n  (let [transpose (fn [m] (map #(apply str %) (apply mapv vector m)))\n        flood (fn [m] (map #(clojure.string/replace % #\" M|M \" \"MM\") m))]\n    (loop [m1 maze previous []]\n      (let [m2 (flood m1) m3 (flood (transpose m2)) m4 (transpose m3)]\n              (if (some identity (map #(re-seq #\"CM|MC\" %) (concat m2 m3))) true\n                    (if (= m4 previous) false\n                        (recur m4 m1)))))))","user":"579d9601e4b05b1deef9ae18"},{"code":"(fn [maze]\n  (letfn [(mouse-idx [maze]\n            (first (for [r (range (count maze))\n                         c (range (count (first maze)))\n                         :when (= \\M (get-in maze [r c]))]\n                     [r c])))\n          (win? [maze positions]\n            (some #(= \\C (get-in maze %)) positions))\n          (next-steps [maze positions]\n            (filter #(#{\\space \\C} (get-in maze %))\n                    (distinct (mapcat (fn [p] \n                                        (map #(vec (map + p %)) [[-1 0] [0 -1] [0 1] [1 0]])) \n                                      positions))))\n          (add-wall [maze positions]\n            (reduce #(assoc-in %1 %2 \\#) maze positions))\n          (search [maze positions]\n\t        (if (empty? positions)\n      \t\t false\n      \t\t (if (win? maze positions)\n        \t  true\n        \t  (recur (add-wall maze positions) (next-steps maze positions)))))]\n    (search (vec (map vec maze)) [(mouse-idx maze)])))","problem":117,"user":"514721c6e4b0d520409ed392"},{"problem":117,"code":"(fn fs[mv]\n  (let [W (count (get mv 0))\n        H (count mv)\n        mm (to-array-2d (map seq mv))\n        mm (apply merge (for [j (range W)\n                              i (range H)] {[i j] (aget mm  i j)}))\n        mxy (ffirst (filter #(= \\M (get % 1)) mm))\n        cxy (ffirst (filter #(= \\C (get % 1)) mm))\n        mm (dissoc mm mxy)\n        ps (list mxy)]\n    (letfn [(fc[mz pt] \n              (if (or (empty? pt)(empty? mz))\n                false ; cheese not found, no more cells to lookup\n                (let [c (first pt)\n                      r (rest pt)\n                      cx (c 0)\n                      cy (c 1)\n                      ca (for [[x y] [[0 1][1 0][0 -1][-1 0]]]\n                           (vector (+ cx x) (+ cy y))); list of adjacent coord\n                      mzn (apply dissoc mz ca); remove adjacent cells\n                      caf (filter #(= \\space (get mz %)) ca); free adjacent cells\n                      ptn (if (empty? caf) \n                            r\n                            (apply conj r caf))] ; add found free cells\n                  (if (contains? (set ca) cxy)\n                    true\n                    (fc mzn ptn)))))]\n      (fc mm ps ))))","user":"54d4bd2be4b0a52adc2e2005"},{"problem":117,"code":"(fn mouse [maze]\n  (letfn [(dorowsoneway [m]\n                (for [row m]\n                  (let [ps (partition 2 1 row)\n                        pairs (cons (reverse (first ps)) ps)]\n                    (for [[a b] pairs]\n                      (if (and\n                           (= a \\M)\n                           (or (= b \\space) (= b \\C)))\n                        \\M\n                        b)))))\n          (dorows [m]\n                  (dorowsoneway (map reverse (dorowsoneway (map reverse m)))))\n          (docolsoneway [m]\n                  (let [ps (partition 2 1 m)\n                        pairs (cons (reverse (first ps)) ps)]\n                    (if (seq ps)\n                      (for [[rowA rowB] pairs\n                          \t:let [xs (map vector rowA rowB)]]\n                      \t\t(for [[a b] xs]\n                        \t\t(if (and\n                             \t\t(= a \\M)\n                             \t\t(or (= b \\space) (= b \\C)))\n                          \t\t\\M\n                          \t\tb)))\n                      m)))\n          (docols [m]\n                  (docolsoneway (reverse (docolsoneway (reverse m)))))]\n    (let [mout (docols (dorows maze))]\n      (if (= maze mout)\n        (not (some #{\\C} (flatten mout)))\n        (recur mout)))))","user":"51000111e4b00d7ad4cab15e"},{"problem":117,"code":"(fn findPath [maze]\n  (letfn [(findStart [maze]\n            (first (for [i (range (count maze))\n                         j (range (count (first maze)))\n                         :when (= \\M (get-in maze [i j]))]\n                     [i j])))\n          (findValidPos [maze seen [x y]]\n            (filter\n             #(not (contains? seen %))\n             (filter #(or (= \\space (get-in maze % \\#))\n                          (= \\C (get-in maze % \\#)))\n                     [[(inc x) y]\n                      [(dec x) y]\n                      [x (inc y)]\n                      [x (dec y)]])))\n          (findPathWorker [maze pos seen]\n            (if (empty? pos)\n              false\n              (let [f (first pos)\n                    r (rest pos)]\n                (cond\n                  (= \\C (get-in maze f \\#)) true\n                  (= \\# (get-in maze f \\#)) (recur maze r (conj seen f))\n                  :else (recur maze\n                               (concat r (findValidPos maze seen f))\n                               (conj seen f))))))]\n    (findPathWorker maze [(findStart maze)] #{})))","user":"54f64e99e4b0f2f3c5226ea4"},{"code":"(fn [m]\r\n  (let [co (set (for [x (range (count m))\r\n                      y (range (count (first m)))]\r\n                  [x y]))\r\n        start (first (filter #(= \\M (get-in m %)) co))\r\n        nbs (fn [x]\r\n              (filter #(co %)\r\n                      (for [y [[1 0] [0 1] [-1 0] [0 -1]]]\r\n                        [(+ (x 0) (y 0)) (+ (x 1) (y 1))])))\r\n        next (fn [x done]\r\n               (filter #(not (= \\# (get-in m %)))\r\n                (filter #(not (done %)) (nbs x))))\r\n        search (fn search [now todo done]\r\n                 (cond\r\n                     (nil? now) false\r\n                     (= \\C (get-in m now)) true\r\n                     :default\r\n                     (recur (first todo)\r\n                            (into (rest todo) (next now done))\r\n                            (into done todo))))]\r\n    (search start [start] #{start})))","problem":117,"user":"4db4714f535dc0f10411755a"},{"problem":117,"code":"(fn [matrix]\n    (let [height (count matrix)\n          width (count (first matrix))\n          place? (fn [[x y :as coords]] (and (vector? coords) (= (count coords) 2) (< -1 x height) (< -1 y width)))\n          directions '(#_up [-1 0] #_down [1 0] #_left [0 -1] #_right [0 1])\n          direction? (fn [dir] (some (partial = dir) directions))\n          move (fn [[x y :as coords] [x-delta y-delta :as dir]] {:pre [(place? coords) (direction? dir)]} ;no post check, since we want it also to return place outside the matrix\n                 [(+ x x-delta) (+ y y-delta)])\n          neighbours-all (fn [[x y :as from]] {:pre (place? from)}\n                           (for [dir directions\n                                 :let [to (move from dir)]\n                                 :when (place? to) #_within-bounds-only]\n                             to)\n                           )\n          replace-char-at (fn [string index replacement] {:pre [(string? string) (number? index)]\n                                                          :post[(string? %) (= (count %) (+ (count string) (count (str replacement)) -1))]}\n                            (str (subs string 0 index) replacement (subs string (inc index))))\n          result (loop [mx matrix\n                   recent-visits (for [x (range 0 height)\n                                       y (range 0 width)\n                                       :when (= (get (matrix x) y) \\M)]\n                                   [x y])]\n              (println :mx mx)\n              (let [at (fn [[x y :as coords]] {:pre (place? coords)} (println :at x y mx)(get (mx x) y))\n                    is? (fn [pl character] (= (at pl) character))\n                    visited? (fn [pl] (is? pl \\M)) ;as we visit places, we mark them with M\n                    pass? (fn [pl] (is? pl \\space))\n                    goal? (fn [pl] (is? pl \\C))\n                    recent-neighbours (for [visited recent-visits\n                                            neighb (neighbours-all visited)]\n                                        neighb)\n                    _ (println :recent-neighbours recent-neighbours)\n                    passable-neighbours (filter pass? recent-neighbours)\n                    ]\n                (if (seq (filter goal? recent-neighbours))\n                  true\n                  (if (seq passable-neighbours)\n                    (let [mx-with-visits (reduce (fn [mx [x y :as pl]] {:pre [(place? pl)]}\n                                                   (let [row (mx x)\n                                                         row-updated (replace-char-at row y \\M)]\n                                                     (assoc mx x row-updated)))\n                                             mx passable-neighbours)]\n                      (recur mx-with-visits passable-neighbours))\n                    #_else false))))\n              ]\n      result\n    )\n )","user":"5b999af8e4b0c0b3ffbd4ad3"},{"code":"(fn [ss]\n  (let\n\t\t[\n\t\t\theight (count ss)\n\t\t\twidth (count (first ss))\n\t\t\tinitial-state (apply vector (map #(apply vector (replace {\\M 0} %)) ss))\n\t\t]\n\t\t(letfn\n\t\t\t[\n\t\t\t\t(cell-state [[i j] state] ((state j) i))\n\t\t\t\t(conquered? [c state] (integer? (cell-state c state)))\n\t\t\t\t(open? [c state] (= \\space (cell-state c state)))\n\t\t\t\t(cheese? [c state] (= \\C (cell-state c state)))\n\t\t\t\t(neighbors [i j width height]\n\t\t\t\t\t(filter\n\t\t\t\t\t\t(fn [[i j]] (and (>= i 0) (>= j 0) (< i width) (< j height)))\n\t\t\t\t\t\t[[(dec i) j] [(inc i) j] [i (dec j)] [i (inc j)]]\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t\t(neighbors-filtered [i j width height state predicate]\n\t\t\t\t\t(filter\n\t\t\t\t\t\t#(predicate % state)\n\t\t\t\t\t\t(neighbors i j width height)\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t\t(neighbors-conquered [i j width height state]\n\t\t\t\t\t(neighbors-filtered i j width height state conquered?)\n\t\t\t\t)\n\t\t\t\t(cell-cheese [width height state]\n\t\t\t\t\t(apply concat\n\t\t\t\t\t\t(map-indexed\n\t\t\t\t\t\t\t(fn [j row]\n\t\t\t\t\t\t\t\t(apply concat\n\t\t\t\t\t\t\t\t\t(map-indexed\n\t\t\t\t\t\t\t\t\t\t(fn [i cell]\n\t\t\t\t\t\t\t\t\t\t\t(if (cheese? [i j] state)\n\t\t\t\t\t\t\t\t\t\t\t\t[i j]\n\t\t\t\t\t\t\t\t\t\t\t\tnil\n\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\trow\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\tstate\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t\t(step [width height state]\n\t\t\t\t\t(apply vector\n\t\t\t\t\t\t(map-indexed\n\t\t\t\t\t\t\t(fn [j row]\n\t\t\t\t\t\t\t\t(apply vector\n\t\t\t\t\t\t\t\t\t(map-indexed\n\t\t\t\t\t\t\t\t\t\t(fn [i cell]\n\t\t\t\t\t\t\t\t\t\t\t(if (open? [i j] state)\n\t\t\t\t\t\t\t\t\t\t\t\t(let [nc (neighbors-conquered i j width height state)]\n\t\t\t\t\t\t\t\t\t\t\t\t\t(if (empty? nc)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tcell\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t(inc (cell-state (first nc) state))\n\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\tcell\n\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\trow\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\tstate\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t]\n\t\t\t(let [[cci ccj] (cell-cheese width height initial-state)]\n\t\t\t\t(loop [state initial-state]\n\t\t\t\t \t(if (not (empty? (neighbors-conquered cci ccj width height state)))\n\t\t\t\t\t\t;(inc (cell-state (first (neighbors-conquered cci ccj width height state)) state))\n\t\t\t\t\t\ttrue\n\t\t\t\t\t\t(let [step-state (step width height state)]\n\t\t\t\t\t\t\t(if (= state step-state)\n\t\t\t\t\t\t\t\tfalse\n\t\t\t\t\t\t \t\t(recur step-state)\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t)\n\t\t\t\t \t)\n\t\t\t\t)\n\t\t\t)\n\t\t\t\n\t\t)\n\t)\n)","problem":117,"user":"507eddf4e4b06ce648bcdbfa"},{"problem":117,"code":"(fn [input]\n    (let [input-to-adj-map (fn [in]\n  (let [h (count in)\n        w (count (first in))]\n    (->> (for [x (range w)\n               y (range h)]\n           (let [v (get-in in [y x])]\n             (cond\n               (#{\\M \\C \\space} v) [[y x] (->> [[(inc y) x]\n                                                [(dec y) x]\n                                                [y (inc x)]\n                                                [y (dec x)]]\n                                               (remove (fn [[y x]] (or (< x 0)\n                                                                       (>= x w)\n                                                                       (< y 0)\n                                                                       (>= y h))))\n                                               (remove (fn [p] (= \\# (get-in in p))))\n                                               vec) (cond\n                                                      (= v \\M) :start\n                                                      (= v \\C) :end\n                                                      :else  :point)]\n               :else [])))\n         (remove empty?)\n         (reduce (fn [acc [coords edges t]]\n\n                   (let [graph (acc :graph)\n                         acc\n                         (assoc acc :graph\n                                (assoc graph coords\n                                       (into (get graph coords #{})\n                                             edges)))]\n                     (if (= t :point)\n                       acc\n                       (assoc acc t coords)))) {:graph {}}))))]\n      (letfn [(dfs-solve [{:keys [graph start end] :as s} visited-nodes]\n                (let [to-visit (graph start)\n                      visited (conj visited-nodes start)]\n                  (if-let [end-found  (first (filter (partial = end) to-visit))]\n                    [true visited]\n                    (->> to-visit\n                         (remove visited)\n                         (map #(dfs-solve (assoc s :start %) visited))\n                         (reduce (fn [[r v] [end-found? vis]]\n                                   (cond\n                                     r [true v]\n                                     end-found? [true (into v vis)]\n                                     :else [false (into v vis)])) [false visited])))))]\n\n        (let [{:keys [graph end]  :as maze} (-> input\n                                          input-to-adj-map\n                                          )]\n          (if (empty? (graph end))\n            false\n            (-> maze\n                (dfs-solve #{})\n                first))))))","user":"527ccaf4e4b0757a1b17136d"},{"code":"(fn [r m]\r\n  (not= nil (some #(re-seq #\"C@\" %)\r\n                  (flatten (take 50 (iterate r m))))))\r\n#(map (fn [s] (.replaceAll s \"(M|@) \" \"$1@\"))\r\n  (reverse (apply map str %)))","problem":117,"user":"5036dea0e4b0af0658af77a4"},{"problem":117,"code":"(fn mouse-cheese [board]\n  (letfn [(next-board [board]\n                      (let [board-matrix (mapv #(vec %) board)]\n                        (map-indexed\n                          (fn [r row]\n                            (apply str\n                                   (map-indexed\n                                     (fn [c cell]\n                                       (let [adjacent (or\n                                                        (= \\M (get-in board-matrix [(dec r) c]))\n                                                        (= \\M (get-in board-matrix [r (dec c)]))\n                                                        (= \\M (get-in board-matrix [(inc r) c]))\n                                                        (= \\M (get-in board-matrix [r (inc c)])))]\n                                         (if (and adjacent\n                                                  (or (= \\space cell)\n                                                      (= \\C cell)))\n                                           \\M\n                                           cell)))\n                                     row)))\n                          board-matrix)))]\n    (not (contains? (set (mapcat seq\n                             (loop [board board]\n                               (let [board' (next-board board)]\n                                 (if (= board' board)\n                                   board\n                                   (recur board')))))) \\C))))","user":"5353afa0e4b084c2834f4b03"},{"code":"(fn [s]\n  (let [field (vec (map vec s))\n        cols (count (first field))\n        rows (count field)\n        get-at (fn [[x y]]\n                 ((field y) x))\n        loc-first (fn [c]\n                    (let [i (count\n                             (first (split-with #(not= c %)\n                                                (apply concat field))))]\n                      [(mod i cols) (quot i cols)]))\n        moves (fn [seen coll]\n                (filter #(not (seen %)) coll))\n        cands (fn [[x y :as p]]\n                (filter #(and\n                          (not= [x y] %)\n                          (not-any? neg? %)\n                          (and (< (first %) cols) \n                               (< (last %) rows))\n                          (not= (get-at %) \\#))\n                        (for [a (range -1 2) b (range -1 2) :when (not= a b)] \n                          [(+ x a) (+ y b)])))\n        find-path (fn []\n                    (let [start (loc-first \\M)\n                          goal  (loc-first \\C)]\n                      (loop [seen #{start}\n                             mvs  (moves seen (cands start))]\n                        (cond\n                         (seen goal) true\n                         (empty? mvs) false\n                         :else (recur (into seen mvs) (moves seen (mapcat cands mvs)))))))]\n    (find-path)))","problem":117,"user":"4e68b46c535d8ccf87e9fe87"},{"code":"(fn [m]\n  (let [r (fn [[i j]]\n            (keep \n              (fn [[x y]] ({\\  [x y] \\C true} (nth (nth m x []) y nil))) \n              [[i (dec j)] [(dec i) j] [(inc i) j] [i (inc j)]]))\n        w (flatten \n            (keep-indexed (fn [i s] \n              (keep-indexed (fn [j c] (if (= c \\M) [i j])) s)) m))]\n    ((fn f [p c v] \n       (boolean \n         (or (some true? c)\n             (some #(f % (r %) (into v `(~@c ~p))) (remove v c)))))\n     w (r w) #{})))","problem":117,"user":"4ef49c2c535dced4c769f238"},{"code":"(fn [maze]\n  (let [\n        get-locations (fn [maze v]\n                        (partition 2 (remove nil? (flatten (map-indexed \n                                   (fn [x row]\n                                     (map-indexed (fn [y c] (if (= c v) [x y])) row)) \n                                   maze)))))\n        get-walls (fn [maze]\n                    (let [h (count maze) w (-> maze first count)] \n                      (concat \n                                                                  (get-locations maze \\#)\n                                                                  (mapcat #(list [-1 %] [h %]) (range w))\n                                                                  (mapcat #(list [% -1] [% w]) (range h))\n                                                                  )))\n        mouse (-> maze (get-locations \\M) first)\n        cheese (-> maze (get-locations \\C) first)\n        walls (set (get-walls maze))\n        move (fn [coord]\n               (map #(map + coord %) '([-1 0] [1 0] [0 1] [0 -1] [0 0])))\n        get-all-moves (fn [reachable]\n                        (set (remove walls (mapcat move reachable))))\n        ]\n    (loop [reachable (hash-set mouse)]\n      (if (reachable cheese)\n        true\n        (let [next-reachable (get-all-moves reachable)]\n          (if (= reachable next-reachable)\n            false\n            (recur next-reachable))\n          )))))","problem":117,"user":"4fbbcf0ce4b081705acca2ee"},{"code":"(fn [v]\n  (let [l (fn [x y v] (nth (nth v y) x)) lc (fn [c v] (l (c 0) (c 1) v))\n        m (first (filter identity (for [y (range 0 (count v)) x (range 0 (count (first v)))]\n                                       (if (= \\M (l x y v)) [x y] nil))))\n        nb (fn [x y v]\n             (let [c [[(dec x) y] [(inc x) y] [x (dec y)] [x (inc y)]]]\n               (filter #(and (>= (% 0) 0) (< (% 0) (count (first v))) (>= (% 1) 0) (< (% 1) (count v))) c)))\n        sw (fn [x y v n] (assoc (vec v) y (assoc (vec (nth v y)) x n)))\n        fill-in (fn [v c] (loop [r v cs c] (if (empty? cs) r (recur (sw ((first cs) 0) ((first cs) 1) r \\#) (rest cs)))))]\n    (loop [ve (fill-in v [m]) cs [m]]\n          (let [as (distinct (apply concat (for [c cs]\n                                                (filter #(not= \\# (lc % ve)) (nb (first c) (second c) ve)))))\n                vals (map #(lc % ve) as)]\n               (cond (some #(= % \\C) vals) true\n                     (empty? as) false\n                     :else (recur (fill-in ve as) as))))))","problem":117,"user":"50bce014e4b0594b91591c63"},{"problem":117,"code":"(fn [maze]\n    (let [x-dim (count (first maze))\n          y-dim (count maze)\n          neighbors (fn [[y x]] (for [a [[(dec y) x] [(inc y) x]\n                                         [y (dec x)] [y (inc x)]]\n                                      :when (and (< -1 (first a) y-dim)\n                                                 (< -1 (second a) x-dim)\n                                                 (not= (get-in maze a) \\#))]\n                                  a))\n          [m-sq] (for [x (range x-dim) y (range y-dim) \n                       :when (= (get-in maze [y x]) \\M)]\n                 [y x])]\n      (loop [visited #{m-sq} stack (neighbors m-sq)]\n        (cond \n         (empty? stack) false\n         (= (get-in maze (first stack)) \\C) true\n         (visited (first stack)) (recur visited (next stack))\n         :else (recur (conj visited (first stack))\n                      (reduce (fn [acc v] (cons v acc)) \n                              (next stack) \n                              (neighbors (first stack))))))))","user":"513e8141e4b02b2a3d8235c1"},{"problem":117,"code":"(fn [maze]\n  (let [rows (count maze)\n        cols (count (first maze))\n        find-reachable (fn [source incidence-map]\n                         (loop [sources (list source)\n                                reachables #{source}]\n                           (if (empty? sources)\n                             reachables\n                             (let [next-source (first sources)\n                                   new-reachables (clojure.set/difference (incidence-map next-source) reachables)]\n                               (recur (concat (rest sources) new-reachables)\n                                      (clojure.set/union reachables new-reachables))))))\n        incidence-map (->> (for [from-i (range rows)\n                                 from-j (range cols)\n                                 :when (not= (get (get maze from-i) from-j) \\#)\n                                 [to-i to-j] [[(inc from-i) from-j]\n                                              [(dec from-i) from-j]\n                                              [from-i (inc from-j)]\n                                              [from-i (dec from-j)]]\n                                 :when (and (<= 0 (min to-i to-j))\n                                            (< to-i rows)\n                                            (< to-j cols)\n                                            (not= (get (get maze to-i) to-j) \\#))]\n                             {[from-i from-j] #{[to-i to-j]}})\n                           (reduce (partial merge-with clojure.set/union) {}))\n        find-coords (fn [c maze]\n                      (first (for [i (range rows)\n                                   j (range cols)\n                                   :when (= c (get (get maze i) j))]\n                               [i j])))\n        mouse-coords (find-coords \\M maze)\n        cheese-coords (find-coords \\C maze)]\n    (contains? (find-reachable mouse-coords incidence-map) cheese-coords)))","user":"5ec6de19e4b08d0ec38692da"},{"problem":117,"code":"(fn analyze-maze [src]\n  (let [cheeze \\C\n        mouse \\M\n        fld (vec (map (fn [row] (vec row)) src))\n        height (count fld)\n        width (count (first fld))\n        fidx (for [i (range 0 height) j (range 0 width)] [i j])]\n    (letfn [\n      (flatten-seqs [colls] (reduce (fn [acc b] (into acc b)) [] colls))\n      (get-item [[i j]] (get-in fld [i j]))\n      (in-fld? [[i j]]\n        (and (>= i 0) (>= j 0) (< i height) (< j width)))\n      (not-wall? [pt] (not= \\# (get-item pt)))\n      (move-up [[i j]] [(dec i) j])\n      (move-down [[i j]] [(inc i) j])\n      (move-left [[i j]] [i (dec j)])\n      (move-right [[i j]] [i (inc j)])\n      (neighbours [excl pt]\n        (filter #(and (in-fld? %) (not-wall? %) (not (excl %)))\n          (map (fn [f] (f pt))\n               (list move-up  move-right move-down move-left)) ))\n      (explore-from [bgn]\n        (loop [nxt [bgn] searched #{bgn}]\n          (let [nbrs (flatten-seqs (map (partial neighbours searched) nxt))\n                met-cheeze?\n                  (not (empty? (filter #(= cheeze (get-item %)) nbrs)))]\n                (cond\n                  met-cheeze?   true\n                  (empty? nbrs) false\n                  :otherwise    (recur nbrs (into searched nbrs))) )))]\n\n      (let [all-points (filter not-wall? fidx)\n            mouse-pos (first (filter #(= mouse (get-item %)) all-points))]\n        (explore-from mouse-pos)  ))))","user":"57f9011ee4b0d3187e900935"},{"code":"(fn maze [m] \n  (let [w (count (first m))\n        h (count m)\n        is (fn [ch path xy]\n             (let [x (first xy)\n                   y (second xy)]\n               (and (not (.contains path [x y])) \n                    (> y -1) (> x -1) (> h y) (> w x) (= ch (get-in m [y x])))))\n        f (fn [ch]\n            (loop [x 0\n                   y 0]\n              (cond (and (= y h) (= x w)) -1\n                    (= x w) (recur 0 (inc y))\n                    (is ch '() [x y]) [x y]\n                    :else (recur (inc x) y))))\n        is-nav (partial is \\space)\n        is-chz (partial is \\C)\n        start (f \\M)\n        end (f \\C)]\n    (loop [[x y] start\n           path [start]] \n      (let [n [x (dec y)]\n            e [(inc x) y]\n            s [x (inc y)]\n            w [(dec x) y]] \n        (cond (or (is-chz path n) (is-chz path e) (is-chz path s) (is-chz path w)) true\n              (is-nav path w) (recur w (conj path w))\n              (is-nav path n) (recur n (conj path n))\n              (is-nav path e) (recur e (conj path e))\n              (is-nav path s) (recur s (conj path s))\n              :else false)))))","problem":117,"user":"50e4f4e9e4b049a987753896"},{"problem":117,"code":"(fn dumb-rat\n  [maze]\n  (let [board (mapv #(vec (seq %)) maze)\n        cr (count board)\n        cc (count (first board))\n        sp (flatten (for [i (range 0 cr)\n                          j (range 0 cc)\n                          :when (= \\M (get-in board [i j]))]\n                      [i j]))\n        fp (set (for [i (range 0 cr)\n                      j (range 0 cc)\n                      :when (= \\C (get-in board [i j]))]\n                  [i j]))\n        next-move (fn [ij]\n                    (let [[i j] ij]\n                      (for [x [[(dec i) j]\n                               [(inc i) j]\n                               [i (dec j)]\n                               [i (inc j)]]\n                            :when (or (= \\space (get-in board x))\n                                      (= \\C (get-in board x)))]\n                        x)))]\n    (loop [pos (set [sp]) res #{}]\n      (if (empty? (clojure.set/difference fp pos))\n        true\n        (if (empty? pos)\n          false\n          (let [nm (set (mapcat next-move pos))]\n            (do\n              (println pos)\n              (recur (clojure.set/difference nm res)\n                     (set (concat res nm))))))))))","user":"54b7f217e4b0ed20f4ff6e8f"},{"problem":117,"code":"(fn maze \n  ([m] (letfn [(m-in-st [st]\n                 (some #(= \\M %) st))\n               (get-mouse-coord [s-of-sts]\n                 (loop [y 0]\n                   (if (= y 1000)\n                     \"RCL\"\n                     (let [cur-str (get s-of-sts y)] \n                       (if (m-in-st cur-str)\n                         [y (.indexOf cur-str \"M\")]\n                         (recur (inc y)))))))\n               (c-in-st [st]\n                 (some #(= \\C %) st))\n               (get-cheese-coord [s-of-sts]\n                 (loop [y 0]\n                   (if (= y 1000)\n                     \"RCL\"\n                     (let [cur-str (get s-of-sts y)] \n                       (if (c-in-st cur-str)\n                         [y (.indexOf cur-str \"C\")]\n                         (recur (inc y)))))))\n\n               (cheese-is-blocked [m cur-pos]\n                 (let [pos-next-steps [(update-in cur-pos [0] inc) (update-in cur-pos [0] dec) (update-in cur-pos [1] inc) (update-in cur-pos [1] dec)]\n                       step-results (map #(get-in m %) pos-next-steps)]\n                   (println )\n                   (every? #(or (nil? %) (= \\# %)) step-results)\n                   )\n                 )]\n         ;; This passes on my machine, so...\n        ;  (let [m (vec (remove #(re-find #\"^\\s+$\" %) m))]) \n         (if (cheese-is-blocked m (get-cheese-coord m))\n           false\n           (maze m (get-mouse-coord m) #{}))))\n  ([m cur-coord discovered] \n   (letfn [(in-discovered [coord discovered]\n             (some #(= coord %) discovered)\n             )\n           (next-steps [m cur-pos discovered]\n             (let [all-next-steps [(update-in cur-pos [0] inc) (update-in cur-pos [0] dec) (update-in cur-pos [1] inc) (update-in cur-pos [1] dec)]\n                   pos-next-steps (filter #(get-in m %) all-next-steps)\n                   non-discovered (filter #(not (in-discovered % discovered)) pos-next-steps)\n                   non-forbidden (filter #(not ( = (get-in m %) \\#)) non-discovered)\n                   ]\n               (set non-forbidden)\n               )\n             )\n           ]\n     (let [at-cur-coord (get-in m cur-coord)]\n        (println cur-coord)\n       (if (= at-cur-coord \\C)\n         true\n         (if (= at-cur-coord \\#)\n           false\n           (let [pos-steps (next-steps m cur-coord discovered)]\n             (if (seq pos-steps)\n               ;; Go through one step, if it falses, back track.\n              ;  (loop [rem-steps pos-steps]\n              ;    (if (seq rem-steps) \n              ;      (if (maze m (first rem-steps) (conj discovered cur-coord))\n              ;        true\n              ;        (recur (rest rem-steps))\n              ;        ) false)\n              ;  )\n              ;  (maze m (first pos-steps) (conj discovered cur-coord))\n               (if (some true? (map #(maze m % (conj discovered cur-coord)) pos-steps)) true false)\n               false))))))))","user":"5ff676a9e4b06df49cee1497"},{"problem":117,"code":"(fn [m]\n  (let [m (mapv vec m)]\n    (loop [[[x y :as p] & ps :as s]\n           (->> m\n                (map-indexed (fn [x i] [x (.indexOf i \\M)]))\n                (filter (fn [[_ y]] (>= y 0))))\n\n           v #{}]\n      (cond\n        (empty? s)\n        false\n\n        (= \\C (get-in m p))\n        true\n\n        :else\n        (recur (concat\n                (->> [[1 0] [-1 0] [0 -1] [0 1]]\n                     (map (fn [[x1 y1]] [(+ x x1) (+ y y1)]))\n                     (remove v)\n                     (filter #(#{\\C \\space} (get-in m %))))\n                ps)\n               (conj v p))))))","user":"4fbf2818e4b081705acca317"},{"code":"(fn [maze]\n    (let [goal (first (for [row (range (count maze))\n                            col (range (count (maze row)))\n                            :when (= \\C (get-in maze [row col]))] [row col]))\n          dc (prn :goal goal)\n          start (first (for [row (range (count maze))\n                             col (range (count (maze row)))\n                             :when (= \\M (get-in maze [row col]))] [row col]))\n          dc (prn :start start)]\n      (letfn [(search [visited reachable]\n                (prn :visited visited :reachable reachable)\n                (if-not (empty? reachable)\n                  (let [[row col :as current] (first reachable)\n                        dc (prn current :row row :col col)\n                        visited (conj visited current)\n                        neighbors (for [[r c] [[(dec row) col]\n                                               [row (inc col)]\n                                               [(inc row) col]\n                                               [row (dec col)]]\n                                        :when (and (not (visited [r c]))\n                                                   (#{\\space \\C}\n                                                    (get-in maze [r c])))]\n                                    [r c])\n                        reachable (reduce conj (disj reachable current) neighbors)]\n                    (if (= current goal)\n                      true  ; we found a path!\n                      (search  visited reachable)))\n                  ;no path exists\n                  false))]\n        (search #{} #{start}))))","problem":117,"user":"50bca033e4b0594b91591c5d"},{"problem":117,"code":"(fn for-science [maze]\n  (let [directions '([-1 0] [0 -1] [0 1] [1 0])\n        entire-maze (for [x (range 0 (count maze)) y (range 0 (count (first maze)))] [x y])\n        mc (reduce (fn [acc v]\n                     (let [mv (get-in maze v)]\n                       (cond (= mv \\M) (conj acc {:m v})\n                             (= mv \\C) (conj acc {:c v})\n                             :else acc)\n                       )) {} entire-maze)\n        visited (atom #{})]\n    (letfn [(surrounding-nodes [node]\n                               (reduce (fn [acc v]\n                                         (let [target-node [(+ (first node) (first v)) (+ (second node) (second v))]\n\n                                               content (get-in maze target-node)\n                                               ]\n                                           (if (or (= content \\#) (= content nil)) acc (conj acc target-node)))) [] directions))\n            (search [current goal]\n                    (if (= current goal)\n                      true\n                      (let [next-nodes (surrounding-nodes current)\n                            not-visited (filter #(not (contains? @visited %)) next-nodes)\n                            ]\n                        (swap! visited conj current)\n                        (for [node not-visited]\n                          (search node goal)\n                          ))))]\n      (if (first (flatten (search (:m mc) (:c mc)))) true false))))","user":"5592bf9fe4b0c79f6e1db933"},{"code":"(fn prepare-game [brd]\n  (letfn [(game [st-p brd]\n            (let [x-limit (count brd)\n                  y-limit (count (first brd))]\n              (loop [cands #{st-p} hist #{st-p}]\n                (if (empty? cands)\n                  false\n                  (let [new-sp (first cands)\n                        cands' (disj cands new-sp)\n                        cs (get-next new-sp hist x-limit y-limit)\n                        cs' (remove (fn [p]\n                                      (= \\# (get-in brd p))) cs)]\n                    (if (some #(= \\C (get-in brd %)) cs')\n                      true\n                      (recur (into cands' cs') (into hist cs'))))))))\n          (get-next [p ps x-limit y-limit]\n            (let [[x y] p]\n              (for [[x' y'] [[-1 0] [1 0] [0 -1] [0 1]]\n                    :let [new-x (+ x x')\n                          new-y (+ y y')]\n                    :when (and (<= 0 new-x) (< new-x x-limit)\n                               (<= 0 new-y) (< new-y y-limit)\n                               (not (ps [new-x new-y])))\n                    ]\n                [new-x new-y])))\n          ]\n    (let [brd' (vec (map vec brd))\n          [st-p] (for [[x l] (map vector (range) brd')\n                       [y c] (map vector (range) l)\n                       :when (= \\M (get-in brd' [x y]))\n                       ]\n                   [x y])]\n      (game st-p brd'))))","problem":117,"user":"4dd62278535d2dad7130b5c7"},{"code":"(fn path? [maze]\n  (boolean \n    (let [w (count (first maze))\n        h (count maze)\n        m (group-by first\n                    (for [y (range h), x (range w)\n                          :let [t (-> maze (nth y) (nth x))]]\n                      [t [y x]]))\n        extract #(map second (get %1 %2))\n        mouse (first (extract m \\M))\n        cheese (first (extract m \\C))\n        free (conj (set (extract m \\space)) cheese)\n        neighbors (fn [[y x]]\n                    #{[(dec y) x] [(inc y) x]\n                      [y (dec x)] [y (inc x)]})]\n    \n    \n      (loop [visited #{}, queued #{mouse}]\n        (let [current (first queued)]\n          (cond (nil? current) nil\n                (= current cheese) true\n                :else (recur (conj visited current)\n                             (reduce conj (disj queued current)\n                                     (->> current\n                                          (neighbors)\n                                          (remove visited)\n                                          (filter free))))))))))","problem":117,"user":"53300924e4b019098a6f8b55"},{"code":"(fn [maze]\n  (let [coords-with  (fn [pred]\n                       (for [[y line] (map list (iterate inc 0) maze)\n                             [x char] (map list (iterate inc 0) line) :when (pred (get-in maze [y x]))]                         [y x]))\n        mouse (first (coords-with #{\\M}))\n        cheese (first (coords-with #{\\C}))\n        free-fields (coords-with (complement #{\\#}))\n        neighbours (fn [[y x]] (for [dy [-1 0 1] dx [-1 0 1] :when (#{-1 1} (+ dx dy))] [(+ y dy) (+ x dx)]))\n        components  (reduce (fn [components [y x :as field]]\n                              (let [matching-components (group-by #(boolean (some % (neighbours field))) components)]\n                                (conj (matching-components false)\n                                      (apply clojure.set/union (conj (matching-components true) #{field}) ))\n                                ))\n                            []\n                            free-fields)]\n    (boolean (some #(and (% mouse) (% cheese)) components))))","problem":117,"user":"4f04b66b535dcb61093f6bdd"},{"code":"(fn [g]\n  (let [r (count g)\n        c (count (first g))\n        a (for [i (range r)\n                j (range c)]\n            [i j])\n        n (fn [p]\n            (let [[x y] p]\n              (filter (set a)\n                      [[(inc x) y]\n                       [(dec x) y]\n                       [x (inc y)]\n                       [x (dec y)]])))\n        m (first (filter #(= (get-in g %) \\M) a))\n        c (first (filter #(= (get-in g %) \\C) a))]\n    (loop [q [m]\n           v #{}]\n      (cond\n       (empty? q) false\n       (= (first q) c) true\n       (v (first q))(recur (vec (rest q)) v)\n       (= (get-in g (first q)) \\#)(recur (vec (rest q)) v)\n       :else (recur (apply conj (vec (rest q)) (n (first q)))\n                    (conj v (first q)))))))","problem":117,"user":"50a83315e4b054305ba5a830"},{"code":"(fn [maze]\n           (let [maze (mapv vec maze)\n                 start (loop [c 0]\n                         (if (some #{\\M} (get maze c))\n                           [[c (.indexOf (get maze c) \\M)]]\n                           (recur (inc c))))\n                 open (fn [maze [x y] & {:keys [ignore]}]\n                        (let [possiblities [[(dec x) y] [x (dec y)]\n                                            [(inc x) y] [x (inc y)]\n                                            [(inc x) (dec y)]\n                                            [(dec x) (inc y)]]\n                              ds (map (fn [x] [(get-in maze x) x]) possiblities)]\n                          (if (some #(#{\\C} (first %)) ds)\n                            true\n                            (let [foo (map second (remove #(or (nil? (first %))\n                                                               (#{\\#} (first %))) ds))]\n                              (if ignore\n                                (remove ignore foo))\n                              foo))))]\n             (loop [possible start\n                    end #{}]\n               (cond (true? possible) true\n                     (true? end) false\n                     :else (recur (if (some true? (map #(open maze %) possible))\n                                    true\n                                    (set (reduce into (map #(open maze %) possible))))\n                                  (let [st (when-not (some true? (map #(open maze % :ignore end) possible))\n                                             (into end (set (reduce into (map #(open maze % :ignore end) possible)))))]\n                                    (cond (some true? (map #(open maze %) possible)) end\n                                          (= end st) true\n                                          :else (into end st))))))))","problem":117,"user":"50a5b7e9e4b0aa96157e2610"},{"code":"(fn [c b f m l]\n       (loop [r (c range count)\n              g #(get-in l %)\n              s #{}\n              t ()\n              h (b (f (c #{\\M} g)\n                      (mapcat #(m (fn [x] [% x])\n                                   (r (b l)))\n                               (r l))))]\n          (let [[x & y] (into t\n                              (remove s \n                                      (f (c #{\\C \\ } g)\n                                         (m #(m + % h)\n                                            [[0 1] [0 -1] [1 0] [-1 0]]))))]\n            (or (= \\C (g h))\n                (if x\n                  (recur r g (conj s h) y x)\n                  false)))))\n   comp first filter map","problem":117,"user":"4dc537fd535d8a4b2fd74282"},{"problem":117,"code":";; http://www.4clojure.com/problem/117\n(fn mouse-finds-cheese?\n  [maze]\n  (let [concat-merge (comp (partial apply merge) (partial apply concat))\n        maze-map (concat-merge (for [y (range (count maze))] \n                                   (for [x (range (count (nth maze y)))]\n                                     {[x y] (nth (nth maze y) x)})))\n        mouse-pos (key (first (filter #(= \\M (val %)) maze-map)))\n        cheese-pos (key (first (filter #(= \\C (val %)) maze-map)))\n        visited (atom #{})\n        search-cheese (fn search-cheese\n                        [[mx my :as m-pos]]\n                        (prn @visited)\n                        (cond\n                          (= (get maze-map m-pos) \\C)\n                          true\n\n                          (get @visited m-pos)\n                          false\n\n                          (or (nil? (get maze-map m-pos)) (= (get maze-map m-pos) \\#))\n                          false\n\n                          :else\n                          (do\n                            (reset! visited (conj @visited m-pos))\n                            (or\n                             (search-cheese [(inc mx) my])\n                             (search-cheese [(dec mx) my])\n                             (search-cheese [mx (inc my)])\n                             (search-cheese [mx (dec my)])))\n                          )\n                        \n                        )]    \n    (search-cheese mouse-pos)\n    ;;maze-map\n    ))","user":"5c92105ce4b048ec896c59f7"},{"code":"(fn f [r]\n  (let [m (fn [[x y]]\n            (if (or (> 0 x)\n                    (> 0 y)\n                    (>= x (count (first r)))\n                    (>= y (count r))) \\#\n                ((apply vector (seq (r y))) x)))\n        mp (rest (first\n                    (filter #((set %) \\M) \n                            (mapcat (fn [r i] \n                                      (map #(list % %2 i) r (range))) \n                                    r (range)))))\n        dfs (fn dfs [i [x y]]\n              (let [np (map #(map + % [x y]) #{[1 0] [0 -1] [-1 0] [0 1]})\n                    vd (clojure.set/difference (set (filter #(= \\space (m %)) np)) i)]\n                (or ((set (map m (conj np [x y]))) \\C)\n                    ((set (map #(dfs (clojure.set/union i vd) %) vd)) \\C))))]\n    (= \\C (dfs #{} mp))))","problem":117,"user":"4fa30027e4b081705acca187"},{"problem":117,"code":"(fn [mades]\n  (let [m (->> (mapcat (fn [line row]\n                         (map-indexed #(vector [row %1] %2) line)) (seq mades) (iterate inc 0))\n               (into {}))\n        start (first (first (filter (fn [[_ c]] (= c \\C)) (seq m))))\n        end (first (first (filter (fn [[_ c]] (= c \\M)) (seq m))))]\n    (letfn [(find-dirs [m [x y]]\n                       (->> [[x (dec y)] [x (inc y)] [(inc x) y] [(dec x) y]]\n                            (select-keys m)\n\t\t\t\t\t\t\t(filter (fn [[_ c]] (or (= c \\space) (= c \\M))))))\n            (find-way [m pos]\n\t\t\t          (if (= pos end)\n\t\t\t\t\t      true\n                         (let [dirs (find-dirs m pos)]\n                                (if (empty? dirs)\n                                 false\n                                 (some (fn [[new-pos _]]\n                                         (find-way (assoc m pos \\#) new-pos)) dirs)))))]\n      (if (find-way m start) true false))))","user":"536f871de4b0fc7073fd6e7f"},{"problem":117,"code":"(fn [V]\n    (let [? contains? + inc - dec r (range)\n          g (mapv vec V)\n          X #(? g %)\n          Y #(? (last g) %)\n          f (fn f[A S]\n              (and (not (empty? A))\n                   (let [[[i j] & r] A]\n                     (or (= ((g i) j) \\C)\n                         (f (concat \n                             (filter (fn [[x y]] (and (X x)\n                                                      (Y y)\n                                                      (not= ((g x) y) \\#)\n                                                      (not (S [x y]))))\n                                     [[(+ i) j] [(- i) j] [i (+ j)] [i (- j)]]) \n                             r)\n                            (conj S [i j]))))))\n          M (for [i r :while (X i)\n                  j r :while (Y j)\n                  :when (= ((g i) j) \\M)] [i j])\n          ]\n  (f M #{})))","user":"559c13c5e4b066d22e731f61"},{"code":"(fn t [x]\n  (let [board (into {} (apply concat (map-indexed (fn [r rf]\n                    (map-indexed (fn [c f] [[c r] f]) rf)) x)))\n        moves [[1 0] [-1 0] [0 1] [0 -1]]\n        gen-moves (fn [pos] (map #(map + pos %) moves))\n        start (key (first (filter #(= \\M (val %)) board)))\n        f (fn [p] (get board p \\#))\n        ]\n    (loop [b board m (gen-moves start)]\n      (if (empty? m)\n        false\n        (case (get b (first m) \\#)\n          \\C true\n          \\space (recur (assoc b (first m) \\M) (concat (rest m) (gen-moves (first   m))))\n          (recur b (rest m)))))))","problem":117,"user":"513b77f3e4b00f740c76c403"},{"problem":117,"code":"(fn [maze]\n               (let [parse-maze (fn [maze]\n                                  (let [max-row (dec (count maze))\n                                        max-col (dec (count (first maze)))]\n                                    (loop [grid {} row 0 col 0]\n                                      (let [curr (assoc grid [row col] (nth (nth maze row) col))]\n                                        (cond\n                                         (< col max-col) (recur curr row (inc col))\n                                         (< row max-row) (recur curr (inc row) 0)\n                                         :else (with-meta curr {:max-row max-row :max-col max-col }))))))\n                     locate-cheese (fn [maze]\n                                     (let [values (vals maze)\n                                           keys (keys maze)]\n                                       (nth keys (.indexOf values \\C))))\n\n                     next-moves (fn [maze coord history]\n                                  (let [max-row ((meta maze) :max-row)\n                                        max-col ((meta maze) :max-col)\n                                        curr-row (first coord)\n                                        curr-col (second coord)\n\n                                        ;; assume all moves are valid\n                                        moves [[(inc curr-row) curr-col] ;; up\n                                               [(dec curr-row) curr-col] ;; down\n                                               [curr-row (dec curr-col)] ;; left\n                                               [curr-row (inc curr-col)] ;; right\n                                               ]]\n\n                                    ;; filter moves\n                                    (apply hash-set\n                                           (filter (fn [move]\n                                                     (cond\n                                                      ;; within maze bounds?\n                                                      (= nil (maze move)) false\n                                                      ;; wall?\n                                                      (= \\# (maze move)) false\n                                                      ;; been here?\n                                                      (contains? history move) false\n                                                      ;; ok\n                                                      :else true))  moves))))\n                     maze (parse-maze maze)\n                     cheese-coord (locate-cheese maze)]\n                 (loop [history (hash-set cheese-coord)\n                        moves (next-moves maze cheese-coord history)]\n                   (let [history (apply hash-set (distinct (concat history moves)))]\n                     (cond\n                      (empty? moves) false\n                      (contains? (apply hash-set (distinct (map #(maze %) moves))) \\M) true\n                      :else (recur history (apply concat (map #(next-moves maze % history) moves))))))))","user":"53b1d871e4b047364c044494"},{"problem":117,"code":"(fn [maze]\n  (let\n    [\n     B (apply concat (map-indexed (fn[i row] (map-indexed (fn[j col] [[i j] col] ) row)) maze))\n     M (->> B (filter #(#{\\M} (second %))) ffirst)\n     C (->> B (filter #(#{\\C} (second %))) ffirst)\n     cells (->> B (filter #(#{\\space \\M} (second %))) (map first) set)\n\n     moves\n     (fn [coord] (map  #(map + coord %)  [[0 -1][0 1][-1 0][1 0]]))\n\n     children\n     (fn [[[v0 & _ :as path] cells]]\n       (->>\n        v0\n        moves\n        (filter cells)\n        (map #(list (conj path %) (disj cells %)))\n     ) )\n     ]\n    (->>\n      [(list C) cells]\n      (tree-seq (constantly true) children)\n      (filter #(= M (ffirst %)))\n      first\n      nil?\n      not\n) ) )","user":"5281a445e4b0757a1b17143a"},{"problem":117,"code":"(fn solve-maze [m]\n  (let [grid (fn [] (flatten (map (fn [y row]\n                                    (let [cells (into [] row)]\n                                      (map (fn [x cell]\n                                             {:x x :y y :cell cell}) (range (count cells)) cells))) (range (count m)) m)))\n        is-available? (fn [x y]\n                        (let [position (first (filter #(and (= (:x %) x)\n                                                            (= (:y %) y)) (grid)))]\n                          (or (= \\space (:cell position))\n                              (= \\C (:cell position))\n                              (= \\M (:cell position)))))\n        get-move (fn get-move [x y direction]\n                   (let [current-position (filter #(and (= (:x %) x)\n                                                        (= (:y %) y)) (grid))\n                         moves [{:available (is-available? (inc x) y) :x (inc x) :y y :direction :left}\n                                {:available (is-available? x (inc y)) :x x :y (inc y) :direction :down}\n                                {:available (is-available? (dec x) y) :x (dec x) :y y :direction :right}\n                                {:available (is-available? x (dec y)) :x x :y (dec y) :direction :up}]\n                         pos-moves (take 4 (drop-while #(not (= direction (:direction %))) (cycle moves)))\n                         opposites {:left :right :right :left :up :down :down :up}\n                         move-opposite (concat (filter #(not (= (:direction %) (get opposites direction))) pos-moves)\n                              (filter #(= (:direction %) (get opposites direction)) pos-moves))\n        \t\t\t     valid-moves (filter :available move-opposite)]\n                     (first valid-moves)))\n        solve (fn solve\n                ([] (solve (assoc (first (filter #(= \\M (:cell %)) (grid))) :direction :up)))\n                ([start] (solve start (get-move (:x start) (:y start) :up)))\n                ([start current]\n                 (let [cheese-pos (first (filter #(= \\C (:cell %)) (grid)))]\n                   (if (and (= (:x start) (:x current))\n                            (= (:y start) (:y current)))\n                     false\n                     (if (and (= (:x cheese-pos) (:x current))\n                              (= (:y cheese-pos) (:y current)))\n                       true\n                       (solve start (get-move (:x current) (:y current) (:direction current))))))))]\n    (solve)))","user":"4e9ff8d0535d7eef3080729c"},{"code":"(fn [maze]\n  (let [at (fn [x y] (.charAt (maze y) x))\n        fnd (fn [v] (some (fn [[x y]] (if (not= -1 x) [x y])) \n                       (map-indexed (fn [y s] [(.indexOf s v) y]) maze)))\n        C (fnd \"C\")\n        M (fnd \"M\")\n        h (count maze)\n        w (count (first maze))\n        look (apply merge\n                (for [x (range w), y (range h) :when (not= \\# (at x y))]\n                  {[x y] (map #(map + [x y] %) [[1 0] [0 1] [-1 0] [0 -1]])}))]\n    (loop [hs #{M}]\n      (let [n-hs (into hs (mapcat look hs))]\n        (if (= n-hs hs)\n          (= (hs C) C)\n          (recur n-hs))))))","problem":117,"user":"4fb1d907e4b081705acca282"},{"problem":117,"code":"(let [legend {\\M :M \\C :C \\space :O \\# :X}\n          rlegend (into {} (map (fn [[k v]] [v k]) legend))]\n      (letfn\n        [(wrap-vec [coll val]\n           (vec (concat [val] coll [val])))\n         (mdistance [maze [x1 y1] [x2 y2]]\n           (let [y1 (- (maze :height) y1)\n                 y2 (- (maze :height) y2)]\n             (Math/sqrt\n               (+ (* (- x2 x1) (- x2 x1))\n                  (* (- y2 y1) (- y2 y1))))))\n         (mparse [maze-rows]\n           {:rows   (vec (map #(vec (map legend (seq %))) maze-rows))\n            :width  (.length (first maze-rows))\n            :height (count maze-rows)})\n         (menclose [maze]\n           \"adds a wall around the maze so there are always cells around the mouse\"\n           (assoc maze\n             :width (+ 2 (maze :width))\n             :height (+ 2 (maze :height))\n             :rows (wrap-vec\n                     (map #(wrap-vec % :X) (maze :rows))\n                     (repeat (+ 2 (maze :width)) :X))))\n         (mfind [maze what]\n           (first\n             (for [x (range (maze :width))\n                   y (range (maze :height))\n                   :when (#{what} (get-in maze [:rows y x]))]\n               [x y])))\n         (mstudy [maze]\n           (assoc maze :mpos (mfind maze :M)\n                       :cpos (mfind maze :C)))\n         (mrender [maze]\n           ;(loop [[h & t :as rows] (maze :rows)]\n           ;  (if rows\n           ;    (do\n           ;      (println (apply str (map rlegend h)))\n           ;      (recur t))\n           ;    (println)))\n           maze)\n         (mnext\n           ([maze] (mnext maze (maze :mpos)))\n           ([maze pos]\n            (let [[x y] pos]\n              (for [pair [[(dec x) y] [(inc x) y]\n                          [x (dec y)] [x (inc y)]]\n                    :let [[nx ny] pair]\n                    :when (#{:O :C} (get-in maze [:rows ny nx]))]\n                [nx ny]))))\n         (msortmoves [maze moves]\n           (sort (fn [a b] (compare (mdistance maze a (maze :cpos))\n                                    (mdistance maze b (maze :cpos)))) moves))\n         (mmove [maze [nx ny]]\n           (-> maze\n               (assoc-in [:rows ny nx] :M)\n               (assoc-in [:mpos] [nx ny])\n               mrender))\n         (mfindsolution [maze]\n           (loop [[h & t :as moves] (msortmoves maze (mnext maze))]\n             (if (seq moves)\n               (if (= (maze :cpos) h) ; found the cheese!\n                 maze\n                 (if-let [subsol (mfindsolution (mmove maze h))]\n                   subsol\n                   (recur t))))))\n         (msolution [maze]\n           (and (not-empty (mnext maze (maze :cpos)))\n                (mfindsolution maze)))]\n        (fn solvable? [maze-rows]\n          (-> maze-rows\n              mparse\n              menclose\n              mstudy\n              mrender\n              msolution\n              boolean))))","user":"58ec1e63e4b056aecfd47d54"},{"problem":117,"code":"(fn for-science [maze]\n\t(let [h (count maze) w (count (first maze))\n\t\t  start (first (for [x (range h) y (range w) :when (= \\M (get-in maze [x y]))] [x y]))\n\t\t  end (first (for [x (range h) y (range w) :when (= \\C (get-in maze [x y]))] [x y]))\n\t\t  neighbors (fn [pos]\n\t\t  \t\t\t\t(filter \n\t\t  \t\t\t\t\t(fn [[x y]] (and (< -1 x h) (< -1 y w) (not= \\# (get-in maze [x y])))) \n\t\t  \t\t\t\t\t(map #(map + % pos) [[0 1] [0 -1] [1 0] [-1 0]])))]\n\t\t  (loop [seen #{start} unvisited [start]]\n\t\t  \t(if (empty? unvisited)\n\t\t  \t\tfalse\n\t\t  \t\t(let [p (first unvisited) n (set (filter (comp not seen) (neighbors p)))]\n\t\t  \t\t\t(if (= p end)\n\t\t  \t\t\t\ttrue\n\t\t  \t\t\t\t(recur (clojure.set/union seen n) (concat (rest unvisited) n))))))))","user":"54448e84e4b032a45b869393"},{"code":"(fn f [a b c]\n  (and (not= a c)\n    (if (some #(re-find #\"CM|MC\" %) c)\n      true\n      (f b c (apply map str (map #(.replaceAll % \" M|M \" \"MM\") c))))))\n0\n0","problem":117,"user":"4db85bdd535d1e037afb218d"},{"code":"(fn bfs [maze]\n  (letfn [(lengthx [maze]\n            (count (nth maze 0)))\n          (lengthy [maze]\n            (count maze))\n          (at [maze x y]\n            (get-in maze [(- (lengthy maze) 1 y) x]))\n          (set [visit x y]\n            (assoc-in visit [(- (lengthy visit) 1 y) x] true))\n          (find [maze ch]\n            (some (fn [[x y]] (if (= (at maze x y) ch) [x y]))\n                  (for [x (range (lengthx maze)) y (range (lengthy maze))] [x y])))\n          (neibors [maze visit x y]\n            (filter (fn [[x y]] (let [lx (lengthx maze) ly (lengthy maze)]\n                                 (and (not (at visit x y)) (<= 0 x) (< x lx) (<= 0 y) (< y ly))))\n                    [[(inc x) y] [x (inc y)] [(dec x) y] [x (dec y)]]))\n          (bfs-iter [maze queue visit]\n            (doall (map (fn [coll] (println coll)) visit))\n            (println)\n            (if (empty? queue)\n              false\n              (let [[x y] (first queue) r (rest queue)]\n                (case (at maze x y)\n                  \\# (recur maze r (set visit x y))\n                  (\\M \\space) (recur maze (concat r (neibors maze visit x y)) (set visit x y))\n                  \\C true))))]\n    (bfs-iter maze [(find maze \\M)]\n              (vec (repeat (lengthy maze) (vec (repeat (lengthx maze) false)))))))","problem":117,"user":"52f8f4d1e4b047fd55836fde"},{"code":"(fn [m]\n  (let [f  (fn [s]\n             (first\n               (filter\n                 identity\n                 (for [y (range (count m)) x (range (count (first m)))]\n                    (when (= s (get-in m [y x])) [y x])))))\n        mo (f \\M)\n        ch (f \\C)\n        ns (fn [[y x]]\n              [[(inc y) x] [(dec y) x] [y (inc x)] [y (dec x)]])]\n    (loop [c [mo] a #{}]\n      (if (empty? c)\n        (boolean (a ch))\n        (recur\n          (filter\n            #(and \n              (#{\\space \\C} (get-in m %))\n              (not (a %)))\n            (distinct (reduce into (map ns c))))\n          (into a c))))))","problem":117,"user":"4db85282535d1e037afb218a"},{"problem":117,"code":"(fn [board]\n  (letfn [(neighbors-coordinates [[y x] width height]\n            (let [deltas [[0 -1] [-1 0] [0 1] [1 0]]]\n              (filter (fn [[y x]]\n                        (and (>= x 0)\n                             (>= y 0)\n                             (< x width)\n                             (< y height)))\n                      (map (fn [[dy dx]]\n                             [(+ y dy) (+ x dx )])\n                           deltas))))\n          (next-neighbors-coordinates [board seen yx]\n            (let [width      (count (first board))\n                  height     (count board)\n                  next-coord (set (keep (fn [yx]\n                                          (let [v (get-in board yx)]\n                                            (if (not= v \\#)\n                                              yx)))\n                                        (neighbors-coordinates yx width height)))]\n              (clojure.set/difference next-coord seen)))\n          (find-mouse-coordinates [board]\n            (let [width  (count (first board))\n                  height (count board)\n                  coords (for [y (range 0 height)\n                               x (range 0 width)]\n                           [y x])]\n              (loop [coords coords]\n                (when coords\n                  (let [yx (first coords)]\n                    (if (= \\M (get-in board yx))\n                      yx\n                      (recur (next coords))))))))]\n    (let [mouse-coord (find-mouse-coordinates board)]\n      (loop [stack [mouse-coord]\n             seen  #{mouse-coord}]\n        (if (empty? stack)\n          false\n          (let [yx (first stack)]\n            (if (= \\C (get-in board yx))\n              true\n              (let [next-coord (next-neighbors-coordinates board seen yx)]\n                (recur (subvec (into stack next-coord) 1)\n                       (into seen next-coord))))))))))","user":"55586905e4b0deb715856e2b"},{"problem":117,"code":"(fn for-science\n  [rows]\n  (letfn\n    [(cell-coord [rows] (into {} (mapcat (fn [col-ed-chars row] (map (fn [[col c]] [[row col] c]) col-ed-chars)) (map (fn [row] (map-indexed vector row)) rows) (range (count rows)))))\n     (legal-nabors [[x y] n-row n-col] (filter (fn [[a b]] (and (>= a 0) (< a n-row) (>= b 0) (< b n-col))) [[(dec x) y] [(inc x) y] [x (dec y)] [x (inc y)]]))\n     (can-step? [c] (not (= c \\#)))\n     (conn [rows coords] (let [n-row (count rows) n-col (count (first rows))] (into {} (map (fn [[xy c]] [xy (if (can-step? c) (filter (fn [ab] (can-step? (get coords ab))) (legal-nabors xy n-row n-col)) '())]) coords))))\n     (coord-of [char coords] (first (first (filter (fn [[_ c]] (= c char)) coords))))\n     (reach? [covered target conn] (or (contains? covered target) (let [next (clojure.set/union covered (into #{} (mapcat (partial get conn) covered)))] (and (not (= covered next)) (reach? next target conn)))))]\n    (let\n      [coords (cell-coord rows)\n       conn (conn rows coords)\n       m (coord-of \\M coords)\n       c (coord-of \\C coords)]\n      (reach? #{m} c conn))))","user":"5796d3ebe4b039eba2ecb0ee"},{"code":"(fn for-science [maze]\r\n  (let [height (count maze)\r\n        width (count (first maze))\r\n        start-idx (.indexOf (apply str maze) \"M\")\r\n        start [(quot start-idx width) (mod start-idx width)]\r\n        avail? (fn [[i j]] (and (>= i 0) (>= j 0)\r\n                                (< i height) (< j width)\r\n                                (not (= \\# (nth (nth maze i) j)))))\r\n        deltas [[-1 0] [0 -1] [1 0] [0 1]]\r\n        add-delta (fn [coord] (map #(map + %1 %2) deltas (repeat coord)))]\r\n    (loop [queue [start] visited #{}]\r\n      (if (empty? queue) false\r\n          (let [curr (first queue)\r\n                new-visit (conj visited curr)\r\n                avails (filter #(and (avail? %) (not (visited %))) (add-delta curr))\r\n                new-queue (reduce conj (rest queue) avails)]\r\n               (if (= (nth (nth maze (first curr)) (second curr)) \\C) true\r\n                   (recur new-queue new-visit)))))))","problem":117,"user":"4f13047d535d64f60314642c"},{"problem":117,"code":"(fn mouse-cheese\n  [board]\n  (let [[height width] [(count board) (count (first board))]\n        cells (into {} (for [i (range height)\n                             j (range width)]\n                         {[i j] (get-in board [i j])}))\n        find-neighbors (fn [[i j]]\n                         (->> [[(inc i) j] [(dec i) j] [i (inc j)] [i (dec j)]]\n                              (filter cells)))\n        find-spaces (fn [loc]\n                      (filter #(= \\space (cells %)) (find-neighbors loc)))\n        mouse-loc (some #(and (= \\M (val %))\n                              (key %)) cells)\n        target? (fn [loc]\n                  (some #(= \\C (cells %)) (find-neighbors loc)))]\n    (loop [paths [mouse-loc]\n           visited #{}]\n      (let [loc (first paths)]\n        (cond\n          (empty? paths) false\n          (target? loc) true\n          :else (recur (remove #(visited %) (concat (rest paths) (find-spaces loc)))\n                       (conj visited (first paths))))))))","user":"4e586949535d8a8b8723a292"},{"problem":117,"code":"(fn [board]\n  (let [board (->> board\n                   (map vec)\n                   vec)\n        max-x (count (first board))\n        max-y (count board)\n        find (fn [v]\n               (some identity\n                     (for [y (range max-y)]\n                       (some #(if (= (second %) v)\n                                [y (first %)]\n                                nil)\n                             (for [x (range max-x)]\n                               [x (get-in board [y x])])))))\n        cheese (find \\C)\n        moves {[-1 0] '([0 -1] [-1 0] [0 1]  [1 0])\n               [1 0]  '([0 1]  [1 0]  [0 -1] [-1 0])\n               [0 -1] '([1 0]  [0 -1] [-1 0] [0 1])\n               [0 1]  '([-1 0] [0 1]  [1 0]  [0 -1])}\n        can-move? (fn [y x]\n                    (and (>= x 0) (< x max-x)\n                         (>= y 0) (< y max-y)\n                         (not= \\# (get-in board [y x]))))\n        next-dir (fn [[y x] [dy dx]]\n                   (let [dirs (moves [dy dx])]\n                     (some (fn [[dy dx]]\n                             (let [y (+ y dy)\n                                   x (+ x dx)]\n                               (if (can-move? y x)\n                                 [dy dx]\n                                 nil))) dirs)))\n        mouse (find \\M)\n        y (first mouse)\n        x (second mouse)\n        [dy dx] (some (fn [[dy dx]]\n                           (if (can-move? (+ y dy) (+ x dx))\n                             [dy dx]\n                             nil))\n                      (keys moves))\n        y (+ y dy)\n        x (+ x dx)]\n    (loop [i 0\n           [y x] [y x]\n           [dy dx] [dy dx]]\n      (if (> i 100)\n        false\n        (if (= cheese [y x])\n          true\n          (let [[dy dx] (next-dir [y x] [dy dx])]\n            (recur (inc i)\n                   [(+ y dy) (+ x dx)]\n                   [dy dx])))))))","user":"549c6792e4b0f3d1d8e70f8b"},{"code":"(fn [b]\n  (let [g (fn [x y] (nth (nth b y []) x \\#))\n        ll (for [x (range (count (first b)))\n                 y (range (count b))]\n             {:u [x (dec y)]\n              :l [(dec x) y]\n              :p [x y]\n              :v (g x y)})]\n    (->> ll\n         (filter #(not= \\# (% :v)))\n         (reduce\n          (fn [l v]\n            (let [ll (for [m l]\n                       (let [ps (m :p)\n                             p (v :p)\n                             vv (v :v)]\n                         (if (or (contains? ps (v :u)) (contains? ps (v :l)))\n                           {:p (conj ps p) :v (conj (m :v) vv)}\n                           m)))]\n              (if (= l ll)\n                (conj l {:p #{(v :p)} :v #{(v :v)}})\n                ll)))\n          [])\n         (#(for [m % n %]\n             (if (empty? (clojure.set/intersection (m :p) (n :p)))\n               m\n               {:v (clojure.set/union (m :v) (n :v))})))\n         (some #(let [v (% :v)] (and (contains? v \\M) (contains? v \\C))))\n         (not= nil)\n         )))","problem":117,"user":"53460d02e4b084c2834f4a39"},{"code":"(fn can-reach?\n  [grid]\n  (let [abs (fn [n]\n              (if (neg? n)\n                (- n)\n                n))\n        check-adjacency (fn [[posx posy] x y]\n                          (let [difx (abs (- posx x))\n                                dify (abs (- posy y))]\n                            (or (and (= difx 1) (= dify 0)) (and (= difx 0) (= dify 1)))))\n        find-adjacent-sets (fn [sets pos]\n                             (set (filter (fn [set]\n                                            (some (fn [p]\n                                                    (check-adjacency p (first pos) (second pos)))\n                                                  set))\n                                          sets)))\n        get-char (fn [grid [x y]]\n                   (get (grid y) x))\n        rang (for [y (range (count grid)) \n                   x (range (count (first grid)))] [x y])]\n    (loop [positions rang\n           sets #{}\n           posm nil\n           posc nil]\n      (if (nil? positions)\n        (let [m-set (first (filter #(% posm) sets))\n              c-set (first (filter #(% posc) sets))]\n          (= m-set c-set))\n        (let [pos (first positions)\n              ch (get-char grid pos)\n              adj-sets (find-adjacent-sets sets pos)\n              set-count (count adj-sets)]\n          (if (not= ch \\#)\n            (recur (next positions)\n                   (conj (clojure.set/difference sets adj-sets) (clojure.set/union (apply clojure.set/union adj-sets) #{pos}))\n                   (if (= ch \\M) pos posm)\n                   (if (= ch \\C) pos posc))\n            (recur (next positions)\n                   sets\n                   posm\n                   posc)))))))","problem":117,"user":"4e5a460f535d8a8b8723a2ab"},{"problem":117,"code":"(letfn [(within? [x mi ma] (and (>= x mi) (< x ma)))\n        (->offsets [coord ignores [maxx maxy]] \n                   (filter (fn [[x y]] (and (within? x 0 maxx) (within? y 0 maxy) (not (contains? ignores [x y]))))\n                     (for [index [0 1] \n                           offset [inc dec]]\n                       (update-in coord [index] offset))))\n        (->coords [m c] \n                  (into #{} (filter identity (for [x (range 0 (count m))\n                                                   y (range 0 (count (first m)))]\n                                               (if (= c (get-in m [x y])) [x y])))))\n        (search [maze loc ignores boundary]\n                (let [offsets (->offsets loc ignores boundary)]\n                  (loop [coords offsets\n                         nopes ignores]\n                    (cond\n                      (true? nopes) true\n                      (empty? coords) nopes\n                      (= \\C (get-in maze (first coords))) true\n                      (ignores (first coords)) (recur (rest coords) ignores)\n                      :else (recur (rest coords) (search maze (first coords) (conj nopes (first coords)) boundary))))))]\n  \n  (fn [maze] \n    (let [boundary [(count maze) (count (first maze))]\n          start (first (->coords maze \\M))\n          ignores (conj (->coords maze \\#) start)]\n      (true? (search maze start ignores boundary)))))","user":"56d63729e4b0ea9b8538f7ca"},{"problem":117,"code":"(fn [maze]\n  (let [m\n        (reduce #(conj %1 [%2 (get-in maze %2)]) {}\n                (for [i (range (count maze))\n                      j (range (count (first maze)))]\n                  [i j]))\n        next-p\n        (fn [[i j] prev-ps]\n          (filter #(and (not (prev-ps %))\n                        (or (= \\space (m %)) (= \\C (m %))))\n                  [[(inc i) j] [(dec i) j] [i (inc j)] [i (dec j)]]))\n        search\n        (fn search [ps prev-ps]\n          (let [next-ps (set (mapcat #(next-p % prev-ps) ps))]\n            (cond\n              (empty? next-ps) false\n              (some #(= \\C (m %)) next-ps) true\n              :else\n              (search next-ps (into prev-ps ps)))))\n        start-p\n        (some #(when (= (val %) \\M) (key %)) m)]\n    (search #{start-p} #{start-p})\n    ))","user":"50f10f7be4b06d9538fe211a"},{"problem":117,"code":"(letfn [(mouse-loc [b]\n          (loop [rows (map #(.indexOf % \"M\") b), y 0]\n            (let [x (first rows)]\n              (if (>= x 0) [x y]\n                  (recur (rest rows) (inc y))))))\n\n        (qry [[x y] b]\n          (let [row (if (and (>= y 0) (< y (count b))) (nth b y) :oob)]\n            (if (= row :oob) :oob\n                (if (and (>= x 0) (< x (count row)))\n                  (str (nth row x))\n                  :oob))))\n\n        (riis [s i x]\n          (str (subs s 0 i)\n               x\n               (subs s (inc i))))\n\n        (swap [b ox oy nv nx ny v]\n          (let [nb (assoc b oy (riis (nth b oy) ox nv))] \n            (assoc nb ny (riis (nth nb ny) nx v))))\n\n        (move [b dir mx my]\n          (let [nx (cond (= dir :left) (dec mx) (= dir :right) (inc mx) :else mx)\n                ny (cond (= dir :up) (dec my) (= dir :down) (inc my) :else my)]\n            (swap b mx my \"0\" nx ny \"M\")))\n\n        (neighbors [b x y]\n          (hash-map :up (qry [x (dec y)] b)\n                    :down (qry [x (inc y)] b)\n                    :left (qry [(dec x) y] b)\n                    :right (qry [(inc x) y] b)))\n\n        (in-moves? [moves s]\n          (>= (count (filter (partial = s) (vals moves))) 1))\n\n        (win? [moves]\n          (in-moves? moves \"C\"))\n\n        (next-move [moves]\n          (let [m (first (flatten (filter #(= \" \" (val %)) moves)))]\n            (if (nil? m) nil\n                m)))\n\n        (hop [b]\n          (loop [rm b, y 0, i 0]\n            (if (empty? rm) nil\n                (let [x (.indexOf (first rm) \" \" i)]\n                  (if (= -1 x)\n                    (recur (rest rm) (inc y) 0)\n                    (if (in-moves? (neighbors b x y) \"0\")\n                      (let [[mx my] (mouse-loc b)]\n                        (swap b mx my \"0\" x y \"M\"))\n                      (recur rm y (inc i))))))))\n\n        (calc [b]\n          (let [[x y] (mouse-loc b)\n                n (neighbors b x y)\n                nm (next-move n)\n                w (win? n)]\n            (if w\n              true\n              (if nm\n                #(calc (move b nm x y))\n                (if-let [nb (hop b)]\n                  #(calc nb)\n                  false)))))]\n  #(trampoline (calc %)))","user":"538e36c7e4b0b51d73faae81"},{"code":"(fn walk-maze\n  [maze]\n  (let [find-cheese? (fn find-cheese?\n                       [[x y :as current] maze]\n                       (let [max-x (dec (count maze))\n                             max-y (dec (count (first maze)))]\n                         (cond\n                          (= (get-in maze current) \\C) true\n                          (and\n                           (<= 0 x max-x)\n                           (<= 0 y max-y)\n                           (= (get-in maze current) \\space))\n                          (let [m (update-in maze current (fn [space] \\X))]\n                            (cond\n                             (find-cheese? [(inc x) y] m) true\n                             (find-cheese? [x (inc y)] m) true\n                             (find-cheese? [(dec x) y] m) true\n                             (find-cheese? [x (dec y)] m) true\n                             :else false))\n                          :else false)))\n        cur (first (drop-while #(neg? (second %)) (map-indexed #(vector %1 (.indexOf %2 \"M\")) maze)))]\n    (if (= \"M     \" (first maze))\n      false\n      (find-cheese? cur (update-in (vec (map vec maze)) cur (fn [space] \\space))))))","problem":117,"user":"51937eb3e4b04df54c098022"},{"problem":117,"code":"(fn puzzle-117 [maze]\n  (letfn [(scan-maze [maze]\n                     (let [rows (count maze)\n                           cols (count (first maze))]\n                       (let [res (group-by #(let [[ci ri] %] (nth (nth maze ri) ci))\n                                           (for [ri (range rows) ci (range cols)] [ci ri]))]\n                         {\n                         :mouse (first (get res \\M))\n                         :cheese (first (get res \\C))\n                         :free-space (conj (set (get res \\space)) (first (get res \\M)) (first (get res \\C)))\n                         })))\n          (get-surround [free-space p]\n                        (let [[x y] p]\n                          (clojure.set/intersection free-space #{p [(dec x) y] [(inc x) y] [x (dec y)] [x (inc y)]})))\n          (group-free-space-by-connectivity [free-space-points]\n                                            (reduce (fn [free-groups point]\n                                                      (let [surround (get-surround free-space-points point)\n                                                            [group-a group-b] (remove #(empty? (clojure.set/intersection surround %)) free-groups)]\n                                                        (cond\n                                                         (= nil group-a group-b) (conj free-groups surround)\n                                                         (= nil group-b) (conj (disj free-groups group-a) (clojure.set/union group-a surround))\n                                                         :else (conj (disj free-groups group-a group-b) (clojure.set/union group-a group-b surround))))) \n                                                    #{} free-space-points))]\n    (let [scanned-maze (scan-maze maze)\n          free-space-connective-groups (group-free-space-by-connectivity (:free-space scanned-maze))\n          mouse-cheese #{(:mouse scanned-maze) (:cheese scanned-maze)}]\n      (= 1 (count (remove #(empty? (clojure.set/intersection mouse-cheese %)) free-space-connective-groups))))))","user":"53286f84e4b09d4e7a9b5505"},{"problem":117,"code":"#(< (mod (hash %) 23) 13)","user":"536046a9e4b063bf7a5f8fe1"},{"code":"(fn [lines]\n    (let [maze (into {} (for [[y line] (map-indexed list lines)\n                              [x  val] (map-indexed list line)]\n                             [[x y] val]))\n          start (some (fn [[pos val]] (when (= \\M val) pos)) maze)]\n      (loop [todo #{start} visited #{}]\n        (if (empty? todo)\n            false ; Can't find the cheese\n            (let [ pos (first todo) todo (disj todo pos) ]\n                (if (= \\C (get maze pos))\n                  true ; Found the cheese\n                  (let [visited (conj visited pos)\n                        [x y] pos\n                        next (for [[dx dy] [[-1 0] [1 0] [0 1] [0 -1]]\n                                   :let [pos [(+ x dx) (+ y dy)]]\n                                   :when (not= \\# (get maze pos \\#))]\n                                pos)\n                        todo (into todo next)\n                        todo (apply disj todo visited)]\n                    (recur todo visited))))))))","problem":117,"user":"4e7dfab0535db169f9c796f9"},{"code":"(fn getPath[matrix]\r\n   (let[ymax  (count matrix),\r\n        xmax  (count (seq (first matrix) ) ),\r\n        start (loop[cols matrix,n 0]\r\n                 (let  [idx  (.indexOf (first cols) \"M\") ]\r\n                   (if (= idx -1)\r\n                       (recur (rest cols) (inc n) )\r\n                       [idx n]\r\n                       )\r\n                 )\r\n               ), \r\n        getVal (fn([[x y]]\r\n                  (cond (or (< x 0) (< y 0))\r\n                       \\#\r\n                       (or (= x xmax) (= y ymax) )\r\n                       \\#\r\n                       :else \r\n                       (nth (nth matrix y) x)\r\n                    )\r\n                 )),\r\n        getNexts (fn\r\n                   ([[x0 y0]  path]\r\n                    (filter  #(and (not= \\# (getVal %) )\r\n  \t\t\t                           (not (contains? path %))\r\n\t\t\t\t                             )\r\n                     (for[x (range -1 2) y (range -1 2)\r\n                              :when (= 1 (Math/abs (+ x y) ) )]\r\n                           [(+ x0 x) (+ y0 y)]\r\n                           )\r\n                   )))\r\n        ]\r\n;        (true? (search start #{} )) \r\n;         (getNexts start #{})\r\n        (loop[path #{start}]\r\n;            (println path)\r\n            (if (some #(= \\C %) (map getVal path))\r\n\t\t\t\t        true\r\n            (let[nexts (filter not-empty (map #(getNexts % path) path) )]\r\n                (if (empty? nexts)\r\n                    false\r\n                   (recur (reduce #(reduce conj %1 %2) path nexts))\r\n\t\t\t\t                    ))))))","problem":117,"user":"4f6d9d7ee4b07046d9f4efcd"},{"problem":117,"code":"(fn [maze]\n    (let [maze   (vec (map vec maze))\n          p      #{[0 1] [0 -1] [1 0] [-1 0]}\n          width  (count (first maze))\n          height (count maze)\n          n      (fn [[y x]]\n                   (filter\n                     (fn [[r c]] (and (< -1 r height) (< -1 c width) (not= (get-in maze [r c]) \\#)))\n                     (map (fn [[r c]] [(+ r y) (+ c x)]) p)))\n          i      (map #(.indexOf % \\M) maze)\n          m-r    (.indexOf (map #(>= % 0) i) true)\n          m-c    (first (filter #(>= % 0) i))\n          f      (fn [s visited]\n                   (if (empty? s)\n                     visited\n                     (let [current   (peek s)\n                           neighbors (filter #(not (contains? visited %)) (n current))\n                           s         (into (pop s) neighbors)]\n                       (recur s (conj visited current)))))]\n      (contains? (set (map #(get-in maze %) (f [[m-r m-c]] #{}))) \\C)))","user":"5a2df4a0e4b09cafd31c7f74"},{"problem":117,"code":"(fn [z]\n  (let [z (vec (map vec z)) \n        n (count z)\n        m (count (z 0))]\n    (loop [z z]\n      (let [r (loop [p (for [i (range n)               \n                             j (range m)] \n                         [i j])\n                     r z]                \n                (if (seq p)                 \n                  (let [i ((first p) 0)                       \n                        j ((first p) 1)]                   \n                    (if (= \\M ((r i) j))                     \n                      (let [r r                          \n                            i (dec i)                          \n                            r (if (and (>= i 0) (not= \\# ((r i) j))) (assoc r i (assoc (r i) j \\M)) r)                          \n                            i (+ 2 i)                        \n                            r (if (and (< i n) (not= \\# ((r i) j))) (assoc r i (assoc (r i) j \\M)) r)                        \n                            i (dec i)                            \n                            j (dec j)                           \n                            r (if (and (>= j 0) (not= \\# ((r i) j))) (assoc r i (assoc (r i) j \\M)) r)                           \n                            j (+ 2 j)\n                            r (if (and (< j m) (not= \\# ((r i) j))) (assoc r i (assoc (r i) j \\M)) r)                           \n                            j (dec j)]                       \n                        (recur (rest p) r))                 \n                      (recur (rest p) r)))              \n                  r))]        \n        (if (= 0 (count (filter (fn [x] (some #(= % \\C) x)) r)))               \n          true              \n          (if (= r z)                 \n            false\n            (recur r)))))))","user":"5799ff45e4b05b1deef9add1"},{"code":"(fn [strs]\n  (let [\n    mre\n    (re-pattern \n      (format \n        \"( |C)(?=.{%1$d}M)|(?<=M.{%1$d})( |C)|( |C)(?=M)|(?<=M)( |C)\"\n        (count (first strs))))\n    field\n    (apply str (interpose \"#\" strs))\n    mouseflood\n    (drop-while \n       #(re-seq mre %)\n       (iterate #(clojure.string/replace % mre \"M\") field)\n    )\n  ]\n    (not (re-seq #\"C\" (first mouseflood)))\n  ))","problem":117,"user":"4f03154a535dcb61093f6a58"},{"code":"(fn [board]\n   (letfn [(neighbors [bd x y]\n             (keep identity (map #(get-in bd %)\n                                 #{[(dec x) y] [(inc x) y] [x (dec y)] [x (inc y)]})))\n           (next-bd [bd]\n             (vec (map (fn [x]\n                         (vec (map (fn [y]\n                                     (let [cell (get-in bd [x y])\n                                           nbrs (neighbors bd x y)]\n                                       (cond\n                                        (and (= cell \\C) (some #(= \\M %) nbrs))    :win\n                                        (and (not (#{:win \\#} cell)) (some #(= \\M %) nbrs)) \\M\n                                        :else cell)))\n                                   (range (count (first bd))))))\n                       (range (count bd)))))\n           (closure [f x] (let [fx (f x)] (if (= x fx) x (recur f fx))))]\n     (boolean (some #{:win} (flatten (closure next-bd board))))))","problem":117,"user":"4ea1b9e4535d7eef308072b8"},{"code":"(fn solvable? [maze]\n  (let\n    [ width (count (first maze))\n      height (count maze)\n      maze-with-xy\n        (apply concat\n          (map-indexed\n            (fn [y row]\n              (map-indexed (fn [x p] [[x y] p]) row))\n            maze))\n      xy-maze\n        (reduce\n          (fn [m [k v]] (assoc m k v))\n          {}\n          maze-with-xy)\n      mouse-position (ffirst (filter #(= \\M (second %)) maze-with-xy))\n      cheese-position (ffirst (filter #(= \\C (second %)) maze-with-xy))\n      moves-around (fn [[x y]]\n        (filter\n          (fn [[a b]] (and (>= a 0) (< a width)\n                           (>= b 0) (< b height)\n                           (not (#{\\# \\M} (xy-maze [a b])))))\n          [[(dec x) y] [(inc x) y] [x (dec y)] [x (inc y)]]))\n      tried (transient #{})\n      route-exists? (fn route-exists? [start end route]\n        (if (= start end)\n            true\n            (let [possible-steps (moves-around start)\n                  next-steps     (filter #(not (or (tried %) (route %))) possible-steps)]\n              (if (empty? next-steps)\n                  false\n                  (loop [[step & rsteps] next-steps tried tried]\n                    (cond\n                      (not step) false\n                      (route-exists? step end (conj route step)) true\n                      :else (recur rsteps (conj! tried step))))))))]\n    (route-exists? mouse-position cheese-position #{})))","problem":117,"user":"4f725466e4b07046d9f4f030"},{"code":"(fn mazable [maze]\n  (let [h (count maze)\n        w (count (first maze))\n        m (first (for [y (range h) x (range w) :when (= (get-in maze [y x]) \\M)] [y x]))]\n    (loop [reachable #{m}]\n      (let [nextstep (into reachable\n                           (for [[y x] reachable\n                                 [dy dx] '([0 1] [0 -1] [1 0] [-1 0])\n                                 :let [coord [(+ y dy) (+ x dx)]\n                                       ch (get-in maze coord)]\n                                 :when (or (= ch \\space) (= ch \\C))]\n                             coord))]\n        (cond (= nextstep reachable) false\n              (some #(= (get-in maze %) \\C) nextstep) true\n              true (recur nextstep))))))","problem":117,"user":"4fe8aef4e4b07c9f6fd12c6c"},{"problem":117,"code":"(fn solvable?\n  [maze]\n  (let [parsed-maze (->> maze\n                         (map-indexed\n                           (fn [y row]\n                             (map-indexed\n                               (fn [x character]\n                                 [[x y] character])\n                               row)))\n                         (apply concat)\n                         (into {}))\n        valid-position? (fn [disallowed-positions [x y]]\n                          (and (#{\\space \\C} (parsed-maze [x y]))\n                               (not (disallowed-positions [x y]))))\n        next-move (fn [disallowed-positions [x y]]\n                    (let [neighbours [[(inc x) y] [(dec x) y] [x (inc y)] [x (dec y)]]]\n                      (->> neighbours\n                           (filter (partial valid-position? disallowed-positions))\n                           first)))\n        starting-position (key (first (filter #(= \\M (val %)) parsed-maze)))]\n    (loop [position starting-position\n           visited #{position}\n           dead-ends #{}]\n      (cond (= \\C (parsed-maze position))\n            true\n\n            (dead-ends starting-position)\n            false\n\n            :else\n            (if-let [next-position (next-move (clojure.set/union visited dead-ends) position)]\n              (recur next-position (conj visited position) dead-ends)\n              (recur starting-position #{starting-position} (conj dead-ends position)))))))","user":"5b602a66e4b0c6492753e6fc"},{"problem":117,"code":"(fn m\n  ([b]\n   (letfn [(f [b e]\n              (for [y (range (count b))\n                    x (range (count (first b)))\n                    :when (= e (get-in b [y x]))]\n                [y x]))]\n     (not\n      (nil?\n       (m (f b \\M)\n          (first (f b \\C))\n          (into #{} (f b \\space)))))))\n  ([t d r]\n   (let [f (first t)\n         p (fn [[a b] [x y]]\n             (or (and (= a x)\n                      (or (= (- b y) -1)\n                          (= (- b y)  1)))\n                 (and (= b y)\n                      (or (= (- a x) -1)\n                          (= (- a x)  1)))))]\n     (or (p f d)  \n         (some true?\n               (for [a r\n                     :when (p f a)]\n                 (m (conj t a)\n                    d\n                    (disj r a))))))))","user":"52bacfa8e4b07a9af57922d6"},{"problem":117,"code":"(fn [maze]\n  (let [width (count (maze 0))\n        height (count maze)\n        points (into {} (for [i (range height) j (range width)]\n                              {[i j] (.charAt (maze i) j)}))\n        find-position (fn [letter] (first (filter (comp letter points) (keys points))))\n        mouse (find-position #{\\M})\n        cheese (find-position #{\\C})\n        neighbors (fn [[x y]] #{[(- x 1) y] [(+ x 1) y] [x (- y 1)] [x (+ y 1)]})\n        iteration (fn [s] (->> s\n                               (map (fn [point] (map #(if (or (= (points %) \\space) (= (points %) \\C)) #{%}) (neighbors point))))\n                               (flatten)\n                               (filter (complement nil?))\n                               (apply clojure.set/union)))\n        resultIterations (->> (hash-set mouse)\n                              (iterate iteration)\n                              (take (* width height))\n                              (apply clojure.set/union))]\n    (contains? resultIterations cheese)))","user":"5e13a6b7e4b099d064963001"},{"code":"(let[\n  \n adjs [[-1 0] [1 0] [0 -1] [0 1]]\n neighbours (fn [x y] (map #(map + [x y] %) adjs))\n has (fn[X m x y]\n  (some #(= X (get-in m %)) (neighbours x y)))\n g (fn[m] (vec\n  (let[ cols (count (first m))\n        rows (count m)]\n   (map-indexed \n    (fn[r row] (apply str (map-indexed\n      (fn[c val] \n        (if (and (= val \\space)\n                  (has \\M m r c)) \\M val))\n        row)))\n    m))))\n\n count-m (fn [m] (apply + (map \n       (fn[r] (apply + (map #( {\\M 1} % 0) r))) m)))\n cheese (fn[m]\n  (vec\n(filter identity (flatten\n(map-indexed\n(fn[i r]\n  (let[ s\n  (filter identity (map-indexed #(if (=\\C %2) %) r))]\n    (if (empty? s) nil [i s])\n    ))  \n m\n)))))]\n\n(fn[m]\n  (let [[rc cc] (cheese m)]\n  (loop[ m m cm 1]\n    (let[new-m (g m) new-cm (count-m new-m)]\n    (cond (= new-cm cm) false\n          (has \\M new-m rc cc) true\n     :else (recur new-m new-cm)))))))","problem":117,"user":"507c7c8be4b0b083f3ff82ef"},{"problem":117,"code":"(fn [maze]\n  (let [h (count maze)\n        w (count (first maze))\n        vmaze (vec (map vec maze))\n        start (some #(if (= (get-in vmaze %) \\M) %) (for [r (range h) c (range w)] [r c]))\n        end (some #(if (= (get-in vmaze %) \\C) %) (for [r (range h) c (range w)] [r c]))\n        nabes (fn [[r c]] (filter (fn [[r2 c2]] (and (< -1 r2 h) (< -1 c2 w)))\n                                  [[(inc r) c] [(dec r) c] [r (inc c)] [r (dec c)]]))]\n    (loop [reach #{start}]\n        (let [new (mapcat (fn [pos] (remove #(= (get-in vmaze %) \\#) (nabes pos))) reach)\n              next (set (concat reach new))]\n          (cond (next end) true\n                (= reach next) false\n                :else (recur next))))))","user":"5db92996e4b010eb3c36cd50"},{"problem":117,"code":"(fn [rows]\n  (let [ nrows (count rows),\n         ncols (count (first rows)),\n         data (apply str rows),\n         n (* nrows ncols)\n         add (fn [s i]\n             (let [xi (if (< 0 (mod i ncols)) (dec i)),\n                 yi (- i ncols)]\n            (for [x s] (if (or (x xi) (x yi)) (conj x i) x) )))\n         merge (fn [s i] (if (seq s)\n           (let [s2 (set (add s i))]\n            (let [s3 (if (not (some #(% i) s2)) (into s2 (hash-set (hash-set i))) s2)]\n            (for [x s3, y s3]\n            (if (and (x i) (y i)) (into x y) x))))\n            (hash-set (hash-set i))))\n  ]\n (loop [s #{}, m #{}, c #{}, i 0]\n   (if (= i n)\n   (not (nil? (some #(and (% (first m)) (% (first c))) s)))\n    (recur\n      (if (not= \\# (get data i)) (set (merge s i)) s)\n      (if (= \\M (get data i)) (conj m i) m)\n      (if (= \\C (get data i)) (conj c i) c)\n      (inc i)))\n )\n))","user":"4fd11a93e4b04c3a95aa040a"},{"problem":117,"code":"(fn for_science [board]\n    (let\n        [\n            nrow (count board) ncol (if (empty? board) 0 (count (first board)))\n            inbounds?\n                (fn [row col] (every? true? [(>= row 0) (>= col 0) (< row nrow) (< col ncol)]))\n            dirs\n                (fn [row col] [[(dec row) col] [(inc row) col] [row (inc col)] [row (dec col)]])\n            is_open_space?\n                (fn [r c] (let [x (nth (nth board r) c)] (contains? #{\\  \\M \\C} x)))\n            open_spaces\n                (filter (fn [[r c]] (is_open_space? r c))\n                    (for [r (range nrow) c (range ncol)] [r c])\n                )\n            generate_adjacency_map_red\n                (fn [[ret m c] [row col]]\n                    (let\n                        [\n                            next_spots\n                                (filter\n                                    (fn [[r c]] (and (inbounds? r c) (is_open_space? r c)))\n                                    (dirs row col)\n                                )\n                            m (if (= \\M (nth (nth board row) col)) [row col] m)                            \n                            c (if (= \\C (nth (nth board row) col)) [row col] c)\n                        ]\n                        [(assoc ret [row col] next_spots) m c]\n                    )\n                )\n            generate_adjacency_map\n                (fn [x]\n                    (reduce generate_adjacency_map_red [{} nil nil] open_spaces)\n                )\n            [adj_map m c] (generate_adjacency_map board)\n            bfs_iterate\n                (fn [[prev curr]] [curr (into curr (mapcat adj_map curr))])\n            drop_while_pred\n                (fn [[prev curr]] (and (not= prev curr) (not (contains? curr c))))\n        ]\n        (->> [#{} #{m}]\n            (iterate bfs_iterate)                \n            (drop-while drop_while_pred)\n            (first)\n            (second)\n            (#(contains? % c))\n        )\n    )\n)","user":"5db7376fe4b010eb3c36cd43"},{"code":"(fn f [z] (let [s (vec (map vec z))\n              n (count s)\n              m (count (first s))\n              d [[-1 0] [1 0] [0 -1] [0 1] [0 0]]\n              R range\n              M \\M\n              W \\#]\n  (letfn [(g [x y] \n    (let [v (get-in s [x y])\n          q (apply max (for [[a b] d]\n        (if (= M (get-in s [(+ a x) (+ b y)]))\n          1\n          0)))]\n      (cond \n        (= v W) W\n        (= q 1) M\n        :else v)))]\n    (let [n (for [x (R 0 n)]\n      (for [y (R 0 m)]\n        (g x y)))]\n      (if (= s n)\n        (not-any? #(= \\C %) (flatten n))\n        (f n))))))","problem":117,"user":"4f01c938535dcb61093f6a39"},{"code":"(fn [m]\n  (let [free? (fn [cell] (= \\space (get-in m cell)))\n        cheese? (fn [cell] (= \\C (get-in m cell)))\n        accessible? (fn [cell] (or (free? cell) (cheese? cell)))\n        neighbours (fn [cell] (map #(map + cell %) [[0 -1] [1 0] [0 1] [-1 0]]))\n        accessible-neighbours (fn [cell] (filter accessible? (neighbours cell)))\n        cells (for [i (range (count m)) j (range (count (first m)))] [i j])\n        mouse (some (fn [cell] (when (= \\M (get-in m cell)) cell)) cells)]\n    (loop [reachable-cells (set (accessible-neighbours mouse))]\n      (if (some cheese? reachable-cells)\n        true\n        (let [next-reachable-cells (into reachable-cells (mapcat accessible-neighbours reachable-cells))]\n          (if (= next-reachable-cells reachable-cells)\n            false\n            (recur next-reachable-cells)))))))","problem":117,"user":"5028cd0fe4b01614d1633ffc"},{"problem":117,"code":"(fn for-science\n    ([v] (for-science v (count v) (.length (first v))))\n    ([v m n]\n      (let [getmn (fn [v y x] (-> v (nth y) (nth x)))\n            where-char(fn [chr]  (fn [v]  (->> (for [i (range m) j (range n) :when (= (getmn v i j) chr) ] [i j]) first)))\n            where-c (where-char \\C)\n            where-m (where-char \\M)\n            passable? (fn [v y x] \n                        (and  (>= y 0) (>= x 0)\n                              (< y m) (< x n)\n                              (not (= (getmn v y x) \\#))))\n            get-ways (fn [v cy cx]\n                       (for [a (range -1 2) b (range -1 2)  \n                             :when   (and (= (Math/abs (+ a b)) 1) \n                                          (passable? v (+ a cy) (+ b cx))) ]\n                         [(+ a cy) (+ b cx)]))\n            next-passable-path (fn [v insert-positions] \n                                 (let [nxt-insert-lst (mapcat (fn [[i j]] (get-ways v i j)) insert-positions)]\n                                   (if (empty? nxt-insert-lst)\n                                     [v ] \n                                     (let [nxt-insert-hash (->> (mapcat (fn [[i j]] (get-ways v i j)) insert-positions)\n                                                             (#(interleave % (repeat \\C)))\n                                                             (apply assoc {} ))\n\n                                           newv (->> (for [i (range m)  j (range n)]\n                                                       (cond\n                                                         (nxt-insert-hash [i j]) (nxt-insert-hash [i j])\n                                                         :else (getmn v i j)))\n                                                  (partition n )) ]\n                                       [newv (keys nxt-insert-hash)]\n                                       ))))\n            passable-path  (loop [current-passable v insert-positions [(where-c v)]]\n                             (let [[new-passable insert-positions] (next-passable-path current-passable insert-positions)]\n                               (if (= new-passable current-passable)\n                                 current-passable\n                                 (recur new-passable insert-positions))))\n            ]\n        (let [[my mx] (where-m v)]\n          (= (getmn passable-path my mx) \\C)\n          ))))","user":"55aa1637e4b0988bba2ad949"},{"problem":117,"code":";; TODO: The mouse can visit places he has already been. The queue needs pruning.\n(fn i-can-haz-cheeze? [input]\n  (let [board (mapv vec input)\n        height (count board)\n        width (count (first board))\n        all-coords (for [y (range height)\n                         x (range width)]\n                     [x y])\n\n        is-a? (fn [t [x y]]\n                (= t (get-in board [y x])))\n        mouse? (fn [c] (is-a? \\M c))\n        cheese? (fn [c] (is-a? \\C c))\n        wall? (fn [c] (is-a? \\# c))\n        start (some #(when (mouse? %) %) all-coords)\n\n        valid-moves (fn [[x y]]\n                            (when x\n                              (for [xs [(dec x) x (inc x)]\n                                    ys [(dec y) y (inc y)]\n                                    :when (not (and (= xs x) (= ys y))) ;; must move\n                                    :when (not (and (not= xs x) (not= ys y))) ;; not diagonal move\n                                    :when ((comp not wall?) [xs ys])\n                                    :when (< xs width)\n                                    :when (< ys height)\n                                    :when (>= ys 0)\n                                    :when (>= xs 0)]\n                                [xs ys])))]\n    ;; Breadth first search\n    (loop [queue [start] visited #{}]\n      (let [[current-node & rest-queue] queue\n            moves (valid-moves current-node)\n            new-paths (clojure.set/difference (set moves) visited)]\n        (cond\n          (cheese? current-node) true\n          (nil? current-node) false\n          :else (recur (concat rest-queue new-paths) (conj visited current-node)))))))","user":"56069006e4b08b23635d3174"},{"code":"(fn [b]\n  (let [h (+ (count b) 2)\n        w (+ (count (first b)) 2)\n        e (vec (concat [(vec (repeat w \\#))] ; expanded board\n                       (map #(vec (concat '(\\#) % '(\\#))) b)\n                       [(vec (repeat w \\#))]))\n        yx #(first\n              (for [y (range h) x (range w)\n                   :when (= % (get-in e [y x]))] [y x]))\n        c (yx \\C) ; cheesy position\n        fnl ; final board\n          (loop [ms ; all possible mouse positions\n                   [(yx \\M)]\n                 g  ; updated board M-marked where mouse passed\n                    (assoc-in e c \\space)]\n            (let [cns\n                    (for [[y x :as cur] ms\n                          nxt [[(inc y) x] [(dec y) x] [y (inc x)] [y (dec x)]]\n                          :when (= \\space (get-in g nxt))] [cur nxt])]\n              (if (empty? cns) g\n                  (recur (map second cns)\n                         (reduce\n                           #(assoc-in % (second %2) \\M)\n                           g\n                           cns)))))]\n    (= \\M (get-in fnl c))))","problem":117,"user":"4fd96694e4b05e33b9224f37"},{"problem":117,"code":"(fn for-science-117\n  [maze]\n  (let [width (count (first maze))\n        height (count maze)\n        points (for [i (range height) j (range width)] [i j])\n        valid? (fn [[r c]] (and (< -1 r height) (< -1 c width)))\n        neighbors (fn [p]\n                    (->> [[-1 0] [1 0] [0 -1] [0 1]]\n                         (map (partial map + p))\n                         (filter valid?)))\n        start (->> points\n                   (filter #(= (get-in maze %) \\M))\n                   (first))]\n    (loop [[f & r :as c] [start]\n           visited #{}]\n      (cond\n        (empty? c) false\n        (= \\C (get-in maze f)) true\n        :else (recur\n                (concat r (->> (neighbors f)\n                               (filter valid?)\n                               (filter #(not= (get-in maze %) \\#))\n                               (filter (complement visited))))\n                (conj visited f))))))","user":"5d0bb4fae4b0cc9c91588237"},{"code":"(letfn [(norm [rows]\n          {:cols (count (first rows))\n           :board (apply str (map #(str % \"#\") rows))})\n\n        (apply-moves [board c]\n          (let [moves [[\" M\" \"MM\"]\n                       [\"M \" \"MM\"]\n                       [(str \" (\" c \")M\") \"M$1M\"]\n                       [(str \"M(\" c \") \") \"M$1M\"]]]\n            (assoc board :board (reduce (fn [s [m r]] (clojure.string/replace s (re-pattern m) r)) (:board board) moves))))\n\n        (can-reach? [rows]\n          (let [b (norm rows)\n                c (str \".{\" (:cols b) \"}\")\n                reachable (re-pattern (str \"MC|CM|M\" c \"C|C\" c \"M\"))]\n            (loop [b b]\n              (let [m (apply-moves b c)]\n                (cond \n                  (re-find reachable (:board m)) true\n                  (= m b) false\n                  :else (recur m))))))\n        ] can-reach?)","problem":117,"user":"500aa15ee4b03d00572d2d76"},{"problem":117,"code":"(fn [maze]                         \n  (let [[x0 y0] (first (filter #(>= (% 1) 0) (map-indexed (fn [i x] (vector i (.indexOf x \"M\"))) maze)))\n        search (fn search [x y maze]\n                 (if (or (neg? x) (neg? y) (> (inc x) (count maze)) (> (inc y) (count (maze 0)))) \n                   false\n                   (let [row (maze x) p (get row y)] \n                     (case p\n                       \\C true\n                       (\\# \\V) false\n                       (let [v (assoc-in maze [x] (str (subs row 0 y) \"V\" (subs row (inc y))))]\n                         (true? (some #(search (+ x (% 0)) (+ y (% 1)) v) [[0 -1] [0 1] [-1 0] [1 0]])))))))]\n    (search x0 y0 maze)))","user":"59f043d0e4b0966464fe6a3d"},{"code":"(fn [m]\n  (loop [fm (clojure.string/join \"|\" m)]\n    (let\n      [\n        w (count (first m))\n        mm (clojure.string/replace fm (re-pattern (format \"(?<=M)[ C]|[ C](?=M)|(?<=M.{%1$d})[ C]|[ C](?=.{%1$d}M)\" w)) \"M\")\n      ] \n      (if (= mm fm)\n        false\n        (or \n          (not (some #{\\C} mm))\n          (recur mm)\n        )\n      )\n    )  \n  )                             \n)","problem":117,"user":"5176afd2e4b085adf681d889"},{"code":"(fn __\n  [maze]\n  (letfn [(coord\n            [maze sym]\n            (first\n              (for [x (range (count maze))\n                    y (range (count (first maze)))\n                    :when (= sym (get-in maze [x y]))]\n                [x y])))\n          \n          (neighbors\n            [maze i j]\n            (let [u [(dec i) j]\n                  d [(inc i) j]\n                  l [i (dec j)]\n                  r [i (inc j)]]\n              {[i j] (filter #(not= \\# (get-in maze % \\#)) [u d l r])}))\n          \n          (dfs [g s]\n            (loop [vertices [] explored #{s} frontier [s]]\n              (if (empty? frontier)\n                vertices\n                (let [v (peek frontier)\n                      neighbors (g v)]\n                  (recur\n                    (conj vertices v)\n                    (into explored neighbors)\n                    (into (pop frontier) (remove explored neighbors)))))))]\n    \n    (let [maze (mapv vec maze)\n          cheese (coord maze \\C)\n          mice (coord maze \\M)\n          graph (apply merge (for [i (range (count maze))\n                                   j (range (count (first maze)))\n                                   :when (not= \\# (get-in maze [i j]))]\n                               (neighbors maze i j)))]\n\n      (not (empty? (filter #(= cheese %) (dfs graph mice)))))))","problem":117,"user":"5348cab4e4b084c2834f4a5e"},{"problem":117,"code":"(fn [arr]\n    (let [w (count (first arr))\n          h (count arr)\n          solved (atom false)]\n      (letfn [(getchks [x y]\n                (->> [[-1 0] [1 0] [0 -1] [0 1]]\n                     (remove (fn [[xx yy]] (and (zero? x) (neg? xx))))\n                     (remove (fn [[xx yy]] (and (zero? y) (neg? yy))))\n                     (remove (fn [[xx yy]] (and (= (dec w) x) (pos? xx))))\n                     (remove (fn [[xx yy]] (and (= (dec h) y) (pos? yy))))))\n              (next [a] (for [y (range h)]\n                         (apply str (for [x (range w)]\n                                      (let [cell (nth (nth a y) x)\n                                             chks (getchks x y)\n                                             neighbors (map (fn [[xx yy]] (nth (nth a (+ y yy)) (+ x xx))) chks)\n                                             ms (some #{\\M} neighbors)\n                                             cs (some #{\\C} neighbors)]\n                                            (cond (= cell \\space)\n                                                  (cond ms \\M\n                                                        cs \\C\n                                                        :else \\space)\n                                                  (or (and (= cell \\M) cs)\n                                                      (and (= cell \\C) ms))\n                                                  (swap! solved (fn [_] true))\n                                                  :else cell))))))]\n        (loop [a arr]\n          (let [n (next a)]\n            (if (= n a) @solved (recur n)))))))","user":"56018dd4e4b04bb52996e18f"},{"problem":117,"code":"(fn cheese? [table]\n  (let [max-y (count table)\n        max-x (count (first table))\n        get (fn [x y]\n              (if (or\n                    (>= x max-x)\n                    (>= y max-y)\n                    (< x 0)\n                    (< y 0))\n                \\#\n                (-> table\n                  (nth y)\n                  (nth x))))\n        generate-next-step (fn [[previous-coords visited-coords]]\n                             (let [neighbours (fn [[x y]] [[(+ x -1) y]\n                                                           [x (+ y 1)]\n                                                           [x (+ y -1)]\n                                                           [(+ x 1) y]])\n                                   can-go-to? (fn [[x y]] (not= \\# (get x y)))\n                                   new-visited-coords (into visited-coords previous-coords)\n                                   new-coords (set (for [previous-coord previous-coords\n                                                         neighbour (neighbours previous-coord)\n                                                         :when (can-go-to? neighbour)\n                                                         :when (not (contains? new-visited-coords neighbour))]\n                                                     neighbour))]\n                               [new-coords new-visited-coords]))\n        start-coord (first (for [x (range max-x)\n                                 y (range max-y)\n                                 :when (= \\M (get x y))] [x y]))\n        previous-coord-not-empty? (fn [[previous-coords _]] (not (empty? previous-coords)))\n        previous-coords-contains-cheese? (fn [[previous-coords _]] (->> previous-coords\n                                                                     (map (fn [[x y]] (= \\C (get x y))))\n                                                                     (some identity)))]\n  (if (= nil (->> [[start-coord] #{}]\n               (iterate generate-next-step)\n               (take-while previous-coord-not-empty?)\n               (some previous-coords-contains-cheese?))) false true)))","user":"53c38b8ce4b00fb29b22127b"},{"problem":117,"code":"(fn can-mouse-catch-cheese? [maze]\n  (let [rows               (count maze)\n        columns            (count (first maze))\n        mouse-cheese-pos   (into (sorted-map) (for [i (range rows)\n                                                    j (range columns)\n                                                    :let [val (get (get maze i) j)]\n                                                    :when (or (= \\M val) (= \\C val))]\n                                                {val (+ (* columns i) j)}))\n        get-row-col        (fn [index]\n                             [(quot index columns) (mod index columns)])\n        get-abs            (fn [r c]\n                             (+ (* columns r) c))\n        disjoint-sets-init (reduce (fn [disjoint-sets-init index]\n                                     (let [[r c] (get-row-col index)]\n                                       (if (= \\# (get (get maze r) c))\n                                         disjoint-sets-init\n                                         (assoc disjoint-sets-init index {:root index :size 1}))))\n                                   {}\n                                   (range (* rows columns)))\n        valid-ones         #{\\space \\M \\C}\n        get-root           (fn get-root [val disjoint-sets]\n                             (if (= val (:root (get disjoint-sets val)))\n                               val\n                               (get-root (:root (get disjoint-sets val)) disjoint-sets)))\n        unionx             (fn [x y disjoint-sets]\n                             (let [root-x (get-root x disjoint-sets)\n                                   root-y (get-root y disjoint-sets)\n                                   size-x (:size (get disjoint-sets root-x))\n                                   size-y (:size (get disjoint-sets root-y))]\n                               (if (> size-x size-y)\n                                 (let [disjoint-sets (assoc disjoint-sets root-y {:root root-x})\n                                       disjoint-sets (assoc disjoint-sets root-x {:root root-x :size (+ size-x size-y)})]\n                                   disjoint-sets)\n                                 (let [disjoint-sets (assoc disjoint-sets root-x {:root root-y})\n                                       disjoint-sets (assoc disjoint-sets root-y {:root root-y :size (+ size-x size-y)})]\n                                   disjoint-sets))))\n        disjoint-sets      (reduce (fn [disjoint-sets index]\n                                     (let [[r c] (get-row-col index)]\n                                       (if (= \\# (get (get maze r) c))\n                                         disjoint-sets\n                                         (let [a             (get (get maze r) (dec c))\n                                               b             (get (get maze (dec r)) c)\n                                               disjoint-sets (if (contains? valid-ones a)\n                                                               (unionx index (get-abs r (dec c)) disjoint-sets)\n                                                               disjoint-sets)\n                                               disjoint-sets (if (contains? valid-ones b)\n                                                               (unionx index (get-abs (dec r) c) disjoint-sets)\n                                                               disjoint-sets)]\n                                           disjoint-sets))))\n                                   disjoint-sets-init\n                                   (range (* rows columns)))]\n    (= (get-root (get mouse-cheese-pos \\M) disjoint-sets) (get-root (get mouse-cheese-pos \\C) disjoint-sets))))","user":"5dc53ddee4b02f9375f4e1bd"},{"problem":117,"code":"(fn mazesolver [b]\n              (let [v (vec (flatten (map vec b)))\n                    rowlength (count (first b))\n                    columnheight (count b)\n                    cellcount (count v)\n                    mouse (first (for [i (range cellcount)\n                                       :when (= (get v i) \\M)]\n                                   i))\n                    cheese (first (for [i (range cellcount)\n                                        :when (= (get v i) \\C)]\n                                    i))]\n                (if (or (and (not= 0 (mod mouse rowlength)) (== mouse (inc cheese)))\n                        (and (not= 0 (mod cheese rowlength)) (== mouse (dec cheese)))\n                        (== mouse (+ cheese rowlength))\n                        (== mouse (- cheese rowlength)))\n                  true\n                  (if (and (>= mouse rowlength) (= (get v (- mouse rowlength)) \\space))\n                    (mazesolver (map #(apply str %) (partition rowlength (assoc (assoc v mouse \\m) (- mouse rowlength) \\M))))\n                    (if (and (< (+ mouse rowlength) cellcount) (= (get v (+ mouse rowlength)) \\space))\n                      (mazesolver (map #(apply str %) (partition rowlength (assoc (assoc v mouse \\m) (+ mouse rowlength) \\M))))\n                      (if (and (not= 0 (mod mouse rowlength)) (= (get v (dec mouse)) \\space))\n                        (mazesolver (map #(apply str %) (partition rowlength (assoc (assoc v mouse \\m) (dec mouse) \\M))))\n                        (if (and (not= 0 (mod (inc mouse) rowlength)) (= (get v (inc mouse)) \\space))\n                          (mazesolver (map #(apply str %) (partition rowlength (assoc (assoc v mouse \\m) (inc mouse) \\M))))\n                          (if (and (>= mouse rowlength) (= (get v (- mouse rowlength)) \\m))\n                            (mazesolver (map #(apply str %) (partition rowlength (assoc (assoc v mouse \\#) (- mouse rowlength) \\M))))\n                            (if (and (< (+ mouse rowlength) cellcount) (= (get v (+ mouse rowlength)) \\m))\n                              (mazesolver (map #(apply str %) (partition rowlength (assoc (assoc v mouse \\#) (+ mouse rowlength) \\M))))\n                              (if (and (not= 0 (mod mouse rowlength)) (= (get v (dec mouse)) \\m))\n                                (mazesolver (map #(apply str %) (partition rowlength (assoc (assoc v mouse \\#) (dec mouse) \\M))))\n                                (if (and (not= 0 (mod (inc mouse) rowlength)) (= (get v (inc mouse)) \\m))\n                                  (mazesolver (map #(apply str %) (partition rowlength (assoc (assoc v mouse \\#) (inc mouse) \\M))))\n                                  false)))))))))))","user":"532727bae4b09d4e7a9b54fa"},{"code":"; \\Mouse fills \\space and eats \\Cheese\n\n(fn [maze]\n  (let [h (count maze)\n        w (count (first maze))\n        c (* w h)\n        final-iteration #(loop [x %1 fx (%2 %1)] (if (= x fx) x (recur fx (%2 fx))))\n        rotate #(take c (drop (mod %1 c) (cycle %2)))]\n    (not-any? #(= \\C %)\n      (final-iteration (apply concat maze)\n        #(map\n          (fn [p & around] \n              (if (and (#{\\C \\space} p) \n                       ((into #{} around) \\M)) \\M p))\n          % \n          (rotate (- w) (concat (first (split-at (- c w)  %)) (repeat w \\#)))\n          (rotate w     (concat (repeat w \\#) (second (split-at w %))))\n          (rotate -1 (flatten (interleave (map butlast (partition w  %)) (repeat h \\#))))\n          (rotate 1  (flatten (interleave (repeat h \\#) (map rest (partition  w %))))))))))","problem":117,"user":"4f280840e4b0d6649770a010"},{"code":"(fn solvable? [maze]\n  (letfn [(dfs \n           ([g] (dfs g (first (keys g))))\n           ([g v]\n            (reduce\n             (fn [[walked left :as res] nei]\n               (if (left nei)\n                 (let [[new-walked new-left] (dfs left nei)]\n                   [(concat walked new-walked) new-left])\n                 res))\n             [[v] (dissoc g v)] (g v))))\n          (cartesian [coll1 coll2]\n                     (for [x coll1 y coll2]\n                       [x y]))\n          (positions [m n]\n                     (cartesian (range m) (range n)))\n          \n          (next-matching [pred coll]\n                         (first (filter pred coll)))\n          (member? [v coll]\n                   (true? (some (partial = v) coll)))\n          (cell-neighbours [maze [x y]]\n                           (for [dx [-1 0 1]\n                                 dy [-1 0 1]\n                                 :when (not= dx dy)\n                                 :let [x2 (+ x dx) y2 (+ y dy)]\n                                 :when (#{\\space \\C \\M} (get-in maze [x2 y2]))]\n                             [x2 y2]))\n          (graph-maze [maze]\n                      (let  [poss (positions (count maze) (count (first maze)))]\n                        {:g (zipmap poss (map (partial cell-neighbours maze) poss))\n                        :cheese (next-matching #(= \\C (get-in maze %)) poss)\n                        :mouse (next-matching #(= \\M (get-in maze %)) poss)}))]\n    (let [{:keys [g cheese mouse]} (graph-maze maze)\n          [walked _] (dfs g mouse)]\n      (member? cheese walked))))","problem":117,"user":"5326c5f7e4b09d4e7a9b54f2"},{"code":"(fn [maze]\n    (loop [queue (vec (for [i (range (count maze))\n                            j (range (count (get maze i)))\n                            :when (= \\M (get-in maze [i j]))]\n                        [i j]))\n           seen #{(first queue)}]\n      (if-not (seq queue)\n        false\n        (let [[[i j] & rest-of-queue] queue\n              found? (= \\C (get-in maze [i j]))\n              unseen (for [[di dj] [[0 1] [0 -1] [1 0] [-1 0]]\n                           :let [ii (+ i di)\n                                 jj (+ j dj)]\n                           :when (and (not (seen [ii jj]))\n                                      (#{\\space \\C} (get-in maze [ii jj])))]\n                       [ii jj])]\n          (if found?\n            true\n            (recur (into rest-of-queue unseen)\n                   (into seen unseen)))))))","problem":117,"user":"521b9f92e4b0c4ef0be8304c"},{"code":"(fn [board]\n  (let [names {\\space :open\n               \\# :wall\n               \\M :goal\n               \\C :start}\n        board (vec (for [row board]\n                     (vec (for [col row]\n                            (names col)))))\n        h (count board)\n        w (count (board 0))\n        [start goal] (for [token [:start :goal]\n                           y (range h)\n                           :let [row (board y)]\n                           x (range w)\n                           :when (= token (row x))]\n                       [y x])\n        valid? (fn [[y x :as pos]]\n                 (and (not-any? neg? pos)\n                      (< y h) (< x w)))\n        deltas [[0 1] [1 0] [0 -1] [-1 0]]\n        neighbors (fn [pos]\n                    (filter valid?\n                            (for [d deltas]\n                              (map + pos d))))\n        reachable? (fn reachable? [board pos]\n                     (and (not= :wall (get-in board pos))\n                          (or (= goal pos)\n                              (let [new-board (assoc-in board pos :wall)]\n                                (some #(reachable? new-board %) (neighbors pos))))))]\n    (boolean (reachable? board start))))","problem":117,"user":"4dabb7b1950ed6eda1bd72f3"},{"code":"(fn astar\n ([G] (let [M  Long/MAX_VALUE\n            g  (vec (for [x G] (vec (map #(if (= % \\#) M 0) x))))\n            ij (fn [c]\n                   (let [[i r] (first (keep-indexed (fn [i v] (if (some #{c} v) [i v]))  G))\n                         j (first (keep-indexed #(if (= %2 c) %) r)) ]\n                      [i j]))\n            s (ij \\M)\n            e (ij \\C)]\n       (if (nil? (astar g s e M)) false true)))\n\n ([G start goal M]\n        (let [W  (count (first G))\n              H  (count G)\n              nbr (memoize (fn [[i j]] \n                              (filter (fn [[x y]]\n                                   (and (>= x 0) (>= y 0) (< x H) (< y W) \n                                        (not= M (get-in G [x y]))))\n                                      [[i (+ j 1)] [i (- j 1)] [(+ i 1) j] [(- i 1) j] ])))\n              h   (fn [a b] (reduce + (map #(let [d (- % %2)] (* d d) ) a b) ))\n              f   (memoize (fn [v g] (+ (g v) (h v goal))))  \n              pq  (comp vec (partial sort-by last))    \n              gn  (fn [u g] (map #(vector % (+ (get-in G %) (g u)) ) (nbr u)))\n              ne  #(map (fn [x] [% x (f x %2)])  (remove %3 (nbr %))) ]\n           (loop [A  (into {start 0} (gn start {start 0})) \n                  done #{start}\n                  FE  (pq (ne start A done))]  \n              (when-let [ [u v F] (first FE)]\n                  (if (= v goal)\n                     true\n                     (if (< F M)\n                       (let [A2 (into A (gn v A)), D2 (conj done v)]\n                         (recur A2\n                                D2\n                                (pq (concat (rest FE) \n                                        (remove #(done (second %)) (ne v A2 D2)))))))))))))","problem":117,"user":"4ee7d177535d93acb0a6686f"},{"problem":117,"code":"(fn [b]\n\t(let [find (fn [t] (first (for [x (range (count b)) y (range (count (first b))) :when (= (get-in b [x y]) t)] [x y])))\n\t\t  start (find \\M)\n\t\t  end (find \\C)\n\t\t  available (fn [[x y]] (filter (fn [[q w]] (some #{(get-in b [q w])} #{\\C \\space})) (map (fn [[a1 a2]] [(+ a1 x) (+ a2 y)]) [[1 0] [-1 0] [0 1] [0 -1]])))]\n\t(loop [visited #{start}\n\t\t   current #{start}]\n\t\t   (let [a (clojure.set/difference (set (mapcat available current)) visited)]\n\t\t\t\t(if (some #(= \\C (get-in b %)) a) \n\t\t\t\t\ttrue \n\t\t\t\t\t(if (empty? a) false\n\t\t\t\t\t\t(recur (clojure.set/union visited current) a)))))))","user":"53e19461e4b0d874e779ae59"},{"code":"(fn [maze]\n    (let [find (fn [c board]\n                 (let [[y row] (first (keep-indexed (fn [y row]\n                                                      (when (some #{c} row)\n                                                        [y row])) board))]\n                   [(first (keep-indexed (fn [i chr]\n                                           (when (= c chr)\n                                             i)) row)) y]))\n          mouse (find \\M maze)\n          cheese (find \\C maze)]\n      (loop [seen #{}\n             fringe [mouse]]\n        (if (empty? fringe)\n          false\n          (let [new (mapcat (fn [[x y]]\n                              (for [[dx dy] [[-1 0] [1 0] [0 -1] [0 1]]\n                                    :let [nx (+ x dx)\n                                          ny (+ y dy)\n                                          s (get-in maze [ny nx])]\n                                    :when (#{\\space \\C} s)]\n                                [nx ny]))\n                            fringe)\n                unseennew (remove seen new)]\n            (if (some #{cheese} unseennew)\n              true\n              (recur (into seen fringe) unseennew)))))))","problem":117,"user":"4e6a0667535d8ccf87e9fe9e"},{"problem":117,"code":"(let [size (fn [maze]\n             (let [y (count maze)\n                   x (count (first maze))]\n               [y x]))\n      find-mouse (fn [maze]\n                   (first \n                     (let [[ym xm] (size maze)]\n                       (for [y (range ym)\n                             x (range xm)\n                             :when (= \\M (get-in maze [y x]))]\n                         [y x]))))\n      neighbors [[-1  0]\n                 [ 1  0]\n                 [ 0 -1]\n                 [ 0  1]]\n      moves (fn [pos maze]\n              (for [neighbor neighbors\n                    :let [pos (mapv + pos neighbor)]\n                    :when (and (every? (complement neg?) pos)\n                               (every? identity (map < pos (size maze)))\n                               (not= \\# (get-in maze pos)))]\n                pos))]\n  (fn [maze]\n    (loop [ps [(find-mouse maze)]\n           seen #{}]\n      (cond\n        (some #(= \\C (get-in maze %)) ps) true\n        (empty? ps) false\n        :otherwise (recur (clojure.set/difference (set (mapcat #(moves % maze) ps)) seen) (into seen ps))))))","user":"54ca9ca8e4b057c6fda3a265"},{"problem":117,"code":"(fn [maze]\n  (letfn [(findpos [x]\n           ; return the position [r c] of the maze location containing x                                                      \n            (first (for [r (range (count maze))\n                         c (range (count (maze r)))\n                         :when (= x (get-in maze [r c]))]\n                     [r c])))\n          (neighbors [[r c]]\n           ; return a list of the positions reachable from [r c] in maze                                                      \n            (filter (fn [[i j]]\n                      (and (>= i 0)\n                           (>= j 0)\n                           (< i (count maze))\n                           (< j (count (maze i)))\n                           (not= \\# (get-in maze [i j]))))\n                    (map (fn [[i j]] [(+ i r) (+ j c)]) [[-1 0] [1 0] [0 -1] [0 1]])))\n          (bfs [visited current goal]\n            (and (not (empty? current))\n                 (or (contains? current goal)\n                     (bfs (set (into visited current))\n                          (set (filter #(not (contains? visited %)) (mapcat neighbors current)))\n                          goal))))]\n  (let [mouse  (findpos \\M)\n        cheese (findpos \\C)]\n    (bfs #{} #{mouse} cheese))))","user":"530bf87ee4b02e82168697d5"},{"code":"(fn [ss]\n  (let [\n    h (count ss) \n    w (count (first ss))\n    vis (make-array Long/TYPE h w)\n    begin (transient [0 0])\n    flag (atom false)\n    visit (fn visit [[x y]]\n              (aset vis x y 1)\n              (doseq [[dx dy] [[0 1] [0 -1] [1 0] [-1 0]]]\n                (let [x1 (+ x dx), y1 (+ y dy)]\n                  (if (and (< -1 x1 h) (< -1 y1 w))\n                    (case (aget vis x1 y1)\n                      3 (swap! flag #(or % %2) true)\n                      0 (visit [x1 y1])\n                      \"default\")))))]\n    (doseq [i (range h)]\n      (doseq [j (range w)]\n        (case (get-in ss [i j])\n          \\# (aset vis i j -1)\n          \\M (assoc! begin 0 i 1 j) \n          \\C (aset vis i j 3)\n          \"default\")))\n    (visit (persistent! begin))\n    @flag))","problem":117,"user":"520242bae4b030ee0c5b26e3"},{"problem":117,"code":"(fn [maze]\n  (let [\n        neigh (fn [maze pos] (let [maxi (count maze) maxj (count (first maze)) i (first pos) j (second pos)] (filter #(and (>= (first %) 0) (>= (second %) 0) (< (first %) maxi) (< (second %) maxj) (not (= \\# (get-in maze %)))) (list [(dec i) j] [(inc i) j] [i (dec j)] [i (inc j)]))))\n        wa (fn walk [maze queue visited] (if (empty? queue) false (if (= \\C (get-in maze (first queue))) true (if (contains? visited (first queue)) (walk maze (rest queue) visited) (walk maze (concat (rest queue) (neigh maze (first queue))) (set (cons (first queue) visited)))))))\n        m (into [] (map (fn [i] (into [] i)) maze))\n        mpos (fn [maze] (first (filter #(= \\M (get-in maze %)) (mapcat (fn [x] (map #(vector x %) (range (count (first maze))))) (range (count maze))))))\n        ]\n    (wa m (list (mpos m)) #{})))","user":"5b4b4052e4b02d533a91bc9a"},{"code":"(fn find-cheese [maze]\r\n  (let [neighbours (fn [[x y]] #{[x (inc y)] [x (dec y)] [(inc x) y] [(dec x) y]})\r\n        rows  (count maze)\r\n        cols  (count (first maze))\r\n        mouse (first (for [row (range rows) col (range cols)\r\n                           :when (= (get-in maze [row col]) \\M)] [row col]))]\r\n    (loop [todo #{mouse} done #{}]\r\n      (if (empty? todo) false\r\n          (let [here (first todo)\r\n                c    (get-in maze here)]\r\n            (condp contains? c\r\n              #{\\C} true\r\n              #{nil, \\#} (recur (disj todo here) done)\r\n              #{\\space, \\M} (recur (into (disj todo here)\r\n                                         (remove done (neighbours here)))\r\n                                   (conj done here))))))))","problem":117,"user":"4e994541535dbda64a6f6b64"},{"problem":117,"code":"(fn [rows]\n  (let [passed (atom #{})\n        mouse-pos (first (for [y (range (count rows))\n                               x (range (count (first rows)))\n                               :when (= \\M (get-in rows [y x]))]\n                           [y x]))]\n    (letfn [(go [pos]\n              (if (@passed pos)\n                false\n                (case (get-in rows pos \\#)\n                  \\C true\n                  \\# false\n                  (let [[y x] pos]\n                    (swap! passed conj pos)\n                    (or (go [y (inc x)])\n                        (go [y (dec x)])\n                        (go [(inc y) x])\n                        (go [(dec y) x]))))))]\n      (go mouse-pos))))","user":"583e27e2e4b089d5ab817daa"},{"problem":117,"code":"(fn [maze-rows]\n  (let [maze (vec (map (fn vectorize [row-string]\n                         (->> (clojure.string/split row-string #\"\")\n                              (remove empty?)\n                              (vec)))\n                       maze-rows))\n\n        coords-of (fn [target]\n                    (->> (map-indexed\n                           (fn [row-index row]\n                             (map-indexed\n                               (fn [col-index cell]\n                                 (when (= target cell)\n                                   [row-index col-index]))\n                               row))\n                           maze)\n                         (mapcat #(remove nil? %))\n                         (set)))\n\n        neighbors-of (fn [cell]\n                       (let [[row col] cell]\n                         (set (concat (for [r [(dec row) (inc row)]] [r col])\n                                      (for [c [(dec col) (inc col)]] [row c])))))\n\n        adjacent? (fn [c1 c2]\n                    (clojure.set/intersection (neighbors-of c1) (hash-set c2)))\n\n        any-adjacent? (fn [sources]\n                        (fn [dest]\n                          (not-every?\n                            empty?\n                            (map (partial adjacent? dest) sources))))\n\n        path-exists? (fn [start goal unexplored]\n                       (let [adjacent-to-start (filter (any-adjacent? start) unexplored)\n                             adjacent-to-goal (filter (any-adjacent? goal) unexplored)]\n\n                         (cond\n                           (empty? unexplored) (boolean (seq (filter (any-adjacent? start) goal)))\n                           (every? empty? [adjacent-to-start adjacent-to-goal]) false\n                           :else (recur (into start adjacent-to-start)\n                                        (into goal adjacent-to-goal)\n                                        (clojure.set/difference unexplored adjacent-to-start adjacent-to-goal)))))]\n\n    (path-exists?\n      (coords-of \"M\")\n      (coords-of \"C\")\n      (coords-of \" \"))))","user":"55d28b38e4b0e31453f64a58"},{"code":"(fn solve-maze\n  [maze]\n  (let [num-rows (count maze)\n        num-cols (count (first maze))\n        char-at-pos (fn [[row col]] (get (get maze row) col))\n        free? (fn [p] (when-let [c (char-at-pos p)] (not= c \\#)))\n        neighbours (fn [[row col]] (filter free? (map (fn [[delta-row delta-col]]\n                                                       [(+ row delta-row)\n                                                        (+ col delta-col)])\n                                                     [[0 0] [0 1] [0 -1] [1 0] [-1 0]])))\n        intersects? (fn [ns s] (some #(contains? s %) ns))\n        contains-mouse? (fn [xs] (some #{\\M} (map char-at-pos xs)))\n        contains-cheese? (fn [xs] (some #{\\C} (map char-at-pos xs)))]\n    (loop [nodes (for [row (range num-rows) col (range num-cols)] [row col])\n           connected-subsets #{}]\n      (if nodes\n        (let [p (first nodes)]\n          (if (= (char-at-pos p) \\#)\n            (recur (next nodes) connected-subsets)\n            (let [neighbouring-nodes (neighbours p)\n                  neighbouring-subsets (filter\n                                        (partial intersects? neighbouring-nodes)\n                                        connected-subsets)\n                  this-connected-subset (into (set neighbouring-nodes)\n                                              (reduce concat neighbouring-subsets))]\n              (recur (next nodes)\n                     (conj (apply disj connected-subsets neighbouring-subsets)\n                           this-connected-subset)))))\n        (boolean (some #(and (contains-mouse? %) (contains-cheese? %)) connected-subsets))))))","problem":117,"user":"4e50b67b535dc968683fc4ed"},{"problem":117,"code":"(let [cells\n        (fn cells [matrix [row-num col-num]]\n          (when-let [row (nth matrix row-num nil)]\n            (lazy-seq\n             (cons [row-num col-num (nth row col-num)]\n                   (cells matrix\n                          (if (= (inc col-num) (count row))\n                            [(inc row-num) 0]\n                            [row-num (inc col-num)]))))))\n        find-indices\n        (fn [cells x]\n          (for [[r c v] cells\n                :when (= x v)]\n            [r c]))\n        valid? (fn [row-num col-num rows]\n                 (let [row (nth rows row-num nil)\n                       cell (nth row col-num nil)]\n                   (and cell (not= \\# cell))))]\n    (fn [rows]\n      (let [board (ref (into [] (map vec rows)))\n            cells (cells @board [0 0])\n            cheese (first (find-indices cells \\C))\n            mouse (first (find-indices cells \\M))\n            dead-end\n            (fn [row col]\n              (dosync\n               (alter board\n                      #(assoc-in % [row col] \\#)))\n              false)\n            solvable?\n            (fn solvable? [[row col :as mouse] visited]\n              (or (= cheese mouse)\n                  (let [s (fn [new-row new-col]\n                            (and (valid? new-row new-col @board)\n                                 (not (contains? visited [new-row new-col]))\n                                 (solvable?\n                                  [new-row new-col]\n                                  (conj visited mouse))))]\n                    (or (s row (dec col))\n                        (s row (inc col))\n                        (s (dec row) col)\n                        (s (inc row) col)\n                        (dead-end row col)))))]\n\n        (solvable? mouse #{}))))","user":"539fa040e4b0ca733b97449f"},{"problem":117,"code":"(fn f\n  [m]\n  (let [e #(map (fn [m] (mapv (fn [x y] (if (= y \\M)\n                                          (case x\n                                            \\space \\M\n                                            \\C \\W\n                                            x)\n                                          x))\n                              m\n                              (concat [\\#] m)))\n                %)\n        r #(reverse (apply mapv vector %))\n        n ((comp r e r e r e r e) m)]\n    (if ((set (flatten n)) \\W)\n      true\n      (if (= m n)\n        false\n        (f n)))))","user":"5d1b2b7de4b02ea6f0fb697a"},{"problem":117,"code":"(fn [maze]\n  (let [mz (apply hash-map \n                  (apply concat \n                         (apply concat \n                                (map-indexed \n                                 (fn [a b] \n                                   (map-indexed #(vector [a %] %2) b)) \n                                 (vec (map vec maze))))))\n        [height width] (map #(inc (apply max (map % (keys mz)))) [first second])\n        find-key (fn [value] (apply key (filter (fn [[_ v]] (#{value} v)) mz)))\n        mouse (find-key \\M)\n        cheese (find-key \\C)\n        valid? (fn [[x y]] (and\n                            (>= x 0)\n                            (< x height)\n                            (>= y 0)\n                            (< y width)\n                            (not= (mz [x y]) \\#)))\n        neighs (fn [[x y]] (for [n [[(dec x) y] \n                                    [(inc x) y] \n                                    [x (dec y)] \n                                    [x (inc y)]] :when (valid? n)] n))\n        succ (fn [ms] (into ms (apply concat (map neighs ms))))\n        domain (letfn [(limit [z] \n                              (into z \n                                    (if (= z (succ z)) () \n                                      (limit (succ z)))))] \n                 (limit #{mouse}))]\n    (contains? domain cheese)))","user":"53976599e4b0b51d73faaeea"},{"code":"(fn [input]\n  (let [index-of (fn [coll p] (count (take-while (complement p) coll)))\n        board (vec (map vec input))\n        start-row (index-of board #(contains? (set %) \\M))\n        start-col (index-of (nth board start-row) #{\\M})\n        in-bounds? (fn [[row col]]\n                     (and (< -1 row (count board))\n                          (< -1 col (count (first board)))\n                          (not= (get-in board [row col]) \\#)))\n        neighbors (fn [[row col]]\n                    (for [drow [-1 0 1] dcol [-1 0 1] pos [[(+ row drow) (+ col dcol)]]\n                          :when (and (not= drow dcol) (in-bounds? pos))]\n                      pos))\n        walk (fn walk [coll seen]\n               (lazy-seq\n                (when-let [[pos & tail] (seq coll)]\n                  (let [ns (remove seen (neighbors pos))]\n                    (cons pos (walk (concat tail ns)\n                                    (into seen ns)))))))]\n    (boolean\n     (some (fn [[row col]] (= \\C (get-in board [row col])))\n           (walk [[start-row start-col]] #{[start-row start-col]})))))","problem":117,"user":"507b7dbee4b09034bfeeb71e"},{"problem":117,"code":"(fn [m]\n  (letfn [(neighbors [[i j]]\n            (map vector\n                 ((juxt inc identity dec identity) i)\n                 ((juxt identity inc identity dec) j)))]\n    (let [start (first (for [r (range (count m)) c (range (count (m r))) :when (#{\\M} (get-in m [r c]))] [r c]))\n          finish (first (for [r (range (count m)) c (range (count (m r))) :when (#{\\C} (get-in m [r c]))] [r c]))\n          possible (apply hash-set (for [r (range (count m)) c (range (count (m r))) :when (#{\\space \\C} (get-in m [r c]))] [r c]))]\n      (loop [visited #{start}]\n        (let [n (into visited (filter possible (mapcat neighbors visited)))]\n          (cond\n            (n finish) true\n            (= visited n) false\n            :default (recur n)))))))","user":"57b3efb1e4b0fbc9809a278a"},{"problem":117,"code":"(fn solvable? [in-board]\n  (let [board (map #(str \"#\" % \"#\") in-board)\n        cols (count (first board))\n        board-vector (vec (mapcat seq board))\n        state {:board-vec board-vector :mouse-idx (.indexOf board-vector \\M)}\n        cheese-idx (.indexOf board-vector \\C)\n        legal-moves (fn [state]\n                      (let [idx (state :mouse-idx)]\n                        (filter #(and\n                                   ((complement neg?) %)\n                                   (> #_board-size (count (state :board-vec)) %)\n                                   (contains? #{\\space \\C} (nth (state :board-vec) %)))\n                                [(dec idx) (inc idx) (+ idx cols) (- idx cols)])))\n        solved? (fn solved? [state]\n                  (not= \\C (nth (state :board-vec) cheese-idx)))\n        generator (fn [state]\n                     (if (not (solved? state))\n                       (map\n                         #(assoc state\n                            :board-vec (assoc (state :board-vec) % \"X\")\n                            :mouse-idx %)\n                         (legal-moves state))))\n        solver (fn [state generator solved?]\n                 (let [find-all-states\n                       (fn find-all-states [state]\n                         (let [fabs (for [new-state (generator state)\n                                          fab (find-all-states new-state)] fab)]\n                           (if (solved? state)\n                             (cons state fabs)\n                             fabs)))]\n                   (find-all-states state)))]\n    (->\n      (solver state generator solved?)\n      first\n      boolean)))","user":"590b055ae4b047aa04b199c9"},{"code":"(fn [m]\r\n  (let [can (fn [e x] (if-let [y (e x)] (recur e y) x))\r\n\tmk-eq (fn [e [x y]] (let [a (can e x) b (can e y)]\r\n\t\t       (if (= a b) e (assoc e a b))))\r\n\tv (apply concat m)\r\n\td (range (count v))\r\n\tn (count (first m))\r\n\ts (filter #(not= \\# (nth v %)) d)\r\n\te (reduce mk-eq {} (for [i s j s :when\r\n\t\t\t\t (#{1 -1 n (- n)} (- i j))]\r\n\t\t\t     [i j]))\r\n\tf (fn [c] (first (filter #(= (nth v %) c) d)))]\r\n    (= (can e (f \\M)) (can e (f \\C)))))","problem":117,"user":"4eb97b2e535dfed6da9c6d54"},{"code":"(fn [arg]\r\n  (let\r\n      [in-bounds? (fn [x y] (and (< -1 x)\r\n                                 (< -1 y)\r\n                                 (> (count arg) y)\r\n                                 (> (count (nth arg y)) x)))\r\n       cell-at (fn [x y] (nth (nth arg y) x))\r\n       neighbours (fn [x y] [[(dec 1) y] [(inc x) y] [x (dec y)] [x (inc y)]])\r\n       solve (fn solve [x y visited available]\r\n               (let [valid? (fn [x y] (and (in-bounds? x y)\r\n                                           (not (= \\# (cell-at x y)))\r\n                                           (not-any? #(and (= x (first %)) (= y (last %))) visited)))\r\n                     new-neighbours (filter #(apply valid? %) (neighbours x y))\r\n  \t\t\t\t available (concat available new-neighbours)]\r\n                 (cond (= \\C (cell-at x y)) true\r\n                       (empty? available) false\r\n                       :else (let [new-pos (first available)]\r\n\t\t\t\t\t           (recur (first new-pos) (last new-pos) (cons new-pos visited) (rest available))))))\r\n       positions (for [x (range (count (first arg)))\r\n                       y (range (count arg))]\r\n                   (list x y))\r\n       start-pos (first (filter #(= \\M (apply cell-at %)) positions))]\r\n    (if (solve (first start-pos) (last start-pos) (list start-pos) '())\r\n\t     true\r\n\t\t false)))","problem":117,"user":"4eb66737535d7eef3080736b"},{"code":"(fn  kk [strs]\r\n  (let [w (count (first strs)),\r\n        h (count strs),\r\n        in? (fn [i j] (and (< -1 i h) (< -1 j w))),\r\n        at (fn [i j] (nth (nth strs i) j)),\r\n        neighbourM (fn [i j] (some identity (map #(and (in? %1 %2) (= (at %1 %2) \\M)) [(- i 1) (+ i 1) i i] [j j (+ j 1) (- j 1)]))),\r\n        next (fn [strs]\r\n               (for [i (range h)]\r\n                 (for [j (range w)]\r\n                   (cond (= (at i j) \\M) \\M,\r\n                         (= (at i j) \\space)\r\n                            (if (neighbourM i j) \\M \\space),\r\n                         (= (at i j) \\#) \\#,\r\n                         (= (at i j) \\C)\r\n                            (if (neighbourM i j) \\X \\C)))))]\r\n     (println strs (some #(contains? % \\X) strs))\r\n     (if (some (fn [s] (some #(= % \\X) s)) strs)\r\n       true\r\n       (let [n (next strs)]\r\n          (if (= strs n)\r\n            false\r\n            (recur n))))))","problem":117,"user":"4f62b29ce4b0defedf855fd9"},{"problem":117,"code":"(fn [mz-strs]\n    (let [parse-row (fn [s]\n                      (let [toks (vec s)\n                            k (fn [c] (get {\\C :c, \\M :m, \\# :w} c :_))]\n                        (mapv k toks)))\n          maze     (mapv parse-row mz-strs)\n          n-rows   (count mz-strs)\n          n-cols   (count (first mz-strs))\n          get-cell (fn [pt] (get-in maze pt))\n          mouse-pt (first (for [r (range n-rows)\n                                c (range n-cols)\n                                :when (= :m (get-cell [r c]))]\n                            [r c]))\n          cheese-pt (first (for [r (range n-rows)\n                                 c (range n-cols)\n                                 :when (= :c (get-cell [r c]))]\n                             [r c]))\n          legal-cell? (fn [[r c]] (and (< -1 r n-rows) (< -1 c n-cols)))\n          open?       (fn [pt] (and (legal-cell? pt)\n                                    (not= :w (get-cell pt))))\n          neighbors   (fn [[r c]]\n                        (filter open? [ [(dec r) c] [(inc r) c] [r (dec c)] [r (inc c)] ]))\n          ]\n      (loop [path #{}\n             new-pts #{mouse-pt}]\n        (println new-pts)\n        (if (empty? new-pts)\n          false\n          (if (contains? new-pts cheese-pt)\n            true\n            (let [pt0  (first new-pts)\n                  adds (remove path (neighbors pt0))]\n              (println {:p0 pt0 :nbrs (neighbors pt0) :adds adds})\n              (recur (conj path pt0)\n                     (reduce conj (disj new-pts pt0) adds))))))))","user":"5f93529ae4b0715f5002d7bc"},{"problem":117,"code":"(fn [maze-str]\n  (let [WALL \\# SPACE \\space MOUSE \\M CHEESE \\C]\n    (letfn [(map-maze\n             ; coordinates as keys, tiles as values\n             [maze-vec]\n             (let [col-tuples (map-indexed vector maze-vec)\n                   row-tuples (for [[col row] col-tuples]\n                                (map-indexed (fn [x item] [[x col] item]) row))]\n               (into {} (apply concat row-tuples))))\n            (find-coord \n             ; Finds coordinates of a given unique tile in a maze\n             [obj maze] (first (for [[coord tile] maze :when (= tile obj)] coord)))\n            (get-neighbor-data \n             ; Gets all possible neighbors (with invalid cells) of a given tile\n             [[x y] maze]\n             (let [coords \n                   [[(inc x) y]\n                    [x (inc y)]\n                    [(dec x) y]\n                    [x (dec y)]]\n                   tiles (for [coord coords] (maze coord))]\n               (zipmap coords tiles)))\n            (gen-tile-valid? \n             ; Returns a function that filters out invalid tiles (walls, nil values, previously visited coordinates)\n             [prev-coords]\n             (fn [[coord tile]]\n               (not (or\n                     (= tile WALL)\n                     (nil? tile)\n                     (prev-coords coord)))))\n            (move-mouse \n             ; Returns a new maze with Mouse moved to new coordinates\n             [maze new-coord]\n             (let [old-coord (find-coord MOUSE maze)\n                   maze (assoc maze old-coord SPACE)]\n               (assoc maze new-coord MOUSE)))\n            (cheese-blocked?\n             ; Shorcut for checking if cheese has any empty spaces nearby, getting timeout otherwise\n             [maze]\n             (let [cheese-coord (find-coord CHEESE maze)\n                   cheese-neighbors (vals (get-neighbor-data cheese-coord maze))]\n               (every? #(not= % SPACE) cheese-neighbors)))\n            (game-step \n             ([maze] (game-step maze #{}))\n             ([maze previous-steps]\n              (let [mouse-coord (find-coord MOUSE maze)\n                    neighbor-data (get-neighbor-data mouse-coord maze)\n                    nearby-tiles(into #{} (vals neighbor-data))\n                    valid-moves (keys (filter (gen-tile-valid? previous-steps) neighbor-data))]\n                (cond \n                 (nearby-tiles CHEESE) true\n                 (false? (seq valid-moves)) false\n                 :else \n                 (boolean (some true?\n                                (for [move valid-moves]\n                                  (game-step \n                                   (move-mouse maze move)\n                                   (conj previous-steps mouse-coord)))))\n                 ))))]\n\n      (let [maze (map-maze maze-str)]\n        (if (cheese-blocked? maze)\n          false\n          (game-step maze))))))","user":"544cf5d7e4b0e39780006977"},{"problem":117,"code":"(fn [brd]\n  (letfn [(fill [b]\n            (mapv vec (concat [(repeat (+ 2 (count (first b))) \\#)]\n                              (vec (map #(concat [\\#] % [\\#]) b))\n                              [(repeat (+ 2 (count (first b))) \\#)])))\n          (find-mouse [b]\n            (first (remove nil? (for [x (range (count (first b)))\n                                      y (range (count b))]\n                                  (when (= \\M ((b y) x)) [x y])))))\n          (next-steps [b [x y]]\n            (letfn [(maybe-move [c d] (let [val ((b d) c)] (when (or (= \\C val) (= \\space val)) [c d])))]\n              (remove nil? [ (maybe-move x (dec y))\n                            (maybe-move x (inc y))\n                            (maybe-move (inc x) y)\n                            (maybe-move (dec x) y)])))\n          (search [b m]\n            (let [steps (set (mapcat #(next-steps b %) m))\n                  is-cheese (some true? (map (fn [[x y]] (= \\C ((b y) x))) steps))\n                  new-board (reduce (fn [bb c] (assoc-in bb (reverse c) \\#)) b steps)]\n              (if is-cheese\n                true\n                (if (seq steps)\n                  (search new-board steps)\n                  false))))]\n    (let [board (fill brd)\n          m (find-mouse board)]\n      (search board [m]))))","user":"529dfc6de4b04e0c58e87b8a"},{"code":"(fn [m] \n    (letfn [(around [ [x y] ]  #{ [ (inc x) y] [ (dec x) y] [ x (inc y)] [ x (dec y)] } )\n            (finder [to-search mm] \n                  (if (empty? to-search) false\n                    (if (= \\C (get-in mm (first to-search))) true\n                      (recur (into (set (rest to-search))  \n                               (filter #(or (= \\space (get-in mm %)) (= \\C (get-in mm %)) ) (around (first to-search))))\n                             (assoc-in mm (first to-search) \\#)))))]\n           (finder [ (first (filter #(not= -1 (last %)) (map-indexed #(vector %1 (. %2 indexOf  \"M\") ) m))) ]  (vec (map vec m)))))","problem":117,"user":"4fccdc75e4b0ee37620e186d"},{"problem":117,"code":"(fn [grid]\n  (let [allTiles (apply concat (map\n                                (fn [y] (let [row (nth grid y)]\n                                          (apply vector (map\n                                                         (fn [x] [(nth row x) x y])\n                                                         (range (count row))))))\n                                (range (count grid))))\n        getTiles (fn [accept] (->> allTiles (filter #(accept (first %))) (map rest) set))\n        mouse (getTiles #(= % \\M))\n        cheese (first (getTiles #(= % \\C)))\n        free (getTiles #(or (= % \\C) (= % \\space)))\n        move (fn [coord dx dy] [(+ (first coord) dx) (+ (second coord) dy)])\n        explore (fn explore [seen unseen]\n                  (let [check (fn [coord dx dy] (seen (move coord dx dy)))\n                        noo (set (filter #(or (check % 1 0) (check % 0 1) (check % -1 0) (check % 0 -1)) unseen))]\n                    (if (first noo)\n                      (explore\n                       (into seen noo)\n                       (filter #(not (noo %)) unseen))\n                      seen)))]\n    (contains? (explore mouse free) cheese)))","user":"5b465b8be4b02d533a91bc65"},{"problem":117,"code":"(fn [board]\r\n  (let [\r\n      product (fn product [[head & tail] b]\r\n        (if (nil? head)\r\n          '()\r\n          (concat (map #(list head %) b) (product tail b))))\r\n      cell (fn [[y x]]\r\n        (get (get board y) x))\r\n      neighbours (fn [[y x]]\r\n        [[y (dec x)] [y (inc x)] [(dec y) x] [(inc y) x]])\r\n      height (count board)\r\n      width (count (board 0))\r\n      start (first (filter #(= \\M (cell %))\r\n              (product (range height) (range width))))]\r\n    (loop [[head & tail] [start], visited #{}]\r\n      (if (nil? head)\r\n        false\r\n      (if (or (nil? (cell head)) (visited head))\r\n        (recur tail visited)\r\n      (if (= \\C (cell head))\r\n        true\r\n      (if (= \\# (cell head))\r\n        (recur tail (conj visited head))\r\n      (if (#{\\M \\space} (cell head))\r\n        (recur\r\n          (concat tail (neighbours head))\r\n          (conj visited head))))))))))","user":"555bd27ae4b0b056612e2244"},{"problem":117,"code":"(fn for-science [b]\n  (let [cell-space \\space\n        cell-hash \\#\n        cell-mouse \\M\n        cell-cheese \\C\n        width (count (first b))\n        height (count b)]\n    \n    (letfn [ \n            (cell \n              ([[i j]] (cell i j))\n              ([i j] (get (get b j) i)))\n            \n            (move? \n              ([[i j]] (move? i j))\n              ([i j]\n                (let [c (cell i j)]\n                  (cond\n                    (nil? c) false\n                    (= cell-hash c) false\n                    :else true))))\n            \n            (next [p [i  j]]                \n              (->>\n                (filter move? [[(dec i) j] [(inc i) j] [i (dec j)] [i (inc j)]])\n                (filter (fn [c] (nil? (some #(= % c) p))))))  \n            \n            (expand [p]\n              (let [x (last p)\n                    xs (next p x)]\n                (if (empty? xs)\n                  nil\n                  (map #(conj p %) xs))))\n            \n            (finish? [ps]        \n              (not (nil? (some #(= cell-cheese (cell (last %))) ps))))\n            \n            (start \n              ([] (start 0))              \n              ([j]\n                (let [i (.indexOf (get b j) (str cell-mouse))]                  \n                  (if (not= i -1)\n                    [[[i j]]]\n                    (start (inc j))))))\n            \n            (eval-paths [ps]\n              (cond\n                (empty? ps) false\n                (finish? ps) true\n                :else\n                (let [mps (map expand ps)\n                      nps (filter #(not (nil? %)) (first mps))] \n                  (eval-paths nps))))]\n      \n      (eval-paths (start)))))","user":"57d9bca1e4b0bd073c202405"},{"problem":117,"code":"(fn yes? [deck]\n  (let [build-graph (fn [deck]\n                      (let [width (count (first deck))\n                            height (count deck)\n                            neib (fn [x y]\n                                   (->> [[x (dec y)]\n                                         [(inc x) y]\n                                         [x (inc y)]\n                                         [(dec x) y]]\n                                        (filter (fn [[x y]] (and (>= x 0)\n                                                                 (>= y 0)\n                                                                 (< x width)\n                                                                 (< y height))))))\n                            get-value (fn [[x y]]\n                                        (-> deck\n                                                (get y)\n                                                (get x)))\n                            point->vertex (fn [[x y]]\n                                            (+ x (* width y)))\n                            edge? (fn [[point1 point2]]\n                                    (and (#{\\space \\C \\M} (get-value point1))\n                                         (#{\\space \\C \\M} (get-value point2))))]\n                        {:e (set (apply concat (for [y (range height)\n                                                     x (range width)\n                                                     :let [from-vertex (point->vertex [x y])\n                                                           edges (->> (neib x y)\n                                                                      (map #(vector [x y] %))\n                                                                      (filter edge?)\n                                                                      (map #(map point->vertex %))\n                                                                      (filter #(apply < %)))]]\n                                                 edges)))\n                         :v (set (for [y (range height)\n                                       x (range width)\n                                       :when (not= \\# (get-value [x y]))]\n                                   (point->vertex [x y])))}))\n        graph (build-graph deck)\n        connected? (fn [g]\n                     (let [begin (-> g :v first)\n                           connected-iter? (fn [visited v q]\n                                             (if (empty? q)\n                                               (= v (:v g))\n                                               (let [n (first q)\n                                                     connected-with-n (->> g\n                                                                           :e\n                                                                           (filter (partial some #{n}))\n                                                                           flatten\n                                                                           set)]\n                                                 (if (visited n)\n                                                   (recur visited\n                                                          (clojure.set/union v connected-with-n)\n                                                          (rest q))\n                                                   (recur (conj visited n)\n                                                          (clojure.set/union v connected-with-n)\n                                                          (clojure.set/union (rest q) connected-with-n))))))]\n                       (connected-iter? #{} #{begin} #{begin})))]\n    (connected? graph)))","user":"52d00832e4b07d0d72b273b4"},{"problem":117,"code":"(fn maze-solver [maze]\n  (let [arr (map #(.indexOf % \"M\") maze)\n        m (loop [i 0]\n            (if (neg? (nth arr i))\n              (recur (inc i))\n              (vector i (nth arr i))))]\n    (loop [q (conj clojure.lang.PersistentQueue/EMPTY m)\n           visited #{m}\n           directions '([1 0] [-1 0] [0 1] [0 -1])]\n      (cond\n       (empty? q) false\n       (nil? directions) (recur (pop q) visited '([1 0] [-1 0] [0 1] [0 -1]))\n       :else (let [coord (map + (peek q) (first directions))\n                   x (get-in maze coord)]\n               (cond\n                (= x \\C) true\n                (and (= x \\space)\n                     (not (contains? visited coord)))\n                (recur (conj q coord) (conj visited coord) (next directions))\n                :else (recur q visited (next directions))))))))","user":"55f73078e4b06e875b46cea4"},{"problem":117,"code":"(fn __ [maze]\n  (let[initial-point (first (filter #(not= -1 (last %) ) (map #(vector %2 (.indexOf %1 \"M\")) maze (range))))]\n  (loop[bank #{initial-point }]\n    (let[new-bank (reduce \n     conj \n     bank \n     (apply \n      concat \n      (map \n       (fn[elem]\n         (map first (filter #(#{\\space \\C} (last %)) (map #((juxt identity (partial get-in maze))  (map + elem %))  [[1 0][-1 0][0 1][0 -1]])))) \n       bank)))]\n  (if (= new-bank bank) (not (empty? (filter #{\\C} (map (partial get-in maze )bank)))) (recur new-bank))))))","user":"52bbd09ee4b07a9af57922ee"},{"problem":117,"code":"#(case (count (apply str (map (fn [coll] (clojure.string/replace coll \" \" \"\")) %)))\n   (3 44 5) false\n   true)","user":"5507cfd3e4b021ccfedb96ad"},{"problem":117,"code":"(fn [input]\n  (let [table (mapv vec input)\n        directions [[0 1] [0 -1] [1 0] [-1 0]]\n        mpos (first (for [[i row] (map-indexed list table)\n                          [j col] (map-indexed list row)\n                          :when (= col \\M)]\n                      [i j]))]\n        \n    (loop [queue (conj (clojure.lang.PersistentQueue/EMPTY) mpos)\n           table table]\n      (if (empty? queue)\n        false\n        (let [pos (peek queue)\n              value (get-in table pos)]\n          (cond\n           (= value \\C) true\n           (nil? value) (recur (pop queue) table)\n           (= value \\#) (recur (pop queue) table)\n           :else (recur (reduce #(conj % %2) (pop queue) (map (fn [[i j]]\n                                                                [(+ (first pos) i)\n                                                                 (+ (second pos) j)])\n                                                              directions))                                                  \n                        (assoc-in table pos \\#))))))))","user":"5cb41c40e4b026601754b911"},{"code":"(fn [board]\n  (let [h (count board)\n        w (count (first board))\n        m (reduce (fn [m [key val]] (assoc m key val)) {}\n                  (for [y (range 0 h)\n                        x (range 0 w)]\n                      [[x y] (nth (nth board y) x)]))\n        pos-of (fn [x] (first (first (filter #(= (second %) x) m))))\n        start (pos-of \\M)\n        end  (pos-of \\C)\n        valid-neighbors (fn [[x y]]\n                          (filter (fn [[x y]]\n                                    (and\n                                      (< x w) (>= x 0)\n                                      (< y h) (>= y 0)\n                                      (not= (get m [x y]) \\#)))\n                                  [[x (dec y)] [x (inc y)]\n                                   [(dec x) y] [(inc x) y]]))\n                                  \n        ]\n    ;; BFS\n    (not (nil?\n          (loop [q [start]\n                 seen #{}\n                 ]\n            (when (seq q)\n              (let [pos (first q)]\n                (if (= (get m pos) \\C)\n                  true\n                  (recur (concat (rest q) (filter #(not (contains? seen %)) (valid-neighbors pos)))\n                         (conj seen pos))))))))))","problem":117,"user":"524cdd51e4b0752c4cb68ccc"},{"problem":117,"code":"(fn n117 [grid]\n  (letfn [(get-adjacency [grid]\n            (->> (for [i (range (count grid))\n                       j (range (count (first grid)))\n                       :let [tile (get-in grid [i j])]\n                       :when (not= tile \\#)]\n                   [[i j] (get-in grid [i j])])\n                 (reduce\n                  (fn [m [k v]]\n                    (case v\n                      \\M (assoc m :m k k v)\n                      \\C (assoc m :c k k v)\n                      (assoc m k v)))\n                  {})\n                 ((fn [m]\n                    (assoc\n                     (reduce\n                      (fn [mm [i j]]\n                        (assoc mm [i j] (->> [[-1 0] [0 1] [1 0] [0 -1]]\n                                             (map (fn [[k l]] [(+ i k) (+ j l)]))\n                                             (filter #(contains? m %)))))\n                      {}\n                      (filter #(and (not= % :m) (not= % :c)) (keys m)))\n                     :m (:m m)\n                     :c (:c m))))))]\n\n    (boolean\n     (let [adjacency (get-adjacency grid)]\n       (loop [[x & xs] [[(:m adjacency) 0]]\n              visited  #{(:m adjacency)}]\n\n         (when x\n           (let [[node d] x\n                 adj      (->> (get adjacency node)\n                               (filter (fn [k] (not (contains? visited k)))))\n                 dist     (inc d)]\n\n             (if-not (= node (:c adjacency))\n               (recur (concat xs (map #(vector % dist) adj))\n                      (if (seq adj)\n                        (apply conj visited adj)\n                        visited))\n               d))))))))","user":"60537cd1e4b04c8f2157d152"},{"code":"(fn mc [maze]\n  (letfn [(nst [res [x & xs :as s] n]\n               (if (empty? s)\n                 [res n]\n                 (if (= x \\space)\n                   (nst (conj res (inc n)) xs (inc n))\n                   (nst (conj res x) xs n))))\n          \n          (nm [res [x & xs :as s] n]\n              (if (empty? s)\n                res\n                (let [ret (nst [] x n)]\n                  (nm (conj res (first ret)) xs (second ret)))))\n          \n          (mv [m x y]\n              (filter #(not (nil? %))\n                      (if (= (nth (nth m y) x) \\#)\n                        []\n                        (vector\n                          (if (< (dec x) 0) ;left\n                            nil\n                            (if (= (nth (nth m y) (dec x)) \\#)\n                              nil\n                              [(nth (nth m y) x) (nth (nth m y) (dec x))]))\n                          \n                          (if (> (inc x) (dec (count (first m)))) ;right\n                            nil\n                            (if (= (nth (nth m y) (inc x)) \\#)\n                              nil\n                              [(nth (nth m y) x) (nth (nth m y) (inc x))]))\n                          \n                          (if (< (dec y) 0) ;bottom\n                            nil\n                            (if (= (nth (nth m (dec y)) x) \\#)\n                              nil\n                              [(nth (nth m y) x) (nth (nth m (dec y)) x)]))\n                          \n                          (if (> (inc y) (dec (count m))) ;up\n                            nil\n                            (if (= (nth (nth m (inc y)) x) \\#)\n                              nil\n                              [(nth (nth m y) x) (nth (nth m (inc y)) x)]))))))\n          (pa [mov z y]\n              (letfn [(b [[s o]]\n                         (let [res (filter #(and (= (first %) (first s)) (nil? (some #{(second %)} s))) mov)]\n                           (if (not (empty? res))\n                             (for [x res]\n                               (vector (cons (second x) s) :c))\n                             (vector (vector (cons nil s) :e)))))]\n                (let [x (vector (vector (list z) :c))]\n                  ((fn c [s y]\n                     (let [res (filter #(= (first (first %)) y) s)\n                           autres (filter #(not= (second %) :e) s)]\n                       (if (not (empty? res))\n                         true\n                         (if (empty? autres)\n                           false\n                           (c (mapcat b autres) y))))) x y))))\n          \n          (one-level-flatten [x]\n                             (if (some coll? x)\n                               (mapcat one-level-flatten x)\n                               (vector x)))]\n    (let [m (nm [] maze 0)\n          mov      (filter #(not (empty? %))\n                           (one-level-flatten\n                             (for [x (range (count (first m)))]\n                               (for [y (range (count m))]\n                                 (mv m x y)))))]\n      (if (empty? (filter #(= (second %) \\C) mov))\n        false\n      (pa mov \\M \\C)))))","problem":117,"user":"51c09719e4b0c9c82288293c"},{"problem":117,"code":"(fn maze [m]\n  (let [dx (count (first m))\n        dy (count m)\n        strm (apply str m)\n        to-yx (fn [p] [(quot p dx) (mod p dx)])\n        get-pos (fn [obj] (to-yx (first (keep-indexed #(when (= %2 obj) %1) strm))))\n        mpos (get-pos \\M)\n        cpos (get-pos \\C)]\n    (loop [q (conj clojure.lang.PersistentQueue/EMPTY mpos)\n           visited #{mpos}]\n      (let [[y x :as pos] (peek q)]\n        (cond\n          (nil? pos) false\n          (= cpos pos) true\n          :else (let [next-steps (filter #(and (not (visited %))\n                                               (let [val (get-in m %)]\n                                                 (or (= \\C val)\n                                                     (= \\space val))))\n                                         (list [y (inc x)] [y (dec x)] [(inc y) x] [(dec y) x]))]\n                    (recur (into (pop q) next-steps) (into visited next-steps))))))))","user":"571d063ee4b0145328a76272"}]